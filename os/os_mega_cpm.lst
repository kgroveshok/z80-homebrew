# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 43 16			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 1   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0103			  
0103			STORE_0_AUTORUN: equ $20  
0103			  
0103			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0103			  
0103			STORE_0_AUTOFILE: equ $21  
0103			STORE_0_BANKRUN: equ $23  
0103			STORE_0_FILERUN: equ $24  
0103			  
0103			; Block 0 offsets for settings  
0103			  
0103			; if set then skip prompt for start up and accept all  
0103			  
0103			STORE_0_QUICKSTART: equ $25  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0103			  
0103			hardware_config: equ key_face_held - 10  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_config - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			spi_device_id: equ spi_device - 1    ; human readable bank number  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ scratch-2  
0103			os_new_parse_len: equ os_new_malloc - 2  
0103			os_new_word_len: equ os_new_parse_len - 2  
0103			os_new_work_ptr: equ os_new_word_len - 2  
0103			os_new_src_ptr: equ os_new_work_ptr - 2  
0103			os_new_exec: equ os_new_src_ptr - 2  
0103			os_new_exec_ptr: equ os_new_exec - 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ os_new_exec_ptr - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103				  
0103			  
0103					;ld a, 0  
0103					;ld (hardware_diag), a  
0103			  
0103					; clear all the buffers  
0103			  
0103 21 16 ed				ld hl, display_fb1  
0106 22 d2 eb				ld (display_fb_active), hl  
0109			  
0109 cd 97 09				call clear_display  
010c			  
010c 21 d4 eb				ld hl, display_fb2  
010f 22 d2 eb				ld (display_fb_active), hl  
0112			  
0112 cd 97 09				call clear_display  
0115			  
0115					; init primary frame buffer area  
0115 21 b7 ed				ld hl, display_fb0  
0118 22 d2 eb				ld (display_fb_active), hl  
011b			  
011b cd 97 09				call clear_display  
011e			  
011e			  
011e cd 28 58				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0121			  
0121 cd 16 59			call key_init  
0124 cd ab 01			call storage_init  
0127			  
0127				; setup malloc functions  
0127			  
0127				if MALLOC_1  
0127 cd 67 10				call  heap_init  
012a				endif  
012a				if MALLOC_4  
012a					call  heap_init  
012a				endif  
012a			  
012a				; init sound hardware if present  
012a			  
012a				if SOUND_ENABLE  
012a					call sound_init  
012a				endif  
012a			  
012a				; lcd test sequence  
012a					  
012a cd ba 09			call update_display  
012d cd 09 09			call delay1s  
0130 3e 2b			ld a,'+'  
0132 cd 9c 09			call fill_display  
0135 cd ba 09			call update_display  
0138 cd 09 09			call delay1s  
013b 3e 2a			ld a,'*'  
013d cd 9c 09			call fill_display  
0140 cd ba 09			call update_display  
0143 cd 09 09			call delay1s  
0146 3e 2d			ld a,'-'  
0148 cd 9c 09			call fill_display  
014b cd ba 09			call update_display  
014e cd 09 09			call delay1s  
0151			  
0151			; boot splash screen  
0151			if display_cols == 20	  
0151			        ld a, display_row_1    
0151			else  
0151 3e 0a		        ld a, display_row_1 +10   
0153			endif  
0153 11 84 01			ld de, bootmsg  
0156 cd aa 09			call str_at_display  
0159 cd ba 09			call update_display  
015c			  
015c			  
015c cd 09 09			call delay1s  
015f cd 09 09			call delay1s  
0162			if display_cols == 20	  
0162			            LD   A, display_row_3+2  
0162			else  
0162 3e 5c		            LD   A, display_row_3+12  
0164			endif  
0164 11 99 01			ld de, bootmsg1  
0167 cd aa 09			call str_at_display  
016a cd ba 09			call update_display  
016d cd 09 09			call delay1s  
0170 cd 09 09			call delay1s  
0173			  
0173			;	ld a, display_row_4+3  
0173			;	ld de, bootmsg2  
0173			;	call str_at_display  
0173			;	call update_display  
0173			;	call delay1s  
0173			;	call delay1s  
0173			  
0173			; debug mark setup  
0173			  
0173 3e 5f		ld a, '_'  
0175 32 71 ee		ld (debug_mark),a  
0178 32 72 ee		ld (debug_mark+1),a  
017b 32 73 ee		ld (debug_mark+2),a  
017e 3e 00		ld a,0  
0180 32 74 ee		ld (debug_mark+3),a  
0183			  
0183 c9					ret  
0184			  
0184			  
0184 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
0199 .. 00		bootmsg1:	db "by Kevin Groves",0  
01a9			;bootmsg2:	db "Firmware v0.1",0  
01a9			  
01a9			; a 4x20 lcd  
01a9			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01a9			  
01a9			;if display_cols == 20  
01a9			;	include "firmware_lcd_4x20.asm"  
01a9			;endif  
01a9			  
01a9			;if display_cols == 40  
01a9			;	include "firmware_lcd_4x40.asm"  
01a9			;endif  
01a9			  
01a9			;  
01a9			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01a9			; TODO abstract the bit bang video out interface for dual display  
01a9			; TODO wire video out to tx pin on rc2014 bus  
01a9			  
01a9			; must supply cin, and cin_wait for low level hardware abstraction   
01a9			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01a9			; test scancode  
01a9			  
01a9			;;;;;  
01a9			;;;  
01a9			; Moved out to mini and maxi versions  
01a9			;  
01a9			; include "firmware_key_4x4.asm"  
01a9			; using existing 4 wire x 4 resistor array for input  
01a9			;include "firmware_key_4x10.asm"  
01a9			; need to mod the board for 5 rows due to resistor array  
01a9			;include "firmware_key_5x10.asm"  
01a9			  
01a9			; storage hardware interface  
01a9			  
01a9			; use microchip serial eeprom for storage  
01a9			  
01a9			  
01a9			if STORAGE_SE  
01a9				include "firmware_spi.asm"  
01a9				include "firmware_seeprom.asm"  
01a9			else  
01a9			   ; create some stubs for the labels  
01a9 c9			se_readbyte: ret  
01aa c9			se_writebyte: ret  
01ab c9			storage_init: ret  
01ac			  
01ac			endif  
01ac			  
01ac			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01ac			;include "firmware_cf.asm"  
01ac			  
01ac			; load up high level storage hardward abstractions  
01ac			include "firmware_storage.asm"  
01ac			 
01ac			; persisent storage hardware abstraction layer  
01ac			 
01ac			 
01ac			 
01ac			; Block 0 on storage is a config state 
01ac			 
01ac			 
01ac			 
01ac			; TODO add read phy block and write phy block functions 
01ac			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01ac			 
01ac			; Abstraction layer  
01ac			 
01ac			; Logocial block size is same size as physical size - using tape concept 
01ac			 
01ac			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01ac			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01ac			 
01ac			 
01ac			 
01ac			; Filesystem layout (Logical layout) 
01ac			; 
01ac			; Block 0 - Bank config  
01ac			; 
01ac			;      Byte - 0 file id counter 
01ac			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01ac			;      Byte - 3-20 zero terminated bank label 
01ac			; 
01ac			; Block 1 > File storage 
01ac			; 
01ac			;      Byte 0 file id    - block 0 file details 
01ac			;      Byte 1 block id - block 0 is file  
01ac			;            Byte 2-15 - File name 
01ac			; 
01ac			;       - to end of block data 
01ac			; 
01ac			 
01ac			 
01ac			; Read Block 
01ac			; ---------- 
01ac			; 
01ac			; With current bank 
01ac			;  
01ac			; Get block number to read 
01ac			; Load physical blocks starting at start block into buffer 
01ac			 
01ac			; de points to buffer to use 
01ac			; hl holds logical block number  
01ac			 
01ac			storage_read_block: 
01ac			 
01ac				; TODO bank selection 
01ac			 
01ac				; for each of the physical blocks read it into the buffer 
01ac 06 40			ld b, STORE_BLOCK_PHY 
01ae			 
01ae				if DEBUG_STORESE 
01ae d5					push de 
01af				endif 
01af				 
01af			.rl1:    
01af			 
01af				; read physical block at hl into de 
01af			        ; increment hl and de to next read position on exit 
01af			 
01af e5				push hl 
01b0 d5				push de	 
01b1 c5				push bc 
01b2			;	if DEBUG_STORESE 
01b2			;		push af 
01b2			;		ld a, 'R' 
01b2			;		ld (debug_mark),a 
01b2			;		pop af 
01b2			;		CALLMONITOR 
01b2			;	endif 
01b2 cd a9 01			call se_readbyte 
01b5			;	if DEBUG_STORESE 
01b5			;		ld a,(spi_portbyte) 
01b5			;		ld l, a 
01b5			;		push af 
01b5			;		ld a, '1' 
01b5			;		ld (debug_mark),a 
01b5			;		pop af 
01b5			;		CALLMONITOR 
01b5			;	endif 
01b5 c1				pop bc 
01b6 d1				pop de 
01b7 e1				pop hl 
01b8 12				ld (de),a 
01b9 23				inc hl 
01ba 13				inc de 
01bb			 
01bb			;	if DEBUG_STORESE 
01bb			;		push af 
01bb			;		ld a, 'r' 
01bb			;		ld (debug_mark),a 
01bb			;		pop af 
01bb			;		CALLMONITOR 
01bb			;	endif 
01bb			 
01bb 10 f2			djnz .rl1 
01bd			 
01bd				if DEBUG_STORESE 
01bd					DMARK "SRB" 
01bd f5				push af  
01be 3a d2 01			ld a, (.dmark)  
01c1 32 71 ee			ld (debug_mark),a  
01c4 3a d3 01			ld a, (.dmark+1)  
01c7 32 72 ee			ld (debug_mark+1),a  
01ca 3a d4 01			ld a, (.dmark+2)  
01cd 32 73 ee			ld (debug_mark+2),a  
01d0 18 03			jr .pastdmark  
01d2 ..			.dmark: db "SRB"  
01d5 f1			.pastdmark: pop af  
01d6			endm  
# End of macro DMARK
01d6 d1					pop de 
01d7			; 
01d7			;		push af 
01d7			;		ld a, 'R' 
01d7			;		ld (debug_mark),a 
01d7			;		pop af 
01d7					CALLMONITOR 
01d7 cd 6d 14			call break_point_state  
01da				endm  
# End of macro CALLMONITOR
01da				endif 
01da c9				ret	 
01db				 
01db			 
01db			; File Size 
01db			; --------- 
01db			; 
01db			;   hl file id 
01db			; 
01db			;  returns in hl the number of blocks 
01db			 
01db			storage_file_size: 
01db 5d				ld e, l 
01dc 16 00			ld d, 0 
01de 21 40 00			ld hl, STORE_BLOCK_PHY 
01e1					if DEBUG_FORTH_WORDS 
01e1						DMARK "SIZ" 
01e1 f5				push af  
01e2 3a f6 01			ld a, (.dmark)  
01e5 32 71 ee			ld (debug_mark),a  
01e8 3a f7 01			ld a, (.dmark+1)  
01eb 32 72 ee			ld (debug_mark+1),a  
01ee 3a f8 01			ld a, (.dmark+2)  
01f1 32 73 ee			ld (debug_mark+2),a  
01f4 18 03			jr .pastdmark  
01f6 ..			.dmark: db "SIZ"  
01f9 f1			.pastdmark: pop af  
01fa			endm  
# End of macro DMARK
01fa						CALLMONITOR 
01fa cd 6d 14			call break_point_state  
01fd				endm  
# End of macro CALLMONITOR
01fd					endif 
01fd cd d1 04			call storage_findnextid 
0200			 
0200 cd ed 0b			call ishlzero 
0203			;	ld a, l 
0203			;	add h 
0203			;	cp 0 
0203 c8				ret z			; block not found so EOF 
0204			 
0204 11 5c eb			ld de, store_page 
0207 cd ac 01			call storage_read_block 
020a			 
020a 3a 5e eb			ld a, (store_page+2)	 ; get extent count 
020d 6f				ld l, a 
020e 26 00			ld h, 0 
0210 c9			 	ret 
0211			 
0211			 
0211			; Write Block 
0211			; ----------- 
0211			; 
0211			; With current bank 
0211			;  
0211			; Get block number to write 
0211			; Write physical blocks starting at start block from buffer 
0211			  
0211			storage_write_block: 
0211				; TODO bank selection 
0211			 
0211				; for each of the physical blocks read it into the buffer 
0211 06 40			ld b, STORE_BLOCK_PHY 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SWB" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 71 ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 72 ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 73 ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SWB"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c			 
022c					;push af 
022c					;ld a, 'W' 
022c					;ld (debug_mark),a 
022c					;pop af 
022c					CALLMONITOR 
022c cd 6d 14			call break_point_state  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f			 
022f			; might not be working 
022f			;	call se_writepage 
022f			 
022f			;	ret 
022f			; 
022f			 
022f			 
022f			 
022f			.wl1:    
022f			 
022f				; read physical block at hl into de 
022f			        ; increment hl and de to next read position on exit 
022f			 
022f e5				push hl 
0230 d5				push de	 
0231 c5				push bc 
0232 1a				ld a,(de) 
0233				;if DEBUG_STORESE 
0233			;		push af 
0233			;		ld a, 'W' 
0233			;		ld (debug_mark),a 
0233			;		pop af 
0233			;		CALLMONITOR 
0233			;	endif 
0233 cd aa 01			call se_writebyte 
0236			;	call delay250ms 
0236 00				nop 
0237 00				nop 
0238 00				nop 
0239			;	if DEBUG_STORESE 
0239			;		push af 
0239			;		ld a, 'w' 
0239			;		ld (debug_mark),a 
0239			;		pop af 
0239			;		CALLMONITOR 
0239			;	endif 
0239 c1				pop bc 
023a d1				pop de 
023b e1				pop hl 
023c 23				inc hl 
023d 13				inc de 
023e			 
023e			 
023e 10 ef			djnz .wl1 
0240			 
0240				if DEBUG_STORESE 
0240					DMARK "SW2" 
0240 f5				push af  
0241 3a 55 02			ld a, (.dmark)  
0244 32 71 ee			ld (debug_mark),a  
0247 3a 56 02			ld a, (.dmark+1)  
024a 32 72 ee			ld (debug_mark+1),a  
024d 3a 57 02			ld a, (.dmark+2)  
0250 32 73 ee			ld (debug_mark+2),a  
0253 18 03			jr .pastdmark  
0255 ..			.dmark: db "SW2"  
0258 f1			.pastdmark: pop af  
0259			endm  
# End of macro DMARK
0259			 
0259					;push af 
0259					;ld a, 'W' 
0259					;ld (debug_mark),a 
0259					;pop af 
0259					CALLMONITOR 
0259 cd 6d 14			call break_point_state  
025c				endm  
# End of macro CALLMONITOR
025c				endif 
025c c9				ret	 
025d			 
025d			; Init bank 
025d			; --------- 
025d			; 
025d			; With current bank 
025d			; 
025d			; Setup block 0 config 
025d			;     Set 0 file id counter 
025d			;     Set formatted byte pattern 
025d			;     Zero out bank label 
025d			;      
025d			; For every logical block write 0-1 byte as null 
025d			 
025d			storage_get_block_0: 
025d			 
025d				; TODO check presence 
025d			 
025d				; get block 0 config 
025d			 
025d 21 00 00			ld hl, 0 
0260 11 5c eb			ld de, store_page 
0263 cd ac 01			call storage_read_block 
0266			 
0266				if DEBUG_STORESE 
0266					DMARK "SB0" 
0266 f5				push af  
0267 3a 7b 02			ld a, (.dmark)  
026a 32 71 ee			ld (debug_mark),a  
026d 3a 7c 02			ld a, (.dmark+1)  
0270 32 72 ee			ld (debug_mark+1),a  
0273 3a 7d 02			ld a, (.dmark+2)  
0276 32 73 ee			ld (debug_mark+2),a  
0279 18 03			jr .pastdmark  
027b ..			.dmark: db "SB0"  
027e f1			.pastdmark: pop af  
027f			endm  
# End of macro DMARK
027f 11 5c eb				ld de, store_page 
0282			;		push af 
0282			;		ld a, 'i' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282					CALLMONITOR 
0282 cd 6d 14			call break_point_state  
0285				endm  
# End of macro CALLMONITOR
0285				endif 
0285			 
0285				; is this area formatted? 
0285			 
0285			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0285 2a 5d eb			ld hl, (store_page+1) 
0288 3e 80			ld a,0x80 
028a bd				cp l 
028b 20 22			jr nz, .ininotformatted 
028d				; do a double check 
028d 3e 27			ld a, 0x27 
028f bc				cp h 
0290 20 1d			jr nz, .ininotformatted 
0292			 
0292				; formatted then 
0292			 
0292				if DEBUG_STORESE 
0292					DMARK "SB1" 
0292 f5				push af  
0293 3a a7 02			ld a, (.dmark)  
0296 32 71 ee			ld (debug_mark),a  
0299 3a a8 02			ld a, (.dmark+1)  
029c 32 72 ee			ld (debug_mark+1),a  
029f 3a a9 02			ld a, (.dmark+2)  
02a2 32 73 ee			ld (debug_mark+2),a  
02a5 18 03			jr .pastdmark  
02a7 ..			.dmark: db "SB1"  
02aa f1			.pastdmark: pop af  
02ab			endm  
# End of macro DMARK
02ab					;push af 
02ab					;ld a, 'I' 
02ab					;ld (debug_mark),a 
02ab					;pop af 
02ab					CALLMONITOR 
02ab cd 6d 14			call break_point_state  
02ae				endm  
# End of macro CALLMONITOR
02ae				endif 
02ae c9				ret 
02af			 
02af			.ininotformatted: 
02af				; bank not formatted so poke various bits to make sure 
02af			 
02af				if DEBUG_STORESE 
02af					DMARK "SB2" 
02af f5				push af  
02b0 3a c4 02			ld a, (.dmark)  
02b3 32 71 ee			ld (debug_mark),a  
02b6 3a c5 02			ld a, (.dmark+1)  
02b9 32 72 ee			ld (debug_mark+1),a  
02bc 3a c6 02			ld a, (.dmark+2)  
02bf 32 73 ee			ld (debug_mark+2),a  
02c2 18 03			jr .pastdmark  
02c4 ..			.dmark: db "SB2"  
02c7 f1			.pastdmark: pop af  
02c8			endm  
# End of macro DMARK
02c8					;push af 
02c8					;ld a, 'f' 
02c8					;ld (debug_mark),a 
02c8					;pop af 
02c8					CALLMONITOR 
02c8 cd 6d 14			call break_point_state  
02cb				endm  
# End of macro CALLMONITOR
02cb				endif 
02cb			 
02cb cd cc 08			call storage_clear_page 
02ce			 
02ce 21 5c eb			ld hl, store_page 
02d1 3e 00			ld a, 0 
02d3				 
02d3 77				ld (hl),a   ; reset file counter 
02d4			 
02d4 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02d7 22 5d eb		 	ld (store_page+1), hl	 
02da			 
02da				; set default label 
02da			 
02da 21 76 03			ld hl, .defaultbanklabl 
02dd 11 5f eb		 	ld de, store_page+3 
02e0 01 0f 00			ld bc, 15 
02e3 ed b0			ldir 
02e5			 
02e5				; Append the current bank id 
02e5 21 68 eb			ld hl, store_page+3+9 
02e8 3a 41 eb			ld a, (spi_device_id) 
02eb 77				ld (hl), a 
02ec			 
02ec				; save default page 0 
02ec			 
02ec 21 00 00			ld hl, 0 
02ef 11 5c eb			ld de, store_page 
02f2				if DEBUG_STORESE 
02f2					DMARK "SB3" 
02f2 f5				push af  
02f3 3a 07 03			ld a, (.dmark)  
02f6 32 71 ee			ld (debug_mark),a  
02f9 3a 08 03			ld a, (.dmark+1)  
02fc 32 72 ee			ld (debug_mark+1),a  
02ff 3a 09 03			ld a, (.dmark+2)  
0302 32 73 ee			ld (debug_mark+2),a  
0305 18 03			jr .pastdmark  
0307 ..			.dmark: db "SB3"  
030a f1			.pastdmark: pop af  
030b			endm  
# End of macro DMARK
030b			;		push af 
030b			;		ld a, 'F' 
030b			;		ld (debug_mark),a 
030b			;		pop af 
030b					CALLMONITOR 
030b cd 6d 14			call break_point_state  
030e				endm  
# End of macro CALLMONITOR
030e				endif 
030e cd 11 02			call storage_write_block 
0311				if DEBUG_STORESE 
0311					DMARK "SB4" 
0311 f5				push af  
0312 3a 26 03			ld a, (.dmark)  
0315 32 71 ee			ld (debug_mark),a  
0318 3a 27 03			ld a, (.dmark+1)  
031b 32 72 ee			ld (debug_mark+1),a  
031e 3a 28 03			ld a, (.dmark+2)  
0321 32 73 ee			ld (debug_mark+2),a  
0324 18 03			jr .pastdmark  
0326 ..			.dmark: db "SB4"  
0329 f1			.pastdmark: pop af  
032a			endm  
# End of macro DMARK
032a			;		push af 
032a			;		ld a, '>' 
032a			;		ld (debug_mark),a 
032a			;		pop af 
032a					CALLMONITOR 
032a cd 6d 14			call break_point_state  
032d				endm  
# End of macro CALLMONITOR
032d				endif 
032d			 
032d 00				nop 
032e 00				nop 
032f 00				nop 
0330			 
0330				; now set 0 in every page to mark as a free block 
0330			 
0330 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0332 21 40 00			ld hl, STORE_BLOCK_PHY 
0335			 
0335 3e 00		.setmark1:   	ld a,0 
0337 e5					push hl 
0338 c5					push bc 
0339 cd aa 01				call se_writebyte 
033c 3e 0a			ld a, 10 
033e cd ee 08			call aDelayInMS 
0341 23				inc hl 
0342 cd aa 01				call se_writebyte 
0345 3e 0a			ld a, 10 
0347 cd ee 08			call aDelayInMS 
034a 2b				dec hl 
034b c1					pop bc 
034c e1					pop hl 
034d 3e 40				ld a, STORE_BLOCK_PHY 
034f cd c4 0b				call addatohl 
0352 10 e1				djnz .setmark1 
0354			 
0354 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0356 3e 00		.setmark2:   	ld a,0 
0358 e5					push hl 
0359 c5					push bc 
035a cd aa 01				call se_writebyte 
035d 3e 0a			ld a, 10 
035f cd ee 08			call aDelayInMS 
0362 23				inc hl 
0363 cd aa 01				call se_writebyte 
0366 3e 0a			ld a, 10 
0368 cd ee 08			call aDelayInMS 
036b 2b				dec hl 
036c c1					pop bc 
036d e1					pop hl 
036e 3e 40				ld a, STORE_BLOCK_PHY 
0370 cd c4 0b				call addatohl 
0373 10 e1				djnz .setmark2 
0375			 
0375					 
0375			 
0375			 
0375 c9				ret 
0376			 
0376			 
0376			 
0376			 
0376 .. 00		.defaultbanklabl:   db "BankLabel_",0 
0381			 
0381			 
0381			 
0381			; Label Bank 
0381			; ---------- 
0381			; 
0381			; With current bank 
0381			; Read block 0 
0381			; Set label 
0381			; Write block 0 
0381			 
0381			; label str pointer in hl 
0381			 
0381			storage_label:     
0381			 
0381				if DEBUG_STORESE 
0381					DMARK "LBL" 
0381 f5				push af  
0382 3a 96 03			ld a, (.dmark)  
0385 32 71 ee			ld (debug_mark),a  
0388 3a 97 03			ld a, (.dmark+1)  
038b 32 72 ee			ld (debug_mark+1),a  
038e 3a 98 03			ld a, (.dmark+2)  
0391 32 73 ee			ld (debug_mark+2),a  
0394 18 03			jr .pastdmark  
0396 ..			.dmark: db "LBL"  
0399 f1			.pastdmark: pop af  
039a			endm  
# End of macro DMARK
039a					CALLMONITOR 
039a cd 6d 14			call break_point_state  
039d				endm  
# End of macro CALLMONITOR
039d				endif 
039d			 
039d e5				push hl 
039e			 
039e cd 5d 02			call storage_get_block_0 
03a1			 
03a1				; set default label 
03a1			 
03a1 e1				pop hl 
03a2			 
03a2 11 5f eb		 	ld de, store_page+3 
03a5 01 0f 00			ld bc, 15 
03a8				if DEBUG_STORESE 
03a8					DMARK "LB3" 
03a8 f5				push af  
03a9 3a bd 03			ld a, (.dmark)  
03ac 32 71 ee			ld (debug_mark),a  
03af 3a be 03			ld a, (.dmark+1)  
03b2 32 72 ee			ld (debug_mark+1),a  
03b5 3a bf 03			ld a, (.dmark+2)  
03b8 32 73 ee			ld (debug_mark+2),a  
03bb 18 03			jr .pastdmark  
03bd ..			.dmark: db "LB3"  
03c0 f1			.pastdmark: pop af  
03c1			endm  
# End of macro DMARK
03c1					CALLMONITOR 
03c1 cd 6d 14			call break_point_state  
03c4				endm  
# End of macro CALLMONITOR
03c4				endif 
03c4 ed b0			ldir 
03c6				; save default page 0 
03c6			 
03c6 21 00 00			ld hl, 0 
03c9 11 5c eb			ld de, store_page 
03cc				if DEBUG_STORESE 
03cc					DMARK "LBW" 
03cc f5				push af  
03cd 3a e1 03			ld a, (.dmark)  
03d0 32 71 ee			ld (debug_mark),a  
03d3 3a e2 03			ld a, (.dmark+1)  
03d6 32 72 ee			ld (debug_mark+1),a  
03d9 3a e3 03			ld a, (.dmark+2)  
03dc 32 73 ee			ld (debug_mark+2),a  
03df 18 03			jr .pastdmark  
03e1 ..			.dmark: db "LBW"  
03e4 f1			.pastdmark: pop af  
03e5			endm  
# End of macro DMARK
03e5					CALLMONITOR 
03e5 cd 6d 14			call break_point_state  
03e8				endm  
# End of macro CALLMONITOR
03e8				endif 
03e8 cd 11 02			call storage_write_block 
03eb			 
03eb c9				ret 
03ec			 
03ec			 
03ec			 
03ec			; Read Block 0 - Config 
03ec			; --------------------- 
03ec			; 
03ec			; With current bank 
03ec			; Call presence test 
03ec			;    If not present format/init bank  
03ec			; Read block 0  
03ec			;  
03ec			 
03ec			 
03ec			; Dir 
03ec			; --- 
03ec			; 
03ec			; With current bank 
03ec			; Load Block 0 Config 
03ec			; Get max file id number 
03ec			; For each logical block 
03ec			;    Read block read byte 2 
03ec			;      if first block of file 
03ec			;         Display file name 
03ec			;         Display type flags for file 
03ec			;        
03ec			 
03ec			; moving to words as this requires stack control 
03ec			 
03ec			 
03ec			; Delete File 
03ec			; ----------- 
03ec			; 
03ec			; With current bank 
03ec			; 
03ec			; Load Block 0 Config 
03ec			; Get max file id number 
03ec			; For each logical block 
03ec			;    Read block file id 
03ec			;      If first block of file and dont have file id 
03ec			;         if file to delete 
03ec			;         Save file id 
03ec			;         Null file id 
03ec			;         Write this block back 
03ec			;      If file id is one saved 
03ec			;         Null file id 
03ec			;         Write this block back 
03ec			 
03ec			storage_erase: 
03ec			 
03ec				; hl contains the file id 
03ec			 
03ec 5d				ld e, l 
03ed 16 00			ld d, 0 
03ef 21 40 00			ld hl, STORE_BLOCK_PHY 
03f2					if DEBUG_FORTH_WORDS 
03f2						DMARK "ERA" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 71 ee			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 72 ee			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 73 ee			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "ERA"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b						CALLMONITOR 
040b cd 6d 14			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e					endif 
040e cd d1 04			call storage_findnextid 
0411 cd ed 0b			call ishlzero 
0414 c8				ret z 
0415			 
0415 e5				push hl 
0416			 
0416				; TODO check file not found 
0416			 
0416 11 5c eb			ld de, store_page 
0419 cd ac 01			call storage_read_block 
041c			 
041c					if DEBUG_FORTH_WORDS 
041c						DMARK "ER1" 
041c f5				push af  
041d 3a 31 04			ld a, (.dmark)  
0420 32 71 ee			ld (debug_mark),a  
0423 3a 32 04			ld a, (.dmark+1)  
0426 32 72 ee			ld (debug_mark+1),a  
0429 3a 33 04			ld a, (.dmark+2)  
042c 32 73 ee			ld (debug_mark+2),a  
042f 18 03			jr .pastdmark  
0431 ..			.dmark: db "ER1"  
0434 f1			.pastdmark: pop af  
0435			endm  
# End of macro DMARK
0435						CALLMONITOR 
0435 cd 6d 14			call break_point_state  
0438				endm  
# End of macro CALLMONITOR
0438					endif 
0438 3a 5c eb			ld a, (store_page)	; get file id 
043b 32 55 eb			ld (store_tmpid), a 
043e			 
043e 3a 5e eb			ld a, (store_page+2)    ; get count of extends 
0441 32 54 eb			ld (store_tmpext), a 
0444			 
0444				; wipe file header 
0444			 
0444 e1				pop hl 
0445 3e 00			ld a, 0 
0447 32 5c eb			ld (store_page), a 
044a 32 5d eb			ld (store_page+1),a 
044d 11 5c eb			ld de, store_page 
0450					if DEBUG_FORTH_WORDS 
0450						DMARK "ER2" 
0450 f5				push af  
0451 3a 65 04			ld a, (.dmark)  
0454 32 71 ee			ld (debug_mark),a  
0457 3a 66 04			ld a, (.dmark+1)  
045a 32 72 ee			ld (debug_mark+1),a  
045d 3a 67 04			ld a, (.dmark+2)  
0460 32 73 ee			ld (debug_mark+2),a  
0463 18 03			jr .pastdmark  
0465 ..			.dmark: db "ER2"  
0468 f1			.pastdmark: pop af  
0469			endm  
# End of macro DMARK
0469						CALLMONITOR 
0469 cd 6d 14			call break_point_state  
046c				endm  
# End of macro CALLMONITOR
046c					endif 
046c cd 11 02			call storage_write_block 
046f			 
046f			 
046f				; wipe file extents 
046f			 
046f 3a 54 eb			ld a, (store_tmpext) 
0472 47				ld b, a 
0473			 
0473			.eraext:	  
0473 c5				push bc 
0474			 
0474 21 40 00			ld hl, STORE_BLOCK_PHY 
0477 3a 55 eb			ld a,(store_tmpid) 
047a 5f				ld e, a 
047b 50				ld d, b	 
047c					if DEBUG_FORTH_WORDS 
047c						DMARK "ER3" 
047c f5				push af  
047d 3a 91 04			ld a, (.dmark)  
0480 32 71 ee			ld (debug_mark),a  
0483 3a 92 04			ld a, (.dmark+1)  
0486 32 72 ee			ld (debug_mark+1),a  
0489 3a 93 04			ld a, (.dmark+2)  
048c 32 73 ee			ld (debug_mark+2),a  
048f 18 03			jr .pastdmark  
0491 ..			.dmark: db "ER3"  
0494 f1			.pastdmark: pop af  
0495			endm  
# End of macro DMARK
0495						CALLMONITOR 
0495 cd 6d 14			call break_point_state  
0498				endm  
# End of macro CALLMONITOR
0498					endif 
0498 cd d1 04			call storage_findnextid 
049b			 
049b e5				push hl 
049c 11 5c eb			ld de, store_page 
049f cd ac 01			call storage_read_block 
04a2			 
04a2				; free block	 
04a2			 
04a2 3e 00			ld a, 0 
04a4 32 5c eb			ld (store_page), a 
04a7 32 5d eb			ld (store_page+1),a 
04aa 11 5c eb			ld de, store_page 
04ad e1				pop hl 
04ae					if DEBUG_FORTH_WORDS 
04ae						DMARK "ER4" 
04ae f5				push af  
04af 3a c3 04			ld a, (.dmark)  
04b2 32 71 ee			ld (debug_mark),a  
04b5 3a c4 04			ld a, (.dmark+1)  
04b8 32 72 ee			ld (debug_mark+1),a  
04bb 3a c5 04			ld a, (.dmark+2)  
04be 32 73 ee			ld (debug_mark+2),a  
04c1 18 03			jr .pastdmark  
04c3 ..			.dmark: db "ER4"  
04c6 f1			.pastdmark: pop af  
04c7			endm  
# End of macro DMARK
04c7						CALLMONITOR 
04c7 cd 6d 14			call break_point_state  
04ca				endm  
# End of macro CALLMONITOR
04ca					endif 
04ca cd 11 02			call storage_write_block 
04cd			 
04cd c1				pop bc 
04ce 10 a3			djnz .eraext 
04d0			 
04d0 c9				ret 
04d1			 
04d1			 
04d1			; Find Free Block 
04d1			; --------------- 
04d1			; 
04d1			; With current bank 
04d1			;  
04d1			; From given starting logical block 
04d1			;    Read block  
04d1			;    If no file id 
04d1			;         Return block id 
04d1			 
04d1			 
04d1			; hl starting page number 
04d1			; hl contains free page number or zero if no pages free 
04d1			; e contains the file id to locate 
04d1			; d contains the block number 
04d1			 
04d1			; TODO change to find file id and use zero for free block 
04d1			 
04d1			storage_findnextid: 
04d1			 
04d1				; now locate first 0 page to mark as a free block 
04d1			 
04d1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04d3			;	ld hl, STORE_BLOCK_PHY 
04d3			 
04d3					if DEBUG_FORTH_WORDS 
04d3					DMARK "FNI" 
04d3 f5				push af  
04d4 3a e8 04			ld a, (.dmark)  
04d7 32 71 ee			ld (debug_mark),a  
04da 3a e9 04			ld a, (.dmark+1)  
04dd 32 72 ee			ld (debug_mark+1),a  
04e0 3a ea 04			ld a, (.dmark+2)  
04e3 32 73 ee			ld (debug_mark+2),a  
04e6 18 03			jr .pastdmark  
04e8 ..			.dmark: db "FNI"  
04eb f1			.pastdmark: pop af  
04ec			endm  
# End of macro DMARK
04ec						CALLMONITOR 
04ec cd 6d 14			call break_point_state  
04ef				endm  
# End of macro CALLMONITOR
04ef					endif 
04ef			.ff1:   	 
04ef e5					push hl 
04f0 c5					push bc 
04f1 d5					push de 
04f2 cd a9 01				call se_readbyte 
04f5 5f					ld e,a 
04f6 23					inc hl 
04f7 cd a9 01				call se_readbyte 
04fa 57					ld d, a 
04fb e1					pop hl 
04fc e5					push hl 
04fd cd e2 0b				call cmp16 
0500 28 49				jr z, .fffound 
0502			 
0502 d1					pop de 
0503 c1					pop bc 
0504 e1					pop hl 
0505			 
0505					; is found? 
0505					;cp e 
0505					;ret z 
0505			 
0505 3e 40				ld a, STORE_BLOCK_PHY 
0507 cd c4 0b				call addatohl 
050a 10 e3				djnz .ff1 
050c			 
050c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
050e			.ff2:   	 
050e			 
050e e5					push hl 
050f c5					push bc 
0510 d5					push de 
0511 cd a9 01				call se_readbyte 
0514 5f					ld e,a 
0515 23					inc hl 
0516 cd a9 01				call se_readbyte 
0519 57					ld d, a 
051a			 
051a e1					pop hl 
051b e5					push hl 
051c cd e2 0b				call cmp16 
051f 28 2a				jr z, .fffound 
0521			 
0521 d1					pop de 
0522 c1					pop bc 
0523 e1					pop hl 
0524					; is found? 
0524					;cp e 
0524					;ret z 
0524			 
0524 3e 40				ld a, STORE_BLOCK_PHY 
0526 cd c4 0b				call addatohl 
0529 10 e3				djnz .ff2 
052b			 
052b			 
052b					if DEBUG_FORTH_WORDS 
052b					DMARK "FN-" 
052b f5				push af  
052c 3a 40 05			ld a, (.dmark)  
052f 32 71 ee			ld (debug_mark),a  
0532 3a 41 05			ld a, (.dmark+1)  
0535 32 72 ee			ld (debug_mark+1),a  
0538 3a 42 05			ld a, (.dmark+2)  
053b 32 73 ee			ld (debug_mark+2),a  
053e 18 03			jr .pastdmark  
0540 ..			.dmark: db "FN-"  
0543 f1			.pastdmark: pop af  
0544			endm  
# End of macro DMARK
0544					;	push af 
0544					;	ld a, 'n' 
0544					;	ld (debug_mark),a 
0544					;	pop af 
0544						CALLMONITOR 
0544 cd 6d 14			call break_point_state  
0547				endm  
# End of macro CALLMONITOR
0547					endif 
0547				; no free marks! 
0547 21 00 00				ld hl, 0 
054a c9				ret 
054b			.fffound: 
054b				 
054b			 
054b d1					pop de 
054c c1					pop bc 
054d e1					pop hl 
054e					if DEBUG_FORTH_WORDS 
054e					DMARK "FNF" 
054e f5				push af  
054f 3a 63 05			ld a, (.dmark)  
0552 32 71 ee			ld (debug_mark),a  
0555 3a 64 05			ld a, (.dmark+1)  
0558 32 72 ee			ld (debug_mark+1),a  
055b 3a 65 05			ld a, (.dmark+2)  
055e 32 73 ee			ld (debug_mark+2),a  
0561 18 03			jr .pastdmark  
0563 ..			.dmark: db "FNF"  
0566 f1			.pastdmark: pop af  
0567			endm  
# End of macro DMARK
0567					;	push af 
0567					;	ld a, 'n' 
0567					;	ld (debug_mark),a 
0567					;	pop af 
0567						CALLMONITOR 
0567 cd 6d 14			call break_point_state  
056a				endm  
# End of macro CALLMONITOR
056a					endif 
056a c9				ret 
056b			 
056b			 
056b			 
056b			; Free Space 
056b			; ---------- 
056b			; 
056b			; With current bank 
056b			; 
056b			; Set block count to zero 
056b			; Starting with first logical block 
056b			;      Find free block  
056b			;      If block id given, increment block count 
056b			; 
056b			;  
056b			 
056b			 
056b			; hl contains count of free blocks 
056b			 
056b			storage_freeblocks: 
056b			 
056b				; now locate first 0 page to mark as a free block 
056b			 
056b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
056d 21 40 00			ld hl, STORE_BLOCK_PHY 
0570 11 00 00			ld de, 0 
0573			 
0573			.fb1:   	 
0573 e5					push hl 
0574 c5					push bc 
0575 d5					push de 
0576 cd a9 01				call se_readbyte 
0579 d1					pop de 
057a c1					pop bc 
057b e1					pop hl 
057c			 
057c					; is free? 
057c fe 00				cp 0 
057e 20 01				jr nz, .ff1cont 
0580 13					inc de 
0581			 
0581			.ff1cont: 
0581			 
0581			 
0581 3e 40				ld a, STORE_BLOCK_PHY 
0583 cd c4 0b				call addatohl 
0586 10 eb				djnz .fb1 
0588			 
0588 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
058a			.fb2:   	 
058a e5					push hl 
058b c5					push bc 
058c d5					push de 
058d cd a9 01				call se_readbyte 
0590 d1					pop de 
0591 c1					pop bc 
0592 e1					pop hl 
0593			 
0593					; is free? 
0593 fe 00				cp 0 
0595 20 01				jr nz, .ff2cont 
0597 13					inc de 
0598			 
0598			.ff2cont: 
0598			 
0598 3e 40				ld a, STORE_BLOCK_PHY 
059a cd c4 0b				call addatohl 
059d 10 eb				djnz .fb2 
059f			 
059f eb				ex de, hl 
05a0 c9				ret 
05a1			 
05a1			; Get File ID 
05a1			; ----------- 
05a1			; 
05a1			; With current bank 
05a1			;  
05a1			; Load Block 0 Config 
05a1			; Get max file id number 
05a1			; For each logical block 
05a1			;    Read block file id 
05a1			;      If first block of file and dont have file id 
05a1			;         if file get id and exit 
05a1			 
05a1			 
05a1			 
05a1			 
05a1			; Create File 
05a1			; ----------- 
05a1			; 
05a1			; With current bank  
05a1			; Load Block 0 Config 
05a1			; Get max file id number 
05a1			; Increment file id number 
05a1			; Save Config 
05a1			; Find free block 
05a1			; Set buffer with file name and file id 
05a1			; Write buffer to free block  
05a1			 
05a1			 
05a1			; hl point to file name 
05a1			; hl returns file id 
05a1			 
05a1			; file format: 
05a1			; byte 0 - file id 
05a1			; byte 1 - extent number 
05a1			; byte 2-> data 
05a1			 
05a1			; format for extent number 0: 
05a1			; 
05a1			; byte 0 - file id 
05a1			; byte 1 - extent 0 
05a1			; byte 2 - extent count 
05a1			; byte 3 -> file name and meta data 
05a1			 
05a1			 
05a1			storage_create: 
05a1				if DEBUG_STORESE 
05a1					DMARK "SCR" 
05a1 f5				push af  
05a2 3a b6 05			ld a, (.dmark)  
05a5 32 71 ee			ld (debug_mark),a  
05a8 3a b7 05			ld a, (.dmark+1)  
05ab 32 72 ee			ld (debug_mark+1),a  
05ae 3a b8 05			ld a, (.dmark+2)  
05b1 32 73 ee			ld (debug_mark+2),a  
05b4 18 03			jr .pastdmark  
05b6 ..			.dmark: db "SCR"  
05b9 f1			.pastdmark: pop af  
05ba			endm  
# End of macro DMARK
05ba					CALLMONITOR 
05ba cd 6d 14			call break_point_state  
05bd				endm  
# End of macro CALLMONITOR
05bd				endif 
05bd			 
05bd e5				push hl		; save file name pointer 
05be			 
05be cd 5d 02			call storage_get_block_0 
05c1			 
05c1 3a 5c eb			ld a,(store_page)	; get current file id 
05c4 3c				inc a 
05c5 32 5c eb			ld (store_page),a 
05c8				 
05c8 32 55 eb			ld (store_tmpid),a			; save id 
05cb			 
05cb 21 00 00			ld hl, 0 
05ce 11 5c eb			ld de, store_page 
05d1				if DEBUG_STORESE 
05d1					DMARK "SCw" 
05d1 f5				push af  
05d2 3a e6 05			ld a, (.dmark)  
05d5 32 71 ee			ld (debug_mark),a  
05d8 3a e7 05			ld a, (.dmark+1)  
05db 32 72 ee			ld (debug_mark+1),a  
05de 3a e8 05			ld a, (.dmark+2)  
05e1 32 73 ee			ld (debug_mark+2),a  
05e4 18 03			jr .pastdmark  
05e6 ..			.dmark: db "SCw"  
05e9 f1			.pastdmark: pop af  
05ea			endm  
# End of macro DMARK
05ea					CALLMONITOR 
05ea cd 6d 14			call break_point_state  
05ed				endm  
# End of macro CALLMONITOR
05ed				endif 
05ed cd 11 02			call storage_write_block	 ; save update 
05f0			 
05f0				if DEBUG_STORESE 
05f0 11 5c eb				ld de, store_page 
05f3					DMARK "SCC" 
05f3 f5				push af  
05f4 3a 08 06			ld a, (.dmark)  
05f7 32 71 ee			ld (debug_mark),a  
05fa 3a 09 06			ld a, (.dmark+1)  
05fd 32 72 ee			ld (debug_mark+1),a  
0600 3a 0a 06			ld a, (.dmark+2)  
0603 32 73 ee			ld (debug_mark+2),a  
0606 18 03			jr .pastdmark  
0608 ..			.dmark: db "SCC"  
060b f1			.pastdmark: pop af  
060c			endm  
# End of macro DMARK
060c					CALLMONITOR 
060c cd 6d 14			call break_point_state  
060f				endm  
# End of macro CALLMONITOR
060f				endif 
060f				;  
060f				 
060f 21 40 00			ld hl, STORE_BLOCK_PHY 
0612 11 00 00			ld de, 0 
0615 cd d1 04			call storage_findnextid 
0618			 
0618 22 46 eb			ld (store_tmppageid), hl    ; save page to use  
061b			 
061b				; TODO detect 0 = no spare blocks 
061b			 
061b				; hl now contains the free page to use for the file header page 
061b			 
061b				if DEBUG_STORESE 
061b				DMARK "SCF" 
061b f5				push af  
061c 3a 30 06			ld a, (.dmark)  
061f 32 71 ee			ld (debug_mark),a  
0622 3a 31 06			ld a, (.dmark+1)  
0625 32 72 ee			ld (debug_mark+1),a  
0628 3a 32 06			ld a, (.dmark+2)  
062b 32 73 ee			ld (debug_mark+2),a  
062e 18 03			jr .pastdmark  
0630 ..			.dmark: db "SCF"  
0633 f1			.pastdmark: pop af  
0634			endm  
# End of macro DMARK
0634					CALLMONITOR 
0634 cd 6d 14			call break_point_state  
0637				endm  
# End of macro CALLMONITOR
0637				endif 
0637			 
0637 22 46 eb			ld (store_tmppageid), hl 
063a				 
063a 3a 55 eb			ld a,(store_tmpid)    ; get file id 
063d			;	ld a, (store_filecache)			; save to cache 
063d			 
063d 32 5c eb			ld (store_page),a    ; set page id 
0640 3e 00			ld a, 0			 ; extent 0 is file header 
0642 32 5d eb			ld (store_page+1), a   ; set file extent 
0645			 
0645 32 5e eb			ld (store_page+2), a   ; extent count for the file 
0648			 
0648			;	inc hl 		; init block 0 of file 
0648			;	inc hl   		; skip file and extent id 
0648			 ;       ld a, 0 
0648			;	ld (hl),a 
0648			;	ld a, (store_filecache+1)  	; save to cache 
0648			 
0648			;	inc hl    ; file name 
0648				 
0648				 
0648 11 5f eb			ld de, store_page+3    ; get buffer for term string to use as file name 
064b				if DEBUG_STORESE 
064b					DMARK "SCc" 
064b f5				push af  
064c 3a 60 06			ld a, (.dmark)  
064f 32 71 ee			ld (debug_mark),a  
0652 3a 61 06			ld a, (.dmark+1)  
0655 32 72 ee			ld (debug_mark+1),a  
0658 3a 62 06			ld a, (.dmark+2)  
065b 32 73 ee			ld (debug_mark+2),a  
065e 18 03			jr .pastdmark  
0660 ..			.dmark: db "SCc"  
0663 f1			.pastdmark: pop af  
0664			endm  
# End of macro DMARK
0664					CALLMONITOR 
0664 cd 6d 14			call break_point_state  
0667				endm  
# End of macro CALLMONITOR
0667				endif 
0667 e1				pop hl    ; get zero term string 
0668 e5				push hl 
0669 3e 00			ld a, 0 
066b cd 2d 10			call strlent 
066e 23				inc hl   ; cover zero term 
066f 06 00			ld b,0 
0671 4d				ld c,l 
0672 e1				pop hl 
0673				;ex de, hl 
0673				if DEBUG_STORESE 
0673					DMARK "SCa" 
0673 f5				push af  
0674 3a 88 06			ld a, (.dmark)  
0677 32 71 ee			ld (debug_mark),a  
067a 3a 89 06			ld a, (.dmark+1)  
067d 32 72 ee			ld (debug_mark+1),a  
0680 3a 8a 06			ld a, (.dmark+2)  
0683 32 73 ee			ld (debug_mark+2),a  
0686 18 03			jr .pastdmark  
0688 ..			.dmark: db "SCa"  
068b f1			.pastdmark: pop af  
068c			endm  
# End of macro DMARK
068c					;push af 
068c					;ld a, 'a' 
068c					;ld (debug_mark),a 
068c					;pop af 
068c					CALLMONITOR 
068c cd 6d 14			call break_point_state  
068f				endm  
# End of macro CALLMONITOR
068f				endif 
068f ed b0			ldir    ; copy zero term string 
0691				if DEBUG_STORESE 
0691					DMARK "SCA" 
0691 f5				push af  
0692 3a a6 06			ld a, (.dmark)  
0695 32 71 ee			ld (debug_mark),a  
0698 3a a7 06			ld a, (.dmark+1)  
069b 32 72 ee			ld (debug_mark+1),a  
069e 3a a8 06			ld a, (.dmark+2)  
06a1 32 73 ee			ld (debug_mark+2),a  
06a4 18 03			jr .pastdmark  
06a6 ..			.dmark: db "SCA"  
06a9 f1			.pastdmark: pop af  
06aa			endm  
# End of macro DMARK
06aa					CALLMONITOR 
06aa cd 6d 14			call break_point_state  
06ad				endm  
# End of macro CALLMONITOR
06ad				endif 
06ad			 
06ad				; write file header page 
06ad			 
06ad 2a 46 eb			ld hl,(store_tmppageid) 
06b0 11 5c eb			ld de, store_page 
06b3				if DEBUG_STORESE 
06b3					DMARK "SCb" 
06b3 f5				push af  
06b4 3a c8 06			ld a, (.dmark)  
06b7 32 71 ee			ld (debug_mark),a  
06ba 3a c9 06			ld a, (.dmark+1)  
06bd 32 72 ee			ld (debug_mark+1),a  
06c0 3a ca 06			ld a, (.dmark+2)  
06c3 32 73 ee			ld (debug_mark+2),a  
06c6 18 03			jr .pastdmark  
06c8 ..			.dmark: db "SCb"  
06cb f1			.pastdmark: pop af  
06cc			endm  
# End of macro DMARK
06cc					;push af 
06cc					;ld a, 'b' 
06cc					;ld (debug_mark),a 
06cc					;pop af 
06cc					CALLMONITOR 
06cc cd 6d 14			call break_point_state  
06cf				endm  
# End of macro CALLMONITOR
06cf				endif 
06cf cd 11 02			call storage_write_block 
06d2			 
06d2 3a 55 eb			ld a, (store_tmpid) 
06d5 6f				ld l, a 
06d6 26 00			ld h,0 
06d8				if DEBUG_STORESE 
06d8					DMARK "SCz" 
06d8 f5				push af  
06d9 3a ed 06			ld a, (.dmark)  
06dc 32 71 ee			ld (debug_mark),a  
06df 3a ee 06			ld a, (.dmark+1)  
06e2 32 72 ee			ld (debug_mark+1),a  
06e5 3a ef 06			ld a, (.dmark+2)  
06e8 32 73 ee			ld (debug_mark+2),a  
06eb 18 03			jr .pastdmark  
06ed ..			.dmark: db "SCz"  
06f0 f1			.pastdmark: pop af  
06f1			endm  
# End of macro DMARK
06f1					CALLMONITOR 
06f1 cd 6d 14			call break_point_state  
06f4				endm  
# End of macro CALLMONITOR
06f4				endif 
06f4 c9				ret 
06f5				 
06f5			 
06f5			 
06f5			; 
06f5			; Read File 
06f5			; 
06f5			; h - file id to locate 
06f5			; l - extent to locate 
06f5			; de - pointer to string to read into 
06f5			; 
06f5			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06f5			 
06f5			.sr_fail: 
06f5 d1				pop de 
06f6 c9				ret 
06f7			 
06f7			storage_read: 
06f7 d5				push de 
06f8			 
06f8			; TODO BUG the above push is it popped before the RET Z? 
06f8			 
06f8			; TODO how to handle multiple part blocks 
06f8			 
06f8				; locate file extent to read 
06f8			 
06f8 5c				ld e, h 
06f9 55				ld d, l 
06fa 21 40 00			ld hl, STORE_BLOCK_PHY 
06fd				if DEBUG_STORESE 
06fd					DMARK "SRE" 
06fd f5				push af  
06fe 3a 12 07			ld a, (.dmark)  
0701 32 71 ee			ld (debug_mark),a  
0704 3a 13 07			ld a, (.dmark+1)  
0707 32 72 ee			ld (debug_mark+1),a  
070a 3a 14 07			ld a, (.dmark+2)  
070d 32 73 ee			ld (debug_mark+2),a  
0710 18 03			jr .pastdmark  
0712 ..			.dmark: db "SRE"  
0715 f1			.pastdmark: pop af  
0716			endm  
# End of macro DMARK
0716					CALLMONITOR 
0716 cd 6d 14			call break_point_state  
0719				endm  
# End of macro CALLMONITOR
0719				endif 
0719 cd d1 04			call storage_findnextid 
071c			 
071c				if DEBUG_STORESE 
071c					DMARK "SRf" 
071c f5				push af  
071d 3a 31 07			ld a, (.dmark)  
0720 32 71 ee			ld (debug_mark),a  
0723 3a 32 07			ld a, (.dmark+1)  
0726 32 72 ee			ld (debug_mark+1),a  
0729 3a 33 07			ld a, (.dmark+2)  
072c 32 73 ee			ld (debug_mark+2),a  
072f 18 03			jr .pastdmark  
0731 ..			.dmark: db "SRf"  
0734 f1			.pastdmark: pop af  
0735			endm  
# End of macro DMARK
0735					CALLMONITOR 
0735 cd 6d 14			call break_point_state  
0738				endm  
# End of macro CALLMONITOR
0738				endif 
0738 cd ed 0b			call ishlzero 
073b			;	ld a, l 
073b			;	add h 
073b			;	cp 0 
073b 28 b8			jr z,.sr_fail			; block not found so EOF 
073d			 
073d				; hl contains page number to load 
073d d1				pop de   ; get storage 
073e d5				push de 
073f				if DEBUG_STORESE 
073f					DMARK "SRg" 
073f f5				push af  
0740 3a 54 07			ld a, (.dmark)  
0743 32 71 ee			ld (debug_mark),a  
0746 3a 55 07			ld a, (.dmark+1)  
0749 32 72 ee			ld (debug_mark+1),a  
074c 3a 56 07			ld a, (.dmark+2)  
074f 32 73 ee			ld (debug_mark+2),a  
0752 18 03			jr .pastdmark  
0754 ..			.dmark: db "SRg"  
0757 f1			.pastdmark: pop af  
0758			endm  
# End of macro DMARK
0758					CALLMONITOR 
0758 cd 6d 14			call break_point_state  
075b				endm  
# End of macro CALLMONITOR
075b				endif 
075b cd ac 01			call storage_read_block 
075e			 
075e			 
075e			; TODO if block has no zeros then need to read next block  
075e			 
075e			 
075e					 
075e e1				pop hl 		 ; return start of data to show as not EOF 
075f 23				inc hl   ; past file id 
0760 23				inc hl   ; past ext 
0761				if DEBUG_STORESE 
0761					DMARK "SRe" 
0761 f5				push af  
0762 3a 76 07			ld a, (.dmark)  
0765 32 71 ee			ld (debug_mark),a  
0768 3a 77 07			ld a, (.dmark+1)  
076b 32 72 ee			ld (debug_mark+1),a  
076e 3a 78 07			ld a, (.dmark+2)  
0771 32 73 ee			ld (debug_mark+2),a  
0774 18 03			jr .pastdmark  
0776 ..			.dmark: db "SRe"  
0779 f1			.pastdmark: pop af  
077a			endm  
# End of macro DMARK
077a					CALLMONITOR 
077a cd 6d 14			call break_point_state  
077d				endm  
# End of macro CALLMONITOR
077d				endif 
077d c9					ret 
077e			 
077e			 
077e			 
077e			; 
077e			; Append File 
077e			; 
077e			; hl - file id to locate 
077e			; de - pointer to (multi block) string to write 
077e			 
077e			.sa_notfound: 
077e d1				pop de 
077f c9				ret 
0780			 
0780			 
0780			storage_append: 
0780				; hl -  file id to append to 
0780				; de - string to append 
0780			 
0780 d5				push de 
0781				 
0781				if DEBUG_STORESE 
0781					DMARK "AP1" 
0781 f5				push af  
0782 3a 96 07			ld a, (.dmark)  
0785 32 71 ee			ld (debug_mark),a  
0788 3a 97 07			ld a, (.dmark+1)  
078b 32 72 ee			ld (debug_mark+1),a  
078e 3a 98 07			ld a, (.dmark+2)  
0791 32 73 ee			ld (debug_mark+2),a  
0794 18 03			jr .pastdmark  
0796 ..			.dmark: db "AP1"  
0799 f1			.pastdmark: pop af  
079a			endm  
# End of macro DMARK
079a					CALLMONITOR 
079a cd 6d 14			call break_point_state  
079d				endm  
# End of macro CALLMONITOR
079d				endif 
079d			 
079d 7d				ld a, l 
079e 32 55 eb			ld (store_tmpid), a 
07a1			 
07a1				; get file header  
07a1			 
07a1 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
07a3 3a 55 eb			ld a, (store_tmpid) 
07a6 5f				ld e, a 
07a7			 
07a7 21 40 00				ld hl, STORE_BLOCK_PHY 
07aa cd d1 04				call storage_findnextid 
07ad			 
07ad cd ed 0b			call ishlzero 
07b0 28 cc			jr z, .sa_notfound 
07b2			 
07b2 22 46 eb			ld (store_tmppageid), hl 
07b5			 
07b5				; TODO handle file id not found 
07b5			 
07b5				if DEBUG_STORESE 
07b5					DMARK "AP2" 
07b5 f5				push af  
07b6 3a ca 07			ld a, (.dmark)  
07b9 32 71 ee			ld (debug_mark),a  
07bc 3a cb 07			ld a, (.dmark+1)  
07bf 32 72 ee			ld (debug_mark+1),a  
07c2 3a cc 07			ld a, (.dmark+2)  
07c5 32 73 ee			ld (debug_mark+2),a  
07c8 18 03			jr .pastdmark  
07ca ..			.dmark: db "AP2"  
07cd f1			.pastdmark: pop af  
07ce			endm  
# End of macro DMARK
07ce					CALLMONITOR 
07ce cd 6d 14			call break_point_state  
07d1				endm  
# End of macro CALLMONITOR
07d1				endif 
07d1			 
07d1				; update file extent count 
07d1			 
07d1 11 5c eb			ld de, store_page 
07d4			 
07d4 cd ac 01			call storage_read_block 
07d7			 
07d7				if DEBUG_STORESE 
07d7					DMARK "AP3" 
07d7 f5				push af  
07d8 3a ec 07			ld a, (.dmark)  
07db 32 71 ee			ld (debug_mark),a  
07de 3a ed 07			ld a, (.dmark+1)  
07e1 32 72 ee			ld (debug_mark+1),a  
07e4 3a ee 07			ld a, (.dmark+2)  
07e7 32 73 ee			ld (debug_mark+2),a  
07ea 18 03			jr .pastdmark  
07ec ..			.dmark: db "AP3"  
07ef f1			.pastdmark: pop af  
07f0			endm  
# End of macro DMARK
07f0					CALLMONITOR 
07f0 cd 6d 14			call break_point_state  
07f3				endm  
# End of macro CALLMONITOR
07f3				endif 
07f3			;	ld (store_tmppageid), hl 
07f3			 
07f3 3a 5e eb			ld a, (store_page+2) 
07f6 3c				inc a 
07f7 32 5e eb			ld (store_page+2), a 
07fa 32 54 eb			ld (store_tmpext), a 
07fd				 
07fd				if DEBUG_STORESE 
07fd					DMARK "AP3" 
07fd f5				push af  
07fe 3a 12 08			ld a, (.dmark)  
0801 32 71 ee			ld (debug_mark),a  
0804 3a 13 08			ld a, (.dmark+1)  
0807 32 72 ee			ld (debug_mark+1),a  
080a 3a 14 08			ld a, (.dmark+2)  
080d 32 73 ee			ld (debug_mark+2),a  
0810 18 03			jr .pastdmark  
0812 ..			.dmark: db "AP3"  
0815 f1			.pastdmark: pop af  
0816			endm  
# End of macro DMARK
0816					CALLMONITOR 
0816 cd 6d 14			call break_point_state  
0819				endm  
# End of macro CALLMONITOR
0819				endif 
0819 2a 46 eb			ld hl, (store_tmppageid) 
081c 11 5c eb			ld de, store_page 
081f cd 11 02			call storage_write_block 
0822			 
0822				; find free block 
0822			 
0822 11 00 00			ld de, 0			 ; file extent to locate 
0825			 
0825 21 40 00				ld hl, STORE_BLOCK_PHY 
0828 cd d1 04				call storage_findnextid 
082b cd ed 0b			call ishlzero 
082e ca 7e 07			jp z, .sa_notfound 
0831			 
0831					; TODO handle no space left 
0831					 
0831 22 46 eb				ld (store_tmppageid), hl 
0834			 
0834				if DEBUG_STORESE 
0834					DMARK "AP4" 
0834 f5				push af  
0835 3a 49 08			ld a, (.dmark)  
0838 32 71 ee			ld (debug_mark),a  
083b 3a 4a 08			ld a, (.dmark+1)  
083e 32 72 ee			ld (debug_mark+1),a  
0841 3a 4b 08			ld a, (.dmark+2)  
0844 32 73 ee			ld (debug_mark+2),a  
0847 18 03			jr .pastdmark  
0849 ..			.dmark: db "AP4"  
084c f1			.pastdmark: pop af  
084d			endm  
# End of macro DMARK
084d					CALLMONITOR 
084d cd 6d 14			call break_point_state  
0850				endm  
# End of macro CALLMONITOR
0850				endif 
0850					; init the buffer with zeros so we can id if the buffer is full or not 
0850			 
0850 e5					push hl 
0851 c5					push bc 
0852			 
0852 21 5c eb				ld hl, store_page 
0855 06 40				ld b, STORE_BLOCK_PHY 
0857 3e 00				ld a, 0 
0859 77			.zeroblock:	ld (hl), a 
085a 23					inc hl 
085b 10 fc				djnz .zeroblock 
085d			 
085d c1					pop bc 
085e e1					pop hl 
085f			 
085f					; construct block 
085f			 
085f 3a 55 eb				ld a, (store_tmpid) 
0862 32 5c eb				ld (store_page), a   ; file id 
0865 3a 54 eb				ld a, (store_tmpext)   ; extent for this block 
0868 32 5d eb				ld (store_page+1), a 
086b			 
086b e1					pop hl    ; get string to write 
086c 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
086e 11 5e eb				ld de, store_page+2 
0871			 
0871				if DEBUG_STORESE 
0871					DMARK "AP5" 
0871 f5				push af  
0872 3a 86 08			ld a, (.dmark)  
0875 32 71 ee			ld (debug_mark),a  
0878 3a 87 08			ld a, (.dmark+1)  
087b 32 72 ee			ld (debug_mark+1),a  
087e 3a 88 08			ld a, (.dmark+2)  
0881 32 73 ee			ld (debug_mark+2),a  
0884 18 03			jr .pastdmark  
0886 ..			.dmark: db "AP5"  
0889 f1			.pastdmark: pop af  
088a			endm  
# End of macro DMARK
088a					CALLMONITOR 
088a cd 6d 14			call break_point_state  
088d				endm  
# End of macro CALLMONITOR
088d				endif 
088d			 
088d			 
088d			 
088d					; fill buffer with data until end of string or full block 
088d			 
088d 7e			.appd:		ld a, (hl) 
088e 12					ld (de), a 
088f fe 00				cp 0 
0891 28 04				jr z, .appdone 
0893 23					inc hl 
0894 13					inc de 
0895 10 f6				djnz .appd 
0897			 
0897 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0898 f5					push af   		; save last byte dumped 
0899			 
0899			 
0899 2a 46 eb			ld hl, (store_tmppageid) 
089c 11 5c eb			ld de, store_page 
089f				if DEBUG_STORESE 
089f					DMARK "AP6" 
089f f5				push af  
08a0 3a b4 08			ld a, (.dmark)  
08a3 32 71 ee			ld (debug_mark),a  
08a6 3a b5 08			ld a, (.dmark+1)  
08a9 32 72 ee			ld (debug_mark+1),a  
08ac 3a b6 08			ld a, (.dmark+2)  
08af 32 73 ee			ld (debug_mark+2),a  
08b2 18 03			jr .pastdmark  
08b4 ..			.dmark: db "AP6"  
08b7 f1			.pastdmark: pop af  
08b8			endm  
# End of macro DMARK
08b8					CALLMONITOR 
08b8 cd 6d 14			call break_point_state  
08bb				endm  
# End of macro CALLMONITOR
08bb				endif 
08bb cd 11 02				call storage_write_block 
08be			 
08be			 
08be				; was that a full block of data written? 
08be				; any more to write out? 
08be			 
08be				; if yes then set vars and jump to start of function again 
08be			 
08be f1					pop af 
08bf d1					pop de 
08c0			 
08c0 fe 00				cp 0		 ; no, string was fully written 
08c2 c8					ret z 
08c3			 
08c3					; setup vars for next cycle 
08c3			 
08c3 3a 55 eb				ld a, (store_tmpid) 
08c6 6f					ld l, a 
08c7 26 00				ld h, 0 
08c9			 
08c9 c3 80 07			 	jp storage_append	 ; yes, need to write out some more 
08cc			 
08cc			 
08cc			 
08cc			 
08cc			 
08cc			 
08cc			 
08cc			if DEBUG_STORECF 
08cc			storageput:	 
08cc					ret 
08cc			storageread: 
08cc					ld hl, store_page 
08cc					ld b, 200 
08cc					ld a,0 
08cc			.src:		ld (hl),a 
08cc					inc hl 
08cc					djnz .src 
08cc					 
08cc			 
08cc					ld de, 0 
08cc					ld bc, 1 
08cc					ld hl, store_page 
08cc					call cfRead 
08cc			 
08cc				call cfGetError 
08cc				ld hl,scratch 
08cc				call hexout 
08cc				ld hl, scratch+2 
08cc				ld a, 0 
08cc				ld (hl),a 
08cc				ld de, scratch 
08cc				ld a,display_row_1 
08cc				call str_at_display 
08cc				call update_display 
08cc			 
08cc					ld hl, store_page 
08cc					ld (os_cur_ptr),hl 
08cc			 
08cc					ret 
08cc			endif 
08cc			 
08cc			 
08cc			; Clear out the main buffer store (used to remove junk before writing a new block) 
08cc			 
08cc			storage_clear_page: 
08cc e5				push hl 
08cd d5				push de 
08ce c5				push bc 
08cf 21 5c eb			ld hl, store_page 
08d2 3e 00			ld a, 0 
08d4 77				ld (hl), a 
08d5			 
08d5 11 5d eb			ld de, store_page+1 
08d8 01 40 00			ld bc, STORE_BLOCK_PHY 
08db			 
08db ed b0			ldir 
08dd				 
08dd c1				pop bc 
08de d1				pop de 
08df e1				pop hl 
08e0 c9				ret 
08e1			 
08e1			; eof 
# End of file firmware_storage.asm
08e1			  
08e1			; support routines for above hardware abstraction layer  
08e1			  
08e1			include "firmware_general.asm"        ; general support functions  
08e1			 
08e1			; word look up 
08e1			 
08e1			; in 
08e1			; a is the index 
08e1			; hl is pointer start of array 
08e1			; 
08e1			; returns 
08e1			; hl to the word 
08e1			; 
08e1			 
08e1			table_lookup:  
08e1 d5					push de 
08e2 eb					ex de, hl 
08e3			 
08e3 6f					ld l, a 
08e4 26 00				ld h, 0 
08e6 29					add hl, hl 
08e7 19					add hl, de 
08e8 7e					ld a, (hl) 
08e9 23					inc hl 
08ea 66					ld h,(hl) 
08eb 6f					ld l, a 
08ec			 
08ec d1					pop de 
08ed c9					ret 
08ee			 
08ee			; Delay loops 
08ee			 
08ee			 
08ee			 
08ee			aDelayInMS: 
08ee c5				push bc 
08ef 47				ld b,a 
08f0			msdelay: 
08f0 c5				push bc 
08f1				 
08f1			 
08f1 01 41 00			ld bc,041h 
08f4 cd 0c 09			call delayloop 
08f7 c1				pop bc 
08f8 05				dec b 
08f9 20 f5			jr nz,msdelay 
08fb			 
08fb			;if CPU_CLOCK_8MHZ 
08fb			;msdelay8: 
08fb			;	push bc 
08fb			;	 
08fb			; 
08fb			;	ld bc,041h 
08fb			;	call delayloop 
08fb			;	pop bc 
08fb			;	dec b 
08fb			;	jr nz,msdelay8 
08fb			;endif 
08fb			 
08fb			 
08fb c1				pop bc 
08fc c9				ret 
08fd			 
08fd			 
08fd			delay250ms: 
08fd				;push de 
08fd 01 00 40			ld bc, 04000h 
0900 c3 0c 09			jp delayloop 
0903			delay500ms: 
0903				;push de 
0903 01 00 80			ld bc, 08000h 
0906 c3 0c 09			jp delayloop 
0909			delay1s: 
0909				;push bc 
0909			   ; Clobbers A, d and e 
0909 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
090c			delayloop: 
090c c5			    push bc 
090d			 
090d			if BASE_CPM 
090d 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0910			.cpmloop: 
0910 c5				push bc 
0911			 
0911			endif 
0911			 
0911			 
0911			 
0911			delayloopi: 
0911			;	push bc 
0911			;.dl: 
0911 cb 47		    bit     0,a    	; 8 
0913 cb 47		    bit     0,a    	; 8 
0915 cb 47		    bit     0,a    	; 8 
0917 e6 ff		    and     255  	; 7 
0919 0b			    dec     bc      	; 6 
091a 79			    ld      a,c     	; 4 
091b b0			    or      b     	; 4 
091c c2 11 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
091f			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
091f				;pop de 
091f			;pop bc 
091f			 
091f			if BASE_CPM 
091f c1				pop bc 
0920				 
0920 0b			    dec     bc      	; 6 
0921 79			    ld      a,c     	; 4 
0922 b0			    or      b     	; 4 
0923 c2 10 09		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0926				 
0926			 
0926			endif 
0926			;if CPU_CLOCK_8MHZ 
0926			;    pop bc 
0926			;    push bc 
0926			;.dl8: 
0926			;    bit     0,a    	; 8 
0926			;    bit     0,a    	; 8 
0926			;    bit     0,a    	; 8 
0926			;    and     255  	; 7 
0926			;    dec     bc      	; 6 
0926			;    ld      a,c     	; 4 
0926			;    or      b     	; 4 
0926			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0926			;endif 
0926			 
0926			;if CPU_CLOCK_10MHZ 
0926			;    pop bc 
0926			;    push bc 
0926			;.dl8: 
0926			;    bit     0,a    	; 8 
0926			;    bit     0,a    	; 8 
0926			;    bit     0,a    	; 8 
0926			;    and     255  	; 7 
0926			;    dec     bc      	; 6 
0926			;    ld      a,c     	; 4 
0926			;    or      b     	; 4 
0926			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0926			;endif 
0926 c1			    pop bc 
0927			 
0927 c9				ret 
0928			 
0928			 
0928			 
0928			; eof 
# End of file firmware_general.asm
0928			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0928			; display routines that use the physical hardware abstraction layer 
0928			 
0928			 
0928			; information window 
0928			 
0928			; pass hl with 1st string to display 
0928			; pass de with 2nd string to display 
0928			 
0928			info_panel: 
0928 e5				push hl 
0929			 
0929 2a d2 eb			ld hl, (display_fb_active) 
092c e5				push hl    ; future de destination 
092d 21 b7 ed				ld hl, display_fb0 
0930 22 d2 eb				ld (display_fb_active), hl 
0933			 
0933			;	call clear_display 
0933			 
0933				if BASE_CPM 
0933 3e 2e			ld a, '.' 
0935				else 
0935				ld a, 165 
0935				endif 
0935 cd 9c 09			call fill_display 
0938			 
0938			 
0938 3e 55			ld a, display_row_3 + 5 
093a cd aa 09			call str_at_display 
093d			 
093d e1				pop hl 
093e d1				pop de 
093f			 
093f e5				push hl 
0940			 
0940			 
0940 3e 2d			ld a, display_row_2 + 5 
0942 cd aa 09			call str_at_display 
0945			 
0945			 
0945 cd ba 09			call update_display 
0948 cd 72 19			call next_page_prompt 
094b cd 97 09			call clear_display 
094e			 
094e				 
094e 21 16 ed				ld hl, display_fb1 
0951 22 d2 eb				ld (display_fb_active), hl 
0954 cd ba 09			call update_display 
0957			 
0957 e1				pop hl 
0958			 
0958 c9				ret 
0959			 
0959			 
0959			 
0959			 
0959			; TODO windowing? 
0959			 
0959			; TODO scroll line up 
0959			 
0959			scroll_up: 
0959			 
0959 e5				push hl 
095a d5				push de 
095b c5				push bc 
095c			 
095c				; get frame buffer  
095c			 
095c 2a d2 eb			ld hl, (display_fb_active) 
095f e5				push hl    ; future de destination 
0960			 
0960 11 28 00			ld  de, display_cols 
0963 19				add hl, de 
0964			 
0964 d1				pop de 
0965			 
0965				;ex de, hl 
0965 01 9f 00			ld bc, display_fb_len -1  
0968			;if DEBUG_FORTH_WORDS 
0968			;	DMARK "SCL" 
0968			;	CALLMONITOR 
0968			;endif	 
0968 ed b0			ldir 
096a			 
096a				; wipe bottom row 
096a			 
096a			 
096a 2a d2 eb			ld hl, (display_fb_active) 
096d 11 a0 00			ld de, display_cols*display_rows 
0970 19				add hl, de 
0971 06 28			ld b, display_cols 
0973 3e 20			ld a, ' ' 
0975			.scwipe: 
0975 77				ld (hl), a 
0976 2b				dec hl 
0977 10 fc			djnz .scwipe 
0979			 
0979				;pop hl 
0979			 
0979 c1				pop bc 
097a d1				pop de 
097b e1				pop hl 
097c			 
097c c9				ret 
097d			 
097d			 
097d			;scroll_upo: 
097d			;	ld de, display_row_1 
097d			 ;	ld hl, display_row_2 
097d			;	ld bc, display_cols 
097d			;	ldir 
097d			;	ld de, display_row_2 
097d			 ;	ld hl, display_row_3 
097d			;	ld bc, display_cols 
097d			;	ldir 
097d			;	ld de, display_row_3 
097d			 ;	ld hl, display_row_4 
097d			;	ld bc, display_cols 
097d			;	ldir 
097d			 
097d			; TODO clear row 4 
097d			 
097d			;	ret 
097d			 
097d				 
097d			scroll_down: 
097d			 
097d e5				push hl 
097e d5				push de 
097f c5				push bc 
0980			 
0980				; get frame buffer  
0980			 
0980 2a d2 eb			ld hl, (display_fb_active) 
0983			 
0983 11 9f 00			ld de, display_fb_len - 1 
0986 19				add hl, de 
0987			 
0987 e5			push hl    ; future de destination 
0988			 
0988 11 28 00			ld  de, display_cols 
098b ed 52			sbc hl, de 
098d			 
098d			 
098d d1				pop de 
098e			 
098e			;	ex de, hl 
098e 01 9f 00			ld bc, display_fb_len -1  
0991			 
0991			 
0991				 
0991			 
0991 ed b0			ldir 
0993			 
0993				; wipe bottom row 
0993			 
0993			 
0993			;	ld hl, (display_fb_active) 
0993			;;	ld de, display_cols*display_rows 
0993			;;	add hl, de 
0993			;	ld b, display_cols 
0993			;	ld a, ' ' 
0993			;.scwiped: 
0993			;	ld (hl), a 
0993			;	dec hl 
0993			;	djnz .scwiped 
0993			 
0993				;pop hl 
0993			 
0993 c1				pop bc 
0994 d1				pop de 
0995 e1				pop hl 
0996			 
0996 c9				ret 
0997			;scroll_down: 
0997			;	ld de, display_row_4 
0997			;	ld hl, display_row_3 
0997			;	ld bc, display_cols 
0997			;	ldir 
0997			;	ld de, display_row_3 
0997			; 	ld hl, display_row_2 
0997			;	ld bc, display_cols 
0997			;	ldir 
0997			;	ld de, display_row_2 
0997			;	ld hl, display_row_1 
0997			;	ld bc, display_cols 
0997			;	ldir 
0997			;;; TODO clear row 1 
0997			;	ret 
0997			 
0997			 
0997			 
0997			 
0997			 
0997			; clear active frame buffer 
0997			 
0997			clear_display: 
0997 3e 20			ld a, ' ' 
0999 c3 9c 09			jp fill_display 
099c			 
099c			; fill active frame buffer with a char in A 
099c			 
099c			fill_display: 
099c 06 a0			ld b,display_fb_len 
099e 2a d2 eb			ld hl, (display_fb_active) 
09a1 77			.fd1:	ld (hl),a 
09a2 23				inc hl 
09a3 10 fc			djnz .fd1 
09a5 23				inc hl 
09a6 3e 00			ld a,0 
09a8 77				ld (hl),a 
09a9			 
09a9			 
09a9 c9				ret 
09aa			; Write string (DE) at pos (A) to active frame buffer 
09aa			 
09aa 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
09ad 06 00					ld b,0 
09af 4f					ld c,a 
09b0 09					add hl,bc 
09b1 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
09b2 b7			            OR   A              ;Null terminator? 
09b3 c8			            RET  Z              ;Yes, so finished 
09b4 77					ld (hl),a 
09b5 23				inc hl 
09b6 13			            INC  DE             ;Point to next character 
09b7 18 f8		            JR   .sad1     ;Repeat 
09b9 c9					ret 
09ba			 
09ba			; using current frame buffer write to physical display 
09ba			 
09ba			update_display: 
09ba e5				push hl 
09bb 2a d2 eb			ld hl, (display_fb_active) 
09be cd 65 58			call write_display 
09c1 e1				pop hl 
09c2 c9				ret 
09c3			 
09c3			; TODO scrolling 
09c3			 
09c3			 
09c3			; move cursor right one char 
09c3			cursor_right: 
09c3			 
09c3				; TODO shift right 
09c3				; TODO if beyond max col 
09c3				; TODO       cursor_next_line 
09c3			 
09c3 c9				ret 
09c4			 
09c4			 
09c4			cursor_next_line: 
09c4				; TODO first char 
09c4				; TODO line down 
09c4				; TODO if past last row 
09c4				; TODO    scroll up 
09c4			 
09c4 c9				ret 
09c5			 
09c5			cursor_left: 
09c5				; TODO shift left 
09c5				; TODO if beyond left  
09c5				; TODO     cursor prev line 
09c5				 
09c5 c9				ret 
09c6			 
09c6			cursor_prev_line: 
09c6				; TODO last char 
09c6				; TODO line up 
09c6				; TODO if past first row 
09c6				; TODO   scroll down 
09c6			 
09c6 c9				ret 
09c7			 
09c7			 
09c7			cout: 
09c7				; A - char 
09c7 c9				ret 
09c8			 
09c8			 
09c8			; Display a menu and allow item selection (optional toggle items) 
09c8			; 
09c8			; format: 
09c8			; hl pointer to word array with zero term for items 
09c8			; e.g.    db item1 
09c8			;         db .... 
09c8			;         db 0 
09c8			; 
09c8			; a = starting menu item  
09c8			; 
09c8			; de = pointer item toggle array   (todo) 
09c8			; 
09c8			; returns item selected in a 1-... 
09c8			; returns 0 if back button pressed 
09c8			; 
09c8			; NOTE: Uses system frame buffer to display 
09c8			; 
09c8			; LEFT, Q = go back 
09c8			; RIGHT, SPACE, CR = select 
09c8			; UP, A - Up 
09c8			; DOWN, Z - Down 
09c8			 
09c8			 
09c8			 
09c8			 
09c8			 
09c8			menu: 
09c8			 
09c8					; keep array pointer 
09c8			 
09c8 22 5a eb				ld (store_tmp1), hl 
09cb 32 58 eb				ld (store_tmp2), a 
09ce			 
09ce					; check for key bounce 
09ce			 
09ce			if BASE_KEV 
09ce			 
09ce			.mbounce:	call cin 
09ce					cp 0 
09ce					jr nz, .mbounce 
09ce			endif 
09ce					; for ease use ex 
09ce			 
09ce					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
09ce 21 b7 ed				ld hl, display_fb0 
09d1 22 d2 eb				ld (display_fb_active), hl 
09d4			 
09d4 cd 97 09		.mloop:		call clear_display 
09d7 cd ba 09				call update_display 
09da			 
09da					; draw selection id '>' at 1 
09da			 
09da					; init start of list display 
09da			 
09da 3e 05				ld a, 5 
09dc 32 56 eb				ld (store_tmp3), a   ; display row count 
09df 3a 58 eb				ld a,( store_tmp2) 
09e2 32 59 eb				ld (store_tmp2+1), a   ; display item count 
09e5			 
09e5					 
09e5			.mitem:	 
09e5			 
09e5			 
09e5 3a 59 eb				ld a,(store_tmp2+1) 
09e8 6f					ld l, a 
09e9 26 00				ld h, 0 
09eb 29					add hl, hl 
09ec ed 5b 5a eb			ld de, (store_tmp1) 
09f0 19					add hl, de 
09f1 7e					ld a, (hl) 
09f2 23					inc hl 
09f3 66					ld h,(hl) 
09f4 6f					ld l, a 
09f5			 
09f5 cd ed 0b				call ishlzero 
09f8 28 1a				jr z, .mdone 
09fa			 
09fa eb					ex de, hl 
09fb 3a 56 eb				ld a, (store_tmp3) 
09fe cd aa 09				call str_at_display 
0a01					 
0a01			 
0a01					; next item 
0a01 3a 59 eb				ld a, (store_tmp2+1) 
0a04 3c					inc a 
0a05 32 59 eb				ld (store_tmp2+1), a   ; display item count 
0a08			 
0a08			 		; next row 
0a08			 
0a08 3a 56 eb				ld a, (store_tmp3) 
0a0b c6 28				add display_cols 
0a0d 32 56 eb				ld (store_tmp3), a 
0a10			 
0a10					; at end of screen? 
0a10			 
0a10 fe 10				cp display_rows*4 
0a12 20 d1				jr nz, .mitem 
0a14			 
0a14			 
0a14			.mdone: 
0a14 cd ed 0b				call ishlzero 
0a17 28 08				jr z, .nodn 
0a19			 
0a19 3e 78				ld a, display_row_4 
0a1b 11 9a 0a				ld de, .mdown 
0a1e cd aa 09				call str_at_display 
0a21			 
0a21					; draw options to fill the screens with active item on line 1 
0a21					; if current option is 2 or more then display ^ in top 
0a21			 
0a21 3a 58 eb		.nodn:		ld a, (store_tmp2) 
0a24 fe 00				cp 0 
0a26 28 08				jr z, .noup 
0a28			 
0a28 3e 00				ld a, 0 
0a2a 11 98 0a				ld de, .mup 
0a2d cd aa 09				call str_at_display 
0a30			 
0a30 3e 02		.noup:		ld a, 2 
0a32 11 96 0a				ld de, .msel 
0a35 cd aa 09				call str_at_display 
0a38			 
0a38					; if current option + 1 is not null then display V in bottom 
0a38					; get key 
0a38 cd ba 09				call update_display 
0a3b			 
0a3b			 
0a3b					; handle key 
0a3b			 
0a3b cd 17 59				call cin_wait 
0a3e			 
0a3e fe 05				cp KEY_UP 
0a40 28 2b				jr z, .mgoup 
0a42 fe 61				cp 'a' 
0a44 28 27				jr z, .mgoup 
0a46 fe 0a				cp KEY_DOWN 
0a48 28 32				jr z, .mgod 
0a4a fe 7a				cp 'z' 
0a4c 28 2e				jr z, .mgod 
0a4e fe 20				cp ' ' 
0a50 28 34				jr z, .goend 
0a52 fe 0c				cp KEY_RIGHT 
0a54 28 30				jr z, .goend 
0a56 fe 0d				cp KEY_CR 
0a58 28 2c				jr z, .goend 
0a5a fe 71				cp 'q' 
0a5c 28 0b				jr z, .goback 
0a5e			 
0a5e fe 0b				cp KEY_LEFT 
0a60 28 07				jr z, .goback 
0a62 fe 08				cp KEY_BS 
0a64 28 03				jr z, .goback 
0a66 c3 d4 09				jp .mloop 
0a69			 
0a69			.goback: 
0a69 3e 00			ld a, 0 
0a6b 18 1d			jr .goend2 
0a6d			 
0a6d				; move up one 
0a6d			.mgoup: 
0a6d 3a 58 eb				ld a, (store_tmp2) 
0a70 fe 00				cp 0 
0a72 ca d4 09				jp z, .mloop 
0a75 3d					dec a 
0a76 32 58 eb				ld (store_tmp2), a 
0a79 c3 d4 09				jp .mloop 
0a7c			 
0a7c				; move down one 
0a7c			.mgod: 
0a7c 3a 58 eb				ld a, (store_tmp2) 
0a7f 3c					inc a 
0a80 32 58 eb				ld (store_tmp2), a 
0a83 c3 d4 09				jp .mloop 
0a86			 
0a86			 
0a86			.goend: 
0a86					; get selected item number 
0a86			 
0a86 3a 58 eb				ld a, (store_tmp2) 
0a89 3c					inc a 
0a8a			 
0a8a			.goend2: 
0a8a f5					push af 
0a8b			 
0a8b					; restore active fb 
0a8b					; TODO BUG assumes fb1 
0a8b			 
0a8b 21 16 ed				ld hl, display_fb1 
0a8e 22 d2 eb				ld (display_fb_active), hl 
0a91			 
0a91					; restore main regs 
0a91			 
0a91			 
0a91 cd ba 09				call update_display 
0a94			 
0a94 f1					pop af 
0a95			 
0a95 c9				ret 
0a96			 
0a96 .. 00		.msel:   db ">",0 
0a98 .. 00		.mup:   db "^",0 
0a9a .. 00		.mdown:   db "v",0 
0a9c			 
0a9c			 
0a9c			; eof 
0a9c			 
# End of file firmware_display.asm
0a9c			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0a9c			; random number generators 
0a9c			 
0a9c			 
0a9c			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0a9c			 
0a9c			 
0a9c			;-----> Generate a random number 
0a9c			; output a=answer 0<=a<=255 
0a9c			; all registers are preserved except: af 
0a9c			random: 
0a9c e5			        push    hl 
0a9d d5			        push    de 
0a9e 2a b4 eb		        ld      hl,(randData) 
0aa1 ed 5f		        ld      a,r 
0aa3 57			        ld      d,a 
0aa4 5e			        ld      e,(hl) 
0aa5 19			        add     hl,de 
0aa6 85			        add     a,l 
0aa7 ac			        xor     h 
0aa8 22 b4 eb		        ld      (randData),hl 
0aab d1			        pop     de 
0aac e1			        pop     hl 
0aad c9			        ret 
0aae			 
0aae			 
0aae			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0aae			 
0aae			 
0aae			 
0aae			;------LFSR------ 
0aae			;James Montelongo 
0aae			;optimized by Spencer Putt 
0aae			;out: 
0aae			; a = 8 bit random number 
0aae			RandLFSR: 
0aae 21 ba eb		        ld hl,LFSRSeed+4 
0ab1 5e			        ld e,(hl) 
0ab2 23			        inc hl 
0ab3 56			        ld d,(hl) 
0ab4 23			        inc hl 
0ab5 4e			        ld c,(hl) 
0ab6 23			        inc hl 
0ab7 7e			        ld a,(hl) 
0ab8 47			        ld b,a 
0ab9 cb 13		        rl e  
0abb cb 12			rl d 
0abd cb 11		        rl c  
0abf 17				rla 
0ac0 cb 13		        rl e  
0ac2 cb 12			rl d 
0ac4 cb 11		        rl c  
0ac6 17				rla 
0ac7 cb 13		        rl e  
0ac9 cb 12			rl d 
0acb cb 11		        rl c  
0acd 17				rla 
0ace 67			        ld h,a 
0acf cb 13		        rl e  
0ad1 cb 12			rl d 
0ad3 cb 11		        rl c  
0ad5 17				rla 
0ad6 a8			        xor b 
0ad7 cb 13		        rl e  
0ad9 cb 12			rl d 
0adb ac			        xor h 
0adc a9			        xor c 
0add aa			        xor d 
0ade 21 bc eb		        ld hl,LFSRSeed+6 
0ae1 11 bd eb		        ld de,LFSRSeed+7 
0ae4 01 07 00		        ld bc,7 
0ae7 ed b8		        lddr 
0ae9 12			        ld (de),a 
0aea c9			        ret 
0aeb			 
0aeb			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0aeb			 
0aeb			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0aeb			 
0aeb			 
0aeb			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0aeb			 
0aeb			prng16: 
0aeb			;Inputs: 
0aeb			;   (seed1) contains a 16-bit seed value 
0aeb			;   (seed2) contains a NON-ZERO 16-bit seed value 
0aeb			;Outputs: 
0aeb			;   HL is the result 
0aeb			;   BC is the result of the LCG, so not that great of quality 
0aeb			;   DE is preserved 
0aeb			;Destroys: 
0aeb			;   AF 
0aeb			;cycle: 4,294,901,760 (almost 4.3 billion) 
0aeb			;160cc 
0aeb			;26 bytes 
0aeb 2a ae eb		    ld hl,(seed1) 
0aee 44			    ld b,h 
0aef 4d			    ld c,l 
0af0 29			    add hl,hl 
0af1 29			    add hl,hl 
0af2 2c			    inc l 
0af3 09			    add hl,bc 
0af4 22 ae eb		    ld (seed1),hl 
0af7 2a ac eb		    ld hl,(seed2) 
0afa 29			    add hl,hl 
0afb 9f			    sbc a,a 
0afc e6 2d		    and %00101101 
0afe ad			    xor l 
0aff 6f			    ld l,a 
0b00 22 ac eb		    ld (seed2),hl 
0b03 09			    add hl,bc 
0b04 c9			    ret 
0b05			 
0b05			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0b05			 
0b05			rand32: 
0b05			;Inputs: 
0b05			;   (seed1_0) holds the lower 16 bits of the first seed 
0b05			;   (seed1_1) holds the upper 16 bits of the first seed 
0b05			;   (seed2_0) holds the lower 16 bits of the second seed 
0b05			;   (seed2_1) holds the upper 16 bits of the second seed 
0b05			;   **NOTE: seed2 must be non-zero 
0b05			;Outputs: 
0b05			;   HL is the result 
0b05			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0b05			;Destroys: 
0b05			;   AF 
0b05			;Tested and passes all CAcert tests 
0b05			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0b05			;it has a period of 18,446,744,069,414,584,320 
0b05			;roughly 18.4 quintillion. 
0b05			;LFSR taps: 0,2,6,7  = 11000101 
0b05			;291cc 
0b05			;seed1_0=$+1 
0b05			;    ld hl,12345 
0b05			;seed1_1=$+1 
0b05			;    ld de,6789 
0b05			;    ld b,h 
0b05			;    ld c,l 
0b05			;    add hl,hl \ rl e \ rl d 
0b05			;    add hl,hl \ rl e \ rl d 
0b05			;    inc l 
0b05			;    add hl,bc 
0b05			;    ld (seed1_0),hl 
0b05			;    ld hl,(seed1_1) 
0b05			;    adc hl,de 
0b05			;    ld (seed1_1),hl 
0b05			;    ex de,hl 
0b05			;seed2_0=$+1 
0b05			;    ld hl,9876 
0b05			;seed2_1=$+1 
0b05			;    ld bc,54321 
0b05			;    add hl,hl \ rl c \ rl b 
0b05			;    ld (seed2_1),bc 
0b05			;    sbc a,a 
0b05			;    and %11000101 
0b05			;    xor l 
0b05			;    ld l,a 
0b05			;    ld (seed2_0),hl 
0b05			;    ex de,hl 
0b05			;    add hl,bc 
0b05			;    ret 
0b05			; 
0b05			 
0b05			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0b05			; 20 bytes, 86 cycles (excluding ret) 
0b05			 
0b05			; returns   hl = pseudorandom number 
0b05			; corrupts   a 
0b05			 
0b05			; generates 16-bit pseudorandom numbers with a period of 65535 
0b05			; using the xorshift method: 
0b05			 
0b05			; hl ^= hl << 7 
0b05			; hl ^= hl >> 9 
0b05			; hl ^= hl << 8 
0b05			 
0b05			; some alternative shift triplets which also perform well are: 
0b05			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0b05			 
0b05			;  org 32768 
0b05			 
0b05			xrnd: 
0b05 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
0b08 3e 00		  ld a,0 
0b0a bd			  cp l 
0b0b 20 02		  jr nz, .xrnd1 
0b0d 2e 01		  ld l, 1 
0b0f			.xrnd1: 
0b0f			 
0b0f 7c			  ld a,h 
0b10 1f			  rra 
0b11 7d			  ld a,l 
0b12 1f			  rra 
0b13 ac			  xor h 
0b14 67			  ld h,a 
0b15 7d			  ld a,l 
0b16 1f			  rra 
0b17 7c			  ld a,h 
0b18 1f			  rra 
0b19 ad			  xor l 
0b1a 6f			  ld l,a 
0b1b ac			  xor h 
0b1c 67			  ld h,a 
0b1d			 
0b1d 22 b2 eb		  ld (xrandc),hl 
0b20			 
0b20 c9			  ret 
0b21			;  
0b21			 
0b21			 
0b21			;;;; int maths 
0b21			 
0b21			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b21			; Divide 16-bit values (with 16-bit result) 
0b21			; In: Divide BC by divider DE 
0b21			; Out: BC = result, HL = rest 
0b21			; 
0b21			Div16: 
0b21 21 00 00		    ld hl,0 
0b24 78			    ld a,b 
0b25 06 08		    ld b,8 
0b27			Div16_Loop1: 
0b27 17			    rla 
0b28 ed 6a		    adc hl,hl 
0b2a ed 52		    sbc hl,de 
0b2c 30 01		    jr nc,Div16_NoAdd1 
0b2e 19			    add hl,de 
0b2f			Div16_NoAdd1: 
0b2f 10 f6		    djnz Div16_Loop1 
0b31 17			    rla 
0b32 2f			    cpl 
0b33 47			    ld b,a 
0b34 79			    ld a,c 
0b35 48			    ld c,b 
0b36 06 08		    ld b,8 
0b38			Div16_Loop2: 
0b38 17			    rla 
0b39 ed 6a		    adc hl,hl 
0b3b ed 52		    sbc hl,de 
0b3d 30 01		    jr nc,Div16_NoAdd2 
0b3f 19			    add hl,de 
0b40			Div16_NoAdd2: 
0b40 10 f6		    djnz Div16_Loop2 
0b42 17			    rla 
0b43 2f			    cpl 
0b44 41			    ld b,c 
0b45 4f			    ld c,a 
0b46 c9			ret 
0b47			 
0b47			 
0b47			;http://z80-heaven.wikidot.com/math 
0b47			; 
0b47			;Inputs: 
0b47			;     DE and A are factors 
0b47			;Outputs: 
0b47			;     A is not changed 
0b47			;     B is 0 
0b47			;     C is not changed 
0b47			;     DE is not changed 
0b47			;     HL is the product 
0b47			;Time: 
0b47			;     342+6x 
0b47			; 
0b47			Mult16: 
0b47			 
0b47 06 08		     ld b,8          ;7           7 
0b49 21 00 00		     ld hl,0         ;10         10 
0b4c 29			       add hl,hl     ;11*8       88 
0b4d 07			       rlca          ;4*8        32 
0b4e 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b50 19			         add hl,de   ;--         -- 
0b51 10 f9		       djnz $-5      ;13*7+8     99 
0b53 c9			ret 
0b54			 
0b54			; 
0b54			; Square root of 16-bit value 
0b54			; In:  HL = value 
0b54			; Out:  D = result (rounded down) 
0b54			; 
0b54			;Sqr16: 
0b54			;    ld de,#0040 
0b54			;    ld a,l 
0b54			;    ld l,h 
0b54			;    ld h,d 
0b54			;    or a 
0b54			;    ld b,8 
0b54			;Sqr16_Loop: 
0b54			;    sbc hl,de 
0b54			;    jr nc,Sqr16_Skip 
0b54			;    add hl,de 
0b54			;Sqr16_Skip: 
0b54			;    ccf 
0b54			;    rl d 
0b54			;    add a,a 
0b54			;    adc hl,hl 
0b54			;    add a,a 
0b54			;    adc hl,hl 
0b54			;    djnz Sqr16_Loop 
0b54			;    ret 
0b54			; 
0b54			; 
0b54			; Divide 8-bit values 
0b54			; In: Divide E by divider C 
0b54			; Out: A = result, B = rest 
0b54			; 
0b54			Div8: 
0b54 af			    xor a 
0b55 06 08		    ld b,8 
0b57			Div8_Loop: 
0b57 cb 13		    rl e 
0b59 17			    rla 
0b5a 91			    sub c 
0b5b 30 01		    jr nc,Div8_NoAdd 
0b5d 81			    add a,c 
0b5e			Div8_NoAdd: 
0b5e 10 f7		    djnz Div8_Loop 
0b60 47			    ld b,a 
0b61 7b			    ld a,e 
0b62 17			    rla 
0b63 2f			    cpl 
0b64 c9			    ret 
0b65			 
0b65			; 
0b65			; Multiply 8-bit value with a 16-bit value (unrolled) 
0b65			; In: Multiply A with DE 
0b65			; Out: HL = result 
0b65			; 
0b65			Mult12U: 
0b65 2e 00		    ld l,0 
0b67 87			    add a,a 
0b68 30 01		    jr nc,Mult12U_NoAdd0 
0b6a 19			    add hl,de 
0b6b			Mult12U_NoAdd0: 
0b6b 29			    add hl,hl 
0b6c 87			    add a,a 
0b6d 30 01		    jr nc,Mult12U_NoAdd1 
0b6f 19			    add hl,de 
0b70			Mult12U_NoAdd1: 
0b70 29			    add hl,hl 
0b71 87			    add a,a 
0b72 30 01		    jr nc,Mult12U_NoAdd2 
0b74 19			    add hl,de 
0b75			Mult12U_NoAdd2: 
0b75 29			    add hl,hl 
0b76 87			    add a,a 
0b77 30 01		    jr nc,Mult12U_NoAdd3 
0b79 19			    add hl,de 
0b7a			Mult12U_NoAdd3: 
0b7a 29			    add hl,hl 
0b7b 87			    add a,a 
0b7c 30 01		    jr nc,Mult12U_NoAdd4 
0b7e 19			    add hl,de 
0b7f			Mult12U_NoAdd4: 
0b7f 29			    add hl,hl 
0b80 87			    add a,a 
0b81 30 01		    jr nc,Mult12U_NoAdd5 
0b83 19			    add hl,de 
0b84			Mult12U_NoAdd5: 
0b84 29			    add hl,hl 
0b85 87			    add a,a 
0b86 30 01		    jr nc,Mult12U_NoAdd6 
0b88 19			    add hl,de 
0b89			Mult12U_NoAdd6: 
0b89 29			    add hl,hl 
0b8a 87			    add a,a 
0b8b d0			    ret nc 
0b8c 19			    add hl,de 
0b8d c9			    ret 
0b8e			 
0b8e			; 
0b8e			; Multiply 8-bit value with a 16-bit value (right rotating) 
0b8e			; In: Multiply A with DE 
0b8e			;      Put lowest value in A for most efficient calculation 
0b8e			; Out: HL = result 
0b8e			; 
0b8e			Mult12R: 
0b8e 21 00 00		    ld hl,0 
0b91			Mult12R_Loop: 
0b91 cb 3f		    srl a 
0b93 30 01		    jr nc,Mult12R_NoAdd 
0b95 19			    add hl,de 
0b96			Mult12R_NoAdd: 
0b96 cb 23		    sla e 
0b98 cb 12		    rl d 
0b9a b7			    or a 
0b9b c2 91 0b		    jp nz,Mult12R_Loop 
0b9e c9			    ret 
0b9f			 
0b9f			; 
0b9f			; Multiply 16-bit values (with 32-bit result) 
0b9f			; In: Multiply BC with DE 
0b9f			; Out: BCHL = result 
0b9f			; 
0b9f			Mult32: 
0b9f 79			    ld a,c 
0ba0 48			    ld c,b 
0ba1 21 00 00		    ld hl,0 
0ba4 06 10		    ld b,16 
0ba6			Mult32_Loop: 
0ba6 29			    add hl,hl 
0ba7 17			    rla 
0ba8 cb 11		    rl c 
0baa 30 07		    jr nc,Mult32_NoAdd 
0bac 19			    add hl,de 
0bad ce 00		    adc a,0 
0baf d2 b3 0b		    jp nc,Mult32_NoAdd 
0bb2 0c			    inc c 
0bb3			Mult32_NoAdd: 
0bb3 10 f1		    djnz Mult32_Loop 
0bb5 41			    ld b,c 
0bb6 4f			    ld c,a 
0bb7 c9			    ret 
0bb8			 
0bb8			 
0bb8			 
0bb8			; 
0bb8			; Multiply 8-bit values 
0bb8			; In:  Multiply H with E 
0bb8			; Out: HL = result 
0bb8			; 
0bb8			Mult8: 
0bb8 16 00		    ld d,0 
0bba 6a			    ld l,d 
0bbb 06 08		    ld b,8 
0bbd			Mult8_Loop: 
0bbd 29			    add hl,hl 
0bbe 30 01		    jr nc,Mult8_NoAdd 
0bc0 19			    add hl,de 
0bc1			Mult8_NoAdd: 
0bc1 10 fa		    djnz Mult8_Loop 
0bc3 c9			    ret 
0bc4			 
0bc4			 
0bc4			 
0bc4			 
0bc4			 
0bc4			 
0bc4			 
0bc4			 
0bc4			;;http://z80-heaven.wikidot.com/math 
0bc4			;;This divides DE by BC, storing the result in DE, remainder in HL 
0bc4			; 
0bc4			;DE_Div_BC:          ;1281-2x, x is at most 16 
0bc4			;     ld a,16        ;7 
0bc4			;     ld hl,0        ;10 
0bc4			;     jp $+5         ;10 
0bc4			;.DivLoop: 
0bc4			;       add hl,bc    ;-- 
0bc4			;       dec a        ;64 
0bc4			;       jr z,.DivLoopEnd        ;86 
0bc4			; 
0bc4			;       sla e        ;128 
0bc4			;       rl d         ;128 
0bc4			;       adc hl,hl    ;240 
0bc4			;       sbc hl,bc    ;240 
0bc4			;       jr nc,.DivLoop ;23|21 
0bc4			;       inc e        ;-- 
0bc4			;       jp .DivLoop+1 
0bc4			; 
0bc4			;.DivLoopEnd: 
0bc4			 
0bc4			;HL_Div_C: 
0bc4			;Inputs: 
0bc4			;     HL is the numerator 
0bc4			;     C is the denominator 
0bc4			;Outputs: 
0bc4			;     A is the remainder 
0bc4			;     B is 0 
0bc4			;     C is not changed 
0bc4			;     DE is not changed 
0bc4			;     HL is the quotient 
0bc4			; 
0bc4			;       ld b,16 
0bc4			;       xor a 
0bc4			;         add hl,hl 
0bc4			;         rla 
0bc4			;         cp c 
0bc4			;         jr c,$+4 
0bc4			;           inc l 
0bc4			;           sub c 
0bc4			;         djnz $-7 
0bc4			 
0bc4			; https://plutiedev.com/z80-add-8bit-to-16bit 
0bc4			 
0bc4			addatohl: 
0bc4 85			    add   a, l    ; A = A+L 
0bc5 6f			    ld    l, a    ; L = A+L 
0bc6 8c			    adc   a, h    ; A = A+L+H+carry 
0bc7 95			    sub   l       ; A = H+carry 
0bc8 67			    ld    h, a    ; H = H+carry 
0bc9 c9			ret 
0bca			 
0bca			addatode: 
0bca 83			    add   a, e    ; A = A+L 
0bcb 5f			    ld    e, a    ; L = A+L 
0bcc 8a			    adc   a, d    ; A = A+L+H+carry 
0bcd 93			    sub   e       ; A = H+carry 
0bce 57			    ld    d, a    ; H = H+carry 
0bcf c9			ret 
0bd0			 
0bd0			 
0bd0			addatobc: 
0bd0 81			    add   a, c    ; A = A+L 
0bd1 4f			    ld    c, a    ; L = A+L 
0bd2 88			    adc   a, b    ; A = A+L+H+carry 
0bd3 91			    sub   c       ; A = H+carry 
0bd4 47			    ld    b, a    ; H = H+carry 
0bd5 c9			ret 
0bd6			 
0bd6			subafromhl: 
0bd6			   ; If A=0 do nothing 
0bd6			    ; Otherwise flip A's sign. Since 
0bd6			    ; the upper byte becomes -1, also 
0bd6			    ; substract 1 from H. 
0bd6 ed 44		    neg 
0bd8 ca e1 0b		    jp    z, Skip 
0bdb 25			    dec   h 
0bdc			     
0bdc			    ; Now add the low byte as usual 
0bdc			    ; Two's complement takes care of 
0bdc			    ; ensuring the result is correct 
0bdc 85			    add   a, l 
0bdd 6f			    ld    l, a 
0bde 8c			    adc   a, h 
0bdf 95			    sub   l 
0be0 67			    ld    h, a 
0be1			Skip: 
0be1 c9				ret 
0be2			 
0be2			 
0be2			; compare hl and de 
0be2			; returns:  
0be2			; if hl = de, z=1, s=0, c0=0 
0be2			; if hl > de, z=0, s=0, c=0 
0be2			; if hl < de, z=0, s=1, c=1 
0be2			cmp16:	 
0be2 b7				or a 
0be3 ed 52			sbc hl,de 
0be5 e0				ret po 
0be6 7c				ld a,h 
0be7 1f				rra 
0be8 ee 40			xor 01000000B 
0bea 37				scf 
0beb 8f				adc a,a 
0bec c9				ret 
0bed			 
0bed			 
0bed			; test if hl contains zero   - A is destroyed 
0bed			 
0bed			ishlzero:    
0bed b7				or a     ; reset flags 
0bee 7c				ld a, h 
0bef b5				or l        	 
0bf0			 
0bf0 c9				ret 
0bf1			 
0bf1			 
0bf1			 
0bf1			 
0bf1			if FORTH_ENABLE_FLOATMATH 
0bf1			;include "float/bbcmath.z80" 
0bf1			include "float/lpfpcalc.asm" 
0bf1			endif 
0bf1			 
0bf1			 
0bf1			; eof 
0bf1			 
# End of file firmware_maths.asm
0bf1			include "firmware_strings.asm"   ; string handling  
0bf1			 
0bf1			 
0bf1			; TODO string len 
0bf1			; input text string, end on cr with zero term 
0bf1			; a offset into frame buffer to start prompt 
0bf1			; d is max length 
0bf1			; e is display size TODO 
0bf1			; c is current cursor position 
0bf1			; hl is ptr to where string will be stored 
0bf1			 
0bf1			 
0bf1			; TODO check limit of buffer for new inserts 
0bf1			; TODO check insert does not push beyond buffer 
0bf1			; TODO scroll in a limited display area 
0bf1			; TODO scroll whole screen on page wrap 
0bf1			 
0bf1			 
0bf1			; TODO handle KEY_PREVWORD 
0bf1			; TODO handle KEY_NEXTWORD 
0bf1			; TODO handle KEY_HOME 
0bf1			; TODO handle KEY_END 
0bf1			; TODO use LCD cursor? 
0bf1			 
0bf1 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0bf4 81					add c 
0bf5 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0bf8 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
0bfb 79					ld a, c 
0bfc cd c4 0b				call addatohl 
0bff 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0c02 7a					ld a,d 
0c03 32 6c ee			        ld (input_size), a       ; save length of input area 
0c06 79					ld a, c 
0c07 32 5b ee				ld (input_cursor),a      ; init cursor start position  
0c0a 7b					ld a,e 
0c0b 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0c0e					 
0c0e					 
0c0e			 
0c0e			;		ld a,(input_ptr) 
0c0e			;		ld (input_under_cursor),a 	; save what is under the cursor 
0c0e			 
0c0e			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0c0e					; init cursor shape if not set by the cin routines 
0c0e 21 ca eb				ld hl, cursor_shape 
0c11 3e ff				ld a, 255 
0c13 77					ld (hl), a 
0c14 23					inc hl 
0c15 3e 00				ld a, 0 
0c17 77					ld (hl), a 
0c18			 
0c18 3e 0f				ld a, CUR_BLINK_RATE 
0c1a 32 66 ee				ld (input_cur_flash), a 
0c1d 3e 01				ld a, 1 
0c1f 32 65 ee				ld (input_cur_onoff),a 
0c22			 
0c22			;	if DEBUG_INPUT 
0c22			;		push af 
0c22			;		ld a, 'I' 
0c22			;		ld (debug_mark),a 
0c22			;		pop af 
0c22			;		CALLMONITOR 
0c22			;	endif 
0c22			.is1:		; main entry loop 
0c22			 
0c22			 
0c22			 
0c22					; pause 1ms 
0c22			 
0c22 3e 01				ld a, 1 
0c24 cd ee 08				call aDelayInMS 
0c27			 
0c27					; dec flash counter 
0c27 3a 66 ee				ld a, (input_cur_flash) 
0c2a 3d					dec a 
0c2b 32 66 ee				ld (input_cur_flash), a 
0c2e fe 00				cp 0 
0c30 20 0d				jr nz, .nochgstate 
0c32			 
0c32			 
0c32					; change state 
0c32 3a 65 ee				ld a,(input_cur_onoff) 
0c35 ed 44				neg 
0c37 32 65 ee				ld (input_cur_onoff),a 
0c3a			 
0c3a			 
0c3a					; reset on change of state 
0c3a 3e 0f				ld a, CUR_BLINK_RATE 
0c3c 32 66 ee				ld (input_cur_flash), a 
0c3f			 
0c3f			.nochgstate: 
0c3f					 
0c3f					 
0c3f			 
0c3f					; display cursor  
0c3f			 
0c3f			;		ld hl, (input_start) 
0c3f			;		ld a, (input_cursor) 
0c3f			;		call addatohl 
0c3f			 
0c3f					; get char under cursor and replace with cursor 
0c3f 2a 6f ee		ld hl, (input_ptr) 
0c42			;		ld a, (hl) 
0c42			;		ld (input_under_cursor),a 
0c42			;		ld a, '_' 
0c42			;		ld (hl), a 
0c42			 
0c42					; display string 
0c42			 
0c42 ed 5b 6d ee			ld de, (input_start) 
0c46 3a 6a ee				ld a, (input_at_pos) 
0c49 cd aa 09				call str_at_display 
0c4c			;	        call update_display 
0c4c			 
0c4c					; find place to put the cursor 
0c4c			;		add h 
0c4c			;		ld l, display_row_1 
0c4c			;		sub l 
0c4c			; (input_at_pos) 
0c4c					;ld c, a 
0c4c			;		ld a, (input_cursor) 
0c4c			;		ld l, (input_at_pos) 
0c4c			;		;ld b, h 
0c4c			;		add l 
0c4c			;		ld (input_at_cursor),a 
0c4c					;ld l,h 
0c4c			 
0c4c			;		ld h, 0 
0c4c			;		ld l,(input_at_pos) 
0c4c			;		ld a, (input_cursor) 
0c4c			;		call addatohl 
0c4c			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c4c			;		call subafromhl 
0c4c			;		ld a,l 
0c4c			;		ld (input_at_cursor), a 
0c4c			 
0c4c				if DEBUG_INPUT 
0c4c					ld a, (hardware_diag) 
0c4c					cp 0 
0c4c					jr z, .skip_input_diag 
0c4c			 
0c4c					ld a,(input_at_pos) 
0c4c					ld hl, LFSRSeed 
0c4c					call hexout 
0c4c					ld a, (input_cursor) 
0c4c					ld hl, LFSRSeed+2 
0c4c					call hexout 
0c4c					ld a,(input_at_cursor) 
0c4c					ld hl, LFSRSeed+4 
0c4c					call hexout 
0c4c			 
0c4c					ld a,(input_cur_onoff) 
0c4c					ld hl, LFSRSeed+6 
0c4c					call hexout 
0c4c			 
0c4c					ld a,(input_cur_flash) 
0c4c					ld hl, LFSRSeed+8 
0c4c					call hexout 
0c4c			 
0c4c					ld a,(input_len) 
0c4c					ld hl, LFSRSeed+10 
0c4c					call hexout 
0c4c					ld hl, LFSRSeed+12 
0c4c					ld a, 0 
0c4c					ld (hl),a 
0c4c					ld a, display_row_4 
0c4c					ld de, LFSRSeed 
0c4c					call str_at_display 
0c4c					.skip_input_diag: 
0c4c				endif 
0c4c			 
0c4c					; decide on if we are showing the cursor this time round 
0c4c			 
0c4c 3a 65 ee				ld a, (input_cur_onoff) 
0c4f fe ff				cp 255 
0c51 28 13				jr z, .skipcur 
0c53			 
0c53			 
0c53 3a 68 ee				ld a,(input_at_cursor) 
0c56 11 ca eb				ld de, cursor_shape 
0c59 cd aa 09				call str_at_display 
0c5c			 
0c5c					; save length of current input string 
0c5c 2a 6d ee				ld hl, (input_start) 
0c5f cd 22 10				call strlenz 
0c62 7d					ld a,l 
0c63 32 60 ee				ld (input_len),a 
0c66			 
0c66			.skipcur: 
0c66			 
0c66 cd ba 09			        call update_display 
0c69					 
0c69			 
0c69			 
0c69					; wait 
0c69				 
0c69					; TODO loop without wait to flash the cursor and char under cursor	 
0c69 cd 1f 59				call cin    ; _wait 
0c6c			 
0c6c fe 00				cp 0 
0c6e ca 22 0c				jp z, .is1 
0c71			 
0c71					; get ptr to char to input into 
0c71			 
0c71 4f					ld c,a 
0c72 2a 6d ee				ld hl, (input_start) 
0c75 3a 5b ee				ld a, (input_cursor) 
0c78 cd c4 0b				call addatohl 
0c7b 22 6f ee				ld (input_ptr), hl 
0c7e 79					ld a,c 
0c7f			 
0c7f					; replace char under cursor 
0c7f			 
0c7f			;		ld hl, (input_ptr) 
0c7f			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0c7f			;		ld (hl), a 
0c7f			 
0c7f			;	if DEBUG_INPUT 
0c7f			;		push af 
0c7f			;		ld a, 'i' 
0c7f			;		ld (debug_mark),a 
0c7f			;		pop af 
0c7f			;		CALLMONITOR 
0c7f			;	endif 
0c7f fe 0e				cp KEY_HOME 
0c81 20 0e				jr nz, .iske 
0c83			 
0c83 3a 6a ee				ld a, (input_at_pos) 
0c86 32 68 ee				ld (input_at_cursor),a 
0c89 3e 00				ld a, 0 
0c8b 32 5b ee				ld (input_cursor), a 
0c8e c3 22 0c				jp .is1 
0c91					 
0c91 fe 0f		.iske:		cp KEY_END 
0c93 20 03				jr nz, .isknw 
0c95 c3 22 0c				jp .is1 
0c98			 
0c98 fe 06		.isknw:		cp KEY_NEXTWORD 
0c9a 20 1b				jr nz, .iskpw 
0c9c			 
0c9c 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
0c9f 7e					ld a,(hl)	 
0ca0 fe 00				cp 0 
0ca2 ca 22 0c				jp z, .is1    ; end of string 
0ca5 fe 20				cp ' ' 
0ca7 ca 22 0c				jp z, .is1    ; end of word 
0caa 23					inc hl 
0cab 22 6f ee				ld (input_ptr), hl 
0cae 3a 68 ee				ld a, (input_at_cursor) 
0cb1 3c					inc a 
0cb2 32 68 ee				ld (input_at_cursor), a 
0cb5 18 e5				jr .isknwm 
0cb7			 
0cb7 fe 07		.iskpw:		cp KEY_PREVWORD 
0cb9 20 1b				jr nz, .iskl 
0cbb			.iskpwm:	 
0cbb 2a 6f ee				ld hl, (input_ptr) 
0cbe 7e					ld a,(hl)	 
0cbf fe 00				cp 0  
0cc1 ca 22 0c				jp z, .is1    ; end of string 
0cc4 fe 20				cp ' ' 
0cc6 ca 22 0c				jp z, .is1    ; end of word 
0cc9 2b					dec hl 
0cca 22 6f ee				ld (input_ptr), hl 
0ccd 3a 68 ee				ld a, (input_at_cursor) 
0cd0 3d					dec a 
0cd1 32 68 ee				ld (input_at_cursor), a 
0cd4 18 e5				jr .iskpwm 
0cd6			 
0cd6			 
0cd6 fe 0b		.iskl:		cp KEY_LEFT 
0cd8 20 27				jr nz, .isk1 
0cda			 
0cda 3a 5b ee				ld a, (input_cursor) 
0cdd			 
0cdd fe 00				cp 0 
0cdf ca 22 0c				jp z, .is1 		; at start of line to ignore  
0ce2			 
0ce2 3d					dec  a 		; TODO check underflow 
0ce3 32 5b ee				ld (input_cursor), a 
0ce6			 
0ce6 2a 6f ee				ld hl, (input_ptr) 
0ce9 2b					dec hl 
0cea 22 6f ee				ld (input_ptr), hl 
0ced					 
0ced 3a 68 ee				ld a, (input_at_cursor) 
0cf0 3d					dec a 
0cf1 32 68 ee				ld (input_at_cursor), a 
0cf4			 
0cf4 3e 01				ld a, 1		; show cursor moving 
0cf6 32 65 ee				ld (input_cur_onoff),a 
0cf9 3e 0f				ld a, CUR_BLINK_RATE 
0cfb 32 66 ee				ld (input_cur_flash), a 
0cfe			 
0cfe c3 22 0c				jp .is1 
0d01			 
0d01 fe 0c		.isk1:		cp KEY_RIGHT 
0d03 20 2a				jr nz, .isk2 
0d05			 
0d05 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0d08 5f					ld e,a 
0d09 3a 5b ee				ld a, (input_cursor) 
0d0c bb					cp e 
0d0d ca 22 0c				jp z, .is1		; at the end of string so dont go right 
0d10			 
0d10 3c					inc  a 		; TODO check overflow 
0d11 32 5b ee				ld (input_cursor), a 
0d14			 
0d14 3a 68 ee				ld a, (input_at_cursor) 
0d17 3c					inc a 
0d18 32 68 ee				ld (input_at_cursor), a 
0d1b			 
0d1b 2a 6f ee				ld hl, (input_ptr) 
0d1e 23					inc hl 
0d1f 22 6f ee				ld (input_ptr), hl 
0d22			 
0d22 3e 01				ld a, 1		; show cursor moving 
0d24 32 65 ee				ld (input_cur_onoff),a 
0d27 3e 0f				ld a, CUR_BLINK_RATE 
0d29 32 66 ee				ld (input_cur_flash), a 
0d2c			 
0d2c c3 22 0c				jp .is1 
0d2f			 
0d2f fe 05		.isk2:		cp KEY_UP 
0d31			 
0d31 20 26				jr nz, .isk3 
0d33			 
0d33					; swap last command with the current on 
0d33			 
0d33					; move cursor to start of string 
0d33 2a 6d ee				ld hl, (input_start) 
0d36 22 6f ee				ld (input_ptr), hl 
0d39			 
0d39 3a 6a ee				ld a, (input_at_pos) 
0d3c 32 68 ee				ld (input_at_cursor), a 
0d3f			 
0d3f 3e 00				ld a, 0 
0d41 32 5b ee				ld (input_cursor), a 
0d44					 
0d44					; swap input and last command buffers 
0d44			 
0d44 21 7e e6				ld hl, os_cli_cmd 
0d47 11 7d e7				ld de, os_last_cmd 
0d4a 06 ff				ld b, 255 
0d4c 7e			.swap1:		ld a, (hl) 
0d4d 4f					ld c,a 
0d4e 1a					ld a, (de) 
0d4f 77					ld (hl), a 
0d50 79					ld a,c 
0d51 12					ld (de),a 
0d52 23					inc hl 
0d53 13					inc de 
0d54 10 f6				djnz .swap1 
0d56			 
0d56			 
0d56			 
0d56			 
0d56			 
0d56 c3 22 0c				jp .is1 
0d59			 
0d59 fe 08		.isk3:		cp KEY_BS 
0d5b 20 3c				jr nz, .isk4 
0d5d			 
0d5d 3a 5b ee				ld a, (input_cursor) 
0d60			 
0d60 fe 00				cp 0 
0d62 ca 22 0c				jp z, .is1 		; at start of line to ignore  
0d65			 
0d65 3d					dec  a 		; TODO check underflow 
0d66 32 5b ee				ld (input_cursor), a 
0d69			 
0d69					; hl is source 
0d69					; de needs to be source - 1 
0d69			 
0d69			;		ld a, 0 
0d69			;		dec hl 
0d69			;		ld (hl), a 
0d69			 
0d69 2a 6f ee				ld hl, (input_ptr) 
0d6c 2b					dec hl 
0d6d 22 6f ee				ld (input_ptr), hl 
0d70			 
0d70					; shift all data 
0d70			 
0d70 e5					push hl 
0d71 23					inc hl 
0d72 d1					pop de 
0d73 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0d76 4f					ld c,a 
0d77 06 00				ld b,0 
0d79 ed b0				ldir  
0d7b			 
0d7b			 
0d7b			 
0d7b			 
0d7b 3a 68 ee				ld a, (input_at_cursor) 
0d7e 3d					dec a 
0d7f 32 68 ee				ld (input_at_cursor), a 
0d82			 
0d82			 
0d82 3e 01				ld a, 1		; show cursor moving 
0d84 32 65 ee				ld (input_cur_onoff),a 
0d87 3e 0f				ld a, CUR_BLINK_RATE 
0d89 32 66 ee				ld (input_cur_flash), a 
0d8c			 
0d8c					; remove char 
0d8c 3a 68 ee				ld a, (input_at_cursor) 
0d8f 3c					inc a 
0d90 11 1a 0e				ld de,.iblank 
0d93 cd aa 09				call str_at_display 
0d96			 
0d96 c3 22 0c				jp .is1 
0d99			 
0d99 fe 0d		.isk4:		cp KEY_CR 
0d9b 28 6c				jr z, .endinput 
0d9d			 
0d9d					; else add the key press to the end 
0d9d			 
0d9d 4f					ld c, a			; save key pressed 
0d9e			 
0d9e 7e					ld a,(hl)		; get what is currently under char 
0d9f			 
0d9f fe 00				cp 0			; we are at the end of the string 
0da1 20 2f				jr nz, .onchar 
0da3					 
0da3					; add a char to the end of the string 
0da3				 
0da3 71					ld (hl),c 
0da4 23					inc hl 
0da5			;		ld a,' ' 
0da5			;		ld (hl),a 
0da5			;		inc hl 
0da5 3e 00				ld a,0 
0da7 77					ld (hl),a 
0da8 2b					dec hl 
0da9			 
0da9 3a 5b ee				ld a, (input_cursor) 
0dac 3c					inc a				; TODO check max string length and scroll  
0dad 32 5b ee				ld (input_cursor), a		; inc cursor pos 
0db0							 
0db0 3a 68 ee				ld a, (input_at_cursor) 
0db3 3c					inc a 
0db4 32 68 ee				ld (input_at_cursor), a 
0db7			 
0db7 2a 6f ee				ld hl, (input_ptr) 
0dba 23					inc hl 
0dbb 22 6f ee				ld (input_ptr), hl 
0dbe			 
0dbe 2a 6f ee				ld hl, (input_ptr) 
0dc1 23					inc hl 
0dc2 22 6f ee				ld (input_ptr), hl 
0dc5			;	if DEBUG_INPUT 
0dc5			;		push af 
0dc5			;		ld a, '+' 
0dc5			;		ld (debug_mark),a 
0dc5			;		pop af 
0dc5			;		CALLMONITOR 
0dc5			;	endif 
0dc5 3e 01				ld a, 1		; show cursor moving 
0dc7 32 65 ee				ld (input_cur_onoff),a 
0dca 3e 0f				ld a, CUR_BLINK_RATE 
0dcc 32 66 ee				ld (input_cur_flash), a 
0dcf c3 22 0c				jp .is1 
0dd2					 
0dd2			 
0dd2			 
0dd2					; if on a char then insert 
0dd2			.onchar: 
0dd2			 
0dd2					; TODO over flow check: make sure insert does not blow out buffer 
0dd2			 
0dd2					; need to do some maths to use lddr 
0dd2			 
0dd2 e5					push hl   ; save char pos 
0dd3 c5					push bc 
0dd4			 
0dd4 2a 6d ee				ld hl, (input_start) 
0dd7 3a 60 ee				ld a, (input_len) 
0dda cd c4 0b				call addatohl  		; end of string 
0ddd 23					inc hl 
0dde 23					inc hl		; past zero term 
0ddf e5					push hl 
0de0 23					inc hl 
0de1 e5					push hl  
0de2			 
0de2								; start and end of lddr set, now how much to move? 
0de2			 
0de2							 
0de2 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0de5 47					ld b,a 
0de6 3a 60 ee				ld a,(input_len) 
0de9 5f					ld e,a 
0dea 90					sub b 
0deb 3c					inc a		;?? 
0dec 3c					inc a		;?? 
0ded 3c					inc a		;?? 
0dee			 
0dee 06 00				ld b,0 
0df0 4f					ld c,a 
0df1			 
0df1				if DEBUG_INPUT 
0df1					push af 
0df1					ld a, 'i' 
0df1					ld (debug_mark),a 
0df1					pop af 
0df1			;		CALLMONITOR 
0df1				endif 
0df1 d1					pop de 
0df2 e1					pop hl 
0df3				if DEBUG_INPUT 
0df3					push af 
0df3					ld a, 'I' 
0df3					ld (debug_mark),a 
0df3					pop af 
0df3			;		CALLMONITOR 
0df3				endif 
0df3 ed b8				lddr 
0df5				 
0df5			 
0df5			 
0df5					; TODO have a key for insert/overwrite mode???? 
0df5 c1					pop bc 
0df6 e1					pop hl 
0df7 71					ld (hl), c		; otherwise overwrite current char 
0df8					 
0df8			 
0df8			 
0df8			 
0df8 3a 5b ee				ld a, (input_cursor) 
0dfb 3c					inc  a 		; TODO check overflow 
0dfc 32 5b ee				ld (input_cursor), a 
0dff			 
0dff 3a 68 ee				ld a, (input_at_cursor) 
0e02 3c					inc a 
0e03 32 68 ee				ld (input_at_cursor), a 
0e06			 
0e06 c3 22 0c				jp .is1 
0e09			 
0e09			.endinput:	; TODO look for end of string 
0e09			 
0e09					; add trailing space for end of token 
0e09			 
0e09 2a 6d ee				ld hl, (input_start) 
0e0c 3a 60 ee				ld a,(input_len) 
0e0f cd c4 0b				call addatohl 
0e12 3e 20				ld a, ' ' 
0e14 77					ld (hl),a 
0e15					; TODO eof of parse marker 
0e15			 
0e15 23					inc hl 
0e16 3e 00				ld a, 0 
0e18 77					ld (hl),a 
0e19			 
0e19			 
0e19 c9					ret 
0e1a			 
0e1a .. 00		.iblank: db " ",0 
0e1c			 
0e1c			 
0e1c 32 6a ee		input_str_prev:	ld (input_at_pos), a 
0e1f 22 6d ee				ld (input_start), hl 
0e22 3e 01				ld a,1			; add cursor 
0e24 77					ld (hl),a 
0e25 23					inc hl 
0e26 3e 00				ld a,0 
0e28 77					ld (hl),a 
0e29 22 6f ee				ld (input_ptr), hl 
0e2c 7a					ld a,d 
0e2d 32 6c ee				ld (input_size), a 
0e30 3e 00				ld a,0 
0e32 32 5b ee				ld (input_cursor),a 
0e35			.instr1:	 
0e35			 
0e35					; TODO do block cursor 
0e35					; TODO switch cursor depending on the modifer key 
0e35			 
0e35					; update cursor shape change on key hold 
0e35			 
0e35 2a 6f ee				ld hl, (input_ptr) 
0e38 2b					dec hl 
0e39 3a ca eb				ld a,(cursor_shape) 
0e3c 77					ld (hl), a 
0e3d			 
0e3d					; display entered text 
0e3d 3a 6a ee				ld a,(input_at_pos) 
0e40 cd 34 58		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e43 ed 5b 6d ee	            	LD   de, (input_start) 
0e47 cd 29 58		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e4a			 
0e4a cd 1f 59				call cin 
0e4d fe 00				cp 0 
0e4f 28 e4				jr z, .instr1 
0e51			 
0e51					; proecess keyboard controls first 
0e51			 
0e51 2a 6f ee				ld hl,(input_ptr) 
0e54			 
0e54 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0e56 28 5a				jr z, .instrcr 
0e58			 
0e58 fe 08				cp KEY_BS 	; back space 
0e5a 20 0f				jr nz, .instr2 
0e5c					; process back space 
0e5c			 
0e5c					; TODO stop back space if at start of string 
0e5c 2b					dec hl 
0e5d 2b					dec hl ; to over write cursor 
0e5e 3a ca eb				ld a,(cursor_shape) 
0e61					;ld a,0 
0e61 77					ld (hl),a 
0e62 23					inc hl 
0e63 3e 20				ld a," " 
0e65 77					ld (hl),a 
0e66 22 6f ee				ld (input_ptr),hl 
0e69					 
0e69			 
0e69 18 ca				jr .instr1 
0e6b			 
0e6b fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0e6d 20 06				jr nz, .instr3 
0e6f 2b					dec hl 
0e70 22 6f ee				ld (input_ptr),hl 
0e73 18 c0				jr .instr1 
0e75				 
0e75 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0e77 20 06				jr nz, .instr4 
0e79 23					inc hl 
0e7a 22 6f ee				ld (input_ptr),hl 
0e7d 18 b6				jr .instr1 
0e7f			 
0e7f fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0e81 20 06				jr nz, .instr5 
0e83 2b					dec hl 
0e84 22 6f ee				ld (input_ptr),hl 
0e87 18 ac				jr .instr1 
0e89			 
0e89 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0e8b 20 06				jr nz, .instr6 
0e8d 2b					dec hl 
0e8e 22 6f ee				ld (input_ptr),hl 
0e91 18 a2				jr .instr1 
0e93 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0e95 20 0b				jr nz, .instrnew 
0e97			 
0e97 21 57 e3			ld hl, scratch 
0e9a 11 7d e7			ld de, os_last_cmd 
0e9d cd bb 0e			call strcpy 
0ea0 18 93				jr .instr1 
0ea2			 
0ea2			 
0ea2			.instrnew:	; no special key pressed to see if we have room to store it 
0ea2			 
0ea2					; TODO do string size test 
0ea2			 
0ea2 2b					dec hl ; to over write cursor 
0ea3 77					ld (hl),a 
0ea4 23					inc hl 
0ea5 3a ca eb				ld a,(cursor_shape) 
0ea8 77					ld (hl),a 
0ea9 23					inc hl 
0eaa 3e 00				ld a,0 
0eac 77					ld (hl),a 
0ead			 
0ead 22 6f ee				ld (input_ptr),hl 
0eb0					 
0eb0 18 83				jr .instr1 
0eb2 2b			.instrcr:	dec hl		; remove cursor 
0eb3 3e 20				ld a,' '	; TODO add a trailing space for safety 
0eb5 77					ld (hl),a 
0eb6 23					inc hl 
0eb7 3e 00				ld a,0 
0eb9 77					ld (hl),a 
0eba			 
0eba			 
0eba					; if at end of line scroll up    
0eba					; TODO detecting only end of line 4 for scroll up  
0eba			 
0eba					;ld   
0eba			 
0eba c9					ret 
0ebb			 
0ebb			 
0ebb			; strcpy hl = dest, de source 
0ebb			 
0ebb 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ebc b7			            OR   A              ;Null terminator? 
0ebd c8			            RET  Z              ;Yes, so finished 
0ebe 1a					ld a,(de) 
0ebf 77					ld (hl),a 
0ec0 13			            INC  DE             ;Point to next character 
0ec1 23					inc hl 
0ec2 18 f7		            JR   strcpy       ;Repeat 
0ec4 c9					ret 
0ec5			 
0ec5			 
0ec5			; TODO string_at  
0ec5			; pass string which starts with lcd offset address and then null term string 
0ec5			 
0ec5			; TODO string to dec 
0ec5			; TODO string to hex 
0ec5			; TODO byte to string hex 
0ec5			; TODO byte to string dec 
0ec5			 
0ec5			 
0ec5			 
0ec5			; from z80uartmonitor 
0ec5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ec5			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0ec5			; pass hl for where to put the text 
0ec5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ec5 c5			hexout:	PUSH BC 
0ec6 f5					PUSH AF 
0ec7 47					LD B, A 
0ec8					; Upper nybble 
0ec8 cb 3f				SRL A 
0eca cb 3f				SRL A 
0ecc cb 3f				SRL A 
0ece cb 3f				SRL A 
0ed0 cd e0 0e				CALL tohex 
0ed3 77					ld (hl),a 
0ed4 23					inc hl	 
0ed5					 
0ed5					; Lower nybble 
0ed5 78					LD A, B 
0ed6 e6 0f				AND 0FH 
0ed8 cd e0 0e				CALL tohex 
0edb 77					ld (hl),a 
0edc 23					inc hl	 
0edd					 
0edd f1					POP AF 
0ede c1					POP BC 
0edf c9					RET 
0ee0					 
0ee0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ee0			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ee0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ee0			tohex: 
0ee0 e5					PUSH HL 
0ee1 d5					PUSH DE 
0ee2 16 00				LD D, 0 
0ee4 5f					LD E, A 
0ee5 21 ed 0e				LD HL, .DATA 
0ee8 19					ADD HL, DE 
0ee9 7e					LD A, (HL) 
0eea d1					POP DE 
0eeb e1					POP HL 
0eec c9					RET 
0eed			 
0eed			.DATA: 
0eed 30					DEFB	30h	; 0 
0eee 31					DEFB	31h	; 1 
0eef 32					DEFB	32h	; 2 
0ef0 33					DEFB	33h	; 3 
0ef1 34					DEFB	34h	; 4 
0ef2 35					DEFB	35h	; 5 
0ef3 36					DEFB	36h	; 6 
0ef4 37					DEFB	37h	; 7 
0ef5 38					DEFB	38h	; 8 
0ef6 39					DEFB	39h	; 9 
0ef7 41					DEFB	41h	; A 
0ef8 42					DEFB	42h	; B 
0ef9 43					DEFB	43h	; C 
0efa 44					DEFB	44h	; D 
0efb 45					DEFB	45h	; E 
0efc 46					DEFB	46h	; F 
0efd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0efd			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0efd			;;    subtract $30, if result > 9 then subtract $7 more 
0efd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0efd			atohex: 
0efd d6 30				SUB $30 
0eff fe 0a				CP 10 
0f01 f8					RET M		; If result negative it was 0-9 so we're done 
0f02 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0f04 c9					RET		 
0f05			 
0f05			 
0f05			 
0f05			 
0f05			; Get 2 ASCII characters as hex byte from pointer in hl 
0f05			 
0f05			BYTERD: 
0f05 16 00			LD	D,00h		;Set up 
0f07 cd 0f 0f			CALL	HEXCON		;Get byte and convert to hex 
0f0a 87				ADD	A,A		;First nibble so 
0f0b 87				ADD	A,A		;multiply by 16 
0f0c 87				ADD	A,A		; 
0f0d 87				ADD	A,A		; 
0f0e 57				LD	D,A		;Save hi nibble in D 
0f0f			HEXCON: 
0f0f 7e				ld a, (hl)		;Get next chr 
0f10 23				inc hl 
0f11 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f13 fe 0a			CP	00Ah		;Is it 0-9 ? 
0f15 38 02			JR	C,NALPHA	;If so miss next bit 
0f17 d6 07			SUB	007h		;Else convert alpha 
0f19			NALPHA: 
0f19 b2				OR	D		;Add hi nibble back 
0f1a c9				RET			; 
0f1b			 
0f1b			 
0f1b			; 
0f1b			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f1b			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f1b			; characters (0-9a-f) are accepted. 
0f1b			; 
0f1b			;get_word        push    af 
0f1b			;                call    get_byte        ; Get the upper byte 
0f1b			;                ld      h, a 
0f1b			;                call    get_byte        ; Get the lower byte 
0f1b			;                ld      l, a 
0f1b			;                pop     af 
0f1b			;                ret 
0f1b			; 
0f1b			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f1b			; the routine get_nibble is used only valid characters are accepted - the  
0f1b			; input routine only accepts characters 0-9a-f. 
0f1b			; 
0f1b c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f1c 7e					ld a,(hl) 
0f1d 23					inc hl 
0f1e cd 43 0f		                call    nibble2val      ; Get upper nibble 
0f21 cb 07		                rlc     a 
0f23 cb 07		                rlc     a 
0f25 cb 07		                rlc     a 
0f27 cb 07		                rlc     a 
0f29 47			                ld      b, a            ; Save upper four bits 
0f2a 7e					ld a,(hl) 
0f2b cd 43 0f		                call    nibble2val      ; Get lower nibble 
0f2e b0			                or      b               ; Combine both nibbles 
0f2f c1			                pop     bc              ; Restore B (and C) 
0f30 c9			                ret 
0f31			; 
0f31			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f31			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f31			; to the serial line interface. The lower 4 bits of A contain the value of  
0f31			; that particular digit. 
0f31			; 
0f31			;get_nibble      ld a,(hl)           ; Read a character 
0f31			;                call    to_upper        ; Convert to upper case 
0f31			;                call    is_hex          ; Was it a hex digit? 
0f31			;                jr      nc, get_nibble  ; No, get another character 
0f31			 ;               call    nibble2val      ; Convert nibble to value 
0f31			 ;               call    print_nibble 
0f31			 ;               ret 
0f31			; 
0f31			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f31			; A valid hexadecimal digit is denoted by a set C flag. 
0f31			; 
0f31			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f31			;                ret     nc              ; Yes 
0f31			;                cp      '0'             ; Less than '0'? 
0f31			;                jr      nc, is_hex_1    ; No, continue 
0f31			;                ccf                     ; Complement carry (i.e. clear it) 
0f31			;                ret 
0f31			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f31			;                ret     c               ; Yes 
0f31			;                cp      'A'             ; Less than 'A'? 
0f31			;                jr      nc, is_hex_2    ; No, continue 
0f31			;                ccf                     ; Yes - clear carry and return 
0f31			;                ret 
0f31			;is_hex_2        scf                     ; Set carry 
0f31			;                ret 
0f31			; 
0f31			; Convert a single character contained in A to upper case: 
0f31			; 
0f31 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f33 d8			                ret     c 
0f34 fe 7b		                cp      'z' + 1         ; > 'z'? 
0f36 d0			                ret     nc              ; Nothing to do, either 
0f37 e6 5f		                and     $5f             ; Convert to upper case 
0f39 c9			                ret 
0f3a			 
0f3a			 
0f3a			to_lower: 
0f3a			 
0f3a			   ; if char is in [A-Z] make it lower case 
0f3a			 
0f3a			   ; enter : a = char 
0f3a			   ; exit  : a = lower case char 
0f3a			   ; uses  : af 
0f3a			 
0f3a fe 41		   cp 'A' 
0f3c d8			   ret c 
0f3d			    
0f3d fe 5b		   cp 'Z'+1 
0f3f d0			   ret nc 
0f40			    
0f40 f6 20		   or $20 
0f42 c9			   ret 
0f43			 
0f43			; 
0f43			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f43			; corresponding value in A. 
0f43			; 
0f43 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f45 38 02		                jr      c, nibble2val_1 ; Yes 
0f47 d6 07		                sub     7               ; Adjust for A-F 
0f49 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f4b e6 0f		                and     $f              ; Only return lower 4 bits 
0f4d c9			                ret 
0f4e			; 
0f4e			; Print_nibble prints a single hex nibble which is contained in the lower  
0f4e			; four bits of A: 
0f4e			; 
0f4e			;print_nibble    push    af              ; We won't destroy the contents of A 
0f4e			;                and     $f              ; Just in case... 
0f4e			;                add     a, '0'             ; If we have a digit we are done here. 
0f4e			;                cp      '9' + 1         ; Is the result > 9? 
0f4e			;                jr      c, print_nibble_1 
0f4e			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f4e			;print_nibble_1  call    putc            ; Print the nibble and 
0f4e			;                pop     af              ; restore the original value of A 
0f4e			;                ret 
0f4e			;; 
0f4e			;; Send a CR/LF pair: 
0f4e			; 
0f4e			;crlf            push    af 
0f4e			;                ld      a, cr 
0f4e			;                call    putc 
0f4e			;                ld      a, lf 
0f4e			;                call    putc 
0f4e			;                pop     af 
0f4e			;                ret 
0f4e			; 
0f4e			; Print_word prints the four hex digits of a word to the serial line. The  
0f4e			; word is expected to be in HL. 
0f4e			; 
0f4e			;print_word      push    hl 
0f4e			;                push    af 
0f4e			;                ld      a, h 
0f4e			;                call    print_byte 
0f4e			;                ld      a, l 
0f4e			;                call    print_byte 
0f4e			;                pop     af 
0f4e			;                pop     hl 
0f4e			;                ret 
0f4e			; 
0f4e			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f4e			; The byte to be printed is expected to be in A. 
0f4e			; 
0f4e			;print_byte      push    af              ; Save the contents of the registers 
0f4e			;                push    bc 
0f4e			;                ld      b, a 
0f4e			;                rrca 
0f4e			;                rrca 
0f4e			;                rrca 
0f4e			;                rrca 
0f4e			;                call    print_nibble    ; Print high nibble 
0f4e			;                ld      a, b 
0f4e			;                call    print_nibble    ; Print low nibble 
0f4e			;                pop     bc              ; Restore original register contents 
0f4e			;                pop     af 
0f4e			;                ret 
0f4e			 
0f4e			 
0f4e			 
0f4e			 
0f4e			 
0f4e			fourehexhl:  
0f4e 7e				ld a,(hl) 
0f4f cd fd 0e			call atohex 
0f52 cb 3f				SRL A 
0f54 cb 3f				SRL A 
0f56 cb 3f				SRL A 
0f58 cb 3f				SRL A 
0f5a 47				ld b, a 
0f5b 23				inc hl 
0f5c 7e				ld a,(hl) 
0f5d 23				inc hl 
0f5e cd fd 0e			call atohex 
0f61 80				add b 
0f62 57				ld d,a 
0f63 7e				ld a,(hl) 
0f64 cd fd 0e			call atohex 
0f67 cb 3f				SRL A 
0f69 cb 3f				SRL A 
0f6b cb 3f				SRL A 
0f6d cb 3f				SRL A 
0f6f 47				ld b, a 
0f70 23				inc hl 
0f71 7e				ld a,(hl) 
0f72 23				inc hl 
0f73 cd fd 0e			call atohex 
0f76 80				add b 
0f77 5f				ld e, a 
0f78 d5				push de 
0f79 e1				pop hl 
0f7a c9				ret 
0f7b			 
0f7b			; pass hl. returns z set if the byte at hl is a digit 
0f7b			;isdigithl:  
0f7b			;	push bc 
0f7b			;	ld a,(hl) 
0f7b			;	cp ':' 
0f7b			;	jr nc, .isdf 		; > 
0f7b			;	cp '0' 
0f7b			;	jr c, .isdf		; < 
0f7b			; 
0f7b			;	; TODO find a better way to set z 
0f7b			; 
0f7b			;	ld b,a 
0f7b			;	cp b 
0f7b			;	pop bc 
0f7b			;	ret 
0f7b			; 
0f7b			;.isdf:	; not digit so clear z 
0f7b			; 
0f7b			;	; TODO find a better way to unset z 
0f7b			; 
0f7b			;	ld b,a 
0f7b			;	inc b 
0f7b			;	cp b 
0f7b			; 
0f7b			;	pop bc 
0f7b			;	ret 
0f7b				 
0f7b				 
0f7b			 
0f7b			 
0f7b			; pass hl as the four byte address to load 
0f7b			 
0f7b			get_word_hl:  
0f7b e5				push hl 
0f7c cd 1b 0f			call get_byte 
0f7f				 
0f7f 47				ld b, a 
0f80			 
0f80 e1				pop hl 
0f81 23				inc hl 
0f82 23				inc hl 
0f83			 
0f83			; TODO not able to handle a-f  
0f83 7e				ld a,(hl) 
0f84			;	;cp ':' 
0f84			;	cp 'g' 
0f84			;	jr nc, .single_byte_hl 		; > 
0f84			;	cp 'G' 
0f84			;	jr nc, .single_byte_hl 		; > 
0f84			;	cp '0' 
0f84			;	jr c, .single_byte_hl		; < 
0f84			 
0f84				;call isdigithl 
0f84 fe 00			cp 0 
0f86 28 06			jr z, .single_byte_hl 
0f88			 
0f88			.getwhln:   ; hex word so get next byte 
0f88			 
0f88 cd 1b 0f			call get_byte 
0f8b 6f				ld l, a 
0f8c 60				ld h,b 
0f8d c9				ret 
0f8e 68			.single_byte_hl:   ld l,b 
0f8f 26 00				ld h,0 
0f91 c9					ret 
0f92			 
0f92			 
0f92			 
0f92			 
0f92 21 11 17			ld hl,asc+1 
0f95			;	ld a, (hl) 
0f95			;	call nibble2val 
0f95 cd 1b 0f			call get_byte 
0f98			 
0f98			;	call fourehexhl 
0f98 32 8b e3			ld (scratch+52),a 
0f9b				 
0f9b 21 89 e3			ld hl,scratch+50 
0f9e 22 7a e6			ld (os_cur_ptr),hl 
0fa1			 
0fa1 c9				ret 
0fa2			 
0fa2			 
0fa2			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0fa2			 
0fa2			; Decimal Unsigned Version 
0fa2			 
0fa2			;Number in a to decimal ASCII 
0fa2			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0fa2			;Example: display a=56 as "056" 
0fa2			;input: a = number 
0fa2			;Output: a=0,value of a in the screen 
0fa2			;destroys af,bc (don't know about hl and de) 
0fa2			DispAToASCII: 
0fa2 0e 9c			ld	c,-100 
0fa4 cd ae 0f			call	.Na1 
0fa7 0e f6			ld	c,-10 
0fa9 cd ae 0f			call	.Na1 
0fac 0e ff			ld	c,-1 
0fae 06 2f		.Na1:	ld	b,'0'-1 
0fb0 04			.Na2:	inc	b 
0fb1 81				add	a,c 
0fb2 38 fc			jr	c,.Na2 
0fb4 91				sub	c		;works as add 100/10/1 
0fb5 f5				push af		;safer than ld c,a 
0fb6 78				ld	a,b		;char is in b 
0fb7			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0fb7 f1				pop af		;safer than ld a,c 
0fb8 c9				ret 
0fb9			 
0fb9			; Decimal Signed Version 
0fb9			 
0fb9			; DispA 
0fb9			; -------------------------------------------------------------- 
0fb9			; Converts a signed integer value to a zero-terminated ASCII 
0fb9			; string representative of that value (using radix 10). 
0fb9			; -------------------------------------------------------------- 
0fb9			; INPUTS: 
0fb9			;     HL     Value to convert (two's complement integer). 
0fb9			;     DE     Base address of string destination. (pointer). 
0fb9			; -------------------------------------------------------------- 
0fb9			; OUTPUTS: 
0fb9			;     None 
0fb9			; -------------------------------------------------------------- 
0fb9			; REGISTERS/MEMORY DESTROYED 
0fb9			; AF HL 
0fb9			; -------------------------------------------------------------- 
0fb9			 
0fb9			;DispHLToASCII: 
0fb9			;   push    de 
0fb9			;   push    bc 
0fb9			; 
0fb9			;; Detect sign of HL. 
0fb9			;    bit    7, h 
0fb9			;    jr     z, ._DoConvert 
0fb9			; 
0fb9			;; HL is negative. Output '-' to string and negate HL. 
0fb9			;    ld     a, '-' 
0fb9			;    ld     (de), a 
0fb9			;    inc    de 
0fb9			; 
0fb9			;; Negate HL (using two's complement) 
0fb9			;    xor    a 
0fb9			;    sub    l 
0fb9			;    ld     l, a 
0fb9			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0fb9			;    sbc    a, h 
0fb9			;    ld     h, a 
0fb9			; 
0fb9			;; Convert HL to digit characters 
0fb9			;._DoConvert: 
0fb9			;    ld     b, 0     ; B will count character length of number 
0fb9			;-   ld     a, 10 
0fb9			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0fb9			;    push   af 
0fb9			;    inc    b 
0fb9			;    ld     a, h 
0fb9			;    or     l 
0fb9			;    jr     nz, - 
0fb9			; 
0fb9			;; Retrieve digits from stack 
0fb9			;-   pop    af 
0fb9			;    or     $30 
0fb9			;    ld     (de), a 
0fb9			;    inc    de 
0fb9			;    djnz   - 
0fb9			; 
0fb9			;; Terminate string with NULL 
0fb9			;    xor    a 
0fb9			;    ld     (de), a 
0fb9			; 
0fb9			;    pop    bc 
0fb9			;    pop    de 
0fb9			;    ret 
0fb9			 
0fb9			;Comments 
0fb9			; 
0fb9			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0fb9			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0fb9			;    Note that the output string will not be fixed-width. 
0fb9			; 
0fb9			;Example Usage 
0fb9			; 
0fb9			;    ld    hl, -1004 
0fb9			;    ld    de, OP1 
0fb9			;    call  DispA 
0fb9			;    ld    hl, OP1 
0fb9			;    syscall  PutS 
0fb9			 
0fb9			 
0fb9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fb9			 
0fb9			 
0fb9			;Converts an ASCII string to an unsigned 16-bit integer 
0fb9			;Quits when it reaches a non-decimal digit 
0fb9			 
0fb9			string_to_uint16: 
0fb9			atoui_16: 
0fb9			;Input: 
0fb9			;     DE points to the string 
0fb9			;Outputs: 
0fb9			;     HL is the result 
0fb9			;     A is the 8-bit value of the number 
0fb9			;     DE points to the byte after the number 
0fb9			;Destroys: 
0fb9			;     BC 
0fb9			;       if the string is non-empty, BC is HL/10 
0fb9			;Size:  24 bytes 
0fb9			;Speed: 42+d(104+{0,9}) 
0fb9			;       d is the number of digits in the number 
0fb9			;       max is 640 cycles for a 5 digit number 
0fb9			;Assuming no leading zeros: 
0fb9			;1 digit:  146cc 
0fb9			;2 digit:  250cc 
0fb9			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0fb9			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0fb9			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0fb9			;avg: 544.81158447265625cc (544+13297/16384) 
0fb9			;=============================================================== 
0fb9 21 00 00		  ld hl,0 
0fbc			.u16a: 
0fbc 1a			  ld a,(de) 
0fbd d6 30		  sub 30h 
0fbf fe 0a		  cp 10 
0fc1 d0			  ret nc 
0fc2 13			  inc de 
0fc3 44			  ld b,h 
0fc4 4d			  ld c,l 
0fc5 29			  add hl,hl 
0fc6 29			  add hl,hl 
0fc7 09			  add hl,bc 
0fc8 29			  add hl,hl 
0fc9 85			  add a,l 
0fca 6f			  ld l,a 
0fcb 30 ef		  jr nc,.u16a 
0fcd 24			  inc h 
0fce c3 bc 0f		  jp .u16a 
0fd1			 
0fd1			 
0fd1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fd1			 
0fd1			;written by Zeda 
0fd1			;Converts a 16-bit unsigned integer to an ASCII string. 
0fd1			 
0fd1			uitoa_16: 
0fd1			;Input: 
0fd1			;   DE is the number to convert 
0fd1			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0fd1			;Output: 
0fd1			;   HL points to the null-terminated ASCII string 
0fd1			;      NOTE: This isn't necessarily the same as the input HL. 
0fd1 d5			  push de 
0fd2 c5			  push bc 
0fd3 f5			  push af 
0fd4 eb			  ex de,hl 
0fd5			 
0fd5 01 f0 d8		  ld bc,-10000 
0fd8 3e 2f		  ld a,'0'-1 
0fda 3c			  inc a 
0fdb 09			  add hl,bc  
0fdc 38 fc		   jr c,$-2 
0fde 12			  ld (de),a 
0fdf 13			  inc de 
0fe0			 
0fe0 01 e8 03		  ld bc,1000 
0fe3 3e 3a		  ld a,'9'+1 
0fe5 3d			  dec a  
0fe6 09			  add hl,bc  
0fe7 30 fc		   jr nc,$-2 
0fe9 12			  ld (de),a 
0fea 13			  inc de 
0feb			 
0feb 01 9c ff		  ld bc,-100 
0fee 3e 2f		  ld a,'0'-1 
0ff0 3c			  inc a  
0ff1 09			  add hl,bc  
0ff2 38 fc		   jr c,$-2 
0ff4 12			  ld (de),a 
0ff5 13			  inc de 
0ff6			 
0ff6 7d			  ld a,l 
0ff7 26 3a		  ld h,'9'+1 
0ff9 25			  dec h  
0ffa c6 0a		  add a,10  
0ffc 30 fb		   jr nc,$-3 
0ffe c6 30		  add a,'0' 
1000 eb			  ex de,hl 
1001 72			  ld (hl),d 
1002 23			  inc hl 
1003 77			  ld (hl),a 
1004 23			  inc hl 
1005 36 00		  ld (hl),0 
1007			 
1007			;Now strip the leading zeros 
1007 0e fa		  ld c,-6 
1009 09			  add hl,bc 
100a 3e 30		  ld a,'0' 
100c 23			  inc hl  
100d be			  cp (hl)  
100e 28 fc		  jr z,$-2 
1010			 
1010			;Make sure that the string is non-empty! 
1010 7e			  ld a,(hl) 
1011 b7			  or a 
1012 20 01		  jr nz,.atoub 
1014 2b			  dec hl 
1015			.atoub: 
1015			 
1015 f1			  pop af 
1016 c1			  pop bc 
1017 d1			  pop de 
1018 c9			  ret 
1019			 
1019			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1019			 
1019			toUpper: 
1019			;A is the char. 
1019			;If A is a lowercase letter, this sets it to the matching uppercase 
1019			;18cc or 30cc or 41cc 
1019			;avg: 26.75cc 
1019 fe 61		  cp 'a' 
101b d8			  ret c 
101c fe 7b		  cp 'z'+1 
101e d0			  ret nc 
101f d6 20		  sub 'a'-'A' 
1021 c9			  ret 
1022			 
1022			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1022			 
1022			; String Length 
1022			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1022			 
1022			; Get the length of the null-terminated string starting at $8000 hl 
1022			;    LD     HL, $8000 
1022			 
1022			strlenz: 
1022			 
1022 af			    XOR    A               ; Zero is the value we are looking for. 
1023 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1024 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1025			                           ; 65, 536 bytes (the entire addressable memory space). 
1025 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1027			 
1027			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1027 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1028 6f			    LD     L, A             ; number of bytes 
1029 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
102b 2b			    DEC    HL              ; Compensate for null. 
102c c9				ret 
102d			 
102d			; Get the length of the A terminated string starting at $8000 hl 
102d			;    LD     HL, $8000 
102d			 
102d			strlent: 
102d			 
102d			                  ; A is the value we are looking for. 
102d 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
102f 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1031			                           ; 65, 536 bytes (the entire addressable memory space). 
1031 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1033			 
1033			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1033 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1035 2e 00		    LD     L, 0             ; number of bytes 
1037 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1039 2b			    DEC    HL              ; Compensate for null. 
103a c9				ret 
103b			 
103b			 
103b			;Comparing Strings 
103b			 
103b			;IN    HL     Address of string1. 
103b			;      DE     Address of string2. 
103b			 
103b			; doc given but wrong??? 
103b			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
103b			;      carry  Set if string1 > string2, reset if string1 <= string2. 
103b			; tested 
103b			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
103b			 
103b			strcmp_old: 
103b e5			    PUSH   HL 
103c d5			    PUSH   DE 
103d			 
103d 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
103e be			    CP     (HL)            ; (want to minimize work). 
103f 38 01		    JR     C, Str1IsBigger 
1041 7e			    LD     A, (HL) 
1042			 
1042			Str1IsBigger: 
1042 4f			    LD     C, A             ; Put length in BC 
1043 06 00		    LD     B, 0 
1045 13			    INC    DE              ; Increment pointers to meat of string. 
1046 23			    INC    HL 
1047			 
1047			CmpLoop: 
1047 1a			    LD     A, (DE)          ; Compare bytes. 
1048 ed a1		    CPI 
104a 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
104c 13			    INC    DE              ; Update pointer. 
104d ea 47 10		    JP     PE, CmpLoop 
1050			 
1050 d1			    POP    DE 
1051 e1			    POP    HL 
1052 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1053 be			    CP     (HL) 
1054 c9			    RET 
1055			 
1055			NoMatch: 
1055 2b			    DEC    HL 
1056 be			    CP     (HL)            ; Compare again to affect carry. 
1057 d1			    POP    DE 
1058 e1			    POP    HL 
1059 c9			    RET 
105a			 
105a			;; test strmp 
105a			; 
105a			;ld de, .str1 
105a			;ld hl, .str2 
105a			;call strcmp 
105a			;jr z, .z1 
105a			;;this 
105a			;	if DEBUG_FORTH_WORDS 
105a			;		DMARK "NZ1" 
105a			;		CALLMONITOR 
105a			;	endif 
105a			;.z1: 
105a			; 
105a			;	if DEBUG_FORTH_WORDS 
105a			;		DMARK "ZZ1" 
105a			;		CALLMONITOR 
105a			;	endif 
105a			; 
105a			;ld de, .str1 
105a			;ld hl, .str1 
105a			;call strcmp 
105a			;jr z, .z2 
105a			;;this 
105a			;	if DEBUG_FORTH_WORDS 
105a			;		DMARK "NZ2" 
105a			;		CALLMONITOR 
105a			;	endif 
105a			;.z2: 
105a			; 
105a			;	if DEBUG_FORTH_WORDS 
105a			;		DMARK "ZZ2" 
105a			;		CALLMONITOR 
105a			;	endif 
105a			; 
105a			;ld de, .str1 
105a			;ld hl, .str2 
105a			;call strcmp 
105a			;jr c, .c1 
105a			; 
105a			;	if DEBUG_FORTH_WORDS 
105a			;		DMARK "Nc1" 
105a			;		CALLMONITOR 
105a			;	endif 
105a			;.c1: 
105a			;;this 
105a			;	if DEBUG_FORTH_WORDS 
105a			;		DMARK "cc1" 
105a			;		CALLMONITOR 
105a			;	endif 
105a			; 
105a			;ld de, .str1 
105a			;ld hl, .str1 
105a			;call strcmp 
105a			;jr c, .c2 
105a			;;this 
105a			;	if DEBUG_FORTH_WORDS 
105a			;		DMARK "Nc2" 
105a			;		CALLMONITOR 
105a			;	endif 
105a			;.c2: 
105a			; 
105a			;	if DEBUG_FORTH_WORDS 
105a			;		DMARK "cc2" 
105a			;		CALLMONITOR 
105a			;	endif 
105a			;	NEXTW 
105a			;.str1:   db "string1",0 
105a			;.str2:   db "string2",0 
105a			 
105a			; only care about direct match or not 
105a			; hl and de strings 
105a			; zero set if the same 
105a			 
105a			strcmp: 
105a 1a				ld a, (de) 
105b be				cp (hl) 
105c 28 02			jr z, .ssame 
105e b7				or a 
105f c9				ret 
1060			 
1060			.ssame:  
1060 fe 00			cp 0 
1062 c8				ret z 
1063			 
1063 23				inc hl 
1064 13				inc de 
1065 18 f3			jr strcmp 
1067				 
1067				 
1067			 
1067			 
1067			 
1067			 
1067			; eof 
1067			 
1067			 
1067			 
1067			 
1067			 
1067			 
# End of file firmware_strings.asm
1067			include "firmware_memory.asm"   ; malloc and free  
1067			 
1067			if DEBUG_FORTH_MALLOC_HIGH 
1067			.mallocsize: db "Wants malloc >256",0 
1067			.mallocasize: db "MALLOC gives >256",0 
1067			.malloczero: db "MALLOC gives zero",0 
1067			 
1067			malloc_guard_zerolen: 
1067				push hl 
1067				push de 
1067				push af 
1067			 
1067				ld de, 0 
1067			        call cmp16 
1067				jr nz, .lowalloz 
1067			 
1067				push hl 
1067				push de 
1067					ld hl, display_fb0 
1067					ld (display_fb_active), hl 
1067				call clear_display 
1067				ld a, 0 
1067				ld de, .malloczero 
1067				call str_at_display 
1067				call update_display 
1067				call delay1s 
1067				call delay1s 
1067				ld a, 0 
1067				ld (os_view_disable), a 
1067			 
1067				pop de 
1067				pop hl 
1067			 
1067				 
1067			 
1067				CALLMONITOR 
1067			.lowalloz: 
1067			 
1067			 
1067				pop af 
1067				pop de 
1067				pop hl 
1067			ret 
1067			 
1067			malloc_guard_entry: 
1067				push hl 
1067				push de 
1067				push af 
1067			 
1067			 	or a      ;clear carry flag 
1067				push hl 
1067				ld de, 255 
1067				sbc hl, de 
1067				jr c, .lowalloc 
1067			 
1067				push de 
1067					ld hl, display_fb0 
1067					ld (display_fb_active), hl 
1067				call clear_display 
1067				ld a, 0 
1067				ld de, .mallocsize 
1067				call str_at_display 
1067				call update_display 
1067				call delay1s 
1067				call delay1s 
1067				ld a, 0 
1067				ld (os_view_disable), a 
1067			 
1067				pop de 
1067				pop hl 
1067			 
1067				 
1067			 
1067				CALLMONITOR 
1067				jr .lowdone 
1067			.lowalloc: 
1067			 
1067			 
1067				pop hl 
1067			.lowdone:	pop af 
1067				pop de 
1067				pop hl 
1067			ret 
1067			 
1067			malloc_guard_exit: 
1067				push hl 
1067				push de 
1067				push af 
1067			 
1067			 	or a      ;clear carry flag 
1067				push hl 
1067				ld de, 255 
1067				sbc hl, de 
1067				jr c, .lowallocx 
1067			 
1067				push de 
1067					ld hl, display_fb0 
1067					ld (display_fb_active), hl 
1067				call clear_display 
1067				ld a, 0 
1067				ld de, .mallocasize 
1067				call str_at_display 
1067				call update_display 
1067				call delay1s 
1067				call delay1s 
1067				ld a, 0 
1067				ld (os_view_disable), a 
1067				pop de 
1067				pop hl 
1067			 
1067				CALLMONITOR 
1067				jr .lowdonex 
1067			.lowallocx: 
1067			 
1067				pop hl 
1067			.lowdonex:	pop af 
1067				pop de 
1067				pop hl 
1067			ret 
1067			endif 
1067			 
1067			if MALLOC_2 
1067			; Z80 Malloc and Free Functions 
1067			 
1067			; Malloc Function: 
1067			; Input: 
1067			;   HL: Size of block to allocate 
1067			; Output: 
1067			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1067			 
1067			malloc: 
1067				 
1067			if DEBUG_FORTH_MALLOC_HIGH 
1067			call malloc_guard_entry 
1067			endif 
1067			 
1067			 
1067			 
1067			 
1067					if DEBUG_FORTH_MALLOC 
1067						DMARK "mal" 
1067						CALLMONITOR 
1067					endif 
1067			    push af            ; Save AF register 
1067			    ld a, l            ; Load low byte of size into A 
1067			    or h               ; Check if size is zero 
1067			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1067			 
1067			    ; Allocate memory 
1067			    ld hl, (heap_start) ; Load start of heap into HL 
1067					if DEBUG_FORTH_MALLOC 
1067						DMARK "ma1" 
1067						CALLMONITOR 
1067					endif 
1067			    call malloc_internal ; Call internal malloc function 
1067			    pop af             ; Restore AF register 
1067			if DEBUG_FORTH_MALLOC_HIGH 
1067			call malloc_guard_exit 
1067			call malloc_guard_zerolen 
1067			endif 
1067			    ret                ; Return 
1067			 
1067			; Free Function: 
1067			; Input: 
1067			;   HL: Pointer to memory block to free 
1067			; Output: 
1067			;   None 
1067			 
1067			free: 
1067			    push af            ; Save AF register 
1067			    ld a, l            ; Load low byte of pointer into A 
1067			    or h               ; Check if pointer is NULL 
1067			    jp z, free_exit    ; If pointer is NULL, exit 
1067			 
1067			    ; Free memory 
1067			    ld hl, (heap_start) ; Load start of heap into HL 
1067			    call free_internal  ; Call internal free function 
1067			    pop af             ; Restore AF register 
1067			    ret                ; Return 
1067			 
1067			; Internal Malloc Function: 
1067			; Input: 
1067			;   HL: Size of block to allocate 
1067			; Output: 
1067			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1067			 
1067			malloc_internal: 
1067			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1067			    add hl, bc         ; Add management overhead to requested size 
1067			    ex de, hl          ; Save total size in DE, and keep it in HL 
1067					if DEBUG_FORTH_MALLOC 
1067						DMARK "ma2" 
1067						CALLMONITOR 
1067					endif 
1067			 
1067			    ; Search for free memory block 
1067			    ld de, (heap_end)  ; Load end of heap into DE 
1067			    ld bc, 0           ; Initialize counter 
1067			 
1067					if DEBUG_FORTH_MALLOC 
1067						DMARK "ma2" 
1067						CALLMONITOR 
1067					endif 
1067			malloc_search_loop: 
1067			    ; Check if current block is free 
1067			    ld a, (hl)         ; Load current block's status (free or used) 
1067			    cp 0               ; Compare with zero (free) 
1067			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1067			 
1067			    ; Check if current block is large enough 
1067			    ld a, (hl+1)       ; Load high byte of block size 
1067			    cp l               ; Compare with low byte of requested size 
1067			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1067			 
1067			    ld a, (hl+2)       ; Load low byte of block size 
1067			    cp h               ; Compare with high byte of requested size 
1067			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1067			 
1067			    ; Mark block as used 
1067			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1067			 
1067			    ; Calculate remaining space in block 
1067			    ld bc, 0           ; Clear BC 
1067			    add hl, bc         ; Increment HL to point to start of data block 
1067			    add hl, de         ; HL = HL + DE (total size) 
1067			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1067			    add hl, bc         ; Add management overhead to start of data block 
1067			 
1067			    ; Save pointer to allocated block in HL 
1067			if DEBUG_FORTH_MALLOC_HIGH 
1067						DMARK "ma5" 
1067			call malloc_guard_exit 
1067			call malloc_guard_zerolen 
1067			endif 
1067			    ret 
1067			 
1067			malloc_skip_block_check: 
1067			    ; Move to the next block 
1067			    ld bc, 3           ; Size of management overhead 
1067			    add hl, bc         ; Move to the next block 
1067			    inc de             ; Increment counter 
1067			 
1067			    ; Check if we have reached the end of heap 
1067			    ld a, e            ; Load low byte of heap end address 
1067			    cp (hl)            ; Compare with low byte of current address 
1067			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1067			    ld a, d            ; Load high byte of heap end address 
1067			    cp 0               ; Check if it's zero (end of memory) 
1067			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1067			 
1067			    ; If we reached here, allocation failed 
1067			    xor a              ; Set result to NULL 
1067			if DEBUG_FORTH_MALLOC_HIGH 
1067						DMARK "ma6" 
1067			call malloc_guard_exit 
1067			call malloc_guard_zerolen 
1067			endif 
1067			    ret 
1067			malloc_exit: 
1067			if DEBUG_FORTH_MALLOC_HIGH 
1067						DMARK "ma7" 
1067			call malloc_guard_exit 
1067			call malloc_guard_zerolen 
1067			endif 
1067			    ret 
1067			 
1067			; Internal Free Function: 
1067			; Input: 
1067			;   HL: Pointer to memory block to free 
1067			; Output: 
1067			;   None 
1067			 
1067			free_internal: 
1067			    ld de, (heap_start) ; Load start of heap into DE 
1067			    ld bc, 0            ; Initialize counter 
1067			 
1067			free_search_loop: 
1067			    ; Check if current block contains the pointer 
1067			    ld a, l             ; Load low byte of pointer 
1067			    cp (hl+1)           ; Compare with high byte of current block's address 
1067			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1067			    ld a, h             ; Load high byte of pointer 
1067			    cp (hl+2)           ; Compare with low byte of current block's address 
1067			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1067			 
1067			    ; Mark block as free 
1067			    ld (hl), 0          ; Set status byte to indicate free block 
1067			    ret                 ; Return 
1067			 
1067			free_skip_block_check: 
1067			    ; Move to the next block 
1067			    ld bc, 3            ; Size of management overhead 
1067			    add hl, bc          ; Move to the next block 
1067			    inc de              ; Increment counter 
1067			 
1067			    ; Check if we have reached the end of heap 
1067			    ld a, e             ; Load low byte of heap end address 
1067			    cp (hl)             ; Compare with low byte of current address 
1067			    jr nz, free_search_loop  ; If not equal, continue searching 
1067			    ld a, d             ; Load high byte of heap end address 
1067			    cp 0                ; Check if it's zero (end of memory) 
1067			    jr nz, free_search_loop  ; If not zero, continue searching 
1067			 
1067			    ; If we reached here, pointer is not found in heap 
1067			    ret 
1067			 
1067			free_exit: 
1067			    ret                 ; Return 
1067			 
1067			; Define heap start and end addresses 
1067			;heap_start:    .dw 0xC000   ; Start of heap 
1067			;heap_end:      .dw 0xE000   ; End of heap 
1067			 
1067			endif 
1067			 
1067			 
1067			if MALLOC_1 
1067			 
1067			 
1067			 
1067			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1067			 
1067			;moved to firmware.asm 
1067			;heap_start        .equ  0x9000      ; Starting address of heap 
1067			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1067			 
1067			;      .org 0 
1067			;      jp    main 
1067			 
1067			 
1067			;      .org  0x100 
1067			;main: 
1067			;      ld    HL, 0x8100 
1067			;      ld    SP, HL 
1067			; 
1067			;      call  heap_init 
1067			; 
1067			;      ; Make some allocations 
1067			;      ld    HL, 12 
1067			;      call  malloc            ; Allocates 0x9004 
1067			; 
1067			;      ld    HL, 12 
1067			;      call  malloc            ; Allocates 0x9014 
1067			; 
1067			;      ld    HL, 12 
1067			;      call  malloc            ; Allocates 0x9024 
1067			; 
1067			;      ; Free some allocations 
1067			;      ld    HL, 0x9014 
1067			;      call  free 
1067			; 
1067			;      ld    HL, 0x9004 
1067			;      call  free 
1067			; 
1067			;      ld    HL, 0x9024 
1067			;      call  free 
1067			; 
1067			; 
1067			;      halt 
1067			 
1067			 
1067			;------------------------------------------------------------------------------ 
1067			;     heap_init                                                               : 
1067			;                                                                             : 
1067			; Description                                                                 : 
1067			;     Initialise the heap and make it ready for malloc and free operations.   : 
1067			;                                                                             : 
1067			;     The heap is maintained as a linked list, starting with an initial       : 
1067			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1067			;     the first free block in the heap. Each block then points to the next    : 
1067			;     free block within the heap, and the free list ends at the first block   : 
1067			;     with a null pointer to the next free block.                             : 
1067			;                                                                             : 
1067			; Parameters                                                                  : 
1067			;     Inputs are compile-time only. Two defines which specify the starting    : 
1067			;     address of the heap and its size are required, along with a memory      : 
1067			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1067			;     principally stores a pointer to the first free block in the heap.       : 
1067			;                                                                             : 
1067			; Returns                                                                     : 
1067			;     Nothing                                                                 : 
1067			;------------------------------------------------------------------------------ 
1067			heap_init: 
1067 e5			      push  HL 
1068			 
1068			      ; Initialise free list struct 
1068 21 47 59		      ld    HL, heap_start 
106b 22 42 59		      ld    (free_list), HL 
106e 21 00 00		      ld    HL, 0 
1071 22 44 59		      ld    (free_list+2), HL 
1074			 
1074			      ; Insert first free block at bottom of heap, consumes entire heap 
1074 21 39 e3		      ld    HL, heap_start+heap_size-4 
1077 22 47 59		      ld    (heap_start), HL        ; Next block (end of free list) 
107a 21 f2 89		      ld    HL, heap_size-4 
107d 22 49 59		      ld    (heap_start+2), HL      ; Block size 
1080			 
1080			      ; Insert end of free list block at top of heap - two null words will 
1080			      ; terminate the free list 
1080 21 00 00		      ld    HL, 0 
1083 22 3b e3		      ld    (heap_start+heap_size-2), HL 
1086 22 39 e3		      ld    (heap_start+heap_size-4), HL 
1089			 
1089 e1			      pop   HL 
108a			 
108a c9			      ret 
108b			 
108b			 
108b			;------------------------------------------------------------------------------ 
108b			;     malloc                                                                  : 
108b			;                                                                             : 
108b			; Description                                                                 : 
108b			;     Allocates the wanted space from the heap and returns the address of the : 
108b			;     first useable byte of the allocation.                                   : 
108b			;                                                                             : 
108b			;     Allocations can happen in one of two ways:                              : 
108b			;                                                                             : 
108b			;     1. A free block may be found which is the exact size wanted. In this    : 
108b			;        case the block is removed from the free list and retuedn to the      : 
108b			;        caller.                                                              : 
108b			;     2. A free block may be found which is larger than the size wanted. In   : 
108b			;        this case, the larger block is split into two. The first portion of  : 
108b			;        this block will become the requested space by the malloc call and    : 
108b			;        is returned to the caller. The second portion becomes a new free     : 
108b			;        block, and the free list is adjusted to maintain continuity via this : 
108b			;        newly created block.                                                 : 
108b			;                                                                             : 
108b			;     malloc does not set any initial value in the allocated space, the       : 
108b			;     caller is required to do this as required.                              : 
108b			;                                                                             : 
108b			;     This implementation of malloc uses the stack exclusively, and is        : 
108b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
108b			;     advisable to disable interrupts before calling malloc, and recommended  : 
108b			;     to avoid the use of malloc inside ISRs in general.                      : 
108b			;                                                                             : 
108b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
108b			;                                                                             : 
108b			; Parameters                                                                  : 
108b			;     HL  Number of bytes wanted                                              : 
108b			;                                                                             : 
108b			; Returns                                                                     : 
108b			;     HL  Address of the first useable byte of the allocation                 : 
108b			;                                                                             : 
108b			; Flags                                                                       : 
108b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
108b			;                                                                             : 
108b			; Stack frame                                                                 : 
108b			;       |             |                                                       : 
108b			;       +-------------+                                                       : 
108b			;       |     BC      |                                                       : 
108b			;       +-------------+                                                       : 
108b			;       |     DE      |                                                       : 
108b			;       +-------------+                                                       : 
108b			;       |     IX      |                                                       : 
108b			;       +-------------+                                                       : 
108b			;       |  prev_free  |                                                       : 
108b			;   +4  +-------------+                                                       : 
108b			;       |  this_free  |                                                       : 
108b			;   +2  +-------------+                                                       : 
108b			;       |  next_free  |                                                       : 
108b			;   +0  +-------------+                                                       : 
108b			;       |             |                                                       : 
108b			;                                                                             : 
108b			;------------------------------------------------------------------------------ 
108b			 
108b			 
108b			;malloc: 
108b			; 
108b			;	SAVESP ON 1 
108b			; 
108b			;	call malloc_code 
108b			; 
108b			;	CHECKSP ON 1 
108b			;	ret 
108b			 
108b			 
108b			malloc: 
108b c5			      push  BC 
108c d5			      push  DE 
108d dd e5		      push  IX 
108f			if DEBUG_FORTH_MALLOC_HIGH 
108f			call malloc_guard_entry 
108f			endif 
108f			 
108f					if DEBUG_FORTH_MALLOC 
108f						DMARK "mal" 
108f						CALLMONITOR 
108f					endif 
108f 7c			      ld    A, H                    ; Exit if no space requested 
1090 b5			      or    L 
1091 ca 50 11		      jp    Z, malloc_early_exit 
1094			 
1094			;inc hl 
1094			;inc hl 
1094			;inc hl 
1094			; 
1094			;inc hl 
1094			;inc hl 
1094			;inc hl 
1094			;inc hl 
1094			;inc hl 
1094			;inc hl 
1094			;inc hl 
1094			;inc hl 
1094			;inc hl 
1094			 
1094			 
1094			 
1094			 
1094					if DEBUG_FORTH_MALLOC 
1094						DMARK "maA" 
1094						CALLMONITOR 
1094					endif 
1094			      ; Set up stack frame 
1094 eb			      ex    DE, HL 
1095 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1098 39			      add   HL, SP 
1099 f9			      ld    SP, HL 
109a dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
109e dd 39		      add   IX, SP 
10a0			 
10a0			      ; Setup initial state 
10a0 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
10a3 19			      add   HL, DE 
10a4			 
10a4 44			      ld    B, H                    ; Move want to BC 
10a5 4d			      ld    C, L 
10a6			 
10a6 21 42 59		      ld    HL, free_list           ; Store prev_free ptr to stack 
10a9 dd 75 04		      ld    (IX+4), L 
10ac dd 74 05		      ld    (IX+5), H 
10af			 
10af 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
10b0 23			      inc   HL 
10b1 56			      ld    D, (HL) 
10b2 dd 73 02		      ld    (IX+2), E 
10b5 dd 72 03		      ld    (IX+3), D 
10b8 eb			      ex    DE, HL                  ; this_free ptr into HL 
10b9			 
10b9					if DEBUG_FORTH_MALLOC 
10b9						DMARK "maB" 
10b9						CALLMONITOR 
10b9					endif 
10b9			      ; Loop through free block list to find some space 
10b9			malloc_find_space: 
10b9 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
10ba 23			      inc   HL 
10bb 56			      ld    D, (HL) 
10bc			 
10bc 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
10bd b3			      or    E 
10be ca 4a 11		      jp    Z, malloc_no_space 
10c1			 
10c1 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
10c4 dd 72 01		      ld    (IX+1), D 
10c7			 
10c7			      ; Does this block have enough space to make the allocation? 
10c7 23			      inc   HL                      ; Load free block size into DE 
10c8 5e			      ld    E, (HL) 
10c9 23			      inc   HL 
10ca 56			      ld    D, (HL) 
10cb			 
10cb eb			      ex    DE, HL                  ; Check size of block against want 
10cc b7			      or    A                       ; Ensure carry flag clear 
10cd ed 42		      sbc   HL, BC 
10cf e5			      push  HL                      ; Store the result for later (new block size) 
10d0			 
10d0 ca 1f 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
10d3 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
10d5			 
10d5			      ; this_free block is not big enough, setup ptrs to test next free block 
10d5 e1			      pop   HL                      ; Discard previous result 
10d6			 
10d6 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
10d9 dd 66 03		      ld    H, (IX+3) 
10dc dd 75 04		      ld    (IX+4), L 
10df dd 74 05		      ld    (IX+5), H 
10e2			 
10e2 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
10e5 dd 66 01		      ld    H, (IX+1) 
10e8 dd 75 02		      ld    (IX+2), L 
10eb dd 74 03		      ld    (IX+3), H 
10ee			 
10ee					if DEBUG_FORTH_MALLOC 
10ee						DMARK "MA>" 
10ee						CALLMONITOR 
10ee					endif 
10ee 18 c9		      jr    malloc_find_space 
10f0			 
10f0			      ; split a bigger block into two - requested size and remaining size 
10f0			malloc_alloc_split: 
10f0					if DEBUG_FORTH_MALLOC 
10f0						DMARK "MAs" 
10f0						CALLMONITOR 
10f0					endif 
10f0 eb			      ex    DE, HL                  ; Calculate address of new free block 
10f1 2b			      dec   HL 
10f2 2b			      dec   HL 
10f3 2b			      dec   HL 
10f4 09			      add   HL, BC 
10f5			 
10f5			      ; Create a new block and point it at next_free 
10f5 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
10f8 dd 56 01		      ld    D, (IX+1) 
10fb			 
10fb 73			      ld    (HL), E                 ; Store next_free ptr into new block 
10fc 23			      inc   HL 
10fd 72			      ld    (HL), D 
10fe			 
10fe d1			      pop   DE                      ; Store size of new block into new block 
10ff 23			      inc   HL 
1100 73			      ld    (HL), E 
1101 23			      inc   HL 
1102 72			      ld    (HL), D 
1103			 
1103			      ; Update this_free ptr to point to new block 
1103 2b			      dec   HL 
1104 2b			      dec   HL 
1105 2b			      dec   HL 
1106			 
1106 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1109 dd 56 03		      ld    D, (IX+3) 
110c			 
110c dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
110f dd 74 03		      ld    (IX+3), H 
1112			 
1112			      ; Modify this_free block to be allocation 
1112 eb			      ex    DE, HL 
1113 af			      xor   A                       ; Null the next block ptr of allocated block 
1114 77			      ld    (HL), A 
1115 23			      inc   HL 
1116 77			      ld    (HL), A 
1117			 
1117 23			      inc   HL                      ; Store want size into allocated block 
1118 71			      ld    (HL), C 
1119 23			      inc   HL 
111a 70			      ld    (HL), B 
111b 23			      inc   HL 
111c e5			      push  HL                      ; Address of allocation to return 
111d			 
111d 18 19		      jr    malloc_update_links 
111f			 
111f			malloc_alloc_fit: 
111f e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1120			 
1120					if DEBUG_FORTH_MALLOC 
1120						DMARK "MAf" 
1120						CALLMONITOR 
1120					endif 
1120			      ; Modify this_free block to be allocation 
1120 eb			      ex    DE, HL 
1121 2b			      dec   HL 
1122 2b			      dec   HL 
1123 2b			      dec   HL 
1124			 
1124 af			      xor   A                       ; Null the next block ptr of allocated block 
1125 77			      ld    (HL), A 
1126 23			      inc   HL 
1127 77			      ld    (HL), A 
1128			 
1128 23			      inc   HL                      ; Store address of allocation to return 
1129 23			      inc   HL 
112a 23			      inc   HL 
112b e5			      push  HL 
112c			 
112c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
112c dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
112f dd 66 01		      ld    H, (IX+1) 
1132			 
1132 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1135 dd 74 03		      ld    (IX+3), H 
1138			 
1138			 
1138			malloc_update_links: 
1138			      ; Update prev_free ptr to point to this_free 
1138 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
113b dd 66 05		      ld    H, (IX+5) 
113e			 
113e dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1141 dd 56 03		      ld    D, (IX+3) 
1144			 
1144 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1145 23			      inc   HL 
1146 72			      ld    (HL), D 
1147			 
1147					if DEBUG_FORTH_MALLOC 
1147						DMARK "Mul" 
1147						CALLMONITOR 
1147					endif 
1147			      ; Clear the Z flag to indicate successful allocation 
1147 7a			      ld    A, D 
1148 b3			      or    E 
1149			 
1149 d1			      pop   DE                      ; Address of allocation 
114a					if DEBUG_FORTH_MALLOC 
114a						DMARK "MAu" 
114a						CALLMONITOR 
114a					endif 
114a			 
114a			malloc_no_space: 
114a 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
114d 39			      add   HL, SP 
114e f9			      ld    SP, HL 
114f			 
114f eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1150					if DEBUG_FORTH_MALLOC 
1150						DMARK "MAN" 
1150						CALLMONITOR 
1150					endif 
1150			 
1150			malloc_early_exit: 
1150					if DEBUG_FORTH_MALLOC 
1150						DMARK "MAx" 
1150						CALLMONITOR 
1150					endif 
1150 dd e1		      pop   IX 
1152 d1			      pop   DE 
1153 c1			      pop   BC 
1154			 
1154			if DEBUG_FORTH_MALLOC_HIGH 
1154			call malloc_guard_exit 
1154			call malloc_guard_zerolen 
1154			endif 
1154 c9			      ret 
1155			 
1155			 
1155			;------------------------------------------------------------------------------ 
1155			;     free                                                                    : 
1155			;                                                                             : 
1155			; Description                                                                 : 
1155			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1155			;     returned by malloc, otherwise the behaviour is undefined.               : 
1155			;                                                                             : 
1155			;     Where possible, directly adjacent free blocks will be merged together   : 
1155			;     into larger blocks to help ensure that the heap does not become         : 
1155			;     excessively fragmented.                                                 : 
1155			;                                                                             : 
1155			;     free does not clear or set any other value into the freed space, and    : 
1155			;     therefore its contents may be visible through subsequent malloc's. The  : 
1155			;     caller should clear the freed space as required.                        : 
1155			;                                                                             : 
1155			;     This implementation of free uses the stack exclusively, and is          : 
1155			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1155			;     advisable to disable interrupts before calling free, and recommended    : 
1155			;     to avoid the use of free inside ISRs in general.                        : 
1155			;                                                                             : 
1155			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1155			;                                                                             : 
1155			; Parameters                                                                  : 
1155			;     HL  Pointer to address of first byte of allocation to be freed          : 
1155			;                                                                             : 
1155			; Returns                                                                     : 
1155			;     Nothing                                                                 : 
1155			;                                                                             : 
1155			; Stack frame                                                                 : 
1155			;       |             |                                                       : 
1155			;       +-------------+                                                       : 
1155			;       |     BC      |                                                       : 
1155			;       +-------------+                                                       : 
1155			;       |     DE      |                                                       : 
1155			;       +-------------+                                                       : 
1155			;       |     IX      |                                                       : 
1155			;       +-------------+                                                       : 
1155			;       |  prev_free  |                                                       : 
1155			;   +2  +-------------+                                                       : 
1155			;       |  next_free  |                                                       : 
1155			;   +0  +-------------+                                                       : 
1155			;       |             |                                                       : 
1155			;                                                                             : 
1155			;------------------------------------------------------------------------------ 
1155			free: 
1155 c5			      push  BC 
1156 d5			      push  DE 
1157 dd e5		      push  IX 
1159			 
1159 7c			      ld    A, H                    ; Exit if ptr is null 
115a b5			      or    L 
115b ca 1f 12		      jp    Z, free_early_exit 
115e			 
115e			      ; Set up stack frame 
115e eb			      ex    DE, HL 
115f 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1162 39			      add   HL, SP 
1163 f9			      ld    SP, HL 
1164 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1168 dd 39		      add   IX, SP 
116a			 
116a			      ; The address in HL points to the start of the useable allocated space, 
116a			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
116a			      ; address of the block itself. 
116a eb			      ex    DE, HL 
116b 11 fc ff		      ld    DE, -4 
116e 19			      add   HL, DE 
116f			 
116f			      ; An allocated block must have a null next block pointer in it 
116f 7e			      ld    A, (HL) 
1170 23			      inc   HL 
1171 b6			      or    (HL) 
1172 c2 1a 12		      jp    NZ, free_done 
1175			 
1175 2b			      dec   HL 
1176			 
1176 44			      ld    B, H                    ; Copy HL to BC 
1177 4d			      ld    C, L 
1178			 
1178			      ; Loop through the free list to find the first block with an address 
1178			      ; higher than the block being freed 
1178 21 42 59		      ld    HL, free_list 
117b			 
117b			free_find_higher_block: 
117b 5e			      ld    E, (HL)                 ; Load next ptr from free block 
117c 23			      inc   HL 
117d 56			      ld    D, (HL) 
117e 2b			      dec   HL 
117f			 
117f dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1182 dd 72 01		      ld    (IX+1), D 
1185 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1188 dd 74 03		      ld    (IX+3), H 
118b			 
118b 78			      ld    A, B                    ; Check if DE is greater than BC 
118c ba			      cp    D                       ; Compare MSB first 
118d 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
118f 30 04		      jr    NC, free_find_higher_block_skip 
1191 79			      ld    A, C 
1192 bb			      cp    E                       ; Then compare LSB 
1193 38 08		      jr    C, free_found_higher_block 
1195			 
1195			free_find_higher_block_skip: 
1195 7a			      ld    A, D                    ; Reached the end of the free list? 
1196 b3			      or    E 
1197 ca 1a 12		      jp    Z, free_done 
119a			 
119a eb			      ex    DE, HL 
119b			 
119b 18 de		      jr    free_find_higher_block 
119d			 
119d			free_found_higher_block: 
119d			      ; Insert freed block between prev and next free blocks 
119d 71			      ld    (HL), C                 ; Point prev free block to freed block 
119e 23			      inc   HL 
119f 70			      ld    (HL), B 
11a0			 
11a0 60			      ld    H, B                    ; Point freed block at next free block 
11a1 69			      ld    L, C 
11a2 73			      ld    (HL), E 
11a3 23			      inc   HL 
11a4 72			      ld    (HL), D 
11a5			 
11a5			      ; Check if the freed block is adjacent to the next free block 
11a5 23			      inc   HL                      ; Load size of freed block into HL 
11a6 5e			      ld    E, (HL) 
11a7 23			      inc   HL 
11a8 56			      ld    D, (HL) 
11a9 eb			      ex    DE, HL 
11aa			 
11aa 09			      add   HL, BC                  ; Add addr of freed block and its size 
11ab			 
11ab dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
11ae dd 56 01		      ld    D, (IX+1) 
11b1			 
11b1 b7			      or    A                       ; Clear the carry flag 
11b2 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11b4 20 22		      jr    NZ, free_check_adjacent_to_prev 
11b6			 
11b6			      ; Freed block is adjacent to next, merge into one bigger block 
11b6 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
11b7 5e			      ld    E, (HL) 
11b8 23			      inc   HL 
11b9 56			      ld    D, (HL) 
11ba e5			      push  HL                      ; Save ptr to next block for later 
11bb			 
11bb 60			      ld    H, B                    ; Store ptr from next block into freed block 
11bc 69			      ld    L, C 
11bd 73			      ld    (HL), E 
11be 23			      inc   HL 
11bf 72			      ld    (HL), D 
11c0			 
11c0 e1			      pop   HL                      ; Restore ptr to next block 
11c1 23			      inc   HL                      ; Load size of next block into DE 
11c2 5e			      ld    E, (HL) 
11c3 23			      inc   HL 
11c4 56			      ld    D, (HL) 
11c5 d5			      push  DE                      ; Save next block size for later 
11c6			 
11c6 60			      ld    H, B                    ; Load size of freed block into HL 
11c7 69			      ld    L, C 
11c8 23			      inc   HL 
11c9 23			      inc   HL 
11ca 5e			      ld    E, (HL) 
11cb 23			      inc   HL 
11cc 56			      ld    D, (HL) 
11cd eb			      ex    DE, HL 
11ce			 
11ce d1			      pop   DE                      ; Restore size of next block 
11cf 19			      add   HL, DE                  ; Add sizes of both blocks 
11d0 eb			      ex    DE, HL 
11d1			 
11d1 60			      ld    H, B                    ; Store new bigger size into freed block 
11d2 69			      ld    L, C 
11d3 23			      inc   HL 
11d4 23			      inc   HL 
11d5 73			      ld    (HL), E 
11d6 23			      inc   HL 
11d7 72			      ld    (HL), D 
11d8			 
11d8			free_check_adjacent_to_prev: 
11d8			      ; Check if the freed block is adjacent to the prev free block 
11d8 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
11db dd 66 03		      ld    H, (IX+3) 
11de			 
11de 23			      inc   HL                      ; Size of prev free block into DE 
11df 23			      inc   HL 
11e0 5e			      ld    E, (HL) 
11e1 23			      inc   HL 
11e2 56			      ld    D, (HL) 
11e3 2b			      dec   HL 
11e4 2b			      dec   HL 
11e5 2b			      dec   HL 
11e6			 
11e6 19			      add   HL, DE                  ; Add prev block addr and size 
11e7			 
11e7 b7			      or    A                       ; Clear the carry flag 
11e8 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
11ea 20 2e		      jr    NZ, free_done 
11ec			 
11ec			      ; Freed block is adjacent to prev, merge into one bigger block 
11ec 60			      ld    H, B                    ; Load next ptr from freed block into DE 
11ed 69			      ld    L, C 
11ee 5e			      ld    E, (HL) 
11ef 23			      inc   HL 
11f0 56			      ld    D, (HL) 
11f1 e5			      push  HL                      ; Save freed block ptr for later 
11f2			 
11f2 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11f5 dd 66 03		      ld    H, (IX+3) 
11f8 73			      ld    (HL), E 
11f9 23			      inc   HL 
11fa 72			      ld    (HL), D 
11fb			 
11fb e1			      pop   HL                      ; Restore freed block ptr 
11fc 23			      inc   HL                      ; Load size of freed block into DE 
11fd 5e			      ld    E, (HL) 
11fe 23			      inc   HL 
11ff 56			      ld    D, (HL) 
1200 d5			      push  DE                      ; Save freed block size for later 
1201			 
1201 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1204 dd 66 03		      ld    H, (IX+3) 
1207 23			      inc   HL 
1208 23			      inc   HL 
1209 5e			      ld    E, (HL) 
120a 23			      inc   HL 
120b 56			      ld    D, (HL) 
120c			 
120c e1			      pop   HL                      ; Add sizes of both blocks 
120d 19			      add   HL, DE 
120e eb			      ex    DE, HL 
120f			 
120f dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1212 dd 66 03		      ld    H, (IX+3) 
1215 23			      inc   HL 
1216 23			      inc   HL 
1217 73			      ld    (HL), E 
1218 23			      inc   HL 
1219 72			      ld    (HL), D 
121a			 
121a			free_done: 
121a 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
121d 39			      add   HL, SP 
121e f9			      ld    SP, HL 
121f			 
121f			free_early_exit: 
121f dd e1		      pop   IX 
1221 d1			      pop   DE 
1222 c1			      pop   BC 
1223			 
1223 c9			      ret 
1224			 
1224			; moved to firmware.asm 
1224			; 
1224			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1224			;                  .dw   0 
1224			 
1224			 
1224			endif 
1224			 
1224			 
1224			if MALLOC_3 
1224			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1224			;heap_start        .equ  0x9000      ; Starting address of heap 
1224			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1224			; 
1224			 ;     .org 0 
1224			  ;    jp    main 
1224			; 
1224			; 
1224			 ;     .org  0x100 
1224			;main: 
1224			 ;     ld    HL, 0x8100 
1224			  ;    ld    SP, HL 
1224			; 
1224			;      call  heap_init 
1224			 
1224			      ; Make some allocations 
1224			;      ld    HL, 12 
1224			;      call  malloc            ; Allocates 0x9004 
1224			; 
1224			 ;     ld    HL, 12 
1224			;      call  malloc            ; Allocates 0x9014 
1224			 
1224			;      ld    HL, 12 
1224			;      call  malloc            ; Allocates 0x9024 
1224			 
1224			      ; Free some allocations 
1224			;      ld    HL, 0x9014 
1224			;      call  free 
1224			 
1224			;      ld    HL, 0x9004 
1224			;      call  free 
1224			; 
1224			;      ld    HL, 0x9024 
1224			;      call  free 
1224			 
1224			 
1224			 ;     halt 
1224			 
1224			 
1224			;------------------------------------------------------------------------------ 
1224			;     heap_init                                                               : 
1224			;                                                                             : 
1224			; Description                                                                 : 
1224			;     Initialise the heap and make it ready for malloc and free operations.   : 
1224			;                                                                             : 
1224			;     The heap is maintained as a linked list, starting with an initial       : 
1224			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1224			;     the first free block in the heap. Each block then points to the next    : 
1224			;     free block within the heap, and the free list ends at the first block   : 
1224			;     with a null pointer to the next free block.                             : 
1224			;                                                                             : 
1224			; Parameters                                                                  : 
1224			;     Inputs are compile-time only. Two defines which specify the starting    : 
1224			;     address of the heap and its size are required, along with a memory      : 
1224			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1224			;     principally stores a pointer to the first free block in the heap.       : 
1224			;                                                                             : 
1224			; Returns                                                                     : 
1224			;     Nothing                                                                 : 
1224			;------------------------------------------------------------------------------ 
1224			heap_init: 
1224			      push  HL 
1224			 
1224			      ; Initialise free list struct 
1224			      ld    HL, heap_start 
1224			      ld    (free_list), HL 
1224			      ld    HL, 0 
1224			      ld    (free_list+2), HL 
1224			 
1224			      ; Insert first free block at bottom of heap, consumes entire heap 
1224			      ld    HL, heap_start+heap_size-4 
1224			      ld    (heap_start), HL        ; Next block (end of free list) 
1224			      ld    HL, heap_size-4 
1224			      ld    (heap_start+2), HL      ; Block size 
1224			 
1224			      ; Insert end of free list block at top of heap - two null words will 
1224			      ; terminate the free list 
1224			      ld    HL, 0 
1224			      ld    (heap_start+heap_size-2), HL 
1224			      ld    (heap_start+heap_size-4), HL 
1224			 
1224			      pop   HL 
1224			 
1224			      ret 
1224			 
1224			 
1224			;------------------------------------------------------------------------------ 
1224			;     malloc                                                                  : 
1224			;                                                                             : 
1224			; Description                                                                 : 
1224			;     Allocates the wanted space from the heap and returns the address of the : 
1224			;     first useable byte of the allocation.                                   : 
1224			;                                                                             : 
1224			;     Allocations can happen in one of two ways:                              : 
1224			;                                                                             : 
1224			;     1. A free block may be found which is the exact size wanted. In this    : 
1224			;        case the block is removed from the free list and retuedn to the      : 
1224			;        caller.                                                              : 
1224			;     2. A free block may be found which is larger than the size wanted. In   : 
1224			;        this case, the larger block is split into two. The first portion of  : 
1224			;        this block will become the requested space by the malloc call and    : 
1224			;        is returned to the caller. The second portion becomes a new free     : 
1224			;        block, and the free list is adjusted to maintain continuity via this : 
1224			;        newly created block.                                                 : 
1224			;                                                                             : 
1224			;     malloc does not set any initial value in the allocated space, the       : 
1224			;     caller is required to do this as required.                              : 
1224			;                                                                             : 
1224			;     This implementation of malloc uses the stack exclusively, and is        : 
1224			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1224			;     advisable to disable interrupts before calling malloc, and recommended  : 
1224			;     to avoid the use of malloc inside ISRs in general.                      : 
1224			;                                                                             : 
1224			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1224			;                                                                             : 
1224			; Parameters                                                                  : 
1224			;     HL  Number of bytes wanted                                              : 
1224			;                                                                             : 
1224			; Returns                                                                     : 
1224			;     HL  Address of the first useable byte of the allocation                 : 
1224			;                                                                             : 
1224			; Flags                                                                       : 
1224			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1224			;                                                                             : 
1224			; Stack frame                                                                 : 
1224			;       |             |                                                       : 
1224			;       +-------------+                                                       : 
1224			;       |     BC      |                                                       : 
1224			;       +-------------+                                                       : 
1224			;       |     DE      |                                                       : 
1224			;       +-------------+                                                       : 
1224			;       |     IX      |                                                       : 
1224			;       +-------------+                                                       : 
1224			;       |  prev_free  |                                                       : 
1224			;   +4  +-------------+                                                       : 
1224			;       |  this_free  |                                                       : 
1224			;   +2  +-------------+                                                       : 
1224			;       |  next_free  |                                                       : 
1224			;   +0  +-------------+                                                       : 
1224			;       |             |                                                       : 
1224			;                                                                             : 
1224			;------------------------------------------------------------------------------ 
1224			malloc: 
1224			      push  BC 
1224			      push  DE 
1224			      push  IX 
1224			 
1224			      ld    A, H                    ; Exit if no space requested 
1224			      or    L 
1224			      jp    Z, malloc_early_exit 
1224			 
1224			      ; Set up stack frame 
1224			      ex    DE, HL 
1224			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1224			      add   HL, SP 
1224			      ld    SP, HL 
1224			      ld    IX, 0                   ; Use IX as a frame pointer 
1224			      add   IX, SP 
1224			 
1224			      ; Setup initial state 
1224			      ld    HL, 4                   ; want must also include space used by block struct 
1224			      add   HL, DE 
1224			 
1224			      ld    B, H                    ; Move want to BC 
1224			      ld    C, L 
1224			 
1224			      ld    HL, free_list           ; Store prev_free ptr to stack 
1224			      ld    (IX+4), L 
1224			      ld    (IX+5), H 
1224			 
1224			      ld    E, (HL)                 ; Store this_free ptr to stack 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			      ld    (IX+2), E 
1224			      ld    (IX+3), D 
1224			      ex    DE, HL                  ; this_free ptr into HL 
1224			 
1224			      ; Loop through free block list to find some space 
1224			malloc_find_space: 
1224			      ld    E, (HL)                 ; Load next_free ptr into DE 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			 
1224			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1224			      or    E 
1224			      jp    Z, malloc_no_space 
1224			 
1224			      ld    (IX+0), E               ; Store next_free ptr to stack 
1224			      ld    (IX+1), D 
1224			 
1224			      ; Does this block have enough space to make the allocation? 
1224			      inc   HL                      ; Load free block size into DE 
1224			      ld    E, (HL) 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			 
1224			      ex    DE, HL                  ; Check size of block against want 
1224			      or    A                       ; Ensure carry flag clear 
1224			      sbc   HL, BC 
1224			      push  HL                      ; Store the result for later (new block size) 
1224			 
1224			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1224			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1224			 
1224			      ; this_free block is not big enough, setup ptrs to test next free block 
1224			      pop   HL                      ; Discard previous result 
1224			 
1224			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1224			      ld    H, (IX+3) 
1224			      ld    (IX+4), L 
1224			      ld    (IX+5), H 
1224			 
1224			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1224			      ld    H, (IX+1) 
1224			      ld    (IX+2), L 
1224			      ld    (IX+3), H 
1224			 
1224			      jr    malloc_find_space 
1224			 
1224			      ; split a bigger block into two - requested size and remaining size 
1224			malloc_alloc_split: 
1224			      ex    DE, HL                  ; Calculate address of new free block 
1224			      dec   HL 
1224			      dec   HL 
1224			      dec   HL 
1224			      add   HL, BC 
1224			 
1224			      ; Create a new block and point it at next_free 
1224			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1224			      ld    D, (IX+1) 
1224			 
1224			      ld    (HL), E                 ; Store next_free ptr into new block 
1224			      inc   HL 
1224			      ld    (HL), D 
1224			 
1224			      pop   DE                      ; Store size of new block into new block 
1224			      inc   HL 
1224			      ld    (HL), E 
1224			      inc   HL 
1224			      ld    (HL), D 
1224			 
1224			      ; Update this_free ptr to point to new block 
1224			      dec   HL 
1224			      dec   HL 
1224			      dec   HL 
1224			 
1224			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1224			      ld    D, (IX+3) 
1224			 
1224			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1224			      ld    (IX+3), H 
1224			 
1224			      ; Modify this_free block to be allocation 
1224			      ex    DE, HL 
1224			      xor   A                       ; Null the next block ptr of allocated block 
1224			      ld    (HL), A 
1224			      inc   HL 
1224			      ld    (HL), A 
1224			 
1224			      inc   HL                      ; Store want size into allocated block 
1224			      ld    (HL), C 
1224			      inc   HL 
1224			      ld    (HL), B 
1224			      inc   HL 
1224			      push  HL                      ; Address of allocation to return 
1224			 
1224			      jr    malloc_update_links 
1224			 
1224			malloc_alloc_fit: 
1224			      pop   HL                      ; Dont need new block size, want is exact fit 
1224			 
1224			      ; Modify this_free block to be allocation 
1224			      ex    DE, HL 
1224			      dec   HL 
1224			      dec   HL 
1224			      dec   HL 
1224			 
1224			      xor   A                       ; Null the next block ptr of allocated block 
1224			      ld    (HL), A 
1224			      inc   HL 
1224			      ld    (HL), A 
1224			 
1224			      inc   HL                      ; Store address of allocation to return 
1224			      inc   HL 
1224			      inc   HL 
1224			      push  HL 
1224			 
1224			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1224			      ld    L, (IX+0)               ; next_free to HL 
1224			      ld    H, (IX+1) 
1224			 
1224			      ld    (IX+2), L               ; HL to this_free 
1224			      ld    (IX+3), H 
1224			 
1224			 
1224			malloc_update_links: 
1224			      ; Update prev_free ptr to point to this_free 
1224			      ld    L, (IX+4)               ; prev_free ptr to HL 
1224			      ld    H, (IX+5) 
1224			 
1224			      ld    E, (IX+2)               ; this_free ptr to DE 
1224			      ld    D, (IX+3) 
1224			 
1224			      ld    (HL), E                 ; this_free ptr into prev_free 
1224			      inc   HL 
1224			      ld    (HL), D 
1224			 
1224			      ; Clear the Z flag to indicate successful allocation 
1224			      ld    A, D 
1224			      or    E 
1224			 
1224			      pop   DE                      ; Address of allocation 
1224			 
1224			malloc_no_space: 
1224			      ld    HL, 6                   ; Clean up stack frame 
1224			      add   HL, SP 
1224			      ld    SP, HL 
1224			 
1224			      ex    DE, HL                  ; Alloc addr into HL for return 
1224			 
1224			malloc_early_exit: 
1224			      pop   IX 
1224			      pop   DE 
1224			      pop   BC 
1224			 
1224			      ret 
1224			 
1224			 
1224			;------------------------------------------------------------------------------ 
1224			;     free                                                                    : 
1224			;                                                                             : 
1224			; Description                                                                 : 
1224			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1224			;     returned by malloc, otherwise the behaviour is undefined.               : 
1224			;                                                                             : 
1224			;     Where possible, directly adjacent free blocks will be merged together   : 
1224			;     into larger blocks to help ensure that the heap does not become         : 
1224			;     excessively fragmented.                                                 : 
1224			;                                                                             : 
1224			;     free does not clear or set any other value into the freed space, and    : 
1224			;     therefore its contents may be visible through subsequent malloc's. The  : 
1224			;     caller should clear the freed space as required.                        : 
1224			;                                                                             : 
1224			;     This implementation of free uses the stack exclusively, and is          : 
1224			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1224			;     advisable to disable interrupts before calling free, and recommended    : 
1224			;     to avoid the use of free inside ISRs in general.                        : 
1224			;                                                                             : 
1224			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1224			;                                                                             : 
1224			; Parameters                                                                  : 
1224			;     HL  Pointer to address of first byte of allocation to be freed          : 
1224			;                                                                             : 
1224			; Returns                                                                     : 
1224			;     Nothing                                                                 : 
1224			;                                                                             : 
1224			; Stack frame                                                                 : 
1224			;       |             |                                                       : 
1224			;       +-------------+                                                       : 
1224			;       |     BC      |                                                       : 
1224			;       +-------------+                                                       : 
1224			;       |     DE      |                                                       : 
1224			;       +-------------+                                                       : 
1224			;       |     IX      |                                                       : 
1224			;       +-------------+                                                       : 
1224			;       |  prev_free  |                                                       : 
1224			;   +2  +-------------+                                                       : 
1224			;       |  next_free  |                                                       : 
1224			;   +0  +-------------+                                                       : 
1224			;       |             |                                                       : 
1224			;                                                                             : 
1224			;------------------------------------------------------------------------------ 
1224			free: 
1224			      push  BC 
1224			      push  DE 
1224			      push  IX 
1224			 
1224			      ld    A, H                    ; Exit if ptr is null 
1224			      or    L 
1224			      jp    Z, free_early_exit 
1224			 
1224			      ; Set up stack frame 
1224			      ex    DE, HL 
1224			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1224			      add   HL, SP 
1224			      ld    SP, HL 
1224			      ld    IX, 0                   ; Use IX as a frame pointer 
1224			      add   IX, SP 
1224			 
1224			      ; The address in HL points to the start of the useable allocated space, 
1224			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1224			      ; address of the block itself. 
1224			      ex    DE, HL 
1224			      ld    DE, -4 
1224			      add   HL, DE 
1224			 
1224			      ; An allocated block must have a null next block pointer in it 
1224			      ld    A, (HL) 
1224			      inc   HL 
1224			      or    (HL) 
1224			      jp    NZ, free_done 
1224			 
1224			      dec   HL 
1224			 
1224			      ld    B, H                    ; Copy HL to BC 
1224			      ld    C, L 
1224			 
1224			      ; Loop through the free list to find the first block with an address 
1224			      ; higher than the block being freed 
1224			      ld    HL, free_list 
1224			 
1224			free_find_higher_block: 
1224			      ld    E, (HL)                 ; Load next ptr from free block 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			      dec   HL 
1224			 
1224			      ld    (IX+0), E               ; Save ptr to next free block 
1224			      ld    (IX+1), D 
1224			      ld    (IX+2), L               ; Save ptr to prev free block 
1224			      ld    (IX+3), H 
1224			 
1224			      ld    A, B                    ; Check if DE is greater than BC 
1224			      cp    D                       ; Compare MSB first 
1224			      jr    Z, $+4                  ; MSB the same, compare LSB 
1224			      jr    NC, free_find_higher_block_skip 
1224			      ld    A, C 
1224			      cp    E                       ; Then compare LSB 
1224			      jr    C, free_found_higher_block 
1224			 
1224			free_find_higher_block_skip: 
1224			      ld    A, D                    ; Reached the end of the free list? 
1224			      or    E 
1224			      jp    Z, free_done 
1224			 
1224			      ex    DE, HL 
1224			 
1224			      jr    free_find_higher_block 
1224			 
1224			free_found_higher_block: 
1224			      ; Insert freed block between prev and next free blocks 
1224			      ld    (HL), C                 ; Point prev free block to freed block 
1224			      inc   HL 
1224			      ld    (HL), B 
1224			 
1224			      ld    H, B                    ; Point freed block at next free block 
1224			      ld    L, C 
1224			      ld    (HL), E 
1224			      inc   HL 
1224			      ld    (HL), D 
1224			 
1224			      ; Check if the freed block is adjacent to the next free block 
1224			      inc   HL                      ; Load size of freed block into HL 
1224			      ld    E, (HL) 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			      ex    DE, HL 
1224			 
1224			      add   HL, BC                  ; Add addr of freed block and its size 
1224			 
1224			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1224			      ld    D, (IX+1) 
1224			 
1224			      or    A                       ; Clear the carry flag 
1224			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1224			      jr    NZ, free_check_adjacent_to_prev 
1224			 
1224			      ; Freed block is adjacent to next, merge into one bigger block 
1224			      ex    DE, HL                  ; Load next ptr from next block into DE 
1224			      ld    E, (HL) 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			      push  HL                      ; Save ptr to next block for later 
1224			 
1224			      ld    H, B                    ; Store ptr from next block into freed block 
1224			      ld    L, C 
1224			      ld    (HL), E 
1224			      inc   HL 
1224			      ld    (HL), D 
1224			 
1224			      pop   HL                      ; Restore ptr to next block 
1224			      inc   HL                      ; Load size of next block into DE 
1224			      ld    E, (HL) 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			      push  DE                      ; Save next block size for later 
1224			 
1224			      ld    H, B                    ; Load size of freed block into HL 
1224			      ld    L, C 
1224			      inc   HL 
1224			      inc   HL 
1224			      ld    E, (HL) 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			      ex    DE, HL 
1224			 
1224			      pop   DE                      ; Restore size of next block 
1224			      add   HL, DE                  ; Add sizes of both blocks 
1224			      ex    DE, HL 
1224			 
1224			      ld    H, B                    ; Store new bigger size into freed block 
1224			      ld    L, C 
1224			      inc   HL 
1224			      inc   HL 
1224			      ld    (HL), E 
1224			      inc   HL 
1224			      ld    (HL), D 
1224			 
1224			free_check_adjacent_to_prev: 
1224			      ; Check if the freed block is adjacent to the prev free block 
1224			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1224			      ld    H, (IX+3) 
1224			 
1224			      inc   HL                      ; Size of prev free block into DE 
1224			      inc   HL 
1224			      ld    E, (HL) 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			      dec   HL 
1224			      dec   HL 
1224			      dec   HL 
1224			 
1224			      add   HL, DE                  ; Add prev block addr and size 
1224			 
1224			      or    A                       ; Clear the carry flag 
1224			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1224			      jr    NZ, free_done 
1224			 
1224			      ; Freed block is adjacent to prev, merge into one bigger block 
1224			      ld    H, B                    ; Load next ptr from freed block into DE 
1224			      ld    L, C 
1224			      ld    E, (HL) 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			      push  HL                      ; Save freed block ptr for later 
1224			 
1224			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1224			      ld    H, (IX+3) 
1224			      ld    (HL), E 
1224			      inc   HL 
1224			      ld    (HL), D 
1224			 
1224			      pop   HL                      ; Restore freed block ptr 
1224			      inc   HL                      ; Load size of freed block into DE 
1224			      ld    E, (HL) 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			      push  DE                      ; Save freed block size for later 
1224			 
1224			      ld    L, (IX+2)               ; Load size of prev block into DE 
1224			      ld    H, (IX+3) 
1224			      inc   HL 
1224			      inc   HL 
1224			      ld    E, (HL) 
1224			      inc   HL 
1224			      ld    D, (HL) 
1224			 
1224			      pop   HL                      ; Add sizes of both blocks 
1224			      add   HL, DE 
1224			      ex    DE, HL 
1224			 
1224			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1224			      ld    H, (IX+3) 
1224			      inc   HL 
1224			      inc   HL 
1224			      ld    (HL), E 
1224			      inc   HL 
1224			      ld    (HL), D 
1224			 
1224			free_done: 
1224			      ld    HL, 4                   ; Clean up stack frame 
1224			      add   HL, SP 
1224			      ld    SP, HL 
1224			 
1224			free_early_exit: 
1224			      pop   IX 
1224			      pop   DE 
1224			      pop   BC 
1224			 
1224			      ret 
1224			 
1224			 
1224			;      .org 0x8000 
1224			; 
1224			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1224			 ;                 .dw   0 
1224			 
1224			endif 
1224			 
1224			 
1224			if MALLOC_4 
1224			 
1224			; My memory allocation code. Very very simple.... 
1224			; allocate space under 250 chars 
1224			 
1224			heap_init: 
1224				; init start of heap as zero 
1224				;  
1224			 
1224				ld hl, heap_start 
1224				ld a, 0 
1224				ld (hl), a      ; empty block 
1224				inc hl 
1224				ld a, 0 
1224				ld (hl), a      ; length of block 
1224				; write end of list 
1224				inc hl 
1224				ld a,(hl) 
1224				inc hl 
1224				ld a,(hl) 
1224				 
1224			 
1224				; init some malloc vars 
1224			 
1224				ld hl, 0 
1224				ld (free_list), hl       ; store last malloc location 
1224			 
1224				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1224				ld a, 0 
1224				ld (hl), a 
1224			 
1224			 
1224				ld hl, heap_start 
1224				;  
1224				  
1224				ret 
1224			 
1224			 
1224			;    free block marker 
1224			;    requested size  
1224			;    pointer to next block 
1224			;    .... 
1224			;    next block marker 
1224			 
1224			 
1224			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1224			; 
1224			 
1224			 
1224			malloc:  
1224				push de 
1224				push bc 
1224				push af 
1224			 
1224				; hl space required 
1224				 
1224				ld c, l    ; hold space   (TODO only a max of 255) 
1224			 
1224			;	inc c     ; TODO BUG need to fix memory leak on push str 
1224			;	inc c 
1224			;	inc c 
1224			;	inc c 
1224			;	inc c 
1224			;	inc c 
1224			;	inc c 
1224			 
1224			 
1224			 
1224				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1224			 
1224				ld a, (free_list+3) 
1224				cp 0 
1224				jr z, .contheap 
1224			 
1224				ld hl, (free_list)     ; get last alloc 
1224					if DEBUG_FORTH_MALLOC_INT 
1224						DMARK "mrs" 
1224						CALLMONITOR 
1224					endif 
1224				jr .startalloc 
1224			 
1224			.contheap: 
1224				ld hl, heap_start 
1224			 
1224			.startalloc: 
1224			 
1224					if DEBUG_FORTH_MALLOC_INT 
1224						DMARK "mym" 
1224						CALLMONITOR 
1224					endif 
1224			.findblock: 
1224					if DEBUG_FORTH_MALLOC_INT 
1224						DMARK "mmf" 
1224						CALLMONITOR 
1224					endif 
1224			 
1224				ld a,(hl)  
1224				; if byte is zero then clear to use 
1224			 
1224				cp 0 
1224				jr z, .foundemptyblock 
1224			 
1224				; if byte is not clear 
1224				;     then byte is offset to next block 
1224			 
1224				inc hl 
1224				ld a, (hl) ; get size 
1224			.nextblock:	inc hl 
1224					ld e, (hl) 
1224					inc hl 
1224					ld d, (hl) 
1224					ex de, hl 
1224			;	inc hl  ; move past the store space 
1224			;	inc hl  ; move past zero index  
1224			 
1224				; TODO detect no more space 
1224			 
1224				push hl 
1224				ld de, heap_end 
1224				call cmp16 
1224				pop hl 
1224				jr nc, .nospace 
1224			 
1224				jr .findblock 
1224			 
1224			.nospace: ld hl, 0 
1224				jp .exit 
1224			 
1224			 
1224			.foundemptyblock:	 
1224					if DEBUG_FORTH_MALLOC_INT 
1224						DMARK "mme" 
1224						CALLMONITOR 
1224					endif 
1224			 
1224			; TODO has block enough space if reusing??? 
1224			 
1224				;  
1224			 
1224			; see if this block has been previously used 
1224				inc hl 
1224				ld a, (hl) 
1224				dec hl 
1224				cp 0 
1224				jr z, .newblock 
1224			 
1224					if DEBUG_FORTH_MALLOC_INT 
1224						DMARK "meR" 
1224						CALLMONITOR 
1224					endif 
1224			 
1224			; no reusing previously allocated block 
1224			 
1224			; is it smaller than previously used? 
1224				 
1224				inc hl    ; move to size 
1224				ld a, c 
1224				sub (hl)        ; we want c < (hl) 
1224				dec hl    ; move back to marker 
1224			        jr z, .findblock 
1224			 
1224				; update with the new size which should be lower 
1224			 
1224			        ;inc  hl   ; negate next move. move back to size  
1224			 
1224			.newblock: 
1224				; need to be at marker here 
1224			 
1224					if DEBUG_FORTH_MALLOC_INT 
1224						DMARK "meN" 
1224						CALLMONITOR 
1224					endif 
1224			 
1224			 
1224				ld a, c 
1224			 
1224				ld (free_list+3), a	 ; flag resume from last malloc  
1224				ld (free_list), hl    ; save out last location 
1224			 
1224			 
1224				;inc a     ; space for length byte 
1224				ld (hl), a     ; save block in use marker 
1224			 
1224				inc hl   ; move to space marker 
1224				ld (hl), a    ; save new space 
1224			 
1224				inc hl   ; move to start of allocated area 
1224				 
1224			;	push hl     ; save where we are - 1  
1224			 
1224			;	inc hl  ; move past zero index  
1224				; skip space to set down new marker 
1224			 
1224				; provide some extra space for now 
1224			 
1224				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1224				inc a 
1224				inc a 
1224			 
1224				push hl   ; save where we are in the node block 
1224			 
1224				call addatohl 
1224			 
1224				; write linked list point 
1224			 
1224				pop de     ; get our node position 
1224				ex de, hl 
1224			 
1224				ld (hl), e 
1224				inc hl 
1224				ld (hl), d 
1224			 
1224				inc hl 
1224			 
1224				; now at start of allocated data so save pointer 
1224			 
1224				push hl 
1224			 
1224				; jump to position of next node and setup empty header in DE 
1224			 
1224				ex de, hl 
1224			 
1224			;	inc hl ; move past end of block 
1224			 
1224				ld a, 0 
1224				ld (hl), a   ; empty marker 
1224				inc hl 
1224				ld (hl), a   ; size 
1224				inc hl  
1224				ld (hl), a   ; ptr 
1224				inc hl 
1224				ld (hl), a   ; ptr 
1224			 
1224			 
1224				pop hl 
1224			 
1224					if DEBUG_FORTH_MALLOC_INT 
1224						DMARK "mmr" 
1224						CALLMONITOR 
1224					endif 
1224			 
1224			.exit: 
1224				pop af 
1224				pop bc 
1224				pop de  
1224				ret 
1224			 
1224			 
1224			 
1224			 
1224			free:  
1224				push hl 
1224				push af 
1224				; get address in hl 
1224			 
1224					if DEBUG_FORTH_MALLOC_INT 
1224						DMARK "fre" 
1224						CALLMONITOR 
1224					endif 
1224				; data is at hl - move to block count 
1224				dec hl 
1224				dec hl    ; get past pointer 
1224				dec hl 
1224			 
1224				ld a, (hl)    ; need this for a validation check 
1224			 
1224				dec hl    ; move to block marker 
1224			 
1224				; now check that the block count and block marker are the same  
1224			        ; this checks that we are on a malloc node and not random memory 
1224			        ; OK a faint chance this could be a problem but rare - famous last words! 
1224			 
1224				ld c, a 
1224				ld a, (hl)    
1224			 
1224				cp c 
1224				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1224			 
1224				; yes good chance we are on a malloc node 
1224			 
1224				ld a, 0      
1224				ld (hl), a   ; mark as free 
1224			 
1224				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1224			 
1224			.freeignore:  
1224			 
1224				pop af 
1224				pop hl 
1224			 
1224				ret 
1224			 
1224			 
1224			 
1224			endif 
1224			 
1224			; eof 
# End of file firmware_memory.asm
1224			  
1224			; device C  
1224			if SOUND_ENABLE  
1224				include "firmware_sound.asm"  
1224			endif  
1224			  
1224			include "firmware_diags.asm"  
1224			; Hardware diags menu 
1224			 
1224			 
1224			config: 
1224			 
1224 3e 00			ld a, 0 
1226 21 54 12			ld hl, .configmn 
1229 cd c8 09			call menu 
122c			 
122c fe 00			cp 0 
122e c8				ret z 
122f			 
122f fe 01			cp 1 
1231 cc 13 13			call z, .savetostore 
1234			 
1234 fe 02			cp 2 
1236 cc ff 12			call z, .selautoload 
1239 fe 03			cp 3 
123b cc f5 12			call z, .disautoload 
123e fe 04			cp 4 
1240 cc 09 13			call z, .selbank 
1243 fe 05			cp 5 
1245 cc 34 13			call z, .debug_tog 
1248 fe 06			cp 6 
124a cc 77 14			call z, .bpsgo 
124d fe 07			cp 7 
124f cc 5a 13			call z, hardware_diags 
1252			 
1252 18 d0			jr config 
1254			 
1254			.configmn: 
1254 64 12			dw .c3 
1256 7b 12			dw .c2 
1258 90 12			dw .c2a 
125a a6 12			dw .c2b 
125c			;	dw .c4 
125c c3 12			dw .m4 
125e de 12			dw .m4b 
1260 e6 12			dw .c1 
1262 00 00			dw 0 
1264				 
1264			 
1264 .. 00		.c3: db "Add Dictionary To File",0 
127b .. 00		.c2: db "Select Autoload File",0 
1290 .. 00		.c2a: db "Disable Autoload File", 0 
12a6 .. 00		.c2b: db "Select Storage Bank",0 
12ba .. 00		.c4: db "Settings",0 
12c3 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
12de .. 00		.m4b:   db "Monitor",0 
12e6 .. 00		.c1: db "Hardware Diags",0 
12f5			 
12f5			 
12f5			.disautoload: 
12f5				if STORAGE_SE 
12f5				ld a, $fe      ; bit 0 clear 
12f5				ld (spi_device), a 
12f5			 
12f5				call storage_get_block_0 
12f5			 
12f5				ld a, 0 
12f5				ld (store_page+STORE_0_AUTOFILE), a 
12f5			 
12f5					ld hl, 0 
12f5					ld de, store_page 
12f5				call storage_write_block	 ; save update 
12f5				else 
12f5			 
12f5 21 1d 13			ld hl, .notav 
12f8 11 33 13			ld de, .empty 
12fb cd 28 09			call info_panel 
12fe				endif 
12fe			 
12fe			 
12fe c9				ret 
12ff			 
12ff			 
12ff			 
12ff			; Select auto start 
12ff			 
12ff			.selautoload: 
12ff			 
12ff				 
12ff				if STORAGE_SE 
12ff			 
12ff					call config_dir 
12ff				        ld hl, scratch 
12ff					ld a, 0 
12ff					call menu 
12ff			 
12ff					cp 0 
12ff					ret z 
12ff			 
12ff					dec a 
12ff			 
12ff			 
12ff					; locate menu option 
12ff			 
12ff					ld hl, scratch 
12ff					call table_lookup 
12ff			 
12ff					if DEBUG_FORTH_WORDS 
12ff						DMARK "ALl" 
12ff						CALLMONITOR 
12ff					endif 
12ff					; with the pointer to the menu it, the byte following the zero term is the file id 
12ff			 
12ff					ld a, 0 
12ff					ld bc, 50   ; max of bytes to look at 
12ff					cpir  
12ff			 
12ff					if DEBUG_FORTH_WORDS 
12ff						DMARK "ALb" 
12ff						CALLMONITOR 
12ff					endif 
12ff					;inc hl 
12ff			 
12ff					ld a, (hl)   ; file id 
12ff					 
12ff				        ; save bank and file ids 
12ff			 
12ff					push af 
12ff			 
12ff			; TODO need to save to block 0 on bank 1	 
12ff			 
12ff					call storage_get_block_0 
12ff			 
12ff					if DEBUG_FORTH_WORDS 
12ff						DMARK "AL0" 
12ff						CALLMONITOR 
12ff					endif 
12ff					pop af 
12ff			 
12ff					ld (store_page+STORE_0_FILERUN),a 
12ff					 
12ff					; save bank id 
12ff			 
12ff					ld a,(spi_device) 
12ff					ld (store_page+STORE_0_BANKRUN),a 
12ff			 
12ff					; enable auto run of store file 
12ff			 
12ff					ld a, 1 
12ff					ld (store_page+STORE_0_AUTOFILE),a 
12ff			 
12ff					; save buffer 
12ff			 
12ff					ld hl, 0 
12ff					ld de, store_page 
12ff					if DEBUG_FORTH_WORDS 
12ff						DMARK "ALw" 
12ff						CALLMONITOR 
12ff					endif 
12ff				call storage_write_block	 ; save update 
12ff			  
12ff			 
12ff			 
12ff			 
12ff					ld hl, scratch 
12ff					call config_fdir 
12ff			 
12ff				else 
12ff			 
12ff 21 1d 13			ld hl, .notav 
1302 11 33 13			ld de, .empty 
1305 cd 28 09			call info_panel 
1308			 
1308				endif 
1308 c9				ret 
1309			 
1309			 
1309			 
1309			; Select storage bank 
1309			 
1309			.selbank: 
1309			 
1309				if STORAGE_SE 
1309				else 
1309			 
1309 21 1d 13			ld hl, .notav 
130c 11 33 13			ld de, .empty 
130f cd 28 09			call info_panel 
1312				endif 
1312				 
1312 c9				ret 
1313			 
1313			if STORAGE_SE 
1313			 
1313			.config_ldir:   
1313				; Load storage bank labels into menu array 
1313			 
1313				 
1313			 
1313			 
1313				ret 
1313			 
1313			 
1313			endif 
1313			 
1313			 
1313			; Save user words to storage 
1313			 
1313			.savetostore: 
1313			 
1313				if STORAGE_SE 
1313			 
1313					call config_dir 
1313				        ld hl, scratch 
1313					ld a, 0 
1313					call menu 
1313					 
1313					ld hl, scratch 
1313					call config_fdir 
1313			 
1313				else 
1313			 
1313 21 1d 13			ld hl, .notav 
1316 11 33 13			ld de, .empty 
1319 cd 28 09			call info_panel 
131c			 
131c				endif 
131c			 
131c c9				ret 
131d .. 00		.notav:    db "Feature not available",0 
1333 .. 00		.empty:    db "",0 
1334			 
1334			 
1334			 
1334			if STORAGE_SE 
1334			 
1334			config_fdir: 
1334				; using the scratch dir go through and release the memory allocated for each string 
1334				 
1334				ld hl, scratch 
1334			.cfdir:	ld e,(hl) 
1334				inc hl 
1334				ld d,(hl) 
1334				inc hl 
1334			 
1334				ex de, hl 
1334				call ishlzero 
1334				ret z     ; return on null pointer 
1334				call free 
1334				ex de, hl 
1334				jr .cfdir 
1334			 
1334			 
1334				ret 
1334			 
1334			 
1334			config_dir: 
1334			 
1334				; for the config menus that need to build a directory of storage call this routine 
1334				; it will construct a menu in scratch to pass to menu 
1334			 
1334				; open storage device 
1334			 
1334				; execute DIR to build a list of files and their ids into scratch in menu format 
1334				; once the menu has finished then will need to call config_fdir to release the strings 
1334				 
1334				; c = number items 
1334			 
1334				 
1334				call storage_get_block_0 
1334			 
1334				ld hl, store_page     ; get current id count 
1334				ld b, (hl) 
1334				ld c, 0    ; count of files   
1334			 
1334			 
1334				ld hl, scratch 
1334				ld (store_tmp2), hl    ; location to poke strings 
1334			 
1334				; check for empty drive 
1334			 
1334				ld a, 0 
1334				cp b 
1334				jp z, .dirdone 
1334			 
1334				 
1334					if DEBUG_FORTH_WORDS 
1334						DMARK "Cdc" 
1334						CALLMONITOR 
1334					endif 
1334			 
1334			 
1334			.diritem:	 
1334				push bc 
1334				; for each of the current ids do a search for them and if found push to stack 
1334			 
1334					ld hl, STORE_BLOCK_PHY 
1334					ld d, 0		 ; look for extent 0 of block id as this contains file name 
1334					ld e,b 
1334			 
1334					call storage_findnextid 
1334			 
1334			 
1334					; if found hl will be non zero 
1334			 
1334					call ishlzero 
1334					jr z, .dirnotfound 
1334			 
1334					; increase count 
1334			 
1334					pop bc	 
1334					inc c 
1334					push bc 
1334					 
1334			 
1334					; get file header and push the file name 
1334			 
1334					ld de, store_page 
1334					call storage_read_block 
1334			 
1334					; push file id to stack 
1334				 
1334					ld a, (store_page) 
1334					ld h, 0 
1334					ld l, a 
1334			 
1334					;call forth_push_numhl 
1334					; TODO store id 
1334			 
1334					push hl 
1334			 
1334					; push extent count to stack  
1334				 
1334					ld hl, store_page+3 
1334			 
1334					; get file name length 
1334			 
1334					call strlenz   
1334			 
1334					inc hl   ; cover zero term 
1334					inc hl  ; stick the id at the end of the area 
1334			 
1334					push hl 
1334					pop bc    ; move length to bc 
1334			 
1334					call malloc 
1334			 
1334					; TODO save malloc area to scratch 
1334			 
1334					ex de, hl 
1334					ld hl, (store_tmp2) 
1334					ld (hl), e 
1334					inc hl 
1334					ld (hl), d 
1334					inc hl 
1334					ld (store_tmp2), hl 
1334			 
1334					 
1334			 
1334					;pop hl   ; get source 
1334			;		ex de, hl    ; swap aronund	 
1334			 
1334					ld hl, store_page+3 
1334					if DEBUG_FORTH_WORDS 
1334						DMARK "CFd" 
1334						CALLMONITOR 
1334					endif 
1334					ldir 
1334			 
1334					; de is past string, move back one and store id 
1334					 
1334					dec de 
1334			 
1334					; store file id 
1334			 
1334					pop hl 
1334					ex de,hl 
1334					ld (hl), e 
1334			 
1334					if DEBUG_FORTH_WORDS 
1334						DMARK "Cdi" 
1334						CALLMONITOR 
1334					endif 
1334					 
1334			.dirnotfound: 
1334					pop bc     
1334					djnz .diritem 
1334				 
1334			.dirdone:	 
1334			 
1334					ld a, 0 
1334					ld hl, (store_tmp2) 
1334					ld (hl), a 
1334					inc hl 
1334					ld (hl), a 
1334					inc hl 
1334					; push a count of the dir items found 
1334			 
1334			;		ld h, 0 
1334			;		ld l, c 
1334			 
1334				ret 
1334			 
1334			endif 
1334			 
1334			 
1334			; Settings 
1334			; Run  
1334			 
1334			 
1334			 
1334			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1334			;;hd_menu2:   db "        2: Editor",0   
1334			;hd_menu2:   db "        2: Editor       6: Menu",0   
1334			;hd_menu3:   db "        3: Storage",0 
1334			;hd_menu4:   db "0=quit  4: Debug",0 
1334			;hd_don:     db "ON",0 
1334			;hd_doff:     db "OFF",0 
1334			; 
1334			; 
1334			; 
1334			;hardware_diags_old:       
1334			; 
1334			;.diagmenu: 
1334			;	call clear_display 
1334			;	ld a, display_row_1 
1334			;	ld de, hd_menu1 
1334			;	call str_at_display 
1334			; 
1334			;	ld a, display_row_2 
1334			;	ld de, hd_menu2 
1334			;	call str_at_display 
1334			; 
1334			;	ld a, display_row_3 
1334			;	ld de, hd_menu3 
1334			;	call str_at_display 
1334			; 
1334			;	ld a,  display_row_4 
1334			;	ld de, hd_menu4 
1334			;	call str_at_display 
1334			; 
1334			;	; display debug state 
1334			; 
1334			;	ld de, hd_don 
1334			;	ld a, (os_view_disable) 
1334			;	cp 0 
1334			;	jr z, .distog 
1334			;	ld de, hd_doff 
1334			;.distog: ld a, display_row_4+17 
1334			;	call str_at_display 
1334			; 
1334			;	call update_display 
1334			; 
1334			;	call cin_wait 
1334			; 
1334			; 
1334			; 
1334			;	cp '4' 
1334			;	jr nz, .diagn1 
1334			; 
1334			;	; debug toggle 
1334			; 
1334			;	ld a, (os_view_disable) 
1334			;	ld b, '*' 
1334			;	cp 0 
1334			;	jr z, .debtog 
1334			;	ld b, 0 
1334			;.debtog:	 
1334			;	ld a,b 
1334			;	ld (os_view_disable),a 
1334			; 
1334			;.diagn1: cp '0' 
1334			;	 ret z 
1334			; 
1334			;;	cp '1' 
1334			;;       jp z, matrix	 
1334			;;   TODO keyboard matrix test 
1334			; 
1334			;	cp '2' 
1334			;	jp z, .diagedit 
1334			; 
1334			;;	cp '6' 
1334			;;	jp z, .menutest 
1334			;;if ENABLE_BASIC 
1334			;;	cp '6' 
1334			;;	jp z, basic 
1334			;;endif 
1334			 ; 
1334			;	jp .diagmenu 
1334			; 
1334			; 
1334			;	ret 
1334			 
1334			 
1334			.debug_tog: 
1334 21 7b 13			ld hl, .menudebug 
1337				 
1337 3a 48 e3			ld a, (os_view_disable) 
133a fe 2a			cp '*' 
133c 20 04			jr nz,.tdon  
133e 3e 01			ld a, 1 
1340 18 02			jr .tog1 
1342 3e 00		.tdon: ld a, 0 
1344			 
1344			.tog1: 
1344 cd c8 09			call menu 
1347 fe 00			cp 0 
1349 c8				ret z 
134a fe 01			cp 1    ; disable debug 
134c 28 04			jr z, .dtog0 
134e 3e 2a			ld a, '*' 
1350 18 02			jr .dtogset 
1352 3e 00		.dtog0: ld a, 0 
1354 32 48 e3		.dtogset:  ld (os_view_disable), a 
1357 c3 34 13			jp .debug_tog 
135a			 
135a			 
135a			hardware_diags:       
135a			 
135a			.diagm: 
135a 21 6d 13			ld hl, .menuitems 
135d 3e 00			ld a, 0 
135f cd c8 09			call menu 
1362			 
1362 fe 00		         cp 0 
1364 c8				 ret z 
1365			 
1365 fe 02			cp 2 
1367 ca c6 13			jp z, .diagedit 
136a			 
136a			;	cp '6' 
136a			;	jp z, .menutest 
136a			;if ENABLE_BASIC 
136a			;	cp '6' 
136a			;	jp z, basic 
136a			;endif 
136a			  
136a c3 5a 13			jp .diagm 
136d			 
136d				 
136d 81 13		.menuitems:   	dw .m1 
136f 8c 13				dw .m2 
1371 93 13				dw .m3 
1373 9b 13				dw .m5 
1375 a1 13				dw .m5a 
1377 aa 13				dw .m5b 
1379 00 00				dw 0 
137b			 
137b			.menudebug: 
137b b3 13				dw .m6 
137d bc 13				dw .m7 
137f 00 00				dw 0 
1381			 
1381 .. 00		.m1:   db "Key Matrix",0 
138c .. 00		.m2:   db "Editor",0 
1393 .. 00		.m3:   db "Storage",0 
139b .. 00		.m5:   db "Sound",0 
13a1 .. 00		.m5a:  db "RAM Test",0 
13aa .. 00		.m5b:  db "LCD Test",0 
13b3			 
13b3 .. 00		.m6:   db "Debug ON",0 
13bc .. 00		.m7:   db "Debug OFF",0 
13c6			 
13c6			; debug editor 
13c6			 
13c6			.diagedit: 
13c6			 
13c6 21 57 e3			ld hl, scratch 
13c9			;	ld bc, 250 
13c9			;	ldir 
13c9				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
13c9 3e 00			ld a, 0 
13cb 77				ld (hl), a 
13cc 23				inc hl 
13cd 77				ld (hl), a 
13ce 23				inc hl 
13cf 77				ld (hl), a 
13d0			 
13d0 cd 97 09		        call clear_display 
13d3 cd ba 09			call update_display 
13d6				;ld a, 1 
13d6				;ld (hardware_diag), a 
13d6			.diloop: 
13d6 3e 00			ld a, display_row_1 
13d8 0e 00			ld c, 0 
13da 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
13dc 1e 28			ld e, 40 
13de			 
13de 21 57 e3			ld hl, scratch	 
13e1 cd f1 0b			call input_str 
13e4			 
13e4 3e 28			ld a, display_row_2 
13e6 11 57 e3			ld de, scratch 
13e9 cd aa 09			call str_at_display 
13ec cd ba 09			call update_display 
13ef			 
13ef c3 d6 13			jp .diloop 
13f2			 
13f2			 
13f2			; pass word in hl 
13f2			; a has display location 
13f2			display_word_at: 
13f2 f5				push af 
13f3 e5				push hl 
13f4 7c				ld a,h 
13f5 21 5c e6			ld hl, os_word_scratch 
13f8 cd c5 0e			call hexout 
13fb e1				pop hl 
13fc 7d				ld a,l 
13fd 21 5e e6			ld hl, os_word_scratch+2 
1400 cd c5 0e			call hexout 
1403 21 60 e6			ld hl, os_word_scratch+4 
1406 3e 00			ld a,0 
1408 77				ld (hl),a 
1409 11 5c e6			ld de,os_word_scratch 
140c f1				pop af 
140d cd aa 09				call str_at_display 
1410 c9				ret 
1411			 
1411			display_ptr_state: 
1411			 
1411				; to restore afterwards 
1411			 
1411 d5				push de 
1412 c5				push bc 
1413 e5				push hl 
1414 f5				push af 
1415			 
1415				; for use in here 
1415			 
1415			;	push bc 
1415			;	push de 
1415			;	push hl 
1415			;	push af 
1415			 
1415 cd 97 09			call clear_display 
1418			 
1418 11 eb 15			ld de, .ptrstate 
141b 3e 00			ld a, display_row_1 
141d cd aa 09			call str_at_display 
1420			 
1420				; display debug step 
1420			 
1420			 
1420 11 71 ee			ld de, debug_mark 
1423 3e 26			ld a, display_row_1+display_cols-2 
1425 cd aa 09			call str_at_display 
1428			 
1428				; display a 
1428 11 f5 15			ld de, .ptrcliptr 
142b 3e 28			ld a, display_row_2 
142d cd aa 09			call str_at_display 
1430			 
1430 f1				pop af 
1431 2a 22 eb			ld hl,(cli_ptr) 
1434 3e 30			ld a, display_row_2+8 
1436 cd f2 13			call display_word_at 
1439			 
1439			 
1439				; display hl 
1439			 
1439			 
1439 11 fd 15			ld de, .ptrclioptr 
143c 3e 32			ld a, display_row_2+10 
143e cd aa 09			call str_at_display 
1441			; 
1441			;	pop hl 
1441 3e 35			ld a, display_row_2+13 
1443 2a 20 eb			ld hl,(cli_origptr) 
1446 cd f2 13			call display_word_at 
1449			; 
1449			;	 
1449			;	; display de 
1449			 
1449			;	ld de, .regstatede 
1449			;	ld a, display_row_3 
1449			;	call str_at_display 
1449			 
1449			;	pop de 
1449			;	ld h,d 
1449			;	ld l, e 
1449			;	ld a, display_row_3+3 
1449			;	call display_word_at 
1449			 
1449			 
1449				; display bc 
1449			 
1449			;	ld de, .regstatebc 
1449			;	ld a, display_row_3+10 
1449			;	call str_at_display 
1449			 
1449			;	pop bc 
1449			;	ld h,b 
1449			;	ld l, c 
1449			;	ld a, display_row_3+13 
1449			;	call display_word_at 
1449			 
1449			 
1449				; display dsp 
1449			 
1449			;	ld de, .regstatedsp 
1449			;	ld a, display_row_4 
1449			;	call str_at_display 
1449			 
1449				 
1449			;	ld hl,(cli_data_sp) 
1449			;	ld a, display_row_4+4 
1449			;	call display_word_at 
1449			 
1449				; display rsp 
1449			 
1449 11 2c 16			ld de, .regstatersp 
144c 3e 82			ld a, display_row_4+10 
144e cd aa 09			call str_at_display 
1451			 
1451				 
1451 2a 08 eb			ld hl,(cli_ret_sp) 
1454 3e 86			ld a, display_row_4+14 
1456 cd f2 13			call display_word_at 
1459			 
1459 cd ba 09			call update_display 
145c			 
145c cd 09 09			call delay1s 
145f cd 09 09			call delay1s 
1462 cd 09 09			call delay1s 
1465			 
1465			 
1465 cd 72 19			call next_page_prompt 
1468			 
1468				; restore  
1468			 
1468 f1				pop af 
1469 e1				pop hl 
146a c1				pop bc 
146b d1				pop de 
146c c9				ret 
146d			 
146d			break_point_state: 
146d f5				push af 
146e			 
146e				; see if disabled 
146e			 
146e 3a 48 e3			ld a, (os_view_disable) 
1471 fe 2a			cp '*' 
1473 20 02			jr nz, .bpsgo 
1475 f1				pop af 
1476 c9				ret 
1477			 
1477			.bpsgo: 
1477 f1				pop af 
1478 f5				push af 
1479 22 44 e3			ld (os_view_hl), hl 
147c ed 53 42 e3		ld (os_view_de), de 
1480 ed 43 40 e3		ld (os_view_bc), bc 
1484 e5				push hl 
1485 6f				ld l, a 
1486 26 00			ld h, 0 
1488 22 46 e3			ld (os_view_af),hl 
148b			 
148b 21 b7 ed				ld hl, display_fb0 
148e 22 d2 eb				ld (display_fb_active), hl 
1491 e1				pop hl	 
1492			 
1492 3e 31			ld a, '1' 
1494 fe 2a		.bps1:  cp '*' 
1496 20 03			jr nz, .bps1b 
1498 32 48 e3			ld (os_view_disable),a 
149b fe 31		.bps1b:  cp '1' 
149d 20 14			jr nz, .bps2 
149f			 
149f				; display reg 
149f			 
149f				 
149f			 
149f 3a 46 e3			ld a, (os_view_af) 
14a2 2a 44 e3			ld hl, (os_view_hl) 
14a5 ed 5b 42 e3		ld de, (os_view_de) 
14a9 ed 4b 40 e3		ld bc, (os_view_bc) 
14ad cd 47 15			call display_reg_state 
14b0 c3 33 15			jp .bpschk 
14b3			 
14b3 fe 32		.bps2:  cp '2' 
14b5 20 08			jr nz, .bps3 
14b7				 
14b7				; display hl 
14b7 2a 44 e3			ld hl, (os_view_hl) 
14ba cd 31 16			call display_dump_at_hl 
14bd			 
14bd 18 74			jr .bpschk 
14bf			 
14bf fe 33		.bps3:  cp '3' 
14c1 20 08			jr nz, .bps4 
14c3			 
14c3			        ; display de 
14c3 2a 42 e3			ld hl, (os_view_de) 
14c6 cd 31 16			call display_dump_at_hl 
14c9			 
14c9 18 68			jr .bpschk 
14cb fe 34		.bps4:  cp '4' 
14cd 20 08			jr nz, .bps5 
14cf			 
14cf			        ; display bc 
14cf 2a 40 e3			ld hl, (os_view_bc) 
14d2 cd 31 16			call display_dump_at_hl 
14d5			 
14d5 18 5c			jr .bpschk 
14d7 fe 35		.bps5:  cp '5' 
14d9 20 08		        jr nz, .bps7 
14db			 
14db				; display cur ptr 
14db 2a 22 eb			ld hl, (cli_ptr) 
14de cd 31 16			call display_dump_at_hl 
14e1			 
14e1 18 50			jr .bpschk 
14e3 fe 36		.bps7:  cp '6' 
14e5 20 08			jr nz, .bps8b 
14e7				 
14e7				; display cur orig ptr 
14e7 2a 20 eb			ld hl, (cli_origptr) 
14ea cd 31 16			call display_dump_at_hl 
14ed 18 44			jr .bpschk 
14ef fe 37		.bps8b:  cp '7' 
14f1 20 08			jr nz, .bps9 
14f3				 
14f3				; display dsp 
14f3 2a 04 eb			ld hl, (cli_data_sp) 
14f6 cd 31 16			call display_dump_at_hl 
14f9			 
14f9 18 38			jr .bpschk 
14fb fe 39		.bps9:  cp '9' 
14fd 20 05			jr nz, .bps8c 
14ff				 
14ff				; display SP 
14ff			;	ld hl, sp 
14ff cd 31 16			call display_dump_at_hl 
1502			 
1502 18 2f			jr .bpschk 
1504 fe 38		.bps8c:  cp '8' 
1506 20 08			jr nz, .bps8d 
1508				 
1508				; display rsp 
1508 2a 08 eb			ld hl, (cli_ret_sp) 
150b cd 31 16			call display_dump_at_hl 
150e			 
150e 18 23			jr .bpschk 
1510 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1512 20 05			jr nz, .bps8 
1514 cd 68 17			call monitor 
1517			 
1517 18 1a			jr .bpschk 
1519 fe 30		.bps8:  cp '0' 
151b 20 16			jr nz, .bpschk 
151d			 
151d 21 16 ed				ld hl, display_fb1 
1520 22 d2 eb				ld (display_fb_active), hl 
1523 cd ba 09				call update_display 
1526			 
1526				;ld a, (os_view_af) 
1526 2a 44 e3			ld hl, (os_view_hl) 
1529 ed 5b 42 e3		ld de, (os_view_de) 
152d ed 4b 40 e3		ld bc, (os_view_bc) 
1531 f1				pop af 
1532 c9				ret 
1533			 
1533			.bpschk:   
1533 cd 09 09			call delay1s 
1536 3e 9f		ld a,display_row_4 + display_cols - 1 
1538 11 70 19		        ld de, endprg 
153b cd aa 09			call str_at_display 
153e cd ba 09			call update_display 
1541 cd 17 59			call cin_wait 
1544			 
1544 c3 94 14			jp .bps1 
1547			 
1547			 
1547			display_reg_state: 
1547			 
1547				; to restore afterwards 
1547			 
1547 d5				push de 
1548 c5				push bc 
1549 e5				push hl 
154a f5				push af 
154b			 
154b				; for use in here 
154b			 
154b c5				push bc 
154c d5				push de 
154d e5				push hl 
154e f5				push af 
154f			 
154f cd 97 09			call clear_display 
1552			 
1552 11 07 16			ld de, .regstate 
1555 3e 00			ld a, display_row_1 
1557 cd aa 09			call str_at_display 
155a			 
155a				; display debug step 
155a			 
155a			 
155a 11 71 ee			ld de, debug_mark 
155d 3e 25			ld a, display_row_1+display_cols-3 
155f cd aa 09			call str_at_display 
1562			 
1562				; display a 
1562 11 23 16			ld de, .regstatea 
1565 3e 28			ld a, display_row_2 
1567 cd aa 09			call str_at_display 
156a			 
156a e1				pop hl 
156b			;	ld h,0 
156b			;	ld l, a 
156b 3e 2b			ld a, display_row_2+3 
156d cd f2 13			call display_word_at 
1570			 
1570			 
1570				; display hl 
1570			 
1570			 
1570 11 17 16			ld de, .regstatehl 
1573 3e 32			ld a, display_row_2+10 
1575 cd aa 09			call str_at_display 
1578			 
1578 e1				pop hl 
1579 3e 35			ld a, display_row_2+13 
157b cd f2 13			call display_word_at 
157e			 
157e				 
157e				; display de 
157e			 
157e 11 1b 16			ld de, .regstatede 
1581 3e 50			ld a, display_row_3 
1583 cd aa 09			call str_at_display 
1586			 
1586 e1				pop hl 
1587			;	ld h,d 
1587			;	ld l, e 
1587 3e 53			ld a, display_row_3+3 
1589 cd f2 13			call display_word_at 
158c			 
158c			 
158c				; display bc 
158c			 
158c 11 1f 16			ld de, .regstatebc 
158f 3e 5a			ld a, display_row_3+10 
1591 cd aa 09			call str_at_display 
1594			 
1594 e1				pop hl 
1595			;	ld h,b 
1595			;	ld l, c 
1595 3e 5d			ld a, display_row_3+13 
1597 cd f2 13			call display_word_at 
159a			 
159a			 
159a				; display dsp 
159a			 
159a 11 27 16			ld de, .regstatedsp 
159d 3e 78			ld a, display_row_4 
159f cd aa 09			call str_at_display 
15a2			 
15a2				 
15a2 2a 04 eb			ld hl,(cli_data_sp) 
15a5 3e 7c			ld a, display_row_4+4 
15a7 cd f2 13			call display_word_at 
15aa			 
15aa				; display rsp 
15aa			 
15aa 11 2c 16			ld de, .regstatersp 
15ad 3e 82			ld a, display_row_4+10 
15af cd aa 09			call str_at_display 
15b2			 
15b2				 
15b2 2a 08 eb			ld hl,(cli_ret_sp) 
15b5 3e 86			ld a, display_row_4+14 
15b7 cd f2 13			call display_word_at 
15ba			 
15ba cd ba 09			call update_display 
15bd			 
15bd			;	call delay1s 
15bd			;	call delay1s 
15bd			;	call delay1s 
15bd			 
15bd			 
15bd			;	call next_page_prompt 
15bd			 
15bd				; restore  
15bd			 
15bd f1				pop af 
15be e1				pop hl 
15bf c1				pop bc 
15c0 d1				pop de 
15c1 c9				ret 
15c2			 
15c2 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
15d6 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
15eb .. 00		.ptrstate:	db "Ptr State",0 
15f5 .. 00		.ptrcliptr:     db "cli_ptr",0 
15fd .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1607 .. 00		.regstate:	db "Reg State (1/0)",0 
1617 .. 00		.regstatehl:	db "HL:",0 
161b .. 00		.regstatede:	db "DE:",0 
161f .. 00		.regstatebc:	db "BC:",0 
1623 .. 00		.regstatea:	db "A :",0 
1627 .. 00		.regstatedsp:	db "DSP:",0 
162c .. 00		.regstatersp:	db "RSP:",0 
1631			 
1631			display_dump_at_hl: 
1631 e5				push hl 
1632 d5				push de 
1633 c5				push bc 
1634 f5				push af 
1635			 
1635 22 7a e6			ld (os_cur_ptr),hl	 
1638 cd 97 09			call clear_display 
163b cd 7a 18			call dumpcont 
163e			;	call delay1s 
163e			;	call next_page_prompt 
163e			 
163e			 
163e f1				pop af 
163f c1				pop bc 
1640 d1				pop de 
1641 e1				pop hl 
1642 c9				ret 
1643			 
1643			;if ENABLE_BASIC 
1643			;	include "nascombasic.asm" 
1643			;	basic: 
1643			;	include "forth/FORTH.ASM" 
1643			;endif 
1643			 
1643			; eof 
1643			 
1643			 
# End of file firmware_diags.asm
1643			  
1643			  
1643			  
1643			  
1643			; eof  
1643			  
# End of file firmware.asm
1643			 
1643			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1643			;if BASE_KEV  
1643			;baseram: equ 08000h 
1643			;endif 
1643			 
1643			;if BASE_SC114 
1643			;baseram:     equ    endofcode 
1643			;endif 
1643			 
1643			 
1643			; start system 
1643			 
1643			coldstart: 
1643				; set sp 
1643				; di/ei 
1643			 
1643 f3				di 
1644 31 00 f0			ld sp, tos 
1647			;	ei 
1647			 
1647			 
1647				; disable breakpoint by default 
1647			 
1647 3e 2a			ld a,'*' 
1649 32 48 e3			ld (os_view_disable),a 
164c			 
164c				; init hardware 
164c			 
164c				; init keyboard and screen hardware 
164c			 
164c cd 03 01			call hardware_init 
164f			 
164f			 
164f				; detect if any keys are held down to enable breakpoints at start up 
164f			 
164f cd 1f 59			call cin  
1652 fe 00			cp 0 
1654 28 03			jr z, .nokeys 
1656			 
1656				;call hardware_diags 
1656 cd 24 12			call config 
1659			 
1659			;	ld de, .bpen 
1659			;	ld a, display_row_4 
1659			;	call str_at_display 
1659			;	call update_display 
1659			; 
1659			;	ld a,0 
1659			;	ld (os_view_disable),a 
1659			; 
1659			;.bpwait: 
1659			;	call cin 
1659			;	cp 0 
1659			;	jr z, .bpwait 
1659			;	jr .nokeys 
1659			; 
1659			; 
1659			;.bpen:  db "Break points enabled!",0 
1659			 
1659			 
1659			 
1659			 
1659			 
1659			 
1659			.nokeys: 
1659			 
1659			 
1659				 
1659			 
1659			;jp  testkey 
1659			 
1659			;call storage_get_block_0 
1659			; 
1659			;ld hl, 0 
1659			;ld de, store_page 
1659			;call storage_read_block 
1659			 
1659				 
1659			;ld hl, 10 
1659			;ld de, store_page 
1659			;call storage_read_block 
1659			 
1659			 
1659			 
1659			 
1659			 
1659			;stop:	nop 
1659			;	jp stop 
1659			 
1659			 
1659			 
1659			main: 
1659 cd 97 09			call clear_display 
165c cd ba 09			call update_display 
165f			 
165f			 
165f			 
165f			;	call testlcd 
165f			 
165f			 
165f			 
165f cd 38 1d			call forth_init 
1662			 
1662			 
1662			warmstart: 
1662 cd 0e 1d			call forth_warmstart 
1665			 
1665				; run startup word load 
1665			        ; TODO prevent this running at warmstart after crash  
1665			 
1665				if STARTUP_ENABLE 
1665					if STORAGE_SE 
1665						call forth_autoload 
1665					endif 
1665 cd 65 55				call forth_startup 
1668			 
1668			 
1668				endif 
1668			 
1668				; show free memory after boot 
1668 11 02 17			ld de, freeram 
166b 3e 00			ld a, display_row_1 
166d cd aa 09			call str_at_display 
1670			 
1670			; Or use heap_size word???? 
1670 21 3d e3			ld hl, heap_end 
1673 11 47 59			ld de, heap_start 
1676 ed 52			sbc hl, de 
1678 e5				push hl 
1679 7c				ld a,h	         	 
167a 21 5c e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
167d cd c5 0e			call hexout 
1680 e1			   	pop hl 
1681			 
1681 7d				ld a,l 
1682 21 5e e6			ld hl, os_word_scratch+2 
1685 cd c5 0e			call hexout 
1688 21 60 e6			ld hl, os_word_scratch+4 
168b 3e 00			ld a, 0 
168d 77				ld (hl),a 
168e 11 5c e6			ld de, os_word_scratch 
1691 3e 0d			ld a, display_row_1 + 13 
1693 cd aa 09			call str_at_display 
1696 cd ba 09			call update_display 
1699			 
1699			 
1699				;call demo 
1699			 
1699			 
1699				; init scratch input area for cli commands 
1699			 
1699 21 7e e6			ld hl, os_cli_cmd 
169c 3e 00			ld a,0 
169e 77				ld (hl),a 
169f 23				inc hl 
16a0 77				ld (hl),a 
16a1			 
16a1 3e 00			ld a,0 
16a3 32 7d e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
16a6			 
16a6 32 7a e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
16a9 32 7b e6			ld (os_cur_ptr+1),a	 
16ac			 
16ac 32 5c e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
16af 32 5d e6			ld (os_word_scratch+1),a	 
16b2				 
16b2			 
16b2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16b2 21 7e e6			ld hl, os_cli_cmd 
16b5			 
16b5 3e 00			ld a, 0		 ; init cli input 
16b7 77				ld (hl), a 
16b8 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16ba			cli: 
16ba				; show cli prompt 
16ba				;push af 
16ba				;ld a, 0 
16ba				;ld de, prompt 
16ba				;call str_at_display 
16ba			 
16ba				;call update_display 
16ba				;pop af 
16ba				;inc a 
16ba				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
16ba 0e 00			ld c, 0 
16bc 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16be 1e 28			ld e, 40 
16c0			 
16c0 21 7e e6			ld hl, os_cli_cmd 
16c3			 
16c3				STACKFRAME OFF $fefe $9f9f 
16c3				if DEBUG_STACK_IMB 
16c3					if OFF 
16c3						exx 
16c3						ld de, $fefe 
16c3						ld a, d 
16c3						ld hl, curframe 
16c3						call hexout 
16c3						ld a, e 
16c3						ld hl, curframe+2 
16c3						call hexout 
16c3						ld hl, $fefe 
16c3						push hl 
16c3						ld hl, $9f9f 
16c3						push hl 
16c3						exx 
16c3					endif 
16c3				endif 
16c3			endm 
# End of macro STACKFRAME
16c3			 
16c3 cd f1 0b			call input_str 
16c6			 
16c6				STACKFRAMECHK OFF $fefe $9f9f 
16c6				if DEBUG_STACK_IMB 
16c6					if OFF 
16c6						exx 
16c6						ld hl, $9f9f 
16c6						pop de   ; $9f9f 
16c6						call cmp16 
16c6						jr nz, .spnosame 
16c6						ld hl, $fefe 
16c6						pop de   ; $fefe 
16c6						call cmp16 
16c6						jr z, .spfrsame 
16c6						.spnosame: call showsperror 
16c6						.spfrsame: nop 
16c6						exx 
16c6					endif 
16c6				endif 
16c6			endm 
# End of macro STACKFRAMECHK
16c6			 
16c6				; copy input to last command 
16c6			 
16c6 21 7e e6			ld hl, os_cli_cmd 
16c9 11 7d e7			ld de, os_last_cmd 
16cc 01 ff 00			ld bc, 255 
16cf ed b0			ldir 
16d1			 
16d1				; wipe current buffer 
16d1			 
16d1			;	ld a, 0 
16d1			;	ld hl, os_cli_cmd 
16d1			;	ld de, os_cli_cmd+1 
16d1			;	ld bc, 254 
16d1			;	ldir 
16d1				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16d1			;	call strcpy 
16d1			;	ld a, 0 
16d1			;	ld (hl), a 
16d1			;	inc hl 
16d1			;	ld (hl), a 
16d1			;	inc hl 
16d1			;	ld (hl), a 
16d1			 
16d1				; switch frame buffer to program  
16d1			 
16d1 21 16 ed				ld hl, display_fb1 
16d4 22 d2 eb				ld (display_fb_active), hl 
16d7			 
16d7			;	nop 
16d7				STACKFRAME ON $fbfe $8f9f 
16d7				if DEBUG_STACK_IMB 
16d7					if ON 
16d7						exx 
16d7						ld de, $fbfe 
16d7						ld a, d 
16d7						ld hl, curframe 
16d7						call hexout 
16d7						ld a, e 
16d7						ld hl, curframe+2 
16d7						call hexout 
16d7						ld hl, $fbfe 
16d7						push hl 
16d7						ld hl, $8f9f 
16d7						push hl 
16d7						exx 
16d7					endif 
16d7				endif 
16d7			endm 
# End of macro STACKFRAME
16d7				; first time into the parser so pass over the current scratch pad 
16d7 21 7e e6			ld hl,os_cli_cmd 
16da				; tokenise the entered statement(s) in HL 
16da cd b1 1d			call forthparse 
16dd			        ; exec forth statements in top of return stack 
16dd cd f1 1d			call forthexec 
16e0				;call forthexec_cleanup 
16e0			;	call parsenext 
16e0			 
16e0				STACKFRAMECHK ON $fbfe $8f9f 
16e0				if DEBUG_STACK_IMB 
16e0					if ON 
16e0						exx 
16e0						ld hl, $8f9f 
16e0						pop de   ; $8f9f 
16e0						call cmp16 
16e0						jr nz, .spnosame 
16e0						ld hl, $fbfe 
16e0						pop de   ; $fbfe 
16e0						call cmp16 
16e0						jr z, .spfrsame 
16e0						.spnosame: call showsperror 
16e0						.spfrsame: nop 
16e0						exx 
16e0					endif 
16e0				endif 
16e0			endm 
# End of macro STACKFRAMECHK
16e0				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
16e0			 
16e0 3e 78			ld a, display_row_4 
16e2 11 14 17			ld de, endprog 
16e5			 
16e5 cd ba 09			call update_display		 
16e8			 
16e8 cd 72 19			call next_page_prompt 
16eb			 
16eb				; switch frame buffer to cli 
16eb			 
16eb 21 b7 ed				ld hl, display_fb0 
16ee 22 d2 eb				ld (display_fb_active), hl 
16f1			 
16f1			 
16f1 cd 97 09		        call clear_display 
16f4 cd ba 09			call update_display		 
16f7			 
16f7 21 7e e6			ld hl, os_cli_cmd 
16fa			 
16fa 3e 00			ld a, 0		 ; init cli input 
16fc 77				ld (hl), a 
16fd			 
16fd				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
16fd			 
16fd				; now on last line 
16fd			 
16fd				; TODO scroll screen up 
16fd			 
16fd				; TODO instead just clear screen and place at top of screen 
16fd			 
16fd			;	ld a, 0 
16fd			;	ld (f_cursor_ptr),a 
16fd			 
16fd				;call clear_display 
16fd				;call update_display 
16fd			 
16fd				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16fd 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16ff c3 ba 16			jp cli 
1702			 
1702 .. 00		freeram: db "Free bytes: $",0 
1710 ..			asc: db "1A2F" 
1714 .. 00		endprog: db "End prog...",0 
1720			 
1720			testenter2:   
1720 21 89 e3			ld hl,scratch+50 
1723 22 7a e6			ld (os_cur_ptr),hl 
1726 c3 ba 16			jp cli 
1729			 
1729			testenter:  
1729			 
1729 21 10 17			ld hl,asc 
172c			;	ld a,(hl) 
172c			;	call nibble2val 
172c cd 1b 0f			call get_byte 
172f			 
172f			 
172f			;	ld a,(hl) 
172f			;	call atohex 
172f			 
172f			;	call fourehexhl 
172f 32 89 e3			ld (scratch+50),a 
1732			 
1732			 
1732			 
1732 21 12 17			ld hl,asc+2 
1735			;	ld a, (hl) 
1735			;	call nibble2val 
1735 cd 1b 0f			call get_byte 
1738			 
1738			;	call fourehexhl 
1738 32 8b e3			ld (scratch+52),a 
173b				 
173b 21 89 e3			ld hl,scratch+50 
173e 22 7a e6			ld (os_cur_ptr),hl 
1741 c3 ba 16			jp cli 
1744			 
1744			enter:	 
1744 3a 5b e3			ld a,(scratch+4) 
1747 fe 00			cp 0 
1749 28 0c			jr z, .entercont 
174b				; no, not a null term line so has an address to work out.... 
174b			 
174b 21 59 e3			ld hl,scratch+2 
174e cd 7b 0f			call get_word_hl 
1751			 
1751 22 7a e6			ld (os_cur_ptr),hl	 
1754 c3 ba 16			jp cli 
1757			 
1757			 
1757			.entercont:  
1757			 
1757 21 59 e3			ld hl, scratch+2 
175a cd 1b 0f			call get_byte 
175d			 
175d 2a 7a e6		   	ld hl,(os_cur_ptr) 
1760 77					ld (hl),a 
1761 23					inc hl 
1762 22 7a e6				ld (os_cur_ptr),hl 
1765				 
1765			; get byte  
1765			 
1765			 
1765 c3 ba 16			jp cli 
1768			 
1768			 
1768			; basic monitor support 
1768			 
1768			monitor: 
1768				;  
1768 cd 97 09			call clear_display 
176b 3e 00			ld a, 0 
176d 11 b5 17			ld de, .monprompt 
1770 cd aa 09			call str_at_display 
1773 cd ba 09			call update_display 
1776			 
1776				; get a monitor command 
1776			 
1776 0e 00			ld c, 0     ; entry at top left 
1778 16 64			ld d, 100   ; max buffer size 
177a 1e 0f			ld e, 15    ; input scroll area 
177c 3e 00			ld a, 0     ; init string 
177e 21 55 e5			ld hl, os_input 
1781 77				ld (hl), a 
1782 23				inc hl 
1783 77				ld (hl), a 
1784 21 55 e5			ld hl, os_input 
1787 3e 01			ld a, 1     ; init string 
1789 cd f1 0b			call input_str 
178c			 
178c cd 97 09		        call clear_display 
178f cd ba 09			call update_display		 
1792			 
1792 3a 55 e5			ld a, (os_input) 
1795 cd 19 10			call toUpper 
1798 fe 48		        cp 'H' 
179a 28 6f		        jr z, .monhelp 
179c fe 44			cp 'D'		; dump 
179e ca 2c 18			jp z, .mondump	 
17a1 fe 43			cp 'C'		; dump 
17a3 ca 46 18			jp z, .moncdump	 
17a6 fe 4d			cp 'M'		; dump 
17a8 ca b7 17			jp z, .moneditstart 
17ab fe 55			cp 'U'		; dump 
17ad 28 14			jr z, .monedit	 
17af fe 51			cp 'Q'		; dump 
17b1 c8				ret z	 
17b2			 
17b2			 
17b2				; TODO "S" to access symbol by name and not need the address 
17b2				; TODO "F" to find a string in memory 
17b2			 
17b2 c3 68 17			jp monitor 
17b5			 
17b5 .. 00		.monprompt: db ">", 0 
17b7			 
17b7			.moneditstart: 
17b7				; get starting address 
17b7			 
17b7 21 57 e5			ld hl,os_input+2 
17ba cd 7b 0f			call get_word_hl 
17bd			 
17bd 22 7a e6			ld (os_cur_ptr),hl	 
17c0			 
17c0 c3 68 17			jp monitor 
17c3			 
17c3			.monedit: 
17c3				; get byte to load 
17c3			 
17c3 21 57 e5			ld hl,os_input+2 
17c6 cd 1b 0f			call get_byte 
17c9			 
17c9				; get address to update 
17c9 2a 7a e6			ld hl, (os_cur_ptr) 
17cc			 
17cc				; update byte 
17cc			 
17cc 77				ld (hl), a 
17cd			 
17cd				; move to next address and save it 
17cd			 
17cd 23				inc hl 
17ce 22 7a e6			ld (os_cur_ptr),hl	 
17d1			 
17d1 c3 68 17			jp monitor 
17d4			 
17d4			 
17d4 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
17e8 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1804 .. 00		.monhelptext3:  db "Q-Quit",0 
180b			        
180b			.monhelp: 
180b 3e 00			ld a, display_row_1 
180d 11 d4 17		        ld de, .monhelptext1 
1810			 
1810 cd aa 09			call str_at_display 
1813 3e 28			ld a, display_row_2 
1815 11 e8 17		        ld de, .monhelptext2 
1818					 
1818 cd aa 09			call str_at_display 
181b 3e 50			ld a, display_row_3 
181d 11 04 18		        ld de, .monhelptext3 
1820					 
1820 cd aa 09			call str_at_display 
1823 cd ba 09			call update_display		 
1826			 
1826 cd 72 19			call next_page_prompt 
1829 c3 68 17			jp monitor 
182c			 
182c			.mondump:    
182c 21 57 e5			ld hl,os_input+2 
182f cd 7b 0f			call get_word_hl 
1832			 
1832 22 7a e6			ld (os_cur_ptr),hl	 
1835 cd 7a 18			call dumpcont 
1838 3e 78			ld a, display_row_4 
183a 11 14 17			ld de, endprog 
183d			 
183d cd ba 09			call update_display		 
1840			 
1840 cd 72 19			call next_page_prompt 
1843 c3 68 17			jp monitor 
1846			.moncdump: 
1846 cd 7a 18			call dumpcont 
1849 3e 78			ld a, display_row_4 
184b 11 14 17			ld de, endprog 
184e			 
184e cd ba 09			call update_display		 
1851			 
1851 cd 72 19			call next_page_prompt 
1854 c3 68 17			jp monitor 
1857			 
1857			 
1857			; TODO symbol access  
1857			 
1857			.symbols:     ;; A list of symbols that can be called up  
1857 b7 ed			dw display_fb0 
1859 .. 00			db "fb0",0  
185d 5c eb		     	dw store_page 
185f .. 00			db "store_page",0 
186a			 
186a			 
186a			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
186a			 
186a 3a 58 e3			ld a,(scratch+1) 
186d fe 00			cp 0 
186f 28 09			jr z, dumpcont 
1871			 
1871				; no, not a null term line so has an address to work out.... 
1871			 
1871 21 59 e3			ld hl,scratch+2 
1874 cd 7b 0f			call get_word_hl 
1877			 
1877 22 7a e6			ld (os_cur_ptr),hl	 
187a			 
187a			 
187a			 
187a			dumpcont: 
187a			 
187a				; dump bytes at ptr 
187a			 
187a			 
187a 3e 00			ld a, display_row_1 
187c 2a d2 eb			ld hl, (display_fb_active) 
187f cd c4 0b			call addatohl 
1882 cd aa 18			call .dumpbyterow 
1885			 
1885 3e 28			ld a, display_row_2 
1887 2a d2 eb			ld hl, (display_fb_active) 
188a cd c4 0b			call addatohl 
188d cd aa 18			call .dumpbyterow 
1890			 
1890			 
1890 3e 50			ld a, display_row_3 
1892 2a d2 eb			ld hl, (display_fb_active) 
1895 cd c4 0b			call addatohl 
1898 cd aa 18			call .dumpbyterow 
189b			 
189b 3e 78			ld a, display_row_4 
189d 2a d2 eb			ld hl, (display_fb_active) 
18a0 cd c4 0b			call addatohl 
18a3 cd aa 18			call .dumpbyterow 
18a6			 
18a6 cd ba 09			call update_display 
18a9			;		jp cli 
18a9 c9				ret 
18aa			 
18aa			.dumpbyterow: 
18aa			 
18aa				;push af 
18aa			 
18aa e5				push hl 
18ab			 
18ab				; calc where to poke the ascii 
18ab			if display_cols == 20 
18ab				ld a, 16 
18ab			else 
18ab 3e 1f			ld a, 31 
18ad			endif 
18ad			 
18ad cd c4 0b			call addatohl 
18b0 22 5c e6			ld (os_word_scratch),hl  		; save pos for later 
18b3			 
18b3			 
18b3			; display decoding address 
18b3 2a 7a e6		   	ld hl,(os_cur_ptr) 
18b6			 
18b6 7c				ld a,h 
18b7 e1				pop hl 
18b8 e5				push hl 
18b9			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18b9 cd c5 0e			call hexout 
18bc 2a 7a e6		   	ld hl,(os_cur_ptr) 
18bf			 
18bf 7d				ld a,l 
18c0 e1				pop hl 
18c1 23				inc hl 
18c2 23				inc hl 
18c3 e5				push hl 
18c4			;	ld hl, os_word_scratch+2 
18c4 cd c5 0e			call hexout 
18c7 e1				pop hl 
18c8 23				inc hl 
18c9 23				inc hl 
18ca				;ld hl, os_word_scratch+4 
18ca 3e 3a			ld a, ':' 
18cc 77				ld (hl),a 
18cd 23				inc hl 
18ce				;ld a, 0 
18ce				;ld (hl),a 
18ce				;ld de, os_word_scratch 
18ce				;pop af 
18ce				;push af 
18ce			;		ld a, display_row_2 
18ce			;		call str_at_display 
18ce			;		call update_display 
18ce			 
18ce			 
18ce			;pop af 
18ce			;	add 5 
18ce			 
18ce			if display_cols == 20 
18ce				ld b, 4 
18ce			else 
18ce 06 08			ld b, 8 
18d0			endif	 
18d0			 
18d0			.dumpbyte: 
18d0 c5				push bc 
18d1 e5				push hl 
18d2			 
18d2			 
18d2 2a 7a e6		   	ld hl,(os_cur_ptr) 
18d5 7e					ld a,(hl) 
18d6			 
18d6					; poke the ascii to display 
18d6 2a 5c e6				ld hl,(os_word_scratch) 
18d9 77					ld (hl),a 
18da 23					inc hl 
18db 22 5c e6				ld (os_word_scratch),hl 
18de			 
18de					 
18de			 
18de			 
18de e1					pop hl 
18df e5					push hl 
18e0			 
18e0 cd c5 0e				call hexout 
18e3			 
18e3					 
18e3 2a 7a e6		   	ld hl,(os_cur_ptr) 
18e6 23				inc hl 
18e7 22 7a e6		   	ld (os_cur_ptr),hl 
18ea			 
18ea e1					pop hl 
18eb 23					inc hl 
18ec 23					inc hl 
18ed 23					inc hl 
18ee			 
18ee			 
18ee			 
18ee					;ld a,0 
18ee					;ld (os_word_scratch+2),a 
18ee					;pop af 
18ee					;push af 
18ee			 
18ee					;ld de, os_word_scratch 
18ee					;call str_at_display 
18ee			;		call update_display 
18ee			;		pop af 
18ee c1					pop bc 
18ef c6 03				add 3 
18f1 10 dd			djnz .dumpbyte 
18f3			 
18f3				 
18f3			 
18f3 c9				ret 
18f4			 
18f4			jump:	 
18f4			 
18f4 21 59 e3			ld hl,scratch+2 
18f7 cd 7b 0f			call get_word_hl 
18fa				;ld hl,(scratch+2) 
18fa				;call fourehexhl 
18fa			 
18fa 22 7a e6			ld (os_cur_ptr),hl	 
18fd			 
18fd e9				jp (hl) 
18fe			 
18fe			 
18fe			 
18fe			; TODO implement a basic monitor mode to start with 
18fe			 
18fe			 
18fe			 
18fe			 
18fe			 
18fe			 
18fe			 
18fe			 
18fe			 
18fe			; testing and demo code during development 
18fe			 
18fe			 
18fe .. 00		str1: db "Enter some text...",0 
1911 .. 00		clear: db "                    ",0 
1926			 
1926			demo: 
1926			 
1926			 
1926			 
1926			;	call update_display 
1926			 
1926				; init scratch input area for testing 
1926 21 57 e3			ld hl, scratch	 
1929 3e 00			ld a,0 
192b 77				ld (hl),a 
192c			 
192c			 
192c 3e 28		            LD   A, display_row_2 
192e			;            CALL fLCD_Pos       ;Position cursor to location in A 
192e 11 fe 18		            LD   DE, str1 
1931 cd aa 09			call str_at_display 
1934			 
1934			;            CALL fLCD_Str       ;Display string pointed to by DE 
1934			cloop:	 
1934 3e 50		            LD   A, display_row_3 
1936			;            CALL fLCD_Pos       ;Position cursor to location in A 
1936 11 11 19		            LD   DE, clear 
1939			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1939 cd aa 09				call str_at_display 
193c 3e 78			ld a, display_row_4 
193e 11 6e 19			ld de, prompt 
1941			 
1941 cd aa 09				call str_at_display 
1944 cd ba 09			call update_display 
1947			 
1947 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1949 16 0a			ld d, 10 
194b 21 57 e3			ld hl, scratch	 
194e cd f1 0b			call input_str 
1951			 
1951			;	call clear_display 
1951			;'	call update_display 
1951			 
1951 3e 00		            LD   A, display_row_1 
1953			;            CALL fLCD_Pos       ;Position cursor to location in A 
1953 11 11 19		            LD   DE, clear 
1956 cd aa 09				call str_at_display 
1959			;            CALL fLCD_Str       ;Display string pointed to by DE 
1959 3e 00		            LD   A, display_row_1 
195b			;            CALL fLCD_Pos       ;Position cursor to location in A 
195b 11 57 e3		            LD   DE, scratch 
195e			;            CALL fLCD_Str       ;Display string pointed to by DE 
195e cd aa 09				call str_at_display 
1961 cd ba 09			call update_display 
1964			 
1964 3e 00				ld a,0 
1966 21 57 e3			ld hl, scratch 
1969 77				ld (hl),a 
196a			 
196a 00				nop 
196b c3 34 19			jp cloop 
196e			 
196e			 
196e			 
196e			; OS Prompt 
196e			 
196e .. 00		prompt: db ">",0 
1970 .. 00		endprg: db "?",0 
1972			 
1972			 
1972			; handy next page prompt 
1972			next_page_prompt: 
1972 e5				push hl 
1973 d5				push de 
1974 f5				push af 
1975 c5				push bc 
1976			 
1976 3e 9f			ld a,display_row_4 + display_cols - 1 
1978 11 70 19		        ld de, endprg 
197b cd aa 09			call str_at_display 
197e cd ba 09			call update_display 
1981 cd 17 59			call cin_wait 
1984 c1				pop bc 
1985 f1				pop af 
1986 d1				pop de 
1987 e1				pop hl 
1988			 
1988			 
1988 c9				ret 
1989			 
1989			 
1989			; forth parser 
1989			 
1989			; My forth kernel 
1989			include "forth_kernel.asm" 
1989			; 
1989			; kernel to the forth OS 
1989			 
1989			DS_TYPE_STR: equ 1     ; string type 
1989			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1989			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1989			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1989			 
1989			FORTH_PARSEV1: equ 0 
1989			FORTH_PARSEV2: equ 0 
1989			FORTH_PARSEV3: equ 0 
1989			FORTH_PARSEV4: equ 0 
1989			FORTH_PARSEV5: equ 1 
1989			 
1989			;if FORTH_PARSEV5 
1989			;	FORTH_END_BUFFER: equ 0 
1989			;else 
1989			FORTH_END_BUFFER: equ 127 
1989			;endif 
1989			 
1989			FORTH_TRUE: equ 1 
1989			FORTH_FALSE: equ 0 
1989			 
1989			if FORTH_PARSEV4 
1989			include "forth_stackops.asm" 
1989			endif 
1989			 
1989			if FORTH_PARSEV5 
1989			include "forth_stackopsv5.asm" 
1989			 
1989			; Stack operations for v5 parser on wards 
1989			; * DATA stack 
1989			; * LOOP stack 
1989			; * RETURN stack 
1989			 
1989			 
1989			 
1989			FORTH_CHK_DSP_UNDER: macro 
1989				push hl 
1989				push de 
1989				ld hl,(cli_data_sp) 
1989				ld de, cli_data_stack 
1989				call cmp16 
1989				jp c, fault_dsp_under 
1989				pop de 
1989				pop hl 
1989				endm 
1989			 
1989			 
1989			FORTH_CHK_RSP_UNDER: macro 
1989				push hl 
1989				push de 
1989				ld hl,(cli_ret_sp) 
1989				ld de, cli_ret_stack 
1989				call cmp16 
1989				jp c, fault_rsp_under 
1989				pop de 
1989				pop hl 
1989				endm 
1989			 
1989			FORTH_CHK_LOOP_UNDER: macro 
1989				push hl 
1989				push de 
1989				ld hl,(cli_loop_sp) 
1989				ld de, cli_loop_stack 
1989				call cmp16 
1989				jp c, fault_loop_under 
1989				pop de 
1989				pop hl 
1989				endm 
1989			 
1989			FORTH_ERR_TOS_NOTSTR: macro 
1989				; TOSO might need more for checks when used 
1989				push af 
1989				ld a,(hl) 
1989				cp DS_TYPE_STR 
1989				jp nz, type_faultn   
1989				pop af 
1989				endm 
1989			 
1989			FORTH_ERR_TOS_NOTNUM: macro 
1989				push af 
1989				ld a,(hl) 
1989				cp DS_TYPE_INUM 
1989				jp nz, type_faultn   
1989				pop af 
1989				endm 
1989			 
1989			 
1989			; increase data stack pointer and save hl to it 
1989				 
1989			FORTH_DSP_NEXT: macro 
1989				call macro_forth_dsp_next 
1989				endm 
1989			 
1989			 
1989			macro_forth_dsp_next: 
1989				if DEBUG_FORTH_STACK_GUARD 
1989 cd 2f 56				call check_stacks 
198c				endif 
198c e5				push hl 
198d d5				push de 
198e eb				ex de,hl 
198f 2a 04 eb			ld hl,(cli_data_sp) 
1992 23				inc hl 
1993 23				inc hl 
1994			 
1994			; PARSEV5 
1994 23				inc hl 
1995 22 04 eb			ld (cli_data_sp),hl 
1998 73				ld (hl), e 
1999 23				inc hl 
199a 72				ld (hl), d 
199b d1				pop de 
199c e1				pop hl 
199d				if DEBUG_FORTH_STACK_GUARD 
199d cd 2f 56				call check_stacks 
19a0				endif 
19a0 c9				ret 
19a1			 
19a1			 
19a1			; increase ret stack pointer and save hl to it 
19a1				 
19a1			FORTH_RSP_NEXT: macro 
19a1				call macro_forth_rsp_next 
19a1				endm 
19a1			 
19a1			macro_forth_rsp_next: 
19a1				if DEBUG_FORTH_STACK_GUARD 
19a1 cd 2f 56				call check_stacks 
19a4				endif 
19a4 e5				push hl 
19a5 d5				push de 
19a6 eb				ex de,hl 
19a7 2a 08 eb			ld hl,(cli_ret_sp) 
19aa 23				inc hl 
19ab 23				inc hl 
19ac 22 08 eb			ld (cli_ret_sp),hl 
19af 73				ld (hl), e 
19b0 23				inc hl 
19b1 72				ld (hl), d 
19b2 d1				pop de 
19b3 e1				pop hl 
19b4				if DEBUG_FORTH_STACK_GUARD 
19b4 cd 2f 56				call check_stacks 
19b7				endif 
19b7 c9				ret 
19b8			 
19b8			; get current ret stack pointer and save to hl  
19b8				 
19b8			FORTH_RSP_TOS: macro 
19b8				call macro_forth_rsp_tos 
19b8				endm 
19b8			 
19b8			macro_forth_rsp_tos: 
19b8				;push de 
19b8 2a 08 eb			ld hl,(cli_ret_sp) 
19bb cd f3 19			call loadhlptrtohl 
19be				;ld e, (hl) 
19be				;inc hl 
19be				;ld d, (hl) 
19be				;ex de, hl 
19be					if DEBUG_FORTH_WORDS 
19be			;			DMARK "RST" 
19be						CALLMONITOR 
19be cd 6d 14			call break_point_state  
19c1				endm  
# End of macro CALLMONITOR
19c1					endif 
19c1				;pop de 
19c1 c9				ret 
19c2			 
19c2			; pop ret stack pointer 
19c2				 
19c2			FORTH_RSP_POP: macro 
19c2				call macro_forth_rsp_pop 
19c2				endm 
19c2			 
19c2			 
19c2			macro_forth_rsp_pop: 
19c2				if DEBUG_FORTH_STACK_GUARD 
19c2			;		DMARK "RPP" 
19c2 cd 2f 56				call check_stacks 
19c5					FORTH_CHK_RSP_UNDER 
19c5 e5				push hl 
19c6 d5				push de 
19c7 2a 08 eb			ld hl,(cli_ret_sp) 
19ca 11 c2 ea			ld de, cli_ret_stack 
19cd cd e2 0b			call cmp16 
19d0 da 43 57			jp c, fault_rsp_under 
19d3 d1				pop de 
19d4 e1				pop hl 
19d5				endm 
# End of macro FORTH_CHK_RSP_UNDER
19d5				endif 
19d5 e5				push hl 
19d6 2a 08 eb			ld hl,(cli_ret_sp) 
19d9			 
19d9			 
19d9				if FORTH_ENABLE_FREE 
19d9			 
19d9					; get pointer 
19d9			 
19d9					push de 
19d9					push hl 
19d9			 
19d9					ld e, (hl) 
19d9					inc hl 
19d9					ld d, (hl) 
19d9			 
19d9					ex de, hl 
19d9					call free 
19d9			 
19d9					pop hl 
19d9					pop de 
19d9			 
19d9			 
19d9				endif 
19d9			 
19d9			 
19d9 2b				dec hl 
19da 2b				dec hl 
19db 22 08 eb			ld (cli_ret_sp), hl 
19de				; do stack underflow checks 
19de e1				pop hl 
19df				if DEBUG_FORTH_STACK_GUARD 
19df cd 2f 56				call check_stacks 
19e2					FORTH_CHK_RSP_UNDER 
19e2 e5				push hl 
19e3 d5				push de 
19e4 2a 08 eb			ld hl,(cli_ret_sp) 
19e7 11 c2 ea			ld de, cli_ret_stack 
19ea cd e2 0b			call cmp16 
19ed da 43 57			jp c, fault_rsp_under 
19f0 d1				pop de 
19f1 e1				pop hl 
19f2				endm 
# End of macro FORTH_CHK_RSP_UNDER
19f2				endif 
19f2 c9				ret 
19f3			 
19f3			 
19f3			 
19f3			; routine to load word pointed to by hl into hl 
19f3			 
19f3			loadhlptrtohl: 
19f3			 
19f3 d5				push de 
19f4 5e				ld e, (hl) 
19f5 23				inc hl 
19f6 56				ld d, (hl) 
19f7 eb				ex de, hl 
19f8 d1				pop de 
19f9			 
19f9 c9				ret 
19fa			 
19fa			 
19fa			 
19fa			 
19fa			 
19fa			; push a number held in HL onto the data stack 
19fa			; entry point for pushing a value when already in hl used in function above 
19fa			 
19fa			forth_push_numhl: 
19fa			 
19fa e5				push hl    ; save value to push 
19fb			 
19fb			if DEBUG_FORTH_PUSH 
19fb				; see if disabled 
19fb			 
19fb			 
19fb f5				push af 
19fc 3a 48 e3			ld a, (os_view_disable) 
19ff fe 2a			cp '*' 
1a01 28 34			jr z, .pskip2 
1a03 e5				push hl 
1a04 e5			push hl 
1a05 cd 97 09			call clear_display 
1a08 e1			pop hl 
1a09 7c				ld a,h 
1a0a 21 5c e6			ld hl, os_word_scratch 
1a0d cd c5 0e			call hexout 
1a10 e1				pop hl 
1a11 7d				ld a,l 
1a12 21 5e e6			ld hl, os_word_scratch+2 
1a15 cd c5 0e			call hexout 
1a18			 
1a18 21 60 e6			ld hl, os_word_scratch+4 
1a1b 3e 00			ld a,0 
1a1d 77				ld (hl),a 
1a1e 11 5c e6			ld de,os_word_scratch 
1a21 3e 28				ld a, display_row_2 
1a23 cd aa 09				call str_at_display 
1a26 11 3d 45			ld de, .push_num 
1a29 3e 00			ld a, display_row_1 
1a2b			 
1a2b cd aa 09				call str_at_display 
1a2e			 
1a2e			 
1a2e cd ba 09			call update_display 
1a31 cd 09 09			call delay1s 
1a34 cd 09 09			call delay1s 
1a37			.pskip2:  
1a37			 
1a37 f1				pop af 
1a38			endif	 
1a38			 
1a38			 
1a38				FORTH_DSP_NEXT 
1a38 cd 89 19			call macro_forth_dsp_next 
1a3b				endm 
# End of macro FORTH_DSP_NEXT
1a3b			 
1a3b 2a 04 eb			ld hl, (cli_data_sp) 
1a3e			 
1a3e				; save item type 
1a3e 3e 02			ld a,  DS_TYPE_INUM 
1a40 77				ld (hl), a 
1a41 23				inc hl 
1a42			 
1a42				; get word off stack 
1a42 d1				pop de 
1a43 7b				ld a,e 
1a44 77				ld (hl), a 
1a45 23				inc hl 
1a46 7a				ld a,d 
1a47 77				ld (hl), a 
1a48			 
1a48			if DEBUG_FORTH_PUSH 
1a48 2b				dec hl 
1a49 2b				dec hl 
1a4a 2b				dec hl 
1a4b						DMARK "PH5" 
1a4b f5				push af  
1a4c 3a 60 1a			ld a, (.dmark)  
1a4f 32 71 ee			ld (debug_mark),a  
1a52 3a 61 1a			ld a, (.dmark+1)  
1a55 32 72 ee			ld (debug_mark+1),a  
1a58 3a 62 1a			ld a, (.dmark+2)  
1a5b 32 73 ee			ld (debug_mark+2),a  
1a5e 18 03			jr .pastdmark  
1a60 ..			.dmark: db "PH5"  
1a63 f1			.pastdmark: pop af  
1a64			endm  
# End of macro DMARK
1a64				CALLMONITOR 
1a64 cd 6d 14			call break_point_state  
1a67				endm  
# End of macro CALLMONITOR
1a67			endif	 
1a67			 
1a67 c9				ret 
1a68			 
1a68			 
1a68			; Push a string to stack pointed to by hl 
1a68			 
1a68			forth_push_str: 
1a68			 
1a68			if DEBUG_FORTH_PUSH 
1a68						DMARK "PSQ" 
1a68 f5				push af  
1a69 3a 7d 1a			ld a, (.dmark)  
1a6c 32 71 ee			ld (debug_mark),a  
1a6f 3a 7e 1a			ld a, (.dmark+1)  
1a72 32 72 ee			ld (debug_mark+1),a  
1a75 3a 7f 1a			ld a, (.dmark+2)  
1a78 32 73 ee			ld (debug_mark+2),a  
1a7b 18 03			jr .pastdmark  
1a7d ..			.dmark: db "PSQ"  
1a80 f1			.pastdmark: pop af  
1a81			endm  
# End of macro DMARK
1a81				CALLMONITOR 
1a81 cd 6d 14			call break_point_state  
1a84				endm  
# End of macro CALLMONITOR
1a84			endif	 
1a84			    
1a84 e5				push hl 
1a85 e5				push hl 
1a86			 
1a86			;	ld a, 0   ; find end of string 
1a86 cd 22 10			call strlenz 
1a89			if DEBUG_FORTH_PUSH 
1a89						DMARK "PQ2" 
1a89 f5				push af  
1a8a 3a 9e 1a			ld a, (.dmark)  
1a8d 32 71 ee			ld (debug_mark),a  
1a90 3a 9f 1a			ld a, (.dmark+1)  
1a93 32 72 ee			ld (debug_mark+1),a  
1a96 3a a0 1a			ld a, (.dmark+2)  
1a99 32 73 ee			ld (debug_mark+2),a  
1a9c 18 03			jr .pastdmark  
1a9e ..			.dmark: db "PQ2"  
1aa1 f1			.pastdmark: pop af  
1aa2			endm  
# End of macro DMARK
1aa2				CALLMONITOR 
1aa2 cd 6d 14			call break_point_state  
1aa5				endm  
# End of macro CALLMONITOR
1aa5			endif	 
1aa5 eb				ex de, hl 
1aa6 e1				pop hl   ; get ptr to start of string 
1aa7			if DEBUG_FORTH_PUSH 
1aa7						DMARK "PQ3" 
1aa7 f5				push af  
1aa8 3a bc 1a			ld a, (.dmark)  
1aab 32 71 ee			ld (debug_mark),a  
1aae 3a bd 1a			ld a, (.dmark+1)  
1ab1 32 72 ee			ld (debug_mark+1),a  
1ab4 3a be 1a			ld a, (.dmark+2)  
1ab7 32 73 ee			ld (debug_mark+2),a  
1aba 18 03			jr .pastdmark  
1abc ..			.dmark: db "PQ3"  
1abf f1			.pastdmark: pop af  
1ac0			endm  
# End of macro DMARK
1ac0				CALLMONITOR 
1ac0 cd 6d 14			call break_point_state  
1ac3				endm  
# End of macro CALLMONITOR
1ac3			endif	 
1ac3 19				add hl,de 
1ac4			if DEBUG_FORTH_PUSH 
1ac4						DMARK "PQE" 
1ac4 f5				push af  
1ac5 3a d9 1a			ld a, (.dmark)  
1ac8 32 71 ee			ld (debug_mark),a  
1acb 3a da 1a			ld a, (.dmark+1)  
1ace 32 72 ee			ld (debug_mark+1),a  
1ad1 3a db 1a			ld a, (.dmark+2)  
1ad4 32 73 ee			ld (debug_mark+2),a  
1ad7 18 03			jr .pastdmark  
1ad9 ..			.dmark: db "PQE"  
1adc f1			.pastdmark: pop af  
1add			endm  
# End of macro DMARK
1add				CALLMONITOR 
1add cd 6d 14			call break_point_state  
1ae0				endm  
# End of macro CALLMONITOR
1ae0			endif	 
1ae0			 
1ae0 2b				dec hl    ; see if there is an optional trailing double quote 
1ae1 7e				ld a,(hl) 
1ae2 fe 22			cp '"' 
1ae4 20 03			jr nz, .strnoq 
1ae6 3e 00			ld a, 0      ; get rid of double quote 
1ae8 77				ld (hl), a 
1ae9 23			.strnoq: inc hl 
1aea			 
1aea 3e 00			ld a, 0 
1aec 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1aed			 
1aed 13				inc de ; add one for the type string 
1aee 13				inc de ; add one for null term??? 
1aef			 
1aef				; tos is get string pointer again 
1aef				; de contains space to allocate 
1aef				 
1aef d5				push de 
1af0			 
1af0 eb				ex de, hl 
1af1			 
1af1				;push af 
1af1			 
1af1			if DEBUG_FORTH_PUSH 
1af1						DMARK "PHm" 
1af1 f5				push af  
1af2 3a 06 1b			ld a, (.dmark)  
1af5 32 71 ee			ld (debug_mark),a  
1af8 3a 07 1b			ld a, (.dmark+1)  
1afb 32 72 ee			ld (debug_mark+1),a  
1afe 3a 08 1b			ld a, (.dmark+2)  
1b01 32 73 ee			ld (debug_mark+2),a  
1b04 18 03			jr .pastdmark  
1b06 ..			.dmark: db "PHm"  
1b09 f1			.pastdmark: pop af  
1b0a			endm  
# End of macro DMARK
1b0a				CALLMONITOR 
1b0a cd 6d 14			call break_point_state  
1b0d				endm  
# End of macro CALLMONITOR
1b0d			endif	 
1b0d cd 8b 10			call malloc	; on ret hl now contains allocated memory 
1b10				if DEBUG_FORTH_MALLOC_GUARD 
1b10 cc 95 45				call z,malloc_error 
1b13				endif 
1b13			 
1b13				 
1b13 c1				pop bc    ; get length 
1b14 d1				pop de   ;  get string start    
1b15			 
1b15				; hl has destination from malloc 
1b15			 
1b15 eb				ex de, hl    ; prep for ldir 
1b16			 
1b16 d5				push de   ; save malloc area for DSP later 
1b17				;push hl   ; save malloc area for DSP later 
1b17			 
1b17			if DEBUG_FORTH_PUSH 
1b17						DMARK "PHc" 
1b17 f5				push af  
1b18 3a 2c 1b			ld a, (.dmark)  
1b1b 32 71 ee			ld (debug_mark),a  
1b1e 3a 2d 1b			ld a, (.dmark+1)  
1b21 32 72 ee			ld (debug_mark+1),a  
1b24 3a 2e 1b			ld a, (.dmark+2)  
1b27 32 73 ee			ld (debug_mark+2),a  
1b2a 18 03			jr .pastdmark  
1b2c ..			.dmark: db "PHc"  
1b2f f1			.pastdmark: pop af  
1b30			endm  
# End of macro DMARK
1b30				CALLMONITOR 
1b30 cd 6d 14			call break_point_state  
1b33				endm  
# End of macro CALLMONITOR
1b33			endif	 
1b33			 
1b33			 
1b33 ed b0			ldir 
1b35			 
1b35			 
1b35				; push malloc to data stack     macro?????  
1b35			 
1b35				FORTH_DSP_NEXT 
1b35 cd 89 19			call macro_forth_dsp_next 
1b38				endm 
# End of macro FORTH_DSP_NEXT
1b38			 
1b38				; save value and type 
1b38			 
1b38 2a 04 eb			ld hl, (cli_data_sp) 
1b3b			 
1b3b				; save item type 
1b3b 3e 01			ld a,  DS_TYPE_STR 
1b3d 77				ld (hl), a 
1b3e 23				inc hl 
1b3f			 
1b3f				; get malloc word off stack 
1b3f d1				pop de 
1b40 73				ld (hl), e 
1b41 23				inc hl 
1b42 72				ld (hl), d 
1b43			 
1b43			 
1b43			 
1b43			if DEBUG_FORTH_PUSH 
1b43 2a 04 eb			ld hl, (cli_data_sp) 
1b46						DMARK "PHS" 
1b46 f5				push af  
1b47 3a 5b 1b			ld a, (.dmark)  
1b4a 32 71 ee			ld (debug_mark),a  
1b4d 3a 5c 1b			ld a, (.dmark+1)  
1b50 32 72 ee			ld (debug_mark+1),a  
1b53 3a 5d 1b			ld a, (.dmark+2)  
1b56 32 73 ee			ld (debug_mark+2),a  
1b59 18 03			jr .pastdmark  
1b5b ..			.dmark: db "PHS"  
1b5e f1			.pastdmark: pop af  
1b5f			endm  
# End of macro DMARK
1b5f				CALLMONITOR 
1b5f cd 6d 14			call break_point_state  
1b62				endm  
# End of macro CALLMONITOR
1b62			;	ex de,hl 
1b62			endif	 
1b62				; in case of spaces, skip the ptr past the copied string 
1b62				;pop af 
1b62				;ld (cli_origptr),hl 
1b62			 
1b62 c9				ret 
1b63			 
1b63			 
1b63			 
1b63			; TODO ascii push input onto stack given hl to start of input 
1b63			 
1b63			; identify type 
1b63			; if starts with a " then a string 
1b63			; otherwise it is a number 
1b63			;  
1b63			; if a string 
1b63			;     scan for ending " to get length of string to malloc for + 1 
1b63			;     malloc 
1b63			;     put pointer to string on stack first byte flags as string 
1b63			; 
1b63			; else a number 
1b63			;    look for number format identifier 
1b63			;    $xx hex 
1b63			;    %xxxxx bin 
1b63			;    xxxxx decimal 
1b63			;    convert number to 16bit word.  
1b63			;    malloc word + 1 with flag to identiy as num 
1b63			;    put pointer to number on stack 
1b63			;   
1b63			;  
1b63			  
1b63			forth_apush: 
1b63				; kernel push 
1b63			 
1b63			if DEBUG_FORTH_PUSH 
1b63						DMARK "PSH" 
1b63 f5				push af  
1b64 3a 78 1b			ld a, (.dmark)  
1b67 32 71 ee			ld (debug_mark),a  
1b6a 3a 79 1b			ld a, (.dmark+1)  
1b6d 32 72 ee			ld (debug_mark+1),a  
1b70 3a 7a 1b			ld a, (.dmark+2)  
1b73 32 73 ee			ld (debug_mark+2),a  
1b76 18 03			jr .pastdmark  
1b78 ..			.dmark: db "PSH"  
1b7b f1			.pastdmark: pop af  
1b7c			endm  
# End of macro DMARK
1b7c				CALLMONITOR 
1b7c cd 6d 14			call break_point_state  
1b7f				endm  
# End of macro CALLMONITOR
1b7f			endif	 
1b7f				; identify input type 
1b7f			 
1b7f 7e				ld a,(hl) 
1b80 fe 22			cp '"' 
1b82 28 0a			jr z, .fapstr 
1b84 fe 24			cp '$' 
1b86 ca ae 1b			jp z, .faphex 
1b89 fe 25			cp '%' 
1b8b ca 96 1b			jp z, .fapbin 
1b8e			;	cp 'b' 
1b8e			;	jp z, .fabin 
1b8e				; else decimal 
1b8e			 
1b8e				; TODO do decimal conversion 
1b8e				; decimal is stored as a 16bit word 
1b8e			 
1b8e				; by default everything is a string if type is not detected 
1b8e			.fapstr: ; 
1b8e fe 22			cp '"' 
1b90 20 01			jr nz, .strnoqu 
1b92 23				inc hl 
1b93			.strnoqu: 
1b93 c3 68 1a			jp forth_push_str 
1b96			 
1b96			 
1b96			 
1b96			.fapbin:    ; push a binary string.  
1b96 11 00 00			ld de, 0   ; hold a 16bit value 
1b99			 
1b99 23			.fapbinshift:	inc hl  
1b9a 7e				ld a,(hl) 
1b9b fe 00			cp 0     ; done scanning  
1b9d 28 0b			jr z, .fapbdone  	; got it in HL so push  
1b9f			 
1b9f				; left shift de 
1b9f eb				ex de, hl	 
1ba0 29				add hl, hl 
1ba1			 
1ba1				; is 1 
1ba1 fe 31			cp '1' 
1ba3 20 02			jr nz, .binzero 
1ba5 cb 4d			bit 1, l 
1ba7			.binzero: 
1ba7 eb				ex de, hl	 ; save current de 
1ba8 18 ef			jr .fapbinshift 
1baa			 
1baa			.fapbdone: 
1baa eb				ex de, hl 
1bab c3 fa 19			jp forth_push_numhl 
1bae			 
1bae			 
1bae			.faphex:   ; hex is always stored as a 16bit word 
1bae				; skip number prefix 
1bae 23				inc hl 
1baf				; turn ascii into number 
1baf cd 7b 0f			call get_word_hl	; ret 16bit word in hl 
1bb2			 
1bb2 c3 fa 19			jp forth_push_numhl 
1bb5			 
1bb5 00				 nop 
1bb6			 
1bb6			.fabin:   ; TODO bin conversion 
1bb6			 
1bb6			 
1bb6 c9				ret 
1bb7			 
1bb7			 
1bb7			; get either a string ptr or a 16bit word from the data stack 
1bb7			 
1bb7			FORTH_DSP: macro 
1bb7				call macro_forth_dsp 
1bb7				endm 
1bb7			 
1bb7			macro_forth_dsp: 
1bb7				; data stack pointer points to current word on tos 
1bb7			 
1bb7 2a 04 eb			ld hl,(cli_data_sp) 
1bba			 
1bba				if DEBUG_FORTH_PUSH 
1bba						DMARK "DSP" 
1bba f5				push af  
1bbb 3a cf 1b			ld a, (.dmark)  
1bbe 32 71 ee			ld (debug_mark),a  
1bc1 3a d0 1b			ld a, (.dmark+1)  
1bc4 32 72 ee			ld (debug_mark+1),a  
1bc7 3a d1 1b			ld a, (.dmark+2)  
1bca 32 73 ee			ld (debug_mark+2),a  
1bcd 18 03			jr .pastdmark  
1bcf ..			.dmark: db "DSP"  
1bd2 f1			.pastdmark: pop af  
1bd3			endm  
# End of macro DMARK
1bd3			 
1bd3 cd ca 45				call display_data_sp 
1bd6				;call break_point_state 
1bd6				;rst 030h 
1bd6				CALLMONITOR 
1bd6 cd 6d 14			call break_point_state  
1bd9				endm  
# End of macro CALLMONITOR
1bd9				endif 
1bd9			 
1bd9 c9				ret 
1bda			 
1bda			; return hl to start of value on stack 
1bda			 
1bda			FORTH_DSP_VALUE: macro 
1bda				call macro_forth_dsp_value 
1bda				endm 
1bda			 
1bda			macro_forth_dsp_value: 
1bda			 
1bda				FORTH_DSP 
1bda cd b7 1b			call macro_forth_dsp 
1bdd				endm 
# End of macro FORTH_DSP
1bdd			 
1bdd d5				push de 
1bde			 
1bde 23				inc hl ; skip type 
1bdf			 
1bdf 5e				ld e, (hl) 
1be0 23				inc hl 
1be1 56				ld d, (hl) 
1be2 eb				ex de,hl  
1be3			 
1be3 d1				pop de 
1be4			 
1be4 c9				ret 
1be5			 
1be5			; return hl to start of value to second item on stack 
1be5			 
1be5			FORTH_DSP_VALUEM1: macro 
1be5				call macro_forth_dsp_value_m1 
1be5				endm 
1be5			 
1be5			macro_forth_dsp_value_m1: 
1be5			 
1be5				FORTH_DSP 
1be5 cd b7 1b			call macro_forth_dsp 
1be8				endm 
# End of macro FORTH_DSP
1be8			 
1be8 2b				dec hl 
1be9 2b				dec hl 
1bea			;	dec hl 
1bea			 
1bea d5				push de 
1beb			 
1beb 5e				ld e, (hl) 
1bec 23				inc hl 
1bed 56				ld d, (hl) 
1bee eb				ex de,hl  
1bef			 
1bef d1				pop de 
1bf0			 
1bf0 c9				ret 
1bf1			 
1bf1				 
1bf1			 
1bf1			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1bf1			 
1bf1			FORTH_DSP_POP: macro 
1bf1				call macro_forth_dsp_pop 
1bf1				endm 
1bf1			 
1bf1			 
1bf1			; get the tos data type 
1bf1			 
1bf1			FORTH_DSP_TYPE:   macro 
1bf1			 
1bf1				;FORTH_DSP_VALUE 
1bf1				FORTH_DSP 
1bf1				 
1bf1				; hl points to value 
1bf1				; check type 
1bf1			 
1bf1				ld a,(hl) 
1bf1			 
1bf1				endm 
1bf1			 
1bf1			; load the tos value into hl 
1bf1			 
1bf1			 
1bf1			FORTH_DSP_VALUEHL:  macro 
1bf1				call macro_dsp_valuehl 
1bf1				endm 
1bf1			 
1bf1			 
1bf1			 
1bf1			macro_dsp_valuehl: 
1bf1				FORTH_DSP_VALUE 
1bf1 cd da 1b			call macro_forth_dsp_value 
1bf4				endm 
# End of macro FORTH_DSP_VALUE
1bf4			 
1bf4				;FORTH_ERR_TOS_NOTNUM 
1bf4			 
1bf4				;inc hl   ; skip type id 
1bf4			 
1bf4			;	push de 
1bf4			; 
1bf4			;	ld e, (hl) 
1bf4			;	inc hl 
1bf4			;	ld d, (hl) 
1bf4			;	ex de,hl  
1bf4			 
1bf4			;	pop de 
1bf4			 
1bf4				if DEBUG_FORTH_PUSH 
1bf4						DMARK "DVL" 
1bf4 f5				push af  
1bf5 3a 09 1c			ld a, (.dmark)  
1bf8 32 71 ee			ld (debug_mark),a  
1bfb 3a 0a 1c			ld a, (.dmark+1)  
1bfe 32 72 ee			ld (debug_mark+1),a  
1c01 3a 0b 1c			ld a, (.dmark+2)  
1c04 32 73 ee			ld (debug_mark+2),a  
1c07 18 03			jr .pastdmark  
1c09 ..			.dmark: db "DVL"  
1c0c f1			.pastdmark: pop af  
1c0d			endm  
# End of macro DMARK
1c0d				CALLMONITOR 
1c0d cd 6d 14			call break_point_state  
1c10				endm  
# End of macro CALLMONITOR
1c10				endif 
1c10 c9				ret 
1c11			 
1c11			forth_apushstrhl:      
1c11				; push of string requires use of cli_origptr 
1c11				; bodge use 
1c11			 
1c11				; get current cli_origptr, save, update with temp pointer  
1c11 ed 5b 20 eb		ld de, (cli_origptr) 
1c15 22 20 eb			ld (cli_origptr), hl 
1c18 d5				push de 
1c19 cd 63 1b			call forth_apush 
1c1c d1				pop de 
1c1d ed 53 20 eb		ld (cli_origptr), de 
1c21 c9			        ret	 
1c22			 
1c22			 
1c22			; increase loop stack pointer and save hl to it 
1c22				 
1c22			FORTH_LOOP_NEXT: macro 
1c22				call macro_forth_loop_next 
1c22				;nop 
1c22				endm 
1c22			 
1c22			macro_forth_loop_next: 
1c22				if DEBUG_FORTH_STACK_GUARD 
1c22 cd 2f 56				call check_stacks 
1c25				endif 
1c25 e5				push hl 
1c26 d5				push de 
1c27 eb				ex de,hl 
1c28 2a 06 eb			ld hl,(cli_loop_sp) 
1c2b 23				inc hl 
1c2c 23				inc hl 
1c2d					if DEBUG_FORTH_WORDS 
1c2d						DMARK "LNX" 
1c2d f5				push af  
1c2e 3a 42 1c			ld a, (.dmark)  
1c31 32 71 ee			ld (debug_mark),a  
1c34 3a 43 1c			ld a, (.dmark+1)  
1c37 32 72 ee			ld (debug_mark+1),a  
1c3a 3a 44 1c			ld a, (.dmark+2)  
1c3d 32 73 ee			ld (debug_mark+2),a  
1c40 18 03			jr .pastdmark  
1c42 ..			.dmark: db "LNX"  
1c45 f1			.pastdmark: pop af  
1c46			endm  
# End of macro DMARK
1c46						CALLMONITOR 
1c46 cd 6d 14			call break_point_state  
1c49				endm  
# End of macro CALLMONITOR
1c49					endif 
1c49 22 06 eb			ld (cli_loop_sp),hl 
1c4c 73				ld (hl), e 
1c4d 23				inc hl 
1c4e 72				ld (hl), d 
1c4f d1				pop de    ; been reversed so save a swap on restore 
1c50 e1				pop hl 
1c51				if DEBUG_FORTH_STACK_GUARD 
1c51 cd 2f 56				call check_stacks 
1c54				endif 
1c54 c9				ret 
1c55			 
1c55			; get current ret stack pointer and save to hl  
1c55				 
1c55			FORTH_LOOP_TOS: macro 
1c55				call macro_forth_loop_tos 
1c55				endm 
1c55			 
1c55			macro_forth_loop_tos: 
1c55 d5				push de 
1c56 2a 06 eb			ld hl,(cli_loop_sp) 
1c59 5e				ld e, (hl) 
1c5a 23				inc hl 
1c5b 56				ld d, (hl) 
1c5c eb				ex de, hl 
1c5d d1				pop de 
1c5e c9				ret 
1c5f			 
1c5f			; pop loop stack pointer 
1c5f				 
1c5f			FORTH_LOOP_POP: macro 
1c5f				call macro_forth_loop_pop 
1c5f				endm 
1c5f			 
1c5f			 
1c5f			macro_forth_loop_pop: 
1c5f				if DEBUG_FORTH_STACK_GUARD 
1c5f					DMARK "LPP" 
1c5f f5				push af  
1c60 3a 74 1c			ld a, (.dmark)  
1c63 32 71 ee			ld (debug_mark),a  
1c66 3a 75 1c			ld a, (.dmark+1)  
1c69 32 72 ee			ld (debug_mark+1),a  
1c6c 3a 76 1c			ld a, (.dmark+2)  
1c6f 32 73 ee			ld (debug_mark+2),a  
1c72 18 03			jr .pastdmark  
1c74 ..			.dmark: db "LPP"  
1c77 f1			.pastdmark: pop af  
1c78			endm  
# End of macro DMARK
1c78 cd 2f 56				call check_stacks 
1c7b					FORTH_CHK_LOOP_UNDER 
1c7b e5				push hl 
1c7c d5				push de 
1c7d 2a 06 eb			ld hl,(cli_loop_sp) 
1c80 11 c0 e9			ld de, cli_loop_stack 
1c83 cd e2 0b			call cmp16 
1c86 da 49 57			jp c, fault_loop_under 
1c89 d1				pop de 
1c8a e1				pop hl 
1c8b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c8b				endif 
1c8b e5				push hl 
1c8c 2a 06 eb			ld hl,(cli_loop_sp) 
1c8f 2b				dec hl 
1c90 2b				dec hl 
1c91 22 06 eb			ld (cli_loop_sp), hl 
1c94				; TODO do stack underflow checks 
1c94 e1				pop hl 
1c95				if DEBUG_FORTH_STACK_GUARD 
1c95 cd 2f 56				call check_stacks 
1c98					FORTH_CHK_LOOP_UNDER 
1c98 e5				push hl 
1c99 d5				push de 
1c9a 2a 06 eb			ld hl,(cli_loop_sp) 
1c9d 11 c0 e9			ld de, cli_loop_stack 
1ca0 cd e2 0b			call cmp16 
1ca3 da 49 57			jp c, fault_loop_under 
1ca6 d1				pop de 
1ca7 e1				pop hl 
1ca8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ca8				endif 
1ca8 c9				ret 
1ca9			 
1ca9			macro_forth_dsp_pop: 
1ca9			 
1ca9 e5				push hl 
1caa			 
1caa				; release malloc data 
1caa			 
1caa				if DEBUG_FORTH_STACK_GUARD 
1caa cd 2f 56				call check_stacks 
1cad					FORTH_CHK_DSP_UNDER 
1cad e5				push hl 
1cae d5				push de 
1caf 2a 04 eb			ld hl,(cli_data_sp) 
1cb2 11 be e8			ld de, cli_data_stack 
1cb5 cd e2 0b			call cmp16 
1cb8 da 3d 57			jp c, fault_dsp_under 
1cbb d1				pop de 
1cbc e1				pop hl 
1cbd				endm 
# End of macro FORTH_CHK_DSP_UNDER
1cbd				endif 
1cbd				;ld hl,(cli_data_sp) 
1cbd			if DEBUG_FORTH_DOT 
1cbd				DMARK "DPP" 
1cbd				CALLMONITOR 
1cbd			endif	 
1cbd			 
1cbd			 
1cbd			if FORTH_ENABLE_DSPPOPFREE 
1cbd			 
1cbd				FORTH_DSP 
1cbd cd b7 1b			call macro_forth_dsp 
1cc0				endm 
# End of macro FORTH_DSP
1cc0			 
1cc0 7e				ld a, (hl) 
1cc1 fe 01			cp DS_TYPE_STR 
1cc3 20 07			jr nz, .skippopfree 
1cc5			 
1cc5				FORTH_DSP_VALUEHL 
1cc5 cd f1 1b			call macro_dsp_valuehl 
1cc8				endm 
# End of macro FORTH_DSP_VALUEHL
1cc8 00				nop 
1cc9			if DEBUG_FORTH_DOT 
1cc9				DMARK "DPf" 
1cc9				CALLMONITOR 
1cc9			endif	 
1cc9 cd 55 11			call free 
1ccc			.skippopfree: 
1ccc				 
1ccc			 
1ccc			endif 
1ccc			 
1ccc			if DEBUG_FORTH_DOT_KEY 
1ccc				DMARK "DP2" 
1ccc				CALLMONITOR 
1ccc			endif	 
1ccc			 
1ccc				; move pointer down 
1ccc			 
1ccc 2a 04 eb			ld hl,(cli_data_sp) 
1ccf 2b				dec hl 
1cd0 2b				dec hl 
1cd1			; PARSEV5 
1cd1 2b				dec hl 
1cd2 22 04 eb			ld (cli_data_sp), hl 
1cd5			 
1cd5				if DEBUG_FORTH_STACK_GUARD 
1cd5 cd 2f 56				call check_stacks 
1cd8					FORTH_CHK_DSP_UNDER 
1cd8 e5				push hl 
1cd9 d5				push de 
1cda 2a 04 eb			ld hl,(cli_data_sp) 
1cdd 11 be e8			ld de, cli_data_stack 
1ce0 cd e2 0b			call cmp16 
1ce3 da 3d 57			jp c, fault_dsp_under 
1ce6 d1				pop de 
1ce7 e1				pop hl 
1ce8				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ce8				endif 
1ce8			 
1ce8 e1				pop hl 
1ce9			 
1ce9 c9				ret 
1cea			 
1cea			getwordathl: 
1cea				; hl points to an address 
1cea				; load hl with the word at that address 
1cea			 
1cea d5				push de 
1ceb			 
1ceb 5e				ld e, (hl) 
1cec 23				inc hl 
1ced 56				ld d, (hl) 
1cee eb				ex de, hl 
1cef			 
1cef d1				pop de 
1cf0 c9				ret 
1cf1			 
1cf1			 
1cf1			 
1cf1			 
1cf1			 
1cf1			; eof 
1cf1			 
# End of file forth_stackopsv5.asm
1cf1			endif 
1cf1			 
1cf1			user_word_eol:  
1cf1				; hl contains the pointer to where to create a linked list item from the end 
1cf1				; of the user dict to continue on at the system word dict 
1cf1				 
1cf1				; poke the stub of the word list linked list to repoint to rom words 
1cf1			 
1cf1				; stub format 
1cf1				; db   word id 
1cf1				; dw    link to next word 
1cf1			        ; db char length of token 
1cf1				; db string + 0 term 
1cf1				; db exec code....  
1cf1			 
1cf1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1cf3 77				ld (hl), a		; word id 
1cf4 23				inc hl 
1cf5			 
1cf5 11 bb 1e			ld de, sysdict 
1cf8 73				ld (hl), e		; next word link ie system dict 
1cf9 23				inc hl 
1cfa 72				ld (hl), d		; next word link ie system dict 
1cfb 23				inc hl	 
1cfc			 
1cfc			;	ld (hl), sysdict		; next word link ie system dict 
1cfc			;	inc hl 
1cfc			;	inc hl 
1cfc			 
1cfc			;	inc hl 
1cfc			;	inc hl 
1cfc			 
1cfc 3e 02			ld a, 2			; word length is 0 
1cfe 77				ld (hl), a	 
1cff 23				inc hl 
1d00			 
1d00 3e 7e			ld a, '~'			; word length is 0 
1d02 77				ld (hl), a	 
1d03 23				inc hl 
1d04 3e 00			ld a, 0			; save empty word 
1d06 77				ld (hl), a 
1d07			 
1d07 c9				ret 
1d08			 
1d08				 
1d08			 
1d08			forthexec_cleanup: 
1d08				FORTH_RSP_POP 
1d08 cd c2 19			call macro_forth_rsp_pop 
1d0b				endm 
# End of macro FORTH_RSP_POP
1d0b c9				ret 
1d0c			 
1d0c			forth_call_hl: 
1d0c				; taking hl 
1d0c e5				push hl 
1d0d c9				ret 
1d0e			 
1d0e			; this is called to reset Forth system but keep existing uwords etc 
1d0e			 
1d0e			forth_warmstart: 
1d0e				; setup stack over/under flow checks 
1d0e				if DEBUG_FORTH_STACK_GUARD 
1d0e cd 15 56				call chk_stk_init 
1d11				endif 
1d11			 
1d11				; init stack pointers  - * these stacks go upwards *  
1d11 21 c2 ea			ld hl, cli_ret_stack 
1d14 22 08 eb			ld (cli_ret_sp), hl	 
1d17				; set bottom of stack 
1d17 3e 00			ld a,0 
1d19 77				ld (hl),a 
1d1a 23				inc hl 
1d1b 77				ld (hl),a 
1d1c			 
1d1c 21 be e8			ld hl, cli_data_stack 
1d1f 22 04 eb			ld (cli_data_sp), hl	 
1d22				; set bottom of stack 
1d22 3e 00			ld a,0 
1d24 77				ld (hl),a 
1d25 23				inc hl 
1d26 77				ld (hl),a 
1d27			 
1d27 21 c0 e9			ld hl, cli_loop_stack 
1d2a 22 06 eb			ld (cli_loop_sp), hl	 
1d2d				; set bottom of stack 
1d2d 3e 00			ld a,0 
1d2f 77				ld (hl),a 
1d30 23				inc hl 
1d31 77				ld (hl),a 
1d32			 
1d32				; init extent of current open file 
1d32			 
1d32 3e 00			ld a, 0 
1d34 32 53 eb			ld (store_openext), a 
1d37			 
1d37 c9				ret 
1d38			 
1d38			 
1d38			; Cold Start - this is called to setup the whole Forth system 
1d38			 
1d38			forth_init: 
1d38			 
1d38				; setup stack over/under flow checks 
1d38			 
1d38			;	if DEBUG_FORTH_STACK_GUARD 
1d38			;		call chk_stk_init 
1d38			;	endif 
1d38			 
1d38				; enable auto display updates (slow.....) 
1d38			 
1d38 3e 01			ld a, 1 
1d3a 32 1e eb			ld (cli_autodisplay), a 
1d3d			 
1d3d			 
1d3d			 
1d3d				; show start up screen 
1d3d			 
1d3d cd 97 09			call clear_display 
1d40			 
1d40 3e 00			ld a,0 
1d42 32 40 eb			ld (f_cursor_ptr), a 
1d45			 
1d45				; set start of word list in start of ram - for use when creating user words 
1d45			 
1d45 21 38 59			ld hl, baseram 
1d48 22 54 e6			ld (os_last_new_uword), hl 
1d4b cd f1 1c			call user_word_eol 
1d4e				 
1d4e			;		call display_data_sp 
1d4e			;		call next_page_prompt 
1d4e			 
1d4e			 
1d4e			 
1d4e			 
1d4e c9				ret 
1d4f			 
1d4f .. 00		.bootforth: db " Forth Kernel Init ",0 
1d63			 
1d63			; TODO push to stack 
1d63			 
1d63			;  
1d63			 
1d63			if FORTH_PARSEV2 
1d63			 
1d63			 
1d63				include "forth_parserv2.asm" 
1d63			 
1d63			endif 
1d63			 
1d63			 
1d63			; parse cli version 1 
1d63			 
1d63			if FORTH_PARSEV1 
1d63			 
1d63			 
1d63			 
1d63			      include "forth_parserv1.asm" 
1d63			endif 
1d63				 
1d63			if FORTH_PARSEV3 
1d63			 
1d63			 
1d63			 
1d63			      include "forth_parserv3.asm" 
1d63				include "forth_wordsv3.asm" 
1d63			endif 
1d63			 
1d63			if FORTH_PARSEV4 
1d63			 
1d63			 
1d63			 
1d63			      include "forth_parserv4.asm" 
1d63				include "forth_wordsv4.asm" 
1d63			endif 
1d63			 
1d63			if FORTH_PARSEV5 
1d63			 
1d63			 
1d63			 
1d63			      include "forth_parserv5.asm" 
1d63			 
1d63			 
1d63			; A better parser without using malloc and string copies all over the place.  
1d63			; Exec in situ should be faster 
1d63			 
1d63			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1d63			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1d63			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1d63			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1d63			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1d63			WORD_SYS_END: equ 0   ; Opcode for all user words 
1d63			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1d63			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1d63			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1d63			 
1d63			; Core word preamble macro 
1d63			 
1d63			CWHEAD:   macro nxtword opcode lit len opflags 
1d63				db WORD_SYS_CORE+opcode             
1d63				; internal op code number 
1d63				dw nxtword            
1d63				; link to next dict word block 
1d63				db len + 1 
1d63				; literal length of dict word inc zero term 
1d63				db lit,0              
1d63				; literal dict word 
1d63			        ; TODO db opflags        
1d63				endm 
1d63			 
1d63			 
1d63			NEXTW: macro  
1d63				jp macro_next 
1d63				endm 
1d63			 
1d63			macro_next: 
1d63			if DEBUG_FORTH_PARSE_KEY 
1d63				DMARK "NXT" 
1d63				CALLMONITOR 
1d63			endif	 
1d63			;	inc hl  ; skip token null term  
1d63 ed 4b 22 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1d67 ed 5b 20 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1d6b 2a 58 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d6e			if DEBUG_FORTH_PARSE_KEY 
1d6e				DMARK "}AA" 
1d6e				CALLMONITOR 
1d6e			endif	 
1d6e c3 71 1e			jp execnext 
1d71				;jp exec1 
1d71			       
1d71			 
1d71			 
1d71			; Another go at the parser to compile  
1d71			 
1d71			 
1d71			; TODO rework parser to change all of the string words to byte tokens 
1d71			; TODO do a search for  
1d71			 
1d71			; TODO first run normal parser to zero term sections 
1d71			; TODO for each word do a token look up to get the op code 
1d71			; TODO need some means to flag to the exec that this is a byte code form    
1d71			 
1d71			 
1d71			forthcompile: 
1d71			 
1d71			; 
1d71			; line parse: 
1d71			;       parse raw input buffer 
1d71			;       tokenise the words 
1d71			;       malloc new copy (for looping etc) 
1d71			;       copy to malloc + current pc in line to start of string and add line term 
1d71			;       save on new rsp 
1d71			; 
1d71			 
1d71			; hl to point to the line to tokenise 
1d71			 
1d71			;	push hl 
1d71 22 58 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d74			 
1d74			;	ld a,0		; string term on input 
1d74			;	call strlent 
1d74			 
1d74			;	ld (os_tok_len), hl	 ; save string length 
1d74			 
1d74			;if DEBUG_FORTH_TOK 
1d74			;	ex de,hl		 
1d74			;endif 
1d74			 
1d74			;	pop hl 		; get back string pointer 
1d74			 
1d74			if DEBUG_FORTH_TOK 
1d74						DMARK "TOc" 
1d74				CALLMONITOR 
1d74			endif 
1d74 7e			.cptoken2:    ld a,(hl) 
1d75 23				inc hl 
1d76 fe 7f			cp FORTH_END_BUFFER 
1d78 28 29			jr z, .cptokendone2 
1d7a fe 00			cp 0 
1d7c 28 25			jr z, .cptokendone2 
1d7e fe 22			cp '"' 
1d80 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1d82 fe 20			cp ' ' 
1d84 20 ee			jr nz,  .cptoken2 
1d86			 
1d86			; TODO consume comments held between ( and ) 
1d86			 
1d86				; we have a space so change to zero term for dict match later 
1d86 2b				dec hl 
1d87 3e 00			ld a,0 
1d89 77				ld (hl), a 
1d8a 23				inc hl 
1d8b 18 e7			jr .cptoken2 
1d8d				 
1d8d			 
1d8d			.cptokenstr2: 
1d8d				; skip all white space until either eol (because forgot to term) or end double quote 
1d8d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d8d				;inc hl ; skip current double quote 
1d8d 7e				ld a,(hl) 
1d8e 23				inc hl 
1d8f fe 22			cp '"' 
1d91 28 e1			jr z, .cptoken2 
1d93 fe 7f			cp FORTH_END_BUFFER 
1d95 28 0c			jr z, .cptokendone2 
1d97 fe 00			cp 0 
1d99 28 08			jr z, .cptokendone2 
1d9b fe 20			cp ' ' 
1d9d 28 02			jr z, .cptmp2 
1d9f 18 ec			jr .cptokenstr2 
1da1			 
1da1			.cptmp2:	; we have a space so change to zero term for dict match later 
1da1				;dec hl 
1da1				;ld a,"-"	; TODO remove this when working 
1da1				;ld (hl), a 
1da1				;inc hl 
1da1 18 ea			jr .cptokenstr2 
1da3			 
1da3			.cptokendone2: 
1da3				;inc hl 
1da3 3e 7f			ld a, FORTH_END_BUFFER 
1da5 77				ld (hl),a 
1da6 23				inc hl 
1da7 3e 21			ld a, '!' 
1da9 77				ld (hl),a 
1daa			 
1daa 2a 58 e6			ld hl,(os_tok_ptr) 
1dad			         
1dad			if DEBUG_FORTH_TOK 
1dad						DMARK "Tc1" 
1dad				CALLMONITOR 
1dad			endif 
1dad			 
1dad				; push exec string to top of return stack 
1dad				FORTH_RSP_NEXT 
1dad cd a1 19			call macro_forth_rsp_next 
1db0				endm 
# End of macro FORTH_RSP_NEXT
1db0 c9				ret 
1db1			 
1db1			; Another go at the parser need to simplify the process 
1db1			 
1db1			forthparse: 
1db1			 
1db1			; 
1db1			; line parse: 
1db1			;       parse raw input buffer 
1db1			;       tokenise the words 
1db1			;       malloc new copy (for looping etc) 
1db1			;       copy to malloc + current pc in line to start of string and add line term 
1db1			;       save on new rsp 
1db1			; 
1db1			 
1db1			; hl to point to the line to tokenise 
1db1			 
1db1			;	push hl 
1db1 22 58 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1db4			 
1db4			;	ld a,0		; string term on input 
1db4			;	call strlent 
1db4			 
1db4			;	ld (os_tok_len), hl	 ; save string length 
1db4			 
1db4			;if DEBUG_FORTH_TOK 
1db4			;	ex de,hl		 
1db4			;endif 
1db4			 
1db4			;	pop hl 		; get back string pointer 
1db4			 
1db4			if DEBUG_FORTH_TOK 
1db4						DMARK "TOK" 
1db4				CALLMONITOR 
1db4			endif 
1db4 7e			.ptoken2:    ld a,(hl) 
1db5 23				inc hl 
1db6 fe 7f			cp FORTH_END_BUFFER 
1db8 28 29			jr z, .ptokendone2 
1dba fe 00			cp 0 
1dbc 28 25			jr z, .ptokendone2 
1dbe fe 22			cp '"' 
1dc0 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1dc2 fe 20			cp ' ' 
1dc4 20 ee			jr nz,  .ptoken2 
1dc6			 
1dc6			; TODO consume comments held between ( and ) 
1dc6			 
1dc6				; we have a space so change to zero term for dict match later 
1dc6 2b				dec hl 
1dc7 3e 00			ld a,0 
1dc9 77				ld (hl), a 
1dca 23				inc hl 
1dcb 18 e7			jr .ptoken2 
1dcd				 
1dcd			 
1dcd			.ptokenstr2: 
1dcd				; skip all white space until either eol (because forgot to term) or end double quote 
1dcd			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1dcd				;inc hl ; skip current double quote 
1dcd 7e				ld a,(hl) 
1dce 23				inc hl 
1dcf fe 22			cp '"' 
1dd1 28 e1			jr z, .ptoken2 
1dd3 fe 7f			cp FORTH_END_BUFFER 
1dd5 28 0c			jr z, .ptokendone2 
1dd7 fe 00			cp 0 
1dd9 28 08			jr z, .ptokendone2 
1ddb fe 20			cp ' ' 
1ddd 28 02			jr z, .ptmp2 
1ddf 18 ec			jr .ptokenstr2 
1de1			 
1de1			.ptmp2:	; we have a space so change to zero term for dict match later 
1de1				;dec hl 
1de1				;ld a,"-"	; TODO remove this when working 
1de1				;ld (hl), a 
1de1				;inc hl 
1de1 18 ea			jr .ptokenstr2 
1de3			 
1de3			.ptokendone2: 
1de3				;inc hl 
1de3 3e 7f			ld a, FORTH_END_BUFFER 
1de5 77				ld (hl),a 
1de6 23				inc hl 
1de7 3e 21			ld a, '!' 
1de9 77				ld (hl),a 
1dea			 
1dea 2a 58 e6			ld hl,(os_tok_ptr) 
1ded			         
1ded			if DEBUG_FORTH_TOK 
1ded						DMARK "TK1" 
1ded				CALLMONITOR 
1ded			endif 
1ded			 
1ded				; push exec string to top of return stack 
1ded				FORTH_RSP_NEXT 
1ded cd a1 19			call macro_forth_rsp_next 
1df0				endm 
# End of macro FORTH_RSP_NEXT
1df0 c9				ret 
1df1			 
1df1			; 
1df1			;	; malloc size + buffer pointer + if is loop flag 
1df1			;	ld hl,(os_tok_len) 		 ; get string length 
1df1			; 
1df1			;	ld a,l 
1df1			; 
1df1			;	cp 0			; we dont want to use a null string 
1df1			;	ret z 
1df1			; 
1df1			;;	add 3    ; prefix malloc with buffer for current word ptr 
1df1			; 
1df1			;	add 5     ; TODO when certain not over writing memory remove 
1df1			; 
1df1			;		 
1df1			; 
1df1			;if DEBUG_FORTH_TOK 
1df1			;			DMARK "TKE" 
1df1			;	CALLMONITOR 
1df1			;endif 
1df1			; 
1df1			;	ld l,a 
1df1			;	ld h,0 
1df1			;;	push hl   ; save required space for the copy later 
1df1			;	call malloc 
1df1			;if DEBUG_FORTH_TOK 
1df1			;			DMARK "TKM" 
1df1			;	CALLMONITOR 
1df1			;endif 
1df1			;	if DEBUG_FORTH_MALLOC_GUARD 
1df1			;		push af 
1df1			;		call ishlzero 
1df1			;;		ld a, l 
1df1			;;		add h 
1df1			;;		cp 0 
1df1			;		pop af 
1df1			;		 
1df1			;		call z,malloc_error 
1df1			;	endif 
1df1			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1df1			; 
1df1			; 
1df1			;if DEBUG_FORTH_TOK 
1df1			;			DMARK "TKR" 
1df1			;	CALLMONITOR 
1df1			;endif 
1df1			; 
1df1			;	FORTH_RSP_NEXT 
1df1			; 
1df1			;	;inc hl	 ; go past current buffer pointer 
1df1			;	;inc hl 
1df1			;	;inc hl   ; and past if loop flag 
1df1			;		; TODO Need to set flag  
1df1			; 
1df1			;	 
1df1			;	 
1df1			;	ex de,hl	; malloc is dest 
1df1			;	ld hl, (os_tok_len) 
1df1			;;	pop bc 
1df1			;	ld c, l                
1df1			;	ld b,0 
1df1			;	ld hl, (os_tok_ptr) 
1df1			; 
1df1			;if DEBUG_FORTH_TOK 
1df1			;			DMARK "TKT" 
1df1			;	CALLMONITOR 
1df1			;endif 
1df1			; 
1df1			;	; do str cpy 
1df1			; 
1df1			;	ldir      ; copy byte in hl to de 
1df1			; 
1df1			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1df1			; 
1df1			;if DEBUG_FORTH_TOK 
1df1			; 
1df1			;			DMARK "TKY" 
1df1			;	CALLMONITOR 
1df1			;endif 
1df1			;	;ld a,0 
1df1			;	;ld a,FORTH_END_BUFFER 
1df1			;	ex de, hl 
1df1			;	;dec hl			 ; go back over the space delim at the end of word 
1df1			;	;ld (hl),a 
1df1			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1df1			;	ld a,FORTH_END_BUFFER 
1df1			;	ld (hl),a 
1df1			;	inc hl 
1df1			;	ld a,FORTH_END_BUFFER 
1df1			;	ld (hl),a 
1df1			; 
1df1			;	; init the malloc area data 
1df1			;	; set pc for in current area 
1df1			;	;ld hl, (os_tok_malloc) 
1df1			;	;inc hl 
1df1			;	;inc hl 
1df1			;	;inc hl 
1df1			;	;ex de,hl 
1df1			;	;ld hl, (os_tok_malloc) 
1df1			;	;ld (hl),e 
1df1			;	;inc hl 
1df1			;	;ld (hl),d 
1df1			; 
1df1			; 
1df1			;	ld hl,(os_tok_malloc) 
1df1			;if DEBUG_FORTH_PARSE_KEY 
1df1			;			DMARK "TKU" 
1df1			;	CALLMONITOR 
1df1			;endif 
1df1			; 
1df1			;	ret 
1df1			 
1df1			forthexec: 
1df1			 
1df1			; line exec: 
1df1			; forth parser 
1df1			 
1df1			; 
1df1			;       get current exec line on rsp 
1df1			 
1df1				FORTH_RSP_TOS 
1df1 cd b8 19			call macro_forth_rsp_tos 
1df4				endm 
# End of macro FORTH_RSP_TOS
1df4			 
1df4			;       restore current pc - hl points to malloc of data 
1df4			 
1df4				;ld e, (hl) 
1df4				;inc hl 
1df4				;ld d, (hl) 
1df4				;ex de,hl 
1df4			 
1df4			 
1df4			exec1: 
1df4 22 58 e6			ld (os_tok_ptr), hl 
1df7			 
1df7				; copy our PC to working vars  
1df7 22 22 eb			ld (cli_ptr), hl 
1dfa 22 20 eb			ld (cli_origptr), hl 
1dfd			 
1dfd 7e				ld a,(hl) 
1dfe fe 7f			cp FORTH_END_BUFFER 
1e00 c8				ret z 
1e01			 
1e01				; skip any nulls 
1e01			 
1e01 fe 00			cp 0 
1e03 20 03			jr nz, .execword 
1e05 23				inc hl 
1e06 18 ec			jr exec1 
1e08			 
1e08			 
1e08			.execword: 
1e08			 
1e08			 
1e08			 
1e08			if DEBUG_FORTH_PARSE_KEY 
1e08						DMARK "KYQ" 
1e08				CALLMONITOR 
1e08			endif 
1e08			;       while at start of word: 
1e08			; get start of dict (in user area first) 
1e08			 
1e08 21 38 59		ld hl, baseram 
1e0b			;ld hl, sysdict 
1e0b 22 24 eb		ld (cli_nextword),hl 
1e0e			;           match word at pc 
1e0e			;           exec word 
1e0e			;           or push to dsp 
1e0e			;           forward to next token 
1e0e			;           if line term pop rsp and exit 
1e0e			;        
1e0e			 
1e0e			if DEBUG_FORTH_PARSE_KEY 
1e0e						DMARK "KYq" 
1e0e				CALLMONITOR 
1e0e			endif 
1e0e			 
1e0e			; 
1e0e			; word comp 
1e0e			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1e0e			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1e0e			;    move to start of word  
1e0e			;    compare word to cli_token 
1e0e			 
1e0e			.execpnword:	; HL at start of a word in the dictionary to check 
1e0e			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1e0e			;	ld (cli_ptr), hl 
1e0e			 
1e0e 2a 24 eb			ld hl,(cli_nextword) 
1e11			 
1e11 cd b4 1e			call forth_tok_next 
1e14			; tok next start here 
1e14			;	; TODO skip compiled symbol for now 
1e14			;	inc hl 
1e14			; 
1e14			;	; save pointer to next word 
1e14			; 
1e14			;	; hl now points to the address of the next word pointer  
1e14			;	ld e, (hl) 
1e14			;	inc hl 
1e14			;	ld d, (hl) 
1e14			;	inc l 
1e14			; 
1e14			;	ex de,hl 
1e14			;if DEBUG_FORTH_PARSE_NEXTWORD 
1e14			;	push bc 
1e14			;	ld bc, (cli_nextword) 
1e14			;			DMARK "NXW" 
1e14			;	CALLMONITOR 
1e14			;	pop bc 
1e14			;endif 
1e14			; tok next end here 
1e14 22 24 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1e17 eb				ex de, hl 
1e18			 
1e18			 
1e18				; save the pointer of the current token - 1 to check against 
1e18				 
1e18 22 28 eb			ld (cli_token), hl   
1e1b				; TODO maybe remove below save if no debug 
1e1b				; save token string ptr for any debug later 
1e1b 23				inc hl  
1e1c 22 2a eb			ld (cli_origtoken), hl 
1e1f 2b				dec hl 
1e20				; save pointer to the start of the next dictionay word 
1e20 7e				ld a,(hl)   ; get string length 
1e21 47				ld b,a 
1e22			.execpnwordinc:  
1e22 23				inc hl 
1e23 10 fd			djnz .execpnwordinc 
1e25 22 26 eb			ld (cli_execword), hl      ; save start of this words code 
1e28			 
1e28				; now check the word token against the string being parsed 
1e28			 
1e28 2a 28 eb			ld hl,(cli_token) 
1e2b 23				inc hl     ; skip string length (use zero term instead to end) 
1e2c 22 28 eb			ld (cli_token), hl 
1e2f			 
1e2f			if DEBUG_FORTH_PARSE_KEY 
1e2f						DMARK "KY2" 
1e2f			endif 
1e2f			if DEBUG_FORTH_PARSE_EXEC 
1e2f				; see if disabled 
1e2f			 
1e2f				ld a, (os_view_disable) 
1e2f				cp '*' 
1e2f				jr z, .skip 
1e2f			 
1e2f				push hl 
1e2f				push hl 
1e2f				call clear_display 
1e2f				ld de, .compword 
1e2f				ld a, display_row_1 
1e2f				call str_at_display 
1e2f				pop de 
1e2f				ld a, display_row_2 
1e2f				call str_at_display 
1e2f				ld hl,(cli_ptr) 
1e2f				ld a,(hl) 
1e2f			        ld hl, os_word_scratch 
1e2f				ld (hl),a 
1e2f				ld a,0 
1e2f				inc hl 
1e2f				ld (hl),a 	 
1e2f				ld de, os_word_scratch 
1e2f				ld a, display_row_2+10 
1e2f				call str_at_display 
1e2f				call update_display 
1e2f				ld a, 100 
1e2f				call aDelayInMS 
1e2f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e2f				call delay250ms 
1e2f				endif 
1e2f				pop hl 
1e2f			.skip:  
1e2f			endif	 
1e2f			.execpnchar:    ; compare char between token and string to parse 
1e2f			 
1e2f			if DEBUG_FORTH_PARSE_KEY 
1e2f						DMARK "Ky3" 
1e2f			endif 
1e2f			if DEBUG_FORTH_PARSE_EXEC 
1e2f				; see if disabled 
1e2f			 
1e2f				ld a, (os_view_disable) 
1e2f				cp '*' 
1e2f				jr z, .skip2 
1e2f			 
1e2f			;	call clear_display 
1e2f			ld hl,(cli_token) 
1e2f			ld a,(hl) 
1e2f			ld (os_word_scratch),a 
1e2f				ld hl,(cli_ptr) 
1e2f			ld a,(hl) 
1e2f				ld (os_word_scratch+1),a 
1e2f				ld a,0 
1e2f				ld (os_word_scratch+2),a 
1e2f				ld de,os_word_scratch 
1e2f				ld a,display_row_4 
1e2f				call str_at_display 
1e2f				call update_display 
1e2f			.skip2:  
1e2f			endif 
1e2f 2a 28 eb			ld hl,(cli_token) 
1e32 7e				ld a, (hl)	 ; char in word token 
1e33 23				inc hl 		; move to next char 
1e34 22 28 eb			ld (cli_token), hl ; and save it 
1e37 47				ld b,a 
1e38			 
1e38 2a 22 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1e3b 7e				ld a,(hl) 
1e3c 23				inc hl 
1e3d 22 22 eb			ld (cli_ptr), hl		; move to next char 
1e40 cd 19 10			call toUpper 		; make sure the input string matches case 
1e43			 
1e43			if DEBUG_FORTH_PARSE 
1e43			endif 
1e43			 
1e43				; input stream end of token is a space so get rid of it 
1e43			 
1e43			;	cp ' ' 
1e43			;	jr nz, .pnskipspace 
1e43			; 
1e43			;	ld a, 0		; make same term as word token term 
1e43			; 
1e43			;.pnskipspace: 
1e43			 
1e43			if DEBUG_FORTH_PARSE_KEY 
1e43						DMARK "KY7" 
1e43			endif 
1e43 b8				cp b 
1e44 c2 5a 1e			jp nz, .execpnskipword	 ; no match so move to next word 
1e47				 
1e47			;    if same 
1e47			;       scan for string terms 0 for token and 32 for input 
1e47			 
1e47				 
1e47			if DEBUG_FORTH_PARSE_KEY 
1e47						DMARK "KY8" 
1e47			endif 
1e47			 
1e47 80				add b			 
1e48 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1e4a							; TODO need to make sure last word in zero term string is accounted for 
1e4a 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1e4c			 
1e4c			 
1e4c				; at end of both strings so both are exact match 
1e4c			 
1e4c			;       skip ptr for next word 
1e4c			 
1e4c 2a 22 eb			ld hl,(cli_ptr) 	; at input string term 
1e4f 23				inc hl			 ; at next char 
1e50 22 22 eb			ld (cli_ptr), hl     ; save for next round of the parser 
1e53 22 20 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1e56				 
1e56				 
1e56			if DEBUG_FORTH_PARSE_KEY 
1e56						DMARK "KY3" 
1e56			endif 
1e56			 
1e56			 
1e56			 
1e56			;       exec code block 
1e56			if DEBUG_FORTH_JP 
1e56				call clear_display 
1e56				call update_display 
1e56				call delay1s 
1e56				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e56				ld a,h 
1e56				ld hl, os_word_scratch 
1e56				call hexout 
1e56				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e56				ld a,l 
1e56				ld hl, os_word_scratch+2 
1e56				call hexout 
1e56				ld hl, os_word_scratch+4 
1e56				ld a,0 
1e56				ld (hl),a 
1e56				ld de,os_word_scratch 
1e56				call str_at_display 
1e56					ld a, display_row_2 
1e56					call str_at_display 
1e56				ld de, (cli_origtoken) 
1e56				ld a, display_row_1+10 
1e56					call str_at_display 
1e56			 
1e56				ld a,display_row_1 
1e56				ld de, .foundword 
1e56				ld a, display_row_3 
1e56				call str_at_display 
1e56				call update_display 
1e56				call delay1s 
1e56				call delay1s 
1e56				call delay1s 
1e56			endif 
1e56			 
1e56			if DEBUG_FORTH_PARSE_KEY 
1e56						DMARK "KYj" 
1e56			endif 
1e56				; TODO save the word pointer in this exec 
1e56			 
1e56 2a 26 eb			ld hl,(cli_execword) 
1e59 e9				jp (hl) 
1e5a			 
1e5a			 
1e5a			;    if not same 
1e5a			;	scan for zero term 
1e5a			;	get ptr for next word 
1e5a			;	goto word comp 
1e5a			 
1e5a			.execpnskipword:	; get pointer to next word 
1e5a 2a 24 eb			ld hl,(cli_nextword) 
1e5d			 
1e5d 7e				ld a,(hl) 
1e5e fe 00			cp WORD_SYS_END 
1e60			;	cp 0 
1e60 28 09			jr z, .execendofdict			 ; at end of words 
1e62			 
1e62			if DEBUG_FORTH_PARSE_KEY 
1e62						DMARK "KY4" 
1e62			endif 
1e62			if DEBUG_FORTH_PARSE_EXEC 
1e62			 
1e62				; see if disabled 
1e62			 
1e62				ld a, (os_view_disable) 
1e62				cp '*' 
1e62				jr z, .noskip 
1e62			 
1e62			 
1e62				ld de, .nowordfound 
1e62				ld a, display_row_3 
1e62				call str_at_display 
1e62				call update_display 
1e62				ld a, 100 
1e62				call aDelayInMS 
1e62				 
1e62				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e62					call delay250ms 
1e62				endif 
1e62			.noskip:  
1e62			 
1e62			endif	 
1e62			 
1e62 2a 20 eb			ld hl,(cli_origptr) 
1e65 22 22 eb			ld (cli_ptr),hl 
1e68			 
1e68			if DEBUG_FORTH_PARSE_KEY 
1e68						DMARK "KY5" 
1e68			endif 
1e68 c3 0e 1e			jp .execpnword			; else go to next word 
1e6b			 
1e6b			.execendofdict:  
1e6b			 
1e6b			if DEBUG_FORTH_PARSE_KEY 
1e6b						DMARK "KYe" 
1e6b			endif 
1e6b			if DEBUG_FORTH_PARSE_EXEC 
1e6b				; see if disabled 
1e6b			 
1e6b				ld a, (os_view_disable) 
1e6b				cp '*' 
1e6b				jr z, .ispskip 
1e6b			 
1e6b				call clear_display 
1e6b				call update_display 
1e6b				call delay1s 
1e6b				ld de, (cli_origptr) 
1e6b				ld a, display_row_1 
1e6b				call str_at_display 
1e6b				 
1e6b				ld de, .enddict 
1e6b				ld a, display_row_3 
1e6b				call str_at_display 
1e6b				call update_display 
1e6b				ld a, 100 
1e6b				call aDelayInMS 
1e6b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e6b				call delay1s 
1e6b				call delay1s 
1e6b				call delay1s 
1e6b				endif 
1e6b			.ispskip:  
1e6b				 
1e6b			endif	 
1e6b			 
1e6b			 
1e6b			 
1e6b				; if the word is not a keyword then must be a literal so push it to stack 
1e6b			 
1e6b			; push token to stack to end of word 
1e6b			 
1e6b				STACKFRAME ON $1efe $2f9f 
1e6b				if DEBUG_STACK_IMB 
1e6b					if ON 
1e6b						exx 
1e6b						ld de, $1efe 
1e6b						ld a, d 
1e6b						ld hl, curframe 
1e6b						call hexout 
1e6b						ld a, e 
1e6b						ld hl, curframe+2 
1e6b						call hexout 
1e6b						ld hl, $1efe 
1e6b						push hl 
1e6b						ld hl, $2f9f 
1e6b						push hl 
1e6b						exx 
1e6b					endif 
1e6b				endif 
1e6b			endm 
# End of macro STACKFRAME
1e6b			 
1e6b 2a 58 e6		ld hl,(os_tok_ptr) 
1e6e cd 63 1b		call forth_apush 
1e71			 
1e71				STACKFRAMECHK ON $1efe $2f9f 
1e71				if DEBUG_STACK_IMB 
1e71					if ON 
1e71						exx 
1e71						ld hl, $2f9f 
1e71						pop de   ; $2f9f 
1e71						call cmp16 
1e71						jr nz, .spnosame 
1e71						ld hl, $1efe 
1e71						pop de   ; $1efe 
1e71						call cmp16 
1e71						jr z, .spfrsame 
1e71						.spnosame: call showsperror 
1e71						.spfrsame: nop 
1e71						exx 
1e71					endif 
1e71				endif 
1e71			endm 
# End of macro STACKFRAMECHK
1e71			 
1e71			execnext: 
1e71			 
1e71			if DEBUG_FORTH_PARSE_KEY 
1e71						DMARK "KY>" 
1e71			endif 
1e71			; move past token to next word 
1e71			 
1e71 2a 58 e6		ld hl, (os_tok_ptr) 
1e74 3e 00		ld a, 0 
1e76 01 ff 00		ld bc, 255     ; input buffer size 
1e79 ed b1		cpir 
1e7b			 
1e7b			if DEBUG_FORTH_PARSE_KEY 
1e7b						DMARK "KY!" 
1e7b				CALLMONITOR 
1e7b			endif	 
1e7b			; TODO this might place hl on the null, so will need to forward on??? 
1e7b			;inc hl   ; see if this gets onto the next item 
1e7b			 
1e7b			 
1e7b			; TODO pass a pointer to the buffer to push 
1e7b			; TODO call function to push 
1e7b			 
1e7b			; look for end of input 
1e7b			 
1e7b			;inc hl 
1e7b			;ld a,(hl) 
1e7b			;cp FORTH_END_BUFFER 
1e7b			;ret z 
1e7b			 
1e7b			 
1e7b c3 f4 1d		jp exec1 
1e7e			 
1e7e			 
1e7e			 
1e7e			 
1e7e			 
1e7e			 
1e7e			 
1e7e			 
1e7e			 
1e7e			findnexttok: 
1e7e			 
1e7e				; hl is pointer to move 
1e7e				; de is the token to locate 
1e7e			 
1e7e					if DEBUG_FORTH 
1e7e						DMARK "NTK" 
1e7e						CALLMONITOR 
1e7e					endif 
1e7e d5				push de 
1e7f			 
1e7f			.fnt1:	 
1e7f				; find first char of token to locate 
1e7f			 
1e7f 1a				ld a, (de) 
1e80 4f				ld c,a 
1e81 7e				ld a,(hl) 
1e82 cd 19 10			call toUpper 
1e85					if DEBUG_FORTH 
1e85						DMARK "NT1" 
1e85						CALLMONITOR 
1e85					endif 
1e85 b9				cp c 
1e86			 
1e86 28 03			jr z, .fnt2cmpmorefirst	 
1e88			 
1e88				; first char not found move to next char 
1e88			 
1e88 23				inc hl 
1e89 18 f4			jr .fnt1 
1e8b			 
1e8b			.fnt2cmpmorefirst:	 
1e8b				; first char of token found.  
1e8b			 
1e8b e5				push hl     ; save start of token just in case it is the right one 
1e8c d9				exx 
1e8d e1				pop hl        ; save it to hl' 
1e8e d9				exx 
1e8f			 
1e8f			 
1e8f			.fnt2cmpmore:	 
1e8f				; compare the rest 
1e8f				 
1e8f 23				inc hl 
1e90 13				inc de 
1e91				 
1e91 1a				ld a, (de) 
1e92 4f				ld c,a 
1e93 7e				ld a,(hl) 
1e94 cd 19 10			call toUpper 
1e97			 
1e97					if DEBUG_FORTH 
1e97						DMARK "NT2" 
1e97						CALLMONITOR 
1e97					endif 
1e97				; c has the token to find char 
1e97				; a has the mem to scan char 
1e97			 
1e97 b9				cp c 
1e98 28 04			jr z,.fntmatch1 
1e9a			 
1e9a				; they are not the same 
1e9a			 
1e9a					if DEBUG_FORTH 
1e9a						DMARK "NT3" 
1e9a						CALLMONITOR 
1e9a					endif 
1e9a d1				pop de	; reset de token to look for 
1e9b d5				push de 
1e9c 18 e1			jr .fnt1 
1e9e				 
1e9e			.fntmatch1: 
1e9e			 
1e9e				; is the same char a null which means we might have a full hit? 
1e9e					if DEBUG_FORTH 
1e9e						DMARK "NT4" 
1e9e						CALLMONITOR 
1e9e					endif 
1e9e			 
1e9e fe 00			cp 0 
1ea0 28 0b			jr z, .fntmatchyes 
1ea2			 
1ea2				; are we at the end of the token to find? 
1ea2			 
1ea2					if DEBUG_FORTH 
1ea2						DMARK "NT5" 
1ea2						CALLMONITOR 
1ea2					endif 
1ea2 3e 00			ld a, 0 
1ea4 b9				cp c 
1ea5			 
1ea5 c2 8f 1e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1ea8			 
1ea8					if DEBUG_FORTH 
1ea8						DMARK "NT6" 
1ea8						CALLMONITOR 
1ea8					endif 
1ea8				; token to find is exhusted but no match to stream 
1ea8			 
1ea8				; restore tok pointer and continue on 
1ea8 d1				pop de 
1ea9 d5				push de 
1eaa c3 7f 1e			jp .fnt1 
1ead			 
1ead			 
1ead			.fntmatchyes: 
1ead			 
1ead				; hl now contains the end of the found token 
1ead			 
1ead				; get rid of saved token pointer to find 
1ead			 
1ead d1				pop de 
1eae			 
1eae					if DEBUG_FORTH 
1eae						DMARK "NT9" 
1eae						CALLMONITOR 
1eae					endif 
1eae			 
1eae				; hl will be on the null term so forward on 
1eae			 
1eae				; get back the saved start of the token 
1eae			 
1eae d9				exx 
1eaf e5				push hl     ; save start of token just in case it is the right one 
1eb0 d9				exx 
1eb1 e1				pop hl        ; save it to hl 
1eb2			 
1eb2 c9				ret 
1eb3			 
1eb3			 
1eb3			; LIST needs to find a specific token   
1eb3			; FORGET needs to find a spefici token 
1eb3			 
1eb3			; SAVE needs to find all tokens by flag 
1eb3			; WORDS just needs to scan through all  by flag 
1eb3			; UWORDS needs to scan through all by flag 
1eb3			 
1eb3			 
1eb3			; given hl as pointer to start of dict look up string 
1eb3			; return hl as pointer to start of word block 
1eb3			; or 0 if not found 
1eb3			 
1eb3			forth_find_tok: 
1eb3 c9				ret 
1eb4			 
1eb4			; given hl as pointer to dict structure 
1eb4			; move to the next dict block structure 
1eb4			 
1eb4			forth_tok_next: 
1eb4				; hl now points to the address of the next word pointer  
1eb4				; TODO skip compiled symbol for now 
1eb4			;	push de 
1eb4 23				inc hl 
1eb5 5e				ld e, (hl) 
1eb6 23				inc hl 
1eb7 56				ld d, (hl) 
1eb8 23				inc hl 
1eb9			 
1eb9 eb				ex de,hl 
1eba			if DEBUG_FORTH_PARSE_NEXTWORD 
1eba				push bc 
1eba				ld bc, (cli_nextword) 
1eba						DMARK "NXW" 
1eba				CALLMONITOR 
1eba				pop bc 
1eba			endif 
1eba			;	pop de	 
1eba c9				ret 
1ebb			 
1ebb			 
1ebb			 
1ebb			; eof 
# End of file forth_parserv5.asm
1ebb				include "forth_wordsv4.asm" 
1ebb			 
1ebb			; the core word dictionary v4 
1ebb			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1ebb			 
1ebb			; this is a linked list for each of the system words used 
1ebb			; user defined words will follow the same format but will be in ram 
1ebb			 
1ebb			 
1ebb			; 
1ebb			; 
1ebb			; define linked list: 
1ebb			; 
1ebb			; 1. compiled byte op code 
1ebb			; 2. len of text word 
1ebb			; 3. text word 
1ebb			; 4. ptr to next dictionary word 
1ebb			; 5. asm, calls etc for the word 
1ebb			; 
1ebb			;  if 1 == 0 then last word in dict  
1ebb			;   
1ebb			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1ebb			;  
1ebb			;  
1ebb			; create basic standard set of words 
1ebb			; 
1ebb			;  
1ebb			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1ebb			; 2DUP 2DROP 2SWAP  
1ebb			; @ C@ - get byte  
1ebb			; ! C! - store byte 
1ebb			; 0< true if less than zero 
1ebb			; 0= true if zero 
1ebb			; < >  
1ebb			; = true if same 
1ebb			; variables 
1ebb			 
1ebb			 
1ebb			; Hardware specific words I may need 
1ebb			; 
1ebb			; IN OUT  
1ebb			; calls to key util functions 
1ebb			; calls to hardward abstraction stuff 
1ebb			; easy control of frame buffers and lcd i/o 
1ebb			; keyboard  
1ebb			 
1ebb			 
1ebb			;DICT: macro 
1ebb			; op_code, len, word, next 
1ebb			;    word: 
1ebb			;    db op_code 
1ebb			;    ds word zero term 
1ebb			;    dw next 
1ebb			;    endm 
1ebb			 
1ebb			 
1ebb			 
1ebb			 
1ebb			; op code 1 is a flag for user define words which are to be handled differently 
1ebb			 
1ebb			 
1ebb			; 
1ebb			; 
1ebb			;    TODO on entry to a word this should be the expected environment 
1ebb			;    hl - tos value if number then held, if string this is the ptr 
1ebb			;    de -  
1ebb			 
1ebb			 
1ebb			; opcode ranges 
1ebb			; 0 - end of word dict 
1ebb			; 255 - user define words 
1ebb			 
1ebb			sysdict: 
1ebb			include "forth_opcodes.asm" 
1ebb			; op codes for forth keywords 
1ebb			; free to use code 0  
1ebb				OPCODE_HEAP: equ  1 
1ebb				OPCODE_EXEC: equ 2 
1ebb				OPCODE_DUP: equ 3 
1ebb				OPCODE_SWAP: equ 4 
1ebb				OPCODE_COLN: equ 5 
1ebb				OPCODE_SCOLN: equ 6 
1ebb				OPCODE_DROP: equ 7 
1ebb				OPCODE_DUP2: equ 8 
1ebb				OPCODE_DROP2: equ 9 
1ebb				OPCODE_SWAP2: equ 10 
1ebb				OPCODE_AT: equ 11 
1ebb				OPCODE_CAT: equ 12 
1ebb				OPCODE_BANG: equ 13 
1ebb				OPCODE_CBANG: equ 14 
1ebb				OPCODE_SCALL: equ 15 
1ebb				OPCODE_DEPTH: equ 16 
1ebb				OPCODE_OVER: equ 17 
1ebb				OPCODE_PAUSE: equ 18 
1ebb				OPCODE_PAUSES: equ 19 
1ebb				OPCODE_ROT: equ 20 
1ebb			;free to reuse	OPCODE_WORDS: equ 21 
1ebb			        OPCODE_NOT: equ 21 
1ebb				OPCODE_UWORDS: equ 22 
1ebb				OPCODE_BP: equ 23 
1ebb				OPCODE_MONITOR: equ 24  
1ebb				OPCODE_MALLOC: equ 25 
1ebb				OPCODE_FREE: equ 26 
1ebb				OPCODE_LIST: equ 27 
1ebb				OPCODE_FORGET: equ 28 
1ebb				OPCODE_NOP: equ 29 
1ebb				OPCODE_COMO: equ 30 
1ebb				OPCODE_COMC: equ 31 
1ebb			;free to reuse	OPCODE_ENDCORE: equ 32 
1ebb				OPCODE_AFTERSOUND: equ 33 
1ebb				OPCODE_GP2: equ 34 
1ebb				OPCODE_GP3: equ 35 
1ebb				OPCODE_GP4: equ 36 
1ebb				OPCODE_SIN: equ 37 
1ebb				OPCODE_SOUT: equ 38 
1ebb				OPCODE_SPIO: equ 39 
1ebb				OPCODE_SPICEH: equ 40 
1ebb				OPCODE_SPIOb: equ 41 
1ebb				OPCODE_SPII: equ 42 
1ebb				OPCODE_SESEL: equ 43 
1ebb				OPCODE_CARTDEV: equ 44 
1ebb			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1ebb				OPCODE_FB: equ 46 
1ebb				OPCODE_EMIT: equ 47 
1ebb				OPCODE_DOTH: equ 48 
1ebb				OPCODE_DOTF: equ 49 
1ebb				OPCODE_DOT: equ 50 
1ebb				OPCODE_CLS: equ 51 
1ebb				OPCODE_DRAW: equ 52 
1ebb				OPCODE_DUMP: equ 53 
1ebb				OPCODE_CDUMP: equ 54 
1ebb				OPCODE_DAT: equ 55 
1ebb				OPCODE_HOME: equ 56 
1ebb				OPCODE_SPACE: equ 57 
1ebb				OPCODE_SPACES: equ 58 
1ebb				OPCODE_SCROLL: equ 59 
1ebb				OPCODE_ATQ: equ 60 
1ebb				OPCODE_AUTODSP: equ 61 
1ebb				OPCODE_MENU: equ 62 
1ebb			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1ebb				OPCODE_THEN: equ 64 
1ebb				OPCODE_ELSE: equ 65 
1ebb				OPCODE_DO: equ 66 
1ebb				OPCODE_LOOP: equ 67 
1ebb				OPCODE_I: equ 68 
1ebb				OPCODE_DLOOP: equ 69  
1ebb				OPCODE_REPEAT: equ 70  
1ebb				OPCODE_UNTIL: equ 71 
1ebb				OPCODE_ENDFLOW: equ 72 
1ebb				OPCODE_WAITK: equ 73 
1ebb				OPCODE_ACCEPT: equ 74 
1ebb				OPCODE_EDIT: equ 75 
1ebb			;free to reuse	OPCODE_ENDKEY: equ 76 
1ebb				OPCODE_LZERO: equ 77 
1ebb				OPCODE_TZERO: equ 78 
1ebb				OPCODE_LESS: equ 79 
1ebb				OPCODE_GT: equ 80 
1ebb				OPCODE_EQUAL: equ 81  
1ebb			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1ebb				OPCODE_NEG: equ 83 
1ebb				OPCODE_DIV: equ 84 
1ebb				OPCODE_MUL: equ 85 
1ebb				OPCODE_MIN: equ 86 
1ebb				OPCODE_MAX: equ 87 
1ebb				OPCODE_RND16: equ 88 
1ebb				OPCODE_RND8: equ 89 
1ebb				OPCODE_RND: equ 90 
1ebb			;free to reuse	OPCODE_ENDMATHS: equ 91  
1ebb				OPCODE_BYNAME: equ 92 
1ebb				OPCODE_DIR: equ 93 
1ebb				OPCODE_SAVE: equ 94 
1ebb				OPCODE_LOAD: equ 95 
1ebb				OPCODE_BSAVE: equ 96 
1ebb				OPCODE_BLOAD: equ 97 
1ebb				OPCODE_SEO: equ 98  
1ebb				OPCODE_SEI: equ 99 
1ebb				OPCODE_SFREE: equ 100 
1ebb				OPCODE_SIZE: equ 101 
1ebb				OPCODE_CREATE: equ 102 
1ebb				OPCODE_APPEND: equ 103 
1ebb				OPCODE_SDEL: equ 104 
1ebb				OPCODE_OPEN: equ 105 
1ebb				OPCODE_READ: equ 106 
1ebb				OPCODE_EOF: equ 106 
1ebb				OPCODE_FORMAT: equ 107 
1ebb				OPCODE_LABEL: equ 108 
1ebb				OPCODE_LABELS: equ 109 
1ebb			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1ebb				OPCODE_UPPER: equ 111 
1ebb				OPCODE_LOWER: equ 112 
1ebb				OPCODE_SUBSTR: equ 113 
1ebb				OPCODE_LEFT: equ 114 
1ebb				OPCODE_RIGHT: equ 115 
1ebb				OPCODE_STR2NUM: equ 116 
1ebb				OPCODE_NUM2STR: equ 117 
1ebb				OPCODE_CONCAT: equ 118 
1ebb				OPCODE_FIND: equ 119 
1ebb				OPCODE_LEN: equ 120 
1ebb				OPCODE_CHAR: equ 121 
1ebb			; free to reuse	OPCODE_STRLEN: equ 122 
1ebb			; free to reuse	OPCODE_ENDSTR: equ 123 
1ebb				OPCODE_V0S: equ 124 
1ebb				OPCODE_V0Q: equ 125 
1ebb				OPCODE_V1S: equ 126 
1ebb				OPCODE_V1Q: equ 127 
1ebb				OPCODE_V2S: equ 128 
1ebb				OPCODE_V2Q: equ 129 
1ebb				OPCODE_V3S: equ 130 
1ebb				OPCODE_V3Q: equ 131 
1ebb			;free to reuse	OPCODE_END: equ 132 
1ebb				OPCODE_ZDUP: equ 133 
1ebb			 
1ebb			; eof 
# End of file forth_opcodes.asm
1ebb			 
1ebb			include "forth_words_core.asm" 
1ebb			 
1ebb			; | ## Core Words 
1ebb			 
1ebb			;if MALLOC_4 
1ebb			 
1ebb			.HEAP: 
1ebb				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1ebb 15				db WORD_SYS_CORE+OPCODE_HEAP             
1ebc fa 1e			dw .EXEC            
1ebe 05				db 4 + 1 
1ebf .. 00			db "HEAP",0              
1ec4				endm 
# End of macro CWHEAD
1ec4			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1ec4			; | | u1 - Current number of bytes in the heap 
1ec4			; | | u2 - Remaining bytes left on the heap 
1ec4			; | |  
1ec4			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1ec4			 
1ec4			 
1ec4					if DEBUG_FORTH_WORDS_KEY 
1ec4						DMARK "HEP" 
1ec4 f5				push af  
1ec5 3a d9 1e			ld a, (.dmark)  
1ec8 32 71 ee			ld (debug_mark),a  
1ecb 3a da 1e			ld a, (.dmark+1)  
1ece 32 72 ee			ld (debug_mark+1),a  
1ed1 3a db 1e			ld a, (.dmark+2)  
1ed4 32 73 ee			ld (debug_mark+2),a  
1ed7 18 03			jr .pastdmark  
1ed9 ..			.dmark: db "HEP"  
1edc f1			.pastdmark: pop af  
1edd			endm  
# End of macro DMARK
1edd						CALLMONITOR 
1edd cd 6d 14			call break_point_state  
1ee0				endm  
# End of macro CALLMONITOR
1ee0					endif 
1ee0 2a 42 59				ld hl, (free_list )      
1ee3 11 47 59				ld de, heap_start 
1ee6			 
1ee6 ed 52				sbc hl, de  
1ee8			 
1ee8 cd fa 19				call forth_push_numhl 
1eeb			 
1eeb			 
1eeb ed 5b 42 59			ld de, (free_list )      
1eef 21 3d e3				ld hl, heap_end 
1ef2			 
1ef2 ed 52				sbc hl, de 
1ef4			 
1ef4 cd fa 19				call forth_push_numhl 
1ef7					 
1ef7			 
1ef7					 
1ef7			 
1ef7			 
1ef7			 
1ef7					NEXTW 
1ef7 c3 63 1d			jp macro_next 
1efa				endm 
# End of macro NEXTW
1efa			;endif 
1efa			 
1efa			.EXEC: 
1efa			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1efa			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
1efa			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1efa			;; > > 
1efa			;; > >   
1efa			;	STACKFRAME OFF $5efe $5f9f 
1efa			; 
1efa			;		if DEBUG_FORTH_WORDS_KEY 
1efa			;			DMARK "EXE" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			; 
1efa			;	FORTH_DSP_VALUEHL 
1efa			; 
1efa			;	FORTH_DSP_POP 
1efa			; 
1efa			;		if DEBUG_FORTH_WORDS 
1efa			;			DMARK "EX1" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			;;	ld e,(hl) 
1efa			;;	inc hl 
1efa			;;	ld d,(hl) 
1efa			;;	ex de,hl 
1efa			; 
1efa			;;		if DEBUG_FORTH_WORDS 
1efa			;;			DMARK "EX2" 
1efa			;;			CALLMONITOR 
1efa			;;		endif 
1efa			;	push hl 
1efa			; 
1efa			;	;ld a, 0 
1efa			;	;ld a, FORTH_END_BUFFER 
1efa			;	call strlenz 
1efa			;	inc hl   ; include zero term to copy 
1efa			;	inc hl   ; include term 
1efa			;	inc hl   ; include term 
1efa			;	ld b,0 
1efa			;	ld c,l 
1efa			;	pop hl 
1efa			;	ld de, execscratch 
1efa			;		if DEBUG_FORTH_WORDS 
1efa			;			DMARK "EX3" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			;	ldir 
1efa			; 
1efa			; 
1efa			;	ld hl, execscratch 
1efa			; 
1efa			;		if DEBUG_FORTH_WORDS 
1efa			;			DMARK "EXe" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			; 
1efa			;	call forthparse 
1efa			;	call forthexec 
1efa			;;	call forthexec_cleanup 
1efa			;;	call forthparse 
1efa			;;	call forthexec 
1efa			; 
1efa			;	STACKFRAMECHK OFF $5efe $5f9f 
1efa			; 
1efa			;	; an immediate word so no need to process any more words 
1efa			;	ret 
1efa			;	NEXTW 
1efa			 
1efa			; dead code - old version  
1efa			;	FORTH_RSP_NEXT 
1efa			 
1efa			;  
1efa			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1efa			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1efa			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1efa			;	push hl 
1efa			;	push de 
1efa			;	push bc 
1efa			; 
1efa			; 
1efa			;		if DEBUG_FORTH_WORDS_KEY 
1efa			;			DMARK "EXR" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			; 
1efa			; 
1efa			; 
1efa			;	;v5 FORTH_DSP_VALUE 
1efa			;	FORTH_DSP_VALUEHL 
1efa			; 
1efa			;	; TODO do string type checks 
1efa			; 
1efa			;;v5	inc hl   ; skip type 
1efa			; 
1efa			;	push hl  ; source code  
1efa			;		if DEBUG_FORTH_WORDS 
1efa			;			DMARK "EX1" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			;	ld a, 0 
1efa			;	call strlent 
1efa			; 
1efa			;	inc hl 
1efa			;	inc hl 
1efa			;	inc hl 
1efa			;	inc hl 
1efa			; 
1efa			;	push hl    ; size 
1efa			; 
1efa			;		if DEBUG_FORTH_WORDS 
1efa			;			DMARK "EX2" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			;	call malloc 
1efa			; 
1efa			;	ex de, hl    ; de now contains malloc area 
1efa			;	pop bc   	; get byte count 
1efa			;	pop hl      ; get string to copy 
1efa			; 
1efa			;	push de     ; save malloc for free later 
1efa			; 
1efa			;		if DEBUG_FORTH_WORDS 
1efa			;			DMARK "EX3" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			;	ldir       ; duplicate string 
1efa			; 
1efa			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1efa			;	 
1efa			;	; TODO fix the parse would be better than this...  
1efa			;	ex de, hl 
1efa			;	dec hl 
1efa			;	ld a, 0 
1efa			;	ld (hl), a 
1efa			;	dec hl 
1efa			;	ld a, ' ' 
1efa			;	ld (hl), a 
1efa			;	dec hl 
1efa			;	ld (hl), a 
1efa			; 
1efa			;	dec hl 
1efa			;	ld (hl), a 
1efa			; 
1efa			; 
1efa			;	FORTH_DSP_POP  
1efa			; 
1efa			;	pop hl     
1efa			;	push hl    ; save malloc area 
1efa			; 
1efa			;		if DEBUG_FORTH_WORDS 
1efa			;			DMARK "EX4" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			; 
1efa			;	call forthparse 
1efa			;	call forthexec 
1efa			;	 
1efa			;	pop hl 
1efa			;	if DEBUG_FORTH_WORDS 
1efa			;		DMARK "EX5" 
1efa			;		CALLMONITOR 
1efa			;	endif 
1efa			; 
1efa			;	if FORTH_ENABLE_FREE 
1efa			;	call free 
1efa			;	endif 
1efa			; 
1efa			;	if DEBUG_FORTH_WORDS 
1efa			;		DMARK "EX6" 
1efa			;		CALLMONITOR 
1efa			;	endif 
1efa			; 
1efa			;	pop bc 
1efa			;	pop de 
1efa			;	pop hl 
1efa			;;	FORTH_RSP_POP	  
1efa			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1efa			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1efa			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1efa			; 
1efa			;	if DEBUG_FORTH_WORDS 
1efa			;		DMARK "EX7" 
1efa			;		CALLMONITOR 
1efa			;	endif 
1efa			;	NEXTW 
1efa			 
1efa			;.STKEXEC: 
1efa			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1efa			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
1efa			; 
1efa			; 
1efa			;		if DEBUG_FORTH_WORDS_KEY 
1efa			;			DMARK "STX" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			; 
1efa			;	FORTH_DSP_VALUEHL 
1efa			; 
1efa			;	ld (store_tmp1), hl    ; count 
1efa			; 
1efa			;	FORTH_DSP_POP 
1efa			;.stkexec1: 
1efa			;	ld hl, (store_tmp1)   ; count 
1efa			;	ld a, 0 
1efa			;	cp l 
1efa			;	ret z 
1efa			; 
1efa			;	dec hl 
1efa			;	ld (store_tmp1), hl    ; count 
1efa			;	 
1efa			;	FORTH_DSP_VALUEHL 
1efa			;	push hl 
1efa			;	 
1efa			;		if DEBUG_FORTH_WORDS 
1efa			;			DMARK "EXp" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			;	FORTH_DSP_POP 
1efa			; 
1efa			;	call strlenz 
1efa			;	inc hl   ; include zero term to copy 
1efa			;	inc hl   ; include zero term to copy 
1efa			;	inc hl   ; include zero term to copy 
1efa			;	ld b,0 
1efa			;	ld c,l 
1efa			;	pop hl 
1efa			;	ld de, execscratch 
1efa			;		if DEBUG_FORTH_WORDS 
1efa			;			DMARK "EX3" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			;	ldir 
1efa			; 
1efa			; 
1efa			;	ld hl, execscratch 
1efa			; 
1efa			;		if DEBUG_FORTH_WORDS 
1efa			;			DMARK "EXP" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			; 
1efa			;	call forthparse 
1efa			;	ld hl, execscratch 
1efa			;		if DEBUG_FORTH_WORDS 
1efa			;			DMARK "EXx" 
1efa			;			CALLMONITOR 
1efa			;		endif 
1efa			;	call forthexec 
1efa			; 
1efa			;	jp .stkexec1 
1efa			; 
1efa			;	ret 
1efa			 
1efa			 
1efa			.DUP: 
1efa				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1efa 17				db WORD_SYS_CORE+OPCODE_DUP             
1efb 70 1f			dw .ZDUP            
1efd 04				db 3 + 1 
1efe .. 00			db "DUP",0              
1f02				endm 
# End of macro CWHEAD
1f02			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1f02			 
1f02					if DEBUG_FORTH_WORDS_KEY 
1f02						DMARK "DUP" 
1f02 f5				push af  
1f03 3a 17 1f			ld a, (.dmark)  
1f06 32 71 ee			ld (debug_mark),a  
1f09 3a 18 1f			ld a, (.dmark+1)  
1f0c 32 72 ee			ld (debug_mark+1),a  
1f0f 3a 19 1f			ld a, (.dmark+2)  
1f12 32 73 ee			ld (debug_mark+2),a  
1f15 18 03			jr .pastdmark  
1f17 ..			.dmark: db "DUP"  
1f1a f1			.pastdmark: pop af  
1f1b			endm  
# End of macro DMARK
1f1b						CALLMONITOR 
1f1b cd 6d 14			call break_point_state  
1f1e				endm  
# End of macro CALLMONITOR
1f1e					endif 
1f1e			 
1f1e					FORTH_DSP 
1f1e cd b7 1b			call macro_forth_dsp 
1f21				endm 
# End of macro FORTH_DSP
1f21			 
1f21 7e					ld a, (HL) 
1f22 fe 01				cp DS_TYPE_STR 
1f24 20 25				jr nz, .dupinum 
1f26			 
1f26					; push another string 
1f26			 
1f26					FORTH_DSP_VALUEHL     		 
1f26 cd f1 1b			call macro_dsp_valuehl 
1f29				endm 
# End of macro FORTH_DSP_VALUEHL
1f29			 
1f29				if DEBUG_FORTH_WORDS 
1f29					DMARK "DUs" 
1f29 f5				push af  
1f2a 3a 3e 1f			ld a, (.dmark)  
1f2d 32 71 ee			ld (debug_mark),a  
1f30 3a 3f 1f			ld a, (.dmark+1)  
1f33 32 72 ee			ld (debug_mark+1),a  
1f36 3a 40 1f			ld a, (.dmark+2)  
1f39 32 73 ee			ld (debug_mark+2),a  
1f3c 18 03			jr .pastdmark  
1f3e ..			.dmark: db "DUs"  
1f41 f1			.pastdmark: pop af  
1f42			endm  
# End of macro DMARK
1f42					CALLMONITOR 
1f42 cd 6d 14			call break_point_state  
1f45				endm  
# End of macro CALLMONITOR
1f45				endif 
1f45 cd 68 1a				call forth_push_str 
1f48			 
1f48					NEXTW 
1f48 c3 63 1d			jp macro_next 
1f4b				endm 
# End of macro NEXTW
1f4b			 
1f4b			 
1f4b			.dupinum: 
1f4b					 
1f4b			 
1f4b			 
1f4b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f4b cd f1 1b			call macro_dsp_valuehl 
1f4e				endm 
# End of macro FORTH_DSP_VALUEHL
1f4e			 
1f4e				; TODO add floating point number detection 
1f4e			 
1f4e				if DEBUG_FORTH_WORDS 
1f4e					DMARK "DUi" 
1f4e f5				push af  
1f4f 3a 63 1f			ld a, (.dmark)  
1f52 32 71 ee			ld (debug_mark),a  
1f55 3a 64 1f			ld a, (.dmark+1)  
1f58 32 72 ee			ld (debug_mark+1),a  
1f5b 3a 65 1f			ld a, (.dmark+2)  
1f5e 32 73 ee			ld (debug_mark+2),a  
1f61 18 03			jr .pastdmark  
1f63 ..			.dmark: db "DUi"  
1f66 f1			.pastdmark: pop af  
1f67			endm  
# End of macro DMARK
1f67					CALLMONITOR 
1f67 cd 6d 14			call break_point_state  
1f6a				endm  
# End of macro CALLMONITOR
1f6a				endif 
1f6a			 
1f6a cd fa 19				call forth_push_numhl 
1f6d					NEXTW 
1f6d c3 63 1d			jp macro_next 
1f70				endm 
# End of macro NEXTW
1f70			.ZDUP: 
1f70				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1f70 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1f71 a8 1f			dw .SWAP            
1f73 05				db 4 + 1 
1f74 .. 00			db "?DUP",0              
1f79				endm 
# End of macro CWHEAD
1f79			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1f79			 
1f79					if DEBUG_FORTH_WORDS_KEY 
1f79						DMARK "qDU" 
1f79 f5				push af  
1f7a 3a 8e 1f			ld a, (.dmark)  
1f7d 32 71 ee			ld (debug_mark),a  
1f80 3a 8f 1f			ld a, (.dmark+1)  
1f83 32 72 ee			ld (debug_mark+1),a  
1f86 3a 90 1f			ld a, (.dmark+2)  
1f89 32 73 ee			ld (debug_mark+2),a  
1f8c 18 03			jr .pastdmark  
1f8e ..			.dmark: db "qDU"  
1f91 f1			.pastdmark: pop af  
1f92			endm  
# End of macro DMARK
1f92						CALLMONITOR 
1f92 cd 6d 14			call break_point_state  
1f95				endm  
# End of macro CALLMONITOR
1f95					endif 
1f95					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f95 cd f1 1b			call macro_dsp_valuehl 
1f98				endm 
# End of macro FORTH_DSP_VALUEHL
1f98			 
1f98 e5					push hl 
1f99			 
1f99					; is it a zero? 
1f99			 
1f99 3e 00				ld a, 0 
1f9b 84					add h 
1f9c 85					add l 
1f9d			 
1f9d e1					pop hl 
1f9e			 
1f9e fe 00				cp 0 
1fa0 28 03				jr z, .dup2orig 
1fa2			 
1fa2			 
1fa2 cd fa 19				call forth_push_numhl 
1fa5			 
1fa5			 
1fa5				; TODO add floating point number detection 
1fa5			 
1fa5			.dup2orig: 
1fa5			 
1fa5					NEXTW 
1fa5 c3 63 1d			jp macro_next 
1fa8				endm 
# End of macro NEXTW
1fa8			.SWAP: 
1fa8				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1fa8 18				db WORD_SYS_CORE+OPCODE_SWAP             
1fa9 e7 1f			dw .COLN            
1fab 05				db 4 + 1 
1fac .. 00			db "SWAP",0              
1fb1				endm 
# End of macro CWHEAD
1fb1			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1fb1					if DEBUG_FORTH_WORDS_KEY 
1fb1						DMARK "SWP" 
1fb1 f5				push af  
1fb2 3a c6 1f			ld a, (.dmark)  
1fb5 32 71 ee			ld (debug_mark),a  
1fb8 3a c7 1f			ld a, (.dmark+1)  
1fbb 32 72 ee			ld (debug_mark+1),a  
1fbe 3a c8 1f			ld a, (.dmark+2)  
1fc1 32 73 ee			ld (debug_mark+2),a  
1fc4 18 03			jr .pastdmark  
1fc6 ..			.dmark: db "SWP"  
1fc9 f1			.pastdmark: pop af  
1fca			endm  
# End of macro DMARK
1fca						CALLMONITOR 
1fca cd 6d 14			call break_point_state  
1fcd				endm  
# End of macro CALLMONITOR
1fcd					endif 
1fcd			 
1fcd					FORTH_DSP_VALUEHL 
1fcd cd f1 1b			call macro_dsp_valuehl 
1fd0				endm 
# End of macro FORTH_DSP_VALUEHL
1fd0 e5					push hl     ; w2 
1fd1			 
1fd1					FORTH_DSP_POP 
1fd1 cd a9 1c			call macro_forth_dsp_pop 
1fd4				endm 
# End of macro FORTH_DSP_POP
1fd4			 
1fd4					FORTH_DSP_VALUEHL 
1fd4 cd f1 1b			call macro_dsp_valuehl 
1fd7				endm 
# End of macro FORTH_DSP_VALUEHL
1fd7			 
1fd7					FORTH_DSP_POP 
1fd7 cd a9 1c			call macro_forth_dsp_pop 
1fda				endm 
# End of macro FORTH_DSP_POP
1fda			 
1fda d1					pop de     ; w2	, hl = w1 
1fdb			 
1fdb eb					ex de, hl 
1fdc d5					push de 
1fdd			 
1fdd cd fa 19				call forth_push_numhl 
1fe0			 
1fe0 e1					pop hl 
1fe1			 
1fe1 cd fa 19				call forth_push_numhl 
1fe4					 
1fe4			 
1fe4					NEXTW 
1fe4 c3 63 1d			jp macro_next 
1fe7				endm 
# End of macro NEXTW
1fe7			.COLN: 
1fe7				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1fe7 19				db WORD_SYS_CORE+OPCODE_COLN             
1fe8 73 21			dw .SCOLN            
1fea 02				db 1 + 1 
1feb .. 00			db ":",0              
1fed				endm 
# End of macro CWHEAD
1fed			; | : ( -- )         Create new word | DONE 
1fed			 
1fed					if DEBUG_FORTH_WORDS_KEY 
1fed						DMARK "CLN" 
1fed f5				push af  
1fee 3a 02 20			ld a, (.dmark)  
1ff1 32 71 ee			ld (debug_mark),a  
1ff4 3a 03 20			ld a, (.dmark+1)  
1ff7 32 72 ee			ld (debug_mark+1),a  
1ffa 3a 04 20			ld a, (.dmark+2)  
1ffd 32 73 ee			ld (debug_mark+2),a  
2000 18 03			jr .pastdmark  
2002 ..			.dmark: db "CLN"  
2005 f1			.pastdmark: pop af  
2006			endm  
# End of macro DMARK
2006						CALLMONITOR 
2006 cd 6d 14			call break_point_state  
2009				endm  
# End of macro CALLMONITOR
2009					endif 
2009				STACKFRAME OFF $8efe $989f 
2009				if DEBUG_STACK_IMB 
2009					if OFF 
2009						exx 
2009						ld de, $8efe 
2009						ld a, d 
2009						ld hl, curframe 
2009						call hexout 
2009						ld a, e 
2009						ld hl, curframe+2 
2009						call hexout 
2009						ld hl, $8efe 
2009						push hl 
2009						ld hl, $989f 
2009						push hl 
2009						exx 
2009					endif 
2009				endif 
2009			endm 
# End of macro STACKFRAME
2009				; get parser buffer length  of new word 
2009			 
2009				 
2009			 
2009					; move tok past this to start of name defintition 
2009					; TODO get word to define 
2009					; TODO Move past word token 
2009					; TODO get length of string up to the ';' 
2009			 
2009 2a 58 e6			ld hl, (os_tok_ptr) 
200c 23				inc hl 
200d 23				inc hl 
200e			 
200e 3e 3b			ld a, ';' 
2010 cd 2d 10			call strlent 
2013			 
2013 7d				ld a,l 
2014 32 53 e3			ld (os_new_parse_len), a 
2017			 
2017			 
2017			if DEBUG_FORTH_UWORD 
2017 ed 5b 58 e6		ld de, (os_tok_ptr) 
201b						DMARK ":01" 
201b f5				push af  
201c 3a 30 20			ld a, (.dmark)  
201f 32 71 ee			ld (debug_mark),a  
2022 3a 31 20			ld a, (.dmark+1)  
2025 32 72 ee			ld (debug_mark+1),a  
2028 3a 32 20			ld a, (.dmark+2)  
202b 32 73 ee			ld (debug_mark+2),a  
202e 18 03			jr .pastdmark  
2030 ..			.dmark: db ":01"  
2033 f1			.pastdmark: pop af  
2034			endm  
# End of macro DMARK
2034				CALLMONITOR 
2034 cd 6d 14			call break_point_state  
2037				endm  
# End of macro CALLMONITOR
2037			endif 
2037			 
2037			; 
2037			;  new word memory layout: 
2037			;  
2037			;    : adg 6666 ;  
2037			; 
2037			;    db   1     ; user defined word  
2037 23				inc hl    
2038			;    dw   sysdict 
2038 23				inc hl 
2039 23				inc hl 
203a			;    db <word len>+1 (for null) 
203a 23				inc hl 
203b			;    db .... <word> 
203b			; 
203b			 
203b 23				inc hl    ; some extras for the word preamble before the above 
203c 23				inc hl 
203d 23				inc hl 
203e 23				inc hl 
203f 23				inc hl 
2040 23				inc hl 
2041 23				inc hl  
2042 23				inc hl 
2043 23				inc hl 
2044 23				inc hl 
2045 23				inc hl 
2046 23				inc hl 
2047 23				inc hl 
2048 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2049			;       exec word buffer 
2049			;	<ptr word>   
2049 23				inc hl 
204a 23				inc hl 
204b			;       <word list><null term> 7F final term 
204b			 
204b			 
204b			if DEBUG_FORTH_UWORD 
204b						DMARK ":02" 
204b f5				push af  
204c 3a 60 20			ld a, (.dmark)  
204f 32 71 ee			ld (debug_mark),a  
2052 3a 61 20			ld a, (.dmark+1)  
2055 32 72 ee			ld (debug_mark+1),a  
2058 3a 62 20			ld a, (.dmark+2)  
205b 32 73 ee			ld (debug_mark+2),a  
205e 18 03			jr .pastdmark  
2060 ..			.dmark: db ":02"  
2063 f1			.pastdmark: pop af  
2064			endm  
# End of macro DMARK
2064				CALLMONITOR 
2064 cd 6d 14			call break_point_state  
2067				endm  
# End of macro CALLMONITOR
2067			endif 
2067			 
2067				 
2067					; malloc the size 
2067			 
2067 cd 8b 10				call malloc 
206a 22 55 e3				ld (os_new_malloc), hl     ; save malloc start 
206d			 
206d			;    db   1     ; user defined word  
206d 3e 01				ld a, WORD_SYS_UWORD  
206f 77					ld (hl), a 
2070				 
2070 23				inc hl    
2071			;    dw   sysdict 
2071 11 bb 1e			ld de, sysdict       ; continue on with the scan to the system dict 
2074 73				ld (hl), e 
2075 23				inc hl 
2076 72				ld (hl), d 
2077 23				inc hl 
2078			 
2078			 
2078			;    Setup dict word 
2078			 
2078 23				inc hl 
2079 22 4f e3			ld (os_new_work_ptr), hl     ; save start of dict word  
207c			 
207c				; 1. get length of dict word 
207c			 
207c			 
207c 2a 58 e6			ld hl, (os_tok_ptr) 
207f 23				inc hl 
2080 23				inc hl    ; position to start of dict word 
2081 3e 00			ld a, 0 
2083 cd 2d 10			call strlent 
2086			 
2086			 
2086 23				inc hl    ; to include null??? 
2087			 
2087				; write length of dict word 
2087			 
2087 ed 5b 4f e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
208b 1b				dec de 
208c eb				ex de, hl 
208d 73				ld (hl), e 
208e eb				ex de, hl 
208f			 
208f				 
208f			 
208f				; copy  
208f 4d				ld c, l 
2090 06 00			ld b, 0 
2092 ed 5b 4f e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2096 2a 58 e6			ld hl, (os_tok_ptr) 
2099 23				inc hl 
209a 23				inc hl    ; position to start of dict word 
209b				 
209b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
209b				 
209b				; TODO need to convert word to upper case 
209b			 
209b			ucasetok:	 
209b 7e				ld a,(hl) 
209c cd 19 10			call toUpper 
209f 77				ld (hl),a 
20a0 ed a0			ldi 
20a2 f2 9b 20		 	jp p, ucasetok 
20a5			 
20a5			 
20a5			 
20a5				; de now points to start of where the word body code should be placed 
20a5 ed 53 4f e3		ld (os_new_work_ptr), de 
20a9				; hl now points to the words to throw at forthexec which needs to be copied 
20a9 22 4d e3			ld (os_new_src_ptr), hl 
20ac			 
20ac				; TODO add 'call to forthexec' 
20ac			 
20ac			if DEBUG_FORTH_UWORD 
20ac c5				push bc 
20ad ed 4b 55 e3		ld bc, (os_new_malloc) 
20b1						DMARK ":0x" 
20b1 f5				push af  
20b2 3a c6 20			ld a, (.dmark)  
20b5 32 71 ee			ld (debug_mark),a  
20b8 3a c7 20			ld a, (.dmark+1)  
20bb 32 72 ee			ld (debug_mark+1),a  
20be 3a c8 20			ld a, (.dmark+2)  
20c1 32 73 ee			ld (debug_mark+2),a  
20c4 18 03			jr .pastdmark  
20c6 ..			.dmark: db ":0x"  
20c9 f1			.pastdmark: pop af  
20ca			endm  
# End of macro DMARK
20ca				CALLMONITOR 
20ca cd 6d 14			call break_point_state  
20cd				endm  
# End of macro CALLMONITOR
20cd c1				pop bc 
20ce			endif 
20ce			 
20ce			 
20ce				; create word preamble which should be: 
20ce			 
20ce			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
20ce			 
20ce				;    ld hl, <word code> 
20ce				;    jp user_exec 
20ce			        ;    <word code bytes> 
20ce			 
20ce			 
20ce			;	inc de     ; TODO ??? or are we already past the word's null 
20ce eb				ex de, hl 
20cf			 
20cf 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
20d1			 
20d1 23				inc hl 
20d2 22 49 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
20d5 23				inc hl 
20d6			 
20d6 23				inc hl 
20d7 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
20d9			 
20d9 01 c3 44			ld bc, user_exec 
20dc 23				inc hl 
20dd 71				ld (hl), c     ; poke address of user_exec 
20de 23				inc hl 
20df 70				ld (hl), b     
20e0			 ; 
20e0			;	inc hl 
20e0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
20e0			; 
20e0			; 
20e0			;	ld bc, macro_forth_rsp_next 
20e0			;	inc hl 
20e0			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
20e0			;	inc hl 
20e0			;	ld (hl), b     
20e0			 ; 
20e0			;	inc hl 
20e0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
20e0			; 
20e0			; 
20e0			;	inc hl 
20e0			;	ld bc, forthexec 
20e0			;	ld (hl), c     ; poke address of forthexec 
20e0			;	inc hl 
20e0			;	ld (hl), b      
20e0			; 
20e0			;	inc hl 
20e0			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
20e0			; 
20e0			;	ld bc, user_dict_next 
20e0			;	inc hl 
20e0			;	ld (hl), c     ; poke address of forthexec 
20e0			;	inc hl 
20e0			;	ld (hl), b      
20e0			 
20e0				; hl is now where we need to copy the word byte data to save this 
20e0			 
20e0 23				inc hl 
20e1 22 4b e3			ld (os_new_exec), hl 
20e4				 
20e4				; copy definition 
20e4			 
20e4 eb				ex de, hl 
20e5			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
20e5			;	inc de    ; skip the PC for this parse 
20e5 3a 53 e3			ld a, (os_new_parse_len) 
20e8 4f				ld c, a 
20e9 06 00			ld b, 0 
20eb ed b0			ldir		 ; copy defintion 
20ed			 
20ed			 
20ed				; poke the address of where the new word bytes live for forthexec 
20ed			 
20ed 2a 49 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
20f0			 
20f0 ed 5b 4b e3		ld de, (os_new_exec)      
20f4				 
20f4 73				ld (hl), e 
20f5 23				inc hl 
20f6 72				ld (hl), d 
20f7			 
20f7					; TODO copy last user dict word next link to this word 
20f7					; TODO update last user dict word to point to this word 
20f7			; 
20f7			; hl f923 de 812a ; bc 811a 
20f7			 
20f7			if DEBUG_FORTH_UWORD 
20f7 c5				push bc 
20f8 ed 4b 55 e3		ld bc, (os_new_malloc) 
20fc						DMARK ":0A" 
20fc f5				push af  
20fd 3a 11 21			ld a, (.dmark)  
2100 32 71 ee			ld (debug_mark),a  
2103 3a 12 21			ld a, (.dmark+1)  
2106 32 72 ee			ld (debug_mark+1),a  
2109 3a 13 21			ld a, (.dmark+2)  
210c 32 73 ee			ld (debug_mark+2),a  
210f 18 03			jr .pastdmark  
2111 ..			.dmark: db ":0A"  
2114 f1			.pastdmark: pop af  
2115			endm  
# End of macro DMARK
2115				CALLMONITOR 
2115 cd 6d 14			call break_point_state  
2118				endm  
# End of macro CALLMONITOR
2118 c1				pop bc 
2119			endif 
2119			if DEBUG_FORTH_UWORD 
2119 c5				push bc 
211a ed 4b 55 e3		ld bc, (os_new_malloc) 
211e 03				inc bc 
211f 03				inc bc 
2120 03				inc bc 
2121 03				inc bc 
2122 03				inc bc 
2123 03				inc bc 
2124 03				inc bc 
2125 03				inc bc 
2126			 
2126						DMARK ":0B" 
2126 f5				push af  
2127 3a 3b 21			ld a, (.dmark)  
212a 32 71 ee			ld (debug_mark),a  
212d 3a 3c 21			ld a, (.dmark+1)  
2130 32 72 ee			ld (debug_mark+1),a  
2133 3a 3d 21			ld a, (.dmark+2)  
2136 32 73 ee			ld (debug_mark+2),a  
2139 18 03			jr .pastdmark  
213b ..			.dmark: db ":0B"  
213e f1			.pastdmark: pop af  
213f			endm  
# End of macro DMARK
213f				CALLMONITOR 
213f cd 6d 14			call break_point_state  
2142				endm  
# End of macro CALLMONITOR
2142 c1				pop bc 
2143			endif 
2143			 
2143			; update word dict linked list for new word 
2143			 
2143			 
2143 2a 54 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2146 23			inc hl     ; move to next work linked list ptr 
2147			 
2147 ed 5b 55 e3	ld de, (os_new_malloc)		 ; new next word 
214b 73			ld (hl), e 
214c 23			inc hl 
214d 72			ld (hl), d 
214e			 
214e			if DEBUG_FORTH_UWORD 
214e ed 4b 54 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2152			endif 
2152			 
2152 ed 53 54 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
2156			 
2156			 
2156			if DEBUG_FORTH_UWORD 
2156						DMARK ":0+" 
2156 f5				push af  
2157 3a 6b 21			ld a, (.dmark)  
215a 32 71 ee			ld (debug_mark),a  
215d 3a 6c 21			ld a, (.dmark+1)  
2160 32 72 ee			ld (debug_mark+1),a  
2163 3a 6d 21			ld a, (.dmark+2)  
2166 32 73 ee			ld (debug_mark+2),a  
2169 18 03			jr .pastdmark  
216b ..			.dmark: db ":0+"  
216e f1			.pastdmark: pop af  
216f			endm  
# End of macro DMARK
216f				CALLMONITOR 
216f cd 6d 14			call break_point_state  
2172				endm  
# End of macro CALLMONITOR
2172			endif 
2172			 
2172				STACKFRAMECHK OFF $8efe $989f 
2172				if DEBUG_STACK_IMB 
2172					if OFF 
2172						exx 
2172						ld hl, $989f 
2172						pop de   ; $989f 
2172						call cmp16 
2172						jr nz, .spnosame 
2172						ld hl, $8efe 
2172						pop de   ; $8efe 
2172						call cmp16 
2172						jr z, .spfrsame 
2172						.spnosame: call showsperror 
2172						.spfrsame: nop 
2172						exx 
2172					endif 
2172				endif 
2172			endm 
# End of macro STACKFRAMECHK
2172			 
2172 c9			ret    ; dont process any remaining parser tokens as they form new word 
2173			 
2173			 
2173			 
2173			 
2173			;		NEXT 
2173			.SCOLN: 
2173			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2173 06				db OPCODE_SCOLN 
2174 bf 21			dw .DROP 
2176 02				db 2 
2177 .. 00			db ";",0           
2179			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2179					if DEBUG_FORTH_WORDS_KEY 
2179						DMARK "SCN" 
2179 f5				push af  
217a 3a 8e 21			ld a, (.dmark)  
217d 32 71 ee			ld (debug_mark),a  
2180 3a 8f 21			ld a, (.dmark+1)  
2183 32 72 ee			ld (debug_mark+1),a  
2186 3a 90 21			ld a, (.dmark+2)  
2189 32 73 ee			ld (debug_mark+2),a  
218c 18 03			jr .pastdmark  
218e ..			.dmark: db "SCN"  
2191 f1			.pastdmark: pop af  
2192			endm  
# End of macro DMARK
2192						CALLMONITOR 
2192 cd 6d 14			call break_point_state  
2195				endm  
# End of macro CALLMONITOR
2195					endif 
2195					FORTH_RSP_TOS 
2195 cd b8 19			call macro_forth_rsp_tos 
2198				endm 
# End of macro FORTH_RSP_TOS
2198 e5					push hl 
2199					FORTH_RSP_POP 
2199 cd c2 19			call macro_forth_rsp_pop 
219c				endm 
# End of macro FORTH_RSP_POP
219c e1					pop hl 
219d			;		ex de,hl 
219d 22 58 e6				ld (os_tok_ptr),hl 
21a0			 
21a0			if DEBUG_FORTH_UWORD 
21a0						DMARK "SCL" 
21a0 f5				push af  
21a1 3a b5 21			ld a, (.dmark)  
21a4 32 71 ee			ld (debug_mark),a  
21a7 3a b6 21			ld a, (.dmark+1)  
21aa 32 72 ee			ld (debug_mark+1),a  
21ad 3a b7 21			ld a, (.dmark+2)  
21b0 32 73 ee			ld (debug_mark+2),a  
21b3 18 03			jr .pastdmark  
21b5 ..			.dmark: db "SCL"  
21b8 f1			.pastdmark: pop af  
21b9			endm  
# End of macro DMARK
21b9				CALLMONITOR 
21b9 cd 6d 14			call break_point_state  
21bc				endm  
# End of macro CALLMONITOR
21bc			endif 
21bc					NEXTW 
21bc c3 63 1d			jp macro_next 
21bf				endm 
# End of macro NEXTW
21bf			 
21bf			.DROP: 
21bf				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
21bf 1b				db WORD_SYS_CORE+OPCODE_DROP             
21c0 ea 21			dw .DUP2            
21c2 05				db 4 + 1 
21c3 .. 00			db "DROP",0              
21c8				endm 
# End of macro CWHEAD
21c8			; | DROP ( w -- )   drop the TOS item   | DONE 
21c8					if DEBUG_FORTH_WORDS_KEY 
21c8						DMARK "DRP" 
21c8 f5				push af  
21c9 3a dd 21			ld a, (.dmark)  
21cc 32 71 ee			ld (debug_mark),a  
21cf 3a de 21			ld a, (.dmark+1)  
21d2 32 72 ee			ld (debug_mark+1),a  
21d5 3a df 21			ld a, (.dmark+2)  
21d8 32 73 ee			ld (debug_mark+2),a  
21db 18 03			jr .pastdmark  
21dd ..			.dmark: db "DRP"  
21e0 f1			.pastdmark: pop af  
21e1			endm  
# End of macro DMARK
21e1						CALLMONITOR 
21e1 cd 6d 14			call break_point_state  
21e4				endm  
# End of macro CALLMONITOR
21e4					endif 
21e4					FORTH_DSP_POP 
21e4 cd a9 1c			call macro_forth_dsp_pop 
21e7				endm 
# End of macro FORTH_DSP_POP
21e7					NEXTW 
21e7 c3 63 1d			jp macro_next 
21ea				endm 
# End of macro NEXTW
21ea			.DUP2: 
21ea				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
21ea 1c				db WORD_SYS_CORE+OPCODE_DUP2             
21eb 2f 22			dw .DROP2            
21ed 05				db 4 + 1 
21ee .. 00			db "2DUP",0              
21f3				endm 
# End of macro CWHEAD
21f3			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
21f3					if DEBUG_FORTH_WORDS_KEY 
21f3						DMARK "2DU" 
21f3 f5				push af  
21f4 3a 08 22			ld a, (.dmark)  
21f7 32 71 ee			ld (debug_mark),a  
21fa 3a 09 22			ld a, (.dmark+1)  
21fd 32 72 ee			ld (debug_mark+1),a  
2200 3a 0a 22			ld a, (.dmark+2)  
2203 32 73 ee			ld (debug_mark+2),a  
2206 18 03			jr .pastdmark  
2208 ..			.dmark: db "2DU"  
220b f1			.pastdmark: pop af  
220c			endm  
# End of macro DMARK
220c						CALLMONITOR 
220c cd 6d 14			call break_point_state  
220f				endm  
# End of macro CALLMONITOR
220f					endif 
220f					FORTH_DSP_VALUEHL 
220f cd f1 1b			call macro_dsp_valuehl 
2212				endm 
# End of macro FORTH_DSP_VALUEHL
2212 e5					push hl      ; 2 
2213			 
2213					FORTH_DSP_POP 
2213 cd a9 1c			call macro_forth_dsp_pop 
2216				endm 
# End of macro FORTH_DSP_POP
2216					 
2216					FORTH_DSP_VALUEHL 
2216 cd f1 1b			call macro_dsp_valuehl 
2219				endm 
# End of macro FORTH_DSP_VALUEHL
2219			;		push hl      ; 1 
2219			 
2219					FORTH_DSP_POP 
2219 cd a9 1c			call macro_forth_dsp_pop 
221c				endm 
# End of macro FORTH_DSP_POP
221c			 
221c			;		pop hl       ; 1 
221c d1					pop de       ; 2 
221d			 
221d cd fa 19				call forth_push_numhl 
2220 eb					ex de, hl 
2221 cd fa 19				call forth_push_numhl 
2224			 
2224					 
2224 eb					ex de, hl 
2225			 
2225 cd fa 19				call forth_push_numhl 
2228 eb					ex de, hl 
2229 cd fa 19				call forth_push_numhl 
222c			 
222c			 
222c					NEXTW 
222c c3 63 1d			jp macro_next 
222f				endm 
# End of macro NEXTW
222f			.DROP2: 
222f				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
222f 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2230 5e 22			dw .SWAP2            
2232 06				db 5 + 1 
2233 .. 00			db "2DROP",0              
2239				endm 
# End of macro CWHEAD
2239			; | 2DROP ( w w -- )    Double drop | DONE 
2239					if DEBUG_FORTH_WORDS_KEY 
2239						DMARK "2DR" 
2239 f5				push af  
223a 3a 4e 22			ld a, (.dmark)  
223d 32 71 ee			ld (debug_mark),a  
2240 3a 4f 22			ld a, (.dmark+1)  
2243 32 72 ee			ld (debug_mark+1),a  
2246 3a 50 22			ld a, (.dmark+2)  
2249 32 73 ee			ld (debug_mark+2),a  
224c 18 03			jr .pastdmark  
224e ..			.dmark: db "2DR"  
2251 f1			.pastdmark: pop af  
2252			endm  
# End of macro DMARK
2252						CALLMONITOR 
2252 cd 6d 14			call break_point_state  
2255				endm  
# End of macro CALLMONITOR
2255					endif 
2255					FORTH_DSP_POP 
2255 cd a9 1c			call macro_forth_dsp_pop 
2258				endm 
# End of macro FORTH_DSP_POP
2258					FORTH_DSP_POP 
2258 cd a9 1c			call macro_forth_dsp_pop 
225b				endm 
# End of macro FORTH_DSP_POP
225b					NEXTW 
225b c3 63 1d			jp macro_next 
225e				endm 
# End of macro NEXTW
225e			.SWAP2: 
225e				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
225e 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
225f 87 22			dw .AT            
2261 06				db 5 + 1 
2262 .. 00			db "2SWAP",0              
2268				endm 
# End of macro CWHEAD
2268			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2268					if DEBUG_FORTH_WORDS_KEY 
2268						DMARK "2SW" 
2268 f5				push af  
2269 3a 7d 22			ld a, (.dmark)  
226c 32 71 ee			ld (debug_mark),a  
226f 3a 7e 22			ld a, (.dmark+1)  
2272 32 72 ee			ld (debug_mark+1),a  
2275 3a 7f 22			ld a, (.dmark+2)  
2278 32 73 ee			ld (debug_mark+2),a  
227b 18 03			jr .pastdmark  
227d ..			.dmark: db "2SW"  
2280 f1			.pastdmark: pop af  
2281			endm  
# End of macro DMARK
2281						CALLMONITOR 
2281 cd 6d 14			call break_point_state  
2284				endm  
# End of macro CALLMONITOR
2284					endif 
2284					NEXTW 
2284 c3 63 1d			jp macro_next 
2287				endm 
# End of macro NEXTW
2287			.AT: 
2287				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2287 1f				db WORD_SYS_CORE+OPCODE_AT             
2288 b9 22			dw .CAT            
228a 02				db 1 + 1 
228b .. 00			db "@",0              
228d				endm 
# End of macro CWHEAD
228d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
228d			 
228d					if DEBUG_FORTH_WORDS_KEY 
228d						DMARK "AT." 
228d f5				push af  
228e 3a a2 22			ld a, (.dmark)  
2291 32 71 ee			ld (debug_mark),a  
2294 3a a3 22			ld a, (.dmark+1)  
2297 32 72 ee			ld (debug_mark+1),a  
229a 3a a4 22			ld a, (.dmark+2)  
229d 32 73 ee			ld (debug_mark+2),a  
22a0 18 03			jr .pastdmark  
22a2 ..			.dmark: db "AT."  
22a5 f1			.pastdmark: pop af  
22a6			endm  
# End of macro DMARK
22a6						CALLMONITOR 
22a6 cd 6d 14			call break_point_state  
22a9				endm  
# End of macro CALLMONITOR
22a9					endif 
22a9			.getbyteat:	 
22a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22a9 cd f1 1b			call macro_dsp_valuehl 
22ac				endm 
# End of macro FORTH_DSP_VALUEHL
22ac					 
22ac			;		push hl 
22ac				 
22ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22ac cd a9 1c			call macro_forth_dsp_pop 
22af				endm 
# End of macro FORTH_DSP_POP
22af			 
22af			;		pop hl 
22af			 
22af 7e					ld a, (hl) 
22b0			 
22b0 6f					ld l, a 
22b1 26 00				ld h, 0 
22b3 cd fa 19				call forth_push_numhl 
22b6			 
22b6					NEXTW 
22b6 c3 63 1d			jp macro_next 
22b9				endm 
# End of macro NEXTW
22b9			.CAT: 
22b9				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
22b9 20				db WORD_SYS_CORE+OPCODE_CAT             
22ba e2 22			dw .BANG            
22bc 03				db 2 + 1 
22bd .. 00			db "C@",0              
22c0				endm 
# End of macro CWHEAD
22c0			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
22c0					if DEBUG_FORTH_WORDS_KEY 
22c0						DMARK "CAA" 
22c0 f5				push af  
22c1 3a d5 22			ld a, (.dmark)  
22c4 32 71 ee			ld (debug_mark),a  
22c7 3a d6 22			ld a, (.dmark+1)  
22ca 32 72 ee			ld (debug_mark+1),a  
22cd 3a d7 22			ld a, (.dmark+2)  
22d0 32 73 ee			ld (debug_mark+2),a  
22d3 18 03			jr .pastdmark  
22d5 ..			.dmark: db "CAA"  
22d8 f1			.pastdmark: pop af  
22d9			endm  
# End of macro DMARK
22d9						CALLMONITOR 
22d9 cd 6d 14			call break_point_state  
22dc				endm  
# End of macro CALLMONITOR
22dc					endif 
22dc c3 a9 22				jp .getbyteat 
22df					NEXTW 
22df c3 63 1d			jp macro_next 
22e2				endm 
# End of macro NEXTW
22e2			.BANG: 
22e2				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
22e2 21				db WORD_SYS_CORE+OPCODE_BANG             
22e3 18 23			dw .CBANG            
22e5 02				db 1 + 1 
22e6 .. 00			db "!",0              
22e8				endm 
# End of macro CWHEAD
22e8			; | ! ( x w -- ) Store x at address w      | DONE 
22e8					if DEBUG_FORTH_WORDS_KEY 
22e8						DMARK "BNG" 
22e8 f5				push af  
22e9 3a fd 22			ld a, (.dmark)  
22ec 32 71 ee			ld (debug_mark),a  
22ef 3a fe 22			ld a, (.dmark+1)  
22f2 32 72 ee			ld (debug_mark+1),a  
22f5 3a ff 22			ld a, (.dmark+2)  
22f8 32 73 ee			ld (debug_mark+2),a  
22fb 18 03			jr .pastdmark  
22fd ..			.dmark: db "BNG"  
2300 f1			.pastdmark: pop af  
2301			endm  
# End of macro DMARK
2301						CALLMONITOR 
2301 cd 6d 14			call break_point_state  
2304				endm  
# End of macro CALLMONITOR
2304					endif 
2304			 
2304			.storebyteat:		 
2304					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2304 cd f1 1b			call macro_dsp_valuehl 
2307				endm 
# End of macro FORTH_DSP_VALUEHL
2307					 
2307 e5					push hl 
2308				 
2308					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2308 cd a9 1c			call macro_forth_dsp_pop 
230b				endm 
# End of macro FORTH_DSP_POP
230b			 
230b					; get byte to poke 
230b			 
230b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
230b cd f1 1b			call macro_dsp_valuehl 
230e				endm 
# End of macro FORTH_DSP_VALUEHL
230e e5					push hl 
230f			 
230f			 
230f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
230f cd a9 1c			call macro_forth_dsp_pop 
2312				endm 
# End of macro FORTH_DSP_POP
2312			 
2312			 
2312 d1					pop de 
2313 e1					pop hl 
2314			 
2314 73					ld (hl),e 
2315			 
2315			 
2315					NEXTW 
2315 c3 63 1d			jp macro_next 
2318				endm 
# End of macro NEXTW
2318			.CBANG: 
2318				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2318 22				db WORD_SYS_CORE+OPCODE_CBANG             
2319 41 23			dw .SCALL            
231b 03				db 2 + 1 
231c .. 00			db "C!",0              
231f				endm 
# End of macro CWHEAD
231f			; | C!  ( x w -- ) Store x at address w  | DONE 
231f					if DEBUG_FORTH_WORDS_KEY 
231f						DMARK "CBA" 
231f f5				push af  
2320 3a 34 23			ld a, (.dmark)  
2323 32 71 ee			ld (debug_mark),a  
2326 3a 35 23			ld a, (.dmark+1)  
2329 32 72 ee			ld (debug_mark+1),a  
232c 3a 36 23			ld a, (.dmark+2)  
232f 32 73 ee			ld (debug_mark+2),a  
2332 18 03			jr .pastdmark  
2334 ..			.dmark: db "CBA"  
2337 f1			.pastdmark: pop af  
2338			endm  
# End of macro DMARK
2338						CALLMONITOR 
2338 cd 6d 14			call break_point_state  
233b				endm  
# End of macro CALLMONITOR
233b					endif 
233b c3 04 23				jp .storebyteat 
233e					NEXTW 
233e c3 63 1d			jp macro_next 
2341				endm 
# End of macro NEXTW
2341			.SCALL: 
2341				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2341 23				db WORD_SYS_CORE+OPCODE_SCALL             
2342 75 23			dw .DEPTH            
2344 05				db 4 + 1 
2345 .. 00			db "CALL",0              
234a				endm 
# End of macro CWHEAD
234a			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
234a					if DEBUG_FORTH_WORDS_KEY 
234a						DMARK "CLL" 
234a f5				push af  
234b 3a 5f 23			ld a, (.dmark)  
234e 32 71 ee			ld (debug_mark),a  
2351 3a 60 23			ld a, (.dmark+1)  
2354 32 72 ee			ld (debug_mark+1),a  
2357 3a 61 23			ld a, (.dmark+2)  
235a 32 73 ee			ld (debug_mark+2),a  
235d 18 03			jr .pastdmark  
235f ..			.dmark: db "CLL"  
2362 f1			.pastdmark: pop af  
2363			endm  
# End of macro DMARK
2363						CALLMONITOR 
2363 cd 6d 14			call break_point_state  
2366				endm  
# End of macro CALLMONITOR
2366					endif 
2366			 
2366					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2366 cd f1 1b			call macro_dsp_valuehl 
2369				endm 
# End of macro FORTH_DSP_VALUEHL
2369			 
2369			;		push hl 
2369			 
2369					; destroy value TOS 
2369			 
2369					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2369 cd a9 1c			call macro_forth_dsp_pop 
236c				endm 
# End of macro FORTH_DSP_POP
236c			 
236c						 
236c			;		pop hl 
236c			 
236c					; how to do a call with hl???? save SP? 
236c cd 0c 1d				call forth_call_hl 
236f			 
236f			 
236f					; TODO push value back onto stack for another op etc 
236f			 
236f cd fa 19				call forth_push_numhl 
2372					NEXTW 
2372 c3 63 1d			jp macro_next 
2375				endm 
# End of macro NEXTW
2375			.DEPTH: 
2375				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2375 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2376 b2 23			dw .OVER            
2378 06				db 5 + 1 
2379 .. 00			db "DEPTH",0              
237f				endm 
# End of macro CWHEAD
237f			; | DEPTH ( -- u ) Push count of stack | DONE 
237f					; take current TOS and remove from base value div by two to get count 
237f					if DEBUG_FORTH_WORDS_KEY 
237f						DMARK "DEP" 
237f f5				push af  
2380 3a 94 23			ld a, (.dmark)  
2383 32 71 ee			ld (debug_mark),a  
2386 3a 95 23			ld a, (.dmark+1)  
2389 32 72 ee			ld (debug_mark+1),a  
238c 3a 96 23			ld a, (.dmark+2)  
238f 32 73 ee			ld (debug_mark+2),a  
2392 18 03			jr .pastdmark  
2394 ..			.dmark: db "DEP"  
2397 f1			.pastdmark: pop af  
2398			endm  
# End of macro DMARK
2398						CALLMONITOR 
2398 cd 6d 14			call break_point_state  
239b				endm  
# End of macro CALLMONITOR
239b					endif 
239b			 
239b			 
239b 2a 04 eb			ld hl, (cli_data_sp) 
239e 11 be e8			ld de, cli_data_stack 
23a1 ed 52			sbc hl,de 
23a3				 
23a3				; div by size of stack item 
23a3			 
23a3 5d				ld e,l 
23a4 0e 03			ld c, 3 
23a6 cd 54 0b			call Div8 
23a9			 
23a9 6f				ld l,a 
23aa 26 00			ld h,0 
23ac			 
23ac				;srl h 
23ac				;rr l 
23ac			 
23ac cd fa 19				call forth_push_numhl 
23af					NEXTW 
23af c3 63 1d			jp macro_next 
23b2				endm 
# End of macro NEXTW
23b2			.OVER: 
23b2				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
23b2 42				db WORD_SYS_CORE+46             
23b3 f9 23			dw .PAUSE            
23b5 05				db 4 + 1 
23b6 .. 00			db "OVER",0              
23bb				endm 
# End of macro CWHEAD
23bb			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
23bb					if DEBUG_FORTH_WORDS_KEY 
23bb						DMARK "OVR" 
23bb f5				push af  
23bc 3a d0 23			ld a, (.dmark)  
23bf 32 71 ee			ld (debug_mark),a  
23c2 3a d1 23			ld a, (.dmark+1)  
23c5 32 72 ee			ld (debug_mark+1),a  
23c8 3a d2 23			ld a, (.dmark+2)  
23cb 32 73 ee			ld (debug_mark+2),a  
23ce 18 03			jr .pastdmark  
23d0 ..			.dmark: db "OVR"  
23d3 f1			.pastdmark: pop af  
23d4			endm  
# End of macro DMARK
23d4						CALLMONITOR 
23d4 cd 6d 14			call break_point_state  
23d7				endm  
# End of macro CALLMONITOR
23d7					endif 
23d7			 
23d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23d7 cd f1 1b			call macro_dsp_valuehl 
23da				endm 
# End of macro FORTH_DSP_VALUEHL
23da e5					push hl    ; n2 
23db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23db cd a9 1c			call macro_forth_dsp_pop 
23de				endm 
# End of macro FORTH_DSP_POP
23de			 
23de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23de cd f1 1b			call macro_dsp_valuehl 
23e1				endm 
# End of macro FORTH_DSP_VALUEHL
23e1 e5					push hl    ; n1 
23e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23e2 cd a9 1c			call macro_forth_dsp_pop 
23e5				endm 
# End of macro FORTH_DSP_POP
23e5			 
23e5 d1					pop de     ; n1 
23e6 e1					pop hl     ; n2 
23e7			 
23e7 d5					push de 
23e8 e5					push hl 
23e9 d5					push de 
23ea			 
23ea					; push back  
23ea			 
23ea e1					pop hl 
23eb cd fa 19				call forth_push_numhl 
23ee e1					pop hl 
23ef cd fa 19				call forth_push_numhl 
23f2 e1					pop hl 
23f3 cd fa 19				call forth_push_numhl 
23f6					NEXTW 
23f6 c3 63 1d			jp macro_next 
23f9				endm 
# End of macro NEXTW
23f9			 
23f9			.PAUSE: 
23f9				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
23f9 43				db WORD_SYS_CORE+47             
23fa 2e 24			dw .PAUSES            
23fc 08				db 7 + 1 
23fd .. 00			db "PAUSEMS",0              
2405				endm 
# End of macro CWHEAD
2405			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2405					if DEBUG_FORTH_WORDS_KEY 
2405						DMARK "PMS" 
2405 f5				push af  
2406 3a 1a 24			ld a, (.dmark)  
2409 32 71 ee			ld (debug_mark),a  
240c 3a 1b 24			ld a, (.dmark+1)  
240f 32 72 ee			ld (debug_mark+1),a  
2412 3a 1c 24			ld a, (.dmark+2)  
2415 32 73 ee			ld (debug_mark+2),a  
2418 18 03			jr .pastdmark  
241a ..			.dmark: db "PMS"  
241d f1			.pastdmark: pop af  
241e			endm  
# End of macro DMARK
241e						CALLMONITOR 
241e cd 6d 14			call break_point_state  
2421				endm  
# End of macro CALLMONITOR
2421					endif 
2421					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2421 cd f1 1b			call macro_dsp_valuehl 
2424				endm 
# End of macro FORTH_DSP_VALUEHL
2424			;		push hl    ; n2 
2424					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2424 cd a9 1c			call macro_forth_dsp_pop 
2427				endm 
# End of macro FORTH_DSP_POP
2427			;		pop hl 
2427			 
2427 7d					ld a, l 
2428 cd ee 08				call aDelayInMS 
242b				       NEXTW 
242b c3 63 1d			jp macro_next 
242e				endm 
# End of macro NEXTW
242e			.PAUSES:  
242e				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
242e 44				db WORD_SYS_CORE+48             
242f 9d 24			dw .ROT            
2431 06				db 5 + 1 
2432 .. 00			db "PAUSE",0              
2438				endm 
# End of macro CWHEAD
2438			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2438					if DEBUG_FORTH_WORDS_KEY 
2438						DMARK "PAU" 
2438 f5				push af  
2439 3a 4d 24			ld a, (.dmark)  
243c 32 71 ee			ld (debug_mark),a  
243f 3a 4e 24			ld a, (.dmark+1)  
2442 32 72 ee			ld (debug_mark+1),a  
2445 3a 4f 24			ld a, (.dmark+2)  
2448 32 73 ee			ld (debug_mark+2),a  
244b 18 03			jr .pastdmark  
244d ..			.dmark: db "PAU"  
2450 f1			.pastdmark: pop af  
2451			endm  
# End of macro DMARK
2451						CALLMONITOR 
2451 cd 6d 14			call break_point_state  
2454				endm  
# End of macro CALLMONITOR
2454					endif 
2454					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2454 cd f1 1b			call macro_dsp_valuehl 
2457				endm 
# End of macro FORTH_DSP_VALUEHL
2457			;		push hl    ; n2 
2457					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2457 cd a9 1c			call macro_forth_dsp_pop 
245a				endm 
# End of macro FORTH_DSP_POP
245a			;		pop hl 
245a 45					ld b, l 
245b					if DEBUG_FORTH_WORDS 
245b						DMARK "PAU" 
245b f5				push af  
245c 3a 70 24			ld a, (.dmark)  
245f 32 71 ee			ld (debug_mark),a  
2462 3a 71 24			ld a, (.dmark+1)  
2465 32 72 ee			ld (debug_mark+1),a  
2468 3a 72 24			ld a, (.dmark+2)  
246b 32 73 ee			ld (debug_mark+2),a  
246e 18 03			jr .pastdmark  
2470 ..			.dmark: db "PAU"  
2473 f1			.pastdmark: pop af  
2474			endm  
# End of macro DMARK
2474						CALLMONITOR 
2474 cd 6d 14			call break_point_state  
2477				endm  
# End of macro CALLMONITOR
2477					endif 
2477 c5			.pauses1:	push bc 
2478 cd 09 09				call delay1s 
247b c1					pop bc 
247c					if DEBUG_FORTH_WORDS 
247c						DMARK "PA1" 
247c f5				push af  
247d 3a 91 24			ld a, (.dmark)  
2480 32 71 ee			ld (debug_mark),a  
2483 3a 92 24			ld a, (.dmark+1)  
2486 32 72 ee			ld (debug_mark+1),a  
2489 3a 93 24			ld a, (.dmark+2)  
248c 32 73 ee			ld (debug_mark+2),a  
248f 18 03			jr .pastdmark  
2491 ..			.dmark: db "PA1"  
2494 f1			.pastdmark: pop af  
2495			endm  
# End of macro DMARK
2495						CALLMONITOR 
2495 cd 6d 14			call break_point_state  
2498				endm  
# End of macro CALLMONITOR
2498					endif 
2498 10 dd				djnz .pauses1 
249a			 
249a				       NEXTW 
249a c3 63 1d			jp macro_next 
249d				endm 
# End of macro NEXTW
249d			.ROT: 
249d				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
249d 45				db WORD_SYS_CORE+49             
249e eb 24			dw .UWORDS            
24a0 04				db 3 + 1 
24a1 .. 00			db "ROT",0              
24a5				endm 
# End of macro CWHEAD
24a5			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
24a5					if DEBUG_FORTH_WORDS_KEY 
24a5						DMARK "ROT" 
24a5 f5				push af  
24a6 3a ba 24			ld a, (.dmark)  
24a9 32 71 ee			ld (debug_mark),a  
24ac 3a bb 24			ld a, (.dmark+1)  
24af 32 72 ee			ld (debug_mark+1),a  
24b2 3a bc 24			ld a, (.dmark+2)  
24b5 32 73 ee			ld (debug_mark+2),a  
24b8 18 03			jr .pastdmark  
24ba ..			.dmark: db "ROT"  
24bd f1			.pastdmark: pop af  
24be			endm  
# End of macro DMARK
24be						CALLMONITOR 
24be cd 6d 14			call break_point_state  
24c1				endm  
# End of macro CALLMONITOR
24c1					endif 
24c1			 
24c1					FORTH_DSP_VALUEHL 
24c1 cd f1 1b			call macro_dsp_valuehl 
24c4				endm 
# End of macro FORTH_DSP_VALUEHL
24c4 e5					push hl    ; u3  
24c5			 
24c5					FORTH_DSP_POP 
24c5 cd a9 1c			call macro_forth_dsp_pop 
24c8				endm 
# End of macro FORTH_DSP_POP
24c8			   
24c8					FORTH_DSP_VALUEHL 
24c8 cd f1 1b			call macro_dsp_valuehl 
24cb				endm 
# End of macro FORTH_DSP_VALUEHL
24cb e5					push hl     ; u2 
24cc			 
24cc					FORTH_DSP_POP 
24cc cd a9 1c			call macro_forth_dsp_pop 
24cf				endm 
# End of macro FORTH_DSP_POP
24cf			 
24cf					FORTH_DSP_VALUEHL 
24cf cd f1 1b			call macro_dsp_valuehl 
24d2				endm 
# End of macro FORTH_DSP_VALUEHL
24d2 e5					push hl     ; u1 
24d3			 
24d3					FORTH_DSP_POP 
24d3 cd a9 1c			call macro_forth_dsp_pop 
24d6				endm 
# End of macro FORTH_DSP_POP
24d6			 
24d6 c1					pop bc      ; u1 
24d7 e1					pop hl      ; u2 
24d8 d1					pop de      ; u3 
24d9			 
24d9			 
24d9 c5					push bc 
24da d5					push de 
24db e5					push hl 
24dc			 
24dc			 
24dc e1					pop hl 
24dd cd fa 19				call forth_push_numhl 
24e0			 
24e0 e1					pop hl 
24e1 cd fa 19				call forth_push_numhl 
24e4			 
24e4 e1					pop hl 
24e5 cd fa 19				call forth_push_numhl 
24e8					 
24e8			 
24e8			 
24e8			 
24e8			 
24e8			 
24e8				       NEXTW 
24e8 c3 63 1d			jp macro_next 
24eb				endm 
# End of macro NEXTW
24eb			 
24eb			.UWORDS: 
24eb				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
24eb 50				db WORD_SYS_CORE+60             
24ec ad 25			dw .BP            
24ee 07				db 6 + 1 
24ef .. 00			db "UWORDS",0              
24f6				endm 
# End of macro CWHEAD
24f6			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
24f6			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
24f6			; | | Following the count are the individual words. 
24f6			; | | 
24f6			; | | e.g. UWORDS 
24f6			; | | BOX DIRLIST 2 
24f6			; | |  
24f6			; | | Can be used to save the words to storage via: 
24f6			; | | UWORDS $01 DO $01 APPEND LOOP 
24f6				if DEBUG_FORTH_WORDS_KEY 
24f6					DMARK "UWR" 
24f6 f5				push af  
24f7 3a 0b 25			ld a, (.dmark)  
24fa 32 71 ee			ld (debug_mark),a  
24fd 3a 0c 25			ld a, (.dmark+1)  
2500 32 72 ee			ld (debug_mark+1),a  
2503 3a 0d 25			ld a, (.dmark+2)  
2506 32 73 ee			ld (debug_mark+2),a  
2509 18 03			jr .pastdmark  
250b ..			.dmark: db "UWR"  
250e f1			.pastdmark: pop af  
250f			endm  
# End of macro DMARK
250f					CALLMONITOR 
250f cd 6d 14			call break_point_state  
2512				endm  
# End of macro CALLMONITOR
2512				endif 
2512 21 38 59				ld hl, baseram 
2515					;ld hl, baseusermem 
2515 01 00 00				ld bc, 0    ; start a counter 
2518			 
2518				; skip dict stub 
2518			 
2518 cd b4 1e				call forth_tok_next 
251b			 
251b			 
251b			; while we have words to look for 
251b			 
251b 7e			.douscan:	ld a, (hl)      
251c				if DEBUG_FORTH_WORDS 
251c					DMARK "UWs" 
251c f5				push af  
251d 3a 31 25			ld a, (.dmark)  
2520 32 71 ee			ld (debug_mark),a  
2523 3a 32 25			ld a, (.dmark+1)  
2526 32 72 ee			ld (debug_mark+1),a  
2529 3a 33 25			ld a, (.dmark+2)  
252c 32 73 ee			ld (debug_mark+2),a  
252f 18 03			jr .pastdmark  
2531 ..			.dmark: db "UWs"  
2534 f1			.pastdmark: pop af  
2535			endm  
# End of macro DMARK
2535					CALLMONITOR 
2535 cd 6d 14			call break_point_state  
2538				endm  
# End of macro CALLMONITOR
2538				endif 
2538 fe 00				cp WORD_SYS_END 
253a 28 4d				jr z, .udone 
253c fe 01				cp WORD_SYS_UWORD 
253e 20 44				jr nz, .nuword 
2540			 
2540				if DEBUG_FORTH_WORDS 
2540					DMARK "UWu" 
2540 f5				push af  
2541 3a 55 25			ld a, (.dmark)  
2544 32 71 ee			ld (debug_mark),a  
2547 3a 56 25			ld a, (.dmark+1)  
254a 32 72 ee			ld (debug_mark+1),a  
254d 3a 57 25			ld a, (.dmark+2)  
2550 32 73 ee			ld (debug_mark+2),a  
2553 18 03			jr .pastdmark  
2555 ..			.dmark: db "UWu"  
2558 f1			.pastdmark: pop af  
2559			endm  
# End of macro DMARK
2559					CALLMONITOR 
2559 cd 6d 14			call break_point_state  
255c				endm  
# End of macro CALLMONITOR
255c				endif 
255c					; we have a uword so push its name to the stack 
255c			 
255c e5				   	push hl  ; save so we can move to next dict block 
255d			 
255d					; skip opcode 
255d 23					inc hl  
255e					; skip next ptr 
255e 23					inc hl  
255f 23					inc hl 
2560					; skip len 
2560 23					inc hl 
2561				if DEBUG_FORTH_WORDS 
2561					DMARK "UWt" 
2561 f5				push af  
2562 3a 76 25			ld a, (.dmark)  
2565 32 71 ee			ld (debug_mark),a  
2568 3a 77 25			ld a, (.dmark+1)  
256b 32 72 ee			ld (debug_mark+1),a  
256e 3a 78 25			ld a, (.dmark+2)  
2571 32 73 ee			ld (debug_mark+2),a  
2574 18 03			jr .pastdmark  
2576 ..			.dmark: db "UWt"  
2579 f1			.pastdmark: pop af  
257a			endm  
# End of macro DMARK
257a					CALLMONITOR 
257a cd 6d 14			call break_point_state  
257d				endm  
# End of macro CALLMONITOR
257d				endif 
257d 03					inc bc 
257e			 
257e c5					push bc 
257f cd 68 1a				call forth_push_str 
2582 c1					pop bc 
2583			 
2583 e1					pop hl 	 
2584			 
2584 cd b4 1e		.nuword:	call forth_tok_next 
2587 18 92				jr .douscan  
2589			 
2589			.udone:		 ; push count of uwords found 
2589 c5					push bc 
258a e1					pop hl 
258b			 
258b				if DEBUG_FORTH_WORDS 
258b					DMARK "UWc" 
258b f5				push af  
258c 3a a0 25			ld a, (.dmark)  
258f 32 71 ee			ld (debug_mark),a  
2592 3a a1 25			ld a, (.dmark+1)  
2595 32 72 ee			ld (debug_mark+1),a  
2598 3a a2 25			ld a, (.dmark+2)  
259b 32 73 ee			ld (debug_mark+2),a  
259e 18 03			jr .pastdmark  
25a0 ..			.dmark: db "UWc"  
25a3 f1			.pastdmark: pop af  
25a4			endm  
# End of macro DMARK
25a4					CALLMONITOR 
25a4 cd 6d 14			call break_point_state  
25a7				endm  
# End of macro CALLMONITOR
25a7				endif 
25a7 cd fa 19				call forth_push_numhl 
25aa			 
25aa			 
25aa				       NEXTW 
25aa c3 63 1d			jp macro_next 
25ad				endm 
# End of macro NEXTW
25ad			 
25ad			.BP: 
25ad				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
25ad 54				db WORD_SYS_CORE+64             
25ae e3 25			dw .MONITOR            
25b0 03				db 2 + 1 
25b1 .. 00			db "BP",0              
25b4				endm 
# End of macro CWHEAD
25b4			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
25b4			; | | $00 Will enable the break points within specific code paths 
25b4			; | | $01 Will disable break points 
25b4			; | |  
25b4			; | | By default break points are off. Either the above can be used to enable them 
25b4			; | | or if a key is held down during start up the spashscreen will appear to freeze 
25b4			; | | and on release of the pressed key a message will be disaplayed to notify 
25b4			; | | that break points are enabled. Pressing any key will then continue boot process. 
25b4					; get byte count 
25b4					if DEBUG_FORTH_WORDS_KEY 
25b4						DMARK "BP." 
25b4 f5				push af  
25b5 3a c9 25			ld a, (.dmark)  
25b8 32 71 ee			ld (debug_mark),a  
25bb 3a ca 25			ld a, (.dmark+1)  
25be 32 72 ee			ld (debug_mark+1),a  
25c1 3a cb 25			ld a, (.dmark+2)  
25c4 32 73 ee			ld (debug_mark+2),a  
25c7 18 03			jr .pastdmark  
25c9 ..			.dmark: db "BP."  
25cc f1			.pastdmark: pop af  
25cd			endm  
# End of macro DMARK
25cd						CALLMONITOR 
25cd cd 6d 14			call break_point_state  
25d0				endm  
# End of macro CALLMONITOR
25d0					endif 
25d0			 
25d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25d0 cd f1 1b			call macro_dsp_valuehl 
25d3				endm 
# End of macro FORTH_DSP_VALUEHL
25d3			 
25d3			;		push hl 
25d3			 
25d3					; destroy value TOS 
25d3			 
25d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25d3 cd a9 1c			call macro_forth_dsp_pop 
25d6				endm 
# End of macro FORTH_DSP_POP
25d6			 
25d6			;		pop hl 
25d6			 
25d6 3e 00				ld a,0 
25d8 bd					cp l 
25d9 28 02				jr z, .bpset 
25db 3e 2a				ld a, '*' 
25dd			 
25dd 32 48 e3		.bpset:		ld (os_view_disable), a 
25e0			 
25e0			 
25e0					NEXTW 
25e0 c3 63 1d			jp macro_next 
25e3				endm 
# End of macro NEXTW
25e3			 
25e3			 
25e3			.MONITOR: 
25e3				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
25e3 55				db WORD_SYS_CORE+65             
25e4 16 26			dw .MALLOC            
25e6 08				db 7 + 1 
25e7 .. 00			db "MONITOR",0              
25ef				endm 
# End of macro CWHEAD
25ef			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
25ef			; | | At start the current various registers will be displayed with contents. 
25ef			; | | Top right corner will show the most recent debug marker seen. 
25ef			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
25ef			; | | and the return stack pointer (RSP). 
25ef			; | | Pressing: 
25ef			; | |    1 - Initial screen 
25ef			; | |    2 - Display a data dump of HL 
25ef			; | |    3 - Display a data dump of DE 
25ef			; | |    4 - Display a data dump of BC 
25ef			; | |    5 - Display a data dump of HL 
25ef			; | |    6 - Display a data dump of DSP 
25ef			; | |    7 - Display a data dump of RSP 
25ef			; | |    8 - Display a data dump of what is at DSP 
25ef			; | |    9 - Display a data dump of what is at RSP 
25ef			; | |    0 - Exit monitor and continue running. This will also enable break points 
25ef			; | |    * - Disable break points 
25ef			; | |    # - Enter traditional monitor mode 
25ef			; | | 
25ef			; | | Monitor Mode 
25ef			; | | ------------ 
25ef			; | | A prompt of '>' will be shown for various commands: 
25ef			; | |    D xxxx - Display a data dump starting from hex address xxxx 
25ef			; | |    C - Continue display a data dump from the last set address 
25ef			; | |    M xxxx - Set start of memory edit at address xx 
25ef			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
25ef			; | |    Q - Return to previous 
25ef					if DEBUG_FORTH_WORDS_KEY 
25ef						DMARK "MON" 
25ef f5				push af  
25f0 3a 04 26			ld a, (.dmark)  
25f3 32 71 ee			ld (debug_mark),a  
25f6 3a 05 26			ld a, (.dmark+1)  
25f9 32 72 ee			ld (debug_mark+1),a  
25fc 3a 06 26			ld a, (.dmark+2)  
25ff 32 73 ee			ld (debug_mark+2),a  
2602 18 03			jr .pastdmark  
2604 ..			.dmark: db "MON"  
2607 f1			.pastdmark: pop af  
2608			endm  
# End of macro DMARK
2608						CALLMONITOR 
2608 cd 6d 14			call break_point_state  
260b				endm  
# End of macro CALLMONITOR
260b					endif 
260b 3e 00				ld a, 0 
260d 32 48 e3				ld (os_view_disable), a 
2610			 
2610					CALLMONITOR 
2610 cd 6d 14			call break_point_state  
2613				endm  
# End of macro CALLMONITOR
2613			 
2613			;	call monitor 
2613			 
2613					NEXTW 
2613 c3 63 1d			jp macro_next 
2616				endm 
# End of macro NEXTW
2616			 
2616			 
2616			.MALLOC: 
2616				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2616 56				db WORD_SYS_CORE+66             
2617 3f 26			dw .MALLOC2            
2619 06				db 5 + 1 
261a .. 00			db "ALLOT",0              
2620				endm 
# End of macro CWHEAD
2620			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2620					if DEBUG_FORTH_WORDS_KEY 
2620						DMARK "ALL" 
2620 f5				push af  
2621 3a 35 26			ld a, (.dmark)  
2624 32 71 ee			ld (debug_mark),a  
2627 3a 36 26			ld a, (.dmark+1)  
262a 32 72 ee			ld (debug_mark+1),a  
262d 3a 37 26			ld a, (.dmark+2)  
2630 32 73 ee			ld (debug_mark+2),a  
2633 18 03			jr .pastdmark  
2635 ..			.dmark: db "ALL"  
2638 f1			.pastdmark: pop af  
2639			endm  
# End of macro DMARK
2639						CALLMONITOR 
2639 cd 6d 14			call break_point_state  
263c				endm  
# End of macro CALLMONITOR
263c					endif 
263c c3 66 26				jp .mallocc 
263f			.MALLOC2: 
263f				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
263f 56				db WORD_SYS_CORE+66             
2640 7d 26			dw .FREE            
2642 07				db 6 + 1 
2643 .. 00			db "MALLOC",0              
264a				endm 
# End of macro CWHEAD
264a			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
264a					; get byte count 
264a					if DEBUG_FORTH_WORDS_KEY 
264a						DMARK "MAL" 
264a f5				push af  
264b 3a 5f 26			ld a, (.dmark)  
264e 32 71 ee			ld (debug_mark),a  
2651 3a 60 26			ld a, (.dmark+1)  
2654 32 72 ee			ld (debug_mark+1),a  
2657 3a 61 26			ld a, (.dmark+2)  
265a 32 73 ee			ld (debug_mark+2),a  
265d 18 03			jr .pastdmark  
265f ..			.dmark: db "MAL"  
2662 f1			.pastdmark: pop af  
2663			endm  
# End of macro DMARK
2663						CALLMONITOR 
2663 cd 6d 14			call break_point_state  
2666				endm  
# End of macro CALLMONITOR
2666					endif 
2666			.mallocc: 
2666					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2666 cd f1 1b			call macro_dsp_valuehl 
2669				endm 
# End of macro FORTH_DSP_VALUEHL
2669			 
2669			;		push hl 
2669			 
2669					; destroy value TOS 
2669			 
2669					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2669 cd a9 1c			call macro_forth_dsp_pop 
266c				endm 
# End of macro FORTH_DSP_POP
266c			 
266c			;		pop hl 
266c cd 8b 10				call malloc 
266f				if DEBUG_FORTH_MALLOC_GUARD 
266f f5					push af 
2670 cd ed 0b				call ishlzero 
2673			;		ld a, l 
2673			;		add h 
2673			;		cp 0 
2673 f1					pop af 
2674					 
2674 cc 95 45				call z,malloc_error 
2677				endif 
2677			 
2677 cd fa 19				call forth_push_numhl 
267a					NEXTW 
267a c3 63 1d			jp macro_next 
267d				endm 
# End of macro NEXTW
267d			 
267d			.FREE: 
267d				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
267d 57				db WORD_SYS_CORE+67             
267e ae 26			dw .LIST            
2680 05				db 4 + 1 
2681 .. 00			db "FREE",0              
2686				endm 
# End of macro CWHEAD
2686			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2686					if DEBUG_FORTH_WORDS_KEY 
2686						DMARK "FRE" 
2686 f5				push af  
2687 3a 9b 26			ld a, (.dmark)  
268a 32 71 ee			ld (debug_mark),a  
268d 3a 9c 26			ld a, (.dmark+1)  
2690 32 72 ee			ld (debug_mark+1),a  
2693 3a 9d 26			ld a, (.dmark+2)  
2696 32 73 ee			ld (debug_mark+2),a  
2699 18 03			jr .pastdmark  
269b ..			.dmark: db "FRE"  
269e f1			.pastdmark: pop af  
269f			endm  
# End of macro DMARK
269f						CALLMONITOR 
269f cd 6d 14			call break_point_state  
26a2				endm  
# End of macro CALLMONITOR
26a2					endif 
26a2					; get address 
26a2			 
26a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26a2 cd f1 1b			call macro_dsp_valuehl 
26a5				endm 
# End of macro FORTH_DSP_VALUEHL
26a5			 
26a5			;		push hl 
26a5			 
26a5					; destroy value TOS 
26a5			 
26a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26a5 cd a9 1c			call macro_forth_dsp_pop 
26a8				endm 
# End of macro FORTH_DSP_POP
26a8			 
26a8			;		pop hl 
26a8			if FORTH_ENABLE_MALLOCFREE 
26a8 cd 55 11				call free 
26ab			endif 
26ab					NEXTW 
26ab c3 63 1d			jp macro_next 
26ae				endm 
# End of macro NEXTW
26ae			.LIST: 
26ae				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
26ae 5c				db WORD_SYS_CORE+72             
26af 9c 28			dw .FORGET            
26b1 05				db 4 + 1 
26b2 .. 00			db "LIST",0              
26b7				endm 
# End of macro CWHEAD
26b7			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
26b7			; | | The quoted word must be in upper case. 
26b7				if DEBUG_FORTH_WORDS_KEY 
26b7					DMARK "LST" 
26b7 f5				push af  
26b8 3a cc 26			ld a, (.dmark)  
26bb 32 71 ee			ld (debug_mark),a  
26be 3a cd 26			ld a, (.dmark+1)  
26c1 32 72 ee			ld (debug_mark+1),a  
26c4 3a ce 26			ld a, (.dmark+2)  
26c7 32 73 ee			ld (debug_mark+2),a  
26ca 18 03			jr .pastdmark  
26cc ..			.dmark: db "LST"  
26cf f1			.pastdmark: pop af  
26d0			endm  
# End of macro DMARK
26d0					CALLMONITOR 
26d0 cd 6d 14			call break_point_state  
26d3				endm  
# End of macro CALLMONITOR
26d3				endif 
26d3			 
26d3					FORTH_DSP_VALUEHL 
26d3 cd f1 1b			call macro_dsp_valuehl 
26d6				endm 
# End of macro FORTH_DSP_VALUEHL
26d6			 
26d6 e5					push hl 
26d7					FORTH_DSP_POP 
26d7 cd a9 1c			call macro_forth_dsp_pop 
26da				endm 
# End of macro FORTH_DSP_POP
26da c1					pop bc 
26db			 
26db			; Start format of scratch string 
26db			 
26db 21 57 e3				ld hl, scratch 
26de			 
26de 3e 3a				ld a, ':' 
26e0 77					ld (hl),a 
26e1 23					inc hl 
26e2 3e 20				ld a, ' ' 
26e4 77					ld (hl), a 
26e5			 
26e5					; Get ptr to the word we need to look up 
26e5			 
26e5			;		FORTH_DSP_VALUEHL 
26e5					;v5 FORTH_DSP_VALUE 
26e5				; TODO type check 
26e5			;		inc hl    ; Skip type check  
26e5			;		push hl 
26e5			;		ex de, hl    ; put into DE 
26e5			 
26e5			 
26e5 21 38 59				ld hl, baseram 
26e8					;ld hl, baseusermem 
26e8			 
26e8 e5			push hl   ; sacreifical push 
26e9			 
26e9			.ldouscanm: 
26e9 e1				pop hl 
26ea			.ldouscan: 
26ea				if DEBUG_FORTH_WORDS 
26ea					DMARK "LSs" 
26ea f5				push af  
26eb 3a ff 26			ld a, (.dmark)  
26ee 32 71 ee			ld (debug_mark),a  
26f1 3a 00 27			ld a, (.dmark+1)  
26f4 32 72 ee			ld (debug_mark+1),a  
26f7 3a 01 27			ld a, (.dmark+2)  
26fa 32 73 ee			ld (debug_mark+2),a  
26fd 18 03			jr .pastdmark  
26ff ..			.dmark: db "LSs"  
2702 f1			.pastdmark: pop af  
2703			endm  
# End of macro DMARK
2703					CALLMONITOR 
2703 cd 6d 14			call break_point_state  
2706				endm  
# End of macro CALLMONITOR
2706				endif 
2706				; skip dict stub 
2706 cd b4 1e				call forth_tok_next 
2709			 
2709			 
2709			; while we have words to look for 
2709			 
2709 7e				ld a, (hl)      
270a				if DEBUG_FORTH_WORDS 
270a					DMARK "LSk" 
270a f5				push af  
270b 3a 1f 27			ld a, (.dmark)  
270e 32 71 ee			ld (debug_mark),a  
2711 3a 20 27			ld a, (.dmark+1)  
2714 32 72 ee			ld (debug_mark+1),a  
2717 3a 21 27			ld a, (.dmark+2)  
271a 32 73 ee			ld (debug_mark+2),a  
271d 18 03			jr .pastdmark  
271f ..			.dmark: db "LSk"  
2722 f1			.pastdmark: pop af  
2723			endm  
# End of macro DMARK
2723					CALLMONITOR 
2723 cd 6d 14			call break_point_state  
2726				endm  
# End of macro CALLMONITOR
2726				endif 
2726					;cp WORD_SYS_END 
2726					;jp z, .lunotfound 
2726			 
2726					; if we hit non uwords then gone too far 
2726 fe 01				cp WORD_SYS_UWORD 
2728 c2 58 28				jp nz, .lunotfound 
272b			 
272b				if DEBUG_FORTH_WORDS 
272b					DMARK "LSu" 
272b f5				push af  
272c 3a 40 27			ld a, (.dmark)  
272f 32 71 ee			ld (debug_mark),a  
2732 3a 41 27			ld a, (.dmark+1)  
2735 32 72 ee			ld (debug_mark+1),a  
2738 3a 42 27			ld a, (.dmark+2)  
273b 32 73 ee			ld (debug_mark+2),a  
273e 18 03			jr .pastdmark  
2740 ..			.dmark: db "LSu"  
2743 f1			.pastdmark: pop af  
2744			endm  
# End of macro DMARK
2744					CALLMONITOR 
2744 cd 6d 14			call break_point_state  
2747				endm  
# End of macro CALLMONITOR
2747				endif 
2747			 
2747					; found a uword but is it the one we want... 
2747			 
2747 c5					push bc     ; uword to find is on bc 
2748 d1					pop de 
2749			 
2749 e5					push hl  ; to save the ptr 
274a			 
274a					; skip opcode 
274a 23					inc hl  
274b					; skip next ptr 
274b 23					inc hl  
274c 23					inc hl 
274d					; skip len 
274d 23					inc hl 
274e			 
274e				if DEBUG_FORTH_WORDS 
274e					DMARK "LSc" 
274e f5				push af  
274f 3a 63 27			ld a, (.dmark)  
2752 32 71 ee			ld (debug_mark),a  
2755 3a 64 27			ld a, (.dmark+1)  
2758 32 72 ee			ld (debug_mark+1),a  
275b 3a 65 27			ld a, (.dmark+2)  
275e 32 73 ee			ld (debug_mark+2),a  
2761 18 03			jr .pastdmark  
2763 ..			.dmark: db "LSc"  
2766 f1			.pastdmark: pop af  
2767			endm  
# End of macro DMARK
2767					CALLMONITOR 
2767 cd 6d 14			call break_point_state  
276a				endm  
# End of macro CALLMONITOR
276a				endif 
276a cd 5a 10				call strcmp 
276d c2 e9 26				jp nz, .ldouscanm 
2770				 
2770			 
2770			 
2770					; we have a uword so push its name to the stack 
2770			 
2770			;	   	push hl  ; save so we can move to next dict block 
2770 e1			pop hl 
2771			 
2771				if DEBUG_FORTH_WORDS 
2771					DMARK "LSm" 
2771 f5				push af  
2772 3a 86 27			ld a, (.dmark)  
2775 32 71 ee			ld (debug_mark),a  
2778 3a 87 27			ld a, (.dmark+1)  
277b 32 72 ee			ld (debug_mark+1),a  
277e 3a 88 27			ld a, (.dmark+2)  
2781 32 73 ee			ld (debug_mark+2),a  
2784 18 03			jr .pastdmark  
2786 ..			.dmark: db "LSm"  
2789 f1			.pastdmark: pop af  
278a			endm  
# End of macro DMARK
278a					CALLMONITOR 
278a cd 6d 14			call break_point_state  
278d				endm  
# End of macro CALLMONITOR
278d				endif 
278d			 
278d					; skip opcode 
278d 23					inc hl  
278e					; skip next ptr 
278e 23					inc hl  
278f 23					inc hl 
2790					; skip len 
2790 7e					ld a, (hl)   ; save length to add 
2791				if DEBUG_FORTH_WORDS 
2791					DMARK "LS2" 
2791 f5				push af  
2792 3a a6 27			ld a, (.dmark)  
2795 32 71 ee			ld (debug_mark),a  
2798 3a a7 27			ld a, (.dmark+1)  
279b 32 72 ee			ld (debug_mark+1),a  
279e 3a a8 27			ld a, (.dmark+2)  
27a1 32 73 ee			ld (debug_mark+2),a  
27a4 18 03			jr .pastdmark  
27a6 ..			.dmark: db "LS2"  
27a9 f1			.pastdmark: pop af  
27aa			endm  
# End of macro DMARK
27aa					CALLMONITOR 
27aa cd 6d 14			call break_point_state  
27ad				endm  
# End of macro CALLMONITOR
27ad				endif 
27ad			 
27ad					; save this location 
27ad				 
27ad e5					push hl 
27ae			 
27ae 23					inc hl 
27af 11 59 e3				ld de, scratch+2 
27b2 4f					ld c, a 
27b3 06 00				ld b, 0 
27b5			 
27b5				if DEBUG_FORTH_WORDS 
27b5					DMARK "LSn" 
27b5 f5				push af  
27b6 3a ca 27			ld a, (.dmark)  
27b9 32 71 ee			ld (debug_mark),a  
27bc 3a cb 27			ld a, (.dmark+1)  
27bf 32 72 ee			ld (debug_mark+1),a  
27c2 3a cc 27			ld a, (.dmark+2)  
27c5 32 73 ee			ld (debug_mark+2),a  
27c8 18 03			jr .pastdmark  
27ca ..			.dmark: db "LSn"  
27cd f1			.pastdmark: pop af  
27ce			endm  
# End of macro DMARK
27ce					CALLMONITOR 
27ce cd 6d 14			call break_point_state  
27d1				endm  
# End of macro CALLMONITOR
27d1				endif 
27d1			 
27d1					; copy uword name to scratch 
27d1			 
27d1 ed b0				ldir 
27d3			 
27d3 1b					dec de 
27d4 3e 20				ld a, ' '    ; change null to space 
27d6 12					ld (de), a 
27d7			 
27d7 13					inc de 
27d8			 
27d8 d5					push de 
27d9 c1					pop bc     ; move scratch pointer to end of word name and save it 
27da			 
27da e1					pop hl 
27db 7e					ld a, (hl) 
27dc					;inc hl 
27dc					; skip word string 
27dc cd c4 0b				call addatohl 
27df			 
27df 23					inc hl 
27e0			 
27e0				if DEBUG_FORTH_WORDS 
27e0					DMARK "LS3" 
27e0 f5				push af  
27e1 3a f5 27			ld a, (.dmark)  
27e4 32 71 ee			ld (debug_mark),a  
27e7 3a f6 27			ld a, (.dmark+1)  
27ea 32 72 ee			ld (debug_mark+1),a  
27ed 3a f7 27			ld a, (.dmark+2)  
27f0 32 73 ee			ld (debug_mark+2),a  
27f3 18 03			jr .pastdmark  
27f5 ..			.dmark: db "LS3"  
27f8 f1			.pastdmark: pop af  
27f9			endm  
# End of macro DMARK
27f9					CALLMONITOR 
27f9 cd 6d 14			call break_point_state  
27fc				endm  
# End of macro CALLMONITOR
27fc				endif 
27fc					; should now be at the start of the machine code to setup the eval of the uword 
27fc					; now locate the ptr to the string defintion 
27fc			 
27fc					; skip ld hl, 
27fc					; then load the ptr 
27fc			; TODO use get from hl ptr 
27fc 23					inc hl 
27fd 5e					ld e, (hl) 
27fe 23					inc hl 
27ff 56					ld d, (hl) 
2800 eb					ex de, hl 
2801			 
2801			 
2801				if DEBUG_FORTH_WORDS 
2801					DMARK "LSt" 
2801 f5				push af  
2802 3a 16 28			ld a, (.dmark)  
2805 32 71 ee			ld (debug_mark),a  
2808 3a 17 28			ld a, (.dmark+1)  
280b 32 72 ee			ld (debug_mark+1),a  
280e 3a 18 28			ld a, (.dmark+2)  
2811 32 73 ee			ld (debug_mark+2),a  
2814 18 03			jr .pastdmark  
2816 ..			.dmark: db "LSt"  
2819 f1			.pastdmark: pop af  
281a			endm  
# End of macro DMARK
281a					CALLMONITOR 
281a cd 6d 14			call break_point_state  
281d				endm  
# End of macro CALLMONITOR
281d				endif 
281d			 
281d			; cant push right now due to tokenised strings  
281d			 
281d			; get the destination of where to copy this definition to. 
281d			 
281d c5					push bc 
281e d1					pop de 
281f			 
281f 7e			.listl:         ld a,(hl) 
2820 fe 00				cp 0 
2822 28 09				jr z, .lreplsp     ; replace zero with space 
2824					;cp FORTH_END_BUFFER 
2824 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2826 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2828				 
2828					; just copy this char as is then 
2828			 
2828 12					ld (de), a 
2829			 
2829 23			.listnxt:	inc hl 
282a 13					inc de 
282b 18 f2				jr .listl 
282d			 
282d 3e 20		.lreplsp:	ld a,' ' 
282f 12					ld (de), a 
2830 18 f7				jr .listnxt 
2832			 
2832			; close up uword def 
2832			 
2832			.listdone: 
2832 12					ld (de), a 
2833 13					inc de 
2834 3e 00				ld a, 0 
2836 12					ld (de), a 
2837			 
2837			; now have def so clean up and push to stack 
2837			 
2837 21 57 e3				ld hl, scratch 
283a				if DEBUG_FORTH_WORDS 
283a					DMARK "Ltp" 
283a f5				push af  
283b 3a 4f 28			ld a, (.dmark)  
283e 32 71 ee			ld (debug_mark),a  
2841 3a 50 28			ld a, (.dmark+1)  
2844 32 72 ee			ld (debug_mark+1),a  
2847 3a 51 28			ld a, (.dmark+2)  
284a 32 73 ee			ld (debug_mark+2),a  
284d 18 03			jr .pastdmark  
284f ..			.dmark: db "Ltp"  
2852 f1			.pastdmark: pop af  
2853			endm  
# End of macro DMARK
2853					CALLMONITOR 
2853 cd 6d 14			call break_point_state  
2856				endm  
# End of macro CALLMONITOR
2856				endif 
2856			 
2856 18 1f			jr .listpush 
2858			 
2858			;.lnuword:	pop hl 
2858			;		call forth_tok_next 
2858			;		jp .ldouscan  
2858			 
2858			.lunotfound:		  
2858			 
2858				if DEBUG_FORTH_WORDS 
2858					DMARK "LSn" 
2858 f5				push af  
2859 3a 6d 28			ld a, (.dmark)  
285c 32 71 ee			ld (debug_mark),a  
285f 3a 6e 28			ld a, (.dmark+1)  
2862 32 72 ee			ld (debug_mark+1),a  
2865 3a 6f 28			ld a, (.dmark+2)  
2868 32 73 ee			ld (debug_mark+2),a  
286b 18 03			jr .pastdmark  
286d ..			.dmark: db "LSn"  
2870 f1			.pastdmark: pop af  
2871			endm  
# End of macro DMARK
2871					CALLMONITOR 
2871 cd 6d 14			call break_point_state  
2874				endm  
# End of macro CALLMONITOR
2874				endif 
2874			 
2874					 
2874			;		FORTH_DSP_POP 
2874			;		ld hl, .luno 
2874			 
2874					NEXTW			 
2874 c3 63 1d			jp macro_next 
2877				endm 
# End of macro NEXTW
2877			 
2877			.listpush: 
2877				if DEBUG_FORTH_WORDS 
2877					DMARK "LS>" 
2877 f5				push af  
2878 3a 8c 28			ld a, (.dmark)  
287b 32 71 ee			ld (debug_mark),a  
287e 3a 8d 28			ld a, (.dmark+1)  
2881 32 72 ee			ld (debug_mark+1),a  
2884 3a 8e 28			ld a, (.dmark+2)  
2887 32 73 ee			ld (debug_mark+2),a  
288a 18 03			jr .pastdmark  
288c ..			.dmark: db "LS>"  
288f f1			.pastdmark: pop af  
2890			endm  
# End of macro DMARK
2890					CALLMONITOR 
2890 cd 6d 14			call break_point_state  
2893				endm  
# End of macro CALLMONITOR
2893				endif 
2893 cd 68 1a				call forth_push_str 
2896			 
2896			 
2896			 
2896					NEXTW 
2896 c3 63 1d			jp macro_next 
2899				endm 
# End of macro NEXTW
2899			 
2899			;.luno:    db "Word not found",0 
2899			 
2899			 
2899			 
2899			 
2899			 
2899			;		push hl   ; save pointer to start of uword def string 
2899			; 
2899			;; look for FORTH_EOL_LINE 
2899			;		ld a, FORTH_END_BUFFER 
2899			;		call strlent 
2899			; 
2899			;		inc hl		 ; space for coln def 
2899			;		inc hl 
2899			;		inc hl          ; space for terms 
2899			;		inc hl 
2899			; 
2899			;		ld a, 20   ; TODO get actual length 
2899			;		call addatohl    ; include a random amount of room for the uword name 
2899			; 
2899			;		 
2899			;	if DEBUG_FORTH_WORDS 
2899			;		DMARK "Lt1" 
2899			;		CALLMONITOR 
2899			;	endif 
2899			;		 
2899			; 
2899			;; malloc space for the string because we cant change it 
2899			; 
2899			;		call malloc 
2899			;	if DEBUG_FORTH_MALLOC_GUARD 
2899			;		push af 
2899			;		call ishlzero 
2899			;		pop af 
2899			;		 
2899			;		call z,malloc_error 
2899			;	endif 
2899			; 
2899			;	if DEBUG_FORTH_WORDS 
2899			;		DMARK "Lt2" 
2899			;		CALLMONITOR 
2899			;	endif 
2899			;		pop de 
2899			;		push hl    ; push the malloc to release later 
2899			;		push hl   ;  push back a copy for the later stack push 
2899			;		 
2899			;; copy the string swapping out the zero terms for spaces 
2899			; 
2899			;		; de has our source 
2899			;		; hl has our dest 
2899			; 
2899			;; add the coln def 
2899			; 
2899			;		ld a, ':' 
2899			;		ld (hl), a 
2899			;		inc hl 
2899			;		ld a, ' ' 
2899			;		ld (hl), a 
2899			;		inc hl 
2899			; 
2899			;; add the uname word 
2899			;		push de   ; save our string for now 
2899			;		ex de, hl 
2899			; 
2899			;		FORTH_DSP_VALUE 
2899			;		;v5 FORTH_DSP_VALUE 
2899			; 
2899			;		inc hl   ; skip type but we know by now this is OK 
2899			; 
2899			;.luword:	ld a,(hl) 
2899			;		cp 0 
2899			;		jr z, .luword2 
2899			;		ld (de), a 
2899			;		inc de 
2899			;		inc hl 
2899			;		jr .luword 
2899			; 
2899			;.luword2:	ld a, ' ' 
2899			;		ld (de), a 
2899			;;		inc hl 
2899			;;		inc de 
2899			;;		ld (de), a 
2899			;;		inc hl 
2899			;		inc de 
2899			; 
2899			;		ex de, hl 
2899			;		pop de 
2899			;		 
2899			;		 
2899			; 
2899			;; detoken that string and copy it 
2899			; 
2899			;	if DEBUG_FORTH_WORDS 
2899			;		DMARK "Lt2" 
2899			;		CALLMONITOR 
2899			;	endif 
2899			;.ldetok:	ld a, (de) 
2899			;		cp FORTH_END_BUFFER 
2899			;		jr z, .ldetokend 
2899			;		; swap out any zero term for space 
2899			;		cp 0 
2899			;		jr nz, .ldetoknext 
2899			;		ld a, ' ' 
2899			; 
2899			;	if DEBUG_FORTH_WORDS 
2899			;		DMARK "LtS" 
2899			;		CALLMONITOR 
2899			;	endif 
2899			;.ldetoknext:	ld (hl), a 
2899			;		inc de 
2899			;		inc hl 
2899			;		jr .ldetok 
2899			; 
2899			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2899			;		ld (hl), a  
2899			; 
2899			;; free that temp malloc 
2899			; 
2899			;		pop hl    
2899			; 
2899			;	if DEBUG_FORTH_WORDS 
2899			;		DMARK "Lt4" 
2899			;		CALLMONITOR 
2899			;	endif 
2899			;		call forth_apushstrhl 
2899			; 
2899			;		; get rid of temp malloc area 
2899			; 
2899			;		pop hl 
2899			;		call free 
2899			; 
2899			;		jr .ludone 
2899			; 
2899			;.lnuword:	pop hl 
2899			;		call forth_tok_next 
2899			;		jp .ldouscan  
2899			; 
2899			;.ludone:		 pop hl 
2899			; 
2899					NEXTW 
2899 c3 63 1d			jp macro_next 
289c				endm 
# End of macro NEXTW
289c			 
289c			.FORGET: 
289c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
289c 5d				db WORD_SYS_CORE+73             
289d 15 29			dw .NOP            
289f 07				db 6 + 1 
28a0 .. 00			db "FORGET",0              
28a7				endm 
# End of macro CWHEAD
28a7			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
28a7			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
28a7			; | |  
28a7			; | | e.g. "MORE" forget 
28a7					if DEBUG_FORTH_WORDS_KEY 
28a7						DMARK "FRG" 
28a7 f5				push af  
28a8 3a bc 28			ld a, (.dmark)  
28ab 32 71 ee			ld (debug_mark),a  
28ae 3a bd 28			ld a, (.dmark+1)  
28b1 32 72 ee			ld (debug_mark+1),a  
28b4 3a be 28			ld a, (.dmark+2)  
28b7 32 73 ee			ld (debug_mark+2),a  
28ba 18 03			jr .pastdmark  
28bc ..			.dmark: db "FRG"  
28bf f1			.pastdmark: pop af  
28c0			endm  
# End of macro DMARK
28c0						CALLMONITOR 
28c0 cd 6d 14			call break_point_state  
28c3				endm  
# End of macro CALLMONITOR
28c3					endif 
28c3			 
28c3				; find uword 
28c3			        ; update start of word with "_" 
28c3				; replace uword with deleted flag 
28c3			 
28c3			 
28c3			;	if DEBUG_FORTH_WORDS 
28c3			;		DMARK "FOG" 
28c3			;		CALLMONITOR 
28c3			;	endif 
28c3			 
28c3			 
28c3					; Get ptr to the word we need to look up 
28c3			 
28c3					FORTH_DSP_VALUEHL 
28c3 cd f1 1b			call macro_dsp_valuehl 
28c6				endm 
# End of macro FORTH_DSP_VALUEHL
28c6					;v5 FORTH_DSP_VALUE 
28c6				; TODO type check 
28c6			;		inc hl    ; Skip type check  
28c6 e5					push hl 
28c7 c1					pop bc 
28c8			;		ex de, hl    ; put into DE 
28c8			 
28c8			 
28c8 21 38 59				ld hl, baseram 
28cb					;ld hl, baseusermem 
28cb			 
28cb				; skip dict stub 
28cb			;	call forth_tok_next 
28cb e5			push hl   ; sacreifical push 
28cc			 
28cc			.fldouscanm: 
28cc e1				pop hl 
28cd			.fldouscan: 
28cd			;	if DEBUG_FORTH_WORDS 
28cd			;		DMARK "LSs" 
28cd			;		CALLMONITOR 
28cd			;	endif 
28cd				; skip dict stub 
28cd cd b4 1e				call forth_tok_next 
28d0			 
28d0			 
28d0			; while we have words to look for 
28d0			 
28d0 7e				ld a, (hl)      
28d1			;	if DEBUG_FORTH_WORDS 
28d1			;		DMARK "LSk" 
28d1			;		CALLMONITOR 
28d1			;	endif 
28d1 fe 00				cp WORD_SYS_END 
28d3 ca 0f 29				jp z, .flunotfound 
28d6 fe 01				cp WORD_SYS_UWORD 
28d8 c2 cd 28				jp nz, .fldouscan 
28db			 
28db			;	if DEBUG_FORTH_WORDS 
28db			;		DMARK "LSu" 
28db			;		CALLMONITOR 
28db			;	endif 
28db			 
28db					; found a uword but is it the one we want... 
28db			 
28db c5					push bc     ; uword to find is on bc 
28dc d1					pop de 
28dd			 
28dd e5					push hl  ; to save the ptr 
28de			 
28de					; skip opcode 
28de 23					inc hl  
28df					; skip next ptr 
28df 23					inc hl  
28e0 23					inc hl 
28e1					; skip len 
28e1 23					inc hl 
28e2			 
28e2			;	if DEBUG_FORTH_WORDS 
28e2			;		DMARK "LSc" 
28e2			;		CALLMONITOR 
28e2			;	endif 
28e2 cd 5a 10				call strcmp 
28e5 c2 cc 28				jp nz, .fldouscanm 
28e8			; 
28e8			; 
28e8			;; while we have words to look for 
28e8			; 
28e8			;.fdouscan:	ld a, (hl)      
28e8			;	if DEBUG_FORTH_WORDS 
28e8			;		DMARK "LSs" 
28e8			;		CALLMONITOR 
28e8			;	endif 
28e8			;		cp WORD_SYS_END 
28e8			;		jp z, .fudone 
28e8			;		cp WORD_SYS_UWORD 
28e8			;		jp nz, .fnuword 
28e8			; 
28e8			;	if DEBUG_FORTH_WORDS 
28e8			;		DMARK "FGu" 
28e8			;		CALLMONITOR 
28e8			;	endif 
28e8			; 
28e8			;		; found a uword but is it the one we want... 
28e8			; 
28e8			; 
28e8			;	        pop de   ; get back the dsp name 
28e8			;		push de 
28e8			; 
28e8			;		push hl  ; to save the ptr 
28e8			; 
28e8			;		; skip opcode 
28e8			;		inc hl  
28e8			;		; skip next ptr 
28e8			;		inc hl  
28e8			;		inc hl 
28e8			;		; skip len 
28e8			;		inc hl 
28e8			; 
28e8			;	if DEBUG_FORTH_WORDS 
28e8			;		DMARK "FGc" 
28e8			;		CALLMONITOR 
28e8			;	endif 
28e8			;		call strcmp 
28e8			;		jp nz, .fnuword 
28e8			 
28e8			 
28e8 e1			pop hl 
28e9			 
28e9				 
28e9				if DEBUG_FORTH_WORDS 
28e9					DMARK "FGm" 
28e9 f5				push af  
28ea 3a fe 28			ld a, (.dmark)  
28ed 32 71 ee			ld (debug_mark),a  
28f0 3a ff 28			ld a, (.dmark+1)  
28f3 32 72 ee			ld (debug_mark+1),a  
28f6 3a 00 29			ld a, (.dmark+2)  
28f9 32 73 ee			ld (debug_mark+2),a  
28fc 18 03			jr .pastdmark  
28fe ..			.dmark: db "FGm"  
2901 f1			.pastdmark: pop af  
2902			endm  
# End of macro DMARK
2902					CALLMONITOR 
2902 cd 6d 14			call break_point_state  
2905				endm  
# End of macro CALLMONITOR
2905				endif 
2905			 
2905			 
2905			 
2905					; we have a uword so push its name to the stack 
2905			 
2905			;	   	push hl  ; save so we can move to next dict block 
2905			;pop hl 
2905			 
2905					; update opcode to deleted 
2905 3e 03				ld a, WORD_SYS_DELETED 
2907 77					ld (hl), a 
2908			 
2908 23					inc hl  
2909					; skip next ptr 
2909 23					inc hl  
290a 23					inc hl 
290b					; skip len 
290b 23					inc hl 
290c			 
290c					; TODO change parser to skip deleted words but for now mark it out 
290c 3e 5f				ld a, "_" 
290e 77					ld  (hl),a 
290f			 
290f			;		jr .fudone 
290f			; 
290f			;.fnuword:	pop hl 
290f			;		call forth_tok_next 
290f			;		jp .fdouscan  
290f			 
290f			.flunotfound:		  
290f			 
290f			 
290f					 
290f					FORTH_DSP_POP 
290f cd a9 1c			call macro_forth_dsp_pop 
2912				endm 
# End of macro FORTH_DSP_POP
2912			;		ld hl, .luno 
2912			;.fudone:		 pop hl 
2912					NEXTW 
2912 c3 63 1d			jp macro_next 
2915				endm 
# End of macro NEXTW
2915			.NOP: 
2915				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2915 61				db WORD_SYS_CORE+77             
2916 3c 29			dw .COMO            
2918 04				db 3 + 1 
2919 .. 00			db "NOP",0              
291d				endm 
# End of macro CWHEAD
291d			; | NOP (  --  ) Do nothing | DONE 
291d					if DEBUG_FORTH_WORDS_KEY 
291d						DMARK "NOP" 
291d f5				push af  
291e 3a 32 29			ld a, (.dmark)  
2921 32 71 ee			ld (debug_mark),a  
2924 3a 33 29			ld a, (.dmark+1)  
2927 32 72 ee			ld (debug_mark+1),a  
292a 3a 34 29			ld a, (.dmark+2)  
292d 32 73 ee			ld (debug_mark+2),a  
2930 18 03			jr .pastdmark  
2932 ..			.dmark: db "NOP"  
2935 f1			.pastdmark: pop af  
2936			endm  
# End of macro DMARK
2936						CALLMONITOR 
2936 cd 6d 14			call break_point_state  
2939				endm  
# End of macro CALLMONITOR
2939					endif 
2939				       NEXTW 
2939 c3 63 1d			jp macro_next 
293c				endm 
# End of macro NEXTW
293c			.COMO: 
293c				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
293c 6e				db WORD_SYS_CORE+90             
293d 8e 29			dw .COMC            
293f 02				db 1 + 1 
2940 .. 00			db "(",0              
2942				endm 
# End of macro CWHEAD
2942			; | ( ( -- )  Start of comment | DONE 
2942			 
2942			 
2942 2a 58 e6				ld hl, ( os_tok_ptr) 
2945 11 89 29			ld de, .closepar 
2948					 
2948					if DEBUG_FORTH_WORDS 
2948						DMARK ").." 
2948 f5				push af  
2949 3a 5d 29			ld a, (.dmark)  
294c 32 71 ee			ld (debug_mark),a  
294f 3a 5e 29			ld a, (.dmark+1)  
2952 32 72 ee			ld (debug_mark+1),a  
2955 3a 5f 29			ld a, (.dmark+2)  
2958 32 73 ee			ld (debug_mark+2),a  
295b 18 03			jr .pastdmark  
295d ..			.dmark: db ").."  
2960 f1			.pastdmark: pop af  
2961			endm  
# End of macro DMARK
2961						CALLMONITOR 
2961 cd 6d 14			call break_point_state  
2964				endm  
# End of macro CALLMONITOR
2964					endif 
2964 cd 7e 1e			call findnexttok  
2967			 
2967					if DEBUG_FORTH_WORDS 
2967						DMARK "IF5" 
2967 f5				push af  
2968 3a 7c 29			ld a, (.dmark)  
296b 32 71 ee			ld (debug_mark),a  
296e 3a 7d 29			ld a, (.dmark+1)  
2971 32 72 ee			ld (debug_mark+1),a  
2974 3a 7e 29			ld a, (.dmark+2)  
2977 32 73 ee			ld (debug_mark+2),a  
297a 18 03			jr .pastdmark  
297c ..			.dmark: db "IF5"  
297f f1			.pastdmark: pop af  
2980			endm  
# End of macro DMARK
2980						CALLMONITOR 
2980 cd 6d 14			call break_point_state  
2983				endm  
# End of macro CALLMONITOR
2983					endif 
2983				; replace below with ) exec using tok_ptr 
2983 22 58 e6			ld (os_tok_ptr), hl 
2986 c3 f4 1d			jp exec1 
2989			 
2989 .. 00			.closepar:   db ")",0 
298b			 
298b				       NEXTW 
298b c3 63 1d			jp macro_next 
298e				endm 
# End of macro NEXTW
298e			.COMC: 
298e				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
298e 6f				db WORD_SYS_CORE+91             
298f 97 29			dw .SCRATCH            
2991 02				db 1 + 1 
2992 .. 00			db ")",0              
2994				endm 
# End of macro CWHEAD
2994			; | ) ( -- )  End of comment |  DONE  
2994				       NEXTW 
2994 c3 63 1d			jp macro_next 
2997				endm 
# End of macro NEXTW
2997			 
2997			.SCRATCH: 
2997				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2997 6f				db WORD_SYS_CORE+91             
2998 d2 29			dw .INC            
299a 08				db 7 + 1 
299b .. 00			db "SCRATCH",0              
29a3				endm 
# End of macro CWHEAD
29a3			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
29a3			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
29a3			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
29a3			; | |  
29a3			; | | e.g.    : score $00 scratch ; 
29a3			; | |  
29a3			; | | $00 score ! 
29a3			; | | $01 score +! 
29a3			; | |  
29a3			; | | e.g.   : varword $0a scratch ;  
29a3			; | | 
29a3			; | | $8000 varword ! 
29a3					if DEBUG_FORTH_WORDS_KEY 
29a3						DMARK "SCR" 
29a3 f5				push af  
29a4 3a b8 29			ld a, (.dmark)  
29a7 32 71 ee			ld (debug_mark),a  
29aa 3a b9 29			ld a, (.dmark+1)  
29ad 32 72 ee			ld (debug_mark+1),a  
29b0 3a ba 29			ld a, (.dmark+2)  
29b3 32 73 ee			ld (debug_mark+2),a  
29b6 18 03			jr .pastdmark  
29b8 ..			.dmark: db "SCR"  
29bb f1			.pastdmark: pop af  
29bc			endm  
# End of macro DMARK
29bc						CALLMONITOR 
29bc cd 6d 14			call break_point_state  
29bf				endm  
# End of macro CALLMONITOR
29bf					endif 
29bf			 
29bf					FORTH_DSP_VALUEHL 
29bf cd f1 1b			call macro_dsp_valuehl 
29c2				endm 
# End of macro FORTH_DSP_VALUEHL
29c2				 
29c2					FORTH_DSP_POP 
29c2 cd a9 1c			call macro_forth_dsp_pop 
29c5				endm 
# End of macro FORTH_DSP_POP
29c5			 
29c5 7d					ld a, l 
29c6 21 7c e8				ld hl, os_var_array 
29c9 cd c4 0b				call addatohl 
29cc			 
29cc cd fa 19				call forth_push_numhl 
29cf			 
29cf				       NEXTW 
29cf c3 63 1d			jp macro_next 
29d2				endm 
# End of macro NEXTW
29d2			 
29d2			.INC: 
29d2				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
29d2 6f				db WORD_SYS_CORE+91             
29d3 26 2a			dw .DEC            
29d5 03				db 2 + 1 
29d6 .. 00			db "+!",0              
29d9				endm 
# End of macro CWHEAD
29d9			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
29d9					if DEBUG_FORTH_WORDS_KEY 
29d9						DMARK "+s_" 
29d9 f5				push af  
29da 3a ee 29			ld a, (.dmark)  
29dd 32 71 ee			ld (debug_mark),a  
29e0 3a ef 29			ld a, (.dmark+1)  
29e3 32 72 ee			ld (debug_mark+1),a  
29e6 3a f0 29			ld a, (.dmark+2)  
29e9 32 73 ee			ld (debug_mark+2),a  
29ec 18 03			jr .pastdmark  
29ee ..			.dmark: db "+s_"  
29f1 f1			.pastdmark: pop af  
29f2			endm  
# End of macro DMARK
29f2						CALLMONITOR 
29f2 cd 6d 14			call break_point_state  
29f5				endm  
# End of macro CALLMONITOR
29f5					endif 
29f5			 
29f5					FORTH_DSP_VALUEHL 
29f5 cd f1 1b			call macro_dsp_valuehl 
29f8				endm 
# End of macro FORTH_DSP_VALUEHL
29f8			 
29f8 e5					push hl   ; save address 
29f9			 
29f9					FORTH_DSP_POP 
29f9 cd a9 1c			call macro_forth_dsp_pop 
29fc				endm 
# End of macro FORTH_DSP_POP
29fc			 
29fc					FORTH_DSP_VALUEHL 
29fc cd f1 1b			call macro_dsp_valuehl 
29ff				endm 
# End of macro FORTH_DSP_VALUEHL
29ff			 
29ff					FORTH_DSP_POP 
29ff cd a9 1c			call macro_forth_dsp_pop 
2a02				endm 
# End of macro FORTH_DSP_POP
2a02			 
2a02					; hl contains value to add to byte at a 
2a02				 
2a02 eb					ex de, hl 
2a03			 
2a03 e1					pop hl 
2a04			 
2a04					if DEBUG_FORTH_WORDS 
2a04						DMARK "INC" 
2a04 f5				push af  
2a05 3a 19 2a			ld a, (.dmark)  
2a08 32 71 ee			ld (debug_mark),a  
2a0b 3a 1a 2a			ld a, (.dmark+1)  
2a0e 32 72 ee			ld (debug_mark+1),a  
2a11 3a 1b 2a			ld a, (.dmark+2)  
2a14 32 73 ee			ld (debug_mark+2),a  
2a17 18 03			jr .pastdmark  
2a19 ..			.dmark: db "INC"  
2a1c f1			.pastdmark: pop af  
2a1d			endm  
# End of macro DMARK
2a1d						CALLMONITOR 
2a1d cd 6d 14			call break_point_state  
2a20				endm  
# End of macro CALLMONITOR
2a20					endif 
2a20			 
2a20 7e					ld a,(hl) 
2a21 83					add e 
2a22 77					ld (hl),a 
2a23			 
2a23			 
2a23			 
2a23				       NEXTW 
2a23 c3 63 1d			jp macro_next 
2a26				endm 
# End of macro NEXTW
2a26			 
2a26			.DEC: 
2a26				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2a26 6f				db WORD_SYS_CORE+91             
2a27 77 2a			dw .INC2            
2a29 03				db 2 + 1 
2a2a .. 00			db "-!",0              
2a2d				endm 
# End of macro CWHEAD
2a2d			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2a2d					if DEBUG_FORTH_WORDS_KEY 
2a2d						DMARK "-s_" 
2a2d f5				push af  
2a2e 3a 42 2a			ld a, (.dmark)  
2a31 32 71 ee			ld (debug_mark),a  
2a34 3a 43 2a			ld a, (.dmark+1)  
2a37 32 72 ee			ld (debug_mark+1),a  
2a3a 3a 44 2a			ld a, (.dmark+2)  
2a3d 32 73 ee			ld (debug_mark+2),a  
2a40 18 03			jr .pastdmark  
2a42 ..			.dmark: db "-s_"  
2a45 f1			.pastdmark: pop af  
2a46			endm  
# End of macro DMARK
2a46						CALLMONITOR 
2a46 cd 6d 14			call break_point_state  
2a49				endm  
# End of macro CALLMONITOR
2a49					endif 
2a49			 
2a49					FORTH_DSP_VALUEHL 
2a49 cd f1 1b			call macro_dsp_valuehl 
2a4c				endm 
# End of macro FORTH_DSP_VALUEHL
2a4c			 
2a4c e5					push hl   ; save address 
2a4d			 
2a4d					FORTH_DSP_POP 
2a4d cd a9 1c			call macro_forth_dsp_pop 
2a50				endm 
# End of macro FORTH_DSP_POP
2a50			 
2a50					FORTH_DSP_VALUEHL 
2a50 cd f1 1b			call macro_dsp_valuehl 
2a53				endm 
# End of macro FORTH_DSP_VALUEHL
2a53			 
2a53					; hl contains value to add to byte at a 
2a53				 
2a53 eb					ex de, hl 
2a54			 
2a54 e1					pop hl 
2a55			 
2a55					if DEBUG_FORTH_WORDS 
2a55						DMARK "DEC" 
2a55 f5				push af  
2a56 3a 6a 2a			ld a, (.dmark)  
2a59 32 71 ee			ld (debug_mark),a  
2a5c 3a 6b 2a			ld a, (.dmark+1)  
2a5f 32 72 ee			ld (debug_mark+1),a  
2a62 3a 6c 2a			ld a, (.dmark+2)  
2a65 32 73 ee			ld (debug_mark+2),a  
2a68 18 03			jr .pastdmark  
2a6a ..			.dmark: db "DEC"  
2a6d f1			.pastdmark: pop af  
2a6e			endm  
# End of macro DMARK
2a6e						CALLMONITOR 
2a6e cd 6d 14			call break_point_state  
2a71				endm  
# End of macro CALLMONITOR
2a71					endif 
2a71			 
2a71 7e					ld a,(hl) 
2a72 93					sub e 
2a73 77					ld (hl),a 
2a74			 
2a74			 
2a74			 
2a74				       NEXTW 
2a74 c3 63 1d			jp macro_next 
2a77				endm 
# End of macro NEXTW
2a77			 
2a77			.INC2: 
2a77				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2a77 6f				db WORD_SYS_CORE+91             
2a78 21 2b			dw .DEC2            
2a7a 04				db 3 + 1 
2a7b .. 00			db "+2!",0              
2a7f				endm 
# End of macro CWHEAD
2a7f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2a7f			 
2a7f					if DEBUG_FORTH_WORDS_KEY 
2a7f						DMARK "+2s" 
2a7f f5				push af  
2a80 3a 94 2a			ld a, (.dmark)  
2a83 32 71 ee			ld (debug_mark),a  
2a86 3a 95 2a			ld a, (.dmark+1)  
2a89 32 72 ee			ld (debug_mark+1),a  
2a8c 3a 96 2a			ld a, (.dmark+2)  
2a8f 32 73 ee			ld (debug_mark+2),a  
2a92 18 03			jr .pastdmark  
2a94 ..			.dmark: db "+2s"  
2a97 f1			.pastdmark: pop af  
2a98			endm  
# End of macro DMARK
2a98						CALLMONITOR 
2a98 cd 6d 14			call break_point_state  
2a9b				endm  
# End of macro CALLMONITOR
2a9b					endif 
2a9b			 
2a9b					; Address 
2a9b			 
2a9b					FORTH_DSP_VALUEHL 
2a9b cd f1 1b			call macro_dsp_valuehl 
2a9e				endm 
# End of macro FORTH_DSP_VALUEHL
2a9e			 
2a9e e5					push hl    ; save address 
2a9f			 
2a9f					; load content into de 
2a9f			 
2a9f 5e					ld e,(hl) 
2aa0 23					inc hl 
2aa1 56					ld d, (hl) 
2aa2			 
2aa2					if DEBUG_FORTH_WORDS 
2aa2						DMARK "+2a" 
2aa2 f5				push af  
2aa3 3a b7 2a			ld a, (.dmark)  
2aa6 32 71 ee			ld (debug_mark),a  
2aa9 3a b8 2a			ld a, (.dmark+1)  
2aac 32 72 ee			ld (debug_mark+1),a  
2aaf 3a b9 2a			ld a, (.dmark+2)  
2ab2 32 73 ee			ld (debug_mark+2),a  
2ab5 18 03			jr .pastdmark  
2ab7 ..			.dmark: db "+2a"  
2aba f1			.pastdmark: pop af  
2abb			endm  
# End of macro DMARK
2abb						CALLMONITOR 
2abb cd 6d 14			call break_point_state  
2abe				endm  
# End of macro CALLMONITOR
2abe					endif 
2abe			 
2abe					FORTH_DSP_POP 
2abe cd a9 1c			call macro_forth_dsp_pop 
2ac1				endm 
# End of macro FORTH_DSP_POP
2ac1			 
2ac1					; Get value to add 
2ac1			 
2ac1					FORTH_DSP_VALUE 
2ac1 cd da 1b			call macro_forth_dsp_value 
2ac4				endm 
# End of macro FORTH_DSP_VALUE
2ac4			 
2ac4					if DEBUG_FORTH_WORDS 
2ac4						DMARK "+2v" 
2ac4 f5				push af  
2ac5 3a d9 2a			ld a, (.dmark)  
2ac8 32 71 ee			ld (debug_mark),a  
2acb 3a da 2a			ld a, (.dmark+1)  
2ace 32 72 ee			ld (debug_mark+1),a  
2ad1 3a db 2a			ld a, (.dmark+2)  
2ad4 32 73 ee			ld (debug_mark+2),a  
2ad7 18 03			jr .pastdmark  
2ad9 ..			.dmark: db "+2v"  
2adc f1			.pastdmark: pop af  
2add			endm  
# End of macro DMARK
2add						CALLMONITOR 
2add cd 6d 14			call break_point_state  
2ae0				endm  
# End of macro CALLMONITOR
2ae0					endif 
2ae0			 
2ae0 19					add hl, de 
2ae1			 
2ae1					if DEBUG_FORTH_WORDS 
2ae1						DMARK "+2+" 
2ae1 f5				push af  
2ae2 3a f6 2a			ld a, (.dmark)  
2ae5 32 71 ee			ld (debug_mark),a  
2ae8 3a f7 2a			ld a, (.dmark+1)  
2aeb 32 72 ee			ld (debug_mark+1),a  
2aee 3a f8 2a			ld a, (.dmark+2)  
2af1 32 73 ee			ld (debug_mark+2),a  
2af4 18 03			jr .pastdmark  
2af6 ..			.dmark: db "+2+"  
2af9 f1			.pastdmark: pop af  
2afa			endm  
# End of macro DMARK
2afa						CALLMONITOR 
2afa cd 6d 14			call break_point_state  
2afd				endm  
# End of macro CALLMONITOR
2afd					endif 
2afd			 
2afd					; move result to de 
2afd			 
2afd eb					ex de, hl 
2afe			 
2afe					; Address 
2afe			 
2afe e1					pop hl 
2aff			 
2aff					; save it back 
2aff			 
2aff 73					ld (hl), e 
2b00 23					inc hl 
2b01 72					ld (hl), d 
2b02			 
2b02					if DEBUG_FORTH_WORDS 
2b02						DMARK "+2e" 
2b02 f5				push af  
2b03 3a 17 2b			ld a, (.dmark)  
2b06 32 71 ee			ld (debug_mark),a  
2b09 3a 18 2b			ld a, (.dmark+1)  
2b0c 32 72 ee			ld (debug_mark+1),a  
2b0f 3a 19 2b			ld a, (.dmark+2)  
2b12 32 73 ee			ld (debug_mark+2),a  
2b15 18 03			jr .pastdmark  
2b17 ..			.dmark: db "+2e"  
2b1a f1			.pastdmark: pop af  
2b1b			endm  
# End of macro DMARK
2b1b						CALLMONITOR 
2b1b cd 6d 14			call break_point_state  
2b1e				endm  
# End of macro CALLMONITOR
2b1e					endif 
2b1e			 
2b1e			 
2b1e			 
2b1e			 
2b1e			 
2b1e				       NEXTW 
2b1e c3 63 1d			jp macro_next 
2b21				endm 
# End of macro NEXTW
2b21			 
2b21			.DEC2: 
2b21				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2b21 6f				db WORD_SYS_CORE+91             
2b22 cd 2b			dw .GET2            
2b24 04				db 3 + 1 
2b25 .. 00			db "-2!",0              
2b29				endm 
# End of macro CWHEAD
2b29			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2b29			 
2b29			 
2b29					if DEBUG_FORTH_WORDS_KEY 
2b29						DMARK "-2s" 
2b29 f5				push af  
2b2a 3a 3e 2b			ld a, (.dmark)  
2b2d 32 71 ee			ld (debug_mark),a  
2b30 3a 3f 2b			ld a, (.dmark+1)  
2b33 32 72 ee			ld (debug_mark+1),a  
2b36 3a 40 2b			ld a, (.dmark+2)  
2b39 32 73 ee			ld (debug_mark+2),a  
2b3c 18 03			jr .pastdmark  
2b3e ..			.dmark: db "-2s"  
2b41 f1			.pastdmark: pop af  
2b42			endm  
# End of macro DMARK
2b42						CALLMONITOR 
2b42 cd 6d 14			call break_point_state  
2b45				endm  
# End of macro CALLMONITOR
2b45					endif 
2b45			 
2b45					; Address 
2b45			 
2b45					FORTH_DSP_VALUEHL 
2b45 cd f1 1b			call macro_dsp_valuehl 
2b48				endm 
# End of macro FORTH_DSP_VALUEHL
2b48			 
2b48 e5					push hl    ; save address 
2b49			 
2b49					; load content into de 
2b49			 
2b49 5e					ld e,(hl) 
2b4a 23					inc hl 
2b4b 56					ld d, (hl) 
2b4c			 
2b4c					if DEBUG_FORTH_WORDS 
2b4c						DMARK "-2a" 
2b4c f5				push af  
2b4d 3a 61 2b			ld a, (.dmark)  
2b50 32 71 ee			ld (debug_mark),a  
2b53 3a 62 2b			ld a, (.dmark+1)  
2b56 32 72 ee			ld (debug_mark+1),a  
2b59 3a 63 2b			ld a, (.dmark+2)  
2b5c 32 73 ee			ld (debug_mark+2),a  
2b5f 18 03			jr .pastdmark  
2b61 ..			.dmark: db "-2a"  
2b64 f1			.pastdmark: pop af  
2b65			endm  
# End of macro DMARK
2b65						CALLMONITOR 
2b65 cd 6d 14			call break_point_state  
2b68				endm  
# End of macro CALLMONITOR
2b68					endif 
2b68			 
2b68					FORTH_DSP_POP 
2b68 cd a9 1c			call macro_forth_dsp_pop 
2b6b				endm 
# End of macro FORTH_DSP_POP
2b6b			 
2b6b					; Get value to remove 
2b6b			 
2b6b					FORTH_DSP_VALUE 
2b6b cd da 1b			call macro_forth_dsp_value 
2b6e				endm 
# End of macro FORTH_DSP_VALUE
2b6e			 
2b6e					if DEBUG_FORTH_WORDS 
2b6e						DMARK "-2v" 
2b6e f5				push af  
2b6f 3a 83 2b			ld a, (.dmark)  
2b72 32 71 ee			ld (debug_mark),a  
2b75 3a 84 2b			ld a, (.dmark+1)  
2b78 32 72 ee			ld (debug_mark+1),a  
2b7b 3a 85 2b			ld a, (.dmark+2)  
2b7e 32 73 ee			ld (debug_mark+2),a  
2b81 18 03			jr .pastdmark  
2b83 ..			.dmark: db "-2v"  
2b86 f1			.pastdmark: pop af  
2b87			endm  
# End of macro DMARK
2b87						CALLMONITOR 
2b87 cd 6d 14			call break_point_state  
2b8a				endm  
# End of macro CALLMONITOR
2b8a					endif 
2b8a			 
2b8a eb					ex de, hl 
2b8b ed 52				sbc hl, de 
2b8d			 
2b8d					if DEBUG_FORTH_WORDS 
2b8d						DMARK "-2d" 
2b8d f5				push af  
2b8e 3a a2 2b			ld a, (.dmark)  
2b91 32 71 ee			ld (debug_mark),a  
2b94 3a a3 2b			ld a, (.dmark+1)  
2b97 32 72 ee			ld (debug_mark+1),a  
2b9a 3a a4 2b			ld a, (.dmark+2)  
2b9d 32 73 ee			ld (debug_mark+2),a  
2ba0 18 03			jr .pastdmark  
2ba2 ..			.dmark: db "-2d"  
2ba5 f1			.pastdmark: pop af  
2ba6			endm  
# End of macro DMARK
2ba6						CALLMONITOR 
2ba6 cd 6d 14			call break_point_state  
2ba9				endm  
# End of macro CALLMONITOR
2ba9					endif 
2ba9			 
2ba9					; move result to de 
2ba9			 
2ba9 eb					ex de, hl 
2baa			 
2baa					; Address 
2baa			 
2baa e1					pop hl 
2bab			 
2bab					; save it back 
2bab			 
2bab 73					ld (hl), e 
2bac 23					inc hl 
2bad 72					ld (hl), d 
2bae			 
2bae					if DEBUG_FORTH_WORDS 
2bae						DMARK "-2e" 
2bae f5				push af  
2baf 3a c3 2b			ld a, (.dmark)  
2bb2 32 71 ee			ld (debug_mark),a  
2bb5 3a c4 2b			ld a, (.dmark+1)  
2bb8 32 72 ee			ld (debug_mark+1),a  
2bbb 3a c5 2b			ld a, (.dmark+2)  
2bbe 32 73 ee			ld (debug_mark+2),a  
2bc1 18 03			jr .pastdmark  
2bc3 ..			.dmark: db "-2e"  
2bc6 f1			.pastdmark: pop af  
2bc7			endm  
# End of macro DMARK
2bc7						CALLMONITOR 
2bc7 cd 6d 14			call break_point_state  
2bca				endm  
# End of macro CALLMONITOR
2bca					endif 
2bca			 
2bca			 
2bca			 
2bca			 
2bca			 
2bca				       NEXTW 
2bca c3 63 1d			jp macro_next 
2bcd				endm 
# End of macro NEXTW
2bcd			.GET2: 
2bcd				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2bcd 6f				db WORD_SYS_CORE+91             
2bce fd 2b			dw .BANG2            
2bd0 03				db 2 + 1 
2bd1 .. 00			db "2@",0              
2bd4				endm 
# End of macro CWHEAD
2bd4			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2bd4					if DEBUG_FORTH_WORDS_KEY 
2bd4						DMARK "2A_" 
2bd4 f5				push af  
2bd5 3a e9 2b			ld a, (.dmark)  
2bd8 32 71 ee			ld (debug_mark),a  
2bdb 3a ea 2b			ld a, (.dmark+1)  
2bde 32 72 ee			ld (debug_mark+1),a  
2be1 3a eb 2b			ld a, (.dmark+2)  
2be4 32 73 ee			ld (debug_mark+2),a  
2be7 18 03			jr .pastdmark  
2be9 ..			.dmark: db "2A_"  
2bec f1			.pastdmark: pop af  
2bed			endm  
# End of macro DMARK
2bed						CALLMONITOR 
2bed cd 6d 14			call break_point_state  
2bf0				endm  
# End of macro CALLMONITOR
2bf0					endif 
2bf0			 
2bf0					FORTH_DSP_VALUEHL 
2bf0 cd f1 1b			call macro_dsp_valuehl 
2bf3				endm 
# End of macro FORTH_DSP_VALUEHL
2bf3			 
2bf3 5e					ld e, (hl) 
2bf4 23					inc hl 
2bf5 56					ld d, (hl) 
2bf6			 
2bf6 eb					ex de, hl 
2bf7			 
2bf7 cd fa 19				call forth_push_numhl 
2bfa			 
2bfa				       NEXTW 
2bfa c3 63 1d			jp macro_next 
2bfd				endm 
# End of macro NEXTW
2bfd			.BANG2: 
2bfd				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2bfd 6f				db WORD_SYS_CORE+91             
2bfe 35 2c			dw .CONFIG            
2c00 03				db 2 + 1 
2c01 .. 00			db "2!",0              
2c04				endm 
# End of macro CWHEAD
2c04			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2c04					if DEBUG_FORTH_WORDS_KEY 
2c04						DMARK "2S_" 
2c04 f5				push af  
2c05 3a 19 2c			ld a, (.dmark)  
2c08 32 71 ee			ld (debug_mark),a  
2c0b 3a 1a 2c			ld a, (.dmark+1)  
2c0e 32 72 ee			ld (debug_mark+1),a  
2c11 3a 1b 2c			ld a, (.dmark+2)  
2c14 32 73 ee			ld (debug_mark+2),a  
2c17 18 03			jr .pastdmark  
2c19 ..			.dmark: db "2S_"  
2c1c f1			.pastdmark: pop af  
2c1d			endm  
# End of macro DMARK
2c1d						CALLMONITOR 
2c1d cd 6d 14			call break_point_state  
2c20				endm  
# End of macro CALLMONITOR
2c20					endif 
2c20			 
2c20					FORTH_DSP_VALUEHL 
2c20 cd f1 1b			call macro_dsp_valuehl 
2c23				endm 
# End of macro FORTH_DSP_VALUEHL
2c23			 
2c23 e5					push hl   ; save address 
2c24			 
2c24			 
2c24					FORTH_DSP_POP 
2c24 cd a9 1c			call macro_forth_dsp_pop 
2c27				endm 
# End of macro FORTH_DSP_POP
2c27			 
2c27					 
2c27					FORTH_DSP_VALUEHL 
2c27 cd f1 1b			call macro_dsp_valuehl 
2c2a				endm 
# End of macro FORTH_DSP_VALUEHL
2c2a			 
2c2a					FORTH_DSP_POP 
2c2a cd a9 1c			call macro_forth_dsp_pop 
2c2d				endm 
# End of macro FORTH_DSP_POP
2c2d			 
2c2d eb					ex de, hl    ; value now in de 
2c2e			 
2c2e e1					pop hl 
2c2f			 
2c2f 73					ld (hl), e 
2c30			 
2c30 23					inc hl 
2c31			 
2c31 72					ld (hl), d 
2c32			 
2c32			 
2c32				       NEXTW 
2c32 c3 63 1d			jp macro_next 
2c35				endm 
# End of macro NEXTW
2c35			.CONFIG: 
2c35				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2c35 6f				db WORD_SYS_CORE+91             
2c36 46 2c			dw .ENDCORE            
2c38 07				db 6 + 1 
2c39 .. 00			db "CONFIG",0              
2c40				endm 
# End of macro CWHEAD
2c40			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2c40			 
2c40 cd 24 12				call config 
2c43					NEXTW 
2c43 c3 63 1d			jp macro_next 
2c46				endm 
# End of macro NEXTW
2c46			.ENDCORE: 
2c46			 
2c46			; eof 
2c46			 
2c46			 
# End of file forth_words_core.asm
2c46			include "forth_words_flow.asm" 
2c46			 
2c46			; | ## Program Flow Words 
2c46			 
2c46			.IF: 
2c46				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2c46 1e				db WORD_SYS_CORE+10             
2c47 3b 2d			dw .THEN            
2c49 03				db 2 + 1 
2c4a .. 00			db "IF",0              
2c4d				endm 
# End of macro CWHEAD
2c4d			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2c4d			; 
2c4d					if DEBUG_FORTH_WORDS_KEY 
2c4d						DMARK "IF." 
2c4d f5				push af  
2c4e 3a 62 2c			ld a, (.dmark)  
2c51 32 71 ee			ld (debug_mark),a  
2c54 3a 63 2c			ld a, (.dmark+1)  
2c57 32 72 ee			ld (debug_mark+1),a  
2c5a 3a 64 2c			ld a, (.dmark+2)  
2c5d 32 73 ee			ld (debug_mark+2),a  
2c60 18 03			jr .pastdmark  
2c62 ..			.dmark: db "IF."  
2c65 f1			.pastdmark: pop af  
2c66			endm  
# End of macro DMARK
2c66						CALLMONITOR 
2c66 cd 6d 14			call break_point_state  
2c69				endm  
# End of macro CALLMONITOR
2c69					endif 
2c69			; eval TOS 
2c69			 
2c69				FORTH_DSP_VALUEHL 
2c69 cd f1 1b			call macro_dsp_valuehl 
2c6c				endm 
# End of macro FORTH_DSP_VALUEHL
2c6c			 
2c6c			;	push hl 
2c6c				FORTH_DSP_POP 
2c6c cd a9 1c			call macro_forth_dsp_pop 
2c6f				endm 
# End of macro FORTH_DSP_POP
2c6f			;	pop hl 
2c6f			 
2c6f					if DEBUG_FORTH_WORDS 
2c6f						DMARK "IF1" 
2c6f f5				push af  
2c70 3a 84 2c			ld a, (.dmark)  
2c73 32 71 ee			ld (debug_mark),a  
2c76 3a 85 2c			ld a, (.dmark+1)  
2c79 32 72 ee			ld (debug_mark+1),a  
2c7c 3a 86 2c			ld a, (.dmark+2)  
2c7f 32 73 ee			ld (debug_mark+2),a  
2c82 18 03			jr .pastdmark  
2c84 ..			.dmark: db "IF1"  
2c87 f1			.pastdmark: pop af  
2c88			endm  
# End of macro DMARK
2c88						CALLMONITOR 
2c88 cd 6d 14			call break_point_state  
2c8b				endm  
# End of macro CALLMONITOR
2c8b					endif 
2c8b b7				or a        ; clear carry flag 
2c8c 11 00 00			ld de, 0 
2c8f eb				ex de,hl 
2c90 ed 52			sbc hl, de 
2c92 c2 1c 2d			jp nz, .iftrue 
2c95			 
2c95					if DEBUG_FORTH_WORDS 
2c95						DMARK "IF2" 
2c95 f5				push af  
2c96 3a aa 2c			ld a, (.dmark)  
2c99 32 71 ee			ld (debug_mark),a  
2c9c 3a ab 2c			ld a, (.dmark+1)  
2c9f 32 72 ee			ld (debug_mark+1),a  
2ca2 3a ac 2c			ld a, (.dmark+2)  
2ca5 32 73 ee			ld (debug_mark+2),a  
2ca8 18 03			jr .pastdmark  
2caa ..			.dmark: db "IF2"  
2cad f1			.pastdmark: pop af  
2cae			endm  
# End of macro DMARK
2cae						CALLMONITOR 
2cae cd 6d 14			call break_point_state  
2cb1				endm  
# End of macro CALLMONITOR
2cb1					endif 
2cb1			 
2cb1			; if not true then skip to THEN 
2cb1			 
2cb1				; TODO get tok_ptr 
2cb1				; TODO consume toks until we get to THEN 
2cb1			 
2cb1 2a 58 e6			ld hl, (os_tok_ptr) 
2cb4					if DEBUG_FORTH_WORDS 
2cb4						DMARK "IF3" 
2cb4 f5				push af  
2cb5 3a c9 2c			ld a, (.dmark)  
2cb8 32 71 ee			ld (debug_mark),a  
2cbb 3a ca 2c			ld a, (.dmark+1)  
2cbe 32 72 ee			ld (debug_mark+1),a  
2cc1 3a cb 2c			ld a, (.dmark+2)  
2cc4 32 73 ee			ld (debug_mark+2),a  
2cc7 18 03			jr .pastdmark  
2cc9 ..			.dmark: db "IF3"  
2ccc f1			.pastdmark: pop af  
2ccd			endm  
# End of macro DMARK
2ccd						CALLMONITOR 
2ccd cd 6d 14			call break_point_state  
2cd0				endm  
# End of macro CALLMONITOR
2cd0						 
2cd0					endif 
2cd0 11 17 2d			ld de, .ifthen 
2cd3					if DEBUG_FORTH_WORDS 
2cd3						DMARK "IF4" 
2cd3 f5				push af  
2cd4 3a e8 2c			ld a, (.dmark)  
2cd7 32 71 ee			ld (debug_mark),a  
2cda 3a e9 2c			ld a, (.dmark+1)  
2cdd 32 72 ee			ld (debug_mark+1),a  
2ce0 3a ea 2c			ld a, (.dmark+2)  
2ce3 32 73 ee			ld (debug_mark+2),a  
2ce6 18 03			jr .pastdmark  
2ce8 ..			.dmark: db "IF4"  
2ceb f1			.pastdmark: pop af  
2cec			endm  
# End of macro DMARK
2cec						CALLMONITOR 
2cec cd 6d 14			call break_point_state  
2cef				endm  
# End of macro CALLMONITOR
2cef					endif 
2cef cd 7e 1e			call findnexttok  
2cf2			 
2cf2					if DEBUG_FORTH_WORDS 
2cf2						DMARK "IF5" 
2cf2 f5				push af  
2cf3 3a 07 2d			ld a, (.dmark)  
2cf6 32 71 ee			ld (debug_mark),a  
2cf9 3a 08 2d			ld a, (.dmark+1)  
2cfc 32 72 ee			ld (debug_mark+1),a  
2cff 3a 09 2d			ld a, (.dmark+2)  
2d02 32 73 ee			ld (debug_mark+2),a  
2d05 18 03			jr .pastdmark  
2d07 ..			.dmark: db "IF5"  
2d0a f1			.pastdmark: pop af  
2d0b			endm  
# End of macro DMARK
2d0b						CALLMONITOR 
2d0b cd 6d 14			call break_point_state  
2d0e				endm  
# End of macro CALLMONITOR
2d0e					endif 
2d0e				; TODO replace below with ; exec using tok_ptr 
2d0e 22 58 e6			ld (os_tok_ptr), hl 
2d11 c3 f4 1d			jp exec1 
2d14				NEXTW 
2d14 c3 63 1d			jp macro_next 
2d17				endm 
# End of macro NEXTW
2d17			 
2d17 .. 00		.ifthen:  db "THEN",0 
2d1c			 
2d1c			.iftrue:		 
2d1c				; Exec next words normally 
2d1c			 
2d1c				; if true then exec following IF as normal 
2d1c					if DEBUG_FORTH_WORDS 
2d1c						DMARK "IFT" 
2d1c f5				push af  
2d1d 3a 31 2d			ld a, (.dmark)  
2d20 32 71 ee			ld (debug_mark),a  
2d23 3a 32 2d			ld a, (.dmark+1)  
2d26 32 72 ee			ld (debug_mark+1),a  
2d29 3a 33 2d			ld a, (.dmark+2)  
2d2c 32 73 ee			ld (debug_mark+2),a  
2d2f 18 03			jr .pastdmark  
2d31 ..			.dmark: db "IFT"  
2d34 f1			.pastdmark: pop af  
2d35			endm  
# End of macro DMARK
2d35						CALLMONITOR 
2d35 cd 6d 14			call break_point_state  
2d38				endm  
# End of macro CALLMONITOR
2d38					endif 
2d38			 
2d38					NEXTW 
2d38 c3 63 1d			jp macro_next 
2d3b				endm 
# End of macro NEXTW
2d3b			.THEN: 
2d3b				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2d3b 1f				db WORD_SYS_CORE+11             
2d3c 63 2d			dw .ELSE            
2d3e 05				db 4 + 1 
2d3f .. 00			db "THEN",0              
2d44				endm 
# End of macro CWHEAD
2d44			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2d44					if DEBUG_FORTH_WORDS_KEY 
2d44						DMARK "THN" 
2d44 f5				push af  
2d45 3a 59 2d			ld a, (.dmark)  
2d48 32 71 ee			ld (debug_mark),a  
2d4b 3a 5a 2d			ld a, (.dmark+1)  
2d4e 32 72 ee			ld (debug_mark+1),a  
2d51 3a 5b 2d			ld a, (.dmark+2)  
2d54 32 73 ee			ld (debug_mark+2),a  
2d57 18 03			jr .pastdmark  
2d59 ..			.dmark: db "THN"  
2d5c f1			.pastdmark: pop af  
2d5d			endm  
# End of macro DMARK
2d5d						CALLMONITOR 
2d5d cd 6d 14			call break_point_state  
2d60				endm  
# End of macro CALLMONITOR
2d60					endif 
2d60					NEXTW 
2d60 c3 63 1d			jp macro_next 
2d63				endm 
# End of macro NEXTW
2d63			.ELSE: 
2d63				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2d63 20				db WORD_SYS_CORE+12             
2d64 8b 2d			dw .DO            
2d66 03				db 2 + 1 
2d67 .. 00			db "ELSE",0              
2d6c				endm 
# End of macro CWHEAD
2d6c			; | ELSE ( -- ) Not supported - does nothing | TODO 
2d6c			 
2d6c					if DEBUG_FORTH_WORDS_KEY 
2d6c						DMARK "ELS" 
2d6c f5				push af  
2d6d 3a 81 2d			ld a, (.dmark)  
2d70 32 71 ee			ld (debug_mark),a  
2d73 3a 82 2d			ld a, (.dmark+1)  
2d76 32 72 ee			ld (debug_mark+1),a  
2d79 3a 83 2d			ld a, (.dmark+2)  
2d7c 32 73 ee			ld (debug_mark+2),a  
2d7f 18 03			jr .pastdmark  
2d81 ..			.dmark: db "ELS"  
2d84 f1			.pastdmark: pop af  
2d85			endm  
# End of macro DMARK
2d85						CALLMONITOR 
2d85 cd 6d 14			call break_point_state  
2d88				endm  
# End of macro CALLMONITOR
2d88					endif 
2d88			 
2d88			 
2d88					NEXTW 
2d88 c3 63 1d			jp macro_next 
2d8b				endm 
# End of macro NEXTW
2d8b			.DO: 
2d8b				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2d8b 21				db WORD_SYS_CORE+13             
2d8c b2 2e			dw .LOOP            
2d8e 03				db 2 + 1 
2d8f .. 00			db "DO",0              
2d92				endm 
# End of macro CWHEAD
2d92			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2d92			 
2d92					if DEBUG_FORTH_WORDS_KEY 
2d92						DMARK "DO." 
2d92 f5				push af  
2d93 3a a7 2d			ld a, (.dmark)  
2d96 32 71 ee			ld (debug_mark),a  
2d99 3a a8 2d			ld a, (.dmark+1)  
2d9c 32 72 ee			ld (debug_mark+1),a  
2d9f 3a a9 2d			ld a, (.dmark+2)  
2da2 32 73 ee			ld (debug_mark+2),a  
2da5 18 03			jr .pastdmark  
2da7 ..			.dmark: db "DO."  
2daa f1			.pastdmark: pop af  
2dab			endm  
# End of macro DMARK
2dab						CALLMONITOR 
2dab cd 6d 14			call break_point_state  
2dae				endm  
# End of macro CALLMONITOR
2dae					endif 
2dae			;  push pc to rsp stack past the DO 
2dae			 
2dae 2a 58 e6				ld hl, (os_tok_ptr) 
2db1 23					inc hl   ; D 
2db2 23					inc hl  ; O 
2db3 23					inc hl   ; null 
2db4					if DEBUG_FORTH_WORDS 
2db4						DMARK "DO2" 
2db4 f5				push af  
2db5 3a c9 2d			ld a, (.dmark)  
2db8 32 71 ee			ld (debug_mark),a  
2dbb 3a ca 2d			ld a, (.dmark+1)  
2dbe 32 72 ee			ld (debug_mark+1),a  
2dc1 3a cb 2d			ld a, (.dmark+2)  
2dc4 32 73 ee			ld (debug_mark+2),a  
2dc7 18 03			jr .pastdmark  
2dc9 ..			.dmark: db "DO2"  
2dcc f1			.pastdmark: pop af  
2dcd			endm  
# End of macro DMARK
2dcd						CALLMONITOR 
2dcd cd 6d 14			call break_point_state  
2dd0				endm  
# End of macro CALLMONITOR
2dd0					endif 
2dd0					FORTH_RSP_NEXT 
2dd0 cd a1 19			call macro_forth_rsp_next 
2dd3				endm 
# End of macro FORTH_RSP_NEXT
2dd3					if DEBUG_FORTH_WORDS 
2dd3						DMARK "DO3" 
2dd3 f5				push af  
2dd4 3a e8 2d			ld a, (.dmark)  
2dd7 32 71 ee			ld (debug_mark),a  
2dda 3a e9 2d			ld a, (.dmark+1)  
2ddd 32 72 ee			ld (debug_mark+1),a  
2de0 3a ea 2d			ld a, (.dmark+2)  
2de3 32 73 ee			ld (debug_mark+2),a  
2de6 18 03			jr .pastdmark  
2de8 ..			.dmark: db "DO3"  
2deb f1			.pastdmark: pop af  
2dec			endm  
# End of macro DMARK
2dec						CALLMONITOR 
2dec cd 6d 14			call break_point_state  
2def				endm  
# End of macro CALLMONITOR
2def					endif 
2def			 
2def					;if DEBUG_FORTH_WORDS 
2def				;		push hl 
2def			;		endif  
2def			 
2def			; get counters from data stack 
2def			 
2def			 
2def					FORTH_DSP_VALUEHL 
2def cd f1 1b			call macro_dsp_valuehl 
2df2				endm 
# End of macro FORTH_DSP_VALUEHL
2df2 e5					push hl		 ; hl now has starting counter which needs to be tos 
2df3			 
2df3					if DEBUG_FORTH_WORDS 
2df3						DMARK "DO4" 
2df3 f5				push af  
2df4 3a 08 2e			ld a, (.dmark)  
2df7 32 71 ee			ld (debug_mark),a  
2dfa 3a 09 2e			ld a, (.dmark+1)  
2dfd 32 72 ee			ld (debug_mark+1),a  
2e00 3a 0a 2e			ld a, (.dmark+2)  
2e03 32 73 ee			ld (debug_mark+2),a  
2e06 18 03			jr .pastdmark  
2e08 ..			.dmark: db "DO4"  
2e0b f1			.pastdmark: pop af  
2e0c			endm  
# End of macro DMARK
2e0c						CALLMONITOR 
2e0c cd 6d 14			call break_point_state  
2e0f				endm  
# End of macro CALLMONITOR
2e0f					endif 
2e0f					FORTH_DSP_POP 
2e0f cd a9 1c			call macro_forth_dsp_pop 
2e12				endm 
# End of macro FORTH_DSP_POP
2e12			 
2e12					if DEBUG_FORTH_WORDS 
2e12						DMARK "DO5" 
2e12 f5				push af  
2e13 3a 27 2e			ld a, (.dmark)  
2e16 32 71 ee			ld (debug_mark),a  
2e19 3a 28 2e			ld a, (.dmark+1)  
2e1c 32 72 ee			ld (debug_mark+1),a  
2e1f 3a 29 2e			ld a, (.dmark+2)  
2e22 32 73 ee			ld (debug_mark+2),a  
2e25 18 03			jr .pastdmark  
2e27 ..			.dmark: db "DO5"  
2e2a f1			.pastdmark: pop af  
2e2b			endm  
# End of macro DMARK
2e2b						CALLMONITOR 
2e2b cd 6d 14			call break_point_state  
2e2e				endm  
# End of macro CALLMONITOR
2e2e					endif 
2e2e			 
2e2e					FORTH_DSP_VALUEHL 
2e2e cd f1 1b			call macro_dsp_valuehl 
2e31				endm 
# End of macro FORTH_DSP_VALUEHL
2e31			;		push hl		 ; hl now has starting limit counter 
2e31			 
2e31					if DEBUG_FORTH_WORDS 
2e31						DMARK "DO6" 
2e31 f5				push af  
2e32 3a 46 2e			ld a, (.dmark)  
2e35 32 71 ee			ld (debug_mark),a  
2e38 3a 47 2e			ld a, (.dmark+1)  
2e3b 32 72 ee			ld (debug_mark+1),a  
2e3e 3a 48 2e			ld a, (.dmark+2)  
2e41 32 73 ee			ld (debug_mark+2),a  
2e44 18 03			jr .pastdmark  
2e46 ..			.dmark: db "DO6"  
2e49 f1			.pastdmark: pop af  
2e4a			endm  
# End of macro DMARK
2e4a						CALLMONITOR 
2e4a cd 6d 14			call break_point_state  
2e4d				endm  
# End of macro CALLMONITOR
2e4d					endif 
2e4d					FORTH_DSP_POP 
2e4d cd a9 1c			call macro_forth_dsp_pop 
2e50				endm 
# End of macro FORTH_DSP_POP
2e50			 
2e50			; put counters on the loop stack 
2e50			 
2e50			;		pop hl			 ; limit counter 
2e50 d1					pop de			; start counter 
2e51			 
2e51					; push limit counter 
2e51			 
2e51					if DEBUG_FORTH_WORDS 
2e51						DMARK "DO7" 
2e51 f5				push af  
2e52 3a 66 2e			ld a, (.dmark)  
2e55 32 71 ee			ld (debug_mark),a  
2e58 3a 67 2e			ld a, (.dmark+1)  
2e5b 32 72 ee			ld (debug_mark+1),a  
2e5e 3a 68 2e			ld a, (.dmark+2)  
2e61 32 73 ee			ld (debug_mark+2),a  
2e64 18 03			jr .pastdmark  
2e66 ..			.dmark: db "DO7"  
2e69 f1			.pastdmark: pop af  
2e6a			endm  
# End of macro DMARK
2e6a						CALLMONITOR 
2e6a cd 6d 14			call break_point_state  
2e6d				endm  
# End of macro CALLMONITOR
2e6d					endif 
2e6d					FORTH_LOOP_NEXT 
2e6d cd 22 1c			call macro_forth_loop_next 
2e70				endm 
# End of macro FORTH_LOOP_NEXT
2e70			 
2e70					; push start counter 
2e70			 
2e70 eb					ex de, hl 
2e71					if DEBUG_FORTH_WORDS 
2e71						DMARK "DO7" 
2e71 f5				push af  
2e72 3a 86 2e			ld a, (.dmark)  
2e75 32 71 ee			ld (debug_mark),a  
2e78 3a 87 2e			ld a, (.dmark+1)  
2e7b 32 72 ee			ld (debug_mark+1),a  
2e7e 3a 88 2e			ld a, (.dmark+2)  
2e81 32 73 ee			ld (debug_mark+2),a  
2e84 18 03			jr .pastdmark  
2e86 ..			.dmark: db "DO7"  
2e89 f1			.pastdmark: pop af  
2e8a			endm  
# End of macro DMARK
2e8a						CALLMONITOR 
2e8a cd 6d 14			call break_point_state  
2e8d				endm  
# End of macro CALLMONITOR
2e8d					endif 
2e8d					FORTH_LOOP_NEXT 
2e8d cd 22 1c			call macro_forth_loop_next 
2e90				endm 
# End of macro FORTH_LOOP_NEXT
2e90			 
2e90			 
2e90					; init first round of I counter 
2e90			 
2e90 22 7c e6				ld (os_current_i), hl 
2e93			 
2e93					if DEBUG_FORTH_WORDS 
2e93						DMARK "DO8" 
2e93 f5				push af  
2e94 3a a8 2e			ld a, (.dmark)  
2e97 32 71 ee			ld (debug_mark),a  
2e9a 3a a9 2e			ld a, (.dmark+1)  
2e9d 32 72 ee			ld (debug_mark+1),a  
2ea0 3a aa 2e			ld a, (.dmark+2)  
2ea3 32 73 ee			ld (debug_mark+2),a  
2ea6 18 03			jr .pastdmark  
2ea8 ..			.dmark: db "DO8"  
2eab f1			.pastdmark: pop af  
2eac			endm  
# End of macro DMARK
2eac						CALLMONITOR 
2eac cd 6d 14			call break_point_state  
2eaf				endm  
# End of macro CALLMONITOR
2eaf					endif 
2eaf			 
2eaf					NEXTW 
2eaf c3 63 1d			jp macro_next 
2eb2				endm 
# End of macro NEXTW
2eb2			.LOOP: 
2eb2				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2eb2 22				db WORD_SYS_CORE+14             
2eb3 ca 2f			dw .I            
2eb5 05				db 4 + 1 
2eb6 .. 00			db "LOOP",0              
2ebb				endm 
# End of macro CWHEAD
2ebb			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2ebb			 
2ebb				; pop tos as current loop count to hl 
2ebb			 
2ebb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2ebb			 
2ebb				FORTH_LOOP_TOS 
2ebb cd 55 1c			call macro_forth_loop_tos 
2ebe				endm 
# End of macro FORTH_LOOP_TOS
2ebe e5				push hl 
2ebf			 
2ebf					if DEBUG_FORTH_WORDS_KEY 
2ebf						DMARK "LOP" 
2ebf f5				push af  
2ec0 3a d4 2e			ld a, (.dmark)  
2ec3 32 71 ee			ld (debug_mark),a  
2ec6 3a d5 2e			ld a, (.dmark+1)  
2ec9 32 72 ee			ld (debug_mark+1),a  
2ecc 3a d6 2e			ld a, (.dmark+2)  
2ecf 32 73 ee			ld (debug_mark+2),a  
2ed2 18 03			jr .pastdmark  
2ed4 ..			.dmark: db "LOP"  
2ed7 f1			.pastdmark: pop af  
2ed8			endm  
# End of macro DMARK
2ed8						CALLMONITOR 
2ed8 cd 6d 14			call break_point_state  
2edb				endm  
# End of macro CALLMONITOR
2edb					endif 
2edb				; next item on the stack is the limit. get it 
2edb			 
2edb			 
2edb				FORTH_LOOP_POP 
2edb cd 5f 1c			call macro_forth_loop_pop 
2ede				endm 
# End of macro FORTH_LOOP_POP
2ede			 
2ede				FORTH_LOOP_TOS 
2ede cd 55 1c			call macro_forth_loop_tos 
2ee1				endm 
# End of macro FORTH_LOOP_TOS
2ee1			 
2ee1 d1				pop de		 ; de = i, hl = limit 
2ee2			 
2ee2					if DEBUG_FORTH_WORDS 
2ee2						DMARK "LP1" 
2ee2 f5				push af  
2ee3 3a f7 2e			ld a, (.dmark)  
2ee6 32 71 ee			ld (debug_mark),a  
2ee9 3a f8 2e			ld a, (.dmark+1)  
2eec 32 72 ee			ld (debug_mark+1),a  
2eef 3a f9 2e			ld a, (.dmark+2)  
2ef2 32 73 ee			ld (debug_mark+2),a  
2ef5 18 03			jr .pastdmark  
2ef7 ..			.dmark: db "LP1"  
2efa f1			.pastdmark: pop af  
2efb			endm  
# End of macro DMARK
2efb						CALLMONITOR 
2efb cd 6d 14			call break_point_state  
2efe				endm  
# End of macro CALLMONITOR
2efe					endif 
2efe			 
2efe				; go back to previous word 
2efe			 
2efe d5				push de    ; save I for inc later 
2eff			 
2eff			 
2eff				; get limit 
2eff				;  is I at limit? 
2eff			 
2eff			 
2eff					if DEBUG_FORTH_WORDS 
2eff						DMARK "LP1" 
2eff f5				push af  
2f00 3a 14 2f			ld a, (.dmark)  
2f03 32 71 ee			ld (debug_mark),a  
2f06 3a 15 2f			ld a, (.dmark+1)  
2f09 32 72 ee			ld (debug_mark+1),a  
2f0c 3a 16 2f			ld a, (.dmark+2)  
2f0f 32 73 ee			ld (debug_mark+2),a  
2f12 18 03			jr .pastdmark  
2f14 ..			.dmark: db "LP1"  
2f17 f1			.pastdmark: pop af  
2f18			endm  
# End of macro DMARK
2f18						CALLMONITOR 
2f18 cd 6d 14			call break_point_state  
2f1b				endm  
# End of macro CALLMONITOR
2f1b					endif 
2f1b			 
2f1b ed 52			sbc hl, de 
2f1d			 
2f1d			 
2f1d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2f1d			 
2f1d 20 26				jr nz, .loopnotdone 
2f1f			 
2f1f e1				pop hl   ; get rid of saved I 
2f20				FORTH_LOOP_POP     ; get rid of limit 
2f20 cd 5f 1c			call macro_forth_loop_pop 
2f23				endm 
# End of macro FORTH_LOOP_POP
2f23			 
2f23				FORTH_RSP_POP     ; get rid of DO ptr 
2f23 cd c2 19			call macro_forth_rsp_pop 
2f26				endm 
# End of macro FORTH_RSP_POP
2f26			 
2f26			if DEBUG_FORTH_WORDS 
2f26						DMARK "LP>" 
2f26 f5				push af  
2f27 3a 3b 2f			ld a, (.dmark)  
2f2a 32 71 ee			ld (debug_mark),a  
2f2d 3a 3c 2f			ld a, (.dmark+1)  
2f30 32 72 ee			ld (debug_mark+1),a  
2f33 3a 3d 2f			ld a, (.dmark+2)  
2f36 32 73 ee			ld (debug_mark+2),a  
2f39 18 03			jr .pastdmark  
2f3b ..			.dmark: db "LP>"  
2f3e f1			.pastdmark: pop af  
2f3f			endm  
# End of macro DMARK
2f3f				CALLMONITOR 
2f3f cd 6d 14			call break_point_state  
2f42				endm  
# End of macro CALLMONITOR
2f42			endif 
2f42			 
2f42					NEXTW 
2f42 c3 63 1d			jp macro_next 
2f45				endm 
# End of macro NEXTW
2f45				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2f45			 
2f45			.loopnotdone: 
2f45			 
2f45 e1				pop hl    ; get I 
2f46 23				inc hl 
2f47			 
2f47			   	; save new I 
2f47			 
2f47			 
2f47					; set I counter 
2f47			 
2f47 22 7c e6				ld (os_current_i), hl 
2f4a			 
2f4a					if DEBUG_FORTH_WORDS 
2f4a						DMARK "LPN" 
2f4a f5				push af  
2f4b 3a 5f 2f			ld a, (.dmark)  
2f4e 32 71 ee			ld (debug_mark),a  
2f51 3a 60 2f			ld a, (.dmark+1)  
2f54 32 72 ee			ld (debug_mark+1),a  
2f57 3a 61 2f			ld a, (.dmark+2)  
2f5a 32 73 ee			ld (debug_mark+2),a  
2f5d 18 03			jr .pastdmark  
2f5f ..			.dmark: db "LPN"  
2f62 f1			.pastdmark: pop af  
2f63			endm  
# End of macro DMARK
2f63					CALLMONITOR 
2f63 cd 6d 14			call break_point_state  
2f66				endm  
# End of macro CALLMONITOR
2f66					endif 
2f66					 
2f66				FORTH_LOOP_NEXT 
2f66 cd 22 1c			call macro_forth_loop_next 
2f69				endm 
# End of macro FORTH_LOOP_NEXT
2f69			 
2f69			 
2f69					if DEBUG_FORTH_WORDS 
2f69 eb						ex de,hl 
2f6a					endif 
2f6a			 
2f6a			;	; get DO ptr 
2f6a			; 
2f6a					if DEBUG_FORTH_WORDS 
2f6a						DMARK "LP7" 
2f6a f5				push af  
2f6b 3a 7f 2f			ld a, (.dmark)  
2f6e 32 71 ee			ld (debug_mark),a  
2f71 3a 80 2f			ld a, (.dmark+1)  
2f74 32 72 ee			ld (debug_mark+1),a  
2f77 3a 81 2f			ld a, (.dmark+2)  
2f7a 32 73 ee			ld (debug_mark+2),a  
2f7d 18 03			jr .pastdmark  
2f7f ..			.dmark: db "LP7"  
2f82 f1			.pastdmark: pop af  
2f83			endm  
# End of macro DMARK
2f83					CALLMONITOR 
2f83 cd 6d 14			call break_point_state  
2f86				endm  
# End of macro CALLMONITOR
2f86					endif 
2f86				FORTH_RSP_TOS 
2f86 cd b8 19			call macro_forth_rsp_tos 
2f89				endm 
# End of macro FORTH_RSP_TOS
2f89			 
2f89					if DEBUG_FORTH_WORDS 
2f89						DMARK "LP8" 
2f89 f5				push af  
2f8a 3a 9e 2f			ld a, (.dmark)  
2f8d 32 71 ee			ld (debug_mark),a  
2f90 3a 9f 2f			ld a, (.dmark+1)  
2f93 32 72 ee			ld (debug_mark+1),a  
2f96 3a a0 2f			ld a, (.dmark+2)  
2f99 32 73 ee			ld (debug_mark+2),a  
2f9c 18 03			jr .pastdmark  
2f9e ..			.dmark: db "LP8"  
2fa1 f1			.pastdmark: pop af  
2fa2			endm  
# End of macro DMARK
2fa2					CALLMONITOR 
2fa2 cd 6d 14			call break_point_state  
2fa5				endm  
# End of macro CALLMONITOR
2fa5					endif 
2fa5				;push hl 
2fa5			 
2fa5				; not going to DO any more 
2fa5				; get rid of the RSP pointer as DO will add it back in 
2fa5				;FORTH_RSP_POP 
2fa5				;pop hl 
2fa5			 
2fa5				;ld hl,(cli_ret_sp) 
2fa5				;ld e, (hl) 
2fa5				;inc hl 
2fa5				;ld d, (hl) 
2fa5				;ex de,hl 
2fa5 22 58 e6			ld (os_tok_ptr), hl 
2fa8					if DEBUG_FORTH_WORDS 
2fa8						DMARK "LP<" 
2fa8 f5				push af  
2fa9 3a bd 2f			ld a, (.dmark)  
2fac 32 71 ee			ld (debug_mark),a  
2faf 3a be 2f			ld a, (.dmark+1)  
2fb2 32 72 ee			ld (debug_mark+1),a  
2fb5 3a bf 2f			ld a, (.dmark+2)  
2fb8 32 73 ee			ld (debug_mark+2),a  
2fbb 18 03			jr .pastdmark  
2fbd ..			.dmark: db "LP<"  
2fc0 f1			.pastdmark: pop af  
2fc1			endm  
# End of macro DMARK
2fc1					CALLMONITOR 
2fc1 cd 6d 14			call break_point_state  
2fc4				endm  
# End of macro CALLMONITOR
2fc4				endif 
2fc4 c3 f4 1d			jp exec1 
2fc7			 
2fc7					 
2fc7			 
2fc7			 
2fc7					NEXTW 
2fc7 c3 63 1d			jp macro_next 
2fca				endm 
# End of macro NEXTW
2fca			.I:  
2fca			 
2fca				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2fca 5e				db WORD_SYS_CORE+74             
2fcb f5 2f			dw .DLOOP            
2fcd 02				db 1 + 1 
2fce .. 00			db "I",0              
2fd0				endm 
# End of macro CWHEAD
2fd0			; | I ( -- ) Current loop counter | DONE 
2fd0					if DEBUG_FORTH_WORDS_KEY 
2fd0						DMARK "I.." 
2fd0 f5				push af  
2fd1 3a e5 2f			ld a, (.dmark)  
2fd4 32 71 ee			ld (debug_mark),a  
2fd7 3a e6 2f			ld a, (.dmark+1)  
2fda 32 72 ee			ld (debug_mark+1),a  
2fdd 3a e7 2f			ld a, (.dmark+2)  
2fe0 32 73 ee			ld (debug_mark+2),a  
2fe3 18 03			jr .pastdmark  
2fe5 ..			.dmark: db "I.."  
2fe8 f1			.pastdmark: pop af  
2fe9			endm  
# End of macro DMARK
2fe9						CALLMONITOR 
2fe9 cd 6d 14			call break_point_state  
2fec				endm  
# End of macro CALLMONITOR
2fec					endif 
2fec			 
2fec 2a 7c e6				ld hl,(os_current_i) 
2fef cd fa 19				call forth_push_numhl 
2ff2			 
2ff2					NEXTW 
2ff2 c3 63 1d			jp macro_next 
2ff5				endm 
# End of macro NEXTW
2ff5			.DLOOP: 
2ff5				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2ff5 5f				db WORD_SYS_CORE+75             
2ff6 d6 30			dw .REPEAT            
2ff8 06				db 5 + 1 
2ff9 .. 00			db "-LOOP",0              
2fff				endm 
# End of macro CWHEAD
2fff			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2fff				; pop tos as current loop count to hl 
2fff					if DEBUG_FORTH_WORDS_KEY 
2fff						DMARK "-LP" 
2fff f5				push af  
3000 3a 14 30			ld a, (.dmark)  
3003 32 71 ee			ld (debug_mark),a  
3006 3a 15 30			ld a, (.dmark+1)  
3009 32 72 ee			ld (debug_mark+1),a  
300c 3a 16 30			ld a, (.dmark+2)  
300f 32 73 ee			ld (debug_mark+2),a  
3012 18 03			jr .pastdmark  
3014 ..			.dmark: db "-LP"  
3017 f1			.pastdmark: pop af  
3018			endm  
# End of macro DMARK
3018						CALLMONITOR 
3018 cd 6d 14			call break_point_state  
301b				endm  
# End of macro CALLMONITOR
301b					endif 
301b			 
301b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
301b			 
301b				FORTH_LOOP_TOS 
301b cd 55 1c			call macro_forth_loop_tos 
301e				endm 
# End of macro FORTH_LOOP_TOS
301e e5				push hl 
301f			 
301f					if DEBUG_FORTH_WORDS 
301f						DMARK "-LP" 
301f f5				push af  
3020 3a 34 30			ld a, (.dmark)  
3023 32 71 ee			ld (debug_mark),a  
3026 3a 35 30			ld a, (.dmark+1)  
3029 32 72 ee			ld (debug_mark+1),a  
302c 3a 36 30			ld a, (.dmark+2)  
302f 32 73 ee			ld (debug_mark+2),a  
3032 18 03			jr .pastdmark  
3034 ..			.dmark: db "-LP"  
3037 f1			.pastdmark: pop af  
3038			endm  
# End of macro DMARK
3038						CALLMONITOR 
3038 cd 6d 14			call break_point_state  
303b				endm  
# End of macro CALLMONITOR
303b					endif 
303b				; next item on the stack is the limit. get it 
303b			 
303b			 
303b				FORTH_LOOP_POP 
303b cd 5f 1c			call macro_forth_loop_pop 
303e				endm 
# End of macro FORTH_LOOP_POP
303e			 
303e				FORTH_LOOP_TOS 
303e cd 55 1c			call macro_forth_loop_tos 
3041				endm 
# End of macro FORTH_LOOP_TOS
3041			 
3041 d1				pop de		 ; de = i, hl = limit 
3042			 
3042					if DEBUG_FORTH_WORDS 
3042						DMARK "-L1" 
3042 f5				push af  
3043 3a 57 30			ld a, (.dmark)  
3046 32 71 ee			ld (debug_mark),a  
3049 3a 58 30			ld a, (.dmark+1)  
304c 32 72 ee			ld (debug_mark+1),a  
304f 3a 59 30			ld a, (.dmark+2)  
3052 32 73 ee			ld (debug_mark+2),a  
3055 18 03			jr .pastdmark  
3057 ..			.dmark: db "-L1"  
305a f1			.pastdmark: pop af  
305b			endm  
# End of macro DMARK
305b						CALLMONITOR 
305b cd 6d 14			call break_point_state  
305e				endm  
# End of macro CALLMONITOR
305e					endif 
305e			 
305e				; go back to previous word 
305e			 
305e d5				push de    ; save I for inc later 
305f			 
305f			 
305f				; get limit 
305f				;  is I at limit? 
305f			 
305f			 
305f					if DEBUG_FORTH_WORDS 
305f						DMARK "-L1" 
305f f5				push af  
3060 3a 74 30			ld a, (.dmark)  
3063 32 71 ee			ld (debug_mark),a  
3066 3a 75 30			ld a, (.dmark+1)  
3069 32 72 ee			ld (debug_mark+1),a  
306c 3a 76 30			ld a, (.dmark+2)  
306f 32 73 ee			ld (debug_mark+2),a  
3072 18 03			jr .pastdmark  
3074 ..			.dmark: db "-L1"  
3077 f1			.pastdmark: pop af  
3078			endm  
# End of macro DMARK
3078						CALLMONITOR 
3078 cd 6d 14			call break_point_state  
307b				endm  
# End of macro CALLMONITOR
307b					endif 
307b			 
307b ed 52			sbc hl, de 
307d			 
307d			 
307d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
307d			 
307d 20 26				jr nz, .mloopnotdone 
307f			 
307f e1				pop hl   ; get rid of saved I 
3080				FORTH_LOOP_POP     ; get rid of limit 
3080 cd 5f 1c			call macro_forth_loop_pop 
3083				endm 
# End of macro FORTH_LOOP_POP
3083			 
3083				FORTH_RSP_POP     ; get rid of DO ptr 
3083 cd c2 19			call macro_forth_rsp_pop 
3086				endm 
# End of macro FORTH_RSP_POP
3086			 
3086			if DEBUG_FORTH_WORDS 
3086						DMARK "-L>" 
3086 f5				push af  
3087 3a 9b 30			ld a, (.dmark)  
308a 32 71 ee			ld (debug_mark),a  
308d 3a 9c 30			ld a, (.dmark+1)  
3090 32 72 ee			ld (debug_mark+1),a  
3093 3a 9d 30			ld a, (.dmark+2)  
3096 32 73 ee			ld (debug_mark+2),a  
3099 18 03			jr .pastdmark  
309b ..			.dmark: db "-L>"  
309e f1			.pastdmark: pop af  
309f			endm  
# End of macro DMARK
309f				CALLMONITOR 
309f cd 6d 14			call break_point_state  
30a2				endm  
# End of macro CALLMONITOR
30a2			endif 
30a2			 
30a2					NEXTW 
30a2 c3 63 1d			jp macro_next 
30a5				endm 
# End of macro NEXTW
30a5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
30a5			 
30a5			.mloopnotdone: 
30a5			 
30a5 e1				pop hl    ; get I 
30a6 2b				dec hl 
30a7			 
30a7			   	; save new I 
30a7			 
30a7			 
30a7					; set I counter 
30a7			 
30a7 22 7c e6				ld (os_current_i), hl 
30aa			 
30aa					 
30aa				FORTH_LOOP_NEXT 
30aa cd 22 1c			call macro_forth_loop_next 
30ad				endm 
# End of macro FORTH_LOOP_NEXT
30ad			 
30ad			 
30ad					if DEBUG_FORTH_WORDS 
30ad eb						ex de,hl 
30ae					endif 
30ae			 
30ae			;	; get DO ptr 
30ae			; 
30ae				FORTH_RSP_TOS 
30ae cd b8 19			call macro_forth_rsp_tos 
30b1				endm 
# End of macro FORTH_RSP_TOS
30b1			 
30b1				;push hl 
30b1			 
30b1				; not going to DO any more 
30b1				; get rid of the RSP pointer as DO will add it back in 
30b1				;FORTH_RSP_POP 
30b1				;pop hl 
30b1			 
30b1			 
30b1 22 58 e6			ld (os_tok_ptr), hl 
30b4					if DEBUG_FORTH_WORDS 
30b4						DMARK "-L<" 
30b4 f5				push af  
30b5 3a c9 30			ld a, (.dmark)  
30b8 32 71 ee			ld (debug_mark),a  
30bb 3a ca 30			ld a, (.dmark+1)  
30be 32 72 ee			ld (debug_mark+1),a  
30c1 3a cb 30			ld a, (.dmark+2)  
30c4 32 73 ee			ld (debug_mark+2),a  
30c7 18 03			jr .pastdmark  
30c9 ..			.dmark: db "-L<"  
30cc f1			.pastdmark: pop af  
30cd			endm  
# End of macro DMARK
30cd					CALLMONITOR 
30cd cd 6d 14			call break_point_state  
30d0				endm  
# End of macro CALLMONITOR
30d0				endif 
30d0 c3 f4 1d			jp exec1 
30d3			 
30d3					 
30d3			 
30d3			 
30d3			 
30d3				NEXTW 
30d3 c3 63 1d			jp macro_next 
30d6				endm 
# End of macro NEXTW
30d6			 
30d6			 
30d6			 
30d6			 
30d6			.REPEAT: 
30d6				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
30d6 71				db WORD_SYS_CORE+93             
30d7 29 31			dw .UNTIL            
30d9 06				db 5 + 1 
30da .. 00			db "REPEAT",0              
30e1				endm 
# End of macro CWHEAD
30e1			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
30e1			;  push pc to rsp stack past the REPEAT 
30e1					if DEBUG_FORTH_WORDS_KEY 
30e1						DMARK "REP" 
30e1 f5				push af  
30e2 3a f6 30			ld a, (.dmark)  
30e5 32 71 ee			ld (debug_mark),a  
30e8 3a f7 30			ld a, (.dmark+1)  
30eb 32 72 ee			ld (debug_mark+1),a  
30ee 3a f8 30			ld a, (.dmark+2)  
30f1 32 73 ee			ld (debug_mark+2),a  
30f4 18 03			jr .pastdmark  
30f6 ..			.dmark: db "REP"  
30f9 f1			.pastdmark: pop af  
30fa			endm  
# End of macro DMARK
30fa						CALLMONITOR 
30fa cd 6d 14			call break_point_state  
30fd				endm  
# End of macro CALLMONITOR
30fd					endif 
30fd			 
30fd 2a 58 e6				ld hl, (os_tok_ptr) 
3100 23					inc hl   ; R 
3101 23					inc hl  ; E 
3102 23					inc hl   ; P 
3103 23					inc hl   ; E 
3104 23					inc hl   ; A 
3105 23					inc hl   ; T 
3106 23					inc hl   ; zero 
3107					FORTH_RSP_NEXT 
3107 cd a1 19			call macro_forth_rsp_next 
310a				endm 
# End of macro FORTH_RSP_NEXT
310a			 
310a			 
310a					if DEBUG_FORTH_WORDS 
310a						DMARK "REP" 
310a f5				push af  
310b 3a 1f 31			ld a, (.dmark)  
310e 32 71 ee			ld (debug_mark),a  
3111 3a 20 31			ld a, (.dmark+1)  
3114 32 72 ee			ld (debug_mark+1),a  
3117 3a 21 31			ld a, (.dmark+2)  
311a 32 73 ee			ld (debug_mark+2),a  
311d 18 03			jr .pastdmark  
311f ..			.dmark: db "REP"  
3122 f1			.pastdmark: pop af  
3123			endm  
# End of macro DMARK
3123						;pop bc    ; TODO BUG ?????? what is this for???? 
3123						CALLMONITOR 
3123 cd 6d 14			call break_point_state  
3126				endm  
# End of macro CALLMONITOR
3126					endif 
3126			 
3126					NEXTW 
3126 c3 63 1d			jp macro_next 
3129				endm 
# End of macro NEXTW
3129			;	       NEXTW 
3129			 
3129			.UNTIL: 
3129				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3129 72				db WORD_SYS_CORE+94             
312a c0 31			dw .ENDFLOW            
312c 06				db 5 + 1 
312d .. 00			db "UNTIL",0              
3133				endm 
# End of macro CWHEAD
3133			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3133			 
3133				; pop tos as check 
3133			 
3133				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3133			 
3133				FORTH_DSP_VALUEHL 
3133 cd f1 1b			call macro_dsp_valuehl 
3136				endm 
# End of macro FORTH_DSP_VALUEHL
3136			 
3136					if DEBUG_FORTH_WORDS_KEY 
3136						DMARK "UNT" 
3136 f5				push af  
3137 3a 4b 31			ld a, (.dmark)  
313a 32 71 ee			ld (debug_mark),a  
313d 3a 4c 31			ld a, (.dmark+1)  
3140 32 72 ee			ld (debug_mark+1),a  
3143 3a 4d 31			ld a, (.dmark+2)  
3146 32 73 ee			ld (debug_mark+2),a  
3149 18 03			jr .pastdmark  
314b ..			.dmark: db "UNT"  
314e f1			.pastdmark: pop af  
314f			endm  
# End of macro DMARK
314f						CALLMONITOR 
314f cd 6d 14			call break_point_state  
3152				endm  
# End of macro CALLMONITOR
3152					endif 
3152			 
3152			;	push hl 
3152				FORTH_DSP_POP 
3152 cd a9 1c			call macro_forth_dsp_pop 
3155				endm 
# End of macro FORTH_DSP_POP
3155			 
3155			;	pop hl 
3155			 
3155				; test if true 
3155			 
3155 cd ed 0b			call ishlzero 
3158			;	ld a,l 
3158			;	add h 
3158			; 
3158			;	cp 0 
3158			 
3158 20 3e			jr nz, .untilnotdone 
315a			 
315a					if DEBUG_FORTH_WORDS 
315a						DMARK "UNf" 
315a f5				push af  
315b 3a 6f 31			ld a, (.dmark)  
315e 32 71 ee			ld (debug_mark),a  
3161 3a 70 31			ld a, (.dmark+1)  
3164 32 72 ee			ld (debug_mark+1),a  
3167 3a 71 31			ld a, (.dmark+2)  
316a 32 73 ee			ld (debug_mark+2),a  
316d 18 03			jr .pastdmark  
316f ..			.dmark: db "UNf"  
3172 f1			.pastdmark: pop af  
3173			endm  
# End of macro DMARK
3173						CALLMONITOR 
3173 cd 6d 14			call break_point_state  
3176				endm  
# End of macro CALLMONITOR
3176					endif 
3176			 
3176			 
3176			 
3176				FORTH_RSP_POP     ; get rid of DO ptr 
3176 cd c2 19			call macro_forth_rsp_pop 
3179				endm 
# End of macro FORTH_RSP_POP
3179			 
3179			if DEBUG_FORTH_WORDS 
3179						DMARK "UN>" 
3179 f5				push af  
317a 3a 8e 31			ld a, (.dmark)  
317d 32 71 ee			ld (debug_mark),a  
3180 3a 8f 31			ld a, (.dmark+1)  
3183 32 72 ee			ld (debug_mark+1),a  
3186 3a 90 31			ld a, (.dmark+2)  
3189 32 73 ee			ld (debug_mark+2),a  
318c 18 03			jr .pastdmark  
318e ..			.dmark: db "UN>"  
3191 f1			.pastdmark: pop af  
3192			endm  
# End of macro DMARK
3192				CALLMONITOR 
3192 cd 6d 14			call break_point_state  
3195				endm  
# End of macro CALLMONITOR
3195			endif 
3195			 
3195					NEXTW 
3195 c3 63 1d			jp macro_next 
3198				endm 
# End of macro NEXTW
3198				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3198			 
3198			.untilnotdone: 
3198			 
3198			 
3198			;	; get DO ptr 
3198			; 
3198				FORTH_RSP_TOS 
3198 cd b8 19			call macro_forth_rsp_tos 
319b				endm 
# End of macro FORTH_RSP_TOS
319b			 
319b				;push hl 
319b			 
319b				; not going to DO any more 
319b				; get rid of the RSP pointer as DO will add it back in 
319b				;FORTH_RSP_POP 
319b				;pop hl 
319b			 
319b			 
319b 22 58 e6			ld (os_tok_ptr), hl 
319e					if DEBUG_FORTH_WORDS 
319e						DMARK "UN<" 
319e f5				push af  
319f 3a b3 31			ld a, (.dmark)  
31a2 32 71 ee			ld (debug_mark),a  
31a5 3a b4 31			ld a, (.dmark+1)  
31a8 32 72 ee			ld (debug_mark+1),a  
31ab 3a b5 31			ld a, (.dmark+2)  
31ae 32 73 ee			ld (debug_mark+2),a  
31b1 18 03			jr .pastdmark  
31b3 ..			.dmark: db "UN<"  
31b6 f1			.pastdmark: pop af  
31b7			endm  
# End of macro DMARK
31b7					CALLMONITOR 
31b7 cd 6d 14			call break_point_state  
31ba				endm  
# End of macro CALLMONITOR
31ba				endif 
31ba c3 f4 1d			jp exec1 
31bd			 
31bd					 
31bd			 
31bd			 
31bd					NEXTW 
31bd c3 63 1d			jp macro_next 
31c0				endm 
# End of macro NEXTW
31c0			 
31c0			 
31c0			.ENDFLOW: 
31c0			 
31c0			; eof 
31c0			 
# End of file forth_words_flow.asm
31c0			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
31c0			include "forth_words_logic.asm" 
31c0			 
31c0			; | ## Logic Words 
31c0			 
31c0			.NOT: 
31c0				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
31c0 2d				db WORD_SYS_CORE+25             
31c1 08 32			dw .IS            
31c3 04				db 3 + 1 
31c4 .. 00			db "NOT",0              
31c8				endm 
# End of macro CWHEAD
31c8			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
31c8					if DEBUG_FORTH_WORDS_KEY 
31c8						DMARK "NOT" 
31c8 f5				push af  
31c9 3a dd 31			ld a, (.dmark)  
31cc 32 71 ee			ld (debug_mark),a  
31cf 3a de 31			ld a, (.dmark+1)  
31d2 32 72 ee			ld (debug_mark+1),a  
31d5 3a df 31			ld a, (.dmark+2)  
31d8 32 73 ee			ld (debug_mark+2),a  
31db 18 03			jr .pastdmark  
31dd ..			.dmark: db "NOT"  
31e0 f1			.pastdmark: pop af  
31e1			endm  
# End of macro DMARK
31e1						CALLMONITOR 
31e1 cd 6d 14			call break_point_state  
31e4				endm  
# End of macro CALLMONITOR
31e4					endif 
31e4					FORTH_DSP 
31e4 cd b7 1b			call macro_forth_dsp 
31e7				endm 
# End of macro FORTH_DSP
31e7 7e					ld a,(hl)	; get type of value on TOS 
31e8 fe 02				cp DS_TYPE_INUM  
31ea 28 03				jr z, .noti 
31ec					NEXTW 
31ec c3 63 1d			jp macro_next 
31ef				endm 
# End of macro NEXTW
31ef			.noti:          FORTH_DSP_VALUEHL 
31ef cd f1 1b			call macro_dsp_valuehl 
31f2				endm 
# End of macro FORTH_DSP_VALUEHL
31f2			;		push hl 
31f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31f2 cd a9 1c			call macro_forth_dsp_pop 
31f5				endm 
# End of macro FORTH_DSP_POP
31f5			;		pop hl 
31f5 3e 00				ld a,0 
31f7 bd					cp l 
31f8 28 04				jr z, .not2t 
31fa 2e 00				ld l, 0 
31fc 18 02				jr .notip 
31fe			 
31fe 2e ff		.not2t:		ld l, 255 
3200			 
3200 26 00		.notip:		ld h, 0	 
3202			 
3202 cd fa 19				call forth_push_numhl 
3205					NEXTW 
3205 c3 63 1d			jp macro_next 
3208				endm 
# End of macro NEXTW
3208			 
3208			.IS: 
3208				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3208 2d				db WORD_SYS_CORE+25             
3209 2e 32			dw .LZERO            
320b 03				db 2 + 1 
320c .. 00			db "IS",0              
320f				endm 
# End of macro CWHEAD
320f			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
320f					if DEBUG_FORTH_WORDS_KEY 
320f						DMARK "IS." 
320f f5				push af  
3210 3a 24 32			ld a, (.dmark)  
3213 32 71 ee			ld (debug_mark),a  
3216 3a 25 32			ld a, (.dmark+1)  
3219 32 72 ee			ld (debug_mark+1),a  
321c 3a 26 32			ld a, (.dmark+2)  
321f 32 73 ee			ld (debug_mark+2),a  
3222 18 03			jr .pastdmark  
3224 ..			.dmark: db "IS."  
3227 f1			.pastdmark: pop af  
3228			endm  
# End of macro DMARK
3228						CALLMONITOR 
3228 cd 6d 14			call break_point_state  
322b				endm  
# End of macro CALLMONITOR
322b					endif 
322b					NEXTW 
322b c3 63 1d			jp macro_next 
322e				endm 
# End of macro NEXTW
322e			.LZERO: 
322e				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
322e 2d				db WORD_SYS_CORE+25             
322f 38 32			dw .TZERO            
3231 03				db 2 + 1 
3232 .. 00			db "0<",0              
3235				endm 
# End of macro CWHEAD
3235			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3235					NEXTW 
3235 c3 63 1d			jp macro_next 
3238				endm 
# End of macro NEXTW
3238			.TZERO: 
3238				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3238 2e				db WORD_SYS_CORE+26             
3239 7f 32			dw .LESS            
323b 03				db 2 + 1 
323c .. 00			db "0=",0              
323f				endm 
# End of macro CWHEAD
323f			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
323f				; TODO add floating point number detection 
323f					;v5 FORTH_DSP_VALUE 
323f					if DEBUG_FORTH_WORDS_KEY 
323f						DMARK "0=." 
323f f5				push af  
3240 3a 54 32			ld a, (.dmark)  
3243 32 71 ee			ld (debug_mark),a  
3246 3a 55 32			ld a, (.dmark+1)  
3249 32 72 ee			ld (debug_mark+1),a  
324c 3a 56 32			ld a, (.dmark+2)  
324f 32 73 ee			ld (debug_mark+2),a  
3252 18 03			jr .pastdmark  
3254 ..			.dmark: db "0=."  
3257 f1			.pastdmark: pop af  
3258			endm  
# End of macro DMARK
3258						CALLMONITOR 
3258 cd 6d 14			call break_point_state  
325b				endm  
# End of macro CALLMONITOR
325b					endif 
325b					FORTH_DSP 
325b cd b7 1b			call macro_forth_dsp 
325e				endm 
# End of macro FORTH_DSP
325e 7e					ld a,(hl)	; get type of value on TOS 
325f fe 02				cp DS_TYPE_INUM  
3261 28 00				jr z, .tz_inum 
3263			 
3263				if FORTH_ENABLE_FLOATMATH 
3263					jr .tz_done 
3263			 
3263				endif 
3263					 
3263			 
3263			.tz_inum: 
3263					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3263 cd f1 1b			call macro_dsp_valuehl 
3266				endm 
# End of macro FORTH_DSP_VALUEHL
3266			 
3266			;		push hl 
3266			 
3266					; destroy value TOS 
3266			 
3266					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3266 cd a9 1c			call macro_forth_dsp_pop 
3269				endm 
# End of macro FORTH_DSP_POP
3269			 
3269			;		pop hl 
3269			 
3269 3e 00				ld a,0 
326b			 
326b bd					cp l 
326c 20 08				jr nz, .tz_notzero 
326e			 
326e bc					cp h 
326f			 
326f 20 05				jr nz, .tz_notzero 
3271			 
3271			 
3271 21 01 00				ld hl, FORTH_TRUE 
3274 18 03				jr .tz_done 
3276			 
3276 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3279			 
3279					; push value back onto stack for another op etc 
3279			 
3279			.tz_done: 
3279 cd fa 19				call forth_push_numhl 
327c			 
327c					NEXTW 
327c c3 63 1d			jp macro_next 
327f				endm 
# End of macro NEXTW
327f			.LESS: 
327f				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
327f 2f				db WORD_SYS_CORE+27             
3280 e8 32			dw .GT            
3282 02				db 1 + 1 
3283 .. 00			db "<",0              
3285				endm 
# End of macro CWHEAD
3285			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3285				; TODO add floating point number detection 
3285					if DEBUG_FORTH_WORDS_KEY 
3285						DMARK "LES" 
3285 f5				push af  
3286 3a 9a 32			ld a, (.dmark)  
3289 32 71 ee			ld (debug_mark),a  
328c 3a 9b 32			ld a, (.dmark+1)  
328f 32 72 ee			ld (debug_mark+1),a  
3292 3a 9c 32			ld a, (.dmark+2)  
3295 32 73 ee			ld (debug_mark+2),a  
3298 18 03			jr .pastdmark  
329a ..			.dmark: db "LES"  
329d f1			.pastdmark: pop af  
329e			endm  
# End of macro DMARK
329e						CALLMONITOR 
329e cd 6d 14			call break_point_state  
32a1				endm  
# End of macro CALLMONITOR
32a1					endif 
32a1					FORTH_DSP 
32a1 cd b7 1b			call macro_forth_dsp 
32a4				endm 
# End of macro FORTH_DSP
32a4					;v5 FORTH_DSP_VALUE 
32a4 7e					ld a,(hl)	; get type of value on TOS 
32a5 fe 02				cp DS_TYPE_INUM  
32a7 28 00				jr z, .less_inum 
32a9			 
32a9				if FORTH_ENABLE_FLOATMATH 
32a9					jr .less_done 
32a9			 
32a9				endif 
32a9					 
32a9			 
32a9			.less_inum: 
32a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32a9 cd f1 1b			call macro_dsp_valuehl 
32ac				endm 
# End of macro FORTH_DSP_VALUEHL
32ac			 
32ac e5					push hl  ; u2 
32ad			 
32ad					; destroy value TOS 
32ad			 
32ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32ad cd a9 1c			call macro_forth_dsp_pop 
32b0				endm 
# End of macro FORTH_DSP_POP
32b0			 
32b0			 
32b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32b0 cd f1 1b			call macro_dsp_valuehl 
32b3				endm 
# End of macro FORTH_DSP_VALUEHL
32b3			 
32b3 e5					push hl    ; u1 
32b4			 
32b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32b4 cd a9 1c			call macro_forth_dsp_pop 
32b7				endm 
# End of macro FORTH_DSP_POP
32b7			 
32b7			 
32b7 b7			 or a      ;clear carry flag 
32b8 01 00 00		 ld bc, FORTH_FALSE 
32bb e1			  pop hl    ; u1 
32bc d1			  pop de    ; u2 
32bd ed 52		  sbc hl,de 
32bf 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
32c1			 
32c1 01 01 00		 ld bc, FORTH_TRUE 
32c4			.lscont:  
32c4 c5					push bc 
32c5 e1					pop hl 
32c6			 
32c6					if DEBUG_FORTH_WORDS 
32c6						DMARK "LT1" 
32c6 f5				push af  
32c7 3a db 32			ld a, (.dmark)  
32ca 32 71 ee			ld (debug_mark),a  
32cd 3a dc 32			ld a, (.dmark+1)  
32d0 32 72 ee			ld (debug_mark+1),a  
32d3 3a dd 32			ld a, (.dmark+2)  
32d6 32 73 ee			ld (debug_mark+2),a  
32d9 18 03			jr .pastdmark  
32db ..			.dmark: db "LT1"  
32de f1			.pastdmark: pop af  
32df			endm  
# End of macro DMARK
32df						CALLMONITOR 
32df cd 6d 14			call break_point_state  
32e2				endm  
# End of macro CALLMONITOR
32e2					endif 
32e2 cd fa 19				call forth_push_numhl 
32e5			 
32e5					NEXTW 
32e5 c3 63 1d			jp macro_next 
32e8				endm 
# End of macro NEXTW
32e8			.GT: 
32e8				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
32e8 30				db WORD_SYS_CORE+28             
32e9 51 33			dw .EQUAL            
32eb 02				db 1 + 1 
32ec .. 00			db ">",0              
32ee				endm 
# End of macro CWHEAD
32ee			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
32ee				; TODO add floating point number detection 
32ee					if DEBUG_FORTH_WORDS_KEY 
32ee						DMARK "GRT" 
32ee f5				push af  
32ef 3a 03 33			ld a, (.dmark)  
32f2 32 71 ee			ld (debug_mark),a  
32f5 3a 04 33			ld a, (.dmark+1)  
32f8 32 72 ee			ld (debug_mark+1),a  
32fb 3a 05 33			ld a, (.dmark+2)  
32fe 32 73 ee			ld (debug_mark+2),a  
3301 18 03			jr .pastdmark  
3303 ..			.dmark: db "GRT"  
3306 f1			.pastdmark: pop af  
3307			endm  
# End of macro DMARK
3307						CALLMONITOR 
3307 cd 6d 14			call break_point_state  
330a				endm  
# End of macro CALLMONITOR
330a					endif 
330a					FORTH_DSP 
330a cd b7 1b			call macro_forth_dsp 
330d				endm 
# End of macro FORTH_DSP
330d					;FORTH_DSP_VALUE 
330d 7e					ld a,(hl)	; get type of value on TOS 
330e fe 02				cp DS_TYPE_INUM  
3310 28 00				jr z, .gt_inum 
3312			 
3312				if FORTH_ENABLE_FLOATMATH 
3312					jr .gt_done 
3312			 
3312				endif 
3312					 
3312			 
3312			.gt_inum: 
3312					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3312 cd f1 1b			call macro_dsp_valuehl 
3315				endm 
# End of macro FORTH_DSP_VALUEHL
3315			 
3315 e5					push hl  ; u2 
3316			 
3316					; destroy value TOS 
3316			 
3316					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3316 cd a9 1c			call macro_forth_dsp_pop 
3319				endm 
# End of macro FORTH_DSP_POP
3319			 
3319			 
3319					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3319 cd f1 1b			call macro_dsp_valuehl 
331c				endm 
# End of macro FORTH_DSP_VALUEHL
331c			 
331c e5					push hl    ; u1 
331d			 
331d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
331d cd a9 1c			call macro_forth_dsp_pop 
3320				endm 
# End of macro FORTH_DSP_POP
3320			 
3320			 
3320 b7			 or a      ;clear carry flag 
3321 01 00 00		 ld bc, FORTH_FALSE 
3324 e1			  pop hl    ; u1 
3325 d1			  pop de    ; u2 
3326 ed 52		  sbc hl,de 
3328 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
332a			 
332a 01 01 00		 ld bc, FORTH_TRUE 
332d			.gtcont:  
332d c5					push bc 
332e e1					pop hl 
332f			 
332f					if DEBUG_FORTH_WORDS 
332f						DMARK "GT1" 
332f f5				push af  
3330 3a 44 33			ld a, (.dmark)  
3333 32 71 ee			ld (debug_mark),a  
3336 3a 45 33			ld a, (.dmark+1)  
3339 32 72 ee			ld (debug_mark+1),a  
333c 3a 46 33			ld a, (.dmark+2)  
333f 32 73 ee			ld (debug_mark+2),a  
3342 18 03			jr .pastdmark  
3344 ..			.dmark: db "GT1"  
3347 f1			.pastdmark: pop af  
3348			endm  
# End of macro DMARK
3348						CALLMONITOR 
3348 cd 6d 14			call break_point_state  
334b				endm  
# End of macro CALLMONITOR
334b					endif 
334b cd fa 19				call forth_push_numhl 
334e			 
334e					NEXTW 
334e c3 63 1d			jp macro_next 
3351				endm 
# End of macro NEXTW
3351			.EQUAL: 
3351				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3351 31				db WORD_SYS_CORE+29             
3352 bc 33			dw .ENDLOGIC            
3354 02				db 1 + 1 
3355 .. 00			db "=",0              
3357				endm 
# End of macro CWHEAD
3357			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3357				; TODO add floating point number detection 
3357					if DEBUG_FORTH_WORDS_KEY 
3357						DMARK "EQ." 
3357 f5				push af  
3358 3a 6c 33			ld a, (.dmark)  
335b 32 71 ee			ld (debug_mark),a  
335e 3a 6d 33			ld a, (.dmark+1)  
3361 32 72 ee			ld (debug_mark+1),a  
3364 3a 6e 33			ld a, (.dmark+2)  
3367 32 73 ee			ld (debug_mark+2),a  
336a 18 03			jr .pastdmark  
336c ..			.dmark: db "EQ."  
336f f1			.pastdmark: pop af  
3370			endm  
# End of macro DMARK
3370						CALLMONITOR 
3370 cd 6d 14			call break_point_state  
3373				endm  
# End of macro CALLMONITOR
3373					endif 
3373					FORTH_DSP 
3373 cd b7 1b			call macro_forth_dsp 
3376				endm 
# End of macro FORTH_DSP
3376					;v5 FORTH_DSP_VALUE 
3376 7e					ld a,(hl)	; get type of value on TOS 
3377 fe 02				cp DS_TYPE_INUM  
3379 28 00				jr z, .eq_inum 
337b			 
337b				if FORTH_ENABLE_FLOATMATH 
337b					jr .eq_done 
337b			 
337b				endif 
337b					 
337b			 
337b			.eq_inum: 
337b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
337b cd f1 1b			call macro_dsp_valuehl 
337e				endm 
# End of macro FORTH_DSP_VALUEHL
337e			 
337e e5					push hl 
337f			 
337f					; destroy value TOS 
337f			 
337f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
337f cd a9 1c			call macro_forth_dsp_pop 
3382				endm 
# End of macro FORTH_DSP_POP
3382			 
3382			 
3382					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3382 cd f1 1b			call macro_dsp_valuehl 
3385				endm 
# End of macro FORTH_DSP_VALUEHL
3385			 
3385					; one value on hl get other one back 
3385			 
3385 e5					push hl 
3386			 
3386					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3386 cd a9 1c			call macro_forth_dsp_pop 
3389				endm 
# End of macro FORTH_DSP_POP
3389			 
3389 0e 00				ld c, FORTH_FALSE 
338b			 
338b e1					pop hl 
338c d1					pop de 
338d			 
338d 7b					ld a, e 
338e bd					cp l 
338f			 
338f 20 06				jr nz, .eq_done 
3391			 
3391 7a					ld a, d 
3392 bc					cp h 
3393			 
3393 20 02				jr nz, .eq_done 
3395			 
3395 0e 01				ld c, FORTH_TRUE 
3397					 
3397			 
3397			 
3397			.eq_done: 
3397			 
3397					; TODO push value back onto stack for another op etc 
3397			 
3397 26 00				ld h, 0 
3399 69					ld l, c 
339a					if DEBUG_FORTH_WORDS 
339a						DMARK "EQ1" 
339a f5				push af  
339b 3a af 33			ld a, (.dmark)  
339e 32 71 ee			ld (debug_mark),a  
33a1 3a b0 33			ld a, (.dmark+1)  
33a4 32 72 ee			ld (debug_mark+1),a  
33a7 3a b1 33			ld a, (.dmark+2)  
33aa 32 73 ee			ld (debug_mark+2),a  
33ad 18 03			jr .pastdmark  
33af ..			.dmark: db "EQ1"  
33b2 f1			.pastdmark: pop af  
33b3			endm  
# End of macro DMARK
33b3						CALLMONITOR 
33b3 cd 6d 14			call break_point_state  
33b6				endm  
# End of macro CALLMONITOR
33b6					endif 
33b6 cd fa 19				call forth_push_numhl 
33b9			 
33b9					NEXTW 
33b9 c3 63 1d			jp macro_next 
33bc				endm 
# End of macro NEXTW
33bc			 
33bc			 
33bc			.ENDLOGIC: 
33bc			; eof 
33bc			 
33bc			 
# End of file forth_words_logic.asm
33bc			include "forth_words_maths.asm" 
33bc			 
33bc			; | ## Maths Words 
33bc			 
33bc			.PLUS:	 
33bc				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
33bc 15				db WORD_SYS_CORE+1             
33bd fe 33			dw .NEG            
33bf 02				db 1 + 1 
33c0 .. 00			db "+",0              
33c2				endm 
# End of macro CWHEAD
33c2			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
33c2					if DEBUG_FORTH_WORDS_KEY 
33c2						DMARK "PLU" 
33c2 f5				push af  
33c3 3a d7 33			ld a, (.dmark)  
33c6 32 71 ee			ld (debug_mark),a  
33c9 3a d8 33			ld a, (.dmark+1)  
33cc 32 72 ee			ld (debug_mark+1),a  
33cf 3a d9 33			ld a, (.dmark+2)  
33d2 32 73 ee			ld (debug_mark+2),a  
33d5 18 03			jr .pastdmark  
33d7 ..			.dmark: db "PLU"  
33da f1			.pastdmark: pop af  
33db			endm  
# End of macro DMARK
33db						CALLMONITOR 
33db cd 6d 14			call break_point_state  
33de				endm  
# End of macro CALLMONITOR
33de					endif 
33de					; add top two values and push back result 
33de			 
33de					;for v5 FORTH_DSP_VALUE 
33de					FORTH_DSP 
33de cd b7 1b			call macro_forth_dsp 
33e1				endm 
# End of macro FORTH_DSP
33e1 7e					ld a,(hl)	; get type of value on TOS 
33e2 fe 02				cp DS_TYPE_INUM  
33e4 28 03				jr z, .dot_inum 
33e6			 
33e6					NEXTW 
33e6 c3 63 1d			jp macro_next 
33e9				endm 
# End of macro NEXTW
33e9			 
33e9			; float maths 
33e9			 
33e9				if FORTH_ENABLE_FLOATMATH 
33e9						inc hl      ; now at start of numeric as string 
33e9			 
33e9					if DEBUG_FORTH_MATHS 
33e9						DMARK "ADD" 
33e9				CALLMONITOR 
33e9					endif 
33e9			 
33e9					;ld ix, hl 
33e9					call CON 
33e9			 
33e9			 
33e9					push hl 
33e9					 
33e9					 
33e9			 
33e9						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
33e9			 
33e9					; get next number 
33e9			 
33e9						FORTH_DSP_VALUE 
33e9			 
33e9						inc hl      ; now at start of numeric as string 
33e9			 
33e9					;ld ix, hl 
33e9					call CON 
33e9			 
33e9					push hl 
33e9			 
33e9			 
33e9						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33e9			 
33e9						; TODO do add 
33e9			 
33e9						call IADD 
33e9			 
33e9						; TODO get result back as ascii 
33e9			 
33e9						; TODO push result  
33e9			 
33e9			 
33e9			 
33e9						jr .dot_done 
33e9				endif 
33e9			 
33e9			.dot_inum: 
33e9			 
33e9			 
33e9					if DEBUG_FORTH_DOT 
33e9						DMARK "+IT" 
33e9				CALLMONITOR 
33e9					endif 
33e9			 
33e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33e9 cd f1 1b			call macro_dsp_valuehl 
33ec				endm 
# End of macro FORTH_DSP_VALUEHL
33ec			 
33ec				; TODO add floating point number detection 
33ec			 
33ec e5					push hl 
33ed			 
33ed					; destroy value TOS 
33ed			 
33ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33ed cd a9 1c			call macro_forth_dsp_pop 
33f0				endm 
# End of macro FORTH_DSP_POP
33f0			 
33f0			 
33f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33f0 cd f1 1b			call macro_dsp_valuehl 
33f3				endm 
# End of macro FORTH_DSP_VALUEHL
33f3			 
33f3					; one value on hl get other one back 
33f3			 
33f3 d1					pop de 
33f4			 
33f4					; do the add 
33f4			 
33f4 19					add hl,de 
33f5			 
33f5					; save it 
33f5			 
33f5			;		push hl	 
33f5			 
33f5					; 
33f5			 
33f5					; destroy value TOS 
33f5			 
33f5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33f5 cd a9 1c			call macro_forth_dsp_pop 
33f8				endm 
# End of macro FORTH_DSP_POP
33f8			 
33f8					; TODO push value back onto stack for another op etc 
33f8			 
33f8			;		pop hl 
33f8			 
33f8			.dot_done: 
33f8 cd fa 19				call forth_push_numhl 
33fb			 
33fb					NEXTW 
33fb c3 63 1d			jp macro_next 
33fe				endm 
# End of macro NEXTW
33fe			.NEG: 
33fe			 
33fe				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
33fe 17				db WORD_SYS_CORE+3             
33ff 41 34			dw .DIV            
3401 02				db 1 + 1 
3402 .. 00			db "-",0              
3404				endm 
# End of macro CWHEAD
3404			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3404					if DEBUG_FORTH_WORDS_KEY 
3404						DMARK "SUB" 
3404 f5				push af  
3405 3a 19 34			ld a, (.dmark)  
3408 32 71 ee			ld (debug_mark),a  
340b 3a 1a 34			ld a, (.dmark+1)  
340e 32 72 ee			ld (debug_mark+1),a  
3411 3a 1b 34			ld a, (.dmark+2)  
3414 32 73 ee			ld (debug_mark+2),a  
3417 18 03			jr .pastdmark  
3419 ..			.dmark: db "SUB"  
341c f1			.pastdmark: pop af  
341d			endm  
# End of macro DMARK
341d						CALLMONITOR 
341d cd 6d 14			call break_point_state  
3420				endm  
# End of macro CALLMONITOR
3420					endif 
3420			 
3420			 
3420				; TODO add floating point number detection 
3420					; v5 FORTH_DSP_VALUE 
3420					FORTH_DSP 
3420 cd b7 1b			call macro_forth_dsp 
3423				endm 
# End of macro FORTH_DSP
3423 7e					ld a,(hl)	; get type of value on TOS 
3424 fe 02				cp DS_TYPE_INUM  
3426 28 03				jr z, .neg_inum 
3428			 
3428					NEXTW 
3428 c3 63 1d			jp macro_next 
342b				endm 
# End of macro NEXTW
342b			 
342b			; float maths 
342b			 
342b				if FORTH_ENABLE_FLOATMATH 
342b					jr .neg_done 
342b			 
342b				endif 
342b					 
342b			 
342b			.neg_inum: 
342b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
342b cd f1 1b			call macro_dsp_valuehl 
342e				endm 
# End of macro FORTH_DSP_VALUEHL
342e			 
342e e5					push hl 
342f			 
342f					; destroy value TOS 
342f			 
342f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
342f cd a9 1c			call macro_forth_dsp_pop 
3432				endm 
# End of macro FORTH_DSP_POP
3432			 
3432			 
3432					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3432 cd f1 1b			call macro_dsp_valuehl 
3435				endm 
# End of macro FORTH_DSP_VALUEHL
3435			 
3435					; one value on hl get other one back 
3435			 
3435 d1					pop de 
3436			 
3436					; do the sub 
3436			;		ex de, hl 
3436			 
3436 ed 52				sbc hl,de 
3438			 
3438					; save it 
3438			 
3438			;		push hl	 
3438			 
3438					; 
3438			 
3438					; destroy value TOS 
3438			 
3438					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3438 cd a9 1c			call macro_forth_dsp_pop 
343b				endm 
# End of macro FORTH_DSP_POP
343b			 
343b					; TODO push value back onto stack for another op etc 
343b			 
343b			;		pop hl 
343b			 
343b cd fa 19				call forth_push_numhl 
343e			.neg_done: 
343e			 
343e					NEXTW 
343e c3 63 1d			jp macro_next 
3441				endm 
# End of macro NEXTW
3441			.DIV: 
3441				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3441 18				db WORD_SYS_CORE+4             
3442 8e 34			dw .MUL            
3444 02				db 1 + 1 
3445 .. 00			db "/",0              
3447				endm 
# End of macro CWHEAD
3447			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3447					if DEBUG_FORTH_WORDS_KEY 
3447						DMARK "DIV" 
3447 f5				push af  
3448 3a 5c 34			ld a, (.dmark)  
344b 32 71 ee			ld (debug_mark),a  
344e 3a 5d 34			ld a, (.dmark+1)  
3451 32 72 ee			ld (debug_mark+1),a  
3454 3a 5e 34			ld a, (.dmark+2)  
3457 32 73 ee			ld (debug_mark+2),a  
345a 18 03			jr .pastdmark  
345c ..			.dmark: db "DIV"  
345f f1			.pastdmark: pop af  
3460			endm  
# End of macro DMARK
3460						CALLMONITOR 
3460 cd 6d 14			call break_point_state  
3463				endm  
# End of macro CALLMONITOR
3463					endif 
3463				; TODO add floating point number detection 
3463					; v5 FORTH_DSP_VALUE 
3463					FORTH_DSP 
3463 cd b7 1b			call macro_forth_dsp 
3466				endm 
# End of macro FORTH_DSP
3466 7e					ld a,(hl)	; get type of value on TOS 
3467 fe 02				cp DS_TYPE_INUM  
3469 28 03				jr z, .div_inum 
346b			 
346b				if FORTH_ENABLE_FLOATMATH 
346b					jr .div_done 
346b			 
346b				endif 
346b					NEXTW 
346b c3 63 1d			jp macro_next 
346e				endm 
# End of macro NEXTW
346e			.div_inum: 
346e			 
346e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
346e cd f1 1b			call macro_dsp_valuehl 
3471				endm 
# End of macro FORTH_DSP_VALUEHL
3471			 
3471 e5					push hl    ; to go to bc 
3472			 
3472					; destroy value TOS 
3472			 
3472					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3472 cd a9 1c			call macro_forth_dsp_pop 
3475				endm 
# End of macro FORTH_DSP_POP
3475			 
3475			 
3475					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3475 cd f1 1b			call macro_dsp_valuehl 
3478				endm 
# End of macro FORTH_DSP_VALUEHL
3478			 
3478					; hl to go to de 
3478			 
3478 e5					push hl 
3479			 
3479 c1					pop bc 
347a d1					pop de		 
347b			 
347b			 
347b					if DEBUG_FORTH_MATHS 
347b						DMARK "DIV" 
347b				CALLMONITOR 
347b					endif 
347b					; one value on hl but move to a get other one back 
347b			 
347b			        
347b cd 21 0b			call Div16 
347e			 
347e			;	push af	 
347e e5				push hl 
347f c5				push bc 
3480			 
3480					if DEBUG_FORTH_MATHS 
3480						DMARK "DI1" 
3480				CALLMONITOR 
3480					endif 
3480			 
3480					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3480 cd a9 1c			call macro_forth_dsp_pop 
3483				endm 
# End of macro FORTH_DSP_POP
3483			 
3483			 
3483			 
3483 e1					pop hl    ; result 
3484			 
3484 cd fa 19				call forth_push_numhl 
3487			 
3487 e1					pop hl    ; reminder 
3488			;		ld h,0 
3488			;		ld l,d 
3488			 
3488 cd fa 19				call forth_push_numhl 
348b			.div_done: 
348b					NEXTW 
348b c3 63 1d			jp macro_next 
348e				endm 
# End of macro NEXTW
348e			.MUL: 
348e				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
348e 19				db WORD_SYS_CORE+5             
348f d3 34			dw .MIN            
3491 02				db 1 + 1 
3492 .. 00			db "*",0              
3494				endm 
# End of macro CWHEAD
3494			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3494				; TODO add floating point number detection 
3494					if DEBUG_FORTH_WORDS_KEY 
3494						DMARK "MUL" 
3494 f5				push af  
3495 3a a9 34			ld a, (.dmark)  
3498 32 71 ee			ld (debug_mark),a  
349b 3a aa 34			ld a, (.dmark+1)  
349e 32 72 ee			ld (debug_mark+1),a  
34a1 3a ab 34			ld a, (.dmark+2)  
34a4 32 73 ee			ld (debug_mark+2),a  
34a7 18 03			jr .pastdmark  
34a9 ..			.dmark: db "MUL"  
34ac f1			.pastdmark: pop af  
34ad			endm  
# End of macro DMARK
34ad						CALLMONITOR 
34ad cd 6d 14			call break_point_state  
34b0				endm  
# End of macro CALLMONITOR
34b0					endif 
34b0					FORTH_DSP 
34b0 cd b7 1b			call macro_forth_dsp 
34b3				endm 
# End of macro FORTH_DSP
34b3					; v5 FORTH_DSP_VALUE 
34b3 7e					ld a,(hl)	; get type of value on TOS 
34b4 fe 02				cp DS_TYPE_INUM  
34b6 28 03				jr z, .mul_inum 
34b8			 
34b8				if FORTH_ENABLE_FLOATMATH 
34b8					jr .mul_done 
34b8			 
34b8				endif 
34b8			 
34b8					NEXTW 
34b8 c3 63 1d			jp macro_next 
34bb				endm 
# End of macro NEXTW
34bb			.mul_inum:	 
34bb			 
34bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34bb cd f1 1b			call macro_dsp_valuehl 
34be				endm 
# End of macro FORTH_DSP_VALUEHL
34be			 
34be e5					push hl 
34bf			 
34bf					; destroy value TOS 
34bf			 
34bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34bf cd a9 1c			call macro_forth_dsp_pop 
34c2				endm 
# End of macro FORTH_DSP_POP
34c2			 
34c2			 
34c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34c2 cd f1 1b			call macro_dsp_valuehl 
34c5				endm 
# End of macro FORTH_DSP_VALUEHL
34c5			 
34c5					; one value on hl but move to a get other one back 
34c5			 
34c5 7d					ld a, l 
34c6			 
34c6 d1					pop de 
34c7			 
34c7					; do the mull 
34c7			;		ex de, hl 
34c7			 
34c7 cd 47 0b				call Mult16 
34ca					; save it 
34ca			 
34ca			;		push hl	 
34ca			 
34ca					; 
34ca			 
34ca					; destroy value TOS 
34ca			 
34ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34ca cd a9 1c			call macro_forth_dsp_pop 
34cd				endm 
# End of macro FORTH_DSP_POP
34cd			 
34cd					; TODO push value back onto stack for another op etc 
34cd			 
34cd			;		pop hl 
34cd			 
34cd cd fa 19				call forth_push_numhl 
34d0			 
34d0			.mul_done: 
34d0					NEXTW 
34d0 c3 63 1d			jp macro_next 
34d3				endm 
# End of macro NEXTW
34d3			 
34d3			 
34d3			 
34d3			 
34d3			.MIN: 
34d3				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
34d3 49				db WORD_SYS_CORE+53             
34d4 54 35			dw .MAX            
34d6 04				db 3 + 1 
34d7 .. 00			db "MIN",0              
34db				endm 
# End of macro CWHEAD
34db			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
34db					if DEBUG_FORTH_WORDS_KEY 
34db						DMARK "MIN" 
34db f5				push af  
34dc 3a f0 34			ld a, (.dmark)  
34df 32 71 ee			ld (debug_mark),a  
34e2 3a f1 34			ld a, (.dmark+1)  
34e5 32 72 ee			ld (debug_mark+1),a  
34e8 3a f2 34			ld a, (.dmark+2)  
34eb 32 73 ee			ld (debug_mark+2),a  
34ee 18 03			jr .pastdmark  
34f0 ..			.dmark: db "MIN"  
34f3 f1			.pastdmark: pop af  
34f4			endm  
# End of macro DMARK
34f4						CALLMONITOR 
34f4 cd 6d 14			call break_point_state  
34f7				endm  
# End of macro CALLMONITOR
34f7					endif 
34f7					; get u2 
34f7			 
34f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34f7 cd f1 1b			call macro_dsp_valuehl 
34fa				endm 
# End of macro FORTH_DSP_VALUEHL
34fa			 
34fa e5					push hl   ; u2 
34fb			 
34fb					; destroy value TOS 
34fb			 
34fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34fb cd a9 1c			call macro_forth_dsp_pop 
34fe				endm 
# End of macro FORTH_DSP_POP
34fe			 
34fe					; get u1 
34fe			 
34fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34fe cd f1 1b			call macro_dsp_valuehl 
3501				endm 
# End of macro FORTH_DSP_VALUEHL
3501			 
3501 e5					push hl  ; u1 
3502			 
3502					; destroy value TOS 
3502			 
3502					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3502 cd a9 1c			call macro_forth_dsp_pop 
3505				endm 
# End of macro FORTH_DSP_POP
3505			 
3505 b7			 or a      ;clear carry flag 
3506 e1			  pop hl    ; u1 
3507 d1			  pop de    ; u2 
3508 e5				push hl   ; saved in case hl is lowest 
3509 ed 52		  sbc hl,de 
350b 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
350d			 
350d e1				pop hl 
350e					if DEBUG_FORTH_WORDS 
350e						DMARK "MIN" 
350e f5				push af  
350f 3a 23 35			ld a, (.dmark)  
3512 32 71 ee			ld (debug_mark),a  
3515 3a 24 35			ld a, (.dmark+1)  
3518 32 72 ee			ld (debug_mark+1),a  
351b 3a 25 35			ld a, (.dmark+2)  
351e 32 73 ee			ld (debug_mark+2),a  
3521 18 03			jr .pastdmark  
3523 ..			.dmark: db "MIN"  
3526 f1			.pastdmark: pop af  
3527			endm  
# End of macro DMARK
3527						CALLMONITOR 
3527 cd 6d 14			call break_point_state  
352a				endm  
# End of macro CALLMONITOR
352a					endif 
352a cd fa 19				call forth_push_numhl 
352d			 
352d				       NEXTW 
352d c3 63 1d			jp macro_next 
3530				endm 
# End of macro NEXTW
3530			 
3530			.mincont:  
3530 c1				pop bc   ; tidy up 
3531 eb				ex de , hl  
3532					if DEBUG_FORTH_WORDS 
3532						DMARK "MI1" 
3532 f5				push af  
3533 3a 47 35			ld a, (.dmark)  
3536 32 71 ee			ld (debug_mark),a  
3539 3a 48 35			ld a, (.dmark+1)  
353c 32 72 ee			ld (debug_mark+1),a  
353f 3a 49 35			ld a, (.dmark+2)  
3542 32 73 ee			ld (debug_mark+2),a  
3545 18 03			jr .pastdmark  
3547 ..			.dmark: db "MI1"  
354a f1			.pastdmark: pop af  
354b			endm  
# End of macro DMARK
354b						CALLMONITOR 
354b cd 6d 14			call break_point_state  
354e				endm  
# End of macro CALLMONITOR
354e					endif 
354e cd fa 19				call forth_push_numhl 
3551			 
3551				       NEXTW 
3551 c3 63 1d			jp macro_next 
3554				endm 
# End of macro NEXTW
3554			.MAX: 
3554				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3554 4a				db WORD_SYS_CORE+54             
3555 d5 35			dw .RND16            
3557 04				db 3 + 1 
3558 .. 00			db "MAX",0              
355c				endm 
# End of macro CWHEAD
355c			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
355c					if DEBUG_FORTH_WORDS_KEY 
355c						DMARK "MAX" 
355c f5				push af  
355d 3a 71 35			ld a, (.dmark)  
3560 32 71 ee			ld (debug_mark),a  
3563 3a 72 35			ld a, (.dmark+1)  
3566 32 72 ee			ld (debug_mark+1),a  
3569 3a 73 35			ld a, (.dmark+2)  
356c 32 73 ee			ld (debug_mark+2),a  
356f 18 03			jr .pastdmark  
3571 ..			.dmark: db "MAX"  
3574 f1			.pastdmark: pop af  
3575			endm  
# End of macro DMARK
3575						CALLMONITOR 
3575 cd 6d 14			call break_point_state  
3578				endm  
# End of macro CALLMONITOR
3578					endif 
3578					; get u2 
3578			 
3578					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3578 cd f1 1b			call macro_dsp_valuehl 
357b				endm 
# End of macro FORTH_DSP_VALUEHL
357b			 
357b e5					push hl   ; u2 
357c			 
357c					; destroy value TOS 
357c			 
357c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
357c cd a9 1c			call macro_forth_dsp_pop 
357f				endm 
# End of macro FORTH_DSP_POP
357f			 
357f					; get u1 
357f			 
357f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
357f cd f1 1b			call macro_dsp_valuehl 
3582				endm 
# End of macro FORTH_DSP_VALUEHL
3582			 
3582 e5					push hl  ; u1 
3583			 
3583					; destroy value TOS 
3583			 
3583					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3583 cd a9 1c			call macro_forth_dsp_pop 
3586				endm 
# End of macro FORTH_DSP_POP
3586			 
3586 b7			 or a      ;clear carry flag 
3587 e1			  pop hl    ; u1 
3588 d1			  pop de    ; u2 
3589 e5				push hl   ; saved in case hl is lowest 
358a ed 52		  sbc hl,de 
358c 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
358e			 
358e e1				pop hl 
358f					if DEBUG_FORTH_WORDS 
358f						DMARK "MAX" 
358f f5				push af  
3590 3a a4 35			ld a, (.dmark)  
3593 32 71 ee			ld (debug_mark),a  
3596 3a a5 35			ld a, (.dmark+1)  
3599 32 72 ee			ld (debug_mark+1),a  
359c 3a a6 35			ld a, (.dmark+2)  
359f 32 73 ee			ld (debug_mark+2),a  
35a2 18 03			jr .pastdmark  
35a4 ..			.dmark: db "MAX"  
35a7 f1			.pastdmark: pop af  
35a8			endm  
# End of macro DMARK
35a8						CALLMONITOR 
35a8 cd 6d 14			call break_point_state  
35ab				endm  
# End of macro CALLMONITOR
35ab					endif 
35ab cd fa 19				call forth_push_numhl 
35ae			 
35ae				       NEXTW 
35ae c3 63 1d			jp macro_next 
35b1				endm 
# End of macro NEXTW
35b1			 
35b1			.maxcont:  
35b1 c1				pop bc   ; tidy up 
35b2 eb				ex de , hl  
35b3					if DEBUG_FORTH_WORDS 
35b3						DMARK "MA1" 
35b3 f5				push af  
35b4 3a c8 35			ld a, (.dmark)  
35b7 32 71 ee			ld (debug_mark),a  
35ba 3a c9 35			ld a, (.dmark+1)  
35bd 32 72 ee			ld (debug_mark+1),a  
35c0 3a ca 35			ld a, (.dmark+2)  
35c3 32 73 ee			ld (debug_mark+2),a  
35c6 18 03			jr .pastdmark  
35c8 ..			.dmark: db "MA1"  
35cb f1			.pastdmark: pop af  
35cc			endm  
# End of macro DMARK
35cc						CALLMONITOR 
35cc cd 6d 14			call break_point_state  
35cf				endm  
# End of macro CALLMONITOR
35cf					endif 
35cf cd fa 19				call forth_push_numhl 
35d2				       NEXTW 
35d2 c3 63 1d			jp macro_next 
35d5				endm 
# End of macro NEXTW
35d5			 
35d5			.RND16: 
35d5				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
35d5 4e				db WORD_SYS_CORE+58             
35d6 04 36			dw .RND8            
35d8 06				db 5 + 1 
35d9 .. 00			db "RND16",0              
35df				endm 
# End of macro CWHEAD
35df			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
35df					if DEBUG_FORTH_WORDS_KEY 
35df						DMARK "R16" 
35df f5				push af  
35e0 3a f4 35			ld a, (.dmark)  
35e3 32 71 ee			ld (debug_mark),a  
35e6 3a f5 35			ld a, (.dmark+1)  
35e9 32 72 ee			ld (debug_mark+1),a  
35ec 3a f6 35			ld a, (.dmark+2)  
35ef 32 73 ee			ld (debug_mark+2),a  
35f2 18 03			jr .pastdmark  
35f4 ..			.dmark: db "R16"  
35f7 f1			.pastdmark: pop af  
35f8			endm  
# End of macro DMARK
35f8						CALLMONITOR 
35f8 cd 6d 14			call break_point_state  
35fb				endm  
# End of macro CALLMONITOR
35fb					endif 
35fb cd eb 0a				call prng16  
35fe cd fa 19				call forth_push_numhl 
3601				       NEXTW 
3601 c3 63 1d			jp macro_next 
3604				endm 
# End of macro NEXTW
3604			.RND8: 
3604				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3604 60				db WORD_SYS_CORE+76             
3605 39 36			dw .RND            
3607 05				db 4 + 1 
3608 .. 00			db "RND8",0              
360d				endm 
# End of macro CWHEAD
360d			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
360d					if DEBUG_FORTH_WORDS_KEY 
360d						DMARK "RN8" 
360d f5				push af  
360e 3a 22 36			ld a, (.dmark)  
3611 32 71 ee			ld (debug_mark),a  
3614 3a 23 36			ld a, (.dmark+1)  
3617 32 72 ee			ld (debug_mark+1),a  
361a 3a 24 36			ld a, (.dmark+2)  
361d 32 73 ee			ld (debug_mark+2),a  
3620 18 03			jr .pastdmark  
3622 ..			.dmark: db "RN8"  
3625 f1			.pastdmark: pop af  
3626			endm  
# End of macro DMARK
3626						CALLMONITOR 
3626 cd 6d 14			call break_point_state  
3629				endm  
# End of macro CALLMONITOR
3629					endif 
3629 2a b2 eb				ld hl,(xrandc) 
362c 23					inc hl 
362d cd 05 0b				call xrnd 
3630 6f					ld l,a	 
3631 26 00				ld h,0 
3633 cd fa 19				call forth_push_numhl 
3636				       NEXTW 
3636 c3 63 1d			jp macro_next 
3639				endm 
# End of macro NEXTW
3639			.RND: 
3639				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3639 60				db WORD_SYS_CORE+76             
363a 3f 37			dw .ENDMATHS            
363c 04				db 3 + 1 
363d .. 00			db "RND",0              
3641				endm 
# End of macro CWHEAD
3641			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3641			 
3641					if DEBUG_FORTH_WORDS_KEY 
3641						DMARK "RND" 
3641 f5				push af  
3642 3a 56 36			ld a, (.dmark)  
3645 32 71 ee			ld (debug_mark),a  
3648 3a 57 36			ld a, (.dmark+1)  
364b 32 72 ee			ld (debug_mark+1),a  
364e 3a 58 36			ld a, (.dmark+2)  
3651 32 73 ee			ld (debug_mark+2),a  
3654 18 03			jr .pastdmark  
3656 ..			.dmark: db "RND"  
3659 f1			.pastdmark: pop af  
365a			endm  
# End of macro DMARK
365a						CALLMONITOR 
365a cd 6d 14			call break_point_state  
365d				endm  
# End of macro CALLMONITOR
365d					endif 
365d					 
365d					FORTH_DSP_VALUEHL    ; upper range 
365d cd f1 1b			call macro_dsp_valuehl 
3660				endm 
# End of macro FORTH_DSP_VALUEHL
3660			 
3660 22 b6 eb				ld (LFSRSeed), hl	 
3663			 
3663					if DEBUG_FORTH_WORDS 
3663						DMARK "RN1" 
3663 f5				push af  
3664 3a 78 36			ld a, (.dmark)  
3667 32 71 ee			ld (debug_mark),a  
366a 3a 79 36			ld a, (.dmark+1)  
366d 32 72 ee			ld (debug_mark+1),a  
3670 3a 7a 36			ld a, (.dmark+2)  
3673 32 73 ee			ld (debug_mark+2),a  
3676 18 03			jr .pastdmark  
3678 ..			.dmark: db "RN1"  
367b f1			.pastdmark: pop af  
367c			endm  
# End of macro DMARK
367c						CALLMONITOR 
367c cd 6d 14			call break_point_state  
367f				endm  
# End of macro CALLMONITOR
367f					endif 
367f					FORTH_DSP_POP 
367f cd a9 1c			call macro_forth_dsp_pop 
3682				endm 
# End of macro FORTH_DSP_POP
3682			 
3682					FORTH_DSP_VALUEHL    ; low range 
3682 cd f1 1b			call macro_dsp_valuehl 
3685				endm 
# End of macro FORTH_DSP_VALUEHL
3685			 
3685					if DEBUG_FORTH_WORDS 
3685						DMARK "RN2" 
3685 f5				push af  
3686 3a 9a 36			ld a, (.dmark)  
3689 32 71 ee			ld (debug_mark),a  
368c 3a 9b 36			ld a, (.dmark+1)  
368f 32 72 ee			ld (debug_mark+1),a  
3692 3a 9c 36			ld a, (.dmark+2)  
3695 32 73 ee			ld (debug_mark+2),a  
3698 18 03			jr .pastdmark  
369a ..			.dmark: db "RN2"  
369d f1			.pastdmark: pop af  
369e			endm  
# End of macro DMARK
369e						CALLMONITOR 
369e cd 6d 14			call break_point_state  
36a1				endm  
# End of macro CALLMONITOR
36a1					endif 
36a1 22 b8 eb				ld (LFSRSeed+2), hl 
36a4			 
36a4					FORTH_DSP_POP 
36a4 cd a9 1c			call macro_forth_dsp_pop 
36a7				endm 
# End of macro FORTH_DSP_POP
36a7			 
36a7 e5					push hl 
36a8			 
36a8 e1			.inrange:	pop hl 
36a9 cd eb 0a				call prng16  
36ac					if DEBUG_FORTH_WORDS 
36ac						DMARK "RN3" 
36ac f5				push af  
36ad 3a c1 36			ld a, (.dmark)  
36b0 32 71 ee			ld (debug_mark),a  
36b3 3a c2 36			ld a, (.dmark+1)  
36b6 32 72 ee			ld (debug_mark+1),a  
36b9 3a c3 36			ld a, (.dmark+2)  
36bc 32 73 ee			ld (debug_mark+2),a  
36bf 18 03			jr .pastdmark  
36c1 ..			.dmark: db "RN3"  
36c4 f1			.pastdmark: pop af  
36c5			endm  
# End of macro DMARK
36c5						CALLMONITOR 
36c5 cd 6d 14			call break_point_state  
36c8				endm  
# End of macro CALLMONITOR
36c8					endif 
36c8					 
36c8					; if the range is 8bit knock out the high byte 
36c8			 
36c8 ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
36cc			 
36cc 3e 00				ld a, 0 
36ce ba					cp d  
36cf 20 1e				jr nz, .hirange 
36d1 26 00				ld h, 0   ; knock it down to 8bit 
36d3			 
36d3					if DEBUG_FORTH_WORDS 
36d3						DMARK "RNk" 
36d3 f5				push af  
36d4 3a e8 36			ld a, (.dmark)  
36d7 32 71 ee			ld (debug_mark),a  
36da 3a e9 36			ld a, (.dmark+1)  
36dd 32 72 ee			ld (debug_mark+1),a  
36e0 3a ea 36			ld a, (.dmark+2)  
36e3 32 73 ee			ld (debug_mark+2),a  
36e6 18 03			jr .pastdmark  
36e8 ..			.dmark: db "RNk"  
36eb f1			.pastdmark: pop af  
36ec			endm  
# End of macro DMARK
36ec						CALLMONITOR 
36ec cd 6d 14			call break_point_state  
36ef				endm  
# End of macro CALLMONITOR
36ef					endif 
36ef			.hirange:   
36ef e5					push hl  
36f0 b7					or a  
36f1 ed 52		                sbc hl, de 
36f3			 
36f3					;call cmp16 
36f3			 
36f3 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
36f5 e1					pop hl 
36f6 e5					push hl 
36f7			 
36f7					if DEBUG_FORTH_WORDS 
36f7						DMARK "RN4" 
36f7 f5				push af  
36f8 3a 0c 37			ld a, (.dmark)  
36fb 32 71 ee			ld (debug_mark),a  
36fe 3a 0d 37			ld a, (.dmark+1)  
3701 32 72 ee			ld (debug_mark+1),a  
3704 3a 0e 37			ld a, (.dmark+2)  
3707 32 73 ee			ld (debug_mark+2),a  
370a 18 03			jr .pastdmark  
370c ..			.dmark: db "RN4"  
370f f1			.pastdmark: pop af  
3710			endm  
# End of macro DMARK
3710						CALLMONITOR 
3710 cd 6d 14			call break_point_state  
3713				endm  
# End of macro CALLMONITOR
3713					endif 
3713 ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
3717					;call cmp16 
3717				 
3717 b7					or a  
3718 ed 52		                sbc hl, de 
371a 38 8c				jr c, .inrange 
371c			 
371c e1					pop hl 
371d					 
371d					if DEBUG_FORTH_WORDS 
371d						DMARK "RNd" 
371d f5				push af  
371e 3a 32 37			ld a, (.dmark)  
3721 32 71 ee			ld (debug_mark),a  
3724 3a 33 37			ld a, (.dmark+1)  
3727 32 72 ee			ld (debug_mark+1),a  
372a 3a 34 37			ld a, (.dmark+2)  
372d 32 73 ee			ld (debug_mark+2),a  
3730 18 03			jr .pastdmark  
3732 ..			.dmark: db "RNd"  
3735 f1			.pastdmark: pop af  
3736			endm  
# End of macro DMARK
3736						CALLMONITOR 
3736 cd 6d 14			call break_point_state  
3739				endm  
# End of macro CALLMONITOR
3739					endif 
3739			 
3739			 
3739 cd fa 19				call forth_push_numhl 
373c				       NEXTW 
373c c3 63 1d			jp macro_next 
373f				endm 
# End of macro NEXTW
373f			 
373f			.ENDMATHS: 
373f			 
373f			; eof 
373f			 
# End of file forth_words_maths.asm
373f			include "forth_words_display.asm" 
373f			 
373f			; | ## Display Words 
373f			 
373f			.INFO: 
373f			 
373f				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
373f 62				db WORD_SYS_CORE+78             
3740 5c 37			dw .ATP            
3742 05				db 4 + 1 
3743 .. 00			db "INFO",0              
3748				endm 
# End of macro CWHEAD
3748			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3748					FORTH_DSP_VALUEHL 
3748 cd f1 1b			call macro_dsp_valuehl 
374b				endm 
# End of macro FORTH_DSP_VALUEHL
374b			 
374b					FORTH_DSP_POP 
374b cd a9 1c			call macro_forth_dsp_pop 
374e				endm 
# End of macro FORTH_DSP_POP
374e			 
374e e5					push hl 
374f			 
374f					FORTH_DSP_VALUEHL 
374f cd f1 1b			call macro_dsp_valuehl 
3752				endm 
# End of macro FORTH_DSP_VALUEHL
3752			 
3752					FORTH_DSP_POP 
3752 cd a9 1c			call macro_forth_dsp_pop 
3755				endm 
# End of macro FORTH_DSP_POP
3755			 
3755 d1					pop de 
3756			 
3756 cd 28 09				call info_panel 
3759			 
3759			 
3759					NEXTW 
3759 c3 63 1d			jp macro_next 
375c				endm 
# End of macro NEXTW
375c			.ATP: 
375c				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
375c 62				db WORD_SYS_CORE+78             
375d d3 37			dw .FB            
375f 04				db 3 + 1 
3760 .. 00			db "AT?",0              
3764				endm 
# End of macro CWHEAD
3764			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3764					if DEBUG_FORTH_WORDS_KEY 
3764						DMARK "AT?" 
3764 f5				push af  
3765 3a 79 37			ld a, (.dmark)  
3768 32 71 ee			ld (debug_mark),a  
376b 3a 7a 37			ld a, (.dmark+1)  
376e 32 72 ee			ld (debug_mark+1),a  
3771 3a 7b 37			ld a, (.dmark+2)  
3774 32 73 ee			ld (debug_mark+2),a  
3777 18 03			jr .pastdmark  
3779 ..			.dmark: db "AT?"  
377c f1			.pastdmark: pop af  
377d			endm  
# End of macro DMARK
377d						CALLMONITOR 
377d cd 6d 14			call break_point_state  
3780				endm  
# End of macro CALLMONITOR
3780					endif 
3780 3a 40 eb				ld a, (f_cursor_ptr) 
3783			 
3783			if DEBUG_FORTH_WORDS 
3783				DMARK "AT?" 
3783 f5				push af  
3784 3a 98 37			ld a, (.dmark)  
3787 32 71 ee			ld (debug_mark),a  
378a 3a 99 37			ld a, (.dmark+1)  
378d 32 72 ee			ld (debug_mark+1),a  
3790 3a 9a 37			ld a, (.dmark+2)  
3793 32 73 ee			ld (debug_mark+2),a  
3796 18 03			jr .pastdmark  
3798 ..			.dmark: db "AT?"  
379b f1			.pastdmark: pop af  
379c			endm  
# End of macro DMARK
379c				CALLMONITOR 
379c cd 6d 14			call break_point_state  
379f				endm  
# End of macro CALLMONITOR
379f			endif	 
379f					; count the number of rows 
379f			 
379f 06 00				ld b, 0 
37a1 4f			.atpr:		ld c, a    ; save in case we go below zero 
37a2 d6 28				sub display_cols 
37a4 f2 aa 37				jp p, .atprunder 
37a7 04					inc b 
37a8 18 f7				jr .atpr 
37aa			.atprunder:	 
37aa			if DEBUG_FORTH_WORDS 
37aa				DMARK "A?2" 
37aa f5				push af  
37ab 3a bf 37			ld a, (.dmark)  
37ae 32 71 ee			ld (debug_mark),a  
37b1 3a c0 37			ld a, (.dmark+1)  
37b4 32 72 ee			ld (debug_mark+1),a  
37b7 3a c1 37			ld a, (.dmark+2)  
37ba 32 73 ee			ld (debug_mark+2),a  
37bd 18 03			jr .pastdmark  
37bf ..			.dmark: db "A?2"  
37c2 f1			.pastdmark: pop af  
37c3			endm  
# End of macro DMARK
37c3				CALLMONITOR 
37c3 cd 6d 14			call break_point_state  
37c6				endm  
# End of macro CALLMONITOR
37c6			endif	 
37c6 26 00				ld h, 0 
37c8 69					ld l, c 
37c9 cd fa 19				call forth_push_numhl 
37cc 68					ld l, b  
37cd cd fa 19				call forth_push_numhl 
37d0			 
37d0			 
37d0				NEXTW 
37d0 c3 63 1d			jp macro_next 
37d3				endm 
# End of macro NEXTW
37d3			 
37d3			.FB: 
37d3				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
37d3 1b				db WORD_SYS_CORE+7             
37d4 21 38			dw .EMIT            
37d6 03				db 2 + 1 
37d7 .. 00			db "FB",0              
37da				endm 
# End of macro CWHEAD
37da			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
37da			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
37da			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
37da			; | | If automatic display is off then updates will not be shown until DRAW is used. 
37da					if DEBUG_FORTH_WORDS_KEY 
37da						DMARK "FB." 
37da f5				push af  
37db 3a ef 37			ld a, (.dmark)  
37de 32 71 ee			ld (debug_mark),a  
37e1 3a f0 37			ld a, (.dmark+1)  
37e4 32 72 ee			ld (debug_mark+1),a  
37e7 3a f1 37			ld a, (.dmark+2)  
37ea 32 73 ee			ld (debug_mark+2),a  
37ed 18 03			jr .pastdmark  
37ef ..			.dmark: db "FB."  
37f2 f1			.pastdmark: pop af  
37f3			endm  
# End of macro DMARK
37f3						CALLMONITOR 
37f3 cd 6d 14			call break_point_state  
37f6				endm  
# End of macro CALLMONITOR
37f6					endif 
37f6			 
37f6					FORTH_DSP_VALUEHL 
37f6 cd f1 1b			call macro_dsp_valuehl 
37f9				endm 
# End of macro FORTH_DSP_VALUEHL
37f9			 
37f9 7d					ld a, l 
37fa fe 01				cp 1 
37fc 20 05				jr nz, .fbn1 
37fe 21 16 ed				ld hl, display_fb1 
3801 18 15				jr .fbset 
3803 fe 02		.fbn1:		cp 2 
3805 20 05				jr nz, .fbn2 
3807 21 d4 eb				ld hl, display_fb2 
380a 18 0c				jr .fbset 
380c fe 03		.fbn2:		cp 3 
380e 20 05				jr nz, .fbn3 
3810 21 75 ec				ld hl, display_fb3 
3813 18 03				jr .fbset 
3815			.fbn3:		 ; if invalid number select first 
3815 21 16 ed				ld hl, display_fb1 
3818 22 d2 eb		.fbset:		ld (display_fb_active), hl 
381b			 
381b					FORTH_DSP_POP 
381b cd a9 1c			call macro_forth_dsp_pop 
381e				endm 
# End of macro FORTH_DSP_POP
381e			 
381e					NEXTW 
381e c3 63 1d			jp macro_next 
3821				endm 
# End of macro NEXTW
3821			 
3821			 
3821			.EMIT: 
3821				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3821 1b				db WORD_SYS_CORE+7             
3822 72 38			dw .DOTH            
3824 05				db 4 + 1 
3825 .. 00			db "EMIT",0              
382a				endm 
# End of macro CWHEAD
382a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
382a					; get value off TOS and display it 
382a			 
382a					if DEBUG_FORTH_WORDS_KEY 
382a						DMARK "EMT" 
382a f5				push af  
382b 3a 3f 38			ld a, (.dmark)  
382e 32 71 ee			ld (debug_mark),a  
3831 3a 40 38			ld a, (.dmark+1)  
3834 32 72 ee			ld (debug_mark+1),a  
3837 3a 41 38			ld a, (.dmark+2)  
383a 32 73 ee			ld (debug_mark+2),a  
383d 18 03			jr .pastdmark  
383f ..			.dmark: db "EMT"  
3842 f1			.pastdmark: pop af  
3843			endm  
# End of macro DMARK
3843						CALLMONITOR 
3843 cd 6d 14			call break_point_state  
3846				endm  
# End of macro CALLMONITOR
3846					endif 
3846			 
3846					FORTH_DSP_VALUEHL 
3846 cd f1 1b			call macro_dsp_valuehl 
3849				endm 
# End of macro FORTH_DSP_VALUEHL
3849			 
3849 7d					ld a,l 
384a			 
384a					; TODO write to display 
384a			 
384a 32 55 e5				ld (os_input), a 
384d 3e 00				ld a, 0 
384f 32 56 e5				ld (os_input+1), a 
3852					 
3852 3a 40 eb				ld a, (f_cursor_ptr) 
3855 11 55 e5				ld de, os_input 
3858 cd aa 09				call str_at_display 
385b			 
385b			 
385b 3a 1e eb				ld a,(cli_autodisplay) 
385e fe 00				cp 0 
3860 28 03				jr z, .enoupdate 
3862 cd ba 09						call update_display 
3865					.enoupdate: 
3865			 
3865 3a 40 eb				ld a, (f_cursor_ptr) 
3868 3c					inc a 
3869 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
386c			 
386c			 
386c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
386c cd a9 1c			call macro_forth_dsp_pop 
386f				endm 
# End of macro FORTH_DSP_POP
386f			  
386f			 
386f					NEXTW 
386f c3 63 1d			jp macro_next 
3872				endm 
# End of macro NEXTW
3872			.DOTH: 
3872				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3872 1c				db WORD_SYS_CORE+8             
3873 a2 38			dw .DOTF            
3875 03				db 2 + 1 
3876 .. 00			db ".-",0              
3879				endm 
# End of macro CWHEAD
3879			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3879					; get value off TOS and display it 
3879					if DEBUG_FORTH_WORDS_KEY 
3879						DMARK "DTD" 
3879 f5				push af  
387a 3a 8e 38			ld a, (.dmark)  
387d 32 71 ee			ld (debug_mark),a  
3880 3a 8f 38			ld a, (.dmark+1)  
3883 32 72 ee			ld (debug_mark+1),a  
3886 3a 90 38			ld a, (.dmark+2)  
3889 32 73 ee			ld (debug_mark+2),a  
388c 18 03			jr .pastdmark  
388e ..			.dmark: db "DTD"  
3891 f1			.pastdmark: pop af  
3892			endm  
# End of macro DMARK
3892						CALLMONITOR 
3892 cd 6d 14			call break_point_state  
3895				endm  
# End of macro CALLMONITOR
3895					endif 
3895 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3897 3e 00			ld a, 0 
3899 32 1f eb			ld (cli_mvdot), a 
389c c3 f9 38			jp .dotgo 
389f				NEXTW 
389f c3 63 1d			jp macro_next 
38a2				endm 
# End of macro NEXTW
38a2			.DOTF: 
38a2				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
38a2 1c				db WORD_SYS_CORE+8             
38a3 d0 38			dw .DOT            
38a5 03				db 2 + 1 
38a6 .. 00			db ".>",0              
38a9				endm 
# End of macro CWHEAD
38a9			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
38a9					; get value off TOS and display it 
38a9			        ; TODO BUG adds extra spaces 
38a9			        ; TODO BUG handle numerics? 
38a9					if DEBUG_FORTH_WORDS_KEY 
38a9						DMARK "DTC" 
38a9 f5				push af  
38aa 3a be 38			ld a, (.dmark)  
38ad 32 71 ee			ld (debug_mark),a  
38b0 3a bf 38			ld a, (.dmark+1)  
38b3 32 72 ee			ld (debug_mark+1),a  
38b6 3a c0 38			ld a, (.dmark+2)  
38b9 32 73 ee			ld (debug_mark+2),a  
38bc 18 03			jr .pastdmark  
38be ..			.dmark: db "DTC"  
38c1 f1			.pastdmark: pop af  
38c2			endm  
# End of macro DMARK
38c2						CALLMONITOR 
38c2 cd 6d 14			call break_point_state  
38c5				endm  
# End of macro CALLMONITOR
38c5					endif 
38c5 3e 01			ld a, 1 
38c7 32 1f eb			ld (cli_mvdot), a 
38ca c3 f9 38			jp .dotgo 
38cd				NEXTW 
38cd c3 63 1d			jp macro_next 
38d0				endm 
# End of macro NEXTW
38d0			 
38d0			.DOT: 
38d0				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
38d0 1c				db WORD_SYS_CORE+8             
38d1 5c 39			dw .CLS            
38d3 02				db 1 + 1 
38d4 .. 00			db ".",0              
38d6				endm 
# End of macro CWHEAD
38d6			        ; | . ( u -- ) Display TOS | DONE 
38d6					; get value off TOS and display it 
38d6			 
38d6					if DEBUG_FORTH_WORDS_KEY 
38d6						DMARK "DOT" 
38d6 f5				push af  
38d7 3a eb 38			ld a, (.dmark)  
38da 32 71 ee			ld (debug_mark),a  
38dd 3a ec 38			ld a, (.dmark+1)  
38e0 32 72 ee			ld (debug_mark+1),a  
38e3 3a ed 38			ld a, (.dmark+2)  
38e6 32 73 ee			ld (debug_mark+2),a  
38e9 18 03			jr .pastdmark  
38eb ..			.dmark: db "DOT"  
38ee f1			.pastdmark: pop af  
38ef			endm  
# End of macro DMARK
38ef						CALLMONITOR 
38ef cd 6d 14			call break_point_state  
38f2				endm  
# End of macro CALLMONITOR
38f2					endif 
38f2 3e 00			ld a, 0 
38f4 32 1f eb			ld (cli_mvdot), a 
38f7 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
38f9				 
38f9			 
38f9			.dotgo: 
38f9			 
38f9			; move up type to on stack for parserv5 
38f9					FORTH_DSP 
38f9 cd b7 1b			call macro_forth_dsp 
38fc				endm 
# End of macro FORTH_DSP
38fc				;FORTH_DSP_VALUE  
38fc			 
38fc			if DEBUG_FORTH_DOT 
38fc				DMARK "DOT" 
38fc				CALLMONITOR 
38fc			endif	 
38fc			;		.print: 
38fc			 
38fc 7e				ld a,(hl)  ; work out what type of value is on the TOS 
38fd 23				inc hl   ; position to the actual value 
38fe fe 01			cp DS_TYPE_STR 
3900 20 06			jr nz, .dotnum1  
3902			 
3902			; display string 
3902				FORTH_DSP_VALUE  
3902 cd da 1b			call macro_forth_dsp_value 
3905				endm 
# End of macro FORTH_DSP_VALUE
3905 eb				ex de,hl 
3906 18 11			jr .dotwrite 
3908			 
3908			.dotnum1: 
3908 fe 02			cp DS_TYPE_INUM 
390a 20 0c			jr nz, .dotflot 
390c			 
390c			 
390c			; display number 
390c			 
390c			;	push hl 
390c			;	call clear_display 
390c			;	pop hl 
390c			 
390c 5e				ld e, (hl) 
390d 23				inc hl 
390e 56				ld d, (hl) 
390f 21 57 e3			ld hl, scratch 
3912			if DEBUG_FORTH_DOT 
3912				DMARK "DT1" 
3912				CALLMONITOR 
3912			endif	 
3912			 
3912 cd d1 0f			call uitoa_16 
3915 eb				ex de,hl 
3916			 
3916			if DEBUG_FORTH_DOT 
3916				DMARK "DT2" 
3916				CALLMONITOR 
3916			endif	 
3916			 
3916			;	ld de, os_word_scratch 
3916 18 01			jr .dotwrite 
3918			 
3918 00			.dotflot:   nop 
3919			; TODO print floating point number 
3919			 
3919			.dotwrite:		 
3919			 
3919					; if c is set then set all '-' to spaces 
3919					; need to also take into account .>  
3919			 
3919 3e 01				ld a, 1 
391b b9					cp c 
391c 20 13				jr nz, .nodashswap 
391e			 
391e					; DE has the string to write, working with HL 
391e			 
391e 06 ff				ld b, 255 
3920 d5					push de 
3921 e1					pop hl 
3922			 
3922			if DEBUG_FORTH_DOT 
3922				DMARK "DT-" 
3922				CALLMONITOR 
3922			endif	 
3922 7e			.dashscan:	ld a, (hl) 
3923 fe 00				cp 0 
3925 28 0a				jr z, .nodashswap 
3927 fe 2d				cp '-' 
3929 20 03				jr nz, .dashskip 
392b 3e 20				ld a, ' ' 
392d 77					ld (hl), a 
392e 23			.dashskip:	inc hl 
392f			if DEBUG_FORTH_DOT 
392f				DMARK "D-2" 
392f				CALLMONITOR 
392f			endif	 
392f 10 f1				djnz .dashscan 
3931			 
3931			if DEBUG_FORTH_DOT 
3931				DMARK "D-1" 
3931				CALLMONITOR 
3931			endif	 
3931			 
3931			.nodashswap: 
3931			 
3931 e5					push hl   ; save string start in case we need to advance print 
3932			 
3932 3a 40 eb				ld a, (f_cursor_ptr) 
3935 cd aa 09				call str_at_display 
3938 3a 1e eb				ld a,(cli_autodisplay) 
393b fe 00				cp 0 
393d 28 03				jr z, .noupdate 
393f cd ba 09						call update_display 
3942					.noupdate: 
3942			 
3942			 
3942					; see if we need to advance the print position 
3942			 
3942 e1					pop hl   ; get back string 
3943			 
3943 3a 1f eb				ld a, (cli_mvdot) 
3946			if DEBUG_FORTH_DOT 
3946					ld e,a 
3946				DMARK "D>1" 
3946				CALLMONITOR 
3946			endif	 
3946 fe 00				cp 0 
3948 28 0c				jr z, .noadv 
394a					; yes, lets advance the print position 
394a 3e 00				ld a, 0 
394c cd 2d 10				call strlent 
394f 3a 40 eb				ld a, (f_cursor_ptr) 
3952 85					add a,l 
3953					;call addatohl 
3953					;ld a, l 
3953 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
3956			 
3956			if DEBUG_FORTH_DOT 
3956				DMARK "D->" 
3956				CALLMONITOR 
3956			endif	 
3956			 
3956			.noadv:	 
3956			 
3956					if DEBUG_FORTH_DOT_WAIT 
3956							call next_page_prompt 
3956					endif	 
3956			; TODO this pop off the stack causes a crash. i dont know why 
3956			 
3956			 
3956			if DEBUG_FORTH_DOT 
3956				DMARK "DTh" 
3956				CALLMONITOR 
3956			endif	 
3956			 
3956					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3956 cd a9 1c			call macro_forth_dsp_pop 
3959				endm 
# End of macro FORTH_DSP_POP
3959			 
3959			if DEBUG_FORTH_DOT 
3959				DMARK "DTi" 
3959				CALLMONITOR 
3959			endif	 
3959			 
3959			 
3959					NEXTW 
3959 c3 63 1d			jp macro_next 
395c				endm 
# End of macro NEXTW
395c			 
395c			.CLS: 
395c				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
395c 35				db WORD_SYS_CORE+33             
395d 89 39			dw .DRAW            
395f 04				db 3 + 1 
3960 .. 00			db "CLS",0              
3964				endm 
# End of macro CWHEAD
3964			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3964					if DEBUG_FORTH_WORDS_KEY 
3964						DMARK "CLS" 
3964 f5				push af  
3965 3a 79 39			ld a, (.dmark)  
3968 32 71 ee			ld (debug_mark),a  
396b 3a 7a 39			ld a, (.dmark+1)  
396e 32 72 ee			ld (debug_mark+1),a  
3971 3a 7b 39			ld a, (.dmark+2)  
3974 32 73 ee			ld (debug_mark+2),a  
3977 18 03			jr .pastdmark  
3979 ..			.dmark: db "CLS"  
397c f1			.pastdmark: pop af  
397d			endm  
# End of macro DMARK
397d						CALLMONITOR 
397d cd 6d 14			call break_point_state  
3980				endm  
# End of macro CALLMONITOR
3980					endif 
3980 cd 97 09				call clear_display 
3983 c3 97 3a				jp .home		; and home cursor 
3986					NEXTW 
3986 c3 63 1d			jp macro_next 
3989				endm 
# End of macro NEXTW
3989			 
3989			.DRAW: 
3989				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3989 36				db WORD_SYS_CORE+34             
398a b4 39			dw .DUMP            
398c 05				db 4 + 1 
398d .. 00			db "DRAW",0              
3992				endm 
# End of macro CWHEAD
3992			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3992					if DEBUG_FORTH_WORDS_KEY 
3992						DMARK "DRW" 
3992 f5				push af  
3993 3a a7 39			ld a, (.dmark)  
3996 32 71 ee			ld (debug_mark),a  
3999 3a a8 39			ld a, (.dmark+1)  
399c 32 72 ee			ld (debug_mark+1),a  
399f 3a a9 39			ld a, (.dmark+2)  
39a2 32 73 ee			ld (debug_mark+2),a  
39a5 18 03			jr .pastdmark  
39a7 ..			.dmark: db "DRW"  
39aa f1			.pastdmark: pop af  
39ab			endm  
# End of macro DMARK
39ab						CALLMONITOR 
39ab cd 6d 14			call break_point_state  
39ae				endm  
# End of macro CALLMONITOR
39ae					endif 
39ae cd ba 09				call update_display 
39b1					NEXTW 
39b1 c3 63 1d			jp macro_next 
39b4				endm 
# End of macro NEXTW
39b4			 
39b4			.DUMP: 
39b4				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
39b4 37				db WORD_SYS_CORE+35             
39b5 ec 39			dw .CDUMP            
39b7 05				db 4 + 1 
39b8 .. 00			db "DUMP",0              
39bd				endm 
# End of macro CWHEAD
39bd			; | DUMP ( x -- ) With address x display dump   | DONE 
39bd			; TODO pop address to use off of the stack 
39bd					if DEBUG_FORTH_WORDS_KEY 
39bd						DMARK "DUM" 
39bd f5				push af  
39be 3a d2 39			ld a, (.dmark)  
39c1 32 71 ee			ld (debug_mark),a  
39c4 3a d3 39			ld a, (.dmark+1)  
39c7 32 72 ee			ld (debug_mark+1),a  
39ca 3a d4 39			ld a, (.dmark+2)  
39cd 32 73 ee			ld (debug_mark+2),a  
39d0 18 03			jr .pastdmark  
39d2 ..			.dmark: db "DUM"  
39d5 f1			.pastdmark: pop af  
39d6			endm  
# End of macro DMARK
39d6						CALLMONITOR 
39d6 cd 6d 14			call break_point_state  
39d9				endm  
# End of macro CALLMONITOR
39d9					endif 
39d9 cd 97 09				call clear_display 
39dc			 
39dc					; get address 
39dc			 
39dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39dc cd f1 1b			call macro_dsp_valuehl 
39df				endm 
# End of macro FORTH_DSP_VALUEHL
39df				 
39df					; save it for cdump 
39df			 
39df 22 7a e6				ld (os_cur_ptr),hl 
39e2			 
39e2					; destroy value TOS 
39e2			 
39e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39e2 cd a9 1c			call macro_forth_dsp_pop 
39e5				endm 
# End of macro FORTH_DSP_POP
39e5			 
39e5 cd 7a 18				call dumpcont	; skip old style of param parsing	 
39e8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
39e9					NEXTW 
39e9 c3 63 1d			jp macro_next 
39ec				endm 
# End of macro NEXTW
39ec			.CDUMP: 
39ec				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
39ec 38				db WORD_SYS_CORE+36             
39ed 1c 3a			dw .DAT            
39ef 06				db 5 + 1 
39f0 .. 00			db "CDUMP",0              
39f6				endm 
# End of macro CWHEAD
39f6			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
39f6					if DEBUG_FORTH_WORDS_KEY 
39f6						DMARK "CDP" 
39f6 f5				push af  
39f7 3a 0b 3a			ld a, (.dmark)  
39fa 32 71 ee			ld (debug_mark),a  
39fd 3a 0c 3a			ld a, (.dmark+1)  
3a00 32 72 ee			ld (debug_mark+1),a  
3a03 3a 0d 3a			ld a, (.dmark+2)  
3a06 32 73 ee			ld (debug_mark+2),a  
3a09 18 03			jr .pastdmark  
3a0b ..			.dmark: db "CDP"  
3a0e f1			.pastdmark: pop af  
3a0f			endm  
# End of macro DMARK
3a0f						CALLMONITOR 
3a0f cd 6d 14			call break_point_state  
3a12				endm  
# End of macro CALLMONITOR
3a12					endif 
3a12 cd 97 09				call clear_display 
3a15 cd 7a 18				call dumpcont	 
3a18 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3a19					NEXTW 
3a19 c3 63 1d			jp macro_next 
3a1c				endm 
# End of macro NEXTW
3a1c			 
3a1c			 
3a1c			 
3a1c			 
3a1c			.DAT: 
3a1c				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3a1c 3d				db WORD_SYS_CORE+41             
3a1d 72 3a			dw .HOME            
3a1f 03				db 2 + 1 
3a20 .. 00			db "AT",0              
3a23				endm 
# End of macro CWHEAD
3a23			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3a23					if DEBUG_FORTH_WORDS_KEY 
3a23						DMARK "AT." 
3a23 f5				push af  
3a24 3a 38 3a			ld a, (.dmark)  
3a27 32 71 ee			ld (debug_mark),a  
3a2a 3a 39 3a			ld a, (.dmark+1)  
3a2d 32 72 ee			ld (debug_mark+1),a  
3a30 3a 3a 3a			ld a, (.dmark+2)  
3a33 32 73 ee			ld (debug_mark+2),a  
3a36 18 03			jr .pastdmark  
3a38 ..			.dmark: db "AT."  
3a3b f1			.pastdmark: pop af  
3a3c			endm  
# End of macro DMARK
3a3c						CALLMONITOR 
3a3c cd 6d 14			call break_point_state  
3a3f				endm  
# End of macro CALLMONITOR
3a3f					endif 
3a3f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a3f cd f1 1b			call macro_dsp_valuehl 
3a42				endm 
# End of macro FORTH_DSP_VALUEHL
3a42			 
3a42			 
3a42					; TODO save cursor row 
3a42 7d					ld a,l 
3a43 fe 02				cp 2 
3a45 20 04				jr nz, .crow3 
3a47 3e 28				ld a, display_row_2 
3a49 18 12				jr .ccol1 
3a4b fe 03		.crow3:		cp 3 
3a4d 20 04				jr nz, .crow4 
3a4f 3e 50				ld a, display_row_3 
3a51 18 0a				jr .ccol1 
3a53 fe 04		.crow4:		cp 4 
3a55 20 04				jr nz, .crow1 
3a57 3e 78				ld a, display_row_4 
3a59 18 02				jr .ccol1 
3a5b 3e 00		.crow1:		ld a,display_row_1 
3a5d f5			.ccol1:		push af			; got row offset 
3a5e 6f					ld l,a 
3a5f 26 00				ld h,0 
3a61					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a61 cd a9 1c			call macro_forth_dsp_pop 
3a64				endm 
# End of macro FORTH_DSP_POP
3a64					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a64 cd f1 1b			call macro_dsp_valuehl 
3a67				endm 
# End of macro FORTH_DSP_VALUEHL
3a67					; TODO save cursor col 
3a67 f1					pop af 
3a68 85					add l		; add col offset 
3a69 32 40 eb				ld (f_cursor_ptr), a 
3a6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a6c cd a9 1c			call macro_forth_dsp_pop 
3a6f				endm 
# End of macro FORTH_DSP_POP
3a6f			 
3a6f					; calculate  
3a6f			 
3a6f					NEXTW 
3a6f c3 63 1d			jp macro_next 
3a72				endm 
# End of macro NEXTW
3a72			 
3a72			 
3a72			.HOME: 
3a72				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3a72 41				db WORD_SYS_CORE+45             
3a73 9f 3a			dw .SPACE            
3a75 05				db 4 + 1 
3a76 .. 00			db "HOME",0              
3a7b				endm 
# End of macro CWHEAD
3a7b			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3a7b					if DEBUG_FORTH_WORDS_KEY 
3a7b						DMARK "HOM" 
3a7b f5				push af  
3a7c 3a 90 3a			ld a, (.dmark)  
3a7f 32 71 ee			ld (debug_mark),a  
3a82 3a 91 3a			ld a, (.dmark+1)  
3a85 32 72 ee			ld (debug_mark+1),a  
3a88 3a 92 3a			ld a, (.dmark+2)  
3a8b 32 73 ee			ld (debug_mark+2),a  
3a8e 18 03			jr .pastdmark  
3a90 ..			.dmark: db "HOM"  
3a93 f1			.pastdmark: pop af  
3a94			endm  
# End of macro DMARK
3a94						CALLMONITOR 
3a94 cd 6d 14			call break_point_state  
3a97				endm  
# End of macro CALLMONITOR
3a97					endif 
3a97 3e 00		.home:		ld a, 0		; and home cursor 
3a99 32 40 eb				ld (f_cursor_ptr), a 
3a9c					NEXTW 
3a9c c3 63 1d			jp macro_next 
3a9f				endm 
# End of macro NEXTW
3a9f			 
3a9f			 
3a9f			.SPACE: 
3a9f				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3a9f 46				db WORD_SYS_CORE+50             
3aa0 cd 3a			dw .SPACES            
3aa2 03				db 2 + 1 
3aa3 .. 00			db "BL",0              
3aa6				endm 
# End of macro CWHEAD
3aa6			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3aa6					if DEBUG_FORTH_WORDS_KEY 
3aa6						DMARK "BL." 
3aa6 f5				push af  
3aa7 3a bb 3a			ld a, (.dmark)  
3aaa 32 71 ee			ld (debug_mark),a  
3aad 3a bc 3a			ld a, (.dmark+1)  
3ab0 32 72 ee			ld (debug_mark+1),a  
3ab3 3a bd 3a			ld a, (.dmark+2)  
3ab6 32 73 ee			ld (debug_mark+2),a  
3ab9 18 03			jr .pastdmark  
3abb ..			.dmark: db "BL."  
3abe f1			.pastdmark: pop af  
3abf			endm  
# End of macro DMARK
3abf						CALLMONITOR 
3abf cd 6d 14			call break_point_state  
3ac2				endm  
# End of macro CALLMONITOR
3ac2					endif 
3ac2 21 cb 3a				ld hl, .blstr 
3ac5 cd 68 1a				call forth_push_str 
3ac8					 
3ac8				       NEXTW 
3ac8 c3 63 1d			jp macro_next 
3acb				endm 
# End of macro NEXTW
3acb			 
3acb .. 00		.blstr: db " ", 0 
3acd			 
3acd			.SPACES: 
3acd				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3acd 47				db WORD_SYS_CORE+51             
3ace 68 3b			dw .SCROLL            
3ad0 07				db 6 + 1 
3ad1 .. 00			db "SPACES",0              
3ad8				endm 
# End of macro CWHEAD
3ad8			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3ad8					if DEBUG_FORTH_WORDS_KEY 
3ad8						DMARK "SPS" 
3ad8 f5				push af  
3ad9 3a ed 3a			ld a, (.dmark)  
3adc 32 71 ee			ld (debug_mark),a  
3adf 3a ee 3a			ld a, (.dmark+1)  
3ae2 32 72 ee			ld (debug_mark+1),a  
3ae5 3a ef 3a			ld a, (.dmark+2)  
3ae8 32 73 ee			ld (debug_mark+2),a  
3aeb 18 03			jr .pastdmark  
3aed ..			.dmark: db "SPS"  
3af0 f1			.pastdmark: pop af  
3af1			endm  
# End of macro DMARK
3af1						CALLMONITOR 
3af1 cd 6d 14			call break_point_state  
3af4				endm  
# End of macro CALLMONITOR
3af4					endif 
3af4			 
3af4			 
3af4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3af4 cd f1 1b			call macro_dsp_valuehl 
3af7				endm 
# End of macro FORTH_DSP_VALUEHL
3af7			 
3af7			;		push hl    ; u 
3af7					if DEBUG_FORTH_WORDS 
3af7						DMARK "SPA" 
3af7 f5				push af  
3af8 3a 0c 3b			ld a, (.dmark)  
3afb 32 71 ee			ld (debug_mark),a  
3afe 3a 0d 3b			ld a, (.dmark+1)  
3b01 32 72 ee			ld (debug_mark+1),a  
3b04 3a 0e 3b			ld a, (.dmark+2)  
3b07 32 73 ee			ld (debug_mark+2),a  
3b0a 18 03			jr .pastdmark  
3b0c ..			.dmark: db "SPA"  
3b0f f1			.pastdmark: pop af  
3b10			endm  
# End of macro DMARK
3b10						CALLMONITOR 
3b10 cd 6d 14			call break_point_state  
3b13				endm  
# End of macro CALLMONITOR
3b13					endif 
3b13			 
3b13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b13 cd a9 1c			call macro_forth_dsp_pop 
3b16				endm 
# End of macro FORTH_DSP_POP
3b16			;		pop hl 
3b16 4d					ld c, l 
3b17 06 00				ld b, 0 
3b19 21 57 e3				ld hl, scratch  
3b1c			 
3b1c					if DEBUG_FORTH_WORDS 
3b1c						DMARK "SP2" 
3b1c f5				push af  
3b1d 3a 31 3b			ld a, (.dmark)  
3b20 32 71 ee			ld (debug_mark),a  
3b23 3a 32 3b			ld a, (.dmark+1)  
3b26 32 72 ee			ld (debug_mark+1),a  
3b29 3a 33 3b			ld a, (.dmark+2)  
3b2c 32 73 ee			ld (debug_mark+2),a  
3b2f 18 03			jr .pastdmark  
3b31 ..			.dmark: db "SP2"  
3b34 f1			.pastdmark: pop af  
3b35			endm  
# End of macro DMARK
3b35						CALLMONITOR 
3b35 cd 6d 14			call break_point_state  
3b38				endm  
# End of macro CALLMONITOR
3b38					endif 
3b38 3e 20				ld a, ' ' 
3b3a c5			.spaces1:	push bc 
3b3b 77					ld (hl),a 
3b3c 23					inc hl 
3b3d c1					pop bc 
3b3e 10 fa				djnz .spaces1 
3b40 3e 00				ld a,0 
3b42 77					ld (hl),a 
3b43 21 57 e3				ld hl, scratch 
3b46					if DEBUG_FORTH_WORDS 
3b46						DMARK "SP3" 
3b46 f5				push af  
3b47 3a 5b 3b			ld a, (.dmark)  
3b4a 32 71 ee			ld (debug_mark),a  
3b4d 3a 5c 3b			ld a, (.dmark+1)  
3b50 32 72 ee			ld (debug_mark+1),a  
3b53 3a 5d 3b			ld a, (.dmark+2)  
3b56 32 73 ee			ld (debug_mark+2),a  
3b59 18 03			jr .pastdmark  
3b5b ..			.dmark: db "SP3"  
3b5e f1			.pastdmark: pop af  
3b5f			endm  
# End of macro DMARK
3b5f						CALLMONITOR 
3b5f cd 6d 14			call break_point_state  
3b62				endm  
# End of macro CALLMONITOR
3b62					endif 
3b62 cd 63 1b				call forth_apush 
3b65			 
3b65				       NEXTW 
3b65 c3 63 1d			jp macro_next 
3b68				endm 
# End of macro NEXTW
3b68			 
3b68			 
3b68			 
3b68			.SCROLL: 
3b68				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3b68 53				db WORD_SYS_CORE+63             
3b69 95 3b			dw .SCROLLD            
3b6b 07				db 6 + 1 
3b6c .. 00			db "SCROLL",0              
3b73				endm 
# End of macro CWHEAD
3b73			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3b73					if DEBUG_FORTH_WORDS_KEY 
3b73						DMARK "SCR" 
3b73 f5				push af  
3b74 3a 88 3b			ld a, (.dmark)  
3b77 32 71 ee			ld (debug_mark),a  
3b7a 3a 89 3b			ld a, (.dmark+1)  
3b7d 32 72 ee			ld (debug_mark+1),a  
3b80 3a 8a 3b			ld a, (.dmark+2)  
3b83 32 73 ee			ld (debug_mark+2),a  
3b86 18 03			jr .pastdmark  
3b88 ..			.dmark: db "SCR"  
3b8b f1			.pastdmark: pop af  
3b8c			endm  
# End of macro DMARK
3b8c						CALLMONITOR 
3b8c cd 6d 14			call break_point_state  
3b8f				endm  
# End of macro CALLMONITOR
3b8f					endif 
3b8f			 
3b8f cd 59 09			call scroll_up 
3b92			;	call update_display 
3b92			 
3b92					NEXTW 
3b92 c3 63 1d			jp macro_next 
3b95				endm 
# End of macro NEXTW
3b95			 
3b95			 
3b95			 
3b95			;		; get dir 
3b95			; 
3b95			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b95			; 
3b95			;		push hl 
3b95			; 
3b95			;		; destroy value TOS 
3b95			; 
3b95			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b95			; 
3b95			;		; get count 
3b95			; 
3b95			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b95			; 
3b95			;		push hl 
3b95			; 
3b95			;		; destroy value TOS 
3b95			; 
3b95			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b95			; 
3b95			;		; one value on hl get other one back 
3b95			; 
3b95			;		pop bc    ; count 
3b95			; 
3b95			;		pop de   ; dir 
3b95			; 
3b95			; 
3b95			;		ld b, c 
3b95			; 
3b95			;.scrolldir:     push bc 
3b95			;		push de 
3b95			; 
3b95			;		ld a, 0 
3b95			;		cp e 
3b95			;		jr z, .scrollup  
3b95			;		call scroll_down 
3b95			;		jr .scrollnext 
3b95			;.scrollup:	call scroll_up 
3b95			; 
3b95			;		 
3b95			;.scrollnext: 
3b95			;		pop de 
3b95			;		pop bc 
3b95			;		djnz .scrolldir 
3b95			; 
3b95			; 
3b95			; 
3b95			; 
3b95			; 
3b95			;		NEXTW 
3b95			 
3b95			.SCROLLD: 
3b95				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3b95 53				db WORD_SYS_CORE+63             
3b96 c3 3b			dw .ATQ            
3b98 08				db 7 + 1 
3b99 .. 00			db "SCROLLD",0              
3ba1				endm 
# End of macro CWHEAD
3ba1			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3ba1					if DEBUG_FORTH_WORDS_KEY 
3ba1						DMARK "SCD" 
3ba1 f5				push af  
3ba2 3a b6 3b			ld a, (.dmark)  
3ba5 32 71 ee			ld (debug_mark),a  
3ba8 3a b7 3b			ld a, (.dmark+1)  
3bab 32 72 ee			ld (debug_mark+1),a  
3bae 3a b8 3b			ld a, (.dmark+2)  
3bb1 32 73 ee			ld (debug_mark+2),a  
3bb4 18 03			jr .pastdmark  
3bb6 ..			.dmark: db "SCD"  
3bb9 f1			.pastdmark: pop af  
3bba			endm  
# End of macro DMARK
3bba						CALLMONITOR 
3bba cd 6d 14			call break_point_state  
3bbd				endm  
# End of macro CALLMONITOR
3bbd					endif 
3bbd			 
3bbd cd 7d 09			call scroll_down 
3bc0			;	call update_display 
3bc0			 
3bc0					NEXTW 
3bc0 c3 63 1d			jp macro_next 
3bc3				endm 
# End of macro NEXTW
3bc3			 
3bc3			 
3bc3			.ATQ: 
3bc3				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3bc3 62				db WORD_SYS_CORE+78             
3bc4 21 3c			dw .AUTODSP            
3bc6 04				db 3 + 1 
3bc7 .. 00			db "AT@",0              
3bcb				endm 
# End of macro CWHEAD
3bcb			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3bcb					if DEBUG_FORTH_WORDS_KEY 
3bcb						DMARK "ATA" 
3bcb f5				push af  
3bcc 3a e0 3b			ld a, (.dmark)  
3bcf 32 71 ee			ld (debug_mark),a  
3bd2 3a e1 3b			ld a, (.dmark+1)  
3bd5 32 72 ee			ld (debug_mark+1),a  
3bd8 3a e2 3b			ld a, (.dmark+2)  
3bdb 32 73 ee			ld (debug_mark+2),a  
3bde 18 03			jr .pastdmark  
3be0 ..			.dmark: db "ATA"  
3be3 f1			.pastdmark: pop af  
3be4			endm  
# End of macro DMARK
3be4						CALLMONITOR 
3be4 cd 6d 14			call break_point_state  
3be7				endm  
# End of macro CALLMONITOR
3be7					endif 
3be7			 
3be7			 
3be7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3be7 cd f1 1b			call macro_dsp_valuehl 
3bea				endm 
# End of macro FORTH_DSP_VALUEHL
3bea			 
3bea					; TODO save cursor row 
3bea 7d					ld a,l 
3beb fe 02				cp 2 
3bed 20 04				jr nz, .crow3aq 
3bef 3e 28				ld a, display_row_2 
3bf1 18 12				jr .ccol1aq 
3bf3 fe 03		.crow3aq:		cp 3 
3bf5 20 04				jr nz, .crow4aq 
3bf7 3e 50				ld a, display_row_3 
3bf9 18 0a				jr .ccol1aq 
3bfb fe 04		.crow4aq:		cp 4 
3bfd 20 04				jr nz, .crow1aq 
3bff 3e 78				ld a, display_row_4 
3c01 18 02				jr .ccol1aq 
3c03 3e 00		.crow1aq:		ld a,display_row_1 
3c05 f5			.ccol1aq:		push af			; got row offset 
3c06 6f					ld l,a 
3c07 26 00				ld h,0 
3c09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c09 cd a9 1c			call macro_forth_dsp_pop 
3c0c				endm 
# End of macro FORTH_DSP_POP
3c0c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c0c cd f1 1b			call macro_dsp_valuehl 
3c0f				endm 
# End of macro FORTH_DSP_VALUEHL
3c0f					; TODO save cursor col 
3c0f f1					pop af 
3c10 85					add l		; add col offset 
3c11			 
3c11					; add current frame buffer address 
3c11 2a d2 eb				ld hl, (display_fb_active) 
3c14 cd c4 0b				call addatohl 
3c17			 
3c17			 
3c17			 
3c17			 
3c17					; get char frame buffer location offset in hl 
3c17			 
3c17 7e					ld a,(hl) 
3c18 26 00				ld h, 0 
3c1a 6f					ld l, a 
3c1b			 
3c1b cd fa 19				call forth_push_numhl 
3c1e			 
3c1e			 
3c1e					NEXTW 
3c1e c3 63 1d			jp macro_next 
3c21				endm 
# End of macro NEXTW
3c21			 
3c21			.AUTODSP: 
3c21				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3c21 63				db WORD_SYS_CORE+79             
3c22 37 3c			dw .MENU            
3c24 05				db 4 + 1 
3c25 .. 00			db "ADSP",0              
3c2a				endm 
# End of macro CWHEAD
3c2a			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3c2a			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3c2a			 
3c2a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c2a cd f1 1b			call macro_dsp_valuehl 
3c2d				endm 
# End of macro FORTH_DSP_VALUEHL
3c2d			 
3c2d			;		push hl 
3c2d			 
3c2d					; destroy value TOS 
3c2d			 
3c2d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c2d cd a9 1c			call macro_forth_dsp_pop 
3c30				endm 
# End of macro FORTH_DSP_POP
3c30			 
3c30			;		pop hl 
3c30			 
3c30 7d					ld a,l 
3c31 32 1e eb				ld (cli_autodisplay), a 
3c34				       NEXTW 
3c34 c3 63 1d			jp macro_next 
3c37				endm 
# End of macro NEXTW
3c37			 
3c37			.MENU: 
3c37				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3c37 70				db WORD_SYS_CORE+92             
3c38 e0 3c			dw .ENDDISPLAY            
3c3a 05				db 4 + 1 
3c3b .. 00			db "MENU",0              
3c40				endm 
# End of macro CWHEAD
3c40			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3c40			 
3c40			;		; get number of items on the stack 
3c40			; 
3c40				 
3c40					FORTH_DSP_VALUEHL 
3c40 cd f1 1b			call macro_dsp_valuehl 
3c43				endm 
# End of macro FORTH_DSP_VALUEHL
3c43				 
3c43					if DEBUG_FORTH_WORDS_KEY 
3c43						DMARK "MNU" 
3c43 f5				push af  
3c44 3a 58 3c			ld a, (.dmark)  
3c47 32 71 ee			ld (debug_mark),a  
3c4a 3a 59 3c			ld a, (.dmark+1)  
3c4d 32 72 ee			ld (debug_mark+1),a  
3c50 3a 5a 3c			ld a, (.dmark+2)  
3c53 32 73 ee			ld (debug_mark+2),a  
3c56 18 03			jr .pastdmark  
3c58 ..			.dmark: db "MNU"  
3c5b f1			.pastdmark: pop af  
3c5c			endm  
# End of macro DMARK
3c5c						CALLMONITOR 
3c5c cd 6d 14			call break_point_state  
3c5f				endm  
# End of macro CALLMONITOR
3c5f					endif 
3c5f			 
3c5f 45					ld b, l	 
3c60 05					dec b 
3c61			 
3c61					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c61 cd a9 1c			call macro_forth_dsp_pop 
3c64				endm 
# End of macro FORTH_DSP_POP
3c64			 
3c64			 
3c64					; go directly through the stack to pluck out the string pointers and build an array 
3c64			 
3c64			;		FORTH_DSP 
3c64			 
3c64					; hl contains top most stack item 
3c64				 
3c64 11 57 e3				ld de, scratch 
3c67			 
3c67			.mbuild: 
3c67			 
3c67					FORTH_DSP_VALUEHL 
3c67 cd f1 1b			call macro_dsp_valuehl 
3c6a				endm 
# End of macro FORTH_DSP_VALUEHL
3c6a			 
3c6a					if DEBUG_FORTH_WORDS 
3c6a						DMARK "MN3" 
3c6a f5				push af  
3c6b 3a 7f 3c			ld a, (.dmark)  
3c6e 32 71 ee			ld (debug_mark),a  
3c71 3a 80 3c			ld a, (.dmark+1)  
3c74 32 72 ee			ld (debug_mark+1),a  
3c77 3a 81 3c			ld a, (.dmark+2)  
3c7a 32 73 ee			ld (debug_mark+2),a  
3c7d 18 03			jr .pastdmark  
3c7f ..			.dmark: db "MN3"  
3c82 f1			.pastdmark: pop af  
3c83			endm  
# End of macro DMARK
3c83						CALLMONITOR 
3c83 cd 6d 14			call break_point_state  
3c86				endm  
# End of macro CALLMONITOR
3c86					endif 
3c86 eb					ex de, hl 
3c87 73					ld (hl), e 
3c88 23					inc hl 
3c89 72					ld (hl), d 
3c8a 23					inc hl 
3c8b eb					ex de, hl 
3c8c			 
3c8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c8c cd a9 1c			call macro_forth_dsp_pop 
3c8f				endm 
# End of macro FORTH_DSP_POP
3c8f			 
3c8f 10 d6				djnz .mbuild 
3c91			 
3c91					; done add term 
3c91			 
3c91 eb					ex de, hl 
3c92 36 00				ld (hl), 0 
3c94 23					inc hl 
3c95 36 00				ld (hl), 0 
3c97			 
3c97				 
3c97					 
3c97 21 57 e3				ld hl, scratch 
3c9a			 
3c9a					if DEBUG_FORTH_WORDS 
3c9a						DMARK "MNx" 
3c9a f5				push af  
3c9b 3a af 3c			ld a, (.dmark)  
3c9e 32 71 ee			ld (debug_mark),a  
3ca1 3a b0 3c			ld a, (.dmark+1)  
3ca4 32 72 ee			ld (debug_mark+1),a  
3ca7 3a b1 3c			ld a, (.dmark+2)  
3caa 32 73 ee			ld (debug_mark+2),a  
3cad 18 03			jr .pastdmark  
3caf ..			.dmark: db "MNx"  
3cb2 f1			.pastdmark: pop af  
3cb3			endm  
# End of macro DMARK
3cb3						CALLMONITOR 
3cb3 cd 6d 14			call break_point_state  
3cb6				endm  
# End of macro CALLMONITOR
3cb6					endif 
3cb6			 
3cb6			 
3cb6			 
3cb6 3e 00				ld a, 0 
3cb8 cd c8 09				call menu 
3cbb			 
3cbb			 
3cbb 6f					ld l, a 
3cbc 26 00				ld h, 0 
3cbe			 
3cbe					if DEBUG_FORTH_WORDS 
3cbe						DMARK "MNr" 
3cbe f5				push af  
3cbf 3a d3 3c			ld a, (.dmark)  
3cc2 32 71 ee			ld (debug_mark),a  
3cc5 3a d4 3c			ld a, (.dmark+1)  
3cc8 32 72 ee			ld (debug_mark+1),a  
3ccb 3a d5 3c			ld a, (.dmark+2)  
3cce 32 73 ee			ld (debug_mark+2),a  
3cd1 18 03			jr .pastdmark  
3cd3 ..			.dmark: db "MNr"  
3cd6 f1			.pastdmark: pop af  
3cd7			endm  
# End of macro DMARK
3cd7						CALLMONITOR 
3cd7 cd 6d 14			call break_point_state  
3cda				endm  
# End of macro CALLMONITOR
3cda					endif 
3cda			 
3cda cd fa 19				call forth_push_numhl 
3cdd			 
3cdd			 
3cdd			 
3cdd			 
3cdd				       NEXTW 
3cdd c3 63 1d			jp macro_next 
3ce0				endm 
# End of macro NEXTW
3ce0			 
3ce0			 
3ce0			.ENDDISPLAY: 
3ce0			 
3ce0			; eof 
# End of file forth_words_display.asm
3ce0			include "forth_words_str.asm" 
3ce0			 
3ce0			; | ## String Words 
3ce0			 
3ce0			.PTR:   
3ce0			 
3ce0				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3ce0 48				db WORD_SYS_CORE+52             
3ce1 0d 3d			dw .STYPE            
3ce3 04				db 3 + 1 
3ce4 .. 00			db "PTR",0              
3ce8				endm 
# End of macro CWHEAD
3ce8			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3ce8			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3ce8			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3ce8			 
3ce8					if DEBUG_FORTH_WORDS_KEY 
3ce8						DMARK "PTR" 
3ce8 f5				push af  
3ce9 3a fd 3c			ld a, (.dmark)  
3cec 32 71 ee			ld (debug_mark),a  
3cef 3a fe 3c			ld a, (.dmark+1)  
3cf2 32 72 ee			ld (debug_mark+1),a  
3cf5 3a ff 3c			ld a, (.dmark+2)  
3cf8 32 73 ee			ld (debug_mark+2),a  
3cfb 18 03			jr .pastdmark  
3cfd ..			.dmark: db "PTR"  
3d00 f1			.pastdmark: pop af  
3d01			endm  
# End of macro DMARK
3d01						CALLMONITOR 
3d01 cd 6d 14			call break_point_state  
3d04				endm  
# End of macro CALLMONITOR
3d04					endif 
3d04					FORTH_DSP_VALUEHL 
3d04 cd f1 1b			call macro_dsp_valuehl 
3d07				endm 
# End of macro FORTH_DSP_VALUEHL
3d07 cd fa 19				call forth_push_numhl 
3d0a			 
3d0a			 
3d0a					NEXTW 
3d0a c3 63 1d			jp macro_next 
3d0d				endm 
# End of macro NEXTW
3d0d			.STYPE: 
3d0d				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3d0d 48				db WORD_SYS_CORE+52             
3d0e 5c 3d			dw .UPPER            
3d10 06				db 5 + 1 
3d11 .. 00			db "STYPE",0              
3d17				endm 
# End of macro CWHEAD
3d17			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3d17					if DEBUG_FORTH_WORDS_KEY 
3d17						DMARK "STY" 
3d17 f5				push af  
3d18 3a 2c 3d			ld a, (.dmark)  
3d1b 32 71 ee			ld (debug_mark),a  
3d1e 3a 2d 3d			ld a, (.dmark+1)  
3d21 32 72 ee			ld (debug_mark+1),a  
3d24 3a 2e 3d			ld a, (.dmark+2)  
3d27 32 73 ee			ld (debug_mark+2),a  
3d2a 18 03			jr .pastdmark  
3d2c ..			.dmark: db "STY"  
3d2f f1			.pastdmark: pop af  
3d30			endm  
# End of macro DMARK
3d30						CALLMONITOR 
3d30 cd 6d 14			call break_point_state  
3d33				endm  
# End of macro CALLMONITOR
3d33					endif 
3d33					FORTH_DSP 
3d33 cd b7 1b			call macro_forth_dsp 
3d36				endm 
# End of macro FORTH_DSP
3d36					;v5 FORTH_DSP_VALUE 
3d36			 
3d36 7e					ld a, (hl) 
3d37			 
3d37 f5					push af 
3d38			 
3d38			; Dont destroy TOS		FORTH_DSP_POP 
3d38			 
3d38 f1					pop af 
3d39			 
3d39 fe 01				cp DS_TYPE_STR 
3d3b 28 09				jr z, .typestr 
3d3d			 
3d3d fe 02				cp DS_TYPE_INUM 
3d3f 28 0a				jr z, .typeinum 
3d41			 
3d41 21 5a 3d				ld hl, .tna 
3d44 18 0a				jr .tpush 
3d46			 
3d46 21 56 3d		.typestr:	ld hl, .tstr 
3d49 18 05				jr .tpush 
3d4b 21 58 3d		.typeinum:	ld hl, .tinum 
3d4e 18 00				jr .tpush 
3d50			 
3d50			.tpush: 
3d50			 
3d50 cd 68 1a				call forth_push_str 
3d53			 
3d53					NEXTW 
3d53 c3 63 1d			jp macro_next 
3d56				endm 
# End of macro NEXTW
3d56 .. 00		.tstr:	db "s",0 
3d58 .. 00		.tinum:  db "i",0 
3d5a .. 00		.tna:   db "?", 0 
3d5c			 
3d5c			 
3d5c			.UPPER: 
3d5c				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3d5c 48				db WORD_SYS_CORE+52             
3d5d 97 3d			dw .LOWER            
3d5f 06				db 5 + 1 
3d60 .. 00			db "UPPER",0              
3d66				endm 
# End of macro CWHEAD
3d66			; | UPPER ( s -- s ) Upper case string s  | DONE 
3d66					if DEBUG_FORTH_WORDS_KEY 
3d66						DMARK "UPR" 
3d66 f5				push af  
3d67 3a 7b 3d			ld a, (.dmark)  
3d6a 32 71 ee			ld (debug_mark),a  
3d6d 3a 7c 3d			ld a, (.dmark+1)  
3d70 32 72 ee			ld (debug_mark+1),a  
3d73 3a 7d 3d			ld a, (.dmark+2)  
3d76 32 73 ee			ld (debug_mark+2),a  
3d79 18 03			jr .pastdmark  
3d7b ..			.dmark: db "UPR"  
3d7e f1			.pastdmark: pop af  
3d7f			endm  
# End of macro DMARK
3d7f						CALLMONITOR 
3d7f cd 6d 14			call break_point_state  
3d82				endm  
# End of macro CALLMONITOR
3d82					endif 
3d82			 
3d82					FORTH_DSP 
3d82 cd b7 1b			call macro_forth_dsp 
3d85				endm 
# End of macro FORTH_DSP
3d85					 
3d85			; TODO check is string type 
3d85			 
3d85					FORTH_DSP_VALUEHL 
3d85 cd f1 1b			call macro_dsp_valuehl 
3d88				endm 
# End of macro FORTH_DSP_VALUEHL
3d88			; get pointer to string in hl 
3d88			 
3d88 7e			.toup:		ld a, (hl) 
3d89 fe 00				cp 0 
3d8b 28 07				jr z, .toupdone 
3d8d			 
3d8d cd 31 0f				call to_upper 
3d90			 
3d90 77					ld (hl), a 
3d91 23					inc hl 
3d92 18 f4				jr .toup 
3d94			 
3d94					 
3d94			 
3d94			 
3d94			; for each char convert to upper 
3d94					 
3d94			.toupdone: 
3d94			 
3d94			 
3d94					NEXTW 
3d94 c3 63 1d			jp macro_next 
3d97				endm 
# End of macro NEXTW
3d97			.LOWER: 
3d97				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3d97 48				db WORD_SYS_CORE+52             
3d98 d2 3d			dw .TCASE            
3d9a 06				db 5 + 1 
3d9b .. 00			db "LOWER",0              
3da1				endm 
# End of macro CWHEAD
3da1			; | LOWER ( s -- s ) Lower case string s  | DONE 
3da1					if DEBUG_FORTH_WORDS_KEY 
3da1						DMARK "LWR" 
3da1 f5				push af  
3da2 3a b6 3d			ld a, (.dmark)  
3da5 32 71 ee			ld (debug_mark),a  
3da8 3a b7 3d			ld a, (.dmark+1)  
3dab 32 72 ee			ld (debug_mark+1),a  
3dae 3a b8 3d			ld a, (.dmark+2)  
3db1 32 73 ee			ld (debug_mark+2),a  
3db4 18 03			jr .pastdmark  
3db6 ..			.dmark: db "LWR"  
3db9 f1			.pastdmark: pop af  
3dba			endm  
# End of macro DMARK
3dba						CALLMONITOR 
3dba cd 6d 14			call break_point_state  
3dbd				endm  
# End of macro CALLMONITOR
3dbd					endif 
3dbd			 
3dbd					FORTH_DSP 
3dbd cd b7 1b			call macro_forth_dsp 
3dc0				endm 
# End of macro FORTH_DSP
3dc0					 
3dc0			; TODO check is string type 
3dc0			 
3dc0					FORTH_DSP_VALUEHL 
3dc0 cd f1 1b			call macro_dsp_valuehl 
3dc3				endm 
# End of macro FORTH_DSP_VALUEHL
3dc3			; get pointer to string in hl 
3dc3			 
3dc3 7e			.tolow:		ld a, (hl) 
3dc4 fe 00				cp 0 
3dc6 28 07				jr z, .tolowdone 
3dc8			 
3dc8 cd 3a 0f				call to_lower 
3dcb			 
3dcb 77					ld (hl), a 
3dcc 23					inc hl 
3dcd 18 f4				jr .tolow 
3dcf			 
3dcf					 
3dcf			 
3dcf			 
3dcf			; for each char convert to low 
3dcf					 
3dcf			.tolowdone: 
3dcf					NEXTW 
3dcf c3 63 1d			jp macro_next 
3dd2				endm 
# End of macro NEXTW
3dd2			.TCASE: 
3dd2				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3dd2 48				db WORD_SYS_CORE+52             
3dd3 08 3f			dw .SUBSTR            
3dd5 06				db 5 + 1 
3dd6 .. 00			db "TCASE",0              
3ddc				endm 
# End of macro CWHEAD
3ddc			; | TCASE ( s -- s ) Title case string s  | DONE 
3ddc					if DEBUG_FORTH_WORDS_KEY 
3ddc						DMARK "TCS" 
3ddc f5				push af  
3ddd 3a f1 3d			ld a, (.dmark)  
3de0 32 71 ee			ld (debug_mark),a  
3de3 3a f2 3d			ld a, (.dmark+1)  
3de6 32 72 ee			ld (debug_mark+1),a  
3de9 3a f3 3d			ld a, (.dmark+2)  
3dec 32 73 ee			ld (debug_mark+2),a  
3def 18 03			jr .pastdmark  
3df1 ..			.dmark: db "TCS"  
3df4 f1			.pastdmark: pop af  
3df5			endm  
# End of macro DMARK
3df5						CALLMONITOR 
3df5 cd 6d 14			call break_point_state  
3df8				endm  
# End of macro CALLMONITOR
3df8					endif 
3df8			 
3df8					FORTH_DSP 
3df8 cd b7 1b			call macro_forth_dsp 
3dfb				endm 
# End of macro FORTH_DSP
3dfb					 
3dfb			; TODO check is string type 
3dfb			 
3dfb					FORTH_DSP_VALUEHL 
3dfb cd f1 1b			call macro_dsp_valuehl 
3dfe				endm 
# End of macro FORTH_DSP_VALUEHL
3dfe			; get pointer to string in hl 
3dfe			 
3dfe					if DEBUG_FORTH_WORDS 
3dfe						DMARK "TC1" 
3dfe f5				push af  
3dff 3a 13 3e			ld a, (.dmark)  
3e02 32 71 ee			ld (debug_mark),a  
3e05 3a 14 3e			ld a, (.dmark+1)  
3e08 32 72 ee			ld (debug_mark+1),a  
3e0b 3a 15 3e			ld a, (.dmark+2)  
3e0e 32 73 ee			ld (debug_mark+2),a  
3e11 18 03			jr .pastdmark  
3e13 ..			.dmark: db "TC1"  
3e16 f1			.pastdmark: pop af  
3e17			endm  
# End of macro DMARK
3e17						CALLMONITOR 
3e17 cd 6d 14			call break_point_state  
3e1a				endm  
# End of macro CALLMONITOR
3e1a					endif 
3e1a			 
3e1a					; first time in turn to upper case first char 
3e1a			 
3e1a 7e					ld a, (hl) 
3e1b c3 a5 3e				jp .totsiptou 
3e1e			 
3e1e			 
3e1e 7e			.tot:		ld a, (hl) 
3e1f fe 00				cp 0 
3e21 ca e9 3e				jp z, .totdone 
3e24			 
3e24					if DEBUG_FORTH_WORDS 
3e24						DMARK "TC2" 
3e24 f5				push af  
3e25 3a 39 3e			ld a, (.dmark)  
3e28 32 71 ee			ld (debug_mark),a  
3e2b 3a 3a 3e			ld a, (.dmark+1)  
3e2e 32 72 ee			ld (debug_mark+1),a  
3e31 3a 3b 3e			ld a, (.dmark+2)  
3e34 32 73 ee			ld (debug_mark+2),a  
3e37 18 03			jr .pastdmark  
3e39 ..			.dmark: db "TC2"  
3e3c f1			.pastdmark: pop af  
3e3d			endm  
# End of macro DMARK
3e3d						CALLMONITOR 
3e3d cd 6d 14			call break_point_state  
3e40				endm  
# End of macro CALLMONITOR
3e40					endif 
3e40					; check to see if current char is a space 
3e40			 
3e40 fe 20				cp ' ' 
3e42 28 21				jr z, .totsp 
3e44 cd 3a 0f				call to_lower 
3e47					if DEBUG_FORTH_WORDS 
3e47						DMARK "TC3" 
3e47 f5				push af  
3e48 3a 5c 3e			ld a, (.dmark)  
3e4b 32 71 ee			ld (debug_mark),a  
3e4e 3a 5d 3e			ld a, (.dmark+1)  
3e51 32 72 ee			ld (debug_mark+1),a  
3e54 3a 5e 3e			ld a, (.dmark+2)  
3e57 32 73 ee			ld (debug_mark+2),a  
3e5a 18 03			jr .pastdmark  
3e5c ..			.dmark: db "TC3"  
3e5f f1			.pastdmark: pop af  
3e60			endm  
# End of macro DMARK
3e60						CALLMONITOR 
3e60 cd 6d 14			call break_point_state  
3e63				endm  
# End of macro CALLMONITOR
3e63					endif 
3e63 18 63				jr .totnxt 
3e65			 
3e65			.totsp:         ; on a space, find next char which should be upper 
3e65			 
3e65					if DEBUG_FORTH_WORDS 
3e65						DMARK "TC4" 
3e65 f5				push af  
3e66 3a 7a 3e			ld a, (.dmark)  
3e69 32 71 ee			ld (debug_mark),a  
3e6c 3a 7b 3e			ld a, (.dmark+1)  
3e6f 32 72 ee			ld (debug_mark+1),a  
3e72 3a 7c 3e			ld a, (.dmark+2)  
3e75 32 73 ee			ld (debug_mark+2),a  
3e78 18 03			jr .pastdmark  
3e7a ..			.dmark: db "TC4"  
3e7d f1			.pastdmark: pop af  
3e7e			endm  
# End of macro DMARK
3e7e						CALLMONITOR 
3e7e cd 6d 14			call break_point_state  
3e81				endm  
# End of macro CALLMONITOR
3e81					endif 
3e81					;; 
3e81			 
3e81 fe 20				cp ' ' 
3e83 20 20				jr nz, .totsiptou 
3e85 23					inc hl 
3e86 7e					ld a, (hl) 
3e87					if DEBUG_FORTH_WORDS 
3e87						DMARK "TC5" 
3e87 f5				push af  
3e88 3a 9c 3e			ld a, (.dmark)  
3e8b 32 71 ee			ld (debug_mark),a  
3e8e 3a 9d 3e			ld a, (.dmark+1)  
3e91 32 72 ee			ld (debug_mark+1),a  
3e94 3a 9e 3e			ld a, (.dmark+2)  
3e97 32 73 ee			ld (debug_mark+2),a  
3e9a 18 03			jr .pastdmark  
3e9c ..			.dmark: db "TC5"  
3e9f f1			.pastdmark: pop af  
3ea0			endm  
# End of macro DMARK
3ea0						CALLMONITOR 
3ea0 cd 6d 14			call break_point_state  
3ea3				endm  
# End of macro CALLMONITOR
3ea3					endif 
3ea3 18 c0				jr .totsp 
3ea5 fe 00		.totsiptou:    cp 0 
3ea7 28 40				jr z, .totdone 
3ea9					; not space and not zero term so upper case it 
3ea9 cd 31 0f				call to_upper 
3eac			 
3eac					if DEBUG_FORTH_WORDS 
3eac						DMARK "TC6" 
3eac f5				push af  
3ead 3a c1 3e			ld a, (.dmark)  
3eb0 32 71 ee			ld (debug_mark),a  
3eb3 3a c2 3e			ld a, (.dmark+1)  
3eb6 32 72 ee			ld (debug_mark+1),a  
3eb9 3a c3 3e			ld a, (.dmark+2)  
3ebc 32 73 ee			ld (debug_mark+2),a  
3ebf 18 03			jr .pastdmark  
3ec1 ..			.dmark: db "TC6"  
3ec4 f1			.pastdmark: pop af  
3ec5			endm  
# End of macro DMARK
3ec5						CALLMONITOR 
3ec5 cd 6d 14			call break_point_state  
3ec8				endm  
# End of macro CALLMONITOR
3ec8					endif 
3ec8			 
3ec8			 
3ec8			.totnxt: 
3ec8			 
3ec8 77					ld (hl), a 
3ec9 23					inc hl 
3eca					if DEBUG_FORTH_WORDS 
3eca						DMARK "TC7" 
3eca f5				push af  
3ecb 3a df 3e			ld a, (.dmark)  
3ece 32 71 ee			ld (debug_mark),a  
3ed1 3a e0 3e			ld a, (.dmark+1)  
3ed4 32 72 ee			ld (debug_mark+1),a  
3ed7 3a e1 3e			ld a, (.dmark+2)  
3eda 32 73 ee			ld (debug_mark+2),a  
3edd 18 03			jr .pastdmark  
3edf ..			.dmark: db "TC7"  
3ee2 f1			.pastdmark: pop af  
3ee3			endm  
# End of macro DMARK
3ee3						CALLMONITOR 
3ee3 cd 6d 14			call break_point_state  
3ee6				endm  
# End of macro CALLMONITOR
3ee6					endif 
3ee6 c3 1e 3e				jp .tot 
3ee9			 
3ee9					 
3ee9			 
3ee9			 
3ee9			; for each char convert to low 
3ee9					 
3ee9			.totdone: 
3ee9					if DEBUG_FORTH_WORDS 
3ee9						DMARK "TCd" 
3ee9 f5				push af  
3eea 3a fe 3e			ld a, (.dmark)  
3eed 32 71 ee			ld (debug_mark),a  
3ef0 3a ff 3e			ld a, (.dmark+1)  
3ef3 32 72 ee			ld (debug_mark+1),a  
3ef6 3a 00 3f			ld a, (.dmark+2)  
3ef9 32 73 ee			ld (debug_mark+2),a  
3efc 18 03			jr .pastdmark  
3efe ..			.dmark: db "TCd"  
3f01 f1			.pastdmark: pop af  
3f02			endm  
# End of macro DMARK
3f02						CALLMONITOR 
3f02 cd 6d 14			call break_point_state  
3f05				endm  
# End of macro CALLMONITOR
3f05					endif 
3f05					NEXTW 
3f05 c3 63 1d			jp macro_next 
3f08				endm 
# End of macro NEXTW
3f08			 
3f08			.SUBSTR: 
3f08				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3f08 48				db WORD_SYS_CORE+52             
3f09 66 3f			dw .LEFT            
3f0b 07				db 6 + 1 
3f0c .. 00			db "SUBSTR",0              
3f13				endm 
# End of macro CWHEAD
3f13			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3f13			 
3f13					if DEBUG_FORTH_WORDS_KEY 
3f13						DMARK "SST" 
3f13 f5				push af  
3f14 3a 28 3f			ld a, (.dmark)  
3f17 32 71 ee			ld (debug_mark),a  
3f1a 3a 29 3f			ld a, (.dmark+1)  
3f1d 32 72 ee			ld (debug_mark+1),a  
3f20 3a 2a 3f			ld a, (.dmark+2)  
3f23 32 73 ee			ld (debug_mark+2),a  
3f26 18 03			jr .pastdmark  
3f28 ..			.dmark: db "SST"  
3f2b f1			.pastdmark: pop af  
3f2c			endm  
# End of macro DMARK
3f2c						CALLMONITOR 
3f2c cd 6d 14			call break_point_state  
3f2f				endm  
# End of macro CALLMONITOR
3f2f					endif 
3f2f			; TODO check string type 
3f2f					FORTH_DSP_VALUEHL 
3f2f cd f1 1b			call macro_dsp_valuehl 
3f32				endm 
# End of macro FORTH_DSP_VALUEHL
3f32			 
3f32 e5					push hl      ; string length 
3f33			 
3f33					FORTH_DSP_POP 
3f33 cd a9 1c			call macro_forth_dsp_pop 
3f36				endm 
# End of macro FORTH_DSP_POP
3f36			 
3f36					FORTH_DSP_VALUEHL 
3f36 cd f1 1b			call macro_dsp_valuehl 
3f39				endm 
# End of macro FORTH_DSP_VALUEHL
3f39			 
3f39 e5					push hl     ; start char 
3f3a			 
3f3a					FORTH_DSP_POP 
3f3a cd a9 1c			call macro_forth_dsp_pop 
3f3d				endm 
# End of macro FORTH_DSP_POP
3f3d			 
3f3d			 
3f3d					FORTH_DSP_VALUE 
3f3d cd da 1b			call macro_forth_dsp_value 
3f40				endm 
# End of macro FORTH_DSP_VALUE
3f40			 
3f40 d1					pop de    ; get start post offset 
3f41			 
3f41 19					add hl, de    ; starting offset 
3f42			 
3f42 c1					pop bc 
3f43 c5					push bc      ; grab size of string 
3f44			 
3f44 e5					push hl    ; save string start  
3f45			 
3f45 26 00				ld h, 0 
3f47 69					ld l, c 
3f48 23					inc hl 
3f49 23					inc hl 
3f4a			 
3f4a cd 8b 10				call malloc 
3f4d				if DEBUG_FORTH_MALLOC_GUARD 
3f4d cc 95 45				call z,malloc_error 
3f50				endif 
3f50			 
3f50 eb					ex de, hl      ; save malloc area for string copy 
3f51 e1					pop hl    ; get back source 
3f52 c1					pop bc    ; get length of string back 
3f53			 
3f53 d5					push de    ; save malloc area for after we push 
3f54 ed b0				ldir     ; copy substr 
3f56			 
3f56			 
3f56 eb					ex de, hl 
3f57 3e 00				ld a, 0 
3f59 77					ld (hl), a   ; term substr 
3f5a			 
3f5a					 
3f5a e1					pop hl    ; get malloc so we can push it 
3f5b e5					push hl   ; save so we can free it afterwards 
3f5c			 
3f5c cd 68 1a				call forth_push_str 
3f5f			 
3f5f e1					pop hl 
3f60 cd 55 11				call free 
3f63			 
3f63					 
3f63					 
3f63			 
3f63			 
3f63					NEXTW 
3f63 c3 63 1d			jp macro_next 
3f66				endm 
# End of macro NEXTW
3f66			 
3f66			.LEFT: 
3f66				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3f66 48				db WORD_SYS_CORE+52             
3f67 8e 3f			dw .RIGHT            
3f69 05				db 4 + 1 
3f6a .. 00			db "LEFT",0              
3f6f				endm 
# End of macro CWHEAD
3f6f			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3f6f					if DEBUG_FORTH_WORDS_KEY 
3f6f						DMARK "LEF" 
3f6f f5				push af  
3f70 3a 84 3f			ld a, (.dmark)  
3f73 32 71 ee			ld (debug_mark),a  
3f76 3a 85 3f			ld a, (.dmark+1)  
3f79 32 72 ee			ld (debug_mark+1),a  
3f7c 3a 86 3f			ld a, (.dmark+2)  
3f7f 32 73 ee			ld (debug_mark+2),a  
3f82 18 03			jr .pastdmark  
3f84 ..			.dmark: db "LEF"  
3f87 f1			.pastdmark: pop af  
3f88			endm  
# End of macro DMARK
3f88						CALLMONITOR 
3f88 cd 6d 14			call break_point_state  
3f8b				endm  
# End of macro CALLMONITOR
3f8b					endif 
3f8b			 
3f8b					NEXTW 
3f8b c3 63 1d			jp macro_next 
3f8e				endm 
# End of macro NEXTW
3f8e			.RIGHT: 
3f8e				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3f8e 48				db WORD_SYS_CORE+52             
3f8f b7 3f			dw .STR2NUM            
3f91 06				db 5 + 1 
3f92 .. 00			db "RIGHT",0              
3f98				endm 
# End of macro CWHEAD
3f98			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3f98					if DEBUG_FORTH_WORDS_KEY 
3f98						DMARK "RIG" 
3f98 f5				push af  
3f99 3a ad 3f			ld a, (.dmark)  
3f9c 32 71 ee			ld (debug_mark),a  
3f9f 3a ae 3f			ld a, (.dmark+1)  
3fa2 32 72 ee			ld (debug_mark+1),a  
3fa5 3a af 3f			ld a, (.dmark+2)  
3fa8 32 73 ee			ld (debug_mark+2),a  
3fab 18 03			jr .pastdmark  
3fad ..			.dmark: db "RIG"  
3fb0 f1			.pastdmark: pop af  
3fb1			endm  
# End of macro DMARK
3fb1						CALLMONITOR 
3fb1 cd 6d 14			call break_point_state  
3fb4				endm  
# End of macro CALLMONITOR
3fb4					endif 
3fb4			 
3fb4					NEXTW 
3fb4 c3 63 1d			jp macro_next 
3fb7				endm 
# End of macro NEXTW
3fb7			 
3fb7			 
3fb7			.STR2NUM: 
3fb7				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3fb7 48				db WORD_SYS_CORE+52             
3fb8 43 40			dw .NUM2STR            
3fba 08				db 7 + 1 
3fbb .. 00			db "STR2NUM",0              
3fc3				endm 
# End of macro CWHEAD
3fc3			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3fc3			 
3fc3			 
3fc3			; TODO STR type check to do 
3fc3					if DEBUG_FORTH_WORDS_KEY 
3fc3						DMARK "S2N" 
3fc3 f5				push af  
3fc4 3a d8 3f			ld a, (.dmark)  
3fc7 32 71 ee			ld (debug_mark),a  
3fca 3a d9 3f			ld a, (.dmark+1)  
3fcd 32 72 ee			ld (debug_mark+1),a  
3fd0 3a da 3f			ld a, (.dmark+2)  
3fd3 32 73 ee			ld (debug_mark+2),a  
3fd6 18 03			jr .pastdmark  
3fd8 ..			.dmark: db "S2N"  
3fdb f1			.pastdmark: pop af  
3fdc			endm  
# End of macro DMARK
3fdc						CALLMONITOR 
3fdc cd 6d 14			call break_point_state  
3fdf				endm  
# End of macro CALLMONITOR
3fdf					endif 
3fdf			 
3fdf					;FORTH_DSP 
3fdf					FORTH_DSP_VALUE 
3fdf cd da 1b			call macro_forth_dsp_value 
3fe2				endm 
# End of macro FORTH_DSP_VALUE
3fe2					;inc hl 
3fe2			 
3fe2 eb					ex de, hl 
3fe3					if DEBUG_FORTH_WORDS 
3fe3						DMARK "S2a" 
3fe3 f5				push af  
3fe4 3a f8 3f			ld a, (.dmark)  
3fe7 32 71 ee			ld (debug_mark),a  
3fea 3a f9 3f			ld a, (.dmark+1)  
3fed 32 72 ee			ld (debug_mark+1),a  
3ff0 3a fa 3f			ld a, (.dmark+2)  
3ff3 32 73 ee			ld (debug_mark+2),a  
3ff6 18 03			jr .pastdmark  
3ff8 ..			.dmark: db "S2a"  
3ffb f1			.pastdmark: pop af  
3ffc			endm  
# End of macro DMARK
3ffc						CALLMONITOR 
3ffc cd 6d 14			call break_point_state  
3fff				endm  
# End of macro CALLMONITOR
3fff					endif 
3fff cd b9 0f				call string_to_uint16 
4002			 
4002					if DEBUG_FORTH_WORDS 
4002						DMARK "S2b" 
4002 f5				push af  
4003 3a 17 40			ld a, (.dmark)  
4006 32 71 ee			ld (debug_mark),a  
4009 3a 18 40			ld a, (.dmark+1)  
400c 32 72 ee			ld (debug_mark+1),a  
400f 3a 19 40			ld a, (.dmark+2)  
4012 32 73 ee			ld (debug_mark+2),a  
4015 18 03			jr .pastdmark  
4017 ..			.dmark: db "S2b"  
401a f1			.pastdmark: pop af  
401b			endm  
# End of macro DMARK
401b						CALLMONITOR 
401b cd 6d 14			call break_point_state  
401e				endm  
# End of macro CALLMONITOR
401e					endif 
401e			;		push hl 
401e					FORTH_DSP_POP 
401e cd a9 1c			call macro_forth_dsp_pop 
4021				endm 
# End of macro FORTH_DSP_POP
4021			;		pop hl 
4021					 
4021					if DEBUG_FORTH_WORDS 
4021						DMARK "S2b" 
4021 f5				push af  
4022 3a 36 40			ld a, (.dmark)  
4025 32 71 ee			ld (debug_mark),a  
4028 3a 37 40			ld a, (.dmark+1)  
402b 32 72 ee			ld (debug_mark+1),a  
402e 3a 38 40			ld a, (.dmark+2)  
4031 32 73 ee			ld (debug_mark+2),a  
4034 18 03			jr .pastdmark  
4036 ..			.dmark: db "S2b"  
4039 f1			.pastdmark: pop af  
403a			endm  
# End of macro DMARK
403a						CALLMONITOR 
403a cd 6d 14			call break_point_state  
403d				endm  
# End of macro CALLMONITOR
403d					endif 
403d cd fa 19				call forth_push_numhl	 
4040			 
4040				 
4040				       NEXTW 
4040 c3 63 1d			jp macro_next 
4043				endm 
# End of macro NEXTW
4043			.NUM2STR: 
4043				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4043 48				db WORD_SYS_CORE+52             
4044 52 40			dw .CONCAT            
4046 08				db 7 + 1 
4047 .. 00			db "NUM2STR",0              
404f				endm 
# End of macro CWHEAD
404f			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
404f			 
404f			;		; malloc a string to target 
404f			;		ld hl, 10     ; TODO max string size should be fine 
404f			;		call malloc 
404f			;		push hl    ; save malloc location 
404f			; 
404f			; 
404f			;; TODO check int type 
404f			;		FORTH_DSP_VALUEHL 
404f			;		ld a, l 
404f			;		call DispAToASCII   
404f			;;TODO need to chage above call to dump into string 
404f			; 
404f			; 
404f			 
404f				       NEXTW 
404f c3 63 1d			jp macro_next 
4052				endm 
# End of macro NEXTW
4052			 
4052			.CONCAT: 
4052				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4052 48				db WORD_SYS_CORE+52             
4053 05 41			dw .FIND            
4055 07				db 6 + 1 
4056 .. 00			db "CONCAT",0              
405d				endm 
# End of macro CWHEAD
405d			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
405d			 
405d			; TODO check string type 
405d			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
405d			 
405d					if DEBUG_FORTH_WORDS_KEY 
405d						DMARK "CON" 
405d f5				push af  
405e 3a 72 40			ld a, (.dmark)  
4061 32 71 ee			ld (debug_mark),a  
4064 3a 73 40			ld a, (.dmark+1)  
4067 32 72 ee			ld (debug_mark+1),a  
406a 3a 74 40			ld a, (.dmark+2)  
406d 32 73 ee			ld (debug_mark+2),a  
4070 18 03			jr .pastdmark  
4072 ..			.dmark: db "CON"  
4075 f1			.pastdmark: pop af  
4076			endm  
# End of macro DMARK
4076						CALLMONITOR 
4076 cd 6d 14			call break_point_state  
4079				endm  
# End of macro CALLMONITOR
4079					endif 
4079			 
4079			 
4079					FORTH_DSP_VALUE 
4079 cd da 1b			call macro_forth_dsp_value 
407c				endm 
# End of macro FORTH_DSP_VALUE
407c e5					push hl   ; s2 
407d			 
407d					FORTH_DSP_POP 
407d cd a9 1c			call macro_forth_dsp_pop 
4080				endm 
# End of macro FORTH_DSP_POP
4080			 
4080					FORTH_DSP_VALUE 
4080 cd da 1b			call macro_forth_dsp_value 
4083				endm 
# End of macro FORTH_DSP_VALUE
4083			 
4083 e5					push hl   ; s1 
4084			 
4084					FORTH_DSP_POP 
4084 cd a9 1c			call macro_forth_dsp_pop 
4087				endm 
# End of macro FORTH_DSP_POP
4087					 
4087			 
4087					; copy s1 
4087			 
4087				 
4087					; save ptr 
4087 e1					pop hl  
4088 e5					push hl 
4089 3e 00				ld a, 0 
408b cd 2d 10				call strlent 
408e					;inc hl    ; zer0 
408e 06 00				ld b, 0 
4090 4d					ld c, l 
4091 e1					pop hl		 
4092 11 57 e3				ld de, scratch	 
4095					if DEBUG_FORTH_WORDS 
4095						DMARK "CO1" 
4095 f5				push af  
4096 3a aa 40			ld a, (.dmark)  
4099 32 71 ee			ld (debug_mark),a  
409c 3a ab 40			ld a, (.dmark+1)  
409f 32 72 ee			ld (debug_mark+1),a  
40a2 3a ac 40			ld a, (.dmark+2)  
40a5 32 73 ee			ld (debug_mark+2),a  
40a8 18 03			jr .pastdmark  
40aa ..			.dmark: db "CO1"  
40ad f1			.pastdmark: pop af  
40ae			endm  
# End of macro DMARK
40ae						CALLMONITOR 
40ae cd 6d 14			call break_point_state  
40b1				endm  
# End of macro CALLMONITOR
40b1					endif 
40b1 ed b0				ldir 
40b3			 
40b3 e1					pop hl 
40b4 e5					push hl 
40b5 d5					push de 
40b6			 
40b6			 
40b6 3e 00				ld a, 0 
40b8 cd 2d 10				call strlent 
40bb 23					inc hl    ; zer0 
40bc 23					inc hl 
40bd 06 00				ld b, 0 
40bf 4d					ld c, l 
40c0 d1					pop de 
40c1 e1					pop hl		 
40c2					if DEBUG_FORTH_WORDS 
40c2						DMARK "CO2" 
40c2 f5				push af  
40c3 3a d7 40			ld a, (.dmark)  
40c6 32 71 ee			ld (debug_mark),a  
40c9 3a d8 40			ld a, (.dmark+1)  
40cc 32 72 ee			ld (debug_mark+1),a  
40cf 3a d9 40			ld a, (.dmark+2)  
40d2 32 73 ee			ld (debug_mark+2),a  
40d5 18 03			jr .pastdmark  
40d7 ..			.dmark: db "CO2"  
40da f1			.pastdmark: pop af  
40db			endm  
# End of macro DMARK
40db						CALLMONITOR 
40db cd 6d 14			call break_point_state  
40de				endm  
# End of macro CALLMONITOR
40de					endif 
40de ed b0				ldir 
40e0			 
40e0			 
40e0			 
40e0 21 57 e3				ld hl, scratch 
40e3					if DEBUG_FORTH_WORDS 
40e3						DMARK "CO5" 
40e3 f5				push af  
40e4 3a f8 40			ld a, (.dmark)  
40e7 32 71 ee			ld (debug_mark),a  
40ea 3a f9 40			ld a, (.dmark+1)  
40ed 32 72 ee			ld (debug_mark+1),a  
40f0 3a fa 40			ld a, (.dmark+2)  
40f3 32 73 ee			ld (debug_mark+2),a  
40f6 18 03			jr .pastdmark  
40f8 ..			.dmark: db "CO5"  
40fb f1			.pastdmark: pop af  
40fc			endm  
# End of macro DMARK
40fc						CALLMONITOR 
40fc cd 6d 14			call break_point_state  
40ff				endm  
# End of macro CALLMONITOR
40ff					endif 
40ff			 
40ff cd 68 1a				call forth_push_str 
4102			 
4102			 
4102			 
4102			 
4102				       NEXTW 
4102 c3 63 1d			jp macro_next 
4105				endm 
# End of macro NEXTW
4105			 
4105			 
4105			.FIND: 
4105				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4105 4b				db WORD_SYS_CORE+55             
4106 c3 41			dw .LEN            
4108 05				db 4 + 1 
4109 .. 00			db "FIND",0              
410e				endm 
# End of macro CWHEAD
410e			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
410e			 
410e					if DEBUG_FORTH_WORDS_KEY 
410e						DMARK "FND" 
410e f5				push af  
410f 3a 23 41			ld a, (.dmark)  
4112 32 71 ee			ld (debug_mark),a  
4115 3a 24 41			ld a, (.dmark+1)  
4118 32 72 ee			ld (debug_mark+1),a  
411b 3a 25 41			ld a, (.dmark+2)  
411e 32 73 ee			ld (debug_mark+2),a  
4121 18 03			jr .pastdmark  
4123 ..			.dmark: db "FND"  
4126 f1			.pastdmark: pop af  
4127			endm  
# End of macro DMARK
4127						CALLMONITOR 
4127 cd 6d 14			call break_point_state  
412a				endm  
# End of macro CALLMONITOR
412a					endif 
412a			 
412a			; TODO check string type 
412a					FORTH_DSP_VALUE 
412a cd da 1b			call macro_forth_dsp_value 
412d				endm 
# End of macro FORTH_DSP_VALUE
412d			 
412d e5					push hl    
412e 7e					ld a,(hl)    ; char to find   
412f			; TODO change char to substr 
412f			 
412f f5					push af 
4130					 
4130			 
4130			 
4130					if DEBUG_FORTH_WORDS 
4130						DMARK "FN1" 
4130 f5				push af  
4131 3a 45 41			ld a, (.dmark)  
4134 32 71 ee			ld (debug_mark),a  
4137 3a 46 41			ld a, (.dmark+1)  
413a 32 72 ee			ld (debug_mark+1),a  
413d 3a 47 41			ld a, (.dmark+2)  
4140 32 73 ee			ld (debug_mark+2),a  
4143 18 03			jr .pastdmark  
4145 ..			.dmark: db "FN1"  
4148 f1			.pastdmark: pop af  
4149			endm  
# End of macro DMARK
4149						CALLMONITOR 
4149 cd 6d 14			call break_point_state  
414c				endm  
# End of macro CALLMONITOR
414c					endif 
414c			 
414c					FORTH_DSP_POP 
414c cd a9 1c			call macro_forth_dsp_pop 
414f				endm 
# End of macro FORTH_DSP_POP
414f			 
414f					; string to search 
414f			 
414f					FORTH_DSP_VALUE 
414f cd da 1b			call macro_forth_dsp_value 
4152				endm 
# End of macro FORTH_DSP_VALUE
4152			 
4152 d1					pop de  ; d is char to find  
4153			 
4153					if DEBUG_FORTH_WORDS 
4153						DMARK "FN2" 
4153 f5				push af  
4154 3a 68 41			ld a, (.dmark)  
4157 32 71 ee			ld (debug_mark),a  
415a 3a 69 41			ld a, (.dmark+1)  
415d 32 72 ee			ld (debug_mark+1),a  
4160 3a 6a 41			ld a, (.dmark+2)  
4163 32 73 ee			ld (debug_mark+2),a  
4166 18 03			jr .pastdmark  
4168 ..			.dmark: db "FN2"  
416b f1			.pastdmark: pop af  
416c			endm  
# End of macro DMARK
416c						CALLMONITOR 
416c cd 6d 14			call break_point_state  
416f				endm  
# End of macro CALLMONITOR
416f					endif 
416f					 
416f 01 00 00				ld bc, 0 
4172 7e			.findchar:      ld a,(hl) 
4173 fe 00				cp 0   		 
4175 28 27				jr z, .finddone     
4177 ba					cp d 
4178 28 20				jr z, .foundchar 
417a 03					inc bc 
417b 23					inc hl 
417c					if DEBUG_FORTH_WORDS 
417c						DMARK "FN3" 
417c f5				push af  
417d 3a 91 41			ld a, (.dmark)  
4180 32 71 ee			ld (debug_mark),a  
4183 3a 92 41			ld a, (.dmark+1)  
4186 32 72 ee			ld (debug_mark+1),a  
4189 3a 93 41			ld a, (.dmark+2)  
418c 32 73 ee			ld (debug_mark+2),a  
418f 18 03			jr .pastdmark  
4191 ..			.dmark: db "FN3"  
4194 f1			.pastdmark: pop af  
4195			endm  
# End of macro DMARK
4195						CALLMONITOR 
4195 cd 6d 14			call break_point_state  
4198				endm  
# End of macro CALLMONITOR
4198					endif 
4198 18 d8				jr .findchar 
419a			 
419a			 
419a c5			.foundchar:	push bc 
419b e1					pop hl 
419c 18 03				jr .findexit 
419e			 
419e			 
419e							 
419e			 
419e			.finddone:     ; got to end of string with no find 
419e 21 00 00				ld hl, 0 
41a1			.findexit: 
41a1			 
41a1					if DEBUG_FORTH_WORDS 
41a1						DMARK "FNd" 
41a1 f5				push af  
41a2 3a b6 41			ld a, (.dmark)  
41a5 32 71 ee			ld (debug_mark),a  
41a8 3a b7 41			ld a, (.dmark+1)  
41ab 32 72 ee			ld (debug_mark+1),a  
41ae 3a b8 41			ld a, (.dmark+2)  
41b1 32 73 ee			ld (debug_mark+2),a  
41b4 18 03			jr .pastdmark  
41b6 ..			.dmark: db "FNd"  
41b9 f1			.pastdmark: pop af  
41ba			endm  
# End of macro DMARK
41ba						CALLMONITOR 
41ba cd 6d 14			call break_point_state  
41bd				endm  
# End of macro CALLMONITOR
41bd					endif 
41bd cd fa 19			call forth_push_numhl 
41c0			 
41c0				       NEXTW 
41c0 c3 63 1d			jp macro_next 
41c3				endm 
# End of macro NEXTW
41c3			 
41c3			.LEN: 
41c3				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
41c3 4c				db WORD_SYS_CORE+56             
41c4 f8 41			dw .CHAR            
41c6 06				db 5 + 1 
41c7 .. 00			db "COUNT",0              
41cd				endm 
# End of macro CWHEAD
41cd			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
41cd			 
41cd					if DEBUG_FORTH_WORDS_KEY 
41cd						DMARK "CNT" 
41cd f5				push af  
41ce 3a e2 41			ld a, (.dmark)  
41d1 32 71 ee			ld (debug_mark),a  
41d4 3a e3 41			ld a, (.dmark+1)  
41d7 32 72 ee			ld (debug_mark+1),a  
41da 3a e4 41			ld a, (.dmark+2)  
41dd 32 73 ee			ld (debug_mark+2),a  
41e0 18 03			jr .pastdmark  
41e2 ..			.dmark: db "CNT"  
41e5 f1			.pastdmark: pop af  
41e6			endm  
# End of macro DMARK
41e6						CALLMONITOR 
41e6 cd 6d 14			call break_point_state  
41e9				endm  
# End of macro CALLMONITOR
41e9					endif 
41e9			; TODO check string type 
41e9					FORTH_DSP 
41e9 cd b7 1b			call macro_forth_dsp 
41ec				endm 
# End of macro FORTH_DSP
41ec					;v5FORTH_DSP_VALUE 
41ec			 
41ec 23					inc hl 
41ed			 
41ed 3e 00				ld a, 0 
41ef cd 2d 10				call strlent 
41f2			 
41f2 cd fa 19				call forth_push_numhl 
41f5			 
41f5			 
41f5			 
41f5				       NEXTW 
41f5 c3 63 1d			jp macro_next 
41f8				endm 
# End of macro NEXTW
41f8			.CHAR: 
41f8				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
41f8 4d				db WORD_SYS_CORE+57             
41f9 2e 42			dw .ENDSTR            
41fb 05				db 4 + 1 
41fc .. 00			db "CHAR",0              
4201				endm 
# End of macro CWHEAD
4201			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4201					if DEBUG_FORTH_WORDS_KEY 
4201						DMARK "CHR" 
4201 f5				push af  
4202 3a 16 42			ld a, (.dmark)  
4205 32 71 ee			ld (debug_mark),a  
4208 3a 17 42			ld a, (.dmark+1)  
420b 32 72 ee			ld (debug_mark+1),a  
420e 3a 18 42			ld a, (.dmark+2)  
4211 32 73 ee			ld (debug_mark+2),a  
4214 18 03			jr .pastdmark  
4216 ..			.dmark: db "CHR"  
4219 f1			.pastdmark: pop af  
421a			endm  
# End of macro DMARK
421a						CALLMONITOR 
421a cd 6d 14			call break_point_state  
421d				endm  
# End of macro CALLMONITOR
421d					endif 
421d					FORTH_DSP 
421d cd b7 1b			call macro_forth_dsp 
4220				endm 
# End of macro FORTH_DSP
4220					;v5 FORTH_DSP_VALUE 
4220 23					inc hl      ; now at start of numeric as string 
4221			 
4221			;		push hl 
4221			 
4221					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4221 cd a9 1c			call macro_forth_dsp_pop 
4224				endm 
# End of macro FORTH_DSP_POP
4224			 
4224			;		pop hl 
4224			 
4224					; push the content of a onto the stack as a value 
4224			 
4224 7e					ld a,(hl)   ; get char 
4225 26 00				ld h,0 
4227 6f					ld l,a 
4228 cd fa 19				call forth_push_numhl 
422b			 
422b				       NEXTW 
422b c3 63 1d			jp macro_next 
422e				endm 
# End of macro NEXTW
422e			 
422e			 
422e			 
422e			 
422e			.ENDSTR: 
422e			; eof 
422e			 
# End of file forth_words_str.asm
422e			include "forth_words_key.asm" 
422e			 
422e			; | ## Keyboard Words 
422e			 
422e			.KEY: 
422e				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
422e 3e				db WORD_SYS_CORE+42             
422f 5e 42			dw .WAITK            
4231 04				db 3 + 1 
4232 .. 00			db "KEY",0              
4236				endm 
# End of macro CWHEAD
4236			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4236			 
4236					if DEBUG_FORTH_WORDS_KEY 
4236						DMARK "KEY" 
4236 f5				push af  
4237 3a 4b 42			ld a, (.dmark)  
423a 32 71 ee			ld (debug_mark),a  
423d 3a 4c 42			ld a, (.dmark+1)  
4240 32 72 ee			ld (debug_mark+1),a  
4243 3a 4d 42			ld a, (.dmark+2)  
4246 32 73 ee			ld (debug_mark+2),a  
4249 18 03			jr .pastdmark  
424b ..			.dmark: db "KEY"  
424e f1			.pastdmark: pop af  
424f			endm  
# End of macro DMARK
424f						CALLMONITOR 
424f cd 6d 14			call break_point_state  
4252				endm  
# End of macro CALLMONITOR
4252					endif 
4252			; TODO currently waits 
4252 cd 1f 59				call cin 
4255					;call cin_wait 
4255 6f					ld l, a 
4256 26 00				ld h, 0 
4258 cd fa 19				call forth_push_numhl 
425b					NEXTW 
425b c3 63 1d			jp macro_next 
425e				endm 
# End of macro NEXTW
425e			.WAITK: 
425e				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
425e 3f				db WORD_SYS_CORE+43             
425f 90 42			dw .ACCEPT            
4261 06				db 5 + 1 
4262 .. 00			db "WAITK",0              
4268				endm 
# End of macro CWHEAD
4268			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4268					if DEBUG_FORTH_WORDS_KEY 
4268						DMARK "WAI" 
4268 f5				push af  
4269 3a 7d 42			ld a, (.dmark)  
426c 32 71 ee			ld (debug_mark),a  
426f 3a 7e 42			ld a, (.dmark+1)  
4272 32 72 ee			ld (debug_mark+1),a  
4275 3a 7f 42			ld a, (.dmark+2)  
4278 32 73 ee			ld (debug_mark+2),a  
427b 18 03			jr .pastdmark  
427d ..			.dmark: db "WAI"  
4280 f1			.pastdmark: pop af  
4281			endm  
# End of macro DMARK
4281						CALLMONITOR 
4281 cd 6d 14			call break_point_state  
4284				endm  
# End of macro CALLMONITOR
4284					endif 
4284 cd 17 59				call cin_wait 
4287 6f					ld l, a 
4288 26 00				ld h, 0 
428a cd fa 19				call forth_push_numhl 
428d					NEXTW 
428d c3 63 1d			jp macro_next 
4290				endm 
# End of macro NEXTW
4290			.ACCEPT: 
4290				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4290 40				db WORD_SYS_CORE+44             
4291 ee 42			dw .EDIT            
4293 07				db 6 + 1 
4294 .. 00			db "ACCEPT",0              
429b				endm 
# End of macro CWHEAD
429b			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
429b					; TODO crashes on push 
429b					if DEBUG_FORTH_WORDS_KEY 
429b						DMARK "ACC" 
429b f5				push af  
429c 3a b0 42			ld a, (.dmark)  
429f 32 71 ee			ld (debug_mark),a  
42a2 3a b1 42			ld a, (.dmark+1)  
42a5 32 72 ee			ld (debug_mark+1),a  
42a8 3a b2 42			ld a, (.dmark+2)  
42ab 32 73 ee			ld (debug_mark+2),a  
42ae 18 03			jr .pastdmark  
42b0 ..			.dmark: db "ACC"  
42b3 f1			.pastdmark: pop af  
42b4			endm  
# End of macro DMARK
42b4						CALLMONITOR 
42b4 cd 6d 14			call break_point_state  
42b7				endm  
# End of macro CALLMONITOR
42b7					endif 
42b7 21 55 e5				ld hl, os_input 
42ba 3e 00				ld a, 0 
42bc 77					ld (hl),a 
42bd 3a 40 eb				ld a,(f_cursor_ptr) 
42c0 16 64				ld d, 100 
42c2 0e 00				ld c, 0 
42c4 1e 28				ld e, 40 
42c6 cd f1 0b				call input_str 
42c9					; TODO perhaps do a type check and wrap in quotes if not a number 
42c9 21 55 e5				ld hl, os_input 
42cc					if DEBUG_FORTH_WORDS 
42cc						DMARK "AC1" 
42cc f5				push af  
42cd 3a e1 42			ld a, (.dmark)  
42d0 32 71 ee			ld (debug_mark),a  
42d3 3a e2 42			ld a, (.dmark+1)  
42d6 32 72 ee			ld (debug_mark+1),a  
42d9 3a e3 42			ld a, (.dmark+2)  
42dc 32 73 ee			ld (debug_mark+2),a  
42df 18 03			jr .pastdmark  
42e1 ..			.dmark: db "AC1"  
42e4 f1			.pastdmark: pop af  
42e5			endm  
# End of macro DMARK
42e5						CALLMONITOR 
42e5 cd 6d 14			call break_point_state  
42e8				endm  
# End of macro CALLMONITOR
42e8					endif 
42e8 cd 68 1a				call forth_push_str 
42eb					NEXTW 
42eb c3 63 1d			jp macro_next 
42ee				endm 
# End of macro NEXTW
42ee			 
42ee			.EDIT: 
42ee				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
42ee 40				db WORD_SYS_CORE+44             
42ef 90 43			dw .ENDKEY            
42f1 05				db 4 + 1 
42f2 .. 00			db "EDIT",0              
42f7				endm 
# End of macro CWHEAD
42f7			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
42f7			 
42f7					; TODO does not copy from stack 
42f7					if DEBUG_FORTH_WORDS_KEY 
42f7						DMARK "EDT" 
42f7 f5				push af  
42f8 3a 0c 43			ld a, (.dmark)  
42fb 32 71 ee			ld (debug_mark),a  
42fe 3a 0d 43			ld a, (.dmark+1)  
4301 32 72 ee			ld (debug_mark+1),a  
4304 3a 0e 43			ld a, (.dmark+2)  
4307 32 73 ee			ld (debug_mark+2),a  
430a 18 03			jr .pastdmark  
430c ..			.dmark: db "EDT"  
430f f1			.pastdmark: pop af  
4310			endm  
# End of macro DMARK
4310						CALLMONITOR 
4310 cd 6d 14			call break_point_state  
4313				endm  
# End of macro CALLMONITOR
4313					endif 
4313			 
4313					;FORTH_DSP 
4313					FORTH_DSP_VALUEHL 
4313 cd f1 1b			call macro_dsp_valuehl 
4316				endm 
# End of macro FORTH_DSP_VALUEHL
4316			;		inc hl    ; TODO do type check 
4316			 
4316			;		call get_word_hl 
4316 e5					push hl 
4317					if DEBUG_FORTH_WORDS 
4317						DMARK "EDp" 
4317 f5				push af  
4318 3a 2c 43			ld a, (.dmark)  
431b 32 71 ee			ld (debug_mark),a  
431e 3a 2d 43			ld a, (.dmark+1)  
4321 32 72 ee			ld (debug_mark+1),a  
4324 3a 2e 43			ld a, (.dmark+2)  
4327 32 73 ee			ld (debug_mark+2),a  
432a 18 03			jr .pastdmark  
432c ..			.dmark: db "EDp"  
432f f1			.pastdmark: pop af  
4330			endm  
# End of macro DMARK
4330						CALLMONITOR 
4330 cd 6d 14			call break_point_state  
4333				endm  
# End of macro CALLMONITOR
4333					endif 
4333				;	ld a, 0 
4333 cd 22 10				call strlenz 
4336 23					inc hl 
4337			 
4337 06 00				ld b, 0 
4339 4d					ld c, l 
433a			 
433a e1					pop hl 
433b 11 55 e5				ld de, os_input 
433e					if DEBUG_FORTH_WORDS_KEY 
433e						DMARK "EDc" 
433e f5				push af  
433f 3a 53 43			ld a, (.dmark)  
4342 32 71 ee			ld (debug_mark),a  
4345 3a 54 43			ld a, (.dmark+1)  
4348 32 72 ee			ld (debug_mark+1),a  
434b 3a 55 43			ld a, (.dmark+2)  
434e 32 73 ee			ld (debug_mark+2),a  
4351 18 03			jr .pastdmark  
4353 ..			.dmark: db "EDc"  
4356 f1			.pastdmark: pop af  
4357			endm  
# End of macro DMARK
4357						CALLMONITOR 
4357 cd 6d 14			call break_point_state  
435a				endm  
# End of macro CALLMONITOR
435a					endif 
435a ed b0				ldir 
435c			 
435c			 
435c 21 55 e5				ld hl, os_input 
435f					;ld a, 0 
435f					;ld (hl),a 
435f 3a 40 eb				ld a,(f_cursor_ptr) 
4362 16 64				ld d, 100 
4364 0e 00				ld c, 0 
4366 1e 28				ld e, 40 
4368 cd f1 0b				call input_str 
436b					; TODO perhaps do a type check and wrap in quotes if not a number 
436b 21 55 e5				ld hl, os_input 
436e					if DEBUG_FORTH_WORDS 
436e						DMARK "ED1" 
436e f5				push af  
436f 3a 83 43			ld a, (.dmark)  
4372 32 71 ee			ld (debug_mark),a  
4375 3a 84 43			ld a, (.dmark+1)  
4378 32 72 ee			ld (debug_mark+1),a  
437b 3a 85 43			ld a, (.dmark+2)  
437e 32 73 ee			ld (debug_mark+2),a  
4381 18 03			jr .pastdmark  
4383 ..			.dmark: db "ED1"  
4386 f1			.pastdmark: pop af  
4387			endm  
# End of macro DMARK
4387						CALLMONITOR 
4387 cd 6d 14			call break_point_state  
438a				endm  
# End of macro CALLMONITOR
438a					endif 
438a cd 68 1a				call forth_push_str 
438d					NEXTW 
438d c3 63 1d			jp macro_next 
4390				endm 
# End of macro NEXTW
4390			 
4390			 
4390			 
4390			.ENDKEY: 
4390			; eof 
4390			 
# End of file forth_words_key.asm
4390			 
4390			if STORAGE_SE 
4390			   	include "forth_words_storage.asm" 
4390			endif 
4390				include "forth_words_device.asm" 
4390			; Device related words 
4390			 
4390			; | ## Device Words 
4390			 
4390			if SOUND_ENABLE 
4390			.NOTE: 
4390				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4390			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4390					if DEBUG_FORTH_WORDS_KEY 
4390						DMARK "NTE" 
4390						CALLMONITOR 
4390					endif 
4390			 
4390				 
4390			 
4390					NEXTW 
4390			.AFTERSOUND: 
4390			endif 
4390			 
4390			 
4390			USE_GPIO: equ 0 
4390			 
4390			if USE_GPIO 
4390			.GP1: 
4390				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4390			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4390					NEXTW 
4390			.GP2: 
4390				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4390			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4390			 
4390					NEXTW 
4390			 
4390			.GP3: 
4390				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4390			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4390			 
4390					NEXTW 
4390			 
4390			.GP4: 
4390				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4390			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4390			 
4390					NEXTW 
4390			.SIN: 
4390			 
4390			 
4390			endif 
4390			 
4390			 
4390				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4390 33				db WORD_SYS_CORE+31             
4391 c5 43			dw .SOUT            
4393 03				db 2 + 1 
4394 .. 00			db "IN",0              
4397				endm 
# End of macro CWHEAD
4397			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4397					if DEBUG_FORTH_WORDS_KEY 
4397						DMARK "IN." 
4397 f5				push af  
4398 3a ac 43			ld a, (.dmark)  
439b 32 71 ee			ld (debug_mark),a  
439e 3a ad 43			ld a, (.dmark+1)  
43a1 32 72 ee			ld (debug_mark+1),a  
43a4 3a ae 43			ld a, (.dmark+2)  
43a7 32 73 ee			ld (debug_mark+2),a  
43aa 18 03			jr .pastdmark  
43ac ..			.dmark: db "IN."  
43af f1			.pastdmark: pop af  
43b0			endm  
# End of macro DMARK
43b0						CALLMONITOR 
43b0 cd 6d 14			call break_point_state  
43b3				endm  
# End of macro CALLMONITOR
43b3					endif 
43b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43b3 cd f1 1b			call macro_dsp_valuehl 
43b6				endm 
# End of macro FORTH_DSP_VALUEHL
43b6			 
43b6 e5					push hl 
43b7			 
43b7					; destroy value TOS 
43b7			 
43b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43b7 cd a9 1c			call macro_forth_dsp_pop 
43ba				endm 
# End of macro FORTH_DSP_POP
43ba			 
43ba					; one value on hl get other one back 
43ba			 
43ba c1					pop bc 
43bb			 
43bb					; do the sub 
43bb			;		ex de, hl 
43bb			 
43bb ed 68				in l,(c) 
43bd			 
43bd					; save it 
43bd			 
43bd 26 00				ld h,0 
43bf			 
43bf					; TODO push value back onto stack for another op etc 
43bf			 
43bf cd fa 19				call forth_push_numhl 
43c2					NEXTW 
43c2 c3 63 1d			jp macro_next 
43c5				endm 
# End of macro NEXTW
43c5			.SOUT: 
43c5				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
43c5 34				db WORD_SYS_CORE+32             
43c6 18 44			dw .SPIO            
43c8 04				db 3 + 1 
43c9 .. 00			db "OUT",0              
43cd				endm 
# End of macro CWHEAD
43cd			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
43cd					if DEBUG_FORTH_WORDS_KEY 
43cd						DMARK "OUT" 
43cd f5				push af  
43ce 3a e2 43			ld a, (.dmark)  
43d1 32 71 ee			ld (debug_mark),a  
43d4 3a e3 43			ld a, (.dmark+1)  
43d7 32 72 ee			ld (debug_mark+1),a  
43da 3a e4 43			ld a, (.dmark+2)  
43dd 32 73 ee			ld (debug_mark+2),a  
43e0 18 03			jr .pastdmark  
43e2 ..			.dmark: db "OUT"  
43e5 f1			.pastdmark: pop af  
43e6			endm  
# End of macro DMARK
43e6						CALLMONITOR 
43e6 cd 6d 14			call break_point_state  
43e9				endm  
# End of macro CALLMONITOR
43e9					endif 
43e9			 
43e9					; get port 
43e9			 
43e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43e9 cd f1 1b			call macro_dsp_valuehl 
43ec				endm 
# End of macro FORTH_DSP_VALUEHL
43ec			 
43ec e5					push hl 
43ed			 
43ed					; destroy value TOS 
43ed			 
43ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43ed cd a9 1c			call macro_forth_dsp_pop 
43f0				endm 
# End of macro FORTH_DSP_POP
43f0			 
43f0					; get byte to send 
43f0			 
43f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43f0 cd f1 1b			call macro_dsp_valuehl 
43f3				endm 
# End of macro FORTH_DSP_VALUEHL
43f3			 
43f3			;		push hl 
43f3			 
43f3					; destroy value TOS 
43f3			 
43f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43f3 cd a9 1c			call macro_forth_dsp_pop 
43f6				endm 
# End of macro FORTH_DSP_POP
43f6			 
43f6					; one value on hl get other one back 
43f6			 
43f6			;		pop hl 
43f6			 
43f6 c1					pop bc 
43f7			 
43f7					if DEBUG_FORTH_WORDS 
43f7						DMARK "OUT" 
43f7 f5				push af  
43f8 3a 0c 44			ld a, (.dmark)  
43fb 32 71 ee			ld (debug_mark),a  
43fe 3a 0d 44			ld a, (.dmark+1)  
4401 32 72 ee			ld (debug_mark+1),a  
4404 3a 0e 44			ld a, (.dmark+2)  
4407 32 73 ee			ld (debug_mark+2),a  
440a 18 03			jr .pastdmark  
440c ..			.dmark: db "OUT"  
440f f1			.pastdmark: pop af  
4410			endm  
# End of macro DMARK
4410						CALLMONITOR 
4410 cd 6d 14			call break_point_state  
4413				endm  
# End of macro CALLMONITOR
4413					endif 
4413			 
4413 ed 69				out (c), l 
4415			 
4415					NEXTW 
4415 c3 63 1d			jp macro_next 
4418				endm 
# End of macro NEXTW
4418			 
4418			 
4418			.SPIO: 
4418			 
4418			if STORAGE_SE 
4418				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4418			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4418			 
4418					call spi_ce_low 
4418			    NEXTW 
4418			 
4418			.SPICEH: 
4418				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4418			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4418			 
4418					call spi_ce_high 
4418			    NEXTW 
4418			 
4418			 
4418			.SPIOb: 
4418			 
4418				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4418			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4418			 
4418					; get port 
4418			 
4418			 
4418					; get byte to send 
4418			 
4418					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4418			 
4418			;		push hl    ; u1  
4418			 
4418					; destroy value TOS 
4418			 
4418					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4418			 
4418					; one value on hl get other one back 
4418			 
4418			;		pop hl   ; u2 - addr 
4418			 
4418					; TODO Send SPI byte 
4418			 
4418					ld a, l 
4418					call spi_send_byte 
4418			 
4418					NEXTW 
4418			 
4418			.SPII: 
4418				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4418			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4418			 
4418					; TODO Get SPI byte 
4418			 
4418					call spi_read_byte 
4418			 
4418					ld h, 0 
4418					ld l, a 
4418					call forth_push_numhl 
4418			 
4418					NEXTW 
4418			 
4418			 
4418			 
4418			.SESEL: 
4418				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4418			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4418					if DEBUG_FORTH_WORDS_KEY 
4418						DMARK "BNK" 
4418						CALLMONITOR 
4418					endif 
4418			 
4418					ld a, 255 
4418					ld (spi_cartdev), a 
4418			 
4418					; get bank 
4418			 
4418					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4418			 
4418			;		push hl 
4418			 
4418					; destroy value TOS 
4418			 
4418					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4418			 
4418					; one value on hl get other one back 
4418			 
4418			;		pop hl 
4418			 
4418			 
4418					ld c, SPI_CE_HIGH 
4418					ld b, '0'    ; human readable bank number 
4418			 
4418					ld a, l 
4418			 
4418					if DEBUG_FORTH_WORDS 
4418						DMARK "BNK" 
4418						CALLMONITOR 
4418					endif 
4418			 
4418					; active low 
4418			 
4418					cp 0 
4418					jr z, .bset 
4418					cp 1 
4418					jr nz, .b2 
4418					res 0, c 
4418					ld b, '1'    ; human readable bank number 
4418			.b2:		cp 2 
4418					jr nz, .b3 
4418					res 1, c 
4418					ld b, '2'    ; human readable bank number 
4418			.b3:		cp 3 
4418					jr nz, .b4 
4418					res 2, c 
4418					ld b, '3'    ; human readable bank number 
4418			.b4:		cp 4 
4418					jr nz, .b5 
4418					res 3, c 
4418					ld b, '4'    ; human readable bank number 
4418			.b5:		cp 5 
4418					jr nz, .bset 
4418					res 4, c 
4418					ld b, '5'    ; human readable bank number 
4418			 
4418			.bset: 
4418					ld a, c 
4418					ld (spi_device),a 
4418					ld a, b 
4418					ld (spi_device_id),a 
4418					if DEBUG_FORTH_WORDS 
4418						DMARK "BN2" 
4418						CALLMONITOR 
4418					endif 
4418			 
4418					NEXTW 
4418			 
4418			.CARTDEV: 
4418				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4418			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4418					if DEBUG_FORTH_WORDS_KEY 
4418						DMARK "CDV" 
4418						CALLMONITOR 
4418					endif 
4418			 
4418					; disable se storage bank selection 
4418			 
4418					ld a, SPI_CE_HIGH		; ce high 
4418					ld (spi_device), a 
4418			 
4418					; get bank 
4418			 
4418					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4418			 
4418			;		push hl 
4418			 
4418					; destroy value TOS 
4418			 
4418					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4418			 
4418					; one value on hl get other one back 
4418			 
4418			;		pop hl 
4418			 
4418					; active low 
4418			 
4418					ld c, 255 
4418			 
4418					ld a, l 
4418					if DEBUG_FORTH_WORDS 
4418						DMARK "CDV" 
4418						CALLMONITOR 
4418					endif 
4418					cp 0 
4418					jr z, .cset 
4418					cp 1 
4418					jr nz, .c2 
4418					res 0, c 
4418			.c2:		cp 2 
4418					jr nz, .c3 
4418					res 1, c 
4418			.c3:		cp 3 
4418					jr nz, .c4 
4418					res 2, c 
4418			.c4:		cp 4 
4418					jr nz, .c5 
4418					res 3, c 
4418			.c5:		cp 5 
4418					jr nz, .c6 
4418					res 4, c 
4418			.c6:		cp 6 
4418					jr nz, .c7 
4418					res 5, c 
4418			.c7:		cp 7 
4418					jr nz, .c8 
4418					res 6, c 
4418			.c8:		cp 8 
4418					jr nz, .cset 
4418					res 7, c 
4418			.cset:		ld a, c 
4418					ld (spi_cartdev),a 
4418			 
4418					if DEBUG_FORTH_WORDS 
4418						DMARK "CD2" 
4418						CALLMONITOR 
4418					endif 
4418					NEXTW 
4418			endif 
4418			 
4418			.ENDDEVICE: 
4418			; eof 
4418			 
# End of file forth_words_device.asm
4418			 
4418			; var handler 
4418			 
4418			 
4418			.VARS: 
4418				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4418 78				db WORD_SYS_CORE+100             
4419 30 44			dw .V0Q            
441b 04				db 3 + 1 
441c .. 00			db "V0!",0              
4420				endm 
# End of macro CWHEAD
4420			;| V0! ( u1 -- )  Store value to v0  | DONE 
4420			 
4420					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4420 cd f1 1b			call macro_dsp_valuehl 
4423				endm 
# End of macro FORTH_DSP_VALUEHL
4423			 
4423 11 0a eb				ld de, cli_var_array 
4426			 
4426 eb					ex de, hl 
4427 73					ld (hl), e 
4428 23					inc hl 
4429 72					ld (hl), d 
442a			 
442a					; destroy value TOS 
442a			 
442a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
442a cd a9 1c			call macro_forth_dsp_pop 
442d				endm 
# End of macro FORTH_DSP_POP
442d			 
442d				       NEXTW 
442d c3 63 1d			jp macro_next 
4430				endm 
# End of macro NEXTW
4430			.V0Q: 
4430				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4430 79				db WORD_SYS_CORE+101             
4431 41 44			dw .V1S            
4433 04				db 3 + 1 
4434 .. 00			db "V0@",0              
4438				endm 
# End of macro CWHEAD
4438			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4438 2a 0a eb				ld hl, (cli_var_array) 
443b cd fa 19				call forth_push_numhl 
443e			 
443e				       NEXTW 
443e c3 63 1d			jp macro_next 
4441				endm 
# End of macro NEXTW
4441			.V1S: 
4441				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4441 7a				db WORD_SYS_CORE+102             
4442 59 44			dw .V1Q            
4444 04				db 3 + 1 
4445 .. 00			db "V1!",0              
4449				endm 
# End of macro CWHEAD
4449			;| V1! ( u1 -- )  Store value to v1 | DONE 
4449					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4449 cd f1 1b			call macro_dsp_valuehl 
444c				endm 
# End of macro FORTH_DSP_VALUEHL
444c			 
444c 11 0c eb				ld de, cli_var_array+2 
444f				 
444f eb					ex de, hl 
4450 73					ld (hl), e 
4451 23					inc hl 
4452 72					ld (hl), d 
4453			 
4453					; destroy value TOS 
4453			 
4453					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4453 cd a9 1c			call macro_forth_dsp_pop 
4456				endm 
# End of macro FORTH_DSP_POP
4456				       NEXTW 
4456 c3 63 1d			jp macro_next 
4459				endm 
# End of macro NEXTW
4459			.V1Q: 
4459				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4459 7b				db WORD_SYS_CORE+103             
445a 6a 44			dw .V2S            
445c 04				db 3 + 1 
445d .. 00			db "V1@",0              
4461				endm 
# End of macro CWHEAD
4461			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4461 2a 0c eb				ld hl, (cli_var_array+2) 
4464 cd fa 19				call forth_push_numhl 
4467				       NEXTW 
4467 c3 63 1d			jp macro_next 
446a				endm 
# End of macro NEXTW
446a			.V2S: 
446a				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
446a 7c				db WORD_SYS_CORE+104             
446b 82 44			dw .V2Q            
446d 04				db 3 + 1 
446e .. 00			db "V2!",0              
4472				endm 
# End of macro CWHEAD
4472			;| V2! ( u1 -- )  Store value to v2 | DONE 
4472					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4472 cd f1 1b			call macro_dsp_valuehl 
4475				endm 
# End of macro FORTH_DSP_VALUEHL
4475			 
4475 11 0e eb				ld de, cli_var_array+4 
4478				 
4478 eb					ex de, hl 
4479 73					ld (hl), e 
447a 23					inc hl 
447b 72					ld (hl), d 
447c			 
447c					; destroy value TOS 
447c			 
447c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
447c cd a9 1c			call macro_forth_dsp_pop 
447f				endm 
# End of macro FORTH_DSP_POP
447f				       NEXTW 
447f c3 63 1d			jp macro_next 
4482				endm 
# End of macro NEXTW
4482			.V2Q: 
4482				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4482 7d				db WORD_SYS_CORE+105             
4483 93 44			dw .V3S            
4485 04				db 3 + 1 
4486 .. 00			db "V2@",0              
448a				endm 
# End of macro CWHEAD
448a			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
448a 2a 0e eb				ld hl, (cli_var_array+4) 
448d cd fa 19				call forth_push_numhl 
4490				       NEXTW 
4490 c3 63 1d			jp macro_next 
4493				endm 
# End of macro NEXTW
4493			.V3S: 
4493				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4493 7c				db WORD_SYS_CORE+104             
4494 ab 44			dw .V3Q            
4496 04				db 3 + 1 
4497 .. 00			db "V3!",0              
449b				endm 
# End of macro CWHEAD
449b			;| V3! ( u1 -- )  Store value to v3 | DONE 
449b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
449b cd f1 1b			call macro_dsp_valuehl 
449e				endm 
# End of macro FORTH_DSP_VALUEHL
449e			 
449e 11 10 eb				ld de, cli_var_array+6 
44a1				 
44a1 eb					ex de, hl 
44a2 73					ld (hl), e 
44a3 23					inc hl 
44a4 72					ld (hl), d 
44a5			 
44a5					; destroy value TOS 
44a5			 
44a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44a5 cd a9 1c			call macro_forth_dsp_pop 
44a8				endm 
# End of macro FORTH_DSP_POP
44a8				       NEXTW 
44a8 c3 63 1d			jp macro_next 
44ab				endm 
# End of macro NEXTW
44ab			.V3Q: 
44ab				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
44ab 7d				db WORD_SYS_CORE+105             
44ac bc 44			dw .END            
44ae 04				db 3 + 1 
44af .. 00			db "V3@",0              
44b3				endm 
# End of macro CWHEAD
44b3			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
44b3 2a 10 eb				ld hl, (cli_var_array+6) 
44b6 cd fa 19				call forth_push_numhl 
44b9				       NEXTW 
44b9 c3 63 1d			jp macro_next 
44bc				endm 
# End of macro NEXTW
44bc			 
44bc			 
44bc			 
44bc			 
44bc			 
44bc			; end of dict marker 
44bc			 
44bc 00			.END:    db WORD_SYS_END 
44bd 00 00			dw 0 
44bf 00				db 0 
44c0			 
44c0			; use to jp here for user dict words to save on macro expansion  
44c0			 
44c0			user_dict_next: 
44c0				NEXTW 
44c0 c3 63 1d			jp macro_next 
44c3				endm 
# End of macro NEXTW
44c3			 
44c3			 
44c3			user_exec: 
44c3				;    ld hl, <word code> 
44c3				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
44c3				;    call forthexec 
44c3				;    jp user_dict_next   (NEXT) 
44c3			        ;    <word code bytes> 
44c3 eb				ex de, hl 
44c4 2a 58 e6			ld hl,(os_tok_ptr) 
44c7				 
44c7				FORTH_RSP_NEXT 
44c7 cd a1 19			call macro_forth_rsp_next 
44ca				endm 
# End of macro FORTH_RSP_NEXT
44ca			 
44ca			if DEBUG_FORTH_UWORD 
44ca						DMARK "UEX" 
44ca f5				push af  
44cb 3a df 44			ld a, (.dmark)  
44ce 32 71 ee			ld (debug_mark),a  
44d1 3a e0 44			ld a, (.dmark+1)  
44d4 32 72 ee			ld (debug_mark+1),a  
44d7 3a e1 44			ld a, (.dmark+2)  
44da 32 73 ee			ld (debug_mark+2),a  
44dd 18 03			jr .pastdmark  
44df ..			.dmark: db "UEX"  
44e2 f1			.pastdmark: pop af  
44e3			endm  
# End of macro DMARK
44e3				CALLMONITOR 
44e3 cd 6d 14			call break_point_state  
44e6				endm  
# End of macro CALLMONITOR
44e6			endif 
44e6			 
44e6			 
44e6			 
44e6 eb				ex de, hl 
44e7 22 58 e6			ld (os_tok_ptr), hl 
44ea				 
44ea				; Don't use next - Skips the first word in uword. 
44ea			 
44ea c3 f4 1d			jp exec1 
44ed			;	NEXT 
44ed			 
44ed			 
44ed			; eof 
# End of file forth_wordsv4.asm
44ed			endif 
44ed			;;;;;;;;;;;;;; Debug code 
44ed			 
44ed			 
44ed			;if DEBUG_FORTH_PARSE 
44ed .. 00		.nowordfound: db "No match",0 
44f6 .. 00		.compword:	db "Comparing word ",0 
4506 .. 00		.nextwordat:	db "Next word at",0 
4513 .. 00		.charmatch:	db "Char match",0 
451e			;endif 
451e			if DEBUG_FORTH_JP 
451e			.foundword:	db "Word match. Exec..",0 
451e			endif 
451e			;if DEBUG_FORTH_PUSH 
451e .. 00		.enddict:	db "Dict end. Push.",0 
452e .. 00		.push_str:	db "Pushing string",0 
453d .. 00		.push_num:	db "Pushing number",0 
454c .. 00		.data_sp:	db "SP:",0 
4550 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4562 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4574 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4586			;endif 
4586			;if DEBUG_FORTH_MALLOC 
4586 .. 00		.push_malloc:	db "Malloc address",0 
4595			;endif 
4595			 
4595			 
4595			 
4595			; display malloc address and current data stack pointer  
4595			 
4595			malloc_error: 
4595 d5				push de 
4596 f5				push af 
4597 e5				push hl 
4598 cd 97 09			call clear_display 
459b 11 bd 45			ld de, .mallocerr 
459e 3e 00			ld a,0 
45a0			;	ld de,os_word_scratch 
45a0 cd aa 09			call str_at_display 
45a3 3e 11			ld a, display_row_1+17 
45a5 11 71 ee			ld de, debug_mark 
45a8 cd aa 09			call str_at_display 
45ab cd ba 09			call update_display 
45ae				;call break_point_state 
45ae cd 17 59			call cin_wait 
45b1			 
45b1 3e 20			ld a, ' ' 
45b3 32 48 e3			ld (os_view_disable), a 
45b6 e1				pop hl 
45b7 f1				pop af 
45b8 d1				pop de	 
45b9				CALLMONITOR 
45b9 cd 6d 14			call break_point_state  
45bc				endm  
# End of macro CALLMONITOR
45bc c9				ret 
45bd			 
45bd .. 00		.mallocerr: 	db "Malloc Error",0 
45ca			;if DEBUG_FORTH_PUSH 
45ca			display_data_sp: 
45ca f5				push af 
45cb			 
45cb				; see if disabled 
45cb			 
45cb 3a 48 e3			ld a, (os_view_disable) 
45ce fe 2a			cp '*' 
45d0 28 67			jr z, .skipdsp 
45d2			 
45d2 e5				push hl 
45d3 e5				push hl 
45d4 e5			push hl 
45d5 cd 97 09			call clear_display 
45d8 e1			pop hl 
45d9 7c				ld a,h 
45da 21 5c e6			ld hl, os_word_scratch 
45dd cd c5 0e			call hexout 
45e0 e1				pop hl 
45e1 7d				ld a,l 
45e2 21 5e e6			ld hl, os_word_scratch+2 
45e5 cd c5 0e			call hexout 
45e8 21 60 e6			ld hl, os_word_scratch+4 
45eb 3e 00			ld a,0 
45ed 77				ld (hl),a 
45ee 11 5c e6			ld de,os_word_scratch 
45f1 3e 28				ld a, display_row_2 
45f3 cd aa 09				call str_at_display 
45f6 11 50 45			ld de, .wordinhl 
45f9 3e 00			ld a, display_row_1 
45fb			 
45fb cd aa 09				call str_at_display 
45fe 11 71 ee			ld de, debug_mark 
4601 3e 11			ld a, display_row_1+17 
4603			 
4603 cd aa 09				call str_at_display 
4606			 
4606				; display current data stack pointer 
4606 11 4c 45			ld de,.data_sp 
4609 3e 30				ld a, display_row_2 + 8 
460b cd aa 09				call str_at_display 
460e			 
460e 2a 04 eb			ld hl,(cli_data_sp) 
4611 e5				push hl 
4612 7c				ld a,h 
4613 21 5c e6			ld hl, os_word_scratch 
4616 cd c5 0e			call hexout 
4619 e1				pop hl 
461a 7d				ld a,l 
461b 21 5e e6			ld hl, os_word_scratch+2 
461e cd c5 0e			call hexout 
4621 21 60 e6			ld hl, os_word_scratch+4 
4624 3e 00			ld a,0 
4626 77				ld (hl),a 
4627 11 5c e6			ld de,os_word_scratch 
462a 3e 33				ld a, display_row_2 + 11 
462c cd aa 09				call str_at_display 
462f			 
462f			 
462f cd ba 09			call update_display 
4632 cd 09 09			call delay1s 
4635 cd 09 09			call delay1s 
4638 e1				pop hl 
4639			.skipdsp: 
4639 f1				pop af 
463a c9				ret 
463b			 
463b			display_data_malloc: 
463b			 
463b f5				push af 
463c e5				push hl 
463d e5				push hl 
463e e5			push hl 
463f cd 97 09			call clear_display 
4642 e1			pop hl 
4643 7c				ld a,h 
4644 21 5c e6			ld hl, os_word_scratch 
4647 cd c5 0e			call hexout 
464a e1				pop hl 
464b 7d				ld a,l 
464c 21 5e e6			ld hl, os_word_scratch+2 
464f cd c5 0e			call hexout 
4652 21 60 e6			ld hl, os_word_scratch+4 
4655 3e 00			ld a,0 
4657 77				ld (hl),a 
4658 11 5c e6			ld de,os_word_scratch 
465b 3e 28				ld a, display_row_2 
465d cd aa 09				call str_at_display 
4660 11 86 45			ld de, .push_malloc 
4663 3e 00			ld a, display_row_1 
4665			 
4665 cd aa 09				call str_at_display 
4668			 
4668				; display current data stack pointer 
4668 11 4c 45			ld de,.data_sp 
466b 3e 30				ld a, display_row_2 + 8 
466d cd aa 09				call str_at_display 
4670			 
4670 2a 04 eb			ld hl,(cli_data_sp) 
4673 e5				push hl 
4674 7c				ld a,h 
4675 21 5c e6			ld hl, os_word_scratch 
4678 cd c5 0e			call hexout 
467b e1				pop hl 
467c 7d				ld a,l 
467d 21 5e e6			ld hl, os_word_scratch+2 
4680 cd c5 0e			call hexout 
4683 21 60 e6			ld hl, os_word_scratch+4 
4686 3e 00			ld a,0 
4688 77				ld (hl),a 
4689 11 5c e6			ld de,os_word_scratch 
468c 3e 33				ld a, display_row_2 + 11 
468e cd aa 09				call str_at_display 
4691			 
4691 cd ba 09			call update_display 
4694 cd 09 09			call delay1s 
4697 cd 09 09			call delay1s 
469a e1				pop hl 
469b f1				pop af 
469c c9				ret 
469d			;endif 
469d			 
469d			include "forth_autostart.asm" 
469d			; list of commands to perform at system start up 
469d			 
469d			startcmds: 
469d			;	dw test11 
469d			;	dw test12 
469d			;	dw test13 
469d			;	dw test14 
469d			;	dw test15 
469d			;	dw test16 
469d			;	dw test17 
469d			;	dw ifthtest1 
469d			;	dw ifthtest2 
469d			;	dw ifthtest3 
469d			;	dw mmtest1 
469d			;	dw mmtest2 
469d			;	dw mmtest3 
469d			;	dw mmtest4 
469d			;	dw mmtest5 
469d			;	dw mmtest6 
469d			;	dw iftest1 
469d			;	dw iftest2 
469d			;	dw iftest3 
469d			;	dw looptest1 
469d			;	dw looptest2 
469d			;	dw test1 
469d			;	dw test2 
469d			;	dw test3 
469d			;	dw test4 
469d			;	dw game2r 
469d			;	dw game2b1 
469d			;	dw game2b2 
469d			 
469d				; start up words that are actually useful 
469d			 
469d fb 46			dw clrstack 
469f 2e 47			dw type 
46a1 ef 48			dw stest 
46a3 52 47			dw strncpy 
46a5 90 48			dw list 
46a7 b3 47			dw start1 
46a9 c5 47			dw start2 
46ab			;	dw start3 
46ab d8 47			dw start3b 
46ad 30 48			dw start3c 
46af			 
46af				; (unit) testing words 
46af			 
46af 66 49			dw mtesta 
46b1 1b 4a			dw mtestb 
46b3 be 4a			dw mtestc 
46b5 73 4b			dw mtestd 
46b7 17 4c			dw mteste 
46b9			 
46b9				; demo/game words 
46b9			 
46b9 23 53		        dw game3w 
46bb 51 53		        dw game3p 
46bd 6f 53		        dw game3sc 
46bf a0 53		        dw game3vsi 
46c1 cc 53		        dw game3vs 
46c3				 
46c3 16 51			dw game2b 
46c5 84 51			dw game2bf 
46c7 ce 51			dw game2mba 
46c9 64 52			dw game2mbas 
46cb a6 52			dw game2mb 
46cd			 
46cd d7 4d			dw game1 
46cf e8 4d			dw game1a 
46d1 4a 4e			dw game1b 
46d3 7f 4e			dw game1c 
46d5 b5 4e			dw game1d 
46d7 e6 4e			dw game1s 
46d9 fa 4e			dw game1t 
46db 0f 4f			dw game1f 
46dd 43 4f			dw game1z 
46df 87 4f			dw game1zz 
46e1			 
46e1 cd 4c			dw test5 
46e3 05 4d			dw test6 
46e5 3d 4d			dw test7 
46e7 51 4d			dw test8 
46e9 7d 4d			dw test9 
46eb 93 4d			dw test10 
46ed				 
46ed 5e 50		        dw ssv5 
46ef 42 50		        dw ssv4 
46f1 26 50		        dw ssv3 
46f3 f0 4f		        dw ssv2 
46f5 77 50		        dw ssv1 
46f7 bf 50		        dw ssv1cpm 
46f9			;	dw keyup 
46f9			;	dw keydown 
46f9			;	dw keyleft 
46f9			;	dw keyright 
46f9			;	dw 	keyf1 
46f9			;	dw keyf2 
46f9			;	dw keyf3 
46f9			;	dw keyf4 
46f9			;	dw keyf5 
46f9			;	dw keyf6 
46f9			;	dw keyf7 
46f9			;	dw keyf8 
46f9			;	dw keyf9 
46f9			;	dw keyf10 
46f9			;	dw keyf11 
46f9			;	dw keyf12 
46f9			;	dw keytab 
46f9			;	dw keycr 
46f9			;	dw keyhome 
46f9			;	dw keyend 
46f9			;	dw keybs 
46f9 00 00			db 0, 0	 
46fb			 
46fb			 
46fb			; clear stack  
46fb			 
46fb .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
472e			 
472e			; type ( addr count - ) 
472e .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4752			 
4752			; some direct memory words 
4752			; strncpy ( len t f -- t ) 
4752			 
4752 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
47b3			 
47b3 .. 00		start1:     	db ": bpon $0000 bp ;",0 
47c5 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
47d8			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
47d8 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
4830 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
4890			 
4890			 
4890			; a handy word to list items on the stack 
4890			 
4890 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
48ef			 
48ef			 
48ef			; test stack  
48ef			; rnd8 stest 
48ef			 
48ef .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4966			 
4966			; random malloc and free cycles 
4966			 
4966 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4a1b			 
4a1b			; fixed malloc and free cycles 
4a1b			 
4a1b .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4abe			 
4abe			; fixed double string push and drop cycle  
4abe			 
4abe .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4b73			 
4b73			; consistent fixed string push and drop cycle  
4b73			 
4b73 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4c17			 
4c17 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4ccd			 
4ccd			;test1:		db ": aa 1 2 3 ;", 0 
4ccd			;test2:     	db "111 aa 888 999",0 
4ccd			;test3:     	db ": bb 77 ;",0 
4ccd			;test4:     	db "$02 $01 do i . loop bb",0 
4ccd			 
4ccd .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4d05 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4d3d .. 00		test7:     	db ": box hline vline ;",0 
4d51 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4d7d .. 00		test9:     	db ": sw $01 adsp world ;",0 
4d93 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4db8 .. 00		test11:     	db "hello create .",0 
4dc7 .. 00		test12:     	db "hello2 create .",0 
4dd7			 
4dd7			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4dd7			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4dd7			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4dd7			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4dd7			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4dd7			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4dd7			 
4dd7			;iftest1:     	db "$0001 IF cls .",0 
4dd7			;iftest2:     	db "$0000 IF cls .",0 
4dd7			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4dd7			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4dd7			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4dd7			 
4dd7			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4dd7			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4dd7			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4dd7			 
4dd7			 
4dd7			 
4dd7			; a small guess the number game 
4dd7			 
4dd7 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4de8 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4e4a			 
4e4a .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4e7f .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4eb5 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4ee6 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4efa .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4f0f .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4f43 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4f87			 
4f87			; Using 'ga' save a high score across multiple runs using external storage 
4f87			 
4f87 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
4ff0			 
4ff0			 
4ff0			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
4ff0			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
4ff0			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
4ff0			 
4ff0			; simple screen saver to test code memory reuse to destruction 
4ff0			 
4ff0 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5026 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5042 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
505e .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5077 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
50bf .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5116			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5116			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5116			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5116			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5116			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5116			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5116			 
5116			 
5116			 
5116			; minesweeper/battleship finding game 
5116			; draws a game board of random ship/mine positions 
5116			; user enters coords to see if it hits on 
5116			; game ends when all are hit 
5116			; when hit or miss says how many may be in the area 
5116			 
5116			; setup the game board and then hide it 
5116 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5184 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
51ce			; prompt for where to target 
51ce .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5264 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5289			; TODO see if the entered coords hits or misses pushes char hit of miss 
5289 .. 00		game2mbht:      db ": mbckht nop ;",0 
5298 .. 00		game2mbms:      db ": mbcms nop ;",0 
52a6			; TODO how many might be near by 
52a6 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5323			 
5323			; Game 3 
5323			 
5323			; Vert scroller ski game - avoid the trees! 
5323			 
5323			; v0 score (ie turns) 
5323			; v1 player pos 
5323			; v2 left wall 
5323			; v3 right wall 
5323			 
5323			; Draw side walls randomly 
5323			 
5323 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5351			 
5351			; Draw player 
5351 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
536f			 
536f			; TODO Get Key 
536f			 
536f			; TODO Move left right 
536f			 
536f			; scroll and move walls a bit 
536f			 
536f .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
53a0			 
53a0			; main game loop 
53a0			 
53a0 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
53cc .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
540b			 
540b			; key board defs 
540b			 
540b .. 00		keyup:       db ": keyup $05 ;",0 
5419 .. 00		keydown:       db ": keydown $0a ;",0 
5429 .. 00		keyleft:       db ": keyleft $0b ;",0 
5439 .. 00		keyright:       db ": keyright $0c ;",0 
544a .. 00		keyf1:       db ": keyf1 $10 ;",0 
5458 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5466 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5474 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5482 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5490 .. 00		keyf6:       db ": keyf6 $15 ;",0 
549e .. 00		keyf7:       db ": keyf7 $16 ;",0 
54ac .. 00		keyf8:       db ": keyf8 $17 ;",0 
54ba .. 00		keyf9:       db ": keyf9 $18 ;",0 
54c8 .. 00		keyf10:       db ": keyf10 $19 ;",0 
54d7 .. 00		keyf11:       db ": keyf11 $1a ;",0 
54e6 .. 00		keyf12:       db ": keyf12 $1b ;",0 
54f5			 
54f5 .. 00		keytab:       db ": keytab $09 ;",0 
5504 .. 00		keycr:       db ": keycr $0d ;",0 
5512 .. 00		keyhome:       db ": keyhome $0e ;",0 
5522 .. 00		keyend:       db ": keyend $0f ;",0 
5531 .. 00		keybs:       db ": keybs $08 ;",0 
553f			 
553f			   
553f			 
553f			 
553f			 
553f			; eof 
# End of file forth_autostart.asm
553f			 
553f .. 00		sprompt1: db "Startup load...",0 
554f .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5565			 
5565			 
5565			 
5565			 
5565			forth_startup: 
5565 21 9d 46			ld hl, startcmds 
5568 3e 00			ld a, 0 
556a 32 7d e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
556d			 
556d e5			.start1:	push hl 
556e cd 97 09			call clear_display 
5571 11 3f 55			ld de, sprompt1 
5574 3e 00		        ld a, display_row_1 
5576 cd aa 09			call str_at_display 
5579 11 4f 55			ld de, sprompt2 
557c 3e 28		        ld a, display_row_2 
557e cd aa 09			call str_at_display 
5581 e1				pop hl 
5582 e5				push hl 
5583 5e				ld e,(hl) 
5584 23				inc hl 
5585 56				ld d,(hl) 
5586 3e 50		        ld a, display_row_3 
5588 cd aa 09			call str_at_display 
558b cd ba 09			call update_display 
558e			 
558e			 
558e 3a 7d e7			ld a, (os_last_cmd) 
5591 fe 00			cp 0 
5593 28 05			jr z, .startprompt 
5595 cd fd 08			call delay250ms 
5598 18 24			jr .startdo 
559a				 
559a				 
559a			 
559a			.startprompt: 
559a			 
559a 3e 9f			ld a,display_row_4 + display_cols - 1 
559c 11 70 19		        ld de, endprg 
559f cd aa 09			call str_at_display 
55a2 cd ba 09			call update_display 
55a5 cd 09 09			call delay1s 
55a8 cd 17 59			call cin_wait 
55ab						 
55ab fe 2a			cp '*' 
55ad 28 5e			jr z, .startupend1 
55af fe 23			cp '#' 
55b1 20 07			jr nz, .startno 
55b3 3e 01			ld a, 1 
55b5 32 7d e7			ld (os_last_cmd),a 
55b8 18 04			jr .startdo 
55ba fe 31		.startno:	cp '1' 
55bc 28 3a			jr z,.startnxt  
55be			 
55be				; exec startup line 
55be			.startdo:	 
55be e1				pop hl 
55bf e5				push hl 
55c0				 
55c0 5e				ld e,(hl) 
55c1 23				inc hl 
55c2 56				ld d,(hl) 
55c3 eb				ex de,hl 
55c4			 
55c4 e5				push hl 
55c5			 
55c5 3e 00			ld a, 0 
55c7				;ld a, FORTH_END_BUFFER 
55c7 cd 2d 10			call strlent 
55ca 23				inc hl   ; include zero term to copy 
55cb 06 00			ld b,0 
55cd 4d				ld c,l 
55ce e1				pop hl 
55cf 11 57 e3			ld de, scratch 
55d2 ed b0			ldir 
55d4			 
55d4			 
55d4 21 57 e3			ld hl, scratch 
55d7 cd b1 1d			call forthparse 
55da cd f1 1d			call forthexec 
55dd cd 08 1d			call forthexec_cleanup 
55e0			 
55e0 3e 78			ld a, display_row_4 
55e2 11 14 17			ld de, endprog 
55e5			 
55e5 cd ba 09			call update_display		 
55e8			 
55e8 3a 7d e7			ld a, (os_last_cmd) 
55eb fe 00			cp 0 
55ed 20 09			jr nz, .startnxt 
55ef cd 72 19			call next_page_prompt 
55f2 cd 97 09		        call clear_display 
55f5 cd ba 09			call update_display		 
55f8			 
55f8				; move onto next startup line? 
55f8			.startnxt: 
55f8			 
55f8 cd fd 08			call delay250ms 
55fb e1				pop hl 
55fc			 
55fc 23				inc hl 
55fd 23				inc hl 
55fe			 
55fe e5				push hl 
55ff 5e				ld e, (hl) 
5600 23				inc hl 
5601 56				ld d, (hl) 
5602 e1				pop hl 
5603				; TODO replace 0 test 
5603			 
5603 eb				ex de, hl 
5604 cd ed 0b			call ishlzero 
5607			;	ld a,e 
5607			;	add d 
5607			;	cp 0    ; any left to do? 
5607 eb				ex de, hl 
5608 c2 6d 55			jp nz, .start1 
560b 18 01			jr .startupend 
560d			 
560d e1			.startupend1: pop hl 
560e			.startupend: 
560e			 
560e cd 97 09			call clear_display 
5611 cd ba 09			call update_display 
5614 c9				ret 
5615			 
5615			 
5615			; stack over and underflow checks 
5615			 
5615			; init the words to detect the under/overflow 
5615			 
5615			chk_stk_init: 
5615				; a vague random number to check so we dont get any "lucky" hits 
5615 3e 2d			ld a, 45 
5617 6f				ld l, a 
5618 00				nop 
5619 3e 17			ld a, 23 
561b 67				ld h, a 
561c			 
561c 22 3e e3			ld (chk_word), hl     ; the word we need to check against 
561f			 
561f			;	ld (chk_stund), hl	; stack points.... 
561f 22 00 ef			ld (chk_stovr), hl 
5622 22 02 eb			ld (chk_ret_und), hl 
5625 22 c0 ea			ld (chk_ret_ovr), hl 
5628 22 be e9			ld (chk_loop_ovr), hl 
562b 22 bc e8			ld (chk_data_ovr), hl 
562e c9				ret 
562f				 
562f			check_stacks: 
562f				; check all stack words 
562f			 
562f e5				push hl 
5630 d5				push de 
5631			 
5631			;	ld de,(chk_word) 
5631			;	ld hl, (chk_stund)	; stack points.... 
5631			;	if DEBUG_STK_FAULT 
5631			;		DMARK "FAa" 
5631			;		CALLMONITOR 
5631			;	endif 
5631			;	call cmp16 
5631			;	jp z, .chk_faulta 
5631			; 
5631			;	ld de, sfaultsu 
5631			;	jp .chk_fault 
5631			 
5631 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5634 ed 5b 3e e3		ld de,(chk_word) 
5638				if DEBUG_STK_FAULT 
5638					DMARK "FAb" 
5638					CALLMONITOR 
5638				endif 
5638 cd e2 0b			call cmp16 
563b 28 06			jr z, .chk_fault1 
563d 11 de 56			ld de, sfaultso 
5640 c3 92 56			jp .chk_fault 
5643			.chk_fault1:  
5643 2a 02 eb			ld hl, (chk_ret_und) 
5646 ed 5b 3e e3		ld de,(chk_word) 
564a				if DEBUG_STK_FAULT 
564a					DMARK "FAU" 
564a					CALLMONITOR 
564a				endif 
564a cd e2 0b			call cmp16 
564d ca 56 56			jp z, .chk_fault2 
5650 11 ee 56			ld de, sfaultru 
5653 c3 92 56			jp .chk_fault 
5656			.chk_fault2:  
5656 2a c0 ea			ld hl, (chk_ret_ovr) 
5659 ed 5b 3e e3		ld de,(chk_word) 
565d				if DEBUG_STK_FAULT 
565d					DMARK "FA1" 
565d					CALLMONITOR 
565d				endif 
565d cd e2 0b			call cmp16 
5660 ca 69 56			jp z, .chk_fault3 
5663 11 fc 56			ld de, sfaultro 
5666 c3 92 56			jp .chk_fault 
5669			.chk_fault3:  
5669 2a be e9			ld hl, (chk_loop_ovr) 
566c ed 5b 3e e3		ld de,(chk_word) 
5670				if DEBUG_STK_FAULT 
5670					DMARK "FA2" 
5670					CALLMONITOR 
5670				endif 
5670 cd e2 0b			call cmp16 
5673 ca 7c 56			jp z, .chk_fault4 
5676 11 16 57			ld de, sfaultlo 
5679 c3 92 56			jp .chk_fault 
567c			.chk_fault4:  
567c 2a bc e8			ld hl, (chk_data_ovr) 
567f ed 5b 3e e3		ld de,(chk_word) 
5683				if DEBUG_STK_FAULT 
5683					DMARK "FA3" 
5683					CALLMONITOR 
5683				endif 
5683 cd e2 0b			call cmp16 
5686 ca 8f 56			jp z, .chk_fault5 
5689 11 30 57			ld de, sfaultdo 
568c c3 92 56			jp .chk_fault 
568f			 
568f			 
568f			.chk_fault5:  
568f d1				pop de 
5690 e1				pop hl 
5691			 
5691 c9				ret 
5692			 
5692 cd 97 09		.chk_fault: 	call clear_display 
5695 3e 28				ld a, display_row_2 
5697 cd aa 09				call str_at_display 
569a 11 c0 56				   ld de, .stackfault 
569d 3e 00				ld a, display_row_1 
569f cd aa 09				call str_at_display 
56a2 11 71 ee				    ld de, debug_mark 
56a5 3e 11				ld a, display_row_1+17 
56a7 cd aa 09				call str_at_display 
56aa cd ba 09				call update_display 
56ad			 
56ad				; prompt before entering montior for investigating issue 
56ad			 
56ad 3e 78			ld a, display_row_4 
56af 11 14 17			ld de, endprog 
56b2			 
56b2 cd ba 09			call update_display		 
56b5			 
56b5 cd 72 19			call next_page_prompt 
56b8			 
56b8 d1				pop de 
56b9 e1				pop hl 
56ba cd 68 17				call monitor 
56bd c3 62 16				jp warmstart 
56c0					;jp 0 
56c0					;halt 
56c0			 
56c0			 
56c0			 
56c0 .. 00		.stackfault: 	db "Stack fault:",0 
56cd			 
56cd .. 00		sfaultsu: 	db	"Stack under flow",0 
56de .. 00		sfaultso: 	db	"Stack over flow",0 
56ee .. 00		sfaultru:	db "RTS underflow",0 
56fc .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5716 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5730 .. 00		sfaultdo:	db "DTS overflow", 0 
573d			 
573d			 
573d			fault_dsp_under: 
573d 11 4f 57			ld de, .dsp_under 
5740 c3 ff 57			jp .show_fault 
5743			 
5743			fault_rsp_under: 
5743 11 5d 57			ld de, .rsp_under 
5746 c3 ff 57			jp .show_fault 
5749			fault_loop_under: 
5749 11 6b 57			ld de, .loop_under 
574c c3 ff 57			jp .show_fault 
574f			 
574f .. 00		.dsp_under: db "DSP Underflow",0 
575d .. 00		.rsp_under: db "RSP Underflow",0 
576b .. 00		.loop_under: db "LOOP Underflow",0 
577a			 
577a			 
577a d5			type_faultn: 	push de 
577b e5					push hl 
577c cd 97 09				call clear_display 
577f 11 a6 57				   ld de, .typefaultn 
5782 3e 00				ld a, display_row_1 
5784 cd aa 09				call str_at_display 
5787 11 71 ee				    ld de, debug_mark 
578a 3e 11				ld a, display_row_1+17 
578c cd aa 09				call str_at_display 
578f cd ba 09				call update_display 
5792			 
5792				; prompt before entering montior for investigating issue 
5792			 
5792 3e 78			ld a, display_row_4 
5794 11 14 17			ld de, endprog 
5797			 
5797 cd ba 09			call update_display		 
579a			 
579a cd 72 19			call next_page_prompt 
579d			 
579d e5					push hl 
579e d5					push de 
579f cd 68 17				call monitor 
57a2 c3 62 16				jp warmstart 
57a5 76					halt 
57a6			 
57a6			 
57a6 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
57bd			 
57bd d5			type_faults: 	push de 
57be e5					push hl 
57bf cd 97 09				call clear_display 
57c2 11 e8 57				   ld de, .typefaults 
57c5 3e 00				ld a, display_row_1 
57c7 cd aa 09				call str_at_display 
57ca 11 71 ee				    ld de, debug_mark 
57cd 3e 11				ld a, display_row_1+17 
57cf cd aa 09				call str_at_display 
57d2 cd ba 09				call update_display 
57d5			 
57d5				; prompt before entering montior for investigating issue 
57d5			 
57d5 3e 78			ld a, display_row_4 
57d7 11 14 17			ld de, endprog 
57da			 
57da cd ba 09			call update_display		 
57dd			 
57dd cd 72 19			call next_page_prompt 
57e0			 
57e0 e1					pop hl 
57e1 d1					pop de 
57e2 cd 68 17				call monitor 
57e5 c3 62 16				jp warmstart 
57e8			 
57e8			 
57e8 .. 00		.typefaults: db "STR Type Expected TOS!",0 
57ff			 
57ff			.show_fault: 	 
57ff d5					push de 
5800 cd 97 09				call clear_display 
5803 d1					pop de 
5804 3e 00				ld a, display_row_1 
5806 cd aa 09				call str_at_display 
5809 11 71 ee				    ld de, debug_mark 
580c 3e 11				ld a, display_row_1+17 
580e cd aa 09				call str_at_display 
5811 cd ba 09				call update_display 
5814			 
5814				; prompt before entering montior for investigating issue 
5814			 
5814 3e 78			ld a, display_row_4 
5816 11 14 17			ld de, endprog 
5819			 
5819 cd ba 09			call update_display		 
581c			 
581c cd 72 19			call next_page_prompt 
581f			 
581f e1					pop hl 
5820 d1					pop de 
5821 cd 68 17				call monitor 
5824			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5824			; TODO Make optional fault restart to cli or warm boot? 
5824					;jp warmstart 
5824 c3 ba 16				jp cli 
5827 76					halt 
5828			 
5828			; handle the auto run of code from files in storage 
5828			 
5828			 
5828			if STORAGE_SE 
5828			 
5828			sprompt3: db "Loading from start-up file?:",0 
5828			sprompt4: db "(Y=Any key/N=No)",0 
5828			 
5828			 
5828			forth_autoload: 
5828			 
5828				; load block 0 of store 1 
5828				 
5828				ld a, $fe      ; bit 0 clear 
5828				ld (spi_device), a 
5828			 
5828				call storage_get_block_0 
5828			 
5828				ld a, (store_page+STORE_0_AUTOFILE) 
5828			 
5828				cp 0 
5828				ret z     ; auto start not enabled 
5828			 
5828				call clear_display 
5828			 
5828				; set bank 
5828			 
5828					ld a, (store_page+STORE_0_BANKRUN) 
5828					ld (spi_device), a 
5828			 
5828				; get file id to load from and get the file name to display 
5828			 
5828					ld a, (store_page+STORE_0_FILERUN) 
5828			 
5828					ld l, 0 
5828					ld h, a 
5828					ld de, store_page 
5828			 
5828					if DEBUG_FORTH_WORDS 
5828						DMARK "ASp" 
5828						CALLMONITOR 
5828					endif 
5828					call storage_read 
5828			 
5828					if DEBUG_FORTH_WORDS 
5828						DMARK "ASr" 
5828						CALLMONITOR 
5828					endif 
5828			 
5828					call ishlzero 
5828					ret z             ; file not found 
5828			 
5828					ld a, display_row_2 + 10 
5828					ld de, store_page+3 
5828					call str_at_display 
5828				 
5828			; 
5828			 
5828				ld a, display_row_1+5 
5828				ld de, sprompt3 
5828				call str_at_display 
5828				ld a, display_row_3+15 
5828				ld de, sprompt4 
5828				call str_at_display 
5828			 
5828				call update_display 
5828			 
5828				call cin_wait 
5828				cp 'n' 
5828				ret z 
5828				cp 'N' 
5828				ret z 
5828			 
5828				call delay1s 
5828			 
5828				ld a, (store_page+2) 
5828				ld (store_openmaxext), a    ; save count of ext 
5828				ld a, 1  
5828				ld (store_openext), a    ; save count of ext 
5828			 
5828			.autof:  
5828				ld l , a 
5828				 
5828				ld a, (store_page) 
5828				ld h, a	 
5828				ld de, store_page 
5828					if DEBUG_FORTH_WORDS 
5828						DMARK "ASl" 
5828						CALLMONITOR 
5828					endif 
5828					call storage_read 
5828				call ishlzero 
5828				ret z 
5828			;	jr z, .autoend 
5828			 
5828					if DEBUG_FORTH_WORDS 
5828						DMARK "ASc" 
5828						CALLMONITOR 
5828					endif 
5828				ld de, store_page+2 
5828				ld a, display_row_4 
5828				call str_at_display 
5828			 
5828				call update_display 
5828				call delay250ms 
5828			 
5828			 
5828			 
5828				ld hl, store_page+2 
5828				call forthparse 
5828				call forthexec 
5828				call forthexec_cleanup 
5828			 
5828				 
5828				ld a, (store_openext) 
5828				inc a 
5828				ld (store_openext), a    ; save count of ext 
5828			 
5828				jr .autof 
5828			;.autofdone: 
5828			; 
5828			;		if DEBUG_FORTH_WORDS 
5828			;			DMARK "ASx" 
5828			;			CALLMONITOR 
5828			;		endif 
5828			;;	call clear_display 
5828			;	ret 
5828			 
5828			 
5828			 
5828			endif 
5828			 
5828			 
5828			; eof 
# End of file forth_kernel.asm
5828			;include "nascombasic.asm" 
5828			 
5828			 
5828			; find out where the code ends if loaded into RAM (for SC114) 
5828			;endofcode:  
5828			;	nop 
5828			 
5828			 
5828			; eof 
5828			 
# End of file main.asm
5828			;include "firmware_lcd_4x40.asm" 
5828			;;include "firmware_lcd_4x20.asm" 
5828			include "firmware_cpm_display.asm" 
5828			 
5828			; Serial display interface for SC114 
5828			 
5828			 
5828			display_row_1: equ 0 
5828			display_row_2: equ display_row_1+display_cols 
5828			display_row_3: equ display_row_2 + display_cols 
5828			display_row_4: equ display_row_3 + display_cols 
5828			 
5828			kLCDWidth:  EQU display_cols             ;Width in characters 
5828			kLCD_Line1: EQU 0x00  
5828			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5828			; E1 
5828			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5828			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5828			 
5828			lcd_init: 
5828				; no init as handled by the SCM bios 
5828 c9				ret 
5829			 
5829			 
5829			; low level functions for direct screen writes 
5829			 
5829			; output char at pos? 
5829			fLCD_Str: 
5829			        ;out (SC114_SIO_1_OUT),a 
5829 c5				push bc 
582a d5				push de 
582b 5f				ld e, a 
582c			; TODO Replace with CP/M BIOS call 
582c 0e 02			ld c, $02 
582e cd 05 00			call 5 
5831 d1				pop de 
5832 c1				pop bc 
5833 c9				ret 
5834			 
5834			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5834			fLCD_Pos: 
5834				; use ASCII escape to position 
5834			        ;out (SC114_SIO_1_OUT),a 
5834 c5				push bc 
5835 d5				push de 
5836 5f				ld e, a 
5837 0e 02			ld c, $02 
5839			; TODO Replace with CP/M BIOS call 
5839 cd 05 00			call 5 
583c d1				pop de 
583d c1				pop bc 
583e			 
583e c9				ret 
583f			 
583f			; output char at pos 
583f			fLCD_Data: 
583f			      ;  out (SC114_SIO_1_OUT),a 
583f c5				push bc 
5840 d5				push de 
5841 0e 02			ld c, $02 
5843 5f				ld e, a 
5844			; TODO Replace with CP/M BIOS call 
5844 cd 05 00			call 5 
5847 d1				pop de 
5848 c1				pop bc 
5849			 
5849 c9				ret 
584a			 
584a			; ascii cls  
584a			 
584a 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
584e			 
584e 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5865			;.clscpm: db 3, $3c,"$" 
5865			 
5865			; write the frame buffer given in hl to hardware  
5865			write_display: 
5865			 
5865			API: equ 0 
5865			 
5865			if API 
5865				push bc 
5865				ld b, 4 
5865			 
5865			        ld (display_write_tmp), hl 	  
5865			 
5865				; clear and home cursor 
5865			 
5865				ld c, 9 
5865				ld de, .cls 
5865			; TODO Replace with CP/M BIOS call 
5865				call 5 
5865			 
5865			 
5865			.writeln: 
5865			 
5865				ld de, (display_write_tmp) 
5865				ld c, 6 
5865			; TODO Replace with CP/M BIOS call 
5865				rst $30 
5865				ld c, 7 
5865				rst $30 
5865			 
5865				ld hl, (display_write_tmp) 
5865				ld de, display_cols 
5865				add hl,de 
5865				ld (display_write_tmp),hl 
5865			 
5865				djnz  .writeln 
5865			 
5865				pop bc 
5865			 
5865			 
5865				ret 
5865			endif 
5865 e5				push hl 
5866 c5				push bc 
5867 d5				push de 
5868			 
5868			;	ld c, 2 
5868			;	;ld de, .cls 
5868			;	ld a, 27 
5868			;	rst $30 
5868			;	ld c, 2 
5868			;	;ld de, .cls 
5868			;	ld a, '[' 
5868			;	rst $30 
5868			; 
5868			;	ld c, 2 
5868			;	;ld de, .cls 
5868			;	ld a, 'H' 
5868			;	rst $30 
5868			; 
5868			 
5868			 
5868			; lots of CR/LF 
5868			;	ld c, 9 
5868			;	ld de, .clscpm 
5868			;	call 5 
5868			 
5868			; xterm cls 
5868 0e 02			ld c, 2 
586a 1e 1b			ld e, 27 
586c cd 05 00			call 5 
586f			; cls causes too much flicker 
586f			;	ld c, 2 
586f			;	ld e, 'c' 
586f			;	call 5 
586f			 
586f			; use xterm home instead 
586f 0e 02			ld c, 2 
5871 1e 5b			ld e, '[' 
5873 cd 05 00			call 5 
5876 0e 02			ld c, 2 
5878 1e 48			ld e, 'H' 
587a cd 05 00			call 5 
587d			LLL: equ 0 
587d			 
587d			if LLL 
587d			 
587d				ld c, 2 
587d				;ld de, .cls 
587d				ld e, 27 
587d			; TODO Replace with CP/M BIOS call 
587d				call 5 
587d			 
587d			 
587d				ld c, 2 
587d				;ld de, .cls 
587d				ld e, '[' 
587d			; TODO Replace with CP/M BIOS call 
587d				call 5 
587d				ld c, 2 
587d				;ld de, .cls 
587d				ld e, '2' 
587d			; TODO Replace with CP/M BIOS call 
587d				call 5 
587d				ld c, 2 
587d				;ld de, .cls 
587d				ld e, 'J' 
587d			; TODO Replace with CP/M BIOS call 
587d				call 5 
587d			 
587d			endif 
587d			 
587d d1				pop de 
587e c1				pop bc 
587f e1				pop hl 
5880			 
5880			 
5880 22 cf eb		        ld (display_write_tmp), hl 	  
5883 3e 00			ld a, kLCD_Line1 
5885			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5885 06 28			ld b, display_cols 
5887 ed 5b cf eb		ld de, (display_write_tmp) 
588b cd 0e 59			call write_len_string 
588e				 
588e			 
588e e5			push hl 
588f d5			push de 
5890 c5			push bc 
5891 0e 02			ld c, 2 
5893 1e 0a			ld e, 10 
5895 cd 05 00			call 5 
5898 0e 02			ld c, 2 
589a 1e 0d			ld e, 13 
589c cd 05 00			call 5 
589f			; TODO Replace with CP/M BIOS call 
589f				;rst $30 
589f c1			pop bc 
58a0 d1			pop de 
58a1 e1			pop hl 
58a2			 
58a2				 
58a2 2a cf eb			ld hl, (display_write_tmp) 
58a5 11 28 00			ld de, display_cols 
58a8 19				add hl,de 
58a9 22 cf eb			ld (display_write_tmp),hl 
58ac			 
58ac				 
58ac 3e 28			ld a, kLCD_Line2 
58ae			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
58ae 06 28			ld b, display_cols 
58b0 ed 5b cf eb		ld de, (display_write_tmp) 
58b4 cd 0e 59			call write_len_string 
58b7				 
58b7 2a cf eb			ld hl, (display_write_tmp) 
58ba 11 28 00			ld de, display_cols 
58bd 19				add hl,de 
58be 22 cf eb			ld (display_write_tmp),hl 
58c1			 
58c1 e5			push hl 
58c2 d5			push de 
58c3 c5			push bc 
58c4 0e 07			ld c, 7 
58c6			; TODO Replace with CP/M BIOS call 
58c6				;rst $30 
58c6 0e 02			ld c, 2 
58c8 1e 0a			ld e, 10 
58ca cd 05 00			call 5 
58cd 0e 02			ld c, 2 
58cf 1e 0d			ld e, 13 
58d1 cd 05 00			call 5 
58d4 c1			pop bc 
58d5 d1			pop de 
58d6 e1			pop hl 
58d7			 
58d7				 
58d7 3e 50			ld a, kLCD_Line3 
58d9			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
58d9 06 28			ld b, display_cols 
58db ed 5b cf eb		ld de, (display_write_tmp) 
58df cd 0e 59			call write_len_string 
58e2				 
58e2 2a cf eb			ld hl, (display_write_tmp) 
58e5 11 28 00			ld de, display_cols 
58e8 19				add hl,de 
58e9 22 cf eb			ld (display_write_tmp),hl 
58ec			 
58ec e5			push hl 
58ed d5			push de 
58ee c5			push bc 
58ef 0e 07			ld c, 7 
58f1			; TODO Replace with CP/M BIOS call 
58f1				;rst $30 
58f1 0e 02			ld c, 2 
58f3 1e 0a			ld e, 10 
58f5 cd 05 00			call 5 
58f8 0e 02			ld c, 2 
58fa 1e 0d			ld e, 13 
58fc cd 05 00			call 5 
58ff c1			pop bc 
5900 d1			pop de 
5901 e1			pop hl 
5902			 
5902				 
5902 3e 78			ld a, kLCD_Line4 
5904			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5904 06 28			ld b, display_cols 
5906 ed 5b cf eb		ld de, (display_write_tmp) 
590a cd 0e 59			call write_len_string 
590d c9					ret 
590e			 
590e			 
590e				; write out a fixed length string given in b from de 
590e			 
590e 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
590f cd 3f 58		            CALL fLCD_Data      ;Write character to display 
5912 13				inc de 
5913 10 f9			djnz write_len_string 
5915 c9				ret 
5916			 
5916			 
5916			; eof 
# End of file firmware_cpm_display.asm
5916			;include "firmware_key_5x10.asm" 
5916			;;include "firmware_key_4x10.asm" 
5916			include "firmware_key_cpm.asm" 
5916			; Serial keyboard interface for SC114 
5916			 
5916			 
5916			key_init: 
5916				; no init as handled by the SCM bios 
5916 c9				ret 
5917			 
5917			 
5917			cin_wait: 
5917			;	ld a, 0 
5917			;	ret 
5917			 
5917				;in a,(SC114_SIO_1_IN) 
5917			        ; Use SCM API to get from whatever console device we are using 
5917			 
5917			; TODO Replace with CP/M BIOS call 
5917 c5				push bc 
5918 0e 01			ld c, $01 
591a cd 05 00			call 5 
591d c1				pop bc 
591e c9				ret 
591f			 
591f			cin: 
591f			 
591f			 
591f c5				push bc 
5920			 
5920				; any key waiting to process? 
5920			; TODO Replace with CP/M BIOS call 
5920 0e 06			ld c, $06 
5922 cd 05 00			call 5 
5925 28 0d			jr z, .cin_skip 
5927			 
5927				; yep, get it 
5927			 
5927 0e 01			ld c, $01 
5929			; TODO Replace with CP/M BIOS call 
5929 cd 05 00			call 5 
592c			 
592c fe 7f			cp $7f     ; back space 
592e 20 02			jr nz, .skipbs 
5930 3e 08			ld a, KEY_BS 
5932			.skipbs: 
5932			 
5932 c1				pop bc 
5933 c9				ret 
5934			.cin_skip: 
5934 3e 00			ld a, 0 
5936 c1				pop bc 
5937 c9				ret 
5938			 
5938			 
5938			 
5938			 
# End of file firmware_key_cpm.asm
5938			endofcode:  
5938			baseram:  
5938 00				nop 
5939			 
5939			heap_start: equ baseram+15  ; Starting address of heap 
5939			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5939			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5939			;VDU:  EQU     endofcode           ; BASIC Work space 
5939			; eof 
5939			 
# End of file os_mega_cpm.asm
5939
