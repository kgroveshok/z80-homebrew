# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 03 19			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd e6 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd e6 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd e6 0a				call clear_display  
0023			  
0023			  
0023 cd 5e 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd a7 66			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd bd 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd 09 0b			call update_display  
0032 cd 66 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd eb 0a			call fill_display  
003a cd 09 0b			call update_display  
003d cd 66 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd eb 0a			call fill_display  
0045 cd 09 0b			call update_display  
0048 cd 66 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd eb 0a			call fill_display  
0050 cd 09 0b			call update_display  
0053 cd 66 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd f9 0a			call str_at_display  
005e cd 09 0b			call update_display  
0061			  
0061			  
0061 cd 66 0a			call delay1s  
0064 cd 66 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd f9 0a			call str_at_display  
006f cd 09 0b			call update_display  
0072 cd 66 0a			call delay1s  
0075 cd 66 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 cf f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a cf f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 cf f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a cf f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 cf f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a d1 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a ce f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 ce f9			ld (spi_device), a 
01e0 32 d1 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a cf f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 cf f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a cf f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 cf f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a cf f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 cf f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a cf f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 cf f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 4b 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a cf f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 cf f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a cf f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 cf f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a cf f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 cf f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a cf f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 cf f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 4b 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a cf f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 cf f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a cf f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 cf f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 a5 ef			ld hl,scratch+2 
02bb cd d1 10			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 c6 f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 aa ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a c6 f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a c6 f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 c6 f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 c6 f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 cb ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a cb ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a c6 f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 c6 f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 cb ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 c6 f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd 2d 17			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd 2d 17			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 2e 06			call storage_findnextid 
035d			 
035d cd 43 0d			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd 2d 17			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd 2d 17			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd 2d 17			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd 2d 17			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd 2d 17			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 cd 29 0a			call storage_clear_page 
042b			 
042b 21 e8 f9			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 e9 f9		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 d3 04			ld hl, .defaultbanklabl 
043a 11 eb f9		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; Append the current bank id 
0442 21 f4 f9			ld hl, store_page+3+9 
0445 3a cd f9			ld a, (spi_device_id) 
0448 77				ld (hl), a 
0449			 
0449				; save default page 0 
0449			 
0449 21 00 00			ld hl, 0 
044c 11 e8 f9			ld de, store_page 
044f				if DEBUG_STORESE 
044f					DMARK "SB3" 
044f f5				push af  
0450 3a 64 04			ld a, (.dmark)  
0453 32 bd fb			ld (debug_mark),a  
0456 3a 65 04			ld a, (.dmark+1)  
0459 32 be fb			ld (debug_mark+1),a  
045c 3a 66 04			ld a, (.dmark+2)  
045f 32 bf fb			ld (debug_mark+2),a  
0462 18 03			jr .pastdmark  
0464 ..			.dmark: db "SB3"  
0467 f1			.pastdmark: pop af  
0468			endm  
# End of macro DMARK
0468			;		push af 
0468			;		ld a, 'F' 
0468			;		ld (debug_mark),a 
0468			;		pop af 
0468					CALLMONITOR 
0468 cd 2d 17			call break_point_state  
046b				endm  
# End of macro CALLMONITOR
046b				endif 
046b cd 6e 03			call storage_write_block 
046e				if DEBUG_STORESE 
046e					DMARK "SB4" 
046e f5				push af  
046f 3a 83 04			ld a, (.dmark)  
0472 32 bd fb			ld (debug_mark),a  
0475 3a 84 04			ld a, (.dmark+1)  
0478 32 be fb			ld (debug_mark+1),a  
047b 3a 85 04			ld a, (.dmark+2)  
047e 32 bf fb			ld (debug_mark+2),a  
0481 18 03			jr .pastdmark  
0483 ..			.dmark: db "SB4"  
0486 f1			.pastdmark: pop af  
0487			endm  
# End of macro DMARK
0487			;		push af 
0487			;		ld a, '>' 
0487			;		ld (debug_mark),a 
0487			;		pop af 
0487					CALLMONITOR 
0487 cd 2d 17			call break_point_state  
048a				endm  
# End of macro CALLMONITOR
048a				endif 
048a			 
048a 00				nop 
048b 00				nop 
048c 00				nop 
048d			 
048d				; now set 0 in every page to mark as a free block 
048d			 
048d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048f 21 40 00			ld hl, STORE_BLOCK_PHY 
0492			 
0492 3e 00		.setmark1:   	ld a,0 
0494 e5					push hl 
0495 c5					push bc 
0496 cd e7 01				call se_writebyte 
0499 3e 0a			ld a, 10 
049b cd 4b 0a			call aDelayInMS 
049e 23				inc hl 
049f cd e7 01				call se_writebyte 
04a2 3e 0a			ld a, 10 
04a4 cd 4b 0a			call aDelayInMS 
04a7 2b				dec hl 
04a8 c1					pop bc 
04a9 e1					pop hl 
04aa 3e 40				ld a, STORE_BLOCK_PHY 
04ac cd 1a 0d				call addatohl 
04af 10 e1				djnz .setmark1 
04b1			 
04b1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b3 3e 00		.setmark2:   	ld a,0 
04b5 e5					push hl 
04b6 c5					push bc 
04b7 cd e7 01				call se_writebyte 
04ba 3e 0a			ld a, 10 
04bc cd 4b 0a			call aDelayInMS 
04bf 23				inc hl 
04c0 cd e7 01				call se_writebyte 
04c3 3e 0a			ld a, 10 
04c5 cd 4b 0a			call aDelayInMS 
04c8 2b				dec hl 
04c9 c1					pop bc 
04ca e1					pop hl 
04cb 3e 40				ld a, STORE_BLOCK_PHY 
04cd cd 1a 0d				call addatohl 
04d0 10 e1				djnz .setmark2 
04d2			 
04d2					 
04d2			 
04d2			 
04d2 c9				ret 
04d3			 
04d3			 
04d3			 
04d3			 
04d3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04de			 
04de			 
04de			 
04de			; Label Bank 
04de			; ---------- 
04de			; 
04de			; With current bank 
04de			; Read block 0 
04de			; Set label 
04de			; Write block 0 
04de			 
04de			; label str pointer in hl 
04de			 
04de			storage_label:     
04de			 
04de				if DEBUG_STORESE 
04de					DMARK "LBL" 
04de f5				push af  
04df 3a f3 04			ld a, (.dmark)  
04e2 32 bd fb			ld (debug_mark),a  
04e5 3a f4 04			ld a, (.dmark+1)  
04e8 32 be fb			ld (debug_mark+1),a  
04eb 3a f5 04			ld a, (.dmark+2)  
04ee 32 bf fb			ld (debug_mark+2),a  
04f1 18 03			jr .pastdmark  
04f3 ..			.dmark: db "LBL"  
04f6 f1			.pastdmark: pop af  
04f7			endm  
# End of macro DMARK
04f7					CALLMONITOR 
04f7 cd 2d 17			call break_point_state  
04fa				endm  
# End of macro CALLMONITOR
04fa				endif 
04fa			 
04fa e5				push hl 
04fb			 
04fb cd ba 03			call storage_get_block_0 
04fe			 
04fe				; set default label 
04fe			 
04fe e1				pop hl 
04ff			 
04ff 11 eb f9		 	ld de, store_page+3 
0502 01 0f 00			ld bc, 15 
0505				if DEBUG_STORESE 
0505					DMARK "LB3" 
0505 f5				push af  
0506 3a 1a 05			ld a, (.dmark)  
0509 32 bd fb			ld (debug_mark),a  
050c 3a 1b 05			ld a, (.dmark+1)  
050f 32 be fb			ld (debug_mark+1),a  
0512 3a 1c 05			ld a, (.dmark+2)  
0515 32 bf fb			ld (debug_mark+2),a  
0518 18 03			jr .pastdmark  
051a ..			.dmark: db "LB3"  
051d f1			.pastdmark: pop af  
051e			endm  
# End of macro DMARK
051e					CALLMONITOR 
051e cd 2d 17			call break_point_state  
0521				endm  
# End of macro CALLMONITOR
0521				endif 
0521 ed b0			ldir 
0523				; save default page 0 
0523			 
0523 21 00 00			ld hl, 0 
0526 11 e8 f9			ld de, store_page 
0529				if DEBUG_STORESE 
0529					DMARK "LBW" 
0529 f5				push af  
052a 3a 3e 05			ld a, (.dmark)  
052d 32 bd fb			ld (debug_mark),a  
0530 3a 3f 05			ld a, (.dmark+1)  
0533 32 be fb			ld (debug_mark+1),a  
0536 3a 40 05			ld a, (.dmark+2)  
0539 32 bf fb			ld (debug_mark+2),a  
053c 18 03			jr .pastdmark  
053e ..			.dmark: db "LBW"  
0541 f1			.pastdmark: pop af  
0542			endm  
# End of macro DMARK
0542					CALLMONITOR 
0542 cd 2d 17			call break_point_state  
0545				endm  
# End of macro CALLMONITOR
0545				endif 
0545 cd 6e 03			call storage_write_block 
0548			 
0548 c9				ret 
0549			 
0549			 
0549			 
0549			; Read Block 0 - Config 
0549			; --------------------- 
0549			; 
0549			; With current bank 
0549			; Call presence test 
0549			;    If not present format/init bank  
0549			; Read block 0  
0549			;  
0549			 
0549			 
0549			; Dir 
0549			; --- 
0549			; 
0549			; With current bank 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block read byte 2 
0549			;      if first block of file 
0549			;         Display file name 
0549			;         Display type flags for file 
0549			;        
0549			 
0549			; moving to words as this requires stack control 
0549			 
0549			 
0549			; Delete File 
0549			; ----------- 
0549			; 
0549			; With current bank 
0549			; 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block file id 
0549			;      If first block of file and dont have file id 
0549			;         if file to delete 
0549			;         Save file id 
0549			;         Null file id 
0549			;         Write this block back 
0549			;      If file id is one saved 
0549			;         Null file id 
0549			;         Write this block back 
0549			 
0549			storage_erase: 
0549			 
0549				; hl contains the file id 
0549			 
0549 5d				ld e, l 
054a 16 00			ld d, 0 
054c 21 40 00			ld hl, STORE_BLOCK_PHY 
054f					if DEBUG_FORTH_WORDS 
054f						DMARK "ERA" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 bd fb			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 be fb			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 bf fb			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "ERA"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568						CALLMONITOR 
0568 cd 2d 17			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b cd 2e 06			call storage_findnextid 
056e cd 43 0d			call ishlzero 
0571 c8				ret z 
0572			 
0572 e5				push hl 
0573			 
0573				; TODO check file not found 
0573			 
0573 11 e8 f9			ld de, store_page 
0576 cd 09 03			call storage_read_block 
0579			 
0579					if DEBUG_FORTH_WORDS 
0579						DMARK "ER1" 
0579 f5				push af  
057a 3a 8e 05			ld a, (.dmark)  
057d 32 bd fb			ld (debug_mark),a  
0580 3a 8f 05			ld a, (.dmark+1)  
0583 32 be fb			ld (debug_mark+1),a  
0586 3a 90 05			ld a, (.dmark+2)  
0589 32 bf fb			ld (debug_mark+2),a  
058c 18 03			jr .pastdmark  
058e ..			.dmark: db "ER1"  
0591 f1			.pastdmark: pop af  
0592			endm  
# End of macro DMARK
0592						CALLMONITOR 
0592 cd 2d 17			call break_point_state  
0595				endm  
# End of macro CALLMONITOR
0595					endif 
0595 3a e8 f9			ld a, (store_page)	; get file id 
0598 32 e1 f9			ld (store_tmpid), a 
059b			 
059b 3a ea f9			ld a, (store_page+2)    ; get count of extends 
059e 32 e0 f9			ld (store_tmpext), a 
05a1			 
05a1				; wipe file header 
05a1			 
05a1 e1				pop hl 
05a2 3e 00			ld a, 0 
05a4 32 e8 f9			ld (store_page), a 
05a7 32 e9 f9			ld (store_page+1),a 
05aa 11 e8 f9			ld de, store_page 
05ad					if DEBUG_FORTH_WORDS 
05ad						DMARK "ER2" 
05ad f5				push af  
05ae 3a c2 05			ld a, (.dmark)  
05b1 32 bd fb			ld (debug_mark),a  
05b4 3a c3 05			ld a, (.dmark+1)  
05b7 32 be fb			ld (debug_mark+1),a  
05ba 3a c4 05			ld a, (.dmark+2)  
05bd 32 bf fb			ld (debug_mark+2),a  
05c0 18 03			jr .pastdmark  
05c2 ..			.dmark: db "ER2"  
05c5 f1			.pastdmark: pop af  
05c6			endm  
# End of macro DMARK
05c6						CALLMONITOR 
05c6 cd 2d 17			call break_point_state  
05c9				endm  
# End of macro CALLMONITOR
05c9					endif 
05c9 cd 6e 03			call storage_write_block 
05cc			 
05cc			 
05cc				; wipe file extents 
05cc			 
05cc 3a e0 f9			ld a, (store_tmpext) 
05cf 47				ld b, a 
05d0			 
05d0			.eraext:	  
05d0 c5				push bc 
05d1			 
05d1 21 40 00			ld hl, STORE_BLOCK_PHY 
05d4 3a e1 f9			ld a,(store_tmpid) 
05d7 5f				ld e, a 
05d8 50				ld d, b	 
05d9					if DEBUG_FORTH_WORDS 
05d9						DMARK "ER3" 
05d9 f5				push af  
05da 3a ee 05			ld a, (.dmark)  
05dd 32 bd fb			ld (debug_mark),a  
05e0 3a ef 05			ld a, (.dmark+1)  
05e3 32 be fb			ld (debug_mark+1),a  
05e6 3a f0 05			ld a, (.dmark+2)  
05e9 32 bf fb			ld (debug_mark+2),a  
05ec 18 03			jr .pastdmark  
05ee ..			.dmark: db "ER3"  
05f1 f1			.pastdmark: pop af  
05f2			endm  
# End of macro DMARK
05f2						CALLMONITOR 
05f2 cd 2d 17			call break_point_state  
05f5				endm  
# End of macro CALLMONITOR
05f5					endif 
05f5 cd 2e 06			call storage_findnextid 
05f8			 
05f8 e5				push hl 
05f9 11 e8 f9			ld de, store_page 
05fc cd 09 03			call storage_read_block 
05ff			 
05ff				; free block	 
05ff			 
05ff 3e 00			ld a, 0 
0601 32 e8 f9			ld (store_page), a 
0604 32 e9 f9			ld (store_page+1),a 
0607 11 e8 f9			ld de, store_page 
060a e1				pop hl 
060b					if DEBUG_FORTH_WORDS 
060b						DMARK "ER4" 
060b f5				push af  
060c 3a 20 06			ld a, (.dmark)  
060f 32 bd fb			ld (debug_mark),a  
0612 3a 21 06			ld a, (.dmark+1)  
0615 32 be fb			ld (debug_mark+1),a  
0618 3a 22 06			ld a, (.dmark+2)  
061b 32 bf fb			ld (debug_mark+2),a  
061e 18 03			jr .pastdmark  
0620 ..			.dmark: db "ER4"  
0623 f1			.pastdmark: pop af  
0624			endm  
# End of macro DMARK
0624						CALLMONITOR 
0624 cd 2d 17			call break_point_state  
0627				endm  
# End of macro CALLMONITOR
0627					endif 
0627 cd 6e 03			call storage_write_block 
062a			 
062a c1				pop bc 
062b 10 a3			djnz .eraext 
062d			 
062d c9				ret 
062e			 
062e			 
062e			; Find Free Block 
062e			; --------------- 
062e			; 
062e			; With current bank 
062e			;  
062e			; From given starting logical block 
062e			;    Read block  
062e			;    If no file id 
062e			;         Return block id 
062e			 
062e			 
062e			; hl starting page number 
062e			; hl contains free page number or zero if no pages free 
062e			; e contains the file id to locate 
062e			; d contains the block number 
062e			 
062e			; TODO change to find file id and use zero for free block 
062e			 
062e			storage_findnextid: 
062e			 
062e				; now locate first 0 page to mark as a free block 
062e			 
062e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0630			;	ld hl, STORE_BLOCK_PHY 
0630			 
0630					if DEBUG_FORTH_WORDS 
0630					DMARK "FNI" 
0630 f5				push af  
0631 3a 45 06			ld a, (.dmark)  
0634 32 bd fb			ld (debug_mark),a  
0637 3a 46 06			ld a, (.dmark+1)  
063a 32 be fb			ld (debug_mark+1),a  
063d 3a 47 06			ld a, (.dmark+2)  
0640 32 bf fb			ld (debug_mark+2),a  
0643 18 03			jr .pastdmark  
0645 ..			.dmark: db "FNI"  
0648 f1			.pastdmark: pop af  
0649			endm  
# End of macro DMARK
0649						CALLMONITOR 
0649 cd 2d 17			call break_point_state  
064c				endm  
# End of macro CALLMONITOR
064c					endif 
064c			.ff1:   	 
064c e5					push hl 
064d c5					push bc 
064e d5					push de 
064f cd 89 02				call se_readbyte 
0652 5f					ld e,a 
0653 23					inc hl 
0654 cd 89 02				call se_readbyte 
0657 57					ld d, a 
0658 e1					pop hl 
0659 e5					push hl 
065a cd 38 0d				call cmp16 
065d 28 49				jr z, .fffound 
065f			 
065f d1					pop de 
0660 c1					pop bc 
0661 e1					pop hl 
0662			 
0662					; is found? 
0662					;cp e 
0662					;ret z 
0662			 
0662 3e 40				ld a, STORE_BLOCK_PHY 
0664 cd 1a 0d				call addatohl 
0667 10 e3				djnz .ff1 
0669			 
0669 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066b			.ff2:   	 
066b			 
066b e5					push hl 
066c c5					push bc 
066d d5					push de 
066e cd 89 02				call se_readbyte 
0671 5f					ld e,a 
0672 23					inc hl 
0673 cd 89 02				call se_readbyte 
0676 57					ld d, a 
0677			 
0677 e1					pop hl 
0678 e5					push hl 
0679 cd 38 0d				call cmp16 
067c 28 2a				jr z, .fffound 
067e			 
067e d1					pop de 
067f c1					pop bc 
0680 e1					pop hl 
0681					; is found? 
0681					;cp e 
0681					;ret z 
0681			 
0681 3e 40				ld a, STORE_BLOCK_PHY 
0683 cd 1a 0d				call addatohl 
0686 10 e3				djnz .ff2 
0688			 
0688			 
0688					if DEBUG_FORTH_WORDS 
0688					DMARK "FN-" 
0688 f5				push af  
0689 3a 9d 06			ld a, (.dmark)  
068c 32 bd fb			ld (debug_mark),a  
068f 3a 9e 06			ld a, (.dmark+1)  
0692 32 be fb			ld (debug_mark+1),a  
0695 3a 9f 06			ld a, (.dmark+2)  
0698 32 bf fb			ld (debug_mark+2),a  
069b 18 03			jr .pastdmark  
069d ..			.dmark: db "FN-"  
06a0 f1			.pastdmark: pop af  
06a1			endm  
# End of macro DMARK
06a1					;	push af 
06a1					;	ld a, 'n' 
06a1					;	ld (debug_mark),a 
06a1					;	pop af 
06a1						CALLMONITOR 
06a1 cd 2d 17			call break_point_state  
06a4				endm  
# End of macro CALLMONITOR
06a4					endif 
06a4				; no free marks! 
06a4 21 00 00				ld hl, 0 
06a7 c9				ret 
06a8			.fffound: 
06a8				 
06a8			 
06a8 d1					pop de 
06a9 c1					pop bc 
06aa e1					pop hl 
06ab					if DEBUG_FORTH_WORDS 
06ab					DMARK "FNF" 
06ab f5				push af  
06ac 3a c0 06			ld a, (.dmark)  
06af 32 bd fb			ld (debug_mark),a  
06b2 3a c1 06			ld a, (.dmark+1)  
06b5 32 be fb			ld (debug_mark+1),a  
06b8 3a c2 06			ld a, (.dmark+2)  
06bb 32 bf fb			ld (debug_mark+2),a  
06be 18 03			jr .pastdmark  
06c0 ..			.dmark: db "FNF"  
06c3 f1			.pastdmark: pop af  
06c4			endm  
# End of macro DMARK
06c4					;	push af 
06c4					;	ld a, 'n' 
06c4					;	ld (debug_mark),a 
06c4					;	pop af 
06c4						CALLMONITOR 
06c4 cd 2d 17			call break_point_state  
06c7				endm  
# End of macro CALLMONITOR
06c7					endif 
06c7 c9				ret 
06c8			 
06c8			 
06c8			 
06c8			; Free Space 
06c8			; ---------- 
06c8			; 
06c8			; With current bank 
06c8			; 
06c8			; Set block count to zero 
06c8			; Starting with first logical block 
06c8			;      Find free block  
06c8			;      If block id given, increment block count 
06c8			; 
06c8			;  
06c8			 
06c8			 
06c8			; hl contains count of free blocks 
06c8			 
06c8			storage_freeblocks: 
06c8			 
06c8				; now locate first 0 page to mark as a free block 
06c8			 
06c8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06ca 21 40 00			ld hl, STORE_BLOCK_PHY 
06cd 11 00 00			ld de, 0 
06d0			 
06d0			.fb1:   	 
06d0 e5					push hl 
06d1 c5					push bc 
06d2 d5					push de 
06d3 cd 89 02				call se_readbyte 
06d6 d1					pop de 
06d7 c1					pop bc 
06d8 e1					pop hl 
06d9			 
06d9					; is free? 
06d9 fe 00				cp 0 
06db 20 01				jr nz, .ff1cont 
06dd 13					inc de 
06de			 
06de			.ff1cont: 
06de			 
06de			 
06de 3e 40				ld a, STORE_BLOCK_PHY 
06e0 cd 1a 0d				call addatohl 
06e3 10 eb				djnz .fb1 
06e5			 
06e5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e7			.fb2:   	 
06e7 e5					push hl 
06e8 c5					push bc 
06e9 d5					push de 
06ea cd 89 02				call se_readbyte 
06ed d1					pop de 
06ee c1					pop bc 
06ef e1					pop hl 
06f0			 
06f0					; is free? 
06f0 fe 00				cp 0 
06f2 20 01				jr nz, .ff2cont 
06f4 13					inc de 
06f5			 
06f5			.ff2cont: 
06f5			 
06f5 3e 40				ld a, STORE_BLOCK_PHY 
06f7 cd 1a 0d				call addatohl 
06fa 10 eb				djnz .fb2 
06fc			 
06fc eb				ex de, hl 
06fd c9				ret 
06fe			 
06fe			; Get File ID 
06fe			; ----------- 
06fe			; 
06fe			; With current bank 
06fe			;  
06fe			; Load Block 0 Config 
06fe			; Get max file id number 
06fe			; For each logical block 
06fe			;    Read block file id 
06fe			;      If first block of file and dont have file id 
06fe			;         if file get id and exit 
06fe			 
06fe			 
06fe			 
06fe			 
06fe			; Create File 
06fe			; ----------- 
06fe			; 
06fe			; With current bank  
06fe			; Load Block 0 Config 
06fe			; Get max file id number 
06fe			; Increment file id number 
06fe			; Save Config 
06fe			; Find free block 
06fe			; Set buffer with file name and file id 
06fe			; Write buffer to free block  
06fe			 
06fe			 
06fe			; hl point to file name 
06fe			; hl returns file id 
06fe			 
06fe			; file format: 
06fe			; byte 0 - file id 
06fe			; byte 1 - extent number 
06fe			; byte 2-> data 
06fe			 
06fe			; format for extent number 0: 
06fe			; 
06fe			; byte 0 - file id 
06fe			; byte 1 - extent 0 
06fe			; byte 2 - extent count 
06fe			; byte 3 -> file name and meta data 
06fe			 
06fe			 
06fe			storage_create: 
06fe				if DEBUG_STORESE 
06fe					DMARK "SCR" 
06fe f5				push af  
06ff 3a 13 07			ld a, (.dmark)  
0702 32 bd fb			ld (debug_mark),a  
0705 3a 14 07			ld a, (.dmark+1)  
0708 32 be fb			ld (debug_mark+1),a  
070b 3a 15 07			ld a, (.dmark+2)  
070e 32 bf fb			ld (debug_mark+2),a  
0711 18 03			jr .pastdmark  
0713 ..			.dmark: db "SCR"  
0716 f1			.pastdmark: pop af  
0717			endm  
# End of macro DMARK
0717					CALLMONITOR 
0717 cd 2d 17			call break_point_state  
071a				endm  
# End of macro CALLMONITOR
071a				endif 
071a			 
071a e5				push hl		; save file name pointer 
071b			 
071b cd ba 03			call storage_get_block_0 
071e			 
071e 3a e8 f9			ld a,(store_page)	; get current file id 
0721 3c				inc a 
0722 32 e8 f9			ld (store_page),a 
0725				 
0725 32 e1 f9			ld (store_tmpid),a			; save id 
0728			 
0728 21 00 00			ld hl, 0 
072b 11 e8 f9			ld de, store_page 
072e				if DEBUG_STORESE 
072e					DMARK "SCw" 
072e f5				push af  
072f 3a 43 07			ld a, (.dmark)  
0732 32 bd fb			ld (debug_mark),a  
0735 3a 44 07			ld a, (.dmark+1)  
0738 32 be fb			ld (debug_mark+1),a  
073b 3a 45 07			ld a, (.dmark+2)  
073e 32 bf fb			ld (debug_mark+2),a  
0741 18 03			jr .pastdmark  
0743 ..			.dmark: db "SCw"  
0746 f1			.pastdmark: pop af  
0747			endm  
# End of macro DMARK
0747					CALLMONITOR 
0747 cd 2d 17			call break_point_state  
074a				endm  
# End of macro CALLMONITOR
074a				endif 
074a cd 6e 03			call storage_write_block	 ; save update 
074d			 
074d				if DEBUG_STORESE 
074d 11 e8 f9				ld de, store_page 
0750					DMARK "SCC" 
0750 f5				push af  
0751 3a 65 07			ld a, (.dmark)  
0754 32 bd fb			ld (debug_mark),a  
0757 3a 66 07			ld a, (.dmark+1)  
075a 32 be fb			ld (debug_mark+1),a  
075d 3a 67 07			ld a, (.dmark+2)  
0760 32 bf fb			ld (debug_mark+2),a  
0763 18 03			jr .pastdmark  
0765 ..			.dmark: db "SCC"  
0768 f1			.pastdmark: pop af  
0769			endm  
# End of macro DMARK
0769					CALLMONITOR 
0769 cd 2d 17			call break_point_state  
076c				endm  
# End of macro CALLMONITOR
076c				endif 
076c				;  
076c				 
076c 21 40 00			ld hl, STORE_BLOCK_PHY 
076f 11 00 00			ld de, 0 
0772 cd 2e 06			call storage_findnextid 
0775			 
0775 22 d2 f9			ld (store_tmppageid), hl    ; save page to use  
0778			 
0778				; TODO detect 0 = no spare blocks 
0778			 
0778				; hl now contains the free page to use for the file header page 
0778			 
0778				if DEBUG_STORESE 
0778				DMARK "SCF" 
0778 f5				push af  
0779 3a 8d 07			ld a, (.dmark)  
077c 32 bd fb			ld (debug_mark),a  
077f 3a 8e 07			ld a, (.dmark+1)  
0782 32 be fb			ld (debug_mark+1),a  
0785 3a 8f 07			ld a, (.dmark+2)  
0788 32 bf fb			ld (debug_mark+2),a  
078b 18 03			jr .pastdmark  
078d ..			.dmark: db "SCF"  
0790 f1			.pastdmark: pop af  
0791			endm  
# End of macro DMARK
0791					CALLMONITOR 
0791 cd 2d 17			call break_point_state  
0794				endm  
# End of macro CALLMONITOR
0794				endif 
0794			 
0794 22 d2 f9			ld (store_tmppageid), hl 
0797				 
0797 3a e1 f9			ld a,(store_tmpid)    ; get file id 
079a			;	ld a, (store_filecache)			; save to cache 
079a			 
079a 32 e8 f9			ld (store_page),a    ; set page id 
079d 3e 00			ld a, 0			 ; extent 0 is file header 
079f 32 e9 f9			ld (store_page+1), a   ; set file extent 
07a2			 
07a2 32 ea f9			ld (store_page+2), a   ; extent count for the file 
07a5			 
07a5			;	inc hl 		; init block 0 of file 
07a5			;	inc hl   		; skip file and extent id 
07a5			 ;       ld a, 0 
07a5			;	ld (hl),a 
07a5			;	ld a, (store_filecache+1)  	; save to cache 
07a5			 
07a5			;	inc hl    ; file name 
07a5				 
07a5				 
07a5 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
07a8				if DEBUG_STORESE 
07a8					DMARK "SCc" 
07a8 f5				push af  
07a9 3a bd 07			ld a, (.dmark)  
07ac 32 bd fb			ld (debug_mark),a  
07af 3a be 07			ld a, (.dmark+1)  
07b2 32 be fb			ld (debug_mark+1),a  
07b5 3a bf 07			ld a, (.dmark+2)  
07b8 32 bf fb			ld (debug_mark+2),a  
07bb 18 03			jr .pastdmark  
07bd ..			.dmark: db "SCc"  
07c0 f1			.pastdmark: pop af  
07c1			endm  
# End of macro DMARK
07c1					CALLMONITOR 
07c1 cd 2d 17			call break_point_state  
07c4				endm  
# End of macro CALLMONITOR
07c4				endif 
07c4 e1				pop hl    ; get zero term string 
07c5 e5				push hl 
07c6 3e 00			ld a, 0 
07c8 cd 83 11			call strlent 
07cb 23				inc hl   ; cover zero term 
07cc 06 00			ld b,0 
07ce 4d				ld c,l 
07cf e1				pop hl 
07d0				;ex de, hl 
07d0				if DEBUG_STORESE 
07d0					DMARK "SCa" 
07d0 f5				push af  
07d1 3a e5 07			ld a, (.dmark)  
07d4 32 bd fb			ld (debug_mark),a  
07d7 3a e6 07			ld a, (.dmark+1)  
07da 32 be fb			ld (debug_mark+1),a  
07dd 3a e7 07			ld a, (.dmark+2)  
07e0 32 bf fb			ld (debug_mark+2),a  
07e3 18 03			jr .pastdmark  
07e5 ..			.dmark: db "SCa"  
07e8 f1			.pastdmark: pop af  
07e9			endm  
# End of macro DMARK
07e9					;push af 
07e9					;ld a, 'a' 
07e9					;ld (debug_mark),a 
07e9					;pop af 
07e9					CALLMONITOR 
07e9 cd 2d 17			call break_point_state  
07ec				endm  
# End of macro CALLMONITOR
07ec				endif 
07ec ed b0			ldir    ; copy zero term string 
07ee				if DEBUG_STORESE 
07ee					DMARK "SCA" 
07ee f5				push af  
07ef 3a 03 08			ld a, (.dmark)  
07f2 32 bd fb			ld (debug_mark),a  
07f5 3a 04 08			ld a, (.dmark+1)  
07f8 32 be fb			ld (debug_mark+1),a  
07fb 3a 05 08			ld a, (.dmark+2)  
07fe 32 bf fb			ld (debug_mark+2),a  
0801 18 03			jr .pastdmark  
0803 ..			.dmark: db "SCA"  
0806 f1			.pastdmark: pop af  
0807			endm  
# End of macro DMARK
0807					CALLMONITOR 
0807 cd 2d 17			call break_point_state  
080a				endm  
# End of macro CALLMONITOR
080a				endif 
080a			 
080a				; write file header page 
080a			 
080a 2a d2 f9			ld hl,(store_tmppageid) 
080d 11 e8 f9			ld de, store_page 
0810				if DEBUG_STORESE 
0810					DMARK "SCb" 
0810 f5				push af  
0811 3a 25 08			ld a, (.dmark)  
0814 32 bd fb			ld (debug_mark),a  
0817 3a 26 08			ld a, (.dmark+1)  
081a 32 be fb			ld (debug_mark+1),a  
081d 3a 27 08			ld a, (.dmark+2)  
0820 32 bf fb			ld (debug_mark+2),a  
0823 18 03			jr .pastdmark  
0825 ..			.dmark: db "SCb"  
0828 f1			.pastdmark: pop af  
0829			endm  
# End of macro DMARK
0829					;push af 
0829					;ld a, 'b' 
0829					;ld (debug_mark),a 
0829					;pop af 
0829					CALLMONITOR 
0829 cd 2d 17			call break_point_state  
082c				endm  
# End of macro CALLMONITOR
082c				endif 
082c cd 6e 03			call storage_write_block 
082f			 
082f 3a e1 f9			ld a, (store_tmpid) 
0832 6f				ld l, a 
0833 26 00			ld h,0 
0835				if DEBUG_STORESE 
0835					DMARK "SCz" 
0835 f5				push af  
0836 3a 4a 08			ld a, (.dmark)  
0839 32 bd fb			ld (debug_mark),a  
083c 3a 4b 08			ld a, (.dmark+1)  
083f 32 be fb			ld (debug_mark+1),a  
0842 3a 4c 08			ld a, (.dmark+2)  
0845 32 bf fb			ld (debug_mark+2),a  
0848 18 03			jr .pastdmark  
084a ..			.dmark: db "SCz"  
084d f1			.pastdmark: pop af  
084e			endm  
# End of macro DMARK
084e					CALLMONITOR 
084e cd 2d 17			call break_point_state  
0851				endm  
# End of macro CALLMONITOR
0851				endif 
0851 c9				ret 
0852				 
0852			 
0852			 
0852			; 
0852			; Read File 
0852			; 
0852			; h - file id to locate 
0852			; l - extent to locate 
0852			; de - pointer to string to read into 
0852			; 
0852			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0852			 
0852			.sr_fail: 
0852 d1				pop de 
0853 c9				ret 
0854			 
0854			storage_read: 
0854 d5				push de 
0855			 
0855			; TODO BUG the above push is it popped before the RET Z? 
0855			 
0855			; TODO how to handle multiple part blocks 
0855			 
0855				; locate file extent to read 
0855			 
0855 5c				ld e, h 
0856 55				ld d, l 
0857 21 40 00			ld hl, STORE_BLOCK_PHY 
085a				if DEBUG_STORESE 
085a					DMARK "SRE" 
085a f5				push af  
085b 3a 6f 08			ld a, (.dmark)  
085e 32 bd fb			ld (debug_mark),a  
0861 3a 70 08			ld a, (.dmark+1)  
0864 32 be fb			ld (debug_mark+1),a  
0867 3a 71 08			ld a, (.dmark+2)  
086a 32 bf fb			ld (debug_mark+2),a  
086d 18 03			jr .pastdmark  
086f ..			.dmark: db "SRE"  
0872 f1			.pastdmark: pop af  
0873			endm  
# End of macro DMARK
0873					CALLMONITOR 
0873 cd 2d 17			call break_point_state  
0876				endm  
# End of macro CALLMONITOR
0876				endif 
0876 cd 2e 06			call storage_findnextid 
0879			 
0879				if DEBUG_STORESE 
0879					DMARK "SRf" 
0879 f5				push af  
087a 3a 8e 08			ld a, (.dmark)  
087d 32 bd fb			ld (debug_mark),a  
0880 3a 8f 08			ld a, (.dmark+1)  
0883 32 be fb			ld (debug_mark+1),a  
0886 3a 90 08			ld a, (.dmark+2)  
0889 32 bf fb			ld (debug_mark+2),a  
088c 18 03			jr .pastdmark  
088e ..			.dmark: db "SRf"  
0891 f1			.pastdmark: pop af  
0892			endm  
# End of macro DMARK
0892					CALLMONITOR 
0892 cd 2d 17			call break_point_state  
0895				endm  
# End of macro CALLMONITOR
0895				endif 
0895 cd 43 0d			call ishlzero 
0898			;	ld a, l 
0898			;	add h 
0898			;	cp 0 
0898 28 b8			jr z,.sr_fail			; block not found so EOF 
089a			 
089a				; hl contains page number to load 
089a d1				pop de   ; get storage 
089b d5				push de 
089c				if DEBUG_STORESE 
089c					DMARK "SRg" 
089c f5				push af  
089d 3a b1 08			ld a, (.dmark)  
08a0 32 bd fb			ld (debug_mark),a  
08a3 3a b2 08			ld a, (.dmark+1)  
08a6 32 be fb			ld (debug_mark+1),a  
08a9 3a b3 08			ld a, (.dmark+2)  
08ac 32 bf fb			ld (debug_mark+2),a  
08af 18 03			jr .pastdmark  
08b1 ..			.dmark: db "SRg"  
08b4 f1			.pastdmark: pop af  
08b5			endm  
# End of macro DMARK
08b5					CALLMONITOR 
08b5 cd 2d 17			call break_point_state  
08b8				endm  
# End of macro CALLMONITOR
08b8				endif 
08b8 cd 09 03			call storage_read_block 
08bb			 
08bb			 
08bb			; TODO if block has no zeros then need to read next block  
08bb			 
08bb			 
08bb					 
08bb e1				pop hl 		 ; return start of data to show as not EOF 
08bc 23				inc hl   ; past file id 
08bd 23				inc hl   ; past ext 
08be				if DEBUG_STORESE 
08be					DMARK "SRe" 
08be f5				push af  
08bf 3a d3 08			ld a, (.dmark)  
08c2 32 bd fb			ld (debug_mark),a  
08c5 3a d4 08			ld a, (.dmark+1)  
08c8 32 be fb			ld (debug_mark+1),a  
08cb 3a d5 08			ld a, (.dmark+2)  
08ce 32 bf fb			ld (debug_mark+2),a  
08d1 18 03			jr .pastdmark  
08d3 ..			.dmark: db "SRe"  
08d6 f1			.pastdmark: pop af  
08d7			endm  
# End of macro DMARK
08d7					CALLMONITOR 
08d7 cd 2d 17			call break_point_state  
08da				endm  
# End of macro CALLMONITOR
08da				endif 
08da c9					ret 
08db			 
08db			 
08db			 
08db			; 
08db			; Append File 
08db			; 
08db			; hl - file id to locate 
08db			; de - pointer to (multi block) string to write 
08db			 
08db			.sa_notfound: 
08db d1				pop de 
08dc c9				ret 
08dd			 
08dd			 
08dd			storage_append: 
08dd				; hl -  file id to append to 
08dd				; de - string to append 
08dd			 
08dd d5				push de 
08de				 
08de				if DEBUG_STORESE 
08de					DMARK "AP1" 
08de f5				push af  
08df 3a f3 08			ld a, (.dmark)  
08e2 32 bd fb			ld (debug_mark),a  
08e5 3a f4 08			ld a, (.dmark+1)  
08e8 32 be fb			ld (debug_mark+1),a  
08eb 3a f5 08			ld a, (.dmark+2)  
08ee 32 bf fb			ld (debug_mark+2),a  
08f1 18 03			jr .pastdmark  
08f3 ..			.dmark: db "AP1"  
08f6 f1			.pastdmark: pop af  
08f7			endm  
# End of macro DMARK
08f7					CALLMONITOR 
08f7 cd 2d 17			call break_point_state  
08fa				endm  
# End of macro CALLMONITOR
08fa				endif 
08fa			 
08fa 7d				ld a, l 
08fb 32 e1 f9			ld (store_tmpid), a 
08fe			 
08fe				; get file header  
08fe			 
08fe 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0900 3a e1 f9			ld a, (store_tmpid) 
0903 5f				ld e, a 
0904			 
0904 21 40 00				ld hl, STORE_BLOCK_PHY 
0907 cd 2e 06				call storage_findnextid 
090a			 
090a cd 43 0d			call ishlzero 
090d 28 cc			jr z, .sa_notfound 
090f			 
090f 22 d2 f9			ld (store_tmppageid), hl 
0912			 
0912				; TODO handle file id not found 
0912			 
0912				if DEBUG_STORESE 
0912					DMARK "AP2" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 bd fb			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 be fb			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 bf fb			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "AP2"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd 2d 17			call break_point_state  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e			 
092e				; update file extent count 
092e			 
092e 11 e8 f9			ld de, store_page 
0931			 
0931 cd 09 03			call storage_read_block 
0934			 
0934				if DEBUG_STORESE 
0934					DMARK "AP3" 
0934 f5				push af  
0935 3a 49 09			ld a, (.dmark)  
0938 32 bd fb			ld (debug_mark),a  
093b 3a 4a 09			ld a, (.dmark+1)  
093e 32 be fb			ld (debug_mark+1),a  
0941 3a 4b 09			ld a, (.dmark+2)  
0944 32 bf fb			ld (debug_mark+2),a  
0947 18 03			jr .pastdmark  
0949 ..			.dmark: db "AP3"  
094c f1			.pastdmark: pop af  
094d			endm  
# End of macro DMARK
094d					CALLMONITOR 
094d cd 2d 17			call break_point_state  
0950				endm  
# End of macro CALLMONITOR
0950				endif 
0950			;	ld (store_tmppageid), hl 
0950			 
0950 3a ea f9			ld a, (store_page+2) 
0953 3c				inc a 
0954 32 ea f9			ld (store_page+2), a 
0957 32 e0 f9			ld (store_tmpext), a 
095a				 
095a				if DEBUG_STORESE 
095a					DMARK "AP3" 
095a f5				push af  
095b 3a 6f 09			ld a, (.dmark)  
095e 32 bd fb			ld (debug_mark),a  
0961 3a 70 09			ld a, (.dmark+1)  
0964 32 be fb			ld (debug_mark+1),a  
0967 3a 71 09			ld a, (.dmark+2)  
096a 32 bf fb			ld (debug_mark+2),a  
096d 18 03			jr .pastdmark  
096f ..			.dmark: db "AP3"  
0972 f1			.pastdmark: pop af  
0973			endm  
# End of macro DMARK
0973					CALLMONITOR 
0973 cd 2d 17			call break_point_state  
0976				endm  
# End of macro CALLMONITOR
0976				endif 
0976 2a d2 f9			ld hl, (store_tmppageid) 
0979 11 e8 f9			ld de, store_page 
097c cd 6e 03			call storage_write_block 
097f			 
097f				; find free block 
097f			 
097f 11 00 00			ld de, 0			 ; file extent to locate 
0982			 
0982 21 40 00				ld hl, STORE_BLOCK_PHY 
0985 cd 2e 06				call storage_findnextid 
0988 cd 43 0d			call ishlzero 
098b ca db 08			jp z, .sa_notfound 
098e			 
098e					; TODO handle no space left 
098e					 
098e 22 d2 f9				ld (store_tmppageid), hl 
0991			 
0991				if DEBUG_STORESE 
0991					DMARK "AP4" 
0991 f5				push af  
0992 3a a6 09			ld a, (.dmark)  
0995 32 bd fb			ld (debug_mark),a  
0998 3a a7 09			ld a, (.dmark+1)  
099b 32 be fb			ld (debug_mark+1),a  
099e 3a a8 09			ld a, (.dmark+2)  
09a1 32 bf fb			ld (debug_mark+2),a  
09a4 18 03			jr .pastdmark  
09a6 ..			.dmark: db "AP4"  
09a9 f1			.pastdmark: pop af  
09aa			endm  
# End of macro DMARK
09aa					CALLMONITOR 
09aa cd 2d 17			call break_point_state  
09ad				endm  
# End of macro CALLMONITOR
09ad				endif 
09ad					; init the buffer with zeros so we can id if the buffer is full or not 
09ad			 
09ad e5					push hl 
09ae c5					push bc 
09af			 
09af 21 e8 f9				ld hl, store_page 
09b2 06 40				ld b, STORE_BLOCK_PHY 
09b4 3e 00				ld a, 0 
09b6 77			.zeroblock:	ld (hl), a 
09b7 23					inc hl 
09b8 10 fc				djnz .zeroblock 
09ba			 
09ba c1					pop bc 
09bb e1					pop hl 
09bc			 
09bc					; construct block 
09bc			 
09bc 3a e1 f9				ld a, (store_tmpid) 
09bf 32 e8 f9				ld (store_page), a   ; file id 
09c2 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09c5 32 e9 f9				ld (store_page+1), a 
09c8			 
09c8 e1					pop hl    ; get string to write 
09c9 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09cb 11 ea f9				ld de, store_page+2 
09ce			 
09ce				if DEBUG_STORESE 
09ce					DMARK "AP5" 
09ce f5				push af  
09cf 3a e3 09			ld a, (.dmark)  
09d2 32 bd fb			ld (debug_mark),a  
09d5 3a e4 09			ld a, (.dmark+1)  
09d8 32 be fb			ld (debug_mark+1),a  
09db 3a e5 09			ld a, (.dmark+2)  
09de 32 bf fb			ld (debug_mark+2),a  
09e1 18 03			jr .pastdmark  
09e3 ..			.dmark: db "AP5"  
09e6 f1			.pastdmark: pop af  
09e7			endm  
# End of macro DMARK
09e7					CALLMONITOR 
09e7 cd 2d 17			call break_point_state  
09ea				endm  
# End of macro CALLMONITOR
09ea				endif 
09ea			 
09ea			 
09ea			 
09ea					; fill buffer with data until end of string or full block 
09ea			 
09ea 7e			.appd:		ld a, (hl) 
09eb 12					ld (de), a 
09ec fe 00				cp 0 
09ee 28 04				jr z, .appdone 
09f0 23					inc hl 
09f1 13					inc de 
09f2 10 f6				djnz .appd 
09f4			 
09f4 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09f5 f5					push af   		; save last byte dumped 
09f6			 
09f6			 
09f6 2a d2 f9			ld hl, (store_tmppageid) 
09f9 11 e8 f9			ld de, store_page 
09fc				if DEBUG_STORESE 
09fc					DMARK "AP6" 
09fc f5				push af  
09fd 3a 11 0a			ld a, (.dmark)  
0a00 32 bd fb			ld (debug_mark),a  
0a03 3a 12 0a			ld a, (.dmark+1)  
0a06 32 be fb			ld (debug_mark+1),a  
0a09 3a 13 0a			ld a, (.dmark+2)  
0a0c 32 bf fb			ld (debug_mark+2),a  
0a0f 18 03			jr .pastdmark  
0a11 ..			.dmark: db "AP6"  
0a14 f1			.pastdmark: pop af  
0a15			endm  
# End of macro DMARK
0a15					CALLMONITOR 
0a15 cd 2d 17			call break_point_state  
0a18				endm  
# End of macro CALLMONITOR
0a18				endif 
0a18 cd 6e 03				call storage_write_block 
0a1b			 
0a1b			 
0a1b				; was that a full block of data written? 
0a1b				; any more to write out? 
0a1b			 
0a1b				; if yes then set vars and jump to start of function again 
0a1b			 
0a1b f1					pop af 
0a1c d1					pop de 
0a1d			 
0a1d fe 00				cp 0		 ; no, string was fully written 
0a1f c8					ret z 
0a20			 
0a20					; setup vars for next cycle 
0a20			 
0a20 3a e1 f9				ld a, (store_tmpid) 
0a23 6f					ld l, a 
0a24 26 00				ld h, 0 
0a26			 
0a26 c3 dd 08			 	jp storage_append	 ; yes, need to write out some more 
0a29			 
0a29			 
0a29			 
0a29			 
0a29			 
0a29			 
0a29			 
0a29			if DEBUG_STORECF 
0a29			storageput:	 
0a29					ret 
0a29			storageread: 
0a29					ld hl, store_page 
0a29					ld b, 200 
0a29					ld a,0 
0a29			.src:		ld (hl),a 
0a29					inc hl 
0a29					djnz .src 
0a29					 
0a29			 
0a29					ld de, 0 
0a29					ld bc, 1 
0a29					ld hl, store_page 
0a29					call cfRead 
0a29			 
0a29				call cfGetError 
0a29				ld hl,scratch 
0a29				call hexout 
0a29				ld hl, scratch+2 
0a29				ld a, 0 
0a29				ld (hl),a 
0a29				ld de, scratch 
0a29				ld a,display_row_1 
0a29				call str_at_display 
0a29				call update_display 
0a29			 
0a29					ld hl, store_page 
0a29					ld (os_cur_ptr),hl 
0a29			 
0a29					ret 
0a29			endif 
0a29			 
0a29			 
0a29			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a29			 
0a29			storage_clear_page: 
0a29 e5				push hl 
0a2a d5				push de 
0a2b c5				push bc 
0a2c 21 e8 f9			ld hl, store_page 
0a2f 3e 00			ld a, 0 
0a31 77				ld (hl), a 
0a32			 
0a32 11 e9 f9			ld de, store_page+1 
0a35 01 40 00			ld bc, STORE_BLOCK_PHY 
0a38			 
0a38 ed b0			ldir 
0a3a				 
0a3a c1				pop bc 
0a3b d1				pop de 
0a3c e1				pop hl 
0a3d c9				ret 
0a3e			 
0a3e			; eof 
# End of file firmware_storage.asm
0a3e			  
0a3e			; support routines for above hardware abstraction layer  
0a3e			  
0a3e			include "firmware_general.asm"        ; general support functions  
0a3e			 
0a3e			; word look up 
0a3e			 
0a3e			; in 
0a3e			; a is the index 
0a3e			; hl is pointer start of array 
0a3e			; 
0a3e			; returns 
0a3e			; hl to the word 
0a3e			; 
0a3e			 
0a3e			table_lookup:  
0a3e d5					push de 
0a3f eb					ex de, hl 
0a40			 
0a40 6f					ld l, a 
0a41 26 00				ld h, 0 
0a43 29					add hl, hl 
0a44 19					add hl, de 
0a45 7e					ld a, (hl) 
0a46 23					inc hl 
0a47 66					ld h,(hl) 
0a48 6f					ld l, a 
0a49			 
0a49 d1					pop de 
0a4a c9					ret 
0a4b			 
0a4b			; Delay loops 
0a4b			 
0a4b			 
0a4b			 
0a4b			aDelayInMS: 
0a4b c5				push bc 
0a4c 47				ld b,a 
0a4d			msdelay: 
0a4d c5				push bc 
0a4e				 
0a4e			 
0a4e 01 41 00			ld bc,041h 
0a51 cd 69 0a			call delayloop 
0a54 c1				pop bc 
0a55 05				dec b 
0a56 20 f5			jr nz,msdelay 
0a58			 
0a58			;if CPU_CLOCK_8MHZ 
0a58			;msdelay8: 
0a58			;	push bc 
0a58			;	 
0a58			; 
0a58			;	ld bc,041h 
0a58			;	call delayloop 
0a58			;	pop bc 
0a58			;	dec b 
0a58			;	jr nz,msdelay8 
0a58			;endif 
0a58			 
0a58			 
0a58 c1				pop bc 
0a59 c9				ret 
0a5a			 
0a5a			 
0a5a			delay250ms: 
0a5a				;push de 
0a5a 01 00 40			ld bc, 04000h 
0a5d c3 69 0a			jp delayloop 
0a60			delay500ms: 
0a60				;push de 
0a60 01 00 80			ld bc, 08000h 
0a63 c3 69 0a			jp delayloop 
0a66			delay1s: 
0a66				;push bc 
0a66			   ; Clobbers A, d and e 
0a66 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a69			delayloop: 
0a69 c5			    push bc 
0a6a			 
0a6a			if BASE_CPM 
0a6a				ld bc, CPM_DELAY_TUNE 
0a6a			.cpmloop: 
0a6a				push bc 
0a6a			 
0a6a			endif 
0a6a			 
0a6a			 
0a6a			 
0a6a			delayloopi: 
0a6a			;	push bc 
0a6a			;.dl: 
0a6a cb 47		    bit     0,a    	; 8 
0a6c cb 47		    bit     0,a    	; 8 
0a6e cb 47		    bit     0,a    	; 8 
0a70 e6 ff		    and     255  	; 7 
0a72 0b			    dec     bc      	; 6 
0a73 79			    ld      a,c     	; 4 
0a74 b0			    or      b     	; 4 
0a75 c2 6a 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a78			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a78				;pop de 
0a78			;pop bc 
0a78			 
0a78			if BASE_CPM 
0a78				pop bc 
0a78				 
0a78			    dec     bc      	; 6 
0a78			    ld      a,c     	; 4 
0a78			    or      b     	; 4 
0a78			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a78				 
0a78			 
0a78			endif 
0a78			;if CPU_CLOCK_8MHZ 
0a78			;    pop bc 
0a78			;    push bc 
0a78			;.dl8: 
0a78			;    bit     0,a    	; 8 
0a78			;    bit     0,a    	; 8 
0a78			;    bit     0,a    	; 8 
0a78			;    and     255  	; 7 
0a78			;    dec     bc      	; 6 
0a78			;    ld      a,c     	; 4 
0a78			;    or      b     	; 4 
0a78			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a78			;endif 
0a78			 
0a78			;if CPU_CLOCK_10MHZ 
0a78			;    pop bc 
0a78			;    push bc 
0a78			;.dl8: 
0a78			;    bit     0,a    	; 8 
0a78			;    bit     0,a    	; 8 
0a78			;    bit     0,a    	; 8 
0a78			;    and     255  	; 7 
0a78			;    dec     bc      	; 6 
0a78			;    ld      a,c     	; 4 
0a78			;    or      b     	; 4 
0a78			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a78			;endif 
0a78 c1			    pop bc 
0a79			 
0a79 c9				ret 
0a7a			 
0a7a			 
0a7a			 
0a7a			; eof 
# End of file firmware_general.asm
0a7a			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a7a			; display routines that use the physical hardware abstraction layer 
0a7a			 
0a7a			 
0a7a			; information window 
0a7a			 
0a7a			; pass hl with 1st string to display 
0a7a			; pass de with 2nd string to display 
0a7a			 
0a7a			info_panel: 
0a7a e5				push hl 
0a7b			 
0a7b 2a 5e fa			ld hl, (display_fb_active) 
0a7e e5				push hl    ; future de destination 
0a7f 21 53 fb				ld hl, display_fb0 
0a82 22 5e fa				ld (display_fb_active), hl 
0a85			 
0a85 cd e6 0a			call clear_display 
0a88			 
0a88			 
0a88 3e 2d			ld a, display_row_3 + 5 
0a8a cd f9 0a			call str_at_display 
0a8d			 
0a8d e1				pop hl 
0a8e d1				pop de 
0a8f			 
0a8f e5				push hl 
0a90			 
0a90			 
0a90 3e 19			ld a, display_row_2 + 5 
0a92 cd f9 0a			call str_at_display 
0a95			 
0a95			 
0a95 cd 09 0b			call update_display 
0a98 cd 35 1c			call next_page_prompt 
0a9b cd e6 0a			call clear_display 
0a9e			 
0a9e				 
0a9e 21 02 fb				ld hl, display_fb1 
0aa1 22 5e fa				ld (display_fb_active), hl 
0aa4 cd 09 0b			call update_display 
0aa7			 
0aa7			 
0aa7 c9				ret 
0aa8			 
0aa8			 
0aa8			 
0aa8			 
0aa8			; TODO windowing? 
0aa8			 
0aa8			; TODO scroll line up 
0aa8			 
0aa8			scroll_up: 
0aa8			 
0aa8 e5				push hl 
0aa9 d5				push de 
0aaa c5				push bc 
0aab			 
0aab				; get frame buffer  
0aab			 
0aab 2a 5e fa			ld hl, (display_fb_active) 
0aae e5				push hl    ; future de destination 
0aaf			 
0aaf 11 14 00			ld  de, display_cols 
0ab2 19				add hl, de 
0ab3			 
0ab3 d1				pop de 
0ab4			 
0ab4				;ex de, hl 
0ab4 01 4f 00			ld bc, display_fb_len -1  
0ab7			;if DEBUG_FORTH_WORDS 
0ab7			;	DMARK "SCL" 
0ab7			;	CALLMONITOR 
0ab7			;endif	 
0ab7 ed b0			ldir 
0ab9			 
0ab9				; wipe bottom row 
0ab9			 
0ab9			 
0ab9 2a 5e fa			ld hl, (display_fb_active) 
0abc 11 50 00			ld de, display_cols*display_rows 
0abf 19				add hl, de 
0ac0 06 14			ld b, display_cols 
0ac2 3e 20			ld a, ' ' 
0ac4			.scwipe: 
0ac4 77				ld (hl), a 
0ac5 2b				dec hl 
0ac6 10 fc			djnz .scwipe 
0ac8			 
0ac8				;pop hl 
0ac8			 
0ac8 c1				pop bc 
0ac9 d1				pop de 
0aca e1				pop hl 
0acb			 
0acb c9				ret 
0acc			 
0acc			 
0acc			;scroll_upo: 
0acc			;	ld de, display_row_1 
0acc			 ;	ld hl, display_row_2 
0acc			;	ld bc, display_cols 
0acc			;	ldir 
0acc			;	ld de, display_row_2 
0acc			 ;	ld hl, display_row_3 
0acc			;	ld bc, display_cols 
0acc			;	ldir 
0acc			;	ld de, display_row_3 
0acc			 ;	ld hl, display_row_4 
0acc			;	ld bc, display_cols 
0acc			;	ldir 
0acc			 
0acc			; TODO clear row 4 
0acc			 
0acc			;	ret 
0acc			 
0acc				 
0acc			scroll_down: 
0acc			 
0acc e5				push hl 
0acd d5				push de 
0ace c5				push bc 
0acf			 
0acf				; get frame buffer  
0acf			 
0acf 2a 5e fa			ld hl, (display_fb_active) 
0ad2			 
0ad2 11 4f 00			ld de, display_fb_len - 1 
0ad5 19				add hl, de 
0ad6			 
0ad6 e5			push hl    ; future de destination 
0ad7			 
0ad7 11 14 00			ld  de, display_cols 
0ada ed 52			sbc hl, de 
0adc			 
0adc			 
0adc d1				pop de 
0add			 
0add			;	ex de, hl 
0add 01 4f 00			ld bc, display_fb_len -1  
0ae0			 
0ae0			 
0ae0				 
0ae0			 
0ae0 ed b0			ldir 
0ae2			 
0ae2				; wipe bottom row 
0ae2			 
0ae2			 
0ae2			;	ld hl, (display_fb_active) 
0ae2			;;	ld de, display_cols*display_rows 
0ae2			;;	add hl, de 
0ae2			;	ld b, display_cols 
0ae2			;	ld a, ' ' 
0ae2			;.scwiped: 
0ae2			;	ld (hl), a 
0ae2			;	dec hl 
0ae2			;	djnz .scwiped 
0ae2			 
0ae2				;pop hl 
0ae2			 
0ae2 c1				pop bc 
0ae3 d1				pop de 
0ae4 e1				pop hl 
0ae5			 
0ae5 c9				ret 
0ae6			;scroll_down: 
0ae6			;	ld de, display_row_4 
0ae6			;	ld hl, display_row_3 
0ae6			;	ld bc, display_cols 
0ae6			;	ldir 
0ae6			;	ld de, display_row_3 
0ae6			; 	ld hl, display_row_2 
0ae6			;	ld bc, display_cols 
0ae6			;	ldir 
0ae6			;	ld de, display_row_2 
0ae6			;	ld hl, display_row_1 
0ae6			;	ld bc, display_cols 
0ae6			;	ldir 
0ae6			;;; TODO clear row 1 
0ae6			;	ret 
0ae6			 
0ae6			 
0ae6			 
0ae6			 
0ae6			 
0ae6			; clear active frame buffer 
0ae6			 
0ae6			clear_display: 
0ae6 3e 20			ld a, ' ' 
0ae8 c3 eb 0a			jp fill_display 
0aeb			 
0aeb			; fill active frame buffer with a char in A 
0aeb			 
0aeb			fill_display: 
0aeb 06 50			ld b,display_fb_len 
0aed 2a 5e fa			ld hl, (display_fb_active) 
0af0 77			.fd1:	ld (hl),a 
0af1 23				inc hl 
0af2 10 fc			djnz .fd1 
0af4 23				inc hl 
0af5 3e 00			ld a,0 
0af7 77				ld (hl),a 
0af8			 
0af8			 
0af8 c9				ret 
0af9			; Write string (DE) at pos (A) to active frame buffer 
0af9			 
0af9 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0afc 06 00					ld b,0 
0afe 4f					ld c,a 
0aff 09					add hl,bc 
0b00 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0b01 b7			            OR   A              ;Null terminator? 
0b02 c8			            RET  Z              ;Yes, so finished 
0b03 77					ld (hl),a 
0b04 23				inc hl 
0b05 13			            INC  DE             ;Point to next character 
0b06 18 f8		            JR   .sad1     ;Repeat 
0b08 c9					ret 
0b09			 
0b09			; using current frame buffer write to physical display 
0b09			 
0b09			update_display: 
0b09 e5				push hl 
0b0a 2a 5e fa			ld hl, (display_fb_active) 
0b0d cd 7d 65			call write_display 
0b10 e1				pop hl 
0b11 c9				ret 
0b12			 
0b12			; TODO scrolling 
0b12			 
0b12			 
0b12			; move cursor right one char 
0b12			cursor_right: 
0b12			 
0b12				; TODO shift right 
0b12				; TODO if beyond max col 
0b12				; TODO       cursor_next_line 
0b12			 
0b12 c9				ret 
0b13			 
0b13			 
0b13			cursor_next_line: 
0b13				; TODO first char 
0b13				; TODO line down 
0b13				; TODO if past last row 
0b13				; TODO    scroll up 
0b13			 
0b13 c9				ret 
0b14			 
0b14			cursor_left: 
0b14				; TODO shift left 
0b14				; TODO if beyond left  
0b14				; TODO     cursor prev line 
0b14				 
0b14 c9				ret 
0b15			 
0b15			cursor_prev_line: 
0b15				; TODO last char 
0b15				; TODO line up 
0b15				; TODO if past first row 
0b15				; TODO   scroll down 
0b15			 
0b15 c9				ret 
0b16			 
0b16			 
0b16			cout: 
0b16				; A - char 
0b16 c9				ret 
0b17			 
0b17			 
0b17			; Display a menu and allow item selection (optional toggle items) 
0b17			; 
0b17			; format: 
0b17			; hl pointer to word array with zero term for items 
0b17			; e.g.    db item1 
0b17			;         db .... 
0b17			;         db 0 
0b17			; 
0b17			; a = starting menu item  
0b17			; 
0b17			; de = pointer item toggle array   (todo) 
0b17			; 
0b17			; returns item selected in a 1-... 
0b17			; returns 0 if back button pressed 
0b17			; 
0b17			; NOTE: Uses system frame buffer to display 
0b17			; 
0b17			; LEFT, Q = go back 
0b17			; RIGHT, SPACE, CR = select 
0b17			; UP, A - Up 
0b17			; DOWN, Z - Down 
0b17			 
0b17			 
0b17			 
0b17			 
0b17			 
0b17			menu: 
0b17			 
0b17					; keep array pointer 
0b17			 
0b17 22 e6 f9				ld (store_tmp1), hl 
0b1a 32 e4 f9				ld (store_tmp2), a 
0b1d			 
0b1d					; check for key bounce 
0b1d			 
0b1d			if BASE_KEV 
0b1d			 
0b1d cd 32 67		.mbounce:	call cin 
0b20 fe 00				cp 0 
0b22 20 f9				jr nz, .mbounce 
0b24			endif 
0b24					; for ease use ex 
0b24			 
0b24					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b24 21 53 fb				ld hl, display_fb0 
0b27 22 5e fa				ld (display_fb_active), hl 
0b2a			 
0b2a cd e6 0a		.mloop:		call clear_display 
0b2d cd 09 0b				call update_display 
0b30			 
0b30					; draw selection id '>' at 1 
0b30			 
0b30					; init start of list display 
0b30			 
0b30 3e 05				ld a, 5 
0b32 32 e2 f9				ld (store_tmp3), a   ; display row count 
0b35 3a e4 f9				ld a,( store_tmp2) 
0b38 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b3b			 
0b3b					 
0b3b			.mitem:	 
0b3b			 
0b3b			 
0b3b 3a e5 f9				ld a,(store_tmp2+1) 
0b3e 6f					ld l, a 
0b3f 26 00				ld h, 0 
0b41 29					add hl, hl 
0b42 ed 5b e6 f9			ld de, (store_tmp1) 
0b46 19					add hl, de 
0b47 7e					ld a, (hl) 
0b48 23					inc hl 
0b49 66					ld h,(hl) 
0b4a 6f					ld l, a 
0b4b			 
0b4b cd 43 0d				call ishlzero 
0b4e 28 1a				jr z, .mdone 
0b50			 
0b50 eb					ex de, hl 
0b51 3a e2 f9				ld a, (store_tmp3) 
0b54 cd f9 0a				call str_at_display 
0b57					 
0b57			 
0b57					; next item 
0b57 3a e5 f9				ld a, (store_tmp2+1) 
0b5a 3c					inc a 
0b5b 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b5e			 
0b5e			 		; next row 
0b5e			 
0b5e 3a e2 f9				ld a, (store_tmp3) 
0b61 c6 14				add display_cols 
0b63 32 e2 f9				ld (store_tmp3), a 
0b66			 
0b66					; at end of screen? 
0b66			 
0b66 fe 10				cp display_rows*4 
0b68 20 d1				jr nz, .mitem 
0b6a			 
0b6a			 
0b6a			.mdone: 
0b6a cd 43 0d				call ishlzero 
0b6d 28 08				jr z, .nodn 
0b6f			 
0b6f 3e 3c				ld a, display_row_4 
0b71 11 f0 0b				ld de, .mdown 
0b74 cd f9 0a				call str_at_display 
0b77			 
0b77					; draw options to fill the screens with active item on line 1 
0b77					; if current option is 2 or more then display ^ in top 
0b77			 
0b77 3a e4 f9		.nodn:		ld a, (store_tmp2) 
0b7a fe 00				cp 0 
0b7c 28 08				jr z, .noup 
0b7e			 
0b7e 3e 00				ld a, 0 
0b80 11 ee 0b				ld de, .mup 
0b83 cd f9 0a				call str_at_display 
0b86			 
0b86 3e 02		.noup:		ld a, 2 
0b88 11 ec 0b				ld de, .msel 
0b8b cd f9 0a				call str_at_display 
0b8e			 
0b8e					; if current option + 1 is not null then display V in bottom 
0b8e					; get key 
0b8e cd 09 0b				call update_display 
0b91			 
0b91			 
0b91					; handle key 
0b91			 
0b91 cd 21 67				call cin_wait 
0b94			 
0b94 fe 05				cp KEY_UP 
0b96 28 2b				jr z, .mgoup 
0b98 fe 61				cp 'a' 
0b9a 28 27				jr z, .mgoup 
0b9c fe 0a				cp KEY_DOWN 
0b9e 28 32				jr z, .mgod 
0ba0 fe 7a				cp 'z' 
0ba2 28 2e				jr z, .mgod 
0ba4 fe 20				cp ' ' 
0ba6 28 34				jr z, .goend 
0ba8 fe 0c				cp KEY_RIGHT 
0baa 28 30				jr z, .goend 
0bac fe 0d				cp KEY_CR 
0bae 28 2c				jr z, .goend 
0bb0 fe 71				cp 'q' 
0bb2 28 0b				jr z, .goback 
0bb4			 
0bb4 fe 0b				cp KEY_LEFT 
0bb6 28 07				jr z, .goback 
0bb8 fe 08				cp KEY_BS 
0bba 28 03				jr z, .goback 
0bbc c3 2a 0b				jp .mloop 
0bbf			 
0bbf			.goback: 
0bbf 3e 00			ld a, 0 
0bc1 18 1d			jr .goend2 
0bc3			 
0bc3				; move up one 
0bc3			.mgoup: 
0bc3 3a e4 f9				ld a, (store_tmp2) 
0bc6 fe 00				cp 0 
0bc8 ca 2a 0b				jp z, .mloop 
0bcb 3d					dec a 
0bcc 32 e4 f9				ld (store_tmp2), a 
0bcf c3 2a 0b				jp .mloop 
0bd2			 
0bd2				; move down one 
0bd2			.mgod: 
0bd2 3a e4 f9				ld a, (store_tmp2) 
0bd5 3c					inc a 
0bd6 32 e4 f9				ld (store_tmp2), a 
0bd9 c3 2a 0b				jp .mloop 
0bdc			 
0bdc			 
0bdc			.goend: 
0bdc					; get selected item number 
0bdc			 
0bdc 3a e4 f9				ld a, (store_tmp2) 
0bdf 3c					inc a 
0be0			 
0be0			.goend2: 
0be0 f5					push af 
0be1			 
0be1					; restore active fb 
0be1					; TODO BUG assumes fb1 
0be1			 
0be1 21 02 fb				ld hl, display_fb1 
0be4 22 5e fa				ld (display_fb_active), hl 
0be7			 
0be7					; restore main regs 
0be7			 
0be7			 
0be7 cd 09 0b				call update_display 
0bea			 
0bea f1					pop af 
0beb			 
0beb c9				ret 
0bec			 
0bec .. 00		.msel:   db ">",0 
0bee .. 00		.mup:   db "^",0 
0bf0 .. 00		.mdown:   db "v",0 
0bf2			 
0bf2			 
0bf2			; eof 
0bf2			 
# End of file firmware_display.asm
0bf2			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bf2			; random number generators 
0bf2			 
0bf2			 
0bf2			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bf2			 
0bf2			 
0bf2			;-----> Generate a random number 
0bf2			; output a=answer 0<=a<=255 
0bf2			; all registers are preserved except: af 
0bf2			random: 
0bf2 e5			        push    hl 
0bf3 d5			        push    de 
0bf4 2a 40 fa		        ld      hl,(randData) 
0bf7 ed 5f		        ld      a,r 
0bf9 57			        ld      d,a 
0bfa 5e			        ld      e,(hl) 
0bfb 19			        add     hl,de 
0bfc 85			        add     a,l 
0bfd ac			        xor     h 
0bfe 22 40 fa		        ld      (randData),hl 
0c01 d1			        pop     de 
0c02 e1			        pop     hl 
0c03 c9			        ret 
0c04			 
0c04			 
0c04			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0c04			 
0c04			 
0c04			 
0c04			;------LFSR------ 
0c04			;James Montelongo 
0c04			;optimized by Spencer Putt 
0c04			;out: 
0c04			; a = 8 bit random number 
0c04			RandLFSR: 
0c04 21 46 fa		        ld hl,LFSRSeed+4 
0c07 5e			        ld e,(hl) 
0c08 23			        inc hl 
0c09 56			        ld d,(hl) 
0c0a 23			        inc hl 
0c0b 4e			        ld c,(hl) 
0c0c 23			        inc hl 
0c0d 7e			        ld a,(hl) 
0c0e 47			        ld b,a 
0c0f cb 13		        rl e  
0c11 cb 12			rl d 
0c13 cb 11		        rl c  
0c15 17				rla 
0c16 cb 13		        rl e  
0c18 cb 12			rl d 
0c1a cb 11		        rl c  
0c1c 17				rla 
0c1d cb 13		        rl e  
0c1f cb 12			rl d 
0c21 cb 11		        rl c  
0c23 17				rla 
0c24 67			        ld h,a 
0c25 cb 13		        rl e  
0c27 cb 12			rl d 
0c29 cb 11		        rl c  
0c2b 17				rla 
0c2c a8			        xor b 
0c2d cb 13		        rl e  
0c2f cb 12			rl d 
0c31 ac			        xor h 
0c32 a9			        xor c 
0c33 aa			        xor d 
0c34 21 48 fa		        ld hl,LFSRSeed+6 
0c37 11 49 fa		        ld de,LFSRSeed+7 
0c3a 01 07 00		        ld bc,7 
0c3d ed b8		        lddr 
0c3f 12			        ld (de),a 
0c40 c9			        ret 
0c41			 
0c41			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c41			 
0c41			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c41			 
0c41			 
0c41			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c41			 
0c41			prng16: 
0c41			;Inputs: 
0c41			;   (seed1) contains a 16-bit seed value 
0c41			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c41			;Outputs: 
0c41			;   HL is the result 
0c41			;   BC is the result of the LCG, so not that great of quality 
0c41			;   DE is preserved 
0c41			;Destroys: 
0c41			;   AF 
0c41			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c41			;160cc 
0c41			;26 bytes 
0c41 2a 3a fa		    ld hl,(seed1) 
0c44 44			    ld b,h 
0c45 4d			    ld c,l 
0c46 29			    add hl,hl 
0c47 29			    add hl,hl 
0c48 2c			    inc l 
0c49 09			    add hl,bc 
0c4a 22 3a fa		    ld (seed1),hl 
0c4d 2a 38 fa		    ld hl,(seed2) 
0c50 29			    add hl,hl 
0c51 9f			    sbc a,a 
0c52 e6 2d		    and %00101101 
0c54 ad			    xor l 
0c55 6f			    ld l,a 
0c56 22 38 fa		    ld (seed2),hl 
0c59 09			    add hl,bc 
0c5a c9			    ret 
0c5b			 
0c5b			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c5b			 
0c5b			rand32: 
0c5b			;Inputs: 
0c5b			;   (seed1_0) holds the lower 16 bits of the first seed 
0c5b			;   (seed1_1) holds the upper 16 bits of the first seed 
0c5b			;   (seed2_0) holds the lower 16 bits of the second seed 
0c5b			;   (seed2_1) holds the upper 16 bits of the second seed 
0c5b			;   **NOTE: seed2 must be non-zero 
0c5b			;Outputs: 
0c5b			;   HL is the result 
0c5b			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c5b			;Destroys: 
0c5b			;   AF 
0c5b			;Tested and passes all CAcert tests 
0c5b			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c5b			;it has a period of 18,446,744,069,414,584,320 
0c5b			;roughly 18.4 quintillion. 
0c5b			;LFSR taps: 0,2,6,7  = 11000101 
0c5b			;291cc 
0c5b			;seed1_0=$+1 
0c5b			;    ld hl,12345 
0c5b			;seed1_1=$+1 
0c5b			;    ld de,6789 
0c5b			;    ld b,h 
0c5b			;    ld c,l 
0c5b			;    add hl,hl \ rl e \ rl d 
0c5b			;    add hl,hl \ rl e \ rl d 
0c5b			;    inc l 
0c5b			;    add hl,bc 
0c5b			;    ld (seed1_0),hl 
0c5b			;    ld hl,(seed1_1) 
0c5b			;    adc hl,de 
0c5b			;    ld (seed1_1),hl 
0c5b			;    ex de,hl 
0c5b			;seed2_0=$+1 
0c5b			;    ld hl,9876 
0c5b			;seed2_1=$+1 
0c5b			;    ld bc,54321 
0c5b			;    add hl,hl \ rl c \ rl b 
0c5b			;    ld (seed2_1),bc 
0c5b			;    sbc a,a 
0c5b			;    and %11000101 
0c5b			;    xor l 
0c5b			;    ld l,a 
0c5b			;    ld (seed2_0),hl 
0c5b			;    ex de,hl 
0c5b			;    add hl,bc 
0c5b			;    ret 
0c5b			; 
0c5b			 
0c5b			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c5b			; 20 bytes, 86 cycles (excluding ret) 
0c5b			 
0c5b			; returns   hl = pseudorandom number 
0c5b			; corrupts   a 
0c5b			 
0c5b			; generates 16-bit pseudorandom numbers with a period of 65535 
0c5b			; using the xorshift method: 
0c5b			 
0c5b			; hl ^= hl << 7 
0c5b			; hl ^= hl >> 9 
0c5b			; hl ^= hl << 8 
0c5b			 
0c5b			; some alternative shift triplets which also perform well are: 
0c5b			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c5b			 
0c5b			;  org 32768 
0c5b			 
0c5b			xrnd: 
0c5b 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0c5e 3e 00		  ld a,0 
0c60 bd			  cp l 
0c61 20 02		  jr nz, .xrnd1 
0c63 2e 01		  ld l, 1 
0c65			.xrnd1: 
0c65			 
0c65 7c			  ld a,h 
0c66 1f			  rra 
0c67 7d			  ld a,l 
0c68 1f			  rra 
0c69 ac			  xor h 
0c6a 67			  ld h,a 
0c6b 7d			  ld a,l 
0c6c 1f			  rra 
0c6d 7c			  ld a,h 
0c6e 1f			  rra 
0c6f ad			  xor l 
0c70 6f			  ld l,a 
0c71 ac			  xor h 
0c72 67			  ld h,a 
0c73			 
0c73 22 3e fa		  ld (xrandc),hl 
0c76			 
0c76 c9			  ret 
0c77			;  
0c77			 
0c77			 
0c77			;;;; int maths 
0c77			 
0c77			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c77			; Divide 16-bit values (with 16-bit result) 
0c77			; In: Divide BC by divider DE 
0c77			; Out: BC = result, HL = rest 
0c77			; 
0c77			Div16: 
0c77 21 00 00		    ld hl,0 
0c7a 78			    ld a,b 
0c7b 06 08		    ld b,8 
0c7d			Div16_Loop1: 
0c7d 17			    rla 
0c7e ed 6a		    adc hl,hl 
0c80 ed 52		    sbc hl,de 
0c82 30 01		    jr nc,Div16_NoAdd1 
0c84 19			    add hl,de 
0c85			Div16_NoAdd1: 
0c85 10 f6		    djnz Div16_Loop1 
0c87 17			    rla 
0c88 2f			    cpl 
0c89 47			    ld b,a 
0c8a 79			    ld a,c 
0c8b 48			    ld c,b 
0c8c 06 08		    ld b,8 
0c8e			Div16_Loop2: 
0c8e 17			    rla 
0c8f ed 6a		    adc hl,hl 
0c91 ed 52		    sbc hl,de 
0c93 30 01		    jr nc,Div16_NoAdd2 
0c95 19			    add hl,de 
0c96			Div16_NoAdd2: 
0c96 10 f6		    djnz Div16_Loop2 
0c98 17			    rla 
0c99 2f			    cpl 
0c9a 41			    ld b,c 
0c9b 4f			    ld c,a 
0c9c c9			ret 
0c9d			 
0c9d			 
0c9d			;http://z80-heaven.wikidot.com/math 
0c9d			; 
0c9d			;Inputs: 
0c9d			;     DE and A are factors 
0c9d			;Outputs: 
0c9d			;     A is not changed 
0c9d			;     B is 0 
0c9d			;     C is not changed 
0c9d			;     DE is not changed 
0c9d			;     HL is the product 
0c9d			;Time: 
0c9d			;     342+6x 
0c9d			; 
0c9d			Mult16: 
0c9d			 
0c9d 06 08		     ld b,8          ;7           7 
0c9f 21 00 00		     ld hl,0         ;10         10 
0ca2 29			       add hl,hl     ;11*8       88 
0ca3 07			       rlca          ;4*8        32 
0ca4 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ca6 19			         add hl,de   ;--         -- 
0ca7 10 f9		       djnz $-5      ;13*7+8     99 
0ca9 c9			ret 
0caa			 
0caa			; 
0caa			; Square root of 16-bit value 
0caa			; In:  HL = value 
0caa			; Out:  D = result (rounded down) 
0caa			; 
0caa			;Sqr16: 
0caa			;    ld de,#0040 
0caa			;    ld a,l 
0caa			;    ld l,h 
0caa			;    ld h,d 
0caa			;    or a 
0caa			;    ld b,8 
0caa			;Sqr16_Loop: 
0caa			;    sbc hl,de 
0caa			;    jr nc,Sqr16_Skip 
0caa			;    add hl,de 
0caa			;Sqr16_Skip: 
0caa			;    ccf 
0caa			;    rl d 
0caa			;    add a,a 
0caa			;    adc hl,hl 
0caa			;    add a,a 
0caa			;    adc hl,hl 
0caa			;    djnz Sqr16_Loop 
0caa			;    ret 
0caa			; 
0caa			; 
0caa			; Divide 8-bit values 
0caa			; In: Divide E by divider C 
0caa			; Out: A = result, B = rest 
0caa			; 
0caa			Div8: 
0caa af			    xor a 
0cab 06 08		    ld b,8 
0cad			Div8_Loop: 
0cad cb 13		    rl e 
0caf 17			    rla 
0cb0 91			    sub c 
0cb1 30 01		    jr nc,Div8_NoAdd 
0cb3 81			    add a,c 
0cb4			Div8_NoAdd: 
0cb4 10 f7		    djnz Div8_Loop 
0cb6 47			    ld b,a 
0cb7 7b			    ld a,e 
0cb8 17			    rla 
0cb9 2f			    cpl 
0cba c9			    ret 
0cbb			 
0cbb			; 
0cbb			; Multiply 8-bit value with a 16-bit value (unrolled) 
0cbb			; In: Multiply A with DE 
0cbb			; Out: HL = result 
0cbb			; 
0cbb			Mult12U: 
0cbb 2e 00		    ld l,0 
0cbd 87			    add a,a 
0cbe 30 01		    jr nc,Mult12U_NoAdd0 
0cc0 19			    add hl,de 
0cc1			Mult12U_NoAdd0: 
0cc1 29			    add hl,hl 
0cc2 87			    add a,a 
0cc3 30 01		    jr nc,Mult12U_NoAdd1 
0cc5 19			    add hl,de 
0cc6			Mult12U_NoAdd1: 
0cc6 29			    add hl,hl 
0cc7 87			    add a,a 
0cc8 30 01		    jr nc,Mult12U_NoAdd2 
0cca 19			    add hl,de 
0ccb			Mult12U_NoAdd2: 
0ccb 29			    add hl,hl 
0ccc 87			    add a,a 
0ccd 30 01		    jr nc,Mult12U_NoAdd3 
0ccf 19			    add hl,de 
0cd0			Mult12U_NoAdd3: 
0cd0 29			    add hl,hl 
0cd1 87			    add a,a 
0cd2 30 01		    jr nc,Mult12U_NoAdd4 
0cd4 19			    add hl,de 
0cd5			Mult12U_NoAdd4: 
0cd5 29			    add hl,hl 
0cd6 87			    add a,a 
0cd7 30 01		    jr nc,Mult12U_NoAdd5 
0cd9 19			    add hl,de 
0cda			Mult12U_NoAdd5: 
0cda 29			    add hl,hl 
0cdb 87			    add a,a 
0cdc 30 01		    jr nc,Mult12U_NoAdd6 
0cde 19			    add hl,de 
0cdf			Mult12U_NoAdd6: 
0cdf 29			    add hl,hl 
0ce0 87			    add a,a 
0ce1 d0			    ret nc 
0ce2 19			    add hl,de 
0ce3 c9			    ret 
0ce4			 
0ce4			; 
0ce4			; Multiply 8-bit value with a 16-bit value (right rotating) 
0ce4			; In: Multiply A with DE 
0ce4			;      Put lowest value in A for most efficient calculation 
0ce4			; Out: HL = result 
0ce4			; 
0ce4			Mult12R: 
0ce4 21 00 00		    ld hl,0 
0ce7			Mult12R_Loop: 
0ce7 cb 3f		    srl a 
0ce9 30 01		    jr nc,Mult12R_NoAdd 
0ceb 19			    add hl,de 
0cec			Mult12R_NoAdd: 
0cec cb 23		    sla e 
0cee cb 12		    rl d 
0cf0 b7			    or a 
0cf1 c2 e7 0c		    jp nz,Mult12R_Loop 
0cf4 c9			    ret 
0cf5			 
0cf5			; 
0cf5			; Multiply 16-bit values (with 32-bit result) 
0cf5			; In: Multiply BC with DE 
0cf5			; Out: BCHL = result 
0cf5			; 
0cf5			Mult32: 
0cf5 79			    ld a,c 
0cf6 48			    ld c,b 
0cf7 21 00 00		    ld hl,0 
0cfa 06 10		    ld b,16 
0cfc			Mult32_Loop: 
0cfc 29			    add hl,hl 
0cfd 17			    rla 
0cfe cb 11		    rl c 
0d00 30 07		    jr nc,Mult32_NoAdd 
0d02 19			    add hl,de 
0d03 ce 00		    adc a,0 
0d05 d2 09 0d		    jp nc,Mult32_NoAdd 
0d08 0c			    inc c 
0d09			Mult32_NoAdd: 
0d09 10 f1		    djnz Mult32_Loop 
0d0b 41			    ld b,c 
0d0c 4f			    ld c,a 
0d0d c9			    ret 
0d0e			 
0d0e			 
0d0e			 
0d0e			; 
0d0e			; Multiply 8-bit values 
0d0e			; In:  Multiply H with E 
0d0e			; Out: HL = result 
0d0e			; 
0d0e			Mult8: 
0d0e 16 00		    ld d,0 
0d10 6a			    ld l,d 
0d11 06 08		    ld b,8 
0d13			Mult8_Loop: 
0d13 29			    add hl,hl 
0d14 30 01		    jr nc,Mult8_NoAdd 
0d16 19			    add hl,de 
0d17			Mult8_NoAdd: 
0d17 10 fa		    djnz Mult8_Loop 
0d19 c9			    ret 
0d1a			 
0d1a			 
0d1a			 
0d1a			 
0d1a			 
0d1a			 
0d1a			 
0d1a			 
0d1a			;;http://z80-heaven.wikidot.com/math 
0d1a			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d1a			; 
0d1a			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d1a			;     ld a,16        ;7 
0d1a			;     ld hl,0        ;10 
0d1a			;     jp $+5         ;10 
0d1a			;.DivLoop: 
0d1a			;       add hl,bc    ;-- 
0d1a			;       dec a        ;64 
0d1a			;       jr z,.DivLoopEnd        ;86 
0d1a			; 
0d1a			;       sla e        ;128 
0d1a			;       rl d         ;128 
0d1a			;       adc hl,hl    ;240 
0d1a			;       sbc hl,bc    ;240 
0d1a			;       jr nc,.DivLoop ;23|21 
0d1a			;       inc e        ;-- 
0d1a			;       jp .DivLoop+1 
0d1a			; 
0d1a			;.DivLoopEnd: 
0d1a			 
0d1a			;HL_Div_C: 
0d1a			;Inputs: 
0d1a			;     HL is the numerator 
0d1a			;     C is the denominator 
0d1a			;Outputs: 
0d1a			;     A is the remainder 
0d1a			;     B is 0 
0d1a			;     C is not changed 
0d1a			;     DE is not changed 
0d1a			;     HL is the quotient 
0d1a			; 
0d1a			;       ld b,16 
0d1a			;       xor a 
0d1a			;         add hl,hl 
0d1a			;         rla 
0d1a			;         cp c 
0d1a			;         jr c,$+4 
0d1a			;           inc l 
0d1a			;           sub c 
0d1a			;         djnz $-7 
0d1a			 
0d1a			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d1a			 
0d1a			addatohl: 
0d1a 85			    add   a, l    ; A = A+L 
0d1b 6f			    ld    l, a    ; L = A+L 
0d1c 8c			    adc   a, h    ; A = A+L+H+carry 
0d1d 95			    sub   l       ; A = H+carry 
0d1e 67			    ld    h, a    ; H = H+carry 
0d1f c9			ret 
0d20			 
0d20			addatode: 
0d20 83			    add   a, e    ; A = A+L 
0d21 5f			    ld    e, a    ; L = A+L 
0d22 8a			    adc   a, d    ; A = A+L+H+carry 
0d23 93			    sub   e       ; A = H+carry 
0d24 57			    ld    d, a    ; H = H+carry 
0d25 c9			ret 
0d26			 
0d26			 
0d26			addatobc: 
0d26 81			    add   a, c    ; A = A+L 
0d27 4f			    ld    c, a    ; L = A+L 
0d28 88			    adc   a, b    ; A = A+L+H+carry 
0d29 91			    sub   c       ; A = H+carry 
0d2a 47			    ld    b, a    ; H = H+carry 
0d2b c9			ret 
0d2c			 
0d2c			subafromhl: 
0d2c			   ; If A=0 do nothing 
0d2c			    ; Otherwise flip A's sign. Since 
0d2c			    ; the upper byte becomes -1, also 
0d2c			    ; substract 1 from H. 
0d2c ed 44		    neg 
0d2e ca 37 0d		    jp    z, Skip 
0d31 25			    dec   h 
0d32			     
0d32			    ; Now add the low byte as usual 
0d32			    ; Two's complement takes care of 
0d32			    ; ensuring the result is correct 
0d32 85			    add   a, l 
0d33 6f			    ld    l, a 
0d34 8c			    adc   a, h 
0d35 95			    sub   l 
0d36 67			    ld    h, a 
0d37			Skip: 
0d37 c9				ret 
0d38			 
0d38			 
0d38			; compare hl and de 
0d38			; returns:  
0d38			; if hl = de, z=1, s=0, c0=0 
0d38			; if hl > de, z=0, s=0, c=0 
0d38			; if hl < de, z=0, s=1, c=1 
0d38			cmp16:	 
0d38 b7				or a 
0d39 ed 52			sbc hl,de 
0d3b e0				ret po 
0d3c 7c				ld a,h 
0d3d 1f				rra 
0d3e ee 40			xor 01000000B 
0d40 37				scf 
0d41 8f				adc a,a 
0d42 c9				ret 
0d43			 
0d43			 
0d43			; test if hl contains zero   - A is destroyed 
0d43			 
0d43			ishlzero:    
0d43 b7				or a     ; reset flags 
0d44 7c				ld a, h 
0d45 b5				or l        	 
0d46			 
0d46 c9				ret 
0d47			 
0d47			 
0d47			 
0d47			 
0d47			if FORTH_ENABLE_FLOATMATH 
0d47			;include "float/bbcmath.z80" 
0d47			include "float/lpfpcalc.asm" 
0d47			endif 
0d47			 
0d47			 
0d47			; eof 
0d47			 
# End of file firmware_maths.asm
0d47			include "firmware_strings.asm"   ; string handling  
0d47			 
0d47			 
0d47			; TODO string len 
0d47			; input text string, end on cr with zero term 
0d47			; a offset into frame buffer to start prompt 
0d47			; d is max length 
0d47			; e is display size TODO 
0d47			; c is current cursor position 
0d47			; hl is ptr to where string will be stored 
0d47			 
0d47			 
0d47			; TODO check limit of buffer for new inserts 
0d47			; TODO check insert does not push beyond buffer 
0d47			; TODO scroll in a limited display area 
0d47			; TODO scroll whole screen on page wrap 
0d47			 
0d47			 
0d47			; TODO handle KEY_PREVWORD 
0d47			; TODO handle KEY_NEXTWORD 
0d47			; TODO handle KEY_HOME 
0d47			; TODO handle KEY_END 
0d47			; TODO use LCD cursor? 
0d47			 
0d47 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d4a 81					add c 
0d4b 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d4e 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0d51 79					ld a, c 
0d52 cd 1a 0d				call addatohl 
0d55 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d58 7a					ld a,d 
0d59 32 b8 fb			        ld (input_size), a       ; save length of input area 
0d5c 79					ld a, c 
0d5d 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0d60 7b					ld a,e 
0d61 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d64					 
0d64					 
0d64			 
0d64			;		ld a,(input_ptr) 
0d64			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d64			 
0d64			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d64					; init cursor shape if not set by the cin routines 
0d64 21 56 fa				ld hl, cursor_shape 
0d67 3e ff				ld a, 255 
0d69 77					ld (hl), a 
0d6a 23					inc hl 
0d6b 3e 00				ld a, 0 
0d6d 77					ld (hl), a 
0d6e			 
0d6e 3e 0f				ld a, CUR_BLINK_RATE 
0d70 32 b2 fb				ld (input_cur_flash), a 
0d73 3e 01				ld a, 1 
0d75 32 b1 fb				ld (input_cur_onoff),a 
0d78			 
0d78			;	if DEBUG_INPUT 
0d78			;		push af 
0d78			;		ld a, 'I' 
0d78			;		ld (debug_mark),a 
0d78			;		pop af 
0d78			;		CALLMONITOR 
0d78			;	endif 
0d78			.is1:		; main entry loop 
0d78			 
0d78			 
0d78			 
0d78					; pause 1ms 
0d78			 
0d78 3e 01				ld a, 1 
0d7a cd 4b 0a				call aDelayInMS 
0d7d			 
0d7d					; dec flash counter 
0d7d 3a b2 fb				ld a, (input_cur_flash) 
0d80 3d					dec a 
0d81 32 b2 fb				ld (input_cur_flash), a 
0d84 fe 00				cp 0 
0d86 20 0d				jr nz, .nochgstate 
0d88			 
0d88			 
0d88					; change state 
0d88 3a b1 fb				ld a,(input_cur_onoff) 
0d8b ed 44				neg 
0d8d 32 b1 fb				ld (input_cur_onoff),a 
0d90			 
0d90			 
0d90					; reset on change of state 
0d90 3e 0f				ld a, CUR_BLINK_RATE 
0d92 32 b2 fb				ld (input_cur_flash), a 
0d95			 
0d95			.nochgstate: 
0d95					 
0d95					 
0d95			 
0d95					; display cursor  
0d95			 
0d95			;		ld hl, (input_start) 
0d95			;		ld a, (input_cursor) 
0d95			;		call addatohl 
0d95			 
0d95					; get char under cursor and replace with cursor 
0d95 2a bb fb		ld hl, (input_ptr) 
0d98			;		ld a, (hl) 
0d98			;		ld (input_under_cursor),a 
0d98			;		ld a, '_' 
0d98			;		ld (hl), a 
0d98			 
0d98					; display string 
0d98			 
0d98 ed 5b b9 fb			ld de, (input_start) 
0d9c 3a b6 fb				ld a, (input_at_pos) 
0d9f cd f9 0a				call str_at_display 
0da2			;	        call update_display 
0da2			 
0da2					; find place to put the cursor 
0da2			;		add h 
0da2			;		ld l, display_row_1 
0da2			;		sub l 
0da2			; (input_at_pos) 
0da2					;ld c, a 
0da2			;		ld a, (input_cursor) 
0da2			;		ld l, (input_at_pos) 
0da2			;		;ld b, h 
0da2			;		add l 
0da2			;		ld (input_at_cursor),a 
0da2					;ld l,h 
0da2			 
0da2			;		ld h, 0 
0da2			;		ld l,(input_at_pos) 
0da2			;		ld a, (input_cursor) 
0da2			;		call addatohl 
0da2			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0da2			;		call subafromhl 
0da2			;		ld a,l 
0da2			;		ld (input_at_cursor), a 
0da2			 
0da2				if DEBUG_INPUT 
0da2					ld a, (hardware_diag) 
0da2					cp 0 
0da2					jr z, .skip_input_diag 
0da2			 
0da2					ld a,(input_at_pos) 
0da2					ld hl, LFSRSeed 
0da2					call hexout 
0da2					ld a, (input_cursor) 
0da2					ld hl, LFSRSeed+2 
0da2					call hexout 
0da2					ld a,(input_at_cursor) 
0da2					ld hl, LFSRSeed+4 
0da2					call hexout 
0da2			 
0da2					ld a,(input_cur_onoff) 
0da2					ld hl, LFSRSeed+6 
0da2					call hexout 
0da2			 
0da2					ld a,(input_cur_flash) 
0da2					ld hl, LFSRSeed+8 
0da2					call hexout 
0da2			 
0da2					ld a,(input_len) 
0da2					ld hl, LFSRSeed+10 
0da2					call hexout 
0da2					ld hl, LFSRSeed+12 
0da2					ld a, 0 
0da2					ld (hl),a 
0da2					ld a, display_row_4 
0da2					ld de, LFSRSeed 
0da2					call str_at_display 
0da2					.skip_input_diag: 
0da2				endif 
0da2			 
0da2					; decide on if we are showing the cursor this time round 
0da2			 
0da2 3a b1 fb				ld a, (input_cur_onoff) 
0da5 fe ff				cp 255 
0da7 28 13				jr z, .skipcur 
0da9			 
0da9			 
0da9 3a b4 fb				ld a,(input_at_cursor) 
0dac 11 56 fa				ld de, cursor_shape 
0daf cd f9 0a				call str_at_display 
0db2			 
0db2					; save length of current input string 
0db2 2a b9 fb				ld hl, (input_start) 
0db5 cd 78 11				call strlenz 
0db8 7d					ld a,l 
0db9 32 ac fb				ld (input_len),a 
0dbc			 
0dbc			.skipcur: 
0dbc			 
0dbc cd 09 0b			        call update_display 
0dbf					 
0dbf			 
0dbf			 
0dbf					; wait 
0dbf				 
0dbf					; TODO loop without wait to flash the cursor and char under cursor	 
0dbf cd 32 67				call cin    ; _wait 
0dc2			 
0dc2 fe 00				cp 0 
0dc4 ca 78 0d				jp z, .is1 
0dc7			 
0dc7					; get ptr to char to input into 
0dc7			 
0dc7 4f					ld c,a 
0dc8 2a b9 fb				ld hl, (input_start) 
0dcb 3a a7 fb				ld a, (input_cursor) 
0dce cd 1a 0d				call addatohl 
0dd1 22 bb fb				ld (input_ptr), hl 
0dd4 79					ld a,c 
0dd5			 
0dd5					; replace char under cursor 
0dd5			 
0dd5			;		ld hl, (input_ptr) 
0dd5			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dd5			;		ld (hl), a 
0dd5			 
0dd5			;	if DEBUG_INPUT 
0dd5			;		push af 
0dd5			;		ld a, 'i' 
0dd5			;		ld (debug_mark),a 
0dd5			;		pop af 
0dd5			;		CALLMONITOR 
0dd5			;	endif 
0dd5 fe 0e				cp KEY_HOME 
0dd7 20 0e				jr nz, .iske 
0dd9			 
0dd9 3a b6 fb				ld a, (input_at_pos) 
0ddc 32 b4 fb				ld (input_at_cursor),a 
0ddf 3e 00				ld a, 0 
0de1 32 a7 fb				ld (input_cursor), a 
0de4 c3 78 0d				jp .is1 
0de7					 
0de7 fe 0f		.iske:		cp KEY_END 
0de9 20 03				jr nz, .isknw 
0deb c3 78 0d				jp .is1 
0dee			 
0dee fe 06		.isknw:		cp KEY_NEXTWORD 
0df0 20 1b				jr nz, .iskpw 
0df2			 
0df2 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0df5 7e					ld a,(hl)	 
0df6 fe 00				cp 0 
0df8 ca 78 0d				jp z, .is1    ; end of string 
0dfb fe 20				cp ' ' 
0dfd ca 78 0d				jp z, .is1    ; end of word 
0e00 23					inc hl 
0e01 22 bb fb				ld (input_ptr), hl 
0e04 3a b4 fb				ld a, (input_at_cursor) 
0e07 3c					inc a 
0e08 32 b4 fb				ld (input_at_cursor), a 
0e0b 18 e5				jr .isknwm 
0e0d			 
0e0d fe 07		.iskpw:		cp KEY_PREVWORD 
0e0f 20 1b				jr nz, .iskl 
0e11			.iskpwm:	 
0e11 2a bb fb				ld hl, (input_ptr) 
0e14 7e					ld a,(hl)	 
0e15 fe 00				cp 0  
0e17 ca 78 0d				jp z, .is1    ; end of string 
0e1a fe 20				cp ' ' 
0e1c ca 78 0d				jp z, .is1    ; end of word 
0e1f 2b					dec hl 
0e20 22 bb fb				ld (input_ptr), hl 
0e23 3a b4 fb				ld a, (input_at_cursor) 
0e26 3d					dec a 
0e27 32 b4 fb				ld (input_at_cursor), a 
0e2a 18 e5				jr .iskpwm 
0e2c			 
0e2c			 
0e2c fe 0b		.iskl:		cp KEY_LEFT 
0e2e 20 27				jr nz, .isk1 
0e30			 
0e30 3a a7 fb				ld a, (input_cursor) 
0e33			 
0e33 fe 00				cp 0 
0e35 ca 78 0d				jp z, .is1 		; at start of line to ignore  
0e38			 
0e38 3d					dec  a 		; TODO check underflow 
0e39 32 a7 fb				ld (input_cursor), a 
0e3c			 
0e3c 2a bb fb				ld hl, (input_ptr) 
0e3f 2b					dec hl 
0e40 22 bb fb				ld (input_ptr), hl 
0e43					 
0e43 3a b4 fb				ld a, (input_at_cursor) 
0e46 3d					dec a 
0e47 32 b4 fb				ld (input_at_cursor), a 
0e4a			 
0e4a 3e 01				ld a, 1		; show cursor moving 
0e4c 32 b1 fb				ld (input_cur_onoff),a 
0e4f 3e 0f				ld a, CUR_BLINK_RATE 
0e51 32 b2 fb				ld (input_cur_flash), a 
0e54			 
0e54 c3 78 0d				jp .is1 
0e57			 
0e57 fe 0c		.isk1:		cp KEY_RIGHT 
0e59 20 2a				jr nz, .isk2 
0e5b			 
0e5b 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e5e 5f					ld e,a 
0e5f 3a a7 fb				ld a, (input_cursor) 
0e62 bb					cp e 
0e63 ca 78 0d				jp z, .is1		; at the end of string so dont go right 
0e66			 
0e66 3c					inc  a 		; TODO check overflow 
0e67 32 a7 fb				ld (input_cursor), a 
0e6a			 
0e6a 3a b4 fb				ld a, (input_at_cursor) 
0e6d 3c					inc a 
0e6e 32 b4 fb				ld (input_at_cursor), a 
0e71			 
0e71 2a bb fb				ld hl, (input_ptr) 
0e74 23					inc hl 
0e75 22 bb fb				ld (input_ptr), hl 
0e78			 
0e78 3e 01				ld a, 1		; show cursor moving 
0e7a 32 b1 fb				ld (input_cur_onoff),a 
0e7d 3e 0f				ld a, CUR_BLINK_RATE 
0e7f 32 b2 fb				ld (input_cur_flash), a 
0e82			 
0e82 c3 78 0d				jp .is1 
0e85			 
0e85 fe 05		.isk2:		cp KEY_UP 
0e87			 
0e87 20 26				jr nz, .isk3 
0e89			 
0e89					; swap last command with the current on 
0e89			 
0e89					; move cursor to start of string 
0e89 2a b9 fb				ld hl, (input_start) 
0e8c 22 bb fb				ld (input_ptr), hl 
0e8f			 
0e8f 3a b6 fb				ld a, (input_at_pos) 
0e92 32 b4 fb				ld (input_at_cursor), a 
0e95			 
0e95 3e 00				ld a, 0 
0e97 32 a7 fb				ld (input_cursor), a 
0e9a					 
0e9a					; swap input and last command buffers 
0e9a			 
0e9a 21 ca f2				ld hl, os_cli_cmd 
0e9d 11 c9 f3				ld de, os_last_cmd 
0ea0 06 ff				ld b, 255 
0ea2 7e			.swap1:		ld a, (hl) 
0ea3 4f					ld c,a 
0ea4 1a					ld a, (de) 
0ea5 77					ld (hl), a 
0ea6 79					ld a,c 
0ea7 12					ld (de),a 
0ea8 23					inc hl 
0ea9 13					inc de 
0eaa 10 f6				djnz .swap1 
0eac			 
0eac			 
0eac			 
0eac			 
0eac			 
0eac c3 78 0d				jp .is1 
0eaf			 
0eaf fe 08		.isk3:		cp KEY_BS 
0eb1 20 3c				jr nz, .isk4 
0eb3			 
0eb3 3a a7 fb				ld a, (input_cursor) 
0eb6			 
0eb6 fe 00				cp 0 
0eb8 ca 78 0d				jp z, .is1 		; at start of line to ignore  
0ebb			 
0ebb 3d					dec  a 		; TODO check underflow 
0ebc 32 a7 fb				ld (input_cursor), a 
0ebf			 
0ebf					; hl is source 
0ebf					; de needs to be source - 1 
0ebf			 
0ebf			;		ld a, 0 
0ebf			;		dec hl 
0ebf			;		ld (hl), a 
0ebf			 
0ebf 2a bb fb				ld hl, (input_ptr) 
0ec2 2b					dec hl 
0ec3 22 bb fb				ld (input_ptr), hl 
0ec6			 
0ec6					; shift all data 
0ec6			 
0ec6 e5					push hl 
0ec7 23					inc hl 
0ec8 d1					pop de 
0ec9 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ecc 4f					ld c,a 
0ecd 06 00				ld b,0 
0ecf ed b0				ldir  
0ed1			 
0ed1			 
0ed1			 
0ed1			 
0ed1 3a b4 fb				ld a, (input_at_cursor) 
0ed4 3d					dec a 
0ed5 32 b4 fb				ld (input_at_cursor), a 
0ed8			 
0ed8			 
0ed8 3e 01				ld a, 1		; show cursor moving 
0eda 32 b1 fb				ld (input_cur_onoff),a 
0edd 3e 0f				ld a, CUR_BLINK_RATE 
0edf 32 b2 fb				ld (input_cur_flash), a 
0ee2			 
0ee2					; remove char 
0ee2 3a b4 fb				ld a, (input_at_cursor) 
0ee5 3c					inc a 
0ee6 11 70 0f				ld de,.iblank 
0ee9 cd f9 0a				call str_at_display 
0eec			 
0eec c3 78 0d				jp .is1 
0eef			 
0eef fe 0d		.isk4:		cp KEY_CR 
0ef1 28 6c				jr z, .endinput 
0ef3			 
0ef3					; else add the key press to the end 
0ef3			 
0ef3 4f					ld c, a			; save key pressed 
0ef4			 
0ef4 7e					ld a,(hl)		; get what is currently under char 
0ef5			 
0ef5 fe 00				cp 0			; we are at the end of the string 
0ef7 20 2f				jr nz, .onchar 
0ef9					 
0ef9					; add a char to the end of the string 
0ef9				 
0ef9 71					ld (hl),c 
0efa 23					inc hl 
0efb			;		ld a,' ' 
0efb			;		ld (hl),a 
0efb			;		inc hl 
0efb 3e 00				ld a,0 
0efd 77					ld (hl),a 
0efe 2b					dec hl 
0eff			 
0eff 3a a7 fb				ld a, (input_cursor) 
0f02 3c					inc a				; TODO check max string length and scroll  
0f03 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0f06							 
0f06 3a b4 fb				ld a, (input_at_cursor) 
0f09 3c					inc a 
0f0a 32 b4 fb				ld (input_at_cursor), a 
0f0d			 
0f0d 2a bb fb				ld hl, (input_ptr) 
0f10 23					inc hl 
0f11 22 bb fb				ld (input_ptr), hl 
0f14			 
0f14 2a bb fb				ld hl, (input_ptr) 
0f17 23					inc hl 
0f18 22 bb fb				ld (input_ptr), hl 
0f1b			;	if DEBUG_INPUT 
0f1b			;		push af 
0f1b			;		ld a, '+' 
0f1b			;		ld (debug_mark),a 
0f1b			;		pop af 
0f1b			;		CALLMONITOR 
0f1b			;	endif 
0f1b 3e 01				ld a, 1		; show cursor moving 
0f1d 32 b1 fb				ld (input_cur_onoff),a 
0f20 3e 0f				ld a, CUR_BLINK_RATE 
0f22 32 b2 fb				ld (input_cur_flash), a 
0f25 c3 78 0d				jp .is1 
0f28					 
0f28			 
0f28			 
0f28					; if on a char then insert 
0f28			.onchar: 
0f28			 
0f28					; TODO over flow check: make sure insert does not blow out buffer 
0f28			 
0f28					; need to do some maths to use lddr 
0f28			 
0f28 e5					push hl   ; save char pos 
0f29 c5					push bc 
0f2a			 
0f2a 2a b9 fb				ld hl, (input_start) 
0f2d 3a ac fb				ld a, (input_len) 
0f30 cd 1a 0d				call addatohl  		; end of string 
0f33 23					inc hl 
0f34 23					inc hl		; past zero term 
0f35 e5					push hl 
0f36 23					inc hl 
0f37 e5					push hl  
0f38			 
0f38								; start and end of lddr set, now how much to move? 
0f38			 
0f38							 
0f38 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f3b 47					ld b,a 
0f3c 3a ac fb				ld a,(input_len) 
0f3f 5f					ld e,a 
0f40 90					sub b 
0f41 3c					inc a		;?? 
0f42 3c					inc a		;?? 
0f43 3c					inc a		;?? 
0f44			 
0f44 06 00				ld b,0 
0f46 4f					ld c,a 
0f47			 
0f47				if DEBUG_INPUT 
0f47					push af 
0f47					ld a, 'i' 
0f47					ld (debug_mark),a 
0f47					pop af 
0f47			;		CALLMONITOR 
0f47				endif 
0f47 d1					pop de 
0f48 e1					pop hl 
0f49				if DEBUG_INPUT 
0f49					push af 
0f49					ld a, 'I' 
0f49					ld (debug_mark),a 
0f49					pop af 
0f49			;		CALLMONITOR 
0f49				endif 
0f49 ed b8				lddr 
0f4b				 
0f4b			 
0f4b			 
0f4b					; TODO have a key for insert/overwrite mode???? 
0f4b c1					pop bc 
0f4c e1					pop hl 
0f4d 71					ld (hl), c		; otherwise overwrite current char 
0f4e					 
0f4e			 
0f4e			 
0f4e			 
0f4e 3a a7 fb				ld a, (input_cursor) 
0f51 3c					inc  a 		; TODO check overflow 
0f52 32 a7 fb				ld (input_cursor), a 
0f55			 
0f55 3a b4 fb				ld a, (input_at_cursor) 
0f58 3c					inc a 
0f59 32 b4 fb				ld (input_at_cursor), a 
0f5c			 
0f5c c3 78 0d				jp .is1 
0f5f			 
0f5f			.endinput:	; TODO look for end of string 
0f5f			 
0f5f					; add trailing space for end of token 
0f5f			 
0f5f 2a b9 fb				ld hl, (input_start) 
0f62 3a ac fb				ld a,(input_len) 
0f65 cd 1a 0d				call addatohl 
0f68 3e 20				ld a, ' ' 
0f6a 77					ld (hl),a 
0f6b					; TODO eof of parse marker 
0f6b			 
0f6b 23					inc hl 
0f6c 3e 00				ld a, 0 
0f6e 77					ld (hl),a 
0f6f			 
0f6f			 
0f6f c9					ret 
0f70			 
0f70 .. 00		.iblank: db " ",0 
0f72			 
0f72			 
0f72 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0f75 22 b9 fb				ld (input_start), hl 
0f78 3e 01				ld a,1			; add cursor 
0f7a 77					ld (hl),a 
0f7b 23					inc hl 
0f7c 3e 00				ld a,0 
0f7e 77					ld (hl),a 
0f7f 22 bb fb				ld (input_ptr), hl 
0f82 7a					ld a,d 
0f83 32 b8 fb				ld (input_size), a 
0f86 3e 00				ld a,0 
0f88 32 a7 fb				ld (input_cursor),a 
0f8b			.instr1:	 
0f8b			 
0f8b					; TODO do block cursor 
0f8b					; TODO switch cursor depending on the modifer key 
0f8b			 
0f8b					; update cursor shape change on key hold 
0f8b			 
0f8b 2a bb fb				ld hl, (input_ptr) 
0f8e 2b					dec hl 
0f8f 3a 56 fa				ld a,(cursor_shape) 
0f92 77					ld (hl), a 
0f93			 
0f93					; display entered text 
0f93 3a b6 fb				ld a,(input_at_pos) 
0f96 cd 50 66		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f99 ed 5b b9 fb	            	LD   de, (input_start) 
0f9d cd 58 66		            	CALL fLCD_Str       ;Display string pointed to by DE 
0fa0			 
0fa0 cd 32 67				call cin 
0fa3 fe 00				cp 0 
0fa5 28 e4				jr z, .instr1 
0fa7			 
0fa7					; proecess keyboard controls first 
0fa7			 
0fa7 2a bb fb				ld hl,(input_ptr) 
0faa			 
0faa fe 0d				cp KEY_CR	 ; pressing enter ends input 
0fac 28 5a				jr z, .instrcr 
0fae			 
0fae fe 08				cp KEY_BS 	; back space 
0fb0 20 0f				jr nz, .instr2 
0fb2					; process back space 
0fb2			 
0fb2					; TODO stop back space if at start of string 
0fb2 2b					dec hl 
0fb3 2b					dec hl ; to over write cursor 
0fb4 3a 56 fa				ld a,(cursor_shape) 
0fb7					;ld a,0 
0fb7 77					ld (hl),a 
0fb8 23					inc hl 
0fb9 3e 20				ld a," " 
0fbb 77					ld (hl),a 
0fbc 22 bb fb				ld (input_ptr),hl 
0fbf					 
0fbf			 
0fbf 18 ca				jr .instr1 
0fc1			 
0fc1 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fc3 20 06				jr nz, .instr3 
0fc5 2b					dec hl 
0fc6 22 bb fb				ld (input_ptr),hl 
0fc9 18 c0				jr .instr1 
0fcb				 
0fcb fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fcd 20 06				jr nz, .instr4 
0fcf 23					inc hl 
0fd0 22 bb fb				ld (input_ptr),hl 
0fd3 18 b6				jr .instr1 
0fd5			 
0fd5 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fd7 20 06				jr nz, .instr5 
0fd9 2b					dec hl 
0fda 22 bb fb				ld (input_ptr),hl 
0fdd 18 ac				jr .instr1 
0fdf			 
0fdf fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fe1 20 06				jr nz, .instr6 
0fe3 2b					dec hl 
0fe4 22 bb fb				ld (input_ptr),hl 
0fe7 18 a2				jr .instr1 
0fe9 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0feb 20 0b				jr nz, .instrnew 
0fed			 
0fed 21 a3 ef			ld hl, scratch 
0ff0 11 c9 f3			ld de, os_last_cmd 
0ff3 cd 11 10			call strcpy 
0ff6 18 93				jr .instr1 
0ff8			 
0ff8			 
0ff8			.instrnew:	; no special key pressed to see if we have room to store it 
0ff8			 
0ff8					; TODO do string size test 
0ff8			 
0ff8 2b					dec hl ; to over write cursor 
0ff9 77					ld (hl),a 
0ffa 23					inc hl 
0ffb 3a 56 fa				ld a,(cursor_shape) 
0ffe 77					ld (hl),a 
0fff 23					inc hl 
1000 3e 00				ld a,0 
1002 77					ld (hl),a 
1003			 
1003 22 bb fb				ld (input_ptr),hl 
1006					 
1006 18 83				jr .instr1 
1008 2b			.instrcr:	dec hl		; remove cursor 
1009 3e 20				ld a,' '	; TODO add a trailing space for safety 
100b 77					ld (hl),a 
100c 23					inc hl 
100d 3e 00				ld a,0 
100f 77					ld (hl),a 
1010			 
1010			 
1010					; if at end of line scroll up    
1010					; TODO detecting only end of line 4 for scroll up  
1010			 
1010					;ld   
1010			 
1010 c9					ret 
1011			 
1011			 
1011			; strcpy hl = dest, de source 
1011			 
1011 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1012 b7			            OR   A              ;Null terminator? 
1013 c8			            RET  Z              ;Yes, so finished 
1014 1a					ld a,(de) 
1015 77					ld (hl),a 
1016 13			            INC  DE             ;Point to next character 
1017 23					inc hl 
1018 18 f7		            JR   strcpy       ;Repeat 
101a c9					ret 
101b			 
101b			 
101b			; TODO string_at  
101b			; pass string which starts with lcd offset address and then null term string 
101b			 
101b			; TODO string to dec 
101b			; TODO string to hex 
101b			; TODO byte to string hex 
101b			; TODO byte to string dec 
101b			 
101b			 
101b			 
101b			; from z80uartmonitor 
101b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
101b			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
101b			; pass hl for where to put the text 
101b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
101b c5			hexout:	PUSH BC 
101c f5					PUSH AF 
101d 47					LD B, A 
101e					; Upper nybble 
101e cb 3f				SRL A 
1020 cb 3f				SRL A 
1022 cb 3f				SRL A 
1024 cb 3f				SRL A 
1026 cd 36 10				CALL tohex 
1029 77					ld (hl),a 
102a 23					inc hl	 
102b					 
102b					; Lower nybble 
102b 78					LD A, B 
102c e6 0f				AND 0FH 
102e cd 36 10				CALL tohex 
1031 77					ld (hl),a 
1032 23					inc hl	 
1033					 
1033 f1					POP AF 
1034 c1					POP BC 
1035 c9					RET 
1036					 
1036			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1036			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1036			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1036			tohex: 
1036 e5					PUSH HL 
1037 d5					PUSH DE 
1038 16 00				LD D, 0 
103a 5f					LD E, A 
103b 21 43 10				LD HL, .DATA 
103e 19					ADD HL, DE 
103f 7e					LD A, (HL) 
1040 d1					POP DE 
1041 e1					POP HL 
1042 c9					RET 
1043			 
1043			.DATA: 
1043 30					DEFB	30h	; 0 
1044 31					DEFB	31h	; 1 
1045 32					DEFB	32h	; 2 
1046 33					DEFB	33h	; 3 
1047 34					DEFB	34h	; 4 
1048 35					DEFB	35h	; 5 
1049 36					DEFB	36h	; 6 
104a 37					DEFB	37h	; 7 
104b 38					DEFB	38h	; 8 
104c 39					DEFB	39h	; 9 
104d 41					DEFB	41h	; A 
104e 42					DEFB	42h	; B 
104f 43					DEFB	43h	; C 
1050 44					DEFB	44h	; D 
1051 45					DEFB	45h	; E 
1052 46					DEFB	46h	; F 
1053			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1053			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1053			;;    subtract $30, if result > 9 then subtract $7 more 
1053			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1053			atohex: 
1053 d6 30				SUB $30 
1055 fe 0a				CP 10 
1057 f8					RET M		; If result negative it was 0-9 so we're done 
1058 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
105a c9					RET		 
105b			 
105b			 
105b			 
105b			 
105b			; Get 2 ASCII characters as hex byte from pointer in hl 
105b			 
105b			BYTERD: 
105b 16 00			LD	D,00h		;Set up 
105d cd 65 10			CALL	HEXCON		;Get byte and convert to hex 
1060 87				ADD	A,A		;First nibble so 
1061 87				ADD	A,A		;multiply by 16 
1062 87				ADD	A,A		; 
1063 87				ADD	A,A		; 
1064 57				LD	D,A		;Save hi nibble in D 
1065			HEXCON: 
1065 7e				ld a, (hl)		;Get next chr 
1066 23				inc hl 
1067 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1069 fe 0a			CP	00Ah		;Is it 0-9 ? 
106b 38 02			JR	C,NALPHA	;If so miss next bit 
106d d6 07			SUB	007h		;Else convert alpha 
106f			NALPHA: 
106f b2				OR	D		;Add hi nibble back 
1070 c9				RET			; 
1071			 
1071			 
1071			; 
1071			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1071			; Since the routines get_byte and therefore get_nibble are called, only valid 
1071			; characters (0-9a-f) are accepted. 
1071			; 
1071			;get_word        push    af 
1071			;                call    get_byte        ; Get the upper byte 
1071			;                ld      h, a 
1071			;                call    get_byte        ; Get the lower byte 
1071			;                ld      l, a 
1071			;                pop     af 
1071			;                ret 
1071			; 
1071			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1071			; the routine get_nibble is used only valid characters are accepted - the  
1071			; input routine only accepts characters 0-9a-f. 
1071			; 
1071 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1072 7e					ld a,(hl) 
1073 23					inc hl 
1074 cd 99 10		                call    nibble2val      ; Get upper nibble 
1077 cb 07		                rlc     a 
1079 cb 07		                rlc     a 
107b cb 07		                rlc     a 
107d cb 07		                rlc     a 
107f 47			                ld      b, a            ; Save upper four bits 
1080 7e					ld a,(hl) 
1081 cd 99 10		                call    nibble2val      ; Get lower nibble 
1084 b0			                or      b               ; Combine both nibbles 
1085 c1			                pop     bc              ; Restore B (and C) 
1086 c9			                ret 
1087			; 
1087			; Get a hexadecimal digit from the serial line. This routine blocks until 
1087			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1087			; to the serial line interface. The lower 4 bits of A contain the value of  
1087			; that particular digit. 
1087			; 
1087			;get_nibble      ld a,(hl)           ; Read a character 
1087			;                call    to_upper        ; Convert to upper case 
1087			;                call    is_hex          ; Was it a hex digit? 
1087			;                jr      nc, get_nibble  ; No, get another character 
1087			 ;               call    nibble2val      ; Convert nibble to value 
1087			 ;               call    print_nibble 
1087			 ;               ret 
1087			; 
1087			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1087			; A valid hexadecimal digit is denoted by a set C flag. 
1087			; 
1087			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1087			;                ret     nc              ; Yes 
1087			;                cp      '0'             ; Less than '0'? 
1087			;                jr      nc, is_hex_1    ; No, continue 
1087			;                ccf                     ; Complement carry (i.e. clear it) 
1087			;                ret 
1087			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1087			;                ret     c               ; Yes 
1087			;                cp      'A'             ; Less than 'A'? 
1087			;                jr      nc, is_hex_2    ; No, continue 
1087			;                ccf                     ; Yes - clear carry and return 
1087			;                ret 
1087			;is_hex_2        scf                     ; Set carry 
1087			;                ret 
1087			; 
1087			; Convert a single character contained in A to upper case: 
1087			; 
1087 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1089 d8			                ret     c 
108a fe 7b		                cp      'z' + 1         ; > 'z'? 
108c d0			                ret     nc              ; Nothing to do, either 
108d e6 5f		                and     $5f             ; Convert to upper case 
108f c9			                ret 
1090			 
1090			 
1090			to_lower: 
1090			 
1090			   ; if char is in [A-Z] make it lower case 
1090			 
1090			   ; enter : a = char 
1090			   ; exit  : a = lower case char 
1090			   ; uses  : af 
1090			 
1090 fe 41		   cp 'A' 
1092 d8			   ret c 
1093			    
1093 fe 5b		   cp 'Z'+1 
1095 d0			   ret nc 
1096			    
1096 f6 20		   or $20 
1098 c9			   ret 
1099			 
1099			; 
1099			; Expects a hexadecimal digit (upper case!) in A and returns the 
1099			; corresponding value in A. 
1099			; 
1099 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
109b 38 02		                jr      c, nibble2val_1 ; Yes 
109d d6 07		                sub     7               ; Adjust for A-F 
109f d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
10a1 e6 0f		                and     $f              ; Only return lower 4 bits 
10a3 c9			                ret 
10a4			; 
10a4			; Print_nibble prints a single hex nibble which is contained in the lower  
10a4			; four bits of A: 
10a4			; 
10a4			;print_nibble    push    af              ; We won't destroy the contents of A 
10a4			;                and     $f              ; Just in case... 
10a4			;                add     a, '0'             ; If we have a digit we are done here. 
10a4			;                cp      '9' + 1         ; Is the result > 9? 
10a4			;                jr      c, print_nibble_1 
10a4			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
10a4			;print_nibble_1  call    putc            ; Print the nibble and 
10a4			;                pop     af              ; restore the original value of A 
10a4			;                ret 
10a4			;; 
10a4			;; Send a CR/LF pair: 
10a4			; 
10a4			;crlf            push    af 
10a4			;                ld      a, cr 
10a4			;                call    putc 
10a4			;                ld      a, lf 
10a4			;                call    putc 
10a4			;                pop     af 
10a4			;                ret 
10a4			; 
10a4			; Print_word prints the four hex digits of a word to the serial line. The  
10a4			; word is expected to be in HL. 
10a4			; 
10a4			;print_word      push    hl 
10a4			;                push    af 
10a4			;                ld      a, h 
10a4			;                call    print_byte 
10a4			;                ld      a, l 
10a4			;                call    print_byte 
10a4			;                pop     af 
10a4			;                pop     hl 
10a4			;                ret 
10a4			; 
10a4			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
10a4			; The byte to be printed is expected to be in A. 
10a4			; 
10a4			;print_byte      push    af              ; Save the contents of the registers 
10a4			;                push    bc 
10a4			;                ld      b, a 
10a4			;                rrca 
10a4			;                rrca 
10a4			;                rrca 
10a4			;                rrca 
10a4			;                call    print_nibble    ; Print high nibble 
10a4			;                ld      a, b 
10a4			;                call    print_nibble    ; Print low nibble 
10a4			;                pop     bc              ; Restore original register contents 
10a4			;                pop     af 
10a4			;                ret 
10a4			 
10a4			 
10a4			 
10a4			 
10a4			 
10a4			fourehexhl:  
10a4 7e				ld a,(hl) 
10a5 cd 53 10			call atohex 
10a8 cb 3f				SRL A 
10aa cb 3f				SRL A 
10ac cb 3f				SRL A 
10ae cb 3f				SRL A 
10b0 47				ld b, a 
10b1 23				inc hl 
10b2 7e				ld a,(hl) 
10b3 23				inc hl 
10b4 cd 53 10			call atohex 
10b7 80				add b 
10b8 57				ld d,a 
10b9 7e				ld a,(hl) 
10ba cd 53 10			call atohex 
10bd cb 3f				SRL A 
10bf cb 3f				SRL A 
10c1 cb 3f				SRL A 
10c3 cb 3f				SRL A 
10c5 47				ld b, a 
10c6 23				inc hl 
10c7 7e				ld a,(hl) 
10c8 23				inc hl 
10c9 cd 53 10			call atohex 
10cc 80				add b 
10cd 5f				ld e, a 
10ce d5				push de 
10cf e1				pop hl 
10d0 c9				ret 
10d1			 
10d1			; pass hl. returns z set if the byte at hl is a digit 
10d1			;isdigithl:  
10d1			;	push bc 
10d1			;	ld a,(hl) 
10d1			;	cp ':' 
10d1			;	jr nc, .isdf 		; > 
10d1			;	cp '0' 
10d1			;	jr c, .isdf		; < 
10d1			; 
10d1			;	; TODO find a better way to set z 
10d1			; 
10d1			;	ld b,a 
10d1			;	cp b 
10d1			;	pop bc 
10d1			;	ret 
10d1			; 
10d1			;.isdf:	; not digit so clear z 
10d1			; 
10d1			;	; TODO find a better way to unset z 
10d1			; 
10d1			;	ld b,a 
10d1			;	inc b 
10d1			;	cp b 
10d1			; 
10d1			;	pop bc 
10d1			;	ret 
10d1				 
10d1				 
10d1			 
10d1			 
10d1			; pass hl as the four byte address to load 
10d1			 
10d1			get_word_hl:  
10d1 e5				push hl 
10d2 cd 71 10			call get_byte 
10d5				 
10d5 47				ld b, a 
10d6			 
10d6 e1				pop hl 
10d7 23				inc hl 
10d8 23				inc hl 
10d9			 
10d9			; TODO not able to handle a-f  
10d9 7e				ld a,(hl) 
10da			;	;cp ':' 
10da			;	cp 'g' 
10da			;	jr nc, .single_byte_hl 		; > 
10da			;	cp 'G' 
10da			;	jr nc, .single_byte_hl 		; > 
10da			;	cp '0' 
10da			;	jr c, .single_byte_hl		; < 
10da			 
10da				;call isdigithl 
10da fe 00			cp 0 
10dc 28 06			jr z, .single_byte_hl 
10de			 
10de			.getwhln:   ; hex word so get next byte 
10de			 
10de cd 71 10			call get_byte 
10e1 6f				ld l, a 
10e2 60				ld h,b 
10e3 c9				ret 
10e4 68			.single_byte_hl:   ld l,b 
10e5 26 00				ld h,0 
10e7 c9					ret 
10e8			 
10e8			 
10e8			 
10e8			 
10e8 21 d4 19			ld hl,asc+1 
10eb			;	ld a, (hl) 
10eb			;	call nibble2val 
10eb cd 71 10			call get_byte 
10ee			 
10ee			;	call fourehexhl 
10ee 32 d7 ef			ld (scratch+52),a 
10f1				 
10f1 21 d5 ef			ld hl,scratch+50 
10f4 22 c6 f2			ld (os_cur_ptr),hl 
10f7			 
10f7 c9				ret 
10f8			 
10f8			 
10f8			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10f8			 
10f8			; Decimal Unsigned Version 
10f8			 
10f8			;Number in a to decimal ASCII 
10f8			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10f8			;Example: display a=56 as "056" 
10f8			;input: a = number 
10f8			;Output: a=0,value of a in the screen 
10f8			;destroys af,bc (don't know about hl and de) 
10f8			DispAToASCII: 
10f8 0e 9c			ld	c,-100 
10fa cd 04 11			call	.Na1 
10fd 0e f6			ld	c,-10 
10ff cd 04 11			call	.Na1 
1102 0e ff			ld	c,-1 
1104 06 2f		.Na1:	ld	b,'0'-1 
1106 04			.Na2:	inc	b 
1107 81				add	a,c 
1108 38 fc			jr	c,.Na2 
110a 91				sub	c		;works as add 100/10/1 
110b f5				push af		;safer than ld c,a 
110c 78				ld	a,b		;char is in b 
110d			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
110d f1				pop af		;safer than ld a,c 
110e c9				ret 
110f			 
110f			; Decimal Signed Version 
110f			 
110f			; DispA 
110f			; -------------------------------------------------------------- 
110f			; Converts a signed integer value to a zero-terminated ASCII 
110f			; string representative of that value (using radix 10). 
110f			; -------------------------------------------------------------- 
110f			; INPUTS: 
110f			;     HL     Value to convert (two's complement integer). 
110f			;     DE     Base address of string destination. (pointer). 
110f			; -------------------------------------------------------------- 
110f			; OUTPUTS: 
110f			;     None 
110f			; -------------------------------------------------------------- 
110f			; REGISTERS/MEMORY DESTROYED 
110f			; AF HL 
110f			; -------------------------------------------------------------- 
110f			 
110f			;DispHLToASCII: 
110f			;   push    de 
110f			;   push    bc 
110f			; 
110f			;; Detect sign of HL. 
110f			;    bit    7, h 
110f			;    jr     z, ._DoConvert 
110f			; 
110f			;; HL is negative. Output '-' to string and negate HL. 
110f			;    ld     a, '-' 
110f			;    ld     (de), a 
110f			;    inc    de 
110f			; 
110f			;; Negate HL (using two's complement) 
110f			;    xor    a 
110f			;    sub    l 
110f			;    ld     l, a 
110f			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
110f			;    sbc    a, h 
110f			;    ld     h, a 
110f			; 
110f			;; Convert HL to digit characters 
110f			;._DoConvert: 
110f			;    ld     b, 0     ; B will count character length of number 
110f			;-   ld     a, 10 
110f			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
110f			;    push   af 
110f			;    inc    b 
110f			;    ld     a, h 
110f			;    or     l 
110f			;    jr     nz, - 
110f			; 
110f			;; Retrieve digits from stack 
110f			;-   pop    af 
110f			;    or     $30 
110f			;    ld     (de), a 
110f			;    inc    de 
110f			;    djnz   - 
110f			; 
110f			;; Terminate string with NULL 
110f			;    xor    a 
110f			;    ld     (de), a 
110f			; 
110f			;    pop    bc 
110f			;    pop    de 
110f			;    ret 
110f			 
110f			;Comments 
110f			; 
110f			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
110f			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
110f			;    Note that the output string will not be fixed-width. 
110f			; 
110f			;Example Usage 
110f			; 
110f			;    ld    hl, -1004 
110f			;    ld    de, OP1 
110f			;    call  DispA 
110f			;    ld    hl, OP1 
110f			;    syscall  PutS 
110f			 
110f			 
110f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
110f			 
110f			 
110f			;Converts an ASCII string to an unsigned 16-bit integer 
110f			;Quits when it reaches a non-decimal digit 
110f			 
110f			string_to_uint16: 
110f			atoui_16: 
110f			;Input: 
110f			;     DE points to the string 
110f			;Outputs: 
110f			;     HL is the result 
110f			;     A is the 8-bit value of the number 
110f			;     DE points to the byte after the number 
110f			;Destroys: 
110f			;     BC 
110f			;       if the string is non-empty, BC is HL/10 
110f			;Size:  24 bytes 
110f			;Speed: 42+d(104+{0,9}) 
110f			;       d is the number of digits in the number 
110f			;       max is 640 cycles for a 5 digit number 
110f			;Assuming no leading zeros: 
110f			;1 digit:  146cc 
110f			;2 digit:  250cc 
110f			;3 digit:  354cc or 363cc (avg: 354.126cc) 
110f			;4 digit:  458cc or 467cc (avg: 458.27cc) 
110f			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
110f			;avg: 544.81158447265625cc (544+13297/16384) 
110f			;=============================================================== 
110f 21 00 00		  ld hl,0 
1112			.u16a: 
1112 1a			  ld a,(de) 
1113 d6 30		  sub 30h 
1115 fe 0a		  cp 10 
1117 d0			  ret nc 
1118 13			  inc de 
1119 44			  ld b,h 
111a 4d			  ld c,l 
111b 29			  add hl,hl 
111c 29			  add hl,hl 
111d 09			  add hl,bc 
111e 29			  add hl,hl 
111f 85			  add a,l 
1120 6f			  ld l,a 
1121 30 ef		  jr nc,.u16a 
1123 24			  inc h 
1124 c3 12 11		  jp .u16a 
1127			 
1127			 
1127			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1127			 
1127			;written by Zeda 
1127			;Converts a 16-bit unsigned integer to an ASCII string. 
1127			 
1127			uitoa_16: 
1127			;Input: 
1127			;   DE is the number to convert 
1127			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1127			;Output: 
1127			;   HL points to the null-terminated ASCII string 
1127			;      NOTE: This isn't necessarily the same as the input HL. 
1127 d5			  push de 
1128 c5			  push bc 
1129 f5			  push af 
112a eb			  ex de,hl 
112b			 
112b 01 f0 d8		  ld bc,-10000 
112e 3e 2f		  ld a,'0'-1 
1130 3c			  inc a 
1131 09			  add hl,bc  
1132 38 fc		   jr c,$-2 
1134 12			  ld (de),a 
1135 13			  inc de 
1136			 
1136 01 e8 03		  ld bc,1000 
1139 3e 3a		  ld a,'9'+1 
113b 3d			  dec a  
113c 09			  add hl,bc  
113d 30 fc		   jr nc,$-2 
113f 12			  ld (de),a 
1140 13			  inc de 
1141			 
1141 01 9c ff		  ld bc,-100 
1144 3e 2f		  ld a,'0'-1 
1146 3c			  inc a  
1147 09			  add hl,bc  
1148 38 fc		   jr c,$-2 
114a 12			  ld (de),a 
114b 13			  inc de 
114c			 
114c 7d			  ld a,l 
114d 26 3a		  ld h,'9'+1 
114f 25			  dec h  
1150 c6 0a		  add a,10  
1152 30 fb		   jr nc,$-3 
1154 c6 30		  add a,'0' 
1156 eb			  ex de,hl 
1157 72			  ld (hl),d 
1158 23			  inc hl 
1159 77			  ld (hl),a 
115a 23			  inc hl 
115b 36 00		  ld (hl),0 
115d			 
115d			;Now strip the leading zeros 
115d 0e fa		  ld c,-6 
115f 09			  add hl,bc 
1160 3e 30		  ld a,'0' 
1162 23			  inc hl  
1163 be			  cp (hl)  
1164 28 fc		  jr z,$-2 
1166			 
1166			;Make sure that the string is non-empty! 
1166 7e			  ld a,(hl) 
1167 b7			  or a 
1168 20 01		  jr nz,.atoub 
116a 2b			  dec hl 
116b			.atoub: 
116b			 
116b f1			  pop af 
116c c1			  pop bc 
116d d1			  pop de 
116e c9			  ret 
116f			 
116f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
116f			 
116f			toUpper: 
116f			;A is the char. 
116f			;If A is a lowercase letter, this sets it to the matching uppercase 
116f			;18cc or 30cc or 41cc 
116f			;avg: 26.75cc 
116f fe 61		  cp 'a' 
1171 d8			  ret c 
1172 fe 7b		  cp 'z'+1 
1174 d0			  ret nc 
1175 d6 20		  sub 'a'-'A' 
1177 c9			  ret 
1178			 
1178			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1178			 
1178			; String Length 
1178			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1178			 
1178			; Get the length of the null-terminated string starting at $8000 hl 
1178			;    LD     HL, $8000 
1178			 
1178			strlenz: 
1178			 
1178 af			    XOR    A               ; Zero is the value we are looking for. 
1179 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
117a 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
117b			                           ; 65, 536 bytes (the entire addressable memory space). 
117b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
117d			 
117d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
117d 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
117e 6f			    LD     L, A             ; number of bytes 
117f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1181 2b			    DEC    HL              ; Compensate for null. 
1182 c9				ret 
1183			 
1183			; Get the length of the A terminated string starting at $8000 hl 
1183			;    LD     HL, $8000 
1183			 
1183			strlent: 
1183			 
1183			                  ; A is the value we are looking for. 
1183 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1185 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1187			                           ; 65, 536 bytes (the entire addressable memory space). 
1187 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1189			 
1189			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1189 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
118b 2e 00		    LD     L, 0             ; number of bytes 
118d ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
118f 2b			    DEC    HL              ; Compensate for null. 
1190 c9				ret 
1191			 
1191			 
1191			;Comparing Strings 
1191			 
1191			;IN    HL     Address of string1. 
1191			;      DE     Address of string2. 
1191			 
1191			; doc given but wrong??? 
1191			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1191			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1191			; tested 
1191			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1191			 
1191			strcmp_old: 
1191 e5			    PUSH   HL 
1192 d5			    PUSH   DE 
1193			 
1193 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1194 be			    CP     (HL)            ; (want to minimize work). 
1195 38 01		    JR     C, Str1IsBigger 
1197 7e			    LD     A, (HL) 
1198			 
1198			Str1IsBigger: 
1198 4f			    LD     C, A             ; Put length in BC 
1199 06 00		    LD     B, 0 
119b 13			    INC    DE              ; Increment pointers to meat of string. 
119c 23			    INC    HL 
119d			 
119d			CmpLoop: 
119d 1a			    LD     A, (DE)          ; Compare bytes. 
119e ed a1		    CPI 
11a0 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
11a2 13			    INC    DE              ; Update pointer. 
11a3 ea 9d 11		    JP     PE, CmpLoop 
11a6			 
11a6 d1			    POP    DE 
11a7 e1			    POP    HL 
11a8 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
11a9 be			    CP     (HL) 
11aa c9			    RET 
11ab			 
11ab			NoMatch: 
11ab 2b			    DEC    HL 
11ac be			    CP     (HL)            ; Compare again to affect carry. 
11ad d1			    POP    DE 
11ae e1			    POP    HL 
11af c9			    RET 
11b0			 
11b0			;; test strmp 
11b0			; 
11b0			;ld de, .str1 
11b0			;ld hl, .str2 
11b0			;call strcmp 
11b0			;jr z, .z1 
11b0			;;this 
11b0			;	if DEBUG_FORTH_WORDS 
11b0			;		DMARK "NZ1" 
11b0			;		CALLMONITOR 
11b0			;	endif 
11b0			;.z1: 
11b0			; 
11b0			;	if DEBUG_FORTH_WORDS 
11b0			;		DMARK "ZZ1" 
11b0			;		CALLMONITOR 
11b0			;	endif 
11b0			; 
11b0			;ld de, .str1 
11b0			;ld hl, .str1 
11b0			;call strcmp 
11b0			;jr z, .z2 
11b0			;;this 
11b0			;	if DEBUG_FORTH_WORDS 
11b0			;		DMARK "NZ2" 
11b0			;		CALLMONITOR 
11b0			;	endif 
11b0			;.z2: 
11b0			; 
11b0			;	if DEBUG_FORTH_WORDS 
11b0			;		DMARK "ZZ2" 
11b0			;		CALLMONITOR 
11b0			;	endif 
11b0			; 
11b0			;ld de, .str1 
11b0			;ld hl, .str2 
11b0			;call strcmp 
11b0			;jr c, .c1 
11b0			; 
11b0			;	if DEBUG_FORTH_WORDS 
11b0			;		DMARK "Nc1" 
11b0			;		CALLMONITOR 
11b0			;	endif 
11b0			;.c1: 
11b0			;;this 
11b0			;	if DEBUG_FORTH_WORDS 
11b0			;		DMARK "cc1" 
11b0			;		CALLMONITOR 
11b0			;	endif 
11b0			; 
11b0			;ld de, .str1 
11b0			;ld hl, .str1 
11b0			;call strcmp 
11b0			;jr c, .c2 
11b0			;;this 
11b0			;	if DEBUG_FORTH_WORDS 
11b0			;		DMARK "Nc2" 
11b0			;		CALLMONITOR 
11b0			;	endif 
11b0			;.c2: 
11b0			; 
11b0			;	if DEBUG_FORTH_WORDS 
11b0			;		DMARK "cc2" 
11b0			;		CALLMONITOR 
11b0			;	endif 
11b0			;	NEXTW 
11b0			;.str1:   db "string1",0 
11b0			;.str2:   db "string2",0 
11b0			 
11b0			; only care about direct match or not 
11b0			; hl and de strings 
11b0			; zero set if the same 
11b0			 
11b0			strcmp: 
11b0 1a				ld a, (de) 
11b1 be				cp (hl) 
11b2 28 02			jr z, .ssame 
11b4 b7				or a 
11b5 c9				ret 
11b6			 
11b6			.ssame:  
11b6 fe 00			cp 0 
11b8 c8				ret z 
11b9			 
11b9 23				inc hl 
11ba 13				inc de 
11bb 18 f3			jr strcmp 
11bd				 
11bd				 
11bd			 
11bd			 
11bd			 
11bd			 
11bd			; eof 
11bd			 
11bd			 
11bd			 
11bd			 
11bd			 
11bd			 
# End of file firmware_strings.asm
11bd			include "firmware_memory.asm"   ; malloc and free  
11bd			 
11bd			if DEBUG_FORTH_MALLOC_HIGH 
11bd			.mallocsize: db "Wants malloc >256",0 
11bd			.mallocasize: db "MALLOC gives >256",0 
11bd			.malloczero: db "MALLOC gives zero",0 
11bd			 
11bd			malloc_guard_zerolen: 
11bd				push hl 
11bd				push de 
11bd				push af 
11bd			 
11bd				ld de, 0 
11bd			        call cmp16 
11bd				jr nz, .lowalloz 
11bd			 
11bd				push hl 
11bd				push de 
11bd					ld hl, display_fb0 
11bd					ld (display_fb_active), hl 
11bd				call clear_display 
11bd				ld a, 0 
11bd				ld de, .malloczero 
11bd				call str_at_display 
11bd				call update_display 
11bd				call delay1s 
11bd				call delay1s 
11bd				ld a, 0 
11bd				ld (os_view_disable), a 
11bd			 
11bd				pop de 
11bd				pop hl 
11bd			 
11bd				 
11bd			 
11bd				CALLMONITOR 
11bd			.lowalloz: 
11bd			 
11bd			 
11bd				pop af 
11bd				pop de 
11bd				pop hl 
11bd			ret 
11bd			 
11bd			malloc_guard_entry: 
11bd				push hl 
11bd				push de 
11bd				push af 
11bd			 
11bd			 	or a      ;clear carry flag 
11bd				push hl 
11bd				ld de, 255 
11bd				sbc hl, de 
11bd				jr c, .lowalloc 
11bd			 
11bd				push de 
11bd					ld hl, display_fb0 
11bd					ld (display_fb_active), hl 
11bd				call clear_display 
11bd				ld a, 0 
11bd				ld de, .mallocsize 
11bd				call str_at_display 
11bd				call update_display 
11bd				call delay1s 
11bd				call delay1s 
11bd				ld a, 0 
11bd				ld (os_view_disable), a 
11bd			 
11bd				pop de 
11bd				pop hl 
11bd			 
11bd				 
11bd			 
11bd				CALLMONITOR 
11bd				jr .lowdone 
11bd			.lowalloc: 
11bd			 
11bd			 
11bd				pop hl 
11bd			.lowdone:	pop af 
11bd				pop de 
11bd				pop hl 
11bd			ret 
11bd			 
11bd			malloc_guard_exit: 
11bd				push hl 
11bd				push de 
11bd				push af 
11bd			 
11bd			 	or a      ;clear carry flag 
11bd				push hl 
11bd				ld de, 255 
11bd				sbc hl, de 
11bd				jr c, .lowallocx 
11bd			 
11bd				push de 
11bd					ld hl, display_fb0 
11bd					ld (display_fb_active), hl 
11bd				call clear_display 
11bd				ld a, 0 
11bd				ld de, .mallocasize 
11bd				call str_at_display 
11bd				call update_display 
11bd				call delay1s 
11bd				call delay1s 
11bd				ld a, 0 
11bd				ld (os_view_disable), a 
11bd				pop de 
11bd				pop hl 
11bd			 
11bd				CALLMONITOR 
11bd				jr .lowdonex 
11bd			.lowallocx: 
11bd			 
11bd				pop hl 
11bd			.lowdonex:	pop af 
11bd				pop de 
11bd				pop hl 
11bd			ret 
11bd			endif 
11bd			 
11bd			if MALLOC_2 
11bd			; Z80 Malloc and Free Functions 
11bd			 
11bd			; Malloc Function: 
11bd			; Input: 
11bd			;   HL: Size of block to allocate 
11bd			; Output: 
11bd			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11bd			 
11bd			malloc: 
11bd				 
11bd			if DEBUG_FORTH_MALLOC_HIGH 
11bd			call malloc_guard_entry 
11bd			endif 
11bd			 
11bd			 
11bd			 
11bd			 
11bd					if DEBUG_FORTH_MALLOC 
11bd						DMARK "mal" 
11bd						CALLMONITOR 
11bd					endif 
11bd			    push af            ; Save AF register 
11bd			    ld a, l            ; Load low byte of size into A 
11bd			    or h               ; Check if size is zero 
11bd			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11bd			 
11bd			    ; Allocate memory 
11bd			    ld hl, (heap_start) ; Load start of heap into HL 
11bd					if DEBUG_FORTH_MALLOC 
11bd						DMARK "ma1" 
11bd						CALLMONITOR 
11bd					endif 
11bd			    call malloc_internal ; Call internal malloc function 
11bd			    pop af             ; Restore AF register 
11bd			if DEBUG_FORTH_MALLOC_HIGH 
11bd			call malloc_guard_exit 
11bd			call malloc_guard_zerolen 
11bd			endif 
11bd			    ret                ; Return 
11bd			 
11bd			; Free Function: 
11bd			; Input: 
11bd			;   HL: Pointer to memory block to free 
11bd			; Output: 
11bd			;   None 
11bd			 
11bd			free: 
11bd			    push af            ; Save AF register 
11bd			    ld a, l            ; Load low byte of pointer into A 
11bd			    or h               ; Check if pointer is NULL 
11bd			    jp z, free_exit    ; If pointer is NULL, exit 
11bd			 
11bd			    ; Free memory 
11bd			    ld hl, (heap_start) ; Load start of heap into HL 
11bd			    call free_internal  ; Call internal free function 
11bd			    pop af             ; Restore AF register 
11bd			    ret                ; Return 
11bd			 
11bd			; Internal Malloc Function: 
11bd			; Input: 
11bd			;   HL: Size of block to allocate 
11bd			; Output: 
11bd			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11bd			 
11bd			malloc_internal: 
11bd			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11bd			    add hl, bc         ; Add management overhead to requested size 
11bd			    ex de, hl          ; Save total size in DE, and keep it in HL 
11bd					if DEBUG_FORTH_MALLOC 
11bd						DMARK "ma2" 
11bd						CALLMONITOR 
11bd					endif 
11bd			 
11bd			    ; Search for free memory block 
11bd			    ld de, (heap_end)  ; Load end of heap into DE 
11bd			    ld bc, 0           ; Initialize counter 
11bd			 
11bd					if DEBUG_FORTH_MALLOC 
11bd						DMARK "ma2" 
11bd						CALLMONITOR 
11bd					endif 
11bd			malloc_search_loop: 
11bd			    ; Check if current block is free 
11bd			    ld a, (hl)         ; Load current block's status (free or used) 
11bd			    cp 0               ; Compare with zero (free) 
11bd			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11bd			 
11bd			    ; Check if current block is large enough 
11bd			    ld a, (hl+1)       ; Load high byte of block size 
11bd			    cp l               ; Compare with low byte of requested size 
11bd			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11bd			 
11bd			    ld a, (hl+2)       ; Load low byte of block size 
11bd			    cp h               ; Compare with high byte of requested size 
11bd			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11bd			 
11bd			    ; Mark block as used 
11bd			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11bd			 
11bd			    ; Calculate remaining space in block 
11bd			    ld bc, 0           ; Clear BC 
11bd			    add hl, bc         ; Increment HL to point to start of data block 
11bd			    add hl, de         ; HL = HL + DE (total size) 
11bd			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11bd			    add hl, bc         ; Add management overhead to start of data block 
11bd			 
11bd			    ; Save pointer to allocated block in HL 
11bd			if DEBUG_FORTH_MALLOC_HIGH 
11bd						DMARK "ma5" 
11bd			call malloc_guard_exit 
11bd			call malloc_guard_zerolen 
11bd			endif 
11bd			    ret 
11bd			 
11bd			malloc_skip_block_check: 
11bd			    ; Move to the next block 
11bd			    ld bc, 3           ; Size of management overhead 
11bd			    add hl, bc         ; Move to the next block 
11bd			    inc de             ; Increment counter 
11bd			 
11bd			    ; Check if we have reached the end of heap 
11bd			    ld a, e            ; Load low byte of heap end address 
11bd			    cp (hl)            ; Compare with low byte of current address 
11bd			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11bd			    ld a, d            ; Load high byte of heap end address 
11bd			    cp 0               ; Check if it's zero (end of memory) 
11bd			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11bd			 
11bd			    ; If we reached here, allocation failed 
11bd			    xor a              ; Set result to NULL 
11bd			if DEBUG_FORTH_MALLOC_HIGH 
11bd						DMARK "ma6" 
11bd			call malloc_guard_exit 
11bd			call malloc_guard_zerolen 
11bd			endif 
11bd			    ret 
11bd			malloc_exit: 
11bd			if DEBUG_FORTH_MALLOC_HIGH 
11bd						DMARK "ma7" 
11bd			call malloc_guard_exit 
11bd			call malloc_guard_zerolen 
11bd			endif 
11bd			    ret 
11bd			 
11bd			; Internal Free Function: 
11bd			; Input: 
11bd			;   HL: Pointer to memory block to free 
11bd			; Output: 
11bd			;   None 
11bd			 
11bd			free_internal: 
11bd			    ld de, (heap_start) ; Load start of heap into DE 
11bd			    ld bc, 0            ; Initialize counter 
11bd			 
11bd			free_search_loop: 
11bd			    ; Check if current block contains the pointer 
11bd			    ld a, l             ; Load low byte of pointer 
11bd			    cp (hl+1)           ; Compare with high byte of current block's address 
11bd			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11bd			    ld a, h             ; Load high byte of pointer 
11bd			    cp (hl+2)           ; Compare with low byte of current block's address 
11bd			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11bd			 
11bd			    ; Mark block as free 
11bd			    ld (hl), 0          ; Set status byte to indicate free block 
11bd			    ret                 ; Return 
11bd			 
11bd			free_skip_block_check: 
11bd			    ; Move to the next block 
11bd			    ld bc, 3            ; Size of management overhead 
11bd			    add hl, bc          ; Move to the next block 
11bd			    inc de              ; Increment counter 
11bd			 
11bd			    ; Check if we have reached the end of heap 
11bd			    ld a, e             ; Load low byte of heap end address 
11bd			    cp (hl)             ; Compare with low byte of current address 
11bd			    jr nz, free_search_loop  ; If not equal, continue searching 
11bd			    ld a, d             ; Load high byte of heap end address 
11bd			    cp 0                ; Check if it's zero (end of memory) 
11bd			    jr nz, free_search_loop  ; If not zero, continue searching 
11bd			 
11bd			    ; If we reached here, pointer is not found in heap 
11bd			    ret 
11bd			 
11bd			free_exit: 
11bd			    ret                 ; Return 
11bd			 
11bd			; Define heap start and end addresses 
11bd			;heap_start:    .dw 0xC000   ; Start of heap 
11bd			;heap_end:      .dw 0xE000   ; End of heap 
11bd			 
11bd			endif 
11bd			 
11bd			 
11bd			if MALLOC_1 
11bd			 
11bd			 
11bd			 
11bd			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11bd			 
11bd			;moved to firmware.asm 
11bd			;heap_start        .equ  0x9000      ; Starting address of heap 
11bd			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11bd			 
11bd			;      .org 0 
11bd			;      jp    main 
11bd			 
11bd			 
11bd			;      .org  0x100 
11bd			;main: 
11bd			;      ld    HL, 0x8100 
11bd			;      ld    SP, HL 
11bd			; 
11bd			;      call  heap_init 
11bd			; 
11bd			;      ; Make some allocations 
11bd			;      ld    HL, 12 
11bd			;      call  malloc            ; Allocates 0x9004 
11bd			; 
11bd			;      ld    HL, 12 
11bd			;      call  malloc            ; Allocates 0x9014 
11bd			; 
11bd			;      ld    HL, 12 
11bd			;      call  malloc            ; Allocates 0x9024 
11bd			; 
11bd			;      ; Free some allocations 
11bd			;      ld    HL, 0x9014 
11bd			;      call  free 
11bd			; 
11bd			;      ld    HL, 0x9004 
11bd			;      call  free 
11bd			; 
11bd			;      ld    HL, 0x9024 
11bd			;      call  free 
11bd			; 
11bd			; 
11bd			;      halt 
11bd			 
11bd			 
11bd			;------------------------------------------------------------------------------ 
11bd			;     heap_init                                                               : 
11bd			;                                                                             : 
11bd			; Description                                                                 : 
11bd			;     Initialise the heap and make it ready for malloc and free operations.   : 
11bd			;                                                                             : 
11bd			;     The heap is maintained as a linked list, starting with an initial       : 
11bd			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11bd			;     the first free block in the heap. Each block then points to the next    : 
11bd			;     free block within the heap, and the free list ends at the first block   : 
11bd			;     with a null pointer to the next free block.                             : 
11bd			;                                                                             : 
11bd			; Parameters                                                                  : 
11bd			;     Inputs are compile-time only. Two defines which specify the starting    : 
11bd			;     address of the heap and its size are required, along with a memory      : 
11bd			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11bd			;     principally stores a pointer to the first free block in the heap.       : 
11bd			;                                                                             : 
11bd			; Returns                                                                     : 
11bd			;     Nothing                                                                 : 
11bd			;------------------------------------------------------------------------------ 
11bd			heap_init: 
11bd e5			      push  HL 
11be			 
11be			      ; Initialise free list struct 
11be 21 0e 80		      ld    HL, heap_start 
11c1 22 0a 80		      ld    (free_list), HL 
11c4 21 00 00		      ld    HL, 0 
11c7 22 0c 80		      ld    (free_list+2), HL 
11ca			 
11ca			      ; Insert first free block at bottom of heap, consumes entire heap 
11ca 21 0a 80		      ld    HL, heap_start+heap_size-4 
11cd 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11d0 21 fc ff		      ld    HL, heap_size-4 
11d3 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11d6			 
11d6			      ; Insert end of free list block at top of heap - two null words will 
11d6			      ; terminate the free list 
11d6 21 00 00		      ld    HL, 0 
11d9 22 0c 80		      ld    (heap_start+heap_size-2), HL 
11dc 22 0a 80		      ld    (heap_start+heap_size-4), HL 
11df			 
11df e1			      pop   HL 
11e0			 
11e0 c9			      ret 
11e1			 
11e1			 
11e1			;------------------------------------------------------------------------------ 
11e1			;     malloc                                                                  : 
11e1			;                                                                             : 
11e1			; Description                                                                 : 
11e1			;     Allocates the wanted space from the heap and returns the address of the : 
11e1			;     first useable byte of the allocation.                                   : 
11e1			;                                                                             : 
11e1			;     Allocations can happen in one of two ways:                              : 
11e1			;                                                                             : 
11e1			;     1. A free block may be found which is the exact size wanted. In this    : 
11e1			;        case the block is removed from the free list and retuedn to the      : 
11e1			;        caller.                                                              : 
11e1			;     2. A free block may be found which is larger than the size wanted. In   : 
11e1			;        this case, the larger block is split into two. The first portion of  : 
11e1			;        this block will become the requested space by the malloc call and    : 
11e1			;        is returned to the caller. The second portion becomes a new free     : 
11e1			;        block, and the free list is adjusted to maintain continuity via this : 
11e1			;        newly created block.                                                 : 
11e1			;                                                                             : 
11e1			;     malloc does not set any initial value in the allocated space, the       : 
11e1			;     caller is required to do this as required.                              : 
11e1			;                                                                             : 
11e1			;     This implementation of malloc uses the stack exclusively, and is        : 
11e1			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11e1			;     advisable to disable interrupts before calling malloc, and recommended  : 
11e1			;     to avoid the use of malloc inside ISRs in general.                      : 
11e1			;                                                                             : 
11e1			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11e1			;                                                                             : 
11e1			; Parameters                                                                  : 
11e1			;     HL  Number of bytes wanted                                              : 
11e1			;                                                                             : 
11e1			; Returns                                                                     : 
11e1			;     HL  Address of the first useable byte of the allocation                 : 
11e1			;                                                                             : 
11e1			; Flags                                                                       : 
11e1			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11e1			;                                                                             : 
11e1			; Stack frame                                                                 : 
11e1			;       |             |                                                       : 
11e1			;       +-------------+                                                       : 
11e1			;       |     BC      |                                                       : 
11e1			;       +-------------+                                                       : 
11e1			;       |     DE      |                                                       : 
11e1			;       +-------------+                                                       : 
11e1			;       |     IX      |                                                       : 
11e1			;       +-------------+                                                       : 
11e1			;       |  prev_free  |                                                       : 
11e1			;   +4  +-------------+                                                       : 
11e1			;       |  this_free  |                                                       : 
11e1			;   +2  +-------------+                                                       : 
11e1			;       |  next_free  |                                                       : 
11e1			;   +0  +-------------+                                                       : 
11e1			;       |             |                                                       : 
11e1			;                                                                             : 
11e1			;------------------------------------------------------------------------------ 
11e1			 
11e1			 
11e1			;malloc: 
11e1			; 
11e1			;	SAVESP ON 1 
11e1			; 
11e1			;	call malloc_code 
11e1			; 
11e1			;	CHECKSP ON 1 
11e1			;	ret 
11e1			 
11e1			 
11e1			malloc: 
11e1 c5			      push  BC 
11e2 d5			      push  DE 
11e3 dd e5		      push  IX 
11e5			if DEBUG_FORTH_MALLOC_HIGH 
11e5			call malloc_guard_entry 
11e5			endif 
11e5			 
11e5					if DEBUG_FORTH_MALLOC 
11e5						DMARK "mal" 
11e5						CALLMONITOR 
11e5					endif 
11e5 7c			      ld    A, H                    ; Exit if no space requested 
11e6 b5			      or    L 
11e7 ca a6 12		      jp    Z, malloc_early_exit 
11ea			 
11ea			;inc hl 
11ea			;inc hl 
11ea			;inc hl 
11ea			; 
11ea			;inc hl 
11ea			;inc hl 
11ea			;inc hl 
11ea			;inc hl 
11ea			;inc hl 
11ea			;inc hl 
11ea			;inc hl 
11ea			;inc hl 
11ea			;inc hl 
11ea			 
11ea			 
11ea			 
11ea			 
11ea					if DEBUG_FORTH_MALLOC 
11ea						DMARK "maA" 
11ea						CALLMONITOR 
11ea					endif 
11ea			      ; Set up stack frame 
11ea eb			      ex    DE, HL 
11eb 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11ee 39			      add   HL, SP 
11ef f9			      ld    SP, HL 
11f0 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11f4 dd 39		      add   IX, SP 
11f6			 
11f6			      ; Setup initial state 
11f6 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11f9 19			      add   HL, DE 
11fa			 
11fa 44			      ld    B, H                    ; Move want to BC 
11fb 4d			      ld    C, L 
11fc			 
11fc 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ff dd 75 04		      ld    (IX+4), L 
1202 dd 74 05		      ld    (IX+5), H 
1205			 
1205 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1206 23			      inc   HL 
1207 56			      ld    D, (HL) 
1208 dd 73 02		      ld    (IX+2), E 
120b dd 72 03		      ld    (IX+3), D 
120e eb			      ex    DE, HL                  ; this_free ptr into HL 
120f			 
120f					if DEBUG_FORTH_MALLOC 
120f						DMARK "maB" 
120f						CALLMONITOR 
120f					endif 
120f			      ; Loop through free block list to find some space 
120f			malloc_find_space: 
120f 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1210 23			      inc   HL 
1211 56			      ld    D, (HL) 
1212			 
1212 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1213 b3			      or    E 
1214 ca a0 12		      jp    Z, malloc_no_space 
1217			 
1217 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
121a dd 72 01		      ld    (IX+1), D 
121d			 
121d			      ; Does this block have enough space to make the allocation? 
121d 23			      inc   HL                      ; Load free block size into DE 
121e 5e			      ld    E, (HL) 
121f 23			      inc   HL 
1220 56			      ld    D, (HL) 
1221			 
1221 eb			      ex    DE, HL                  ; Check size of block against want 
1222 b7			      or    A                       ; Ensure carry flag clear 
1223 ed 42		      sbc   HL, BC 
1225 e5			      push  HL                      ; Store the result for later (new block size) 
1226			 
1226 ca 75 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1229 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
122b			 
122b			      ; this_free block is not big enough, setup ptrs to test next free block 
122b e1			      pop   HL                      ; Discard previous result 
122c			 
122c dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
122f dd 66 03		      ld    H, (IX+3) 
1232 dd 75 04		      ld    (IX+4), L 
1235 dd 74 05		      ld    (IX+5), H 
1238			 
1238 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
123b dd 66 01		      ld    H, (IX+1) 
123e dd 75 02		      ld    (IX+2), L 
1241 dd 74 03		      ld    (IX+3), H 
1244			 
1244					if DEBUG_FORTH_MALLOC 
1244						DMARK "MA>" 
1244						CALLMONITOR 
1244					endif 
1244 18 c9		      jr    malloc_find_space 
1246			 
1246			      ; split a bigger block into two - requested size and remaining size 
1246			malloc_alloc_split: 
1246					if DEBUG_FORTH_MALLOC 
1246						DMARK "MAs" 
1246						CALLMONITOR 
1246					endif 
1246 eb			      ex    DE, HL                  ; Calculate address of new free block 
1247 2b			      dec   HL 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 09			      add   HL, BC 
124b			 
124b			      ; Create a new block and point it at next_free 
124b dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
124e dd 56 01		      ld    D, (IX+1) 
1251			 
1251 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1252 23			      inc   HL 
1253 72			      ld    (HL), D 
1254			 
1254 d1			      pop   DE                      ; Store size of new block into new block 
1255 23			      inc   HL 
1256 73			      ld    (HL), E 
1257 23			      inc   HL 
1258 72			      ld    (HL), D 
1259			 
1259			      ; Update this_free ptr to point to new block 
1259 2b			      dec   HL 
125a 2b			      dec   HL 
125b 2b			      dec   HL 
125c			 
125c dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
125f dd 56 03		      ld    D, (IX+3) 
1262			 
1262 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1265 dd 74 03		      ld    (IX+3), H 
1268			 
1268			      ; Modify this_free block to be allocation 
1268 eb			      ex    DE, HL 
1269 af			      xor   A                       ; Null the next block ptr of allocated block 
126a 77			      ld    (HL), A 
126b 23			      inc   HL 
126c 77			      ld    (HL), A 
126d			 
126d 23			      inc   HL                      ; Store want size into allocated block 
126e 71			      ld    (HL), C 
126f 23			      inc   HL 
1270 70			      ld    (HL), B 
1271 23			      inc   HL 
1272 e5			      push  HL                      ; Address of allocation to return 
1273			 
1273 18 19		      jr    malloc_update_links 
1275			 
1275			malloc_alloc_fit: 
1275 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1276			 
1276					if DEBUG_FORTH_MALLOC 
1276						DMARK "MAf" 
1276						CALLMONITOR 
1276					endif 
1276			      ; Modify this_free block to be allocation 
1276 eb			      ex    DE, HL 
1277 2b			      dec   HL 
1278 2b			      dec   HL 
1279 2b			      dec   HL 
127a			 
127a af			      xor   A                       ; Null the next block ptr of allocated block 
127b 77			      ld    (HL), A 
127c 23			      inc   HL 
127d 77			      ld    (HL), A 
127e			 
127e 23			      inc   HL                      ; Store address of allocation to return 
127f 23			      inc   HL 
1280 23			      inc   HL 
1281 e5			      push  HL 
1282			 
1282			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1282 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1285 dd 66 01		      ld    H, (IX+1) 
1288			 
1288 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
128b dd 74 03		      ld    (IX+3), H 
128e			 
128e			 
128e			malloc_update_links: 
128e			      ; Update prev_free ptr to point to this_free 
128e dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1291 dd 66 05		      ld    H, (IX+5) 
1294			 
1294 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1297 dd 56 03		      ld    D, (IX+3) 
129a			 
129a 73			      ld    (HL), E                 ; this_free ptr into prev_free 
129b 23			      inc   HL 
129c 72			      ld    (HL), D 
129d			 
129d					if DEBUG_FORTH_MALLOC 
129d						DMARK "Mul" 
129d						CALLMONITOR 
129d					endif 
129d			      ; Clear the Z flag to indicate successful allocation 
129d 7a			      ld    A, D 
129e b3			      or    E 
129f			 
129f d1			      pop   DE                      ; Address of allocation 
12a0					if DEBUG_FORTH_MALLOC 
12a0						DMARK "MAu" 
12a0						CALLMONITOR 
12a0					endif 
12a0			 
12a0			malloc_no_space: 
12a0 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
12a3 39			      add   HL, SP 
12a4 f9			      ld    SP, HL 
12a5			 
12a5 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
12a6					if DEBUG_FORTH_MALLOC 
12a6						DMARK "MAN" 
12a6						CALLMONITOR 
12a6					endif 
12a6			 
12a6			malloc_early_exit: 
12a6					if DEBUG_FORTH_MALLOC 
12a6						DMARK "MAx" 
12a6						CALLMONITOR 
12a6					endif 
12a6 dd e1		      pop   IX 
12a8 d1			      pop   DE 
12a9 c1			      pop   BC 
12aa			 
12aa			if DEBUG_FORTH_MALLOC_HIGH 
12aa			call malloc_guard_exit 
12aa			call malloc_guard_zerolen 
12aa			endif 
12aa c9			      ret 
12ab			 
12ab			 
12ab			;------------------------------------------------------------------------------ 
12ab			;     free                                                                    : 
12ab			;                                                                             : 
12ab			; Description                                                                 : 
12ab			;     Return the space pointed to by HL to the heap. HL must be an address as : 
12ab			;     returned by malloc, otherwise the behaviour is undefined.               : 
12ab			;                                                                             : 
12ab			;     Where possible, directly adjacent free blocks will be merged together   : 
12ab			;     into larger blocks to help ensure that the heap does not become         : 
12ab			;     excessively fragmented.                                                 : 
12ab			;                                                                             : 
12ab			;     free does not clear or set any other value into the freed space, and    : 
12ab			;     therefore its contents may be visible through subsequent malloc's. The  : 
12ab			;     caller should clear the freed space as required.                        : 
12ab			;                                                                             : 
12ab			;     This implementation of free uses the stack exclusively, and is          : 
12ab			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ab			;     advisable to disable interrupts before calling free, and recommended    : 
12ab			;     to avoid the use of free inside ISRs in general.                        : 
12ab			;                                                                             : 
12ab			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ab			;                                                                             : 
12ab			; Parameters                                                                  : 
12ab			;     HL  Pointer to address of first byte of allocation to be freed          : 
12ab			;                                                                             : 
12ab			; Returns                                                                     : 
12ab			;     Nothing                                                                 : 
12ab			;                                                                             : 
12ab			; Stack frame                                                                 : 
12ab			;       |             |                                                       : 
12ab			;       +-------------+                                                       : 
12ab			;       |     BC      |                                                       : 
12ab			;       +-------------+                                                       : 
12ab			;       |     DE      |                                                       : 
12ab			;       +-------------+                                                       : 
12ab			;       |     IX      |                                                       : 
12ab			;       +-------------+                                                       : 
12ab			;       |  prev_free  |                                                       : 
12ab			;   +2  +-------------+                                                       : 
12ab			;       |  next_free  |                                                       : 
12ab			;   +0  +-------------+                                                       : 
12ab			;       |             |                                                       : 
12ab			;                                                                             : 
12ab			;------------------------------------------------------------------------------ 
12ab			free: 
12ab c5			      push  BC 
12ac d5			      push  DE 
12ad dd e5		      push  IX 
12af			 
12af 7c			      ld    A, H                    ; Exit if ptr is null 
12b0 b5			      or    L 
12b1 ca 75 13		      jp    Z, free_early_exit 
12b4			 
12b4			      ; Set up stack frame 
12b4 eb			      ex    DE, HL 
12b5 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12b8 39			      add   HL, SP 
12b9 f9			      ld    SP, HL 
12ba dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12be dd 39		      add   IX, SP 
12c0			 
12c0			      ; The address in HL points to the start of the useable allocated space, 
12c0			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12c0			      ; address of the block itself. 
12c0 eb			      ex    DE, HL 
12c1 11 fc ff		      ld    DE, -4 
12c4 19			      add   HL, DE 
12c5			 
12c5			      ; An allocated block must have a null next block pointer in it 
12c5 7e			      ld    A, (HL) 
12c6 23			      inc   HL 
12c7 b6			      or    (HL) 
12c8 c2 70 13		      jp    NZ, free_done 
12cb			 
12cb 2b			      dec   HL 
12cc			 
12cc 44			      ld    B, H                    ; Copy HL to BC 
12cd 4d			      ld    C, L 
12ce			 
12ce			      ; Loop through the free list to find the first block with an address 
12ce			      ; higher than the block being freed 
12ce 21 0a 80		      ld    HL, free_list 
12d1			 
12d1			free_find_higher_block: 
12d1 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12d2 23			      inc   HL 
12d3 56			      ld    D, (HL) 
12d4 2b			      dec   HL 
12d5			 
12d5 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12d8 dd 72 01		      ld    (IX+1), D 
12db dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12de dd 74 03		      ld    (IX+3), H 
12e1			 
12e1 78			      ld    A, B                    ; Check if DE is greater than BC 
12e2 ba			      cp    D                       ; Compare MSB first 
12e3 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12e5 30 04		      jr    NC, free_find_higher_block_skip 
12e7 79			      ld    A, C 
12e8 bb			      cp    E                       ; Then compare LSB 
12e9 38 08		      jr    C, free_found_higher_block 
12eb			 
12eb			free_find_higher_block_skip: 
12eb 7a			      ld    A, D                    ; Reached the end of the free list? 
12ec b3			      or    E 
12ed ca 70 13		      jp    Z, free_done 
12f0			 
12f0 eb			      ex    DE, HL 
12f1			 
12f1 18 de		      jr    free_find_higher_block 
12f3			 
12f3			free_found_higher_block: 
12f3			      ; Insert freed block between prev and next free blocks 
12f3 71			      ld    (HL), C                 ; Point prev free block to freed block 
12f4 23			      inc   HL 
12f5 70			      ld    (HL), B 
12f6			 
12f6 60			      ld    H, B                    ; Point freed block at next free block 
12f7 69			      ld    L, C 
12f8 73			      ld    (HL), E 
12f9 23			      inc   HL 
12fa 72			      ld    (HL), D 
12fb			 
12fb			      ; Check if the freed block is adjacent to the next free block 
12fb 23			      inc   HL                      ; Load size of freed block into HL 
12fc 5e			      ld    E, (HL) 
12fd 23			      inc   HL 
12fe 56			      ld    D, (HL) 
12ff eb			      ex    DE, HL 
1300			 
1300 09			      add   HL, BC                  ; Add addr of freed block and its size 
1301			 
1301 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1304 dd 56 01		      ld    D, (IX+1) 
1307			 
1307 b7			      or    A                       ; Clear the carry flag 
1308 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
130a 20 22		      jr    NZ, free_check_adjacent_to_prev 
130c			 
130c			      ; Freed block is adjacent to next, merge into one bigger block 
130c eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
130d 5e			      ld    E, (HL) 
130e 23			      inc   HL 
130f 56			      ld    D, (HL) 
1310 e5			      push  HL                      ; Save ptr to next block for later 
1311			 
1311 60			      ld    H, B                    ; Store ptr from next block into freed block 
1312 69			      ld    L, C 
1313 73			      ld    (HL), E 
1314 23			      inc   HL 
1315 72			      ld    (HL), D 
1316			 
1316 e1			      pop   HL                      ; Restore ptr to next block 
1317 23			      inc   HL                      ; Load size of next block into DE 
1318 5e			      ld    E, (HL) 
1319 23			      inc   HL 
131a 56			      ld    D, (HL) 
131b d5			      push  DE                      ; Save next block size for later 
131c			 
131c 60			      ld    H, B                    ; Load size of freed block into HL 
131d 69			      ld    L, C 
131e 23			      inc   HL 
131f 23			      inc   HL 
1320 5e			      ld    E, (HL) 
1321 23			      inc   HL 
1322 56			      ld    D, (HL) 
1323 eb			      ex    DE, HL 
1324			 
1324 d1			      pop   DE                      ; Restore size of next block 
1325 19			      add   HL, DE                  ; Add sizes of both blocks 
1326 eb			      ex    DE, HL 
1327			 
1327 60			      ld    H, B                    ; Store new bigger size into freed block 
1328 69			      ld    L, C 
1329 23			      inc   HL 
132a 23			      inc   HL 
132b 73			      ld    (HL), E 
132c 23			      inc   HL 
132d 72			      ld    (HL), D 
132e			 
132e			free_check_adjacent_to_prev: 
132e			      ; Check if the freed block is adjacent to the prev free block 
132e dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1331 dd 66 03		      ld    H, (IX+3) 
1334			 
1334 23			      inc   HL                      ; Size of prev free block into DE 
1335 23			      inc   HL 
1336 5e			      ld    E, (HL) 
1337 23			      inc   HL 
1338 56			      ld    D, (HL) 
1339 2b			      dec   HL 
133a 2b			      dec   HL 
133b 2b			      dec   HL 
133c			 
133c 19			      add   HL, DE                  ; Add prev block addr and size 
133d			 
133d b7			      or    A                       ; Clear the carry flag 
133e ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1340 20 2e		      jr    NZ, free_done 
1342			 
1342			      ; Freed block is adjacent to prev, merge into one bigger block 
1342 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1343 69			      ld    L, C 
1344 5e			      ld    E, (HL) 
1345 23			      inc   HL 
1346 56			      ld    D, (HL) 
1347 e5			      push  HL                      ; Save freed block ptr for later 
1348			 
1348 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
134b dd 66 03		      ld    H, (IX+3) 
134e 73			      ld    (HL), E 
134f 23			      inc   HL 
1350 72			      ld    (HL), D 
1351			 
1351 e1			      pop   HL                      ; Restore freed block ptr 
1352 23			      inc   HL                      ; Load size of freed block into DE 
1353 5e			      ld    E, (HL) 
1354 23			      inc   HL 
1355 56			      ld    D, (HL) 
1356 d5			      push  DE                      ; Save freed block size for later 
1357			 
1357 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
135a dd 66 03		      ld    H, (IX+3) 
135d 23			      inc   HL 
135e 23			      inc   HL 
135f 5e			      ld    E, (HL) 
1360 23			      inc   HL 
1361 56			      ld    D, (HL) 
1362			 
1362 e1			      pop   HL                      ; Add sizes of both blocks 
1363 19			      add   HL, DE 
1364 eb			      ex    DE, HL 
1365			 
1365 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1368 dd 66 03		      ld    H, (IX+3) 
136b 23			      inc   HL 
136c 23			      inc   HL 
136d 73			      ld    (HL), E 
136e 23			      inc   HL 
136f 72			      ld    (HL), D 
1370			 
1370			free_done: 
1370 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1373 39			      add   HL, SP 
1374 f9			      ld    SP, HL 
1375			 
1375			free_early_exit: 
1375 dd e1		      pop   IX 
1377 d1			      pop   DE 
1378 c1			      pop   BC 
1379			 
1379 c9			      ret 
137a			 
137a			; moved to firmware.asm 
137a			; 
137a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
137a			;                  .dw   0 
137a			 
137a			 
137a			endif 
137a			 
137a			 
137a			if MALLOC_3 
137a			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
137a			;heap_start        .equ  0x9000      ; Starting address of heap 
137a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
137a			; 
137a			 ;     .org 0 
137a			  ;    jp    main 
137a			; 
137a			; 
137a			 ;     .org  0x100 
137a			;main: 
137a			 ;     ld    HL, 0x8100 
137a			  ;    ld    SP, HL 
137a			; 
137a			;      call  heap_init 
137a			 
137a			      ; Make some allocations 
137a			;      ld    HL, 12 
137a			;      call  malloc            ; Allocates 0x9004 
137a			; 
137a			 ;     ld    HL, 12 
137a			;      call  malloc            ; Allocates 0x9014 
137a			 
137a			;      ld    HL, 12 
137a			;      call  malloc            ; Allocates 0x9024 
137a			 
137a			      ; Free some allocations 
137a			;      ld    HL, 0x9014 
137a			;      call  free 
137a			 
137a			;      ld    HL, 0x9004 
137a			;      call  free 
137a			; 
137a			;      ld    HL, 0x9024 
137a			;      call  free 
137a			 
137a			 
137a			 ;     halt 
137a			 
137a			 
137a			;------------------------------------------------------------------------------ 
137a			;     heap_init                                                               : 
137a			;                                                                             : 
137a			; Description                                                                 : 
137a			;     Initialise the heap and make it ready for malloc and free operations.   : 
137a			;                                                                             : 
137a			;     The heap is maintained as a linked list, starting with an initial       : 
137a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
137a			;     the first free block in the heap. Each block then points to the next    : 
137a			;     free block within the heap, and the free list ends at the first block   : 
137a			;     with a null pointer to the next free block.                             : 
137a			;                                                                             : 
137a			; Parameters                                                                  : 
137a			;     Inputs are compile-time only. Two defines which specify the starting    : 
137a			;     address of the heap and its size are required, along with a memory      : 
137a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
137a			;     principally stores a pointer to the first free block in the heap.       : 
137a			;                                                                             : 
137a			; Returns                                                                     : 
137a			;     Nothing                                                                 : 
137a			;------------------------------------------------------------------------------ 
137a			heap_init: 
137a			      push  HL 
137a			 
137a			      ; Initialise free list struct 
137a			      ld    HL, heap_start 
137a			      ld    (free_list), HL 
137a			      ld    HL, 0 
137a			      ld    (free_list+2), HL 
137a			 
137a			      ; Insert first free block at bottom of heap, consumes entire heap 
137a			      ld    HL, heap_start+heap_size-4 
137a			      ld    (heap_start), HL        ; Next block (end of free list) 
137a			      ld    HL, heap_size-4 
137a			      ld    (heap_start+2), HL      ; Block size 
137a			 
137a			      ; Insert end of free list block at top of heap - two null words will 
137a			      ; terminate the free list 
137a			      ld    HL, 0 
137a			      ld    (heap_start+heap_size-2), HL 
137a			      ld    (heap_start+heap_size-4), HL 
137a			 
137a			      pop   HL 
137a			 
137a			      ret 
137a			 
137a			 
137a			;------------------------------------------------------------------------------ 
137a			;     malloc                                                                  : 
137a			;                                                                             : 
137a			; Description                                                                 : 
137a			;     Allocates the wanted space from the heap and returns the address of the : 
137a			;     first useable byte of the allocation.                                   : 
137a			;                                                                             : 
137a			;     Allocations can happen in one of two ways:                              : 
137a			;                                                                             : 
137a			;     1. A free block may be found which is the exact size wanted. In this    : 
137a			;        case the block is removed from the free list and retuedn to the      : 
137a			;        caller.                                                              : 
137a			;     2. A free block may be found which is larger than the size wanted. In   : 
137a			;        this case, the larger block is split into two. The first portion of  : 
137a			;        this block will become the requested space by the malloc call and    : 
137a			;        is returned to the caller. The second portion becomes a new free     : 
137a			;        block, and the free list is adjusted to maintain continuity via this : 
137a			;        newly created block.                                                 : 
137a			;                                                                             : 
137a			;     malloc does not set any initial value in the allocated space, the       : 
137a			;     caller is required to do this as required.                              : 
137a			;                                                                             : 
137a			;     This implementation of malloc uses the stack exclusively, and is        : 
137a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
137a			;     advisable to disable interrupts before calling malloc, and recommended  : 
137a			;     to avoid the use of malloc inside ISRs in general.                      : 
137a			;                                                                             : 
137a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
137a			;                                                                             : 
137a			; Parameters                                                                  : 
137a			;     HL  Number of bytes wanted                                              : 
137a			;                                                                             : 
137a			; Returns                                                                     : 
137a			;     HL  Address of the first useable byte of the allocation                 : 
137a			;                                                                             : 
137a			; Flags                                                                       : 
137a			;     Z   Set if the allocation did not succeed, clear otherwise              : 
137a			;                                                                             : 
137a			; Stack frame                                                                 : 
137a			;       |             |                                                       : 
137a			;       +-------------+                                                       : 
137a			;       |     BC      |                                                       : 
137a			;       +-------------+                                                       : 
137a			;       |     DE      |                                                       : 
137a			;       +-------------+                                                       : 
137a			;       |     IX      |                                                       : 
137a			;       +-------------+                                                       : 
137a			;       |  prev_free  |                                                       : 
137a			;   +4  +-------------+                                                       : 
137a			;       |  this_free  |                                                       : 
137a			;   +2  +-------------+                                                       : 
137a			;       |  next_free  |                                                       : 
137a			;   +0  +-------------+                                                       : 
137a			;       |             |                                                       : 
137a			;                                                                             : 
137a			;------------------------------------------------------------------------------ 
137a			malloc: 
137a			      push  BC 
137a			      push  DE 
137a			      push  IX 
137a			 
137a			      ld    A, H                    ; Exit if no space requested 
137a			      or    L 
137a			      jp    Z, malloc_early_exit 
137a			 
137a			      ; Set up stack frame 
137a			      ex    DE, HL 
137a			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
137a			      add   HL, SP 
137a			      ld    SP, HL 
137a			      ld    IX, 0                   ; Use IX as a frame pointer 
137a			      add   IX, SP 
137a			 
137a			      ; Setup initial state 
137a			      ld    HL, 4                   ; want must also include space used by block struct 
137a			      add   HL, DE 
137a			 
137a			      ld    B, H                    ; Move want to BC 
137a			      ld    C, L 
137a			 
137a			      ld    HL, free_list           ; Store prev_free ptr to stack 
137a			      ld    (IX+4), L 
137a			      ld    (IX+5), H 
137a			 
137a			      ld    E, (HL)                 ; Store this_free ptr to stack 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			      ld    (IX+2), E 
137a			      ld    (IX+3), D 
137a			      ex    DE, HL                  ; this_free ptr into HL 
137a			 
137a			      ; Loop through free block list to find some space 
137a			malloc_find_space: 
137a			      ld    E, (HL)                 ; Load next_free ptr into DE 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			 
137a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
137a			      or    E 
137a			      jp    Z, malloc_no_space 
137a			 
137a			      ld    (IX+0), E               ; Store next_free ptr to stack 
137a			      ld    (IX+1), D 
137a			 
137a			      ; Does this block have enough space to make the allocation? 
137a			      inc   HL                      ; Load free block size into DE 
137a			      ld    E, (HL) 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			 
137a			      ex    DE, HL                  ; Check size of block against want 
137a			      or    A                       ; Ensure carry flag clear 
137a			      sbc   HL, BC 
137a			      push  HL                      ; Store the result for later (new block size) 
137a			 
137a			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
137a			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
137a			 
137a			      ; this_free block is not big enough, setup ptrs to test next free block 
137a			      pop   HL                      ; Discard previous result 
137a			 
137a			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
137a			      ld    H, (IX+3) 
137a			      ld    (IX+4), L 
137a			      ld    (IX+5), H 
137a			 
137a			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
137a			      ld    H, (IX+1) 
137a			      ld    (IX+2), L 
137a			      ld    (IX+3), H 
137a			 
137a			      jr    malloc_find_space 
137a			 
137a			      ; split a bigger block into two - requested size and remaining size 
137a			malloc_alloc_split: 
137a			      ex    DE, HL                  ; Calculate address of new free block 
137a			      dec   HL 
137a			      dec   HL 
137a			      dec   HL 
137a			      add   HL, BC 
137a			 
137a			      ; Create a new block and point it at next_free 
137a			      ld    E, (IX+0)               ; Load next_free ptr into DE 
137a			      ld    D, (IX+1) 
137a			 
137a			      ld    (HL), E                 ; Store next_free ptr into new block 
137a			      inc   HL 
137a			      ld    (HL), D 
137a			 
137a			      pop   DE                      ; Store size of new block into new block 
137a			      inc   HL 
137a			      ld    (HL), E 
137a			      inc   HL 
137a			      ld    (HL), D 
137a			 
137a			      ; Update this_free ptr to point to new block 
137a			      dec   HL 
137a			      dec   HL 
137a			      dec   HL 
137a			 
137a			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
137a			      ld    D, (IX+3) 
137a			 
137a			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
137a			      ld    (IX+3), H 
137a			 
137a			      ; Modify this_free block to be allocation 
137a			      ex    DE, HL 
137a			      xor   A                       ; Null the next block ptr of allocated block 
137a			      ld    (HL), A 
137a			      inc   HL 
137a			      ld    (HL), A 
137a			 
137a			      inc   HL                      ; Store want size into allocated block 
137a			      ld    (HL), C 
137a			      inc   HL 
137a			      ld    (HL), B 
137a			      inc   HL 
137a			      push  HL                      ; Address of allocation to return 
137a			 
137a			      jr    malloc_update_links 
137a			 
137a			malloc_alloc_fit: 
137a			      pop   HL                      ; Dont need new block size, want is exact fit 
137a			 
137a			      ; Modify this_free block to be allocation 
137a			      ex    DE, HL 
137a			      dec   HL 
137a			      dec   HL 
137a			      dec   HL 
137a			 
137a			      xor   A                       ; Null the next block ptr of allocated block 
137a			      ld    (HL), A 
137a			      inc   HL 
137a			      ld    (HL), A 
137a			 
137a			      inc   HL                      ; Store address of allocation to return 
137a			      inc   HL 
137a			      inc   HL 
137a			      push  HL 
137a			 
137a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
137a			      ld    L, (IX+0)               ; next_free to HL 
137a			      ld    H, (IX+1) 
137a			 
137a			      ld    (IX+2), L               ; HL to this_free 
137a			      ld    (IX+3), H 
137a			 
137a			 
137a			malloc_update_links: 
137a			      ; Update prev_free ptr to point to this_free 
137a			      ld    L, (IX+4)               ; prev_free ptr to HL 
137a			      ld    H, (IX+5) 
137a			 
137a			      ld    E, (IX+2)               ; this_free ptr to DE 
137a			      ld    D, (IX+3) 
137a			 
137a			      ld    (HL), E                 ; this_free ptr into prev_free 
137a			      inc   HL 
137a			      ld    (HL), D 
137a			 
137a			      ; Clear the Z flag to indicate successful allocation 
137a			      ld    A, D 
137a			      or    E 
137a			 
137a			      pop   DE                      ; Address of allocation 
137a			 
137a			malloc_no_space: 
137a			      ld    HL, 6                   ; Clean up stack frame 
137a			      add   HL, SP 
137a			      ld    SP, HL 
137a			 
137a			      ex    DE, HL                  ; Alloc addr into HL for return 
137a			 
137a			malloc_early_exit: 
137a			      pop   IX 
137a			      pop   DE 
137a			      pop   BC 
137a			 
137a			      ret 
137a			 
137a			 
137a			;------------------------------------------------------------------------------ 
137a			;     free                                                                    : 
137a			;                                                                             : 
137a			; Description                                                                 : 
137a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
137a			;     returned by malloc, otherwise the behaviour is undefined.               : 
137a			;                                                                             : 
137a			;     Where possible, directly adjacent free blocks will be merged together   : 
137a			;     into larger blocks to help ensure that the heap does not become         : 
137a			;     excessively fragmented.                                                 : 
137a			;                                                                             : 
137a			;     free does not clear or set any other value into the freed space, and    : 
137a			;     therefore its contents may be visible through subsequent malloc's. The  : 
137a			;     caller should clear the freed space as required.                        : 
137a			;                                                                             : 
137a			;     This implementation of free uses the stack exclusively, and is          : 
137a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
137a			;     advisable to disable interrupts before calling free, and recommended    : 
137a			;     to avoid the use of free inside ISRs in general.                        : 
137a			;                                                                             : 
137a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
137a			;                                                                             : 
137a			; Parameters                                                                  : 
137a			;     HL  Pointer to address of first byte of allocation to be freed          : 
137a			;                                                                             : 
137a			; Returns                                                                     : 
137a			;     Nothing                                                                 : 
137a			;                                                                             : 
137a			; Stack frame                                                                 : 
137a			;       |             |                                                       : 
137a			;       +-------------+                                                       : 
137a			;       |     BC      |                                                       : 
137a			;       +-------------+                                                       : 
137a			;       |     DE      |                                                       : 
137a			;       +-------------+                                                       : 
137a			;       |     IX      |                                                       : 
137a			;       +-------------+                                                       : 
137a			;       |  prev_free  |                                                       : 
137a			;   +2  +-------------+                                                       : 
137a			;       |  next_free  |                                                       : 
137a			;   +0  +-------------+                                                       : 
137a			;       |             |                                                       : 
137a			;                                                                             : 
137a			;------------------------------------------------------------------------------ 
137a			free: 
137a			      push  BC 
137a			      push  DE 
137a			      push  IX 
137a			 
137a			      ld    A, H                    ; Exit if ptr is null 
137a			      or    L 
137a			      jp    Z, free_early_exit 
137a			 
137a			      ; Set up stack frame 
137a			      ex    DE, HL 
137a			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
137a			      add   HL, SP 
137a			      ld    SP, HL 
137a			      ld    IX, 0                   ; Use IX as a frame pointer 
137a			      add   IX, SP 
137a			 
137a			      ; The address in HL points to the start of the useable allocated space, 
137a			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
137a			      ; address of the block itself. 
137a			      ex    DE, HL 
137a			      ld    DE, -4 
137a			      add   HL, DE 
137a			 
137a			      ; An allocated block must have a null next block pointer in it 
137a			      ld    A, (HL) 
137a			      inc   HL 
137a			      or    (HL) 
137a			      jp    NZ, free_done 
137a			 
137a			      dec   HL 
137a			 
137a			      ld    B, H                    ; Copy HL to BC 
137a			      ld    C, L 
137a			 
137a			      ; Loop through the free list to find the first block with an address 
137a			      ; higher than the block being freed 
137a			      ld    HL, free_list 
137a			 
137a			free_find_higher_block: 
137a			      ld    E, (HL)                 ; Load next ptr from free block 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			      dec   HL 
137a			 
137a			      ld    (IX+0), E               ; Save ptr to next free block 
137a			      ld    (IX+1), D 
137a			      ld    (IX+2), L               ; Save ptr to prev free block 
137a			      ld    (IX+3), H 
137a			 
137a			      ld    A, B                    ; Check if DE is greater than BC 
137a			      cp    D                       ; Compare MSB first 
137a			      jr    Z, $+4                  ; MSB the same, compare LSB 
137a			      jr    NC, free_find_higher_block_skip 
137a			      ld    A, C 
137a			      cp    E                       ; Then compare LSB 
137a			      jr    C, free_found_higher_block 
137a			 
137a			free_find_higher_block_skip: 
137a			      ld    A, D                    ; Reached the end of the free list? 
137a			      or    E 
137a			      jp    Z, free_done 
137a			 
137a			      ex    DE, HL 
137a			 
137a			      jr    free_find_higher_block 
137a			 
137a			free_found_higher_block: 
137a			      ; Insert freed block between prev and next free blocks 
137a			      ld    (HL), C                 ; Point prev free block to freed block 
137a			      inc   HL 
137a			      ld    (HL), B 
137a			 
137a			      ld    H, B                    ; Point freed block at next free block 
137a			      ld    L, C 
137a			      ld    (HL), E 
137a			      inc   HL 
137a			      ld    (HL), D 
137a			 
137a			      ; Check if the freed block is adjacent to the next free block 
137a			      inc   HL                      ; Load size of freed block into HL 
137a			      ld    E, (HL) 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			      ex    DE, HL 
137a			 
137a			      add   HL, BC                  ; Add addr of freed block and its size 
137a			 
137a			      ld    E, (IX+0)               ; Load addr of next free block into DE 
137a			      ld    D, (IX+1) 
137a			 
137a			      or    A                       ; Clear the carry flag 
137a			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
137a			      jr    NZ, free_check_adjacent_to_prev 
137a			 
137a			      ; Freed block is adjacent to next, merge into one bigger block 
137a			      ex    DE, HL                  ; Load next ptr from next block into DE 
137a			      ld    E, (HL) 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			      push  HL                      ; Save ptr to next block for later 
137a			 
137a			      ld    H, B                    ; Store ptr from next block into freed block 
137a			      ld    L, C 
137a			      ld    (HL), E 
137a			      inc   HL 
137a			      ld    (HL), D 
137a			 
137a			      pop   HL                      ; Restore ptr to next block 
137a			      inc   HL                      ; Load size of next block into DE 
137a			      ld    E, (HL) 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			      push  DE                      ; Save next block size for later 
137a			 
137a			      ld    H, B                    ; Load size of freed block into HL 
137a			      ld    L, C 
137a			      inc   HL 
137a			      inc   HL 
137a			      ld    E, (HL) 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			      ex    DE, HL 
137a			 
137a			      pop   DE                      ; Restore size of next block 
137a			      add   HL, DE                  ; Add sizes of both blocks 
137a			      ex    DE, HL 
137a			 
137a			      ld    H, B                    ; Store new bigger size into freed block 
137a			      ld    L, C 
137a			      inc   HL 
137a			      inc   HL 
137a			      ld    (HL), E 
137a			      inc   HL 
137a			      ld    (HL), D 
137a			 
137a			free_check_adjacent_to_prev: 
137a			      ; Check if the freed block is adjacent to the prev free block 
137a			      ld    L, (IX+2)               ; Prev free block ptr into HL 
137a			      ld    H, (IX+3) 
137a			 
137a			      inc   HL                      ; Size of prev free block into DE 
137a			      inc   HL 
137a			      ld    E, (HL) 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			      dec   HL 
137a			      dec   HL 
137a			      dec   HL 
137a			 
137a			      add   HL, DE                  ; Add prev block addr and size 
137a			 
137a			      or    A                       ; Clear the carry flag 
137a			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
137a			      jr    NZ, free_done 
137a			 
137a			      ; Freed block is adjacent to prev, merge into one bigger block 
137a			      ld    H, B                    ; Load next ptr from freed block into DE 
137a			      ld    L, C 
137a			      ld    E, (HL) 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			      push  HL                      ; Save freed block ptr for later 
137a			 
137a			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
137a			      ld    H, (IX+3) 
137a			      ld    (HL), E 
137a			      inc   HL 
137a			      ld    (HL), D 
137a			 
137a			      pop   HL                      ; Restore freed block ptr 
137a			      inc   HL                      ; Load size of freed block into DE 
137a			      ld    E, (HL) 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			      push  DE                      ; Save freed block size for later 
137a			 
137a			      ld    L, (IX+2)               ; Load size of prev block into DE 
137a			      ld    H, (IX+3) 
137a			      inc   HL 
137a			      inc   HL 
137a			      ld    E, (HL) 
137a			      inc   HL 
137a			      ld    D, (HL) 
137a			 
137a			      pop   HL                      ; Add sizes of both blocks 
137a			      add   HL, DE 
137a			      ex    DE, HL 
137a			 
137a			      ld    L, (IX+2)               ; Store new bigger size into prev block 
137a			      ld    H, (IX+3) 
137a			      inc   HL 
137a			      inc   HL 
137a			      ld    (HL), E 
137a			      inc   HL 
137a			      ld    (HL), D 
137a			 
137a			free_done: 
137a			      ld    HL, 4                   ; Clean up stack frame 
137a			      add   HL, SP 
137a			      ld    SP, HL 
137a			 
137a			free_early_exit: 
137a			      pop   IX 
137a			      pop   DE 
137a			      pop   BC 
137a			 
137a			      ret 
137a			 
137a			 
137a			;      .org 0x8000 
137a			; 
137a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
137a			 ;                 .dw   0 
137a			 
137a			endif 
137a			 
137a			 
137a			if MALLOC_4 
137a			 
137a			; My memory allocation code. Very very simple.... 
137a			; allocate space under 250 chars 
137a			 
137a			heap_init: 
137a				; init start of heap as zero 
137a				;  
137a			 
137a				ld hl, heap_start 
137a				ld a, 0 
137a				ld (hl), a      ; empty block 
137a				inc hl 
137a				ld a, 0 
137a				ld (hl), a      ; length of block 
137a				; write end of list 
137a				inc hl 
137a				ld a,(hl) 
137a				inc hl 
137a				ld a,(hl) 
137a				 
137a			 
137a				; init some malloc vars 
137a			 
137a				ld hl, 0 
137a				ld (free_list), hl       ; store last malloc location 
137a			 
137a				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
137a				ld a, 0 
137a				ld (hl), a 
137a			 
137a			 
137a				ld hl, heap_start 
137a				;  
137a				  
137a				ret 
137a			 
137a			 
137a			;    free block marker 
137a			;    requested size  
137a			;    pointer to next block 
137a			;    .... 
137a			;    next block marker 
137a			 
137a			 
137a			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
137a			; 
137a			 
137a			 
137a			malloc:  
137a				push de 
137a				push bc 
137a				push af 
137a			 
137a				; hl space required 
137a				 
137a				ld c, l    ; hold space   (TODO only a max of 255) 
137a			 
137a			;	inc c     ; TODO BUG need to fix memory leak on push str 
137a			;	inc c 
137a			;	inc c 
137a			;	inc c 
137a			;	inc c 
137a			;	inc c 
137a			;	inc c 
137a			 
137a			 
137a			 
137a				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
137a			 
137a				ld a, (free_list+3) 
137a				cp 0 
137a				jr z, .contheap 
137a			 
137a				ld hl, (free_list)     ; get last alloc 
137a					if DEBUG_FORTH_MALLOC_INT 
137a						DMARK "mrs" 
137a						CALLMONITOR 
137a					endif 
137a				jr .startalloc 
137a			 
137a			.contheap: 
137a				ld hl, heap_start 
137a			 
137a			.startalloc: 
137a			 
137a					if DEBUG_FORTH_MALLOC_INT 
137a						DMARK "mym" 
137a						CALLMONITOR 
137a					endif 
137a			.findblock: 
137a					if DEBUG_FORTH_MALLOC_INT 
137a						DMARK "mmf" 
137a						CALLMONITOR 
137a					endif 
137a			 
137a				ld a,(hl)  
137a				; if byte is zero then clear to use 
137a			 
137a				cp 0 
137a				jr z, .foundemptyblock 
137a			 
137a				; if byte is not clear 
137a				;     then byte is offset to next block 
137a			 
137a				inc hl 
137a				ld a, (hl) ; get size 
137a			.nextblock:	inc hl 
137a					ld e, (hl) 
137a					inc hl 
137a					ld d, (hl) 
137a					ex de, hl 
137a			;	inc hl  ; move past the store space 
137a			;	inc hl  ; move past zero index  
137a			 
137a				; TODO detect no more space 
137a			 
137a				push hl 
137a				ld de, heap_end 
137a				call cmp16 
137a				pop hl 
137a				jr nc, .nospace 
137a			 
137a				jr .findblock 
137a			 
137a			.nospace: ld hl, 0 
137a				jp .exit 
137a			 
137a			 
137a			.foundemptyblock:	 
137a					if DEBUG_FORTH_MALLOC_INT 
137a						DMARK "mme" 
137a						CALLMONITOR 
137a					endif 
137a			 
137a			; TODO has block enough space if reusing??? 
137a			 
137a				;  
137a			 
137a			; see if this block has been previously used 
137a				inc hl 
137a				ld a, (hl) 
137a				dec hl 
137a				cp 0 
137a				jr z, .newblock 
137a			 
137a					if DEBUG_FORTH_MALLOC_INT 
137a						DMARK "meR" 
137a						CALLMONITOR 
137a					endif 
137a			 
137a			; no reusing previously allocated block 
137a			 
137a			; is it smaller than previously used? 
137a				 
137a				inc hl    ; move to size 
137a				ld a, c 
137a				sub (hl)        ; we want c < (hl) 
137a				dec hl    ; move back to marker 
137a			        jr z, .findblock 
137a			 
137a				; update with the new size which should be lower 
137a			 
137a			        ;inc  hl   ; negate next move. move back to size  
137a			 
137a			.newblock: 
137a				; need to be at marker here 
137a			 
137a					if DEBUG_FORTH_MALLOC_INT 
137a						DMARK "meN" 
137a						CALLMONITOR 
137a					endif 
137a			 
137a			 
137a				ld a, c 
137a			 
137a				ld (free_list+3), a	 ; flag resume from last malloc  
137a				ld (free_list), hl    ; save out last location 
137a			 
137a			 
137a				;inc a     ; space for length byte 
137a				ld (hl), a     ; save block in use marker 
137a			 
137a				inc hl   ; move to space marker 
137a				ld (hl), a    ; save new space 
137a			 
137a				inc hl   ; move to start of allocated area 
137a				 
137a			;	push hl     ; save where we are - 1  
137a			 
137a			;	inc hl  ; move past zero index  
137a				; skip space to set down new marker 
137a			 
137a				; provide some extra space for now 
137a			 
137a				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
137a				inc a 
137a				inc a 
137a			 
137a				push hl   ; save where we are in the node block 
137a			 
137a				call addatohl 
137a			 
137a				; write linked list point 
137a			 
137a				pop de     ; get our node position 
137a				ex de, hl 
137a			 
137a				ld (hl), e 
137a				inc hl 
137a				ld (hl), d 
137a			 
137a				inc hl 
137a			 
137a				; now at start of allocated data so save pointer 
137a			 
137a				push hl 
137a			 
137a				; jump to position of next node and setup empty header in DE 
137a			 
137a				ex de, hl 
137a			 
137a			;	inc hl ; move past end of block 
137a			 
137a				ld a, 0 
137a				ld (hl), a   ; empty marker 
137a				inc hl 
137a				ld (hl), a   ; size 
137a				inc hl  
137a				ld (hl), a   ; ptr 
137a				inc hl 
137a				ld (hl), a   ; ptr 
137a			 
137a			 
137a				pop hl 
137a			 
137a					if DEBUG_FORTH_MALLOC_INT 
137a						DMARK "mmr" 
137a						CALLMONITOR 
137a					endif 
137a			 
137a			.exit: 
137a				pop af 
137a				pop bc 
137a				pop de  
137a				ret 
137a			 
137a			 
137a			 
137a			 
137a			free:  
137a				push hl 
137a				push af 
137a				; get address in hl 
137a			 
137a					if DEBUG_FORTH_MALLOC_INT 
137a						DMARK "fre" 
137a						CALLMONITOR 
137a					endif 
137a				; data is at hl - move to block count 
137a				dec hl 
137a				dec hl    ; get past pointer 
137a				dec hl 
137a			 
137a				ld a, (hl)    ; need this for a validation check 
137a			 
137a				dec hl    ; move to block marker 
137a			 
137a				; now check that the block count and block marker are the same  
137a			        ; this checks that we are on a malloc node and not random memory 
137a			        ; OK a faint chance this could be a problem but rare - famous last words! 
137a			 
137a				ld c, a 
137a				ld a, (hl)    
137a			 
137a				cp c 
137a				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
137a			 
137a				; yes good chance we are on a malloc node 
137a			 
137a				ld a, 0      
137a				ld (hl), a   ; mark as free 
137a			 
137a				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
137a			 
137a			.freeignore:  
137a			 
137a				pop af 
137a				pop hl 
137a			 
137a				ret 
137a			 
137a			 
137a			 
137a			endif 
137a			 
137a			; eof 
# End of file firmware_memory.asm
137a			  
137a			; device C  
137a			if SOUND_ENABLE  
137a				include "firmware_sound.asm"  
137a			endif  
137a			  
137a			include "firmware_diags.asm"  
137a			; Hardware diags menu 
137a			 
137a			 
137a			config: 
137a			 
137a 3e 00			ld a, 0 
137c 21 aa 13			ld hl, .configmn 
137f cd 17 0b			call menu 
1382			 
1382 fe 00			cp 0 
1384 c8				ret z 
1385			 
1385 fe 01			cp 1 
1387 cc 14 15			call z, .savetostore 
138a			 
138a fe 02			cp 2 
138c cc 62 14			call z, .selautoload 
138f fe 03			cp 3 
1391 cc 4b 14			call z, .disautoload 
1394 fe 04			cp 4 
1396 cc 12 15			call z, .selbank 
1399 fe 05			cp 5 
139b cc ef 15			call z, .debug_tog 
139e fe 06			cp 6 
13a0 cc 37 17			call z, .bpsgo 
13a3 fe 07			cp 7 
13a5 cc 15 16			call z, hardware_diags 
13a8			 
13a8 18 d0			jr config 
13aa			 
13aa			.configmn: 
13aa ba 13			dw .c3 
13ac d1 13			dw .c2 
13ae e6 13			dw .c2a 
13b0 fc 13			dw .c2b 
13b2			;	dw .c4 
13b2 19 14			dw .m4 
13b4 34 14			dw .m4b 
13b6 3c 14			dw .c1 
13b8 00 00			dw 0 
13ba				 
13ba			 
13ba .. 00		.c3: db "Add Dictionary To File",0 
13d1 .. 00		.c2: db "Select Autoload File",0 
13e6 .. 00		.c2a: db "Disable Autoload File", 0 
13fc .. 00		.c2b: db "Select Storage Bank",0 
1410 .. 00		.c4: db "Settings",0 
1419 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1434 .. 00		.m4b:   db "Monitor",0 
143c .. 00		.c1: db "Hardware Diags",0 
144b			 
144b			 
144b			.disautoload: 
144b				if STORAGE_SE 
144b 3e fe			ld a, $fe      ; bit 0 clear 
144d 32 ce f9			ld (spi_device), a 
1450			 
1450 cd ba 03			call storage_get_block_0 
1453			 
1453 3e 00			ld a, 0 
1455 32 09 fa			ld (store_page+STORE_0_AUTOFILE), a 
1458			 
1458 21 00 00				ld hl, 0 
145b 11 e8 f9				ld de, store_page 
145e cd 6e 03			call storage_write_block	 ; save update 
1461				endif 
1461			 
1461			 
1461 c9				ret 
1462			 
1462			 
1462			 
1462			; Select auto start 
1462			 
1462			.selautoload: 
1462			 
1462				 
1462				if STORAGE_SE 
1462			 
1462 cd 39 15				call config_dir 
1465 21 a3 ef			        ld hl, scratch 
1468 3e 00				ld a, 0 
146a cd 17 0b				call menu 
146d			 
146d fe 00				cp 0 
146f c8					ret z 
1470			 
1470 3d					dec a 
1471			 
1471			 
1471					; locate menu option 
1471			 
1471 21 a3 ef				ld hl, scratch 
1474 cd 3e 0a				call table_lookup 
1477			 
1477					if DEBUG_FORTH_WORDS 
1477						DMARK "ALl" 
1477 f5				push af  
1478 3a 8c 14			ld a, (.dmark)  
147b 32 bd fb			ld (debug_mark),a  
147e 3a 8d 14			ld a, (.dmark+1)  
1481 32 be fb			ld (debug_mark+1),a  
1484 3a 8e 14			ld a, (.dmark+2)  
1487 32 bf fb			ld (debug_mark+2),a  
148a 18 03			jr .pastdmark  
148c ..			.dmark: db "ALl"  
148f f1			.pastdmark: pop af  
1490			endm  
# End of macro DMARK
1490						CALLMONITOR 
1490 cd 2d 17			call break_point_state  
1493				endm  
# End of macro CALLMONITOR
1493					endif 
1493					; with the pointer to the menu it, the byte following the zero term is the file id 
1493			 
1493 3e 00				ld a, 0 
1495 01 32 00				ld bc, 50   ; max of bytes to look at 
1498 ed b1				cpir  
149a			 
149a					if DEBUG_FORTH_WORDS 
149a						DMARK "ALb" 
149a f5				push af  
149b 3a af 14			ld a, (.dmark)  
149e 32 bd fb			ld (debug_mark),a  
14a1 3a b0 14			ld a, (.dmark+1)  
14a4 32 be fb			ld (debug_mark+1),a  
14a7 3a b1 14			ld a, (.dmark+2)  
14aa 32 bf fb			ld (debug_mark+2),a  
14ad 18 03			jr .pastdmark  
14af ..			.dmark: db "ALb"  
14b2 f1			.pastdmark: pop af  
14b3			endm  
# End of macro DMARK
14b3						CALLMONITOR 
14b3 cd 2d 17			call break_point_state  
14b6				endm  
# End of macro CALLMONITOR
14b6					endif 
14b6					;inc hl 
14b6			 
14b6 7e					ld a, (hl)   ; file id 
14b7					 
14b7				        ; save bank and file ids 
14b7			 
14b7 f5					push af 
14b8			 
14b8			; TODO need to save to block 0 on bank 1	 
14b8			 
14b8 cd ba 03				call storage_get_block_0 
14bb			 
14bb					if DEBUG_FORTH_WORDS 
14bb						DMARK "AL0" 
14bb f5				push af  
14bc 3a d0 14			ld a, (.dmark)  
14bf 32 bd fb			ld (debug_mark),a  
14c2 3a d1 14			ld a, (.dmark+1)  
14c5 32 be fb			ld (debug_mark+1),a  
14c8 3a d2 14			ld a, (.dmark+2)  
14cb 32 bf fb			ld (debug_mark+2),a  
14ce 18 03			jr .pastdmark  
14d0 ..			.dmark: db "AL0"  
14d3 f1			.pastdmark: pop af  
14d4			endm  
# End of macro DMARK
14d4						CALLMONITOR 
14d4 cd 2d 17			call break_point_state  
14d7				endm  
# End of macro CALLMONITOR
14d7					endif 
14d7 f1					pop af 
14d8			 
14d8 32 0c fa				ld (store_page+STORE_0_FILERUN),a 
14db					 
14db					; save bank id 
14db			 
14db 3a ce f9				ld a,(spi_device) 
14de 32 0b fa				ld (store_page+STORE_0_BANKRUN),a 
14e1			 
14e1					; enable auto run of store file 
14e1			 
14e1 3e 01				ld a, 1 
14e3 32 09 fa				ld (store_page+STORE_0_AUTOFILE),a 
14e6			 
14e6					; save buffer 
14e6			 
14e6 21 00 00				ld hl, 0 
14e9 11 e8 f9				ld de, store_page 
14ec					if DEBUG_FORTH_WORDS 
14ec						DMARK "ALw" 
14ec f5				push af  
14ed 3a 01 15			ld a, (.dmark)  
14f0 32 bd fb			ld (debug_mark),a  
14f3 3a 02 15			ld a, (.dmark+1)  
14f6 32 be fb			ld (debug_mark+1),a  
14f9 3a 03 15			ld a, (.dmark+2)  
14fc 32 bf fb			ld (debug_mark+2),a  
14ff 18 03			jr .pastdmark  
1501 ..			.dmark: db "ALw"  
1504 f1			.pastdmark: pop af  
1505			endm  
# End of macro DMARK
1505						CALLMONITOR 
1505 cd 2d 17			call break_point_state  
1508				endm  
# End of macro CALLMONITOR
1508					endif 
1508 cd 6e 03			call storage_write_block	 ; save update 
150b			  
150b			 
150b			 
150b			 
150b 21 a3 ef				ld hl, scratch 
150e cd 26 15				call config_fdir 
1511			 
1511			 
1511				endif 
1511 c9				ret 
1512			 
1512			 
1512			 
1512			; Select storage bank 
1512			 
1512			.selbank: 
1512			 
1512				if STORAGE_SE 
1512				endif 
1512				 
1512 c9				ret 
1513			 
1513			if STORAGE_SE 
1513			 
1513			.config_ldir:   
1513				; Load storage bank labels into menu array 
1513			 
1513				 
1513			 
1513			 
1513 c9				ret 
1514			 
1514			 
1514			endif 
1514			 
1514			 
1514			; Save user words to storage 
1514			 
1514			.savetostore: 
1514			 
1514				if STORAGE_SE 
1514			 
1514 cd 39 15				call config_dir 
1517 21 a3 ef			        ld hl, scratch 
151a 3e 00				ld a, 0 
151c cd 17 0b				call menu 
151f					 
151f 21 a3 ef				ld hl, scratch 
1522 cd 26 15				call config_fdir 
1525			 
1525			 
1525				endif 
1525			 
1525 c9				ret 
1526			 
1526			 
1526			 
1526			if STORAGE_SE 
1526			 
1526			config_fdir: 
1526				; using the scratch dir go through and release the memory allocated for each string 
1526				 
1526 21 a3 ef			ld hl, scratch 
1529 5e			.cfdir:	ld e,(hl) 
152a 23				inc hl 
152b 56				ld d,(hl) 
152c 23				inc hl 
152d			 
152d eb				ex de, hl 
152e cd 43 0d			call ishlzero 
1531 c8				ret z     ; return on null pointer 
1532 cd ab 12			call free 
1535 eb				ex de, hl 
1536 18 f1			jr .cfdir 
1538			 
1538			 
1538 c9				ret 
1539			 
1539			 
1539			config_dir: 
1539			 
1539				; for the config menus that need to build a directory of storage call this routine 
1539				; it will construct a menu in scratch to pass to menu 
1539			 
1539				; open storage device 
1539			 
1539				; execute DIR to build a list of files and their ids into scratch in menu format 
1539				; once the menu has finished then will need to call config_fdir to release the strings 
1539				 
1539				; c = number items 
1539			 
1539				 
1539 cd ba 03			call storage_get_block_0 
153c			 
153c 21 e8 f9			ld hl, store_page     ; get current id count 
153f 46				ld b, (hl) 
1540 0e 00			ld c, 0    ; count of files   
1542			 
1542			 
1542 21 a3 ef			ld hl, scratch 
1545 22 e4 f9			ld (store_tmp2), hl    ; location to poke strings 
1548			 
1548				; check for empty drive 
1548			 
1548 3e 00			ld a, 0 
154a b8				cp b 
154b ca e5 15			jp z, .dirdone 
154e			 
154e				 
154e					if DEBUG_FORTH_WORDS 
154e						DMARK "Cdc" 
154e f5				push af  
154f 3a 63 15			ld a, (.dmark)  
1552 32 bd fb			ld (debug_mark),a  
1555 3a 64 15			ld a, (.dmark+1)  
1558 32 be fb			ld (debug_mark+1),a  
155b 3a 65 15			ld a, (.dmark+2)  
155e 32 bf fb			ld (debug_mark+2),a  
1561 18 03			jr .pastdmark  
1563 ..			.dmark: db "Cdc"  
1566 f1			.pastdmark: pop af  
1567			endm  
# End of macro DMARK
1567						CALLMONITOR 
1567 cd 2d 17			call break_point_state  
156a				endm  
# End of macro CALLMONITOR
156a					endif 
156a			 
156a			 
156a			.diritem:	 
156a c5				push bc 
156b				; for each of the current ids do a search for them and if found push to stack 
156b			 
156b 21 40 00				ld hl, STORE_BLOCK_PHY 
156e 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1570 58					ld e,b 
1571			 
1571 cd 2e 06				call storage_findnextid 
1574			 
1574			 
1574					; if found hl will be non zero 
1574			 
1574 cd 43 0d				call ishlzero 
1577 28 69				jr z, .dirnotfound 
1579			 
1579					; increase count 
1579			 
1579 c1					pop bc	 
157a 0c					inc c 
157b c5					push bc 
157c					 
157c			 
157c					; get file header and push the file name 
157c			 
157c 11 e8 f9				ld de, store_page 
157f cd 09 03				call storage_read_block 
1582			 
1582					; push file id to stack 
1582				 
1582 3a e8 f9				ld a, (store_page) 
1585 26 00				ld h, 0 
1587 6f					ld l, a 
1588			 
1588					;call forth_push_numhl 
1588					; TODO store id 
1588			 
1588 e5					push hl 
1589			 
1589					; push extent count to stack  
1589				 
1589 21 eb f9				ld hl, store_page+3 
158c			 
158c					; get file name length 
158c			 
158c cd 78 11				call strlenz   
158f			 
158f 23					inc hl   ; cover zero term 
1590 23					inc hl  ; stick the id at the end of the area 
1591			 
1591 e5					push hl 
1592 c1					pop bc    ; move length to bc 
1593			 
1593 cd e1 11				call malloc 
1596			 
1596					; TODO save malloc area to scratch 
1596			 
1596 eb					ex de, hl 
1597 2a e4 f9				ld hl, (store_tmp2) 
159a 73					ld (hl), e 
159b 23					inc hl 
159c 72					ld (hl), d 
159d 23					inc hl 
159e 22 e4 f9				ld (store_tmp2), hl 
15a1			 
15a1					 
15a1			 
15a1					;pop hl   ; get source 
15a1			;		ex de, hl    ; swap aronund	 
15a1			 
15a1 21 eb f9				ld hl, store_page+3 
15a4					if DEBUG_FORTH_WORDS 
15a4						DMARK "CFd" 
15a4 f5				push af  
15a5 3a b9 15			ld a, (.dmark)  
15a8 32 bd fb			ld (debug_mark),a  
15ab 3a ba 15			ld a, (.dmark+1)  
15ae 32 be fb			ld (debug_mark+1),a  
15b1 3a bb 15			ld a, (.dmark+2)  
15b4 32 bf fb			ld (debug_mark+2),a  
15b7 18 03			jr .pastdmark  
15b9 ..			.dmark: db "CFd"  
15bc f1			.pastdmark: pop af  
15bd			endm  
# End of macro DMARK
15bd						CALLMONITOR 
15bd cd 2d 17			call break_point_state  
15c0				endm  
# End of macro CALLMONITOR
15c0					endif 
15c0 ed b0				ldir 
15c2			 
15c2					; de is past string, move back one and store id 
15c2					 
15c2 1b					dec de 
15c3			 
15c3					; store file id 
15c3			 
15c3 e1					pop hl 
15c4 eb					ex de,hl 
15c5 73					ld (hl), e 
15c6			 
15c6					if DEBUG_FORTH_WORDS 
15c6						DMARK "Cdi" 
15c6 f5				push af  
15c7 3a db 15			ld a, (.dmark)  
15ca 32 bd fb			ld (debug_mark),a  
15cd 3a dc 15			ld a, (.dmark+1)  
15d0 32 be fb			ld (debug_mark+1),a  
15d3 3a dd 15			ld a, (.dmark+2)  
15d6 32 bf fb			ld (debug_mark+2),a  
15d9 18 03			jr .pastdmark  
15db ..			.dmark: db "Cdi"  
15de f1			.pastdmark: pop af  
15df			endm  
# End of macro DMARK
15df						CALLMONITOR 
15df cd 2d 17			call break_point_state  
15e2				endm  
# End of macro CALLMONITOR
15e2					endif 
15e2					 
15e2			.dirnotfound: 
15e2 c1					pop bc     
15e3 10 85				djnz .diritem 
15e5				 
15e5			.dirdone:	 
15e5			 
15e5 3e 00				ld a, 0 
15e7 2a e4 f9				ld hl, (store_tmp2) 
15ea 77					ld (hl), a 
15eb 23					inc hl 
15ec 77					ld (hl), a 
15ed 23					inc hl 
15ee					; push a count of the dir items found 
15ee			 
15ee			;		ld h, 0 
15ee			;		ld l, c 
15ee			 
15ee c9				ret 
15ef			 
15ef			endif 
15ef			 
15ef			 
15ef			; Settings 
15ef			; Run  
15ef			 
15ef			 
15ef			 
15ef			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
15ef			;;hd_menu2:   db "        2: Editor",0   
15ef			;hd_menu2:   db "        2: Editor       6: Menu",0   
15ef			;hd_menu3:   db "        3: Storage",0 
15ef			;hd_menu4:   db "0=quit  4: Debug",0 
15ef			;hd_don:     db "ON",0 
15ef			;hd_doff:     db "OFF",0 
15ef			; 
15ef			; 
15ef			; 
15ef			;hardware_diags_old:       
15ef			; 
15ef			;.diagmenu: 
15ef			;	call clear_display 
15ef			;	ld a, display_row_1 
15ef			;	ld de, hd_menu1 
15ef			;	call str_at_display 
15ef			; 
15ef			;	ld a, display_row_2 
15ef			;	ld de, hd_menu2 
15ef			;	call str_at_display 
15ef			; 
15ef			;	ld a, display_row_3 
15ef			;	ld de, hd_menu3 
15ef			;	call str_at_display 
15ef			; 
15ef			;	ld a,  display_row_4 
15ef			;	ld de, hd_menu4 
15ef			;	call str_at_display 
15ef			; 
15ef			;	; display debug state 
15ef			; 
15ef			;	ld de, hd_don 
15ef			;	ld a, (os_view_disable) 
15ef			;	cp 0 
15ef			;	jr z, .distog 
15ef			;	ld de, hd_doff 
15ef			;.distog: ld a, display_row_4+17 
15ef			;	call str_at_display 
15ef			; 
15ef			;	call update_display 
15ef			; 
15ef			;	call cin_wait 
15ef			; 
15ef			; 
15ef			; 
15ef			;	cp '4' 
15ef			;	jr nz, .diagn1 
15ef			; 
15ef			;	; debug toggle 
15ef			; 
15ef			;	ld a, (os_view_disable) 
15ef			;	ld b, '*' 
15ef			;	cp 0 
15ef			;	jr z, .debtog 
15ef			;	ld b, 0 
15ef			;.debtog:	 
15ef			;	ld a,b 
15ef			;	ld (os_view_disable),a 
15ef			; 
15ef			;.diagn1: cp '0' 
15ef			;	 ret z 
15ef			; 
15ef			;;	cp '1' 
15ef			;;       jp z, matrix	 
15ef			;;   TODO keyboard matrix test 
15ef			; 
15ef			;	cp '2' 
15ef			;	jp z, .diagedit 
15ef			; 
15ef			;;	cp '6' 
15ef			;;	jp z, .menutest 
15ef			;;if ENABLE_BASIC 
15ef			;;	cp '6' 
15ef			;;	jp z, basic 
15ef			;;endif 
15ef			 ; 
15ef			;	jp .diagmenu 
15ef			; 
15ef			; 
15ef			;	ret 
15ef			 
15ef			 
15ef			.debug_tog: 
15ef 21 36 16			ld hl, .menudebug 
15f2				 
15f2 3a 94 ef			ld a, (os_view_disable) 
15f5 fe 2a			cp '*' 
15f7 20 04			jr nz,.tdon  
15f9 3e 01			ld a, 1 
15fb 18 02			jr .tog1 
15fd 3e 00		.tdon: ld a, 0 
15ff			 
15ff			.tog1: 
15ff cd 17 0b			call menu 
1602 fe 00			cp 0 
1604 c8				ret z 
1605 fe 01			cp 1    ; disable debug 
1607 28 04			jr z, .dtog0 
1609 3e 2a			ld a, '*' 
160b 18 02			jr .dtogset 
160d 3e 00		.dtog0: ld a, 0 
160f 32 94 ef		.dtogset:  ld (os_view_disable), a 
1612 c3 ef 15			jp .debug_tog 
1615			 
1615			 
1615			hardware_diags:       
1615			 
1615			.diagm: 
1615 21 28 16			ld hl, .menuitems 
1618 3e 00			ld a, 0 
161a cd 17 0b			call menu 
161d			 
161d fe 00		         cp 0 
161f c8				 ret z 
1620			 
1620 fe 02			cp 2 
1622 ca 81 16			jp z, .diagedit 
1625			 
1625			;	cp '6' 
1625			;	jp z, .menutest 
1625			;if ENABLE_BASIC 
1625			;	cp '6' 
1625			;	jp z, basic 
1625			;endif 
1625			  
1625 c3 15 16			jp .diagm 
1628			 
1628				 
1628 3c 16		.menuitems:   	dw .m1 
162a 47 16				dw .m2 
162c 4e 16				dw .m3 
162e 56 16				dw .m5 
1630 5c 16				dw .m5a 
1632 65 16				dw .m5b 
1634 00 00				dw 0 
1636			 
1636			.menudebug: 
1636 6e 16				dw .m6 
1638 77 16				dw .m7 
163a 00 00				dw 0 
163c			 
163c .. 00		.m1:   db "Key Matrix",0 
1647 .. 00		.m2:   db "Editor",0 
164e .. 00		.m3:   db "Storage",0 
1656 .. 00		.m5:   db "Sound",0 
165c .. 00		.m5a:  db "RAM Test",0 
1665 .. 00		.m5b:  db "LCD Test",0 
166e			 
166e .. 00		.m6:   db "Debug ON",0 
1677 .. 00		.m7:   db "Debug OFF",0 
1681			 
1681			; debug editor 
1681			 
1681			.diagedit: 
1681			 
1681 21 a3 ef			ld hl, scratch 
1684			;	ld bc, 250 
1684			;	ldir 
1684				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1684 3e 00			ld a, 0 
1686 77				ld (hl), a 
1687 23				inc hl 
1688 77				ld (hl), a 
1689 23				inc hl 
168a 77				ld (hl), a 
168b			 
168b cd e6 0a		        call clear_display 
168e cd 09 0b			call update_display 
1691 3e 01			ld a, 1 
1693 32 c3 fb			ld (hardware_diag), a 
1696			.diloop: 
1696 3e 00			ld a, display_row_1 
1698 0e 00			ld c, 0 
169a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
169c 1e 28			ld e, 40 
169e			 
169e 21 a3 ef			ld hl, scratch	 
16a1 cd 47 0d			call input_str 
16a4			 
16a4 3e 14			ld a, display_row_2 
16a6 11 a3 ef			ld de, scratch 
16a9 cd f9 0a			call str_at_display 
16ac cd 09 0b			call update_display 
16af			 
16af c3 96 16			jp .diloop 
16b2			 
16b2			 
16b2			; pass word in hl 
16b2			; a has display location 
16b2			display_word_at: 
16b2 f5				push af 
16b3 e5				push hl 
16b4 7c				ld a,h 
16b5 21 a8 f2			ld hl, os_word_scratch 
16b8 cd 1b 10			call hexout 
16bb e1				pop hl 
16bc 7d				ld a,l 
16bd 21 aa f2			ld hl, os_word_scratch+2 
16c0 cd 1b 10			call hexout 
16c3 21 ac f2			ld hl, os_word_scratch+4 
16c6 3e 00			ld a,0 
16c8 77				ld (hl),a 
16c9 11 a8 f2			ld de,os_word_scratch 
16cc f1				pop af 
16cd cd f9 0a				call str_at_display 
16d0 c9				ret 
16d1			 
16d1			display_ptr_state: 
16d1			 
16d1				; to restore afterwards 
16d1			 
16d1 d5				push de 
16d2 c5				push bc 
16d3 e5				push hl 
16d4 f5				push af 
16d5			 
16d5				; for use in here 
16d5			 
16d5			;	push bc 
16d5			;	push de 
16d5			;	push hl 
16d5			;	push af 
16d5			 
16d5 cd e6 0a			call clear_display 
16d8			 
16d8 11 ab 18			ld de, .ptrstate 
16db 3e 00			ld a, display_row_1 
16dd cd f9 0a			call str_at_display 
16e0			 
16e0				; display debug step 
16e0			 
16e0			 
16e0 11 bd fb			ld de, debug_mark 
16e3 3e 12			ld a, display_row_1+display_cols-2 
16e5 cd f9 0a			call str_at_display 
16e8			 
16e8				; display a 
16e8 11 b5 18			ld de, .ptrcliptr 
16eb 3e 14			ld a, display_row_2 
16ed cd f9 0a			call str_at_display 
16f0			 
16f0 f1				pop af 
16f1 2a ae f9			ld hl,(cli_ptr) 
16f4 3e 1c			ld a, display_row_2+8 
16f6 cd b2 16			call display_word_at 
16f9			 
16f9			 
16f9				; display hl 
16f9			 
16f9			 
16f9 11 bd 18			ld de, .ptrclioptr 
16fc 3e 1e			ld a, display_row_2+10 
16fe cd f9 0a			call str_at_display 
1701			; 
1701			;	pop hl 
1701 3e 21			ld a, display_row_2+13 
1703 2a ac f9			ld hl,(cli_origptr) 
1706 cd b2 16			call display_word_at 
1709			; 
1709			;	 
1709			;	; display de 
1709			 
1709			;	ld de, .regstatede 
1709			;	ld a, display_row_3 
1709			;	call str_at_display 
1709			 
1709			;	pop de 
1709			;	ld h,d 
1709			;	ld l, e 
1709			;	ld a, display_row_3+3 
1709			;	call display_word_at 
1709			 
1709			 
1709				; display bc 
1709			 
1709			;	ld de, .regstatebc 
1709			;	ld a, display_row_3+10 
1709			;	call str_at_display 
1709			 
1709			;	pop bc 
1709			;	ld h,b 
1709			;	ld l, c 
1709			;	ld a, display_row_3+13 
1709			;	call display_word_at 
1709			 
1709			 
1709				; display dsp 
1709			 
1709			;	ld de, .regstatedsp 
1709			;	ld a, display_row_4 
1709			;	call str_at_display 
1709			 
1709				 
1709			;	ld hl,(cli_data_sp) 
1709			;	ld a, display_row_4+4 
1709			;	call display_word_at 
1709			 
1709				; display rsp 
1709			 
1709 11 ec 18			ld de, .regstatersp 
170c 3e 46			ld a, display_row_4+10 
170e cd f9 0a			call str_at_display 
1711			 
1711				 
1711 2a 94 f9			ld hl,(cli_ret_sp) 
1714 3e 4a			ld a, display_row_4+14 
1716 cd b2 16			call display_word_at 
1719			 
1719 cd 09 0b			call update_display 
171c			 
171c cd 66 0a			call delay1s 
171f cd 66 0a			call delay1s 
1722 cd 66 0a			call delay1s 
1725			 
1725			 
1725 cd 35 1c			call next_page_prompt 
1728			 
1728				; restore  
1728			 
1728 f1				pop af 
1729 e1				pop hl 
172a c1				pop bc 
172b d1				pop de 
172c c9				ret 
172d			 
172d			break_point_state: 
172d f5				push af 
172e			 
172e				; see if disabled 
172e			 
172e 3a 94 ef			ld a, (os_view_disable) 
1731 fe 2a			cp '*' 
1733 20 02			jr nz, .bpsgo 
1735 f1				pop af 
1736 c9				ret 
1737			 
1737			.bpsgo: 
1737 f1				pop af 
1738 f5				push af 
1739 22 90 ef			ld (os_view_hl), hl 
173c ed 53 8e ef		ld (os_view_de), de 
1740 ed 43 8c ef		ld (os_view_bc), bc 
1744 e5				push hl 
1745 6f				ld l, a 
1746 26 00			ld h, 0 
1748 22 92 ef			ld (os_view_af),hl 
174b			 
174b 21 53 fb				ld hl, display_fb0 
174e 22 5e fa				ld (display_fb_active), hl 
1751 e1				pop hl	 
1752			 
1752 3e 31			ld a, '1' 
1754 fe 2a		.bps1:  cp '*' 
1756 20 03			jr nz, .bps1b 
1758 32 94 ef			ld (os_view_disable),a 
175b fe 31		.bps1b:  cp '1' 
175d 20 14			jr nz, .bps2 
175f			 
175f				; display reg 
175f			 
175f				 
175f			 
175f 3a 92 ef			ld a, (os_view_af) 
1762 2a 90 ef			ld hl, (os_view_hl) 
1765 ed 5b 8e ef		ld de, (os_view_de) 
1769 ed 4b 8c ef		ld bc, (os_view_bc) 
176d cd 07 18			call display_reg_state 
1770 c3 f3 17			jp .bpschk 
1773			 
1773 fe 32		.bps2:  cp '2' 
1775 20 08			jr nz, .bps3 
1777				 
1777				; display hl 
1777 2a 90 ef			ld hl, (os_view_hl) 
177a cd f1 18			call display_dump_at_hl 
177d			 
177d 18 74			jr .bpschk 
177f			 
177f fe 33		.bps3:  cp '3' 
1781 20 08			jr nz, .bps4 
1783			 
1783			        ; display de 
1783 2a 8e ef			ld hl, (os_view_de) 
1786 cd f1 18			call display_dump_at_hl 
1789			 
1789 18 68			jr .bpschk 
178b fe 34		.bps4:  cp '4' 
178d 20 08			jr nz, .bps5 
178f			 
178f			        ; display bc 
178f 2a 8c ef			ld hl, (os_view_bc) 
1792 cd f1 18			call display_dump_at_hl 
1795			 
1795 18 5c			jr .bpschk 
1797 fe 35		.bps5:  cp '5' 
1799 20 08		        jr nz, .bps7 
179b			 
179b				; display cur ptr 
179b 2a ae f9			ld hl, (cli_ptr) 
179e cd f1 18			call display_dump_at_hl 
17a1			 
17a1 18 50			jr .bpschk 
17a3 fe 36		.bps7:  cp '6' 
17a5 20 08			jr nz, .bps8b 
17a7				 
17a7				; display cur orig ptr 
17a7 2a ac f9			ld hl, (cli_origptr) 
17aa cd f1 18			call display_dump_at_hl 
17ad 18 44			jr .bpschk 
17af fe 37		.bps8b:  cp '7' 
17b1 20 08			jr nz, .bps9 
17b3				 
17b3				; display dsp 
17b3 2a 90 f9			ld hl, (cli_data_sp) 
17b6 cd f1 18			call display_dump_at_hl 
17b9			 
17b9 18 38			jr .bpschk 
17bb fe 39		.bps9:  cp '9' 
17bd 20 05			jr nz, .bps8c 
17bf				 
17bf				; display SP 
17bf			;	ld hl, sp 
17bf cd f1 18			call display_dump_at_hl 
17c2			 
17c2 18 2f			jr .bpschk 
17c4 fe 38		.bps8c:  cp '8' 
17c6 20 08			jr nz, .bps8d 
17c8				 
17c8				; display rsp 
17c8 2a 94 f9			ld hl, (cli_ret_sp) 
17cb cd f1 18			call display_dump_at_hl 
17ce			 
17ce 18 23			jr .bpschk 
17d0 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
17d2 20 05			jr nz, .bps8 
17d4 cd 2b 1a			call monitor 
17d7			 
17d7 18 1a			jr .bpschk 
17d9 fe 30		.bps8:  cp '0' 
17db 20 16			jr nz, .bpschk 
17dd			 
17dd 21 02 fb				ld hl, display_fb1 
17e0 22 5e fa				ld (display_fb_active), hl 
17e3 cd 09 0b				call update_display 
17e6			 
17e6				;ld a, (os_view_af) 
17e6 2a 90 ef			ld hl, (os_view_hl) 
17e9 ed 5b 8e ef		ld de, (os_view_de) 
17ed ed 4b 8c ef		ld bc, (os_view_bc) 
17f1 f1				pop af 
17f2 c9				ret 
17f3			 
17f3			.bpschk:   
17f3 cd 66 0a			call delay1s 
17f6 3e 4f		ld a,display_row_4 + display_cols - 1 
17f8 11 33 1c		        ld de, endprg 
17fb cd f9 0a			call str_at_display 
17fe cd 09 0b			call update_display 
1801 cd 21 67			call cin_wait 
1804			 
1804 c3 54 17			jp .bps1 
1807			 
1807			 
1807			display_reg_state: 
1807			 
1807				; to restore afterwards 
1807			 
1807 d5				push de 
1808 c5				push bc 
1809 e5				push hl 
180a f5				push af 
180b			 
180b				; for use in here 
180b			 
180b c5				push bc 
180c d5				push de 
180d e5				push hl 
180e f5				push af 
180f			 
180f cd e6 0a			call clear_display 
1812			 
1812 11 c7 18			ld de, .regstate 
1815 3e 00			ld a, display_row_1 
1817 cd f9 0a			call str_at_display 
181a			 
181a				; display debug step 
181a			 
181a			 
181a 11 bd fb			ld de, debug_mark 
181d 3e 11			ld a, display_row_1+display_cols-3 
181f cd f9 0a			call str_at_display 
1822			 
1822				; display a 
1822 11 e3 18			ld de, .regstatea 
1825 3e 14			ld a, display_row_2 
1827 cd f9 0a			call str_at_display 
182a			 
182a e1				pop hl 
182b			;	ld h,0 
182b			;	ld l, a 
182b 3e 17			ld a, display_row_2+3 
182d cd b2 16			call display_word_at 
1830			 
1830			 
1830				; display hl 
1830			 
1830			 
1830 11 d7 18			ld de, .regstatehl 
1833 3e 1e			ld a, display_row_2+10 
1835 cd f9 0a			call str_at_display 
1838			 
1838 e1				pop hl 
1839 3e 21			ld a, display_row_2+13 
183b cd b2 16			call display_word_at 
183e			 
183e				 
183e				; display de 
183e			 
183e 11 db 18			ld de, .regstatede 
1841 3e 28			ld a, display_row_3 
1843 cd f9 0a			call str_at_display 
1846			 
1846 e1				pop hl 
1847			;	ld h,d 
1847			;	ld l, e 
1847 3e 2b			ld a, display_row_3+3 
1849 cd b2 16			call display_word_at 
184c			 
184c			 
184c				; display bc 
184c			 
184c 11 df 18			ld de, .regstatebc 
184f 3e 32			ld a, display_row_3+10 
1851 cd f9 0a			call str_at_display 
1854			 
1854 e1				pop hl 
1855			;	ld h,b 
1855			;	ld l, c 
1855 3e 35			ld a, display_row_3+13 
1857 cd b2 16			call display_word_at 
185a			 
185a			 
185a				; display dsp 
185a			 
185a 11 e7 18			ld de, .regstatedsp 
185d 3e 3c			ld a, display_row_4 
185f cd f9 0a			call str_at_display 
1862			 
1862				 
1862 2a 90 f9			ld hl,(cli_data_sp) 
1865 3e 40			ld a, display_row_4+4 
1867 cd b2 16			call display_word_at 
186a			 
186a				; display rsp 
186a			 
186a 11 ec 18			ld de, .regstatersp 
186d 3e 46			ld a, display_row_4+10 
186f cd f9 0a			call str_at_display 
1872			 
1872				 
1872 2a 94 f9			ld hl,(cli_ret_sp) 
1875 3e 4a			ld a, display_row_4+14 
1877 cd b2 16			call display_word_at 
187a			 
187a cd 09 0b			call update_display 
187d			 
187d			;	call delay1s 
187d			;	call delay1s 
187d			;	call delay1s 
187d			 
187d			 
187d			;	call next_page_prompt 
187d			 
187d				; restore  
187d			 
187d f1				pop af 
187e e1				pop hl 
187f c1				pop bc 
1880 d1				pop de 
1881 c9				ret 
1882			 
1882 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1896 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
18ab .. 00		.ptrstate:	db "Ptr State",0 
18b5 .. 00		.ptrcliptr:     db "cli_ptr",0 
18bd .. 00		.ptrclioptr:     db "cli_o_ptr",0 
18c7 .. 00		.regstate:	db "Reg State (1/0)",0 
18d7 .. 00		.regstatehl:	db "HL:",0 
18db .. 00		.regstatede:	db "DE:",0 
18df .. 00		.regstatebc:	db "BC:",0 
18e3 .. 00		.regstatea:	db "A :",0 
18e7 .. 00		.regstatedsp:	db "DSP:",0 
18ec .. 00		.regstatersp:	db "RSP:",0 
18f1			 
18f1			display_dump_at_hl: 
18f1 e5				push hl 
18f2 d5				push de 
18f3 c5				push bc 
18f4 f5				push af 
18f5			 
18f5 22 c6 f2			ld (os_cur_ptr),hl	 
18f8 cd e6 0a			call clear_display 
18fb cd 3d 1b			call dumpcont 
18fe			;	call delay1s 
18fe			;	call next_page_prompt 
18fe			 
18fe			 
18fe f1				pop af 
18ff c1				pop bc 
1900 d1				pop de 
1901 e1				pop hl 
1902 c9				ret 
1903			 
1903			;if ENABLE_BASIC 
1903			;	include "nascombasic.asm" 
1903			;	basic: 
1903			;	include "forth/FORTH.ASM" 
1903			;endif 
1903			 
1903			; eof 
1903			 
1903			 
# End of file firmware_diags.asm
1903			  
1903			  
1903			  
1903			  
1903			; eof  
1903			  
# End of file firmware.asm
1903			 
1903			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1903			;if BASE_KEV  
1903			;baseram: equ 08000h 
1903			;endif 
1903			 
1903			;if BASE_SC114 
1903			;baseram:     equ    endofcode 
1903			;endif 
1903			 
1903			 
1903			; start system 
1903			 
1903			coldstart: 
1903				; set sp 
1903				; di/ei 
1903			 
1903 f3				di 
1904 31 fd ff			ld sp, tos 
1907			;	ei 
1907			 
1907			 
1907				; disable breakpoint by default 
1907			 
1907 3e 2a			ld a,'*' 
1909 32 94 ef			ld (os_view_disable),a 
190c			 
190c				; init hardware 
190c			 
190c				; init keyboard and screen hardware 
190c			 
190c cd 03 00			call hardware_init 
190f			 
190f			 
190f				; detect if any keys are held down to enable breakpoints at start up 
190f			 
190f cd 32 67			call cin  
1912 fe 00			cp 0 
1914 28 03			jr z, .nokeys 
1916			 
1916				;call hardware_diags 
1916 cd 7a 13			call config 
1919			 
1919			;	ld de, .bpen 
1919			;	ld a, display_row_4 
1919			;	call str_at_display 
1919			;	call update_display 
1919			; 
1919			;	ld a,0 
1919			;	ld (os_view_disable),a 
1919			; 
1919			;.bpwait: 
1919			;	call cin 
1919			;	cp 0 
1919			;	jr z, .bpwait 
1919			;	jr .nokeys 
1919			; 
1919			; 
1919			;.bpen:  db "Break points enabled!",0 
1919			 
1919			 
1919			 
1919			 
1919			 
1919			 
1919			.nokeys: 
1919			 
1919			 
1919				 
1919			 
1919			;jp  testkey 
1919			 
1919			;call storage_get_block_0 
1919			; 
1919			;ld hl, 0 
1919			;ld de, store_page 
1919			;call storage_read_block 
1919			 
1919				 
1919			;ld hl, 10 
1919			;ld de, store_page 
1919			;call storage_read_block 
1919			 
1919			 
1919			 
1919			 
1919			 
1919			;stop:	nop 
1919			;	jp stop 
1919			 
1919			 
1919			 
1919			main: 
1919 cd e6 0a			call clear_display 
191c cd 09 0b			call update_display 
191f			 
191f			 
191f			 
191f			;	call testlcd 
191f			 
191f			 
191f			 
191f cd fb 1f			call forth_init 
1922			 
1922			 
1922			warmstart: 
1922 cd d1 1f			call forth_warmstart 
1925			 
1925				; run startup word load 
1925			        ; TODO prevent this running at warmstart after crash  
1925			 
1925				if STARTUP_ENABLE 
1925					if STORAGE_SE 
1925 cd 63 64					call forth_autoload 
1928					endif 
1928 cd 72 61				call forth_startup 
192b			 
192b			 
192b				endif 
192b			 
192b				; show free memory after boot 
192b 11 c5 19			ld de, freeram 
192e 3e 00			ld a, display_row_1 
1930 cd f9 0a			call str_at_display 
1933			 
1933			; Or use heap_size word???? 
1933 21 89 ef			ld hl, heap_end 
1936 11 0e 80			ld de, heap_start 
1939 ed 52			sbc hl, de 
193b e5				push hl 
193c 7c				ld a,h	         	 
193d 21 a8 f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1940 cd 1b 10			call hexout 
1943 e1			   	pop hl 
1944			 
1944 7d				ld a,l 
1945 21 aa f2			ld hl, os_word_scratch+2 
1948 cd 1b 10			call hexout 
194b 21 ac f2			ld hl, os_word_scratch+4 
194e 3e 00			ld a, 0 
1950 77				ld (hl),a 
1951 11 a8 f2			ld de, os_word_scratch 
1954 3e 0d			ld a, display_row_1 + 13 
1956 cd f9 0a			call str_at_display 
1959 cd 09 0b			call update_display 
195c			 
195c			 
195c				;call demo 
195c			 
195c			 
195c				; init scratch input area for cli commands 
195c			 
195c 21 ca f2			ld hl, os_cli_cmd 
195f 3e 00			ld a,0 
1961 77				ld (hl),a 
1962 23				inc hl 
1963 77				ld (hl),a 
1964			 
1964 3e 00			ld a,0 
1966 32 c9 f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1969			 
1969 32 c6 f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
196c 32 c7 f2			ld (os_cur_ptr+1),a	 
196f			 
196f 32 a8 f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1972 32 a9 f2			ld (os_word_scratch+1),a	 
1975				 
1975			 
1975				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1975 21 ca f2			ld hl, os_cli_cmd 
1978			 
1978 3e 00			ld a, 0		 ; init cli input 
197a 77				ld (hl), a 
197b 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
197d			cli: 
197d				; show cli prompt 
197d				;push af 
197d				;ld a, 0 
197d				;ld de, prompt 
197d				;call str_at_display 
197d			 
197d				;call update_display 
197d				;pop af 
197d				;inc a 
197d				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
197d 0e 00			ld c, 0 
197f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1981 1e 28			ld e, 40 
1983			 
1983 21 ca f2			ld hl, os_cli_cmd 
1986			 
1986				STACKFRAME OFF $fefe $9f9f 
1986				if DEBUG_STACK_IMB 
1986					if OFF 
1986						exx 
1986						ld de, $fefe 
1986						ld a, d 
1986						ld hl, curframe 
1986						call hexout 
1986						ld a, e 
1986						ld hl, curframe+2 
1986						call hexout 
1986						ld hl, $fefe 
1986						push hl 
1986						ld hl, $9f9f 
1986						push hl 
1986						exx 
1986					endif 
1986				endif 
1986			endm 
# End of macro STACKFRAME
1986			 
1986 cd 47 0d			call input_str 
1989			 
1989				STACKFRAMECHK OFF $fefe $9f9f 
1989				if DEBUG_STACK_IMB 
1989					if OFF 
1989						exx 
1989						ld hl, $9f9f 
1989						pop de   ; $9f9f 
1989						call cmp16 
1989						jr nz, .spnosame 
1989						ld hl, $fefe 
1989						pop de   ; $fefe 
1989						call cmp16 
1989						jr z, .spfrsame 
1989						.spnosame: call showsperror 
1989						.spfrsame: nop 
1989						exx 
1989					endif 
1989				endif 
1989			endm 
# End of macro STACKFRAMECHK
1989			 
1989				; copy input to last command 
1989			 
1989 21 ca f2			ld hl, os_cli_cmd 
198c 11 c9 f3			ld de, os_last_cmd 
198f 01 ff 00			ld bc, 255 
1992 ed b0			ldir 
1994			 
1994				; wipe current buffer 
1994			 
1994			;	ld a, 0 
1994			;	ld hl, os_cli_cmd 
1994			;	ld de, os_cli_cmd+1 
1994			;	ld bc, 254 
1994			;	ldir 
1994				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1994			;	call strcpy 
1994			;	ld a, 0 
1994			;	ld (hl), a 
1994			;	inc hl 
1994			;	ld (hl), a 
1994			;	inc hl 
1994			;	ld (hl), a 
1994			 
1994				; switch frame buffer to program  
1994			 
1994 21 02 fb				ld hl, display_fb1 
1997 22 5e fa				ld (display_fb_active), hl 
199a			 
199a			;	nop 
199a				STACKFRAME ON $fbfe $8f9f 
199a				if DEBUG_STACK_IMB 
199a					if ON 
199a						exx 
199a						ld de, $fbfe 
199a						ld a, d 
199a						ld hl, curframe 
199a						call hexout 
199a						ld a, e 
199a						ld hl, curframe+2 
199a						call hexout 
199a						ld hl, $fbfe 
199a						push hl 
199a						ld hl, $8f9f 
199a						push hl 
199a						exx 
199a					endif 
199a				endif 
199a			endm 
# End of macro STACKFRAME
199a				; first time into the parser so pass over the current scratch pad 
199a 21 ca f2			ld hl,os_cli_cmd 
199d				; tokenise the entered statement(s) in HL 
199d cd 74 20			call forthparse 
19a0			        ; exec forth statements in top of return stack 
19a0 cd b4 20			call forthexec 
19a3				;call forthexec_cleanup 
19a3			;	call parsenext 
19a3			 
19a3				STACKFRAMECHK ON $fbfe $8f9f 
19a3				if DEBUG_STACK_IMB 
19a3					if ON 
19a3						exx 
19a3						ld hl, $8f9f 
19a3						pop de   ; $8f9f 
19a3						call cmp16 
19a3						jr nz, .spnosame 
19a3						ld hl, $fbfe 
19a3						pop de   ; $fbfe 
19a3						call cmp16 
19a3						jr z, .spfrsame 
19a3						.spnosame: call showsperror 
19a3						.spfrsame: nop 
19a3						exx 
19a3					endif 
19a3				endif 
19a3			endm 
# End of macro STACKFRAMECHK
19a3				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
19a3			 
19a3 3e 3c			ld a, display_row_4 
19a5 11 d7 19			ld de, endprog 
19a8			 
19a8 cd 09 0b			call update_display		 
19ab			 
19ab cd 35 1c			call next_page_prompt 
19ae			 
19ae				; switch frame buffer to cli 
19ae			 
19ae 21 53 fb				ld hl, display_fb0 
19b1 22 5e fa				ld (display_fb_active), hl 
19b4			 
19b4			 
19b4 cd e6 0a		        call clear_display 
19b7 cd 09 0b			call update_display		 
19ba			 
19ba 21 ca f2			ld hl, os_cli_cmd 
19bd			 
19bd 3e 00			ld a, 0		 ; init cli input 
19bf 77				ld (hl), a 
19c0			 
19c0				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
19c0			 
19c0				; now on last line 
19c0			 
19c0				; TODO scroll screen up 
19c0			 
19c0				; TODO instead just clear screen and place at top of screen 
19c0			 
19c0			;	ld a, 0 
19c0			;	ld (f_cursor_ptr),a 
19c0			 
19c0				;call clear_display 
19c0				;call update_display 
19c0			 
19c0				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19c0 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19c2 c3 7d 19			jp cli 
19c5			 
19c5 .. 00		freeram: db "Free bytes: $",0 
19d3 ..			asc: db "1A2F" 
19d7 .. 00		endprog: db "End prog...",0 
19e3			 
19e3			testenter2:   
19e3 21 d5 ef			ld hl,scratch+50 
19e6 22 c6 f2			ld (os_cur_ptr),hl 
19e9 c3 7d 19			jp cli 
19ec			 
19ec			testenter:  
19ec			 
19ec 21 d3 19			ld hl,asc 
19ef			;	ld a,(hl) 
19ef			;	call nibble2val 
19ef cd 71 10			call get_byte 
19f2			 
19f2			 
19f2			;	ld a,(hl) 
19f2			;	call atohex 
19f2			 
19f2			;	call fourehexhl 
19f2 32 d5 ef			ld (scratch+50),a 
19f5			 
19f5			 
19f5			 
19f5 21 d5 19			ld hl,asc+2 
19f8			;	ld a, (hl) 
19f8			;	call nibble2val 
19f8 cd 71 10			call get_byte 
19fb			 
19fb			;	call fourehexhl 
19fb 32 d7 ef			ld (scratch+52),a 
19fe				 
19fe 21 d5 ef			ld hl,scratch+50 
1a01 22 c6 f2			ld (os_cur_ptr),hl 
1a04 c3 7d 19			jp cli 
1a07			 
1a07			enter:	 
1a07 3a a7 ef			ld a,(scratch+4) 
1a0a fe 00			cp 0 
1a0c 28 0c			jr z, .entercont 
1a0e				; no, not a null term line so has an address to work out.... 
1a0e			 
1a0e 21 a5 ef			ld hl,scratch+2 
1a11 cd d1 10			call get_word_hl 
1a14			 
1a14 22 c6 f2			ld (os_cur_ptr),hl	 
1a17 c3 7d 19			jp cli 
1a1a			 
1a1a			 
1a1a			.entercont:  
1a1a			 
1a1a 21 a5 ef			ld hl, scratch+2 
1a1d cd 71 10			call get_byte 
1a20			 
1a20 2a c6 f2		   	ld hl,(os_cur_ptr) 
1a23 77					ld (hl),a 
1a24 23					inc hl 
1a25 22 c6 f2				ld (os_cur_ptr),hl 
1a28				 
1a28			; get byte  
1a28			 
1a28			 
1a28 c3 7d 19			jp cli 
1a2b			 
1a2b			 
1a2b			; basic monitor support 
1a2b			 
1a2b			monitor: 
1a2b				;  
1a2b cd e6 0a			call clear_display 
1a2e 3e 00			ld a, 0 
1a30 11 78 1a			ld de, .monprompt 
1a33 cd f9 0a			call str_at_display 
1a36 cd 09 0b			call update_display 
1a39			 
1a39				; get a monitor command 
1a39			 
1a39 0e 00			ld c, 0     ; entry at top left 
1a3b 16 64			ld d, 100   ; max buffer size 
1a3d 1e 0f			ld e, 15    ; input scroll area 
1a3f 3e 00			ld a, 0     ; init string 
1a41 21 a1 f1			ld hl, os_input 
1a44 77				ld (hl), a 
1a45 23				inc hl 
1a46 77				ld (hl), a 
1a47 21 a1 f1			ld hl, os_input 
1a4a 3e 01			ld a, 1     ; init string 
1a4c cd 47 0d			call input_str 
1a4f			 
1a4f cd e6 0a		        call clear_display 
1a52 cd 09 0b			call update_display		 
1a55			 
1a55 3a a1 f1			ld a, (os_input) 
1a58 cd 6f 11			call toUpper 
1a5b fe 48		        cp 'H' 
1a5d 28 6f		        jr z, .monhelp 
1a5f fe 44			cp 'D'		; dump 
1a61 ca ef 1a			jp z, .mondump	 
1a64 fe 43			cp 'C'		; dump 
1a66 ca 09 1b			jp z, .moncdump	 
1a69 fe 4d			cp 'M'		; dump 
1a6b ca 7a 1a			jp z, .moneditstart 
1a6e fe 55			cp 'U'		; dump 
1a70 28 14			jr z, .monedit	 
1a72 fe 51			cp 'Q'		; dump 
1a74 c8				ret z	 
1a75			 
1a75			 
1a75				; TODO "S" to access symbol by name and not need the address 
1a75				; TODO "F" to find a string in memory 
1a75			 
1a75 c3 2b 1a			jp monitor 
1a78			 
1a78 .. 00		.monprompt: db ">", 0 
1a7a			 
1a7a			.moneditstart: 
1a7a				; get starting address 
1a7a			 
1a7a 21 a3 f1			ld hl,os_input+2 
1a7d cd d1 10			call get_word_hl 
1a80			 
1a80 22 c6 f2			ld (os_cur_ptr),hl	 
1a83			 
1a83 c3 2b 1a			jp monitor 
1a86			 
1a86			.monedit: 
1a86				; get byte to load 
1a86			 
1a86 21 a3 f1			ld hl,os_input+2 
1a89 cd 71 10			call get_byte 
1a8c			 
1a8c				; get address to update 
1a8c 2a c6 f2			ld hl, (os_cur_ptr) 
1a8f			 
1a8f				; update byte 
1a8f			 
1a8f 77				ld (hl), a 
1a90			 
1a90				; move to next address and save it 
1a90			 
1a90 23				inc hl 
1a91 22 c6 f2			ld (os_cur_ptr),hl	 
1a94			 
1a94 c3 2b 1a			jp monitor 
1a97			 
1a97			 
1a97 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1aab .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1ac7 .. 00		.monhelptext3:  db "Q-Quit",0 
1ace			        
1ace			.monhelp: 
1ace 3e 00			ld a, display_row_1 
1ad0 11 97 1a		        ld de, .monhelptext1 
1ad3			 
1ad3 cd f9 0a			call str_at_display 
1ad6 3e 14			ld a, display_row_2 
1ad8 11 ab 1a		        ld de, .monhelptext2 
1adb					 
1adb cd f9 0a			call str_at_display 
1ade 3e 28			ld a, display_row_3 
1ae0 11 c7 1a		        ld de, .monhelptext3 
1ae3					 
1ae3 cd f9 0a			call str_at_display 
1ae6 cd 09 0b			call update_display		 
1ae9			 
1ae9 cd 35 1c			call next_page_prompt 
1aec c3 2b 1a			jp monitor 
1aef			 
1aef			.mondump:    
1aef 21 a3 f1			ld hl,os_input+2 
1af2 cd d1 10			call get_word_hl 
1af5			 
1af5 22 c6 f2			ld (os_cur_ptr),hl	 
1af8 cd 3d 1b			call dumpcont 
1afb 3e 3c			ld a, display_row_4 
1afd 11 d7 19			ld de, endprog 
1b00			 
1b00 cd 09 0b			call update_display		 
1b03			 
1b03 cd 35 1c			call next_page_prompt 
1b06 c3 2b 1a			jp monitor 
1b09			.moncdump: 
1b09 cd 3d 1b			call dumpcont 
1b0c 3e 3c			ld a, display_row_4 
1b0e 11 d7 19			ld de, endprog 
1b11			 
1b11 cd 09 0b			call update_display		 
1b14			 
1b14 cd 35 1c			call next_page_prompt 
1b17 c3 2b 1a			jp monitor 
1b1a			 
1b1a			 
1b1a			; TODO symbol access  
1b1a			 
1b1a			.symbols:     ;; A list of symbols that can be called up  
1b1a 53 fb			dw display_fb0 
1b1c .. 00			db "fb0",0  
1b20 e8 f9		     	dw store_page 
1b22 .. 00			db "store_page",0 
1b2d			 
1b2d			 
1b2d			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b2d			 
1b2d 3a a4 ef			ld a,(scratch+1) 
1b30 fe 00			cp 0 
1b32 28 09			jr z, dumpcont 
1b34			 
1b34				; no, not a null term line so has an address to work out.... 
1b34			 
1b34 21 a5 ef			ld hl,scratch+2 
1b37 cd d1 10			call get_word_hl 
1b3a			 
1b3a 22 c6 f2			ld (os_cur_ptr),hl	 
1b3d			 
1b3d			 
1b3d			 
1b3d			dumpcont: 
1b3d			 
1b3d				; dump bytes at ptr 
1b3d			 
1b3d			 
1b3d 3e 00			ld a, display_row_1 
1b3f 2a 5e fa			ld hl, (display_fb_active) 
1b42 cd 1a 0d			call addatohl 
1b45 cd 6d 1b			call .dumpbyterow 
1b48			 
1b48 3e 14			ld a, display_row_2 
1b4a 2a 5e fa			ld hl, (display_fb_active) 
1b4d cd 1a 0d			call addatohl 
1b50 cd 6d 1b			call .dumpbyterow 
1b53			 
1b53			 
1b53 3e 28			ld a, display_row_3 
1b55 2a 5e fa			ld hl, (display_fb_active) 
1b58 cd 1a 0d			call addatohl 
1b5b cd 6d 1b			call .dumpbyterow 
1b5e			 
1b5e 3e 3c			ld a, display_row_4 
1b60 2a 5e fa			ld hl, (display_fb_active) 
1b63 cd 1a 0d			call addatohl 
1b66 cd 6d 1b			call .dumpbyterow 
1b69			 
1b69 cd 09 0b			call update_display 
1b6c			;		jp cli 
1b6c c9				ret 
1b6d			 
1b6d			.dumpbyterow: 
1b6d			 
1b6d				;push af 
1b6d			 
1b6d e5				push hl 
1b6e			 
1b6e				; calc where to poke the ascii 
1b6e			if display_cols == 20 
1b6e 3e 10			ld a, 16 
1b70			else 
1b70				ld a, 31 
1b70			endif 
1b70			 
1b70 cd 1a 0d			call addatohl 
1b73 22 a8 f2			ld (os_word_scratch),hl  		; save pos for later 
1b76			 
1b76			 
1b76			; display decoding address 
1b76 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b79			 
1b79 7c				ld a,h 
1b7a e1				pop hl 
1b7b e5				push hl 
1b7c			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b7c cd 1b 10			call hexout 
1b7f 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b82			 
1b82 7d				ld a,l 
1b83 e1				pop hl 
1b84 23				inc hl 
1b85 23				inc hl 
1b86 e5				push hl 
1b87			;	ld hl, os_word_scratch+2 
1b87 cd 1b 10			call hexout 
1b8a e1				pop hl 
1b8b 23				inc hl 
1b8c 23				inc hl 
1b8d				;ld hl, os_word_scratch+4 
1b8d 3e 3a			ld a, ':' 
1b8f 77				ld (hl),a 
1b90 23				inc hl 
1b91				;ld a, 0 
1b91				;ld (hl),a 
1b91				;ld de, os_word_scratch 
1b91				;pop af 
1b91				;push af 
1b91			;		ld a, display_row_2 
1b91			;		call str_at_display 
1b91			;		call update_display 
1b91			 
1b91			 
1b91			;pop af 
1b91			;	add 5 
1b91			 
1b91			if display_cols == 20 
1b91 06 04			ld b, 4 
1b93			else 
1b93				ld b, 8 
1b93			endif	 
1b93			 
1b93			.dumpbyte: 
1b93 c5				push bc 
1b94 e5				push hl 
1b95			 
1b95			 
1b95 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b98 7e					ld a,(hl) 
1b99			 
1b99					; poke the ascii to display 
1b99 2a a8 f2				ld hl,(os_word_scratch) 
1b9c 77					ld (hl),a 
1b9d 23					inc hl 
1b9e 22 a8 f2				ld (os_word_scratch),hl 
1ba1			 
1ba1					 
1ba1			 
1ba1			 
1ba1 e1					pop hl 
1ba2 e5					push hl 
1ba3			 
1ba3 cd 1b 10				call hexout 
1ba6			 
1ba6					 
1ba6 2a c6 f2		   	ld hl,(os_cur_ptr) 
1ba9 23				inc hl 
1baa 22 c6 f2		   	ld (os_cur_ptr),hl 
1bad			 
1bad e1					pop hl 
1bae 23					inc hl 
1baf 23					inc hl 
1bb0 23					inc hl 
1bb1			 
1bb1			 
1bb1			 
1bb1					;ld a,0 
1bb1					;ld (os_word_scratch+2),a 
1bb1					;pop af 
1bb1					;push af 
1bb1			 
1bb1					;ld de, os_word_scratch 
1bb1					;call str_at_display 
1bb1			;		call update_display 
1bb1			;		pop af 
1bb1 c1					pop bc 
1bb2 c6 03				add 3 
1bb4 10 dd			djnz .dumpbyte 
1bb6			 
1bb6				 
1bb6			 
1bb6 c9				ret 
1bb7			 
1bb7			jump:	 
1bb7			 
1bb7 21 a5 ef			ld hl,scratch+2 
1bba cd d1 10			call get_word_hl 
1bbd				;ld hl,(scratch+2) 
1bbd				;call fourehexhl 
1bbd			 
1bbd 22 c6 f2			ld (os_cur_ptr),hl	 
1bc0			 
1bc0 e9				jp (hl) 
1bc1			 
1bc1			 
1bc1			 
1bc1			; TODO implement a basic monitor mode to start with 
1bc1			 
1bc1			 
1bc1			 
1bc1			 
1bc1			 
1bc1			 
1bc1			 
1bc1			 
1bc1			 
1bc1			; testing and demo code during development 
1bc1			 
1bc1			 
1bc1 .. 00		str1: db "Enter some text...",0 
1bd4 .. 00		clear: db "                    ",0 
1be9			 
1be9			demo: 
1be9			 
1be9			 
1be9			 
1be9			;	call update_display 
1be9			 
1be9				; init scratch input area for testing 
1be9 21 a3 ef			ld hl, scratch	 
1bec 3e 00			ld a,0 
1bee 77				ld (hl),a 
1bef			 
1bef			 
1bef 3e 14		            LD   A, display_row_2 
1bf1			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bf1 11 c1 1b		            LD   DE, str1 
1bf4 cd f9 0a			call str_at_display 
1bf7			 
1bf7			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bf7			cloop:	 
1bf7 3e 28		            LD   A, display_row_3 
1bf9			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bf9 11 d4 1b		            LD   DE, clear 
1bfc			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1bfc cd f9 0a				call str_at_display 
1bff 3e 3c			ld a, display_row_4 
1c01 11 31 1c			ld de, prompt 
1c04			 
1c04 cd f9 0a				call str_at_display 
1c07 cd 09 0b			call update_display 
1c0a			 
1c0a 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c0c 16 0a			ld d, 10 
1c0e 21 a3 ef			ld hl, scratch	 
1c11 cd 47 0d			call input_str 
1c14			 
1c14			;	call clear_display 
1c14			;'	call update_display 
1c14			 
1c14 3e 00		            LD   A, display_row_1 
1c16			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c16 11 d4 1b		            LD   DE, clear 
1c19 cd f9 0a				call str_at_display 
1c1c			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c1c 3e 00		            LD   A, display_row_1 
1c1e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c1e 11 a3 ef		            LD   DE, scratch 
1c21			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c21 cd f9 0a				call str_at_display 
1c24 cd 09 0b			call update_display 
1c27			 
1c27 3e 00				ld a,0 
1c29 21 a3 ef			ld hl, scratch 
1c2c 77				ld (hl),a 
1c2d			 
1c2d 00				nop 
1c2e c3 f7 1b			jp cloop 
1c31			 
1c31			 
1c31			 
1c31			; OS Prompt 
1c31			 
1c31 .. 00		prompt: db ">",0 
1c33 .. 00		endprg: db "?",0 
1c35			 
1c35			 
1c35			; handy next page prompt 
1c35			next_page_prompt: 
1c35 e5				push hl 
1c36 d5				push de 
1c37 f5				push af 
1c38 c5				push bc 
1c39			 
1c39 3e 4f			ld a,display_row_4 + display_cols - 1 
1c3b 11 33 1c		        ld de, endprg 
1c3e cd f9 0a			call str_at_display 
1c41 cd 09 0b			call update_display 
1c44 cd 21 67			call cin_wait 
1c47 c1				pop bc 
1c48 f1				pop af 
1c49 d1				pop de 
1c4a e1				pop hl 
1c4b			 
1c4b			 
1c4b c9				ret 
1c4c			 
1c4c			 
1c4c			; forth parser 
1c4c			 
1c4c			; My forth kernel 
1c4c			include "forth_kernel.asm" 
1c4c			; 
1c4c			; kernel to the forth OS 
1c4c			 
1c4c			DS_TYPE_STR: equ 1     ; string type 
1c4c			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c4c			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c4c			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c4c			 
1c4c			FORTH_PARSEV1: equ 0 
1c4c			FORTH_PARSEV2: equ 0 
1c4c			FORTH_PARSEV3: equ 0 
1c4c			FORTH_PARSEV4: equ 0 
1c4c			FORTH_PARSEV5: equ 1 
1c4c			 
1c4c			;if FORTH_PARSEV5 
1c4c			;	FORTH_END_BUFFER: equ 0 
1c4c			;else 
1c4c			FORTH_END_BUFFER: equ 127 
1c4c			;endif 
1c4c			 
1c4c			FORTH_TRUE: equ 1 
1c4c			FORTH_FALSE: equ 0 
1c4c			 
1c4c			if FORTH_PARSEV4 
1c4c			include "forth_stackops.asm" 
1c4c			endif 
1c4c			 
1c4c			if FORTH_PARSEV5 
1c4c			include "forth_stackopsv5.asm" 
1c4c			 
1c4c			; Stack operations for v5 parser on wards 
1c4c			; * DATA stack 
1c4c			; * LOOP stack 
1c4c			; * RETURN stack 
1c4c			 
1c4c			 
1c4c			 
1c4c			FORTH_CHK_DSP_UNDER: macro 
1c4c				push hl 
1c4c				push de 
1c4c				ld hl,(cli_data_sp) 
1c4c				ld de, cli_data_stack 
1c4c				call cmp16 
1c4c				jp c, fault_dsp_under 
1c4c				pop de 
1c4c				pop hl 
1c4c				endm 
1c4c			 
1c4c			 
1c4c			FORTH_CHK_RSP_UNDER: macro 
1c4c				push hl 
1c4c				push de 
1c4c				ld hl,(cli_ret_sp) 
1c4c				ld de, cli_ret_stack 
1c4c				call cmp16 
1c4c				jp c, fault_rsp_under 
1c4c				pop de 
1c4c				pop hl 
1c4c				endm 
1c4c			 
1c4c			FORTH_CHK_LOOP_UNDER: macro 
1c4c				push hl 
1c4c				push de 
1c4c				ld hl,(cli_loop_sp) 
1c4c				ld de, cli_loop_stack 
1c4c				call cmp16 
1c4c				jp c, fault_loop_under 
1c4c				pop de 
1c4c				pop hl 
1c4c				endm 
1c4c			 
1c4c			FORTH_ERR_TOS_NOTSTR: macro 
1c4c				; TOSO might need more for checks when used 
1c4c				push af 
1c4c				ld a,(hl) 
1c4c				cp DS_TYPE_STR 
1c4c				jp nz, type_faultn   
1c4c				pop af 
1c4c				endm 
1c4c			 
1c4c			FORTH_ERR_TOS_NOTNUM: macro 
1c4c				push af 
1c4c				ld a,(hl) 
1c4c				cp DS_TYPE_INUM 
1c4c				jp nz, type_faultn   
1c4c				pop af 
1c4c				endm 
1c4c			 
1c4c			 
1c4c			; increase data stack pointer and save hl to it 
1c4c				 
1c4c			FORTH_DSP_NEXT: macro 
1c4c				call macro_forth_dsp_next 
1c4c				endm 
1c4c			 
1c4c			 
1c4c			macro_forth_dsp_next: 
1c4c				if DEBUG_FORTH_STACK_GUARD 
1c4c cd 3c 62				call check_stacks 
1c4f				endif 
1c4f e5				push hl 
1c50 d5				push de 
1c51 eb				ex de,hl 
1c52 2a 90 f9			ld hl,(cli_data_sp) 
1c55 23				inc hl 
1c56 23				inc hl 
1c57			 
1c57			; PARSEV5 
1c57 23				inc hl 
1c58 22 90 f9			ld (cli_data_sp),hl 
1c5b 73				ld (hl), e 
1c5c 23				inc hl 
1c5d 72				ld (hl), d 
1c5e d1				pop de 
1c5f e1				pop hl 
1c60				if DEBUG_FORTH_STACK_GUARD 
1c60 cd 3c 62				call check_stacks 
1c63				endif 
1c63 c9				ret 
1c64			 
1c64			 
1c64			; increase ret stack pointer and save hl to it 
1c64				 
1c64			FORTH_RSP_NEXT: macro 
1c64				call macro_forth_rsp_next 
1c64				endm 
1c64			 
1c64			macro_forth_rsp_next: 
1c64				if DEBUG_FORTH_STACK_GUARD 
1c64 cd 3c 62				call check_stacks 
1c67				endif 
1c67 e5				push hl 
1c68 d5				push de 
1c69 eb				ex de,hl 
1c6a 2a 94 f9			ld hl,(cli_ret_sp) 
1c6d 23				inc hl 
1c6e 23				inc hl 
1c6f 22 94 f9			ld (cli_ret_sp),hl 
1c72 73				ld (hl), e 
1c73 23				inc hl 
1c74 72				ld (hl), d 
1c75 d1				pop de 
1c76 e1				pop hl 
1c77				if DEBUG_FORTH_STACK_GUARD 
1c77 cd 3c 62				call check_stacks 
1c7a				endif 
1c7a c9				ret 
1c7b			 
1c7b			; get current ret stack pointer and save to hl  
1c7b				 
1c7b			FORTH_RSP_TOS: macro 
1c7b				call macro_forth_rsp_tos 
1c7b				endm 
1c7b			 
1c7b			macro_forth_rsp_tos: 
1c7b				;push de 
1c7b 2a 94 f9			ld hl,(cli_ret_sp) 
1c7e cd b6 1c			call loadhlptrtohl 
1c81				;ld e, (hl) 
1c81				;inc hl 
1c81				;ld d, (hl) 
1c81				;ex de, hl 
1c81					if DEBUG_FORTH_WORDS 
1c81			;			DMARK "RST" 
1c81						CALLMONITOR 
1c81 cd 2d 17			call break_point_state  
1c84				endm  
# End of macro CALLMONITOR
1c84					endif 
1c84				;pop de 
1c84 c9				ret 
1c85			 
1c85			; pop ret stack pointer 
1c85				 
1c85			FORTH_RSP_POP: macro 
1c85				call macro_forth_rsp_pop 
1c85				endm 
1c85			 
1c85			 
1c85			macro_forth_rsp_pop: 
1c85				if DEBUG_FORTH_STACK_GUARD 
1c85			;		DMARK "RPP" 
1c85 cd 3c 62				call check_stacks 
1c88					FORTH_CHK_RSP_UNDER 
1c88 e5				push hl 
1c89 d5				push de 
1c8a 2a 94 f9			ld hl,(cli_ret_sp) 
1c8d 11 0e f9			ld de, cli_ret_stack 
1c90 cd 38 0d			call cmp16 
1c93 da 50 63			jp c, fault_rsp_under 
1c96 d1				pop de 
1c97 e1				pop hl 
1c98				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c98				endif 
1c98 e5				push hl 
1c99 2a 94 f9			ld hl,(cli_ret_sp) 
1c9c			 
1c9c			 
1c9c				if FORTH_ENABLE_FREE 
1c9c			 
1c9c					; get pointer 
1c9c			 
1c9c					push de 
1c9c					push hl 
1c9c			 
1c9c					ld e, (hl) 
1c9c					inc hl 
1c9c					ld d, (hl) 
1c9c			 
1c9c					ex de, hl 
1c9c					call free 
1c9c			 
1c9c					pop hl 
1c9c					pop de 
1c9c			 
1c9c			 
1c9c				endif 
1c9c			 
1c9c			 
1c9c 2b				dec hl 
1c9d 2b				dec hl 
1c9e 22 94 f9			ld (cli_ret_sp), hl 
1ca1				; do stack underflow checks 
1ca1 e1				pop hl 
1ca2				if DEBUG_FORTH_STACK_GUARD 
1ca2 cd 3c 62				call check_stacks 
1ca5					FORTH_CHK_RSP_UNDER 
1ca5 e5				push hl 
1ca6 d5				push de 
1ca7 2a 94 f9			ld hl,(cli_ret_sp) 
1caa 11 0e f9			ld de, cli_ret_stack 
1cad cd 38 0d			call cmp16 
1cb0 da 50 63			jp c, fault_rsp_under 
1cb3 d1				pop de 
1cb4 e1				pop hl 
1cb5				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cb5				endif 
1cb5 c9				ret 
1cb6			 
1cb6			 
1cb6			 
1cb6			; routine to load word pointed to by hl into hl 
1cb6			 
1cb6			loadhlptrtohl: 
1cb6			 
1cb6 d5				push de 
1cb7 5e				ld e, (hl) 
1cb8 23				inc hl 
1cb9 56				ld d, (hl) 
1cba eb				ex de, hl 
1cbb d1				pop de 
1cbc			 
1cbc c9				ret 
1cbd			 
1cbd			 
1cbd			 
1cbd			 
1cbd			 
1cbd			; push a number held in HL onto the data stack 
1cbd			; entry point for pushing a value when already in hl used in function above 
1cbd			 
1cbd			forth_push_numhl: 
1cbd			 
1cbd e5				push hl    ; save value to push 
1cbe			 
1cbe			if DEBUG_FORTH_PUSH 
1cbe				; see if disabled 
1cbe			 
1cbe			 
1cbe f5				push af 
1cbf 3a 94 ef			ld a, (os_view_disable) 
1cc2 fe 2a			cp '*' 
1cc4 28 34			jr z, .pskip2 
1cc6 e5				push hl 
1cc7 e5			push hl 
1cc8 cd e6 0a			call clear_display 
1ccb e1			pop hl 
1ccc 7c				ld a,h 
1ccd 21 a8 f2			ld hl, os_word_scratch 
1cd0 cd 1b 10			call hexout 
1cd3 e1				pop hl 
1cd4 7d				ld a,l 
1cd5 21 aa f2			ld hl, os_word_scratch+2 
1cd8 cd 1b 10			call hexout 
1cdb			 
1cdb 21 ac f2			ld hl, os_word_scratch+4 
1cde 3e 00			ld a,0 
1ce0 77				ld (hl),a 
1ce1 11 a8 f2			ld de,os_word_scratch 
1ce4 3e 14				ld a, display_row_2 
1ce6 cd f9 0a				call str_at_display 
1ce9 11 4a 51			ld de, .push_num 
1cec 3e 00			ld a, display_row_1 
1cee			 
1cee cd f9 0a				call str_at_display 
1cf1			 
1cf1			 
1cf1 cd 09 0b			call update_display 
1cf4 cd 66 0a			call delay1s 
1cf7 cd 66 0a			call delay1s 
1cfa			.pskip2:  
1cfa			 
1cfa f1				pop af 
1cfb			endif	 
1cfb			 
1cfb			 
1cfb				FORTH_DSP_NEXT 
1cfb cd 4c 1c			call macro_forth_dsp_next 
1cfe				endm 
# End of macro FORTH_DSP_NEXT
1cfe			 
1cfe 2a 90 f9			ld hl, (cli_data_sp) 
1d01			 
1d01				; save item type 
1d01 3e 02			ld a,  DS_TYPE_INUM 
1d03 77				ld (hl), a 
1d04 23				inc hl 
1d05			 
1d05				; get word off stack 
1d05 d1				pop de 
1d06 7b				ld a,e 
1d07 77				ld (hl), a 
1d08 23				inc hl 
1d09 7a				ld a,d 
1d0a 77				ld (hl), a 
1d0b			 
1d0b			if DEBUG_FORTH_PUSH 
1d0b 2b				dec hl 
1d0c 2b				dec hl 
1d0d 2b				dec hl 
1d0e						DMARK "PH5" 
1d0e f5				push af  
1d0f 3a 23 1d			ld a, (.dmark)  
1d12 32 bd fb			ld (debug_mark),a  
1d15 3a 24 1d			ld a, (.dmark+1)  
1d18 32 be fb			ld (debug_mark+1),a  
1d1b 3a 25 1d			ld a, (.dmark+2)  
1d1e 32 bf fb			ld (debug_mark+2),a  
1d21 18 03			jr .pastdmark  
1d23 ..			.dmark: db "PH5"  
1d26 f1			.pastdmark: pop af  
1d27			endm  
# End of macro DMARK
1d27				CALLMONITOR 
1d27 cd 2d 17			call break_point_state  
1d2a				endm  
# End of macro CALLMONITOR
1d2a			endif	 
1d2a			 
1d2a c9				ret 
1d2b			 
1d2b			 
1d2b			; Push a string to stack pointed to by hl 
1d2b			 
1d2b			forth_push_str: 
1d2b			 
1d2b			if DEBUG_FORTH_PUSH 
1d2b						DMARK "PSQ" 
1d2b f5				push af  
1d2c 3a 40 1d			ld a, (.dmark)  
1d2f 32 bd fb			ld (debug_mark),a  
1d32 3a 41 1d			ld a, (.dmark+1)  
1d35 32 be fb			ld (debug_mark+1),a  
1d38 3a 42 1d			ld a, (.dmark+2)  
1d3b 32 bf fb			ld (debug_mark+2),a  
1d3e 18 03			jr .pastdmark  
1d40 ..			.dmark: db "PSQ"  
1d43 f1			.pastdmark: pop af  
1d44			endm  
# End of macro DMARK
1d44				CALLMONITOR 
1d44 cd 2d 17			call break_point_state  
1d47				endm  
# End of macro CALLMONITOR
1d47			endif	 
1d47			    
1d47 e5				push hl 
1d48 e5				push hl 
1d49			 
1d49			;	ld a, 0   ; find end of string 
1d49 cd 78 11			call strlenz 
1d4c			if DEBUG_FORTH_PUSH 
1d4c						DMARK "PQ2" 
1d4c f5				push af  
1d4d 3a 61 1d			ld a, (.dmark)  
1d50 32 bd fb			ld (debug_mark),a  
1d53 3a 62 1d			ld a, (.dmark+1)  
1d56 32 be fb			ld (debug_mark+1),a  
1d59 3a 63 1d			ld a, (.dmark+2)  
1d5c 32 bf fb			ld (debug_mark+2),a  
1d5f 18 03			jr .pastdmark  
1d61 ..			.dmark: db "PQ2"  
1d64 f1			.pastdmark: pop af  
1d65			endm  
# End of macro DMARK
1d65				CALLMONITOR 
1d65 cd 2d 17			call break_point_state  
1d68				endm  
# End of macro CALLMONITOR
1d68			endif	 
1d68 eb				ex de, hl 
1d69 e1				pop hl   ; get ptr to start of string 
1d6a			if DEBUG_FORTH_PUSH 
1d6a						DMARK "PQ3" 
1d6a f5				push af  
1d6b 3a 7f 1d			ld a, (.dmark)  
1d6e 32 bd fb			ld (debug_mark),a  
1d71 3a 80 1d			ld a, (.dmark+1)  
1d74 32 be fb			ld (debug_mark+1),a  
1d77 3a 81 1d			ld a, (.dmark+2)  
1d7a 32 bf fb			ld (debug_mark+2),a  
1d7d 18 03			jr .pastdmark  
1d7f ..			.dmark: db "PQ3"  
1d82 f1			.pastdmark: pop af  
1d83			endm  
# End of macro DMARK
1d83				CALLMONITOR 
1d83 cd 2d 17			call break_point_state  
1d86				endm  
# End of macro CALLMONITOR
1d86			endif	 
1d86 19				add hl,de 
1d87			if DEBUG_FORTH_PUSH 
1d87						DMARK "PQE" 
1d87 f5				push af  
1d88 3a 9c 1d			ld a, (.dmark)  
1d8b 32 bd fb			ld (debug_mark),a  
1d8e 3a 9d 1d			ld a, (.dmark+1)  
1d91 32 be fb			ld (debug_mark+1),a  
1d94 3a 9e 1d			ld a, (.dmark+2)  
1d97 32 bf fb			ld (debug_mark+2),a  
1d9a 18 03			jr .pastdmark  
1d9c ..			.dmark: db "PQE"  
1d9f f1			.pastdmark: pop af  
1da0			endm  
# End of macro DMARK
1da0				CALLMONITOR 
1da0 cd 2d 17			call break_point_state  
1da3				endm  
# End of macro CALLMONITOR
1da3			endif	 
1da3			 
1da3 2b				dec hl    ; see if there is an optional trailing double quote 
1da4 7e				ld a,(hl) 
1da5 fe 22			cp '"' 
1da7 20 03			jr nz, .strnoq 
1da9 3e 00			ld a, 0      ; get rid of double quote 
1dab 77				ld (hl), a 
1dac 23			.strnoq: inc hl 
1dad			 
1dad 3e 00			ld a, 0 
1daf 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1db0			 
1db0 13				inc de ; add one for the type string 
1db1 13				inc de ; add one for null term??? 
1db2			 
1db2				; tos is get string pointer again 
1db2				; de contains space to allocate 
1db2				 
1db2 d5				push de 
1db3			 
1db3 eb				ex de, hl 
1db4			 
1db4				;push af 
1db4			 
1db4			if DEBUG_FORTH_PUSH 
1db4						DMARK "PHm" 
1db4 f5				push af  
1db5 3a c9 1d			ld a, (.dmark)  
1db8 32 bd fb			ld (debug_mark),a  
1dbb 3a ca 1d			ld a, (.dmark+1)  
1dbe 32 be fb			ld (debug_mark+1),a  
1dc1 3a cb 1d			ld a, (.dmark+2)  
1dc4 32 bf fb			ld (debug_mark+2),a  
1dc7 18 03			jr .pastdmark  
1dc9 ..			.dmark: db "PHm"  
1dcc f1			.pastdmark: pop af  
1dcd			endm  
# End of macro DMARK
1dcd				CALLMONITOR 
1dcd cd 2d 17			call break_point_state  
1dd0				endm  
# End of macro CALLMONITOR
1dd0			endif	 
1dd0 cd e1 11			call malloc	; on ret hl now contains allocated memory 
1dd3				if DEBUG_FORTH_MALLOC_GUARD 
1dd3 cc a2 51				call z,malloc_error 
1dd6				endif 
1dd6			 
1dd6				 
1dd6 c1				pop bc    ; get length 
1dd7 d1				pop de   ;  get string start    
1dd8			 
1dd8				; hl has destination from malloc 
1dd8			 
1dd8 eb				ex de, hl    ; prep for ldir 
1dd9			 
1dd9 d5				push de   ; save malloc area for DSP later 
1dda				;push hl   ; save malloc area for DSP later 
1dda			 
1dda			if DEBUG_FORTH_PUSH 
1dda						DMARK "PHc" 
1dda f5				push af  
1ddb 3a ef 1d			ld a, (.dmark)  
1dde 32 bd fb			ld (debug_mark),a  
1de1 3a f0 1d			ld a, (.dmark+1)  
1de4 32 be fb			ld (debug_mark+1),a  
1de7 3a f1 1d			ld a, (.dmark+2)  
1dea 32 bf fb			ld (debug_mark+2),a  
1ded 18 03			jr .pastdmark  
1def ..			.dmark: db "PHc"  
1df2 f1			.pastdmark: pop af  
1df3			endm  
# End of macro DMARK
1df3				CALLMONITOR 
1df3 cd 2d 17			call break_point_state  
1df6				endm  
# End of macro CALLMONITOR
1df6			endif	 
1df6			 
1df6			 
1df6 ed b0			ldir 
1df8			 
1df8			 
1df8				; push malloc to data stack     macro?????  
1df8			 
1df8				FORTH_DSP_NEXT 
1df8 cd 4c 1c			call macro_forth_dsp_next 
1dfb				endm 
# End of macro FORTH_DSP_NEXT
1dfb			 
1dfb				; save value and type 
1dfb			 
1dfb 2a 90 f9			ld hl, (cli_data_sp) 
1dfe			 
1dfe				; save item type 
1dfe 3e 01			ld a,  DS_TYPE_STR 
1e00 77				ld (hl), a 
1e01 23				inc hl 
1e02			 
1e02				; get malloc word off stack 
1e02 d1				pop de 
1e03 73				ld (hl), e 
1e04 23				inc hl 
1e05 72				ld (hl), d 
1e06			 
1e06			 
1e06			 
1e06			if DEBUG_FORTH_PUSH 
1e06 2a 90 f9			ld hl, (cli_data_sp) 
1e09						DMARK "PHS" 
1e09 f5				push af  
1e0a 3a 1e 1e			ld a, (.dmark)  
1e0d 32 bd fb			ld (debug_mark),a  
1e10 3a 1f 1e			ld a, (.dmark+1)  
1e13 32 be fb			ld (debug_mark+1),a  
1e16 3a 20 1e			ld a, (.dmark+2)  
1e19 32 bf fb			ld (debug_mark+2),a  
1e1c 18 03			jr .pastdmark  
1e1e ..			.dmark: db "PHS"  
1e21 f1			.pastdmark: pop af  
1e22			endm  
# End of macro DMARK
1e22				CALLMONITOR 
1e22 cd 2d 17			call break_point_state  
1e25				endm  
# End of macro CALLMONITOR
1e25			;	ex de,hl 
1e25			endif	 
1e25				; in case of spaces, skip the ptr past the copied string 
1e25				;pop af 
1e25				;ld (cli_origptr),hl 
1e25			 
1e25 c9				ret 
1e26			 
1e26			 
1e26			 
1e26			; TODO ascii push input onto stack given hl to start of input 
1e26			 
1e26			; identify type 
1e26			; if starts with a " then a string 
1e26			; otherwise it is a number 
1e26			;  
1e26			; if a string 
1e26			;     scan for ending " to get length of string to malloc for + 1 
1e26			;     malloc 
1e26			;     put pointer to string on stack first byte flags as string 
1e26			; 
1e26			; else a number 
1e26			;    look for number format identifier 
1e26			;    $xx hex 
1e26			;    %xxxxx bin 
1e26			;    xxxxx decimal 
1e26			;    convert number to 16bit word.  
1e26			;    malloc word + 1 with flag to identiy as num 
1e26			;    put pointer to number on stack 
1e26			;   
1e26			;  
1e26			  
1e26			forth_apush: 
1e26				; kernel push 
1e26			 
1e26			if DEBUG_FORTH_PUSH 
1e26						DMARK "PSH" 
1e26 f5				push af  
1e27 3a 3b 1e			ld a, (.dmark)  
1e2a 32 bd fb			ld (debug_mark),a  
1e2d 3a 3c 1e			ld a, (.dmark+1)  
1e30 32 be fb			ld (debug_mark+1),a  
1e33 3a 3d 1e			ld a, (.dmark+2)  
1e36 32 bf fb			ld (debug_mark+2),a  
1e39 18 03			jr .pastdmark  
1e3b ..			.dmark: db "PSH"  
1e3e f1			.pastdmark: pop af  
1e3f			endm  
# End of macro DMARK
1e3f				CALLMONITOR 
1e3f cd 2d 17			call break_point_state  
1e42				endm  
# End of macro CALLMONITOR
1e42			endif	 
1e42				; identify input type 
1e42			 
1e42 7e				ld a,(hl) 
1e43 fe 22			cp '"' 
1e45 28 0a			jr z, .fapstr 
1e47 fe 24			cp '$' 
1e49 ca 71 1e			jp z, .faphex 
1e4c fe 25			cp '%' 
1e4e ca 59 1e			jp z, .fapbin 
1e51			;	cp 'b' 
1e51			;	jp z, .fabin 
1e51				; else decimal 
1e51			 
1e51				; TODO do decimal conversion 
1e51				; decimal is stored as a 16bit word 
1e51			 
1e51				; by default everything is a string if type is not detected 
1e51			.fapstr: ; 
1e51 fe 22			cp '"' 
1e53 20 01			jr nz, .strnoqu 
1e55 23				inc hl 
1e56			.strnoqu: 
1e56 c3 2b 1d			jp forth_push_str 
1e59			 
1e59			 
1e59			 
1e59			.fapbin:    ; push a binary string.  
1e59 11 00 00			ld de, 0   ; hold a 16bit value 
1e5c			 
1e5c 23			.fapbinshift:	inc hl  
1e5d 7e				ld a,(hl) 
1e5e fe 00			cp 0     ; done scanning  
1e60 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e62			 
1e62				; left shift de 
1e62 eb				ex de, hl	 
1e63 29				add hl, hl 
1e64			 
1e64				; is 1 
1e64 fe 31			cp '1' 
1e66 20 02			jr nz, .binzero 
1e68 cb 4d			bit 1, l 
1e6a			.binzero: 
1e6a eb				ex de, hl	 ; save current de 
1e6b 18 ef			jr .fapbinshift 
1e6d			 
1e6d			.fapbdone: 
1e6d eb				ex de, hl 
1e6e c3 bd 1c			jp forth_push_numhl 
1e71			 
1e71			 
1e71			.faphex:   ; hex is always stored as a 16bit word 
1e71				; skip number prefix 
1e71 23				inc hl 
1e72				; turn ascii into number 
1e72 cd d1 10			call get_word_hl	; ret 16bit word in hl 
1e75			 
1e75 c3 bd 1c			jp forth_push_numhl 
1e78			 
1e78 00				 nop 
1e79			 
1e79			.fabin:   ; TODO bin conversion 
1e79			 
1e79			 
1e79 c9				ret 
1e7a			 
1e7a			 
1e7a			; get either a string ptr or a 16bit word from the data stack 
1e7a			 
1e7a			FORTH_DSP: macro 
1e7a				call macro_forth_dsp 
1e7a				endm 
1e7a			 
1e7a			macro_forth_dsp: 
1e7a				; data stack pointer points to current word on tos 
1e7a			 
1e7a 2a 90 f9			ld hl,(cli_data_sp) 
1e7d			 
1e7d				if DEBUG_FORTH_PUSH 
1e7d						DMARK "DSP" 
1e7d f5				push af  
1e7e 3a 92 1e			ld a, (.dmark)  
1e81 32 bd fb			ld (debug_mark),a  
1e84 3a 93 1e			ld a, (.dmark+1)  
1e87 32 be fb			ld (debug_mark+1),a  
1e8a 3a 94 1e			ld a, (.dmark+2)  
1e8d 32 bf fb			ld (debug_mark+2),a  
1e90 18 03			jr .pastdmark  
1e92 ..			.dmark: db "DSP"  
1e95 f1			.pastdmark: pop af  
1e96			endm  
# End of macro DMARK
1e96			 
1e96 cd d7 51				call display_data_sp 
1e99				;call break_point_state 
1e99				;rst 030h 
1e99				CALLMONITOR 
1e99 cd 2d 17			call break_point_state  
1e9c				endm  
# End of macro CALLMONITOR
1e9c				endif 
1e9c			 
1e9c c9				ret 
1e9d			 
1e9d			; return hl to start of value on stack 
1e9d			 
1e9d			FORTH_DSP_VALUE: macro 
1e9d				call macro_forth_dsp_value 
1e9d				endm 
1e9d			 
1e9d			macro_forth_dsp_value: 
1e9d			 
1e9d				FORTH_DSP 
1e9d cd 7a 1e			call macro_forth_dsp 
1ea0				endm 
# End of macro FORTH_DSP
1ea0			 
1ea0 d5				push de 
1ea1			 
1ea1 23				inc hl ; skip type 
1ea2			 
1ea2 5e				ld e, (hl) 
1ea3 23				inc hl 
1ea4 56				ld d, (hl) 
1ea5 eb				ex de,hl  
1ea6			 
1ea6 d1				pop de 
1ea7			 
1ea7 c9				ret 
1ea8			 
1ea8			; return hl to start of value to second item on stack 
1ea8			 
1ea8			FORTH_DSP_VALUEM1: macro 
1ea8				call macro_forth_dsp_value_m1 
1ea8				endm 
1ea8			 
1ea8			macro_forth_dsp_value_m1: 
1ea8			 
1ea8				FORTH_DSP 
1ea8 cd 7a 1e			call macro_forth_dsp 
1eab				endm 
# End of macro FORTH_DSP
1eab			 
1eab 2b				dec hl 
1eac 2b				dec hl 
1ead			;	dec hl 
1ead			 
1ead d5				push de 
1eae			 
1eae 5e				ld e, (hl) 
1eaf 23				inc hl 
1eb0 56				ld d, (hl) 
1eb1 eb				ex de,hl  
1eb2			 
1eb2 d1				pop de 
1eb3			 
1eb3 c9				ret 
1eb4			 
1eb4				 
1eb4			 
1eb4			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1eb4			 
1eb4			FORTH_DSP_POP: macro 
1eb4				call macro_forth_dsp_pop 
1eb4				endm 
1eb4			 
1eb4			 
1eb4			; get the tos data type 
1eb4			 
1eb4			FORTH_DSP_TYPE:   macro 
1eb4			 
1eb4				;FORTH_DSP_VALUE 
1eb4				FORTH_DSP 
1eb4				 
1eb4				; hl points to value 
1eb4				; check type 
1eb4			 
1eb4				ld a,(hl) 
1eb4			 
1eb4				endm 
1eb4			 
1eb4			; load the tos value into hl 
1eb4			 
1eb4			 
1eb4			FORTH_DSP_VALUEHL:  macro 
1eb4				call macro_dsp_valuehl 
1eb4				endm 
1eb4			 
1eb4			 
1eb4			 
1eb4			macro_dsp_valuehl: 
1eb4				FORTH_DSP_VALUE 
1eb4 cd 9d 1e			call macro_forth_dsp_value 
1eb7				endm 
# End of macro FORTH_DSP_VALUE
1eb7			 
1eb7				;FORTH_ERR_TOS_NOTNUM 
1eb7			 
1eb7				;inc hl   ; skip type id 
1eb7			 
1eb7			;	push de 
1eb7			; 
1eb7			;	ld e, (hl) 
1eb7			;	inc hl 
1eb7			;	ld d, (hl) 
1eb7			;	ex de,hl  
1eb7			 
1eb7			;	pop de 
1eb7			 
1eb7				if DEBUG_FORTH_PUSH 
1eb7						DMARK "DVL" 
1eb7 f5				push af  
1eb8 3a cc 1e			ld a, (.dmark)  
1ebb 32 bd fb			ld (debug_mark),a  
1ebe 3a cd 1e			ld a, (.dmark+1)  
1ec1 32 be fb			ld (debug_mark+1),a  
1ec4 3a ce 1e			ld a, (.dmark+2)  
1ec7 32 bf fb			ld (debug_mark+2),a  
1eca 18 03			jr .pastdmark  
1ecc ..			.dmark: db "DVL"  
1ecf f1			.pastdmark: pop af  
1ed0			endm  
# End of macro DMARK
1ed0				CALLMONITOR 
1ed0 cd 2d 17			call break_point_state  
1ed3				endm  
# End of macro CALLMONITOR
1ed3				endif 
1ed3 c9				ret 
1ed4			 
1ed4			forth_apushstrhl:      
1ed4				; push of string requires use of cli_origptr 
1ed4				; bodge use 
1ed4			 
1ed4				; get current cli_origptr, save, update with temp pointer  
1ed4 ed 5b ac f9		ld de, (cli_origptr) 
1ed8 22 ac f9			ld (cli_origptr), hl 
1edb d5				push de 
1edc cd 26 1e			call forth_apush 
1edf d1				pop de 
1ee0 ed 53 ac f9		ld (cli_origptr), de 
1ee4 c9			        ret	 
1ee5			 
1ee5			 
1ee5			; increase loop stack pointer and save hl to it 
1ee5				 
1ee5			FORTH_LOOP_NEXT: macro 
1ee5				call macro_forth_loop_next 
1ee5				;nop 
1ee5				endm 
1ee5			 
1ee5			macro_forth_loop_next: 
1ee5				if DEBUG_FORTH_STACK_GUARD 
1ee5 cd 3c 62				call check_stacks 
1ee8				endif 
1ee8 e5				push hl 
1ee9 d5				push de 
1eea eb				ex de,hl 
1eeb 2a 92 f9			ld hl,(cli_loop_sp) 
1eee 23				inc hl 
1eef 23				inc hl 
1ef0					if DEBUG_FORTH_WORDS 
1ef0						DMARK "LNX" 
1ef0 f5				push af  
1ef1 3a 05 1f			ld a, (.dmark)  
1ef4 32 bd fb			ld (debug_mark),a  
1ef7 3a 06 1f			ld a, (.dmark+1)  
1efa 32 be fb			ld (debug_mark+1),a  
1efd 3a 07 1f			ld a, (.dmark+2)  
1f00 32 bf fb			ld (debug_mark+2),a  
1f03 18 03			jr .pastdmark  
1f05 ..			.dmark: db "LNX"  
1f08 f1			.pastdmark: pop af  
1f09			endm  
# End of macro DMARK
1f09						CALLMONITOR 
1f09 cd 2d 17			call break_point_state  
1f0c				endm  
# End of macro CALLMONITOR
1f0c					endif 
1f0c 22 92 f9			ld (cli_loop_sp),hl 
1f0f 73				ld (hl), e 
1f10 23				inc hl 
1f11 72				ld (hl), d 
1f12 d1				pop de    ; been reversed so save a swap on restore 
1f13 e1				pop hl 
1f14				if DEBUG_FORTH_STACK_GUARD 
1f14 cd 3c 62				call check_stacks 
1f17				endif 
1f17 c9				ret 
1f18			 
1f18			; get current ret stack pointer and save to hl  
1f18				 
1f18			FORTH_LOOP_TOS: macro 
1f18				call macro_forth_loop_tos 
1f18				endm 
1f18			 
1f18			macro_forth_loop_tos: 
1f18 d5				push de 
1f19 2a 92 f9			ld hl,(cli_loop_sp) 
1f1c 5e				ld e, (hl) 
1f1d 23				inc hl 
1f1e 56				ld d, (hl) 
1f1f eb				ex de, hl 
1f20 d1				pop de 
1f21 c9				ret 
1f22			 
1f22			; pop loop stack pointer 
1f22				 
1f22			FORTH_LOOP_POP: macro 
1f22				call macro_forth_loop_pop 
1f22				endm 
1f22			 
1f22			 
1f22			macro_forth_loop_pop: 
1f22				if DEBUG_FORTH_STACK_GUARD 
1f22					DMARK "LPP" 
1f22 f5				push af  
1f23 3a 37 1f			ld a, (.dmark)  
1f26 32 bd fb			ld (debug_mark),a  
1f29 3a 38 1f			ld a, (.dmark+1)  
1f2c 32 be fb			ld (debug_mark+1),a  
1f2f 3a 39 1f			ld a, (.dmark+2)  
1f32 32 bf fb			ld (debug_mark+2),a  
1f35 18 03			jr .pastdmark  
1f37 ..			.dmark: db "LPP"  
1f3a f1			.pastdmark: pop af  
1f3b			endm  
# End of macro DMARK
1f3b cd 3c 62				call check_stacks 
1f3e					FORTH_CHK_LOOP_UNDER 
1f3e e5				push hl 
1f3f d5				push de 
1f40 2a 92 f9			ld hl,(cli_loop_sp) 
1f43 11 0c f7			ld de, cli_loop_stack 
1f46 cd 38 0d			call cmp16 
1f49 da 56 63			jp c, fault_loop_under 
1f4c d1				pop de 
1f4d e1				pop hl 
1f4e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f4e				endif 
1f4e e5				push hl 
1f4f 2a 92 f9			ld hl,(cli_loop_sp) 
1f52 2b				dec hl 
1f53 2b				dec hl 
1f54 22 92 f9			ld (cli_loop_sp), hl 
1f57				; TODO do stack underflow checks 
1f57 e1				pop hl 
1f58				if DEBUG_FORTH_STACK_GUARD 
1f58 cd 3c 62				call check_stacks 
1f5b					FORTH_CHK_LOOP_UNDER 
1f5b e5				push hl 
1f5c d5				push de 
1f5d 2a 92 f9			ld hl,(cli_loop_sp) 
1f60 11 0c f7			ld de, cli_loop_stack 
1f63 cd 38 0d			call cmp16 
1f66 da 56 63			jp c, fault_loop_under 
1f69 d1				pop de 
1f6a e1				pop hl 
1f6b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f6b				endif 
1f6b c9				ret 
1f6c			 
1f6c			macro_forth_dsp_pop: 
1f6c			 
1f6c e5				push hl 
1f6d			 
1f6d				; release malloc data 
1f6d			 
1f6d				if DEBUG_FORTH_STACK_GUARD 
1f6d cd 3c 62				call check_stacks 
1f70					FORTH_CHK_DSP_UNDER 
1f70 e5				push hl 
1f71 d5				push de 
1f72 2a 90 f9			ld hl,(cli_data_sp) 
1f75 11 0a f5			ld de, cli_data_stack 
1f78 cd 38 0d			call cmp16 
1f7b da 4a 63			jp c, fault_dsp_under 
1f7e d1				pop de 
1f7f e1				pop hl 
1f80				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f80				endif 
1f80				;ld hl,(cli_data_sp) 
1f80			if DEBUG_FORTH_DOT 
1f80				DMARK "DPP" 
1f80				CALLMONITOR 
1f80			endif	 
1f80			 
1f80			 
1f80			if FORTH_ENABLE_DSPPOPFREE 
1f80			 
1f80				FORTH_DSP 
1f80 cd 7a 1e			call macro_forth_dsp 
1f83				endm 
# End of macro FORTH_DSP
1f83			 
1f83 7e				ld a, (hl) 
1f84 fe 01			cp DS_TYPE_STR 
1f86 20 07			jr nz, .skippopfree 
1f88			 
1f88				FORTH_DSP_VALUEHL 
1f88 cd b4 1e			call macro_dsp_valuehl 
1f8b				endm 
# End of macro FORTH_DSP_VALUEHL
1f8b 00				nop 
1f8c			if DEBUG_FORTH_DOT 
1f8c				DMARK "DPf" 
1f8c				CALLMONITOR 
1f8c			endif	 
1f8c cd ab 12			call free 
1f8f			.skippopfree: 
1f8f				 
1f8f			 
1f8f			endif 
1f8f			 
1f8f			if DEBUG_FORTH_DOT_KEY 
1f8f				DMARK "DP2" 
1f8f				CALLMONITOR 
1f8f			endif	 
1f8f			 
1f8f				; move pointer down 
1f8f			 
1f8f 2a 90 f9			ld hl,(cli_data_sp) 
1f92 2b				dec hl 
1f93 2b				dec hl 
1f94			; PARSEV5 
1f94 2b				dec hl 
1f95 22 90 f9			ld (cli_data_sp), hl 
1f98			 
1f98				if DEBUG_FORTH_STACK_GUARD 
1f98 cd 3c 62				call check_stacks 
1f9b					FORTH_CHK_DSP_UNDER 
1f9b e5				push hl 
1f9c d5				push de 
1f9d 2a 90 f9			ld hl,(cli_data_sp) 
1fa0 11 0a f5			ld de, cli_data_stack 
1fa3 cd 38 0d			call cmp16 
1fa6 da 4a 63			jp c, fault_dsp_under 
1fa9 d1				pop de 
1faa e1				pop hl 
1fab				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fab				endif 
1fab			 
1fab e1				pop hl 
1fac			 
1fac c9				ret 
1fad			 
1fad			getwordathl: 
1fad				; hl points to an address 
1fad				; load hl with the word at that address 
1fad			 
1fad d5				push de 
1fae			 
1fae 5e				ld e, (hl) 
1faf 23				inc hl 
1fb0 56				ld d, (hl) 
1fb1 eb				ex de, hl 
1fb2			 
1fb2 d1				pop de 
1fb3 c9				ret 
1fb4			 
1fb4			 
1fb4			 
1fb4			 
1fb4			 
1fb4			; eof 
1fb4			 
# End of file forth_stackopsv5.asm
1fb4			endif 
1fb4			 
1fb4			user_word_eol:  
1fb4				; hl contains the pointer to where to create a linked list item from the end 
1fb4				; of the user dict to continue on at the system word dict 
1fb4				 
1fb4				; poke the stub of the word list linked list to repoint to rom words 
1fb4			 
1fb4				; stub format 
1fb4				; db   word id 
1fb4				; dw    link to next word 
1fb4			        ; db char length of token 
1fb4				; db string + 0 term 
1fb4				; db exec code....  
1fb4			 
1fb4 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1fb6 77				ld (hl), a		; word id 
1fb7 23				inc hl 
1fb8			 
1fb8 11 7e 21			ld de, sysdict 
1fbb 73				ld (hl), e		; next word link ie system dict 
1fbc 23				inc hl 
1fbd 72				ld (hl), d		; next word link ie system dict 
1fbe 23				inc hl	 
1fbf			 
1fbf			;	ld (hl), sysdict		; next word link ie system dict 
1fbf			;	inc hl 
1fbf			;	inc hl 
1fbf			 
1fbf			;	inc hl 
1fbf			;	inc hl 
1fbf			 
1fbf 3e 02			ld a, 2			; word length is 0 
1fc1 77				ld (hl), a	 
1fc2 23				inc hl 
1fc3			 
1fc3 3e 7e			ld a, '~'			; word length is 0 
1fc5 77				ld (hl), a	 
1fc6 23				inc hl 
1fc7 3e 00			ld a, 0			; save empty word 
1fc9 77				ld (hl), a 
1fca			 
1fca c9				ret 
1fcb			 
1fcb				 
1fcb			 
1fcb			forthexec_cleanup: 
1fcb				FORTH_RSP_POP 
1fcb cd 85 1c			call macro_forth_rsp_pop 
1fce				endm 
# End of macro FORTH_RSP_POP
1fce c9				ret 
1fcf			 
1fcf			forth_call_hl: 
1fcf				; taking hl 
1fcf e5				push hl 
1fd0 c9				ret 
1fd1			 
1fd1			; this is called to reset Forth system but keep existing uwords etc 
1fd1			 
1fd1			forth_warmstart: 
1fd1				; setup stack over/under flow checks 
1fd1				if DEBUG_FORTH_STACK_GUARD 
1fd1 cd 22 62				call chk_stk_init 
1fd4				endif 
1fd4			 
1fd4				; init stack pointers  - * these stacks go upwards *  
1fd4 21 0e f9			ld hl, cli_ret_stack 
1fd7 22 94 f9			ld (cli_ret_sp), hl	 
1fda				; set bottom of stack 
1fda 3e 00			ld a,0 
1fdc 77				ld (hl),a 
1fdd 23				inc hl 
1fde 77				ld (hl),a 
1fdf			 
1fdf 21 0a f5			ld hl, cli_data_stack 
1fe2 22 90 f9			ld (cli_data_sp), hl	 
1fe5				; set bottom of stack 
1fe5 3e 00			ld a,0 
1fe7 77				ld (hl),a 
1fe8 23				inc hl 
1fe9 77				ld (hl),a 
1fea			 
1fea 21 0c f7			ld hl, cli_loop_stack 
1fed 22 92 f9			ld (cli_loop_sp), hl	 
1ff0				; set bottom of stack 
1ff0 3e 00			ld a,0 
1ff2 77				ld (hl),a 
1ff3 23				inc hl 
1ff4 77				ld (hl),a 
1ff5			 
1ff5				; init extent of current open file 
1ff5			 
1ff5 3e 00			ld a, 0 
1ff7 32 df f9			ld (store_openext), a 
1ffa			 
1ffa c9				ret 
1ffb			 
1ffb			 
1ffb			; Cold Start - this is called to setup the whole Forth system 
1ffb			 
1ffb			forth_init: 
1ffb			 
1ffb				; setup stack over/under flow checks 
1ffb			 
1ffb			;	if DEBUG_FORTH_STACK_GUARD 
1ffb			;		call chk_stk_init 
1ffb			;	endif 
1ffb			 
1ffb				; enable auto display updates (slow.....) 
1ffb			 
1ffb 3e 01			ld a, 1 
1ffd 32 aa f9			ld (cli_autodisplay), a 
2000			 
2000			 
2000			 
2000				; show start up screen 
2000			 
2000 cd e6 0a			call clear_display 
2003			 
2003 3e 00			ld a,0 
2005 32 cc f9			ld (f_cursor_ptr), a 
2008			 
2008				; set start of word list in start of ram - for use when creating user words 
2008			 
2008 21 00 80			ld hl, baseram 
200b 22 a0 f2			ld (os_last_new_uword), hl 
200e cd b4 1f			call user_word_eol 
2011				 
2011			;		call display_data_sp 
2011			;		call next_page_prompt 
2011			 
2011			 
2011			 
2011			 
2011 c9				ret 
2012			 
2012 .. 00		.bootforth: db " Forth Kernel Init ",0 
2026			 
2026			; TODO push to stack 
2026			 
2026			;  
2026			 
2026			if FORTH_PARSEV2 
2026			 
2026			 
2026				include "forth_parserv2.asm" 
2026			 
2026			endif 
2026			 
2026			 
2026			; parse cli version 1 
2026			 
2026			if FORTH_PARSEV1 
2026			 
2026			 
2026			 
2026			      include "forth_parserv1.asm" 
2026			endif 
2026				 
2026			if FORTH_PARSEV3 
2026			 
2026			 
2026			 
2026			      include "forth_parserv3.asm" 
2026				include "forth_wordsv3.asm" 
2026			endif 
2026			 
2026			if FORTH_PARSEV4 
2026			 
2026			 
2026			 
2026			      include "forth_parserv4.asm" 
2026				include "forth_wordsv4.asm" 
2026			endif 
2026			 
2026			if FORTH_PARSEV5 
2026			 
2026			 
2026			 
2026			      include "forth_parserv5.asm" 
2026			 
2026			 
2026			; A better parser without using malloc and string copies all over the place.  
2026			; Exec in situ should be faster 
2026			 
2026			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2026			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2026			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2026			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2026			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2026			WORD_SYS_END: equ 0   ; Opcode for all user words 
2026			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2026			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2026			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2026			 
2026			; Core word preamble macro 
2026			 
2026			CWHEAD:   macro nxtword opcode lit len opflags 
2026				db WORD_SYS_CORE+opcode             
2026				; internal op code number 
2026				dw nxtword            
2026				; link to next dict word block 
2026				db len + 1 
2026				; literal length of dict word inc zero term 
2026				db lit,0              
2026				; literal dict word 
2026			        ; TODO db opflags        
2026				endm 
2026			 
2026			 
2026			NEXTW: macro  
2026				jp macro_next 
2026				endm 
2026			 
2026			macro_next: 
2026			if DEBUG_FORTH_PARSE_KEY 
2026				DMARK "NXT" 
2026				CALLMONITOR 
2026			endif	 
2026			;	inc hl  ; skip token null term  
2026 ed 4b ae f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
202a ed 5b ac f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
202e 2a a4 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2031			if DEBUG_FORTH_PARSE_KEY 
2031				DMARK "}AA" 
2031				CALLMONITOR 
2031			endif	 
2031 c3 34 21			jp execnext 
2034				;jp exec1 
2034			       
2034			 
2034			 
2034			; Another go at the parser to compile  
2034			 
2034			 
2034			; TODO rework parser to change all of the string words to byte tokens 
2034			; TODO do a search for  
2034			 
2034			; TODO first run normal parser to zero term sections 
2034			; TODO for each word do a token look up to get the op code 
2034			; TODO need some means to flag to the exec that this is a byte code form    
2034			 
2034			 
2034			forthcompile: 
2034			 
2034			; 
2034			; line parse: 
2034			;       parse raw input buffer 
2034			;       tokenise the words 
2034			;       malloc new copy (for looping etc) 
2034			;       copy to malloc + current pc in line to start of string and add line term 
2034			;       save on new rsp 
2034			; 
2034			 
2034			; hl to point to the line to tokenise 
2034			 
2034			;	push hl 
2034 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
2037			 
2037			;	ld a,0		; string term on input 
2037			;	call strlent 
2037			 
2037			;	ld (os_tok_len), hl	 ; save string length 
2037			 
2037			;if DEBUG_FORTH_TOK 
2037			;	ex de,hl		 
2037			;endif 
2037			 
2037			;	pop hl 		; get back string pointer 
2037			 
2037			if DEBUG_FORTH_TOK 
2037						DMARK "TOc" 
2037				CALLMONITOR 
2037			endif 
2037 7e			.cptoken2:    ld a,(hl) 
2038 23				inc hl 
2039 fe 7f			cp FORTH_END_BUFFER 
203b 28 29			jr z, .cptokendone2 
203d fe 00			cp 0 
203f 28 25			jr z, .cptokendone2 
2041 fe 22			cp '"' 
2043 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2045 fe 20			cp ' ' 
2047 20 ee			jr nz,  .cptoken2 
2049			 
2049			; TODO consume comments held between ( and ) 
2049			 
2049				; we have a space so change to zero term for dict match later 
2049 2b				dec hl 
204a 3e 00			ld a,0 
204c 77				ld (hl), a 
204d 23				inc hl 
204e 18 e7			jr .cptoken2 
2050				 
2050			 
2050			.cptokenstr2: 
2050				; skip all white space until either eol (because forgot to term) or end double quote 
2050			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2050				;inc hl ; skip current double quote 
2050 7e				ld a,(hl) 
2051 23				inc hl 
2052 fe 22			cp '"' 
2054 28 e1			jr z, .cptoken2 
2056 fe 7f			cp FORTH_END_BUFFER 
2058 28 0c			jr z, .cptokendone2 
205a fe 00			cp 0 
205c 28 08			jr z, .cptokendone2 
205e fe 20			cp ' ' 
2060 28 02			jr z, .cptmp2 
2062 18 ec			jr .cptokenstr2 
2064			 
2064			.cptmp2:	; we have a space so change to zero term for dict match later 
2064				;dec hl 
2064				;ld a,"-"	; TODO remove this when working 
2064				;ld (hl), a 
2064				;inc hl 
2064 18 ea			jr .cptokenstr2 
2066			 
2066			.cptokendone2: 
2066				;inc hl 
2066 3e 7f			ld a, FORTH_END_BUFFER 
2068 77				ld (hl),a 
2069 23				inc hl 
206a 3e 21			ld a, '!' 
206c 77				ld (hl),a 
206d			 
206d 2a a4 f2			ld hl,(os_tok_ptr) 
2070			         
2070			if DEBUG_FORTH_TOK 
2070						DMARK "Tc1" 
2070				CALLMONITOR 
2070			endif 
2070			 
2070				; push exec string to top of return stack 
2070				FORTH_RSP_NEXT 
2070 cd 64 1c			call macro_forth_rsp_next 
2073				endm 
# End of macro FORTH_RSP_NEXT
2073 c9				ret 
2074			 
2074			; Another go at the parser need to simplify the process 
2074			 
2074			forthparse: 
2074			 
2074			; 
2074			; line parse: 
2074			;       parse raw input buffer 
2074			;       tokenise the words 
2074			;       malloc new copy (for looping etc) 
2074			;       copy to malloc + current pc in line to start of string and add line term 
2074			;       save on new rsp 
2074			; 
2074			 
2074			; hl to point to the line to tokenise 
2074			 
2074			;	push hl 
2074 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
2077			 
2077			;	ld a,0		; string term on input 
2077			;	call strlent 
2077			 
2077			;	ld (os_tok_len), hl	 ; save string length 
2077			 
2077			;if DEBUG_FORTH_TOK 
2077			;	ex de,hl		 
2077			;endif 
2077			 
2077			;	pop hl 		; get back string pointer 
2077			 
2077			if DEBUG_FORTH_TOK 
2077						DMARK "TOK" 
2077				CALLMONITOR 
2077			endif 
2077 7e			.ptoken2:    ld a,(hl) 
2078 23				inc hl 
2079 fe 7f			cp FORTH_END_BUFFER 
207b 28 29			jr z, .ptokendone2 
207d fe 00			cp 0 
207f 28 25			jr z, .ptokendone2 
2081 fe 22			cp '"' 
2083 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2085 fe 20			cp ' ' 
2087 20 ee			jr nz,  .ptoken2 
2089			 
2089			; TODO consume comments held between ( and ) 
2089			 
2089				; we have a space so change to zero term for dict match later 
2089 2b				dec hl 
208a 3e 00			ld a,0 
208c 77				ld (hl), a 
208d 23				inc hl 
208e 18 e7			jr .ptoken2 
2090				 
2090			 
2090			.ptokenstr2: 
2090				; skip all white space until either eol (because forgot to term) or end double quote 
2090			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2090				;inc hl ; skip current double quote 
2090 7e				ld a,(hl) 
2091 23				inc hl 
2092 fe 22			cp '"' 
2094 28 e1			jr z, .ptoken2 
2096 fe 7f			cp FORTH_END_BUFFER 
2098 28 0c			jr z, .ptokendone2 
209a fe 00			cp 0 
209c 28 08			jr z, .ptokendone2 
209e fe 20			cp ' ' 
20a0 28 02			jr z, .ptmp2 
20a2 18 ec			jr .ptokenstr2 
20a4			 
20a4			.ptmp2:	; we have a space so change to zero term for dict match later 
20a4				;dec hl 
20a4				;ld a,"-"	; TODO remove this when working 
20a4				;ld (hl), a 
20a4				;inc hl 
20a4 18 ea			jr .ptokenstr2 
20a6			 
20a6			.ptokendone2: 
20a6				;inc hl 
20a6 3e 7f			ld a, FORTH_END_BUFFER 
20a8 77				ld (hl),a 
20a9 23				inc hl 
20aa 3e 21			ld a, '!' 
20ac 77				ld (hl),a 
20ad			 
20ad 2a a4 f2			ld hl,(os_tok_ptr) 
20b0			         
20b0			if DEBUG_FORTH_TOK 
20b0						DMARK "TK1" 
20b0				CALLMONITOR 
20b0			endif 
20b0			 
20b0				; push exec string to top of return stack 
20b0				FORTH_RSP_NEXT 
20b0 cd 64 1c			call macro_forth_rsp_next 
20b3				endm 
# End of macro FORTH_RSP_NEXT
20b3 c9				ret 
20b4			 
20b4			; 
20b4			;	; malloc size + buffer pointer + if is loop flag 
20b4			;	ld hl,(os_tok_len) 		 ; get string length 
20b4			; 
20b4			;	ld a,l 
20b4			; 
20b4			;	cp 0			; we dont want to use a null string 
20b4			;	ret z 
20b4			; 
20b4			;;	add 3    ; prefix malloc with buffer for current word ptr 
20b4			; 
20b4			;	add 5     ; TODO when certain not over writing memory remove 
20b4			; 
20b4			;		 
20b4			; 
20b4			;if DEBUG_FORTH_TOK 
20b4			;			DMARK "TKE" 
20b4			;	CALLMONITOR 
20b4			;endif 
20b4			; 
20b4			;	ld l,a 
20b4			;	ld h,0 
20b4			;;	push hl   ; save required space for the copy later 
20b4			;	call malloc 
20b4			;if DEBUG_FORTH_TOK 
20b4			;			DMARK "TKM" 
20b4			;	CALLMONITOR 
20b4			;endif 
20b4			;	if DEBUG_FORTH_MALLOC_GUARD 
20b4			;		push af 
20b4			;		call ishlzero 
20b4			;;		ld a, l 
20b4			;;		add h 
20b4			;;		cp 0 
20b4			;		pop af 
20b4			;		 
20b4			;		call z,malloc_error 
20b4			;	endif 
20b4			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20b4			; 
20b4			; 
20b4			;if DEBUG_FORTH_TOK 
20b4			;			DMARK "TKR" 
20b4			;	CALLMONITOR 
20b4			;endif 
20b4			; 
20b4			;	FORTH_RSP_NEXT 
20b4			; 
20b4			;	;inc hl	 ; go past current buffer pointer 
20b4			;	;inc hl 
20b4			;	;inc hl   ; and past if loop flag 
20b4			;		; TODO Need to set flag  
20b4			; 
20b4			;	 
20b4			;	 
20b4			;	ex de,hl	; malloc is dest 
20b4			;	ld hl, (os_tok_len) 
20b4			;;	pop bc 
20b4			;	ld c, l                
20b4			;	ld b,0 
20b4			;	ld hl, (os_tok_ptr) 
20b4			; 
20b4			;if DEBUG_FORTH_TOK 
20b4			;			DMARK "TKT" 
20b4			;	CALLMONITOR 
20b4			;endif 
20b4			; 
20b4			;	; do str cpy 
20b4			; 
20b4			;	ldir      ; copy byte in hl to de 
20b4			; 
20b4			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20b4			; 
20b4			;if DEBUG_FORTH_TOK 
20b4			; 
20b4			;			DMARK "TKY" 
20b4			;	CALLMONITOR 
20b4			;endif 
20b4			;	;ld a,0 
20b4			;	;ld a,FORTH_END_BUFFER 
20b4			;	ex de, hl 
20b4			;	;dec hl			 ; go back over the space delim at the end of word 
20b4			;	;ld (hl),a 
20b4			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20b4			;	ld a,FORTH_END_BUFFER 
20b4			;	ld (hl),a 
20b4			;	inc hl 
20b4			;	ld a,FORTH_END_BUFFER 
20b4			;	ld (hl),a 
20b4			; 
20b4			;	; init the malloc area data 
20b4			;	; set pc for in current area 
20b4			;	;ld hl, (os_tok_malloc) 
20b4			;	;inc hl 
20b4			;	;inc hl 
20b4			;	;inc hl 
20b4			;	;ex de,hl 
20b4			;	;ld hl, (os_tok_malloc) 
20b4			;	;ld (hl),e 
20b4			;	;inc hl 
20b4			;	;ld (hl),d 
20b4			; 
20b4			; 
20b4			;	ld hl,(os_tok_malloc) 
20b4			;if DEBUG_FORTH_PARSE_KEY 
20b4			;			DMARK "TKU" 
20b4			;	CALLMONITOR 
20b4			;endif 
20b4			; 
20b4			;	ret 
20b4			 
20b4			forthexec: 
20b4			 
20b4			; line exec: 
20b4			; forth parser 
20b4			 
20b4			; 
20b4			;       get current exec line on rsp 
20b4			 
20b4				FORTH_RSP_TOS 
20b4 cd 7b 1c			call macro_forth_rsp_tos 
20b7				endm 
# End of macro FORTH_RSP_TOS
20b7			 
20b7			;       restore current pc - hl points to malloc of data 
20b7			 
20b7				;ld e, (hl) 
20b7				;inc hl 
20b7				;ld d, (hl) 
20b7				;ex de,hl 
20b7			 
20b7			 
20b7			exec1: 
20b7 22 a4 f2			ld (os_tok_ptr), hl 
20ba			 
20ba				; copy our PC to working vars  
20ba 22 ae f9			ld (cli_ptr), hl 
20bd 22 ac f9			ld (cli_origptr), hl 
20c0			 
20c0 7e				ld a,(hl) 
20c1 fe 7f			cp FORTH_END_BUFFER 
20c3 c8				ret z 
20c4			 
20c4				; skip any nulls 
20c4			 
20c4 fe 00			cp 0 
20c6 20 03			jr nz, .execword 
20c8 23				inc hl 
20c9 18 ec			jr exec1 
20cb			 
20cb			 
20cb			.execword: 
20cb			 
20cb			 
20cb			 
20cb			if DEBUG_FORTH_PARSE_KEY 
20cb						DMARK "KYQ" 
20cb				CALLMONITOR 
20cb			endif 
20cb			;       while at start of word: 
20cb			; get start of dict (in user area first) 
20cb			 
20cb 21 00 80		ld hl, baseram 
20ce			;ld hl, sysdict 
20ce 22 b0 f9		ld (cli_nextword),hl 
20d1			;           match word at pc 
20d1			;           exec word 
20d1			;           or push to dsp 
20d1			;           forward to next token 
20d1			;           if line term pop rsp and exit 
20d1			;        
20d1			 
20d1			if DEBUG_FORTH_PARSE_KEY 
20d1						DMARK "KYq" 
20d1				CALLMONITOR 
20d1			endif 
20d1			 
20d1			; 
20d1			; word comp 
20d1			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20d1			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20d1			;    move to start of word  
20d1			;    compare word to cli_token 
20d1			 
20d1			.execpnword:	; HL at start of a word in the dictionary to check 
20d1			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20d1			;	ld (cli_ptr), hl 
20d1			 
20d1 2a b0 f9			ld hl,(cli_nextword) 
20d4			 
20d4 cd 77 21			call forth_tok_next 
20d7			; tok next start here 
20d7			;	; TODO skip compiled symbol for now 
20d7			;	inc hl 
20d7			; 
20d7			;	; save pointer to next word 
20d7			; 
20d7			;	; hl now points to the address of the next word pointer  
20d7			;	ld e, (hl) 
20d7			;	inc hl 
20d7			;	ld d, (hl) 
20d7			;	inc l 
20d7			; 
20d7			;	ex de,hl 
20d7			;if DEBUG_FORTH_PARSE_NEXTWORD 
20d7			;	push bc 
20d7			;	ld bc, (cli_nextword) 
20d7			;			DMARK "NXW" 
20d7			;	CALLMONITOR 
20d7			;	pop bc 
20d7			;endif 
20d7			; tok next end here 
20d7 22 b0 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
20da eb				ex de, hl 
20db			 
20db			 
20db				; save the pointer of the current token - 1 to check against 
20db				 
20db 22 b4 f9			ld (cli_token), hl   
20de				; TODO maybe remove below save if no debug 
20de				; save token string ptr for any debug later 
20de 23				inc hl  
20df 22 b6 f9			ld (cli_origtoken), hl 
20e2 2b				dec hl 
20e3				; save pointer to the start of the next dictionay word 
20e3 7e				ld a,(hl)   ; get string length 
20e4 47				ld b,a 
20e5			.execpnwordinc:  
20e5 23				inc hl 
20e6 10 fd			djnz .execpnwordinc 
20e8 22 b2 f9			ld (cli_execword), hl      ; save start of this words code 
20eb			 
20eb				; now check the word token against the string being parsed 
20eb			 
20eb 2a b4 f9			ld hl,(cli_token) 
20ee 23				inc hl     ; skip string length (use zero term instead to end) 
20ef 22 b4 f9			ld (cli_token), hl 
20f2			 
20f2			if DEBUG_FORTH_PARSE_KEY 
20f2						DMARK "KY2" 
20f2			endif 
20f2			if DEBUG_FORTH_PARSE_EXEC 
20f2				; see if disabled 
20f2			 
20f2				ld a, (os_view_disable) 
20f2				cp '*' 
20f2				jr z, .skip 
20f2			 
20f2				push hl 
20f2				push hl 
20f2				call clear_display 
20f2				ld de, .compword 
20f2				ld a, display_row_1 
20f2				call str_at_display 
20f2				pop de 
20f2				ld a, display_row_2 
20f2				call str_at_display 
20f2				ld hl,(cli_ptr) 
20f2				ld a,(hl) 
20f2			        ld hl, os_word_scratch 
20f2				ld (hl),a 
20f2				ld a,0 
20f2				inc hl 
20f2				ld (hl),a 	 
20f2				ld de, os_word_scratch 
20f2				ld a, display_row_2+10 
20f2				call str_at_display 
20f2				call update_display 
20f2				ld a, 100 
20f2				call aDelayInMS 
20f2				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20f2				call delay250ms 
20f2				endif 
20f2				pop hl 
20f2			.skip:  
20f2			endif	 
20f2			.execpnchar:    ; compare char between token and string to parse 
20f2			 
20f2			if DEBUG_FORTH_PARSE_KEY 
20f2						DMARK "Ky3" 
20f2			endif 
20f2			if DEBUG_FORTH_PARSE_EXEC 
20f2				; see if disabled 
20f2			 
20f2				ld a, (os_view_disable) 
20f2				cp '*' 
20f2				jr z, .skip2 
20f2			 
20f2			;	call clear_display 
20f2			ld hl,(cli_token) 
20f2			ld a,(hl) 
20f2			ld (os_word_scratch),a 
20f2				ld hl,(cli_ptr) 
20f2			ld a,(hl) 
20f2				ld (os_word_scratch+1),a 
20f2				ld a,0 
20f2				ld (os_word_scratch+2),a 
20f2				ld de,os_word_scratch 
20f2				ld a,display_row_4 
20f2				call str_at_display 
20f2				call update_display 
20f2			.skip2:  
20f2			endif 
20f2 2a b4 f9			ld hl,(cli_token) 
20f5 7e				ld a, (hl)	 ; char in word token 
20f6 23				inc hl 		; move to next char 
20f7 22 b4 f9			ld (cli_token), hl ; and save it 
20fa 47				ld b,a 
20fb			 
20fb 2a ae f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
20fe 7e				ld a,(hl) 
20ff 23				inc hl 
2100 22 ae f9			ld (cli_ptr), hl		; move to next char 
2103 cd 6f 11			call toUpper 		; make sure the input string matches case 
2106			 
2106			if DEBUG_FORTH_PARSE 
2106			endif 
2106			 
2106				; input stream end of token is a space so get rid of it 
2106			 
2106			;	cp ' ' 
2106			;	jr nz, .pnskipspace 
2106			; 
2106			;	ld a, 0		; make same term as word token term 
2106			; 
2106			;.pnskipspace: 
2106			 
2106			if DEBUG_FORTH_PARSE_KEY 
2106						DMARK "KY7" 
2106			endif 
2106 b8				cp b 
2107 c2 1d 21			jp nz, .execpnskipword	 ; no match so move to next word 
210a				 
210a			;    if same 
210a			;       scan for string terms 0 for token and 32 for input 
210a			 
210a				 
210a			if DEBUG_FORTH_PARSE_KEY 
210a						DMARK "KY8" 
210a			endif 
210a			 
210a 80				add b			 
210b fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
210d							; TODO need to make sure last word in zero term string is accounted for 
210d 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
210f			 
210f			 
210f				; at end of both strings so both are exact match 
210f			 
210f			;       skip ptr for next word 
210f			 
210f 2a ae f9			ld hl,(cli_ptr) 	; at input string term 
2112 23				inc hl			 ; at next char 
2113 22 ae f9			ld (cli_ptr), hl     ; save for next round of the parser 
2116 22 ac f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2119				 
2119				 
2119			if DEBUG_FORTH_PARSE_KEY 
2119						DMARK "KY3" 
2119			endif 
2119			 
2119			 
2119			 
2119			;       exec code block 
2119			if DEBUG_FORTH_JP 
2119				call clear_display 
2119				call update_display 
2119				call delay1s 
2119				ld hl, (cli_execword)     ; save for next check if no match on this word 
2119				ld a,h 
2119				ld hl, os_word_scratch 
2119				call hexout 
2119				ld hl, (cli_execword)     ; save for next check if no match on this word 
2119				ld a,l 
2119				ld hl, os_word_scratch+2 
2119				call hexout 
2119				ld hl, os_word_scratch+4 
2119				ld a,0 
2119				ld (hl),a 
2119				ld de,os_word_scratch 
2119				call str_at_display 
2119					ld a, display_row_2 
2119					call str_at_display 
2119				ld de, (cli_origtoken) 
2119				ld a, display_row_1+10 
2119					call str_at_display 
2119			 
2119				ld a,display_row_1 
2119				ld de, .foundword 
2119				ld a, display_row_3 
2119				call str_at_display 
2119				call update_display 
2119				call delay1s 
2119				call delay1s 
2119				call delay1s 
2119			endif 
2119			 
2119			if DEBUG_FORTH_PARSE_KEY 
2119						DMARK "KYj" 
2119			endif 
2119				; TODO save the word pointer in this exec 
2119			 
2119 2a b2 f9			ld hl,(cli_execword) 
211c e9				jp (hl) 
211d			 
211d			 
211d			;    if not same 
211d			;	scan for zero term 
211d			;	get ptr for next word 
211d			;	goto word comp 
211d			 
211d			.execpnskipword:	; get pointer to next word 
211d 2a b0 f9			ld hl,(cli_nextword) 
2120			 
2120 7e				ld a,(hl) 
2121 fe 00			cp WORD_SYS_END 
2123			;	cp 0 
2123 28 09			jr z, .execendofdict			 ; at end of words 
2125			 
2125			if DEBUG_FORTH_PARSE_KEY 
2125						DMARK "KY4" 
2125			endif 
2125			if DEBUG_FORTH_PARSE_EXEC 
2125			 
2125				; see if disabled 
2125			 
2125				ld a, (os_view_disable) 
2125				cp '*' 
2125				jr z, .noskip 
2125			 
2125			 
2125				ld de, .nowordfound 
2125				ld a, display_row_3 
2125				call str_at_display 
2125				call update_display 
2125				ld a, 100 
2125				call aDelayInMS 
2125				 
2125				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2125					call delay250ms 
2125				endif 
2125			.noskip:  
2125			 
2125			endif	 
2125			 
2125 2a ac f9			ld hl,(cli_origptr) 
2128 22 ae f9			ld (cli_ptr),hl 
212b			 
212b			if DEBUG_FORTH_PARSE_KEY 
212b						DMARK "KY5" 
212b			endif 
212b c3 d1 20			jp .execpnword			; else go to next word 
212e			 
212e			.execendofdict:  
212e			 
212e			if DEBUG_FORTH_PARSE_KEY 
212e						DMARK "KYe" 
212e			endif 
212e			if DEBUG_FORTH_PARSE_EXEC 
212e				; see if disabled 
212e			 
212e				ld a, (os_view_disable) 
212e				cp '*' 
212e				jr z, .ispskip 
212e			 
212e				call clear_display 
212e				call update_display 
212e				call delay1s 
212e				ld de, (cli_origptr) 
212e				ld a, display_row_1 
212e				call str_at_display 
212e				 
212e				ld de, .enddict 
212e				ld a, display_row_3 
212e				call str_at_display 
212e				call update_display 
212e				ld a, 100 
212e				call aDelayInMS 
212e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
212e				call delay1s 
212e				call delay1s 
212e				call delay1s 
212e				endif 
212e			.ispskip:  
212e				 
212e			endif	 
212e			 
212e			 
212e			 
212e				; if the word is not a keyword then must be a literal so push it to stack 
212e			 
212e			; push token to stack to end of word 
212e			 
212e				STACKFRAME ON $1efe $2f9f 
212e				if DEBUG_STACK_IMB 
212e					if ON 
212e						exx 
212e						ld de, $1efe 
212e						ld a, d 
212e						ld hl, curframe 
212e						call hexout 
212e						ld a, e 
212e						ld hl, curframe+2 
212e						call hexout 
212e						ld hl, $1efe 
212e						push hl 
212e						ld hl, $2f9f 
212e						push hl 
212e						exx 
212e					endif 
212e				endif 
212e			endm 
# End of macro STACKFRAME
212e			 
212e 2a a4 f2		ld hl,(os_tok_ptr) 
2131 cd 26 1e		call forth_apush 
2134			 
2134				STACKFRAMECHK ON $1efe $2f9f 
2134				if DEBUG_STACK_IMB 
2134					if ON 
2134						exx 
2134						ld hl, $2f9f 
2134						pop de   ; $2f9f 
2134						call cmp16 
2134						jr nz, .spnosame 
2134						ld hl, $1efe 
2134						pop de   ; $1efe 
2134						call cmp16 
2134						jr z, .spfrsame 
2134						.spnosame: call showsperror 
2134						.spfrsame: nop 
2134						exx 
2134					endif 
2134				endif 
2134			endm 
# End of macro STACKFRAMECHK
2134			 
2134			execnext: 
2134			 
2134			if DEBUG_FORTH_PARSE_KEY 
2134						DMARK "KY>" 
2134			endif 
2134			; move past token to next word 
2134			 
2134 2a a4 f2		ld hl, (os_tok_ptr) 
2137 3e 00		ld a, 0 
2139 01 ff 00		ld bc, 255     ; input buffer size 
213c ed b1		cpir 
213e			 
213e			if DEBUG_FORTH_PARSE_KEY 
213e						DMARK "KY!" 
213e				CALLMONITOR 
213e			endif	 
213e			; TODO this might place hl on the null, so will need to forward on??? 
213e			;inc hl   ; see if this gets onto the next item 
213e			 
213e			 
213e			; TODO pass a pointer to the buffer to push 
213e			; TODO call function to push 
213e			 
213e			; look for end of input 
213e			 
213e			;inc hl 
213e			;ld a,(hl) 
213e			;cp FORTH_END_BUFFER 
213e			;ret z 
213e			 
213e			 
213e c3 b7 20		jp exec1 
2141			 
2141			 
2141			 
2141			 
2141			 
2141			 
2141			 
2141			 
2141			 
2141			findnexttok: 
2141			 
2141				; hl is pointer to move 
2141				; de is the token to locate 
2141			 
2141					if DEBUG_FORTH 
2141						DMARK "NTK" 
2141						CALLMONITOR 
2141					endif 
2141 d5				push de 
2142			 
2142			.fnt1:	 
2142				; find first char of token to locate 
2142			 
2142 1a				ld a, (de) 
2143 4f				ld c,a 
2144 7e				ld a,(hl) 
2145 cd 6f 11			call toUpper 
2148					if DEBUG_FORTH 
2148						DMARK "NT1" 
2148						CALLMONITOR 
2148					endif 
2148 b9				cp c 
2149			 
2149 28 03			jr z, .fnt2cmpmorefirst	 
214b			 
214b				; first char not found move to next char 
214b			 
214b 23				inc hl 
214c 18 f4			jr .fnt1 
214e			 
214e			.fnt2cmpmorefirst:	 
214e				; first char of token found.  
214e			 
214e e5				push hl     ; save start of token just in case it is the right one 
214f d9				exx 
2150 e1				pop hl        ; save it to hl' 
2151 d9				exx 
2152			 
2152			 
2152			.fnt2cmpmore:	 
2152				; compare the rest 
2152				 
2152 23				inc hl 
2153 13				inc de 
2154				 
2154 1a				ld a, (de) 
2155 4f				ld c,a 
2156 7e				ld a,(hl) 
2157 cd 6f 11			call toUpper 
215a			 
215a					if DEBUG_FORTH 
215a						DMARK "NT2" 
215a						CALLMONITOR 
215a					endif 
215a				; c has the token to find char 
215a				; a has the mem to scan char 
215a			 
215a b9				cp c 
215b 28 04			jr z,.fntmatch1 
215d			 
215d				; they are not the same 
215d			 
215d					if DEBUG_FORTH 
215d						DMARK "NT3" 
215d						CALLMONITOR 
215d					endif 
215d d1				pop de	; reset de token to look for 
215e d5				push de 
215f 18 e1			jr .fnt1 
2161				 
2161			.fntmatch1: 
2161			 
2161				; is the same char a null which means we might have a full hit? 
2161					if DEBUG_FORTH 
2161						DMARK "NT4" 
2161						CALLMONITOR 
2161					endif 
2161			 
2161 fe 00			cp 0 
2163 28 0b			jr z, .fntmatchyes 
2165			 
2165				; are we at the end of the token to find? 
2165			 
2165					if DEBUG_FORTH 
2165						DMARK "NT5" 
2165						CALLMONITOR 
2165					endif 
2165 3e 00			ld a, 0 
2167 b9				cp c 
2168			 
2168 c2 52 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
216b			 
216b					if DEBUG_FORTH 
216b						DMARK "NT6" 
216b						CALLMONITOR 
216b					endif 
216b				; token to find is exhusted but no match to stream 
216b			 
216b				; restore tok pointer and continue on 
216b d1				pop de 
216c d5				push de 
216d c3 42 21			jp .fnt1 
2170			 
2170			 
2170			.fntmatchyes: 
2170			 
2170				; hl now contains the end of the found token 
2170			 
2170				; get rid of saved token pointer to find 
2170			 
2170 d1				pop de 
2171			 
2171					if DEBUG_FORTH 
2171						DMARK "NT9" 
2171						CALLMONITOR 
2171					endif 
2171			 
2171				; hl will be on the null term so forward on 
2171			 
2171				; get back the saved start of the token 
2171			 
2171 d9				exx 
2172 e5				push hl     ; save start of token just in case it is the right one 
2173 d9				exx 
2174 e1				pop hl        ; save it to hl 
2175			 
2175 c9				ret 
2176			 
2176			 
2176			; LIST needs to find a specific token   
2176			; FORGET needs to find a spefici token 
2176			 
2176			; SAVE needs to find all tokens by flag 
2176			; WORDS just needs to scan through all  by flag 
2176			; UWORDS needs to scan through all by flag 
2176			 
2176			 
2176			; given hl as pointer to start of dict look up string 
2176			; return hl as pointer to start of word block 
2176			; or 0 if not found 
2176			 
2176			forth_find_tok: 
2176 c9				ret 
2177			 
2177			; given hl as pointer to dict structure 
2177			; move to the next dict block structure 
2177			 
2177			forth_tok_next: 
2177				; hl now points to the address of the next word pointer  
2177				; TODO skip compiled symbol for now 
2177			;	push de 
2177 23				inc hl 
2178 5e				ld e, (hl) 
2179 23				inc hl 
217a 56				ld d, (hl) 
217b 23				inc hl 
217c			 
217c eb				ex de,hl 
217d			if DEBUG_FORTH_PARSE_NEXTWORD 
217d				push bc 
217d				ld bc, (cli_nextword) 
217d						DMARK "NXW" 
217d				CALLMONITOR 
217d				pop bc 
217d			endif 
217d			;	pop de	 
217d c9				ret 
217e			 
217e			 
217e			 
217e			; eof 
# End of file forth_parserv5.asm
217e				include "forth_wordsv4.asm" 
217e			 
217e			; the core word dictionary v4 
217e			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
217e			 
217e			; this is a linked list for each of the system words used 
217e			; user defined words will follow the same format but will be in ram 
217e			 
217e			 
217e			; 
217e			; 
217e			; define linked list: 
217e			; 
217e			; 1. compiled byte op code 
217e			; 2. len of text word 
217e			; 3. text word 
217e			; 4. ptr to next dictionary word 
217e			; 5. asm, calls etc for the word 
217e			; 
217e			;  if 1 == 0 then last word in dict  
217e			;   
217e			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
217e			;  
217e			;  
217e			; create basic standard set of words 
217e			; 
217e			;  
217e			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
217e			; 2DUP 2DROP 2SWAP  
217e			; @ C@ - get byte  
217e			; ! C! - store byte 
217e			; 0< true if less than zero 
217e			; 0= true if zero 
217e			; < >  
217e			; = true if same 
217e			; variables 
217e			 
217e			 
217e			; Hardware specific words I may need 
217e			; 
217e			; IN OUT  
217e			; calls to key util functions 
217e			; calls to hardward abstraction stuff 
217e			; easy control of frame buffers and lcd i/o 
217e			; keyboard  
217e			 
217e			 
217e			;DICT: macro 
217e			; op_code, len, word, next 
217e			;    word: 
217e			;    db op_code 
217e			;    ds word zero term 
217e			;    dw next 
217e			;    endm 
217e			 
217e			 
217e			 
217e			 
217e			; op code 1 is a flag for user define words which are to be handled differently 
217e			 
217e			 
217e			; 
217e			; 
217e			;    TODO on entry to a word this should be the expected environment 
217e			;    hl - tos value if number then held, if string this is the ptr 
217e			;    de -  
217e			 
217e			 
217e			; opcode ranges 
217e			; 0 - end of word dict 
217e			; 255 - user define words 
217e			 
217e			sysdict: 
217e			include "forth_opcodes.asm" 
217e			; op codes for forth keywords 
217e			; free to use code 0  
217e				OPCODE_HEAP: equ  1 
217e				OPCODE_EXEC: equ 2 
217e				OPCODE_DUP: equ 3 
217e				OPCODE_SWAP: equ 4 
217e				OPCODE_COLN: equ 5 
217e				OPCODE_SCOLN: equ 6 
217e				OPCODE_DROP: equ 7 
217e				OPCODE_DUP2: equ 8 
217e				OPCODE_DROP2: equ 9 
217e				OPCODE_SWAP2: equ 10 
217e				OPCODE_AT: equ 11 
217e				OPCODE_CAT: equ 12 
217e				OPCODE_BANG: equ 13 
217e				OPCODE_CBANG: equ 14 
217e				OPCODE_SCALL: equ 15 
217e				OPCODE_DEPTH: equ 16 
217e				OPCODE_OVER: equ 17 
217e				OPCODE_PAUSE: equ 18 
217e				OPCODE_PAUSES: equ 19 
217e				OPCODE_ROT: equ 20 
217e			;free to reuse	OPCODE_WORDS: equ 21 
217e			        OPCODE_NOT: equ 21 
217e				OPCODE_UWORDS: equ 22 
217e				OPCODE_BP: equ 23 
217e				OPCODE_MONITOR: equ 24  
217e				OPCODE_MALLOC: equ 25 
217e				OPCODE_FREE: equ 26 
217e				OPCODE_LIST: equ 27 
217e				OPCODE_FORGET: equ 28 
217e				OPCODE_NOP: equ 29 
217e				OPCODE_COMO: equ 30 
217e				OPCODE_COMC: equ 31 
217e			;free to reuse	OPCODE_ENDCORE: equ 32 
217e				OPCODE_AFTERSOUND: equ 33 
217e				OPCODE_GP2: equ 34 
217e				OPCODE_GP3: equ 35 
217e				OPCODE_GP4: equ 36 
217e				OPCODE_SIN: equ 37 
217e				OPCODE_SOUT: equ 38 
217e				OPCODE_SPIO: equ 39 
217e				OPCODE_SPICEH: equ 40 
217e				OPCODE_SPIOb: equ 41 
217e				OPCODE_SPII: equ 42 
217e				OPCODE_SESEL: equ 43 
217e				OPCODE_CARTDEV: equ 44 
217e			; free to reuse	OPCODE_ENDDEVICE: equ 45 
217e				OPCODE_FB: equ 46 
217e				OPCODE_EMIT: equ 47 
217e				OPCODE_DOTH: equ 48 
217e				OPCODE_DOTF: equ 49 
217e				OPCODE_DOT: equ 50 
217e				OPCODE_CLS: equ 51 
217e				OPCODE_DRAW: equ 52 
217e				OPCODE_DUMP: equ 53 
217e				OPCODE_CDUMP: equ 54 
217e				OPCODE_DAT: equ 55 
217e				OPCODE_HOME: equ 56 
217e				OPCODE_SPACE: equ 57 
217e				OPCODE_SPACES: equ 58 
217e				OPCODE_SCROLL: equ 59 
217e				OPCODE_ATQ: equ 60 
217e				OPCODE_AUTODSP: equ 61 
217e				OPCODE_MENU: equ 62 
217e			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
217e				OPCODE_THEN: equ 64 
217e				OPCODE_ELSE: equ 65 
217e				OPCODE_DO: equ 66 
217e				OPCODE_LOOP: equ 67 
217e				OPCODE_I: equ 68 
217e				OPCODE_DLOOP: equ 69  
217e				OPCODE_REPEAT: equ 70  
217e				OPCODE_UNTIL: equ 71 
217e				OPCODE_ENDFLOW: equ 72 
217e				OPCODE_WAITK: equ 73 
217e				OPCODE_ACCEPT: equ 74 
217e				OPCODE_EDIT: equ 75 
217e			;free to reuse	OPCODE_ENDKEY: equ 76 
217e				OPCODE_LZERO: equ 77 
217e				OPCODE_TZERO: equ 78 
217e				OPCODE_LESS: equ 79 
217e				OPCODE_GT: equ 80 
217e				OPCODE_EQUAL: equ 81  
217e			;free to reuse	OPCODE_ENDLOGIC: equ 82 
217e				OPCODE_NEG: equ 83 
217e				OPCODE_DIV: equ 84 
217e				OPCODE_MUL: equ 85 
217e				OPCODE_MIN: equ 86 
217e				OPCODE_MAX: equ 87 
217e				OPCODE_RND16: equ 88 
217e				OPCODE_RND8: equ 89 
217e				OPCODE_RND: equ 90 
217e			;free to reuse	OPCODE_ENDMATHS: equ 91  
217e				OPCODE_BYNAME: equ 92 
217e				OPCODE_DIR: equ 93 
217e				OPCODE_SAVE: equ 94 
217e				OPCODE_LOAD: equ 95 
217e				OPCODE_BSAVE: equ 96 
217e				OPCODE_BLOAD: equ 97 
217e				OPCODE_SEO: equ 98  
217e				OPCODE_SEI: equ 99 
217e				OPCODE_SFREE: equ 100 
217e				OPCODE_SIZE: equ 101 
217e				OPCODE_CREATE: equ 102 
217e				OPCODE_APPEND: equ 103 
217e				OPCODE_SDEL: equ 104 
217e				OPCODE_OPEN: equ 105 
217e				OPCODE_READ: equ 106 
217e				OPCODE_EOF: equ 106 
217e				OPCODE_FORMAT: equ 107 
217e				OPCODE_LABEL: equ 108 
217e				OPCODE_LABELS: equ 109 
217e			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
217e				OPCODE_UPPER: equ 111 
217e				OPCODE_LOWER: equ 112 
217e				OPCODE_SUBSTR: equ 113 
217e				OPCODE_LEFT: equ 114 
217e				OPCODE_RIGHT: equ 115 
217e				OPCODE_STR2NUM: equ 116 
217e				OPCODE_NUM2STR: equ 117 
217e				OPCODE_CONCAT: equ 118 
217e				OPCODE_FIND: equ 119 
217e				OPCODE_LEN: equ 120 
217e				OPCODE_CHAR: equ 121 
217e			; free to reuse	OPCODE_STRLEN: equ 122 
217e			; free to reuse	OPCODE_ENDSTR: equ 123 
217e				OPCODE_V0S: equ 124 
217e				OPCODE_V0Q: equ 125 
217e				OPCODE_V1S: equ 126 
217e				OPCODE_V1Q: equ 127 
217e				OPCODE_V2S: equ 128 
217e				OPCODE_V2Q: equ 129 
217e				OPCODE_V3S: equ 130 
217e				OPCODE_V3Q: equ 131 
217e			;free to reuse	OPCODE_END: equ 132 
217e				OPCODE_ZDUP: equ 133 
217e			 
217e			; eof 
# End of file forth_opcodes.asm
217e			 
217e			include "forth_words_core.asm" 
217e			 
217e			; | ## Core Words 
217e			 
217e			;if MALLOC_4 
217e			 
217e			.HEAP: 
217e				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
217e 15				db WORD_SYS_CORE+OPCODE_HEAP             
217f bd 21			dw .EXEC            
2181 05				db 4 + 1 
2182 .. 00			db "HEAP",0              
2187				endm 
# End of macro CWHEAD
2187			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2187			; | | u1 - Current number of bytes in the heap 
2187			; | | u2 - Remaining bytes left on the heap 
2187			; | |  
2187			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2187			 
2187			 
2187					if DEBUG_FORTH_WORDS_KEY 
2187						DMARK "HEP" 
2187 f5				push af  
2188 3a 9c 21			ld a, (.dmark)  
218b 32 bd fb			ld (debug_mark),a  
218e 3a 9d 21			ld a, (.dmark+1)  
2191 32 be fb			ld (debug_mark+1),a  
2194 3a 9e 21			ld a, (.dmark+2)  
2197 32 bf fb			ld (debug_mark+2),a  
219a 18 03			jr .pastdmark  
219c ..			.dmark: db "HEP"  
219f f1			.pastdmark: pop af  
21a0			endm  
# End of macro DMARK
21a0						CALLMONITOR 
21a0 cd 2d 17			call break_point_state  
21a3				endm  
# End of macro CALLMONITOR
21a3					endif 
21a3 2a 0a 80				ld hl, (free_list )      
21a6 11 0e 80				ld de, heap_start 
21a9			 
21a9 ed 52				sbc hl, de  
21ab			 
21ab cd bd 1c				call forth_push_numhl 
21ae			 
21ae			 
21ae ed 5b 0a 80			ld de, (free_list )      
21b2 21 89 ef				ld hl, heap_end 
21b5			 
21b5 ed 52				sbc hl, de 
21b7			 
21b7 cd bd 1c				call forth_push_numhl 
21ba					 
21ba			 
21ba					 
21ba			 
21ba			 
21ba			 
21ba					NEXTW 
21ba c3 26 20			jp macro_next 
21bd				endm 
# End of macro NEXTW
21bd			;endif 
21bd			 
21bd			.EXEC: 
21bd			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21bd			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21bd			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21bd			;; > > 
21bd			;; > >   
21bd			;	STACKFRAME OFF $5efe $5f9f 
21bd			; 
21bd			;		if DEBUG_FORTH_WORDS_KEY 
21bd			;			DMARK "EXE" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			; 
21bd			;	FORTH_DSP_VALUEHL 
21bd			; 
21bd			;	FORTH_DSP_POP 
21bd			; 
21bd			;		if DEBUG_FORTH_WORDS 
21bd			;			DMARK "EX1" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			;;	ld e,(hl) 
21bd			;;	inc hl 
21bd			;;	ld d,(hl) 
21bd			;;	ex de,hl 
21bd			; 
21bd			;;		if DEBUG_FORTH_WORDS 
21bd			;;			DMARK "EX2" 
21bd			;;			CALLMONITOR 
21bd			;;		endif 
21bd			;	push hl 
21bd			; 
21bd			;	;ld a, 0 
21bd			;	;ld a, FORTH_END_BUFFER 
21bd			;	call strlenz 
21bd			;	inc hl   ; include zero term to copy 
21bd			;	inc hl   ; include term 
21bd			;	inc hl   ; include term 
21bd			;	ld b,0 
21bd			;	ld c,l 
21bd			;	pop hl 
21bd			;	ld de, execscratch 
21bd			;		if DEBUG_FORTH_WORDS 
21bd			;			DMARK "EX3" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			;	ldir 
21bd			; 
21bd			; 
21bd			;	ld hl, execscratch 
21bd			; 
21bd			;		if DEBUG_FORTH_WORDS 
21bd			;			DMARK "EXe" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			; 
21bd			;	call forthparse 
21bd			;	call forthexec 
21bd			;;	call forthexec_cleanup 
21bd			;;	call forthparse 
21bd			;;	call forthexec 
21bd			; 
21bd			;	STACKFRAMECHK OFF $5efe $5f9f 
21bd			; 
21bd			;	; an immediate word so no need to process any more words 
21bd			;	ret 
21bd			;	NEXTW 
21bd			 
21bd			; dead code - old version  
21bd			;	FORTH_RSP_NEXT 
21bd			 
21bd			;  
21bd			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21bd			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21bd			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21bd			;	push hl 
21bd			;	push de 
21bd			;	push bc 
21bd			; 
21bd			; 
21bd			;		if DEBUG_FORTH_WORDS_KEY 
21bd			;			DMARK "EXR" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			; 
21bd			; 
21bd			; 
21bd			;	;v5 FORTH_DSP_VALUE 
21bd			;	FORTH_DSP_VALUEHL 
21bd			; 
21bd			;	; TODO do string type checks 
21bd			; 
21bd			;;v5	inc hl   ; skip type 
21bd			; 
21bd			;	push hl  ; source code  
21bd			;		if DEBUG_FORTH_WORDS 
21bd			;			DMARK "EX1" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			;	ld a, 0 
21bd			;	call strlent 
21bd			; 
21bd			;	inc hl 
21bd			;	inc hl 
21bd			;	inc hl 
21bd			;	inc hl 
21bd			; 
21bd			;	push hl    ; size 
21bd			; 
21bd			;		if DEBUG_FORTH_WORDS 
21bd			;			DMARK "EX2" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			;	call malloc 
21bd			; 
21bd			;	ex de, hl    ; de now contains malloc area 
21bd			;	pop bc   	; get byte count 
21bd			;	pop hl      ; get string to copy 
21bd			; 
21bd			;	push de     ; save malloc for free later 
21bd			; 
21bd			;		if DEBUG_FORTH_WORDS 
21bd			;			DMARK "EX3" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			;	ldir       ; duplicate string 
21bd			; 
21bd			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21bd			;	 
21bd			;	; TODO fix the parse would be better than this...  
21bd			;	ex de, hl 
21bd			;	dec hl 
21bd			;	ld a, 0 
21bd			;	ld (hl), a 
21bd			;	dec hl 
21bd			;	ld a, ' ' 
21bd			;	ld (hl), a 
21bd			;	dec hl 
21bd			;	ld (hl), a 
21bd			; 
21bd			;	dec hl 
21bd			;	ld (hl), a 
21bd			; 
21bd			; 
21bd			;	FORTH_DSP_POP  
21bd			; 
21bd			;	pop hl     
21bd			;	push hl    ; save malloc area 
21bd			; 
21bd			;		if DEBUG_FORTH_WORDS 
21bd			;			DMARK "EX4" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			; 
21bd			;	call forthparse 
21bd			;	call forthexec 
21bd			;	 
21bd			;	pop hl 
21bd			;	if DEBUG_FORTH_WORDS 
21bd			;		DMARK "EX5" 
21bd			;		CALLMONITOR 
21bd			;	endif 
21bd			; 
21bd			;	if FORTH_ENABLE_FREE 
21bd			;	call free 
21bd			;	endif 
21bd			; 
21bd			;	if DEBUG_FORTH_WORDS 
21bd			;		DMARK "EX6" 
21bd			;		CALLMONITOR 
21bd			;	endif 
21bd			; 
21bd			;	pop bc 
21bd			;	pop de 
21bd			;	pop hl 
21bd			;;	FORTH_RSP_POP	  
21bd			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21bd			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21bd			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21bd			; 
21bd			;	if DEBUG_FORTH_WORDS 
21bd			;		DMARK "EX7" 
21bd			;		CALLMONITOR 
21bd			;	endif 
21bd			;	NEXTW 
21bd			 
21bd			;.STKEXEC: 
21bd			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21bd			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21bd			; 
21bd			; 
21bd			;		if DEBUG_FORTH_WORDS_KEY 
21bd			;			DMARK "STX" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			; 
21bd			;	FORTH_DSP_VALUEHL 
21bd			; 
21bd			;	ld (store_tmp1), hl    ; count 
21bd			; 
21bd			;	FORTH_DSP_POP 
21bd			;.stkexec1: 
21bd			;	ld hl, (store_tmp1)   ; count 
21bd			;	ld a, 0 
21bd			;	cp l 
21bd			;	ret z 
21bd			; 
21bd			;	dec hl 
21bd			;	ld (store_tmp1), hl    ; count 
21bd			;	 
21bd			;	FORTH_DSP_VALUEHL 
21bd			;	push hl 
21bd			;	 
21bd			;		if DEBUG_FORTH_WORDS 
21bd			;			DMARK "EXp" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			;	FORTH_DSP_POP 
21bd			; 
21bd			;	call strlenz 
21bd			;	inc hl   ; include zero term to copy 
21bd			;	inc hl   ; include zero term to copy 
21bd			;	inc hl   ; include zero term to copy 
21bd			;	ld b,0 
21bd			;	ld c,l 
21bd			;	pop hl 
21bd			;	ld de, execscratch 
21bd			;		if DEBUG_FORTH_WORDS 
21bd			;			DMARK "EX3" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			;	ldir 
21bd			; 
21bd			; 
21bd			;	ld hl, execscratch 
21bd			; 
21bd			;		if DEBUG_FORTH_WORDS 
21bd			;			DMARK "EXP" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			; 
21bd			;	call forthparse 
21bd			;	ld hl, execscratch 
21bd			;		if DEBUG_FORTH_WORDS 
21bd			;			DMARK "EXx" 
21bd			;			CALLMONITOR 
21bd			;		endif 
21bd			;	call forthexec 
21bd			; 
21bd			;	jp .stkexec1 
21bd			; 
21bd			;	ret 
21bd			 
21bd			 
21bd			.DUP: 
21bd				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21bd 17				db WORD_SYS_CORE+OPCODE_DUP             
21be 33 22			dw .ZDUP            
21c0 04				db 3 + 1 
21c1 .. 00			db "DUP",0              
21c5				endm 
# End of macro CWHEAD
21c5			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21c5			 
21c5					if DEBUG_FORTH_WORDS_KEY 
21c5						DMARK "DUP" 
21c5 f5				push af  
21c6 3a da 21			ld a, (.dmark)  
21c9 32 bd fb			ld (debug_mark),a  
21cc 3a db 21			ld a, (.dmark+1)  
21cf 32 be fb			ld (debug_mark+1),a  
21d2 3a dc 21			ld a, (.dmark+2)  
21d5 32 bf fb			ld (debug_mark+2),a  
21d8 18 03			jr .pastdmark  
21da ..			.dmark: db "DUP"  
21dd f1			.pastdmark: pop af  
21de			endm  
# End of macro DMARK
21de						CALLMONITOR 
21de cd 2d 17			call break_point_state  
21e1				endm  
# End of macro CALLMONITOR
21e1					endif 
21e1			 
21e1					FORTH_DSP 
21e1 cd 7a 1e			call macro_forth_dsp 
21e4				endm 
# End of macro FORTH_DSP
21e4			 
21e4 7e					ld a, (HL) 
21e5 fe 01				cp DS_TYPE_STR 
21e7 20 25				jr nz, .dupinum 
21e9			 
21e9					; push another string 
21e9			 
21e9					FORTH_DSP_VALUEHL     		 
21e9 cd b4 1e			call macro_dsp_valuehl 
21ec				endm 
# End of macro FORTH_DSP_VALUEHL
21ec			 
21ec				if DEBUG_FORTH_WORDS 
21ec					DMARK "DUs" 
21ec f5				push af  
21ed 3a 01 22			ld a, (.dmark)  
21f0 32 bd fb			ld (debug_mark),a  
21f3 3a 02 22			ld a, (.dmark+1)  
21f6 32 be fb			ld (debug_mark+1),a  
21f9 3a 03 22			ld a, (.dmark+2)  
21fc 32 bf fb			ld (debug_mark+2),a  
21ff 18 03			jr .pastdmark  
2201 ..			.dmark: db "DUs"  
2204 f1			.pastdmark: pop af  
2205			endm  
# End of macro DMARK
2205					CALLMONITOR 
2205 cd 2d 17			call break_point_state  
2208				endm  
# End of macro CALLMONITOR
2208				endif 
2208 cd 2b 1d				call forth_push_str 
220b			 
220b					NEXTW 
220b c3 26 20			jp macro_next 
220e				endm 
# End of macro NEXTW
220e			 
220e			 
220e			.dupinum: 
220e					 
220e			 
220e			 
220e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
220e cd b4 1e			call macro_dsp_valuehl 
2211				endm 
# End of macro FORTH_DSP_VALUEHL
2211			 
2211				; TODO add floating point number detection 
2211			 
2211				if DEBUG_FORTH_WORDS 
2211					DMARK "DUi" 
2211 f5				push af  
2212 3a 26 22			ld a, (.dmark)  
2215 32 bd fb			ld (debug_mark),a  
2218 3a 27 22			ld a, (.dmark+1)  
221b 32 be fb			ld (debug_mark+1),a  
221e 3a 28 22			ld a, (.dmark+2)  
2221 32 bf fb			ld (debug_mark+2),a  
2224 18 03			jr .pastdmark  
2226 ..			.dmark: db "DUi"  
2229 f1			.pastdmark: pop af  
222a			endm  
# End of macro DMARK
222a					CALLMONITOR 
222a cd 2d 17			call break_point_state  
222d				endm  
# End of macro CALLMONITOR
222d				endif 
222d			 
222d cd bd 1c				call forth_push_numhl 
2230					NEXTW 
2230 c3 26 20			jp macro_next 
2233				endm 
# End of macro NEXTW
2233			.ZDUP: 
2233				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2233 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2234 6b 22			dw .SWAP            
2236 05				db 4 + 1 
2237 .. 00			db "?DUP",0              
223c				endm 
# End of macro CWHEAD
223c			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
223c			 
223c					if DEBUG_FORTH_WORDS_KEY 
223c						DMARK "qDU" 
223c f5				push af  
223d 3a 51 22			ld a, (.dmark)  
2240 32 bd fb			ld (debug_mark),a  
2243 3a 52 22			ld a, (.dmark+1)  
2246 32 be fb			ld (debug_mark+1),a  
2249 3a 53 22			ld a, (.dmark+2)  
224c 32 bf fb			ld (debug_mark+2),a  
224f 18 03			jr .pastdmark  
2251 ..			.dmark: db "qDU"  
2254 f1			.pastdmark: pop af  
2255			endm  
# End of macro DMARK
2255						CALLMONITOR 
2255 cd 2d 17			call break_point_state  
2258				endm  
# End of macro CALLMONITOR
2258					endif 
2258					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2258 cd b4 1e			call macro_dsp_valuehl 
225b				endm 
# End of macro FORTH_DSP_VALUEHL
225b			 
225b e5					push hl 
225c			 
225c					; is it a zero? 
225c			 
225c 3e 00				ld a, 0 
225e 84					add h 
225f 85					add l 
2260			 
2260 e1					pop hl 
2261			 
2261 fe 00				cp 0 
2263 28 03				jr z, .dup2orig 
2265			 
2265			 
2265 cd bd 1c				call forth_push_numhl 
2268			 
2268			 
2268				; TODO add floating point number detection 
2268			 
2268			.dup2orig: 
2268			 
2268					NEXTW 
2268 c3 26 20			jp macro_next 
226b				endm 
# End of macro NEXTW
226b			.SWAP: 
226b				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
226b 18				db WORD_SYS_CORE+OPCODE_SWAP             
226c aa 22			dw .COLN            
226e 05				db 4 + 1 
226f .. 00			db "SWAP",0              
2274				endm 
# End of macro CWHEAD
2274			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2274					if DEBUG_FORTH_WORDS_KEY 
2274						DMARK "SWP" 
2274 f5				push af  
2275 3a 89 22			ld a, (.dmark)  
2278 32 bd fb			ld (debug_mark),a  
227b 3a 8a 22			ld a, (.dmark+1)  
227e 32 be fb			ld (debug_mark+1),a  
2281 3a 8b 22			ld a, (.dmark+2)  
2284 32 bf fb			ld (debug_mark+2),a  
2287 18 03			jr .pastdmark  
2289 ..			.dmark: db "SWP"  
228c f1			.pastdmark: pop af  
228d			endm  
# End of macro DMARK
228d						CALLMONITOR 
228d cd 2d 17			call break_point_state  
2290				endm  
# End of macro CALLMONITOR
2290					endif 
2290			 
2290					FORTH_DSP_VALUEHL 
2290 cd b4 1e			call macro_dsp_valuehl 
2293				endm 
# End of macro FORTH_DSP_VALUEHL
2293 e5					push hl     ; w2 
2294			 
2294					FORTH_DSP_POP 
2294 cd 6c 1f			call macro_forth_dsp_pop 
2297				endm 
# End of macro FORTH_DSP_POP
2297			 
2297					FORTH_DSP_VALUEHL 
2297 cd b4 1e			call macro_dsp_valuehl 
229a				endm 
# End of macro FORTH_DSP_VALUEHL
229a			 
229a					FORTH_DSP_POP 
229a cd 6c 1f			call macro_forth_dsp_pop 
229d				endm 
# End of macro FORTH_DSP_POP
229d			 
229d d1					pop de     ; w2	, hl = w1 
229e			 
229e eb					ex de, hl 
229f d5					push de 
22a0			 
22a0 cd bd 1c				call forth_push_numhl 
22a3			 
22a3 e1					pop hl 
22a4			 
22a4 cd bd 1c				call forth_push_numhl 
22a7					 
22a7			 
22a7					NEXTW 
22a7 c3 26 20			jp macro_next 
22aa				endm 
# End of macro NEXTW
22aa			.COLN: 
22aa				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22aa 19				db WORD_SYS_CORE+OPCODE_COLN             
22ab 36 24			dw .SCOLN            
22ad 02				db 1 + 1 
22ae .. 00			db ":",0              
22b0				endm 
# End of macro CWHEAD
22b0			; | : ( -- )         Create new word | DONE 
22b0			 
22b0					if DEBUG_FORTH_WORDS_KEY 
22b0						DMARK "CLN" 
22b0 f5				push af  
22b1 3a c5 22			ld a, (.dmark)  
22b4 32 bd fb			ld (debug_mark),a  
22b7 3a c6 22			ld a, (.dmark+1)  
22ba 32 be fb			ld (debug_mark+1),a  
22bd 3a c7 22			ld a, (.dmark+2)  
22c0 32 bf fb			ld (debug_mark+2),a  
22c3 18 03			jr .pastdmark  
22c5 ..			.dmark: db "CLN"  
22c8 f1			.pastdmark: pop af  
22c9			endm  
# End of macro DMARK
22c9						CALLMONITOR 
22c9 cd 2d 17			call break_point_state  
22cc				endm  
# End of macro CALLMONITOR
22cc					endif 
22cc				STACKFRAME OFF $8efe $989f 
22cc				if DEBUG_STACK_IMB 
22cc					if OFF 
22cc						exx 
22cc						ld de, $8efe 
22cc						ld a, d 
22cc						ld hl, curframe 
22cc						call hexout 
22cc						ld a, e 
22cc						ld hl, curframe+2 
22cc						call hexout 
22cc						ld hl, $8efe 
22cc						push hl 
22cc						ld hl, $989f 
22cc						push hl 
22cc						exx 
22cc					endif 
22cc				endif 
22cc			endm 
# End of macro STACKFRAME
22cc				; get parser buffer length  of new word 
22cc			 
22cc				 
22cc			 
22cc					; move tok past this to start of name defintition 
22cc					; TODO get word to define 
22cc					; TODO Move past word token 
22cc					; TODO get length of string up to the ';' 
22cc			 
22cc 2a a4 f2			ld hl, (os_tok_ptr) 
22cf 23				inc hl 
22d0 23				inc hl 
22d1			 
22d1 3e 3b			ld a, ';' 
22d3 cd 83 11			call strlent 
22d6			 
22d6 7d				ld a,l 
22d7 32 9f ef			ld (os_new_parse_len), a 
22da			 
22da			 
22da			if DEBUG_FORTH_UWORD 
22da ed 5b a4 f2		ld de, (os_tok_ptr) 
22de						DMARK ":01" 
22de f5				push af  
22df 3a f3 22			ld a, (.dmark)  
22e2 32 bd fb			ld (debug_mark),a  
22e5 3a f4 22			ld a, (.dmark+1)  
22e8 32 be fb			ld (debug_mark+1),a  
22eb 3a f5 22			ld a, (.dmark+2)  
22ee 32 bf fb			ld (debug_mark+2),a  
22f1 18 03			jr .pastdmark  
22f3 ..			.dmark: db ":01"  
22f6 f1			.pastdmark: pop af  
22f7			endm  
# End of macro DMARK
22f7				CALLMONITOR 
22f7 cd 2d 17			call break_point_state  
22fa				endm  
# End of macro CALLMONITOR
22fa			endif 
22fa			 
22fa			; 
22fa			;  new word memory layout: 
22fa			;  
22fa			;    : adg 6666 ;  
22fa			; 
22fa			;    db   1     ; user defined word  
22fa 23				inc hl    
22fb			;    dw   sysdict 
22fb 23				inc hl 
22fc 23				inc hl 
22fd			;    db <word len>+1 (for null) 
22fd 23				inc hl 
22fe			;    db .... <word> 
22fe			; 
22fe			 
22fe 23				inc hl    ; some extras for the word preamble before the above 
22ff 23				inc hl 
2300 23				inc hl 
2301 23				inc hl 
2302 23				inc hl 
2303 23				inc hl 
2304 23				inc hl  
2305 23				inc hl 
2306 23				inc hl 
2307 23				inc hl 
2308 23				inc hl 
2309 23				inc hl 
230a 23				inc hl 
230b 23				inc hl     ; TODO how many do we really need?     maybe only 6 
230c			;       exec word buffer 
230c			;	<ptr word>   
230c 23				inc hl 
230d 23				inc hl 
230e			;       <word list><null term> 7F final term 
230e			 
230e			 
230e			if DEBUG_FORTH_UWORD 
230e						DMARK ":02" 
230e f5				push af  
230f 3a 23 23			ld a, (.dmark)  
2312 32 bd fb			ld (debug_mark),a  
2315 3a 24 23			ld a, (.dmark+1)  
2318 32 be fb			ld (debug_mark+1),a  
231b 3a 25 23			ld a, (.dmark+2)  
231e 32 bf fb			ld (debug_mark+2),a  
2321 18 03			jr .pastdmark  
2323 ..			.dmark: db ":02"  
2326 f1			.pastdmark: pop af  
2327			endm  
# End of macro DMARK
2327				CALLMONITOR 
2327 cd 2d 17			call break_point_state  
232a				endm  
# End of macro CALLMONITOR
232a			endif 
232a			 
232a				 
232a					; malloc the size 
232a			 
232a cd e1 11				call malloc 
232d 22 a1 ef				ld (os_new_malloc), hl     ; save malloc start 
2330			 
2330			;    db   1     ; user defined word  
2330 3e 01				ld a, WORD_SYS_UWORD  
2332 77					ld (hl), a 
2333				 
2333 23				inc hl    
2334			;    dw   sysdict 
2334 11 7e 21			ld de, sysdict       ; continue on with the scan to the system dict 
2337 73				ld (hl), e 
2338 23				inc hl 
2339 72				ld (hl), d 
233a 23				inc hl 
233b			 
233b			 
233b			;    Setup dict word 
233b			 
233b 23				inc hl 
233c 22 9b ef			ld (os_new_work_ptr), hl     ; save start of dict word  
233f			 
233f				; 1. get length of dict word 
233f			 
233f			 
233f 2a a4 f2			ld hl, (os_tok_ptr) 
2342 23				inc hl 
2343 23				inc hl    ; position to start of dict word 
2344 3e 00			ld a, 0 
2346 cd 83 11			call strlent 
2349			 
2349			 
2349 23				inc hl    ; to include null??? 
234a			 
234a				; write length of dict word 
234a			 
234a ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
234e 1b				dec de 
234f eb				ex de, hl 
2350 73				ld (hl), e 
2351 eb				ex de, hl 
2352			 
2352				 
2352			 
2352				; copy  
2352 4d				ld c, l 
2353 06 00			ld b, 0 
2355 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2359 2a a4 f2			ld hl, (os_tok_ptr) 
235c 23				inc hl 
235d 23				inc hl    ; position to start of dict word 
235e				 
235e			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
235e				 
235e				; TODO need to convert word to upper case 
235e			 
235e			ucasetok:	 
235e 7e				ld a,(hl) 
235f cd 6f 11			call toUpper 
2362 77				ld (hl),a 
2363 ed a0			ldi 
2365 f2 5e 23		 	jp p, ucasetok 
2368			 
2368			 
2368			 
2368				; de now points to start of where the word body code should be placed 
2368 ed 53 9b ef		ld (os_new_work_ptr), de 
236c				; hl now points to the words to throw at forthexec which needs to be copied 
236c 22 99 ef			ld (os_new_src_ptr), hl 
236f			 
236f				; TODO add 'call to forthexec' 
236f			 
236f			if DEBUG_FORTH_UWORD 
236f c5				push bc 
2370 ed 4b a1 ef		ld bc, (os_new_malloc) 
2374						DMARK ":0x" 
2374 f5				push af  
2375 3a 89 23			ld a, (.dmark)  
2378 32 bd fb			ld (debug_mark),a  
237b 3a 8a 23			ld a, (.dmark+1)  
237e 32 be fb			ld (debug_mark+1),a  
2381 3a 8b 23			ld a, (.dmark+2)  
2384 32 bf fb			ld (debug_mark+2),a  
2387 18 03			jr .pastdmark  
2389 ..			.dmark: db ":0x"  
238c f1			.pastdmark: pop af  
238d			endm  
# End of macro DMARK
238d				CALLMONITOR 
238d cd 2d 17			call break_point_state  
2390				endm  
# End of macro CALLMONITOR
2390 c1				pop bc 
2391			endif 
2391			 
2391			 
2391				; create word preamble which should be: 
2391			 
2391			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2391			 
2391				;    ld hl, <word code> 
2391				;    jp user_exec 
2391			        ;    <word code bytes> 
2391			 
2391			 
2391			;	inc de     ; TODO ??? or are we already past the word's null 
2391 eb				ex de, hl 
2392			 
2392 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2394			 
2394 23				inc hl 
2395 22 95 ef			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2398 23				inc hl 
2399			 
2399 23				inc hl 
239a 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
239c			 
239c 01 d0 50			ld bc, user_exec 
239f 23				inc hl 
23a0 71				ld (hl), c     ; poke address of user_exec 
23a1 23				inc hl 
23a2 70				ld (hl), b     
23a3			 ; 
23a3			;	inc hl 
23a3			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23a3			; 
23a3			; 
23a3			;	ld bc, macro_forth_rsp_next 
23a3			;	inc hl 
23a3			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23a3			;	inc hl 
23a3			;	ld (hl), b     
23a3			 ; 
23a3			;	inc hl 
23a3			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23a3			; 
23a3			; 
23a3			;	inc hl 
23a3			;	ld bc, forthexec 
23a3			;	ld (hl), c     ; poke address of forthexec 
23a3			;	inc hl 
23a3			;	ld (hl), b      
23a3			; 
23a3			;	inc hl 
23a3			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23a3			; 
23a3			;	ld bc, user_dict_next 
23a3			;	inc hl 
23a3			;	ld (hl), c     ; poke address of forthexec 
23a3			;	inc hl 
23a3			;	ld (hl), b      
23a3			 
23a3				; hl is now where we need to copy the word byte data to save this 
23a3			 
23a3 23				inc hl 
23a4 22 97 ef			ld (os_new_exec), hl 
23a7				 
23a7				; copy definition 
23a7			 
23a7 eb				ex de, hl 
23a8			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23a8			;	inc de    ; skip the PC for this parse 
23a8 3a 9f ef			ld a, (os_new_parse_len) 
23ab 4f				ld c, a 
23ac 06 00			ld b, 0 
23ae ed b0			ldir		 ; copy defintion 
23b0			 
23b0			 
23b0				; poke the address of where the new word bytes live for forthexec 
23b0			 
23b0 2a 95 ef			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23b3			 
23b3 ed 5b 97 ef		ld de, (os_new_exec)      
23b7				 
23b7 73				ld (hl), e 
23b8 23				inc hl 
23b9 72				ld (hl), d 
23ba			 
23ba					; TODO copy last user dict word next link to this word 
23ba					; TODO update last user dict word to point to this word 
23ba			; 
23ba			; hl f923 de 812a ; bc 811a 
23ba			 
23ba			if DEBUG_FORTH_UWORD 
23ba c5				push bc 
23bb ed 4b a1 ef		ld bc, (os_new_malloc) 
23bf						DMARK ":0A" 
23bf f5				push af  
23c0 3a d4 23			ld a, (.dmark)  
23c3 32 bd fb			ld (debug_mark),a  
23c6 3a d5 23			ld a, (.dmark+1)  
23c9 32 be fb			ld (debug_mark+1),a  
23cc 3a d6 23			ld a, (.dmark+2)  
23cf 32 bf fb			ld (debug_mark+2),a  
23d2 18 03			jr .pastdmark  
23d4 ..			.dmark: db ":0A"  
23d7 f1			.pastdmark: pop af  
23d8			endm  
# End of macro DMARK
23d8				CALLMONITOR 
23d8 cd 2d 17			call break_point_state  
23db				endm  
# End of macro CALLMONITOR
23db c1				pop bc 
23dc			endif 
23dc			if DEBUG_FORTH_UWORD 
23dc c5				push bc 
23dd ed 4b a1 ef		ld bc, (os_new_malloc) 
23e1 03				inc bc 
23e2 03				inc bc 
23e3 03				inc bc 
23e4 03				inc bc 
23e5 03				inc bc 
23e6 03				inc bc 
23e7 03				inc bc 
23e8 03				inc bc 
23e9			 
23e9						DMARK ":0B" 
23e9 f5				push af  
23ea 3a fe 23			ld a, (.dmark)  
23ed 32 bd fb			ld (debug_mark),a  
23f0 3a ff 23			ld a, (.dmark+1)  
23f3 32 be fb			ld (debug_mark+1),a  
23f6 3a 00 24			ld a, (.dmark+2)  
23f9 32 bf fb			ld (debug_mark+2),a  
23fc 18 03			jr .pastdmark  
23fe ..			.dmark: db ":0B"  
2401 f1			.pastdmark: pop af  
2402			endm  
# End of macro DMARK
2402				CALLMONITOR 
2402 cd 2d 17			call break_point_state  
2405				endm  
# End of macro CALLMONITOR
2405 c1				pop bc 
2406			endif 
2406			 
2406			; update word dict linked list for new word 
2406			 
2406			 
2406 2a a0 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2409 23			inc hl     ; move to next work linked list ptr 
240a			 
240a ed 5b a1 ef	ld de, (os_new_malloc)		 ; new next word 
240e 73			ld (hl), e 
240f 23			inc hl 
2410 72			ld (hl), d 
2411			 
2411			if DEBUG_FORTH_UWORD 
2411 ed 4b a0 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2415			endif 
2415			 
2415 ed 53 a0 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
2419			 
2419			 
2419			if DEBUG_FORTH_UWORD 
2419						DMARK ":0+" 
2419 f5				push af  
241a 3a 2e 24			ld a, (.dmark)  
241d 32 bd fb			ld (debug_mark),a  
2420 3a 2f 24			ld a, (.dmark+1)  
2423 32 be fb			ld (debug_mark+1),a  
2426 3a 30 24			ld a, (.dmark+2)  
2429 32 bf fb			ld (debug_mark+2),a  
242c 18 03			jr .pastdmark  
242e ..			.dmark: db ":0+"  
2431 f1			.pastdmark: pop af  
2432			endm  
# End of macro DMARK
2432				CALLMONITOR 
2432 cd 2d 17			call break_point_state  
2435				endm  
# End of macro CALLMONITOR
2435			endif 
2435			 
2435				STACKFRAMECHK OFF $8efe $989f 
2435				if DEBUG_STACK_IMB 
2435					if OFF 
2435						exx 
2435						ld hl, $989f 
2435						pop de   ; $989f 
2435						call cmp16 
2435						jr nz, .spnosame 
2435						ld hl, $8efe 
2435						pop de   ; $8efe 
2435						call cmp16 
2435						jr z, .spfrsame 
2435						.spnosame: call showsperror 
2435						.spfrsame: nop 
2435						exx 
2435					endif 
2435				endif 
2435			endm 
# End of macro STACKFRAMECHK
2435			 
2435 c9			ret    ; dont process any remaining parser tokens as they form new word 
2436			 
2436			 
2436			 
2436			 
2436			;		NEXT 
2436			.SCOLN: 
2436			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2436 06				db OPCODE_SCOLN 
2437 82 24			dw .DROP 
2439 02				db 2 
243a .. 00			db ";",0           
243c			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
243c					if DEBUG_FORTH_WORDS_KEY 
243c						DMARK "SCN" 
243c f5				push af  
243d 3a 51 24			ld a, (.dmark)  
2440 32 bd fb			ld (debug_mark),a  
2443 3a 52 24			ld a, (.dmark+1)  
2446 32 be fb			ld (debug_mark+1),a  
2449 3a 53 24			ld a, (.dmark+2)  
244c 32 bf fb			ld (debug_mark+2),a  
244f 18 03			jr .pastdmark  
2451 ..			.dmark: db "SCN"  
2454 f1			.pastdmark: pop af  
2455			endm  
# End of macro DMARK
2455						CALLMONITOR 
2455 cd 2d 17			call break_point_state  
2458				endm  
# End of macro CALLMONITOR
2458					endif 
2458					FORTH_RSP_TOS 
2458 cd 7b 1c			call macro_forth_rsp_tos 
245b				endm 
# End of macro FORTH_RSP_TOS
245b e5					push hl 
245c					FORTH_RSP_POP 
245c cd 85 1c			call macro_forth_rsp_pop 
245f				endm 
# End of macro FORTH_RSP_POP
245f e1					pop hl 
2460			;		ex de,hl 
2460 22 a4 f2				ld (os_tok_ptr),hl 
2463			 
2463			if DEBUG_FORTH_UWORD 
2463						DMARK "SCL" 
2463 f5				push af  
2464 3a 78 24			ld a, (.dmark)  
2467 32 bd fb			ld (debug_mark),a  
246a 3a 79 24			ld a, (.dmark+1)  
246d 32 be fb			ld (debug_mark+1),a  
2470 3a 7a 24			ld a, (.dmark+2)  
2473 32 bf fb			ld (debug_mark+2),a  
2476 18 03			jr .pastdmark  
2478 ..			.dmark: db "SCL"  
247b f1			.pastdmark: pop af  
247c			endm  
# End of macro DMARK
247c				CALLMONITOR 
247c cd 2d 17			call break_point_state  
247f				endm  
# End of macro CALLMONITOR
247f			endif 
247f					NEXTW 
247f c3 26 20			jp macro_next 
2482				endm 
# End of macro NEXTW
2482			 
2482			.DROP: 
2482				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2482 1b				db WORD_SYS_CORE+OPCODE_DROP             
2483 ad 24			dw .DUP2            
2485 05				db 4 + 1 
2486 .. 00			db "DROP",0              
248b				endm 
# End of macro CWHEAD
248b			; | DROP ( w -- )   drop the TOS item   | DONE 
248b					if DEBUG_FORTH_WORDS_KEY 
248b						DMARK "DRP" 
248b f5				push af  
248c 3a a0 24			ld a, (.dmark)  
248f 32 bd fb			ld (debug_mark),a  
2492 3a a1 24			ld a, (.dmark+1)  
2495 32 be fb			ld (debug_mark+1),a  
2498 3a a2 24			ld a, (.dmark+2)  
249b 32 bf fb			ld (debug_mark+2),a  
249e 18 03			jr .pastdmark  
24a0 ..			.dmark: db "DRP"  
24a3 f1			.pastdmark: pop af  
24a4			endm  
# End of macro DMARK
24a4						CALLMONITOR 
24a4 cd 2d 17			call break_point_state  
24a7				endm  
# End of macro CALLMONITOR
24a7					endif 
24a7					FORTH_DSP_POP 
24a7 cd 6c 1f			call macro_forth_dsp_pop 
24aa				endm 
# End of macro FORTH_DSP_POP
24aa					NEXTW 
24aa c3 26 20			jp macro_next 
24ad				endm 
# End of macro NEXTW
24ad			.DUP2: 
24ad				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24ad 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24ae f2 24			dw .DROP2            
24b0 05				db 4 + 1 
24b1 .. 00			db "2DUP",0              
24b6				endm 
# End of macro CWHEAD
24b6			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24b6					if DEBUG_FORTH_WORDS_KEY 
24b6						DMARK "2DU" 
24b6 f5				push af  
24b7 3a cb 24			ld a, (.dmark)  
24ba 32 bd fb			ld (debug_mark),a  
24bd 3a cc 24			ld a, (.dmark+1)  
24c0 32 be fb			ld (debug_mark+1),a  
24c3 3a cd 24			ld a, (.dmark+2)  
24c6 32 bf fb			ld (debug_mark+2),a  
24c9 18 03			jr .pastdmark  
24cb ..			.dmark: db "2DU"  
24ce f1			.pastdmark: pop af  
24cf			endm  
# End of macro DMARK
24cf						CALLMONITOR 
24cf cd 2d 17			call break_point_state  
24d2				endm  
# End of macro CALLMONITOR
24d2					endif 
24d2					FORTH_DSP_VALUEHL 
24d2 cd b4 1e			call macro_dsp_valuehl 
24d5				endm 
# End of macro FORTH_DSP_VALUEHL
24d5 e5					push hl      ; 2 
24d6			 
24d6					FORTH_DSP_POP 
24d6 cd 6c 1f			call macro_forth_dsp_pop 
24d9				endm 
# End of macro FORTH_DSP_POP
24d9					 
24d9					FORTH_DSP_VALUEHL 
24d9 cd b4 1e			call macro_dsp_valuehl 
24dc				endm 
# End of macro FORTH_DSP_VALUEHL
24dc			;		push hl      ; 1 
24dc			 
24dc					FORTH_DSP_POP 
24dc cd 6c 1f			call macro_forth_dsp_pop 
24df				endm 
# End of macro FORTH_DSP_POP
24df			 
24df			;		pop hl       ; 1 
24df d1					pop de       ; 2 
24e0			 
24e0 cd bd 1c				call forth_push_numhl 
24e3 eb					ex de, hl 
24e4 cd bd 1c				call forth_push_numhl 
24e7			 
24e7					 
24e7 eb					ex de, hl 
24e8			 
24e8 cd bd 1c				call forth_push_numhl 
24eb eb					ex de, hl 
24ec cd bd 1c				call forth_push_numhl 
24ef			 
24ef			 
24ef					NEXTW 
24ef c3 26 20			jp macro_next 
24f2				endm 
# End of macro NEXTW
24f2			.DROP2: 
24f2				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24f2 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24f3 21 25			dw .SWAP2            
24f5 06				db 5 + 1 
24f6 .. 00			db "2DROP",0              
24fc				endm 
# End of macro CWHEAD
24fc			; | 2DROP ( w w -- )    Double drop | DONE 
24fc					if DEBUG_FORTH_WORDS_KEY 
24fc						DMARK "2DR" 
24fc f5				push af  
24fd 3a 11 25			ld a, (.dmark)  
2500 32 bd fb			ld (debug_mark),a  
2503 3a 12 25			ld a, (.dmark+1)  
2506 32 be fb			ld (debug_mark+1),a  
2509 3a 13 25			ld a, (.dmark+2)  
250c 32 bf fb			ld (debug_mark+2),a  
250f 18 03			jr .pastdmark  
2511 ..			.dmark: db "2DR"  
2514 f1			.pastdmark: pop af  
2515			endm  
# End of macro DMARK
2515						CALLMONITOR 
2515 cd 2d 17			call break_point_state  
2518				endm  
# End of macro CALLMONITOR
2518					endif 
2518					FORTH_DSP_POP 
2518 cd 6c 1f			call macro_forth_dsp_pop 
251b				endm 
# End of macro FORTH_DSP_POP
251b					FORTH_DSP_POP 
251b cd 6c 1f			call macro_forth_dsp_pop 
251e				endm 
# End of macro FORTH_DSP_POP
251e					NEXTW 
251e c3 26 20			jp macro_next 
2521				endm 
# End of macro NEXTW
2521			.SWAP2: 
2521				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2521 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2522 4a 25			dw .AT            
2524 06				db 5 + 1 
2525 .. 00			db "2SWAP",0              
252b				endm 
# End of macro CWHEAD
252b			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
252b					if DEBUG_FORTH_WORDS_KEY 
252b						DMARK "2SW" 
252b f5				push af  
252c 3a 40 25			ld a, (.dmark)  
252f 32 bd fb			ld (debug_mark),a  
2532 3a 41 25			ld a, (.dmark+1)  
2535 32 be fb			ld (debug_mark+1),a  
2538 3a 42 25			ld a, (.dmark+2)  
253b 32 bf fb			ld (debug_mark+2),a  
253e 18 03			jr .pastdmark  
2540 ..			.dmark: db "2SW"  
2543 f1			.pastdmark: pop af  
2544			endm  
# End of macro DMARK
2544						CALLMONITOR 
2544 cd 2d 17			call break_point_state  
2547				endm  
# End of macro CALLMONITOR
2547					endif 
2547					NEXTW 
2547 c3 26 20			jp macro_next 
254a				endm 
# End of macro NEXTW
254a			.AT: 
254a				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
254a 1f				db WORD_SYS_CORE+OPCODE_AT             
254b 7c 25			dw .CAT            
254d 02				db 1 + 1 
254e .. 00			db "@",0              
2550				endm 
# End of macro CWHEAD
2550			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2550			 
2550					if DEBUG_FORTH_WORDS_KEY 
2550						DMARK "AT." 
2550 f5				push af  
2551 3a 65 25			ld a, (.dmark)  
2554 32 bd fb			ld (debug_mark),a  
2557 3a 66 25			ld a, (.dmark+1)  
255a 32 be fb			ld (debug_mark+1),a  
255d 3a 67 25			ld a, (.dmark+2)  
2560 32 bf fb			ld (debug_mark+2),a  
2563 18 03			jr .pastdmark  
2565 ..			.dmark: db "AT."  
2568 f1			.pastdmark: pop af  
2569			endm  
# End of macro DMARK
2569						CALLMONITOR 
2569 cd 2d 17			call break_point_state  
256c				endm  
# End of macro CALLMONITOR
256c					endif 
256c			.getbyteat:	 
256c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
256c cd b4 1e			call macro_dsp_valuehl 
256f				endm 
# End of macro FORTH_DSP_VALUEHL
256f					 
256f			;		push hl 
256f				 
256f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
256f cd 6c 1f			call macro_forth_dsp_pop 
2572				endm 
# End of macro FORTH_DSP_POP
2572			 
2572			;		pop hl 
2572			 
2572 7e					ld a, (hl) 
2573			 
2573 6f					ld l, a 
2574 26 00				ld h, 0 
2576 cd bd 1c				call forth_push_numhl 
2579			 
2579					NEXTW 
2579 c3 26 20			jp macro_next 
257c				endm 
# End of macro NEXTW
257c			.CAT: 
257c				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
257c 20				db WORD_SYS_CORE+OPCODE_CAT             
257d a5 25			dw .BANG            
257f 03				db 2 + 1 
2580 .. 00			db "C@",0              
2583				endm 
# End of macro CWHEAD
2583			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2583					if DEBUG_FORTH_WORDS_KEY 
2583						DMARK "CAA" 
2583 f5				push af  
2584 3a 98 25			ld a, (.dmark)  
2587 32 bd fb			ld (debug_mark),a  
258a 3a 99 25			ld a, (.dmark+1)  
258d 32 be fb			ld (debug_mark+1),a  
2590 3a 9a 25			ld a, (.dmark+2)  
2593 32 bf fb			ld (debug_mark+2),a  
2596 18 03			jr .pastdmark  
2598 ..			.dmark: db "CAA"  
259b f1			.pastdmark: pop af  
259c			endm  
# End of macro DMARK
259c						CALLMONITOR 
259c cd 2d 17			call break_point_state  
259f				endm  
# End of macro CALLMONITOR
259f					endif 
259f c3 6c 25				jp .getbyteat 
25a2					NEXTW 
25a2 c3 26 20			jp macro_next 
25a5				endm 
# End of macro NEXTW
25a5			.BANG: 
25a5				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25a5 21				db WORD_SYS_CORE+OPCODE_BANG             
25a6 db 25			dw .CBANG            
25a8 02				db 1 + 1 
25a9 .. 00			db "!",0              
25ab				endm 
# End of macro CWHEAD
25ab			; | ! ( x w -- ) Store x at address w      | DONE 
25ab					if DEBUG_FORTH_WORDS_KEY 
25ab						DMARK "BNG" 
25ab f5				push af  
25ac 3a c0 25			ld a, (.dmark)  
25af 32 bd fb			ld (debug_mark),a  
25b2 3a c1 25			ld a, (.dmark+1)  
25b5 32 be fb			ld (debug_mark+1),a  
25b8 3a c2 25			ld a, (.dmark+2)  
25bb 32 bf fb			ld (debug_mark+2),a  
25be 18 03			jr .pastdmark  
25c0 ..			.dmark: db "BNG"  
25c3 f1			.pastdmark: pop af  
25c4			endm  
# End of macro DMARK
25c4						CALLMONITOR 
25c4 cd 2d 17			call break_point_state  
25c7				endm  
# End of macro CALLMONITOR
25c7					endif 
25c7			 
25c7			.storebyteat:		 
25c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25c7 cd b4 1e			call macro_dsp_valuehl 
25ca				endm 
# End of macro FORTH_DSP_VALUEHL
25ca					 
25ca e5					push hl 
25cb				 
25cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25cb cd 6c 1f			call macro_forth_dsp_pop 
25ce				endm 
# End of macro FORTH_DSP_POP
25ce			 
25ce					; get byte to poke 
25ce			 
25ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25ce cd b4 1e			call macro_dsp_valuehl 
25d1				endm 
# End of macro FORTH_DSP_VALUEHL
25d1 e5					push hl 
25d2			 
25d2			 
25d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25d2 cd 6c 1f			call macro_forth_dsp_pop 
25d5				endm 
# End of macro FORTH_DSP_POP
25d5			 
25d5			 
25d5 d1					pop de 
25d6 e1					pop hl 
25d7			 
25d7 73					ld (hl),e 
25d8			 
25d8			 
25d8					NEXTW 
25d8 c3 26 20			jp macro_next 
25db				endm 
# End of macro NEXTW
25db			.CBANG: 
25db				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25db 22				db WORD_SYS_CORE+OPCODE_CBANG             
25dc 04 26			dw .SCALL            
25de 03				db 2 + 1 
25df .. 00			db "C!",0              
25e2				endm 
# End of macro CWHEAD
25e2			; | C!  ( x w -- ) Store x at address w  | DONE 
25e2					if DEBUG_FORTH_WORDS_KEY 
25e2						DMARK "CBA" 
25e2 f5				push af  
25e3 3a f7 25			ld a, (.dmark)  
25e6 32 bd fb			ld (debug_mark),a  
25e9 3a f8 25			ld a, (.dmark+1)  
25ec 32 be fb			ld (debug_mark+1),a  
25ef 3a f9 25			ld a, (.dmark+2)  
25f2 32 bf fb			ld (debug_mark+2),a  
25f5 18 03			jr .pastdmark  
25f7 ..			.dmark: db "CBA"  
25fa f1			.pastdmark: pop af  
25fb			endm  
# End of macro DMARK
25fb						CALLMONITOR 
25fb cd 2d 17			call break_point_state  
25fe				endm  
# End of macro CALLMONITOR
25fe					endif 
25fe c3 c7 25				jp .storebyteat 
2601					NEXTW 
2601 c3 26 20			jp macro_next 
2604				endm 
# End of macro NEXTW
2604			.SCALL: 
2604				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2604 23				db WORD_SYS_CORE+OPCODE_SCALL             
2605 38 26			dw .DEPTH            
2607 05				db 4 + 1 
2608 .. 00			db "CALL",0              
260d				endm 
# End of macro CWHEAD
260d			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
260d					if DEBUG_FORTH_WORDS_KEY 
260d						DMARK "CLL" 
260d f5				push af  
260e 3a 22 26			ld a, (.dmark)  
2611 32 bd fb			ld (debug_mark),a  
2614 3a 23 26			ld a, (.dmark+1)  
2617 32 be fb			ld (debug_mark+1),a  
261a 3a 24 26			ld a, (.dmark+2)  
261d 32 bf fb			ld (debug_mark+2),a  
2620 18 03			jr .pastdmark  
2622 ..			.dmark: db "CLL"  
2625 f1			.pastdmark: pop af  
2626			endm  
# End of macro DMARK
2626						CALLMONITOR 
2626 cd 2d 17			call break_point_state  
2629				endm  
# End of macro CALLMONITOR
2629					endif 
2629			 
2629					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2629 cd b4 1e			call macro_dsp_valuehl 
262c				endm 
# End of macro FORTH_DSP_VALUEHL
262c			 
262c			;		push hl 
262c			 
262c					; destroy value TOS 
262c			 
262c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
262c cd 6c 1f			call macro_forth_dsp_pop 
262f				endm 
# End of macro FORTH_DSP_POP
262f			 
262f						 
262f			;		pop hl 
262f			 
262f					; how to do a call with hl???? save SP? 
262f cd cf 1f				call forth_call_hl 
2632			 
2632			 
2632					; TODO push value back onto stack for another op etc 
2632			 
2632 cd bd 1c				call forth_push_numhl 
2635					NEXTW 
2635 c3 26 20			jp macro_next 
2638				endm 
# End of macro NEXTW
2638			.DEPTH: 
2638				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2638 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2639 75 26			dw .OVER            
263b 06				db 5 + 1 
263c .. 00			db "DEPTH",0              
2642				endm 
# End of macro CWHEAD
2642			; | DEPTH ( -- u ) Push count of stack | DONE 
2642					; take current TOS and remove from base value div by two to get count 
2642					if DEBUG_FORTH_WORDS_KEY 
2642						DMARK "DEP" 
2642 f5				push af  
2643 3a 57 26			ld a, (.dmark)  
2646 32 bd fb			ld (debug_mark),a  
2649 3a 58 26			ld a, (.dmark+1)  
264c 32 be fb			ld (debug_mark+1),a  
264f 3a 59 26			ld a, (.dmark+2)  
2652 32 bf fb			ld (debug_mark+2),a  
2655 18 03			jr .pastdmark  
2657 ..			.dmark: db "DEP"  
265a f1			.pastdmark: pop af  
265b			endm  
# End of macro DMARK
265b						CALLMONITOR 
265b cd 2d 17			call break_point_state  
265e				endm  
# End of macro CALLMONITOR
265e					endif 
265e			 
265e			 
265e 2a 90 f9			ld hl, (cli_data_sp) 
2661 11 0a f5			ld de, cli_data_stack 
2664 ed 52			sbc hl,de 
2666				 
2666				; div by size of stack item 
2666			 
2666 5d				ld e,l 
2667 0e 03			ld c, 3 
2669 cd aa 0c			call Div8 
266c			 
266c 6f				ld l,a 
266d 26 00			ld h,0 
266f			 
266f				;srl h 
266f				;rr l 
266f			 
266f cd bd 1c				call forth_push_numhl 
2672					NEXTW 
2672 c3 26 20			jp macro_next 
2675				endm 
# End of macro NEXTW
2675			.OVER: 
2675				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2675 42				db WORD_SYS_CORE+46             
2676 bc 26			dw .PAUSE            
2678 05				db 4 + 1 
2679 .. 00			db "OVER",0              
267e				endm 
# End of macro CWHEAD
267e			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
267e					if DEBUG_FORTH_WORDS_KEY 
267e						DMARK "OVR" 
267e f5				push af  
267f 3a 93 26			ld a, (.dmark)  
2682 32 bd fb			ld (debug_mark),a  
2685 3a 94 26			ld a, (.dmark+1)  
2688 32 be fb			ld (debug_mark+1),a  
268b 3a 95 26			ld a, (.dmark+2)  
268e 32 bf fb			ld (debug_mark+2),a  
2691 18 03			jr .pastdmark  
2693 ..			.dmark: db "OVR"  
2696 f1			.pastdmark: pop af  
2697			endm  
# End of macro DMARK
2697						CALLMONITOR 
2697 cd 2d 17			call break_point_state  
269a				endm  
# End of macro CALLMONITOR
269a					endif 
269a			 
269a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
269a cd b4 1e			call macro_dsp_valuehl 
269d				endm 
# End of macro FORTH_DSP_VALUEHL
269d e5					push hl    ; n2 
269e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
269e cd 6c 1f			call macro_forth_dsp_pop 
26a1				endm 
# End of macro FORTH_DSP_POP
26a1			 
26a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26a1 cd b4 1e			call macro_dsp_valuehl 
26a4				endm 
# End of macro FORTH_DSP_VALUEHL
26a4 e5					push hl    ; n1 
26a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26a5 cd 6c 1f			call macro_forth_dsp_pop 
26a8				endm 
# End of macro FORTH_DSP_POP
26a8			 
26a8 d1					pop de     ; n1 
26a9 e1					pop hl     ; n2 
26aa			 
26aa d5					push de 
26ab e5					push hl 
26ac d5					push de 
26ad			 
26ad					; push back  
26ad			 
26ad e1					pop hl 
26ae cd bd 1c				call forth_push_numhl 
26b1 e1					pop hl 
26b2 cd bd 1c				call forth_push_numhl 
26b5 e1					pop hl 
26b6 cd bd 1c				call forth_push_numhl 
26b9					NEXTW 
26b9 c3 26 20			jp macro_next 
26bc				endm 
# End of macro NEXTW
26bc			 
26bc			.PAUSE: 
26bc				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26bc 43				db WORD_SYS_CORE+47             
26bd f1 26			dw .PAUSES            
26bf 08				db 7 + 1 
26c0 .. 00			db "PAUSEMS",0              
26c8				endm 
# End of macro CWHEAD
26c8			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26c8					if DEBUG_FORTH_WORDS_KEY 
26c8						DMARK "PMS" 
26c8 f5				push af  
26c9 3a dd 26			ld a, (.dmark)  
26cc 32 bd fb			ld (debug_mark),a  
26cf 3a de 26			ld a, (.dmark+1)  
26d2 32 be fb			ld (debug_mark+1),a  
26d5 3a df 26			ld a, (.dmark+2)  
26d8 32 bf fb			ld (debug_mark+2),a  
26db 18 03			jr .pastdmark  
26dd ..			.dmark: db "PMS"  
26e0 f1			.pastdmark: pop af  
26e1			endm  
# End of macro DMARK
26e1						CALLMONITOR 
26e1 cd 2d 17			call break_point_state  
26e4				endm  
# End of macro CALLMONITOR
26e4					endif 
26e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e4 cd b4 1e			call macro_dsp_valuehl 
26e7				endm 
# End of macro FORTH_DSP_VALUEHL
26e7			;		push hl    ; n2 
26e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26e7 cd 6c 1f			call macro_forth_dsp_pop 
26ea				endm 
# End of macro FORTH_DSP_POP
26ea			;		pop hl 
26ea			 
26ea 7d					ld a, l 
26eb cd 4b 0a				call aDelayInMS 
26ee				       NEXTW 
26ee c3 26 20			jp macro_next 
26f1				endm 
# End of macro NEXTW
26f1			.PAUSES:  
26f1				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26f1 44				db WORD_SYS_CORE+48             
26f2 60 27			dw .ROT            
26f4 06				db 5 + 1 
26f5 .. 00			db "PAUSE",0              
26fb				endm 
# End of macro CWHEAD
26fb			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26fb					if DEBUG_FORTH_WORDS_KEY 
26fb						DMARK "PAU" 
26fb f5				push af  
26fc 3a 10 27			ld a, (.dmark)  
26ff 32 bd fb			ld (debug_mark),a  
2702 3a 11 27			ld a, (.dmark+1)  
2705 32 be fb			ld (debug_mark+1),a  
2708 3a 12 27			ld a, (.dmark+2)  
270b 32 bf fb			ld (debug_mark+2),a  
270e 18 03			jr .pastdmark  
2710 ..			.dmark: db "PAU"  
2713 f1			.pastdmark: pop af  
2714			endm  
# End of macro DMARK
2714						CALLMONITOR 
2714 cd 2d 17			call break_point_state  
2717				endm  
# End of macro CALLMONITOR
2717					endif 
2717					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2717 cd b4 1e			call macro_dsp_valuehl 
271a				endm 
# End of macro FORTH_DSP_VALUEHL
271a			;		push hl    ; n2 
271a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
271a cd 6c 1f			call macro_forth_dsp_pop 
271d				endm 
# End of macro FORTH_DSP_POP
271d			;		pop hl 
271d 45					ld b, l 
271e					if DEBUG_FORTH_WORDS 
271e						DMARK "PAU" 
271e f5				push af  
271f 3a 33 27			ld a, (.dmark)  
2722 32 bd fb			ld (debug_mark),a  
2725 3a 34 27			ld a, (.dmark+1)  
2728 32 be fb			ld (debug_mark+1),a  
272b 3a 35 27			ld a, (.dmark+2)  
272e 32 bf fb			ld (debug_mark+2),a  
2731 18 03			jr .pastdmark  
2733 ..			.dmark: db "PAU"  
2736 f1			.pastdmark: pop af  
2737			endm  
# End of macro DMARK
2737						CALLMONITOR 
2737 cd 2d 17			call break_point_state  
273a				endm  
# End of macro CALLMONITOR
273a					endif 
273a c5			.pauses1:	push bc 
273b cd 66 0a				call delay1s 
273e c1					pop bc 
273f					if DEBUG_FORTH_WORDS 
273f						DMARK "PA1" 
273f f5				push af  
2740 3a 54 27			ld a, (.dmark)  
2743 32 bd fb			ld (debug_mark),a  
2746 3a 55 27			ld a, (.dmark+1)  
2749 32 be fb			ld (debug_mark+1),a  
274c 3a 56 27			ld a, (.dmark+2)  
274f 32 bf fb			ld (debug_mark+2),a  
2752 18 03			jr .pastdmark  
2754 ..			.dmark: db "PA1"  
2757 f1			.pastdmark: pop af  
2758			endm  
# End of macro DMARK
2758						CALLMONITOR 
2758 cd 2d 17			call break_point_state  
275b				endm  
# End of macro CALLMONITOR
275b					endif 
275b 10 dd				djnz .pauses1 
275d			 
275d				       NEXTW 
275d c3 26 20			jp macro_next 
2760				endm 
# End of macro NEXTW
2760			.ROT: 
2760				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2760 45				db WORD_SYS_CORE+49             
2761 ae 27			dw .UWORDS            
2763 04				db 3 + 1 
2764 .. 00			db "ROT",0              
2768				endm 
# End of macro CWHEAD
2768			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2768					if DEBUG_FORTH_WORDS_KEY 
2768						DMARK "ROT" 
2768 f5				push af  
2769 3a 7d 27			ld a, (.dmark)  
276c 32 bd fb			ld (debug_mark),a  
276f 3a 7e 27			ld a, (.dmark+1)  
2772 32 be fb			ld (debug_mark+1),a  
2775 3a 7f 27			ld a, (.dmark+2)  
2778 32 bf fb			ld (debug_mark+2),a  
277b 18 03			jr .pastdmark  
277d ..			.dmark: db "ROT"  
2780 f1			.pastdmark: pop af  
2781			endm  
# End of macro DMARK
2781						CALLMONITOR 
2781 cd 2d 17			call break_point_state  
2784				endm  
# End of macro CALLMONITOR
2784					endif 
2784			 
2784					FORTH_DSP_VALUEHL 
2784 cd b4 1e			call macro_dsp_valuehl 
2787				endm 
# End of macro FORTH_DSP_VALUEHL
2787 e5					push hl    ; u3  
2788			 
2788					FORTH_DSP_POP 
2788 cd 6c 1f			call macro_forth_dsp_pop 
278b				endm 
# End of macro FORTH_DSP_POP
278b			   
278b					FORTH_DSP_VALUEHL 
278b cd b4 1e			call macro_dsp_valuehl 
278e				endm 
# End of macro FORTH_DSP_VALUEHL
278e e5					push hl     ; u2 
278f			 
278f					FORTH_DSP_POP 
278f cd 6c 1f			call macro_forth_dsp_pop 
2792				endm 
# End of macro FORTH_DSP_POP
2792			 
2792					FORTH_DSP_VALUEHL 
2792 cd b4 1e			call macro_dsp_valuehl 
2795				endm 
# End of macro FORTH_DSP_VALUEHL
2795 e5					push hl     ; u1 
2796			 
2796					FORTH_DSP_POP 
2796 cd 6c 1f			call macro_forth_dsp_pop 
2799				endm 
# End of macro FORTH_DSP_POP
2799			 
2799 c1					pop bc      ; u1 
279a e1					pop hl      ; u2 
279b d1					pop de      ; u3 
279c			 
279c			 
279c c5					push bc 
279d d5					push de 
279e e5					push hl 
279f			 
279f			 
279f e1					pop hl 
27a0 cd bd 1c				call forth_push_numhl 
27a3			 
27a3 e1					pop hl 
27a4 cd bd 1c				call forth_push_numhl 
27a7			 
27a7 e1					pop hl 
27a8 cd bd 1c				call forth_push_numhl 
27ab					 
27ab			 
27ab			 
27ab			 
27ab			 
27ab			 
27ab				       NEXTW 
27ab c3 26 20			jp macro_next 
27ae				endm 
# End of macro NEXTW
27ae			 
27ae			.UWORDS: 
27ae				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27ae 50				db WORD_SYS_CORE+60             
27af 70 28			dw .BP            
27b1 07				db 6 + 1 
27b2 .. 00			db "UWORDS",0              
27b9				endm 
# End of macro CWHEAD
27b9			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27b9			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27b9			; | | Following the count are the individual words. 
27b9			; | | 
27b9			; | | e.g. UWORDS 
27b9			; | | BOX DIRLIST 2 
27b9			; | |  
27b9			; | | Can be used to save the words to storage via: 
27b9			; | | UWORDS $01 DO $01 APPEND LOOP 
27b9				if DEBUG_FORTH_WORDS_KEY 
27b9					DMARK "UWR" 
27b9 f5				push af  
27ba 3a ce 27			ld a, (.dmark)  
27bd 32 bd fb			ld (debug_mark),a  
27c0 3a cf 27			ld a, (.dmark+1)  
27c3 32 be fb			ld (debug_mark+1),a  
27c6 3a d0 27			ld a, (.dmark+2)  
27c9 32 bf fb			ld (debug_mark+2),a  
27cc 18 03			jr .pastdmark  
27ce ..			.dmark: db "UWR"  
27d1 f1			.pastdmark: pop af  
27d2			endm  
# End of macro DMARK
27d2					CALLMONITOR 
27d2 cd 2d 17			call break_point_state  
27d5				endm  
# End of macro CALLMONITOR
27d5				endif 
27d5 21 00 80				ld hl, baseram 
27d8					;ld hl, baseusermem 
27d8 01 00 00				ld bc, 0    ; start a counter 
27db			 
27db				; skip dict stub 
27db			 
27db cd 77 21				call forth_tok_next 
27de			 
27de			 
27de			; while we have words to look for 
27de			 
27de 7e			.douscan:	ld a, (hl)      
27df				if DEBUG_FORTH_WORDS 
27df					DMARK "UWs" 
27df f5				push af  
27e0 3a f4 27			ld a, (.dmark)  
27e3 32 bd fb			ld (debug_mark),a  
27e6 3a f5 27			ld a, (.dmark+1)  
27e9 32 be fb			ld (debug_mark+1),a  
27ec 3a f6 27			ld a, (.dmark+2)  
27ef 32 bf fb			ld (debug_mark+2),a  
27f2 18 03			jr .pastdmark  
27f4 ..			.dmark: db "UWs"  
27f7 f1			.pastdmark: pop af  
27f8			endm  
# End of macro DMARK
27f8					CALLMONITOR 
27f8 cd 2d 17			call break_point_state  
27fb				endm  
# End of macro CALLMONITOR
27fb				endif 
27fb fe 00				cp WORD_SYS_END 
27fd 28 4d				jr z, .udone 
27ff fe 01				cp WORD_SYS_UWORD 
2801 20 44				jr nz, .nuword 
2803			 
2803				if DEBUG_FORTH_WORDS 
2803					DMARK "UWu" 
2803 f5				push af  
2804 3a 18 28			ld a, (.dmark)  
2807 32 bd fb			ld (debug_mark),a  
280a 3a 19 28			ld a, (.dmark+1)  
280d 32 be fb			ld (debug_mark+1),a  
2810 3a 1a 28			ld a, (.dmark+2)  
2813 32 bf fb			ld (debug_mark+2),a  
2816 18 03			jr .pastdmark  
2818 ..			.dmark: db "UWu"  
281b f1			.pastdmark: pop af  
281c			endm  
# End of macro DMARK
281c					CALLMONITOR 
281c cd 2d 17			call break_point_state  
281f				endm  
# End of macro CALLMONITOR
281f				endif 
281f					; we have a uword so push its name to the stack 
281f			 
281f e5				   	push hl  ; save so we can move to next dict block 
2820			 
2820					; skip opcode 
2820 23					inc hl  
2821					; skip next ptr 
2821 23					inc hl  
2822 23					inc hl 
2823					; skip len 
2823 23					inc hl 
2824				if DEBUG_FORTH_WORDS 
2824					DMARK "UWt" 
2824 f5				push af  
2825 3a 39 28			ld a, (.dmark)  
2828 32 bd fb			ld (debug_mark),a  
282b 3a 3a 28			ld a, (.dmark+1)  
282e 32 be fb			ld (debug_mark+1),a  
2831 3a 3b 28			ld a, (.dmark+2)  
2834 32 bf fb			ld (debug_mark+2),a  
2837 18 03			jr .pastdmark  
2839 ..			.dmark: db "UWt"  
283c f1			.pastdmark: pop af  
283d			endm  
# End of macro DMARK
283d					CALLMONITOR 
283d cd 2d 17			call break_point_state  
2840				endm  
# End of macro CALLMONITOR
2840				endif 
2840 03					inc bc 
2841			 
2841 c5					push bc 
2842 cd 2b 1d				call forth_push_str 
2845 c1					pop bc 
2846			 
2846 e1					pop hl 	 
2847			 
2847 cd 77 21		.nuword:	call forth_tok_next 
284a 18 92				jr .douscan  
284c			 
284c			.udone:		 ; push count of uwords found 
284c c5					push bc 
284d e1					pop hl 
284e			 
284e				if DEBUG_FORTH_WORDS 
284e					DMARK "UWc" 
284e f5				push af  
284f 3a 63 28			ld a, (.dmark)  
2852 32 bd fb			ld (debug_mark),a  
2855 3a 64 28			ld a, (.dmark+1)  
2858 32 be fb			ld (debug_mark+1),a  
285b 3a 65 28			ld a, (.dmark+2)  
285e 32 bf fb			ld (debug_mark+2),a  
2861 18 03			jr .pastdmark  
2863 ..			.dmark: db "UWc"  
2866 f1			.pastdmark: pop af  
2867			endm  
# End of macro DMARK
2867					CALLMONITOR 
2867 cd 2d 17			call break_point_state  
286a				endm  
# End of macro CALLMONITOR
286a				endif 
286a cd bd 1c				call forth_push_numhl 
286d			 
286d			 
286d				       NEXTW 
286d c3 26 20			jp macro_next 
2870				endm 
# End of macro NEXTW
2870			 
2870			.BP: 
2870				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2870 54				db WORD_SYS_CORE+64             
2871 a6 28			dw .MONITOR            
2873 03				db 2 + 1 
2874 .. 00			db "BP",0              
2877				endm 
# End of macro CWHEAD
2877			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2877			; | | $00 Will enable the break points within specific code paths 
2877			; | | $01 Will disable break points 
2877			; | |  
2877			; | | By default break points are off. Either the above can be used to enable them 
2877			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2877			; | | and on release of the pressed key a message will be disaplayed to notify 
2877			; | | that break points are enabled. Pressing any key will then continue boot process. 
2877					; get byte count 
2877					if DEBUG_FORTH_WORDS_KEY 
2877						DMARK "BP." 
2877 f5				push af  
2878 3a 8c 28			ld a, (.dmark)  
287b 32 bd fb			ld (debug_mark),a  
287e 3a 8d 28			ld a, (.dmark+1)  
2881 32 be fb			ld (debug_mark+1),a  
2884 3a 8e 28			ld a, (.dmark+2)  
2887 32 bf fb			ld (debug_mark+2),a  
288a 18 03			jr .pastdmark  
288c ..			.dmark: db "BP."  
288f f1			.pastdmark: pop af  
2890			endm  
# End of macro DMARK
2890						CALLMONITOR 
2890 cd 2d 17			call break_point_state  
2893				endm  
# End of macro CALLMONITOR
2893					endif 
2893			 
2893					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2893 cd b4 1e			call macro_dsp_valuehl 
2896				endm 
# End of macro FORTH_DSP_VALUEHL
2896			 
2896			;		push hl 
2896			 
2896					; destroy value TOS 
2896			 
2896					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2896 cd 6c 1f			call macro_forth_dsp_pop 
2899				endm 
# End of macro FORTH_DSP_POP
2899			 
2899			;		pop hl 
2899			 
2899 3e 00				ld a,0 
289b bd					cp l 
289c 28 02				jr z, .bpset 
289e 3e 2a				ld a, '*' 
28a0			 
28a0 32 94 ef		.bpset:		ld (os_view_disable), a 
28a3			 
28a3			 
28a3					NEXTW 
28a3 c3 26 20			jp macro_next 
28a6				endm 
# End of macro NEXTW
28a6			 
28a6			 
28a6			.MONITOR: 
28a6				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28a6 55				db WORD_SYS_CORE+65             
28a7 d9 28			dw .MALLOC            
28a9 08				db 7 + 1 
28aa .. 00			db "MONITOR",0              
28b2				endm 
# End of macro CWHEAD
28b2			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28b2			; | | At start the current various registers will be displayed with contents. 
28b2			; | | Top right corner will show the most recent debug marker seen. 
28b2			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28b2			; | | and the return stack pointer (RSP). 
28b2			; | | Pressing: 
28b2			; | |    1 - Initial screen 
28b2			; | |    2 - Display a data dump of HL 
28b2			; | |    3 - Display a data dump of DE 
28b2			; | |    4 - Display a data dump of BC 
28b2			; | |    5 - Display a data dump of HL 
28b2			; | |    6 - Display a data dump of DSP 
28b2			; | |    7 - Display a data dump of RSP 
28b2			; | |    8 - Display a data dump of what is at DSP 
28b2			; | |    9 - Display a data dump of what is at RSP 
28b2			; | |    0 - Exit monitor and continue running. This will also enable break points 
28b2			; | |    * - Disable break points 
28b2			; | |    # - Enter traditional monitor mode 
28b2			; | | 
28b2			; | | Monitor Mode 
28b2			; | | ------------ 
28b2			; | | A prompt of '>' will be shown for various commands: 
28b2			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28b2			; | |    C - Continue display a data dump from the last set address 
28b2			; | |    M xxxx - Set start of memory edit at address xx 
28b2			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28b2			; | |    Q - Return to previous 
28b2					if DEBUG_FORTH_WORDS_KEY 
28b2						DMARK "MON" 
28b2 f5				push af  
28b3 3a c7 28			ld a, (.dmark)  
28b6 32 bd fb			ld (debug_mark),a  
28b9 3a c8 28			ld a, (.dmark+1)  
28bc 32 be fb			ld (debug_mark+1),a  
28bf 3a c9 28			ld a, (.dmark+2)  
28c2 32 bf fb			ld (debug_mark+2),a  
28c5 18 03			jr .pastdmark  
28c7 ..			.dmark: db "MON"  
28ca f1			.pastdmark: pop af  
28cb			endm  
# End of macro DMARK
28cb						CALLMONITOR 
28cb cd 2d 17			call break_point_state  
28ce				endm  
# End of macro CALLMONITOR
28ce					endif 
28ce 3e 00				ld a, 0 
28d0 32 94 ef				ld (os_view_disable), a 
28d3			 
28d3					CALLMONITOR 
28d3 cd 2d 17			call break_point_state  
28d6				endm  
# End of macro CALLMONITOR
28d6			 
28d6			;	call monitor 
28d6			 
28d6					NEXTW 
28d6 c3 26 20			jp macro_next 
28d9				endm 
# End of macro NEXTW
28d9			 
28d9			 
28d9			.MALLOC: 
28d9				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28d9 56				db WORD_SYS_CORE+66             
28da 02 29			dw .MALLOC2            
28dc 06				db 5 + 1 
28dd .. 00			db "ALLOT",0              
28e3				endm 
# End of macro CWHEAD
28e3			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28e3					if DEBUG_FORTH_WORDS_KEY 
28e3						DMARK "ALL" 
28e3 f5				push af  
28e4 3a f8 28			ld a, (.dmark)  
28e7 32 bd fb			ld (debug_mark),a  
28ea 3a f9 28			ld a, (.dmark+1)  
28ed 32 be fb			ld (debug_mark+1),a  
28f0 3a fa 28			ld a, (.dmark+2)  
28f3 32 bf fb			ld (debug_mark+2),a  
28f6 18 03			jr .pastdmark  
28f8 ..			.dmark: db "ALL"  
28fb f1			.pastdmark: pop af  
28fc			endm  
# End of macro DMARK
28fc						CALLMONITOR 
28fc cd 2d 17			call break_point_state  
28ff				endm  
# End of macro CALLMONITOR
28ff					endif 
28ff c3 29 29				jp .mallocc 
2902			.MALLOC2: 
2902				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2902 56				db WORD_SYS_CORE+66             
2903 40 29			dw .FREE            
2905 07				db 6 + 1 
2906 .. 00			db "MALLOC",0              
290d				endm 
# End of macro CWHEAD
290d			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
290d					; get byte count 
290d					if DEBUG_FORTH_WORDS_KEY 
290d						DMARK "MAL" 
290d f5				push af  
290e 3a 22 29			ld a, (.dmark)  
2911 32 bd fb			ld (debug_mark),a  
2914 3a 23 29			ld a, (.dmark+1)  
2917 32 be fb			ld (debug_mark+1),a  
291a 3a 24 29			ld a, (.dmark+2)  
291d 32 bf fb			ld (debug_mark+2),a  
2920 18 03			jr .pastdmark  
2922 ..			.dmark: db "MAL"  
2925 f1			.pastdmark: pop af  
2926			endm  
# End of macro DMARK
2926						CALLMONITOR 
2926 cd 2d 17			call break_point_state  
2929				endm  
# End of macro CALLMONITOR
2929					endif 
2929			.mallocc: 
2929					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2929 cd b4 1e			call macro_dsp_valuehl 
292c				endm 
# End of macro FORTH_DSP_VALUEHL
292c			 
292c			;		push hl 
292c			 
292c					; destroy value TOS 
292c			 
292c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
292c cd 6c 1f			call macro_forth_dsp_pop 
292f				endm 
# End of macro FORTH_DSP_POP
292f			 
292f			;		pop hl 
292f cd e1 11				call malloc 
2932				if DEBUG_FORTH_MALLOC_GUARD 
2932 f5					push af 
2933 cd 43 0d				call ishlzero 
2936			;		ld a, l 
2936			;		add h 
2936			;		cp 0 
2936 f1					pop af 
2937					 
2937 cc a2 51				call z,malloc_error 
293a				endif 
293a			 
293a cd bd 1c				call forth_push_numhl 
293d					NEXTW 
293d c3 26 20			jp macro_next 
2940				endm 
# End of macro NEXTW
2940			 
2940			.FREE: 
2940				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2940 57				db WORD_SYS_CORE+67             
2941 71 29			dw .LIST            
2943 05				db 4 + 1 
2944 .. 00			db "FREE",0              
2949				endm 
# End of macro CWHEAD
2949			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2949					if DEBUG_FORTH_WORDS_KEY 
2949						DMARK "FRE" 
2949 f5				push af  
294a 3a 5e 29			ld a, (.dmark)  
294d 32 bd fb			ld (debug_mark),a  
2950 3a 5f 29			ld a, (.dmark+1)  
2953 32 be fb			ld (debug_mark+1),a  
2956 3a 60 29			ld a, (.dmark+2)  
2959 32 bf fb			ld (debug_mark+2),a  
295c 18 03			jr .pastdmark  
295e ..			.dmark: db "FRE"  
2961 f1			.pastdmark: pop af  
2962			endm  
# End of macro DMARK
2962						CALLMONITOR 
2962 cd 2d 17			call break_point_state  
2965				endm  
# End of macro CALLMONITOR
2965					endif 
2965					; get address 
2965			 
2965					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2965 cd b4 1e			call macro_dsp_valuehl 
2968				endm 
# End of macro FORTH_DSP_VALUEHL
2968			 
2968			;		push hl 
2968			 
2968					; destroy value TOS 
2968			 
2968					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2968 cd 6c 1f			call macro_forth_dsp_pop 
296b				endm 
# End of macro FORTH_DSP_POP
296b			 
296b			;		pop hl 
296b			if FORTH_ENABLE_MALLOCFREE 
296b cd ab 12				call free 
296e			endif 
296e					NEXTW 
296e c3 26 20			jp macro_next 
2971				endm 
# End of macro NEXTW
2971			.LIST: 
2971				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2971 5c				db WORD_SYS_CORE+72             
2972 5f 2b			dw .FORGET            
2974 05				db 4 + 1 
2975 .. 00			db "LIST",0              
297a				endm 
# End of macro CWHEAD
297a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
297a			; | | The quoted word must be in upper case. 
297a				if DEBUG_FORTH_WORDS_KEY 
297a					DMARK "LST" 
297a f5				push af  
297b 3a 8f 29			ld a, (.dmark)  
297e 32 bd fb			ld (debug_mark),a  
2981 3a 90 29			ld a, (.dmark+1)  
2984 32 be fb			ld (debug_mark+1),a  
2987 3a 91 29			ld a, (.dmark+2)  
298a 32 bf fb			ld (debug_mark+2),a  
298d 18 03			jr .pastdmark  
298f ..			.dmark: db "LST"  
2992 f1			.pastdmark: pop af  
2993			endm  
# End of macro DMARK
2993					CALLMONITOR 
2993 cd 2d 17			call break_point_state  
2996				endm  
# End of macro CALLMONITOR
2996				endif 
2996			 
2996					FORTH_DSP_VALUEHL 
2996 cd b4 1e			call macro_dsp_valuehl 
2999				endm 
# End of macro FORTH_DSP_VALUEHL
2999			 
2999 e5					push hl 
299a					FORTH_DSP_POP 
299a cd 6c 1f			call macro_forth_dsp_pop 
299d				endm 
# End of macro FORTH_DSP_POP
299d c1					pop bc 
299e			 
299e			; Start format of scratch string 
299e			 
299e 21 a3 ef				ld hl, scratch 
29a1			 
29a1 3e 3a				ld a, ':' 
29a3 77					ld (hl),a 
29a4 23					inc hl 
29a5 3e 20				ld a, ' ' 
29a7 77					ld (hl), a 
29a8			 
29a8					; Get ptr to the word we need to look up 
29a8			 
29a8			;		FORTH_DSP_VALUEHL 
29a8					;v5 FORTH_DSP_VALUE 
29a8				; TODO type check 
29a8			;		inc hl    ; Skip type check  
29a8			;		push hl 
29a8			;		ex de, hl    ; put into DE 
29a8			 
29a8			 
29a8 21 00 80				ld hl, baseram 
29ab					;ld hl, baseusermem 
29ab			 
29ab e5			push hl   ; sacreifical push 
29ac			 
29ac			.ldouscanm: 
29ac e1				pop hl 
29ad			.ldouscan: 
29ad				if DEBUG_FORTH_WORDS 
29ad					DMARK "LSs" 
29ad f5				push af  
29ae 3a c2 29			ld a, (.dmark)  
29b1 32 bd fb			ld (debug_mark),a  
29b4 3a c3 29			ld a, (.dmark+1)  
29b7 32 be fb			ld (debug_mark+1),a  
29ba 3a c4 29			ld a, (.dmark+2)  
29bd 32 bf fb			ld (debug_mark+2),a  
29c0 18 03			jr .pastdmark  
29c2 ..			.dmark: db "LSs"  
29c5 f1			.pastdmark: pop af  
29c6			endm  
# End of macro DMARK
29c6					CALLMONITOR 
29c6 cd 2d 17			call break_point_state  
29c9				endm  
# End of macro CALLMONITOR
29c9				endif 
29c9				; skip dict stub 
29c9 cd 77 21				call forth_tok_next 
29cc			 
29cc			 
29cc			; while we have words to look for 
29cc			 
29cc 7e				ld a, (hl)      
29cd				if DEBUG_FORTH_WORDS 
29cd					DMARK "LSk" 
29cd f5				push af  
29ce 3a e2 29			ld a, (.dmark)  
29d1 32 bd fb			ld (debug_mark),a  
29d4 3a e3 29			ld a, (.dmark+1)  
29d7 32 be fb			ld (debug_mark+1),a  
29da 3a e4 29			ld a, (.dmark+2)  
29dd 32 bf fb			ld (debug_mark+2),a  
29e0 18 03			jr .pastdmark  
29e2 ..			.dmark: db "LSk"  
29e5 f1			.pastdmark: pop af  
29e6			endm  
# End of macro DMARK
29e6					CALLMONITOR 
29e6 cd 2d 17			call break_point_state  
29e9				endm  
# End of macro CALLMONITOR
29e9				endif 
29e9					;cp WORD_SYS_END 
29e9					;jp z, .lunotfound 
29e9			 
29e9					; if we hit non uwords then gone too far 
29e9 fe 01				cp WORD_SYS_UWORD 
29eb c2 1b 2b				jp nz, .lunotfound 
29ee			 
29ee				if DEBUG_FORTH_WORDS 
29ee					DMARK "LSu" 
29ee f5				push af  
29ef 3a 03 2a			ld a, (.dmark)  
29f2 32 bd fb			ld (debug_mark),a  
29f5 3a 04 2a			ld a, (.dmark+1)  
29f8 32 be fb			ld (debug_mark+1),a  
29fb 3a 05 2a			ld a, (.dmark+2)  
29fe 32 bf fb			ld (debug_mark+2),a  
2a01 18 03			jr .pastdmark  
2a03 ..			.dmark: db "LSu"  
2a06 f1			.pastdmark: pop af  
2a07			endm  
# End of macro DMARK
2a07					CALLMONITOR 
2a07 cd 2d 17			call break_point_state  
2a0a				endm  
# End of macro CALLMONITOR
2a0a				endif 
2a0a			 
2a0a					; found a uword but is it the one we want... 
2a0a			 
2a0a c5					push bc     ; uword to find is on bc 
2a0b d1					pop de 
2a0c			 
2a0c e5					push hl  ; to save the ptr 
2a0d			 
2a0d					; skip opcode 
2a0d 23					inc hl  
2a0e					; skip next ptr 
2a0e 23					inc hl  
2a0f 23					inc hl 
2a10					; skip len 
2a10 23					inc hl 
2a11			 
2a11				if DEBUG_FORTH_WORDS 
2a11					DMARK "LSc" 
2a11 f5				push af  
2a12 3a 26 2a			ld a, (.dmark)  
2a15 32 bd fb			ld (debug_mark),a  
2a18 3a 27 2a			ld a, (.dmark+1)  
2a1b 32 be fb			ld (debug_mark+1),a  
2a1e 3a 28 2a			ld a, (.dmark+2)  
2a21 32 bf fb			ld (debug_mark+2),a  
2a24 18 03			jr .pastdmark  
2a26 ..			.dmark: db "LSc"  
2a29 f1			.pastdmark: pop af  
2a2a			endm  
# End of macro DMARK
2a2a					CALLMONITOR 
2a2a cd 2d 17			call break_point_state  
2a2d				endm  
# End of macro CALLMONITOR
2a2d				endif 
2a2d cd b0 11				call strcmp 
2a30 c2 ac 29				jp nz, .ldouscanm 
2a33				 
2a33			 
2a33			 
2a33					; we have a uword so push its name to the stack 
2a33			 
2a33			;	   	push hl  ; save so we can move to next dict block 
2a33 e1			pop hl 
2a34			 
2a34				if DEBUG_FORTH_WORDS 
2a34					DMARK "LSm" 
2a34 f5				push af  
2a35 3a 49 2a			ld a, (.dmark)  
2a38 32 bd fb			ld (debug_mark),a  
2a3b 3a 4a 2a			ld a, (.dmark+1)  
2a3e 32 be fb			ld (debug_mark+1),a  
2a41 3a 4b 2a			ld a, (.dmark+2)  
2a44 32 bf fb			ld (debug_mark+2),a  
2a47 18 03			jr .pastdmark  
2a49 ..			.dmark: db "LSm"  
2a4c f1			.pastdmark: pop af  
2a4d			endm  
# End of macro DMARK
2a4d					CALLMONITOR 
2a4d cd 2d 17			call break_point_state  
2a50				endm  
# End of macro CALLMONITOR
2a50				endif 
2a50			 
2a50					; skip opcode 
2a50 23					inc hl  
2a51					; skip next ptr 
2a51 23					inc hl  
2a52 23					inc hl 
2a53					; skip len 
2a53 7e					ld a, (hl)   ; save length to add 
2a54				if DEBUG_FORTH_WORDS 
2a54					DMARK "LS2" 
2a54 f5				push af  
2a55 3a 69 2a			ld a, (.dmark)  
2a58 32 bd fb			ld (debug_mark),a  
2a5b 3a 6a 2a			ld a, (.dmark+1)  
2a5e 32 be fb			ld (debug_mark+1),a  
2a61 3a 6b 2a			ld a, (.dmark+2)  
2a64 32 bf fb			ld (debug_mark+2),a  
2a67 18 03			jr .pastdmark  
2a69 ..			.dmark: db "LS2"  
2a6c f1			.pastdmark: pop af  
2a6d			endm  
# End of macro DMARK
2a6d					CALLMONITOR 
2a6d cd 2d 17			call break_point_state  
2a70				endm  
# End of macro CALLMONITOR
2a70				endif 
2a70			 
2a70					; save this location 
2a70				 
2a70 e5					push hl 
2a71			 
2a71 23					inc hl 
2a72 11 a5 ef				ld de, scratch+2 
2a75 4f					ld c, a 
2a76 06 00				ld b, 0 
2a78			 
2a78				if DEBUG_FORTH_WORDS 
2a78					DMARK "LSn" 
2a78 f5				push af  
2a79 3a 8d 2a			ld a, (.dmark)  
2a7c 32 bd fb			ld (debug_mark),a  
2a7f 3a 8e 2a			ld a, (.dmark+1)  
2a82 32 be fb			ld (debug_mark+1),a  
2a85 3a 8f 2a			ld a, (.dmark+2)  
2a88 32 bf fb			ld (debug_mark+2),a  
2a8b 18 03			jr .pastdmark  
2a8d ..			.dmark: db "LSn"  
2a90 f1			.pastdmark: pop af  
2a91			endm  
# End of macro DMARK
2a91					CALLMONITOR 
2a91 cd 2d 17			call break_point_state  
2a94				endm  
# End of macro CALLMONITOR
2a94				endif 
2a94			 
2a94					; copy uword name to scratch 
2a94			 
2a94 ed b0				ldir 
2a96			 
2a96 1b					dec de 
2a97 3e 20				ld a, ' '    ; change null to space 
2a99 12					ld (de), a 
2a9a			 
2a9a 13					inc de 
2a9b			 
2a9b d5					push de 
2a9c c1					pop bc     ; move scratch pointer to end of word name and save it 
2a9d			 
2a9d e1					pop hl 
2a9e 7e					ld a, (hl) 
2a9f					;inc hl 
2a9f					; skip word string 
2a9f cd 1a 0d				call addatohl 
2aa2			 
2aa2 23					inc hl 
2aa3			 
2aa3				if DEBUG_FORTH_WORDS 
2aa3					DMARK "LS3" 
2aa3 f5				push af  
2aa4 3a b8 2a			ld a, (.dmark)  
2aa7 32 bd fb			ld (debug_mark),a  
2aaa 3a b9 2a			ld a, (.dmark+1)  
2aad 32 be fb			ld (debug_mark+1),a  
2ab0 3a ba 2a			ld a, (.dmark+2)  
2ab3 32 bf fb			ld (debug_mark+2),a  
2ab6 18 03			jr .pastdmark  
2ab8 ..			.dmark: db "LS3"  
2abb f1			.pastdmark: pop af  
2abc			endm  
# End of macro DMARK
2abc					CALLMONITOR 
2abc cd 2d 17			call break_point_state  
2abf				endm  
# End of macro CALLMONITOR
2abf				endif 
2abf					; should now be at the start of the machine code to setup the eval of the uword 
2abf					; now locate the ptr to the string defintion 
2abf			 
2abf					; skip ld hl, 
2abf					; then load the ptr 
2abf			; TODO use get from hl ptr 
2abf 23					inc hl 
2ac0 5e					ld e, (hl) 
2ac1 23					inc hl 
2ac2 56					ld d, (hl) 
2ac3 eb					ex de, hl 
2ac4			 
2ac4			 
2ac4				if DEBUG_FORTH_WORDS 
2ac4					DMARK "LSt" 
2ac4 f5				push af  
2ac5 3a d9 2a			ld a, (.dmark)  
2ac8 32 bd fb			ld (debug_mark),a  
2acb 3a da 2a			ld a, (.dmark+1)  
2ace 32 be fb			ld (debug_mark+1),a  
2ad1 3a db 2a			ld a, (.dmark+2)  
2ad4 32 bf fb			ld (debug_mark+2),a  
2ad7 18 03			jr .pastdmark  
2ad9 ..			.dmark: db "LSt"  
2adc f1			.pastdmark: pop af  
2add			endm  
# End of macro DMARK
2add					CALLMONITOR 
2add cd 2d 17			call break_point_state  
2ae0				endm  
# End of macro CALLMONITOR
2ae0				endif 
2ae0			 
2ae0			; cant push right now due to tokenised strings  
2ae0			 
2ae0			; get the destination of where to copy this definition to. 
2ae0			 
2ae0 c5					push bc 
2ae1 d1					pop de 
2ae2			 
2ae2 7e			.listl:         ld a,(hl) 
2ae3 fe 00				cp 0 
2ae5 28 09				jr z, .lreplsp     ; replace zero with space 
2ae7					;cp FORTH_END_BUFFER 
2ae7 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ae9 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2aeb				 
2aeb					; just copy this char as is then 
2aeb			 
2aeb 12					ld (de), a 
2aec			 
2aec 23			.listnxt:	inc hl 
2aed 13					inc de 
2aee 18 f2				jr .listl 
2af0			 
2af0 3e 20		.lreplsp:	ld a,' ' 
2af2 12					ld (de), a 
2af3 18 f7				jr .listnxt 
2af5			 
2af5			; close up uword def 
2af5			 
2af5			.listdone: 
2af5 12					ld (de), a 
2af6 13					inc de 
2af7 3e 00				ld a, 0 
2af9 12					ld (de), a 
2afa			 
2afa			; now have def so clean up and push to stack 
2afa			 
2afa 21 a3 ef				ld hl, scratch 
2afd				if DEBUG_FORTH_WORDS 
2afd					DMARK "Ltp" 
2afd f5				push af  
2afe 3a 12 2b			ld a, (.dmark)  
2b01 32 bd fb			ld (debug_mark),a  
2b04 3a 13 2b			ld a, (.dmark+1)  
2b07 32 be fb			ld (debug_mark+1),a  
2b0a 3a 14 2b			ld a, (.dmark+2)  
2b0d 32 bf fb			ld (debug_mark+2),a  
2b10 18 03			jr .pastdmark  
2b12 ..			.dmark: db "Ltp"  
2b15 f1			.pastdmark: pop af  
2b16			endm  
# End of macro DMARK
2b16					CALLMONITOR 
2b16 cd 2d 17			call break_point_state  
2b19				endm  
# End of macro CALLMONITOR
2b19				endif 
2b19			 
2b19 18 1f			jr .listpush 
2b1b			 
2b1b			;.lnuword:	pop hl 
2b1b			;		call forth_tok_next 
2b1b			;		jp .ldouscan  
2b1b			 
2b1b			.lunotfound:		  
2b1b			 
2b1b				if DEBUG_FORTH_WORDS 
2b1b					DMARK "LSn" 
2b1b f5				push af  
2b1c 3a 30 2b			ld a, (.dmark)  
2b1f 32 bd fb			ld (debug_mark),a  
2b22 3a 31 2b			ld a, (.dmark+1)  
2b25 32 be fb			ld (debug_mark+1),a  
2b28 3a 32 2b			ld a, (.dmark+2)  
2b2b 32 bf fb			ld (debug_mark+2),a  
2b2e 18 03			jr .pastdmark  
2b30 ..			.dmark: db "LSn"  
2b33 f1			.pastdmark: pop af  
2b34			endm  
# End of macro DMARK
2b34					CALLMONITOR 
2b34 cd 2d 17			call break_point_state  
2b37				endm  
# End of macro CALLMONITOR
2b37				endif 
2b37			 
2b37					 
2b37			;		FORTH_DSP_POP 
2b37			;		ld hl, .luno 
2b37			 
2b37					NEXTW			 
2b37 c3 26 20			jp macro_next 
2b3a				endm 
# End of macro NEXTW
2b3a			 
2b3a			.listpush: 
2b3a				if DEBUG_FORTH_WORDS 
2b3a					DMARK "LS>" 
2b3a f5				push af  
2b3b 3a 4f 2b			ld a, (.dmark)  
2b3e 32 bd fb			ld (debug_mark),a  
2b41 3a 50 2b			ld a, (.dmark+1)  
2b44 32 be fb			ld (debug_mark+1),a  
2b47 3a 51 2b			ld a, (.dmark+2)  
2b4a 32 bf fb			ld (debug_mark+2),a  
2b4d 18 03			jr .pastdmark  
2b4f ..			.dmark: db "LS>"  
2b52 f1			.pastdmark: pop af  
2b53			endm  
# End of macro DMARK
2b53					CALLMONITOR 
2b53 cd 2d 17			call break_point_state  
2b56				endm  
# End of macro CALLMONITOR
2b56				endif 
2b56 cd 2b 1d				call forth_push_str 
2b59			 
2b59			 
2b59			 
2b59					NEXTW 
2b59 c3 26 20			jp macro_next 
2b5c				endm 
# End of macro NEXTW
2b5c			 
2b5c			;.luno:    db "Word not found",0 
2b5c			 
2b5c			 
2b5c			 
2b5c			 
2b5c			 
2b5c			;		push hl   ; save pointer to start of uword def string 
2b5c			; 
2b5c			;; look for FORTH_EOL_LINE 
2b5c			;		ld a, FORTH_END_BUFFER 
2b5c			;		call strlent 
2b5c			; 
2b5c			;		inc hl		 ; space for coln def 
2b5c			;		inc hl 
2b5c			;		inc hl          ; space for terms 
2b5c			;		inc hl 
2b5c			; 
2b5c			;		ld a, 20   ; TODO get actual length 
2b5c			;		call addatohl    ; include a random amount of room for the uword name 
2b5c			; 
2b5c			;		 
2b5c			;	if DEBUG_FORTH_WORDS 
2b5c			;		DMARK "Lt1" 
2b5c			;		CALLMONITOR 
2b5c			;	endif 
2b5c			;		 
2b5c			; 
2b5c			;; malloc space for the string because we cant change it 
2b5c			; 
2b5c			;		call malloc 
2b5c			;	if DEBUG_FORTH_MALLOC_GUARD 
2b5c			;		push af 
2b5c			;		call ishlzero 
2b5c			;		pop af 
2b5c			;		 
2b5c			;		call z,malloc_error 
2b5c			;	endif 
2b5c			; 
2b5c			;	if DEBUG_FORTH_WORDS 
2b5c			;		DMARK "Lt2" 
2b5c			;		CALLMONITOR 
2b5c			;	endif 
2b5c			;		pop de 
2b5c			;		push hl    ; push the malloc to release later 
2b5c			;		push hl   ;  push back a copy for the later stack push 
2b5c			;		 
2b5c			;; copy the string swapping out the zero terms for spaces 
2b5c			; 
2b5c			;		; de has our source 
2b5c			;		; hl has our dest 
2b5c			; 
2b5c			;; add the coln def 
2b5c			; 
2b5c			;		ld a, ':' 
2b5c			;		ld (hl), a 
2b5c			;		inc hl 
2b5c			;		ld a, ' ' 
2b5c			;		ld (hl), a 
2b5c			;		inc hl 
2b5c			; 
2b5c			;; add the uname word 
2b5c			;		push de   ; save our string for now 
2b5c			;		ex de, hl 
2b5c			; 
2b5c			;		FORTH_DSP_VALUE 
2b5c			;		;v5 FORTH_DSP_VALUE 
2b5c			; 
2b5c			;		inc hl   ; skip type but we know by now this is OK 
2b5c			; 
2b5c			;.luword:	ld a,(hl) 
2b5c			;		cp 0 
2b5c			;		jr z, .luword2 
2b5c			;		ld (de), a 
2b5c			;		inc de 
2b5c			;		inc hl 
2b5c			;		jr .luword 
2b5c			; 
2b5c			;.luword2:	ld a, ' ' 
2b5c			;		ld (de), a 
2b5c			;;		inc hl 
2b5c			;;		inc de 
2b5c			;;		ld (de), a 
2b5c			;;		inc hl 
2b5c			;		inc de 
2b5c			; 
2b5c			;		ex de, hl 
2b5c			;		pop de 
2b5c			;		 
2b5c			;		 
2b5c			; 
2b5c			;; detoken that string and copy it 
2b5c			; 
2b5c			;	if DEBUG_FORTH_WORDS 
2b5c			;		DMARK "Lt2" 
2b5c			;		CALLMONITOR 
2b5c			;	endif 
2b5c			;.ldetok:	ld a, (de) 
2b5c			;		cp FORTH_END_BUFFER 
2b5c			;		jr z, .ldetokend 
2b5c			;		; swap out any zero term for space 
2b5c			;		cp 0 
2b5c			;		jr nz, .ldetoknext 
2b5c			;		ld a, ' ' 
2b5c			; 
2b5c			;	if DEBUG_FORTH_WORDS 
2b5c			;		DMARK "LtS" 
2b5c			;		CALLMONITOR 
2b5c			;	endif 
2b5c			;.ldetoknext:	ld (hl), a 
2b5c			;		inc de 
2b5c			;		inc hl 
2b5c			;		jr .ldetok 
2b5c			; 
2b5c			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b5c			;		ld (hl), a  
2b5c			; 
2b5c			;; free that temp malloc 
2b5c			; 
2b5c			;		pop hl    
2b5c			; 
2b5c			;	if DEBUG_FORTH_WORDS 
2b5c			;		DMARK "Lt4" 
2b5c			;		CALLMONITOR 
2b5c			;	endif 
2b5c			;		call forth_apushstrhl 
2b5c			; 
2b5c			;		; get rid of temp malloc area 
2b5c			; 
2b5c			;		pop hl 
2b5c			;		call free 
2b5c			; 
2b5c			;		jr .ludone 
2b5c			; 
2b5c			;.lnuword:	pop hl 
2b5c			;		call forth_tok_next 
2b5c			;		jp .ldouscan  
2b5c			; 
2b5c			;.ludone:		 pop hl 
2b5c			; 
2b5c					NEXTW 
2b5c c3 26 20			jp macro_next 
2b5f				endm 
# End of macro NEXTW
2b5f			 
2b5f			.FORGET: 
2b5f				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b5f 5d				db WORD_SYS_CORE+73             
2b60 d8 2b			dw .NOP            
2b62 07				db 6 + 1 
2b63 .. 00			db "FORGET",0              
2b6a				endm 
# End of macro CWHEAD
2b6a			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b6a			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b6a			; | |  
2b6a			; | | e.g. "MORE" forget 
2b6a					if DEBUG_FORTH_WORDS_KEY 
2b6a						DMARK "FRG" 
2b6a f5				push af  
2b6b 3a 7f 2b			ld a, (.dmark)  
2b6e 32 bd fb			ld (debug_mark),a  
2b71 3a 80 2b			ld a, (.dmark+1)  
2b74 32 be fb			ld (debug_mark+1),a  
2b77 3a 81 2b			ld a, (.dmark+2)  
2b7a 32 bf fb			ld (debug_mark+2),a  
2b7d 18 03			jr .pastdmark  
2b7f ..			.dmark: db "FRG"  
2b82 f1			.pastdmark: pop af  
2b83			endm  
# End of macro DMARK
2b83						CALLMONITOR 
2b83 cd 2d 17			call break_point_state  
2b86				endm  
# End of macro CALLMONITOR
2b86					endif 
2b86			 
2b86				; find uword 
2b86			        ; update start of word with "_" 
2b86				; replace uword with deleted flag 
2b86			 
2b86			 
2b86			;	if DEBUG_FORTH_WORDS 
2b86			;		DMARK "FOG" 
2b86			;		CALLMONITOR 
2b86			;	endif 
2b86			 
2b86			 
2b86					; Get ptr to the word we need to look up 
2b86			 
2b86					FORTH_DSP_VALUEHL 
2b86 cd b4 1e			call macro_dsp_valuehl 
2b89				endm 
# End of macro FORTH_DSP_VALUEHL
2b89					;v5 FORTH_DSP_VALUE 
2b89				; TODO type check 
2b89			;		inc hl    ; Skip type check  
2b89 e5					push hl 
2b8a c1					pop bc 
2b8b			;		ex de, hl    ; put into DE 
2b8b			 
2b8b			 
2b8b 21 00 80				ld hl, baseram 
2b8e					;ld hl, baseusermem 
2b8e			 
2b8e				; skip dict stub 
2b8e			;	call forth_tok_next 
2b8e e5			push hl   ; sacreifical push 
2b8f			 
2b8f			.fldouscanm: 
2b8f e1				pop hl 
2b90			.fldouscan: 
2b90			;	if DEBUG_FORTH_WORDS 
2b90			;		DMARK "LSs" 
2b90			;		CALLMONITOR 
2b90			;	endif 
2b90				; skip dict stub 
2b90 cd 77 21				call forth_tok_next 
2b93			 
2b93			 
2b93			; while we have words to look for 
2b93			 
2b93 7e				ld a, (hl)      
2b94			;	if DEBUG_FORTH_WORDS 
2b94			;		DMARK "LSk" 
2b94			;		CALLMONITOR 
2b94			;	endif 
2b94 fe 00				cp WORD_SYS_END 
2b96 ca d2 2b				jp z, .flunotfound 
2b99 fe 01				cp WORD_SYS_UWORD 
2b9b c2 90 2b				jp nz, .fldouscan 
2b9e			 
2b9e			;	if DEBUG_FORTH_WORDS 
2b9e			;		DMARK "LSu" 
2b9e			;		CALLMONITOR 
2b9e			;	endif 
2b9e			 
2b9e					; found a uword but is it the one we want... 
2b9e			 
2b9e c5					push bc     ; uword to find is on bc 
2b9f d1					pop de 
2ba0			 
2ba0 e5					push hl  ; to save the ptr 
2ba1			 
2ba1					; skip opcode 
2ba1 23					inc hl  
2ba2					; skip next ptr 
2ba2 23					inc hl  
2ba3 23					inc hl 
2ba4					; skip len 
2ba4 23					inc hl 
2ba5			 
2ba5			;	if DEBUG_FORTH_WORDS 
2ba5			;		DMARK "LSc" 
2ba5			;		CALLMONITOR 
2ba5			;	endif 
2ba5 cd b0 11				call strcmp 
2ba8 c2 8f 2b				jp nz, .fldouscanm 
2bab			; 
2bab			; 
2bab			;; while we have words to look for 
2bab			; 
2bab			;.fdouscan:	ld a, (hl)      
2bab			;	if DEBUG_FORTH_WORDS 
2bab			;		DMARK "LSs" 
2bab			;		CALLMONITOR 
2bab			;	endif 
2bab			;		cp WORD_SYS_END 
2bab			;		jp z, .fudone 
2bab			;		cp WORD_SYS_UWORD 
2bab			;		jp nz, .fnuword 
2bab			; 
2bab			;	if DEBUG_FORTH_WORDS 
2bab			;		DMARK "FGu" 
2bab			;		CALLMONITOR 
2bab			;	endif 
2bab			; 
2bab			;		; found a uword but is it the one we want... 
2bab			; 
2bab			; 
2bab			;	        pop de   ; get back the dsp name 
2bab			;		push de 
2bab			; 
2bab			;		push hl  ; to save the ptr 
2bab			; 
2bab			;		; skip opcode 
2bab			;		inc hl  
2bab			;		; skip next ptr 
2bab			;		inc hl  
2bab			;		inc hl 
2bab			;		; skip len 
2bab			;		inc hl 
2bab			; 
2bab			;	if DEBUG_FORTH_WORDS 
2bab			;		DMARK "FGc" 
2bab			;		CALLMONITOR 
2bab			;	endif 
2bab			;		call strcmp 
2bab			;		jp nz, .fnuword 
2bab			 
2bab			 
2bab e1			pop hl 
2bac			 
2bac				 
2bac				if DEBUG_FORTH_WORDS 
2bac					DMARK "FGm" 
2bac f5				push af  
2bad 3a c1 2b			ld a, (.dmark)  
2bb0 32 bd fb			ld (debug_mark),a  
2bb3 3a c2 2b			ld a, (.dmark+1)  
2bb6 32 be fb			ld (debug_mark+1),a  
2bb9 3a c3 2b			ld a, (.dmark+2)  
2bbc 32 bf fb			ld (debug_mark+2),a  
2bbf 18 03			jr .pastdmark  
2bc1 ..			.dmark: db "FGm"  
2bc4 f1			.pastdmark: pop af  
2bc5			endm  
# End of macro DMARK
2bc5					CALLMONITOR 
2bc5 cd 2d 17			call break_point_state  
2bc8				endm  
# End of macro CALLMONITOR
2bc8				endif 
2bc8			 
2bc8			 
2bc8			 
2bc8					; we have a uword so push its name to the stack 
2bc8			 
2bc8			;	   	push hl  ; save so we can move to next dict block 
2bc8			;pop hl 
2bc8			 
2bc8					; update opcode to deleted 
2bc8 3e 03				ld a, WORD_SYS_DELETED 
2bca 77					ld (hl), a 
2bcb			 
2bcb 23					inc hl  
2bcc					; skip next ptr 
2bcc 23					inc hl  
2bcd 23					inc hl 
2bce					; skip len 
2bce 23					inc hl 
2bcf			 
2bcf					; TODO change parser to skip deleted words but for now mark it out 
2bcf 3e 5f				ld a, "_" 
2bd1 77					ld  (hl),a 
2bd2			 
2bd2			;		jr .fudone 
2bd2			; 
2bd2			;.fnuword:	pop hl 
2bd2			;		call forth_tok_next 
2bd2			;		jp .fdouscan  
2bd2			 
2bd2			.flunotfound:		  
2bd2			 
2bd2			 
2bd2					 
2bd2					FORTH_DSP_POP 
2bd2 cd 6c 1f			call macro_forth_dsp_pop 
2bd5				endm 
# End of macro FORTH_DSP_POP
2bd5			;		ld hl, .luno 
2bd5			;.fudone:		 pop hl 
2bd5					NEXTW 
2bd5 c3 26 20			jp macro_next 
2bd8				endm 
# End of macro NEXTW
2bd8			.NOP: 
2bd8				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bd8 61				db WORD_SYS_CORE+77             
2bd9 ff 2b			dw .COMO            
2bdb 04				db 3 + 1 
2bdc .. 00			db "NOP",0              
2be0				endm 
# End of macro CWHEAD
2be0			; | NOP (  --  ) Do nothing | DONE 
2be0					if DEBUG_FORTH_WORDS_KEY 
2be0						DMARK "NOP" 
2be0 f5				push af  
2be1 3a f5 2b			ld a, (.dmark)  
2be4 32 bd fb			ld (debug_mark),a  
2be7 3a f6 2b			ld a, (.dmark+1)  
2bea 32 be fb			ld (debug_mark+1),a  
2bed 3a f7 2b			ld a, (.dmark+2)  
2bf0 32 bf fb			ld (debug_mark+2),a  
2bf3 18 03			jr .pastdmark  
2bf5 ..			.dmark: db "NOP"  
2bf8 f1			.pastdmark: pop af  
2bf9			endm  
# End of macro DMARK
2bf9						CALLMONITOR 
2bf9 cd 2d 17			call break_point_state  
2bfc				endm  
# End of macro CALLMONITOR
2bfc					endif 
2bfc				       NEXTW 
2bfc c3 26 20			jp macro_next 
2bff				endm 
# End of macro NEXTW
2bff			.COMO: 
2bff				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bff 6e				db WORD_SYS_CORE+90             
2c00 51 2c			dw .COMC            
2c02 02				db 1 + 1 
2c03 .. 00			db "(",0              
2c05				endm 
# End of macro CWHEAD
2c05			; | ( ( -- )  Start of comment | DONE 
2c05			 
2c05			 
2c05 2a a4 f2				ld hl, ( os_tok_ptr) 
2c08 11 4c 2c			ld de, .closepar 
2c0b					 
2c0b					if DEBUG_FORTH_WORDS 
2c0b						DMARK ").." 
2c0b f5				push af  
2c0c 3a 20 2c			ld a, (.dmark)  
2c0f 32 bd fb			ld (debug_mark),a  
2c12 3a 21 2c			ld a, (.dmark+1)  
2c15 32 be fb			ld (debug_mark+1),a  
2c18 3a 22 2c			ld a, (.dmark+2)  
2c1b 32 bf fb			ld (debug_mark+2),a  
2c1e 18 03			jr .pastdmark  
2c20 ..			.dmark: db ").."  
2c23 f1			.pastdmark: pop af  
2c24			endm  
# End of macro DMARK
2c24						CALLMONITOR 
2c24 cd 2d 17			call break_point_state  
2c27				endm  
# End of macro CALLMONITOR
2c27					endif 
2c27 cd 41 21			call findnexttok  
2c2a			 
2c2a					if DEBUG_FORTH_WORDS 
2c2a						DMARK "IF5" 
2c2a f5				push af  
2c2b 3a 3f 2c			ld a, (.dmark)  
2c2e 32 bd fb			ld (debug_mark),a  
2c31 3a 40 2c			ld a, (.dmark+1)  
2c34 32 be fb			ld (debug_mark+1),a  
2c37 3a 41 2c			ld a, (.dmark+2)  
2c3a 32 bf fb			ld (debug_mark+2),a  
2c3d 18 03			jr .pastdmark  
2c3f ..			.dmark: db "IF5"  
2c42 f1			.pastdmark: pop af  
2c43			endm  
# End of macro DMARK
2c43						CALLMONITOR 
2c43 cd 2d 17			call break_point_state  
2c46				endm  
# End of macro CALLMONITOR
2c46					endif 
2c46				; replace below with ) exec using tok_ptr 
2c46 22 a4 f2			ld (os_tok_ptr), hl 
2c49 c3 b7 20			jp exec1 
2c4c			 
2c4c .. 00			.closepar:   db ")",0 
2c4e			 
2c4e				       NEXTW 
2c4e c3 26 20			jp macro_next 
2c51				endm 
# End of macro NEXTW
2c51			.COMC: 
2c51				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c51 6f				db WORD_SYS_CORE+91             
2c52 5a 2c			dw .SCRATCH            
2c54 02				db 1 + 1 
2c55 .. 00			db ")",0              
2c57				endm 
# End of macro CWHEAD
2c57			; | ) ( -- )  End of comment |  DONE  
2c57				       NEXTW 
2c57 c3 26 20			jp macro_next 
2c5a				endm 
# End of macro NEXTW
2c5a			 
2c5a			.SCRATCH: 
2c5a				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c5a 6f				db WORD_SYS_CORE+91             
2c5b 95 2c			dw .INC            
2c5d 08				db 7 + 1 
2c5e .. 00			db "SCRATCH",0              
2c66				endm 
# End of macro CWHEAD
2c66			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c66			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c66			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c66			; | |  
2c66			; | | e.g.    : score $00 scratch ; 
2c66			; | |  
2c66			; | | $00 score ! 
2c66			; | | $01 score +! 
2c66			; | |  
2c66			; | | e.g.   : varword $0a scratch ;  
2c66			; | | 
2c66			; | | $8000 varword ! 
2c66					if DEBUG_FORTH_WORDS_KEY 
2c66						DMARK "SCR" 
2c66 f5				push af  
2c67 3a 7b 2c			ld a, (.dmark)  
2c6a 32 bd fb			ld (debug_mark),a  
2c6d 3a 7c 2c			ld a, (.dmark+1)  
2c70 32 be fb			ld (debug_mark+1),a  
2c73 3a 7d 2c			ld a, (.dmark+2)  
2c76 32 bf fb			ld (debug_mark+2),a  
2c79 18 03			jr .pastdmark  
2c7b ..			.dmark: db "SCR"  
2c7e f1			.pastdmark: pop af  
2c7f			endm  
# End of macro DMARK
2c7f						CALLMONITOR 
2c7f cd 2d 17			call break_point_state  
2c82				endm  
# End of macro CALLMONITOR
2c82					endif 
2c82			 
2c82					FORTH_DSP_VALUEHL 
2c82 cd b4 1e			call macro_dsp_valuehl 
2c85				endm 
# End of macro FORTH_DSP_VALUEHL
2c85				 
2c85					FORTH_DSP_POP 
2c85 cd 6c 1f			call macro_forth_dsp_pop 
2c88				endm 
# End of macro FORTH_DSP_POP
2c88			 
2c88 7d					ld a, l 
2c89 21 c8 f4				ld hl, os_var_array 
2c8c cd 1a 0d				call addatohl 
2c8f			 
2c8f cd bd 1c				call forth_push_numhl 
2c92			 
2c92				       NEXTW 
2c92 c3 26 20			jp macro_next 
2c95				endm 
# End of macro NEXTW
2c95			 
2c95			.INC: 
2c95				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c95 6f				db WORD_SYS_CORE+91             
2c96 e9 2c			dw .DEC            
2c98 03				db 2 + 1 
2c99 .. 00			db "+!",0              
2c9c				endm 
# End of macro CWHEAD
2c9c			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c9c					if DEBUG_FORTH_WORDS_KEY 
2c9c						DMARK "+s_" 
2c9c f5				push af  
2c9d 3a b1 2c			ld a, (.dmark)  
2ca0 32 bd fb			ld (debug_mark),a  
2ca3 3a b2 2c			ld a, (.dmark+1)  
2ca6 32 be fb			ld (debug_mark+1),a  
2ca9 3a b3 2c			ld a, (.dmark+2)  
2cac 32 bf fb			ld (debug_mark+2),a  
2caf 18 03			jr .pastdmark  
2cb1 ..			.dmark: db "+s_"  
2cb4 f1			.pastdmark: pop af  
2cb5			endm  
# End of macro DMARK
2cb5						CALLMONITOR 
2cb5 cd 2d 17			call break_point_state  
2cb8				endm  
# End of macro CALLMONITOR
2cb8					endif 
2cb8			 
2cb8					FORTH_DSP_VALUEHL 
2cb8 cd b4 1e			call macro_dsp_valuehl 
2cbb				endm 
# End of macro FORTH_DSP_VALUEHL
2cbb			 
2cbb e5					push hl   ; save address 
2cbc			 
2cbc					FORTH_DSP_POP 
2cbc cd 6c 1f			call macro_forth_dsp_pop 
2cbf				endm 
# End of macro FORTH_DSP_POP
2cbf			 
2cbf					FORTH_DSP_VALUEHL 
2cbf cd b4 1e			call macro_dsp_valuehl 
2cc2				endm 
# End of macro FORTH_DSP_VALUEHL
2cc2			 
2cc2					FORTH_DSP_POP 
2cc2 cd 6c 1f			call macro_forth_dsp_pop 
2cc5				endm 
# End of macro FORTH_DSP_POP
2cc5			 
2cc5					; hl contains value to add to byte at a 
2cc5				 
2cc5 eb					ex de, hl 
2cc6			 
2cc6 e1					pop hl 
2cc7			 
2cc7					if DEBUG_FORTH_WORDS 
2cc7						DMARK "INC" 
2cc7 f5				push af  
2cc8 3a dc 2c			ld a, (.dmark)  
2ccb 32 bd fb			ld (debug_mark),a  
2cce 3a dd 2c			ld a, (.dmark+1)  
2cd1 32 be fb			ld (debug_mark+1),a  
2cd4 3a de 2c			ld a, (.dmark+2)  
2cd7 32 bf fb			ld (debug_mark+2),a  
2cda 18 03			jr .pastdmark  
2cdc ..			.dmark: db "INC"  
2cdf f1			.pastdmark: pop af  
2ce0			endm  
# End of macro DMARK
2ce0						CALLMONITOR 
2ce0 cd 2d 17			call break_point_state  
2ce3				endm  
# End of macro CALLMONITOR
2ce3					endif 
2ce3			 
2ce3 7e					ld a,(hl) 
2ce4 83					add e 
2ce5 77					ld (hl),a 
2ce6			 
2ce6			 
2ce6			 
2ce6				       NEXTW 
2ce6 c3 26 20			jp macro_next 
2ce9				endm 
# End of macro NEXTW
2ce9			 
2ce9			.DEC: 
2ce9				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2ce9 6f				db WORD_SYS_CORE+91             
2cea 3a 2d			dw .INC2            
2cec 03				db 2 + 1 
2ced .. 00			db "-!",0              
2cf0				endm 
# End of macro CWHEAD
2cf0			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2cf0					if DEBUG_FORTH_WORDS_KEY 
2cf0						DMARK "-s_" 
2cf0 f5				push af  
2cf1 3a 05 2d			ld a, (.dmark)  
2cf4 32 bd fb			ld (debug_mark),a  
2cf7 3a 06 2d			ld a, (.dmark+1)  
2cfa 32 be fb			ld (debug_mark+1),a  
2cfd 3a 07 2d			ld a, (.dmark+2)  
2d00 32 bf fb			ld (debug_mark+2),a  
2d03 18 03			jr .pastdmark  
2d05 ..			.dmark: db "-s_"  
2d08 f1			.pastdmark: pop af  
2d09			endm  
# End of macro DMARK
2d09						CALLMONITOR 
2d09 cd 2d 17			call break_point_state  
2d0c				endm  
# End of macro CALLMONITOR
2d0c					endif 
2d0c			 
2d0c					FORTH_DSP_VALUEHL 
2d0c cd b4 1e			call macro_dsp_valuehl 
2d0f				endm 
# End of macro FORTH_DSP_VALUEHL
2d0f			 
2d0f e5					push hl   ; save address 
2d10			 
2d10					FORTH_DSP_POP 
2d10 cd 6c 1f			call macro_forth_dsp_pop 
2d13				endm 
# End of macro FORTH_DSP_POP
2d13			 
2d13					FORTH_DSP_VALUEHL 
2d13 cd b4 1e			call macro_dsp_valuehl 
2d16				endm 
# End of macro FORTH_DSP_VALUEHL
2d16			 
2d16					; hl contains value to add to byte at a 
2d16				 
2d16 eb					ex de, hl 
2d17			 
2d17 e1					pop hl 
2d18			 
2d18					if DEBUG_FORTH_WORDS 
2d18						DMARK "DEC" 
2d18 f5				push af  
2d19 3a 2d 2d			ld a, (.dmark)  
2d1c 32 bd fb			ld (debug_mark),a  
2d1f 3a 2e 2d			ld a, (.dmark+1)  
2d22 32 be fb			ld (debug_mark+1),a  
2d25 3a 2f 2d			ld a, (.dmark+2)  
2d28 32 bf fb			ld (debug_mark+2),a  
2d2b 18 03			jr .pastdmark  
2d2d ..			.dmark: db "DEC"  
2d30 f1			.pastdmark: pop af  
2d31			endm  
# End of macro DMARK
2d31						CALLMONITOR 
2d31 cd 2d 17			call break_point_state  
2d34				endm  
# End of macro CALLMONITOR
2d34					endif 
2d34			 
2d34 7e					ld a,(hl) 
2d35 93					sub e 
2d36 77					ld (hl),a 
2d37			 
2d37			 
2d37			 
2d37				       NEXTW 
2d37 c3 26 20			jp macro_next 
2d3a				endm 
# End of macro NEXTW
2d3a			 
2d3a			.INC2: 
2d3a				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d3a 6f				db WORD_SYS_CORE+91             
2d3b e4 2d			dw .DEC2            
2d3d 04				db 3 + 1 
2d3e .. 00			db "+2!",0              
2d42				endm 
# End of macro CWHEAD
2d42			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d42			 
2d42					if DEBUG_FORTH_WORDS_KEY 
2d42						DMARK "+2s" 
2d42 f5				push af  
2d43 3a 57 2d			ld a, (.dmark)  
2d46 32 bd fb			ld (debug_mark),a  
2d49 3a 58 2d			ld a, (.dmark+1)  
2d4c 32 be fb			ld (debug_mark+1),a  
2d4f 3a 59 2d			ld a, (.dmark+2)  
2d52 32 bf fb			ld (debug_mark+2),a  
2d55 18 03			jr .pastdmark  
2d57 ..			.dmark: db "+2s"  
2d5a f1			.pastdmark: pop af  
2d5b			endm  
# End of macro DMARK
2d5b						CALLMONITOR 
2d5b cd 2d 17			call break_point_state  
2d5e				endm  
# End of macro CALLMONITOR
2d5e					endif 
2d5e			 
2d5e					; Address 
2d5e			 
2d5e					FORTH_DSP_VALUEHL 
2d5e cd b4 1e			call macro_dsp_valuehl 
2d61				endm 
# End of macro FORTH_DSP_VALUEHL
2d61			 
2d61 e5					push hl    ; save address 
2d62			 
2d62					; load content into de 
2d62			 
2d62 5e					ld e,(hl) 
2d63 23					inc hl 
2d64 56					ld d, (hl) 
2d65			 
2d65					if DEBUG_FORTH_WORDS 
2d65						DMARK "+2a" 
2d65 f5				push af  
2d66 3a 7a 2d			ld a, (.dmark)  
2d69 32 bd fb			ld (debug_mark),a  
2d6c 3a 7b 2d			ld a, (.dmark+1)  
2d6f 32 be fb			ld (debug_mark+1),a  
2d72 3a 7c 2d			ld a, (.dmark+2)  
2d75 32 bf fb			ld (debug_mark+2),a  
2d78 18 03			jr .pastdmark  
2d7a ..			.dmark: db "+2a"  
2d7d f1			.pastdmark: pop af  
2d7e			endm  
# End of macro DMARK
2d7e						CALLMONITOR 
2d7e cd 2d 17			call break_point_state  
2d81				endm  
# End of macro CALLMONITOR
2d81					endif 
2d81			 
2d81					FORTH_DSP_POP 
2d81 cd 6c 1f			call macro_forth_dsp_pop 
2d84				endm 
# End of macro FORTH_DSP_POP
2d84			 
2d84					; Get value to add 
2d84			 
2d84					FORTH_DSP_VALUE 
2d84 cd 9d 1e			call macro_forth_dsp_value 
2d87				endm 
# End of macro FORTH_DSP_VALUE
2d87			 
2d87					if DEBUG_FORTH_WORDS 
2d87						DMARK "+2v" 
2d87 f5				push af  
2d88 3a 9c 2d			ld a, (.dmark)  
2d8b 32 bd fb			ld (debug_mark),a  
2d8e 3a 9d 2d			ld a, (.dmark+1)  
2d91 32 be fb			ld (debug_mark+1),a  
2d94 3a 9e 2d			ld a, (.dmark+2)  
2d97 32 bf fb			ld (debug_mark+2),a  
2d9a 18 03			jr .pastdmark  
2d9c ..			.dmark: db "+2v"  
2d9f f1			.pastdmark: pop af  
2da0			endm  
# End of macro DMARK
2da0						CALLMONITOR 
2da0 cd 2d 17			call break_point_state  
2da3				endm  
# End of macro CALLMONITOR
2da3					endif 
2da3			 
2da3 19					add hl, de 
2da4			 
2da4					if DEBUG_FORTH_WORDS 
2da4						DMARK "+2+" 
2da4 f5				push af  
2da5 3a b9 2d			ld a, (.dmark)  
2da8 32 bd fb			ld (debug_mark),a  
2dab 3a ba 2d			ld a, (.dmark+1)  
2dae 32 be fb			ld (debug_mark+1),a  
2db1 3a bb 2d			ld a, (.dmark+2)  
2db4 32 bf fb			ld (debug_mark+2),a  
2db7 18 03			jr .pastdmark  
2db9 ..			.dmark: db "+2+"  
2dbc f1			.pastdmark: pop af  
2dbd			endm  
# End of macro DMARK
2dbd						CALLMONITOR 
2dbd cd 2d 17			call break_point_state  
2dc0				endm  
# End of macro CALLMONITOR
2dc0					endif 
2dc0			 
2dc0					; move result to de 
2dc0			 
2dc0 eb					ex de, hl 
2dc1			 
2dc1					; Address 
2dc1			 
2dc1 e1					pop hl 
2dc2			 
2dc2					; save it back 
2dc2			 
2dc2 73					ld (hl), e 
2dc3 23					inc hl 
2dc4 72					ld (hl), d 
2dc5			 
2dc5					if DEBUG_FORTH_WORDS 
2dc5						DMARK "+2e" 
2dc5 f5				push af  
2dc6 3a da 2d			ld a, (.dmark)  
2dc9 32 bd fb			ld (debug_mark),a  
2dcc 3a db 2d			ld a, (.dmark+1)  
2dcf 32 be fb			ld (debug_mark+1),a  
2dd2 3a dc 2d			ld a, (.dmark+2)  
2dd5 32 bf fb			ld (debug_mark+2),a  
2dd8 18 03			jr .pastdmark  
2dda ..			.dmark: db "+2e"  
2ddd f1			.pastdmark: pop af  
2dde			endm  
# End of macro DMARK
2dde						CALLMONITOR 
2dde cd 2d 17			call break_point_state  
2de1				endm  
# End of macro CALLMONITOR
2de1					endif 
2de1			 
2de1			 
2de1			 
2de1			 
2de1			 
2de1				       NEXTW 
2de1 c3 26 20			jp macro_next 
2de4				endm 
# End of macro NEXTW
2de4			 
2de4			.DEC2: 
2de4				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2de4 6f				db WORD_SYS_CORE+91             
2de5 90 2e			dw .GET2            
2de7 04				db 3 + 1 
2de8 .. 00			db "-2!",0              
2dec				endm 
# End of macro CWHEAD
2dec			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dec			 
2dec			 
2dec					if DEBUG_FORTH_WORDS_KEY 
2dec						DMARK "-2s" 
2dec f5				push af  
2ded 3a 01 2e			ld a, (.dmark)  
2df0 32 bd fb			ld (debug_mark),a  
2df3 3a 02 2e			ld a, (.dmark+1)  
2df6 32 be fb			ld (debug_mark+1),a  
2df9 3a 03 2e			ld a, (.dmark+2)  
2dfc 32 bf fb			ld (debug_mark+2),a  
2dff 18 03			jr .pastdmark  
2e01 ..			.dmark: db "-2s"  
2e04 f1			.pastdmark: pop af  
2e05			endm  
# End of macro DMARK
2e05						CALLMONITOR 
2e05 cd 2d 17			call break_point_state  
2e08				endm  
# End of macro CALLMONITOR
2e08					endif 
2e08			 
2e08					; Address 
2e08			 
2e08					FORTH_DSP_VALUEHL 
2e08 cd b4 1e			call macro_dsp_valuehl 
2e0b				endm 
# End of macro FORTH_DSP_VALUEHL
2e0b			 
2e0b e5					push hl    ; save address 
2e0c			 
2e0c					; load content into de 
2e0c			 
2e0c 5e					ld e,(hl) 
2e0d 23					inc hl 
2e0e 56					ld d, (hl) 
2e0f			 
2e0f					if DEBUG_FORTH_WORDS 
2e0f						DMARK "-2a" 
2e0f f5				push af  
2e10 3a 24 2e			ld a, (.dmark)  
2e13 32 bd fb			ld (debug_mark),a  
2e16 3a 25 2e			ld a, (.dmark+1)  
2e19 32 be fb			ld (debug_mark+1),a  
2e1c 3a 26 2e			ld a, (.dmark+2)  
2e1f 32 bf fb			ld (debug_mark+2),a  
2e22 18 03			jr .pastdmark  
2e24 ..			.dmark: db "-2a"  
2e27 f1			.pastdmark: pop af  
2e28			endm  
# End of macro DMARK
2e28						CALLMONITOR 
2e28 cd 2d 17			call break_point_state  
2e2b				endm  
# End of macro CALLMONITOR
2e2b					endif 
2e2b			 
2e2b					FORTH_DSP_POP 
2e2b cd 6c 1f			call macro_forth_dsp_pop 
2e2e				endm 
# End of macro FORTH_DSP_POP
2e2e			 
2e2e					; Get value to remove 
2e2e			 
2e2e					FORTH_DSP_VALUE 
2e2e cd 9d 1e			call macro_forth_dsp_value 
2e31				endm 
# End of macro FORTH_DSP_VALUE
2e31			 
2e31					if DEBUG_FORTH_WORDS 
2e31						DMARK "-2v" 
2e31 f5				push af  
2e32 3a 46 2e			ld a, (.dmark)  
2e35 32 bd fb			ld (debug_mark),a  
2e38 3a 47 2e			ld a, (.dmark+1)  
2e3b 32 be fb			ld (debug_mark+1),a  
2e3e 3a 48 2e			ld a, (.dmark+2)  
2e41 32 bf fb			ld (debug_mark+2),a  
2e44 18 03			jr .pastdmark  
2e46 ..			.dmark: db "-2v"  
2e49 f1			.pastdmark: pop af  
2e4a			endm  
# End of macro DMARK
2e4a						CALLMONITOR 
2e4a cd 2d 17			call break_point_state  
2e4d				endm  
# End of macro CALLMONITOR
2e4d					endif 
2e4d			 
2e4d eb					ex de, hl 
2e4e ed 52				sbc hl, de 
2e50			 
2e50					if DEBUG_FORTH_WORDS 
2e50						DMARK "-2d" 
2e50 f5				push af  
2e51 3a 65 2e			ld a, (.dmark)  
2e54 32 bd fb			ld (debug_mark),a  
2e57 3a 66 2e			ld a, (.dmark+1)  
2e5a 32 be fb			ld (debug_mark+1),a  
2e5d 3a 67 2e			ld a, (.dmark+2)  
2e60 32 bf fb			ld (debug_mark+2),a  
2e63 18 03			jr .pastdmark  
2e65 ..			.dmark: db "-2d"  
2e68 f1			.pastdmark: pop af  
2e69			endm  
# End of macro DMARK
2e69						CALLMONITOR 
2e69 cd 2d 17			call break_point_state  
2e6c				endm  
# End of macro CALLMONITOR
2e6c					endif 
2e6c			 
2e6c					; move result to de 
2e6c			 
2e6c eb					ex de, hl 
2e6d			 
2e6d					; Address 
2e6d			 
2e6d e1					pop hl 
2e6e			 
2e6e					; save it back 
2e6e			 
2e6e 73					ld (hl), e 
2e6f 23					inc hl 
2e70 72					ld (hl), d 
2e71			 
2e71					if DEBUG_FORTH_WORDS 
2e71						DMARK "-2e" 
2e71 f5				push af  
2e72 3a 86 2e			ld a, (.dmark)  
2e75 32 bd fb			ld (debug_mark),a  
2e78 3a 87 2e			ld a, (.dmark+1)  
2e7b 32 be fb			ld (debug_mark+1),a  
2e7e 3a 88 2e			ld a, (.dmark+2)  
2e81 32 bf fb			ld (debug_mark+2),a  
2e84 18 03			jr .pastdmark  
2e86 ..			.dmark: db "-2e"  
2e89 f1			.pastdmark: pop af  
2e8a			endm  
# End of macro DMARK
2e8a						CALLMONITOR 
2e8a cd 2d 17			call break_point_state  
2e8d				endm  
# End of macro CALLMONITOR
2e8d					endif 
2e8d			 
2e8d			 
2e8d			 
2e8d			 
2e8d			 
2e8d				       NEXTW 
2e8d c3 26 20			jp macro_next 
2e90				endm 
# End of macro NEXTW
2e90			.GET2: 
2e90				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e90 6f				db WORD_SYS_CORE+91             
2e91 c0 2e			dw .BANG2            
2e93 03				db 2 + 1 
2e94 .. 00			db "2@",0              
2e97				endm 
# End of macro CWHEAD
2e97			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e97					if DEBUG_FORTH_WORDS_KEY 
2e97						DMARK "2A_" 
2e97 f5				push af  
2e98 3a ac 2e			ld a, (.dmark)  
2e9b 32 bd fb			ld (debug_mark),a  
2e9e 3a ad 2e			ld a, (.dmark+1)  
2ea1 32 be fb			ld (debug_mark+1),a  
2ea4 3a ae 2e			ld a, (.dmark+2)  
2ea7 32 bf fb			ld (debug_mark+2),a  
2eaa 18 03			jr .pastdmark  
2eac ..			.dmark: db "2A_"  
2eaf f1			.pastdmark: pop af  
2eb0			endm  
# End of macro DMARK
2eb0						CALLMONITOR 
2eb0 cd 2d 17			call break_point_state  
2eb3				endm  
# End of macro CALLMONITOR
2eb3					endif 
2eb3			 
2eb3					FORTH_DSP_VALUEHL 
2eb3 cd b4 1e			call macro_dsp_valuehl 
2eb6				endm 
# End of macro FORTH_DSP_VALUEHL
2eb6			 
2eb6 5e					ld e, (hl) 
2eb7 23					inc hl 
2eb8 56					ld d, (hl) 
2eb9			 
2eb9 eb					ex de, hl 
2eba			 
2eba cd bd 1c				call forth_push_numhl 
2ebd			 
2ebd				       NEXTW 
2ebd c3 26 20			jp macro_next 
2ec0				endm 
# End of macro NEXTW
2ec0			.BANG2: 
2ec0				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2ec0 6f				db WORD_SYS_CORE+91             
2ec1 f8 2e			dw .CONFIG            
2ec3 03				db 2 + 1 
2ec4 .. 00			db "2!",0              
2ec7				endm 
# End of macro CWHEAD
2ec7			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ec7					if DEBUG_FORTH_WORDS_KEY 
2ec7						DMARK "2S_" 
2ec7 f5				push af  
2ec8 3a dc 2e			ld a, (.dmark)  
2ecb 32 bd fb			ld (debug_mark),a  
2ece 3a dd 2e			ld a, (.dmark+1)  
2ed1 32 be fb			ld (debug_mark+1),a  
2ed4 3a de 2e			ld a, (.dmark+2)  
2ed7 32 bf fb			ld (debug_mark+2),a  
2eda 18 03			jr .pastdmark  
2edc ..			.dmark: db "2S_"  
2edf f1			.pastdmark: pop af  
2ee0			endm  
# End of macro DMARK
2ee0						CALLMONITOR 
2ee0 cd 2d 17			call break_point_state  
2ee3				endm  
# End of macro CALLMONITOR
2ee3					endif 
2ee3			 
2ee3					FORTH_DSP_VALUEHL 
2ee3 cd b4 1e			call macro_dsp_valuehl 
2ee6				endm 
# End of macro FORTH_DSP_VALUEHL
2ee6			 
2ee6 e5					push hl   ; save address 
2ee7			 
2ee7			 
2ee7					FORTH_DSP_POP 
2ee7 cd 6c 1f			call macro_forth_dsp_pop 
2eea				endm 
# End of macro FORTH_DSP_POP
2eea			 
2eea					 
2eea					FORTH_DSP_VALUEHL 
2eea cd b4 1e			call macro_dsp_valuehl 
2eed				endm 
# End of macro FORTH_DSP_VALUEHL
2eed			 
2eed					FORTH_DSP_POP 
2eed cd 6c 1f			call macro_forth_dsp_pop 
2ef0				endm 
# End of macro FORTH_DSP_POP
2ef0			 
2ef0 eb					ex de, hl    ; value now in de 
2ef1			 
2ef1 e1					pop hl 
2ef2			 
2ef2 73					ld (hl), e 
2ef3			 
2ef3 23					inc hl 
2ef4			 
2ef4 72					ld (hl), d 
2ef5			 
2ef5			 
2ef5				       NEXTW 
2ef5 c3 26 20			jp macro_next 
2ef8				endm 
# End of macro NEXTW
2ef8			.CONFIG: 
2ef8				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2ef8 6f				db WORD_SYS_CORE+91             
2ef9 09 2f			dw .ENDCORE            
2efb 07				db 6 + 1 
2efc .. 00			db "CONFIG",0              
2f03				endm 
# End of macro CWHEAD
2f03			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2f03			 
2f03 cd 7a 13				call config 
2f06					NEXTW 
2f06 c3 26 20			jp macro_next 
2f09				endm 
# End of macro NEXTW
2f09			.ENDCORE: 
2f09			 
2f09			; eof 
2f09			 
2f09			 
# End of file forth_words_core.asm
2f09			include "forth_words_flow.asm" 
2f09			 
2f09			; | ## Program Flow Words 
2f09			 
2f09			.IF: 
2f09				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f09 1e				db WORD_SYS_CORE+10             
2f0a fe 2f			dw .THEN            
2f0c 03				db 2 + 1 
2f0d .. 00			db "IF",0              
2f10				endm 
# End of macro CWHEAD
2f10			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f10			; 
2f10					if DEBUG_FORTH_WORDS_KEY 
2f10						DMARK "IF." 
2f10 f5				push af  
2f11 3a 25 2f			ld a, (.dmark)  
2f14 32 bd fb			ld (debug_mark),a  
2f17 3a 26 2f			ld a, (.dmark+1)  
2f1a 32 be fb			ld (debug_mark+1),a  
2f1d 3a 27 2f			ld a, (.dmark+2)  
2f20 32 bf fb			ld (debug_mark+2),a  
2f23 18 03			jr .pastdmark  
2f25 ..			.dmark: db "IF."  
2f28 f1			.pastdmark: pop af  
2f29			endm  
# End of macro DMARK
2f29						CALLMONITOR 
2f29 cd 2d 17			call break_point_state  
2f2c				endm  
# End of macro CALLMONITOR
2f2c					endif 
2f2c			; eval TOS 
2f2c			 
2f2c				FORTH_DSP_VALUEHL 
2f2c cd b4 1e			call macro_dsp_valuehl 
2f2f				endm 
# End of macro FORTH_DSP_VALUEHL
2f2f			 
2f2f			;	push hl 
2f2f				FORTH_DSP_POP 
2f2f cd 6c 1f			call macro_forth_dsp_pop 
2f32				endm 
# End of macro FORTH_DSP_POP
2f32			;	pop hl 
2f32			 
2f32					if DEBUG_FORTH_WORDS 
2f32						DMARK "IF1" 
2f32 f5				push af  
2f33 3a 47 2f			ld a, (.dmark)  
2f36 32 bd fb			ld (debug_mark),a  
2f39 3a 48 2f			ld a, (.dmark+1)  
2f3c 32 be fb			ld (debug_mark+1),a  
2f3f 3a 49 2f			ld a, (.dmark+2)  
2f42 32 bf fb			ld (debug_mark+2),a  
2f45 18 03			jr .pastdmark  
2f47 ..			.dmark: db "IF1"  
2f4a f1			.pastdmark: pop af  
2f4b			endm  
# End of macro DMARK
2f4b						CALLMONITOR 
2f4b cd 2d 17			call break_point_state  
2f4e				endm  
# End of macro CALLMONITOR
2f4e					endif 
2f4e b7				or a        ; clear carry flag 
2f4f 11 00 00			ld de, 0 
2f52 eb				ex de,hl 
2f53 ed 52			sbc hl, de 
2f55 c2 df 2f			jp nz, .iftrue 
2f58			 
2f58					if DEBUG_FORTH_WORDS 
2f58						DMARK "IF2" 
2f58 f5				push af  
2f59 3a 6d 2f			ld a, (.dmark)  
2f5c 32 bd fb			ld (debug_mark),a  
2f5f 3a 6e 2f			ld a, (.dmark+1)  
2f62 32 be fb			ld (debug_mark+1),a  
2f65 3a 6f 2f			ld a, (.dmark+2)  
2f68 32 bf fb			ld (debug_mark+2),a  
2f6b 18 03			jr .pastdmark  
2f6d ..			.dmark: db "IF2"  
2f70 f1			.pastdmark: pop af  
2f71			endm  
# End of macro DMARK
2f71						CALLMONITOR 
2f71 cd 2d 17			call break_point_state  
2f74				endm  
# End of macro CALLMONITOR
2f74					endif 
2f74			 
2f74			; if not true then skip to THEN 
2f74			 
2f74				; TODO get tok_ptr 
2f74				; TODO consume toks until we get to THEN 
2f74			 
2f74 2a a4 f2			ld hl, (os_tok_ptr) 
2f77					if DEBUG_FORTH_WORDS 
2f77						DMARK "IF3" 
2f77 f5				push af  
2f78 3a 8c 2f			ld a, (.dmark)  
2f7b 32 bd fb			ld (debug_mark),a  
2f7e 3a 8d 2f			ld a, (.dmark+1)  
2f81 32 be fb			ld (debug_mark+1),a  
2f84 3a 8e 2f			ld a, (.dmark+2)  
2f87 32 bf fb			ld (debug_mark+2),a  
2f8a 18 03			jr .pastdmark  
2f8c ..			.dmark: db "IF3"  
2f8f f1			.pastdmark: pop af  
2f90			endm  
# End of macro DMARK
2f90						CALLMONITOR 
2f90 cd 2d 17			call break_point_state  
2f93				endm  
# End of macro CALLMONITOR
2f93						 
2f93					endif 
2f93 11 da 2f			ld de, .ifthen 
2f96					if DEBUG_FORTH_WORDS 
2f96						DMARK "IF4" 
2f96 f5				push af  
2f97 3a ab 2f			ld a, (.dmark)  
2f9a 32 bd fb			ld (debug_mark),a  
2f9d 3a ac 2f			ld a, (.dmark+1)  
2fa0 32 be fb			ld (debug_mark+1),a  
2fa3 3a ad 2f			ld a, (.dmark+2)  
2fa6 32 bf fb			ld (debug_mark+2),a  
2fa9 18 03			jr .pastdmark  
2fab ..			.dmark: db "IF4"  
2fae f1			.pastdmark: pop af  
2faf			endm  
# End of macro DMARK
2faf						CALLMONITOR 
2faf cd 2d 17			call break_point_state  
2fb2				endm  
# End of macro CALLMONITOR
2fb2					endif 
2fb2 cd 41 21			call findnexttok  
2fb5			 
2fb5					if DEBUG_FORTH_WORDS 
2fb5						DMARK "IF5" 
2fb5 f5				push af  
2fb6 3a ca 2f			ld a, (.dmark)  
2fb9 32 bd fb			ld (debug_mark),a  
2fbc 3a cb 2f			ld a, (.dmark+1)  
2fbf 32 be fb			ld (debug_mark+1),a  
2fc2 3a cc 2f			ld a, (.dmark+2)  
2fc5 32 bf fb			ld (debug_mark+2),a  
2fc8 18 03			jr .pastdmark  
2fca ..			.dmark: db "IF5"  
2fcd f1			.pastdmark: pop af  
2fce			endm  
# End of macro DMARK
2fce						CALLMONITOR 
2fce cd 2d 17			call break_point_state  
2fd1				endm  
# End of macro CALLMONITOR
2fd1					endif 
2fd1				; TODO replace below with ; exec using tok_ptr 
2fd1 22 a4 f2			ld (os_tok_ptr), hl 
2fd4 c3 b7 20			jp exec1 
2fd7				NEXTW 
2fd7 c3 26 20			jp macro_next 
2fda				endm 
# End of macro NEXTW
2fda			 
2fda .. 00		.ifthen:  db "THEN",0 
2fdf			 
2fdf			.iftrue:		 
2fdf				; Exec next words normally 
2fdf			 
2fdf				; if true then exec following IF as normal 
2fdf					if DEBUG_FORTH_WORDS 
2fdf						DMARK "IFT" 
2fdf f5				push af  
2fe0 3a f4 2f			ld a, (.dmark)  
2fe3 32 bd fb			ld (debug_mark),a  
2fe6 3a f5 2f			ld a, (.dmark+1)  
2fe9 32 be fb			ld (debug_mark+1),a  
2fec 3a f6 2f			ld a, (.dmark+2)  
2fef 32 bf fb			ld (debug_mark+2),a  
2ff2 18 03			jr .pastdmark  
2ff4 ..			.dmark: db "IFT"  
2ff7 f1			.pastdmark: pop af  
2ff8			endm  
# End of macro DMARK
2ff8						CALLMONITOR 
2ff8 cd 2d 17			call break_point_state  
2ffb				endm  
# End of macro CALLMONITOR
2ffb					endif 
2ffb			 
2ffb					NEXTW 
2ffb c3 26 20			jp macro_next 
2ffe				endm 
# End of macro NEXTW
2ffe			.THEN: 
2ffe				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2ffe 1f				db WORD_SYS_CORE+11             
2fff 26 30			dw .ELSE            
3001 05				db 4 + 1 
3002 .. 00			db "THEN",0              
3007				endm 
# End of macro CWHEAD
3007			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3007					if DEBUG_FORTH_WORDS_KEY 
3007						DMARK "THN" 
3007 f5				push af  
3008 3a 1c 30			ld a, (.dmark)  
300b 32 bd fb			ld (debug_mark),a  
300e 3a 1d 30			ld a, (.dmark+1)  
3011 32 be fb			ld (debug_mark+1),a  
3014 3a 1e 30			ld a, (.dmark+2)  
3017 32 bf fb			ld (debug_mark+2),a  
301a 18 03			jr .pastdmark  
301c ..			.dmark: db "THN"  
301f f1			.pastdmark: pop af  
3020			endm  
# End of macro DMARK
3020						CALLMONITOR 
3020 cd 2d 17			call break_point_state  
3023				endm  
# End of macro CALLMONITOR
3023					endif 
3023					NEXTW 
3023 c3 26 20			jp macro_next 
3026				endm 
# End of macro NEXTW
3026			.ELSE: 
3026				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3026 20				db WORD_SYS_CORE+12             
3027 4e 30			dw .DO            
3029 03				db 2 + 1 
302a .. 00			db "ELSE",0              
302f				endm 
# End of macro CWHEAD
302f			; | ELSE ( -- ) Not supported - does nothing | TODO 
302f			 
302f					if DEBUG_FORTH_WORDS_KEY 
302f						DMARK "ELS" 
302f f5				push af  
3030 3a 44 30			ld a, (.dmark)  
3033 32 bd fb			ld (debug_mark),a  
3036 3a 45 30			ld a, (.dmark+1)  
3039 32 be fb			ld (debug_mark+1),a  
303c 3a 46 30			ld a, (.dmark+2)  
303f 32 bf fb			ld (debug_mark+2),a  
3042 18 03			jr .pastdmark  
3044 ..			.dmark: db "ELS"  
3047 f1			.pastdmark: pop af  
3048			endm  
# End of macro DMARK
3048						CALLMONITOR 
3048 cd 2d 17			call break_point_state  
304b				endm  
# End of macro CALLMONITOR
304b					endif 
304b			 
304b			 
304b					NEXTW 
304b c3 26 20			jp macro_next 
304e				endm 
# End of macro NEXTW
304e			.DO: 
304e				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
304e 21				db WORD_SYS_CORE+13             
304f 75 31			dw .LOOP            
3051 03				db 2 + 1 
3052 .. 00			db "DO",0              
3055				endm 
# End of macro CWHEAD
3055			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3055			 
3055					if DEBUG_FORTH_WORDS_KEY 
3055						DMARK "DO." 
3055 f5				push af  
3056 3a 6a 30			ld a, (.dmark)  
3059 32 bd fb			ld (debug_mark),a  
305c 3a 6b 30			ld a, (.dmark+1)  
305f 32 be fb			ld (debug_mark+1),a  
3062 3a 6c 30			ld a, (.dmark+2)  
3065 32 bf fb			ld (debug_mark+2),a  
3068 18 03			jr .pastdmark  
306a ..			.dmark: db "DO."  
306d f1			.pastdmark: pop af  
306e			endm  
# End of macro DMARK
306e						CALLMONITOR 
306e cd 2d 17			call break_point_state  
3071				endm  
# End of macro CALLMONITOR
3071					endif 
3071			;  push pc to rsp stack past the DO 
3071			 
3071 2a a4 f2				ld hl, (os_tok_ptr) 
3074 23					inc hl   ; D 
3075 23					inc hl  ; O 
3076 23					inc hl   ; null 
3077					if DEBUG_FORTH_WORDS 
3077						DMARK "DO2" 
3077 f5				push af  
3078 3a 8c 30			ld a, (.dmark)  
307b 32 bd fb			ld (debug_mark),a  
307e 3a 8d 30			ld a, (.dmark+1)  
3081 32 be fb			ld (debug_mark+1),a  
3084 3a 8e 30			ld a, (.dmark+2)  
3087 32 bf fb			ld (debug_mark+2),a  
308a 18 03			jr .pastdmark  
308c ..			.dmark: db "DO2"  
308f f1			.pastdmark: pop af  
3090			endm  
# End of macro DMARK
3090						CALLMONITOR 
3090 cd 2d 17			call break_point_state  
3093				endm  
# End of macro CALLMONITOR
3093					endif 
3093					FORTH_RSP_NEXT 
3093 cd 64 1c			call macro_forth_rsp_next 
3096				endm 
# End of macro FORTH_RSP_NEXT
3096					if DEBUG_FORTH_WORDS 
3096						DMARK "DO3" 
3096 f5				push af  
3097 3a ab 30			ld a, (.dmark)  
309a 32 bd fb			ld (debug_mark),a  
309d 3a ac 30			ld a, (.dmark+1)  
30a0 32 be fb			ld (debug_mark+1),a  
30a3 3a ad 30			ld a, (.dmark+2)  
30a6 32 bf fb			ld (debug_mark+2),a  
30a9 18 03			jr .pastdmark  
30ab ..			.dmark: db "DO3"  
30ae f1			.pastdmark: pop af  
30af			endm  
# End of macro DMARK
30af						CALLMONITOR 
30af cd 2d 17			call break_point_state  
30b2				endm  
# End of macro CALLMONITOR
30b2					endif 
30b2			 
30b2					;if DEBUG_FORTH_WORDS 
30b2				;		push hl 
30b2			;		endif  
30b2			 
30b2			; get counters from data stack 
30b2			 
30b2			 
30b2					FORTH_DSP_VALUEHL 
30b2 cd b4 1e			call macro_dsp_valuehl 
30b5				endm 
# End of macro FORTH_DSP_VALUEHL
30b5 e5					push hl		 ; hl now has starting counter which needs to be tos 
30b6			 
30b6					if DEBUG_FORTH_WORDS 
30b6						DMARK "DO4" 
30b6 f5				push af  
30b7 3a cb 30			ld a, (.dmark)  
30ba 32 bd fb			ld (debug_mark),a  
30bd 3a cc 30			ld a, (.dmark+1)  
30c0 32 be fb			ld (debug_mark+1),a  
30c3 3a cd 30			ld a, (.dmark+2)  
30c6 32 bf fb			ld (debug_mark+2),a  
30c9 18 03			jr .pastdmark  
30cb ..			.dmark: db "DO4"  
30ce f1			.pastdmark: pop af  
30cf			endm  
# End of macro DMARK
30cf						CALLMONITOR 
30cf cd 2d 17			call break_point_state  
30d2				endm  
# End of macro CALLMONITOR
30d2					endif 
30d2					FORTH_DSP_POP 
30d2 cd 6c 1f			call macro_forth_dsp_pop 
30d5				endm 
# End of macro FORTH_DSP_POP
30d5			 
30d5					if DEBUG_FORTH_WORDS 
30d5						DMARK "DO5" 
30d5 f5				push af  
30d6 3a ea 30			ld a, (.dmark)  
30d9 32 bd fb			ld (debug_mark),a  
30dc 3a eb 30			ld a, (.dmark+1)  
30df 32 be fb			ld (debug_mark+1),a  
30e2 3a ec 30			ld a, (.dmark+2)  
30e5 32 bf fb			ld (debug_mark+2),a  
30e8 18 03			jr .pastdmark  
30ea ..			.dmark: db "DO5"  
30ed f1			.pastdmark: pop af  
30ee			endm  
# End of macro DMARK
30ee						CALLMONITOR 
30ee cd 2d 17			call break_point_state  
30f1				endm  
# End of macro CALLMONITOR
30f1					endif 
30f1			 
30f1					FORTH_DSP_VALUEHL 
30f1 cd b4 1e			call macro_dsp_valuehl 
30f4				endm 
# End of macro FORTH_DSP_VALUEHL
30f4			;		push hl		 ; hl now has starting limit counter 
30f4			 
30f4					if DEBUG_FORTH_WORDS 
30f4						DMARK "DO6" 
30f4 f5				push af  
30f5 3a 09 31			ld a, (.dmark)  
30f8 32 bd fb			ld (debug_mark),a  
30fb 3a 0a 31			ld a, (.dmark+1)  
30fe 32 be fb			ld (debug_mark+1),a  
3101 3a 0b 31			ld a, (.dmark+2)  
3104 32 bf fb			ld (debug_mark+2),a  
3107 18 03			jr .pastdmark  
3109 ..			.dmark: db "DO6"  
310c f1			.pastdmark: pop af  
310d			endm  
# End of macro DMARK
310d						CALLMONITOR 
310d cd 2d 17			call break_point_state  
3110				endm  
# End of macro CALLMONITOR
3110					endif 
3110					FORTH_DSP_POP 
3110 cd 6c 1f			call macro_forth_dsp_pop 
3113				endm 
# End of macro FORTH_DSP_POP
3113			 
3113			; put counters on the loop stack 
3113			 
3113			;		pop hl			 ; limit counter 
3113 d1					pop de			; start counter 
3114			 
3114					; push limit counter 
3114			 
3114					if DEBUG_FORTH_WORDS 
3114						DMARK "DO7" 
3114 f5				push af  
3115 3a 29 31			ld a, (.dmark)  
3118 32 bd fb			ld (debug_mark),a  
311b 3a 2a 31			ld a, (.dmark+1)  
311e 32 be fb			ld (debug_mark+1),a  
3121 3a 2b 31			ld a, (.dmark+2)  
3124 32 bf fb			ld (debug_mark+2),a  
3127 18 03			jr .pastdmark  
3129 ..			.dmark: db "DO7"  
312c f1			.pastdmark: pop af  
312d			endm  
# End of macro DMARK
312d						CALLMONITOR 
312d cd 2d 17			call break_point_state  
3130				endm  
# End of macro CALLMONITOR
3130					endif 
3130					FORTH_LOOP_NEXT 
3130 cd e5 1e			call macro_forth_loop_next 
3133				endm 
# End of macro FORTH_LOOP_NEXT
3133			 
3133					; push start counter 
3133			 
3133 eb					ex de, hl 
3134					if DEBUG_FORTH_WORDS 
3134						DMARK "DO7" 
3134 f5				push af  
3135 3a 49 31			ld a, (.dmark)  
3138 32 bd fb			ld (debug_mark),a  
313b 3a 4a 31			ld a, (.dmark+1)  
313e 32 be fb			ld (debug_mark+1),a  
3141 3a 4b 31			ld a, (.dmark+2)  
3144 32 bf fb			ld (debug_mark+2),a  
3147 18 03			jr .pastdmark  
3149 ..			.dmark: db "DO7"  
314c f1			.pastdmark: pop af  
314d			endm  
# End of macro DMARK
314d						CALLMONITOR 
314d cd 2d 17			call break_point_state  
3150				endm  
# End of macro CALLMONITOR
3150					endif 
3150					FORTH_LOOP_NEXT 
3150 cd e5 1e			call macro_forth_loop_next 
3153				endm 
# End of macro FORTH_LOOP_NEXT
3153			 
3153			 
3153					; init first round of I counter 
3153			 
3153 22 c8 f2				ld (os_current_i), hl 
3156			 
3156					if DEBUG_FORTH_WORDS 
3156						DMARK "DO8" 
3156 f5				push af  
3157 3a 6b 31			ld a, (.dmark)  
315a 32 bd fb			ld (debug_mark),a  
315d 3a 6c 31			ld a, (.dmark+1)  
3160 32 be fb			ld (debug_mark+1),a  
3163 3a 6d 31			ld a, (.dmark+2)  
3166 32 bf fb			ld (debug_mark+2),a  
3169 18 03			jr .pastdmark  
316b ..			.dmark: db "DO8"  
316e f1			.pastdmark: pop af  
316f			endm  
# End of macro DMARK
316f						CALLMONITOR 
316f cd 2d 17			call break_point_state  
3172				endm  
# End of macro CALLMONITOR
3172					endif 
3172			 
3172					NEXTW 
3172 c3 26 20			jp macro_next 
3175				endm 
# End of macro NEXTW
3175			.LOOP: 
3175				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3175 22				db WORD_SYS_CORE+14             
3176 8d 32			dw .I            
3178 05				db 4 + 1 
3179 .. 00			db "LOOP",0              
317e				endm 
# End of macro CWHEAD
317e			; | LOOP ( -- ) Increment and test loop counter  | DONE 
317e			 
317e				; pop tos as current loop count to hl 
317e			 
317e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
317e			 
317e				FORTH_LOOP_TOS 
317e cd 18 1f			call macro_forth_loop_tos 
3181				endm 
# End of macro FORTH_LOOP_TOS
3181 e5				push hl 
3182			 
3182					if DEBUG_FORTH_WORDS_KEY 
3182						DMARK "LOP" 
3182 f5				push af  
3183 3a 97 31			ld a, (.dmark)  
3186 32 bd fb			ld (debug_mark),a  
3189 3a 98 31			ld a, (.dmark+1)  
318c 32 be fb			ld (debug_mark+1),a  
318f 3a 99 31			ld a, (.dmark+2)  
3192 32 bf fb			ld (debug_mark+2),a  
3195 18 03			jr .pastdmark  
3197 ..			.dmark: db "LOP"  
319a f1			.pastdmark: pop af  
319b			endm  
# End of macro DMARK
319b						CALLMONITOR 
319b cd 2d 17			call break_point_state  
319e				endm  
# End of macro CALLMONITOR
319e					endif 
319e				; next item on the stack is the limit. get it 
319e			 
319e			 
319e				FORTH_LOOP_POP 
319e cd 22 1f			call macro_forth_loop_pop 
31a1				endm 
# End of macro FORTH_LOOP_POP
31a1			 
31a1				FORTH_LOOP_TOS 
31a1 cd 18 1f			call macro_forth_loop_tos 
31a4				endm 
# End of macro FORTH_LOOP_TOS
31a4			 
31a4 d1				pop de		 ; de = i, hl = limit 
31a5			 
31a5					if DEBUG_FORTH_WORDS 
31a5						DMARK "LP1" 
31a5 f5				push af  
31a6 3a ba 31			ld a, (.dmark)  
31a9 32 bd fb			ld (debug_mark),a  
31ac 3a bb 31			ld a, (.dmark+1)  
31af 32 be fb			ld (debug_mark+1),a  
31b2 3a bc 31			ld a, (.dmark+2)  
31b5 32 bf fb			ld (debug_mark+2),a  
31b8 18 03			jr .pastdmark  
31ba ..			.dmark: db "LP1"  
31bd f1			.pastdmark: pop af  
31be			endm  
# End of macro DMARK
31be						CALLMONITOR 
31be cd 2d 17			call break_point_state  
31c1				endm  
# End of macro CALLMONITOR
31c1					endif 
31c1			 
31c1				; go back to previous word 
31c1			 
31c1 d5				push de    ; save I for inc later 
31c2			 
31c2			 
31c2				; get limit 
31c2				;  is I at limit? 
31c2			 
31c2			 
31c2					if DEBUG_FORTH_WORDS 
31c2						DMARK "LP1" 
31c2 f5				push af  
31c3 3a d7 31			ld a, (.dmark)  
31c6 32 bd fb			ld (debug_mark),a  
31c9 3a d8 31			ld a, (.dmark+1)  
31cc 32 be fb			ld (debug_mark+1),a  
31cf 3a d9 31			ld a, (.dmark+2)  
31d2 32 bf fb			ld (debug_mark+2),a  
31d5 18 03			jr .pastdmark  
31d7 ..			.dmark: db "LP1"  
31da f1			.pastdmark: pop af  
31db			endm  
# End of macro DMARK
31db						CALLMONITOR 
31db cd 2d 17			call break_point_state  
31de				endm  
# End of macro CALLMONITOR
31de					endif 
31de			 
31de ed 52			sbc hl, de 
31e0			 
31e0			 
31e0				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31e0			 
31e0 20 26				jr nz, .loopnotdone 
31e2			 
31e2 e1				pop hl   ; get rid of saved I 
31e3				FORTH_LOOP_POP     ; get rid of limit 
31e3 cd 22 1f			call macro_forth_loop_pop 
31e6				endm 
# End of macro FORTH_LOOP_POP
31e6			 
31e6				FORTH_RSP_POP     ; get rid of DO ptr 
31e6 cd 85 1c			call macro_forth_rsp_pop 
31e9				endm 
# End of macro FORTH_RSP_POP
31e9			 
31e9			if DEBUG_FORTH_WORDS 
31e9						DMARK "LP>" 
31e9 f5				push af  
31ea 3a fe 31			ld a, (.dmark)  
31ed 32 bd fb			ld (debug_mark),a  
31f0 3a ff 31			ld a, (.dmark+1)  
31f3 32 be fb			ld (debug_mark+1),a  
31f6 3a 00 32			ld a, (.dmark+2)  
31f9 32 bf fb			ld (debug_mark+2),a  
31fc 18 03			jr .pastdmark  
31fe ..			.dmark: db "LP>"  
3201 f1			.pastdmark: pop af  
3202			endm  
# End of macro DMARK
3202				CALLMONITOR 
3202 cd 2d 17			call break_point_state  
3205				endm  
# End of macro CALLMONITOR
3205			endif 
3205			 
3205					NEXTW 
3205 c3 26 20			jp macro_next 
3208				endm 
# End of macro NEXTW
3208				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3208			 
3208			.loopnotdone: 
3208			 
3208 e1				pop hl    ; get I 
3209 23				inc hl 
320a			 
320a			   	; save new I 
320a			 
320a			 
320a					; set I counter 
320a			 
320a 22 c8 f2				ld (os_current_i), hl 
320d			 
320d					if DEBUG_FORTH_WORDS 
320d						DMARK "LPN" 
320d f5				push af  
320e 3a 22 32			ld a, (.dmark)  
3211 32 bd fb			ld (debug_mark),a  
3214 3a 23 32			ld a, (.dmark+1)  
3217 32 be fb			ld (debug_mark+1),a  
321a 3a 24 32			ld a, (.dmark+2)  
321d 32 bf fb			ld (debug_mark+2),a  
3220 18 03			jr .pastdmark  
3222 ..			.dmark: db "LPN"  
3225 f1			.pastdmark: pop af  
3226			endm  
# End of macro DMARK
3226					CALLMONITOR 
3226 cd 2d 17			call break_point_state  
3229				endm  
# End of macro CALLMONITOR
3229					endif 
3229					 
3229				FORTH_LOOP_NEXT 
3229 cd e5 1e			call macro_forth_loop_next 
322c				endm 
# End of macro FORTH_LOOP_NEXT
322c			 
322c			 
322c					if DEBUG_FORTH_WORDS 
322c eb						ex de,hl 
322d					endif 
322d			 
322d			;	; get DO ptr 
322d			; 
322d					if DEBUG_FORTH_WORDS 
322d						DMARK "LP7" 
322d f5				push af  
322e 3a 42 32			ld a, (.dmark)  
3231 32 bd fb			ld (debug_mark),a  
3234 3a 43 32			ld a, (.dmark+1)  
3237 32 be fb			ld (debug_mark+1),a  
323a 3a 44 32			ld a, (.dmark+2)  
323d 32 bf fb			ld (debug_mark+2),a  
3240 18 03			jr .pastdmark  
3242 ..			.dmark: db "LP7"  
3245 f1			.pastdmark: pop af  
3246			endm  
# End of macro DMARK
3246					CALLMONITOR 
3246 cd 2d 17			call break_point_state  
3249				endm  
# End of macro CALLMONITOR
3249					endif 
3249				FORTH_RSP_TOS 
3249 cd 7b 1c			call macro_forth_rsp_tos 
324c				endm 
# End of macro FORTH_RSP_TOS
324c			 
324c					if DEBUG_FORTH_WORDS 
324c						DMARK "LP8" 
324c f5				push af  
324d 3a 61 32			ld a, (.dmark)  
3250 32 bd fb			ld (debug_mark),a  
3253 3a 62 32			ld a, (.dmark+1)  
3256 32 be fb			ld (debug_mark+1),a  
3259 3a 63 32			ld a, (.dmark+2)  
325c 32 bf fb			ld (debug_mark+2),a  
325f 18 03			jr .pastdmark  
3261 ..			.dmark: db "LP8"  
3264 f1			.pastdmark: pop af  
3265			endm  
# End of macro DMARK
3265					CALLMONITOR 
3265 cd 2d 17			call break_point_state  
3268				endm  
# End of macro CALLMONITOR
3268					endif 
3268				;push hl 
3268			 
3268				; not going to DO any more 
3268				; get rid of the RSP pointer as DO will add it back in 
3268				;FORTH_RSP_POP 
3268				;pop hl 
3268			 
3268				;ld hl,(cli_ret_sp) 
3268				;ld e, (hl) 
3268				;inc hl 
3268				;ld d, (hl) 
3268				;ex de,hl 
3268 22 a4 f2			ld (os_tok_ptr), hl 
326b					if DEBUG_FORTH_WORDS 
326b						DMARK "LP<" 
326b f5				push af  
326c 3a 80 32			ld a, (.dmark)  
326f 32 bd fb			ld (debug_mark),a  
3272 3a 81 32			ld a, (.dmark+1)  
3275 32 be fb			ld (debug_mark+1),a  
3278 3a 82 32			ld a, (.dmark+2)  
327b 32 bf fb			ld (debug_mark+2),a  
327e 18 03			jr .pastdmark  
3280 ..			.dmark: db "LP<"  
3283 f1			.pastdmark: pop af  
3284			endm  
# End of macro DMARK
3284					CALLMONITOR 
3284 cd 2d 17			call break_point_state  
3287				endm  
# End of macro CALLMONITOR
3287				endif 
3287 c3 b7 20			jp exec1 
328a			 
328a					 
328a			 
328a			 
328a					NEXTW 
328a c3 26 20			jp macro_next 
328d				endm 
# End of macro NEXTW
328d			.I:  
328d			 
328d				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
328d 5e				db WORD_SYS_CORE+74             
328e b8 32			dw .DLOOP            
3290 02				db 1 + 1 
3291 .. 00			db "I",0              
3293				endm 
# End of macro CWHEAD
3293			; | I ( -- ) Current loop counter | DONE 
3293					if DEBUG_FORTH_WORDS_KEY 
3293						DMARK "I.." 
3293 f5				push af  
3294 3a a8 32			ld a, (.dmark)  
3297 32 bd fb			ld (debug_mark),a  
329a 3a a9 32			ld a, (.dmark+1)  
329d 32 be fb			ld (debug_mark+1),a  
32a0 3a aa 32			ld a, (.dmark+2)  
32a3 32 bf fb			ld (debug_mark+2),a  
32a6 18 03			jr .pastdmark  
32a8 ..			.dmark: db "I.."  
32ab f1			.pastdmark: pop af  
32ac			endm  
# End of macro DMARK
32ac						CALLMONITOR 
32ac cd 2d 17			call break_point_state  
32af				endm  
# End of macro CALLMONITOR
32af					endif 
32af			 
32af 2a c8 f2				ld hl,(os_current_i) 
32b2 cd bd 1c				call forth_push_numhl 
32b5			 
32b5					NEXTW 
32b5 c3 26 20			jp macro_next 
32b8				endm 
# End of macro NEXTW
32b8			.DLOOP: 
32b8				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32b8 5f				db WORD_SYS_CORE+75             
32b9 99 33			dw .REPEAT            
32bb 06				db 5 + 1 
32bc .. 00			db "-LOOP",0              
32c2				endm 
# End of macro CWHEAD
32c2			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32c2				; pop tos as current loop count to hl 
32c2					if DEBUG_FORTH_WORDS_KEY 
32c2						DMARK "-LP" 
32c2 f5				push af  
32c3 3a d7 32			ld a, (.dmark)  
32c6 32 bd fb			ld (debug_mark),a  
32c9 3a d8 32			ld a, (.dmark+1)  
32cc 32 be fb			ld (debug_mark+1),a  
32cf 3a d9 32			ld a, (.dmark+2)  
32d2 32 bf fb			ld (debug_mark+2),a  
32d5 18 03			jr .pastdmark  
32d7 ..			.dmark: db "-LP"  
32da f1			.pastdmark: pop af  
32db			endm  
# End of macro DMARK
32db						CALLMONITOR 
32db cd 2d 17			call break_point_state  
32de				endm  
# End of macro CALLMONITOR
32de					endif 
32de			 
32de				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32de			 
32de				FORTH_LOOP_TOS 
32de cd 18 1f			call macro_forth_loop_tos 
32e1				endm 
# End of macro FORTH_LOOP_TOS
32e1 e5				push hl 
32e2			 
32e2					if DEBUG_FORTH_WORDS 
32e2						DMARK "-LP" 
32e2 f5				push af  
32e3 3a f7 32			ld a, (.dmark)  
32e6 32 bd fb			ld (debug_mark),a  
32e9 3a f8 32			ld a, (.dmark+1)  
32ec 32 be fb			ld (debug_mark+1),a  
32ef 3a f9 32			ld a, (.dmark+2)  
32f2 32 bf fb			ld (debug_mark+2),a  
32f5 18 03			jr .pastdmark  
32f7 ..			.dmark: db "-LP"  
32fa f1			.pastdmark: pop af  
32fb			endm  
# End of macro DMARK
32fb						CALLMONITOR 
32fb cd 2d 17			call break_point_state  
32fe				endm  
# End of macro CALLMONITOR
32fe					endif 
32fe				; next item on the stack is the limit. get it 
32fe			 
32fe			 
32fe				FORTH_LOOP_POP 
32fe cd 22 1f			call macro_forth_loop_pop 
3301				endm 
# End of macro FORTH_LOOP_POP
3301			 
3301				FORTH_LOOP_TOS 
3301 cd 18 1f			call macro_forth_loop_tos 
3304				endm 
# End of macro FORTH_LOOP_TOS
3304			 
3304 d1				pop de		 ; de = i, hl = limit 
3305			 
3305					if DEBUG_FORTH_WORDS 
3305						DMARK "-L1" 
3305 f5				push af  
3306 3a 1a 33			ld a, (.dmark)  
3309 32 bd fb			ld (debug_mark),a  
330c 3a 1b 33			ld a, (.dmark+1)  
330f 32 be fb			ld (debug_mark+1),a  
3312 3a 1c 33			ld a, (.dmark+2)  
3315 32 bf fb			ld (debug_mark+2),a  
3318 18 03			jr .pastdmark  
331a ..			.dmark: db "-L1"  
331d f1			.pastdmark: pop af  
331e			endm  
# End of macro DMARK
331e						CALLMONITOR 
331e cd 2d 17			call break_point_state  
3321				endm  
# End of macro CALLMONITOR
3321					endif 
3321			 
3321				; go back to previous word 
3321			 
3321 d5				push de    ; save I for inc later 
3322			 
3322			 
3322				; get limit 
3322				;  is I at limit? 
3322			 
3322			 
3322					if DEBUG_FORTH_WORDS 
3322						DMARK "-L1" 
3322 f5				push af  
3323 3a 37 33			ld a, (.dmark)  
3326 32 bd fb			ld (debug_mark),a  
3329 3a 38 33			ld a, (.dmark+1)  
332c 32 be fb			ld (debug_mark+1),a  
332f 3a 39 33			ld a, (.dmark+2)  
3332 32 bf fb			ld (debug_mark+2),a  
3335 18 03			jr .pastdmark  
3337 ..			.dmark: db "-L1"  
333a f1			.pastdmark: pop af  
333b			endm  
# End of macro DMARK
333b						CALLMONITOR 
333b cd 2d 17			call break_point_state  
333e				endm  
# End of macro CALLMONITOR
333e					endif 
333e			 
333e ed 52			sbc hl, de 
3340			 
3340			 
3340				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3340			 
3340 20 26				jr nz, .mloopnotdone 
3342			 
3342 e1				pop hl   ; get rid of saved I 
3343				FORTH_LOOP_POP     ; get rid of limit 
3343 cd 22 1f			call macro_forth_loop_pop 
3346				endm 
# End of macro FORTH_LOOP_POP
3346			 
3346				FORTH_RSP_POP     ; get rid of DO ptr 
3346 cd 85 1c			call macro_forth_rsp_pop 
3349				endm 
# End of macro FORTH_RSP_POP
3349			 
3349			if DEBUG_FORTH_WORDS 
3349						DMARK "-L>" 
3349 f5				push af  
334a 3a 5e 33			ld a, (.dmark)  
334d 32 bd fb			ld (debug_mark),a  
3350 3a 5f 33			ld a, (.dmark+1)  
3353 32 be fb			ld (debug_mark+1),a  
3356 3a 60 33			ld a, (.dmark+2)  
3359 32 bf fb			ld (debug_mark+2),a  
335c 18 03			jr .pastdmark  
335e ..			.dmark: db "-L>"  
3361 f1			.pastdmark: pop af  
3362			endm  
# End of macro DMARK
3362				CALLMONITOR 
3362 cd 2d 17			call break_point_state  
3365				endm  
# End of macro CALLMONITOR
3365			endif 
3365			 
3365					NEXTW 
3365 c3 26 20			jp macro_next 
3368				endm 
# End of macro NEXTW
3368				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3368			 
3368			.mloopnotdone: 
3368			 
3368 e1				pop hl    ; get I 
3369 2b				dec hl 
336a			 
336a			   	; save new I 
336a			 
336a			 
336a					; set I counter 
336a			 
336a 22 c8 f2				ld (os_current_i), hl 
336d			 
336d					 
336d				FORTH_LOOP_NEXT 
336d cd e5 1e			call macro_forth_loop_next 
3370				endm 
# End of macro FORTH_LOOP_NEXT
3370			 
3370			 
3370					if DEBUG_FORTH_WORDS 
3370 eb						ex de,hl 
3371					endif 
3371			 
3371			;	; get DO ptr 
3371			; 
3371				FORTH_RSP_TOS 
3371 cd 7b 1c			call macro_forth_rsp_tos 
3374				endm 
# End of macro FORTH_RSP_TOS
3374			 
3374				;push hl 
3374			 
3374				; not going to DO any more 
3374				; get rid of the RSP pointer as DO will add it back in 
3374				;FORTH_RSP_POP 
3374				;pop hl 
3374			 
3374			 
3374 22 a4 f2			ld (os_tok_ptr), hl 
3377					if DEBUG_FORTH_WORDS 
3377						DMARK "-L<" 
3377 f5				push af  
3378 3a 8c 33			ld a, (.dmark)  
337b 32 bd fb			ld (debug_mark),a  
337e 3a 8d 33			ld a, (.dmark+1)  
3381 32 be fb			ld (debug_mark+1),a  
3384 3a 8e 33			ld a, (.dmark+2)  
3387 32 bf fb			ld (debug_mark+2),a  
338a 18 03			jr .pastdmark  
338c ..			.dmark: db "-L<"  
338f f1			.pastdmark: pop af  
3390			endm  
# End of macro DMARK
3390					CALLMONITOR 
3390 cd 2d 17			call break_point_state  
3393				endm  
# End of macro CALLMONITOR
3393				endif 
3393 c3 b7 20			jp exec1 
3396			 
3396					 
3396			 
3396			 
3396			 
3396				NEXTW 
3396 c3 26 20			jp macro_next 
3399				endm 
# End of macro NEXTW
3399			 
3399			 
3399			 
3399			 
3399			.REPEAT: 
3399				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3399 71				db WORD_SYS_CORE+93             
339a ec 33			dw .UNTIL            
339c 06				db 5 + 1 
339d .. 00			db "REPEAT",0              
33a4				endm 
# End of macro CWHEAD
33a4			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33a4			;  push pc to rsp stack past the REPEAT 
33a4					if DEBUG_FORTH_WORDS_KEY 
33a4						DMARK "REP" 
33a4 f5				push af  
33a5 3a b9 33			ld a, (.dmark)  
33a8 32 bd fb			ld (debug_mark),a  
33ab 3a ba 33			ld a, (.dmark+1)  
33ae 32 be fb			ld (debug_mark+1),a  
33b1 3a bb 33			ld a, (.dmark+2)  
33b4 32 bf fb			ld (debug_mark+2),a  
33b7 18 03			jr .pastdmark  
33b9 ..			.dmark: db "REP"  
33bc f1			.pastdmark: pop af  
33bd			endm  
# End of macro DMARK
33bd						CALLMONITOR 
33bd cd 2d 17			call break_point_state  
33c0				endm  
# End of macro CALLMONITOR
33c0					endif 
33c0			 
33c0 2a a4 f2				ld hl, (os_tok_ptr) 
33c3 23					inc hl   ; R 
33c4 23					inc hl  ; E 
33c5 23					inc hl   ; P 
33c6 23					inc hl   ; E 
33c7 23					inc hl   ; A 
33c8 23					inc hl   ; T 
33c9 23					inc hl   ; zero 
33ca					FORTH_RSP_NEXT 
33ca cd 64 1c			call macro_forth_rsp_next 
33cd				endm 
# End of macro FORTH_RSP_NEXT
33cd			 
33cd			 
33cd					if DEBUG_FORTH_WORDS 
33cd						DMARK "REP" 
33cd f5				push af  
33ce 3a e2 33			ld a, (.dmark)  
33d1 32 bd fb			ld (debug_mark),a  
33d4 3a e3 33			ld a, (.dmark+1)  
33d7 32 be fb			ld (debug_mark+1),a  
33da 3a e4 33			ld a, (.dmark+2)  
33dd 32 bf fb			ld (debug_mark+2),a  
33e0 18 03			jr .pastdmark  
33e2 ..			.dmark: db "REP"  
33e5 f1			.pastdmark: pop af  
33e6			endm  
# End of macro DMARK
33e6						;pop bc    ; TODO BUG ?????? what is this for???? 
33e6						CALLMONITOR 
33e6 cd 2d 17			call break_point_state  
33e9				endm  
# End of macro CALLMONITOR
33e9					endif 
33e9			 
33e9					NEXTW 
33e9 c3 26 20			jp macro_next 
33ec				endm 
# End of macro NEXTW
33ec			;	       NEXTW 
33ec			 
33ec			.UNTIL: 
33ec				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33ec 72				db WORD_SYS_CORE+94             
33ed 83 34			dw .ENDFLOW            
33ef 06				db 5 + 1 
33f0 .. 00			db "UNTIL",0              
33f6				endm 
# End of macro CWHEAD
33f6			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33f6			 
33f6				; pop tos as check 
33f6			 
33f6				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33f6			 
33f6				FORTH_DSP_VALUEHL 
33f6 cd b4 1e			call macro_dsp_valuehl 
33f9				endm 
# End of macro FORTH_DSP_VALUEHL
33f9			 
33f9					if DEBUG_FORTH_WORDS_KEY 
33f9						DMARK "UNT" 
33f9 f5				push af  
33fa 3a 0e 34			ld a, (.dmark)  
33fd 32 bd fb			ld (debug_mark),a  
3400 3a 0f 34			ld a, (.dmark+1)  
3403 32 be fb			ld (debug_mark+1),a  
3406 3a 10 34			ld a, (.dmark+2)  
3409 32 bf fb			ld (debug_mark+2),a  
340c 18 03			jr .pastdmark  
340e ..			.dmark: db "UNT"  
3411 f1			.pastdmark: pop af  
3412			endm  
# End of macro DMARK
3412						CALLMONITOR 
3412 cd 2d 17			call break_point_state  
3415				endm  
# End of macro CALLMONITOR
3415					endif 
3415			 
3415			;	push hl 
3415				FORTH_DSP_POP 
3415 cd 6c 1f			call macro_forth_dsp_pop 
3418				endm 
# End of macro FORTH_DSP_POP
3418			 
3418			;	pop hl 
3418			 
3418				; test if true 
3418			 
3418 cd 43 0d			call ishlzero 
341b			;	ld a,l 
341b			;	add h 
341b			; 
341b			;	cp 0 
341b			 
341b 20 3e			jr nz, .untilnotdone 
341d			 
341d					if DEBUG_FORTH_WORDS 
341d						DMARK "UNf" 
341d f5				push af  
341e 3a 32 34			ld a, (.dmark)  
3421 32 bd fb			ld (debug_mark),a  
3424 3a 33 34			ld a, (.dmark+1)  
3427 32 be fb			ld (debug_mark+1),a  
342a 3a 34 34			ld a, (.dmark+2)  
342d 32 bf fb			ld (debug_mark+2),a  
3430 18 03			jr .pastdmark  
3432 ..			.dmark: db "UNf"  
3435 f1			.pastdmark: pop af  
3436			endm  
# End of macro DMARK
3436						CALLMONITOR 
3436 cd 2d 17			call break_point_state  
3439				endm  
# End of macro CALLMONITOR
3439					endif 
3439			 
3439			 
3439			 
3439				FORTH_RSP_POP     ; get rid of DO ptr 
3439 cd 85 1c			call macro_forth_rsp_pop 
343c				endm 
# End of macro FORTH_RSP_POP
343c			 
343c			if DEBUG_FORTH_WORDS 
343c						DMARK "UN>" 
343c f5				push af  
343d 3a 51 34			ld a, (.dmark)  
3440 32 bd fb			ld (debug_mark),a  
3443 3a 52 34			ld a, (.dmark+1)  
3446 32 be fb			ld (debug_mark+1),a  
3449 3a 53 34			ld a, (.dmark+2)  
344c 32 bf fb			ld (debug_mark+2),a  
344f 18 03			jr .pastdmark  
3451 ..			.dmark: db "UN>"  
3454 f1			.pastdmark: pop af  
3455			endm  
# End of macro DMARK
3455				CALLMONITOR 
3455 cd 2d 17			call break_point_state  
3458				endm  
# End of macro CALLMONITOR
3458			endif 
3458			 
3458					NEXTW 
3458 c3 26 20			jp macro_next 
345b				endm 
# End of macro NEXTW
345b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
345b			 
345b			.untilnotdone: 
345b			 
345b			 
345b			;	; get DO ptr 
345b			; 
345b				FORTH_RSP_TOS 
345b cd 7b 1c			call macro_forth_rsp_tos 
345e				endm 
# End of macro FORTH_RSP_TOS
345e			 
345e				;push hl 
345e			 
345e				; not going to DO any more 
345e				; get rid of the RSP pointer as DO will add it back in 
345e				;FORTH_RSP_POP 
345e				;pop hl 
345e			 
345e			 
345e 22 a4 f2			ld (os_tok_ptr), hl 
3461					if DEBUG_FORTH_WORDS 
3461						DMARK "UN<" 
3461 f5				push af  
3462 3a 76 34			ld a, (.dmark)  
3465 32 bd fb			ld (debug_mark),a  
3468 3a 77 34			ld a, (.dmark+1)  
346b 32 be fb			ld (debug_mark+1),a  
346e 3a 78 34			ld a, (.dmark+2)  
3471 32 bf fb			ld (debug_mark+2),a  
3474 18 03			jr .pastdmark  
3476 ..			.dmark: db "UN<"  
3479 f1			.pastdmark: pop af  
347a			endm  
# End of macro DMARK
347a					CALLMONITOR 
347a cd 2d 17			call break_point_state  
347d				endm  
# End of macro CALLMONITOR
347d				endif 
347d c3 b7 20			jp exec1 
3480			 
3480					 
3480			 
3480			 
3480					NEXTW 
3480 c3 26 20			jp macro_next 
3483				endm 
# End of macro NEXTW
3483			 
3483			 
3483			.ENDFLOW: 
3483			 
3483			; eof 
3483			 
# End of file forth_words_flow.asm
3483			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3483			include "forth_words_logic.asm" 
3483			 
3483			; | ## Logic Words 
3483			 
3483			.NOT: 
3483				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3483 2d				db WORD_SYS_CORE+25             
3484 cb 34			dw .IS            
3486 04				db 3 + 1 
3487 .. 00			db "NOT",0              
348b				endm 
# End of macro CWHEAD
348b			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
348b					if DEBUG_FORTH_WORDS_KEY 
348b						DMARK "NOT" 
348b f5				push af  
348c 3a a0 34			ld a, (.dmark)  
348f 32 bd fb			ld (debug_mark),a  
3492 3a a1 34			ld a, (.dmark+1)  
3495 32 be fb			ld (debug_mark+1),a  
3498 3a a2 34			ld a, (.dmark+2)  
349b 32 bf fb			ld (debug_mark+2),a  
349e 18 03			jr .pastdmark  
34a0 ..			.dmark: db "NOT"  
34a3 f1			.pastdmark: pop af  
34a4			endm  
# End of macro DMARK
34a4						CALLMONITOR 
34a4 cd 2d 17			call break_point_state  
34a7				endm  
# End of macro CALLMONITOR
34a7					endif 
34a7					FORTH_DSP 
34a7 cd 7a 1e			call macro_forth_dsp 
34aa				endm 
# End of macro FORTH_DSP
34aa 7e					ld a,(hl)	; get type of value on TOS 
34ab fe 02				cp DS_TYPE_INUM  
34ad 28 03				jr z, .noti 
34af					NEXTW 
34af c3 26 20			jp macro_next 
34b2				endm 
# End of macro NEXTW
34b2			.noti:          FORTH_DSP_VALUEHL 
34b2 cd b4 1e			call macro_dsp_valuehl 
34b5				endm 
# End of macro FORTH_DSP_VALUEHL
34b5			;		push hl 
34b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34b5 cd 6c 1f			call macro_forth_dsp_pop 
34b8				endm 
# End of macro FORTH_DSP_POP
34b8			;		pop hl 
34b8 3e 00				ld a,0 
34ba bd					cp l 
34bb 28 04				jr z, .not2t 
34bd 2e 00				ld l, 0 
34bf 18 02				jr .notip 
34c1			 
34c1 2e ff		.not2t:		ld l, 255 
34c3			 
34c3 26 00		.notip:		ld h, 0	 
34c5			 
34c5 cd bd 1c				call forth_push_numhl 
34c8					NEXTW 
34c8 c3 26 20			jp macro_next 
34cb				endm 
# End of macro NEXTW
34cb			 
34cb			.IS: 
34cb				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34cb 2d				db WORD_SYS_CORE+25             
34cc f1 34			dw .LZERO            
34ce 03				db 2 + 1 
34cf .. 00			db "IS",0              
34d2				endm 
# End of macro CWHEAD
34d2			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34d2					if DEBUG_FORTH_WORDS_KEY 
34d2						DMARK "IS." 
34d2 f5				push af  
34d3 3a e7 34			ld a, (.dmark)  
34d6 32 bd fb			ld (debug_mark),a  
34d9 3a e8 34			ld a, (.dmark+1)  
34dc 32 be fb			ld (debug_mark+1),a  
34df 3a e9 34			ld a, (.dmark+2)  
34e2 32 bf fb			ld (debug_mark+2),a  
34e5 18 03			jr .pastdmark  
34e7 ..			.dmark: db "IS."  
34ea f1			.pastdmark: pop af  
34eb			endm  
# End of macro DMARK
34eb						CALLMONITOR 
34eb cd 2d 17			call break_point_state  
34ee				endm  
# End of macro CALLMONITOR
34ee					endif 
34ee					NEXTW 
34ee c3 26 20			jp macro_next 
34f1				endm 
# End of macro NEXTW
34f1			.LZERO: 
34f1				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34f1 2d				db WORD_SYS_CORE+25             
34f2 fb 34			dw .TZERO            
34f4 03				db 2 + 1 
34f5 .. 00			db "0<",0              
34f8				endm 
# End of macro CWHEAD
34f8			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34f8					NEXTW 
34f8 c3 26 20			jp macro_next 
34fb				endm 
# End of macro NEXTW
34fb			.TZERO: 
34fb				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34fb 2e				db WORD_SYS_CORE+26             
34fc 42 35			dw .LESS            
34fe 03				db 2 + 1 
34ff .. 00			db "0=",0              
3502				endm 
# End of macro CWHEAD
3502			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3502				; TODO add floating point number detection 
3502					;v5 FORTH_DSP_VALUE 
3502					if DEBUG_FORTH_WORDS_KEY 
3502						DMARK "0=." 
3502 f5				push af  
3503 3a 17 35			ld a, (.dmark)  
3506 32 bd fb			ld (debug_mark),a  
3509 3a 18 35			ld a, (.dmark+1)  
350c 32 be fb			ld (debug_mark+1),a  
350f 3a 19 35			ld a, (.dmark+2)  
3512 32 bf fb			ld (debug_mark+2),a  
3515 18 03			jr .pastdmark  
3517 ..			.dmark: db "0=."  
351a f1			.pastdmark: pop af  
351b			endm  
# End of macro DMARK
351b						CALLMONITOR 
351b cd 2d 17			call break_point_state  
351e				endm  
# End of macro CALLMONITOR
351e					endif 
351e					FORTH_DSP 
351e cd 7a 1e			call macro_forth_dsp 
3521				endm 
# End of macro FORTH_DSP
3521 7e					ld a,(hl)	; get type of value on TOS 
3522 fe 02				cp DS_TYPE_INUM  
3524 28 00				jr z, .tz_inum 
3526			 
3526				if FORTH_ENABLE_FLOATMATH 
3526					jr .tz_done 
3526			 
3526				endif 
3526					 
3526			 
3526			.tz_inum: 
3526					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3526 cd b4 1e			call macro_dsp_valuehl 
3529				endm 
# End of macro FORTH_DSP_VALUEHL
3529			 
3529			;		push hl 
3529			 
3529					; destroy value TOS 
3529			 
3529					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3529 cd 6c 1f			call macro_forth_dsp_pop 
352c				endm 
# End of macro FORTH_DSP_POP
352c			 
352c			;		pop hl 
352c			 
352c 3e 00				ld a,0 
352e			 
352e bd					cp l 
352f 20 08				jr nz, .tz_notzero 
3531			 
3531 bc					cp h 
3532			 
3532 20 05				jr nz, .tz_notzero 
3534			 
3534			 
3534 21 01 00				ld hl, FORTH_TRUE 
3537 18 03				jr .tz_done 
3539			 
3539 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
353c			 
353c					; push value back onto stack for another op etc 
353c			 
353c			.tz_done: 
353c cd bd 1c				call forth_push_numhl 
353f			 
353f					NEXTW 
353f c3 26 20			jp macro_next 
3542				endm 
# End of macro NEXTW
3542			.LESS: 
3542				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3542 2f				db WORD_SYS_CORE+27             
3543 ab 35			dw .GT            
3545 02				db 1 + 1 
3546 .. 00			db "<",0              
3548				endm 
# End of macro CWHEAD
3548			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3548				; TODO add floating point number detection 
3548					if DEBUG_FORTH_WORDS_KEY 
3548						DMARK "LES" 
3548 f5				push af  
3549 3a 5d 35			ld a, (.dmark)  
354c 32 bd fb			ld (debug_mark),a  
354f 3a 5e 35			ld a, (.dmark+1)  
3552 32 be fb			ld (debug_mark+1),a  
3555 3a 5f 35			ld a, (.dmark+2)  
3558 32 bf fb			ld (debug_mark+2),a  
355b 18 03			jr .pastdmark  
355d ..			.dmark: db "LES"  
3560 f1			.pastdmark: pop af  
3561			endm  
# End of macro DMARK
3561						CALLMONITOR 
3561 cd 2d 17			call break_point_state  
3564				endm  
# End of macro CALLMONITOR
3564					endif 
3564					FORTH_DSP 
3564 cd 7a 1e			call macro_forth_dsp 
3567				endm 
# End of macro FORTH_DSP
3567					;v5 FORTH_DSP_VALUE 
3567 7e					ld a,(hl)	; get type of value on TOS 
3568 fe 02				cp DS_TYPE_INUM  
356a 28 00				jr z, .less_inum 
356c			 
356c				if FORTH_ENABLE_FLOATMATH 
356c					jr .less_done 
356c			 
356c				endif 
356c					 
356c			 
356c			.less_inum: 
356c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
356c cd b4 1e			call macro_dsp_valuehl 
356f				endm 
# End of macro FORTH_DSP_VALUEHL
356f			 
356f e5					push hl  ; u2 
3570			 
3570					; destroy value TOS 
3570			 
3570					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3570 cd 6c 1f			call macro_forth_dsp_pop 
3573				endm 
# End of macro FORTH_DSP_POP
3573			 
3573			 
3573					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3573 cd b4 1e			call macro_dsp_valuehl 
3576				endm 
# End of macro FORTH_DSP_VALUEHL
3576			 
3576 e5					push hl    ; u1 
3577			 
3577					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3577 cd 6c 1f			call macro_forth_dsp_pop 
357a				endm 
# End of macro FORTH_DSP_POP
357a			 
357a			 
357a b7			 or a      ;clear carry flag 
357b 01 00 00		 ld bc, FORTH_FALSE 
357e e1			  pop hl    ; u1 
357f d1			  pop de    ; u2 
3580 ed 52		  sbc hl,de 
3582 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3584			 
3584 01 01 00		 ld bc, FORTH_TRUE 
3587			.lscont:  
3587 c5					push bc 
3588 e1					pop hl 
3589			 
3589					if DEBUG_FORTH_WORDS 
3589						DMARK "LT1" 
3589 f5				push af  
358a 3a 9e 35			ld a, (.dmark)  
358d 32 bd fb			ld (debug_mark),a  
3590 3a 9f 35			ld a, (.dmark+1)  
3593 32 be fb			ld (debug_mark+1),a  
3596 3a a0 35			ld a, (.dmark+2)  
3599 32 bf fb			ld (debug_mark+2),a  
359c 18 03			jr .pastdmark  
359e ..			.dmark: db "LT1"  
35a1 f1			.pastdmark: pop af  
35a2			endm  
# End of macro DMARK
35a2						CALLMONITOR 
35a2 cd 2d 17			call break_point_state  
35a5				endm  
# End of macro CALLMONITOR
35a5					endif 
35a5 cd bd 1c				call forth_push_numhl 
35a8			 
35a8					NEXTW 
35a8 c3 26 20			jp macro_next 
35ab				endm 
# End of macro NEXTW
35ab			.GT: 
35ab				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35ab 30				db WORD_SYS_CORE+28             
35ac 14 36			dw .EQUAL            
35ae 02				db 1 + 1 
35af .. 00			db ">",0              
35b1				endm 
# End of macro CWHEAD
35b1			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35b1				; TODO add floating point number detection 
35b1					if DEBUG_FORTH_WORDS_KEY 
35b1						DMARK "GRT" 
35b1 f5				push af  
35b2 3a c6 35			ld a, (.dmark)  
35b5 32 bd fb			ld (debug_mark),a  
35b8 3a c7 35			ld a, (.dmark+1)  
35bb 32 be fb			ld (debug_mark+1),a  
35be 3a c8 35			ld a, (.dmark+2)  
35c1 32 bf fb			ld (debug_mark+2),a  
35c4 18 03			jr .pastdmark  
35c6 ..			.dmark: db "GRT"  
35c9 f1			.pastdmark: pop af  
35ca			endm  
# End of macro DMARK
35ca						CALLMONITOR 
35ca cd 2d 17			call break_point_state  
35cd				endm  
# End of macro CALLMONITOR
35cd					endif 
35cd					FORTH_DSP 
35cd cd 7a 1e			call macro_forth_dsp 
35d0				endm 
# End of macro FORTH_DSP
35d0					;FORTH_DSP_VALUE 
35d0 7e					ld a,(hl)	; get type of value on TOS 
35d1 fe 02				cp DS_TYPE_INUM  
35d3 28 00				jr z, .gt_inum 
35d5			 
35d5				if FORTH_ENABLE_FLOATMATH 
35d5					jr .gt_done 
35d5			 
35d5				endif 
35d5					 
35d5			 
35d5			.gt_inum: 
35d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35d5 cd b4 1e			call macro_dsp_valuehl 
35d8				endm 
# End of macro FORTH_DSP_VALUEHL
35d8			 
35d8 e5					push hl  ; u2 
35d9			 
35d9					; destroy value TOS 
35d9			 
35d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35d9 cd 6c 1f			call macro_forth_dsp_pop 
35dc				endm 
# End of macro FORTH_DSP_POP
35dc			 
35dc			 
35dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35dc cd b4 1e			call macro_dsp_valuehl 
35df				endm 
# End of macro FORTH_DSP_VALUEHL
35df			 
35df e5					push hl    ; u1 
35e0			 
35e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e0 cd 6c 1f			call macro_forth_dsp_pop 
35e3				endm 
# End of macro FORTH_DSP_POP
35e3			 
35e3			 
35e3 b7			 or a      ;clear carry flag 
35e4 01 00 00		 ld bc, FORTH_FALSE 
35e7 e1			  pop hl    ; u1 
35e8 d1			  pop de    ; u2 
35e9 ed 52		  sbc hl,de 
35eb 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35ed			 
35ed 01 01 00		 ld bc, FORTH_TRUE 
35f0			.gtcont:  
35f0 c5					push bc 
35f1 e1					pop hl 
35f2			 
35f2					if DEBUG_FORTH_WORDS 
35f2						DMARK "GT1" 
35f2 f5				push af  
35f3 3a 07 36			ld a, (.dmark)  
35f6 32 bd fb			ld (debug_mark),a  
35f9 3a 08 36			ld a, (.dmark+1)  
35fc 32 be fb			ld (debug_mark+1),a  
35ff 3a 09 36			ld a, (.dmark+2)  
3602 32 bf fb			ld (debug_mark+2),a  
3605 18 03			jr .pastdmark  
3607 ..			.dmark: db "GT1"  
360a f1			.pastdmark: pop af  
360b			endm  
# End of macro DMARK
360b						CALLMONITOR 
360b cd 2d 17			call break_point_state  
360e				endm  
# End of macro CALLMONITOR
360e					endif 
360e cd bd 1c				call forth_push_numhl 
3611			 
3611					NEXTW 
3611 c3 26 20			jp macro_next 
3614				endm 
# End of macro NEXTW
3614			.EQUAL: 
3614				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3614 31				db WORD_SYS_CORE+29             
3615 7f 36			dw .ENDLOGIC            
3617 02				db 1 + 1 
3618 .. 00			db "=",0              
361a				endm 
# End of macro CWHEAD
361a			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
361a				; TODO add floating point number detection 
361a					if DEBUG_FORTH_WORDS_KEY 
361a						DMARK "EQ." 
361a f5				push af  
361b 3a 2f 36			ld a, (.dmark)  
361e 32 bd fb			ld (debug_mark),a  
3621 3a 30 36			ld a, (.dmark+1)  
3624 32 be fb			ld (debug_mark+1),a  
3627 3a 31 36			ld a, (.dmark+2)  
362a 32 bf fb			ld (debug_mark+2),a  
362d 18 03			jr .pastdmark  
362f ..			.dmark: db "EQ."  
3632 f1			.pastdmark: pop af  
3633			endm  
# End of macro DMARK
3633						CALLMONITOR 
3633 cd 2d 17			call break_point_state  
3636				endm  
# End of macro CALLMONITOR
3636					endif 
3636					FORTH_DSP 
3636 cd 7a 1e			call macro_forth_dsp 
3639				endm 
# End of macro FORTH_DSP
3639					;v5 FORTH_DSP_VALUE 
3639 7e					ld a,(hl)	; get type of value on TOS 
363a fe 02				cp DS_TYPE_INUM  
363c 28 00				jr z, .eq_inum 
363e			 
363e				if FORTH_ENABLE_FLOATMATH 
363e					jr .eq_done 
363e			 
363e				endif 
363e					 
363e			 
363e			.eq_inum: 
363e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
363e cd b4 1e			call macro_dsp_valuehl 
3641				endm 
# End of macro FORTH_DSP_VALUEHL
3641			 
3641 e5					push hl 
3642			 
3642					; destroy value TOS 
3642			 
3642					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3642 cd 6c 1f			call macro_forth_dsp_pop 
3645				endm 
# End of macro FORTH_DSP_POP
3645			 
3645			 
3645					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3645 cd b4 1e			call macro_dsp_valuehl 
3648				endm 
# End of macro FORTH_DSP_VALUEHL
3648			 
3648					; one value on hl get other one back 
3648			 
3648 e5					push hl 
3649			 
3649					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3649 cd 6c 1f			call macro_forth_dsp_pop 
364c				endm 
# End of macro FORTH_DSP_POP
364c			 
364c 0e 00				ld c, FORTH_FALSE 
364e			 
364e e1					pop hl 
364f d1					pop de 
3650			 
3650 7b					ld a, e 
3651 bd					cp l 
3652			 
3652 20 06				jr nz, .eq_done 
3654			 
3654 7a					ld a, d 
3655 bc					cp h 
3656			 
3656 20 02				jr nz, .eq_done 
3658			 
3658 0e 01				ld c, FORTH_TRUE 
365a					 
365a			 
365a			 
365a			.eq_done: 
365a			 
365a					; TODO push value back onto stack for another op etc 
365a			 
365a 26 00				ld h, 0 
365c 69					ld l, c 
365d					if DEBUG_FORTH_WORDS 
365d						DMARK "EQ1" 
365d f5				push af  
365e 3a 72 36			ld a, (.dmark)  
3661 32 bd fb			ld (debug_mark),a  
3664 3a 73 36			ld a, (.dmark+1)  
3667 32 be fb			ld (debug_mark+1),a  
366a 3a 74 36			ld a, (.dmark+2)  
366d 32 bf fb			ld (debug_mark+2),a  
3670 18 03			jr .pastdmark  
3672 ..			.dmark: db "EQ1"  
3675 f1			.pastdmark: pop af  
3676			endm  
# End of macro DMARK
3676						CALLMONITOR 
3676 cd 2d 17			call break_point_state  
3679				endm  
# End of macro CALLMONITOR
3679					endif 
3679 cd bd 1c				call forth_push_numhl 
367c			 
367c					NEXTW 
367c c3 26 20			jp macro_next 
367f				endm 
# End of macro NEXTW
367f			 
367f			 
367f			.ENDLOGIC: 
367f			; eof 
367f			 
367f			 
# End of file forth_words_logic.asm
367f			include "forth_words_maths.asm" 
367f			 
367f			; | ## Maths Words 
367f			 
367f			.PLUS:	 
367f				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
367f 15				db WORD_SYS_CORE+1             
3680 c1 36			dw .NEG            
3682 02				db 1 + 1 
3683 .. 00			db "+",0              
3685				endm 
# End of macro CWHEAD
3685			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3685					if DEBUG_FORTH_WORDS_KEY 
3685						DMARK "PLU" 
3685 f5				push af  
3686 3a 9a 36			ld a, (.dmark)  
3689 32 bd fb			ld (debug_mark),a  
368c 3a 9b 36			ld a, (.dmark+1)  
368f 32 be fb			ld (debug_mark+1),a  
3692 3a 9c 36			ld a, (.dmark+2)  
3695 32 bf fb			ld (debug_mark+2),a  
3698 18 03			jr .pastdmark  
369a ..			.dmark: db "PLU"  
369d f1			.pastdmark: pop af  
369e			endm  
# End of macro DMARK
369e						CALLMONITOR 
369e cd 2d 17			call break_point_state  
36a1				endm  
# End of macro CALLMONITOR
36a1					endif 
36a1					; add top two values and push back result 
36a1			 
36a1					;for v5 FORTH_DSP_VALUE 
36a1					FORTH_DSP 
36a1 cd 7a 1e			call macro_forth_dsp 
36a4				endm 
# End of macro FORTH_DSP
36a4 7e					ld a,(hl)	; get type of value on TOS 
36a5 fe 02				cp DS_TYPE_INUM  
36a7 28 03				jr z, .dot_inum 
36a9			 
36a9					NEXTW 
36a9 c3 26 20			jp macro_next 
36ac				endm 
# End of macro NEXTW
36ac			 
36ac			; float maths 
36ac			 
36ac				if FORTH_ENABLE_FLOATMATH 
36ac						inc hl      ; now at start of numeric as string 
36ac			 
36ac					if DEBUG_FORTH_MATHS 
36ac						DMARK "ADD" 
36ac				CALLMONITOR 
36ac					endif 
36ac			 
36ac					;ld ix, hl 
36ac					call CON 
36ac			 
36ac			 
36ac					push hl 
36ac					 
36ac					 
36ac			 
36ac						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36ac			 
36ac					; get next number 
36ac			 
36ac						FORTH_DSP_VALUE 
36ac			 
36ac						inc hl      ; now at start of numeric as string 
36ac			 
36ac					;ld ix, hl 
36ac					call CON 
36ac			 
36ac					push hl 
36ac			 
36ac			 
36ac						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ac			 
36ac						; TODO do add 
36ac			 
36ac						call IADD 
36ac			 
36ac						; TODO get result back as ascii 
36ac			 
36ac						; TODO push result  
36ac			 
36ac			 
36ac			 
36ac						jr .dot_done 
36ac				endif 
36ac			 
36ac			.dot_inum: 
36ac			 
36ac			 
36ac					if DEBUG_FORTH_DOT 
36ac						DMARK "+IT" 
36ac				CALLMONITOR 
36ac					endif 
36ac			 
36ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ac cd b4 1e			call macro_dsp_valuehl 
36af				endm 
# End of macro FORTH_DSP_VALUEHL
36af			 
36af				; TODO add floating point number detection 
36af			 
36af e5					push hl 
36b0			 
36b0					; destroy value TOS 
36b0			 
36b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b0 cd 6c 1f			call macro_forth_dsp_pop 
36b3				endm 
# End of macro FORTH_DSP_POP
36b3			 
36b3			 
36b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b3 cd b4 1e			call macro_dsp_valuehl 
36b6				endm 
# End of macro FORTH_DSP_VALUEHL
36b6			 
36b6					; one value on hl get other one back 
36b6			 
36b6 d1					pop de 
36b7			 
36b7					; do the add 
36b7			 
36b7 19					add hl,de 
36b8			 
36b8					; save it 
36b8			 
36b8			;		push hl	 
36b8			 
36b8					; 
36b8			 
36b8					; destroy value TOS 
36b8			 
36b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b8 cd 6c 1f			call macro_forth_dsp_pop 
36bb				endm 
# End of macro FORTH_DSP_POP
36bb			 
36bb					; TODO push value back onto stack for another op etc 
36bb			 
36bb			;		pop hl 
36bb			 
36bb			.dot_done: 
36bb cd bd 1c				call forth_push_numhl 
36be			 
36be					NEXTW 
36be c3 26 20			jp macro_next 
36c1				endm 
# End of macro NEXTW
36c1			.NEG: 
36c1			 
36c1				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36c1 17				db WORD_SYS_CORE+3             
36c2 04 37			dw .DIV            
36c4 02				db 1 + 1 
36c5 .. 00			db "-",0              
36c7				endm 
# End of macro CWHEAD
36c7			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36c7					if DEBUG_FORTH_WORDS_KEY 
36c7						DMARK "SUB" 
36c7 f5				push af  
36c8 3a dc 36			ld a, (.dmark)  
36cb 32 bd fb			ld (debug_mark),a  
36ce 3a dd 36			ld a, (.dmark+1)  
36d1 32 be fb			ld (debug_mark+1),a  
36d4 3a de 36			ld a, (.dmark+2)  
36d7 32 bf fb			ld (debug_mark+2),a  
36da 18 03			jr .pastdmark  
36dc ..			.dmark: db "SUB"  
36df f1			.pastdmark: pop af  
36e0			endm  
# End of macro DMARK
36e0						CALLMONITOR 
36e0 cd 2d 17			call break_point_state  
36e3				endm  
# End of macro CALLMONITOR
36e3					endif 
36e3			 
36e3			 
36e3				; TODO add floating point number detection 
36e3					; v5 FORTH_DSP_VALUE 
36e3					FORTH_DSP 
36e3 cd 7a 1e			call macro_forth_dsp 
36e6				endm 
# End of macro FORTH_DSP
36e6 7e					ld a,(hl)	; get type of value on TOS 
36e7 fe 02				cp DS_TYPE_INUM  
36e9 28 03				jr z, .neg_inum 
36eb			 
36eb					NEXTW 
36eb c3 26 20			jp macro_next 
36ee				endm 
# End of macro NEXTW
36ee			 
36ee			; float maths 
36ee			 
36ee				if FORTH_ENABLE_FLOATMATH 
36ee					jr .neg_done 
36ee			 
36ee				endif 
36ee					 
36ee			 
36ee			.neg_inum: 
36ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ee cd b4 1e			call macro_dsp_valuehl 
36f1				endm 
# End of macro FORTH_DSP_VALUEHL
36f1			 
36f1 e5					push hl 
36f2			 
36f2					; destroy value TOS 
36f2			 
36f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f2 cd 6c 1f			call macro_forth_dsp_pop 
36f5				endm 
# End of macro FORTH_DSP_POP
36f5			 
36f5			 
36f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f5 cd b4 1e			call macro_dsp_valuehl 
36f8				endm 
# End of macro FORTH_DSP_VALUEHL
36f8			 
36f8					; one value on hl get other one back 
36f8			 
36f8 d1					pop de 
36f9			 
36f9					; do the sub 
36f9			;		ex de, hl 
36f9			 
36f9 ed 52				sbc hl,de 
36fb			 
36fb					; save it 
36fb			 
36fb			;		push hl	 
36fb			 
36fb					; 
36fb			 
36fb					; destroy value TOS 
36fb			 
36fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fb cd 6c 1f			call macro_forth_dsp_pop 
36fe				endm 
# End of macro FORTH_DSP_POP
36fe			 
36fe					; TODO push value back onto stack for another op etc 
36fe			 
36fe			;		pop hl 
36fe			 
36fe cd bd 1c				call forth_push_numhl 
3701			.neg_done: 
3701			 
3701					NEXTW 
3701 c3 26 20			jp macro_next 
3704				endm 
# End of macro NEXTW
3704			.DIV: 
3704				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3704 18				db WORD_SYS_CORE+4             
3705 51 37			dw .MUL            
3707 02				db 1 + 1 
3708 .. 00			db "/",0              
370a				endm 
# End of macro CWHEAD
370a			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
370a					if DEBUG_FORTH_WORDS_KEY 
370a						DMARK "DIV" 
370a f5				push af  
370b 3a 1f 37			ld a, (.dmark)  
370e 32 bd fb			ld (debug_mark),a  
3711 3a 20 37			ld a, (.dmark+1)  
3714 32 be fb			ld (debug_mark+1),a  
3717 3a 21 37			ld a, (.dmark+2)  
371a 32 bf fb			ld (debug_mark+2),a  
371d 18 03			jr .pastdmark  
371f ..			.dmark: db "DIV"  
3722 f1			.pastdmark: pop af  
3723			endm  
# End of macro DMARK
3723						CALLMONITOR 
3723 cd 2d 17			call break_point_state  
3726				endm  
# End of macro CALLMONITOR
3726					endif 
3726				; TODO add floating point number detection 
3726					; v5 FORTH_DSP_VALUE 
3726					FORTH_DSP 
3726 cd 7a 1e			call macro_forth_dsp 
3729				endm 
# End of macro FORTH_DSP
3729 7e					ld a,(hl)	; get type of value on TOS 
372a fe 02				cp DS_TYPE_INUM  
372c 28 03				jr z, .div_inum 
372e			 
372e				if FORTH_ENABLE_FLOATMATH 
372e					jr .div_done 
372e			 
372e				endif 
372e					NEXTW 
372e c3 26 20			jp macro_next 
3731				endm 
# End of macro NEXTW
3731			.div_inum: 
3731			 
3731					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3731 cd b4 1e			call macro_dsp_valuehl 
3734				endm 
# End of macro FORTH_DSP_VALUEHL
3734			 
3734 e5					push hl    ; to go to bc 
3735			 
3735					; destroy value TOS 
3735			 
3735					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3735 cd 6c 1f			call macro_forth_dsp_pop 
3738				endm 
# End of macro FORTH_DSP_POP
3738			 
3738			 
3738					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3738 cd b4 1e			call macro_dsp_valuehl 
373b				endm 
# End of macro FORTH_DSP_VALUEHL
373b			 
373b					; hl to go to de 
373b			 
373b e5					push hl 
373c			 
373c c1					pop bc 
373d d1					pop de		 
373e			 
373e			 
373e					if DEBUG_FORTH_MATHS 
373e						DMARK "DIV" 
373e				CALLMONITOR 
373e					endif 
373e					; one value on hl but move to a get other one back 
373e			 
373e			        
373e cd 77 0c			call Div16 
3741			 
3741			;	push af	 
3741 e5				push hl 
3742 c5				push bc 
3743			 
3743					if DEBUG_FORTH_MATHS 
3743						DMARK "DI1" 
3743				CALLMONITOR 
3743					endif 
3743			 
3743					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3743 cd 6c 1f			call macro_forth_dsp_pop 
3746				endm 
# End of macro FORTH_DSP_POP
3746			 
3746			 
3746			 
3746 e1					pop hl    ; result 
3747			 
3747 cd bd 1c				call forth_push_numhl 
374a			 
374a e1					pop hl    ; reminder 
374b			;		ld h,0 
374b			;		ld l,d 
374b			 
374b cd bd 1c				call forth_push_numhl 
374e			.div_done: 
374e					NEXTW 
374e c3 26 20			jp macro_next 
3751				endm 
# End of macro NEXTW
3751			.MUL: 
3751				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3751 19				db WORD_SYS_CORE+5             
3752 96 37			dw .MIN            
3754 02				db 1 + 1 
3755 .. 00			db "*",0              
3757				endm 
# End of macro CWHEAD
3757			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3757				; TODO add floating point number detection 
3757					if DEBUG_FORTH_WORDS_KEY 
3757						DMARK "MUL" 
3757 f5				push af  
3758 3a 6c 37			ld a, (.dmark)  
375b 32 bd fb			ld (debug_mark),a  
375e 3a 6d 37			ld a, (.dmark+1)  
3761 32 be fb			ld (debug_mark+1),a  
3764 3a 6e 37			ld a, (.dmark+2)  
3767 32 bf fb			ld (debug_mark+2),a  
376a 18 03			jr .pastdmark  
376c ..			.dmark: db "MUL"  
376f f1			.pastdmark: pop af  
3770			endm  
# End of macro DMARK
3770						CALLMONITOR 
3770 cd 2d 17			call break_point_state  
3773				endm  
# End of macro CALLMONITOR
3773					endif 
3773					FORTH_DSP 
3773 cd 7a 1e			call macro_forth_dsp 
3776				endm 
# End of macro FORTH_DSP
3776					; v5 FORTH_DSP_VALUE 
3776 7e					ld a,(hl)	; get type of value on TOS 
3777 fe 02				cp DS_TYPE_INUM  
3779 28 03				jr z, .mul_inum 
377b			 
377b				if FORTH_ENABLE_FLOATMATH 
377b					jr .mul_done 
377b			 
377b				endif 
377b			 
377b					NEXTW 
377b c3 26 20			jp macro_next 
377e				endm 
# End of macro NEXTW
377e			.mul_inum:	 
377e			 
377e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377e cd b4 1e			call macro_dsp_valuehl 
3781				endm 
# End of macro FORTH_DSP_VALUEHL
3781			 
3781 e5					push hl 
3782			 
3782					; destroy value TOS 
3782			 
3782					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3782 cd 6c 1f			call macro_forth_dsp_pop 
3785				endm 
# End of macro FORTH_DSP_POP
3785			 
3785			 
3785					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3785 cd b4 1e			call macro_dsp_valuehl 
3788				endm 
# End of macro FORTH_DSP_VALUEHL
3788			 
3788					; one value on hl but move to a get other one back 
3788			 
3788 7d					ld a, l 
3789			 
3789 d1					pop de 
378a			 
378a					; do the mull 
378a			;		ex de, hl 
378a			 
378a cd 9d 0c				call Mult16 
378d					; save it 
378d			 
378d			;		push hl	 
378d			 
378d					; 
378d			 
378d					; destroy value TOS 
378d			 
378d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378d cd 6c 1f			call macro_forth_dsp_pop 
3790				endm 
# End of macro FORTH_DSP_POP
3790			 
3790					; TODO push value back onto stack for another op etc 
3790			 
3790			;		pop hl 
3790			 
3790 cd bd 1c				call forth_push_numhl 
3793			 
3793			.mul_done: 
3793					NEXTW 
3793 c3 26 20			jp macro_next 
3796				endm 
# End of macro NEXTW
3796			 
3796			 
3796			 
3796			 
3796			.MIN: 
3796				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3796 49				db WORD_SYS_CORE+53             
3797 17 38			dw .MAX            
3799 04				db 3 + 1 
379a .. 00			db "MIN",0              
379e				endm 
# End of macro CWHEAD
379e			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
379e					if DEBUG_FORTH_WORDS_KEY 
379e						DMARK "MIN" 
379e f5				push af  
379f 3a b3 37			ld a, (.dmark)  
37a2 32 bd fb			ld (debug_mark),a  
37a5 3a b4 37			ld a, (.dmark+1)  
37a8 32 be fb			ld (debug_mark+1),a  
37ab 3a b5 37			ld a, (.dmark+2)  
37ae 32 bf fb			ld (debug_mark+2),a  
37b1 18 03			jr .pastdmark  
37b3 ..			.dmark: db "MIN"  
37b6 f1			.pastdmark: pop af  
37b7			endm  
# End of macro DMARK
37b7						CALLMONITOR 
37b7 cd 2d 17			call break_point_state  
37ba				endm  
# End of macro CALLMONITOR
37ba					endif 
37ba					; get u2 
37ba			 
37ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ba cd b4 1e			call macro_dsp_valuehl 
37bd				endm 
# End of macro FORTH_DSP_VALUEHL
37bd			 
37bd e5					push hl   ; u2 
37be			 
37be					; destroy value TOS 
37be			 
37be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37be cd 6c 1f			call macro_forth_dsp_pop 
37c1				endm 
# End of macro FORTH_DSP_POP
37c1			 
37c1					; get u1 
37c1			 
37c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37c1 cd b4 1e			call macro_dsp_valuehl 
37c4				endm 
# End of macro FORTH_DSP_VALUEHL
37c4			 
37c4 e5					push hl  ; u1 
37c5			 
37c5					; destroy value TOS 
37c5			 
37c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37c5 cd 6c 1f			call macro_forth_dsp_pop 
37c8				endm 
# End of macro FORTH_DSP_POP
37c8			 
37c8 b7			 or a      ;clear carry flag 
37c9 e1			  pop hl    ; u1 
37ca d1			  pop de    ; u2 
37cb e5				push hl   ; saved in case hl is lowest 
37cc ed 52		  sbc hl,de 
37ce 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37d0			 
37d0 e1				pop hl 
37d1					if DEBUG_FORTH_WORDS 
37d1						DMARK "MIN" 
37d1 f5				push af  
37d2 3a e6 37			ld a, (.dmark)  
37d5 32 bd fb			ld (debug_mark),a  
37d8 3a e7 37			ld a, (.dmark+1)  
37db 32 be fb			ld (debug_mark+1),a  
37de 3a e8 37			ld a, (.dmark+2)  
37e1 32 bf fb			ld (debug_mark+2),a  
37e4 18 03			jr .pastdmark  
37e6 ..			.dmark: db "MIN"  
37e9 f1			.pastdmark: pop af  
37ea			endm  
# End of macro DMARK
37ea						CALLMONITOR 
37ea cd 2d 17			call break_point_state  
37ed				endm  
# End of macro CALLMONITOR
37ed					endif 
37ed cd bd 1c				call forth_push_numhl 
37f0			 
37f0				       NEXTW 
37f0 c3 26 20			jp macro_next 
37f3				endm 
# End of macro NEXTW
37f3			 
37f3			.mincont:  
37f3 c1				pop bc   ; tidy up 
37f4 eb				ex de , hl  
37f5					if DEBUG_FORTH_WORDS 
37f5						DMARK "MI1" 
37f5 f5				push af  
37f6 3a 0a 38			ld a, (.dmark)  
37f9 32 bd fb			ld (debug_mark),a  
37fc 3a 0b 38			ld a, (.dmark+1)  
37ff 32 be fb			ld (debug_mark+1),a  
3802 3a 0c 38			ld a, (.dmark+2)  
3805 32 bf fb			ld (debug_mark+2),a  
3808 18 03			jr .pastdmark  
380a ..			.dmark: db "MI1"  
380d f1			.pastdmark: pop af  
380e			endm  
# End of macro DMARK
380e						CALLMONITOR 
380e cd 2d 17			call break_point_state  
3811				endm  
# End of macro CALLMONITOR
3811					endif 
3811 cd bd 1c				call forth_push_numhl 
3814			 
3814				       NEXTW 
3814 c3 26 20			jp macro_next 
3817				endm 
# End of macro NEXTW
3817			.MAX: 
3817				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3817 4a				db WORD_SYS_CORE+54             
3818 98 38			dw .RND16            
381a 04				db 3 + 1 
381b .. 00			db "MAX",0              
381f				endm 
# End of macro CWHEAD
381f			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
381f					if DEBUG_FORTH_WORDS_KEY 
381f						DMARK "MAX" 
381f f5				push af  
3820 3a 34 38			ld a, (.dmark)  
3823 32 bd fb			ld (debug_mark),a  
3826 3a 35 38			ld a, (.dmark+1)  
3829 32 be fb			ld (debug_mark+1),a  
382c 3a 36 38			ld a, (.dmark+2)  
382f 32 bf fb			ld (debug_mark+2),a  
3832 18 03			jr .pastdmark  
3834 ..			.dmark: db "MAX"  
3837 f1			.pastdmark: pop af  
3838			endm  
# End of macro DMARK
3838						CALLMONITOR 
3838 cd 2d 17			call break_point_state  
383b				endm  
# End of macro CALLMONITOR
383b					endif 
383b					; get u2 
383b			 
383b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
383b cd b4 1e			call macro_dsp_valuehl 
383e				endm 
# End of macro FORTH_DSP_VALUEHL
383e			 
383e e5					push hl   ; u2 
383f			 
383f					; destroy value TOS 
383f			 
383f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383f cd 6c 1f			call macro_forth_dsp_pop 
3842				endm 
# End of macro FORTH_DSP_POP
3842			 
3842					; get u1 
3842			 
3842					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3842 cd b4 1e			call macro_dsp_valuehl 
3845				endm 
# End of macro FORTH_DSP_VALUEHL
3845			 
3845 e5					push hl  ; u1 
3846			 
3846					; destroy value TOS 
3846			 
3846					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3846 cd 6c 1f			call macro_forth_dsp_pop 
3849				endm 
# End of macro FORTH_DSP_POP
3849			 
3849 b7			 or a      ;clear carry flag 
384a e1			  pop hl    ; u1 
384b d1			  pop de    ; u2 
384c e5				push hl   ; saved in case hl is lowest 
384d ed 52		  sbc hl,de 
384f 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3851			 
3851 e1				pop hl 
3852					if DEBUG_FORTH_WORDS 
3852						DMARK "MAX" 
3852 f5				push af  
3853 3a 67 38			ld a, (.dmark)  
3856 32 bd fb			ld (debug_mark),a  
3859 3a 68 38			ld a, (.dmark+1)  
385c 32 be fb			ld (debug_mark+1),a  
385f 3a 69 38			ld a, (.dmark+2)  
3862 32 bf fb			ld (debug_mark+2),a  
3865 18 03			jr .pastdmark  
3867 ..			.dmark: db "MAX"  
386a f1			.pastdmark: pop af  
386b			endm  
# End of macro DMARK
386b						CALLMONITOR 
386b cd 2d 17			call break_point_state  
386e				endm  
# End of macro CALLMONITOR
386e					endif 
386e cd bd 1c				call forth_push_numhl 
3871			 
3871				       NEXTW 
3871 c3 26 20			jp macro_next 
3874				endm 
# End of macro NEXTW
3874			 
3874			.maxcont:  
3874 c1				pop bc   ; tidy up 
3875 eb				ex de , hl  
3876					if DEBUG_FORTH_WORDS 
3876						DMARK "MA1" 
3876 f5				push af  
3877 3a 8b 38			ld a, (.dmark)  
387a 32 bd fb			ld (debug_mark),a  
387d 3a 8c 38			ld a, (.dmark+1)  
3880 32 be fb			ld (debug_mark+1),a  
3883 3a 8d 38			ld a, (.dmark+2)  
3886 32 bf fb			ld (debug_mark+2),a  
3889 18 03			jr .pastdmark  
388b ..			.dmark: db "MA1"  
388e f1			.pastdmark: pop af  
388f			endm  
# End of macro DMARK
388f						CALLMONITOR 
388f cd 2d 17			call break_point_state  
3892				endm  
# End of macro CALLMONITOR
3892					endif 
3892 cd bd 1c				call forth_push_numhl 
3895				       NEXTW 
3895 c3 26 20			jp macro_next 
3898				endm 
# End of macro NEXTW
3898			 
3898			.RND16: 
3898				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3898 4e				db WORD_SYS_CORE+58             
3899 c7 38			dw .RND8            
389b 06				db 5 + 1 
389c .. 00			db "RND16",0              
38a2				endm 
# End of macro CWHEAD
38a2			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38a2					if DEBUG_FORTH_WORDS_KEY 
38a2						DMARK "R16" 
38a2 f5				push af  
38a3 3a b7 38			ld a, (.dmark)  
38a6 32 bd fb			ld (debug_mark),a  
38a9 3a b8 38			ld a, (.dmark+1)  
38ac 32 be fb			ld (debug_mark+1),a  
38af 3a b9 38			ld a, (.dmark+2)  
38b2 32 bf fb			ld (debug_mark+2),a  
38b5 18 03			jr .pastdmark  
38b7 ..			.dmark: db "R16"  
38ba f1			.pastdmark: pop af  
38bb			endm  
# End of macro DMARK
38bb						CALLMONITOR 
38bb cd 2d 17			call break_point_state  
38be				endm  
# End of macro CALLMONITOR
38be					endif 
38be cd 41 0c				call prng16  
38c1 cd bd 1c				call forth_push_numhl 
38c4				       NEXTW 
38c4 c3 26 20			jp macro_next 
38c7				endm 
# End of macro NEXTW
38c7			.RND8: 
38c7				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38c7 60				db WORD_SYS_CORE+76             
38c8 fc 38			dw .RND            
38ca 05				db 4 + 1 
38cb .. 00			db "RND8",0              
38d0				endm 
# End of macro CWHEAD
38d0			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38d0					if DEBUG_FORTH_WORDS_KEY 
38d0						DMARK "RN8" 
38d0 f5				push af  
38d1 3a e5 38			ld a, (.dmark)  
38d4 32 bd fb			ld (debug_mark),a  
38d7 3a e6 38			ld a, (.dmark+1)  
38da 32 be fb			ld (debug_mark+1),a  
38dd 3a e7 38			ld a, (.dmark+2)  
38e0 32 bf fb			ld (debug_mark+2),a  
38e3 18 03			jr .pastdmark  
38e5 ..			.dmark: db "RN8"  
38e8 f1			.pastdmark: pop af  
38e9			endm  
# End of macro DMARK
38e9						CALLMONITOR 
38e9 cd 2d 17			call break_point_state  
38ec				endm  
# End of macro CALLMONITOR
38ec					endif 
38ec 2a 3e fa				ld hl,(xrandc) 
38ef 23					inc hl 
38f0 cd 5b 0c				call xrnd 
38f3 6f					ld l,a	 
38f4 26 00				ld h,0 
38f6 cd bd 1c				call forth_push_numhl 
38f9				       NEXTW 
38f9 c3 26 20			jp macro_next 
38fc				endm 
# End of macro NEXTW
38fc			.RND: 
38fc				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38fc 60				db WORD_SYS_CORE+76             
38fd 02 3a			dw .ENDMATHS            
38ff 04				db 3 + 1 
3900 .. 00			db "RND",0              
3904				endm 
# End of macro CWHEAD
3904			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3904			 
3904					if DEBUG_FORTH_WORDS_KEY 
3904						DMARK "RND" 
3904 f5				push af  
3905 3a 19 39			ld a, (.dmark)  
3908 32 bd fb			ld (debug_mark),a  
390b 3a 1a 39			ld a, (.dmark+1)  
390e 32 be fb			ld (debug_mark+1),a  
3911 3a 1b 39			ld a, (.dmark+2)  
3914 32 bf fb			ld (debug_mark+2),a  
3917 18 03			jr .pastdmark  
3919 ..			.dmark: db "RND"  
391c f1			.pastdmark: pop af  
391d			endm  
# End of macro DMARK
391d						CALLMONITOR 
391d cd 2d 17			call break_point_state  
3920				endm  
# End of macro CALLMONITOR
3920					endif 
3920					 
3920					FORTH_DSP_VALUEHL    ; upper range 
3920 cd b4 1e			call macro_dsp_valuehl 
3923				endm 
# End of macro FORTH_DSP_VALUEHL
3923			 
3923 22 42 fa				ld (LFSRSeed), hl	 
3926			 
3926					if DEBUG_FORTH_WORDS 
3926						DMARK "RN1" 
3926 f5				push af  
3927 3a 3b 39			ld a, (.dmark)  
392a 32 bd fb			ld (debug_mark),a  
392d 3a 3c 39			ld a, (.dmark+1)  
3930 32 be fb			ld (debug_mark+1),a  
3933 3a 3d 39			ld a, (.dmark+2)  
3936 32 bf fb			ld (debug_mark+2),a  
3939 18 03			jr .pastdmark  
393b ..			.dmark: db "RN1"  
393e f1			.pastdmark: pop af  
393f			endm  
# End of macro DMARK
393f						CALLMONITOR 
393f cd 2d 17			call break_point_state  
3942				endm  
# End of macro CALLMONITOR
3942					endif 
3942					FORTH_DSP_POP 
3942 cd 6c 1f			call macro_forth_dsp_pop 
3945				endm 
# End of macro FORTH_DSP_POP
3945			 
3945					FORTH_DSP_VALUEHL    ; low range 
3945 cd b4 1e			call macro_dsp_valuehl 
3948				endm 
# End of macro FORTH_DSP_VALUEHL
3948			 
3948					if DEBUG_FORTH_WORDS 
3948						DMARK "RN2" 
3948 f5				push af  
3949 3a 5d 39			ld a, (.dmark)  
394c 32 bd fb			ld (debug_mark),a  
394f 3a 5e 39			ld a, (.dmark+1)  
3952 32 be fb			ld (debug_mark+1),a  
3955 3a 5f 39			ld a, (.dmark+2)  
3958 32 bf fb			ld (debug_mark+2),a  
395b 18 03			jr .pastdmark  
395d ..			.dmark: db "RN2"  
3960 f1			.pastdmark: pop af  
3961			endm  
# End of macro DMARK
3961						CALLMONITOR 
3961 cd 2d 17			call break_point_state  
3964				endm  
# End of macro CALLMONITOR
3964					endif 
3964 22 44 fa				ld (LFSRSeed+2), hl 
3967			 
3967					FORTH_DSP_POP 
3967 cd 6c 1f			call macro_forth_dsp_pop 
396a				endm 
# End of macro FORTH_DSP_POP
396a			 
396a e5					push hl 
396b			 
396b e1			.inrange:	pop hl 
396c cd 41 0c				call prng16  
396f					if DEBUG_FORTH_WORDS 
396f						DMARK "RN3" 
396f f5				push af  
3970 3a 84 39			ld a, (.dmark)  
3973 32 bd fb			ld (debug_mark),a  
3976 3a 85 39			ld a, (.dmark+1)  
3979 32 be fb			ld (debug_mark+1),a  
397c 3a 86 39			ld a, (.dmark+2)  
397f 32 bf fb			ld (debug_mark+2),a  
3982 18 03			jr .pastdmark  
3984 ..			.dmark: db "RN3"  
3987 f1			.pastdmark: pop af  
3988			endm  
# End of macro DMARK
3988						CALLMONITOR 
3988 cd 2d 17			call break_point_state  
398b				endm  
# End of macro CALLMONITOR
398b					endif 
398b					 
398b					; if the range is 8bit knock out the high byte 
398b			 
398b ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
398f			 
398f 3e 00				ld a, 0 
3991 ba					cp d  
3992 20 1e				jr nz, .hirange 
3994 26 00				ld h, 0   ; knock it down to 8bit 
3996			 
3996					if DEBUG_FORTH_WORDS 
3996						DMARK "RNk" 
3996 f5				push af  
3997 3a ab 39			ld a, (.dmark)  
399a 32 bd fb			ld (debug_mark),a  
399d 3a ac 39			ld a, (.dmark+1)  
39a0 32 be fb			ld (debug_mark+1),a  
39a3 3a ad 39			ld a, (.dmark+2)  
39a6 32 bf fb			ld (debug_mark+2),a  
39a9 18 03			jr .pastdmark  
39ab ..			.dmark: db "RNk"  
39ae f1			.pastdmark: pop af  
39af			endm  
# End of macro DMARK
39af						CALLMONITOR 
39af cd 2d 17			call break_point_state  
39b2				endm  
# End of macro CALLMONITOR
39b2					endif 
39b2			.hirange:   
39b2 e5					push hl  
39b3 b7					or a  
39b4 ed 52		                sbc hl, de 
39b6			 
39b6					;call cmp16 
39b6			 
39b6 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39b8 e1					pop hl 
39b9 e5					push hl 
39ba			 
39ba					if DEBUG_FORTH_WORDS 
39ba						DMARK "RN4" 
39ba f5				push af  
39bb 3a cf 39			ld a, (.dmark)  
39be 32 bd fb			ld (debug_mark),a  
39c1 3a d0 39			ld a, (.dmark+1)  
39c4 32 be fb			ld (debug_mark+1),a  
39c7 3a d1 39			ld a, (.dmark+2)  
39ca 32 bf fb			ld (debug_mark+2),a  
39cd 18 03			jr .pastdmark  
39cf ..			.dmark: db "RN4"  
39d2 f1			.pastdmark: pop af  
39d3			endm  
# End of macro DMARK
39d3						CALLMONITOR 
39d3 cd 2d 17			call break_point_state  
39d6				endm  
# End of macro CALLMONITOR
39d6					endif 
39d6 ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
39da					;call cmp16 
39da				 
39da b7					or a  
39db ed 52		                sbc hl, de 
39dd 38 8c				jr c, .inrange 
39df			 
39df e1					pop hl 
39e0					 
39e0					if DEBUG_FORTH_WORDS 
39e0						DMARK "RNd" 
39e0 f5				push af  
39e1 3a f5 39			ld a, (.dmark)  
39e4 32 bd fb			ld (debug_mark),a  
39e7 3a f6 39			ld a, (.dmark+1)  
39ea 32 be fb			ld (debug_mark+1),a  
39ed 3a f7 39			ld a, (.dmark+2)  
39f0 32 bf fb			ld (debug_mark+2),a  
39f3 18 03			jr .pastdmark  
39f5 ..			.dmark: db "RNd"  
39f8 f1			.pastdmark: pop af  
39f9			endm  
# End of macro DMARK
39f9						CALLMONITOR 
39f9 cd 2d 17			call break_point_state  
39fc				endm  
# End of macro CALLMONITOR
39fc					endif 
39fc			 
39fc			 
39fc cd bd 1c				call forth_push_numhl 
39ff				       NEXTW 
39ff c3 26 20			jp macro_next 
3a02				endm 
# End of macro NEXTW
3a02			 
3a02			.ENDMATHS: 
3a02			 
3a02			; eof 
3a02			 
# End of file forth_words_maths.asm
3a02			include "forth_words_display.asm" 
3a02			 
3a02			; | ## Display Words 
3a02			 
3a02			.ATP: 
3a02				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a02 62				db WORD_SYS_CORE+78             
3a03 79 3a			dw .FB            
3a05 04				db 3 + 1 
3a06 .. 00			db "AT?",0              
3a0a				endm 
# End of macro CWHEAD
3a0a			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a0a					if DEBUG_FORTH_WORDS_KEY 
3a0a						DMARK "AT?" 
3a0a f5				push af  
3a0b 3a 1f 3a			ld a, (.dmark)  
3a0e 32 bd fb			ld (debug_mark),a  
3a11 3a 20 3a			ld a, (.dmark+1)  
3a14 32 be fb			ld (debug_mark+1),a  
3a17 3a 21 3a			ld a, (.dmark+2)  
3a1a 32 bf fb			ld (debug_mark+2),a  
3a1d 18 03			jr .pastdmark  
3a1f ..			.dmark: db "AT?"  
3a22 f1			.pastdmark: pop af  
3a23			endm  
# End of macro DMARK
3a23						CALLMONITOR 
3a23 cd 2d 17			call break_point_state  
3a26				endm  
# End of macro CALLMONITOR
3a26					endif 
3a26 3a cc f9				ld a, (f_cursor_ptr) 
3a29			 
3a29			if DEBUG_FORTH_WORDS 
3a29				DMARK "AT?" 
3a29 f5				push af  
3a2a 3a 3e 3a			ld a, (.dmark)  
3a2d 32 bd fb			ld (debug_mark),a  
3a30 3a 3f 3a			ld a, (.dmark+1)  
3a33 32 be fb			ld (debug_mark+1),a  
3a36 3a 40 3a			ld a, (.dmark+2)  
3a39 32 bf fb			ld (debug_mark+2),a  
3a3c 18 03			jr .pastdmark  
3a3e ..			.dmark: db "AT?"  
3a41 f1			.pastdmark: pop af  
3a42			endm  
# End of macro DMARK
3a42				CALLMONITOR 
3a42 cd 2d 17			call break_point_state  
3a45				endm  
# End of macro CALLMONITOR
3a45			endif	 
3a45					; count the number of rows 
3a45			 
3a45 06 00				ld b, 0 
3a47 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a48 d6 14				sub display_cols 
3a4a f2 50 3a				jp p, .atprunder 
3a4d 04					inc b 
3a4e 18 f7				jr .atpr 
3a50			.atprunder:	 
3a50			if DEBUG_FORTH_WORDS 
3a50				DMARK "A?2" 
3a50 f5				push af  
3a51 3a 65 3a			ld a, (.dmark)  
3a54 32 bd fb			ld (debug_mark),a  
3a57 3a 66 3a			ld a, (.dmark+1)  
3a5a 32 be fb			ld (debug_mark+1),a  
3a5d 3a 67 3a			ld a, (.dmark+2)  
3a60 32 bf fb			ld (debug_mark+2),a  
3a63 18 03			jr .pastdmark  
3a65 ..			.dmark: db "A?2"  
3a68 f1			.pastdmark: pop af  
3a69			endm  
# End of macro DMARK
3a69				CALLMONITOR 
3a69 cd 2d 17			call break_point_state  
3a6c				endm  
# End of macro CALLMONITOR
3a6c			endif	 
3a6c 26 00				ld h, 0 
3a6e 69					ld l, c 
3a6f cd bd 1c				call forth_push_numhl 
3a72 68					ld l, b  
3a73 cd bd 1c				call forth_push_numhl 
3a76			 
3a76			 
3a76				NEXTW 
3a76 c3 26 20			jp macro_next 
3a79				endm 
# End of macro NEXTW
3a79			 
3a79			.FB: 
3a79				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3a79 1b				db WORD_SYS_CORE+7             
3a7a c7 3a			dw .EMIT            
3a7c 03				db 2 + 1 
3a7d .. 00			db "FB",0              
3a80				endm 
# End of macro CWHEAD
3a80			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3a80			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3a80			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3a80			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3a80					if DEBUG_FORTH_WORDS_KEY 
3a80						DMARK "FB." 
3a80 f5				push af  
3a81 3a 95 3a			ld a, (.dmark)  
3a84 32 bd fb			ld (debug_mark),a  
3a87 3a 96 3a			ld a, (.dmark+1)  
3a8a 32 be fb			ld (debug_mark+1),a  
3a8d 3a 97 3a			ld a, (.dmark+2)  
3a90 32 bf fb			ld (debug_mark+2),a  
3a93 18 03			jr .pastdmark  
3a95 ..			.dmark: db "FB."  
3a98 f1			.pastdmark: pop af  
3a99			endm  
# End of macro DMARK
3a99						CALLMONITOR 
3a99 cd 2d 17			call break_point_state  
3a9c				endm  
# End of macro CALLMONITOR
3a9c					endif 
3a9c			 
3a9c					FORTH_DSP_VALUEHL 
3a9c cd b4 1e			call macro_dsp_valuehl 
3a9f				endm 
# End of macro FORTH_DSP_VALUEHL
3a9f			 
3a9f 7d					ld a, l 
3aa0 fe 01				cp 1 
3aa2 20 05				jr nz, .fbn1 
3aa4 21 02 fb				ld hl, display_fb1 
3aa7 18 15				jr .fbset 
3aa9 fe 02		.fbn1:		cp 2 
3aab 20 05				jr nz, .fbn2 
3aad 21 60 fa				ld hl, display_fb2 
3ab0 18 0c				jr .fbset 
3ab2 fe 03		.fbn2:		cp 3 
3ab4 20 05				jr nz, .fbn3 
3ab6 21 b1 fa				ld hl, display_fb3 
3ab9 18 03				jr .fbset 
3abb			.fbn3:		 ; if invalid number select first 
3abb 21 02 fb				ld hl, display_fb1 
3abe 22 5e fa		.fbset:		ld (display_fb_active), hl 
3ac1			 
3ac1					FORTH_DSP_POP 
3ac1 cd 6c 1f			call macro_forth_dsp_pop 
3ac4				endm 
# End of macro FORTH_DSP_POP
3ac4			 
3ac4					NEXTW 
3ac4 c3 26 20			jp macro_next 
3ac7				endm 
# End of macro NEXTW
3ac7			 
3ac7			 
3ac7			.EMIT: 
3ac7				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3ac7 1b				db WORD_SYS_CORE+7             
3ac8 18 3b			dw .DOTH            
3aca 05				db 4 + 1 
3acb .. 00			db "EMIT",0              
3ad0				endm 
# End of macro CWHEAD
3ad0			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3ad0					; get value off TOS and display it 
3ad0			 
3ad0					if DEBUG_FORTH_WORDS_KEY 
3ad0						DMARK "EMT" 
3ad0 f5				push af  
3ad1 3a e5 3a			ld a, (.dmark)  
3ad4 32 bd fb			ld (debug_mark),a  
3ad7 3a e6 3a			ld a, (.dmark+1)  
3ada 32 be fb			ld (debug_mark+1),a  
3add 3a e7 3a			ld a, (.dmark+2)  
3ae0 32 bf fb			ld (debug_mark+2),a  
3ae3 18 03			jr .pastdmark  
3ae5 ..			.dmark: db "EMT"  
3ae8 f1			.pastdmark: pop af  
3ae9			endm  
# End of macro DMARK
3ae9						CALLMONITOR 
3ae9 cd 2d 17			call break_point_state  
3aec				endm  
# End of macro CALLMONITOR
3aec					endif 
3aec			 
3aec					FORTH_DSP_VALUEHL 
3aec cd b4 1e			call macro_dsp_valuehl 
3aef				endm 
# End of macro FORTH_DSP_VALUEHL
3aef			 
3aef 7d					ld a,l 
3af0			 
3af0					; TODO write to display 
3af0			 
3af0 32 a1 f1				ld (os_input), a 
3af3 3e 00				ld a, 0 
3af5 32 a2 f1				ld (os_input+1), a 
3af8					 
3af8 3a cc f9				ld a, (f_cursor_ptr) 
3afb 11 a1 f1				ld de, os_input 
3afe cd f9 0a				call str_at_display 
3b01			 
3b01			 
3b01 3a aa f9				ld a,(cli_autodisplay) 
3b04 fe 00				cp 0 
3b06 28 03				jr z, .enoupdate 
3b08 cd 09 0b						call update_display 
3b0b					.enoupdate: 
3b0b			 
3b0b 3a cc f9				ld a, (f_cursor_ptr) 
3b0e 3c					inc a 
3b0f 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3b12			 
3b12			 
3b12					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b12 cd 6c 1f			call macro_forth_dsp_pop 
3b15				endm 
# End of macro FORTH_DSP_POP
3b15			  
3b15			 
3b15					NEXTW 
3b15 c3 26 20			jp macro_next 
3b18				endm 
# End of macro NEXTW
3b18			.DOTH: 
3b18				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b18 1c				db WORD_SYS_CORE+8             
3b19 48 3b			dw .DOTF            
3b1b 03				db 2 + 1 
3b1c .. 00			db ".-",0              
3b1f				endm 
# End of macro CWHEAD
3b1f			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b1f					; get value off TOS and display it 
3b1f					if DEBUG_FORTH_WORDS_KEY 
3b1f						DMARK "DTD" 
3b1f f5				push af  
3b20 3a 34 3b			ld a, (.dmark)  
3b23 32 bd fb			ld (debug_mark),a  
3b26 3a 35 3b			ld a, (.dmark+1)  
3b29 32 be fb			ld (debug_mark+1),a  
3b2c 3a 36 3b			ld a, (.dmark+2)  
3b2f 32 bf fb			ld (debug_mark+2),a  
3b32 18 03			jr .pastdmark  
3b34 ..			.dmark: db "DTD"  
3b37 f1			.pastdmark: pop af  
3b38			endm  
# End of macro DMARK
3b38						CALLMONITOR 
3b38 cd 2d 17			call break_point_state  
3b3b				endm  
# End of macro CALLMONITOR
3b3b					endif 
3b3b 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b3d 3e 00			ld a, 0 
3b3f 32 ab f9			ld (cli_mvdot), a 
3b42 c3 9f 3b			jp .dotgo 
3b45				NEXTW 
3b45 c3 26 20			jp macro_next 
3b48				endm 
# End of macro NEXTW
3b48			.DOTF: 
3b48				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b48 1c				db WORD_SYS_CORE+8             
3b49 76 3b			dw .DOT            
3b4b 03				db 2 + 1 
3b4c .. 00			db ".>",0              
3b4f				endm 
# End of macro CWHEAD
3b4f			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b4f					; get value off TOS and display it 
3b4f			        ; TODO BUG adds extra spaces 
3b4f			        ; TODO BUG handle numerics? 
3b4f					if DEBUG_FORTH_WORDS_KEY 
3b4f						DMARK "DTC" 
3b4f f5				push af  
3b50 3a 64 3b			ld a, (.dmark)  
3b53 32 bd fb			ld (debug_mark),a  
3b56 3a 65 3b			ld a, (.dmark+1)  
3b59 32 be fb			ld (debug_mark+1),a  
3b5c 3a 66 3b			ld a, (.dmark+2)  
3b5f 32 bf fb			ld (debug_mark+2),a  
3b62 18 03			jr .pastdmark  
3b64 ..			.dmark: db "DTC"  
3b67 f1			.pastdmark: pop af  
3b68			endm  
# End of macro DMARK
3b68						CALLMONITOR 
3b68 cd 2d 17			call break_point_state  
3b6b				endm  
# End of macro CALLMONITOR
3b6b					endif 
3b6b 3e 01			ld a, 1 
3b6d 32 ab f9			ld (cli_mvdot), a 
3b70 c3 9f 3b			jp .dotgo 
3b73				NEXTW 
3b73 c3 26 20			jp macro_next 
3b76				endm 
# End of macro NEXTW
3b76			 
3b76			.DOT: 
3b76				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3b76 1c				db WORD_SYS_CORE+8             
3b77 02 3c			dw .CLS            
3b79 02				db 1 + 1 
3b7a .. 00			db ".",0              
3b7c				endm 
# End of macro CWHEAD
3b7c			        ; | . ( u -- ) Display TOS | DONE 
3b7c					; get value off TOS and display it 
3b7c			 
3b7c					if DEBUG_FORTH_WORDS_KEY 
3b7c						DMARK "DOT" 
3b7c f5				push af  
3b7d 3a 91 3b			ld a, (.dmark)  
3b80 32 bd fb			ld (debug_mark),a  
3b83 3a 92 3b			ld a, (.dmark+1)  
3b86 32 be fb			ld (debug_mark+1),a  
3b89 3a 93 3b			ld a, (.dmark+2)  
3b8c 32 bf fb			ld (debug_mark+2),a  
3b8f 18 03			jr .pastdmark  
3b91 ..			.dmark: db "DOT"  
3b94 f1			.pastdmark: pop af  
3b95			endm  
# End of macro DMARK
3b95						CALLMONITOR 
3b95 cd 2d 17			call break_point_state  
3b98				endm  
# End of macro CALLMONITOR
3b98					endif 
3b98 3e 00			ld a, 0 
3b9a 32 ab f9			ld (cli_mvdot), a 
3b9d 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3b9f				 
3b9f			 
3b9f			.dotgo: 
3b9f			 
3b9f			; move up type to on stack for parserv5 
3b9f					FORTH_DSP 
3b9f cd 7a 1e			call macro_forth_dsp 
3ba2				endm 
# End of macro FORTH_DSP
3ba2				;FORTH_DSP_VALUE  
3ba2			 
3ba2			if DEBUG_FORTH_DOT 
3ba2				DMARK "DOT" 
3ba2				CALLMONITOR 
3ba2			endif	 
3ba2			;		.print: 
3ba2			 
3ba2 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3ba3 23				inc hl   ; position to the actual value 
3ba4 fe 01			cp DS_TYPE_STR 
3ba6 20 06			jr nz, .dotnum1  
3ba8			 
3ba8			; display string 
3ba8				FORTH_DSP_VALUE  
3ba8 cd 9d 1e			call macro_forth_dsp_value 
3bab				endm 
# End of macro FORTH_DSP_VALUE
3bab eb				ex de,hl 
3bac 18 11			jr .dotwrite 
3bae			 
3bae			.dotnum1: 
3bae fe 02			cp DS_TYPE_INUM 
3bb0 20 0c			jr nz, .dotflot 
3bb2			 
3bb2			 
3bb2			; display number 
3bb2			 
3bb2			;	push hl 
3bb2			;	call clear_display 
3bb2			;	pop hl 
3bb2			 
3bb2 5e				ld e, (hl) 
3bb3 23				inc hl 
3bb4 56				ld d, (hl) 
3bb5 21 a3 ef			ld hl, scratch 
3bb8			if DEBUG_FORTH_DOT 
3bb8				DMARK "DT1" 
3bb8				CALLMONITOR 
3bb8			endif	 
3bb8			 
3bb8 cd 27 11			call uitoa_16 
3bbb eb				ex de,hl 
3bbc			 
3bbc			if DEBUG_FORTH_DOT 
3bbc				DMARK "DT2" 
3bbc				CALLMONITOR 
3bbc			endif	 
3bbc			 
3bbc			;	ld de, os_word_scratch 
3bbc 18 01			jr .dotwrite 
3bbe			 
3bbe 00			.dotflot:   nop 
3bbf			; TODO print floating point number 
3bbf			 
3bbf			.dotwrite:		 
3bbf			 
3bbf					; if c is set then set all '-' to spaces 
3bbf					; need to also take into account .>  
3bbf			 
3bbf 3e 01				ld a, 1 
3bc1 b9					cp c 
3bc2 20 13				jr nz, .nodashswap 
3bc4			 
3bc4					; DE has the string to write, working with HL 
3bc4			 
3bc4 06 ff				ld b, 255 
3bc6 d5					push de 
3bc7 e1					pop hl 
3bc8			 
3bc8			if DEBUG_FORTH_DOT 
3bc8				DMARK "DT-" 
3bc8				CALLMONITOR 
3bc8			endif	 
3bc8 7e			.dashscan:	ld a, (hl) 
3bc9 fe 00				cp 0 
3bcb 28 0a				jr z, .nodashswap 
3bcd fe 2d				cp '-' 
3bcf 20 03				jr nz, .dashskip 
3bd1 3e 20				ld a, ' ' 
3bd3 77					ld (hl), a 
3bd4 23			.dashskip:	inc hl 
3bd5			if DEBUG_FORTH_DOT 
3bd5				DMARK "D-2" 
3bd5				CALLMONITOR 
3bd5			endif	 
3bd5 10 f1				djnz .dashscan 
3bd7			 
3bd7			if DEBUG_FORTH_DOT 
3bd7				DMARK "D-1" 
3bd7				CALLMONITOR 
3bd7			endif	 
3bd7			 
3bd7			.nodashswap: 
3bd7			 
3bd7 e5					push hl   ; save string start in case we need to advance print 
3bd8			 
3bd8 3a cc f9				ld a, (f_cursor_ptr) 
3bdb cd f9 0a				call str_at_display 
3bde 3a aa f9				ld a,(cli_autodisplay) 
3be1 fe 00				cp 0 
3be3 28 03				jr z, .noupdate 
3be5 cd 09 0b						call update_display 
3be8					.noupdate: 
3be8			 
3be8			 
3be8					; see if we need to advance the print position 
3be8			 
3be8 e1					pop hl   ; get back string 
3be9			 
3be9 3a ab f9				ld a, (cli_mvdot) 
3bec			if DEBUG_FORTH_DOT 
3bec					ld e,a 
3bec				DMARK "D>1" 
3bec				CALLMONITOR 
3bec			endif	 
3bec fe 00				cp 0 
3bee 28 0c				jr z, .noadv 
3bf0					; yes, lets advance the print position 
3bf0 3e 00				ld a, 0 
3bf2 cd 83 11				call strlent 
3bf5 3a cc f9				ld a, (f_cursor_ptr) 
3bf8 85					add a,l 
3bf9					;call addatohl 
3bf9					;ld a, l 
3bf9 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3bfc			 
3bfc			if DEBUG_FORTH_DOT 
3bfc				DMARK "D->" 
3bfc				CALLMONITOR 
3bfc			endif	 
3bfc			 
3bfc			.noadv:	 
3bfc			 
3bfc					if DEBUG_FORTH_DOT_WAIT 
3bfc							call next_page_prompt 
3bfc					endif	 
3bfc			; TODO this pop off the stack causes a crash. i dont know why 
3bfc			 
3bfc			 
3bfc			if DEBUG_FORTH_DOT 
3bfc				DMARK "DTh" 
3bfc				CALLMONITOR 
3bfc			endif	 
3bfc			 
3bfc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bfc cd 6c 1f			call macro_forth_dsp_pop 
3bff				endm 
# End of macro FORTH_DSP_POP
3bff			 
3bff			if DEBUG_FORTH_DOT 
3bff				DMARK "DTi" 
3bff				CALLMONITOR 
3bff			endif	 
3bff			 
3bff			 
3bff					NEXTW 
3bff c3 26 20			jp macro_next 
3c02				endm 
# End of macro NEXTW
3c02			 
3c02			.CLS: 
3c02				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c02 35				db WORD_SYS_CORE+33             
3c03 2f 3c			dw .DRAW            
3c05 04				db 3 + 1 
3c06 .. 00			db "CLS",0              
3c0a				endm 
# End of macro CWHEAD
3c0a			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c0a					if DEBUG_FORTH_WORDS_KEY 
3c0a						DMARK "CLS" 
3c0a f5				push af  
3c0b 3a 1f 3c			ld a, (.dmark)  
3c0e 32 bd fb			ld (debug_mark),a  
3c11 3a 20 3c			ld a, (.dmark+1)  
3c14 32 be fb			ld (debug_mark+1),a  
3c17 3a 21 3c			ld a, (.dmark+2)  
3c1a 32 bf fb			ld (debug_mark+2),a  
3c1d 18 03			jr .pastdmark  
3c1f ..			.dmark: db "CLS"  
3c22 f1			.pastdmark: pop af  
3c23			endm  
# End of macro DMARK
3c23						CALLMONITOR 
3c23 cd 2d 17			call break_point_state  
3c26				endm  
# End of macro CALLMONITOR
3c26					endif 
3c26 cd e6 0a				call clear_display 
3c29 c3 3d 3d				jp .home		; and home cursor 
3c2c					NEXTW 
3c2c c3 26 20			jp macro_next 
3c2f				endm 
# End of macro NEXTW
3c2f			 
3c2f			.DRAW: 
3c2f				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c2f 36				db WORD_SYS_CORE+34             
3c30 5a 3c			dw .DUMP            
3c32 05				db 4 + 1 
3c33 .. 00			db "DRAW",0              
3c38				endm 
# End of macro CWHEAD
3c38			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c38					if DEBUG_FORTH_WORDS_KEY 
3c38						DMARK "DRW" 
3c38 f5				push af  
3c39 3a 4d 3c			ld a, (.dmark)  
3c3c 32 bd fb			ld (debug_mark),a  
3c3f 3a 4e 3c			ld a, (.dmark+1)  
3c42 32 be fb			ld (debug_mark+1),a  
3c45 3a 4f 3c			ld a, (.dmark+2)  
3c48 32 bf fb			ld (debug_mark+2),a  
3c4b 18 03			jr .pastdmark  
3c4d ..			.dmark: db "DRW"  
3c50 f1			.pastdmark: pop af  
3c51			endm  
# End of macro DMARK
3c51						CALLMONITOR 
3c51 cd 2d 17			call break_point_state  
3c54				endm  
# End of macro CALLMONITOR
3c54					endif 
3c54 cd 09 0b				call update_display 
3c57					NEXTW 
3c57 c3 26 20			jp macro_next 
3c5a				endm 
# End of macro NEXTW
3c5a			 
3c5a			.DUMP: 
3c5a				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3c5a 37				db WORD_SYS_CORE+35             
3c5b 92 3c			dw .CDUMP            
3c5d 05				db 4 + 1 
3c5e .. 00			db "DUMP",0              
3c63				endm 
# End of macro CWHEAD
3c63			; | DUMP ( x -- ) With address x display dump   | DONE 
3c63			; TODO pop address to use off of the stack 
3c63					if DEBUG_FORTH_WORDS_KEY 
3c63						DMARK "DUM" 
3c63 f5				push af  
3c64 3a 78 3c			ld a, (.dmark)  
3c67 32 bd fb			ld (debug_mark),a  
3c6a 3a 79 3c			ld a, (.dmark+1)  
3c6d 32 be fb			ld (debug_mark+1),a  
3c70 3a 7a 3c			ld a, (.dmark+2)  
3c73 32 bf fb			ld (debug_mark+2),a  
3c76 18 03			jr .pastdmark  
3c78 ..			.dmark: db "DUM"  
3c7b f1			.pastdmark: pop af  
3c7c			endm  
# End of macro DMARK
3c7c						CALLMONITOR 
3c7c cd 2d 17			call break_point_state  
3c7f				endm  
# End of macro CALLMONITOR
3c7f					endif 
3c7f cd e6 0a				call clear_display 
3c82			 
3c82					; get address 
3c82			 
3c82					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c82 cd b4 1e			call macro_dsp_valuehl 
3c85				endm 
# End of macro FORTH_DSP_VALUEHL
3c85				 
3c85					; save it for cdump 
3c85			 
3c85 22 c6 f2				ld (os_cur_ptr),hl 
3c88			 
3c88					; destroy value TOS 
3c88			 
3c88					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c88 cd 6c 1f			call macro_forth_dsp_pop 
3c8b				endm 
# End of macro FORTH_DSP_POP
3c8b			 
3c8b cd 3d 1b				call dumpcont	; skip old style of param parsing	 
3c8e c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3c8f					NEXTW 
3c8f c3 26 20			jp macro_next 
3c92				endm 
# End of macro NEXTW
3c92			.CDUMP: 
3c92				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3c92 38				db WORD_SYS_CORE+36             
3c93 c2 3c			dw .DAT            
3c95 06				db 5 + 1 
3c96 .. 00			db "CDUMP",0              
3c9c				endm 
# End of macro CWHEAD
3c9c			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3c9c					if DEBUG_FORTH_WORDS_KEY 
3c9c						DMARK "CDP" 
3c9c f5				push af  
3c9d 3a b1 3c			ld a, (.dmark)  
3ca0 32 bd fb			ld (debug_mark),a  
3ca3 3a b2 3c			ld a, (.dmark+1)  
3ca6 32 be fb			ld (debug_mark+1),a  
3ca9 3a b3 3c			ld a, (.dmark+2)  
3cac 32 bf fb			ld (debug_mark+2),a  
3caf 18 03			jr .pastdmark  
3cb1 ..			.dmark: db "CDP"  
3cb4 f1			.pastdmark: pop af  
3cb5			endm  
# End of macro DMARK
3cb5						CALLMONITOR 
3cb5 cd 2d 17			call break_point_state  
3cb8				endm  
# End of macro CALLMONITOR
3cb8					endif 
3cb8 cd e6 0a				call clear_display 
3cbb cd 3d 1b				call dumpcont	 
3cbe c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3cbf					NEXTW 
3cbf c3 26 20			jp macro_next 
3cc2				endm 
# End of macro NEXTW
3cc2			 
3cc2			 
3cc2			 
3cc2			 
3cc2			.DAT: 
3cc2				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3cc2 3d				db WORD_SYS_CORE+41             
3cc3 18 3d			dw .HOME            
3cc5 03				db 2 + 1 
3cc6 .. 00			db "AT",0              
3cc9				endm 
# End of macro CWHEAD
3cc9			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3cc9					if DEBUG_FORTH_WORDS_KEY 
3cc9						DMARK "AT." 
3cc9 f5				push af  
3cca 3a de 3c			ld a, (.dmark)  
3ccd 32 bd fb			ld (debug_mark),a  
3cd0 3a df 3c			ld a, (.dmark+1)  
3cd3 32 be fb			ld (debug_mark+1),a  
3cd6 3a e0 3c			ld a, (.dmark+2)  
3cd9 32 bf fb			ld (debug_mark+2),a  
3cdc 18 03			jr .pastdmark  
3cde ..			.dmark: db "AT."  
3ce1 f1			.pastdmark: pop af  
3ce2			endm  
# End of macro DMARK
3ce2						CALLMONITOR 
3ce2 cd 2d 17			call break_point_state  
3ce5				endm  
# End of macro CALLMONITOR
3ce5					endif 
3ce5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ce5 cd b4 1e			call macro_dsp_valuehl 
3ce8				endm 
# End of macro FORTH_DSP_VALUEHL
3ce8			 
3ce8			 
3ce8					; TODO save cursor row 
3ce8 7d					ld a,l 
3ce9 fe 02				cp 2 
3ceb 20 04				jr nz, .crow3 
3ced 3e 14				ld a, display_row_2 
3cef 18 12				jr .ccol1 
3cf1 fe 03		.crow3:		cp 3 
3cf3 20 04				jr nz, .crow4 
3cf5 3e 28				ld a, display_row_3 
3cf7 18 0a				jr .ccol1 
3cf9 fe 04		.crow4:		cp 4 
3cfb 20 04				jr nz, .crow1 
3cfd 3e 3c				ld a, display_row_4 
3cff 18 02				jr .ccol1 
3d01 3e 00		.crow1:		ld a,display_row_1 
3d03 f5			.ccol1:		push af			; got row offset 
3d04 6f					ld l,a 
3d05 26 00				ld h,0 
3d07					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d07 cd 6c 1f			call macro_forth_dsp_pop 
3d0a				endm 
# End of macro FORTH_DSP_POP
3d0a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d0a cd b4 1e			call macro_dsp_valuehl 
3d0d				endm 
# End of macro FORTH_DSP_VALUEHL
3d0d					; TODO save cursor col 
3d0d f1					pop af 
3d0e 85					add l		; add col offset 
3d0f 32 cc f9				ld (f_cursor_ptr), a 
3d12					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d12 cd 6c 1f			call macro_forth_dsp_pop 
3d15				endm 
# End of macro FORTH_DSP_POP
3d15			 
3d15					; calculate  
3d15			 
3d15					NEXTW 
3d15 c3 26 20			jp macro_next 
3d18				endm 
# End of macro NEXTW
3d18			 
3d18			 
3d18			.HOME: 
3d18				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d18 41				db WORD_SYS_CORE+45             
3d19 45 3d			dw .SPACE            
3d1b 05				db 4 + 1 
3d1c .. 00			db "HOME",0              
3d21				endm 
# End of macro CWHEAD
3d21			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d21					if DEBUG_FORTH_WORDS_KEY 
3d21						DMARK "HOM" 
3d21 f5				push af  
3d22 3a 36 3d			ld a, (.dmark)  
3d25 32 bd fb			ld (debug_mark),a  
3d28 3a 37 3d			ld a, (.dmark+1)  
3d2b 32 be fb			ld (debug_mark+1),a  
3d2e 3a 38 3d			ld a, (.dmark+2)  
3d31 32 bf fb			ld (debug_mark+2),a  
3d34 18 03			jr .pastdmark  
3d36 ..			.dmark: db "HOM"  
3d39 f1			.pastdmark: pop af  
3d3a			endm  
# End of macro DMARK
3d3a						CALLMONITOR 
3d3a cd 2d 17			call break_point_state  
3d3d				endm  
# End of macro CALLMONITOR
3d3d					endif 
3d3d 3e 00		.home:		ld a, 0		; and home cursor 
3d3f 32 cc f9				ld (f_cursor_ptr), a 
3d42					NEXTW 
3d42 c3 26 20			jp macro_next 
3d45				endm 
# End of macro NEXTW
3d45			 
3d45			 
3d45			.SPACE: 
3d45				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d45 46				db WORD_SYS_CORE+50             
3d46 73 3d			dw .SPACES            
3d48 03				db 2 + 1 
3d49 .. 00			db "BL",0              
3d4c				endm 
# End of macro CWHEAD
3d4c			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3d4c					if DEBUG_FORTH_WORDS_KEY 
3d4c						DMARK "BL." 
3d4c f5				push af  
3d4d 3a 61 3d			ld a, (.dmark)  
3d50 32 bd fb			ld (debug_mark),a  
3d53 3a 62 3d			ld a, (.dmark+1)  
3d56 32 be fb			ld (debug_mark+1),a  
3d59 3a 63 3d			ld a, (.dmark+2)  
3d5c 32 bf fb			ld (debug_mark+2),a  
3d5f 18 03			jr .pastdmark  
3d61 ..			.dmark: db "BL."  
3d64 f1			.pastdmark: pop af  
3d65			endm  
# End of macro DMARK
3d65						CALLMONITOR 
3d65 cd 2d 17			call break_point_state  
3d68				endm  
# End of macro CALLMONITOR
3d68					endif 
3d68 21 71 3d				ld hl, .blstr 
3d6b cd 2b 1d				call forth_push_str 
3d6e					 
3d6e				       NEXTW 
3d6e c3 26 20			jp macro_next 
3d71				endm 
# End of macro NEXTW
3d71			 
3d71 .. 00		.blstr: db " ", 0 
3d73			 
3d73			.SPACES: 
3d73				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3d73 47				db WORD_SYS_CORE+51             
3d74 0e 3e			dw .SCROLL            
3d76 07				db 6 + 1 
3d77 .. 00			db "SPACES",0              
3d7e				endm 
# End of macro CWHEAD
3d7e			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3d7e					if DEBUG_FORTH_WORDS_KEY 
3d7e						DMARK "SPS" 
3d7e f5				push af  
3d7f 3a 93 3d			ld a, (.dmark)  
3d82 32 bd fb			ld (debug_mark),a  
3d85 3a 94 3d			ld a, (.dmark+1)  
3d88 32 be fb			ld (debug_mark+1),a  
3d8b 3a 95 3d			ld a, (.dmark+2)  
3d8e 32 bf fb			ld (debug_mark+2),a  
3d91 18 03			jr .pastdmark  
3d93 ..			.dmark: db "SPS"  
3d96 f1			.pastdmark: pop af  
3d97			endm  
# End of macro DMARK
3d97						CALLMONITOR 
3d97 cd 2d 17			call break_point_state  
3d9a				endm  
# End of macro CALLMONITOR
3d9a					endif 
3d9a			 
3d9a			 
3d9a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d9a cd b4 1e			call macro_dsp_valuehl 
3d9d				endm 
# End of macro FORTH_DSP_VALUEHL
3d9d			 
3d9d			;		push hl    ; u 
3d9d					if DEBUG_FORTH_WORDS 
3d9d						DMARK "SPA" 
3d9d f5				push af  
3d9e 3a b2 3d			ld a, (.dmark)  
3da1 32 bd fb			ld (debug_mark),a  
3da4 3a b3 3d			ld a, (.dmark+1)  
3da7 32 be fb			ld (debug_mark+1),a  
3daa 3a b4 3d			ld a, (.dmark+2)  
3dad 32 bf fb			ld (debug_mark+2),a  
3db0 18 03			jr .pastdmark  
3db2 ..			.dmark: db "SPA"  
3db5 f1			.pastdmark: pop af  
3db6			endm  
# End of macro DMARK
3db6						CALLMONITOR 
3db6 cd 2d 17			call break_point_state  
3db9				endm  
# End of macro CALLMONITOR
3db9					endif 
3db9			 
3db9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3db9 cd 6c 1f			call macro_forth_dsp_pop 
3dbc				endm 
# End of macro FORTH_DSP_POP
3dbc			;		pop hl 
3dbc 4d					ld c, l 
3dbd 06 00				ld b, 0 
3dbf 21 a3 ef				ld hl, scratch  
3dc2			 
3dc2					if DEBUG_FORTH_WORDS 
3dc2						DMARK "SP2" 
3dc2 f5				push af  
3dc3 3a d7 3d			ld a, (.dmark)  
3dc6 32 bd fb			ld (debug_mark),a  
3dc9 3a d8 3d			ld a, (.dmark+1)  
3dcc 32 be fb			ld (debug_mark+1),a  
3dcf 3a d9 3d			ld a, (.dmark+2)  
3dd2 32 bf fb			ld (debug_mark+2),a  
3dd5 18 03			jr .pastdmark  
3dd7 ..			.dmark: db "SP2"  
3dda f1			.pastdmark: pop af  
3ddb			endm  
# End of macro DMARK
3ddb						CALLMONITOR 
3ddb cd 2d 17			call break_point_state  
3dde				endm  
# End of macro CALLMONITOR
3dde					endif 
3dde 3e 20				ld a, ' ' 
3de0 c5			.spaces1:	push bc 
3de1 77					ld (hl),a 
3de2 23					inc hl 
3de3 c1					pop bc 
3de4 10 fa				djnz .spaces1 
3de6 3e 00				ld a,0 
3de8 77					ld (hl),a 
3de9 21 a3 ef				ld hl, scratch 
3dec					if DEBUG_FORTH_WORDS 
3dec						DMARK "SP3" 
3dec f5				push af  
3ded 3a 01 3e			ld a, (.dmark)  
3df0 32 bd fb			ld (debug_mark),a  
3df3 3a 02 3e			ld a, (.dmark+1)  
3df6 32 be fb			ld (debug_mark+1),a  
3df9 3a 03 3e			ld a, (.dmark+2)  
3dfc 32 bf fb			ld (debug_mark+2),a  
3dff 18 03			jr .pastdmark  
3e01 ..			.dmark: db "SP3"  
3e04 f1			.pastdmark: pop af  
3e05			endm  
# End of macro DMARK
3e05						CALLMONITOR 
3e05 cd 2d 17			call break_point_state  
3e08				endm  
# End of macro CALLMONITOR
3e08					endif 
3e08 cd 26 1e				call forth_apush 
3e0b			 
3e0b				       NEXTW 
3e0b c3 26 20			jp macro_next 
3e0e				endm 
# End of macro NEXTW
3e0e			 
3e0e			 
3e0e			 
3e0e			.SCROLL: 
3e0e				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e0e 53				db WORD_SYS_CORE+63             
3e0f 3b 3e			dw .SCROLLD            
3e11 07				db 6 + 1 
3e12 .. 00			db "SCROLL",0              
3e19				endm 
# End of macro CWHEAD
3e19			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e19					if DEBUG_FORTH_WORDS_KEY 
3e19						DMARK "SCR" 
3e19 f5				push af  
3e1a 3a 2e 3e			ld a, (.dmark)  
3e1d 32 bd fb			ld (debug_mark),a  
3e20 3a 2f 3e			ld a, (.dmark+1)  
3e23 32 be fb			ld (debug_mark+1),a  
3e26 3a 30 3e			ld a, (.dmark+2)  
3e29 32 bf fb			ld (debug_mark+2),a  
3e2c 18 03			jr .pastdmark  
3e2e ..			.dmark: db "SCR"  
3e31 f1			.pastdmark: pop af  
3e32			endm  
# End of macro DMARK
3e32						CALLMONITOR 
3e32 cd 2d 17			call break_point_state  
3e35				endm  
# End of macro CALLMONITOR
3e35					endif 
3e35			 
3e35 cd a8 0a			call scroll_up 
3e38			;	call update_display 
3e38			 
3e38					NEXTW 
3e38 c3 26 20			jp macro_next 
3e3b				endm 
# End of macro NEXTW
3e3b			 
3e3b			 
3e3b			 
3e3b			;		; get dir 
3e3b			; 
3e3b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e3b			; 
3e3b			;		push hl 
3e3b			; 
3e3b			;		; destroy value TOS 
3e3b			; 
3e3b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e3b			; 
3e3b			;		; get count 
3e3b			; 
3e3b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e3b			; 
3e3b			;		push hl 
3e3b			; 
3e3b			;		; destroy value TOS 
3e3b			; 
3e3b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e3b			; 
3e3b			;		; one value on hl get other one back 
3e3b			; 
3e3b			;		pop bc    ; count 
3e3b			; 
3e3b			;		pop de   ; dir 
3e3b			; 
3e3b			; 
3e3b			;		ld b, c 
3e3b			; 
3e3b			;.scrolldir:     push bc 
3e3b			;		push de 
3e3b			; 
3e3b			;		ld a, 0 
3e3b			;		cp e 
3e3b			;		jr z, .scrollup  
3e3b			;		call scroll_down 
3e3b			;		jr .scrollnext 
3e3b			;.scrollup:	call scroll_up 
3e3b			; 
3e3b			;		 
3e3b			;.scrollnext: 
3e3b			;		pop de 
3e3b			;		pop bc 
3e3b			;		djnz .scrolldir 
3e3b			; 
3e3b			; 
3e3b			; 
3e3b			; 
3e3b			; 
3e3b			;		NEXTW 
3e3b			 
3e3b			.SCROLLD: 
3e3b				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e3b 53				db WORD_SYS_CORE+63             
3e3c 69 3e			dw .ATQ            
3e3e 08				db 7 + 1 
3e3f .. 00			db "SCROLLD",0              
3e47				endm 
# End of macro CWHEAD
3e47			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3e47					if DEBUG_FORTH_WORDS_KEY 
3e47						DMARK "SCD" 
3e47 f5				push af  
3e48 3a 5c 3e			ld a, (.dmark)  
3e4b 32 bd fb			ld (debug_mark),a  
3e4e 3a 5d 3e			ld a, (.dmark+1)  
3e51 32 be fb			ld (debug_mark+1),a  
3e54 3a 5e 3e			ld a, (.dmark+2)  
3e57 32 bf fb			ld (debug_mark+2),a  
3e5a 18 03			jr .pastdmark  
3e5c ..			.dmark: db "SCD"  
3e5f f1			.pastdmark: pop af  
3e60			endm  
# End of macro DMARK
3e60						CALLMONITOR 
3e60 cd 2d 17			call break_point_state  
3e63				endm  
# End of macro CALLMONITOR
3e63					endif 
3e63			 
3e63 cd cc 0a			call scroll_down 
3e66			;	call update_display 
3e66			 
3e66					NEXTW 
3e66 c3 26 20			jp macro_next 
3e69				endm 
# End of macro NEXTW
3e69			 
3e69			 
3e69			.ATQ: 
3e69				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3e69 62				db WORD_SYS_CORE+78             
3e6a c7 3e			dw .AUTODSP            
3e6c 04				db 3 + 1 
3e6d .. 00			db "AT@",0              
3e71				endm 
# End of macro CWHEAD
3e71			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3e71					if DEBUG_FORTH_WORDS_KEY 
3e71						DMARK "ATA" 
3e71 f5				push af  
3e72 3a 86 3e			ld a, (.dmark)  
3e75 32 bd fb			ld (debug_mark),a  
3e78 3a 87 3e			ld a, (.dmark+1)  
3e7b 32 be fb			ld (debug_mark+1),a  
3e7e 3a 88 3e			ld a, (.dmark+2)  
3e81 32 bf fb			ld (debug_mark+2),a  
3e84 18 03			jr .pastdmark  
3e86 ..			.dmark: db "ATA"  
3e89 f1			.pastdmark: pop af  
3e8a			endm  
# End of macro DMARK
3e8a						CALLMONITOR 
3e8a cd 2d 17			call break_point_state  
3e8d				endm  
# End of macro CALLMONITOR
3e8d					endif 
3e8d			 
3e8d			 
3e8d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e8d cd b4 1e			call macro_dsp_valuehl 
3e90				endm 
# End of macro FORTH_DSP_VALUEHL
3e90			 
3e90					; TODO save cursor row 
3e90 7d					ld a,l 
3e91 fe 02				cp 2 
3e93 20 04				jr nz, .crow3aq 
3e95 3e 14				ld a, display_row_2 
3e97 18 12				jr .ccol1aq 
3e99 fe 03		.crow3aq:		cp 3 
3e9b 20 04				jr nz, .crow4aq 
3e9d 3e 28				ld a, display_row_3 
3e9f 18 0a				jr .ccol1aq 
3ea1 fe 04		.crow4aq:		cp 4 
3ea3 20 04				jr nz, .crow1aq 
3ea5 3e 3c				ld a, display_row_4 
3ea7 18 02				jr .ccol1aq 
3ea9 3e 00		.crow1aq:		ld a,display_row_1 
3eab f5			.ccol1aq:		push af			; got row offset 
3eac 6f					ld l,a 
3ead 26 00				ld h,0 
3eaf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eaf cd 6c 1f			call macro_forth_dsp_pop 
3eb2				endm 
# End of macro FORTH_DSP_POP
3eb2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eb2 cd b4 1e			call macro_dsp_valuehl 
3eb5				endm 
# End of macro FORTH_DSP_VALUEHL
3eb5					; TODO save cursor col 
3eb5 f1					pop af 
3eb6 85					add l		; add col offset 
3eb7			 
3eb7					; add current frame buffer address 
3eb7 2a 5e fa				ld hl, (display_fb_active) 
3eba cd 1a 0d				call addatohl 
3ebd			 
3ebd			 
3ebd			 
3ebd			 
3ebd					; get char frame buffer location offset in hl 
3ebd			 
3ebd 7e					ld a,(hl) 
3ebe 26 00				ld h, 0 
3ec0 6f					ld l, a 
3ec1			 
3ec1 cd bd 1c				call forth_push_numhl 
3ec4			 
3ec4			 
3ec4					NEXTW 
3ec4 c3 26 20			jp macro_next 
3ec7				endm 
# End of macro NEXTW
3ec7			 
3ec7			.AUTODSP: 
3ec7				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3ec7 63				db WORD_SYS_CORE+79             
3ec8 dd 3e			dw .MENU            
3eca 05				db 4 + 1 
3ecb .. 00			db "ADSP",0              
3ed0				endm 
# End of macro CWHEAD
3ed0			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3ed0			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3ed0			 
3ed0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ed0 cd b4 1e			call macro_dsp_valuehl 
3ed3				endm 
# End of macro FORTH_DSP_VALUEHL
3ed3			 
3ed3			;		push hl 
3ed3			 
3ed3					; destroy value TOS 
3ed3			 
3ed3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ed3 cd 6c 1f			call macro_forth_dsp_pop 
3ed6				endm 
# End of macro FORTH_DSP_POP
3ed6			 
3ed6			;		pop hl 
3ed6			 
3ed6 7d					ld a,l 
3ed7 32 aa f9				ld (cli_autodisplay), a 
3eda				       NEXTW 
3eda c3 26 20			jp macro_next 
3edd				endm 
# End of macro NEXTW
3edd			 
3edd			.MENU: 
3edd				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3edd 70				db WORD_SYS_CORE+92             
3ede 86 3f			dw .ENDDISPLAY            
3ee0 05				db 4 + 1 
3ee1 .. 00			db "MENU",0              
3ee6				endm 
# End of macro CWHEAD
3ee6			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3ee6			 
3ee6			;		; get number of items on the stack 
3ee6			; 
3ee6				 
3ee6					FORTH_DSP_VALUEHL 
3ee6 cd b4 1e			call macro_dsp_valuehl 
3ee9				endm 
# End of macro FORTH_DSP_VALUEHL
3ee9				 
3ee9					if DEBUG_FORTH_WORDS_KEY 
3ee9						DMARK "MNU" 
3ee9 f5				push af  
3eea 3a fe 3e			ld a, (.dmark)  
3eed 32 bd fb			ld (debug_mark),a  
3ef0 3a ff 3e			ld a, (.dmark+1)  
3ef3 32 be fb			ld (debug_mark+1),a  
3ef6 3a 00 3f			ld a, (.dmark+2)  
3ef9 32 bf fb			ld (debug_mark+2),a  
3efc 18 03			jr .pastdmark  
3efe ..			.dmark: db "MNU"  
3f01 f1			.pastdmark: pop af  
3f02			endm  
# End of macro DMARK
3f02						CALLMONITOR 
3f02 cd 2d 17			call break_point_state  
3f05				endm  
# End of macro CALLMONITOR
3f05					endif 
3f05			 
3f05 45					ld b, l	 
3f06 05					dec b 
3f07			 
3f07					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f07 cd 6c 1f			call macro_forth_dsp_pop 
3f0a				endm 
# End of macro FORTH_DSP_POP
3f0a			 
3f0a			 
3f0a					; go directly through the stack to pluck out the string pointers and build an array 
3f0a			 
3f0a			;		FORTH_DSP 
3f0a			 
3f0a					; hl contains top most stack item 
3f0a				 
3f0a 11 a3 ef				ld de, scratch 
3f0d			 
3f0d			.mbuild: 
3f0d			 
3f0d					FORTH_DSP_VALUEHL 
3f0d cd b4 1e			call macro_dsp_valuehl 
3f10				endm 
# End of macro FORTH_DSP_VALUEHL
3f10			 
3f10					if DEBUG_FORTH_WORDS 
3f10						DMARK "MN3" 
3f10 f5				push af  
3f11 3a 25 3f			ld a, (.dmark)  
3f14 32 bd fb			ld (debug_mark),a  
3f17 3a 26 3f			ld a, (.dmark+1)  
3f1a 32 be fb			ld (debug_mark+1),a  
3f1d 3a 27 3f			ld a, (.dmark+2)  
3f20 32 bf fb			ld (debug_mark+2),a  
3f23 18 03			jr .pastdmark  
3f25 ..			.dmark: db "MN3"  
3f28 f1			.pastdmark: pop af  
3f29			endm  
# End of macro DMARK
3f29						CALLMONITOR 
3f29 cd 2d 17			call break_point_state  
3f2c				endm  
# End of macro CALLMONITOR
3f2c					endif 
3f2c eb					ex de, hl 
3f2d 73					ld (hl), e 
3f2e 23					inc hl 
3f2f 72					ld (hl), d 
3f30 23					inc hl 
3f31 eb					ex de, hl 
3f32			 
3f32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f32 cd 6c 1f			call macro_forth_dsp_pop 
3f35				endm 
# End of macro FORTH_DSP_POP
3f35			 
3f35 10 d6				djnz .mbuild 
3f37			 
3f37					; done add term 
3f37			 
3f37 eb					ex de, hl 
3f38 36 00				ld (hl), 0 
3f3a 23					inc hl 
3f3b 36 00				ld (hl), 0 
3f3d			 
3f3d				 
3f3d					 
3f3d 21 a3 ef				ld hl, scratch 
3f40			 
3f40					if DEBUG_FORTH_WORDS 
3f40						DMARK "MNx" 
3f40 f5				push af  
3f41 3a 55 3f			ld a, (.dmark)  
3f44 32 bd fb			ld (debug_mark),a  
3f47 3a 56 3f			ld a, (.dmark+1)  
3f4a 32 be fb			ld (debug_mark+1),a  
3f4d 3a 57 3f			ld a, (.dmark+2)  
3f50 32 bf fb			ld (debug_mark+2),a  
3f53 18 03			jr .pastdmark  
3f55 ..			.dmark: db "MNx"  
3f58 f1			.pastdmark: pop af  
3f59			endm  
# End of macro DMARK
3f59						CALLMONITOR 
3f59 cd 2d 17			call break_point_state  
3f5c				endm  
# End of macro CALLMONITOR
3f5c					endif 
3f5c			 
3f5c			 
3f5c			 
3f5c 3e 00				ld a, 0 
3f5e cd 17 0b				call menu 
3f61			 
3f61			 
3f61 6f					ld l, a 
3f62 26 00				ld h, 0 
3f64			 
3f64					if DEBUG_FORTH_WORDS 
3f64						DMARK "MNr" 
3f64 f5				push af  
3f65 3a 79 3f			ld a, (.dmark)  
3f68 32 bd fb			ld (debug_mark),a  
3f6b 3a 7a 3f			ld a, (.dmark+1)  
3f6e 32 be fb			ld (debug_mark+1),a  
3f71 3a 7b 3f			ld a, (.dmark+2)  
3f74 32 bf fb			ld (debug_mark+2),a  
3f77 18 03			jr .pastdmark  
3f79 ..			.dmark: db "MNr"  
3f7c f1			.pastdmark: pop af  
3f7d			endm  
# End of macro DMARK
3f7d						CALLMONITOR 
3f7d cd 2d 17			call break_point_state  
3f80				endm  
# End of macro CALLMONITOR
3f80					endif 
3f80			 
3f80 cd bd 1c				call forth_push_numhl 
3f83			 
3f83			 
3f83			 
3f83			 
3f83				       NEXTW 
3f83 c3 26 20			jp macro_next 
3f86				endm 
# End of macro NEXTW
3f86			 
3f86			 
3f86			.ENDDISPLAY: 
3f86			 
3f86			; eof 
# End of file forth_words_display.asm
3f86			include "forth_words_str.asm" 
3f86			 
3f86			; | ## String Words 
3f86			 
3f86			.PTR:   
3f86			 
3f86				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3f86 48				db WORD_SYS_CORE+52             
3f87 b3 3f			dw .STYPE            
3f89 04				db 3 + 1 
3f8a .. 00			db "PTR",0              
3f8e				endm 
# End of macro CWHEAD
3f8e			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3f8e			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3f8e			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3f8e			 
3f8e					if DEBUG_FORTH_WORDS_KEY 
3f8e						DMARK "PTR" 
3f8e f5				push af  
3f8f 3a a3 3f			ld a, (.dmark)  
3f92 32 bd fb			ld (debug_mark),a  
3f95 3a a4 3f			ld a, (.dmark+1)  
3f98 32 be fb			ld (debug_mark+1),a  
3f9b 3a a5 3f			ld a, (.dmark+2)  
3f9e 32 bf fb			ld (debug_mark+2),a  
3fa1 18 03			jr .pastdmark  
3fa3 ..			.dmark: db "PTR"  
3fa6 f1			.pastdmark: pop af  
3fa7			endm  
# End of macro DMARK
3fa7						CALLMONITOR 
3fa7 cd 2d 17			call break_point_state  
3faa				endm  
# End of macro CALLMONITOR
3faa					endif 
3faa					FORTH_DSP_VALUEHL 
3faa cd b4 1e			call macro_dsp_valuehl 
3fad				endm 
# End of macro FORTH_DSP_VALUEHL
3fad cd bd 1c				call forth_push_numhl 
3fb0			 
3fb0			 
3fb0					NEXTW 
3fb0 c3 26 20			jp macro_next 
3fb3				endm 
# End of macro NEXTW
3fb3			.STYPE: 
3fb3				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3fb3 48				db WORD_SYS_CORE+52             
3fb4 02 40			dw .UPPER            
3fb6 06				db 5 + 1 
3fb7 .. 00			db "STYPE",0              
3fbd				endm 
# End of macro CWHEAD
3fbd			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3fbd					if DEBUG_FORTH_WORDS_KEY 
3fbd						DMARK "STY" 
3fbd f5				push af  
3fbe 3a d2 3f			ld a, (.dmark)  
3fc1 32 bd fb			ld (debug_mark),a  
3fc4 3a d3 3f			ld a, (.dmark+1)  
3fc7 32 be fb			ld (debug_mark+1),a  
3fca 3a d4 3f			ld a, (.dmark+2)  
3fcd 32 bf fb			ld (debug_mark+2),a  
3fd0 18 03			jr .pastdmark  
3fd2 ..			.dmark: db "STY"  
3fd5 f1			.pastdmark: pop af  
3fd6			endm  
# End of macro DMARK
3fd6						CALLMONITOR 
3fd6 cd 2d 17			call break_point_state  
3fd9				endm  
# End of macro CALLMONITOR
3fd9					endif 
3fd9					FORTH_DSP 
3fd9 cd 7a 1e			call macro_forth_dsp 
3fdc				endm 
# End of macro FORTH_DSP
3fdc					;v5 FORTH_DSP_VALUE 
3fdc			 
3fdc 7e					ld a, (hl) 
3fdd			 
3fdd f5					push af 
3fde			 
3fde			; Dont destroy TOS		FORTH_DSP_POP 
3fde			 
3fde f1					pop af 
3fdf			 
3fdf fe 01				cp DS_TYPE_STR 
3fe1 28 09				jr z, .typestr 
3fe3			 
3fe3 fe 02				cp DS_TYPE_INUM 
3fe5 28 0a				jr z, .typeinum 
3fe7			 
3fe7 21 00 40				ld hl, .tna 
3fea 18 0a				jr .tpush 
3fec			 
3fec 21 fc 3f		.typestr:	ld hl, .tstr 
3fef 18 05				jr .tpush 
3ff1 21 fe 3f		.typeinum:	ld hl, .tinum 
3ff4 18 00				jr .tpush 
3ff6			 
3ff6			.tpush: 
3ff6			 
3ff6 cd 2b 1d				call forth_push_str 
3ff9			 
3ff9					NEXTW 
3ff9 c3 26 20			jp macro_next 
3ffc				endm 
# End of macro NEXTW
3ffc .. 00		.tstr:	db "s",0 
3ffe .. 00		.tinum:  db "i",0 
4000 .. 00		.tna:   db "?", 0 
4002			 
4002			 
4002			.UPPER: 
4002				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4002 48				db WORD_SYS_CORE+52             
4003 3d 40			dw .LOWER            
4005 06				db 5 + 1 
4006 .. 00			db "UPPER",0              
400c				endm 
# End of macro CWHEAD
400c			; | UPPER ( s -- s ) Upper case string s  | DONE 
400c					if DEBUG_FORTH_WORDS_KEY 
400c						DMARK "UPR" 
400c f5				push af  
400d 3a 21 40			ld a, (.dmark)  
4010 32 bd fb			ld (debug_mark),a  
4013 3a 22 40			ld a, (.dmark+1)  
4016 32 be fb			ld (debug_mark+1),a  
4019 3a 23 40			ld a, (.dmark+2)  
401c 32 bf fb			ld (debug_mark+2),a  
401f 18 03			jr .pastdmark  
4021 ..			.dmark: db "UPR"  
4024 f1			.pastdmark: pop af  
4025			endm  
# End of macro DMARK
4025						CALLMONITOR 
4025 cd 2d 17			call break_point_state  
4028				endm  
# End of macro CALLMONITOR
4028					endif 
4028			 
4028					FORTH_DSP 
4028 cd 7a 1e			call macro_forth_dsp 
402b				endm 
# End of macro FORTH_DSP
402b					 
402b			; TODO check is string type 
402b			 
402b					FORTH_DSP_VALUEHL 
402b cd b4 1e			call macro_dsp_valuehl 
402e				endm 
# End of macro FORTH_DSP_VALUEHL
402e			; get pointer to string in hl 
402e			 
402e 7e			.toup:		ld a, (hl) 
402f fe 00				cp 0 
4031 28 07				jr z, .toupdone 
4033			 
4033 cd 87 10				call to_upper 
4036			 
4036 77					ld (hl), a 
4037 23					inc hl 
4038 18 f4				jr .toup 
403a			 
403a					 
403a			 
403a			 
403a			; for each char convert to upper 
403a					 
403a			.toupdone: 
403a			 
403a			 
403a					NEXTW 
403a c3 26 20			jp macro_next 
403d				endm 
# End of macro NEXTW
403d			.LOWER: 
403d				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
403d 48				db WORD_SYS_CORE+52             
403e 78 40			dw .TCASE            
4040 06				db 5 + 1 
4041 .. 00			db "LOWER",0              
4047				endm 
# End of macro CWHEAD
4047			; | LOWER ( s -- s ) Lower case string s  | DONE 
4047					if DEBUG_FORTH_WORDS_KEY 
4047						DMARK "LWR" 
4047 f5				push af  
4048 3a 5c 40			ld a, (.dmark)  
404b 32 bd fb			ld (debug_mark),a  
404e 3a 5d 40			ld a, (.dmark+1)  
4051 32 be fb			ld (debug_mark+1),a  
4054 3a 5e 40			ld a, (.dmark+2)  
4057 32 bf fb			ld (debug_mark+2),a  
405a 18 03			jr .pastdmark  
405c ..			.dmark: db "LWR"  
405f f1			.pastdmark: pop af  
4060			endm  
# End of macro DMARK
4060						CALLMONITOR 
4060 cd 2d 17			call break_point_state  
4063				endm  
# End of macro CALLMONITOR
4063					endif 
4063			 
4063					FORTH_DSP 
4063 cd 7a 1e			call macro_forth_dsp 
4066				endm 
# End of macro FORTH_DSP
4066					 
4066			; TODO check is string type 
4066			 
4066					FORTH_DSP_VALUEHL 
4066 cd b4 1e			call macro_dsp_valuehl 
4069				endm 
# End of macro FORTH_DSP_VALUEHL
4069			; get pointer to string in hl 
4069			 
4069 7e			.tolow:		ld a, (hl) 
406a fe 00				cp 0 
406c 28 07				jr z, .tolowdone 
406e			 
406e cd 90 10				call to_lower 
4071			 
4071 77					ld (hl), a 
4072 23					inc hl 
4073 18 f4				jr .tolow 
4075			 
4075					 
4075			 
4075			 
4075			; for each char convert to low 
4075					 
4075			.tolowdone: 
4075					NEXTW 
4075 c3 26 20			jp macro_next 
4078				endm 
# End of macro NEXTW
4078			.TCASE: 
4078				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4078 48				db WORD_SYS_CORE+52             
4079 ae 41			dw .SUBSTR            
407b 06				db 5 + 1 
407c .. 00			db "TCASE",0              
4082				endm 
# End of macro CWHEAD
4082			; | TCASE ( s -- s ) Title case string s  | DONE 
4082					if DEBUG_FORTH_WORDS_KEY 
4082						DMARK "TCS" 
4082 f5				push af  
4083 3a 97 40			ld a, (.dmark)  
4086 32 bd fb			ld (debug_mark),a  
4089 3a 98 40			ld a, (.dmark+1)  
408c 32 be fb			ld (debug_mark+1),a  
408f 3a 99 40			ld a, (.dmark+2)  
4092 32 bf fb			ld (debug_mark+2),a  
4095 18 03			jr .pastdmark  
4097 ..			.dmark: db "TCS"  
409a f1			.pastdmark: pop af  
409b			endm  
# End of macro DMARK
409b						CALLMONITOR 
409b cd 2d 17			call break_point_state  
409e				endm  
# End of macro CALLMONITOR
409e					endif 
409e			 
409e					FORTH_DSP 
409e cd 7a 1e			call macro_forth_dsp 
40a1				endm 
# End of macro FORTH_DSP
40a1					 
40a1			; TODO check is string type 
40a1			 
40a1					FORTH_DSP_VALUEHL 
40a1 cd b4 1e			call macro_dsp_valuehl 
40a4				endm 
# End of macro FORTH_DSP_VALUEHL
40a4			; get pointer to string in hl 
40a4			 
40a4					if DEBUG_FORTH_WORDS 
40a4						DMARK "TC1" 
40a4 f5				push af  
40a5 3a b9 40			ld a, (.dmark)  
40a8 32 bd fb			ld (debug_mark),a  
40ab 3a ba 40			ld a, (.dmark+1)  
40ae 32 be fb			ld (debug_mark+1),a  
40b1 3a bb 40			ld a, (.dmark+2)  
40b4 32 bf fb			ld (debug_mark+2),a  
40b7 18 03			jr .pastdmark  
40b9 ..			.dmark: db "TC1"  
40bc f1			.pastdmark: pop af  
40bd			endm  
# End of macro DMARK
40bd						CALLMONITOR 
40bd cd 2d 17			call break_point_state  
40c0				endm  
# End of macro CALLMONITOR
40c0					endif 
40c0			 
40c0					; first time in turn to upper case first char 
40c0			 
40c0 7e					ld a, (hl) 
40c1 c3 4b 41				jp .totsiptou 
40c4			 
40c4			 
40c4 7e			.tot:		ld a, (hl) 
40c5 fe 00				cp 0 
40c7 ca 8f 41				jp z, .totdone 
40ca			 
40ca					if DEBUG_FORTH_WORDS 
40ca						DMARK "TC2" 
40ca f5				push af  
40cb 3a df 40			ld a, (.dmark)  
40ce 32 bd fb			ld (debug_mark),a  
40d1 3a e0 40			ld a, (.dmark+1)  
40d4 32 be fb			ld (debug_mark+1),a  
40d7 3a e1 40			ld a, (.dmark+2)  
40da 32 bf fb			ld (debug_mark+2),a  
40dd 18 03			jr .pastdmark  
40df ..			.dmark: db "TC2"  
40e2 f1			.pastdmark: pop af  
40e3			endm  
# End of macro DMARK
40e3						CALLMONITOR 
40e3 cd 2d 17			call break_point_state  
40e6				endm  
# End of macro CALLMONITOR
40e6					endif 
40e6					; check to see if current char is a space 
40e6			 
40e6 fe 20				cp ' ' 
40e8 28 21				jr z, .totsp 
40ea cd 90 10				call to_lower 
40ed					if DEBUG_FORTH_WORDS 
40ed						DMARK "TC3" 
40ed f5				push af  
40ee 3a 02 41			ld a, (.dmark)  
40f1 32 bd fb			ld (debug_mark),a  
40f4 3a 03 41			ld a, (.dmark+1)  
40f7 32 be fb			ld (debug_mark+1),a  
40fa 3a 04 41			ld a, (.dmark+2)  
40fd 32 bf fb			ld (debug_mark+2),a  
4100 18 03			jr .pastdmark  
4102 ..			.dmark: db "TC3"  
4105 f1			.pastdmark: pop af  
4106			endm  
# End of macro DMARK
4106						CALLMONITOR 
4106 cd 2d 17			call break_point_state  
4109				endm  
# End of macro CALLMONITOR
4109					endif 
4109 18 63				jr .totnxt 
410b			 
410b			.totsp:         ; on a space, find next char which should be upper 
410b			 
410b					if DEBUG_FORTH_WORDS 
410b						DMARK "TC4" 
410b f5				push af  
410c 3a 20 41			ld a, (.dmark)  
410f 32 bd fb			ld (debug_mark),a  
4112 3a 21 41			ld a, (.dmark+1)  
4115 32 be fb			ld (debug_mark+1),a  
4118 3a 22 41			ld a, (.dmark+2)  
411b 32 bf fb			ld (debug_mark+2),a  
411e 18 03			jr .pastdmark  
4120 ..			.dmark: db "TC4"  
4123 f1			.pastdmark: pop af  
4124			endm  
# End of macro DMARK
4124						CALLMONITOR 
4124 cd 2d 17			call break_point_state  
4127				endm  
# End of macro CALLMONITOR
4127					endif 
4127					;; 
4127			 
4127 fe 20				cp ' ' 
4129 20 20				jr nz, .totsiptou 
412b 23					inc hl 
412c 7e					ld a, (hl) 
412d					if DEBUG_FORTH_WORDS 
412d						DMARK "TC5" 
412d f5				push af  
412e 3a 42 41			ld a, (.dmark)  
4131 32 bd fb			ld (debug_mark),a  
4134 3a 43 41			ld a, (.dmark+1)  
4137 32 be fb			ld (debug_mark+1),a  
413a 3a 44 41			ld a, (.dmark+2)  
413d 32 bf fb			ld (debug_mark+2),a  
4140 18 03			jr .pastdmark  
4142 ..			.dmark: db "TC5"  
4145 f1			.pastdmark: pop af  
4146			endm  
# End of macro DMARK
4146						CALLMONITOR 
4146 cd 2d 17			call break_point_state  
4149				endm  
# End of macro CALLMONITOR
4149					endif 
4149 18 c0				jr .totsp 
414b fe 00		.totsiptou:    cp 0 
414d 28 40				jr z, .totdone 
414f					; not space and not zero term so upper case it 
414f cd 87 10				call to_upper 
4152			 
4152					if DEBUG_FORTH_WORDS 
4152						DMARK "TC6" 
4152 f5				push af  
4153 3a 67 41			ld a, (.dmark)  
4156 32 bd fb			ld (debug_mark),a  
4159 3a 68 41			ld a, (.dmark+1)  
415c 32 be fb			ld (debug_mark+1),a  
415f 3a 69 41			ld a, (.dmark+2)  
4162 32 bf fb			ld (debug_mark+2),a  
4165 18 03			jr .pastdmark  
4167 ..			.dmark: db "TC6"  
416a f1			.pastdmark: pop af  
416b			endm  
# End of macro DMARK
416b						CALLMONITOR 
416b cd 2d 17			call break_point_state  
416e				endm  
# End of macro CALLMONITOR
416e					endif 
416e			 
416e			 
416e			.totnxt: 
416e			 
416e 77					ld (hl), a 
416f 23					inc hl 
4170					if DEBUG_FORTH_WORDS 
4170						DMARK "TC7" 
4170 f5				push af  
4171 3a 85 41			ld a, (.dmark)  
4174 32 bd fb			ld (debug_mark),a  
4177 3a 86 41			ld a, (.dmark+1)  
417a 32 be fb			ld (debug_mark+1),a  
417d 3a 87 41			ld a, (.dmark+2)  
4180 32 bf fb			ld (debug_mark+2),a  
4183 18 03			jr .pastdmark  
4185 ..			.dmark: db "TC7"  
4188 f1			.pastdmark: pop af  
4189			endm  
# End of macro DMARK
4189						CALLMONITOR 
4189 cd 2d 17			call break_point_state  
418c				endm  
# End of macro CALLMONITOR
418c					endif 
418c c3 c4 40				jp .tot 
418f			 
418f					 
418f			 
418f			 
418f			; for each char convert to low 
418f					 
418f			.totdone: 
418f					if DEBUG_FORTH_WORDS 
418f						DMARK "TCd" 
418f f5				push af  
4190 3a a4 41			ld a, (.dmark)  
4193 32 bd fb			ld (debug_mark),a  
4196 3a a5 41			ld a, (.dmark+1)  
4199 32 be fb			ld (debug_mark+1),a  
419c 3a a6 41			ld a, (.dmark+2)  
419f 32 bf fb			ld (debug_mark+2),a  
41a2 18 03			jr .pastdmark  
41a4 ..			.dmark: db "TCd"  
41a7 f1			.pastdmark: pop af  
41a8			endm  
# End of macro DMARK
41a8						CALLMONITOR 
41a8 cd 2d 17			call break_point_state  
41ab				endm  
# End of macro CALLMONITOR
41ab					endif 
41ab					NEXTW 
41ab c3 26 20			jp macro_next 
41ae				endm 
# End of macro NEXTW
41ae			 
41ae			.SUBSTR: 
41ae				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
41ae 48				db WORD_SYS_CORE+52             
41af 0c 42			dw .LEFT            
41b1 07				db 6 + 1 
41b2 .. 00			db "SUBSTR",0              
41b9				endm 
# End of macro CWHEAD
41b9			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
41b9			 
41b9					if DEBUG_FORTH_WORDS_KEY 
41b9						DMARK "SST" 
41b9 f5				push af  
41ba 3a ce 41			ld a, (.dmark)  
41bd 32 bd fb			ld (debug_mark),a  
41c0 3a cf 41			ld a, (.dmark+1)  
41c3 32 be fb			ld (debug_mark+1),a  
41c6 3a d0 41			ld a, (.dmark+2)  
41c9 32 bf fb			ld (debug_mark+2),a  
41cc 18 03			jr .pastdmark  
41ce ..			.dmark: db "SST"  
41d1 f1			.pastdmark: pop af  
41d2			endm  
# End of macro DMARK
41d2						CALLMONITOR 
41d2 cd 2d 17			call break_point_state  
41d5				endm  
# End of macro CALLMONITOR
41d5					endif 
41d5			; TODO check string type 
41d5					FORTH_DSP_VALUEHL 
41d5 cd b4 1e			call macro_dsp_valuehl 
41d8				endm 
# End of macro FORTH_DSP_VALUEHL
41d8			 
41d8 e5					push hl      ; string length 
41d9			 
41d9					FORTH_DSP_POP 
41d9 cd 6c 1f			call macro_forth_dsp_pop 
41dc				endm 
# End of macro FORTH_DSP_POP
41dc			 
41dc					FORTH_DSP_VALUEHL 
41dc cd b4 1e			call macro_dsp_valuehl 
41df				endm 
# End of macro FORTH_DSP_VALUEHL
41df			 
41df e5					push hl     ; start char 
41e0			 
41e0					FORTH_DSP_POP 
41e0 cd 6c 1f			call macro_forth_dsp_pop 
41e3				endm 
# End of macro FORTH_DSP_POP
41e3			 
41e3			 
41e3					FORTH_DSP_VALUE 
41e3 cd 9d 1e			call macro_forth_dsp_value 
41e6				endm 
# End of macro FORTH_DSP_VALUE
41e6			 
41e6 d1					pop de    ; get start post offset 
41e7			 
41e7 19					add hl, de    ; starting offset 
41e8			 
41e8 c1					pop bc 
41e9 c5					push bc      ; grab size of string 
41ea			 
41ea e5					push hl    ; save string start  
41eb			 
41eb 26 00				ld h, 0 
41ed 69					ld l, c 
41ee 23					inc hl 
41ef 23					inc hl 
41f0			 
41f0 cd e1 11				call malloc 
41f3				if DEBUG_FORTH_MALLOC_GUARD 
41f3 cc a2 51				call z,malloc_error 
41f6				endif 
41f6			 
41f6 eb					ex de, hl      ; save malloc area for string copy 
41f7 e1					pop hl    ; get back source 
41f8 c1					pop bc    ; get length of string back 
41f9			 
41f9 d5					push de    ; save malloc area for after we push 
41fa ed b0				ldir     ; copy substr 
41fc			 
41fc			 
41fc eb					ex de, hl 
41fd 3e 00				ld a, 0 
41ff 77					ld (hl), a   ; term substr 
4200			 
4200					 
4200 e1					pop hl    ; get malloc so we can push it 
4201 e5					push hl   ; save so we can free it afterwards 
4202			 
4202 cd 2b 1d				call forth_push_str 
4205			 
4205 e1					pop hl 
4206 cd ab 12				call free 
4209			 
4209					 
4209					 
4209			 
4209			 
4209					NEXTW 
4209 c3 26 20			jp macro_next 
420c				endm 
# End of macro NEXTW
420c			 
420c			.LEFT: 
420c				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
420c 48				db WORD_SYS_CORE+52             
420d 34 42			dw .RIGHT            
420f 05				db 4 + 1 
4210 .. 00			db "LEFT",0              
4215				endm 
# End of macro CWHEAD
4215			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4215					if DEBUG_FORTH_WORDS_KEY 
4215						DMARK "LEF" 
4215 f5				push af  
4216 3a 2a 42			ld a, (.dmark)  
4219 32 bd fb			ld (debug_mark),a  
421c 3a 2b 42			ld a, (.dmark+1)  
421f 32 be fb			ld (debug_mark+1),a  
4222 3a 2c 42			ld a, (.dmark+2)  
4225 32 bf fb			ld (debug_mark+2),a  
4228 18 03			jr .pastdmark  
422a ..			.dmark: db "LEF"  
422d f1			.pastdmark: pop af  
422e			endm  
# End of macro DMARK
422e						CALLMONITOR 
422e cd 2d 17			call break_point_state  
4231				endm  
# End of macro CALLMONITOR
4231					endif 
4231			 
4231					NEXTW 
4231 c3 26 20			jp macro_next 
4234				endm 
# End of macro NEXTW
4234			.RIGHT: 
4234				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4234 48				db WORD_SYS_CORE+52             
4235 5d 42			dw .STR2NUM            
4237 06				db 5 + 1 
4238 .. 00			db "RIGHT",0              
423e				endm 
# End of macro CWHEAD
423e			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
423e					if DEBUG_FORTH_WORDS_KEY 
423e						DMARK "RIG" 
423e f5				push af  
423f 3a 53 42			ld a, (.dmark)  
4242 32 bd fb			ld (debug_mark),a  
4245 3a 54 42			ld a, (.dmark+1)  
4248 32 be fb			ld (debug_mark+1),a  
424b 3a 55 42			ld a, (.dmark+2)  
424e 32 bf fb			ld (debug_mark+2),a  
4251 18 03			jr .pastdmark  
4253 ..			.dmark: db "RIG"  
4256 f1			.pastdmark: pop af  
4257			endm  
# End of macro DMARK
4257						CALLMONITOR 
4257 cd 2d 17			call break_point_state  
425a				endm  
# End of macro CALLMONITOR
425a					endif 
425a			 
425a					NEXTW 
425a c3 26 20			jp macro_next 
425d				endm 
# End of macro NEXTW
425d			 
425d			 
425d			.STR2NUM: 
425d				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
425d 48				db WORD_SYS_CORE+52             
425e e9 42			dw .NUM2STR            
4260 08				db 7 + 1 
4261 .. 00			db "STR2NUM",0              
4269				endm 
# End of macro CWHEAD
4269			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4269			 
4269			 
4269			; TODO STR type check to do 
4269					if DEBUG_FORTH_WORDS_KEY 
4269						DMARK "S2N" 
4269 f5				push af  
426a 3a 7e 42			ld a, (.dmark)  
426d 32 bd fb			ld (debug_mark),a  
4270 3a 7f 42			ld a, (.dmark+1)  
4273 32 be fb			ld (debug_mark+1),a  
4276 3a 80 42			ld a, (.dmark+2)  
4279 32 bf fb			ld (debug_mark+2),a  
427c 18 03			jr .pastdmark  
427e ..			.dmark: db "S2N"  
4281 f1			.pastdmark: pop af  
4282			endm  
# End of macro DMARK
4282						CALLMONITOR 
4282 cd 2d 17			call break_point_state  
4285				endm  
# End of macro CALLMONITOR
4285					endif 
4285			 
4285					;FORTH_DSP 
4285					FORTH_DSP_VALUE 
4285 cd 9d 1e			call macro_forth_dsp_value 
4288				endm 
# End of macro FORTH_DSP_VALUE
4288					;inc hl 
4288			 
4288 eb					ex de, hl 
4289					if DEBUG_FORTH_WORDS 
4289						DMARK "S2a" 
4289 f5				push af  
428a 3a 9e 42			ld a, (.dmark)  
428d 32 bd fb			ld (debug_mark),a  
4290 3a 9f 42			ld a, (.dmark+1)  
4293 32 be fb			ld (debug_mark+1),a  
4296 3a a0 42			ld a, (.dmark+2)  
4299 32 bf fb			ld (debug_mark+2),a  
429c 18 03			jr .pastdmark  
429e ..			.dmark: db "S2a"  
42a1 f1			.pastdmark: pop af  
42a2			endm  
# End of macro DMARK
42a2						CALLMONITOR 
42a2 cd 2d 17			call break_point_state  
42a5				endm  
# End of macro CALLMONITOR
42a5					endif 
42a5 cd 0f 11				call string_to_uint16 
42a8			 
42a8					if DEBUG_FORTH_WORDS 
42a8						DMARK "S2b" 
42a8 f5				push af  
42a9 3a bd 42			ld a, (.dmark)  
42ac 32 bd fb			ld (debug_mark),a  
42af 3a be 42			ld a, (.dmark+1)  
42b2 32 be fb			ld (debug_mark+1),a  
42b5 3a bf 42			ld a, (.dmark+2)  
42b8 32 bf fb			ld (debug_mark+2),a  
42bb 18 03			jr .pastdmark  
42bd ..			.dmark: db "S2b"  
42c0 f1			.pastdmark: pop af  
42c1			endm  
# End of macro DMARK
42c1						CALLMONITOR 
42c1 cd 2d 17			call break_point_state  
42c4				endm  
# End of macro CALLMONITOR
42c4					endif 
42c4			;		push hl 
42c4					FORTH_DSP_POP 
42c4 cd 6c 1f			call macro_forth_dsp_pop 
42c7				endm 
# End of macro FORTH_DSP_POP
42c7			;		pop hl 
42c7					 
42c7					if DEBUG_FORTH_WORDS 
42c7						DMARK "S2b" 
42c7 f5				push af  
42c8 3a dc 42			ld a, (.dmark)  
42cb 32 bd fb			ld (debug_mark),a  
42ce 3a dd 42			ld a, (.dmark+1)  
42d1 32 be fb			ld (debug_mark+1),a  
42d4 3a de 42			ld a, (.dmark+2)  
42d7 32 bf fb			ld (debug_mark+2),a  
42da 18 03			jr .pastdmark  
42dc ..			.dmark: db "S2b"  
42df f1			.pastdmark: pop af  
42e0			endm  
# End of macro DMARK
42e0						CALLMONITOR 
42e0 cd 2d 17			call break_point_state  
42e3				endm  
# End of macro CALLMONITOR
42e3					endif 
42e3 cd bd 1c				call forth_push_numhl	 
42e6			 
42e6				 
42e6				       NEXTW 
42e6 c3 26 20			jp macro_next 
42e9				endm 
# End of macro NEXTW
42e9			.NUM2STR: 
42e9				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
42e9 48				db WORD_SYS_CORE+52             
42ea f8 42			dw .CONCAT            
42ec 08				db 7 + 1 
42ed .. 00			db "NUM2STR",0              
42f5				endm 
# End of macro CWHEAD
42f5			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
42f5			 
42f5			;		; malloc a string to target 
42f5			;		ld hl, 10     ; TODO max string size should be fine 
42f5			;		call malloc 
42f5			;		push hl    ; save malloc location 
42f5			; 
42f5			; 
42f5			;; TODO check int type 
42f5			;		FORTH_DSP_VALUEHL 
42f5			;		ld a, l 
42f5			;		call DispAToASCII   
42f5			;;TODO need to chage above call to dump into string 
42f5			; 
42f5			; 
42f5			 
42f5				       NEXTW 
42f5 c3 26 20			jp macro_next 
42f8				endm 
# End of macro NEXTW
42f8			 
42f8			.CONCAT: 
42f8				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
42f8 48				db WORD_SYS_CORE+52             
42f9 ab 43			dw .FIND            
42fb 07				db 6 + 1 
42fc .. 00			db "CONCAT",0              
4303				endm 
# End of macro CWHEAD
4303			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4303			 
4303			; TODO check string type 
4303			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4303			 
4303					if DEBUG_FORTH_WORDS_KEY 
4303						DMARK "CON" 
4303 f5				push af  
4304 3a 18 43			ld a, (.dmark)  
4307 32 bd fb			ld (debug_mark),a  
430a 3a 19 43			ld a, (.dmark+1)  
430d 32 be fb			ld (debug_mark+1),a  
4310 3a 1a 43			ld a, (.dmark+2)  
4313 32 bf fb			ld (debug_mark+2),a  
4316 18 03			jr .pastdmark  
4318 ..			.dmark: db "CON"  
431b f1			.pastdmark: pop af  
431c			endm  
# End of macro DMARK
431c						CALLMONITOR 
431c cd 2d 17			call break_point_state  
431f				endm  
# End of macro CALLMONITOR
431f					endif 
431f			 
431f			 
431f					FORTH_DSP_VALUE 
431f cd 9d 1e			call macro_forth_dsp_value 
4322				endm 
# End of macro FORTH_DSP_VALUE
4322 e5					push hl   ; s2 
4323			 
4323					FORTH_DSP_POP 
4323 cd 6c 1f			call macro_forth_dsp_pop 
4326				endm 
# End of macro FORTH_DSP_POP
4326			 
4326					FORTH_DSP_VALUE 
4326 cd 9d 1e			call macro_forth_dsp_value 
4329				endm 
# End of macro FORTH_DSP_VALUE
4329			 
4329 e5					push hl   ; s1 
432a			 
432a					FORTH_DSP_POP 
432a cd 6c 1f			call macro_forth_dsp_pop 
432d				endm 
# End of macro FORTH_DSP_POP
432d					 
432d			 
432d					; copy s1 
432d			 
432d				 
432d					; save ptr 
432d e1					pop hl  
432e e5					push hl 
432f 3e 00				ld a, 0 
4331 cd 83 11				call strlent 
4334					;inc hl    ; zer0 
4334 06 00				ld b, 0 
4336 4d					ld c, l 
4337 e1					pop hl		 
4338 11 a3 ef				ld de, scratch	 
433b					if DEBUG_FORTH_WORDS 
433b						DMARK "CO1" 
433b f5				push af  
433c 3a 50 43			ld a, (.dmark)  
433f 32 bd fb			ld (debug_mark),a  
4342 3a 51 43			ld a, (.dmark+1)  
4345 32 be fb			ld (debug_mark+1),a  
4348 3a 52 43			ld a, (.dmark+2)  
434b 32 bf fb			ld (debug_mark+2),a  
434e 18 03			jr .pastdmark  
4350 ..			.dmark: db "CO1"  
4353 f1			.pastdmark: pop af  
4354			endm  
# End of macro DMARK
4354						CALLMONITOR 
4354 cd 2d 17			call break_point_state  
4357				endm  
# End of macro CALLMONITOR
4357					endif 
4357 ed b0				ldir 
4359			 
4359 e1					pop hl 
435a e5					push hl 
435b d5					push de 
435c			 
435c			 
435c 3e 00				ld a, 0 
435e cd 83 11				call strlent 
4361 23					inc hl    ; zer0 
4362 23					inc hl 
4363 06 00				ld b, 0 
4365 4d					ld c, l 
4366 d1					pop de 
4367 e1					pop hl		 
4368					if DEBUG_FORTH_WORDS 
4368						DMARK "CO2" 
4368 f5				push af  
4369 3a 7d 43			ld a, (.dmark)  
436c 32 bd fb			ld (debug_mark),a  
436f 3a 7e 43			ld a, (.dmark+1)  
4372 32 be fb			ld (debug_mark+1),a  
4375 3a 7f 43			ld a, (.dmark+2)  
4378 32 bf fb			ld (debug_mark+2),a  
437b 18 03			jr .pastdmark  
437d ..			.dmark: db "CO2"  
4380 f1			.pastdmark: pop af  
4381			endm  
# End of macro DMARK
4381						CALLMONITOR 
4381 cd 2d 17			call break_point_state  
4384				endm  
# End of macro CALLMONITOR
4384					endif 
4384 ed b0				ldir 
4386			 
4386			 
4386			 
4386 21 a3 ef				ld hl, scratch 
4389					if DEBUG_FORTH_WORDS 
4389						DMARK "CO5" 
4389 f5				push af  
438a 3a 9e 43			ld a, (.dmark)  
438d 32 bd fb			ld (debug_mark),a  
4390 3a 9f 43			ld a, (.dmark+1)  
4393 32 be fb			ld (debug_mark+1),a  
4396 3a a0 43			ld a, (.dmark+2)  
4399 32 bf fb			ld (debug_mark+2),a  
439c 18 03			jr .pastdmark  
439e ..			.dmark: db "CO5"  
43a1 f1			.pastdmark: pop af  
43a2			endm  
# End of macro DMARK
43a2						CALLMONITOR 
43a2 cd 2d 17			call break_point_state  
43a5				endm  
# End of macro CALLMONITOR
43a5					endif 
43a5			 
43a5 cd 2b 1d				call forth_push_str 
43a8			 
43a8			 
43a8			 
43a8			 
43a8				       NEXTW 
43a8 c3 26 20			jp macro_next 
43ab				endm 
# End of macro NEXTW
43ab			 
43ab			 
43ab			.FIND: 
43ab				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
43ab 4b				db WORD_SYS_CORE+55             
43ac 69 44			dw .LEN            
43ae 05				db 4 + 1 
43af .. 00			db "FIND",0              
43b4				endm 
# End of macro CWHEAD
43b4			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
43b4			 
43b4					if DEBUG_FORTH_WORDS_KEY 
43b4						DMARK "FND" 
43b4 f5				push af  
43b5 3a c9 43			ld a, (.dmark)  
43b8 32 bd fb			ld (debug_mark),a  
43bb 3a ca 43			ld a, (.dmark+1)  
43be 32 be fb			ld (debug_mark+1),a  
43c1 3a cb 43			ld a, (.dmark+2)  
43c4 32 bf fb			ld (debug_mark+2),a  
43c7 18 03			jr .pastdmark  
43c9 ..			.dmark: db "FND"  
43cc f1			.pastdmark: pop af  
43cd			endm  
# End of macro DMARK
43cd						CALLMONITOR 
43cd cd 2d 17			call break_point_state  
43d0				endm  
# End of macro CALLMONITOR
43d0					endif 
43d0			 
43d0			; TODO check string type 
43d0					FORTH_DSP_VALUE 
43d0 cd 9d 1e			call macro_forth_dsp_value 
43d3				endm 
# End of macro FORTH_DSP_VALUE
43d3			 
43d3 e5					push hl    
43d4 7e					ld a,(hl)    ; char to find   
43d5			; TODO change char to substr 
43d5			 
43d5 f5					push af 
43d6					 
43d6			 
43d6			 
43d6					if DEBUG_FORTH_WORDS 
43d6						DMARK "FN1" 
43d6 f5				push af  
43d7 3a eb 43			ld a, (.dmark)  
43da 32 bd fb			ld (debug_mark),a  
43dd 3a ec 43			ld a, (.dmark+1)  
43e0 32 be fb			ld (debug_mark+1),a  
43e3 3a ed 43			ld a, (.dmark+2)  
43e6 32 bf fb			ld (debug_mark+2),a  
43e9 18 03			jr .pastdmark  
43eb ..			.dmark: db "FN1"  
43ee f1			.pastdmark: pop af  
43ef			endm  
# End of macro DMARK
43ef						CALLMONITOR 
43ef cd 2d 17			call break_point_state  
43f2				endm  
# End of macro CALLMONITOR
43f2					endif 
43f2			 
43f2					FORTH_DSP_POP 
43f2 cd 6c 1f			call macro_forth_dsp_pop 
43f5				endm 
# End of macro FORTH_DSP_POP
43f5			 
43f5					; string to search 
43f5			 
43f5					FORTH_DSP_VALUE 
43f5 cd 9d 1e			call macro_forth_dsp_value 
43f8				endm 
# End of macro FORTH_DSP_VALUE
43f8			 
43f8 d1					pop de  ; d is char to find  
43f9			 
43f9					if DEBUG_FORTH_WORDS 
43f9						DMARK "FN2" 
43f9 f5				push af  
43fa 3a 0e 44			ld a, (.dmark)  
43fd 32 bd fb			ld (debug_mark),a  
4400 3a 0f 44			ld a, (.dmark+1)  
4403 32 be fb			ld (debug_mark+1),a  
4406 3a 10 44			ld a, (.dmark+2)  
4409 32 bf fb			ld (debug_mark+2),a  
440c 18 03			jr .pastdmark  
440e ..			.dmark: db "FN2"  
4411 f1			.pastdmark: pop af  
4412			endm  
# End of macro DMARK
4412						CALLMONITOR 
4412 cd 2d 17			call break_point_state  
4415				endm  
# End of macro CALLMONITOR
4415					endif 
4415					 
4415 01 00 00				ld bc, 0 
4418 7e			.findchar:      ld a,(hl) 
4419 fe 00				cp 0   		 
441b 28 27				jr z, .finddone     
441d ba					cp d 
441e 28 20				jr z, .foundchar 
4420 03					inc bc 
4421 23					inc hl 
4422					if DEBUG_FORTH_WORDS 
4422						DMARK "FN3" 
4422 f5				push af  
4423 3a 37 44			ld a, (.dmark)  
4426 32 bd fb			ld (debug_mark),a  
4429 3a 38 44			ld a, (.dmark+1)  
442c 32 be fb			ld (debug_mark+1),a  
442f 3a 39 44			ld a, (.dmark+2)  
4432 32 bf fb			ld (debug_mark+2),a  
4435 18 03			jr .pastdmark  
4437 ..			.dmark: db "FN3"  
443a f1			.pastdmark: pop af  
443b			endm  
# End of macro DMARK
443b						CALLMONITOR 
443b cd 2d 17			call break_point_state  
443e				endm  
# End of macro CALLMONITOR
443e					endif 
443e 18 d8				jr .findchar 
4440			 
4440			 
4440 c5			.foundchar:	push bc 
4441 e1					pop hl 
4442 18 03				jr .findexit 
4444			 
4444			 
4444							 
4444			 
4444			.finddone:     ; got to end of string with no find 
4444 21 00 00				ld hl, 0 
4447			.findexit: 
4447			 
4447					if DEBUG_FORTH_WORDS 
4447						DMARK "FNd" 
4447 f5				push af  
4448 3a 5c 44			ld a, (.dmark)  
444b 32 bd fb			ld (debug_mark),a  
444e 3a 5d 44			ld a, (.dmark+1)  
4451 32 be fb			ld (debug_mark+1),a  
4454 3a 5e 44			ld a, (.dmark+2)  
4457 32 bf fb			ld (debug_mark+2),a  
445a 18 03			jr .pastdmark  
445c ..			.dmark: db "FNd"  
445f f1			.pastdmark: pop af  
4460			endm  
# End of macro DMARK
4460						CALLMONITOR 
4460 cd 2d 17			call break_point_state  
4463				endm  
# End of macro CALLMONITOR
4463					endif 
4463 cd bd 1c			call forth_push_numhl 
4466			 
4466				       NEXTW 
4466 c3 26 20			jp macro_next 
4469				endm 
# End of macro NEXTW
4469			 
4469			.LEN: 
4469				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4469 4c				db WORD_SYS_CORE+56             
446a 9e 44			dw .CHAR            
446c 06				db 5 + 1 
446d .. 00			db "COUNT",0              
4473				endm 
# End of macro CWHEAD
4473			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4473			 
4473					if DEBUG_FORTH_WORDS_KEY 
4473						DMARK "CNT" 
4473 f5				push af  
4474 3a 88 44			ld a, (.dmark)  
4477 32 bd fb			ld (debug_mark),a  
447a 3a 89 44			ld a, (.dmark+1)  
447d 32 be fb			ld (debug_mark+1),a  
4480 3a 8a 44			ld a, (.dmark+2)  
4483 32 bf fb			ld (debug_mark+2),a  
4486 18 03			jr .pastdmark  
4488 ..			.dmark: db "CNT"  
448b f1			.pastdmark: pop af  
448c			endm  
# End of macro DMARK
448c						CALLMONITOR 
448c cd 2d 17			call break_point_state  
448f				endm  
# End of macro CALLMONITOR
448f					endif 
448f			; TODO check string type 
448f					FORTH_DSP 
448f cd 7a 1e			call macro_forth_dsp 
4492				endm 
# End of macro FORTH_DSP
4492					;v5FORTH_DSP_VALUE 
4492			 
4492 23					inc hl 
4493			 
4493 3e 00				ld a, 0 
4495 cd 83 11				call strlent 
4498			 
4498 cd bd 1c				call forth_push_numhl 
449b			 
449b			 
449b			 
449b				       NEXTW 
449b c3 26 20			jp macro_next 
449e				endm 
# End of macro NEXTW
449e			.CHAR: 
449e				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
449e 4d				db WORD_SYS_CORE+57             
449f d4 44			dw .ENDSTR            
44a1 05				db 4 + 1 
44a2 .. 00			db "CHAR",0              
44a7				endm 
# End of macro CWHEAD
44a7			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
44a7					if DEBUG_FORTH_WORDS_KEY 
44a7						DMARK "CHR" 
44a7 f5				push af  
44a8 3a bc 44			ld a, (.dmark)  
44ab 32 bd fb			ld (debug_mark),a  
44ae 3a bd 44			ld a, (.dmark+1)  
44b1 32 be fb			ld (debug_mark+1),a  
44b4 3a be 44			ld a, (.dmark+2)  
44b7 32 bf fb			ld (debug_mark+2),a  
44ba 18 03			jr .pastdmark  
44bc ..			.dmark: db "CHR"  
44bf f1			.pastdmark: pop af  
44c0			endm  
# End of macro DMARK
44c0						CALLMONITOR 
44c0 cd 2d 17			call break_point_state  
44c3				endm  
# End of macro CALLMONITOR
44c3					endif 
44c3					FORTH_DSP 
44c3 cd 7a 1e			call macro_forth_dsp 
44c6				endm 
# End of macro FORTH_DSP
44c6					;v5 FORTH_DSP_VALUE 
44c6 23					inc hl      ; now at start of numeric as string 
44c7			 
44c7			;		push hl 
44c7			 
44c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44c7 cd 6c 1f			call macro_forth_dsp_pop 
44ca				endm 
# End of macro FORTH_DSP_POP
44ca			 
44ca			;		pop hl 
44ca			 
44ca					; push the content of a onto the stack as a value 
44ca			 
44ca 7e					ld a,(hl)   ; get char 
44cb 26 00				ld h,0 
44cd 6f					ld l,a 
44ce cd bd 1c				call forth_push_numhl 
44d1			 
44d1				       NEXTW 
44d1 c3 26 20			jp macro_next 
44d4				endm 
# End of macro NEXTW
44d4			 
44d4			 
44d4			 
44d4			 
44d4			.ENDSTR: 
44d4			; eof 
44d4			 
# End of file forth_words_str.asm
44d4			include "forth_words_key.asm" 
44d4			 
44d4			; | ## Keyboard Words 
44d4			 
44d4			.KEY: 
44d4				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
44d4 3e				db WORD_SYS_CORE+42             
44d5 04 45			dw .WAITK            
44d7 04				db 3 + 1 
44d8 .. 00			db "KEY",0              
44dc				endm 
# End of macro CWHEAD
44dc			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
44dc			 
44dc					if DEBUG_FORTH_WORDS_KEY 
44dc						DMARK "KEY" 
44dc f5				push af  
44dd 3a f1 44			ld a, (.dmark)  
44e0 32 bd fb			ld (debug_mark),a  
44e3 3a f2 44			ld a, (.dmark+1)  
44e6 32 be fb			ld (debug_mark+1),a  
44e9 3a f3 44			ld a, (.dmark+2)  
44ec 32 bf fb			ld (debug_mark+2),a  
44ef 18 03			jr .pastdmark  
44f1 ..			.dmark: db "KEY"  
44f4 f1			.pastdmark: pop af  
44f5			endm  
# End of macro DMARK
44f5						CALLMONITOR 
44f5 cd 2d 17			call break_point_state  
44f8				endm  
# End of macro CALLMONITOR
44f8					endif 
44f8			; TODO currently waits 
44f8 cd 32 67				call cin 
44fb					;call cin_wait 
44fb 6f					ld l, a 
44fc 26 00				ld h, 0 
44fe cd bd 1c				call forth_push_numhl 
4501					NEXTW 
4501 c3 26 20			jp macro_next 
4504				endm 
# End of macro NEXTW
4504			.WAITK: 
4504				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4504 3f				db WORD_SYS_CORE+43             
4505 36 45			dw .ACCEPT            
4507 06				db 5 + 1 
4508 .. 00			db "WAITK",0              
450e				endm 
# End of macro CWHEAD
450e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
450e					if DEBUG_FORTH_WORDS_KEY 
450e						DMARK "WAI" 
450e f5				push af  
450f 3a 23 45			ld a, (.dmark)  
4512 32 bd fb			ld (debug_mark),a  
4515 3a 24 45			ld a, (.dmark+1)  
4518 32 be fb			ld (debug_mark+1),a  
451b 3a 25 45			ld a, (.dmark+2)  
451e 32 bf fb			ld (debug_mark+2),a  
4521 18 03			jr .pastdmark  
4523 ..			.dmark: db "WAI"  
4526 f1			.pastdmark: pop af  
4527			endm  
# End of macro DMARK
4527						CALLMONITOR 
4527 cd 2d 17			call break_point_state  
452a				endm  
# End of macro CALLMONITOR
452a					endif 
452a cd 21 67				call cin_wait 
452d 6f					ld l, a 
452e 26 00				ld h, 0 
4530 cd bd 1c				call forth_push_numhl 
4533					NEXTW 
4533 c3 26 20			jp macro_next 
4536				endm 
# End of macro NEXTW
4536			.ACCEPT: 
4536				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4536 40				db WORD_SYS_CORE+44             
4537 94 45			dw .EDIT            
4539 07				db 6 + 1 
453a .. 00			db "ACCEPT",0              
4541				endm 
# End of macro CWHEAD
4541			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4541					; TODO crashes on push 
4541					if DEBUG_FORTH_WORDS_KEY 
4541						DMARK "ACC" 
4541 f5				push af  
4542 3a 56 45			ld a, (.dmark)  
4545 32 bd fb			ld (debug_mark),a  
4548 3a 57 45			ld a, (.dmark+1)  
454b 32 be fb			ld (debug_mark+1),a  
454e 3a 58 45			ld a, (.dmark+2)  
4551 32 bf fb			ld (debug_mark+2),a  
4554 18 03			jr .pastdmark  
4556 ..			.dmark: db "ACC"  
4559 f1			.pastdmark: pop af  
455a			endm  
# End of macro DMARK
455a						CALLMONITOR 
455a cd 2d 17			call break_point_state  
455d				endm  
# End of macro CALLMONITOR
455d					endif 
455d 21 a1 f1				ld hl, os_input 
4560 3e 00				ld a, 0 
4562 77					ld (hl),a 
4563 3a cc f9				ld a,(f_cursor_ptr) 
4566 16 64				ld d, 100 
4568 0e 00				ld c, 0 
456a 1e 28				ld e, 40 
456c cd 47 0d				call input_str 
456f					; TODO perhaps do a type check and wrap in quotes if not a number 
456f 21 a1 f1				ld hl, os_input 
4572					if DEBUG_FORTH_WORDS 
4572						DMARK "AC1" 
4572 f5				push af  
4573 3a 87 45			ld a, (.dmark)  
4576 32 bd fb			ld (debug_mark),a  
4579 3a 88 45			ld a, (.dmark+1)  
457c 32 be fb			ld (debug_mark+1),a  
457f 3a 89 45			ld a, (.dmark+2)  
4582 32 bf fb			ld (debug_mark+2),a  
4585 18 03			jr .pastdmark  
4587 ..			.dmark: db "AC1"  
458a f1			.pastdmark: pop af  
458b			endm  
# End of macro DMARK
458b						CALLMONITOR 
458b cd 2d 17			call break_point_state  
458e				endm  
# End of macro CALLMONITOR
458e					endif 
458e cd 2b 1d				call forth_push_str 
4591					NEXTW 
4591 c3 26 20			jp macro_next 
4594				endm 
# End of macro NEXTW
4594			 
4594			.EDIT: 
4594				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4594 40				db WORD_SYS_CORE+44             
4595 36 46			dw .ENDKEY            
4597 05				db 4 + 1 
4598 .. 00			db "EDIT",0              
459d				endm 
# End of macro CWHEAD
459d			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
459d			 
459d					; TODO does not copy from stack 
459d					if DEBUG_FORTH_WORDS_KEY 
459d						DMARK "EDT" 
459d f5				push af  
459e 3a b2 45			ld a, (.dmark)  
45a1 32 bd fb			ld (debug_mark),a  
45a4 3a b3 45			ld a, (.dmark+1)  
45a7 32 be fb			ld (debug_mark+1),a  
45aa 3a b4 45			ld a, (.dmark+2)  
45ad 32 bf fb			ld (debug_mark+2),a  
45b0 18 03			jr .pastdmark  
45b2 ..			.dmark: db "EDT"  
45b5 f1			.pastdmark: pop af  
45b6			endm  
# End of macro DMARK
45b6						CALLMONITOR 
45b6 cd 2d 17			call break_point_state  
45b9				endm  
# End of macro CALLMONITOR
45b9					endif 
45b9			 
45b9					;FORTH_DSP 
45b9					FORTH_DSP_VALUEHL 
45b9 cd b4 1e			call macro_dsp_valuehl 
45bc				endm 
# End of macro FORTH_DSP_VALUEHL
45bc			;		inc hl    ; TODO do type check 
45bc			 
45bc			;		call get_word_hl 
45bc e5					push hl 
45bd					if DEBUG_FORTH_WORDS 
45bd						DMARK "EDp" 
45bd f5				push af  
45be 3a d2 45			ld a, (.dmark)  
45c1 32 bd fb			ld (debug_mark),a  
45c4 3a d3 45			ld a, (.dmark+1)  
45c7 32 be fb			ld (debug_mark+1),a  
45ca 3a d4 45			ld a, (.dmark+2)  
45cd 32 bf fb			ld (debug_mark+2),a  
45d0 18 03			jr .pastdmark  
45d2 ..			.dmark: db "EDp"  
45d5 f1			.pastdmark: pop af  
45d6			endm  
# End of macro DMARK
45d6						CALLMONITOR 
45d6 cd 2d 17			call break_point_state  
45d9				endm  
# End of macro CALLMONITOR
45d9					endif 
45d9				;	ld a, 0 
45d9 cd 78 11				call strlenz 
45dc 23					inc hl 
45dd			 
45dd 06 00				ld b, 0 
45df 4d					ld c, l 
45e0			 
45e0 e1					pop hl 
45e1 11 a1 f1				ld de, os_input 
45e4					if DEBUG_FORTH_WORDS_KEY 
45e4						DMARK "EDc" 
45e4 f5				push af  
45e5 3a f9 45			ld a, (.dmark)  
45e8 32 bd fb			ld (debug_mark),a  
45eb 3a fa 45			ld a, (.dmark+1)  
45ee 32 be fb			ld (debug_mark+1),a  
45f1 3a fb 45			ld a, (.dmark+2)  
45f4 32 bf fb			ld (debug_mark+2),a  
45f7 18 03			jr .pastdmark  
45f9 ..			.dmark: db "EDc"  
45fc f1			.pastdmark: pop af  
45fd			endm  
# End of macro DMARK
45fd						CALLMONITOR 
45fd cd 2d 17			call break_point_state  
4600				endm  
# End of macro CALLMONITOR
4600					endif 
4600 ed b0				ldir 
4602			 
4602			 
4602 21 a1 f1				ld hl, os_input 
4605					;ld a, 0 
4605					;ld (hl),a 
4605 3a cc f9				ld a,(f_cursor_ptr) 
4608 16 64				ld d, 100 
460a 0e 00				ld c, 0 
460c 1e 28				ld e, 40 
460e cd 47 0d				call input_str 
4611					; TODO perhaps do a type check and wrap in quotes if not a number 
4611 21 a1 f1				ld hl, os_input 
4614					if DEBUG_FORTH_WORDS 
4614						DMARK "ED1" 
4614 f5				push af  
4615 3a 29 46			ld a, (.dmark)  
4618 32 bd fb			ld (debug_mark),a  
461b 3a 2a 46			ld a, (.dmark+1)  
461e 32 be fb			ld (debug_mark+1),a  
4621 3a 2b 46			ld a, (.dmark+2)  
4624 32 bf fb			ld (debug_mark+2),a  
4627 18 03			jr .pastdmark  
4629 ..			.dmark: db "ED1"  
462c f1			.pastdmark: pop af  
462d			endm  
# End of macro DMARK
462d						CALLMONITOR 
462d cd 2d 17			call break_point_state  
4630				endm  
# End of macro CALLMONITOR
4630					endif 
4630 cd 2b 1d				call forth_push_str 
4633					NEXTW 
4633 c3 26 20			jp macro_next 
4636				endm 
# End of macro NEXTW
4636			 
4636			 
4636			 
4636			.ENDKEY: 
4636			; eof 
4636			 
# End of file forth_words_key.asm
4636			 
4636			if STORAGE_SE 
4636			   	include "forth_words_storage.asm" 
4636			 
4636			; | ## Fixed Storage Words 
4636			 
4636			 
4636			.BREAD: 
4636			  
4636				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4636 3a				db WORD_SYS_CORE+38             
4637 b9 46			dw .BWRITE            
4639 06				db 5 + 1 
463a .. 00			db "BREAD",0              
4640				endm 
# End of macro CWHEAD
4640			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4640				 
4640					if DEBUG_FORTH_WORDS_KEY 
4640						DMARK "BRD" 
4640 f5				push af  
4641 3a 55 46			ld a, (.dmark)  
4644 32 bd fb			ld (debug_mark),a  
4647 3a 56 46			ld a, (.dmark+1)  
464a 32 be fb			ld (debug_mark+1),a  
464d 3a 57 46			ld a, (.dmark+2)  
4650 32 bf fb			ld (debug_mark+2),a  
4653 18 03			jr .pastdmark  
4655 ..			.dmark: db "BRD"  
4658 f1			.pastdmark: pop af  
4659			endm  
# End of macro DMARK
4659						CALLMONITOR 
4659 cd 2d 17			call break_point_state  
465c				endm  
# End of macro CALLMONITOR
465c					endif 
465c			 
465c				FORTH_DSP_VALUEHL 
465c cd b4 1e			call macro_dsp_valuehl 
465f				endm 
# End of macro FORTH_DSP_VALUEHL
465f			 
465f				FORTH_DSP_POP 
465f cd 6c 1f			call macro_forth_dsp_pop 
4662				endm 
# End of macro FORTH_DSP_POP
4662			 
4662				; calc block address 
4662			 
4662 eb				ex de, hl 
4663 3e 40			ld a, STORE_BLOCK_PHY 
4665 cd 9d 0c			call Mult16 
4668			 
4668			 
4668 11 e8 f9			ld de, store_page 
466b			 
466b					if DEBUG_FORTH_WORDS 
466b						DMARK "BR1" 
466b f5				push af  
466c 3a 80 46			ld a, (.dmark)  
466f 32 bd fb			ld (debug_mark),a  
4672 3a 81 46			ld a, (.dmark+1)  
4675 32 be fb			ld (debug_mark+1),a  
4678 3a 82 46			ld a, (.dmark+2)  
467b 32 bf fb			ld (debug_mark+2),a  
467e 18 03			jr .pastdmark  
4680 ..			.dmark: db "BR1"  
4683 f1			.pastdmark: pop af  
4684			endm  
# End of macro DMARK
4684						CALLMONITOR 
4684 cd 2d 17			call break_point_state  
4687				endm  
# End of macro CALLMONITOR
4687					endif 
4687			 
4687 cd 09 03			call storage_read_block 
468a			 
468a cd 43 0d			call ishlzero 
468d 20 05			jr nz, .brfound 
468f			 
468f cd bd 1c			call forth_push_numhl 
4692 18 22			jr .brdone 
4694			 
4694			 
4694			.brfound: 
4694 21 ea f9		        ld hl, store_page+2 
4697			 
4697					if DEBUG_FORTH_WORDS 
4697						DMARK "BR2" 
4697 f5				push af  
4698 3a ac 46			ld a, (.dmark)  
469b 32 bd fb			ld (debug_mark),a  
469e 3a ad 46			ld a, (.dmark+1)  
46a1 32 be fb			ld (debug_mark+1),a  
46a4 3a ae 46			ld a, (.dmark+2)  
46a7 32 bf fb			ld (debug_mark+2),a  
46aa 18 03			jr .pastdmark  
46ac ..			.dmark: db "BR2"  
46af f1			.pastdmark: pop af  
46b0			endm  
# End of macro DMARK
46b0						CALLMONITOR 
46b0 cd 2d 17			call break_point_state  
46b3				endm  
# End of macro CALLMONITOR
46b3					endif 
46b3			 
46b3 cd 2b 1d			call forth_push_str 
46b6			 
46b6			 
46b6			.brdone: 
46b6			 
46b6					NEXTW 
46b6 c3 26 20			jp macro_next 
46b9				endm 
# End of macro NEXTW
46b9			.BWRITE: 
46b9				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
46b9 3a				db WORD_SYS_CORE+38             
46ba 4e 47			dw .BUPD            
46bc 07				db 6 + 1 
46bd .. 00			db "BWRITE",0              
46c4				endm 
# End of macro CWHEAD
46c4			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
46c4			 
46c4					if DEBUG_FORTH_WORDS_KEY 
46c4						DMARK "BWR" 
46c4 f5				push af  
46c5 3a d9 46			ld a, (.dmark)  
46c8 32 bd fb			ld (debug_mark),a  
46cb 3a da 46			ld a, (.dmark+1)  
46ce 32 be fb			ld (debug_mark+1),a  
46d1 3a db 46			ld a, (.dmark+2)  
46d4 32 bf fb			ld (debug_mark+2),a  
46d7 18 03			jr .pastdmark  
46d9 ..			.dmark: db "BWR"  
46dc f1			.pastdmark: pop af  
46dd			endm  
# End of macro DMARK
46dd						CALLMONITOR 
46dd cd 2d 17			call break_point_state  
46e0				endm  
# End of macro CALLMONITOR
46e0					endif 
46e0			 
46e0				FORTH_DSP_VALUEHL 
46e0 cd b4 1e			call macro_dsp_valuehl 
46e3				endm 
# End of macro FORTH_DSP_VALUEHL
46e3			 
46e3				; calc block address 
46e3			 
46e3 eb				ex de, hl 
46e4 3e 40			ld a, STORE_BLOCK_PHY 
46e6 cd 9d 0c			call Mult16 
46e9			 
46e9 e5				push hl         ; address 
46ea			 
46ea				FORTH_DSP_POP 
46ea cd 6c 1f			call macro_forth_dsp_pop 
46ed				endm 
# End of macro FORTH_DSP_POP
46ed			 
46ed				FORTH_DSP_VALUEHL 
46ed cd b4 1e			call macro_dsp_valuehl 
46f0				endm 
# End of macro FORTH_DSP_VALUEHL
46f0			 
46f0				FORTH_DSP_POP 
46f0 cd 6c 1f			call macro_forth_dsp_pop 
46f3				endm 
# End of macro FORTH_DSP_POP
46f3			 
46f3 cd 29 0a			call storage_clear_page 
46f6			 
46f6				; copy string to store page 
46f6			 
46f6 e5				push hl     ; save string address 
46f7			 
46f7 3e 00			ld a, 0 
46f9 cd 83 11			call strlent 
46fc			 
46fc 23				inc hl 
46fd			 
46fd 4d				ld c, l 
46fe 06 00			ld b, 0 
4700			 
4700 e1				pop hl 
4701 11 ea f9			ld de, store_page + 2 
4704					if DEBUG_FORTH_WORDS 
4704						DMARK "BW1" 
4704 f5				push af  
4705 3a 19 47			ld a, (.dmark)  
4708 32 bd fb			ld (debug_mark),a  
470b 3a 1a 47			ld a, (.dmark+1)  
470e 32 be fb			ld (debug_mark+1),a  
4711 3a 1b 47			ld a, (.dmark+2)  
4714 32 bf fb			ld (debug_mark+2),a  
4717 18 03			jr .pastdmark  
4719 ..			.dmark: db "BW1"  
471c f1			.pastdmark: pop af  
471d			endm  
# End of macro DMARK
471d						CALLMONITOR 
471d cd 2d 17			call break_point_state  
4720				endm  
# End of macro CALLMONITOR
4720					endif 
4720 ed b0			ldir 
4722			 
4722			 
4722				; poke the start of the block with flags to prevent high level file ops hitting the block 
4722			 
4722 21 ff ff			ld hl, $ffff 
4725			 
4725 22 e8 f9			ld (store_page), hl	 
4728				 
4728 e1				pop hl    ; get address 
4729 11 e8 f9			ld de, store_page 
472c			 
472c					if DEBUG_FORTH_WORDS 
472c						DMARK "BW2" 
472c f5				push af  
472d 3a 41 47			ld a, (.dmark)  
4730 32 bd fb			ld (debug_mark),a  
4733 3a 42 47			ld a, (.dmark+1)  
4736 32 be fb			ld (debug_mark+1),a  
4739 3a 43 47			ld a, (.dmark+2)  
473c 32 bf fb			ld (debug_mark+2),a  
473f 18 03			jr .pastdmark  
4741 ..			.dmark: db "BW2"  
4744 f1			.pastdmark: pop af  
4745			endm  
# End of macro DMARK
4745						CALLMONITOR 
4745 cd 2d 17			call break_point_state  
4748				endm  
# End of macro CALLMONITOR
4748					endif 
4748			 
4748 cd 6e 03			call storage_write_block 
474b			 
474b					NEXTW 
474b c3 26 20			jp macro_next 
474e				endm 
# End of macro NEXTW
474e			 
474e			.BUPD: 
474e				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
474e 3a				db WORD_SYS_CORE+38             
474f a4 47			dw .BYID            
4751 05				db 4 + 1 
4752 .. 00			db "BUPD",0              
4757				endm 
# End of macro CWHEAD
4757			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
4757			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4757			; | | or completely different file system structure. 
4757			 
4757					if DEBUG_FORTH_WORDS_KEY 
4757						DMARK "BUD" 
4757 f5				push af  
4758 3a 6c 47			ld a, (.dmark)  
475b 32 bd fb			ld (debug_mark),a  
475e 3a 6d 47			ld a, (.dmark+1)  
4761 32 be fb			ld (debug_mark+1),a  
4764 3a 6e 47			ld a, (.dmark+2)  
4767 32 bf fb			ld (debug_mark+2),a  
476a 18 03			jr .pastdmark  
476c ..			.dmark: db "BUD"  
476f f1			.pastdmark: pop af  
4770			endm  
# End of macro DMARK
4770						CALLMONITOR 
4770 cd 2d 17			call break_point_state  
4773				endm  
# End of macro CALLMONITOR
4773					endif 
4773			 
4773				FORTH_DSP_VALUEHL 
4773 cd b4 1e			call macro_dsp_valuehl 
4776				endm 
# End of macro FORTH_DSP_VALUEHL
4776			 
4776				; calc block address 
4776			 
4776 eb				ex de, hl 
4777 3e 40			ld a, STORE_BLOCK_PHY 
4779 cd 9d 0c			call Mult16 
477c			 
477c				FORTH_DSP_POP 
477c cd 6c 1f			call macro_forth_dsp_pop 
477f				endm 
# End of macro FORTH_DSP_POP
477f			 
477f			 
477f 11 e8 f9			ld de, store_page 
4782			 
4782					if DEBUG_FORTH_WORDS 
4782						DMARK "BUe" 
4782 f5				push af  
4783 3a 97 47			ld a, (.dmark)  
4786 32 bd fb			ld (debug_mark),a  
4789 3a 98 47			ld a, (.dmark+1)  
478c 32 be fb			ld (debug_mark+1),a  
478f 3a 99 47			ld a, (.dmark+2)  
4792 32 bf fb			ld (debug_mark+2),a  
4795 18 03			jr .pastdmark  
4797 ..			.dmark: db "BUe"  
479a f1			.pastdmark: pop af  
479b			endm  
# End of macro DMARK
479b						CALLMONITOR 
479b cd 2d 17			call break_point_state  
479e				endm  
# End of macro CALLMONITOR
479e					endif 
479e			 
479e cd 6e 03			call storage_write_block 
47a1			 
47a1					NEXTW 
47a1 c3 26 20			jp macro_next 
47a4				endm 
# End of macro NEXTW
47a4			 
47a4			.BYID: 
47a4			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
47a4			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
47a4			; 
47a4			;		 
47a4			;		if DEBUG_FORTH_WORDS_KEY 
47a4			;			DMARK "BYID" 
47a4			;			CALLMONITOR 
47a4			;		endif 
47a4			; 
47a4			;		; get direct address 
47a4			; 
47a4			;		FORTH_DSP_VALUEHL 
47a4			; 
47a4			;		FORTH_DSP_POP 
47a4			; 
47a4			;	; calc block address 
47a4			; 
47a4			;	ex de, hl 
47a4			;	ld a, STORE_BLOCK_PHY 
47a4			;	call Mult16 
47a4			;	;	do BREAD with number as param 
47a4			;	; push the file name	 
47a4			;	ld de, store_page 
47a4			;	call storage_read_block 
47a4			 ;       ld hl, store_page+2 
47a4			; 
47a4			; 
47a4			;		NEXTW 
47a4			;.BYNAME: 
47a4			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
47a4			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
47a4			;		NEXTW 
47a4			; 
47a4			.DIR: 
47a4				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
47a4 3a				db WORD_SYS_CORE+38             
47a5 a8 48			dw .SAVE            
47a7 04				db 3 + 1 
47a8 .. 00			db "DIR",0              
47ac				endm 
# End of macro CWHEAD
47ac			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
47ac			 
47ac					if DEBUG_FORTH_WORDS_KEY 
47ac						DMARK "DIR" 
47ac f5				push af  
47ad 3a c1 47			ld a, (.dmark)  
47b0 32 bd fb			ld (debug_mark),a  
47b3 3a c2 47			ld a, (.dmark+1)  
47b6 32 be fb			ld (debug_mark+1),a  
47b9 3a c3 47			ld a, (.dmark+2)  
47bc 32 bf fb			ld (debug_mark+2),a  
47bf 18 03			jr .pastdmark  
47c1 ..			.dmark: db "DIR"  
47c4 f1			.pastdmark: pop af  
47c5			endm  
# End of macro DMARK
47c5						CALLMONITOR 
47c5 cd 2d 17			call break_point_state  
47c8				endm  
# End of macro CALLMONITOR
47c8					endif 
47c8 cd ba 03			call storage_get_block_0 
47cb			 
47cb 21 e8 f9			ld hl, store_page     ; get current id count 
47ce 46				ld b, (hl) 
47cf 0e 00			ld c, 0    ; count of files   
47d1					if DEBUG_FORTH_WORDS 
47d1						DMARK "DI1" 
47d1 f5				push af  
47d2 3a e6 47			ld a, (.dmark)  
47d5 32 bd fb			ld (debug_mark),a  
47d8 3a e7 47			ld a, (.dmark+1)  
47db 32 be fb			ld (debug_mark+1),a  
47de 3a e8 47			ld a, (.dmark+2)  
47e1 32 bf fb			ld (debug_mark+2),a  
47e4 18 03			jr .pastdmark  
47e6 ..			.dmark: db "DI1"  
47e9 f1			.pastdmark: pop af  
47ea			endm  
# End of macro DMARK
47ea						CALLMONITOR 
47ea cd 2d 17			call break_point_state  
47ed				endm  
# End of macro CALLMONITOR
47ed					endif 
47ed			 
47ed				; check for empty drive 
47ed			 
47ed 3e 00			ld a, 0 
47ef b8				cp b 
47f0 ca 5e 48			jp z, .dirdone 
47f3			 
47f3				; for each of the current ids do a search for them and if found push to stack 
47f3			 
47f3 c5			.diritem:	push bc 
47f4 21 40 00				ld hl, STORE_BLOCK_PHY 
47f7 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
47f9 58					ld e,b 
47fa			 
47fa			;		if DEBUG_FORTH_WORDS 
47fa			;			DMARK "DI2" 
47fa			;			CALLMONITOR 
47fa			;		endif 
47fa			 
47fa cd 2e 06				call storage_findnextid 
47fd			 
47fd			;		if DEBUG_FORTH_WORDS 
47fd			;			DMARK "DI3" 
47fd			;			CALLMONITOR 
47fd			;		endif 
47fd			 
47fd					; if found hl will be non zero 
47fd			 
47fd cd 43 0d				call ishlzero 
4800			;		ld a, l 
4800			;		add h 
4800			; 
4800			;		cp 0 
4800 28 59				jr z, .dirnotfound 
4802			 
4802					; increase count 
4802			 
4802 c1					pop bc	 
4803 0c					inc c 
4804 c5					push bc 
4805					 
4805			 
4805					; get file header and push the file name 
4805			 
4805 11 e8 f9				ld de, store_page 
4808 cd 09 03				call storage_read_block 
480b			 
480b					; push file id to stack 
480b				 
480b 3a e8 f9				ld a, (store_page) 
480e 26 00				ld h, 0 
4810 6f					ld l, a 
4811 cd bd 1c				call forth_push_numhl 
4814			 
4814					; push extent count to stack  
4814				 
4814 3a ea f9				ld a, (store_page+2) 
4817 26 00				ld h, 0 
4819 6f					ld l, a 
481a cd bd 1c				call forth_push_numhl 
481d			 
481d					; push file name 
481d			 
481d 21 eb f9				ld hl, store_page+3 
4820					if DEBUG_FORTH_WORDS 
4820						DMARK "DI5" 
4820 f5				push af  
4821 3a 35 48			ld a, (.dmark)  
4824 32 bd fb			ld (debug_mark),a  
4827 3a 36 48			ld a, (.dmark+1)  
482a 32 be fb			ld (debug_mark+1),a  
482d 3a 37 48			ld a, (.dmark+2)  
4830 32 bf fb			ld (debug_mark+2),a  
4833 18 03			jr .pastdmark  
4835 ..			.dmark: db "DI5"  
4838 f1			.pastdmark: pop af  
4839			endm  
# End of macro DMARK
4839						CALLMONITOR 
4839 cd 2d 17			call break_point_state  
483c				endm  
# End of macro CALLMONITOR
483c					endif 
483c cd 2b 1d				call forth_push_str 
483f					if DEBUG_FORTH_WORDS 
483f						DMARK "DI6" 
483f f5				push af  
4840 3a 54 48			ld a, (.dmark)  
4843 32 bd fb			ld (debug_mark),a  
4846 3a 55 48			ld a, (.dmark+1)  
4849 32 be fb			ld (debug_mark+1),a  
484c 3a 56 48			ld a, (.dmark+2)  
484f 32 bf fb			ld (debug_mark+2),a  
4852 18 03			jr .pastdmark  
4854 ..			.dmark: db "DI6"  
4857 f1			.pastdmark: pop af  
4858			endm  
# End of macro DMARK
4858						CALLMONITOR 
4858 cd 2d 17			call break_point_state  
485b				endm  
# End of macro CALLMONITOR
485b					endif 
485b			.dirnotfound: 
485b c1					pop bc     
485c 10 95				djnz .diritem 
485e				 
485e			.dirdone:	 
485e					if DEBUG_FORTH_WORDS 
485e						DMARK "DI7" 
485e f5				push af  
485f 3a 73 48			ld a, (.dmark)  
4862 32 bd fb			ld (debug_mark),a  
4865 3a 74 48			ld a, (.dmark+1)  
4868 32 be fb			ld (debug_mark+1),a  
486b 3a 75 48			ld a, (.dmark+2)  
486e 32 bf fb			ld (debug_mark+2),a  
4871 18 03			jr .pastdmark  
4873 ..			.dmark: db "DI7"  
4876 f1			.pastdmark: pop af  
4877			endm  
# End of macro DMARK
4877						CALLMONITOR 
4877 cd 2d 17			call break_point_state  
487a				endm  
# End of macro CALLMONITOR
487a					endif 
487a			 
487a					; push a count of the dir items found 
487a			 
487a 26 00				ld h, 0 
487c 69					ld l, c 
487d cd bd 1c				call forth_push_numhl 
4880			 
4880					; push the bank label 
4880			 
4880 cd ba 03				call storage_get_block_0 
4883			 
4883				 
4883 21 eb f9		 		ld hl, store_page+3 
4886			 
4886					if DEBUG_FORTH_WORDS 
4886						DMARK "DI8" 
4886 f5				push af  
4887 3a 9b 48			ld a, (.dmark)  
488a 32 bd fb			ld (debug_mark),a  
488d 3a 9c 48			ld a, (.dmark+1)  
4890 32 be fb			ld (debug_mark+1),a  
4893 3a 9d 48			ld a, (.dmark+2)  
4896 32 bf fb			ld (debug_mark+2),a  
4899 18 03			jr .pastdmark  
489b ..			.dmark: db "DI8"  
489e f1			.pastdmark: pop af  
489f			endm  
# End of macro DMARK
489f						CALLMONITOR 
489f cd 2d 17			call break_point_state  
48a2				endm  
# End of macro CALLMONITOR
48a2					endif 
48a2 cd 2b 1d				call forth_push_str 
48a5			 
48a5			 
48a5				 
48a5					NEXTW 
48a5 c3 26 20			jp macro_next 
48a8				endm 
# End of macro NEXTW
48a8			.SAVE: 
48a8			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
48a8			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
48a8			;		NEXTW 
48a8			;.LOAD: 
48a8			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
48a8			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
48a8			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
48a8			;; > > The LOAD command can not be used in any user words or compound lines. 
48a8			; 
48a8			;		; store_openext use it. If zero it is EOF 
48a8			; 
48a8			;		; read block from current stream id 
48a8			;		; if the block does not contain zero term keep reading blocks until zero found 
48a8			;		; push the block to stack 
48a8			;		; save the block id to stream 
48a8			; 
48a8			; 
48a8			;		FORTH_DSP_VALUEHL 
48a8			; 
48a8			;;		push hl 
48a8			; 
48a8			;	if DEBUG_STORESE 
48a8			;		DMARK "LOA" 
48a8			;		CALLMONITOR 
48a8			;	endif 
48a8			;		FORTH_DSP_POP 
48a8			; 
48a8			;;		pop hl 
48a8			; 
48a8			;		ld h, l 
48a8			;		ld l, 0 
48a8			; 
48a8			;		push hl     ; stack holds current file id and extent to work with 
48a8			; 
48a8			; 
48a8			;		ld de, store_page      ; get block zero of file 
48a8			;	if DEBUG_STORESE 
48a8			;		DMARK "LO0" 
48a8			;		CALLMONITOR 
48a8			;	endif 
48a8			;		call storage_read 
48a8			; 
48a8			;		ld a, (store_page+2)    ; max extents for this file 
48a8			;		ld  (store_openmaxext),a   ; get our limit 
48a8			; 
48a8			;	if DEBUG_STORESE 
48a8			;		DMARK "LOE" 
48a8			;		CALLMONITOR 
48a8			;	endif 
48a8			; 
48a8			;; TODO dont know why max extents are not present 
48a8			;;		cp 0 
48a8			;;		jp z, .loadeof     ; dont read past eof 
48a8			; 
48a8			;;		ld a, 1   ; start from the head of the file 
48a8			; 
48a8			;.loadline:	pop hl 
48a8			;		inc hl 
48a8			;		ld  a, (store_openmaxext)   ; get our limit 
48a8			;	if DEBUG_STORESE 
48a8			;		DMARK "LOx" 
48a8			;		CALLMONITOR 
48a8			;	endif 
48a8			;		inc a 
48a8			;		cp l 
48a8			;		jp z, .loadeof 
48a8			;		push hl    ; save current extent 
48a8			; 
48a8			;		ld de, store_page 
48a8			; 
48a8			;	if DEBUG_STORESE 
48a8			;		DMARK "LO1" 
48a8			;		CALLMONITOR 
48a8			;	endif 
48a8			;		call storage_read 
48a8			; 
48a8			;	if DEBUG_STORESE 
48a8			;		DMARK "LO2" 
48a8			;		CALLMONITOR 
48a8			;	endif 
48a8			;	call ishlzero 
48a8			;	ld a, l 
48a8			;	add h 
48a8			;	cp 0 
48a8			;	jr z, .loadeof 
48a8			; 
48a8			;	; not eof so hl should point to data to exec 
48a8			; 
48a8			;	; will need to add the FORTH_END_BUFFER flag 
48a8			 ; 
48a8			;	ld hl, store_page+2 
48a8			;	ld bc, 255 
48a8			;	ld a, 0 
48a8			;	cpir 
48a8			;	if DEBUG_STORESE 
48a8			;		DMARK "LOt" 
48a8			;		CALLMONITOR 
48a8			;	endif 
48a8			;	dec hl 
48a8			;	ld a, ' ' 
48a8			;	ld (hl), a 
48a8			;	inc hl 
48a8			;	ld (hl), a 
48a8			;	inc hl 
48a8			;	ld (hl), a 
48a8			;	inc hl 
48a8			;	ld a, FORTH_END_BUFFER 
48a8			;	ld (hl), a 
48a8			; 
48a8			;	; TODO handle more than a single block read 
48a8			; 
48a8			; 
48a8			;	ld hl, store_page+2 
48a8			; 
48a8			;	ld (os_tok_ptr), hl 
48a8			; 
48a8			;	if DEBUG_STORESE 
48a8			;		DMARK "LO3" 
48a8			;		CALLMONITOR 
48a8			;	endif 
48a8			; 
48a8			;	call forthparse 
48a8			;	call forthexec 
48a8			;	call forthexec_cleanup 
48a8			; 
48a8			;	; go to next extent 
48a8			; 
48a8			;	; get next block  or mark as eof 
48a8			;	jp .loadline 
48a8			; 
48a8			; 
48a8			; 
48a8			;	       NEXTW 
48a8			;.loadeof:	ld a, 0 
48a8			;		ld (store_openext), a 
48a8			; 
48a8			;	if DEBUG_STORESE 
48a8			;		DMARK "LOF" 
48a8			;		CALLMONITOR 
48a8			;	endif 
48a8			;		ret 
48a8			;		;NEXTW 
48a8			;.BSAVE:   
48a8			; 
48a8			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
48a8			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
48a8			;		NEXTW 
48a8			;.BLOAD: 
48a8			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
48a8			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
48a8			;		NEXTW 
48a8			;;;; counter gap 
48a8			 
48a8			 
48a8			.SEO: 
48a8				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
48a8 64				db WORD_SYS_CORE+80             
48a9 c7 48			dw .SEI            
48ab 04				db 3 + 1 
48ac .. 00			db "SEO",0              
48b0				endm 
# End of macro CWHEAD
48b0			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
48b0			 
48b0					; get port 
48b0			 
48b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48b0 cd b4 1e			call macro_dsp_valuehl 
48b3				endm 
# End of macro FORTH_DSP_VALUEHL
48b3			 
48b3 e5					push hl    ; u2 - byte 
48b4			 
48b4					; destroy value TOS 
48b4			 
48b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48b4 cd 6c 1f			call macro_forth_dsp_pop 
48b7				endm 
# End of macro FORTH_DSP_POP
48b7			 
48b7					; get byte to send 
48b7			 
48b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48b7 cd b4 1e			call macro_dsp_valuehl 
48ba				endm 
# End of macro FORTH_DSP_VALUEHL
48ba			 
48ba e5					push hl    ; u1 - addr 
48bb			 
48bb					; destroy value TOS 
48bb			 
48bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48bb cd 6c 1f			call macro_forth_dsp_pop 
48be				endm 
# End of macro FORTH_DSP_POP
48be			 
48be					; one value on hl get other one back 
48be			 
48be d1					pop de   ; u1 - byte 
48bf			 
48bf e1					pop hl   ; u2 - addr 
48c0			 
48c0					; TODO Send SPI byte 
48c0			 
48c0			 
48c0 7b					ld a, e 
48c1 cd e7 01				call se_writebyte 
48c4			 
48c4					 
48c4			 
48c4					NEXTW 
48c4 c3 26 20			jp macro_next 
48c7				endm 
# End of macro NEXTW
48c7			 
48c7			.SEI: 
48c7				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
48c7 65				db WORD_SYS_CORE+81             
48c8 e1 48			dw .SFREE            
48ca 04				db 3 + 1 
48cb .. 00			db "SEI",0              
48cf				endm 
# End of macro CWHEAD
48cf			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
48cf			 
48cf					; get port 
48cf			 
48cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48cf cd b4 1e			call macro_dsp_valuehl 
48d2				endm 
# End of macro FORTH_DSP_VALUEHL
48d2			 
48d2			;		push hl 
48d2			 
48d2					; destroy value TOS 
48d2			 
48d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48d2 cd 6c 1f			call macro_forth_dsp_pop 
48d5				endm 
# End of macro FORTH_DSP_POP
48d5			 
48d5					; one value on hl get other one back 
48d5			 
48d5			;		pop hl 
48d5			 
48d5			 
48d5					; TODO Get SPI byte 
48d5			 
48d5 cd 89 02				call se_readbyte 
48d8			 
48d8 26 00				ld h, 0 
48da 6f					ld l, a 
48db cd bd 1c				call forth_push_numhl 
48de			 
48de					NEXTW 
48de c3 26 20			jp macro_next 
48e1				endm 
# End of macro NEXTW
48e1			 
48e1			.SFREE: 
48e1				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
48e1 67				db WORD_SYS_CORE+83             
48e2 10 49			dw .SIZE            
48e4 06				db 5 + 1 
48e5 .. 00			db "FFREE",0              
48eb				endm 
# End of macro CWHEAD
48eb			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
48eb					if DEBUG_FORTH_WORDS_KEY 
48eb						DMARK "FFR" 
48eb f5				push af  
48ec 3a 00 49			ld a, (.dmark)  
48ef 32 bd fb			ld (debug_mark),a  
48f2 3a 01 49			ld a, (.dmark+1)  
48f5 32 be fb			ld (debug_mark+1),a  
48f8 3a 02 49			ld a, (.dmark+2)  
48fb 32 bf fb			ld (debug_mark+2),a  
48fe 18 03			jr .pastdmark  
4900 ..			.dmark: db "FFR"  
4903 f1			.pastdmark: pop af  
4904			endm  
# End of macro DMARK
4904						CALLMONITOR 
4904 cd 2d 17			call break_point_state  
4907				endm  
# End of macro CALLMONITOR
4907					endif 
4907			 
4907 cd c8 06				call storage_freeblocks 
490a			 
490a cd bd 1c				call forth_push_numhl 
490d			 
490d				       NEXTW 
490d c3 26 20			jp macro_next 
4910				endm 
# End of macro NEXTW
4910			.SIZE: 
4910				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4910 67				db WORD_SYS_CORE+83             
4911 44 49			dw .CREATE            
4913 05				db 4 + 1 
4914 .. 00			db "SIZE",0              
4919				endm 
# End of macro CWHEAD
4919			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4919					if DEBUG_FORTH_WORDS_KEY 
4919						DMARK "SIZ" 
4919 f5				push af  
491a 3a 2e 49			ld a, (.dmark)  
491d 32 bd fb			ld (debug_mark),a  
4920 3a 2f 49			ld a, (.dmark+1)  
4923 32 be fb			ld (debug_mark+1),a  
4926 3a 30 49			ld a, (.dmark+2)  
4929 32 bf fb			ld (debug_mark+2),a  
492c 18 03			jr .pastdmark  
492e ..			.dmark: db "SIZ"  
4931 f1			.pastdmark: pop af  
4932			endm  
# End of macro DMARK
4932						CALLMONITOR 
4932 cd 2d 17			call break_point_state  
4935				endm  
# End of macro CALLMONITOR
4935					endif 
4935			 
4935					FORTH_DSP_VALUEHL 
4935 cd b4 1e			call macro_dsp_valuehl 
4938				endm 
# End of macro FORTH_DSP_VALUEHL
4938			;		push hl 
4938					FORTH_DSP_POP 
4938 cd 6c 1f			call macro_forth_dsp_pop 
493b				endm 
# End of macro FORTH_DSP_POP
493b			;		pop hl 
493b cd 38 03				call storage_file_size 
493e			 
493e cd bd 1c				call forth_push_numhl 
4941			  
4941			 
4941				       NEXTW 
4941 c3 26 20			jp macro_next 
4944				endm 
# End of macro NEXTW
4944			 
4944			.CREATE: 
4944				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4944 68				db WORD_SYS_CORE+84             
4945 b2 49			dw .APPEND            
4947 07				db 6 + 1 
4948 .. 00			db "CREATE",0              
494f				endm 
# End of macro CWHEAD
494f			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
494f			; | | e.g.  
494f			; | | TestProgram CREATE 
494f			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
494f			; | |  
494f			; | | Max file IDs are 255. 
494f			; | |  
494f					 
494f					if DEBUG_FORTH_WORDS_KEY 
494f						DMARK "CRT" 
494f f5				push af  
4950 3a 64 49			ld a, (.dmark)  
4953 32 bd fb			ld (debug_mark),a  
4956 3a 65 49			ld a, (.dmark+1)  
4959 32 be fb			ld (debug_mark+1),a  
495c 3a 66 49			ld a, (.dmark+2)  
495f 32 bf fb			ld (debug_mark+2),a  
4962 18 03			jr .pastdmark  
4964 ..			.dmark: db "CRT"  
4967 f1			.pastdmark: pop af  
4968			endm  
# End of macro DMARK
4968						CALLMONITOR 
4968 cd 2d 17			call break_point_state  
496b				endm  
# End of macro CALLMONITOR
496b					endif 
496b			;		call storage_get_block_0 
496b			 
496b					; TODO pop hl 
496b			 
496b					;v5 FORTH_DSP_VALUE 
496b					FORTH_DSP_VALUE 
496b cd 9d 1e			call macro_forth_dsp_value 
496e				endm 
# End of macro FORTH_DSP_VALUE
496e			 
496e				if DEBUG_STORESE 
496e					DMARK "CR1" 
496e f5				push af  
496f 3a 83 49			ld a, (.dmark)  
4972 32 bd fb			ld (debug_mark),a  
4975 3a 84 49			ld a, (.dmark+1)  
4978 32 be fb			ld (debug_mark+1),a  
497b 3a 85 49			ld a, (.dmark+2)  
497e 32 bf fb			ld (debug_mark+2),a  
4981 18 03			jr .pastdmark  
4983 ..			.dmark: db "CR1"  
4986 f1			.pastdmark: pop af  
4987			endm  
# End of macro DMARK
4987					CALLMONITOR 
4987 cd 2d 17			call break_point_state  
498a				endm  
# End of macro CALLMONITOR
498a				endif 
498a			;		push hl 
498a			;		FORTH_DSP_POP 
498a			;		pop hl 
498a			 
498a			;		inc hl   ; move past the type marker 
498a			 
498a cd fe 06				call storage_create 
498d			 
498d				if DEBUG_STORESE 
498d					DMARK "CT1" 
498d f5				push af  
498e 3a a2 49			ld a, (.dmark)  
4991 32 bd fb			ld (debug_mark),a  
4994 3a a3 49			ld a, (.dmark+1)  
4997 32 be fb			ld (debug_mark+1),a  
499a 3a a4 49			ld a, (.dmark+2)  
499d 32 bf fb			ld (debug_mark+2),a  
49a0 18 03			jr .pastdmark  
49a2 ..			.dmark: db "CT1"  
49a5 f1			.pastdmark: pop af  
49a6			endm  
# End of macro DMARK
49a6					CALLMONITOR 
49a6 cd 2d 17			call break_point_state  
49a9				endm  
# End of macro CALLMONITOR
49a9				endif 
49a9			;		push hl 
49a9					FORTH_DSP_POP 
49a9 cd 6c 1f			call macro_forth_dsp_pop 
49ac				endm 
# End of macro FORTH_DSP_POP
49ac			;		pop hl 
49ac					; push file id to stack 
49ac cd bd 1c				call forth_push_numhl 
49af			 
49af			 
49af			 
49af				       NEXTW 
49af c3 26 20			jp macro_next 
49b2				endm 
# End of macro NEXTW
49b2			 
49b2			.APPEND: 
49b2				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
49b2 69				db WORD_SYS_CORE+85             
49b3 43 4a			dw .SDEL            
49b5 07				db 6 + 1 
49b6 .. 00			db "APPEND",0              
49bd				endm 
# End of macro CWHEAD
49bd			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
49bd			; | | e.g. 
49bd			; | | Test CREATE      -> $01 
49bd			; | | "A string to add to file" $01 APPEND 
49bd			; | |  
49bd			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
49bd					if DEBUG_FORTH_WORDS_KEY 
49bd						DMARK "APP" 
49bd f5				push af  
49be 3a d2 49			ld a, (.dmark)  
49c1 32 bd fb			ld (debug_mark),a  
49c4 3a d3 49			ld a, (.dmark+1)  
49c7 32 be fb			ld (debug_mark+1),a  
49ca 3a d4 49			ld a, (.dmark+2)  
49cd 32 bf fb			ld (debug_mark+2),a  
49d0 18 03			jr .pastdmark  
49d2 ..			.dmark: db "APP"  
49d5 f1			.pastdmark: pop af  
49d6			endm  
# End of macro DMARK
49d6						CALLMONITOR 
49d6 cd 2d 17			call break_point_state  
49d9				endm  
# End of macro CALLMONITOR
49d9					endif 
49d9			 
49d9					FORTH_DSP_VALUEHL 
49d9 cd b4 1e			call macro_dsp_valuehl 
49dc				endm 
# End of macro FORTH_DSP_VALUEHL
49dc e5					push hl 	; save file id 
49dd			 
49dd				if DEBUG_STORESE 
49dd					DMARK "AP1" 
49dd f5				push af  
49de 3a f2 49			ld a, (.dmark)  
49e1 32 bd fb			ld (debug_mark),a  
49e4 3a f3 49			ld a, (.dmark+1)  
49e7 32 be fb			ld (debug_mark+1),a  
49ea 3a f4 49			ld a, (.dmark+2)  
49ed 32 bf fb			ld (debug_mark+2),a  
49f0 18 03			jr .pastdmark  
49f2 ..			.dmark: db "AP1"  
49f5 f1			.pastdmark: pop af  
49f6			endm  
# End of macro DMARK
49f6					CALLMONITOR 
49f6 cd 2d 17			call break_point_state  
49f9				endm  
# End of macro CALLMONITOR
49f9				endif 
49f9					FORTH_DSP_POP 
49f9 cd 6c 1f			call macro_forth_dsp_pop 
49fc				endm 
# End of macro FORTH_DSP_POP
49fc			 
49fc					FORTH_DSP_VALUEHL 
49fc cd b4 1e			call macro_dsp_valuehl 
49ff				endm 
# End of macro FORTH_DSP_VALUEHL
49ff					;v5 FORTH_DSP_VALUE 
49ff e5					push hl 	; save ptr to string to save 
4a00			 
4a00				if DEBUG_STORESE 
4a00					DMARK "AP1" 
4a00 f5				push af  
4a01 3a 15 4a			ld a, (.dmark)  
4a04 32 bd fb			ld (debug_mark),a  
4a07 3a 16 4a			ld a, (.dmark+1)  
4a0a 32 be fb			ld (debug_mark+1),a  
4a0d 3a 17 4a			ld a, (.dmark+2)  
4a10 32 bf fb			ld (debug_mark+2),a  
4a13 18 03			jr .pastdmark  
4a15 ..			.dmark: db "AP1"  
4a18 f1			.pastdmark: pop af  
4a19			endm  
# End of macro DMARK
4a19					CALLMONITOR 
4a19 cd 2d 17			call break_point_state  
4a1c				endm  
# End of macro CALLMONITOR
4a1c				endif 
4a1c					FORTH_DSP_POP 
4a1c cd 6c 1f			call macro_forth_dsp_pop 
4a1f				endm 
# End of macro FORTH_DSP_POP
4a1f			 
4a1f d1					pop de 
4a20 e1					pop hl 
4a21				if DEBUG_STORESE 
4a21					DMARK "AP2" 
4a21 f5				push af  
4a22 3a 36 4a			ld a, (.dmark)  
4a25 32 bd fb			ld (debug_mark),a  
4a28 3a 37 4a			ld a, (.dmark+1)  
4a2b 32 be fb			ld (debug_mark+1),a  
4a2e 3a 38 4a			ld a, (.dmark+2)  
4a31 32 bf fb			ld (debug_mark+2),a  
4a34 18 03			jr .pastdmark  
4a36 ..			.dmark: db "AP2"  
4a39 f1			.pastdmark: pop af  
4a3a			endm  
# End of macro DMARK
4a3a					CALLMONITOR 
4a3a cd 2d 17			call break_point_state  
4a3d				endm  
# End of macro CALLMONITOR
4a3d				endif 
4a3d					;inc de ; skip var type indicator 
4a3d			 
4a3d					; TODO how to append numerics???? 
4a3d			 
4a3d cd dd 08				call storage_append		 
4a40			 
4a40				       NEXTW 
4a40 c3 26 20			jp macro_next 
4a43				endm 
# End of macro NEXTW
4a43			.SDEL: 
4a43				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a43 6a				db WORD_SYS_CORE+86             
4a44 8f 4a			dw .OPEN            
4a46 05				db 4 + 1 
4a47 .. 00			db "ERA",0              
4a4b				endm 
# End of macro CWHEAD
4a4b			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4a4b					FORTH_DSP_VALUEHL 
4a4b cd b4 1e			call macro_dsp_valuehl 
4a4e				endm 
# End of macro FORTH_DSP_VALUEHL
4a4e			;		push hl 	; save file id 
4a4e			 
4a4e					if DEBUG_FORTH_WORDS_KEY 
4a4e						DMARK "ERA" 
4a4e f5				push af  
4a4f 3a 63 4a			ld a, (.dmark)  
4a52 32 bd fb			ld (debug_mark),a  
4a55 3a 64 4a			ld a, (.dmark+1)  
4a58 32 be fb			ld (debug_mark+1),a  
4a5b 3a 65 4a			ld a, (.dmark+2)  
4a5e 32 bf fb			ld (debug_mark+2),a  
4a61 18 03			jr .pastdmark  
4a63 ..			.dmark: db "ERA"  
4a66 f1			.pastdmark: pop af  
4a67			endm  
# End of macro DMARK
4a67						CALLMONITOR 
4a67 cd 2d 17			call break_point_state  
4a6a				endm  
# End of macro CALLMONITOR
4a6a					endif 
4a6a				if DEBUG_STORESE 
4a6a					DMARK "ER1" 
4a6a f5				push af  
4a6b 3a 7f 4a			ld a, (.dmark)  
4a6e 32 bd fb			ld (debug_mark),a  
4a71 3a 80 4a			ld a, (.dmark+1)  
4a74 32 be fb			ld (debug_mark+1),a  
4a77 3a 81 4a			ld a, (.dmark+2)  
4a7a 32 bf fb			ld (debug_mark+2),a  
4a7d 18 03			jr .pastdmark  
4a7f ..			.dmark: db "ER1"  
4a82 f1			.pastdmark: pop af  
4a83			endm  
# End of macro DMARK
4a83					CALLMONITOR 
4a83 cd 2d 17			call break_point_state  
4a86				endm  
# End of macro CALLMONITOR
4a86				endif 
4a86					FORTH_DSP_POP 
4a86 cd 6c 1f			call macro_forth_dsp_pop 
4a89				endm 
# End of macro FORTH_DSP_POP
4a89			 
4a89			;		pop hl 
4a89			 
4a89 cd 49 05				call storage_erase 
4a8c				       NEXTW 
4a8c c3 26 20			jp macro_next 
4a8f				endm 
# End of macro NEXTW
4a8f			 
4a8f			.OPEN: 
4a8f				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4a8f 6b				db WORD_SYS_CORE+87             
4a90 1f 4b			dw .READ            
4a92 05				db 4 + 1 
4a93 .. 00			db "OPEN",0              
4a98				endm 
# End of macro CWHEAD
4a98			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4a98			; | | e.g. 
4a98			; | | $01 OPEN $01 DO $01 READ . LOOP 
4a98			; | | 
4a98			; | | Will return with 255 blocks if the file does not exist 
4a98			 
4a98					if DEBUG_FORTH_WORDS_KEY 
4a98						DMARK "OPN" 
4a98 f5				push af  
4a99 3a ad 4a			ld a, (.dmark)  
4a9c 32 bd fb			ld (debug_mark),a  
4a9f 3a ae 4a			ld a, (.dmark+1)  
4aa2 32 be fb			ld (debug_mark+1),a  
4aa5 3a af 4a			ld a, (.dmark+2)  
4aa8 32 bf fb			ld (debug_mark+2),a  
4aab 18 03			jr .pastdmark  
4aad ..			.dmark: db "OPN"  
4ab0 f1			.pastdmark: pop af  
4ab1			endm  
# End of macro DMARK
4ab1						CALLMONITOR 
4ab1 cd 2d 17			call break_point_state  
4ab4				endm  
# End of macro CALLMONITOR
4ab4					endif 
4ab4					; TODO handle multiple file opens 
4ab4			 
4ab4 3e 01			       	ld a, 1 
4ab6 32 df f9				ld (store_openext), a 
4ab9			 
4ab9					; get max extents for this file 
4ab9				 
4ab9								 
4ab9					FORTH_DSP_VALUEHL 
4ab9 cd b4 1e			call macro_dsp_valuehl 
4abc				endm 
# End of macro FORTH_DSP_VALUEHL
4abc			 
4abc 65					ld h, l 
4abd 2e 00				ld l, 0 
4abf			 
4abf				if DEBUG_STORESE 
4abf					DMARK "OPN" 
4abf f5				push af  
4ac0 3a d4 4a			ld a, (.dmark)  
4ac3 32 bd fb			ld (debug_mark),a  
4ac6 3a d5 4a			ld a, (.dmark+1)  
4ac9 32 be fb			ld (debug_mark+1),a  
4acc 3a d6 4a			ld a, (.dmark+2)  
4acf 32 bf fb			ld (debug_mark+2),a  
4ad2 18 03			jr .pastdmark  
4ad4 ..			.dmark: db "OPN"  
4ad7 f1			.pastdmark: pop af  
4ad8			endm  
# End of macro DMARK
4ad8					CALLMONITOR 
4ad8 cd 2d 17			call break_point_state  
4adb				endm  
# End of macro CALLMONITOR
4adb				endif 
4adb			;		push hl 
4adb					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4adb cd 6c 1f			call macro_forth_dsp_pop 
4ade				endm 
# End of macro FORTH_DSP_POP
4ade			;		pop hl 
4ade						 
4ade 11 e8 f9				ld de, store_page      ; get block zero of file 
4ae1 cd 54 08				call storage_read 
4ae4 cd 43 0d			call ishlzero 
4ae7 20 04			jr nz, .opfound 
4ae9			 
4ae9				; file does not exist so indicate with 255 extents in use 
4ae9			 
4ae9 3e ff			ld a, 255 
4aeb 18 29			jr .skipopeneof 
4aed			 
4aed			 
4aed			.opfound: 
4aed			 
4aed			 
4aed 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4af0 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
4af3					 
4af3				if DEBUG_STORESE 
4af3					DMARK "OPx" 
4af3 f5				push af  
4af4 3a 08 4b			ld a, (.dmark)  
4af7 32 bd fb			ld (debug_mark),a  
4afa 3a 09 4b			ld a, (.dmark+1)  
4afd 32 be fb			ld (debug_mark+1),a  
4b00 3a 0a 4b			ld a, (.dmark+2)  
4b03 32 bf fb			ld (debug_mark+2),a  
4b06 18 03			jr .pastdmark  
4b08 ..			.dmark: db "OPx"  
4b0b f1			.pastdmark: pop af  
4b0c			endm  
# End of macro DMARK
4b0c					CALLMONITOR 
4b0c cd 2d 17			call break_point_state  
4b0f				endm  
# End of macro CALLMONITOR
4b0f				endif 
4b0f fe 00				cp 0 
4b11 20 03				jr nz, .skipopeneof 
4b13					; have opened an empty file 
4b13					 
4b13 32 df f9				ld (store_openext), a 
4b16			 
4b16			.skipopeneof: 
4b16			 
4b16 6f					ld l, a 
4b17 26 00				ld h, 0 
4b19 cd bd 1c				call forth_push_numhl 
4b1c			 
4b1c			 
4b1c				       NEXTW 
4b1c c3 26 20			jp macro_next 
4b1f				endm 
# End of macro NEXTW
4b1f			.READ: 
4b1f				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b1f 6c				db WORD_SYS_CORE+88             
4b20 66 4c			dw .EOF            
4b22 05				db 4 + 1 
4b23 .. 00			db "READ",0              
4b28				endm 
# End of macro CWHEAD
4b28			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b28			; | | e.g. 
4b28			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b28			 
4b28					if DEBUG_FORTH_WORDS_KEY 
4b28						DMARK "REA" 
4b28 f5				push af  
4b29 3a 3d 4b			ld a, (.dmark)  
4b2c 32 bd fb			ld (debug_mark),a  
4b2f 3a 3e 4b			ld a, (.dmark+1)  
4b32 32 be fb			ld (debug_mark+1),a  
4b35 3a 3f 4b			ld a, (.dmark+2)  
4b38 32 bf fb			ld (debug_mark+2),a  
4b3b 18 03			jr .pastdmark  
4b3d ..			.dmark: db "REA"  
4b40 f1			.pastdmark: pop af  
4b41			endm  
# End of macro DMARK
4b41						CALLMONITOR 
4b41 cd 2d 17			call break_point_state  
4b44				endm  
# End of macro CALLMONITOR
4b44					endif 
4b44					; store_openext use it. If zero it is EOF 
4b44			 
4b44					; read block from current stream id 
4b44					; if the block does not contain zero term keep reading blocks until zero found 
4b44					; push the block to stack 
4b44					; save the block id to stream 
4b44			 
4b44			 
4b44					FORTH_DSP_VALUEHL 
4b44 cd b4 1e			call macro_dsp_valuehl 
4b47				endm 
# End of macro FORTH_DSP_VALUEHL
4b47			 
4b47			;		push hl 
4b47			 
4b47				if DEBUG_STORESE 
4b47					DMARK "REA" 
4b47 f5				push af  
4b48 3a 5c 4b			ld a, (.dmark)  
4b4b 32 bd fb			ld (debug_mark),a  
4b4e 3a 5d 4b			ld a, (.dmark+1)  
4b51 32 be fb			ld (debug_mark+1),a  
4b54 3a 5e 4b			ld a, (.dmark+2)  
4b57 32 bf fb			ld (debug_mark+2),a  
4b5a 18 03			jr .pastdmark  
4b5c ..			.dmark: db "REA"  
4b5f f1			.pastdmark: pop af  
4b60			endm  
# End of macro DMARK
4b60					CALLMONITOR 
4b60 cd 2d 17			call break_point_state  
4b63				endm  
# End of macro CALLMONITOR
4b63				endif 
4b63					FORTH_DSP_POP 
4b63 cd 6c 1f			call macro_forth_dsp_pop 
4b66				endm 
# End of macro FORTH_DSP_POP
4b66			 
4b66			;		pop hl 
4b66				 
4b66 65					ld h,l 
4b67			 
4b67 3a df f9				ld a, (store_openext) 
4b6a 6f					ld l, a 
4b6b					 
4b6b fe 00				cp 0 
4b6d ca 38 4c				jp z, .ateof     ; dont read past eof 
4b70			 
4b70			 
4b70 11 e8 f9				ld de, store_page 
4b73				if DEBUG_STORESE 
4b73					DMARK "RE1" 
4b73 f5				push af  
4b74 3a 88 4b			ld a, (.dmark)  
4b77 32 bd fb			ld (debug_mark),a  
4b7a 3a 89 4b			ld a, (.dmark+1)  
4b7d 32 be fb			ld (debug_mark+1),a  
4b80 3a 8a 4b			ld a, (.dmark+2)  
4b83 32 bf fb			ld (debug_mark+2),a  
4b86 18 03			jr .pastdmark  
4b88 ..			.dmark: db "RE1"  
4b8b f1			.pastdmark: pop af  
4b8c			endm  
# End of macro DMARK
4b8c					CALLMONITOR 
4b8c cd 2d 17			call break_point_state  
4b8f				endm  
# End of macro CALLMONITOR
4b8f				endif 
4b8f cd 54 08				call storage_read 
4b92			 
4b92				if DEBUG_STORESE 
4b92					DMARK "RE2" 
4b92 f5				push af  
4b93 3a a7 4b			ld a, (.dmark)  
4b96 32 bd fb			ld (debug_mark),a  
4b99 3a a8 4b			ld a, (.dmark+1)  
4b9c 32 be fb			ld (debug_mark+1),a  
4b9f 3a a9 4b			ld a, (.dmark+2)  
4ba2 32 bf fb			ld (debug_mark+2),a  
4ba5 18 03			jr .pastdmark  
4ba7 ..			.dmark: db "RE2"  
4baa f1			.pastdmark: pop af  
4bab			endm  
# End of macro DMARK
4bab					CALLMONITOR 
4bab cd 2d 17			call break_point_state  
4bae				endm  
# End of macro CALLMONITOR
4bae				endif 
4bae cd 43 0d			call ishlzero 
4bb1			;	ld a, l 
4bb1			;	add h 
4bb1			;	cp 0 
4bb1 ca 3e 4c			jp z, .readeof 
4bb4			 
4bb4				; not eof so hl should point to data to push to stack 
4bb4			 
4bb4				if DEBUG_STORESE 
4bb4					DMARK "RE3" 
4bb4 f5				push af  
4bb5 3a c9 4b			ld a, (.dmark)  
4bb8 32 bd fb			ld (debug_mark),a  
4bbb 3a ca 4b			ld a, (.dmark+1)  
4bbe 32 be fb			ld (debug_mark+1),a  
4bc1 3a cb 4b			ld a, (.dmark+2)  
4bc4 32 bf fb			ld (debug_mark+2),a  
4bc7 18 03			jr .pastdmark  
4bc9 ..			.dmark: db "RE3"  
4bcc f1			.pastdmark: pop af  
4bcd			endm  
# End of macro DMARK
4bcd					CALLMONITOR 
4bcd cd 2d 17			call break_point_state  
4bd0				endm  
# End of macro CALLMONITOR
4bd0				endif 
4bd0 cd 2b 1d			call forth_push_str 
4bd3			 
4bd3				if DEBUG_STORESE 
4bd3					DMARK "RE4" 
4bd3 f5				push af  
4bd4 3a e8 4b			ld a, (.dmark)  
4bd7 32 bd fb			ld (debug_mark),a  
4bda 3a e9 4b			ld a, (.dmark+1)  
4bdd 32 be fb			ld (debug_mark+1),a  
4be0 3a ea 4b			ld a, (.dmark+2)  
4be3 32 bf fb			ld (debug_mark+2),a  
4be6 18 03			jr .pastdmark  
4be8 ..			.dmark: db "RE4"  
4beb f1			.pastdmark: pop af  
4bec			endm  
# End of macro DMARK
4bec					CALLMONITOR 
4bec cd 2d 17			call break_point_state  
4bef				endm  
# End of macro CALLMONITOR
4bef				endif 
4bef				; get next block  or mark as eof 
4bef			 
4bef 3a de f9			ld a, (store_openmaxext)   ; get our limit 
4bf2 4f				ld c, a	 
4bf3 3a df f9			ld a, (store_openext) 
4bf6			 
4bf6				if DEBUG_STORESE 
4bf6					DMARK "RE5" 
4bf6 f5				push af  
4bf7 3a 0b 4c			ld a, (.dmark)  
4bfa 32 bd fb			ld (debug_mark),a  
4bfd 3a 0c 4c			ld a, (.dmark+1)  
4c00 32 be fb			ld (debug_mark+1),a  
4c03 3a 0d 4c			ld a, (.dmark+2)  
4c06 32 bf fb			ld (debug_mark+2),a  
4c09 18 03			jr .pastdmark  
4c0b ..			.dmark: db "RE5"  
4c0e f1			.pastdmark: pop af  
4c0f			endm  
# End of macro DMARK
4c0f					CALLMONITOR 
4c0f cd 2d 17			call break_point_state  
4c12				endm  
# End of macro CALLMONITOR
4c12				endif 
4c12 b9				cp c 
4c13 28 29			jr z, .readeof     ; at last extent 
4c15			 
4c15 3c					inc a 
4c16 32 df f9				ld (store_openext), a 
4c19			 
4c19				if DEBUG_STORESE 
4c19					DMARK "RE6" 
4c19 f5				push af  
4c1a 3a 2e 4c			ld a, (.dmark)  
4c1d 32 bd fb			ld (debug_mark),a  
4c20 3a 2f 4c			ld a, (.dmark+1)  
4c23 32 be fb			ld (debug_mark+1),a  
4c26 3a 30 4c			ld a, (.dmark+2)  
4c29 32 bf fb			ld (debug_mark+2),a  
4c2c 18 03			jr .pastdmark  
4c2e ..			.dmark: db "RE6"  
4c31 f1			.pastdmark: pop af  
4c32			endm  
# End of macro DMARK
4c32					CALLMONITOR 
4c32 cd 2d 17			call break_point_state  
4c35				endm  
# End of macro CALLMONITOR
4c35				endif 
4c35			 
4c35			 
4c35				       NEXTW 
4c35 c3 26 20			jp macro_next 
4c38				endm 
# End of macro NEXTW
4c38			.ateof: 
4c38 21 62 4c				ld hl, .showeof 
4c3b cd 2b 1d				call forth_push_str 
4c3e 3e 00		.readeof:	ld a, 0 
4c40 32 df f9				ld (store_openext), a 
4c43			 
4c43					 
4c43				if DEBUG_STORESE 
4c43					DMARK "REF" 
4c43 f5				push af  
4c44 3a 58 4c			ld a, (.dmark)  
4c47 32 bd fb			ld (debug_mark),a  
4c4a 3a 59 4c			ld a, (.dmark+1)  
4c4d 32 be fb			ld (debug_mark+1),a  
4c50 3a 5a 4c			ld a, (.dmark+2)  
4c53 32 bf fb			ld (debug_mark+2),a  
4c56 18 03			jr .pastdmark  
4c58 ..			.dmark: db "REF"  
4c5b f1			.pastdmark: pop af  
4c5c			endm  
# End of macro DMARK
4c5c					CALLMONITOR 
4c5c cd 2d 17			call break_point_state  
4c5f				endm  
# End of macro CALLMONITOR
4c5f				endif 
4c5f				       NEXTW 
4c5f c3 26 20			jp macro_next 
4c62				endm 
# End of macro NEXTW
4c62			 
4c62 .. 00		.showeof:   db "eof", 0 
4c66			 
4c66			 
4c66			.EOF: 
4c66				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4c66 6d				db WORD_SYS_CORE+89             
4c67 a7 4c			dw .FORMAT            
4c69 04				db 3 + 1 
4c6a .. 00			db "EOF",0              
4c6e				endm 
# End of macro CWHEAD
4c6e			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4c6e			; | | e.g. 
4c6e			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4c6e					; TODO if current block id for stream is zero then push true else false 
4c6e			 
4c6e					if DEBUG_FORTH_WORDS_KEY 
4c6e						DMARK "EOF" 
4c6e f5				push af  
4c6f 3a 83 4c			ld a, (.dmark)  
4c72 32 bd fb			ld (debug_mark),a  
4c75 3a 84 4c			ld a, (.dmark+1)  
4c78 32 be fb			ld (debug_mark+1),a  
4c7b 3a 85 4c			ld a, (.dmark+2)  
4c7e 32 bf fb			ld (debug_mark+2),a  
4c81 18 03			jr .pastdmark  
4c83 ..			.dmark: db "EOF"  
4c86 f1			.pastdmark: pop af  
4c87			endm  
# End of macro DMARK
4c87						CALLMONITOR 
4c87 cd 2d 17			call break_point_state  
4c8a				endm  
# End of macro CALLMONITOR
4c8a					endif 
4c8a			 
4c8a					; TODO handlue multiple file streams 
4c8a			 
4c8a					FORTH_DSP_POP     ; for now just get rid of stream id 
4c8a cd 6c 1f			call macro_forth_dsp_pop 
4c8d				endm 
# End of macro FORTH_DSP_POP
4c8d			 
4c8d 2e 01				ld l, 1 
4c8f 3a de f9				ld a, (store_openmaxext) 
4c92 fe 00				cp 0 
4c94 28 09				jr  z, .eofdone   ; empty file 
4c96 3a df f9				ld a, (store_openext) 
4c99 fe 00				cp 0 
4c9b 28 02				jr  z, .eofdone 
4c9d 2e 00				ld l, 0 
4c9f 26 00		.eofdone:	ld h, 0 
4ca1 cd bd 1c				call forth_push_numhl 
4ca4			 
4ca4			 
4ca4				       NEXTW 
4ca4 c3 26 20			jp macro_next 
4ca7				endm 
# End of macro NEXTW
4ca7			 
4ca7			.FORMAT: 
4ca7				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4ca7 6d				db WORD_SYS_CORE+89             
4ca8 f8 4c			dw .LABEL            
4caa 07				db 6 + 1 
4cab .. 00			db "FORMAT",0              
4cb2				endm 
# End of macro CWHEAD
4cb2			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4cb2					; TODO if current block id for stream is zero then push true else false 
4cb2				 
4cb2				if DEBUG_STORESE 
4cb2					DMARK "FOR" 
4cb2 f5				push af  
4cb3 3a c7 4c			ld a, (.dmark)  
4cb6 32 bd fb			ld (debug_mark),a  
4cb9 3a c8 4c			ld a, (.dmark+1)  
4cbc 32 be fb			ld (debug_mark+1),a  
4cbf 3a c9 4c			ld a, (.dmark+2)  
4cc2 32 bf fb			ld (debug_mark+2),a  
4cc5 18 03			jr .pastdmark  
4cc7 ..			.dmark: db "FOR"  
4cca f1			.pastdmark: pop af  
4ccb			endm  
# End of macro DMARK
4ccb					CALLMONITOR 
4ccb cd 2d 17			call break_point_state  
4cce				endm  
# End of macro CALLMONITOR
4cce				endif 
4cce					; Wipes the bank check flags to cause a reformat on next block 0 read 
4cce			 
4cce 21 01 00				ld hl, 1 
4cd1 3e 00				ld a, 0 
4cd3 cd e7 01				call se_writebyte 
4cd6			 
4cd6				if DEBUG_STORESE 
4cd6					DMARK "FO0" 
4cd6 f5				push af  
4cd7 3a eb 4c			ld a, (.dmark)  
4cda 32 bd fb			ld (debug_mark),a  
4cdd 3a ec 4c			ld a, (.dmark+1)  
4ce0 32 be fb			ld (debug_mark+1),a  
4ce3 3a ed 4c			ld a, (.dmark+2)  
4ce6 32 bf fb			ld (debug_mark+2),a  
4ce9 18 03			jr .pastdmark  
4ceb ..			.dmark: db "FO0"  
4cee f1			.pastdmark: pop af  
4cef			endm  
# End of macro DMARK
4cef					CALLMONITOR 
4cef cd 2d 17			call break_point_state  
4cf2				endm  
# End of macro CALLMONITOR
4cf2				endif 
4cf2					; force bank init 
4cf2			 
4cf2 cd ba 03				call storage_get_block_0 
4cf5					 
4cf5				       NEXTW 
4cf5 c3 26 20			jp macro_next 
4cf8				endm 
# End of macro NEXTW
4cf8			.LABEL: 
4cf8				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4cf8 6d				db WORD_SYS_CORE+89             
4cf9 46 4d			dw .STOREPAGE            
4cfb 06				db 5 + 1 
4cfc .. 00			db "LABEL",0              
4d02				endm 
# End of macro CWHEAD
4d02			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d02					; TODO test to see if bank is selected 
4d02				 
4d02					if DEBUG_FORTH_WORDS_KEY 
4d02						DMARK "LBL" 
4d02 f5				push af  
4d03 3a 17 4d			ld a, (.dmark)  
4d06 32 bd fb			ld (debug_mark),a  
4d09 3a 18 4d			ld a, (.dmark+1)  
4d0c 32 be fb			ld (debug_mark+1),a  
4d0f 3a 19 4d			ld a, (.dmark+2)  
4d12 32 bf fb			ld (debug_mark+2),a  
4d15 18 03			jr .pastdmark  
4d17 ..			.dmark: db "LBL"  
4d1a f1			.pastdmark: pop af  
4d1b			endm  
# End of macro DMARK
4d1b						CALLMONITOR 
4d1b cd 2d 17			call break_point_state  
4d1e				endm  
# End of macro CALLMONITOR
4d1e					endif 
4d1e			;	if DEBUG_STORESE 
4d1e			;		DMARK "LBL" 
4d1e			;		CALLMONITOR 
4d1e			;	endif 
4d1e					FORTH_DSP_VALUEHL 
4d1e cd b4 1e			call macro_dsp_valuehl 
4d21				endm 
# End of macro FORTH_DSP_VALUEHL
4d21					;v5FORTH_DSP_VALUE 
4d21					 
4d21			;		push hl 
4d21					FORTH_DSP_POP 
4d21 cd 6c 1f			call macro_forth_dsp_pop 
4d24				endm 
# End of macro FORTH_DSP_POP
4d24			;		pop hl 
4d24			 
4d24			;v5		inc hl   ; move past the type marker 
4d24			 
4d24				if DEBUG_STORESE 
4d24					DMARK "LBl" 
4d24 f5				push af  
4d25 3a 39 4d			ld a, (.dmark)  
4d28 32 bd fb			ld (debug_mark),a  
4d2b 3a 3a 4d			ld a, (.dmark+1)  
4d2e 32 be fb			ld (debug_mark+1),a  
4d31 3a 3b 4d			ld a, (.dmark+2)  
4d34 32 bf fb			ld (debug_mark+2),a  
4d37 18 03			jr .pastdmark  
4d39 ..			.dmark: db "LBl"  
4d3c f1			.pastdmark: pop af  
4d3d			endm  
# End of macro DMARK
4d3d					CALLMONITOR 
4d3d cd 2d 17			call break_point_state  
4d40				endm  
# End of macro CALLMONITOR
4d40				endif 
4d40 cd de 04				call storage_label 
4d43			 
4d43				       NEXTW 
4d43 c3 26 20			jp macro_next 
4d46				endm 
# End of macro NEXTW
4d46			.STOREPAGE: 
4d46				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d46 6d				db WORD_SYS_CORE+89             
4d47 79 4d			dw .LABELS            
4d49 0a				db 9 + 1 
4d4a .. 00			db "STOREPAGE",0              
4d54				endm 
# End of macro CWHEAD
4d54			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4d54					; TODO test to see if bank is selected 
4d54				 
4d54					if DEBUG_FORTH_WORDS_KEY 
4d54						DMARK "STP" 
4d54 f5				push af  
4d55 3a 69 4d			ld a, (.dmark)  
4d58 32 bd fb			ld (debug_mark),a  
4d5b 3a 6a 4d			ld a, (.dmark+1)  
4d5e 32 be fb			ld (debug_mark+1),a  
4d61 3a 6b 4d			ld a, (.dmark+2)  
4d64 32 bf fb			ld (debug_mark+2),a  
4d67 18 03			jr .pastdmark  
4d69 ..			.dmark: db "STP"  
4d6c f1			.pastdmark: pop af  
4d6d			endm  
# End of macro DMARK
4d6d						CALLMONITOR 
4d6d cd 2d 17			call break_point_state  
4d70				endm  
# End of macro CALLMONITOR
4d70					endif 
4d70			;	if DEBUG_STORESE 
4d70			;		DMARK "STP" 
4d70			;		CALLMONITOR 
4d70			;	endif 
4d70			 
4d70 21 e8 f9			ld hl, store_page 
4d73 cd bd 1c			call forth_push_numhl 
4d76			 
4d76			 
4d76				       NEXTW 
4d76 c3 26 20			jp macro_next 
4d79				endm 
# End of macro NEXTW
4d79			.LABELS: 
4d79				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4d79 6d				db WORD_SYS_CORE+89             
4d7a 03 4e			dw .ENDSTORAGE            
4d7c 07				db 6 + 1 
4d7d .. 00			db "LABELS",0              
4d84				endm 
# End of macro CWHEAD
4d84			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4d84					;  
4d84			 
4d84					; save the current device selected to restore afterwards 
4d84				 
4d84 3a ce f9				ld a, (spi_device) 
4d87 f5					push af 
4d88			 
4d88			 
4d88					; run through each of the banks 
4d88			 
4d88 21 01 00				ld hl, 1 
4d8b cd bd 1c				call forth_push_numhl 
4d8e 3e ff				ld a, SPI_CE_HIGH 
4d90 cb 87				res SPI_CE0, a 
4d92 32 ce f9				ld (spi_device), a 
4d95 cd ba 03				call storage_get_block_0 
4d98 21 eb f9				ld hl, store_page+3 
4d9b cd 2b 1d				call forth_push_str 
4d9e			 
4d9e					 
4d9e 21 02 00				ld hl, 2 
4da1 cd bd 1c				call forth_push_numhl 
4da4 3e ff				ld a, SPI_CE_HIGH 
4da6 cb 8f				res SPI_CE1, a 
4da8 32 ce f9				ld (spi_device), a 
4dab cd ba 03				call storage_get_block_0 
4dae 21 eb f9				ld hl, store_page+3 
4db1 cd 2b 1d				call forth_push_str 
4db4			 
4db4					 
4db4 21 03 00				ld hl, 3 
4db7 cd bd 1c				call forth_push_numhl 
4dba 3e ff				ld a, SPI_CE_HIGH 
4dbc cb 97				res SPI_CE2, a 
4dbe 32 ce f9				ld (spi_device), a 
4dc1 cd ba 03				call storage_get_block_0 
4dc4 21 eb f9				ld hl, store_page+3 
4dc7 cd 2b 1d				call forth_push_str 
4dca			 
4dca			 
4dca 21 04 00				ld hl, 4 
4dcd cd bd 1c				call forth_push_numhl 
4dd0 3e ff				ld a, SPI_CE_HIGH 
4dd2 cb 9f				res SPI_CE3, a 
4dd4 32 ce f9				ld (spi_device), a 
4dd7 cd ba 03				call storage_get_block_0 
4dda 21 eb f9				ld hl, store_page+3 
4ddd cd 2b 1d				call forth_push_str 
4de0			 
4de0					 
4de0			 
4de0 21 05 00				ld hl, 5 
4de3 cd bd 1c				call forth_push_numhl 
4de6 3e ff				ld a, SPI_CE_HIGH 
4de8 cb a7				res SPI_CE4, a 
4dea 32 ce f9				ld (spi_device), a 
4ded cd ba 03				call storage_get_block_0 
4df0 21 eb f9				ld hl, store_page+3 
4df3 cd 2b 1d				call forth_push_str 
4df6			 
4df6					 
4df6					; push fixed count of storage devices (on board) for now 
4df6			 
4df6 21 05 00				ld hl, 5 
4df9 cd bd 1c				call forth_push_numhl 
4dfc			 
4dfc					; restore selected device  
4dfc				 
4dfc f1					pop af 
4dfd 32 ce f9				ld (spi_device), a 
4e00			 
4e00				       NEXTW 
4e00 c3 26 20			jp macro_next 
4e03				endm 
# End of macro NEXTW
4e03			 
4e03			.ENDSTORAGE: 
4e03			; eof 
# End of file forth_words_storage.asm
4e03			endif 
4e03				include "forth_words_device.asm" 
4e03			; Device related words 
4e03			 
4e03			; | ## Device Words 
4e03			 
4e03			if SOUND_ENABLE 
4e03			.NOTE: 
4e03				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e03			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e03					if DEBUG_FORTH_WORDS_KEY 
4e03						DMARK "NTE" 
4e03						CALLMONITOR 
4e03					endif 
4e03			 
4e03				 
4e03			 
4e03					NEXTW 
4e03			.AFTERSOUND: 
4e03			endif 
4e03			 
4e03			 
4e03			USE_GPIO: equ 0 
4e03			 
4e03			if USE_GPIO 
4e03			.GP1: 
4e03				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e03			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e03					NEXTW 
4e03			.GP2: 
4e03				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e03			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e03			 
4e03					NEXTW 
4e03			 
4e03			.GP3: 
4e03				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e03			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e03			 
4e03					NEXTW 
4e03			 
4e03			.GP4: 
4e03				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e03			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e03			 
4e03					NEXTW 
4e03			.SIN: 
4e03			 
4e03			 
4e03			endif 
4e03			 
4e03			 
4e03				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e03 33				db WORD_SYS_CORE+31             
4e04 38 4e			dw .SOUT            
4e06 03				db 2 + 1 
4e07 .. 00			db "IN",0              
4e0a				endm 
# End of macro CWHEAD
4e0a			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e0a					if DEBUG_FORTH_WORDS_KEY 
4e0a						DMARK "IN." 
4e0a f5				push af  
4e0b 3a 1f 4e			ld a, (.dmark)  
4e0e 32 bd fb			ld (debug_mark),a  
4e11 3a 20 4e			ld a, (.dmark+1)  
4e14 32 be fb			ld (debug_mark+1),a  
4e17 3a 21 4e			ld a, (.dmark+2)  
4e1a 32 bf fb			ld (debug_mark+2),a  
4e1d 18 03			jr .pastdmark  
4e1f ..			.dmark: db "IN."  
4e22 f1			.pastdmark: pop af  
4e23			endm  
# End of macro DMARK
4e23						CALLMONITOR 
4e23 cd 2d 17			call break_point_state  
4e26				endm  
# End of macro CALLMONITOR
4e26					endif 
4e26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e26 cd b4 1e			call macro_dsp_valuehl 
4e29				endm 
# End of macro FORTH_DSP_VALUEHL
4e29			 
4e29 e5					push hl 
4e2a			 
4e2a					; destroy value TOS 
4e2a			 
4e2a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e2a cd 6c 1f			call macro_forth_dsp_pop 
4e2d				endm 
# End of macro FORTH_DSP_POP
4e2d			 
4e2d					; one value on hl get other one back 
4e2d			 
4e2d c1					pop bc 
4e2e			 
4e2e					; do the sub 
4e2e			;		ex de, hl 
4e2e			 
4e2e ed 68				in l,(c) 
4e30			 
4e30					; save it 
4e30			 
4e30 26 00				ld h,0 
4e32			 
4e32					; TODO push value back onto stack for another op etc 
4e32			 
4e32 cd bd 1c				call forth_push_numhl 
4e35					NEXTW 
4e35 c3 26 20			jp macro_next 
4e38				endm 
# End of macro NEXTW
4e38			.SOUT: 
4e38				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e38 34				db WORD_SYS_CORE+32             
4e39 8b 4e			dw .SPIO            
4e3b 04				db 3 + 1 
4e3c .. 00			db "OUT",0              
4e40				endm 
# End of macro CWHEAD
4e40			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e40					if DEBUG_FORTH_WORDS_KEY 
4e40						DMARK "OUT" 
4e40 f5				push af  
4e41 3a 55 4e			ld a, (.dmark)  
4e44 32 bd fb			ld (debug_mark),a  
4e47 3a 56 4e			ld a, (.dmark+1)  
4e4a 32 be fb			ld (debug_mark+1),a  
4e4d 3a 57 4e			ld a, (.dmark+2)  
4e50 32 bf fb			ld (debug_mark+2),a  
4e53 18 03			jr .pastdmark  
4e55 ..			.dmark: db "OUT"  
4e58 f1			.pastdmark: pop af  
4e59			endm  
# End of macro DMARK
4e59						CALLMONITOR 
4e59 cd 2d 17			call break_point_state  
4e5c				endm  
# End of macro CALLMONITOR
4e5c					endif 
4e5c			 
4e5c					; get port 
4e5c			 
4e5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e5c cd b4 1e			call macro_dsp_valuehl 
4e5f				endm 
# End of macro FORTH_DSP_VALUEHL
4e5f			 
4e5f e5					push hl 
4e60			 
4e60					; destroy value TOS 
4e60			 
4e60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e60 cd 6c 1f			call macro_forth_dsp_pop 
4e63				endm 
# End of macro FORTH_DSP_POP
4e63			 
4e63					; get byte to send 
4e63			 
4e63					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e63 cd b4 1e			call macro_dsp_valuehl 
4e66				endm 
# End of macro FORTH_DSP_VALUEHL
4e66			 
4e66			;		push hl 
4e66			 
4e66					; destroy value TOS 
4e66			 
4e66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e66 cd 6c 1f			call macro_forth_dsp_pop 
4e69				endm 
# End of macro FORTH_DSP_POP
4e69			 
4e69					; one value on hl get other one back 
4e69			 
4e69			;		pop hl 
4e69			 
4e69 c1					pop bc 
4e6a			 
4e6a					if DEBUG_FORTH_WORDS 
4e6a						DMARK "OUT" 
4e6a f5				push af  
4e6b 3a 7f 4e			ld a, (.dmark)  
4e6e 32 bd fb			ld (debug_mark),a  
4e71 3a 80 4e			ld a, (.dmark+1)  
4e74 32 be fb			ld (debug_mark+1),a  
4e77 3a 81 4e			ld a, (.dmark+2)  
4e7a 32 bf fb			ld (debug_mark+2),a  
4e7d 18 03			jr .pastdmark  
4e7f ..			.dmark: db "OUT"  
4e82 f1			.pastdmark: pop af  
4e83			endm  
# End of macro DMARK
4e83						CALLMONITOR 
4e83 cd 2d 17			call break_point_state  
4e86				endm  
# End of macro CALLMONITOR
4e86					endif 
4e86			 
4e86 ed 69				out (c), l 
4e88			 
4e88					NEXTW 
4e88 c3 26 20			jp macro_next 
4e8b				endm 
# End of macro NEXTW
4e8b			 
4e8b			 
4e8b			.SPIO: 
4e8b			 
4e8b			if STORAGE_SE 
4e8b				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4e8b 51				db WORD_SYS_CORE+61             
4e8c 9c 4e			dw .SPICEH            
4e8e 07				db 6 + 1 
4e8f .. 00			db "SPICEL",0              
4e96				endm 
# End of macro CWHEAD
4e96			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4e96			 
4e96 cd 95 01				call spi_ce_low 
4e99			    NEXTW 
4e99 c3 26 20			jp macro_next 
4e9c				endm 
# End of macro NEXTW
4e9c			 
4e9c			.SPICEH: 
4e9c				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4e9c 51				db WORD_SYS_CORE+61             
4e9d ad 4e			dw .SPIOb            
4e9f 07				db 6 + 1 
4ea0 .. 00			db "SPICEH",0              
4ea7				endm 
# End of macro CWHEAD
4ea7			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ea7			 
4ea7 cd 84 01				call spi_ce_high 
4eaa			    NEXTW 
4eaa c3 26 20			jp macro_next 
4ead				endm 
# End of macro NEXTW
4ead			 
4ead			 
4ead			.SPIOb: 
4ead			 
4ead				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4ead 51				db WORD_SYS_CORE+61             
4eae c3 4e			dw .SPII            
4eb0 05				db 4 + 1 
4eb1 .. 00			db "SPIO",0              
4eb6				endm 
# End of macro CWHEAD
4eb6			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4eb6			 
4eb6					; get port 
4eb6			 
4eb6			 
4eb6					; get byte to send 
4eb6			 
4eb6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eb6 cd b4 1e			call macro_dsp_valuehl 
4eb9				endm 
# End of macro FORTH_DSP_VALUEHL
4eb9			 
4eb9			;		push hl    ; u1  
4eb9			 
4eb9					; destroy value TOS 
4eb9			 
4eb9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eb9 cd 6c 1f			call macro_forth_dsp_pop 
4ebc				endm 
# End of macro FORTH_DSP_POP
4ebc			 
4ebc					; one value on hl get other one back 
4ebc			 
4ebc			;		pop hl   ; u2 - addr 
4ebc			 
4ebc					; TODO Send SPI byte 
4ebc			 
4ebc 7d					ld a, l 
4ebd cd b9 00				call spi_send_byte 
4ec0			 
4ec0					NEXTW 
4ec0 c3 26 20			jp macro_next 
4ec3				endm 
# End of macro NEXTW
4ec3			 
4ec3			.SPII: 
4ec3				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4ec3 52				db WORD_SYS_CORE+62             
4ec4 d8 4e			dw .SESEL            
4ec6 06				db 5 + 1 
4ec7 .. 00			db "SPII",0              
4ecc				endm 
# End of macro CWHEAD
4ecc			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4ecc			 
4ecc					; TODO Get SPI byte 
4ecc			 
4ecc cd da 00				call spi_read_byte 
4ecf			 
4ecf 26 00				ld h, 0 
4ed1 6f					ld l, a 
4ed2 cd bd 1c				call forth_push_numhl 
4ed5			 
4ed5					NEXTW 
4ed5 c3 26 20			jp macro_next 
4ed8				endm 
# End of macro NEXTW
4ed8			 
4ed8			 
4ed8			 
4ed8			.SESEL: 
4ed8				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4ed8 66				db WORD_SYS_CORE+82             
4ed9 7c 4f			dw .CARTDEV            
4edb 05				db 4 + 1 
4edc .. 00			db "BANK",0              
4ee1				endm 
# End of macro CWHEAD
4ee1			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4ee1					if DEBUG_FORTH_WORDS_KEY 
4ee1						DMARK "BNK" 
4ee1 f5				push af  
4ee2 3a f6 4e			ld a, (.dmark)  
4ee5 32 bd fb			ld (debug_mark),a  
4ee8 3a f7 4e			ld a, (.dmark+1)  
4eeb 32 be fb			ld (debug_mark+1),a  
4eee 3a f8 4e			ld a, (.dmark+2)  
4ef1 32 bf fb			ld (debug_mark+2),a  
4ef4 18 03			jr .pastdmark  
4ef6 ..			.dmark: db "BNK"  
4ef9 f1			.pastdmark: pop af  
4efa			endm  
# End of macro DMARK
4efa						CALLMONITOR 
4efa cd 2d 17			call break_point_state  
4efd				endm  
# End of macro CALLMONITOR
4efd					endif 
4efd			 
4efd 3e ff				ld a, 255 
4eff 32 d1 f9				ld (spi_cartdev), a 
4f02			 
4f02					; get bank 
4f02			 
4f02					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f02 cd b4 1e			call macro_dsp_valuehl 
4f05				endm 
# End of macro FORTH_DSP_VALUEHL
4f05			 
4f05			;		push hl 
4f05			 
4f05					; destroy value TOS 
4f05			 
4f05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f05 cd 6c 1f			call macro_forth_dsp_pop 
4f08				endm 
# End of macro FORTH_DSP_POP
4f08			 
4f08					; one value on hl get other one back 
4f08			 
4f08			;		pop hl 
4f08			 
4f08			 
4f08 0e ff				ld c, SPI_CE_HIGH 
4f0a 06 30				ld b, '0'    ; human readable bank number 
4f0c			 
4f0c 7d					ld a, l 
4f0d			 
4f0d					if DEBUG_FORTH_WORDS 
4f0d						DMARK "BNK" 
4f0d f5				push af  
4f0e 3a 22 4f			ld a, (.dmark)  
4f11 32 bd fb			ld (debug_mark),a  
4f14 3a 23 4f			ld a, (.dmark+1)  
4f17 32 be fb			ld (debug_mark+1),a  
4f1a 3a 24 4f			ld a, (.dmark+2)  
4f1d 32 bf fb			ld (debug_mark+2),a  
4f20 18 03			jr .pastdmark  
4f22 ..			.dmark: db "BNK"  
4f25 f1			.pastdmark: pop af  
4f26			endm  
# End of macro DMARK
4f26						CALLMONITOR 
4f26 cd 2d 17			call break_point_state  
4f29				endm  
# End of macro CALLMONITOR
4f29					endif 
4f29			 
4f29					; active low 
4f29			 
4f29 fe 00				cp 0 
4f2b 28 28				jr z, .bset 
4f2d fe 01				cp 1 
4f2f 20 04				jr nz, .b2 
4f31 cb 81				res 0, c 
4f33 06 31				ld b, '1'    ; human readable bank number 
4f35 fe 02		.b2:		cp 2 
4f37 20 04				jr nz, .b3 
4f39 cb 89				res 1, c 
4f3b 06 32				ld b, '2'    ; human readable bank number 
4f3d fe 03		.b3:		cp 3 
4f3f 20 04				jr nz, .b4 
4f41 cb 91				res 2, c 
4f43 06 33				ld b, '3'    ; human readable bank number 
4f45 fe 04		.b4:		cp 4 
4f47 20 04				jr nz, .b5 
4f49 cb 99				res 3, c 
4f4b 06 34				ld b, '4'    ; human readable bank number 
4f4d fe 05		.b5:		cp 5 
4f4f 20 04				jr nz, .bset 
4f51 cb a1				res 4, c 
4f53 06 35				ld b, '5'    ; human readable bank number 
4f55			 
4f55			.bset: 
4f55 79					ld a, c 
4f56 32 ce f9				ld (spi_device),a 
4f59 78					ld a, b 
4f5a 32 cd f9				ld (spi_device_id),a 
4f5d					if DEBUG_FORTH_WORDS 
4f5d						DMARK "BN2" 
4f5d f5				push af  
4f5e 3a 72 4f			ld a, (.dmark)  
4f61 32 bd fb			ld (debug_mark),a  
4f64 3a 73 4f			ld a, (.dmark+1)  
4f67 32 be fb			ld (debug_mark+1),a  
4f6a 3a 74 4f			ld a, (.dmark+2)  
4f6d 32 bf fb			ld (debug_mark+2),a  
4f70 18 03			jr .pastdmark  
4f72 ..			.dmark: db "BN2"  
4f75 f1			.pastdmark: pop af  
4f76			endm  
# End of macro DMARK
4f76						CALLMONITOR 
4f76 cd 2d 17			call break_point_state  
4f79				endm  
# End of macro CALLMONITOR
4f79					endif 
4f79			 
4f79					NEXTW 
4f79 c3 26 20			jp macro_next 
4f7c				endm 
# End of macro NEXTW
4f7c			 
4f7c			.CARTDEV: 
4f7c				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4f7c 66				db WORD_SYS_CORE+82             
4f7d 25 50			dw .ENDDEVICE            
4f7f 08				db 7 + 1 
4f80 .. 00			db "CARTDEV",0              
4f88				endm 
# End of macro CWHEAD
4f88			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4f88					if DEBUG_FORTH_WORDS_KEY 
4f88						DMARK "CDV" 
4f88 f5				push af  
4f89 3a 9d 4f			ld a, (.dmark)  
4f8c 32 bd fb			ld (debug_mark),a  
4f8f 3a 9e 4f			ld a, (.dmark+1)  
4f92 32 be fb			ld (debug_mark+1),a  
4f95 3a 9f 4f			ld a, (.dmark+2)  
4f98 32 bf fb			ld (debug_mark+2),a  
4f9b 18 03			jr .pastdmark  
4f9d ..			.dmark: db "CDV"  
4fa0 f1			.pastdmark: pop af  
4fa1			endm  
# End of macro DMARK
4fa1						CALLMONITOR 
4fa1 cd 2d 17			call break_point_state  
4fa4				endm  
# End of macro CALLMONITOR
4fa4					endif 
4fa4			 
4fa4					; disable se storage bank selection 
4fa4			 
4fa4 3e ff				ld a, SPI_CE_HIGH		; ce high 
4fa6 32 ce f9				ld (spi_device), a 
4fa9			 
4fa9					; get bank 
4fa9			 
4fa9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fa9 cd b4 1e			call macro_dsp_valuehl 
4fac				endm 
# End of macro FORTH_DSP_VALUEHL
4fac			 
4fac			;		push hl 
4fac			 
4fac					; destroy value TOS 
4fac			 
4fac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fac cd 6c 1f			call macro_forth_dsp_pop 
4faf				endm 
# End of macro FORTH_DSP_POP
4faf			 
4faf					; one value on hl get other one back 
4faf			 
4faf			;		pop hl 
4faf			 
4faf					; active low 
4faf			 
4faf 0e ff				ld c, 255 
4fb1			 
4fb1 7d					ld a, l 
4fb2					if DEBUG_FORTH_WORDS 
4fb2						DMARK "CDV" 
4fb2 f5				push af  
4fb3 3a c7 4f			ld a, (.dmark)  
4fb6 32 bd fb			ld (debug_mark),a  
4fb9 3a c8 4f			ld a, (.dmark+1)  
4fbc 32 be fb			ld (debug_mark+1),a  
4fbf 3a c9 4f			ld a, (.dmark+2)  
4fc2 32 bf fb			ld (debug_mark+2),a  
4fc5 18 03			jr .pastdmark  
4fc7 ..			.dmark: db "CDV"  
4fca f1			.pastdmark: pop af  
4fcb			endm  
# End of macro DMARK
4fcb						CALLMONITOR 
4fcb cd 2d 17			call break_point_state  
4fce				endm  
# End of macro CALLMONITOR
4fce					endif 
4fce fe 00				cp 0 
4fd0 28 30				jr z, .cset 
4fd2 fe 01				cp 1 
4fd4 20 02				jr nz, .c2 
4fd6 cb 81				res 0, c 
4fd8 fe 02		.c2:		cp 2 
4fda 20 02				jr nz, .c3 
4fdc cb 89				res 1, c 
4fde fe 03		.c3:		cp 3 
4fe0 20 02				jr nz, .c4 
4fe2 cb 91				res 2, c 
4fe4 fe 04		.c4:		cp 4 
4fe6 20 02				jr nz, .c5 
4fe8 cb 99				res 3, c 
4fea fe 05		.c5:		cp 5 
4fec 20 02				jr nz, .c6 
4fee cb a1				res 4, c 
4ff0 fe 06		.c6:		cp 6 
4ff2 20 02				jr nz, .c7 
4ff4 cb a9				res 5, c 
4ff6 fe 07		.c7:		cp 7 
4ff8 20 02				jr nz, .c8 
4ffa cb b1				res 6, c 
4ffc fe 08		.c8:		cp 8 
4ffe 20 02				jr nz, .cset 
5000 cb b9				res 7, c 
5002 79			.cset:		ld a, c 
5003 32 d1 f9				ld (spi_cartdev),a 
5006			 
5006					if DEBUG_FORTH_WORDS 
5006						DMARK "CD2" 
5006 f5				push af  
5007 3a 1b 50			ld a, (.dmark)  
500a 32 bd fb			ld (debug_mark),a  
500d 3a 1c 50			ld a, (.dmark+1)  
5010 32 be fb			ld (debug_mark+1),a  
5013 3a 1d 50			ld a, (.dmark+2)  
5016 32 bf fb			ld (debug_mark+2),a  
5019 18 03			jr .pastdmark  
501b ..			.dmark: db "CD2"  
501e f1			.pastdmark: pop af  
501f			endm  
# End of macro DMARK
501f						CALLMONITOR 
501f cd 2d 17			call break_point_state  
5022				endm  
# End of macro CALLMONITOR
5022					endif 
5022					NEXTW 
5022 c3 26 20			jp macro_next 
5025				endm 
# End of macro NEXTW
5025			endif 
5025			 
5025			.ENDDEVICE: 
5025			; eof 
5025			 
# End of file forth_words_device.asm
5025			 
5025			; var handler 
5025			 
5025			 
5025			.VARS: 
5025				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5025 78				db WORD_SYS_CORE+100             
5026 3d 50			dw .V0Q            
5028 04				db 3 + 1 
5029 .. 00			db "V0!",0              
502d				endm 
# End of macro CWHEAD
502d			;| V0! ( u1 -- )  Store value to v0  | DONE 
502d			 
502d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
502d cd b4 1e			call macro_dsp_valuehl 
5030				endm 
# End of macro FORTH_DSP_VALUEHL
5030			 
5030 11 96 f9				ld de, cli_var_array 
5033			 
5033 eb					ex de, hl 
5034 73					ld (hl), e 
5035 23					inc hl 
5036 72					ld (hl), d 
5037			 
5037					; destroy value TOS 
5037			 
5037					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5037 cd 6c 1f			call macro_forth_dsp_pop 
503a				endm 
# End of macro FORTH_DSP_POP
503a			 
503a				       NEXTW 
503a c3 26 20			jp macro_next 
503d				endm 
# End of macro NEXTW
503d			.V0Q: 
503d				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
503d 79				db WORD_SYS_CORE+101             
503e 4e 50			dw .V1S            
5040 04				db 3 + 1 
5041 .. 00			db "V0@",0              
5045				endm 
# End of macro CWHEAD
5045			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5045 2a 96 f9				ld hl, (cli_var_array) 
5048 cd bd 1c				call forth_push_numhl 
504b			 
504b				       NEXTW 
504b c3 26 20			jp macro_next 
504e				endm 
# End of macro NEXTW
504e			.V1S: 
504e				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
504e 7a				db WORD_SYS_CORE+102             
504f 66 50			dw .V1Q            
5051 04				db 3 + 1 
5052 .. 00			db "V1!",0              
5056				endm 
# End of macro CWHEAD
5056			;| V1! ( u1 -- )  Store value to v1 | DONE 
5056					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5056 cd b4 1e			call macro_dsp_valuehl 
5059				endm 
# End of macro FORTH_DSP_VALUEHL
5059			 
5059 11 98 f9				ld de, cli_var_array+2 
505c				 
505c eb					ex de, hl 
505d 73					ld (hl), e 
505e 23					inc hl 
505f 72					ld (hl), d 
5060			 
5060					; destroy value TOS 
5060			 
5060					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5060 cd 6c 1f			call macro_forth_dsp_pop 
5063				endm 
# End of macro FORTH_DSP_POP
5063				       NEXTW 
5063 c3 26 20			jp macro_next 
5066				endm 
# End of macro NEXTW
5066			.V1Q: 
5066				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5066 7b				db WORD_SYS_CORE+103             
5067 77 50			dw .V2S            
5069 04				db 3 + 1 
506a .. 00			db "V1@",0              
506e				endm 
# End of macro CWHEAD
506e			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
506e 2a 98 f9				ld hl, (cli_var_array+2) 
5071 cd bd 1c				call forth_push_numhl 
5074				       NEXTW 
5074 c3 26 20			jp macro_next 
5077				endm 
# End of macro NEXTW
5077			.V2S: 
5077				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5077 7c				db WORD_SYS_CORE+104             
5078 8f 50			dw .V2Q            
507a 04				db 3 + 1 
507b .. 00			db "V2!",0              
507f				endm 
# End of macro CWHEAD
507f			;| V2! ( u1 -- )  Store value to v2 | DONE 
507f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
507f cd b4 1e			call macro_dsp_valuehl 
5082				endm 
# End of macro FORTH_DSP_VALUEHL
5082			 
5082 11 9a f9				ld de, cli_var_array+4 
5085				 
5085 eb					ex de, hl 
5086 73					ld (hl), e 
5087 23					inc hl 
5088 72					ld (hl), d 
5089			 
5089					; destroy value TOS 
5089			 
5089					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5089 cd 6c 1f			call macro_forth_dsp_pop 
508c				endm 
# End of macro FORTH_DSP_POP
508c				       NEXTW 
508c c3 26 20			jp macro_next 
508f				endm 
# End of macro NEXTW
508f			.V2Q: 
508f				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
508f 7d				db WORD_SYS_CORE+105             
5090 a0 50			dw .V3S            
5092 04				db 3 + 1 
5093 .. 00			db "V2@",0              
5097				endm 
# End of macro CWHEAD
5097			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5097 2a 9a f9				ld hl, (cli_var_array+4) 
509a cd bd 1c				call forth_push_numhl 
509d				       NEXTW 
509d c3 26 20			jp macro_next 
50a0				endm 
# End of macro NEXTW
50a0			.V3S: 
50a0				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
50a0 7c				db WORD_SYS_CORE+104             
50a1 b8 50			dw .V3Q            
50a3 04				db 3 + 1 
50a4 .. 00			db "V3!",0              
50a8				endm 
# End of macro CWHEAD
50a8			;| V3! ( u1 -- )  Store value to v3 | DONE 
50a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50a8 cd b4 1e			call macro_dsp_valuehl 
50ab				endm 
# End of macro FORTH_DSP_VALUEHL
50ab			 
50ab 11 9c f9				ld de, cli_var_array+6 
50ae				 
50ae eb					ex de, hl 
50af 73					ld (hl), e 
50b0 23					inc hl 
50b1 72					ld (hl), d 
50b2			 
50b2					; destroy value TOS 
50b2			 
50b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50b2 cd 6c 1f			call macro_forth_dsp_pop 
50b5				endm 
# End of macro FORTH_DSP_POP
50b5				       NEXTW 
50b5 c3 26 20			jp macro_next 
50b8				endm 
# End of macro NEXTW
50b8			.V3Q: 
50b8				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
50b8 7d				db WORD_SYS_CORE+105             
50b9 c9 50			dw .END            
50bb 04				db 3 + 1 
50bc .. 00			db "V3@",0              
50c0				endm 
# End of macro CWHEAD
50c0			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
50c0 2a 9c f9				ld hl, (cli_var_array+6) 
50c3 cd bd 1c				call forth_push_numhl 
50c6				       NEXTW 
50c6 c3 26 20			jp macro_next 
50c9				endm 
# End of macro NEXTW
50c9			 
50c9			 
50c9			 
50c9			 
50c9			 
50c9			; end of dict marker 
50c9			 
50c9 00			.END:    db WORD_SYS_END 
50ca 00 00			dw 0 
50cc 00				db 0 
50cd			 
50cd			; use to jp here for user dict words to save on macro expansion  
50cd			 
50cd			user_dict_next: 
50cd				NEXTW 
50cd c3 26 20			jp macro_next 
50d0				endm 
# End of macro NEXTW
50d0			 
50d0			 
50d0			user_exec: 
50d0				;    ld hl, <word code> 
50d0				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
50d0				;    call forthexec 
50d0				;    jp user_dict_next   (NEXT) 
50d0			        ;    <word code bytes> 
50d0 eb				ex de, hl 
50d1 2a a4 f2			ld hl,(os_tok_ptr) 
50d4				 
50d4				FORTH_RSP_NEXT 
50d4 cd 64 1c			call macro_forth_rsp_next 
50d7				endm 
# End of macro FORTH_RSP_NEXT
50d7			 
50d7			if DEBUG_FORTH_UWORD 
50d7						DMARK "UEX" 
50d7 f5				push af  
50d8 3a ec 50			ld a, (.dmark)  
50db 32 bd fb			ld (debug_mark),a  
50de 3a ed 50			ld a, (.dmark+1)  
50e1 32 be fb			ld (debug_mark+1),a  
50e4 3a ee 50			ld a, (.dmark+2)  
50e7 32 bf fb			ld (debug_mark+2),a  
50ea 18 03			jr .pastdmark  
50ec ..			.dmark: db "UEX"  
50ef f1			.pastdmark: pop af  
50f0			endm  
# End of macro DMARK
50f0				CALLMONITOR 
50f0 cd 2d 17			call break_point_state  
50f3				endm  
# End of macro CALLMONITOR
50f3			endif 
50f3			 
50f3			 
50f3			 
50f3 eb				ex de, hl 
50f4 22 a4 f2			ld (os_tok_ptr), hl 
50f7				 
50f7				; Don't use next - Skips the first word in uword. 
50f7			 
50f7 c3 b7 20			jp exec1 
50fa			;	NEXT 
50fa			 
50fa			 
50fa			; eof 
# End of file forth_wordsv4.asm
50fa			endif 
50fa			;;;;;;;;;;;;;; Debug code 
50fa			 
50fa			 
50fa			;if DEBUG_FORTH_PARSE 
50fa .. 00		.nowordfound: db "No match",0 
5103 .. 00		.compword:	db "Comparing word ",0 
5113 .. 00		.nextwordat:	db "Next word at",0 
5120 .. 00		.charmatch:	db "Char match",0 
512b			;endif 
512b			if DEBUG_FORTH_JP 
512b			.foundword:	db "Word match. Exec..",0 
512b			endif 
512b			;if DEBUG_FORTH_PUSH 
512b .. 00		.enddict:	db "Dict end. Push.",0 
513b .. 00		.push_str:	db "Pushing string",0 
514a .. 00		.push_num:	db "Pushing number",0 
5159 .. 00		.data_sp:	db "SP:",0 
515d .. 00		.wordinhl:	db "Word in HL (2/0):",0 
516f .. 00		.wordinde:	db "Word in DE (3/0):",0 
5181 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5193			;endif 
5193			;if DEBUG_FORTH_MALLOC 
5193 .. 00		.push_malloc:	db "Malloc address",0 
51a2			;endif 
51a2			 
51a2			 
51a2			 
51a2			; display malloc address and current data stack pointer  
51a2			 
51a2			malloc_error: 
51a2 d5				push de 
51a3 f5				push af 
51a4 e5				push hl 
51a5 cd e6 0a			call clear_display 
51a8 11 ca 51			ld de, .mallocerr 
51ab 3e 00			ld a,0 
51ad			;	ld de,os_word_scratch 
51ad cd f9 0a			call str_at_display 
51b0 3e 11			ld a, display_row_1+17 
51b2 11 bd fb			ld de, debug_mark 
51b5 cd f9 0a			call str_at_display 
51b8 cd 09 0b			call update_display 
51bb				;call break_point_state 
51bb cd 21 67			call cin_wait 
51be			 
51be 3e 20			ld a, ' ' 
51c0 32 94 ef			ld (os_view_disable), a 
51c3 e1				pop hl 
51c4 f1				pop af 
51c5 d1				pop de	 
51c6				CALLMONITOR 
51c6 cd 2d 17			call break_point_state  
51c9				endm  
# End of macro CALLMONITOR
51c9 c9				ret 
51ca			 
51ca .. 00		.mallocerr: 	db "Malloc Error",0 
51d7			;if DEBUG_FORTH_PUSH 
51d7			display_data_sp: 
51d7 f5				push af 
51d8			 
51d8				; see if disabled 
51d8			 
51d8 3a 94 ef			ld a, (os_view_disable) 
51db fe 2a			cp '*' 
51dd 28 67			jr z, .skipdsp 
51df			 
51df e5				push hl 
51e0 e5				push hl 
51e1 e5			push hl 
51e2 cd e6 0a			call clear_display 
51e5 e1			pop hl 
51e6 7c				ld a,h 
51e7 21 a8 f2			ld hl, os_word_scratch 
51ea cd 1b 10			call hexout 
51ed e1				pop hl 
51ee 7d				ld a,l 
51ef 21 aa f2			ld hl, os_word_scratch+2 
51f2 cd 1b 10			call hexout 
51f5 21 ac f2			ld hl, os_word_scratch+4 
51f8 3e 00			ld a,0 
51fa 77				ld (hl),a 
51fb 11 a8 f2			ld de,os_word_scratch 
51fe 3e 14				ld a, display_row_2 
5200 cd f9 0a				call str_at_display 
5203 11 5d 51			ld de, .wordinhl 
5206 3e 00			ld a, display_row_1 
5208			 
5208 cd f9 0a				call str_at_display 
520b 11 bd fb			ld de, debug_mark 
520e 3e 11			ld a, display_row_1+17 
5210			 
5210 cd f9 0a				call str_at_display 
5213			 
5213				; display current data stack pointer 
5213 11 59 51			ld de,.data_sp 
5216 3e 1c				ld a, display_row_2 + 8 
5218 cd f9 0a				call str_at_display 
521b			 
521b 2a 90 f9			ld hl,(cli_data_sp) 
521e e5				push hl 
521f 7c				ld a,h 
5220 21 a8 f2			ld hl, os_word_scratch 
5223 cd 1b 10			call hexout 
5226 e1				pop hl 
5227 7d				ld a,l 
5228 21 aa f2			ld hl, os_word_scratch+2 
522b cd 1b 10			call hexout 
522e 21 ac f2			ld hl, os_word_scratch+4 
5231 3e 00			ld a,0 
5233 77				ld (hl),a 
5234 11 a8 f2			ld de,os_word_scratch 
5237 3e 1f				ld a, display_row_2 + 11 
5239 cd f9 0a				call str_at_display 
523c			 
523c			 
523c cd 09 0b			call update_display 
523f cd 66 0a			call delay1s 
5242 cd 66 0a			call delay1s 
5245 e1				pop hl 
5246			.skipdsp: 
5246 f1				pop af 
5247 c9				ret 
5248			 
5248			display_data_malloc: 
5248			 
5248 f5				push af 
5249 e5				push hl 
524a e5				push hl 
524b e5			push hl 
524c cd e6 0a			call clear_display 
524f e1			pop hl 
5250 7c				ld a,h 
5251 21 a8 f2			ld hl, os_word_scratch 
5254 cd 1b 10			call hexout 
5257 e1				pop hl 
5258 7d				ld a,l 
5259 21 aa f2			ld hl, os_word_scratch+2 
525c cd 1b 10			call hexout 
525f 21 ac f2			ld hl, os_word_scratch+4 
5262 3e 00			ld a,0 
5264 77				ld (hl),a 
5265 11 a8 f2			ld de,os_word_scratch 
5268 3e 14				ld a, display_row_2 
526a cd f9 0a				call str_at_display 
526d 11 93 51			ld de, .push_malloc 
5270 3e 00			ld a, display_row_1 
5272			 
5272 cd f9 0a				call str_at_display 
5275			 
5275				; display current data stack pointer 
5275 11 59 51			ld de,.data_sp 
5278 3e 1c				ld a, display_row_2 + 8 
527a cd f9 0a				call str_at_display 
527d			 
527d 2a 90 f9			ld hl,(cli_data_sp) 
5280 e5				push hl 
5281 7c				ld a,h 
5282 21 a8 f2			ld hl, os_word_scratch 
5285 cd 1b 10			call hexout 
5288 e1				pop hl 
5289 7d				ld a,l 
528a 21 aa f2			ld hl, os_word_scratch+2 
528d cd 1b 10			call hexout 
5290 21 ac f2			ld hl, os_word_scratch+4 
5293 3e 00			ld a,0 
5295 77				ld (hl),a 
5296 11 a8 f2			ld de,os_word_scratch 
5299 3e 1f				ld a, display_row_2 + 11 
529b cd f9 0a				call str_at_display 
529e			 
529e cd 09 0b			call update_display 
52a1 cd 66 0a			call delay1s 
52a4 cd 66 0a			call delay1s 
52a7 e1				pop hl 
52a8 f1				pop af 
52a9 c9				ret 
52aa			;endif 
52aa			 
52aa			include "forth_autostart.asm" 
52aa			; list of commands to perform at system start up 
52aa			 
52aa			startcmds: 
52aa			;	dw test11 
52aa			;	dw test12 
52aa			;	dw test13 
52aa			;	dw test14 
52aa			;	dw test15 
52aa			;	dw test16 
52aa			;	dw test17 
52aa			;	dw ifthtest1 
52aa			;	dw ifthtest2 
52aa			;	dw ifthtest3 
52aa			;	dw mmtest1 
52aa			;	dw mmtest2 
52aa			;	dw mmtest3 
52aa			;	dw mmtest4 
52aa			;	dw mmtest5 
52aa			;	dw mmtest6 
52aa			;	dw iftest1 
52aa			;	dw iftest2 
52aa			;	dw iftest3 
52aa			;	dw looptest1 
52aa			;	dw looptest2 
52aa			;	dw test1 
52aa			;	dw test2 
52aa			;	dw test3 
52aa			;	dw test4 
52aa			;	dw game2r 
52aa			;	dw game2b1 
52aa			;	dw game2b2 
52aa			 
52aa				; start up words that are actually useful 
52aa			 
52aa 08 53			dw clrstack 
52ac 3b 53			dw type 
52ae fc 54			dw stest 
52b0 5f 53			dw strncpy 
52b2 9d 54			dw list 
52b4 c0 53			dw start1 
52b6 d2 53			dw start2 
52b8			;	dw start3 
52b8 e5 53			dw start3b 
52ba 3d 54			dw start3c 
52bc			 
52bc				; (unit) testing words 
52bc			 
52bc 73 55			dw mtesta 
52be 28 56			dw mtestb 
52c0 cb 56			dw mtestc 
52c2 80 57			dw mtestd 
52c4 24 58			dw mteste 
52c6			 
52c6				; demo/game words 
52c6			 
52c6 30 5f		        dw game3w 
52c8 5e 5f		        dw game3p 
52ca 7c 5f		        dw game3sc 
52cc ad 5f		        dw game3vsi 
52ce d9 5f		        dw game3vs 
52d0				 
52d0 23 5d			dw game2b 
52d2 91 5d			dw game2bf 
52d4 db 5d			dw game2mba 
52d6 71 5e			dw game2mbas 
52d8 b3 5e			dw game2mb 
52da			 
52da e4 59			dw game1 
52dc f5 59			dw game1a 
52de 57 5a			dw game1b 
52e0 8c 5a			dw game1c 
52e2 c2 5a			dw game1d 
52e4 f3 5a			dw game1s 
52e6 07 5b			dw game1t 
52e8 1c 5b			dw game1f 
52ea 50 5b			dw game1z 
52ec 94 5b			dw game1zz 
52ee			 
52ee da 58			dw test5 
52f0 12 59			dw test6 
52f2 4a 59			dw test7 
52f4 5e 59			dw test8 
52f6 8a 59			dw test9 
52f8 a0 59			dw test10 
52fa				 
52fa 6b 5c		        dw ssv5 
52fc 4f 5c		        dw ssv4 
52fe 33 5c		        dw ssv3 
5300 fd 5b		        dw ssv2 
5302 84 5c		        dw ssv1 
5304 cc 5c		        dw ssv1cpm 
5306			;	dw keyup 
5306			;	dw keydown 
5306			;	dw keyleft 
5306			;	dw keyright 
5306			;	dw 	keyf1 
5306			;	dw keyf2 
5306			;	dw keyf3 
5306			;	dw keyf4 
5306			;	dw keyf5 
5306			;	dw keyf6 
5306			;	dw keyf7 
5306			;	dw keyf8 
5306			;	dw keyf9 
5306			;	dw keyf10 
5306			;	dw keyf11 
5306			;	dw keyf12 
5306			;	dw keytab 
5306			;	dw keycr 
5306			;	dw keyhome 
5306			;	dw keyend 
5306			;	dw keybs 
5306 00 00			db 0, 0	 
5308			 
5308			 
5308			; clear stack  
5308			 
5308 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
533b			 
533b			; type ( addr count - ) 
533b .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
535f			 
535f			; some direct memory words 
535f			; strncpy ( len t f -- t ) 
535f			 
535f .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
53c0			 
53c0 .. 00		start1:     	db ": bpon $0000 bp ;",0 
53d2 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
53e5			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
53e5 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
543d .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
549d			 
549d			 
549d			; a handy word to list items on the stack 
549d			 
549d .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
54fc			 
54fc			 
54fc			; test stack  
54fc			; rnd8 stest 
54fc			 
54fc .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5573			 
5573			; random malloc and free cycles 
5573			 
5573 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5628			 
5628			; fixed malloc and free cycles 
5628			 
5628 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56cb			 
56cb			; fixed double string push and drop cycle  
56cb			 
56cb .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5780			 
5780			; consistent fixed string push and drop cycle  
5780			 
5780 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5824			 
5824 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
58da			 
58da			;test1:		db ": aa 1 2 3 ;", 0 
58da			;test2:     	db "111 aa 888 999",0 
58da			;test3:     	db ": bb 77 ;",0 
58da			;test4:     	db "$02 $01 do i . loop bb",0 
58da			 
58da .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5912 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
594a .. 00		test7:     	db ": box hline vline ;",0 
595e .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
598a .. 00		test9:     	db ": sw $01 adsp world ;",0 
59a0 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
59c5 .. 00		test11:     	db "hello create .",0 
59d4 .. 00		test12:     	db "hello2 create .",0 
59e4			 
59e4			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
59e4			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
59e4			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
59e4			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
59e4			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
59e4			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
59e4			 
59e4			;iftest1:     	db "$0001 IF cls .",0 
59e4			;iftest2:     	db "$0000 IF cls .",0 
59e4			;iftest3:     	db "$0002 $0003 - IF cls .",0 
59e4			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
59e4			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
59e4			 
59e4			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59e4			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59e4			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59e4			 
59e4			 
59e4			 
59e4			; a small guess the number game 
59e4			 
59e4 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
59f5 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a57			 
5a57 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5a8c .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5ac2 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5af3 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b07 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b1c .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b50 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5b94			 
5b94			; Using 'ga' save a high score across multiple runs using external storage 
5b94			 
5b94 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5bfd			 
5bfd			 
5bfd			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5bfd			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5bfd			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5bfd			 
5bfd			; simple screen saver to test code memory reuse to destruction 
5bfd			 
5bfd .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c33 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c4f .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5c6b .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5c84 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5ccc .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d23			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d23			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d23			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d23			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d23			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d23			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d23			 
5d23			 
5d23			 
5d23			; minesweeper/battleship finding game 
5d23			; draws a game board of random ship/mine positions 
5d23			; user enters coords to see if it hits on 
5d23			; game ends when all are hit 
5d23			; when hit or miss says how many may be in the area 
5d23			 
5d23			; setup the game board and then hide it 
5d23 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5d91 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5ddb			; prompt for where to target 
5ddb .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5e71 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5e96			; TODO see if the entered coords hits or misses pushes char hit of miss 
5e96 .. 00		game2mbht:      db ": mbckht nop ;",0 
5ea5 .. 00		game2mbms:      db ": mbcms nop ;",0 
5eb3			; TODO how many might be near by 
5eb3 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f30			 
5f30			; Game 3 
5f30			 
5f30			; Vert scroller ski game - avoid the trees! 
5f30			 
5f30			; v0 score (ie turns) 
5f30			; v1 player pos 
5f30			; v2 left wall 
5f30			; v3 right wall 
5f30			 
5f30			; Draw side walls randomly 
5f30			 
5f30 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f5e			 
5f5e			; Draw player 
5f5e .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5f7c			 
5f7c			; TODO Get Key 
5f7c			 
5f7c			; TODO Move left right 
5f7c			 
5f7c			; scroll and move walls a bit 
5f7c			 
5f7c .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5fad			 
5fad			; main game loop 
5fad			 
5fad .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5fd9 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6018			 
6018			; key board defs 
6018			 
6018 .. 00		keyup:       db ": keyup $05 ;",0 
6026 .. 00		keydown:       db ": keydown $0a ;",0 
6036 .. 00		keyleft:       db ": keyleft $0b ;",0 
6046 .. 00		keyright:       db ": keyright $0c ;",0 
6057 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6065 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6073 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6081 .. 00		keyf4:       db ": keyf4 $13 ;",0 
608f .. 00		keyf5:       db ": keyf5 $14 ;",0 
609d .. 00		keyf6:       db ": keyf6 $15 ;",0 
60ab .. 00		keyf7:       db ": keyf7 $16 ;",0 
60b9 .. 00		keyf8:       db ": keyf8 $17 ;",0 
60c7 .. 00		keyf9:       db ": keyf9 $18 ;",0 
60d5 .. 00		keyf10:       db ": keyf10 $19 ;",0 
60e4 .. 00		keyf11:       db ": keyf11 $1a ;",0 
60f3 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6102			 
6102 .. 00		keytab:       db ": keytab $09 ;",0 
6111 .. 00		keycr:       db ": keycr $0d ;",0 
611f .. 00		keyhome:       db ": keyhome $0e ;",0 
612f .. 00		keyend:       db ": keyend $0f ;",0 
613e .. 00		keybs:       db ": keybs $08 ;",0 
614c			 
614c			   
614c			 
614c			 
614c			 
614c			; eof 
# End of file forth_autostart.asm
614c			 
614c .. 00		sprompt1: db "Startup load...",0 
615c .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6172			 
6172			 
6172			 
6172			 
6172			forth_startup: 
6172 21 aa 52			ld hl, startcmds 
6175 3e 00			ld a, 0 
6177 32 c9 f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
617a			 
617a e5			.start1:	push hl 
617b cd e6 0a			call clear_display 
617e 11 4c 61			ld de, sprompt1 
6181 3e 00		        ld a, display_row_1 
6183 cd f9 0a			call str_at_display 
6186 11 5c 61			ld de, sprompt2 
6189 3e 14		        ld a, display_row_2 
618b cd f9 0a			call str_at_display 
618e e1				pop hl 
618f e5				push hl 
6190 5e				ld e,(hl) 
6191 23				inc hl 
6192 56				ld d,(hl) 
6193 3e 28		        ld a, display_row_3 
6195 cd f9 0a			call str_at_display 
6198 cd 09 0b			call update_display 
619b			 
619b			 
619b 3a c9 f3			ld a, (os_last_cmd) 
619e fe 00			cp 0 
61a0 28 05			jr z, .startprompt 
61a2 cd 5a 0a			call delay250ms 
61a5 18 24			jr .startdo 
61a7				 
61a7				 
61a7			 
61a7			.startprompt: 
61a7			 
61a7 3e 4f			ld a,display_row_4 + display_cols - 1 
61a9 11 33 1c		        ld de, endprg 
61ac cd f9 0a			call str_at_display 
61af cd 09 0b			call update_display 
61b2 cd 66 0a			call delay1s 
61b5 cd 21 67			call cin_wait 
61b8						 
61b8 fe 2a			cp '*' 
61ba 28 5e			jr z, .startupend1 
61bc fe 23			cp '#' 
61be 20 07			jr nz, .startno 
61c0 3e 01			ld a, 1 
61c2 32 c9 f3			ld (os_last_cmd),a 
61c5 18 04			jr .startdo 
61c7 fe 31		.startno:	cp '1' 
61c9 28 3a			jr z,.startnxt  
61cb			 
61cb				; exec startup line 
61cb			.startdo:	 
61cb e1				pop hl 
61cc e5				push hl 
61cd				 
61cd 5e				ld e,(hl) 
61ce 23				inc hl 
61cf 56				ld d,(hl) 
61d0 eb				ex de,hl 
61d1			 
61d1 e5				push hl 
61d2			 
61d2 3e 00			ld a, 0 
61d4				;ld a, FORTH_END_BUFFER 
61d4 cd 83 11			call strlent 
61d7 23				inc hl   ; include zero term to copy 
61d8 06 00			ld b,0 
61da 4d				ld c,l 
61db e1				pop hl 
61dc 11 a3 ef			ld de, scratch 
61df ed b0			ldir 
61e1			 
61e1			 
61e1 21 a3 ef			ld hl, scratch 
61e4 cd 74 20			call forthparse 
61e7 cd b4 20			call forthexec 
61ea cd cb 1f			call forthexec_cleanup 
61ed			 
61ed 3e 3c			ld a, display_row_4 
61ef 11 d7 19			ld de, endprog 
61f2			 
61f2 cd 09 0b			call update_display		 
61f5			 
61f5 3a c9 f3			ld a, (os_last_cmd) 
61f8 fe 00			cp 0 
61fa 20 09			jr nz, .startnxt 
61fc cd 35 1c			call next_page_prompt 
61ff cd e6 0a		        call clear_display 
6202 cd 09 0b			call update_display		 
6205			 
6205				; move onto next startup line? 
6205			.startnxt: 
6205			 
6205 cd 5a 0a			call delay250ms 
6208 e1				pop hl 
6209			 
6209 23				inc hl 
620a 23				inc hl 
620b			 
620b e5				push hl 
620c 5e				ld e, (hl) 
620d 23				inc hl 
620e 56				ld d, (hl) 
620f e1				pop hl 
6210				; TODO replace 0 test 
6210			 
6210 eb				ex de, hl 
6211 cd 43 0d			call ishlzero 
6214			;	ld a,e 
6214			;	add d 
6214			;	cp 0    ; any left to do? 
6214 eb				ex de, hl 
6215 c2 7a 61			jp nz, .start1 
6218 18 01			jr .startupend 
621a			 
621a e1			.startupend1: pop hl 
621b			.startupend: 
621b			 
621b cd e6 0a			call clear_display 
621e cd 09 0b			call update_display 
6221 c9				ret 
6222			 
6222			 
6222			; stack over and underflow checks 
6222			 
6222			; init the words to detect the under/overflow 
6222			 
6222			chk_stk_init: 
6222				; a vague random number to check so we dont get any "lucky" hits 
6222 3e 2d			ld a, 45 
6224 6f				ld l, a 
6225 00				nop 
6226 3e 17			ld a, 23 
6228 67				ld h, a 
6229			 
6229 22 8a ef			ld (chk_word), hl     ; the word we need to check against 
622c			 
622c			;	ld (chk_stund), hl	; stack points.... 
622c 22 fd fb			ld (chk_stovr), hl 
622f 22 8e f9			ld (chk_ret_und), hl 
6232 22 0c f9			ld (chk_ret_ovr), hl 
6235 22 0a f7			ld (chk_loop_ovr), hl 
6238 22 08 f5			ld (chk_data_ovr), hl 
623b c9				ret 
623c				 
623c			check_stacks: 
623c				; check all stack words 
623c			 
623c e5				push hl 
623d d5				push de 
623e			 
623e			;	ld de,(chk_word) 
623e			;	ld hl, (chk_stund)	; stack points.... 
623e			;	if DEBUG_STK_FAULT 
623e			;		DMARK "FAa" 
623e			;		CALLMONITOR 
623e			;	endif 
623e			;	call cmp16 
623e			;	jp z, .chk_faulta 
623e			; 
623e			;	ld de, sfaultsu 
623e			;	jp .chk_fault 
623e			 
623e 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
6241 ed 5b 8a ef		ld de,(chk_word) 
6245				if DEBUG_STK_FAULT 
6245					DMARK "FAb" 
6245					CALLMONITOR 
6245				endif 
6245 cd 38 0d			call cmp16 
6248 28 06			jr z, .chk_fault1 
624a 11 eb 62			ld de, sfaultso 
624d c3 9f 62			jp .chk_fault 
6250			.chk_fault1:  
6250 2a 8e f9			ld hl, (chk_ret_und) 
6253 ed 5b 8a ef		ld de,(chk_word) 
6257				if DEBUG_STK_FAULT 
6257					DMARK "FAU" 
6257					CALLMONITOR 
6257				endif 
6257 cd 38 0d			call cmp16 
625a ca 63 62			jp z, .chk_fault2 
625d 11 fb 62			ld de, sfaultru 
6260 c3 9f 62			jp .chk_fault 
6263			.chk_fault2:  
6263 2a 0c f9			ld hl, (chk_ret_ovr) 
6266 ed 5b 8a ef		ld de,(chk_word) 
626a				if DEBUG_STK_FAULT 
626a					DMARK "FA1" 
626a					CALLMONITOR 
626a				endif 
626a cd 38 0d			call cmp16 
626d ca 76 62			jp z, .chk_fault3 
6270 11 09 63			ld de, sfaultro 
6273 c3 9f 62			jp .chk_fault 
6276			.chk_fault3:  
6276 2a 0a f7			ld hl, (chk_loop_ovr) 
6279 ed 5b 8a ef		ld de,(chk_word) 
627d				if DEBUG_STK_FAULT 
627d					DMARK "FA2" 
627d					CALLMONITOR 
627d				endif 
627d cd 38 0d			call cmp16 
6280 ca 89 62			jp z, .chk_fault4 
6283 11 23 63			ld de, sfaultlo 
6286 c3 9f 62			jp .chk_fault 
6289			.chk_fault4:  
6289 2a 08 f5			ld hl, (chk_data_ovr) 
628c ed 5b 8a ef		ld de,(chk_word) 
6290				if DEBUG_STK_FAULT 
6290					DMARK "FA3" 
6290					CALLMONITOR 
6290				endif 
6290 cd 38 0d			call cmp16 
6293 ca 9c 62			jp z, .chk_fault5 
6296 11 3d 63			ld de, sfaultdo 
6299 c3 9f 62			jp .chk_fault 
629c			 
629c			 
629c			.chk_fault5:  
629c d1				pop de 
629d e1				pop hl 
629e			 
629e c9				ret 
629f			 
629f cd e6 0a		.chk_fault: 	call clear_display 
62a2 3e 14				ld a, display_row_2 
62a4 cd f9 0a				call str_at_display 
62a7 11 cd 62				   ld de, .stackfault 
62aa 3e 00				ld a, display_row_1 
62ac cd f9 0a				call str_at_display 
62af 11 bd fb				    ld de, debug_mark 
62b2 3e 11				ld a, display_row_1+17 
62b4 cd f9 0a				call str_at_display 
62b7 cd 09 0b				call update_display 
62ba			 
62ba				; prompt before entering montior for investigating issue 
62ba			 
62ba 3e 3c			ld a, display_row_4 
62bc 11 d7 19			ld de, endprog 
62bf			 
62bf cd 09 0b			call update_display		 
62c2			 
62c2 cd 35 1c			call next_page_prompt 
62c5			 
62c5 d1				pop de 
62c6 e1				pop hl 
62c7 cd 2b 1a				call monitor 
62ca c3 22 19				jp warmstart 
62cd					;jp 0 
62cd					;halt 
62cd			 
62cd			 
62cd			 
62cd .. 00		.stackfault: 	db "Stack fault:",0 
62da			 
62da .. 00		sfaultsu: 	db	"Stack under flow",0 
62eb .. 00		sfaultso: 	db	"Stack over flow",0 
62fb .. 00		sfaultru:	db "RTS underflow",0 
6309 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6323 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
633d .. 00		sfaultdo:	db "DTS overflow", 0 
634a			 
634a			 
634a			fault_dsp_under: 
634a 11 5c 63			ld de, .dsp_under 
634d c3 0c 64			jp .show_fault 
6350			 
6350			fault_rsp_under: 
6350 11 6a 63			ld de, .rsp_under 
6353 c3 0c 64			jp .show_fault 
6356			fault_loop_under: 
6356 11 78 63			ld de, .loop_under 
6359 c3 0c 64			jp .show_fault 
635c			 
635c .. 00		.dsp_under: db "DSP Underflow",0 
636a .. 00		.rsp_under: db "RSP Underflow",0 
6378 .. 00		.loop_under: db "LOOP Underflow",0 
6387			 
6387			 
6387 d5			type_faultn: 	push de 
6388 e5					push hl 
6389 cd e6 0a				call clear_display 
638c 11 b3 63				   ld de, .typefaultn 
638f 3e 00				ld a, display_row_1 
6391 cd f9 0a				call str_at_display 
6394 11 bd fb				    ld de, debug_mark 
6397 3e 11				ld a, display_row_1+17 
6399 cd f9 0a				call str_at_display 
639c cd 09 0b				call update_display 
639f			 
639f				; prompt before entering montior for investigating issue 
639f			 
639f 3e 3c			ld a, display_row_4 
63a1 11 d7 19			ld de, endprog 
63a4			 
63a4 cd 09 0b			call update_display		 
63a7			 
63a7 cd 35 1c			call next_page_prompt 
63aa			 
63aa e5					push hl 
63ab d5					push de 
63ac cd 2b 1a				call monitor 
63af c3 22 19				jp warmstart 
63b2 76					halt 
63b3			 
63b3			 
63b3 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
63ca			 
63ca d5			type_faults: 	push de 
63cb e5					push hl 
63cc cd e6 0a				call clear_display 
63cf 11 f5 63				   ld de, .typefaults 
63d2 3e 00				ld a, display_row_1 
63d4 cd f9 0a				call str_at_display 
63d7 11 bd fb				    ld de, debug_mark 
63da 3e 11				ld a, display_row_1+17 
63dc cd f9 0a				call str_at_display 
63df cd 09 0b				call update_display 
63e2			 
63e2				; prompt before entering montior for investigating issue 
63e2			 
63e2 3e 3c			ld a, display_row_4 
63e4 11 d7 19			ld de, endprog 
63e7			 
63e7 cd 09 0b			call update_display		 
63ea			 
63ea cd 35 1c			call next_page_prompt 
63ed			 
63ed e1					pop hl 
63ee d1					pop de 
63ef cd 2b 1a				call monitor 
63f2 c3 22 19				jp warmstart 
63f5			 
63f5			 
63f5 .. 00		.typefaults: db "STR Type Expected TOS!",0 
640c			 
640c			.show_fault: 	 
640c d5					push de 
640d cd e6 0a				call clear_display 
6410 d1					pop de 
6411 3e 00				ld a, display_row_1 
6413 cd f9 0a				call str_at_display 
6416 11 bd fb				    ld de, debug_mark 
6419 3e 11				ld a, display_row_1+17 
641b cd f9 0a				call str_at_display 
641e cd 09 0b				call update_display 
6421			 
6421				; prompt before entering montior for investigating issue 
6421			 
6421 3e 3c			ld a, display_row_4 
6423 11 d7 19			ld de, endprog 
6426			 
6426 cd 09 0b			call update_display		 
6429			 
6429 cd 35 1c			call next_page_prompt 
642c			 
642c e1					pop hl 
642d d1					pop de 
642e cd 2b 1a				call monitor 
6431			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6431			; TODO Make optional fault restart to cli or warm boot? 
6431					;jp warmstart 
6431 c3 7d 19				jp cli 
6434 76					halt 
6435			 
6435			; handle the auto run of code from files in storage 
6435			 
6435			 
6435			if STORAGE_SE 
6435			 
6435 .. 00		sprompt3: db "Loading from start-up file?:",0 
6452 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6463			 
6463			 
6463			forth_autoload: 
6463			 
6463				; load block 0 of store 1 
6463				 
6463 3e fe			ld a, $fe      ; bit 0 clear 
6465 32 ce f9			ld (spi_device), a 
6468			 
6468 cd ba 03			call storage_get_block_0 
646b			 
646b 3a 09 fa			ld a, (store_page+STORE_0_AUTOFILE) 
646e			 
646e fe 00			cp 0 
6470 c8				ret z     ; auto start not enabled 
6471			 
6471 cd e6 0a			call clear_display 
6474			 
6474				; set bank 
6474			 
6474 3a 0b fa				ld a, (store_page+STORE_0_BANKRUN) 
6477 32 ce f9				ld (spi_device), a 
647a			 
647a				; get file id to load from and get the file name to display 
647a			 
647a 3a 0c fa				ld a, (store_page+STORE_0_FILERUN) 
647d			 
647d 2e 00				ld l, 0 
647f 67					ld h, a 
6480 11 e8 f9				ld de, store_page 
6483			 
6483					if DEBUG_FORTH_WORDS 
6483						DMARK "ASp" 
6483 f5				push af  
6484 3a 98 64			ld a, (.dmark)  
6487 32 bd fb			ld (debug_mark),a  
648a 3a 99 64			ld a, (.dmark+1)  
648d 32 be fb			ld (debug_mark+1),a  
6490 3a 9a 64			ld a, (.dmark+2)  
6493 32 bf fb			ld (debug_mark+2),a  
6496 18 03			jr .pastdmark  
6498 ..			.dmark: db "ASp"  
649b f1			.pastdmark: pop af  
649c			endm  
# End of macro DMARK
649c						CALLMONITOR 
649c cd 2d 17			call break_point_state  
649f				endm  
# End of macro CALLMONITOR
649f					endif 
649f cd 54 08				call storage_read 
64a2			 
64a2					if DEBUG_FORTH_WORDS 
64a2						DMARK "ASr" 
64a2 f5				push af  
64a3 3a b7 64			ld a, (.dmark)  
64a6 32 bd fb			ld (debug_mark),a  
64a9 3a b8 64			ld a, (.dmark+1)  
64ac 32 be fb			ld (debug_mark+1),a  
64af 3a b9 64			ld a, (.dmark+2)  
64b2 32 bf fb			ld (debug_mark+2),a  
64b5 18 03			jr .pastdmark  
64b7 ..			.dmark: db "ASr"  
64ba f1			.pastdmark: pop af  
64bb			endm  
# End of macro DMARK
64bb						CALLMONITOR 
64bb cd 2d 17			call break_point_state  
64be				endm  
# End of macro CALLMONITOR
64be					endif 
64be			 
64be cd 43 0d				call ishlzero 
64c1 c8					ret z             ; file not found 
64c2			 
64c2 3e 1e				ld a, display_row_2 + 10 
64c4 11 eb f9				ld de, store_page+3 
64c7 cd f9 0a				call str_at_display 
64ca				 
64ca			; 
64ca			 
64ca 3e 05			ld a, display_row_1+5 
64cc 11 35 64			ld de, sprompt3 
64cf cd f9 0a			call str_at_display 
64d2 3e 37			ld a, display_row_3+15 
64d4 11 52 64			ld de, sprompt4 
64d7 cd f9 0a			call str_at_display 
64da			 
64da cd 09 0b			call update_display 
64dd			 
64dd cd 21 67			call cin_wait 
64e0 fe 6e			cp 'n' 
64e2 c8				ret z 
64e3 fe 4e			cp 'N' 
64e5 c8				ret z 
64e6			 
64e6 cd 66 0a			call delay1s 
64e9			 
64e9 3a ea f9			ld a, (store_page+2) 
64ec 32 de f9			ld (store_openmaxext), a    ; save count of ext 
64ef 3e 01			ld a, 1  
64f1 32 df f9			ld (store_openext), a    ; save count of ext 
64f4			 
64f4			.autof:  
64f4 6f				ld l , a 
64f5				 
64f5 3a e8 f9			ld a, (store_page) 
64f8 67				ld h, a	 
64f9 11 e8 f9			ld de, store_page 
64fc					if DEBUG_FORTH_WORDS 
64fc						DMARK "ASl" 
64fc f5				push af  
64fd 3a 11 65			ld a, (.dmark)  
6500 32 bd fb			ld (debug_mark),a  
6503 3a 12 65			ld a, (.dmark+1)  
6506 32 be fb			ld (debug_mark+1),a  
6509 3a 13 65			ld a, (.dmark+2)  
650c 32 bf fb			ld (debug_mark+2),a  
650f 18 03			jr .pastdmark  
6511 ..			.dmark: db "ASl"  
6514 f1			.pastdmark: pop af  
6515			endm  
# End of macro DMARK
6515						CALLMONITOR 
6515 cd 2d 17			call break_point_state  
6518				endm  
# End of macro CALLMONITOR
6518					endif 
6518 cd 54 08				call storage_read 
651b cd 43 0d			call ishlzero 
651e c8				ret z 
651f			;	jr z, .autoend 
651f			 
651f					if DEBUG_FORTH_WORDS 
651f						DMARK "ASc" 
651f f5				push af  
6520 3a 34 65			ld a, (.dmark)  
6523 32 bd fb			ld (debug_mark),a  
6526 3a 35 65			ld a, (.dmark+1)  
6529 32 be fb			ld (debug_mark+1),a  
652c 3a 36 65			ld a, (.dmark+2)  
652f 32 bf fb			ld (debug_mark+2),a  
6532 18 03			jr .pastdmark  
6534 ..			.dmark: db "ASc"  
6537 f1			.pastdmark: pop af  
6538			endm  
# End of macro DMARK
6538						CALLMONITOR 
6538 cd 2d 17			call break_point_state  
653b				endm  
# End of macro CALLMONITOR
653b					endif 
653b 11 ea f9			ld de, store_page+2 
653e 3e 3c			ld a, display_row_4 
6540 cd f9 0a			call str_at_display 
6543			 
6543 cd 09 0b			call update_display 
6546 cd 5a 0a			call delay250ms 
6549			 
6549			 
6549			 
6549 21 ea f9			ld hl, store_page+2 
654c cd 74 20			call forthparse 
654f cd b4 20			call forthexec 
6552 cd cb 1f			call forthexec_cleanup 
6555			 
6555				 
6555 3a df f9			ld a, (store_openext) 
6558 3c				inc a 
6559 32 df f9			ld (store_openext), a    ; save count of ext 
655c			 
655c 18 96			jr .autof 
655e			;.autofdone: 
655e			; 
655e			;		if DEBUG_FORTH_WORDS 
655e			;			DMARK "ASx" 
655e			;			CALLMONITOR 
655e			;		endif 
655e			;;	call clear_display 
655e			;	ret 
655e			 
655e			 
655e			 
655e			endif 
655e			 
655e			 
655e			; eof 
# End of file forth_kernel.asm
655e			;include "nascombasic.asm" 
655e			 
655e			 
655e			; find out where the code ends if loaded into RAM (for SC114) 
655e			;endofcode:  
655e			;	nop 
655e			 
655e			 
655e			; eof 
655e			 
# End of file main.asm
655e			include "firmware_lcd_4x20.asm" 
655e			; **********************************************************************  
655e			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
655e			; **********************************************************************  
655e			;  
655e			; **  Written as a Small Computer Monitor App  
655e			; **  www.scc.me.uk  
655e			;  
655e			; History  
655e			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
655e			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
655e			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
655e			;  
655e			; **********************************************************************  
655e			;  
655e			; This program is an example of one of the methods of interfacing an   
655e			; alphanumeric LCD module.   
655e			;  
655e			; In this example the display is connected to either a Z80 PIO or a   
655e			; simple 8-bit output port.   
655e			;  
655e			; This interfacing method uses 4-bit data mode and uses time delays  
655e			; rather than polling the display's ready status. As a result the   
655e			; interface only requires 6 simple output lines:  
655e			;   Output bit 0 = not used  
655e			;   Output bit 1 = not used  
655e			;   Output bit 2 = RS         High = data, Low = instruction  
655e			;   Output bit 3 = E          Active high  
655e			;   Output bit 4 = DB4  
655e			;   Output bit 5 = DB5  
655e			;   Output bit 6 = DB6  
655e			;   Output bit 7 = DB7  
655e			; Display's R/W is connected to 0v so it is always in write mode  
655e			;  
655e			; This set up should work with any system supporting the RC2014 bus  
655e			  
655e			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
655e			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
655e			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
655e			;  
655e			; **********************************************************************  
655e			  
655e			; **********************************************************************  
655e			; **  Constants  
655e			; **********************************************************************  
655e			; LCD constants required by LCD support module  
655e			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
655e			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
655e			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
655e			kLCDWidth:  EQU display_cols             ;Width in characters  
655e			  
655e			; **********************************************************************  
655e			; **  Code library usage  
655e			; **********************************************************************  
655e			  
655e			; send character to current cursor position  
655e			; wraps and/or scrolls screen automatically  
655e			  
655e			  
655e			lcd_init:  
655e			  
655e			; SCMonAPI functions used  
655e			  
655e			; Alphanumeric LCD functions used  
655e			; no need to specify specific functions for this module  
655e			  
655e 3e cf		            LD   A, 11001111b  
6560 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6562 3e 00		            LD   A, 00000000b  
6564 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6566			  
6566			; Initialise alphanumeric LCD module  
6566 cd df 65		            CALL fLCD_Init      ;Initialise LCD module  
6569			  
6569 c9				ret  
656a			  
656a			;  
656a			;;  
656a			; lcd functions  
656a			;  
656a			;  
656a			  
656a			; what is at cursor position   
656a			  
656a			;get_cursor:	ld de, (cursor_row)   ;  row + col  
656a			;		call curptr  
656a			;		ret  
656a			  
656a			  
656a			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
656a			  
656a			curptr:  
656a c5				push bc  
656b 21 53 fb			ld hl, display_fb0  
656e			cpr:	  
656e				; loop for cursor whole row  
656e 0e 14			ld c, display_cols  
6570 23			cpr1:	inc hl  
6571 0d				dec c  
6572 20 fc			jr nz, cpr1  
6574 05				dec b  
6575 20 f7			jr nz, cpr  
6577			  
6577				; add col	  
6577			  
6577 23			cpr2:	inc hl  
6578 1d				dec e  
6579 20 fc			jr nz, cpr2  
657b			  
657b c1				pop bc  
657c c9				ret  
657d				  
657d			  
657d			  
657d			  
657d			  
657d			; write the frame buffer given in hl to hardware   
657d 22 5b fa		write_display: ld (display_write_tmp), hl 	   
6580 3e 00			ld a, kLCD_Line1  
6582 cd 50 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6585 06 14			ld b, display_cols  
6587 ed 5b 5b fa		ld de, (display_write_tmp)  
658b cd d7 65			call write_len_string  
658e				  
658e				  
658e 2a 5b fa			ld hl, (display_write_tmp)  
6591 11 14 00			ld de, display_cols  
6594 19				add hl,de  
6595 22 5b fa			ld (display_write_tmp),hl  
6598			  
6598				  
6598 3e 40			ld a, kLCD_Line2  
659a cd 50 66		            CALL fLCD_Pos       ;Position cursor to location in A  
659d 06 14			ld b, display_cols  
659f ed 5b 5b fa		ld de, (display_write_tmp)  
65a3 cd d7 65			call write_len_string  
65a6				  
65a6 2a 5b fa			ld hl, (display_write_tmp)  
65a9 11 14 00			ld de, display_cols  
65ac 19				add hl,de  
65ad 22 5b fa			ld (display_write_tmp),hl  
65b0			  
65b0				  
65b0 3e 14			ld a, kLCD_Line3  
65b2 cd 50 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65b5 06 14			ld b, display_cols  
65b7 ed 5b 5b fa		ld de, (display_write_tmp)  
65bb cd d7 65			call write_len_string  
65be				  
65be 2a 5b fa			ld hl, (display_write_tmp)  
65c1 11 14 00			ld de, display_cols  
65c4 19				add hl,de  
65c5 22 5b fa			ld (display_write_tmp),hl  
65c8			  
65c8				  
65c8 3e 54			ld a, kLCD_Line4  
65ca cd 50 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65cd 06 14			ld b, display_cols  
65cf ed 5b 5b fa		ld de, (display_write_tmp)  
65d3 cd d7 65			call write_len_string  
65d6 c9					ret  
65d7				  
65d7				; write out a fixed length string given in b from de  
65d7			  
65d7 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
65d8 cd 29 66		            CALL fLCD_Data      ;Write character to display  
65db 13				inc de  
65dc 10 f9			djnz write_len_string  
65de c9				ret  
65df			  
65df			; Some other things to do  
65df			;            LD   A, kLCD_Clear ;Display clear  
65df			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
65df			;            LD   A, kLCD_Under ;Display on with underscore cursor  
65df			;            LD   A, kLCD_On     ;Display on with no cursor  
65df			;            ;LD   A, kLCD_Off   ;Display off  
65df			;            CALL fLCD_Inst      ;Send instruction to display  
65df			;  
65df			;  
65df			;            halt  
65df			;  
65df			;  
65df			;MsgHello:   DB  "Hello World!",0  
65df			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
65df			  
65df			; Custom characters 5 pixels wide by 8 pixels high  
65df			; Up to 8 custom characters can be defined  
65df			;BitMaps:      
65df			;; Character 0x00 = Battery icon  
65df			;            DB  01110b  
65df			;            DB  11011b  
65df			;            DB  10001b  
65df			;            DB  10001b  
65df			;            DB  11111b  
65df			;            DB  11111b  
65df			;            DB  11111b  
65df			;            DB  11111b  
65df			;; Character 0x01 = Bluetooth icon  
65df			;            DB  01100b  
65df			;            DB  01010b  
65df			;            DB  11100b  
65df			;            DB  01000b  
65df			;            DB  11100b  
65df			;            DB  01010b  
65df			;            DB  01100b  
65df			;            DB  00000b  
65df			;  
65df			  
65df			  
65df			; **********************************************************************  
65df			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
65df			; **********************************************************************  
65df			;  
65df			; **  Written as a Small Computer Monitor App   
65df			; **  Version 0.1 SCC 2018-05-16  
65df			; **  www.scc.me.uk  
65df			;  
65df			; **********************************************************************  
65df			;  
65df			; This module provides support for alphanumeric LCD modules using with  
65df			; *  HD44780 (or compatible) controller  
65df			; *  5 x 7 pixel fonts  
65df			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
65df			; *  Interface via six digital outputs to the display (see below)  
65df			;  
65df			; LCD module pinout:  
65df			;   1  Vss   0v supply  
65df			;   2  Vdd   5v supply  
65df			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
65df			;   4  RS    High = data, Low = instruction  
65df			;   5  R/W   High = Read, Low = Write  
65df			;   6  E     Enable signal (active high)  
65df			;   7  DB0   Data bit 0  
65df			;   8  DB1   Data bit 1  
65df			;   9  DB2   Data bit 2  
65df			;  10  DB3   Data bit 3  
65df			;  11  DB4   Data bit 4  
65df			;  12  DB5   Data bit 5  
65df			;  13  DB6   Data bit 6  
65df			;  14  DB7   Data bit 7  
65df			;  15  A     Backlight anode (+)  
65df			;  16  K     Backlight cathode (-)  
65df			;  
65df			; This interfacing method uses 4-bit data mode and uses time delays  
65df			; rather than polling the display's ready status. As a result the   
65df			; interface only requires 6 simple output lines:  
65df			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
65df			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
65df			;   LCD DB4 = Microcomputer output port bit 4  
65df			;   LCD DB5 = Microcomputer output port bit 5  
65df			;   LCD DB6 = Microcomputer output port bit 6  
65df			;   LCD DB7 = Microcomputer output port bit 7  
65df			; Display's R/W is connected to 0v so it is always in write mode  
65df			; All 6 connections must be on the same port address <kLCDPrt>  
65df			; This method also allows a decent length of cable from micro to LCD  
65df			;  
65df			; **********************************************************************  
65df			;  
65df			; To include the code for any given function provided by this module,   
65df			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
65df			; the parent source file.  
65df			; For example:  #REQUIRES   uHexPrefix  
65df			;  
65df			; Also #INCLUDE this file at some point after the #REQUIRES statements  
65df			; in the parent source file.  
65df			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
65df			;  
65df			; These are the function names provided by this module:  
65df			; fLCD_Init                     ;Initialise LCD  
65df			; fLCD_Inst                     ;Send instruction to LCD  
65df			; fLCD_Data                     ;Send data byte to LCD  
65df			; fLCD_Pos                      ;Position cursor  
65df			; fLCD_Str                      ;Display string  
65df			; fLCD_Def                      ;Define custom character  
65df			;  
65df			; **********************************************************************  
65df			;  
65df			; Requires SCMonAPI.asm to also be included in the project  
65df			;  
65df			  
65df			  
65df			; **********************************************************************  
65df			; **  Constants  
65df			; **********************************************************************  
65df			  
65df			; Constants that must be defined externally  
65df			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
65df			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
65df			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
65df			;kLCDWidth: EQU 20             ;Width in characters  
65df			  
65df			; general line offsets in any frame buffer  
65df			  
65df			  
65df			display_row_1: equ 0  
65df			display_row_2: equ display_row_1+display_cols  
65df			display_row_3: equ display_row_2 + display_cols  
65df			display_row_4: equ display_row_3 + display_cols  
65df			;display_row_4_eol:   
65df			  
65df			  
65df			; Cursor position values for the start of each line  
65df			kLCD_Line1: EQU 0x00   
65df			kLCD_Line2: EQU 0x40    
65df			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
65df			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
65df			  
65df			; Instructions to send as A register to fLCD_Inst  
65df			kLCD_Clear: EQU 00000001b     ;LCD clear  
65df			kLCD_Off:   EQU 00001000b     ;LCD off  
65df			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
65df			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
65df			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
65df			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
65df			  
65df			; Constants used by this code module  
65df			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
65df			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
65df			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
65df			  
65df			  
65df			  
65df			; **********************************************************************  
65df			; **  LCD support functions  
65df			; **********************************************************************  
65df			  
65df			; Initialise alphanumeric LCD module  
65df			; LCD control register codes:  
65df			;   DL   0 = 4-bit mode        1 = 8-bit mode  
65df			;   N    0 = 1-line mode       1 = 2-line mode  
65df			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
65df			;   D    0 = Display off       1 = Display on  
65df			;   C    0 = Cursor off        1 = Cursor on  
65df			;   B    0 = Blinking off      1 = Blinking on  
65df			;   ID   0 = Decrement mode    1 = Increment mode  
65df			;   SH   0 = Entire shift off  1 = Entire shift on  
65df 3e 28		fLCD_Init:  LD   A, 40  
65e1 cd 96 66		            CALL LCDDelay       ;Delay 40ms after power up  
65e4			; For reliable reset set 8-bit mode - 3 times  
65e4 cd 80 66		            CALL WrFn8bit       ;Function = 8-bit mode  
65e7 cd 80 66		            CALL WrFn8bit       ;Function = 8-bit mode  
65ea cd 80 66		            CALL WrFn8bit       ;Function = 8-bit mode  
65ed			; Set 4-bit mode  
65ed cd 7c 66		            CALL WrFn4bit       ;Function = 4-bit mode  
65f0 cd 94 66		            CALL LCDDelay1      ;Delay 37 us or more  
65f3			; Function set  
65f3 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
65f5 cd 08 66		            CALL fLCD_Inst      ;2 line, display on  
65f8			; Display On/Off control  
65f8 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
65fa cd 08 66		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
65fd			; Display Clear  
65fd 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
65ff cd 08 66		            CALL fLCD_Inst      ;Clear display  
6602			; Entry mode  
6602 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6604 cd 08 66		            CALL fLCD_Inst      ;Increment mode, shift off  
6607			; Display module now initialised  
6607 c9			            RET  
6608			; ok to here  
6608			  
6608			; Write instruction to LCD  
6608			;   On entry: A = Instruction byte to be written  
6608			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6608 f5			fLCD_Inst:  PUSH AF  
6609 f5			            PUSH AF  
660a cd 1c 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
660d f1			            POP  AF  
660e 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
660f 17			            RLA  
6610 17			            RLA  
6611 17			            RLA  
6612 cd 1c 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6615 3e 02		            LD   A, 2  
6617 cd 96 66		            CALL LCDDelay       ;Delay 2 ms to complete   
661a f1			            POP  AF  
661b c9			            RET  
661c e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
661e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6620 cb df		            SET  kLCDBitE, A  
6622 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6624 cb 9f		            RES  kLCDBitE, A  
6626 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6628 c9			            RET  
6629			  
6629			  
6629			; Write data to LCD  
6629			;   On entry: A = Data byte to be written  
6629			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6629 f5			fLCD_Data:  PUSH AF  
662a f5			            PUSH AF  
662b cd 3d 66		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
662e f1			            POP  AF  
662f 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6630 17			            RLA  
6631 17			            RLA  
6632 17			            RLA  
6633 cd 3d 66		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6636 3e 96		            LD   A, 150  
6638 3d			Wait:      DEC  A              ;Wait a while to allow data   
6639 20 fd		            JR   NZ, Wait      ;  write to complete  
663b f1			            POP  AF  
663c c9			            RET  
663d e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
663f cb d7		            SET  kLCDBitRS, A  
6641 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6643 cb df		            SET  kLCDBitE, A  
6645 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6647 cb 9f		            RES  kLCDBitE, A  
6649 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
664b cb 97		            RES  kLCDBitRS, A  
664d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
664f c9			            RET  
6650			  
6650			  
6650			; Position cursor to specified location  
6650			;   On entry: A = Cursor position  
6650			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6650 f5			fLCD_Pos:   PUSH AF  
6651 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6653 cd 08 66		            CALL fLCD_Inst      ;Write instruction to LCD  
6656 f1			            POP  AF  
6657 c9			            RET  
6658			  
6658			  
6658			; Output text string to LCD  
6658			;   On entry: DE = Pointer to null terminated text string  
6658			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6658 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6659 b7			            OR   A              ;Null terminator?  
665a c8			            RET  Z              ;Yes, so finished  
665b cd 29 66		            CALL fLCD_Data      ;Write character to display  
665e 13			            INC  DE             ;Point to next character  
665f 18 f7		            JR   fLCD_Str       ;Repeat  
6661 c9					ret  
6662			  
6662			; Define custom character  
6662			;   On entry: A = Character number (0 to 7)  
6662			;             DE = Pointer to character bitmap data  
6662			;   On exit:  A = Next character number  
6662			;             DE = Next location following bitmap  
6662			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6662			; Character is   
6662 c5			fLCD_Def:   PUSH BC  
6663 f5			            PUSH AF  
6664 07			            RLCA                ;Calculate location  
6665 07			            RLCA                ;  for bitmap data  
6666 07			            RLCA                ;  = 8 x CharacterNumber  
6667 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6669 cd 08 66		            CALL fLCD_Inst      ;Write instruction to LCD  
666c 06 00		            LD   B, 0  
666e 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
666f cd 29 66		            CALL fLCD_Data      ;Write byte to display  
6672 13			            INC  DE             ;Point to next byte  
6673 04			            INC  B              ;Count bytes  
6674 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6676 28 f6		            JR   Z, Loop       ;No, so repeat  
6678 f1			            POP  AF  
6679 3c			            INC  A              ;Increment character number  
667a c1			            POP  BC  
667b c9			            RET  
667c			  
667c			  
667c			; **********************************************************************  
667c			; **  Private functions  
667c			; **********************************************************************  
667c			  
667c			; Write function to LCD  
667c			;   On entry: A = Function byte to be written  
667c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
667c 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
667e 18 02		            JR   WrFunc  
6680 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6682 f5			WrFunc:     PUSH AF  
6683 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6685 cb df		            SET  kLCDBitE, A  
6687 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6689 cb 9f		            RES  kLCDBitE, A  
668b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
668d 3e 05		            LD   A, 5  
668f cd 96 66		            CALL LCDDelay       ;Delay 5 ms to complete  
6692 f1			            POP  AF  
6693 c9			            RET  
6694			  
6694			  
6694			; Delay in milliseconds  
6694			;   On entry: A = Number of milliseconds delay  
6694			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6694 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6696 d5			LCDDelay:   PUSH DE  
6697 5f			            LD   E, A           ;Delay by 'A' ms  
6698 16 00		            LD   D, 0  
669a cd 4b 0a		            CALL aDelayInMS  
669d d1			            POP  DE  
669e c9			            RET  
669f			  
669f			  
669f			  
669f			  
669f			; eof  
669f			  
# End of file firmware_lcd_4x20.asm
669f			include "firmware_key_4x4.asm" 
669f			  
669f			  
669f			; bit mask for each scan column and row for teing the matrix  
669f			  
669f			; out   
669f 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
66a3			; in  
66a3 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
66a7			  
66a7			; row/col to character map  
66a7			  
66a7			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
66a7			;    
66a7			  
66a7			; physical key matrix map to face of key  
66a7			  
66a7			  
66a7			;      	1	2	3	A  
66a7			;   	abc”	def&	ghi$	s1  
66a7			;			  
66a7			;	4	5	6	B  
66a7			; 	jkl,	mno.	pqr:	s2  
66a7			;			  
66a7			; 	7	8	9	C  
66a7			;	stu;	vwx@	yz?!	s3  
66a7			;			  
66a7			; 	*	0	#	D  
66a7			; 	shift lck '	Space < >	Enter ( )	s4  
66a7			;       tab bs 		  
66a7			  
66a7			  
66a7			  
66a7			  
66a7			key_init:  
66a7			  
66a7			; SCMonAPI functions used  
66a7			  
66a7			; Alphanumeric LCD functions used  
66a7			; no need to specify specific functions for this module  
66a7			  
66a7			  
66a7 3e cf		            LD   A, 11001111b  
66a9 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
66ab			;            LD   A, 00000000b  
66ab 3e 0f		            LD   A, 00001111b  
66ad d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
66af			  
66af			  
66af				; TODO Configure cursor shapes  
66af			  
66af				; Load cursor shapes   
66af 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
66b1 11 c1 66		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
66b4 06 02		            LD   B, 2           ;Number of characters to define  
66b6 cd 62 66		.DefLoop:   CALL fLCD_Def       ;Define custom character  
66b9 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
66bb			  
66bb 3e 01				ld a, 1  
66bd 32 56 fa			ld (cursor_shape),a  
66c0 c9				ret  
66c1			  
66c1			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
66c1			; Up to 8 custom characters can be defined  
66c1			.cursor_shapes:      
66c1			;; Character 0x00 = Normal  
66c1 1f			            DB  11111b  
66c2 1f			            DB  11111b  
66c3 1f			            DB  11111b  
66c4 1f			            DB  11111b  
66c5 1f			            DB  11111b  
66c6 1f			            DB  11111b  
66c7 1f			            DB  11111b  
66c8 1f			            DB  11111b  
66c9			;; Character 0x01 = Modifier  
66c9 1f			            DB  11111b  
66ca 1b			            DB  11011b  
66cb 1b			            DB  11011b  
66cc 1b			            DB  11011b  
66cd 1b			            DB  11011b  
66ce 1f			            DB  11111b  
66cf 1b			            DB  11011b  
66d0 1f			            DB  11111b  
66d1			  
66d1			  
66d1			  
66d1			  
66d1			; Display custom character 0  
66d1			;            LD   A, kLCD_Line1+14  
66d1			;            CALL fLCD_Pos       ;Position cursor to location in A  
66d1			;            LD   A, 0  
66d1			;            CALL fLCD_Data      ;Write character in A at cursor  
66d1			  
66d1			; Display custom character 1  
66d1			;            LD   A, kLCD_Line2+14  
66d1			;            CALL fLCD_Pos      ;Position cursor to location in A  
66d1			;            LD   A, 1  
66d1			;            CALL fLCD_Data     ;Write character in A at cursor  
66d1			  
66d1			; keyboard scanning   
66d1			  
66d1			  
66d1			; key_rows: equ 4  
66d1			; key_cols: equ 4  
66d1			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
66d1			  
66d1			; key_scanr: equ key_row_bitmask  
66d1			; key_scanc: equ key_col_bitmask  
66d1			  
66d1			; key_char_map: equ key_map  
66d1			  
66d1			  
66d1			  
66d1			; character in from keyboard  
66d1			  
66d1 ..			.matrix_to_char: db "D#0*C987B654A321"  
66e1			  
66e1			  
66e1			; map the physical key to a char dependant on state  
66e1			  
66e1			.key_map_fa:   
66e1			  
66e1 ..					db 'D'  
66e2 0d					db KEY_CR    ; cr  
66e3 ..					db ' '  
66e4 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
66e5 ..					db 'C'  
66e6 ..					db 'y'  
66e7 ..					db 'v'  
66e8 ..					db 's'  
66e9 ..					db 'B'  
66ea ..					db 'p'  
66eb ..					db 'm'  
66ec ..					db 'j'  
66ed ..					db 'A'  
66ee ..					db 'g'  
66ef ..					db 'd'  
66f0 ..					db 'a'  
66f1			  
66f1			.key_map_fb:  
66f1			  
66f1 ..					db 'A'  
66f2 ..					db '+'   
66f3 ..					db '<'  
66f4 ..					db  "'"    
66f5			  
66f5 ..					db 'A'  
66f6 ..					db 'z'  
66f7 ..					db 'w'  
66f8 ..					db 't'  
66f9 ..					db 'A'  
66fa ..					db 'q'  
66fb ..					db 'n'  
66fc ..					db 'k'  
66fd ..					db 'A'  
66fe ..					db 'h'  
66ff ..					db 'e'  
6700 ..			 		db 'b'  
6701			  
6701			.key_map_fc:   
6701			  
6701			  
6701 ..					db 'A'  
6702 ..					db '-'   
6703 ..					db '>'  
6704 ..					db  '='   	  
6705 ..					db 'A'  
6706 ..					db '?'  
6707 ..					db 'x'  
6708 ..					db 'u'  
6709 ..					db 'A'  
670a ..					db 'r'  
670b ..					db 'o'  
670c ..					db 'l'  
670d ..					db 'A'  
670e ..					db 'i'  
670f ..					db 'f'  
6710 ..					db 'c'  
6711			  
6711				  
6711			.key_map_fd:  
6711			  
6711 ..					db 'A'  
6712 ..					db '/'   
6713 ..					db '%'   
6714 08					db KEY_BS  ; back space  
6715 ..					db 'A'  
6716 ..					db '!'  
6717 ..					db '@'  
6718 ..					db ';'  
6719 ..					db 'A'  
671a ..					db ':'  
671b ..					db '.'  
671c ..					db ','  
671d ..					db 'A'  
671e ..					db '$'  
671f ..					db '&'  
6720 ..				 	db '"'  
6721			  
6721					  
6721				  
6721			  
6721			; add cin and cin_wait  
6721			  
6721 cd 32 67		cin_wait: 	call cin  
6724 fe 00			cp 0  
6726 28 f9			jr z, cin_wait   ; block until key press  
6728			  
6728 f5				push af   ; save key pressed  
6729			  
6729 cd 32 67		.cin_wait1:	call cin  
672c fe 00			cp 0  
672e 20 f9			jr nz, .cin_wait1  	; wait for key release  
6730			  
6730 f1				pop af   ; get key  
6731 c9				ret  
6732			  
6732			  
6732 cd 43 67		cin: 	call .mtoc  
6735			  
6735				; no key held  
6735 fe 00			cp 0  
6737 c8				ret z  
6738			  
6738				; stop key bounce  
6738			  
6738			;	ld (key_held),a		 ; save it  
6738 47				ld b, a  
6739			  
6739 c5			.cina1:	push bc  
673a cd 43 67			call .mtoc  
673d c1				pop bc  
673e b8				cp b  
673f 28 f8			jr z, .cina1  
6741 78				ld a,b		  
6742 c9				ret  
6743			  
6743			; detect keyboard modifier key press and apply new overlay to the face key held  
6743			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6743			  
6743			;.cin_map_modifier:   
6743			;	ld a, (hl)  
6743			;	and 255  
6743			;	ret NZ		; modifier key not flagged  
6743			;  
6743			;	; get key face  
6743			;  
6743			;	ld b,(key_face_held)  
6743			;  
6743			;	ld b, key_cols * key_rows  
6743			;  
6743			;	push de  
6743			;	pop hl  
6743			;  
6743			;.mmod1: ld a,(hl)   ; get map test  
6743			;	cp b  
6743			;	jr z, .mmod2  
6743			;  
6743			;  
6743			;  
6743			;.mmod2: inc hl    ;   
6743			;  
6743			;	  
6743			;  
6743			;	  
6743			;  
6743			;	ld hl,key_actual_pressed  
6743			;	ld (hl),a,  
6743			;	ret  
6743			  
6743				  
6743			  
6743			; map matrix key held to char on face of key  
6743			  
6743			.mtoc:  
6743			  
6743			  
6743				; TODO optimise the code....  
6743			  
6743			; scan keyboard row 1  
6743 3e 80			ld a, 128  
6745 21 d3 fb			ld hl, keyscan_table  
6748 cd 2a 68			call .rowscan  
674b			  
674b				   
674b			  
674b 3e 40			ld a, 64  
674d 21 d7 fb			ld hl, keyscan_table+key_cols  
6750 cd 2a 68			call .rowscan  
6753			  
6753			  
6753			  
6753			  
6753 3e 20			ld a, 32  
6755 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6758 cd 2a 68			call .rowscan  
675b			  
675b			  
675b			  
675b 3e 10			ld a, 16  
675d 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6760 cd 2a 68			call .rowscan  
6763			  
6763			  
6763				; flag if key D is held down and remove from reporting  
6763 01 11 67			ld bc, .key_map_fd    
6766 21 d3 fb			ld hl, keyscan_table  
6769 11 c5 fb			ld de, key_fd  
676c cd bc 67			call .key_shift_hold  
676f fe ff			cp 255  
6771 28 33			jr z, .cinmap  
6773				; flag if key C is held down and remove from reporting  
6773 01 01 67			ld bc, .key_map_fc    
6776 21 d7 fb			ld hl, keyscan_table+key_cols  
6779 11 c6 fb			ld de, key_fc  
677c cd bc 67			call .key_shift_hold  
677f fe ff			cp 255  
6781 28 23			jr z, .cinmap  
6783				; flag if key B is held down and remove from reporting  
6783 01 f1 66			ld bc, .key_map_fb    
6786 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6789 11 c7 fb			ld de, key_fb  
678c cd bc 67			call .key_shift_hold  
678f fe ff			cp 255  
6791 28 13			jr z, .cinmap  
6793				; flag if key A is held down and remove from reporting  
6793 01 e1 66			ld bc, .key_map_fa    
6796 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6799 11 c8 fb			ld de, key_fa  
679c cd bc 67			call .key_shift_hold  
679f fe ff			cp 255  
67a1 28 03			jr z, .cinmap  
67a3			  
67a3 11 d1 66			ld de, .matrix_to_char  
67a6			  
67a6			  
67a6			.cinmap:   
67a6				if DEBUG_KEY  
67a6			            LD   A, kLCD_Line4  
67a6			            CALL fLCD_Pos       ;Position cursor to location in A  
67a6					push de  
67a6			            LD   DE, keyscan_table  
67a6			            CALL fLCD_Str       ;Display string pointed to by DE  
67a6					pop de  
67a6				endif  
67a6			  
67a6				; scan key matrix table for any held key  
67a6			  
67a6				; de holds either the default matrix or one selected above  
67a6			  
67a6 21 d3 fb			ld hl, keyscan_table  
67a9 06 10			ld b,key_cols*key_rows  
67ab			  
67ab 7e			.cin1:	ld a,(hl)  
67ac fe 23			cp '#'  
67ae 28 08			jr z, .cinhit  
67b0 23				inc hl  
67b1 13				inc de  
67b2 05				dec b  
67b3 20 f6			jr nz, .cin1  
67b5				; no key found held  
67b5 3e 00			ld a,0  
67b7 c9				ret  
67b8 d5			.cinhit: push de  
67b9 e1				pop hl  
67ba 7e				ld a,(hl)  
67bb c9				ret  
67bc			  
67bc			; flag a control key is held   
67bc			; hl is key pin, de is flag indicator  
67bc			  
67bc			.key_shift_hold:  
67bc c5				push bc  
67bd 3e 01			ld a, 1  
67bf 32 56 fa			ld (cursor_shape),a  
67c2 06 00			ld b, 0  
67c4 7e				ld a, (hl)  
67c5 fe 2e			cp '.'  
67c7 28 0a			jr z, .key_shift1  
67c9 06 ff			ld b, 255  
67cb 3e 2b			ld a, '+'    ; hide key from later scans  
67cd 77				ld (hl),a  
67ce 3e 02			ld a, 2  
67d0 32 56 fa			ld (cursor_shape),a  
67d3			.key_shift1:  
67d3				; write flag indicator  
67d3 78				ld a,b  
67d4 12				ld (de),a  
67d5			  
67d5 d1				pop de    ; de now holds the key map ptr  
67d6 c9				ret  
67d7			  
67d7				  
67d7				  
67d7			  
67d7			  
67d7			  
67d7			  
67d7			  
67d7			  
67d7			  
67d7			  
67d7			  
67d7			  
67d7 c9				ret  
67d8			  
67d8			;	push hl  
67d8			;	push de  
67d8			;	push bc  
67d8			;	call keyscan  
67d8			;	; map key matrix to ascii value of key face  
67d8			;  
67d8			;	ld hl, key_face_map  
67d8			;	ld de, keyscan_table  
67d8			;  
67d8			;	; get how many keys to look at  
67d8			;	ld b, keyscan_table_len  
67d8			;	  
67d8			;  
67d8			;	; at this stage fall out on first key hit  
67d8			;	; TODO handle multiple key press  
67d8			;  
67d8			;map1:	ld a,(hl)  
67d8			;	cp '#'  
67d8			;	jr z, keyhit  
67d8			;	inc hl  
67d8			;	inc de  
67d8			;	dec b  
67d8			;	jr nz, map1  
67d8			;nohit:	ld a, 0  
67d8			;	jr keydone  
67d8			;keyhit: push de  
67d8			;	pop hl  
67d8			;	ld a,(hl)  
67d8			;keydone:  
67d8			;	push bc  
67d8			;	push de  
67d8			; 	push hl  
67d8			;	ret   
67d8			;  
67d8			  
67d8			  
67d8			  
67d8			  
67d8			; scan physical key matrix  
67d8			  
67d8			  
67d8			;keyscan:  
67d8			;  
67d8			;; for each key_row use keyscanr bit mask for out  
67d8			;; then read in for keyscanc bitmask  
67d8			;; save result of row scan to keyscantable  
67d8			;  
67d8			;; scan keyboard row 1  
67d8			;  
67d8			;	ld b, key_rows  
67d8			;	ld hl, key_scanr  
67d8			;	ld de, keyscan_table  
67d8			;  
67d8			;rowloop:  
67d8			;  
67d8			;	ld a,(hl)		; out bit mask to energise keyboard row  
67d8			;	call rowscan  
67d8			;	inc hl  
67d8			;	dec b  
67d8			;	jr nz, rowloop  
67d8			;  
67d8			;	ret  
67d8			;  
67d8			;  
67d8			;; pass a out bitmask, b row number  
67d8			;arowscan:   
67d8			;	push bc  
67d8			;  
67d8			;	ld d, b  
67d8			;  
67d8			;	; calculate buffer location for this row  
67d8			;  
67d8			;	ld hl, keyscan_table	  
67d8			;kbufr:  ld e, key_cols  
67d8			;kbufc:	inc hl  
67d8			;	dec e  
67d8			;	jr nz, kbufc  
67d8			;	dec d  
67d8			;	jr nz, kbufr  
67d8			;  
67d8			;	; energise row and read columns  
67d8			;  
67d8			;	out (portbdata),a  
67d8			;	in a,(portbdata)  
67d8			;	ld c,a  
67d8			;  
67d8			;  
67d8			;	; save buffer loc  
67d8			;  
67d8			;	ld (keybufptr), hl  
67d8			;  
67d8			;	ld hl, key_scanc  
67d8			;	ld d, key_cols  
67d8			;  
67d8			;	; for each column check each bit mask  
67d8			;  
67d8			;colloop:  
67d8			;	  
67d8			;  
67d8			;	; reset flags for the row   
67d8			;  
67d8			;	ld b,'.'  
67d8			;	and (hl)  
67d8			;	jr z, maskskip  
67d8			;	ld b,'#'  
67d8			;maskskip:  
67d8			;	; save  key state  
67d8			;	push hl  
67d8			;	ld hl, (keybufptr)  
67d8			;	ld (hl), b  
67d8			;	inc hl  
67d8			;	ld (keybufptr), hl  
67d8			;  
67d8			;	; move to next bit mask  
67d8			;	pop hl  
67d8			;	inc hl  
67d8			;  
67d8			;	dec d  
67d8			;	jr nz, colloop  
67d8			;  
67d8			;	ret  
67d8			;  
67d8			;  
67d8			;;  
67d8			; lcd functions  
67d8			;  
67d8			;  
67d8			  
67d8			;if DEBUG_KEY_MATRIX  
67d8			  
67d8			; test function to display hardware view of matrix state  
67d8			  
67d8			matrix:  
67d8			  
67d8			  
67d8			  
67d8			; scan keyboard row 1  
67d8 3e 80			ld a, 128  
67da 21 f8 fb			ld hl, keyscan_table_row1  
67dd cd 2a 68			call .rowscan  
67e0			  
67e0 3e 40			ld a, 64  
67e2 21 f3 fb			ld hl, keyscan_table_row2  
67e5 cd 2a 68			call .rowscan  
67e8			  
67e8 3e 20			ld a, 32  
67ea 21 ee fb			ld hl, keyscan_table_row3  
67ed cd 2a 68			call .rowscan  
67f0			  
67f0 3e 10			ld a, 16  
67f2 21 e9 fb			ld hl, keyscan_table_row4  
67f5 cd 2a 68			call .rowscan  
67f8			  
67f8			; Display text on first line  
67f8 3e 00		            LD   A, kLCD_Line1  
67fa cd 50 66		            CALL fLCD_Pos       ;Position cursor to location in A  
67fd 11 f8 fb		            LD   DE, keyscan_table_row1  
6800			            ;LD   DE, MsgHello  
6800 cd 58 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6803			  
6803			; Display text on second line  
6803 3e 40		            LD   A, kLCD_Line2  
6805 cd 50 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6808 11 f3 fb		            LD   DE, keyscan_table_row2  
680b cd 58 66		            CALL fLCD_Str       ;Display string pointed to by DE  
680e 3e 14		            LD   A, kLCD_Line3  
6810 cd 50 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6813 11 ee fb		            LD   DE, keyscan_table_row3  
6816 cd 58 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6819 3e 54		            LD   A, kLCD_Line4  
681b cd 50 66		            CALL fLCD_Pos       ;Position cursor to location in A  
681e 11 e9 fb		            LD   DE, keyscan_table_row4  
6821 cd 58 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6824			  
6824 cd 5a 0a			call delay250ms  
6827 c3 d8 67			jp matrix  
682a			  
682a			; pass de as row display flags  
682a			.rowscan:   
682a d3 c1			out (portbdata),a  
682c db c1			in a,(portbdata)  
682e 4f				ld c,a  
682f				; reset flags for the row   
682f 06 2e			ld b,'.'  
6831 e6 01			and 1  
6833 28 02			jr z, .p1on  
6835 06 23			ld b,'#'  
6837			.p1on:  
6837 70				ld (hl), b  
6838 23				inc hl  
6839			  
6839 06 2e			ld b,'.'  
683b 79				ld a,c  
683c e6 02			and 2  
683e			;	bit 0,a  
683e 28 02			jr z, .p2on  
6840 06 23			ld b,'#'  
6842			.p2on:  
6842 70				ld (hl), b  
6843 23				inc hl  
6844			;  
6844 06 2e			ld b,'.'  
6846 79				ld a,c  
6847 e6 04			and 4  
6849			;;	bit 0,a  
6849 28 02			jr z, .p3on  
684b 06 23			ld b,'#'  
684d			.p3on:  
684d 70				ld (hl), b  
684e 23				inc hl  
684f			;;  
684f 06 2e			ld b,'.'  
6851			;;	bit 0,a  
6851 79				ld a,c  
6852 e6 08			and 8  
6854 28 02			jr z, .p4on  
6856 06 23			ld b,'#'  
6858			.p4on:  
6858 70				ld (hl), b  
6859 23				inc hl  
685a			  
685a			; zero term  
685a 06 00			ld b,0  
685c 70				ld (hl), b  
685d			  
685d c9			.rscandone: ret  
685e			  
685e			  
685e			  
685e			;endif  
685e			  
685e			  
685e			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
685e
