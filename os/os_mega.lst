# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 6d 18			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd d5 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd d5 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd d5 0a				call clear_display  
0023			  
0023			  
0023 cd 38 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd cf 67			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd ac 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 69 13				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd f8 0a			call update_display  
0035 cd 55 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd da 0a			call fill_display  
003d cd f8 0a			call update_display  
0040 cd 55 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd da 0a			call fill_display  
0048 cd f8 0a			call update_display  
004b cd 55 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd da 0a			call fill_display  
0053 cd f8 0a			call update_display  
0056 cd 55 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd e8 0a			call str_at_display  
0061 cd f8 0a			call update_display  
0064			  
0064			  
0064 cd 55 0a			call delay1s  
0067 cd 55 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd e8 0a			call str_at_display  
0072 cd f8 0a			call update_display  
0075 cd 55 0a			call delay1s  
0078 cd 55 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 49 f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 49 f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 49 f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 49 f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 49 f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 4b f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 48 f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 48 f8			ld (spi_device), a 
01e3 32 4b f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 49 f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 49 f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 49 f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 49 f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 49 f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 49 f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 49 f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 49 f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 3a 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 49 f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 49 f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 49 f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 49 f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 49 f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 49 f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 49 f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 49 f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 3a 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 49 f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 49 f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 49 f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 49 f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 1f ee			ld hl,scratch+2 
02be cd c0 10			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 40 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 24 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 40 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 40 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 40 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 40 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 45 ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 45 ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 40 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 40 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 45 ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 40 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 97 16			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 97 16			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 2d 06			call storage_findnextid 
0360			 
0360 cd 32 0d			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 97 16			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 97 16			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 97 16			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 97 16			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 97 16			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b cd 18 0a			call storage_clear_page 
042e			 
042e 21 62 f8			ld hl, store_page 
0431 3e 00			ld a, 0 
0433				 
0433 77				ld (hl),a   ; reset file counter 
0434			 
0434 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0437 22 63 f8		 	ld (store_page+1), hl	 
043a			 
043a				; set default label 
043a			 
043a 21 d6 04			ld hl, .defaultbanklabl 
043d 11 65 f8		 	ld de, store_page+3 
0440 01 0f 00			ld bc, 15 
0443 ed b0			ldir 
0445			 
0445				; Append the current bank id 
0445 21 6e f8			ld hl, store_page+3+9 
0448 3a 47 f8			ld a, (spi_device_id) 
044b 77				ld (hl), a 
044c			 
044c				; save default page 0 
044c			 
044c 21 00 00			ld hl, 0 
044f 11 62 f8			ld de, store_page 
0452				if DEBUG_STORESE 
0452					DMARK "SB3" 
0452 f5				push af  
0453 3a 67 04			ld a, (.dmark)  
0456 32 77 fb			ld (debug_mark),a  
0459 3a 68 04			ld a, (.dmark+1)  
045c 32 78 fb			ld (debug_mark+1),a  
045f 3a 69 04			ld a, (.dmark+2)  
0462 32 79 fb			ld (debug_mark+2),a  
0465 18 03			jr .pastdmark  
0467 ..			.dmark: db "SB3"  
046a f1			.pastdmark: pop af  
046b			endm  
# End of macro DMARK
046b			;		push af 
046b			;		ld a, 'F' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b					CALLMONITOR 
046b cd 97 16			call break_point_state  
046e				endm  
# End of macro CALLMONITOR
046e				endif 
046e cd 71 03			call storage_write_block 
0471				if DEBUG_STORESE 
0471					DMARK "SB4" 
0471 f5				push af  
0472 3a 86 04			ld a, (.dmark)  
0475 32 77 fb			ld (debug_mark),a  
0478 3a 87 04			ld a, (.dmark+1)  
047b 32 78 fb			ld (debug_mark+1),a  
047e 3a 88 04			ld a, (.dmark+2)  
0481 32 79 fb			ld (debug_mark+2),a  
0484 18 03			jr .pastdmark  
0486 ..			.dmark: db "SB4"  
0489 f1			.pastdmark: pop af  
048a			endm  
# End of macro DMARK
048a			;		push af 
048a			;		ld a, '>' 
048a			;		ld (debug_mark),a 
048a			;		pop af 
048a					CALLMONITOR 
048a cd 97 16			call break_point_state  
048d				endm  
# End of macro CALLMONITOR
048d				endif 
048d			 
048d 00				nop 
048e 00				nop 
048f 00				nop 
0490			 
0490				; now set 0 in every page to mark as a free block 
0490			 
0490 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0492 21 40 00			ld hl, STORE_BLOCK_PHY 
0495			 
0495 3e 00		.setmark1:   	ld a,0 
0497 e5					push hl 
0498 c5					push bc 
0499 cd ea 01				call se_writebyte 
049c 3e 0a			ld a, 10 
049e cd 3a 0a			call aDelayInMS 
04a1 23				inc hl 
04a2 cd ea 01				call se_writebyte 
04a5 3e 0a			ld a, 10 
04a7 cd 3a 0a			call aDelayInMS 
04aa 2b				dec hl 
04ab c1					pop bc 
04ac e1					pop hl 
04ad 3e 40				ld a, STORE_BLOCK_PHY 
04af cd 09 0d				call addatohl 
04b2 10 e1				djnz .setmark1 
04b4			 
04b4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b6 3e 00		.setmark2:   	ld a,0 
04b8 e5					push hl 
04b9 c5					push bc 
04ba cd ea 01				call se_writebyte 
04bd 3e 0a			ld a, 10 
04bf cd 3a 0a			call aDelayInMS 
04c2 23				inc hl 
04c3 cd ea 01				call se_writebyte 
04c6 3e 0a			ld a, 10 
04c8 cd 3a 0a			call aDelayInMS 
04cb 2b				dec hl 
04cc c1					pop bc 
04cd e1					pop hl 
04ce 3e 40				ld a, STORE_BLOCK_PHY 
04d0 cd 09 0d				call addatohl 
04d3 10 e1				djnz .setmark2 
04d5			 
04d5					 
04d5			 
04d5			 
04d5 c9				ret 
04d6			 
04d6			 
04d6			 
04d6			 
04d6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04e1			 
04e1			 
04e1			 
04e1			; Label Bank 
04e1			; ---------- 
04e1			; 
04e1			; With current bank 
04e1			; Read block 0 
04e1			; Set label 
04e1			; Write block 0 
04e1			 
04e1			; label str pointer in hl 
04e1			 
04e1			storage_label:     
04e1			 
04e1				if DEBUG_STORESE 
04e1					DMARK "LBL" 
04e1 f5				push af  
04e2 3a f6 04			ld a, (.dmark)  
04e5 32 77 fb			ld (debug_mark),a  
04e8 3a f7 04			ld a, (.dmark+1)  
04eb 32 78 fb			ld (debug_mark+1),a  
04ee 3a f8 04			ld a, (.dmark+2)  
04f1 32 79 fb			ld (debug_mark+2),a  
04f4 18 03			jr .pastdmark  
04f6 ..			.dmark: db "LBL"  
04f9 f1			.pastdmark: pop af  
04fa			endm  
# End of macro DMARK
04fa					CALLMONITOR 
04fa cd 97 16			call break_point_state  
04fd				endm  
# End of macro CALLMONITOR
04fd				endif 
04fd			 
04fd e5				push hl 
04fe			 
04fe cd bd 03			call storage_get_block_0 
0501			 
0501				; set default label 
0501			 
0501 e1				pop hl 
0502			 
0502 11 65 f8		 	ld de, store_page+3 
0505 01 0f 00			ld bc, 15 
0508				if DEBUG_STORESE 
0508					DMARK "LB3" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 77 fb			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 78 fb			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 79 fb			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "LB3"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521					CALLMONITOR 
0521 cd 97 16			call break_point_state  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 ed b0			ldir 
0526				; save default page 0 
0526			 
0526 21 00 00			ld hl, 0 
0529 11 62 f8			ld de, store_page 
052c				if DEBUG_STORESE 
052c					DMARK "LBW" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 77 fb			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 78 fb			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 79 fb			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "LBW"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545					CALLMONITOR 
0545 cd 97 16			call break_point_state  
0548				endm  
# End of macro CALLMONITOR
0548				endif 
0548 cd 71 03			call storage_write_block 
054b			 
054b c9				ret 
054c			 
054c			 
054c			 
054c			; Read Block 0 - Config 
054c			; --------------------- 
054c			; 
054c			; With current bank 
054c			; Call presence test 
054c			;    If not present format/init bank  
054c			; Read block 0  
054c			;  
054c			 
054c			 
054c			; Dir 
054c			; --- 
054c			; 
054c			; With current bank 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block read byte 2 
054c			;      if first block of file 
054c			;         Display file name 
054c			;         Display type flags for file 
054c			;        
054c			 
054c			; moving to words as this requires stack control 
054c			 
054c			 
054c			; Delete File 
054c			; ----------- 
054c			; 
054c			; With current bank 
054c			; 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block file id 
054c			;      If first block of file and dont have file id 
054c			;         if file to delete 
054c			;         Save file id 
054c			;         Null file id 
054c			;         Write this block back 
054c			;      If file id is one saved 
054c			;         Null file id 
054c			;         Write this block back 
054c			 
054c			storage_erase: 
054c			 
054c				; hl contains the file id 
054c			 
054c 5d				ld e, l 
054d 16 00			ld d, 0 
054f 21 40 00			ld hl, STORE_BLOCK_PHY 
0552					if DEBUG_FORTH_WORDS 
0552						DMARK "ERA" 
0552 f5				push af  
0553 3a 67 05			ld a, (.dmark)  
0556 32 77 fb			ld (debug_mark),a  
0559 3a 68 05			ld a, (.dmark+1)  
055c 32 78 fb			ld (debug_mark+1),a  
055f 3a 69 05			ld a, (.dmark+2)  
0562 32 79 fb			ld (debug_mark+2),a  
0565 18 03			jr .pastdmark  
0567 ..			.dmark: db "ERA"  
056a f1			.pastdmark: pop af  
056b			endm  
# End of macro DMARK
056b						CALLMONITOR 
056b cd 97 16			call break_point_state  
056e				endm  
# End of macro CALLMONITOR
056e					endif 
056e cd 2d 06			call storage_findnextid 
0571			 
0571 e5				push hl 
0572			 
0572				; TODO check file not found 
0572			 
0572 11 62 f8			ld de, store_page 
0575 cd 0c 03			call storage_read_block 
0578			 
0578					if DEBUG_FORTH_WORDS 
0578						DMARK "ER1" 
0578 f5				push af  
0579 3a 8d 05			ld a, (.dmark)  
057c 32 77 fb			ld (debug_mark),a  
057f 3a 8e 05			ld a, (.dmark+1)  
0582 32 78 fb			ld (debug_mark+1),a  
0585 3a 8f 05			ld a, (.dmark+2)  
0588 32 79 fb			ld (debug_mark+2),a  
058b 18 03			jr .pastdmark  
058d ..			.dmark: db "ER1"  
0590 f1			.pastdmark: pop af  
0591			endm  
# End of macro DMARK
0591						CALLMONITOR 
0591 cd 97 16			call break_point_state  
0594				endm  
# End of macro CALLMONITOR
0594					endif 
0594 3a 62 f8			ld a, (store_page)	; get file id 
0597 32 5b f8			ld (store_tmpid), a 
059a			 
059a 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
059d 32 5a f8			ld (store_tmpext), a 
05a0			 
05a0				; wipe file header 
05a0			 
05a0 e1				pop hl 
05a1 3e 00			ld a, 0 
05a3 32 62 f8			ld (store_page), a 
05a6 32 63 f8			ld (store_page+1),a 
05a9 11 62 f8			ld de, store_page 
05ac					if DEBUG_FORTH_WORDS 
05ac						DMARK "ER2" 
05ac f5				push af  
05ad 3a c1 05			ld a, (.dmark)  
05b0 32 77 fb			ld (debug_mark),a  
05b3 3a c2 05			ld a, (.dmark+1)  
05b6 32 78 fb			ld (debug_mark+1),a  
05b9 3a c3 05			ld a, (.dmark+2)  
05bc 32 79 fb			ld (debug_mark+2),a  
05bf 18 03			jr .pastdmark  
05c1 ..			.dmark: db "ER2"  
05c4 f1			.pastdmark: pop af  
05c5			endm  
# End of macro DMARK
05c5						CALLMONITOR 
05c5 cd 97 16			call break_point_state  
05c8				endm  
# End of macro CALLMONITOR
05c8					endif 
05c8 cd 71 03			call storage_write_block 
05cb			 
05cb			 
05cb				; wipe file extents 
05cb			 
05cb 3a 5a f8			ld a, (store_tmpext) 
05ce 47				ld b, a 
05cf			 
05cf			.eraext:	  
05cf c5				push bc 
05d0			 
05d0 21 40 00			ld hl, STORE_BLOCK_PHY 
05d3 3a 5b f8			ld a,(store_tmpid) 
05d6 5f				ld e, a 
05d7 50				ld d, b	 
05d8					if DEBUG_FORTH_WORDS 
05d8						DMARK "ER3" 
05d8 f5				push af  
05d9 3a ed 05			ld a, (.dmark)  
05dc 32 77 fb			ld (debug_mark),a  
05df 3a ee 05			ld a, (.dmark+1)  
05e2 32 78 fb			ld (debug_mark+1),a  
05e5 3a ef 05			ld a, (.dmark+2)  
05e8 32 79 fb			ld (debug_mark+2),a  
05eb 18 03			jr .pastdmark  
05ed ..			.dmark: db "ER3"  
05f0 f1			.pastdmark: pop af  
05f1			endm  
# End of macro DMARK
05f1						CALLMONITOR 
05f1 cd 97 16			call break_point_state  
05f4				endm  
# End of macro CALLMONITOR
05f4					endif 
05f4 cd 2d 06			call storage_findnextid 
05f7			 
05f7 e5				push hl 
05f8 11 62 f8			ld de, store_page 
05fb cd 0c 03			call storage_read_block 
05fe			 
05fe				; free block	 
05fe			 
05fe 3e 00			ld a, 0 
0600 32 62 f8			ld (store_page), a 
0603 32 63 f8			ld (store_page+1),a 
0606 11 62 f8			ld de, store_page 
0609 e1				pop hl 
060a					if DEBUG_FORTH_WORDS 
060a						DMARK "ER4" 
060a f5				push af  
060b 3a 1f 06			ld a, (.dmark)  
060e 32 77 fb			ld (debug_mark),a  
0611 3a 20 06			ld a, (.dmark+1)  
0614 32 78 fb			ld (debug_mark+1),a  
0617 3a 21 06			ld a, (.dmark+2)  
061a 32 79 fb			ld (debug_mark+2),a  
061d 18 03			jr .pastdmark  
061f ..			.dmark: db "ER4"  
0622 f1			.pastdmark: pop af  
0623			endm  
# End of macro DMARK
0623						CALLMONITOR 
0623 cd 97 16			call break_point_state  
0626				endm  
# End of macro CALLMONITOR
0626					endif 
0626 cd 71 03			call storage_write_block 
0629			 
0629 c1				pop bc 
062a 10 a3			djnz .eraext 
062c			 
062c c9				ret 
062d			 
062d			 
062d			; Find Free Block 
062d			; --------------- 
062d			; 
062d			; With current bank 
062d			;  
062d			; From given starting logical block 
062d			;    Read block  
062d			;    If no file id 
062d			;         Return block id 
062d			 
062d			 
062d			; hl starting page number 
062d			; hl contains free page number or zero if no pages free 
062d			; e contains the file id to locate 
062d			; d contains the block number 
062d			 
062d			; TODO change to find file id and use zero for free block 
062d			 
062d			storage_findnextid: 
062d			 
062d				; now locate first 0 page to mark as a free block 
062d			 
062d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062f			;	ld hl, STORE_BLOCK_PHY 
062f			 
062f					if DEBUG_FORTH_WORDS 
062f					DMARK "FNI" 
062f f5				push af  
0630 3a 44 06			ld a, (.dmark)  
0633 32 77 fb			ld (debug_mark),a  
0636 3a 45 06			ld a, (.dmark+1)  
0639 32 78 fb			ld (debug_mark+1),a  
063c 3a 46 06			ld a, (.dmark+2)  
063f 32 79 fb			ld (debug_mark+2),a  
0642 18 03			jr .pastdmark  
0644 ..			.dmark: db "FNI"  
0647 f1			.pastdmark: pop af  
0648			endm  
# End of macro DMARK
0648						CALLMONITOR 
0648 cd 97 16			call break_point_state  
064b				endm  
# End of macro CALLMONITOR
064b					endif 
064b			.ff1:   	 
064b e5					push hl 
064c c5					push bc 
064d d5					push de 
064e cd 8c 02				call se_readbyte 
0651 5f					ld e,a 
0652 23					inc hl 
0653 cd 8c 02				call se_readbyte 
0656 57					ld d, a 
0657 e1					pop hl 
0658 e5					push hl 
0659 cd 27 0d				call cmp16 
065c 28 49				jr z, .fffound 
065e			 
065e d1					pop de 
065f c1					pop bc 
0660 e1					pop hl 
0661			 
0661					; is found? 
0661					;cp e 
0661					;ret z 
0661			 
0661 3e 40				ld a, STORE_BLOCK_PHY 
0663 cd 09 0d				call addatohl 
0666 10 e3				djnz .ff1 
0668			 
0668 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066a			.ff2:   	 
066a			 
066a e5					push hl 
066b c5					push bc 
066c d5					push de 
066d cd 8c 02				call se_readbyte 
0670 5f					ld e,a 
0671 23					inc hl 
0672 cd 8c 02				call se_readbyte 
0675 57					ld d, a 
0676			 
0676 e1					pop hl 
0677 e5					push hl 
0678 cd 27 0d				call cmp16 
067b 28 2a				jr z, .fffound 
067d			 
067d d1					pop de 
067e c1					pop bc 
067f e1					pop hl 
0680					; is found? 
0680					;cp e 
0680					;ret z 
0680			 
0680 3e 40				ld a, STORE_BLOCK_PHY 
0682 cd 09 0d				call addatohl 
0685 10 e3				djnz .ff2 
0687			 
0687			 
0687					if DEBUG_FORTH_WORDS 
0687					DMARK "FN-" 
0687 f5				push af  
0688 3a 9c 06			ld a, (.dmark)  
068b 32 77 fb			ld (debug_mark),a  
068e 3a 9d 06			ld a, (.dmark+1)  
0691 32 78 fb			ld (debug_mark+1),a  
0694 3a 9e 06			ld a, (.dmark+2)  
0697 32 79 fb			ld (debug_mark+2),a  
069a 18 03			jr .pastdmark  
069c ..			.dmark: db "FN-"  
069f f1			.pastdmark: pop af  
06a0			endm  
# End of macro DMARK
06a0					;	push af 
06a0					;	ld a, 'n' 
06a0					;	ld (debug_mark),a 
06a0					;	pop af 
06a0						CALLMONITOR 
06a0 cd 97 16			call break_point_state  
06a3				endm  
# End of macro CALLMONITOR
06a3					endif 
06a3				; no free marks! 
06a3 21 00 00				ld hl, 0 
06a6 c9				ret 
06a7			.fffound: 
06a7				 
06a7			 
06a7 d1					pop de 
06a8 c1					pop bc 
06a9 e1					pop hl 
06aa					if DEBUG_FORTH_WORDS 
06aa					DMARK "FNF" 
06aa f5				push af  
06ab 3a bf 06			ld a, (.dmark)  
06ae 32 77 fb			ld (debug_mark),a  
06b1 3a c0 06			ld a, (.dmark+1)  
06b4 32 78 fb			ld (debug_mark+1),a  
06b7 3a c1 06			ld a, (.dmark+2)  
06ba 32 79 fb			ld (debug_mark+2),a  
06bd 18 03			jr .pastdmark  
06bf ..			.dmark: db "FNF"  
06c2 f1			.pastdmark: pop af  
06c3			endm  
# End of macro DMARK
06c3					;	push af 
06c3					;	ld a, 'n' 
06c3					;	ld (debug_mark),a 
06c3					;	pop af 
06c3						CALLMONITOR 
06c3 cd 97 16			call break_point_state  
06c6				endm  
# End of macro CALLMONITOR
06c6					endif 
06c6 c9				ret 
06c7			 
06c7			 
06c7			 
06c7			; Free Space 
06c7			; ---------- 
06c7			; 
06c7			; With current bank 
06c7			; 
06c7			; Set block count to zero 
06c7			; Starting with first logical block 
06c7			;      Find free block  
06c7			;      If block id given, increment block count 
06c7			; 
06c7			;  
06c7			 
06c7			 
06c7			; hl contains count of free blocks 
06c7			 
06c7			storage_freeblocks: 
06c7			 
06c7				; now locate first 0 page to mark as a free block 
06c7			 
06c7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c9 21 40 00			ld hl, STORE_BLOCK_PHY 
06cc 11 00 00			ld de, 0 
06cf			 
06cf			.fb1:   	 
06cf e5					push hl 
06d0 c5					push bc 
06d1 d5					push de 
06d2 cd 8c 02				call se_readbyte 
06d5 d1					pop de 
06d6 c1					pop bc 
06d7 e1					pop hl 
06d8			 
06d8					; is free? 
06d8 fe 00				cp 0 
06da 20 01				jr nz, .ff1cont 
06dc 13					inc de 
06dd			 
06dd			.ff1cont: 
06dd			 
06dd			 
06dd 3e 40				ld a, STORE_BLOCK_PHY 
06df cd 09 0d				call addatohl 
06e2 10 eb				djnz .fb1 
06e4			 
06e4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e6			.fb2:   	 
06e6 e5					push hl 
06e7 c5					push bc 
06e8 d5					push de 
06e9 cd 8c 02				call se_readbyte 
06ec d1					pop de 
06ed c1					pop bc 
06ee e1					pop hl 
06ef			 
06ef					; is free? 
06ef fe 00				cp 0 
06f1 20 01				jr nz, .ff2cont 
06f3 13					inc de 
06f4			 
06f4			.ff2cont: 
06f4			 
06f4 3e 40				ld a, STORE_BLOCK_PHY 
06f6 cd 09 0d				call addatohl 
06f9 10 eb				djnz .fb2 
06fb			 
06fb eb				ex de, hl 
06fc c9				ret 
06fd			 
06fd			; Get File ID 
06fd			; ----------- 
06fd			; 
06fd			; With current bank 
06fd			;  
06fd			; Load Block 0 Config 
06fd			; Get max file id number 
06fd			; For each logical block 
06fd			;    Read block file id 
06fd			;      If first block of file and dont have file id 
06fd			;         if file get id and exit 
06fd			 
06fd			 
06fd			 
06fd			 
06fd			; Create File 
06fd			; ----------- 
06fd			; 
06fd			; With current bank  
06fd			; Load Block 0 Config 
06fd			; Get max file id number 
06fd			; Increment file id number 
06fd			; Save Config 
06fd			; Find free block 
06fd			; Set buffer with file name and file id 
06fd			; Write buffer to free block  
06fd			 
06fd			 
06fd			; hl point to file name 
06fd			; hl returns file id 
06fd			 
06fd			; file format: 
06fd			; byte 0 - file id 
06fd			; byte 1 - extent number 
06fd			; byte 2-> data 
06fd			 
06fd			; format for extent number 0: 
06fd			; 
06fd			; byte 0 - file id 
06fd			; byte 1 - extent 0 
06fd			; byte 2 - extent count 
06fd			; byte 3 -> file name and meta data 
06fd			 
06fd			 
06fd			storage_create: 
06fd				if DEBUG_STORESE 
06fd					DMARK "SCR" 
06fd f5				push af  
06fe 3a 12 07			ld a, (.dmark)  
0701 32 77 fb			ld (debug_mark),a  
0704 3a 13 07			ld a, (.dmark+1)  
0707 32 78 fb			ld (debug_mark+1),a  
070a 3a 14 07			ld a, (.dmark+2)  
070d 32 79 fb			ld (debug_mark+2),a  
0710 18 03			jr .pastdmark  
0712 ..			.dmark: db "SCR"  
0715 f1			.pastdmark: pop af  
0716			endm  
# End of macro DMARK
0716					CALLMONITOR 
0716 cd 97 16			call break_point_state  
0719				endm  
# End of macro CALLMONITOR
0719				endif 
0719			 
0719 e5				push hl		; save file name pointer 
071a			 
071a cd bd 03			call storage_get_block_0 
071d			 
071d 3a 62 f8			ld a,(store_page)	; get current file id 
0720 3c				inc a 
0721 32 62 f8			ld (store_page),a 
0724				 
0724 32 5b f8			ld (store_tmpid),a			; save id 
0727			 
0727 21 00 00			ld hl, 0 
072a 11 62 f8			ld de, store_page 
072d				if DEBUG_STORESE 
072d					DMARK "SCw" 
072d f5				push af  
072e 3a 42 07			ld a, (.dmark)  
0731 32 77 fb			ld (debug_mark),a  
0734 3a 43 07			ld a, (.dmark+1)  
0737 32 78 fb			ld (debug_mark+1),a  
073a 3a 44 07			ld a, (.dmark+2)  
073d 32 79 fb			ld (debug_mark+2),a  
0740 18 03			jr .pastdmark  
0742 ..			.dmark: db "SCw"  
0745 f1			.pastdmark: pop af  
0746			endm  
# End of macro DMARK
0746					CALLMONITOR 
0746 cd 97 16			call break_point_state  
0749				endm  
# End of macro CALLMONITOR
0749				endif 
0749 cd 71 03			call storage_write_block	 ; save update 
074c			 
074c				if DEBUG_STORESE 
074c 11 62 f8				ld de, store_page 
074f					DMARK "SCC" 
074f f5				push af  
0750 3a 64 07			ld a, (.dmark)  
0753 32 77 fb			ld (debug_mark),a  
0756 3a 65 07			ld a, (.dmark+1)  
0759 32 78 fb			ld (debug_mark+1),a  
075c 3a 66 07			ld a, (.dmark+2)  
075f 32 79 fb			ld (debug_mark+2),a  
0762 18 03			jr .pastdmark  
0764 ..			.dmark: db "SCC"  
0767 f1			.pastdmark: pop af  
0768			endm  
# End of macro DMARK
0768					CALLMONITOR 
0768 cd 97 16			call break_point_state  
076b				endm  
# End of macro CALLMONITOR
076b				endif 
076b				;  
076b				 
076b 21 40 00			ld hl, STORE_BLOCK_PHY 
076e 11 00 00			ld de, 0 
0771 cd 2d 06			call storage_findnextid 
0774			 
0774 22 4c f8			ld (store_tmppageid), hl    ; save page to use  
0777			 
0777				; TODO detect 0 = no spare blocks 
0777			 
0777				; hl now contains the free page to use for the file header page 
0777			 
0777				if DEBUG_STORESE 
0777				DMARK "SCF" 
0777 f5				push af  
0778 3a 8c 07			ld a, (.dmark)  
077b 32 77 fb			ld (debug_mark),a  
077e 3a 8d 07			ld a, (.dmark+1)  
0781 32 78 fb			ld (debug_mark+1),a  
0784 3a 8e 07			ld a, (.dmark+2)  
0787 32 79 fb			ld (debug_mark+2),a  
078a 18 03			jr .pastdmark  
078c ..			.dmark: db "SCF"  
078f f1			.pastdmark: pop af  
0790			endm  
# End of macro DMARK
0790					CALLMONITOR 
0790 cd 97 16			call break_point_state  
0793				endm  
# End of macro CALLMONITOR
0793				endif 
0793			 
0793 22 4c f8			ld (store_tmppageid), hl 
0796				 
0796 3a 5b f8			ld a,(store_tmpid)    ; get file id 
0799			;	ld a, (store_filecache)			; save to cache 
0799			 
0799 32 62 f8			ld (store_page),a    ; set page id 
079c 3e 00			ld a, 0			 ; extent 0 is file header 
079e 32 63 f8			ld (store_page+1), a   ; set file extent 
07a1			 
07a1 32 64 f8			ld (store_page+2), a   ; extent count for the file 
07a4			 
07a4			;	inc hl 		; init block 0 of file 
07a4			;	inc hl   		; skip file and extent id 
07a4			 ;       ld a, 0 
07a4			;	ld (hl),a 
07a4			;	ld a, (store_filecache+1)  	; save to cache 
07a4			 
07a4			;	inc hl    ; file name 
07a4				 
07a4				 
07a4 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
07a7				if DEBUG_STORESE 
07a7					DMARK "SCc" 
07a7 f5				push af  
07a8 3a bc 07			ld a, (.dmark)  
07ab 32 77 fb			ld (debug_mark),a  
07ae 3a bd 07			ld a, (.dmark+1)  
07b1 32 78 fb			ld (debug_mark+1),a  
07b4 3a be 07			ld a, (.dmark+2)  
07b7 32 79 fb			ld (debug_mark+2),a  
07ba 18 03			jr .pastdmark  
07bc ..			.dmark: db "SCc"  
07bf f1			.pastdmark: pop af  
07c0			endm  
# End of macro DMARK
07c0					CALLMONITOR 
07c0 cd 97 16			call break_point_state  
07c3				endm  
# End of macro CALLMONITOR
07c3				endif 
07c3 e1				pop hl    ; get zero term string 
07c4 e5				push hl 
07c5 3e 00			ld a, 0 
07c7 cd 72 11			call strlent 
07ca 23				inc hl   ; cover zero term 
07cb 06 00			ld b,0 
07cd 4d				ld c,l 
07ce e1				pop hl 
07cf				;ex de, hl 
07cf				if DEBUG_STORESE 
07cf					DMARK "SCa" 
07cf f5				push af  
07d0 3a e4 07			ld a, (.dmark)  
07d3 32 77 fb			ld (debug_mark),a  
07d6 3a e5 07			ld a, (.dmark+1)  
07d9 32 78 fb			ld (debug_mark+1),a  
07dc 3a e6 07			ld a, (.dmark+2)  
07df 32 79 fb			ld (debug_mark+2),a  
07e2 18 03			jr .pastdmark  
07e4 ..			.dmark: db "SCa"  
07e7 f1			.pastdmark: pop af  
07e8			endm  
# End of macro DMARK
07e8					;push af 
07e8					;ld a, 'a' 
07e8					;ld (debug_mark),a 
07e8					;pop af 
07e8					CALLMONITOR 
07e8 cd 97 16			call break_point_state  
07eb				endm  
# End of macro CALLMONITOR
07eb				endif 
07eb ed b0			ldir    ; copy zero term string 
07ed				if DEBUG_STORESE 
07ed					DMARK "SCA" 
07ed f5				push af  
07ee 3a 02 08			ld a, (.dmark)  
07f1 32 77 fb			ld (debug_mark),a  
07f4 3a 03 08			ld a, (.dmark+1)  
07f7 32 78 fb			ld (debug_mark+1),a  
07fa 3a 04 08			ld a, (.dmark+2)  
07fd 32 79 fb			ld (debug_mark+2),a  
0800 18 03			jr .pastdmark  
0802 ..			.dmark: db "SCA"  
0805 f1			.pastdmark: pop af  
0806			endm  
# End of macro DMARK
0806					CALLMONITOR 
0806 cd 97 16			call break_point_state  
0809				endm  
# End of macro CALLMONITOR
0809				endif 
0809			 
0809				; write file header page 
0809			 
0809 2a 4c f8			ld hl,(store_tmppageid) 
080c 11 62 f8			ld de, store_page 
080f				if DEBUG_STORESE 
080f					DMARK "SCb" 
080f f5				push af  
0810 3a 24 08			ld a, (.dmark)  
0813 32 77 fb			ld (debug_mark),a  
0816 3a 25 08			ld a, (.dmark+1)  
0819 32 78 fb			ld (debug_mark+1),a  
081c 3a 26 08			ld a, (.dmark+2)  
081f 32 79 fb			ld (debug_mark+2),a  
0822 18 03			jr .pastdmark  
0824 ..			.dmark: db "SCb"  
0827 f1			.pastdmark: pop af  
0828			endm  
# End of macro DMARK
0828					;push af 
0828					;ld a, 'b' 
0828					;ld (debug_mark),a 
0828					;pop af 
0828					CALLMONITOR 
0828 cd 97 16			call break_point_state  
082b				endm  
# End of macro CALLMONITOR
082b				endif 
082b cd 71 03			call storage_write_block 
082e			 
082e 3a 5b f8			ld a, (store_tmpid) 
0831 6f				ld l, a 
0832 26 00			ld h,0 
0834				if DEBUG_STORESE 
0834					DMARK "SCz" 
0834 f5				push af  
0835 3a 49 08			ld a, (.dmark)  
0838 32 77 fb			ld (debug_mark),a  
083b 3a 4a 08			ld a, (.dmark+1)  
083e 32 78 fb			ld (debug_mark+1),a  
0841 3a 4b 08			ld a, (.dmark+2)  
0844 32 79 fb			ld (debug_mark+2),a  
0847 18 03			jr .pastdmark  
0849 ..			.dmark: db "SCz"  
084c f1			.pastdmark: pop af  
084d			endm  
# End of macro DMARK
084d					CALLMONITOR 
084d cd 97 16			call break_point_state  
0850				endm  
# End of macro CALLMONITOR
0850				endif 
0850 c9				ret 
0851				 
0851			 
0851			 
0851			; 
0851			; Read File 
0851			; 
0851			; h - file id to locate 
0851			; l - extent to locate 
0851			; de - pointer to string to read into 
0851			; 
0851			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0851			storage_read: 
0851 d5				push de 
0852			 
0852			; TODO BUG the above push is it popped before the RET Z? 
0852			 
0852			; TODO how to handle multiple part blocks 
0852			 
0852				; locate file extent to read 
0852			 
0852 5c				ld e, h 
0853 55				ld d, l 
0854 21 40 00			ld hl, STORE_BLOCK_PHY 
0857				if DEBUG_STORESE 
0857					DMARK "SRE" 
0857 f5				push af  
0858 3a 6c 08			ld a, (.dmark)  
085b 32 77 fb			ld (debug_mark),a  
085e 3a 6d 08			ld a, (.dmark+1)  
0861 32 78 fb			ld (debug_mark+1),a  
0864 3a 6e 08			ld a, (.dmark+2)  
0867 32 79 fb			ld (debug_mark+2),a  
086a 18 03			jr .pastdmark  
086c ..			.dmark: db "SRE"  
086f f1			.pastdmark: pop af  
0870			endm  
# End of macro DMARK
0870					CALLMONITOR 
0870 cd 97 16			call break_point_state  
0873				endm  
# End of macro CALLMONITOR
0873				endif 
0873 cd 2d 06			call storage_findnextid 
0876			 
0876				if DEBUG_STORESE 
0876					DMARK "SRf" 
0876 f5				push af  
0877 3a 8b 08			ld a, (.dmark)  
087a 32 77 fb			ld (debug_mark),a  
087d 3a 8c 08			ld a, (.dmark+1)  
0880 32 78 fb			ld (debug_mark+1),a  
0883 3a 8d 08			ld a, (.dmark+2)  
0886 32 79 fb			ld (debug_mark+2),a  
0889 18 03			jr .pastdmark  
088b ..			.dmark: db "SRf"  
088e f1			.pastdmark: pop af  
088f			endm  
# End of macro DMARK
088f					CALLMONITOR 
088f cd 97 16			call break_point_state  
0892				endm  
# End of macro CALLMONITOR
0892				endif 
0892 cd 32 0d			call ishlzero 
0895			;	ld a, l 
0895			;	add h 
0895			;	cp 0 
0895 c8				ret z			; block not found so EOF 
0896			 
0896				; hl contains page number to load 
0896 d1				pop de   ; get storage 
0897 d5				push de 
0898				if DEBUG_STORESE 
0898					DMARK "SRg" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 77 fb			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 78 fb			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 79 fb			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SRg"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd 97 16			call break_point_state  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd 0c 03			call storage_read_block 
08b7			 
08b7			 
08b7			; TODO if block has no zeros then need to read next block  
08b7			 
08b7			 
08b7					 
08b7 e1				pop hl 		 ; return start of data to show as not EOF 
08b8 23				inc hl   ; past file id 
08b9 23				inc hl   ; past ext 
08ba				if DEBUG_STORESE 
08ba					DMARK "SRe" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 77 fb			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 78 fb			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 79 fb			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SRe"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd 97 16			call break_point_state  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6 c9					ret 
08d7			 
08d7			 
08d7			 
08d7			; 
08d7			; Append File 
08d7			; 
08d7			; hl - file id to locate 
08d7			; de - pointer to (multi block) string to write 
08d7			 
08d7			 
08d7			storage_append: 
08d7				; hl -  file id to append to 
08d7				; de - string to append 
08d7			 
08d7 d5				push de 
08d8				 
08d8				if DEBUG_STORESE 
08d8					DMARK "AP1" 
08d8 f5				push af  
08d9 3a ed 08			ld a, (.dmark)  
08dc 32 77 fb			ld (debug_mark),a  
08df 3a ee 08			ld a, (.dmark+1)  
08e2 32 78 fb			ld (debug_mark+1),a  
08e5 3a ef 08			ld a, (.dmark+2)  
08e8 32 79 fb			ld (debug_mark+2),a  
08eb 18 03			jr .pastdmark  
08ed ..			.dmark: db "AP1"  
08f0 f1			.pastdmark: pop af  
08f1			endm  
# End of macro DMARK
08f1					CALLMONITOR 
08f1 cd 97 16			call break_point_state  
08f4				endm  
# End of macro CALLMONITOR
08f4				endif 
08f4			 
08f4 7d				ld a, l 
08f5 32 5b f8			ld (store_tmpid), a 
08f8			 
08f8				; get file header  
08f8			 
08f8 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08fa 3a 5b f8			ld a, (store_tmpid) 
08fd 5f				ld e, a 
08fe			 
08fe 21 40 00				ld hl, STORE_BLOCK_PHY 
0901 cd 2d 06				call storage_findnextid 
0904			 
0904 22 4c f8			ld (store_tmppageid), hl 
0907			 
0907				; TODO handle file id not found 
0907			 
0907				if DEBUG_STORESE 
0907					DMARK "AP2" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 77 fb			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 78 fb			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 79 fb			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "AP2"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd 97 16			call break_point_state  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923			 
0923				; update file extent count 
0923			 
0923 11 62 f8			ld de, store_page 
0926			 
0926 cd 0c 03			call storage_read_block 
0929			 
0929				if DEBUG_STORESE 
0929					DMARK "AP3" 
0929 f5				push af  
092a 3a 3e 09			ld a, (.dmark)  
092d 32 77 fb			ld (debug_mark),a  
0930 3a 3f 09			ld a, (.dmark+1)  
0933 32 78 fb			ld (debug_mark+1),a  
0936 3a 40 09			ld a, (.dmark+2)  
0939 32 79 fb			ld (debug_mark+2),a  
093c 18 03			jr .pastdmark  
093e ..			.dmark: db "AP3"  
0941 f1			.pastdmark: pop af  
0942			endm  
# End of macro DMARK
0942					CALLMONITOR 
0942 cd 97 16			call break_point_state  
0945				endm  
# End of macro CALLMONITOR
0945				endif 
0945			;	ld (store_tmppageid), hl 
0945			 
0945 3a 64 f8			ld a, (store_page+2) 
0948 3c				inc a 
0949 32 64 f8			ld (store_page+2), a 
094c 32 5a f8			ld (store_tmpext), a 
094f				 
094f				if DEBUG_STORESE 
094f					DMARK "AP3" 
094f f5				push af  
0950 3a 64 09			ld a, (.dmark)  
0953 32 77 fb			ld (debug_mark),a  
0956 3a 65 09			ld a, (.dmark+1)  
0959 32 78 fb			ld (debug_mark+1),a  
095c 3a 66 09			ld a, (.dmark+2)  
095f 32 79 fb			ld (debug_mark+2),a  
0962 18 03			jr .pastdmark  
0964 ..			.dmark: db "AP3"  
0967 f1			.pastdmark: pop af  
0968			endm  
# End of macro DMARK
0968					CALLMONITOR 
0968 cd 97 16			call break_point_state  
096b				endm  
# End of macro CALLMONITOR
096b				endif 
096b 2a 4c f8			ld hl, (store_tmppageid) 
096e 11 62 f8			ld de, store_page 
0971 cd 71 03			call storage_write_block 
0974			 
0974				; find free block 
0974			 
0974 11 00 00			ld de, 0			 ; file extent to locate 
0977			 
0977 21 40 00				ld hl, STORE_BLOCK_PHY 
097a cd 2d 06				call storage_findnextid 
097d			 
097d					; TODO handle no space left 
097d					 
097d 22 4c f8				ld (store_tmppageid), hl 
0980			 
0980				if DEBUG_STORESE 
0980					DMARK "AP4" 
0980 f5				push af  
0981 3a 95 09			ld a, (.dmark)  
0984 32 77 fb			ld (debug_mark),a  
0987 3a 96 09			ld a, (.dmark+1)  
098a 32 78 fb			ld (debug_mark+1),a  
098d 3a 97 09			ld a, (.dmark+2)  
0990 32 79 fb			ld (debug_mark+2),a  
0993 18 03			jr .pastdmark  
0995 ..			.dmark: db "AP4"  
0998 f1			.pastdmark: pop af  
0999			endm  
# End of macro DMARK
0999					CALLMONITOR 
0999 cd 97 16			call break_point_state  
099c				endm  
# End of macro CALLMONITOR
099c				endif 
099c					; init the buffer with zeros so we can id if the buffer is full or not 
099c			 
099c e5					push hl 
099d c5					push bc 
099e			 
099e 21 62 f8				ld hl, store_page 
09a1 06 40				ld b, STORE_BLOCK_PHY 
09a3 3e 00				ld a, 0 
09a5 77			.zeroblock:	ld (hl), a 
09a6 23					inc hl 
09a7 10 fc				djnz .zeroblock 
09a9			 
09a9 c1					pop bc 
09aa e1					pop hl 
09ab			 
09ab					; construct block 
09ab			 
09ab 3a 5b f8				ld a, (store_tmpid) 
09ae 32 62 f8				ld (store_page), a   ; file id 
09b1 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09b4 32 63 f8				ld (store_page+1), a 
09b7			 
09b7 e1					pop hl    ; get string to write 
09b8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09ba 11 64 f8				ld de, store_page+2 
09bd			 
09bd				if DEBUG_STORESE 
09bd					DMARK "AP5" 
09bd f5				push af  
09be 3a d2 09			ld a, (.dmark)  
09c1 32 77 fb			ld (debug_mark),a  
09c4 3a d3 09			ld a, (.dmark+1)  
09c7 32 78 fb			ld (debug_mark+1),a  
09ca 3a d4 09			ld a, (.dmark+2)  
09cd 32 79 fb			ld (debug_mark+2),a  
09d0 18 03			jr .pastdmark  
09d2 ..			.dmark: db "AP5"  
09d5 f1			.pastdmark: pop af  
09d6			endm  
# End of macro DMARK
09d6					CALLMONITOR 
09d6 cd 97 16			call break_point_state  
09d9				endm  
# End of macro CALLMONITOR
09d9				endif 
09d9			 
09d9			 
09d9			 
09d9					; fill buffer with data until end of string or full block 
09d9			 
09d9 7e			.appd:		ld a, (hl) 
09da 12					ld (de), a 
09db fe 00				cp 0 
09dd 28 04				jr z, .appdone 
09df 23					inc hl 
09e0 13					inc de 
09e1 10 f6				djnz .appd 
09e3			 
09e3 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e4 f5					push af   		; save last byte dumped 
09e5			 
09e5			 
09e5 2a 4c f8			ld hl, (store_tmppageid) 
09e8 11 62 f8			ld de, store_page 
09eb				if DEBUG_STORESE 
09eb					DMARK "AP6" 
09eb f5				push af  
09ec 3a 00 0a			ld a, (.dmark)  
09ef 32 77 fb			ld (debug_mark),a  
09f2 3a 01 0a			ld a, (.dmark+1)  
09f5 32 78 fb			ld (debug_mark+1),a  
09f8 3a 02 0a			ld a, (.dmark+2)  
09fb 32 79 fb			ld (debug_mark+2),a  
09fe 18 03			jr .pastdmark  
0a00 ..			.dmark: db "AP6"  
0a03 f1			.pastdmark: pop af  
0a04			endm  
# End of macro DMARK
0a04					CALLMONITOR 
0a04 cd 97 16			call break_point_state  
0a07				endm  
# End of macro CALLMONITOR
0a07				endif 
0a07 cd 71 03				call storage_write_block 
0a0a			 
0a0a			 
0a0a				; was that a full block of data written? 
0a0a				; any more to write out? 
0a0a			 
0a0a				; if yes then set vars and jump to start of function again 
0a0a			 
0a0a f1					pop af 
0a0b d1					pop de 
0a0c			 
0a0c fe 00				cp 0		 ; no, string was fully written 
0a0e c8					ret z 
0a0f			 
0a0f					; setup vars for next cycle 
0a0f			 
0a0f 3a 5b f8				ld a, (store_tmpid) 
0a12 6f					ld l, a 
0a13 26 00				ld h, 0 
0a15			 
0a15 c3 d7 08			 	jp storage_append	 ; yes, need to write out some more 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			if DEBUG_STORECF 
0a18			storageput:	 
0a18					ret 
0a18			storageread: 
0a18					ld hl, store_page 
0a18					ld b, 200 
0a18					ld a,0 
0a18			.src:		ld (hl),a 
0a18					inc hl 
0a18					djnz .src 
0a18					 
0a18			 
0a18					ld de, 0 
0a18					ld bc, 1 
0a18					ld hl, store_page 
0a18					call cfRead 
0a18			 
0a18				call cfGetError 
0a18				ld hl,scratch 
0a18				call hexout 
0a18				ld hl, scratch+2 
0a18				ld a, 0 
0a18				ld (hl),a 
0a18				ld de, scratch 
0a18				ld a,display_row_1 
0a18				call str_at_display 
0a18				call update_display 
0a18			 
0a18					ld hl, store_page 
0a18					ld (os_cur_ptr),hl 
0a18			 
0a18					ret 
0a18			endif 
0a18			 
0a18			 
0a18			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a18			 
0a18			storage_clear_page: 
0a18 e5				push hl 
0a19 d5				push de 
0a1a c5				push bc 
0a1b 21 62 f8			ld hl, store_page 
0a1e 3e 00			ld a, 0 
0a20 77				ld (hl), a 
0a21			 
0a21 11 63 f8			ld de, store_page+1 
0a24 01 40 00			ld bc, STORE_BLOCK_PHY 
0a27			 
0a27 ed b0			ldir 
0a29				 
0a29 c1				pop bc 
0a2a d1				pop de 
0a2b e1				pop hl 
0a2c c9				ret 
0a2d			 
0a2d			; eof 
# End of file firmware_storage.asm
0a2d			  
0a2d			; support routines for above hardware abstraction layer  
0a2d			  
0a2d			include "firmware_general.asm"        ; general support functions  
0a2d			 
0a2d			; word look up 
0a2d			 
0a2d			; in 
0a2d			; a is the index 
0a2d			; hl is pointer start of array 
0a2d			; 
0a2d			; returns 
0a2d			; hl to the word 
0a2d			; 
0a2d			 
0a2d			table_lookup:  
0a2d d5					push de 
0a2e eb					ex de, hl 
0a2f			 
0a2f 6f					ld l, a 
0a30 26 00				ld h, 0 
0a32 29					add hl, hl 
0a33 19					add hl, de 
0a34 7e					ld a, (hl) 
0a35 23					inc hl 
0a36 66					ld h,(hl) 
0a37 6f					ld l, a 
0a38			 
0a38 d1					pop de 
0a39 c9					ret 
0a3a			 
0a3a			; Delay loops 
0a3a			 
0a3a			 
0a3a			 
0a3a			aDelayInMS: 
0a3a c5				push bc 
0a3b 47				ld b,a 
0a3c			msdelay: 
0a3c c5				push bc 
0a3d				 
0a3d			 
0a3d 01 41 00			ld bc,041h 
0a40 cd 58 0a			call delayloop 
0a43 c1				pop bc 
0a44 05				dec b 
0a45 20 f5			jr nz,msdelay 
0a47			 
0a47			;if CPU_CLOCK_8MHZ 
0a47			;msdelay8: 
0a47			;	push bc 
0a47			;	 
0a47			; 
0a47			;	ld bc,041h 
0a47			;	call delayloop 
0a47			;	pop bc 
0a47			;	dec b 
0a47			;	jr nz,msdelay8 
0a47			;endif 
0a47			 
0a47			 
0a47 c1				pop bc 
0a48 c9				ret 
0a49			 
0a49			 
0a49			delay250ms: 
0a49				;push de 
0a49 01 00 40			ld bc, 04000h 
0a4c c3 58 0a			jp delayloop 
0a4f			delay500ms: 
0a4f				;push de 
0a4f 01 00 80			ld bc, 08000h 
0a52 c3 58 0a			jp delayloop 
0a55			delay1s: 
0a55				;push bc 
0a55			   ; Clobbers A, d and e 
0a55 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a58			delayloop: 
0a58 c5			    push bc 
0a59			 
0a59			if BASE_CPM 
0a59				ld bc, CPM_DELAY_TUNE 
0a59			.cpmloop: 
0a59				push bc 
0a59			 
0a59			endif 
0a59			 
0a59			 
0a59			 
0a59			delayloopi: 
0a59			;	push bc 
0a59			;.dl: 
0a59 cb 47		    bit     0,a    	; 8 
0a5b cb 47		    bit     0,a    	; 8 
0a5d cb 47		    bit     0,a    	; 8 
0a5f e6 ff		    and     255  	; 7 
0a61 0b			    dec     bc      	; 6 
0a62 79			    ld      a,c     	; 4 
0a63 b0			    or      b     	; 4 
0a64 c2 59 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a67			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a67				;pop de 
0a67			;pop bc 
0a67			 
0a67			if BASE_CPM 
0a67				pop bc 
0a67				 
0a67			    dec     bc      	; 6 
0a67			    ld      a,c     	; 4 
0a67			    or      b     	; 4 
0a67			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a67				 
0a67			 
0a67			endif 
0a67			;if CPU_CLOCK_8MHZ 
0a67			;    pop bc 
0a67			;    push bc 
0a67			;.dl8: 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    and     255  	; 7 
0a67			;    dec     bc      	; 6 
0a67			;    ld      a,c     	; 4 
0a67			;    or      b     	; 4 
0a67			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a67			;endif 
0a67			 
0a67			;if CPU_CLOCK_10MHZ 
0a67			;    pop bc 
0a67			;    push bc 
0a67			;.dl8: 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    and     255  	; 7 
0a67			;    dec     bc      	; 6 
0a67			;    ld      a,c     	; 4 
0a67			;    or      b     	; 4 
0a67			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a67			;endif 
0a67 c1			    pop bc 
0a68			 
0a68 c9				ret 
0a69			 
0a69			 
0a69			 
0a69			; eof 
# End of file firmware_general.asm
0a69			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a69			; display routines that use the physical hardware abstraction layer 
0a69			 
0a69			 
0a69			; information window 
0a69			 
0a69			; pass hl with 1st string to display 
0a69			; pass de with 2nd string to display 
0a69			 
0a69			info_panel: 
0a69 e5				push hl 
0a6a			 
0a6a 2a d8 f8			ld hl, (display_fb_active) 
0a6d e5				push hl    ; future de destination 
0a6e 21 bd fa				ld hl, display_fb0 
0a71 22 d8 f8				ld (display_fb_active), hl 
0a74			 
0a74 cd d5 0a			call clear_display 
0a77			 
0a77			 
0a77 3e 55			ld a, display_row_3 + 5 
0a79 cd e8 0a			call str_at_display 
0a7c			 
0a7c e1				pop hl 
0a7d d1				pop de 
0a7e			 
0a7e e5				push hl 
0a7f			 
0a7f			 
0a7f 3e 2d			ld a, display_row_2 + 5 
0a81 cd e8 0a			call str_at_display 
0a84			 
0a84			 
0a84 cd f8 0a			call update_display 
0a87 cd 9f 1b			call next_page_prompt 
0a8a cd d5 0a			call clear_display 
0a8d			 
0a8d				 
0a8d 21 1c fa				ld hl, display_fb1 
0a90 22 d8 f8				ld (display_fb_active), hl 
0a93 cd f8 0a			call update_display 
0a96			 
0a96			 
0a96 c9				ret 
0a97			 
0a97			 
0a97			 
0a97			 
0a97			; TODO windowing? 
0a97			 
0a97			; TODO scroll line up 
0a97			 
0a97			scroll_up: 
0a97			 
0a97 e5				push hl 
0a98 d5				push de 
0a99 c5				push bc 
0a9a			 
0a9a				; get frame buffer  
0a9a			 
0a9a 2a d8 f8			ld hl, (display_fb_active) 
0a9d e5				push hl    ; future de destination 
0a9e			 
0a9e 11 28 00			ld  de, display_cols 
0aa1 19				add hl, de 
0aa2			 
0aa2 d1				pop de 
0aa3			 
0aa3				;ex de, hl 
0aa3 01 9f 00			ld bc, display_fb_len -1  
0aa6			;if DEBUG_FORTH_WORDS 
0aa6			;	DMARK "SCL" 
0aa6			;	CALLMONITOR 
0aa6			;endif	 
0aa6 ed b0			ldir 
0aa8			 
0aa8				; wipe bottom row 
0aa8			 
0aa8			 
0aa8 2a d8 f8			ld hl, (display_fb_active) 
0aab 11 a0 00			ld de, display_cols*display_rows 
0aae 19				add hl, de 
0aaf 06 28			ld b, display_cols 
0ab1 3e 20			ld a, ' ' 
0ab3			.scwipe: 
0ab3 77				ld (hl), a 
0ab4 2b				dec hl 
0ab5 10 fc			djnz .scwipe 
0ab7			 
0ab7				;pop hl 
0ab7			 
0ab7 c1				pop bc 
0ab8 d1				pop de 
0ab9 e1				pop hl 
0aba			 
0aba c9				ret 
0abb			 
0abb			 
0abb			;scroll_upo: 
0abb			;	ld de, display_row_1 
0abb			 ;	ld hl, display_row_2 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			;	ld de, display_row_2 
0abb			 ;	ld hl, display_row_3 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			;	ld de, display_row_3 
0abb			 ;	ld hl, display_row_4 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			 
0abb			; TODO clear row 4 
0abb			 
0abb			;	ret 
0abb			 
0abb				 
0abb			scroll_down: 
0abb			 
0abb e5				push hl 
0abc d5				push de 
0abd c5				push bc 
0abe			 
0abe				; get frame buffer  
0abe			 
0abe 2a d8 f8			ld hl, (display_fb_active) 
0ac1			 
0ac1 11 9f 00			ld de, display_fb_len - 1 
0ac4 19				add hl, de 
0ac5			 
0ac5 e5			push hl    ; future de destination 
0ac6			 
0ac6 11 28 00			ld  de, display_cols 
0ac9 ed 52			sbc hl, de 
0acb			 
0acb			 
0acb d1				pop de 
0acc			 
0acc			;	ex de, hl 
0acc 01 9f 00			ld bc, display_fb_len -1  
0acf			 
0acf			 
0acf				 
0acf			 
0acf ed b0			ldir 
0ad1			 
0ad1				; wipe bottom row 
0ad1			 
0ad1			 
0ad1			;	ld hl, (display_fb_active) 
0ad1			;;	ld de, display_cols*display_rows 
0ad1			;;	add hl, de 
0ad1			;	ld b, display_cols 
0ad1			;	ld a, ' ' 
0ad1			;.scwiped: 
0ad1			;	ld (hl), a 
0ad1			;	dec hl 
0ad1			;	djnz .scwiped 
0ad1			 
0ad1				;pop hl 
0ad1			 
0ad1 c1				pop bc 
0ad2 d1				pop de 
0ad3 e1				pop hl 
0ad4			 
0ad4 c9				ret 
0ad5			;scroll_down: 
0ad5			;	ld de, display_row_4 
0ad5			;	ld hl, display_row_3 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;	ld de, display_row_3 
0ad5			; 	ld hl, display_row_2 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;	ld de, display_row_2 
0ad5			;	ld hl, display_row_1 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;;; TODO clear row 1 
0ad5			;	ret 
0ad5			 
0ad5			 
0ad5			 
0ad5			 
0ad5			 
0ad5			; clear active frame buffer 
0ad5			 
0ad5			clear_display: 
0ad5 3e 20			ld a, ' ' 
0ad7 c3 da 0a			jp fill_display 
0ada			 
0ada			; fill active frame buffer with a char in A 
0ada			 
0ada			fill_display: 
0ada 06 a0			ld b,display_fb_len 
0adc 2a d8 f8			ld hl, (display_fb_active) 
0adf 77			.fd1:	ld (hl),a 
0ae0 23				inc hl 
0ae1 10 fc			djnz .fd1 
0ae3 23				inc hl 
0ae4 3e 00			ld a,0 
0ae6 77				ld (hl),a 
0ae7			 
0ae7			 
0ae7 c9				ret 
0ae8			; Write string (DE) at pos (A) to active frame buffer 
0ae8			 
0ae8 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0aeb 06 00					ld b,0 
0aed 4f					ld c,a 
0aee 09					add hl,bc 
0aef 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0af0 b7			            OR   A              ;Null terminator? 
0af1 c8			            RET  Z              ;Yes, so finished 
0af2 77					ld (hl),a 
0af3 23				inc hl 
0af4 13			            INC  DE             ;Point to next character 
0af5 18 f8		            JR   .sad1     ;Repeat 
0af7 c9					ret 
0af8			 
0af8			; using current frame buffer write to physical display 
0af8			 
0af8			update_display: 
0af8 e5				push hl 
0af9 2a d8 f8			ld hl, (display_fb_active) 
0afc cd 64 65			call write_display 
0aff e1				pop hl 
0b00 c9				ret 
0b01			 
0b01			; TODO scrolling 
0b01			 
0b01			 
0b01			; move cursor right one char 
0b01			cursor_right: 
0b01			 
0b01				; TODO shift right 
0b01				; TODO if beyond max col 
0b01				; TODO       cursor_next_line 
0b01			 
0b01 c9				ret 
0b02			 
0b02			 
0b02			cursor_next_line: 
0b02				; TODO first char 
0b02				; TODO line down 
0b02				; TODO if past last row 
0b02				; TODO    scroll up 
0b02			 
0b02 c9				ret 
0b03			 
0b03			cursor_left: 
0b03				; TODO shift left 
0b03				; TODO if beyond left  
0b03				; TODO     cursor prev line 
0b03				 
0b03 c9				ret 
0b04			 
0b04			cursor_prev_line: 
0b04				; TODO last char 
0b04				; TODO line up 
0b04				; TODO if past first row 
0b04				; TODO   scroll down 
0b04			 
0b04 c9				ret 
0b05			 
0b05			 
0b05			cout: 
0b05				; A - char 
0b05 c9				ret 
0b06			 
0b06			 
0b06			; Display a menu and allow item selection (optional toggle items) 
0b06			; 
0b06			; format: 
0b06			; hl pointer to word array with zero term for items 
0b06			; e.g.    db item1 
0b06			;         db .... 
0b06			;         db 0 
0b06			; 
0b06			; a = starting menu item  
0b06			; 
0b06			; de = pointer item toggle array   (todo) 
0b06			; 
0b06			; returns item selected in a 1-... 
0b06			; returns 0 if back button pressed 
0b06			; 
0b06			; NOTE: Uses system frame buffer to display 
0b06			; 
0b06			; LEFT, Q = go back 
0b06			; RIGHT, SPACE, CR = select 
0b06			; UP, A - Up 
0b06			; DOWN, Z - Down 
0b06			 
0b06			 
0b06			 
0b06			 
0b06			 
0b06			menu: 
0b06			 
0b06					; keep array pointer 
0b06			 
0b06 22 60 f8				ld (store_tmp1), hl 
0b09 32 5e f8				ld (store_tmp2), a 
0b0c			 
0b0c					; check for key bounce 
0b0c			 
0b0c			if BASE_KEV 
0b0c			 
0b0c cd af 68		.mbounce:	call cin 
0b0f fe 00				cp 0 
0b11 20 f9				jr nz, .mbounce 
0b13			endif 
0b13					; for ease use ex 
0b13			 
0b13					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b13 21 bd fa				ld hl, display_fb0 
0b16 22 d8 f8				ld (display_fb_active), hl 
0b19			 
0b19 cd d5 0a		.mloop:		call clear_display 
0b1c cd f8 0a				call update_display 
0b1f			 
0b1f					; draw selection id '>' at 1 
0b1f			 
0b1f					; init start of list display 
0b1f			 
0b1f 3e 05				ld a, 5 
0b21 32 5c f8				ld (store_tmp3), a   ; display row count 
0b24 3a 5e f8				ld a,( store_tmp2) 
0b27 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b2a			 
0b2a					 
0b2a			.mitem:	 
0b2a			 
0b2a			 
0b2a 3a 5f f8				ld a,(store_tmp2+1) 
0b2d 6f					ld l, a 
0b2e 26 00				ld h, 0 
0b30 29					add hl, hl 
0b31 ed 5b 60 f8			ld de, (store_tmp1) 
0b35 19					add hl, de 
0b36 7e					ld a, (hl) 
0b37 23					inc hl 
0b38 66					ld h,(hl) 
0b39 6f					ld l, a 
0b3a			 
0b3a cd 32 0d				call ishlzero 
0b3d 28 1a				jr z, .mdone 
0b3f			 
0b3f eb					ex de, hl 
0b40 3a 5c f8				ld a, (store_tmp3) 
0b43 cd e8 0a				call str_at_display 
0b46					 
0b46			 
0b46					; next item 
0b46 3a 5f f8				ld a, (store_tmp2+1) 
0b49 3c					inc a 
0b4a 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b4d			 
0b4d			 		; next row 
0b4d			 
0b4d 3a 5c f8				ld a, (store_tmp3) 
0b50 c6 28				add display_cols 
0b52 32 5c f8				ld (store_tmp3), a 
0b55			 
0b55					; at end of screen? 
0b55			 
0b55 fe 10				cp display_rows*4 
0b57 20 d1				jr nz, .mitem 
0b59			 
0b59			 
0b59			.mdone: 
0b59 cd 32 0d				call ishlzero 
0b5c 28 08				jr z, .nodn 
0b5e			 
0b5e 3e 78				ld a, display_row_4 
0b60 11 df 0b				ld de, .mdown 
0b63 cd e8 0a				call str_at_display 
0b66			 
0b66					; draw options to fill the screens with active item on line 1 
0b66					; if current option is 2 or more then display ^ in top 
0b66			 
0b66 3a 5e f8		.nodn:		ld a, (store_tmp2) 
0b69 fe 00				cp 0 
0b6b 28 08				jr z, .noup 
0b6d			 
0b6d 3e 00				ld a, 0 
0b6f 11 dd 0b				ld de, .mup 
0b72 cd e8 0a				call str_at_display 
0b75			 
0b75 3e 02		.noup:		ld a, 2 
0b77 11 db 0b				ld de, .msel 
0b7a cd e8 0a				call str_at_display 
0b7d			 
0b7d					; if current option + 1 is not null then display V in bottom 
0b7d					; get key 
0b7d cd f8 0a				call update_display 
0b80			 
0b80			 
0b80					; handle key 
0b80			 
0b80 cd 9e 68				call cin_wait 
0b83			 
0b83 fe 05				cp KEY_UP 
0b85 28 2b				jr z, .mgoup 
0b87 fe 61				cp 'a' 
0b89 28 27				jr z, .mgoup 
0b8b fe 0a				cp KEY_DOWN 
0b8d 28 32				jr z, .mgod 
0b8f fe 7a				cp 'z' 
0b91 28 2e				jr z, .mgod 
0b93 fe 20				cp ' ' 
0b95 28 34				jr z, .goend 
0b97 fe 0c				cp KEY_RIGHT 
0b99 28 30				jr z, .goend 
0b9b fe 0d				cp KEY_CR 
0b9d 28 2c				jr z, .goend 
0b9f fe 71				cp 'q' 
0ba1 28 0b				jr z, .goback 
0ba3			 
0ba3 fe 0b				cp KEY_LEFT 
0ba5 28 07				jr z, .goback 
0ba7 fe 08				cp KEY_BS 
0ba9 28 03				jr z, .goback 
0bab c3 19 0b				jp .mloop 
0bae			 
0bae			.goback: 
0bae 3e 00			ld a, 0 
0bb0 18 1d			jr .goend2 
0bb2			 
0bb2				; move up one 
0bb2			.mgoup: 
0bb2 3a 5e f8				ld a, (store_tmp2) 
0bb5 fe 00				cp 0 
0bb7 ca 19 0b				jp z, .mloop 
0bba 3d					dec a 
0bbb 32 5e f8				ld (store_tmp2), a 
0bbe c3 19 0b				jp .mloop 
0bc1			 
0bc1				; move down one 
0bc1			.mgod: 
0bc1 3a 5e f8				ld a, (store_tmp2) 
0bc4 3c					inc a 
0bc5 32 5e f8				ld (store_tmp2), a 
0bc8 c3 19 0b				jp .mloop 
0bcb			 
0bcb			 
0bcb			.goend: 
0bcb					; get selected item number 
0bcb			 
0bcb 3a 5e f8				ld a, (store_tmp2) 
0bce 3c					inc a 
0bcf			 
0bcf			.goend2: 
0bcf f5					push af 
0bd0			 
0bd0					; restore active fb 
0bd0					; TODO BUG assumes fb1 
0bd0			 
0bd0 21 1c fa				ld hl, display_fb1 
0bd3 22 d8 f8				ld (display_fb_active), hl 
0bd6			 
0bd6					; restore main regs 
0bd6			 
0bd6			 
0bd6 cd f8 0a				call update_display 
0bd9			 
0bd9 f1					pop af 
0bda			 
0bda c9				ret 
0bdb			 
0bdb .. 00		.msel:   db ">",0 
0bdd .. 00		.mup:   db "^",0 
0bdf .. 00		.mdown:   db "v",0 
0be1			 
0be1			 
0be1			; eof 
0be1			 
# End of file firmware_display.asm
0be1			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0be1			; random number generators 
0be1			 
0be1			 
0be1			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0be1			 
0be1			 
0be1			;-----> Generate a random number 
0be1			; output a=answer 0<=a<=255 
0be1			; all registers are preserved except: af 
0be1			random: 
0be1 e5			        push    hl 
0be2 d5			        push    de 
0be3 2a ba f8		        ld      hl,(randData) 
0be6 ed 5f		        ld      a,r 
0be8 57			        ld      d,a 
0be9 5e			        ld      e,(hl) 
0bea 19			        add     hl,de 
0beb 85			        add     a,l 
0bec ac			        xor     h 
0bed 22 ba f8		        ld      (randData),hl 
0bf0 d1			        pop     de 
0bf1 e1			        pop     hl 
0bf2 c9			        ret 
0bf3			 
0bf3			 
0bf3			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bf3			 
0bf3			 
0bf3			 
0bf3			;------LFSR------ 
0bf3			;James Montelongo 
0bf3			;optimized by Spencer Putt 
0bf3			;out: 
0bf3			; a = 8 bit random number 
0bf3			RandLFSR: 
0bf3 21 c0 f8		        ld hl,LFSRSeed+4 
0bf6 5e			        ld e,(hl) 
0bf7 23			        inc hl 
0bf8 56			        ld d,(hl) 
0bf9 23			        inc hl 
0bfa 4e			        ld c,(hl) 
0bfb 23			        inc hl 
0bfc 7e			        ld a,(hl) 
0bfd 47			        ld b,a 
0bfe cb 13		        rl e  
0c00 cb 12			rl d 
0c02 cb 11		        rl c  
0c04 17				rla 
0c05 cb 13		        rl e  
0c07 cb 12			rl d 
0c09 cb 11		        rl c  
0c0b 17				rla 
0c0c cb 13		        rl e  
0c0e cb 12			rl d 
0c10 cb 11		        rl c  
0c12 17				rla 
0c13 67			        ld h,a 
0c14 cb 13		        rl e  
0c16 cb 12			rl d 
0c18 cb 11		        rl c  
0c1a 17				rla 
0c1b a8			        xor b 
0c1c cb 13		        rl e  
0c1e cb 12			rl d 
0c20 ac			        xor h 
0c21 a9			        xor c 
0c22 aa			        xor d 
0c23 21 c2 f8		        ld hl,LFSRSeed+6 
0c26 11 c3 f8		        ld de,LFSRSeed+7 
0c29 01 07 00		        ld bc,7 
0c2c ed b8		        lddr 
0c2e 12			        ld (de),a 
0c2f c9			        ret 
0c30			 
0c30			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c30			 
0c30			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c30			 
0c30			 
0c30			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c30			 
0c30			prng16: 
0c30			;Inputs: 
0c30			;   (seed1) contains a 16-bit seed value 
0c30			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c30			;Outputs: 
0c30			;   HL is the result 
0c30			;   BC is the result of the LCG, so not that great of quality 
0c30			;   DE is preserved 
0c30			;Destroys: 
0c30			;   AF 
0c30			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c30			;160cc 
0c30			;26 bytes 
0c30 2a b4 f8		    ld hl,(seed1) 
0c33 44			    ld b,h 
0c34 4d			    ld c,l 
0c35 29			    add hl,hl 
0c36 29			    add hl,hl 
0c37 2c			    inc l 
0c38 09			    add hl,bc 
0c39 22 b4 f8		    ld (seed1),hl 
0c3c 2a b2 f8		    ld hl,(seed2) 
0c3f 29			    add hl,hl 
0c40 9f			    sbc a,a 
0c41 e6 2d		    and %00101101 
0c43 ad			    xor l 
0c44 6f			    ld l,a 
0c45 22 b2 f8		    ld (seed2),hl 
0c48 09			    add hl,bc 
0c49 c9			    ret 
0c4a			 
0c4a			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c4a			 
0c4a			rand32: 
0c4a			;Inputs: 
0c4a			;   (seed1_0) holds the lower 16 bits of the first seed 
0c4a			;   (seed1_1) holds the upper 16 bits of the first seed 
0c4a			;   (seed2_0) holds the lower 16 bits of the second seed 
0c4a			;   (seed2_1) holds the upper 16 bits of the second seed 
0c4a			;   **NOTE: seed2 must be non-zero 
0c4a			;Outputs: 
0c4a			;   HL is the result 
0c4a			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c4a			;Destroys: 
0c4a			;   AF 
0c4a			;Tested and passes all CAcert tests 
0c4a			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c4a			;it has a period of 18,446,744,069,414,584,320 
0c4a			;roughly 18.4 quintillion. 
0c4a			;LFSR taps: 0,2,6,7  = 11000101 
0c4a			;291cc 
0c4a			;seed1_0=$+1 
0c4a			;    ld hl,12345 
0c4a			;seed1_1=$+1 
0c4a			;    ld de,6789 
0c4a			;    ld b,h 
0c4a			;    ld c,l 
0c4a			;    add hl,hl \ rl e \ rl d 
0c4a			;    add hl,hl \ rl e \ rl d 
0c4a			;    inc l 
0c4a			;    add hl,bc 
0c4a			;    ld (seed1_0),hl 
0c4a			;    ld hl,(seed1_1) 
0c4a			;    adc hl,de 
0c4a			;    ld (seed1_1),hl 
0c4a			;    ex de,hl 
0c4a			;seed2_0=$+1 
0c4a			;    ld hl,9876 
0c4a			;seed2_1=$+1 
0c4a			;    ld bc,54321 
0c4a			;    add hl,hl \ rl c \ rl b 
0c4a			;    ld (seed2_1),bc 
0c4a			;    sbc a,a 
0c4a			;    and %11000101 
0c4a			;    xor l 
0c4a			;    ld l,a 
0c4a			;    ld (seed2_0),hl 
0c4a			;    ex de,hl 
0c4a			;    add hl,bc 
0c4a			;    ret 
0c4a			; 
0c4a			 
0c4a			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c4a			; 20 bytes, 86 cycles (excluding ret) 
0c4a			 
0c4a			; returns   hl = pseudorandom number 
0c4a			; corrupts   a 
0c4a			 
0c4a			; generates 16-bit pseudorandom numbers with a period of 65535 
0c4a			; using the xorshift method: 
0c4a			 
0c4a			; hl ^= hl << 7 
0c4a			; hl ^= hl >> 9 
0c4a			; hl ^= hl << 8 
0c4a			 
0c4a			; some alternative shift triplets which also perform well are: 
0c4a			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c4a			 
0c4a			;  org 32768 
0c4a			 
0c4a			xrnd: 
0c4a 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0c4d 3e 00		  ld a,0 
0c4f bd			  cp l 
0c50 20 02		  jr nz, .xrnd1 
0c52 2e 01		  ld l, 1 
0c54			.xrnd1: 
0c54			 
0c54 7c			  ld a,h 
0c55 1f			  rra 
0c56 7d			  ld a,l 
0c57 1f			  rra 
0c58 ac			  xor h 
0c59 67			  ld h,a 
0c5a 7d			  ld a,l 
0c5b 1f			  rra 
0c5c 7c			  ld a,h 
0c5d 1f			  rra 
0c5e ad			  xor l 
0c5f 6f			  ld l,a 
0c60 ac			  xor h 
0c61 67			  ld h,a 
0c62			 
0c62 22 b8 f8		  ld (xrandc),hl 
0c65			 
0c65 c9			  ret 
0c66			;  
0c66			 
0c66			 
0c66			;;;; int maths 
0c66			 
0c66			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c66			; Divide 16-bit values (with 16-bit result) 
0c66			; In: Divide BC by divider DE 
0c66			; Out: BC = result, HL = rest 
0c66			; 
0c66			Div16: 
0c66 21 00 00		    ld hl,0 
0c69 78			    ld a,b 
0c6a 06 08		    ld b,8 
0c6c			Div16_Loop1: 
0c6c 17			    rla 
0c6d ed 6a		    adc hl,hl 
0c6f ed 52		    sbc hl,de 
0c71 30 01		    jr nc,Div16_NoAdd1 
0c73 19			    add hl,de 
0c74			Div16_NoAdd1: 
0c74 10 f6		    djnz Div16_Loop1 
0c76 17			    rla 
0c77 2f			    cpl 
0c78 47			    ld b,a 
0c79 79			    ld a,c 
0c7a 48			    ld c,b 
0c7b 06 08		    ld b,8 
0c7d			Div16_Loop2: 
0c7d 17			    rla 
0c7e ed 6a		    adc hl,hl 
0c80 ed 52		    sbc hl,de 
0c82 30 01		    jr nc,Div16_NoAdd2 
0c84 19			    add hl,de 
0c85			Div16_NoAdd2: 
0c85 10 f6		    djnz Div16_Loop2 
0c87 17			    rla 
0c88 2f			    cpl 
0c89 41			    ld b,c 
0c8a 4f			    ld c,a 
0c8b c9			ret 
0c8c			 
0c8c			 
0c8c			;http://z80-heaven.wikidot.com/math 
0c8c			; 
0c8c			;Inputs: 
0c8c			;     DE and A are factors 
0c8c			;Outputs: 
0c8c			;     A is not changed 
0c8c			;     B is 0 
0c8c			;     C is not changed 
0c8c			;     DE is not changed 
0c8c			;     HL is the product 
0c8c			;Time: 
0c8c			;     342+6x 
0c8c			; 
0c8c			Mult16: 
0c8c			 
0c8c 06 08		     ld b,8          ;7           7 
0c8e 21 00 00		     ld hl,0         ;10         10 
0c91 29			       add hl,hl     ;11*8       88 
0c92 07			       rlca          ;4*8        32 
0c93 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c95 19			         add hl,de   ;--         -- 
0c96 10 f9		       djnz $-5      ;13*7+8     99 
0c98 c9			ret 
0c99			 
0c99			; 
0c99			; Square root of 16-bit value 
0c99			; In:  HL = value 
0c99			; Out:  D = result (rounded down) 
0c99			; 
0c99			;Sqr16: 
0c99			;    ld de,#0040 
0c99			;    ld a,l 
0c99			;    ld l,h 
0c99			;    ld h,d 
0c99			;    or a 
0c99			;    ld b,8 
0c99			;Sqr16_Loop: 
0c99			;    sbc hl,de 
0c99			;    jr nc,Sqr16_Skip 
0c99			;    add hl,de 
0c99			;Sqr16_Skip: 
0c99			;    ccf 
0c99			;    rl d 
0c99			;    add a,a 
0c99			;    adc hl,hl 
0c99			;    add a,a 
0c99			;    adc hl,hl 
0c99			;    djnz Sqr16_Loop 
0c99			;    ret 
0c99			; 
0c99			; 
0c99			; Divide 8-bit values 
0c99			; In: Divide E by divider C 
0c99			; Out: A = result, B = rest 
0c99			; 
0c99			Div8: 
0c99 af			    xor a 
0c9a 06 08		    ld b,8 
0c9c			Div8_Loop: 
0c9c cb 13		    rl e 
0c9e 17			    rla 
0c9f 91			    sub c 
0ca0 30 01		    jr nc,Div8_NoAdd 
0ca2 81			    add a,c 
0ca3			Div8_NoAdd: 
0ca3 10 f7		    djnz Div8_Loop 
0ca5 47			    ld b,a 
0ca6 7b			    ld a,e 
0ca7 17			    rla 
0ca8 2f			    cpl 
0ca9 c9			    ret 
0caa			 
0caa			; 
0caa			; Multiply 8-bit value with a 16-bit value (unrolled) 
0caa			; In: Multiply A with DE 
0caa			; Out: HL = result 
0caa			; 
0caa			Mult12U: 
0caa 2e 00		    ld l,0 
0cac 87			    add a,a 
0cad 30 01		    jr nc,Mult12U_NoAdd0 
0caf 19			    add hl,de 
0cb0			Mult12U_NoAdd0: 
0cb0 29			    add hl,hl 
0cb1 87			    add a,a 
0cb2 30 01		    jr nc,Mult12U_NoAdd1 
0cb4 19			    add hl,de 
0cb5			Mult12U_NoAdd1: 
0cb5 29			    add hl,hl 
0cb6 87			    add a,a 
0cb7 30 01		    jr nc,Mult12U_NoAdd2 
0cb9 19			    add hl,de 
0cba			Mult12U_NoAdd2: 
0cba 29			    add hl,hl 
0cbb 87			    add a,a 
0cbc 30 01		    jr nc,Mult12U_NoAdd3 
0cbe 19			    add hl,de 
0cbf			Mult12U_NoAdd3: 
0cbf 29			    add hl,hl 
0cc0 87			    add a,a 
0cc1 30 01		    jr nc,Mult12U_NoAdd4 
0cc3 19			    add hl,de 
0cc4			Mult12U_NoAdd4: 
0cc4 29			    add hl,hl 
0cc5 87			    add a,a 
0cc6 30 01		    jr nc,Mult12U_NoAdd5 
0cc8 19			    add hl,de 
0cc9			Mult12U_NoAdd5: 
0cc9 29			    add hl,hl 
0cca 87			    add a,a 
0ccb 30 01		    jr nc,Mult12U_NoAdd6 
0ccd 19			    add hl,de 
0cce			Mult12U_NoAdd6: 
0cce 29			    add hl,hl 
0ccf 87			    add a,a 
0cd0 d0			    ret nc 
0cd1 19			    add hl,de 
0cd2 c9			    ret 
0cd3			 
0cd3			; 
0cd3			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cd3			; In: Multiply A with DE 
0cd3			;      Put lowest value in A for most efficient calculation 
0cd3			; Out: HL = result 
0cd3			; 
0cd3			Mult12R: 
0cd3 21 00 00		    ld hl,0 
0cd6			Mult12R_Loop: 
0cd6 cb 3f		    srl a 
0cd8 30 01		    jr nc,Mult12R_NoAdd 
0cda 19			    add hl,de 
0cdb			Mult12R_NoAdd: 
0cdb cb 23		    sla e 
0cdd cb 12		    rl d 
0cdf b7			    or a 
0ce0 c2 d6 0c		    jp nz,Mult12R_Loop 
0ce3 c9			    ret 
0ce4			 
0ce4			; 
0ce4			; Multiply 16-bit values (with 32-bit result) 
0ce4			; In: Multiply BC with DE 
0ce4			; Out: BCHL = result 
0ce4			; 
0ce4			Mult32: 
0ce4 79			    ld a,c 
0ce5 48			    ld c,b 
0ce6 21 00 00		    ld hl,0 
0ce9 06 10		    ld b,16 
0ceb			Mult32_Loop: 
0ceb 29			    add hl,hl 
0cec 17			    rla 
0ced cb 11		    rl c 
0cef 30 07		    jr nc,Mult32_NoAdd 
0cf1 19			    add hl,de 
0cf2 ce 00		    adc a,0 
0cf4 d2 f8 0c		    jp nc,Mult32_NoAdd 
0cf7 0c			    inc c 
0cf8			Mult32_NoAdd: 
0cf8 10 f1		    djnz Mult32_Loop 
0cfa 41			    ld b,c 
0cfb 4f			    ld c,a 
0cfc c9			    ret 
0cfd			 
0cfd			 
0cfd			 
0cfd			; 
0cfd			; Multiply 8-bit values 
0cfd			; In:  Multiply H with E 
0cfd			; Out: HL = result 
0cfd			; 
0cfd			Mult8: 
0cfd 16 00		    ld d,0 
0cff 6a			    ld l,d 
0d00 06 08		    ld b,8 
0d02			Mult8_Loop: 
0d02 29			    add hl,hl 
0d03 30 01		    jr nc,Mult8_NoAdd 
0d05 19			    add hl,de 
0d06			Mult8_NoAdd: 
0d06 10 fa		    djnz Mult8_Loop 
0d08 c9			    ret 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			;;http://z80-heaven.wikidot.com/math 
0d09			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d09			; 
0d09			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d09			;     ld a,16        ;7 
0d09			;     ld hl,0        ;10 
0d09			;     jp $+5         ;10 
0d09			;.DivLoop: 
0d09			;       add hl,bc    ;-- 
0d09			;       dec a        ;64 
0d09			;       jr z,.DivLoopEnd        ;86 
0d09			; 
0d09			;       sla e        ;128 
0d09			;       rl d         ;128 
0d09			;       adc hl,hl    ;240 
0d09			;       sbc hl,bc    ;240 
0d09			;       jr nc,.DivLoop ;23|21 
0d09			;       inc e        ;-- 
0d09			;       jp .DivLoop+1 
0d09			; 
0d09			;.DivLoopEnd: 
0d09			 
0d09			;HL_Div_C: 
0d09			;Inputs: 
0d09			;     HL is the numerator 
0d09			;     C is the denominator 
0d09			;Outputs: 
0d09			;     A is the remainder 
0d09			;     B is 0 
0d09			;     C is not changed 
0d09			;     DE is not changed 
0d09			;     HL is the quotient 
0d09			; 
0d09			;       ld b,16 
0d09			;       xor a 
0d09			;         add hl,hl 
0d09			;         rla 
0d09			;         cp c 
0d09			;         jr c,$+4 
0d09			;           inc l 
0d09			;           sub c 
0d09			;         djnz $-7 
0d09			 
0d09			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d09			 
0d09			addatohl: 
0d09 85			    add   a, l    ; A = A+L 
0d0a 6f			    ld    l, a    ; L = A+L 
0d0b 8c			    adc   a, h    ; A = A+L+H+carry 
0d0c 95			    sub   l       ; A = H+carry 
0d0d 67			    ld    h, a    ; H = H+carry 
0d0e c9			ret 
0d0f			 
0d0f			addatode: 
0d0f 83			    add   a, e    ; A = A+L 
0d10 5f			    ld    e, a    ; L = A+L 
0d11 8a			    adc   a, d    ; A = A+L+H+carry 
0d12 93			    sub   e       ; A = H+carry 
0d13 57			    ld    d, a    ; H = H+carry 
0d14 c9			ret 
0d15			 
0d15			 
0d15			addatobc: 
0d15 81			    add   a, c    ; A = A+L 
0d16 4f			    ld    c, a    ; L = A+L 
0d17 88			    adc   a, b    ; A = A+L+H+carry 
0d18 91			    sub   c       ; A = H+carry 
0d19 47			    ld    b, a    ; H = H+carry 
0d1a c9			ret 
0d1b			 
0d1b			subafromhl: 
0d1b			   ; If A=0 do nothing 
0d1b			    ; Otherwise flip A's sign. Since 
0d1b			    ; the upper byte becomes -1, also 
0d1b			    ; substract 1 from H. 
0d1b ed 44		    neg 
0d1d ca 26 0d		    jp    z, Skip 
0d20 25			    dec   h 
0d21			     
0d21			    ; Now add the low byte as usual 
0d21			    ; Two's complement takes care of 
0d21			    ; ensuring the result is correct 
0d21 85			    add   a, l 
0d22 6f			    ld    l, a 
0d23 8c			    adc   a, h 
0d24 95			    sub   l 
0d25 67			    ld    h, a 
0d26			Skip: 
0d26 c9				ret 
0d27			 
0d27			 
0d27			; compare hl and de 
0d27			; returns:  
0d27			; if hl = de, z=1, s=0, c0=0 
0d27			; if hl > de, z=0, s=0, c=0 
0d27			; if hl < de, z=0, s=1, c=1 
0d27			cmp16:	 
0d27 b7				or a 
0d28 ed 52			sbc hl,de 
0d2a e0				ret po 
0d2b 7c				ld a,h 
0d2c 1f				rra 
0d2d ee 40			xor 01000000B 
0d2f 37				scf 
0d30 8f				adc a,a 
0d31 c9				ret 
0d32			 
0d32			 
0d32			; test if hl contains zero   - A is destroyed 
0d32			 
0d32			ishlzero:    
0d32 b7				or a     ; reset flags 
0d33 7c				ld a, h 
0d34 b5				or l        	 
0d35			 
0d35 c9				ret 
0d36			 
0d36			 
0d36			 
0d36			 
0d36			if FORTH_ENABLE_FLOATMATH 
0d36			;include "float/bbcmath.z80" 
0d36			include "float/lpfpcalc.asm" 
0d36			endif 
0d36			 
0d36			 
0d36			; eof 
0d36			 
# End of file firmware_maths.asm
0d36			include "firmware_strings.asm"   ; string handling  
0d36			 
0d36			 
0d36			; TODO string len 
0d36			; input text string, end on cr with zero term 
0d36			; a offset into frame buffer to start prompt 
0d36			; d is max length 
0d36			; e is display size TODO 
0d36			; c is current cursor position 
0d36			; hl is ptr to where string will be stored 
0d36			 
0d36			 
0d36			; TODO check limit of buffer for new inserts 
0d36			; TODO check insert does not push beyond buffer 
0d36			; TODO scroll in a limited display area 
0d36			; TODO scroll whole screen on page wrap 
0d36			 
0d36			 
0d36			; TODO handle KEY_PREVWORD 
0d36			; TODO handle KEY_NEXTWORD 
0d36			; TODO handle KEY_HOME 
0d36			; TODO handle KEY_END 
0d36			; TODO use LCD cursor? 
0d36			 
0d36 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d39 81					add c 
0d3a 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d3d 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0d40 79					ld a, c 
0d41 cd 09 0d				call addatohl 
0d44 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d47 7a					ld a,d 
0d48 32 72 fb			        ld (input_size), a       ; save length of input area 
0d4b 79					ld a, c 
0d4c 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0d4f 7b					ld a,e 
0d50 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d53					 
0d53					 
0d53			 
0d53			;		ld a,(input_ptr) 
0d53			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d53			 
0d53			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d53					; init cursor shape if not set by the cin routines 
0d53 21 d0 f8				ld hl, cursor_shape 
0d56 3e ff				ld a, 255 
0d58 77					ld (hl), a 
0d59 23					inc hl 
0d5a 3e 00				ld a, 0 
0d5c 77					ld (hl), a 
0d5d			 
0d5d 3e 0f				ld a, CUR_BLINK_RATE 
0d5f 32 6c fb				ld (input_cur_flash), a 
0d62 3e 01				ld a, 1 
0d64 32 6b fb				ld (input_cur_onoff),a 
0d67			 
0d67			;	if DEBUG_INPUT 
0d67			;		push af 
0d67			;		ld a, 'I' 
0d67			;		ld (debug_mark),a 
0d67			;		pop af 
0d67			;		CALLMONITOR 
0d67			;	endif 
0d67			.is1:		; main entry loop 
0d67			 
0d67			 
0d67			 
0d67					; pause 1ms 
0d67			 
0d67 3e 01				ld a, 1 
0d69 cd 3a 0a				call aDelayInMS 
0d6c			 
0d6c					; dec flash counter 
0d6c 3a 6c fb				ld a, (input_cur_flash) 
0d6f 3d					dec a 
0d70 32 6c fb				ld (input_cur_flash), a 
0d73 fe 00				cp 0 
0d75 20 0d				jr nz, .nochgstate 
0d77			 
0d77			 
0d77					; change state 
0d77 3a 6b fb				ld a,(input_cur_onoff) 
0d7a ed 44				neg 
0d7c 32 6b fb				ld (input_cur_onoff),a 
0d7f			 
0d7f			 
0d7f					; reset on change of state 
0d7f 3e 0f				ld a, CUR_BLINK_RATE 
0d81 32 6c fb				ld (input_cur_flash), a 
0d84			 
0d84			.nochgstate: 
0d84					 
0d84					 
0d84			 
0d84					; display cursor  
0d84			 
0d84			;		ld hl, (input_start) 
0d84			;		ld a, (input_cursor) 
0d84			;		call addatohl 
0d84			 
0d84					; get char under cursor and replace with cursor 
0d84 2a 75 fb		ld hl, (input_ptr) 
0d87			;		ld a, (hl) 
0d87			;		ld (input_under_cursor),a 
0d87			;		ld a, '_' 
0d87			;		ld (hl), a 
0d87			 
0d87					; display string 
0d87			 
0d87 ed 5b 73 fb			ld de, (input_start) 
0d8b 3a 70 fb				ld a, (input_at_pos) 
0d8e cd e8 0a				call str_at_display 
0d91			;	        call update_display 
0d91			 
0d91					; find place to put the cursor 
0d91			;		add h 
0d91			;		ld l, display_row_1 
0d91			;		sub l 
0d91			; (input_at_pos) 
0d91					;ld c, a 
0d91			;		ld a, (input_cursor) 
0d91			;		ld l, (input_at_pos) 
0d91			;		;ld b, h 
0d91			;		add l 
0d91			;		ld (input_at_cursor),a 
0d91					;ld l,h 
0d91			 
0d91			;		ld h, 0 
0d91			;		ld l,(input_at_pos) 
0d91			;		ld a, (input_cursor) 
0d91			;		call addatohl 
0d91			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d91			;		call subafromhl 
0d91			;		ld a,l 
0d91			;		ld (input_at_cursor), a 
0d91			 
0d91				if DEBUG_INPUT 
0d91					ld a, (hardware_diag) 
0d91					cp 0 
0d91					jr z, .skip_input_diag 
0d91			 
0d91					ld a,(input_at_pos) 
0d91					ld hl, LFSRSeed 
0d91					call hexout 
0d91					ld a, (input_cursor) 
0d91					ld hl, LFSRSeed+2 
0d91					call hexout 
0d91					ld a,(input_at_cursor) 
0d91					ld hl, LFSRSeed+4 
0d91					call hexout 
0d91			 
0d91					ld a,(input_cur_onoff) 
0d91					ld hl, LFSRSeed+6 
0d91					call hexout 
0d91			 
0d91					ld a,(input_cur_flash) 
0d91					ld hl, LFSRSeed+8 
0d91					call hexout 
0d91			 
0d91					ld a,(input_len) 
0d91					ld hl, LFSRSeed+10 
0d91					call hexout 
0d91					ld hl, LFSRSeed+12 
0d91					ld a, 0 
0d91					ld (hl),a 
0d91					ld a, display_row_4 
0d91					ld de, LFSRSeed 
0d91					call str_at_display 
0d91					.skip_input_diag: 
0d91				endif 
0d91			 
0d91					; decide on if we are showing the cursor this time round 
0d91			 
0d91 3a 6b fb				ld a, (input_cur_onoff) 
0d94 fe ff				cp 255 
0d96 28 13				jr z, .skipcur 
0d98			 
0d98			 
0d98 3a 6e fb				ld a,(input_at_cursor) 
0d9b 11 d0 f8				ld de, cursor_shape 
0d9e cd e8 0a				call str_at_display 
0da1			 
0da1					; save length of current input string 
0da1 2a 73 fb				ld hl, (input_start) 
0da4 cd 67 11				call strlenz 
0da7 7d					ld a,l 
0da8 32 66 fb				ld (input_len),a 
0dab			 
0dab			.skipcur: 
0dab			 
0dab cd f8 0a			        call update_display 
0dae					 
0dae			 
0dae			 
0dae					; wait 
0dae				 
0dae					; TODO loop without wait to flash the cursor and char under cursor	 
0dae cd af 68				call cin    ; _wait 
0db1			 
0db1 fe 00				cp 0 
0db3 ca 67 0d				jp z, .is1 
0db6			 
0db6					; get ptr to char to input into 
0db6			 
0db6 4f					ld c,a 
0db7 2a 73 fb				ld hl, (input_start) 
0dba 3a 61 fb				ld a, (input_cursor) 
0dbd cd 09 0d				call addatohl 
0dc0 22 75 fb				ld (input_ptr), hl 
0dc3 79					ld a,c 
0dc4			 
0dc4					; replace char under cursor 
0dc4			 
0dc4			;		ld hl, (input_ptr) 
0dc4			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dc4			;		ld (hl), a 
0dc4			 
0dc4			;	if DEBUG_INPUT 
0dc4			;		push af 
0dc4			;		ld a, 'i' 
0dc4			;		ld (debug_mark),a 
0dc4			;		pop af 
0dc4			;		CALLMONITOR 
0dc4			;	endif 
0dc4 fe 0e				cp KEY_HOME 
0dc6 20 0e				jr nz, .iske 
0dc8			 
0dc8 3a 70 fb				ld a, (input_at_pos) 
0dcb 32 6e fb				ld (input_at_cursor),a 
0dce 3e 00				ld a, 0 
0dd0 32 61 fb				ld (input_cursor), a 
0dd3 c3 67 0d				jp .is1 
0dd6					 
0dd6 fe 0f		.iske:		cp KEY_END 
0dd8 20 03				jr nz, .isknw 
0dda c3 67 0d				jp .is1 
0ddd			 
0ddd fe 06		.isknw:		cp KEY_NEXTWORD 
0ddf 20 1b				jr nz, .iskpw 
0de1			 
0de1 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0de4 7e					ld a,(hl)	 
0de5 fe 00				cp 0 
0de7 ca 67 0d				jp z, .is1    ; end of string 
0dea fe 20				cp ' ' 
0dec ca 67 0d				jp z, .is1    ; end of word 
0def 23					inc hl 
0df0 22 75 fb				ld (input_ptr), hl 
0df3 3a 6e fb				ld a, (input_at_cursor) 
0df6 3c					inc a 
0df7 32 6e fb				ld (input_at_cursor), a 
0dfa 18 e5				jr .isknwm 
0dfc			 
0dfc fe 07		.iskpw:		cp KEY_PREVWORD 
0dfe 20 1b				jr nz, .iskl 
0e00			.iskpwm:	 
0e00 2a 75 fb				ld hl, (input_ptr) 
0e03 7e					ld a,(hl)	 
0e04 fe 00				cp 0  
0e06 ca 67 0d				jp z, .is1    ; end of string 
0e09 fe 20				cp ' ' 
0e0b ca 67 0d				jp z, .is1    ; end of word 
0e0e 2b					dec hl 
0e0f 22 75 fb				ld (input_ptr), hl 
0e12 3a 6e fb				ld a, (input_at_cursor) 
0e15 3d					dec a 
0e16 32 6e fb				ld (input_at_cursor), a 
0e19 18 e5				jr .iskpwm 
0e1b			 
0e1b			 
0e1b fe 0b		.iskl:		cp KEY_LEFT 
0e1d 20 27				jr nz, .isk1 
0e1f			 
0e1f 3a 61 fb				ld a, (input_cursor) 
0e22			 
0e22 fe 00				cp 0 
0e24 ca 67 0d				jp z, .is1 		; at start of line to ignore  
0e27			 
0e27 3d					dec  a 		; TODO check underflow 
0e28 32 61 fb				ld (input_cursor), a 
0e2b			 
0e2b 2a 75 fb				ld hl, (input_ptr) 
0e2e 2b					dec hl 
0e2f 22 75 fb				ld (input_ptr), hl 
0e32					 
0e32 3a 6e fb				ld a, (input_at_cursor) 
0e35 3d					dec a 
0e36 32 6e fb				ld (input_at_cursor), a 
0e39			 
0e39 3e 01				ld a, 1		; show cursor moving 
0e3b 32 6b fb				ld (input_cur_onoff),a 
0e3e 3e 0f				ld a, CUR_BLINK_RATE 
0e40 32 6c fb				ld (input_cur_flash), a 
0e43			 
0e43 c3 67 0d				jp .is1 
0e46			 
0e46 fe 0c		.isk1:		cp KEY_RIGHT 
0e48 20 2a				jr nz, .isk2 
0e4a			 
0e4a 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e4d 5f					ld e,a 
0e4e 3a 61 fb				ld a, (input_cursor) 
0e51 bb					cp e 
0e52 ca 67 0d				jp z, .is1		; at the end of string so dont go right 
0e55			 
0e55 3c					inc  a 		; TODO check overflow 
0e56 32 61 fb				ld (input_cursor), a 
0e59			 
0e59 3a 6e fb				ld a, (input_at_cursor) 
0e5c 3c					inc a 
0e5d 32 6e fb				ld (input_at_cursor), a 
0e60			 
0e60 2a 75 fb				ld hl, (input_ptr) 
0e63 23					inc hl 
0e64 22 75 fb				ld (input_ptr), hl 
0e67			 
0e67 3e 01				ld a, 1		; show cursor moving 
0e69 32 6b fb				ld (input_cur_onoff),a 
0e6c 3e 0f				ld a, CUR_BLINK_RATE 
0e6e 32 6c fb				ld (input_cur_flash), a 
0e71			 
0e71 c3 67 0d				jp .is1 
0e74			 
0e74 fe 05		.isk2:		cp KEY_UP 
0e76			 
0e76 20 26				jr nz, .isk3 
0e78			 
0e78					; swap last command with the current on 
0e78			 
0e78					; move cursor to start of string 
0e78 2a 73 fb				ld hl, (input_start) 
0e7b 22 75 fb				ld (input_ptr), hl 
0e7e			 
0e7e 3a 70 fb				ld a, (input_at_pos) 
0e81 32 6e fb				ld (input_at_cursor), a 
0e84			 
0e84 3e 00				ld a, 0 
0e86 32 61 fb				ld (input_cursor), a 
0e89					 
0e89					; swap input and last command buffers 
0e89			 
0e89 21 44 f1				ld hl, os_cli_cmd 
0e8c 11 43 f2				ld de, os_last_cmd 
0e8f 06 ff				ld b, 255 
0e91 7e			.swap1:		ld a, (hl) 
0e92 4f					ld c,a 
0e93 1a					ld a, (de) 
0e94 77					ld (hl), a 
0e95 79					ld a,c 
0e96 12					ld (de),a 
0e97 23					inc hl 
0e98 13					inc de 
0e99 10 f6				djnz .swap1 
0e9b			 
0e9b			 
0e9b			 
0e9b			 
0e9b			 
0e9b c3 67 0d				jp .is1 
0e9e			 
0e9e fe 08		.isk3:		cp KEY_BS 
0ea0 20 3c				jr nz, .isk4 
0ea2			 
0ea2 3a 61 fb				ld a, (input_cursor) 
0ea5			 
0ea5 fe 00				cp 0 
0ea7 ca 67 0d				jp z, .is1 		; at start of line to ignore  
0eaa			 
0eaa 3d					dec  a 		; TODO check underflow 
0eab 32 61 fb				ld (input_cursor), a 
0eae			 
0eae					; hl is source 
0eae					; de needs to be source - 1 
0eae			 
0eae			;		ld a, 0 
0eae			;		dec hl 
0eae			;		ld (hl), a 
0eae			 
0eae 2a 75 fb				ld hl, (input_ptr) 
0eb1 2b					dec hl 
0eb2 22 75 fb				ld (input_ptr), hl 
0eb5			 
0eb5					; shift all data 
0eb5			 
0eb5 e5					push hl 
0eb6 23					inc hl 
0eb7 d1					pop de 
0eb8 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ebb 4f					ld c,a 
0ebc 06 00				ld b,0 
0ebe ed b0				ldir  
0ec0			 
0ec0			 
0ec0			 
0ec0			 
0ec0 3a 6e fb				ld a, (input_at_cursor) 
0ec3 3d					dec a 
0ec4 32 6e fb				ld (input_at_cursor), a 
0ec7			 
0ec7			 
0ec7 3e 01				ld a, 1		; show cursor moving 
0ec9 32 6b fb				ld (input_cur_onoff),a 
0ecc 3e 0f				ld a, CUR_BLINK_RATE 
0ece 32 6c fb				ld (input_cur_flash), a 
0ed1			 
0ed1					; remove char 
0ed1 3a 6e fb				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 11 5f 0f				ld de,.iblank 
0ed8 cd e8 0a				call str_at_display 
0edb			 
0edb c3 67 0d				jp .is1 
0ede			 
0ede fe 0d		.isk4:		cp KEY_CR 
0ee0 28 6c				jr z, .endinput 
0ee2			 
0ee2					; else add the key press to the end 
0ee2			 
0ee2 4f					ld c, a			; save key pressed 
0ee3			 
0ee3 7e					ld a,(hl)		; get what is currently under char 
0ee4			 
0ee4 fe 00				cp 0			; we are at the end of the string 
0ee6 20 2f				jr nz, .onchar 
0ee8					 
0ee8					; add a char to the end of the string 
0ee8				 
0ee8 71					ld (hl),c 
0ee9 23					inc hl 
0eea			;		ld a,' ' 
0eea			;		ld (hl),a 
0eea			;		inc hl 
0eea 3e 00				ld a,0 
0eec 77					ld (hl),a 
0eed 2b					dec hl 
0eee			 
0eee 3a 61 fb				ld a, (input_cursor) 
0ef1 3c					inc a				; TODO check max string length and scroll  
0ef2 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0ef5							 
0ef5 3a 6e fb				ld a, (input_at_cursor) 
0ef8 3c					inc a 
0ef9 32 6e fb				ld (input_at_cursor), a 
0efc			 
0efc 2a 75 fb				ld hl, (input_ptr) 
0eff 23					inc hl 
0f00 22 75 fb				ld (input_ptr), hl 
0f03			 
0f03 2a 75 fb				ld hl, (input_ptr) 
0f06 23					inc hl 
0f07 22 75 fb				ld (input_ptr), hl 
0f0a			;	if DEBUG_INPUT 
0f0a			;		push af 
0f0a			;		ld a, '+' 
0f0a			;		ld (debug_mark),a 
0f0a			;		pop af 
0f0a			;		CALLMONITOR 
0f0a			;	endif 
0f0a 3e 01				ld a, 1		; show cursor moving 
0f0c 32 6b fb				ld (input_cur_onoff),a 
0f0f 3e 0f				ld a, CUR_BLINK_RATE 
0f11 32 6c fb				ld (input_cur_flash), a 
0f14 c3 67 0d				jp .is1 
0f17					 
0f17			 
0f17			 
0f17					; if on a char then insert 
0f17			.onchar: 
0f17			 
0f17					; TODO over flow check: make sure insert does not blow out buffer 
0f17			 
0f17					; need to do some maths to use lddr 
0f17			 
0f17 e5					push hl   ; save char pos 
0f18 c5					push bc 
0f19			 
0f19 2a 73 fb				ld hl, (input_start) 
0f1c 3a 66 fb				ld a, (input_len) 
0f1f cd 09 0d				call addatohl  		; end of string 
0f22 23					inc hl 
0f23 23					inc hl		; past zero term 
0f24 e5					push hl 
0f25 23					inc hl 
0f26 e5					push hl  
0f27			 
0f27								; start and end of lddr set, now how much to move? 
0f27			 
0f27							 
0f27 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f2a 47					ld b,a 
0f2b 3a 66 fb				ld a,(input_len) 
0f2e 5f					ld e,a 
0f2f 90					sub b 
0f30 3c					inc a		;?? 
0f31 3c					inc a		;?? 
0f32 3c					inc a		;?? 
0f33			 
0f33 06 00				ld b,0 
0f35 4f					ld c,a 
0f36			 
0f36				if DEBUG_INPUT 
0f36					push af 
0f36					ld a, 'i' 
0f36					ld (debug_mark),a 
0f36					pop af 
0f36			;		CALLMONITOR 
0f36				endif 
0f36 d1					pop de 
0f37 e1					pop hl 
0f38				if DEBUG_INPUT 
0f38					push af 
0f38					ld a, 'I' 
0f38					ld (debug_mark),a 
0f38					pop af 
0f38			;		CALLMONITOR 
0f38				endif 
0f38 ed b8				lddr 
0f3a				 
0f3a			 
0f3a			 
0f3a					; TODO have a key for insert/overwrite mode???? 
0f3a c1					pop bc 
0f3b e1					pop hl 
0f3c 71					ld (hl), c		; otherwise overwrite current char 
0f3d					 
0f3d			 
0f3d			 
0f3d			 
0f3d 3a 61 fb				ld a, (input_cursor) 
0f40 3c					inc  a 		; TODO check overflow 
0f41 32 61 fb				ld (input_cursor), a 
0f44			 
0f44 3a 6e fb				ld a, (input_at_cursor) 
0f47 3c					inc a 
0f48 32 6e fb				ld (input_at_cursor), a 
0f4b			 
0f4b c3 67 0d				jp .is1 
0f4e			 
0f4e			.endinput:	; TODO look for end of string 
0f4e			 
0f4e					; add trailing space for end of token 
0f4e			 
0f4e 2a 73 fb				ld hl, (input_start) 
0f51 3a 66 fb				ld a,(input_len) 
0f54 cd 09 0d				call addatohl 
0f57 3e 20				ld a, ' ' 
0f59 77					ld (hl),a 
0f5a					; TODO eof of parse marker 
0f5a			 
0f5a 23					inc hl 
0f5b 3e 00				ld a, 0 
0f5d 77					ld (hl),a 
0f5e			 
0f5e			 
0f5e c9					ret 
0f5f			 
0f5f .. 00		.iblank: db " ",0 
0f61			 
0f61			 
0f61 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0f64 22 73 fb				ld (input_start), hl 
0f67 3e 01				ld a,1			; add cursor 
0f69 77					ld (hl),a 
0f6a 23					inc hl 
0f6b 3e 00				ld a,0 
0f6d 77					ld (hl),a 
0f6e 22 75 fb				ld (input_ptr), hl 
0f71 7a					ld a,d 
0f72 32 72 fb				ld (input_size), a 
0f75 3e 00				ld a,0 
0f77 32 61 fb				ld (input_cursor),a 
0f7a			.instr1:	 
0f7a			 
0f7a					; TODO do block cursor 
0f7a					; TODO switch cursor depending on the modifer key 
0f7a			 
0f7a					; update cursor shape change on key hold 
0f7a			 
0f7a 2a 75 fb				ld hl, (input_ptr) 
0f7d 2b					dec hl 
0f7e 3a d0 f8				ld a,(cursor_shape) 
0f81 77					ld (hl), a 
0f82			 
0f82					; display entered text 
0f82 3a 70 fb				ld a,(input_at_pos) 
0f85 cd 73 66		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f88 ed 5b 73 fb	            	LD   de, (input_start) 
0f8c cd 95 66		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f8f			 
0f8f cd af 68				call cin 
0f92 fe 00				cp 0 
0f94 28 e4				jr z, .instr1 
0f96			 
0f96					; proecess keyboard controls first 
0f96			 
0f96 2a 75 fb				ld hl,(input_ptr) 
0f99			 
0f99 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f9b 28 5a				jr z, .instrcr 
0f9d			 
0f9d fe 08				cp KEY_BS 	; back space 
0f9f 20 0f				jr nz, .instr2 
0fa1					; process back space 
0fa1			 
0fa1					; TODO stop back space if at start of string 
0fa1 2b					dec hl 
0fa2 2b					dec hl ; to over write cursor 
0fa3 3a d0 f8				ld a,(cursor_shape) 
0fa6					;ld a,0 
0fa6 77					ld (hl),a 
0fa7 23					inc hl 
0fa8 3e 20				ld a," " 
0faa 77					ld (hl),a 
0fab 22 75 fb				ld (input_ptr),hl 
0fae					 
0fae			 
0fae 18 ca				jr .instr1 
0fb0			 
0fb0 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fb2 20 06				jr nz, .instr3 
0fb4 2b					dec hl 
0fb5 22 75 fb				ld (input_ptr),hl 
0fb8 18 c0				jr .instr1 
0fba				 
0fba fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fbc 20 06				jr nz, .instr4 
0fbe 23					inc hl 
0fbf 22 75 fb				ld (input_ptr),hl 
0fc2 18 b6				jr .instr1 
0fc4			 
0fc4 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc6 20 06				jr nz, .instr5 
0fc8 2b					dec hl 
0fc9 22 75 fb				ld (input_ptr),hl 
0fcc 18 ac				jr .instr1 
0fce			 
0fce fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fd0 20 06				jr nz, .instr6 
0fd2 2b					dec hl 
0fd3 22 75 fb				ld (input_ptr),hl 
0fd6 18 a2				jr .instr1 
0fd8 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fda 20 0b				jr nz, .instrnew 
0fdc			 
0fdc 21 1d ee			ld hl, scratch 
0fdf 11 43 f2			ld de, os_last_cmd 
0fe2 cd 00 10			call strcpy 
0fe5 18 93				jr .instr1 
0fe7			 
0fe7			 
0fe7			.instrnew:	; no special key pressed to see if we have room to store it 
0fe7			 
0fe7					; TODO do string size test 
0fe7			 
0fe7 2b					dec hl ; to over write cursor 
0fe8 77					ld (hl),a 
0fe9 23					inc hl 
0fea 3a d0 f8				ld a,(cursor_shape) 
0fed 77					ld (hl),a 
0fee 23					inc hl 
0fef 3e 00				ld a,0 
0ff1 77					ld (hl),a 
0ff2			 
0ff2 22 75 fb				ld (input_ptr),hl 
0ff5					 
0ff5 18 83				jr .instr1 
0ff7 2b			.instrcr:	dec hl		; remove cursor 
0ff8 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ffa 77					ld (hl),a 
0ffb 23					inc hl 
0ffc 3e 00				ld a,0 
0ffe 77					ld (hl),a 
0fff			 
0fff			 
0fff					; if at end of line scroll up    
0fff					; TODO detecting only end of line 4 for scroll up  
0fff			 
0fff					;ld   
0fff			 
0fff c9					ret 
1000			 
1000			 
1000			; strcpy hl = dest, de source 
1000			 
1000 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1001 b7			            OR   A              ;Null terminator? 
1002 c8			            RET  Z              ;Yes, so finished 
1003 1a					ld a,(de) 
1004 77					ld (hl),a 
1005 13			            INC  DE             ;Point to next character 
1006 23					inc hl 
1007 18 f7		            JR   strcpy       ;Repeat 
1009 c9					ret 
100a			 
100a			 
100a			; TODO string_at  
100a			; pass string which starts with lcd offset address and then null term string 
100a			 
100a			; TODO string to dec 
100a			; TODO string to hex 
100a			; TODO byte to string hex 
100a			; TODO byte to string dec 
100a			 
100a			 
100a			 
100a			; from z80uartmonitor 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
100a			; pass hl for where to put the text 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a c5			hexout:	PUSH BC 
100b f5					PUSH AF 
100c 47					LD B, A 
100d					; Upper nybble 
100d cb 3f				SRL A 
100f cb 3f				SRL A 
1011 cb 3f				SRL A 
1013 cb 3f				SRL A 
1015 cd 25 10				CALL tohex 
1018 77					ld (hl),a 
1019 23					inc hl	 
101a					 
101a					; Lower nybble 
101a 78					LD A, B 
101b e6 0f				AND 0FH 
101d cd 25 10				CALL tohex 
1020 77					ld (hl),a 
1021 23					inc hl	 
1022					 
1022 f1					POP AF 
1023 c1					POP BC 
1024 c9					RET 
1025					 
1025			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1025			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1025			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1025			tohex: 
1025 e5					PUSH HL 
1026 d5					PUSH DE 
1027 16 00				LD D, 0 
1029 5f					LD E, A 
102a 21 32 10				LD HL, .DATA 
102d 19					ADD HL, DE 
102e 7e					LD A, (HL) 
102f d1					POP DE 
1030 e1					POP HL 
1031 c9					RET 
1032			 
1032			.DATA: 
1032 30					DEFB	30h	; 0 
1033 31					DEFB	31h	; 1 
1034 32					DEFB	32h	; 2 
1035 33					DEFB	33h	; 3 
1036 34					DEFB	34h	; 4 
1037 35					DEFB	35h	; 5 
1038 36					DEFB	36h	; 6 
1039 37					DEFB	37h	; 7 
103a 38					DEFB	38h	; 8 
103b 39					DEFB	39h	; 9 
103c 41					DEFB	41h	; A 
103d 42					DEFB	42h	; B 
103e 43					DEFB	43h	; C 
103f 44					DEFB	44h	; D 
1040 45					DEFB	45h	; E 
1041 46					DEFB	46h	; F 
1042			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1042			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1042			;;    subtract $30, if result > 9 then subtract $7 more 
1042			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1042			atohex: 
1042 d6 30				SUB $30 
1044 fe 0a				CP 10 
1046 f8					RET M		; If result negative it was 0-9 so we're done 
1047 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1049 c9					RET		 
104a			 
104a			 
104a			 
104a			 
104a			; Get 2 ASCII characters as hex byte from pointer in hl 
104a			 
104a			BYTERD: 
104a 16 00			LD	D,00h		;Set up 
104c cd 54 10			CALL	HEXCON		;Get byte and convert to hex 
104f 87				ADD	A,A		;First nibble so 
1050 87				ADD	A,A		;multiply by 16 
1051 87				ADD	A,A		; 
1052 87				ADD	A,A		; 
1053 57				LD	D,A		;Save hi nibble in D 
1054			HEXCON: 
1054 7e				ld a, (hl)		;Get next chr 
1055 23				inc hl 
1056 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1058 fe 0a			CP	00Ah		;Is it 0-9 ? 
105a 38 02			JR	C,NALPHA	;If so miss next bit 
105c d6 07			SUB	007h		;Else convert alpha 
105e			NALPHA: 
105e b2				OR	D		;Add hi nibble back 
105f c9				RET			; 
1060			 
1060			 
1060			; 
1060			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1060			; Since the routines get_byte and therefore get_nibble are called, only valid 
1060			; characters (0-9a-f) are accepted. 
1060			; 
1060			;get_word        push    af 
1060			;                call    get_byte        ; Get the upper byte 
1060			;                ld      h, a 
1060			;                call    get_byte        ; Get the lower byte 
1060			;                ld      l, a 
1060			;                pop     af 
1060			;                ret 
1060			; 
1060			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1060			; the routine get_nibble is used only valid characters are accepted - the  
1060			; input routine only accepts characters 0-9a-f. 
1060			; 
1060 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1061 7e					ld a,(hl) 
1062 23					inc hl 
1063 cd 88 10		                call    nibble2val      ; Get upper nibble 
1066 cb 07		                rlc     a 
1068 cb 07		                rlc     a 
106a cb 07		                rlc     a 
106c cb 07		                rlc     a 
106e 47			                ld      b, a            ; Save upper four bits 
106f 7e					ld a,(hl) 
1070 cd 88 10		                call    nibble2val      ; Get lower nibble 
1073 b0			                or      b               ; Combine both nibbles 
1074 c1			                pop     bc              ; Restore B (and C) 
1075 c9			                ret 
1076			; 
1076			; Get a hexadecimal digit from the serial line. This routine blocks until 
1076			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1076			; to the serial line interface. The lower 4 bits of A contain the value of  
1076			; that particular digit. 
1076			; 
1076			;get_nibble      ld a,(hl)           ; Read a character 
1076			;                call    to_upper        ; Convert to upper case 
1076			;                call    is_hex          ; Was it a hex digit? 
1076			;                jr      nc, get_nibble  ; No, get another character 
1076			 ;               call    nibble2val      ; Convert nibble to value 
1076			 ;               call    print_nibble 
1076			 ;               ret 
1076			; 
1076			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1076			; A valid hexadecimal digit is denoted by a set C flag. 
1076			; 
1076			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1076			;                ret     nc              ; Yes 
1076			;                cp      '0'             ; Less than '0'? 
1076			;                jr      nc, is_hex_1    ; No, continue 
1076			;                ccf                     ; Complement carry (i.e. clear it) 
1076			;                ret 
1076			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1076			;                ret     c               ; Yes 
1076			;                cp      'A'             ; Less than 'A'? 
1076			;                jr      nc, is_hex_2    ; No, continue 
1076			;                ccf                     ; Yes - clear carry and return 
1076			;                ret 
1076			;is_hex_2        scf                     ; Set carry 
1076			;                ret 
1076			; 
1076			; Convert a single character contained in A to upper case: 
1076			; 
1076 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1078 d8			                ret     c 
1079 fe 7b		                cp      'z' + 1         ; > 'z'? 
107b d0			                ret     nc              ; Nothing to do, either 
107c e6 5f		                and     $5f             ; Convert to upper case 
107e c9			                ret 
107f			 
107f			 
107f			to_lower: 
107f			 
107f			   ; if char is in [A-Z] make it lower case 
107f			 
107f			   ; enter : a = char 
107f			   ; exit  : a = lower case char 
107f			   ; uses  : af 
107f			 
107f fe 41		   cp 'A' 
1081 d8			   ret c 
1082			    
1082 fe 5b		   cp 'Z'+1 
1084 d0			   ret nc 
1085			    
1085 f6 20		   or $20 
1087 c9			   ret 
1088			 
1088			; 
1088			; Expects a hexadecimal digit (upper case!) in A and returns the 
1088			; corresponding value in A. 
1088			; 
1088 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
108a 38 02		                jr      c, nibble2val_1 ; Yes 
108c d6 07		                sub     7               ; Adjust for A-F 
108e d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1090 e6 0f		                and     $f              ; Only return lower 4 bits 
1092 c9			                ret 
1093			; 
1093			; Print_nibble prints a single hex nibble which is contained in the lower  
1093			; four bits of A: 
1093			; 
1093			;print_nibble    push    af              ; We won't destroy the contents of A 
1093			;                and     $f              ; Just in case... 
1093			;                add     a, '0'             ; If we have a digit we are done here. 
1093			;                cp      '9' + 1         ; Is the result > 9? 
1093			;                jr      c, print_nibble_1 
1093			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1093			;print_nibble_1  call    putc            ; Print the nibble and 
1093			;                pop     af              ; restore the original value of A 
1093			;                ret 
1093			;; 
1093			;; Send a CR/LF pair: 
1093			; 
1093			;crlf            push    af 
1093			;                ld      a, cr 
1093			;                call    putc 
1093			;                ld      a, lf 
1093			;                call    putc 
1093			;                pop     af 
1093			;                ret 
1093			; 
1093			; Print_word prints the four hex digits of a word to the serial line. The  
1093			; word is expected to be in HL. 
1093			; 
1093			;print_word      push    hl 
1093			;                push    af 
1093			;                ld      a, h 
1093			;                call    print_byte 
1093			;                ld      a, l 
1093			;                call    print_byte 
1093			;                pop     af 
1093			;                pop     hl 
1093			;                ret 
1093			; 
1093			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1093			; The byte to be printed is expected to be in A. 
1093			; 
1093			;print_byte      push    af              ; Save the contents of the registers 
1093			;                push    bc 
1093			;                ld      b, a 
1093			;                rrca 
1093			;                rrca 
1093			;                rrca 
1093			;                rrca 
1093			;                call    print_nibble    ; Print high nibble 
1093			;                ld      a, b 
1093			;                call    print_nibble    ; Print low nibble 
1093			;                pop     bc              ; Restore original register contents 
1093			;                pop     af 
1093			;                ret 
1093			 
1093			 
1093			 
1093			 
1093			 
1093			fourehexhl:  
1093 7e				ld a,(hl) 
1094 cd 42 10			call atohex 
1097 cb 3f				SRL A 
1099 cb 3f				SRL A 
109b cb 3f				SRL A 
109d cb 3f				SRL A 
109f 47				ld b, a 
10a0 23				inc hl 
10a1 7e				ld a,(hl) 
10a2 23				inc hl 
10a3 cd 42 10			call atohex 
10a6 80				add b 
10a7 57				ld d,a 
10a8 7e				ld a,(hl) 
10a9 cd 42 10			call atohex 
10ac cb 3f				SRL A 
10ae cb 3f				SRL A 
10b0 cb 3f				SRL A 
10b2 cb 3f				SRL A 
10b4 47				ld b, a 
10b5 23				inc hl 
10b6 7e				ld a,(hl) 
10b7 23				inc hl 
10b8 cd 42 10			call atohex 
10bb 80				add b 
10bc 5f				ld e, a 
10bd d5				push de 
10be e1				pop hl 
10bf c9				ret 
10c0			 
10c0			; pass hl. returns z set if the byte at hl is a digit 
10c0			;isdigithl:  
10c0			;	push bc 
10c0			;	ld a,(hl) 
10c0			;	cp ':' 
10c0			;	jr nc, .isdf 		; > 
10c0			;	cp '0' 
10c0			;	jr c, .isdf		; < 
10c0			; 
10c0			;	; TODO find a better way to set z 
10c0			; 
10c0			;	ld b,a 
10c0			;	cp b 
10c0			;	pop bc 
10c0			;	ret 
10c0			; 
10c0			;.isdf:	; not digit so clear z 
10c0			; 
10c0			;	; TODO find a better way to unset z 
10c0			; 
10c0			;	ld b,a 
10c0			;	inc b 
10c0			;	cp b 
10c0			; 
10c0			;	pop bc 
10c0			;	ret 
10c0				 
10c0				 
10c0			 
10c0			 
10c0			; pass hl as the four byte address to load 
10c0			 
10c0			get_word_hl:  
10c0 e5				push hl 
10c1 cd 60 10			call get_byte 
10c4				 
10c4 47				ld b, a 
10c5			 
10c5 e1				pop hl 
10c6 23				inc hl 
10c7 23				inc hl 
10c8			 
10c8			; TODO not able to handle a-f  
10c8 7e				ld a,(hl) 
10c9			;	;cp ':' 
10c9			;	cp 'g' 
10c9			;	jr nc, .single_byte_hl 		; > 
10c9			;	cp 'G' 
10c9			;	jr nc, .single_byte_hl 		; > 
10c9			;	cp '0' 
10c9			;	jr c, .single_byte_hl		; < 
10c9			 
10c9				;call isdigithl 
10c9 fe 00			cp 0 
10cb 28 06			jr z, .single_byte_hl 
10cd			 
10cd			.getwhln:   ; hex word so get next byte 
10cd			 
10cd cd 60 10			call get_byte 
10d0 6f				ld l, a 
10d1 60				ld h,b 
10d2 c9				ret 
10d3 68			.single_byte_hl:   ld l,b 
10d4 26 00				ld h,0 
10d6 c9					ret 
10d7			 
10d7			 
10d7			 
10d7			 
10d7 21 3e 19			ld hl,asc+1 
10da			;	ld a, (hl) 
10da			;	call nibble2val 
10da cd 60 10			call get_byte 
10dd			 
10dd			;	call fourehexhl 
10dd 32 51 ee			ld (scratch+52),a 
10e0				 
10e0 21 4f ee			ld hl,scratch+50 
10e3 22 40 f1			ld (os_cur_ptr),hl 
10e6			 
10e6 c9				ret 
10e7			 
10e7			 
10e7			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10e7			 
10e7			; Decimal Unsigned Version 
10e7			 
10e7			;Number in a to decimal ASCII 
10e7			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10e7			;Example: display a=56 as "056" 
10e7			;input: a = number 
10e7			;Output: a=0,value of a in the screen 
10e7			;destroys af,bc (don't know about hl and de) 
10e7			DispAToASCII: 
10e7 0e 9c			ld	c,-100 
10e9 cd f3 10			call	.Na1 
10ec 0e f6			ld	c,-10 
10ee cd f3 10			call	.Na1 
10f1 0e ff			ld	c,-1 
10f3 06 2f		.Na1:	ld	b,'0'-1 
10f5 04			.Na2:	inc	b 
10f6 81				add	a,c 
10f7 38 fc			jr	c,.Na2 
10f9 91				sub	c		;works as add 100/10/1 
10fa f5				push af		;safer than ld c,a 
10fb 78				ld	a,b		;char is in b 
10fc			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10fc f1				pop af		;safer than ld a,c 
10fd c9				ret 
10fe			 
10fe			; Decimal Signed Version 
10fe			 
10fe			; DispA 
10fe			; -------------------------------------------------------------- 
10fe			; Converts a signed integer value to a zero-terminated ASCII 
10fe			; string representative of that value (using radix 10). 
10fe			; -------------------------------------------------------------- 
10fe			; INPUTS: 
10fe			;     HL     Value to convert (two's complement integer). 
10fe			;     DE     Base address of string destination. (pointer). 
10fe			; -------------------------------------------------------------- 
10fe			; OUTPUTS: 
10fe			;     None 
10fe			; -------------------------------------------------------------- 
10fe			; REGISTERS/MEMORY DESTROYED 
10fe			; AF HL 
10fe			; -------------------------------------------------------------- 
10fe			 
10fe			;DispHLToASCII: 
10fe			;   push    de 
10fe			;   push    bc 
10fe			; 
10fe			;; Detect sign of HL. 
10fe			;    bit    7, h 
10fe			;    jr     z, ._DoConvert 
10fe			; 
10fe			;; HL is negative. Output '-' to string and negate HL. 
10fe			;    ld     a, '-' 
10fe			;    ld     (de), a 
10fe			;    inc    de 
10fe			; 
10fe			;; Negate HL (using two's complement) 
10fe			;    xor    a 
10fe			;    sub    l 
10fe			;    ld     l, a 
10fe			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10fe			;    sbc    a, h 
10fe			;    ld     h, a 
10fe			; 
10fe			;; Convert HL to digit characters 
10fe			;._DoConvert: 
10fe			;    ld     b, 0     ; B will count character length of number 
10fe			;-   ld     a, 10 
10fe			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10fe			;    push   af 
10fe			;    inc    b 
10fe			;    ld     a, h 
10fe			;    or     l 
10fe			;    jr     nz, - 
10fe			; 
10fe			;; Retrieve digits from stack 
10fe			;-   pop    af 
10fe			;    or     $30 
10fe			;    ld     (de), a 
10fe			;    inc    de 
10fe			;    djnz   - 
10fe			; 
10fe			;; Terminate string with NULL 
10fe			;    xor    a 
10fe			;    ld     (de), a 
10fe			; 
10fe			;    pop    bc 
10fe			;    pop    de 
10fe			;    ret 
10fe			 
10fe			;Comments 
10fe			; 
10fe			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10fe			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10fe			;    Note that the output string will not be fixed-width. 
10fe			; 
10fe			;Example Usage 
10fe			; 
10fe			;    ld    hl, -1004 
10fe			;    ld    de, OP1 
10fe			;    call  DispA 
10fe			;    ld    hl, OP1 
10fe			;    syscall  PutS 
10fe			 
10fe			 
10fe			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fe			 
10fe			 
10fe			;Converts an ASCII string to an unsigned 16-bit integer 
10fe			;Quits when it reaches a non-decimal digit 
10fe			 
10fe			string_to_uint16: 
10fe			atoui_16: 
10fe			;Input: 
10fe			;     DE points to the string 
10fe			;Outputs: 
10fe			;     HL is the result 
10fe			;     A is the 8-bit value of the number 
10fe			;     DE points to the byte after the number 
10fe			;Destroys: 
10fe			;     BC 
10fe			;       if the string is non-empty, BC is HL/10 
10fe			;Size:  24 bytes 
10fe			;Speed: 42+d(104+{0,9}) 
10fe			;       d is the number of digits in the number 
10fe			;       max is 640 cycles for a 5 digit number 
10fe			;Assuming no leading zeros: 
10fe			;1 digit:  146cc 
10fe			;2 digit:  250cc 
10fe			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10fe			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10fe			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10fe			;avg: 544.81158447265625cc (544+13297/16384) 
10fe			;=============================================================== 
10fe 21 00 00		  ld hl,0 
1101			.u16a: 
1101 1a			  ld a,(de) 
1102 d6 30		  sub 30h 
1104 fe 0a		  cp 10 
1106 d0			  ret nc 
1107 13			  inc de 
1108 44			  ld b,h 
1109 4d			  ld c,l 
110a 29			  add hl,hl 
110b 29			  add hl,hl 
110c 09			  add hl,bc 
110d 29			  add hl,hl 
110e 85			  add a,l 
110f 6f			  ld l,a 
1110 30 ef		  jr nc,.u16a 
1112 24			  inc h 
1113 c3 01 11		  jp .u16a 
1116			 
1116			 
1116			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1116			 
1116			;written by Zeda 
1116			;Converts a 16-bit unsigned integer to an ASCII string. 
1116			 
1116			uitoa_16: 
1116			;Input: 
1116			;   DE is the number to convert 
1116			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1116			;Output: 
1116			;   HL points to the null-terminated ASCII string 
1116			;      NOTE: This isn't necessarily the same as the input HL. 
1116 d5			  push de 
1117 c5			  push bc 
1118 f5			  push af 
1119 eb			  ex de,hl 
111a			 
111a 01 f0 d8		  ld bc,-10000 
111d 3e 2f		  ld a,'0'-1 
111f 3c			  inc a 
1120 09			  add hl,bc  
1121 38 fc		   jr c,$-2 
1123 12			  ld (de),a 
1124 13			  inc de 
1125			 
1125 01 e8 03		  ld bc,1000 
1128 3e 3a		  ld a,'9'+1 
112a 3d			  dec a  
112b 09			  add hl,bc  
112c 30 fc		   jr nc,$-2 
112e 12			  ld (de),a 
112f 13			  inc de 
1130			 
1130 01 9c ff		  ld bc,-100 
1133 3e 2f		  ld a,'0'-1 
1135 3c			  inc a  
1136 09			  add hl,bc  
1137 38 fc		   jr c,$-2 
1139 12			  ld (de),a 
113a 13			  inc de 
113b			 
113b 7d			  ld a,l 
113c 26 3a		  ld h,'9'+1 
113e 25			  dec h  
113f c6 0a		  add a,10  
1141 30 fb		   jr nc,$-3 
1143 c6 30		  add a,'0' 
1145 eb			  ex de,hl 
1146 72			  ld (hl),d 
1147 23			  inc hl 
1148 77			  ld (hl),a 
1149 23			  inc hl 
114a 36 00		  ld (hl),0 
114c			 
114c			;Now strip the leading zeros 
114c 0e fa		  ld c,-6 
114e 09			  add hl,bc 
114f 3e 30		  ld a,'0' 
1151 23			  inc hl  
1152 be			  cp (hl)  
1153 28 fc		  jr z,$-2 
1155			 
1155			;Make sure that the string is non-empty! 
1155 7e			  ld a,(hl) 
1156 b7			  or a 
1157 20 01		  jr nz,.atoub 
1159 2b			  dec hl 
115a			.atoub: 
115a			 
115a f1			  pop af 
115b c1			  pop bc 
115c d1			  pop de 
115d c9			  ret 
115e			 
115e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
115e			 
115e			toUpper: 
115e			;A is the char. 
115e			;If A is a lowercase letter, this sets it to the matching uppercase 
115e			;18cc or 30cc or 41cc 
115e			;avg: 26.75cc 
115e fe 61		  cp 'a' 
1160 d8			  ret c 
1161 fe 7b		  cp 'z'+1 
1163 d0			  ret nc 
1164 d6 20		  sub 'a'-'A' 
1166 c9			  ret 
1167			 
1167			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1167			 
1167			; String Length 
1167			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1167			 
1167			; Get the length of the null-terminated string starting at $8000 hl 
1167			;    LD     HL, $8000 
1167			 
1167			strlenz: 
1167			 
1167 af			    XOR    A               ; Zero is the value we are looking for. 
1168 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1169 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
116a			                           ; 65, 536 bytes (the entire addressable memory space). 
116a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
116c			 
116c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
116c 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
116d 6f			    LD     L, A             ; number of bytes 
116e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1170 2b			    DEC    HL              ; Compensate for null. 
1171 c9				ret 
1172			 
1172			; Get the length of the A terminated string starting at $8000 hl 
1172			;    LD     HL, $8000 
1172			 
1172			strlent: 
1172			 
1172			                  ; A is the value we are looking for. 
1172 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1174 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1176			                           ; 65, 536 bytes (the entire addressable memory space). 
1176 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1178			 
1178			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1178 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
117a 2e 00		    LD     L, 0             ; number of bytes 
117c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
117e 2b			    DEC    HL              ; Compensate for null. 
117f c9				ret 
1180			 
1180			 
1180			;Comparing Strings 
1180			 
1180			;IN    HL     Address of string1. 
1180			;      DE     Address of string2. 
1180			 
1180			; doc given but wrong??? 
1180			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1180			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1180			; tested 
1180			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1180			 
1180			strcmp_old: 
1180 e5			    PUSH   HL 
1181 d5			    PUSH   DE 
1182			 
1182 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1183 be			    CP     (HL)            ; (want to minimize work). 
1184 38 01		    JR     C, Str1IsBigger 
1186 7e			    LD     A, (HL) 
1187			 
1187			Str1IsBigger: 
1187 4f			    LD     C, A             ; Put length in BC 
1188 06 00		    LD     B, 0 
118a 13			    INC    DE              ; Increment pointers to meat of string. 
118b 23			    INC    HL 
118c			 
118c			CmpLoop: 
118c 1a			    LD     A, (DE)          ; Compare bytes. 
118d ed a1		    CPI 
118f 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1191 13			    INC    DE              ; Update pointer. 
1192 ea 8c 11		    JP     PE, CmpLoop 
1195			 
1195 d1			    POP    DE 
1196 e1			    POP    HL 
1197 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1198 be			    CP     (HL) 
1199 c9			    RET 
119a			 
119a			NoMatch: 
119a 2b			    DEC    HL 
119b be			    CP     (HL)            ; Compare again to affect carry. 
119c d1			    POP    DE 
119d e1			    POP    HL 
119e c9			    RET 
119f			 
119f			;; test strmp 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str2 
119f			;call strcmp 
119f			;jr z, .z1 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "NZ1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.z1: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "ZZ1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str1 
119f			;call strcmp 
119f			;jr z, .z2 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "NZ2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.z2: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "ZZ2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str2 
119f			;call strcmp 
119f			;jr c, .c1 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "Nc1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.c1: 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "cc1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str1 
119f			;call strcmp 
119f			;jr c, .c2 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "Nc2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.c2: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "cc2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;	NEXTW 
119f			;.str1:   db "string1",0 
119f			;.str2:   db "string2",0 
119f			 
119f			; only care about direct match or not 
119f			; hl and de strings 
119f			; zero set if the same 
119f			 
119f			strcmp: 
119f 1a				ld a, (de) 
11a0 be				cp (hl) 
11a1 28 02			jr z, .ssame 
11a3 b7				or a 
11a4 c9				ret 
11a5			 
11a5			.ssame:  
11a5 fe 00			cp 0 
11a7 c8				ret z 
11a8			 
11a8 23				inc hl 
11a9 13				inc de 
11aa 18 f3			jr strcmp 
11ac				 
11ac				 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			; eof 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
# End of file firmware_strings.asm
11ac			include "firmware_memory.asm"   ; malloc and free  
11ac			 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			.mallocsize: db "Wants malloc >256",0 
11ac			.mallocasize: db "MALLOC gives >256",0 
11ac			.malloczero: db "MALLOC gives zero",0 
11ac			 
11ac			malloc_guard_zerolen: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac				ld de, 0 
11ac			        call cmp16 
11ac				jr nz, .lowalloz 
11ac			 
11ac				push hl 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .malloczero 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac			.lowalloz: 
11ac			 
11ac			 
11ac				pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_entry: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowalloc 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocsize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdone 
11ac			.lowalloc: 
11ac			 
11ac			 
11ac				pop hl 
11ac			.lowdone:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_exit: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowallocx 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocasize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdonex 
11ac			.lowallocx: 
11ac			 
11ac				pop hl 
11ac			.lowdonex:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			endif 
11ac			 
11ac			if MALLOC_2 
11ac			; Z80 Malloc and Free Functions 
11ac			 
11ac			; Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc: 
11ac				 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_entry 
11ac			endif 
11ac			 
11ac			 
11ac			 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "mal" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of size into A 
11ac			    or h               ; Check if size is zero 
11ac			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11ac			 
11ac			    ; Allocate memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma1" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    call malloc_internal ; Call internal malloc function 
11ac			    pop af             ; Restore AF register 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret                ; Return 
11ac			 
11ac			; Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free: 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of pointer into A 
11ac			    or h               ; Check if pointer is NULL 
11ac			    jp z, free_exit    ; If pointer is NULL, exit 
11ac			 
11ac			    ; Free memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac			    call free_internal  ; Call internal free function 
11ac			    pop af             ; Restore AF register 
11ac			    ret                ; Return 
11ac			 
11ac			; Internal Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc_internal: 
11ac			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to requested size 
11ac			    ex de, hl          ; Save total size in DE, and keep it in HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			 
11ac			    ; Search for free memory block 
11ac			    ld de, (heap_end)  ; Load end of heap into DE 
11ac			    ld bc, 0           ; Initialize counter 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			malloc_search_loop: 
11ac			    ; Check if current block is free 
11ac			    ld a, (hl)         ; Load current block's status (free or used) 
11ac			    cp 0               ; Compare with zero (free) 
11ac			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11ac			 
11ac			    ; Check if current block is large enough 
11ac			    ld a, (hl+1)       ; Load high byte of block size 
11ac			    cp l               ; Compare with low byte of requested size 
11ac			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11ac			 
11ac			    ld a, (hl+2)       ; Load low byte of block size 
11ac			    cp h               ; Compare with high byte of requested size 
11ac			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11ac			 
11ac			    ; Mark block as used 
11ac			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11ac			 
11ac			    ; Calculate remaining space in block 
11ac			    ld bc, 0           ; Clear BC 
11ac			    add hl, bc         ; Increment HL to point to start of data block 
11ac			    add hl, de         ; HL = HL + DE (total size) 
11ac			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to start of data block 
11ac			 
11ac			    ; Save pointer to allocated block in HL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma5" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			malloc_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3           ; Size of management overhead 
11ac			    add hl, bc         ; Move to the next block 
11ac			    inc de             ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e            ; Load low byte of heap end address 
11ac			    cp (hl)            ; Compare with low byte of current address 
11ac			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11ac			    ld a, d            ; Load high byte of heap end address 
11ac			    cp 0               ; Check if it's zero (end of memory) 
11ac			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, allocation failed 
11ac			    xor a              ; Set result to NULL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma6" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			malloc_exit: 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma7" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			; Internal Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free_internal: 
11ac			    ld de, (heap_start) ; Load start of heap into DE 
11ac			    ld bc, 0            ; Initialize counter 
11ac			 
11ac			free_search_loop: 
11ac			    ; Check if current block contains the pointer 
11ac			    ld a, l             ; Load low byte of pointer 
11ac			    cp (hl+1)           ; Compare with high byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			    ld a, h             ; Load high byte of pointer 
11ac			    cp (hl+2)           ; Compare with low byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			 
11ac			    ; Mark block as free 
11ac			    ld (hl), 0          ; Set status byte to indicate free block 
11ac			    ret                 ; Return 
11ac			 
11ac			free_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3            ; Size of management overhead 
11ac			    add hl, bc          ; Move to the next block 
11ac			    inc de              ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e             ; Load low byte of heap end address 
11ac			    cp (hl)             ; Compare with low byte of current address 
11ac			    jr nz, free_search_loop  ; If not equal, continue searching 
11ac			    ld a, d             ; Load high byte of heap end address 
11ac			    cp 0                ; Check if it's zero (end of memory) 
11ac			    jr nz, free_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, pointer is not found in heap 
11ac			    ret 
11ac			 
11ac			free_exit: 
11ac			    ret                 ; Return 
11ac			 
11ac			; Define heap start and end addresses 
11ac			;heap_start:    .dw 0xC000   ; Start of heap 
11ac			;heap_end:      .dw 0xE000   ; End of heap 
11ac			 
11ac			endif 
11ac			 
11ac			 
11ac			if MALLOC_1 
11ac			 
11ac			 
11ac			 
11ac			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11ac			 
11ac			;moved to firmware.asm 
11ac			;heap_start        .equ  0x9000      ; Starting address of heap 
11ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11ac			 
11ac			;      .org 0 
11ac			;      jp    main 
11ac			 
11ac			 
11ac			;      .org  0x100 
11ac			;main: 
11ac			;      ld    HL, 0x8100 
11ac			;      ld    SP, HL 
11ac			; 
11ac			;      call  heap_init 
11ac			; 
11ac			;      ; Make some allocations 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9004 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9014 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9024 
11ac			; 
11ac			;      ; Free some allocations 
11ac			;      ld    HL, 0x9014 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9004 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9024 
11ac			;      call  free 
11ac			; 
11ac			; 
11ac			;      halt 
11ac			 
11ac			 
11ac			;------------------------------------------------------------------------------ 
11ac			;     heap_init                                                               : 
11ac			;                                                                             : 
11ac			; Description                                                                 : 
11ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
11ac			;                                                                             : 
11ac			;     The heap is maintained as a linked list, starting with an initial       : 
11ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11ac			;     the first free block in the heap. Each block then points to the next    : 
11ac			;     free block within the heap, and the free list ends at the first block   : 
11ac			;     with a null pointer to the next free block.                             : 
11ac			;                                                                             : 
11ac			; Parameters                                                                  : 
11ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
11ac			;     address of the heap and its size are required, along with a memory      : 
11ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11ac			;     principally stores a pointer to the first free block in the heap.       : 
11ac			;                                                                             : 
11ac			; Returns                                                                     : 
11ac			;     Nothing                                                                 : 
11ac			;------------------------------------------------------------------------------ 
11ac			heap_init: 
11ac e5			      push  HL 
11ad			 
11ad			      ; Initialise free list struct 
11ad 21 0e 80		      ld    HL, heap_start 
11b0 22 0a 80		      ld    (free_list), HL 
11b3 21 00 00		      ld    HL, 0 
11b6 22 0c 80		      ld    (free_list+2), HL 
11b9			 
11b9			      ; Insert first free block at bottom of heap, consumes entire heap 
11b9 21 ff ed		      ld    HL, heap_start+heap_size-4 
11bc 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11bf 21 f1 6d		      ld    HL, heap_size-4 
11c2 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c5			 
11c5			      ; Insert end of free list block at top of heap - two null words will 
11c5			      ; terminate the free list 
11c5 21 00 00		      ld    HL, 0 
11c8 22 01 ee		      ld    (heap_start+heap_size-2), HL 
11cb 22 ff ed		      ld    (heap_start+heap_size-4), HL 
11ce			 
11ce e1			      pop   HL 
11cf			 
11cf c9			      ret 
11d0			 
11d0			 
11d0			;------------------------------------------------------------------------------ 
11d0			;     malloc                                                                  : 
11d0			;                                                                             : 
11d0			; Description                                                                 : 
11d0			;     Allocates the wanted space from the heap and returns the address of the : 
11d0			;     first useable byte of the allocation.                                   : 
11d0			;                                                                             : 
11d0			;     Allocations can happen in one of two ways:                              : 
11d0			;                                                                             : 
11d0			;     1. A free block may be found which is the exact size wanted. In this    : 
11d0			;        case the block is removed from the free list and retuedn to the      : 
11d0			;        caller.                                                              : 
11d0			;     2. A free block may be found which is larger than the size wanted. In   : 
11d0			;        this case, the larger block is split into two. The first portion of  : 
11d0			;        this block will become the requested space by the malloc call and    : 
11d0			;        is returned to the caller. The second portion becomes a new free     : 
11d0			;        block, and the free list is adjusted to maintain continuity via this : 
11d0			;        newly created block.                                                 : 
11d0			;                                                                             : 
11d0			;     malloc does not set any initial value in the allocated space, the       : 
11d0			;     caller is required to do this as required.                              : 
11d0			;                                                                             : 
11d0			;     This implementation of malloc uses the stack exclusively, and is        : 
11d0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d0			;     advisable to disable interrupts before calling malloc, and recommended  : 
11d0			;     to avoid the use of malloc inside ISRs in general.                      : 
11d0			;                                                                             : 
11d0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d0			;                                                                             : 
11d0			; Parameters                                                                  : 
11d0			;     HL  Number of bytes wanted                                              : 
11d0			;                                                                             : 
11d0			; Returns                                                                     : 
11d0			;     HL  Address of the first useable byte of the allocation                 : 
11d0			;                                                                             : 
11d0			; Flags                                                                       : 
11d0			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11d0			;                                                                             : 
11d0			; Stack frame                                                                 : 
11d0			;       |             |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     BC      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     DE      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     IX      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |  prev_free  |                                                       : 
11d0			;   +4  +-------------+                                                       : 
11d0			;       |  this_free  |                                                       : 
11d0			;   +2  +-------------+                                                       : 
11d0			;       |  next_free  |                                                       : 
11d0			;   +0  +-------------+                                                       : 
11d0			;       |             |                                                       : 
11d0			;                                                                             : 
11d0			;------------------------------------------------------------------------------ 
11d0			 
11d0			 
11d0			;malloc: 
11d0			; 
11d0			;	SAVESP ON 1 
11d0			; 
11d0			;	call malloc_code 
11d0			; 
11d0			;	CHECKSP ON 1 
11d0			;	ret 
11d0			 
11d0			 
11d0			malloc: 
11d0 c5			      push  BC 
11d1 d5			      push  DE 
11d2 dd e5		      push  IX 
11d4			if DEBUG_FORTH_MALLOC_HIGH 
11d4			call malloc_guard_entry 
11d4			endif 
11d4			 
11d4					if DEBUG_FORTH_MALLOC 
11d4						DMARK "mal" 
11d4						CALLMONITOR 
11d4					endif 
11d4 7c			      ld    A, H                    ; Exit if no space requested 
11d5 b5			      or    L 
11d6 ca 95 12		      jp    Z, malloc_early_exit 
11d9			 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			; 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			 
11d9			 
11d9			 
11d9			 
11d9					if DEBUG_FORTH_MALLOC 
11d9						DMARK "maA" 
11d9						CALLMONITOR 
11d9					endif 
11d9			      ; Set up stack frame 
11d9 eb			      ex    DE, HL 
11da 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11dd 39			      add   HL, SP 
11de f9			      ld    SP, HL 
11df dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e3 dd 39		      add   IX, SP 
11e5			 
11e5			      ; Setup initial state 
11e5 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e8 19			      add   HL, DE 
11e9			 
11e9 44			      ld    B, H                    ; Move want to BC 
11ea 4d			      ld    C, L 
11eb			 
11eb 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ee dd 75 04		      ld    (IX+4), L 
11f1 dd 74 05		      ld    (IX+5), H 
11f4			 
11f4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 dd 73 02		      ld    (IX+2), E 
11fa dd 72 03		      ld    (IX+3), D 
11fd eb			      ex    DE, HL                  ; this_free ptr into HL 
11fe			 
11fe					if DEBUG_FORTH_MALLOC 
11fe						DMARK "maB" 
11fe						CALLMONITOR 
11fe					endif 
11fe			      ; Loop through free block list to find some space 
11fe			malloc_find_space: 
11fe 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11ff 23			      inc   HL 
1200 56			      ld    D, (HL) 
1201			 
1201 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1202 b3			      or    E 
1203 ca 8f 12		      jp    Z, malloc_no_space 
1206			 
1206 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1209 dd 72 01		      ld    (IX+1), D 
120c			 
120c			      ; Does this block have enough space to make the allocation? 
120c 23			      inc   HL                      ; Load free block size into DE 
120d 5e			      ld    E, (HL) 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210			 
1210 eb			      ex    DE, HL                  ; Check size of block against want 
1211 b7			      or    A                       ; Ensure carry flag clear 
1212 ed 42		      sbc   HL, BC 
1214 e5			      push  HL                      ; Store the result for later (new block size) 
1215			 
1215 ca 64 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1218 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
121a			 
121a			      ; this_free block is not big enough, setup ptrs to test next free block 
121a e1			      pop   HL                      ; Discard previous result 
121b			 
121b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121e dd 66 03		      ld    H, (IX+3) 
1221 dd 75 04		      ld    (IX+4), L 
1224 dd 74 05		      ld    (IX+5), H 
1227			 
1227 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
122a dd 66 01		      ld    H, (IX+1) 
122d dd 75 02		      ld    (IX+2), L 
1230 dd 74 03		      ld    (IX+3), H 
1233			 
1233					if DEBUG_FORTH_MALLOC 
1233						DMARK "MA>" 
1233						CALLMONITOR 
1233					endif 
1233 18 c9		      jr    malloc_find_space 
1235			 
1235			      ; split a bigger block into two - requested size and remaining size 
1235			malloc_alloc_split: 
1235					if DEBUG_FORTH_MALLOC 
1235						DMARK "MAs" 
1235						CALLMONITOR 
1235					endif 
1235 eb			      ex    DE, HL                  ; Calculate address of new free block 
1236 2b			      dec   HL 
1237 2b			      dec   HL 
1238 2b			      dec   HL 
1239 09			      add   HL, BC 
123a			 
123a			      ; Create a new block and point it at next_free 
123a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123d dd 56 01		      ld    D, (IX+1) 
1240			 
1240 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1241 23			      inc   HL 
1242 72			      ld    (HL), D 
1243			 
1243 d1			      pop   DE                      ; Store size of new block into new block 
1244 23			      inc   HL 
1245 73			      ld    (HL), E 
1246 23			      inc   HL 
1247 72			      ld    (HL), D 
1248			 
1248			      ; Update this_free ptr to point to new block 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 2b			      dec   HL 
124b			 
124b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124e dd 56 03		      ld    D, (IX+3) 
1251			 
1251 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1254 dd 74 03		      ld    (IX+3), H 
1257			 
1257			      ; Modify this_free block to be allocation 
1257 eb			      ex    DE, HL 
1258 af			      xor   A                       ; Null the next block ptr of allocated block 
1259 77			      ld    (HL), A 
125a 23			      inc   HL 
125b 77			      ld    (HL), A 
125c			 
125c 23			      inc   HL                      ; Store want size into allocated block 
125d 71			      ld    (HL), C 
125e 23			      inc   HL 
125f 70			      ld    (HL), B 
1260 23			      inc   HL 
1261 e5			      push  HL                      ; Address of allocation to return 
1262			 
1262 18 19		      jr    malloc_update_links 
1264			 
1264			malloc_alloc_fit: 
1264 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1265			 
1265					if DEBUG_FORTH_MALLOC 
1265						DMARK "MAf" 
1265						CALLMONITOR 
1265					endif 
1265			      ; Modify this_free block to be allocation 
1265 eb			      ex    DE, HL 
1266 2b			      dec   HL 
1267 2b			      dec   HL 
1268 2b			      dec   HL 
1269			 
1269 af			      xor   A                       ; Null the next block ptr of allocated block 
126a 77			      ld    (HL), A 
126b 23			      inc   HL 
126c 77			      ld    (HL), A 
126d			 
126d 23			      inc   HL                      ; Store address of allocation to return 
126e 23			      inc   HL 
126f 23			      inc   HL 
1270 e5			      push  HL 
1271			 
1271			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1271 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1274 dd 66 01		      ld    H, (IX+1) 
1277			 
1277 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
127a dd 74 03		      ld    (IX+3), H 
127d			 
127d			 
127d			malloc_update_links: 
127d			      ; Update prev_free ptr to point to this_free 
127d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1280 dd 66 05		      ld    H, (IX+5) 
1283			 
1283 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1286 dd 56 03		      ld    D, (IX+3) 
1289			 
1289 73			      ld    (HL), E                 ; this_free ptr into prev_free 
128a 23			      inc   HL 
128b 72			      ld    (HL), D 
128c			 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "Mul" 
128c						CALLMONITOR 
128c					endif 
128c			      ; Clear the Z flag to indicate successful allocation 
128c 7a			      ld    A, D 
128d b3			      or    E 
128e			 
128e d1			      pop   DE                      ; Address of allocation 
128f					if DEBUG_FORTH_MALLOC 
128f						DMARK "MAu" 
128f						CALLMONITOR 
128f					endif 
128f			 
128f			malloc_no_space: 
128f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1292 39			      add   HL, SP 
1293 f9			      ld    SP, HL 
1294			 
1294 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAN" 
1295						CALLMONITOR 
1295					endif 
1295			 
1295			malloc_early_exit: 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAx" 
1295						CALLMONITOR 
1295					endif 
1295 dd e1		      pop   IX 
1297 d1			      pop   DE 
1298 c1			      pop   BC 
1299			 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299 c9			      ret 
129a			 
129a			 
129a			;------------------------------------------------------------------------------ 
129a			;     free                                                                    : 
129a			;                                                                             : 
129a			; Description                                                                 : 
129a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
129a			;     returned by malloc, otherwise the behaviour is undefined.               : 
129a			;                                                                             : 
129a			;     Where possible, directly adjacent free blocks will be merged together   : 
129a			;     into larger blocks to help ensure that the heap does not become         : 
129a			;     excessively fragmented.                                                 : 
129a			;                                                                             : 
129a			;     free does not clear or set any other value into the freed space, and    : 
129a			;     therefore its contents may be visible through subsequent malloc's. The  : 
129a			;     caller should clear the freed space as required.                        : 
129a			;                                                                             : 
129a			;     This implementation of free uses the stack exclusively, and is          : 
129a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
129a			;     advisable to disable interrupts before calling free, and recommended    : 
129a			;     to avoid the use of free inside ISRs in general.                        : 
129a			;                                                                             : 
129a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
129a			;                                                                             : 
129a			; Parameters                                                                  : 
129a			;     HL  Pointer to address of first byte of allocation to be freed          : 
129a			;                                                                             : 
129a			; Returns                                                                     : 
129a			;     Nothing                                                                 : 
129a			;                                                                             : 
129a			; Stack frame                                                                 : 
129a			;       |             |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     BC      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     DE      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     IX      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |  prev_free  |                                                       : 
129a			;   +2  +-------------+                                                       : 
129a			;       |  next_free  |                                                       : 
129a			;   +0  +-------------+                                                       : 
129a			;       |             |                                                       : 
129a			;                                                                             : 
129a			;------------------------------------------------------------------------------ 
129a			free: 
129a c5			      push  BC 
129b d5			      push  DE 
129c dd e5		      push  IX 
129e			 
129e 7c			      ld    A, H                    ; Exit if ptr is null 
129f b5			      or    L 
12a0 ca 64 13		      jp    Z, free_early_exit 
12a3			 
12a3			      ; Set up stack frame 
12a3 eb			      ex    DE, HL 
12a4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a7 39			      add   HL, SP 
12a8 f9			      ld    SP, HL 
12a9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12ad dd 39		      add   IX, SP 
12af			 
12af			      ; The address in HL points to the start of the useable allocated space, 
12af			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12af			      ; address of the block itself. 
12af eb			      ex    DE, HL 
12b0 11 fc ff		      ld    DE, -4 
12b3 19			      add   HL, DE 
12b4			 
12b4			      ; An allocated block must have a null next block pointer in it 
12b4 7e			      ld    A, (HL) 
12b5 23			      inc   HL 
12b6 b6			      or    (HL) 
12b7 c2 5f 13		      jp    NZ, free_done 
12ba			 
12ba 2b			      dec   HL 
12bb			 
12bb 44			      ld    B, H                    ; Copy HL to BC 
12bc 4d			      ld    C, L 
12bd			 
12bd			      ; Loop through the free list to find the first block with an address 
12bd			      ; higher than the block being freed 
12bd 21 0a 80		      ld    HL, free_list 
12c0			 
12c0			free_find_higher_block: 
12c0 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12c1 23			      inc   HL 
12c2 56			      ld    D, (HL) 
12c3 2b			      dec   HL 
12c4			 
12c4 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c7 dd 72 01		      ld    (IX+1), D 
12ca dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12cd dd 74 03		      ld    (IX+3), H 
12d0			 
12d0 78			      ld    A, B                    ; Check if DE is greater than BC 
12d1 ba			      cp    D                       ; Compare MSB first 
12d2 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d4 30 04		      jr    NC, free_find_higher_block_skip 
12d6 79			      ld    A, C 
12d7 bb			      cp    E                       ; Then compare LSB 
12d8 38 08		      jr    C, free_found_higher_block 
12da			 
12da			free_find_higher_block_skip: 
12da 7a			      ld    A, D                    ; Reached the end of the free list? 
12db b3			      or    E 
12dc ca 5f 13		      jp    Z, free_done 
12df			 
12df eb			      ex    DE, HL 
12e0			 
12e0 18 de		      jr    free_find_higher_block 
12e2			 
12e2			free_found_higher_block: 
12e2			      ; Insert freed block between prev and next free blocks 
12e2 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e3 23			      inc   HL 
12e4 70			      ld    (HL), B 
12e5			 
12e5 60			      ld    H, B                    ; Point freed block at next free block 
12e6 69			      ld    L, C 
12e7 73			      ld    (HL), E 
12e8 23			      inc   HL 
12e9 72			      ld    (HL), D 
12ea			 
12ea			      ; Check if the freed block is adjacent to the next free block 
12ea 23			      inc   HL                      ; Load size of freed block into HL 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee eb			      ex    DE, HL 
12ef			 
12ef 09			      add   HL, BC                  ; Add addr of freed block and its size 
12f0			 
12f0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f3 dd 56 01		      ld    D, (IX+1) 
12f6			 
12f6 b7			      or    A                       ; Clear the carry flag 
12f7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f9 20 22		      jr    NZ, free_check_adjacent_to_prev 
12fb			 
12fb			      ; Freed block is adjacent to next, merge into one bigger block 
12fb eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12fc 5e			      ld    E, (HL) 
12fd 23			      inc   HL 
12fe 56			      ld    D, (HL) 
12ff e5			      push  HL                      ; Save ptr to next block for later 
1300			 
1300 60			      ld    H, B                    ; Store ptr from next block into freed block 
1301 69			      ld    L, C 
1302 73			      ld    (HL), E 
1303 23			      inc   HL 
1304 72			      ld    (HL), D 
1305			 
1305 e1			      pop   HL                      ; Restore ptr to next block 
1306 23			      inc   HL                      ; Load size of next block into DE 
1307 5e			      ld    E, (HL) 
1308 23			      inc   HL 
1309 56			      ld    D, (HL) 
130a d5			      push  DE                      ; Save next block size for later 
130b			 
130b 60			      ld    H, B                    ; Load size of freed block into HL 
130c 69			      ld    L, C 
130d 23			      inc   HL 
130e 23			      inc   HL 
130f 5e			      ld    E, (HL) 
1310 23			      inc   HL 
1311 56			      ld    D, (HL) 
1312 eb			      ex    DE, HL 
1313			 
1313 d1			      pop   DE                      ; Restore size of next block 
1314 19			      add   HL, DE                  ; Add sizes of both blocks 
1315 eb			      ex    DE, HL 
1316			 
1316 60			      ld    H, B                    ; Store new bigger size into freed block 
1317 69			      ld    L, C 
1318 23			      inc   HL 
1319 23			      inc   HL 
131a 73			      ld    (HL), E 
131b 23			      inc   HL 
131c 72			      ld    (HL), D 
131d			 
131d			free_check_adjacent_to_prev: 
131d			      ; Check if the freed block is adjacent to the prev free block 
131d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1320 dd 66 03		      ld    H, (IX+3) 
1323			 
1323 23			      inc   HL                      ; Size of prev free block into DE 
1324 23			      inc   HL 
1325 5e			      ld    E, (HL) 
1326 23			      inc   HL 
1327 56			      ld    D, (HL) 
1328 2b			      dec   HL 
1329 2b			      dec   HL 
132a 2b			      dec   HL 
132b			 
132b 19			      add   HL, DE                  ; Add prev block addr and size 
132c			 
132c b7			      or    A                       ; Clear the carry flag 
132d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132f 20 2e		      jr    NZ, free_done 
1331			 
1331			      ; Freed block is adjacent to prev, merge into one bigger block 
1331 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1332 69			      ld    L, C 
1333 5e			      ld    E, (HL) 
1334 23			      inc   HL 
1335 56			      ld    D, (HL) 
1336 e5			      push  HL                      ; Save freed block ptr for later 
1337			 
1337 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
133a dd 66 03		      ld    H, (IX+3) 
133d 73			      ld    (HL), E 
133e 23			      inc   HL 
133f 72			      ld    (HL), D 
1340			 
1340 e1			      pop   HL                      ; Restore freed block ptr 
1341 23			      inc   HL                      ; Load size of freed block into DE 
1342 5e			      ld    E, (HL) 
1343 23			      inc   HL 
1344 56			      ld    D, (HL) 
1345 d5			      push  DE                      ; Save freed block size for later 
1346			 
1346 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1349 dd 66 03		      ld    H, (IX+3) 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e 5e			      ld    E, (HL) 
134f 23			      inc   HL 
1350 56			      ld    D, (HL) 
1351			 
1351 e1			      pop   HL                      ; Add sizes of both blocks 
1352 19			      add   HL, DE 
1353 eb			      ex    DE, HL 
1354			 
1354 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1357 dd 66 03		      ld    H, (IX+3) 
135a 23			      inc   HL 
135b 23			      inc   HL 
135c 73			      ld    (HL), E 
135d 23			      inc   HL 
135e 72			      ld    (HL), D 
135f			 
135f			free_done: 
135f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1362 39			      add   HL, SP 
1363 f9			      ld    SP, HL 
1364			 
1364			free_early_exit: 
1364 dd e1		      pop   IX 
1366 d1			      pop   DE 
1367 c1			      pop   BC 
1368			 
1368 c9			      ret 
1369			 
1369			; moved to firmware.asm 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			;                  .dw   0 
1369			 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_3 
1369			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1369			;heap_start        .equ  0x9000      ; Starting address of heap 
1369			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1369			; 
1369			 ;     .org 0 
1369			  ;    jp    main 
1369			; 
1369			; 
1369			 ;     .org  0x100 
1369			;main: 
1369			 ;     ld    HL, 0x8100 
1369			  ;    ld    SP, HL 
1369			; 
1369			;      call  heap_init 
1369			 
1369			      ; Make some allocations 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9004 
1369			; 
1369			 ;     ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9014 
1369			 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9024 
1369			 
1369			      ; Free some allocations 
1369			;      ld    HL, 0x9014 
1369			;      call  free 
1369			 
1369			;      ld    HL, 0x9004 
1369			;      call  free 
1369			; 
1369			;      ld    HL, 0x9024 
1369			;      call  free 
1369			 
1369			 
1369			 ;     halt 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     heap_init                                                               : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Initialise the heap and make it ready for malloc and free operations.   : 
1369			;                                                                             : 
1369			;     The heap is maintained as a linked list, starting with an initial       : 
1369			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1369			;     the first free block in the heap. Each block then points to the next    : 
1369			;     free block within the heap, and the free list ends at the first block   : 
1369			;     with a null pointer to the next free block.                             : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     Inputs are compile-time only. Two defines which specify the starting    : 
1369			;     address of the heap and its size are required, along with a memory      : 
1369			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1369			;     principally stores a pointer to the first free block in the heap.       : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;------------------------------------------------------------------------------ 
1369			heap_init: 
1369			      push  HL 
1369			 
1369			      ; Initialise free list struct 
1369			      ld    HL, heap_start 
1369			      ld    (free_list), HL 
1369			      ld    HL, 0 
1369			      ld    (free_list+2), HL 
1369			 
1369			      ; Insert first free block at bottom of heap, consumes entire heap 
1369			      ld    HL, heap_start+heap_size-4 
1369			      ld    (heap_start), HL        ; Next block (end of free list) 
1369			      ld    HL, heap_size-4 
1369			      ld    (heap_start+2), HL      ; Block size 
1369			 
1369			      ; Insert end of free list block at top of heap - two null words will 
1369			      ; terminate the free list 
1369			      ld    HL, 0 
1369			      ld    (heap_start+heap_size-2), HL 
1369			      ld    (heap_start+heap_size-4), HL 
1369			 
1369			      pop   HL 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     malloc                                                                  : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Allocates the wanted space from the heap and returns the address of the : 
1369			;     first useable byte of the allocation.                                   : 
1369			;                                                                             : 
1369			;     Allocations can happen in one of two ways:                              : 
1369			;                                                                             : 
1369			;     1. A free block may be found which is the exact size wanted. In this    : 
1369			;        case the block is removed from the free list and retuedn to the      : 
1369			;        caller.                                                              : 
1369			;     2. A free block may be found which is larger than the size wanted. In   : 
1369			;        this case, the larger block is split into two. The first portion of  : 
1369			;        this block will become the requested space by the malloc call and    : 
1369			;        is returned to the caller. The second portion becomes a new free     : 
1369			;        block, and the free list is adjusted to maintain continuity via this : 
1369			;        newly created block.                                                 : 
1369			;                                                                             : 
1369			;     malloc does not set any initial value in the allocated space, the       : 
1369			;     caller is required to do this as required.                              : 
1369			;                                                                             : 
1369			;     This implementation of malloc uses the stack exclusively, and is        : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling malloc, and recommended  : 
1369			;     to avoid the use of malloc inside ISRs in general.                      : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Number of bytes wanted                                              : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     HL  Address of the first useable byte of the allocation                 : 
1369			;                                                                             : 
1369			; Flags                                                                       : 
1369			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +4  +-------------+                                                       : 
1369			;       |  this_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			malloc: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if no space requested 
1369			      or    L 
1369			      jp    Z, malloc_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; Setup initial state 
1369			      ld    HL, 4                   ; want must also include space used by block struct 
1369			      add   HL, DE 
1369			 
1369			      ld    B, H                    ; Move want to BC 
1369			      ld    C, L 
1369			 
1369			      ld    HL, free_list           ; Store prev_free ptr to stack 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    E, (HL)                 ; Store this_free ptr to stack 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ld    (IX+2), E 
1369			      ld    (IX+3), D 
1369			      ex    DE, HL                  ; this_free ptr into HL 
1369			 
1369			      ; Loop through free block list to find some space 
1369			malloc_find_space: 
1369			      ld    E, (HL)                 ; Load next_free ptr into DE 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1369			      or    E 
1369			      jp    Z, malloc_no_space 
1369			 
1369			      ld    (IX+0), E               ; Store next_free ptr to stack 
1369			      ld    (IX+1), D 
1369			 
1369			      ; Does this block have enough space to make the allocation? 
1369			      inc   HL                      ; Load free block size into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ex    DE, HL                  ; Check size of block against want 
1369			      or    A                       ; Ensure carry flag clear 
1369			      sbc   HL, BC 
1369			      push  HL                      ; Store the result for later (new block size) 
1369			 
1369			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1369			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1369			 
1369			      ; this_free block is not big enough, setup ptrs to test next free block 
1369			      pop   HL                      ; Discard previous result 
1369			 
1369			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1369			      ld    H, (IX+3) 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1369			      ld    H, (IX+1) 
1369			      ld    (IX+2), L 
1369			      ld    (IX+3), H 
1369			 
1369			      jr    malloc_find_space 
1369			 
1369			      ; split a bigger block into two - requested size and remaining size 
1369			malloc_alloc_split: 
1369			      ex    DE, HL                  ; Calculate address of new free block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      add   HL, BC 
1369			 
1369			      ; Create a new block and point it at next_free 
1369			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      ld    (HL), E                 ; Store next_free ptr into new block 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   DE                      ; Store size of new block into new block 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Update this_free ptr to point to new block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1369			      ld    (IX+3), H 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store want size into allocated block 
1369			      ld    (HL), C 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			      inc   HL 
1369			      push  HL                      ; Address of allocation to return 
1369			 
1369			      jr    malloc_update_links 
1369			 
1369			malloc_alloc_fit: 
1369			      pop   HL                      ; Dont need new block size, want is exact fit 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store address of allocation to return 
1369			      inc   HL 
1369			      inc   HL 
1369			      push  HL 
1369			 
1369			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1369			      ld    L, (IX+0)               ; next_free to HL 
1369			      ld    H, (IX+1) 
1369			 
1369			      ld    (IX+2), L               ; HL to this_free 
1369			      ld    (IX+3), H 
1369			 
1369			 
1369			malloc_update_links: 
1369			      ; Update prev_free ptr to point to this_free 
1369			      ld    L, (IX+4)               ; prev_free ptr to HL 
1369			      ld    H, (IX+5) 
1369			 
1369			      ld    E, (IX+2)               ; this_free ptr to DE 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (HL), E                 ; this_free ptr into prev_free 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Clear the Z flag to indicate successful allocation 
1369			      ld    A, D 
1369			      or    E 
1369			 
1369			      pop   DE                      ; Address of allocation 
1369			 
1369			malloc_no_space: 
1369			      ld    HL, 6                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			      ex    DE, HL                  ; Alloc addr into HL for return 
1369			 
1369			malloc_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     free                                                                    : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1369			;     returned by malloc, otherwise the behaviour is undefined.               : 
1369			;                                                                             : 
1369			;     Where possible, directly adjacent free blocks will be merged together   : 
1369			;     into larger blocks to help ensure that the heap does not become         : 
1369			;     excessively fragmented.                                                 : 
1369			;                                                                             : 
1369			;     free does not clear or set any other value into the freed space, and    : 
1369			;     therefore its contents may be visible through subsequent malloc's. The  : 
1369			;     caller should clear the freed space as required.                        : 
1369			;                                                                             : 
1369			;     This implementation of free uses the stack exclusively, and is          : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling free, and recommended    : 
1369			;     to avoid the use of free inside ISRs in general.                        : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Pointer to address of first byte of allocation to be freed          : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			free: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if ptr is null 
1369			      or    L 
1369			      jp    Z, free_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; The address in HL points to the start of the useable allocated space, 
1369			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1369			      ; address of the block itself. 
1369			      ex    DE, HL 
1369			      ld    DE, -4 
1369			      add   HL, DE 
1369			 
1369			      ; An allocated block must have a null next block pointer in it 
1369			      ld    A, (HL) 
1369			      inc   HL 
1369			      or    (HL) 
1369			      jp    NZ, free_done 
1369			 
1369			      dec   HL 
1369			 
1369			      ld    B, H                    ; Copy HL to BC 
1369			      ld    C, L 
1369			 
1369			      ; Loop through the free list to find the first block with an address 
1369			      ; higher than the block being freed 
1369			      ld    HL, free_list 
1369			 
1369			free_find_higher_block: 
1369			      ld    E, (HL)                 ; Load next ptr from free block 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			 
1369			      ld    (IX+0), E               ; Save ptr to next free block 
1369			      ld    (IX+1), D 
1369			      ld    (IX+2), L               ; Save ptr to prev free block 
1369			      ld    (IX+3), H 
1369			 
1369			      ld    A, B                    ; Check if DE is greater than BC 
1369			      cp    D                       ; Compare MSB first 
1369			      jr    Z, $+4                  ; MSB the same, compare LSB 
1369			      jr    NC, free_find_higher_block_skip 
1369			      ld    A, C 
1369			      cp    E                       ; Then compare LSB 
1369			      jr    C, free_found_higher_block 
1369			 
1369			free_find_higher_block_skip: 
1369			      ld    A, D                    ; Reached the end of the free list? 
1369			      or    E 
1369			      jp    Z, free_done 
1369			 
1369			      ex    DE, HL 
1369			 
1369			      jr    free_find_higher_block 
1369			 
1369			free_found_higher_block: 
1369			      ; Insert freed block between prev and next free blocks 
1369			      ld    (HL), C                 ; Point prev free block to freed block 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			 
1369			      ld    H, B                    ; Point freed block at next free block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Check if the freed block is adjacent to the next free block 
1369			      inc   HL                      ; Load size of freed block into HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      add   HL, BC                  ; Add addr of freed block and its size 
1369			 
1369			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_check_adjacent_to_prev 
1369			 
1369			      ; Freed block is adjacent to next, merge into one bigger block 
1369			      ex    DE, HL                  ; Load next ptr from next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save ptr to next block for later 
1369			 
1369			      ld    H, B                    ; Store ptr from next block into freed block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore ptr to next block 
1369			      inc   HL                      ; Load size of next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save next block size for later 
1369			 
1369			      ld    H, B                    ; Load size of freed block into HL 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      pop   DE                      ; Restore size of next block 
1369			      add   HL, DE                  ; Add sizes of both blocks 
1369			      ex    DE, HL 
1369			 
1369			      ld    H, B                    ; Store new bigger size into freed block 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_check_adjacent_to_prev: 
1369			      ; Check if the freed block is adjacent to the prev free block 
1369			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1369			      ld    H, (IX+3) 
1369			 
1369			      inc   HL                      ; Size of prev free block into DE 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      add   HL, DE                  ; Add prev block addr and size 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_done 
1369			 
1369			      ; Freed block is adjacent to prev, merge into one bigger block 
1369			      ld    H, B                    ; Load next ptr from freed block into DE 
1369			      ld    L, C 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save freed block ptr for later 
1369			 
1369			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1369			      ld    H, (IX+3) 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore freed block ptr 
1369			      inc   HL                      ; Load size of freed block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save freed block size for later 
1369			 
1369			      ld    L, (IX+2)               ; Load size of prev block into DE 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      pop   HL                      ; Add sizes of both blocks 
1369			      add   HL, DE 
1369			      ex    DE, HL 
1369			 
1369			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_done: 
1369			      ld    HL, 4                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			free_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;      .org 0x8000 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			 ;                 .dw   0 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_4 
1369			 
1369			; My memory allocation code. Very very simple.... 
1369			; allocate space under 250 chars 
1369			 
1369			heap_init: 
1369				; init start of heap as zero 
1369				;  
1369			 
1369				ld hl, heap_start 
1369				ld a, 0 
1369				ld (hl), a      ; empty block 
1369				inc hl 
1369				ld a, 0 
1369				ld (hl), a      ; length of block 
1369				; write end of list 
1369				inc hl 
1369				ld a,(hl) 
1369				inc hl 
1369				ld a,(hl) 
1369				 
1369			 
1369				; init some malloc vars 
1369			 
1369				ld hl, 0 
1369				ld (free_list), hl       ; store last malloc location 
1369			 
1369				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1369				ld a, 0 
1369				ld (hl), a 
1369			 
1369			 
1369				ld hl, heap_start 
1369				;  
1369				  
1369				ret 
1369			 
1369			 
1369			;    free block marker 
1369			;    requested size  
1369			;    pointer to next block 
1369			;    .... 
1369			;    next block marker 
1369			 
1369			 
1369			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1369			; 
1369			 
1369			 
1369			malloc:  
1369				push de 
1369				push bc 
1369				push af 
1369			 
1369				; hl space required 
1369				 
1369				ld c, l    ; hold space   (TODO only a max of 255) 
1369			 
1369			;	inc c     ; TODO BUG need to fix memory leak on push str 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			 
1369			 
1369			 
1369				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1369			 
1369				ld a, (free_list+3) 
1369				cp 0 
1369				jr z, .contheap 
1369			 
1369				ld hl, (free_list)     ; get last alloc 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mrs" 
1369						CALLMONITOR 
1369					endif 
1369				jr .startalloc 
1369			 
1369			.contheap: 
1369				ld hl, heap_start 
1369			 
1369			.startalloc: 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mym" 
1369						CALLMONITOR 
1369					endif 
1369			.findblock: 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmf" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369				ld a,(hl)  
1369				; if byte is zero then clear to use 
1369			 
1369				cp 0 
1369				jr z, .foundemptyblock 
1369			 
1369				; if byte is not clear 
1369				;     then byte is offset to next block 
1369			 
1369				inc hl 
1369				ld a, (hl) ; get size 
1369			.nextblock:	inc hl 
1369					ld e, (hl) 
1369					inc hl 
1369					ld d, (hl) 
1369					ex de, hl 
1369			;	inc hl  ; move past the store space 
1369			;	inc hl  ; move past zero index  
1369			 
1369				; TODO detect no more space 
1369			 
1369				push hl 
1369				ld de, heap_end 
1369				call cmp16 
1369				pop hl 
1369				jr nc, .nospace 
1369			 
1369				jr .findblock 
1369			 
1369			.nospace: ld hl, 0 
1369				jp .exit 
1369			 
1369			 
1369			.foundemptyblock:	 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mme" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; TODO has block enough space if reusing??? 
1369			 
1369				;  
1369			 
1369			; see if this block has been previously used 
1369				inc hl 
1369				ld a, (hl) 
1369				dec hl 
1369				cp 0 
1369				jr z, .newblock 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meR" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; no reusing previously allocated block 
1369			 
1369			; is it smaller than previously used? 
1369				 
1369				inc hl    ; move to size 
1369				ld a, c 
1369				sub (hl)        ; we want c < (hl) 
1369				dec hl    ; move back to marker 
1369			        jr z, .findblock 
1369			 
1369				; update with the new size which should be lower 
1369			 
1369			        ;inc  hl   ; negate next move. move back to size  
1369			 
1369			.newblock: 
1369				; need to be at marker here 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meN" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			 
1369				ld a, c 
1369			 
1369				ld (free_list+3), a	 ; flag resume from last malloc  
1369				ld (free_list), hl    ; save out last location 
1369			 
1369			 
1369				;inc a     ; space for length byte 
1369				ld (hl), a     ; save block in use marker 
1369			 
1369				inc hl   ; move to space marker 
1369				ld (hl), a    ; save new space 
1369			 
1369				inc hl   ; move to start of allocated area 
1369				 
1369			;	push hl     ; save where we are - 1  
1369			 
1369			;	inc hl  ; move past zero index  
1369				; skip space to set down new marker 
1369			 
1369				; provide some extra space for now 
1369			 
1369				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1369				inc a 
1369				inc a 
1369			 
1369				push hl   ; save where we are in the node block 
1369			 
1369				call addatohl 
1369			 
1369				; write linked list point 
1369			 
1369				pop de     ; get our node position 
1369				ex de, hl 
1369			 
1369				ld (hl), e 
1369				inc hl 
1369				ld (hl), d 
1369			 
1369				inc hl 
1369			 
1369				; now at start of allocated data so save pointer 
1369			 
1369				push hl 
1369			 
1369				; jump to position of next node and setup empty header in DE 
1369			 
1369				ex de, hl 
1369			 
1369			;	inc hl ; move past end of block 
1369			 
1369				ld a, 0 
1369				ld (hl), a   ; empty marker 
1369				inc hl 
1369				ld (hl), a   ; size 
1369				inc hl  
1369				ld (hl), a   ; ptr 
1369				inc hl 
1369				ld (hl), a   ; ptr 
1369			 
1369			 
1369				pop hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmr" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			.exit: 
1369				pop af 
1369				pop bc 
1369				pop de  
1369				ret 
1369			 
1369			 
1369			 
1369			 
1369			free:  
1369				push hl 
1369				push af 
1369				; get address in hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "fre" 
1369						CALLMONITOR 
1369					endif 
1369				; data is at hl - move to block count 
1369				dec hl 
1369				dec hl    ; get past pointer 
1369				dec hl 
1369			 
1369				ld a, (hl)    ; need this for a validation check 
1369			 
1369				dec hl    ; move to block marker 
1369			 
1369				; now check that the block count and block marker are the same  
1369			        ; this checks that we are on a malloc node and not random memory 
1369			        ; OK a faint chance this could be a problem but rare - famous last words! 
1369			 
1369				ld c, a 
1369				ld a, (hl)    
1369			 
1369				cp c 
1369				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1369			 
1369				; yes good chance we are on a malloc node 
1369			 
1369				ld a, 0      
1369				ld (hl), a   ; mark as free 
1369			 
1369				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1369			 
1369			.freeignore:  
1369			 
1369				pop af 
1369				pop hl 
1369			 
1369				ret 
1369			 
1369			 
1369			 
1369			endif 
1369			 
1369			; eof 
# End of file firmware_memory.asm
1369			  
1369			; device C  
1369			if SOUND_ENABLE  
1369				include "firmware_sound.asm"  
1369			; Sound abstraction layer 
1369			 
1369			; support different sound chips through common interface 
1369			 
1369			SOUND_DEVICE_AY: equ 0 
1369			 
1369			SOUND_DEVICE: equ Device_A 
1369			 
1369			 
1369			 
1369			if SOUND_DEVICE_AY 
1369				include "firmware_sound_ay38910.asm" 
1369			else 
1369				include "firmware_sound_sn76489an.asm" 
1369			 
1369			; Device support for SN76489AN sound chip 
1369			 
1369			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1369			; http://danceswithferrets.org/geekblog/?p=93 
1369			; https://www.smspower.org/Development/SN76489 
1369			 
1369			; D0 [ 3] 
1369			; D1 [ 2] 
1369			; D2 [ 1] 
1369			; D3 [15] 
1369			; D4 [13] 
1369			; D5 [12] 
1369			; D6 [11] 
1369			; D7 [10] 
1369			; /WE [ 5] 
1369			; CLK [14] 
1369			; /OE [ 6] 
1369			; AUDIO [ 7] 
1369			; GND 8 
1369			; +5 16 
1369			; 
1369			 
1369			; Write sequence: 
1369			; CE low 
1369			; Data bus 
1369			; WE low then high 
1369			; 32 clock cycles / 8ns write time at 4mhz 
1369			; 
1369			; https://github.com/jblang/SN76489 
1369			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1369			; Tried: 
1369			; 
1369			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1369			; 
1369			; Connected WE to OR too 
1369			;  
1369			; That enabled the clock when required 
1369			; However still random bus corruption. Need further investigation 
1369			 
1369			 
1369			SOUND_LATCH: equ 10000000B 
1369			SOUND_DATA: equ 0B 
1369			SOUND_CH0:  equ 0B    ; Tone 
1369			SOUND_CH1: equ 0100000B        ; Tone 
1369			SOUND_CH2: equ 1000000B   ; Tone 
1369			SOUND_CH3: equ 1100000B    ; Noise 
1369			SOUND_VOL: equ 10000B 
1369			SOUND_TONE: equ 0B 
1369			 
1369			 
1369			sound_init: 
1369 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
136b cd 80 13			call note_send_byte 
136e 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1370 cd 80 13			call note_send_byte 
1373 cd 49 0a			call delay250ms 
1376 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
1378 cd 80 13			call note_send_byte 
137b cd 49 0a			call delay250ms 
137e c9				ret 
137f			 
137f			; Play a note 
137f			; h = note 
137f			; l = duration 
137f			; a = channel 
137f			 
137f			 
137f			;  frequ = clock / ( 2 x reg valu x 32 )  
137f			 
137f			note:  
137f				 
137f			 
137f c9				ret 
1380			 
1380			note_send_byte: 
1380				; byte in a 
1380			 
1380				; we high 
1380 d3 40			out (Device_B), a 
1382			;	ld a, 1 
1382			;	call aDelayInMS 
1382 00				nop  
1383 00				nop  
1384 00				nop  
1385 00				nop  
1386				; we low 
1386 d3 40			out (Device_B), a 
1388			;	ld a, 1 
1388			;	call aDelayInMS 
1388 00				nop  
1389 00				nop  
138a 00				nop  
138b 00				nop  
138c				; we high 
138c d3 40			out (Device_B), a 
138e			;	ld a, 1 
138e			;	call aDelayInMS 
138e 00				nop  
138f 00				nop  
1390 00				nop  
1391 00				nop  
1392			 
1392			 
1392 c9				ret 
1393			 
1393			;void SilenceAllChannels() 
1393			;{ 
1393			;  SendByte(0x9f); 
1393			;  SendByte(0xbf); 
1393			;  SendByte(0xdf); 
1393			;  SendByte(0xff); 
1393			;} 
1393			 
1393			 
1393			; eof 
1393			 
# End of file firmware_sound_sn76489an.asm
1393			endif 
1393			 
1393			 
1393			; Abstraction entry points 
1393			 
1393			; init  
1393			 
1393			; sound_init in specific hardware files 
1393			 
1393			; Play a note 
1393			; h = note 
1393			; l = duration 
1393			; a = channel 
1393			 
1393			;note:     
1393			;	ret 
1393			 
1393			 
1393			 
1393			 
1393			; eof 
1393			 
# End of file firmware_sound.asm
1393			endif  
1393			  
1393			include "firmware_diags.asm"  
1393			; Hardware diags menu 
1393			 
1393			 
1393			config: 
1393			 
1393 3e 00			ld a, 0 
1395 21 b9 13			ld hl, .configmn 
1398 cd 06 0b			call menu 
139b			 
139b fe 00			cp 0 
139d c8				ret z 
139e			 
139e fe 01			cp 1 
13a0 cc 7e 14			call z, .savetostore 
13a3			 
13a3 fe 02			cp 2 
13a5 cc 3f 14			call z, .selautoload 
13a8 fe 03			cp 3 
13aa cc 7c 14			call z, .selbank 
13ad fe 05			cp 5 
13af cc 59 15			call z, .debug_tog 
13b2 fe 06			cp 6 
13b4 cc 7f 15			call z, hardware_diags 
13b7			 
13b7 18 da			jr config 
13b9			 
13b9			.configmn: 
13b9 c7 13			dw .c3 
13bb e3 13			dw .c2 
13bd f8 13			dw .c2b 
13bf 0c 14			dw .c4 
13c1 15 14			dw .m4 
13c3 30 14			dw .c1 
13c5 00 00			dw 0 
13c7				 
13c7			 
13c7 .. 00		.c3: db "Add User Dictionary To File",0 
13e3 .. 00		.c2: db "Select Autoload File",0 
13f8 .. 00		.c2b: db "Select Storage Bank",0 
140c .. 00		.c4: db "Settings",0 
1415 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1430 .. 00		.c1: db "Hardware Diags",0 
143f			 
143f			; Select auto start 
143f			 
143f			.selautoload: 
143f			 
143f				 
143f				if STORAGE_SE 
143f			 
143f cd a3 14				call config_dir 
1442 21 1d ee			        ld hl, scratch 
1445 3e 00				ld a, 0 
1447 cd 06 0b				call menu 
144a			 
144a					; locate menu option 
144a			 
144a 21 1d ee				ld hl, scratch 
144d cd 2d 0a				call table_lookup 
1450			 
1450					; with the pointer to the menu it, the byte following the zero term is the file id 
1450			 
1450 3e 00				ld a, 0 
1452 01 32 00				ld bc, 50   ; max of bytes to look at 
1455 ed b1				cpir  
1457			 
1457 23					inc hl 
1458			 
1458 7e					ld a, (hl)   ; file id 
1459					 
1459				        ; save bank and file ids 
1459			 
1459 f5					push af 
145a			 
145a			; TODO need to save to block 0 on bank 1	 
145a			 
145a cd bd 03				call storage_get_block_0 
145d			 
145d f1					pop af 
145e			 
145e 32 86 f8				ld (store_page+STORE_0_FILERUN),a 
1461					 
1461					; save bank id 
1461			 
1461 3a 48 f8				ld a,(spi_device) 
1464 32 85 f8				ld (store_page+STORE_0_BANKRUN),a 
1467			 
1467					; enable auto run of store file 
1467			 
1467 3e 01				ld a, 1 
1469 32 83 f8				ld (store_page+STORE_0_AUTOFILE),a 
146c			 
146c					; save buffer 
146c			 
146c 21 00 00				ld hl, 0 
146f 11 62 f8				ld de, store_page 
1472 cd 71 03			call storage_write_block	 ; save update 
1475			  
1475			 
1475			 
1475			 
1475 21 1d ee				ld hl, scratch 
1478 cd 90 14				call config_fdir 
147b			 
147b			 
147b				endif 
147b c9				ret 
147c			 
147c			 
147c			 
147c			; Select storage bank 
147c			 
147c			.selbank: 
147c			 
147c				if STORAGE_SE 
147c				endif 
147c				 
147c c9				ret 
147d			 
147d			if STORAGE_SE 
147d			 
147d			.config_ldir:   
147d				; Load storage bank labels into menu array 
147d			 
147d				 
147d			 
147d			 
147d c9				ret 
147e			 
147e			 
147e			endif 
147e			 
147e			 
147e			; Save user words to storage 
147e			 
147e			.savetostore: 
147e			 
147e				if STORAGE_SE 
147e			 
147e cd a3 14				call config_dir 
1481 21 1d ee			        ld hl, scratch 
1484 3e 00				ld a, 0 
1486 cd 06 0b				call menu 
1489					 
1489 21 1d ee				ld hl, scratch 
148c cd 90 14				call config_fdir 
148f			 
148f			 
148f				endif 
148f			 
148f c9				ret 
1490			 
1490			 
1490			 
1490			if STORAGE_SE 
1490			 
1490			config_fdir: 
1490				; using the scratch dir go through and release the memory allocated for each string 
1490				 
1490 21 1d ee			ld hl, scratch 
1493 5e			.cfdir:	ld e,(hl) 
1494 23				inc hl 
1495 56				ld d,(hl) 
1496 23				inc hl 
1497			 
1497 eb				ex de, hl 
1498 cd 32 0d			call ishlzero 
149b c8				ret z     ; return on null pointer 
149c cd 9a 12			call free 
149f eb				ex de, hl 
14a0 18 f1			jr .cfdir 
14a2			 
14a2			 
14a2 c9				ret 
14a3			 
14a3			 
14a3			config_dir: 
14a3			 
14a3				; for the config menus that need to build a directory of storage call this routine 
14a3				; it will construct a menu in scratch to pass to menu 
14a3			 
14a3				; open storage device 
14a3			 
14a3				; execute DIR to build a list of files and their ids into scratch in menu format 
14a3				; once the menu has finished then will need to call config_fdir to release the strings 
14a3				 
14a3				; c = number items 
14a3			 
14a3				 
14a3 cd bd 03			call storage_get_block_0 
14a6			 
14a6 21 62 f8			ld hl, store_page     ; get current id count 
14a9 46				ld b, (hl) 
14aa 0e 00			ld c, 0    ; count of files   
14ac			 
14ac			 
14ac 21 1d ee			ld hl, scratch 
14af 22 5e f8			ld (store_tmp2), hl    ; location to poke strings 
14b2			 
14b2				; check for empty drive 
14b2			 
14b2 3e 00			ld a, 0 
14b4 b8				cp b 
14b5 ca 4f 15			jp z, .dirdone 
14b8			 
14b8				 
14b8					if DEBUG_FORTH_WORDS 
14b8						DMARK "Cdc" 
14b8 f5				push af  
14b9 3a cd 14			ld a, (.dmark)  
14bc 32 77 fb			ld (debug_mark),a  
14bf 3a ce 14			ld a, (.dmark+1)  
14c2 32 78 fb			ld (debug_mark+1),a  
14c5 3a cf 14			ld a, (.dmark+2)  
14c8 32 79 fb			ld (debug_mark+2),a  
14cb 18 03			jr .pastdmark  
14cd ..			.dmark: db "Cdc"  
14d0 f1			.pastdmark: pop af  
14d1			endm  
# End of macro DMARK
14d1						CALLMONITOR 
14d1 cd 97 16			call break_point_state  
14d4				endm  
# End of macro CALLMONITOR
14d4					endif 
14d4			 
14d4			 
14d4			.diritem:	 
14d4 c5				push bc 
14d5				; for each of the current ids do a search for them and if found push to stack 
14d5			 
14d5 21 40 00				ld hl, STORE_BLOCK_PHY 
14d8 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
14da 58					ld e,b 
14db			 
14db cd 2d 06				call storage_findnextid 
14de			 
14de			 
14de					; if found hl will be non zero 
14de			 
14de cd 32 0d				call ishlzero 
14e1 28 69				jr z, .dirnotfound 
14e3			 
14e3					; increase count 
14e3			 
14e3 c1					pop bc	 
14e4 0c					inc c 
14e5 c5					push bc 
14e6					 
14e6			 
14e6					; get file header and push the file name 
14e6			 
14e6 11 62 f8				ld de, store_page 
14e9 cd 0c 03				call storage_read_block 
14ec			 
14ec					; push file id to stack 
14ec				 
14ec 3a 62 f8				ld a, (store_page) 
14ef 26 00				ld h, 0 
14f1 6f					ld l, a 
14f2			 
14f2					;call forth_push_numhl 
14f2					; TODO store id 
14f2			 
14f2 e5					push hl 
14f3			 
14f3					; push extent count to stack  
14f3				 
14f3 21 65 f8				ld hl, store_page+3 
14f6			 
14f6					; get file name length 
14f6			 
14f6 cd 67 11				call strlenz   
14f9			 
14f9 23					inc hl   ; cover zero term 
14fa 23					inc hl  ; stick the id at the end of the area 
14fb			 
14fb e5					push hl 
14fc c1					pop bc    ; move length to bc 
14fd			 
14fd cd d0 11				call malloc 
1500			 
1500					; TODO save malloc area to scratch 
1500			 
1500 eb					ex de, hl 
1501 2a 5e f8				ld hl, (store_tmp2) 
1504 73					ld (hl), e 
1505 23					inc hl 
1506 72					ld (hl), d 
1507 23					inc hl 
1508 22 5e f8				ld (store_tmp2), hl 
150b			 
150b					 
150b			 
150b					;pop hl   ; get source 
150b			;		ex de, hl    ; swap aronund	 
150b			 
150b 21 65 f8				ld hl, store_page+3 
150e					if DEBUG_FORTH_WORDS 
150e						DMARK "CFd" 
150e f5				push af  
150f 3a 23 15			ld a, (.dmark)  
1512 32 77 fb			ld (debug_mark),a  
1515 3a 24 15			ld a, (.dmark+1)  
1518 32 78 fb			ld (debug_mark+1),a  
151b 3a 25 15			ld a, (.dmark+2)  
151e 32 79 fb			ld (debug_mark+2),a  
1521 18 03			jr .pastdmark  
1523 ..			.dmark: db "CFd"  
1526 f1			.pastdmark: pop af  
1527			endm  
# End of macro DMARK
1527						CALLMONITOR 
1527 cd 97 16			call break_point_state  
152a				endm  
# End of macro CALLMONITOR
152a					endif 
152a ed b0				ldir 
152c			 
152c					; de is past string, move back one and store id 
152c					 
152c 1b					dec de 
152d			 
152d					; store file id 
152d			 
152d e1					pop hl 
152e eb					ex de,hl 
152f 73					ld (hl), e 
1530			 
1530					if DEBUG_FORTH_WORDS 
1530						DMARK "Cdi" 
1530 f5				push af  
1531 3a 45 15			ld a, (.dmark)  
1534 32 77 fb			ld (debug_mark),a  
1537 3a 46 15			ld a, (.dmark+1)  
153a 32 78 fb			ld (debug_mark+1),a  
153d 3a 47 15			ld a, (.dmark+2)  
1540 32 79 fb			ld (debug_mark+2),a  
1543 18 03			jr .pastdmark  
1545 ..			.dmark: db "Cdi"  
1548 f1			.pastdmark: pop af  
1549			endm  
# End of macro DMARK
1549						CALLMONITOR 
1549 cd 97 16			call break_point_state  
154c				endm  
# End of macro CALLMONITOR
154c					endif 
154c					 
154c			.dirnotfound: 
154c c1					pop bc     
154d 10 85				djnz .diritem 
154f				 
154f			.dirdone:	 
154f			 
154f 3e 00				ld a, 0 
1551 2a 5e f8				ld hl, (store_tmp2) 
1554 77					ld (hl), a 
1555 23					inc hl 
1556 77					ld (hl), a 
1557 23					inc hl 
1558					; push a count of the dir items found 
1558			 
1558			;		ld h, 0 
1558			;		ld l, c 
1558			 
1558 c9				ret 
1559			 
1559			endif 
1559			 
1559			 
1559			; Settings 
1559			; Run  
1559			 
1559			 
1559			 
1559			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1559			;;hd_menu2:   db "        2: Editor",0   
1559			;hd_menu2:   db "        2: Editor       6: Menu",0   
1559			;hd_menu3:   db "        3: Storage",0 
1559			;hd_menu4:   db "0=quit  4: Debug",0 
1559			;hd_don:     db "ON",0 
1559			;hd_doff:     db "OFF",0 
1559			; 
1559			; 
1559			; 
1559			;hardware_diags_old:       
1559			; 
1559			;.diagmenu: 
1559			;	call clear_display 
1559			;	ld a, display_row_1 
1559			;	ld de, hd_menu1 
1559			;	call str_at_display 
1559			; 
1559			;	ld a, display_row_2 
1559			;	ld de, hd_menu2 
1559			;	call str_at_display 
1559			; 
1559			;	ld a, display_row_3 
1559			;	ld de, hd_menu3 
1559			;	call str_at_display 
1559			; 
1559			;	ld a,  display_row_4 
1559			;	ld de, hd_menu4 
1559			;	call str_at_display 
1559			; 
1559			;	; display debug state 
1559			; 
1559			;	ld de, hd_don 
1559			;	ld a, (os_view_disable) 
1559			;	cp 0 
1559			;	jr z, .distog 
1559			;	ld de, hd_doff 
1559			;.distog: ld a, display_row_4+17 
1559			;	call str_at_display 
1559			; 
1559			;	call update_display 
1559			; 
1559			;	call cin_wait 
1559			; 
1559			; 
1559			; 
1559			;	cp '4' 
1559			;	jr nz, .diagn1 
1559			; 
1559			;	; debug toggle 
1559			; 
1559			;	ld a, (os_view_disable) 
1559			;	ld b, '*' 
1559			;	cp 0 
1559			;	jr z, .debtog 
1559			;	ld b, 0 
1559			;.debtog:	 
1559			;	ld a,b 
1559			;	ld (os_view_disable),a 
1559			; 
1559			;.diagn1: cp '0' 
1559			;	 ret z 
1559			; 
1559			;;	cp '1' 
1559			;;       jp z, matrix	 
1559			;;   TODO keyboard matrix test 
1559			; 
1559			;	cp '2' 
1559			;	jp z, .diagedit 
1559			; 
1559			;;	cp '6' 
1559			;;	jp z, .menutest 
1559			;;if ENABLE_BASIC 
1559			;;	cp '6' 
1559			;;	jp z, basic 
1559			;;endif 
1559			 ; 
1559			;	jp .diagmenu 
1559			; 
1559			; 
1559			;	ret 
1559			 
1559			 
1559			.debug_tog: 
1559 21 a0 15			ld hl, .menudebug 
155c				 
155c 3a 0e ee			ld a, (os_view_disable) 
155f fe 2a			cp '*' 
1561 20 04			jr nz,.tdon  
1563 3e 01			ld a, 1 
1565 18 02			jr .tog1 
1567 3e 00		.tdon: ld a, 0 
1569			 
1569			.tog1: 
1569 cd 06 0b			call menu 
156c fe 00			cp 0 
156e c8				ret z 
156f fe 01			cp 1    ; disable debug 
1571 28 04			jr z, .dtog0 
1573 3e 2a			ld a, '*' 
1575 18 02			jr .dtogset 
1577 3e 00		.dtog0: ld a, 0 
1579 32 0e ee		.dtogset:  ld (os_view_disable), a 
157c c3 59 15			jp .debug_tog 
157f			 
157f			 
157f			hardware_diags:       
157f			 
157f			.diagm: 
157f 21 92 15			ld hl, .menuitems 
1582 3e 00			ld a, 0 
1584 cd 06 0b			call menu 
1587			 
1587 fe 00		         cp 0 
1589 c8				 ret z 
158a			 
158a fe 02			cp 2 
158c ca eb 15			jp z, .diagedit 
158f			 
158f			;	cp '6' 
158f			;	jp z, .menutest 
158f			;if ENABLE_BASIC 
158f			;	cp '6' 
158f			;	jp z, basic 
158f			;endif 
158f			  
158f c3 7f 15			jp .diagm 
1592			 
1592				 
1592 a6 15		.menuitems:   	dw .m1 
1594 b1 15				dw .m2 
1596 b8 15				dw .m3 
1598 c0 15				dw .m5 
159a c6 15				dw .m5a 
159c cf 15				dw .m5b 
159e 00 00				dw 0 
15a0			 
15a0			.menudebug: 
15a0 d8 15				dw .m6 
15a2 e1 15				dw .m7 
15a4 00 00				dw 0 
15a6			 
15a6 .. 00		.m1:   db "Key Matrix",0 
15b1 .. 00		.m2:   db "Editor",0 
15b8 .. 00		.m3:   db "Storage",0 
15c0 .. 00		.m5:   db "Sound",0 
15c6 .. 00		.m5a:  db "RAM Test",0 
15cf .. 00		.m5b:  db "LCD Test",0 
15d8			 
15d8 .. 00		.m6:   db "Debug ON",0 
15e1 .. 00		.m7:   db "Debug OFF",0 
15eb			 
15eb			; debug editor 
15eb			 
15eb			.diagedit: 
15eb			 
15eb 21 1d ee			ld hl, scratch 
15ee			;	ld bc, 250 
15ee			;	ldir 
15ee				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
15ee 3e 00			ld a, 0 
15f0 77				ld (hl), a 
15f1 23				inc hl 
15f2 77				ld (hl), a 
15f3 23				inc hl 
15f4 77				ld (hl), a 
15f5			 
15f5 cd d5 0a		        call clear_display 
15f8 cd f8 0a			call update_display 
15fb 3e 01			ld a, 1 
15fd 32 7d fb			ld (hardware_diag), a 
1600			.diloop: 
1600 3e 00			ld a, display_row_1 
1602 0e 00			ld c, 0 
1604 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1606 1e 28			ld e, 40 
1608			 
1608 21 1d ee			ld hl, scratch	 
160b cd 36 0d			call input_str 
160e			 
160e 3e 28			ld a, display_row_2 
1610 11 1d ee			ld de, scratch 
1613 cd e8 0a			call str_at_display 
1616 cd f8 0a			call update_display 
1619			 
1619 c3 00 16			jp .diloop 
161c			 
161c			 
161c			; pass word in hl 
161c			; a has display location 
161c			display_word_at: 
161c f5				push af 
161d e5				push hl 
161e 7c				ld a,h 
161f 21 22 f1			ld hl, os_word_scratch 
1622 cd 0a 10			call hexout 
1625 e1				pop hl 
1626 7d				ld a,l 
1627 21 24 f1			ld hl, os_word_scratch+2 
162a cd 0a 10			call hexout 
162d 21 26 f1			ld hl, os_word_scratch+4 
1630 3e 00			ld a,0 
1632 77				ld (hl),a 
1633 11 22 f1			ld de,os_word_scratch 
1636 f1				pop af 
1637 cd e8 0a				call str_at_display 
163a c9				ret 
163b			 
163b			display_ptr_state: 
163b			 
163b				; to restore afterwards 
163b			 
163b d5				push de 
163c c5				push bc 
163d e5				push hl 
163e f5				push af 
163f			 
163f				; for use in here 
163f			 
163f			;	push bc 
163f			;	push de 
163f			;	push hl 
163f			;	push af 
163f			 
163f cd d5 0a			call clear_display 
1642			 
1642 11 15 18			ld de, .ptrstate 
1645 3e 00			ld a, display_row_1 
1647 cd e8 0a			call str_at_display 
164a			 
164a				; display debug step 
164a			 
164a			 
164a 11 77 fb			ld de, debug_mark 
164d 3e 26			ld a, display_row_1+display_cols-2 
164f cd e8 0a			call str_at_display 
1652			 
1652				; display a 
1652 11 1f 18			ld de, .ptrcliptr 
1655 3e 28			ld a, display_row_2 
1657 cd e8 0a			call str_at_display 
165a			 
165a f1				pop af 
165b 2a 28 f8			ld hl,(cli_ptr) 
165e 3e 30			ld a, display_row_2+8 
1660 cd 1c 16			call display_word_at 
1663			 
1663			 
1663				; display hl 
1663			 
1663			 
1663 11 27 18			ld de, .ptrclioptr 
1666 3e 32			ld a, display_row_2+10 
1668 cd e8 0a			call str_at_display 
166b			; 
166b			;	pop hl 
166b 3e 35			ld a, display_row_2+13 
166d 2a 26 f8			ld hl,(cli_origptr) 
1670 cd 1c 16			call display_word_at 
1673			; 
1673			;	 
1673			;	; display de 
1673			 
1673			;	ld de, .regstatede 
1673			;	ld a, display_row_3 
1673			;	call str_at_display 
1673			 
1673			;	pop de 
1673			;	ld h,d 
1673			;	ld l, e 
1673			;	ld a, display_row_3+3 
1673			;	call display_word_at 
1673			 
1673			 
1673				; display bc 
1673			 
1673			;	ld de, .regstatebc 
1673			;	ld a, display_row_3+10 
1673			;	call str_at_display 
1673			 
1673			;	pop bc 
1673			;	ld h,b 
1673			;	ld l, c 
1673			;	ld a, display_row_3+13 
1673			;	call display_word_at 
1673			 
1673			 
1673				; display dsp 
1673			 
1673			;	ld de, .regstatedsp 
1673			;	ld a, display_row_4 
1673			;	call str_at_display 
1673			 
1673				 
1673			;	ld hl,(cli_data_sp) 
1673			;	ld a, display_row_4+4 
1673			;	call display_word_at 
1673			 
1673				; display rsp 
1673			 
1673 11 56 18			ld de, .regstatersp 
1676 3e 82			ld a, display_row_4+10 
1678 cd e8 0a			call str_at_display 
167b			 
167b				 
167b 2a 0e f8			ld hl,(cli_ret_sp) 
167e 3e 86			ld a, display_row_4+14 
1680 cd 1c 16			call display_word_at 
1683			 
1683 cd f8 0a			call update_display 
1686			 
1686 cd 55 0a			call delay1s 
1689 cd 55 0a			call delay1s 
168c cd 55 0a			call delay1s 
168f			 
168f			 
168f cd 9f 1b			call next_page_prompt 
1692			 
1692				; restore  
1692			 
1692 f1				pop af 
1693 e1				pop hl 
1694 c1				pop bc 
1695 d1				pop de 
1696 c9				ret 
1697			 
1697			break_point_state: 
1697 f5				push af 
1698			 
1698				; see if disabled 
1698			 
1698 3a 0e ee			ld a, (os_view_disable) 
169b fe 2a			cp '*' 
169d 20 02			jr nz, .bpsgo 
169f f1				pop af 
16a0 c9				ret 
16a1			 
16a1			.bpsgo: 
16a1 f1				pop af 
16a2 f5				push af 
16a3 22 0a ee			ld (os_view_hl), hl 
16a6 ed 53 08 ee		ld (os_view_de), de 
16aa ed 43 06 ee		ld (os_view_bc), bc 
16ae e5				push hl 
16af 6f				ld l, a 
16b0 26 00			ld h, 0 
16b2 22 0c ee			ld (os_view_af),hl 
16b5			 
16b5 21 bd fa				ld hl, display_fb0 
16b8 22 d8 f8				ld (display_fb_active), hl 
16bb e1				pop hl	 
16bc			 
16bc 3e 31			ld a, '1' 
16be fe 2a		.bps1:  cp '*' 
16c0 20 03			jr nz, .bps1b 
16c2 32 0e ee			ld (os_view_disable),a 
16c5 fe 31		.bps1b:  cp '1' 
16c7 20 14			jr nz, .bps2 
16c9			 
16c9				; display reg 
16c9			 
16c9				 
16c9			 
16c9 3a 0c ee			ld a, (os_view_af) 
16cc 2a 0a ee			ld hl, (os_view_hl) 
16cf ed 5b 08 ee		ld de, (os_view_de) 
16d3 ed 4b 06 ee		ld bc, (os_view_bc) 
16d7 cd 71 17			call display_reg_state 
16da c3 5d 17			jp .bpschk 
16dd			 
16dd fe 32		.bps2:  cp '2' 
16df 20 08			jr nz, .bps3 
16e1				 
16e1				; display hl 
16e1 2a 0a ee			ld hl, (os_view_hl) 
16e4 cd 5b 18			call display_dump_at_hl 
16e7			 
16e7 18 74			jr .bpschk 
16e9			 
16e9 fe 33		.bps3:  cp '3' 
16eb 20 08			jr nz, .bps4 
16ed			 
16ed			        ; display de 
16ed 2a 08 ee			ld hl, (os_view_de) 
16f0 cd 5b 18			call display_dump_at_hl 
16f3			 
16f3 18 68			jr .bpschk 
16f5 fe 34		.bps4:  cp '4' 
16f7 20 08			jr nz, .bps5 
16f9			 
16f9			        ; display bc 
16f9 2a 06 ee			ld hl, (os_view_bc) 
16fc cd 5b 18			call display_dump_at_hl 
16ff			 
16ff 18 5c			jr .bpschk 
1701 fe 35		.bps5:  cp '5' 
1703 20 08		        jr nz, .bps7 
1705			 
1705				; display cur ptr 
1705 2a 28 f8			ld hl, (cli_ptr) 
1708 cd 5b 18			call display_dump_at_hl 
170b			 
170b 18 50			jr .bpschk 
170d fe 36		.bps7:  cp '6' 
170f 20 08			jr nz, .bps8b 
1711				 
1711				; display cur orig ptr 
1711 2a 26 f8			ld hl, (cli_origptr) 
1714 cd 5b 18			call display_dump_at_hl 
1717 18 44			jr .bpschk 
1719 fe 37		.bps8b:  cp '7' 
171b 20 08			jr nz, .bps9 
171d				 
171d				; display dsp 
171d 2a 0a f8			ld hl, (cli_data_sp) 
1720 cd 5b 18			call display_dump_at_hl 
1723			 
1723 18 38			jr .bpschk 
1725 fe 39		.bps9:  cp '9' 
1727 20 05			jr nz, .bps8c 
1729				 
1729				; display SP 
1729			;	ld hl, sp 
1729 cd 5b 18			call display_dump_at_hl 
172c			 
172c 18 2f			jr .bpschk 
172e fe 38		.bps8c:  cp '8' 
1730 20 08			jr nz, .bps8d 
1732				 
1732				; display rsp 
1732 2a 0e f8			ld hl, (cli_ret_sp) 
1735 cd 5b 18			call display_dump_at_hl 
1738			 
1738 18 23			jr .bpschk 
173a fe 23		.bps8d:  cp '#'     ; access monitor sub system 
173c 20 05			jr nz, .bps8 
173e cd 95 19			call monitor 
1741			 
1741 18 1a			jr .bpschk 
1743 fe 30		.bps8:  cp '0' 
1745 20 16			jr nz, .bpschk 
1747			 
1747 21 1c fa				ld hl, display_fb1 
174a 22 d8 f8				ld (display_fb_active), hl 
174d cd f8 0a				call update_display 
1750			 
1750				;ld a, (os_view_af) 
1750 2a 0a ee			ld hl, (os_view_hl) 
1753 ed 5b 08 ee		ld de, (os_view_de) 
1757 ed 4b 06 ee		ld bc, (os_view_bc) 
175b f1				pop af 
175c c9				ret 
175d			 
175d			.bpschk:   
175d cd 55 0a			call delay1s 
1760 3e 9f		ld a,display_row_4 + display_cols - 1 
1762 11 9d 1b		        ld de, endprg 
1765 cd e8 0a			call str_at_display 
1768 cd f8 0a			call update_display 
176b cd 9e 68			call cin_wait 
176e			 
176e c3 be 16			jp .bps1 
1771			 
1771			 
1771			display_reg_state: 
1771			 
1771				; to restore afterwards 
1771			 
1771 d5				push de 
1772 c5				push bc 
1773 e5				push hl 
1774 f5				push af 
1775			 
1775				; for use in here 
1775			 
1775 c5				push bc 
1776 d5				push de 
1777 e5				push hl 
1778 f5				push af 
1779			 
1779 cd d5 0a			call clear_display 
177c			 
177c 11 31 18			ld de, .regstate 
177f 3e 00			ld a, display_row_1 
1781 cd e8 0a			call str_at_display 
1784			 
1784				; display debug step 
1784			 
1784			 
1784 11 77 fb			ld de, debug_mark 
1787 3e 25			ld a, display_row_1+display_cols-3 
1789 cd e8 0a			call str_at_display 
178c			 
178c				; display a 
178c 11 4d 18			ld de, .regstatea 
178f 3e 28			ld a, display_row_2 
1791 cd e8 0a			call str_at_display 
1794			 
1794 e1				pop hl 
1795			;	ld h,0 
1795			;	ld l, a 
1795 3e 2b			ld a, display_row_2+3 
1797 cd 1c 16			call display_word_at 
179a			 
179a			 
179a				; display hl 
179a			 
179a			 
179a 11 41 18			ld de, .regstatehl 
179d 3e 32			ld a, display_row_2+10 
179f cd e8 0a			call str_at_display 
17a2			 
17a2 e1				pop hl 
17a3 3e 35			ld a, display_row_2+13 
17a5 cd 1c 16			call display_word_at 
17a8			 
17a8				 
17a8				; display de 
17a8			 
17a8 11 45 18			ld de, .regstatede 
17ab 3e 50			ld a, display_row_3 
17ad cd e8 0a			call str_at_display 
17b0			 
17b0 e1				pop hl 
17b1			;	ld h,d 
17b1			;	ld l, e 
17b1 3e 53			ld a, display_row_3+3 
17b3 cd 1c 16			call display_word_at 
17b6			 
17b6			 
17b6				; display bc 
17b6			 
17b6 11 49 18			ld de, .regstatebc 
17b9 3e 5a			ld a, display_row_3+10 
17bb cd e8 0a			call str_at_display 
17be			 
17be e1				pop hl 
17bf			;	ld h,b 
17bf			;	ld l, c 
17bf 3e 5d			ld a, display_row_3+13 
17c1 cd 1c 16			call display_word_at 
17c4			 
17c4			 
17c4				; display dsp 
17c4			 
17c4 11 51 18			ld de, .regstatedsp 
17c7 3e 78			ld a, display_row_4 
17c9 cd e8 0a			call str_at_display 
17cc			 
17cc				 
17cc 2a 0a f8			ld hl,(cli_data_sp) 
17cf 3e 7c			ld a, display_row_4+4 
17d1 cd 1c 16			call display_word_at 
17d4			 
17d4				; display rsp 
17d4			 
17d4 11 56 18			ld de, .regstatersp 
17d7 3e 82			ld a, display_row_4+10 
17d9 cd e8 0a			call str_at_display 
17dc			 
17dc				 
17dc 2a 0e f8			ld hl,(cli_ret_sp) 
17df 3e 86			ld a, display_row_4+14 
17e1 cd 1c 16			call display_word_at 
17e4			 
17e4 cd f8 0a			call update_display 
17e7			 
17e7			;	call delay1s 
17e7			;	call delay1s 
17e7			;	call delay1s 
17e7			 
17e7			 
17e7			;	call next_page_prompt 
17e7			 
17e7				; restore  
17e7			 
17e7 f1				pop af 
17e8 e1				pop hl 
17e9 c1				pop bc 
17ea d1				pop de 
17eb c9				ret 
17ec			 
17ec .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1800 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1815 .. 00		.ptrstate:	db "Ptr State",0 
181f .. 00		.ptrcliptr:     db "cli_ptr",0 
1827 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1831 .. 00		.regstate:	db "Reg State (1/0)",0 
1841 .. 00		.regstatehl:	db "HL:",0 
1845 .. 00		.regstatede:	db "DE:",0 
1849 .. 00		.regstatebc:	db "BC:",0 
184d .. 00		.regstatea:	db "A :",0 
1851 .. 00		.regstatedsp:	db "DSP:",0 
1856 .. 00		.regstatersp:	db "RSP:",0 
185b			 
185b			display_dump_at_hl: 
185b e5				push hl 
185c d5				push de 
185d c5				push bc 
185e f5				push af 
185f			 
185f 22 40 f1			ld (os_cur_ptr),hl	 
1862 cd d5 0a			call clear_display 
1865 cd a7 1a			call dumpcont 
1868			;	call delay1s 
1868			;	call next_page_prompt 
1868			 
1868			 
1868 f1				pop af 
1869 c1				pop bc 
186a d1				pop de 
186b e1				pop hl 
186c c9				ret 
186d			 
186d			;if ENABLE_BASIC 
186d			;	include "nascombasic.asm" 
186d			;	basic: 
186d			;	include "forth/FORTH.ASM" 
186d			;endif 
186d			 
186d			; eof 
186d			 
186d			 
# End of file firmware_diags.asm
186d			  
186d			  
186d			  
186d			  
186d			; eof  
186d			  
# End of file firmware.asm
186d			 
186d			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
186d			;if BASE_KEV  
186d			;baseram: equ 08000h 
186d			;endif 
186d			 
186d			;if BASE_SC114 
186d			;baseram:     equ    endofcode 
186d			;endif 
186d			 
186d			 
186d			; start system 
186d			 
186d			coldstart: 
186d				; set sp 
186d				; di/ei 
186d			 
186d f3				di 
186e 31 fd ff			ld sp, tos 
1871			;	ei 
1871			 
1871			 
1871				; disable breakpoint by default 
1871			 
1871 3e 2a			ld a,'*' 
1873 32 0e ee			ld (os_view_disable),a 
1876			 
1876				; init hardware 
1876			 
1876				; init keyboard and screen hardware 
1876			 
1876 cd 03 00			call hardware_init 
1879			 
1879			 
1879				; detect if any keys are held down to enable breakpoints at start up 
1879			 
1879 cd af 68			call cin  
187c fe 00			cp 0 
187e 28 03			jr z, .nokeys 
1880			 
1880				;call hardware_diags 
1880 cd 93 13			call config 
1883			 
1883			;	ld de, .bpen 
1883			;	ld a, display_row_4 
1883			;	call str_at_display 
1883			;	call update_display 
1883			; 
1883			;	ld a,0 
1883			;	ld (os_view_disable),a 
1883			; 
1883			;.bpwait: 
1883			;	call cin 
1883			;	cp 0 
1883			;	jr z, .bpwait 
1883			;	jr .nokeys 
1883			; 
1883			; 
1883			;.bpen:  db "Break points enabled!",0 
1883			 
1883			 
1883			 
1883			 
1883			 
1883			 
1883			.nokeys: 
1883			 
1883			 
1883				 
1883			 
1883			;jp  testkey 
1883			 
1883			;call storage_get_block_0 
1883			; 
1883			;ld hl, 0 
1883			;ld de, store_page 
1883			;call storage_read_block 
1883			 
1883				 
1883			;ld hl, 10 
1883			;ld de, store_page 
1883			;call storage_read_block 
1883			 
1883			 
1883			 
1883			 
1883			 
1883			;stop:	nop 
1883			;	jp stop 
1883			 
1883			 
1883			 
1883			main: 
1883 cd d5 0a			call clear_display 
1886 cd f8 0a			call update_display 
1889			 
1889			 
1889			 
1889			;	call testlcd 
1889			 
1889			 
1889			 
1889 cd 65 1f			call forth_init 
188c			 
188c			 
188c			warmstart: 
188c cd 3b 1f			call forth_warmstart 
188f			 
188f				; run startup word load 
188f			        ; TODO prevent this running at warmstart after crash  
188f			 
188f				if STARTUP_ENABLE 
188f cd 1b 62				call forth_startup 
1892			 
1892					if STORAGE_SE 
1892 cd fa 64					call forth_autoload 
1895					endif 
1895			 
1895				endif 
1895			 
1895				; show free memory after boot 
1895 11 2f 19			ld de, freeram 
1898 3e 00			ld a, display_row_1 
189a cd e8 0a			call str_at_display 
189d			 
189d			; Or use heap_size word???? 
189d 21 03 ee			ld hl, heap_end 
18a0 11 0e 80			ld de, heap_start 
18a3 ed 52			sbc hl, de 
18a5 e5				push hl 
18a6 7c				ld a,h	         	 
18a7 21 22 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18aa cd 0a 10			call hexout 
18ad e1			   	pop hl 
18ae			 
18ae 7d				ld a,l 
18af 21 24 f1			ld hl, os_word_scratch+2 
18b2 cd 0a 10			call hexout 
18b5 21 26 f1			ld hl, os_word_scratch+4 
18b8 3e 00			ld a, 0 
18ba 77				ld (hl),a 
18bb 11 22 f1			ld de, os_word_scratch 
18be 3e 0d			ld a, display_row_1 + 13 
18c0 cd e8 0a			call str_at_display 
18c3 cd f8 0a			call update_display 
18c6			 
18c6			 
18c6				;call demo 
18c6			 
18c6			 
18c6				; init scratch input area for cli commands 
18c6			 
18c6 21 44 f1			ld hl, os_cli_cmd 
18c9 3e 00			ld a,0 
18cb 77				ld (hl),a 
18cc 23				inc hl 
18cd 77				ld (hl),a 
18ce			 
18ce 3e 00			ld a,0 
18d0 32 43 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18d3			 
18d3 32 40 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18d6 32 41 f1			ld (os_cur_ptr+1),a	 
18d9			 
18d9 32 22 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18dc 32 23 f1			ld (os_word_scratch+1),a	 
18df				 
18df			 
18df				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18df 21 44 f1			ld hl, os_cli_cmd 
18e2			 
18e2 3e 00			ld a, 0		 ; init cli input 
18e4 77				ld (hl), a 
18e5 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18e7			cli: 
18e7				; show cli prompt 
18e7				;push af 
18e7				;ld a, 0 
18e7				;ld de, prompt 
18e7				;call str_at_display 
18e7			 
18e7				;call update_display 
18e7				;pop af 
18e7				;inc a 
18e7				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18e7 0e 00			ld c, 0 
18e9 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18eb 1e 28			ld e, 40 
18ed			 
18ed 21 44 f1			ld hl, os_cli_cmd 
18f0			 
18f0				STACKFRAME OFF $fefe $9f9f 
18f0				if DEBUG_STACK_IMB 
18f0					if OFF 
18f0						exx 
18f0						ld de, $fefe 
18f0						ld a, d 
18f0						ld hl, curframe 
18f0						call hexout 
18f0						ld a, e 
18f0						ld hl, curframe+2 
18f0						call hexout 
18f0						ld hl, $fefe 
18f0						push hl 
18f0						ld hl, $9f9f 
18f0						push hl 
18f0						exx 
18f0					endif 
18f0				endif 
18f0			endm 
# End of macro STACKFRAME
18f0			 
18f0 cd 36 0d			call input_str 
18f3			 
18f3				STACKFRAMECHK OFF $fefe $9f9f 
18f3				if DEBUG_STACK_IMB 
18f3					if OFF 
18f3						exx 
18f3						ld hl, $9f9f 
18f3						pop de   ; $9f9f 
18f3						call cmp16 
18f3						jr nz, .spnosame 
18f3						ld hl, $fefe 
18f3						pop de   ; $fefe 
18f3						call cmp16 
18f3						jr z, .spfrsame 
18f3						.spnosame: call showsperror 
18f3						.spfrsame: nop 
18f3						exx 
18f3					endif 
18f3				endif 
18f3			endm 
# End of macro STACKFRAMECHK
18f3			 
18f3				; copy input to last command 
18f3			 
18f3 21 44 f1			ld hl, os_cli_cmd 
18f6 11 43 f2			ld de, os_last_cmd 
18f9 01 ff 00			ld bc, 255 
18fc ed b0			ldir 
18fe			 
18fe				; wipe current buffer 
18fe			 
18fe			;	ld a, 0 
18fe			;	ld hl, os_cli_cmd 
18fe			;	ld de, os_cli_cmd+1 
18fe			;	ld bc, 254 
18fe			;	ldir 
18fe				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18fe			;	call strcpy 
18fe			;	ld a, 0 
18fe			;	ld (hl), a 
18fe			;	inc hl 
18fe			;	ld (hl), a 
18fe			;	inc hl 
18fe			;	ld (hl), a 
18fe			 
18fe				; switch frame buffer to program  
18fe			 
18fe 21 1c fa				ld hl, display_fb1 
1901 22 d8 f8				ld (display_fb_active), hl 
1904			 
1904			;	nop 
1904				STACKFRAME ON $fbfe $8f9f 
1904				if DEBUG_STACK_IMB 
1904					if ON 
1904						exx 
1904						ld de, $fbfe 
1904						ld a, d 
1904						ld hl, curframe 
1904						call hexout 
1904						ld a, e 
1904						ld hl, curframe+2 
1904						call hexout 
1904						ld hl, $fbfe 
1904						push hl 
1904						ld hl, $8f9f 
1904						push hl 
1904						exx 
1904					endif 
1904				endif 
1904			endm 
# End of macro STACKFRAME
1904				; first time into the parser so pass over the current scratch pad 
1904 21 44 f1			ld hl,os_cli_cmd 
1907				; tokenise the entered statement(s) in HL 
1907 cd de 1f			call forthparse 
190a			        ; exec forth statements in top of return stack 
190a cd 1e 20			call forthexec 
190d				;call forthexec_cleanup 
190d			;	call parsenext 
190d			 
190d				STACKFRAMECHK ON $fbfe $8f9f 
190d				if DEBUG_STACK_IMB 
190d					if ON 
190d						exx 
190d						ld hl, $8f9f 
190d						pop de   ; $8f9f 
190d						call cmp16 
190d						jr nz, .spnosame 
190d						ld hl, $fbfe 
190d						pop de   ; $fbfe 
190d						call cmp16 
190d						jr z, .spfrsame 
190d						.spnosame: call showsperror 
190d						.spfrsame: nop 
190d						exx 
190d					endif 
190d				endif 
190d			endm 
# End of macro STACKFRAMECHK
190d				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
190d			 
190d 3e 78			ld a, display_row_4 
190f 11 41 19			ld de, endprog 
1912			 
1912 cd f8 0a			call update_display		 
1915			 
1915 cd 9f 1b			call next_page_prompt 
1918			 
1918				; switch frame buffer to cli 
1918			 
1918 21 bd fa				ld hl, display_fb0 
191b 22 d8 f8				ld (display_fb_active), hl 
191e			 
191e			 
191e cd d5 0a		        call clear_display 
1921 cd f8 0a			call update_display		 
1924			 
1924 21 44 f1			ld hl, os_cli_cmd 
1927			 
1927 3e 00			ld a, 0		 ; init cli input 
1929 77				ld (hl), a 
192a			 
192a				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
192a			 
192a				; now on last line 
192a			 
192a				; TODO scroll screen up 
192a			 
192a				; TODO instead just clear screen and place at top of screen 
192a			 
192a			;	ld a, 0 
192a			;	ld (f_cursor_ptr),a 
192a			 
192a				;call clear_display 
192a				;call update_display 
192a			 
192a				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
192a 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
192c c3 e7 18			jp cli 
192f			 
192f .. 00		freeram: db "Free bytes: $",0 
193d ..			asc: db "1A2F" 
1941 .. 00		endprog: db "End prog...",0 
194d			 
194d			testenter2:   
194d 21 4f ee			ld hl,scratch+50 
1950 22 40 f1			ld (os_cur_ptr),hl 
1953 c3 e7 18			jp cli 
1956			 
1956			testenter:  
1956			 
1956 21 3d 19			ld hl,asc 
1959			;	ld a,(hl) 
1959			;	call nibble2val 
1959 cd 60 10			call get_byte 
195c			 
195c			 
195c			;	ld a,(hl) 
195c			;	call atohex 
195c			 
195c			;	call fourehexhl 
195c 32 4f ee			ld (scratch+50),a 
195f			 
195f			 
195f			 
195f 21 3f 19			ld hl,asc+2 
1962			;	ld a, (hl) 
1962			;	call nibble2val 
1962 cd 60 10			call get_byte 
1965			 
1965			;	call fourehexhl 
1965 32 51 ee			ld (scratch+52),a 
1968				 
1968 21 4f ee			ld hl,scratch+50 
196b 22 40 f1			ld (os_cur_ptr),hl 
196e c3 e7 18			jp cli 
1971			 
1971			enter:	 
1971 3a 21 ee			ld a,(scratch+4) 
1974 fe 00			cp 0 
1976 28 0c			jr z, .entercont 
1978				; no, not a null term line so has an address to work out.... 
1978			 
1978 21 1f ee			ld hl,scratch+2 
197b cd c0 10			call get_word_hl 
197e			 
197e 22 40 f1			ld (os_cur_ptr),hl	 
1981 c3 e7 18			jp cli 
1984			 
1984			 
1984			.entercont:  
1984			 
1984 21 1f ee			ld hl, scratch+2 
1987 cd 60 10			call get_byte 
198a			 
198a 2a 40 f1		   	ld hl,(os_cur_ptr) 
198d 77					ld (hl),a 
198e 23					inc hl 
198f 22 40 f1				ld (os_cur_ptr),hl 
1992				 
1992			; get byte  
1992			 
1992			 
1992 c3 e7 18			jp cli 
1995			 
1995			 
1995			; basic monitor support 
1995			 
1995			monitor: 
1995				;  
1995 cd d5 0a			call clear_display 
1998 3e 00			ld a, 0 
199a 11 e2 19			ld de, .monprompt 
199d cd e8 0a			call str_at_display 
19a0 cd f8 0a			call update_display 
19a3			 
19a3				; get a monitor command 
19a3			 
19a3 0e 00			ld c, 0     ; entry at top left 
19a5 16 64			ld d, 100   ; max buffer size 
19a7 1e 0f			ld e, 15    ; input scroll area 
19a9 3e 00			ld a, 0     ; init string 
19ab 21 1b f0			ld hl, os_input 
19ae 77				ld (hl), a 
19af 23				inc hl 
19b0 77				ld (hl), a 
19b1 21 1b f0			ld hl, os_input 
19b4 3e 01			ld a, 1     ; init string 
19b6 cd 36 0d			call input_str 
19b9			 
19b9 cd d5 0a		        call clear_display 
19bc cd f8 0a			call update_display		 
19bf			 
19bf 3a 1b f0			ld a, (os_input) 
19c2 cd 5e 11			call toUpper 
19c5 fe 48		        cp 'H' 
19c7 28 6f		        jr z, .monhelp 
19c9 fe 44			cp 'D'		; dump 
19cb ca 59 1a			jp z, .mondump	 
19ce fe 43			cp 'C'		; dump 
19d0 ca 73 1a			jp z, .moncdump	 
19d3 fe 4d			cp 'M'		; dump 
19d5 ca e4 19			jp z, .moneditstart 
19d8 fe 55			cp 'U'		; dump 
19da 28 14			jr z, .monedit	 
19dc fe 51			cp 'Q'		; dump 
19de c8				ret z	 
19df			 
19df			 
19df				; TODO "S" to access symbol by name and not need the address 
19df				; TODO "F" to find a string in memory 
19df			 
19df c3 95 19			jp monitor 
19e2			 
19e2 .. 00		.monprompt: db ">", 0 
19e4			 
19e4			.moneditstart: 
19e4				; get starting address 
19e4			 
19e4 21 1d f0			ld hl,os_input+2 
19e7 cd c0 10			call get_word_hl 
19ea			 
19ea 22 40 f1			ld (os_cur_ptr),hl	 
19ed			 
19ed c3 95 19			jp monitor 
19f0			 
19f0			.monedit: 
19f0				; get byte to load 
19f0			 
19f0 21 1d f0			ld hl,os_input+2 
19f3 cd 60 10			call get_byte 
19f6			 
19f6				; get address to update 
19f6 2a 40 f1			ld hl, (os_cur_ptr) 
19f9			 
19f9				; update byte 
19f9			 
19f9 77				ld (hl), a 
19fa			 
19fa				; move to next address and save it 
19fa			 
19fa 23				inc hl 
19fb 22 40 f1			ld (os_cur_ptr),hl	 
19fe			 
19fe c3 95 19			jp monitor 
1a01			 
1a01			 
1a01 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a15 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a31 .. 00		.monhelptext3:  db "Q-Quit",0 
1a38			        
1a38			.monhelp: 
1a38 3e 00			ld a, display_row_1 
1a3a 11 01 1a		        ld de, .monhelptext1 
1a3d			 
1a3d cd e8 0a			call str_at_display 
1a40 3e 28			ld a, display_row_2 
1a42 11 15 1a		        ld de, .monhelptext2 
1a45					 
1a45 cd e8 0a			call str_at_display 
1a48 3e 50			ld a, display_row_3 
1a4a 11 31 1a		        ld de, .monhelptext3 
1a4d					 
1a4d cd e8 0a			call str_at_display 
1a50 cd f8 0a			call update_display		 
1a53			 
1a53 cd 9f 1b			call next_page_prompt 
1a56 c3 95 19			jp monitor 
1a59			 
1a59			.mondump:    
1a59 21 1d f0			ld hl,os_input+2 
1a5c cd c0 10			call get_word_hl 
1a5f			 
1a5f 22 40 f1			ld (os_cur_ptr),hl	 
1a62 cd a7 1a			call dumpcont 
1a65 3e 78			ld a, display_row_4 
1a67 11 41 19			ld de, endprog 
1a6a			 
1a6a cd f8 0a			call update_display		 
1a6d			 
1a6d cd 9f 1b			call next_page_prompt 
1a70 c3 95 19			jp monitor 
1a73			.moncdump: 
1a73 cd a7 1a			call dumpcont 
1a76 3e 78			ld a, display_row_4 
1a78 11 41 19			ld de, endprog 
1a7b			 
1a7b cd f8 0a			call update_display		 
1a7e			 
1a7e cd 9f 1b			call next_page_prompt 
1a81 c3 95 19			jp monitor 
1a84			 
1a84			 
1a84			; TODO symbol access  
1a84			 
1a84			.symbols:     ;; A list of symbols that can be called up  
1a84 bd fa			dw display_fb0 
1a86 .. 00			db "fb0",0  
1a8a 62 f8		     	dw store_page 
1a8c .. 00			db "store_page",0 
1a97			 
1a97			 
1a97			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a97			 
1a97 3a 1e ee			ld a,(scratch+1) 
1a9a fe 00			cp 0 
1a9c 28 09			jr z, dumpcont 
1a9e			 
1a9e				; no, not a null term line so has an address to work out.... 
1a9e			 
1a9e 21 1f ee			ld hl,scratch+2 
1aa1 cd c0 10			call get_word_hl 
1aa4			 
1aa4 22 40 f1			ld (os_cur_ptr),hl	 
1aa7			 
1aa7			 
1aa7			 
1aa7			dumpcont: 
1aa7			 
1aa7				; dump bytes at ptr 
1aa7			 
1aa7			 
1aa7 3e 00			ld a, display_row_1 
1aa9 2a d8 f8			ld hl, (display_fb_active) 
1aac cd 09 0d			call addatohl 
1aaf cd d7 1a			call .dumpbyterow 
1ab2			 
1ab2 3e 28			ld a, display_row_2 
1ab4 2a d8 f8			ld hl, (display_fb_active) 
1ab7 cd 09 0d			call addatohl 
1aba cd d7 1a			call .dumpbyterow 
1abd			 
1abd			 
1abd 3e 50			ld a, display_row_3 
1abf 2a d8 f8			ld hl, (display_fb_active) 
1ac2 cd 09 0d			call addatohl 
1ac5 cd d7 1a			call .dumpbyterow 
1ac8			 
1ac8 3e 78			ld a, display_row_4 
1aca 2a d8 f8			ld hl, (display_fb_active) 
1acd cd 09 0d			call addatohl 
1ad0 cd d7 1a			call .dumpbyterow 
1ad3			 
1ad3 cd f8 0a			call update_display 
1ad6			;		jp cli 
1ad6 c9				ret 
1ad7			 
1ad7			.dumpbyterow: 
1ad7			 
1ad7				;push af 
1ad7			 
1ad7 e5				push hl 
1ad8			 
1ad8				; calc where to poke the ascii 
1ad8			if display_cols == 20 
1ad8				ld a, 16 
1ad8			else 
1ad8 3e 1f			ld a, 31 
1ada			endif 
1ada			 
1ada cd 09 0d			call addatohl 
1add 22 22 f1			ld (os_word_scratch),hl  		; save pos for later 
1ae0			 
1ae0			 
1ae0			; display decoding address 
1ae0 2a 40 f1		   	ld hl,(os_cur_ptr) 
1ae3			 
1ae3 7c				ld a,h 
1ae4 e1				pop hl 
1ae5 e5				push hl 
1ae6			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ae6 cd 0a 10			call hexout 
1ae9 2a 40 f1		   	ld hl,(os_cur_ptr) 
1aec			 
1aec 7d				ld a,l 
1aed e1				pop hl 
1aee 23				inc hl 
1aef 23				inc hl 
1af0 e5				push hl 
1af1			;	ld hl, os_word_scratch+2 
1af1 cd 0a 10			call hexout 
1af4 e1				pop hl 
1af5 23				inc hl 
1af6 23				inc hl 
1af7				;ld hl, os_word_scratch+4 
1af7 3e 3a			ld a, ':' 
1af9 77				ld (hl),a 
1afa 23				inc hl 
1afb				;ld a, 0 
1afb				;ld (hl),a 
1afb				;ld de, os_word_scratch 
1afb				;pop af 
1afb				;push af 
1afb			;		ld a, display_row_2 
1afb			;		call str_at_display 
1afb			;		call update_display 
1afb			 
1afb			 
1afb			;pop af 
1afb			;	add 5 
1afb			 
1afb			if display_cols == 20 
1afb				ld b, 4 
1afb			else 
1afb 06 08			ld b, 8 
1afd			endif	 
1afd			 
1afd			.dumpbyte: 
1afd c5				push bc 
1afe e5				push hl 
1aff			 
1aff			 
1aff 2a 40 f1		   	ld hl,(os_cur_ptr) 
1b02 7e					ld a,(hl) 
1b03			 
1b03					; poke the ascii to display 
1b03 2a 22 f1				ld hl,(os_word_scratch) 
1b06 77					ld (hl),a 
1b07 23					inc hl 
1b08 22 22 f1				ld (os_word_scratch),hl 
1b0b			 
1b0b					 
1b0b			 
1b0b			 
1b0b e1					pop hl 
1b0c e5					push hl 
1b0d			 
1b0d cd 0a 10				call hexout 
1b10			 
1b10					 
1b10 2a 40 f1		   	ld hl,(os_cur_ptr) 
1b13 23				inc hl 
1b14 22 40 f1		   	ld (os_cur_ptr),hl 
1b17			 
1b17 e1					pop hl 
1b18 23					inc hl 
1b19 23					inc hl 
1b1a 23					inc hl 
1b1b			 
1b1b			 
1b1b			 
1b1b					;ld a,0 
1b1b					;ld (os_word_scratch+2),a 
1b1b					;pop af 
1b1b					;push af 
1b1b			 
1b1b					;ld de, os_word_scratch 
1b1b					;call str_at_display 
1b1b			;		call update_display 
1b1b			;		pop af 
1b1b c1					pop bc 
1b1c c6 03				add 3 
1b1e 10 dd			djnz .dumpbyte 
1b20			 
1b20				 
1b20			 
1b20 c9				ret 
1b21			 
1b21			jump:	 
1b21			 
1b21 21 1f ee			ld hl,scratch+2 
1b24 cd c0 10			call get_word_hl 
1b27				;ld hl,(scratch+2) 
1b27				;call fourehexhl 
1b27			 
1b27 22 40 f1			ld (os_cur_ptr),hl	 
1b2a			 
1b2a e9				jp (hl) 
1b2b			 
1b2b			 
1b2b			 
1b2b			; TODO implement a basic monitor mode to start with 
1b2b			 
1b2b			 
1b2b			 
1b2b			 
1b2b			 
1b2b			 
1b2b			 
1b2b			 
1b2b			 
1b2b			; testing and demo code during development 
1b2b			 
1b2b			 
1b2b .. 00		str1: db "Enter some text...",0 
1b3e .. 00		clear: db "                    ",0 
1b53			 
1b53			demo: 
1b53			 
1b53			 
1b53			 
1b53			;	call update_display 
1b53			 
1b53				; init scratch input area for testing 
1b53 21 1d ee			ld hl, scratch	 
1b56 3e 00			ld a,0 
1b58 77				ld (hl),a 
1b59			 
1b59			 
1b59 3e 28		            LD   A, display_row_2 
1b5b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b5b 11 2b 1b		            LD   DE, str1 
1b5e cd e8 0a			call str_at_display 
1b61			 
1b61			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b61			cloop:	 
1b61 3e 50		            LD   A, display_row_3 
1b63			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b63 11 3e 1b		            LD   DE, clear 
1b66			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b66 cd e8 0a				call str_at_display 
1b69 3e 78			ld a, display_row_4 
1b6b 11 9b 1b			ld de, prompt 
1b6e			 
1b6e cd e8 0a				call str_at_display 
1b71 cd f8 0a			call update_display 
1b74			 
1b74 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b76 16 0a			ld d, 10 
1b78 21 1d ee			ld hl, scratch	 
1b7b cd 36 0d			call input_str 
1b7e			 
1b7e			;	call clear_display 
1b7e			;'	call update_display 
1b7e			 
1b7e 3e 00		            LD   A, display_row_1 
1b80			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b80 11 3e 1b		            LD   DE, clear 
1b83 cd e8 0a				call str_at_display 
1b86			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b86 3e 00		            LD   A, display_row_1 
1b88			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b88 11 1d ee		            LD   DE, scratch 
1b8b			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b8b cd e8 0a				call str_at_display 
1b8e cd f8 0a			call update_display 
1b91			 
1b91 3e 00				ld a,0 
1b93 21 1d ee			ld hl, scratch 
1b96 77				ld (hl),a 
1b97			 
1b97 00				nop 
1b98 c3 61 1b			jp cloop 
1b9b			 
1b9b			 
1b9b			 
1b9b			; OS Prompt 
1b9b			 
1b9b .. 00		prompt: db ">",0 
1b9d .. 00		endprg: db "?",0 
1b9f			 
1b9f			 
1b9f			; handy next page prompt 
1b9f			next_page_prompt: 
1b9f e5				push hl 
1ba0 d5				push de 
1ba1 f5				push af 
1ba2 c5				push bc 
1ba3			 
1ba3 3e 9f			ld a,display_row_4 + display_cols - 1 
1ba5 11 9d 1b		        ld de, endprg 
1ba8 cd e8 0a			call str_at_display 
1bab cd f8 0a			call update_display 
1bae cd 9e 68			call cin_wait 
1bb1 c1				pop bc 
1bb2 f1				pop af 
1bb3 d1				pop de 
1bb4 e1				pop hl 
1bb5			 
1bb5			 
1bb5 c9				ret 
1bb6			 
1bb6			 
1bb6			; forth parser 
1bb6			 
1bb6			; My forth kernel 
1bb6			include "forth_kernel.asm" 
1bb6			; 
1bb6			; kernel to the forth OS 
1bb6			 
1bb6			DS_TYPE_STR: equ 1     ; string type 
1bb6			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1bb6			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1bb6			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1bb6			 
1bb6			FORTH_PARSEV1: equ 0 
1bb6			FORTH_PARSEV2: equ 0 
1bb6			FORTH_PARSEV3: equ 0 
1bb6			FORTH_PARSEV4: equ 0 
1bb6			FORTH_PARSEV5: equ 1 
1bb6			 
1bb6			;if FORTH_PARSEV5 
1bb6			;	FORTH_END_BUFFER: equ 0 
1bb6			;else 
1bb6			FORTH_END_BUFFER: equ 127 
1bb6			;endif 
1bb6			 
1bb6			FORTH_TRUE: equ 1 
1bb6			FORTH_FALSE: equ 0 
1bb6			 
1bb6			if FORTH_PARSEV4 
1bb6			include "forth_stackops.asm" 
1bb6			endif 
1bb6			 
1bb6			if FORTH_PARSEV5 
1bb6			include "forth_stackopsv5.asm" 
1bb6			 
1bb6			; Stack operations for v5 parser on wards 
1bb6			; * DATA stack 
1bb6			; * LOOP stack 
1bb6			; * RETURN stack 
1bb6			 
1bb6			 
1bb6			 
1bb6			FORTH_CHK_DSP_UNDER: macro 
1bb6				push hl 
1bb6				push de 
1bb6				ld hl,(cli_data_sp) 
1bb6				ld de, cli_data_stack 
1bb6				call cmp16 
1bb6				jp c, fault_dsp_under 
1bb6				pop de 
1bb6				pop hl 
1bb6				endm 
1bb6			 
1bb6			 
1bb6			FORTH_CHK_RSP_UNDER: macro 
1bb6				push hl 
1bb6				push de 
1bb6				ld hl,(cli_ret_sp) 
1bb6				ld de, cli_ret_stack 
1bb6				call cmp16 
1bb6				jp c, fault_rsp_under 
1bb6				pop de 
1bb6				pop hl 
1bb6				endm 
1bb6			 
1bb6			FORTH_CHK_LOOP_UNDER: macro 
1bb6				push hl 
1bb6				push de 
1bb6				ld hl,(cli_loop_sp) 
1bb6				ld de, cli_loop_stack 
1bb6				call cmp16 
1bb6				jp c, fault_loop_under 
1bb6				pop de 
1bb6				pop hl 
1bb6				endm 
1bb6			 
1bb6			FORTH_ERR_TOS_NOTSTR: macro 
1bb6				; TOSO might need more for checks when used 
1bb6				push af 
1bb6				ld a,(hl) 
1bb6				cp DS_TYPE_STR 
1bb6				jp nz, type_faultn   
1bb6				pop af 
1bb6				endm 
1bb6			 
1bb6			FORTH_ERR_TOS_NOTNUM: macro 
1bb6				push af 
1bb6				ld a,(hl) 
1bb6				cp DS_TYPE_INUM 
1bb6				jp nz, type_faultn   
1bb6				pop af 
1bb6				endm 
1bb6			 
1bb6			 
1bb6			; increase data stack pointer and save hl to it 
1bb6				 
1bb6			FORTH_DSP_NEXT: macro 
1bb6				call macro_forth_dsp_next 
1bb6				endm 
1bb6			 
1bb6			 
1bb6			macro_forth_dsp_next: 
1bb6				if DEBUG_FORTH_STACK_GUARD 
1bb6 cd e5 62				call check_stacks 
1bb9				endif 
1bb9 e5				push hl 
1bba d5				push de 
1bbb eb				ex de,hl 
1bbc 2a 0a f8			ld hl,(cli_data_sp) 
1bbf 23				inc hl 
1bc0 23				inc hl 
1bc1			 
1bc1			; PARSEV5 
1bc1 23				inc hl 
1bc2 22 0a f8			ld (cli_data_sp),hl 
1bc5 73				ld (hl), e 
1bc6 23				inc hl 
1bc7 72				ld (hl), d 
1bc8 d1				pop de 
1bc9 e1				pop hl 
1bca				if DEBUG_FORTH_STACK_GUARD 
1bca cd e5 62				call check_stacks 
1bcd				endif 
1bcd c9				ret 
1bce			 
1bce			 
1bce			; increase ret stack pointer and save hl to it 
1bce				 
1bce			FORTH_RSP_NEXT: macro 
1bce				call macro_forth_rsp_next 
1bce				endm 
1bce			 
1bce			macro_forth_rsp_next: 
1bce				if DEBUG_FORTH_STACK_GUARD 
1bce cd e5 62				call check_stacks 
1bd1				endif 
1bd1 e5				push hl 
1bd2 d5				push de 
1bd3 eb				ex de,hl 
1bd4 2a 0e f8			ld hl,(cli_ret_sp) 
1bd7 23				inc hl 
1bd8 23				inc hl 
1bd9 22 0e f8			ld (cli_ret_sp),hl 
1bdc 73				ld (hl), e 
1bdd 23				inc hl 
1bde 72				ld (hl), d 
1bdf d1				pop de 
1be0 e1				pop hl 
1be1				if DEBUG_FORTH_STACK_GUARD 
1be1 cd e5 62				call check_stacks 
1be4				endif 
1be4 c9				ret 
1be5			 
1be5			; get current ret stack pointer and save to hl  
1be5				 
1be5			FORTH_RSP_TOS: macro 
1be5				call macro_forth_rsp_tos 
1be5				endm 
1be5			 
1be5			macro_forth_rsp_tos: 
1be5				;push de 
1be5 2a 0e f8			ld hl,(cli_ret_sp) 
1be8 cd 20 1c			call loadhlptrtohl 
1beb				;ld e, (hl) 
1beb				;inc hl 
1beb				;ld d, (hl) 
1beb				;ex de, hl 
1beb					if DEBUG_FORTH_WORDS 
1beb			;			DMARK "RST" 
1beb						CALLMONITOR 
1beb cd 97 16			call break_point_state  
1bee				endm  
# End of macro CALLMONITOR
1bee					endif 
1bee				;pop de 
1bee c9				ret 
1bef			 
1bef			; pop ret stack pointer 
1bef				 
1bef			FORTH_RSP_POP: macro 
1bef				call macro_forth_rsp_pop 
1bef				endm 
1bef			 
1bef			 
1bef			macro_forth_rsp_pop: 
1bef				if DEBUG_FORTH_STACK_GUARD 
1bef			;		DMARK "RPP" 
1bef cd e5 62				call check_stacks 
1bf2					FORTH_CHK_RSP_UNDER 
1bf2 e5				push hl 
1bf3 d5				push de 
1bf4 2a 0e f8			ld hl,(cli_ret_sp) 
1bf7 11 88 f7			ld de, cli_ret_stack 
1bfa cd 27 0d			call cmp16 
1bfd da f9 63			jp c, fault_rsp_under 
1c00 d1				pop de 
1c01 e1				pop hl 
1c02				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c02				endif 
1c02 e5				push hl 
1c03 2a 0e f8			ld hl,(cli_ret_sp) 
1c06			 
1c06			 
1c06				if FORTH_ENABLE_FREE 
1c06			 
1c06					; get pointer 
1c06			 
1c06					push de 
1c06					push hl 
1c06			 
1c06					ld e, (hl) 
1c06					inc hl 
1c06					ld d, (hl) 
1c06			 
1c06					ex de, hl 
1c06					call free 
1c06			 
1c06					pop hl 
1c06					pop de 
1c06			 
1c06			 
1c06				endif 
1c06			 
1c06			 
1c06 2b				dec hl 
1c07 2b				dec hl 
1c08 22 0e f8			ld (cli_ret_sp), hl 
1c0b				; do stack underflow checks 
1c0b e1				pop hl 
1c0c				if DEBUG_FORTH_STACK_GUARD 
1c0c cd e5 62				call check_stacks 
1c0f					FORTH_CHK_RSP_UNDER 
1c0f e5				push hl 
1c10 d5				push de 
1c11 2a 0e f8			ld hl,(cli_ret_sp) 
1c14 11 88 f7			ld de, cli_ret_stack 
1c17 cd 27 0d			call cmp16 
1c1a da f9 63			jp c, fault_rsp_under 
1c1d d1				pop de 
1c1e e1				pop hl 
1c1f				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c1f				endif 
1c1f c9				ret 
1c20			 
1c20			 
1c20			 
1c20			; routine to load word pointed to by hl into hl 
1c20			 
1c20			loadhlptrtohl: 
1c20			 
1c20 d5				push de 
1c21 5e				ld e, (hl) 
1c22 23				inc hl 
1c23 56				ld d, (hl) 
1c24 eb				ex de, hl 
1c25 d1				pop de 
1c26			 
1c26 c9				ret 
1c27			 
1c27			 
1c27			 
1c27			 
1c27			 
1c27			; push a number held in HL onto the data stack 
1c27			; entry point for pushing a value when already in hl used in function above 
1c27			 
1c27			forth_push_numhl: 
1c27			 
1c27 e5				push hl    ; save value to push 
1c28			 
1c28			if DEBUG_FORTH_PUSH 
1c28				; see if disabled 
1c28			 
1c28			 
1c28 f5				push af 
1c29 3a 0e ee			ld a, (os_view_disable) 
1c2c fe 2a			cp '*' 
1c2e 28 34			jr z, .pskip2 
1c30 e5				push hl 
1c31 e5			push hl 
1c32 cd d5 0a			call clear_display 
1c35 e1			pop hl 
1c36 7c				ld a,h 
1c37 21 22 f1			ld hl, os_word_scratch 
1c3a cd 0a 10			call hexout 
1c3d e1				pop hl 
1c3e 7d				ld a,l 
1c3f 21 24 f1			ld hl, os_word_scratch+2 
1c42 cd 0a 10			call hexout 
1c45			 
1c45 21 26 f1			ld hl, os_word_scratch+4 
1c48 3e 00			ld a,0 
1c4a 77				ld (hl),a 
1c4b 11 22 f1			ld de,os_word_scratch 
1c4e 3e 28				ld a, display_row_2 
1c50 cd e8 0a				call str_at_display 
1c53 11 f3 51			ld de, .push_num 
1c56 3e 00			ld a, display_row_1 
1c58			 
1c58 cd e8 0a				call str_at_display 
1c5b			 
1c5b			 
1c5b cd f8 0a			call update_display 
1c5e cd 55 0a			call delay1s 
1c61 cd 55 0a			call delay1s 
1c64			.pskip2:  
1c64			 
1c64 f1				pop af 
1c65			endif	 
1c65			 
1c65			 
1c65				FORTH_DSP_NEXT 
1c65 cd b6 1b			call macro_forth_dsp_next 
1c68				endm 
# End of macro FORTH_DSP_NEXT
1c68			 
1c68 2a 0a f8			ld hl, (cli_data_sp) 
1c6b			 
1c6b				; save item type 
1c6b 3e 02			ld a,  DS_TYPE_INUM 
1c6d 77				ld (hl), a 
1c6e 23				inc hl 
1c6f			 
1c6f				; get word off stack 
1c6f d1				pop de 
1c70 7b				ld a,e 
1c71 77				ld (hl), a 
1c72 23				inc hl 
1c73 7a				ld a,d 
1c74 77				ld (hl), a 
1c75			 
1c75			if DEBUG_FORTH_PUSH 
1c75 2b				dec hl 
1c76 2b				dec hl 
1c77 2b				dec hl 
1c78						DMARK "PH5" 
1c78 f5				push af  
1c79 3a 8d 1c			ld a, (.dmark)  
1c7c 32 77 fb			ld (debug_mark),a  
1c7f 3a 8e 1c			ld a, (.dmark+1)  
1c82 32 78 fb			ld (debug_mark+1),a  
1c85 3a 8f 1c			ld a, (.dmark+2)  
1c88 32 79 fb			ld (debug_mark+2),a  
1c8b 18 03			jr .pastdmark  
1c8d ..			.dmark: db "PH5"  
1c90 f1			.pastdmark: pop af  
1c91			endm  
# End of macro DMARK
1c91				CALLMONITOR 
1c91 cd 97 16			call break_point_state  
1c94				endm  
# End of macro CALLMONITOR
1c94			endif	 
1c94			 
1c94 c9				ret 
1c95			 
1c95			 
1c95			; Push a string to stack pointed to by hl 
1c95			 
1c95			forth_push_str: 
1c95			 
1c95			if DEBUG_FORTH_PUSH 
1c95						DMARK "PSQ" 
1c95 f5				push af  
1c96 3a aa 1c			ld a, (.dmark)  
1c99 32 77 fb			ld (debug_mark),a  
1c9c 3a ab 1c			ld a, (.dmark+1)  
1c9f 32 78 fb			ld (debug_mark+1),a  
1ca2 3a ac 1c			ld a, (.dmark+2)  
1ca5 32 79 fb			ld (debug_mark+2),a  
1ca8 18 03			jr .pastdmark  
1caa ..			.dmark: db "PSQ"  
1cad f1			.pastdmark: pop af  
1cae			endm  
# End of macro DMARK
1cae				CALLMONITOR 
1cae cd 97 16			call break_point_state  
1cb1				endm  
# End of macro CALLMONITOR
1cb1			endif	 
1cb1			    
1cb1 e5				push hl 
1cb2 e5				push hl 
1cb3			 
1cb3			;	ld a, 0   ; find end of string 
1cb3 cd 67 11			call strlenz 
1cb6			if DEBUG_FORTH_PUSH 
1cb6						DMARK "PQ2" 
1cb6 f5				push af  
1cb7 3a cb 1c			ld a, (.dmark)  
1cba 32 77 fb			ld (debug_mark),a  
1cbd 3a cc 1c			ld a, (.dmark+1)  
1cc0 32 78 fb			ld (debug_mark+1),a  
1cc3 3a cd 1c			ld a, (.dmark+2)  
1cc6 32 79 fb			ld (debug_mark+2),a  
1cc9 18 03			jr .pastdmark  
1ccb ..			.dmark: db "PQ2"  
1cce f1			.pastdmark: pop af  
1ccf			endm  
# End of macro DMARK
1ccf				CALLMONITOR 
1ccf cd 97 16			call break_point_state  
1cd2				endm  
# End of macro CALLMONITOR
1cd2			endif	 
1cd2 eb				ex de, hl 
1cd3 e1				pop hl   ; get ptr to start of string 
1cd4			if DEBUG_FORTH_PUSH 
1cd4						DMARK "PQ3" 
1cd4 f5				push af  
1cd5 3a e9 1c			ld a, (.dmark)  
1cd8 32 77 fb			ld (debug_mark),a  
1cdb 3a ea 1c			ld a, (.dmark+1)  
1cde 32 78 fb			ld (debug_mark+1),a  
1ce1 3a eb 1c			ld a, (.dmark+2)  
1ce4 32 79 fb			ld (debug_mark+2),a  
1ce7 18 03			jr .pastdmark  
1ce9 ..			.dmark: db "PQ3"  
1cec f1			.pastdmark: pop af  
1ced			endm  
# End of macro DMARK
1ced				CALLMONITOR 
1ced cd 97 16			call break_point_state  
1cf0				endm  
# End of macro CALLMONITOR
1cf0			endif	 
1cf0 19				add hl,de 
1cf1			if DEBUG_FORTH_PUSH 
1cf1						DMARK "PQE" 
1cf1 f5				push af  
1cf2 3a 06 1d			ld a, (.dmark)  
1cf5 32 77 fb			ld (debug_mark),a  
1cf8 3a 07 1d			ld a, (.dmark+1)  
1cfb 32 78 fb			ld (debug_mark+1),a  
1cfe 3a 08 1d			ld a, (.dmark+2)  
1d01 32 79 fb			ld (debug_mark+2),a  
1d04 18 03			jr .pastdmark  
1d06 ..			.dmark: db "PQE"  
1d09 f1			.pastdmark: pop af  
1d0a			endm  
# End of macro DMARK
1d0a				CALLMONITOR 
1d0a cd 97 16			call break_point_state  
1d0d				endm  
# End of macro CALLMONITOR
1d0d			endif	 
1d0d			 
1d0d 2b				dec hl    ; see if there is an optional trailing double quote 
1d0e 7e				ld a,(hl) 
1d0f fe 22			cp '"' 
1d11 20 03			jr nz, .strnoq 
1d13 3e 00			ld a, 0      ; get rid of double quote 
1d15 77				ld (hl), a 
1d16 23			.strnoq: inc hl 
1d17			 
1d17 3e 00			ld a, 0 
1d19 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d1a			 
1d1a 13				inc de ; add one for the type string 
1d1b 13				inc de ; add one for null term??? 
1d1c			 
1d1c				; tos is get string pointer again 
1d1c				; de contains space to allocate 
1d1c				 
1d1c d5				push de 
1d1d			 
1d1d eb				ex de, hl 
1d1e			 
1d1e				;push af 
1d1e			 
1d1e			if DEBUG_FORTH_PUSH 
1d1e						DMARK "PHm" 
1d1e f5				push af  
1d1f 3a 33 1d			ld a, (.dmark)  
1d22 32 77 fb			ld (debug_mark),a  
1d25 3a 34 1d			ld a, (.dmark+1)  
1d28 32 78 fb			ld (debug_mark+1),a  
1d2b 3a 35 1d			ld a, (.dmark+2)  
1d2e 32 79 fb			ld (debug_mark+2),a  
1d31 18 03			jr .pastdmark  
1d33 ..			.dmark: db "PHm"  
1d36 f1			.pastdmark: pop af  
1d37			endm  
# End of macro DMARK
1d37				CALLMONITOR 
1d37 cd 97 16			call break_point_state  
1d3a				endm  
# End of macro CALLMONITOR
1d3a			endif	 
1d3a cd d0 11			call malloc	; on ret hl now contains allocated memory 
1d3d				if DEBUG_FORTH_MALLOC_GUARD 
1d3d cc 4b 52				call z,malloc_error 
1d40				endif 
1d40			 
1d40				 
1d40 c1				pop bc    ; get length 
1d41 d1				pop de   ;  get string start    
1d42			 
1d42				; hl has destination from malloc 
1d42			 
1d42 eb				ex de, hl    ; prep for ldir 
1d43			 
1d43 d5				push de   ; save malloc area for DSP later 
1d44				;push hl   ; save malloc area for DSP later 
1d44			 
1d44			if DEBUG_FORTH_PUSH 
1d44						DMARK "PHc" 
1d44 f5				push af  
1d45 3a 59 1d			ld a, (.dmark)  
1d48 32 77 fb			ld (debug_mark),a  
1d4b 3a 5a 1d			ld a, (.dmark+1)  
1d4e 32 78 fb			ld (debug_mark+1),a  
1d51 3a 5b 1d			ld a, (.dmark+2)  
1d54 32 79 fb			ld (debug_mark+2),a  
1d57 18 03			jr .pastdmark  
1d59 ..			.dmark: db "PHc"  
1d5c f1			.pastdmark: pop af  
1d5d			endm  
# End of macro DMARK
1d5d				CALLMONITOR 
1d5d cd 97 16			call break_point_state  
1d60				endm  
# End of macro CALLMONITOR
1d60			endif	 
1d60			 
1d60			 
1d60 ed b0			ldir 
1d62			 
1d62			 
1d62				; push malloc to data stack     macro?????  
1d62			 
1d62				FORTH_DSP_NEXT 
1d62 cd b6 1b			call macro_forth_dsp_next 
1d65				endm 
# End of macro FORTH_DSP_NEXT
1d65			 
1d65				; save value and type 
1d65			 
1d65 2a 0a f8			ld hl, (cli_data_sp) 
1d68			 
1d68				; save item type 
1d68 3e 01			ld a,  DS_TYPE_STR 
1d6a 77				ld (hl), a 
1d6b 23				inc hl 
1d6c			 
1d6c				; get malloc word off stack 
1d6c d1				pop de 
1d6d 73				ld (hl), e 
1d6e 23				inc hl 
1d6f 72				ld (hl), d 
1d70			 
1d70			 
1d70			 
1d70			if DEBUG_FORTH_PUSH 
1d70 2a 0a f8			ld hl, (cli_data_sp) 
1d73						DMARK "PHS" 
1d73 f5				push af  
1d74 3a 88 1d			ld a, (.dmark)  
1d77 32 77 fb			ld (debug_mark),a  
1d7a 3a 89 1d			ld a, (.dmark+1)  
1d7d 32 78 fb			ld (debug_mark+1),a  
1d80 3a 8a 1d			ld a, (.dmark+2)  
1d83 32 79 fb			ld (debug_mark+2),a  
1d86 18 03			jr .pastdmark  
1d88 ..			.dmark: db "PHS"  
1d8b f1			.pastdmark: pop af  
1d8c			endm  
# End of macro DMARK
1d8c				CALLMONITOR 
1d8c cd 97 16			call break_point_state  
1d8f				endm  
# End of macro CALLMONITOR
1d8f			;	ex de,hl 
1d8f			endif	 
1d8f				; in case of spaces, skip the ptr past the copied string 
1d8f				;pop af 
1d8f				;ld (cli_origptr),hl 
1d8f			 
1d8f c9				ret 
1d90			 
1d90			 
1d90			 
1d90			; TODO ascii push input onto stack given hl to start of input 
1d90			 
1d90			; identify type 
1d90			; if starts with a " then a string 
1d90			; otherwise it is a number 
1d90			;  
1d90			; if a string 
1d90			;     scan for ending " to get length of string to malloc for + 1 
1d90			;     malloc 
1d90			;     put pointer to string on stack first byte flags as string 
1d90			; 
1d90			; else a number 
1d90			;    look for number format identifier 
1d90			;    $xx hex 
1d90			;    %xxxxx bin 
1d90			;    xxxxx decimal 
1d90			;    convert number to 16bit word.  
1d90			;    malloc word + 1 with flag to identiy as num 
1d90			;    put pointer to number on stack 
1d90			;   
1d90			;  
1d90			  
1d90			forth_apush: 
1d90				; kernel push 
1d90			 
1d90			if DEBUG_FORTH_PUSH 
1d90						DMARK "PSH" 
1d90 f5				push af  
1d91 3a a5 1d			ld a, (.dmark)  
1d94 32 77 fb			ld (debug_mark),a  
1d97 3a a6 1d			ld a, (.dmark+1)  
1d9a 32 78 fb			ld (debug_mark+1),a  
1d9d 3a a7 1d			ld a, (.dmark+2)  
1da0 32 79 fb			ld (debug_mark+2),a  
1da3 18 03			jr .pastdmark  
1da5 ..			.dmark: db "PSH"  
1da8 f1			.pastdmark: pop af  
1da9			endm  
# End of macro DMARK
1da9				CALLMONITOR 
1da9 cd 97 16			call break_point_state  
1dac				endm  
# End of macro CALLMONITOR
1dac			endif	 
1dac				; identify input type 
1dac			 
1dac 7e				ld a,(hl) 
1dad fe 22			cp '"' 
1daf 28 0a			jr z, .fapstr 
1db1 fe 24			cp '$' 
1db3 ca db 1d			jp z, .faphex 
1db6 fe 25			cp '%' 
1db8 ca c3 1d			jp z, .fapbin 
1dbb			;	cp 'b' 
1dbb			;	jp z, .fabin 
1dbb				; else decimal 
1dbb			 
1dbb				; TODO do decimal conversion 
1dbb				; decimal is stored as a 16bit word 
1dbb			 
1dbb				; by default everything is a string if type is not detected 
1dbb			.fapstr: ; 
1dbb fe 22			cp '"' 
1dbd 20 01			jr nz, .strnoqu 
1dbf 23				inc hl 
1dc0			.strnoqu: 
1dc0 c3 95 1c			jp forth_push_str 
1dc3			 
1dc3			 
1dc3			 
1dc3			.fapbin:    ; push a binary string.  
1dc3 11 00 00			ld de, 0   ; hold a 16bit value 
1dc6			 
1dc6 23			.fapbinshift:	inc hl  
1dc7 7e				ld a,(hl) 
1dc8 fe 00			cp 0     ; done scanning  
1dca 28 0b			jr z, .fapbdone  	; got it in HL so push  
1dcc			 
1dcc				; left shift de 
1dcc eb				ex de, hl	 
1dcd 29				add hl, hl 
1dce			 
1dce				; is 1 
1dce fe 31			cp '1' 
1dd0 20 02			jr nz, .binzero 
1dd2 cb 4d			bit 1, l 
1dd4			.binzero: 
1dd4 eb				ex de, hl	 ; save current de 
1dd5 18 ef			jr .fapbinshift 
1dd7			 
1dd7			.fapbdone: 
1dd7 eb				ex de, hl 
1dd8 c3 27 1c			jp forth_push_numhl 
1ddb			 
1ddb			 
1ddb			.faphex:   ; hex is always stored as a 16bit word 
1ddb				; skip number prefix 
1ddb 23				inc hl 
1ddc				; turn ascii into number 
1ddc cd c0 10			call get_word_hl	; ret 16bit word in hl 
1ddf			 
1ddf c3 27 1c			jp forth_push_numhl 
1de2			 
1de2 00				 nop 
1de3			 
1de3			.fabin:   ; TODO bin conversion 
1de3			 
1de3			 
1de3 c9				ret 
1de4			 
1de4			 
1de4			; get either a string ptr or a 16bit word from the data stack 
1de4			 
1de4			FORTH_DSP: macro 
1de4				call macro_forth_dsp 
1de4				endm 
1de4			 
1de4			macro_forth_dsp: 
1de4				; data stack pointer points to current word on tos 
1de4			 
1de4 2a 0a f8			ld hl,(cli_data_sp) 
1de7			 
1de7				if DEBUG_FORTH_PUSH 
1de7						DMARK "DSP" 
1de7 f5				push af  
1de8 3a fc 1d			ld a, (.dmark)  
1deb 32 77 fb			ld (debug_mark),a  
1dee 3a fd 1d			ld a, (.dmark+1)  
1df1 32 78 fb			ld (debug_mark+1),a  
1df4 3a fe 1d			ld a, (.dmark+2)  
1df7 32 79 fb			ld (debug_mark+2),a  
1dfa 18 03			jr .pastdmark  
1dfc ..			.dmark: db "DSP"  
1dff f1			.pastdmark: pop af  
1e00			endm  
# End of macro DMARK
1e00			 
1e00 cd 80 52				call display_data_sp 
1e03				;call break_point_state 
1e03				;rst 030h 
1e03				CALLMONITOR 
1e03 cd 97 16			call break_point_state  
1e06				endm  
# End of macro CALLMONITOR
1e06				endif 
1e06			 
1e06 c9				ret 
1e07			 
1e07			; return hl to start of value on stack 
1e07			 
1e07			FORTH_DSP_VALUE: macro 
1e07				call macro_forth_dsp_value 
1e07				endm 
1e07			 
1e07			macro_forth_dsp_value: 
1e07			 
1e07				FORTH_DSP 
1e07 cd e4 1d			call macro_forth_dsp 
1e0a				endm 
# End of macro FORTH_DSP
1e0a			 
1e0a d5				push de 
1e0b			 
1e0b 23				inc hl ; skip type 
1e0c			 
1e0c 5e				ld e, (hl) 
1e0d 23				inc hl 
1e0e 56				ld d, (hl) 
1e0f eb				ex de,hl  
1e10			 
1e10 d1				pop de 
1e11			 
1e11 c9				ret 
1e12			 
1e12			; return hl to start of value to second item on stack 
1e12			 
1e12			FORTH_DSP_VALUEM1: macro 
1e12				call macro_forth_dsp_value_m1 
1e12				endm 
1e12			 
1e12			macro_forth_dsp_value_m1: 
1e12			 
1e12				FORTH_DSP 
1e12 cd e4 1d			call macro_forth_dsp 
1e15				endm 
# End of macro FORTH_DSP
1e15			 
1e15 2b				dec hl 
1e16 2b				dec hl 
1e17			;	dec hl 
1e17			 
1e17 d5				push de 
1e18			 
1e18 5e				ld e, (hl) 
1e19 23				inc hl 
1e1a 56				ld d, (hl) 
1e1b eb				ex de,hl  
1e1c			 
1e1c d1				pop de 
1e1d			 
1e1d c9				ret 
1e1e			 
1e1e				 
1e1e			 
1e1e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e1e			 
1e1e			FORTH_DSP_POP: macro 
1e1e				call macro_forth_dsp_pop 
1e1e				endm 
1e1e			 
1e1e			 
1e1e			; get the tos data type 
1e1e			 
1e1e			FORTH_DSP_TYPE:   macro 
1e1e			 
1e1e				;FORTH_DSP_VALUE 
1e1e				FORTH_DSP 
1e1e				 
1e1e				; hl points to value 
1e1e				; check type 
1e1e			 
1e1e				ld a,(hl) 
1e1e			 
1e1e				endm 
1e1e			 
1e1e			; load the tos value into hl 
1e1e			 
1e1e			 
1e1e			FORTH_DSP_VALUEHL:  macro 
1e1e				call macro_dsp_valuehl 
1e1e				endm 
1e1e			 
1e1e			 
1e1e			 
1e1e			macro_dsp_valuehl: 
1e1e				FORTH_DSP_VALUE 
1e1e cd 07 1e			call macro_forth_dsp_value 
1e21				endm 
# End of macro FORTH_DSP_VALUE
1e21			 
1e21				;FORTH_ERR_TOS_NOTNUM 
1e21			 
1e21				;inc hl   ; skip type id 
1e21			 
1e21			;	push de 
1e21			; 
1e21			;	ld e, (hl) 
1e21			;	inc hl 
1e21			;	ld d, (hl) 
1e21			;	ex de,hl  
1e21			 
1e21			;	pop de 
1e21			 
1e21				if DEBUG_FORTH_PUSH 
1e21						DMARK "DVL" 
1e21 f5				push af  
1e22 3a 36 1e			ld a, (.dmark)  
1e25 32 77 fb			ld (debug_mark),a  
1e28 3a 37 1e			ld a, (.dmark+1)  
1e2b 32 78 fb			ld (debug_mark+1),a  
1e2e 3a 38 1e			ld a, (.dmark+2)  
1e31 32 79 fb			ld (debug_mark+2),a  
1e34 18 03			jr .pastdmark  
1e36 ..			.dmark: db "DVL"  
1e39 f1			.pastdmark: pop af  
1e3a			endm  
# End of macro DMARK
1e3a				CALLMONITOR 
1e3a cd 97 16			call break_point_state  
1e3d				endm  
# End of macro CALLMONITOR
1e3d				endif 
1e3d c9				ret 
1e3e			 
1e3e			forth_apushstrhl:      
1e3e				; push of string requires use of cli_origptr 
1e3e				; bodge use 
1e3e			 
1e3e				; get current cli_origptr, save, update with temp pointer  
1e3e ed 5b 26 f8		ld de, (cli_origptr) 
1e42 22 26 f8			ld (cli_origptr), hl 
1e45 d5				push de 
1e46 cd 90 1d			call forth_apush 
1e49 d1				pop de 
1e4a ed 53 26 f8		ld (cli_origptr), de 
1e4e c9			        ret	 
1e4f			 
1e4f			 
1e4f			; increase loop stack pointer and save hl to it 
1e4f				 
1e4f			FORTH_LOOP_NEXT: macro 
1e4f				call macro_forth_loop_next 
1e4f				;nop 
1e4f				endm 
1e4f			 
1e4f			macro_forth_loop_next: 
1e4f				if DEBUG_FORTH_STACK_GUARD 
1e4f cd e5 62				call check_stacks 
1e52				endif 
1e52 e5				push hl 
1e53 d5				push de 
1e54 eb				ex de,hl 
1e55 2a 0c f8			ld hl,(cli_loop_sp) 
1e58 23				inc hl 
1e59 23				inc hl 
1e5a					if DEBUG_FORTH_WORDS 
1e5a						DMARK "LNX" 
1e5a f5				push af  
1e5b 3a 6f 1e			ld a, (.dmark)  
1e5e 32 77 fb			ld (debug_mark),a  
1e61 3a 70 1e			ld a, (.dmark+1)  
1e64 32 78 fb			ld (debug_mark+1),a  
1e67 3a 71 1e			ld a, (.dmark+2)  
1e6a 32 79 fb			ld (debug_mark+2),a  
1e6d 18 03			jr .pastdmark  
1e6f ..			.dmark: db "LNX"  
1e72 f1			.pastdmark: pop af  
1e73			endm  
# End of macro DMARK
1e73						CALLMONITOR 
1e73 cd 97 16			call break_point_state  
1e76				endm  
# End of macro CALLMONITOR
1e76					endif 
1e76 22 0c f8			ld (cli_loop_sp),hl 
1e79 73				ld (hl), e 
1e7a 23				inc hl 
1e7b 72				ld (hl), d 
1e7c d1				pop de    ; been reversed so save a swap on restore 
1e7d e1				pop hl 
1e7e				if DEBUG_FORTH_STACK_GUARD 
1e7e cd e5 62				call check_stacks 
1e81				endif 
1e81 c9				ret 
1e82			 
1e82			; get current ret stack pointer and save to hl  
1e82				 
1e82			FORTH_LOOP_TOS: macro 
1e82				call macro_forth_loop_tos 
1e82				endm 
1e82			 
1e82			macro_forth_loop_tos: 
1e82 d5				push de 
1e83 2a 0c f8			ld hl,(cli_loop_sp) 
1e86 5e				ld e, (hl) 
1e87 23				inc hl 
1e88 56				ld d, (hl) 
1e89 eb				ex de, hl 
1e8a d1				pop de 
1e8b c9				ret 
1e8c			 
1e8c			; pop loop stack pointer 
1e8c				 
1e8c			FORTH_LOOP_POP: macro 
1e8c				call macro_forth_loop_pop 
1e8c				endm 
1e8c			 
1e8c			 
1e8c			macro_forth_loop_pop: 
1e8c				if DEBUG_FORTH_STACK_GUARD 
1e8c					DMARK "LPP" 
1e8c f5				push af  
1e8d 3a a1 1e			ld a, (.dmark)  
1e90 32 77 fb			ld (debug_mark),a  
1e93 3a a2 1e			ld a, (.dmark+1)  
1e96 32 78 fb			ld (debug_mark+1),a  
1e99 3a a3 1e			ld a, (.dmark+2)  
1e9c 32 79 fb			ld (debug_mark+2),a  
1e9f 18 03			jr .pastdmark  
1ea1 ..			.dmark: db "LPP"  
1ea4 f1			.pastdmark: pop af  
1ea5			endm  
# End of macro DMARK
1ea5 cd e5 62				call check_stacks 
1ea8					FORTH_CHK_LOOP_UNDER 
1ea8 e5				push hl 
1ea9 d5				push de 
1eaa 2a 0c f8			ld hl,(cli_loop_sp) 
1ead 11 86 f5			ld de, cli_loop_stack 
1eb0 cd 27 0d			call cmp16 
1eb3 da ff 63			jp c, fault_loop_under 
1eb6 d1				pop de 
1eb7 e1				pop hl 
1eb8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1eb8				endif 
1eb8 e5				push hl 
1eb9 2a 0c f8			ld hl,(cli_loop_sp) 
1ebc 2b				dec hl 
1ebd 2b				dec hl 
1ebe 22 0c f8			ld (cli_loop_sp), hl 
1ec1				; TODO do stack underflow checks 
1ec1 e1				pop hl 
1ec2				if DEBUG_FORTH_STACK_GUARD 
1ec2 cd e5 62				call check_stacks 
1ec5					FORTH_CHK_LOOP_UNDER 
1ec5 e5				push hl 
1ec6 d5				push de 
1ec7 2a 0c f8			ld hl,(cli_loop_sp) 
1eca 11 86 f5			ld de, cli_loop_stack 
1ecd cd 27 0d			call cmp16 
1ed0 da ff 63			jp c, fault_loop_under 
1ed3 d1				pop de 
1ed4 e1				pop hl 
1ed5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ed5				endif 
1ed5 c9				ret 
1ed6			 
1ed6			macro_forth_dsp_pop: 
1ed6			 
1ed6 e5				push hl 
1ed7			 
1ed7				; release malloc data 
1ed7			 
1ed7				if DEBUG_FORTH_STACK_GUARD 
1ed7 cd e5 62				call check_stacks 
1eda					FORTH_CHK_DSP_UNDER 
1eda e5				push hl 
1edb d5				push de 
1edc 2a 0a f8			ld hl,(cli_data_sp) 
1edf 11 84 f3			ld de, cli_data_stack 
1ee2 cd 27 0d			call cmp16 
1ee5 da f3 63			jp c, fault_dsp_under 
1ee8 d1				pop de 
1ee9 e1				pop hl 
1eea				endm 
# End of macro FORTH_CHK_DSP_UNDER
1eea				endif 
1eea				;ld hl,(cli_data_sp) 
1eea			if DEBUG_FORTH_DOT 
1eea				DMARK "DPP" 
1eea				CALLMONITOR 
1eea			endif	 
1eea			 
1eea			 
1eea			if FORTH_ENABLE_DSPPOPFREE 
1eea			 
1eea				FORTH_DSP 
1eea cd e4 1d			call macro_forth_dsp 
1eed				endm 
# End of macro FORTH_DSP
1eed			 
1eed 7e				ld a, (hl) 
1eee fe 01			cp DS_TYPE_STR 
1ef0 20 07			jr nz, .skippopfree 
1ef2			 
1ef2				FORTH_DSP_VALUEHL 
1ef2 cd 1e 1e			call macro_dsp_valuehl 
1ef5				endm 
# End of macro FORTH_DSP_VALUEHL
1ef5 00				nop 
1ef6			if DEBUG_FORTH_DOT 
1ef6				DMARK "DPf" 
1ef6				CALLMONITOR 
1ef6			endif	 
1ef6 cd 9a 12			call free 
1ef9			.skippopfree: 
1ef9				 
1ef9			 
1ef9			endif 
1ef9			 
1ef9			if DEBUG_FORTH_DOT_KEY 
1ef9				DMARK "DP2" 
1ef9				CALLMONITOR 
1ef9			endif	 
1ef9			 
1ef9				; move pointer down 
1ef9			 
1ef9 2a 0a f8			ld hl,(cli_data_sp) 
1efc 2b				dec hl 
1efd 2b				dec hl 
1efe			; PARSEV5 
1efe 2b				dec hl 
1eff 22 0a f8			ld (cli_data_sp), hl 
1f02			 
1f02				if DEBUG_FORTH_STACK_GUARD 
1f02 cd e5 62				call check_stacks 
1f05					FORTH_CHK_DSP_UNDER 
1f05 e5				push hl 
1f06 d5				push de 
1f07 2a 0a f8			ld hl,(cli_data_sp) 
1f0a 11 84 f3			ld de, cli_data_stack 
1f0d cd 27 0d			call cmp16 
1f10 da f3 63			jp c, fault_dsp_under 
1f13 d1				pop de 
1f14 e1				pop hl 
1f15				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f15				endif 
1f15			 
1f15 e1				pop hl 
1f16			 
1f16 c9				ret 
1f17			 
1f17			getwordathl: 
1f17				; hl points to an address 
1f17				; load hl with the word at that address 
1f17			 
1f17 d5				push de 
1f18			 
1f18 5e				ld e, (hl) 
1f19 23				inc hl 
1f1a 56				ld d, (hl) 
1f1b eb				ex de, hl 
1f1c			 
1f1c d1				pop de 
1f1d c9				ret 
1f1e			 
1f1e			 
1f1e			 
1f1e			 
1f1e			 
1f1e			; eof 
1f1e			 
# End of file forth_stackopsv5.asm
1f1e			endif 
1f1e			 
1f1e			user_word_eol:  
1f1e				; hl contains the pointer to where to create a linked list item from the end 
1f1e				; of the user dict to continue on at the system word dict 
1f1e				 
1f1e				; poke the stub of the word list linked list to repoint to rom words 
1f1e			 
1f1e				; stub format 
1f1e				; db   word id 
1f1e				; dw    link to next word 
1f1e			        ; db char length of token 
1f1e				; db string + 0 term 
1f1e				; db exec code....  
1f1e			 
1f1e 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f20 77				ld (hl), a		; word id 
1f21 23				inc hl 
1f22			 
1f22 11 e8 20			ld de, sysdict 
1f25 73				ld (hl), e		; next word link ie system dict 
1f26 23				inc hl 
1f27 72				ld (hl), d		; next word link ie system dict 
1f28 23				inc hl	 
1f29			 
1f29			;	ld (hl), sysdict		; next word link ie system dict 
1f29			;	inc hl 
1f29			;	inc hl 
1f29			 
1f29			;	inc hl 
1f29			;	inc hl 
1f29			 
1f29 3e 02			ld a, 2			; word length is 0 
1f2b 77				ld (hl), a	 
1f2c 23				inc hl 
1f2d			 
1f2d 3e 7e			ld a, '~'			; word length is 0 
1f2f 77				ld (hl), a	 
1f30 23				inc hl 
1f31 3e 00			ld a, 0			; save empty word 
1f33 77				ld (hl), a 
1f34			 
1f34 c9				ret 
1f35			 
1f35				 
1f35			 
1f35			forthexec_cleanup: 
1f35				FORTH_RSP_POP 
1f35 cd ef 1b			call macro_forth_rsp_pop 
1f38				endm 
# End of macro FORTH_RSP_POP
1f38 c9				ret 
1f39			 
1f39			forth_call_hl: 
1f39				; taking hl 
1f39 e5				push hl 
1f3a c9				ret 
1f3b			 
1f3b			; this is called to reset Forth system but keep existing uwords etc 
1f3b			 
1f3b			forth_warmstart: 
1f3b				; setup stack over/under flow checks 
1f3b				if DEBUG_FORTH_STACK_GUARD 
1f3b cd cb 62				call chk_stk_init 
1f3e				endif 
1f3e			 
1f3e				; init stack pointers  - * these stacks go upwards *  
1f3e 21 88 f7			ld hl, cli_ret_stack 
1f41 22 0e f8			ld (cli_ret_sp), hl	 
1f44				; set bottom of stack 
1f44 3e 00			ld a,0 
1f46 77				ld (hl),a 
1f47 23				inc hl 
1f48 77				ld (hl),a 
1f49			 
1f49 21 84 f3			ld hl, cli_data_stack 
1f4c 22 0a f8			ld (cli_data_sp), hl	 
1f4f				; set bottom of stack 
1f4f 3e 00			ld a,0 
1f51 77				ld (hl),a 
1f52 23				inc hl 
1f53 77				ld (hl),a 
1f54			 
1f54 21 86 f5			ld hl, cli_loop_stack 
1f57 22 0c f8			ld (cli_loop_sp), hl	 
1f5a				; set bottom of stack 
1f5a 3e 00			ld a,0 
1f5c 77				ld (hl),a 
1f5d 23				inc hl 
1f5e 77				ld (hl),a 
1f5f			 
1f5f				; init extent of current open file 
1f5f			 
1f5f 3e 00			ld a, 0 
1f61 32 59 f8			ld (store_openext), a 
1f64			 
1f64 c9				ret 
1f65			 
1f65			 
1f65			; Cold Start - this is called to setup the whole Forth system 
1f65			 
1f65			forth_init: 
1f65			 
1f65				; setup stack over/under flow checks 
1f65			 
1f65			;	if DEBUG_FORTH_STACK_GUARD 
1f65			;		call chk_stk_init 
1f65			;	endif 
1f65			 
1f65				; enable auto display updates (slow.....) 
1f65			 
1f65 3e 01			ld a, 1 
1f67 32 24 f8			ld (cli_autodisplay), a 
1f6a			 
1f6a			 
1f6a			 
1f6a				; show start up screen 
1f6a			 
1f6a cd d5 0a			call clear_display 
1f6d			 
1f6d 3e 00			ld a,0 
1f6f 32 46 f8			ld (f_cursor_ptr), a 
1f72			 
1f72				; set start of word list in start of ram - for use when creating user words 
1f72			 
1f72 21 00 80			ld hl, baseram 
1f75 22 1a f1			ld (os_last_new_uword), hl 
1f78 cd 1e 1f			call user_word_eol 
1f7b				 
1f7b			;		call display_data_sp 
1f7b			;		call next_page_prompt 
1f7b			 
1f7b			 
1f7b			 
1f7b			 
1f7b c9				ret 
1f7c			 
1f7c .. 00		.bootforth: db " Forth Kernel Init ",0 
1f90			 
1f90			; TODO push to stack 
1f90			 
1f90			;  
1f90			 
1f90			if FORTH_PARSEV2 
1f90			 
1f90			 
1f90				include "forth_parserv2.asm" 
1f90			 
1f90			endif 
1f90			 
1f90			 
1f90			; parse cli version 1 
1f90			 
1f90			if FORTH_PARSEV1 
1f90			 
1f90			 
1f90			 
1f90			      include "forth_parserv1.asm" 
1f90			endif 
1f90				 
1f90			if FORTH_PARSEV3 
1f90			 
1f90			 
1f90			 
1f90			      include "forth_parserv3.asm" 
1f90				include "forth_wordsv3.asm" 
1f90			endif 
1f90			 
1f90			if FORTH_PARSEV4 
1f90			 
1f90			 
1f90			 
1f90			      include "forth_parserv4.asm" 
1f90				include "forth_wordsv4.asm" 
1f90			endif 
1f90			 
1f90			if FORTH_PARSEV5 
1f90			 
1f90			 
1f90			 
1f90			      include "forth_parserv5.asm" 
1f90			 
1f90			 
1f90			; A better parser without using malloc and string copies all over the place.  
1f90			; Exec in situ should be faster 
1f90			 
1f90			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f90			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f90			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f90			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f90			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f90			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f90			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f90			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f90			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f90			 
1f90			; Core word preamble macro 
1f90			 
1f90			CWHEAD:   macro nxtword opcode lit len opflags 
1f90				db WORD_SYS_CORE+opcode             
1f90				; internal op code number 
1f90				dw nxtword            
1f90				; link to next dict word block 
1f90				db len + 1 
1f90				; literal length of dict word inc zero term 
1f90				db lit,0              
1f90				; literal dict word 
1f90			        ; TODO db opflags        
1f90				endm 
1f90			 
1f90			 
1f90			NEXTW: macro  
1f90				jp macro_next 
1f90				endm 
1f90			 
1f90			macro_next: 
1f90			if DEBUG_FORTH_PARSE_KEY 
1f90				DMARK "NXT" 
1f90				CALLMONITOR 
1f90			endif	 
1f90			;	inc hl  ; skip token null term  
1f90 ed 4b 28 f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f94 ed 5b 26 f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f98 2a 1e f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f9b			if DEBUG_FORTH_PARSE_KEY 
1f9b				DMARK "}AA" 
1f9b				CALLMONITOR 
1f9b			endif	 
1f9b c3 9e 20			jp execnext 
1f9e				;jp exec1 
1f9e			       
1f9e			 
1f9e			 
1f9e			; Another go at the parser to compile  
1f9e			 
1f9e			 
1f9e			; TODO rework parser to change all of the string words to byte tokens 
1f9e			; TODO do a search for  
1f9e			 
1f9e			; TODO first run normal parser to zero term sections 
1f9e			; TODO for each word do a token look up to get the op code 
1f9e			; TODO need some means to flag to the exec that this is a byte code form    
1f9e			 
1f9e			 
1f9e			forthcompile: 
1f9e			 
1f9e			; 
1f9e			; line parse: 
1f9e			;       parse raw input buffer 
1f9e			;       tokenise the words 
1f9e			;       malloc new copy (for looping etc) 
1f9e			;       copy to malloc + current pc in line to start of string and add line term 
1f9e			;       save on new rsp 
1f9e			; 
1f9e			 
1f9e			; hl to point to the line to tokenise 
1f9e			 
1f9e			;	push hl 
1f9e 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
1fa1			 
1fa1			;	ld a,0		; string term on input 
1fa1			;	call strlent 
1fa1			 
1fa1			;	ld (os_tok_len), hl	 ; save string length 
1fa1			 
1fa1			;if DEBUG_FORTH_TOK 
1fa1			;	ex de,hl		 
1fa1			;endif 
1fa1			 
1fa1			;	pop hl 		; get back string pointer 
1fa1			 
1fa1			if DEBUG_FORTH_TOK 
1fa1						DMARK "TOc" 
1fa1				CALLMONITOR 
1fa1			endif 
1fa1 7e			.cptoken2:    ld a,(hl) 
1fa2 23				inc hl 
1fa3 fe 7f			cp FORTH_END_BUFFER 
1fa5 28 29			jr z, .cptokendone2 
1fa7 fe 00			cp 0 
1fa9 28 25			jr z, .cptokendone2 
1fab fe 22			cp '"' 
1fad 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1faf fe 20			cp ' ' 
1fb1 20 ee			jr nz,  .cptoken2 
1fb3			 
1fb3			; TODO consume comments held between ( and ) 
1fb3			 
1fb3				; we have a space so change to zero term for dict match later 
1fb3 2b				dec hl 
1fb4 3e 00			ld a,0 
1fb6 77				ld (hl), a 
1fb7 23				inc hl 
1fb8 18 e7			jr .cptoken2 
1fba				 
1fba			 
1fba			.cptokenstr2: 
1fba				; skip all white space until either eol (because forgot to term) or end double quote 
1fba			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fba				;inc hl ; skip current double quote 
1fba 7e				ld a,(hl) 
1fbb 23				inc hl 
1fbc fe 22			cp '"' 
1fbe 28 e1			jr z, .cptoken2 
1fc0 fe 7f			cp FORTH_END_BUFFER 
1fc2 28 0c			jr z, .cptokendone2 
1fc4 fe 00			cp 0 
1fc6 28 08			jr z, .cptokendone2 
1fc8 fe 20			cp ' ' 
1fca 28 02			jr z, .cptmp2 
1fcc 18 ec			jr .cptokenstr2 
1fce			 
1fce			.cptmp2:	; we have a space so change to zero term for dict match later 
1fce				;dec hl 
1fce				;ld a,"-"	; TODO remove this when working 
1fce				;ld (hl), a 
1fce				;inc hl 
1fce 18 ea			jr .cptokenstr2 
1fd0			 
1fd0			.cptokendone2: 
1fd0				;inc hl 
1fd0 3e 7f			ld a, FORTH_END_BUFFER 
1fd2 77				ld (hl),a 
1fd3 23				inc hl 
1fd4 3e 21			ld a, '!' 
1fd6 77				ld (hl),a 
1fd7			 
1fd7 2a 1e f1			ld hl,(os_tok_ptr) 
1fda			         
1fda			if DEBUG_FORTH_TOK 
1fda						DMARK "Tc1" 
1fda				CALLMONITOR 
1fda			endif 
1fda			 
1fda				; push exec string to top of return stack 
1fda				FORTH_RSP_NEXT 
1fda cd ce 1b			call macro_forth_rsp_next 
1fdd				endm 
# End of macro FORTH_RSP_NEXT
1fdd c9				ret 
1fde			 
1fde			; Another go at the parser need to simplify the process 
1fde			 
1fde			forthparse: 
1fde			 
1fde			; 
1fde			; line parse: 
1fde			;       parse raw input buffer 
1fde			;       tokenise the words 
1fde			;       malloc new copy (for looping etc) 
1fde			;       copy to malloc + current pc in line to start of string and add line term 
1fde			;       save on new rsp 
1fde			; 
1fde			 
1fde			; hl to point to the line to tokenise 
1fde			 
1fde			;	push hl 
1fde 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
1fe1			 
1fe1			;	ld a,0		; string term on input 
1fe1			;	call strlent 
1fe1			 
1fe1			;	ld (os_tok_len), hl	 ; save string length 
1fe1			 
1fe1			;if DEBUG_FORTH_TOK 
1fe1			;	ex de,hl		 
1fe1			;endif 
1fe1			 
1fe1			;	pop hl 		; get back string pointer 
1fe1			 
1fe1			if DEBUG_FORTH_TOK 
1fe1						DMARK "TOK" 
1fe1				CALLMONITOR 
1fe1			endif 
1fe1 7e			.ptoken2:    ld a,(hl) 
1fe2 23				inc hl 
1fe3 fe 7f			cp FORTH_END_BUFFER 
1fe5 28 29			jr z, .ptokendone2 
1fe7 fe 00			cp 0 
1fe9 28 25			jr z, .ptokendone2 
1feb fe 22			cp '"' 
1fed 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fef fe 20			cp ' ' 
1ff1 20 ee			jr nz,  .ptoken2 
1ff3			 
1ff3			; TODO consume comments held between ( and ) 
1ff3			 
1ff3				; we have a space so change to zero term for dict match later 
1ff3 2b				dec hl 
1ff4 3e 00			ld a,0 
1ff6 77				ld (hl), a 
1ff7 23				inc hl 
1ff8 18 e7			jr .ptoken2 
1ffa				 
1ffa			 
1ffa			.ptokenstr2: 
1ffa				; skip all white space until either eol (because forgot to term) or end double quote 
1ffa			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1ffa				;inc hl ; skip current double quote 
1ffa 7e				ld a,(hl) 
1ffb 23				inc hl 
1ffc fe 22			cp '"' 
1ffe 28 e1			jr z, .ptoken2 
2000 fe 7f			cp FORTH_END_BUFFER 
2002 28 0c			jr z, .ptokendone2 
2004 fe 00			cp 0 
2006 28 08			jr z, .ptokendone2 
2008 fe 20			cp ' ' 
200a 28 02			jr z, .ptmp2 
200c 18 ec			jr .ptokenstr2 
200e			 
200e			.ptmp2:	; we have a space so change to zero term for dict match later 
200e				;dec hl 
200e				;ld a,"-"	; TODO remove this when working 
200e				;ld (hl), a 
200e				;inc hl 
200e 18 ea			jr .ptokenstr2 
2010			 
2010			.ptokendone2: 
2010				;inc hl 
2010 3e 7f			ld a, FORTH_END_BUFFER 
2012 77				ld (hl),a 
2013 23				inc hl 
2014 3e 21			ld a, '!' 
2016 77				ld (hl),a 
2017			 
2017 2a 1e f1			ld hl,(os_tok_ptr) 
201a			         
201a			if DEBUG_FORTH_TOK 
201a						DMARK "TK1" 
201a				CALLMONITOR 
201a			endif 
201a			 
201a				; push exec string to top of return stack 
201a				FORTH_RSP_NEXT 
201a cd ce 1b			call macro_forth_rsp_next 
201d				endm 
# End of macro FORTH_RSP_NEXT
201d c9				ret 
201e			 
201e			; 
201e			;	; malloc size + buffer pointer + if is loop flag 
201e			;	ld hl,(os_tok_len) 		 ; get string length 
201e			; 
201e			;	ld a,l 
201e			; 
201e			;	cp 0			; we dont want to use a null string 
201e			;	ret z 
201e			; 
201e			;;	add 3    ; prefix malloc with buffer for current word ptr 
201e			; 
201e			;	add 5     ; TODO when certain not over writing memory remove 
201e			; 
201e			;		 
201e			; 
201e			;if DEBUG_FORTH_TOK 
201e			;			DMARK "TKE" 
201e			;	CALLMONITOR 
201e			;endif 
201e			; 
201e			;	ld l,a 
201e			;	ld h,0 
201e			;;	push hl   ; save required space for the copy later 
201e			;	call malloc 
201e			;if DEBUG_FORTH_TOK 
201e			;			DMARK "TKM" 
201e			;	CALLMONITOR 
201e			;endif 
201e			;	if DEBUG_FORTH_MALLOC_GUARD 
201e			;		push af 
201e			;		call ishlzero 
201e			;;		ld a, l 
201e			;;		add h 
201e			;;		cp 0 
201e			;		pop af 
201e			;		 
201e			;		call z,malloc_error 
201e			;	endif 
201e			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
201e			; 
201e			; 
201e			;if DEBUG_FORTH_TOK 
201e			;			DMARK "TKR" 
201e			;	CALLMONITOR 
201e			;endif 
201e			; 
201e			;	FORTH_RSP_NEXT 
201e			; 
201e			;	;inc hl	 ; go past current buffer pointer 
201e			;	;inc hl 
201e			;	;inc hl   ; and past if loop flag 
201e			;		; TODO Need to set flag  
201e			; 
201e			;	 
201e			;	 
201e			;	ex de,hl	; malloc is dest 
201e			;	ld hl, (os_tok_len) 
201e			;;	pop bc 
201e			;	ld c, l                
201e			;	ld b,0 
201e			;	ld hl, (os_tok_ptr) 
201e			; 
201e			;if DEBUG_FORTH_TOK 
201e			;			DMARK "TKT" 
201e			;	CALLMONITOR 
201e			;endif 
201e			; 
201e			;	; do str cpy 
201e			; 
201e			;	ldir      ; copy byte in hl to de 
201e			; 
201e			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
201e			; 
201e			;if DEBUG_FORTH_TOK 
201e			; 
201e			;			DMARK "TKY" 
201e			;	CALLMONITOR 
201e			;endif 
201e			;	;ld a,0 
201e			;	;ld a,FORTH_END_BUFFER 
201e			;	ex de, hl 
201e			;	;dec hl			 ; go back over the space delim at the end of word 
201e			;	;ld (hl),a 
201e			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
201e			;	ld a,FORTH_END_BUFFER 
201e			;	ld (hl),a 
201e			;	inc hl 
201e			;	ld a,FORTH_END_BUFFER 
201e			;	ld (hl),a 
201e			; 
201e			;	; init the malloc area data 
201e			;	; set pc for in current area 
201e			;	;ld hl, (os_tok_malloc) 
201e			;	;inc hl 
201e			;	;inc hl 
201e			;	;inc hl 
201e			;	;ex de,hl 
201e			;	;ld hl, (os_tok_malloc) 
201e			;	;ld (hl),e 
201e			;	;inc hl 
201e			;	;ld (hl),d 
201e			; 
201e			; 
201e			;	ld hl,(os_tok_malloc) 
201e			;if DEBUG_FORTH_PARSE_KEY 
201e			;			DMARK "TKU" 
201e			;	CALLMONITOR 
201e			;endif 
201e			; 
201e			;	ret 
201e			 
201e			forthexec: 
201e			 
201e			; line exec: 
201e			; forth parser 
201e			 
201e			; 
201e			;       get current exec line on rsp 
201e			 
201e				FORTH_RSP_TOS 
201e cd e5 1b			call macro_forth_rsp_tos 
2021				endm 
# End of macro FORTH_RSP_TOS
2021			 
2021			;       restore current pc - hl points to malloc of data 
2021			 
2021				;ld e, (hl) 
2021				;inc hl 
2021				;ld d, (hl) 
2021				;ex de,hl 
2021			 
2021			 
2021			exec1: 
2021 22 1e f1			ld (os_tok_ptr), hl 
2024			 
2024				; copy our PC to working vars  
2024 22 28 f8			ld (cli_ptr), hl 
2027 22 26 f8			ld (cli_origptr), hl 
202a			 
202a 7e				ld a,(hl) 
202b fe 7f			cp FORTH_END_BUFFER 
202d c8				ret z 
202e			 
202e				; skip any nulls 
202e			 
202e fe 00			cp 0 
2030 20 03			jr nz, .execword 
2032 23				inc hl 
2033 18 ec			jr exec1 
2035			 
2035			 
2035			.execword: 
2035			 
2035			 
2035			 
2035			if DEBUG_FORTH_PARSE_KEY 
2035						DMARK "KYQ" 
2035				CALLMONITOR 
2035			endif 
2035			;       while at start of word: 
2035			; get start of dict (in user area first) 
2035			 
2035 21 00 80		ld hl, baseram 
2038			;ld hl, sysdict 
2038 22 2a f8		ld (cli_nextword),hl 
203b			;           match word at pc 
203b			;           exec word 
203b			;           or push to dsp 
203b			;           forward to next token 
203b			;           if line term pop rsp and exit 
203b			;        
203b			 
203b			if DEBUG_FORTH_PARSE_KEY 
203b						DMARK "KYq" 
203b				CALLMONITOR 
203b			endif 
203b			 
203b			; 
203b			; word comp 
203b			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
203b			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
203b			;    move to start of word  
203b			;    compare word to cli_token 
203b			 
203b			.execpnword:	; HL at start of a word in the dictionary to check 
203b			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
203b			;	ld (cli_ptr), hl 
203b			 
203b 2a 2a f8			ld hl,(cli_nextword) 
203e			 
203e cd e1 20			call forth_tok_next 
2041			; tok next start here 
2041			;	; TODO skip compiled symbol for now 
2041			;	inc hl 
2041			; 
2041			;	; save pointer to next word 
2041			; 
2041			;	; hl now points to the address of the next word pointer  
2041			;	ld e, (hl) 
2041			;	inc hl 
2041			;	ld d, (hl) 
2041			;	inc l 
2041			; 
2041			;	ex de,hl 
2041			;if DEBUG_FORTH_PARSE_NEXTWORD 
2041			;	push bc 
2041			;	ld bc, (cli_nextword) 
2041			;			DMARK "NXW" 
2041			;	CALLMONITOR 
2041			;	pop bc 
2041			;endif 
2041			; tok next end here 
2041 22 2a f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
2044 eb				ex de, hl 
2045			 
2045			 
2045				; save the pointer of the current token - 1 to check against 
2045				 
2045 22 2e f8			ld (cli_token), hl   
2048				; TODO maybe remove below save if no debug 
2048				; save token string ptr for any debug later 
2048 23				inc hl  
2049 22 30 f8			ld (cli_origtoken), hl 
204c 2b				dec hl 
204d				; save pointer to the start of the next dictionay word 
204d 7e				ld a,(hl)   ; get string length 
204e 47				ld b,a 
204f			.execpnwordinc:  
204f 23				inc hl 
2050 10 fd			djnz .execpnwordinc 
2052 22 2c f8			ld (cli_execword), hl      ; save start of this words code 
2055			 
2055				; now check the word token against the string being parsed 
2055			 
2055 2a 2e f8			ld hl,(cli_token) 
2058 23				inc hl     ; skip string length (use zero term instead to end) 
2059 22 2e f8			ld (cli_token), hl 
205c			 
205c			if DEBUG_FORTH_PARSE_KEY 
205c						DMARK "KY2" 
205c			endif 
205c			if DEBUG_FORTH_PARSE_EXEC 
205c				; see if disabled 
205c			 
205c				ld a, (os_view_disable) 
205c				cp '*' 
205c				jr z, .skip 
205c			 
205c				push hl 
205c				push hl 
205c				call clear_display 
205c				ld de, .compword 
205c				ld a, display_row_1 
205c				call str_at_display 
205c				pop de 
205c				ld a, display_row_2 
205c				call str_at_display 
205c				ld hl,(cli_ptr) 
205c				ld a,(hl) 
205c			        ld hl, os_word_scratch 
205c				ld (hl),a 
205c				ld a,0 
205c				inc hl 
205c				ld (hl),a 	 
205c				ld de, os_word_scratch 
205c				ld a, display_row_2+10 
205c				call str_at_display 
205c				call update_display 
205c				ld a, 100 
205c				call aDelayInMS 
205c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
205c				call delay250ms 
205c				endif 
205c				pop hl 
205c			.skip:  
205c			endif	 
205c			.execpnchar:    ; compare char between token and string to parse 
205c			 
205c			if DEBUG_FORTH_PARSE_KEY 
205c						DMARK "Ky3" 
205c			endif 
205c			if DEBUG_FORTH_PARSE_EXEC 
205c				; see if disabled 
205c			 
205c				ld a, (os_view_disable) 
205c				cp '*' 
205c				jr z, .skip2 
205c			 
205c			;	call clear_display 
205c			ld hl,(cli_token) 
205c			ld a,(hl) 
205c			ld (os_word_scratch),a 
205c				ld hl,(cli_ptr) 
205c			ld a,(hl) 
205c				ld (os_word_scratch+1),a 
205c				ld a,0 
205c				ld (os_word_scratch+2),a 
205c				ld de,os_word_scratch 
205c				ld a,display_row_4 
205c				call str_at_display 
205c				call update_display 
205c			.skip2:  
205c			endif 
205c 2a 2e f8			ld hl,(cli_token) 
205f 7e				ld a, (hl)	 ; char in word token 
2060 23				inc hl 		; move to next char 
2061 22 2e f8			ld (cli_token), hl ; and save it 
2064 47				ld b,a 
2065			 
2065 2a 28 f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
2068 7e				ld a,(hl) 
2069 23				inc hl 
206a 22 28 f8			ld (cli_ptr), hl		; move to next char 
206d cd 5e 11			call toUpper 		; make sure the input string matches case 
2070			 
2070			if DEBUG_FORTH_PARSE 
2070			endif 
2070			 
2070				; input stream end of token is a space so get rid of it 
2070			 
2070			;	cp ' ' 
2070			;	jr nz, .pnskipspace 
2070			; 
2070			;	ld a, 0		; make same term as word token term 
2070			; 
2070			;.pnskipspace: 
2070			 
2070			if DEBUG_FORTH_PARSE_KEY 
2070						DMARK "KY7" 
2070			endif 
2070 b8				cp b 
2071 c2 87 20			jp nz, .execpnskipword	 ; no match so move to next word 
2074				 
2074			;    if same 
2074			;       scan for string terms 0 for token and 32 for input 
2074			 
2074				 
2074			if DEBUG_FORTH_PARSE_KEY 
2074						DMARK "KY8" 
2074			endif 
2074			 
2074 80				add b			 
2075 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2077							; TODO need to make sure last word in zero term string is accounted for 
2077 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2079			 
2079			 
2079				; at end of both strings so both are exact match 
2079			 
2079			;       skip ptr for next word 
2079			 
2079 2a 28 f8			ld hl,(cli_ptr) 	; at input string term 
207c 23				inc hl			 ; at next char 
207d 22 28 f8			ld (cli_ptr), hl     ; save for next round of the parser 
2080 22 26 f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2083				 
2083				 
2083			if DEBUG_FORTH_PARSE_KEY 
2083						DMARK "KY3" 
2083			endif 
2083			 
2083			 
2083			 
2083			;       exec code block 
2083			if DEBUG_FORTH_JP 
2083				call clear_display 
2083				call update_display 
2083				call delay1s 
2083				ld hl, (cli_execword)     ; save for next check if no match on this word 
2083				ld a,h 
2083				ld hl, os_word_scratch 
2083				call hexout 
2083				ld hl, (cli_execword)     ; save for next check if no match on this word 
2083				ld a,l 
2083				ld hl, os_word_scratch+2 
2083				call hexout 
2083				ld hl, os_word_scratch+4 
2083				ld a,0 
2083				ld (hl),a 
2083				ld de,os_word_scratch 
2083				call str_at_display 
2083					ld a, display_row_2 
2083					call str_at_display 
2083				ld de, (cli_origtoken) 
2083				ld a, display_row_1+10 
2083					call str_at_display 
2083			 
2083				ld a,display_row_1 
2083				ld de, .foundword 
2083				ld a, display_row_3 
2083				call str_at_display 
2083				call update_display 
2083				call delay1s 
2083				call delay1s 
2083				call delay1s 
2083			endif 
2083			 
2083			if DEBUG_FORTH_PARSE_KEY 
2083						DMARK "KYj" 
2083			endif 
2083				; TODO save the word pointer in this exec 
2083			 
2083 2a 2c f8			ld hl,(cli_execword) 
2086 e9				jp (hl) 
2087			 
2087			 
2087			;    if not same 
2087			;	scan for zero term 
2087			;	get ptr for next word 
2087			;	goto word comp 
2087			 
2087			.execpnskipword:	; get pointer to next word 
2087 2a 2a f8			ld hl,(cli_nextword) 
208a			 
208a 7e				ld a,(hl) 
208b fe 00			cp WORD_SYS_END 
208d			;	cp 0 
208d 28 09			jr z, .execendofdict			 ; at end of words 
208f			 
208f			if DEBUG_FORTH_PARSE_KEY 
208f						DMARK "KY4" 
208f			endif 
208f			if DEBUG_FORTH_PARSE_EXEC 
208f			 
208f				; see if disabled 
208f			 
208f				ld a, (os_view_disable) 
208f				cp '*' 
208f				jr z, .noskip 
208f			 
208f			 
208f				ld de, .nowordfound 
208f				ld a, display_row_3 
208f				call str_at_display 
208f				call update_display 
208f				ld a, 100 
208f				call aDelayInMS 
208f				 
208f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
208f					call delay250ms 
208f				endif 
208f			.noskip:  
208f			 
208f			endif	 
208f			 
208f 2a 26 f8			ld hl,(cli_origptr) 
2092 22 28 f8			ld (cli_ptr),hl 
2095			 
2095			if DEBUG_FORTH_PARSE_KEY 
2095						DMARK "KY5" 
2095			endif 
2095 c3 3b 20			jp .execpnword			; else go to next word 
2098			 
2098			.execendofdict:  
2098			 
2098			if DEBUG_FORTH_PARSE_KEY 
2098						DMARK "KYe" 
2098			endif 
2098			if DEBUG_FORTH_PARSE_EXEC 
2098				; see if disabled 
2098			 
2098				ld a, (os_view_disable) 
2098				cp '*' 
2098				jr z, .ispskip 
2098			 
2098				call clear_display 
2098				call update_display 
2098				call delay1s 
2098				ld de, (cli_origptr) 
2098				ld a, display_row_1 
2098				call str_at_display 
2098				 
2098				ld de, .enddict 
2098				ld a, display_row_3 
2098				call str_at_display 
2098				call update_display 
2098				ld a, 100 
2098				call aDelayInMS 
2098				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2098				call delay1s 
2098				call delay1s 
2098				call delay1s 
2098				endif 
2098			.ispskip:  
2098				 
2098			endif	 
2098			 
2098			 
2098			 
2098				; if the word is not a keyword then must be a literal so push it to stack 
2098			 
2098			; push token to stack to end of word 
2098			 
2098				STACKFRAME ON $1efe $2f9f 
2098				if DEBUG_STACK_IMB 
2098					if ON 
2098						exx 
2098						ld de, $1efe 
2098						ld a, d 
2098						ld hl, curframe 
2098						call hexout 
2098						ld a, e 
2098						ld hl, curframe+2 
2098						call hexout 
2098						ld hl, $1efe 
2098						push hl 
2098						ld hl, $2f9f 
2098						push hl 
2098						exx 
2098					endif 
2098				endif 
2098			endm 
# End of macro STACKFRAME
2098			 
2098 2a 1e f1		ld hl,(os_tok_ptr) 
209b cd 90 1d		call forth_apush 
209e			 
209e				STACKFRAMECHK ON $1efe $2f9f 
209e				if DEBUG_STACK_IMB 
209e					if ON 
209e						exx 
209e						ld hl, $2f9f 
209e						pop de   ; $2f9f 
209e						call cmp16 
209e						jr nz, .spnosame 
209e						ld hl, $1efe 
209e						pop de   ; $1efe 
209e						call cmp16 
209e						jr z, .spfrsame 
209e						.spnosame: call showsperror 
209e						.spfrsame: nop 
209e						exx 
209e					endif 
209e				endif 
209e			endm 
# End of macro STACKFRAMECHK
209e			 
209e			execnext: 
209e			 
209e			if DEBUG_FORTH_PARSE_KEY 
209e						DMARK "KY>" 
209e			endif 
209e			; move past token to next word 
209e			 
209e 2a 1e f1		ld hl, (os_tok_ptr) 
20a1 3e 00		ld a, 0 
20a3 01 ff 00		ld bc, 255     ; input buffer size 
20a6 ed b1		cpir 
20a8			 
20a8			if DEBUG_FORTH_PARSE_KEY 
20a8						DMARK "KY!" 
20a8				CALLMONITOR 
20a8			endif	 
20a8			; TODO this might place hl on the null, so will need to forward on??? 
20a8			;inc hl   ; see if this gets onto the next item 
20a8			 
20a8			 
20a8			; TODO pass a pointer to the buffer to push 
20a8			; TODO call function to push 
20a8			 
20a8			; look for end of input 
20a8			 
20a8			;inc hl 
20a8			;ld a,(hl) 
20a8			;cp FORTH_END_BUFFER 
20a8			;ret z 
20a8			 
20a8			 
20a8 c3 21 20		jp exec1 
20ab			 
20ab			 
20ab			 
20ab			 
20ab			 
20ab			 
20ab			 
20ab			 
20ab			 
20ab			findnexttok: 
20ab			 
20ab				; hl is pointer to move 
20ab				; de is the token to locate 
20ab			 
20ab					if DEBUG_FORTH 
20ab						DMARK "NTK" 
20ab						CALLMONITOR 
20ab					endif 
20ab d5				push de 
20ac			 
20ac			.fnt1:	 
20ac				; find first char of token to locate 
20ac			 
20ac 1a				ld a, (de) 
20ad 4f				ld c,a 
20ae 7e				ld a,(hl) 
20af cd 5e 11			call toUpper 
20b2					if DEBUG_FORTH 
20b2						DMARK "NT1" 
20b2						CALLMONITOR 
20b2					endif 
20b2 b9				cp c 
20b3			 
20b3 28 03			jr z, .fnt2cmpmorefirst	 
20b5			 
20b5				; first char not found move to next char 
20b5			 
20b5 23				inc hl 
20b6 18 f4			jr .fnt1 
20b8			 
20b8			.fnt2cmpmorefirst:	 
20b8				; first char of token found.  
20b8			 
20b8 e5				push hl     ; save start of token just in case it is the right one 
20b9 d9				exx 
20ba e1				pop hl        ; save it to hl' 
20bb d9				exx 
20bc			 
20bc			 
20bc			.fnt2cmpmore:	 
20bc				; compare the rest 
20bc				 
20bc 23				inc hl 
20bd 13				inc de 
20be				 
20be 1a				ld a, (de) 
20bf 4f				ld c,a 
20c0 7e				ld a,(hl) 
20c1 cd 5e 11			call toUpper 
20c4			 
20c4					if DEBUG_FORTH 
20c4						DMARK "NT2" 
20c4						CALLMONITOR 
20c4					endif 
20c4				; c has the token to find char 
20c4				; a has the mem to scan char 
20c4			 
20c4 b9				cp c 
20c5 28 04			jr z,.fntmatch1 
20c7			 
20c7				; they are not the same 
20c7			 
20c7					if DEBUG_FORTH 
20c7						DMARK "NT3" 
20c7						CALLMONITOR 
20c7					endif 
20c7 d1				pop de	; reset de token to look for 
20c8 d5				push de 
20c9 18 e1			jr .fnt1 
20cb				 
20cb			.fntmatch1: 
20cb			 
20cb				; is the same char a null which means we might have a full hit? 
20cb					if DEBUG_FORTH 
20cb						DMARK "NT4" 
20cb						CALLMONITOR 
20cb					endif 
20cb			 
20cb fe 00			cp 0 
20cd 28 0b			jr z, .fntmatchyes 
20cf			 
20cf				; are we at the end of the token to find? 
20cf			 
20cf					if DEBUG_FORTH 
20cf						DMARK "NT5" 
20cf						CALLMONITOR 
20cf					endif 
20cf 3e 00			ld a, 0 
20d1 b9				cp c 
20d2			 
20d2 c2 bc 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
20d5			 
20d5					if DEBUG_FORTH 
20d5						DMARK "NT6" 
20d5						CALLMONITOR 
20d5					endif 
20d5				; token to find is exhusted but no match to stream 
20d5			 
20d5				; restore tok pointer and continue on 
20d5 d1				pop de 
20d6 d5				push de 
20d7 c3 ac 20			jp .fnt1 
20da			 
20da			 
20da			.fntmatchyes: 
20da			 
20da				; hl now contains the end of the found token 
20da			 
20da				; get rid of saved token pointer to find 
20da			 
20da d1				pop de 
20db			 
20db					if DEBUG_FORTH 
20db						DMARK "NT9" 
20db						CALLMONITOR 
20db					endif 
20db			 
20db				; hl will be on the null term so forward on 
20db			 
20db				; get back the saved start of the token 
20db			 
20db d9				exx 
20dc e5				push hl     ; save start of token just in case it is the right one 
20dd d9				exx 
20de e1				pop hl        ; save it to hl 
20df			 
20df c9				ret 
20e0			 
20e0			 
20e0			; LIST needs to find a specific token   
20e0			; FORGET needs to find a spefici token 
20e0			 
20e0			; SAVE needs to find all tokens by flag 
20e0			; WORDS just needs to scan through all  by flag 
20e0			; UWORDS needs to scan through all by flag 
20e0			 
20e0			 
20e0			; given hl as pointer to start of dict look up string 
20e0			; return hl as pointer to start of word block 
20e0			; or 0 if not found 
20e0			 
20e0			forth_find_tok: 
20e0 c9				ret 
20e1			 
20e1			; given hl as pointer to dict structure 
20e1			; move to the next dict block structure 
20e1			 
20e1			forth_tok_next: 
20e1				; hl now points to the address of the next word pointer  
20e1				; TODO skip compiled symbol for now 
20e1			;	push de 
20e1 23				inc hl 
20e2 5e				ld e, (hl) 
20e3 23				inc hl 
20e4 56				ld d, (hl) 
20e5 23				inc hl 
20e6			 
20e6 eb				ex de,hl 
20e7			if DEBUG_FORTH_PARSE_NEXTWORD 
20e7				push bc 
20e7				ld bc, (cli_nextword) 
20e7						DMARK "NXW" 
20e7				CALLMONITOR 
20e7				pop bc 
20e7			endif 
20e7			;	pop de	 
20e7 c9				ret 
20e8			 
20e8			 
20e8			 
20e8			; eof 
# End of file forth_parserv5.asm
20e8				include "forth_wordsv4.asm" 
20e8			 
20e8			; the core word dictionary v4 
20e8			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20e8			 
20e8			; this is a linked list for each of the system words used 
20e8			; user defined words will follow the same format but will be in ram 
20e8			 
20e8			 
20e8			; 
20e8			; 
20e8			; define linked list: 
20e8			; 
20e8			; 1. compiled byte op code 
20e8			; 2. len of text word 
20e8			; 3. text word 
20e8			; 4. ptr to next dictionary word 
20e8			; 5. asm, calls etc for the word 
20e8			; 
20e8			;  if 1 == 0 then last word in dict  
20e8			;   
20e8			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20e8			;  
20e8			;  
20e8			; create basic standard set of words 
20e8			; 
20e8			;  
20e8			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20e8			; 2DUP 2DROP 2SWAP  
20e8			; @ C@ - get byte  
20e8			; ! C! - store byte 
20e8			; 0< true if less than zero 
20e8			; 0= true if zero 
20e8			; < >  
20e8			; = true if same 
20e8			; variables 
20e8			 
20e8			 
20e8			; Hardware specific words I may need 
20e8			; 
20e8			; IN OUT  
20e8			; calls to key util functions 
20e8			; calls to hardward abstraction stuff 
20e8			; easy control of frame buffers and lcd i/o 
20e8			; keyboard  
20e8			 
20e8			 
20e8			;DICT: macro 
20e8			; op_code, len, word, next 
20e8			;    word: 
20e8			;    db op_code 
20e8			;    ds word zero term 
20e8			;    dw next 
20e8			;    endm 
20e8			 
20e8			 
20e8			 
20e8			 
20e8			; op code 1 is a flag for user define words which are to be handled differently 
20e8			 
20e8			 
20e8			; 
20e8			; 
20e8			;    TODO on entry to a word this should be the expected environment 
20e8			;    hl - tos value if number then held, if string this is the ptr 
20e8			;    de -  
20e8			 
20e8			 
20e8			; opcode ranges 
20e8			; 0 - end of word dict 
20e8			; 255 - user define words 
20e8			 
20e8			sysdict: 
20e8			include "forth_opcodes.asm" 
20e8			; op codes for forth keywords 
20e8			; free to use code 0  
20e8				OPCODE_HEAP: equ  1 
20e8				OPCODE_EXEC: equ 2 
20e8				OPCODE_DUP: equ 3 
20e8				OPCODE_SWAP: equ 4 
20e8				OPCODE_COLN: equ 5 
20e8				OPCODE_SCOLN: equ 6 
20e8				OPCODE_DROP: equ 7 
20e8				OPCODE_DUP2: equ 8 
20e8				OPCODE_DROP2: equ 9 
20e8				OPCODE_SWAP2: equ 10 
20e8				OPCODE_AT: equ 11 
20e8				OPCODE_CAT: equ 12 
20e8				OPCODE_BANG: equ 13 
20e8				OPCODE_CBANG: equ 14 
20e8				OPCODE_SCALL: equ 15 
20e8				OPCODE_DEPTH: equ 16 
20e8				OPCODE_OVER: equ 17 
20e8				OPCODE_PAUSE: equ 18 
20e8				OPCODE_PAUSES: equ 19 
20e8				OPCODE_ROT: equ 20 
20e8			;free to reuse	OPCODE_WORDS: equ 21 
20e8			        OPCODE_NOT: equ 21 
20e8				OPCODE_UWORDS: equ 22 
20e8				OPCODE_BP: equ 23 
20e8				OPCODE_MONITOR: equ 24  
20e8				OPCODE_MALLOC: equ 25 
20e8				OPCODE_FREE: equ 26 
20e8				OPCODE_LIST: equ 27 
20e8				OPCODE_FORGET: equ 28 
20e8				OPCODE_NOP: equ 29 
20e8				OPCODE_COMO: equ 30 
20e8				OPCODE_COMC: equ 31 
20e8			;free to reuse	OPCODE_ENDCORE: equ 32 
20e8				OPCODE_AFTERSOUND: equ 33 
20e8				OPCODE_GP2: equ 34 
20e8				OPCODE_GP3: equ 35 
20e8				OPCODE_GP4: equ 36 
20e8				OPCODE_SIN: equ 37 
20e8				OPCODE_SOUT: equ 38 
20e8				OPCODE_SPIO: equ 39 
20e8				OPCODE_SPICEH: equ 40 
20e8				OPCODE_SPIOb: equ 41 
20e8				OPCODE_SPII: equ 42 
20e8				OPCODE_SESEL: equ 43 
20e8				OPCODE_CARTDEV: equ 44 
20e8			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20e8				OPCODE_FB: equ 46 
20e8				OPCODE_EMIT: equ 47 
20e8				OPCODE_DOTH: equ 48 
20e8				OPCODE_DOTF: equ 49 
20e8				OPCODE_DOT: equ 50 
20e8				OPCODE_CLS: equ 51 
20e8				OPCODE_DRAW: equ 52 
20e8				OPCODE_DUMP: equ 53 
20e8				OPCODE_CDUMP: equ 54 
20e8				OPCODE_DAT: equ 55 
20e8				OPCODE_HOME: equ 56 
20e8				OPCODE_SPACE: equ 57 
20e8				OPCODE_SPACES: equ 58 
20e8				OPCODE_SCROLL: equ 59 
20e8				OPCODE_ATQ: equ 60 
20e8				OPCODE_AUTODSP: equ 61 
20e8				OPCODE_MENU: equ 62 
20e8			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20e8				OPCODE_THEN: equ 64 
20e8				OPCODE_ELSE: equ 65 
20e8				OPCODE_DO: equ 66 
20e8				OPCODE_LOOP: equ 67 
20e8				OPCODE_I: equ 68 
20e8				OPCODE_DLOOP: equ 69  
20e8				OPCODE_REPEAT: equ 70  
20e8				OPCODE_UNTIL: equ 71 
20e8				OPCODE_ENDFLOW: equ 72 
20e8				OPCODE_WAITK: equ 73 
20e8				OPCODE_ACCEPT: equ 74 
20e8				OPCODE_EDIT: equ 75 
20e8			;free to reuse	OPCODE_ENDKEY: equ 76 
20e8				OPCODE_LZERO: equ 77 
20e8				OPCODE_TZERO: equ 78 
20e8				OPCODE_LESS: equ 79 
20e8				OPCODE_GT: equ 80 
20e8				OPCODE_EQUAL: equ 81  
20e8			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20e8				OPCODE_NEG: equ 83 
20e8				OPCODE_DIV: equ 84 
20e8				OPCODE_MUL: equ 85 
20e8				OPCODE_MIN: equ 86 
20e8				OPCODE_MAX: equ 87 
20e8				OPCODE_RND16: equ 88 
20e8				OPCODE_RND8: equ 89 
20e8				OPCODE_RND: equ 90 
20e8			;free to reuse	OPCODE_ENDMATHS: equ 91  
20e8				OPCODE_BYNAME: equ 92 
20e8				OPCODE_DIR: equ 93 
20e8				OPCODE_SAVE: equ 94 
20e8				OPCODE_LOAD: equ 95 
20e8				OPCODE_BSAVE: equ 96 
20e8				OPCODE_BLOAD: equ 97 
20e8				OPCODE_SEO: equ 98  
20e8				OPCODE_SEI: equ 99 
20e8				OPCODE_SFREE: equ 100 
20e8				OPCODE_SIZE: equ 101 
20e8				OPCODE_CREATE: equ 102 
20e8				OPCODE_APPEND: equ 103 
20e8				OPCODE_SDEL: equ 104 
20e8				OPCODE_OPEN: equ 105 
20e8				OPCODE_READ: equ 106 
20e8				OPCODE_EOF: equ 106 
20e8				OPCODE_FORMAT: equ 107 
20e8				OPCODE_LABEL: equ 108 
20e8				OPCODE_LABELS: equ 109 
20e8			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20e8				OPCODE_UPPER: equ 111 
20e8				OPCODE_LOWER: equ 112 
20e8				OPCODE_SUBSTR: equ 113 
20e8				OPCODE_LEFT: equ 114 
20e8				OPCODE_RIGHT: equ 115 
20e8				OPCODE_STR2NUM: equ 116 
20e8				OPCODE_NUM2STR: equ 117 
20e8				OPCODE_CONCAT: equ 118 
20e8				OPCODE_FIND: equ 119 
20e8				OPCODE_LEN: equ 120 
20e8				OPCODE_CHAR: equ 121 
20e8			; free to reuse	OPCODE_STRLEN: equ 122 
20e8			; free to reuse	OPCODE_ENDSTR: equ 123 
20e8				OPCODE_V0S: equ 124 
20e8				OPCODE_V0Q: equ 125 
20e8				OPCODE_V1S: equ 126 
20e8				OPCODE_V1Q: equ 127 
20e8				OPCODE_V2S: equ 128 
20e8				OPCODE_V2Q: equ 129 
20e8				OPCODE_V3S: equ 130 
20e8				OPCODE_V3Q: equ 131 
20e8			;free to reuse	OPCODE_END: equ 132 
20e8				OPCODE_ZDUP: equ 133 
20e8			 
20e8			; eof 
# End of file forth_opcodes.asm
20e8			 
20e8			include "forth_words_core.asm" 
20e8			 
20e8			; | ## Core Words 
20e8			 
20e8			;if MALLOC_4 
20e8			 
20e8			.HEAP: 
20e8				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20e8 15				db WORD_SYS_CORE+OPCODE_HEAP             
20e9 27 21			dw .EXEC            
20eb 05				db 4 + 1 
20ec .. 00			db "HEAP",0              
20f1				endm 
# End of macro CWHEAD
20f1			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20f1			; | | u1 - Current number of bytes in the heap 
20f1			; | | u2 - Remaining bytes left on the heap 
20f1			; | |  
20f1			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20f1			 
20f1			 
20f1					if DEBUG_FORTH_WORDS_KEY 
20f1						DMARK "HEP" 
20f1 f5				push af  
20f2 3a 06 21			ld a, (.dmark)  
20f5 32 77 fb			ld (debug_mark),a  
20f8 3a 07 21			ld a, (.dmark+1)  
20fb 32 78 fb			ld (debug_mark+1),a  
20fe 3a 08 21			ld a, (.dmark+2)  
2101 32 79 fb			ld (debug_mark+2),a  
2104 18 03			jr .pastdmark  
2106 ..			.dmark: db "HEP"  
2109 f1			.pastdmark: pop af  
210a			endm  
# End of macro DMARK
210a						CALLMONITOR 
210a cd 97 16			call break_point_state  
210d				endm  
# End of macro CALLMONITOR
210d					endif 
210d 2a 0a 80				ld hl, (free_list )      
2110 11 0e 80				ld de, heap_start 
2113			 
2113 ed 52				sbc hl, de  
2115			 
2115 cd 27 1c				call forth_push_numhl 
2118			 
2118			 
2118 ed 5b 0a 80			ld de, (free_list )      
211c 21 03 ee				ld hl, heap_end 
211f			 
211f ed 52				sbc hl, de 
2121			 
2121 cd 27 1c				call forth_push_numhl 
2124					 
2124			 
2124					 
2124			 
2124			 
2124			 
2124					NEXTW 
2124 c3 90 1f			jp macro_next 
2127				endm 
# End of macro NEXTW
2127			;endif 
2127			 
2127			.EXEC: 
2127				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2127 16				db WORD_SYS_CORE+OPCODE_EXEC             
2128 c3 21			dw .STKEXEC            
212a 05				db 4 + 1 
212b .. 00			db "EXEC",0              
2130				endm 
# End of macro CWHEAD
2130			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
2130			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2130			; | | 
2130			; | |   
2130				STACKFRAME OFF $5efe $5f9f 
2130				if DEBUG_STACK_IMB 
2130					if OFF 
2130						exx 
2130						ld de, $5efe 
2130						ld a, d 
2130						ld hl, curframe 
2130						call hexout 
2130						ld a, e 
2130						ld hl, curframe+2 
2130						call hexout 
2130						ld hl, $5efe 
2130						push hl 
2130						ld hl, $5f9f 
2130						push hl 
2130						exx 
2130					endif 
2130				endif 
2130			endm 
# End of macro STACKFRAME
2130			 
2130					if DEBUG_FORTH_WORDS_KEY 
2130						DMARK "EXE" 
2130 f5				push af  
2131 3a 45 21			ld a, (.dmark)  
2134 32 77 fb			ld (debug_mark),a  
2137 3a 46 21			ld a, (.dmark+1)  
213a 32 78 fb			ld (debug_mark+1),a  
213d 3a 47 21			ld a, (.dmark+2)  
2140 32 79 fb			ld (debug_mark+2),a  
2143 18 03			jr .pastdmark  
2145 ..			.dmark: db "EXE"  
2148 f1			.pastdmark: pop af  
2149			endm  
# End of macro DMARK
2149						CALLMONITOR 
2149 cd 97 16			call break_point_state  
214c				endm  
# End of macro CALLMONITOR
214c					endif 
214c			 
214c				FORTH_DSP_VALUEHL 
214c cd 1e 1e			call macro_dsp_valuehl 
214f				endm 
# End of macro FORTH_DSP_VALUEHL
214f			 
214f				FORTH_DSP_POP 
214f cd d6 1e			call macro_forth_dsp_pop 
2152				endm 
# End of macro FORTH_DSP_POP
2152			 
2152					if DEBUG_FORTH_WORDS 
2152						DMARK "EX1" 
2152 f5				push af  
2153 3a 67 21			ld a, (.dmark)  
2156 32 77 fb			ld (debug_mark),a  
2159 3a 68 21			ld a, (.dmark+1)  
215c 32 78 fb			ld (debug_mark+1),a  
215f 3a 69 21			ld a, (.dmark+2)  
2162 32 79 fb			ld (debug_mark+2),a  
2165 18 03			jr .pastdmark  
2167 ..			.dmark: db "EX1"  
216a f1			.pastdmark: pop af  
216b			endm  
# End of macro DMARK
216b						CALLMONITOR 
216b cd 97 16			call break_point_state  
216e				endm  
# End of macro CALLMONITOR
216e					endif 
216e			;	ld e,(hl) 
216e			;	inc hl 
216e			;	ld d,(hl) 
216e			;	ex de,hl 
216e			 
216e			;		if DEBUG_FORTH_WORDS 
216e			;			DMARK "EX2" 
216e			;			CALLMONITOR 
216e			;		endif 
216e e5				push hl 
216f			 
216f				;ld a, 0 
216f				;ld a, FORTH_END_BUFFER 
216f cd 67 11			call strlenz 
2172 23				inc hl   ; include zero term to copy 
2173 23				inc hl   ; include term 
2174 23				inc hl   ; include term 
2175 06 00			ld b,0 
2177 4d				ld c,l 
2178 e1				pop hl 
2179 11 1c ef			ld de, execscratch 
217c					if DEBUG_FORTH_WORDS 
217c						DMARK "EX3" 
217c f5				push af  
217d 3a 91 21			ld a, (.dmark)  
2180 32 77 fb			ld (debug_mark),a  
2183 3a 92 21			ld a, (.dmark+1)  
2186 32 78 fb			ld (debug_mark+1),a  
2189 3a 93 21			ld a, (.dmark+2)  
218c 32 79 fb			ld (debug_mark+2),a  
218f 18 03			jr .pastdmark  
2191 ..			.dmark: db "EX3"  
2194 f1			.pastdmark: pop af  
2195			endm  
# End of macro DMARK
2195						CALLMONITOR 
2195 cd 97 16			call break_point_state  
2198				endm  
# End of macro CALLMONITOR
2198					endif 
2198 ed b0			ldir 
219a			 
219a			 
219a 21 1c ef			ld hl, execscratch 
219d			 
219d					if DEBUG_FORTH_WORDS 
219d						DMARK "EXe" 
219d f5				push af  
219e 3a b2 21			ld a, (.dmark)  
21a1 32 77 fb			ld (debug_mark),a  
21a4 3a b3 21			ld a, (.dmark+1)  
21a7 32 78 fb			ld (debug_mark+1),a  
21aa 3a b4 21			ld a, (.dmark+2)  
21ad 32 79 fb			ld (debug_mark+2),a  
21b0 18 03			jr .pastdmark  
21b2 ..			.dmark: db "EXe"  
21b5 f1			.pastdmark: pop af  
21b6			endm  
# End of macro DMARK
21b6						CALLMONITOR 
21b6 cd 97 16			call break_point_state  
21b9				endm  
# End of macro CALLMONITOR
21b9					endif 
21b9			 
21b9 cd de 1f			call forthparse 
21bc cd 1e 20			call forthexec 
21bf			;	call forthexec_cleanup 
21bf			;	call forthparse 
21bf			;	call forthexec 
21bf			 
21bf				STACKFRAMECHK OFF $5efe $5f9f 
21bf				if DEBUG_STACK_IMB 
21bf					if OFF 
21bf						exx 
21bf						ld hl, $5f9f 
21bf						pop de   ; $5f9f 
21bf						call cmp16 
21bf						jr nz, .spnosame 
21bf						ld hl, $5efe 
21bf						pop de   ; $5efe 
21bf						call cmp16 
21bf						jr z, .spfrsame 
21bf						.spnosame: call showsperror 
21bf						.spfrsame: nop 
21bf						exx 
21bf					endif 
21bf				endif 
21bf			endm 
# End of macro STACKFRAMECHK
21bf			 
21bf				; an immediate word so no need to process any more words 
21bf c9				ret 
21c0				NEXTW 
21c0 c3 90 1f			jp macro_next 
21c3				endm 
# End of macro NEXTW
21c3			 
21c3			; dead code - old version  
21c3			;	FORTH_RSP_NEXT 
21c3			 
21c3			;  
21c3			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21c3			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21c3			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21c3			;	push hl 
21c3			;	push de 
21c3			;	push bc 
21c3			; 
21c3			; 
21c3			;		if DEBUG_FORTH_WORDS_KEY 
21c3			;			DMARK "EXR" 
21c3			;			CALLMONITOR 
21c3			;		endif 
21c3			; 
21c3			; 
21c3			; 
21c3			;	;v5 FORTH_DSP_VALUE 
21c3			;	FORTH_DSP_VALUEHL 
21c3			; 
21c3			;	; TODO do string type checks 
21c3			; 
21c3			;;v5	inc hl   ; skip type 
21c3			; 
21c3			;	push hl  ; source code  
21c3			;		if DEBUG_FORTH_WORDS 
21c3			;			DMARK "EX1" 
21c3			;			CALLMONITOR 
21c3			;		endif 
21c3			;	ld a, 0 
21c3			;	call strlent 
21c3			; 
21c3			;	inc hl 
21c3			;	inc hl 
21c3			;	inc hl 
21c3			;	inc hl 
21c3			; 
21c3			;	push hl    ; size 
21c3			; 
21c3			;		if DEBUG_FORTH_WORDS 
21c3			;			DMARK "EX2" 
21c3			;			CALLMONITOR 
21c3			;		endif 
21c3			;	call malloc 
21c3			; 
21c3			;	ex de, hl    ; de now contains malloc area 
21c3			;	pop bc   	; get byte count 
21c3			;	pop hl      ; get string to copy 
21c3			; 
21c3			;	push de     ; save malloc for free later 
21c3			; 
21c3			;		if DEBUG_FORTH_WORDS 
21c3			;			DMARK "EX3" 
21c3			;			CALLMONITOR 
21c3			;		endif 
21c3			;	ldir       ; duplicate string 
21c3			; 
21c3			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21c3			;	 
21c3			;	; TODO fix the parse would be better than this...  
21c3			;	ex de, hl 
21c3			;	dec hl 
21c3			;	ld a, 0 
21c3			;	ld (hl), a 
21c3			;	dec hl 
21c3			;	ld a, ' ' 
21c3			;	ld (hl), a 
21c3			;	dec hl 
21c3			;	ld (hl), a 
21c3			; 
21c3			;	dec hl 
21c3			;	ld (hl), a 
21c3			; 
21c3			; 
21c3			;	FORTH_DSP_POP  
21c3			; 
21c3			;	pop hl     
21c3			;	push hl    ; save malloc area 
21c3			; 
21c3			;		if DEBUG_FORTH_WORDS 
21c3			;			DMARK "EX4" 
21c3			;			CALLMONITOR 
21c3			;		endif 
21c3			; 
21c3			;	call forthparse 
21c3			;	call forthexec 
21c3			;	 
21c3			;	pop hl 
21c3			;	if DEBUG_FORTH_WORDS 
21c3			;		DMARK "EX5" 
21c3			;		CALLMONITOR 
21c3			;	endif 
21c3			; 
21c3			;	if FORTH_ENABLE_FREE 
21c3			;	call free 
21c3			;	endif 
21c3			; 
21c3			;	if DEBUG_FORTH_WORDS 
21c3			;		DMARK "EX6" 
21c3			;		CALLMONITOR 
21c3			;	endif 
21c3			; 
21c3			;	pop bc 
21c3			;	pop de 
21c3			;	pop hl 
21c3			;;	FORTH_RSP_POP	  
21c3			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21c3			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21c3			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21c3			; 
21c3			;	if DEBUG_FORTH_WORDS 
21c3			;		DMARK "EX7" 
21c3			;		CALLMONITOR 
21c3			;	endif 
21c3			;	NEXTW 
21c3			 
21c3			.STKEXEC: 
21c3				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21c3 3f				db WORD_SYS_CORE+43             
21c4 0b 23			dw .ZDUP            
21c6 08				db 7 + 1 
21c7 .. 00			db "STKEXEC",0              
21cf				endm 
# End of macro CWHEAD
21cf			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
21cf			 
21cf			 
21cf					if DEBUG_FORTH_WORDS_KEY 
21cf						DMARK "STX" 
21cf f5				push af  
21d0 3a e4 21			ld a, (.dmark)  
21d3 32 77 fb			ld (debug_mark),a  
21d6 3a e5 21			ld a, (.dmark+1)  
21d9 32 78 fb			ld (debug_mark+1),a  
21dc 3a e6 21			ld a, (.dmark+2)  
21df 32 79 fb			ld (debug_mark+2),a  
21e2 18 03			jr .pastdmark  
21e4 ..			.dmark: db "STX"  
21e7 f1			.pastdmark: pop af  
21e8			endm  
# End of macro DMARK
21e8						CALLMONITOR 
21e8 cd 97 16			call break_point_state  
21eb				endm  
# End of macro CALLMONITOR
21eb					endif 
21eb			 
21eb				FORTH_DSP_VALUEHL 
21eb cd 1e 1e			call macro_dsp_valuehl 
21ee				endm 
# End of macro FORTH_DSP_VALUEHL
21ee			 
21ee 22 60 f8			ld (store_tmp1), hl    ; count 
21f1			 
21f1				FORTH_DSP_POP 
21f1 cd d6 1e			call macro_forth_dsp_pop 
21f4				endm 
# End of macro FORTH_DSP_POP
21f4			.stkexec1: 
21f4 2a 60 f8			ld hl, (store_tmp1)   ; count 
21f7 3e 00			ld a, 0 
21f9 bd				cp l 
21fa c8				ret z 
21fb			 
21fb 2b				dec hl 
21fc 22 60 f8			ld (store_tmp1), hl    ; count 
21ff				 
21ff				FORTH_DSP_VALUEHL 
21ff cd 1e 1e			call macro_dsp_valuehl 
2202				endm 
# End of macro FORTH_DSP_VALUEHL
2202 e5				push hl 
2203				 
2203					if DEBUG_FORTH_WORDS 
2203						DMARK "EXp" 
2203 f5				push af  
2204 3a 18 22			ld a, (.dmark)  
2207 32 77 fb			ld (debug_mark),a  
220a 3a 19 22			ld a, (.dmark+1)  
220d 32 78 fb			ld (debug_mark+1),a  
2210 3a 1a 22			ld a, (.dmark+2)  
2213 32 79 fb			ld (debug_mark+2),a  
2216 18 03			jr .pastdmark  
2218 ..			.dmark: db "EXp"  
221b f1			.pastdmark: pop af  
221c			endm  
# End of macro DMARK
221c						CALLMONITOR 
221c cd 97 16			call break_point_state  
221f				endm  
# End of macro CALLMONITOR
221f					endif 
221f				FORTH_DSP_POP 
221f cd d6 1e			call macro_forth_dsp_pop 
2222				endm 
# End of macro FORTH_DSP_POP
2222			 
2222 cd 67 11			call strlenz 
2225 23				inc hl   ; include zero term to copy 
2226 23				inc hl   ; include zero term to copy 
2227 23				inc hl   ; include zero term to copy 
2228 06 00			ld b,0 
222a 4d				ld c,l 
222b e1				pop hl 
222c 11 1c ef			ld de, execscratch 
222f					if DEBUG_FORTH_WORDS 
222f						DMARK "EX3" 
222f f5				push af  
2230 3a 44 22			ld a, (.dmark)  
2233 32 77 fb			ld (debug_mark),a  
2236 3a 45 22			ld a, (.dmark+1)  
2239 32 78 fb			ld (debug_mark+1),a  
223c 3a 46 22			ld a, (.dmark+2)  
223f 32 79 fb			ld (debug_mark+2),a  
2242 18 03			jr .pastdmark  
2244 ..			.dmark: db "EX3"  
2247 f1			.pastdmark: pop af  
2248			endm  
# End of macro DMARK
2248						CALLMONITOR 
2248 cd 97 16			call break_point_state  
224b				endm  
# End of macro CALLMONITOR
224b					endif 
224b ed b0			ldir 
224d			 
224d			 
224d 21 1c ef			ld hl, execscratch 
2250			 
2250					if DEBUG_FORTH_WORDS 
2250						DMARK "EXP" 
2250 f5				push af  
2251 3a 65 22			ld a, (.dmark)  
2254 32 77 fb			ld (debug_mark),a  
2257 3a 66 22			ld a, (.dmark+1)  
225a 32 78 fb			ld (debug_mark+1),a  
225d 3a 67 22			ld a, (.dmark+2)  
2260 32 79 fb			ld (debug_mark+2),a  
2263 18 03			jr .pastdmark  
2265 ..			.dmark: db "EXP"  
2268 f1			.pastdmark: pop af  
2269			endm  
# End of macro DMARK
2269						CALLMONITOR 
2269 cd 97 16			call break_point_state  
226c				endm  
# End of macro CALLMONITOR
226c					endif 
226c			 
226c cd de 1f			call forthparse 
226f 21 1c ef			ld hl, execscratch 
2272					if DEBUG_FORTH_WORDS 
2272						DMARK "EXx" 
2272 f5				push af  
2273 3a 87 22			ld a, (.dmark)  
2276 32 77 fb			ld (debug_mark),a  
2279 3a 88 22			ld a, (.dmark+1)  
227c 32 78 fb			ld (debug_mark+1),a  
227f 3a 89 22			ld a, (.dmark+2)  
2282 32 79 fb			ld (debug_mark+2),a  
2285 18 03			jr .pastdmark  
2287 ..			.dmark: db "EXx"  
228a f1			.pastdmark: pop af  
228b			endm  
# End of macro DMARK
228b						CALLMONITOR 
228b cd 97 16			call break_point_state  
228e				endm  
# End of macro CALLMONITOR
228e					endif 
228e cd 1e 20			call forthexec 
2291			 
2291 c3 f4 21			jp .stkexec1 
2294			 
2294 c9				ret 
2295			 
2295			 
2295			.DUP: 
2295				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2295 17				db WORD_SYS_CORE+OPCODE_DUP             
2296 0b 23			dw .ZDUP            
2298 04				db 3 + 1 
2299 .. 00			db "DUP",0              
229d				endm 
# End of macro CWHEAD
229d			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
229d			 
229d					if DEBUG_FORTH_WORDS_KEY 
229d						DMARK "DUP" 
229d f5				push af  
229e 3a b2 22			ld a, (.dmark)  
22a1 32 77 fb			ld (debug_mark),a  
22a4 3a b3 22			ld a, (.dmark+1)  
22a7 32 78 fb			ld (debug_mark+1),a  
22aa 3a b4 22			ld a, (.dmark+2)  
22ad 32 79 fb			ld (debug_mark+2),a  
22b0 18 03			jr .pastdmark  
22b2 ..			.dmark: db "DUP"  
22b5 f1			.pastdmark: pop af  
22b6			endm  
# End of macro DMARK
22b6						CALLMONITOR 
22b6 cd 97 16			call break_point_state  
22b9				endm  
# End of macro CALLMONITOR
22b9					endif 
22b9			 
22b9					FORTH_DSP 
22b9 cd e4 1d			call macro_forth_dsp 
22bc				endm 
# End of macro FORTH_DSP
22bc			 
22bc 7e					ld a, (HL) 
22bd fe 01				cp DS_TYPE_STR 
22bf 20 25				jr nz, .dupinum 
22c1			 
22c1					; push another string 
22c1			 
22c1					FORTH_DSP_VALUEHL     		 
22c1 cd 1e 1e			call macro_dsp_valuehl 
22c4				endm 
# End of macro FORTH_DSP_VALUEHL
22c4			 
22c4				if DEBUG_FORTH_WORDS 
22c4					DMARK "DUs" 
22c4 f5				push af  
22c5 3a d9 22			ld a, (.dmark)  
22c8 32 77 fb			ld (debug_mark),a  
22cb 3a da 22			ld a, (.dmark+1)  
22ce 32 78 fb			ld (debug_mark+1),a  
22d1 3a db 22			ld a, (.dmark+2)  
22d4 32 79 fb			ld (debug_mark+2),a  
22d7 18 03			jr .pastdmark  
22d9 ..			.dmark: db "DUs"  
22dc f1			.pastdmark: pop af  
22dd			endm  
# End of macro DMARK
22dd					CALLMONITOR 
22dd cd 97 16			call break_point_state  
22e0				endm  
# End of macro CALLMONITOR
22e0				endif 
22e0 cd 95 1c				call forth_push_str 
22e3			 
22e3					NEXTW 
22e3 c3 90 1f			jp macro_next 
22e6				endm 
# End of macro NEXTW
22e6			 
22e6			 
22e6			.dupinum: 
22e6					 
22e6			 
22e6			 
22e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22e6 cd 1e 1e			call macro_dsp_valuehl 
22e9				endm 
# End of macro FORTH_DSP_VALUEHL
22e9			 
22e9				; TODO add floating point number detection 
22e9			 
22e9				if DEBUG_FORTH_WORDS 
22e9					DMARK "DUi" 
22e9 f5				push af  
22ea 3a fe 22			ld a, (.dmark)  
22ed 32 77 fb			ld (debug_mark),a  
22f0 3a ff 22			ld a, (.dmark+1)  
22f3 32 78 fb			ld (debug_mark+1),a  
22f6 3a 00 23			ld a, (.dmark+2)  
22f9 32 79 fb			ld (debug_mark+2),a  
22fc 18 03			jr .pastdmark  
22fe ..			.dmark: db "DUi"  
2301 f1			.pastdmark: pop af  
2302			endm  
# End of macro DMARK
2302					CALLMONITOR 
2302 cd 97 16			call break_point_state  
2305				endm  
# End of macro CALLMONITOR
2305				endif 
2305			 
2305 cd 27 1c				call forth_push_numhl 
2308					NEXTW 
2308 c3 90 1f			jp macro_next 
230b				endm 
# End of macro NEXTW
230b			.ZDUP: 
230b				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
230b 99				db WORD_SYS_CORE+OPCODE_ZDUP             
230c 43 23			dw .SWAP            
230e 05				db 4 + 1 
230f .. 00			db "?DUP",0              
2314				endm 
# End of macro CWHEAD
2314			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2314			 
2314					if DEBUG_FORTH_WORDS_KEY 
2314						DMARK "qDU" 
2314 f5				push af  
2315 3a 29 23			ld a, (.dmark)  
2318 32 77 fb			ld (debug_mark),a  
231b 3a 2a 23			ld a, (.dmark+1)  
231e 32 78 fb			ld (debug_mark+1),a  
2321 3a 2b 23			ld a, (.dmark+2)  
2324 32 79 fb			ld (debug_mark+2),a  
2327 18 03			jr .pastdmark  
2329 ..			.dmark: db "qDU"  
232c f1			.pastdmark: pop af  
232d			endm  
# End of macro DMARK
232d						CALLMONITOR 
232d cd 97 16			call break_point_state  
2330				endm  
# End of macro CALLMONITOR
2330					endif 
2330					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2330 cd 1e 1e			call macro_dsp_valuehl 
2333				endm 
# End of macro FORTH_DSP_VALUEHL
2333			 
2333 e5					push hl 
2334			 
2334					; is it a zero? 
2334			 
2334 3e 00				ld a, 0 
2336 84					add h 
2337 85					add l 
2338			 
2338 e1					pop hl 
2339			 
2339 fe 00				cp 0 
233b 28 03				jr z, .dup2orig 
233d			 
233d			 
233d cd 27 1c				call forth_push_numhl 
2340			 
2340			 
2340				; TODO add floating point number detection 
2340			 
2340			.dup2orig: 
2340			 
2340					NEXTW 
2340 c3 90 1f			jp macro_next 
2343				endm 
# End of macro NEXTW
2343			.SWAP: 
2343				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2343 18				db WORD_SYS_CORE+OPCODE_SWAP             
2344 82 23			dw .COLN            
2346 05				db 4 + 1 
2347 .. 00			db "SWAP",0              
234c				endm 
# End of macro CWHEAD
234c			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
234c					if DEBUG_FORTH_WORDS_KEY 
234c						DMARK "SWP" 
234c f5				push af  
234d 3a 61 23			ld a, (.dmark)  
2350 32 77 fb			ld (debug_mark),a  
2353 3a 62 23			ld a, (.dmark+1)  
2356 32 78 fb			ld (debug_mark+1),a  
2359 3a 63 23			ld a, (.dmark+2)  
235c 32 79 fb			ld (debug_mark+2),a  
235f 18 03			jr .pastdmark  
2361 ..			.dmark: db "SWP"  
2364 f1			.pastdmark: pop af  
2365			endm  
# End of macro DMARK
2365						CALLMONITOR 
2365 cd 97 16			call break_point_state  
2368				endm  
# End of macro CALLMONITOR
2368					endif 
2368			 
2368					FORTH_DSP_VALUEHL 
2368 cd 1e 1e			call macro_dsp_valuehl 
236b				endm 
# End of macro FORTH_DSP_VALUEHL
236b e5					push hl     ; w2 
236c			 
236c					FORTH_DSP_POP 
236c cd d6 1e			call macro_forth_dsp_pop 
236f				endm 
# End of macro FORTH_DSP_POP
236f			 
236f					FORTH_DSP_VALUEHL 
236f cd 1e 1e			call macro_dsp_valuehl 
2372				endm 
# End of macro FORTH_DSP_VALUEHL
2372			 
2372					FORTH_DSP_POP 
2372 cd d6 1e			call macro_forth_dsp_pop 
2375				endm 
# End of macro FORTH_DSP_POP
2375			 
2375 d1					pop de     ; w2	, hl = w1 
2376			 
2376 eb					ex de, hl 
2377 d5					push de 
2378			 
2378 cd 27 1c				call forth_push_numhl 
237b			 
237b e1					pop hl 
237c			 
237c cd 27 1c				call forth_push_numhl 
237f					 
237f			 
237f					NEXTW 
237f c3 90 1f			jp macro_next 
2382				endm 
# End of macro NEXTW
2382			.COLN: 
2382				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2382 19				db WORD_SYS_CORE+OPCODE_COLN             
2383 0e 25			dw .SCOLN            
2385 02				db 1 + 1 
2386 .. 00			db ":",0              
2388				endm 
# End of macro CWHEAD
2388			; | : ( -- )         Create new word | DONE 
2388			 
2388					if DEBUG_FORTH_WORDS_KEY 
2388						DMARK "CLN" 
2388 f5				push af  
2389 3a 9d 23			ld a, (.dmark)  
238c 32 77 fb			ld (debug_mark),a  
238f 3a 9e 23			ld a, (.dmark+1)  
2392 32 78 fb			ld (debug_mark+1),a  
2395 3a 9f 23			ld a, (.dmark+2)  
2398 32 79 fb			ld (debug_mark+2),a  
239b 18 03			jr .pastdmark  
239d ..			.dmark: db "CLN"  
23a0 f1			.pastdmark: pop af  
23a1			endm  
# End of macro DMARK
23a1						CALLMONITOR 
23a1 cd 97 16			call break_point_state  
23a4				endm  
# End of macro CALLMONITOR
23a4					endif 
23a4				STACKFRAME OFF $8efe $989f 
23a4				if DEBUG_STACK_IMB 
23a4					if OFF 
23a4						exx 
23a4						ld de, $8efe 
23a4						ld a, d 
23a4						ld hl, curframe 
23a4						call hexout 
23a4						ld a, e 
23a4						ld hl, curframe+2 
23a4						call hexout 
23a4						ld hl, $8efe 
23a4						push hl 
23a4						ld hl, $989f 
23a4						push hl 
23a4						exx 
23a4					endif 
23a4				endif 
23a4			endm 
# End of macro STACKFRAME
23a4				; get parser buffer length  of new word 
23a4			 
23a4				 
23a4			 
23a4					; move tok past this to start of name defintition 
23a4					; TODO get word to define 
23a4					; TODO Move past word token 
23a4					; TODO get length of string up to the ';' 
23a4			 
23a4 2a 1e f1			ld hl, (os_tok_ptr) 
23a7 23				inc hl 
23a8 23				inc hl 
23a9			 
23a9 3e 3b			ld a, ';' 
23ab cd 72 11			call strlent 
23ae			 
23ae 7d				ld a,l 
23af 32 19 ee			ld (os_new_parse_len), a 
23b2			 
23b2			 
23b2			if DEBUG_FORTH_UWORD 
23b2 ed 5b 1e f1		ld de, (os_tok_ptr) 
23b6						DMARK ":01" 
23b6 f5				push af  
23b7 3a cb 23			ld a, (.dmark)  
23ba 32 77 fb			ld (debug_mark),a  
23bd 3a cc 23			ld a, (.dmark+1)  
23c0 32 78 fb			ld (debug_mark+1),a  
23c3 3a cd 23			ld a, (.dmark+2)  
23c6 32 79 fb			ld (debug_mark+2),a  
23c9 18 03			jr .pastdmark  
23cb ..			.dmark: db ":01"  
23ce f1			.pastdmark: pop af  
23cf			endm  
# End of macro DMARK
23cf				CALLMONITOR 
23cf cd 97 16			call break_point_state  
23d2				endm  
# End of macro CALLMONITOR
23d2			endif 
23d2			 
23d2			; 
23d2			;  new word memory layout: 
23d2			;  
23d2			;    : adg 6666 ;  
23d2			; 
23d2			;    db   1     ; user defined word  
23d2 23				inc hl    
23d3			;    dw   sysdict 
23d3 23				inc hl 
23d4 23				inc hl 
23d5			;    db <word len>+1 (for null) 
23d5 23				inc hl 
23d6			;    db .... <word> 
23d6			; 
23d6			 
23d6 23				inc hl    ; some extras for the word preamble before the above 
23d7 23				inc hl 
23d8 23				inc hl 
23d9 23				inc hl 
23da 23				inc hl 
23db 23				inc hl 
23dc 23				inc hl  
23dd 23				inc hl 
23de 23				inc hl 
23df 23				inc hl 
23e0 23				inc hl 
23e1 23				inc hl 
23e2 23				inc hl 
23e3 23				inc hl     ; TODO how many do we really need?     maybe only 6 
23e4			;       exec word buffer 
23e4			;	<ptr word>   
23e4 23				inc hl 
23e5 23				inc hl 
23e6			;       <word list><null term> 7F final term 
23e6			 
23e6			 
23e6			if DEBUG_FORTH_UWORD 
23e6						DMARK ":02" 
23e6 f5				push af  
23e7 3a fb 23			ld a, (.dmark)  
23ea 32 77 fb			ld (debug_mark),a  
23ed 3a fc 23			ld a, (.dmark+1)  
23f0 32 78 fb			ld (debug_mark+1),a  
23f3 3a fd 23			ld a, (.dmark+2)  
23f6 32 79 fb			ld (debug_mark+2),a  
23f9 18 03			jr .pastdmark  
23fb ..			.dmark: db ":02"  
23fe f1			.pastdmark: pop af  
23ff			endm  
# End of macro DMARK
23ff				CALLMONITOR 
23ff cd 97 16			call break_point_state  
2402				endm  
# End of macro CALLMONITOR
2402			endif 
2402			 
2402				 
2402					; malloc the size 
2402			 
2402 cd d0 11				call malloc 
2405 22 1b ee				ld (os_new_malloc), hl     ; save malloc start 
2408			 
2408			;    db   1     ; user defined word  
2408 3e 01				ld a, WORD_SYS_UWORD  
240a 77					ld (hl), a 
240b				 
240b 23				inc hl    
240c			;    dw   sysdict 
240c 11 e8 20			ld de, sysdict       ; continue on with the scan to the system dict 
240f 73				ld (hl), e 
2410 23				inc hl 
2411 72				ld (hl), d 
2412 23				inc hl 
2413			 
2413			 
2413			;    Setup dict word 
2413			 
2413 23				inc hl 
2414 22 15 ee			ld (os_new_work_ptr), hl     ; save start of dict word  
2417			 
2417				; 1. get length of dict word 
2417			 
2417			 
2417 2a 1e f1			ld hl, (os_tok_ptr) 
241a 23				inc hl 
241b 23				inc hl    ; position to start of dict word 
241c 3e 00			ld a, 0 
241e cd 72 11			call strlent 
2421			 
2421			 
2421 23				inc hl    ; to include null??? 
2422			 
2422				; write length of dict word 
2422			 
2422 ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2426 1b				dec de 
2427 eb				ex de, hl 
2428 73				ld (hl), e 
2429 eb				ex de, hl 
242a			 
242a				 
242a			 
242a				; copy  
242a 4d				ld c, l 
242b 06 00			ld b, 0 
242d ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2431 2a 1e f1			ld hl, (os_tok_ptr) 
2434 23				inc hl 
2435 23				inc hl    ; position to start of dict word 
2436				 
2436			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2436				 
2436				; TODO need to convert word to upper case 
2436			 
2436			ucasetok:	 
2436 7e				ld a,(hl) 
2437 cd 5e 11			call toUpper 
243a 77				ld (hl),a 
243b ed a0			ldi 
243d f2 36 24		 	jp p, ucasetok 
2440			 
2440			 
2440			 
2440				; de now points to start of where the word body code should be placed 
2440 ed 53 15 ee		ld (os_new_work_ptr), de 
2444				; hl now points to the words to throw at forthexec which needs to be copied 
2444 22 13 ee			ld (os_new_src_ptr), hl 
2447			 
2447				; TODO add 'call to forthexec' 
2447			 
2447			if DEBUG_FORTH_UWORD 
2447 c5				push bc 
2448 ed 4b 1b ee		ld bc, (os_new_malloc) 
244c						DMARK ":0x" 
244c f5				push af  
244d 3a 61 24			ld a, (.dmark)  
2450 32 77 fb			ld (debug_mark),a  
2453 3a 62 24			ld a, (.dmark+1)  
2456 32 78 fb			ld (debug_mark+1),a  
2459 3a 63 24			ld a, (.dmark+2)  
245c 32 79 fb			ld (debug_mark+2),a  
245f 18 03			jr .pastdmark  
2461 ..			.dmark: db ":0x"  
2464 f1			.pastdmark: pop af  
2465			endm  
# End of macro DMARK
2465				CALLMONITOR 
2465 cd 97 16			call break_point_state  
2468				endm  
# End of macro CALLMONITOR
2468 c1				pop bc 
2469			endif 
2469			 
2469			 
2469				; create word preamble which should be: 
2469			 
2469			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2469			 
2469				;    ld hl, <word code> 
2469				;    jp user_exec 
2469			        ;    <word code bytes> 
2469			 
2469			 
2469			;	inc de     ; TODO ??? or are we already past the word's null 
2469 eb				ex de, hl 
246a			 
246a 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
246c			 
246c 23				inc hl 
246d 22 0f ee			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2470 23				inc hl 
2471			 
2471 23				inc hl 
2472 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2474			 
2474 01 79 51			ld bc, user_exec 
2477 23				inc hl 
2478 71				ld (hl), c     ; poke address of user_exec 
2479 23				inc hl 
247a 70				ld (hl), b     
247b			 ; 
247b			;	inc hl 
247b			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
247b			; 
247b			; 
247b			;	ld bc, macro_forth_rsp_next 
247b			;	inc hl 
247b			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
247b			;	inc hl 
247b			;	ld (hl), b     
247b			 ; 
247b			;	inc hl 
247b			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
247b			; 
247b			; 
247b			;	inc hl 
247b			;	ld bc, forthexec 
247b			;	ld (hl), c     ; poke address of forthexec 
247b			;	inc hl 
247b			;	ld (hl), b      
247b			; 
247b			;	inc hl 
247b			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
247b			; 
247b			;	ld bc, user_dict_next 
247b			;	inc hl 
247b			;	ld (hl), c     ; poke address of forthexec 
247b			;	inc hl 
247b			;	ld (hl), b      
247b			 
247b				; hl is now where we need to copy the word byte data to save this 
247b			 
247b 23				inc hl 
247c 22 11 ee			ld (os_new_exec), hl 
247f				 
247f				; copy definition 
247f			 
247f eb				ex de, hl 
2480			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2480			;	inc de    ; skip the PC for this parse 
2480 3a 19 ee			ld a, (os_new_parse_len) 
2483 4f				ld c, a 
2484 06 00			ld b, 0 
2486 ed b0			ldir		 ; copy defintion 
2488			 
2488			 
2488				; poke the address of where the new word bytes live for forthexec 
2488			 
2488 2a 0f ee			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
248b			 
248b ed 5b 11 ee		ld de, (os_new_exec)      
248f				 
248f 73				ld (hl), e 
2490 23				inc hl 
2491 72				ld (hl), d 
2492			 
2492					; TODO copy last user dict word next link to this word 
2492					; TODO update last user dict word to point to this word 
2492			; 
2492			; hl f923 de 812a ; bc 811a 
2492			 
2492			if DEBUG_FORTH_UWORD 
2492 c5				push bc 
2493 ed 4b 1b ee		ld bc, (os_new_malloc) 
2497						DMARK ":0A" 
2497 f5				push af  
2498 3a ac 24			ld a, (.dmark)  
249b 32 77 fb			ld (debug_mark),a  
249e 3a ad 24			ld a, (.dmark+1)  
24a1 32 78 fb			ld (debug_mark+1),a  
24a4 3a ae 24			ld a, (.dmark+2)  
24a7 32 79 fb			ld (debug_mark+2),a  
24aa 18 03			jr .pastdmark  
24ac ..			.dmark: db ":0A"  
24af f1			.pastdmark: pop af  
24b0			endm  
# End of macro DMARK
24b0				CALLMONITOR 
24b0 cd 97 16			call break_point_state  
24b3				endm  
# End of macro CALLMONITOR
24b3 c1				pop bc 
24b4			endif 
24b4			if DEBUG_FORTH_UWORD 
24b4 c5				push bc 
24b5 ed 4b 1b ee		ld bc, (os_new_malloc) 
24b9 03				inc bc 
24ba 03				inc bc 
24bb 03				inc bc 
24bc 03				inc bc 
24bd 03				inc bc 
24be 03				inc bc 
24bf 03				inc bc 
24c0 03				inc bc 
24c1			 
24c1						DMARK ":0B" 
24c1 f5				push af  
24c2 3a d6 24			ld a, (.dmark)  
24c5 32 77 fb			ld (debug_mark),a  
24c8 3a d7 24			ld a, (.dmark+1)  
24cb 32 78 fb			ld (debug_mark+1),a  
24ce 3a d8 24			ld a, (.dmark+2)  
24d1 32 79 fb			ld (debug_mark+2),a  
24d4 18 03			jr .pastdmark  
24d6 ..			.dmark: db ":0B"  
24d9 f1			.pastdmark: pop af  
24da			endm  
# End of macro DMARK
24da				CALLMONITOR 
24da cd 97 16			call break_point_state  
24dd				endm  
# End of macro CALLMONITOR
24dd c1				pop bc 
24de			endif 
24de			 
24de			; update word dict linked list for new word 
24de			 
24de			 
24de 2a 1a f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
24e1 23			inc hl     ; move to next work linked list ptr 
24e2			 
24e2 ed 5b 1b ee	ld de, (os_new_malloc)		 ; new next word 
24e6 73			ld (hl), e 
24e7 23			inc hl 
24e8 72			ld (hl), d 
24e9			 
24e9			if DEBUG_FORTH_UWORD 
24e9 ed 4b 1a f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
24ed			endif 
24ed			 
24ed ed 53 1a f1	ld (os_last_new_uword), de      ; update last new uword ptr 
24f1			 
24f1			 
24f1			if DEBUG_FORTH_UWORD 
24f1						DMARK ":0+" 
24f1 f5				push af  
24f2 3a 06 25			ld a, (.dmark)  
24f5 32 77 fb			ld (debug_mark),a  
24f8 3a 07 25			ld a, (.dmark+1)  
24fb 32 78 fb			ld (debug_mark+1),a  
24fe 3a 08 25			ld a, (.dmark+2)  
2501 32 79 fb			ld (debug_mark+2),a  
2504 18 03			jr .pastdmark  
2506 ..			.dmark: db ":0+"  
2509 f1			.pastdmark: pop af  
250a			endm  
# End of macro DMARK
250a				CALLMONITOR 
250a cd 97 16			call break_point_state  
250d				endm  
# End of macro CALLMONITOR
250d			endif 
250d			 
250d				STACKFRAMECHK OFF $8efe $989f 
250d				if DEBUG_STACK_IMB 
250d					if OFF 
250d						exx 
250d						ld hl, $989f 
250d						pop de   ; $989f 
250d						call cmp16 
250d						jr nz, .spnosame 
250d						ld hl, $8efe 
250d						pop de   ; $8efe 
250d						call cmp16 
250d						jr z, .spfrsame 
250d						.spnosame: call showsperror 
250d						.spfrsame: nop 
250d						exx 
250d					endif 
250d				endif 
250d			endm 
# End of macro STACKFRAMECHK
250d			 
250d c9			ret    ; dont process any remaining parser tokens as they form new word 
250e			 
250e			 
250e			 
250e			 
250e			;		NEXT 
250e			.SCOLN: 
250e			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
250e 06				db OPCODE_SCOLN 
250f 5a 25			dw .DROP 
2511 02				db 2 
2512 .. 00			db ";",0           
2514			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2514					if DEBUG_FORTH_WORDS_KEY 
2514						DMARK "SCN" 
2514 f5				push af  
2515 3a 29 25			ld a, (.dmark)  
2518 32 77 fb			ld (debug_mark),a  
251b 3a 2a 25			ld a, (.dmark+1)  
251e 32 78 fb			ld (debug_mark+1),a  
2521 3a 2b 25			ld a, (.dmark+2)  
2524 32 79 fb			ld (debug_mark+2),a  
2527 18 03			jr .pastdmark  
2529 ..			.dmark: db "SCN"  
252c f1			.pastdmark: pop af  
252d			endm  
# End of macro DMARK
252d						CALLMONITOR 
252d cd 97 16			call break_point_state  
2530				endm  
# End of macro CALLMONITOR
2530					endif 
2530					FORTH_RSP_TOS 
2530 cd e5 1b			call macro_forth_rsp_tos 
2533				endm 
# End of macro FORTH_RSP_TOS
2533 e5					push hl 
2534					FORTH_RSP_POP 
2534 cd ef 1b			call macro_forth_rsp_pop 
2537				endm 
# End of macro FORTH_RSP_POP
2537 e1					pop hl 
2538			;		ex de,hl 
2538 22 1e f1				ld (os_tok_ptr),hl 
253b			 
253b			if DEBUG_FORTH_UWORD 
253b						DMARK "SCL" 
253b f5				push af  
253c 3a 50 25			ld a, (.dmark)  
253f 32 77 fb			ld (debug_mark),a  
2542 3a 51 25			ld a, (.dmark+1)  
2545 32 78 fb			ld (debug_mark+1),a  
2548 3a 52 25			ld a, (.dmark+2)  
254b 32 79 fb			ld (debug_mark+2),a  
254e 18 03			jr .pastdmark  
2550 ..			.dmark: db "SCL"  
2553 f1			.pastdmark: pop af  
2554			endm  
# End of macro DMARK
2554				CALLMONITOR 
2554 cd 97 16			call break_point_state  
2557				endm  
# End of macro CALLMONITOR
2557			endif 
2557					NEXTW 
2557 c3 90 1f			jp macro_next 
255a				endm 
# End of macro NEXTW
255a			 
255a			.DROP: 
255a				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
255a 1b				db WORD_SYS_CORE+OPCODE_DROP             
255b 85 25			dw .DUP2            
255d 05				db 4 + 1 
255e .. 00			db "DROP",0              
2563				endm 
# End of macro CWHEAD
2563			; | DROP ( w -- )   drop the TOS item   | DONE 
2563					if DEBUG_FORTH_WORDS_KEY 
2563						DMARK "DRP" 
2563 f5				push af  
2564 3a 78 25			ld a, (.dmark)  
2567 32 77 fb			ld (debug_mark),a  
256a 3a 79 25			ld a, (.dmark+1)  
256d 32 78 fb			ld (debug_mark+1),a  
2570 3a 7a 25			ld a, (.dmark+2)  
2573 32 79 fb			ld (debug_mark+2),a  
2576 18 03			jr .pastdmark  
2578 ..			.dmark: db "DRP"  
257b f1			.pastdmark: pop af  
257c			endm  
# End of macro DMARK
257c						CALLMONITOR 
257c cd 97 16			call break_point_state  
257f				endm  
# End of macro CALLMONITOR
257f					endif 
257f					FORTH_DSP_POP 
257f cd d6 1e			call macro_forth_dsp_pop 
2582				endm 
# End of macro FORTH_DSP_POP
2582					NEXTW 
2582 c3 90 1f			jp macro_next 
2585				endm 
# End of macro NEXTW
2585			.DUP2: 
2585				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2585 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2586 ca 25			dw .DROP2            
2588 05				db 4 + 1 
2589 .. 00			db "2DUP",0              
258e				endm 
# End of macro CWHEAD
258e			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
258e					if DEBUG_FORTH_WORDS_KEY 
258e						DMARK "2DU" 
258e f5				push af  
258f 3a a3 25			ld a, (.dmark)  
2592 32 77 fb			ld (debug_mark),a  
2595 3a a4 25			ld a, (.dmark+1)  
2598 32 78 fb			ld (debug_mark+1),a  
259b 3a a5 25			ld a, (.dmark+2)  
259e 32 79 fb			ld (debug_mark+2),a  
25a1 18 03			jr .pastdmark  
25a3 ..			.dmark: db "2DU"  
25a6 f1			.pastdmark: pop af  
25a7			endm  
# End of macro DMARK
25a7						CALLMONITOR 
25a7 cd 97 16			call break_point_state  
25aa				endm  
# End of macro CALLMONITOR
25aa					endif 
25aa					FORTH_DSP_VALUEHL 
25aa cd 1e 1e			call macro_dsp_valuehl 
25ad				endm 
# End of macro FORTH_DSP_VALUEHL
25ad e5					push hl      ; 2 
25ae			 
25ae					FORTH_DSP_POP 
25ae cd d6 1e			call macro_forth_dsp_pop 
25b1				endm 
# End of macro FORTH_DSP_POP
25b1					 
25b1					FORTH_DSP_VALUEHL 
25b1 cd 1e 1e			call macro_dsp_valuehl 
25b4				endm 
# End of macro FORTH_DSP_VALUEHL
25b4			;		push hl      ; 1 
25b4			 
25b4					FORTH_DSP_POP 
25b4 cd d6 1e			call macro_forth_dsp_pop 
25b7				endm 
# End of macro FORTH_DSP_POP
25b7			 
25b7			;		pop hl       ; 1 
25b7 d1					pop de       ; 2 
25b8			 
25b8 cd 27 1c				call forth_push_numhl 
25bb eb					ex de, hl 
25bc cd 27 1c				call forth_push_numhl 
25bf			 
25bf					 
25bf eb					ex de, hl 
25c0			 
25c0 cd 27 1c				call forth_push_numhl 
25c3 eb					ex de, hl 
25c4 cd 27 1c				call forth_push_numhl 
25c7			 
25c7			 
25c7					NEXTW 
25c7 c3 90 1f			jp macro_next 
25ca				endm 
# End of macro NEXTW
25ca			.DROP2: 
25ca				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
25ca 1d				db WORD_SYS_CORE+OPCODE_DROP2             
25cb f9 25			dw .SWAP2            
25cd 06				db 5 + 1 
25ce .. 00			db "2DROP",0              
25d4				endm 
# End of macro CWHEAD
25d4			; | 2DROP ( w w -- )    Double drop | DONE 
25d4					if DEBUG_FORTH_WORDS_KEY 
25d4						DMARK "2DR" 
25d4 f5				push af  
25d5 3a e9 25			ld a, (.dmark)  
25d8 32 77 fb			ld (debug_mark),a  
25db 3a ea 25			ld a, (.dmark+1)  
25de 32 78 fb			ld (debug_mark+1),a  
25e1 3a eb 25			ld a, (.dmark+2)  
25e4 32 79 fb			ld (debug_mark+2),a  
25e7 18 03			jr .pastdmark  
25e9 ..			.dmark: db "2DR"  
25ec f1			.pastdmark: pop af  
25ed			endm  
# End of macro DMARK
25ed						CALLMONITOR 
25ed cd 97 16			call break_point_state  
25f0				endm  
# End of macro CALLMONITOR
25f0					endif 
25f0					FORTH_DSP_POP 
25f0 cd d6 1e			call macro_forth_dsp_pop 
25f3				endm 
# End of macro FORTH_DSP_POP
25f3					FORTH_DSP_POP 
25f3 cd d6 1e			call macro_forth_dsp_pop 
25f6				endm 
# End of macro FORTH_DSP_POP
25f6					NEXTW 
25f6 c3 90 1f			jp macro_next 
25f9				endm 
# End of macro NEXTW
25f9			.SWAP2: 
25f9				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
25f9 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
25fa 22 26			dw .AT            
25fc 06				db 5 + 1 
25fd .. 00			db "2SWAP",0              
2603				endm 
# End of macro CWHEAD
2603			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2603					if DEBUG_FORTH_WORDS_KEY 
2603						DMARK "2SW" 
2603 f5				push af  
2604 3a 18 26			ld a, (.dmark)  
2607 32 77 fb			ld (debug_mark),a  
260a 3a 19 26			ld a, (.dmark+1)  
260d 32 78 fb			ld (debug_mark+1),a  
2610 3a 1a 26			ld a, (.dmark+2)  
2613 32 79 fb			ld (debug_mark+2),a  
2616 18 03			jr .pastdmark  
2618 ..			.dmark: db "2SW"  
261b f1			.pastdmark: pop af  
261c			endm  
# End of macro DMARK
261c						CALLMONITOR 
261c cd 97 16			call break_point_state  
261f				endm  
# End of macro CALLMONITOR
261f					endif 
261f					NEXTW 
261f c3 90 1f			jp macro_next 
2622				endm 
# End of macro NEXTW
2622			.AT: 
2622				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2622 1f				db WORD_SYS_CORE+OPCODE_AT             
2623 54 26			dw .CAT            
2625 02				db 1 + 1 
2626 .. 00			db "@",0              
2628				endm 
# End of macro CWHEAD
2628			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2628			 
2628					if DEBUG_FORTH_WORDS_KEY 
2628						DMARK "AT." 
2628 f5				push af  
2629 3a 3d 26			ld a, (.dmark)  
262c 32 77 fb			ld (debug_mark),a  
262f 3a 3e 26			ld a, (.dmark+1)  
2632 32 78 fb			ld (debug_mark+1),a  
2635 3a 3f 26			ld a, (.dmark+2)  
2638 32 79 fb			ld (debug_mark+2),a  
263b 18 03			jr .pastdmark  
263d ..			.dmark: db "AT."  
2640 f1			.pastdmark: pop af  
2641			endm  
# End of macro DMARK
2641						CALLMONITOR 
2641 cd 97 16			call break_point_state  
2644				endm  
# End of macro CALLMONITOR
2644					endif 
2644			.getbyteat:	 
2644					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2644 cd 1e 1e			call macro_dsp_valuehl 
2647				endm 
# End of macro FORTH_DSP_VALUEHL
2647					 
2647			;		push hl 
2647				 
2647					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2647 cd d6 1e			call macro_forth_dsp_pop 
264a				endm 
# End of macro FORTH_DSP_POP
264a			 
264a			;		pop hl 
264a			 
264a 7e					ld a, (hl) 
264b			 
264b 6f					ld l, a 
264c 26 00				ld h, 0 
264e cd 27 1c				call forth_push_numhl 
2651			 
2651					NEXTW 
2651 c3 90 1f			jp macro_next 
2654				endm 
# End of macro NEXTW
2654			.CAT: 
2654				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2654 20				db WORD_SYS_CORE+OPCODE_CAT             
2655 7d 26			dw .BANG            
2657 03				db 2 + 1 
2658 .. 00			db "C@",0              
265b				endm 
# End of macro CWHEAD
265b			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
265b					if DEBUG_FORTH_WORDS_KEY 
265b						DMARK "CAA" 
265b f5				push af  
265c 3a 70 26			ld a, (.dmark)  
265f 32 77 fb			ld (debug_mark),a  
2662 3a 71 26			ld a, (.dmark+1)  
2665 32 78 fb			ld (debug_mark+1),a  
2668 3a 72 26			ld a, (.dmark+2)  
266b 32 79 fb			ld (debug_mark+2),a  
266e 18 03			jr .pastdmark  
2670 ..			.dmark: db "CAA"  
2673 f1			.pastdmark: pop af  
2674			endm  
# End of macro DMARK
2674						CALLMONITOR 
2674 cd 97 16			call break_point_state  
2677				endm  
# End of macro CALLMONITOR
2677					endif 
2677 c3 44 26				jp .getbyteat 
267a					NEXTW 
267a c3 90 1f			jp macro_next 
267d				endm 
# End of macro NEXTW
267d			.BANG: 
267d				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
267d 21				db WORD_SYS_CORE+OPCODE_BANG             
267e b3 26			dw .CBANG            
2680 02				db 1 + 1 
2681 .. 00			db "!",0              
2683				endm 
# End of macro CWHEAD
2683			; | ! ( x w -- ) Store x at address w      | DONE 
2683					if DEBUG_FORTH_WORDS_KEY 
2683						DMARK "BNG" 
2683 f5				push af  
2684 3a 98 26			ld a, (.dmark)  
2687 32 77 fb			ld (debug_mark),a  
268a 3a 99 26			ld a, (.dmark+1)  
268d 32 78 fb			ld (debug_mark+1),a  
2690 3a 9a 26			ld a, (.dmark+2)  
2693 32 79 fb			ld (debug_mark+2),a  
2696 18 03			jr .pastdmark  
2698 ..			.dmark: db "BNG"  
269b f1			.pastdmark: pop af  
269c			endm  
# End of macro DMARK
269c						CALLMONITOR 
269c cd 97 16			call break_point_state  
269f				endm  
# End of macro CALLMONITOR
269f					endif 
269f			 
269f			.storebyteat:		 
269f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
269f cd 1e 1e			call macro_dsp_valuehl 
26a2				endm 
# End of macro FORTH_DSP_VALUEHL
26a2					 
26a2 e5					push hl 
26a3				 
26a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26a3 cd d6 1e			call macro_forth_dsp_pop 
26a6				endm 
# End of macro FORTH_DSP_POP
26a6			 
26a6					; get byte to poke 
26a6			 
26a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26a6 cd 1e 1e			call macro_dsp_valuehl 
26a9				endm 
# End of macro FORTH_DSP_VALUEHL
26a9 e5					push hl 
26aa			 
26aa			 
26aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26aa cd d6 1e			call macro_forth_dsp_pop 
26ad				endm 
# End of macro FORTH_DSP_POP
26ad			 
26ad			 
26ad d1					pop de 
26ae e1					pop hl 
26af			 
26af 73					ld (hl),e 
26b0			 
26b0			 
26b0					NEXTW 
26b0 c3 90 1f			jp macro_next 
26b3				endm 
# End of macro NEXTW
26b3			.CBANG: 
26b3				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
26b3 22				db WORD_SYS_CORE+OPCODE_CBANG             
26b4 dc 26			dw .SCALL            
26b6 03				db 2 + 1 
26b7 .. 00			db "C!",0              
26ba				endm 
# End of macro CWHEAD
26ba			; | C!  ( x w -- ) Store x at address w  | DONE 
26ba					if DEBUG_FORTH_WORDS_KEY 
26ba						DMARK "CBA" 
26ba f5				push af  
26bb 3a cf 26			ld a, (.dmark)  
26be 32 77 fb			ld (debug_mark),a  
26c1 3a d0 26			ld a, (.dmark+1)  
26c4 32 78 fb			ld (debug_mark+1),a  
26c7 3a d1 26			ld a, (.dmark+2)  
26ca 32 79 fb			ld (debug_mark+2),a  
26cd 18 03			jr .pastdmark  
26cf ..			.dmark: db "CBA"  
26d2 f1			.pastdmark: pop af  
26d3			endm  
# End of macro DMARK
26d3						CALLMONITOR 
26d3 cd 97 16			call break_point_state  
26d6				endm  
# End of macro CALLMONITOR
26d6					endif 
26d6 c3 9f 26				jp .storebyteat 
26d9					NEXTW 
26d9 c3 90 1f			jp macro_next 
26dc				endm 
# End of macro NEXTW
26dc			.SCALL: 
26dc				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
26dc 23				db WORD_SYS_CORE+OPCODE_SCALL             
26dd 10 27			dw .DEPTH            
26df 05				db 4 + 1 
26e0 .. 00			db "CALL",0              
26e5				endm 
# End of macro CWHEAD
26e5			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
26e5					if DEBUG_FORTH_WORDS_KEY 
26e5						DMARK "CLL" 
26e5 f5				push af  
26e6 3a fa 26			ld a, (.dmark)  
26e9 32 77 fb			ld (debug_mark),a  
26ec 3a fb 26			ld a, (.dmark+1)  
26ef 32 78 fb			ld (debug_mark+1),a  
26f2 3a fc 26			ld a, (.dmark+2)  
26f5 32 79 fb			ld (debug_mark+2),a  
26f8 18 03			jr .pastdmark  
26fa ..			.dmark: db "CLL"  
26fd f1			.pastdmark: pop af  
26fe			endm  
# End of macro DMARK
26fe						CALLMONITOR 
26fe cd 97 16			call break_point_state  
2701				endm  
# End of macro CALLMONITOR
2701					endif 
2701			 
2701					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2701 cd 1e 1e			call macro_dsp_valuehl 
2704				endm 
# End of macro FORTH_DSP_VALUEHL
2704			 
2704			;		push hl 
2704			 
2704					; destroy value TOS 
2704			 
2704					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2704 cd d6 1e			call macro_forth_dsp_pop 
2707				endm 
# End of macro FORTH_DSP_POP
2707			 
2707						 
2707			;		pop hl 
2707			 
2707					; how to do a call with hl???? save SP? 
2707 cd 39 1f				call forth_call_hl 
270a			 
270a			 
270a					; TODO push value back onto stack for another op etc 
270a			 
270a cd 27 1c				call forth_push_numhl 
270d					NEXTW 
270d c3 90 1f			jp macro_next 
2710				endm 
# End of macro NEXTW
2710			.DEPTH: 
2710				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2710 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2711 4d 27			dw .OVER            
2713 06				db 5 + 1 
2714 .. 00			db "DEPTH",0              
271a				endm 
# End of macro CWHEAD
271a			; | DEPTH ( -- u ) Push count of stack | DONE 
271a					; take current TOS and remove from base value div by two to get count 
271a					if DEBUG_FORTH_WORDS_KEY 
271a						DMARK "DEP" 
271a f5				push af  
271b 3a 2f 27			ld a, (.dmark)  
271e 32 77 fb			ld (debug_mark),a  
2721 3a 30 27			ld a, (.dmark+1)  
2724 32 78 fb			ld (debug_mark+1),a  
2727 3a 31 27			ld a, (.dmark+2)  
272a 32 79 fb			ld (debug_mark+2),a  
272d 18 03			jr .pastdmark  
272f ..			.dmark: db "DEP"  
2732 f1			.pastdmark: pop af  
2733			endm  
# End of macro DMARK
2733						CALLMONITOR 
2733 cd 97 16			call break_point_state  
2736				endm  
# End of macro CALLMONITOR
2736					endif 
2736			 
2736			 
2736 2a 0a f8			ld hl, (cli_data_sp) 
2739 11 84 f3			ld de, cli_data_stack 
273c ed 52			sbc hl,de 
273e				 
273e				; div by size of stack item 
273e			 
273e 5d				ld e,l 
273f 0e 03			ld c, 3 
2741 cd 99 0c			call Div8 
2744			 
2744 6f				ld l,a 
2745 26 00			ld h,0 
2747			 
2747				;srl h 
2747				;rr l 
2747			 
2747 cd 27 1c				call forth_push_numhl 
274a					NEXTW 
274a c3 90 1f			jp macro_next 
274d				endm 
# End of macro NEXTW
274d			.OVER: 
274d				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
274d 42				db WORD_SYS_CORE+46             
274e 94 27			dw .PAUSE            
2750 05				db 4 + 1 
2751 .. 00			db "OVER",0              
2756				endm 
# End of macro CWHEAD
2756			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2756					if DEBUG_FORTH_WORDS_KEY 
2756						DMARK "OVR" 
2756 f5				push af  
2757 3a 6b 27			ld a, (.dmark)  
275a 32 77 fb			ld (debug_mark),a  
275d 3a 6c 27			ld a, (.dmark+1)  
2760 32 78 fb			ld (debug_mark+1),a  
2763 3a 6d 27			ld a, (.dmark+2)  
2766 32 79 fb			ld (debug_mark+2),a  
2769 18 03			jr .pastdmark  
276b ..			.dmark: db "OVR"  
276e f1			.pastdmark: pop af  
276f			endm  
# End of macro DMARK
276f						CALLMONITOR 
276f cd 97 16			call break_point_state  
2772				endm  
# End of macro CALLMONITOR
2772					endif 
2772			 
2772					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2772 cd 1e 1e			call macro_dsp_valuehl 
2775				endm 
# End of macro FORTH_DSP_VALUEHL
2775 e5					push hl    ; n2 
2776					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2776 cd d6 1e			call macro_forth_dsp_pop 
2779				endm 
# End of macro FORTH_DSP_POP
2779			 
2779					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2779 cd 1e 1e			call macro_dsp_valuehl 
277c				endm 
# End of macro FORTH_DSP_VALUEHL
277c e5					push hl    ; n1 
277d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
277d cd d6 1e			call macro_forth_dsp_pop 
2780				endm 
# End of macro FORTH_DSP_POP
2780			 
2780 d1					pop de     ; n1 
2781 e1					pop hl     ; n2 
2782			 
2782 d5					push de 
2783 e5					push hl 
2784 d5					push de 
2785			 
2785					; push back  
2785			 
2785 e1					pop hl 
2786 cd 27 1c				call forth_push_numhl 
2789 e1					pop hl 
278a cd 27 1c				call forth_push_numhl 
278d e1					pop hl 
278e cd 27 1c				call forth_push_numhl 
2791					NEXTW 
2791 c3 90 1f			jp macro_next 
2794				endm 
# End of macro NEXTW
2794			 
2794			.PAUSE: 
2794				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2794 43				db WORD_SYS_CORE+47             
2795 c9 27			dw .PAUSES            
2797 08				db 7 + 1 
2798 .. 00			db "PAUSEMS",0              
27a0				endm 
# End of macro CWHEAD
27a0			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
27a0					if DEBUG_FORTH_WORDS_KEY 
27a0						DMARK "PMS" 
27a0 f5				push af  
27a1 3a b5 27			ld a, (.dmark)  
27a4 32 77 fb			ld (debug_mark),a  
27a7 3a b6 27			ld a, (.dmark+1)  
27aa 32 78 fb			ld (debug_mark+1),a  
27ad 3a b7 27			ld a, (.dmark+2)  
27b0 32 79 fb			ld (debug_mark+2),a  
27b3 18 03			jr .pastdmark  
27b5 ..			.dmark: db "PMS"  
27b8 f1			.pastdmark: pop af  
27b9			endm  
# End of macro DMARK
27b9						CALLMONITOR 
27b9 cd 97 16			call break_point_state  
27bc				endm  
# End of macro CALLMONITOR
27bc					endif 
27bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27bc cd 1e 1e			call macro_dsp_valuehl 
27bf				endm 
# End of macro FORTH_DSP_VALUEHL
27bf			;		push hl    ; n2 
27bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27bf cd d6 1e			call macro_forth_dsp_pop 
27c2				endm 
# End of macro FORTH_DSP_POP
27c2			;		pop hl 
27c2			 
27c2 7d					ld a, l 
27c3 cd 3a 0a				call aDelayInMS 
27c6				       NEXTW 
27c6 c3 90 1f			jp macro_next 
27c9				endm 
# End of macro NEXTW
27c9			.PAUSES:  
27c9				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
27c9 44				db WORD_SYS_CORE+48             
27ca 38 28			dw .ROT            
27cc 06				db 5 + 1 
27cd .. 00			db "PAUSE",0              
27d3				endm 
# End of macro CWHEAD
27d3			; | PAUSE ( n -- )  Pause for n seconds | DONE 
27d3					if DEBUG_FORTH_WORDS_KEY 
27d3						DMARK "PAU" 
27d3 f5				push af  
27d4 3a e8 27			ld a, (.dmark)  
27d7 32 77 fb			ld (debug_mark),a  
27da 3a e9 27			ld a, (.dmark+1)  
27dd 32 78 fb			ld (debug_mark+1),a  
27e0 3a ea 27			ld a, (.dmark+2)  
27e3 32 79 fb			ld (debug_mark+2),a  
27e6 18 03			jr .pastdmark  
27e8 ..			.dmark: db "PAU"  
27eb f1			.pastdmark: pop af  
27ec			endm  
# End of macro DMARK
27ec						CALLMONITOR 
27ec cd 97 16			call break_point_state  
27ef				endm  
# End of macro CALLMONITOR
27ef					endif 
27ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27ef cd 1e 1e			call macro_dsp_valuehl 
27f2				endm 
# End of macro FORTH_DSP_VALUEHL
27f2			;		push hl    ; n2 
27f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27f2 cd d6 1e			call macro_forth_dsp_pop 
27f5				endm 
# End of macro FORTH_DSP_POP
27f5			;		pop hl 
27f5 45					ld b, l 
27f6					if DEBUG_FORTH_WORDS 
27f6						DMARK "PAU" 
27f6 f5				push af  
27f7 3a 0b 28			ld a, (.dmark)  
27fa 32 77 fb			ld (debug_mark),a  
27fd 3a 0c 28			ld a, (.dmark+1)  
2800 32 78 fb			ld (debug_mark+1),a  
2803 3a 0d 28			ld a, (.dmark+2)  
2806 32 79 fb			ld (debug_mark+2),a  
2809 18 03			jr .pastdmark  
280b ..			.dmark: db "PAU"  
280e f1			.pastdmark: pop af  
280f			endm  
# End of macro DMARK
280f						CALLMONITOR 
280f cd 97 16			call break_point_state  
2812				endm  
# End of macro CALLMONITOR
2812					endif 
2812 c5			.pauses1:	push bc 
2813 cd 55 0a				call delay1s 
2816 c1					pop bc 
2817					if DEBUG_FORTH_WORDS 
2817						DMARK "PA1" 
2817 f5				push af  
2818 3a 2c 28			ld a, (.dmark)  
281b 32 77 fb			ld (debug_mark),a  
281e 3a 2d 28			ld a, (.dmark+1)  
2821 32 78 fb			ld (debug_mark+1),a  
2824 3a 2e 28			ld a, (.dmark+2)  
2827 32 79 fb			ld (debug_mark+2),a  
282a 18 03			jr .pastdmark  
282c ..			.dmark: db "PA1"  
282f f1			.pastdmark: pop af  
2830			endm  
# End of macro DMARK
2830						CALLMONITOR 
2830 cd 97 16			call break_point_state  
2833				endm  
# End of macro CALLMONITOR
2833					endif 
2833 10 dd				djnz .pauses1 
2835			 
2835				       NEXTW 
2835 c3 90 1f			jp macro_next 
2838				endm 
# End of macro NEXTW
2838			.ROT: 
2838				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2838 45				db WORD_SYS_CORE+49             
2839 86 28			dw .UWORDS            
283b 04				db 3 + 1 
283c .. 00			db "ROT",0              
2840				endm 
# End of macro CWHEAD
2840			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2840					if DEBUG_FORTH_WORDS_KEY 
2840						DMARK "ROT" 
2840 f5				push af  
2841 3a 55 28			ld a, (.dmark)  
2844 32 77 fb			ld (debug_mark),a  
2847 3a 56 28			ld a, (.dmark+1)  
284a 32 78 fb			ld (debug_mark+1),a  
284d 3a 57 28			ld a, (.dmark+2)  
2850 32 79 fb			ld (debug_mark+2),a  
2853 18 03			jr .pastdmark  
2855 ..			.dmark: db "ROT"  
2858 f1			.pastdmark: pop af  
2859			endm  
# End of macro DMARK
2859						CALLMONITOR 
2859 cd 97 16			call break_point_state  
285c				endm  
# End of macro CALLMONITOR
285c					endif 
285c			 
285c					FORTH_DSP_VALUEHL 
285c cd 1e 1e			call macro_dsp_valuehl 
285f				endm 
# End of macro FORTH_DSP_VALUEHL
285f e5					push hl    ; u3  
2860			 
2860					FORTH_DSP_POP 
2860 cd d6 1e			call macro_forth_dsp_pop 
2863				endm 
# End of macro FORTH_DSP_POP
2863			   
2863					FORTH_DSP_VALUEHL 
2863 cd 1e 1e			call macro_dsp_valuehl 
2866				endm 
# End of macro FORTH_DSP_VALUEHL
2866 e5					push hl     ; u2 
2867			 
2867					FORTH_DSP_POP 
2867 cd d6 1e			call macro_forth_dsp_pop 
286a				endm 
# End of macro FORTH_DSP_POP
286a			 
286a					FORTH_DSP_VALUEHL 
286a cd 1e 1e			call macro_dsp_valuehl 
286d				endm 
# End of macro FORTH_DSP_VALUEHL
286d e5					push hl     ; u1 
286e			 
286e					FORTH_DSP_POP 
286e cd d6 1e			call macro_forth_dsp_pop 
2871				endm 
# End of macro FORTH_DSP_POP
2871			 
2871 c1					pop bc      ; u1 
2872 e1					pop hl      ; u2 
2873 d1					pop de      ; u3 
2874			 
2874			 
2874 c5					push bc 
2875 d5					push de 
2876 e5					push hl 
2877			 
2877			 
2877 e1					pop hl 
2878 cd 27 1c				call forth_push_numhl 
287b			 
287b e1					pop hl 
287c cd 27 1c				call forth_push_numhl 
287f			 
287f e1					pop hl 
2880 cd 27 1c				call forth_push_numhl 
2883					 
2883			 
2883			 
2883			 
2883			 
2883			 
2883				       NEXTW 
2883 c3 90 1f			jp macro_next 
2886				endm 
# End of macro NEXTW
2886			 
2886			.UWORDS: 
2886				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2886 50				db WORD_SYS_CORE+60             
2887 48 29			dw .BP            
2889 07				db 6 + 1 
288a .. 00			db "UWORDS",0              
2891				endm 
# End of macro CWHEAD
2891			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2891			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2891			; | | Following the count are the individual words. 
2891			; | | 
2891			; | | e.g. UWORDS 
2891			; | | BOX DIRLIST 2 
2891			; | |  
2891			; | | Can be used to save the words to storage via: 
2891			; | | UWORDS $01 DO $01 APPEND LOOP 
2891				if DEBUG_FORTH_WORDS_KEY 
2891					DMARK "UWR" 
2891 f5				push af  
2892 3a a6 28			ld a, (.dmark)  
2895 32 77 fb			ld (debug_mark),a  
2898 3a a7 28			ld a, (.dmark+1)  
289b 32 78 fb			ld (debug_mark+1),a  
289e 3a a8 28			ld a, (.dmark+2)  
28a1 32 79 fb			ld (debug_mark+2),a  
28a4 18 03			jr .pastdmark  
28a6 ..			.dmark: db "UWR"  
28a9 f1			.pastdmark: pop af  
28aa			endm  
# End of macro DMARK
28aa					CALLMONITOR 
28aa cd 97 16			call break_point_state  
28ad				endm  
# End of macro CALLMONITOR
28ad				endif 
28ad 21 00 80				ld hl, baseram 
28b0					;ld hl, baseusermem 
28b0 01 00 00				ld bc, 0    ; start a counter 
28b3			 
28b3				; skip dict stub 
28b3			 
28b3 cd e1 20				call forth_tok_next 
28b6			 
28b6			 
28b6			; while we have words to look for 
28b6			 
28b6 7e			.douscan:	ld a, (hl)      
28b7				if DEBUG_FORTH_WORDS 
28b7					DMARK "UWs" 
28b7 f5				push af  
28b8 3a cc 28			ld a, (.dmark)  
28bb 32 77 fb			ld (debug_mark),a  
28be 3a cd 28			ld a, (.dmark+1)  
28c1 32 78 fb			ld (debug_mark+1),a  
28c4 3a ce 28			ld a, (.dmark+2)  
28c7 32 79 fb			ld (debug_mark+2),a  
28ca 18 03			jr .pastdmark  
28cc ..			.dmark: db "UWs"  
28cf f1			.pastdmark: pop af  
28d0			endm  
# End of macro DMARK
28d0					CALLMONITOR 
28d0 cd 97 16			call break_point_state  
28d3				endm  
# End of macro CALLMONITOR
28d3				endif 
28d3 fe 00				cp WORD_SYS_END 
28d5 28 4d				jr z, .udone 
28d7 fe 01				cp WORD_SYS_UWORD 
28d9 20 44				jr nz, .nuword 
28db			 
28db				if DEBUG_FORTH_WORDS 
28db					DMARK "UWu" 
28db f5				push af  
28dc 3a f0 28			ld a, (.dmark)  
28df 32 77 fb			ld (debug_mark),a  
28e2 3a f1 28			ld a, (.dmark+1)  
28e5 32 78 fb			ld (debug_mark+1),a  
28e8 3a f2 28			ld a, (.dmark+2)  
28eb 32 79 fb			ld (debug_mark+2),a  
28ee 18 03			jr .pastdmark  
28f0 ..			.dmark: db "UWu"  
28f3 f1			.pastdmark: pop af  
28f4			endm  
# End of macro DMARK
28f4					CALLMONITOR 
28f4 cd 97 16			call break_point_state  
28f7				endm  
# End of macro CALLMONITOR
28f7				endif 
28f7					; we have a uword so push its name to the stack 
28f7			 
28f7 e5				   	push hl  ; save so we can move to next dict block 
28f8			 
28f8					; skip opcode 
28f8 23					inc hl  
28f9					; skip next ptr 
28f9 23					inc hl  
28fa 23					inc hl 
28fb					; skip len 
28fb 23					inc hl 
28fc				if DEBUG_FORTH_WORDS 
28fc					DMARK "UWt" 
28fc f5				push af  
28fd 3a 11 29			ld a, (.dmark)  
2900 32 77 fb			ld (debug_mark),a  
2903 3a 12 29			ld a, (.dmark+1)  
2906 32 78 fb			ld (debug_mark+1),a  
2909 3a 13 29			ld a, (.dmark+2)  
290c 32 79 fb			ld (debug_mark+2),a  
290f 18 03			jr .pastdmark  
2911 ..			.dmark: db "UWt"  
2914 f1			.pastdmark: pop af  
2915			endm  
# End of macro DMARK
2915					CALLMONITOR 
2915 cd 97 16			call break_point_state  
2918				endm  
# End of macro CALLMONITOR
2918				endif 
2918 03					inc bc 
2919			 
2919 c5					push bc 
291a cd 95 1c				call forth_push_str 
291d c1					pop bc 
291e			 
291e e1					pop hl 	 
291f			 
291f cd e1 20		.nuword:	call forth_tok_next 
2922 18 92				jr .douscan  
2924			 
2924			.udone:		 ; push count of uwords found 
2924 c5					push bc 
2925 e1					pop hl 
2926			 
2926				if DEBUG_FORTH_WORDS 
2926					DMARK "UWc" 
2926 f5				push af  
2927 3a 3b 29			ld a, (.dmark)  
292a 32 77 fb			ld (debug_mark),a  
292d 3a 3c 29			ld a, (.dmark+1)  
2930 32 78 fb			ld (debug_mark+1),a  
2933 3a 3d 29			ld a, (.dmark+2)  
2936 32 79 fb			ld (debug_mark+2),a  
2939 18 03			jr .pastdmark  
293b ..			.dmark: db "UWc"  
293e f1			.pastdmark: pop af  
293f			endm  
# End of macro DMARK
293f					CALLMONITOR 
293f cd 97 16			call break_point_state  
2942				endm  
# End of macro CALLMONITOR
2942				endif 
2942 cd 27 1c				call forth_push_numhl 
2945			 
2945			 
2945				       NEXTW 
2945 c3 90 1f			jp macro_next 
2948				endm 
# End of macro NEXTW
2948			 
2948			.BP: 
2948				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2948 54				db WORD_SYS_CORE+64             
2949 7e 29			dw .MONITOR            
294b 03				db 2 + 1 
294c .. 00			db "BP",0              
294f				endm 
# End of macro CWHEAD
294f			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
294f			; | | $00 Will enable the break points within specific code paths 
294f			; | | $01 Will disable break points 
294f			; | |  
294f			; | | By default break points are off. Either the above can be used to enable them 
294f			; | | or if a key is held down during start up the spashscreen will appear to freeze 
294f			; | | and on release of the pressed key a message will be disaplayed to notify 
294f			; | | that break points are enabled. Pressing any key will then continue boot process. 
294f					; get byte count 
294f					if DEBUG_FORTH_WORDS_KEY 
294f						DMARK "BP." 
294f f5				push af  
2950 3a 64 29			ld a, (.dmark)  
2953 32 77 fb			ld (debug_mark),a  
2956 3a 65 29			ld a, (.dmark+1)  
2959 32 78 fb			ld (debug_mark+1),a  
295c 3a 66 29			ld a, (.dmark+2)  
295f 32 79 fb			ld (debug_mark+2),a  
2962 18 03			jr .pastdmark  
2964 ..			.dmark: db "BP."  
2967 f1			.pastdmark: pop af  
2968			endm  
# End of macro DMARK
2968						CALLMONITOR 
2968 cd 97 16			call break_point_state  
296b				endm  
# End of macro CALLMONITOR
296b					endif 
296b			 
296b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
296b cd 1e 1e			call macro_dsp_valuehl 
296e				endm 
# End of macro FORTH_DSP_VALUEHL
296e			 
296e			;		push hl 
296e			 
296e					; destroy value TOS 
296e			 
296e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
296e cd d6 1e			call macro_forth_dsp_pop 
2971				endm 
# End of macro FORTH_DSP_POP
2971			 
2971			;		pop hl 
2971			 
2971 3e 00				ld a,0 
2973 bd					cp l 
2974 28 02				jr z, .bpset 
2976 3e 2a				ld a, '*' 
2978			 
2978 32 0e ee		.bpset:		ld (os_view_disable), a 
297b			 
297b			 
297b					NEXTW 
297b c3 90 1f			jp macro_next 
297e				endm 
# End of macro NEXTW
297e			 
297e			 
297e			.MONITOR: 
297e				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
297e 55				db WORD_SYS_CORE+65             
297f b1 29			dw .MALLOC            
2981 08				db 7 + 1 
2982 .. 00			db "MONITOR",0              
298a				endm 
# End of macro CWHEAD
298a			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
298a			; | | At start the current various registers will be displayed with contents. 
298a			; | | Top right corner will show the most recent debug marker seen. 
298a			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
298a			; | | and the return stack pointer (RSP). 
298a			; | | Pressing: 
298a			; | |    1 - Initial screen 
298a			; | |    2 - Display a data dump of HL 
298a			; | |    3 - Display a data dump of DE 
298a			; | |    4 - Display a data dump of BC 
298a			; | |    5 - Display a data dump of HL 
298a			; | |    6 - Display a data dump of DSP 
298a			; | |    7 - Display a data dump of RSP 
298a			; | |    8 - Display a data dump of what is at DSP 
298a			; | |    9 - Display a data dump of what is at RSP 
298a			; | |    0 - Exit monitor and continue running. This will also enable break points 
298a			; | |    * - Disable break points 
298a			; | |    # - Enter traditional monitor mode 
298a			; | | 
298a			; | | Monitor Mode 
298a			; | | ------------ 
298a			; | | A prompt of '>' will be shown for various commands: 
298a			; | |    D xxxx - Display a data dump starting from hex address xxxx 
298a			; | |    C - Continue display a data dump from the last set address 
298a			; | |    M xxxx - Set start of memory edit at address xx 
298a			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
298a			; | |    Q - Return to previous 
298a					if DEBUG_FORTH_WORDS_KEY 
298a						DMARK "MON" 
298a f5				push af  
298b 3a 9f 29			ld a, (.dmark)  
298e 32 77 fb			ld (debug_mark),a  
2991 3a a0 29			ld a, (.dmark+1)  
2994 32 78 fb			ld (debug_mark+1),a  
2997 3a a1 29			ld a, (.dmark+2)  
299a 32 79 fb			ld (debug_mark+2),a  
299d 18 03			jr .pastdmark  
299f ..			.dmark: db "MON"  
29a2 f1			.pastdmark: pop af  
29a3			endm  
# End of macro DMARK
29a3						CALLMONITOR 
29a3 cd 97 16			call break_point_state  
29a6				endm  
# End of macro CALLMONITOR
29a6					endif 
29a6 3e 00				ld a, 0 
29a8 32 0e ee				ld (os_view_disable), a 
29ab			 
29ab					CALLMONITOR 
29ab cd 97 16			call break_point_state  
29ae				endm  
# End of macro CALLMONITOR
29ae			 
29ae			;	call monitor 
29ae			 
29ae					NEXTW 
29ae c3 90 1f			jp macro_next 
29b1				endm 
# End of macro NEXTW
29b1			 
29b1			 
29b1			.MALLOC: 
29b1				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
29b1 56				db WORD_SYS_CORE+66             
29b2 da 29			dw .MALLOC2            
29b4 06				db 5 + 1 
29b5 .. 00			db "ALLOT",0              
29bb				endm 
# End of macro CWHEAD
29bb			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29bb					if DEBUG_FORTH_WORDS_KEY 
29bb						DMARK "ALL" 
29bb f5				push af  
29bc 3a d0 29			ld a, (.dmark)  
29bf 32 77 fb			ld (debug_mark),a  
29c2 3a d1 29			ld a, (.dmark+1)  
29c5 32 78 fb			ld (debug_mark+1),a  
29c8 3a d2 29			ld a, (.dmark+2)  
29cb 32 79 fb			ld (debug_mark+2),a  
29ce 18 03			jr .pastdmark  
29d0 ..			.dmark: db "ALL"  
29d3 f1			.pastdmark: pop af  
29d4			endm  
# End of macro DMARK
29d4						CALLMONITOR 
29d4 cd 97 16			call break_point_state  
29d7				endm  
# End of macro CALLMONITOR
29d7					endif 
29d7 c3 01 2a				jp .mallocc 
29da			.MALLOC2: 
29da				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
29da 56				db WORD_SYS_CORE+66             
29db 18 2a			dw .FREE            
29dd 07				db 6 + 1 
29de .. 00			db "MALLOC",0              
29e5				endm 
# End of macro CWHEAD
29e5			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29e5					; get byte count 
29e5					if DEBUG_FORTH_WORDS_KEY 
29e5						DMARK "MAL" 
29e5 f5				push af  
29e6 3a fa 29			ld a, (.dmark)  
29e9 32 77 fb			ld (debug_mark),a  
29ec 3a fb 29			ld a, (.dmark+1)  
29ef 32 78 fb			ld (debug_mark+1),a  
29f2 3a fc 29			ld a, (.dmark+2)  
29f5 32 79 fb			ld (debug_mark+2),a  
29f8 18 03			jr .pastdmark  
29fa ..			.dmark: db "MAL"  
29fd f1			.pastdmark: pop af  
29fe			endm  
# End of macro DMARK
29fe						CALLMONITOR 
29fe cd 97 16			call break_point_state  
2a01				endm  
# End of macro CALLMONITOR
2a01					endif 
2a01			.mallocc: 
2a01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a01 cd 1e 1e			call macro_dsp_valuehl 
2a04				endm 
# End of macro FORTH_DSP_VALUEHL
2a04			 
2a04			;		push hl 
2a04			 
2a04					; destroy value TOS 
2a04			 
2a04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a04 cd d6 1e			call macro_forth_dsp_pop 
2a07				endm 
# End of macro FORTH_DSP_POP
2a07			 
2a07			;		pop hl 
2a07 cd d0 11				call malloc 
2a0a				if DEBUG_FORTH_MALLOC_GUARD 
2a0a f5					push af 
2a0b cd 32 0d				call ishlzero 
2a0e			;		ld a, l 
2a0e			;		add h 
2a0e			;		cp 0 
2a0e f1					pop af 
2a0f					 
2a0f cc 4b 52				call z,malloc_error 
2a12				endif 
2a12			 
2a12 cd 27 1c				call forth_push_numhl 
2a15					NEXTW 
2a15 c3 90 1f			jp macro_next 
2a18				endm 
# End of macro NEXTW
2a18			 
2a18			.FREE: 
2a18				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2a18 57				db WORD_SYS_CORE+67             
2a19 49 2a			dw .LIST            
2a1b 05				db 4 + 1 
2a1c .. 00			db "FREE",0              
2a21				endm 
# End of macro CWHEAD
2a21			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2a21					if DEBUG_FORTH_WORDS_KEY 
2a21						DMARK "FRE" 
2a21 f5				push af  
2a22 3a 36 2a			ld a, (.dmark)  
2a25 32 77 fb			ld (debug_mark),a  
2a28 3a 37 2a			ld a, (.dmark+1)  
2a2b 32 78 fb			ld (debug_mark+1),a  
2a2e 3a 38 2a			ld a, (.dmark+2)  
2a31 32 79 fb			ld (debug_mark+2),a  
2a34 18 03			jr .pastdmark  
2a36 ..			.dmark: db "FRE"  
2a39 f1			.pastdmark: pop af  
2a3a			endm  
# End of macro DMARK
2a3a						CALLMONITOR 
2a3a cd 97 16			call break_point_state  
2a3d				endm  
# End of macro CALLMONITOR
2a3d					endif 
2a3d					; get address 
2a3d			 
2a3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a3d cd 1e 1e			call macro_dsp_valuehl 
2a40				endm 
# End of macro FORTH_DSP_VALUEHL
2a40			 
2a40			;		push hl 
2a40			 
2a40					; destroy value TOS 
2a40			 
2a40					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a40 cd d6 1e			call macro_forth_dsp_pop 
2a43				endm 
# End of macro FORTH_DSP_POP
2a43			 
2a43			;		pop hl 
2a43			if FORTH_ENABLE_MALLOCFREE 
2a43 cd 9a 12				call free 
2a46			endif 
2a46					NEXTW 
2a46 c3 90 1f			jp macro_next 
2a49				endm 
# End of macro NEXTW
2a49			.LIST: 
2a49				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2a49 5c				db WORD_SYS_CORE+72             
2a4a 0c 2c			dw .FORGET            
2a4c 05				db 4 + 1 
2a4d .. 00			db "LIST",0              
2a52				endm 
# End of macro CWHEAD
2a52			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2a52			; | | The quoted word must be in upper case. 
2a52				if DEBUG_FORTH_WORDS_KEY 
2a52					DMARK "LST" 
2a52 f5				push af  
2a53 3a 67 2a			ld a, (.dmark)  
2a56 32 77 fb			ld (debug_mark),a  
2a59 3a 68 2a			ld a, (.dmark+1)  
2a5c 32 78 fb			ld (debug_mark+1),a  
2a5f 3a 69 2a			ld a, (.dmark+2)  
2a62 32 79 fb			ld (debug_mark+2),a  
2a65 18 03			jr .pastdmark  
2a67 ..			.dmark: db "LST"  
2a6a f1			.pastdmark: pop af  
2a6b			endm  
# End of macro DMARK
2a6b					CALLMONITOR 
2a6b cd 97 16			call break_point_state  
2a6e				endm  
# End of macro CALLMONITOR
2a6e				endif 
2a6e			 
2a6e					FORTH_DSP_VALUEHL 
2a6e cd 1e 1e			call macro_dsp_valuehl 
2a71				endm 
# End of macro FORTH_DSP_VALUEHL
2a71			 
2a71 e5					push hl 
2a72 c1					pop bc 
2a73			 
2a73			; Start format of scratch string 
2a73			 
2a73 21 1d ee				ld hl, scratch 
2a76			 
2a76 3e 3a				ld a, ':' 
2a78 77					ld (hl),a 
2a79 23					inc hl 
2a7a 3e 20				ld a, ' ' 
2a7c 77					ld (hl), a 
2a7d			 
2a7d					; Get ptr to the word we need to look up 
2a7d			 
2a7d			;		FORTH_DSP_VALUEHL 
2a7d					;v5 FORTH_DSP_VALUE 
2a7d				; TODO type check 
2a7d			;		inc hl    ; Skip type check  
2a7d			;		push hl 
2a7d			;		ex de, hl    ; put into DE 
2a7d			 
2a7d			 
2a7d 21 00 80				ld hl, baseram 
2a80					;ld hl, baseusermem 
2a80			 
2a80 e5			push hl   ; sacreifical push 
2a81			 
2a81			.ldouscanm: 
2a81 e1				pop hl 
2a82			.ldouscan: 
2a82				if DEBUG_FORTH_WORDS 
2a82					DMARK "LSs" 
2a82 f5				push af  
2a83 3a 97 2a			ld a, (.dmark)  
2a86 32 77 fb			ld (debug_mark),a  
2a89 3a 98 2a			ld a, (.dmark+1)  
2a8c 32 78 fb			ld (debug_mark+1),a  
2a8f 3a 99 2a			ld a, (.dmark+2)  
2a92 32 79 fb			ld (debug_mark+2),a  
2a95 18 03			jr .pastdmark  
2a97 ..			.dmark: db "LSs"  
2a9a f1			.pastdmark: pop af  
2a9b			endm  
# End of macro DMARK
2a9b					CALLMONITOR 
2a9b cd 97 16			call break_point_state  
2a9e				endm  
# End of macro CALLMONITOR
2a9e				endif 
2a9e				; skip dict stub 
2a9e cd e1 20				call forth_tok_next 
2aa1			 
2aa1			 
2aa1			; while we have words to look for 
2aa1			 
2aa1 7e				ld a, (hl)      
2aa2				if DEBUG_FORTH_WORDS 
2aa2					DMARK "LSk" 
2aa2 f5				push af  
2aa3 3a b7 2a			ld a, (.dmark)  
2aa6 32 77 fb			ld (debug_mark),a  
2aa9 3a b8 2a			ld a, (.dmark+1)  
2aac 32 78 fb			ld (debug_mark+1),a  
2aaf 3a b9 2a			ld a, (.dmark+2)  
2ab2 32 79 fb			ld (debug_mark+2),a  
2ab5 18 03			jr .pastdmark  
2ab7 ..			.dmark: db "LSk"  
2aba f1			.pastdmark: pop af  
2abb			endm  
# End of macro DMARK
2abb					CALLMONITOR 
2abb cd 97 16			call break_point_state  
2abe				endm  
# End of macro CALLMONITOR
2abe				endif 
2abe fe 00				cp WORD_SYS_END 
2ac0 ca f3 2b				jp z, .lunotfound 
2ac3 fe 01				cp WORD_SYS_UWORD 
2ac5 c2 82 2a				jp nz, .ldouscan 
2ac8			 
2ac8				if DEBUG_FORTH_WORDS 
2ac8					DMARK "LSu" 
2ac8 f5				push af  
2ac9 3a dd 2a			ld a, (.dmark)  
2acc 32 77 fb			ld (debug_mark),a  
2acf 3a de 2a			ld a, (.dmark+1)  
2ad2 32 78 fb			ld (debug_mark+1),a  
2ad5 3a df 2a			ld a, (.dmark+2)  
2ad8 32 79 fb			ld (debug_mark+2),a  
2adb 18 03			jr .pastdmark  
2add ..			.dmark: db "LSu"  
2ae0 f1			.pastdmark: pop af  
2ae1			endm  
# End of macro DMARK
2ae1					CALLMONITOR 
2ae1 cd 97 16			call break_point_state  
2ae4				endm  
# End of macro CALLMONITOR
2ae4				endif 
2ae4			 
2ae4					; found a uword but is it the one we want... 
2ae4			 
2ae4 c5					push bc     ; uword to find is on bc 
2ae5 d1					pop de 
2ae6			 
2ae6 e5					push hl  ; to save the ptr 
2ae7			 
2ae7					; skip opcode 
2ae7 23					inc hl  
2ae8					; skip next ptr 
2ae8 23					inc hl  
2ae9 23					inc hl 
2aea					; skip len 
2aea 23					inc hl 
2aeb			 
2aeb				if DEBUG_FORTH_WORDS 
2aeb					DMARK "LSc" 
2aeb f5				push af  
2aec 3a 00 2b			ld a, (.dmark)  
2aef 32 77 fb			ld (debug_mark),a  
2af2 3a 01 2b			ld a, (.dmark+1)  
2af5 32 78 fb			ld (debug_mark+1),a  
2af8 3a 02 2b			ld a, (.dmark+2)  
2afb 32 79 fb			ld (debug_mark+2),a  
2afe 18 03			jr .pastdmark  
2b00 ..			.dmark: db "LSc"  
2b03 f1			.pastdmark: pop af  
2b04			endm  
# End of macro DMARK
2b04					CALLMONITOR 
2b04 cd 97 16			call break_point_state  
2b07				endm  
# End of macro CALLMONITOR
2b07				endif 
2b07 cd 9f 11				call strcmp 
2b0a c2 81 2a				jp nz, .ldouscanm 
2b0d				 
2b0d			 
2b0d			 
2b0d					; we have a uword so push its name to the stack 
2b0d			 
2b0d			;	   	push hl  ; save so we can move to next dict block 
2b0d e1			pop hl 
2b0e			 
2b0e				if DEBUG_FORTH_WORDS 
2b0e					DMARK "LSm" 
2b0e f5				push af  
2b0f 3a 23 2b			ld a, (.dmark)  
2b12 32 77 fb			ld (debug_mark),a  
2b15 3a 24 2b			ld a, (.dmark+1)  
2b18 32 78 fb			ld (debug_mark+1),a  
2b1b 3a 25 2b			ld a, (.dmark+2)  
2b1e 32 79 fb			ld (debug_mark+2),a  
2b21 18 03			jr .pastdmark  
2b23 ..			.dmark: db "LSm"  
2b26 f1			.pastdmark: pop af  
2b27			endm  
# End of macro DMARK
2b27					CALLMONITOR 
2b27 cd 97 16			call break_point_state  
2b2a				endm  
# End of macro CALLMONITOR
2b2a				endif 
2b2a			 
2b2a					; skip opcode 
2b2a 23					inc hl  
2b2b					; skip next ptr 
2b2b 23					inc hl  
2b2c 23					inc hl 
2b2d					; skip len 
2b2d 7e					ld a, (hl)   ; save length to add 
2b2e				if DEBUG_FORTH_WORDS 
2b2e					DMARK "LS2" 
2b2e f5				push af  
2b2f 3a 43 2b			ld a, (.dmark)  
2b32 32 77 fb			ld (debug_mark),a  
2b35 3a 44 2b			ld a, (.dmark+1)  
2b38 32 78 fb			ld (debug_mark+1),a  
2b3b 3a 45 2b			ld a, (.dmark+2)  
2b3e 32 79 fb			ld (debug_mark+2),a  
2b41 18 03			jr .pastdmark  
2b43 ..			.dmark: db "LS2"  
2b46 f1			.pastdmark: pop af  
2b47			endm  
# End of macro DMARK
2b47					CALLMONITOR 
2b47 cd 97 16			call break_point_state  
2b4a				endm  
# End of macro CALLMONITOR
2b4a				endif 
2b4a			 
2b4a					; save this location 
2b4a				 
2b4a e5					push hl 
2b4b			 
2b4b 23					inc hl 
2b4c 11 1f ee				ld de, scratch+2 
2b4f 4f					ld c, a 
2b50 06 00				ld b, 0 
2b52			 
2b52				if DEBUG_FORTH_WORDS 
2b52					DMARK "LSn" 
2b52 f5				push af  
2b53 3a 67 2b			ld a, (.dmark)  
2b56 32 77 fb			ld (debug_mark),a  
2b59 3a 68 2b			ld a, (.dmark+1)  
2b5c 32 78 fb			ld (debug_mark+1),a  
2b5f 3a 69 2b			ld a, (.dmark+2)  
2b62 32 79 fb			ld (debug_mark+2),a  
2b65 18 03			jr .pastdmark  
2b67 ..			.dmark: db "LSn"  
2b6a f1			.pastdmark: pop af  
2b6b			endm  
# End of macro DMARK
2b6b					CALLMONITOR 
2b6b cd 97 16			call break_point_state  
2b6e				endm  
# End of macro CALLMONITOR
2b6e				endif 
2b6e			 
2b6e					; copy uword name to scratch 
2b6e			 
2b6e ed b0				ldir 
2b70			 
2b70 1b					dec de 
2b71 3e 20				ld a, ' '    ; change null to space 
2b73 12					ld (de), a 
2b74			 
2b74 13					inc de 
2b75			 
2b75 d5					push de 
2b76 c1					pop bc     ; move scratch pointer to end of word name and save it 
2b77			 
2b77 e1					pop hl 
2b78 7e					ld a, (hl) 
2b79					;inc hl 
2b79					; skip word string 
2b79 cd 09 0d				call addatohl 
2b7c			 
2b7c 23					inc hl 
2b7d			 
2b7d				if DEBUG_FORTH_WORDS 
2b7d					DMARK "LS3" 
2b7d f5				push af  
2b7e 3a 92 2b			ld a, (.dmark)  
2b81 32 77 fb			ld (debug_mark),a  
2b84 3a 93 2b			ld a, (.dmark+1)  
2b87 32 78 fb			ld (debug_mark+1),a  
2b8a 3a 94 2b			ld a, (.dmark+2)  
2b8d 32 79 fb			ld (debug_mark+2),a  
2b90 18 03			jr .pastdmark  
2b92 ..			.dmark: db "LS3"  
2b95 f1			.pastdmark: pop af  
2b96			endm  
# End of macro DMARK
2b96					CALLMONITOR 
2b96 cd 97 16			call break_point_state  
2b99				endm  
# End of macro CALLMONITOR
2b99				endif 
2b99					; should now be at the start of the machine code to setup the eval of the uword 
2b99					; now locate the ptr to the string defintion 
2b99			 
2b99					; skip ld hl, 
2b99					; then load the ptr 
2b99			 
2b99 23					inc hl 
2b9a 5e					ld e, (hl) 
2b9b 23					inc hl 
2b9c 56					ld d, (hl) 
2b9d eb					ex de, hl 
2b9e			 
2b9e			 
2b9e				if DEBUG_FORTH_WORDS 
2b9e					DMARK "LSt" 
2b9e f5				push af  
2b9f 3a b3 2b			ld a, (.dmark)  
2ba2 32 77 fb			ld (debug_mark),a  
2ba5 3a b4 2b			ld a, (.dmark+1)  
2ba8 32 78 fb			ld (debug_mark+1),a  
2bab 3a b5 2b			ld a, (.dmark+2)  
2bae 32 79 fb			ld (debug_mark+2),a  
2bb1 18 03			jr .pastdmark  
2bb3 ..			.dmark: db "LSt"  
2bb6 f1			.pastdmark: pop af  
2bb7			endm  
# End of macro DMARK
2bb7					CALLMONITOR 
2bb7 cd 97 16			call break_point_state  
2bba				endm  
# End of macro CALLMONITOR
2bba				endif 
2bba			 
2bba			; cant push right now due to tokenised strings  
2bba			 
2bba			; get the destination of where to copy this definition to. 
2bba			 
2bba c5					push bc 
2bbb d1					pop de 
2bbc			 
2bbc 7e			.listl:         ld a,(hl) 
2bbd fe 00				cp 0 
2bbf 28 09				jr z, .lreplsp     ; replace zero with space 
2bc1 fe 7f				cp FORTH_END_BUFFER 
2bc3 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2bc5				 
2bc5					; just copy this char as is then 
2bc5			 
2bc5 12					ld (de), a 
2bc6			 
2bc6 23			.listnxt:	inc hl 
2bc7 13					inc de 
2bc8 18 f2				jr .listl 
2bca			 
2bca 3e 20		.lreplsp:	ld a,' ' 
2bcc 12					ld (de), a 
2bcd 18 f7				jr .listnxt 
2bcf			 
2bcf			; close up uword def 
2bcf			 
2bcf			.listdone: 
2bcf 3e 00				ld a, 0 
2bd1 12					ld (de), a 
2bd2			 
2bd2			; now have def so clean up and push to stack 
2bd2			 
2bd2 21 1d ee				ld hl, scratch 
2bd5				if DEBUG_FORTH_WORDS 
2bd5					DMARK "Ltp" 
2bd5 f5				push af  
2bd6 3a ea 2b			ld a, (.dmark)  
2bd9 32 77 fb			ld (debug_mark),a  
2bdc 3a eb 2b			ld a, (.dmark+1)  
2bdf 32 78 fb			ld (debug_mark+1),a  
2be2 3a ec 2b			ld a, (.dmark+2)  
2be5 32 79 fb			ld (debug_mark+2),a  
2be8 18 03			jr .pastdmark  
2bea ..			.dmark: db "Ltp"  
2bed f1			.pastdmark: pop af  
2bee			endm  
# End of macro DMARK
2bee					CALLMONITOR 
2bee cd 97 16			call break_point_state  
2bf1				endm  
# End of macro CALLMONITOR
2bf1				endif 
2bf1			 
2bf1 18 06			jr .listpush 
2bf3			 
2bf3			;.lnuword:	pop hl 
2bf3			;		call forth_tok_next 
2bf3			;		jp .ldouscan  
2bf3			 
2bf3			.lunotfound:		  
2bf3			 
2bf3			 
2bf3					 
2bf3					FORTH_DSP_POP 
2bf3 cd d6 1e			call macro_forth_dsp_pop 
2bf6				endm 
# End of macro FORTH_DSP_POP
2bf6 21 ff 2b				ld hl, .luno 
2bf9						 
2bf9			 
2bf9			.listpush: 
2bf9 cd 95 1c				call forth_push_str 
2bfc			 
2bfc			 
2bfc			 
2bfc					NEXTW 
2bfc c3 90 1f			jp macro_next 
2bff				endm 
# End of macro NEXTW
2bff			 
2bff .. 00		.luno:    db "Not found",0 
2c09			 
2c09			 
2c09			 
2c09			 
2c09			 
2c09			;		push hl   ; save pointer to start of uword def string 
2c09			; 
2c09			;; look for FORTH_EOL_LINE 
2c09			;		ld a, FORTH_END_BUFFER 
2c09			;		call strlent 
2c09			; 
2c09			;		inc hl		 ; space for coln def 
2c09			;		inc hl 
2c09			;		inc hl          ; space for terms 
2c09			;		inc hl 
2c09			; 
2c09			;		ld a, 20   ; TODO get actual length 
2c09			;		call addatohl    ; include a random amount of room for the uword name 
2c09			; 
2c09			;		 
2c09			;	if DEBUG_FORTH_WORDS 
2c09			;		DMARK "Lt1" 
2c09			;		CALLMONITOR 
2c09			;	endif 
2c09			;		 
2c09			; 
2c09			;; malloc space for the string because we cant change it 
2c09			; 
2c09			;		call malloc 
2c09			;	if DEBUG_FORTH_MALLOC_GUARD 
2c09			;		push af 
2c09			;		call ishlzero 
2c09			;		pop af 
2c09			;		 
2c09			;		call z,malloc_error 
2c09			;	endif 
2c09			; 
2c09			;	if DEBUG_FORTH_WORDS 
2c09			;		DMARK "Lt2" 
2c09			;		CALLMONITOR 
2c09			;	endif 
2c09			;		pop de 
2c09			;		push hl    ; push the malloc to release later 
2c09			;		push hl   ;  push back a copy for the later stack push 
2c09			;		 
2c09			;; copy the string swapping out the zero terms for spaces 
2c09			; 
2c09			;		; de has our source 
2c09			;		; hl has our dest 
2c09			; 
2c09			;; add the coln def 
2c09			; 
2c09			;		ld a, ':' 
2c09			;		ld (hl), a 
2c09			;		inc hl 
2c09			;		ld a, ' ' 
2c09			;		ld (hl), a 
2c09			;		inc hl 
2c09			; 
2c09			;; add the uname word 
2c09			;		push de   ; save our string for now 
2c09			;		ex de, hl 
2c09			; 
2c09			;		FORTH_DSP_VALUE 
2c09			;		;v5 FORTH_DSP_VALUE 
2c09			; 
2c09			;		inc hl   ; skip type but we know by now this is OK 
2c09			; 
2c09			;.luword:	ld a,(hl) 
2c09			;		cp 0 
2c09			;		jr z, .luword2 
2c09			;		ld (de), a 
2c09			;		inc de 
2c09			;		inc hl 
2c09			;		jr .luword 
2c09			; 
2c09			;.luword2:	ld a, ' ' 
2c09			;		ld (de), a 
2c09			;;		inc hl 
2c09			;;		inc de 
2c09			;;		ld (de), a 
2c09			;;		inc hl 
2c09			;		inc de 
2c09			; 
2c09			;		ex de, hl 
2c09			;		pop de 
2c09			;		 
2c09			;		 
2c09			; 
2c09			;; detoken that string and copy it 
2c09			; 
2c09			;	if DEBUG_FORTH_WORDS 
2c09			;		DMARK "Lt2" 
2c09			;		CALLMONITOR 
2c09			;	endif 
2c09			;.ldetok:	ld a, (de) 
2c09			;		cp FORTH_END_BUFFER 
2c09			;		jr z, .ldetokend 
2c09			;		; swap out any zero term for space 
2c09			;		cp 0 
2c09			;		jr nz, .ldetoknext 
2c09			;		ld a, ' ' 
2c09			; 
2c09			;	if DEBUG_FORTH_WORDS 
2c09			;		DMARK "LtS" 
2c09			;		CALLMONITOR 
2c09			;	endif 
2c09			;.ldetoknext:	ld (hl), a 
2c09			;		inc de 
2c09			;		inc hl 
2c09			;		jr .ldetok 
2c09			; 
2c09			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2c09			;		ld (hl), a  
2c09			; 
2c09			;; free that temp malloc 
2c09			; 
2c09			;		pop hl    
2c09			; 
2c09			;	if DEBUG_FORTH_WORDS 
2c09			;		DMARK "Lt4" 
2c09			;		CALLMONITOR 
2c09			;	endif 
2c09			;		call forth_apushstrhl 
2c09			; 
2c09			;		; get rid of temp malloc area 
2c09			; 
2c09			;		pop hl 
2c09			;		call free 
2c09			; 
2c09			;		jr .ludone 
2c09			; 
2c09			;.lnuword:	pop hl 
2c09			;		call forth_tok_next 
2c09			;		jp .ldouscan  
2c09			; 
2c09			;.ludone:		 pop hl 
2c09			; 
2c09					NEXTW 
2c09 c3 90 1f			jp macro_next 
2c0c				endm 
# End of macro NEXTW
2c0c			 
2c0c			.FORGET: 
2c0c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2c0c 5d				db WORD_SYS_CORE+73             
2c0d 85 2c			dw .NOP            
2c0f 07				db 6 + 1 
2c10 .. 00			db "FORGET",0              
2c17				endm 
# End of macro CWHEAD
2c17			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2c17			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2c17			; | |  
2c17			; | | e.g. "MORE" forget 
2c17					if DEBUG_FORTH_WORDS_KEY 
2c17						DMARK "FRG" 
2c17 f5				push af  
2c18 3a 2c 2c			ld a, (.dmark)  
2c1b 32 77 fb			ld (debug_mark),a  
2c1e 3a 2d 2c			ld a, (.dmark+1)  
2c21 32 78 fb			ld (debug_mark+1),a  
2c24 3a 2e 2c			ld a, (.dmark+2)  
2c27 32 79 fb			ld (debug_mark+2),a  
2c2a 18 03			jr .pastdmark  
2c2c ..			.dmark: db "FRG"  
2c2f f1			.pastdmark: pop af  
2c30			endm  
# End of macro DMARK
2c30						CALLMONITOR 
2c30 cd 97 16			call break_point_state  
2c33				endm  
# End of macro CALLMONITOR
2c33					endif 
2c33			 
2c33				; find uword 
2c33			        ; update start of word with "_" 
2c33				; replace uword with deleted flag 
2c33			 
2c33			 
2c33			;	if DEBUG_FORTH_WORDS 
2c33			;		DMARK "FOG" 
2c33			;		CALLMONITOR 
2c33			;	endif 
2c33			 
2c33			 
2c33					; Get ptr to the word we need to look up 
2c33			 
2c33					FORTH_DSP_VALUEHL 
2c33 cd 1e 1e			call macro_dsp_valuehl 
2c36				endm 
# End of macro FORTH_DSP_VALUEHL
2c36					;v5 FORTH_DSP_VALUE 
2c36				; TODO type check 
2c36			;		inc hl    ; Skip type check  
2c36 e5					push hl 
2c37 c1					pop bc 
2c38			;		ex de, hl    ; put into DE 
2c38			 
2c38			 
2c38 21 00 80				ld hl, baseram 
2c3b					;ld hl, baseusermem 
2c3b			 
2c3b				; skip dict stub 
2c3b			;	call forth_tok_next 
2c3b e5			push hl   ; sacreifical push 
2c3c			 
2c3c			.fldouscanm: 
2c3c e1				pop hl 
2c3d			.fldouscan: 
2c3d			;	if DEBUG_FORTH_WORDS 
2c3d			;		DMARK "LSs" 
2c3d			;		CALLMONITOR 
2c3d			;	endif 
2c3d				; skip dict stub 
2c3d cd e1 20				call forth_tok_next 
2c40			 
2c40			 
2c40			; while we have words to look for 
2c40			 
2c40 7e				ld a, (hl)      
2c41			;	if DEBUG_FORTH_WORDS 
2c41			;		DMARK "LSk" 
2c41			;		CALLMONITOR 
2c41			;	endif 
2c41 fe 00				cp WORD_SYS_END 
2c43 ca 7f 2c				jp z, .flunotfound 
2c46 fe 01				cp WORD_SYS_UWORD 
2c48 c2 3d 2c				jp nz, .fldouscan 
2c4b			 
2c4b			;	if DEBUG_FORTH_WORDS 
2c4b			;		DMARK "LSu" 
2c4b			;		CALLMONITOR 
2c4b			;	endif 
2c4b			 
2c4b					; found a uword but is it the one we want... 
2c4b			 
2c4b c5					push bc     ; uword to find is on bc 
2c4c d1					pop de 
2c4d			 
2c4d e5					push hl  ; to save the ptr 
2c4e			 
2c4e					; skip opcode 
2c4e 23					inc hl  
2c4f					; skip next ptr 
2c4f 23					inc hl  
2c50 23					inc hl 
2c51					; skip len 
2c51 23					inc hl 
2c52			 
2c52			;	if DEBUG_FORTH_WORDS 
2c52			;		DMARK "LSc" 
2c52			;		CALLMONITOR 
2c52			;	endif 
2c52 cd 9f 11				call strcmp 
2c55 c2 3c 2c				jp nz, .fldouscanm 
2c58			; 
2c58			; 
2c58			;; while we have words to look for 
2c58			; 
2c58			;.fdouscan:	ld a, (hl)      
2c58			;	if DEBUG_FORTH_WORDS 
2c58			;		DMARK "LSs" 
2c58			;		CALLMONITOR 
2c58			;	endif 
2c58			;		cp WORD_SYS_END 
2c58			;		jp z, .fudone 
2c58			;		cp WORD_SYS_UWORD 
2c58			;		jp nz, .fnuword 
2c58			; 
2c58			;	if DEBUG_FORTH_WORDS 
2c58			;		DMARK "FGu" 
2c58			;		CALLMONITOR 
2c58			;	endif 
2c58			; 
2c58			;		; found a uword but is it the one we want... 
2c58			; 
2c58			; 
2c58			;	        pop de   ; get back the dsp name 
2c58			;		push de 
2c58			; 
2c58			;		push hl  ; to save the ptr 
2c58			; 
2c58			;		; skip opcode 
2c58			;		inc hl  
2c58			;		; skip next ptr 
2c58			;		inc hl  
2c58			;		inc hl 
2c58			;		; skip len 
2c58			;		inc hl 
2c58			; 
2c58			;	if DEBUG_FORTH_WORDS 
2c58			;		DMARK "FGc" 
2c58			;		CALLMONITOR 
2c58			;	endif 
2c58			;		call strcmp 
2c58			;		jp nz, .fnuword 
2c58			 
2c58			 
2c58 e1			pop hl 
2c59			 
2c59				 
2c59				if DEBUG_FORTH_WORDS 
2c59					DMARK "FGm" 
2c59 f5				push af  
2c5a 3a 6e 2c			ld a, (.dmark)  
2c5d 32 77 fb			ld (debug_mark),a  
2c60 3a 6f 2c			ld a, (.dmark+1)  
2c63 32 78 fb			ld (debug_mark+1),a  
2c66 3a 70 2c			ld a, (.dmark+2)  
2c69 32 79 fb			ld (debug_mark+2),a  
2c6c 18 03			jr .pastdmark  
2c6e ..			.dmark: db "FGm"  
2c71 f1			.pastdmark: pop af  
2c72			endm  
# End of macro DMARK
2c72					CALLMONITOR 
2c72 cd 97 16			call break_point_state  
2c75				endm  
# End of macro CALLMONITOR
2c75				endif 
2c75			 
2c75			 
2c75			 
2c75					; we have a uword so push its name to the stack 
2c75			 
2c75			;	   	push hl  ; save so we can move to next dict block 
2c75			;pop hl 
2c75			 
2c75					; update opcode to deleted 
2c75 3e 03				ld a, WORD_SYS_DELETED 
2c77 77					ld (hl), a 
2c78			 
2c78 23					inc hl  
2c79					; skip next ptr 
2c79 23					inc hl  
2c7a 23					inc hl 
2c7b					; skip len 
2c7b 23					inc hl 
2c7c			 
2c7c					; TODO change parser to skip deleted words but for now mark it out 
2c7c 3e 5f				ld a, "_" 
2c7e 77					ld  (hl),a 
2c7f			 
2c7f			;		jr .fudone 
2c7f			; 
2c7f			;.fnuword:	pop hl 
2c7f			;		call forth_tok_next 
2c7f			;		jp .fdouscan  
2c7f			 
2c7f			.flunotfound:		  
2c7f			 
2c7f			 
2c7f					 
2c7f					FORTH_DSP_POP 
2c7f cd d6 1e			call macro_forth_dsp_pop 
2c82				endm 
# End of macro FORTH_DSP_POP
2c82			;		ld hl, .luno 
2c82			;.fudone:		 pop hl 
2c82					NEXTW 
2c82 c3 90 1f			jp macro_next 
2c85				endm 
# End of macro NEXTW
2c85			.NOP: 
2c85				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2c85 61				db WORD_SYS_CORE+77             
2c86 ac 2c			dw .COMO            
2c88 04				db 3 + 1 
2c89 .. 00			db "NOP",0              
2c8d				endm 
# End of macro CWHEAD
2c8d			; | NOP (  --  ) Do nothing | DONE 
2c8d					if DEBUG_FORTH_WORDS_KEY 
2c8d						DMARK "NOP" 
2c8d f5				push af  
2c8e 3a a2 2c			ld a, (.dmark)  
2c91 32 77 fb			ld (debug_mark),a  
2c94 3a a3 2c			ld a, (.dmark+1)  
2c97 32 78 fb			ld (debug_mark+1),a  
2c9a 3a a4 2c			ld a, (.dmark+2)  
2c9d 32 79 fb			ld (debug_mark+2),a  
2ca0 18 03			jr .pastdmark  
2ca2 ..			.dmark: db "NOP"  
2ca5 f1			.pastdmark: pop af  
2ca6			endm  
# End of macro DMARK
2ca6						CALLMONITOR 
2ca6 cd 97 16			call break_point_state  
2ca9				endm  
# End of macro CALLMONITOR
2ca9					endif 
2ca9				       NEXTW 
2ca9 c3 90 1f			jp macro_next 
2cac				endm 
# End of macro NEXTW
2cac			.COMO: 
2cac				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2cac 6e				db WORD_SYS_CORE+90             
2cad fe 2c			dw .COMC            
2caf 02				db 1 + 1 
2cb0 .. 00			db "(",0              
2cb2				endm 
# End of macro CWHEAD
2cb2			; | ( ( -- )  Start of comment | DONE 
2cb2			 
2cb2			 
2cb2 2a 1e f1				ld hl, ( os_tok_ptr) 
2cb5 11 f9 2c			ld de, .closepar 
2cb8					 
2cb8					if DEBUG_FORTH_WORDS 
2cb8						DMARK ").." 
2cb8 f5				push af  
2cb9 3a cd 2c			ld a, (.dmark)  
2cbc 32 77 fb			ld (debug_mark),a  
2cbf 3a ce 2c			ld a, (.dmark+1)  
2cc2 32 78 fb			ld (debug_mark+1),a  
2cc5 3a cf 2c			ld a, (.dmark+2)  
2cc8 32 79 fb			ld (debug_mark+2),a  
2ccb 18 03			jr .pastdmark  
2ccd ..			.dmark: db ").."  
2cd0 f1			.pastdmark: pop af  
2cd1			endm  
# End of macro DMARK
2cd1						CALLMONITOR 
2cd1 cd 97 16			call break_point_state  
2cd4				endm  
# End of macro CALLMONITOR
2cd4					endif 
2cd4 cd ab 20			call findnexttok  
2cd7			 
2cd7					if DEBUG_FORTH_WORDS 
2cd7						DMARK "IF5" 
2cd7 f5				push af  
2cd8 3a ec 2c			ld a, (.dmark)  
2cdb 32 77 fb			ld (debug_mark),a  
2cde 3a ed 2c			ld a, (.dmark+1)  
2ce1 32 78 fb			ld (debug_mark+1),a  
2ce4 3a ee 2c			ld a, (.dmark+2)  
2ce7 32 79 fb			ld (debug_mark+2),a  
2cea 18 03			jr .pastdmark  
2cec ..			.dmark: db "IF5"  
2cef f1			.pastdmark: pop af  
2cf0			endm  
# End of macro DMARK
2cf0						CALLMONITOR 
2cf0 cd 97 16			call break_point_state  
2cf3				endm  
# End of macro CALLMONITOR
2cf3					endif 
2cf3				; replace below with ) exec using tok_ptr 
2cf3 22 1e f1			ld (os_tok_ptr), hl 
2cf6 c3 21 20			jp exec1 
2cf9			 
2cf9 .. 00			.closepar:   db ")",0 
2cfb			 
2cfb				       NEXTW 
2cfb c3 90 1f			jp macro_next 
2cfe				endm 
# End of macro NEXTW
2cfe			.COMC: 
2cfe				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2cfe 6f				db WORD_SYS_CORE+91             
2cff 07 2d			dw .SCRATCH            
2d01 02				db 1 + 1 
2d02 .. 00			db ")",0              
2d04				endm 
# End of macro CWHEAD
2d04			; | ) ( -- )  End of comment |  DONE  
2d04				       NEXTW 
2d04 c3 90 1f			jp macro_next 
2d07				endm 
# End of macro NEXTW
2d07			 
2d07			.SCRATCH: 
2d07				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2d07 6f				db WORD_SYS_CORE+91             
2d08 42 2d			dw .INC            
2d0a 08				db 7 + 1 
2d0b .. 00			db "SCRATCH",0              
2d13				endm 
# End of macro CWHEAD
2d13			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2d13			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2d13			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2d13			; | |  
2d13			; | | e.g.    : score $00 scratch ; 
2d13			; | |  
2d13			; | | $00 score ! 
2d13			; | | $01 score +! 
2d13			; | |  
2d13			; | | e.g.   : varword $0a scratch ;  
2d13			; | | 
2d13			; | | $8000 varword ! 
2d13					if DEBUG_FORTH_WORDS_KEY 
2d13						DMARK "SCR" 
2d13 f5				push af  
2d14 3a 28 2d			ld a, (.dmark)  
2d17 32 77 fb			ld (debug_mark),a  
2d1a 3a 29 2d			ld a, (.dmark+1)  
2d1d 32 78 fb			ld (debug_mark+1),a  
2d20 3a 2a 2d			ld a, (.dmark+2)  
2d23 32 79 fb			ld (debug_mark+2),a  
2d26 18 03			jr .pastdmark  
2d28 ..			.dmark: db "SCR"  
2d2b f1			.pastdmark: pop af  
2d2c			endm  
# End of macro DMARK
2d2c						CALLMONITOR 
2d2c cd 97 16			call break_point_state  
2d2f				endm  
# End of macro CALLMONITOR
2d2f					endif 
2d2f			 
2d2f					FORTH_DSP_VALUEHL 
2d2f cd 1e 1e			call macro_dsp_valuehl 
2d32				endm 
# End of macro FORTH_DSP_VALUEHL
2d32				 
2d32					FORTH_DSP_POP 
2d32 cd d6 1e			call macro_forth_dsp_pop 
2d35				endm 
# End of macro FORTH_DSP_POP
2d35			 
2d35 7d					ld a, l 
2d36 21 42 f3				ld hl, os_var_array 
2d39 cd 09 0d				call addatohl 
2d3c			 
2d3c cd 27 1c				call forth_push_numhl 
2d3f			 
2d3f				       NEXTW 
2d3f c3 90 1f			jp macro_next 
2d42				endm 
# End of macro NEXTW
2d42			 
2d42			.INC: 
2d42				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2d42 6f				db WORD_SYS_CORE+91             
2d43 96 2d			dw .DEC            
2d45 03				db 2 + 1 
2d46 .. 00			db "+!",0              
2d49				endm 
# End of macro CWHEAD
2d49			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2d49					if DEBUG_FORTH_WORDS_KEY 
2d49						DMARK "+s_" 
2d49 f5				push af  
2d4a 3a 5e 2d			ld a, (.dmark)  
2d4d 32 77 fb			ld (debug_mark),a  
2d50 3a 5f 2d			ld a, (.dmark+1)  
2d53 32 78 fb			ld (debug_mark+1),a  
2d56 3a 60 2d			ld a, (.dmark+2)  
2d59 32 79 fb			ld (debug_mark+2),a  
2d5c 18 03			jr .pastdmark  
2d5e ..			.dmark: db "+s_"  
2d61 f1			.pastdmark: pop af  
2d62			endm  
# End of macro DMARK
2d62						CALLMONITOR 
2d62 cd 97 16			call break_point_state  
2d65				endm  
# End of macro CALLMONITOR
2d65					endif 
2d65			 
2d65					FORTH_DSP_VALUEHL 
2d65 cd 1e 1e			call macro_dsp_valuehl 
2d68				endm 
# End of macro FORTH_DSP_VALUEHL
2d68			 
2d68 e5					push hl   ; save address 
2d69			 
2d69					FORTH_DSP_POP 
2d69 cd d6 1e			call macro_forth_dsp_pop 
2d6c				endm 
# End of macro FORTH_DSP_POP
2d6c			 
2d6c					FORTH_DSP_VALUEHL 
2d6c cd 1e 1e			call macro_dsp_valuehl 
2d6f				endm 
# End of macro FORTH_DSP_VALUEHL
2d6f			 
2d6f					FORTH_DSP_POP 
2d6f cd d6 1e			call macro_forth_dsp_pop 
2d72				endm 
# End of macro FORTH_DSP_POP
2d72			 
2d72					; hl contains value to add to byte at a 
2d72				 
2d72 eb					ex de, hl 
2d73			 
2d73 e1					pop hl 
2d74			 
2d74					if DEBUG_FORTH_WORDS 
2d74						DMARK "INC" 
2d74 f5				push af  
2d75 3a 89 2d			ld a, (.dmark)  
2d78 32 77 fb			ld (debug_mark),a  
2d7b 3a 8a 2d			ld a, (.dmark+1)  
2d7e 32 78 fb			ld (debug_mark+1),a  
2d81 3a 8b 2d			ld a, (.dmark+2)  
2d84 32 79 fb			ld (debug_mark+2),a  
2d87 18 03			jr .pastdmark  
2d89 ..			.dmark: db "INC"  
2d8c f1			.pastdmark: pop af  
2d8d			endm  
# End of macro DMARK
2d8d						CALLMONITOR 
2d8d cd 97 16			call break_point_state  
2d90				endm  
# End of macro CALLMONITOR
2d90					endif 
2d90			 
2d90 7e					ld a,(hl) 
2d91 83					add e 
2d92 77					ld (hl),a 
2d93			 
2d93			 
2d93			 
2d93				       NEXTW 
2d93 c3 90 1f			jp macro_next 
2d96				endm 
# End of macro NEXTW
2d96			 
2d96			.DEC: 
2d96				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d96 6f				db WORD_SYS_CORE+91             
2d97 e7 2d			dw .INC2            
2d99 03				db 2 + 1 
2d9a .. 00			db "-!",0              
2d9d				endm 
# End of macro CWHEAD
2d9d			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d9d					if DEBUG_FORTH_WORDS_KEY 
2d9d						DMARK "-s_" 
2d9d f5				push af  
2d9e 3a b2 2d			ld a, (.dmark)  
2da1 32 77 fb			ld (debug_mark),a  
2da4 3a b3 2d			ld a, (.dmark+1)  
2da7 32 78 fb			ld (debug_mark+1),a  
2daa 3a b4 2d			ld a, (.dmark+2)  
2dad 32 79 fb			ld (debug_mark+2),a  
2db0 18 03			jr .pastdmark  
2db2 ..			.dmark: db "-s_"  
2db5 f1			.pastdmark: pop af  
2db6			endm  
# End of macro DMARK
2db6						CALLMONITOR 
2db6 cd 97 16			call break_point_state  
2db9				endm  
# End of macro CALLMONITOR
2db9					endif 
2db9			 
2db9					FORTH_DSP_VALUEHL 
2db9 cd 1e 1e			call macro_dsp_valuehl 
2dbc				endm 
# End of macro FORTH_DSP_VALUEHL
2dbc			 
2dbc e5					push hl   ; save address 
2dbd			 
2dbd					FORTH_DSP_POP 
2dbd cd d6 1e			call macro_forth_dsp_pop 
2dc0				endm 
# End of macro FORTH_DSP_POP
2dc0			 
2dc0					FORTH_DSP_VALUEHL 
2dc0 cd 1e 1e			call macro_dsp_valuehl 
2dc3				endm 
# End of macro FORTH_DSP_VALUEHL
2dc3			 
2dc3					; hl contains value to add to byte at a 
2dc3				 
2dc3 eb					ex de, hl 
2dc4			 
2dc4 e1					pop hl 
2dc5			 
2dc5					if DEBUG_FORTH_WORDS 
2dc5						DMARK "DEC" 
2dc5 f5				push af  
2dc6 3a da 2d			ld a, (.dmark)  
2dc9 32 77 fb			ld (debug_mark),a  
2dcc 3a db 2d			ld a, (.dmark+1)  
2dcf 32 78 fb			ld (debug_mark+1),a  
2dd2 3a dc 2d			ld a, (.dmark+2)  
2dd5 32 79 fb			ld (debug_mark+2),a  
2dd8 18 03			jr .pastdmark  
2dda ..			.dmark: db "DEC"  
2ddd f1			.pastdmark: pop af  
2dde			endm  
# End of macro DMARK
2dde						CALLMONITOR 
2dde cd 97 16			call break_point_state  
2de1				endm  
# End of macro CALLMONITOR
2de1					endif 
2de1			 
2de1 7e					ld a,(hl) 
2de2 93					sub e 
2de3 77					ld (hl),a 
2de4			 
2de4			 
2de4			 
2de4				       NEXTW 
2de4 c3 90 1f			jp macro_next 
2de7				endm 
# End of macro NEXTW
2de7			 
2de7			.INC2: 
2de7				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2de7 6f				db WORD_SYS_CORE+91             
2de8 91 2e			dw .DEC2            
2dea 04				db 3 + 1 
2deb .. 00			db "+2!",0              
2def				endm 
# End of macro CWHEAD
2def			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2def			 
2def					if DEBUG_FORTH_WORDS_KEY 
2def						DMARK "+2s" 
2def f5				push af  
2df0 3a 04 2e			ld a, (.dmark)  
2df3 32 77 fb			ld (debug_mark),a  
2df6 3a 05 2e			ld a, (.dmark+1)  
2df9 32 78 fb			ld (debug_mark+1),a  
2dfc 3a 06 2e			ld a, (.dmark+2)  
2dff 32 79 fb			ld (debug_mark+2),a  
2e02 18 03			jr .pastdmark  
2e04 ..			.dmark: db "+2s"  
2e07 f1			.pastdmark: pop af  
2e08			endm  
# End of macro DMARK
2e08						CALLMONITOR 
2e08 cd 97 16			call break_point_state  
2e0b				endm  
# End of macro CALLMONITOR
2e0b					endif 
2e0b			 
2e0b					; Address 
2e0b			 
2e0b					FORTH_DSP_VALUEHL 
2e0b cd 1e 1e			call macro_dsp_valuehl 
2e0e				endm 
# End of macro FORTH_DSP_VALUEHL
2e0e			 
2e0e e5					push hl    ; save address 
2e0f			 
2e0f					; load content into de 
2e0f			 
2e0f 5e					ld e,(hl) 
2e10 23					inc hl 
2e11 56					ld d, (hl) 
2e12			 
2e12					if DEBUG_FORTH_WORDS 
2e12						DMARK "+2a" 
2e12 f5				push af  
2e13 3a 27 2e			ld a, (.dmark)  
2e16 32 77 fb			ld (debug_mark),a  
2e19 3a 28 2e			ld a, (.dmark+1)  
2e1c 32 78 fb			ld (debug_mark+1),a  
2e1f 3a 29 2e			ld a, (.dmark+2)  
2e22 32 79 fb			ld (debug_mark+2),a  
2e25 18 03			jr .pastdmark  
2e27 ..			.dmark: db "+2a"  
2e2a f1			.pastdmark: pop af  
2e2b			endm  
# End of macro DMARK
2e2b						CALLMONITOR 
2e2b cd 97 16			call break_point_state  
2e2e				endm  
# End of macro CALLMONITOR
2e2e					endif 
2e2e			 
2e2e					FORTH_DSP_POP 
2e2e cd d6 1e			call macro_forth_dsp_pop 
2e31				endm 
# End of macro FORTH_DSP_POP
2e31			 
2e31					; Get value to add 
2e31			 
2e31					FORTH_DSP_VALUE 
2e31 cd 07 1e			call macro_forth_dsp_value 
2e34				endm 
# End of macro FORTH_DSP_VALUE
2e34			 
2e34					if DEBUG_FORTH_WORDS 
2e34						DMARK "+2v" 
2e34 f5				push af  
2e35 3a 49 2e			ld a, (.dmark)  
2e38 32 77 fb			ld (debug_mark),a  
2e3b 3a 4a 2e			ld a, (.dmark+1)  
2e3e 32 78 fb			ld (debug_mark+1),a  
2e41 3a 4b 2e			ld a, (.dmark+2)  
2e44 32 79 fb			ld (debug_mark+2),a  
2e47 18 03			jr .pastdmark  
2e49 ..			.dmark: db "+2v"  
2e4c f1			.pastdmark: pop af  
2e4d			endm  
# End of macro DMARK
2e4d						CALLMONITOR 
2e4d cd 97 16			call break_point_state  
2e50				endm  
# End of macro CALLMONITOR
2e50					endif 
2e50			 
2e50 19					add hl, de 
2e51			 
2e51					if DEBUG_FORTH_WORDS 
2e51						DMARK "+2+" 
2e51 f5				push af  
2e52 3a 66 2e			ld a, (.dmark)  
2e55 32 77 fb			ld (debug_mark),a  
2e58 3a 67 2e			ld a, (.dmark+1)  
2e5b 32 78 fb			ld (debug_mark+1),a  
2e5e 3a 68 2e			ld a, (.dmark+2)  
2e61 32 79 fb			ld (debug_mark+2),a  
2e64 18 03			jr .pastdmark  
2e66 ..			.dmark: db "+2+"  
2e69 f1			.pastdmark: pop af  
2e6a			endm  
# End of macro DMARK
2e6a						CALLMONITOR 
2e6a cd 97 16			call break_point_state  
2e6d				endm  
# End of macro CALLMONITOR
2e6d					endif 
2e6d			 
2e6d					; move result to de 
2e6d			 
2e6d eb					ex de, hl 
2e6e			 
2e6e					; Address 
2e6e			 
2e6e e1					pop hl 
2e6f			 
2e6f					; save it back 
2e6f			 
2e6f 73					ld (hl), e 
2e70 23					inc hl 
2e71 72					ld (hl), d 
2e72			 
2e72					if DEBUG_FORTH_WORDS 
2e72						DMARK "+2e" 
2e72 f5				push af  
2e73 3a 87 2e			ld a, (.dmark)  
2e76 32 77 fb			ld (debug_mark),a  
2e79 3a 88 2e			ld a, (.dmark+1)  
2e7c 32 78 fb			ld (debug_mark+1),a  
2e7f 3a 89 2e			ld a, (.dmark+2)  
2e82 32 79 fb			ld (debug_mark+2),a  
2e85 18 03			jr .pastdmark  
2e87 ..			.dmark: db "+2e"  
2e8a f1			.pastdmark: pop af  
2e8b			endm  
# End of macro DMARK
2e8b						CALLMONITOR 
2e8b cd 97 16			call break_point_state  
2e8e				endm  
# End of macro CALLMONITOR
2e8e					endif 
2e8e			 
2e8e			 
2e8e			 
2e8e			 
2e8e			 
2e8e				       NEXTW 
2e8e c3 90 1f			jp macro_next 
2e91				endm 
# End of macro NEXTW
2e91			 
2e91			.DEC2: 
2e91				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2e91 6f				db WORD_SYS_CORE+91             
2e92 3d 2f			dw .GET2            
2e94 04				db 3 + 1 
2e95 .. 00			db "-2!",0              
2e99				endm 
# End of macro CWHEAD
2e99			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e99			 
2e99			 
2e99					if DEBUG_FORTH_WORDS_KEY 
2e99						DMARK "-2s" 
2e99 f5				push af  
2e9a 3a ae 2e			ld a, (.dmark)  
2e9d 32 77 fb			ld (debug_mark),a  
2ea0 3a af 2e			ld a, (.dmark+1)  
2ea3 32 78 fb			ld (debug_mark+1),a  
2ea6 3a b0 2e			ld a, (.dmark+2)  
2ea9 32 79 fb			ld (debug_mark+2),a  
2eac 18 03			jr .pastdmark  
2eae ..			.dmark: db "-2s"  
2eb1 f1			.pastdmark: pop af  
2eb2			endm  
# End of macro DMARK
2eb2						CALLMONITOR 
2eb2 cd 97 16			call break_point_state  
2eb5				endm  
# End of macro CALLMONITOR
2eb5					endif 
2eb5			 
2eb5					; Address 
2eb5			 
2eb5					FORTH_DSP_VALUEHL 
2eb5 cd 1e 1e			call macro_dsp_valuehl 
2eb8				endm 
# End of macro FORTH_DSP_VALUEHL
2eb8			 
2eb8 e5					push hl    ; save address 
2eb9			 
2eb9					; load content into de 
2eb9			 
2eb9 5e					ld e,(hl) 
2eba 23					inc hl 
2ebb 56					ld d, (hl) 
2ebc			 
2ebc					if DEBUG_FORTH_WORDS 
2ebc						DMARK "-2a" 
2ebc f5				push af  
2ebd 3a d1 2e			ld a, (.dmark)  
2ec0 32 77 fb			ld (debug_mark),a  
2ec3 3a d2 2e			ld a, (.dmark+1)  
2ec6 32 78 fb			ld (debug_mark+1),a  
2ec9 3a d3 2e			ld a, (.dmark+2)  
2ecc 32 79 fb			ld (debug_mark+2),a  
2ecf 18 03			jr .pastdmark  
2ed1 ..			.dmark: db "-2a"  
2ed4 f1			.pastdmark: pop af  
2ed5			endm  
# End of macro DMARK
2ed5						CALLMONITOR 
2ed5 cd 97 16			call break_point_state  
2ed8				endm  
# End of macro CALLMONITOR
2ed8					endif 
2ed8			 
2ed8					FORTH_DSP_POP 
2ed8 cd d6 1e			call macro_forth_dsp_pop 
2edb				endm 
# End of macro FORTH_DSP_POP
2edb			 
2edb					; Get value to remove 
2edb			 
2edb					FORTH_DSP_VALUE 
2edb cd 07 1e			call macro_forth_dsp_value 
2ede				endm 
# End of macro FORTH_DSP_VALUE
2ede			 
2ede					if DEBUG_FORTH_WORDS 
2ede						DMARK "-2v" 
2ede f5				push af  
2edf 3a f3 2e			ld a, (.dmark)  
2ee2 32 77 fb			ld (debug_mark),a  
2ee5 3a f4 2e			ld a, (.dmark+1)  
2ee8 32 78 fb			ld (debug_mark+1),a  
2eeb 3a f5 2e			ld a, (.dmark+2)  
2eee 32 79 fb			ld (debug_mark+2),a  
2ef1 18 03			jr .pastdmark  
2ef3 ..			.dmark: db "-2v"  
2ef6 f1			.pastdmark: pop af  
2ef7			endm  
# End of macro DMARK
2ef7						CALLMONITOR 
2ef7 cd 97 16			call break_point_state  
2efa				endm  
# End of macro CALLMONITOR
2efa					endif 
2efa			 
2efa eb					ex de, hl 
2efb ed 52				sbc hl, de 
2efd			 
2efd					if DEBUG_FORTH_WORDS 
2efd						DMARK "-2d" 
2efd f5				push af  
2efe 3a 12 2f			ld a, (.dmark)  
2f01 32 77 fb			ld (debug_mark),a  
2f04 3a 13 2f			ld a, (.dmark+1)  
2f07 32 78 fb			ld (debug_mark+1),a  
2f0a 3a 14 2f			ld a, (.dmark+2)  
2f0d 32 79 fb			ld (debug_mark+2),a  
2f10 18 03			jr .pastdmark  
2f12 ..			.dmark: db "-2d"  
2f15 f1			.pastdmark: pop af  
2f16			endm  
# End of macro DMARK
2f16						CALLMONITOR 
2f16 cd 97 16			call break_point_state  
2f19				endm  
# End of macro CALLMONITOR
2f19					endif 
2f19			 
2f19					; move result to de 
2f19			 
2f19 eb					ex de, hl 
2f1a			 
2f1a					; Address 
2f1a			 
2f1a e1					pop hl 
2f1b			 
2f1b					; save it back 
2f1b			 
2f1b 73					ld (hl), e 
2f1c 23					inc hl 
2f1d 72					ld (hl), d 
2f1e			 
2f1e					if DEBUG_FORTH_WORDS 
2f1e						DMARK "-2e" 
2f1e f5				push af  
2f1f 3a 33 2f			ld a, (.dmark)  
2f22 32 77 fb			ld (debug_mark),a  
2f25 3a 34 2f			ld a, (.dmark+1)  
2f28 32 78 fb			ld (debug_mark+1),a  
2f2b 3a 35 2f			ld a, (.dmark+2)  
2f2e 32 79 fb			ld (debug_mark+2),a  
2f31 18 03			jr .pastdmark  
2f33 ..			.dmark: db "-2e"  
2f36 f1			.pastdmark: pop af  
2f37			endm  
# End of macro DMARK
2f37						CALLMONITOR 
2f37 cd 97 16			call break_point_state  
2f3a				endm  
# End of macro CALLMONITOR
2f3a					endif 
2f3a			 
2f3a			 
2f3a			 
2f3a			 
2f3a			 
2f3a				       NEXTW 
2f3a c3 90 1f			jp macro_next 
2f3d				endm 
# End of macro NEXTW
2f3d			.GET2: 
2f3d				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2f3d 6f				db WORD_SYS_CORE+91             
2f3e 6d 2f			dw .BANG2            
2f40 03				db 2 + 1 
2f41 .. 00			db "2@",0              
2f44				endm 
# End of macro CWHEAD
2f44			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2f44					if DEBUG_FORTH_WORDS_KEY 
2f44						DMARK "2A_" 
2f44 f5				push af  
2f45 3a 59 2f			ld a, (.dmark)  
2f48 32 77 fb			ld (debug_mark),a  
2f4b 3a 5a 2f			ld a, (.dmark+1)  
2f4e 32 78 fb			ld (debug_mark+1),a  
2f51 3a 5b 2f			ld a, (.dmark+2)  
2f54 32 79 fb			ld (debug_mark+2),a  
2f57 18 03			jr .pastdmark  
2f59 ..			.dmark: db "2A_"  
2f5c f1			.pastdmark: pop af  
2f5d			endm  
# End of macro DMARK
2f5d						CALLMONITOR 
2f5d cd 97 16			call break_point_state  
2f60				endm  
# End of macro CALLMONITOR
2f60					endif 
2f60			 
2f60					FORTH_DSP_VALUEHL 
2f60 cd 1e 1e			call macro_dsp_valuehl 
2f63				endm 
# End of macro FORTH_DSP_VALUEHL
2f63			 
2f63 5e					ld e, (hl) 
2f64 23					inc hl 
2f65 56					ld d, (hl) 
2f66			 
2f66 eb					ex de, hl 
2f67			 
2f67 cd 27 1c				call forth_push_numhl 
2f6a			 
2f6a				       NEXTW 
2f6a c3 90 1f			jp macro_next 
2f6d				endm 
# End of macro NEXTW
2f6d			.BANG2: 
2f6d				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2f6d 6f				db WORD_SYS_CORE+91             
2f6e a5 2f			dw .CONFIG            
2f70 03				db 2 + 1 
2f71 .. 00			db "2!",0              
2f74				endm 
# End of macro CWHEAD
2f74			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2f74					if DEBUG_FORTH_WORDS_KEY 
2f74						DMARK "2S_" 
2f74 f5				push af  
2f75 3a 89 2f			ld a, (.dmark)  
2f78 32 77 fb			ld (debug_mark),a  
2f7b 3a 8a 2f			ld a, (.dmark+1)  
2f7e 32 78 fb			ld (debug_mark+1),a  
2f81 3a 8b 2f			ld a, (.dmark+2)  
2f84 32 79 fb			ld (debug_mark+2),a  
2f87 18 03			jr .pastdmark  
2f89 ..			.dmark: db "2S_"  
2f8c f1			.pastdmark: pop af  
2f8d			endm  
# End of macro DMARK
2f8d						CALLMONITOR 
2f8d cd 97 16			call break_point_state  
2f90				endm  
# End of macro CALLMONITOR
2f90					endif 
2f90			 
2f90					FORTH_DSP_VALUEHL 
2f90 cd 1e 1e			call macro_dsp_valuehl 
2f93				endm 
# End of macro FORTH_DSP_VALUEHL
2f93			 
2f93 e5					push hl   ; save address 
2f94			 
2f94			 
2f94					FORTH_DSP_POP 
2f94 cd d6 1e			call macro_forth_dsp_pop 
2f97				endm 
# End of macro FORTH_DSP_POP
2f97			 
2f97					 
2f97					FORTH_DSP_VALUEHL 
2f97 cd 1e 1e			call macro_dsp_valuehl 
2f9a				endm 
# End of macro FORTH_DSP_VALUEHL
2f9a			 
2f9a					FORTH_DSP_POP 
2f9a cd d6 1e			call macro_forth_dsp_pop 
2f9d				endm 
# End of macro FORTH_DSP_POP
2f9d			 
2f9d eb					ex de, hl    ; value now in de 
2f9e			 
2f9e e1					pop hl 
2f9f			 
2f9f 73					ld (hl), e 
2fa0			 
2fa0 23					inc hl 
2fa1			 
2fa1 72					ld (hl), d 
2fa2			 
2fa2			 
2fa2				       NEXTW 
2fa2 c3 90 1f			jp macro_next 
2fa5				endm 
# End of macro NEXTW
2fa5			.CONFIG: 
2fa5				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2fa5 6f				db WORD_SYS_CORE+91             
2fa6 b6 2f			dw .ENDCORE            
2fa8 07				db 6 + 1 
2fa9 .. 00			db "CONFIG",0              
2fb0				endm 
# End of macro CWHEAD
2fb0			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2fb0			 
2fb0 cd 93 13				call config 
2fb3					NEXTW 
2fb3 c3 90 1f			jp macro_next 
2fb6				endm 
# End of macro NEXTW
2fb6			.ENDCORE: 
2fb6			 
2fb6			; eof 
2fb6			 
2fb6			 
# End of file forth_words_core.asm
2fb6			include "forth_words_flow.asm" 
2fb6			 
2fb6			; | ## Program Flow Words 
2fb6			 
2fb6			.IF: 
2fb6				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2fb6 1e				db WORD_SYS_CORE+10             
2fb7 ab 30			dw .THEN            
2fb9 03				db 2 + 1 
2fba .. 00			db "IF",0              
2fbd				endm 
# End of macro CWHEAD
2fbd			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2fbd			; 
2fbd					if DEBUG_FORTH_WORDS_KEY 
2fbd						DMARK "IF." 
2fbd f5				push af  
2fbe 3a d2 2f			ld a, (.dmark)  
2fc1 32 77 fb			ld (debug_mark),a  
2fc4 3a d3 2f			ld a, (.dmark+1)  
2fc7 32 78 fb			ld (debug_mark+1),a  
2fca 3a d4 2f			ld a, (.dmark+2)  
2fcd 32 79 fb			ld (debug_mark+2),a  
2fd0 18 03			jr .pastdmark  
2fd2 ..			.dmark: db "IF."  
2fd5 f1			.pastdmark: pop af  
2fd6			endm  
# End of macro DMARK
2fd6						CALLMONITOR 
2fd6 cd 97 16			call break_point_state  
2fd9				endm  
# End of macro CALLMONITOR
2fd9					endif 
2fd9			; eval TOS 
2fd9			 
2fd9				FORTH_DSP_VALUEHL 
2fd9 cd 1e 1e			call macro_dsp_valuehl 
2fdc				endm 
# End of macro FORTH_DSP_VALUEHL
2fdc			 
2fdc			;	push hl 
2fdc				FORTH_DSP_POP 
2fdc cd d6 1e			call macro_forth_dsp_pop 
2fdf				endm 
# End of macro FORTH_DSP_POP
2fdf			;	pop hl 
2fdf			 
2fdf					if DEBUG_FORTH_WORDS 
2fdf						DMARK "IF1" 
2fdf f5				push af  
2fe0 3a f4 2f			ld a, (.dmark)  
2fe3 32 77 fb			ld (debug_mark),a  
2fe6 3a f5 2f			ld a, (.dmark+1)  
2fe9 32 78 fb			ld (debug_mark+1),a  
2fec 3a f6 2f			ld a, (.dmark+2)  
2fef 32 79 fb			ld (debug_mark+2),a  
2ff2 18 03			jr .pastdmark  
2ff4 ..			.dmark: db "IF1"  
2ff7 f1			.pastdmark: pop af  
2ff8			endm  
# End of macro DMARK
2ff8						CALLMONITOR 
2ff8 cd 97 16			call break_point_state  
2ffb				endm  
# End of macro CALLMONITOR
2ffb					endif 
2ffb b7				or a        ; clear carry flag 
2ffc 11 00 00			ld de, 0 
2fff eb				ex de,hl 
3000 ed 52			sbc hl, de 
3002 c2 8c 30			jp nz, .iftrue 
3005			 
3005					if DEBUG_FORTH_WORDS 
3005						DMARK "IF2" 
3005 f5				push af  
3006 3a 1a 30			ld a, (.dmark)  
3009 32 77 fb			ld (debug_mark),a  
300c 3a 1b 30			ld a, (.dmark+1)  
300f 32 78 fb			ld (debug_mark+1),a  
3012 3a 1c 30			ld a, (.dmark+2)  
3015 32 79 fb			ld (debug_mark+2),a  
3018 18 03			jr .pastdmark  
301a ..			.dmark: db "IF2"  
301d f1			.pastdmark: pop af  
301e			endm  
# End of macro DMARK
301e						CALLMONITOR 
301e cd 97 16			call break_point_state  
3021				endm  
# End of macro CALLMONITOR
3021					endif 
3021			 
3021			; if not true then skip to THEN 
3021			 
3021				; TODO get tok_ptr 
3021				; TODO consume toks until we get to THEN 
3021			 
3021 2a 1e f1			ld hl, (os_tok_ptr) 
3024					if DEBUG_FORTH_WORDS 
3024						DMARK "IF3" 
3024 f5				push af  
3025 3a 39 30			ld a, (.dmark)  
3028 32 77 fb			ld (debug_mark),a  
302b 3a 3a 30			ld a, (.dmark+1)  
302e 32 78 fb			ld (debug_mark+1),a  
3031 3a 3b 30			ld a, (.dmark+2)  
3034 32 79 fb			ld (debug_mark+2),a  
3037 18 03			jr .pastdmark  
3039 ..			.dmark: db "IF3"  
303c f1			.pastdmark: pop af  
303d			endm  
# End of macro DMARK
303d						CALLMONITOR 
303d cd 97 16			call break_point_state  
3040				endm  
# End of macro CALLMONITOR
3040						 
3040					endif 
3040 11 87 30			ld de, .ifthen 
3043					if DEBUG_FORTH_WORDS 
3043						DMARK "IF4" 
3043 f5				push af  
3044 3a 58 30			ld a, (.dmark)  
3047 32 77 fb			ld (debug_mark),a  
304a 3a 59 30			ld a, (.dmark+1)  
304d 32 78 fb			ld (debug_mark+1),a  
3050 3a 5a 30			ld a, (.dmark+2)  
3053 32 79 fb			ld (debug_mark+2),a  
3056 18 03			jr .pastdmark  
3058 ..			.dmark: db "IF4"  
305b f1			.pastdmark: pop af  
305c			endm  
# End of macro DMARK
305c						CALLMONITOR 
305c cd 97 16			call break_point_state  
305f				endm  
# End of macro CALLMONITOR
305f					endif 
305f cd ab 20			call findnexttok  
3062			 
3062					if DEBUG_FORTH_WORDS 
3062						DMARK "IF5" 
3062 f5				push af  
3063 3a 77 30			ld a, (.dmark)  
3066 32 77 fb			ld (debug_mark),a  
3069 3a 78 30			ld a, (.dmark+1)  
306c 32 78 fb			ld (debug_mark+1),a  
306f 3a 79 30			ld a, (.dmark+2)  
3072 32 79 fb			ld (debug_mark+2),a  
3075 18 03			jr .pastdmark  
3077 ..			.dmark: db "IF5"  
307a f1			.pastdmark: pop af  
307b			endm  
# End of macro DMARK
307b						CALLMONITOR 
307b cd 97 16			call break_point_state  
307e				endm  
# End of macro CALLMONITOR
307e					endif 
307e				; TODO replace below with ; exec using tok_ptr 
307e 22 1e f1			ld (os_tok_ptr), hl 
3081 c3 21 20			jp exec1 
3084				NEXTW 
3084 c3 90 1f			jp macro_next 
3087				endm 
# End of macro NEXTW
3087			 
3087 .. 00		.ifthen:  db "THEN",0 
308c			 
308c			.iftrue:		 
308c				; Exec next words normally 
308c			 
308c				; if true then exec following IF as normal 
308c					if DEBUG_FORTH_WORDS 
308c						DMARK "IFT" 
308c f5				push af  
308d 3a a1 30			ld a, (.dmark)  
3090 32 77 fb			ld (debug_mark),a  
3093 3a a2 30			ld a, (.dmark+1)  
3096 32 78 fb			ld (debug_mark+1),a  
3099 3a a3 30			ld a, (.dmark+2)  
309c 32 79 fb			ld (debug_mark+2),a  
309f 18 03			jr .pastdmark  
30a1 ..			.dmark: db "IFT"  
30a4 f1			.pastdmark: pop af  
30a5			endm  
# End of macro DMARK
30a5						CALLMONITOR 
30a5 cd 97 16			call break_point_state  
30a8				endm  
# End of macro CALLMONITOR
30a8					endif 
30a8			 
30a8					NEXTW 
30a8 c3 90 1f			jp macro_next 
30ab				endm 
# End of macro NEXTW
30ab			.THEN: 
30ab				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
30ab 1f				db WORD_SYS_CORE+11             
30ac d3 30			dw .ELSE            
30ae 05				db 4 + 1 
30af .. 00			db "THEN",0              
30b4				endm 
# End of macro CWHEAD
30b4			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
30b4					if DEBUG_FORTH_WORDS_KEY 
30b4						DMARK "THN" 
30b4 f5				push af  
30b5 3a c9 30			ld a, (.dmark)  
30b8 32 77 fb			ld (debug_mark),a  
30bb 3a ca 30			ld a, (.dmark+1)  
30be 32 78 fb			ld (debug_mark+1),a  
30c1 3a cb 30			ld a, (.dmark+2)  
30c4 32 79 fb			ld (debug_mark+2),a  
30c7 18 03			jr .pastdmark  
30c9 ..			.dmark: db "THN"  
30cc f1			.pastdmark: pop af  
30cd			endm  
# End of macro DMARK
30cd						CALLMONITOR 
30cd cd 97 16			call break_point_state  
30d0				endm  
# End of macro CALLMONITOR
30d0					endif 
30d0					NEXTW 
30d0 c3 90 1f			jp macro_next 
30d3				endm 
# End of macro NEXTW
30d3			.ELSE: 
30d3				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
30d3 20				db WORD_SYS_CORE+12             
30d4 fb 30			dw .DO            
30d6 03				db 2 + 1 
30d7 .. 00			db "ELSE",0              
30dc				endm 
# End of macro CWHEAD
30dc			; | ELSE ( -- ) Not supported - does nothing | TODO 
30dc			 
30dc					if DEBUG_FORTH_WORDS_KEY 
30dc						DMARK "ELS" 
30dc f5				push af  
30dd 3a f1 30			ld a, (.dmark)  
30e0 32 77 fb			ld (debug_mark),a  
30e3 3a f2 30			ld a, (.dmark+1)  
30e6 32 78 fb			ld (debug_mark+1),a  
30e9 3a f3 30			ld a, (.dmark+2)  
30ec 32 79 fb			ld (debug_mark+2),a  
30ef 18 03			jr .pastdmark  
30f1 ..			.dmark: db "ELS"  
30f4 f1			.pastdmark: pop af  
30f5			endm  
# End of macro DMARK
30f5						CALLMONITOR 
30f5 cd 97 16			call break_point_state  
30f8				endm  
# End of macro CALLMONITOR
30f8					endif 
30f8			 
30f8			 
30f8					NEXTW 
30f8 c3 90 1f			jp macro_next 
30fb				endm 
# End of macro NEXTW
30fb			.DO: 
30fb				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
30fb 21				db WORD_SYS_CORE+13             
30fc 22 32			dw .LOOP            
30fe 03				db 2 + 1 
30ff .. 00			db "DO",0              
3102				endm 
# End of macro CWHEAD
3102			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3102			 
3102					if DEBUG_FORTH_WORDS_KEY 
3102						DMARK "DO." 
3102 f5				push af  
3103 3a 17 31			ld a, (.dmark)  
3106 32 77 fb			ld (debug_mark),a  
3109 3a 18 31			ld a, (.dmark+1)  
310c 32 78 fb			ld (debug_mark+1),a  
310f 3a 19 31			ld a, (.dmark+2)  
3112 32 79 fb			ld (debug_mark+2),a  
3115 18 03			jr .pastdmark  
3117 ..			.dmark: db "DO."  
311a f1			.pastdmark: pop af  
311b			endm  
# End of macro DMARK
311b						CALLMONITOR 
311b cd 97 16			call break_point_state  
311e				endm  
# End of macro CALLMONITOR
311e					endif 
311e			;  push pc to rsp stack past the DO 
311e			 
311e 2a 1e f1				ld hl, (os_tok_ptr) 
3121 23					inc hl   ; D 
3122 23					inc hl  ; O 
3123 23					inc hl   ; null 
3124					if DEBUG_FORTH_WORDS 
3124						DMARK "DO2" 
3124 f5				push af  
3125 3a 39 31			ld a, (.dmark)  
3128 32 77 fb			ld (debug_mark),a  
312b 3a 3a 31			ld a, (.dmark+1)  
312e 32 78 fb			ld (debug_mark+1),a  
3131 3a 3b 31			ld a, (.dmark+2)  
3134 32 79 fb			ld (debug_mark+2),a  
3137 18 03			jr .pastdmark  
3139 ..			.dmark: db "DO2"  
313c f1			.pastdmark: pop af  
313d			endm  
# End of macro DMARK
313d						CALLMONITOR 
313d cd 97 16			call break_point_state  
3140				endm  
# End of macro CALLMONITOR
3140					endif 
3140					FORTH_RSP_NEXT 
3140 cd ce 1b			call macro_forth_rsp_next 
3143				endm 
# End of macro FORTH_RSP_NEXT
3143					if DEBUG_FORTH_WORDS 
3143						DMARK "DO3" 
3143 f5				push af  
3144 3a 58 31			ld a, (.dmark)  
3147 32 77 fb			ld (debug_mark),a  
314a 3a 59 31			ld a, (.dmark+1)  
314d 32 78 fb			ld (debug_mark+1),a  
3150 3a 5a 31			ld a, (.dmark+2)  
3153 32 79 fb			ld (debug_mark+2),a  
3156 18 03			jr .pastdmark  
3158 ..			.dmark: db "DO3"  
315b f1			.pastdmark: pop af  
315c			endm  
# End of macro DMARK
315c						CALLMONITOR 
315c cd 97 16			call break_point_state  
315f				endm  
# End of macro CALLMONITOR
315f					endif 
315f			 
315f					;if DEBUG_FORTH_WORDS 
315f				;		push hl 
315f			;		endif  
315f			 
315f			; get counters from data stack 
315f			 
315f			 
315f					FORTH_DSP_VALUEHL 
315f cd 1e 1e			call macro_dsp_valuehl 
3162				endm 
# End of macro FORTH_DSP_VALUEHL
3162 e5					push hl		 ; hl now has starting counter which needs to be tos 
3163			 
3163					if DEBUG_FORTH_WORDS 
3163						DMARK "DO4" 
3163 f5				push af  
3164 3a 78 31			ld a, (.dmark)  
3167 32 77 fb			ld (debug_mark),a  
316a 3a 79 31			ld a, (.dmark+1)  
316d 32 78 fb			ld (debug_mark+1),a  
3170 3a 7a 31			ld a, (.dmark+2)  
3173 32 79 fb			ld (debug_mark+2),a  
3176 18 03			jr .pastdmark  
3178 ..			.dmark: db "DO4"  
317b f1			.pastdmark: pop af  
317c			endm  
# End of macro DMARK
317c						CALLMONITOR 
317c cd 97 16			call break_point_state  
317f				endm  
# End of macro CALLMONITOR
317f					endif 
317f					FORTH_DSP_POP 
317f cd d6 1e			call macro_forth_dsp_pop 
3182				endm 
# End of macro FORTH_DSP_POP
3182			 
3182					if DEBUG_FORTH_WORDS 
3182						DMARK "DO5" 
3182 f5				push af  
3183 3a 97 31			ld a, (.dmark)  
3186 32 77 fb			ld (debug_mark),a  
3189 3a 98 31			ld a, (.dmark+1)  
318c 32 78 fb			ld (debug_mark+1),a  
318f 3a 99 31			ld a, (.dmark+2)  
3192 32 79 fb			ld (debug_mark+2),a  
3195 18 03			jr .pastdmark  
3197 ..			.dmark: db "DO5"  
319a f1			.pastdmark: pop af  
319b			endm  
# End of macro DMARK
319b						CALLMONITOR 
319b cd 97 16			call break_point_state  
319e				endm  
# End of macro CALLMONITOR
319e					endif 
319e			 
319e					FORTH_DSP_VALUEHL 
319e cd 1e 1e			call macro_dsp_valuehl 
31a1				endm 
# End of macro FORTH_DSP_VALUEHL
31a1			;		push hl		 ; hl now has starting limit counter 
31a1			 
31a1					if DEBUG_FORTH_WORDS 
31a1						DMARK "DO6" 
31a1 f5				push af  
31a2 3a b6 31			ld a, (.dmark)  
31a5 32 77 fb			ld (debug_mark),a  
31a8 3a b7 31			ld a, (.dmark+1)  
31ab 32 78 fb			ld (debug_mark+1),a  
31ae 3a b8 31			ld a, (.dmark+2)  
31b1 32 79 fb			ld (debug_mark+2),a  
31b4 18 03			jr .pastdmark  
31b6 ..			.dmark: db "DO6"  
31b9 f1			.pastdmark: pop af  
31ba			endm  
# End of macro DMARK
31ba						CALLMONITOR 
31ba cd 97 16			call break_point_state  
31bd				endm  
# End of macro CALLMONITOR
31bd					endif 
31bd					FORTH_DSP_POP 
31bd cd d6 1e			call macro_forth_dsp_pop 
31c0				endm 
# End of macro FORTH_DSP_POP
31c0			 
31c0			; put counters on the loop stack 
31c0			 
31c0			;		pop hl			 ; limit counter 
31c0 d1					pop de			; start counter 
31c1			 
31c1					; push limit counter 
31c1			 
31c1					if DEBUG_FORTH_WORDS 
31c1						DMARK "DO7" 
31c1 f5				push af  
31c2 3a d6 31			ld a, (.dmark)  
31c5 32 77 fb			ld (debug_mark),a  
31c8 3a d7 31			ld a, (.dmark+1)  
31cb 32 78 fb			ld (debug_mark+1),a  
31ce 3a d8 31			ld a, (.dmark+2)  
31d1 32 79 fb			ld (debug_mark+2),a  
31d4 18 03			jr .pastdmark  
31d6 ..			.dmark: db "DO7"  
31d9 f1			.pastdmark: pop af  
31da			endm  
# End of macro DMARK
31da						CALLMONITOR 
31da cd 97 16			call break_point_state  
31dd				endm  
# End of macro CALLMONITOR
31dd					endif 
31dd					FORTH_LOOP_NEXT 
31dd cd 4f 1e			call macro_forth_loop_next 
31e0				endm 
# End of macro FORTH_LOOP_NEXT
31e0			 
31e0					; push start counter 
31e0			 
31e0 eb					ex de, hl 
31e1					if DEBUG_FORTH_WORDS 
31e1						DMARK "DO7" 
31e1 f5				push af  
31e2 3a f6 31			ld a, (.dmark)  
31e5 32 77 fb			ld (debug_mark),a  
31e8 3a f7 31			ld a, (.dmark+1)  
31eb 32 78 fb			ld (debug_mark+1),a  
31ee 3a f8 31			ld a, (.dmark+2)  
31f1 32 79 fb			ld (debug_mark+2),a  
31f4 18 03			jr .pastdmark  
31f6 ..			.dmark: db "DO7"  
31f9 f1			.pastdmark: pop af  
31fa			endm  
# End of macro DMARK
31fa						CALLMONITOR 
31fa cd 97 16			call break_point_state  
31fd				endm  
# End of macro CALLMONITOR
31fd					endif 
31fd					FORTH_LOOP_NEXT 
31fd cd 4f 1e			call macro_forth_loop_next 
3200				endm 
# End of macro FORTH_LOOP_NEXT
3200			 
3200			 
3200					; init first round of I counter 
3200			 
3200 22 42 f1				ld (os_current_i), hl 
3203			 
3203					if DEBUG_FORTH_WORDS 
3203						DMARK "DO8" 
3203 f5				push af  
3204 3a 18 32			ld a, (.dmark)  
3207 32 77 fb			ld (debug_mark),a  
320a 3a 19 32			ld a, (.dmark+1)  
320d 32 78 fb			ld (debug_mark+1),a  
3210 3a 1a 32			ld a, (.dmark+2)  
3213 32 79 fb			ld (debug_mark+2),a  
3216 18 03			jr .pastdmark  
3218 ..			.dmark: db "DO8"  
321b f1			.pastdmark: pop af  
321c			endm  
# End of macro DMARK
321c						CALLMONITOR 
321c cd 97 16			call break_point_state  
321f				endm  
# End of macro CALLMONITOR
321f					endif 
321f			 
321f					NEXTW 
321f c3 90 1f			jp macro_next 
3222				endm 
# End of macro NEXTW
3222			.LOOP: 
3222				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3222 22				db WORD_SYS_CORE+14             
3223 3a 33			dw .I            
3225 05				db 4 + 1 
3226 .. 00			db "LOOP",0              
322b				endm 
# End of macro CWHEAD
322b			; | LOOP ( -- ) Increment and test loop counter  | DONE 
322b			 
322b				; pop tos as current loop count to hl 
322b			 
322b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
322b			 
322b				FORTH_LOOP_TOS 
322b cd 82 1e			call macro_forth_loop_tos 
322e				endm 
# End of macro FORTH_LOOP_TOS
322e e5				push hl 
322f			 
322f					if DEBUG_FORTH_WORDS_KEY 
322f						DMARK "LOP" 
322f f5				push af  
3230 3a 44 32			ld a, (.dmark)  
3233 32 77 fb			ld (debug_mark),a  
3236 3a 45 32			ld a, (.dmark+1)  
3239 32 78 fb			ld (debug_mark+1),a  
323c 3a 46 32			ld a, (.dmark+2)  
323f 32 79 fb			ld (debug_mark+2),a  
3242 18 03			jr .pastdmark  
3244 ..			.dmark: db "LOP"  
3247 f1			.pastdmark: pop af  
3248			endm  
# End of macro DMARK
3248						CALLMONITOR 
3248 cd 97 16			call break_point_state  
324b				endm  
# End of macro CALLMONITOR
324b					endif 
324b				; next item on the stack is the limit. get it 
324b			 
324b			 
324b				FORTH_LOOP_POP 
324b cd 8c 1e			call macro_forth_loop_pop 
324e				endm 
# End of macro FORTH_LOOP_POP
324e			 
324e				FORTH_LOOP_TOS 
324e cd 82 1e			call macro_forth_loop_tos 
3251				endm 
# End of macro FORTH_LOOP_TOS
3251			 
3251 d1				pop de		 ; de = i, hl = limit 
3252			 
3252					if DEBUG_FORTH_WORDS 
3252						DMARK "LP1" 
3252 f5				push af  
3253 3a 67 32			ld a, (.dmark)  
3256 32 77 fb			ld (debug_mark),a  
3259 3a 68 32			ld a, (.dmark+1)  
325c 32 78 fb			ld (debug_mark+1),a  
325f 3a 69 32			ld a, (.dmark+2)  
3262 32 79 fb			ld (debug_mark+2),a  
3265 18 03			jr .pastdmark  
3267 ..			.dmark: db "LP1"  
326a f1			.pastdmark: pop af  
326b			endm  
# End of macro DMARK
326b						CALLMONITOR 
326b cd 97 16			call break_point_state  
326e				endm  
# End of macro CALLMONITOR
326e					endif 
326e			 
326e				; go back to previous word 
326e			 
326e d5				push de    ; save I for inc later 
326f			 
326f			 
326f				; get limit 
326f				;  is I at limit? 
326f			 
326f			 
326f					if DEBUG_FORTH_WORDS 
326f						DMARK "LP1" 
326f f5				push af  
3270 3a 84 32			ld a, (.dmark)  
3273 32 77 fb			ld (debug_mark),a  
3276 3a 85 32			ld a, (.dmark+1)  
3279 32 78 fb			ld (debug_mark+1),a  
327c 3a 86 32			ld a, (.dmark+2)  
327f 32 79 fb			ld (debug_mark+2),a  
3282 18 03			jr .pastdmark  
3284 ..			.dmark: db "LP1"  
3287 f1			.pastdmark: pop af  
3288			endm  
# End of macro DMARK
3288						CALLMONITOR 
3288 cd 97 16			call break_point_state  
328b				endm  
# End of macro CALLMONITOR
328b					endif 
328b			 
328b ed 52			sbc hl, de 
328d			 
328d			 
328d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
328d			 
328d 20 26				jr nz, .loopnotdone 
328f			 
328f e1				pop hl   ; get rid of saved I 
3290				FORTH_LOOP_POP     ; get rid of limit 
3290 cd 8c 1e			call macro_forth_loop_pop 
3293				endm 
# End of macro FORTH_LOOP_POP
3293			 
3293				FORTH_RSP_POP     ; get rid of DO ptr 
3293 cd ef 1b			call macro_forth_rsp_pop 
3296				endm 
# End of macro FORTH_RSP_POP
3296			 
3296			if DEBUG_FORTH_WORDS 
3296						DMARK "LP>" 
3296 f5				push af  
3297 3a ab 32			ld a, (.dmark)  
329a 32 77 fb			ld (debug_mark),a  
329d 3a ac 32			ld a, (.dmark+1)  
32a0 32 78 fb			ld (debug_mark+1),a  
32a3 3a ad 32			ld a, (.dmark+2)  
32a6 32 79 fb			ld (debug_mark+2),a  
32a9 18 03			jr .pastdmark  
32ab ..			.dmark: db "LP>"  
32ae f1			.pastdmark: pop af  
32af			endm  
# End of macro DMARK
32af				CALLMONITOR 
32af cd 97 16			call break_point_state  
32b2				endm  
# End of macro CALLMONITOR
32b2			endif 
32b2			 
32b2					NEXTW 
32b2 c3 90 1f			jp macro_next 
32b5				endm 
# End of macro NEXTW
32b5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
32b5			 
32b5			.loopnotdone: 
32b5			 
32b5 e1				pop hl    ; get I 
32b6 23				inc hl 
32b7			 
32b7			   	; save new I 
32b7			 
32b7			 
32b7					; set I counter 
32b7			 
32b7 22 42 f1				ld (os_current_i), hl 
32ba			 
32ba					if DEBUG_FORTH_WORDS 
32ba						DMARK "LPN" 
32ba f5				push af  
32bb 3a cf 32			ld a, (.dmark)  
32be 32 77 fb			ld (debug_mark),a  
32c1 3a d0 32			ld a, (.dmark+1)  
32c4 32 78 fb			ld (debug_mark+1),a  
32c7 3a d1 32			ld a, (.dmark+2)  
32ca 32 79 fb			ld (debug_mark+2),a  
32cd 18 03			jr .pastdmark  
32cf ..			.dmark: db "LPN"  
32d2 f1			.pastdmark: pop af  
32d3			endm  
# End of macro DMARK
32d3					CALLMONITOR 
32d3 cd 97 16			call break_point_state  
32d6				endm  
# End of macro CALLMONITOR
32d6					endif 
32d6					 
32d6				FORTH_LOOP_NEXT 
32d6 cd 4f 1e			call macro_forth_loop_next 
32d9				endm 
# End of macro FORTH_LOOP_NEXT
32d9			 
32d9			 
32d9					if DEBUG_FORTH_WORDS 
32d9 eb						ex de,hl 
32da					endif 
32da			 
32da			;	; get DO ptr 
32da			; 
32da					if DEBUG_FORTH_WORDS 
32da						DMARK "LP7" 
32da f5				push af  
32db 3a ef 32			ld a, (.dmark)  
32de 32 77 fb			ld (debug_mark),a  
32e1 3a f0 32			ld a, (.dmark+1)  
32e4 32 78 fb			ld (debug_mark+1),a  
32e7 3a f1 32			ld a, (.dmark+2)  
32ea 32 79 fb			ld (debug_mark+2),a  
32ed 18 03			jr .pastdmark  
32ef ..			.dmark: db "LP7"  
32f2 f1			.pastdmark: pop af  
32f3			endm  
# End of macro DMARK
32f3					CALLMONITOR 
32f3 cd 97 16			call break_point_state  
32f6				endm  
# End of macro CALLMONITOR
32f6					endif 
32f6				FORTH_RSP_TOS 
32f6 cd e5 1b			call macro_forth_rsp_tos 
32f9				endm 
# End of macro FORTH_RSP_TOS
32f9			 
32f9					if DEBUG_FORTH_WORDS 
32f9						DMARK "LP8" 
32f9 f5				push af  
32fa 3a 0e 33			ld a, (.dmark)  
32fd 32 77 fb			ld (debug_mark),a  
3300 3a 0f 33			ld a, (.dmark+1)  
3303 32 78 fb			ld (debug_mark+1),a  
3306 3a 10 33			ld a, (.dmark+2)  
3309 32 79 fb			ld (debug_mark+2),a  
330c 18 03			jr .pastdmark  
330e ..			.dmark: db "LP8"  
3311 f1			.pastdmark: pop af  
3312			endm  
# End of macro DMARK
3312					CALLMONITOR 
3312 cd 97 16			call break_point_state  
3315				endm  
# End of macro CALLMONITOR
3315					endif 
3315				;push hl 
3315			 
3315				; not going to DO any more 
3315				; get rid of the RSP pointer as DO will add it back in 
3315				;FORTH_RSP_POP 
3315				;pop hl 
3315			 
3315				;ld hl,(cli_ret_sp) 
3315				;ld e, (hl) 
3315				;inc hl 
3315				;ld d, (hl) 
3315				;ex de,hl 
3315 22 1e f1			ld (os_tok_ptr), hl 
3318					if DEBUG_FORTH_WORDS 
3318						DMARK "LP<" 
3318 f5				push af  
3319 3a 2d 33			ld a, (.dmark)  
331c 32 77 fb			ld (debug_mark),a  
331f 3a 2e 33			ld a, (.dmark+1)  
3322 32 78 fb			ld (debug_mark+1),a  
3325 3a 2f 33			ld a, (.dmark+2)  
3328 32 79 fb			ld (debug_mark+2),a  
332b 18 03			jr .pastdmark  
332d ..			.dmark: db "LP<"  
3330 f1			.pastdmark: pop af  
3331			endm  
# End of macro DMARK
3331					CALLMONITOR 
3331 cd 97 16			call break_point_state  
3334				endm  
# End of macro CALLMONITOR
3334				endif 
3334 c3 21 20			jp exec1 
3337			 
3337					 
3337			 
3337			 
3337					NEXTW 
3337 c3 90 1f			jp macro_next 
333a				endm 
# End of macro NEXTW
333a			.I:  
333a			 
333a				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
333a 5e				db WORD_SYS_CORE+74             
333b 65 33			dw .DLOOP            
333d 02				db 1 + 1 
333e .. 00			db "I",0              
3340				endm 
# End of macro CWHEAD
3340			; | I ( -- ) Current loop counter | DONE 
3340					if DEBUG_FORTH_WORDS_KEY 
3340						DMARK "I.." 
3340 f5				push af  
3341 3a 55 33			ld a, (.dmark)  
3344 32 77 fb			ld (debug_mark),a  
3347 3a 56 33			ld a, (.dmark+1)  
334a 32 78 fb			ld (debug_mark+1),a  
334d 3a 57 33			ld a, (.dmark+2)  
3350 32 79 fb			ld (debug_mark+2),a  
3353 18 03			jr .pastdmark  
3355 ..			.dmark: db "I.."  
3358 f1			.pastdmark: pop af  
3359			endm  
# End of macro DMARK
3359						CALLMONITOR 
3359 cd 97 16			call break_point_state  
335c				endm  
# End of macro CALLMONITOR
335c					endif 
335c			 
335c 2a 42 f1				ld hl,(os_current_i) 
335f cd 27 1c				call forth_push_numhl 
3362			 
3362					NEXTW 
3362 c3 90 1f			jp macro_next 
3365				endm 
# End of macro NEXTW
3365			.DLOOP: 
3365				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3365 5f				db WORD_SYS_CORE+75             
3366 46 34			dw .REPEAT            
3368 06				db 5 + 1 
3369 .. 00			db "-LOOP",0              
336f				endm 
# End of macro CWHEAD
336f			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
336f				; pop tos as current loop count to hl 
336f					if DEBUG_FORTH_WORDS_KEY 
336f						DMARK "-LP" 
336f f5				push af  
3370 3a 84 33			ld a, (.dmark)  
3373 32 77 fb			ld (debug_mark),a  
3376 3a 85 33			ld a, (.dmark+1)  
3379 32 78 fb			ld (debug_mark+1),a  
337c 3a 86 33			ld a, (.dmark+2)  
337f 32 79 fb			ld (debug_mark+2),a  
3382 18 03			jr .pastdmark  
3384 ..			.dmark: db "-LP"  
3387 f1			.pastdmark: pop af  
3388			endm  
# End of macro DMARK
3388						CALLMONITOR 
3388 cd 97 16			call break_point_state  
338b				endm  
# End of macro CALLMONITOR
338b					endif 
338b			 
338b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
338b			 
338b				FORTH_LOOP_TOS 
338b cd 82 1e			call macro_forth_loop_tos 
338e				endm 
# End of macro FORTH_LOOP_TOS
338e e5				push hl 
338f			 
338f					if DEBUG_FORTH_WORDS 
338f						DMARK "-LP" 
338f f5				push af  
3390 3a a4 33			ld a, (.dmark)  
3393 32 77 fb			ld (debug_mark),a  
3396 3a a5 33			ld a, (.dmark+1)  
3399 32 78 fb			ld (debug_mark+1),a  
339c 3a a6 33			ld a, (.dmark+2)  
339f 32 79 fb			ld (debug_mark+2),a  
33a2 18 03			jr .pastdmark  
33a4 ..			.dmark: db "-LP"  
33a7 f1			.pastdmark: pop af  
33a8			endm  
# End of macro DMARK
33a8						CALLMONITOR 
33a8 cd 97 16			call break_point_state  
33ab				endm  
# End of macro CALLMONITOR
33ab					endif 
33ab				; next item on the stack is the limit. get it 
33ab			 
33ab			 
33ab				FORTH_LOOP_POP 
33ab cd 8c 1e			call macro_forth_loop_pop 
33ae				endm 
# End of macro FORTH_LOOP_POP
33ae			 
33ae				FORTH_LOOP_TOS 
33ae cd 82 1e			call macro_forth_loop_tos 
33b1				endm 
# End of macro FORTH_LOOP_TOS
33b1			 
33b1 d1				pop de		 ; de = i, hl = limit 
33b2			 
33b2					if DEBUG_FORTH_WORDS 
33b2						DMARK "-L1" 
33b2 f5				push af  
33b3 3a c7 33			ld a, (.dmark)  
33b6 32 77 fb			ld (debug_mark),a  
33b9 3a c8 33			ld a, (.dmark+1)  
33bc 32 78 fb			ld (debug_mark+1),a  
33bf 3a c9 33			ld a, (.dmark+2)  
33c2 32 79 fb			ld (debug_mark+2),a  
33c5 18 03			jr .pastdmark  
33c7 ..			.dmark: db "-L1"  
33ca f1			.pastdmark: pop af  
33cb			endm  
# End of macro DMARK
33cb						CALLMONITOR 
33cb cd 97 16			call break_point_state  
33ce				endm  
# End of macro CALLMONITOR
33ce					endif 
33ce			 
33ce				; go back to previous word 
33ce			 
33ce d5				push de    ; save I for inc later 
33cf			 
33cf			 
33cf				; get limit 
33cf				;  is I at limit? 
33cf			 
33cf			 
33cf					if DEBUG_FORTH_WORDS 
33cf						DMARK "-L1" 
33cf f5				push af  
33d0 3a e4 33			ld a, (.dmark)  
33d3 32 77 fb			ld (debug_mark),a  
33d6 3a e5 33			ld a, (.dmark+1)  
33d9 32 78 fb			ld (debug_mark+1),a  
33dc 3a e6 33			ld a, (.dmark+2)  
33df 32 79 fb			ld (debug_mark+2),a  
33e2 18 03			jr .pastdmark  
33e4 ..			.dmark: db "-L1"  
33e7 f1			.pastdmark: pop af  
33e8			endm  
# End of macro DMARK
33e8						CALLMONITOR 
33e8 cd 97 16			call break_point_state  
33eb				endm  
# End of macro CALLMONITOR
33eb					endif 
33eb			 
33eb ed 52			sbc hl, de 
33ed			 
33ed			 
33ed				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
33ed			 
33ed 20 26				jr nz, .mloopnotdone 
33ef			 
33ef e1				pop hl   ; get rid of saved I 
33f0				FORTH_LOOP_POP     ; get rid of limit 
33f0 cd 8c 1e			call macro_forth_loop_pop 
33f3				endm 
# End of macro FORTH_LOOP_POP
33f3			 
33f3				FORTH_RSP_POP     ; get rid of DO ptr 
33f3 cd ef 1b			call macro_forth_rsp_pop 
33f6				endm 
# End of macro FORTH_RSP_POP
33f6			 
33f6			if DEBUG_FORTH_WORDS 
33f6						DMARK "-L>" 
33f6 f5				push af  
33f7 3a 0b 34			ld a, (.dmark)  
33fa 32 77 fb			ld (debug_mark),a  
33fd 3a 0c 34			ld a, (.dmark+1)  
3400 32 78 fb			ld (debug_mark+1),a  
3403 3a 0d 34			ld a, (.dmark+2)  
3406 32 79 fb			ld (debug_mark+2),a  
3409 18 03			jr .pastdmark  
340b ..			.dmark: db "-L>"  
340e f1			.pastdmark: pop af  
340f			endm  
# End of macro DMARK
340f				CALLMONITOR 
340f cd 97 16			call break_point_state  
3412				endm  
# End of macro CALLMONITOR
3412			endif 
3412			 
3412					NEXTW 
3412 c3 90 1f			jp macro_next 
3415				endm 
# End of macro NEXTW
3415				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3415			 
3415			.mloopnotdone: 
3415			 
3415 e1				pop hl    ; get I 
3416 2b				dec hl 
3417			 
3417			   	; save new I 
3417			 
3417			 
3417					; set I counter 
3417			 
3417 22 42 f1				ld (os_current_i), hl 
341a			 
341a					 
341a				FORTH_LOOP_NEXT 
341a cd 4f 1e			call macro_forth_loop_next 
341d				endm 
# End of macro FORTH_LOOP_NEXT
341d			 
341d			 
341d					if DEBUG_FORTH_WORDS 
341d eb						ex de,hl 
341e					endif 
341e			 
341e			;	; get DO ptr 
341e			; 
341e				FORTH_RSP_TOS 
341e cd e5 1b			call macro_forth_rsp_tos 
3421				endm 
# End of macro FORTH_RSP_TOS
3421			 
3421				;push hl 
3421			 
3421				; not going to DO any more 
3421				; get rid of the RSP pointer as DO will add it back in 
3421				;FORTH_RSP_POP 
3421				;pop hl 
3421			 
3421			 
3421 22 1e f1			ld (os_tok_ptr), hl 
3424					if DEBUG_FORTH_WORDS 
3424						DMARK "-L<" 
3424 f5				push af  
3425 3a 39 34			ld a, (.dmark)  
3428 32 77 fb			ld (debug_mark),a  
342b 3a 3a 34			ld a, (.dmark+1)  
342e 32 78 fb			ld (debug_mark+1),a  
3431 3a 3b 34			ld a, (.dmark+2)  
3434 32 79 fb			ld (debug_mark+2),a  
3437 18 03			jr .pastdmark  
3439 ..			.dmark: db "-L<"  
343c f1			.pastdmark: pop af  
343d			endm  
# End of macro DMARK
343d					CALLMONITOR 
343d cd 97 16			call break_point_state  
3440				endm  
# End of macro CALLMONITOR
3440				endif 
3440 c3 21 20			jp exec1 
3443			 
3443					 
3443			 
3443			 
3443			 
3443				NEXTW 
3443 c3 90 1f			jp macro_next 
3446				endm 
# End of macro NEXTW
3446			 
3446			 
3446			 
3446			 
3446			.REPEAT: 
3446				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3446 71				db WORD_SYS_CORE+93             
3447 99 34			dw .UNTIL            
3449 06				db 5 + 1 
344a .. 00			db "REPEAT",0              
3451				endm 
# End of macro CWHEAD
3451			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3451			;  push pc to rsp stack past the REPEAT 
3451					if DEBUG_FORTH_WORDS_KEY 
3451						DMARK "REP" 
3451 f5				push af  
3452 3a 66 34			ld a, (.dmark)  
3455 32 77 fb			ld (debug_mark),a  
3458 3a 67 34			ld a, (.dmark+1)  
345b 32 78 fb			ld (debug_mark+1),a  
345e 3a 68 34			ld a, (.dmark+2)  
3461 32 79 fb			ld (debug_mark+2),a  
3464 18 03			jr .pastdmark  
3466 ..			.dmark: db "REP"  
3469 f1			.pastdmark: pop af  
346a			endm  
# End of macro DMARK
346a						CALLMONITOR 
346a cd 97 16			call break_point_state  
346d				endm  
# End of macro CALLMONITOR
346d					endif 
346d			 
346d 2a 1e f1				ld hl, (os_tok_ptr) 
3470 23					inc hl   ; R 
3471 23					inc hl  ; E 
3472 23					inc hl   ; P 
3473 23					inc hl   ; E 
3474 23					inc hl   ; A 
3475 23					inc hl   ; T 
3476 23					inc hl   ; zero 
3477					FORTH_RSP_NEXT 
3477 cd ce 1b			call macro_forth_rsp_next 
347a				endm 
# End of macro FORTH_RSP_NEXT
347a			 
347a			 
347a					if DEBUG_FORTH_WORDS 
347a						DMARK "REP" 
347a f5				push af  
347b 3a 8f 34			ld a, (.dmark)  
347e 32 77 fb			ld (debug_mark),a  
3481 3a 90 34			ld a, (.dmark+1)  
3484 32 78 fb			ld (debug_mark+1),a  
3487 3a 91 34			ld a, (.dmark+2)  
348a 32 79 fb			ld (debug_mark+2),a  
348d 18 03			jr .pastdmark  
348f ..			.dmark: db "REP"  
3492 f1			.pastdmark: pop af  
3493			endm  
# End of macro DMARK
3493						;pop bc    ; TODO BUG ?????? what is this for???? 
3493						CALLMONITOR 
3493 cd 97 16			call break_point_state  
3496				endm  
# End of macro CALLMONITOR
3496					endif 
3496			 
3496					NEXTW 
3496 c3 90 1f			jp macro_next 
3499				endm 
# End of macro NEXTW
3499			;	       NEXTW 
3499			 
3499			.UNTIL: 
3499				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3499 72				db WORD_SYS_CORE+94             
349a 30 35			dw .ENDFLOW            
349c 06				db 5 + 1 
349d .. 00			db "UNTIL",0              
34a3				endm 
# End of macro CWHEAD
34a3			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
34a3			 
34a3				; pop tos as check 
34a3			 
34a3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
34a3			 
34a3				FORTH_DSP_VALUEHL 
34a3 cd 1e 1e			call macro_dsp_valuehl 
34a6				endm 
# End of macro FORTH_DSP_VALUEHL
34a6			 
34a6					if DEBUG_FORTH_WORDS_KEY 
34a6						DMARK "UNT" 
34a6 f5				push af  
34a7 3a bb 34			ld a, (.dmark)  
34aa 32 77 fb			ld (debug_mark),a  
34ad 3a bc 34			ld a, (.dmark+1)  
34b0 32 78 fb			ld (debug_mark+1),a  
34b3 3a bd 34			ld a, (.dmark+2)  
34b6 32 79 fb			ld (debug_mark+2),a  
34b9 18 03			jr .pastdmark  
34bb ..			.dmark: db "UNT"  
34be f1			.pastdmark: pop af  
34bf			endm  
# End of macro DMARK
34bf						CALLMONITOR 
34bf cd 97 16			call break_point_state  
34c2				endm  
# End of macro CALLMONITOR
34c2					endif 
34c2			 
34c2			;	push hl 
34c2				FORTH_DSP_POP 
34c2 cd d6 1e			call macro_forth_dsp_pop 
34c5				endm 
# End of macro FORTH_DSP_POP
34c5			 
34c5			;	pop hl 
34c5			 
34c5				; test if true 
34c5			 
34c5 cd 32 0d			call ishlzero 
34c8			;	ld a,l 
34c8			;	add h 
34c8			; 
34c8			;	cp 0 
34c8			 
34c8 20 3e			jr nz, .untilnotdone 
34ca			 
34ca					if DEBUG_FORTH_WORDS 
34ca						DMARK "UNf" 
34ca f5				push af  
34cb 3a df 34			ld a, (.dmark)  
34ce 32 77 fb			ld (debug_mark),a  
34d1 3a e0 34			ld a, (.dmark+1)  
34d4 32 78 fb			ld (debug_mark+1),a  
34d7 3a e1 34			ld a, (.dmark+2)  
34da 32 79 fb			ld (debug_mark+2),a  
34dd 18 03			jr .pastdmark  
34df ..			.dmark: db "UNf"  
34e2 f1			.pastdmark: pop af  
34e3			endm  
# End of macro DMARK
34e3						CALLMONITOR 
34e3 cd 97 16			call break_point_state  
34e6				endm  
# End of macro CALLMONITOR
34e6					endif 
34e6			 
34e6			 
34e6			 
34e6				FORTH_RSP_POP     ; get rid of DO ptr 
34e6 cd ef 1b			call macro_forth_rsp_pop 
34e9				endm 
# End of macro FORTH_RSP_POP
34e9			 
34e9			if DEBUG_FORTH_WORDS 
34e9						DMARK "UN>" 
34e9 f5				push af  
34ea 3a fe 34			ld a, (.dmark)  
34ed 32 77 fb			ld (debug_mark),a  
34f0 3a ff 34			ld a, (.dmark+1)  
34f3 32 78 fb			ld (debug_mark+1),a  
34f6 3a 00 35			ld a, (.dmark+2)  
34f9 32 79 fb			ld (debug_mark+2),a  
34fc 18 03			jr .pastdmark  
34fe ..			.dmark: db "UN>"  
3501 f1			.pastdmark: pop af  
3502			endm  
# End of macro DMARK
3502				CALLMONITOR 
3502 cd 97 16			call break_point_state  
3505				endm  
# End of macro CALLMONITOR
3505			endif 
3505			 
3505					NEXTW 
3505 c3 90 1f			jp macro_next 
3508				endm 
# End of macro NEXTW
3508				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3508			 
3508			.untilnotdone: 
3508			 
3508			 
3508			;	; get DO ptr 
3508			; 
3508				FORTH_RSP_TOS 
3508 cd e5 1b			call macro_forth_rsp_tos 
350b				endm 
# End of macro FORTH_RSP_TOS
350b			 
350b				;push hl 
350b			 
350b				; not going to DO any more 
350b				; get rid of the RSP pointer as DO will add it back in 
350b				;FORTH_RSP_POP 
350b				;pop hl 
350b			 
350b			 
350b 22 1e f1			ld (os_tok_ptr), hl 
350e					if DEBUG_FORTH_WORDS 
350e						DMARK "UN<" 
350e f5				push af  
350f 3a 23 35			ld a, (.dmark)  
3512 32 77 fb			ld (debug_mark),a  
3515 3a 24 35			ld a, (.dmark+1)  
3518 32 78 fb			ld (debug_mark+1),a  
351b 3a 25 35			ld a, (.dmark+2)  
351e 32 79 fb			ld (debug_mark+2),a  
3521 18 03			jr .pastdmark  
3523 ..			.dmark: db "UN<"  
3526 f1			.pastdmark: pop af  
3527			endm  
# End of macro DMARK
3527					CALLMONITOR 
3527 cd 97 16			call break_point_state  
352a				endm  
# End of macro CALLMONITOR
352a				endif 
352a c3 21 20			jp exec1 
352d			 
352d					 
352d			 
352d			 
352d					NEXTW 
352d c3 90 1f			jp macro_next 
3530				endm 
# End of macro NEXTW
3530			 
3530			 
3530			.ENDFLOW: 
3530			 
3530			; eof 
3530			 
# End of file forth_words_flow.asm
3530			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3530			include "forth_words_logic.asm" 
3530			 
3530			; | ## Logic Words 
3530			 
3530			.NOT: 
3530				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3530 2d				db WORD_SYS_CORE+25             
3531 78 35			dw .IS            
3533 04				db 3 + 1 
3534 .. 00			db "NOT",0              
3538				endm 
# End of macro CWHEAD
3538			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3538					if DEBUG_FORTH_WORDS_KEY 
3538						DMARK "NOT" 
3538 f5				push af  
3539 3a 4d 35			ld a, (.dmark)  
353c 32 77 fb			ld (debug_mark),a  
353f 3a 4e 35			ld a, (.dmark+1)  
3542 32 78 fb			ld (debug_mark+1),a  
3545 3a 4f 35			ld a, (.dmark+2)  
3548 32 79 fb			ld (debug_mark+2),a  
354b 18 03			jr .pastdmark  
354d ..			.dmark: db "NOT"  
3550 f1			.pastdmark: pop af  
3551			endm  
# End of macro DMARK
3551						CALLMONITOR 
3551 cd 97 16			call break_point_state  
3554				endm  
# End of macro CALLMONITOR
3554					endif 
3554					FORTH_DSP 
3554 cd e4 1d			call macro_forth_dsp 
3557				endm 
# End of macro FORTH_DSP
3557 7e					ld a,(hl)	; get type of value on TOS 
3558 fe 02				cp DS_TYPE_INUM  
355a 28 03				jr z, .noti 
355c					NEXTW 
355c c3 90 1f			jp macro_next 
355f				endm 
# End of macro NEXTW
355f			.noti:          FORTH_DSP_VALUEHL 
355f cd 1e 1e			call macro_dsp_valuehl 
3562				endm 
# End of macro FORTH_DSP_VALUEHL
3562			;		push hl 
3562					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3562 cd d6 1e			call macro_forth_dsp_pop 
3565				endm 
# End of macro FORTH_DSP_POP
3565			;		pop hl 
3565 3e 00				ld a,0 
3567 bd					cp l 
3568 28 04				jr z, .not2t 
356a 2e 00				ld l, 0 
356c 18 02				jr .notip 
356e			 
356e 2e ff		.not2t:		ld l, 255 
3570			 
3570 26 00		.notip:		ld h, 0	 
3572			 
3572 cd 27 1c				call forth_push_numhl 
3575					NEXTW 
3575 c3 90 1f			jp macro_next 
3578				endm 
# End of macro NEXTW
3578			 
3578			.IS: 
3578				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3578 2d				db WORD_SYS_CORE+25             
3579 9e 35			dw .LZERO            
357b 03				db 2 + 1 
357c .. 00			db "IS",0              
357f				endm 
# End of macro CWHEAD
357f			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
357f					if DEBUG_FORTH_WORDS_KEY 
357f						DMARK "IS." 
357f f5				push af  
3580 3a 94 35			ld a, (.dmark)  
3583 32 77 fb			ld (debug_mark),a  
3586 3a 95 35			ld a, (.dmark+1)  
3589 32 78 fb			ld (debug_mark+1),a  
358c 3a 96 35			ld a, (.dmark+2)  
358f 32 79 fb			ld (debug_mark+2),a  
3592 18 03			jr .pastdmark  
3594 ..			.dmark: db "IS."  
3597 f1			.pastdmark: pop af  
3598			endm  
# End of macro DMARK
3598						CALLMONITOR 
3598 cd 97 16			call break_point_state  
359b				endm  
# End of macro CALLMONITOR
359b					endif 
359b					NEXTW 
359b c3 90 1f			jp macro_next 
359e				endm 
# End of macro NEXTW
359e			.LZERO: 
359e				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
359e 2d				db WORD_SYS_CORE+25             
359f a8 35			dw .TZERO            
35a1 03				db 2 + 1 
35a2 .. 00			db "0<",0              
35a5				endm 
# End of macro CWHEAD
35a5			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
35a5					NEXTW 
35a5 c3 90 1f			jp macro_next 
35a8				endm 
# End of macro NEXTW
35a8			.TZERO: 
35a8				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
35a8 2e				db WORD_SYS_CORE+26             
35a9 ef 35			dw .LESS            
35ab 03				db 2 + 1 
35ac .. 00			db "0=",0              
35af				endm 
# End of macro CWHEAD
35af			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
35af				; TODO add floating point number detection 
35af					;v5 FORTH_DSP_VALUE 
35af					if DEBUG_FORTH_WORDS_KEY 
35af						DMARK "0=." 
35af f5				push af  
35b0 3a c4 35			ld a, (.dmark)  
35b3 32 77 fb			ld (debug_mark),a  
35b6 3a c5 35			ld a, (.dmark+1)  
35b9 32 78 fb			ld (debug_mark+1),a  
35bc 3a c6 35			ld a, (.dmark+2)  
35bf 32 79 fb			ld (debug_mark+2),a  
35c2 18 03			jr .pastdmark  
35c4 ..			.dmark: db "0=."  
35c7 f1			.pastdmark: pop af  
35c8			endm  
# End of macro DMARK
35c8						CALLMONITOR 
35c8 cd 97 16			call break_point_state  
35cb				endm  
# End of macro CALLMONITOR
35cb					endif 
35cb					FORTH_DSP 
35cb cd e4 1d			call macro_forth_dsp 
35ce				endm 
# End of macro FORTH_DSP
35ce 7e					ld a,(hl)	; get type of value on TOS 
35cf fe 02				cp DS_TYPE_INUM  
35d1 28 00				jr z, .tz_inum 
35d3			 
35d3				if FORTH_ENABLE_FLOATMATH 
35d3					jr .tz_done 
35d3			 
35d3				endif 
35d3					 
35d3			 
35d3			.tz_inum: 
35d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35d3 cd 1e 1e			call macro_dsp_valuehl 
35d6				endm 
# End of macro FORTH_DSP_VALUEHL
35d6			 
35d6			;		push hl 
35d6			 
35d6					; destroy value TOS 
35d6			 
35d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35d6 cd d6 1e			call macro_forth_dsp_pop 
35d9				endm 
# End of macro FORTH_DSP_POP
35d9			 
35d9			;		pop hl 
35d9			 
35d9 3e 00				ld a,0 
35db			 
35db bd					cp l 
35dc 20 08				jr nz, .tz_notzero 
35de			 
35de bc					cp h 
35df			 
35df 20 05				jr nz, .tz_notzero 
35e1			 
35e1			 
35e1 21 01 00				ld hl, FORTH_TRUE 
35e4 18 03				jr .tz_done 
35e6			 
35e6 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
35e9			 
35e9					; push value back onto stack for another op etc 
35e9			 
35e9			.tz_done: 
35e9 cd 27 1c				call forth_push_numhl 
35ec			 
35ec					NEXTW 
35ec c3 90 1f			jp macro_next 
35ef				endm 
# End of macro NEXTW
35ef			.LESS: 
35ef				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
35ef 2f				db WORD_SYS_CORE+27             
35f0 58 36			dw .GT            
35f2 02				db 1 + 1 
35f3 .. 00			db "<",0              
35f5				endm 
# End of macro CWHEAD
35f5			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
35f5				; TODO add floating point number detection 
35f5					if DEBUG_FORTH_WORDS_KEY 
35f5						DMARK "LES" 
35f5 f5				push af  
35f6 3a 0a 36			ld a, (.dmark)  
35f9 32 77 fb			ld (debug_mark),a  
35fc 3a 0b 36			ld a, (.dmark+1)  
35ff 32 78 fb			ld (debug_mark+1),a  
3602 3a 0c 36			ld a, (.dmark+2)  
3605 32 79 fb			ld (debug_mark+2),a  
3608 18 03			jr .pastdmark  
360a ..			.dmark: db "LES"  
360d f1			.pastdmark: pop af  
360e			endm  
# End of macro DMARK
360e						CALLMONITOR 
360e cd 97 16			call break_point_state  
3611				endm  
# End of macro CALLMONITOR
3611					endif 
3611					FORTH_DSP 
3611 cd e4 1d			call macro_forth_dsp 
3614				endm 
# End of macro FORTH_DSP
3614					;v5 FORTH_DSP_VALUE 
3614 7e					ld a,(hl)	; get type of value on TOS 
3615 fe 02				cp DS_TYPE_INUM  
3617 28 00				jr z, .less_inum 
3619			 
3619				if FORTH_ENABLE_FLOATMATH 
3619					jr .less_done 
3619			 
3619				endif 
3619					 
3619			 
3619			.less_inum: 
3619					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3619 cd 1e 1e			call macro_dsp_valuehl 
361c				endm 
# End of macro FORTH_DSP_VALUEHL
361c			 
361c e5					push hl  ; u2 
361d			 
361d					; destroy value TOS 
361d			 
361d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
361d cd d6 1e			call macro_forth_dsp_pop 
3620				endm 
# End of macro FORTH_DSP_POP
3620			 
3620			 
3620					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3620 cd 1e 1e			call macro_dsp_valuehl 
3623				endm 
# End of macro FORTH_DSP_VALUEHL
3623			 
3623 e5					push hl    ; u1 
3624			 
3624					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3624 cd d6 1e			call macro_forth_dsp_pop 
3627				endm 
# End of macro FORTH_DSP_POP
3627			 
3627			 
3627 b7			 or a      ;clear carry flag 
3628 01 00 00		 ld bc, FORTH_FALSE 
362b e1			  pop hl    ; u1 
362c d1			  pop de    ; u2 
362d ed 52		  sbc hl,de 
362f 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3631			 
3631 01 01 00		 ld bc, FORTH_TRUE 
3634			.lscont:  
3634 c5					push bc 
3635 e1					pop hl 
3636			 
3636					if DEBUG_FORTH_WORDS 
3636						DMARK "LT1" 
3636 f5				push af  
3637 3a 4b 36			ld a, (.dmark)  
363a 32 77 fb			ld (debug_mark),a  
363d 3a 4c 36			ld a, (.dmark+1)  
3640 32 78 fb			ld (debug_mark+1),a  
3643 3a 4d 36			ld a, (.dmark+2)  
3646 32 79 fb			ld (debug_mark+2),a  
3649 18 03			jr .pastdmark  
364b ..			.dmark: db "LT1"  
364e f1			.pastdmark: pop af  
364f			endm  
# End of macro DMARK
364f						CALLMONITOR 
364f cd 97 16			call break_point_state  
3652				endm  
# End of macro CALLMONITOR
3652					endif 
3652 cd 27 1c				call forth_push_numhl 
3655			 
3655					NEXTW 
3655 c3 90 1f			jp macro_next 
3658				endm 
# End of macro NEXTW
3658			.GT: 
3658				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3658 30				db WORD_SYS_CORE+28             
3659 c1 36			dw .EQUAL            
365b 02				db 1 + 1 
365c .. 00			db ">",0              
365e				endm 
# End of macro CWHEAD
365e			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
365e				; TODO add floating point number detection 
365e					if DEBUG_FORTH_WORDS_KEY 
365e						DMARK "GRT" 
365e f5				push af  
365f 3a 73 36			ld a, (.dmark)  
3662 32 77 fb			ld (debug_mark),a  
3665 3a 74 36			ld a, (.dmark+1)  
3668 32 78 fb			ld (debug_mark+1),a  
366b 3a 75 36			ld a, (.dmark+2)  
366e 32 79 fb			ld (debug_mark+2),a  
3671 18 03			jr .pastdmark  
3673 ..			.dmark: db "GRT"  
3676 f1			.pastdmark: pop af  
3677			endm  
# End of macro DMARK
3677						CALLMONITOR 
3677 cd 97 16			call break_point_state  
367a				endm  
# End of macro CALLMONITOR
367a					endif 
367a					FORTH_DSP 
367a cd e4 1d			call macro_forth_dsp 
367d				endm 
# End of macro FORTH_DSP
367d					;FORTH_DSP_VALUE 
367d 7e					ld a,(hl)	; get type of value on TOS 
367e fe 02				cp DS_TYPE_INUM  
3680 28 00				jr z, .gt_inum 
3682			 
3682				if FORTH_ENABLE_FLOATMATH 
3682					jr .gt_done 
3682			 
3682				endif 
3682					 
3682			 
3682			.gt_inum: 
3682					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3682 cd 1e 1e			call macro_dsp_valuehl 
3685				endm 
# End of macro FORTH_DSP_VALUEHL
3685			 
3685 e5					push hl  ; u2 
3686			 
3686					; destroy value TOS 
3686			 
3686					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3686 cd d6 1e			call macro_forth_dsp_pop 
3689				endm 
# End of macro FORTH_DSP_POP
3689			 
3689			 
3689					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3689 cd 1e 1e			call macro_dsp_valuehl 
368c				endm 
# End of macro FORTH_DSP_VALUEHL
368c			 
368c e5					push hl    ; u1 
368d			 
368d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
368d cd d6 1e			call macro_forth_dsp_pop 
3690				endm 
# End of macro FORTH_DSP_POP
3690			 
3690			 
3690 b7			 or a      ;clear carry flag 
3691 01 00 00		 ld bc, FORTH_FALSE 
3694 e1			  pop hl    ; u1 
3695 d1			  pop de    ; u2 
3696 ed 52		  sbc hl,de 
3698 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
369a			 
369a 01 01 00		 ld bc, FORTH_TRUE 
369d			.gtcont:  
369d c5					push bc 
369e e1					pop hl 
369f			 
369f					if DEBUG_FORTH_WORDS 
369f						DMARK "GT1" 
369f f5				push af  
36a0 3a b4 36			ld a, (.dmark)  
36a3 32 77 fb			ld (debug_mark),a  
36a6 3a b5 36			ld a, (.dmark+1)  
36a9 32 78 fb			ld (debug_mark+1),a  
36ac 3a b6 36			ld a, (.dmark+2)  
36af 32 79 fb			ld (debug_mark+2),a  
36b2 18 03			jr .pastdmark  
36b4 ..			.dmark: db "GT1"  
36b7 f1			.pastdmark: pop af  
36b8			endm  
# End of macro DMARK
36b8						CALLMONITOR 
36b8 cd 97 16			call break_point_state  
36bb				endm  
# End of macro CALLMONITOR
36bb					endif 
36bb cd 27 1c				call forth_push_numhl 
36be			 
36be					NEXTW 
36be c3 90 1f			jp macro_next 
36c1				endm 
# End of macro NEXTW
36c1			.EQUAL: 
36c1				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
36c1 31				db WORD_SYS_CORE+29             
36c2 2c 37			dw .ENDLOGIC            
36c4 02				db 1 + 1 
36c5 .. 00			db "=",0              
36c7				endm 
# End of macro CWHEAD
36c7			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
36c7				; TODO add floating point number detection 
36c7					if DEBUG_FORTH_WORDS_KEY 
36c7						DMARK "EQ." 
36c7 f5				push af  
36c8 3a dc 36			ld a, (.dmark)  
36cb 32 77 fb			ld (debug_mark),a  
36ce 3a dd 36			ld a, (.dmark+1)  
36d1 32 78 fb			ld (debug_mark+1),a  
36d4 3a de 36			ld a, (.dmark+2)  
36d7 32 79 fb			ld (debug_mark+2),a  
36da 18 03			jr .pastdmark  
36dc ..			.dmark: db "EQ."  
36df f1			.pastdmark: pop af  
36e0			endm  
# End of macro DMARK
36e0						CALLMONITOR 
36e0 cd 97 16			call break_point_state  
36e3				endm  
# End of macro CALLMONITOR
36e3					endif 
36e3					FORTH_DSP 
36e3 cd e4 1d			call macro_forth_dsp 
36e6				endm 
# End of macro FORTH_DSP
36e6					;v5 FORTH_DSP_VALUE 
36e6 7e					ld a,(hl)	; get type of value on TOS 
36e7 fe 02				cp DS_TYPE_INUM  
36e9 28 00				jr z, .eq_inum 
36eb			 
36eb				if FORTH_ENABLE_FLOATMATH 
36eb					jr .eq_done 
36eb			 
36eb				endif 
36eb					 
36eb			 
36eb			.eq_inum: 
36eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36eb cd 1e 1e			call macro_dsp_valuehl 
36ee				endm 
# End of macro FORTH_DSP_VALUEHL
36ee			 
36ee e5					push hl 
36ef			 
36ef					; destroy value TOS 
36ef			 
36ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ef cd d6 1e			call macro_forth_dsp_pop 
36f2				endm 
# End of macro FORTH_DSP_POP
36f2			 
36f2			 
36f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f2 cd 1e 1e			call macro_dsp_valuehl 
36f5				endm 
# End of macro FORTH_DSP_VALUEHL
36f5			 
36f5					; one value on hl get other one back 
36f5			 
36f5 e5					push hl 
36f6			 
36f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f6 cd d6 1e			call macro_forth_dsp_pop 
36f9				endm 
# End of macro FORTH_DSP_POP
36f9			 
36f9 0e 00				ld c, FORTH_FALSE 
36fb			 
36fb e1					pop hl 
36fc d1					pop de 
36fd			 
36fd 7b					ld a, e 
36fe bd					cp l 
36ff			 
36ff 20 06				jr nz, .eq_done 
3701			 
3701 7a					ld a, d 
3702 bc					cp h 
3703			 
3703 20 02				jr nz, .eq_done 
3705			 
3705 0e 01				ld c, FORTH_TRUE 
3707					 
3707			 
3707			 
3707			.eq_done: 
3707			 
3707					; TODO push value back onto stack for another op etc 
3707			 
3707 26 00				ld h, 0 
3709 69					ld l, c 
370a					if DEBUG_FORTH_WORDS 
370a						DMARK "EQ1" 
370a f5				push af  
370b 3a 1f 37			ld a, (.dmark)  
370e 32 77 fb			ld (debug_mark),a  
3711 3a 20 37			ld a, (.dmark+1)  
3714 32 78 fb			ld (debug_mark+1),a  
3717 3a 21 37			ld a, (.dmark+2)  
371a 32 79 fb			ld (debug_mark+2),a  
371d 18 03			jr .pastdmark  
371f ..			.dmark: db "EQ1"  
3722 f1			.pastdmark: pop af  
3723			endm  
# End of macro DMARK
3723						CALLMONITOR 
3723 cd 97 16			call break_point_state  
3726				endm  
# End of macro CALLMONITOR
3726					endif 
3726 cd 27 1c				call forth_push_numhl 
3729			 
3729					NEXTW 
3729 c3 90 1f			jp macro_next 
372c				endm 
# End of macro NEXTW
372c			 
372c			 
372c			.ENDLOGIC: 
372c			; eof 
372c			 
372c			 
# End of file forth_words_logic.asm
372c			include "forth_words_maths.asm" 
372c			 
372c			; | ## Maths Words 
372c			 
372c			.PLUS:	 
372c				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
372c 15				db WORD_SYS_CORE+1             
372d 6e 37			dw .NEG            
372f 02				db 1 + 1 
3730 .. 00			db "+",0              
3732				endm 
# End of macro CWHEAD
3732			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3732					if DEBUG_FORTH_WORDS_KEY 
3732						DMARK "PLU" 
3732 f5				push af  
3733 3a 47 37			ld a, (.dmark)  
3736 32 77 fb			ld (debug_mark),a  
3739 3a 48 37			ld a, (.dmark+1)  
373c 32 78 fb			ld (debug_mark+1),a  
373f 3a 49 37			ld a, (.dmark+2)  
3742 32 79 fb			ld (debug_mark+2),a  
3745 18 03			jr .pastdmark  
3747 ..			.dmark: db "PLU"  
374a f1			.pastdmark: pop af  
374b			endm  
# End of macro DMARK
374b						CALLMONITOR 
374b cd 97 16			call break_point_state  
374e				endm  
# End of macro CALLMONITOR
374e					endif 
374e					; add top two values and push back result 
374e			 
374e					;for v5 FORTH_DSP_VALUE 
374e					FORTH_DSP 
374e cd e4 1d			call macro_forth_dsp 
3751				endm 
# End of macro FORTH_DSP
3751 7e					ld a,(hl)	; get type of value on TOS 
3752 fe 02				cp DS_TYPE_INUM  
3754 28 03				jr z, .dot_inum 
3756			 
3756					NEXTW 
3756 c3 90 1f			jp macro_next 
3759				endm 
# End of macro NEXTW
3759			 
3759			; float maths 
3759			 
3759				if FORTH_ENABLE_FLOATMATH 
3759						inc hl      ; now at start of numeric as string 
3759			 
3759					if DEBUG_FORTH_MATHS 
3759						DMARK "ADD" 
3759				CALLMONITOR 
3759					endif 
3759			 
3759					;ld ix, hl 
3759					call CON 
3759			 
3759			 
3759					push hl 
3759					 
3759					 
3759			 
3759						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3759			 
3759					; get next number 
3759			 
3759						FORTH_DSP_VALUE 
3759			 
3759						inc hl      ; now at start of numeric as string 
3759			 
3759					;ld ix, hl 
3759					call CON 
3759			 
3759					push hl 
3759			 
3759			 
3759						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3759			 
3759						; TODO do add 
3759			 
3759						call IADD 
3759			 
3759						; TODO get result back as ascii 
3759			 
3759						; TODO push result  
3759			 
3759			 
3759			 
3759						jr .dot_done 
3759				endif 
3759			 
3759			.dot_inum: 
3759			 
3759			 
3759					if DEBUG_FORTH_DOT 
3759						DMARK "+IT" 
3759				CALLMONITOR 
3759					endif 
3759			 
3759					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3759 cd 1e 1e			call macro_dsp_valuehl 
375c				endm 
# End of macro FORTH_DSP_VALUEHL
375c			 
375c				; TODO add floating point number detection 
375c			 
375c e5					push hl 
375d			 
375d					; destroy value TOS 
375d			 
375d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
375d cd d6 1e			call macro_forth_dsp_pop 
3760				endm 
# End of macro FORTH_DSP_POP
3760			 
3760			 
3760					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3760 cd 1e 1e			call macro_dsp_valuehl 
3763				endm 
# End of macro FORTH_DSP_VALUEHL
3763			 
3763					; one value on hl get other one back 
3763			 
3763 d1					pop de 
3764			 
3764					; do the add 
3764			 
3764 19					add hl,de 
3765			 
3765					; save it 
3765			 
3765			;		push hl	 
3765			 
3765					; 
3765			 
3765					; destroy value TOS 
3765			 
3765					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3765 cd d6 1e			call macro_forth_dsp_pop 
3768				endm 
# End of macro FORTH_DSP_POP
3768			 
3768					; TODO push value back onto stack for another op etc 
3768			 
3768			;		pop hl 
3768			 
3768			.dot_done: 
3768 cd 27 1c				call forth_push_numhl 
376b			 
376b					NEXTW 
376b c3 90 1f			jp macro_next 
376e				endm 
# End of macro NEXTW
376e			.NEG: 
376e			 
376e				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
376e 17				db WORD_SYS_CORE+3             
376f b1 37			dw .DIV            
3771 02				db 1 + 1 
3772 .. 00			db "-",0              
3774				endm 
# End of macro CWHEAD
3774			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3774					if DEBUG_FORTH_WORDS_KEY 
3774						DMARK "SUB" 
3774 f5				push af  
3775 3a 89 37			ld a, (.dmark)  
3778 32 77 fb			ld (debug_mark),a  
377b 3a 8a 37			ld a, (.dmark+1)  
377e 32 78 fb			ld (debug_mark+1),a  
3781 3a 8b 37			ld a, (.dmark+2)  
3784 32 79 fb			ld (debug_mark+2),a  
3787 18 03			jr .pastdmark  
3789 ..			.dmark: db "SUB"  
378c f1			.pastdmark: pop af  
378d			endm  
# End of macro DMARK
378d						CALLMONITOR 
378d cd 97 16			call break_point_state  
3790				endm  
# End of macro CALLMONITOR
3790					endif 
3790			 
3790			 
3790				; TODO add floating point number detection 
3790					; v5 FORTH_DSP_VALUE 
3790					FORTH_DSP 
3790 cd e4 1d			call macro_forth_dsp 
3793				endm 
# End of macro FORTH_DSP
3793 7e					ld a,(hl)	; get type of value on TOS 
3794 fe 02				cp DS_TYPE_INUM  
3796 28 03				jr z, .neg_inum 
3798			 
3798					NEXTW 
3798 c3 90 1f			jp macro_next 
379b				endm 
# End of macro NEXTW
379b			 
379b			; float maths 
379b			 
379b				if FORTH_ENABLE_FLOATMATH 
379b					jr .neg_done 
379b			 
379b				endif 
379b					 
379b			 
379b			.neg_inum: 
379b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
379b cd 1e 1e			call macro_dsp_valuehl 
379e				endm 
# End of macro FORTH_DSP_VALUEHL
379e			 
379e e5					push hl 
379f			 
379f					; destroy value TOS 
379f			 
379f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
379f cd d6 1e			call macro_forth_dsp_pop 
37a2				endm 
# End of macro FORTH_DSP_POP
37a2			 
37a2			 
37a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a2 cd 1e 1e			call macro_dsp_valuehl 
37a5				endm 
# End of macro FORTH_DSP_VALUEHL
37a5			 
37a5					; one value on hl get other one back 
37a5			 
37a5 d1					pop de 
37a6			 
37a6					; do the sub 
37a6			;		ex de, hl 
37a6			 
37a6 ed 52				sbc hl,de 
37a8			 
37a8					; save it 
37a8			 
37a8			;		push hl	 
37a8			 
37a8					; 
37a8			 
37a8					; destroy value TOS 
37a8			 
37a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a8 cd d6 1e			call macro_forth_dsp_pop 
37ab				endm 
# End of macro FORTH_DSP_POP
37ab			 
37ab					; TODO push value back onto stack for another op etc 
37ab			 
37ab			;		pop hl 
37ab			 
37ab cd 27 1c				call forth_push_numhl 
37ae			.neg_done: 
37ae			 
37ae					NEXTW 
37ae c3 90 1f			jp macro_next 
37b1				endm 
# End of macro NEXTW
37b1			.DIV: 
37b1				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
37b1 18				db WORD_SYS_CORE+4             
37b2 fe 37			dw .MUL            
37b4 02				db 1 + 1 
37b5 .. 00			db "/",0              
37b7				endm 
# End of macro CWHEAD
37b7			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
37b7					if DEBUG_FORTH_WORDS_KEY 
37b7						DMARK "DIV" 
37b7 f5				push af  
37b8 3a cc 37			ld a, (.dmark)  
37bb 32 77 fb			ld (debug_mark),a  
37be 3a cd 37			ld a, (.dmark+1)  
37c1 32 78 fb			ld (debug_mark+1),a  
37c4 3a ce 37			ld a, (.dmark+2)  
37c7 32 79 fb			ld (debug_mark+2),a  
37ca 18 03			jr .pastdmark  
37cc ..			.dmark: db "DIV"  
37cf f1			.pastdmark: pop af  
37d0			endm  
# End of macro DMARK
37d0						CALLMONITOR 
37d0 cd 97 16			call break_point_state  
37d3				endm  
# End of macro CALLMONITOR
37d3					endif 
37d3				; TODO add floating point number detection 
37d3					; v5 FORTH_DSP_VALUE 
37d3					FORTH_DSP 
37d3 cd e4 1d			call macro_forth_dsp 
37d6				endm 
# End of macro FORTH_DSP
37d6 7e					ld a,(hl)	; get type of value on TOS 
37d7 fe 02				cp DS_TYPE_INUM  
37d9 28 03				jr z, .div_inum 
37db			 
37db				if FORTH_ENABLE_FLOATMATH 
37db					jr .div_done 
37db			 
37db				endif 
37db					NEXTW 
37db c3 90 1f			jp macro_next 
37de				endm 
# End of macro NEXTW
37de			.div_inum: 
37de			 
37de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37de cd 1e 1e			call macro_dsp_valuehl 
37e1				endm 
# End of macro FORTH_DSP_VALUEHL
37e1			 
37e1 e5					push hl    ; to go to bc 
37e2			 
37e2					; destroy value TOS 
37e2			 
37e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e2 cd d6 1e			call macro_forth_dsp_pop 
37e5				endm 
# End of macro FORTH_DSP_POP
37e5			 
37e5			 
37e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37e5 cd 1e 1e			call macro_dsp_valuehl 
37e8				endm 
# End of macro FORTH_DSP_VALUEHL
37e8			 
37e8					; hl to go to de 
37e8			 
37e8 e5					push hl 
37e9			 
37e9 c1					pop bc 
37ea d1					pop de		 
37eb			 
37eb			 
37eb					if DEBUG_FORTH_MATHS 
37eb						DMARK "DIV" 
37eb				CALLMONITOR 
37eb					endif 
37eb					; one value on hl but move to a get other one back 
37eb			 
37eb			        
37eb cd 66 0c			call Div16 
37ee			 
37ee			;	push af	 
37ee e5				push hl 
37ef c5				push bc 
37f0			 
37f0					if DEBUG_FORTH_MATHS 
37f0						DMARK "DI1" 
37f0				CALLMONITOR 
37f0					endif 
37f0			 
37f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37f0 cd d6 1e			call macro_forth_dsp_pop 
37f3				endm 
# End of macro FORTH_DSP_POP
37f3			 
37f3			 
37f3			 
37f3 e1					pop hl    ; result 
37f4			 
37f4 cd 27 1c				call forth_push_numhl 
37f7			 
37f7 e1					pop hl    ; reminder 
37f8			;		ld h,0 
37f8			;		ld l,d 
37f8			 
37f8 cd 27 1c				call forth_push_numhl 
37fb			.div_done: 
37fb					NEXTW 
37fb c3 90 1f			jp macro_next 
37fe				endm 
# End of macro NEXTW
37fe			.MUL: 
37fe				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
37fe 19				db WORD_SYS_CORE+5             
37ff 43 38			dw .MIN            
3801 02				db 1 + 1 
3802 .. 00			db "*",0              
3804				endm 
# End of macro CWHEAD
3804			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3804				; TODO add floating point number detection 
3804					if DEBUG_FORTH_WORDS_KEY 
3804						DMARK "MUL" 
3804 f5				push af  
3805 3a 19 38			ld a, (.dmark)  
3808 32 77 fb			ld (debug_mark),a  
380b 3a 1a 38			ld a, (.dmark+1)  
380e 32 78 fb			ld (debug_mark+1),a  
3811 3a 1b 38			ld a, (.dmark+2)  
3814 32 79 fb			ld (debug_mark+2),a  
3817 18 03			jr .pastdmark  
3819 ..			.dmark: db "MUL"  
381c f1			.pastdmark: pop af  
381d			endm  
# End of macro DMARK
381d						CALLMONITOR 
381d cd 97 16			call break_point_state  
3820				endm  
# End of macro CALLMONITOR
3820					endif 
3820					FORTH_DSP 
3820 cd e4 1d			call macro_forth_dsp 
3823				endm 
# End of macro FORTH_DSP
3823					; v5 FORTH_DSP_VALUE 
3823 7e					ld a,(hl)	; get type of value on TOS 
3824 fe 02				cp DS_TYPE_INUM  
3826 28 03				jr z, .mul_inum 
3828			 
3828				if FORTH_ENABLE_FLOATMATH 
3828					jr .mul_done 
3828			 
3828				endif 
3828			 
3828					NEXTW 
3828 c3 90 1f			jp macro_next 
382b				endm 
# End of macro NEXTW
382b			.mul_inum:	 
382b			 
382b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
382b cd 1e 1e			call macro_dsp_valuehl 
382e				endm 
# End of macro FORTH_DSP_VALUEHL
382e			 
382e e5					push hl 
382f			 
382f					; destroy value TOS 
382f			 
382f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
382f cd d6 1e			call macro_forth_dsp_pop 
3832				endm 
# End of macro FORTH_DSP_POP
3832			 
3832			 
3832					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3832 cd 1e 1e			call macro_dsp_valuehl 
3835				endm 
# End of macro FORTH_DSP_VALUEHL
3835			 
3835					; one value on hl but move to a get other one back 
3835			 
3835 7d					ld a, l 
3836			 
3836 d1					pop de 
3837			 
3837					; do the mull 
3837			;		ex de, hl 
3837			 
3837 cd 8c 0c				call Mult16 
383a					; save it 
383a			 
383a			;		push hl	 
383a			 
383a					; 
383a			 
383a					; destroy value TOS 
383a			 
383a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383a cd d6 1e			call macro_forth_dsp_pop 
383d				endm 
# End of macro FORTH_DSP_POP
383d			 
383d					; TODO push value back onto stack for another op etc 
383d			 
383d			;		pop hl 
383d			 
383d cd 27 1c				call forth_push_numhl 
3840			 
3840			.mul_done: 
3840					NEXTW 
3840 c3 90 1f			jp macro_next 
3843				endm 
# End of macro NEXTW
3843			 
3843			 
3843			 
3843			 
3843			.MIN: 
3843				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3843 49				db WORD_SYS_CORE+53             
3844 c4 38			dw .MAX            
3846 04				db 3 + 1 
3847 .. 00			db "MIN",0              
384b				endm 
# End of macro CWHEAD
384b			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
384b					if DEBUG_FORTH_WORDS_KEY 
384b						DMARK "MIN" 
384b f5				push af  
384c 3a 60 38			ld a, (.dmark)  
384f 32 77 fb			ld (debug_mark),a  
3852 3a 61 38			ld a, (.dmark+1)  
3855 32 78 fb			ld (debug_mark+1),a  
3858 3a 62 38			ld a, (.dmark+2)  
385b 32 79 fb			ld (debug_mark+2),a  
385e 18 03			jr .pastdmark  
3860 ..			.dmark: db "MIN"  
3863 f1			.pastdmark: pop af  
3864			endm  
# End of macro DMARK
3864						CALLMONITOR 
3864 cd 97 16			call break_point_state  
3867				endm  
# End of macro CALLMONITOR
3867					endif 
3867					; get u2 
3867			 
3867					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3867 cd 1e 1e			call macro_dsp_valuehl 
386a				endm 
# End of macro FORTH_DSP_VALUEHL
386a			 
386a e5					push hl   ; u2 
386b			 
386b					; destroy value TOS 
386b			 
386b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
386b cd d6 1e			call macro_forth_dsp_pop 
386e				endm 
# End of macro FORTH_DSP_POP
386e			 
386e					; get u1 
386e			 
386e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
386e cd 1e 1e			call macro_dsp_valuehl 
3871				endm 
# End of macro FORTH_DSP_VALUEHL
3871			 
3871 e5					push hl  ; u1 
3872			 
3872					; destroy value TOS 
3872			 
3872					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3872 cd d6 1e			call macro_forth_dsp_pop 
3875				endm 
# End of macro FORTH_DSP_POP
3875			 
3875 b7			 or a      ;clear carry flag 
3876 e1			  pop hl    ; u1 
3877 d1			  pop de    ; u2 
3878 e5				push hl   ; saved in case hl is lowest 
3879 ed 52		  sbc hl,de 
387b 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
387d			 
387d e1				pop hl 
387e					if DEBUG_FORTH_WORDS 
387e						DMARK "MIN" 
387e f5				push af  
387f 3a 93 38			ld a, (.dmark)  
3882 32 77 fb			ld (debug_mark),a  
3885 3a 94 38			ld a, (.dmark+1)  
3888 32 78 fb			ld (debug_mark+1),a  
388b 3a 95 38			ld a, (.dmark+2)  
388e 32 79 fb			ld (debug_mark+2),a  
3891 18 03			jr .pastdmark  
3893 ..			.dmark: db "MIN"  
3896 f1			.pastdmark: pop af  
3897			endm  
# End of macro DMARK
3897						CALLMONITOR 
3897 cd 97 16			call break_point_state  
389a				endm  
# End of macro CALLMONITOR
389a					endif 
389a cd 27 1c				call forth_push_numhl 
389d			 
389d				       NEXTW 
389d c3 90 1f			jp macro_next 
38a0				endm 
# End of macro NEXTW
38a0			 
38a0			.mincont:  
38a0 c1				pop bc   ; tidy up 
38a1 eb				ex de , hl  
38a2					if DEBUG_FORTH_WORDS 
38a2						DMARK "MI1" 
38a2 f5				push af  
38a3 3a b7 38			ld a, (.dmark)  
38a6 32 77 fb			ld (debug_mark),a  
38a9 3a b8 38			ld a, (.dmark+1)  
38ac 32 78 fb			ld (debug_mark+1),a  
38af 3a b9 38			ld a, (.dmark+2)  
38b2 32 79 fb			ld (debug_mark+2),a  
38b5 18 03			jr .pastdmark  
38b7 ..			.dmark: db "MI1"  
38ba f1			.pastdmark: pop af  
38bb			endm  
# End of macro DMARK
38bb						CALLMONITOR 
38bb cd 97 16			call break_point_state  
38be				endm  
# End of macro CALLMONITOR
38be					endif 
38be cd 27 1c				call forth_push_numhl 
38c1			 
38c1				       NEXTW 
38c1 c3 90 1f			jp macro_next 
38c4				endm 
# End of macro NEXTW
38c4			.MAX: 
38c4				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
38c4 4a				db WORD_SYS_CORE+54             
38c5 45 39			dw .RND16            
38c7 04				db 3 + 1 
38c8 .. 00			db "MAX",0              
38cc				endm 
# End of macro CWHEAD
38cc			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
38cc					if DEBUG_FORTH_WORDS_KEY 
38cc						DMARK "MAX" 
38cc f5				push af  
38cd 3a e1 38			ld a, (.dmark)  
38d0 32 77 fb			ld (debug_mark),a  
38d3 3a e2 38			ld a, (.dmark+1)  
38d6 32 78 fb			ld (debug_mark+1),a  
38d9 3a e3 38			ld a, (.dmark+2)  
38dc 32 79 fb			ld (debug_mark+2),a  
38df 18 03			jr .pastdmark  
38e1 ..			.dmark: db "MAX"  
38e4 f1			.pastdmark: pop af  
38e5			endm  
# End of macro DMARK
38e5						CALLMONITOR 
38e5 cd 97 16			call break_point_state  
38e8				endm  
# End of macro CALLMONITOR
38e8					endif 
38e8					; get u2 
38e8			 
38e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38e8 cd 1e 1e			call macro_dsp_valuehl 
38eb				endm 
# End of macro FORTH_DSP_VALUEHL
38eb			 
38eb e5					push hl   ; u2 
38ec			 
38ec					; destroy value TOS 
38ec			 
38ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ec cd d6 1e			call macro_forth_dsp_pop 
38ef				endm 
# End of macro FORTH_DSP_POP
38ef			 
38ef					; get u1 
38ef			 
38ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ef cd 1e 1e			call macro_dsp_valuehl 
38f2				endm 
# End of macro FORTH_DSP_VALUEHL
38f2			 
38f2 e5					push hl  ; u1 
38f3			 
38f3					; destroy value TOS 
38f3			 
38f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38f3 cd d6 1e			call macro_forth_dsp_pop 
38f6				endm 
# End of macro FORTH_DSP_POP
38f6			 
38f6 b7			 or a      ;clear carry flag 
38f7 e1			  pop hl    ; u1 
38f8 d1			  pop de    ; u2 
38f9 e5				push hl   ; saved in case hl is lowest 
38fa ed 52		  sbc hl,de 
38fc 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
38fe			 
38fe e1				pop hl 
38ff					if DEBUG_FORTH_WORDS 
38ff						DMARK "MAX" 
38ff f5				push af  
3900 3a 14 39			ld a, (.dmark)  
3903 32 77 fb			ld (debug_mark),a  
3906 3a 15 39			ld a, (.dmark+1)  
3909 32 78 fb			ld (debug_mark+1),a  
390c 3a 16 39			ld a, (.dmark+2)  
390f 32 79 fb			ld (debug_mark+2),a  
3912 18 03			jr .pastdmark  
3914 ..			.dmark: db "MAX"  
3917 f1			.pastdmark: pop af  
3918			endm  
# End of macro DMARK
3918						CALLMONITOR 
3918 cd 97 16			call break_point_state  
391b				endm  
# End of macro CALLMONITOR
391b					endif 
391b cd 27 1c				call forth_push_numhl 
391e			 
391e				       NEXTW 
391e c3 90 1f			jp macro_next 
3921				endm 
# End of macro NEXTW
3921			 
3921			.maxcont:  
3921 c1				pop bc   ; tidy up 
3922 eb				ex de , hl  
3923					if DEBUG_FORTH_WORDS 
3923						DMARK "MA1" 
3923 f5				push af  
3924 3a 38 39			ld a, (.dmark)  
3927 32 77 fb			ld (debug_mark),a  
392a 3a 39 39			ld a, (.dmark+1)  
392d 32 78 fb			ld (debug_mark+1),a  
3930 3a 3a 39			ld a, (.dmark+2)  
3933 32 79 fb			ld (debug_mark+2),a  
3936 18 03			jr .pastdmark  
3938 ..			.dmark: db "MA1"  
393b f1			.pastdmark: pop af  
393c			endm  
# End of macro DMARK
393c						CALLMONITOR 
393c cd 97 16			call break_point_state  
393f				endm  
# End of macro CALLMONITOR
393f					endif 
393f cd 27 1c				call forth_push_numhl 
3942				       NEXTW 
3942 c3 90 1f			jp macro_next 
3945				endm 
# End of macro NEXTW
3945			 
3945			.RND16: 
3945				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3945 4e				db WORD_SYS_CORE+58             
3946 74 39			dw .RND8            
3948 06				db 5 + 1 
3949 .. 00			db "RND16",0              
394f				endm 
# End of macro CWHEAD
394f			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
394f					if DEBUG_FORTH_WORDS_KEY 
394f						DMARK "R16" 
394f f5				push af  
3950 3a 64 39			ld a, (.dmark)  
3953 32 77 fb			ld (debug_mark),a  
3956 3a 65 39			ld a, (.dmark+1)  
3959 32 78 fb			ld (debug_mark+1),a  
395c 3a 66 39			ld a, (.dmark+2)  
395f 32 79 fb			ld (debug_mark+2),a  
3962 18 03			jr .pastdmark  
3964 ..			.dmark: db "R16"  
3967 f1			.pastdmark: pop af  
3968			endm  
# End of macro DMARK
3968						CALLMONITOR 
3968 cd 97 16			call break_point_state  
396b				endm  
# End of macro CALLMONITOR
396b					endif 
396b cd 30 0c				call prng16  
396e cd 27 1c				call forth_push_numhl 
3971				       NEXTW 
3971 c3 90 1f			jp macro_next 
3974				endm 
# End of macro NEXTW
3974			.RND8: 
3974				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3974 60				db WORD_SYS_CORE+76             
3975 a9 39			dw .RND            
3977 05				db 4 + 1 
3978 .. 00			db "RND8",0              
397d				endm 
# End of macro CWHEAD
397d			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
397d					if DEBUG_FORTH_WORDS_KEY 
397d						DMARK "RN8" 
397d f5				push af  
397e 3a 92 39			ld a, (.dmark)  
3981 32 77 fb			ld (debug_mark),a  
3984 3a 93 39			ld a, (.dmark+1)  
3987 32 78 fb			ld (debug_mark+1),a  
398a 3a 94 39			ld a, (.dmark+2)  
398d 32 79 fb			ld (debug_mark+2),a  
3990 18 03			jr .pastdmark  
3992 ..			.dmark: db "RN8"  
3995 f1			.pastdmark: pop af  
3996			endm  
# End of macro DMARK
3996						CALLMONITOR 
3996 cd 97 16			call break_point_state  
3999				endm  
# End of macro CALLMONITOR
3999					endif 
3999 2a b8 f8				ld hl,(xrandc) 
399c 23					inc hl 
399d cd 4a 0c				call xrnd 
39a0 6f					ld l,a	 
39a1 26 00				ld h,0 
39a3 cd 27 1c				call forth_push_numhl 
39a6				       NEXTW 
39a6 c3 90 1f			jp macro_next 
39a9				endm 
# End of macro NEXTW
39a9			.RND: 
39a9				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
39a9 60				db WORD_SYS_CORE+76             
39aa af 3a			dw .ENDMATHS            
39ac 04				db 3 + 1 
39ad .. 00			db "RND",0              
39b1				endm 
# End of macro CWHEAD
39b1			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
39b1			 
39b1					if DEBUG_FORTH_WORDS_KEY 
39b1						DMARK "RND" 
39b1 f5				push af  
39b2 3a c6 39			ld a, (.dmark)  
39b5 32 77 fb			ld (debug_mark),a  
39b8 3a c7 39			ld a, (.dmark+1)  
39bb 32 78 fb			ld (debug_mark+1),a  
39be 3a c8 39			ld a, (.dmark+2)  
39c1 32 79 fb			ld (debug_mark+2),a  
39c4 18 03			jr .pastdmark  
39c6 ..			.dmark: db "RND"  
39c9 f1			.pastdmark: pop af  
39ca			endm  
# End of macro DMARK
39ca						CALLMONITOR 
39ca cd 97 16			call break_point_state  
39cd				endm  
# End of macro CALLMONITOR
39cd					endif 
39cd					 
39cd					FORTH_DSP_VALUEHL    ; upper range 
39cd cd 1e 1e			call macro_dsp_valuehl 
39d0				endm 
# End of macro FORTH_DSP_VALUEHL
39d0			 
39d0 22 bc f8				ld (LFSRSeed), hl	 
39d3			 
39d3					if DEBUG_FORTH_WORDS 
39d3						DMARK "RN1" 
39d3 f5				push af  
39d4 3a e8 39			ld a, (.dmark)  
39d7 32 77 fb			ld (debug_mark),a  
39da 3a e9 39			ld a, (.dmark+1)  
39dd 32 78 fb			ld (debug_mark+1),a  
39e0 3a ea 39			ld a, (.dmark+2)  
39e3 32 79 fb			ld (debug_mark+2),a  
39e6 18 03			jr .pastdmark  
39e8 ..			.dmark: db "RN1"  
39eb f1			.pastdmark: pop af  
39ec			endm  
# End of macro DMARK
39ec						CALLMONITOR 
39ec cd 97 16			call break_point_state  
39ef				endm  
# End of macro CALLMONITOR
39ef					endif 
39ef					FORTH_DSP_POP 
39ef cd d6 1e			call macro_forth_dsp_pop 
39f2				endm 
# End of macro FORTH_DSP_POP
39f2			 
39f2					FORTH_DSP_VALUEHL    ; low range 
39f2 cd 1e 1e			call macro_dsp_valuehl 
39f5				endm 
# End of macro FORTH_DSP_VALUEHL
39f5			 
39f5					if DEBUG_FORTH_WORDS 
39f5						DMARK "RN2" 
39f5 f5				push af  
39f6 3a 0a 3a			ld a, (.dmark)  
39f9 32 77 fb			ld (debug_mark),a  
39fc 3a 0b 3a			ld a, (.dmark+1)  
39ff 32 78 fb			ld (debug_mark+1),a  
3a02 3a 0c 3a			ld a, (.dmark+2)  
3a05 32 79 fb			ld (debug_mark+2),a  
3a08 18 03			jr .pastdmark  
3a0a ..			.dmark: db "RN2"  
3a0d f1			.pastdmark: pop af  
3a0e			endm  
# End of macro DMARK
3a0e						CALLMONITOR 
3a0e cd 97 16			call break_point_state  
3a11				endm  
# End of macro CALLMONITOR
3a11					endif 
3a11 22 be f8				ld (LFSRSeed+2), hl 
3a14			 
3a14					FORTH_DSP_POP 
3a14 cd d6 1e			call macro_forth_dsp_pop 
3a17				endm 
# End of macro FORTH_DSP_POP
3a17			 
3a17 e5					push hl 
3a18			 
3a18 e1			.inrange:	pop hl 
3a19 cd 30 0c				call prng16  
3a1c					if DEBUG_FORTH_WORDS 
3a1c						DMARK "RN3" 
3a1c f5				push af  
3a1d 3a 31 3a			ld a, (.dmark)  
3a20 32 77 fb			ld (debug_mark),a  
3a23 3a 32 3a			ld a, (.dmark+1)  
3a26 32 78 fb			ld (debug_mark+1),a  
3a29 3a 33 3a			ld a, (.dmark+2)  
3a2c 32 79 fb			ld (debug_mark+2),a  
3a2f 18 03			jr .pastdmark  
3a31 ..			.dmark: db "RN3"  
3a34 f1			.pastdmark: pop af  
3a35			endm  
# End of macro DMARK
3a35						CALLMONITOR 
3a35 cd 97 16			call break_point_state  
3a38				endm  
# End of macro CALLMONITOR
3a38					endif 
3a38					 
3a38					; if the range is 8bit knock out the high byte 
3a38			 
3a38 ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
3a3c			 
3a3c 3e 00				ld a, 0 
3a3e ba					cp d  
3a3f 20 1e				jr nz, .hirange 
3a41 26 00				ld h, 0   ; knock it down to 8bit 
3a43			 
3a43					if DEBUG_FORTH_WORDS 
3a43						DMARK "RNk" 
3a43 f5				push af  
3a44 3a 58 3a			ld a, (.dmark)  
3a47 32 77 fb			ld (debug_mark),a  
3a4a 3a 59 3a			ld a, (.dmark+1)  
3a4d 32 78 fb			ld (debug_mark+1),a  
3a50 3a 5a 3a			ld a, (.dmark+2)  
3a53 32 79 fb			ld (debug_mark+2),a  
3a56 18 03			jr .pastdmark  
3a58 ..			.dmark: db "RNk"  
3a5b f1			.pastdmark: pop af  
3a5c			endm  
# End of macro DMARK
3a5c						CALLMONITOR 
3a5c cd 97 16			call break_point_state  
3a5f				endm  
# End of macro CALLMONITOR
3a5f					endif 
3a5f			.hirange:   
3a5f e5					push hl  
3a60 b7					or a  
3a61 ed 52		                sbc hl, de 
3a63			 
3a63					;call cmp16 
3a63			 
3a63 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a65 e1					pop hl 
3a66 e5					push hl 
3a67			 
3a67					if DEBUG_FORTH_WORDS 
3a67						DMARK "RN4" 
3a67 f5				push af  
3a68 3a 7c 3a			ld a, (.dmark)  
3a6b 32 77 fb			ld (debug_mark),a  
3a6e 3a 7d 3a			ld a, (.dmark+1)  
3a71 32 78 fb			ld (debug_mark+1),a  
3a74 3a 7e 3a			ld a, (.dmark+2)  
3a77 32 79 fb			ld (debug_mark+2),a  
3a7a 18 03			jr .pastdmark  
3a7c ..			.dmark: db "RN4"  
3a7f f1			.pastdmark: pop af  
3a80			endm  
# End of macro DMARK
3a80						CALLMONITOR 
3a80 cd 97 16			call break_point_state  
3a83				endm  
# End of macro CALLMONITOR
3a83					endif 
3a83 ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
3a87					;call cmp16 
3a87				 
3a87 b7					or a  
3a88 ed 52		                sbc hl, de 
3a8a 38 8c				jr c, .inrange 
3a8c			 
3a8c e1					pop hl 
3a8d					 
3a8d					if DEBUG_FORTH_WORDS 
3a8d						DMARK "RNd" 
3a8d f5				push af  
3a8e 3a a2 3a			ld a, (.dmark)  
3a91 32 77 fb			ld (debug_mark),a  
3a94 3a a3 3a			ld a, (.dmark+1)  
3a97 32 78 fb			ld (debug_mark+1),a  
3a9a 3a a4 3a			ld a, (.dmark+2)  
3a9d 32 79 fb			ld (debug_mark+2),a  
3aa0 18 03			jr .pastdmark  
3aa2 ..			.dmark: db "RNd"  
3aa5 f1			.pastdmark: pop af  
3aa6			endm  
# End of macro DMARK
3aa6						CALLMONITOR 
3aa6 cd 97 16			call break_point_state  
3aa9				endm  
# End of macro CALLMONITOR
3aa9					endif 
3aa9			 
3aa9			 
3aa9 cd 27 1c				call forth_push_numhl 
3aac				       NEXTW 
3aac c3 90 1f			jp macro_next 
3aaf				endm 
# End of macro NEXTW
3aaf			 
3aaf			.ENDMATHS: 
3aaf			 
3aaf			; eof 
3aaf			 
# End of file forth_words_maths.asm
3aaf			include "forth_words_display.asm" 
3aaf			 
3aaf			; | ## Display Words 
3aaf			 
3aaf			.ATP: 
3aaf				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3aaf 62				db WORD_SYS_CORE+78             
3ab0 26 3b			dw .FB            
3ab2 04				db 3 + 1 
3ab3 .. 00			db "AT?",0              
3ab7				endm 
# End of macro CWHEAD
3ab7			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3ab7					if DEBUG_FORTH_WORDS_KEY 
3ab7						DMARK "AT?" 
3ab7 f5				push af  
3ab8 3a cc 3a			ld a, (.dmark)  
3abb 32 77 fb			ld (debug_mark),a  
3abe 3a cd 3a			ld a, (.dmark+1)  
3ac1 32 78 fb			ld (debug_mark+1),a  
3ac4 3a ce 3a			ld a, (.dmark+2)  
3ac7 32 79 fb			ld (debug_mark+2),a  
3aca 18 03			jr .pastdmark  
3acc ..			.dmark: db "AT?"  
3acf f1			.pastdmark: pop af  
3ad0			endm  
# End of macro DMARK
3ad0						CALLMONITOR 
3ad0 cd 97 16			call break_point_state  
3ad3				endm  
# End of macro CALLMONITOR
3ad3					endif 
3ad3 3a 46 f8				ld a, (f_cursor_ptr) 
3ad6			 
3ad6			if DEBUG_FORTH_WORDS 
3ad6				DMARK "AT?" 
3ad6 f5				push af  
3ad7 3a eb 3a			ld a, (.dmark)  
3ada 32 77 fb			ld (debug_mark),a  
3add 3a ec 3a			ld a, (.dmark+1)  
3ae0 32 78 fb			ld (debug_mark+1),a  
3ae3 3a ed 3a			ld a, (.dmark+2)  
3ae6 32 79 fb			ld (debug_mark+2),a  
3ae9 18 03			jr .pastdmark  
3aeb ..			.dmark: db "AT?"  
3aee f1			.pastdmark: pop af  
3aef			endm  
# End of macro DMARK
3aef				CALLMONITOR 
3aef cd 97 16			call break_point_state  
3af2				endm  
# End of macro CALLMONITOR
3af2			endif	 
3af2					; count the number of rows 
3af2			 
3af2 06 00				ld b, 0 
3af4 4f			.atpr:		ld c, a    ; save in case we go below zero 
3af5 d6 28				sub display_cols 
3af7 f2 fd 3a				jp p, .atprunder 
3afa 04					inc b 
3afb 18 f7				jr .atpr 
3afd			.atprunder:	 
3afd			if DEBUG_FORTH_WORDS 
3afd				DMARK "A?2" 
3afd f5				push af  
3afe 3a 12 3b			ld a, (.dmark)  
3b01 32 77 fb			ld (debug_mark),a  
3b04 3a 13 3b			ld a, (.dmark+1)  
3b07 32 78 fb			ld (debug_mark+1),a  
3b0a 3a 14 3b			ld a, (.dmark+2)  
3b0d 32 79 fb			ld (debug_mark+2),a  
3b10 18 03			jr .pastdmark  
3b12 ..			.dmark: db "A?2"  
3b15 f1			.pastdmark: pop af  
3b16			endm  
# End of macro DMARK
3b16				CALLMONITOR 
3b16 cd 97 16			call break_point_state  
3b19				endm  
# End of macro CALLMONITOR
3b19			endif	 
3b19 26 00				ld h, 0 
3b1b 69					ld l, c 
3b1c cd 27 1c				call forth_push_numhl 
3b1f 68					ld l, b  
3b20 cd 27 1c				call forth_push_numhl 
3b23			 
3b23			 
3b23				NEXTW 
3b23 c3 90 1f			jp macro_next 
3b26				endm 
# End of macro NEXTW
3b26			 
3b26			.FB: 
3b26				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b26 1b				db WORD_SYS_CORE+7             
3b27 74 3b			dw .EMIT            
3b29 03				db 2 + 1 
3b2a .. 00			db "FB",0              
3b2d				endm 
# End of macro CWHEAD
3b2d			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b2d			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b2d			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b2d			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b2d					if DEBUG_FORTH_WORDS_KEY 
3b2d						DMARK "FB." 
3b2d f5				push af  
3b2e 3a 42 3b			ld a, (.dmark)  
3b31 32 77 fb			ld (debug_mark),a  
3b34 3a 43 3b			ld a, (.dmark+1)  
3b37 32 78 fb			ld (debug_mark+1),a  
3b3a 3a 44 3b			ld a, (.dmark+2)  
3b3d 32 79 fb			ld (debug_mark+2),a  
3b40 18 03			jr .pastdmark  
3b42 ..			.dmark: db "FB."  
3b45 f1			.pastdmark: pop af  
3b46			endm  
# End of macro DMARK
3b46						CALLMONITOR 
3b46 cd 97 16			call break_point_state  
3b49				endm  
# End of macro CALLMONITOR
3b49					endif 
3b49			 
3b49					FORTH_DSP_VALUEHL 
3b49 cd 1e 1e			call macro_dsp_valuehl 
3b4c				endm 
# End of macro FORTH_DSP_VALUEHL
3b4c			 
3b4c 7d					ld a, l 
3b4d fe 01				cp 1 
3b4f 20 05				jr nz, .fbn1 
3b51 21 1c fa				ld hl, display_fb1 
3b54 18 15				jr .fbset 
3b56 fe 02		.fbn1:		cp 2 
3b58 20 05				jr nz, .fbn2 
3b5a 21 da f8				ld hl, display_fb2 
3b5d 18 0c				jr .fbset 
3b5f fe 03		.fbn2:		cp 3 
3b61 20 05				jr nz, .fbn3 
3b63 21 7b f9				ld hl, display_fb3 
3b66 18 03				jr .fbset 
3b68			.fbn3:		 ; if invalid number select first 
3b68 21 1c fa				ld hl, display_fb1 
3b6b 22 d8 f8		.fbset:		ld (display_fb_active), hl 
3b6e			 
3b6e					FORTH_DSP_POP 
3b6e cd d6 1e			call macro_forth_dsp_pop 
3b71				endm 
# End of macro FORTH_DSP_POP
3b71			 
3b71					NEXTW 
3b71 c3 90 1f			jp macro_next 
3b74				endm 
# End of macro NEXTW
3b74			 
3b74			 
3b74			.EMIT: 
3b74				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b74 1b				db WORD_SYS_CORE+7             
3b75 c5 3b			dw .DOTH            
3b77 05				db 4 + 1 
3b78 .. 00			db "EMIT",0              
3b7d				endm 
# End of macro CWHEAD
3b7d			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b7d					; get value off TOS and display it 
3b7d			 
3b7d					if DEBUG_FORTH_WORDS_KEY 
3b7d						DMARK "EMT" 
3b7d f5				push af  
3b7e 3a 92 3b			ld a, (.dmark)  
3b81 32 77 fb			ld (debug_mark),a  
3b84 3a 93 3b			ld a, (.dmark+1)  
3b87 32 78 fb			ld (debug_mark+1),a  
3b8a 3a 94 3b			ld a, (.dmark+2)  
3b8d 32 79 fb			ld (debug_mark+2),a  
3b90 18 03			jr .pastdmark  
3b92 ..			.dmark: db "EMT"  
3b95 f1			.pastdmark: pop af  
3b96			endm  
# End of macro DMARK
3b96						CALLMONITOR 
3b96 cd 97 16			call break_point_state  
3b99				endm  
# End of macro CALLMONITOR
3b99					endif 
3b99			 
3b99					FORTH_DSP_VALUEHL 
3b99 cd 1e 1e			call macro_dsp_valuehl 
3b9c				endm 
# End of macro FORTH_DSP_VALUEHL
3b9c			 
3b9c 7d					ld a,l 
3b9d			 
3b9d					; TODO write to display 
3b9d			 
3b9d 32 1b f0				ld (os_input), a 
3ba0 3e 00				ld a, 0 
3ba2 32 1c f0				ld (os_input+1), a 
3ba5					 
3ba5 3a 46 f8				ld a, (f_cursor_ptr) 
3ba8 11 1b f0				ld de, os_input 
3bab cd e8 0a				call str_at_display 
3bae			 
3bae			 
3bae 3a 24 f8				ld a,(cli_autodisplay) 
3bb1 fe 00				cp 0 
3bb3 28 03				jr z, .enoupdate 
3bb5 cd f8 0a						call update_display 
3bb8					.enoupdate: 
3bb8			 
3bb8 3a 46 f8				ld a, (f_cursor_ptr) 
3bbb 3c					inc a 
3bbc 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3bbf			 
3bbf			 
3bbf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bbf cd d6 1e			call macro_forth_dsp_pop 
3bc2				endm 
# End of macro FORTH_DSP_POP
3bc2			  
3bc2			 
3bc2					NEXTW 
3bc2 c3 90 1f			jp macro_next 
3bc5				endm 
# End of macro NEXTW
3bc5			.DOTH: 
3bc5				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3bc5 1c				db WORD_SYS_CORE+8             
3bc6 f5 3b			dw .DOTF            
3bc8 03				db 2 + 1 
3bc9 .. 00			db ".-",0              
3bcc				endm 
# End of macro CWHEAD
3bcc			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3bcc					; get value off TOS and display it 
3bcc					if DEBUG_FORTH_WORDS_KEY 
3bcc						DMARK "DTD" 
3bcc f5				push af  
3bcd 3a e1 3b			ld a, (.dmark)  
3bd0 32 77 fb			ld (debug_mark),a  
3bd3 3a e2 3b			ld a, (.dmark+1)  
3bd6 32 78 fb			ld (debug_mark+1),a  
3bd9 3a e3 3b			ld a, (.dmark+2)  
3bdc 32 79 fb			ld (debug_mark+2),a  
3bdf 18 03			jr .pastdmark  
3be1 ..			.dmark: db "DTD"  
3be4 f1			.pastdmark: pop af  
3be5			endm  
# End of macro DMARK
3be5						CALLMONITOR 
3be5 cd 97 16			call break_point_state  
3be8				endm  
# End of macro CALLMONITOR
3be8					endif 
3be8 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3bea 3e 00			ld a, 0 
3bec 32 25 f8			ld (cli_mvdot), a 
3bef c3 4c 3c			jp .dotgo 
3bf2				NEXTW 
3bf2 c3 90 1f			jp macro_next 
3bf5				endm 
# End of macro NEXTW
3bf5			.DOTF: 
3bf5				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bf5 1c				db WORD_SYS_CORE+8             
3bf6 23 3c			dw .DOT            
3bf8 03				db 2 + 1 
3bf9 .. 00			db ".>",0              
3bfc				endm 
# End of macro CWHEAD
3bfc			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3bfc					; get value off TOS and display it 
3bfc			        ; TODO BUG adds extra spaces 
3bfc			        ; TODO BUG handle numerics? 
3bfc					if DEBUG_FORTH_WORDS_KEY 
3bfc						DMARK "DTC" 
3bfc f5				push af  
3bfd 3a 11 3c			ld a, (.dmark)  
3c00 32 77 fb			ld (debug_mark),a  
3c03 3a 12 3c			ld a, (.dmark+1)  
3c06 32 78 fb			ld (debug_mark+1),a  
3c09 3a 13 3c			ld a, (.dmark+2)  
3c0c 32 79 fb			ld (debug_mark+2),a  
3c0f 18 03			jr .pastdmark  
3c11 ..			.dmark: db "DTC"  
3c14 f1			.pastdmark: pop af  
3c15			endm  
# End of macro DMARK
3c15						CALLMONITOR 
3c15 cd 97 16			call break_point_state  
3c18				endm  
# End of macro CALLMONITOR
3c18					endif 
3c18 3e 01			ld a, 1 
3c1a 32 25 f8			ld (cli_mvdot), a 
3c1d c3 4c 3c			jp .dotgo 
3c20				NEXTW 
3c20 c3 90 1f			jp macro_next 
3c23				endm 
# End of macro NEXTW
3c23			 
3c23			.DOT: 
3c23				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c23 1c				db WORD_SYS_CORE+8             
3c24 af 3c			dw .CLS            
3c26 02				db 1 + 1 
3c27 .. 00			db ".",0              
3c29				endm 
# End of macro CWHEAD
3c29			        ; | . ( u -- ) Display TOS | DONE 
3c29					; get value off TOS and display it 
3c29			 
3c29					if DEBUG_FORTH_WORDS_KEY 
3c29						DMARK "DOT" 
3c29 f5				push af  
3c2a 3a 3e 3c			ld a, (.dmark)  
3c2d 32 77 fb			ld (debug_mark),a  
3c30 3a 3f 3c			ld a, (.dmark+1)  
3c33 32 78 fb			ld (debug_mark+1),a  
3c36 3a 40 3c			ld a, (.dmark+2)  
3c39 32 79 fb			ld (debug_mark+2),a  
3c3c 18 03			jr .pastdmark  
3c3e ..			.dmark: db "DOT"  
3c41 f1			.pastdmark: pop af  
3c42			endm  
# End of macro DMARK
3c42						CALLMONITOR 
3c42 cd 97 16			call break_point_state  
3c45				endm  
# End of macro CALLMONITOR
3c45					endif 
3c45 3e 00			ld a, 0 
3c47 32 25 f8			ld (cli_mvdot), a 
3c4a 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c4c				 
3c4c			 
3c4c			.dotgo: 
3c4c			 
3c4c			; move up type to on stack for parserv5 
3c4c					FORTH_DSP 
3c4c cd e4 1d			call macro_forth_dsp 
3c4f				endm 
# End of macro FORTH_DSP
3c4f				;FORTH_DSP_VALUE  
3c4f			 
3c4f			if DEBUG_FORTH_DOT 
3c4f				DMARK "DOT" 
3c4f				CALLMONITOR 
3c4f			endif	 
3c4f			;		.print: 
3c4f			 
3c4f 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c50 23				inc hl   ; position to the actual value 
3c51 fe 01			cp DS_TYPE_STR 
3c53 20 06			jr nz, .dotnum1  
3c55			 
3c55			; display string 
3c55				FORTH_DSP_VALUE  
3c55 cd 07 1e			call macro_forth_dsp_value 
3c58				endm 
# End of macro FORTH_DSP_VALUE
3c58 eb				ex de,hl 
3c59 18 11			jr .dotwrite 
3c5b			 
3c5b			.dotnum1: 
3c5b fe 02			cp DS_TYPE_INUM 
3c5d 20 0c			jr nz, .dotflot 
3c5f			 
3c5f			 
3c5f			; display number 
3c5f			 
3c5f			;	push hl 
3c5f			;	call clear_display 
3c5f			;	pop hl 
3c5f			 
3c5f 5e				ld e, (hl) 
3c60 23				inc hl 
3c61 56				ld d, (hl) 
3c62 21 1d ee			ld hl, scratch 
3c65			if DEBUG_FORTH_DOT 
3c65				DMARK "DT1" 
3c65				CALLMONITOR 
3c65			endif	 
3c65			 
3c65 cd 16 11			call uitoa_16 
3c68 eb				ex de,hl 
3c69			 
3c69			if DEBUG_FORTH_DOT 
3c69				DMARK "DT2" 
3c69				CALLMONITOR 
3c69			endif	 
3c69			 
3c69			;	ld de, os_word_scratch 
3c69 18 01			jr .dotwrite 
3c6b			 
3c6b 00			.dotflot:   nop 
3c6c			; TODO print floating point number 
3c6c			 
3c6c			.dotwrite:		 
3c6c			 
3c6c					; if c is set then set all '-' to spaces 
3c6c					; need to also take into account .>  
3c6c			 
3c6c 3e 01				ld a, 1 
3c6e b9					cp c 
3c6f 20 13				jr nz, .nodashswap 
3c71			 
3c71					; DE has the string to write, working with HL 
3c71			 
3c71 06 ff				ld b, 255 
3c73 d5					push de 
3c74 e1					pop hl 
3c75			 
3c75			if DEBUG_FORTH_DOT 
3c75				DMARK "DT-" 
3c75				CALLMONITOR 
3c75			endif	 
3c75 7e			.dashscan:	ld a, (hl) 
3c76 fe 00				cp 0 
3c78 28 0a				jr z, .nodashswap 
3c7a fe 2d				cp '-' 
3c7c 20 03				jr nz, .dashskip 
3c7e 3e 20				ld a, ' ' 
3c80 77					ld (hl), a 
3c81 23			.dashskip:	inc hl 
3c82			if DEBUG_FORTH_DOT 
3c82				DMARK "D-2" 
3c82				CALLMONITOR 
3c82			endif	 
3c82 10 f1				djnz .dashscan 
3c84			 
3c84			if DEBUG_FORTH_DOT 
3c84				DMARK "D-1" 
3c84				CALLMONITOR 
3c84			endif	 
3c84			 
3c84			.nodashswap: 
3c84			 
3c84 e5					push hl   ; save string start in case we need to advance print 
3c85			 
3c85 3a 46 f8				ld a, (f_cursor_ptr) 
3c88 cd e8 0a				call str_at_display 
3c8b 3a 24 f8				ld a,(cli_autodisplay) 
3c8e fe 00				cp 0 
3c90 28 03				jr z, .noupdate 
3c92 cd f8 0a						call update_display 
3c95					.noupdate: 
3c95			 
3c95			 
3c95					; see if we need to advance the print position 
3c95			 
3c95 e1					pop hl   ; get back string 
3c96			 
3c96 3a 25 f8				ld a, (cli_mvdot) 
3c99			if DEBUG_FORTH_DOT 
3c99					ld e,a 
3c99				DMARK "D>1" 
3c99				CALLMONITOR 
3c99			endif	 
3c99 fe 00				cp 0 
3c9b 28 0c				jr z, .noadv 
3c9d					; yes, lets advance the print position 
3c9d 3e 00				ld a, 0 
3c9f cd 72 11				call strlent 
3ca2 3a 46 f8				ld a, (f_cursor_ptr) 
3ca5 85					add a,l 
3ca6					;call addatohl 
3ca6					;ld a, l 
3ca6 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3ca9			 
3ca9			if DEBUG_FORTH_DOT 
3ca9				DMARK "D->" 
3ca9				CALLMONITOR 
3ca9			endif	 
3ca9			 
3ca9			.noadv:	 
3ca9			 
3ca9					if DEBUG_FORTH_DOT_WAIT 
3ca9							call next_page_prompt 
3ca9					endif	 
3ca9			; TODO this pop off the stack causes a crash. i dont know why 
3ca9			 
3ca9			 
3ca9			if DEBUG_FORTH_DOT 
3ca9				DMARK "DTh" 
3ca9				CALLMONITOR 
3ca9			endif	 
3ca9			 
3ca9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ca9 cd d6 1e			call macro_forth_dsp_pop 
3cac				endm 
# End of macro FORTH_DSP_POP
3cac			 
3cac			if DEBUG_FORTH_DOT 
3cac				DMARK "DTi" 
3cac				CALLMONITOR 
3cac			endif	 
3cac			 
3cac			 
3cac					NEXTW 
3cac c3 90 1f			jp macro_next 
3caf				endm 
# End of macro NEXTW
3caf			 
3caf			.CLS: 
3caf				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3caf 35				db WORD_SYS_CORE+33             
3cb0 dc 3c			dw .DRAW            
3cb2 04				db 3 + 1 
3cb3 .. 00			db "CLS",0              
3cb7				endm 
# End of macro CWHEAD
3cb7			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3cb7					if DEBUG_FORTH_WORDS_KEY 
3cb7						DMARK "CLS" 
3cb7 f5				push af  
3cb8 3a cc 3c			ld a, (.dmark)  
3cbb 32 77 fb			ld (debug_mark),a  
3cbe 3a cd 3c			ld a, (.dmark+1)  
3cc1 32 78 fb			ld (debug_mark+1),a  
3cc4 3a ce 3c			ld a, (.dmark+2)  
3cc7 32 79 fb			ld (debug_mark+2),a  
3cca 18 03			jr .pastdmark  
3ccc ..			.dmark: db "CLS"  
3ccf f1			.pastdmark: pop af  
3cd0			endm  
# End of macro DMARK
3cd0						CALLMONITOR 
3cd0 cd 97 16			call break_point_state  
3cd3				endm  
# End of macro CALLMONITOR
3cd3					endif 
3cd3 cd d5 0a				call clear_display 
3cd6 c3 ea 3d				jp .home		; and home cursor 
3cd9					NEXTW 
3cd9 c3 90 1f			jp macro_next 
3cdc				endm 
# End of macro NEXTW
3cdc			 
3cdc			.DRAW: 
3cdc				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3cdc 36				db WORD_SYS_CORE+34             
3cdd 07 3d			dw .DUMP            
3cdf 05				db 4 + 1 
3ce0 .. 00			db "DRAW",0              
3ce5				endm 
# End of macro CWHEAD
3ce5			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3ce5					if DEBUG_FORTH_WORDS_KEY 
3ce5						DMARK "DRW" 
3ce5 f5				push af  
3ce6 3a fa 3c			ld a, (.dmark)  
3ce9 32 77 fb			ld (debug_mark),a  
3cec 3a fb 3c			ld a, (.dmark+1)  
3cef 32 78 fb			ld (debug_mark+1),a  
3cf2 3a fc 3c			ld a, (.dmark+2)  
3cf5 32 79 fb			ld (debug_mark+2),a  
3cf8 18 03			jr .pastdmark  
3cfa ..			.dmark: db "DRW"  
3cfd f1			.pastdmark: pop af  
3cfe			endm  
# End of macro DMARK
3cfe						CALLMONITOR 
3cfe cd 97 16			call break_point_state  
3d01				endm  
# End of macro CALLMONITOR
3d01					endif 
3d01 cd f8 0a				call update_display 
3d04					NEXTW 
3d04 c3 90 1f			jp macro_next 
3d07				endm 
# End of macro NEXTW
3d07			 
3d07			.DUMP: 
3d07				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3d07 37				db WORD_SYS_CORE+35             
3d08 3f 3d			dw .CDUMP            
3d0a 05				db 4 + 1 
3d0b .. 00			db "DUMP",0              
3d10				endm 
# End of macro CWHEAD
3d10			; | DUMP ( x -- ) With address x display dump   | DONE 
3d10			; TODO pop address to use off of the stack 
3d10					if DEBUG_FORTH_WORDS_KEY 
3d10						DMARK "DUM" 
3d10 f5				push af  
3d11 3a 25 3d			ld a, (.dmark)  
3d14 32 77 fb			ld (debug_mark),a  
3d17 3a 26 3d			ld a, (.dmark+1)  
3d1a 32 78 fb			ld (debug_mark+1),a  
3d1d 3a 27 3d			ld a, (.dmark+2)  
3d20 32 79 fb			ld (debug_mark+2),a  
3d23 18 03			jr .pastdmark  
3d25 ..			.dmark: db "DUM"  
3d28 f1			.pastdmark: pop af  
3d29			endm  
# End of macro DMARK
3d29						CALLMONITOR 
3d29 cd 97 16			call break_point_state  
3d2c				endm  
# End of macro CALLMONITOR
3d2c					endif 
3d2c cd d5 0a				call clear_display 
3d2f			 
3d2f					; get address 
3d2f			 
3d2f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d2f cd 1e 1e			call macro_dsp_valuehl 
3d32				endm 
# End of macro FORTH_DSP_VALUEHL
3d32				 
3d32					; save it for cdump 
3d32			 
3d32 22 40 f1				ld (os_cur_ptr),hl 
3d35			 
3d35					; destroy value TOS 
3d35			 
3d35					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d35 cd d6 1e			call macro_forth_dsp_pop 
3d38				endm 
# End of macro FORTH_DSP_POP
3d38			 
3d38 cd a7 1a				call dumpcont	; skip old style of param parsing	 
3d3b c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3d3c					NEXTW 
3d3c c3 90 1f			jp macro_next 
3d3f				endm 
# End of macro NEXTW
3d3f			.CDUMP: 
3d3f				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3d3f 38				db WORD_SYS_CORE+36             
3d40 6f 3d			dw .DAT            
3d42 06				db 5 + 1 
3d43 .. 00			db "CDUMP",0              
3d49				endm 
# End of macro CWHEAD
3d49			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3d49					if DEBUG_FORTH_WORDS_KEY 
3d49						DMARK "CDP" 
3d49 f5				push af  
3d4a 3a 5e 3d			ld a, (.dmark)  
3d4d 32 77 fb			ld (debug_mark),a  
3d50 3a 5f 3d			ld a, (.dmark+1)  
3d53 32 78 fb			ld (debug_mark+1),a  
3d56 3a 60 3d			ld a, (.dmark+2)  
3d59 32 79 fb			ld (debug_mark+2),a  
3d5c 18 03			jr .pastdmark  
3d5e ..			.dmark: db "CDP"  
3d61 f1			.pastdmark: pop af  
3d62			endm  
# End of macro DMARK
3d62						CALLMONITOR 
3d62 cd 97 16			call break_point_state  
3d65				endm  
# End of macro CALLMONITOR
3d65					endif 
3d65 cd d5 0a				call clear_display 
3d68 cd a7 1a				call dumpcont	 
3d6b c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3d6c					NEXTW 
3d6c c3 90 1f			jp macro_next 
3d6f				endm 
# End of macro NEXTW
3d6f			 
3d6f			 
3d6f			 
3d6f			 
3d6f			.DAT: 
3d6f				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3d6f 3d				db WORD_SYS_CORE+41             
3d70 c5 3d			dw .HOME            
3d72 03				db 2 + 1 
3d73 .. 00			db "AT",0              
3d76				endm 
# End of macro CWHEAD
3d76			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3d76					if DEBUG_FORTH_WORDS_KEY 
3d76						DMARK "AT." 
3d76 f5				push af  
3d77 3a 8b 3d			ld a, (.dmark)  
3d7a 32 77 fb			ld (debug_mark),a  
3d7d 3a 8c 3d			ld a, (.dmark+1)  
3d80 32 78 fb			ld (debug_mark+1),a  
3d83 3a 8d 3d			ld a, (.dmark+2)  
3d86 32 79 fb			ld (debug_mark+2),a  
3d89 18 03			jr .pastdmark  
3d8b ..			.dmark: db "AT."  
3d8e f1			.pastdmark: pop af  
3d8f			endm  
# End of macro DMARK
3d8f						CALLMONITOR 
3d8f cd 97 16			call break_point_state  
3d92				endm  
# End of macro CALLMONITOR
3d92					endif 
3d92					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d92 cd 1e 1e			call macro_dsp_valuehl 
3d95				endm 
# End of macro FORTH_DSP_VALUEHL
3d95			 
3d95			 
3d95					; TODO save cursor row 
3d95 7d					ld a,l 
3d96 fe 02				cp 2 
3d98 20 04				jr nz, .crow3 
3d9a 3e 28				ld a, display_row_2 
3d9c 18 12				jr .ccol1 
3d9e fe 03		.crow3:		cp 3 
3da0 20 04				jr nz, .crow4 
3da2 3e 50				ld a, display_row_3 
3da4 18 0a				jr .ccol1 
3da6 fe 04		.crow4:		cp 4 
3da8 20 04				jr nz, .crow1 
3daa 3e 78				ld a, display_row_4 
3dac 18 02				jr .ccol1 
3dae 3e 00		.crow1:		ld a,display_row_1 
3db0 f5			.ccol1:		push af			; got row offset 
3db1 6f					ld l,a 
3db2 26 00				ld h,0 
3db4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3db4 cd d6 1e			call macro_forth_dsp_pop 
3db7				endm 
# End of macro FORTH_DSP_POP
3db7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3db7 cd 1e 1e			call macro_dsp_valuehl 
3dba				endm 
# End of macro FORTH_DSP_VALUEHL
3dba					; TODO save cursor col 
3dba f1					pop af 
3dbb 85					add l		; add col offset 
3dbc 32 46 f8				ld (f_cursor_ptr), a 
3dbf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dbf cd d6 1e			call macro_forth_dsp_pop 
3dc2				endm 
# End of macro FORTH_DSP_POP
3dc2			 
3dc2					; calculate  
3dc2			 
3dc2					NEXTW 
3dc2 c3 90 1f			jp macro_next 
3dc5				endm 
# End of macro NEXTW
3dc5			 
3dc5			 
3dc5			.HOME: 
3dc5				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3dc5 41				db WORD_SYS_CORE+45             
3dc6 f2 3d			dw .SPACE            
3dc8 05				db 4 + 1 
3dc9 .. 00			db "HOME",0              
3dce				endm 
# End of macro CWHEAD
3dce			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3dce					if DEBUG_FORTH_WORDS_KEY 
3dce						DMARK "HOM" 
3dce f5				push af  
3dcf 3a e3 3d			ld a, (.dmark)  
3dd2 32 77 fb			ld (debug_mark),a  
3dd5 3a e4 3d			ld a, (.dmark+1)  
3dd8 32 78 fb			ld (debug_mark+1),a  
3ddb 3a e5 3d			ld a, (.dmark+2)  
3dde 32 79 fb			ld (debug_mark+2),a  
3de1 18 03			jr .pastdmark  
3de3 ..			.dmark: db "HOM"  
3de6 f1			.pastdmark: pop af  
3de7			endm  
# End of macro DMARK
3de7						CALLMONITOR 
3de7 cd 97 16			call break_point_state  
3dea				endm  
# End of macro CALLMONITOR
3dea					endif 
3dea 3e 00		.home:		ld a, 0		; and home cursor 
3dec 32 46 f8				ld (f_cursor_ptr), a 
3def					NEXTW 
3def c3 90 1f			jp macro_next 
3df2				endm 
# End of macro NEXTW
3df2			 
3df2			 
3df2			.SPACE: 
3df2				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3df2 46				db WORD_SYS_CORE+50             
3df3 20 3e			dw .SPACES            
3df5 03				db 2 + 1 
3df6 .. 00			db "BL",0              
3df9				endm 
# End of macro CWHEAD
3df9			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3df9					if DEBUG_FORTH_WORDS_KEY 
3df9						DMARK "BL." 
3df9 f5				push af  
3dfa 3a 0e 3e			ld a, (.dmark)  
3dfd 32 77 fb			ld (debug_mark),a  
3e00 3a 0f 3e			ld a, (.dmark+1)  
3e03 32 78 fb			ld (debug_mark+1),a  
3e06 3a 10 3e			ld a, (.dmark+2)  
3e09 32 79 fb			ld (debug_mark+2),a  
3e0c 18 03			jr .pastdmark  
3e0e ..			.dmark: db "BL."  
3e11 f1			.pastdmark: pop af  
3e12			endm  
# End of macro DMARK
3e12						CALLMONITOR 
3e12 cd 97 16			call break_point_state  
3e15				endm  
# End of macro CALLMONITOR
3e15					endif 
3e15 21 1e 3e				ld hl, .blstr 
3e18 cd 95 1c				call forth_push_str 
3e1b					 
3e1b				       NEXTW 
3e1b c3 90 1f			jp macro_next 
3e1e				endm 
# End of macro NEXTW
3e1e			 
3e1e .. 00		.blstr: db " ", 0 
3e20			 
3e20			.SPACES: 
3e20				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3e20 47				db WORD_SYS_CORE+51             
3e21 bb 3e			dw .SCROLL            
3e23 07				db 6 + 1 
3e24 .. 00			db "SPACES",0              
3e2b				endm 
# End of macro CWHEAD
3e2b			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3e2b					if DEBUG_FORTH_WORDS_KEY 
3e2b						DMARK "SPS" 
3e2b f5				push af  
3e2c 3a 40 3e			ld a, (.dmark)  
3e2f 32 77 fb			ld (debug_mark),a  
3e32 3a 41 3e			ld a, (.dmark+1)  
3e35 32 78 fb			ld (debug_mark+1),a  
3e38 3a 42 3e			ld a, (.dmark+2)  
3e3b 32 79 fb			ld (debug_mark+2),a  
3e3e 18 03			jr .pastdmark  
3e40 ..			.dmark: db "SPS"  
3e43 f1			.pastdmark: pop af  
3e44			endm  
# End of macro DMARK
3e44						CALLMONITOR 
3e44 cd 97 16			call break_point_state  
3e47				endm  
# End of macro CALLMONITOR
3e47					endif 
3e47			 
3e47			 
3e47					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e47 cd 1e 1e			call macro_dsp_valuehl 
3e4a				endm 
# End of macro FORTH_DSP_VALUEHL
3e4a			 
3e4a			;		push hl    ; u 
3e4a					if DEBUG_FORTH_WORDS 
3e4a						DMARK "SPA" 
3e4a f5				push af  
3e4b 3a 5f 3e			ld a, (.dmark)  
3e4e 32 77 fb			ld (debug_mark),a  
3e51 3a 60 3e			ld a, (.dmark+1)  
3e54 32 78 fb			ld (debug_mark+1),a  
3e57 3a 61 3e			ld a, (.dmark+2)  
3e5a 32 79 fb			ld (debug_mark+2),a  
3e5d 18 03			jr .pastdmark  
3e5f ..			.dmark: db "SPA"  
3e62 f1			.pastdmark: pop af  
3e63			endm  
# End of macro DMARK
3e63						CALLMONITOR 
3e63 cd 97 16			call break_point_state  
3e66				endm  
# End of macro CALLMONITOR
3e66					endif 
3e66			 
3e66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e66 cd d6 1e			call macro_forth_dsp_pop 
3e69				endm 
# End of macro FORTH_DSP_POP
3e69			;		pop hl 
3e69 4d					ld c, l 
3e6a 06 00				ld b, 0 
3e6c 21 1d ee				ld hl, scratch  
3e6f			 
3e6f					if DEBUG_FORTH_WORDS 
3e6f						DMARK "SP2" 
3e6f f5				push af  
3e70 3a 84 3e			ld a, (.dmark)  
3e73 32 77 fb			ld (debug_mark),a  
3e76 3a 85 3e			ld a, (.dmark+1)  
3e79 32 78 fb			ld (debug_mark+1),a  
3e7c 3a 86 3e			ld a, (.dmark+2)  
3e7f 32 79 fb			ld (debug_mark+2),a  
3e82 18 03			jr .pastdmark  
3e84 ..			.dmark: db "SP2"  
3e87 f1			.pastdmark: pop af  
3e88			endm  
# End of macro DMARK
3e88						CALLMONITOR 
3e88 cd 97 16			call break_point_state  
3e8b				endm  
# End of macro CALLMONITOR
3e8b					endif 
3e8b 3e 20				ld a, ' ' 
3e8d c5			.spaces1:	push bc 
3e8e 77					ld (hl),a 
3e8f 23					inc hl 
3e90 c1					pop bc 
3e91 10 fa				djnz .spaces1 
3e93 3e 00				ld a,0 
3e95 77					ld (hl),a 
3e96 21 1d ee				ld hl, scratch 
3e99					if DEBUG_FORTH_WORDS 
3e99						DMARK "SP3" 
3e99 f5				push af  
3e9a 3a ae 3e			ld a, (.dmark)  
3e9d 32 77 fb			ld (debug_mark),a  
3ea0 3a af 3e			ld a, (.dmark+1)  
3ea3 32 78 fb			ld (debug_mark+1),a  
3ea6 3a b0 3e			ld a, (.dmark+2)  
3ea9 32 79 fb			ld (debug_mark+2),a  
3eac 18 03			jr .pastdmark  
3eae ..			.dmark: db "SP3"  
3eb1 f1			.pastdmark: pop af  
3eb2			endm  
# End of macro DMARK
3eb2						CALLMONITOR 
3eb2 cd 97 16			call break_point_state  
3eb5				endm  
# End of macro CALLMONITOR
3eb5					endif 
3eb5 cd 90 1d				call forth_apush 
3eb8			 
3eb8				       NEXTW 
3eb8 c3 90 1f			jp macro_next 
3ebb				endm 
# End of macro NEXTW
3ebb			 
3ebb			 
3ebb			 
3ebb			.SCROLL: 
3ebb				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3ebb 53				db WORD_SYS_CORE+63             
3ebc e8 3e			dw .SCROLLD            
3ebe 07				db 6 + 1 
3ebf .. 00			db "SCROLL",0              
3ec6				endm 
# End of macro CWHEAD
3ec6			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3ec6					if DEBUG_FORTH_WORDS_KEY 
3ec6						DMARK "SCR" 
3ec6 f5				push af  
3ec7 3a db 3e			ld a, (.dmark)  
3eca 32 77 fb			ld (debug_mark),a  
3ecd 3a dc 3e			ld a, (.dmark+1)  
3ed0 32 78 fb			ld (debug_mark+1),a  
3ed3 3a dd 3e			ld a, (.dmark+2)  
3ed6 32 79 fb			ld (debug_mark+2),a  
3ed9 18 03			jr .pastdmark  
3edb ..			.dmark: db "SCR"  
3ede f1			.pastdmark: pop af  
3edf			endm  
# End of macro DMARK
3edf						CALLMONITOR 
3edf cd 97 16			call break_point_state  
3ee2				endm  
# End of macro CALLMONITOR
3ee2					endif 
3ee2			 
3ee2 cd 97 0a			call scroll_up 
3ee5			;	call update_display 
3ee5			 
3ee5					NEXTW 
3ee5 c3 90 1f			jp macro_next 
3ee8				endm 
# End of macro NEXTW
3ee8			 
3ee8			 
3ee8			 
3ee8			;		; get dir 
3ee8			; 
3ee8			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee8			; 
3ee8			;		push hl 
3ee8			; 
3ee8			;		; destroy value TOS 
3ee8			; 
3ee8			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ee8			; 
3ee8			;		; get count 
3ee8			; 
3ee8			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee8			; 
3ee8			;		push hl 
3ee8			; 
3ee8			;		; destroy value TOS 
3ee8			; 
3ee8			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ee8			; 
3ee8			;		; one value on hl get other one back 
3ee8			; 
3ee8			;		pop bc    ; count 
3ee8			; 
3ee8			;		pop de   ; dir 
3ee8			; 
3ee8			; 
3ee8			;		ld b, c 
3ee8			; 
3ee8			;.scrolldir:     push bc 
3ee8			;		push de 
3ee8			; 
3ee8			;		ld a, 0 
3ee8			;		cp e 
3ee8			;		jr z, .scrollup  
3ee8			;		call scroll_down 
3ee8			;		jr .scrollnext 
3ee8			;.scrollup:	call scroll_up 
3ee8			; 
3ee8			;		 
3ee8			;.scrollnext: 
3ee8			;		pop de 
3ee8			;		pop bc 
3ee8			;		djnz .scrolldir 
3ee8			; 
3ee8			; 
3ee8			; 
3ee8			; 
3ee8			; 
3ee8			;		NEXTW 
3ee8			 
3ee8			.SCROLLD: 
3ee8				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3ee8 53				db WORD_SYS_CORE+63             
3ee9 16 3f			dw .ATQ            
3eeb 08				db 7 + 1 
3eec .. 00			db "SCROLLD",0              
3ef4				endm 
# End of macro CWHEAD
3ef4			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3ef4					if DEBUG_FORTH_WORDS_KEY 
3ef4						DMARK "SCD" 
3ef4 f5				push af  
3ef5 3a 09 3f			ld a, (.dmark)  
3ef8 32 77 fb			ld (debug_mark),a  
3efb 3a 0a 3f			ld a, (.dmark+1)  
3efe 32 78 fb			ld (debug_mark+1),a  
3f01 3a 0b 3f			ld a, (.dmark+2)  
3f04 32 79 fb			ld (debug_mark+2),a  
3f07 18 03			jr .pastdmark  
3f09 ..			.dmark: db "SCD"  
3f0c f1			.pastdmark: pop af  
3f0d			endm  
# End of macro DMARK
3f0d						CALLMONITOR 
3f0d cd 97 16			call break_point_state  
3f10				endm  
# End of macro CALLMONITOR
3f10					endif 
3f10			 
3f10 cd bb 0a			call scroll_down 
3f13			;	call update_display 
3f13			 
3f13					NEXTW 
3f13 c3 90 1f			jp macro_next 
3f16				endm 
# End of macro NEXTW
3f16			 
3f16			 
3f16			.ATQ: 
3f16				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3f16 62				db WORD_SYS_CORE+78             
3f17 74 3f			dw .AUTODSP            
3f19 04				db 3 + 1 
3f1a .. 00			db "AT@",0              
3f1e				endm 
# End of macro CWHEAD
3f1e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3f1e					if DEBUG_FORTH_WORDS_KEY 
3f1e						DMARK "ATA" 
3f1e f5				push af  
3f1f 3a 33 3f			ld a, (.dmark)  
3f22 32 77 fb			ld (debug_mark),a  
3f25 3a 34 3f			ld a, (.dmark+1)  
3f28 32 78 fb			ld (debug_mark+1),a  
3f2b 3a 35 3f			ld a, (.dmark+2)  
3f2e 32 79 fb			ld (debug_mark+2),a  
3f31 18 03			jr .pastdmark  
3f33 ..			.dmark: db "ATA"  
3f36 f1			.pastdmark: pop af  
3f37			endm  
# End of macro DMARK
3f37						CALLMONITOR 
3f37 cd 97 16			call break_point_state  
3f3a				endm  
# End of macro CALLMONITOR
3f3a					endif 
3f3a			 
3f3a			 
3f3a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f3a cd 1e 1e			call macro_dsp_valuehl 
3f3d				endm 
# End of macro FORTH_DSP_VALUEHL
3f3d			 
3f3d					; TODO save cursor row 
3f3d 7d					ld a,l 
3f3e fe 02				cp 2 
3f40 20 04				jr nz, .crow3aq 
3f42 3e 28				ld a, display_row_2 
3f44 18 12				jr .ccol1aq 
3f46 fe 03		.crow3aq:		cp 3 
3f48 20 04				jr nz, .crow4aq 
3f4a 3e 50				ld a, display_row_3 
3f4c 18 0a				jr .ccol1aq 
3f4e fe 04		.crow4aq:		cp 4 
3f50 20 04				jr nz, .crow1aq 
3f52 3e 78				ld a, display_row_4 
3f54 18 02				jr .ccol1aq 
3f56 3e 00		.crow1aq:		ld a,display_row_1 
3f58 f5			.ccol1aq:		push af			; got row offset 
3f59 6f					ld l,a 
3f5a 26 00				ld h,0 
3f5c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f5c cd d6 1e			call macro_forth_dsp_pop 
3f5f				endm 
# End of macro FORTH_DSP_POP
3f5f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f5f cd 1e 1e			call macro_dsp_valuehl 
3f62				endm 
# End of macro FORTH_DSP_VALUEHL
3f62					; TODO save cursor col 
3f62 f1					pop af 
3f63 85					add l		; add col offset 
3f64			 
3f64					; add current frame buffer address 
3f64 2a d8 f8				ld hl, (display_fb_active) 
3f67 cd 09 0d				call addatohl 
3f6a			 
3f6a			 
3f6a			 
3f6a			 
3f6a					; get char frame buffer location offset in hl 
3f6a			 
3f6a 7e					ld a,(hl) 
3f6b 26 00				ld h, 0 
3f6d 6f					ld l, a 
3f6e			 
3f6e cd 27 1c				call forth_push_numhl 
3f71			 
3f71			 
3f71					NEXTW 
3f71 c3 90 1f			jp macro_next 
3f74				endm 
# End of macro NEXTW
3f74			 
3f74			.AUTODSP: 
3f74				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3f74 63				db WORD_SYS_CORE+79             
3f75 8a 3f			dw .MENU            
3f77 05				db 4 + 1 
3f78 .. 00			db "ADSP",0              
3f7d				endm 
# End of macro CWHEAD
3f7d			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3f7d			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3f7d			 
3f7d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f7d cd 1e 1e			call macro_dsp_valuehl 
3f80				endm 
# End of macro FORTH_DSP_VALUEHL
3f80			 
3f80			;		push hl 
3f80			 
3f80					; destroy value TOS 
3f80			 
3f80					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f80 cd d6 1e			call macro_forth_dsp_pop 
3f83				endm 
# End of macro FORTH_DSP_POP
3f83			 
3f83			;		pop hl 
3f83			 
3f83 7d					ld a,l 
3f84 32 24 f8				ld (cli_autodisplay), a 
3f87				       NEXTW 
3f87 c3 90 1f			jp macro_next 
3f8a				endm 
# End of macro NEXTW
3f8a			 
3f8a			.MENU: 
3f8a				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f8a 70				db WORD_SYS_CORE+92             
3f8b 33 40			dw .ENDDISPLAY            
3f8d 05				db 4 + 1 
3f8e .. 00			db "MENU",0              
3f93				endm 
# End of macro CWHEAD
3f93			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f93			 
3f93			;		; get number of items on the stack 
3f93			; 
3f93				 
3f93					FORTH_DSP_VALUEHL 
3f93 cd 1e 1e			call macro_dsp_valuehl 
3f96				endm 
# End of macro FORTH_DSP_VALUEHL
3f96				 
3f96					if DEBUG_FORTH_WORDS_KEY 
3f96						DMARK "MNU" 
3f96 f5				push af  
3f97 3a ab 3f			ld a, (.dmark)  
3f9a 32 77 fb			ld (debug_mark),a  
3f9d 3a ac 3f			ld a, (.dmark+1)  
3fa0 32 78 fb			ld (debug_mark+1),a  
3fa3 3a ad 3f			ld a, (.dmark+2)  
3fa6 32 79 fb			ld (debug_mark+2),a  
3fa9 18 03			jr .pastdmark  
3fab ..			.dmark: db "MNU"  
3fae f1			.pastdmark: pop af  
3faf			endm  
# End of macro DMARK
3faf						CALLMONITOR 
3faf cd 97 16			call break_point_state  
3fb2				endm  
# End of macro CALLMONITOR
3fb2					endif 
3fb2			 
3fb2 45					ld b, l	 
3fb3 05					dec b 
3fb4			 
3fb4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fb4 cd d6 1e			call macro_forth_dsp_pop 
3fb7				endm 
# End of macro FORTH_DSP_POP
3fb7			 
3fb7			 
3fb7					; go directly through the stack to pluck out the string pointers and build an array 
3fb7			 
3fb7			;		FORTH_DSP 
3fb7			 
3fb7					; hl contains top most stack item 
3fb7				 
3fb7 11 1d ee				ld de, scratch 
3fba			 
3fba			.mbuild: 
3fba			 
3fba					FORTH_DSP_VALUEHL 
3fba cd 1e 1e			call macro_dsp_valuehl 
3fbd				endm 
# End of macro FORTH_DSP_VALUEHL
3fbd			 
3fbd					if DEBUG_FORTH_WORDS 
3fbd						DMARK "MN3" 
3fbd f5				push af  
3fbe 3a d2 3f			ld a, (.dmark)  
3fc1 32 77 fb			ld (debug_mark),a  
3fc4 3a d3 3f			ld a, (.dmark+1)  
3fc7 32 78 fb			ld (debug_mark+1),a  
3fca 3a d4 3f			ld a, (.dmark+2)  
3fcd 32 79 fb			ld (debug_mark+2),a  
3fd0 18 03			jr .pastdmark  
3fd2 ..			.dmark: db "MN3"  
3fd5 f1			.pastdmark: pop af  
3fd6			endm  
# End of macro DMARK
3fd6						CALLMONITOR 
3fd6 cd 97 16			call break_point_state  
3fd9				endm  
# End of macro CALLMONITOR
3fd9					endif 
3fd9 eb					ex de, hl 
3fda 73					ld (hl), e 
3fdb 23					inc hl 
3fdc 72					ld (hl), d 
3fdd 23					inc hl 
3fde eb					ex de, hl 
3fdf			 
3fdf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fdf cd d6 1e			call macro_forth_dsp_pop 
3fe2				endm 
# End of macro FORTH_DSP_POP
3fe2			 
3fe2 10 d6				djnz .mbuild 
3fe4			 
3fe4					; done add term 
3fe4			 
3fe4 eb					ex de, hl 
3fe5 36 00				ld (hl), 0 
3fe7 23					inc hl 
3fe8 36 00				ld (hl), 0 
3fea			 
3fea				 
3fea					 
3fea 21 1d ee				ld hl, scratch 
3fed			 
3fed					if DEBUG_FORTH_WORDS 
3fed						DMARK "MNx" 
3fed f5				push af  
3fee 3a 02 40			ld a, (.dmark)  
3ff1 32 77 fb			ld (debug_mark),a  
3ff4 3a 03 40			ld a, (.dmark+1)  
3ff7 32 78 fb			ld (debug_mark+1),a  
3ffa 3a 04 40			ld a, (.dmark+2)  
3ffd 32 79 fb			ld (debug_mark+2),a  
4000 18 03			jr .pastdmark  
4002 ..			.dmark: db "MNx"  
4005 f1			.pastdmark: pop af  
4006			endm  
# End of macro DMARK
4006						CALLMONITOR 
4006 cd 97 16			call break_point_state  
4009				endm  
# End of macro CALLMONITOR
4009					endif 
4009			 
4009			 
4009			 
4009 3e 00				ld a, 0 
400b cd 06 0b				call menu 
400e			 
400e			 
400e 6f					ld l, a 
400f 26 00				ld h, 0 
4011			 
4011					if DEBUG_FORTH_WORDS 
4011						DMARK "MNr" 
4011 f5				push af  
4012 3a 26 40			ld a, (.dmark)  
4015 32 77 fb			ld (debug_mark),a  
4018 3a 27 40			ld a, (.dmark+1)  
401b 32 78 fb			ld (debug_mark+1),a  
401e 3a 28 40			ld a, (.dmark+2)  
4021 32 79 fb			ld (debug_mark+2),a  
4024 18 03			jr .pastdmark  
4026 ..			.dmark: db "MNr"  
4029 f1			.pastdmark: pop af  
402a			endm  
# End of macro DMARK
402a						CALLMONITOR 
402a cd 97 16			call break_point_state  
402d				endm  
# End of macro CALLMONITOR
402d					endif 
402d			 
402d cd 27 1c				call forth_push_numhl 
4030			 
4030			 
4030			 
4030			 
4030				       NEXTW 
4030 c3 90 1f			jp macro_next 
4033				endm 
# End of macro NEXTW
4033			 
4033			 
4033			.ENDDISPLAY: 
4033			 
4033			; eof 
# End of file forth_words_display.asm
4033			include "forth_words_str.asm" 
4033			 
4033			; | ## String Words 
4033			 
4033			.PTR:   
4033			 
4033				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4033 48				db WORD_SYS_CORE+52             
4034 60 40			dw .STYPE            
4036 04				db 3 + 1 
4037 .. 00			db "PTR",0              
403b				endm 
# End of macro CWHEAD
403b			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
403b			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
403b			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
403b			 
403b					if DEBUG_FORTH_WORDS_KEY 
403b						DMARK "PTR" 
403b f5				push af  
403c 3a 50 40			ld a, (.dmark)  
403f 32 77 fb			ld (debug_mark),a  
4042 3a 51 40			ld a, (.dmark+1)  
4045 32 78 fb			ld (debug_mark+1),a  
4048 3a 52 40			ld a, (.dmark+2)  
404b 32 79 fb			ld (debug_mark+2),a  
404e 18 03			jr .pastdmark  
4050 ..			.dmark: db "PTR"  
4053 f1			.pastdmark: pop af  
4054			endm  
# End of macro DMARK
4054						CALLMONITOR 
4054 cd 97 16			call break_point_state  
4057				endm  
# End of macro CALLMONITOR
4057					endif 
4057					FORTH_DSP_VALUEHL 
4057 cd 1e 1e			call macro_dsp_valuehl 
405a				endm 
# End of macro FORTH_DSP_VALUEHL
405a cd 27 1c				call forth_push_numhl 
405d			 
405d			 
405d					NEXTW 
405d c3 90 1f			jp macro_next 
4060				endm 
# End of macro NEXTW
4060			.STYPE: 
4060				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4060 48				db WORD_SYS_CORE+52             
4061 af 40			dw .UPPER            
4063 06				db 5 + 1 
4064 .. 00			db "STYPE",0              
406a				endm 
# End of macro CWHEAD
406a			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
406a					if DEBUG_FORTH_WORDS_KEY 
406a						DMARK "STY" 
406a f5				push af  
406b 3a 7f 40			ld a, (.dmark)  
406e 32 77 fb			ld (debug_mark),a  
4071 3a 80 40			ld a, (.dmark+1)  
4074 32 78 fb			ld (debug_mark+1),a  
4077 3a 81 40			ld a, (.dmark+2)  
407a 32 79 fb			ld (debug_mark+2),a  
407d 18 03			jr .pastdmark  
407f ..			.dmark: db "STY"  
4082 f1			.pastdmark: pop af  
4083			endm  
# End of macro DMARK
4083						CALLMONITOR 
4083 cd 97 16			call break_point_state  
4086				endm  
# End of macro CALLMONITOR
4086					endif 
4086					FORTH_DSP 
4086 cd e4 1d			call macro_forth_dsp 
4089				endm 
# End of macro FORTH_DSP
4089					;v5 FORTH_DSP_VALUE 
4089			 
4089 7e					ld a, (hl) 
408a			 
408a f5					push af 
408b			 
408b			; Dont destroy TOS		FORTH_DSP_POP 
408b			 
408b f1					pop af 
408c			 
408c fe 01				cp DS_TYPE_STR 
408e 28 09				jr z, .typestr 
4090			 
4090 fe 02				cp DS_TYPE_INUM 
4092 28 0a				jr z, .typeinum 
4094			 
4094 21 ad 40				ld hl, .tna 
4097 18 0a				jr .tpush 
4099			 
4099 21 a9 40		.typestr:	ld hl, .tstr 
409c 18 05				jr .tpush 
409e 21 ab 40		.typeinum:	ld hl, .tinum 
40a1 18 00				jr .tpush 
40a3			 
40a3			.tpush: 
40a3			 
40a3 cd 95 1c				call forth_push_str 
40a6			 
40a6					NEXTW 
40a6 c3 90 1f			jp macro_next 
40a9				endm 
# End of macro NEXTW
40a9 .. 00		.tstr:	db "s",0 
40ab .. 00		.tinum:  db "i",0 
40ad .. 00		.tna:   db "?", 0 
40af			 
40af			 
40af			.UPPER: 
40af				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
40af 48				db WORD_SYS_CORE+52             
40b0 ea 40			dw .LOWER            
40b2 06				db 5 + 1 
40b3 .. 00			db "UPPER",0              
40b9				endm 
# End of macro CWHEAD
40b9			; | UPPER ( s -- s ) Upper case string s  | DONE 
40b9					if DEBUG_FORTH_WORDS_KEY 
40b9						DMARK "UPR" 
40b9 f5				push af  
40ba 3a ce 40			ld a, (.dmark)  
40bd 32 77 fb			ld (debug_mark),a  
40c0 3a cf 40			ld a, (.dmark+1)  
40c3 32 78 fb			ld (debug_mark+1),a  
40c6 3a d0 40			ld a, (.dmark+2)  
40c9 32 79 fb			ld (debug_mark+2),a  
40cc 18 03			jr .pastdmark  
40ce ..			.dmark: db "UPR"  
40d1 f1			.pastdmark: pop af  
40d2			endm  
# End of macro DMARK
40d2						CALLMONITOR 
40d2 cd 97 16			call break_point_state  
40d5				endm  
# End of macro CALLMONITOR
40d5					endif 
40d5			 
40d5					FORTH_DSP 
40d5 cd e4 1d			call macro_forth_dsp 
40d8				endm 
# End of macro FORTH_DSP
40d8					 
40d8			; TODO check is string type 
40d8			 
40d8					FORTH_DSP_VALUEHL 
40d8 cd 1e 1e			call macro_dsp_valuehl 
40db				endm 
# End of macro FORTH_DSP_VALUEHL
40db			; get pointer to string in hl 
40db			 
40db 7e			.toup:		ld a, (hl) 
40dc fe 00				cp 0 
40de 28 07				jr z, .toupdone 
40e0			 
40e0 cd 76 10				call to_upper 
40e3			 
40e3 77					ld (hl), a 
40e4 23					inc hl 
40e5 18 f4				jr .toup 
40e7			 
40e7					 
40e7			 
40e7			 
40e7			; for each char convert to upper 
40e7					 
40e7			.toupdone: 
40e7			 
40e7			 
40e7					NEXTW 
40e7 c3 90 1f			jp macro_next 
40ea				endm 
# End of macro NEXTW
40ea			.LOWER: 
40ea				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
40ea 48				db WORD_SYS_CORE+52             
40eb 25 41			dw .TCASE            
40ed 06				db 5 + 1 
40ee .. 00			db "LOWER",0              
40f4				endm 
# End of macro CWHEAD
40f4			; | LOWER ( s -- s ) Lower case string s  | DONE 
40f4					if DEBUG_FORTH_WORDS_KEY 
40f4						DMARK "LWR" 
40f4 f5				push af  
40f5 3a 09 41			ld a, (.dmark)  
40f8 32 77 fb			ld (debug_mark),a  
40fb 3a 0a 41			ld a, (.dmark+1)  
40fe 32 78 fb			ld (debug_mark+1),a  
4101 3a 0b 41			ld a, (.dmark+2)  
4104 32 79 fb			ld (debug_mark+2),a  
4107 18 03			jr .pastdmark  
4109 ..			.dmark: db "LWR"  
410c f1			.pastdmark: pop af  
410d			endm  
# End of macro DMARK
410d						CALLMONITOR 
410d cd 97 16			call break_point_state  
4110				endm  
# End of macro CALLMONITOR
4110					endif 
4110			 
4110					FORTH_DSP 
4110 cd e4 1d			call macro_forth_dsp 
4113				endm 
# End of macro FORTH_DSP
4113					 
4113			; TODO check is string type 
4113			 
4113					FORTH_DSP_VALUEHL 
4113 cd 1e 1e			call macro_dsp_valuehl 
4116				endm 
# End of macro FORTH_DSP_VALUEHL
4116			; get pointer to string in hl 
4116			 
4116 7e			.tolow:		ld a, (hl) 
4117 fe 00				cp 0 
4119 28 07				jr z, .tolowdone 
411b			 
411b cd 7f 10				call to_lower 
411e			 
411e 77					ld (hl), a 
411f 23					inc hl 
4120 18 f4				jr .tolow 
4122			 
4122					 
4122			 
4122			 
4122			; for each char convert to low 
4122					 
4122			.tolowdone: 
4122					NEXTW 
4122 c3 90 1f			jp macro_next 
4125				endm 
# End of macro NEXTW
4125			.TCASE: 
4125				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4125 48				db WORD_SYS_CORE+52             
4126 5b 42			dw .SUBSTR            
4128 06				db 5 + 1 
4129 .. 00			db "TCASE",0              
412f				endm 
# End of macro CWHEAD
412f			; | TCASE ( s -- s ) Title case string s  | DONE 
412f					if DEBUG_FORTH_WORDS_KEY 
412f						DMARK "TCS" 
412f f5				push af  
4130 3a 44 41			ld a, (.dmark)  
4133 32 77 fb			ld (debug_mark),a  
4136 3a 45 41			ld a, (.dmark+1)  
4139 32 78 fb			ld (debug_mark+1),a  
413c 3a 46 41			ld a, (.dmark+2)  
413f 32 79 fb			ld (debug_mark+2),a  
4142 18 03			jr .pastdmark  
4144 ..			.dmark: db "TCS"  
4147 f1			.pastdmark: pop af  
4148			endm  
# End of macro DMARK
4148						CALLMONITOR 
4148 cd 97 16			call break_point_state  
414b				endm  
# End of macro CALLMONITOR
414b					endif 
414b			 
414b					FORTH_DSP 
414b cd e4 1d			call macro_forth_dsp 
414e				endm 
# End of macro FORTH_DSP
414e					 
414e			; TODO check is string type 
414e			 
414e					FORTH_DSP_VALUEHL 
414e cd 1e 1e			call macro_dsp_valuehl 
4151				endm 
# End of macro FORTH_DSP_VALUEHL
4151			; get pointer to string in hl 
4151			 
4151					if DEBUG_FORTH_WORDS 
4151						DMARK "TC1" 
4151 f5				push af  
4152 3a 66 41			ld a, (.dmark)  
4155 32 77 fb			ld (debug_mark),a  
4158 3a 67 41			ld a, (.dmark+1)  
415b 32 78 fb			ld (debug_mark+1),a  
415e 3a 68 41			ld a, (.dmark+2)  
4161 32 79 fb			ld (debug_mark+2),a  
4164 18 03			jr .pastdmark  
4166 ..			.dmark: db "TC1"  
4169 f1			.pastdmark: pop af  
416a			endm  
# End of macro DMARK
416a						CALLMONITOR 
416a cd 97 16			call break_point_state  
416d				endm  
# End of macro CALLMONITOR
416d					endif 
416d			 
416d					; first time in turn to upper case first char 
416d			 
416d 7e					ld a, (hl) 
416e c3 f8 41				jp .totsiptou 
4171			 
4171			 
4171 7e			.tot:		ld a, (hl) 
4172 fe 00				cp 0 
4174 ca 3c 42				jp z, .totdone 
4177			 
4177					if DEBUG_FORTH_WORDS 
4177						DMARK "TC2" 
4177 f5				push af  
4178 3a 8c 41			ld a, (.dmark)  
417b 32 77 fb			ld (debug_mark),a  
417e 3a 8d 41			ld a, (.dmark+1)  
4181 32 78 fb			ld (debug_mark+1),a  
4184 3a 8e 41			ld a, (.dmark+2)  
4187 32 79 fb			ld (debug_mark+2),a  
418a 18 03			jr .pastdmark  
418c ..			.dmark: db "TC2"  
418f f1			.pastdmark: pop af  
4190			endm  
# End of macro DMARK
4190						CALLMONITOR 
4190 cd 97 16			call break_point_state  
4193				endm  
# End of macro CALLMONITOR
4193					endif 
4193					; check to see if current char is a space 
4193			 
4193 fe 20				cp ' ' 
4195 28 21				jr z, .totsp 
4197 cd 7f 10				call to_lower 
419a					if DEBUG_FORTH_WORDS 
419a						DMARK "TC3" 
419a f5				push af  
419b 3a af 41			ld a, (.dmark)  
419e 32 77 fb			ld (debug_mark),a  
41a1 3a b0 41			ld a, (.dmark+1)  
41a4 32 78 fb			ld (debug_mark+1),a  
41a7 3a b1 41			ld a, (.dmark+2)  
41aa 32 79 fb			ld (debug_mark+2),a  
41ad 18 03			jr .pastdmark  
41af ..			.dmark: db "TC3"  
41b2 f1			.pastdmark: pop af  
41b3			endm  
# End of macro DMARK
41b3						CALLMONITOR 
41b3 cd 97 16			call break_point_state  
41b6				endm  
# End of macro CALLMONITOR
41b6					endif 
41b6 18 63				jr .totnxt 
41b8			 
41b8			.totsp:         ; on a space, find next char which should be upper 
41b8			 
41b8					if DEBUG_FORTH_WORDS 
41b8						DMARK "TC4" 
41b8 f5				push af  
41b9 3a cd 41			ld a, (.dmark)  
41bc 32 77 fb			ld (debug_mark),a  
41bf 3a ce 41			ld a, (.dmark+1)  
41c2 32 78 fb			ld (debug_mark+1),a  
41c5 3a cf 41			ld a, (.dmark+2)  
41c8 32 79 fb			ld (debug_mark+2),a  
41cb 18 03			jr .pastdmark  
41cd ..			.dmark: db "TC4"  
41d0 f1			.pastdmark: pop af  
41d1			endm  
# End of macro DMARK
41d1						CALLMONITOR 
41d1 cd 97 16			call break_point_state  
41d4				endm  
# End of macro CALLMONITOR
41d4					endif 
41d4					;; 
41d4			 
41d4 fe 20				cp ' ' 
41d6 20 20				jr nz, .totsiptou 
41d8 23					inc hl 
41d9 7e					ld a, (hl) 
41da					if DEBUG_FORTH_WORDS 
41da						DMARK "TC5" 
41da f5				push af  
41db 3a ef 41			ld a, (.dmark)  
41de 32 77 fb			ld (debug_mark),a  
41e1 3a f0 41			ld a, (.dmark+1)  
41e4 32 78 fb			ld (debug_mark+1),a  
41e7 3a f1 41			ld a, (.dmark+2)  
41ea 32 79 fb			ld (debug_mark+2),a  
41ed 18 03			jr .pastdmark  
41ef ..			.dmark: db "TC5"  
41f2 f1			.pastdmark: pop af  
41f3			endm  
# End of macro DMARK
41f3						CALLMONITOR 
41f3 cd 97 16			call break_point_state  
41f6				endm  
# End of macro CALLMONITOR
41f6					endif 
41f6 18 c0				jr .totsp 
41f8 fe 00		.totsiptou:    cp 0 
41fa 28 40				jr z, .totdone 
41fc					; not space and not zero term so upper case it 
41fc cd 76 10				call to_upper 
41ff			 
41ff					if DEBUG_FORTH_WORDS 
41ff						DMARK "TC6" 
41ff f5				push af  
4200 3a 14 42			ld a, (.dmark)  
4203 32 77 fb			ld (debug_mark),a  
4206 3a 15 42			ld a, (.dmark+1)  
4209 32 78 fb			ld (debug_mark+1),a  
420c 3a 16 42			ld a, (.dmark+2)  
420f 32 79 fb			ld (debug_mark+2),a  
4212 18 03			jr .pastdmark  
4214 ..			.dmark: db "TC6"  
4217 f1			.pastdmark: pop af  
4218			endm  
# End of macro DMARK
4218						CALLMONITOR 
4218 cd 97 16			call break_point_state  
421b				endm  
# End of macro CALLMONITOR
421b					endif 
421b			 
421b			 
421b			.totnxt: 
421b			 
421b 77					ld (hl), a 
421c 23					inc hl 
421d					if DEBUG_FORTH_WORDS 
421d						DMARK "TC7" 
421d f5				push af  
421e 3a 32 42			ld a, (.dmark)  
4221 32 77 fb			ld (debug_mark),a  
4224 3a 33 42			ld a, (.dmark+1)  
4227 32 78 fb			ld (debug_mark+1),a  
422a 3a 34 42			ld a, (.dmark+2)  
422d 32 79 fb			ld (debug_mark+2),a  
4230 18 03			jr .pastdmark  
4232 ..			.dmark: db "TC7"  
4235 f1			.pastdmark: pop af  
4236			endm  
# End of macro DMARK
4236						CALLMONITOR 
4236 cd 97 16			call break_point_state  
4239				endm  
# End of macro CALLMONITOR
4239					endif 
4239 c3 71 41				jp .tot 
423c			 
423c					 
423c			 
423c			 
423c			; for each char convert to low 
423c					 
423c			.totdone: 
423c					if DEBUG_FORTH_WORDS 
423c						DMARK "TCd" 
423c f5				push af  
423d 3a 51 42			ld a, (.dmark)  
4240 32 77 fb			ld (debug_mark),a  
4243 3a 52 42			ld a, (.dmark+1)  
4246 32 78 fb			ld (debug_mark+1),a  
4249 3a 53 42			ld a, (.dmark+2)  
424c 32 79 fb			ld (debug_mark+2),a  
424f 18 03			jr .pastdmark  
4251 ..			.dmark: db "TCd"  
4254 f1			.pastdmark: pop af  
4255			endm  
# End of macro DMARK
4255						CALLMONITOR 
4255 cd 97 16			call break_point_state  
4258				endm  
# End of macro CALLMONITOR
4258					endif 
4258					NEXTW 
4258 c3 90 1f			jp macro_next 
425b				endm 
# End of macro NEXTW
425b			 
425b			.SUBSTR: 
425b				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
425b 48				db WORD_SYS_CORE+52             
425c b9 42			dw .LEFT            
425e 07				db 6 + 1 
425f .. 00			db "SUBSTR",0              
4266				endm 
# End of macro CWHEAD
4266			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4266			 
4266					if DEBUG_FORTH_WORDS_KEY 
4266						DMARK "SST" 
4266 f5				push af  
4267 3a 7b 42			ld a, (.dmark)  
426a 32 77 fb			ld (debug_mark),a  
426d 3a 7c 42			ld a, (.dmark+1)  
4270 32 78 fb			ld (debug_mark+1),a  
4273 3a 7d 42			ld a, (.dmark+2)  
4276 32 79 fb			ld (debug_mark+2),a  
4279 18 03			jr .pastdmark  
427b ..			.dmark: db "SST"  
427e f1			.pastdmark: pop af  
427f			endm  
# End of macro DMARK
427f						CALLMONITOR 
427f cd 97 16			call break_point_state  
4282				endm  
# End of macro CALLMONITOR
4282					endif 
4282			; TODO check string type 
4282					FORTH_DSP_VALUEHL 
4282 cd 1e 1e			call macro_dsp_valuehl 
4285				endm 
# End of macro FORTH_DSP_VALUEHL
4285			 
4285 e5					push hl      ; string length 
4286			 
4286					FORTH_DSP_POP 
4286 cd d6 1e			call macro_forth_dsp_pop 
4289				endm 
# End of macro FORTH_DSP_POP
4289			 
4289					FORTH_DSP_VALUEHL 
4289 cd 1e 1e			call macro_dsp_valuehl 
428c				endm 
# End of macro FORTH_DSP_VALUEHL
428c			 
428c e5					push hl     ; start char 
428d			 
428d					FORTH_DSP_POP 
428d cd d6 1e			call macro_forth_dsp_pop 
4290				endm 
# End of macro FORTH_DSP_POP
4290			 
4290			 
4290					FORTH_DSP_VALUE 
4290 cd 07 1e			call macro_forth_dsp_value 
4293				endm 
# End of macro FORTH_DSP_VALUE
4293			 
4293 d1					pop de    ; get start post offset 
4294			 
4294 19					add hl, de    ; starting offset 
4295			 
4295 c1					pop bc 
4296 c5					push bc      ; grab size of string 
4297			 
4297 e5					push hl    ; save string start  
4298			 
4298 26 00				ld h, 0 
429a 69					ld l, c 
429b 23					inc hl 
429c 23					inc hl 
429d			 
429d cd d0 11				call malloc 
42a0				if DEBUG_FORTH_MALLOC_GUARD 
42a0 cc 4b 52				call z,malloc_error 
42a3				endif 
42a3			 
42a3 eb					ex de, hl      ; save malloc area for string copy 
42a4 e1					pop hl    ; get back source 
42a5 c1					pop bc    ; get length of string back 
42a6			 
42a6 d5					push de    ; save malloc area for after we push 
42a7 ed b0				ldir     ; copy substr 
42a9			 
42a9			 
42a9 eb					ex de, hl 
42aa 3e 00				ld a, 0 
42ac 77					ld (hl), a   ; term substr 
42ad			 
42ad					 
42ad e1					pop hl    ; get malloc so we can push it 
42ae e5					push hl   ; save so we can free it afterwards 
42af			 
42af cd 95 1c				call forth_push_str 
42b2			 
42b2 e1					pop hl 
42b3 cd 9a 12				call free 
42b6			 
42b6					 
42b6					 
42b6			 
42b6			 
42b6					NEXTW 
42b6 c3 90 1f			jp macro_next 
42b9				endm 
# End of macro NEXTW
42b9			 
42b9			.LEFT: 
42b9				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
42b9 48				db WORD_SYS_CORE+52             
42ba e1 42			dw .RIGHT            
42bc 05				db 4 + 1 
42bd .. 00			db "LEFT",0              
42c2				endm 
# End of macro CWHEAD
42c2			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
42c2					if DEBUG_FORTH_WORDS_KEY 
42c2						DMARK "LEF" 
42c2 f5				push af  
42c3 3a d7 42			ld a, (.dmark)  
42c6 32 77 fb			ld (debug_mark),a  
42c9 3a d8 42			ld a, (.dmark+1)  
42cc 32 78 fb			ld (debug_mark+1),a  
42cf 3a d9 42			ld a, (.dmark+2)  
42d2 32 79 fb			ld (debug_mark+2),a  
42d5 18 03			jr .pastdmark  
42d7 ..			.dmark: db "LEF"  
42da f1			.pastdmark: pop af  
42db			endm  
# End of macro DMARK
42db						CALLMONITOR 
42db cd 97 16			call break_point_state  
42de				endm  
# End of macro CALLMONITOR
42de					endif 
42de			 
42de					NEXTW 
42de c3 90 1f			jp macro_next 
42e1				endm 
# End of macro NEXTW
42e1			.RIGHT: 
42e1				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
42e1 48				db WORD_SYS_CORE+52             
42e2 0a 43			dw .STR2NUM            
42e4 06				db 5 + 1 
42e5 .. 00			db "RIGHT",0              
42eb				endm 
# End of macro CWHEAD
42eb			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
42eb					if DEBUG_FORTH_WORDS_KEY 
42eb						DMARK "RIG" 
42eb f5				push af  
42ec 3a 00 43			ld a, (.dmark)  
42ef 32 77 fb			ld (debug_mark),a  
42f2 3a 01 43			ld a, (.dmark+1)  
42f5 32 78 fb			ld (debug_mark+1),a  
42f8 3a 02 43			ld a, (.dmark+2)  
42fb 32 79 fb			ld (debug_mark+2),a  
42fe 18 03			jr .pastdmark  
4300 ..			.dmark: db "RIG"  
4303 f1			.pastdmark: pop af  
4304			endm  
# End of macro DMARK
4304						CALLMONITOR 
4304 cd 97 16			call break_point_state  
4307				endm  
# End of macro CALLMONITOR
4307					endif 
4307			 
4307					NEXTW 
4307 c3 90 1f			jp macro_next 
430a				endm 
# End of macro NEXTW
430a			 
430a			 
430a			.STR2NUM: 
430a				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
430a 48				db WORD_SYS_CORE+52             
430b 96 43			dw .NUM2STR            
430d 08				db 7 + 1 
430e .. 00			db "STR2NUM",0              
4316				endm 
# End of macro CWHEAD
4316			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4316			 
4316			 
4316			; TODO STR type check to do 
4316					if DEBUG_FORTH_WORDS_KEY 
4316						DMARK "S2N" 
4316 f5				push af  
4317 3a 2b 43			ld a, (.dmark)  
431a 32 77 fb			ld (debug_mark),a  
431d 3a 2c 43			ld a, (.dmark+1)  
4320 32 78 fb			ld (debug_mark+1),a  
4323 3a 2d 43			ld a, (.dmark+2)  
4326 32 79 fb			ld (debug_mark+2),a  
4329 18 03			jr .pastdmark  
432b ..			.dmark: db "S2N"  
432e f1			.pastdmark: pop af  
432f			endm  
# End of macro DMARK
432f						CALLMONITOR 
432f cd 97 16			call break_point_state  
4332				endm  
# End of macro CALLMONITOR
4332					endif 
4332			 
4332					;FORTH_DSP 
4332					FORTH_DSP_VALUE 
4332 cd 07 1e			call macro_forth_dsp_value 
4335				endm 
# End of macro FORTH_DSP_VALUE
4335					;inc hl 
4335			 
4335 eb					ex de, hl 
4336					if DEBUG_FORTH_WORDS 
4336						DMARK "S2a" 
4336 f5				push af  
4337 3a 4b 43			ld a, (.dmark)  
433a 32 77 fb			ld (debug_mark),a  
433d 3a 4c 43			ld a, (.dmark+1)  
4340 32 78 fb			ld (debug_mark+1),a  
4343 3a 4d 43			ld a, (.dmark+2)  
4346 32 79 fb			ld (debug_mark+2),a  
4349 18 03			jr .pastdmark  
434b ..			.dmark: db "S2a"  
434e f1			.pastdmark: pop af  
434f			endm  
# End of macro DMARK
434f						CALLMONITOR 
434f cd 97 16			call break_point_state  
4352				endm  
# End of macro CALLMONITOR
4352					endif 
4352 cd fe 10				call string_to_uint16 
4355			 
4355					if DEBUG_FORTH_WORDS 
4355						DMARK "S2b" 
4355 f5				push af  
4356 3a 6a 43			ld a, (.dmark)  
4359 32 77 fb			ld (debug_mark),a  
435c 3a 6b 43			ld a, (.dmark+1)  
435f 32 78 fb			ld (debug_mark+1),a  
4362 3a 6c 43			ld a, (.dmark+2)  
4365 32 79 fb			ld (debug_mark+2),a  
4368 18 03			jr .pastdmark  
436a ..			.dmark: db "S2b"  
436d f1			.pastdmark: pop af  
436e			endm  
# End of macro DMARK
436e						CALLMONITOR 
436e cd 97 16			call break_point_state  
4371				endm  
# End of macro CALLMONITOR
4371					endif 
4371			;		push hl 
4371					FORTH_DSP_POP 
4371 cd d6 1e			call macro_forth_dsp_pop 
4374				endm 
# End of macro FORTH_DSP_POP
4374			;		pop hl 
4374					 
4374					if DEBUG_FORTH_WORDS 
4374						DMARK "S2b" 
4374 f5				push af  
4375 3a 89 43			ld a, (.dmark)  
4378 32 77 fb			ld (debug_mark),a  
437b 3a 8a 43			ld a, (.dmark+1)  
437e 32 78 fb			ld (debug_mark+1),a  
4381 3a 8b 43			ld a, (.dmark+2)  
4384 32 79 fb			ld (debug_mark+2),a  
4387 18 03			jr .pastdmark  
4389 ..			.dmark: db "S2b"  
438c f1			.pastdmark: pop af  
438d			endm  
# End of macro DMARK
438d						CALLMONITOR 
438d cd 97 16			call break_point_state  
4390				endm  
# End of macro CALLMONITOR
4390					endif 
4390 cd 27 1c				call forth_push_numhl	 
4393			 
4393				 
4393				       NEXTW 
4393 c3 90 1f			jp macro_next 
4396				endm 
# End of macro NEXTW
4396			.NUM2STR: 
4396				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4396 48				db WORD_SYS_CORE+52             
4397 a5 43			dw .CONCAT            
4399 08				db 7 + 1 
439a .. 00			db "NUM2STR",0              
43a2				endm 
# End of macro CWHEAD
43a2			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
43a2			 
43a2			;		; malloc a string to target 
43a2			;		ld hl, 10     ; TODO max string size should be fine 
43a2			;		call malloc 
43a2			;		push hl    ; save malloc location 
43a2			; 
43a2			; 
43a2			;; TODO check int type 
43a2			;		FORTH_DSP_VALUEHL 
43a2			;		ld a, l 
43a2			;		call DispAToASCII   
43a2			;;TODO need to chage above call to dump into string 
43a2			; 
43a2			; 
43a2			 
43a2				       NEXTW 
43a2 c3 90 1f			jp macro_next 
43a5				endm 
# End of macro NEXTW
43a5			 
43a5			.CONCAT: 
43a5				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
43a5 48				db WORD_SYS_CORE+52             
43a6 58 44			dw .FIND            
43a8 07				db 6 + 1 
43a9 .. 00			db "CONCAT",0              
43b0				endm 
# End of macro CWHEAD
43b0			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
43b0			 
43b0			; TODO check string type 
43b0			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
43b0			 
43b0					if DEBUG_FORTH_WORDS_KEY 
43b0						DMARK "CON" 
43b0 f5				push af  
43b1 3a c5 43			ld a, (.dmark)  
43b4 32 77 fb			ld (debug_mark),a  
43b7 3a c6 43			ld a, (.dmark+1)  
43ba 32 78 fb			ld (debug_mark+1),a  
43bd 3a c7 43			ld a, (.dmark+2)  
43c0 32 79 fb			ld (debug_mark+2),a  
43c3 18 03			jr .pastdmark  
43c5 ..			.dmark: db "CON"  
43c8 f1			.pastdmark: pop af  
43c9			endm  
# End of macro DMARK
43c9						CALLMONITOR 
43c9 cd 97 16			call break_point_state  
43cc				endm  
# End of macro CALLMONITOR
43cc					endif 
43cc			 
43cc			 
43cc					FORTH_DSP_VALUE 
43cc cd 07 1e			call macro_forth_dsp_value 
43cf				endm 
# End of macro FORTH_DSP_VALUE
43cf e5					push hl   ; s2 
43d0			 
43d0					FORTH_DSP_POP 
43d0 cd d6 1e			call macro_forth_dsp_pop 
43d3				endm 
# End of macro FORTH_DSP_POP
43d3			 
43d3					FORTH_DSP_VALUE 
43d3 cd 07 1e			call macro_forth_dsp_value 
43d6				endm 
# End of macro FORTH_DSP_VALUE
43d6			 
43d6 e5					push hl   ; s1 
43d7			 
43d7					FORTH_DSP_POP 
43d7 cd d6 1e			call macro_forth_dsp_pop 
43da				endm 
# End of macro FORTH_DSP_POP
43da					 
43da			 
43da					; copy s1 
43da			 
43da				 
43da					; save ptr 
43da e1					pop hl  
43db e5					push hl 
43dc 3e 00				ld a, 0 
43de cd 72 11				call strlent 
43e1					;inc hl    ; zer0 
43e1 06 00				ld b, 0 
43e3 4d					ld c, l 
43e4 e1					pop hl		 
43e5 11 1d ee				ld de, scratch	 
43e8					if DEBUG_FORTH_WORDS 
43e8						DMARK "CO1" 
43e8 f5				push af  
43e9 3a fd 43			ld a, (.dmark)  
43ec 32 77 fb			ld (debug_mark),a  
43ef 3a fe 43			ld a, (.dmark+1)  
43f2 32 78 fb			ld (debug_mark+1),a  
43f5 3a ff 43			ld a, (.dmark+2)  
43f8 32 79 fb			ld (debug_mark+2),a  
43fb 18 03			jr .pastdmark  
43fd ..			.dmark: db "CO1"  
4400 f1			.pastdmark: pop af  
4401			endm  
# End of macro DMARK
4401						CALLMONITOR 
4401 cd 97 16			call break_point_state  
4404				endm  
# End of macro CALLMONITOR
4404					endif 
4404 ed b0				ldir 
4406			 
4406 e1					pop hl 
4407 e5					push hl 
4408 d5					push de 
4409			 
4409			 
4409 3e 00				ld a, 0 
440b cd 72 11				call strlent 
440e 23					inc hl    ; zer0 
440f 23					inc hl 
4410 06 00				ld b, 0 
4412 4d					ld c, l 
4413 d1					pop de 
4414 e1					pop hl		 
4415					if DEBUG_FORTH_WORDS 
4415						DMARK "CO2" 
4415 f5				push af  
4416 3a 2a 44			ld a, (.dmark)  
4419 32 77 fb			ld (debug_mark),a  
441c 3a 2b 44			ld a, (.dmark+1)  
441f 32 78 fb			ld (debug_mark+1),a  
4422 3a 2c 44			ld a, (.dmark+2)  
4425 32 79 fb			ld (debug_mark+2),a  
4428 18 03			jr .pastdmark  
442a ..			.dmark: db "CO2"  
442d f1			.pastdmark: pop af  
442e			endm  
# End of macro DMARK
442e						CALLMONITOR 
442e cd 97 16			call break_point_state  
4431				endm  
# End of macro CALLMONITOR
4431					endif 
4431 ed b0				ldir 
4433			 
4433			 
4433			 
4433 21 1d ee				ld hl, scratch 
4436					if DEBUG_FORTH_WORDS 
4436						DMARK "CO5" 
4436 f5				push af  
4437 3a 4b 44			ld a, (.dmark)  
443a 32 77 fb			ld (debug_mark),a  
443d 3a 4c 44			ld a, (.dmark+1)  
4440 32 78 fb			ld (debug_mark+1),a  
4443 3a 4d 44			ld a, (.dmark+2)  
4446 32 79 fb			ld (debug_mark+2),a  
4449 18 03			jr .pastdmark  
444b ..			.dmark: db "CO5"  
444e f1			.pastdmark: pop af  
444f			endm  
# End of macro DMARK
444f						CALLMONITOR 
444f cd 97 16			call break_point_state  
4452				endm  
# End of macro CALLMONITOR
4452					endif 
4452			 
4452 cd 95 1c				call forth_push_str 
4455			 
4455			 
4455			 
4455			 
4455				       NEXTW 
4455 c3 90 1f			jp macro_next 
4458				endm 
# End of macro NEXTW
4458			 
4458			 
4458			.FIND: 
4458				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4458 4b				db WORD_SYS_CORE+55             
4459 16 45			dw .LEN            
445b 05				db 4 + 1 
445c .. 00			db "FIND",0              
4461				endm 
# End of macro CWHEAD
4461			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4461			 
4461					if DEBUG_FORTH_WORDS_KEY 
4461						DMARK "FND" 
4461 f5				push af  
4462 3a 76 44			ld a, (.dmark)  
4465 32 77 fb			ld (debug_mark),a  
4468 3a 77 44			ld a, (.dmark+1)  
446b 32 78 fb			ld (debug_mark+1),a  
446e 3a 78 44			ld a, (.dmark+2)  
4471 32 79 fb			ld (debug_mark+2),a  
4474 18 03			jr .pastdmark  
4476 ..			.dmark: db "FND"  
4479 f1			.pastdmark: pop af  
447a			endm  
# End of macro DMARK
447a						CALLMONITOR 
447a cd 97 16			call break_point_state  
447d				endm  
# End of macro CALLMONITOR
447d					endif 
447d			 
447d			; TODO check string type 
447d					FORTH_DSP_VALUE 
447d cd 07 1e			call macro_forth_dsp_value 
4480				endm 
# End of macro FORTH_DSP_VALUE
4480			 
4480 e5					push hl    
4481 7e					ld a,(hl)    ; char to find   
4482			; TODO change char to substr 
4482			 
4482 f5					push af 
4483					 
4483			 
4483			 
4483					if DEBUG_FORTH_WORDS 
4483						DMARK "FN1" 
4483 f5				push af  
4484 3a 98 44			ld a, (.dmark)  
4487 32 77 fb			ld (debug_mark),a  
448a 3a 99 44			ld a, (.dmark+1)  
448d 32 78 fb			ld (debug_mark+1),a  
4490 3a 9a 44			ld a, (.dmark+2)  
4493 32 79 fb			ld (debug_mark+2),a  
4496 18 03			jr .pastdmark  
4498 ..			.dmark: db "FN1"  
449b f1			.pastdmark: pop af  
449c			endm  
# End of macro DMARK
449c						CALLMONITOR 
449c cd 97 16			call break_point_state  
449f				endm  
# End of macro CALLMONITOR
449f					endif 
449f			 
449f					FORTH_DSP_POP 
449f cd d6 1e			call macro_forth_dsp_pop 
44a2				endm 
# End of macro FORTH_DSP_POP
44a2			 
44a2					; string to search 
44a2			 
44a2					FORTH_DSP_VALUE 
44a2 cd 07 1e			call macro_forth_dsp_value 
44a5				endm 
# End of macro FORTH_DSP_VALUE
44a5			 
44a5 d1					pop de  ; d is char to find  
44a6			 
44a6					if DEBUG_FORTH_WORDS 
44a6						DMARK "FN2" 
44a6 f5				push af  
44a7 3a bb 44			ld a, (.dmark)  
44aa 32 77 fb			ld (debug_mark),a  
44ad 3a bc 44			ld a, (.dmark+1)  
44b0 32 78 fb			ld (debug_mark+1),a  
44b3 3a bd 44			ld a, (.dmark+2)  
44b6 32 79 fb			ld (debug_mark+2),a  
44b9 18 03			jr .pastdmark  
44bb ..			.dmark: db "FN2"  
44be f1			.pastdmark: pop af  
44bf			endm  
# End of macro DMARK
44bf						CALLMONITOR 
44bf cd 97 16			call break_point_state  
44c2				endm  
# End of macro CALLMONITOR
44c2					endif 
44c2					 
44c2 01 00 00				ld bc, 0 
44c5 7e			.findchar:      ld a,(hl) 
44c6 fe 00				cp 0   		 
44c8 28 27				jr z, .finddone     
44ca ba					cp d 
44cb 28 20				jr z, .foundchar 
44cd 03					inc bc 
44ce 23					inc hl 
44cf					if DEBUG_FORTH_WORDS 
44cf						DMARK "FN3" 
44cf f5				push af  
44d0 3a e4 44			ld a, (.dmark)  
44d3 32 77 fb			ld (debug_mark),a  
44d6 3a e5 44			ld a, (.dmark+1)  
44d9 32 78 fb			ld (debug_mark+1),a  
44dc 3a e6 44			ld a, (.dmark+2)  
44df 32 79 fb			ld (debug_mark+2),a  
44e2 18 03			jr .pastdmark  
44e4 ..			.dmark: db "FN3"  
44e7 f1			.pastdmark: pop af  
44e8			endm  
# End of macro DMARK
44e8						CALLMONITOR 
44e8 cd 97 16			call break_point_state  
44eb				endm  
# End of macro CALLMONITOR
44eb					endif 
44eb 18 d8				jr .findchar 
44ed			 
44ed			 
44ed c5			.foundchar:	push bc 
44ee e1					pop hl 
44ef 18 03				jr .findexit 
44f1			 
44f1			 
44f1							 
44f1			 
44f1			.finddone:     ; got to end of string with no find 
44f1 21 00 00				ld hl, 0 
44f4			.findexit: 
44f4			 
44f4					if DEBUG_FORTH_WORDS 
44f4						DMARK "FNd" 
44f4 f5				push af  
44f5 3a 09 45			ld a, (.dmark)  
44f8 32 77 fb			ld (debug_mark),a  
44fb 3a 0a 45			ld a, (.dmark+1)  
44fe 32 78 fb			ld (debug_mark+1),a  
4501 3a 0b 45			ld a, (.dmark+2)  
4504 32 79 fb			ld (debug_mark+2),a  
4507 18 03			jr .pastdmark  
4509 ..			.dmark: db "FNd"  
450c f1			.pastdmark: pop af  
450d			endm  
# End of macro DMARK
450d						CALLMONITOR 
450d cd 97 16			call break_point_state  
4510				endm  
# End of macro CALLMONITOR
4510					endif 
4510 cd 27 1c			call forth_push_numhl 
4513			 
4513				       NEXTW 
4513 c3 90 1f			jp macro_next 
4516				endm 
# End of macro NEXTW
4516			 
4516			.LEN: 
4516				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4516 4c				db WORD_SYS_CORE+56             
4517 4b 45			dw .CHAR            
4519 06				db 5 + 1 
451a .. 00			db "COUNT",0              
4520				endm 
# End of macro CWHEAD
4520			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4520			 
4520					if DEBUG_FORTH_WORDS_KEY 
4520						DMARK "CNT" 
4520 f5				push af  
4521 3a 35 45			ld a, (.dmark)  
4524 32 77 fb			ld (debug_mark),a  
4527 3a 36 45			ld a, (.dmark+1)  
452a 32 78 fb			ld (debug_mark+1),a  
452d 3a 37 45			ld a, (.dmark+2)  
4530 32 79 fb			ld (debug_mark+2),a  
4533 18 03			jr .pastdmark  
4535 ..			.dmark: db "CNT"  
4538 f1			.pastdmark: pop af  
4539			endm  
# End of macro DMARK
4539						CALLMONITOR 
4539 cd 97 16			call break_point_state  
453c				endm  
# End of macro CALLMONITOR
453c					endif 
453c			; TODO check string type 
453c					FORTH_DSP 
453c cd e4 1d			call macro_forth_dsp 
453f				endm 
# End of macro FORTH_DSP
453f					;v5FORTH_DSP_VALUE 
453f			 
453f 23					inc hl 
4540			 
4540 3e 00				ld a, 0 
4542 cd 72 11				call strlent 
4545			 
4545 cd 27 1c				call forth_push_numhl 
4548			 
4548			 
4548			 
4548				       NEXTW 
4548 c3 90 1f			jp macro_next 
454b				endm 
# End of macro NEXTW
454b			.CHAR: 
454b				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
454b 4d				db WORD_SYS_CORE+57             
454c 81 45			dw .ENDSTR            
454e 05				db 4 + 1 
454f .. 00			db "CHAR",0              
4554				endm 
# End of macro CWHEAD
4554			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4554					if DEBUG_FORTH_WORDS_KEY 
4554						DMARK "CHR" 
4554 f5				push af  
4555 3a 69 45			ld a, (.dmark)  
4558 32 77 fb			ld (debug_mark),a  
455b 3a 6a 45			ld a, (.dmark+1)  
455e 32 78 fb			ld (debug_mark+1),a  
4561 3a 6b 45			ld a, (.dmark+2)  
4564 32 79 fb			ld (debug_mark+2),a  
4567 18 03			jr .pastdmark  
4569 ..			.dmark: db "CHR"  
456c f1			.pastdmark: pop af  
456d			endm  
# End of macro DMARK
456d						CALLMONITOR 
456d cd 97 16			call break_point_state  
4570				endm  
# End of macro CALLMONITOR
4570					endif 
4570					FORTH_DSP 
4570 cd e4 1d			call macro_forth_dsp 
4573				endm 
# End of macro FORTH_DSP
4573					;v5 FORTH_DSP_VALUE 
4573 23					inc hl      ; now at start of numeric as string 
4574			 
4574			;		push hl 
4574			 
4574					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4574 cd d6 1e			call macro_forth_dsp_pop 
4577				endm 
# End of macro FORTH_DSP_POP
4577			 
4577			;		pop hl 
4577			 
4577					; push the content of a onto the stack as a value 
4577			 
4577 7e					ld a,(hl)   ; get char 
4578 26 00				ld h,0 
457a 6f					ld l,a 
457b cd 27 1c				call forth_push_numhl 
457e			 
457e				       NEXTW 
457e c3 90 1f			jp macro_next 
4581				endm 
# End of macro NEXTW
4581			 
4581			 
4581			 
4581			 
4581			.ENDSTR: 
4581			; eof 
4581			 
# End of file forth_words_str.asm
4581			include "forth_words_key.asm" 
4581			 
4581			; | ## Keyboard Words 
4581			 
4581			.KEY: 
4581				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4581 3e				db WORD_SYS_CORE+42             
4582 b1 45			dw .WAITK            
4584 04				db 3 + 1 
4585 .. 00			db "KEY",0              
4589				endm 
# End of macro CWHEAD
4589			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4589			 
4589					if DEBUG_FORTH_WORDS_KEY 
4589						DMARK "KEY" 
4589 f5				push af  
458a 3a 9e 45			ld a, (.dmark)  
458d 32 77 fb			ld (debug_mark),a  
4590 3a 9f 45			ld a, (.dmark+1)  
4593 32 78 fb			ld (debug_mark+1),a  
4596 3a a0 45			ld a, (.dmark+2)  
4599 32 79 fb			ld (debug_mark+2),a  
459c 18 03			jr .pastdmark  
459e ..			.dmark: db "KEY"  
45a1 f1			.pastdmark: pop af  
45a2			endm  
# End of macro DMARK
45a2						CALLMONITOR 
45a2 cd 97 16			call break_point_state  
45a5				endm  
# End of macro CALLMONITOR
45a5					endif 
45a5			; TODO currently waits 
45a5 cd af 68				call cin 
45a8					;call cin_wait 
45a8 6f					ld l, a 
45a9 26 00				ld h, 0 
45ab cd 27 1c				call forth_push_numhl 
45ae					NEXTW 
45ae c3 90 1f			jp macro_next 
45b1				endm 
# End of macro NEXTW
45b1			.WAITK: 
45b1				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
45b1 3f				db WORD_SYS_CORE+43             
45b2 e3 45			dw .ACCEPT            
45b4 06				db 5 + 1 
45b5 .. 00			db "WAITK",0              
45bb				endm 
# End of macro CWHEAD
45bb			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
45bb					if DEBUG_FORTH_WORDS_KEY 
45bb						DMARK "WAI" 
45bb f5				push af  
45bc 3a d0 45			ld a, (.dmark)  
45bf 32 77 fb			ld (debug_mark),a  
45c2 3a d1 45			ld a, (.dmark+1)  
45c5 32 78 fb			ld (debug_mark+1),a  
45c8 3a d2 45			ld a, (.dmark+2)  
45cb 32 79 fb			ld (debug_mark+2),a  
45ce 18 03			jr .pastdmark  
45d0 ..			.dmark: db "WAI"  
45d3 f1			.pastdmark: pop af  
45d4			endm  
# End of macro DMARK
45d4						CALLMONITOR 
45d4 cd 97 16			call break_point_state  
45d7				endm  
# End of macro CALLMONITOR
45d7					endif 
45d7 cd 9e 68				call cin_wait 
45da 6f					ld l, a 
45db 26 00				ld h, 0 
45dd cd 27 1c				call forth_push_numhl 
45e0					NEXTW 
45e0 c3 90 1f			jp macro_next 
45e3				endm 
# End of macro NEXTW
45e3			.ACCEPT: 
45e3				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
45e3 40				db WORD_SYS_CORE+44             
45e4 41 46			dw .EDIT            
45e6 07				db 6 + 1 
45e7 .. 00			db "ACCEPT",0              
45ee				endm 
# End of macro CWHEAD
45ee			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
45ee					; TODO crashes on push 
45ee					if DEBUG_FORTH_WORDS_KEY 
45ee						DMARK "ACC" 
45ee f5				push af  
45ef 3a 03 46			ld a, (.dmark)  
45f2 32 77 fb			ld (debug_mark),a  
45f5 3a 04 46			ld a, (.dmark+1)  
45f8 32 78 fb			ld (debug_mark+1),a  
45fb 3a 05 46			ld a, (.dmark+2)  
45fe 32 79 fb			ld (debug_mark+2),a  
4601 18 03			jr .pastdmark  
4603 ..			.dmark: db "ACC"  
4606 f1			.pastdmark: pop af  
4607			endm  
# End of macro DMARK
4607						CALLMONITOR 
4607 cd 97 16			call break_point_state  
460a				endm  
# End of macro CALLMONITOR
460a					endif 
460a 21 1b f0				ld hl, os_input 
460d 3e 00				ld a, 0 
460f 77					ld (hl),a 
4610 3a 46 f8				ld a,(f_cursor_ptr) 
4613 16 64				ld d, 100 
4615 0e 00				ld c, 0 
4617 1e 28				ld e, 40 
4619 cd 36 0d				call input_str 
461c					; TODO perhaps do a type check and wrap in quotes if not a number 
461c 21 1b f0				ld hl, os_input 
461f					if DEBUG_FORTH_WORDS 
461f						DMARK "AC1" 
461f f5				push af  
4620 3a 34 46			ld a, (.dmark)  
4623 32 77 fb			ld (debug_mark),a  
4626 3a 35 46			ld a, (.dmark+1)  
4629 32 78 fb			ld (debug_mark+1),a  
462c 3a 36 46			ld a, (.dmark+2)  
462f 32 79 fb			ld (debug_mark+2),a  
4632 18 03			jr .pastdmark  
4634 ..			.dmark: db "AC1"  
4637 f1			.pastdmark: pop af  
4638			endm  
# End of macro DMARK
4638						CALLMONITOR 
4638 cd 97 16			call break_point_state  
463b				endm  
# End of macro CALLMONITOR
463b					endif 
463b cd 95 1c				call forth_push_str 
463e					NEXTW 
463e c3 90 1f			jp macro_next 
4641				endm 
# End of macro NEXTW
4641			 
4641			.EDIT: 
4641				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4641 40				db WORD_SYS_CORE+44             
4642 ca 46			dw .ENDKEY            
4644 05				db 4 + 1 
4645 .. 00			db "EDIT",0              
464a				endm 
# End of macro CWHEAD
464a			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
464a			 
464a					; TODO does not copy from stack 
464a					if DEBUG_FORTH_WORDS_KEY 
464a						DMARK "EDT" 
464a f5				push af  
464b 3a 5f 46			ld a, (.dmark)  
464e 32 77 fb			ld (debug_mark),a  
4651 3a 60 46			ld a, (.dmark+1)  
4654 32 78 fb			ld (debug_mark+1),a  
4657 3a 61 46			ld a, (.dmark+2)  
465a 32 79 fb			ld (debug_mark+2),a  
465d 18 03			jr .pastdmark  
465f ..			.dmark: db "EDT"  
4662 f1			.pastdmark: pop af  
4663			endm  
# End of macro DMARK
4663						CALLMONITOR 
4663 cd 97 16			call break_point_state  
4666				endm  
# End of macro CALLMONITOR
4666					endif 
4666			 
4666					FORTH_DSP 
4666 cd e4 1d			call macro_forth_dsp 
4669				endm 
# End of macro FORTH_DSP
4669					;v5 FORTH_DSP_VALUE 
4669 23					inc hl    ; TODO do type check 
466a			 
466a e5					push hl 
466b 3e 00				ld a, 0 
466d cd 72 11				call strlent 
4670 23					inc hl 
4671			 
4671 06 00				ld b, 0 
4673 4d					ld c, l 
4674			 
4674 e1					pop hl 
4675 11 1b f0				ld de, os_input 
4678					if DEBUG_FORTH_WORDS_KEY 
4678						DMARK "EDc" 
4678 f5				push af  
4679 3a 8d 46			ld a, (.dmark)  
467c 32 77 fb			ld (debug_mark),a  
467f 3a 8e 46			ld a, (.dmark+1)  
4682 32 78 fb			ld (debug_mark+1),a  
4685 3a 8f 46			ld a, (.dmark+2)  
4688 32 79 fb			ld (debug_mark+2),a  
468b 18 03			jr .pastdmark  
468d ..			.dmark: db "EDc"  
4690 f1			.pastdmark: pop af  
4691			endm  
# End of macro DMARK
4691						CALLMONITOR 
4691 cd 97 16			call break_point_state  
4694				endm  
# End of macro CALLMONITOR
4694					endif 
4694 ed b0				ldir 
4696			 
4696			 
4696 21 1b f0				ld hl, os_input 
4699					;ld a, 0 
4699					;ld (hl),a 
4699 3a 46 f8				ld a,(f_cursor_ptr) 
469c 16 64				ld d, 100 
469e 0e 00				ld c, 0 
46a0 1e 28				ld e, 40 
46a2 cd 36 0d				call input_str 
46a5					; TODO perhaps do a type check and wrap in quotes if not a number 
46a5 21 1b f0				ld hl, os_input 
46a8					if DEBUG_FORTH_WORDS 
46a8						DMARK "ED1" 
46a8 f5				push af  
46a9 3a bd 46			ld a, (.dmark)  
46ac 32 77 fb			ld (debug_mark),a  
46af 3a be 46			ld a, (.dmark+1)  
46b2 32 78 fb			ld (debug_mark+1),a  
46b5 3a bf 46			ld a, (.dmark+2)  
46b8 32 79 fb			ld (debug_mark+2),a  
46bb 18 03			jr .pastdmark  
46bd ..			.dmark: db "ED1"  
46c0 f1			.pastdmark: pop af  
46c1			endm  
# End of macro DMARK
46c1						CALLMONITOR 
46c1 cd 97 16			call break_point_state  
46c4				endm  
# End of macro CALLMONITOR
46c4					endif 
46c4 cd 95 1c				call forth_push_str 
46c7					NEXTW 
46c7 c3 90 1f			jp macro_next 
46ca				endm 
# End of macro NEXTW
46ca			 
46ca			 
46ca			 
46ca			.ENDKEY: 
46ca			; eof 
46ca			 
# End of file forth_words_key.asm
46ca			 
46ca			if STORAGE_SE 
46ca			   	include "forth_words_storage.asm" 
46ca			 
46ca			; | ## Fixed Storage Words 
46ca			 
46ca			 
46ca			.BREAD: 
46ca			  
46ca				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
46ca 3a				db WORD_SYS_CORE+38             
46cb 43 47			dw .BWRITE            
46cd 06				db 5 + 1 
46ce .. 00			db "BREAD",0              
46d4				endm 
# End of macro CWHEAD
46d4			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
46d4				 
46d4					if DEBUG_FORTH_WORDS_KEY 
46d4						DMARK "BRD" 
46d4 f5				push af  
46d5 3a e9 46			ld a, (.dmark)  
46d8 32 77 fb			ld (debug_mark),a  
46db 3a ea 46			ld a, (.dmark+1)  
46de 32 78 fb			ld (debug_mark+1),a  
46e1 3a eb 46			ld a, (.dmark+2)  
46e4 32 79 fb			ld (debug_mark+2),a  
46e7 18 03			jr .pastdmark  
46e9 ..			.dmark: db "BRD"  
46ec f1			.pastdmark: pop af  
46ed			endm  
# End of macro DMARK
46ed						CALLMONITOR 
46ed cd 97 16			call break_point_state  
46f0				endm  
# End of macro CALLMONITOR
46f0					endif 
46f0			 
46f0				FORTH_DSP_VALUEHL 
46f0 cd 1e 1e			call macro_dsp_valuehl 
46f3				endm 
# End of macro FORTH_DSP_VALUEHL
46f3			 
46f3				FORTH_DSP_POP 
46f3 cd d6 1e			call macro_forth_dsp_pop 
46f6				endm 
# End of macro FORTH_DSP_POP
46f6			 
46f6				; calc block address 
46f6			 
46f6 eb				ex de, hl 
46f7 3e 40			ld a, STORE_BLOCK_PHY 
46f9 cd 8c 0c			call Mult16 
46fc			 
46fc			 
46fc 11 62 f8			ld de, store_page 
46ff			 
46ff					if DEBUG_FORTH_WORDS 
46ff						DMARK "BR1" 
46ff f5				push af  
4700 3a 14 47			ld a, (.dmark)  
4703 32 77 fb			ld (debug_mark),a  
4706 3a 15 47			ld a, (.dmark+1)  
4709 32 78 fb			ld (debug_mark+1),a  
470c 3a 16 47			ld a, (.dmark+2)  
470f 32 79 fb			ld (debug_mark+2),a  
4712 18 03			jr .pastdmark  
4714 ..			.dmark: db "BR1"  
4717 f1			.pastdmark: pop af  
4718			endm  
# End of macro DMARK
4718						CALLMONITOR 
4718 cd 97 16			call break_point_state  
471b				endm  
# End of macro CALLMONITOR
471b					endif 
471b			 
471b cd 0c 03			call storage_read_block 
471e			 
471e 21 64 f8		        ld hl, store_page+2 
4721					if DEBUG_FORTH_WORDS 
4721						DMARK "BR2" 
4721 f5				push af  
4722 3a 36 47			ld a, (.dmark)  
4725 32 77 fb			ld (debug_mark),a  
4728 3a 37 47			ld a, (.dmark+1)  
472b 32 78 fb			ld (debug_mark+1),a  
472e 3a 38 47			ld a, (.dmark+2)  
4731 32 79 fb			ld (debug_mark+2),a  
4734 18 03			jr .pastdmark  
4736 ..			.dmark: db "BR2"  
4739 f1			.pastdmark: pop af  
473a			endm  
# End of macro DMARK
473a						CALLMONITOR 
473a cd 97 16			call break_point_state  
473d				endm  
# End of macro CALLMONITOR
473d					endif 
473d cd 95 1c			call forth_push_str 
4740			 
4740			 
4740					NEXTW 
4740 c3 90 1f			jp macro_next 
4743				endm 
# End of macro NEXTW
4743			.BWRITE: 
4743				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4743 3a				db WORD_SYS_CORE+38             
4744 d8 47			dw .BUPD            
4746 07				db 6 + 1 
4747 .. 00			db "BWRITE",0              
474e				endm 
# End of macro CWHEAD
474e			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
474e			 
474e					if DEBUG_FORTH_WORDS_KEY 
474e						DMARK "BWR" 
474e f5				push af  
474f 3a 63 47			ld a, (.dmark)  
4752 32 77 fb			ld (debug_mark),a  
4755 3a 64 47			ld a, (.dmark+1)  
4758 32 78 fb			ld (debug_mark+1),a  
475b 3a 65 47			ld a, (.dmark+2)  
475e 32 79 fb			ld (debug_mark+2),a  
4761 18 03			jr .pastdmark  
4763 ..			.dmark: db "BWR"  
4766 f1			.pastdmark: pop af  
4767			endm  
# End of macro DMARK
4767						CALLMONITOR 
4767 cd 97 16			call break_point_state  
476a				endm  
# End of macro CALLMONITOR
476a					endif 
476a			 
476a				FORTH_DSP_VALUEHL 
476a cd 1e 1e			call macro_dsp_valuehl 
476d				endm 
# End of macro FORTH_DSP_VALUEHL
476d			 
476d				; calc block address 
476d			 
476d eb				ex de, hl 
476e 3e 40			ld a, STORE_BLOCK_PHY 
4770 cd 8c 0c			call Mult16 
4773			 
4773 e5				push hl         ; address 
4774			 
4774				FORTH_DSP_POP 
4774 cd d6 1e			call macro_forth_dsp_pop 
4777				endm 
# End of macro FORTH_DSP_POP
4777			 
4777				FORTH_DSP_VALUEHL 
4777 cd 1e 1e			call macro_dsp_valuehl 
477a				endm 
# End of macro FORTH_DSP_VALUEHL
477a			 
477a				FORTH_DSP_POP 
477a cd d6 1e			call macro_forth_dsp_pop 
477d				endm 
# End of macro FORTH_DSP_POP
477d			 
477d cd 18 0a			call storage_clear_page 
4780			 
4780				; copy string to store page 
4780			 
4780 e5				push hl     ; save string address 
4781			 
4781 3e 00			ld a, 0 
4783 cd 72 11			call strlent 
4786			 
4786 23				inc hl 
4787			 
4787 4d				ld c, l 
4788 06 00			ld b, 0 
478a			 
478a e1				pop hl 
478b 11 64 f8			ld de, store_page + 2 
478e					if DEBUG_FORTH_WORDS 
478e						DMARK "BW1" 
478e f5				push af  
478f 3a a3 47			ld a, (.dmark)  
4792 32 77 fb			ld (debug_mark),a  
4795 3a a4 47			ld a, (.dmark+1)  
4798 32 78 fb			ld (debug_mark+1),a  
479b 3a a5 47			ld a, (.dmark+2)  
479e 32 79 fb			ld (debug_mark+2),a  
47a1 18 03			jr .pastdmark  
47a3 ..			.dmark: db "BW1"  
47a6 f1			.pastdmark: pop af  
47a7			endm  
# End of macro DMARK
47a7						CALLMONITOR 
47a7 cd 97 16			call break_point_state  
47aa				endm  
# End of macro CALLMONITOR
47aa					endif 
47aa ed b0			ldir 
47ac			 
47ac			 
47ac				; poke the start of the block with flags to prevent high level file ops hitting the block 
47ac			 
47ac 21 ff ff			ld hl, $ffff 
47af			 
47af 22 62 f8			ld (store_page), hl	 
47b2				 
47b2 e1				pop hl    ; get address 
47b3 11 62 f8			ld de, store_page 
47b6			 
47b6					if DEBUG_FORTH_WORDS 
47b6						DMARK "BW2" 
47b6 f5				push af  
47b7 3a cb 47			ld a, (.dmark)  
47ba 32 77 fb			ld (debug_mark),a  
47bd 3a cc 47			ld a, (.dmark+1)  
47c0 32 78 fb			ld (debug_mark+1),a  
47c3 3a cd 47			ld a, (.dmark+2)  
47c6 32 79 fb			ld (debug_mark+2),a  
47c9 18 03			jr .pastdmark  
47cb ..			.dmark: db "BW2"  
47ce f1			.pastdmark: pop af  
47cf			endm  
# End of macro DMARK
47cf						CALLMONITOR 
47cf cd 97 16			call break_point_state  
47d2				endm  
# End of macro CALLMONITOR
47d2					endif 
47d2			 
47d2 cd 71 03			call storage_write_block 
47d5			 
47d5					NEXTW 
47d5 c3 90 1f			jp macro_next 
47d8				endm 
# End of macro NEXTW
47d8			 
47d8			.BUPD: 
47d8				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
47d8 3a				db WORD_SYS_CORE+38             
47d9 2e 48			dw .BYID            
47db 05				db 4 + 1 
47dc .. 00			db "BUPD",0              
47e1				endm 
# End of macro CWHEAD
47e1			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
47e1			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
47e1			; | | or completely different file system structure. 
47e1			 
47e1					if DEBUG_FORTH_WORDS_KEY 
47e1						DMARK "BUD" 
47e1 f5				push af  
47e2 3a f6 47			ld a, (.dmark)  
47e5 32 77 fb			ld (debug_mark),a  
47e8 3a f7 47			ld a, (.dmark+1)  
47eb 32 78 fb			ld (debug_mark+1),a  
47ee 3a f8 47			ld a, (.dmark+2)  
47f1 32 79 fb			ld (debug_mark+2),a  
47f4 18 03			jr .pastdmark  
47f6 ..			.dmark: db "BUD"  
47f9 f1			.pastdmark: pop af  
47fa			endm  
# End of macro DMARK
47fa						CALLMONITOR 
47fa cd 97 16			call break_point_state  
47fd				endm  
# End of macro CALLMONITOR
47fd					endif 
47fd			 
47fd				FORTH_DSP_VALUEHL 
47fd cd 1e 1e			call macro_dsp_valuehl 
4800				endm 
# End of macro FORTH_DSP_VALUEHL
4800			 
4800				; calc block address 
4800			 
4800 eb				ex de, hl 
4801 3e 40			ld a, STORE_BLOCK_PHY 
4803 cd 8c 0c			call Mult16 
4806			 
4806				FORTH_DSP_POP 
4806 cd d6 1e			call macro_forth_dsp_pop 
4809				endm 
# End of macro FORTH_DSP_POP
4809			 
4809			 
4809 11 62 f8			ld de, store_page 
480c			 
480c					if DEBUG_FORTH_WORDS 
480c						DMARK "BUe" 
480c f5				push af  
480d 3a 21 48			ld a, (.dmark)  
4810 32 77 fb			ld (debug_mark),a  
4813 3a 22 48			ld a, (.dmark+1)  
4816 32 78 fb			ld (debug_mark+1),a  
4819 3a 23 48			ld a, (.dmark+2)  
481c 32 79 fb			ld (debug_mark+2),a  
481f 18 03			jr .pastdmark  
4821 ..			.dmark: db "BUe"  
4824 f1			.pastdmark: pop af  
4825			endm  
# End of macro DMARK
4825						CALLMONITOR 
4825 cd 97 16			call break_point_state  
4828				endm  
# End of macro CALLMONITOR
4828					endif 
4828			 
4828 cd 71 03			call storage_write_block 
482b			 
482b					NEXTW 
482b c3 90 1f			jp macro_next 
482e				endm 
# End of macro NEXTW
482e			 
482e			.BYID: 
482e			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
482e			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
482e			; 
482e			;		 
482e			;		if DEBUG_FORTH_WORDS_KEY 
482e			;			DMARK "BYID" 
482e			;			CALLMONITOR 
482e			;		endif 
482e			; 
482e			;		; get direct address 
482e			; 
482e			;		FORTH_DSP_VALUEHL 
482e			; 
482e			;		FORTH_DSP_POP 
482e			; 
482e			;	; calc block address 
482e			; 
482e			;	ex de, hl 
482e			;	ld a, STORE_BLOCK_PHY 
482e			;	call Mult16 
482e			;	;	do BREAD with number as param 
482e			;	; push the file name	 
482e			;	ld de, store_page 
482e			;	call storage_read_block 
482e			 ;       ld hl, store_page+2 
482e			; 
482e			; 
482e			;		NEXTW 
482e			;.BYNAME: 
482e			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
482e			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
482e			;		NEXTW 
482e			; 
482e			.DIR: 
482e				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
482e 3a				db WORD_SYS_CORE+38             
482f 32 49			dw .SAVE            
4831 04				db 3 + 1 
4832 .. 00			db "DIR",0              
4836				endm 
# End of macro CWHEAD
4836			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4836			 
4836					if DEBUG_FORTH_WORDS_KEY 
4836						DMARK "DIR" 
4836 f5				push af  
4837 3a 4b 48			ld a, (.dmark)  
483a 32 77 fb			ld (debug_mark),a  
483d 3a 4c 48			ld a, (.dmark+1)  
4840 32 78 fb			ld (debug_mark+1),a  
4843 3a 4d 48			ld a, (.dmark+2)  
4846 32 79 fb			ld (debug_mark+2),a  
4849 18 03			jr .pastdmark  
484b ..			.dmark: db "DIR"  
484e f1			.pastdmark: pop af  
484f			endm  
# End of macro DMARK
484f						CALLMONITOR 
484f cd 97 16			call break_point_state  
4852				endm  
# End of macro CALLMONITOR
4852					endif 
4852 cd bd 03			call storage_get_block_0 
4855			 
4855 21 62 f8			ld hl, store_page     ; get current id count 
4858 46				ld b, (hl) 
4859 0e 00			ld c, 0    ; count of files   
485b					if DEBUG_FORTH_WORDS 
485b						DMARK "DI1" 
485b f5				push af  
485c 3a 70 48			ld a, (.dmark)  
485f 32 77 fb			ld (debug_mark),a  
4862 3a 71 48			ld a, (.dmark+1)  
4865 32 78 fb			ld (debug_mark+1),a  
4868 3a 72 48			ld a, (.dmark+2)  
486b 32 79 fb			ld (debug_mark+2),a  
486e 18 03			jr .pastdmark  
4870 ..			.dmark: db "DI1"  
4873 f1			.pastdmark: pop af  
4874			endm  
# End of macro DMARK
4874						CALLMONITOR 
4874 cd 97 16			call break_point_state  
4877				endm  
# End of macro CALLMONITOR
4877					endif 
4877			 
4877				; check for empty drive 
4877			 
4877 3e 00			ld a, 0 
4879 b8				cp b 
487a ca e8 48			jp z, .dirdone 
487d			 
487d				; for each of the current ids do a search for them and if found push to stack 
487d			 
487d c5			.diritem:	push bc 
487e 21 40 00				ld hl, STORE_BLOCK_PHY 
4881 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4883 58					ld e,b 
4884			 
4884			;		if DEBUG_FORTH_WORDS 
4884			;			DMARK "DI2" 
4884			;			CALLMONITOR 
4884			;		endif 
4884			 
4884 cd 2d 06				call storage_findnextid 
4887			 
4887			;		if DEBUG_FORTH_WORDS 
4887			;			DMARK "DI3" 
4887			;			CALLMONITOR 
4887			;		endif 
4887			 
4887					; if found hl will be non zero 
4887			 
4887 cd 32 0d				call ishlzero 
488a			;		ld a, l 
488a			;		add h 
488a			; 
488a			;		cp 0 
488a 28 59				jr z, .dirnotfound 
488c			 
488c					; increase count 
488c			 
488c c1					pop bc	 
488d 0c					inc c 
488e c5					push bc 
488f					 
488f			 
488f					; get file header and push the file name 
488f			 
488f 11 62 f8				ld de, store_page 
4892 cd 0c 03				call storage_read_block 
4895			 
4895					; push file id to stack 
4895				 
4895 3a 62 f8				ld a, (store_page) 
4898 26 00				ld h, 0 
489a 6f					ld l, a 
489b cd 27 1c				call forth_push_numhl 
489e			 
489e					; push extent count to stack  
489e				 
489e 3a 64 f8				ld a, (store_page+2) 
48a1 26 00				ld h, 0 
48a3 6f					ld l, a 
48a4 cd 27 1c				call forth_push_numhl 
48a7			 
48a7					; push file name 
48a7			 
48a7 21 65 f8				ld hl, store_page+3 
48aa					if DEBUG_FORTH_WORDS 
48aa						DMARK "DI5" 
48aa f5				push af  
48ab 3a bf 48			ld a, (.dmark)  
48ae 32 77 fb			ld (debug_mark),a  
48b1 3a c0 48			ld a, (.dmark+1)  
48b4 32 78 fb			ld (debug_mark+1),a  
48b7 3a c1 48			ld a, (.dmark+2)  
48ba 32 79 fb			ld (debug_mark+2),a  
48bd 18 03			jr .pastdmark  
48bf ..			.dmark: db "DI5"  
48c2 f1			.pastdmark: pop af  
48c3			endm  
# End of macro DMARK
48c3						CALLMONITOR 
48c3 cd 97 16			call break_point_state  
48c6				endm  
# End of macro CALLMONITOR
48c6					endif 
48c6 cd 95 1c				call forth_push_str 
48c9					if DEBUG_FORTH_WORDS 
48c9						DMARK "DI6" 
48c9 f5				push af  
48ca 3a de 48			ld a, (.dmark)  
48cd 32 77 fb			ld (debug_mark),a  
48d0 3a df 48			ld a, (.dmark+1)  
48d3 32 78 fb			ld (debug_mark+1),a  
48d6 3a e0 48			ld a, (.dmark+2)  
48d9 32 79 fb			ld (debug_mark+2),a  
48dc 18 03			jr .pastdmark  
48de ..			.dmark: db "DI6"  
48e1 f1			.pastdmark: pop af  
48e2			endm  
# End of macro DMARK
48e2						CALLMONITOR 
48e2 cd 97 16			call break_point_state  
48e5				endm  
# End of macro CALLMONITOR
48e5					endif 
48e5			.dirnotfound: 
48e5 c1					pop bc     
48e6 10 95				djnz .diritem 
48e8				 
48e8			.dirdone:	 
48e8					if DEBUG_FORTH_WORDS 
48e8						DMARK "DI7" 
48e8 f5				push af  
48e9 3a fd 48			ld a, (.dmark)  
48ec 32 77 fb			ld (debug_mark),a  
48ef 3a fe 48			ld a, (.dmark+1)  
48f2 32 78 fb			ld (debug_mark+1),a  
48f5 3a ff 48			ld a, (.dmark+2)  
48f8 32 79 fb			ld (debug_mark+2),a  
48fb 18 03			jr .pastdmark  
48fd ..			.dmark: db "DI7"  
4900 f1			.pastdmark: pop af  
4901			endm  
# End of macro DMARK
4901						CALLMONITOR 
4901 cd 97 16			call break_point_state  
4904				endm  
# End of macro CALLMONITOR
4904					endif 
4904			 
4904					; push a count of the dir items found 
4904			 
4904 26 00				ld h, 0 
4906 69					ld l, c 
4907 cd 27 1c				call forth_push_numhl 
490a			 
490a					; push the bank label 
490a			 
490a cd bd 03				call storage_get_block_0 
490d			 
490d				 
490d 21 65 f8		 		ld hl, store_page+3 
4910			 
4910					if DEBUG_FORTH_WORDS 
4910						DMARK "DI8" 
4910 f5				push af  
4911 3a 25 49			ld a, (.dmark)  
4914 32 77 fb			ld (debug_mark),a  
4917 3a 26 49			ld a, (.dmark+1)  
491a 32 78 fb			ld (debug_mark+1),a  
491d 3a 27 49			ld a, (.dmark+2)  
4920 32 79 fb			ld (debug_mark+2),a  
4923 18 03			jr .pastdmark  
4925 ..			.dmark: db "DI8"  
4928 f1			.pastdmark: pop af  
4929			endm  
# End of macro DMARK
4929						CALLMONITOR 
4929 cd 97 16			call break_point_state  
492c				endm  
# End of macro CALLMONITOR
492c					endif 
492c cd 95 1c				call forth_push_str 
492f			 
492f			 
492f				 
492f					NEXTW 
492f c3 90 1f			jp macro_next 
4932				endm 
# End of macro NEXTW
4932			.SAVE: 
4932			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4932			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4932			;		NEXTW 
4932			;.LOAD: 
4932			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4932			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4932			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4932			;; > > The LOAD command can not be used in any user words or compound lines. 
4932			; 
4932			;		; store_openext use it. If zero it is EOF 
4932			; 
4932			;		; read block from current stream id 
4932			;		; if the block does not contain zero term keep reading blocks until zero found 
4932			;		; push the block to stack 
4932			;		; save the block id to stream 
4932			; 
4932			; 
4932			;		FORTH_DSP_VALUEHL 
4932			; 
4932			;;		push hl 
4932			; 
4932			;	if DEBUG_STORESE 
4932			;		DMARK "LOA" 
4932			;		CALLMONITOR 
4932			;	endif 
4932			;		FORTH_DSP_POP 
4932			; 
4932			;;		pop hl 
4932			; 
4932			;		ld h, l 
4932			;		ld l, 0 
4932			; 
4932			;		push hl     ; stack holds current file id and extent to work with 
4932			; 
4932			; 
4932			;		ld de, store_page      ; get block zero of file 
4932			;	if DEBUG_STORESE 
4932			;		DMARK "LO0" 
4932			;		CALLMONITOR 
4932			;	endif 
4932			;		call storage_read 
4932			; 
4932			;		ld a, (store_page+2)    ; max extents for this file 
4932			;		ld  (store_openmaxext),a   ; get our limit 
4932			; 
4932			;	if DEBUG_STORESE 
4932			;		DMARK "LOE" 
4932			;		CALLMONITOR 
4932			;	endif 
4932			; 
4932			;; TODO dont know why max extents are not present 
4932			;;		cp 0 
4932			;;		jp z, .loadeof     ; dont read past eof 
4932			; 
4932			;;		ld a, 1   ; start from the head of the file 
4932			; 
4932			;.loadline:	pop hl 
4932			;		inc hl 
4932			;		ld  a, (store_openmaxext)   ; get our limit 
4932			;	if DEBUG_STORESE 
4932			;		DMARK "LOx" 
4932			;		CALLMONITOR 
4932			;	endif 
4932			;		inc a 
4932			;		cp l 
4932			;		jp z, .loadeof 
4932			;		push hl    ; save current extent 
4932			; 
4932			;		ld de, store_page 
4932			; 
4932			;	if DEBUG_STORESE 
4932			;		DMARK "LO1" 
4932			;		CALLMONITOR 
4932			;	endif 
4932			;		call storage_read 
4932			; 
4932			;	if DEBUG_STORESE 
4932			;		DMARK "LO2" 
4932			;		CALLMONITOR 
4932			;	endif 
4932			;	call ishlzero 
4932			;	ld a, l 
4932			;	add h 
4932			;	cp 0 
4932			;	jr z, .loadeof 
4932			; 
4932			;	; not eof so hl should point to data to exec 
4932			; 
4932			;	; will need to add the FORTH_END_BUFFER flag 
4932			 ; 
4932			;	ld hl, store_page+2 
4932			;	ld bc, 255 
4932			;	ld a, 0 
4932			;	cpir 
4932			;	if DEBUG_STORESE 
4932			;		DMARK "LOt" 
4932			;		CALLMONITOR 
4932			;	endif 
4932			;	dec hl 
4932			;	ld a, ' ' 
4932			;	ld (hl), a 
4932			;	inc hl 
4932			;	ld (hl), a 
4932			;	inc hl 
4932			;	ld (hl), a 
4932			;	inc hl 
4932			;	ld a, FORTH_END_BUFFER 
4932			;	ld (hl), a 
4932			; 
4932			;	; TODO handle more than a single block read 
4932			; 
4932			; 
4932			;	ld hl, store_page+2 
4932			; 
4932			;	ld (os_tok_ptr), hl 
4932			; 
4932			;	if DEBUG_STORESE 
4932			;		DMARK "LO3" 
4932			;		CALLMONITOR 
4932			;	endif 
4932			; 
4932			;	call forthparse 
4932			;	call forthexec 
4932			;	call forthexec_cleanup 
4932			; 
4932			;	; go to next extent 
4932			; 
4932			;	; get next block  or mark as eof 
4932			;	jp .loadline 
4932			; 
4932			; 
4932			; 
4932			;	       NEXTW 
4932			;.loadeof:	ld a, 0 
4932			;		ld (store_openext), a 
4932			; 
4932			;	if DEBUG_STORESE 
4932			;		DMARK "LOF" 
4932			;		CALLMONITOR 
4932			;	endif 
4932			;		ret 
4932			;		;NEXTW 
4932			;.BSAVE:   
4932			; 
4932			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4932			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4932			;		NEXTW 
4932			;.BLOAD: 
4932			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4932			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4932			;		NEXTW 
4932			;;;; counter gap 
4932			 
4932			 
4932			.SEO: 
4932				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4932 64				db WORD_SYS_CORE+80             
4933 51 49			dw .SEI            
4935 04				db 3 + 1 
4936 .. 00			db "SEO",0              
493a				endm 
# End of macro CWHEAD
493a			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
493a			 
493a					; get port 
493a			 
493a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
493a cd 1e 1e			call macro_dsp_valuehl 
493d				endm 
# End of macro FORTH_DSP_VALUEHL
493d			 
493d e5					push hl    ; u2 - byte 
493e			 
493e					; destroy value TOS 
493e			 
493e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
493e cd d6 1e			call macro_forth_dsp_pop 
4941				endm 
# End of macro FORTH_DSP_POP
4941			 
4941					; get byte to send 
4941			 
4941					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4941 cd 1e 1e			call macro_dsp_valuehl 
4944				endm 
# End of macro FORTH_DSP_VALUEHL
4944			 
4944 e5					push hl    ; u1 - addr 
4945			 
4945					; destroy value TOS 
4945			 
4945					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4945 cd d6 1e			call macro_forth_dsp_pop 
4948				endm 
# End of macro FORTH_DSP_POP
4948			 
4948					; one value on hl get other one back 
4948			 
4948 d1					pop de   ; u1 - byte 
4949			 
4949 e1					pop hl   ; u2 - addr 
494a			 
494a					; TODO Send SPI byte 
494a			 
494a			 
494a 7b					ld a, e 
494b cd ea 01				call se_writebyte 
494e			 
494e					 
494e			 
494e					NEXTW 
494e c3 90 1f			jp macro_next 
4951				endm 
# End of macro NEXTW
4951			 
4951			.SEI: 
4951				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4951 65				db WORD_SYS_CORE+81             
4952 6b 49			dw .SFREE            
4954 04				db 3 + 1 
4955 .. 00			db "SEI",0              
4959				endm 
# End of macro CWHEAD
4959			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4959			 
4959					; get port 
4959			 
4959					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4959 cd 1e 1e			call macro_dsp_valuehl 
495c				endm 
# End of macro FORTH_DSP_VALUEHL
495c			 
495c			;		push hl 
495c			 
495c					; destroy value TOS 
495c			 
495c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
495c cd d6 1e			call macro_forth_dsp_pop 
495f				endm 
# End of macro FORTH_DSP_POP
495f			 
495f					; one value on hl get other one back 
495f			 
495f			;		pop hl 
495f			 
495f			 
495f					; TODO Get SPI byte 
495f			 
495f cd 8c 02				call se_readbyte 
4962			 
4962 26 00				ld h, 0 
4964 6f					ld l, a 
4965 cd 27 1c				call forth_push_numhl 
4968			 
4968					NEXTW 
4968 c3 90 1f			jp macro_next 
496b				endm 
# End of macro NEXTW
496b			 
496b			.SFREE: 
496b				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
496b 67				db WORD_SYS_CORE+83             
496c 9a 49			dw .SIZE            
496e 06				db 5 + 1 
496f .. 00			db "FFREE",0              
4975				endm 
# End of macro CWHEAD
4975			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4975					if DEBUG_FORTH_WORDS_KEY 
4975						DMARK "FFR" 
4975 f5				push af  
4976 3a 8a 49			ld a, (.dmark)  
4979 32 77 fb			ld (debug_mark),a  
497c 3a 8b 49			ld a, (.dmark+1)  
497f 32 78 fb			ld (debug_mark+1),a  
4982 3a 8c 49			ld a, (.dmark+2)  
4985 32 79 fb			ld (debug_mark+2),a  
4988 18 03			jr .pastdmark  
498a ..			.dmark: db "FFR"  
498d f1			.pastdmark: pop af  
498e			endm  
# End of macro DMARK
498e						CALLMONITOR 
498e cd 97 16			call break_point_state  
4991				endm  
# End of macro CALLMONITOR
4991					endif 
4991			 
4991 cd c7 06				call storage_freeblocks 
4994			 
4994 cd 27 1c				call forth_push_numhl 
4997			 
4997				       NEXTW 
4997 c3 90 1f			jp macro_next 
499a				endm 
# End of macro NEXTW
499a			.SIZE: 
499a				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
499a 67				db WORD_SYS_CORE+83             
499b ce 49			dw .CREATE            
499d 05				db 4 + 1 
499e .. 00			db "SIZE",0              
49a3				endm 
# End of macro CWHEAD
49a3			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
49a3					if DEBUG_FORTH_WORDS_KEY 
49a3						DMARK "SIZ" 
49a3 f5				push af  
49a4 3a b8 49			ld a, (.dmark)  
49a7 32 77 fb			ld (debug_mark),a  
49aa 3a b9 49			ld a, (.dmark+1)  
49ad 32 78 fb			ld (debug_mark+1),a  
49b0 3a ba 49			ld a, (.dmark+2)  
49b3 32 79 fb			ld (debug_mark+2),a  
49b6 18 03			jr .pastdmark  
49b8 ..			.dmark: db "SIZ"  
49bb f1			.pastdmark: pop af  
49bc			endm  
# End of macro DMARK
49bc						CALLMONITOR 
49bc cd 97 16			call break_point_state  
49bf				endm  
# End of macro CALLMONITOR
49bf					endif 
49bf			 
49bf					FORTH_DSP_VALUEHL 
49bf cd 1e 1e			call macro_dsp_valuehl 
49c2				endm 
# End of macro FORTH_DSP_VALUEHL
49c2			;		push hl 
49c2					FORTH_DSP_POP 
49c2 cd d6 1e			call macro_forth_dsp_pop 
49c5				endm 
# End of macro FORTH_DSP_POP
49c5			;		pop hl 
49c5 cd 3b 03				call storage_file_size 
49c8			 
49c8 cd 27 1c				call forth_push_numhl 
49cb			  
49cb			 
49cb				       NEXTW 
49cb c3 90 1f			jp macro_next 
49ce				endm 
# End of macro NEXTW
49ce			 
49ce			.CREATE: 
49ce				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
49ce 68				db WORD_SYS_CORE+84             
49cf 3c 4a			dw .APPEND            
49d1 07				db 6 + 1 
49d2 .. 00			db "CREATE",0              
49d9				endm 
# End of macro CWHEAD
49d9			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
49d9			; | | e.g.  
49d9			; | | TestProgram CREATE 
49d9			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
49d9			; | |  
49d9			; | | Max file IDs are 255. 
49d9			; | |  
49d9					 
49d9					if DEBUG_FORTH_WORDS_KEY 
49d9						DMARK "CRT" 
49d9 f5				push af  
49da 3a ee 49			ld a, (.dmark)  
49dd 32 77 fb			ld (debug_mark),a  
49e0 3a ef 49			ld a, (.dmark+1)  
49e3 32 78 fb			ld (debug_mark+1),a  
49e6 3a f0 49			ld a, (.dmark+2)  
49e9 32 79 fb			ld (debug_mark+2),a  
49ec 18 03			jr .pastdmark  
49ee ..			.dmark: db "CRT"  
49f1 f1			.pastdmark: pop af  
49f2			endm  
# End of macro DMARK
49f2						CALLMONITOR 
49f2 cd 97 16			call break_point_state  
49f5				endm  
# End of macro CALLMONITOR
49f5					endif 
49f5			;		call storage_get_block_0 
49f5			 
49f5					; TODO pop hl 
49f5			 
49f5					;v5 FORTH_DSP_VALUE 
49f5					FORTH_DSP_VALUE 
49f5 cd 07 1e			call macro_forth_dsp_value 
49f8				endm 
# End of macro FORTH_DSP_VALUE
49f8			 
49f8				if DEBUG_STORESE 
49f8					DMARK "CR1" 
49f8 f5				push af  
49f9 3a 0d 4a			ld a, (.dmark)  
49fc 32 77 fb			ld (debug_mark),a  
49ff 3a 0e 4a			ld a, (.dmark+1)  
4a02 32 78 fb			ld (debug_mark+1),a  
4a05 3a 0f 4a			ld a, (.dmark+2)  
4a08 32 79 fb			ld (debug_mark+2),a  
4a0b 18 03			jr .pastdmark  
4a0d ..			.dmark: db "CR1"  
4a10 f1			.pastdmark: pop af  
4a11			endm  
# End of macro DMARK
4a11					CALLMONITOR 
4a11 cd 97 16			call break_point_state  
4a14				endm  
# End of macro CALLMONITOR
4a14				endif 
4a14			;		push hl 
4a14			;		FORTH_DSP_POP 
4a14			;		pop hl 
4a14			 
4a14			;		inc hl   ; move past the type marker 
4a14			 
4a14 cd fd 06				call storage_create 
4a17			 
4a17				if DEBUG_STORESE 
4a17					DMARK "CT1" 
4a17 f5				push af  
4a18 3a 2c 4a			ld a, (.dmark)  
4a1b 32 77 fb			ld (debug_mark),a  
4a1e 3a 2d 4a			ld a, (.dmark+1)  
4a21 32 78 fb			ld (debug_mark+1),a  
4a24 3a 2e 4a			ld a, (.dmark+2)  
4a27 32 79 fb			ld (debug_mark+2),a  
4a2a 18 03			jr .pastdmark  
4a2c ..			.dmark: db "CT1"  
4a2f f1			.pastdmark: pop af  
4a30			endm  
# End of macro DMARK
4a30					CALLMONITOR 
4a30 cd 97 16			call break_point_state  
4a33				endm  
# End of macro CALLMONITOR
4a33				endif 
4a33			;		push hl 
4a33					FORTH_DSP_POP 
4a33 cd d6 1e			call macro_forth_dsp_pop 
4a36				endm 
# End of macro FORTH_DSP_POP
4a36			;		pop hl 
4a36					; push file id to stack 
4a36 cd 27 1c				call forth_push_numhl 
4a39			 
4a39			 
4a39			 
4a39				       NEXTW 
4a39 c3 90 1f			jp macro_next 
4a3c				endm 
# End of macro NEXTW
4a3c			 
4a3c			.APPEND: 
4a3c				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4a3c 69				db WORD_SYS_CORE+85             
4a3d cd 4a			dw .SDEL            
4a3f 07				db 6 + 1 
4a40 .. 00			db "APPEND",0              
4a47				endm 
# End of macro CWHEAD
4a47			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4a47			; | | e.g. 
4a47			; | | Test CREATE      -> $01 
4a47			; | | "A string to add to file" $01 APPEND 
4a47			; | |  
4a47			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4a47					if DEBUG_FORTH_WORDS_KEY 
4a47						DMARK "APP" 
4a47 f5				push af  
4a48 3a 5c 4a			ld a, (.dmark)  
4a4b 32 77 fb			ld (debug_mark),a  
4a4e 3a 5d 4a			ld a, (.dmark+1)  
4a51 32 78 fb			ld (debug_mark+1),a  
4a54 3a 5e 4a			ld a, (.dmark+2)  
4a57 32 79 fb			ld (debug_mark+2),a  
4a5a 18 03			jr .pastdmark  
4a5c ..			.dmark: db "APP"  
4a5f f1			.pastdmark: pop af  
4a60			endm  
# End of macro DMARK
4a60						CALLMONITOR 
4a60 cd 97 16			call break_point_state  
4a63				endm  
# End of macro CALLMONITOR
4a63					endif 
4a63			 
4a63					FORTH_DSP_VALUEHL 
4a63 cd 1e 1e			call macro_dsp_valuehl 
4a66				endm 
# End of macro FORTH_DSP_VALUEHL
4a66 e5					push hl 	; save file id 
4a67			 
4a67				if DEBUG_STORESE 
4a67					DMARK "AP1" 
4a67 f5				push af  
4a68 3a 7c 4a			ld a, (.dmark)  
4a6b 32 77 fb			ld (debug_mark),a  
4a6e 3a 7d 4a			ld a, (.dmark+1)  
4a71 32 78 fb			ld (debug_mark+1),a  
4a74 3a 7e 4a			ld a, (.dmark+2)  
4a77 32 79 fb			ld (debug_mark+2),a  
4a7a 18 03			jr .pastdmark  
4a7c ..			.dmark: db "AP1"  
4a7f f1			.pastdmark: pop af  
4a80			endm  
# End of macro DMARK
4a80					CALLMONITOR 
4a80 cd 97 16			call break_point_state  
4a83				endm  
# End of macro CALLMONITOR
4a83				endif 
4a83					FORTH_DSP_POP 
4a83 cd d6 1e			call macro_forth_dsp_pop 
4a86				endm 
# End of macro FORTH_DSP_POP
4a86			 
4a86					FORTH_DSP_VALUEHL 
4a86 cd 1e 1e			call macro_dsp_valuehl 
4a89				endm 
# End of macro FORTH_DSP_VALUEHL
4a89					;v5 FORTH_DSP_VALUE 
4a89 e5					push hl 	; save ptr to string to save 
4a8a			 
4a8a				if DEBUG_STORESE 
4a8a					DMARK "AP1" 
4a8a f5				push af  
4a8b 3a 9f 4a			ld a, (.dmark)  
4a8e 32 77 fb			ld (debug_mark),a  
4a91 3a a0 4a			ld a, (.dmark+1)  
4a94 32 78 fb			ld (debug_mark+1),a  
4a97 3a a1 4a			ld a, (.dmark+2)  
4a9a 32 79 fb			ld (debug_mark+2),a  
4a9d 18 03			jr .pastdmark  
4a9f ..			.dmark: db "AP1"  
4aa2 f1			.pastdmark: pop af  
4aa3			endm  
# End of macro DMARK
4aa3					CALLMONITOR 
4aa3 cd 97 16			call break_point_state  
4aa6				endm  
# End of macro CALLMONITOR
4aa6				endif 
4aa6					FORTH_DSP_POP 
4aa6 cd d6 1e			call macro_forth_dsp_pop 
4aa9				endm 
# End of macro FORTH_DSP_POP
4aa9			 
4aa9 d1					pop de 
4aaa e1					pop hl 
4aab				if DEBUG_STORESE 
4aab					DMARK "AP2" 
4aab f5				push af  
4aac 3a c0 4a			ld a, (.dmark)  
4aaf 32 77 fb			ld (debug_mark),a  
4ab2 3a c1 4a			ld a, (.dmark+1)  
4ab5 32 78 fb			ld (debug_mark+1),a  
4ab8 3a c2 4a			ld a, (.dmark+2)  
4abb 32 79 fb			ld (debug_mark+2),a  
4abe 18 03			jr .pastdmark  
4ac0 ..			.dmark: db "AP2"  
4ac3 f1			.pastdmark: pop af  
4ac4			endm  
# End of macro DMARK
4ac4					CALLMONITOR 
4ac4 cd 97 16			call break_point_state  
4ac7				endm  
# End of macro CALLMONITOR
4ac7				endif 
4ac7					;inc de ; skip var type indicator 
4ac7			 
4ac7					; TODO how to append numerics???? 
4ac7			 
4ac7 cd d7 08				call storage_append		 
4aca			 
4aca				       NEXTW 
4aca c3 90 1f			jp macro_next 
4acd				endm 
# End of macro NEXTW
4acd			.SDEL: 
4acd				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4acd 6a				db WORD_SYS_CORE+86             
4ace 19 4b			dw .OPEN            
4ad0 05				db 4 + 1 
4ad1 .. 00			db "ERA",0              
4ad5				endm 
# End of macro CWHEAD
4ad5			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4ad5					FORTH_DSP_VALUEHL 
4ad5 cd 1e 1e			call macro_dsp_valuehl 
4ad8				endm 
# End of macro FORTH_DSP_VALUEHL
4ad8			;		push hl 	; save file id 
4ad8			 
4ad8					if DEBUG_FORTH_WORDS_KEY 
4ad8						DMARK "ERA" 
4ad8 f5				push af  
4ad9 3a ed 4a			ld a, (.dmark)  
4adc 32 77 fb			ld (debug_mark),a  
4adf 3a ee 4a			ld a, (.dmark+1)  
4ae2 32 78 fb			ld (debug_mark+1),a  
4ae5 3a ef 4a			ld a, (.dmark+2)  
4ae8 32 79 fb			ld (debug_mark+2),a  
4aeb 18 03			jr .pastdmark  
4aed ..			.dmark: db "ERA"  
4af0 f1			.pastdmark: pop af  
4af1			endm  
# End of macro DMARK
4af1						CALLMONITOR 
4af1 cd 97 16			call break_point_state  
4af4				endm  
# End of macro CALLMONITOR
4af4					endif 
4af4				if DEBUG_STORESE 
4af4					DMARK "ER1" 
4af4 f5				push af  
4af5 3a 09 4b			ld a, (.dmark)  
4af8 32 77 fb			ld (debug_mark),a  
4afb 3a 0a 4b			ld a, (.dmark+1)  
4afe 32 78 fb			ld (debug_mark+1),a  
4b01 3a 0b 4b			ld a, (.dmark+2)  
4b04 32 79 fb			ld (debug_mark+2),a  
4b07 18 03			jr .pastdmark  
4b09 ..			.dmark: db "ER1"  
4b0c f1			.pastdmark: pop af  
4b0d			endm  
# End of macro DMARK
4b0d					CALLMONITOR 
4b0d cd 97 16			call break_point_state  
4b10				endm  
# End of macro CALLMONITOR
4b10				endif 
4b10					FORTH_DSP_POP 
4b10 cd d6 1e			call macro_forth_dsp_pop 
4b13				endm 
# End of macro FORTH_DSP_POP
4b13			 
4b13			;		pop hl 
4b13			 
4b13 cd 4c 05				call storage_erase 
4b16				       NEXTW 
4b16 c3 90 1f			jp macro_next 
4b19				endm 
# End of macro NEXTW
4b19			 
4b19			.OPEN: 
4b19				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4b19 6b				db WORD_SYS_CORE+87             
4b1a a0 4b			dw .READ            
4b1c 05				db 4 + 1 
4b1d .. 00			db "OPEN",0              
4b22				endm 
# End of macro CWHEAD
4b22			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4b22			; | | e.g. 
4b22			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b22			 
4b22					if DEBUG_FORTH_WORDS_KEY 
4b22						DMARK "OPN" 
4b22 f5				push af  
4b23 3a 37 4b			ld a, (.dmark)  
4b26 32 77 fb			ld (debug_mark),a  
4b29 3a 38 4b			ld a, (.dmark+1)  
4b2c 32 78 fb			ld (debug_mark+1),a  
4b2f 3a 39 4b			ld a, (.dmark+2)  
4b32 32 79 fb			ld (debug_mark+2),a  
4b35 18 03			jr .pastdmark  
4b37 ..			.dmark: db "OPN"  
4b3a f1			.pastdmark: pop af  
4b3b			endm  
# End of macro DMARK
4b3b						CALLMONITOR 
4b3b cd 97 16			call break_point_state  
4b3e				endm  
# End of macro CALLMONITOR
4b3e					endif 
4b3e					; TODO handle multiple file opens 
4b3e			 
4b3e 3e 01			       	ld a, 1 
4b40 32 59 f8				ld (store_openext), a 
4b43			 
4b43					; get max extents for this file 
4b43				 
4b43								 
4b43					FORTH_DSP_VALUEHL 
4b43 cd 1e 1e			call macro_dsp_valuehl 
4b46				endm 
# End of macro FORTH_DSP_VALUEHL
4b46			 
4b46 65					ld h, l 
4b47 2e 00				ld l, 0 
4b49			 
4b49				if DEBUG_STORESE 
4b49					DMARK "OPN" 
4b49 f5				push af  
4b4a 3a 5e 4b			ld a, (.dmark)  
4b4d 32 77 fb			ld (debug_mark),a  
4b50 3a 5f 4b			ld a, (.dmark+1)  
4b53 32 78 fb			ld (debug_mark+1),a  
4b56 3a 60 4b			ld a, (.dmark+2)  
4b59 32 79 fb			ld (debug_mark+2),a  
4b5c 18 03			jr .pastdmark  
4b5e ..			.dmark: db "OPN"  
4b61 f1			.pastdmark: pop af  
4b62			endm  
# End of macro DMARK
4b62					CALLMONITOR 
4b62 cd 97 16			call break_point_state  
4b65				endm  
# End of macro CALLMONITOR
4b65				endif 
4b65			;		push hl 
4b65					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b65 cd d6 1e			call macro_forth_dsp_pop 
4b68				endm 
# End of macro FORTH_DSP_POP
4b68			;		pop hl 
4b68						 
4b68 11 62 f8				ld de, store_page      ; get block zero of file 
4b6b cd 51 08				call storage_read 
4b6e			 
4b6e			 
4b6e 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
4b71 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4b74					 
4b74				if DEBUG_STORESE 
4b74					DMARK "OPx" 
4b74 f5				push af  
4b75 3a 89 4b			ld a, (.dmark)  
4b78 32 77 fb			ld (debug_mark),a  
4b7b 3a 8a 4b			ld a, (.dmark+1)  
4b7e 32 78 fb			ld (debug_mark+1),a  
4b81 3a 8b 4b			ld a, (.dmark+2)  
4b84 32 79 fb			ld (debug_mark+2),a  
4b87 18 03			jr .pastdmark  
4b89 ..			.dmark: db "OPx"  
4b8c f1			.pastdmark: pop af  
4b8d			endm  
# End of macro DMARK
4b8d					CALLMONITOR 
4b8d cd 97 16			call break_point_state  
4b90				endm  
# End of macro CALLMONITOR
4b90				endif 
4b90 fe 00				cp 0 
4b92 20 03				jr nz, .skipopeneof 
4b94					; have opened an empty file 
4b94					 
4b94 32 59 f8				ld (store_openext), a 
4b97			 
4b97			.skipopeneof: 
4b97			 
4b97 6f					ld l, a 
4b98 26 00				ld h, 0 
4b9a cd 27 1c				call forth_push_numhl 
4b9d			 
4b9d			 
4b9d				       NEXTW 
4b9d c3 90 1f			jp macro_next 
4ba0				endm 
# End of macro NEXTW
4ba0			.READ: 
4ba0				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4ba0 6c				db WORD_SYS_CORE+88             
4ba1 e7 4c			dw .EOF            
4ba3 05				db 4 + 1 
4ba4 .. 00			db "READ",0              
4ba9				endm 
# End of macro CWHEAD
4ba9			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4ba9			; | | e.g. 
4ba9			; | | $01 OPEN $01 DO $01 READ . LOOP 
4ba9			 
4ba9					if DEBUG_FORTH_WORDS_KEY 
4ba9						DMARK "REA" 
4ba9 f5				push af  
4baa 3a be 4b			ld a, (.dmark)  
4bad 32 77 fb			ld (debug_mark),a  
4bb0 3a bf 4b			ld a, (.dmark+1)  
4bb3 32 78 fb			ld (debug_mark+1),a  
4bb6 3a c0 4b			ld a, (.dmark+2)  
4bb9 32 79 fb			ld (debug_mark+2),a  
4bbc 18 03			jr .pastdmark  
4bbe ..			.dmark: db "REA"  
4bc1 f1			.pastdmark: pop af  
4bc2			endm  
# End of macro DMARK
4bc2						CALLMONITOR 
4bc2 cd 97 16			call break_point_state  
4bc5				endm  
# End of macro CALLMONITOR
4bc5					endif 
4bc5					; store_openext use it. If zero it is EOF 
4bc5			 
4bc5					; read block from current stream id 
4bc5					; if the block does not contain zero term keep reading blocks until zero found 
4bc5					; push the block to stack 
4bc5					; save the block id to stream 
4bc5			 
4bc5			 
4bc5					FORTH_DSP_VALUEHL 
4bc5 cd 1e 1e			call macro_dsp_valuehl 
4bc8				endm 
# End of macro FORTH_DSP_VALUEHL
4bc8			 
4bc8			;		push hl 
4bc8			 
4bc8				if DEBUG_STORESE 
4bc8					DMARK "REA" 
4bc8 f5				push af  
4bc9 3a dd 4b			ld a, (.dmark)  
4bcc 32 77 fb			ld (debug_mark),a  
4bcf 3a de 4b			ld a, (.dmark+1)  
4bd2 32 78 fb			ld (debug_mark+1),a  
4bd5 3a df 4b			ld a, (.dmark+2)  
4bd8 32 79 fb			ld (debug_mark+2),a  
4bdb 18 03			jr .pastdmark  
4bdd ..			.dmark: db "REA"  
4be0 f1			.pastdmark: pop af  
4be1			endm  
# End of macro DMARK
4be1					CALLMONITOR 
4be1 cd 97 16			call break_point_state  
4be4				endm  
# End of macro CALLMONITOR
4be4				endif 
4be4					FORTH_DSP_POP 
4be4 cd d6 1e			call macro_forth_dsp_pop 
4be7				endm 
# End of macro FORTH_DSP_POP
4be7			 
4be7			;		pop hl 
4be7				 
4be7 65					ld h,l 
4be8			 
4be8 3a 59 f8				ld a, (store_openext) 
4beb 6f					ld l, a 
4bec					 
4bec fe 00				cp 0 
4bee ca b9 4c				jp z, .ateof     ; dont read past eof 
4bf1			 
4bf1			 
4bf1 11 62 f8				ld de, store_page 
4bf4				if DEBUG_STORESE 
4bf4					DMARK "RE1" 
4bf4 f5				push af  
4bf5 3a 09 4c			ld a, (.dmark)  
4bf8 32 77 fb			ld (debug_mark),a  
4bfb 3a 0a 4c			ld a, (.dmark+1)  
4bfe 32 78 fb			ld (debug_mark+1),a  
4c01 3a 0b 4c			ld a, (.dmark+2)  
4c04 32 79 fb			ld (debug_mark+2),a  
4c07 18 03			jr .pastdmark  
4c09 ..			.dmark: db "RE1"  
4c0c f1			.pastdmark: pop af  
4c0d			endm  
# End of macro DMARK
4c0d					CALLMONITOR 
4c0d cd 97 16			call break_point_state  
4c10				endm  
# End of macro CALLMONITOR
4c10				endif 
4c10 cd 51 08				call storage_read 
4c13			 
4c13				if DEBUG_STORESE 
4c13					DMARK "RE2" 
4c13 f5				push af  
4c14 3a 28 4c			ld a, (.dmark)  
4c17 32 77 fb			ld (debug_mark),a  
4c1a 3a 29 4c			ld a, (.dmark+1)  
4c1d 32 78 fb			ld (debug_mark+1),a  
4c20 3a 2a 4c			ld a, (.dmark+2)  
4c23 32 79 fb			ld (debug_mark+2),a  
4c26 18 03			jr .pastdmark  
4c28 ..			.dmark: db "RE2"  
4c2b f1			.pastdmark: pop af  
4c2c			endm  
# End of macro DMARK
4c2c					CALLMONITOR 
4c2c cd 97 16			call break_point_state  
4c2f				endm  
# End of macro CALLMONITOR
4c2f				endif 
4c2f cd 32 0d			call ishlzero 
4c32			;	ld a, l 
4c32			;	add h 
4c32			;	cp 0 
4c32 ca bf 4c			jp z, .readeof 
4c35			 
4c35				; not eof so hl should point to data to push to stack 
4c35			 
4c35				if DEBUG_STORESE 
4c35					DMARK "RE3" 
4c35 f5				push af  
4c36 3a 4a 4c			ld a, (.dmark)  
4c39 32 77 fb			ld (debug_mark),a  
4c3c 3a 4b 4c			ld a, (.dmark+1)  
4c3f 32 78 fb			ld (debug_mark+1),a  
4c42 3a 4c 4c			ld a, (.dmark+2)  
4c45 32 79 fb			ld (debug_mark+2),a  
4c48 18 03			jr .pastdmark  
4c4a ..			.dmark: db "RE3"  
4c4d f1			.pastdmark: pop af  
4c4e			endm  
# End of macro DMARK
4c4e					CALLMONITOR 
4c4e cd 97 16			call break_point_state  
4c51				endm  
# End of macro CALLMONITOR
4c51				endif 
4c51 cd 95 1c			call forth_push_str 
4c54			 
4c54				if DEBUG_STORESE 
4c54					DMARK "RE4" 
4c54 f5				push af  
4c55 3a 69 4c			ld a, (.dmark)  
4c58 32 77 fb			ld (debug_mark),a  
4c5b 3a 6a 4c			ld a, (.dmark+1)  
4c5e 32 78 fb			ld (debug_mark+1),a  
4c61 3a 6b 4c			ld a, (.dmark+2)  
4c64 32 79 fb			ld (debug_mark+2),a  
4c67 18 03			jr .pastdmark  
4c69 ..			.dmark: db "RE4"  
4c6c f1			.pastdmark: pop af  
4c6d			endm  
# End of macro DMARK
4c6d					CALLMONITOR 
4c6d cd 97 16			call break_point_state  
4c70				endm  
# End of macro CALLMONITOR
4c70				endif 
4c70				; get next block  or mark as eof 
4c70			 
4c70 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
4c73 4f				ld c, a	 
4c74 3a 59 f8			ld a, (store_openext) 
4c77			 
4c77				if DEBUG_STORESE 
4c77					DMARK "RE5" 
4c77 f5				push af  
4c78 3a 8c 4c			ld a, (.dmark)  
4c7b 32 77 fb			ld (debug_mark),a  
4c7e 3a 8d 4c			ld a, (.dmark+1)  
4c81 32 78 fb			ld (debug_mark+1),a  
4c84 3a 8e 4c			ld a, (.dmark+2)  
4c87 32 79 fb			ld (debug_mark+2),a  
4c8a 18 03			jr .pastdmark  
4c8c ..			.dmark: db "RE5"  
4c8f f1			.pastdmark: pop af  
4c90			endm  
# End of macro DMARK
4c90					CALLMONITOR 
4c90 cd 97 16			call break_point_state  
4c93				endm  
# End of macro CALLMONITOR
4c93				endif 
4c93 b9				cp c 
4c94 28 29			jr z, .readeof     ; at last extent 
4c96			 
4c96 3c					inc a 
4c97 32 59 f8				ld (store_openext), a 
4c9a			 
4c9a				if DEBUG_STORESE 
4c9a					DMARK "RE6" 
4c9a f5				push af  
4c9b 3a af 4c			ld a, (.dmark)  
4c9e 32 77 fb			ld (debug_mark),a  
4ca1 3a b0 4c			ld a, (.dmark+1)  
4ca4 32 78 fb			ld (debug_mark+1),a  
4ca7 3a b1 4c			ld a, (.dmark+2)  
4caa 32 79 fb			ld (debug_mark+2),a  
4cad 18 03			jr .pastdmark  
4caf ..			.dmark: db "RE6"  
4cb2 f1			.pastdmark: pop af  
4cb3			endm  
# End of macro DMARK
4cb3					CALLMONITOR 
4cb3 cd 97 16			call break_point_state  
4cb6				endm  
# End of macro CALLMONITOR
4cb6				endif 
4cb6			 
4cb6			 
4cb6				       NEXTW 
4cb6 c3 90 1f			jp macro_next 
4cb9				endm 
# End of macro NEXTW
4cb9			.ateof: 
4cb9 21 e3 4c				ld hl, .showeof 
4cbc cd 95 1c				call forth_push_str 
4cbf 3e 00		.readeof:	ld a, 0 
4cc1 32 59 f8				ld (store_openext), a 
4cc4			 
4cc4					 
4cc4				if DEBUG_STORESE 
4cc4					DMARK "REF" 
4cc4 f5				push af  
4cc5 3a d9 4c			ld a, (.dmark)  
4cc8 32 77 fb			ld (debug_mark),a  
4ccb 3a da 4c			ld a, (.dmark+1)  
4cce 32 78 fb			ld (debug_mark+1),a  
4cd1 3a db 4c			ld a, (.dmark+2)  
4cd4 32 79 fb			ld (debug_mark+2),a  
4cd7 18 03			jr .pastdmark  
4cd9 ..			.dmark: db "REF"  
4cdc f1			.pastdmark: pop af  
4cdd			endm  
# End of macro DMARK
4cdd					CALLMONITOR 
4cdd cd 97 16			call break_point_state  
4ce0				endm  
# End of macro CALLMONITOR
4ce0				endif 
4ce0				       NEXTW 
4ce0 c3 90 1f			jp macro_next 
4ce3				endm 
# End of macro NEXTW
4ce3			 
4ce3 .. 00		.showeof:   db "eof", 0 
4ce7			 
4ce7			 
4ce7			.EOF: 
4ce7				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4ce7 6d				db WORD_SYS_CORE+89             
4ce8 28 4d			dw .FORMAT            
4cea 04				db 3 + 1 
4ceb .. 00			db "EOF",0              
4cef				endm 
# End of macro CWHEAD
4cef			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4cef			; | | e.g. 
4cef			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4cef					; TODO if current block id for stream is zero then push true else false 
4cef			 
4cef					if DEBUG_FORTH_WORDS_KEY 
4cef						DMARK "EOF" 
4cef f5				push af  
4cf0 3a 04 4d			ld a, (.dmark)  
4cf3 32 77 fb			ld (debug_mark),a  
4cf6 3a 05 4d			ld a, (.dmark+1)  
4cf9 32 78 fb			ld (debug_mark+1),a  
4cfc 3a 06 4d			ld a, (.dmark+2)  
4cff 32 79 fb			ld (debug_mark+2),a  
4d02 18 03			jr .pastdmark  
4d04 ..			.dmark: db "EOF"  
4d07 f1			.pastdmark: pop af  
4d08			endm  
# End of macro DMARK
4d08						CALLMONITOR 
4d08 cd 97 16			call break_point_state  
4d0b				endm  
# End of macro CALLMONITOR
4d0b					endif 
4d0b			 
4d0b					; TODO handlue multiple file streams 
4d0b			 
4d0b					FORTH_DSP_POP     ; for now just get rid of stream id 
4d0b cd d6 1e			call macro_forth_dsp_pop 
4d0e				endm 
# End of macro FORTH_DSP_POP
4d0e			 
4d0e 2e 01				ld l, 1 
4d10 3a 58 f8				ld a, (store_openmaxext) 
4d13 fe 00				cp 0 
4d15 28 09				jr  z, .eofdone   ; empty file 
4d17 3a 59 f8				ld a, (store_openext) 
4d1a fe 00				cp 0 
4d1c 28 02				jr  z, .eofdone 
4d1e 2e 00				ld l, 0 
4d20 26 00		.eofdone:	ld h, 0 
4d22 cd 27 1c				call forth_push_numhl 
4d25			 
4d25			 
4d25				       NEXTW 
4d25 c3 90 1f			jp macro_next 
4d28				endm 
# End of macro NEXTW
4d28			 
4d28			.FORMAT: 
4d28				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4d28 6d				db WORD_SYS_CORE+89             
4d29 79 4d			dw .LABEL            
4d2b 07				db 6 + 1 
4d2c .. 00			db "FORMAT",0              
4d33				endm 
# End of macro CWHEAD
4d33			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4d33					; TODO if current block id for stream is zero then push true else false 
4d33				 
4d33				if DEBUG_STORESE 
4d33					DMARK "FOR" 
4d33 f5				push af  
4d34 3a 48 4d			ld a, (.dmark)  
4d37 32 77 fb			ld (debug_mark),a  
4d3a 3a 49 4d			ld a, (.dmark+1)  
4d3d 32 78 fb			ld (debug_mark+1),a  
4d40 3a 4a 4d			ld a, (.dmark+2)  
4d43 32 79 fb			ld (debug_mark+2),a  
4d46 18 03			jr .pastdmark  
4d48 ..			.dmark: db "FOR"  
4d4b f1			.pastdmark: pop af  
4d4c			endm  
# End of macro DMARK
4d4c					CALLMONITOR 
4d4c cd 97 16			call break_point_state  
4d4f				endm  
# End of macro CALLMONITOR
4d4f				endif 
4d4f					; Wipes the bank check flags to cause a reformat on next block 0 read 
4d4f			 
4d4f 21 01 00				ld hl, 1 
4d52 3e 00				ld a, 0 
4d54 cd ea 01				call se_writebyte 
4d57			 
4d57				if DEBUG_STORESE 
4d57					DMARK "FO0" 
4d57 f5				push af  
4d58 3a 6c 4d			ld a, (.dmark)  
4d5b 32 77 fb			ld (debug_mark),a  
4d5e 3a 6d 4d			ld a, (.dmark+1)  
4d61 32 78 fb			ld (debug_mark+1),a  
4d64 3a 6e 4d			ld a, (.dmark+2)  
4d67 32 79 fb			ld (debug_mark+2),a  
4d6a 18 03			jr .pastdmark  
4d6c ..			.dmark: db "FO0"  
4d6f f1			.pastdmark: pop af  
4d70			endm  
# End of macro DMARK
4d70					CALLMONITOR 
4d70 cd 97 16			call break_point_state  
4d73				endm  
# End of macro CALLMONITOR
4d73				endif 
4d73					; force bank init 
4d73			 
4d73 cd bd 03				call storage_get_block_0 
4d76					 
4d76				       NEXTW 
4d76 c3 90 1f			jp macro_next 
4d79				endm 
# End of macro NEXTW
4d79			.LABEL: 
4d79				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d79 6d				db WORD_SYS_CORE+89             
4d7a c7 4d			dw .STOREPAGE            
4d7c 06				db 5 + 1 
4d7d .. 00			db "LABEL",0              
4d83				endm 
# End of macro CWHEAD
4d83			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d83					; TODO test to see if bank is selected 
4d83				 
4d83					if DEBUG_FORTH_WORDS_KEY 
4d83						DMARK "LBL" 
4d83 f5				push af  
4d84 3a 98 4d			ld a, (.dmark)  
4d87 32 77 fb			ld (debug_mark),a  
4d8a 3a 99 4d			ld a, (.dmark+1)  
4d8d 32 78 fb			ld (debug_mark+1),a  
4d90 3a 9a 4d			ld a, (.dmark+2)  
4d93 32 79 fb			ld (debug_mark+2),a  
4d96 18 03			jr .pastdmark  
4d98 ..			.dmark: db "LBL"  
4d9b f1			.pastdmark: pop af  
4d9c			endm  
# End of macro DMARK
4d9c						CALLMONITOR 
4d9c cd 97 16			call break_point_state  
4d9f				endm  
# End of macro CALLMONITOR
4d9f					endif 
4d9f			;	if DEBUG_STORESE 
4d9f			;		DMARK "LBL" 
4d9f			;		CALLMONITOR 
4d9f			;	endif 
4d9f					FORTH_DSP_VALUEHL 
4d9f cd 1e 1e			call macro_dsp_valuehl 
4da2				endm 
# End of macro FORTH_DSP_VALUEHL
4da2					;v5FORTH_DSP_VALUE 
4da2					 
4da2			;		push hl 
4da2					FORTH_DSP_POP 
4da2 cd d6 1e			call macro_forth_dsp_pop 
4da5				endm 
# End of macro FORTH_DSP_POP
4da5			;		pop hl 
4da5			 
4da5			;v5		inc hl   ; move past the type marker 
4da5			 
4da5				if DEBUG_STORESE 
4da5					DMARK "LBl" 
4da5 f5				push af  
4da6 3a ba 4d			ld a, (.dmark)  
4da9 32 77 fb			ld (debug_mark),a  
4dac 3a bb 4d			ld a, (.dmark+1)  
4daf 32 78 fb			ld (debug_mark+1),a  
4db2 3a bc 4d			ld a, (.dmark+2)  
4db5 32 79 fb			ld (debug_mark+2),a  
4db8 18 03			jr .pastdmark  
4dba ..			.dmark: db "LBl"  
4dbd f1			.pastdmark: pop af  
4dbe			endm  
# End of macro DMARK
4dbe					CALLMONITOR 
4dbe cd 97 16			call break_point_state  
4dc1				endm  
# End of macro CALLMONITOR
4dc1				endif 
4dc1 cd e1 04				call storage_label 
4dc4			 
4dc4				       NEXTW 
4dc4 c3 90 1f			jp macro_next 
4dc7				endm 
# End of macro NEXTW
4dc7			.STOREPAGE: 
4dc7				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4dc7 6d				db WORD_SYS_CORE+89             
4dc8 fa 4d			dw .LABELS            
4dca 0a				db 9 + 1 
4dcb .. 00			db "STOREPAGE",0              
4dd5				endm 
# End of macro CWHEAD
4dd5			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4dd5					; TODO test to see if bank is selected 
4dd5				 
4dd5					if DEBUG_FORTH_WORDS_KEY 
4dd5						DMARK "STP" 
4dd5 f5				push af  
4dd6 3a ea 4d			ld a, (.dmark)  
4dd9 32 77 fb			ld (debug_mark),a  
4ddc 3a eb 4d			ld a, (.dmark+1)  
4ddf 32 78 fb			ld (debug_mark+1),a  
4de2 3a ec 4d			ld a, (.dmark+2)  
4de5 32 79 fb			ld (debug_mark+2),a  
4de8 18 03			jr .pastdmark  
4dea ..			.dmark: db "STP"  
4ded f1			.pastdmark: pop af  
4dee			endm  
# End of macro DMARK
4dee						CALLMONITOR 
4dee cd 97 16			call break_point_state  
4df1				endm  
# End of macro CALLMONITOR
4df1					endif 
4df1			;	if DEBUG_STORESE 
4df1			;		DMARK "STP" 
4df1			;		CALLMONITOR 
4df1			;	endif 
4df1			 
4df1 21 62 f8			ld hl, store_page 
4df4 cd 27 1c			call forth_push_numhl 
4df7			 
4df7			 
4df7				       NEXTW 
4df7 c3 90 1f			jp macro_next 
4dfa				endm 
# End of macro NEXTW
4dfa			.LABELS: 
4dfa				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4dfa 6d				db WORD_SYS_CORE+89             
4dfb 84 4e			dw .ENDSTORAGE            
4dfd 07				db 6 + 1 
4dfe .. 00			db "LABELS",0              
4e05				endm 
# End of macro CWHEAD
4e05			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4e05					;  
4e05			 
4e05					; save the current device selected to restore afterwards 
4e05				 
4e05 3a 48 f8				ld a, (spi_device) 
4e08 f5					push af 
4e09			 
4e09			 
4e09					; run through each of the banks 
4e09			 
4e09 21 01 00				ld hl, 1 
4e0c cd 27 1c				call forth_push_numhl 
4e0f 3e ff				ld a, SPI_CE_HIGH 
4e11 cb 87				res SPI_CE0, a 
4e13 32 48 f8				ld (spi_device), a 
4e16 cd bd 03				call storage_get_block_0 
4e19 21 65 f8				ld hl, store_page+3 
4e1c cd 95 1c				call forth_push_str 
4e1f			 
4e1f					 
4e1f 21 02 00				ld hl, 2 
4e22 cd 27 1c				call forth_push_numhl 
4e25 3e ff				ld a, SPI_CE_HIGH 
4e27 cb 8f				res SPI_CE1, a 
4e29 32 48 f8				ld (spi_device), a 
4e2c cd bd 03				call storage_get_block_0 
4e2f 21 65 f8				ld hl, store_page+3 
4e32 cd 95 1c				call forth_push_str 
4e35			 
4e35					 
4e35 21 03 00				ld hl, 3 
4e38 cd 27 1c				call forth_push_numhl 
4e3b 3e ff				ld a, SPI_CE_HIGH 
4e3d cb 97				res SPI_CE2, a 
4e3f 32 48 f8				ld (spi_device), a 
4e42 cd bd 03				call storage_get_block_0 
4e45 21 65 f8				ld hl, store_page+3 
4e48 cd 95 1c				call forth_push_str 
4e4b			 
4e4b			 
4e4b 21 04 00				ld hl, 4 
4e4e cd 27 1c				call forth_push_numhl 
4e51 3e ff				ld a, SPI_CE_HIGH 
4e53 cb 9f				res SPI_CE3, a 
4e55 32 48 f8				ld (spi_device), a 
4e58 cd bd 03				call storage_get_block_0 
4e5b 21 65 f8				ld hl, store_page+3 
4e5e cd 95 1c				call forth_push_str 
4e61			 
4e61					 
4e61			 
4e61 21 05 00				ld hl, 5 
4e64 cd 27 1c				call forth_push_numhl 
4e67 3e ff				ld a, SPI_CE_HIGH 
4e69 cb a7				res SPI_CE4, a 
4e6b 32 48 f8				ld (spi_device), a 
4e6e cd bd 03				call storage_get_block_0 
4e71 21 65 f8				ld hl, store_page+3 
4e74 cd 95 1c				call forth_push_str 
4e77			 
4e77					 
4e77					; push fixed count of storage devices (on board) for now 
4e77			 
4e77 21 05 00				ld hl, 5 
4e7a cd 27 1c				call forth_push_numhl 
4e7d			 
4e7d					; restore selected device  
4e7d				 
4e7d f1					pop af 
4e7e 32 48 f8				ld (spi_device), a 
4e81			 
4e81				       NEXTW 
4e81 c3 90 1f			jp macro_next 
4e84				endm 
# End of macro NEXTW
4e84			 
4e84			.ENDSTORAGE: 
4e84			; eof 
# End of file forth_words_storage.asm
4e84			endif 
4e84				include "forth_words_device.asm" 
4e84			; Device related words 
4e84			 
4e84			; | ## Device Words 
4e84			 
4e84			if SOUND_ENABLE 
4e84			.NOTE: 
4e84				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e84 33				db WORD_SYS_CORE+31             
4e85 ac 4e			dw .AFTERSOUND            
4e87 05				db 4 + 1 
4e88 .. 00			db "NOTE",0              
4e8d				endm 
# End of macro CWHEAD
4e8d			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e8d					if DEBUG_FORTH_WORDS_KEY 
4e8d						DMARK "NTE" 
4e8d f5				push af  
4e8e 3a a2 4e			ld a, (.dmark)  
4e91 32 77 fb			ld (debug_mark),a  
4e94 3a a3 4e			ld a, (.dmark+1)  
4e97 32 78 fb			ld (debug_mark+1),a  
4e9a 3a a4 4e			ld a, (.dmark+2)  
4e9d 32 79 fb			ld (debug_mark+2),a  
4ea0 18 03			jr .pastdmark  
4ea2 ..			.dmark: db "NTE"  
4ea5 f1			.pastdmark: pop af  
4ea6			endm  
# End of macro DMARK
4ea6						CALLMONITOR 
4ea6 cd 97 16			call break_point_state  
4ea9				endm  
# End of macro CALLMONITOR
4ea9					endif 
4ea9			 
4ea9				 
4ea9			 
4ea9					NEXTW 
4ea9 c3 90 1f			jp macro_next 
4eac				endm 
# End of macro NEXTW
4eac			.AFTERSOUND: 
4eac			endif 
4eac			 
4eac			 
4eac			USE_GPIO: equ 0 
4eac			 
4eac			if USE_GPIO 
4eac			.GP1: 
4eac				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4eac			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4eac					NEXTW 
4eac			.GP2: 
4eac				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4eac			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4eac			 
4eac					NEXTW 
4eac			 
4eac			.GP3: 
4eac				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4eac			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4eac			 
4eac					NEXTW 
4eac			 
4eac			.GP4: 
4eac				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4eac			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4eac			 
4eac					NEXTW 
4eac			.SIN: 
4eac			 
4eac			 
4eac			endif 
4eac			 
4eac			 
4eac				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4eac 33				db WORD_SYS_CORE+31             
4ead e1 4e			dw .SOUT            
4eaf 03				db 2 + 1 
4eb0 .. 00			db "IN",0              
4eb3				endm 
# End of macro CWHEAD
4eb3			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4eb3					if DEBUG_FORTH_WORDS_KEY 
4eb3						DMARK "IN." 
4eb3 f5				push af  
4eb4 3a c8 4e			ld a, (.dmark)  
4eb7 32 77 fb			ld (debug_mark),a  
4eba 3a c9 4e			ld a, (.dmark+1)  
4ebd 32 78 fb			ld (debug_mark+1),a  
4ec0 3a ca 4e			ld a, (.dmark+2)  
4ec3 32 79 fb			ld (debug_mark+2),a  
4ec6 18 03			jr .pastdmark  
4ec8 ..			.dmark: db "IN."  
4ecb f1			.pastdmark: pop af  
4ecc			endm  
# End of macro DMARK
4ecc						CALLMONITOR 
4ecc cd 97 16			call break_point_state  
4ecf				endm  
# End of macro CALLMONITOR
4ecf					endif 
4ecf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ecf cd 1e 1e			call macro_dsp_valuehl 
4ed2				endm 
# End of macro FORTH_DSP_VALUEHL
4ed2			 
4ed2 e5					push hl 
4ed3			 
4ed3					; destroy value TOS 
4ed3			 
4ed3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ed3 cd d6 1e			call macro_forth_dsp_pop 
4ed6				endm 
# End of macro FORTH_DSP_POP
4ed6			 
4ed6					; one value on hl get other one back 
4ed6			 
4ed6 c1					pop bc 
4ed7			 
4ed7					; do the sub 
4ed7			;		ex de, hl 
4ed7			 
4ed7 ed 68				in l,(c) 
4ed9			 
4ed9					; save it 
4ed9			 
4ed9 26 00				ld h,0 
4edb			 
4edb					; TODO push value back onto stack for another op etc 
4edb			 
4edb cd 27 1c				call forth_push_numhl 
4ede					NEXTW 
4ede c3 90 1f			jp macro_next 
4ee1				endm 
# End of macro NEXTW
4ee1			.SOUT: 
4ee1				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4ee1 34				db WORD_SYS_CORE+32             
4ee2 34 4f			dw .SPIO            
4ee4 04				db 3 + 1 
4ee5 .. 00			db "OUT",0              
4ee9				endm 
# End of macro CWHEAD
4ee9			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4ee9					if DEBUG_FORTH_WORDS_KEY 
4ee9						DMARK "OUT" 
4ee9 f5				push af  
4eea 3a fe 4e			ld a, (.dmark)  
4eed 32 77 fb			ld (debug_mark),a  
4ef0 3a ff 4e			ld a, (.dmark+1)  
4ef3 32 78 fb			ld (debug_mark+1),a  
4ef6 3a 00 4f			ld a, (.dmark+2)  
4ef9 32 79 fb			ld (debug_mark+2),a  
4efc 18 03			jr .pastdmark  
4efe ..			.dmark: db "OUT"  
4f01 f1			.pastdmark: pop af  
4f02			endm  
# End of macro DMARK
4f02						CALLMONITOR 
4f02 cd 97 16			call break_point_state  
4f05				endm  
# End of macro CALLMONITOR
4f05					endif 
4f05			 
4f05					; get port 
4f05			 
4f05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f05 cd 1e 1e			call macro_dsp_valuehl 
4f08				endm 
# End of macro FORTH_DSP_VALUEHL
4f08			 
4f08 e5					push hl 
4f09			 
4f09					; destroy value TOS 
4f09			 
4f09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f09 cd d6 1e			call macro_forth_dsp_pop 
4f0c				endm 
# End of macro FORTH_DSP_POP
4f0c			 
4f0c					; get byte to send 
4f0c			 
4f0c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f0c cd 1e 1e			call macro_dsp_valuehl 
4f0f				endm 
# End of macro FORTH_DSP_VALUEHL
4f0f			 
4f0f			;		push hl 
4f0f			 
4f0f					; destroy value TOS 
4f0f			 
4f0f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f0f cd d6 1e			call macro_forth_dsp_pop 
4f12				endm 
# End of macro FORTH_DSP_POP
4f12			 
4f12					; one value on hl get other one back 
4f12			 
4f12			;		pop hl 
4f12			 
4f12 c1					pop bc 
4f13			 
4f13					if DEBUG_FORTH_WORDS 
4f13						DMARK "OUT" 
4f13 f5				push af  
4f14 3a 28 4f			ld a, (.dmark)  
4f17 32 77 fb			ld (debug_mark),a  
4f1a 3a 29 4f			ld a, (.dmark+1)  
4f1d 32 78 fb			ld (debug_mark+1),a  
4f20 3a 2a 4f			ld a, (.dmark+2)  
4f23 32 79 fb			ld (debug_mark+2),a  
4f26 18 03			jr .pastdmark  
4f28 ..			.dmark: db "OUT"  
4f2b f1			.pastdmark: pop af  
4f2c			endm  
# End of macro DMARK
4f2c						CALLMONITOR 
4f2c cd 97 16			call break_point_state  
4f2f				endm  
# End of macro CALLMONITOR
4f2f					endif 
4f2f			 
4f2f ed 69				out (c), l 
4f31			 
4f31					NEXTW 
4f31 c3 90 1f			jp macro_next 
4f34				endm 
# End of macro NEXTW
4f34			 
4f34			 
4f34			.SPIO: 
4f34			 
4f34			if STORAGE_SE 
4f34				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4f34 51				db WORD_SYS_CORE+61             
4f35 45 4f			dw .SPICEH            
4f37 07				db 6 + 1 
4f38 .. 00			db "SPICEL",0              
4f3f				endm 
# End of macro CWHEAD
4f3f			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4f3f			 
4f3f cd 98 01				call spi_ce_low 
4f42			    NEXTW 
4f42 c3 90 1f			jp macro_next 
4f45				endm 
# End of macro NEXTW
4f45			 
4f45			.SPICEH: 
4f45				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4f45 51				db WORD_SYS_CORE+61             
4f46 56 4f			dw .SPIOb            
4f48 07				db 6 + 1 
4f49 .. 00			db "SPICEH",0              
4f50				endm 
# End of macro CWHEAD
4f50			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4f50			 
4f50 cd 87 01				call spi_ce_high 
4f53			    NEXTW 
4f53 c3 90 1f			jp macro_next 
4f56				endm 
# End of macro NEXTW
4f56			 
4f56			 
4f56			.SPIOb: 
4f56			 
4f56				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4f56 51				db WORD_SYS_CORE+61             
4f57 6c 4f			dw .SPII            
4f59 05				db 4 + 1 
4f5a .. 00			db "SPIO",0              
4f5f				endm 
# End of macro CWHEAD
4f5f			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4f5f			 
4f5f					; get port 
4f5f			 
4f5f			 
4f5f					; get byte to send 
4f5f			 
4f5f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f5f cd 1e 1e			call macro_dsp_valuehl 
4f62				endm 
# End of macro FORTH_DSP_VALUEHL
4f62			 
4f62			;		push hl    ; u1  
4f62			 
4f62					; destroy value TOS 
4f62			 
4f62					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f62 cd d6 1e			call macro_forth_dsp_pop 
4f65				endm 
# End of macro FORTH_DSP_POP
4f65			 
4f65					; one value on hl get other one back 
4f65			 
4f65			;		pop hl   ; u2 - addr 
4f65			 
4f65					; TODO Send SPI byte 
4f65			 
4f65 7d					ld a, l 
4f66 cd bc 00				call spi_send_byte 
4f69			 
4f69					NEXTW 
4f69 c3 90 1f			jp macro_next 
4f6c				endm 
# End of macro NEXTW
4f6c			 
4f6c			.SPII: 
4f6c				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4f6c 52				db WORD_SYS_CORE+62             
4f6d 81 4f			dw .SESEL            
4f6f 06				db 5 + 1 
4f70 .. 00			db "SPII",0              
4f75				endm 
# End of macro CWHEAD
4f75			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4f75			 
4f75					; TODO Get SPI byte 
4f75			 
4f75 cd dd 00				call spi_read_byte 
4f78			 
4f78 26 00				ld h, 0 
4f7a 6f					ld l, a 
4f7b cd 27 1c				call forth_push_numhl 
4f7e			 
4f7e					NEXTW 
4f7e c3 90 1f			jp macro_next 
4f81				endm 
# End of macro NEXTW
4f81			 
4f81			 
4f81			 
4f81			.SESEL: 
4f81				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f81 66				db WORD_SYS_CORE+82             
4f82 25 50			dw .CARTDEV            
4f84 05				db 4 + 1 
4f85 .. 00			db "BANK",0              
4f8a				endm 
# End of macro CWHEAD
4f8a			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f8a					if DEBUG_FORTH_WORDS_KEY 
4f8a						DMARK "BNK" 
4f8a f5				push af  
4f8b 3a 9f 4f			ld a, (.dmark)  
4f8e 32 77 fb			ld (debug_mark),a  
4f91 3a a0 4f			ld a, (.dmark+1)  
4f94 32 78 fb			ld (debug_mark+1),a  
4f97 3a a1 4f			ld a, (.dmark+2)  
4f9a 32 79 fb			ld (debug_mark+2),a  
4f9d 18 03			jr .pastdmark  
4f9f ..			.dmark: db "BNK"  
4fa2 f1			.pastdmark: pop af  
4fa3			endm  
# End of macro DMARK
4fa3						CALLMONITOR 
4fa3 cd 97 16			call break_point_state  
4fa6				endm  
# End of macro CALLMONITOR
4fa6					endif 
4fa6			 
4fa6 3e ff				ld a, 255 
4fa8 32 4b f8				ld (spi_cartdev), a 
4fab			 
4fab					; get bank 
4fab			 
4fab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fab cd 1e 1e			call macro_dsp_valuehl 
4fae				endm 
# End of macro FORTH_DSP_VALUEHL
4fae			 
4fae			;		push hl 
4fae			 
4fae					; destroy value TOS 
4fae			 
4fae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fae cd d6 1e			call macro_forth_dsp_pop 
4fb1				endm 
# End of macro FORTH_DSP_POP
4fb1			 
4fb1					; one value on hl get other one back 
4fb1			 
4fb1			;		pop hl 
4fb1			 
4fb1			 
4fb1 0e ff				ld c, SPI_CE_HIGH 
4fb3 06 30				ld b, '0'    ; human readable bank number 
4fb5			 
4fb5 7d					ld a, l 
4fb6			 
4fb6					if DEBUG_FORTH_WORDS 
4fb6						DMARK "BNK" 
4fb6 f5				push af  
4fb7 3a cb 4f			ld a, (.dmark)  
4fba 32 77 fb			ld (debug_mark),a  
4fbd 3a cc 4f			ld a, (.dmark+1)  
4fc0 32 78 fb			ld (debug_mark+1),a  
4fc3 3a cd 4f			ld a, (.dmark+2)  
4fc6 32 79 fb			ld (debug_mark+2),a  
4fc9 18 03			jr .pastdmark  
4fcb ..			.dmark: db "BNK"  
4fce f1			.pastdmark: pop af  
4fcf			endm  
# End of macro DMARK
4fcf						CALLMONITOR 
4fcf cd 97 16			call break_point_state  
4fd2				endm  
# End of macro CALLMONITOR
4fd2					endif 
4fd2			 
4fd2					; active low 
4fd2			 
4fd2 fe 00				cp 0 
4fd4 28 28				jr z, .bset 
4fd6 fe 01				cp 1 
4fd8 20 04				jr nz, .b2 
4fda cb 81				res 0, c 
4fdc 06 31				ld b, '1'    ; human readable bank number 
4fde fe 02		.b2:		cp 2 
4fe0 20 04				jr nz, .b3 
4fe2 cb 89				res 1, c 
4fe4 06 32				ld b, '2'    ; human readable bank number 
4fe6 fe 03		.b3:		cp 3 
4fe8 20 04				jr nz, .b4 
4fea cb 91				res 2, c 
4fec 06 33				ld b, '3'    ; human readable bank number 
4fee fe 04		.b4:		cp 4 
4ff0 20 04				jr nz, .b5 
4ff2 cb 99				res 3, c 
4ff4 06 34				ld b, '4'    ; human readable bank number 
4ff6 fe 05		.b5:		cp 5 
4ff8 20 04				jr nz, .bset 
4ffa cb a1				res 4, c 
4ffc 06 35				ld b, '5'    ; human readable bank number 
4ffe			 
4ffe			.bset: 
4ffe 79					ld a, c 
4fff 32 48 f8				ld (spi_device),a 
5002 78					ld a, b 
5003 32 47 f8				ld (spi_device_id),a 
5006					if DEBUG_FORTH_WORDS 
5006						DMARK "BN2" 
5006 f5				push af  
5007 3a 1b 50			ld a, (.dmark)  
500a 32 77 fb			ld (debug_mark),a  
500d 3a 1c 50			ld a, (.dmark+1)  
5010 32 78 fb			ld (debug_mark+1),a  
5013 3a 1d 50			ld a, (.dmark+2)  
5016 32 79 fb			ld (debug_mark+2),a  
5019 18 03			jr .pastdmark  
501b ..			.dmark: db "BN2"  
501e f1			.pastdmark: pop af  
501f			endm  
# End of macro DMARK
501f						CALLMONITOR 
501f cd 97 16			call break_point_state  
5022				endm  
# End of macro CALLMONITOR
5022					endif 
5022			 
5022					NEXTW 
5022 c3 90 1f			jp macro_next 
5025				endm 
# End of macro NEXTW
5025			 
5025			.CARTDEV: 
5025				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5025 66				db WORD_SYS_CORE+82             
5026 ce 50			dw .ENDDEVICE            
5028 08				db 7 + 1 
5029 .. 00			db "CARTDEV",0              
5031				endm 
# End of macro CWHEAD
5031			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5031					if DEBUG_FORTH_WORDS_KEY 
5031						DMARK "CDV" 
5031 f5				push af  
5032 3a 46 50			ld a, (.dmark)  
5035 32 77 fb			ld (debug_mark),a  
5038 3a 47 50			ld a, (.dmark+1)  
503b 32 78 fb			ld (debug_mark+1),a  
503e 3a 48 50			ld a, (.dmark+2)  
5041 32 79 fb			ld (debug_mark+2),a  
5044 18 03			jr .pastdmark  
5046 ..			.dmark: db "CDV"  
5049 f1			.pastdmark: pop af  
504a			endm  
# End of macro DMARK
504a						CALLMONITOR 
504a cd 97 16			call break_point_state  
504d				endm  
# End of macro CALLMONITOR
504d					endif 
504d			 
504d					; disable se storage bank selection 
504d			 
504d 3e ff				ld a, SPI_CE_HIGH		; ce high 
504f 32 48 f8				ld (spi_device), a 
5052			 
5052					; get bank 
5052			 
5052					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5052 cd 1e 1e			call macro_dsp_valuehl 
5055				endm 
# End of macro FORTH_DSP_VALUEHL
5055			 
5055			;		push hl 
5055			 
5055					; destroy value TOS 
5055			 
5055					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5055 cd d6 1e			call macro_forth_dsp_pop 
5058				endm 
# End of macro FORTH_DSP_POP
5058			 
5058					; one value on hl get other one back 
5058			 
5058			;		pop hl 
5058			 
5058					; active low 
5058			 
5058 0e ff				ld c, 255 
505a			 
505a 7d					ld a, l 
505b					if DEBUG_FORTH_WORDS 
505b						DMARK "CDV" 
505b f5				push af  
505c 3a 70 50			ld a, (.dmark)  
505f 32 77 fb			ld (debug_mark),a  
5062 3a 71 50			ld a, (.dmark+1)  
5065 32 78 fb			ld (debug_mark+1),a  
5068 3a 72 50			ld a, (.dmark+2)  
506b 32 79 fb			ld (debug_mark+2),a  
506e 18 03			jr .pastdmark  
5070 ..			.dmark: db "CDV"  
5073 f1			.pastdmark: pop af  
5074			endm  
# End of macro DMARK
5074						CALLMONITOR 
5074 cd 97 16			call break_point_state  
5077				endm  
# End of macro CALLMONITOR
5077					endif 
5077 fe 00				cp 0 
5079 28 30				jr z, .cset 
507b fe 01				cp 1 
507d 20 02				jr nz, .c2 
507f cb 81				res 0, c 
5081 fe 02		.c2:		cp 2 
5083 20 02				jr nz, .c3 
5085 cb 89				res 1, c 
5087 fe 03		.c3:		cp 3 
5089 20 02				jr nz, .c4 
508b cb 91				res 2, c 
508d fe 04		.c4:		cp 4 
508f 20 02				jr nz, .c5 
5091 cb 99				res 3, c 
5093 fe 05		.c5:		cp 5 
5095 20 02				jr nz, .c6 
5097 cb a1				res 4, c 
5099 fe 06		.c6:		cp 6 
509b 20 02				jr nz, .c7 
509d cb a9				res 5, c 
509f fe 07		.c7:		cp 7 
50a1 20 02				jr nz, .c8 
50a3 cb b1				res 6, c 
50a5 fe 08		.c8:		cp 8 
50a7 20 02				jr nz, .cset 
50a9 cb b9				res 7, c 
50ab 79			.cset:		ld a, c 
50ac 32 4b f8				ld (spi_cartdev),a 
50af			 
50af					if DEBUG_FORTH_WORDS 
50af						DMARK "CD2" 
50af f5				push af  
50b0 3a c4 50			ld a, (.dmark)  
50b3 32 77 fb			ld (debug_mark),a  
50b6 3a c5 50			ld a, (.dmark+1)  
50b9 32 78 fb			ld (debug_mark+1),a  
50bc 3a c6 50			ld a, (.dmark+2)  
50bf 32 79 fb			ld (debug_mark+2),a  
50c2 18 03			jr .pastdmark  
50c4 ..			.dmark: db "CD2"  
50c7 f1			.pastdmark: pop af  
50c8			endm  
# End of macro DMARK
50c8						CALLMONITOR 
50c8 cd 97 16			call break_point_state  
50cb				endm  
# End of macro CALLMONITOR
50cb					endif 
50cb					NEXTW 
50cb c3 90 1f			jp macro_next 
50ce				endm 
# End of macro NEXTW
50ce			endif 
50ce			 
50ce			.ENDDEVICE: 
50ce			; eof 
50ce			 
# End of file forth_words_device.asm
50ce			 
50ce			; var handler 
50ce			 
50ce			 
50ce			.VARS: 
50ce				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
50ce 78				db WORD_SYS_CORE+100             
50cf e6 50			dw .V0Q            
50d1 04				db 3 + 1 
50d2 .. 00			db "V0!",0              
50d6				endm 
# End of macro CWHEAD
50d6			;| V0! ( u1 -- )  Store value to v0  | DONE 
50d6			 
50d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50d6 cd 1e 1e			call macro_dsp_valuehl 
50d9				endm 
# End of macro FORTH_DSP_VALUEHL
50d9			 
50d9 11 10 f8				ld de, cli_var_array 
50dc			 
50dc eb					ex de, hl 
50dd 73					ld (hl), e 
50de 23					inc hl 
50df 72					ld (hl), d 
50e0			 
50e0					; destroy value TOS 
50e0			 
50e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50e0 cd d6 1e			call macro_forth_dsp_pop 
50e3				endm 
# End of macro FORTH_DSP_POP
50e3			 
50e3				       NEXTW 
50e3 c3 90 1f			jp macro_next 
50e6				endm 
# End of macro NEXTW
50e6			.V0Q: 
50e6				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
50e6 79				db WORD_SYS_CORE+101             
50e7 f7 50			dw .V1S            
50e9 04				db 3 + 1 
50ea .. 00			db "V0@",0              
50ee				endm 
# End of macro CWHEAD
50ee			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
50ee 2a 10 f8				ld hl, (cli_var_array) 
50f1 cd 27 1c				call forth_push_numhl 
50f4			 
50f4				       NEXTW 
50f4 c3 90 1f			jp macro_next 
50f7				endm 
# End of macro NEXTW
50f7			.V1S: 
50f7				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
50f7 7a				db WORD_SYS_CORE+102             
50f8 0f 51			dw .V1Q            
50fa 04				db 3 + 1 
50fb .. 00			db "V1!",0              
50ff				endm 
# End of macro CWHEAD
50ff			;| V1! ( u1 -- )  Store value to v1 | DONE 
50ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50ff cd 1e 1e			call macro_dsp_valuehl 
5102				endm 
# End of macro FORTH_DSP_VALUEHL
5102			 
5102 11 12 f8				ld de, cli_var_array+2 
5105				 
5105 eb					ex de, hl 
5106 73					ld (hl), e 
5107 23					inc hl 
5108 72					ld (hl), d 
5109			 
5109					; destroy value TOS 
5109			 
5109					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5109 cd d6 1e			call macro_forth_dsp_pop 
510c				endm 
# End of macro FORTH_DSP_POP
510c				       NEXTW 
510c c3 90 1f			jp macro_next 
510f				endm 
# End of macro NEXTW
510f			.V1Q: 
510f				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
510f 7b				db WORD_SYS_CORE+103             
5110 20 51			dw .V2S            
5112 04				db 3 + 1 
5113 .. 00			db "V1@",0              
5117				endm 
# End of macro CWHEAD
5117			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5117 2a 12 f8				ld hl, (cli_var_array+2) 
511a cd 27 1c				call forth_push_numhl 
511d				       NEXTW 
511d c3 90 1f			jp macro_next 
5120				endm 
# End of macro NEXTW
5120			.V2S: 
5120				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5120 7c				db WORD_SYS_CORE+104             
5121 38 51			dw .V2Q            
5123 04				db 3 + 1 
5124 .. 00			db "V2!",0              
5128				endm 
# End of macro CWHEAD
5128			;| V2! ( u1 -- )  Store value to v2 | DONE 
5128					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5128 cd 1e 1e			call macro_dsp_valuehl 
512b				endm 
# End of macro FORTH_DSP_VALUEHL
512b			 
512b 11 14 f8				ld de, cli_var_array+4 
512e				 
512e eb					ex de, hl 
512f 73					ld (hl), e 
5130 23					inc hl 
5131 72					ld (hl), d 
5132			 
5132					; destroy value TOS 
5132			 
5132					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5132 cd d6 1e			call macro_forth_dsp_pop 
5135				endm 
# End of macro FORTH_DSP_POP
5135				       NEXTW 
5135 c3 90 1f			jp macro_next 
5138				endm 
# End of macro NEXTW
5138			.V2Q: 
5138				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5138 7d				db WORD_SYS_CORE+105             
5139 49 51			dw .V3S            
513b 04				db 3 + 1 
513c .. 00			db "V2@",0              
5140				endm 
# End of macro CWHEAD
5140			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5140 2a 14 f8				ld hl, (cli_var_array+4) 
5143 cd 27 1c				call forth_push_numhl 
5146				       NEXTW 
5146 c3 90 1f			jp macro_next 
5149				endm 
# End of macro NEXTW
5149			.V3S: 
5149				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5149 7c				db WORD_SYS_CORE+104             
514a 61 51			dw .V3Q            
514c 04				db 3 + 1 
514d .. 00			db "V3!",0              
5151				endm 
# End of macro CWHEAD
5151			;| V3! ( u1 -- )  Store value to v3 | DONE 
5151					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5151 cd 1e 1e			call macro_dsp_valuehl 
5154				endm 
# End of macro FORTH_DSP_VALUEHL
5154			 
5154 11 16 f8				ld de, cli_var_array+6 
5157				 
5157 eb					ex de, hl 
5158 73					ld (hl), e 
5159 23					inc hl 
515a 72					ld (hl), d 
515b			 
515b					; destroy value TOS 
515b			 
515b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
515b cd d6 1e			call macro_forth_dsp_pop 
515e				endm 
# End of macro FORTH_DSP_POP
515e				       NEXTW 
515e c3 90 1f			jp macro_next 
5161				endm 
# End of macro NEXTW
5161			.V3Q: 
5161				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5161 7d				db WORD_SYS_CORE+105             
5162 72 51			dw .END            
5164 04				db 3 + 1 
5165 .. 00			db "V3@",0              
5169				endm 
# End of macro CWHEAD
5169			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5169 2a 16 f8				ld hl, (cli_var_array+6) 
516c cd 27 1c				call forth_push_numhl 
516f				       NEXTW 
516f c3 90 1f			jp macro_next 
5172				endm 
# End of macro NEXTW
5172			 
5172			 
5172			 
5172			 
5172			 
5172			; end of dict marker 
5172			 
5172 00			.END:    db WORD_SYS_END 
5173 00 00			dw 0 
5175 00				db 0 
5176			 
5176			; use to jp here for user dict words to save on macro expansion  
5176			 
5176			user_dict_next: 
5176				NEXTW 
5176 c3 90 1f			jp macro_next 
5179				endm 
# End of macro NEXTW
5179			 
5179			 
5179			user_exec: 
5179				;    ld hl, <word code> 
5179				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5179				;    call forthexec 
5179				;    jp user_dict_next   (NEXT) 
5179			        ;    <word code bytes> 
5179 eb				ex de, hl 
517a 2a 1e f1			ld hl,(os_tok_ptr) 
517d				 
517d				FORTH_RSP_NEXT 
517d cd ce 1b			call macro_forth_rsp_next 
5180				endm 
# End of macro FORTH_RSP_NEXT
5180			 
5180			if DEBUG_FORTH_UWORD 
5180						DMARK "UEX" 
5180 f5				push af  
5181 3a 95 51			ld a, (.dmark)  
5184 32 77 fb			ld (debug_mark),a  
5187 3a 96 51			ld a, (.dmark+1)  
518a 32 78 fb			ld (debug_mark+1),a  
518d 3a 97 51			ld a, (.dmark+2)  
5190 32 79 fb			ld (debug_mark+2),a  
5193 18 03			jr .pastdmark  
5195 ..			.dmark: db "UEX"  
5198 f1			.pastdmark: pop af  
5199			endm  
# End of macro DMARK
5199				CALLMONITOR 
5199 cd 97 16			call break_point_state  
519c				endm  
# End of macro CALLMONITOR
519c			endif 
519c			 
519c			 
519c			 
519c eb				ex de, hl 
519d 22 1e f1			ld (os_tok_ptr), hl 
51a0				 
51a0				; Don't use next - Skips the first word in uword. 
51a0			 
51a0 c3 21 20			jp exec1 
51a3			;	NEXT 
51a3			 
51a3			 
51a3			; eof 
# End of file forth_wordsv4.asm
51a3			endif 
51a3			;;;;;;;;;;;;;; Debug code 
51a3			 
51a3			 
51a3			;if DEBUG_FORTH_PARSE 
51a3 .. 00		.nowordfound: db "No match",0 
51ac .. 00		.compword:	db "Comparing word ",0 
51bc .. 00		.nextwordat:	db "Next word at",0 
51c9 .. 00		.charmatch:	db "Char match",0 
51d4			;endif 
51d4			if DEBUG_FORTH_JP 
51d4			.foundword:	db "Word match. Exec..",0 
51d4			endif 
51d4			;if DEBUG_FORTH_PUSH 
51d4 .. 00		.enddict:	db "Dict end. Push.",0 
51e4 .. 00		.push_str:	db "Pushing string",0 
51f3 .. 00		.push_num:	db "Pushing number",0 
5202 .. 00		.data_sp:	db "SP:",0 
5206 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5218 .. 00		.wordinde:	db "Word in DE (3/0):",0 
522a .. 00		.wordinbc:	db "Word in BC (4/0):",0 
523c			;endif 
523c			;if DEBUG_FORTH_MALLOC 
523c .. 00		.push_malloc:	db "Malloc address",0 
524b			;endif 
524b			 
524b			 
524b			 
524b			; display malloc address and current data stack pointer  
524b			 
524b			malloc_error: 
524b d5				push de 
524c f5				push af 
524d e5				push hl 
524e cd d5 0a			call clear_display 
5251 11 73 52			ld de, .mallocerr 
5254 3e 00			ld a,0 
5256			;	ld de,os_word_scratch 
5256 cd e8 0a			call str_at_display 
5259 3e 11			ld a, display_row_1+17 
525b 11 77 fb			ld de, debug_mark 
525e cd e8 0a			call str_at_display 
5261 cd f8 0a			call update_display 
5264				;call break_point_state 
5264 cd 9e 68			call cin_wait 
5267			 
5267 3e 20			ld a, ' ' 
5269 32 0e ee			ld (os_view_disable), a 
526c e1				pop hl 
526d f1				pop af 
526e d1				pop de	 
526f				CALLMONITOR 
526f cd 97 16			call break_point_state  
5272				endm  
# End of macro CALLMONITOR
5272 c9				ret 
5273			 
5273 .. 00		.mallocerr: 	db "Malloc Error",0 
5280			;if DEBUG_FORTH_PUSH 
5280			display_data_sp: 
5280 f5				push af 
5281			 
5281				; see if disabled 
5281			 
5281 3a 0e ee			ld a, (os_view_disable) 
5284 fe 2a			cp '*' 
5286 28 67			jr z, .skipdsp 
5288			 
5288 e5				push hl 
5289 e5				push hl 
528a e5			push hl 
528b cd d5 0a			call clear_display 
528e e1			pop hl 
528f 7c				ld a,h 
5290 21 22 f1			ld hl, os_word_scratch 
5293 cd 0a 10			call hexout 
5296 e1				pop hl 
5297 7d				ld a,l 
5298 21 24 f1			ld hl, os_word_scratch+2 
529b cd 0a 10			call hexout 
529e 21 26 f1			ld hl, os_word_scratch+4 
52a1 3e 00			ld a,0 
52a3 77				ld (hl),a 
52a4 11 22 f1			ld de,os_word_scratch 
52a7 3e 28				ld a, display_row_2 
52a9 cd e8 0a				call str_at_display 
52ac 11 06 52			ld de, .wordinhl 
52af 3e 00			ld a, display_row_1 
52b1			 
52b1 cd e8 0a				call str_at_display 
52b4 11 77 fb			ld de, debug_mark 
52b7 3e 11			ld a, display_row_1+17 
52b9			 
52b9 cd e8 0a				call str_at_display 
52bc			 
52bc				; display current data stack pointer 
52bc 11 02 52			ld de,.data_sp 
52bf 3e 30				ld a, display_row_2 + 8 
52c1 cd e8 0a				call str_at_display 
52c4			 
52c4 2a 0a f8			ld hl,(cli_data_sp) 
52c7 e5				push hl 
52c8 7c				ld a,h 
52c9 21 22 f1			ld hl, os_word_scratch 
52cc cd 0a 10			call hexout 
52cf e1				pop hl 
52d0 7d				ld a,l 
52d1 21 24 f1			ld hl, os_word_scratch+2 
52d4 cd 0a 10			call hexout 
52d7 21 26 f1			ld hl, os_word_scratch+4 
52da 3e 00			ld a,0 
52dc 77				ld (hl),a 
52dd 11 22 f1			ld de,os_word_scratch 
52e0 3e 33				ld a, display_row_2 + 11 
52e2 cd e8 0a				call str_at_display 
52e5			 
52e5			 
52e5 cd f8 0a			call update_display 
52e8 cd 55 0a			call delay1s 
52eb cd 55 0a			call delay1s 
52ee e1				pop hl 
52ef			.skipdsp: 
52ef f1				pop af 
52f0 c9				ret 
52f1			 
52f1			display_data_malloc: 
52f1			 
52f1 f5				push af 
52f2 e5				push hl 
52f3 e5				push hl 
52f4 e5			push hl 
52f5 cd d5 0a			call clear_display 
52f8 e1			pop hl 
52f9 7c				ld a,h 
52fa 21 22 f1			ld hl, os_word_scratch 
52fd cd 0a 10			call hexout 
5300 e1				pop hl 
5301 7d				ld a,l 
5302 21 24 f1			ld hl, os_word_scratch+2 
5305 cd 0a 10			call hexout 
5308 21 26 f1			ld hl, os_word_scratch+4 
530b 3e 00			ld a,0 
530d 77				ld (hl),a 
530e 11 22 f1			ld de,os_word_scratch 
5311 3e 28				ld a, display_row_2 
5313 cd e8 0a				call str_at_display 
5316 11 3c 52			ld de, .push_malloc 
5319 3e 00			ld a, display_row_1 
531b			 
531b cd e8 0a				call str_at_display 
531e			 
531e				; display current data stack pointer 
531e 11 02 52			ld de,.data_sp 
5321 3e 30				ld a, display_row_2 + 8 
5323 cd e8 0a				call str_at_display 
5326			 
5326 2a 0a f8			ld hl,(cli_data_sp) 
5329 e5				push hl 
532a 7c				ld a,h 
532b 21 22 f1			ld hl, os_word_scratch 
532e cd 0a 10			call hexout 
5331 e1				pop hl 
5332 7d				ld a,l 
5333 21 24 f1			ld hl, os_word_scratch+2 
5336 cd 0a 10			call hexout 
5339 21 26 f1			ld hl, os_word_scratch+4 
533c 3e 00			ld a,0 
533e 77				ld (hl),a 
533f 11 22 f1			ld de,os_word_scratch 
5342 3e 33				ld a, display_row_2 + 11 
5344 cd e8 0a				call str_at_display 
5347			 
5347 cd f8 0a			call update_display 
534a cd 55 0a			call delay1s 
534d cd 55 0a			call delay1s 
5350 e1				pop hl 
5351 f1				pop af 
5352 c9				ret 
5353			;endif 
5353			 
5353			include "forth_autostart.asm" 
5353			; list of commands to perform at system start up 
5353			 
5353			startcmds: 
5353			;	dw test11 
5353			;	dw test12 
5353			;	dw test13 
5353			;	dw test14 
5353			;	dw test15 
5353			;	dw test16 
5353			;	dw test17 
5353			;	dw ifthtest1 
5353			;	dw ifthtest2 
5353			;	dw ifthtest3 
5353			;	dw mmtest1 
5353			;	dw mmtest2 
5353			;	dw mmtest3 
5353			;	dw mmtest4 
5353			;	dw mmtest5 
5353			;	dw mmtest6 
5353			;	dw iftest1 
5353			;	dw iftest2 
5353			;	dw iftest3 
5353			;	dw looptest1 
5353			;	dw looptest2 
5353			;	dw test1 
5353			;	dw test2 
5353			;	dw test3 
5353			;	dw test4 
5353			;	dw game2r 
5353			;	dw game2b1 
5353			;	dw game2b2 
5353			 
5353				; start up words that are actually useful 
5353			 
5353 b1 53			dw clrstack 
5355 e4 53			dw type 
5357 a5 55			dw stest 
5359 08 54			dw strncpy 
535b 46 55			dw list 
535d 69 54			dw start1 
535f 7b 54			dw start2 
5361			;	dw start3 
5361 8e 54			dw start3b 
5363 e6 54			dw start3c 
5365			 
5365				; (unit) testing words 
5365			 
5365 1c 56			dw mtesta 
5367 d1 56			dw mtestb 
5369 74 57			dw mtestc 
536b 29 58			dw mtestd 
536d cd 58			dw mteste 
536f			 
536f				; demo/game words 
536f			 
536f d9 5f		        dw game3w 
5371 07 60		        dw game3p 
5373 25 60		        dw game3sc 
5375 56 60		        dw game3vsi 
5377 82 60		        dw game3vs 
5379				 
5379 cc 5d			dw game2b 
537b 3a 5e			dw game2bf 
537d 84 5e			dw game2mba 
537f 1a 5f			dw game2mbas 
5381 5c 5f			dw game2mb 
5383			 
5383 8d 5a			dw game1 
5385 9e 5a			dw game1a 
5387 00 5b			dw game1b 
5389 35 5b			dw game1c 
538b 6b 5b			dw game1d 
538d 9c 5b			dw game1s 
538f b0 5b			dw game1t 
5391 c5 5b			dw game1f 
5393 f9 5b			dw game1z 
5395 3d 5c			dw game1zz 
5397			 
5397 83 59			dw test5 
5399 bb 59			dw test6 
539b f3 59			dw test7 
539d 07 5a			dw test8 
539f 33 5a			dw test9 
53a1 49 5a			dw test10 
53a3				 
53a3 14 5d		        dw ssv5 
53a5 f8 5c		        dw ssv4 
53a7 dc 5c		        dw ssv3 
53a9 a6 5c		        dw ssv2 
53ab 2d 5d		        dw ssv1 
53ad 75 5d		        dw ssv1cpm 
53af			;	dw keyup 
53af			;	dw keydown 
53af			;	dw keyleft 
53af			;	dw keyright 
53af			;	dw 	keyf1 
53af			;	dw keyf2 
53af			;	dw keyf3 
53af			;	dw keyf4 
53af			;	dw keyf5 
53af			;	dw keyf6 
53af			;	dw keyf7 
53af			;	dw keyf8 
53af			;	dw keyf9 
53af			;	dw keyf10 
53af			;	dw keyf11 
53af			;	dw keyf12 
53af			;	dw keytab 
53af			;	dw keycr 
53af			;	dw keyhome 
53af			;	dw keyend 
53af			;	dw keybs 
53af 00 00			db 0, 0	 
53b1			 
53b1			 
53b1			; clear stack  
53b1			 
53b1 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
53e4			 
53e4			; type ( addr count - ) 
53e4 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5408			 
5408			; some direct memory words 
5408			; strncpy ( len t f -- t ) 
5408			 
5408 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5469			 
5469 .. 00		start1:     	db ": bpon $0000 bp ;",0 
547b .. 00		start2:     	db ": bpoff $0001 bp ;",0 
548e			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
548e .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
54e6 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5546			 
5546			 
5546			; a handy word to list items on the stack 
5546			 
5546 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
55a5			 
55a5			 
55a5			; test stack  
55a5			; rnd8 stest 
55a5			 
55a5 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
561c			 
561c			; random malloc and free cycles 
561c			 
561c .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56d1			 
56d1			; fixed malloc and free cycles 
56d1			 
56d1 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5774			 
5774			; fixed double string push and drop cycle  
5774			 
5774 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5829			 
5829			; consistent fixed string push and drop cycle  
5829			 
5829 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
58cd			 
58cd .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5983			 
5983			;test1:		db ": aa 1 2 3 ;", 0 
5983			;test2:     	db "111 aa 888 999",0 
5983			;test3:     	db ": bb 77 ;",0 
5983			;test4:     	db "$02 $01 do i . loop bb",0 
5983			 
5983 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
59bb .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
59f3 .. 00		test7:     	db ": box hline vline ;",0 
5a07 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5a33 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5a49 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5a6e .. 00		test11:     	db "hello create .",0 
5a7d .. 00		test12:     	db "hello2 create .",0 
5a8d			 
5a8d			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a8d			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a8d			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a8d			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a8d			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a8d			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a8d			 
5a8d			;iftest1:     	db "$0001 IF cls .",0 
5a8d			;iftest2:     	db "$0000 IF cls .",0 
5a8d			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a8d			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a8d			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a8d			 
5a8d			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a8d			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a8d			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a8d			 
5a8d			 
5a8d			 
5a8d			; a small guess the number game 
5a8d			 
5a8d .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a9e .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5b00			 
5b00 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5b35 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b6b .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b9c .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5bb0 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5bc5 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5bf9 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5c3d			 
5c3d			; Using 'ga' save a high score across multiple runs using external storage 
5c3d			 
5c3d .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5ca6			 
5ca6			 
5ca6			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5ca6			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5ca6			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5ca6			 
5ca6			; simple screen saver to test code memory reuse to destruction 
5ca6			 
5ca6 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5cdc .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5cf8 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5d14 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5d2d .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d75 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5dcc			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5dcc			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5dcc			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5dcc			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5dcc			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5dcc			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5dcc			 
5dcc			 
5dcc			 
5dcc			; minesweeper/battleship finding game 
5dcc			; draws a game board of random ship/mine positions 
5dcc			; user enters coords to see if it hits on 
5dcc			; game ends when all are hit 
5dcc			; when hit or miss says how many may be in the area 
5dcc			 
5dcc			; setup the game board and then hide it 
5dcc .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5e3a .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e84			; prompt for where to target 
5e84 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5f1a .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5f3f			; TODO see if the entered coords hits or misses pushes char hit of miss 
5f3f .. 00		game2mbht:      db ": mbckht nop ;",0 
5f4e .. 00		game2mbms:      db ": mbcms nop ;",0 
5f5c			; TODO how many might be near by 
5f5c .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5fd9			 
5fd9			; Game 3 
5fd9			 
5fd9			; Vert scroller ski game - avoid the trees! 
5fd9			 
5fd9			; v0 score (ie turns) 
5fd9			; v1 player pos 
5fd9			; v2 left wall 
5fd9			; v3 right wall 
5fd9			 
5fd9			; Draw side walls randomly 
5fd9			 
5fd9 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6007			 
6007			; Draw player 
6007 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6025			 
6025			; TODO Get Key 
6025			 
6025			; TODO Move left right 
6025			 
6025			; scroll and move walls a bit 
6025			 
6025 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6056			 
6056			; main game loop 
6056			 
6056 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6082 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
60c1			 
60c1			; key board defs 
60c1			 
60c1 .. 00		keyup:       db ": keyup $05 ;",0 
60cf .. 00		keydown:       db ": keydown $0a ;",0 
60df .. 00		keyleft:       db ": keyleft $0b ;",0 
60ef .. 00		keyright:       db ": keyright $0c ;",0 
6100 .. 00		keyf1:       db ": keyf1 $10 ;",0 
610e .. 00		keyf2:       db ": keyf2 $11 ;",0 
611c .. 00		keyf3:       db ": keyf3 $12 ;",0 
612a .. 00		keyf4:       db ": keyf4 $13 ;",0 
6138 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6146 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6154 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6162 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6170 .. 00		keyf9:       db ": keyf9 $18 ;",0 
617e .. 00		keyf10:       db ": keyf10 $19 ;",0 
618d .. 00		keyf11:       db ": keyf11 $1a ;",0 
619c .. 00		keyf12:       db ": keyf12 $1b ;",0 
61ab			 
61ab .. 00		keytab:       db ": keytab $09 ;",0 
61ba .. 00		keycr:       db ": keycr $0d ;",0 
61c8 .. 00		keyhome:       db ": keyhome $0e ;",0 
61d8 .. 00		keyend:       db ": keyend $0f ;",0 
61e7 .. 00		keybs:       db ": keybs $08 ;",0 
61f5			 
61f5			   
61f5			 
61f5			 
61f5			 
61f5			; eof 
# End of file forth_autostart.asm
61f5			 
61f5 .. 00		sprompt1: db "Startup load...",0 
6205 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
621b			 
621b			 
621b			 
621b			 
621b			forth_startup: 
621b 21 53 53			ld hl, startcmds 
621e 3e 00			ld a, 0 
6220 32 43 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6223			 
6223 e5			.start1:	push hl 
6224 cd d5 0a			call clear_display 
6227 11 f5 61			ld de, sprompt1 
622a 3e 00		        ld a, display_row_1 
622c cd e8 0a			call str_at_display 
622f 11 05 62			ld de, sprompt2 
6232 3e 28		        ld a, display_row_2 
6234 cd e8 0a			call str_at_display 
6237 e1				pop hl 
6238 e5				push hl 
6239 5e				ld e,(hl) 
623a 23				inc hl 
623b 56				ld d,(hl) 
623c 3e 50		        ld a, display_row_3 
623e cd e8 0a			call str_at_display 
6241 cd f8 0a			call update_display 
6244			 
6244			 
6244 3a 43 f2			ld a, (os_last_cmd) 
6247 fe 00			cp 0 
6249 28 05			jr z, .startprompt 
624b cd 49 0a			call delay250ms 
624e 18 24			jr .startdo 
6250				 
6250				 
6250			 
6250			.startprompt: 
6250			 
6250 3e 9f			ld a,display_row_4 + display_cols - 1 
6252 11 9d 1b		        ld de, endprg 
6255 cd e8 0a			call str_at_display 
6258 cd f8 0a			call update_display 
625b cd 55 0a			call delay1s 
625e cd 9e 68			call cin_wait 
6261						 
6261 fe 2a			cp '*' 
6263 28 5e			jr z, .startupend1 
6265 fe 23			cp '#' 
6267 20 07			jr nz, .startno 
6269 3e 01			ld a, 1 
626b 32 43 f2			ld (os_last_cmd),a 
626e 18 04			jr .startdo 
6270 fe 31		.startno:	cp '1' 
6272 28 3a			jr z,.startnxt  
6274			 
6274				; exec startup line 
6274			.startdo:	 
6274 e1				pop hl 
6275 e5				push hl 
6276				 
6276 5e				ld e,(hl) 
6277 23				inc hl 
6278 56				ld d,(hl) 
6279 eb				ex de,hl 
627a			 
627a e5				push hl 
627b			 
627b 3e 00			ld a, 0 
627d				;ld a, FORTH_END_BUFFER 
627d cd 72 11			call strlent 
6280 23				inc hl   ; include zero term to copy 
6281 06 00			ld b,0 
6283 4d				ld c,l 
6284 e1				pop hl 
6285 11 1d ee			ld de, scratch 
6288 ed b0			ldir 
628a			 
628a			 
628a 21 1d ee			ld hl, scratch 
628d cd de 1f			call forthparse 
6290 cd 1e 20			call forthexec 
6293 cd 35 1f			call forthexec_cleanup 
6296			 
6296 3e 78			ld a, display_row_4 
6298 11 41 19			ld de, endprog 
629b			 
629b cd f8 0a			call update_display		 
629e			 
629e 3a 43 f2			ld a, (os_last_cmd) 
62a1 fe 00			cp 0 
62a3 20 09			jr nz, .startnxt 
62a5 cd 9f 1b			call next_page_prompt 
62a8 cd d5 0a		        call clear_display 
62ab cd f8 0a			call update_display		 
62ae			 
62ae				; move onto next startup line? 
62ae			.startnxt: 
62ae			 
62ae cd 49 0a			call delay250ms 
62b1 e1				pop hl 
62b2			 
62b2 23				inc hl 
62b3 23				inc hl 
62b4			 
62b4 e5				push hl 
62b5 5e				ld e, (hl) 
62b6 23				inc hl 
62b7 56				ld d, (hl) 
62b8 e1				pop hl 
62b9				; TODO replace 0 test 
62b9			 
62b9 eb				ex de, hl 
62ba cd 32 0d			call ishlzero 
62bd			;	ld a,e 
62bd			;	add d 
62bd			;	cp 0    ; any left to do? 
62bd eb				ex de, hl 
62be c2 23 62			jp nz, .start1 
62c1 18 01			jr .startupend 
62c3			 
62c3 e1			.startupend1: pop hl 
62c4			.startupend: 
62c4			 
62c4 cd d5 0a			call clear_display 
62c7 cd f8 0a			call update_display 
62ca c9				ret 
62cb			 
62cb			 
62cb			; stack over and underflow checks 
62cb			 
62cb			; init the words to detect the under/overflow 
62cb			 
62cb			chk_stk_init: 
62cb				; a vague random number to check so we dont get any "lucky" hits 
62cb 3e 2d			ld a, 45 
62cd 6f				ld l, a 
62ce 00				nop 
62cf 3e 17			ld a, 23 
62d1 67				ld h, a 
62d2			 
62d2 22 04 ee			ld (chk_word), hl     ; the word we need to check against 
62d5			 
62d5			;	ld (chk_stund), hl	; stack points.... 
62d5 22 fd fb			ld (chk_stovr), hl 
62d8 22 08 f8			ld (chk_ret_und), hl 
62db 22 86 f7			ld (chk_ret_ovr), hl 
62de 22 84 f5			ld (chk_loop_ovr), hl 
62e1 22 82 f3			ld (chk_data_ovr), hl 
62e4 c9				ret 
62e5				 
62e5			check_stacks: 
62e5				; check all stack words 
62e5			 
62e5 e5				push hl 
62e6 d5				push de 
62e7			 
62e7			;	ld de,(chk_word) 
62e7			;	ld hl, (chk_stund)	; stack points.... 
62e7			;	if DEBUG_STK_FAULT 
62e7			;		DMARK "FAa" 
62e7			;		CALLMONITOR 
62e7			;	endif 
62e7			;	call cmp16 
62e7			;	jp z, .chk_faulta 
62e7			; 
62e7			;	ld de, sfaultsu 
62e7			;	jp .chk_fault 
62e7			 
62e7 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
62ea ed 5b 04 ee		ld de,(chk_word) 
62ee				if DEBUG_STK_FAULT 
62ee					DMARK "FAb" 
62ee					CALLMONITOR 
62ee				endif 
62ee cd 27 0d			call cmp16 
62f1 28 06			jr z, .chk_fault1 
62f3 11 94 63			ld de, sfaultso 
62f6 c3 48 63			jp .chk_fault 
62f9			.chk_fault1:  
62f9 2a 08 f8			ld hl, (chk_ret_und) 
62fc ed 5b 04 ee		ld de,(chk_word) 
6300				if DEBUG_STK_FAULT 
6300					DMARK "FAU" 
6300					CALLMONITOR 
6300				endif 
6300 cd 27 0d			call cmp16 
6303 ca 0c 63			jp z, .chk_fault2 
6306 11 a4 63			ld de, sfaultru 
6309 c3 48 63			jp .chk_fault 
630c			.chk_fault2:  
630c 2a 86 f7			ld hl, (chk_ret_ovr) 
630f ed 5b 04 ee		ld de,(chk_word) 
6313				if DEBUG_STK_FAULT 
6313					DMARK "FA1" 
6313					CALLMONITOR 
6313				endif 
6313 cd 27 0d			call cmp16 
6316 ca 1f 63			jp z, .chk_fault3 
6319 11 b2 63			ld de, sfaultro 
631c c3 48 63			jp .chk_fault 
631f			.chk_fault3:  
631f 2a 84 f5			ld hl, (chk_loop_ovr) 
6322 ed 5b 04 ee		ld de,(chk_word) 
6326				if DEBUG_STK_FAULT 
6326					DMARK "FA2" 
6326					CALLMONITOR 
6326				endif 
6326 cd 27 0d			call cmp16 
6329 ca 32 63			jp z, .chk_fault4 
632c 11 cc 63			ld de, sfaultlo 
632f c3 48 63			jp .chk_fault 
6332			.chk_fault4:  
6332 2a 82 f3			ld hl, (chk_data_ovr) 
6335 ed 5b 04 ee		ld de,(chk_word) 
6339				if DEBUG_STK_FAULT 
6339					DMARK "FA3" 
6339					CALLMONITOR 
6339				endif 
6339 cd 27 0d			call cmp16 
633c ca 45 63			jp z, .chk_fault5 
633f 11 e6 63			ld de, sfaultdo 
6342 c3 48 63			jp .chk_fault 
6345			 
6345			 
6345			.chk_fault5:  
6345 d1				pop de 
6346 e1				pop hl 
6347			 
6347 c9				ret 
6348			 
6348 cd d5 0a		.chk_fault: 	call clear_display 
634b 3e 28				ld a, display_row_2 
634d cd e8 0a				call str_at_display 
6350 11 76 63				   ld de, .stackfault 
6353 3e 00				ld a, display_row_1 
6355 cd e8 0a				call str_at_display 
6358 11 77 fb				    ld de, debug_mark 
635b 3e 11				ld a, display_row_1+17 
635d cd e8 0a				call str_at_display 
6360 cd f8 0a				call update_display 
6363			 
6363				; prompt before entering montior for investigating issue 
6363			 
6363 3e 78			ld a, display_row_4 
6365 11 41 19			ld de, endprog 
6368			 
6368 cd f8 0a			call update_display		 
636b			 
636b cd 9f 1b			call next_page_prompt 
636e			 
636e d1				pop de 
636f e1				pop hl 
6370 cd 95 19				call monitor 
6373 c3 8c 18				jp warmstart 
6376					;jp 0 
6376					;halt 
6376			 
6376			 
6376			 
6376 .. 00		.stackfault: 	db "Stack fault:",0 
6383			 
6383 .. 00		sfaultsu: 	db	"Stack under flow",0 
6394 .. 00		sfaultso: 	db	"Stack over flow",0 
63a4 .. 00		sfaultru:	db "RTS underflow",0 
63b2 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
63cc .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
63e6 .. 00		sfaultdo:	db "DTS overflow", 0 
63f3			 
63f3			 
63f3			fault_dsp_under: 
63f3 11 05 64			ld de, .dsp_under 
63f6 c3 b5 64			jp .show_fault 
63f9			 
63f9			fault_rsp_under: 
63f9 11 13 64			ld de, .rsp_under 
63fc c3 b5 64			jp .show_fault 
63ff			fault_loop_under: 
63ff 11 21 64			ld de, .loop_under 
6402 c3 b5 64			jp .show_fault 
6405			 
6405 .. 00		.dsp_under: db "DSP Underflow",0 
6413 .. 00		.rsp_under: db "RSP Underflow",0 
6421 .. 00		.loop_under: db "LOOP Underflow",0 
6430			 
6430			 
6430 d5			type_faultn: 	push de 
6431 e5					push hl 
6432 cd d5 0a				call clear_display 
6435 11 5c 64				   ld de, .typefaultn 
6438 3e 00				ld a, display_row_1 
643a cd e8 0a				call str_at_display 
643d 11 77 fb				    ld de, debug_mark 
6440 3e 11				ld a, display_row_1+17 
6442 cd e8 0a				call str_at_display 
6445 cd f8 0a				call update_display 
6448			 
6448				; prompt before entering montior for investigating issue 
6448			 
6448 3e 78			ld a, display_row_4 
644a 11 41 19			ld de, endprog 
644d			 
644d cd f8 0a			call update_display		 
6450			 
6450 cd 9f 1b			call next_page_prompt 
6453			 
6453 e5					push hl 
6454 d5					push de 
6455 cd 95 19				call monitor 
6458 c3 8c 18				jp warmstart 
645b 76					halt 
645c			 
645c			 
645c .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6473			 
6473 d5			type_faults: 	push de 
6474 e5					push hl 
6475 cd d5 0a				call clear_display 
6478 11 9e 64				   ld de, .typefaults 
647b 3e 00				ld a, display_row_1 
647d cd e8 0a				call str_at_display 
6480 11 77 fb				    ld de, debug_mark 
6483 3e 11				ld a, display_row_1+17 
6485 cd e8 0a				call str_at_display 
6488 cd f8 0a				call update_display 
648b			 
648b				; prompt before entering montior for investigating issue 
648b			 
648b 3e 78			ld a, display_row_4 
648d 11 41 19			ld de, endprog 
6490			 
6490 cd f8 0a			call update_display		 
6493			 
6493 cd 9f 1b			call next_page_prompt 
6496			 
6496 e1					pop hl 
6497 d1					pop de 
6498 cd 95 19				call monitor 
649b c3 8c 18				jp warmstart 
649e			 
649e			 
649e .. 00		.typefaults: db "STR Type Expected TOS!",0 
64b5			 
64b5			.show_fault: 	 
64b5 d5					push de 
64b6 cd d5 0a				call clear_display 
64b9 d1					pop de 
64ba 3e 00				ld a, display_row_1 
64bc cd e8 0a				call str_at_display 
64bf 11 77 fb				    ld de, debug_mark 
64c2 3e 11				ld a, display_row_1+17 
64c4 cd e8 0a				call str_at_display 
64c7 cd f8 0a				call update_display 
64ca			 
64ca				; prompt before entering montior for investigating issue 
64ca			 
64ca 3e 78			ld a, display_row_4 
64cc 11 41 19			ld de, endprog 
64cf			 
64cf cd f8 0a			call update_display		 
64d2			 
64d2 cd 9f 1b			call next_page_prompt 
64d5			 
64d5 e1					pop hl 
64d6 d1					pop de 
64d7 cd 95 19				call monitor 
64da			; do a dump to cli and not warmstart so we preserve all of the uwords.  
64da			; TODO Make optional fault restart to cli or warm boot? 
64da					;jp warmstart 
64da c3 e7 18				jp cli 
64dd 76					halt 
64de			 
64de			; handle the auto run of code from files in storage 
64de			 
64de			 
64de			if STORAGE_SE 
64de			 
64de .. 00		sprompt3: db "Loading from start-up file:",0 
64fa			 
64fa			 
64fa			forth_autoload: 
64fa			 
64fa				; load block 0 of store 1 
64fa				 
64fa 3e fe			ld a, $fe      ; bit 0 clear 
64fc 32 48 f8			ld (spi_device), a 
64ff			 
64ff cd bd 03			call storage_get_block_0 
6502			 
6502 3a 83 f8			ld a, (store_page+STORE_0_AUTOFILE) 
6505			 
6505 fe 00			cp 0 
6507 c8				ret z     ; auto start not enabled 
6508			 
6508 cd d5 0a			call clear_display 
650b			 
650b				; set bank 
650b			 
650b 3a 85 f8				ld a, (store_page+STORE_0_BANKRUN) 
650e 32 48 f8				ld (spi_device), a 
6511			 
6511				; get file id to load from and get the file name to display 
6511			 
6511 3a 83 f8				ld a, (store_page+STORE_0_AUTOFILE) 
6514			 
6514 2e 00				ld l, 0 
6516 67					ld h, a 
6517 11 62 f8				ld de, store_page 
651a			 
651a cd 51 08				call storage_read 
651d			 
651d cd 32 0d				call ishlzero 
6520 c8					ret z             ; file not found 
6521			 
6521 3e 5a				ld a, display_row_3 + 10 
6523 11 65 f8				ld de, store_page+3 
6526 cd e8 0a				call str_at_display 
6529				 
6529			; 
6529			 
6529 3e 2d			ld a, display_row_2+5 
652b 11 de 64			ld de, sprompt3 
652e cd e8 0a			call str_at_display 
6531			 
6531 cd f8 0a			call update_display 
6534			 
6534			 
6534 cd 55 0a			call delay1s 
6537			 
6537 c9				ret 
6538			 
6538			 
6538			 
6538			endif 
6538			 
6538			 
6538			; eof 
# End of file forth_kernel.asm
6538			;include "nascombasic.asm" 
6538			 
6538			 
6538			; find out where the code ends if loaded into RAM (for SC114) 
6538			;endofcode:  
6538			;	nop 
6538			 
6538			 
6538			; eof 
6538			 
# End of file main.asm
6538			include "firmware_lcd_4x40.asm" 
6538			; **********************************************************************  
6538			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6538			; **********************************************************************  
6538			;  
6538			; **  Written as a Small Computer Monitor App  
6538			; **  www.scc.me.uk  
6538			;  
6538			; History  
6538			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6538			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6538			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6538			;  
6538			; **********************************************************************  
6538			;  
6538			; This program is an example of one of the methods of interfacing an   
6538			; alphanumeric LCD module.   
6538			;  
6538			; In this example the display is connected to either a Z80 PIO or a   
6538			; simple 8-bit output port.   
6538			;  
6538			; This interfacing method uses 4-bit data mode and uses time delays  
6538			; rather than polling the display's ready status. As a result the   
6538			; interface only requires 6 simple output lines:  
6538			;   Output bit 0 = not used  
6538			;   Output bit 1 = not used  
6538			;   Output bit 2 = RS         High = data, Low = instruction  
6538			;   Output bit 3 = E          Active high  
6538			;   Output bit 4 = DB4  
6538			;   Output bit 5 = DB5  
6538			;   Output bit 6 = DB6  
6538			;   Output bit 7 = DB7  
6538			; Display's R/W is connected to 0v so it is always in write mode  
6538			;  
6538			; This set up should work with any system supporting the RC2014 bus  
6538			  
6538			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6538			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6538			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6538			;  
6538			; **********************************************************************  
6538			  
6538			; Additonal for 4x40. E1 and E2 instead of just E   
6538			; TODO swipe vidout signal on port a to activate E2  
6538			  
6538			; **********************************************************************  
6538			; **  Constants  
6538			; **********************************************************************  
6538			; LCD constants required by LCD support module  
6538			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6538			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6538			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
6538			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
6538			; TODO Decide which E is being set  
6538			kLCDWidth:  EQU display_cols             ;Width in characters  
6538			  
6538			; **********************************************************************  
6538			; **  Code library usage  
6538			; **********************************************************************  
6538			  
6538			; send character to current cursor position  
6538			; wraps and/or scrolls screen automatically  
6538			  
6538			  
6538			  
6538			lcd_init:  
6538			  
6538			; SCMonAPI functions used  
6538			  
6538			; Alphanumeric LCD functions used  
6538			; no need to specify specific functions for this module  
6538			  
6538 3e cf		            LD   A, 11001111b  
653a d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
653c 3e 00		            LD   A, 00000000b  
653e d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6540			  
6540			; Initialise alphanumeric LCD module  
6540 3e 00				ld a, 0  
6542 32 d7 f8				ld (display_lcde1e2), a  
6545 cd c6 65		            CALL fLCD_Init      ;Initialise LCD module  
6548 3e 01				ld a, 1  
654a 32 d7 f8				ld (display_lcde1e2), a  
654d cd c6 65		            CALL fLCD_Init      ;Initialise LCD module  
6550			  
6550 c9				ret  
6551			  
6551			;  
6551			;;  
6551			; lcd functions  
6551			;  
6551			;  
6551			  
6551			; what is at cursor position   
6551			  
6551			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6551			;		call curptr  
6551			;		ret  
6551			  
6551			  
6551			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6551			  
6551			curptr:  
6551 c5				push bc  
6552 21 bd fa			ld hl, display_fb0  
6555			cpr:	  
6555				; loop for cursor whole row  
6555 0e 28			ld c, display_cols  
6557 23			cpr1:	inc hl  
6558 0d				dec c  
6559 20 fc			jr nz, cpr1  
655b 05				dec b  
655c 20 f7			jr nz, cpr  
655e			  
655e				; add col	  
655e			  
655e 23			cpr2:	inc hl  
655f 1d				dec e  
6560 20 fc			jr nz, cpr2  
6562			  
6562 c1				pop bc  
6563 c9				ret  
6564				  
6564			  
6564			  
6564			  
6564			  
6564			; write the frame buffer given in hl to hardware   
6564 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
6567 3e 00			ld a, kLCD_Line1  
6569 cd 73 66		            CALL fLCD_Pos       ;Position cursor to location in A  
656c 06 28			ld b, display_cols  
656e ed 5b d5 f8		ld de, (display_write_tmp)  
6572 cd be 65			call write_len_string  
6575				  
6575				  
6575 2a d5 f8			ld hl, (display_write_tmp)  
6578 11 28 00			ld de, display_cols  
657b 19				add hl,de  
657c 22 d5 f8			ld (display_write_tmp),hl  
657f			  
657f				  
657f 3e 28			ld a, kLCD_Line2  
6581 cd 73 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6584 06 28			ld b, display_cols  
6586 ed 5b d5 f8		ld de, (display_write_tmp)  
658a cd be 65			call write_len_string  
658d				  
658d 2a d5 f8			ld hl, (display_write_tmp)  
6590 11 28 00			ld de, display_cols  
6593 19				add hl,de  
6594 22 d5 f8			ld (display_write_tmp),hl  
6597			  
6597				  
6597 3e 50			ld a, kLCD_Line3  
6599 cd 73 66		            CALL fLCD_Pos       ;Position cursor to location in A  
659c 06 28			ld b, display_cols  
659e ed 5b d5 f8		ld de, (display_write_tmp)  
65a2 cd be 65			call write_len_string  
65a5				  
65a5 2a d5 f8			ld hl, (display_write_tmp)  
65a8 11 28 00			ld de, display_cols  
65ab 19				add hl,de  
65ac 22 d5 f8			ld (display_write_tmp),hl  
65af			  
65af				  
65af 3e 78			ld a, kLCD_Line4  
65b1 cd 73 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65b4 06 28			ld b, display_cols  
65b6 ed 5b d5 f8		ld de, (display_write_tmp)  
65ba cd be 65			call write_len_string  
65bd c9					ret  
65be				  
65be				; write out a fixed length string given in b from de  
65be			  
65be 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
65bf cd 2b 66		            CALL fLCD_Data      ;Write character to display  
65c2 13				inc de  
65c3 10 f9			djnz write_len_string  
65c5 c9				ret  
65c6			  
65c6			; Some other things to do  
65c6			;            LD   A, kLCD_Clear ;Display clear  
65c6			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
65c6			;            LD   A, kLCD_Under ;Display on with underscore cursor  
65c6			;            LD   A, kLCD_On     ;Display on with no cursor  
65c6			;            ;LD   A, kLCD_Off   ;Display off  
65c6			;            CALL fLCD_Inst      ;Send instruction to display  
65c6			;  
65c6			;  
65c6			;            halt  
65c6			;  
65c6			;  
65c6			;MsgHello:   DB  "Hello World!",0  
65c6			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
65c6			  
65c6			; Custom characters 5 pixels wide by 8 pixels high  
65c6			; Up to 8 custom characters can be defined  
65c6			;BitMaps:      
65c6			;; Character 0x00 = Battery icon  
65c6			;            DB  01110b  
65c6			;            DB  11011b  
65c6			;            DB  10001b  
65c6			;            DB  10001b  
65c6			;            DB  11111b  
65c6			;            DB  11111b  
65c6			;            DB  11111b  
65c6			;            DB  11111b  
65c6			;; Character 0x01 = Bluetooth icon  
65c6			;            DB  01100b  
65c6			;            DB  01010b  
65c6			;            DB  11100b  
65c6			;            DB  01000b  
65c6			;            DB  11100b  
65c6			;            DB  01010b  
65c6			;            DB  01100b  
65c6			;            DB  00000b  
65c6			;  
65c6			  
65c6			  
65c6			; **********************************************************************  
65c6			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
65c6			; **********************************************************************  
65c6			;  
65c6			; **  Written as a Small Computer Monitor App   
65c6			; **  Version 0.1 SCC 2018-05-16  
65c6			; **  www.scc.me.uk  
65c6			;  
65c6			; **********************************************************************  
65c6			;  
65c6			; This module provides support for alphanumeric LCD modules using with  
65c6			; *  HD44780 (or compatible) controller  
65c6			; *  5 x 7 pixel fonts  
65c6			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
65c6			; *  Interface via six digital outputs to the display (see below)  
65c6			;  
65c6			; LCD module pinout:  
65c6			;   1  Vss   0v supply  
65c6			;   2  Vdd   5v supply  
65c6			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
65c6			;   4  RS    High = data, Low = instruction  
65c6			;   5  R/W   High = Read, Low = Write  
65c6			;   6  E     Enable signal (active high)  
65c6			;   7  DB0   Data bit 0  
65c6			;   8  DB1   Data bit 1  
65c6			;   9  DB2   Data bit 2  
65c6			;  10  DB3   Data bit 3  
65c6			;  11  DB4   Data bit 4  
65c6			;  12  DB5   Data bit 5  
65c6			;  13  DB6   Data bit 6  
65c6			;  14  DB7   Data bit 7  
65c6			;  15  A     Backlight anode (+)  
65c6			;  16  K     Backlight cathode (-)  
65c6			;  
65c6			; This interfacing method uses 4-bit data mode and uses time delays  
65c6			; rather than polling the display's ready status. As a result the   
65c6			; interface only requires 6 simple output lines:  
65c6			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
65c6			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
65c6			;   LCD DB4 = Microcomputer output port bit 4  
65c6			;   LCD DB5 = Microcomputer output port bit 5  
65c6			;   LCD DB6 = Microcomputer output port bit 6  
65c6			;   LCD DB7 = Microcomputer output port bit 7  
65c6			; Display's R/W is connected to 0v so it is always in write mode  
65c6			; All 6 connections must be on the same port address <kLCDPrt>  
65c6			; This method also allows a decent length of cable from micro to LCD  
65c6			;  
65c6			; **********************************************************************  
65c6			;  
65c6			; To include the code for any given function provided by this module,   
65c6			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
65c6			; the parent source file.  
65c6			; For example:  #REQUIRES   uHexPrefix  
65c6			;  
65c6			; Also #INCLUDE this file at some point after the #REQUIRES statements  
65c6			; in the parent source file.  
65c6			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
65c6			;  
65c6			; These are the function names provided by this module:  
65c6			; fLCD_Init                     ;Initialise LCD  
65c6			; fLCD_Inst                     ;Send instruction to LCD  
65c6			; fLCD_Data                     ;Send data byte to LCD  
65c6			; fLCD_Pos                      ;Position cursor  
65c6			; fLCD_Str                      ;Display string  
65c6			; fLCD_Def                      ;Define custom character  
65c6			;  
65c6			; **********************************************************************  
65c6			;  
65c6			; Requires SCMonAPI.asm to also be included in the project  
65c6			;  
65c6			  
65c6			  
65c6			; **********************************************************************  
65c6			; **  Constants  
65c6			; **********************************************************************  
65c6			  
65c6			; Constants that must be defined externally  
65c6			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
65c6			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
65c6			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
65c6			;kLCDWidth: EQU 20             ;Width in characters  
65c6			  
65c6			; general line offsets in any frame buffer  
65c6			  
65c6			  
65c6			display_row_1: equ 0  
65c6			display_row_2: equ display_row_1+display_cols  
65c6			display_row_3: equ display_row_2 + display_cols  
65c6			display_row_4: equ display_row_3 + display_cols  
65c6			;display_row_4_eol:   
65c6			  
65c6			  
65c6			; Cursor position values for the start of each line  
65c6			  
65c6			; E  
65c6			kLCD_Line1: EQU 0x00   
65c6			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
65c6			; E1  
65c6			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
65c6			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
65c6			  
65c6			; Instructions to send as A register to fLCD_Inst  
65c6			kLCD_Clear: EQU 00000001b     ;LCD clear  
65c6			kLCD_Off:   EQU 00001000b     ;LCD off  
65c6			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
65c6			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
65c6			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
65c6			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
65c6			  
65c6			; Constants used by this code module  
65c6			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
65c6			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
65c6			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
65c6			  
65c6			  
65c6			  
65c6			; **********************************************************************  
65c6			; **  LCD support functions  
65c6			; **********************************************************************  
65c6			  
65c6			; Initialise alphanumeric LCD module  
65c6			; LCD control register codes:  
65c6			;   DL   0 = 4-bit mode        1 = 8-bit mode  
65c6			;   N    0 = 1-line mode       1 = 2-line mode  
65c6			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
65c6			;   D    0 = Display off       1 = Display on  
65c6			;   C    0 = Cursor off        1 = Cursor on  
65c6			;   B    0 = Blinking off      1 = Blinking on  
65c6			;   ID   0 = Decrement mode    1 = Increment mode  
65c6			;   SH   0 = Entire shift off  1 = Entire shift on  
65c6 3e 28		fLCD_Init:  LD   A, 40  
65c8 cd ed 66		            CALL LCDDelay       ;Delay 40ms after power up  
65cb			; For reliable reset set 8-bit mode - 3 times  
65cb cd bd 66		            CALL WrFn8bit       ;Function = 8-bit mode  
65ce cd bd 66		            CALL WrFn8bit       ;Function = 8-bit mode  
65d1 cd bd 66		            CALL WrFn8bit       ;Function = 8-bit mode  
65d4			; Set 4-bit mode  
65d4 cd b9 66		            CALL WrFn4bit       ;Function = 4-bit mode  
65d7 cd eb 66		            CALL LCDDelay1      ;Delay 37 us or more  
65da			; Function set  
65da 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
65dc cd ef 65		            CALL fLCD_Inst      ;2 line, display on  
65df			; Display On/Off control  
65df 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
65e1 cd ef 65		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
65e4			; Display Clear  
65e4 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
65e6 cd ef 65		            CALL fLCD_Inst      ;Clear display  
65e9			; Entry mode  
65e9 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
65eb cd ef 65		            CALL fLCD_Inst      ;Increment mode, shift off  
65ee			; Display module now initialised  
65ee c9			            RET  
65ef			; ok to here  
65ef			  
65ef			; Write instruction to LCD  
65ef			;   On entry: A = Instruction byte to be written  
65ef			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65ef f5			fLCD_Inst:  PUSH AF  
65f0 f5			            PUSH AF  
65f1 cd 03 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
65f4 f1			            POP  AF  
65f5 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
65f6 17			            RLA  
65f7 17			            RLA  
65f8 17			            RLA  
65f9 cd 03 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
65fc 3e 02		            LD   A, 2  
65fe cd ed 66		            CALL LCDDelay       ;Delay 2 ms to complete   
6601 f1			            POP  AF  
6602 c9			            RET  
6603			Wr4bits:   
6603 f5					push af  
6604 3a d7 f8				ld a, (display_lcde1e2)  
6607 fe 00				cp 0     ; e  
6609 20 10				jr nz, .wea2	  
660b f1					pop af  
660c e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
660e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6610 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
6612 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
6614 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6616 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
6618 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
661a c9			            RET  
661b f1			.wea2:		pop af  
661c e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
661e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6620 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
6622 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
6624 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6626 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
6628 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
662a c9			            RET  
662b			  
662b			  
662b			; Write data to LCD  
662b			;   On entry: A = Data byte to be written  
662b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
662b f5			fLCD_Data:  PUSH AF  
662c f5			            PUSH AF  
662d cd 3f 66		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6630 f1			            POP  AF  
6631 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6632 17			            RLA  
6633 17			            RLA  
6634 17			            RLA  
6635 cd 3f 66		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6638 3e 96		            LD   A, 150  
663a 3d			Wait:      DEC  A              ;Wait a while to allow data   
663b 20 fd		            JR   NZ, Wait      ;  write to complete  
663d f1			            POP  AF  
663e c9			            RET  
663f			Wr4bitsa:     
663f f5					push af  
6640 3a d7 f8				ld a, (display_lcde1e2)  
6643 fe 00				cp 0     ; e1  
6645 20 16				jr nz, .we2	  
6647 f1					pop af  
6648 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
664a cb d7		            SET  kLCDBitRS, A  
664c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
664e cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
6650 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
6652 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6654 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
6656 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6658 cb 97		            RES  kLCDBitRS, A  
665a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
665c c9			            RET  
665d f1			.we2:		pop af  
665e e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6660 cb d7		            SET  kLCDBitRS, A  
6662 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6664 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
6666 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
6668 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
666a cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
666c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
666e cb 97		            RES  kLCDBitRS, A  
6670 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6672 c9			            RET  
6673			  
6673			  
6673			; Position cursor to specified location  
6673			;   On entry: A = Cursor position  
6673			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6673 f5			fLCD_Pos:   PUSH AF  
6674					; at this point set the E1 or E2 flag depending on position  
6674			  
6674 c5					push bc  
6675			;		push af  
6675 06 00				ld b, 0  
6677 4f					ld c, a  
6678 3e 4f				ld a, kLCD_Line3-1  
667a b7			 		or a      ;clear carry flag  
667b 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
667c 38 04				jr c, .pe1  
667e			  
667e					; E selection  
667e cb 80				res 0, b         ; bit 0 unset e  
6680			;		pop af    ; before line 3 so recover orig pos  
6680			;		ld c, a    ; save for poking back  
6680 18 06				jr .peset	          
6682			.pe1:          	; E2 selection  
6682 cb c0				set 0, b         ; bit 0 set e1  
6684 79					ld a, c  
6685 de 4f				sbc a, kLCD_Line3-1  
6687 4f					ld c, a	         ; save caculated offset  
6688			;		pop af     ; bin this original value now we have calculated form  
6688			  
6688			.peset:		; set bit  
6688 78					ld a, b  
6689 32 d7 f8				ld (display_lcde1e2), a 	  
668c 79					ld a, c  
668d c1					pop bc  
668e			  
668e f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6690 cd ef 65		            CALL fLCD_Inst      ;Write instruction to LCD  
6693 f1			            POP  AF  
6694 c9			            RET  
6695			  
6695			  
6695			; Output text string to LCD  
6695			;   On entry: DE = Pointer to null terminated text string  
6695			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6695 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6696 b7			            OR   A              ;Null terminator?  
6697 c8			            RET  Z              ;Yes, so finished  
6698 cd 2b 66		            CALL fLCD_Data      ;Write character to display  
669b 13			            INC  DE             ;Point to next character  
669c 18 f7		            JR   fLCD_Str       ;Repeat  
669e c9					ret  
669f			  
669f			; Define custom character  
669f			;   On entry: A = Character number (0 to 7)  
669f			;             DE = Pointer to character bitmap data  
669f			;   On exit:  A = Next character number  
669f			;             DE = Next location following bitmap  
669f			;             BC HL IX IY I AF' BC' DE' HL' preserved  
669f			; Character is   
669f c5			fLCD_Def:   PUSH BC  
66a0 f5			            PUSH AF  
66a1 07			            RLCA                ;Calculate location  
66a2 07			            RLCA                ;  for bitmap data  
66a3 07			            RLCA                ;  = 8 x CharacterNumber  
66a4 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
66a6 cd ef 65		            CALL fLCD_Inst      ;Write instruction to LCD  
66a9 06 00		            LD   B, 0  
66ab 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
66ac cd 2b 66		            CALL fLCD_Data      ;Write byte to display  
66af 13			            INC  DE             ;Point to next byte  
66b0 04			            INC  B              ;Count bytes  
66b1 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
66b3 28 f6		            JR   Z, Loop       ;No, so repeat  
66b5 f1			            POP  AF  
66b6 3c			            INC  A              ;Increment character number  
66b7 c1			            POP  BC  
66b8 c9			            RET  
66b9			  
66b9			  
66b9			; **********************************************************************  
66b9			; **  Private functions  
66b9			; **********************************************************************  
66b9			  
66b9			; Write function to LCD  
66b9			;   On entry: A = Function byte to be written  
66b9			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66b9 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
66bb 18 02		            JR   WrFunc  
66bd 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
66bf f5			WrFunc:     PUSH AF  
66c0 f5					push af  
66c1 3a d7 f8				ld a, (display_lcde1e2)  
66c4 fe 00				cp 0     ; e1  
66c6 20 0f				jr nz, .wfea2	  
66c8 f1					pop af  
66c9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66cb cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
66cd cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
66cf d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66d1 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
66d3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66d5 18 0d			jr .wfskip  
66d7 f1			.wfea2:		pop af  
66d8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66da cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
66dc cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
66de d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66e0 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
66e2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66e4 3e 05		.wfskip:            LD  A, 5  
66e6 cd ed 66		            CALL LCDDelay       ;Delay 5 ms to complete  
66e9 f1			            POP  AF  
66ea c9			            RET  
66eb			  
66eb			  
66eb			; Delay in milliseconds  
66eb			;   On entry: A = Number of milliseconds delay  
66eb			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66eb 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
66ed d5			LCDDelay:   PUSH DE  
66ee 5f			            LD   E, A           ;Delay by 'A' ms  
66ef 16 00		            LD   D, 0  
66f1 cd 3a 0a		            CALL aDelayInMS  
66f4 d1			            POP  DE  
66f5 c9			            RET  
66f6			  
66f6			  
66f6			testlcd:  
66f6 3e 00			ld a, kLCD_Line1  
66f8 cd 73 66			call fLCD_Pos  
66fb 06 28			ld b, 40  
66fd 11 2b 67			ld de, .ttext1  
6700 cd be 65			call write_len_string  
6703			  
6703 3e 28			ld a, kLCD_Line2  
6705 cd 73 66			call fLCD_Pos  
6708 06 28			ld b, 40  
670a 11 54 67			ld de, .ttext2  
670d cd be 65			call write_len_string  
6710 3e 50			ld a, kLCD_Line3  
6712 cd 73 66			call fLCD_Pos  
6715 06 28			ld b, 40  
6717 11 7d 67			ld de, .ttext3  
671a cd be 65			call write_len_string  
671d 3e 78			ld a, kLCD_Line4  
671f cd 73 66			call fLCD_Pos  
6722 06 28			ld b, 40  
6724 11 a6 67			ld de, .ttext4  
6727 cd be 65			call write_len_string  
672a			  
672a 76				halt  
672b			  
672b			  
672b .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
6754 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
677d .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
67a6 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
67cf			   
67cf			  
67cf			  
67cf			; eof  
67cf			  
# End of file firmware_lcd_4x40.asm
67cf			;include "firmware_lcd_4x20.asm" 
67cf			include "firmware_key_5x10.asm" 
67cf			; 5 x 10 decade counter scanner  
67cf			  
67cf			  
67cf			; TODO do cursor shape change for shift keys  
67cf			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
67cf			  
67cf			  
67cf			; bit mask for each scan column and row for teing the matrix  
67cf			  
67cf			  
67cf			key_init:  
67cf			  
67cf			; SCMonAPI functions used  
67cf			  
67cf			; Alphanumeric LCD functions used  
67cf			; no need to specify specific functions for this module  
67cf			  
67cf			  
67cf 3e cf		            LD   A, 11001111b  
67d1 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
67d3			;            LD   A, 00000000b  
67d3 3e 1f		            LD   A, 00011111b  
67d5 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
67d7			  
67d7			  
67d7				; TODO Configure cursor shapes  
67d7			  
67d7				; Load cursor shapes   
67d7 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
67d9 11 e9 67		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
67dc 06 02		            LD   B, 2           ;Number of characters to define  
67de cd 9f 66		.DefLoop:   CALL fLCD_Def       ;Define custom character  
67e1 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
67e3			  
67e3 3e 01				ld a, 1  
67e5 32 d0 f8			ld (cursor_shape),a  
67e8 c9				ret  
67e9			  
67e9			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
67e9			; Up to 8 custom characters can be defined  
67e9			.cursor_shapes:      
67e9			;; Character 0x00 = Normal  
67e9 1f			            DB  11111b  
67ea 1f			            DB  11111b  
67eb 1f			            DB  11111b  
67ec 1f			            DB  11111b  
67ed 1f			            DB  11111b  
67ee 1f			            DB  11111b  
67ef 1f			            DB  11111b  
67f0 1f			            DB  11111b  
67f1			;; Character 0x01 = Modifier  
67f1 1f			            DB  11111b  
67f2 1b			            DB  11011b  
67f3 1b			            DB  11011b  
67f4 1b			            DB  11011b  
67f5 1b			            DB  11011b  
67f6 1f			            DB  11111b  
67f7 1b			            DB  11011b  
67f8 1f			            DB  11111b  
67f9			  
67f9			  
67f9			  
67f9			  
67f9			; Display custom character 0  
67f9			;            LD   A, kLCD_Line1+14  
67f9			;            CALL fLCD_Pos       ;Position cursor to location in A  
67f9			;            LD   A, 0  
67f9			;            CALL fLCD_Data      ;Write character in A at cursor  
67f9			  
67f9			; Display custom character 1  
67f9			;            LD   A, kLCD_Line2+14  
67f9			;            CALL fLCD_Pos      ;Position cursor to location in A  
67f9			;            LD   A, 1  
67f9			;            CALL fLCD_Data     ;Write character in A at cursor  
67f9			  
67f9			; keyboard scanning   
67f9			  
67f9			; character in from keyboard  
67f9			  
67f9			; mapping for the pcb layout  
67f9			  
67f9			.matrix_to_char:  
67f9 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
6804 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
680f 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
681a 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
6825 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
6830			.matrix_to_shift:  
6830			  
6830 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
683b .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
6846 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
6851 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
685c .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
6867			  
6867			.matrix_to_symbolshift:  
6867			  
6867 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6872 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
687d 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
6888			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
6888 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
6893 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
689e			  
689e			  
689e			  
689e			; mapping for a simple straight through breadboard layout  
689e			  
689e			;.matrix_to_char:  
689e			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
689e			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
689e			;		db "asdfghjkl",KEY_CR,0  
689e			;		db "qwertyuiop",0  
689e			;		 db "1234567890",0  
689e			;.matrix_to_shift:  
689e			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
689e			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
689e			;		db "ASDFGHJKL",KEY_CR,0  
689e			;		db "QWERTYUIOP",0  
689e			;		 db "!",'"',"#$%^&*()",0  
689e			;.matrix_to_symbolshift:  
689e			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
689e			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
689e			;		db "_?*fghjk=",KEY_CR,0  
689e			;		db "-/+*[]{}@#",0  
689e			;		 db "1234567890",0  
689e			  
689e			;.matrix_to_char: db "D#0*C987B654A321"  
689e			  
689e			  
689e				  
689e			  
689e			; add cin and cin_wait  
689e			  
689e cd af 68		cin_wait: 	call cin  
68a1						if DEBUG_KEYCINWAIT  
68a1							push af  
68a1							  
68a1							ld hl,key_repeat_ct  
68a1							ld (hl),a  
68a1							inc hl  
68a1							call hexout  
68a1							ld hl,key_repeat_ct+3  
68a1							ld a,0  
68a1							ld (hl),a  
68a1			  
68a1							    LD   A, kLCD_Line1+11  
68a1							    CALL fLCD_Pos       ;Position cursor to location in A  
68a1							    LD   DE, key_repeat_ct  
68a1							    ;LD   DE, MsgHello  
68a1							    CALL fLCD_Str       ;Display string pointed to by DE  
68a1			  
68a1			  
68a1			  
68a1							pop af  
68a1						endif  
68a1 fe 00			cp 0  
68a3 28 f9			jr z, cin_wait   ; block until key press  
68a5			  
68a5							if DEBUG_KEYCINWAIT  
68a5								push af  
68a5			  
68a5								ld a, 'A'	  
68a5								ld hl,key_repeat_ct  
68a5								ld (hl),a  
68a5								inc hl  
68a5								ld a,0  
68a5								ld (hl),a  
68a5			  
68a5								    LD   A, kLCD_Line2+11  
68a5								    CALL fLCD_Pos       ;Position cursor to location in A  
68a5								    LD   DE, key_repeat_ct  
68a5								    ;LD   DE, MsgHello  
68a5								    CALL fLCD_Str       ;Display string pointed to by DE  
68a5			  
68a5							call delay500ms  
68a5			  
68a5								pop af  
68a5							endif  
68a5 f5				push af   ; save key pressed  
68a6			  
68a6			.cin_wait1:	  
68a6							if DEBUG_KEYCINWAIT  
68a6								push af  
68a6			  
68a6								ld a, 'b'	  
68a6								ld hl,key_repeat_ct  
68a6								ld (hl),a  
68a6								inc hl  
68a6								ld a,0  
68a6								ld (hl),a  
68a6			  
68a6								    LD   A, kLCD_Line2+11  
68a6								    CALL fLCD_Pos       ;Position cursor to location in A  
68a6								    LD   DE, key_repeat_ct  
68a6								    ;LD   DE, MsgHello  
68a6								    CALL fLCD_Str       ;Display string pointed to by DE  
68a6			  
68a6			  
68a6							call delay500ms  
68a6			  
68a6								pop af  
68a6							endif  
68a6			  
68a6 cd af 68		call cin  
68a9 fe 00			cp 0  
68ab 20 f9			jr nz, .cin_wait1  	; wait for key release  
68ad			if DEBUG_KEYCINWAIT  
68ad				push af  
68ad			  
68ad				ld a, '3'	  
68ad				ld hl,key_repeat_ct  
68ad				ld (hl),a  
68ad				inc hl  
68ad				ld a,0  
68ad				ld (hl),a  
68ad			  
68ad			            LD   A, kLCD_Line2+11  
68ad			            CALL fLCD_Pos       ;Position cursor to location in A  
68ad			            LD   DE, key_repeat_ct  
68ad			            ;LD   DE, MsgHello  
68ad			            CALL fLCD_Str       ;Display string pointed to by DE  
68ad			  
68ad			  
68ad			call delay500ms  
68ad			  
68ad				pop af  
68ad			endif  
68ad			  
68ad f1				pop af   ; get key  
68ae c9				ret  
68af			  
68af			  
68af cd c3 68		cin: 	call .mtoc  
68b2			  
68b2			if DEBUG_KEYCIN  
68b2				push af  
68b2				  
68b2				ld hl,key_repeat_ct  
68b2				ld (hl),a  
68b2				inc hl  
68b2				call hexout  
68b2				ld hl,key_repeat_ct+3  
68b2				ld a,0  
68b2				ld (hl),a  
68b2			  
68b2			            LD   A, kLCD_Line3+15  
68b2			            CALL fLCD_Pos       ;Position cursor to location in A  
68b2			            LD   DE, key_repeat_ct  
68b2			            ;LD   DE, MsgHello  
68b2			            CALL fLCD_Str       ;Display string pointed to by DE  
68b2			  
68b2			  
68b2			call delay500ms  
68b2			  
68b2				pop af  
68b2			endif  
68b2			  
68b2			  
68b2				; no key held  
68b2 fe 00			cp 0  
68b4 c8				ret z  
68b5			  
68b5			if DEBUG_KEYCIN  
68b5				push af  
68b5			  
68b5				ld a, '1'	  
68b5				ld hl,key_repeat_ct  
68b5				ld (hl),a  
68b5				inc hl  
68b5				ld a,0  
68b5				ld (hl),a  
68b5			  
68b5			            LD   A, kLCD_Line4+15  
68b5			            CALL fLCD_Pos       ;Position cursor to location in A  
68b5			            LD   DE, key_repeat_ct  
68b5			            ;LD   DE, MsgHello  
68b5			            CALL fLCD_Str       ;Display string pointed to by DE  
68b5			  
68b5			  
68b5			call delay500ms  
68b5			  
68b5				pop af  
68b5			endif  
68b5			  
68b5				; stop key bounce  
68b5			  
68b5 32 88 fb			ld (key_held),a		 ; save it  
68b8 47				ld b, a  
68b9			  
68b9 c5			.cina1:	push bc  
68ba			if DEBUG_KEYCIN  
68ba				push af  
68ba			  
68ba				ld hl,key_repeat_ct  
68ba				inc hl  
68ba				call hexout  
68ba				ld hl,key_repeat_ct+3  
68ba				ld a,0  
68ba				ld (hl),a  
68ba				ld hl,key_repeat_ct  
68ba				ld a, '2'	  
68ba				ld (hl),a  
68ba			  
68ba			            LD   A, kLCD_Line4+15  
68ba			            CALL fLCD_Pos       ;Position cursor to location in A  
68ba			            LD   DE, key_repeat_ct  
68ba			            ;LD   DE, MsgHello  
68ba			            CALL fLCD_Str       ;Display string pointed to by DE  
68ba			  
68ba				pop af  
68ba			endif  
68ba cd c3 68			call .mtoc  
68bd c1				pop bc  
68be b8				cp b  
68bf 28 f8			jr z, .cina1  
68c1 78				ld a,b		  
68c2			if DEBUG_KEYCIN  
68c2				push af  
68c2			  
68c2				ld hl,key_repeat_ct  
68c2				inc hl  
68c2				call hexout  
68c2				ld hl,key_repeat_ct+3  
68c2				ld a,0  
68c2				ld (hl),a  
68c2				ld hl,key_repeat_ct  
68c2				ld a, '3'	  
68c2				ld (hl),a  
68c2			  
68c2			            LD   A, kLCD_Line4+15  
68c2			            CALL fLCD_Pos       ;Position cursor to location in A  
68c2			            LD   DE, key_repeat_ct  
68c2			            ;LD   DE, MsgHello  
68c2			            CALL fLCD_Str       ;Display string pointed to by DE  
68c2			  
68c2				pop af  
68c2			endif  
68c2 c9				ret  
68c3			  
68c3			; detect keyboard modifier key press and apply new overlay to the face key held  
68c3			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
68c3			  
68c3			;.cin_map_modifier:   
68c3			;	ld a, (hl)  
68c3			;	and 255  
68c3			;	ret NZ		; modifier key not flagged  
68c3			;  
68c3			;	; get key face  
68c3			;  
68c3			;	ld b,(key_face_held)  
68c3			;  
68c3			;	ld b, key_cols * key_rows  
68c3			;  
68c3			;	push de  
68c3			;	pop hl  
68c3			;  
68c3			;.mmod1: ld a,(hl)   ; get map test  
68c3			;	cp b  
68c3			;	jr z, .mmod2  
68c3			;  
68c3			;  
68c3			;  
68c3			;.mmod2: inc hl    ;   
68c3			;  
68c3			;	  
68c3			;  
68c3			;	  
68c3			;  
68c3			;	ld hl,key_actual_pressed  
68c3			;	ld (hl),a,  
68c3			;	ret  
68c3			  
68c3			; map matrix key held to char on face of key  
68c3			  
68c3			.mtoc:  
68c3			  
68c3			; test decade counter strobes  
68c3			  
68c3			;.decadetest1:  
68c3			  
68c3			; reset counter  
68c3			;ld a, 128  
68c3			;out (portbdata),a  
68c3			  
68c3			  
68c3			;ld b, 5  
68c3			;.dec1:  
68c3			;ld a, 0  
68c3			;out (portbdata),a  
68c3			;call delay1s  
68c3			  
68c3			;ld a, 32  
68c3			;out (portbdata),a  
68c3			;call delay1s  
68c3			;call delay1s  
68c3			;call delay1s  
68c3			;  
68c3			;ld a, 64+32  
68c3			;out (portbdata),a  
68c3			;call delay1s  
68c3			;;djnz .dec1  
68c3			;  
68c3			;jp .decadetest1  
68c3			  
68c3			  
68c3			  
68c3			  
68c3			  
68c3			  
68c3			  
68c3			  
68c3			  
68c3			  
68c3				; scan keyboard matrix and generate raw scan map  
68c3 cd 56 69			call matrix  
68c6			  
68c6				; reuse c bit 0 left modifer button - ie shift  
68c6			        ; reuse c bit 1 for right modifer button - ie symbol shift  
68c6				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
68c6			  
68c6 0e 00			ld c, 0  
68c8			  
68c8				; TODO set flags for modifer key presses   
68c8				; TODO do a search for modifer key...  
68c8			  
68c8				;ld hl,keyscan_table_row4  
68c8 21 e7 fb			ld hl,keyscan_table_row2  
68cb			  
68cb 7e				ld a, (hl)  
68cc fe 23			cp '#'  
68ce 20 07			jr nz, .nextmodcheck  
68d0 cb c1			set 0, c  
68d2 21 30 68			ld hl, .matrix_to_shift  
68d5 18 21			jr .dokeymap  
68d7				; TODO for now igonre  
68d7			.nextmodcheck:  
68d7 21 dc fb			ld hl,keyscan_table_row3  
68da			  
68da 7e				ld a, (hl)  
68db fe 23			cp '#'  
68dd 20 07			jr nz, .nextmodcheck2  
68df cb c9			set 1, c   
68e1 21 67 68			ld hl, .matrix_to_symbolshift  
68e4 18 12			jr .dokeymap  
68e6			.nextmodcheck2:  
68e6 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
68e9			  
68e9 7e				ld a, (hl)  
68ea fe 23			cp '#'  
68ec 20 07			jr nz, .donemodcheck  
68ee cb c9			set 1, c   
68f0 21 30 68			ld hl, .matrix_to_shift  
68f3 18 03			jr .dokeymap  
68f5			  
68f5				; no modifer found so just map to normal keys  
68f5				; get mtoc map matrix to respective keys  
68f5			;	ld hl, .matrix_to_char  
68f5			;	ld hl, .matrix_to_char  
68f5			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
68f5			;	ld a, KEY_SHIFT  
68f5			;	call findchar  
68f5			;  
68f5			;	; got offset to key modifer in b  
68f5			;  
68f5			;	ld hl,keyscan_table_row5  
68f5			;  
68f5			;	ld a,b  
68f5			;	call addatohl  
68f5			;	ld a,(hl)  
68f5			;  
68f5			;	cp '#'  
68f5			;	jr nz, .nextmodcheck  
68f5			;	set 0, c  
68f5			;	ld hl, .matrix_to_char  
68f5			;	jr .dokeymap  
68f5			;	; TODO for now igonre  
68f5			;.nextmodcheck:  
68f5			;	ld hl, .matrix_to_symbolshift  
68f5			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
68f5			;	ld a, KEY_SYMBOLSHIFT  
68f5			;	call findchar  
68f5			;  
68f5			;  
68f5			;	; got offset to key modifer in b  
68f5			;  
68f5			;	ld hl,keyscan_table_row5  
68f5			;  
68f5			;	ld a,b  
68f5			;	call addatohl  
68f5			;	ld a,(hl)  
68f5			;  
68f5			;	cp '#'  
68f5			;	jr nz, .donemodcheck  
68f5			;	set 1, c   
68f5			;	ld hl, .matrix_to_symbolshift  
68f5			;	jr .dokeymap  
68f5			  
68f5			  
68f5			  
68f5			.donemodcheck:  
68f5				; no modifer found so just map to normal keys  
68f5				; get mtoc map matrix to respective keys  
68f5 21 f9 67			ld hl, .matrix_to_char  
68f8			  
68f8			.dokeymap:  
68f8				;ld (key_fa), c   
68f8 cd 11 69			call .mapkeys  
68fb			  
68fb			  
68fb			if DEBUG_KEY  
68fb			  
68fb			; Display text on first line  
68fb			            LD   A, kLCD_Line1  
68fb			            CALL fLCD_Pos       ;Position cursor to location in A  
68fb			            LD   DE, keyscan_table_row1  
68fb			            ;LD   DE, MsgHello  
68fb			            CALL fLCD_Str       ;Display string pointed to by DE  
68fb			  
68fb			; Display text on second line  
68fb			            LD   A, kLCD_Line2  
68fb			            CALL fLCD_Pos       ;Position cursor to location in A  
68fb			            LD   DE, keyscan_table_row2  
68fb			            CALL fLCD_Str       ;Display string pointed to by DE  
68fb			            LD   A, kLCD_Line3  
68fb			            CALL fLCD_Pos       ;Position cursor to location in A  
68fb			            LD   DE, keyscan_table_row3  
68fb			            CALL fLCD_Str       ;Display string pointed to by DE  
68fb			            LD   A, kLCD_Line4  
68fb			            CALL fLCD_Pos       ;Position cursor to location in A  
68fb			            LD   DE, keyscan_table_row4  
68fb			            CALL fLCD_Str       ;Display string pointed to by DE  
68fb			            LD   A, kLCD_Line1+10  
68fb			            CALL fLCD_Pos       ;Position cursor to location in A  
68fb			            LD   DE, keyscan_table_row5  
68fb			            CALL fLCD_Str       ;Display string pointed to by DE  
68fb			  
68fb				;call delay250ms  
68fb			endif  
68fb			;	jp testkey  
68fb			  
68fb			; get first char reported  
68fb			  
68fb 21 c6 fb			ld hl,keyscan_table_row5  
68fe			  
68fe				;ld b, 46   ; 30 keys to remap + 8 nulls   
68fe 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6900			.findkey:  
6900 7e				ld a,(hl)  
6901 fe 00			cp 0  
6903 28 04			jr z, .nextkey  
6905 fe 7e			cp KEY_MATRIX_NO_PRESS  
6907 20 06			jr nz, .foundkey  
6909			.nextkey:  
6909 23				inc hl  
690a 10 f4			djnz .findkey  
690c 3e 00			ld a,0  
690e c9				ret  
690f			.foundkey:  
690f 7e				ld a,(hl)  
6910 c9				ret  
6911				  
6911			  
6911			; convert the raw key map given hl for destination key  
6911			.mapkeys:  
6911 11 c6 fb			ld de,keyscan_table_row5  
6914			  
6914 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6916			.remap:  
6916 1a				ld a,(de)  
6917 fe 23			cp '#'  
6919 20 02			jr nz, .remapnext  
691b				;CALLMONITOR  
691b 7e				ld a,(hl)  
691c 12				ld (de),a  
691d			  
691d			  
691d			  
691d			.remapnext:  
691d 23				inc hl  
691e 13				inc de  
691f 10 f5			djnz .remap  
6921				  
6921 c9				ret  
6922			  
6922			  
6922			  
6922			.mtocold2:  
6922			  
6922			;	; flag if key D is held down and remove from reporting  
6922			;	ld bc, .key_map_fd    
6922			;	ld hl, keyscan_table  
6922			;	ld de, key_fd  
6922			;	call .key_shift_hold  
6922			;	cp 255  
6922			;	jr z, .cinmap  
6922			;	; flag if key C is held down and remove from reporting  
6922			;	ld bc, .key_map_fc    
6922			;	ld hl, keyscan_table+key_cols  
6922			;	ld de, key_fc  
6922			;	call .key_shift_hold  
6922			;	cp 255  
6922			;	jr z, .cinmap  
6922			;	; flag if key B is held down and remove from reporting  
6922			;	ld bc, .key_map_fb    
6922			;	ld hl, keyscan_table+(key_cols*2)  
6922			;	ld de, key_fb  
6922			;	call .key_shift_hold  
6922			;	cp 255  
6922			;	jr z, .cinmap  
6922			;	; flag if key A is held down and remove from reporting  
6922			;	ld bc, .key_map_fa    
6922			;	ld hl, keyscan_table+(key_cols*3)  
6922			;	ld de, key_fa  
6922			;	call .key_shift_hold  
6922			;	cp 255  
6922			;	jr z, .cinmap  
6922			  
6922 11 f9 67			ld de, .matrix_to_char  
6925			  
6925			  
6925			.cinmap1:   
6925				if DEBUG_KEY  
6925			            LD   A, kLCD_Line4  
6925			            CALL fLCD_Pos       ;Position cursor to location in A  
6925					push de  
6925			            LD   DE, keyscan_table  
6925			            CALL fLCD_Str       ;Display string pointed to by DE  
6925					pop de  
6925				endif  
6925			  
6925				; scan key matrix table for any held key  
6925			  
6925				; de holds either the default matrix or one selected above  
6925			  
6925 21 93 fb			ld hl, keyscan_table  
6928 06 32			ld b,key_cols*key_rows  
692a			  
692a 7e			.cin11:	ld a,(hl)  
692b fe 23			cp '#'  
692d 28 08			jr z, .cinhit1  
692f 23				inc hl  
6930 13				inc de  
6931 05				dec b  
6932 20 f6			jr nz, .cin11  
6934				; no key found held  
6934 3e 00			ld a,0  
6936 c9				ret  
6937 d5			.cinhit1: push de  
6938 e1				pop hl  
6939 7e				ld a,(hl)  
693a c9				ret  
693b			  
693b			; flag a control key is held   
693b			; hl is key pin, de is flag indicator  
693b			  
693b			.key_shift_hold1:  
693b c5				push bc  
693c 3e 01			ld a, 1  
693e 32 d0 f8			ld (cursor_shape),a  
6941 06 00			ld b, 0  
6943 7e				ld a, (hl)  
6944 fe 2e			cp '.'  
6946 28 0a			jr z, .key_shift11  
6948 06 ff			ld b, 255  
694a 3e 2b			ld a, '+'    ; hide key from later scans  
694c 77				ld (hl),a  
694d 3e 02			ld a, 2  
694f 32 d0 f8			ld (cursor_shape),a  
6952			.key_shift11:  
6952				; write flag indicator  
6952 78				ld a,b  
6953 12				ld (de),a  
6954			  
6954 d1				pop de    ; de now holds the key map ptr  
6955 c9				ret  
6956			  
6956				  
6956			  
6956			; scans keyboard matrix and flags key press in memory array	  
6956				  
6956			matrix:  
6956				;call matrix  
6956				; TODO optimise the code....  
6956			  
6956			  
6956			;ld hl, keyscan_table_row1  
6956			;ld de, keyscan_table_row1+1  
6956			;ld bc,46  
6956			;ld a,KEY_MATRIX_NO_PRESS  
6956			;ldir  
6956			  
6956			  
6956			  
6956			; reset counter  
6956 3e 80		ld a, 128  
6958 d3 c1		out (portbdata),a  
695a			  
695a 06 0a		ld b, 10  
695c 0e 00		ld c, 0       ; current clock toggle  
695e			  
695e			.colscan:  
695e			  
695e			; set current column  
695e			; disable clock enable and set clock low  
695e			  
695e			;ld a, 0  
695e			;out (portbdata),a  
695e			  
695e			; For each column scan for switches  
695e			  
695e c5			push bc  
695f 21 89 fb		ld hl, keyscan_scancol  
6962 cd 6b 6a		call .rowscan  
6965 c1			pop bc  
6966			  
6966			  
6966			; get back current column  
6966			  
6966			; translate the row scan  
6966			  
6966			;   
6966			; row 1  
6966			  
6966 78			ld a,b  
6967			  
6967 21 fc fb		LD   hl, keyscan_table_row1+10  
696a			  
696a cd 1b 0d		call subafromhl  
696d			;call addatohl  
696d			  
696d 11 89 fb		ld de, keyscan_scancol  
6970			  
6970 1a			ld a,(de)  
6971 77			ld (hl),a  
6972			  
6972			  
6972			  
6972			  
6972			; row 2  
6972			  
6972 78			ld a,b  
6973			  
6973 21 f1 fb		LD   hl, keyscan_table_row2+10  
6976			  
6976			;call addatohl  
6976 cd 1b 0d		call subafromhl  
6979			  
6979			  
6979 11 8a fb		ld de, keyscan_scancol+1  
697c			  
697c 1a			ld a,(de)  
697d 77			ld (hl),a  
697e			  
697e			  
697e			; row 3  
697e			  
697e 78			ld a,b  
697f			  
697f 21 e6 fb		LD   hl, keyscan_table_row3+10  
6982			  
6982			;call addatohl  
6982 cd 1b 0d		call subafromhl  
6985			  
6985 11 8b fb		ld de, keyscan_scancol+2  
6988			  
6988 1a			ld a,(de)  
6989 77			ld (hl),a  
698a			  
698a			  
698a			  
698a			; row 4  
698a			  
698a 78			ld a,b  
698b			  
698b 21 db fb		LD   hl, keyscan_table_row4+10  
698e			  
698e			;call addatohl  
698e cd 1b 0d		call subafromhl  
6991			  
6991 11 8c fb		ld de, keyscan_scancol+3  
6994			  
6994 1a			ld a,(de)  
6995 77			ld (hl),a  
6996			  
6996			; row 5  
6996			  
6996 78			ld a,b  
6997			  
6997 21 d0 fb		LD   hl, keyscan_table_row5+10  
699a			  
699a			;call addatohl  
699a cd 1b 0d		call subafromhl  
699d			  
699d 11 8d fb		ld de, keyscan_scancol+4  
69a0			  
69a0 1a			ld a,(de)  
69a1 77			ld (hl),a  
69a2			  
69a2			; handshake next column  
69a2			  
69a2			  
69a2 3e 40		ld a, 64  
69a4 d3 c1		out (portbdata),a  
69a6			  
69a6 3e 00		ld a, 0  
69a8 d3 c1		out (portbdata),a  
69aa			  
69aa			; toggle clk and move to next column  
69aa			;ld a, 64  
69aa			;cp c  
69aa			;  
69aa			;jr z, .coltoglow  
69aa			;ld c, a  
69aa			;jr .coltog  
69aa			;.coltoglow:  
69aa			;ld c, 0  
69aa			;.coltog:  
69aa			;ld a, c  
69aa			;out (portbdata),a  
69aa			  
69aa 10 b2		djnz .colscan  
69ac			  
69ac 3e 0a		ld a,10  
69ae 21 f2 fb		LD   hl, keyscan_table_row1  
69b1 cd 09 0d		call addatohl  
69b4 3e 00		ld a, 0  
69b6 77			ld (hl), a  
69b7			  
69b7			  
69b7 3e 0a		ld a,10  
69b9 21 e7 fb		LD   hl, keyscan_table_row2  
69bc cd 09 0d		call addatohl  
69bf 3e 00		ld a, 0  
69c1 77			ld (hl), a  
69c2			  
69c2 3e 0a		ld a,10  
69c4 21 dc fb		LD   hl, keyscan_table_row3  
69c7 cd 09 0d		call addatohl  
69ca 3e 00		ld a, 0  
69cc 77			ld (hl), a  
69cd			  
69cd 3e 0a		ld a,10  
69cf 21 d1 fb		LD   hl, keyscan_table_row4  
69d2 cd 09 0d		call addatohl  
69d5 3e 00		ld a, 0  
69d7 77			ld (hl), a  
69d8			  
69d8 3e 0a		ld a,10  
69da 21 c6 fb		LD   hl, keyscan_table_row5  
69dd cd 09 0d		call addatohl  
69e0 3e 00		ld a, 0  
69e2 77			ld (hl), a  
69e3			  
69e3			if DEBUG_KEY_MATRIX  
69e3			  
69e3			; Display text on first line  
69e3			            LD   A, kLCD_Line1  
69e3			            CALL fLCD_Pos       ;Position cursor to location in A  
69e3			            LD   DE, keyscan_table_row1  
69e3			            ;LD   DE, MsgHello  
69e3			            CALL fLCD_Str       ;Display string pointed to by DE  
69e3			  
69e3			; Display text on second line  
69e3			            LD   A, kLCD_Line2  
69e3			            CALL fLCD_Pos       ;Position cursor to location in A  
69e3			            LD   DE, keyscan_table_row2  
69e3			            CALL fLCD_Str       ;Display string pointed to by DE  
69e3			            LD   A, kLCD_Line3  
69e3			            CALL fLCD_Pos       ;Position cursor to location in A  
69e3			            LD   DE, keyscan_table_row3  
69e3			            CALL fLCD_Str       ;Display string pointed to by DE  
69e3			            LD   A, kLCD_Line4  
69e3			            CALL fLCD_Pos       ;Position cursor to location in A  
69e3			            LD   DE, keyscan_table_row4  
69e3			            CALL fLCD_Str       ;Display string pointed to by DE  
69e3			            LD   A, kLCD_Line4+10  
69e3			            CALL fLCD_Pos       ;Position cursor to location in A  
69e3			            LD   DE, keyscan_table_row5  
69e3			            CALL fLCD_Str       ;Display string pointed to by DE  
69e3			  
69e3			;call delay250ms  
69e3				jp matrix  
69e3			endif  
69e3 c9			ret  
69e4			  
69e4			; using decade counter....  
69e4			  
69e4			  
69e4			; TODO reset decade counter to start of scan  
69e4			  
69e4			; reset 15  
69e4			; clock 14  
69e4			; ce 13  
69e4			  
69e4			; 1 - q5  
69e4			; 2 - q1  
69e4			; 3 - q0  
69e4			; 4 - q2  
69e4			; 5 - q6  
69e4			; 6 - q7  
69e4			; 7 - q3  
69e4			; 8 - vss  
69e4			; 9 - q8  
69e4			; 10 - q4  
69e4			; 11 - q9  
69e4			; 12 - cout  
69e4			; 16 - vdd  
69e4			  
69e4			; clock      ce       reset     output  
69e4			; 0          x        0         n  
69e4			; x          1        0         n  
69e4			; x          x        1         q0  
69e4			; rising     0        0         n+1  
69e4			; falling    x        0         n  
69e4			; x          rising   0         n  
69e4			; 1          falling  0         x+1  
69e4			;  
69e4			; x = dont care, if n < 5 carry = 1 otherwise 0  
69e4			  
69e4			;   
69e4			; reset   
69e4			; 13=0, 14=0, 15=1 .. 15=0  
69e4			;  
69e4			; handshake line  
69e4			; 14=1.... read line 14=0  
69e4			  
69e4			  
69e4			  
69e4			  
69e4			  
69e4			; TODO hand shake clock for next column scan  
69e4			; TODO detect each row  
69e4			  
69e4			  
69e4			  
69e4			  
69e4			; reset 128  
69e4			; clock 64  
69e4			; ce 32  
69e4			  
69e4			  
69e4			.cyclestart:  
69e4			  
69e4			; reset counter  
69e4 3e 80		ld a, 128  
69e6 d3 c1		out (portbdata),a  
69e8			  
69e8			; loop leds  
69e8 06 0a		ld b,10  
69ea			  
69ea			.cycle1:  
69ea c5			push bc  
69eb 3e 00		ld a, 0  
69ed d3 c1		out (portbdata),a  
69ef cd 49 0a		call delay250ms  
69f2			  
69f2 3e 40		ld a, 64  
69f4 d3 c1		out (portbdata),a  
69f6 cd 49 0a		call delay250ms  
69f9			  
69f9 3e 00		ld a, 0  
69fb d3 c1		out (portbdata),a  
69fd cd 49 0a		call delay250ms  
6a00			  
6a00 c1			pop bc  
6a01 10 e7		djnz .cycle1  
6a03			  
6a03			  
6a03 18 df		jr .cyclestart  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			; map matrix key held to char on face of key  
6a05			  
6a05			;.mtocold:  
6a05			;  
6a05			;  
6a05			;; reset counter  
6a05			;ld a, 128  
6a05			;out (portbdata),a  
6a05			;  
6a05			;  
6a05			;; scan keyboard row 1  
6a05			;ld a, 0  
6a05			;out (portbdata),a  
6a05			;;ld a, 64  
6a05			;;out (portbdata),a  
6a05			;  
6a05			;  
6a05			;	ld a, 128  
6a05			;	ld hl, keyscan_table  
6a05			;	call .rowscan  
6a05			;  
6a05			;;ld a, 0  
6a05			;;out (portbdata),a  
6a05			;ld a, 64  
6a05			;out (portbdata),a  
6a05			;  
6a05			;	ld a, 64  
6a05			;	ld hl, keyscan_table+key_cols  
6a05			;	call .rowscan  
6a05			;  
6a05			;ld a, 0  
6a05			;out (portbdata),a  
6a05			;;ld a, 64  
6a05			;;out (portbdata),a  
6a05			;	ld a, 32  
6a05			;	ld hl, keyscan_table+(key_cols*2)  
6a05			;	call .rowscan  
6a05			;  
6a05			;  
6a05			;;ld a, 0  
6a05			;;out (portbdata),a  
6a05			;ld a, 64  
6a05			;out (portbdata),a  
6a05			;  
6a05			;	ld a, 16  
6a05			;	ld hl, keyscan_table+(key_cols*3)  
6a05			;	call .rowscan  
6a05			;  
6a05			;  
6a05			;	; flag if key D is held down and remove from reporting  
6a05			;	ld bc, .key_map_fd    
6a05			;	ld hl, keyscan_table  
6a05			;	ld de, key_fd  
6a05			;	call .key_shift_hold  
6a05			;	cp 255  
6a05			;	jr z, .cinmap  
6a05			;	; flag if key C is held down and remove from reporting  
6a05			;	ld bc, .key_map_fc    
6a05			;	ld hl, keyscan_table+key_cols  
6a05			;	ld de, key_fc  
6a05			;	call .key_shift_hold  
6a05			;	cp 255  
6a05			;	jr z, .cinmap  
6a05			;	; flag if key B is held down and remove from reporting  
6a05			;	ld bc, .key_map_fb    
6a05			;	ld hl, keyscan_table+(key_cols*2)  
6a05			;	ld de, key_fb  
6a05			;	call .key_shift_hold  
6a05			;	cp 255  
6a05			;	jr z, .cinmap  
6a05			;	; flag if key A is held down and remove from reporting  
6a05			;	ld bc, .key_map_fa    
6a05			;	ld hl, keyscan_table+(key_cols*3)  
6a05			;	ld de, key_fa  
6a05			;	call .key_shift_hold  
6a05			;	cp 255  
6a05			;	jr z, .cinmap  
6a05			;  
6a05			;	ld de, .matrix_to_char  
6a05			;  
6a05			;  
6a05			;.cinmap:   
6a05			;	if DEBUG_KEY  
6a05			;            LD   A, kLCD_Line4  
6a05			;            CALL fLCD_Pos       ;Position cursor to location in A  
6a05			;		push de  
6a05			;            LD   DE, keyscan_table  
6a05			;            CALL fLCD_Str       ;Display string pointed to by DE  
6a05			;		pop de  
6a05			;	endif  
6a05			  
6a05				; scan key matrix table for any held key  
6a05			  
6a05				; de holds either the default matrix or one selected above  
6a05			  
6a05			;	ld hl, keyscan_table  
6a05			;	ld b,key_cols*key_rows  
6a05			;  
6a05			;.cin1:	ld a,(hl)  
6a05			;	cp '#'  
6a05			;	jr z, .cinhit  
6a05			;	inc hl  
6a05			;	inc de  
6a05			;	dec b  
6a05			;	jr nz, .cin1  
6a05			;	; no key found held  
6a05			;	ld a,0  
6a05			;	ret  
6a05			;.cinhit: push de  
6a05			;	pop hl  
6a05			;	ld a,(hl)  
6a05			;	ret  
6a05			  
6a05			; flag a control key is held   
6a05			; hl is key pin, de is flag indicator  
6a05			  
6a05			;.key_shift_hold:  
6a05			;	push bc  
6a05			;	ld a, 1  
6a05			;	ld (cursor_shape),a  
6a05			;	ld b, 0  
6a05			;	ld a, (hl)  
6a05			;	cp '.'  
6a05			;	jr z, .key_shift1  
6a05			;	ld b, 255  
6a05			;	ld a, '+'    ; hide key from later scans  
6a05			;	ld (hl),a  
6a05			;	ld a, 2  
6a05			;	ld (cursor_shape),a  
6a05			;.key_shift1:  
6a05			;	; write flag indicator  
6a05			;	ld a,b  
6a05			;	ld (de),a  
6a05			;  
6a05			;	pop de    ; de now holds the key map ptr  
6a05			;	ret  
6a05			  
6a05				  
6a05				  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			;	push hl  
6a05			;	push de  
6a05			;	push bc  
6a05			;	call keyscan  
6a05			;	; map key matrix to ascii value of key face  
6a05			;  
6a05			;	ld hl, key_face_map  
6a05			;	ld de, keyscan_table  
6a05			;  
6a05			;	; get how many keys to look at  
6a05			;	ld b, keyscan_table_len  
6a05			;	  
6a05			;  
6a05			;	; at this stage fall out on first key hit  
6a05			;	; TODO handle multiple key press  
6a05			;  
6a05			;map1:	ld a,(hl)  
6a05			;	cp '#'  
6a05			;	jr z, keyhit  
6a05			;	inc hl  
6a05			;	inc de  
6a05			;	dec b  
6a05			;	jr nz, map1  
6a05			;nohit:	ld a, 0  
6a05			;	jr keydone  
6a05			;keyhit: push de  
6a05			;	pop hl  
6a05			;	ld a,(hl)  
6a05			;keydone:  
6a05			;	push bc  
6a05			;	push de  
6a05			; 	push hl  
6a05			;	ret   
6a05			;  
6a05			  
6a05			  
6a05			  
6a05			  
6a05			; scan physical key matrix  
6a05			  
6a05			  
6a05			;keyscan:  
6a05			;  
6a05			;; for each key_row use keyscanr bit mask for out  
6a05			;; then read in for keyscanc bitmask  
6a05			;; save result of row scan to keyscantable  
6a05			;  
6a05			;; scan keyboard row 1  
6a05			;  
6a05			;	ld b, key_rows  
6a05			;	ld hl, key_scanr  
6a05			;	ld de, keyscan_table  
6a05			;  
6a05			;rowloop:  
6a05			;  
6a05			;	ld a,(hl)		; out bit mask to energise keyboard row  
6a05			;	call rowscan  
6a05			;	inc hl  
6a05			;	dec b  
6a05			;	jr nz, rowloop  
6a05			;  
6a05			;	ret  
6a05			;  
6a05			;  
6a05			;; pass a out bitmask, b row number  
6a05			;arowscan:   
6a05			;	push bc  
6a05			;  
6a05			;	ld d, b  
6a05			;  
6a05			;	; calculate buffer location for this row  
6a05			;  
6a05			;	ld hl, keyscan_table	  
6a05			;kbufr:  ld e, key_cols  
6a05			;kbufc:	inc hl  
6a05			;	dec e  
6a05			;	jr nz, kbufc  
6a05			;	dec d  
6a05			;	jr nz, kbufr  
6a05			;  
6a05			;	; energise row and read columns  
6a05			;  
6a05			;	out (portbdata),a  
6a05			;	in a,(portbdata)  
6a05			;	ld c,a  
6a05			;  
6a05			;  
6a05			;	; save buffer loc  
6a05			;  
6a05			;	ld (keybufptr), hl  
6a05			;  
6a05			;	ld hl, key_scanc  
6a05			;	ld d, key_cols  
6a05			;  
6a05			;	; for each column check each bit mask  
6a05			;  
6a05			;colloop:  
6a05			;	  
6a05			;  
6a05			;	; reset flags for the row   
6a05			;  
6a05			;	ld b,'.'  
6a05			;	and (hl)  
6a05			;	jr z, maskskip  
6a05			;	ld b,'#'  
6a05			;maskskip:  
6a05			;	; save  key state  
6a05			;	push hl  
6a05			;	ld hl, (keybufptr)  
6a05			;	ld (hl), b  
6a05			;	inc hl  
6a05			;	ld (keybufptr), hl  
6a05			;  
6a05			;	; move to next bit mask  
6a05			;	pop hl  
6a05			;	inc hl  
6a05			;  
6a05			;	dec d  
6a05			;	jr nz, colloop  
6a05			;  
6a05			;	ret  
6a05			;  
6a05			;  
6a05			;;  
6a05			; lcd functions  
6a05			;  
6a05			;  
6a05			  
6a05			;if DEBUG_KEY_MATRIX  
6a05			  
6a05			; test function to display hardware view of matrix state  
6a05			  
6a05			matrixold:  
6a05			  
6a05			  
6a05			  
6a05			; reset counter  
6a05 3e 80		ld a, 128  
6a07 d3 c1		out (portbdata),a  
6a09			; scan keyboard row 1  
6a09 3e 00		ld a, 0  
6a0b d3 c1		out (portbdata),a  
6a0d			;ld a, 64  
6a0d			;out (portbdata),a  
6a0d 3e 80			ld a, 128  
6a0f 21 f2 fb			ld hl, keyscan_table_row1  
6a12 cd 6b 6a			call .rowscan  
6a15			  
6a15			;ld a, 0  
6a15			;out (portbdata),a  
6a15 3e 40		ld a, 64  
6a17 d3 c1		out (portbdata),a  
6a19 3e 40			ld a, 64  
6a1b 21 e7 fb			ld hl, keyscan_table_row2  
6a1e cd 6b 6a			call .rowscan  
6a21			  
6a21 3e 00		ld a, 0  
6a23 d3 c1		out (portbdata),a  
6a25			;ld a, 64  
6a25			;out (portbdata),a  
6a25 3e 20			ld a, 32  
6a27 21 dc fb			ld hl, keyscan_table_row3  
6a2a cd 6b 6a			call .rowscan  
6a2d			  
6a2d			;ld a, 0  
6a2d			;out (portbdata),a  
6a2d 3e 40		ld a, 64  
6a2f d3 c1		out (portbdata),a  
6a31 3e 10			ld a, 16  
6a33 21 d1 fb			ld hl, keyscan_table_row4  
6a36 cd 6b 6a			call .rowscan  
6a39			  
6a39			; Display text on first line  
6a39 3e 00		            LD   A, kLCD_Line1  
6a3b cd 73 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a3e 11 f2 fb		            LD   DE, keyscan_table_row1  
6a41			            ;LD   DE, MsgHello  
6a41 cd 95 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a44			  
6a44			; Display text on second line  
6a44 3e 28		            LD   A, kLCD_Line2  
6a46 cd 73 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a49 11 e7 fb		            LD   DE, keyscan_table_row2  
6a4c cd 95 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a4f 3e 50		            LD   A, kLCD_Line3  
6a51 cd 73 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a54 11 dc fb		            LD   DE, keyscan_table_row3  
6a57 cd 95 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a5a 3e 78		            LD   A, kLCD_Line4  
6a5c cd 73 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a5f 11 d1 fb		            LD   DE, keyscan_table_row4  
6a62 cd 95 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a65			  
6a65 cd 49 0a			call delay250ms  
6a68 c3 56 69			jp matrix  
6a6b			  
6a6b			; pass de as row display flags  
6a6b			.rowscan:   
6a6b			;	out (portbdata),a  
6a6b db c1			in a,(portbdata)  
6a6d 4f				ld c,a  
6a6e				; reset flags for the row   
6a6e 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a70 e6 01			and 1  
6a72 28 02			jr z, .p1on  
6a74 06 23			ld b,'#'  
6a76			.p1on:  
6a76 70				ld (hl), b  
6a77 23				inc hl  
6a78			  
6a78 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a7a 79				ld a,c  
6a7b e6 02			and 2  
6a7d			;	bit 0,a  
6a7d 28 02			jr z, .p2on  
6a7f 06 23			ld b,'#'  
6a81			.p2on:  
6a81 70				ld (hl), b  
6a82 23				inc hl  
6a83			;  
6a83 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a85 79				ld a,c  
6a86 e6 04			and 4  
6a88			;;	bit 0,a  
6a88 28 02			jr z, .p3on  
6a8a 06 23			ld b,'#'  
6a8c			.p3on:  
6a8c 70				ld (hl), b  
6a8d 23				inc hl  
6a8e			;;  
6a8e 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a90			;;	bit 0,a  
6a90 79				ld a,c  
6a91 e6 08			and 8  
6a93 28 02			jr z, .p4on  
6a95 06 23			ld b,'#'  
6a97			.p4on:  
6a97 70				ld (hl), b  
6a98 23				inc hl  
6a99			  
6a99 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a9b			;;	bit 0,a  
6a9b 79				ld a,c  
6a9c e6 10			and 16  
6a9e 28 02			jr z, .p5on  
6aa0 06 23			ld b,'#'  
6aa2			.p5on:  
6aa2 70				ld (hl), b  
6aa3 23				inc hl  
6aa4			; zero term  
6aa4 06 00			ld b,0  
6aa6 70				ld (hl), b  
6aa7			  
6aa7 c9			.rscandone: ret  
6aa8			  
6aa8			;addatohl:  
6aa8			;  
6aa8			 ;add   a, l    ; A = A+L  
6aa8			  ;  ld    l, a    ; L = A+L  
6aa8			   ; adc   a, h    ; A = A+L+H+carry  
6aa8			   ; sub   l       ; A = H+carry  
6aa8			   ; ld    h, a    ; H = H+carry  
6aa8			  
6aa8			;ret  
6aa8			; eof  
# End of file firmware_key_5x10.asm
6aa8			;include "firmware_key_4x10.asm" 
6aa8			 
6aa8			heap_size:    equ heap_end - heap_start 
6aa8			;eof 
# End of file os_mega.asm
6aa8
