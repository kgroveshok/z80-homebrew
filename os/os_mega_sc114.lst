# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 62 96			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-08-09 11:33' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b			 
801b			 
801b			 
801b			;        nop  
801b			;        nop 
801b			;;	org 05h		; null out bdos call 
801b			; 
801b			;        nop  
801b			;        nop  
801b			;        nop 
801b			;;	org 08h 
801b			;;; 
801b			;;	jp cin		; rst 8 - char in 
801b			;;; 
801b			; 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;	org 010h 
801b			;; 
801b			;	jp cout		; rest 010h  - char out 
801b			;; 
801b			;	org 01bh   
801b			; 
801b			;	;jp  		; rst 01bh   - write string to display 
801b			;	jp str_at_display 
801b			; 
801b			; 
801b			;	org 020h 
801b			; 
801b			;	; jp		 ; rst 020h - read char at screen location 
801b			; 
801b			;	org 028h 
801b			 
801b				; jp		 ; rst 028h  - storage i/o 
801b			 
801b			; 	org 030h 
801b			;	jp break_point_state 
801b			  
801b			; $30  
801b			; org 038h 
801b			; $38 
801b			 
801b			; TODO any more important entry points to add to jump table for easier coding use? 
801b			 
801b			if BASE_KEV = 1  
801b			 
801b				; need to be at $66 for nmi support 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255 
801b				jp nmi 
801b			endif 
801b			 
801b			include "firmware.asm" 
801b			  
801b			; main constants (used here and in firmware)  
801b			  
801b			; TODO have page 0 of storage as bios  
801b			  
801b			Device_A: equ 0h  
801b			Device_B: equ 040h          ; Sound  
801b			  
801b			if BASE_KEV  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_SC114  
801b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			; TODO fixup for CPM  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			Device_D: equ 0c0h             ; Keyboard and LCD  
801b			  
801b			; Odd specific debug points for testing hardware dev  
801b			  
801b			DEBUG_SOUND: equ 0       
801b			DEBUG_STK_FAULT: equ 0  
801b			DEBUG_INPUT: equ 0     ; Debug input entry code  
801b			DEBUG_INPUTV2: equ 0     ; Debug input entry code  
801b			DEBUG_KEYCINWAIT: equ 0  
801b			DEBUG_KEYCIN: equ 0  
801b			DEBUG_KEY: equ 0  
801b			DEBUG_KEY_MATRIX: equ 0  
801b			DEBUG_STORECF: equ 0  
801b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801b			DEBUG_SPI: equ 0    ; low level spi tests  
801b			  
801b			; Enable many break points  
801b			  
801b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801b			DEBUG_FORTH_JP: equ 0    ; 4  
801b			DEBUG_FORTH_MALLOC: equ 0  
801b			DEBUG_FORTH_MALLOC_INT: equ 0  
801b			DEBUG_FORTH_DOT: equ 1  
801b			DEBUG_FORTH_DOT_WAIT: equ 0  
801b			DEBUG_FORTH_MATHS: equ 0  
801b			DEBUG_FORTH_TOK: equ 0    ; 4  
801b			DEBUG_FORTH_PARSE: equ 0    ; 3  
801b			DEBUG_FORTH: equ 0  ;2  
801b			DEBUG_FORTH_WORDS: equ 1   ; 1  
801b			DEBUG_FORTH_PUSH: equ 1   ; 1  
801b			DEBUG_FORTH_UWORD: equ 1   ; 1  
801b			  
801b			; Enable key point breakpoints  
801b			  
801b			DEBUG_FORTH_DOT_KEY: equ 0  
801b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801b			  
801b			; Debug stack imbalances  
801b			  
801b			ON: equ 1  
801b			OFF: equ 0  
801b			  
801b			DEBUG_STACK_IMB: equ 0  
801b			STACK_IMB_STORE: equ 20  
801b			  
801b			; House keeping and protections  
801b			  
801b			DEBUG_FORTH_STACK_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801b			FORTH_ENABLE_FREE: equ 0  
801b			FORTH_ENABLE_MALLOCFREE: equ 1  
801b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801b			FORTH_ENABLE_FLOATMATH: equ 0  
801b			  
801b			  
801b			CALLMONITOR: macro  
801b			;	call break_point_state  
801b			; now use the break point debug vector  
801b				call debug_vector  
801b				endm  
801b			  
801b			MALLOC_1: equ 1        ; from dk88   
801b			MALLOC_2: equ 0           ; broke  
801b			MALLOC_3: equ 0           ; really broke  
801b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801b			  
801b			if BASE_KEV   
801b			;stacksize: equ 256  
801b			; each stack entry is three bytes (type + word)  
801b			stacksize: equ 3*150  
801b			  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 512  
801b			endif  
801b			if BASE_SC114  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			;if STORAGE_SE == 0  
801b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801b			;endif  
801b			  
801b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801b			  
801b			STORE_0_AUTORUN: equ $20  
801b			  
801b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801b			  
801b			STORE_0_AUTOFILE: equ $21  
801b			STORE_0_BANKRUN: equ $23  
801b			STORE_0_FILERUN: equ $24  
801b			  
801b			; Block 0 offsets for settings  
801b			  
801b			; if set then skip prompt for start up and accept all  
801b			  
801b			STORE_0_QUICKSTART: equ $25  
801b			  
801b			; Blocks where directory table is held  
801b			  
801b			; Reducing the number of entries increases the max file size  
801b			  
801b			;STORE_DIR_START: equ 1  
801b			;STORE_DIR_END: equ 33  
801b			  
801b			; Blocks from where file data is stored  
801b			  
801b			;STORE_DATA_START: equ STORE_DIR_END + 1  
801b			  
801b			; Block indicators (<32 are data files)  
801b			  
801b			;STORE_BLOCK_CFG: equ $8f       ; config block  
801b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801b			;STORE_BLOCK_FREE: equ $85       ; data block free  
801b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801b			  
801b			  
801b			  
801b			; Directory entry flags  
801b			  
801b			;STORE_DIR_FREE: equ 0  
801b			;STORE_DIR_FILE:  equ 1  
801b			  
801b			; Structure offsets to directory entries  
801b			;STORE_DE_FLAG: equ 0  
801b			;STORE_DE_MAXEXT: equ 1  
801b			;STORE_DE_FILENAME: equ 2  
801b			  
801b			; Structure offsets to block 0  
801b			  
801b			;STORE_BK0_ISFOR: equ 1  
801b			;STORE_BK0_LABEL: equ 3  
801b			  
801b			; memory allocation   
801b			  
801b			chk_stund: equ tos+2           ; underflow check word  
801b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801b			  
801b			; keyscan table needs rows x cols buffer  
801b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801b			  
801b			keyscan_table_row1: equ chk_stovr -key_cols-1  
801b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801b			keyscan_scancol: equ keyscan_table-key_cols  
801b			;keyscan_table_len: equ key_rows*key_cols  
801b			;keybufptr: equ keyscan_table - 2  
801b			;keysymbol: equ keybufptr - 1  
801b			key_held: equ keyscan_scancol-1	; currently held  
801b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801b			key_fa: equ key_repeat_ct -1 ;  
801b			key_fb: equ key_fa -1 ;  
801b			key_fc: equ key_fb -1 ;  
801b			key_fd: equ key_fc -1 ;  
801b			key_face_held: equ key_fd - 1   
801b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801b			  
801b			hardware_config: equ key_face_held - 10  
801b			  
801b			; hardware config switches  
801b			; TODO add bitmasks on includes for hardware  
801b			; high byte for expansion ids  
801b			;     0000 0000  no card inserted  
801b			;     0000 0001  storage card inserted  
801b			;     0000 0010  spi sd card active  
801b			  
801b			;       
801b			; low byte:  
801b			;     0000 0001   4x4 keypad  
801b			;     0000 0010   full keyboard  
801b			;     0000 0011   spi/ext keyboard  
801b			;     0000 0100   20x4 lcd  
801b			;     0000 1000   40x4 lcd  
801b			;     0000 1100   spi/ext display  
801b			;     0001 0000   ide interface available  
801b			  
801b			hardware_word: equ hardware_config - 2  
801b			  
801b			; debug marker - optional display of debug point on the debug screens  
801b			  
801b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801b			  
801b			debug_mark: equ debug_vector - 4  
801b			  
801b			; input_str vars  
801b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801b			input_size: equ input_start -1  ; number of chars  
801b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801b			input_len: equ input_cur_onoff - 5 ; length of current input  
801b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801b			  
801b			; cursor blink rate  
801b			CUR_BLINK_RATE: equ $09  
801b			;CUR_BLINK_RATE: equ 15  
801b			  
801b			key_actual_pressed: equ input_cursor - 1   
801b			key_symbol: equ key_actual_pressed - 1   
801b			key_shift: equ key_symbol - 1   
801b			  
801b			; Display allocation  
801b			  
801b			;display_rows: equ 4     ; move out to mini and mega files  
801b			;display_cols: equ 20  
801b			  
801b			display_fb_len: equ display_rows*display_cols  
801b			  
801b			; primary frame buffer     
801b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801b			; working frame buffers  
801b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801b			display_fb3: equ  display_fb1-display_fb_len - 1  
801b			display_fb2: equ  display_fb3-display_fb_len - 1  
801b			;  
801b			; pointer to active frame buffer  
801b			display_fb_active: equ display_fb2 - 2  
801b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801b			display_write_tmp: equ display_lcde1e2 - 2  
801b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801b			  
801b			;  
801b			  
801b			;; can load into de directory  
801b			cursor_col: equ display_active-1  
801b			cursor_row: equ cursor_col-1  
801b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801b			  
801b			; maths vars  
801b			  
801b			LFSRSeed: equ cursor_shape -20   
801b			randData: equ LFSRSeed - 2  
801b			xrandc: equ randData - 2  
801b			stackstore: equ xrandc - 2  
801b			seed1: equ  stackstore -2   
801b			seed2: equ seed1 - 2  
801b			  
801b			; cf storage vars  
801b			  
801b			iErrorNum:  equ seed2-1         ;Error number  
801b			iErrorReg:  equ iErrorNum -1              ;Error register  
801b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801b			  
801b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801b			  
801b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801b			  
801b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801b			store_tmpid: equ store_tmp3 - 1		; page temp id  
801b			store_tmpext: equ store_tmpid - 1		; file extent temp  
801b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801b			;  
801b			; spi vars  
801b			  
801b			  
801b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801b			spi_device_id: equ spi_device - 1    ; human readable bank number  
801b			  
801b			;;;;; forth cli params  
801b			  
801b			; TODO use a different frame buffer for forth???  
801b			  
801b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801b			  
801b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801b			  
801b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801b			  
801b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801b			  
801b			; os/forth token vars  
801b			  
801b			os_last_cmd: equ os_var_array-255  
801b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801b			os_current_i: equ os_cli_cmd-2  
801b			os_cur_ptr: equ os_current_i-2  
801b			os_word_scratch: equ os_cur_ptr-30  
801b			os_tok_len: equ os_word_scratch - 2  
801b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801b			os_tok_malloc: equ os_tok_ptr - 2  
801b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801b			execscratch: equ os_input-255        ; exec cmd eval buffer  
801b			scratch: equ execscratch-255  
801b			  
801b			os_stack_1: equ scratch - 3       ; stack holding area 1  
801b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801b			  
801b			  
801b			; temp locations for new word processing to save on adding more   
801b			  
801b			os_new_malloc: equ os_stack_4-2  
801b			os_new_parse_len: equ os_new_malloc - 2  
801b			os_new_word_len: equ os_new_parse_len - 2  
801b			os_new_work_ptr: equ os_new_word_len - 2  
801b			os_new_src_ptr: equ os_new_work_ptr - 2  
801b			os_new_exec: equ os_new_src_ptr - 2  
801b			os_new_exec_ptr: equ os_new_exec - 2  
801b			  
801b			; resume memory alloocations....  
801b			  
801b			;os_view_disable: equ os_new_exec_ptr - 1  
801b			os_view_af: equ os_new_exec_ptr - 2  
801b			os_view_hl: equ os_view_af -2  
801b			os_view_de: equ os_view_hl - 2  
801b			os_view_bc: equ os_view_de - 2  
801b			  
801b			; stack checksum word  
801b			if DEBUG_STACK_IMB  
801b				curframe: equ  os_view_de - 5  
801b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			else  
801b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			endif  
801b			  
801b			; with data stack could see memory filled with junk. need some memory management   
801b			; malloc and free entry points added  
801b			  
801b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			;heap_end: equ free_list-1  ; Starting address of heap  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			heap_end: equ chk_word-1  ; Starting address of heap  
801b			  
801b			  
801b			;if BASE_KEV   
801b			;heap_start: equ 0800eh  ; Starting address of heap  
801b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;heap_start: equ baseram+15  ; Starting address of heap  
801b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;endif  
801b			  
801b			  
801b			;;;;  
801b			  
801b			  
801b			; change below to point to last memory alloc above  
801b			topusermem:  equ   heap_start  
801b			  
801b			;if BASE_KEV   
801b			;baseusermem: equ 08000h  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;;aseusermem:     equ    12  
801b			;baseusermem:     equ    prompt  
801b			;;baseusermem:     equ    endofcode  
801b			;endif  
801b			  
801b			  
801b			; **********************************************************************  
801b			; **  Constants  
801b			; **********************************************************************  
801b			  
801b			; Constants used by this code module  
801b			kDataReg:   EQU Device_D           ;PIO port A data register  
801b			kContReg:   EQU Device_D+2           ;PIO port A control register  
801b			  
801b			  
801b			portbdata:  equ Device_D+1    ; port b data  
801b			portbctl:   equ Device_D+3    ; port b control  
801b			  
801b			  
801b			;KEY_SHIFT:   equ 5  
801b			;KEY_SYMBOLSHIFT:  equ 6  
801b			  
801b			KEY_SHIFTLOCK: equ 4  
801b			  
801b			  
801b			KEY_UP: equ 5  
801b			KEY_NEXTWORD: equ 6  
801b			KEY_PREVWORD: equ 7  
801b			KEY_BS: equ 8  
801b			KEY_TAB:  equ 9  
801b			KEY_DOWN: equ 10  
801b			KEY_LEFT: equ 11  
801b			KEY_RIGHT: equ 12  
801b			KEY_CR:   equ 13  
801b			KEY_HOME: equ 14  
801b			KEY_END: equ 15  
801b			  
801b			KEY_F1: equ 16  
801b			KEY_F2: equ 17  
801b			KEY_F3: equ 18  
801b			KEY_F4: equ 19  
801b			  
801b			KEY_F5: equ 20  
801b			KEY_F6: equ 21  
801b			KEY_F7: equ 22  
801b			KEY_F8: equ 23  
801b			  
801b			KEY_F9: equ 24  
801b			KEY_F10: equ 25  
801b			KEY_F11: equ 26  
801b			KEY_F12: equ 27  
801b			  
801b			;if DEBUG_KEY  
801b			;	KEY_MATRIX_NO_PRESS: equ '.'  
801b			;	KEY_SHIFT:   equ '.'  
801b			;	KEY_SYMBOLSHIFT:  equ '.'  
801b			;else  
801b				KEY_SHIFT:   equ '~'  
801b				KEY_SYMBOLSHIFT:  equ '~'  
801b				KEY_MATRIX_NO_PRESS: equ '~'  
801b			;endi  
801b			  
801b			  
801b			  
801b			  
801b			; Macro to make adding debug marks easier  
801b			  
801b			DMARK: macro str  
801b				push af  
801b				ld a, (.dmark)  
801b				ld (debug_mark),a  
801b				ld a, (.dmark+1)  
801b				ld (debug_mark+1),a  
801b				ld a, (.dmark+2)  
801b				ld (debug_mark+2),a  
801b				jr .pastdmark  
801b			.dmark: db str  
801b			.pastdmark: pop af  
801b			  
801b			endm  
801b			  
801b			  
801b			; macro to detect for stack imbalances  
801b			  
801b			include "stackimbal.asm"  
801b			; Macro and code to detect stock imbalances 
801b			 
801b			SPPUSH: equ 0 
801b			 
801b			; Add a stack frame which can be checked before return 
801b			 
801b			STACKFRAME: macro onoff frame1 frame2 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b						exx 
801b			 
801b						ld de, frame1 
801b						ld a, d 
801b						ld hl, curframe 
801b						call hexout 
801b						ld a, e 
801b						ld hl, curframe+2 
801b						call hexout 
801b			  
801b						ld hl, frame1 
801b						push hl 
801b						ld hl, frame2 
801b						push hl 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			endm 
801b			 
801b			STACKFRAMECHK: macro onoff frame1 frame2 
801b			 
801b					 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						exx 
801b						; check stack frame SP 
801b			 
801b						ld hl, frame2 
801b						pop de   ; frame2 
801b			 
801b						call cmp16 
801b						jr nz, .spnosame 
801b						 
801b			 
801b						ld hl, frame1 
801b						pop de   ; frame1 
801b			 
801b						call cmp16 
801b						jr z, .spfrsame 
801b			 
801b						.spnosame: call showsperror 
801b			 
801b						.spfrsame: nop 
801b			 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			 
801b			 
801b			endm 
801b			 
801b			 
801b			; for a sub routine, wrap SP collection and comparisons 
801b			 
801b			; Usage: 
801b			; 
801b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801b			 
801b			SAVESP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b			 
801b						ld (store_sp+(storeword*4)), sp 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			CHECKSP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b			 
801b						; save SP after last save 
801b				 
801b						ld (store_sp+(storeword*4)+2), sp 
801b			 
801b						push hl 
801b						ld hl, store_sp+(storeword*4) 
801b						call check_stack_sp  
801b						pop hl 
801b			 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			if DEBUG_STACK_IMB 
801b			 
801b			check_stack_sp: 
801b					push de 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					push de 
801b			 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					pop hl 
801b			 
801b			 
801b					; check to see if the same 
801b			 
801b					call cmp16 
801b					jr z, .spsame 
801b			 
801b					; not same 
801b			 
801b					call showsperror 
801b			.spsame: 
801b			 
801b					pop de 
801b			 
801b					ret 
801b			 
801b			.sperr:  db "Stack imbalance",0 
801b			 
801b			 
801b			showsperror: 
801b			 
801b			 
801b				push hl 
801b				push af 
801b				push de 
801b				call clear_display 
801b				ld de, .sperr 
801b				ld a,0 
801b			;	ld de,os_word_scratch 
801b				call str_at_display 
801b				ld a, display_row_1+17 
801b				ld de, debug_mark 
801b				call str_at_display 
801b				ld a, 0 
801b				ld (curframe+4),a 
801b				ld hl, curframe 
801b				ld de, os_word_scratch 
801b				ld a, display_row_4 
801b				call str_at_display 
801b				call update_display 
801b				;call break_point_state 
801b				call cin_wait 
801b			 
801b			;	ld a, ' ' 
801b			;	ld (os_view_disable), a 
801b				call bp_on 
801b				pop de	 
801b				pop af 
801b				pop hl 
801b				CALLMONITOR 
801b				ret 
801b			 
801b			endif 
801b			 
801b			 
801b			 
801b			; eof 
# End of file stackimbal.asm
801b			  
801b			;TODO macro to calc col and row offset into screen  
801b			  
801b			  
801b			  
801b			hardware_init:  
801b			  
801b				  
801b			  
801b					;ld a, 0  
801b					;ld (hardware_diag), a  
801b			  
801b					; clear all the buffers  
801b			  
801b 21 10 ed				ld hl, display_fb1  
801e 22 cc eb				ld (display_fb_active), hl  
8021			  
8021 cd ae 8a				call clear_display  
8024			  
8024 21 ce eb				ld hl, display_fb2  
8027 22 cc eb				ld (display_fb_active), hl  
802a			  
802a cd ae 8a				call clear_display  
802d			  
802d					; init primary frame buffer area  
802d 21 b1 ed				ld hl, display_fb0  
8030 22 cc eb				ld (display_fb_active), hl  
8033			  
8033 cd ae 8a				call clear_display  
8036			  
8036			  
8036 cd 59 dc				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8039			  
8039 cd fb dc			call key_init  
803c cd 9e 80			call storage_init  
803f			  
803f				; setup malloc functions  
803f			  
803f				if MALLOC_1  
803f cd 92 90				call  heap_init  
8042				endif  
8042				if MALLOC_4  
8042					call  heap_init  
8042				endif  
8042			  
8042				; init sound hardware if present  
8042			  
8042				if SOUND_ENABLE  
8042					call sound_init  
8042				endif  
8042			  
8042				; lcd test sequence  
8042					  
8042 cd d1 8a			call update_display  
8045 cd f1 89			call delay1s  
8048 3e 2b			ld a,'+'  
804a cd b3 8a			call fill_display  
804d cd d1 8a			call update_display  
8050 cd f1 89			call delay1s  
8053 3e 2a			ld a,'*'  
8055 cd b3 8a			call fill_display  
8058 cd d1 8a			call update_display  
805b cd f1 89			call delay1s  
805e 3e 2d			ld a,'-'  
8060 cd b3 8a			call fill_display  
8063 cd d1 8a			call update_display  
8066 cd f1 89			call delay1s  
8069			  
8069			; boot splash screen  
8069			if display_cols == 20	  
8069			        ld a, display_row_1    
8069			else  
8069 3e 0a		        ld a, display_row_1 +10   
806b			endif  
806b 11 c0 95			ld de, prom_bootmsg  
806e cd c1 8a			call str_at_display  
8071 cd d1 8a			call update_display  
8074			  
8074			  
8074 cd f1 89			call delay1s  
8077 cd f1 89			call delay1s  
807a			if display_cols == 20	  
807a			            LD   A, display_row_3+2  
807a			else  
807a 3e 5c		            LD   A, display_row_3+12  
807c			endif  
807c 11 d5 95			ld de, prom_bootmsg1  
807f cd c1 8a			call str_at_display  
8082 cd d1 8a			call update_display  
8085 cd f1 89			call delay1s  
8088 cd f1 89			call delay1s  
808b			  
808b			;	ld a, display_row_4+3  
808b			;	ld de, bootmsg2  
808b			;	call str_at_display  
808b			;	call update_display  
808b			;	call delay1s  
808b			;	call delay1s  
808b			  
808b			; debug mark setup  
808b			  
808b 3e 5f		ld a, '_'  
808d 32 6b ee		ld (debug_mark),a  
8090 32 6c ee		ld (debug_mark+1),a  
8093 32 6d ee		ld (debug_mark+2),a  
8096 3e 00		ld a,0  
8098 32 6e ee		ld (debug_mark+3),a  
809b			  
809b c9					ret  
809c			  
809c			  
809c			;bootmsg2:	db "Firmware v0.1",0  
809c			  
809c			; a 4x20 lcd  
809c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809c			  
809c			;if display_cols == 20  
809c			;	include "firmware_lcd_4x20.asm"  
809c			;endif  
809c			  
809c			;if display_cols == 40  
809c			;	include "firmware_lcd_4x40.asm"  
809c			;endif  
809c			  
809c			;  
809c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809c			; TODO abstract the bit bang video out interface for dual display  
809c			; TODO wire video out to tx pin on rc2014 bus  
809c			  
809c			; must supply cin, and cin_wait for low level hardware abstraction   
809c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809c			; test scancode  
809c			  
809c			;;;;;  
809c			;;;  
809c			; Moved out to mini and maxi versions  
809c			;  
809c			; include "firmware_key_4x4.asm"  
809c			; using existing 4 wire x 4 resistor array for input  
809c			;include "firmware_key_4x10.asm"  
809c			; need to mod the board for 5 rows due to resistor array  
809c			;include "firmware_key_5x10.asm"  
809c			  
809c			; storage hardware interface  
809c			  
809c			; use microchip serial eeprom for storage  
809c			  
809c			  
809c			if STORAGE_SE  
809c				include "firmware_spi.asm"  
809c				include "firmware_seeprom.asm"  
809c			else  
809c			   ; create some stubs for the labels  
809c c9			se_readbyte: ret  
809d c9			se_writebyte: ret  
809e c9			storage_init: ret  
809f			  
809f			endif  
809f			  
809f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
809f			;include "firmware_cf.asm"  
809f			  
809f			; load up high level storage hardward abstractions  
809f			include "firmware_storage.asm"  
809f			 
809f			; persisent storage hardware abstraction layer  
809f			 
809f			 
809f			 
809f			; Block 0 on storage is a config state 
809f			 
809f			 
809f			 
809f			; TODO add read phy block and write phy block functions 
809f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
809f			 
809f			; Abstraction layer  
809f			 
809f			; Logocial block size is same size as physical size - using tape concept 
809f			 
809f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
809f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
809f			 
809f			 
809f			 
809f			; Filesystem layout (Logical layout) 
809f			; 
809f			; Block 0 - Bank config  
809f			; 
809f			;      Byte - 0 file id counter 
809f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
809f			;      Byte - 3-20 zero terminated bank label 
809f			; 
809f			; Block 1 > File storage 
809f			; 
809f			;      Byte 0 file id    - block 0 file details 
809f			;      Byte 1 block id - block 0 is file  
809f			;            Byte 2-15 - File name 
809f			; 
809f			;       - to end of block data 
809f			; 
809f			 
809f			; Get ID for the file named in pointer held HL 
809f			; Returns ID in HL = 255 if no file found 
809f			 
809f			storage_getid: 
809f			 
809f 22 73 ea			ld (store_tmp1), hl 
80a2			 
80a2				if DEBUG_STORESE 
80a2					DMARK "SGI" 
80a2 f5				push af  
80a3 3a b7 80			ld a, (.dmark)  
80a6 32 6b ee			ld (debug_mark),a  
80a9 3a b8 80			ld a, (.dmark+1)  
80ac 32 6c ee			ld (debug_mark+1),a  
80af 3a b9 80			ld a, (.dmark+2)  
80b2 32 6d ee			ld (debug_mark+2),a  
80b5 18 03			jr .pastdmark  
80b7 ..			.dmark: db "SGI"  
80ba f1			.pastdmark: pop af  
80bb			endm  
# End of macro DMARK
80bb					CALLMONITOR 
80bb cd 6f ee			call debug_vector  
80be				endm  
# End of macro CALLMONITOR
80be				endif 
80be				; get block 0 and set counter for number of files to scan 
80be			 
80be cd 29 82			call storage_get_block_0 
80c1			 
80c1 3a 7a ea			ld a, (store_page) 
80c4 47				ld b, a 
80c5			 
80c5				; get extent 0 of each file id 
80c5			 
80c5				if DEBUG_STORESE 
80c5					DMARK "SGc" 
80c5 f5				push af  
80c6 3a da 80			ld a, (.dmark)  
80c9 32 6b ee			ld (debug_mark),a  
80cc 3a db 80			ld a, (.dmark+1)  
80cf 32 6c ee			ld (debug_mark+1),a  
80d2 3a dc 80			ld a, (.dmark+2)  
80d5 32 6d ee			ld (debug_mark+2),a  
80d8 18 03			jr .pastdmark  
80da ..			.dmark: db "SGc"  
80dd f1			.pastdmark: pop af  
80de			endm  
# End of macro DMARK
80de					CALLMONITOR 
80de cd 6f ee			call debug_vector  
80e1				endm  
# End of macro CALLMONITOR
80e1				endif 
80e1 60			.getloop:	ld h, b 
80e2 2e 00				ld l, 0 
80e4 c5					push bc 
80e5			 
80e5 11 7a ea				ld de, store_page 
80e8				if DEBUG_STORESE 
80e8					DMARK "SGr" 
80e8 f5				push af  
80e9 3a fd 80			ld a, (.dmark)  
80ec 32 6b ee			ld (debug_mark),a  
80ef 3a fe 80			ld a, (.dmark+1)  
80f2 32 6c ee			ld (debug_mark+1),a  
80f5 3a ff 80			ld a, (.dmark+2)  
80f8 32 6d ee			ld (debug_mark+2),a  
80fb 18 03			jr .pastdmark  
80fd ..			.dmark: db "SGr"  
8100 f1			.pastdmark: pop af  
8101			endm  
# End of macro DMARK
8101					CALLMONITOR 
8101 cd 6f ee			call debug_vector  
8104				endm  
# End of macro CALLMONITOR
8104				endif 
8104 cd d1 86				call storage_read 
8107 cd 04 8d				call ishlzero 
810a 28 2d				jr z, .gap 
810c					 
810c					; have a file name read. Is it one we want. 
810c			 
810c 2a 73 ea				ld hl, (store_tmp1) 
810f 11 7d ea				ld de, store_page+3   ; file name 
8112			 
8112				if DEBUG_STORESE 
8112					DMARK "SGc" 
8112 f5				push af  
8113 3a 27 81			ld a, (.dmark)  
8116 32 6b ee			ld (debug_mark),a  
8119 3a 28 81			ld a, (.dmark+1)  
811c 32 6c ee			ld (debug_mark+1),a  
811f 3a 29 81			ld a, (.dmark+2)  
8122 32 6d ee			ld (debug_mark+2),a  
8125 18 03			jr .pastdmark  
8127 ..			.dmark: db "SGc"  
812a f1			.pastdmark: pop af  
812b			endm  
# End of macro DMARK
812b					CALLMONITOR 
812b cd 6f ee			call debug_vector  
812e				endm  
# End of macro CALLMONITOR
812e				endif 
812e cd 79 90				call strcmp 
8131 20 06				jr nz, .gap   ; not this one 
8133			 
8133 c1				        pop bc 
8134			 
8134 26 00				ld h, 0 
8136 68					ld l, b 
8137 18 22				jr .getdone 
8139						 
8139			 
8139			 
8139			 
8139			.gap: 
8139				if DEBUG_STORESE 
8139					DMARK "SGg" 
8139 f5				push af  
813a 3a 4e 81			ld a, (.dmark)  
813d 32 6b ee			ld (debug_mark),a  
8140 3a 4f 81			ld a, (.dmark+1)  
8143 32 6c ee			ld (debug_mark+1),a  
8146 3a 50 81			ld a, (.dmark+2)  
8149 32 6d ee			ld (debug_mark+2),a  
814c 18 03			jr .pastdmark  
814e ..			.dmark: db "SGg"  
8151 f1			.pastdmark: pop af  
8152			endm  
# End of macro DMARK
8152					CALLMONITOR 
8152 cd 6f ee			call debug_vector  
8155				endm  
# End of macro CALLMONITOR
8155				endif 
8155			 
8155 c1					pop bc 
8156 10 89				djnz .getloop 
8158 21 ff 00				ld hl, 255 
815b			.getdone: 
815b			 
815b				if DEBUG_STORESE 
815b					DMARK "SGe" 
815b f5				push af  
815c 3a 70 81			ld a, (.dmark)  
815f 32 6b ee			ld (debug_mark),a  
8162 3a 71 81			ld a, (.dmark+1)  
8165 32 6c ee			ld (debug_mark+1),a  
8168 3a 72 81			ld a, (.dmark+2)  
816b 32 6d ee			ld (debug_mark+2),a  
816e 18 03			jr .pastdmark  
8170 ..			.dmark: db "SGe"  
8173 f1			.pastdmark: pop af  
8174			endm  
# End of macro DMARK
8174					CALLMONITOR 
8174 cd 6f ee			call debug_vector  
8177				endm  
# End of macro CALLMONITOR
8177				endif 
8177			 
8177 c9				ret 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			; Read Block 
8178			; ---------- 
8178			; 
8178			; With current bank 
8178			;  
8178			; Get block number to read 
8178			; Load physical blocks starting at start block into buffer 
8178			 
8178			; de points to buffer to use 
8178			; hl holds logical block number  
8178			 
8178			storage_read_block: 
8178			 
8178				; TODO bank selection 
8178			 
8178				; for each of the physical blocks read it into the buffer 
8178 06 40			ld b, STORE_BLOCK_PHY 
817a			 
817a				if DEBUG_STORESE 
817a d5					push de 
817b				endif 
817b				 
817b			.rl1:    
817b			 
817b				; read physical block at hl into de 
817b			        ; increment hl and de to next read position on exit 
817b			 
817b e5				push hl 
817c d5				push de	 
817d c5				push bc 
817e			;	if DEBUG_STORESE 
817e			;		push af 
817e			;		ld a, 'R' 
817e			;		ld (debug_mark),a 
817e			;		pop af 
817e			;		CALLMONITOR 
817e			;	endif 
817e cd 9c 80			call se_readbyte 
8181			;	if DEBUG_STORESE 
8181			;		ld a,(spi_portbyte) 
8181			;		ld l, a 
8181			;		push af 
8181			;		ld a, '1' 
8181			;		ld (debug_mark),a 
8181			;		pop af 
8181			;		CALLMONITOR 
8181			;	endif 
8181 c1				pop bc 
8182 d1				pop de 
8183 e1				pop hl 
8184 12				ld (de),a 
8185 23				inc hl 
8186 13				inc de 
8187			 
8187			;	if DEBUG_STORESE 
8187			;		push af 
8187			;		ld a, 'r' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187			;		CALLMONITOR 
8187			;	endif 
8187			 
8187 10 f2			djnz .rl1 
8189			 
8189				if DEBUG_STORESE 
8189					DMARK "SRB" 
8189 f5				push af  
818a 3a 9e 81			ld a, (.dmark)  
818d 32 6b ee			ld (debug_mark),a  
8190 3a 9f 81			ld a, (.dmark+1)  
8193 32 6c ee			ld (debug_mark+1),a  
8196 3a a0 81			ld a, (.dmark+2)  
8199 32 6d ee			ld (debug_mark+2),a  
819c 18 03			jr .pastdmark  
819e ..			.dmark: db "SRB"  
81a1 f1			.pastdmark: pop af  
81a2			endm  
# End of macro DMARK
81a2 d1					pop de 
81a3			; 
81a3			;		push af 
81a3			;		ld a, 'R' 
81a3			;		ld (debug_mark),a 
81a3			;		pop af 
81a3					CALLMONITOR 
81a3 cd 6f ee			call debug_vector  
81a6				endm  
# End of macro CALLMONITOR
81a6				endif 
81a6 c9				ret	 
81a7				 
81a7			 
81a7			; File Size 
81a7			; --------- 
81a7			; 
81a7			;   hl file id 
81a7			; 
81a7			;  returns in hl the number of blocks 
81a7			 
81a7			storage_file_size: 
81a7 5d				ld e, l 
81a8 16 00			ld d, 0 
81aa 21 40 00			ld hl, STORE_BLOCK_PHY 
81ad					if DEBUG_FORTH_WORDS 
81ad						DMARK "SIZ" 
81ad f5				push af  
81ae 3a c2 81			ld a, (.dmark)  
81b1 32 6b ee			ld (debug_mark),a  
81b4 3a c3 81			ld a, (.dmark+1)  
81b7 32 6c ee			ld (debug_mark+1),a  
81ba 3a c4 81			ld a, (.dmark+2)  
81bd 32 6d ee			ld (debug_mark+2),a  
81c0 18 03			jr .pastdmark  
81c2 ..			.dmark: db "SIZ"  
81c5 f1			.pastdmark: pop af  
81c6			endm  
# End of macro DMARK
81c6						CALLMONITOR 
81c6 cd 6f ee			call debug_vector  
81c9				endm  
# End of macro CALLMONITOR
81c9					endif 
81c9 cd ab 84			call storage_findnextid 
81cc			 
81cc cd 04 8d			call ishlzero 
81cf			;	ld a, l 
81cf			;	add h 
81cf			;	cp 0 
81cf c8				ret z			; block not found so EOF 
81d0			 
81d0 11 7a ea			ld de, store_page 
81d3 cd 78 81			call storage_read_block 
81d6			 
81d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81d9 6f				ld l, a 
81da 26 00			ld h, 0 
81dc c9			 	ret 
81dd			 
81dd			 
81dd			; Write Block 
81dd			; ----------- 
81dd			; 
81dd			; With current bank 
81dd			;  
81dd			; Get block number to write 
81dd			; Write physical blocks starting at start block from buffer 
81dd			  
81dd			storage_write_block: 
81dd				; TODO bank selection 
81dd			 
81dd				; for each of the physical blocks read it into the buffer 
81dd 06 40			ld b, STORE_BLOCK_PHY 
81df			 
81df				if DEBUG_STORESE 
81df					DMARK "SWB" 
81df f5				push af  
81e0 3a f4 81			ld a, (.dmark)  
81e3 32 6b ee			ld (debug_mark),a  
81e6 3a f5 81			ld a, (.dmark+1)  
81e9 32 6c ee			ld (debug_mark+1),a  
81ec 3a f6 81			ld a, (.dmark+2)  
81ef 32 6d ee			ld (debug_mark+2),a  
81f2 18 03			jr .pastdmark  
81f4 ..			.dmark: db "SWB"  
81f7 f1			.pastdmark: pop af  
81f8			endm  
# End of macro DMARK
81f8			 
81f8					;push af 
81f8					;ld a, 'W' 
81f8					;ld (debug_mark),a 
81f8					;pop af 
81f8					CALLMONITOR 
81f8 cd 6f ee			call debug_vector  
81fb				endm  
# End of macro CALLMONITOR
81fb				endif 
81fb			 
81fb			; might not be working 
81fb			;	call se_writepage 
81fb			 
81fb			;	ret 
81fb			; 
81fb			 
81fb			 
81fb			 
81fb			.wl1:    
81fb			 
81fb				; read physical block at hl into de 
81fb			        ; increment hl and de to next read position on exit 
81fb			 
81fb e5				push hl 
81fc d5				push de	 
81fd c5				push bc 
81fe 1a				ld a,(de) 
81ff				;if DEBUG_STORESE 
81ff			;		push af 
81ff			;		ld a, 'W' 
81ff			;		ld (debug_mark),a 
81ff			;		pop af 
81ff			;		CALLMONITOR 
81ff			;	endif 
81ff cd 9d 80			call se_writebyte 
8202			;	call delay250ms 
8202 00				nop 
8203 00				nop 
8204 00				nop 
8205			;	if DEBUG_STORESE 
8205			;		push af 
8205			;		ld a, 'w' 
8205			;		ld (debug_mark),a 
8205			;		pop af 
8205			;		CALLMONITOR 
8205			;	endif 
8205 c1				pop bc 
8206 d1				pop de 
8207 e1				pop hl 
8208 23				inc hl 
8209 13				inc de 
820a			 
820a			 
820a 10 ef			djnz .wl1 
820c			 
820c				if DEBUG_STORESE 
820c					DMARK "SW2" 
820c f5				push af  
820d 3a 21 82			ld a, (.dmark)  
8210 32 6b ee			ld (debug_mark),a  
8213 3a 22 82			ld a, (.dmark+1)  
8216 32 6c ee			ld (debug_mark+1),a  
8219 3a 23 82			ld a, (.dmark+2)  
821c 32 6d ee			ld (debug_mark+2),a  
821f 18 03			jr .pastdmark  
8221 ..			.dmark: db "SW2"  
8224 f1			.pastdmark: pop af  
8225			endm  
# End of macro DMARK
8225			 
8225					;push af 
8225					;ld a, 'W' 
8225					;ld (debug_mark),a 
8225					;pop af 
8225					CALLMONITOR 
8225 cd 6f ee			call debug_vector  
8228				endm  
# End of macro CALLMONITOR
8228				endif 
8228 c9				ret	 
8229			 
8229			; Init bank 
8229			; --------- 
8229			; 
8229			; With current bank 
8229			; 
8229			; Setup block 0 config 
8229			;     Set 0 file id counter 
8229			;     Set formatted byte pattern 
8229			;     Zero out bank label 
8229			;      
8229			; For every logical block write 0-1 byte as null 
8229			 
8229			storage_get_block_0: 
8229			 
8229				; TODO check presence 
8229			 
8229				; get block 0 config 
8229			 
8229 21 00 00			ld hl, 0 
822c 11 7a ea			ld de, store_page 
822f cd 78 81			call storage_read_block 
8232			 
8232				if DEBUG_STORESE 
8232					DMARK "SB0" 
8232 f5				push af  
8233 3a 47 82			ld a, (.dmark)  
8236 32 6b ee			ld (debug_mark),a  
8239 3a 48 82			ld a, (.dmark+1)  
823c 32 6c ee			ld (debug_mark+1),a  
823f 3a 49 82			ld a, (.dmark+2)  
8242 32 6d ee			ld (debug_mark+2),a  
8245 18 03			jr .pastdmark  
8247 ..			.dmark: db "SB0"  
824a f1			.pastdmark: pop af  
824b			endm  
# End of macro DMARK
824b 11 7a ea				ld de, store_page 
824e			;		push af 
824e			;		ld a, 'i' 
824e			;		ld (debug_mark),a 
824e			;		pop af 
824e					CALLMONITOR 
824e cd 6f ee			call debug_vector  
8251				endm  
# End of macro CALLMONITOR
8251				endif 
8251			 
8251				; is this area formatted? 
8251			 
8251			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8251 2a 7b ea			ld hl, (store_page+1) 
8254 3e 80			ld a,0x80 
8256 bd				cp l 
8257 20 22			jr nz, .ininotformatted 
8259				; do a double check 
8259 3e 27			ld a, 0x27 
825b bc				cp h 
825c 20 1d			jr nz, .ininotformatted 
825e			 
825e				; formatted then 
825e			 
825e				if DEBUG_STORESE 
825e					DMARK "SB1" 
825e f5				push af  
825f 3a 73 82			ld a, (.dmark)  
8262 32 6b ee			ld (debug_mark),a  
8265 3a 74 82			ld a, (.dmark+1)  
8268 32 6c ee			ld (debug_mark+1),a  
826b 3a 75 82			ld a, (.dmark+2)  
826e 32 6d ee			ld (debug_mark+2),a  
8271 18 03			jr .pastdmark  
8273 ..			.dmark: db "SB1"  
8276 f1			.pastdmark: pop af  
8277			endm  
# End of macro DMARK
8277					;push af 
8277					;ld a, 'I' 
8277					;ld (debug_mark),a 
8277					;pop af 
8277					CALLMONITOR 
8277 cd 6f ee			call debug_vector  
827a				endm  
# End of macro CALLMONITOR
827a				endif 
827a c9				ret 
827b			 
827b			.ininotformatted: 
827b				; bank not formatted so poke various bits to make sure 
827b			 
827b				if DEBUG_STORESE 
827b					DMARK "SB2" 
827b f5				push af  
827c 3a 90 82			ld a, (.dmark)  
827f 32 6b ee			ld (debug_mark),a  
8282 3a 91 82			ld a, (.dmark+1)  
8285 32 6c ee			ld (debug_mark+1),a  
8288 3a 92 82			ld a, (.dmark+2)  
828b 32 6d ee			ld (debug_mark+2),a  
828e 18 03			jr .pastdmark  
8290 ..			.dmark: db "SB2"  
8293 f1			.pastdmark: pop af  
8294			endm  
# End of macro DMARK
8294					;push af 
8294					;ld a, 'f' 
8294					;ld (debug_mark),a 
8294					;pop af 
8294					CALLMONITOR 
8294 cd 6f ee			call debug_vector  
8297				endm  
# End of macro CALLMONITOR
8297				endif 
8297			 
8297 cd b4 89			call storage_clear_page 
829a			 
829a 21 7a ea			ld hl, store_page 
829d 3e 00			ld a, 0 
829f				 
829f 77				ld (hl),a   ; reset file counter 
82a0			 
82a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a3 22 7b ea		 	ld (store_page+1), hl	 
82a6			 
82a6				; set default label 
82a6			 
82a6 21 42 83			ld hl, .defaultbanklabl 
82a9 11 7d ea		 	ld de, store_page+3 
82ac 01 0f 00			ld bc, 15 
82af ed b0			ldir 
82b1			 
82b1				; Append the current bank id 
82b1 21 86 ea			ld hl, store_page+3+9 
82b4 3a 5f ea			ld a, (spi_device_id) 
82b7 77				ld (hl), a 
82b8			 
82b8				; save default page 0 
82b8			 
82b8 21 00 00			ld hl, 0 
82bb 11 7a ea			ld de, store_page 
82be				if DEBUG_STORESE 
82be					DMARK "SB3" 
82be f5				push af  
82bf 3a d3 82			ld a, (.dmark)  
82c2 32 6b ee			ld (debug_mark),a  
82c5 3a d4 82			ld a, (.dmark+1)  
82c8 32 6c ee			ld (debug_mark+1),a  
82cb 3a d5 82			ld a, (.dmark+2)  
82ce 32 6d ee			ld (debug_mark+2),a  
82d1 18 03			jr .pastdmark  
82d3 ..			.dmark: db "SB3"  
82d6 f1			.pastdmark: pop af  
82d7			endm  
# End of macro DMARK
82d7			;		push af 
82d7			;		ld a, 'F' 
82d7			;		ld (debug_mark),a 
82d7			;		pop af 
82d7					CALLMONITOR 
82d7 cd 6f ee			call debug_vector  
82da				endm  
# End of macro CALLMONITOR
82da				endif 
82da cd dd 81			call storage_write_block 
82dd				if DEBUG_STORESE 
82dd					DMARK "SB4" 
82dd f5				push af  
82de 3a f2 82			ld a, (.dmark)  
82e1 32 6b ee			ld (debug_mark),a  
82e4 3a f3 82			ld a, (.dmark+1)  
82e7 32 6c ee			ld (debug_mark+1),a  
82ea 3a f4 82			ld a, (.dmark+2)  
82ed 32 6d ee			ld (debug_mark+2),a  
82f0 18 03			jr .pastdmark  
82f2 ..			.dmark: db "SB4"  
82f5 f1			.pastdmark: pop af  
82f6			endm  
# End of macro DMARK
82f6			;		push af 
82f6			;		ld a, '>' 
82f6			;		ld (debug_mark),a 
82f6			;		pop af 
82f6					CALLMONITOR 
82f6 cd 6f ee			call debug_vector  
82f9				endm  
# End of macro CALLMONITOR
82f9				endif 
82f9			 
82f9 00				nop 
82fa 00				nop 
82fb 00				nop 
82fc			 
82fc				; now set 0 in every page to mark as a free block 
82fc			 
82fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82fe 21 40 00			ld hl, STORE_BLOCK_PHY 
8301			 
8301 3e 00		.setmark1:   	ld a,0 
8303 e5					push hl 
8304 c5					push bc 
8305 cd 9d 80				call se_writebyte 
8308 3e 0a			ld a, 10 
830a cd d6 89			call aDelayInMS 
830d 23				inc hl 
830e cd 9d 80				call se_writebyte 
8311 3e 0a			ld a, 10 
8313 cd d6 89			call aDelayInMS 
8316 2b				dec hl 
8317 c1					pop bc 
8318 e1					pop hl 
8319 3e 40				ld a, STORE_BLOCK_PHY 
831b cd db 8c				call addatohl 
831e 10 e1				djnz .setmark1 
8320			 
8320 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8322 3e 00		.setmark2:   	ld a,0 
8324 e5					push hl 
8325 c5					push bc 
8326 cd 9d 80				call se_writebyte 
8329 3e 0a			ld a, 10 
832b cd d6 89			call aDelayInMS 
832e 23				inc hl 
832f cd 9d 80				call se_writebyte 
8332 3e 0a			ld a, 10 
8334 cd d6 89			call aDelayInMS 
8337 2b				dec hl 
8338 c1					pop bc 
8339 e1					pop hl 
833a 3e 40				ld a, STORE_BLOCK_PHY 
833c cd db 8c				call addatohl 
833f 10 e1				djnz .setmark2 
8341			 
8341					 
8341			 
8341			 
8341 c9				ret 
8342			 
8342			 
8342			 
8342			 
8342 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834d			 
834d			 
834d			 
834d			; Label Bank 
834d			; ---------- 
834d			; 
834d			; With current bank 
834d			; Read block 0 
834d			; Set label 
834d			; Write block 0 
834d			 
834d			; label str pointer in hl 
834d			 
834d			storage_label:     
834d			 
834d				if DEBUG_STORESE 
834d					DMARK "LBL" 
834d f5				push af  
834e 3a 62 83			ld a, (.dmark)  
8351 32 6b ee			ld (debug_mark),a  
8354 3a 63 83			ld a, (.dmark+1)  
8357 32 6c ee			ld (debug_mark+1),a  
835a 3a 64 83			ld a, (.dmark+2)  
835d 32 6d ee			ld (debug_mark+2),a  
8360 18 03			jr .pastdmark  
8362 ..			.dmark: db "LBL"  
8365 f1			.pastdmark: pop af  
8366			endm  
# End of macro DMARK
8366					CALLMONITOR 
8366 cd 6f ee			call debug_vector  
8369				endm  
# End of macro CALLMONITOR
8369				endif 
8369			 
8369 e5				push hl 
836a			 
836a cd 29 82			call storage_get_block_0 
836d			 
836d				; set default label 
836d			 
836d e1				pop hl 
836e			 
836e 11 7d ea		 	ld de, store_page+3 
8371 01 0f 00			ld bc, 15 
8374				if DEBUG_STORESE 
8374					DMARK "LB3" 
8374 f5				push af  
8375 3a 89 83			ld a, (.dmark)  
8378 32 6b ee			ld (debug_mark),a  
837b 3a 8a 83			ld a, (.dmark+1)  
837e 32 6c ee			ld (debug_mark+1),a  
8381 3a 8b 83			ld a, (.dmark+2)  
8384 32 6d ee			ld (debug_mark+2),a  
8387 18 03			jr .pastdmark  
8389 ..			.dmark: db "LB3"  
838c f1			.pastdmark: pop af  
838d			endm  
# End of macro DMARK
838d					CALLMONITOR 
838d cd 6f ee			call debug_vector  
8390				endm  
# End of macro CALLMONITOR
8390				endif 
8390 ed b0			ldir 
8392				; save default page 0 
8392			 
8392 21 00 00			ld hl, 0 
8395 11 7a ea			ld de, store_page 
8398				if DEBUG_STORESE 
8398					DMARK "LBW" 
8398 f5				push af  
8399 3a ad 83			ld a, (.dmark)  
839c 32 6b ee			ld (debug_mark),a  
839f 3a ae 83			ld a, (.dmark+1)  
83a2 32 6c ee			ld (debug_mark+1),a  
83a5 3a af 83			ld a, (.dmark+2)  
83a8 32 6d ee			ld (debug_mark+2),a  
83ab 18 03			jr .pastdmark  
83ad ..			.dmark: db "LBW"  
83b0 f1			.pastdmark: pop af  
83b1			endm  
# End of macro DMARK
83b1					CALLMONITOR 
83b1 cd 6f ee			call debug_vector  
83b4				endm  
# End of macro CALLMONITOR
83b4				endif 
83b4 cd dd 81			call storage_write_block 
83b7			 
83b7 c9				ret 
83b8			 
83b8			 
83b8			 
83b8			; Read Block 0 - Config 
83b8			; --------------------- 
83b8			; 
83b8			; With current bank 
83b8			; Call presence test 
83b8			;    If not present format/init bank  
83b8			; Read block 0  
83b8			;  
83b8			 
83b8			 
83b8			; Dir 
83b8			; --- 
83b8			; 
83b8			; With current bank 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block read byte 2 
83b8			;      if first block of file 
83b8			;         Display file name 
83b8			;         Display type flags for file 
83b8			;        
83b8			 
83b8			; moving to words as this requires stack control 
83b8			 
83b8			 
83b8			; Delete File 
83b8			; ----------- 
83b8			; 
83b8			; With current bank 
83b8			; 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block file id 
83b8			;      If first block of file and dont have file id 
83b8			;         if file to delete 
83b8			;         Save file id 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			;      If file id is one saved 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			 
83b8			 
83b8			.se_done: 
83b8 e1				pop hl 
83b9 c9				ret 
83ba			 
83ba			storage_erase: 
83ba			 
83ba				; hl contains the file id 
83ba			 
83ba 5d				ld e, l 
83bb 16 00			ld d, 0 
83bd 21 40 00			ld hl, STORE_BLOCK_PHY 
83c0					if DEBUG_FORTH_WORDS 
83c0						DMARK "ERA" 
83c0 f5				push af  
83c1 3a d5 83			ld a, (.dmark)  
83c4 32 6b ee			ld (debug_mark),a  
83c7 3a d6 83			ld a, (.dmark+1)  
83ca 32 6c ee			ld (debug_mark+1),a  
83cd 3a d7 83			ld a, (.dmark+2)  
83d0 32 6d ee			ld (debug_mark+2),a  
83d3 18 03			jr .pastdmark  
83d5 ..			.dmark: db "ERA"  
83d8 f1			.pastdmark: pop af  
83d9			endm  
# End of macro DMARK
83d9						CALLMONITOR 
83d9 cd 6f ee			call debug_vector  
83dc				endm  
# End of macro CALLMONITOR
83dc					endif 
83dc cd ab 84			call storage_findnextid 
83df cd 04 8d			call ishlzero 
83e2 c8				ret z 
83e3			 
83e3 e5				push hl 
83e4			 
83e4				; TODO check file not found 
83e4			 
83e4 11 7a ea			ld de, store_page 
83e7 cd 78 81			call storage_read_block 
83ea			 
83ea cd 04 8d			call ishlzero 
83ed ca b8 83			jp z,.se_done 
83f0			 
83f0					if DEBUG_FORTH_WORDS 
83f0						DMARK "ER1" 
83f0 f5				push af  
83f1 3a 05 84			ld a, (.dmark)  
83f4 32 6b ee			ld (debug_mark),a  
83f7 3a 06 84			ld a, (.dmark+1)  
83fa 32 6c ee			ld (debug_mark+1),a  
83fd 3a 07 84			ld a, (.dmark+2)  
8400 32 6d ee			ld (debug_mark+2),a  
8403 18 03			jr .pastdmark  
8405 ..			.dmark: db "ER1"  
8408 f1			.pastdmark: pop af  
8409			endm  
# End of macro DMARK
8409						CALLMONITOR 
8409 cd 6f ee			call debug_vector  
840c				endm  
# End of macro CALLMONITOR
840c					endif 
840c 3a 7a ea			ld a, (store_page)	; get file id 
840f 32 6e ea			ld (store_tmpid), a 
8412			 
8412 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8415 32 6d ea			ld (store_tmpext), a 
8418			 
8418				; wipe file header 
8418			 
8418 e1				pop hl 
8419 3e 00			ld a, 0 
841b 32 7a ea			ld (store_page), a 
841e 32 7b ea			ld (store_page+1),a 
8421 11 7a ea			ld de, store_page 
8424					if DEBUG_FORTH_WORDS 
8424						DMARK "ER2" 
8424 f5				push af  
8425 3a 39 84			ld a, (.dmark)  
8428 32 6b ee			ld (debug_mark),a  
842b 3a 3a 84			ld a, (.dmark+1)  
842e 32 6c ee			ld (debug_mark+1),a  
8431 3a 3b 84			ld a, (.dmark+2)  
8434 32 6d ee			ld (debug_mark+2),a  
8437 18 03			jr .pastdmark  
8439 ..			.dmark: db "ER2"  
843c f1			.pastdmark: pop af  
843d			endm  
# End of macro DMARK
843d						CALLMONITOR 
843d cd 6f ee			call debug_vector  
8440				endm  
# End of macro CALLMONITOR
8440					endif 
8440 cd dd 81			call storage_write_block 
8443			 
8443			 
8443				; wipe file extents 
8443			 
8443 3a 6d ea			ld a, (store_tmpext) 
8446 47				ld b, a 
8447			 
8447			.eraext:	  
8447 c5				push bc 
8448			 
8448 21 40 00			ld hl, STORE_BLOCK_PHY 
844b 3a 6e ea			ld a,(store_tmpid) 
844e 5f				ld e, a 
844f 50				ld d, b	 
8450					if DEBUG_FORTH_WORDS 
8450						DMARK "ER3" 
8450 f5				push af  
8451 3a 65 84			ld a, (.dmark)  
8454 32 6b ee			ld (debug_mark),a  
8457 3a 66 84			ld a, (.dmark+1)  
845a 32 6c ee			ld (debug_mark+1),a  
845d 3a 67 84			ld a, (.dmark+2)  
8460 32 6d ee			ld (debug_mark+2),a  
8463 18 03			jr .pastdmark  
8465 ..			.dmark: db "ER3"  
8468 f1			.pastdmark: pop af  
8469			endm  
# End of macro DMARK
8469						CALLMONITOR 
8469 cd 6f ee			call debug_vector  
846c				endm  
# End of macro CALLMONITOR
846c					endif 
846c cd ab 84			call storage_findnextid 
846f cd 04 8d			call ishlzero 
8472 ca b8 83			jp z,.se_done 
8475			 
8475 e5				push hl 
8476 11 7a ea			ld de, store_page 
8479 cd 78 81			call storage_read_block 
847c			 
847c				; free block	 
847c			 
847c 3e 00			ld a, 0 
847e 32 7a ea			ld (store_page), a 
8481 32 7b ea			ld (store_page+1),a 
8484 11 7a ea			ld de, store_page 
8487 e1				pop hl 
8488					if DEBUG_FORTH_WORDS 
8488						DMARK "ER4" 
8488 f5				push af  
8489 3a 9d 84			ld a, (.dmark)  
848c 32 6b ee			ld (debug_mark),a  
848f 3a 9e 84			ld a, (.dmark+1)  
8492 32 6c ee			ld (debug_mark+1),a  
8495 3a 9f 84			ld a, (.dmark+2)  
8498 32 6d ee			ld (debug_mark+2),a  
849b 18 03			jr .pastdmark  
849d ..			.dmark: db "ER4"  
84a0 f1			.pastdmark: pop af  
84a1			endm  
# End of macro DMARK
84a1						CALLMONITOR 
84a1 cd 6f ee			call debug_vector  
84a4				endm  
# End of macro CALLMONITOR
84a4					endif 
84a4 cd dd 81			call storage_write_block 
84a7			 
84a7 c1				pop bc 
84a8 10 9d			djnz .eraext 
84aa			 
84aa c9				ret 
84ab			 
84ab			 
84ab			; Find Free Block 
84ab			; --------------- 
84ab			; 
84ab			; With current bank 
84ab			;  
84ab			; From given starting logical block 
84ab			;    Read block  
84ab			;    If no file id 
84ab			;         Return block id 
84ab			 
84ab			 
84ab			; hl starting page number 
84ab			; hl contains free page number or zero if no pages free 
84ab			; e contains the file id to locate 
84ab			; d contains the block number 
84ab			 
84ab			; TODO change to find file id and use zero for free block 
84ab			 
84ab			storage_findnextid: 
84ab			 
84ab				; now locate first 0 page to mark as a free block 
84ab			 
84ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ad			;	ld hl, STORE_BLOCK_PHY 
84ad			 
84ad					if DEBUG_FORTH_WORDS 
84ad					DMARK "FNI" 
84ad f5				push af  
84ae 3a c2 84			ld a, (.dmark)  
84b1 32 6b ee			ld (debug_mark),a  
84b4 3a c3 84			ld a, (.dmark+1)  
84b7 32 6c ee			ld (debug_mark+1),a  
84ba 3a c4 84			ld a, (.dmark+2)  
84bd 32 6d ee			ld (debug_mark+2),a  
84c0 18 03			jr .pastdmark  
84c2 ..			.dmark: db "FNI"  
84c5 f1			.pastdmark: pop af  
84c6			endm  
# End of macro DMARK
84c6						CALLMONITOR 
84c6 cd 6f ee			call debug_vector  
84c9				endm  
# End of macro CALLMONITOR
84c9					endif 
84c9			.ff1:   	 
84c9 e5					push hl 
84ca c5					push bc 
84cb d5					push de 
84cc cd 9c 80				call se_readbyte 
84cf 5f					ld e,a 
84d0 23					inc hl 
84d1 cd 9c 80				call se_readbyte 
84d4 57					ld d, a 
84d5 e1					pop hl 
84d6 e5					push hl 
84d7 cd f9 8c				call cmp16 
84da 28 49				jr z, .fffound 
84dc			 
84dc d1					pop de 
84dd c1					pop bc 
84de e1					pop hl 
84df			 
84df					; is found? 
84df					;cp e 
84df					;ret z 
84df			 
84df 3e 40				ld a, STORE_BLOCK_PHY 
84e1 cd db 8c				call addatohl 
84e4 10 e3				djnz .ff1 
84e6			 
84e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e8			.ff2:   	 
84e8			 
84e8 e5					push hl 
84e9 c5					push bc 
84ea d5					push de 
84eb cd 9c 80				call se_readbyte 
84ee 5f					ld e,a 
84ef 23					inc hl 
84f0 cd 9c 80				call se_readbyte 
84f3 57					ld d, a 
84f4			 
84f4 e1					pop hl 
84f5 e5					push hl 
84f6 cd f9 8c				call cmp16 
84f9 28 2a				jr z, .fffound 
84fb			 
84fb d1					pop de 
84fc c1					pop bc 
84fd e1					pop hl 
84fe					; is found? 
84fe					;cp e 
84fe					;ret z 
84fe			 
84fe 3e 40				ld a, STORE_BLOCK_PHY 
8500 cd db 8c				call addatohl 
8503 10 e3				djnz .ff2 
8505			 
8505			 
8505					if DEBUG_FORTH_WORDS 
8505					DMARK "FN-" 
8505 f5				push af  
8506 3a 1a 85			ld a, (.dmark)  
8509 32 6b ee			ld (debug_mark),a  
850c 3a 1b 85			ld a, (.dmark+1)  
850f 32 6c ee			ld (debug_mark+1),a  
8512 3a 1c 85			ld a, (.dmark+2)  
8515 32 6d ee			ld (debug_mark+2),a  
8518 18 03			jr .pastdmark  
851a ..			.dmark: db "FN-"  
851d f1			.pastdmark: pop af  
851e			endm  
# End of macro DMARK
851e					;	push af 
851e					;	ld a, 'n' 
851e					;	ld (debug_mark),a 
851e					;	pop af 
851e						CALLMONITOR 
851e cd 6f ee			call debug_vector  
8521				endm  
# End of macro CALLMONITOR
8521					endif 
8521				; no free marks! 
8521 21 00 00				ld hl, 0 
8524 c9				ret 
8525			.fffound: 
8525				 
8525			 
8525 d1					pop de 
8526 c1					pop bc 
8527 e1					pop hl 
8528					if DEBUG_FORTH_WORDS 
8528					DMARK "FNF" 
8528 f5				push af  
8529 3a 3d 85			ld a, (.dmark)  
852c 32 6b ee			ld (debug_mark),a  
852f 3a 3e 85			ld a, (.dmark+1)  
8532 32 6c ee			ld (debug_mark+1),a  
8535 3a 3f 85			ld a, (.dmark+2)  
8538 32 6d ee			ld (debug_mark+2),a  
853b 18 03			jr .pastdmark  
853d ..			.dmark: db "FNF"  
8540 f1			.pastdmark: pop af  
8541			endm  
# End of macro DMARK
8541					;	push af 
8541					;	ld a, 'n' 
8541					;	ld (debug_mark),a 
8541					;	pop af 
8541						CALLMONITOR 
8541 cd 6f ee			call debug_vector  
8544				endm  
# End of macro CALLMONITOR
8544					endif 
8544 c9				ret 
8545			 
8545			 
8545			 
8545			; Free Space 
8545			; ---------- 
8545			; 
8545			; With current bank 
8545			; 
8545			; Set block count to zero 
8545			; Starting with first logical block 
8545			;      Find free block  
8545			;      If block id given, increment block count 
8545			; 
8545			;  
8545			 
8545			 
8545			; hl contains count of free blocks 
8545			 
8545			storage_freeblocks: 
8545			 
8545				; now locate first 0 page to mark as a free block 
8545			 
8545 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8547 21 40 00			ld hl, STORE_BLOCK_PHY 
854a 11 00 00			ld de, 0 
854d			 
854d			.fb1:   	 
854d e5					push hl 
854e c5					push bc 
854f d5					push de 
8550 cd 9c 80				call se_readbyte 
8553 d1					pop de 
8554 c1					pop bc 
8555 e1					pop hl 
8556			 
8556					; is free? 
8556 fe 00				cp 0 
8558 20 01				jr nz, .ff1cont 
855a 13					inc de 
855b			 
855b			.ff1cont: 
855b			 
855b			 
855b 3e 40				ld a, STORE_BLOCK_PHY 
855d cd db 8c				call addatohl 
8560 10 eb				djnz .fb1 
8562			 
8562 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8564			.fb2:   	 
8564 e5					push hl 
8565 c5					push bc 
8566 d5					push de 
8567 cd 9c 80				call se_readbyte 
856a d1					pop de 
856b c1					pop bc 
856c e1					pop hl 
856d			 
856d					; is free? 
856d fe 00				cp 0 
856f 20 01				jr nz, .ff2cont 
8571 13					inc de 
8572			 
8572			.ff2cont: 
8572			 
8572 3e 40				ld a, STORE_BLOCK_PHY 
8574 cd db 8c				call addatohl 
8577 10 eb				djnz .fb2 
8579			 
8579 eb				ex de, hl 
857a c9				ret 
857b			 
857b			; Get File ID 
857b			; ----------- 
857b			; 
857b			; With current bank 
857b			;  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; For each logical block 
857b			;    Read block file id 
857b			;      If first block of file and dont have file id 
857b			;         if file get id and exit 
857b			 
857b			 
857b			 
857b			 
857b			; Create File 
857b			; ----------- 
857b			; 
857b			; With current bank  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; Increment file id number 
857b			; Save Config 
857b			; Find free block 
857b			; Set buffer with file name and file id 
857b			; Write buffer to free block  
857b			 
857b			 
857b			; hl point to file name 
857b			; hl returns file id 
857b			 
857b			; file format: 
857b			; byte 0 - file id 
857b			; byte 1 - extent number 
857b			; byte 2-> data 
857b			 
857b			; format for extent number 0: 
857b			; 
857b			; byte 0 - file id 
857b			; byte 1 - extent 0 
857b			; byte 2 - extent count 
857b			; byte 3 -> file name and meta data 
857b			 
857b			 
857b			storage_create: 
857b				if DEBUG_STORESE 
857b					DMARK "SCR" 
857b f5				push af  
857c 3a 90 85			ld a, (.dmark)  
857f 32 6b ee			ld (debug_mark),a  
8582 3a 91 85			ld a, (.dmark+1)  
8585 32 6c ee			ld (debug_mark+1),a  
8588 3a 92 85			ld a, (.dmark+2)  
858b 32 6d ee			ld (debug_mark+2),a  
858e 18 03			jr .pastdmark  
8590 ..			.dmark: db "SCR"  
8593 f1			.pastdmark: pop af  
8594			endm  
# End of macro DMARK
8594					CALLMONITOR 
8594 cd 6f ee			call debug_vector  
8597				endm  
# End of macro CALLMONITOR
8597				endif 
8597			 
8597 e5				push hl		; save file name pointer 
8598			 
8598 cd 29 82			call storage_get_block_0 
859b			 
859b 3a 7a ea			ld a,(store_page)	; get current file id 
859e 3c				inc a 
859f 32 7a ea			ld (store_page),a 
85a2				 
85a2 32 6e ea			ld (store_tmpid),a			; save id 
85a5			 
85a5 21 00 00			ld hl, 0 
85a8 11 7a ea			ld de, store_page 
85ab				if DEBUG_STORESE 
85ab					DMARK "SCw" 
85ab f5				push af  
85ac 3a c0 85			ld a, (.dmark)  
85af 32 6b ee			ld (debug_mark),a  
85b2 3a c1 85			ld a, (.dmark+1)  
85b5 32 6c ee			ld (debug_mark+1),a  
85b8 3a c2 85			ld a, (.dmark+2)  
85bb 32 6d ee			ld (debug_mark+2),a  
85be 18 03			jr .pastdmark  
85c0 ..			.dmark: db "SCw"  
85c3 f1			.pastdmark: pop af  
85c4			endm  
# End of macro DMARK
85c4					CALLMONITOR 
85c4 cd 6f ee			call debug_vector  
85c7				endm  
# End of macro CALLMONITOR
85c7				endif 
85c7 cd dd 81			call storage_write_block	 ; save update 
85ca			 
85ca				if DEBUG_STORESE 
85ca 11 7a ea				ld de, store_page 
85cd					DMARK "SCC" 
85cd f5				push af  
85ce 3a e2 85			ld a, (.dmark)  
85d1 32 6b ee			ld (debug_mark),a  
85d4 3a e3 85			ld a, (.dmark+1)  
85d7 32 6c ee			ld (debug_mark+1),a  
85da 3a e4 85			ld a, (.dmark+2)  
85dd 32 6d ee			ld (debug_mark+2),a  
85e0 18 03			jr .pastdmark  
85e2 ..			.dmark: db "SCC"  
85e5 f1			.pastdmark: pop af  
85e6			endm  
# End of macro DMARK
85e6					CALLMONITOR 
85e6 cd 6f ee			call debug_vector  
85e9				endm  
# End of macro CALLMONITOR
85e9				endif 
85e9				;  
85e9				 
85e9 21 40 00			ld hl, STORE_BLOCK_PHY 
85ec 11 00 00			ld de, 0 
85ef cd ab 84			call storage_findnextid 
85f2			 
85f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
85f5			 
85f5				; TODO detect 0 = no spare blocks 
85f5			 
85f5				; hl now contains the free page to use for the file header page 
85f5			 
85f5				if DEBUG_STORESE 
85f5				DMARK "SCF" 
85f5 f5				push af  
85f6 3a 0a 86			ld a, (.dmark)  
85f9 32 6b ee			ld (debug_mark),a  
85fc 3a 0b 86			ld a, (.dmark+1)  
85ff 32 6c ee			ld (debug_mark+1),a  
8602 3a 0c 86			ld a, (.dmark+2)  
8605 32 6d ee			ld (debug_mark+2),a  
8608 18 03			jr .pastdmark  
860a ..			.dmark: db "SCF"  
860d f1			.pastdmark: pop af  
860e			endm  
# End of macro DMARK
860e					CALLMONITOR 
860e cd 6f ee			call debug_vector  
8611				endm  
# End of macro CALLMONITOR
8611				endif 
8611			 
8611 22 65 ea			ld (store_tmppageid), hl 
8614				 
8614 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8617			;	ld a, (store_filecache)			; save to cache 
8617			 
8617 32 7a ea			ld (store_page),a    ; set page id 
861a 3e 00			ld a, 0			 ; extent 0 is file header 
861c 32 7b ea			ld (store_page+1), a   ; set file extent 
861f			 
861f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
8622			 
8622			;	inc hl 		; init block 0 of file 
8622			;	inc hl   		; skip file and extent id 
8622			 ;       ld a, 0 
8622			;	ld (hl),a 
8622			;	ld a, (store_filecache+1)  	; save to cache 
8622			 
8622			;	inc hl    ; file name 
8622				 
8622				 
8622 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8625				if DEBUG_STORESE 
8625					DMARK "SCc" 
8625 f5				push af  
8626 3a 3a 86			ld a, (.dmark)  
8629 32 6b ee			ld (debug_mark),a  
862c 3a 3b 86			ld a, (.dmark+1)  
862f 32 6c ee			ld (debug_mark+1),a  
8632 3a 3c 86			ld a, (.dmark+2)  
8635 32 6d ee			ld (debug_mark+2),a  
8638 18 03			jr .pastdmark  
863a ..			.dmark: db "SCc"  
863d f1			.pastdmark: pop af  
863e			endm  
# End of macro DMARK
863e					CALLMONITOR 
863e cd 6f ee			call debug_vector  
8641				endm  
# End of macro CALLMONITOR
8641				endif 
8641 e1				pop hl    ; get zero term string 
8642 e5				push hl 
8643 3e 00			ld a, 0 
8645 cd 4c 90			call strlent 
8648 23				inc hl   ; cover zero term 
8649 06 00			ld b,0 
864b 4d				ld c,l 
864c e1				pop hl 
864d				;ex de, hl 
864d				if DEBUG_STORESE 
864d					DMARK "SCa" 
864d f5				push af  
864e 3a 62 86			ld a, (.dmark)  
8651 32 6b ee			ld (debug_mark),a  
8654 3a 63 86			ld a, (.dmark+1)  
8657 32 6c ee			ld (debug_mark+1),a  
865a 3a 64 86			ld a, (.dmark+2)  
865d 32 6d ee			ld (debug_mark+2),a  
8660 18 03			jr .pastdmark  
8662 ..			.dmark: db "SCa"  
8665 f1			.pastdmark: pop af  
8666			endm  
# End of macro DMARK
8666					;push af 
8666					;ld a, 'a' 
8666					;ld (debug_mark),a 
8666					;pop af 
8666					CALLMONITOR 
8666 cd 6f ee			call debug_vector  
8669				endm  
# End of macro CALLMONITOR
8669				endif 
8669 ed b0			ldir    ; copy zero term string 
866b				if DEBUG_STORESE 
866b					DMARK "SCA" 
866b f5				push af  
866c 3a 80 86			ld a, (.dmark)  
866f 32 6b ee			ld (debug_mark),a  
8672 3a 81 86			ld a, (.dmark+1)  
8675 32 6c ee			ld (debug_mark+1),a  
8678 3a 82 86			ld a, (.dmark+2)  
867b 32 6d ee			ld (debug_mark+2),a  
867e 18 03			jr .pastdmark  
8680 ..			.dmark: db "SCA"  
8683 f1			.pastdmark: pop af  
8684			endm  
# End of macro DMARK
8684					CALLMONITOR 
8684 cd 6f ee			call debug_vector  
8687				endm  
# End of macro CALLMONITOR
8687				endif 
8687			 
8687				; write file header page 
8687			 
8687 2a 65 ea			ld hl,(store_tmppageid) 
868a 11 7a ea			ld de, store_page 
868d				if DEBUG_STORESE 
868d					DMARK "SCb" 
868d f5				push af  
868e 3a a2 86			ld a, (.dmark)  
8691 32 6b ee			ld (debug_mark),a  
8694 3a a3 86			ld a, (.dmark+1)  
8697 32 6c ee			ld (debug_mark+1),a  
869a 3a a4 86			ld a, (.dmark+2)  
869d 32 6d ee			ld (debug_mark+2),a  
86a0 18 03			jr .pastdmark  
86a2 ..			.dmark: db "SCb"  
86a5 f1			.pastdmark: pop af  
86a6			endm  
# End of macro DMARK
86a6					;push af 
86a6					;ld a, 'b' 
86a6					;ld (debug_mark),a 
86a6					;pop af 
86a6					CALLMONITOR 
86a6 cd 6f ee			call debug_vector  
86a9				endm  
# End of macro CALLMONITOR
86a9				endif 
86a9 cd dd 81			call storage_write_block 
86ac			 
86ac 3a 6e ea			ld a, (store_tmpid) 
86af 6f				ld l, a 
86b0 26 00			ld h,0 
86b2				if DEBUG_STORESE 
86b2					DMARK "SCz" 
86b2 f5				push af  
86b3 3a c7 86			ld a, (.dmark)  
86b6 32 6b ee			ld (debug_mark),a  
86b9 3a c8 86			ld a, (.dmark+1)  
86bc 32 6c ee			ld (debug_mark+1),a  
86bf 3a c9 86			ld a, (.dmark+2)  
86c2 32 6d ee			ld (debug_mark+2),a  
86c5 18 03			jr .pastdmark  
86c7 ..			.dmark: db "SCz"  
86ca f1			.pastdmark: pop af  
86cb			endm  
# End of macro DMARK
86cb					CALLMONITOR 
86cb cd 6f ee			call debug_vector  
86ce				endm  
# End of macro CALLMONITOR
86ce				endif 
86ce c9				ret 
86cf				 
86cf			 
86cf			 
86cf			; 
86cf			; Read File 
86cf			; 
86cf			; h - file id to locate 
86cf			; l - extent to locate 
86cf			; de - pointer to string to read into 
86cf			; 
86cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86cf			 
86cf			.sr_fail: 
86cf d1				pop de 
86d0 c9				ret 
86d1			 
86d1			storage_read: 
86d1			 
86d1			 
86d1 d5				push de 
86d2			 
86d2			; TODO BUG the above push is it popped before the RET Z? 
86d2			 
86d2			; TODO how to handle multiple part blocks 
86d2			 
86d2				; locate file extent to read 
86d2			 
86d2 5c				ld e, h 
86d3 55				ld d, l 
86d4			 
86d4			.srext: 
86d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86db			 
86db 21 40 00			ld hl, STORE_BLOCK_PHY 
86de				if DEBUG_STORESE 
86de					DMARK "sre" 
86de f5				push af  
86df 3a f3 86			ld a, (.dmark)  
86e2 32 6b ee			ld (debug_mark),a  
86e5 3a f4 86			ld a, (.dmark+1)  
86e8 32 6c ee			ld (debug_mark+1),a  
86eb 3a f5 86			ld a, (.dmark+2)  
86ee 32 6d ee			ld (debug_mark+2),a  
86f1 18 03			jr .pastdmark  
86f3 ..			.dmark: db "sre"  
86f6 f1			.pastdmark: pop af  
86f7			endm  
# End of macro DMARK
86f7					CALLMONITOR 
86f7 cd 6f ee			call debug_vector  
86fa				endm  
# End of macro CALLMONITOR
86fa				endif 
86fa cd ab 84			call storage_findnextid 
86fd			 
86fd				if DEBUG_STORESE 
86fd					DMARK "srf" 
86fd f5				push af  
86fe 3a 12 87			ld a, (.dmark)  
8701 32 6b ee			ld (debug_mark),a  
8704 3a 13 87			ld a, (.dmark+1)  
8707 32 6c ee			ld (debug_mark+1),a  
870a 3a 14 87			ld a, (.dmark+2)  
870d 32 6d ee			ld (debug_mark+2),a  
8710 18 03			jr .pastdmark  
8712 ..			.dmark: db "srf"  
8715 f1			.pastdmark: pop af  
8716			endm  
# End of macro DMARK
8716					CALLMONITOR 
8716 cd 6f ee			call debug_vector  
8719				endm  
# End of macro CALLMONITOR
8719				endif 
8719 cd 04 8d			call ishlzero 
871c			;	ld a, l 
871c			;	add h 
871c			;	cp 0 
871c 28 b1			jr z,.sr_fail			; block not found so EOF 
871e			 
871e				; save current address for use by higher level words etc 
871e			 
871e 22 6b ea			ld (store_openaddr),hl 
8721			 
8721			 
8721				; hl contains page number to load 
8721 d1				pop de   ; get storage 
8722 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8726 d5				push de 
8727				if DEBUG_STORESE 
8727					DMARK "srg" 
8727 f5				push af  
8728 3a 3c 87			ld a, (.dmark)  
872b 32 6b ee			ld (debug_mark),a  
872e 3a 3d 87			ld a, (.dmark+1)  
8731 32 6c ee			ld (debug_mark+1),a  
8734 3a 3e 87			ld a, (.dmark+2)  
8737 32 6d ee			ld (debug_mark+2),a  
873a 18 03			jr .pastdmark  
873c ..			.dmark: db "srg"  
873f f1			.pastdmark: pop af  
8740			endm  
# End of macro DMARK
8740					CALLMONITOR 
8740 cd 6f ee			call debug_vector  
8743				endm  
# End of macro CALLMONITOR
8743				endif 
8743 cd 78 81			call storage_read_block 
8746			 
8746				; if this a continuation read??? 
8746			 
8746 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8749			 
8749 3e 3f			ld a, STORE_BLOCK_PHY-1 
874b cd db 8c			call addatohl 
874e 7e				ld a,(hl) 
874f fe 00			cp 0 
8751 28 02			jr z, .markiscont 
8753 3e ff			ld a, 255 
8755			 
8755			.markiscont: 
8755 32 6d ea			ld (store_readcont), a 
8758			 
8758				if DEBUG_STORESE 
8758					DMARK "srC" 
8758 f5				push af  
8759 3a 6d 87			ld a, (.dmark)  
875c 32 6b ee			ld (debug_mark),a  
875f 3a 6e 87			ld a, (.dmark+1)  
8762 32 6c ee			ld (debug_mark+1),a  
8765 3a 6f 87			ld a, (.dmark+2)  
8768 32 6d ee			ld (debug_mark+2),a  
876b 18 03			jr .pastdmark  
876d ..			.dmark: db "srC"  
8770 f1			.pastdmark: pop af  
8771			endm  
# End of macro DMARK
8771					CALLMONITOR 
8771 cd 6f ee			call debug_vector  
8774				endm  
# End of macro CALLMONITOR
8774				endif 
8774				; only short reads enabled 
8774			 
8774 3a 75 ea			ld a, (store_longread) 
8777 fe 00			cp 0 
8779 ca 46 88			jp z, .readdone 
877c			 
877c			; TODO if block has no zeros then need to read next block  
877c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877c			; check last byte of physical block. 
877c			; if not zero then the next block needs to be loaded 
877c			 
877c			 
877c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
877f			 
877f 3e 3f			ld a, STORE_BLOCK_PHY-1 
8781 cd db 8c			call addatohl 
8784				;dec hl 
8784 7e				ld a,(hl) 
8785				if DEBUG_STORESE 
8785					DMARK "sr?" 
8785 f5				push af  
8786 3a 9a 87			ld a, (.dmark)  
8789 32 6b ee			ld (debug_mark),a  
878c 3a 9b 87			ld a, (.dmark+1)  
878f 32 6c ee			ld (debug_mark+1),a  
8792 3a 9c 87			ld a, (.dmark+2)  
8795 32 6d ee			ld (debug_mark+2),a  
8798 18 03			jr .pastdmark  
879a ..			.dmark: db "sr?"  
879d f1			.pastdmark: pop af  
879e			endm  
# End of macro DMARK
879e					CALLMONITOR 
879e cd 6f ee			call debug_vector  
87a1				endm  
# End of macro CALLMONITOR
87a1				endif 
87a1 fe 00			cp 0 
87a3 ca 46 88			jp z, .readdone 
87a6			 
87a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a6			 
87a6 23				inc hl 
87a7			 
87a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87aa			 
87aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87ae			 
87ae eb				ex de, hl 
87af			 
87af				; next ext 
87af			 
87af 23				inc hl 
87b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b3			 
87b3				if DEBUG_STORESE 
87b3					DMARK "sF2" 
87b3 f5				push af  
87b4 3a c8 87			ld a, (.dmark)  
87b7 32 6b ee			ld (debug_mark),a  
87ba 3a c9 87			ld a, (.dmark+1)  
87bd 32 6c ee			ld (debug_mark+1),a  
87c0 3a ca 87			ld a, (.dmark+2)  
87c3 32 6d ee			ld (debug_mark+2),a  
87c6 18 03			jr .pastdmark  
87c8 ..			.dmark: db "sF2"  
87cb f1			.pastdmark: pop af  
87cc			endm  
# End of macro DMARK
87cc					CALLMONITOR 
87cc cd 6f ee			call debug_vector  
87cf				endm  
# End of macro CALLMONITOR
87cf				endif 
87cf			 
87cf				; get and load block 
87cf			 
87cf cd ab 84			call storage_findnextid 
87d2			 
87d2				if DEBUG_STORESE 
87d2					DMARK "sf2" 
87d2 f5				push af  
87d3 3a e7 87			ld a, (.dmark)  
87d6 32 6b ee			ld (debug_mark),a  
87d9 3a e8 87			ld a, (.dmark+1)  
87dc 32 6c ee			ld (debug_mark+1),a  
87df 3a e9 87			ld a, (.dmark+2)  
87e2 32 6d ee			ld (debug_mark+2),a  
87e5 18 03			jr .pastdmark  
87e7 ..			.dmark: db "sf2"  
87ea f1			.pastdmark: pop af  
87eb			endm  
# End of macro DMARK
87eb					CALLMONITOR 
87eb cd 6f ee			call debug_vector  
87ee				endm  
# End of macro CALLMONITOR
87ee				endif 
87ee cd 04 8d			call ishlzero 
87f1			;	ld a, l 
87f1			;	add h 
87f1			;	cp 0 
87f1 ca cf 86			jp z,.sr_fail			; block not found so EOF 
87f4				 
87f4				; save current address for use by higher level words etc 
87f4			 
87f4 22 6b ea			ld (store_openaddr),hl 
87f7			 
87f7 cd 78 81			call storage_read_block 
87fa			 
87fa				; on a continuation block, we now have the file id and ext in the middle of the block 
87fa				; we need to pull everything back  
87fa			 
87fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8801 23				inc hl 
8802 23				inc hl     ; skip id and ext 
8803 01 40 00			ld bc, STORE_BLOCK_PHY 
8806				if DEBUG_STORESE 
8806					DMARK "SR<" 
8806 f5				push af  
8807 3a 1b 88			ld a, (.dmark)  
880a 32 6b ee			ld (debug_mark),a  
880d 3a 1c 88			ld a, (.dmark+1)  
8810 32 6c ee			ld (debug_mark+1),a  
8813 3a 1d 88			ld a, (.dmark+2)  
8816 32 6d ee			ld (debug_mark+2),a  
8819 18 03			jr .pastdmark  
881b ..			.dmark: db "SR<"  
881e f1			.pastdmark: pop af  
881f			endm  
# End of macro DMARK
881f					CALLMONITOR 
881f cd 6f ee			call debug_vector  
8822				endm  
# End of macro CALLMONITOR
8822				endif 
8822 ed b0			ldir     ; copy data 
8824			 
8824				; move the pointer back and pretend we have a full buffer for next recheck 
8824			 
8824 1b				dec de 
8825 1b				dec de 
8826			 
8826			; TODO do pop below now short circuit loop????? 
8826 c1				pop bc     ; get rid of spare de on stack 
8827				if DEBUG_STORESE 
8827					DMARK "SR>" 
8827 f5				push af  
8828 3a 3c 88			ld a, (.dmark)  
882b 32 6b ee			ld (debug_mark),a  
882e 3a 3d 88			ld a, (.dmark+1)  
8831 32 6c ee			ld (debug_mark+1),a  
8834 3a 3e 88			ld a, (.dmark+2)  
8837 32 6d ee			ld (debug_mark+2),a  
883a 18 03			jr .pastdmark  
883c ..			.dmark: db "SR>"  
883f f1			.pastdmark: pop af  
8840			endm  
# End of macro DMARK
8840					CALLMONITOR 
8840 cd 6f ee			call debug_vector  
8843				endm  
# End of macro CALLMONITOR
8843				endif 
8843 c3 d4 86			jp .srext 
8846			 
8846			 
8846			 
8846			 
8846			 
8846			.readdone:		 
8846 e1				pop hl 		 ; return start of data to show as not EOF 
8847 23				inc hl   ; past file id 
8848 23				inc hl   ; past ext 
8849				if DEBUG_STORESE 
8849					DMARK "SRe" 
8849 f5				push af  
884a 3a 5e 88			ld a, (.dmark)  
884d 32 6b ee			ld (debug_mark),a  
8850 3a 5f 88			ld a, (.dmark+1)  
8853 32 6c ee			ld (debug_mark+1),a  
8856 3a 60 88			ld a, (.dmark+2)  
8859 32 6d ee			ld (debug_mark+2),a  
885c 18 03			jr .pastdmark  
885e ..			.dmark: db "SRe"  
8861 f1			.pastdmark: pop af  
8862			endm  
# End of macro DMARK
8862					CALLMONITOR 
8862 cd 6f ee			call debug_vector  
8865				endm  
# End of macro CALLMONITOR
8865				endif 
8865 c9					ret 
8866			 
8866			 
8866			 
8866			; 
8866			; Append File 
8866			; 
8866			; hl - file id to locate 
8866			; de - pointer to (multi block) string to write 
8866			 
8866			.sa_notfound: 
8866 d1				pop de 
8867 c9				ret 
8868			 
8868			 
8868			storage_append: 
8868				; hl -  file id to append to 
8868				; de - string to append 
8868			 
8868 d5				push de 
8869				 
8869				if DEBUG_STORESE 
8869					DMARK "AP1" 
8869 f5				push af  
886a 3a 7e 88			ld a, (.dmark)  
886d 32 6b ee			ld (debug_mark),a  
8870 3a 7f 88			ld a, (.dmark+1)  
8873 32 6c ee			ld (debug_mark+1),a  
8876 3a 80 88			ld a, (.dmark+2)  
8879 32 6d ee			ld (debug_mark+2),a  
887c 18 03			jr .pastdmark  
887e ..			.dmark: db "AP1"  
8881 f1			.pastdmark: pop af  
8882			endm  
# End of macro DMARK
8882					CALLMONITOR 
8882 cd 6f ee			call debug_vector  
8885				endm  
# End of macro CALLMONITOR
8885				endif 
8885			 
8885 7d				ld a, l 
8886 32 6e ea			ld (store_tmpid), a 
8889			 
8889				; get file header  
8889			 
8889 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888b 3a 6e ea			ld a, (store_tmpid) 
888e 5f				ld e, a 
888f			 
888f 21 40 00				ld hl, STORE_BLOCK_PHY 
8892 cd ab 84				call storage_findnextid 
8895			 
8895 cd 04 8d			call ishlzero 
8898 28 cc			jr z, .sa_notfound 
889a			 
889a 22 65 ea			ld (store_tmppageid), hl 
889d			 
889d				; TODO handle file id not found 
889d			 
889d				if DEBUG_STORESE 
889d					DMARK "AP2" 
889d f5				push af  
889e 3a b2 88			ld a, (.dmark)  
88a1 32 6b ee			ld (debug_mark),a  
88a4 3a b3 88			ld a, (.dmark+1)  
88a7 32 6c ee			ld (debug_mark+1),a  
88aa 3a b4 88			ld a, (.dmark+2)  
88ad 32 6d ee			ld (debug_mark+2),a  
88b0 18 03			jr .pastdmark  
88b2 ..			.dmark: db "AP2"  
88b5 f1			.pastdmark: pop af  
88b6			endm  
# End of macro DMARK
88b6					CALLMONITOR 
88b6 cd 6f ee			call debug_vector  
88b9				endm  
# End of macro CALLMONITOR
88b9				endif 
88b9			 
88b9				; update file extent count 
88b9			 
88b9 11 7a ea			ld de, store_page 
88bc			 
88bc cd 78 81			call storage_read_block 
88bf			 
88bf				if DEBUG_STORESE 
88bf					DMARK "AP3" 
88bf f5				push af  
88c0 3a d4 88			ld a, (.dmark)  
88c3 32 6b ee			ld (debug_mark),a  
88c6 3a d5 88			ld a, (.dmark+1)  
88c9 32 6c ee			ld (debug_mark+1),a  
88cc 3a d6 88			ld a, (.dmark+2)  
88cf 32 6d ee			ld (debug_mark+2),a  
88d2 18 03			jr .pastdmark  
88d4 ..			.dmark: db "AP3"  
88d7 f1			.pastdmark: pop af  
88d8			endm  
# End of macro DMARK
88d8					CALLMONITOR 
88d8 cd 6f ee			call debug_vector  
88db				endm  
# End of macro CALLMONITOR
88db				endif 
88db			;	ld (store_tmppageid), hl 
88db			 
88db 3a 7c ea			ld a, (store_page+2) 
88de 3c				inc a 
88df 32 7c ea			ld (store_page+2), a 
88e2 32 6d ea			ld (store_tmpext), a 
88e5				 
88e5				if DEBUG_STORESE 
88e5					DMARK "AP3" 
88e5 f5				push af  
88e6 3a fa 88			ld a, (.dmark)  
88e9 32 6b ee			ld (debug_mark),a  
88ec 3a fb 88			ld a, (.dmark+1)  
88ef 32 6c ee			ld (debug_mark+1),a  
88f2 3a fc 88			ld a, (.dmark+2)  
88f5 32 6d ee			ld (debug_mark+2),a  
88f8 18 03			jr .pastdmark  
88fa ..			.dmark: db "AP3"  
88fd f1			.pastdmark: pop af  
88fe			endm  
# End of macro DMARK
88fe					CALLMONITOR 
88fe cd 6f ee			call debug_vector  
8901				endm  
# End of macro CALLMONITOR
8901				endif 
8901 2a 65 ea			ld hl, (store_tmppageid) 
8904 11 7a ea			ld de, store_page 
8907 cd dd 81			call storage_write_block 
890a			 
890a				; find free block 
890a			 
890a 11 00 00			ld de, 0			 ; file extent to locate 
890d			 
890d 21 40 00				ld hl, STORE_BLOCK_PHY 
8910 cd ab 84				call storage_findnextid 
8913 cd 04 8d			call ishlzero 
8916 ca 66 88			jp z, .sa_notfound 
8919			 
8919					; TODO handle no space left 
8919					 
8919 22 65 ea				ld (store_tmppageid), hl 
891c			 
891c				if DEBUG_STORESE 
891c					DMARK "AP4" 
891c f5				push af  
891d 3a 31 89			ld a, (.dmark)  
8920 32 6b ee			ld (debug_mark),a  
8923 3a 32 89			ld a, (.dmark+1)  
8926 32 6c ee			ld (debug_mark+1),a  
8929 3a 33 89			ld a, (.dmark+2)  
892c 32 6d ee			ld (debug_mark+2),a  
892f 18 03			jr .pastdmark  
8931 ..			.dmark: db "AP4"  
8934 f1			.pastdmark: pop af  
8935			endm  
# End of macro DMARK
8935					CALLMONITOR 
8935 cd 6f ee			call debug_vector  
8938				endm  
# End of macro CALLMONITOR
8938				endif 
8938					; init the buffer with zeros so we can id if the buffer is full or not 
8938			 
8938 e5					push hl 
8939 c5					push bc 
893a			 
893a 21 7a ea				ld hl, store_page 
893d 06 40				ld b, STORE_BLOCK_PHY 
893f 3e 00				ld a, 0 
8941 77			.zeroblock:	ld (hl), a 
8942 23					inc hl 
8943 10 fc				djnz .zeroblock 
8945			 
8945 c1					pop bc 
8946 e1					pop hl 
8947			 
8947					; construct block 
8947			 
8947 3a 6e ea				ld a, (store_tmpid) 
894a 32 7a ea				ld (store_page), a   ; file id 
894d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
8950 32 7b ea				ld (store_page+1), a 
8953			 
8953 e1					pop hl    ; get string to write 
8954 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8956 11 7c ea				ld de, store_page+2 
8959			 
8959				if DEBUG_STORESE 
8959					DMARK "AP5" 
8959 f5				push af  
895a 3a 6e 89			ld a, (.dmark)  
895d 32 6b ee			ld (debug_mark),a  
8960 3a 6f 89			ld a, (.dmark+1)  
8963 32 6c ee			ld (debug_mark+1),a  
8966 3a 70 89			ld a, (.dmark+2)  
8969 32 6d ee			ld (debug_mark+2),a  
896c 18 03			jr .pastdmark  
896e ..			.dmark: db "AP5"  
8971 f1			.pastdmark: pop af  
8972			endm  
# End of macro DMARK
8972					CALLMONITOR 
8972 cd 6f ee			call debug_vector  
8975				endm  
# End of macro CALLMONITOR
8975				endif 
8975			 
8975			 
8975			 
8975					; fill buffer with data until end of string or full block 
8975			 
8975 7e			.appd:		ld a, (hl) 
8976 12					ld (de), a 
8977 fe 00				cp 0 
8979 28 04				jr z, .appdone 
897b 23					inc hl 
897c 13					inc de 
897d 10 f6				djnz .appd 
897f			 
897f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8980 f5					push af   		; save last byte dumped 
8981			 
8981			 
8981 2a 65 ea			ld hl, (store_tmppageid) 
8984 11 7a ea			ld de, store_page 
8987				if DEBUG_STORESE 
8987					DMARK "AP6" 
8987 f5				push af  
8988 3a 9c 89			ld a, (.dmark)  
898b 32 6b ee			ld (debug_mark),a  
898e 3a 9d 89			ld a, (.dmark+1)  
8991 32 6c ee			ld (debug_mark+1),a  
8994 3a 9e 89			ld a, (.dmark+2)  
8997 32 6d ee			ld (debug_mark+2),a  
899a 18 03			jr .pastdmark  
899c ..			.dmark: db "AP6"  
899f f1			.pastdmark: pop af  
89a0			endm  
# End of macro DMARK
89a0					CALLMONITOR 
89a0 cd 6f ee			call debug_vector  
89a3				endm  
# End of macro CALLMONITOR
89a3				endif 
89a3 cd dd 81				call storage_write_block 
89a6			 
89a6			 
89a6				; was that a full block of data written? 
89a6				; any more to write out? 
89a6			 
89a6				; if yes then set vars and jump to start of function again 
89a6			 
89a6 f1					pop af 
89a7 d1					pop de 
89a8			 
89a8 fe 00				cp 0		 ; no, string was fully written 
89aa c8					ret z 
89ab			 
89ab					; setup vars for next cycle 
89ab			 
89ab 3a 6e ea				ld a, (store_tmpid) 
89ae 6f					ld l, a 
89af 26 00				ld h, 0 
89b1			 
89b1 c3 68 88			 	jp storage_append	 ; yes, need to write out some more 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			if DEBUG_STORECF 
89b4			storageput:	 
89b4					ret 
89b4			storageread: 
89b4					ld hl, store_page 
89b4					ld b, 200 
89b4					ld a,0 
89b4			.src:		ld (hl),a 
89b4					inc hl 
89b4					djnz .src 
89b4					 
89b4			 
89b4					ld de, 0 
89b4					ld bc, 1 
89b4					ld hl, store_page 
89b4					call cfRead 
89b4			 
89b4				call cfGetError 
89b4				ld hl,scratch 
89b4				call hexout 
89b4				ld hl, scratch+2 
89b4				ld a, 0 
89b4				ld (hl),a 
89b4				ld de, scratch 
89b4				ld a,display_row_1 
89b4				call str_at_display 
89b4				call update_display 
89b4			 
89b4					ld hl, store_page 
89b4					ld (os_cur_ptr),hl 
89b4			 
89b4					ret 
89b4			endif 
89b4			 
89b4			 
89b4			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b4			 
89b4			storage_clear_page: 
89b4 e5				push hl 
89b5 d5				push de 
89b6 c5				push bc 
89b7 21 7a ea			ld hl, store_page 
89ba 3e 00			ld a, 0 
89bc 77				ld (hl), a 
89bd			 
89bd 11 7b ea			ld de, store_page+1 
89c0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c3			 
89c3 ed b0			ldir 
89c5				 
89c5 c1				pop bc 
89c6 d1				pop de 
89c7 e1				pop hl 
89c8 c9				ret 
89c9			 
89c9			; eof 
# End of file firmware_storage.asm
89c9			  
89c9			; support routines for above hardware abstraction layer  
89c9			  
89c9			include "firmware_general.asm"        ; general support functions  
89c9			 
89c9			; word look up 
89c9			 
89c9			; in 
89c9			; a is the index 
89c9			; hl is pointer start of array 
89c9			; 
89c9			; returns 
89c9			; hl to the word 
89c9			; 
89c9			 
89c9			table_lookup:  
89c9 d5					push de 
89ca eb					ex de, hl 
89cb			 
89cb 6f					ld l, a 
89cc 26 00				ld h, 0 
89ce 29					add hl, hl 
89cf 19					add hl, de 
89d0 7e					ld a, (hl) 
89d1 23					inc hl 
89d2 66					ld h,(hl) 
89d3 6f					ld l, a 
89d4			 
89d4 d1					pop de 
89d5 c9					ret 
89d6			 
89d6			; Delay loops 
89d6			 
89d6			 
89d6			 
89d6			aDelayInMS: 
89d6 c5				push bc 
89d7 47				ld b,a 
89d8			msdelay: 
89d8 c5				push bc 
89d9				 
89d9			 
89d9 01 41 00			ld bc,041h 
89dc cd f4 89			call delayloop 
89df c1				pop bc 
89e0 05				dec b 
89e1 20 f5			jr nz,msdelay 
89e3			 
89e3			;if CPU_CLOCK_8MHZ 
89e3			;msdelay8: 
89e3			;	push bc 
89e3			;	 
89e3			; 
89e3			;	ld bc,041h 
89e3			;	call delayloop 
89e3			;	pop bc 
89e3			;	dec b 
89e3			;	jr nz,msdelay8 
89e3			;endif 
89e3			 
89e3			 
89e3 c1				pop bc 
89e4 c9				ret 
89e5			 
89e5			 
89e5			delay250ms: 
89e5				;push de 
89e5 01 00 40			ld bc, 04000h 
89e8 c3 f4 89			jp delayloop 
89eb			delay500ms: 
89eb				;push de 
89eb 01 00 80			ld bc, 08000h 
89ee c3 f4 89			jp delayloop 
89f1			delay1s: 
89f1				;push bc 
89f1			   ; Clobbers A, d and e 
89f1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f4			delayloop: 
89f4 c5			    push bc 
89f5			 
89f5			if BASE_CPM 
89f5				ld bc, CPM_DELAY_TUNE 
89f5			.cpmloop: 
89f5				push bc 
89f5			 
89f5			endif 
89f5			 
89f5			 
89f5			 
89f5			delayloopi: 
89f5			;	push bc 
89f5			;.dl: 
89f5 cb 47		    bit     0,a    	; 8 
89f7 cb 47		    bit     0,a    	; 8 
89f9 cb 47		    bit     0,a    	; 8 
89fb e6 ff		    and     255  	; 7 
89fd 0b			    dec     bc      	; 6 
89fe 79			    ld      a,c     	; 4 
89ff b0			    or      b     	; 4 
8a00 c2 f5 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a03			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a03				;pop de 
8a03			;pop bc 
8a03			 
8a03			if BASE_CPM 
8a03				pop bc 
8a03				 
8a03			    dec     bc      	; 6 
8a03			    ld      a,c     	; 4 
8a03			    or      b     	; 4 
8a03			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a03				 
8a03			 
8a03			endif 
8a03			;if CPU_CLOCK_8MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03			 
8a03			;if CPU_CLOCK_10MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03 c1			    pop bc 
8a04			 
8a04 c9				ret 
8a05			 
8a05			 
8a05			 
8a05			; eof 
# End of file firmware_general.asm
8a05			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a05			; display routines that use the physical hardware abstraction layer 
8a05			 
8a05			 
8a05			; Display an activity indicator 
8a05			; Each call returns the new char pointed to in hl 
8a05			 
8a05			active: 
8a05 3a c6 eb			ld a, (display_active) 
8a08 fe 06			cp 6 
8a0a			 
8a0a 20 02			jr nz, .sne 
8a0c				; gone past the last one reset sequence 
8a0c 3e ff			ld a, 255 
8a0e			 
8a0e			.sne:   
8a0e				; get the next char in seq 
8a0e 3c				inc a 
8a0f 32 c6 eb			ld (display_active), a 
8a12			 
8a12				; look up the string in the table 
8a12 21 29 8a			ld hl, actseq 
8a15 cb 27			sla a 
8a17 cd db 8c			call addatohl 
8a1a cd 9f 9d			call loadwordinhl 
8a1d			 
8a1d				; forth will write the to string when pushing so move from rom to ram 
8a1d			 
8a1d 11 c7 eb			ld de, display_active+1 
8a20 01 02 00			ld bc, 2 
8a23 ed b0			ldir 
8a25			 
8a25 21 c7 eb			ld hl, display_active+1 
8a28 c9				ret 
8a29				 
8a29				 
8a29			 
8a29			 
8a29			;db "|/-\|-\" 
8a29			 
8a29			actseq: 
8a29			 
8a29 37 8a		dw spin0 
8a2b 39 8a		dw spin1 
8a2d 3b 8a		dw spin2 
8a2f 3d 8a		dw spin3 
8a31 3b 8a		dw spin2 
8a33 39 8a		dw spin1 
8a35 37 8a		dw spin0 
8a37			 
8a37 .. 00		spin0: db " ", 0 
8a39 .. 00		spin1: db "-", 0 
8a3b .. 00		spin2: db "+", 0 
8a3d .. 00		spin3: db "#", 0 
8a3f			 
8a3f			 
8a3f			; information window 
8a3f			 
8a3f			; pass hl with 1st string to display 
8a3f			; pass de with 2nd string to display 
8a3f			 
8a3f			info_panel: 
8a3f e5				push hl 
8a40			 
8a40 2a cc eb			ld hl, (display_fb_active) 
8a43 e5				push hl    ; future de destination 
8a44 21 b1 ed				ld hl, display_fb0 
8a47 22 cc eb				ld (display_fb_active), hl 
8a4a			 
8a4a			;	call clear_display 
8a4a			 
8a4a				if BASE_CPM 
8a4a				ld a, '.' 
8a4a				else 
8a4a 3e a5			ld a, 165 
8a4c				endif 
8a4c cd b3 8a			call fill_display 
8a4f			 
8a4f			 
8a4f 3e 55			ld a, display_row_3 + 5 
8a51 cd c1 8a			call str_at_display 
8a54			 
8a54 e1				pop hl 
8a55 d1				pop de 
8a56			 
8a56 e5				push hl 
8a57			 
8a57			 
8a57 3e 2d			ld a, display_row_2 + 5 
8a59 cd c1 8a			call str_at_display 
8a5c			 
8a5c			 
8a5c cd d1 8a			call update_display 
8a5f cd da 99			call next_page_prompt 
8a62 cd ae 8a			call clear_display 
8a65			 
8a65				 
8a65 21 10 ed				ld hl, display_fb1 
8a68 22 cc eb				ld (display_fb_active), hl 
8a6b cd d1 8a			call update_display 
8a6e			 
8a6e e1				pop hl 
8a6f			 
8a6f c9				ret 
8a70			 
8a70			 
8a70			 
8a70			 
8a70			; TODO windowing? 
8a70			 
8a70			; TODO scroll line up 
8a70			 
8a70			scroll_up: 
8a70			 
8a70 e5				push hl 
8a71 d5				push de 
8a72 c5				push bc 
8a73			 
8a73				; get frame buffer  
8a73			 
8a73 2a cc eb			ld hl, (display_fb_active) 
8a76 e5				push hl    ; future de destination 
8a77			 
8a77 11 28 00			ld  de, display_cols 
8a7a 19				add hl, de 
8a7b			 
8a7b d1				pop de 
8a7c			 
8a7c				;ex de, hl 
8a7c 01 9f 00			ld bc, display_fb_len -1  
8a7f			;if DEBUG_FORTH_WORDS 
8a7f			;	DMARK "SCL" 
8a7f			;	CALLMONITOR 
8a7f			;endif	 
8a7f ed b0			ldir 
8a81			 
8a81				; wipe bottom row 
8a81			 
8a81			 
8a81 2a cc eb			ld hl, (display_fb_active) 
8a84 11 a0 00			ld de, display_cols*display_rows 
8a87 19				add hl, de 
8a88 06 28			ld b, display_cols 
8a8a 3e 20			ld a, ' ' 
8a8c			.scwipe: 
8a8c 77				ld (hl), a 
8a8d 2b				dec hl 
8a8e 10 fc			djnz .scwipe 
8a90			 
8a90				;pop hl 
8a90			 
8a90 c1				pop bc 
8a91 d1				pop de 
8a92 e1				pop hl 
8a93			 
8a93 c9				ret 
8a94			 
8a94			 
8a94			;scroll_upo: 
8a94			;	ld de, display_row_1 
8a94			 ;	ld hl, display_row_2 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_2 
8a94			 ;	ld hl, display_row_3 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_3 
8a94			 ;	ld hl, display_row_4 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			 
8a94			; TODO clear row 4 
8a94			 
8a94			;	ret 
8a94			 
8a94				 
8a94			scroll_down: 
8a94			 
8a94 e5				push hl 
8a95 d5				push de 
8a96 c5				push bc 
8a97			 
8a97				; get frame buffer  
8a97			 
8a97 2a cc eb			ld hl, (display_fb_active) 
8a9a			 
8a9a 11 9f 00			ld de, display_fb_len - 1 
8a9d 19				add hl, de 
8a9e			 
8a9e e5			push hl    ; future de destination 
8a9f			 
8a9f 11 28 00			ld  de, display_cols 
8aa2 ed 52			sbc hl, de 
8aa4			 
8aa4			 
8aa4 d1				pop de 
8aa5			 
8aa5			;	ex de, hl 
8aa5 01 9f 00			ld bc, display_fb_len -1  
8aa8			 
8aa8			 
8aa8				 
8aa8			 
8aa8 ed b0			ldir 
8aaa			 
8aaa				; wipe bottom row 
8aaa			 
8aaa			 
8aaa			;	ld hl, (display_fb_active) 
8aaa			;;	ld de, display_cols*display_rows 
8aaa			;;	add hl, de 
8aaa			;	ld b, display_cols 
8aaa			;	ld a, ' ' 
8aaa			;.scwiped: 
8aaa			;	ld (hl), a 
8aaa			;	dec hl 
8aaa			;	djnz .scwiped 
8aaa			 
8aaa				;pop hl 
8aaa			 
8aaa c1				pop bc 
8aab d1				pop de 
8aac e1				pop hl 
8aad			 
8aad c9				ret 
8aae			;scroll_down: 
8aae			;	ld de, display_row_4 
8aae			;	ld hl, display_row_3 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_3 
8aae			; 	ld hl, display_row_2 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_2 
8aae			;	ld hl, display_row_1 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;;; TODO clear row 1 
8aae			;	ret 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			; clear active frame buffer 
8aae			 
8aae			clear_display: 
8aae 3e 20			ld a, ' ' 
8ab0 c3 b3 8a			jp fill_display 
8ab3			 
8ab3			; fill active frame buffer with a char in A 
8ab3			 
8ab3			fill_display: 
8ab3 06 a0			ld b,display_fb_len 
8ab5 2a cc eb			ld hl, (display_fb_active) 
8ab8 77			.fd1:	ld (hl),a 
8ab9 23				inc hl 
8aba 10 fc			djnz .fd1 
8abc 23				inc hl 
8abd 3e 00			ld a,0 
8abf 77				ld (hl),a 
8ac0			 
8ac0			 
8ac0 c9				ret 
8ac1			; Write string (DE) at pos (A) to active frame buffer 
8ac1			 
8ac1 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ac4 06 00					ld b,0 
8ac6 4f					ld c,a 
8ac7 09					add hl,bc 
8ac8 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ac9 b7			            OR   A              ;Null terminator? 
8aca c8			            RET  Z              ;Yes, so finished 
8acb 77					ld (hl),a 
8acc 23				inc hl 
8acd 13			            INC  DE             ;Point to next character 
8ace 18 f8		            JR   .sad1     ;Repeat 
8ad0 c9					ret 
8ad1			 
8ad1			; using current frame buffer write to physical display 
8ad1			 
8ad1			update_display: 
8ad1 e5				push hl 
8ad2 2a cc eb			ld hl, (display_fb_active) 
8ad5 cd 70 dc			call write_display 
8ad8 e1				pop hl 
8ad9 c9				ret 
8ada			 
8ada			; TODO scrolling 
8ada			 
8ada			 
8ada			; move cursor right one char 
8ada			cursor_right: 
8ada			 
8ada				; TODO shift right 
8ada				; TODO if beyond max col 
8ada				; TODO       cursor_next_line 
8ada			 
8ada c9				ret 
8adb			 
8adb			 
8adb			cursor_next_line: 
8adb				; TODO first char 
8adb				; TODO line down 
8adb				; TODO if past last row 
8adb				; TODO    scroll up 
8adb			 
8adb c9				ret 
8adc			 
8adc			cursor_left: 
8adc				; TODO shift left 
8adc				; TODO if beyond left  
8adc				; TODO     cursor prev line 
8adc				 
8adc c9				ret 
8add			 
8add			cursor_prev_line: 
8add				; TODO last char 
8add				; TODO line up 
8add				; TODO if past first row 
8add				; TODO   scroll down 
8add			 
8add c9				ret 
8ade			 
8ade			 
8ade			cout: 
8ade				; A - char 
8ade c9				ret 
8adf			 
8adf			 
8adf			; Display a menu and allow item selection (optional toggle items) 
8adf			; 
8adf			; format: 
8adf			; hl pointer to word array with zero term for items 
8adf			; e.g.    db item1 
8adf			;         db .... 
8adf			;         db 0 
8adf			; 
8adf			; a = starting menu item  
8adf			; 
8adf			; de = pointer item toggle array   (todo) 
8adf			; 
8adf			; returns item selected in a 1-... 
8adf			; returns 0 if back button pressed 
8adf			; 
8adf			; NOTE: Uses system frame buffer to display 
8adf			; 
8adf			; LEFT, Q = go back 
8adf			; RIGHT, SPACE, CR = select 
8adf			; UP, A - Up 
8adf			; DOWN, Z - Down 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			menu: 
8adf			 
8adf					; keep array pointer 
8adf			 
8adf 22 73 ea				ld (store_tmp1), hl 
8ae2 32 71 ea				ld (store_tmp2), a 
8ae5			 
8ae5					; check for key bounce 
8ae5			 
8ae5			if BASE_KEV 
8ae5			 
8ae5			.mbounce:	call cin 
8ae5					cp 0 
8ae5					jr nz, .mbounce 
8ae5			endif 
8ae5					; for ease use ex 
8ae5			 
8ae5					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae5 21 b1 ed				ld hl, display_fb0 
8ae8 22 cc eb				ld (display_fb_active), hl 
8aeb			 
8aeb cd ae 8a		.mloop:		call clear_display 
8aee cd d1 8a				call update_display 
8af1			 
8af1					; draw selection id '>' at 1 
8af1			 
8af1					; init start of list display 
8af1			 
8af1 3e 05				ld a, 5 
8af3 32 6f ea				ld (store_tmp3), a   ; display row count 
8af6 3a 71 ea				ld a,( store_tmp2) 
8af9 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8afc			 
8afc					 
8afc			.mitem:	 
8afc			 
8afc			 
8afc 3a 72 ea				ld a,(store_tmp2+1) 
8aff 6f					ld l, a 
8b00 26 00				ld h, 0 
8b02 29					add hl, hl 
8b03 ed 5b 73 ea			ld de, (store_tmp1) 
8b07 19					add hl, de 
8b08 7e					ld a, (hl) 
8b09 23					inc hl 
8b0a 66					ld h,(hl) 
8b0b 6f					ld l, a 
8b0c			 
8b0c cd 04 8d				call ishlzero 
8b0f 28 1a				jr z, .mdone 
8b11			 
8b11 eb					ex de, hl 
8b12 3a 6f ea				ld a, (store_tmp3) 
8b15 cd c1 8a				call str_at_display 
8b18					 
8b18			 
8b18					; next item 
8b18 3a 72 ea				ld a, (store_tmp2+1) 
8b1b 3c					inc a 
8b1c 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b1f			 
8b1f			 		; next row 
8b1f			 
8b1f 3a 6f ea				ld a, (store_tmp3) 
8b22 c6 28				add display_cols 
8b24 32 6f ea				ld (store_tmp3), a 
8b27			 
8b27					; at end of screen? 
8b27			 
8b27 fe 10				cp display_rows*4 
8b29 20 d1				jr nz, .mitem 
8b2b			 
8b2b			 
8b2b			.mdone: 
8b2b cd 04 8d				call ishlzero 
8b2e 28 08				jr z, .nodn 
8b30			 
8b30 3e 78				ld a, display_row_4 
8b32 11 b1 8b				ld de, .mdown 
8b35 cd c1 8a				call str_at_display 
8b38			 
8b38					; draw options to fill the screens with active item on line 1 
8b38					; if current option is 2 or more then display ^ in top 
8b38			 
8b38 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b3b fe 00				cp 0 
8b3d 28 08				jr z, .noup 
8b3f			 
8b3f 3e 00				ld a, 0 
8b41 11 af 8b				ld de, .mup 
8b44 cd c1 8a				call str_at_display 
8b47			 
8b47 3e 02		.noup:		ld a, 2 
8b49 11 ad 8b				ld de, .msel 
8b4c cd c1 8a				call str_at_display 
8b4f			 
8b4f					; if current option + 1 is not null then display V in bottom 
8b4f					; get key 
8b4f cd d1 8a				call update_display 
8b52			 
8b52			 
8b52					; handle key 
8b52			 
8b52 cd fc dc				call cin_wait 
8b55			 
8b55 fe 05				cp KEY_UP 
8b57 28 2b				jr z, .mgoup 
8b59 fe 61				cp 'a' 
8b5b 28 27				jr z, .mgoup 
8b5d fe 0a				cp KEY_DOWN 
8b5f 28 32				jr z, .mgod 
8b61 fe 7a				cp 'z' 
8b63 28 2e				jr z, .mgod 
8b65 fe 20				cp ' ' 
8b67 28 34				jr z, .goend 
8b69 fe 0c				cp KEY_RIGHT 
8b6b 28 30				jr z, .goend 
8b6d fe 0d				cp KEY_CR 
8b6f 28 2c				jr z, .goend 
8b71 fe 71				cp 'q' 
8b73 28 0b				jr z, .goback 
8b75			 
8b75 fe 0b				cp KEY_LEFT 
8b77 28 07				jr z, .goback 
8b79 fe 08				cp KEY_BS 
8b7b 28 03				jr z, .goback 
8b7d c3 eb 8a				jp .mloop 
8b80			 
8b80			.goback: 
8b80 3e 00			ld a, 0 
8b82 18 1d			jr .goend2 
8b84			 
8b84				; move up one 
8b84			.mgoup: 
8b84 3a 71 ea				ld a, (store_tmp2) 
8b87 fe 00				cp 0 
8b89 ca eb 8a				jp z, .mloop 
8b8c 3d					dec a 
8b8d 32 71 ea				ld (store_tmp2), a 
8b90 c3 eb 8a				jp .mloop 
8b93			 
8b93				; move down one 
8b93			.mgod: 
8b93 3a 71 ea				ld a, (store_tmp2) 
8b96 3c					inc a 
8b97 32 71 ea				ld (store_tmp2), a 
8b9a c3 eb 8a				jp .mloop 
8b9d			 
8b9d			 
8b9d			.goend: 
8b9d					; get selected item number 
8b9d			 
8b9d 3a 71 ea				ld a, (store_tmp2) 
8ba0 3c					inc a 
8ba1			 
8ba1			.goend2: 
8ba1 f5					push af 
8ba2			 
8ba2					; restore active fb 
8ba2					; TODO BUG assumes fb1 
8ba2			 
8ba2 21 10 ed				ld hl, display_fb1 
8ba5 22 cc eb				ld (display_fb_active), hl 
8ba8			 
8ba8					; restore main regs 
8ba8			 
8ba8			 
8ba8 cd d1 8a				call update_display 
8bab			 
8bab f1					pop af 
8bac			 
8bac c9				ret 
8bad			 
8bad .. 00		.msel:   db ">",0 
8baf .. 00		.mup:   db "^",0 
8bb1 .. 00		.mdown:   db "v",0 
8bb3			 
8bb3			 
8bb3			; eof 
8bb3			 
# End of file firmware_display.asm
8bb3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb3			; random number generators 
8bb3			 
8bb3			 
8bb3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb3			 
8bb3			 
8bb3			;-----> Generate a random number 
8bb3			; output a=answer 0<=a<=255 
8bb3			; all registers are preserved except: af 
8bb3			random: 
8bb3 e5			        push    hl 
8bb4 d5			        push    de 
8bb5 2a ab eb		        ld      hl,(randData) 
8bb8 ed 5f		        ld      a,r 
8bba 57			        ld      d,a 
8bbb 5e			        ld      e,(hl) 
8bbc 19			        add     hl,de 
8bbd 85			        add     a,l 
8bbe ac			        xor     h 
8bbf 22 ab eb		        ld      (randData),hl 
8bc2 d1			        pop     de 
8bc3 e1			        pop     hl 
8bc4 c9			        ret 
8bc5			 
8bc5			 
8bc5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc5			 
8bc5			 
8bc5			 
8bc5			;------LFSR------ 
8bc5			;James Montelongo 
8bc5			;optimized by Spencer Putt 
8bc5			;out: 
8bc5			; a = 8 bit random number 
8bc5			RandLFSR: 
8bc5 21 b1 eb		        ld hl,LFSRSeed+4 
8bc8 5e			        ld e,(hl) 
8bc9 23			        inc hl 
8bca 56			        ld d,(hl) 
8bcb 23			        inc hl 
8bcc 4e			        ld c,(hl) 
8bcd 23			        inc hl 
8bce 7e			        ld a,(hl) 
8bcf 47			        ld b,a 
8bd0 cb 13		        rl e  
8bd2 cb 12			rl d 
8bd4 cb 11		        rl c  
8bd6 17				rla 
8bd7 cb 13		        rl e  
8bd9 cb 12			rl d 
8bdb cb 11		        rl c  
8bdd 17				rla 
8bde cb 13		        rl e  
8be0 cb 12			rl d 
8be2 cb 11		        rl c  
8be4 17				rla 
8be5 67			        ld h,a 
8be6 cb 13		        rl e  
8be8 cb 12			rl d 
8bea cb 11		        rl c  
8bec 17				rla 
8bed a8			        xor b 
8bee cb 13		        rl e  
8bf0 cb 12			rl d 
8bf2 ac			        xor h 
8bf3 a9			        xor c 
8bf4 aa			        xor d 
8bf5 21 b3 eb		        ld hl,LFSRSeed+6 
8bf8 11 b4 eb		        ld de,LFSRSeed+7 
8bfb 01 07 00		        ld bc,7 
8bfe ed b8		        lddr 
8c00 12			        ld (de),a 
8c01 c9			        ret 
8c02			 
8c02			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c02			 
8c02			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c02			 
8c02			 
8c02			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c02			 
8c02			prng16: 
8c02			;Inputs: 
8c02			;   (seed1) contains a 16-bit seed value 
8c02			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c02			;Outputs: 
8c02			;   HL is the result 
8c02			;   BC is the result of the LCG, so not that great of quality 
8c02			;   DE is preserved 
8c02			;Destroys: 
8c02			;   AF 
8c02			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c02			;160cc 
8c02			;26 bytes 
8c02 2a a5 eb		    ld hl,(seed1) 
8c05 44			    ld b,h 
8c06 4d			    ld c,l 
8c07 29			    add hl,hl 
8c08 29			    add hl,hl 
8c09 2c			    inc l 
8c0a 09			    add hl,bc 
8c0b 22 a5 eb		    ld (seed1),hl 
8c0e 2a a3 eb		    ld hl,(seed2) 
8c11 29			    add hl,hl 
8c12 9f			    sbc a,a 
8c13 e6 2d		    and %00101101 
8c15 ad			    xor l 
8c16 6f			    ld l,a 
8c17 22 a3 eb		    ld (seed2),hl 
8c1a 09			    add hl,bc 
8c1b c9			    ret 
8c1c			 
8c1c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1c			 
8c1c			rand32: 
8c1c			;Inputs: 
8c1c			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1c			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1c			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1c			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1c			;   **NOTE: seed2 must be non-zero 
8c1c			;Outputs: 
8c1c			;   HL is the result 
8c1c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1c			;Destroys: 
8c1c			;   AF 
8c1c			;Tested and passes all CAcert tests 
8c1c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1c			;it has a period of 18,446,744,069,414,584,320 
8c1c			;roughly 18.4 quintillion. 
8c1c			;LFSR taps: 0,2,6,7  = 11000101 
8c1c			;291cc 
8c1c			;seed1_0=$+1 
8c1c			;    ld hl,12345 
8c1c			;seed1_1=$+1 
8c1c			;    ld de,6789 
8c1c			;    ld b,h 
8c1c			;    ld c,l 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    inc l 
8c1c			;    add hl,bc 
8c1c			;    ld (seed1_0),hl 
8c1c			;    ld hl,(seed1_1) 
8c1c			;    adc hl,de 
8c1c			;    ld (seed1_1),hl 
8c1c			;    ex de,hl 
8c1c			;seed2_0=$+1 
8c1c			;    ld hl,9876 
8c1c			;seed2_1=$+1 
8c1c			;    ld bc,54321 
8c1c			;    add hl,hl \ rl c \ rl b 
8c1c			;    ld (seed2_1),bc 
8c1c			;    sbc a,a 
8c1c			;    and %11000101 
8c1c			;    xor l 
8c1c			;    ld l,a 
8c1c			;    ld (seed2_0),hl 
8c1c			;    ex de,hl 
8c1c			;    add hl,bc 
8c1c			;    ret 
8c1c			; 
8c1c			 
8c1c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1c			; 20 bytes, 86 cycles (excluding ret) 
8c1c			 
8c1c			; returns   hl = pseudorandom number 
8c1c			; corrupts   a 
8c1c			 
8c1c			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1c			; using the xorshift method: 
8c1c			 
8c1c			; hl ^= hl << 7 
8c1c			; hl ^= hl >> 9 
8c1c			; hl ^= hl << 8 
8c1c			 
8c1c			; some alternative shift triplets which also perform well are: 
8c1c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1c			 
8c1c			;  org 32768 
8c1c			 
8c1c			xrnd: 
8c1c 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c1f 3e 00		  ld a,0 
8c21 bd			  cp l 
8c22 20 02		  jr nz, .xrnd1 
8c24 2e 01		  ld l, 1 
8c26			.xrnd1: 
8c26			 
8c26 7c			  ld a,h 
8c27 1f			  rra 
8c28 7d			  ld a,l 
8c29 1f			  rra 
8c2a ac			  xor h 
8c2b 67			  ld h,a 
8c2c 7d			  ld a,l 
8c2d 1f			  rra 
8c2e 7c			  ld a,h 
8c2f 1f			  rra 
8c30 ad			  xor l 
8c31 6f			  ld l,a 
8c32 ac			  xor h 
8c33 67			  ld h,a 
8c34			 
8c34 22 a9 eb		  ld (xrandc),hl 
8c37			 
8c37 c9			  ret 
8c38			;  
8c38			 
8c38			 
8c38			;;;; int maths 
8c38			 
8c38			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c38			; Divide 16-bit values (with 16-bit result) 
8c38			; In: Divide BC by divider DE 
8c38			; Out: BC = result, HL = rest 
8c38			; 
8c38			Div16: 
8c38 21 00 00		    ld hl,0 
8c3b 78			    ld a,b 
8c3c 06 08		    ld b,8 
8c3e			Div16_Loop1: 
8c3e 17			    rla 
8c3f ed 6a		    adc hl,hl 
8c41 ed 52		    sbc hl,de 
8c43 30 01		    jr nc,Div16_NoAdd1 
8c45 19			    add hl,de 
8c46			Div16_NoAdd1: 
8c46 10 f6		    djnz Div16_Loop1 
8c48 17			    rla 
8c49 2f			    cpl 
8c4a 47			    ld b,a 
8c4b 79			    ld a,c 
8c4c 48			    ld c,b 
8c4d 06 08		    ld b,8 
8c4f			Div16_Loop2: 
8c4f 17			    rla 
8c50 ed 6a		    adc hl,hl 
8c52 ed 52		    sbc hl,de 
8c54 30 01		    jr nc,Div16_NoAdd2 
8c56 19			    add hl,de 
8c57			Div16_NoAdd2: 
8c57 10 f6		    djnz Div16_Loop2 
8c59 17			    rla 
8c5a 2f			    cpl 
8c5b 41			    ld b,c 
8c5c 4f			    ld c,a 
8c5d c9			ret 
8c5e			 
8c5e			 
8c5e			;http://z80-heaven.wikidot.com/math 
8c5e			; 
8c5e			;Inputs: 
8c5e			;     DE and A are factors 
8c5e			;Outputs: 
8c5e			;     A is not changed 
8c5e			;     B is 0 
8c5e			;     C is not changed 
8c5e			;     DE is not changed 
8c5e			;     HL is the product 
8c5e			;Time: 
8c5e			;     342+6x 
8c5e			; 
8c5e			Mult16: 
8c5e			 
8c5e 06 08		     ld b,8          ;7           7 
8c60 21 00 00		     ld hl,0         ;10         10 
8c63 29			       add hl,hl     ;11*8       88 
8c64 07			       rlca          ;4*8        32 
8c65 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c67 19			         add hl,de   ;--         -- 
8c68 10 f9		       djnz $-5      ;13*7+8     99 
8c6a c9			ret 
8c6b			 
8c6b			; 
8c6b			; Square root of 16-bit value 
8c6b			; In:  HL = value 
8c6b			; Out:  D = result (rounded down) 
8c6b			; 
8c6b			;Sqr16: 
8c6b			;    ld de,#0040 
8c6b			;    ld a,l 
8c6b			;    ld l,h 
8c6b			;    ld h,d 
8c6b			;    or a 
8c6b			;    ld b,8 
8c6b			;Sqr16_Loop: 
8c6b			;    sbc hl,de 
8c6b			;    jr nc,Sqr16_Skip 
8c6b			;    add hl,de 
8c6b			;Sqr16_Skip: 
8c6b			;    ccf 
8c6b			;    rl d 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    djnz Sqr16_Loop 
8c6b			;    ret 
8c6b			; 
8c6b			; 
8c6b			; Divide 8-bit values 
8c6b			; In: Divide E by divider C 
8c6b			; Out: A = result, B = rest 
8c6b			; 
8c6b			Div8: 
8c6b af			    xor a 
8c6c 06 08		    ld b,8 
8c6e			Div8_Loop: 
8c6e cb 13		    rl e 
8c70 17			    rla 
8c71 91			    sub c 
8c72 30 01		    jr nc,Div8_NoAdd 
8c74 81			    add a,c 
8c75			Div8_NoAdd: 
8c75 10 f7		    djnz Div8_Loop 
8c77 47			    ld b,a 
8c78 7b			    ld a,e 
8c79 17			    rla 
8c7a 2f			    cpl 
8c7b c9			    ret 
8c7c			 
8c7c			; 
8c7c			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7c			; In: Multiply A with DE 
8c7c			; Out: HL = result 
8c7c			; 
8c7c			Mult12U: 
8c7c 2e 00		    ld l,0 
8c7e 87			    add a,a 
8c7f 30 01		    jr nc,Mult12U_NoAdd0 
8c81 19			    add hl,de 
8c82			Mult12U_NoAdd0: 
8c82 29			    add hl,hl 
8c83 87			    add a,a 
8c84 30 01		    jr nc,Mult12U_NoAdd1 
8c86 19			    add hl,de 
8c87			Mult12U_NoAdd1: 
8c87 29			    add hl,hl 
8c88 87			    add a,a 
8c89 30 01		    jr nc,Mult12U_NoAdd2 
8c8b 19			    add hl,de 
8c8c			Mult12U_NoAdd2: 
8c8c 29			    add hl,hl 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd3 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd3: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd4 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd4: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd5 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd5: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d 30 01		    jr nc,Mult12U_NoAdd6 
8c9f 19			    add hl,de 
8ca0			Mult12U_NoAdd6: 
8ca0 29			    add hl,hl 
8ca1 87			    add a,a 
8ca2 d0			    ret nc 
8ca3 19			    add hl,de 
8ca4 c9			    ret 
8ca5			 
8ca5			; 
8ca5			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca5			; In: Multiply A with DE 
8ca5			;      Put lowest value in A for most efficient calculation 
8ca5			; Out: HL = result 
8ca5			; 
8ca5			Mult12R: 
8ca5 21 00 00		    ld hl,0 
8ca8			Mult12R_Loop: 
8ca8 cb 3f		    srl a 
8caa 30 01		    jr nc,Mult12R_NoAdd 
8cac 19			    add hl,de 
8cad			Mult12R_NoAdd: 
8cad cb 23		    sla e 
8caf cb 12		    rl d 
8cb1 b7			    or a 
8cb2 c2 a8 8c		    jp nz,Mult12R_Loop 
8cb5 c9			    ret 
8cb6			 
8cb6			; 
8cb6			; Multiply 16-bit values (with 32-bit result) 
8cb6			; In: Multiply BC with DE 
8cb6			; Out: BCHL = result 
8cb6			; 
8cb6			Mult32: 
8cb6 79			    ld a,c 
8cb7 48			    ld c,b 
8cb8 21 00 00		    ld hl,0 
8cbb 06 10		    ld b,16 
8cbd			Mult32_Loop: 
8cbd 29			    add hl,hl 
8cbe 17			    rla 
8cbf cb 11		    rl c 
8cc1 30 07		    jr nc,Mult32_NoAdd 
8cc3 19			    add hl,de 
8cc4 ce 00		    adc a,0 
8cc6 d2 ca 8c		    jp nc,Mult32_NoAdd 
8cc9 0c			    inc c 
8cca			Mult32_NoAdd: 
8cca 10 f1		    djnz Mult32_Loop 
8ccc 41			    ld b,c 
8ccd 4f			    ld c,a 
8cce c9			    ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			; 
8ccf			; Multiply 8-bit values 
8ccf			; In:  Multiply H with E 
8ccf			; Out: HL = result 
8ccf			; 
8ccf			Mult8: 
8ccf 16 00		    ld d,0 
8cd1 6a			    ld l,d 
8cd2 06 08		    ld b,8 
8cd4			Mult8_Loop: 
8cd4 29			    add hl,hl 
8cd5 30 01		    jr nc,Mult8_NoAdd 
8cd7 19			    add hl,de 
8cd8			Mult8_NoAdd: 
8cd8 10 fa		    djnz Mult8_Loop 
8cda c9			    ret 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			;;http://z80-heaven.wikidot.com/math 
8cdb			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdb			; 
8cdb			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdb			;     ld a,16        ;7 
8cdb			;     ld hl,0        ;10 
8cdb			;     jp $+5         ;10 
8cdb			;.DivLoop: 
8cdb			;       add hl,bc    ;-- 
8cdb			;       dec a        ;64 
8cdb			;       jr z,.DivLoopEnd        ;86 
8cdb			; 
8cdb			;       sla e        ;128 
8cdb			;       rl d         ;128 
8cdb			;       adc hl,hl    ;240 
8cdb			;       sbc hl,bc    ;240 
8cdb			;       jr nc,.DivLoop ;23|21 
8cdb			;       inc e        ;-- 
8cdb			;       jp .DivLoop+1 
8cdb			; 
8cdb			;.DivLoopEnd: 
8cdb			 
8cdb			;HL_Div_C: 
8cdb			;Inputs: 
8cdb			;     HL is the numerator 
8cdb			;     C is the denominator 
8cdb			;Outputs: 
8cdb			;     A is the remainder 
8cdb			;     B is 0 
8cdb			;     C is not changed 
8cdb			;     DE is not changed 
8cdb			;     HL is the quotient 
8cdb			; 
8cdb			;       ld b,16 
8cdb			;       xor a 
8cdb			;         add hl,hl 
8cdb			;         rla 
8cdb			;         cp c 
8cdb			;         jr c,$+4 
8cdb			;           inc l 
8cdb			;           sub c 
8cdb			;         djnz $-7 
8cdb			 
8cdb			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdb			 
8cdb			addatohl: 
8cdb 85			    add   a, l    ; A = A+L 
8cdc 6f			    ld    l, a    ; L = A+L 
8cdd 8c			    adc   a, h    ; A = A+L+H+carry 
8cde 95			    sub   l       ; A = H+carry 
8cdf 67			    ld    h, a    ; H = H+carry 
8ce0 c9			ret 
8ce1			 
8ce1			addatode: 
8ce1 83			    add   a, e    ; A = A+L 
8ce2 5f			    ld    e, a    ; L = A+L 
8ce3 8a			    adc   a, d    ; A = A+L+H+carry 
8ce4 93			    sub   e       ; A = H+carry 
8ce5 57			    ld    d, a    ; H = H+carry 
8ce6 c9			ret 
8ce7			 
8ce7			 
8ce7			addatobc: 
8ce7 81			    add   a, c    ; A = A+L 
8ce8 4f			    ld    c, a    ; L = A+L 
8ce9 88			    adc   a, b    ; A = A+L+H+carry 
8cea 91			    sub   c       ; A = H+carry 
8ceb 47			    ld    b, a    ; H = H+carry 
8cec c9			ret 
8ced			 
8ced			subafromhl: 
8ced			   ; If A=0 do nothing 
8ced			    ; Otherwise flip A's sign. Since 
8ced			    ; the upper byte becomes -1, also 
8ced			    ; substract 1 from H. 
8ced ed 44		    neg 
8cef ca f8 8c		    jp    z, Skip 
8cf2 25			    dec   h 
8cf3			     
8cf3			    ; Now add the low byte as usual 
8cf3			    ; Two's complement takes care of 
8cf3			    ; ensuring the result is correct 
8cf3 85			    add   a, l 
8cf4 6f			    ld    l, a 
8cf5 8c			    adc   a, h 
8cf6 95			    sub   l 
8cf7 67			    ld    h, a 
8cf8			Skip: 
8cf8 c9				ret 
8cf9			 
8cf9			 
8cf9			; compare hl and de 
8cf9			; returns:  
8cf9			; if hl = de, z=1, s=0, c0=0 
8cf9			; if hl > de, z=0, s=0, c=0 
8cf9			; if hl < de, z=0, s=1, c=1 
8cf9			cmp16:	 
8cf9 b7				or a 
8cfa ed 52			sbc hl,de 
8cfc e0				ret po 
8cfd 7c				ld a,h 
8cfe 1f				rra 
8cff ee 40			xor 01000000B 
8d01 37				scf 
8d02 8f				adc a,a 
8d03 c9				ret 
8d04			 
8d04			 
8d04			; test if hl contains zero   - A is destroyed 
8d04			 
8d04			ishlzero:    
8d04 b7				or a     ; reset flags 
8d05 7c				ld a, h 
8d06 b5				or l        	 
8d07			 
8d07 c9				ret 
8d08			 
8d08			 
8d08			 
8d08			 
8d08			if FORTH_ENABLE_FLOATMATH 
8d08			;include "float/bbcmath.z80" 
8d08			include "float/lpfpcalc.asm" 
8d08			endif 
8d08			 
8d08			 
8d08			; eof 
8d08			 
# End of file firmware_maths.asm
8d08			include "firmware_strings.asm"   ; string handling  
8d08			 
8d08			 
8d08			; TODO string len 
8d08			; input text string, end on cr with zero term 
8d08			; a offset into frame buffer to start prompt 
8d08			; d is max length 
8d08			; e is display size TODO 
8d08			; c is current cursor position 
8d08			; hl is ptr to where string will be stored and edited directly 
8d08			 
8d08			 
8d08			; TODO check limit of buffer for new inserts 
8d08			; TODO check insert does not push beyond buffer 
8d08			; TODO scroll in a limited display area 
8d08			; TODO scroll whole screen on page wrap 
8d08			 
8d08			 
8d08			; TODO use LCD cursor? 
8d08			 
8d08			EDIT_V1: equ 0 
8d08			EDIT_V2: equ 1 
8d08			 
8d08			 
8d08			 
8d08			if EDIT_V2 
8d08			input_str: 
8d08			 
8d08 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
8d0b			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d0b 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d0e			;		ld a, c 
8d0e			;		call addatohl 
8d0e			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d0e 7a					ld a,d 
8d0f 32 66 ee			        ld (input_size), a       ; save length of input area 
8d12 79					ld a, c 
8d13 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d16 7b					ld a,e 
8d17 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d1a			 
8d1a			 
8d1a					; add a trailing space to make screen refresh nicer 
8d1a			 
8d1a					;ld hl, (input_start) 
8d1a					;push hl 
8d1a					;ld a, 0 
8d1a					;call strlent 
8d1a					;ld a, l 
8d1a					;pop hl 
8d1a					;call addatohl 
8d1a					;dec hl 
8d1a					;ld a, ' ' 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld a, 0 
8d1a					;ld (hl), a 
8d1a			 
8d1a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d1a					; init cursor shape if not set by the cin routines 
8d1a 21 c1 eb				ld hl, cursor_shape 
8d1d			if BASE_KEV 
8d1d					ld a, 255 
8d1d			else 
8d1d 3e 23				ld a, '#' 
8d1f			endif 
8d1f 77					ld (hl), a 
8d20 23					inc hl 
8d21 3e 00				ld a, 0 
8d23 77					ld (hl), a 
8d24			 
8d24 3e 09				ld a, CUR_BLINK_RATE 
8d26 32 60 ee				ld (input_cur_flash), a 
8d29 3e 01				ld a, 1 
8d2b 32 5f ee				ld (input_cur_onoff),a 
8d2e			.inmain:	 
8d2e			 
8d2e cd 56 8e				call input_disp_ref 
8d31			 
8d31					; save current length of string 
8d31			 
8d31 2a 67 ee				ld hl, (input_start) 
8d34 3e 00				ld a, 0 
8d36 cd 4c 90				call strlent 
8d39 7d					ld a,l 
8d3a 32 5a ee				ld (input_len), a 
8d3d			 
8d3d					;call input_disp_oncur 
8d3d			 
8d3d					; display current state of input buffer 
8d3d			 
8d3d					; clean any backspace chars 
8d3d			 
8d3d 3e 20				ld a, " " 
8d3f 32 c1 e2				ld (scratch),a 
8d42 3e 00				ld a, 0 
8d44 32 c2 e2				ld (scratch+1),a 
8d47 3a 64 ee				ld a,(input_at_pos) 
8d4a 85					add l 
8d4b 11 c1 e2				ld de, scratch 
8d4e cd c1 8a				call str_at_display 
8d51			 
8d51					; pause 1ms 
8d51			 
8d51 3e 01				ld a, 1 
8d53 cd d6 89				call aDelayInMS 
8d56			 
8d56			; display cursor if visible on this cycle 
8d56			 
8d56					; dec flash counter 
8d56 3a 60 ee				ld a, (input_cur_flash) 
8d59 3d					dec a 
8d5a 32 60 ee				ld (input_cur_flash), a 
8d5d fe 00				cp 0 
8d5f 20 0d				jr nz, .inochgstate 
8d61			 
8d61			 
8d61					; reset on change of state 
8d61 3e 09				ld a, CUR_BLINK_RATE 
8d63 32 60 ee				ld (input_cur_flash), a 
8d66			 
8d66					; change state 
8d66 3a 5f ee				ld a,(input_cur_onoff) 
8d69 ed 44				neg 
8d6b 32 5f ee				ld (input_cur_onoff),a 
8d6e			 
8d6e			 
8d6e			 
8d6e			 
8d6e					; TODO is cursor visible? 
8d6e					; TODO if so then over write the char at curspos pos with the cursor shape 
8d6e			 
8d6e								 
8d6e			 
8d6e			.inochgstate: 
8d6e 3a 5f ee				ld a,(input_cur_onoff) 
8d71 fe ff				cp 255 
8d73 28 0e				jr z, .skipcursor 
8d75 3a 64 ee				ld a, (input_at_pos) 
8d78 47					ld b, a 
8d79 3a 55 ee				ld a, (input_cursor) 
8d7c 80					add b 
8d7d 11 c1 eb				ld de, cursor_shape 
8d80					 
8d80 cd c1 8a				call str_at_display 
8d83			 
8d83			.skipcursor: 
8d83				if DEBUG_INPUTV2 
8d83			 
8d83					ld a,(input_at_pos) 
8d83					ld hl, LFSRSeed 
8d83					call hexout 
8d83					ld a, (input_cursor) 
8d83					ld hl, LFSRSeed+2 
8d83					call hexout 
8d83					ld a,(input_size) 
8d83					ld hl, LFSRSeed+4 
8d83					call hexout 
8d83			 
8d83					ld a,(input_cur_onoff) 
8d83					ld hl, LFSRSeed+6 
8d83					call hexout 
8d83			 
8d83					ld a,(input_cur_flash) 
8d83					ld hl, LFSRSeed+8 
8d83					call hexout 
8d83			 
8d83					ld a,(input_len) 
8d83					ld hl, LFSRSeed+10 
8d83					call hexout 
8d83					ld hl, LFSRSeed+12 
8d83					ld a, 0 
8d83					ld (hl),a 
8d83					ld a, display_row_4 
8d83					ld de, LFSRSeed 
8d83					call str_at_display 
8d83				endif 
8d83 cd d1 8a				call update_display 
8d86			 
8d86					; TODO keyboard processing 
8d86			 
8d86			if BASE_CPM 
8d86					call cin_wait 
8d86			else 
8d86 cd 02 dd				call cin    ; _wait 
8d89			endif 
8d89 fe 00				cp 0 
8d8b ca 2e 8d				jp z, .inmain 
8d8e			 
8d8e fe 0b				cp KEY_LEFT    ; cursor left 
8d90 ca 48 8e				jp z, input_left 
8d93				 
8d93 fe 0c				cp KEY_RIGHT      ; cursor right 
8d95 ca 4f 8e				jp z, input_right 
8d98			 
8d98 fe 0d				cp KEY_CR 
8d9a c8					ret z 
8d9b			 
8d9b fe 08				cp KEY_BS 
8d9d ca bd 8e				jp z, input_delchar 
8da0			 
8da0 fe 06				cp KEY_NEXTWORD 
8da2 ca c9 8d				jp z, input_nxtword 
8da5			 
8da5 fe 07				cp KEY_PREVWORD 
8da7 ca f0 8d				jp z, input_prvword 
8daa			 
8daa fe 0e				cp KEY_HOME    ; jump to start of line 
8dac 20 08				jr nz, .ikh 
8dae 3e 00				ld a, 0 
8db0 32 55 ee				ld (input_cursor), a 
8db3 ca 2e 8d				jp z, .inmain 
8db6			.ikh: 
8db6			 
8db6 fe 0f				cp KEY_END     ; jump to end of line 
8db8 20 09				jr nz, .ike 
8dba 3a 5a ee				ld a, (input_len) 
8dbd 32 55 ee				ld (input_cursor),a 
8dc0 ca 2e 8d				jp z, .inmain 
8dc3			.ike: 
8dc3 fe 05			        cp KEY_UP      ; recall last command 
8dc5 c8					ret z 
8dc6			;jr nz, .irec 
8dc6			; TODO next word 
8dc6			; TODO prev word 
8dc6			;  
8dc6			; 
8dc6			;	ld hl, scratch 
8dc6			;	ld de, os_last_cmd 
8dc6			;	call strcpy 
8dc6			;		jp  .inmain 
8dc6			.irec: 
8dc6			;		jr .instr1 
8dc6			 
8dc6			 
8dc6			 
8dc6					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
8dc6			 
8dc6			; TODO return if any special keys are given 
8dc6			;		ld l, a 
8dc6			;		ld a, 28 ; KEY_F12   ; 27 
8dc6			;		sub l 
8dc6			;		ret m 
8dc6			;		ld a, l 
8dc6					; if no special key then insert as a char 
8dc6			 
8dc6 c3 8f 8e				jp input_inschr 
8dc9			 
8dc9				 
8dc9			input_nxtword: 
8dc9				; jump to start next word after the cursor 
8dc9			 
8dc9			.insknwn:	 
8dc9 cd 85 8e				call input_curptr	 
8dcc 7e					ld a,(hl)	 
8dcd fe 00				cp 0 
8dcf ca 2e 8d				jp z, .inmain    ; end of string 
8dd2			 
8dd2			; if we are on a word, then move off of it 
8dd2			 
8dd2 fe 20				cp ' ' 
8dd4 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8dd6 21 55 ee				ld hl, input_cursor 
8dd9 34					inc (hl) 
8dda 18 ed				jr .insknwn 
8ddc			 
8ddc			.inspace: 
8ddc			 
8ddc cd 85 8e				call input_curptr	 
8ddf 7e					ld a,(hl)	 
8de0 fe 00				cp 0 
8de2 ca 2e 8d				jp z, .inmain    ; end of string 
8de5			 
8de5			; if we are on a word, then move off of it 
8de5			 
8de5 fe 20				cp ' ' 
8de7 c2 2e 8d				jp nz, .inmain     ; we are on non space so at next word 
8dea 21 55 ee				ld hl, input_cursor 
8ded 34					inc (hl) 
8dee 18 ec				jr .inspace 
8df0			 
8df0			 
8df0			 
8df0			 
8df0			input_prvword: 
8df0				; jump to the start of previous word before the cursor 
8df0			 
8df0			; where are we to start with currently? 
8df0			 
8df0 cd 85 8e				call input_curptr	 
8df3 7e					ld a, (hl) 
8df4 fe 20				cp ' ' 
8df6 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8df8			 
8df8			 
8df8			 
8df8			.inskpwn:	 
8df8 3a 55 ee				ld a,(input_cursor) 
8dfb fe 00				cp 0 
8dfd ca 2e 8d				jp z, .inmain    ; start of string 
8e00			 
8e00			;if we are on a word, then move off of it 
8e00			 
8e00 cd 85 8e				call input_curptr	 
8e03 7e					ld a, (hl) 
8e04 fe 20				cp ' ' 
8e06 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
8e08					;jp z, .inmain    ; start of string 
8e08 21 55 ee				ld hl, input_cursor 
8e0b 35					dec (hl) 
8e0c 18 ea				jr .inskpwn 
8e0e			.iwstart: 
8e0e 21 55 ee				ld hl, input_cursor 
8e11 34					inc (hl) 
8e12 c3 2e 8d				jp .inmain 
8e15					 
8e15			 
8e15			.inspacep: 
8e15			 
8e15					;jp .inmain    ; start of string 
8e15			 
8e15			 
8e15			 
8e15 3a 55 ee				ld a,(input_cursor) 
8e18 fe 00				cp 0 
8e1a ca 2e 8d				jp z, .inmain    ; start of string 
8e1d			 
8e1d			; if we are on a word, then move off of it 
8e1d			 
8e1d cd 85 8e				call input_curptr	 
8e20 7e					ld a, (hl) 
8e21 fe 20				cp ' ' 
8e23 c2 2c 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e26 21 55 ee				ld hl, input_cursor 
8e29 35					dec (hl) 
8e2a 18 e9				jr .inspacep 
8e2c			 
8e2c			 
8e2c			.incharp:	 
8e2c					; eat the word to get to the start 
8e2c 3a 55 ee				ld a,(input_cursor) 
8e2f fe 00				cp 0 
8e31 ca 2e 8d				jp z, .inmain    ; start of string 
8e34			 
8e34			; if we are on a word, then move off of it 
8e34			 
8e34 cd 85 8e				call input_curptr	 
8e37 7e					ld a, (hl) 
8e38 fe 20				cp ' ' 
8e3a 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e3c 21 55 ee				ld hl, input_cursor 
8e3f 35					dec (hl) 
8e40 18 ea				jr .incharp 
8e42			.ipwordst: 
8e42					; at space before the prev word so reposition over it 
8e42 21 55 ee				ld hl, input_cursor 
8e45 34					inc (hl) 
8e46 18 b0				jr .inskpwn 
8e48					 
8e48			 
8e48			 
8e48			input_left: 
8e48				; move cursor left 
8e48 21 55 ee			ld hl, input_cursor 
8e4b 35				dec (hl) 
8e4c			;	cp 0 
8e4c			;	jp z, .inmain    ; ignore left as at the start of the string 
8e4c c3 2e 8d			jp .inmain 
8e4f			 
8e4f			input_right: 
8e4f				; move cursor right 
8e4f				 
8e4f				;ld a, (input_size) 
8e4f				;ld b, a 
8e4f 21 55 ee			ld hl, input_cursor 
8e52 34				inc (hl) 
8e53				;dec b 
8e53				;cp 0 
8e53				;jp z, .inmain   ; ignore as at end of the string buffer 
8e53				;ld a, b 
8e53				;inc a 
8e53				;ld (input_cursor), a 
8e53 c3 2e 8d			jp .inmain 
8e56			 
8e56			 
8e56			 
8e56			input_disp_ref: 
8e56				; display the text from start of buffer (ie full refresh) 
8e56 3a 64 ee			ld a, (input_at_pos) 
8e59 2a 67 ee			ld hl,(input_start) 
8e5c eb				ex de, hl 
8e5d cd c1 8a			call str_at_display  
8e60 c9				ret 
8e61			input_disp_oncur: 
8e61				; display the text from cursor position to end of buffer 
8e61				; TODO position start of string at cursor position on screen 
8e61				; TODO draw from that point on 
8e61 3a 55 ee			ld a, (input_cursor) 
8e64 47				ld b, a 
8e65 3a 64 ee			ld a, (input_at_pos) 
8e68 80				add b 
8e69 48				ld c, b     ; save a 
8e6a 78				ld a, b     ; inc string start for cursor 
8e6b 2a 67 ee			ld hl,(input_start) 
8e6e cd db 8c			call addatohl 
8e71 eb				ex de, hl 
8e72 79				ld a, c 
8e73 cd c1 8a			call str_at_display  
8e76 c9				ret 
8e77			 
8e77			input_nxtw: 
8e77				; Find next word 
8e77 c9				ret 
8e78			 
8e78			input_prvw: 
8e78				; Find previous word 
8e78 c9				ret 
8e79			 
8e79			input_lenrem:   
8e79				; Calculate the length of string remaining from current cursor 
8e79				; position to end of buffer (exc null term) 
8e79				 
8e79 3a 55 ee			ld a, (input_cursor) 
8e7c 4f				ld c, a 
8e7d 3a 66 ee			ld a, (input_size) 
8e80 91				sub c 
8e81 06 00			ld b, 0 
8e83 0d				dec c 
8e84 c9				ret	 
8e85			 
8e85			input_curptr: 
8e85				; calc address of the character under the cursor 
8e85				 
8e85 2a 67 ee			ld hl, (input_start) 
8e88 3a 55 ee			ld a, (input_cursor) 
8e8b cd db 8c			call addatohl 
8e8e c9				ret 
8e8f			 
8e8f			input_inschr: 
8e8f				; Insert char at cursor position 
8e8f f5				push af   ; save char 
8e90				;call input_lenrem    ; get bc length of remaining string 
8e90			 
8e90				 
8e90 cd 85 8e			call input_curptr 
8e93			;	ld hl, (input_start) 
8e93			;	ld a, (input_cursor) 
8e93			;	call addatohl 
8e93				;push hl   ; save to come back to 
8e93			 
8e93				; shift everything up one to end of buffer 
8e93			 
8e93				;push hl 
8e93				;dec de 
8e93				;inc de 
8e93			;	ldir 
8e93				 
8e93				;pop hl 
8e93			 
8e93				; are we adding to the end of line? 
8e93			 
8e93 3a 55 ee			ld a, (input_cursor) 
8e96 47				ld b, a 
8e97 3a 5a ee			ld a, (input_len) 
8e9a b8				cp b 
8e9b 20 09			jr nz, .insmid   ; no, insert in middle of text 
8e9d			 
8e9d				; tack on the end of the line 
8e9d f1				pop af 
8e9e 77				ld (hl), a   ; save new char 
8e9f 23				inc hl 
8ea0 3e 00			ld a, 0 
8ea2 77				ld (hl), a 
8ea3 c3 4f 8e			jp input_right 
8ea6				 
8ea6			.insmid: 
8ea6				; hl has insertion point so move everything up one to allow for insertion 
8ea6				;call input_shiftright 
8ea6 f1				pop af 
8ea7			 
8ea7			.shufinsmid: 
8ea7 47				ld b, a     ; b contains new char, c prev char at this position  
8ea8 7e				ld a, (hl) 
8ea9			 
8ea9 fe 00			cp 0    ; at end of string need to then dump new char and add term 
8eab 28 07			jr z, .endinsmid 
8ead 4f				ld c, a 
8eae 78				ld a, b 
8eaf 77				ld (hl), a 
8eb0 23				inc hl 
8eb1 79				ld a, c 
8eb2 18 f3			jr .shufinsmid 
8eb4				 
8eb4			 
8eb4			 
8eb4			 
8eb4			.endinsmid: 
8eb4 78				ld a, b 
8eb5 77				ld (hl), a 
8eb6 23				inc hl 
8eb7 3e 00			ld a, 0 
8eb9 77				ld (hl), a 
8eba			 
8eba			 
8eba			;	ld (hl), a   ; save new char 
8eba			 
8eba c3 4f 8e			jp input_right 
8ebd			 
8ebd			;input_shiftright: 
8ebd			;	; shift text right at cursor, hl has shift start 
8ebd			;	push hl 
8ebd			;	push de 
8ebd			;	push bc 
8ebd			; 
8ebd			; 
8ebd			;	; move to end of string past zero term 
8ebd			;	ld hl,(input_start) 
8ebd			;	ld a, (input_len) 
8ebd			;	call addatohl 
8ebd			;	inc hl 
8ebd			;;	inc hl 
8ebd			;;	inc hl 
8ebd			;	ld a, 0 
8ebd			;	ld (hl), a 
8ebd			;;	dec hl 
8ebd			;	 
8ebd			;;	ld (hl), a 
8ebd			;;	dec hl 
8ebd			; 
8ebd			;	push hl 
8ebd			;	pop de 
8ebd			;	inc de 
8ebd			;	 
8ebd			; 
8ebd			;;	ld hl,(input_start) 
8ebd			;;	ld a, (input_cursor) 
8ebd			;;	call addatohl 
8ebd			; 
8ebd			; 
8ebd			;	; calc how many bytes from cursor pos to end of string we need to shift 
8ebd			;	call input_lenrem    ; get bc length of remaining string 
8ebd			;	;ld a, (input_cursor) 
8ebd			;	;ld c, a 
8ebd			;	ld a, (input_len) 
8ebd			;	cp 2 
8ebd			;	jr z, .iskipzero	 
8ebd			;	;sub c 
8ebd			;	;inc a 
8ebd			;	;ld c, a 
8ebd			;	;ld b, 0 
8ebd			;	inc c 
8ebd			;	inc c 
8ebd			;	; move data 
8ebd			;	lddr 
8ebd			;.iskipzero: 
8ebd			; 
8ebd			;	pop bc 
8ebd			;	pop de 
8ebd			;	pop hl 
8ebd			;	ret	 
8ebd			 
8ebd			input_delchar: 
8ebd				; Delete char at cursor position 
8ebd cd 79 8e			call input_lenrem    ; get bc length of remaining string 
8ec0 2a 67 ee			ld hl, (input_start) 
8ec3 3a 55 ee			ld a, (input_cursor) 
8ec6 cd db 8c			call addatohl 
8ec9			 
8ec9 e5				push hl 
8eca d1				pop de 
8ecb 1b				dec de 
8ecc			 
8ecc			.dl:	 
8ecc ed a0			ldi  
8ece 7e				ld a, (hl) 
8ecf fe 00			cp 0 
8ed1 28 02			jr z, .dldone 
8ed3 18 f7			jr .dl 
8ed5			.dldone: 
8ed5 ed a0			ldi 
8ed7			 
8ed7 c3 48 8e			jp input_left 
8eda			 
8eda			 
8eda			endif 
8eda			 
8eda			 
8eda			 
8eda			if EDIT_V1 
8eda			input_str: 
8eda			 
8eda				    	ld (input_at_pos),a      ; save display position to start 
8eda					add c 
8eda					ld (input_at_cursor),a	; save draw pos of cursor 
8eda					ld (input_start), hl     ; save ptr to buffer 
8eda					ld a, c 
8eda					call addatohl 
8eda					ld (input_ptr), hl     ; save ptr to point under the cursor 
8eda					ld a,d 
8eda				        ld (input_size), a       ; save length of input area 
8eda					ld a, c 
8eda					ld (input_cursor),a      ; init cursor start position  
8eda					ld a,e 
8eda				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8eda					 
8eda					 
8eda			 
8eda			;		ld a,(input_ptr) 
8eda			;		ld (input_under_cursor),a 	; save what is under the cursor 
8eda			 
8eda			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8eda					; init cursor shape if not set by the cin routines 
8eda					ld hl, cursor_shape 
8eda			if BASE_KEV 
8eda					ld a, 255 
8eda			else 
8eda					ld a, '#' 
8eda			endif 
8eda					ld (hl), a 
8eda					inc hl 
8eda					ld a, 0 
8eda					ld (hl), a 
8eda			 
8eda					ld a, CUR_BLINK_RATE 
8eda					ld (input_cur_flash), a 
8eda					ld a, 1 
8eda					ld (input_cur_onoff),a 
8eda			 
8eda			;	if DEBUG_INPUT 
8eda			;		push af 
8eda			;		ld a, 'I' 
8eda			;		ld (debug_mark),a 
8eda			;		pop af 
8eda			;		CALLMONITOR 
8eda			;	endif 
8eda			.is1:		; main entry loop 
8eda			 
8eda			 
8eda			 
8eda					; pause 1ms 
8eda			 
8eda					ld a, 1 
8eda					call aDelayInMS 
8eda			 
8eda					; dec flash counter 
8eda					ld a, (input_cur_flash) 
8eda					dec a 
8eda					ld (input_cur_flash), a 
8eda					cp 0 
8eda					jr nz, .nochgstate 
8eda			 
8eda			 
8eda					; change state 
8eda					ld a,(input_cur_onoff) 
8eda					neg 
8eda					ld (input_cur_onoff),a 
8eda			 
8eda			 
8eda					; reset on change of state 
8eda					ld a, CUR_BLINK_RATE 
8eda					ld (input_cur_flash), a 
8eda			 
8eda			.nochgstate: 
8eda					 
8eda					 
8eda			 
8eda					; display cursor  
8eda			 
8eda			;		ld hl, (input_start) 
8eda			;		ld a, (input_cursor) 
8eda			;		call addatohl 
8eda			 
8eda					; get char under cursor and replace with cursor 
8eda			ld hl, (input_ptr) 
8eda			;		ld a, (hl) 
8eda			;		ld (input_under_cursor),a 
8eda			;		ld a, '_' 
8eda			;		ld (hl), a 
8eda			 
8eda					; display string 
8eda			 
8eda					ld de, (input_start) 
8eda					ld a, (input_at_pos) 
8eda					call str_at_display 
8eda			;	        call update_display 
8eda			 
8eda					; find place to put the cursor 
8eda			;		add h 
8eda			;		ld l, display_row_1 
8eda			;		sub l 
8eda			; (input_at_pos) 
8eda					;ld c, a 
8eda			;		ld a, (input_cursor) 
8eda			;		ld l, (input_at_pos) 
8eda			;		;ld b, h 
8eda			;		add l 
8eda			;		ld (input_at_cursor),a 
8eda					;ld l,h 
8eda			 
8eda			;		ld h, 0 
8eda			;		ld l,(input_at_pos) 
8eda			;		ld a, (input_cursor) 
8eda			;		call addatohl 
8eda			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8eda			;		call subafromhl 
8eda			;		ld a,l 
8eda			;		ld (input_at_cursor), a 
8eda			 
8eda				if DEBUG_INPUT 
8eda					ld a, (hardware_diag) 
8eda					cp 0 
8eda					jr z, .skip_input_diag 
8eda			 
8eda					ld a,(input_at_pos) 
8eda					ld hl, LFSRSeed 
8eda					call hexout 
8eda					ld a, (input_cursor) 
8eda					ld hl, LFSRSeed+2 
8eda					call hexout 
8eda					ld a,(input_at_cursor) 
8eda					ld hl, LFSRSeed+4 
8eda					call hexout 
8eda			 
8eda					ld a,(input_cur_onoff) 
8eda					ld hl, LFSRSeed+6 
8eda					call hexout 
8eda			 
8eda					ld a,(input_cur_flash) 
8eda					ld hl, LFSRSeed+8 
8eda					call hexout 
8eda			 
8eda					ld a,(input_len) 
8eda					ld hl, LFSRSeed+10 
8eda					call hexout 
8eda					ld hl, LFSRSeed+12 
8eda					ld a, 0 
8eda					ld (hl),a 
8eda					ld a, display_row_4 
8eda					ld de, LFSRSeed 
8eda					call str_at_display 
8eda					.skip_input_diag: 
8eda				endif 
8eda			 
8eda					; decide on if we are showing the cursor this time round 
8eda			 
8eda					ld a, (input_cur_onoff) 
8eda					cp 255 
8eda					jr z, .skipcur 
8eda			 
8eda			 
8eda					ld a,(input_at_cursor) 
8eda					ld de, cursor_shape 
8eda					call str_at_display 
8eda			 
8eda					; save length of current input string 
8eda					ld hl, (input_start) 
8eda					ld a, 0 
8eda					call strlent 
8eda					ld a,l 
8eda					ld (input_len),a 
8eda			 
8eda			.skipcur: 
8eda			 
8eda				        call update_display 
8eda					 
8eda			 
8eda			 
8eda					; wait 
8eda				 
8eda					; TODO loop without wait to flash the cursor and char under cursor	 
8eda					call cin    ; _wait 
8eda			 
8eda					cp 0 
8eda					jp z, .is1 
8eda			 
8eda					; get ptr to char to input into 
8eda			 
8eda					ld c,a 
8eda					ld hl, (input_start) 
8eda					ld a, (input_cursor) 
8eda					call addatohl 
8eda					ld (input_ptr), hl 
8eda					ld a,c 
8eda			 
8eda					; replace char under cursor 
8eda			 
8eda			;		ld hl, (input_ptr) 
8eda			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8eda			;		ld (hl), a 
8eda			 
8eda			;	if DEBUG_INPUT 
8eda			;		push af 
8eda			;		ld a, 'i' 
8eda			;		ld (debug_mark),a 
8eda			;		pop af 
8eda			;		CALLMONITOR 
8eda			;	endif 
8eda					cp KEY_HOME 
8eda					jr nz, .iske 
8eda			 
8eda					ld a, (input_at_pos) 
8eda					ld (input_at_cursor),a 
8eda					ld a, 0 
8eda					ld (input_cursor), a 
8eda					jp .is1 
8eda					 
8eda			.iske:		cp KEY_END 
8eda					jr nz, .isknw 
8eda					jp .is1 
8eda			 
8eda			.isknw:		cp KEY_NEXTWORD 
8eda					jr nz, .iskpw 
8eda			 
8eda			.isknwm:	ld hl, (input_ptr) 
8eda					ld a,(hl)	 
8eda					cp 0 
8eda					jp z, .is1    ; end of string 
8eda					cp ' ' 
8eda					jp z, .is1    ; end of word 
8eda					inc hl 
8eda					ld (input_ptr), hl 
8eda					ld a, (input_at_cursor) 
8eda					inc a 
8eda					ld (input_at_cursor), a 
8eda					jr .isknwm 
8eda			 
8eda			.iskpw:		cp KEY_PREVWORD 
8eda					jr nz, .iskl 
8eda			.iskpwm:	 
8eda					ld hl, (input_ptr) 
8eda					ld a,(hl)	 
8eda					cp 0  
8eda					jp z, .is1    ; end of string 
8eda					cp ' ' 
8eda					jp z, .is1    ; end of word 
8eda					dec hl 
8eda					ld (input_ptr), hl 
8eda					ld a, (input_at_cursor) 
8eda					dec a 
8eda					ld (input_at_cursor), a 
8eda					jr .iskpwm 
8eda			 
8eda			 
8eda			.iskl:		cp KEY_LEFT 
8eda					jr nz, .isk1 
8eda			 
8eda					ld a, (input_cursor) 
8eda			 
8eda					cp 0 
8eda					jp z, .is1 		; at start of line to ignore  
8eda			 
8eda					dec  a 		; TODO check underflow 
8eda					ld (input_cursor), a 
8eda			 
8eda					ld hl, (input_ptr) 
8eda					dec hl 
8eda					ld (input_ptr), hl 
8eda					 
8eda					ld a, (input_at_cursor) 
8eda					dec a 
8eda					ld (input_at_cursor), a 
8eda			 
8eda					ld a, 1		; show cursor moving 
8eda					ld (input_cur_onoff),a 
8eda					ld a, CUR_BLINK_RATE 
8eda					ld (input_cur_flash), a 
8eda			 
8eda					jp .is1 
8eda			 
8eda			.isk1:		cp KEY_RIGHT 
8eda					jr nz, .isk2 
8eda			 
8eda					ld a,(input_len)		; TODO BUG why cant i load e direct? 
8eda					ld e,a 
8eda					ld a, (input_cursor) 
8eda					cp e 
8eda					jp z, .is1		; at the end of string so dont go right 
8eda			 
8eda					inc  a 		; TODO check overflow 
8eda					ld (input_cursor), a 
8eda			 
8eda					ld a, (input_at_cursor) 
8eda					inc a 
8eda					ld (input_at_cursor), a 
8eda			 
8eda					ld hl, (input_ptr) 
8eda					inc hl 
8eda					ld (input_ptr), hl 
8eda			 
8eda					ld a, 1		; show cursor moving 
8eda					ld (input_cur_onoff),a 
8eda					ld a, CUR_BLINK_RATE 
8eda					ld (input_cur_flash), a 
8eda			 
8eda					jp .is1 
8eda			 
8eda			.isk2:		cp KEY_UP 
8eda			 
8eda					jr nz, .isk3 
8eda			 
8eda					; swap last command with the current on 
8eda			 
8eda					; move cursor to start of string 
8eda					ld hl, (input_start) 
8eda					ld (input_ptr), hl 
8eda			 
8eda					ld a, (input_at_pos) 
8eda					ld (input_at_cursor), a 
8eda			 
8eda					ld a, 0 
8eda					ld (input_cursor), a 
8eda					 
8eda					; swap input and last command buffers 
8eda			 
8eda					ld hl, os_cli_cmd 
8eda					ld de, os_last_cmd 
8eda					ld b, 255 
8eda			.swap1:		ld a, (hl) 
8eda					ld c,a 
8eda					ld a, (de) 
8eda					ld (hl), a 
8eda					ld a,c 
8eda					ld (de),a 
8eda					inc hl 
8eda					inc de 
8eda					djnz .swap1 
8eda			 
8eda			 
8eda			 
8eda			 
8eda			 
8eda					jp .is1 
8eda			 
8eda			.isk3:		cp KEY_BS 
8eda					jr nz, .isk4 
8eda			 
8eda					ld a, (input_cursor) 
8eda			 
8eda					cp 0 
8eda					jp z, .is1 		; at start of line to ignore  
8eda			 
8eda					dec  a 		; TODO check underflow 
8eda					ld (input_cursor), a 
8eda			 
8eda					; hl is source 
8eda					; de needs to be source - 1 
8eda			 
8eda			;		ld a, 0 
8eda			;		dec hl 
8eda			;		ld (hl), a 
8eda			 
8eda					ld hl, (input_ptr) 
8eda					dec hl 
8eda					ld (input_ptr), hl 
8eda			 
8eda					; shift all data 
8eda			 
8eda					push hl 
8eda					inc hl 
8eda					pop de 
8eda					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8eda					ld c,a 
8eda					ld b,0 
8eda					ldir  
8eda			 
8eda			 
8eda			 
8eda			 
8eda					ld a, (input_at_cursor) 
8eda					dec a 
8eda					ld (input_at_cursor), a 
8eda			 
8eda			 
8eda					ld a, 1		; show cursor moving 
8eda					ld (input_cur_onoff),a 
8eda					ld a, CUR_BLINK_RATE 
8eda					ld (input_cur_flash), a 
8eda			 
8eda					; remove char 
8eda					ld a, (input_at_cursor) 
8eda					inc a 
8eda					ld de,.iblank 
8eda					call str_at_display 
8eda			 
8eda					jp .is1 
8eda			 
8eda			.isk4:		cp KEY_CR 
8eda					jr z, .endinput 
8eda			 
8eda					; else add the key press to the end 
8eda			 
8eda					ld c, a			; save key pressed 
8eda			 
8eda					ld a,(hl)		; get what is currently under char 
8eda			 
8eda					cp 0			; we are at the end of the string 
8eda					jr nz, .onchar 
8eda					 
8eda					; add a char to the end of the string 
8eda				 
8eda					ld (hl),c 
8eda					inc hl 
8eda			;		ld a,' ' 
8eda			;		ld (hl),a 
8eda			;		inc hl 
8eda					ld a,0 
8eda					ld (hl),a 
8eda					dec hl 
8eda			 
8eda					ld a, (input_cursor) 
8eda					inc a				; TODO check max string length and scroll  
8eda					ld (input_cursor), a		; inc cursor pos 
8eda							 
8eda					ld a, (input_at_cursor) 
8eda					inc a 
8eda					ld (input_at_cursor), a 
8eda			 
8eda					ld hl, (input_ptr) 
8eda					inc hl 
8eda					ld (input_ptr), hl 
8eda			 
8eda					ld hl, (input_ptr) 
8eda					inc hl 
8eda					ld (input_ptr), hl 
8eda			;	if DEBUG_INPUT 
8eda			;		push af 
8eda			;		ld a, '+' 
8eda			;		ld (debug_mark),a 
8eda			;		pop af 
8eda			;		CALLMONITOR 
8eda			;	endif 
8eda					ld a, 1		; show cursor moving 
8eda					ld (input_cur_onoff),a 
8eda					ld a, CUR_BLINK_RATE 
8eda					ld (input_cur_flash), a 
8eda					jp .is1 
8eda					 
8eda			 
8eda			 
8eda					; if on a char then insert 
8eda			.onchar: 
8eda			 
8eda					; TODO over flow check: make sure insert does not blow out buffer 
8eda			 
8eda					; need to do some maths to use lddr 
8eda			 
8eda					push hl   ; save char pos 
8eda					push bc 
8eda			 
8eda					ld hl, (input_start) 
8eda					ld a, (input_len) 
8eda					call addatohl  		; end of string 
8eda					inc hl 
8eda					inc hl		; past zero term 
8eda					push hl 
8eda					inc hl 
8eda					push hl  
8eda			 
8eda								; start and end of lddr set, now how much to move? 
8eda			 
8eda							 
8eda					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8eda					ld b,a 
8eda					ld a,(input_len) 
8eda					ld e,a 
8eda					sub b 
8eda					inc a		;?? 
8eda					inc a		;?? 
8eda					inc a		;?? 
8eda			 
8eda					ld b,0 
8eda					ld c,a 
8eda			 
8eda				if DEBUG_INPUT 
8eda					push af 
8eda					ld a, 'i' 
8eda					ld (debug_mark),a 
8eda					pop af 
8eda			;		CALLMONITOR 
8eda				endif 
8eda					pop de 
8eda					pop hl 
8eda				if DEBUG_INPUT 
8eda					push af 
8eda					ld a, 'I' 
8eda					ld (debug_mark),a 
8eda					pop af 
8eda			;		CALLMONITOR 
8eda				endif 
8eda					lddr 
8eda				 
8eda			 
8eda			 
8eda					; TODO have a key for insert/overwrite mode???? 
8eda					pop bc 
8eda					pop hl 
8eda					ld (hl), c		; otherwise overwrite current char 
8eda					 
8eda			 
8eda			 
8eda			 
8eda					ld a, (input_cursor) 
8eda					inc  a 		; TODO check overflow 
8eda					ld (input_cursor), a 
8eda			 
8eda					ld a, (input_at_cursor) 
8eda					inc a 
8eda					ld (input_at_cursor), a 
8eda			 
8eda					jp .is1 
8eda			 
8eda			.endinput:	; TODO look for end of string 
8eda			 
8eda					; add trailing space for end of token 
8eda			 
8eda					ld hl, (input_start) 
8eda					ld a,(input_len) 
8eda					call addatohl 
8eda					ld a, ' ' 
8eda					ld (hl),a 
8eda					; TODO eof of parse marker 
8eda			 
8eda					inc hl 
8eda					ld a, 0 
8eda					ld (hl),a 
8eda			 
8eda			 
8eda					ret 
8eda			 
8eda			.iblank: db " ",0 
8eda			 
8eda			 
8eda			input_str_prev:	ld (input_at_pos), a 
8eda					ld (input_start), hl 
8eda					ld a,1			; add cursor 
8eda					ld (hl),a 
8eda					inc hl 
8eda					ld a,0 
8eda					ld (hl),a 
8eda					ld (input_ptr), hl 
8eda					ld a,d 
8eda					ld (input_size), a 
8eda					ld a,0 
8eda					ld (input_cursor),a 
8eda			.instr1:	 
8eda			 
8eda					; TODO do block cursor 
8eda					; TODO switch cursor depending on the modifer key 
8eda			 
8eda					; update cursor shape change on key hold 
8eda			 
8eda					ld hl, (input_ptr) 
8eda					dec hl 
8eda					ld a,(cursor_shape) 
8eda					ld (hl), a 
8eda			 
8eda					; display entered text 
8eda					ld a,(input_at_pos) 
8eda			            	CALL fLCD_Pos       ;Position cursor to location in A 
8eda			            	LD   de, (input_start) 
8eda			            	CALL fLCD_Str       ;Display string pointed to by DE 
8eda			 
8eda					call cin 
8eda					cp 0 
8eda					jr z, .instr1 
8eda			 
8eda					; proecess keyboard controls first 
8eda			 
8eda					ld hl,(input_ptr) 
8eda			 
8eda					cp KEY_CR	 ; pressing enter ends input 
8eda					jr z, .instrcr 
8eda			 
8eda					cp KEY_BS 	; back space 
8eda					jr nz, .instr2 
8eda					; process back space 
8eda			 
8eda					; TODO stop back space if at start of string 
8eda					dec hl 
8eda					dec hl ; to over write cursor 
8eda					ld a,(cursor_shape) 
8eda					;ld a,0 
8eda					ld (hl),a 
8eda					inc hl 
8eda					ld a," " 
8eda					ld (hl),a 
8eda					ld (input_ptr),hl 
8eda					 
8eda			 
8eda					jr .instr1 
8eda			 
8eda			.instr2:	cp KEY_LEFT    ; cursor left 
8eda					jr nz, .instr3 
8eda					dec hl 
8eda					ld (input_ptr),hl 
8eda					jr .instr1 
8eda				 
8eda			.instr3:	cp KEY_RIGHT      ; cursor right 
8eda					jr nz, .instr4 
8eda					inc hl 
8eda					ld (input_ptr),hl 
8eda					jr .instr1 
8eda			 
8eda			.instr4:	cp KEY_HOME    ; jump to start of line 
8eda					jr nz, .instr5 
8eda					dec hl 
8eda					ld (input_ptr),hl 
8eda					jr .instr1 
8eda			 
8eda			.instr5:	cp KEY_END     ; jump to end of line 
8eda					jr nz, .instr6 
8eda					dec hl 
8eda					ld (input_ptr),hl 
8eda					jr .instr1 
8eda			.instr6:        cp KEY_UP      ; recall last command 
8eda					jr nz, .instrnew 
8eda			 
8eda				ld hl, scratch 
8eda				ld de, os_last_cmd 
8eda				call strcpy 
8eda					jr .instr1 
8eda			 
8eda			 
8eda			.instrnew:	; no special key pressed to see if we have room to store it 
8eda			 
8eda					; TODO do string size test 
8eda			 
8eda					dec hl ; to over write cursor 
8eda					ld (hl),a 
8eda					inc hl 
8eda					ld a,(cursor_shape) 
8eda					ld (hl),a 
8eda					inc hl 
8eda					ld a,0 
8eda					ld (hl),a 
8eda			 
8eda					ld (input_ptr),hl 
8eda					 
8eda					jr .instr1 
8eda			.instrcr:	dec hl		; remove cursor 
8eda					ld a,' '	; TODO add a trailing space for safety 
8eda					ld (hl),a 
8eda					inc hl 
8eda					ld a,0 
8eda					ld (hl),a 
8eda			 
8eda			 
8eda					; if at end of line scroll up    
8eda					; TODO detecting only end of line 4 for scroll up  
8eda			 
8eda					;ld   
8eda			 
8eda					ret 
8eda			 
8eda			 
8eda			endif 
8eda			; strcpy hl = dest, de source 
8eda			 
8eda 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8edb b7			            OR   A              ;Null terminator? 
8edc c8			            RET  Z              ;Yes, so finished 
8edd 1a					ld a,(de) 
8ede 77					ld (hl),a 
8edf 13			            INC  DE             ;Point to next character 
8ee0 23					inc hl 
8ee1 18 f7		            JR   strcpy       ;Repeat 
8ee3 c9					ret 
8ee4			 
8ee4			 
8ee4			; TODO string_at  
8ee4			; pass string which starts with lcd offset address and then null term string 
8ee4			 
8ee4			; TODO string to dec 
8ee4			; TODO string to hex 
8ee4			; TODO byte to string hex 
8ee4			; TODO byte to string dec 
8ee4			 
8ee4			 
8ee4			 
8ee4			; from z80uartmonitor 
8ee4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ee4			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8ee4			; pass hl for where to put the text 
8ee4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ee4 c5			hexout:	PUSH BC 
8ee5 f5					PUSH AF 
8ee6 47					LD B, A 
8ee7					; Upper nybble 
8ee7 cb 3f				SRL A 
8ee9 cb 3f				SRL A 
8eeb cb 3f				SRL A 
8eed cb 3f				SRL A 
8eef cd ff 8e				CALL tohex 
8ef2 77					ld (hl),a 
8ef3 23					inc hl	 
8ef4					 
8ef4					; Lower nybble 
8ef4 78					LD A, B 
8ef5 e6 0f				AND 0FH 
8ef7 cd ff 8e				CALL tohex 
8efa 77					ld (hl),a 
8efb 23					inc hl	 
8efc					 
8efc f1					POP AF 
8efd c1					POP BC 
8efe c9					RET 
8eff					 
8eff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8eff			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8eff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8eff			tohex: 
8eff e5					PUSH HL 
8f00 d5					PUSH DE 
8f01 16 00				LD D, 0 
8f03 5f					LD E, A 
8f04 21 0c 8f				LD HL, .DATA 
8f07 19					ADD HL, DE 
8f08 7e					LD A, (HL) 
8f09 d1					POP DE 
8f0a e1					POP HL 
8f0b c9					RET 
8f0c			 
8f0c			.DATA: 
8f0c 30					DEFB	30h	; 0 
8f0d 31					DEFB	31h	; 1 
8f0e 32					DEFB	32h	; 2 
8f0f 33					DEFB	33h	; 3 
8f10 34					DEFB	34h	; 4 
8f11 35					DEFB	35h	; 5 
8f12 36					DEFB	36h	; 6 
8f13 37					DEFB	37h	; 7 
8f14 38					DEFB	38h	; 8 
8f15 39					DEFB	39h	; 9 
8f16 41					DEFB	41h	; A 
8f17 42					DEFB	42h	; B 
8f18 43					DEFB	43h	; C 
8f19 44					DEFB	44h	; D 
8f1a 45					DEFB	45h	; E 
8f1b 46					DEFB	46h	; F 
8f1c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f1c			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8f1c			;;    subtract $30, if result > 9 then subtract $7 more 
8f1c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f1c			atohex: 
8f1c d6 30				SUB $30 
8f1e fe 0a				CP 10 
8f20 f8					RET M		; If result negative it was 0-9 so we're done 
8f21 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8f23 c9					RET		 
8f24			 
8f24			 
8f24			 
8f24			 
8f24			; Get 2 ASCII characters as hex byte from pointer in hl 
8f24			 
8f24			BYTERD: 
8f24 16 00			LD	D,00h		;Set up 
8f26 cd 2e 8f			CALL	HEXCON		;Get byte and convert to hex 
8f29 87				ADD	A,A		;First nibble so 
8f2a 87				ADD	A,A		;multiply by 16 
8f2b 87				ADD	A,A		; 
8f2c 87				ADD	A,A		; 
8f2d 57				LD	D,A		;Save hi nibble in D 
8f2e			HEXCON: 
8f2e 7e				ld a, (hl)		;Get next chr 
8f2f 23				inc hl 
8f30 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8f32 fe 0a			CP	00Ah		;Is it 0-9 ? 
8f34 38 02			JR	C,NALPHA	;If so miss next bit 
8f36 d6 07			SUB	007h		;Else convert alpha 
8f38			NALPHA: 
8f38 b2				OR	D		;Add hi nibble back 
8f39 c9				RET			; 
8f3a			 
8f3a			 
8f3a			; 
8f3a			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8f3a			; Since the routines get_byte and therefore get_nibble are called, only valid 
8f3a			; characters (0-9a-f) are accepted. 
8f3a			; 
8f3a			;get_word        push    af 
8f3a			;                call    get_byte        ; Get the upper byte 
8f3a			;                ld      h, a 
8f3a			;                call    get_byte        ; Get the lower byte 
8f3a			;                ld      l, a 
8f3a			;                pop     af 
8f3a			;                ret 
8f3a			; 
8f3a			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8f3a			; the routine get_nibble is used only valid characters are accepted - the  
8f3a			; input routine only accepts characters 0-9a-f. 
8f3a			; 
8f3a c5			get_byte:        push    bc              ; Save contents of B (and C) 
8f3b 7e					ld a,(hl) 
8f3c 23					inc hl 
8f3d cd 62 8f		                call    nibble2val      ; Get upper nibble 
8f40 cb 07		                rlc     a 
8f42 cb 07		                rlc     a 
8f44 cb 07		                rlc     a 
8f46 cb 07		                rlc     a 
8f48 47			                ld      b, a            ; Save upper four bits 
8f49 7e					ld a,(hl) 
8f4a cd 62 8f		                call    nibble2val      ; Get lower nibble 
8f4d b0			                or      b               ; Combine both nibbles 
8f4e c1			                pop     bc              ; Restore B (and C) 
8f4f c9			                ret 
8f50			; 
8f50			; Get a hexadecimal digit from the serial line. This routine blocks until 
8f50			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8f50			; to the serial line interface. The lower 4 bits of A contain the value of  
8f50			; that particular digit. 
8f50			; 
8f50			;get_nibble      ld a,(hl)           ; Read a character 
8f50			;                call    to_upper        ; Convert to upper case 
8f50			;                call    is_hex          ; Was it a hex digit? 
8f50			;                jr      nc, get_nibble  ; No, get another character 
8f50			 ;               call    nibble2val      ; Convert nibble to value 
8f50			 ;               call    print_nibble 
8f50			 ;               ret 
8f50			; 
8f50			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8f50			; A valid hexadecimal digit is denoted by a set C flag. 
8f50			; 
8f50			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8f50			;                ret     nc              ; Yes 
8f50			;                cp      '0'             ; Less than '0'? 
8f50			;                jr      nc, is_hex_1    ; No, continue 
8f50			;                ccf                     ; Complement carry (i.e. clear it) 
8f50			;                ret 
8f50			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8f50			;                ret     c               ; Yes 
8f50			;                cp      'A'             ; Less than 'A'? 
8f50			;                jr      nc, is_hex_2    ; No, continue 
8f50			;                ccf                     ; Yes - clear carry and return 
8f50			;                ret 
8f50			;is_hex_2        scf                     ; Set carry 
8f50			;                ret 
8f50			; 
8f50			; Convert a single character contained in A to upper case: 
8f50			; 
8f50 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8f52 d8			                ret     c 
8f53 fe 7b		                cp      'z' + 1         ; > 'z'? 
8f55 d0			                ret     nc              ; Nothing to do, either 
8f56 e6 5f		                and     $5f             ; Convert to upper case 
8f58 c9			                ret 
8f59			 
8f59			 
8f59			to_lower: 
8f59			 
8f59			   ; if char is in [A-Z] make it lower case 
8f59			 
8f59			   ; enter : a = char 
8f59			   ; exit  : a = lower case char 
8f59			   ; uses  : af 
8f59			 
8f59 fe 41		   cp 'A' 
8f5b d8			   ret c 
8f5c			    
8f5c fe 5b		   cp 'Z'+1 
8f5e d0			   ret nc 
8f5f			    
8f5f f6 20		   or $20 
8f61 c9			   ret 
8f62			 
8f62			; 
8f62			; Expects a hexadecimal digit (upper case!) in A and returns the 
8f62			; corresponding value in A. 
8f62			; 
8f62 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8f64 38 02		                jr      c, nibble2val_1 ; Yes 
8f66 d6 07		                sub     7               ; Adjust for A-F 
8f68 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f6a e6 0f		                and     $f              ; Only return lower 4 bits 
8f6c c9			                ret 
8f6d			; 
8f6d			; Print_nibble prints a single hex nibble which is contained in the lower  
8f6d			; four bits of A: 
8f6d			; 
8f6d			;print_nibble    push    af              ; We won't destroy the contents of A 
8f6d			;                and     $f              ; Just in case... 
8f6d			;                add     a, '0'             ; If we have a digit we are done here. 
8f6d			;                cp      '9' + 1         ; Is the result > 9? 
8f6d			;                jr      c, print_nibble_1 
8f6d			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f6d			;print_nibble_1  call    putc            ; Print the nibble and 
8f6d			;                pop     af              ; restore the original value of A 
8f6d			;                ret 
8f6d			;; 
8f6d			;; Send a CR/LF pair: 
8f6d			; 
8f6d			;crlf            push    af 
8f6d			;                ld      a, cr 
8f6d			;                call    putc 
8f6d			;                ld      a, lf 
8f6d			;                call    putc 
8f6d			;                pop     af 
8f6d			;                ret 
8f6d			; 
8f6d			; Print_word prints the four hex digits of a word to the serial line. The  
8f6d			; word is expected to be in HL. 
8f6d			; 
8f6d			;print_word      push    hl 
8f6d			;                push    af 
8f6d			;                ld      a, h 
8f6d			;                call    print_byte 
8f6d			;                ld      a, l 
8f6d			;                call    print_byte 
8f6d			;                pop     af 
8f6d			;                pop     hl 
8f6d			;                ret 
8f6d			; 
8f6d			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f6d			; The byte to be printed is expected to be in A. 
8f6d			; 
8f6d			;print_byte      push    af              ; Save the contents of the registers 
8f6d			;                push    bc 
8f6d			;                ld      b, a 
8f6d			;                rrca 
8f6d			;                rrca 
8f6d			;                rrca 
8f6d			;                rrca 
8f6d			;                call    print_nibble    ; Print high nibble 
8f6d			;                ld      a, b 
8f6d			;                call    print_nibble    ; Print low nibble 
8f6d			;                pop     bc              ; Restore original register contents 
8f6d			;                pop     af 
8f6d			;                ret 
8f6d			 
8f6d			 
8f6d			 
8f6d			 
8f6d			 
8f6d			fourehexhl:  
8f6d 7e				ld a,(hl) 
8f6e cd 1c 8f			call atohex 
8f71 cb 3f				SRL A 
8f73 cb 3f				SRL A 
8f75 cb 3f				SRL A 
8f77 cb 3f				SRL A 
8f79 47				ld b, a 
8f7a 23				inc hl 
8f7b 7e				ld a,(hl) 
8f7c 23				inc hl 
8f7d cd 1c 8f			call atohex 
8f80 80				add b 
8f81 57				ld d,a 
8f82 7e				ld a,(hl) 
8f83 cd 1c 8f			call atohex 
8f86 cb 3f				SRL A 
8f88 cb 3f				SRL A 
8f8a cb 3f				SRL A 
8f8c cb 3f				SRL A 
8f8e 47				ld b, a 
8f8f 23				inc hl 
8f90 7e				ld a,(hl) 
8f91 23				inc hl 
8f92 cd 1c 8f			call atohex 
8f95 80				add b 
8f96 5f				ld e, a 
8f97 d5				push de 
8f98 e1				pop hl 
8f99 c9				ret 
8f9a			 
8f9a			; pass hl. returns z set if the byte at hl is a digit 
8f9a			;isdigithl:  
8f9a			;	push bc 
8f9a			;	ld a,(hl) 
8f9a			;	cp ':' 
8f9a			;	jr nc, .isdf 		; > 
8f9a			;	cp '0' 
8f9a			;	jr c, .isdf		; < 
8f9a			; 
8f9a			;	; TODO find a better way to set z 
8f9a			; 
8f9a			;	ld b,a 
8f9a			;	cp b 
8f9a			;	pop bc 
8f9a			;	ret 
8f9a			; 
8f9a			;.isdf:	; not digit so clear z 
8f9a			; 
8f9a			;	; TODO find a better way to unset z 
8f9a			; 
8f9a			;	ld b,a 
8f9a			;	inc b 
8f9a			;	cp b 
8f9a			; 
8f9a			;	pop bc 
8f9a			;	ret 
8f9a				 
8f9a				 
8f9a			 
8f9a			 
8f9a			; pass hl as the four byte address to load 
8f9a			 
8f9a			get_word_hl:  
8f9a e5				push hl 
8f9b cd 3a 8f			call get_byte 
8f9e				 
8f9e 47				ld b, a 
8f9f			 
8f9f e1				pop hl 
8fa0 23				inc hl 
8fa1 23				inc hl 
8fa2			 
8fa2			; TODO not able to handle a-f  
8fa2 7e				ld a,(hl) 
8fa3			;	;cp ':' 
8fa3			;	cp 'g' 
8fa3			;	jr nc, .single_byte_hl 		; > 
8fa3			;	cp 'G' 
8fa3			;	jr nc, .single_byte_hl 		; > 
8fa3			;	cp '0' 
8fa3			;	jr c, .single_byte_hl		; < 
8fa3			 
8fa3				;call isdigithl 
8fa3 fe 00			cp 0 
8fa5 28 06			jr z, .single_byte_hl 
8fa7			 
8fa7			.getwhln:   ; hex word so get next byte 
8fa7			 
8fa7 cd 3a 8f			call get_byte 
8faa 6f				ld l, a 
8fab 60				ld h,b 
8fac c9				ret 
8fad 68			.single_byte_hl:   ld l,b 
8fae 26 00				ld h,0 
8fb0 c9					ret 
8fb1			 
8fb1			 
8fb1			 
8fb1			 
8fb1 21 51 97			ld hl,asc+1 
8fb4			;	ld a, (hl) 
8fb4			;	call nibble2val 
8fb4 cd 3a 8f			call get_byte 
8fb7			 
8fb7			;	call fourehexhl 
8fb7 32 f5 e2			ld (scratch+52),a 
8fba				 
8fba 21 f3 e2			ld hl,scratch+50 
8fbd 22 e4 e5			ld (os_cur_ptr),hl 
8fc0			 
8fc0 c9				ret 
8fc1			 
8fc1			 
8fc1			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8fc1			 
8fc1			; Decimal Unsigned Version 
8fc1			 
8fc1			;Number in a to decimal ASCII 
8fc1			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8fc1			;Example: display a=56 as "056" 
8fc1			;input: a = number 
8fc1			;Output: a=0,value of a in the screen 
8fc1			;destroys af,bc (don't know about hl and de) 
8fc1			DispAToASCII: 
8fc1 0e 9c			ld	c,-100 
8fc3 cd cd 8f			call	.Na1 
8fc6 0e f6			ld	c,-10 
8fc8 cd cd 8f			call	.Na1 
8fcb 0e ff			ld	c,-1 
8fcd 06 2f		.Na1:	ld	b,'0'-1 
8fcf 04			.Na2:	inc	b 
8fd0 81				add	a,c 
8fd1 38 fc			jr	c,.Na2 
8fd3 91				sub	c		;works as add 100/10/1 
8fd4 f5				push af		;safer than ld c,a 
8fd5 78				ld	a,b		;char is in b 
8fd6			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8fd6 f1				pop af		;safer than ld a,c 
8fd7 c9				ret 
8fd8			 
8fd8			; Decimal Signed Version 
8fd8			 
8fd8			; DispA 
8fd8			; -------------------------------------------------------------- 
8fd8			; Converts a signed integer value to a zero-terminated ASCII 
8fd8			; string representative of that value (using radix 10). 
8fd8			; -------------------------------------------------------------- 
8fd8			; INPUTS: 
8fd8			;     HL     Value to convert (two's complement integer). 
8fd8			;     DE     Base address of string destination. (pointer). 
8fd8			; -------------------------------------------------------------- 
8fd8			; OUTPUTS: 
8fd8			;     None 
8fd8			; -------------------------------------------------------------- 
8fd8			; REGISTERS/MEMORY DESTROYED 
8fd8			; AF HL 
8fd8			; -------------------------------------------------------------- 
8fd8			 
8fd8			;DispHLToASCII: 
8fd8			;   push    de 
8fd8			;   push    bc 
8fd8			; 
8fd8			;; Detect sign of HL. 
8fd8			;    bit    7, h 
8fd8			;    jr     z, ._DoConvert 
8fd8			; 
8fd8			;; HL is negative. Output '-' to string and negate HL. 
8fd8			;    ld     a, '-' 
8fd8			;    ld     (de), a 
8fd8			;    inc    de 
8fd8			; 
8fd8			;; Negate HL (using two's complement) 
8fd8			;    xor    a 
8fd8			;    sub    l 
8fd8			;    ld     l, a 
8fd8			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8fd8			;    sbc    a, h 
8fd8			;    ld     h, a 
8fd8			; 
8fd8			;; Convert HL to digit characters 
8fd8			;._DoConvert: 
8fd8			;    ld     b, 0     ; B will count character length of number 
8fd8			;-   ld     a, 10 
8fd8			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8fd8			;    push   af 
8fd8			;    inc    b 
8fd8			;    ld     a, h 
8fd8			;    or     l 
8fd8			;    jr     nz, - 
8fd8			; 
8fd8			;; Retrieve digits from stack 
8fd8			;-   pop    af 
8fd8			;    or     $30 
8fd8			;    ld     (de), a 
8fd8			;    inc    de 
8fd8			;    djnz   - 
8fd8			; 
8fd8			;; Terminate string with NULL 
8fd8			;    xor    a 
8fd8			;    ld     (de), a 
8fd8			; 
8fd8			;    pop    bc 
8fd8			;    pop    de 
8fd8			;    ret 
8fd8			 
8fd8			;Comments 
8fd8			; 
8fd8			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8fd8			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8fd8			;    Note that the output string will not be fixed-width. 
8fd8			; 
8fd8			;Example Usage 
8fd8			; 
8fd8			;    ld    hl, -1004 
8fd8			;    ld    de, OP1 
8fd8			;    call  DispA 
8fd8			;    ld    hl, OP1 
8fd8			;    syscall  PutS 
8fd8			 
8fd8			 
8fd8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fd8			 
8fd8			 
8fd8			;Converts an ASCII string to an unsigned 16-bit integer 
8fd8			;Quits when it reaches a non-decimal digit 
8fd8			 
8fd8			string_to_uint16: 
8fd8			atoui_16: 
8fd8			;Input: 
8fd8			;     DE points to the string 
8fd8			;Outputs: 
8fd8			;     HL is the result 
8fd8			;     A is the 8-bit value of the number 
8fd8			;     DE points to the byte after the number 
8fd8			;Destroys: 
8fd8			;     BC 
8fd8			;       if the string is non-empty, BC is HL/10 
8fd8			;Size:  24 bytes 
8fd8			;Speed: 42+d(104+{0,9}) 
8fd8			;       d is the number of digits in the number 
8fd8			;       max is 640 cycles for a 5 digit number 
8fd8			;Assuming no leading zeros: 
8fd8			;1 digit:  146cc 
8fd8			;2 digit:  250cc 
8fd8			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8fd8			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8fd8			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8fd8			;avg: 544.81158447265625cc (544+13297/16384) 
8fd8			;=============================================================== 
8fd8 21 00 00		  ld hl,0 
8fdb			.u16a: 
8fdb 1a			  ld a,(de) 
8fdc d6 30		  sub 30h 
8fde fe 0a		  cp 10 
8fe0 d0			  ret nc 
8fe1 13			  inc de 
8fe2 44			  ld b,h 
8fe3 4d			  ld c,l 
8fe4 29			  add hl,hl 
8fe5 29			  add hl,hl 
8fe6 09			  add hl,bc 
8fe7 29			  add hl,hl 
8fe8 85			  add a,l 
8fe9 6f			  ld l,a 
8fea 30 ef		  jr nc,.u16a 
8fec 24			  inc h 
8fed c3 db 8f		  jp .u16a 
8ff0			 
8ff0			 
8ff0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8ff0			 
8ff0			;written by Zeda 
8ff0			;Converts a 16-bit unsigned integer to an ASCII string. 
8ff0			 
8ff0			uitoa_16: 
8ff0			;Input: 
8ff0			;   DE is the number to convert 
8ff0			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8ff0			;Output: 
8ff0			;   HL points to the null-terminated ASCII string 
8ff0			;      NOTE: This isn't necessarily the same as the input HL. 
8ff0 d5			  push de 
8ff1 c5			  push bc 
8ff2 f5			  push af 
8ff3 eb			  ex de,hl 
8ff4			 
8ff4 01 f0 d8		  ld bc,-10000 
8ff7 3e 2f		  ld a,'0'-1 
8ff9 3c			  inc a 
8ffa 09			  add hl,bc  
8ffb 38 fc		   jr c,$-2 
8ffd 12			  ld (de),a 
8ffe 13			  inc de 
8fff			 
8fff 01 e8 03		  ld bc,1000 
9002 3e 3a		  ld a,'9'+1 
9004 3d			  dec a  
9005 09			  add hl,bc  
9006 30 fc		   jr nc,$-2 
9008 12			  ld (de),a 
9009 13			  inc de 
900a			 
900a 01 9c ff		  ld bc,-100 
900d 3e 2f		  ld a,'0'-1 
900f 3c			  inc a  
9010 09			  add hl,bc  
9011 38 fc		   jr c,$-2 
9013 12			  ld (de),a 
9014 13			  inc de 
9015			 
9015 7d			  ld a,l 
9016 26 3a		  ld h,'9'+1 
9018 25			  dec h  
9019 c6 0a		  add a,10  
901b 30 fb		   jr nc,$-3 
901d c6 30		  add a,'0' 
901f eb			  ex de,hl 
9020 72			  ld (hl),d 
9021 23			  inc hl 
9022 77			  ld (hl),a 
9023 23			  inc hl 
9024 36 00		  ld (hl),0 
9026			 
9026			;Now strip the leading zeros 
9026 0e fa		  ld c,-6 
9028 09			  add hl,bc 
9029 3e 30		  ld a,'0' 
902b 23			  inc hl  
902c be			  cp (hl)  
902d 28 fc		  jr z,$-2 
902f			 
902f			;Make sure that the string is non-empty! 
902f 7e			  ld a,(hl) 
9030 b7			  or a 
9031 20 01		  jr nz,.atoub 
9033 2b			  dec hl 
9034			.atoub: 
9034			 
9034 f1			  pop af 
9035 c1			  pop bc 
9036 d1			  pop de 
9037 c9			  ret 
9038			 
9038			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9038			 
9038			toUpper: 
9038			;A is the char. 
9038			;If A is a lowercase letter, this sets it to the matching uppercase 
9038			;18cc or 30cc or 41cc 
9038			;avg: 26.75cc 
9038 fe 61		  cp 'a' 
903a d8			  ret c 
903b fe 7b		  cp 'z'+1 
903d d0			  ret nc 
903e d6 20		  sub 'a'-'A' 
9040 c9			  ret 
9041			 
9041			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9041			 
9041			; String Length 
9041			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9041			 
9041			; Get the length of the null-terminated string starting at $8000 hl 
9041			;    LD     HL, $8000 
9041			 
9041			strlenz: 
9041			 
9041 af			    XOR    A               ; Zero is the value we are looking for. 
9042 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9043 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9044			                           ; 65, 536 bytes (the entire addressable memory space). 
9044 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9046			 
9046			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9046 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9047 6f			    LD     L, A             ; number of bytes 
9048 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
904a 2b			    DEC    HL              ; Compensate for null. 
904b c9				ret 
904c			 
904c			; Get the length of the A terminated string starting at $8000 hl 
904c			;    LD     HL, $8000 
904c			 
904c			strlent: 
904c			 
904c			                  ; A is the value we are looking for. 
904c 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
904e 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9050			                           ; 65, 536 bytes (the entire addressable memory space). 
9050 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9052			 
9052			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9052 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9054 2e 00		    LD     L, 0             ; number of bytes 
9056 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9058 2b			    DEC    HL              ; Compensate for null. 
9059 c9				ret 
905a			 
905a			 
905a			;Comparing Strings 
905a			 
905a			;IN    HL     Address of string1. 
905a			;      DE     Address of string2. 
905a			 
905a			; doc given but wrong??? 
905a			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
905a			;      carry  Set if string1 > string2, reset if string1 <= string2. 
905a			; tested 
905a			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
905a			 
905a			strcmp_old: 
905a e5			    PUSH   HL 
905b d5			    PUSH   DE 
905c			 
905c 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
905d be			    CP     (HL)            ; (want to minimize work). 
905e 38 01		    JR     C, Str1IsBigger 
9060 7e			    LD     A, (HL) 
9061			 
9061			Str1IsBigger: 
9061 4f			    LD     C, A             ; Put length in BC 
9062 06 00		    LD     B, 0 
9064 13			    INC    DE              ; Increment pointers to meat of string. 
9065 23			    INC    HL 
9066			 
9066			CmpLoop: 
9066 1a			    LD     A, (DE)          ; Compare bytes. 
9067 ed a1		    CPI 
9069 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
906b 13			    INC    DE              ; Update pointer. 
906c ea 66 90		    JP     PE, CmpLoop 
906f			 
906f d1			    POP    DE 
9070 e1			    POP    HL 
9071 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
9072 be			    CP     (HL) 
9073 c9			    RET 
9074			 
9074			NoMatch: 
9074 2b			    DEC    HL 
9075 be			    CP     (HL)            ; Compare again to affect carry. 
9076 d1			    POP    DE 
9077 e1			    POP    HL 
9078 c9			    RET 
9079			 
9079			;; test strmp 
9079			; 
9079			;ld de, .str1 
9079			;ld hl, .str2 
9079			;call strcmp 
9079			;jr z, .z1 
9079			;;this 
9079			;	if DEBUG_FORTH_WORDS 
9079			;		DMARK "NZ1" 
9079			;		CALLMONITOR 
9079			;	endif 
9079			;.z1: 
9079			; 
9079			;	if DEBUG_FORTH_WORDS 
9079			;		DMARK "ZZ1" 
9079			;		CALLMONITOR 
9079			;	endif 
9079			; 
9079			;ld de, .str1 
9079			;ld hl, .str1 
9079			;call strcmp 
9079			;jr z, .z2 
9079			;;this 
9079			;	if DEBUG_FORTH_WORDS 
9079			;		DMARK "NZ2" 
9079			;		CALLMONITOR 
9079			;	endif 
9079			;.z2: 
9079			; 
9079			;	if DEBUG_FORTH_WORDS 
9079			;		DMARK "ZZ2" 
9079			;		CALLMONITOR 
9079			;	endif 
9079			; 
9079			;ld de, .str1 
9079			;ld hl, .str2 
9079			;call strcmp 
9079			;jr c, .c1 
9079			; 
9079			;	if DEBUG_FORTH_WORDS 
9079			;		DMARK "Nc1" 
9079			;		CALLMONITOR 
9079			;	endif 
9079			;.c1: 
9079			;;this 
9079			;	if DEBUG_FORTH_WORDS 
9079			;		DMARK "cc1" 
9079			;		CALLMONITOR 
9079			;	endif 
9079			; 
9079			;ld de, .str1 
9079			;ld hl, .str1 
9079			;call strcmp 
9079			;jr c, .c2 
9079			;;this 
9079			;	if DEBUG_FORTH_WORDS 
9079			;		DMARK "Nc2" 
9079			;		CALLMONITOR 
9079			;	endif 
9079			;.c2: 
9079			; 
9079			;	if DEBUG_FORTH_WORDS 
9079			;		DMARK "cc2" 
9079			;		CALLMONITOR 
9079			;	endif 
9079			;	NEXTW 
9079			;.str1:   db "string1",0 
9079			;.str2:   db "string2",0 
9079			 
9079			; only care about direct match or not 
9079			; hl and de strings 
9079			; zero set if the same 
9079			 
9079			strcmp: 
9079 1a				ld a, (de) 
907a be				cp (hl) 
907b 28 02			jr z, .ssame 
907d b7				or a 
907e c9				ret 
907f			 
907f			.ssame:  
907f fe 00			cp 0 
9081 c8				ret z 
9082			 
9082 23				inc hl 
9083 13				inc de 
9084 18 f3			jr strcmp 
9086				 
9086				 
9086			 
9086			;Copyright (c) 2014, Luke Maurits 
9086			;All rights reserved. 
9086			; 
9086			;Redistribution and use in source and binary forms, with or without 
9086			;modification, are permitted provided that the following conditions are met: 
9086			; 
9086			;* Redistributions of source code must retain the above copyright notice, this 
9086			;  list of conditions and the following disclaimer. 
9086			; 
9086			;* Redistributions in binary form must reproduce the above copyright notice, 
9086			;  this list of conditions and the following disclaimer in the documentation 
9086			;  and/or other materials provided with the distribution. 
9086			; 
9086			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
9086			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
9086			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
9086			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
9086			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
9086			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
9086			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
9086			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
9086			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
9086			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
9086			 
9086			; https://github.com/lmaurits/lm512/blob/master/string.z80 
9086			 
9086			StrictStrCmp: 
9086				; Load next chars of each string 
9086 1a				ld a, (de) 
9087 47				ld b, a 
9088 7e				ld a, (hl) 
9089				; Compare 
9089 b8				cp b 
908a				; Return non-zero if chars don't match 
908a c0				ret nz 
908b				; Check for end of both strings 
908b fe 00			cp "\0" 
908d				; Return if strings have ended 
908d c8				ret z 
908e				; Otherwise, advance to next chars 
908e 23				inc hl 
908f 13				inc de 
9090 18 f4			jr StrictStrCmp 
9092			 
9092			;end 
9092			; eof 
9092			 
9092			 
9092			 
9092			 
9092			 
9092			 
# End of file firmware_strings.asm
9092			include "firmware_memory.asm"   ; malloc and free  
9092			 
9092			if DEBUG_FORTH_MALLOC_HIGH 
9092			.mallocsize: db "Wants malloc >256",0 
9092			.mallocasize: db "MALLOC gives >256",0 
9092			.malloczero: db "MALLOC gives zero",0 
9092			 
9092			malloc_guard_zerolen: 
9092				push hl 
9092				push de 
9092				push af 
9092			 
9092				ld de, 0 
9092			        call cmp16 
9092				jr nz, .lowalloz 
9092			 
9092				push hl 
9092				push de 
9092					ld hl, display_fb0 
9092					ld (display_fb_active), hl 
9092				call clear_display 
9092				ld a, 0 
9092				ld de, .malloczero 
9092				call str_at_display 
9092				call update_display 
9092				call delay1s 
9092				call delay1s 
9092				call bp_on 
9092			;	ld a, 0 
9092			;	ld (os_view_disable), a 
9092			 
9092				pop de 
9092				pop hl 
9092			 
9092				 
9092			 
9092				CALLMONITOR 
9092			.lowalloz: 
9092			 
9092			 
9092				pop af 
9092				pop de 
9092				pop hl 
9092			ret 
9092			 
9092			malloc_guard_entry: 
9092				push hl 
9092				push de 
9092				push af 
9092			 
9092			 	or a      ;clear carry flag 
9092				push hl 
9092				ld de, 255 
9092				sbc hl, de 
9092				jr c, .lowalloc 
9092			 
9092				push de 
9092					ld hl, display_fb0 
9092					ld (display_fb_active), hl 
9092				call clear_display 
9092				ld a, 0 
9092				ld de, .mallocsize 
9092				call str_at_display 
9092				call update_display 
9092				call delay1s 
9092				call delay1s 
9092			;	ld a, 0 
9092			;	ld (os_view_disable), a 
9092				call bp_on 
9092			 
9092				pop de 
9092				pop hl 
9092			 
9092				 
9092			 
9092				CALLMONITOR 
9092				jr .lowdone 
9092			.lowalloc: 
9092			 
9092			 
9092				pop hl 
9092			.lowdone:	pop af 
9092				pop de 
9092				pop hl 
9092			ret 
9092			 
9092			malloc_guard_exit: 
9092				push hl 
9092				push de 
9092				push af 
9092			 
9092			 	or a      ;clear carry flag 
9092				push hl 
9092				ld de, 255 
9092				sbc hl, de 
9092				jr c, .lowallocx 
9092			 
9092				push de 
9092					ld hl, display_fb0 
9092					ld (display_fb_active), hl 
9092				call clear_display 
9092				ld a, 0 
9092				ld de, .mallocasize 
9092				call str_at_display 
9092				call update_display 
9092				call delay1s 
9092				call delay1s 
9092			;	ld a, 0 
9092			;	ld (os_view_disable), a 
9092				call bp_on 
9092				pop de 
9092				pop hl 
9092			 
9092				CALLMONITOR 
9092				jr .lowdonex 
9092			.lowallocx: 
9092			 
9092				pop hl 
9092			.lowdonex:	pop af 
9092				pop de 
9092				pop hl 
9092			ret 
9092			endif 
9092			 
9092			if MALLOC_2 
9092			; Z80 Malloc and Free Functions 
9092			 
9092			; Malloc Function: 
9092			; Input: 
9092			;   HL: Size of block to allocate 
9092			; Output: 
9092			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9092			 
9092			malloc: 
9092				 
9092			if DEBUG_FORTH_MALLOC_HIGH 
9092			call malloc_guard_entry 
9092			endif 
9092			 
9092			 
9092			 
9092			 
9092					if DEBUG_FORTH_MALLOC 
9092						DMARK "mal" 
9092						CALLMONITOR 
9092					endif 
9092			    push af            ; Save AF register 
9092			    ld a, l            ; Load low byte of size into A 
9092			    or h               ; Check if size is zero 
9092			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
9092			 
9092			    ; Allocate memory 
9092			    ld hl, (heap_start) ; Load start of heap into HL 
9092					if DEBUG_FORTH_MALLOC 
9092						DMARK "ma1" 
9092						CALLMONITOR 
9092					endif 
9092			    call malloc_internal ; Call internal malloc function 
9092			    pop af             ; Restore AF register 
9092			if DEBUG_FORTH_MALLOC_HIGH 
9092			call malloc_guard_exit 
9092			call malloc_guard_zerolen 
9092			endif 
9092			    ret                ; Return 
9092			 
9092			; Free Function: 
9092			; Input: 
9092			;   HL: Pointer to memory block to free 
9092			; Output: 
9092			;   None 
9092			 
9092			free: 
9092			    push af            ; Save AF register 
9092			    ld a, l            ; Load low byte of pointer into A 
9092			    or h               ; Check if pointer is NULL 
9092			    jp z, free_exit    ; If pointer is NULL, exit 
9092			 
9092			    ; Free memory 
9092			    ld hl, (heap_start) ; Load start of heap into HL 
9092			    call free_internal  ; Call internal free function 
9092			    pop af             ; Restore AF register 
9092			    ret                ; Return 
9092			 
9092			; Internal Malloc Function: 
9092			; Input: 
9092			;   HL: Size of block to allocate 
9092			; Output: 
9092			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9092			 
9092			malloc_internal: 
9092			    ld bc, 2           ; Number of bytes to allocate for management overhead 
9092			    add hl, bc         ; Add management overhead to requested size 
9092			    ex de, hl          ; Save total size in DE, and keep it in HL 
9092					if DEBUG_FORTH_MALLOC 
9092						DMARK "ma2" 
9092						CALLMONITOR 
9092					endif 
9092			 
9092			    ; Search for free memory block 
9092			    ld de, (heap_end)  ; Load end of heap into DE 
9092			    ld bc, 0           ; Initialize counter 
9092			 
9092					if DEBUG_FORTH_MALLOC 
9092						DMARK "ma2" 
9092						CALLMONITOR 
9092					endif 
9092			malloc_search_loop: 
9092			    ; Check if current block is free 
9092			    ld a, (hl)         ; Load current block's status (free or used) 
9092			    cp 0               ; Compare with zero (free) 
9092			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
9092			 
9092			    ; Check if current block is large enough 
9092			    ld a, (hl+1)       ; Load high byte of block size 
9092			    cp l               ; Compare with low byte of requested size 
9092			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
9092			 
9092			    ld a, (hl+2)       ; Load low byte of block size 
9092			    cp h               ; Compare with high byte of requested size 
9092			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
9092			 
9092			    ; Mark block as used 
9092			    ld (hl), 0xFF      ; Set status byte to indicate used block 
9092			 
9092			    ; Calculate remaining space in block 
9092			    ld bc, 0           ; Clear BC 
9092			    add hl, bc         ; Increment HL to point to start of data block 
9092			    add hl, de         ; HL = HL + DE (total size) 
9092			    ld bc, 1           ; Number of bytes to allocate for management overhead 
9092			    add hl, bc         ; Add management overhead to start of data block 
9092			 
9092			    ; Save pointer to allocated block in HL 
9092			if DEBUG_FORTH_MALLOC_HIGH 
9092						DMARK "ma5" 
9092			call malloc_guard_exit 
9092			call malloc_guard_zerolen 
9092			endif 
9092			    ret 
9092			 
9092			malloc_skip_block_check: 
9092			    ; Move to the next block 
9092			    ld bc, 3           ; Size of management overhead 
9092			    add hl, bc         ; Move to the next block 
9092			    inc de             ; Increment counter 
9092			 
9092			    ; Check if we have reached the end of heap 
9092			    ld a, e            ; Load low byte of heap end address 
9092			    cp (hl)            ; Compare with low byte of current address 
9092			    jr nz, malloc_search_loop  ; If not equal, continue searching 
9092			    ld a, d            ; Load high byte of heap end address 
9092			    cp 0               ; Check if it's zero (end of memory) 
9092			    jr nz, malloc_search_loop  ; If not zero, continue searching 
9092			 
9092			    ; If we reached here, allocation failed 
9092			    xor a              ; Set result to NULL 
9092			if DEBUG_FORTH_MALLOC_HIGH 
9092						DMARK "ma6" 
9092			call malloc_guard_exit 
9092			call malloc_guard_zerolen 
9092			endif 
9092			    ret 
9092			malloc_exit: 
9092			if DEBUG_FORTH_MALLOC_HIGH 
9092						DMARK "ma7" 
9092			call malloc_guard_exit 
9092			call malloc_guard_zerolen 
9092			endif 
9092			    ret 
9092			 
9092			; Internal Free Function: 
9092			; Input: 
9092			;   HL: Pointer to memory block to free 
9092			; Output: 
9092			;   None 
9092			 
9092			free_internal: 
9092			    ld de, (heap_start) ; Load start of heap into DE 
9092			    ld bc, 0            ; Initialize counter 
9092			 
9092			free_search_loop: 
9092			    ; Check if current block contains the pointer 
9092			    ld a, l             ; Load low byte of pointer 
9092			    cp (hl+1)           ; Compare with high byte of current block's address 
9092			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9092			    ld a, h             ; Load high byte of pointer 
9092			    cp (hl+2)           ; Compare with low byte of current block's address 
9092			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9092			 
9092			    ; Mark block as free 
9092			    ld (hl), 0          ; Set status byte to indicate free block 
9092			    ret                 ; Return 
9092			 
9092			free_skip_block_check: 
9092			    ; Move to the next block 
9092			    ld bc, 3            ; Size of management overhead 
9092			    add hl, bc          ; Move to the next block 
9092			    inc de              ; Increment counter 
9092			 
9092			    ; Check if we have reached the end of heap 
9092			    ld a, e             ; Load low byte of heap end address 
9092			    cp (hl)             ; Compare with low byte of current address 
9092			    jr nz, free_search_loop  ; If not equal, continue searching 
9092			    ld a, d             ; Load high byte of heap end address 
9092			    cp 0                ; Check if it's zero (end of memory) 
9092			    jr nz, free_search_loop  ; If not zero, continue searching 
9092			 
9092			    ; If we reached here, pointer is not found in heap 
9092			    ret 
9092			 
9092			free_exit: 
9092			    ret                 ; Return 
9092			 
9092			; Define heap start and end addresses 
9092			;heap_start:    .dw 0xC000   ; Start of heap 
9092			;heap_end:      .dw 0xE000   ; End of heap 
9092			 
9092			endif 
9092			 
9092			 
9092			if MALLOC_1 
9092			 
9092			 
9092			 
9092			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
9092			 
9092			;moved to firmware.asm 
9092			;heap_start        .equ  0x9000      ; Starting address of heap 
9092			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9092			 
9092			;      .org 0 
9092			;      jp    main 
9092			 
9092			 
9092			;      .org  0x100 
9092			;main: 
9092			;      ld    HL, 0x8100 
9092			;      ld    SP, HL 
9092			; 
9092			;      call  heap_init 
9092			; 
9092			;      ; Make some allocations 
9092			;      ld    HL, 12 
9092			;      call  malloc            ; Allocates 0x9004 
9092			; 
9092			;      ld    HL, 12 
9092			;      call  malloc            ; Allocates 0x9014 
9092			; 
9092			;      ld    HL, 12 
9092			;      call  malloc            ; Allocates 0x9024 
9092			; 
9092			;      ; Free some allocations 
9092			;      ld    HL, 0x9014 
9092			;      call  free 
9092			; 
9092			;      ld    HL, 0x9004 
9092			;      call  free 
9092			; 
9092			;      ld    HL, 0x9024 
9092			;      call  free 
9092			; 
9092			; 
9092			;      halt 
9092			 
9092			 
9092			;------------------------------------------------------------------------------ 
9092			;     heap_init                                                               : 
9092			;                                                                             : 
9092			; Description                                                                 : 
9092			;     Initialise the heap and make it ready for malloc and free operations.   : 
9092			;                                                                             : 
9092			;     The heap is maintained as a linked list, starting with an initial       : 
9092			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9092			;     the first free block in the heap. Each block then points to the next    : 
9092			;     free block within the heap, and the free list ends at the first block   : 
9092			;     with a null pointer to the next free block.                             : 
9092			;                                                                             : 
9092			; Parameters                                                                  : 
9092			;     Inputs are compile-time only. Two defines which specify the starting    : 
9092			;     address of the heap and its size are required, along with a memory      : 
9092			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9092			;     principally stores a pointer to the first free block in the heap.       : 
9092			;                                                                             : 
9092			; Returns                                                                     : 
9092			;     Nothing                                                                 : 
9092			;------------------------------------------------------------------------------ 
9092			heap_init: 
9092 e5			      push  HL 
9093			 
9093			      ; Initialise free list struct 
9093 21 20 dd		      ld    HL, heap_start 
9096 22 1b dd		      ld    (free_list), HL 
9099 21 00 00		      ld    HL, 0 
909c 22 1d dd		      ld    (free_list+2), HL 
909f			 
909f			      ; Insert first free block at bottom of heap, consumes entire heap 
909f 21 98 e2		      ld    HL, heap_start+heap_size-4 
90a2 22 20 dd		      ld    (heap_start), HL        ; Next block (end of free list) 
90a5 21 78 05		      ld    HL, heap_size-4 
90a8 22 22 dd		      ld    (heap_start+2), HL      ; Block size 
90ab			 
90ab			      ; Insert end of free list block at top of heap - two null words will 
90ab			      ; terminate the free list 
90ab 21 00 00		      ld    HL, 0 
90ae 22 9a e2		      ld    (heap_start+heap_size-2), HL 
90b1 22 98 e2		      ld    (heap_start+heap_size-4), HL 
90b4			 
90b4 e1			      pop   HL 
90b5			 
90b5 c9			      ret 
90b6			 
90b6			 
90b6			;------------------------------------------------------------------------------ 
90b6			;     malloc                                                                  : 
90b6			;                                                                             : 
90b6			; Description                                                                 : 
90b6			;     Allocates the wanted space from the heap and returns the address of the : 
90b6			;     first useable byte of the allocation.                                   : 
90b6			;                                                                             : 
90b6			;     Allocations can happen in one of two ways:                              : 
90b6			;                                                                             : 
90b6			;     1. A free block may be found which is the exact size wanted. In this    : 
90b6			;        case the block is removed from the free list and retuedn to the      : 
90b6			;        caller.                                                              : 
90b6			;     2. A free block may be found which is larger than the size wanted. In   : 
90b6			;        this case, the larger block is split into two. The first portion of  : 
90b6			;        this block will become the requested space by the malloc call and    : 
90b6			;        is returned to the caller. The second portion becomes a new free     : 
90b6			;        block, and the free list is adjusted to maintain continuity via this : 
90b6			;        newly created block.                                                 : 
90b6			;                                                                             : 
90b6			;     malloc does not set any initial value in the allocated space, the       : 
90b6			;     caller is required to do this as required.                              : 
90b6			;                                                                             : 
90b6			;     This implementation of malloc uses the stack exclusively, and is        : 
90b6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90b6			;     advisable to disable interrupts before calling malloc, and recommended  : 
90b6			;     to avoid the use of malloc inside ISRs in general.                      : 
90b6			;                                                                             : 
90b6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90b6			;                                                                             : 
90b6			; Parameters                                                                  : 
90b6			;     HL  Number of bytes wanted                                              : 
90b6			;                                                                             : 
90b6			; Returns                                                                     : 
90b6			;     HL  Address of the first useable byte of the allocation                 : 
90b6			;                                                                             : 
90b6			; Flags                                                                       : 
90b6			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90b6			;                                                                             : 
90b6			; Stack frame                                                                 : 
90b6			;       |             |                                                       : 
90b6			;       +-------------+                                                       : 
90b6			;       |     BC      |                                                       : 
90b6			;       +-------------+                                                       : 
90b6			;       |     DE      |                                                       : 
90b6			;       +-------------+                                                       : 
90b6			;       |     IX      |                                                       : 
90b6			;       +-------------+                                                       : 
90b6			;       |  prev_free  |                                                       : 
90b6			;   +4  +-------------+                                                       : 
90b6			;       |  this_free  |                                                       : 
90b6			;   +2  +-------------+                                                       : 
90b6			;       |  next_free  |                                                       : 
90b6			;   +0  +-------------+                                                       : 
90b6			;       |             |                                                       : 
90b6			;                                                                             : 
90b6			;------------------------------------------------------------------------------ 
90b6			 
90b6			 
90b6			;malloc: 
90b6			; 
90b6			;	SAVESP ON 1 
90b6			; 
90b6			;	call malloc_code 
90b6			; 
90b6			;	CHECKSP ON 1 
90b6			;	ret 
90b6			 
90b6			 
90b6			malloc: 
90b6 c5			      push  BC 
90b7 d5			      push  DE 
90b8 dd e5		      push  IX 
90ba			if DEBUG_FORTH_MALLOC_HIGH 
90ba			call malloc_guard_entry 
90ba			endif 
90ba			 
90ba					if DEBUG_FORTH_MALLOC 
90ba						DMARK "mal" 
90ba						CALLMONITOR 
90ba					endif 
90ba 7c			      ld    A, H                    ; Exit if no space requested 
90bb b5			      or    L 
90bc ca 7b 91		      jp    Z, malloc_early_exit 
90bf			 
90bf			;inc hl 
90bf			;inc hl 
90bf			;inc hl 
90bf			; 
90bf			;inc hl 
90bf			;inc hl 
90bf			;inc hl 
90bf			;inc hl 
90bf			;inc hl 
90bf			;inc hl 
90bf			;inc hl 
90bf			;inc hl 
90bf			;inc hl 
90bf			 
90bf			 
90bf			 
90bf			 
90bf					if DEBUG_FORTH_MALLOC 
90bf						DMARK "maA" 
90bf						CALLMONITOR 
90bf					endif 
90bf			      ; Set up stack frame 
90bf eb			      ex    DE, HL 
90c0 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90c3 39			      add   HL, SP 
90c4 f9			      ld    SP, HL 
90c5 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
90c9 dd 39		      add   IX, SP 
90cb			 
90cb			      ; Setup initial state 
90cb 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
90ce 19			      add   HL, DE 
90cf			 
90cf 44			      ld    B, H                    ; Move want to BC 
90d0 4d			      ld    C, L 
90d1			 
90d1 21 1b dd		      ld    HL, free_list           ; Store prev_free ptr to stack 
90d4 dd 75 04		      ld    (IX+4), L 
90d7 dd 74 05		      ld    (IX+5), H 
90da			 
90da 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
90db 23			      inc   HL 
90dc 56			      ld    D, (HL) 
90dd dd 73 02		      ld    (IX+2), E 
90e0 dd 72 03		      ld    (IX+3), D 
90e3 eb			      ex    DE, HL                  ; this_free ptr into HL 
90e4			 
90e4					if DEBUG_FORTH_MALLOC 
90e4						DMARK "maB" 
90e4						CALLMONITOR 
90e4					endif 
90e4			      ; Loop through free block list to find some space 
90e4			malloc_find_space: 
90e4 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
90e5 23			      inc   HL 
90e6 56			      ld    D, (HL) 
90e7			 
90e7 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90e8 b3			      or    E 
90e9 ca 75 91		      jp    Z, malloc_no_space 
90ec			 
90ec dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
90ef dd 72 01		      ld    (IX+1), D 
90f2			 
90f2			      ; Does this block have enough space to make the allocation? 
90f2 23			      inc   HL                      ; Load free block size into DE 
90f3 5e			      ld    E, (HL) 
90f4 23			      inc   HL 
90f5 56			      ld    D, (HL) 
90f6			 
90f6 eb			      ex    DE, HL                  ; Check size of block against want 
90f7 b7			      or    A                       ; Ensure carry flag clear 
90f8 ed 42		      sbc   HL, BC 
90fa e5			      push  HL                      ; Store the result for later (new block size) 
90fb			 
90fb ca 4a 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
90fe 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9100			 
9100			      ; this_free block is not big enough, setup ptrs to test next free block 
9100 e1			      pop   HL                      ; Discard previous result 
9101			 
9101 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9104 dd 66 03		      ld    H, (IX+3) 
9107 dd 75 04		      ld    (IX+4), L 
910a dd 74 05		      ld    (IX+5), H 
910d			 
910d dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9110 dd 66 01		      ld    H, (IX+1) 
9113 dd 75 02		      ld    (IX+2), L 
9116 dd 74 03		      ld    (IX+3), H 
9119			 
9119					if DEBUG_FORTH_MALLOC 
9119						DMARK "MA>" 
9119						CALLMONITOR 
9119					endif 
9119 18 c9		      jr    malloc_find_space 
911b			 
911b			      ; split a bigger block into two - requested size and remaining size 
911b			malloc_alloc_split: 
911b					if DEBUG_FORTH_MALLOC 
911b						DMARK "MAs" 
911b						CALLMONITOR 
911b					endif 
911b eb			      ex    DE, HL                  ; Calculate address of new free block 
911c 2b			      dec   HL 
911d 2b			      dec   HL 
911e 2b			      dec   HL 
911f 09			      add   HL, BC 
9120			 
9120			      ; Create a new block and point it at next_free 
9120 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9123 dd 56 01		      ld    D, (IX+1) 
9126			 
9126 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9127 23			      inc   HL 
9128 72			      ld    (HL), D 
9129			 
9129 d1			      pop   DE                      ; Store size of new block into new block 
912a 23			      inc   HL 
912b 73			      ld    (HL), E 
912c 23			      inc   HL 
912d 72			      ld    (HL), D 
912e			 
912e			      ; Update this_free ptr to point to new block 
912e 2b			      dec   HL 
912f 2b			      dec   HL 
9130 2b			      dec   HL 
9131			 
9131 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9134 dd 56 03		      ld    D, (IX+3) 
9137			 
9137 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
913a dd 74 03		      ld    (IX+3), H 
913d			 
913d			      ; Modify this_free block to be allocation 
913d eb			      ex    DE, HL 
913e af			      xor   A                       ; Null the next block ptr of allocated block 
913f 77			      ld    (HL), A 
9140 23			      inc   HL 
9141 77			      ld    (HL), A 
9142			 
9142 23			      inc   HL                      ; Store want size into allocated block 
9143 71			      ld    (HL), C 
9144 23			      inc   HL 
9145 70			      ld    (HL), B 
9146 23			      inc   HL 
9147 e5			      push  HL                      ; Address of allocation to return 
9148			 
9148 18 19		      jr    malloc_update_links 
914a			 
914a			malloc_alloc_fit: 
914a e1			      pop   HL                      ; Dont need new block size, want is exact fit 
914b			 
914b					if DEBUG_FORTH_MALLOC 
914b						DMARK "MAf" 
914b						CALLMONITOR 
914b					endif 
914b			      ; Modify this_free block to be allocation 
914b eb			      ex    DE, HL 
914c 2b			      dec   HL 
914d 2b			      dec   HL 
914e 2b			      dec   HL 
914f			 
914f af			      xor   A                       ; Null the next block ptr of allocated block 
9150 77			      ld    (HL), A 
9151 23			      inc   HL 
9152 77			      ld    (HL), A 
9153			 
9153 23			      inc   HL                      ; Store address of allocation to return 
9154 23			      inc   HL 
9155 23			      inc   HL 
9156 e5			      push  HL 
9157			 
9157			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9157 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
915a dd 66 01		      ld    H, (IX+1) 
915d			 
915d dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9160 dd 74 03		      ld    (IX+3), H 
9163			 
9163			 
9163			malloc_update_links: 
9163			      ; Update prev_free ptr to point to this_free 
9163 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9166 dd 66 05		      ld    H, (IX+5) 
9169			 
9169 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
916c dd 56 03		      ld    D, (IX+3) 
916f			 
916f 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9170 23			      inc   HL 
9171 72			      ld    (HL), D 
9172			 
9172					if DEBUG_FORTH_MALLOC 
9172						DMARK "Mul" 
9172						CALLMONITOR 
9172					endif 
9172			      ; Clear the Z flag to indicate successful allocation 
9172 7a			      ld    A, D 
9173 b3			      or    E 
9174			 
9174 d1			      pop   DE                      ; Address of allocation 
9175					if DEBUG_FORTH_MALLOC 
9175						DMARK "MAu" 
9175						CALLMONITOR 
9175					endif 
9175			 
9175			malloc_no_space: 
9175 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9178 39			      add   HL, SP 
9179 f9			      ld    SP, HL 
917a			 
917a eb			      ex    DE, HL                  ; Alloc addr into HL for return 
917b					if DEBUG_FORTH_MALLOC 
917b						DMARK "MAN" 
917b						CALLMONITOR 
917b					endif 
917b			 
917b			malloc_early_exit: 
917b					if DEBUG_FORTH_MALLOC 
917b						DMARK "MAx" 
917b						CALLMONITOR 
917b					endif 
917b dd e1		      pop   IX 
917d d1			      pop   DE 
917e c1			      pop   BC 
917f			 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f c9			      ret 
9180			 
9180			 
9180			;------------------------------------------------------------------------------ 
9180			;     free                                                                    : 
9180			;                                                                             : 
9180			; Description                                                                 : 
9180			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9180			;     returned by malloc, otherwise the behaviour is undefined.               : 
9180			;                                                                             : 
9180			;     Where possible, directly adjacent free blocks will be merged together   : 
9180			;     into larger blocks to help ensure that the heap does not become         : 
9180			;     excessively fragmented.                                                 : 
9180			;                                                                             : 
9180			;     free does not clear or set any other value into the freed space, and    : 
9180			;     therefore its contents may be visible through subsequent malloc's. The  : 
9180			;     caller should clear the freed space as required.                        : 
9180			;                                                                             : 
9180			;     This implementation of free uses the stack exclusively, and is          : 
9180			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9180			;     advisable to disable interrupts before calling free, and recommended    : 
9180			;     to avoid the use of free inside ISRs in general.                        : 
9180			;                                                                             : 
9180			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9180			;                                                                             : 
9180			; Parameters                                                                  : 
9180			;     HL  Pointer to address of first byte of allocation to be freed          : 
9180			;                                                                             : 
9180			; Returns                                                                     : 
9180			;     Nothing                                                                 : 
9180			;                                                                             : 
9180			; Stack frame                                                                 : 
9180			;       |             |                                                       : 
9180			;       +-------------+                                                       : 
9180			;       |     BC      |                                                       : 
9180			;       +-------------+                                                       : 
9180			;       |     DE      |                                                       : 
9180			;       +-------------+                                                       : 
9180			;       |     IX      |                                                       : 
9180			;       +-------------+                                                       : 
9180			;       |  prev_free  |                                                       : 
9180			;   +2  +-------------+                                                       : 
9180			;       |  next_free  |                                                       : 
9180			;   +0  +-------------+                                                       : 
9180			;       |             |                                                       : 
9180			;                                                                             : 
9180			;------------------------------------------------------------------------------ 
9180			free: 
9180 c5			      push  BC 
9181 d5			      push  DE 
9182 dd e5		      push  IX 
9184			 
9184 7c			      ld    A, H                    ; Exit if ptr is null 
9185 b5			      or    L 
9186 ca 4a 92		      jp    Z, free_early_exit 
9189			 
9189			      ; Set up stack frame 
9189 eb			      ex    DE, HL 
918a 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
918d 39			      add   HL, SP 
918e f9			      ld    SP, HL 
918f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9193 dd 39		      add   IX, SP 
9195			 
9195			      ; The address in HL points to the start of the useable allocated space, 
9195			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9195			      ; address of the block itself. 
9195 eb			      ex    DE, HL 
9196 11 fc ff		      ld    DE, -4 
9199 19			      add   HL, DE 
919a			 
919a			      ; An allocated block must have a null next block pointer in it 
919a 7e			      ld    A, (HL) 
919b 23			      inc   HL 
919c b6			      or    (HL) 
919d c2 45 92		      jp    NZ, free_done 
91a0			 
91a0 2b			      dec   HL 
91a1			 
91a1 44			      ld    B, H                    ; Copy HL to BC 
91a2 4d			      ld    C, L 
91a3			 
91a3			      ; Loop through the free list to find the first block with an address 
91a3			      ; higher than the block being freed 
91a3 21 1b dd		      ld    HL, free_list 
91a6			 
91a6			free_find_higher_block: 
91a6 5e			      ld    E, (HL)                 ; Load next ptr from free block 
91a7 23			      inc   HL 
91a8 56			      ld    D, (HL) 
91a9 2b			      dec   HL 
91aa			 
91aa dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
91ad dd 72 01		      ld    (IX+1), D 
91b0 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
91b3 dd 74 03		      ld    (IX+3), H 
91b6			 
91b6 78			      ld    A, B                    ; Check if DE is greater than BC 
91b7 ba			      cp    D                       ; Compare MSB first 
91b8 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
91ba 30 04		      jr    NC, free_find_higher_block_skip 
91bc 79			      ld    A, C 
91bd bb			      cp    E                       ; Then compare LSB 
91be 38 08		      jr    C, free_found_higher_block 
91c0			 
91c0			free_find_higher_block_skip: 
91c0 7a			      ld    A, D                    ; Reached the end of the free list? 
91c1 b3			      or    E 
91c2 ca 45 92		      jp    Z, free_done 
91c5			 
91c5 eb			      ex    DE, HL 
91c6			 
91c6 18 de		      jr    free_find_higher_block 
91c8			 
91c8			free_found_higher_block: 
91c8			      ; Insert freed block between prev and next free blocks 
91c8 71			      ld    (HL), C                 ; Point prev free block to freed block 
91c9 23			      inc   HL 
91ca 70			      ld    (HL), B 
91cb			 
91cb 60			      ld    H, B                    ; Point freed block at next free block 
91cc 69			      ld    L, C 
91cd 73			      ld    (HL), E 
91ce 23			      inc   HL 
91cf 72			      ld    (HL), D 
91d0			 
91d0			      ; Check if the freed block is adjacent to the next free block 
91d0 23			      inc   HL                      ; Load size of freed block into HL 
91d1 5e			      ld    E, (HL) 
91d2 23			      inc   HL 
91d3 56			      ld    D, (HL) 
91d4 eb			      ex    DE, HL 
91d5			 
91d5 09			      add   HL, BC                  ; Add addr of freed block and its size 
91d6			 
91d6 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
91d9 dd 56 01		      ld    D, (IX+1) 
91dc			 
91dc b7			      or    A                       ; Clear the carry flag 
91dd ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91df 20 22		      jr    NZ, free_check_adjacent_to_prev 
91e1			 
91e1			      ; Freed block is adjacent to next, merge into one bigger block 
91e1 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
91e2 5e			      ld    E, (HL) 
91e3 23			      inc   HL 
91e4 56			      ld    D, (HL) 
91e5 e5			      push  HL                      ; Save ptr to next block for later 
91e6			 
91e6 60			      ld    H, B                    ; Store ptr from next block into freed block 
91e7 69			      ld    L, C 
91e8 73			      ld    (HL), E 
91e9 23			      inc   HL 
91ea 72			      ld    (HL), D 
91eb			 
91eb e1			      pop   HL                      ; Restore ptr to next block 
91ec 23			      inc   HL                      ; Load size of next block into DE 
91ed 5e			      ld    E, (HL) 
91ee 23			      inc   HL 
91ef 56			      ld    D, (HL) 
91f0 d5			      push  DE                      ; Save next block size for later 
91f1			 
91f1 60			      ld    H, B                    ; Load size of freed block into HL 
91f2 69			      ld    L, C 
91f3 23			      inc   HL 
91f4 23			      inc   HL 
91f5 5e			      ld    E, (HL) 
91f6 23			      inc   HL 
91f7 56			      ld    D, (HL) 
91f8 eb			      ex    DE, HL 
91f9			 
91f9 d1			      pop   DE                      ; Restore size of next block 
91fa 19			      add   HL, DE                  ; Add sizes of both blocks 
91fb eb			      ex    DE, HL 
91fc			 
91fc 60			      ld    H, B                    ; Store new bigger size into freed block 
91fd 69			      ld    L, C 
91fe 23			      inc   HL 
91ff 23			      inc   HL 
9200 73			      ld    (HL), E 
9201 23			      inc   HL 
9202 72			      ld    (HL), D 
9203			 
9203			free_check_adjacent_to_prev: 
9203			      ; Check if the freed block is adjacent to the prev free block 
9203 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9206 dd 66 03		      ld    H, (IX+3) 
9209			 
9209 23			      inc   HL                      ; Size of prev free block into DE 
920a 23			      inc   HL 
920b 5e			      ld    E, (HL) 
920c 23			      inc   HL 
920d 56			      ld    D, (HL) 
920e 2b			      dec   HL 
920f 2b			      dec   HL 
9210 2b			      dec   HL 
9211			 
9211 19			      add   HL, DE                  ; Add prev block addr and size 
9212			 
9212 b7			      or    A                       ; Clear the carry flag 
9213 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9215 20 2e		      jr    NZ, free_done 
9217			 
9217			      ; Freed block is adjacent to prev, merge into one bigger block 
9217 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9218 69			      ld    L, C 
9219 5e			      ld    E, (HL) 
921a 23			      inc   HL 
921b 56			      ld    D, (HL) 
921c e5			      push  HL                      ; Save freed block ptr for later 
921d			 
921d dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9220 dd 66 03		      ld    H, (IX+3) 
9223 73			      ld    (HL), E 
9224 23			      inc   HL 
9225 72			      ld    (HL), D 
9226			 
9226 e1			      pop   HL                      ; Restore freed block ptr 
9227 23			      inc   HL                      ; Load size of freed block into DE 
9228 5e			      ld    E, (HL) 
9229 23			      inc   HL 
922a 56			      ld    D, (HL) 
922b d5			      push  DE                      ; Save freed block size for later 
922c			 
922c dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
922f dd 66 03		      ld    H, (IX+3) 
9232 23			      inc   HL 
9233 23			      inc   HL 
9234 5e			      ld    E, (HL) 
9235 23			      inc   HL 
9236 56			      ld    D, (HL) 
9237			 
9237 e1			      pop   HL                      ; Add sizes of both blocks 
9238 19			      add   HL, DE 
9239 eb			      ex    DE, HL 
923a			 
923a dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
923d dd 66 03		      ld    H, (IX+3) 
9240 23			      inc   HL 
9241 23			      inc   HL 
9242 73			      ld    (HL), E 
9243 23			      inc   HL 
9244 72			      ld    (HL), D 
9245			 
9245			free_done: 
9245 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9248 39			      add   HL, SP 
9249 f9			      ld    SP, HL 
924a			 
924a			free_early_exit: 
924a dd e1		      pop   IX 
924c d1			      pop   DE 
924d c1			      pop   BC 
924e			 
924e c9			      ret 
924f			 
924f			; moved to firmware.asm 
924f			; 
924f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
924f			;                  .dw   0 
924f			 
924f			 
924f			endif 
924f			 
924f			 
924f			if MALLOC_3 
924f			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
924f			;heap_start        .equ  0x9000      ; Starting address of heap 
924f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
924f			; 
924f			 ;     .org 0 
924f			  ;    jp    main 
924f			; 
924f			; 
924f			 ;     .org  0x100 
924f			;main: 
924f			 ;     ld    HL, 0x8100 
924f			  ;    ld    SP, HL 
924f			; 
924f			;      call  heap_init 
924f			 
924f			      ; Make some allocations 
924f			;      ld    HL, 12 
924f			;      call  malloc            ; Allocates 0x9004 
924f			; 
924f			 ;     ld    HL, 12 
924f			;      call  malloc            ; Allocates 0x9014 
924f			 
924f			;      ld    HL, 12 
924f			;      call  malloc            ; Allocates 0x9024 
924f			 
924f			      ; Free some allocations 
924f			;      ld    HL, 0x9014 
924f			;      call  free 
924f			 
924f			;      ld    HL, 0x9004 
924f			;      call  free 
924f			; 
924f			;      ld    HL, 0x9024 
924f			;      call  free 
924f			 
924f			 
924f			 ;     halt 
924f			 
924f			 
924f			;------------------------------------------------------------------------------ 
924f			;     heap_init                                                               : 
924f			;                                                                             : 
924f			; Description                                                                 : 
924f			;     Initialise the heap and make it ready for malloc and free operations.   : 
924f			;                                                                             : 
924f			;     The heap is maintained as a linked list, starting with an initial       : 
924f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
924f			;     the first free block in the heap. Each block then points to the next    : 
924f			;     free block within the heap, and the free list ends at the first block   : 
924f			;     with a null pointer to the next free block.                             : 
924f			;                                                                             : 
924f			; Parameters                                                                  : 
924f			;     Inputs are compile-time only. Two defines which specify the starting    : 
924f			;     address of the heap and its size are required, along with a memory      : 
924f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
924f			;     principally stores a pointer to the first free block in the heap.       : 
924f			;                                                                             : 
924f			; Returns                                                                     : 
924f			;     Nothing                                                                 : 
924f			;------------------------------------------------------------------------------ 
924f			heap_init: 
924f			      push  HL 
924f			 
924f			      ; Initialise free list struct 
924f			      ld    HL, heap_start 
924f			      ld    (free_list), HL 
924f			      ld    HL, 0 
924f			      ld    (free_list+2), HL 
924f			 
924f			      ; Insert first free block at bottom of heap, consumes entire heap 
924f			      ld    HL, heap_start+heap_size-4 
924f			      ld    (heap_start), HL        ; Next block (end of free list) 
924f			      ld    HL, heap_size-4 
924f			      ld    (heap_start+2), HL      ; Block size 
924f			 
924f			      ; Insert end of free list block at top of heap - two null words will 
924f			      ; terminate the free list 
924f			      ld    HL, 0 
924f			      ld    (heap_start+heap_size-2), HL 
924f			      ld    (heap_start+heap_size-4), HL 
924f			 
924f			      pop   HL 
924f			 
924f			      ret 
924f			 
924f			 
924f			;------------------------------------------------------------------------------ 
924f			;     malloc                                                                  : 
924f			;                                                                             : 
924f			; Description                                                                 : 
924f			;     Allocates the wanted space from the heap and returns the address of the : 
924f			;     first useable byte of the allocation.                                   : 
924f			;                                                                             : 
924f			;     Allocations can happen in one of two ways:                              : 
924f			;                                                                             : 
924f			;     1. A free block may be found which is the exact size wanted. In this    : 
924f			;        case the block is removed from the free list and retuedn to the      : 
924f			;        caller.                                                              : 
924f			;     2. A free block may be found which is larger than the size wanted. In   : 
924f			;        this case, the larger block is split into two. The first portion of  : 
924f			;        this block will become the requested space by the malloc call and    : 
924f			;        is returned to the caller. The second portion becomes a new free     : 
924f			;        block, and the free list is adjusted to maintain continuity via this : 
924f			;        newly created block.                                                 : 
924f			;                                                                             : 
924f			;     malloc does not set any initial value in the allocated space, the       : 
924f			;     caller is required to do this as required.                              : 
924f			;                                                                             : 
924f			;     This implementation of malloc uses the stack exclusively, and is        : 
924f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
924f			;     advisable to disable interrupts before calling malloc, and recommended  : 
924f			;     to avoid the use of malloc inside ISRs in general.                      : 
924f			;                                                                             : 
924f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
924f			;                                                                             : 
924f			; Parameters                                                                  : 
924f			;     HL  Number of bytes wanted                                              : 
924f			;                                                                             : 
924f			; Returns                                                                     : 
924f			;     HL  Address of the first useable byte of the allocation                 : 
924f			;                                                                             : 
924f			; Flags                                                                       : 
924f			;     Z   Set if the allocation did not succeed, clear otherwise              : 
924f			;                                                                             : 
924f			; Stack frame                                                                 : 
924f			;       |             |                                                       : 
924f			;       +-------------+                                                       : 
924f			;       |     BC      |                                                       : 
924f			;       +-------------+                                                       : 
924f			;       |     DE      |                                                       : 
924f			;       +-------------+                                                       : 
924f			;       |     IX      |                                                       : 
924f			;       +-------------+                                                       : 
924f			;       |  prev_free  |                                                       : 
924f			;   +4  +-------------+                                                       : 
924f			;       |  this_free  |                                                       : 
924f			;   +2  +-------------+                                                       : 
924f			;       |  next_free  |                                                       : 
924f			;   +0  +-------------+                                                       : 
924f			;       |             |                                                       : 
924f			;                                                                             : 
924f			;------------------------------------------------------------------------------ 
924f			malloc: 
924f			      push  BC 
924f			      push  DE 
924f			      push  IX 
924f			 
924f			      ld    A, H                    ; Exit if no space requested 
924f			      or    L 
924f			      jp    Z, malloc_early_exit 
924f			 
924f			      ; Set up stack frame 
924f			      ex    DE, HL 
924f			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
924f			      add   HL, SP 
924f			      ld    SP, HL 
924f			      ld    IX, 0                   ; Use IX as a frame pointer 
924f			      add   IX, SP 
924f			 
924f			      ; Setup initial state 
924f			      ld    HL, 4                   ; want must also include space used by block struct 
924f			      add   HL, DE 
924f			 
924f			      ld    B, H                    ; Move want to BC 
924f			      ld    C, L 
924f			 
924f			      ld    HL, free_list           ; Store prev_free ptr to stack 
924f			      ld    (IX+4), L 
924f			      ld    (IX+5), H 
924f			 
924f			      ld    E, (HL)                 ; Store this_free ptr to stack 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			      ld    (IX+2), E 
924f			      ld    (IX+3), D 
924f			      ex    DE, HL                  ; this_free ptr into HL 
924f			 
924f			      ; Loop through free block list to find some space 
924f			malloc_find_space: 
924f			      ld    E, (HL)                 ; Load next_free ptr into DE 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			 
924f			      ld    A, D                    ; Check for null next_free ptr - end of free list 
924f			      or    E 
924f			      jp    Z, malloc_no_space 
924f			 
924f			      ld    (IX+0), E               ; Store next_free ptr to stack 
924f			      ld    (IX+1), D 
924f			 
924f			      ; Does this block have enough space to make the allocation? 
924f			      inc   HL                      ; Load free block size into DE 
924f			      ld    E, (HL) 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			 
924f			      ex    DE, HL                  ; Check size of block against want 
924f			      or    A                       ; Ensure carry flag clear 
924f			      sbc   HL, BC 
924f			      push  HL                      ; Store the result for later (new block size) 
924f			 
924f			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
924f			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
924f			 
924f			      ; this_free block is not big enough, setup ptrs to test next free block 
924f			      pop   HL                      ; Discard previous result 
924f			 
924f			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
924f			      ld    H, (IX+3) 
924f			      ld    (IX+4), L 
924f			      ld    (IX+5), H 
924f			 
924f			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
924f			      ld    H, (IX+1) 
924f			      ld    (IX+2), L 
924f			      ld    (IX+3), H 
924f			 
924f			      jr    malloc_find_space 
924f			 
924f			      ; split a bigger block into two - requested size and remaining size 
924f			malloc_alloc_split: 
924f			      ex    DE, HL                  ; Calculate address of new free block 
924f			      dec   HL 
924f			      dec   HL 
924f			      dec   HL 
924f			      add   HL, BC 
924f			 
924f			      ; Create a new block and point it at next_free 
924f			      ld    E, (IX+0)               ; Load next_free ptr into DE 
924f			      ld    D, (IX+1) 
924f			 
924f			      ld    (HL), E                 ; Store next_free ptr into new block 
924f			      inc   HL 
924f			      ld    (HL), D 
924f			 
924f			      pop   DE                      ; Store size of new block into new block 
924f			      inc   HL 
924f			      ld    (HL), E 
924f			      inc   HL 
924f			      ld    (HL), D 
924f			 
924f			      ; Update this_free ptr to point to new block 
924f			      dec   HL 
924f			      dec   HL 
924f			      dec   HL 
924f			 
924f			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
924f			      ld    D, (IX+3) 
924f			 
924f			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
924f			      ld    (IX+3), H 
924f			 
924f			      ; Modify this_free block to be allocation 
924f			      ex    DE, HL 
924f			      xor   A                       ; Null the next block ptr of allocated block 
924f			      ld    (HL), A 
924f			      inc   HL 
924f			      ld    (HL), A 
924f			 
924f			      inc   HL                      ; Store want size into allocated block 
924f			      ld    (HL), C 
924f			      inc   HL 
924f			      ld    (HL), B 
924f			      inc   HL 
924f			      push  HL                      ; Address of allocation to return 
924f			 
924f			      jr    malloc_update_links 
924f			 
924f			malloc_alloc_fit: 
924f			      pop   HL                      ; Dont need new block size, want is exact fit 
924f			 
924f			      ; Modify this_free block to be allocation 
924f			      ex    DE, HL 
924f			      dec   HL 
924f			      dec   HL 
924f			      dec   HL 
924f			 
924f			      xor   A                       ; Null the next block ptr of allocated block 
924f			      ld    (HL), A 
924f			      inc   HL 
924f			      ld    (HL), A 
924f			 
924f			      inc   HL                      ; Store address of allocation to return 
924f			      inc   HL 
924f			      inc   HL 
924f			      push  HL 
924f			 
924f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
924f			      ld    L, (IX+0)               ; next_free to HL 
924f			      ld    H, (IX+1) 
924f			 
924f			      ld    (IX+2), L               ; HL to this_free 
924f			      ld    (IX+3), H 
924f			 
924f			 
924f			malloc_update_links: 
924f			      ; Update prev_free ptr to point to this_free 
924f			      ld    L, (IX+4)               ; prev_free ptr to HL 
924f			      ld    H, (IX+5) 
924f			 
924f			      ld    E, (IX+2)               ; this_free ptr to DE 
924f			      ld    D, (IX+3) 
924f			 
924f			      ld    (HL), E                 ; this_free ptr into prev_free 
924f			      inc   HL 
924f			      ld    (HL), D 
924f			 
924f			      ; Clear the Z flag to indicate successful allocation 
924f			      ld    A, D 
924f			      or    E 
924f			 
924f			      pop   DE                      ; Address of allocation 
924f			 
924f			malloc_no_space: 
924f			      ld    HL, 6                   ; Clean up stack frame 
924f			      add   HL, SP 
924f			      ld    SP, HL 
924f			 
924f			      ex    DE, HL                  ; Alloc addr into HL for return 
924f			 
924f			malloc_early_exit: 
924f			      pop   IX 
924f			      pop   DE 
924f			      pop   BC 
924f			 
924f			      ret 
924f			 
924f			 
924f			;------------------------------------------------------------------------------ 
924f			;     free                                                                    : 
924f			;                                                                             : 
924f			; Description                                                                 : 
924f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
924f			;     returned by malloc, otherwise the behaviour is undefined.               : 
924f			;                                                                             : 
924f			;     Where possible, directly adjacent free blocks will be merged together   : 
924f			;     into larger blocks to help ensure that the heap does not become         : 
924f			;     excessively fragmented.                                                 : 
924f			;                                                                             : 
924f			;     free does not clear or set any other value into the freed space, and    : 
924f			;     therefore its contents may be visible through subsequent malloc's. The  : 
924f			;     caller should clear the freed space as required.                        : 
924f			;                                                                             : 
924f			;     This implementation of free uses the stack exclusively, and is          : 
924f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
924f			;     advisable to disable interrupts before calling free, and recommended    : 
924f			;     to avoid the use of free inside ISRs in general.                        : 
924f			;                                                                             : 
924f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
924f			;                                                                             : 
924f			; Parameters                                                                  : 
924f			;     HL  Pointer to address of first byte of allocation to be freed          : 
924f			;                                                                             : 
924f			; Returns                                                                     : 
924f			;     Nothing                                                                 : 
924f			;                                                                             : 
924f			; Stack frame                                                                 : 
924f			;       |             |                                                       : 
924f			;       +-------------+                                                       : 
924f			;       |     BC      |                                                       : 
924f			;       +-------------+                                                       : 
924f			;       |     DE      |                                                       : 
924f			;       +-------------+                                                       : 
924f			;       |     IX      |                                                       : 
924f			;       +-------------+                                                       : 
924f			;       |  prev_free  |                                                       : 
924f			;   +2  +-------------+                                                       : 
924f			;       |  next_free  |                                                       : 
924f			;   +0  +-------------+                                                       : 
924f			;       |             |                                                       : 
924f			;                                                                             : 
924f			;------------------------------------------------------------------------------ 
924f			free: 
924f			      push  BC 
924f			      push  DE 
924f			      push  IX 
924f			 
924f			      ld    A, H                    ; Exit if ptr is null 
924f			      or    L 
924f			      jp    Z, free_early_exit 
924f			 
924f			      ; Set up stack frame 
924f			      ex    DE, HL 
924f			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
924f			      add   HL, SP 
924f			      ld    SP, HL 
924f			      ld    IX, 0                   ; Use IX as a frame pointer 
924f			      add   IX, SP 
924f			 
924f			      ; The address in HL points to the start of the useable allocated space, 
924f			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
924f			      ; address of the block itself. 
924f			      ex    DE, HL 
924f			      ld    DE, -4 
924f			      add   HL, DE 
924f			 
924f			      ; An allocated block must have a null next block pointer in it 
924f			      ld    A, (HL) 
924f			      inc   HL 
924f			      or    (HL) 
924f			      jp    NZ, free_done 
924f			 
924f			      dec   HL 
924f			 
924f			      ld    B, H                    ; Copy HL to BC 
924f			      ld    C, L 
924f			 
924f			      ; Loop through the free list to find the first block with an address 
924f			      ; higher than the block being freed 
924f			      ld    HL, free_list 
924f			 
924f			free_find_higher_block: 
924f			      ld    E, (HL)                 ; Load next ptr from free block 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			      dec   HL 
924f			 
924f			      ld    (IX+0), E               ; Save ptr to next free block 
924f			      ld    (IX+1), D 
924f			      ld    (IX+2), L               ; Save ptr to prev free block 
924f			      ld    (IX+3), H 
924f			 
924f			      ld    A, B                    ; Check if DE is greater than BC 
924f			      cp    D                       ; Compare MSB first 
924f			      jr    Z, $+4                  ; MSB the same, compare LSB 
924f			      jr    NC, free_find_higher_block_skip 
924f			      ld    A, C 
924f			      cp    E                       ; Then compare LSB 
924f			      jr    C, free_found_higher_block 
924f			 
924f			free_find_higher_block_skip: 
924f			      ld    A, D                    ; Reached the end of the free list? 
924f			      or    E 
924f			      jp    Z, free_done 
924f			 
924f			      ex    DE, HL 
924f			 
924f			      jr    free_find_higher_block 
924f			 
924f			free_found_higher_block: 
924f			      ; Insert freed block between prev and next free blocks 
924f			      ld    (HL), C                 ; Point prev free block to freed block 
924f			      inc   HL 
924f			      ld    (HL), B 
924f			 
924f			      ld    H, B                    ; Point freed block at next free block 
924f			      ld    L, C 
924f			      ld    (HL), E 
924f			      inc   HL 
924f			      ld    (HL), D 
924f			 
924f			      ; Check if the freed block is adjacent to the next free block 
924f			      inc   HL                      ; Load size of freed block into HL 
924f			      ld    E, (HL) 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			      ex    DE, HL 
924f			 
924f			      add   HL, BC                  ; Add addr of freed block and its size 
924f			 
924f			      ld    E, (IX+0)               ; Load addr of next free block into DE 
924f			      ld    D, (IX+1) 
924f			 
924f			      or    A                       ; Clear the carry flag 
924f			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
924f			      jr    NZ, free_check_adjacent_to_prev 
924f			 
924f			      ; Freed block is adjacent to next, merge into one bigger block 
924f			      ex    DE, HL                  ; Load next ptr from next block into DE 
924f			      ld    E, (HL) 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			      push  HL                      ; Save ptr to next block for later 
924f			 
924f			      ld    H, B                    ; Store ptr from next block into freed block 
924f			      ld    L, C 
924f			      ld    (HL), E 
924f			      inc   HL 
924f			      ld    (HL), D 
924f			 
924f			      pop   HL                      ; Restore ptr to next block 
924f			      inc   HL                      ; Load size of next block into DE 
924f			      ld    E, (HL) 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			      push  DE                      ; Save next block size for later 
924f			 
924f			      ld    H, B                    ; Load size of freed block into HL 
924f			      ld    L, C 
924f			      inc   HL 
924f			      inc   HL 
924f			      ld    E, (HL) 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			      ex    DE, HL 
924f			 
924f			      pop   DE                      ; Restore size of next block 
924f			      add   HL, DE                  ; Add sizes of both blocks 
924f			      ex    DE, HL 
924f			 
924f			      ld    H, B                    ; Store new bigger size into freed block 
924f			      ld    L, C 
924f			      inc   HL 
924f			      inc   HL 
924f			      ld    (HL), E 
924f			      inc   HL 
924f			      ld    (HL), D 
924f			 
924f			free_check_adjacent_to_prev: 
924f			      ; Check if the freed block is adjacent to the prev free block 
924f			      ld    L, (IX+2)               ; Prev free block ptr into HL 
924f			      ld    H, (IX+3) 
924f			 
924f			      inc   HL                      ; Size of prev free block into DE 
924f			      inc   HL 
924f			      ld    E, (HL) 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			      dec   HL 
924f			      dec   HL 
924f			      dec   HL 
924f			 
924f			      add   HL, DE                  ; Add prev block addr and size 
924f			 
924f			      or    A                       ; Clear the carry flag 
924f			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
924f			      jr    NZ, free_done 
924f			 
924f			      ; Freed block is adjacent to prev, merge into one bigger block 
924f			      ld    H, B                    ; Load next ptr from freed block into DE 
924f			      ld    L, C 
924f			      ld    E, (HL) 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			      push  HL                      ; Save freed block ptr for later 
924f			 
924f			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
924f			      ld    H, (IX+3) 
924f			      ld    (HL), E 
924f			      inc   HL 
924f			      ld    (HL), D 
924f			 
924f			      pop   HL                      ; Restore freed block ptr 
924f			      inc   HL                      ; Load size of freed block into DE 
924f			      ld    E, (HL) 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			      push  DE                      ; Save freed block size for later 
924f			 
924f			      ld    L, (IX+2)               ; Load size of prev block into DE 
924f			      ld    H, (IX+3) 
924f			      inc   HL 
924f			      inc   HL 
924f			      ld    E, (HL) 
924f			      inc   HL 
924f			      ld    D, (HL) 
924f			 
924f			      pop   HL                      ; Add sizes of both blocks 
924f			      add   HL, DE 
924f			      ex    DE, HL 
924f			 
924f			      ld    L, (IX+2)               ; Store new bigger size into prev block 
924f			      ld    H, (IX+3) 
924f			      inc   HL 
924f			      inc   HL 
924f			      ld    (HL), E 
924f			      inc   HL 
924f			      ld    (HL), D 
924f			 
924f			free_done: 
924f			      ld    HL, 4                   ; Clean up stack frame 
924f			      add   HL, SP 
924f			      ld    SP, HL 
924f			 
924f			free_early_exit: 
924f			      pop   IX 
924f			      pop   DE 
924f			      pop   BC 
924f			 
924f			      ret 
924f			 
924f			 
924f			;      .org 0x8000 
924f			; 
924f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
924f			 ;                 .dw   0 
924f			 
924f			endif 
924f			 
924f			 
924f			if MALLOC_4 
924f			 
924f			; My memory allocation code. Very very simple.... 
924f			; allocate space under 250 chars 
924f			 
924f			heap_init: 
924f				; init start of heap as zero 
924f				;  
924f			 
924f				ld hl, heap_start 
924f				ld a, 0 
924f				ld (hl), a      ; empty block 
924f				inc hl 
924f				ld a, 0 
924f				ld (hl), a      ; length of block 
924f				; write end of list 
924f				inc hl 
924f				ld a,(hl) 
924f				inc hl 
924f				ld a,(hl) 
924f				 
924f			 
924f				; init some malloc vars 
924f			 
924f				ld hl, 0 
924f				ld (free_list), hl       ; store last malloc location 
924f			 
924f				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
924f				ld a, 0 
924f				ld (hl), a 
924f			 
924f			 
924f				ld hl, heap_start 
924f				;  
924f				  
924f				ret 
924f			 
924f			 
924f			;    free block marker 
924f			;    requested size  
924f			;    pointer to next block 
924f			;    .... 
924f			;    next block marker 
924f			 
924f			 
924f			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
924f			; 
924f			 
924f			 
924f			malloc:  
924f				push de 
924f				push bc 
924f				push af 
924f			 
924f				; hl space required 
924f				 
924f				ld c, l    ; hold space   (TODO only a max of 255) 
924f			 
924f			;	inc c     ; TODO BUG need to fix memory leak on push str 
924f			;	inc c 
924f			;	inc c 
924f			;	inc c 
924f			;	inc c 
924f			;	inc c 
924f			;	inc c 
924f			 
924f			 
924f			 
924f				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
924f			 
924f				ld a, (free_list+3) 
924f				cp 0 
924f				jr z, .contheap 
924f			 
924f				ld hl, (free_list)     ; get last alloc 
924f					if DEBUG_FORTH_MALLOC_INT 
924f						DMARK "mrs" 
924f						CALLMONITOR 
924f					endif 
924f				jr .startalloc 
924f			 
924f			.contheap: 
924f				ld hl, heap_start 
924f			 
924f			.startalloc: 
924f			 
924f					if DEBUG_FORTH_MALLOC_INT 
924f						DMARK "mym" 
924f						CALLMONITOR 
924f					endif 
924f			.findblock: 
924f					if DEBUG_FORTH_MALLOC_INT 
924f						DMARK "mmf" 
924f						CALLMONITOR 
924f					endif 
924f			 
924f				ld a,(hl)  
924f				; if byte is zero then clear to use 
924f			 
924f				cp 0 
924f				jr z, .foundemptyblock 
924f			 
924f				; if byte is not clear 
924f				;     then byte is offset to next block 
924f			 
924f				inc hl 
924f				ld a, (hl) ; get size 
924f			.nextblock:	inc hl 
924f					ld e, (hl) 
924f					inc hl 
924f					ld d, (hl) 
924f					ex de, hl 
924f			;	inc hl  ; move past the store space 
924f			;	inc hl  ; move past zero index  
924f			 
924f				; TODO detect no more space 
924f			 
924f				push hl 
924f				ld de, heap_end 
924f				call cmp16 
924f				pop hl 
924f				jr nc, .nospace 
924f			 
924f				jr .findblock 
924f			 
924f			.nospace: ld hl, 0 
924f				jp .exit 
924f			 
924f			 
924f			.foundemptyblock:	 
924f					if DEBUG_FORTH_MALLOC_INT 
924f						DMARK "mme" 
924f						CALLMONITOR 
924f					endif 
924f			 
924f			; TODO has block enough space if reusing??? 
924f			 
924f				;  
924f			 
924f			; see if this block has been previously used 
924f				inc hl 
924f				ld a, (hl) 
924f				dec hl 
924f				cp 0 
924f				jr z, .newblock 
924f			 
924f					if DEBUG_FORTH_MALLOC_INT 
924f						DMARK "meR" 
924f						CALLMONITOR 
924f					endif 
924f			 
924f			; no reusing previously allocated block 
924f			 
924f			; is it smaller than previously used? 
924f				 
924f				inc hl    ; move to size 
924f				ld a, c 
924f				sub (hl)        ; we want c < (hl) 
924f				dec hl    ; move back to marker 
924f			        jr z, .findblock 
924f			 
924f				; update with the new size which should be lower 
924f			 
924f			        ;inc  hl   ; negate next move. move back to size  
924f			 
924f			.newblock: 
924f				; need to be at marker here 
924f			 
924f					if DEBUG_FORTH_MALLOC_INT 
924f						DMARK "meN" 
924f						CALLMONITOR 
924f					endif 
924f			 
924f			 
924f				ld a, c 
924f			 
924f				ld (free_list+3), a	 ; flag resume from last malloc  
924f				ld (free_list), hl    ; save out last location 
924f			 
924f			 
924f				;inc a     ; space for length byte 
924f				ld (hl), a     ; save block in use marker 
924f			 
924f				inc hl   ; move to space marker 
924f				ld (hl), a    ; save new space 
924f			 
924f				inc hl   ; move to start of allocated area 
924f				 
924f			;	push hl     ; save where we are - 1  
924f			 
924f			;	inc hl  ; move past zero index  
924f				; skip space to set down new marker 
924f			 
924f				; provide some extra space for now 
924f			 
924f				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
924f				inc a 
924f				inc a 
924f			 
924f				push hl   ; save where we are in the node block 
924f			 
924f				call addatohl 
924f			 
924f				; write linked list point 
924f			 
924f				pop de     ; get our node position 
924f				ex de, hl 
924f			 
924f				ld (hl), e 
924f				inc hl 
924f				ld (hl), d 
924f			 
924f				inc hl 
924f			 
924f				; now at start of allocated data so save pointer 
924f			 
924f				push hl 
924f			 
924f				; jump to position of next node and setup empty header in DE 
924f			 
924f				ex de, hl 
924f			 
924f			;	inc hl ; move past end of block 
924f			 
924f				ld a, 0 
924f				ld (hl), a   ; empty marker 
924f				inc hl 
924f				ld (hl), a   ; size 
924f				inc hl  
924f				ld (hl), a   ; ptr 
924f				inc hl 
924f				ld (hl), a   ; ptr 
924f			 
924f			 
924f				pop hl 
924f			 
924f					if DEBUG_FORTH_MALLOC_INT 
924f						DMARK "mmr" 
924f						CALLMONITOR 
924f					endif 
924f			 
924f			.exit: 
924f				pop af 
924f				pop bc 
924f				pop de  
924f				ret 
924f			 
924f			 
924f			 
924f			 
924f			free:  
924f				push hl 
924f				push af 
924f				; get address in hl 
924f			 
924f					if DEBUG_FORTH_MALLOC_INT 
924f						DMARK "fre" 
924f						CALLMONITOR 
924f					endif 
924f				; data is at hl - move to block count 
924f				dec hl 
924f				dec hl    ; get past pointer 
924f				dec hl 
924f			 
924f				ld a, (hl)    ; need this for a validation check 
924f			 
924f				dec hl    ; move to block marker 
924f			 
924f				; now check that the block count and block marker are the same  
924f			        ; this checks that we are on a malloc node and not random memory 
924f			        ; OK a faint chance this could be a problem but rare - famous last words! 
924f			 
924f				ld c, a 
924f				ld a, (hl)    
924f			 
924f				cp c 
924f				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
924f			 
924f				; yes good chance we are on a malloc node 
924f			 
924f				ld a, 0      
924f				ld (hl), a   ; mark as free 
924f			 
924f				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
924f			 
924f			.freeignore:  
924f			 
924f				pop af 
924f				pop hl 
924f			 
924f				ret 
924f			 
924f			 
924f			 
924f			endif 
924f			 
924f			; eof 
# End of file firmware_memory.asm
924f			  
924f			; device C  
924f			; Now handled by SPI  
924f			;if SOUND_ENABLE  
924f			;	include "firmware_sound.asm"  
924f			;endif  
924f			  
924f			include "firmware_diags.asm"  
924f			; Hardware diags menu 
924f			 
924f			 
924f			config: 
924f			 
924f 3e 00			ld a, 0 
9251 21 75 92			ld hl, .configmn 
9254 cd df 8a			call menu 
9257			 
9257 fe 00			cp 0 
9259 c8				ret z 
925a			 
925a			;	cp 1 
925a			;	call z, .savetostore 
925a			 
925a fe 01			cp 1 
925c			if STARTUP_V1 
925c cc 8b 92			call z, .selautoload 
925f			endif 
925f			 
925f			if STARTUP_V2 
925f				call z, .enautoload 
925f			endif 
925f fe 02			cp 2 
9261 cc 81 92			call z, .disautoload 
9264			;	cp 3 
9264			;	call z, .selbank 
9264 fe 03			cp 3 
9266 cc a9 92			call z, .debug_tog 
9269 fe 04			cp 4 
926b cc f7 93			call z, .bpsgo 
926e fe 05			cp 5 
9270 cc d2 92			call z, hardware_diags 
9273			if STARTUP_V2 
9273				cp 6 
9273				call z, create_startup 
9273			endif 
9273 18 da			jr config 
9275			 
9275			.configmn: 
9275			;	dw prom_c3 
9275 e5 95			dw prom_c2 
9277 fa 95			dw prom_c2a 
9279			;	dw prom_c2b 
9279			;	dw prom_c4 
9279 19 96			dw prom_m4 
927b 34 96			dw prom_m4b 
927d 3c 96			dw prom_c1 
927f			if STARTUP_V2 
927f				dw prom_c9 
927f			endif 
927f 00 00			dw 0 
9281				 
9281			 
9281			if STARTUP_V2 
9281			.enautoload: 
9281				if STORAGE_SE 
9281				ld a, $fe      ; bit 0 clear 
9281				ld (spi_device), a 
9281			 
9281				call storage_get_block_0 
9281			 
9281				ld a, 1 
9281				ld (store_page+STORE_0_AUTOFILE), a 
9281			 
9281					ld hl, 0 
9281					ld de, store_page 
9281				call storage_write_block	 ; save update 
9281				else 
9281			 
9281				ld hl, prom_notav 
9281				ld de, prom_empty 
9281				call info_panel 
9281				endif 
9281			 
9281			 
9281				ret 
9281			endif 
9281			 
9281			.disautoload: 
9281				if STORAGE_SE 
9281				ld a, $fe      ; bit 0 clear 
9281				ld (spi_device), a 
9281			 
9281				call storage_get_block_0 
9281			 
9281				ld a, 0 
9281				ld (store_page+STORE_0_AUTOFILE), a 
9281			 
9281					ld hl, 0 
9281					ld de, store_page 
9281				call storage_write_block	 ; save update 
9281				else 
9281			 
9281 21 4b 96			ld hl, prom_notav 
9284 11 61 96			ld de, prom_empty 
9287 cd 3f 8a			call info_panel 
928a				endif 
928a			 
928a			 
928a c9				ret 
928b			 
928b			if STARTUP_V1 
928b			 
928b			; Select auto start 
928b			 
928b			.selautoload: 
928b			 
928b				 
928b				if STORAGE_SE 
928b			 
928b					call config_dir 
928b				        ld hl, scratch 
928b					ld a, 0 
928b					call menu 
928b			 
928b					cp 0 
928b					ret z 
928b			 
928b					dec a 
928b			 
928b			 
928b					; locate menu option 
928b			 
928b					ld hl, scratch 
928b					call table_lookup 
928b			 
928b					if DEBUG_FORTH_WORDS 
928b						DMARK "ALl" 
928b						CALLMONITOR 
928b					endif 
928b					; with the pointer to the menu it, the byte following the zero term is the file id 
928b			 
928b					ld a, 0 
928b					ld bc, 50   ; max of bytes to look at 
928b					cpir  
928b			 
928b					if DEBUG_FORTH_WORDS 
928b						DMARK "ALb" 
928b						CALLMONITOR 
928b					endif 
928b					;inc hl 
928b			 
928b					ld a, (hl)   ; file id 
928b					 
928b				        ; save bank and file ids 
928b			 
928b					push af 
928b			 
928b			; TODO need to save to block 0 on bank 1	 
928b			 
928b					call storage_get_block_0 
928b			 
928b					if DEBUG_FORTH_WORDS 
928b						DMARK "AL0" 
928b						CALLMONITOR 
928b					endif 
928b					pop af 
928b			 
928b					ld (store_page+STORE_0_FILERUN),a 
928b					 
928b					; save bank id 
928b			 
928b					ld a,(spi_device) 
928b					ld (store_page+STORE_0_BANKRUN),a 
928b			 
928b					; enable auto run of store file 
928b			 
928b					ld a, 1 
928b					ld (store_page+STORE_0_AUTOFILE),a 
928b			 
928b					; save buffer 
928b			 
928b					ld hl, 0 
928b					ld de, store_page 
928b					if DEBUG_FORTH_WORDS 
928b						DMARK "ALw" 
928b						CALLMONITOR 
928b					endif 
928b				call storage_write_block	 ; save update 
928b			  
928b			 
928b			 
928b			 
928b					ld hl, scratch 
928b					call config_fdir 
928b			 
928b				else 
928b			 
928b 21 4b 96			ld hl, prom_notav 
928e 11 61 96			ld de, prom_empty 
9291 cd 3f 8a			call info_panel 
9294			 
9294				endif 
9294 c9				ret 
9295			endif 
9295			 
9295			 
9295			; Select storage bank 
9295			 
9295			.selbank: 
9295			 
9295			;	if STORAGE_SE 
9295			;	else 
9295			 
9295 21 4b 96			ld hl, prom_notav 
9298 11 61 96			ld de, prom_empty 
929b cd 3f 8a			call info_panel 
929e			;	endif 
929e				 
929e c9				ret 
929f			 
929f			if STORAGE_SE 
929f			 
929f			.config_ldir:   
929f				; Load storage bank labels into menu array 
929f			 
929f				 
929f			 
929f			 
929f				ret 
929f			 
929f			 
929f			endif 
929f			 
929f			 
929f			; Save user words to storage 
929f			 
929f			.savetostore: 
929f			 
929f			;	if STORAGE_SE 
929f			; 
929f			;		call config_dir 
929f			;	        ld hl, scratch 
929f			;		ld a, 0 
929f			;		call menu 
929f			;		 
929f			;		ld hl, scratch 
929f			;		call config_fdir 
929f			; 
929f			;	else 
929f			 
929f 21 4b 96			ld hl, prom_notav 
92a2 11 61 96			ld de, prom_empty 
92a5 cd 3f 8a			call info_panel 
92a8			 
92a8			;	endif 
92a8			 
92a8 c9				ret 
92a9			 
92a9			if STARTUP_V2 
92a9			 
92a9			create_startup: 
92a9			 
92a9				ld a, 0 
92a9				ld hl, .crstart 
92a9				call menu 
92a9			 
92a9				cp 0 
92a9				ret z 
92a9			 
92a9				cp 1 
92a9				call z, .genlsword 
92a9				cp 2 
92a9				call z, .genedword 
92a9			 
92a9				cp 3 
92a9				call z, .gendemword 
92a9			 
92a9				cp 4 
92a9				call z, .genutlword 
92a9				cp 5 
92a9				call z, .genspiword 
92a9				cp 6 
92a9				call z, .genkeyword 
92a9				cp 7 
92a9				call z, .gensoundword 
92a9				cp 7 
92a9				call z, .genhwword 
92a9				jr create_startup 
92a9			 
92a9			.genhwword: 
92a9				ld hl, crs_hw 
92a9				ld de, .hwworddef 
92a9				call .genfile 
92a9				ret 
92a9			.gensoundword: 
92a9				ld hl, crs_sound 
92a9				ld de, .soundworddef 
92a9				call .genfile 
92a9				ret 
92a9			.genlsword: 
92a9				ld hl, crs_s1 
92a9				ld de, .lsworddef 
92a9				call .genfile 
92a9				ret 
92a9			 
92a9			.genedword: 
92a9				ld de, .edworddef 
92a9				ld hl, crs_s2 
92a9				call .genfile 
92a9				ret 
92a9			 
92a9			.gendemword: 
92a9				ld de, .demoworddef 
92a9				ld hl, crs_s3 
92a9				call .genfile 
92a9				ret 
92a9			 
92a9			.genutlword: 
92a9				ld hl, crs_s4 
92a9				ld de, .utilwordef 
92a9				call .genfile 
92a9				ret 
92a9			.genspiword: 
92a9				ld hl, crs_s5 
92a9				ld de, .spiworddef 
92a9				call .genfile 
92a9				ret 
92a9			.genkeyword: 
92a9				ld hl, crs_s6 
92a9				ld de, .keyworddef 
92a9				call .genfile 
92a9				ret 
92a9			 
92a9			; hl - points to file name 
92a9			; de - points to strings to add to file 
92a9			 
92a9			.genfile: 
92a9				push hl 
92a9				push de 
92a9			 
92a9				call clear_display 
92a9				ld a, display_row_1 
92a9				ld de, .genfiletxt 
92a9				call str_at_display 
92a9				call update_display 
92a9			 
92a9				pop de 
92a9				pop hl 
92a9			 
92a9			 
92a9				push de 
92a9				call storage_create 
92a9				; id in hl 
92a9				pop de   ; table of strings to add 
92a9			 
92a9			.genloop: 
92a9			 
92a9				push hl ; save id for next time around 
92a9				push de ; save de for next time around 
92a9			 
92a9				ex de, hl 
92a9				call loadwordinhl 
92a9				ex de, hl 
92a9			 
92a9				; need hl to be the id 
92a9				; need de to be the string ptr 
92a9				 
92a9				call storage_append 
92a9			 
92a9				pop de 
92a9				pop hl 
92a9			 
92a9				inc de 
92a9				inc de 
92a9			 
92a9				ld a,(de) 
92a9				cp 0 
92a9				jr nz, .genloop 
92a9				inc de 
92a9				ld a, (de) 
92a9				dec de 
92a9				cp 0 
92a9				jr nz, .genloop	 
92a9			 
92a9				ret 
92a9			 
92a9			.genfiletxt:  db "Creating file...",0 
92a9			 
92a9			.hwworddef: 
92a9				dw test5 
92a9				dw test6 
92a9				dw test7 
92a9				dw test8 
92a9				dw test9 
92a9				dw test10 
92a9				dw 0 
92a9			 
92a9			.soundworddef: 
92a9				dw sound1 
92a9				dw sound2 
92a9				dw sound3 
92a9				dw sound4 
92a9				dw sound5 
92a9				dw sound6 
92a9				dw sound7 
92a9				dw sound8 
92a9				dw sound9 
92a9				dw 0 
92a9			 
92a9			.utilwordef: 
92a9				dw strncpy 
92a9				dw type 
92a9				dw clrstack 
92a9				dw longread 
92a9				dw start1 
92a9				dw start2 
92a9			; duplicated 
92a9			;	dw start3b 
92a9			;	dw start3c 
92a9				dw list 
92a9				dw 0 
92a9			 
92a9			.lsworddef: 
92a9				dw start3b 
92a9				dw 0 
92a9			 
92a9			.edworddef: 
92a9				dw edit1 
92a9				dw edit2 
92a9				dw edit3 
92a9				dw 0 
92a9			 
92a9			.demoworddef: 
92a9				dw game1 
92a9				dw game1a 
92a9				dw game1b 
92a9				dw game1c 
92a9				dw game1d 
92a9				dw game1s 
92a9				dw game1t 
92a9				dw game1f 
92a9				dw game1z 
92a9				dw game1zz 
92a9				dw ssv2 
92a9				dw ssv3 
92a9				dw ssv4 
92a9				dw ssv5 
92a9				dw ssv1 
92a9				dw ssv1cpm	 
92a9			;	dw game2b 
92a9			;	dw game2bf 
92a9			;	dw game2mba 
92a9			;	dw game2mbas	 
92a9			;	dw game2mbht 
92a9			;	dw game2mbms 
92a9			;	dw game2mb 
92a9			;	dw game3w 
92a9			;	dw game3p 
92a9			;	dw game3sc 
92a9			;	dw game3vsi 
92a9			;	dw game3vs 
92a9				dw 0 
92a9			 
92a9			 
92a9			.spiworddef: 
92a9			 
92a9			    dw spi1 
92a9			    dw spi2 
92a9			    dw spi2b 
92a9			    dw spi3 
92a9			    dw spi4 
92a9			    dw spi5 
92a9			;    dw spi6 
92a9			;    dw spi7 
92a9			 
92a9			;    dw spi8 
92a9			;    dw spi9 
92a9			;    dw spi10 
92a9			    dw 0 
92a9			 
92a9			.keyworddef: 
92a9			 
92a9				dw keyup 
92a9				dw keydown 
92a9				dw keyleft 
92a9				dw keyright 
92a9				dw 	keyf1 
92a9				dw keyf2 
92a9				dw keyf3 
92a9				dw keyf4 
92a9				dw keyf5 
92a9				dw keyf6 
92a9				dw keyf7 
92a9				dw keyf8 
92a9				dw keyf9 
92a9				dw keyf10 
92a9				dw keyf11 
92a9				dw keyf12 
92a9				dw keytab 
92a9				dw keycr 
92a9				dw keyhome 
92a9				dw keyend 
92a9				dw keybs 
92a9				dw 0 
92a9			 
92a9			.crstart: 
92a9				dw crs_s1 
92a9				dw crs_s2 
92a9				dw crs_s3 
92a9				dw crs_s4 
92a9				dw crs_s5 
92a9				dw crs_s6 
92a9				dw crs_sound 
92a9				dw crs_hw 
92a9				dw 0 
92a9			 
92a9			endif 
92a9			 
92a9			 
92a9			if STORAGE_SE 
92a9			 
92a9			config_fdir: 
92a9				; using the scratch dir go through and release the memory allocated for each string 
92a9				 
92a9				ld hl, scratch 
92a9			.cfdir:	ld e,(hl) 
92a9				inc hl 
92a9				ld d,(hl) 
92a9				inc hl 
92a9			 
92a9				ex de, hl 
92a9				call ishlzero 
92a9				ret z     ; return on null pointer 
92a9				call free 
92a9				ex de, hl 
92a9				jr .cfdir 
92a9			 
92a9			 
92a9				ret 
92a9			 
92a9			 
92a9			config_dir: 
92a9			 
92a9				; for the config menus that need to build a directory of storage call this routine 
92a9				; it will construct a menu in scratch to pass to menu 
92a9			 
92a9				; open storage device 
92a9			 
92a9				; execute DIR to build a list of files and their ids into scratch in menu format 
92a9				; once the menu has finished then will need to call config_fdir to release the strings 
92a9				 
92a9				; c = number items 
92a9			 
92a9				 
92a9				call storage_get_block_0 
92a9			 
92a9				ld hl, store_page     ; get current id count 
92a9				ld b, (hl) 
92a9				ld c, 0    ; count of files   
92a9			 
92a9			 
92a9				ld hl, scratch 
92a9				ld (store_tmp2), hl    ; location to poke strings 
92a9			 
92a9				; check for empty drive 
92a9			 
92a9				ld a, 0 
92a9				cp b 
92a9				jp z, .dirdone 
92a9			 
92a9				 
92a9					if DEBUG_FORTH_WORDS 
92a9						DMARK "Cdc" 
92a9						CALLMONITOR 
92a9					endif 
92a9			 
92a9			 
92a9			.diritem:	 
92a9				push bc 
92a9				; for each of the current ids do a search for them and if found push to stack 
92a9			 
92a9					ld hl, STORE_BLOCK_PHY 
92a9					ld d, 0		 ; look for extent 0 of block id as this contains file name 
92a9					ld e,b 
92a9			 
92a9					call storage_findnextid 
92a9			 
92a9			 
92a9					; if found hl will be non zero 
92a9			 
92a9					call ishlzero 
92a9					jr z, .dirnotfound 
92a9			 
92a9					; increase count 
92a9			 
92a9					pop bc	 
92a9					inc c 
92a9					push bc 
92a9					 
92a9			 
92a9					; get file header and push the file name 
92a9			 
92a9					ld de, store_page 
92a9					call storage_read_block 
92a9			 
92a9					; push file id to stack 
92a9				 
92a9					ld a, (store_page) 
92a9					ld h, 0 
92a9					ld l, a 
92a9			 
92a9					;call forth_push_numhl 
92a9					; TODO store id 
92a9			 
92a9					push hl 
92a9			 
92a9					; push extent count to stack  
92a9				 
92a9					ld hl, store_page+3 
92a9			 
92a9					; get file name length 
92a9			 
92a9					call strlenz   
92a9			 
92a9					inc hl   ; cover zero term 
92a9					inc hl  ; stick the id at the end of the area 
92a9			 
92a9					push hl 
92a9					pop bc    ; move length to bc 
92a9			 
92a9					call malloc 
92a9			 
92a9					; TODO save malloc area to scratch 
92a9			 
92a9					ex de, hl 
92a9					ld hl, (store_tmp2) 
92a9					ld (hl), e 
92a9					inc hl 
92a9					ld (hl), d 
92a9					inc hl 
92a9					ld (store_tmp2), hl 
92a9			 
92a9					 
92a9			 
92a9					;pop hl   ; get source 
92a9			;		ex de, hl    ; swap aronund	 
92a9			 
92a9					ld hl, store_page+3 
92a9					if DEBUG_FORTH_WORDS 
92a9						DMARK "CFd" 
92a9						CALLMONITOR 
92a9					endif 
92a9					ldir 
92a9			 
92a9					; de is past string, move back one and store id 
92a9					 
92a9					dec de 
92a9			 
92a9					; store file id 
92a9			 
92a9					pop hl 
92a9					ex de,hl 
92a9					ld (hl), e 
92a9			 
92a9					if DEBUG_FORTH_WORDS 
92a9						DMARK "Cdi" 
92a9						CALLMONITOR 
92a9					endif 
92a9					 
92a9			.dirnotfound: 
92a9					pop bc     
92a9					djnz .diritem 
92a9				 
92a9			.dirdone:	 
92a9			 
92a9					ld a, 0 
92a9					ld hl, (store_tmp2) 
92a9					ld (hl), a 
92a9					inc hl 
92a9					ld (hl), a 
92a9					inc hl 
92a9					; push a count of the dir items found 
92a9			 
92a9			;		ld h, 0 
92a9			;		ld l, c 
92a9			 
92a9				ret 
92a9			 
92a9			endif 
92a9			 
92a9			 
92a9			; Settings 
92a9			; Run  
92a9			 
92a9			 
92a9			 
92a9			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
92a9			;;hd_menu2:   db "        2: Editor",0   
92a9			;hd_menu2:   db "        2: Editor       6: Menu",0   
92a9			;hd_menu3:   db "        3: Storage",0 
92a9			;hd_menu4:   db "0=quit  4: Debug",0 
92a9			;hd_don:     db "ON",0 
92a9			;hd_doff:     db "OFF",0 
92a9			; 
92a9			; 
92a9			; 
92a9			;hardware_diags_old:       
92a9			; 
92a9			;.diagmenu: 
92a9			;	call clear_display 
92a9			;	ld a, display_row_1 
92a9			;	ld de, hd_menu1 
92a9			;	call str_at_display 
92a9			; 
92a9			;	ld a, display_row_2 
92a9			;	ld de, hd_menu2 
92a9			;	call str_at_display 
92a9			; 
92a9			;	ld a, display_row_3 
92a9			;	ld de, hd_menu3 
92a9			;	call str_at_display 
92a9			; 
92a9			;	ld a,  display_row_4 
92a9			;	ld de, hd_menu4 
92a9			;	call str_at_display 
92a9			; 
92a9			;	; display debug state 
92a9			; 
92a9			;	ld de, hd_don 
92a9			;	ld a, (os_view_disable) 
92a9			;	cp 0 
92a9			;	jr z, .distog 
92a9			;	ld de, hd_doff 
92a9			;.distog: ld a, display_row_4+17 
92a9			;	call str_at_display 
92a9			; 
92a9			;	call update_display 
92a9			; 
92a9			;	call cin_wait 
92a9			; 
92a9			; 
92a9			; 
92a9			;	cp '4' 
92a9			;	jr nz, .diagn1 
92a9			; 
92a9			;	; debug toggle 
92a9			; 
92a9			;	ld a, (os_view_disable) 
92a9			;	ld b, '*' 
92a9			;	cp 0 
92a9			;	jr z, .debtog 
92a9			;	ld b, 0 
92a9			;.debtog:	 
92a9			;	ld a,b 
92a9			;	ld (os_view_disable),a 
92a9			; 
92a9			;.diagn1: cp '0' 
92a9			;	 ret z 
92a9			; 
92a9			;;	cp '1' 
92a9			;;       jp z, matrix	 
92a9			;;   TODO keyboard matrix test 
92a9			; 
92a9			;	cp '2' 
92a9			;	jp z, .diagedit 
92a9			; 
92a9			;;	cp '6' 
92a9			;;	jp z, .menutest 
92a9			;;if ENABLE_BASIC 
92a9			;;	cp '6' 
92a9			;;	jp z, basic 
92a9			;;endif 
92a9			 ; 
92a9			;	jp .diagmenu 
92a9			; 
92a9			; 
92a9			;	ret 
92a9			 
92a9			 
92a9			.debug_tog: 
92a9 21 f3 92			ld hl, .menudebug 
92ac				 
92ac			;	ld a, (os_view_disable) 
92ac			;	cp '*' 
92ac 3a 6f ee			ld a,(debug_vector) 
92af fe c9			cp $C9   ; RET 
92b1 20 04			jr nz,.tdon  
92b3 3e 01			ld a, 1 
92b5 18 02			jr .tog1 
92b7 3e 00		.tdon: ld a, 0 
92b9			 
92b9			.tog1: 
92b9 cd df 8a			call menu 
92bc fe 00			cp 0 
92be c8				ret z 
92bf fe 01			cp 1    ; disable debug 
92c1 28 04			jr z, .dtog0 
92c3 3e 2a			ld a, '*' 
92c5 18 05			jr .dtogset 
92c7			.dtog0:  
92c7				;ld a, 0 
92c7 cd e5 93			call bp_on 
92ca 18 dd			jr .debug_tog 
92cc			.dtogset:  
92cc				; ld (os_view_disable), a 
92cc cd f1 93			call bp_off 
92cf c3 a9 92			jp .debug_tog 
92d2			 
92d2			 
92d2			hardware_diags:       
92d2			 
92d2			.diagm: 
92d2 21 e5 92			ld hl, .menuitems 
92d5 3e 00			ld a, 0 
92d7 cd df 8a			call menu 
92da			 
92da fe 00		         cp 0 
92dc c8				 ret z 
92dd			 
92dd fe 02			cp 2 
92df ca 3e 93			jp z, .diagedit 
92e2			 
92e2			;	cp '6' 
92e2			;	jp z, .menutest 
92e2			;if ENABLE_BASIC 
92e2			;	cp '6' 
92e2			;	jp z, basic 
92e2			;endif 
92e2			  
92e2 c3 d2 92			jp .diagm 
92e5			 
92e5				 
92e5 f9 92		.menuitems:   	dw .m1 
92e7 04 93				dw .m2 
92e9 0b 93				dw .m3 
92eb 13 93				dw .m5 
92ed 19 93				dw .m5a 
92ef 22 93				dw .m5b 
92f1 00 00				dw 0 
92f3			 
92f3			.menudebug: 
92f3 2b 93				dw .m6 
92f5 34 93				dw .m7 
92f7 00 00				dw 0 
92f9			 
92f9 .. 00		.m1:   db "Key Matrix",0 
9304 .. 00		.m2:   db "Editor",0 
930b .. 00		.m3:   db "Storage",0 
9313 .. 00		.m5:   db "Sound",0 
9319 .. 00		.m5a:  db "RAM Test",0 
9322 .. 00		.m5b:  db "LCD Test",0 
932b			 
932b .. 00		.m6:   db "Debug ON",0 
9334 .. 00		.m7:   db "Debug OFF",0 
933e			 
933e			; debug editor 
933e			 
933e			.diagedit: 
933e			 
933e 21 c1 e2			ld hl, scratch 
9341			;	ld bc, 250 
9341			;	ldir 
9341				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9341 3e 00			ld a, 0 
9343 77				ld (hl), a 
9344 23				inc hl 
9345 77				ld (hl), a 
9346 23				inc hl 
9347 77				ld (hl), a 
9348			 
9348 cd ae 8a		        call clear_display 
934b cd d1 8a			call update_display 
934e				;ld a, 1 
934e				;ld (hardware_diag), a 
934e			.diloop: 
934e 3e 00			ld a, display_row_1 
9350 0e 00			ld c, 0 
9352 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9354 1e 28			ld e, 40 
9356			 
9356 21 c1 e2			ld hl, scratch	 
9359 cd 08 8d			call input_str 
935c			 
935c 3e 28			ld a, display_row_2 
935e 11 c1 e2			ld de, scratch 
9361 cd c1 8a			call str_at_display 
9364 cd d1 8a			call update_display 
9367			 
9367 c3 4e 93			jp .diloop 
936a			 
936a			 
936a			; pass word in hl 
936a			; a has display location 
936a			display_word_at: 
936a f5				push af 
936b e5				push hl 
936c 7c				ld a,h 
936d 21 c6 e5			ld hl, os_word_scratch 
9370 cd e4 8e			call hexout 
9373 e1				pop hl 
9374 7d				ld a,l 
9375 21 c8 e5			ld hl, os_word_scratch+2 
9378 cd e4 8e			call hexout 
937b 21 ca e5			ld hl, os_word_scratch+4 
937e 3e 00			ld a,0 
9380 77				ld (hl),a 
9381 11 c6 e5			ld de,os_word_scratch 
9384 f1				pop af 
9385 cd c1 8a				call str_at_display 
9388 c9				ret 
9389			 
9389			display_ptr_state: 
9389			 
9389				; to restore afterwards 
9389			 
9389 d5				push de 
938a c5				push bc 
938b e5				push hl 
938c f5				push af 
938d			 
938d				; for use in here 
938d			 
938d			;	push bc 
938d			;	push de 
938d			;	push hl 
938d			;	push af 
938d			 
938d cd ae 8a			call clear_display 
9390			 
9390 11 68 95			ld de, .ptrstate 
9393 3e 00			ld a, display_row_1 
9395 cd c1 8a			call str_at_display 
9398			 
9398				; display debug step 
9398			 
9398			 
9398 11 6b ee			ld de, debug_mark 
939b 3e 26			ld a, display_row_1+display_cols-2 
939d cd c1 8a			call str_at_display 
93a0			 
93a0				; display a 
93a0 11 72 95			ld de, .ptrcliptr 
93a3 3e 28			ld a, display_row_2 
93a5 cd c1 8a			call str_at_display 
93a8			 
93a8 f1				pop af 
93a9 2a 40 ea			ld hl,(cli_ptr) 
93ac 3e 30			ld a, display_row_2+8 
93ae cd 6a 93			call display_word_at 
93b1			 
93b1			 
93b1				; display hl 
93b1			 
93b1			 
93b1 11 7a 95			ld de, .ptrclioptr 
93b4 3e 32			ld a, display_row_2+10 
93b6 cd c1 8a			call str_at_display 
93b9			; 
93b9			;	pop hl 
93b9 3e 35			ld a, display_row_2+13 
93bb 2a 3e ea			ld hl,(cli_origptr) 
93be cd 6a 93			call display_word_at 
93c1			; 
93c1			;	 
93c1			;	; display de 
93c1			 
93c1			;	ld de, .regstatede 
93c1			;	ld a, display_row_3 
93c1			;	call str_at_display 
93c1			 
93c1			;	pop de 
93c1			;	ld h,d 
93c1			;	ld l, e 
93c1			;	ld a, display_row_3+3 
93c1			;	call display_word_at 
93c1			 
93c1			 
93c1				; display bc 
93c1			 
93c1			;	ld de, .regstatebc 
93c1			;	ld a, display_row_3+10 
93c1			;	call str_at_display 
93c1			 
93c1			;	pop bc 
93c1			;	ld h,b 
93c1			;	ld l, c 
93c1			;	ld a, display_row_3+13 
93c1			;	call display_word_at 
93c1			 
93c1			 
93c1				; display dsp 
93c1			 
93c1			;	ld de, .regstatedsp 
93c1			;	ld a, display_row_4 
93c1			;	call str_at_display 
93c1			 
93c1				 
93c1			;	ld hl,(cli_data_sp) 
93c1			;	ld a, display_row_4+4 
93c1			;	call display_word_at 
93c1			 
93c1				; display rsp 
93c1			 
93c1 11 a9 95			ld de, .regstatersp 
93c4 3e 82			ld a, display_row_4+10 
93c6 cd c1 8a			call str_at_display 
93c9			 
93c9				 
93c9 2a f2 e9			ld hl,(cli_ret_sp) 
93cc 3e 86			ld a, display_row_4+14 
93ce cd 6a 93			call display_word_at 
93d1			 
93d1 cd d1 8a			call update_display 
93d4			 
93d4 cd f1 89			call delay1s 
93d7 cd f1 89			call delay1s 
93da cd f1 89			call delay1s 
93dd			 
93dd			 
93dd cd da 99			call next_page_prompt 
93e0			 
93e0				; restore  
93e0			 
93e0 f1				pop af 
93e1 e1				pop hl 
93e2 c1				pop bc 
93e3 d1				pop de 
93e4 c9				ret 
93e5			 
93e5			; Update the break point vector so that the user can hook a new routine 
93e5			 
93e5			bp_on: 
93e5 3e c3			ld a, $c3    ; JP 
93e7 32 6f ee			ld (debug_vector), a 
93ea 21 f7 93			ld hl, break_point_state 
93ed 22 70 ee			ld (debug_vector+1), hl 
93f0 c9				ret 
93f1			 
93f1			bp_off: 
93f1 3e c9			ld a, $c9    ; RET 
93f3 32 6f ee			ld (debug_vector), a 
93f6 c9				ret 
93f7			 
93f7			 
93f7			break_point_state: 
93f7			;	push af 
93f7			; 
93f7			;	; see if disabled 
93f7			; 
93f7			;	ld a, (os_view_disable) 
93f7			;	cp '*' 
93f7			;	jr nz, .bpsgo 
93f7			;	pop af 
93f7			;	ret 
93f7			 
93f7			.bpsgo: 
93f7			;	pop af 
93f7 f5				push af 
93f8 22 a3 e2			ld (os_view_hl), hl 
93fb ed 53 a1 e2		ld (os_view_de), de 
93ff ed 43 9f e2		ld (os_view_bc), bc 
9403 e5				push hl 
9404 6f				ld l, a 
9405 26 00			ld h, 0 
9407 22 a5 e2			ld (os_view_af),hl 
940a			 
940a 21 b1 ed				ld hl, display_fb0 
940d 22 cc eb				ld (display_fb_active), hl 
9410 e1				pop hl	 
9411			 
9411 3e 31			ld a, '1' 
9413 fe 2a		.bps1:  cp '*' 
9415 cc f1 93			call z, bp_off 
9418			;	jr nz, .bps1b 
9418			;	ld (os_view_disable),a 
9418 fe 31		.bps1b:  cp '1' 
941a 20 14			jr nz, .bps2 
941c			 
941c				; display reg 
941c			 
941c				 
941c			 
941c 3a a5 e2			ld a, (os_view_af) 
941f 2a a3 e2			ld hl, (os_view_hl) 
9422 ed 5b a1 e2		ld de, (os_view_de) 
9426 ed 4b 9f e2		ld bc, (os_view_bc) 
942a cd c4 94			call display_reg_state 
942d c3 b0 94			jp .bpschk 
9430			 
9430 fe 32		.bps2:  cp '2' 
9432 20 08			jr nz, .bps3 
9434				 
9434				; display hl 
9434 2a a3 e2			ld hl, (os_view_hl) 
9437 cd ae 95			call display_dump_at_hl 
943a			 
943a 18 74			jr .bpschk 
943c			 
943c fe 33		.bps3:  cp '3' 
943e 20 08			jr nz, .bps4 
9440			 
9440			        ; display de 
9440 2a a1 e2			ld hl, (os_view_de) 
9443 cd ae 95			call display_dump_at_hl 
9446			 
9446 18 68			jr .bpschk 
9448 fe 34		.bps4:  cp '4' 
944a 20 08			jr nz, .bps5 
944c			 
944c			        ; display bc 
944c 2a 9f e2			ld hl, (os_view_bc) 
944f cd ae 95			call display_dump_at_hl 
9452			 
9452 18 5c			jr .bpschk 
9454 fe 35		.bps5:  cp '5' 
9456 20 08		        jr nz, .bps7 
9458			 
9458				; display cur ptr 
9458 2a 40 ea			ld hl, (cli_ptr) 
945b cd ae 95			call display_dump_at_hl 
945e			 
945e 18 50			jr .bpschk 
9460 fe 36		.bps7:  cp '6' 
9462 20 08			jr nz, .bps8b 
9464				 
9464				; display cur orig ptr 
9464 2a 3e ea			ld hl, (cli_origptr) 
9467 cd ae 95			call display_dump_at_hl 
946a 18 44			jr .bpschk 
946c fe 37		.bps8b:  cp '7' 
946e 20 08			jr nz, .bps9 
9470				 
9470				; display dsp 
9470 2a ee e9			ld hl, (cli_data_sp) 
9473 cd ae 95			call display_dump_at_hl 
9476			 
9476 18 38			jr .bpschk 
9478 fe 39		.bps9:  cp '9' 
947a 20 05			jr nz, .bps8c 
947c				 
947c				; display SP 
947c			;	ld hl, sp 
947c cd ae 95			call display_dump_at_hl 
947f			 
947f 18 2f			jr .bpschk 
9481 fe 38		.bps8c:  cp '8' 
9483 20 08			jr nz, .bps8d 
9485				 
9485				; display rsp 
9485 2a f2 e9			ld hl, (cli_ret_sp) 
9488 cd ae 95			call display_dump_at_hl 
948b			 
948b 18 23			jr .bpschk 
948d fe 23		.bps8d:  cp '#'     ; access monitor sub system 
948f 20 05			jr nz, .bps8 
9491 cd a8 97			call monitor 
9494			 
9494 18 1a			jr .bpschk 
9496 fe 30		.bps8:  cp '0' 
9498 20 16			jr nz, .bpschk 
949a			 
949a 21 10 ed				ld hl, display_fb1 
949d 22 cc eb				ld (display_fb_active), hl 
94a0 cd d1 8a				call update_display 
94a3			 
94a3				;ld a, (os_view_af) 
94a3 2a a3 e2			ld hl, (os_view_hl) 
94a6 ed 5b a1 e2		ld de, (os_view_de) 
94aa ed 4b 9f e2		ld bc, (os_view_bc) 
94ae f1				pop af 
94af c9				ret 
94b0			 
94b0			.bpschk:   
94b0 cd f1 89			call delay1s 
94b3 3e 9f		ld a,display_row_4 + display_cols - 1 
94b5 11 d8 99		        ld de, endprg 
94b8 cd c1 8a			call str_at_display 
94bb cd d1 8a			call update_display 
94be cd fc dc			call cin_wait 
94c1			 
94c1 c3 13 94			jp .bps1 
94c4			 
94c4			 
94c4			display_reg_state: 
94c4			 
94c4				; to restore afterwards 
94c4			 
94c4 d5				push de 
94c5 c5				push bc 
94c6 e5				push hl 
94c7 f5				push af 
94c8			 
94c8				; for use in here 
94c8			 
94c8 c5				push bc 
94c9 d5				push de 
94ca e5				push hl 
94cb f5				push af 
94cc			 
94cc cd ae 8a			call clear_display 
94cf			 
94cf 11 84 95			ld de, .regstate 
94d2 3e 00			ld a, display_row_1 
94d4 cd c1 8a			call str_at_display 
94d7			 
94d7				; display debug step 
94d7			 
94d7			 
94d7 11 6b ee			ld de, debug_mark 
94da 3e 25			ld a, display_row_1+display_cols-3 
94dc cd c1 8a			call str_at_display 
94df			 
94df				; display a 
94df 11 a0 95			ld de, .regstatea 
94e2 3e 28			ld a, display_row_2 
94e4 cd c1 8a			call str_at_display 
94e7			 
94e7 e1				pop hl 
94e8			;	ld h,0 
94e8			;	ld l, a 
94e8 3e 2b			ld a, display_row_2+3 
94ea cd 6a 93			call display_word_at 
94ed			 
94ed			 
94ed				; display hl 
94ed			 
94ed			 
94ed 11 94 95			ld de, .regstatehl 
94f0 3e 32			ld a, display_row_2+10 
94f2 cd c1 8a			call str_at_display 
94f5			 
94f5 e1				pop hl 
94f6 3e 35			ld a, display_row_2+13 
94f8 cd 6a 93			call display_word_at 
94fb			 
94fb				 
94fb				; display de 
94fb			 
94fb 11 98 95			ld de, .regstatede 
94fe 3e 50			ld a, display_row_3 
9500 cd c1 8a			call str_at_display 
9503			 
9503 e1				pop hl 
9504			;	ld h,d 
9504			;	ld l, e 
9504 3e 53			ld a, display_row_3+3 
9506 cd 6a 93			call display_word_at 
9509			 
9509			 
9509				; display bc 
9509			 
9509 11 9c 95			ld de, .regstatebc 
950c 3e 5a			ld a, display_row_3+10 
950e cd c1 8a			call str_at_display 
9511			 
9511 e1				pop hl 
9512			;	ld h,b 
9512			;	ld l, c 
9512 3e 5d			ld a, display_row_3+13 
9514 cd 6a 93			call display_word_at 
9517			 
9517			 
9517				; display dsp 
9517			 
9517 11 a4 95			ld de, .regstatedsp 
951a 3e 78			ld a, display_row_4 
951c cd c1 8a			call str_at_display 
951f			 
951f				 
951f 2a ee e9			ld hl,(cli_data_sp) 
9522 3e 7c			ld a, display_row_4+4 
9524 cd 6a 93			call display_word_at 
9527			 
9527				; display rsp 
9527			 
9527 11 a9 95			ld de, .regstatersp 
952a 3e 82			ld a, display_row_4+10 
952c cd c1 8a			call str_at_display 
952f			 
952f				 
952f 2a f2 e9			ld hl,(cli_ret_sp) 
9532 3e 86			ld a, display_row_4+14 
9534 cd 6a 93			call display_word_at 
9537			 
9537 cd d1 8a			call update_display 
953a			 
953a			;	call delay1s 
953a			;	call delay1s 
953a			;	call delay1s 
953a			 
953a			 
953a			;	call next_page_prompt 
953a			 
953a				; restore  
953a			 
953a f1				pop af 
953b e1				pop hl 
953c c1				pop bc 
953d d1				pop de 
953e c9				ret 
953f			 
953f .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9553 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9568 .. 00		.ptrstate:	db "Ptr State",0 
9572 .. 00		.ptrcliptr:     db "cli_ptr",0 
957a .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9584 .. 00		.regstate:	db "Reg State (1/0)",0 
9594 .. 00		.regstatehl:	db "HL:",0 
9598 .. 00		.regstatede:	db "DE:",0 
959c .. 00		.regstatebc:	db "BC:",0 
95a0 .. 00		.regstatea:	db "A :",0 
95a4 .. 00		.regstatedsp:	db "DSP:",0 
95a9 .. 00		.regstatersp:	db "RSP:",0 
95ae			 
95ae			display_dump_at_hl: 
95ae e5				push hl 
95af d5				push de 
95b0 c5				push bc 
95b1 f5				push af 
95b2			 
95b2 22 e4 e5			ld (os_cur_ptr),hl	 
95b5 cd ae 8a			call clear_display 
95b8 cd e2 98			call dumpcont 
95bb			;	call delay1s 
95bb			;	call next_page_prompt 
95bb			 
95bb			 
95bb f1				pop af 
95bc c1				pop bc 
95bd d1				pop de 
95be e1				pop hl 
95bf c9				ret 
95c0			 
95c0			;if ENABLE_BASIC 
95c0			;	include "nascombasic.asm" 
95c0			;	basic: 
95c0			;	include "forth/FORTH.ASM" 
95c0			;endif 
95c0			 
95c0			; eof 
95c0			 
95c0			 
# End of file firmware_diags.asm
95c0			  
95c0			include "firmware_prompts.asm"  
95c0			; Prompts  
95c0			 
95c0			; boot messages 
95c0			 
95c0 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
95d5 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
95e5			 
95e5			 
95e5			; config menus 
95e5			 
95e5			;prom_c3: db "Add Dictionary To File",0 
95e5			 
95e5			if STARTUP_V1 
95e5 .. 00		prom_c2: db "Select Autoload File",0 
95fa .. 00		prom_c2a: db "Disable Autoload File", 0 
9610			endif 
9610			 
9610			if STARTUP_V2 
9610			prom_c2: db "Enable Autoload Files",0 
9610			prom_c2a: db "Disable Autoload Files", 0 
9610			 
9610			crs_s1: db "*ls-word", 0 
9610			crs_s2: db "*ed-word", 0 
9610			crs_s3: db "*Demo-Games", 0 
9610			crs_s4: db "*Utils", 0 
9610			crs_s5: db "*SPI-Util", 0 
9610			crs_s6: db "*Key-Constants", 0 
9610			crs_sound: db "*Sound-Util", 0 
9610			crs_hw: db "*Hello-World",0 
9610			 
9610			 
9610			 
9610			endif 
9610			;prom_c2b: db "Select Storage Bank",0 
9610 .. 00		prom_c4: db "Settings",0 
9619 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9634 .. 00		prom_m4b:   db "Monitor",0 
963c .. 00		prom_c1: db "Hardware Diags",0 
964b			 
964b			 
964b			if STARTUP_V2 
964b			prom_c9: db "Create Startup Files",0 
964b			endif 
964b			 
964b .. 00		prom_notav:    db "Feature not available",0 
9661 .. 00		prom_empty:    db "",0 
9662			 
9662			; eof 
9662			 
# End of file firmware_prompts.asm
9662			  
9662			  
9662			; eof  
9662			  
# End of file firmware.asm
9662			 
9662			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9662			;if BASE_KEV  
9662			;baseram: equ 08000h 
9662			;endif 
9662			 
9662			;if BASE_SC114 
9662			;baseram:     equ    endofcode 
9662			;endif 
9662			 
9662			 
9662			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
9662			 
9662			; start system 
9662			 
9662			coldstart: 
9662				; set sp 
9662				; di/ei 
9662			 
9662 f3				di 
9663 31 00 f0			ld sp, tos 
9666 cd 46 dc			call init_nmi 
9669			;	ei 
9669			 
9669				; init spinner 
9669 3e 00			ld a,0 
966b 32 c6 eb			ld (display_active), a 
966e			 
966e				; disable breakpoint by default 
966e			 
966e				;ld a,'*' 
966e			;	ld a,' ' 
966e			;	ld (os_view_disable),a 
966e			 
966e				; set break point vector as new break point on or off 
966e cd f1 93			call bp_off 
9671			 
9671				; init hardware 
9671			 
9671				; init keyboard and screen hardware 
9671			 
9671 cd 1b 80			call hardware_init 
9674			 
9674			 
9674 cd f1 89			call delay1s 
9677 3e 58			ld a, display_row_3+8 
9679 11 03 80			ld de, buildtime 
967c cd c1 8a			call str_at_display 
967f cd d1 8a			call update_display 
9682			 
9682 cd f1 89			call delay1s 
9685 cd f1 89			call delay1s 
9688 cd f1 89			call delay1s 
968b			 
968b				; detect if any keys are held down to enable breakpoints at start up 
968b			 
968b cd 02 dd			call cin  
968e fe 00			cp 0 
9690 28 03			jr z, .nokeys 
9692			 
9692				;call hardware_diags 
9692 cd 4f 92			call config 
9695			 
9695			;	ld de, .bpen 
9695			;	ld a, display_row_4 
9695			;	call str_at_display 
9695			;	call update_display 
9695			; 
9695			;	ld a,0 
9695			;	ld (os_view_disable),a 
9695			; 
9695			;.bpwait: 
9695			;	call cin 
9695			;	cp 0 
9695			;	jr z, .bpwait 
9695			;	jr .nokeys 
9695			; 
9695			; 
9695			;.bpen:  db "Break points enabled!",0 
9695			 
9695			 
9695			 
9695			 
9695			 
9695			 
9695			.nokeys: 
9695			 
9695			 
9695				 
9695			 
9695			;jp  testkey 
9695			 
9695			;call storage_get_block_0 
9695			; 
9695			;ld hl, 0 
9695			;ld de, store_page 
9695			;call storage_read_block 
9695			 
9695				 
9695			;ld hl, 10 
9695			;ld de, store_page 
9695			;call storage_read_block 
9695			 
9695			 
9695			 
9695			 
9695			 
9695			;stop:	nop 
9695			;	jp stop 
9695			 
9695			 
9695			 
9695			main: 
9695 cd ae 8a			call clear_display 
9698 cd d1 8a			call update_display 
969b			 
969b			 
969b			 
969b			;	call testlcd 
969b			 
969b			 
969b			 
969b cd ed 9d			call forth_init 
969e			 
969e			 
969e			warmstart: 
969e cd c3 9d			call forth_warmstart 
96a1			 
96a1				; run startup word load 
96a1			        ; TODO prevent this running at warmstart after crash  
96a1			 
96a1				if STARTUP_ENABLE 
96a1			 
96a1					if STARTUP_V1 
96a1			 
96a1						if STORAGE_SE 
96a1							call forth_autoload 
96a1						endif 
96a1 cd 96 db					call forth_startup 
96a4					endif 
96a4			 
96a4					if STARTUP_V2 
96a4			 
96a4						if STORAGE_SE 
96a4							call forth_autoload 
96a4						else 
96a4							call forth_startup 
96a4						endif 
96a4			 
96a4			 
96a4					endif 
96a4			 
96a4				endif 
96a4			 
96a4				; show free memory after boot 
96a4 11 43 97			ld de, freeram 
96a7 3e 00			ld a, display_row_1 
96a9 cd c1 8a			call str_at_display 
96ac			 
96ac				; get current heap start after loading any uwords 
96ac			 
96ac				;ld de, (os_last_new_uword) 
96ac				;ex de, hl 
96ac			 
96ac			; Or use heap_size word???? 
96ac				;ld hl, heap_end 
96ac				;ld hl, heap_size 
96ac				;ld de, topusermem 
96ac				;ld de, heap_start 
96ac ed 5b 1b dd			ld de, (free_list )      
96b0 21 9c e2				ld hl, heap_end 
96b3 ed 52			sbc hl, de 
96b5				;push hl 
96b5				;ld a,h	         	 
96b5				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
96b5				;call hexout 
96b5			   	;pop hl 
96b5			; 
96b5			;	ld a,l 
96b5			;	ld hl, os_word_scratch+2 
96b5			;	call hexout 
96b5			;	ld hl, os_word_scratch+4 
96b5			;	ld a, 0 
96b5			;	ld (hl),a 
96b5 eb				ex de, hl 
96b6 21 c6 e5			ld hl, os_word_scratch 
96b9 cd f0 8f			call uitoa_16 
96bc			 
96bc			 
96bc 11 c6 e5			ld de, os_word_scratch 
96bf 3e 0d			ld a, display_row_1 + 13 
96c1 cd c1 8a			call str_at_display 
96c4 cd d1 8a			call update_display 
96c7			 
96c7			 
96c7				;call demo 
96c7			 
96c7			 
96c7				; init scratch input area for cli commands 
96c7			 
96c7 21 e8 e5			ld hl, os_cli_cmd 
96ca 3e 00			ld a,0 
96cc 77				ld (hl),a 
96cd 23				inc hl 
96ce 77				ld (hl),a 
96cf			 
96cf 3e 00			ld a,0 
96d1 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
96d4			 
96d4 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
96d7 32 e5 e5			ld (os_cur_ptr+1),a	 
96da			 
96da 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
96dd 32 c7 e5			ld (os_word_scratch+1),a	 
96e0				 
96e0			 
96e0				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96e0 21 e8 e5			ld hl, os_cli_cmd 
96e3			 
96e3 3e 00			ld a, 0		 ; init cli input 
96e5 77				ld (hl), a 
96e6 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96e8			cli: 
96e8				; show cli prompt 
96e8				;push af 
96e8				;ld a, 0 
96e8				;ld de, prompt 
96e8				;call str_at_display 
96e8			 
96e8				;call update_display 
96e8				;pop af 
96e8				;inc a 
96e8				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
96e8			 
96e8			.lastrecall: 
96e8			 
96e8 0e 00			ld c, 0 
96ea 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
96ec 1e 28			ld e, 40 
96ee			 
96ee 21 e8 e5			ld hl, os_cli_cmd 
96f1			 
96f1				STACKFRAME OFF $fefe $9f9f 
96f1				if DEBUG_STACK_IMB 
96f1					if OFF 
96f1						exx 
96f1						ld de, $fefe 
96f1						ld a, d 
96f1						ld hl, curframe 
96f1						call hexout 
96f1						ld a, e 
96f1						ld hl, curframe+2 
96f1						call hexout 
96f1						ld hl, $fefe 
96f1						push hl 
96f1						ld hl, $9f9f 
96f1						push hl 
96f1						exx 
96f1					endif 
96f1				endif 
96f1			endm 
# End of macro STACKFRAME
96f1			 
96f1 cd 08 8d			call input_str 
96f4			 
96f4				STACKFRAMECHK OFF $fefe $9f9f 
96f4				if DEBUG_STACK_IMB 
96f4					if OFF 
96f4						exx 
96f4						ld hl, $9f9f 
96f4						pop de   ; $9f9f 
96f4						call cmp16 
96f4						jr nz, .spnosame 
96f4						ld hl, $fefe 
96f4						pop de   ; $fefe 
96f4						call cmp16 
96f4						jr z, .spfrsame 
96f4						.spnosame: call showsperror 
96f4						.spfrsame: nop 
96f4						exx 
96f4					endif 
96f4				endif 
96f4			endm 
# End of macro STACKFRAMECHK
96f4			 
96f4			 
96f4				; check to see if last line recall has been requested 
96f4			 
96f4			if EDIT_V2 
96f4 fe 05			cp KEY_UP 
96f6 20 0f			jr nz, .noexecline 
96f8			 
96f8 11 e8 e5			ld de, os_cli_cmd 
96fb 21 e7 e6			ld hl, os_last_cmd 
96fe 01 ff 00			ld bc, 255 
9701 ed b0			ldir 
9703 3e 00			ld a, 0 
9705 18 e1			jr .lastrecall 
9707			endif 
9707			 
9707			.noexecline: 
9707				; no so exec the line		 
9707			 
9707				; copy input to last command 
9707			 
9707 21 e8 e5			ld hl, os_cli_cmd 
970a 11 e7 e6			ld de, os_last_cmd 
970d 01 ff 00			ld bc, 255 
9710 ed b0			ldir 
9712			 
9712				; wipe current buffer 
9712			 
9712			;	ld a, 0 
9712			;	ld hl, os_cli_cmd 
9712			;	ld de, os_cli_cmd+1 
9712			;	ld bc, 254 
9712			;	ldir 
9712				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9712			;	call strcpy 
9712			;	ld a, 0 
9712			;	ld (hl), a 
9712			;	inc hl 
9712			;	ld (hl), a 
9712			;	inc hl 
9712			;	ld (hl), a 
9712			 
9712				; switch frame buffer to program  
9712			 
9712 21 10 ed				ld hl, display_fb1 
9715 22 cc eb				ld (display_fb_active), hl 
9718			 
9718			;	nop 
9718				STACKFRAME ON $fbfe $8f9f 
9718				if DEBUG_STACK_IMB 
9718					if ON 
9718						exx 
9718						ld de, $fbfe 
9718						ld a, d 
9718						ld hl, curframe 
9718						call hexout 
9718						ld a, e 
9718						ld hl, curframe+2 
9718						call hexout 
9718						ld hl, $fbfe 
9718						push hl 
9718						ld hl, $8f9f 
9718						push hl 
9718						exx 
9718					endif 
9718				endif 
9718			endm 
# End of macro STACKFRAME
9718				; first time into the parser so pass over the current scratch pad 
9718 21 e8 e5			ld hl,os_cli_cmd 
971b				; tokenise the entered statement(s) in HL 
971b cd 6b 9e			call forthparse 
971e			        ; exec forth statements in top of return stack 
971e cd ab 9e			call forthexec 
9721				;call forthexec_cleanup 
9721			;	call parsenext 
9721			 
9721				STACKFRAMECHK ON $fbfe $8f9f 
9721				if DEBUG_STACK_IMB 
9721					if ON 
9721						exx 
9721						ld hl, $8f9f 
9721						pop de   ; $8f9f 
9721						call cmp16 
9721						jr nz, .spnosame 
9721						ld hl, $fbfe 
9721						pop de   ; $fbfe 
9721						call cmp16 
9721						jr z, .spfrsame 
9721						.spnosame: call showsperror 
9721						.spfrsame: nop 
9721						exx 
9721					endif 
9721				endif 
9721			endm 
# End of macro STACKFRAMECHK
9721				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9721			 
9721 3e 78			ld a, display_row_4 
9723 11 54 97			ld de, endprog 
9726			 
9726 cd d1 8a			call update_display		 
9729			 
9729 cd da 99			call next_page_prompt 
972c			 
972c				; switch frame buffer to cli 
972c			 
972c 21 b1 ed				ld hl, display_fb0 
972f 22 cc eb				ld (display_fb_active), hl 
9732			 
9732			 
9732 cd ae 8a		        call clear_display 
9735 cd d1 8a			call update_display		 
9738			 
9738 21 e8 e5			ld hl, os_cli_cmd 
973b			 
973b 3e 00			ld a, 0		 ; init cli input 
973d 77				ld (hl), a 
973e			 
973e				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
973e			 
973e				; now on last line 
973e			 
973e				; TODO scroll screen up 
973e			 
973e				; TODO instead just clear screen and place at top of screen 
973e			 
973e			;	ld a, 0 
973e			;	ld (f_cursor_ptr),a 
973e			 
973e				;call clear_display 
973e				;call update_display 
973e			 
973e				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
973e 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9740 c3 e8 96			jp cli 
9743			 
9743 .. 00		freeram: db "Free bytes: ",0 
9750 ..			asc: db "1A2F" 
9754 .. 00		endprog: db "End prog...",0 
9760			 
9760			testenter2:   
9760 21 f3 e2			ld hl,scratch+50 
9763 22 e4 e5			ld (os_cur_ptr),hl 
9766 c3 e8 96			jp cli 
9769			 
9769			testenter:  
9769			 
9769 21 50 97			ld hl,asc 
976c			;	ld a,(hl) 
976c			;	call nibble2val 
976c cd 3a 8f			call get_byte 
976f			 
976f			 
976f			;	ld a,(hl) 
976f			;	call atohex 
976f			 
976f			;	call fourehexhl 
976f 32 f3 e2			ld (scratch+50),a 
9772			 
9772			 
9772			 
9772 21 52 97			ld hl,asc+2 
9775			;	ld a, (hl) 
9775			;	call nibble2val 
9775 cd 3a 8f			call get_byte 
9778			 
9778			;	call fourehexhl 
9778 32 f5 e2			ld (scratch+52),a 
977b				 
977b 21 f3 e2			ld hl,scratch+50 
977e 22 e4 e5			ld (os_cur_ptr),hl 
9781 c3 e8 96			jp cli 
9784			 
9784			enter:	 
9784 3a c5 e2			ld a,(scratch+4) 
9787 fe 00			cp 0 
9789 28 0c			jr z, .entercont 
978b				; no, not a null term line so has an address to work out.... 
978b			 
978b 21 c3 e2			ld hl,scratch+2 
978e cd 9a 8f			call get_word_hl 
9791			 
9791 22 e4 e5			ld (os_cur_ptr),hl	 
9794 c3 e8 96			jp cli 
9797			 
9797			 
9797			.entercont:  
9797			 
9797 21 c3 e2			ld hl, scratch+2 
979a cd 3a 8f			call get_byte 
979d			 
979d 2a e4 e5		   	ld hl,(os_cur_ptr) 
97a0 77					ld (hl),a 
97a1 23					inc hl 
97a2 22 e4 e5				ld (os_cur_ptr),hl 
97a5				 
97a5			; get byte  
97a5			 
97a5			 
97a5 c3 e8 96			jp cli 
97a8			 
97a8			 
97a8			; basic monitor support 
97a8			 
97a8			monitor: 
97a8				;  
97a8 cd ae 8a			call clear_display 
97ab 3e 00			ld a, 0 
97ad 11 fc 97			ld de, .monprompt 
97b0 cd c1 8a			call str_at_display 
97b3 cd d1 8a			call update_display 
97b6			 
97b6				; get a monitor command 
97b6			 
97b6 0e 00			ld c, 0     ; entry at top left 
97b8 16 64			ld d, 100   ; max buffer size 
97ba 1e 0f			ld e, 15    ; input scroll area 
97bc 3e 00			ld a, 0     ; init string 
97be 21 bf e4			ld hl, os_input 
97c1 77				ld (hl), a 
97c2 23				inc hl 
97c3 77				ld (hl), a 
97c4 21 bf e4			ld hl, os_input 
97c7 3e 01			ld a, 1     ; init string 
97c9 cd 08 8d			call input_str 
97cc			 
97cc cd ae 8a		        call clear_display 
97cf cd d1 8a			call update_display		 
97d2			 
97d2 3a bf e4			ld a, (os_input) 
97d5 cd 38 90			call toUpper 
97d8 fe 48		        cp 'H' 
97da ca 61 98		        jp z, .monhelp 
97dd fe 44			cp 'D'		; dump 
97df ca 94 98			jp z, .mondump	 
97e2 fe 43			cp 'C'		; dump 
97e4 ca ae 98			jp z, .moncdump	 
97e7 fe 4d			cp 'M'		; dump 
97e9 ca fe 97			jp z, .moneditstart 
97ec fe 55			cp 'U'		; dump 
97ee ca 0a 98			jp z, .monedit	 
97f1 fe 47			cp 'G'		; dump 
97f3 ca 8a 98			jp z, .monjump 
97f6 fe 51			cp 'Q'		; dump 
97f8 c8				ret z	 
97f9			 
97f9			 
97f9				; TODO "S" to access symbol by name and not need the address 
97f9				; TODO "F" to find a string in memory 
97f9			 
97f9 c3 a8 97			jp monitor 
97fc			 
97fc .. 00		.monprompt: db ">", 0 
97fe			 
97fe			.moneditstart: 
97fe				; get starting address 
97fe			 
97fe 21 c1 e4			ld hl,os_input+2 
9801 cd 9a 8f			call get_word_hl 
9804			 
9804 22 e4 e5			ld (os_cur_ptr),hl	 
9807			 
9807 c3 a8 97			jp monitor 
980a			 
980a			.monedit: 
980a				; get byte to load 
980a			 
980a 21 c1 e4			ld hl,os_input+2 
980d cd 3a 8f			call get_byte 
9810			 
9810				; get address to update 
9810 2a e4 e5			ld hl, (os_cur_ptr) 
9813			 
9813				; update byte 
9813			 
9813 77				ld (hl), a 
9814			 
9814				; move to next address and save it 
9814			 
9814 23				inc hl 
9815 22 e4 e5			ld (os_cur_ptr),hl	 
9818			 
9818 c3 a8 97			jp monitor 
981b			 
981b			 
981b .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
982f .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
984b .. 00		.monhelptext3:  db "G-Call address",0 
985a .. 00		.monhelptext4:  db "Q-Quit",0 
9861			        
9861			.monhelp: 
9861 3e 00			ld a, display_row_1 
9863 11 1b 98		        ld de, .monhelptext1 
9866			 
9866 cd c1 8a			call str_at_display 
9869 3e 28			ld a, display_row_2 
986b 11 2f 98		        ld de, .monhelptext2 
986e					 
986e cd c1 8a			call str_at_display 
9871 3e 50			ld a, display_row_3 
9873 11 4b 98		        ld de, .monhelptext3 
9876					 
9876 cd c1 8a			call str_at_display 
9879 3e 78			ld a, display_row_4 
987b 11 5a 98		        ld de, .monhelptext4 
987e cd c1 8a			call str_at_display 
9881			 
9881 cd d1 8a			call update_display		 
9884			 
9884 cd da 99			call next_page_prompt 
9887 c3 a8 97			jp monitor 
988a			 
988a			.monjump:    
988a 21 c1 e4			ld hl,os_input+2 
988d cd 9a 8f			call get_word_hl 
9890			 
9890 e9				jp (hl) 
9891 c3 a8 97			jp monitor 
9894			 
9894			.mondump:    
9894 21 c1 e4			ld hl,os_input+2 
9897 cd 9a 8f			call get_word_hl 
989a			 
989a 22 e4 e5			ld (os_cur_ptr),hl	 
989d cd e2 98			call dumpcont 
98a0 3e 78			ld a, display_row_4 
98a2 11 54 97			ld de, endprog 
98a5			 
98a5 cd d1 8a			call update_display		 
98a8			 
98a8 cd da 99			call next_page_prompt 
98ab c3 a8 97			jp monitor 
98ae			.moncdump: 
98ae cd e2 98			call dumpcont 
98b1 3e 78			ld a, display_row_4 
98b3 11 54 97			ld de, endprog 
98b6			 
98b6 cd d1 8a			call update_display		 
98b9			 
98b9 cd da 99			call next_page_prompt 
98bc c3 a8 97			jp monitor 
98bf			 
98bf			 
98bf			; TODO symbol access  
98bf			 
98bf			.symbols:     ;; A list of symbols that can be called up  
98bf b1 ed			dw display_fb0 
98c1 .. 00			db "fb0",0  
98c5 7a ea		     	dw store_page 
98c7 .. 00			db "store_page",0 
98d2			 
98d2			 
98d2			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
98d2			 
98d2 3a c2 e2			ld a,(scratch+1) 
98d5 fe 00			cp 0 
98d7 28 09			jr z, dumpcont 
98d9			 
98d9				; no, not a null term line so has an address to work out.... 
98d9			 
98d9 21 c3 e2			ld hl,scratch+2 
98dc cd 9a 8f			call get_word_hl 
98df			 
98df 22 e4 e5			ld (os_cur_ptr),hl	 
98e2			 
98e2			 
98e2			 
98e2			dumpcont: 
98e2			 
98e2				; dump bytes at ptr 
98e2			 
98e2			 
98e2 3e 00			ld a, display_row_1 
98e4 2a cc eb			ld hl, (display_fb_active) 
98e7 cd db 8c			call addatohl 
98ea cd 12 99			call .dumpbyterow 
98ed			 
98ed 3e 28			ld a, display_row_2 
98ef 2a cc eb			ld hl, (display_fb_active) 
98f2 cd db 8c			call addatohl 
98f5 cd 12 99			call .dumpbyterow 
98f8			 
98f8			 
98f8 3e 50			ld a, display_row_3 
98fa 2a cc eb			ld hl, (display_fb_active) 
98fd cd db 8c			call addatohl 
9900 cd 12 99			call .dumpbyterow 
9903			 
9903 3e 78			ld a, display_row_4 
9905 2a cc eb			ld hl, (display_fb_active) 
9908 cd db 8c			call addatohl 
990b cd 12 99			call .dumpbyterow 
990e			 
990e cd d1 8a			call update_display 
9911			;		jp cli 
9911 c9				ret 
9912			 
9912			.dumpbyterow: 
9912			 
9912				;push af 
9912			 
9912 e5				push hl 
9913			 
9913				; calc where to poke the ascii 
9913			if display_cols == 20 
9913				ld a, 16 
9913			else 
9913 3e 1f			ld a, 31 
9915			endif 
9915			 
9915 cd db 8c			call addatohl 
9918 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
991b			 
991b			 
991b			; display decoding address 
991b 2a e4 e5		   	ld hl,(os_cur_ptr) 
991e			 
991e 7c				ld a,h 
991f e1				pop hl 
9920 e5				push hl 
9921			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9921 cd e4 8e			call hexout 
9924 2a e4 e5		   	ld hl,(os_cur_ptr) 
9927			 
9927 7d				ld a,l 
9928 e1				pop hl 
9929 23				inc hl 
992a 23				inc hl 
992b e5				push hl 
992c			;	ld hl, os_word_scratch+2 
992c cd e4 8e			call hexout 
992f e1				pop hl 
9930 23				inc hl 
9931 23				inc hl 
9932				;ld hl, os_word_scratch+4 
9932 3e 3a			ld a, ':' 
9934 77				ld (hl),a 
9935 23				inc hl 
9936				;ld a, 0 
9936				;ld (hl),a 
9936				;ld de, os_word_scratch 
9936				;pop af 
9936				;push af 
9936			;		ld a, display_row_2 
9936			;		call str_at_display 
9936			;		call update_display 
9936			 
9936			 
9936			;pop af 
9936			;	add 5 
9936			 
9936			if display_cols == 20 
9936				ld b, 4 
9936			else 
9936 06 08			ld b, 8 
9938			endif	 
9938			 
9938			.dumpbyte: 
9938 c5				push bc 
9939 e5				push hl 
993a			 
993a			 
993a 2a e4 e5		   	ld hl,(os_cur_ptr) 
993d 7e					ld a,(hl) 
993e			 
993e					; poke the ascii to display 
993e 2a c6 e5				ld hl,(os_word_scratch) 
9941 77					ld (hl),a 
9942 23					inc hl 
9943 22 c6 e5				ld (os_word_scratch),hl 
9946			 
9946					 
9946			 
9946			 
9946 e1					pop hl 
9947 e5					push hl 
9948			 
9948 cd e4 8e				call hexout 
994b			 
994b					 
994b 2a e4 e5		   	ld hl,(os_cur_ptr) 
994e 23				inc hl 
994f 22 e4 e5		   	ld (os_cur_ptr),hl 
9952			 
9952 e1					pop hl 
9953 23					inc hl 
9954 23					inc hl 
9955 23					inc hl 
9956			 
9956			 
9956			 
9956					;ld a,0 
9956					;ld (os_word_scratch+2),a 
9956					;pop af 
9956					;push af 
9956			 
9956					;ld de, os_word_scratch 
9956					;call str_at_display 
9956			;		call update_display 
9956			;		pop af 
9956 c1					pop bc 
9957 c6 03				add 3 
9959 10 dd			djnz .dumpbyte 
995b			 
995b				 
995b			 
995b c9				ret 
995c			 
995c			jump:	 
995c			 
995c 21 c3 e2			ld hl,scratch+2 
995f cd 9a 8f			call get_word_hl 
9962				;ld hl,(scratch+2) 
9962				;call fourehexhl 
9962			 
9962 22 e4 e5			ld (os_cur_ptr),hl	 
9965			 
9965 e9				jp (hl) 
9966			 
9966			 
9966			 
9966			; TODO implement a basic monitor mode to start with 
9966			 
9966			 
9966			 
9966			 
9966			 
9966			 
9966			 
9966			 
9966			 
9966			; testing and demo code during development 
9966			 
9966			 
9966 .. 00		str1: db "Enter some text...",0 
9979 .. 00		clear: db "                    ",0 
998e			 
998e			demo: 
998e			 
998e			 
998e			 
998e			;	call update_display 
998e			 
998e				; init scratch input area for testing 
998e 21 c1 e2			ld hl, scratch	 
9991 3e 00			ld a,0 
9993 77				ld (hl),a 
9994			 
9994			 
9994 3e 28		            LD   A, display_row_2 
9996			;            CALL fLCD_Pos       ;Position cursor to location in A 
9996 11 66 99		            LD   DE, str1 
9999 cd c1 8a			call str_at_display 
999c			 
999c			;            CALL fLCD_Str       ;Display string pointed to by DE 
999c			cloop:	 
999c 3e 50		            LD   A, display_row_3 
999e			;            CALL fLCD_Pos       ;Position cursor to location in A 
999e 11 79 99		            LD   DE, clear 
99a1			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
99a1 cd c1 8a				call str_at_display 
99a4 3e 78			ld a, display_row_4 
99a6 11 d6 99			ld de, prompt 
99a9			 
99a9 cd c1 8a				call str_at_display 
99ac cd d1 8a			call update_display 
99af			 
99af 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
99b1 16 0a			ld d, 10 
99b3 21 c1 e2			ld hl, scratch	 
99b6 cd 08 8d			call input_str 
99b9			 
99b9			;	call clear_display 
99b9			;'	call update_display 
99b9			 
99b9 3e 00		            LD   A, display_row_1 
99bb			;            CALL fLCD_Pos       ;Position cursor to location in A 
99bb 11 79 99		            LD   DE, clear 
99be cd c1 8a				call str_at_display 
99c1			;            CALL fLCD_Str       ;Display string pointed to by DE 
99c1 3e 00		            LD   A, display_row_1 
99c3			;            CALL fLCD_Pos       ;Position cursor to location in A 
99c3 11 c1 e2		            LD   DE, scratch 
99c6			;            CALL fLCD_Str       ;Display string pointed to by DE 
99c6 cd c1 8a				call str_at_display 
99c9 cd d1 8a			call update_display 
99cc			 
99cc 3e 00				ld a,0 
99ce 21 c1 e2			ld hl, scratch 
99d1 77				ld (hl),a 
99d2			 
99d2 00				nop 
99d3 c3 9c 99			jp cloop 
99d6			 
99d6			 
99d6			 
99d6			; OS Prompt 
99d6			 
99d6 .. 00		prompt: db ">",0 
99d8 .. 00		endprg: db "?",0 
99da			 
99da			 
99da			; handy next page prompt 
99da			next_page_prompt: 
99da e5				push hl 
99db d5				push de 
99dc f5				push af 
99dd c5				push bc 
99de			 
99de 3e 9f			ld a,display_row_4 + display_cols - 1 
99e0 11 d8 99		        ld de, endprg 
99e3 cd c1 8a			call str_at_display 
99e6 cd d1 8a			call update_display 
99e9 cd fc dc			call cin_wait 
99ec c1				pop bc 
99ed f1				pop af 
99ee d1				pop de 
99ef e1				pop hl 
99f0			 
99f0			 
99f0 c9				ret 
99f1			 
99f1			 
99f1			; forth parser 
99f1			 
99f1			; My forth kernel 
99f1			include "forth_kernel.asm" 
99f1			; 
99f1			; kernel to the forth OS 
99f1			 
99f1			DS_TYPE_STR: equ 1     ; string type 
99f1			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
99f1			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
99f1			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
99f1			 
99f1			FORTH_PARSEV1: equ 0 
99f1			FORTH_PARSEV2: equ 0 
99f1			FORTH_PARSEV3: equ 0 
99f1			FORTH_PARSEV4: equ 0 
99f1			FORTH_PARSEV5: equ 1 
99f1			 
99f1			;if FORTH_PARSEV5 
99f1			;	FORTH_END_BUFFER: equ 0 
99f1			;else 
99f1			FORTH_END_BUFFER: equ 127 
99f1			;endif 
99f1			 
99f1			FORTH_TRUE: equ 1 
99f1			FORTH_FALSE: equ 0 
99f1			 
99f1			if FORTH_PARSEV4 
99f1			include "forth_stackops.asm" 
99f1			endif 
99f1			 
99f1			if FORTH_PARSEV5 
99f1			include "forth_stackopsv5.asm" 
99f1			 
99f1			; Stack operations for v5 parser on wards 
99f1			; * DATA stack 
99f1			; * LOOP stack 
99f1			; * RETURN stack 
99f1			 
99f1			 
99f1			 
99f1			FORTH_CHK_DSP_UNDER: macro 
99f1				push hl 
99f1				push de 
99f1				ld hl,(cli_data_sp) 
99f1				ld de, cli_data_stack 
99f1				call cmp16 
99f1				jp c, fault_dsp_under 
99f1				pop de 
99f1				pop hl 
99f1				endm 
99f1			 
99f1			 
99f1			FORTH_CHK_RSP_UNDER: macro 
99f1				push hl 
99f1				push de 
99f1				ld hl,(cli_ret_sp) 
99f1				ld de, cli_ret_stack 
99f1				call cmp16 
99f1				jp c, fault_rsp_under 
99f1				pop de 
99f1				pop hl 
99f1				endm 
99f1			 
99f1			FORTH_CHK_LOOP_UNDER: macro 
99f1				push hl 
99f1				push de 
99f1				ld hl,(cli_loop_sp) 
99f1				ld de, cli_loop_stack 
99f1				call cmp16 
99f1				jp c, fault_loop_under 
99f1				pop de 
99f1				pop hl 
99f1				endm 
99f1			 
99f1			FORTH_ERR_TOS_NOTSTR: macro 
99f1				; TOSO might need more for checks when used 
99f1				push af 
99f1				ld a,(hl) 
99f1				cp DS_TYPE_STR 
99f1				jp nz, type_faultn   
99f1				pop af 
99f1				endm 
99f1			 
99f1			FORTH_ERR_TOS_NOTNUM: macro 
99f1				push af 
99f1				ld a,(hl) 
99f1				cp DS_TYPE_INUM 
99f1				jp nz, type_faultn   
99f1				pop af 
99f1				endm 
99f1			 
99f1			 
99f1			; increase data stack pointer and save hl to it 
99f1				 
99f1			FORTH_DSP_NEXT: macro 
99f1				call macro_forth_dsp_next 
99f1				endm 
99f1			 
99f1			 
99f1			macro_forth_dsp_next: 
99f1				if DEBUG_FORTH_STACK_GUARD 
99f1 cd 77 d9				call check_stacks 
99f4				endif 
99f4 e5				push hl 
99f5 d5				push de 
99f6 eb				ex de,hl 
99f7 2a ee e9			ld hl,(cli_data_sp) 
99fa 23				inc hl 
99fb 23				inc hl 
99fc			 
99fc			; PARSEV5 
99fc 23				inc hl 
99fd 22 ee e9			ld (cli_data_sp),hl 
9a00 73				ld (hl), e 
9a01 23				inc hl 
9a02 72				ld (hl), d 
9a03 d1				pop de 
9a04 e1				pop hl 
9a05				if DEBUG_FORTH_STACK_GUARD 
9a05 cd 77 d9				call check_stacks 
9a08				endif 
9a08 c9				ret 
9a09			 
9a09			 
9a09			; increase ret stack pointer and save hl to it 
9a09				 
9a09			FORTH_RSP_NEXT: macro 
9a09				call macro_forth_rsp_next 
9a09				endm 
9a09			 
9a09			macro_forth_rsp_next: 
9a09				if DEBUG_FORTH_STACK_GUARD 
9a09 cd 77 d9				call check_stacks 
9a0c				endif 
9a0c e5				push hl 
9a0d d5				push de 
9a0e eb				ex de,hl 
9a0f 2a f2 e9			ld hl,(cli_ret_sp) 
9a12 23				inc hl 
9a13 23				inc hl 
9a14 22 f2 e9			ld (cli_ret_sp),hl 
9a17 73				ld (hl), e 
9a18 23				inc hl 
9a19 72				ld (hl), d 
9a1a d1				pop de 
9a1b e1				pop hl 
9a1c				if DEBUG_FORTH_STACK_GUARD 
9a1c cd 77 d9				call check_stacks 
9a1f				endif 
9a1f c9				ret 
9a20			 
9a20			; get current ret stack pointer and save to hl  
9a20				 
9a20			FORTH_RSP_TOS: macro 
9a20				call macro_forth_rsp_tos 
9a20				endm 
9a20			 
9a20			macro_forth_rsp_tos: 
9a20				;push de 
9a20 2a f2 e9			ld hl,(cli_ret_sp) 
9a23 cd 5b 9a			call loadhlptrtohl 
9a26				;ld e, (hl) 
9a26				;inc hl 
9a26				;ld d, (hl) 
9a26				;ex de, hl 
9a26					if DEBUG_FORTH_WORDS 
9a26			;			DMARK "RST" 
9a26						CALLMONITOR 
9a26 cd 6f ee			call debug_vector  
9a29				endm  
# End of macro CALLMONITOR
9a29					endif 
9a29				;pop de 
9a29 c9				ret 
9a2a			 
9a2a			; pop ret stack pointer 
9a2a				 
9a2a			FORTH_RSP_POP: macro 
9a2a				call macro_forth_rsp_pop 
9a2a				endm 
9a2a			 
9a2a			 
9a2a			macro_forth_rsp_pop: 
9a2a				if DEBUG_FORTH_STACK_GUARD 
9a2a			;		DMARK "RPP" 
9a2a cd 77 d9				call check_stacks 
9a2d					FORTH_CHK_RSP_UNDER 
9a2d e5				push hl 
9a2e d5				push de 
9a2f 2a f2 e9			ld hl,(cli_ret_sp) 
9a32 11 ac e9			ld de, cli_ret_stack 
9a35 cd f9 8c			call cmp16 
9a38 da 8b da			jp c, fault_rsp_under 
9a3b d1				pop de 
9a3c e1				pop hl 
9a3d				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a3d				endif 
9a3d e5				push hl 
9a3e 2a f2 e9			ld hl,(cli_ret_sp) 
9a41			 
9a41			 
9a41				if FORTH_ENABLE_FREE 
9a41			 
9a41					; get pointer 
9a41			 
9a41					push de 
9a41					push hl 
9a41			 
9a41					ld e, (hl) 
9a41					inc hl 
9a41					ld d, (hl) 
9a41			 
9a41					ex de, hl 
9a41					call free 
9a41			 
9a41					pop hl 
9a41					pop de 
9a41			 
9a41			 
9a41				endif 
9a41			 
9a41			 
9a41 2b				dec hl 
9a42 2b				dec hl 
9a43 22 f2 e9			ld (cli_ret_sp), hl 
9a46				; do stack underflow checks 
9a46 e1				pop hl 
9a47				if DEBUG_FORTH_STACK_GUARD 
9a47 cd 77 d9				call check_stacks 
9a4a					FORTH_CHK_RSP_UNDER 
9a4a e5				push hl 
9a4b d5				push de 
9a4c 2a f2 e9			ld hl,(cli_ret_sp) 
9a4f 11 ac e9			ld de, cli_ret_stack 
9a52 cd f9 8c			call cmp16 
9a55 da 8b da			jp c, fault_rsp_under 
9a58 d1				pop de 
9a59 e1				pop hl 
9a5a				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a5a				endif 
9a5a c9				ret 
9a5b			 
9a5b			 
9a5b			 
9a5b			; routine to load word pointed to by hl into hl 
9a5b			 
9a5b			loadhlptrtohl: 
9a5b			 
9a5b d5				push de 
9a5c 5e				ld e, (hl) 
9a5d 23				inc hl 
9a5e 56				ld d, (hl) 
9a5f eb				ex de, hl 
9a60 d1				pop de 
9a61			 
9a61 c9				ret 
9a62			 
9a62			 
9a62			 
9a62			 
9a62			 
9a62			; push a number held in HL onto the data stack 
9a62			; entry point for pushing a value when already in hl used in function above 
9a62			 
9a62			forth_push_numhl: 
9a62			 
9a62 e5				push hl    ; save value to push 
9a63			 
9a63			if DEBUG_FORTH_PUSH 
9a63				; see if disabled 
9a63			 
9a63			 
9a63 f5				push af 
9a64 3a 6f ee			ld a,(debug_vector) 
9a67 fe c9			cp $c9   ; ret 
9a69			;	ld a, (os_view_disable) 
9a69			;	cp '*' 
9a69 28 34			jr z, .pskip2 
9a6b e5				push hl 
9a6c e5			push hl 
9a6d cd ae 8a			call clear_display 
9a70 e1			pop hl 
9a71 7c				ld a,h 
9a72 21 c6 e5			ld hl, os_word_scratch 
9a75 cd e4 8e			call hexout 
9a78 e1				pop hl 
9a79 7d				ld a,l 
9a7a 21 c8 e5			ld hl, os_word_scratch+2 
9a7d cd e4 8e			call hexout 
9a80			 
9a80 21 ca e5			ld hl, os_word_scratch+4 
9a83 3e 00			ld a,0 
9a85 77				ld (hl),a 
9a86 11 c6 e5			ld de,os_word_scratch 
9a89 3e 28				ld a, display_row_2 
9a8b cd c1 8a				call str_at_display 
9a8e 11 85 cb			ld de, .push_num 
9a91 3e 00			ld a, display_row_1 
9a93			 
9a93 cd c1 8a				call str_at_display 
9a96			 
9a96			 
9a96 cd d1 8a			call update_display 
9a99 cd f1 89			call delay1s 
9a9c cd f1 89			call delay1s 
9a9f			.pskip2:  
9a9f			 
9a9f f1				pop af 
9aa0			endif	 
9aa0			 
9aa0			 
9aa0				FORTH_DSP_NEXT 
9aa0 cd f1 99			call macro_forth_dsp_next 
9aa3				endm 
# End of macro FORTH_DSP_NEXT
9aa3			 
9aa3 2a ee e9			ld hl, (cli_data_sp) 
9aa6			 
9aa6				; save item type 
9aa6 3e 02			ld a,  DS_TYPE_INUM 
9aa8 77				ld (hl), a 
9aa9 23				inc hl 
9aaa			 
9aaa				; get word off stack 
9aaa d1				pop de 
9aab 7b				ld a,e 
9aac 77				ld (hl), a 
9aad 23				inc hl 
9aae 7a				ld a,d 
9aaf 77				ld (hl), a 
9ab0			 
9ab0			if DEBUG_FORTH_PUSH 
9ab0 2b				dec hl 
9ab1 2b				dec hl 
9ab2 2b				dec hl 
9ab3						DMARK "PH5" 
9ab3 f5				push af  
9ab4 3a c8 9a			ld a, (.dmark)  
9ab7 32 6b ee			ld (debug_mark),a  
9aba 3a c9 9a			ld a, (.dmark+1)  
9abd 32 6c ee			ld (debug_mark+1),a  
9ac0 3a ca 9a			ld a, (.dmark+2)  
9ac3 32 6d ee			ld (debug_mark+2),a  
9ac6 18 03			jr .pastdmark  
9ac8 ..			.dmark: db "PH5"  
9acb f1			.pastdmark: pop af  
9acc			endm  
# End of macro DMARK
9acc				CALLMONITOR 
9acc cd 6f ee			call debug_vector  
9acf				endm  
# End of macro CALLMONITOR
9acf			endif	 
9acf			 
9acf c9				ret 
9ad0			 
9ad0			 
9ad0			; Push a string to stack pointed to by hl 
9ad0			 
9ad0			forth_push_str: 
9ad0			 
9ad0			if DEBUG_FORTH_PUSH 
9ad0						DMARK "PSQ" 
9ad0 f5				push af  
9ad1 3a e5 9a			ld a, (.dmark)  
9ad4 32 6b ee			ld (debug_mark),a  
9ad7 3a e6 9a			ld a, (.dmark+1)  
9ada 32 6c ee			ld (debug_mark+1),a  
9add 3a e7 9a			ld a, (.dmark+2)  
9ae0 32 6d ee			ld (debug_mark+2),a  
9ae3 18 03			jr .pastdmark  
9ae5 ..			.dmark: db "PSQ"  
9ae8 f1			.pastdmark: pop af  
9ae9			endm  
# End of macro DMARK
9ae9				CALLMONITOR 
9ae9 cd 6f ee			call debug_vector  
9aec				endm  
# End of macro CALLMONITOR
9aec			endif	 
9aec			 
9aec			 
9aec			    
9aec e5				push hl 
9aed e5				push hl 
9aee			 
9aee			;	ld a, 0   ; find end of string 
9aee cd 41 90			call strlenz 
9af1			if DEBUG_FORTH_PUSH 
9af1						DMARK "PQ2" 
9af1 f5				push af  
9af2 3a 06 9b			ld a, (.dmark)  
9af5 32 6b ee			ld (debug_mark),a  
9af8 3a 07 9b			ld a, (.dmark+1)  
9afb 32 6c ee			ld (debug_mark+1),a  
9afe 3a 08 9b			ld a, (.dmark+2)  
9b01 32 6d ee			ld (debug_mark+2),a  
9b04 18 03			jr .pastdmark  
9b06 ..			.dmark: db "PQ2"  
9b09 f1			.pastdmark: pop af  
9b0a			endm  
# End of macro DMARK
9b0a				CALLMONITOR 
9b0a cd 6f ee			call debug_vector  
9b0d				endm  
# End of macro CALLMONITOR
9b0d			endif	 
9b0d eb				ex de, hl 
9b0e e1				pop hl   ; get ptr to start of string 
9b0f			if DEBUG_FORTH_PUSH 
9b0f						DMARK "PQ3" 
9b0f f5				push af  
9b10 3a 24 9b			ld a, (.dmark)  
9b13 32 6b ee			ld (debug_mark),a  
9b16 3a 25 9b			ld a, (.dmark+1)  
9b19 32 6c ee			ld (debug_mark+1),a  
9b1c 3a 26 9b			ld a, (.dmark+2)  
9b1f 32 6d ee			ld (debug_mark+2),a  
9b22 18 03			jr .pastdmark  
9b24 ..			.dmark: db "PQ3"  
9b27 f1			.pastdmark: pop af  
9b28			endm  
# End of macro DMARK
9b28				CALLMONITOR 
9b28 cd 6f ee			call debug_vector  
9b2b				endm  
# End of macro CALLMONITOR
9b2b			endif	 
9b2b 19				add hl,de 
9b2c			if DEBUG_FORTH_PUSH 
9b2c						DMARK "PQE" 
9b2c f5				push af  
9b2d 3a 41 9b			ld a, (.dmark)  
9b30 32 6b ee			ld (debug_mark),a  
9b33 3a 42 9b			ld a, (.dmark+1)  
9b36 32 6c ee			ld (debug_mark+1),a  
9b39 3a 43 9b			ld a, (.dmark+2)  
9b3c 32 6d ee			ld (debug_mark+2),a  
9b3f 18 03			jr .pastdmark  
9b41 ..			.dmark: db "PQE"  
9b44 f1			.pastdmark: pop af  
9b45			endm  
# End of macro DMARK
9b45				CALLMONITOR 
9b45 cd 6f ee			call debug_vector  
9b48				endm  
# End of macro CALLMONITOR
9b48			endif	 
9b48			 
9b48 2b				dec hl    ; see if there is an optional trailing double quote 
9b49 7e				ld a,(hl) 
9b4a fe 22			cp '"' 
9b4c 20 03			jr nz, .strnoq 
9b4e 3e 00			ld a, 0      ; get rid of double quote 
9b50 77				ld (hl), a 
9b51 23			.strnoq: inc hl 
9b52			 
9b52 3e 00			ld a, 0 
9b54 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9b55			 
9b55 13				inc de ; add one for the type string 
9b56 13				inc de ; add one for null term??? 
9b57			 
9b57				; tos is get string pointer again 
9b57				; de contains space to allocate 
9b57				 
9b57 d5				push de 
9b58			 
9b58 eb				ex de, hl 
9b59			 
9b59				;push af 
9b59			 
9b59			if DEBUG_FORTH_PUSH 
9b59						DMARK "PHm" 
9b59 f5				push af  
9b5a 3a 6e 9b			ld a, (.dmark)  
9b5d 32 6b ee			ld (debug_mark),a  
9b60 3a 6f 9b			ld a, (.dmark+1)  
9b63 32 6c ee			ld (debug_mark+1),a  
9b66 3a 70 9b			ld a, (.dmark+2)  
9b69 32 6d ee			ld (debug_mark+2),a  
9b6c 18 03			jr .pastdmark  
9b6e ..			.dmark: db "PHm"  
9b71 f1			.pastdmark: pop af  
9b72			endm  
# End of macro DMARK
9b72				CALLMONITOR 
9b72 cd 6f ee			call debug_vector  
9b75				endm  
# End of macro CALLMONITOR
9b75			endif	 
9b75 cd b6 90			call malloc	; on ret hl now contains allocated memory 
9b78				if DEBUG_FORTH_MALLOC_GUARD 
9b78 cc dd cb				call z,malloc_error 
9b7b				endif 
9b7b			 
9b7b				 
9b7b c1				pop bc    ; get length 
9b7c d1				pop de   ;  get string start    
9b7d			 
9b7d				; hl has destination from malloc 
9b7d			 
9b7d eb				ex de, hl    ; prep for ldir 
9b7e			 
9b7e d5				push de   ; save malloc area for DSP later 
9b7f				;push hl   ; save malloc area for DSP later 
9b7f			 
9b7f			if DEBUG_FORTH_PUSH 
9b7f						DMARK "PHc" 
9b7f f5				push af  
9b80 3a 94 9b			ld a, (.dmark)  
9b83 32 6b ee			ld (debug_mark),a  
9b86 3a 95 9b			ld a, (.dmark+1)  
9b89 32 6c ee			ld (debug_mark+1),a  
9b8c 3a 96 9b			ld a, (.dmark+2)  
9b8f 32 6d ee			ld (debug_mark+2),a  
9b92 18 03			jr .pastdmark  
9b94 ..			.dmark: db "PHc"  
9b97 f1			.pastdmark: pop af  
9b98			endm  
# End of macro DMARK
9b98				CALLMONITOR 
9b98 cd 6f ee			call debug_vector  
9b9b				endm  
# End of macro CALLMONITOR
9b9b			endif	 
9b9b			 
9b9b			 
9b9b ed b0			ldir 
9b9d			 
9b9d			 
9b9d				; push malloc to data stack     macro?????  
9b9d			 
9b9d				FORTH_DSP_NEXT 
9b9d cd f1 99			call macro_forth_dsp_next 
9ba0				endm 
# End of macro FORTH_DSP_NEXT
9ba0			 
9ba0				; save value and type 
9ba0			 
9ba0 2a ee e9			ld hl, (cli_data_sp) 
9ba3			 
9ba3				; save item type 
9ba3 3e 01			ld a,  DS_TYPE_STR 
9ba5 77				ld (hl), a 
9ba6 23				inc hl 
9ba7			 
9ba7				; get malloc word off stack 
9ba7 d1				pop de 
9ba8 73				ld (hl), e 
9ba9 23				inc hl 
9baa 72				ld (hl), d 
9bab			 
9bab			 
9bab			 
9bab			if DEBUG_FORTH_PUSH 
9bab 2a ee e9			ld hl, (cli_data_sp) 
9bae						DMARK "PHS" 
9bae f5				push af  
9baf 3a c3 9b			ld a, (.dmark)  
9bb2 32 6b ee			ld (debug_mark),a  
9bb5 3a c4 9b			ld a, (.dmark+1)  
9bb8 32 6c ee			ld (debug_mark+1),a  
9bbb 3a c5 9b			ld a, (.dmark+2)  
9bbe 32 6d ee			ld (debug_mark+2),a  
9bc1 18 03			jr .pastdmark  
9bc3 ..			.dmark: db "PHS"  
9bc6 f1			.pastdmark: pop af  
9bc7			endm  
# End of macro DMARK
9bc7				CALLMONITOR 
9bc7 cd 6f ee			call debug_vector  
9bca				endm  
# End of macro CALLMONITOR
9bca			;	ex de,hl 
9bca			endif	 
9bca				; in case of spaces, skip the ptr past the copied string 
9bca				;pop af 
9bca				;ld (cli_origptr),hl 
9bca			 
9bca c9				ret 
9bcb			 
9bcb			 
9bcb			 
9bcb			; TODO ascii push input onto stack given hl to start of input 
9bcb			 
9bcb			; identify type 
9bcb			; if starts with a " then a string 
9bcb			; otherwise it is a number 
9bcb			;  
9bcb			; if a string 
9bcb			;     scan for ending " to get length of string to malloc for + 1 
9bcb			;     malloc 
9bcb			;     put pointer to string on stack first byte flags as string 
9bcb			; 
9bcb			; else a number 
9bcb			;    look for number format identifier 
9bcb			;    $xx hex 
9bcb			;    %xxxxx bin 
9bcb			;    xxxxx decimal 
9bcb			;    convert number to 16bit word.  
9bcb			;    malloc word + 1 with flag to identiy as num 
9bcb			;    put pointer to number on stack 
9bcb			;   
9bcb			;  
9bcb			  
9bcb			forth_apush: 
9bcb				; kernel push 
9bcb			 
9bcb			if DEBUG_FORTH_PUSH 
9bcb						DMARK "PSH" 
9bcb f5				push af  
9bcc 3a e0 9b			ld a, (.dmark)  
9bcf 32 6b ee			ld (debug_mark),a  
9bd2 3a e1 9b			ld a, (.dmark+1)  
9bd5 32 6c ee			ld (debug_mark+1),a  
9bd8 3a e2 9b			ld a, (.dmark+2)  
9bdb 32 6d ee			ld (debug_mark+2),a  
9bde 18 03			jr .pastdmark  
9be0 ..			.dmark: db "PSH"  
9be3 f1			.pastdmark: pop af  
9be4			endm  
# End of macro DMARK
9be4				CALLMONITOR 
9be4 cd 6f ee			call debug_vector  
9be7				endm  
# End of macro CALLMONITOR
9be7			endif	 
9be7				; identify input type 
9be7			 
9be7 7e				ld a,(hl) 
9be8			 
9be8 fe 23			cp '#' 
9bea ca 24 9c			jp z, .fapdec 
9bed			 
9bed			 
9bed fe 22			cp '"' 
9bef 28 0a			jr z, .fapstr 
9bf1 fe 24			cp '$' 
9bf3 ca 1b 9c			jp z, .faphex 
9bf6 fe 25			cp '%' 
9bf8 ca 03 9c			jp z, .fapbin 
9bfb			;	cp 'b' 
9bfb			;	jp z, .fabin 
9bfb				; else decimal 
9bfb			 
9bfb				; TODO do decimal conversion 
9bfb				; decimal is stored as a 16bit word 
9bfb			 
9bfb				; by default everything is a string if type is not detected 
9bfb			.fapstr: ; 
9bfb fe 22			cp '"' 
9bfd 20 01			jr nz, .strnoqu 
9bff 23				inc hl 
9c00			.strnoqu: 
9c00 c3 d0 9a			jp forth_push_str 
9c03			 
9c03			 
9c03			 
9c03			.fapbin:    ; push a binary string.  
9c03 11 00 00			ld de, 0   ; hold a 16bit value 
9c06			 
9c06 23			.fapbinshift:	inc hl  
9c07 7e				ld a,(hl) 
9c08 fe 00			cp 0     ; done scanning  
9c0a 28 0b			jr z, .fapbdone  	; got it in HL so push  
9c0c			 
9c0c				; left shift de 
9c0c eb				ex de, hl	 
9c0d 29				add hl, hl 
9c0e			 
9c0e				; is 1 
9c0e fe 31			cp '1' 
9c10 20 02			jr nz, .binzero 
9c12 cb 4d			bit 1, l 
9c14			.binzero: 
9c14 eb				ex de, hl	 ; save current de 
9c15 18 ef			jr .fapbinshift 
9c17			 
9c17			.fapbdone: 
9c17 eb				ex de, hl 
9c18 c3 62 9a			jp forth_push_numhl 
9c1b			 
9c1b			 
9c1b			.faphex:   ; hex is always stored as a 16bit word 
9c1b				; skip number prefix 
9c1b 23				inc hl 
9c1c				; turn ascii into number 
9c1c cd 9a 8f			call get_word_hl	; ret 16bit word in hl 
9c1f			 
9c1f c3 62 9a			jp forth_push_numhl 
9c22			 
9c22 00				 nop 
9c23			 
9c23			.fabin:   ; TODO bin conversion 
9c23			 
9c23			 
9c23 c9				ret 
9c24			.fapdec:	 
9c24				; string to dec conversion 
9c24 23				inc hl 
9c25 eb				ex de, hl 
9c26 cd d8 8f			call string_to_uint16 
9c29 c3 62 9a			jp forth_push_numhl 
9c2c c9				ret 
9c2d				 
9c2d			;atoui_16: 
9c2d			 
9c2d			; get either a string ptr or a 16bit word from the data stack 
9c2d			 
9c2d			FORTH_DSP: macro 
9c2d				call macro_forth_dsp 
9c2d				endm 
9c2d			 
9c2d			macro_forth_dsp: 
9c2d				; data stack pointer points to current word on tos 
9c2d			 
9c2d 2a ee e9			ld hl,(cli_data_sp) 
9c30			 
9c30				if DEBUG_FORTH_PUSH 
9c30						DMARK "DSP" 
9c30 f5				push af  
9c31 3a 45 9c			ld a, (.dmark)  
9c34 32 6b ee			ld (debug_mark),a  
9c37 3a 46 9c			ld a, (.dmark+1)  
9c3a 32 6c ee			ld (debug_mark+1),a  
9c3d 3a 47 9c			ld a, (.dmark+2)  
9c40 32 6d ee			ld (debug_mark+2),a  
9c43 18 03			jr .pastdmark  
9c45 ..			.dmark: db "DSP"  
9c48 f1			.pastdmark: pop af  
9c49			endm  
# End of macro DMARK
9c49			 
9c49 cd 10 cc				call display_data_sp 
9c4c				;call break_point_state 
9c4c				;rst 030h 
9c4c				CALLMONITOR 
9c4c cd 6f ee			call debug_vector  
9c4f				endm  
# End of macro CALLMONITOR
9c4f				endif 
9c4f			 
9c4f c9				ret 
9c50			 
9c50			; return hl to start of value on stack 
9c50			 
9c50			FORTH_DSP_VALUE: macro 
9c50				call macro_forth_dsp_value 
9c50				endm 
9c50			 
9c50			macro_forth_dsp_value: 
9c50			 
9c50				FORTH_DSP 
9c50 cd 2d 9c			call macro_forth_dsp 
9c53				endm 
# End of macro FORTH_DSP
9c53			 
9c53 d5				push de 
9c54			 
9c54 23				inc hl ; skip type 
9c55			 
9c55 5e				ld e, (hl) 
9c56 23				inc hl 
9c57 56				ld d, (hl) 
9c58 eb				ex de,hl  
9c59			 
9c59 d1				pop de 
9c5a			 
9c5a c9				ret 
9c5b			 
9c5b			; return hl to start of value to second item on stack 
9c5b			 
9c5b			FORTH_DSP_VALUEM1: macro 
9c5b				call macro_forth_dsp_value_m1 
9c5b				endm 
9c5b			 
9c5b			macro_forth_dsp_value_m1: 
9c5b			 
9c5b				FORTH_DSP 
9c5b cd 2d 9c			call macro_forth_dsp 
9c5e				endm 
# End of macro FORTH_DSP
9c5e			 
9c5e 2b				dec hl 
9c5f 2b				dec hl 
9c60			;	dec hl 
9c60			 
9c60 d5				push de 
9c61			 
9c61 5e				ld e, (hl) 
9c62 23				inc hl 
9c63 56				ld d, (hl) 
9c64 eb				ex de,hl  
9c65			 
9c65 d1				pop de 
9c66			 
9c66 c9				ret 
9c67			 
9c67				 
9c67			 
9c67			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9c67			 
9c67			FORTH_DSP_POP: macro 
9c67				call macro_forth_dsp_pop 
9c67				endm 
9c67			 
9c67			 
9c67			; get the tos data type 
9c67			 
9c67			FORTH_DSP_TYPE:   macro 
9c67			 
9c67				;FORTH_DSP_VALUE 
9c67				FORTH_DSP 
9c67				 
9c67				; hl points to value 
9c67				; check type 
9c67			 
9c67				ld a,(hl) 
9c67			 
9c67				endm 
9c67			 
9c67			; load the tos value into hl 
9c67			 
9c67			 
9c67			FORTH_DSP_VALUEHL:  macro 
9c67				call macro_dsp_valuehl 
9c67				endm 
9c67			 
9c67			 
9c67			 
9c67			macro_dsp_valuehl: 
9c67				FORTH_DSP_VALUE 
9c67 cd 50 9c			call macro_forth_dsp_value 
9c6a				endm 
# End of macro FORTH_DSP_VALUE
9c6a			 
9c6a				;FORTH_ERR_TOS_NOTNUM 
9c6a			 
9c6a				;inc hl   ; skip type id 
9c6a			 
9c6a			;	push de 
9c6a			; 
9c6a			;	ld e, (hl) 
9c6a			;	inc hl 
9c6a			;	ld d, (hl) 
9c6a			;	ex de,hl  
9c6a			 
9c6a			;	pop de 
9c6a			 
9c6a				if DEBUG_FORTH_PUSH 
9c6a						DMARK "DVL" 
9c6a f5				push af  
9c6b 3a 7f 9c			ld a, (.dmark)  
9c6e 32 6b ee			ld (debug_mark),a  
9c71 3a 80 9c			ld a, (.dmark+1)  
9c74 32 6c ee			ld (debug_mark+1),a  
9c77 3a 81 9c			ld a, (.dmark+2)  
9c7a 32 6d ee			ld (debug_mark+2),a  
9c7d 18 03			jr .pastdmark  
9c7f ..			.dmark: db "DVL"  
9c82 f1			.pastdmark: pop af  
9c83			endm  
# End of macro DMARK
9c83				CALLMONITOR 
9c83 cd 6f ee			call debug_vector  
9c86				endm  
# End of macro CALLMONITOR
9c86				endif 
9c86 c9				ret 
9c87			 
9c87			forth_apushstrhl:      
9c87				; push of string requires use of cli_origptr 
9c87				; bodge use 
9c87			 
9c87				; get current cli_origptr, save, update with temp pointer  
9c87 ed 5b 3e ea		ld de, (cli_origptr) 
9c8b 22 3e ea			ld (cli_origptr), hl 
9c8e d5				push de 
9c8f cd cb 9b			call forth_apush 
9c92 d1				pop de 
9c93 ed 53 3e ea		ld (cli_origptr), de 
9c97 c9			        ret	 
9c98			 
9c98			 
9c98			; increase loop stack pointer and save hl to it 
9c98				 
9c98			FORTH_LOOP_NEXT: macro 
9c98				call macro_forth_loop_next 
9c98				;nop 
9c98				endm 
9c98			 
9c98			macro_forth_loop_next: 
9c98				if DEBUG_FORTH_STACK_GUARD 
9c98 cd 77 d9				call check_stacks 
9c9b				endif 
9c9b e5				push hl 
9c9c d5				push de 
9c9d eb				ex de,hl 
9c9e 2a f0 e9			ld hl,(cli_loop_sp) 
9ca1 23				inc hl 
9ca2 23				inc hl 
9ca3					if DEBUG_FORTH_WORDS 
9ca3						DMARK "LNX" 
9ca3 f5				push af  
9ca4 3a b8 9c			ld a, (.dmark)  
9ca7 32 6b ee			ld (debug_mark),a  
9caa 3a b9 9c			ld a, (.dmark+1)  
9cad 32 6c ee			ld (debug_mark+1),a  
9cb0 3a ba 9c			ld a, (.dmark+2)  
9cb3 32 6d ee			ld (debug_mark+2),a  
9cb6 18 03			jr .pastdmark  
9cb8 ..			.dmark: db "LNX"  
9cbb f1			.pastdmark: pop af  
9cbc			endm  
# End of macro DMARK
9cbc						CALLMONITOR 
9cbc cd 6f ee			call debug_vector  
9cbf				endm  
# End of macro CALLMONITOR
9cbf					endif 
9cbf 22 f0 e9			ld (cli_loop_sp),hl 
9cc2 73				ld (hl), e 
9cc3 23				inc hl 
9cc4 72				ld (hl), d 
9cc5 d1				pop de    ; been reversed so save a swap on restore 
9cc6 e1				pop hl 
9cc7				if DEBUG_FORTH_STACK_GUARD 
9cc7 cd 77 d9				call check_stacks 
9cca				endif 
9cca c9				ret 
9ccb			 
9ccb			; get current ret stack pointer and save to hl  
9ccb				 
9ccb			FORTH_LOOP_TOS: macro 
9ccb				call macro_forth_loop_tos 
9ccb				endm 
9ccb			 
9ccb			macro_forth_loop_tos: 
9ccb d5				push de 
9ccc 2a f0 e9			ld hl,(cli_loop_sp) 
9ccf 5e				ld e, (hl) 
9cd0 23				inc hl 
9cd1 56				ld d, (hl) 
9cd2 eb				ex de, hl 
9cd3 d1				pop de 
9cd4 c9				ret 
9cd5			 
9cd5			; pop loop stack pointer 
9cd5				 
9cd5			FORTH_LOOP_POP: macro 
9cd5				call macro_forth_loop_pop 
9cd5				endm 
9cd5			 
9cd5			 
9cd5			macro_forth_loop_pop: 
9cd5				if DEBUG_FORTH_STACK_GUARD 
9cd5					DMARK "LPP" 
9cd5 f5				push af  
9cd6 3a ea 9c			ld a, (.dmark)  
9cd9 32 6b ee			ld (debug_mark),a  
9cdc 3a eb 9c			ld a, (.dmark+1)  
9cdf 32 6c ee			ld (debug_mark+1),a  
9ce2 3a ec 9c			ld a, (.dmark+2)  
9ce5 32 6d ee			ld (debug_mark+2),a  
9ce8 18 03			jr .pastdmark  
9cea ..			.dmark: db "LPP"  
9ced f1			.pastdmark: pop af  
9cee			endm  
# End of macro DMARK
9cee cd 77 d9				call check_stacks 
9cf1					FORTH_CHK_LOOP_UNDER 
9cf1 e5				push hl 
9cf2 d5				push de 
9cf3 2a f0 e9			ld hl,(cli_loop_sp) 
9cf6 11 2a e9			ld de, cli_loop_stack 
9cf9 cd f9 8c			call cmp16 
9cfc da 91 da			jp c, fault_loop_under 
9cff d1				pop de 
9d00 e1				pop hl 
9d01				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d01				endif 
9d01 e5				push hl 
9d02 2a f0 e9			ld hl,(cli_loop_sp) 
9d05 2b				dec hl 
9d06 2b				dec hl 
9d07 22 f0 e9			ld (cli_loop_sp), hl 
9d0a				; TODO do stack underflow checks 
9d0a e1				pop hl 
9d0b				if DEBUG_FORTH_STACK_GUARD 
9d0b cd 77 d9				call check_stacks 
9d0e					FORTH_CHK_LOOP_UNDER 
9d0e e5				push hl 
9d0f d5				push de 
9d10 2a f0 e9			ld hl,(cli_loop_sp) 
9d13 11 2a e9			ld de, cli_loop_stack 
9d16 cd f9 8c			call cmp16 
9d19 da 91 da			jp c, fault_loop_under 
9d1c d1				pop de 
9d1d e1				pop hl 
9d1e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d1e				endif 
9d1e c9				ret 
9d1f			 
9d1f			macro_forth_dsp_pop: 
9d1f			 
9d1f e5				push hl 
9d20			 
9d20				; release malloc data 
9d20			 
9d20				if DEBUG_FORTH_STACK_GUARD 
9d20 cd 77 d9				call check_stacks 
9d23					FORTH_CHK_DSP_UNDER 
9d23 e5				push hl 
9d24 d5				push de 
9d25 2a ee e9			ld hl,(cli_data_sp) 
9d28 11 28 e8			ld de, cli_data_stack 
9d2b cd f9 8c			call cmp16 
9d2e da 85 da			jp c, fault_dsp_under 
9d31 d1				pop de 
9d32 e1				pop hl 
9d33				endm 
# End of macro FORTH_CHK_DSP_UNDER
9d33				endif 
9d33				;ld hl,(cli_data_sp) 
9d33			if DEBUG_FORTH_DOT 
9d33				DMARK "DPP" 
9d33 f5				push af  
9d34 3a 48 9d			ld a, (.dmark)  
9d37 32 6b ee			ld (debug_mark),a  
9d3a 3a 49 9d			ld a, (.dmark+1)  
9d3d 32 6c ee			ld (debug_mark+1),a  
9d40 3a 4a 9d			ld a, (.dmark+2)  
9d43 32 6d ee			ld (debug_mark+2),a  
9d46 18 03			jr .pastdmark  
9d48 ..			.dmark: db "DPP"  
9d4b f1			.pastdmark: pop af  
9d4c			endm  
# End of macro DMARK
9d4c				CALLMONITOR 
9d4c cd 6f ee			call debug_vector  
9d4f				endm  
# End of macro CALLMONITOR
9d4f			endif	 
9d4f			 
9d4f			 
9d4f			if FORTH_ENABLE_DSPPOPFREE 
9d4f			 
9d4f				FORTH_DSP 
9d4f cd 2d 9c			call macro_forth_dsp 
9d52				endm 
# End of macro FORTH_DSP
9d52			 
9d52 7e				ld a, (hl) 
9d53 fe 01			cp DS_TYPE_STR 
9d55 20 23			jr nz, .skippopfree 
9d57			 
9d57				FORTH_DSP_VALUEHL 
9d57 cd 67 9c			call macro_dsp_valuehl 
9d5a				endm 
# End of macro FORTH_DSP_VALUEHL
9d5a 00				nop 
9d5b			if DEBUG_FORTH_DOT 
9d5b				DMARK "DPf" 
9d5b f5				push af  
9d5c 3a 70 9d			ld a, (.dmark)  
9d5f 32 6b ee			ld (debug_mark),a  
9d62 3a 71 9d			ld a, (.dmark+1)  
9d65 32 6c ee			ld (debug_mark+1),a  
9d68 3a 72 9d			ld a, (.dmark+2)  
9d6b 32 6d ee			ld (debug_mark+2),a  
9d6e 18 03			jr .pastdmark  
9d70 ..			.dmark: db "DPf"  
9d73 f1			.pastdmark: pop af  
9d74			endm  
# End of macro DMARK
9d74				CALLMONITOR 
9d74 cd 6f ee			call debug_vector  
9d77				endm  
# End of macro CALLMONITOR
9d77			endif	 
9d77 cd 80 91			call free 
9d7a			.skippopfree: 
9d7a				 
9d7a			 
9d7a			endif 
9d7a			 
9d7a			if DEBUG_FORTH_DOT_KEY 
9d7a				DMARK "DP2" 
9d7a				CALLMONITOR 
9d7a			endif	 
9d7a			 
9d7a				; move pointer down 
9d7a			 
9d7a 2a ee e9			ld hl,(cli_data_sp) 
9d7d 2b				dec hl 
9d7e 2b				dec hl 
9d7f			; PARSEV5 
9d7f 2b				dec hl 
9d80 22 ee e9			ld (cli_data_sp), hl 
9d83			 
9d83				if DEBUG_FORTH_STACK_GUARD 
9d83 cd 77 d9				call check_stacks 
9d86					FORTH_CHK_DSP_UNDER 
9d86 e5				push hl 
9d87 d5				push de 
9d88 2a ee e9			ld hl,(cli_data_sp) 
9d8b 11 28 e8			ld de, cli_data_stack 
9d8e cd f9 8c			call cmp16 
9d91 da 85 da			jp c, fault_dsp_under 
9d94 d1				pop de 
9d95 e1				pop hl 
9d96				endm 
# End of macro FORTH_CHK_DSP_UNDER
9d96				endif 
9d96			 
9d96 e1				pop hl 
9d97			 
9d97 c9				ret 
9d98			 
9d98			getwordathl: 
9d98				; hl points to an address 
9d98				; load hl with the word at that address 
9d98			 
9d98 d5				push de 
9d99			 
9d99 5e				ld e, (hl) 
9d9a 23				inc hl 
9d9b 56				ld d, (hl) 
9d9c eb				ex de, hl 
9d9d			 
9d9d d1				pop de 
9d9e c9				ret 
9d9f			 
9d9f			 
9d9f			 
9d9f			 
9d9f			 
9d9f			; eof 
9d9f			 
# End of file forth_stackopsv5.asm
9d9f			endif 
9d9f			 
9d9f			loadwordinhl:	 
9d9f			 
9d9f d5				push de 
9da0			 
9da0 5e				ld e, (hl) 
9da1 23				inc hl 
9da2 56				ld d, (hl) 
9da3 eb				ex de,hl  
9da4			 
9da4 d1				pop de 
9da5			 
9da5 c9				ret 
9da6			 
9da6			user_word_eol:  
9da6				; hl contains the pointer to where to create a linked list item from the end 
9da6				; of the user dict to continue on at the system word dict 
9da6				 
9da6				; poke the stub of the word list linked list to repoint to rom words 
9da6			 
9da6				; stub format 
9da6				; db   word id 
9da6				; dw    link to next word 
9da6			        ; db char length of token 
9da6				; db string + 0 term 
9da6				; db exec code....  
9da6			 
9da6 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9da8 77				ld (hl), a		; word id 
9da9 23				inc hl 
9daa			 
9daa 11 75 9f			ld de, sysdict 
9dad 73				ld (hl), e		; next word link ie system dict 
9dae 23				inc hl 
9daf 72				ld (hl), d		; next word link ie system dict 
9db0 23				inc hl	 
9db1			 
9db1			;	ld (hl), sysdict		; next word link ie system dict 
9db1			;	inc hl 
9db1			;	inc hl 
9db1			 
9db1			;	inc hl 
9db1			;	inc hl 
9db1			 
9db1 3e 02			ld a, 2			; word length is 0 
9db3 77				ld (hl), a	 
9db4 23				inc hl 
9db5			 
9db5 3e 7e			ld a, '~'			; word length is 0 
9db7 77				ld (hl), a	 
9db8 23				inc hl 
9db9 3e 00			ld a, 0			; save empty word 
9dbb 77				ld (hl), a 
9dbc			 
9dbc c9				ret 
9dbd			 
9dbd				 
9dbd			 
9dbd			forthexec_cleanup: 
9dbd				FORTH_RSP_POP 
9dbd cd 2a 9a			call macro_forth_rsp_pop 
9dc0				endm 
# End of macro FORTH_RSP_POP
9dc0 c9				ret 
9dc1			 
9dc1			forth_call_hl: 
9dc1				; taking hl 
9dc1 e5				push hl 
9dc2 c9				ret 
9dc3			 
9dc3			; this is called to reset Forth system but keep existing uwords etc 
9dc3			 
9dc3			forth_warmstart: 
9dc3				; setup stack over/under flow checks 
9dc3				if DEBUG_FORTH_STACK_GUARD 
9dc3 cd 5d d9				call chk_stk_init 
9dc6				endif 
9dc6			 
9dc6				; init stack pointers  - * these stacks go upwards *  
9dc6 21 ac e9			ld hl, cli_ret_stack 
9dc9 22 f2 e9			ld (cli_ret_sp), hl	 
9dcc				; set bottom of stack 
9dcc 3e 00			ld a,0 
9dce 77				ld (hl),a 
9dcf 23				inc hl 
9dd0 77				ld (hl),a 
9dd1			 
9dd1 21 28 e8			ld hl, cli_data_stack 
9dd4 22 ee e9			ld (cli_data_sp), hl	 
9dd7				; set bottom of stack 
9dd7 3e 00			ld a,0 
9dd9 77				ld (hl),a 
9dda 23				inc hl 
9ddb 77				ld (hl),a 
9ddc			 
9ddc 21 2a e9			ld hl, cli_loop_stack 
9ddf 22 f0 e9			ld (cli_loop_sp), hl	 
9de2				; set bottom of stack 
9de2 3e 00			ld a,0 
9de4 77				ld (hl),a 
9de5 23				inc hl 
9de6 77				ld (hl),a 
9de7			 
9de7				; init extent of current open file 
9de7			 
9de7 3e 00			ld a, 0 
9de9 32 6a ea			ld (store_openext), a 
9dec			 
9dec c9				ret 
9ded			 
9ded			 
9ded			 
9ded			; Cold Start - this is called to setup the whole Forth system 
9ded			 
9ded			forth_init: 
9ded			 
9ded				; setup stack over/under flow checks 
9ded			 
9ded			;	if DEBUG_FORTH_STACK_GUARD 
9ded			;		call chk_stk_init 
9ded			;	endif 
9ded			 
9ded				; enable auto display updates (slow.....) 
9ded			 
9ded 3e 01			ld a, 1 
9def 32 3c ea			ld (cli_autodisplay), a 
9df2			 
9df2				; if storage is in use disable long reads for now 
9df2 3e 00			ld a, 0 
9df4 32 75 ea			ld (store_longread), a 
9df7			 
9df7			 
9df7				; show start up screen 
9df7			 
9df7 cd ae 8a			call clear_display 
9dfa			 
9dfa 3e 00			ld a,0 
9dfc 32 5e ea			ld (f_cursor_ptr), a 
9dff			 
9dff				; set start of word list in start of ram - for use when creating user words 
9dff			 
9dff 21 11 dd			ld hl, baseram 
9e02 22 be e5			ld (os_last_new_uword), hl 
9e05 cd a6 9d			call user_word_eol 
9e08				 
9e08			;		call display_data_sp 
9e08			;		call next_page_prompt 
9e08			 
9e08			 
9e08			 
9e08			 
9e08 c9				ret 
9e09			 
9e09 .. 00		.bootforth: db " Forth Kernel Init ",0 
9e1d			 
9e1d			; TODO push to stack 
9e1d			 
9e1d			;  
9e1d			 
9e1d			if FORTH_PARSEV2 
9e1d			 
9e1d			 
9e1d				include "forth_parserv2.asm" 
9e1d			 
9e1d			endif 
9e1d			 
9e1d			 
9e1d			; parse cli version 1 
9e1d			 
9e1d			if FORTH_PARSEV1 
9e1d			 
9e1d			 
9e1d			 
9e1d			      include "forth_parserv1.asm" 
9e1d			endif 
9e1d				 
9e1d			if FORTH_PARSEV3 
9e1d			 
9e1d			 
9e1d			 
9e1d			      include "forth_parserv3.asm" 
9e1d				include "forth_wordsv3.asm" 
9e1d			endif 
9e1d			 
9e1d			if FORTH_PARSEV4 
9e1d			 
9e1d			 
9e1d			 
9e1d			      include "forth_parserv4.asm" 
9e1d				include "forth_wordsv4.asm" 
9e1d			endif 
9e1d			 
9e1d			if FORTH_PARSEV5 
9e1d			 
9e1d			 
9e1d			 
9e1d			      include "forth_parserv5.asm" 
9e1d			 
9e1d			 
9e1d			; A better parser without using malloc and string copies all over the place.  
9e1d			; Exec in situ should be faster 
9e1d			 
9e1d			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9e1d			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9e1d			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9e1d			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9e1d			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9e1d			WORD_SYS_END: equ 0   ; Opcode for all user words 
9e1d			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9e1d			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9e1d			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9e1d			 
9e1d			; Core word preamble macro 
9e1d			 
9e1d			CWHEAD:   macro nxtword opcode lit len opflags 
9e1d				db WORD_SYS_CORE+opcode             
9e1d				; internal op code number 
9e1d				dw nxtword            
9e1d				; link to next dict word block 
9e1d				db len + 1 
9e1d				; literal length of dict word inc zero term 
9e1d				db lit,0              
9e1d				; literal dict word 
9e1d			        ; TODO db opflags        
9e1d				endm 
9e1d			 
9e1d			 
9e1d			NEXTW: macro  
9e1d				jp macro_next 
9e1d				endm 
9e1d			 
9e1d			macro_next: 
9e1d			if DEBUG_FORTH_PARSE_KEY 
9e1d				DMARK "NXT" 
9e1d				CALLMONITOR 
9e1d			endif	 
9e1d			;	inc hl  ; skip token null term  
9e1d ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e21 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e25 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e28			if DEBUG_FORTH_PARSE_KEY 
9e28				DMARK "}AA" 
9e28				CALLMONITOR 
9e28			endif	 
9e28 c3 2b 9f			jp execnext 
9e2b				;jp exec1 
9e2b			       
9e2b			 
9e2b			 
9e2b			; Another go at the parser to compile  
9e2b			 
9e2b			 
9e2b			; TODO rework parser to change all of the string words to byte tokens 
9e2b			; TODO do a search for  
9e2b			 
9e2b			; TODO first run normal parser to zero term sections 
9e2b			; TODO for each word do a token look up to get the op code 
9e2b			; TODO need some means to flag to the exec that this is a byte code form    
9e2b			 
9e2b			 
9e2b			forthcompile: 
9e2b			 
9e2b			; 
9e2b			; line parse: 
9e2b			;       parse raw input buffer 
9e2b			;       tokenise the words 
9e2b			;       malloc new copy (for looping etc) 
9e2b			;       copy to malloc + current pc in line to start of string and add line term 
9e2b			;       save on new rsp 
9e2b			; 
9e2b			 
9e2b			; hl to point to the line to tokenise 
9e2b			 
9e2b			;	push hl 
9e2b 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e2e			 
9e2e			;	ld a,0		; string term on input 
9e2e			;	call strlent 
9e2e			 
9e2e			;	ld (os_tok_len), hl	 ; save string length 
9e2e			 
9e2e			;if DEBUG_FORTH_TOK 
9e2e			;	ex de,hl		 
9e2e			;endif 
9e2e			 
9e2e			;	pop hl 		; get back string pointer 
9e2e			 
9e2e			if DEBUG_FORTH_TOK 
9e2e						DMARK "TOc" 
9e2e				CALLMONITOR 
9e2e			endif 
9e2e 7e			.cptoken2:    ld a,(hl) 
9e2f 23				inc hl 
9e30 fe 7f			cp FORTH_END_BUFFER 
9e32 28 29			jr z, .cptokendone2 
9e34 fe 00			cp 0 
9e36 28 25			jr z, .cptokendone2 
9e38 fe 22			cp '"' 
9e3a 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9e3c fe 20			cp ' ' 
9e3e 20 ee			jr nz,  .cptoken2 
9e40			 
9e40			; TODO consume comments held between ( and ) 
9e40			 
9e40				; we have a space so change to zero term for dict match later 
9e40 2b				dec hl 
9e41 3e 00			ld a,0 
9e43 77				ld (hl), a 
9e44 23				inc hl 
9e45 18 e7			jr .cptoken2 
9e47				 
9e47			 
9e47			.cptokenstr2: 
9e47				; skip all white space until either eol (because forgot to term) or end double quote 
9e47			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e47				;inc hl ; skip current double quote 
9e47 7e				ld a,(hl) 
9e48 23				inc hl 
9e49 fe 22			cp '"' 
9e4b 28 e1			jr z, .cptoken2 
9e4d fe 7f			cp FORTH_END_BUFFER 
9e4f 28 0c			jr z, .cptokendone2 
9e51 fe 00			cp 0 
9e53 28 08			jr z, .cptokendone2 
9e55 fe 20			cp ' ' 
9e57 28 02			jr z, .cptmp2 
9e59 18 ec			jr .cptokenstr2 
9e5b			 
9e5b			.cptmp2:	; we have a space so change to zero term for dict match later 
9e5b				;dec hl 
9e5b				;ld a,"-"	; TODO remove this when working 
9e5b				;ld (hl), a 
9e5b				;inc hl 
9e5b 18 ea			jr .cptokenstr2 
9e5d			 
9e5d			.cptokendone2: 
9e5d				;inc hl 
9e5d 3e 7f			ld a, FORTH_END_BUFFER 
9e5f 77				ld (hl),a 
9e60 23				inc hl 
9e61 3e 21			ld a, '!' 
9e63 77				ld (hl),a 
9e64			 
9e64 2a c2 e5			ld hl,(os_tok_ptr) 
9e67			         
9e67			if DEBUG_FORTH_TOK 
9e67						DMARK "Tc1" 
9e67				CALLMONITOR 
9e67			endif 
9e67			 
9e67				; push exec string to top of return stack 
9e67				FORTH_RSP_NEXT 
9e67 cd 09 9a			call macro_forth_rsp_next 
9e6a				endm 
# End of macro FORTH_RSP_NEXT
9e6a c9				ret 
9e6b			 
9e6b			; Another go at the parser need to simplify the process 
9e6b			 
9e6b			forthparse: 
9e6b			 
9e6b			; 
9e6b			; line parse: 
9e6b			;       parse raw input buffer 
9e6b			;       tokenise the words 
9e6b			;       malloc new copy (for looping etc) 
9e6b			;       copy to malloc + current pc in line to start of string and add line term 
9e6b			;       save on new rsp 
9e6b			; 
9e6b			 
9e6b			; hl to point to the line to tokenise 
9e6b			 
9e6b			;	push hl 
9e6b 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e6e			 
9e6e			;	ld a,0		; string term on input 
9e6e			;	call strlent 
9e6e			 
9e6e			;	ld (os_tok_len), hl	 ; save string length 
9e6e			 
9e6e			;if DEBUG_FORTH_TOK 
9e6e			;	ex de,hl		 
9e6e			;endif 
9e6e			 
9e6e			;	pop hl 		; get back string pointer 
9e6e			 
9e6e			if DEBUG_FORTH_TOK 
9e6e						DMARK "TOK" 
9e6e				CALLMONITOR 
9e6e			endif 
9e6e 7e			.ptoken2:    ld a,(hl) 
9e6f 23				inc hl 
9e70 fe 7f			cp FORTH_END_BUFFER 
9e72 28 29			jr z, .ptokendone2 
9e74 fe 00			cp 0 
9e76 28 25			jr z, .ptokendone2 
9e78 fe 22			cp '"' 
9e7a 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9e7c fe 20			cp ' ' 
9e7e 20 ee			jr nz,  .ptoken2 
9e80			 
9e80			; TODO consume comments held between ( and ) 
9e80			 
9e80				; we have a space so change to zero term for dict match later 
9e80 2b				dec hl 
9e81 3e 00			ld a,0 
9e83 77				ld (hl), a 
9e84 23				inc hl 
9e85 18 e7			jr .ptoken2 
9e87				 
9e87			 
9e87			.ptokenstr2: 
9e87				; skip all white space until either eol (because forgot to term) or end double quote 
9e87			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e87				;inc hl ; skip current double quote 
9e87 7e				ld a,(hl) 
9e88 23				inc hl 
9e89 fe 22			cp '"' 
9e8b 28 e1			jr z, .ptoken2 
9e8d fe 7f			cp FORTH_END_BUFFER 
9e8f 28 0c			jr z, .ptokendone2 
9e91 fe 00			cp 0 
9e93 28 08			jr z, .ptokendone2 
9e95 fe 20			cp ' ' 
9e97 28 02			jr z, .ptmp2 
9e99 18 ec			jr .ptokenstr2 
9e9b			 
9e9b			.ptmp2:	; we have a space so change to zero term for dict match later 
9e9b				;dec hl 
9e9b				;ld a,"-"	; TODO remove this when working 
9e9b				;ld (hl), a 
9e9b				;inc hl 
9e9b 18 ea			jr .ptokenstr2 
9e9d			 
9e9d			.ptokendone2: 
9e9d				;inc hl 
9e9d 3e 7f			ld a, FORTH_END_BUFFER 
9e9f 77				ld (hl),a 
9ea0 23				inc hl 
9ea1 3e 21			ld a, '!' 
9ea3 77				ld (hl),a 
9ea4			 
9ea4 2a c2 e5			ld hl,(os_tok_ptr) 
9ea7			         
9ea7			if DEBUG_FORTH_TOK 
9ea7						DMARK "TK1" 
9ea7				CALLMONITOR 
9ea7			endif 
9ea7			 
9ea7				; push exec string to top of return stack 
9ea7				FORTH_RSP_NEXT 
9ea7 cd 09 9a			call macro_forth_rsp_next 
9eaa				endm 
# End of macro FORTH_RSP_NEXT
9eaa c9				ret 
9eab			 
9eab			; 
9eab			;	; malloc size + buffer pointer + if is loop flag 
9eab			;	ld hl,(os_tok_len) 		 ; get string length 
9eab			; 
9eab			;	ld a,l 
9eab			; 
9eab			;	cp 0			; we dont want to use a null string 
9eab			;	ret z 
9eab			; 
9eab			;;	add 3    ; prefix malloc with buffer for current word ptr 
9eab			; 
9eab			;	add 5     ; TODO when certain not over writing memory remove 
9eab			; 
9eab			;		 
9eab			; 
9eab			;if DEBUG_FORTH_TOK 
9eab			;			DMARK "TKE" 
9eab			;	CALLMONITOR 
9eab			;endif 
9eab			; 
9eab			;	ld l,a 
9eab			;	ld h,0 
9eab			;;	push hl   ; save required space for the copy later 
9eab			;	call malloc 
9eab			;if DEBUG_FORTH_TOK 
9eab			;			DMARK "TKM" 
9eab			;	CALLMONITOR 
9eab			;endif 
9eab			;	if DEBUG_FORTH_MALLOC_GUARD 
9eab			;		push af 
9eab			;		call ishlzero 
9eab			;;		ld a, l 
9eab			;;		add h 
9eab			;;		cp 0 
9eab			;		pop af 
9eab			;		 
9eab			;		call z,malloc_error 
9eab			;	endif 
9eab			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9eab			; 
9eab			; 
9eab			;if DEBUG_FORTH_TOK 
9eab			;			DMARK "TKR" 
9eab			;	CALLMONITOR 
9eab			;endif 
9eab			; 
9eab			;	FORTH_RSP_NEXT 
9eab			; 
9eab			;	;inc hl	 ; go past current buffer pointer 
9eab			;	;inc hl 
9eab			;	;inc hl   ; and past if loop flag 
9eab			;		; TODO Need to set flag  
9eab			; 
9eab			;	 
9eab			;	 
9eab			;	ex de,hl	; malloc is dest 
9eab			;	ld hl, (os_tok_len) 
9eab			;;	pop bc 
9eab			;	ld c, l                
9eab			;	ld b,0 
9eab			;	ld hl, (os_tok_ptr) 
9eab			; 
9eab			;if DEBUG_FORTH_TOK 
9eab			;			DMARK "TKT" 
9eab			;	CALLMONITOR 
9eab			;endif 
9eab			; 
9eab			;	; do str cpy 
9eab			; 
9eab			;	ldir      ; copy byte in hl to de 
9eab			; 
9eab			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9eab			; 
9eab			;if DEBUG_FORTH_TOK 
9eab			; 
9eab			;			DMARK "TKY" 
9eab			;	CALLMONITOR 
9eab			;endif 
9eab			;	;ld a,0 
9eab			;	;ld a,FORTH_END_BUFFER 
9eab			;	ex de, hl 
9eab			;	;dec hl			 ; go back over the space delim at the end of word 
9eab			;	;ld (hl),a 
9eab			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9eab			;	ld a,FORTH_END_BUFFER 
9eab			;	ld (hl),a 
9eab			;	inc hl 
9eab			;	ld a,FORTH_END_BUFFER 
9eab			;	ld (hl),a 
9eab			; 
9eab			;	; init the malloc area data 
9eab			;	; set pc for in current area 
9eab			;	;ld hl, (os_tok_malloc) 
9eab			;	;inc hl 
9eab			;	;inc hl 
9eab			;	;inc hl 
9eab			;	;ex de,hl 
9eab			;	;ld hl, (os_tok_malloc) 
9eab			;	;ld (hl),e 
9eab			;	;inc hl 
9eab			;	;ld (hl),d 
9eab			; 
9eab			; 
9eab			;	ld hl,(os_tok_malloc) 
9eab			;if DEBUG_FORTH_PARSE_KEY 
9eab			;			DMARK "TKU" 
9eab			;	CALLMONITOR 
9eab			;endif 
9eab			; 
9eab			;	ret 
9eab			 
9eab			forthexec: 
9eab			 
9eab			; line exec: 
9eab			; forth parser 
9eab			 
9eab			; 
9eab			;       get current exec line on rsp 
9eab			 
9eab				FORTH_RSP_TOS 
9eab cd 20 9a			call macro_forth_rsp_tos 
9eae				endm 
# End of macro FORTH_RSP_TOS
9eae			 
9eae			;       restore current pc - hl points to malloc of data 
9eae			 
9eae				;ld e, (hl) 
9eae				;inc hl 
9eae				;ld d, (hl) 
9eae				;ex de,hl 
9eae			 
9eae			 
9eae			exec1: 
9eae 22 c2 e5			ld (os_tok_ptr), hl 
9eb1			 
9eb1				; copy our PC to working vars  
9eb1 22 40 ea			ld (cli_ptr), hl 
9eb4 22 3e ea			ld (cli_origptr), hl 
9eb7			 
9eb7 7e				ld a,(hl) 
9eb8 fe 7f			cp FORTH_END_BUFFER 
9eba c8				ret z 
9ebb			 
9ebb				; skip any nulls 
9ebb			 
9ebb fe 00			cp 0 
9ebd 20 03			jr nz, .execword 
9ebf 23				inc hl 
9ec0 18 ec			jr exec1 
9ec2			 
9ec2			 
9ec2			.execword: 
9ec2			 
9ec2			 
9ec2			 
9ec2			if DEBUG_FORTH_PARSE_KEY 
9ec2						DMARK "KYQ" 
9ec2				CALLMONITOR 
9ec2			endif 
9ec2			;       while at start of word: 
9ec2			; get start of dict (in user area first) 
9ec2			 
9ec2 21 11 dd		ld hl, baseram 
9ec5			;ld hl, sysdict 
9ec5 22 42 ea		ld (cli_nextword),hl 
9ec8			;           match word at pc 
9ec8			;           exec word 
9ec8			;           or push to dsp 
9ec8			;           forward to next token 
9ec8			;           if line term pop rsp and exit 
9ec8			;        
9ec8			 
9ec8			if DEBUG_FORTH_PARSE_KEY 
9ec8						DMARK "KYq" 
9ec8				CALLMONITOR 
9ec8			endif 
9ec8			 
9ec8			; 
9ec8			; word comp 
9ec8			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9ec8			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9ec8			;    move to start of word  
9ec8			;    compare word to cli_token 
9ec8			 
9ec8			.execpnword:	; HL at start of a word in the dictionary to check 
9ec8			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9ec8			;	ld (cli_ptr), hl 
9ec8			 
9ec8 2a 42 ea			ld hl,(cli_nextword) 
9ecb			 
9ecb cd 6e 9f			call forth_tok_next 
9ece			; tok next start here 
9ece			;	; TODO skip compiled symbol for now 
9ece			;	inc hl 
9ece			; 
9ece			;	; save pointer to next word 
9ece			; 
9ece			;	; hl now points to the address of the next word pointer  
9ece			;	ld e, (hl) 
9ece			;	inc hl 
9ece			;	ld d, (hl) 
9ece			;	inc l 
9ece			; 
9ece			;	ex de,hl 
9ece			;if DEBUG_FORTH_PARSE_NEXTWORD 
9ece			;	push bc 
9ece			;	ld bc, (cli_nextword) 
9ece			;			DMARK "NXW" 
9ece			;	CALLMONITOR 
9ece			;	pop bc 
9ece			;endif 
9ece			; tok next end here 
9ece 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9ed1 eb				ex de, hl 
9ed2			 
9ed2			 
9ed2				; save the pointer of the current token - 1 to check against 
9ed2				 
9ed2 22 46 ea			ld (cli_token), hl   
9ed5				; TODO maybe remove below save if no debug 
9ed5				; save token string ptr for any debug later 
9ed5 23				inc hl  
9ed6 22 48 ea			ld (cli_origtoken), hl 
9ed9 2b				dec hl 
9eda				; save pointer to the start of the next dictionay word 
9eda 7e				ld a,(hl)   ; get string length 
9edb 47				ld b,a 
9edc			.execpnwordinc:  
9edc 23				inc hl 
9edd 10 fd			djnz .execpnwordinc 
9edf 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
9ee2			 
9ee2				; now check the word token against the string being parsed 
9ee2			 
9ee2 2a 46 ea			ld hl,(cli_token) 
9ee5 23				inc hl     ; skip string length (use zero term instead to end) 
9ee6 22 46 ea			ld (cli_token), hl 
9ee9			 
9ee9			if DEBUG_FORTH_PARSE_KEY 
9ee9						DMARK "KY2" 
9ee9			endif 
9ee9			if DEBUG_FORTH_PARSE_EXEC 
9ee9				; see if disabled 
9ee9			 
9ee9			;	ld a, (os_view_disable) 
9ee9			;	cp '*' 
9ee9				ld a, (debug_vector) 
9ee9				cp $c9   ; RET  
9ee9				jr z, .skip 
9ee9			 
9ee9				push hl 
9ee9				push hl 
9ee9				call clear_display 
9ee9				ld de, .compword 
9ee9				ld a, display_row_1 
9ee9				call str_at_display 
9ee9				pop de 
9ee9				ld a, display_row_2 
9ee9				call str_at_display 
9ee9				ld hl,(cli_ptr) 
9ee9				ld a,(hl) 
9ee9			        ld hl, os_word_scratch 
9ee9				ld (hl),a 
9ee9				ld a,0 
9ee9				inc hl 
9ee9				ld (hl),a 	 
9ee9				ld de, os_word_scratch 
9ee9				ld a, display_row_2+10 
9ee9				call str_at_display 
9ee9				call update_display 
9ee9				ld a, 100 
9ee9				call aDelayInMS 
9ee9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ee9				call delay250ms 
9ee9				endif 
9ee9				pop hl 
9ee9			.skip:  
9ee9			endif	 
9ee9			.execpnchar:    ; compare char between token and string to parse 
9ee9			 
9ee9			if DEBUG_FORTH_PARSE_KEY 
9ee9						DMARK "Ky3" 
9ee9			endif 
9ee9			if DEBUG_FORTH_PARSE_EXEC 
9ee9				; see if disabled 
9ee9			 
9ee9			;	ld a, (os_view_disable) 
9ee9			;	cp '*' 
9ee9				ld a, (debug_vector) 
9ee9				cp $C9  ; RET 
9ee9				jr z, .skip2 
9ee9			 
9ee9			;	call clear_display 
9ee9			ld hl,(cli_token) 
9ee9			ld a,(hl) 
9ee9			ld (os_word_scratch),a 
9ee9				ld hl,(cli_ptr) 
9ee9			ld a,(hl) 
9ee9				ld (os_word_scratch+1),a 
9ee9				ld a,0 
9ee9				ld (os_word_scratch+2),a 
9ee9				ld de,os_word_scratch 
9ee9				ld a,display_row_4 
9ee9				call str_at_display 
9ee9				call update_display 
9ee9			.skip2:  
9ee9			endif 
9ee9 2a 46 ea			ld hl,(cli_token) 
9eec 7e				ld a, (hl)	 ; char in word token 
9eed 23				inc hl 		; move to next char 
9eee 22 46 ea			ld (cli_token), hl ; and save it 
9ef1 47				ld b,a 
9ef2			 
9ef2 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9ef5 7e				ld a,(hl) 
9ef6 23				inc hl 
9ef7 22 40 ea			ld (cli_ptr), hl		; move to next char 
9efa cd 38 90			call toUpper 		; make sure the input string matches case 
9efd			 
9efd			if DEBUG_FORTH_PARSE 
9efd			endif 
9efd			 
9efd				; input stream end of token is a space so get rid of it 
9efd			 
9efd			;	cp ' ' 
9efd			;	jr nz, .pnskipspace 
9efd			; 
9efd			;	ld a, 0		; make same term as word token term 
9efd			; 
9efd			;.pnskipspace: 
9efd			 
9efd			if DEBUG_FORTH_PARSE_KEY 
9efd						DMARK "KY7" 
9efd			endif 
9efd b8				cp b 
9efe c2 14 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9f01				 
9f01			;    if same 
9f01			;       scan for string terms 0 for token and 32 for input 
9f01			 
9f01				 
9f01			if DEBUG_FORTH_PARSE_KEY 
9f01						DMARK "KY8" 
9f01			endif 
9f01			 
9f01 80				add b			 
9f02 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9f04							; TODO need to make sure last word in zero term string is accounted for 
9f04 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9f06			 
9f06			 
9f06				; at end of both strings so both are exact match 
9f06			 
9f06			;       skip ptr for next word 
9f06			 
9f06 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
9f09 23				inc hl			 ; at next char 
9f0a 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9f0d 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9f10				 
9f10				 
9f10			if DEBUG_FORTH_PARSE_KEY 
9f10						DMARK "KY3" 
9f10			endif 
9f10			 
9f10			 
9f10			 
9f10			;       exec code block 
9f10			if DEBUG_FORTH_JP 
9f10				call clear_display 
9f10				call update_display 
9f10				call delay1s 
9f10				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f10				ld a,h 
9f10				ld hl, os_word_scratch 
9f10				call hexout 
9f10				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f10				ld a,l 
9f10				ld hl, os_word_scratch+2 
9f10				call hexout 
9f10				ld hl, os_word_scratch+4 
9f10				ld a,0 
9f10				ld (hl),a 
9f10				ld de,os_word_scratch 
9f10				call str_at_display 
9f10					ld a, display_row_2 
9f10					call str_at_display 
9f10				ld de, (cli_origtoken) 
9f10				ld a, display_row_1+10 
9f10					call str_at_display 
9f10			 
9f10				ld a,display_row_1 
9f10				ld de, .foundword 
9f10				ld a, display_row_3 
9f10				call str_at_display 
9f10				call update_display 
9f10				call delay1s 
9f10				call delay1s 
9f10				call delay1s 
9f10			endif 
9f10			 
9f10			if DEBUG_FORTH_PARSE_KEY 
9f10						DMARK "KYj" 
9f10			endif 
9f10				; TODO save the word pointer in this exec 
9f10			 
9f10 2a 44 ea			ld hl,(cli_execword) 
9f13 e9				jp (hl) 
9f14			 
9f14			 
9f14			;    if not same 
9f14			;	scan for zero term 
9f14			;	get ptr for next word 
9f14			;	goto word comp 
9f14			 
9f14			.execpnskipword:	; get pointer to next word 
9f14 2a 42 ea			ld hl,(cli_nextword) 
9f17			 
9f17 7e				ld a,(hl) 
9f18 fe 00			cp WORD_SYS_END 
9f1a			;	cp 0 
9f1a 28 09			jr z, .execendofdict			 ; at end of words 
9f1c			 
9f1c			if DEBUG_FORTH_PARSE_KEY 
9f1c						DMARK "KY4" 
9f1c			endif 
9f1c			if DEBUG_FORTH_PARSE_EXEC 
9f1c			 
9f1c				; see if disabled 
9f1c			 
9f1c			;	ld a, (os_view_disable) 
9f1c			;	cp '*' 
9f1c				ld a,(debug_vector) 
9f1c				cp $c9   ; RET 
9f1c				jr z, .noskip 
9f1c			 
9f1c			 
9f1c				ld de, .nowordfound 
9f1c				ld a, display_row_3 
9f1c				call str_at_display 
9f1c				call update_display 
9f1c				ld a, 100 
9f1c				call aDelayInMS 
9f1c				 
9f1c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f1c					call delay250ms 
9f1c				endif 
9f1c			.noskip:  
9f1c			 
9f1c			endif	 
9f1c			 
9f1c 2a 3e ea			ld hl,(cli_origptr) 
9f1f 22 40 ea			ld (cli_ptr),hl 
9f22			 
9f22			if DEBUG_FORTH_PARSE_KEY 
9f22						DMARK "KY5" 
9f22			endif 
9f22 c3 c8 9e			jp .execpnword			; else go to next word 
9f25			 
9f25			.execendofdict:  
9f25			 
9f25			if DEBUG_FORTH_PARSE_KEY 
9f25						DMARK "KYe" 
9f25			endif 
9f25			if DEBUG_FORTH_PARSE_EXEC 
9f25				; see if disabled 
9f25			 
9f25			;	ld a, (os_view_disable) 
9f25			;	cp '*' 
9f25				ld a,(debug_vector) 
9f25				cp $c9   ; ret 
9f25				jr z, .ispskip 
9f25			 
9f25				call clear_display 
9f25				call update_display 
9f25				call delay1s 
9f25				ld de, (cli_origptr) 
9f25				ld a, display_row_1 
9f25				call str_at_display 
9f25				 
9f25				ld de, .enddict 
9f25				ld a, display_row_3 
9f25				call str_at_display 
9f25				call update_display 
9f25				ld a, 100 
9f25				call aDelayInMS 
9f25				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f25				call delay1s 
9f25				call delay1s 
9f25				call delay1s 
9f25				endif 
9f25			.ispskip:  
9f25				 
9f25			endif	 
9f25			 
9f25			 
9f25			 
9f25				; if the word is not a keyword then must be a literal so push it to stack 
9f25			 
9f25			; push token to stack to end of word 
9f25			 
9f25				STACKFRAME ON $1efe $2f9f 
9f25				if DEBUG_STACK_IMB 
9f25					if ON 
9f25						exx 
9f25						ld de, $1efe 
9f25						ld a, d 
9f25						ld hl, curframe 
9f25						call hexout 
9f25						ld a, e 
9f25						ld hl, curframe+2 
9f25						call hexout 
9f25						ld hl, $1efe 
9f25						push hl 
9f25						ld hl, $2f9f 
9f25						push hl 
9f25						exx 
9f25					endif 
9f25				endif 
9f25			endm 
# End of macro STACKFRAME
9f25			 
9f25 2a c2 e5		ld hl,(os_tok_ptr) 
9f28 cd cb 9b		call forth_apush 
9f2b			 
9f2b				STACKFRAMECHK ON $1efe $2f9f 
9f2b				if DEBUG_STACK_IMB 
9f2b					if ON 
9f2b						exx 
9f2b						ld hl, $2f9f 
9f2b						pop de   ; $2f9f 
9f2b						call cmp16 
9f2b						jr nz, .spnosame 
9f2b						ld hl, $1efe 
9f2b						pop de   ; $1efe 
9f2b						call cmp16 
9f2b						jr z, .spfrsame 
9f2b						.spnosame: call showsperror 
9f2b						.spfrsame: nop 
9f2b						exx 
9f2b					endif 
9f2b				endif 
9f2b			endm 
# End of macro STACKFRAMECHK
9f2b			 
9f2b			execnext: 
9f2b			 
9f2b			if DEBUG_FORTH_PARSE_KEY 
9f2b						DMARK "KY>" 
9f2b			endif 
9f2b			; move past token to next word 
9f2b			 
9f2b 2a c2 e5		ld hl, (os_tok_ptr) 
9f2e 3e 00		ld a, 0 
9f30 01 ff 00		ld bc, 255     ; input buffer size 
9f33 ed b1		cpir 
9f35			 
9f35			if DEBUG_FORTH_PARSE_KEY 
9f35						DMARK "KY!" 
9f35				CALLMONITOR 
9f35			endif	 
9f35			; TODO this might place hl on the null, so will need to forward on??? 
9f35			;inc hl   ; see if this gets onto the next item 
9f35			 
9f35			 
9f35			; TODO pass a pointer to the buffer to push 
9f35			; TODO call function to push 
9f35			 
9f35			; look for end of input 
9f35			 
9f35			;inc hl 
9f35			;ld a,(hl) 
9f35			;cp FORTH_END_BUFFER 
9f35			;ret z 
9f35			 
9f35			 
9f35 c3 ae 9e		jp exec1 
9f38			 
9f38			 
9f38			 
9f38			 
9f38			 
9f38			 
9f38			 
9f38			 
9f38			 
9f38			findnexttok: 
9f38			 
9f38				; hl is pointer to move 
9f38				; de is the token to locate 
9f38			 
9f38					if DEBUG_FORTH 
9f38						DMARK "NTK" 
9f38						CALLMONITOR 
9f38					endif 
9f38 d5				push de 
9f39			 
9f39			.fnt1:	 
9f39				; find first char of token to locate 
9f39			 
9f39 1a				ld a, (de) 
9f3a 4f				ld c,a 
9f3b 7e				ld a,(hl) 
9f3c cd 38 90			call toUpper 
9f3f					if DEBUG_FORTH 
9f3f						DMARK "NT1" 
9f3f						CALLMONITOR 
9f3f					endif 
9f3f b9				cp c 
9f40			 
9f40 28 03			jr z, .fnt2cmpmorefirst	 
9f42			 
9f42				; first char not found move to next char 
9f42			 
9f42 23				inc hl 
9f43 18 f4			jr .fnt1 
9f45			 
9f45			.fnt2cmpmorefirst:	 
9f45				; first char of token found.  
9f45			 
9f45 e5				push hl     ; save start of token just in case it is the right one 
9f46 d9				exx 
9f47 e1				pop hl        ; save it to hl' 
9f48 d9				exx 
9f49			 
9f49			 
9f49			.fnt2cmpmore:	 
9f49				; compare the rest 
9f49				 
9f49 23				inc hl 
9f4a 13				inc de 
9f4b				 
9f4b 1a				ld a, (de) 
9f4c 4f				ld c,a 
9f4d 7e				ld a,(hl) 
9f4e cd 38 90			call toUpper 
9f51			 
9f51					if DEBUG_FORTH 
9f51						DMARK "NT2" 
9f51						CALLMONITOR 
9f51					endif 
9f51				; c has the token to find char 
9f51				; a has the mem to scan char 
9f51			 
9f51 b9				cp c 
9f52 28 04			jr z,.fntmatch1 
9f54			 
9f54				; they are not the same 
9f54			 
9f54					if DEBUG_FORTH 
9f54						DMARK "NT3" 
9f54						CALLMONITOR 
9f54					endif 
9f54 d1				pop de	; reset de token to look for 
9f55 d5				push de 
9f56 18 e1			jr .fnt1 
9f58				 
9f58			.fntmatch1: 
9f58			 
9f58				; is the same char a null which means we might have a full hit? 
9f58					if DEBUG_FORTH 
9f58						DMARK "NT4" 
9f58						CALLMONITOR 
9f58					endif 
9f58			 
9f58 fe 00			cp 0 
9f5a 28 0b			jr z, .fntmatchyes 
9f5c			 
9f5c				; are we at the end of the token to find? 
9f5c			 
9f5c					if DEBUG_FORTH 
9f5c						DMARK "NT5" 
9f5c						CALLMONITOR 
9f5c					endif 
9f5c 3e 00			ld a, 0 
9f5e b9				cp c 
9f5f			 
9f5f c2 49 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9f62			 
9f62					if DEBUG_FORTH 
9f62						DMARK "NT6" 
9f62						CALLMONITOR 
9f62					endif 
9f62				; token to find is exhusted but no match to stream 
9f62			 
9f62				; restore tok pointer and continue on 
9f62 d1				pop de 
9f63 d5				push de 
9f64 c3 39 9f			jp .fnt1 
9f67			 
9f67			 
9f67			.fntmatchyes: 
9f67			 
9f67				; hl now contains the end of the found token 
9f67			 
9f67				; get rid of saved token pointer to find 
9f67			 
9f67 d1				pop de 
9f68			 
9f68					if DEBUG_FORTH 
9f68						DMARK "NT9" 
9f68						CALLMONITOR 
9f68					endif 
9f68			 
9f68				; hl will be on the null term so forward on 
9f68			 
9f68				; get back the saved start of the token 
9f68			 
9f68 d9				exx 
9f69 e5				push hl     ; save start of token just in case it is the right one 
9f6a d9				exx 
9f6b e1				pop hl        ; save it to hl 
9f6c			 
9f6c c9				ret 
9f6d			 
9f6d			 
9f6d			; LIST needs to find a specific token   
9f6d			; FORGET needs to find a spefici token 
9f6d			 
9f6d			; SAVE needs to find all tokens by flag 
9f6d			; WORDS just needs to scan through all  by flag 
9f6d			; UWORDS needs to scan through all by flag 
9f6d			 
9f6d			 
9f6d			; given hl as pointer to start of dict look up string 
9f6d			; return hl as pointer to start of word block 
9f6d			; or 0 if not found 
9f6d			 
9f6d			forth_find_tok: 
9f6d c9				ret 
9f6e			 
9f6e			; given hl as pointer to dict structure 
9f6e			; move to the next dict block structure 
9f6e			 
9f6e			forth_tok_next: 
9f6e				; hl now points to the address of the next word pointer  
9f6e				; TODO skip compiled symbol for now 
9f6e			;	push de 
9f6e 23				inc hl 
9f6f 5e				ld e, (hl) 
9f70 23				inc hl 
9f71 56				ld d, (hl) 
9f72 23				inc hl 
9f73			 
9f73 eb				ex de,hl 
9f74			if DEBUG_FORTH_PARSE_NEXTWORD 
9f74				push bc 
9f74				ld bc, (cli_nextword) 
9f74						DMARK "NXW" 
9f74				CALLMONITOR 
9f74				pop bc 
9f74			endif 
9f74			;	pop de	 
9f74 c9				ret 
9f75			 
9f75			 
9f75			 
9f75			; eof 
# End of file forth_parserv5.asm
9f75				include "forth_wordsv4.asm" 
9f75			 
9f75			; the core word dictionary v4 
9f75			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9f75			 
9f75			; this is a linked list for each of the system words used 
9f75			; user defined words will follow the same format but will be in ram 
9f75			 
9f75			 
9f75			; 
9f75			; 
9f75			; define linked list: 
9f75			; 
9f75			; 1. compiled byte op code 
9f75			; 2. len of text word 
9f75			; 3. text word 
9f75			; 4. ptr to next dictionary word 
9f75			; 5. asm, calls etc for the word 
9f75			; 
9f75			;  if 1 == 0 then last word in dict  
9f75			;   
9f75			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9f75			;  
9f75			;  
9f75			; create basic standard set of words 
9f75			; 
9f75			;  
9f75			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9f75			; 2DUP 2DROP 2SWAP  
9f75			; @ C@ - get byte  
9f75			; ! C! - store byte 
9f75			; 0< true if less than zero 
9f75			; 0= true if zero 
9f75			; < >  
9f75			; = true if same 
9f75			; variables 
9f75			 
9f75			 
9f75			; Hardware specific words I may need 
9f75			; 
9f75			; IN OUT  
9f75			; calls to key util functions 
9f75			; calls to hardward abstraction stuff 
9f75			; easy control of frame buffers and lcd i/o 
9f75			; keyboard  
9f75			 
9f75			 
9f75			;DICT: macro 
9f75			; op_code, len, word, next 
9f75			;    word: 
9f75			;    db op_code 
9f75			;    ds word zero term 
9f75			;    dw next 
9f75			;    endm 
9f75			 
9f75			 
9f75			 
9f75			 
9f75			; op code 1 is a flag for user define words which are to be handled differently 
9f75			 
9f75			 
9f75			; 
9f75			; 
9f75			;    TODO on entry to a word this should be the expected environment 
9f75			;    hl - tos value if number then held, if string this is the ptr 
9f75			;    de -  
9f75			 
9f75			 
9f75			; opcode ranges 
9f75			; 0 - end of word dict 
9f75			; 255 - user define words 
9f75			 
9f75			sysdict: 
9f75			include "forth_opcodes.asm" 
9f75			; op codes for forth keywords 
9f75			; free to use code 0  
9f75				OPCODE_HEAP: equ  1 
9f75				OPCODE_EXEC: equ 2 
9f75				OPCODE_DUP: equ 3 
9f75				OPCODE_SWAP: equ 4 
9f75				OPCODE_COLN: equ 5 
9f75				OPCODE_SCOLN: equ 6 
9f75				OPCODE_DROP: equ 7 
9f75				OPCODE_DUP2: equ 8 
9f75				OPCODE_DROP2: equ 9 
9f75				OPCODE_SWAP2: equ 10 
9f75				OPCODE_AT: equ 11 
9f75				OPCODE_CAT: equ 12 
9f75				OPCODE_BANG: equ 13 
9f75				OPCODE_CBANG: equ 14 
9f75				OPCODE_SCALL: equ 15 
9f75				OPCODE_DEPTH: equ 16 
9f75				OPCODE_OVER: equ 17 
9f75				OPCODE_PAUSE: equ 18 
9f75				OPCODE_PAUSES: equ 19 
9f75				OPCODE_ROT: equ 20 
9f75			;free to reuse	OPCODE_WORDS: equ 21 
9f75			        OPCODE_NOT: equ 21 
9f75				OPCODE_UWORDS: equ 22 
9f75				OPCODE_BP: equ 23 
9f75				OPCODE_MONITOR: equ 24  
9f75				OPCODE_MALLOC: equ 25 
9f75				OPCODE_FREE: equ 26 
9f75				OPCODE_LIST: equ 27 
9f75				OPCODE_FORGET: equ 28 
9f75				OPCODE_NOP: equ 29 
9f75				OPCODE_COMO: equ 30 
9f75				OPCODE_COMC: equ 31 
9f75			;free to reuse	OPCODE_ENDCORE: equ 32 
9f75				OPCODE_AFTERSOUND: equ 33 
9f75				OPCODE_GP2: equ 34 
9f75				OPCODE_GP3: equ 35 
9f75				OPCODE_GP4: equ 36 
9f75				OPCODE_SIN: equ 37 
9f75				OPCODE_SOUT: equ 38 
9f75				OPCODE_SPIO: equ 39 
9f75				OPCODE_SPICEH: equ 40 
9f75				OPCODE_SPIOb: equ 41 
9f75				OPCODE_SPII: equ 42 
9f75				OPCODE_SESEL: equ 43 
9f75				OPCODE_CARTDEV: equ 44 
9f75			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9f75				OPCODE_FB: equ 46 
9f75				OPCODE_EMIT: equ 47 
9f75				OPCODE_DOTH: equ 48 
9f75				OPCODE_DOTF: equ 49 
9f75				OPCODE_DOT: equ 50 
9f75				OPCODE_CLS: equ 51 
9f75				OPCODE_DRAW: equ 52 
9f75				OPCODE_DUMP: equ 53 
9f75				OPCODE_CDUMP: equ 54 
9f75				OPCODE_DAT: equ 55 
9f75				OPCODE_HOME: equ 56 
9f75				OPCODE_SPACE: equ 57 
9f75				OPCODE_SPACES: equ 58 
9f75				OPCODE_SCROLL: equ 59 
9f75				OPCODE_ATQ: equ 60 
9f75				OPCODE_AUTODSP: equ 61 
9f75				OPCODE_MENU: equ 62 
9f75			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9f75				OPCODE_THEN: equ 64 
9f75				OPCODE_ELSE: equ 65 
9f75				OPCODE_DO: equ 66 
9f75				OPCODE_LOOP: equ 67 
9f75				OPCODE_I: equ 68 
9f75				OPCODE_DLOOP: equ 69  
9f75				OPCODE_REPEAT: equ 70  
9f75				OPCODE_UNTIL: equ 71 
9f75				OPCODE_ENDFLOW: equ 72 
9f75				OPCODE_WAITK: equ 73 
9f75				OPCODE_ACCEPT: equ 74 
9f75				OPCODE_EDIT: equ 75 
9f75			;free to reuse	OPCODE_ENDKEY: equ 76 
9f75				OPCODE_LZERO: equ 77 
9f75				OPCODE_TZERO: equ 78 
9f75				OPCODE_LESS: equ 79 
9f75				OPCODE_GT: equ 80 
9f75				OPCODE_EQUAL: equ 81  
9f75			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9f75				OPCODE_NEG: equ 83 
9f75				OPCODE_DIV: equ 84 
9f75				OPCODE_MUL: equ 85 
9f75				OPCODE_MIN: equ 86 
9f75				OPCODE_MAX: equ 87 
9f75				OPCODE_RND16: equ 88 
9f75				OPCODE_RND8: equ 89 
9f75				OPCODE_RND: equ 90 
9f75			;free to reuse	OPCODE_ENDMATHS: equ 91  
9f75				OPCODE_BYNAME: equ 92 
9f75				OPCODE_DIR: equ 93 
9f75				OPCODE_SAVE: equ 94 
9f75				OPCODE_LOAD: equ 95 
9f75				OPCODE_BSAVE: equ 96 
9f75				OPCODE_BLOAD: equ 97 
9f75				OPCODE_SEO: equ 98  
9f75				OPCODE_SEI: equ 99 
9f75				OPCODE_SFREE: equ 100 
9f75				OPCODE_SIZE: equ 101 
9f75				OPCODE_CREATE: equ 102 
9f75				OPCODE_APPEND: equ 103 
9f75				OPCODE_SDEL: equ 104 
9f75				OPCODE_OPEN: equ 105 
9f75				OPCODE_READ: equ 106 
9f75				OPCODE_EOF: equ 106 
9f75				OPCODE_FORMAT: equ 107 
9f75				OPCODE_LABEL: equ 108 
9f75				OPCODE_LABELS: equ 109 
9f75			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9f75				OPCODE_UPPER: equ 111 
9f75				OPCODE_LOWER: equ 112 
9f75				OPCODE_SUBSTR: equ 113 
9f75				OPCODE_LEFT: equ 114 
9f75				OPCODE_RIGHT: equ 115 
9f75				OPCODE_STR2NUM: equ 116 
9f75				OPCODE_NUM2STR: equ 117 
9f75				OPCODE_CONCAT: equ 118 
9f75				OPCODE_FIND: equ 119 
9f75				OPCODE_LEN: equ 120 
9f75				OPCODE_CHAR: equ 121 
9f75			; free to reuse	OPCODE_STRLEN: equ 122 
9f75			; free to reuse	OPCODE_ENDSTR: equ 123 
9f75				OPCODE_V0S: equ 124 
9f75				OPCODE_V0Q: equ 125 
9f75				OPCODE_V1S: equ 126 
9f75				OPCODE_V1Q: equ 127 
9f75				OPCODE_V2S: equ 128 
9f75				OPCODE_V2Q: equ 129 
9f75				OPCODE_V3S: equ 130 
9f75				OPCODE_V3Q: equ 131 
9f75			;free to reuse	OPCODE_END: equ 132 
9f75				OPCODE_ZDUP: equ 133 
9f75			 
9f75			; eof 
# End of file forth_opcodes.asm
9f75			 
9f75			include "forth_words_core.asm" 
9f75			 
9f75			; | ## Core Words 
9f75			 
9f75			;if MALLOC_4 
9f75			 
9f75			.HEAP: 
9f75			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9f75 15				db WORD_SYS_CORE+OPCODE_HEAP             
9f76 b4 9f			dw .EXEC            
9f78 05				db 4 + 1 
9f79 .. 00			db "HEAP",0              
9f7e				endm 
# End of macro CWHEAD
9f7e			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9f7e			; | | u1 - Current number of bytes in the heap 
9f7e			; | | u2 - Remaining bytes left on the heap 
9f7e			; | |  
9f7e			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9f7e			 
9f7e			 
9f7e				if DEBUG_FORTH_WORDS_KEY 
9f7e					DMARK "HEP" 
9f7e f5				push af  
9f7f 3a 93 9f			ld a, (.dmark)  
9f82 32 6b ee			ld (debug_mark),a  
9f85 3a 94 9f			ld a, (.dmark+1)  
9f88 32 6c ee			ld (debug_mark+1),a  
9f8b 3a 95 9f			ld a, (.dmark+2)  
9f8e 32 6d ee			ld (debug_mark+2),a  
9f91 18 03			jr .pastdmark  
9f93 ..			.dmark: db "HEP"  
9f96 f1			.pastdmark: pop af  
9f97			endm  
# End of macro DMARK
9f97					CALLMONITOR 
9f97 cd 6f ee			call debug_vector  
9f9a				endm  
# End of macro CALLMONITOR
9f9a				endif 
9f9a 2a 1b dd			ld hl, (free_list )      
9f9d 11 20 dd			ld de, heap_start 
9fa0			 
9fa0 ed 52			sbc hl, de  
9fa2			 
9fa2 cd 62 9a			call forth_push_numhl 
9fa5			 
9fa5			 
9fa5 ed 5b 1b dd		ld de, (free_list )      
9fa9 21 9c e2			ld hl, heap_end 
9fac			 
9fac ed 52			sbc hl, de 
9fae			 
9fae cd 62 9a			call forth_push_numhl 
9fb1				 
9fb1			 
9fb1				 
9fb1			 
9fb1			 
9fb1			 
9fb1				NEXTW 
9fb1 c3 1d 9e			jp macro_next 
9fb4				endm 
# End of macro NEXTW
9fb4			;endif 
9fb4			 
9fb4			.EXEC: 
9fb4			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9fb4			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9fb4			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9fb4			;; > > 
9fb4			;; > >   
9fb4			;	STACKFRAME OFF $5efe $5f9f 
9fb4			; 
9fb4			;		if DEBUG_FORTH_WORDS_KEY 
9fb4			;			DMARK "EXE" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			; 
9fb4			;	FORTH_DSP_VALUEHL 
9fb4			; 
9fb4			;	FORTH_DSP_POP 
9fb4			; 
9fb4			;		if DEBUG_FORTH_WORDS 
9fb4			;			DMARK "EX1" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			;;	ld e,(hl) 
9fb4			;;	inc hl 
9fb4			;;	ld d,(hl) 
9fb4			;;	ex de,hl 
9fb4			; 
9fb4			;;		if DEBUG_FORTH_WORDS 
9fb4			;;			DMARK "EX2" 
9fb4			;;			CALLMONITOR 
9fb4			;;		endif 
9fb4			;	push hl 
9fb4			; 
9fb4			;	;ld a, 0 
9fb4			;	;ld a, FORTH_END_BUFFER 
9fb4			;	call strlenz 
9fb4			;	inc hl   ; include zero term to copy 
9fb4			;	inc hl   ; include term 
9fb4			;	inc hl   ; include term 
9fb4			;	ld b,0 
9fb4			;	ld c,l 
9fb4			;	pop hl 
9fb4			;	ld de, execscratch 
9fb4			;		if DEBUG_FORTH_WORDS 
9fb4			;			DMARK "EX3" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			;	ldir 
9fb4			; 
9fb4			; 
9fb4			;	ld hl, execscratch 
9fb4			; 
9fb4			;		if DEBUG_FORTH_WORDS 
9fb4			;			DMARK "EXe" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			; 
9fb4			;	call forthparse 
9fb4			;	call forthexec 
9fb4			;;	call forthexec_cleanup 
9fb4			;;	call forthparse 
9fb4			;;	call forthexec 
9fb4			; 
9fb4			;	STACKFRAMECHK OFF $5efe $5f9f 
9fb4			; 
9fb4			;	; an immediate word so no need to process any more words 
9fb4			;	ret 
9fb4			;	NEXTW 
9fb4			 
9fb4			; dead code - old version  
9fb4			;	FORTH_RSP_NEXT 
9fb4			 
9fb4			;  
9fb4			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9fb4			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9fb4			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9fb4			;	push hl 
9fb4			;	push de 
9fb4			;	push bc 
9fb4			; 
9fb4			; 
9fb4			;		if DEBUG_FORTH_WORDS_KEY 
9fb4			;			DMARK "EXR" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			; 
9fb4			; 
9fb4			; 
9fb4			;	;v5 FORTH_DSP_VALUE 
9fb4			;	FORTH_DSP_VALUEHL 
9fb4			; 
9fb4			;	; TODO do string type checks 
9fb4			; 
9fb4			;;v5	inc hl   ; skip type 
9fb4			; 
9fb4			;	push hl  ; source code  
9fb4			;		if DEBUG_FORTH_WORDS 
9fb4			;			DMARK "EX1" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			;	ld a, 0 
9fb4			;	call strlent 
9fb4			; 
9fb4			;	inc hl 
9fb4			;	inc hl 
9fb4			;	inc hl 
9fb4			;	inc hl 
9fb4			; 
9fb4			;	push hl    ; size 
9fb4			; 
9fb4			;		if DEBUG_FORTH_WORDS 
9fb4			;			DMARK "EX2" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			;	call malloc 
9fb4			; 
9fb4			;	ex de, hl    ; de now contains malloc area 
9fb4			;	pop bc   	; get byte count 
9fb4			;	pop hl      ; get string to copy 
9fb4			; 
9fb4			;	push de     ; save malloc for free later 
9fb4			; 
9fb4			;		if DEBUG_FORTH_WORDS 
9fb4			;			DMARK "EX3" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			;	ldir       ; duplicate string 
9fb4			; 
9fb4			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9fb4			;	 
9fb4			;	; TODO fix the parse would be better than this...  
9fb4			;	ex de, hl 
9fb4			;	dec hl 
9fb4			;	ld a, 0 
9fb4			;	ld (hl), a 
9fb4			;	dec hl 
9fb4			;	ld a, ' ' 
9fb4			;	ld (hl), a 
9fb4			;	dec hl 
9fb4			;	ld (hl), a 
9fb4			; 
9fb4			;	dec hl 
9fb4			;	ld (hl), a 
9fb4			; 
9fb4			; 
9fb4			;	FORTH_DSP_POP  
9fb4			; 
9fb4			;	pop hl     
9fb4			;	push hl    ; save malloc area 
9fb4			; 
9fb4			;		if DEBUG_FORTH_WORDS 
9fb4			;			DMARK "EX4" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			; 
9fb4			;	call forthparse 
9fb4			;	call forthexec 
9fb4			;	 
9fb4			;	pop hl 
9fb4			;	if DEBUG_FORTH_WORDS 
9fb4			;		DMARK "EX5" 
9fb4			;		CALLMONITOR 
9fb4			;	endif 
9fb4			; 
9fb4			;	if FORTH_ENABLE_FREE 
9fb4			;	call free 
9fb4			;	endif 
9fb4			; 
9fb4			;	if DEBUG_FORTH_WORDS 
9fb4			;		DMARK "EX6" 
9fb4			;		CALLMONITOR 
9fb4			;	endif 
9fb4			; 
9fb4			;	pop bc 
9fb4			;	pop de 
9fb4			;	pop hl 
9fb4			;;	FORTH_RSP_POP	  
9fb4			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9fb4			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9fb4			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9fb4			; 
9fb4			;	if DEBUG_FORTH_WORDS 
9fb4			;		DMARK "EX7" 
9fb4			;		CALLMONITOR 
9fb4			;	endif 
9fb4			;	NEXTW 
9fb4			 
9fb4			;.STKEXEC: 
9fb4			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9fb4			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9fb4			; 
9fb4			; 
9fb4			;		if DEBUG_FORTH_WORDS_KEY 
9fb4			;			DMARK "STX" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			; 
9fb4			;	FORTH_DSP_VALUEHL 
9fb4			; 
9fb4			;	ld (store_tmp1), hl    ; count 
9fb4			; 
9fb4			;	FORTH_DSP_POP 
9fb4			;.stkexec1: 
9fb4			;	ld hl, (store_tmp1)   ; count 
9fb4			;	ld a, 0 
9fb4			;	cp l 
9fb4			;	ret z 
9fb4			; 
9fb4			;	dec hl 
9fb4			;	ld (store_tmp1), hl    ; count 
9fb4			;	 
9fb4			;	FORTH_DSP_VALUEHL 
9fb4			;	push hl 
9fb4			;	 
9fb4			;		if DEBUG_FORTH_WORDS 
9fb4			;			DMARK "EXp" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			;	FORTH_DSP_POP 
9fb4			; 
9fb4			;	call strlenz 
9fb4			;	inc hl   ; include zero term to copy 
9fb4			;	inc hl   ; include zero term to copy 
9fb4			;	inc hl   ; include zero term to copy 
9fb4			;	ld b,0 
9fb4			;	ld c,l 
9fb4			;	pop hl 
9fb4			;	ld de, execscratch 
9fb4			;		if DEBUG_FORTH_WORDS 
9fb4			;			DMARK "EX3" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			;	ldir 
9fb4			; 
9fb4			; 
9fb4			;	ld hl, execscratch 
9fb4			; 
9fb4			;		if DEBUG_FORTH_WORDS 
9fb4			;			DMARK "EXP" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			; 
9fb4			;	call forthparse 
9fb4			;	ld hl, execscratch 
9fb4			;		if DEBUG_FORTH_WORDS 
9fb4			;			DMARK "EXx" 
9fb4			;			CALLMONITOR 
9fb4			;		endif 
9fb4			;	call forthexec 
9fb4			; 
9fb4			;	jp .stkexec1 
9fb4			; 
9fb4			;	ret 
9fb4			 
9fb4			 
9fb4			.DUP: 
9fb4			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9fb4 17				db WORD_SYS_CORE+OPCODE_DUP             
9fb5 2a a0			dw .ZDUP            
9fb7 04				db 3 + 1 
9fb8 .. 00			db "DUP",0              
9fbc				endm 
# End of macro CWHEAD
9fbc			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9fbc			 
9fbc				if DEBUG_FORTH_WORDS_KEY 
9fbc					DMARK "DUP" 
9fbc f5				push af  
9fbd 3a d1 9f			ld a, (.dmark)  
9fc0 32 6b ee			ld (debug_mark),a  
9fc3 3a d2 9f			ld a, (.dmark+1)  
9fc6 32 6c ee			ld (debug_mark+1),a  
9fc9 3a d3 9f			ld a, (.dmark+2)  
9fcc 32 6d ee			ld (debug_mark+2),a  
9fcf 18 03			jr .pastdmark  
9fd1 ..			.dmark: db "DUP"  
9fd4 f1			.pastdmark: pop af  
9fd5			endm  
# End of macro DMARK
9fd5					CALLMONITOR 
9fd5 cd 6f ee			call debug_vector  
9fd8				endm  
# End of macro CALLMONITOR
9fd8				endif 
9fd8			 
9fd8				FORTH_DSP 
9fd8 cd 2d 9c			call macro_forth_dsp 
9fdb				endm 
# End of macro FORTH_DSP
9fdb			 
9fdb 7e				ld a, (HL) 
9fdc fe 01			cp DS_TYPE_STR 
9fde 20 25			jr nz, .dupinum 
9fe0			 
9fe0				; push another string 
9fe0			 
9fe0				FORTH_DSP_VALUEHL     		 
9fe0 cd 67 9c			call macro_dsp_valuehl 
9fe3				endm 
# End of macro FORTH_DSP_VALUEHL
9fe3			 
9fe3			if DEBUG_FORTH_WORDS 
9fe3				DMARK "DUs" 
9fe3 f5				push af  
9fe4 3a f8 9f			ld a, (.dmark)  
9fe7 32 6b ee			ld (debug_mark),a  
9fea 3a f9 9f			ld a, (.dmark+1)  
9fed 32 6c ee			ld (debug_mark+1),a  
9ff0 3a fa 9f			ld a, (.dmark+2)  
9ff3 32 6d ee			ld (debug_mark+2),a  
9ff6 18 03			jr .pastdmark  
9ff8 ..			.dmark: db "DUs"  
9ffb f1			.pastdmark: pop af  
9ffc			endm  
# End of macro DMARK
9ffc				CALLMONITOR 
9ffc cd 6f ee			call debug_vector  
9fff				endm  
# End of macro CALLMONITOR
9fff			endif 
9fff cd d0 9a			call forth_push_str 
a002			 
a002				NEXTW 
a002 c3 1d 9e			jp macro_next 
a005				endm 
# End of macro NEXTW
a005			 
a005			 
a005			.dupinum: 
a005				 
a005			 
a005			 
a005				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a005 cd 67 9c			call macro_dsp_valuehl 
a008				endm 
# End of macro FORTH_DSP_VALUEHL
a008			 
a008			; TODO add floating point number detection 
a008			 
a008			if DEBUG_FORTH_WORDS 
a008				DMARK "DUi" 
a008 f5				push af  
a009 3a 1d a0			ld a, (.dmark)  
a00c 32 6b ee			ld (debug_mark),a  
a00f 3a 1e a0			ld a, (.dmark+1)  
a012 32 6c ee			ld (debug_mark+1),a  
a015 3a 1f a0			ld a, (.dmark+2)  
a018 32 6d ee			ld (debug_mark+2),a  
a01b 18 03			jr .pastdmark  
a01d ..			.dmark: db "DUi"  
a020 f1			.pastdmark: pop af  
a021			endm  
# End of macro DMARK
a021				CALLMONITOR 
a021 cd 6f ee			call debug_vector  
a024				endm  
# End of macro CALLMONITOR
a024			endif 
a024			 
a024 cd 62 9a			call forth_push_numhl 
a027				NEXTW 
a027 c3 1d 9e			jp macro_next 
a02a				endm 
# End of macro NEXTW
a02a			.ZDUP: 
a02a			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a02a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a02b 62 a0			dw .SWAP            
a02d 05				db 4 + 1 
a02e .. 00			db "?DUP",0              
a033				endm 
# End of macro CWHEAD
a033			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a033			 
a033				if DEBUG_FORTH_WORDS_KEY 
a033					DMARK "qDU" 
a033 f5				push af  
a034 3a 48 a0			ld a, (.dmark)  
a037 32 6b ee			ld (debug_mark),a  
a03a 3a 49 a0			ld a, (.dmark+1)  
a03d 32 6c ee			ld (debug_mark+1),a  
a040 3a 4a a0			ld a, (.dmark+2)  
a043 32 6d ee			ld (debug_mark+2),a  
a046 18 03			jr .pastdmark  
a048 ..			.dmark: db "qDU"  
a04b f1			.pastdmark: pop af  
a04c			endm  
# End of macro DMARK
a04c					CALLMONITOR 
a04c cd 6f ee			call debug_vector  
a04f				endm  
# End of macro CALLMONITOR
a04f				endif 
a04f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a04f cd 67 9c			call macro_dsp_valuehl 
a052				endm 
# End of macro FORTH_DSP_VALUEHL
a052			 
a052 e5				push hl 
a053			 
a053				; is it a zero? 
a053			 
a053 3e 00			ld a, 0 
a055 84				add h 
a056 85				add l 
a057			 
a057 e1				pop hl 
a058			 
a058 fe 00			cp 0 
a05a 28 03			jr z, .dup2orig 
a05c			 
a05c			 
a05c cd 62 9a			call forth_push_numhl 
a05f			 
a05f			 
a05f			; TODO add floating point number detection 
a05f			 
a05f			.dup2orig: 
a05f			 
a05f				NEXTW 
a05f c3 1d 9e			jp macro_next 
a062				endm 
# End of macro NEXTW
a062			.SWAP: 
a062			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a062 18				db WORD_SYS_CORE+OPCODE_SWAP             
a063 a1 a0			dw .COLN            
a065 05				db 4 + 1 
a066 .. 00			db "SWAP",0              
a06b				endm 
# End of macro CWHEAD
a06b			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a06b				if DEBUG_FORTH_WORDS_KEY 
a06b					DMARK "SWP" 
a06b f5				push af  
a06c 3a 80 a0			ld a, (.dmark)  
a06f 32 6b ee			ld (debug_mark),a  
a072 3a 81 a0			ld a, (.dmark+1)  
a075 32 6c ee			ld (debug_mark+1),a  
a078 3a 82 a0			ld a, (.dmark+2)  
a07b 32 6d ee			ld (debug_mark+2),a  
a07e 18 03			jr .pastdmark  
a080 ..			.dmark: db "SWP"  
a083 f1			.pastdmark: pop af  
a084			endm  
# End of macro DMARK
a084					CALLMONITOR 
a084 cd 6f ee			call debug_vector  
a087				endm  
# End of macro CALLMONITOR
a087				endif 
a087			 
a087			; TODO Use os stack swap memory 
a087				FORTH_DSP_VALUEHL 
a087 cd 67 9c			call macro_dsp_valuehl 
a08a				endm 
# End of macro FORTH_DSP_VALUEHL
a08a e5				push hl     ; w2 
a08b			 
a08b				FORTH_DSP_POP 
a08b cd 1f 9d			call macro_forth_dsp_pop 
a08e				endm 
# End of macro FORTH_DSP_POP
a08e			 
a08e				FORTH_DSP_VALUEHL 
a08e cd 67 9c			call macro_dsp_valuehl 
a091				endm 
# End of macro FORTH_DSP_VALUEHL
a091			 
a091				FORTH_DSP_POP 
a091 cd 1f 9d			call macro_forth_dsp_pop 
a094				endm 
# End of macro FORTH_DSP_POP
a094			 
a094 d1				pop de     ; w2	, hl = w1 
a095			 
a095 eb				ex de, hl 
a096 d5				push de 
a097			 
a097 cd 62 9a			call forth_push_numhl 
a09a			 
a09a e1				pop hl 
a09b			 
a09b cd 62 9a			call forth_push_numhl 
a09e				 
a09e			 
a09e				NEXTW 
a09e c3 1d 9e			jp macro_next 
a0a1				endm 
# End of macro NEXTW
a0a1			.COLN: 
a0a1			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a0a1 19				db WORD_SYS_CORE+OPCODE_COLN             
a0a2 2d a2			dw .SCOLN            
a0a4 02				db 1 + 1 
a0a5 .. 00			db ":",0              
a0a7				endm 
# End of macro CWHEAD
a0a7			; | : ( -- )         Create new word | DONE 
a0a7			 
a0a7				if DEBUG_FORTH_WORDS_KEY 
a0a7					DMARK "CLN" 
a0a7 f5				push af  
a0a8 3a bc a0			ld a, (.dmark)  
a0ab 32 6b ee			ld (debug_mark),a  
a0ae 3a bd a0			ld a, (.dmark+1)  
a0b1 32 6c ee			ld (debug_mark+1),a  
a0b4 3a be a0			ld a, (.dmark+2)  
a0b7 32 6d ee			ld (debug_mark+2),a  
a0ba 18 03			jr .pastdmark  
a0bc ..			.dmark: db "CLN"  
a0bf f1			.pastdmark: pop af  
a0c0			endm  
# End of macro DMARK
a0c0					CALLMONITOR 
a0c0 cd 6f ee			call debug_vector  
a0c3				endm  
# End of macro CALLMONITOR
a0c3				endif 
a0c3			STACKFRAME OFF $8efe $989f 
a0c3				if DEBUG_STACK_IMB 
a0c3					if OFF 
a0c3						exx 
a0c3						ld de, $8efe 
a0c3						ld a, d 
a0c3						ld hl, curframe 
a0c3						call hexout 
a0c3						ld a, e 
a0c3						ld hl, curframe+2 
a0c3						call hexout 
a0c3						ld hl, $8efe 
a0c3						push hl 
a0c3						ld hl, $989f 
a0c3						push hl 
a0c3						exx 
a0c3					endif 
a0c3				endif 
a0c3			endm 
# End of macro STACKFRAME
a0c3			; get parser buffer length  of new word 
a0c3			 
a0c3			 
a0c3			 
a0c3				; move tok past this to start of name defintition 
a0c3				; TODO get word to define 
a0c3				; TODO Move past word token 
a0c3				; TODO get length of string up to the ';' 
a0c3			 
a0c3 2a c2 e5		ld hl, (os_tok_ptr) 
a0c6 23			inc hl 
a0c7 23			inc hl 
a0c8			 
a0c8 3e 3b		ld a, ';' 
a0ca cd 4c 90		call strlent 
a0cd			 
a0cd 7d			ld a,l 
a0ce 32 b1 e2		ld (os_new_parse_len), a 
a0d1			 
a0d1			 
a0d1			if DEBUG_FORTH_UWORD 
a0d1 ed 5b c2 e5	ld de, (os_tok_ptr) 
a0d5					DMARK ":01" 
a0d5 f5				push af  
a0d6 3a ea a0			ld a, (.dmark)  
a0d9 32 6b ee			ld (debug_mark),a  
a0dc 3a eb a0			ld a, (.dmark+1)  
a0df 32 6c ee			ld (debug_mark+1),a  
a0e2 3a ec a0			ld a, (.dmark+2)  
a0e5 32 6d ee			ld (debug_mark+2),a  
a0e8 18 03			jr .pastdmark  
a0ea ..			.dmark: db ":01"  
a0ed f1			.pastdmark: pop af  
a0ee			endm  
# End of macro DMARK
a0ee			CALLMONITOR 
a0ee cd 6f ee			call debug_vector  
a0f1				endm  
# End of macro CALLMONITOR
a0f1			endif 
a0f1			 
a0f1			; 
a0f1			;  new word memory layout: 
a0f1			;  
a0f1			;    : adg 6666 ;  
a0f1			; 
a0f1			;    db   1     ; user defined word  
a0f1 23			inc hl    
a0f2			;    dw   sysdict 
a0f2 23			inc hl 
a0f3 23			inc hl 
a0f4			;    db <word len>+1 (for null) 
a0f4 23			inc hl 
a0f5			;    db .... <word> 
a0f5			; 
a0f5			 
a0f5 23			inc hl    ; some extras for the word preamble before the above 
a0f6 23			inc hl 
a0f7 23			inc hl 
a0f8 23			inc hl 
a0f9 23			inc hl 
a0fa 23			inc hl 
a0fb 23			inc hl  
a0fc 23			inc hl 
a0fd 23			inc hl 
a0fe 23			inc hl 
a0ff 23			inc hl 
a100 23			inc hl 
a101 23			inc hl 
a102 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a103			;       exec word buffer 
a103			;	<ptr word>   
a103 23			inc hl 
a104 23			inc hl 
a105			;       <word list><null term> 7F final term 
a105			 
a105			 
a105			if DEBUG_FORTH_UWORD 
a105					DMARK ":02" 
a105 f5				push af  
a106 3a 1a a1			ld a, (.dmark)  
a109 32 6b ee			ld (debug_mark),a  
a10c 3a 1b a1			ld a, (.dmark+1)  
a10f 32 6c ee			ld (debug_mark+1),a  
a112 3a 1c a1			ld a, (.dmark+2)  
a115 32 6d ee			ld (debug_mark+2),a  
a118 18 03			jr .pastdmark  
a11a ..			.dmark: db ":02"  
a11d f1			.pastdmark: pop af  
a11e			endm  
# End of macro DMARK
a11e			CALLMONITOR 
a11e cd 6f ee			call debug_vector  
a121				endm  
# End of macro CALLMONITOR
a121			endif 
a121			 
a121			 
a121				; malloc the size 
a121			 
a121 cd b6 90			call malloc 
a124 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
a127			 
a127			;    db   1     ; user defined word  
a127 3e 01			ld a, WORD_SYS_UWORD  
a129 77				ld (hl), a 
a12a			 
a12a 23			inc hl    
a12b			;    dw   sysdict 
a12b 11 75 9f		ld de, sysdict       ; continue on with the scan to the system dict 
a12e 73			ld (hl), e 
a12f 23			inc hl 
a130 72			ld (hl), d 
a131 23			inc hl 
a132			 
a132			 
a132			;    Setup dict word 
a132			 
a132 23			inc hl 
a133 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a136			 
a136			; 1. get length of dict word 
a136			 
a136			 
a136 2a c2 e5		ld hl, (os_tok_ptr) 
a139 23			inc hl 
a13a 23			inc hl    ; position to start of dict word 
a13b 3e 00		ld a, 0 
a13d cd 4c 90		call strlent 
a140			 
a140			 
a140 23			inc hl    ; to include null??? 
a141			 
a141			; write length of dict word 
a141			 
a141 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a145 1b			dec de 
a146 eb			ex de, hl 
a147 73			ld (hl), e 
a148 eb			ex de, hl 
a149			 
a149			 
a149			 
a149			; copy  
a149 4d			ld c, l 
a14a 06 00		ld b, 0 
a14c ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a150 2a c2 e5		ld hl, (os_tok_ptr) 
a153 23			inc hl 
a154 23			inc hl    ; position to start of dict word 
a155			 
a155			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a155			 
a155			; TODO need to convert word to upper case 
a155			 
a155			ucasetok:	 
a155 7e			ld a,(hl) 
a156 cd 38 90		call toUpper 
a159 77			ld (hl),a 
a15a ed a0		ldi 
a15c f2 55 a1		jp p, ucasetok 
a15f			 
a15f			 
a15f			 
a15f			; de now points to start of where the word body code should be placed 
a15f ed 53 ad e2	ld (os_new_work_ptr), de 
a163			; hl now points to the words to throw at forthexec which needs to be copied 
a163 22 ab e2		ld (os_new_src_ptr), hl 
a166			 
a166			; TODO add 'call to forthexec' 
a166			 
a166			if DEBUG_FORTH_UWORD 
a166 c5			push bc 
a167 ed 4b b3 e2	ld bc, (os_new_malloc) 
a16b					DMARK ":0x" 
a16b f5				push af  
a16c 3a 80 a1			ld a, (.dmark)  
a16f 32 6b ee			ld (debug_mark),a  
a172 3a 81 a1			ld a, (.dmark+1)  
a175 32 6c ee			ld (debug_mark+1),a  
a178 3a 82 a1			ld a, (.dmark+2)  
a17b 32 6d ee			ld (debug_mark+2),a  
a17e 18 03			jr .pastdmark  
a180 ..			.dmark: db ":0x"  
a183 f1			.pastdmark: pop af  
a184			endm  
# End of macro DMARK
a184			CALLMONITOR 
a184 cd 6f ee			call debug_vector  
a187				endm  
# End of macro CALLMONITOR
a187 c1			pop bc 
a188			endif 
a188			 
a188			 
a188			; create word preamble which should be: 
a188			 
a188			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a188			 
a188			;    ld hl, <word code> 
a188			;    jp user_exec 
a188			;    <word code bytes> 
a188			 
a188			 
a188			;	inc de     ; TODO ??? or are we already past the word's null 
a188 eb			ex de, hl 
a189			 
a189 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a18b			 
a18b 23			inc hl 
a18c 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a18f 23			inc hl 
a190			 
a190 23			inc hl 
a191 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a193			 
a193 01 0b cb		ld bc, user_exec 
a196 23			inc hl 
a197 71			ld (hl), c     ; poke address of user_exec 
a198 23			inc hl 
a199 70			ld (hl), b     
a19a			; 
a19a			;	inc hl 
a19a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a19a			; 
a19a			; 
a19a			;	ld bc, macro_forth_rsp_next 
a19a			;	inc hl 
a19a			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a19a			;	inc hl 
a19a			;	ld (hl), b     
a19a			; 
a19a			;	inc hl 
a19a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a19a			; 
a19a			; 
a19a			;	inc hl 
a19a			;	ld bc, forthexec 
a19a			;	ld (hl), c     ; poke address of forthexec 
a19a			;	inc hl 
a19a			;	ld (hl), b      
a19a			; 
a19a			;	inc hl 
a19a			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a19a			; 
a19a			;	ld bc, user_dict_next 
a19a			;	inc hl 
a19a			;	ld (hl), c     ; poke address of forthexec 
a19a			;	inc hl 
a19a			;	ld (hl), b      
a19a			 
a19a			; hl is now where we need to copy the word byte data to save this 
a19a			 
a19a 23			inc hl 
a19b 22 a9 e2		ld (os_new_exec), hl 
a19e			 
a19e			; copy definition 
a19e			 
a19e eb			ex de, hl 
a19f			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a19f			;	inc de    ; skip the PC for this parse 
a19f 3a b1 e2		ld a, (os_new_parse_len) 
a1a2 4f			ld c, a 
a1a3 06 00		ld b, 0 
a1a5 ed b0		ldir		 ; copy defintion 
a1a7			 
a1a7			 
a1a7			; poke the address of where the new word bytes live for forthexec 
a1a7			 
a1a7 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a1aa			 
a1aa ed 5b a9 e2	ld de, (os_new_exec)      
a1ae			 
a1ae 73			ld (hl), e 
a1af 23			inc hl 
a1b0 72			ld (hl), d 
a1b1			 
a1b1				; TODO copy last user dict word next link to this word 
a1b1				; TODO update last user dict word to point to this word 
a1b1			; 
a1b1			; hl f923 de 812a ; bc 811a 
a1b1			 
a1b1			if DEBUG_FORTH_UWORD 
a1b1 c5			push bc 
a1b2 ed 4b b3 e2	ld bc, (os_new_malloc) 
a1b6					DMARK ":0A" 
a1b6 f5				push af  
a1b7 3a cb a1			ld a, (.dmark)  
a1ba 32 6b ee			ld (debug_mark),a  
a1bd 3a cc a1			ld a, (.dmark+1)  
a1c0 32 6c ee			ld (debug_mark+1),a  
a1c3 3a cd a1			ld a, (.dmark+2)  
a1c6 32 6d ee			ld (debug_mark+2),a  
a1c9 18 03			jr .pastdmark  
a1cb ..			.dmark: db ":0A"  
a1ce f1			.pastdmark: pop af  
a1cf			endm  
# End of macro DMARK
a1cf			CALLMONITOR 
a1cf cd 6f ee			call debug_vector  
a1d2				endm  
# End of macro CALLMONITOR
a1d2 c1			pop bc 
a1d3			endif 
a1d3			if DEBUG_FORTH_UWORD 
a1d3 c5			push bc 
a1d4 ed 4b b3 e2	ld bc, (os_new_malloc) 
a1d8 03			inc bc 
a1d9 03			inc bc 
a1da 03			inc bc 
a1db 03			inc bc 
a1dc 03			inc bc 
a1dd 03			inc bc 
a1de 03			inc bc 
a1df 03			inc bc 
a1e0			 
a1e0					DMARK ":0B" 
a1e0 f5				push af  
a1e1 3a f5 a1			ld a, (.dmark)  
a1e4 32 6b ee			ld (debug_mark),a  
a1e7 3a f6 a1			ld a, (.dmark+1)  
a1ea 32 6c ee			ld (debug_mark+1),a  
a1ed 3a f7 a1			ld a, (.dmark+2)  
a1f0 32 6d ee			ld (debug_mark+2),a  
a1f3 18 03			jr .pastdmark  
a1f5 ..			.dmark: db ":0B"  
a1f8 f1			.pastdmark: pop af  
a1f9			endm  
# End of macro DMARK
a1f9			CALLMONITOR 
a1f9 cd 6f ee			call debug_vector  
a1fc				endm  
# End of macro CALLMONITOR
a1fc c1			pop bc 
a1fd			endif 
a1fd			 
a1fd			; update word dict linked list for new word 
a1fd			 
a1fd			 
a1fd 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a200 23			inc hl     ; move to next work linked list ptr 
a201			 
a201 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
a205 73			ld (hl), e 
a206 23			inc hl 
a207 72			ld (hl), d 
a208			 
a208			if DEBUG_FORTH_UWORD 
a208 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a20c			endif 
a20c			 
a20c ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a210			 
a210			 
a210			if DEBUG_FORTH_UWORD 
a210					DMARK ":0+" 
a210 f5				push af  
a211 3a 25 a2			ld a, (.dmark)  
a214 32 6b ee			ld (debug_mark),a  
a217 3a 26 a2			ld a, (.dmark+1)  
a21a 32 6c ee			ld (debug_mark+1),a  
a21d 3a 27 a2			ld a, (.dmark+2)  
a220 32 6d ee			ld (debug_mark+2),a  
a223 18 03			jr .pastdmark  
a225 ..			.dmark: db ":0+"  
a228 f1			.pastdmark: pop af  
a229			endm  
# End of macro DMARK
a229			CALLMONITOR 
a229 cd 6f ee			call debug_vector  
a22c				endm  
# End of macro CALLMONITOR
a22c			endif 
a22c			 
a22c			STACKFRAMECHK OFF $8efe $989f 
a22c				if DEBUG_STACK_IMB 
a22c					if OFF 
a22c						exx 
a22c						ld hl, $989f 
a22c						pop de   ; $989f 
a22c						call cmp16 
a22c						jr nz, .spnosame 
a22c						ld hl, $8efe 
a22c						pop de   ; $8efe 
a22c						call cmp16 
a22c						jr z, .spfrsame 
a22c						.spnosame: call showsperror 
a22c						.spfrsame: nop 
a22c						exx 
a22c					endif 
a22c				endif 
a22c			endm 
# End of macro STACKFRAMECHK
a22c			 
a22c c9			ret    ; dont process any remaining parser tokens as they form new word 
a22d			 
a22d			 
a22d			 
a22d			 
a22d			;		NEXT 
a22d			.SCOLN: 
a22d			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a22d 06			db OPCODE_SCOLN 
a22e 79 a2		dw .DROP 
a230 02			db 2 
a231 .. 00		db ";",0           
a233			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a233				if DEBUG_FORTH_WORDS_KEY 
a233					DMARK "SCN" 
a233 f5				push af  
a234 3a 48 a2			ld a, (.dmark)  
a237 32 6b ee			ld (debug_mark),a  
a23a 3a 49 a2			ld a, (.dmark+1)  
a23d 32 6c ee			ld (debug_mark+1),a  
a240 3a 4a a2			ld a, (.dmark+2)  
a243 32 6d ee			ld (debug_mark+2),a  
a246 18 03			jr .pastdmark  
a248 ..			.dmark: db "SCN"  
a24b f1			.pastdmark: pop af  
a24c			endm  
# End of macro DMARK
a24c					CALLMONITOR 
a24c cd 6f ee			call debug_vector  
a24f				endm  
# End of macro CALLMONITOR
a24f				endif 
a24f				FORTH_RSP_TOS 
a24f cd 20 9a			call macro_forth_rsp_tos 
a252				endm 
# End of macro FORTH_RSP_TOS
a252 e5				push hl 
a253				FORTH_RSP_POP 
a253 cd 2a 9a			call macro_forth_rsp_pop 
a256				endm 
# End of macro FORTH_RSP_POP
a256 e1				pop hl 
a257			;		ex de,hl 
a257 22 c2 e5			ld (os_tok_ptr),hl 
a25a			 
a25a			if DEBUG_FORTH_UWORD 
a25a					DMARK "SCL" 
a25a f5				push af  
a25b 3a 6f a2			ld a, (.dmark)  
a25e 32 6b ee			ld (debug_mark),a  
a261 3a 70 a2			ld a, (.dmark+1)  
a264 32 6c ee			ld (debug_mark+1),a  
a267 3a 71 a2			ld a, (.dmark+2)  
a26a 32 6d ee			ld (debug_mark+2),a  
a26d 18 03			jr .pastdmark  
a26f ..			.dmark: db "SCL"  
a272 f1			.pastdmark: pop af  
a273			endm  
# End of macro DMARK
a273			CALLMONITOR 
a273 cd 6f ee			call debug_vector  
a276				endm  
# End of macro CALLMONITOR
a276			endif 
a276				NEXTW 
a276 c3 1d 9e			jp macro_next 
a279				endm 
# End of macro NEXTW
a279			 
a279			.DROP: 
a279			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a279 1b				db WORD_SYS_CORE+OPCODE_DROP             
a27a a4 a2			dw .DUP2            
a27c 05				db 4 + 1 
a27d .. 00			db "DROP",0              
a282				endm 
# End of macro CWHEAD
a282			; | DROP ( w -- )   drop the TOS item   | DONE 
a282				if DEBUG_FORTH_WORDS_KEY 
a282					DMARK "DRP" 
a282 f5				push af  
a283 3a 97 a2			ld a, (.dmark)  
a286 32 6b ee			ld (debug_mark),a  
a289 3a 98 a2			ld a, (.dmark+1)  
a28c 32 6c ee			ld (debug_mark+1),a  
a28f 3a 99 a2			ld a, (.dmark+2)  
a292 32 6d ee			ld (debug_mark+2),a  
a295 18 03			jr .pastdmark  
a297 ..			.dmark: db "DRP"  
a29a f1			.pastdmark: pop af  
a29b			endm  
# End of macro DMARK
a29b					CALLMONITOR 
a29b cd 6f ee			call debug_vector  
a29e				endm  
# End of macro CALLMONITOR
a29e				endif 
a29e				FORTH_DSP_POP 
a29e cd 1f 9d			call macro_forth_dsp_pop 
a2a1				endm 
# End of macro FORTH_DSP_POP
a2a1				NEXTW 
a2a1 c3 1d 9e			jp macro_next 
a2a4				endm 
# End of macro NEXTW
a2a4			.DUP2: 
a2a4			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a2a4 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a2a5 e9 a2			dw .DROP2            
a2a7 05				db 4 + 1 
a2a8 .. 00			db "2DUP",0              
a2ad				endm 
# End of macro CWHEAD
a2ad			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a2ad				if DEBUG_FORTH_WORDS_KEY 
a2ad					DMARK "2DU" 
a2ad f5				push af  
a2ae 3a c2 a2			ld a, (.dmark)  
a2b1 32 6b ee			ld (debug_mark),a  
a2b4 3a c3 a2			ld a, (.dmark+1)  
a2b7 32 6c ee			ld (debug_mark+1),a  
a2ba 3a c4 a2			ld a, (.dmark+2)  
a2bd 32 6d ee			ld (debug_mark+2),a  
a2c0 18 03			jr .pastdmark  
a2c2 ..			.dmark: db "2DU"  
a2c5 f1			.pastdmark: pop af  
a2c6			endm  
# End of macro DMARK
a2c6					CALLMONITOR 
a2c6 cd 6f ee			call debug_vector  
a2c9				endm  
# End of macro CALLMONITOR
a2c9				endif 
a2c9				FORTH_DSP_VALUEHL 
a2c9 cd 67 9c			call macro_dsp_valuehl 
a2cc				endm 
# End of macro FORTH_DSP_VALUEHL
a2cc e5				push hl      ; 2 
a2cd			 
a2cd				FORTH_DSP_POP 
a2cd cd 1f 9d			call macro_forth_dsp_pop 
a2d0				endm 
# End of macro FORTH_DSP_POP
a2d0				 
a2d0				FORTH_DSP_VALUEHL 
a2d0 cd 67 9c			call macro_dsp_valuehl 
a2d3				endm 
# End of macro FORTH_DSP_VALUEHL
a2d3			;		push hl      ; 1 
a2d3			 
a2d3				FORTH_DSP_POP 
a2d3 cd 1f 9d			call macro_forth_dsp_pop 
a2d6				endm 
# End of macro FORTH_DSP_POP
a2d6			 
a2d6			;		pop hl       ; 1 
a2d6 d1				pop de       ; 2 
a2d7			 
a2d7 cd 62 9a			call forth_push_numhl 
a2da eb				ex de, hl 
a2db cd 62 9a			call forth_push_numhl 
a2de			 
a2de				 
a2de eb				ex de, hl 
a2df			 
a2df cd 62 9a			call forth_push_numhl 
a2e2 eb				ex de, hl 
a2e3 cd 62 9a			call forth_push_numhl 
a2e6			 
a2e6			 
a2e6				NEXTW 
a2e6 c3 1d 9e			jp macro_next 
a2e9				endm 
# End of macro NEXTW
a2e9			.DROP2: 
a2e9			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a2e9 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a2ea 18 a3			dw .SWAP2            
a2ec 06				db 5 + 1 
a2ed .. 00			db "2DROP",0              
a2f3				endm 
# End of macro CWHEAD
a2f3			; | 2DROP ( w w -- )    Double drop | DONE 
a2f3				if DEBUG_FORTH_WORDS_KEY 
a2f3					DMARK "2DR" 
a2f3 f5				push af  
a2f4 3a 08 a3			ld a, (.dmark)  
a2f7 32 6b ee			ld (debug_mark),a  
a2fa 3a 09 a3			ld a, (.dmark+1)  
a2fd 32 6c ee			ld (debug_mark+1),a  
a300 3a 0a a3			ld a, (.dmark+2)  
a303 32 6d ee			ld (debug_mark+2),a  
a306 18 03			jr .pastdmark  
a308 ..			.dmark: db "2DR"  
a30b f1			.pastdmark: pop af  
a30c			endm  
# End of macro DMARK
a30c					CALLMONITOR 
a30c cd 6f ee			call debug_vector  
a30f				endm  
# End of macro CALLMONITOR
a30f				endif 
a30f				FORTH_DSP_POP 
a30f cd 1f 9d			call macro_forth_dsp_pop 
a312				endm 
# End of macro FORTH_DSP_POP
a312				FORTH_DSP_POP 
a312 cd 1f 9d			call macro_forth_dsp_pop 
a315				endm 
# End of macro FORTH_DSP_POP
a315				NEXTW 
a315 c3 1d 9e			jp macro_next 
a318				endm 
# End of macro NEXTW
a318			.SWAP2: 
a318			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a318 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a319 41 a3			dw .AT            
a31b 06				db 5 + 1 
a31c .. 00			db "2SWAP",0              
a322				endm 
# End of macro CWHEAD
a322			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a322				if DEBUG_FORTH_WORDS_KEY 
a322					DMARK "2SW" 
a322 f5				push af  
a323 3a 37 a3			ld a, (.dmark)  
a326 32 6b ee			ld (debug_mark),a  
a329 3a 38 a3			ld a, (.dmark+1)  
a32c 32 6c ee			ld (debug_mark+1),a  
a32f 3a 39 a3			ld a, (.dmark+2)  
a332 32 6d ee			ld (debug_mark+2),a  
a335 18 03			jr .pastdmark  
a337 ..			.dmark: db "2SW"  
a33a f1			.pastdmark: pop af  
a33b			endm  
# End of macro DMARK
a33b					CALLMONITOR 
a33b cd 6f ee			call debug_vector  
a33e				endm  
# End of macro CALLMONITOR
a33e				endif 
a33e			; TODO Use os stack swap memory 
a33e				NEXTW 
a33e c3 1d 9e			jp macro_next 
a341				endm 
# End of macro NEXTW
a341			.AT: 
a341			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a341 1f				db WORD_SYS_CORE+OPCODE_AT             
a342 73 a3			dw .CAT            
a344 02				db 1 + 1 
a345 .. 00			db "@",0              
a347				endm 
# End of macro CWHEAD
a347			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a347			 
a347				if DEBUG_FORTH_WORDS_KEY 
a347					DMARK "AT." 
a347 f5				push af  
a348 3a 5c a3			ld a, (.dmark)  
a34b 32 6b ee			ld (debug_mark),a  
a34e 3a 5d a3			ld a, (.dmark+1)  
a351 32 6c ee			ld (debug_mark+1),a  
a354 3a 5e a3			ld a, (.dmark+2)  
a357 32 6d ee			ld (debug_mark+2),a  
a35a 18 03			jr .pastdmark  
a35c ..			.dmark: db "AT."  
a35f f1			.pastdmark: pop af  
a360			endm  
# End of macro DMARK
a360					CALLMONITOR 
a360 cd 6f ee			call debug_vector  
a363				endm  
# End of macro CALLMONITOR
a363				endif 
a363			.getbyteat:	 
a363				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a363 cd 67 9c			call macro_dsp_valuehl 
a366				endm 
# End of macro FORTH_DSP_VALUEHL
a366				 
a366			;		push hl 
a366			 
a366				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a366 cd 1f 9d			call macro_forth_dsp_pop 
a369				endm 
# End of macro FORTH_DSP_POP
a369			 
a369			;		pop hl 
a369			 
a369 7e				ld a, (hl) 
a36a			 
a36a 6f				ld l, a 
a36b 26 00			ld h, 0 
a36d cd 62 9a			call forth_push_numhl 
a370			 
a370				NEXTW 
a370 c3 1d 9e			jp macro_next 
a373				endm 
# End of macro NEXTW
a373			.CAT: 
a373			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a373 20				db WORD_SYS_CORE+OPCODE_CAT             
a374 9c a3			dw .BANG            
a376 03				db 2 + 1 
a377 .. 00			db "C@",0              
a37a				endm 
# End of macro CWHEAD
a37a			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a37a				if DEBUG_FORTH_WORDS_KEY 
a37a					DMARK "CAA" 
a37a f5				push af  
a37b 3a 8f a3			ld a, (.dmark)  
a37e 32 6b ee			ld (debug_mark),a  
a381 3a 90 a3			ld a, (.dmark+1)  
a384 32 6c ee			ld (debug_mark+1),a  
a387 3a 91 a3			ld a, (.dmark+2)  
a38a 32 6d ee			ld (debug_mark+2),a  
a38d 18 03			jr .pastdmark  
a38f ..			.dmark: db "CAA"  
a392 f1			.pastdmark: pop af  
a393			endm  
# End of macro DMARK
a393					CALLMONITOR 
a393 cd 6f ee			call debug_vector  
a396				endm  
# End of macro CALLMONITOR
a396				endif 
a396 c3 63 a3			jp .getbyteat 
a399				NEXTW 
a399 c3 1d 9e			jp macro_next 
a39c				endm 
# End of macro NEXTW
a39c			.BANG: 
a39c			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a39c 21				db WORD_SYS_CORE+OPCODE_BANG             
a39d d2 a3			dw .CBANG            
a39f 02				db 1 + 1 
a3a0 .. 00			db "!",0              
a3a2				endm 
# End of macro CWHEAD
a3a2			; | ! ( x w -- ) Store x at address w      | DONE 
a3a2				if DEBUG_FORTH_WORDS_KEY 
a3a2					DMARK "BNG" 
a3a2 f5				push af  
a3a3 3a b7 a3			ld a, (.dmark)  
a3a6 32 6b ee			ld (debug_mark),a  
a3a9 3a b8 a3			ld a, (.dmark+1)  
a3ac 32 6c ee			ld (debug_mark+1),a  
a3af 3a b9 a3			ld a, (.dmark+2)  
a3b2 32 6d ee			ld (debug_mark+2),a  
a3b5 18 03			jr .pastdmark  
a3b7 ..			.dmark: db "BNG"  
a3ba f1			.pastdmark: pop af  
a3bb			endm  
# End of macro DMARK
a3bb					CALLMONITOR 
a3bb cd 6f ee			call debug_vector  
a3be				endm  
# End of macro CALLMONITOR
a3be				endif 
a3be			 
a3be			.storebyteat:		 
a3be				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3be cd 67 9c			call macro_dsp_valuehl 
a3c1				endm 
# End of macro FORTH_DSP_VALUEHL
a3c1				 
a3c1 e5				push hl 
a3c2			 
a3c2				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3c2 cd 1f 9d			call macro_forth_dsp_pop 
a3c5				endm 
# End of macro FORTH_DSP_POP
a3c5			 
a3c5				; get byte to poke 
a3c5			 
a3c5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3c5 cd 67 9c			call macro_dsp_valuehl 
a3c8				endm 
# End of macro FORTH_DSP_VALUEHL
a3c8 e5				push hl 
a3c9			 
a3c9			 
a3c9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3c9 cd 1f 9d			call macro_forth_dsp_pop 
a3cc				endm 
# End of macro FORTH_DSP_POP
a3cc			 
a3cc			 
a3cc d1				pop de 
a3cd e1				pop hl 
a3ce			 
a3ce 73				ld (hl),e 
a3cf			 
a3cf			 
a3cf				NEXTW 
a3cf c3 1d 9e			jp macro_next 
a3d2				endm 
# End of macro NEXTW
a3d2			.CBANG: 
a3d2			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a3d2 22				db WORD_SYS_CORE+OPCODE_CBANG             
a3d3 fb a3			dw .SCALL            
a3d5 03				db 2 + 1 
a3d6 .. 00			db "C!",0              
a3d9				endm 
# End of macro CWHEAD
a3d9			; | C!  ( x w -- ) Store x at address w  | DONE 
a3d9				if DEBUG_FORTH_WORDS_KEY 
a3d9					DMARK "CBA" 
a3d9 f5				push af  
a3da 3a ee a3			ld a, (.dmark)  
a3dd 32 6b ee			ld (debug_mark),a  
a3e0 3a ef a3			ld a, (.dmark+1)  
a3e3 32 6c ee			ld (debug_mark+1),a  
a3e6 3a f0 a3			ld a, (.dmark+2)  
a3e9 32 6d ee			ld (debug_mark+2),a  
a3ec 18 03			jr .pastdmark  
a3ee ..			.dmark: db "CBA"  
a3f1 f1			.pastdmark: pop af  
a3f2			endm  
# End of macro DMARK
a3f2					CALLMONITOR 
a3f2 cd 6f ee			call debug_vector  
a3f5				endm  
# End of macro CALLMONITOR
a3f5				endif 
a3f5 c3 be a3			jp .storebyteat 
a3f8				NEXTW 
a3f8 c3 1d 9e			jp macro_next 
a3fb				endm 
# End of macro NEXTW
a3fb			.SCALL: 
a3fb			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a3fb 23				db WORD_SYS_CORE+OPCODE_SCALL             
a3fc 2f a4			dw .DEPTH            
a3fe 05				db 4 + 1 
a3ff .. 00			db "CALL",0              
a404				endm 
# End of macro CWHEAD
a404			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a404				if DEBUG_FORTH_WORDS_KEY 
a404					DMARK "CLL" 
a404 f5				push af  
a405 3a 19 a4			ld a, (.dmark)  
a408 32 6b ee			ld (debug_mark),a  
a40b 3a 1a a4			ld a, (.dmark+1)  
a40e 32 6c ee			ld (debug_mark+1),a  
a411 3a 1b a4			ld a, (.dmark+2)  
a414 32 6d ee			ld (debug_mark+2),a  
a417 18 03			jr .pastdmark  
a419 ..			.dmark: db "CLL"  
a41c f1			.pastdmark: pop af  
a41d			endm  
# End of macro DMARK
a41d					CALLMONITOR 
a41d cd 6f ee			call debug_vector  
a420				endm  
# End of macro CALLMONITOR
a420				endif 
a420			 
a420				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a420 cd 67 9c			call macro_dsp_valuehl 
a423				endm 
# End of macro FORTH_DSP_VALUEHL
a423			 
a423			;		push hl 
a423			 
a423				; destroy value TOS 
a423			 
a423				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a423 cd 1f 9d			call macro_forth_dsp_pop 
a426				endm 
# End of macro FORTH_DSP_POP
a426			 
a426					 
a426			;		pop hl 
a426			 
a426				; how to do a call with hl???? save SP? 
a426 cd c1 9d			call forth_call_hl 
a429			 
a429			 
a429				; TODO push value back onto stack for another op etc 
a429			 
a429 cd 62 9a			call forth_push_numhl 
a42c				NEXTW 
a42c c3 1d 9e			jp macro_next 
a42f				endm 
# End of macro NEXTW
a42f			.DEPTH: 
a42f			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a42f 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a430 6c a4			dw .OVER            
a432 06				db 5 + 1 
a433 .. 00			db "DEPTH",0              
a439				endm 
# End of macro CWHEAD
a439			; | DEPTH ( -- u ) Push count of stack | DONE 
a439				; take current TOS and remove from base value div by two to get count 
a439				if DEBUG_FORTH_WORDS_KEY 
a439					DMARK "DEP" 
a439 f5				push af  
a43a 3a 4e a4			ld a, (.dmark)  
a43d 32 6b ee			ld (debug_mark),a  
a440 3a 4f a4			ld a, (.dmark+1)  
a443 32 6c ee			ld (debug_mark+1),a  
a446 3a 50 a4			ld a, (.dmark+2)  
a449 32 6d ee			ld (debug_mark+2),a  
a44c 18 03			jr .pastdmark  
a44e ..			.dmark: db "DEP"  
a451 f1			.pastdmark: pop af  
a452			endm  
# End of macro DMARK
a452					CALLMONITOR 
a452 cd 6f ee			call debug_vector  
a455				endm  
# End of macro CALLMONITOR
a455				endif 
a455			 
a455			 
a455 2a ee e9		ld hl, (cli_data_sp) 
a458 11 28 e8		ld de, cli_data_stack 
a45b ed 52		sbc hl,de 
a45d			 
a45d			; div by size of stack item 
a45d			 
a45d 5d			ld e,l 
a45e 0e 03		ld c, 3 
a460 cd 6b 8c		call Div8 
a463			 
a463 6f			ld l,a 
a464 26 00		ld h,0 
a466			 
a466			;srl h 
a466			;rr l 
a466			 
a466 cd 62 9a			call forth_push_numhl 
a469				NEXTW 
a469 c3 1d 9e			jp macro_next 
a46c				endm 
# End of macro NEXTW
a46c			.OVER: 
a46c			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a46c 42				db WORD_SYS_CORE+46             
a46d b3 a4			dw .PAUSE            
a46f 05				db 4 + 1 
a470 .. 00			db "OVER",0              
a475				endm 
# End of macro CWHEAD
a475			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a475				if DEBUG_FORTH_WORDS_KEY 
a475					DMARK "OVR" 
a475 f5				push af  
a476 3a 8a a4			ld a, (.dmark)  
a479 32 6b ee			ld (debug_mark),a  
a47c 3a 8b a4			ld a, (.dmark+1)  
a47f 32 6c ee			ld (debug_mark+1),a  
a482 3a 8c a4			ld a, (.dmark+2)  
a485 32 6d ee			ld (debug_mark+2),a  
a488 18 03			jr .pastdmark  
a48a ..			.dmark: db "OVR"  
a48d f1			.pastdmark: pop af  
a48e			endm  
# End of macro DMARK
a48e					CALLMONITOR 
a48e cd 6f ee			call debug_vector  
a491				endm  
# End of macro CALLMONITOR
a491				endif 
a491			 
a491			; TODO Use os stack swap memory 
a491				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a491 cd 67 9c			call macro_dsp_valuehl 
a494				endm 
# End of macro FORTH_DSP_VALUEHL
a494 e5				push hl    ; n2 
a495				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a495 cd 1f 9d			call macro_forth_dsp_pop 
a498				endm 
# End of macro FORTH_DSP_POP
a498			 
a498				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a498 cd 67 9c			call macro_dsp_valuehl 
a49b				endm 
# End of macro FORTH_DSP_VALUEHL
a49b e5				push hl    ; n1 
a49c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a49c cd 1f 9d			call macro_forth_dsp_pop 
a49f				endm 
# End of macro FORTH_DSP_POP
a49f			 
a49f d1				pop de     ; n1 
a4a0 e1				pop hl     ; n2 
a4a1			 
a4a1 d5				push de 
a4a2 e5				push hl 
a4a3 d5				push de 
a4a4			 
a4a4				; push back  
a4a4			 
a4a4 e1				pop hl 
a4a5 cd 62 9a			call forth_push_numhl 
a4a8 e1				pop hl 
a4a9 cd 62 9a			call forth_push_numhl 
a4ac e1				pop hl 
a4ad cd 62 9a			call forth_push_numhl 
a4b0				NEXTW 
a4b0 c3 1d 9e			jp macro_next 
a4b3				endm 
# End of macro NEXTW
a4b3			 
a4b3			.PAUSE: 
a4b3			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a4b3 43				db WORD_SYS_CORE+47             
a4b4 e8 a4			dw .PAUSES            
a4b6 08				db 7 + 1 
a4b7 .. 00			db "PAUSEMS",0              
a4bf				endm 
# End of macro CWHEAD
a4bf			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a4bf				if DEBUG_FORTH_WORDS_KEY 
a4bf					DMARK "PMS" 
a4bf f5				push af  
a4c0 3a d4 a4			ld a, (.dmark)  
a4c3 32 6b ee			ld (debug_mark),a  
a4c6 3a d5 a4			ld a, (.dmark+1)  
a4c9 32 6c ee			ld (debug_mark+1),a  
a4cc 3a d6 a4			ld a, (.dmark+2)  
a4cf 32 6d ee			ld (debug_mark+2),a  
a4d2 18 03			jr .pastdmark  
a4d4 ..			.dmark: db "PMS"  
a4d7 f1			.pastdmark: pop af  
a4d8			endm  
# End of macro DMARK
a4d8					CALLMONITOR 
a4d8 cd 6f ee			call debug_vector  
a4db				endm  
# End of macro CALLMONITOR
a4db				endif 
a4db				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4db cd 67 9c			call macro_dsp_valuehl 
a4de				endm 
# End of macro FORTH_DSP_VALUEHL
a4de			;		push hl    ; n2 
a4de				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4de cd 1f 9d			call macro_forth_dsp_pop 
a4e1				endm 
# End of macro FORTH_DSP_POP
a4e1			;		pop hl 
a4e1			 
a4e1 7d				ld a, l 
a4e2 cd d6 89			call aDelayInMS 
a4e5			       NEXTW 
a4e5 c3 1d 9e			jp macro_next 
a4e8				endm 
# End of macro NEXTW
a4e8			.PAUSES:  
a4e8			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a4e8 44				db WORD_SYS_CORE+48             
a4e9 57 a5			dw .ROT            
a4eb 06				db 5 + 1 
a4ec .. 00			db "PAUSE",0              
a4f2				endm 
# End of macro CWHEAD
a4f2			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a4f2				if DEBUG_FORTH_WORDS_KEY 
a4f2					DMARK "PAU" 
a4f2 f5				push af  
a4f3 3a 07 a5			ld a, (.dmark)  
a4f6 32 6b ee			ld (debug_mark),a  
a4f9 3a 08 a5			ld a, (.dmark+1)  
a4fc 32 6c ee			ld (debug_mark+1),a  
a4ff 3a 09 a5			ld a, (.dmark+2)  
a502 32 6d ee			ld (debug_mark+2),a  
a505 18 03			jr .pastdmark  
a507 ..			.dmark: db "PAU"  
a50a f1			.pastdmark: pop af  
a50b			endm  
# End of macro DMARK
a50b					CALLMONITOR 
a50b cd 6f ee			call debug_vector  
a50e				endm  
# End of macro CALLMONITOR
a50e				endif 
a50e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a50e cd 67 9c			call macro_dsp_valuehl 
a511				endm 
# End of macro FORTH_DSP_VALUEHL
a511			;		push hl    ; n2 
a511				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a511 cd 1f 9d			call macro_forth_dsp_pop 
a514				endm 
# End of macro FORTH_DSP_POP
a514			;		pop hl 
a514 45				ld b, l 
a515				if DEBUG_FORTH_WORDS 
a515					DMARK "PAU" 
a515 f5				push af  
a516 3a 2a a5			ld a, (.dmark)  
a519 32 6b ee			ld (debug_mark),a  
a51c 3a 2b a5			ld a, (.dmark+1)  
a51f 32 6c ee			ld (debug_mark+1),a  
a522 3a 2c a5			ld a, (.dmark+2)  
a525 32 6d ee			ld (debug_mark+2),a  
a528 18 03			jr .pastdmark  
a52a ..			.dmark: db "PAU"  
a52d f1			.pastdmark: pop af  
a52e			endm  
# End of macro DMARK
a52e					CALLMONITOR 
a52e cd 6f ee			call debug_vector  
a531				endm  
# End of macro CALLMONITOR
a531				endif 
a531 c5			.pauses1:	push bc 
a532 cd f1 89			call delay1s 
a535 c1				pop bc 
a536				if DEBUG_FORTH_WORDS 
a536					DMARK "PA1" 
a536 f5				push af  
a537 3a 4b a5			ld a, (.dmark)  
a53a 32 6b ee			ld (debug_mark),a  
a53d 3a 4c a5			ld a, (.dmark+1)  
a540 32 6c ee			ld (debug_mark+1),a  
a543 3a 4d a5			ld a, (.dmark+2)  
a546 32 6d ee			ld (debug_mark+2),a  
a549 18 03			jr .pastdmark  
a54b ..			.dmark: db "PA1"  
a54e f1			.pastdmark: pop af  
a54f			endm  
# End of macro DMARK
a54f					CALLMONITOR 
a54f cd 6f ee			call debug_vector  
a552				endm  
# End of macro CALLMONITOR
a552				endif 
a552 10 dd			djnz .pauses1 
a554			 
a554			       NEXTW 
a554 c3 1d 9e			jp macro_next 
a557				endm 
# End of macro NEXTW
a557			.ROT: 
a557			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a557 45				db WORD_SYS_CORE+49             
a558 a5 a5			dw .UWORDS            
a55a 04				db 3 + 1 
a55b .. 00			db "ROT",0              
a55f				endm 
# End of macro CWHEAD
a55f			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a55f				if DEBUG_FORTH_WORDS_KEY 
a55f					DMARK "ROT" 
a55f f5				push af  
a560 3a 74 a5			ld a, (.dmark)  
a563 32 6b ee			ld (debug_mark),a  
a566 3a 75 a5			ld a, (.dmark+1)  
a569 32 6c ee			ld (debug_mark+1),a  
a56c 3a 76 a5			ld a, (.dmark+2)  
a56f 32 6d ee			ld (debug_mark+2),a  
a572 18 03			jr .pastdmark  
a574 ..			.dmark: db "ROT"  
a577 f1			.pastdmark: pop af  
a578			endm  
# End of macro DMARK
a578					CALLMONITOR 
a578 cd 6f ee			call debug_vector  
a57b				endm  
# End of macro CALLMONITOR
a57b				endif 
a57b			 
a57b			; TODO Use os stack swap memory 
a57b				FORTH_DSP_VALUEHL 
a57b cd 67 9c			call macro_dsp_valuehl 
a57e				endm 
# End of macro FORTH_DSP_VALUEHL
a57e e5				push hl    ; u3  
a57f			 
a57f				FORTH_DSP_POP 
a57f cd 1f 9d			call macro_forth_dsp_pop 
a582				endm 
# End of macro FORTH_DSP_POP
a582			 
a582				FORTH_DSP_VALUEHL 
a582 cd 67 9c			call macro_dsp_valuehl 
a585				endm 
# End of macro FORTH_DSP_VALUEHL
a585 e5				push hl     ; u2 
a586			 
a586				FORTH_DSP_POP 
a586 cd 1f 9d			call macro_forth_dsp_pop 
a589				endm 
# End of macro FORTH_DSP_POP
a589			 
a589				FORTH_DSP_VALUEHL 
a589 cd 67 9c			call macro_dsp_valuehl 
a58c				endm 
# End of macro FORTH_DSP_VALUEHL
a58c e5				push hl     ; u1 
a58d			 
a58d				FORTH_DSP_POP 
a58d cd 1f 9d			call macro_forth_dsp_pop 
a590				endm 
# End of macro FORTH_DSP_POP
a590			 
a590 c1				pop bc      ; u1 
a591 e1				pop hl      ; u2 
a592 d1				pop de      ; u3 
a593			 
a593			 
a593 c5				push bc 
a594 d5				push de 
a595 e5				push hl 
a596			 
a596			 
a596 e1				pop hl 
a597 cd 62 9a			call forth_push_numhl 
a59a			 
a59a e1				pop hl 
a59b cd 62 9a			call forth_push_numhl 
a59e			 
a59e e1				pop hl 
a59f cd 62 9a			call forth_push_numhl 
a5a2				 
a5a2			 
a5a2			 
a5a2			 
a5a2			 
a5a2			 
a5a2			       NEXTW 
a5a2 c3 1d 9e			jp macro_next 
a5a5				endm 
# End of macro NEXTW
a5a5			 
a5a5			.UWORDS: 
a5a5			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a5a5 50				db WORD_SYS_CORE+60             
a5a6 67 a6			dw .BP            
a5a8 07				db 6 + 1 
a5a9 .. 00			db "UWORDS",0              
a5b0				endm 
# End of macro CWHEAD
a5b0			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a5b0			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a5b0			; | | Following the count are the individual words. 
a5b0			; | | 
a5b0			; | | e.g. UWORDS 
a5b0			; | | BOX DIRLIST 2 
a5b0			; | |  
a5b0			; | | Can be used to save the words to storage via: 
a5b0			; | | UWORDS $01 DO $01 APPEND LOOP 
a5b0			if DEBUG_FORTH_WORDS_KEY 
a5b0				DMARK "UWR" 
a5b0 f5				push af  
a5b1 3a c5 a5			ld a, (.dmark)  
a5b4 32 6b ee			ld (debug_mark),a  
a5b7 3a c6 a5			ld a, (.dmark+1)  
a5ba 32 6c ee			ld (debug_mark+1),a  
a5bd 3a c7 a5			ld a, (.dmark+2)  
a5c0 32 6d ee			ld (debug_mark+2),a  
a5c3 18 03			jr .pastdmark  
a5c5 ..			.dmark: db "UWR"  
a5c8 f1			.pastdmark: pop af  
a5c9			endm  
# End of macro DMARK
a5c9				CALLMONITOR 
a5c9 cd 6f ee			call debug_vector  
a5cc				endm  
# End of macro CALLMONITOR
a5cc			endif 
a5cc 21 11 dd			ld hl, baseram 
a5cf				;ld hl, baseusermem 
a5cf 01 00 00			ld bc, 0    ; start a counter 
a5d2			 
a5d2			; skip dict stub 
a5d2			 
a5d2 cd 6e 9f			call forth_tok_next 
a5d5			 
a5d5			 
a5d5			; while we have words to look for 
a5d5			 
a5d5 7e			.douscan:	ld a, (hl)      
a5d6			if DEBUG_FORTH_WORDS 
a5d6				DMARK "UWs" 
a5d6 f5				push af  
a5d7 3a eb a5			ld a, (.dmark)  
a5da 32 6b ee			ld (debug_mark),a  
a5dd 3a ec a5			ld a, (.dmark+1)  
a5e0 32 6c ee			ld (debug_mark+1),a  
a5e3 3a ed a5			ld a, (.dmark+2)  
a5e6 32 6d ee			ld (debug_mark+2),a  
a5e9 18 03			jr .pastdmark  
a5eb ..			.dmark: db "UWs"  
a5ee f1			.pastdmark: pop af  
a5ef			endm  
# End of macro DMARK
a5ef				CALLMONITOR 
a5ef cd 6f ee			call debug_vector  
a5f2				endm  
# End of macro CALLMONITOR
a5f2			endif 
a5f2 fe 00			cp WORD_SYS_END 
a5f4 28 4d			jr z, .udone 
a5f6 fe 01			cp WORD_SYS_UWORD 
a5f8 20 44			jr nz, .nuword 
a5fa			 
a5fa			if DEBUG_FORTH_WORDS 
a5fa				DMARK "UWu" 
a5fa f5				push af  
a5fb 3a 0f a6			ld a, (.dmark)  
a5fe 32 6b ee			ld (debug_mark),a  
a601 3a 10 a6			ld a, (.dmark+1)  
a604 32 6c ee			ld (debug_mark+1),a  
a607 3a 11 a6			ld a, (.dmark+2)  
a60a 32 6d ee			ld (debug_mark+2),a  
a60d 18 03			jr .pastdmark  
a60f ..			.dmark: db "UWu"  
a612 f1			.pastdmark: pop af  
a613			endm  
# End of macro DMARK
a613				CALLMONITOR 
a613 cd 6f ee			call debug_vector  
a616				endm  
# End of macro CALLMONITOR
a616			endif 
a616				; we have a uword so push its name to the stack 
a616			 
a616 e5				push hl  ; save so we can move to next dict block 
a617			 
a617				; skip opcode 
a617 23				inc hl  
a618				; skip next ptr 
a618 23				inc hl  
a619 23				inc hl 
a61a				; skip len 
a61a 23				inc hl 
a61b			if DEBUG_FORTH_WORDS 
a61b				DMARK "UWt" 
a61b f5				push af  
a61c 3a 30 a6			ld a, (.dmark)  
a61f 32 6b ee			ld (debug_mark),a  
a622 3a 31 a6			ld a, (.dmark+1)  
a625 32 6c ee			ld (debug_mark+1),a  
a628 3a 32 a6			ld a, (.dmark+2)  
a62b 32 6d ee			ld (debug_mark+2),a  
a62e 18 03			jr .pastdmark  
a630 ..			.dmark: db "UWt"  
a633 f1			.pastdmark: pop af  
a634			endm  
# End of macro DMARK
a634				CALLMONITOR 
a634 cd 6f ee			call debug_vector  
a637				endm  
# End of macro CALLMONITOR
a637			endif 
a637 03				inc bc 
a638			 
a638 c5				push bc 
a639 cd d0 9a			call forth_push_str 
a63c c1				pop bc 
a63d			 
a63d e1				pop hl 	 
a63e			 
a63e cd 6e 9f		.nuword:	call forth_tok_next 
a641 18 92			jr .douscan  
a643			 
a643			.udone:		 ; push count of uwords found 
a643 c5				push bc 
a644 e1				pop hl 
a645			 
a645			if DEBUG_FORTH_WORDS 
a645				DMARK "UWc" 
a645 f5				push af  
a646 3a 5a a6			ld a, (.dmark)  
a649 32 6b ee			ld (debug_mark),a  
a64c 3a 5b a6			ld a, (.dmark+1)  
a64f 32 6c ee			ld (debug_mark+1),a  
a652 3a 5c a6			ld a, (.dmark+2)  
a655 32 6d ee			ld (debug_mark+2),a  
a658 18 03			jr .pastdmark  
a65a ..			.dmark: db "UWc"  
a65d f1			.pastdmark: pop af  
a65e			endm  
# End of macro DMARK
a65e				CALLMONITOR 
a65e cd 6f ee			call debug_vector  
a661				endm  
# End of macro CALLMONITOR
a661			endif 
a661 cd 62 9a			call forth_push_numhl 
a664			 
a664			 
a664			       NEXTW 
a664 c3 1d 9e			jp macro_next 
a667				endm 
# End of macro NEXTW
a667			 
a667			.BP: 
a667			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a667 54				db WORD_SYS_CORE+64             
a668 a1 a6			dw .MONITOR            
a66a 03				db 2 + 1 
a66b .. 00			db "BP",0              
a66e				endm 
# End of macro CWHEAD
a66e			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a66e			; | | $00 Will enable the break points within specific code paths 
a66e			; | | $01 Will disable break points 
a66e			; | |  
a66e			; | | By default break points are off. Either the above can be used to enable them 
a66e			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a66e			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a66e			; | | can disable break points. Exiting will then continue boot process. 
a66e				; get byte count 
a66e				if DEBUG_FORTH_WORDS_KEY 
a66e					DMARK "BP." 
a66e f5				push af  
a66f 3a 83 a6			ld a, (.dmark)  
a672 32 6b ee			ld (debug_mark),a  
a675 3a 84 a6			ld a, (.dmark+1)  
a678 32 6c ee			ld (debug_mark+1),a  
a67b 3a 85 a6			ld a, (.dmark+2)  
a67e 32 6d ee			ld (debug_mark+2),a  
a681 18 03			jr .pastdmark  
a683 ..			.dmark: db "BP."  
a686 f1			.pastdmark: pop af  
a687			endm  
# End of macro DMARK
a687					CALLMONITOR 
a687 cd 6f ee			call debug_vector  
a68a				endm  
# End of macro CALLMONITOR
a68a				endif 
a68a			 
a68a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a68a cd 67 9c			call macro_dsp_valuehl 
a68d				endm 
# End of macro FORTH_DSP_VALUEHL
a68d			 
a68d			;		push hl 
a68d			 
a68d				; destroy value TOS 
a68d			 
a68d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a68d cd 1f 9d			call macro_forth_dsp_pop 
a690				endm 
# End of macro FORTH_DSP_POP
a690			 
a690			;		pop hl 
a690			 
a690 3e 00			ld a,0 
a692 bd				cp l 
a693 28 06			jr z, .bpset 
a695			;		ld a, '*' 
a695 cd f1 93			call bp_off 
a698				NEXTW 
a698 c3 1d 9e			jp macro_next 
a69b				endm 
# End of macro NEXTW
a69b			 
a69b			.bpset:	 
a69b				;	ld (os_view_disable), a 
a69b cd e5 93			call bp_on 
a69e			 
a69e			 
a69e				NEXTW 
a69e c3 1d 9e			jp macro_next 
a6a1				endm 
# End of macro NEXTW
a6a1			 
a6a1			 
a6a1			.MONITOR: 
a6a1			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a6a1 55				db WORD_SYS_CORE+65             
a6a2 d2 a6			dw .MALLOC            
a6a4 08				db 7 + 1 
a6a5 .. 00			db "MONITOR",0              
a6ad				endm 
# End of macro CWHEAD
a6ad			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a6ad			; | | At start the current various registers will be displayed with contents. 
a6ad			; | | Top right corner will show the most recent debug marker seen. 
a6ad			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a6ad			; | | and the return stack pointer (RSP). 
a6ad			; | | Pressing: 
a6ad			; | |    1 - Initial screen 
a6ad			; | |    2 - Display a data dump of HL 
a6ad			; | |    3 - Display a data dump of DE 
a6ad			; | |    4 - Display a data dump of BC 
a6ad			; | |    5 - Display a data dump of HL 
a6ad			; | |    6 - Display a data dump of DSP 
a6ad			; | |    7 - Display a data dump of RSP 
a6ad			; | |    8 - Display a data dump of what is at DSP 
a6ad			; | |    9 - Display a data dump of what is at RSP 
a6ad			; | |    0 - Exit monitor and continue running. This will also enable break points 
a6ad			; | |    * - Disable break points 
a6ad			; | |    # - Enter traditional monitor mode 
a6ad			; | | 
a6ad			; | | Monitor Mode 
a6ad			; | | ------------ 
a6ad			; | | A prompt of '>' will be shown for various commands: 
a6ad			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a6ad			; | |    C - Continue display a data dump from the last set address 
a6ad			; | |    M xxxx - Set start of memory edit at address xx 
a6ad			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a6ad			; | |    G xxxx - Exec code at specific address 
a6ad			; | |    Q - Return to previous 
a6ad				if DEBUG_FORTH_WORDS_KEY 
a6ad					DMARK "MON" 
a6ad f5				push af  
a6ae 3a c2 a6			ld a, (.dmark)  
a6b1 32 6b ee			ld (debug_mark),a  
a6b4 3a c3 a6			ld a, (.dmark+1)  
a6b7 32 6c ee			ld (debug_mark+1),a  
a6ba 3a c4 a6			ld a, (.dmark+2)  
a6bd 32 6d ee			ld (debug_mark+2),a  
a6c0 18 03			jr .pastdmark  
a6c2 ..			.dmark: db "MON"  
a6c5 f1			.pastdmark: pop af  
a6c6			endm  
# End of macro DMARK
a6c6					CALLMONITOR 
a6c6 cd 6f ee			call debug_vector  
a6c9				endm  
# End of macro CALLMONITOR
a6c9				endif 
a6c9			;		ld a, 0 
a6c9			;		ld (os_view_disable), a 
a6c9 cd e5 93			call bp_on 
a6cc			 
a6cc				CALLMONITOR 
a6cc cd 6f ee			call debug_vector  
a6cf				endm  
# End of macro CALLMONITOR
a6cf			 
a6cf			;	call monitor 
a6cf			 
a6cf				NEXTW 
a6cf c3 1d 9e			jp macro_next 
a6d2				endm 
# End of macro NEXTW
a6d2			 
a6d2			 
a6d2			.MALLOC: 
a6d2			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a6d2 56				db WORD_SYS_CORE+66             
a6d3 fb a6			dw .MALLOC2            
a6d5 06				db 5 + 1 
a6d6 .. 00			db "ALLOT",0              
a6dc				endm 
# End of macro CWHEAD
a6dc			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a6dc				if DEBUG_FORTH_WORDS_KEY 
a6dc					DMARK "ALL" 
a6dc f5				push af  
a6dd 3a f1 a6			ld a, (.dmark)  
a6e0 32 6b ee			ld (debug_mark),a  
a6e3 3a f2 a6			ld a, (.dmark+1)  
a6e6 32 6c ee			ld (debug_mark+1),a  
a6e9 3a f3 a6			ld a, (.dmark+2)  
a6ec 32 6d ee			ld (debug_mark+2),a  
a6ef 18 03			jr .pastdmark  
a6f1 ..			.dmark: db "ALL"  
a6f4 f1			.pastdmark: pop af  
a6f5			endm  
# End of macro DMARK
a6f5					CALLMONITOR 
a6f5 cd 6f ee			call debug_vector  
a6f8				endm  
# End of macro CALLMONITOR
a6f8				endif 
a6f8 c3 22 a7			jp .mallocc 
a6fb			.MALLOC2: 
a6fb			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a6fb 56				db WORD_SYS_CORE+66             
a6fc 39 a7			dw .FREE            
a6fe 07				db 6 + 1 
a6ff .. 00			db "MALLOC",0              
a706				endm 
# End of macro CWHEAD
a706			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a706				; get byte count 
a706				if DEBUG_FORTH_WORDS_KEY 
a706					DMARK "MAL" 
a706 f5				push af  
a707 3a 1b a7			ld a, (.dmark)  
a70a 32 6b ee			ld (debug_mark),a  
a70d 3a 1c a7			ld a, (.dmark+1)  
a710 32 6c ee			ld (debug_mark+1),a  
a713 3a 1d a7			ld a, (.dmark+2)  
a716 32 6d ee			ld (debug_mark+2),a  
a719 18 03			jr .pastdmark  
a71b ..			.dmark: db "MAL"  
a71e f1			.pastdmark: pop af  
a71f			endm  
# End of macro DMARK
a71f					CALLMONITOR 
a71f cd 6f ee			call debug_vector  
a722				endm  
# End of macro CALLMONITOR
a722				endif 
a722			.mallocc: 
a722				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a722 cd 67 9c			call macro_dsp_valuehl 
a725				endm 
# End of macro FORTH_DSP_VALUEHL
a725			 
a725			;		push hl 
a725			 
a725				; destroy value TOS 
a725			 
a725				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a725 cd 1f 9d			call macro_forth_dsp_pop 
a728				endm 
# End of macro FORTH_DSP_POP
a728			 
a728			;		pop hl 
a728 cd b6 90			call malloc 
a72b			if DEBUG_FORTH_MALLOC_GUARD 
a72b f5				push af 
a72c cd 04 8d			call ishlzero 
a72f			;		ld a, l 
a72f			;		add h 
a72f			;		cp 0 
a72f f1				pop af 
a730				 
a730 cc dd cb			call z,malloc_error 
a733			endif 
a733			 
a733 cd 62 9a			call forth_push_numhl 
a736				NEXTW 
a736 c3 1d 9e			jp macro_next 
a739				endm 
# End of macro NEXTW
a739			 
a739			.FREE: 
a739			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a739 57				db WORD_SYS_CORE+67             
a73a 6a a7			dw .LIST            
a73c 05				db 4 + 1 
a73d .. 00			db "FREE",0              
a742				endm 
# End of macro CWHEAD
a742			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a742				if DEBUG_FORTH_WORDS_KEY 
a742					DMARK "FRE" 
a742 f5				push af  
a743 3a 57 a7			ld a, (.dmark)  
a746 32 6b ee			ld (debug_mark),a  
a749 3a 58 a7			ld a, (.dmark+1)  
a74c 32 6c ee			ld (debug_mark+1),a  
a74f 3a 59 a7			ld a, (.dmark+2)  
a752 32 6d ee			ld (debug_mark+2),a  
a755 18 03			jr .pastdmark  
a757 ..			.dmark: db "FRE"  
a75a f1			.pastdmark: pop af  
a75b			endm  
# End of macro DMARK
a75b					CALLMONITOR 
a75b cd 6f ee			call debug_vector  
a75e				endm  
# End of macro CALLMONITOR
a75e				endif 
a75e				; get address 
a75e			 
a75e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a75e cd 67 9c			call macro_dsp_valuehl 
a761				endm 
# End of macro FORTH_DSP_VALUEHL
a761			 
a761			;		push hl 
a761			 
a761				; destroy value TOS 
a761			 
a761				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a761 cd 1f 9d			call macro_forth_dsp_pop 
a764				endm 
# End of macro FORTH_DSP_POP
a764			 
a764			;		pop hl 
a764			if FORTH_ENABLE_MALLOCFREE 
a764 cd 80 91			call free 
a767			endif 
a767				NEXTW 
a767 c3 1d 9e			jp macro_next 
a76a				endm 
# End of macro NEXTW
a76a			.LIST: 
a76a			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a76a 5c				db WORD_SYS_CORE+72             
a76b 5a a9			dw .FORGET            
a76d 05				db 4 + 1 
a76e .. 00			db "LIST",0              
a773				endm 
# End of macro CWHEAD
a773			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a773			; | | The quoted word must be in upper case. 
a773			if DEBUG_FORTH_WORDS_KEY 
a773				DMARK "LST" 
a773 f5				push af  
a774 3a 88 a7			ld a, (.dmark)  
a777 32 6b ee			ld (debug_mark),a  
a77a 3a 89 a7			ld a, (.dmark+1)  
a77d 32 6c ee			ld (debug_mark+1),a  
a780 3a 8a a7			ld a, (.dmark+2)  
a783 32 6d ee			ld (debug_mark+2),a  
a786 18 03			jr .pastdmark  
a788 ..			.dmark: db "LST"  
a78b f1			.pastdmark: pop af  
a78c			endm  
# End of macro DMARK
a78c				CALLMONITOR 
a78c cd 6f ee			call debug_vector  
a78f				endm  
# End of macro CALLMONITOR
a78f			endif 
a78f			 
a78f				FORTH_DSP_VALUEHL 
a78f cd 67 9c			call macro_dsp_valuehl 
a792				endm 
# End of macro FORTH_DSP_VALUEHL
a792			 
a792 e5				push hl 
a793				FORTH_DSP_POP 
a793 cd 1f 9d			call macro_forth_dsp_pop 
a796				endm 
# End of macro FORTH_DSP_POP
a796 c1				pop bc 
a797			 
a797			; Start format of scratch string 
a797			 
a797 21 c1 e2			ld hl, scratch 
a79a			 
a79a 3e 3a			ld a, ':' 
a79c 77				ld (hl),a 
a79d 23				inc hl 
a79e 3e 20			ld a, ' ' 
a7a0 77				ld (hl), a 
a7a1			 
a7a1				; Get ptr to the word we need to look up 
a7a1			 
a7a1			;		FORTH_DSP_VALUEHL 
a7a1				;v5 FORTH_DSP_VALUE 
a7a1			; TODO type check 
a7a1			;		inc hl    ; Skip type check  
a7a1			;		push hl 
a7a1			;		ex de, hl    ; put into DE 
a7a1			 
a7a1			 
a7a1 21 11 dd			ld hl, baseram 
a7a4				;ld hl, baseusermem 
a7a4			 
a7a4 e5			push hl   ; sacreifical push 
a7a5			 
a7a5			.ldouscanm: 
a7a5 e1			pop hl 
a7a6			.ldouscan: 
a7a6			if DEBUG_FORTH_WORDS 
a7a6				DMARK "LSs" 
a7a6 f5				push af  
a7a7 3a bb a7			ld a, (.dmark)  
a7aa 32 6b ee			ld (debug_mark),a  
a7ad 3a bc a7			ld a, (.dmark+1)  
a7b0 32 6c ee			ld (debug_mark+1),a  
a7b3 3a bd a7			ld a, (.dmark+2)  
a7b6 32 6d ee			ld (debug_mark+2),a  
a7b9 18 03			jr .pastdmark  
a7bb ..			.dmark: db "LSs"  
a7be f1			.pastdmark: pop af  
a7bf			endm  
# End of macro DMARK
a7bf				CALLMONITOR 
a7bf cd 6f ee			call debug_vector  
a7c2				endm  
# End of macro CALLMONITOR
a7c2			endif 
a7c2			; skip dict stub 
a7c2 cd 6e 9f			call forth_tok_next 
a7c5			 
a7c5			 
a7c5			; while we have words to look for 
a7c5			 
a7c5 7e			ld a, (hl)      
a7c6			if DEBUG_FORTH_WORDS 
a7c6				DMARK "LSk" 
a7c6 f5				push af  
a7c7 3a db a7			ld a, (.dmark)  
a7ca 32 6b ee			ld (debug_mark),a  
a7cd 3a dc a7			ld a, (.dmark+1)  
a7d0 32 6c ee			ld (debug_mark+1),a  
a7d3 3a dd a7			ld a, (.dmark+2)  
a7d6 32 6d ee			ld (debug_mark+2),a  
a7d9 18 03			jr .pastdmark  
a7db ..			.dmark: db "LSk"  
a7de f1			.pastdmark: pop af  
a7df			endm  
# End of macro DMARK
a7df				CALLMONITOR 
a7df cd 6f ee			call debug_vector  
a7e2				endm  
# End of macro CALLMONITOR
a7e2			endif 
a7e2				;cp WORD_SYS_END 
a7e2				;jp z, .lunotfound 
a7e2			 
a7e2					; if we hit non uwords then gone too far 
a7e2 fe 01				cp WORD_SYS_UWORD 
a7e4 c2 16 a9				jp nz, .lunotfound 
a7e7			 
a7e7				if DEBUG_FORTH_WORDS 
a7e7					DMARK "LSu" 
a7e7 f5				push af  
a7e8 3a fc a7			ld a, (.dmark)  
a7eb 32 6b ee			ld (debug_mark),a  
a7ee 3a fd a7			ld a, (.dmark+1)  
a7f1 32 6c ee			ld (debug_mark+1),a  
a7f4 3a fe a7			ld a, (.dmark+2)  
a7f7 32 6d ee			ld (debug_mark+2),a  
a7fa 18 03			jr .pastdmark  
a7fc ..			.dmark: db "LSu"  
a7ff f1			.pastdmark: pop af  
a800			endm  
# End of macro DMARK
a800					CALLMONITOR 
a800 cd 6f ee			call debug_vector  
a803				endm  
# End of macro CALLMONITOR
a803				endif 
a803			 
a803					; found a uword but is it the one we want... 
a803			 
a803 c5					push bc     ; uword to find is on bc 
a804 d1					pop de 
a805			 
a805 e5					push hl  ; to save the ptr 
a806			 
a806					; skip opcode 
a806 23					inc hl  
a807					; skip next ptr 
a807 23					inc hl  
a808 23					inc hl 
a809					; skip len 
a809 23					inc hl 
a80a			 
a80a				if DEBUG_FORTH_WORDS 
a80a					DMARK "LSc" 
a80a f5				push af  
a80b 3a 1f a8			ld a, (.dmark)  
a80e 32 6b ee			ld (debug_mark),a  
a811 3a 20 a8			ld a, (.dmark+1)  
a814 32 6c ee			ld (debug_mark+1),a  
a817 3a 21 a8			ld a, (.dmark+2)  
a81a 32 6d ee			ld (debug_mark+2),a  
a81d 18 03			jr .pastdmark  
a81f ..			.dmark: db "LSc"  
a822 f1			.pastdmark: pop af  
a823			endm  
# End of macro DMARK
a823					CALLMONITOR 
a823 cd 6f ee			call debug_vector  
a826				endm  
# End of macro CALLMONITOR
a826				endif 
a826			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
a826			; ie. If WOO is defined first and then WO. Couldnt list WO. 
a826			; Nope that has gone the other way. It needs to be exact not on first zero 
a826			;		call strcmp 
a826 c5					push bc 
a827 cd 86 90				call StrictStrCmp 
a82a c1					pop bc 
a82b c2 a5 a7				jp nz, .ldouscanm 
a82e				 
a82e			 
a82e			 
a82e					; we have a uword so push its name to the stack 
a82e			 
a82e			;	   	push hl  ; save so we can move to next dict block 
a82e e1			pop hl 
a82f			 
a82f				if DEBUG_FORTH_WORDS 
a82f					DMARK "LSm" 
a82f f5				push af  
a830 3a 44 a8			ld a, (.dmark)  
a833 32 6b ee			ld (debug_mark),a  
a836 3a 45 a8			ld a, (.dmark+1)  
a839 32 6c ee			ld (debug_mark+1),a  
a83c 3a 46 a8			ld a, (.dmark+2)  
a83f 32 6d ee			ld (debug_mark+2),a  
a842 18 03			jr .pastdmark  
a844 ..			.dmark: db "LSm"  
a847 f1			.pastdmark: pop af  
a848			endm  
# End of macro DMARK
a848					CALLMONITOR 
a848 cd 6f ee			call debug_vector  
a84b				endm  
# End of macro CALLMONITOR
a84b				endif 
a84b			 
a84b					; skip opcode 
a84b 23					inc hl  
a84c					; skip next ptr 
a84c 23					inc hl  
a84d 23					inc hl 
a84e					; skip len 
a84e 7e					ld a, (hl)   ; save length to add 
a84f				if DEBUG_FORTH_WORDS 
a84f					DMARK "LS2" 
a84f f5				push af  
a850 3a 64 a8			ld a, (.dmark)  
a853 32 6b ee			ld (debug_mark),a  
a856 3a 65 a8			ld a, (.dmark+1)  
a859 32 6c ee			ld (debug_mark+1),a  
a85c 3a 66 a8			ld a, (.dmark+2)  
a85f 32 6d ee			ld (debug_mark+2),a  
a862 18 03			jr .pastdmark  
a864 ..			.dmark: db "LS2"  
a867 f1			.pastdmark: pop af  
a868			endm  
# End of macro DMARK
a868					CALLMONITOR 
a868 cd 6f ee			call debug_vector  
a86b				endm  
# End of macro CALLMONITOR
a86b				endif 
a86b			 
a86b					; save this location 
a86b				 
a86b e5					push hl 
a86c			 
a86c 23					inc hl 
a86d 11 c3 e2				ld de, scratch+2 
a870 4f					ld c, a 
a871 06 00				ld b, 0 
a873			 
a873				if DEBUG_FORTH_WORDS 
a873					DMARK "LSn" 
a873 f5				push af  
a874 3a 88 a8			ld a, (.dmark)  
a877 32 6b ee			ld (debug_mark),a  
a87a 3a 89 a8			ld a, (.dmark+1)  
a87d 32 6c ee			ld (debug_mark+1),a  
a880 3a 8a a8			ld a, (.dmark+2)  
a883 32 6d ee			ld (debug_mark+2),a  
a886 18 03			jr .pastdmark  
a888 ..			.dmark: db "LSn"  
a88b f1			.pastdmark: pop af  
a88c			endm  
# End of macro DMARK
a88c					CALLMONITOR 
a88c cd 6f ee			call debug_vector  
a88f				endm  
# End of macro CALLMONITOR
a88f				endif 
a88f			 
a88f					; copy uword name to scratch 
a88f			 
a88f ed b0				ldir 
a891			 
a891 1b					dec de 
a892 3e 20				ld a, ' '    ; change null to space 
a894 12					ld (de), a 
a895			 
a895 13					inc de 
a896			 
a896 d5					push de 
a897 c1					pop bc     ; move scratch pointer to end of word name and save it 
a898			 
a898 e1					pop hl 
a899 7e					ld a, (hl) 
a89a					;inc hl 
a89a					; skip word string 
a89a cd db 8c				call addatohl 
a89d			 
a89d 23					inc hl 
a89e			 
a89e				if DEBUG_FORTH_WORDS 
a89e					DMARK "LS3" 
a89e f5				push af  
a89f 3a b3 a8			ld a, (.dmark)  
a8a2 32 6b ee			ld (debug_mark),a  
a8a5 3a b4 a8			ld a, (.dmark+1)  
a8a8 32 6c ee			ld (debug_mark+1),a  
a8ab 3a b5 a8			ld a, (.dmark+2)  
a8ae 32 6d ee			ld (debug_mark+2),a  
a8b1 18 03			jr .pastdmark  
a8b3 ..			.dmark: db "LS3"  
a8b6 f1			.pastdmark: pop af  
a8b7			endm  
# End of macro DMARK
a8b7					CALLMONITOR 
a8b7 cd 6f ee			call debug_vector  
a8ba				endm  
# End of macro CALLMONITOR
a8ba				endif 
a8ba					; should now be at the start of the machine code to setup the eval of the uword 
a8ba					; now locate the ptr to the string defintion 
a8ba			 
a8ba					; skip ld hl, 
a8ba					; then load the ptr 
a8ba			; TODO use get from hl ptr 
a8ba 23					inc hl 
a8bb 5e					ld e, (hl) 
a8bc 23					inc hl 
a8bd 56					ld d, (hl) 
a8be eb					ex de, hl 
a8bf			 
a8bf			 
a8bf				if DEBUG_FORTH_WORDS 
a8bf					DMARK "LSt" 
a8bf f5				push af  
a8c0 3a d4 a8			ld a, (.dmark)  
a8c3 32 6b ee			ld (debug_mark),a  
a8c6 3a d5 a8			ld a, (.dmark+1)  
a8c9 32 6c ee			ld (debug_mark+1),a  
a8cc 3a d6 a8			ld a, (.dmark+2)  
a8cf 32 6d ee			ld (debug_mark+2),a  
a8d2 18 03			jr .pastdmark  
a8d4 ..			.dmark: db "LSt"  
a8d7 f1			.pastdmark: pop af  
a8d8			endm  
# End of macro DMARK
a8d8					CALLMONITOR 
a8d8 cd 6f ee			call debug_vector  
a8db				endm  
# End of macro CALLMONITOR
a8db				endif 
a8db			 
a8db			; cant push right now due to tokenised strings  
a8db			 
a8db			; get the destination of where to copy this definition to. 
a8db			 
a8db c5					push bc 
a8dc d1					pop de 
a8dd			 
a8dd 7e			.listl:         ld a,(hl) 
a8de fe 00				cp 0 
a8e0 28 09				jr z, .lreplsp     ; replace zero with space 
a8e2					;cp FORTH_END_BUFFER 
a8e2 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a8e4 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a8e6				 
a8e6					; just copy this char as is then 
a8e6			 
a8e6 12					ld (de), a 
a8e7			 
a8e7 23			.listnxt:	inc hl 
a8e8 13					inc de 
a8e9 18 f2				jr .listl 
a8eb			 
a8eb 3e 20		.lreplsp:	ld a,' ' 
a8ed 12					ld (de), a 
a8ee 18 f7				jr .listnxt 
a8f0			 
a8f0			; close up uword def 
a8f0			 
a8f0			.listdone: 
a8f0 12					ld (de), a 
a8f1 13					inc de 
a8f2 3e 00				ld a, 0 
a8f4 12					ld (de), a 
a8f5			 
a8f5			; now have def so clean up and push to stack 
a8f5			 
a8f5 21 c1 e2				ld hl, scratch 
a8f8				if DEBUG_FORTH_WORDS 
a8f8					DMARK "Ltp" 
a8f8 f5				push af  
a8f9 3a 0d a9			ld a, (.dmark)  
a8fc 32 6b ee			ld (debug_mark),a  
a8ff 3a 0e a9			ld a, (.dmark+1)  
a902 32 6c ee			ld (debug_mark+1),a  
a905 3a 0f a9			ld a, (.dmark+2)  
a908 32 6d ee			ld (debug_mark+2),a  
a90b 18 03			jr .pastdmark  
a90d ..			.dmark: db "Ltp"  
a910 f1			.pastdmark: pop af  
a911			endm  
# End of macro DMARK
a911					CALLMONITOR 
a911 cd 6f ee			call debug_vector  
a914				endm  
# End of macro CALLMONITOR
a914				endif 
a914			 
a914 18 1f			jr .listpush 
a916			 
a916			;.lnuword:	pop hl 
a916			;		call forth_tok_next 
a916			;		jp .ldouscan  
a916			 
a916			.lunotfound:		  
a916			 
a916				if DEBUG_FORTH_WORDS 
a916					DMARK "LSn" 
a916 f5				push af  
a917 3a 2b a9			ld a, (.dmark)  
a91a 32 6b ee			ld (debug_mark),a  
a91d 3a 2c a9			ld a, (.dmark+1)  
a920 32 6c ee			ld (debug_mark+1),a  
a923 3a 2d a9			ld a, (.dmark+2)  
a926 32 6d ee			ld (debug_mark+2),a  
a929 18 03			jr .pastdmark  
a92b ..			.dmark: db "LSn"  
a92e f1			.pastdmark: pop af  
a92f			endm  
# End of macro DMARK
a92f					CALLMONITOR 
a92f cd 6f ee			call debug_vector  
a932				endm  
# End of macro CALLMONITOR
a932				endif 
a932			 
a932					 
a932			;		FORTH_DSP_POP 
a932			;		ld hl, .luno 
a932			 
a932					NEXTW			 
a932 c3 1d 9e			jp macro_next 
a935				endm 
# End of macro NEXTW
a935			 
a935			.listpush: 
a935				if DEBUG_FORTH_WORDS 
a935					DMARK "LS>" 
a935 f5				push af  
a936 3a 4a a9			ld a, (.dmark)  
a939 32 6b ee			ld (debug_mark),a  
a93c 3a 4b a9			ld a, (.dmark+1)  
a93f 32 6c ee			ld (debug_mark+1),a  
a942 3a 4c a9			ld a, (.dmark+2)  
a945 32 6d ee			ld (debug_mark+2),a  
a948 18 03			jr .pastdmark  
a94a ..			.dmark: db "LS>"  
a94d f1			.pastdmark: pop af  
a94e			endm  
# End of macro DMARK
a94e					CALLMONITOR 
a94e cd 6f ee			call debug_vector  
a951				endm  
# End of macro CALLMONITOR
a951				endif 
a951 cd d0 9a				call forth_push_str 
a954			 
a954			 
a954			 
a954					NEXTW 
a954 c3 1d 9e			jp macro_next 
a957				endm 
# End of macro NEXTW
a957			 
a957			;.luno:    db "Word not found",0 
a957			 
a957			 
a957			 
a957			 
a957			 
a957			;		push hl   ; save pointer to start of uword def string 
a957			; 
a957			;; look for FORTH_EOL_LINE 
a957			;		ld a, FORTH_END_BUFFER 
a957			;		call strlent 
a957			; 
a957			;		inc hl		 ; space for coln def 
a957			;		inc hl 
a957			;		inc hl          ; space for terms 
a957			;		inc hl 
a957			; 
a957			;		ld a, 20   ; TODO get actual length 
a957			;		call addatohl    ; include a random amount of room for the uword name 
a957			; 
a957			;		 
a957			;	if DEBUG_FORTH_WORDS 
a957			;		DMARK "Lt1" 
a957			;		CALLMONITOR 
a957			;	endif 
a957			;		 
a957			; 
a957			;; malloc space for the string because we cant change it 
a957			; 
a957			;		call malloc 
a957			;	if DEBUG_FORTH_MALLOC_GUARD 
a957			;		push af 
a957			;		call ishlzero 
a957			;		pop af 
a957			;		 
a957			;		call z,malloc_error 
a957			;	endif 
a957			; 
a957			;	if DEBUG_FORTH_WORDS 
a957			;		DMARK "Lt2" 
a957			;		CALLMONITOR 
a957			;	endif 
a957			;		pop de 
a957			;		push hl    ; push the malloc to release later 
a957			;		push hl   ;  push back a copy for the later stack push 
a957			;		 
a957			;; copy the string swapping out the zero terms for spaces 
a957			; 
a957			;		; de has our source 
a957			;		; hl has our dest 
a957			; 
a957			;; add the coln def 
a957			; 
a957			;		ld a, ':' 
a957			;		ld (hl), a 
a957			;		inc hl 
a957			;		ld a, ' ' 
a957			;		ld (hl), a 
a957			;		inc hl 
a957			; 
a957			;; add the uname word 
a957			;		push de   ; save our string for now 
a957			;		ex de, hl 
a957			; 
a957			;		FORTH_DSP_VALUE 
a957			;		;v5 FORTH_DSP_VALUE 
a957			; 
a957			;		inc hl   ; skip type but we know by now this is OK 
a957			; 
a957			;.luword:	ld a,(hl) 
a957			;		cp 0 
a957			;		jr z, .luword2 
a957			;		ld (de), a 
a957			;		inc de 
a957			;		inc hl 
a957			;		jr .luword 
a957			; 
a957			;.luword2:	ld a, ' ' 
a957			;		ld (de), a 
a957			;;		inc hl 
a957			;;		inc de 
a957			;;		ld (de), a 
a957			;;		inc hl 
a957			;		inc de 
a957			; 
a957			;		ex de, hl 
a957			;		pop de 
a957			;		 
a957			;		 
a957			; 
a957			;; detoken that string and copy it 
a957			; 
a957			;	if DEBUG_FORTH_WORDS 
a957			;		DMARK "Lt2" 
a957			;		CALLMONITOR 
a957			;	endif 
a957			;.ldetok:	ld a, (de) 
a957			;		cp FORTH_END_BUFFER 
a957			;		jr z, .ldetokend 
a957			;		; swap out any zero term for space 
a957			;		cp 0 
a957			;		jr nz, .ldetoknext 
a957			;		ld a, ' ' 
a957			; 
a957			;	if DEBUG_FORTH_WORDS 
a957			;		DMARK "LtS" 
a957			;		CALLMONITOR 
a957			;	endif 
a957			;.ldetoknext:	ld (hl), a 
a957			;		inc de 
a957			;		inc hl 
a957			;		jr .ldetok 
a957			; 
a957			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a957			;		ld (hl), a  
a957			; 
a957			;; free that temp malloc 
a957			; 
a957			;		pop hl    
a957			; 
a957			;	if DEBUG_FORTH_WORDS 
a957			;		DMARK "Lt4" 
a957			;		CALLMONITOR 
a957			;	endif 
a957			;		call forth_apushstrhl 
a957			; 
a957			;		; get rid of temp malloc area 
a957			; 
a957			;		pop hl 
a957			;		call free 
a957			; 
a957			;		jr .ludone 
a957			; 
a957			;.lnuword:	pop hl 
a957			;		call forth_tok_next 
a957			;		jp .ldouscan  
a957			; 
a957			;.ludone:		 pop hl 
a957			; 
a957					NEXTW 
a957 c3 1d 9e			jp macro_next 
a95a				endm 
# End of macro NEXTW
a95a			 
a95a			.FORGET: 
a95a				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a95a 5d				db WORD_SYS_CORE+73             
a95b d3 a9			dw .NOP            
a95d 07				db 6 + 1 
a95e .. 00			db "FORGET",0              
a965				endm 
# End of macro CWHEAD
a965			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a965			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
a965			; | |  
a965			; | | e.g. "MORE" forget 
a965					if DEBUG_FORTH_WORDS_KEY 
a965						DMARK "FRG" 
a965 f5				push af  
a966 3a 7a a9			ld a, (.dmark)  
a969 32 6b ee			ld (debug_mark),a  
a96c 3a 7b a9			ld a, (.dmark+1)  
a96f 32 6c ee			ld (debug_mark+1),a  
a972 3a 7c a9			ld a, (.dmark+2)  
a975 32 6d ee			ld (debug_mark+2),a  
a978 18 03			jr .pastdmark  
a97a ..			.dmark: db "FRG"  
a97d f1			.pastdmark: pop af  
a97e			endm  
# End of macro DMARK
a97e						CALLMONITOR 
a97e cd 6f ee			call debug_vector  
a981				endm  
# End of macro CALLMONITOR
a981					endif 
a981			 
a981				; find uword 
a981			        ; update start of word with "_" 
a981				; replace uword with deleted flag 
a981			 
a981			 
a981			;	if DEBUG_FORTH_WORDS 
a981			;		DMARK "FOG" 
a981			;		CALLMONITOR 
a981			;	endif 
a981			 
a981			 
a981					; Get ptr to the word we need to look up 
a981			 
a981					FORTH_DSP_VALUEHL 
a981 cd 67 9c			call macro_dsp_valuehl 
a984				endm 
# End of macro FORTH_DSP_VALUEHL
a984					;v5 FORTH_DSP_VALUE 
a984				; TODO type check 
a984			;		inc hl    ; Skip type check  
a984 e5					push hl 
a985 c1					pop bc 
a986			;		ex de, hl    ; put into DE 
a986			 
a986			 
a986 21 11 dd				ld hl, baseram 
a989					;ld hl, baseusermem 
a989			 
a989				; skip dict stub 
a989			;	call forth_tok_next 
a989 e5			push hl   ; sacreifical push 
a98a			 
a98a			.fldouscanm: 
a98a e1				pop hl 
a98b			.fldouscan: 
a98b			;	if DEBUG_FORTH_WORDS 
a98b			;		DMARK "LSs" 
a98b			;		CALLMONITOR 
a98b			;	endif 
a98b				; skip dict stub 
a98b cd 6e 9f				call forth_tok_next 
a98e			 
a98e			 
a98e			; while we have words to look for 
a98e			 
a98e 7e				ld a, (hl)      
a98f			;	if DEBUG_FORTH_WORDS 
a98f			;		DMARK "LSk" 
a98f			;		CALLMONITOR 
a98f			;	endif 
a98f fe 00				cp WORD_SYS_END 
a991 ca cd a9				jp z, .flunotfound 
a994 fe 01				cp WORD_SYS_UWORD 
a996 c2 8b a9				jp nz, .fldouscan 
a999			 
a999			;	if DEBUG_FORTH_WORDS 
a999			;		DMARK "LSu" 
a999			;		CALLMONITOR 
a999			;	endif 
a999			 
a999					; found a uword but is it the one we want... 
a999			 
a999 c5					push bc     ; uword to find is on bc 
a99a d1					pop de 
a99b			 
a99b e5					push hl  ; to save the ptr 
a99c			 
a99c					; skip opcode 
a99c 23					inc hl  
a99d					; skip next ptr 
a99d 23					inc hl  
a99e 23					inc hl 
a99f					; skip len 
a99f 23					inc hl 
a9a0			 
a9a0			;	if DEBUG_FORTH_WORDS 
a9a0			;		DMARK "LSc" 
a9a0			;		CALLMONITOR 
a9a0			;	endif 
a9a0 cd 79 90				call strcmp 
a9a3 c2 8a a9				jp nz, .fldouscanm 
a9a6			; 
a9a6			; 
a9a6			;; while we have words to look for 
a9a6			; 
a9a6			;.fdouscan:	ld a, (hl)      
a9a6			;	if DEBUG_FORTH_WORDS 
a9a6			;		DMARK "LSs" 
a9a6			;		CALLMONITOR 
a9a6			;	endif 
a9a6			;		cp WORD_SYS_END 
a9a6			;		jp z, .fudone 
a9a6			;		cp WORD_SYS_UWORD 
a9a6			;		jp nz, .fnuword 
a9a6			; 
a9a6			;	if DEBUG_FORTH_WORDS 
a9a6			;		DMARK "FGu" 
a9a6			;		CALLMONITOR 
a9a6			;	endif 
a9a6			; 
a9a6			;		; found a uword but is it the one we want... 
a9a6			; 
a9a6			; 
a9a6			;	        pop de   ; get back the dsp name 
a9a6			;		push de 
a9a6			; 
a9a6			;		push hl  ; to save the ptr 
a9a6			; 
a9a6			;		; skip opcode 
a9a6			;		inc hl  
a9a6			;		; skip next ptr 
a9a6			;		inc hl  
a9a6			;		inc hl 
a9a6			;		; skip len 
a9a6			;		inc hl 
a9a6			; 
a9a6			;	if DEBUG_FORTH_WORDS 
a9a6			;		DMARK "FGc" 
a9a6			;		CALLMONITOR 
a9a6			;	endif 
a9a6			;		call strcmp 
a9a6			;		jp nz, .fnuword 
a9a6			 
a9a6			 
a9a6 e1			pop hl 
a9a7			 
a9a7				 
a9a7				if DEBUG_FORTH_WORDS 
a9a7					DMARK "FGm" 
a9a7 f5				push af  
a9a8 3a bc a9			ld a, (.dmark)  
a9ab 32 6b ee			ld (debug_mark),a  
a9ae 3a bd a9			ld a, (.dmark+1)  
a9b1 32 6c ee			ld (debug_mark+1),a  
a9b4 3a be a9			ld a, (.dmark+2)  
a9b7 32 6d ee			ld (debug_mark+2),a  
a9ba 18 03			jr .pastdmark  
a9bc ..			.dmark: db "FGm"  
a9bf f1			.pastdmark: pop af  
a9c0			endm  
# End of macro DMARK
a9c0					CALLMONITOR 
a9c0 cd 6f ee			call debug_vector  
a9c3				endm  
# End of macro CALLMONITOR
a9c3				endif 
a9c3			 
a9c3			 
a9c3			 
a9c3					; we have a uword so push its name to the stack 
a9c3			 
a9c3			;	   	push hl  ; save so we can move to next dict block 
a9c3			;pop hl 
a9c3			 
a9c3					; update opcode to deleted 
a9c3 3e 03				ld a, WORD_SYS_DELETED 
a9c5 77					ld (hl), a 
a9c6			 
a9c6 23					inc hl  
a9c7					; skip next ptr 
a9c7 23					inc hl  
a9c8 23					inc hl 
a9c9					; skip len 
a9c9 23					inc hl 
a9ca			 
a9ca					; TODO change parser to skip deleted words but for now mark it out 
a9ca 3e 5f				ld a, "_" 
a9cc 77					ld  (hl),a 
a9cd			 
a9cd			;		jr .fudone 
a9cd			; 
a9cd			;.fnuword:	pop hl 
a9cd			;		call forth_tok_next 
a9cd			;		jp .fdouscan  
a9cd			 
a9cd			.flunotfound:		  
a9cd			 
a9cd			 
a9cd					 
a9cd					FORTH_DSP_POP 
a9cd cd 1f 9d			call macro_forth_dsp_pop 
a9d0				endm 
# End of macro FORTH_DSP_POP
a9d0			;		ld hl, .luno 
a9d0			;.fudone:		 pop hl 
a9d0					NEXTW 
a9d0 c3 1d 9e			jp macro_next 
a9d3				endm 
# End of macro NEXTW
a9d3			.NOP: 
a9d3				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a9d3 61				db WORD_SYS_CORE+77             
a9d4 fa a9			dw .COMO            
a9d6 04				db 3 + 1 
a9d7 .. 00			db "NOP",0              
a9db				endm 
# End of macro CWHEAD
a9db			; | NOP (  --  ) Do nothing | DONE 
a9db					if DEBUG_FORTH_WORDS_KEY 
a9db						DMARK "NOP" 
a9db f5				push af  
a9dc 3a f0 a9			ld a, (.dmark)  
a9df 32 6b ee			ld (debug_mark),a  
a9e2 3a f1 a9			ld a, (.dmark+1)  
a9e5 32 6c ee			ld (debug_mark+1),a  
a9e8 3a f2 a9			ld a, (.dmark+2)  
a9eb 32 6d ee			ld (debug_mark+2),a  
a9ee 18 03			jr .pastdmark  
a9f0 ..			.dmark: db "NOP"  
a9f3 f1			.pastdmark: pop af  
a9f4			endm  
# End of macro DMARK
a9f4						CALLMONITOR 
a9f4 cd 6f ee			call debug_vector  
a9f7				endm  
# End of macro CALLMONITOR
a9f7					endif 
a9f7				       NEXTW 
a9f7 c3 1d 9e			jp macro_next 
a9fa				endm 
# End of macro NEXTW
a9fa			.COMO: 
a9fa				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a9fa 6e				db WORD_SYS_CORE+90             
a9fb 4c aa			dw .COMC            
a9fd 02				db 1 + 1 
a9fe .. 00			db "(",0              
aa00				endm 
# End of macro CWHEAD
aa00			; | ( ( -- )  Start of comment | DONE 
aa00			 
aa00			 
aa00 2a c2 e5				ld hl, ( os_tok_ptr) 
aa03 11 47 aa			ld de, .closepar 
aa06					 
aa06					if DEBUG_FORTH_WORDS 
aa06						DMARK ").." 
aa06 f5				push af  
aa07 3a 1b aa			ld a, (.dmark)  
aa0a 32 6b ee			ld (debug_mark),a  
aa0d 3a 1c aa			ld a, (.dmark+1)  
aa10 32 6c ee			ld (debug_mark+1),a  
aa13 3a 1d aa			ld a, (.dmark+2)  
aa16 32 6d ee			ld (debug_mark+2),a  
aa19 18 03			jr .pastdmark  
aa1b ..			.dmark: db ").."  
aa1e f1			.pastdmark: pop af  
aa1f			endm  
# End of macro DMARK
aa1f						CALLMONITOR 
aa1f cd 6f ee			call debug_vector  
aa22				endm  
# End of macro CALLMONITOR
aa22					endif 
aa22 cd 38 9f			call findnexttok  
aa25			 
aa25					if DEBUG_FORTH_WORDS 
aa25						DMARK "IF5" 
aa25 f5				push af  
aa26 3a 3a aa			ld a, (.dmark)  
aa29 32 6b ee			ld (debug_mark),a  
aa2c 3a 3b aa			ld a, (.dmark+1)  
aa2f 32 6c ee			ld (debug_mark+1),a  
aa32 3a 3c aa			ld a, (.dmark+2)  
aa35 32 6d ee			ld (debug_mark+2),a  
aa38 18 03			jr .pastdmark  
aa3a ..			.dmark: db "IF5"  
aa3d f1			.pastdmark: pop af  
aa3e			endm  
# End of macro DMARK
aa3e						CALLMONITOR 
aa3e cd 6f ee			call debug_vector  
aa41				endm  
# End of macro CALLMONITOR
aa41					endif 
aa41				; replace below with ) exec using tok_ptr 
aa41 22 c2 e5			ld (os_tok_ptr), hl 
aa44 c3 ae 9e			jp exec1 
aa47			 
aa47 .. 00			.closepar:   db ")",0 
aa49			 
aa49				       NEXTW 
aa49 c3 1d 9e			jp macro_next 
aa4c				endm 
# End of macro NEXTW
aa4c			.COMC: 
aa4c				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
aa4c 6f				db WORD_SYS_CORE+91             
aa4d 55 aa			dw .SCRATCH            
aa4f 02				db 1 + 1 
aa50 .. 00			db ")",0              
aa52				endm 
# End of macro CWHEAD
aa52			; | ) ( -- )  End of comment |  DONE  
aa52				       NEXTW 
aa52 c3 1d 9e			jp macro_next 
aa55				endm 
# End of macro NEXTW
aa55			 
aa55			.SCRATCH: 
aa55				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
aa55 6f				db WORD_SYS_CORE+91             
aa56 90 aa			dw .INC            
aa58 08				db 7 + 1 
aa59 .. 00			db "SCRATCH",0              
aa61				endm 
# End of macro CWHEAD
aa61			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
aa61			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
aa61			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
aa61			; | |  
aa61			; | | e.g.    : score $00 scratch ; 
aa61			; | |  
aa61			; | | $00 score ! 
aa61			; | | $01 score +! 
aa61			; | |  
aa61			; | | e.g.   : varword $0a scratch ;  
aa61			; | | 
aa61			; | | $8000 varword ! 
aa61					if DEBUG_FORTH_WORDS_KEY 
aa61						DMARK "SCR" 
aa61 f5				push af  
aa62 3a 76 aa			ld a, (.dmark)  
aa65 32 6b ee			ld (debug_mark),a  
aa68 3a 77 aa			ld a, (.dmark+1)  
aa6b 32 6c ee			ld (debug_mark+1),a  
aa6e 3a 78 aa			ld a, (.dmark+2)  
aa71 32 6d ee			ld (debug_mark+2),a  
aa74 18 03			jr .pastdmark  
aa76 ..			.dmark: db "SCR"  
aa79 f1			.pastdmark: pop af  
aa7a			endm  
# End of macro DMARK
aa7a						CALLMONITOR 
aa7a cd 6f ee			call debug_vector  
aa7d				endm  
# End of macro CALLMONITOR
aa7d					endif 
aa7d			 
aa7d					FORTH_DSP_VALUEHL 
aa7d cd 67 9c			call macro_dsp_valuehl 
aa80				endm 
# End of macro FORTH_DSP_VALUEHL
aa80				 
aa80					FORTH_DSP_POP 
aa80 cd 1f 9d			call macro_forth_dsp_pop 
aa83				endm 
# End of macro FORTH_DSP_POP
aa83			 
aa83 7d					ld a, l 
aa84 21 e6 e7				ld hl, os_var_array 
aa87 cd db 8c				call addatohl 
aa8a			 
aa8a cd 62 9a				call forth_push_numhl 
aa8d			 
aa8d				       NEXTW 
aa8d c3 1d 9e			jp macro_next 
aa90				endm 
# End of macro NEXTW
aa90			 
aa90			.INC: 
aa90				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
aa90 6f				db WORD_SYS_CORE+91             
aa91 e6 aa			dw .DEC            
aa93 03				db 2 + 1 
aa94 .. 00			db "+!",0              
aa97				endm 
# End of macro CWHEAD
aa97			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
aa97					if DEBUG_FORTH_WORDS_KEY 
aa97						DMARK "+s_" 
aa97 f5				push af  
aa98 3a ac aa			ld a, (.dmark)  
aa9b 32 6b ee			ld (debug_mark),a  
aa9e 3a ad aa			ld a, (.dmark+1)  
aaa1 32 6c ee			ld (debug_mark+1),a  
aaa4 3a ae aa			ld a, (.dmark+2)  
aaa7 32 6d ee			ld (debug_mark+2),a  
aaaa 18 03			jr .pastdmark  
aaac ..			.dmark: db "+s_"  
aaaf f1			.pastdmark: pop af  
aab0			endm  
# End of macro DMARK
aab0						CALLMONITOR 
aab0 cd 6f ee			call debug_vector  
aab3				endm  
# End of macro CALLMONITOR
aab3					endif 
aab3			 
aab3					FORTH_DSP_VALUEHL 
aab3 cd 67 9c			call macro_dsp_valuehl 
aab6				endm 
# End of macro FORTH_DSP_VALUEHL
aab6			 
aab6 e5					push hl   ; save address 
aab7			 
aab7					FORTH_DSP_POP 
aab7 cd 1f 9d			call macro_forth_dsp_pop 
aaba				endm 
# End of macro FORTH_DSP_POP
aaba			 
aaba					FORTH_DSP_VALUEHL 
aaba cd 67 9c			call macro_dsp_valuehl 
aabd				endm 
# End of macro FORTH_DSP_VALUEHL
aabd			 
aabd e5					push hl 
aabe					FORTH_DSP_POP 
aabe cd 1f 9d			call macro_forth_dsp_pop 
aac1				endm 
# End of macro FORTH_DSP_POP
aac1 e1					pop hl 
aac2			 
aac2					; hl contains value to add to byte at a 
aac2				 
aac2 eb					ex de, hl 
aac3			 
aac3 e1					pop hl 
aac4			 
aac4					if DEBUG_FORTH_WORDS 
aac4						DMARK "INC" 
aac4 f5				push af  
aac5 3a d9 aa			ld a, (.dmark)  
aac8 32 6b ee			ld (debug_mark),a  
aacb 3a da aa			ld a, (.dmark+1)  
aace 32 6c ee			ld (debug_mark+1),a  
aad1 3a db aa			ld a, (.dmark+2)  
aad4 32 6d ee			ld (debug_mark+2),a  
aad7 18 03			jr .pastdmark  
aad9 ..			.dmark: db "INC"  
aadc f1			.pastdmark: pop af  
aadd			endm  
# End of macro DMARK
aadd						CALLMONITOR 
aadd cd 6f ee			call debug_vector  
aae0				endm  
# End of macro CALLMONITOR
aae0					endif 
aae0			 
aae0 7e					ld a,(hl) 
aae1 83					add e 
aae2 77					ld (hl),a 
aae3			 
aae3			 
aae3			 
aae3				       NEXTW 
aae3 c3 1d 9e			jp macro_next 
aae6				endm 
# End of macro NEXTW
aae6			 
aae6			.DEC: 
aae6				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
aae6 6f				db WORD_SYS_CORE+91             
aae7 3a ab			dw .INC2            
aae9 03				db 2 + 1 
aaea .. 00			db "-!",0              
aaed				endm 
# End of macro CWHEAD
aaed			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
aaed					if DEBUG_FORTH_WORDS_KEY 
aaed						DMARK "-s_" 
aaed f5				push af  
aaee 3a 02 ab			ld a, (.dmark)  
aaf1 32 6b ee			ld (debug_mark),a  
aaf4 3a 03 ab			ld a, (.dmark+1)  
aaf7 32 6c ee			ld (debug_mark+1),a  
aafa 3a 04 ab			ld a, (.dmark+2)  
aafd 32 6d ee			ld (debug_mark+2),a  
ab00 18 03			jr .pastdmark  
ab02 ..			.dmark: db "-s_"  
ab05 f1			.pastdmark: pop af  
ab06			endm  
# End of macro DMARK
ab06						CALLMONITOR 
ab06 cd 6f ee			call debug_vector  
ab09				endm  
# End of macro CALLMONITOR
ab09					endif 
ab09			 
ab09					FORTH_DSP_VALUEHL 
ab09 cd 67 9c			call macro_dsp_valuehl 
ab0c				endm 
# End of macro FORTH_DSP_VALUEHL
ab0c			 
ab0c e5					push hl   ; save address 
ab0d			 
ab0d					FORTH_DSP_POP 
ab0d cd 1f 9d			call macro_forth_dsp_pop 
ab10				endm 
# End of macro FORTH_DSP_POP
ab10			 
ab10					FORTH_DSP_VALUEHL 
ab10 cd 67 9c			call macro_dsp_valuehl 
ab13				endm 
# End of macro FORTH_DSP_VALUEHL
ab13			 
ab13					; hl contains value to add to byte at a 
ab13				 
ab13 eb					ex de, hl 
ab14			 
ab14 e1					pop hl 
ab15			 
ab15					if DEBUG_FORTH_WORDS 
ab15						DMARK "DEC" 
ab15 f5				push af  
ab16 3a 2a ab			ld a, (.dmark)  
ab19 32 6b ee			ld (debug_mark),a  
ab1c 3a 2b ab			ld a, (.dmark+1)  
ab1f 32 6c ee			ld (debug_mark+1),a  
ab22 3a 2c ab			ld a, (.dmark+2)  
ab25 32 6d ee			ld (debug_mark+2),a  
ab28 18 03			jr .pastdmark  
ab2a ..			.dmark: db "DEC"  
ab2d f1			.pastdmark: pop af  
ab2e			endm  
# End of macro DMARK
ab2e						CALLMONITOR 
ab2e cd 6f ee			call debug_vector  
ab31				endm  
# End of macro CALLMONITOR
ab31					endif 
ab31			 
ab31 7e					ld a,(hl) 
ab32 93					sub e 
ab33 77					ld (hl),a 
ab34			 
ab34			 
ab34					FORTH_DSP_POP 
ab34 cd 1f 9d			call macro_forth_dsp_pop 
ab37				endm 
# End of macro FORTH_DSP_POP
ab37			 
ab37				       NEXTW 
ab37 c3 1d 9e			jp macro_next 
ab3a				endm 
# End of macro NEXTW
ab3a			 
ab3a			.INC2: 
ab3a				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ab3a 6f				db WORD_SYS_CORE+91             
ab3b e7 ab			dw .DEC2            
ab3d 04				db 3 + 1 
ab3e .. 00			db "+2!",0              
ab42				endm 
# End of macro CWHEAD
ab42			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ab42			 
ab42					if DEBUG_FORTH_WORDS_KEY 
ab42						DMARK "+2s" 
ab42 f5				push af  
ab43 3a 57 ab			ld a, (.dmark)  
ab46 32 6b ee			ld (debug_mark),a  
ab49 3a 58 ab			ld a, (.dmark+1)  
ab4c 32 6c ee			ld (debug_mark+1),a  
ab4f 3a 59 ab			ld a, (.dmark+2)  
ab52 32 6d ee			ld (debug_mark+2),a  
ab55 18 03			jr .pastdmark  
ab57 ..			.dmark: db "+2s"  
ab5a f1			.pastdmark: pop af  
ab5b			endm  
# End of macro DMARK
ab5b						CALLMONITOR 
ab5b cd 6f ee			call debug_vector  
ab5e				endm  
# End of macro CALLMONITOR
ab5e					endif 
ab5e			 
ab5e					; Address 
ab5e			 
ab5e					FORTH_DSP_VALUEHL 
ab5e cd 67 9c			call macro_dsp_valuehl 
ab61				endm 
# End of macro FORTH_DSP_VALUEHL
ab61			 
ab61 e5					push hl    ; save address 
ab62			 
ab62					; load content into de 
ab62			 
ab62 5e					ld e,(hl) 
ab63 23					inc hl 
ab64 56					ld d, (hl) 
ab65			 
ab65					if DEBUG_FORTH_WORDS 
ab65						DMARK "+2a" 
ab65 f5				push af  
ab66 3a 7a ab			ld a, (.dmark)  
ab69 32 6b ee			ld (debug_mark),a  
ab6c 3a 7b ab			ld a, (.dmark+1)  
ab6f 32 6c ee			ld (debug_mark+1),a  
ab72 3a 7c ab			ld a, (.dmark+2)  
ab75 32 6d ee			ld (debug_mark+2),a  
ab78 18 03			jr .pastdmark  
ab7a ..			.dmark: db "+2a"  
ab7d f1			.pastdmark: pop af  
ab7e			endm  
# End of macro DMARK
ab7e						CALLMONITOR 
ab7e cd 6f ee			call debug_vector  
ab81				endm  
# End of macro CALLMONITOR
ab81					endif 
ab81			 
ab81					FORTH_DSP_POP 
ab81 cd 1f 9d			call macro_forth_dsp_pop 
ab84				endm 
# End of macro FORTH_DSP_POP
ab84			 
ab84					; Get value to add 
ab84			 
ab84					FORTH_DSP_VALUE 
ab84 cd 50 9c			call macro_forth_dsp_value 
ab87				endm 
# End of macro FORTH_DSP_VALUE
ab87			 
ab87					if DEBUG_FORTH_WORDS 
ab87						DMARK "+2v" 
ab87 f5				push af  
ab88 3a 9c ab			ld a, (.dmark)  
ab8b 32 6b ee			ld (debug_mark),a  
ab8e 3a 9d ab			ld a, (.dmark+1)  
ab91 32 6c ee			ld (debug_mark+1),a  
ab94 3a 9e ab			ld a, (.dmark+2)  
ab97 32 6d ee			ld (debug_mark+2),a  
ab9a 18 03			jr .pastdmark  
ab9c ..			.dmark: db "+2v"  
ab9f f1			.pastdmark: pop af  
aba0			endm  
# End of macro DMARK
aba0						CALLMONITOR 
aba0 cd 6f ee			call debug_vector  
aba3				endm  
# End of macro CALLMONITOR
aba3					endif 
aba3			 
aba3 19					add hl, de 
aba4			 
aba4					if DEBUG_FORTH_WORDS 
aba4						DMARK "+2+" 
aba4 f5				push af  
aba5 3a b9 ab			ld a, (.dmark)  
aba8 32 6b ee			ld (debug_mark),a  
abab 3a ba ab			ld a, (.dmark+1)  
abae 32 6c ee			ld (debug_mark+1),a  
abb1 3a bb ab			ld a, (.dmark+2)  
abb4 32 6d ee			ld (debug_mark+2),a  
abb7 18 03			jr .pastdmark  
abb9 ..			.dmark: db "+2+"  
abbc f1			.pastdmark: pop af  
abbd			endm  
# End of macro DMARK
abbd						CALLMONITOR 
abbd cd 6f ee			call debug_vector  
abc0				endm  
# End of macro CALLMONITOR
abc0					endif 
abc0			 
abc0					; move result to de 
abc0			 
abc0 eb					ex de, hl 
abc1			 
abc1					; Address 
abc1			 
abc1 e1					pop hl 
abc2			 
abc2					; save it back 
abc2			 
abc2 73					ld (hl), e 
abc3 23					inc hl 
abc4 72					ld (hl), d 
abc5			 
abc5					if DEBUG_FORTH_WORDS 
abc5						DMARK "+2e" 
abc5 f5				push af  
abc6 3a da ab			ld a, (.dmark)  
abc9 32 6b ee			ld (debug_mark),a  
abcc 3a db ab			ld a, (.dmark+1)  
abcf 32 6c ee			ld (debug_mark+1),a  
abd2 3a dc ab			ld a, (.dmark+2)  
abd5 32 6d ee			ld (debug_mark+2),a  
abd8 18 03			jr .pastdmark  
abda ..			.dmark: db "+2e"  
abdd f1			.pastdmark: pop af  
abde			endm  
# End of macro DMARK
abde						CALLMONITOR 
abde cd 6f ee			call debug_vector  
abe1				endm  
# End of macro CALLMONITOR
abe1					endif 
abe1			 
abe1			 
abe1			 
abe1					FORTH_DSP_POP 
abe1 cd 1f 9d			call macro_forth_dsp_pop 
abe4				endm 
# End of macro FORTH_DSP_POP
abe4			 
abe4			 
abe4				       NEXTW 
abe4 c3 1d 9e			jp macro_next 
abe7				endm 
# End of macro NEXTW
abe7			 
abe7			.DEC2: 
abe7				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
abe7 6f				db WORD_SYS_CORE+91             
abe8 96 ac			dw .GET2            
abea 04				db 3 + 1 
abeb .. 00			db "-2!",0              
abef				endm 
# End of macro CWHEAD
abef			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
abef			 
abef			 
abef					if DEBUG_FORTH_WORDS_KEY 
abef						DMARK "-2s" 
abef f5				push af  
abf0 3a 04 ac			ld a, (.dmark)  
abf3 32 6b ee			ld (debug_mark),a  
abf6 3a 05 ac			ld a, (.dmark+1)  
abf9 32 6c ee			ld (debug_mark+1),a  
abfc 3a 06 ac			ld a, (.dmark+2)  
abff 32 6d ee			ld (debug_mark+2),a  
ac02 18 03			jr .pastdmark  
ac04 ..			.dmark: db "-2s"  
ac07 f1			.pastdmark: pop af  
ac08			endm  
# End of macro DMARK
ac08						CALLMONITOR 
ac08 cd 6f ee			call debug_vector  
ac0b				endm  
# End of macro CALLMONITOR
ac0b					endif 
ac0b			 
ac0b					; Address 
ac0b			 
ac0b					FORTH_DSP_VALUEHL 
ac0b cd 67 9c			call macro_dsp_valuehl 
ac0e				endm 
# End of macro FORTH_DSP_VALUEHL
ac0e			 
ac0e e5					push hl    ; save address 
ac0f			 
ac0f					; load content into de 
ac0f			 
ac0f 5e					ld e,(hl) 
ac10 23					inc hl 
ac11 56					ld d, (hl) 
ac12			 
ac12					if DEBUG_FORTH_WORDS 
ac12						DMARK "-2a" 
ac12 f5				push af  
ac13 3a 27 ac			ld a, (.dmark)  
ac16 32 6b ee			ld (debug_mark),a  
ac19 3a 28 ac			ld a, (.dmark+1)  
ac1c 32 6c ee			ld (debug_mark+1),a  
ac1f 3a 29 ac			ld a, (.dmark+2)  
ac22 32 6d ee			ld (debug_mark+2),a  
ac25 18 03			jr .pastdmark  
ac27 ..			.dmark: db "-2a"  
ac2a f1			.pastdmark: pop af  
ac2b			endm  
# End of macro DMARK
ac2b						CALLMONITOR 
ac2b cd 6f ee			call debug_vector  
ac2e				endm  
# End of macro CALLMONITOR
ac2e					endif 
ac2e			 
ac2e					FORTH_DSP_POP 
ac2e cd 1f 9d			call macro_forth_dsp_pop 
ac31				endm 
# End of macro FORTH_DSP_POP
ac31			 
ac31					; Get value to remove 
ac31			 
ac31					FORTH_DSP_VALUE 
ac31 cd 50 9c			call macro_forth_dsp_value 
ac34				endm 
# End of macro FORTH_DSP_VALUE
ac34			 
ac34					if DEBUG_FORTH_WORDS 
ac34						DMARK "-2v" 
ac34 f5				push af  
ac35 3a 49 ac			ld a, (.dmark)  
ac38 32 6b ee			ld (debug_mark),a  
ac3b 3a 4a ac			ld a, (.dmark+1)  
ac3e 32 6c ee			ld (debug_mark+1),a  
ac41 3a 4b ac			ld a, (.dmark+2)  
ac44 32 6d ee			ld (debug_mark+2),a  
ac47 18 03			jr .pastdmark  
ac49 ..			.dmark: db "-2v"  
ac4c f1			.pastdmark: pop af  
ac4d			endm  
# End of macro DMARK
ac4d						CALLMONITOR 
ac4d cd 6f ee			call debug_vector  
ac50				endm  
# End of macro CALLMONITOR
ac50					endif 
ac50			 
ac50 eb					ex de, hl 
ac51 ed 52				sbc hl, de 
ac53			 
ac53					if DEBUG_FORTH_WORDS 
ac53						DMARK "-2d" 
ac53 f5				push af  
ac54 3a 68 ac			ld a, (.dmark)  
ac57 32 6b ee			ld (debug_mark),a  
ac5a 3a 69 ac			ld a, (.dmark+1)  
ac5d 32 6c ee			ld (debug_mark+1),a  
ac60 3a 6a ac			ld a, (.dmark+2)  
ac63 32 6d ee			ld (debug_mark+2),a  
ac66 18 03			jr .pastdmark  
ac68 ..			.dmark: db "-2d"  
ac6b f1			.pastdmark: pop af  
ac6c			endm  
# End of macro DMARK
ac6c						CALLMONITOR 
ac6c cd 6f ee			call debug_vector  
ac6f				endm  
# End of macro CALLMONITOR
ac6f					endif 
ac6f			 
ac6f					; move result to de 
ac6f			 
ac6f eb					ex de, hl 
ac70			 
ac70					; Address 
ac70			 
ac70 e1					pop hl 
ac71			 
ac71					; save it back 
ac71			 
ac71 73					ld (hl), e 
ac72 23					inc hl 
ac73 72					ld (hl), d 
ac74			 
ac74					if DEBUG_FORTH_WORDS 
ac74						DMARK "-2e" 
ac74 f5				push af  
ac75 3a 89 ac			ld a, (.dmark)  
ac78 32 6b ee			ld (debug_mark),a  
ac7b 3a 8a ac			ld a, (.dmark+1)  
ac7e 32 6c ee			ld (debug_mark+1),a  
ac81 3a 8b ac			ld a, (.dmark+2)  
ac84 32 6d ee			ld (debug_mark+2),a  
ac87 18 03			jr .pastdmark  
ac89 ..			.dmark: db "-2e"  
ac8c f1			.pastdmark: pop af  
ac8d			endm  
# End of macro DMARK
ac8d						CALLMONITOR 
ac8d cd 6f ee			call debug_vector  
ac90				endm  
# End of macro CALLMONITOR
ac90					endif 
ac90			 
ac90			 
ac90					FORTH_DSP_POP 
ac90 cd 1f 9d			call macro_forth_dsp_pop 
ac93				endm 
# End of macro FORTH_DSP_POP
ac93			 
ac93			 
ac93			 
ac93				       NEXTW 
ac93 c3 1d 9e			jp macro_next 
ac96				endm 
# End of macro NEXTW
ac96			.GET2: 
ac96				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ac96 6f				db WORD_SYS_CORE+91             
ac97 cb ac			dw .BANG2            
ac99 03				db 2 + 1 
ac9a .. 00			db "2@",0              
ac9d				endm 
# End of macro CWHEAD
ac9d			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ac9d					if DEBUG_FORTH_WORDS_KEY 
ac9d						DMARK "2A_" 
ac9d f5				push af  
ac9e 3a b2 ac			ld a, (.dmark)  
aca1 32 6b ee			ld (debug_mark),a  
aca4 3a b3 ac			ld a, (.dmark+1)  
aca7 32 6c ee			ld (debug_mark+1),a  
acaa 3a b4 ac			ld a, (.dmark+2)  
acad 32 6d ee			ld (debug_mark+2),a  
acb0 18 03			jr .pastdmark  
acb2 ..			.dmark: db "2A_"  
acb5 f1			.pastdmark: pop af  
acb6			endm  
# End of macro DMARK
acb6						CALLMONITOR 
acb6 cd 6f ee			call debug_vector  
acb9				endm  
# End of macro CALLMONITOR
acb9					endif 
acb9			 
acb9					FORTH_DSP_VALUEHL 
acb9 cd 67 9c			call macro_dsp_valuehl 
acbc				endm 
# End of macro FORTH_DSP_VALUEHL
acbc			 
acbc e5					push hl   ; save address 
acbd			 
acbd					FORTH_DSP_POP 
acbd cd 1f 9d			call macro_forth_dsp_pop 
acc0				endm 
# End of macro FORTH_DSP_POP
acc0			 
acc0 e1					pop hl 
acc1			 
acc1 5e					ld e, (hl) 
acc2 23					inc hl 
acc3 56					ld d, (hl) 
acc4			 
acc4 eb					ex de, hl 
acc5			 
acc5 cd 62 9a				call forth_push_numhl 
acc8			 
acc8				       NEXTW 
acc8 c3 1d 9e			jp macro_next 
accb				endm 
# End of macro NEXTW
accb			.BANG2: 
accb				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
accb 6f				db WORD_SYS_CORE+91             
accc 03 ad			dw .CONFIG            
acce 03				db 2 + 1 
accf .. 00			db "2!",0              
acd2				endm 
# End of macro CWHEAD
acd2			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
acd2					if DEBUG_FORTH_WORDS_KEY 
acd2						DMARK "2S_" 
acd2 f5				push af  
acd3 3a e7 ac			ld a, (.dmark)  
acd6 32 6b ee			ld (debug_mark),a  
acd9 3a e8 ac			ld a, (.dmark+1)  
acdc 32 6c ee			ld (debug_mark+1),a  
acdf 3a e9 ac			ld a, (.dmark+2)  
ace2 32 6d ee			ld (debug_mark+2),a  
ace5 18 03			jr .pastdmark  
ace7 ..			.dmark: db "2S_"  
acea f1			.pastdmark: pop af  
aceb			endm  
# End of macro DMARK
aceb						CALLMONITOR 
aceb cd 6f ee			call debug_vector  
acee				endm  
# End of macro CALLMONITOR
acee					endif 
acee			 
acee					FORTH_DSP_VALUEHL 
acee cd 67 9c			call macro_dsp_valuehl 
acf1				endm 
# End of macro FORTH_DSP_VALUEHL
acf1			 
acf1 e5					push hl   ; save address 
acf2			 
acf2			 
acf2					FORTH_DSP_POP 
acf2 cd 1f 9d			call macro_forth_dsp_pop 
acf5				endm 
# End of macro FORTH_DSP_POP
acf5			 
acf5					 
acf5					FORTH_DSP_VALUEHL 
acf5 cd 67 9c			call macro_dsp_valuehl 
acf8				endm 
# End of macro FORTH_DSP_VALUEHL
acf8			 
acf8					FORTH_DSP_POP 
acf8 cd 1f 9d			call macro_forth_dsp_pop 
acfb				endm 
# End of macro FORTH_DSP_POP
acfb			 
acfb eb					ex de, hl    ; value now in de 
acfc			 
acfc e1					pop hl 
acfd			 
acfd 73					ld (hl), e 
acfe			 
acfe 23					inc hl 
acff			 
acff 72					ld (hl), d 
ad00			 
ad00			 
ad00				       NEXTW 
ad00 c3 1d 9e			jp macro_next 
ad03				endm 
# End of macro NEXTW
ad03			.CONFIG: 
ad03				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
ad03 6f				db WORD_SYS_CORE+91             
ad04 14 ad			dw .ADTOS            
ad06 07				db 6 + 1 
ad07 .. 00			db "CONFIG",0              
ad0e				endm 
# End of macro CWHEAD
ad0e			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ad0e			 
ad0e cd 4f 92				call config 
ad11					NEXTW 
ad11 c3 1d 9e			jp macro_next 
ad14				endm 
# End of macro NEXTW
ad14			 
ad14			.ADTOS: 
ad14				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
ad14 6f				db WORD_SYS_CORE+91             
ad15 2a ad			dw .SBTOS            
ad17 03				db 2 + 1 
ad18 .. 00			db "1+",0              
ad1b				endm 
# End of macro CWHEAD
ad1b			; | 1+ ( u -- u )  Increment value on TOS | DONE 
ad1b			 
ad1b					FORTH_DSP_VALUEHL 
ad1b cd 67 9c			call macro_dsp_valuehl 
ad1e				endm 
# End of macro FORTH_DSP_VALUEHL
ad1e e5					push hl 
ad1f			 
ad1f					FORTH_DSP_POP 
ad1f cd 1f 9d			call macro_forth_dsp_pop 
ad22				endm 
# End of macro FORTH_DSP_POP
ad22 e1					pop hl 
ad23			 
ad23 23					inc hl 
ad24 cd 62 9a				call forth_push_numhl 
ad27					 
ad27					NEXTW 
ad27 c3 1d 9e			jp macro_next 
ad2a				endm 
# End of macro NEXTW
ad2a			.SBTOS: 
ad2a				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
ad2a 6f				db WORD_SYS_CORE+91             
ad2b 40 ad			dw .ADSTORE            
ad2d 03				db 2 + 1 
ad2e .. 00			db "1-",0              
ad31				endm 
# End of macro CWHEAD
ad31			; | 1- ( u -- u )  Decrement value on TOS | DONE 
ad31			 
ad31					FORTH_DSP_VALUEHL 
ad31 cd 67 9c			call macro_dsp_valuehl 
ad34				endm 
# End of macro FORTH_DSP_VALUEHL
ad34 e5					push hl 
ad35			 
ad35					FORTH_DSP_POP 
ad35 cd 1f 9d			call macro_forth_dsp_pop 
ad38				endm 
# End of macro FORTH_DSP_POP
ad38 e1					pop hl 
ad39			 
ad39 2b					dec hl 
ad3a cd 62 9a				call forth_push_numhl 
ad3d					 
ad3d					NEXTW 
ad3d c3 1d 9e			jp macro_next 
ad40				endm 
# End of macro NEXTW
ad40			.ADSTORE: 
ad40				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
ad40 6f				db WORD_SYS_CORE+91             
ad41 56 ad			dw .ADWSTORE            
ad43 04				db 3 + 1 
ad44 .. 00			db "1+!",0              
ad48				endm 
# End of macro CWHEAD
ad48			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
ad48			 
ad48					FORTH_DSP_VALUEHL 
ad48 cd 67 9c			call macro_dsp_valuehl 
ad4b				endm 
# End of macro FORTH_DSP_VALUEHL
ad4b e5					push hl 
ad4c			 
ad4c					FORTH_DSP_POP 
ad4c cd 1f 9d			call macro_forth_dsp_pop 
ad4f				endm 
# End of macro FORTH_DSP_POP
ad4f e1					pop hl 
ad50			 
ad50 7e					ld a, (hl) 
ad51 3c					inc a 
ad52 77					ld (hl), a 
ad53					 
ad53					NEXTW 
ad53 c3 1d 9e			jp macro_next 
ad56				endm 
# End of macro NEXTW
ad56			.ADWSTORE: 
ad56				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
ad56 6f				db WORD_SYS_CORE+91             
ad57 74 ad			dw .SBSTORE            
ad59 05				db 4 + 1 
ad5a .. 00			db "1+2!",0              
ad5f				endm 
# End of macro CWHEAD
ad5f			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
ad5f			 
ad5f					FORTH_DSP_VALUEHL 
ad5f cd 67 9c			call macro_dsp_valuehl 
ad62				endm 
# End of macro FORTH_DSP_VALUEHL
ad62 e5					push hl 
ad63			 
ad63					FORTH_DSP_POP 
ad63 cd 1f 9d			call macro_forth_dsp_pop 
ad66				endm 
# End of macro FORTH_DSP_POP
ad66 e1					pop hl 
ad67			 
ad67 e5					push hl 
ad68			 
ad68 cd 9f 9d				call loadwordinhl 
ad6b 23					inc hl 
ad6c			 
ad6c d1					pop de 
ad6d eb					ex de, hl 
ad6e 73					ld (hl), e 
ad6f 23					inc hl 
ad70 72					ld (hl), d 
ad71					 
ad71					NEXTW 
ad71 c3 1d 9e			jp macro_next 
ad74				endm 
# End of macro NEXTW
ad74			.SBSTORE: 
ad74				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
ad74 6f				db WORD_SYS_CORE+91             
ad75 8a ad			dw .SBWSTORE            
ad77 04				db 3 + 1 
ad78 .. 00			db "1-!",0              
ad7c				endm 
# End of macro CWHEAD
ad7c			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
ad7c			 
ad7c					FORTH_DSP_VALUEHL 
ad7c cd 67 9c			call macro_dsp_valuehl 
ad7f				endm 
# End of macro FORTH_DSP_VALUEHL
ad7f e5					push hl 
ad80			 
ad80					FORTH_DSP_POP 
ad80 cd 1f 9d			call macro_forth_dsp_pop 
ad83				endm 
# End of macro FORTH_DSP_POP
ad83 e1					pop hl 
ad84			 
ad84 7e					ld a, (hl) 
ad85 3d					dec a 
ad86 77					ld (hl), a 
ad87					 
ad87					NEXTW 
ad87 c3 1d 9e			jp macro_next 
ad8a				endm 
# End of macro NEXTW
ad8a			.SBWSTORE: 
ad8a				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
ad8a 6f				db WORD_SYS_CORE+91             
ad8b a8 ad			dw .ENDCORE            
ad8d 05				db 4 + 1 
ad8e .. 00			db "1-2!",0              
ad93				endm 
# End of macro CWHEAD
ad93			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
ad93			 
ad93					FORTH_DSP_VALUEHL 
ad93 cd 67 9c			call macro_dsp_valuehl 
ad96				endm 
# End of macro FORTH_DSP_VALUEHL
ad96 e5					push hl 
ad97			 
ad97					FORTH_DSP_POP 
ad97 cd 1f 9d			call macro_forth_dsp_pop 
ad9a				endm 
# End of macro FORTH_DSP_POP
ad9a e1					pop hl 
ad9b			 
ad9b e5					push hl 
ad9c			 
ad9c cd 9f 9d				call loadwordinhl 
ad9f 2b					dec hl 
ada0			 
ada0 d1					pop de 
ada1 eb					ex de, hl 
ada2 73					ld (hl), e 
ada3 23					inc hl 
ada4 72					ld (hl), d 
ada5					 
ada5					NEXTW 
ada5 c3 1d 9e			jp macro_next 
ada8				endm 
# End of macro NEXTW
ada8			.ENDCORE: 
ada8			 
ada8			; eof 
ada8			 
ada8			 
# End of file forth_words_core.asm
ada8			include "forth_words_flow.asm" 
ada8			 
ada8			; | ## Program Flow Words 
ada8			 
ada8			.IF: 
ada8				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ada8 1e				db WORD_SYS_CORE+10             
ada9 9d ae			dw .THEN            
adab 03				db 2 + 1 
adac .. 00			db "IF",0              
adaf				endm 
# End of macro CWHEAD
adaf			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
adaf			; 
adaf					if DEBUG_FORTH_WORDS_KEY 
adaf						DMARK "IF." 
adaf f5				push af  
adb0 3a c4 ad			ld a, (.dmark)  
adb3 32 6b ee			ld (debug_mark),a  
adb6 3a c5 ad			ld a, (.dmark+1)  
adb9 32 6c ee			ld (debug_mark+1),a  
adbc 3a c6 ad			ld a, (.dmark+2)  
adbf 32 6d ee			ld (debug_mark+2),a  
adc2 18 03			jr .pastdmark  
adc4 ..			.dmark: db "IF."  
adc7 f1			.pastdmark: pop af  
adc8			endm  
# End of macro DMARK
adc8						CALLMONITOR 
adc8 cd 6f ee			call debug_vector  
adcb				endm  
# End of macro CALLMONITOR
adcb					endif 
adcb			; eval TOS 
adcb			 
adcb				FORTH_DSP_VALUEHL 
adcb cd 67 9c			call macro_dsp_valuehl 
adce				endm 
# End of macro FORTH_DSP_VALUEHL
adce			 
adce			;	push hl 
adce				FORTH_DSP_POP 
adce cd 1f 9d			call macro_forth_dsp_pop 
add1				endm 
# End of macro FORTH_DSP_POP
add1			;	pop hl 
add1			 
add1					if DEBUG_FORTH_WORDS 
add1						DMARK "IF1" 
add1 f5				push af  
add2 3a e6 ad			ld a, (.dmark)  
add5 32 6b ee			ld (debug_mark),a  
add8 3a e7 ad			ld a, (.dmark+1)  
addb 32 6c ee			ld (debug_mark+1),a  
adde 3a e8 ad			ld a, (.dmark+2)  
ade1 32 6d ee			ld (debug_mark+2),a  
ade4 18 03			jr .pastdmark  
ade6 ..			.dmark: db "IF1"  
ade9 f1			.pastdmark: pop af  
adea			endm  
# End of macro DMARK
adea						CALLMONITOR 
adea cd 6f ee			call debug_vector  
aded				endm  
# End of macro CALLMONITOR
aded					endif 
aded b7				or a        ; clear carry flag 
adee 11 00 00			ld de, 0 
adf1 eb				ex de,hl 
adf2 ed 52			sbc hl, de 
adf4 c2 7e ae			jp nz, .iftrue 
adf7			 
adf7					if DEBUG_FORTH_WORDS 
adf7						DMARK "IF2" 
adf7 f5				push af  
adf8 3a 0c ae			ld a, (.dmark)  
adfb 32 6b ee			ld (debug_mark),a  
adfe 3a 0d ae			ld a, (.dmark+1)  
ae01 32 6c ee			ld (debug_mark+1),a  
ae04 3a 0e ae			ld a, (.dmark+2)  
ae07 32 6d ee			ld (debug_mark+2),a  
ae0a 18 03			jr .pastdmark  
ae0c ..			.dmark: db "IF2"  
ae0f f1			.pastdmark: pop af  
ae10			endm  
# End of macro DMARK
ae10						CALLMONITOR 
ae10 cd 6f ee			call debug_vector  
ae13				endm  
# End of macro CALLMONITOR
ae13					endif 
ae13			 
ae13			; if not true then skip to THEN 
ae13			 
ae13				; TODO get tok_ptr 
ae13				; TODO consume toks until we get to THEN 
ae13			 
ae13 2a c2 e5			ld hl, (os_tok_ptr) 
ae16					if DEBUG_FORTH_WORDS 
ae16						DMARK "IF3" 
ae16 f5				push af  
ae17 3a 2b ae			ld a, (.dmark)  
ae1a 32 6b ee			ld (debug_mark),a  
ae1d 3a 2c ae			ld a, (.dmark+1)  
ae20 32 6c ee			ld (debug_mark+1),a  
ae23 3a 2d ae			ld a, (.dmark+2)  
ae26 32 6d ee			ld (debug_mark+2),a  
ae29 18 03			jr .pastdmark  
ae2b ..			.dmark: db "IF3"  
ae2e f1			.pastdmark: pop af  
ae2f			endm  
# End of macro DMARK
ae2f						CALLMONITOR 
ae2f cd 6f ee			call debug_vector  
ae32				endm  
# End of macro CALLMONITOR
ae32						 
ae32					endif 
ae32 11 79 ae			ld de, .ifthen 
ae35					if DEBUG_FORTH_WORDS 
ae35						DMARK "IF4" 
ae35 f5				push af  
ae36 3a 4a ae			ld a, (.dmark)  
ae39 32 6b ee			ld (debug_mark),a  
ae3c 3a 4b ae			ld a, (.dmark+1)  
ae3f 32 6c ee			ld (debug_mark+1),a  
ae42 3a 4c ae			ld a, (.dmark+2)  
ae45 32 6d ee			ld (debug_mark+2),a  
ae48 18 03			jr .pastdmark  
ae4a ..			.dmark: db "IF4"  
ae4d f1			.pastdmark: pop af  
ae4e			endm  
# End of macro DMARK
ae4e						CALLMONITOR 
ae4e cd 6f ee			call debug_vector  
ae51				endm  
# End of macro CALLMONITOR
ae51					endif 
ae51 cd 38 9f			call findnexttok  
ae54			 
ae54					if DEBUG_FORTH_WORDS 
ae54						DMARK "IF5" 
ae54 f5				push af  
ae55 3a 69 ae			ld a, (.dmark)  
ae58 32 6b ee			ld (debug_mark),a  
ae5b 3a 6a ae			ld a, (.dmark+1)  
ae5e 32 6c ee			ld (debug_mark+1),a  
ae61 3a 6b ae			ld a, (.dmark+2)  
ae64 32 6d ee			ld (debug_mark+2),a  
ae67 18 03			jr .pastdmark  
ae69 ..			.dmark: db "IF5"  
ae6c f1			.pastdmark: pop af  
ae6d			endm  
# End of macro DMARK
ae6d						CALLMONITOR 
ae6d cd 6f ee			call debug_vector  
ae70				endm  
# End of macro CALLMONITOR
ae70					endif 
ae70				; TODO replace below with ; exec using tok_ptr 
ae70 22 c2 e5			ld (os_tok_ptr), hl 
ae73 c3 ae 9e			jp exec1 
ae76				NEXTW 
ae76 c3 1d 9e			jp macro_next 
ae79				endm 
# End of macro NEXTW
ae79			 
ae79 .. 00		.ifthen:  db "THEN",0 
ae7e			 
ae7e			.iftrue:		 
ae7e				; Exec next words normally 
ae7e			 
ae7e				; if true then exec following IF as normal 
ae7e					if DEBUG_FORTH_WORDS 
ae7e						DMARK "IFT" 
ae7e f5				push af  
ae7f 3a 93 ae			ld a, (.dmark)  
ae82 32 6b ee			ld (debug_mark),a  
ae85 3a 94 ae			ld a, (.dmark+1)  
ae88 32 6c ee			ld (debug_mark+1),a  
ae8b 3a 95 ae			ld a, (.dmark+2)  
ae8e 32 6d ee			ld (debug_mark+2),a  
ae91 18 03			jr .pastdmark  
ae93 ..			.dmark: db "IFT"  
ae96 f1			.pastdmark: pop af  
ae97			endm  
# End of macro DMARK
ae97						CALLMONITOR 
ae97 cd 6f ee			call debug_vector  
ae9a				endm  
# End of macro CALLMONITOR
ae9a					endif 
ae9a			 
ae9a					NEXTW 
ae9a c3 1d 9e			jp macro_next 
ae9d				endm 
# End of macro NEXTW
ae9d			.THEN: 
ae9d				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ae9d 1f				db WORD_SYS_CORE+11             
ae9e c5 ae			dw .ELSE            
aea0 05				db 4 + 1 
aea1 .. 00			db "THEN",0              
aea6				endm 
# End of macro CWHEAD
aea6			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
aea6					if DEBUG_FORTH_WORDS_KEY 
aea6						DMARK "THN" 
aea6 f5				push af  
aea7 3a bb ae			ld a, (.dmark)  
aeaa 32 6b ee			ld (debug_mark),a  
aead 3a bc ae			ld a, (.dmark+1)  
aeb0 32 6c ee			ld (debug_mark+1),a  
aeb3 3a bd ae			ld a, (.dmark+2)  
aeb6 32 6d ee			ld (debug_mark+2),a  
aeb9 18 03			jr .pastdmark  
aebb ..			.dmark: db "THN"  
aebe f1			.pastdmark: pop af  
aebf			endm  
# End of macro DMARK
aebf						CALLMONITOR 
aebf cd 6f ee			call debug_vector  
aec2				endm  
# End of macro CALLMONITOR
aec2					endif 
aec2					NEXTW 
aec2 c3 1d 9e			jp macro_next 
aec5				endm 
# End of macro NEXTW
aec5			.ELSE: 
aec5				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aec5 20				db WORD_SYS_CORE+12             
aec6 ed ae			dw .DO            
aec8 03				db 2 + 1 
aec9 .. 00			db "ELSE",0              
aece				endm 
# End of macro CWHEAD
aece			; | ELSE ( -- ) Not supported - does nothing | TODO 
aece			 
aece					if DEBUG_FORTH_WORDS_KEY 
aece						DMARK "ELS" 
aece f5				push af  
aecf 3a e3 ae			ld a, (.dmark)  
aed2 32 6b ee			ld (debug_mark),a  
aed5 3a e4 ae			ld a, (.dmark+1)  
aed8 32 6c ee			ld (debug_mark+1),a  
aedb 3a e5 ae			ld a, (.dmark+2)  
aede 32 6d ee			ld (debug_mark+2),a  
aee1 18 03			jr .pastdmark  
aee3 ..			.dmark: db "ELS"  
aee6 f1			.pastdmark: pop af  
aee7			endm  
# End of macro DMARK
aee7						CALLMONITOR 
aee7 cd 6f ee			call debug_vector  
aeea				endm  
# End of macro CALLMONITOR
aeea					endif 
aeea			 
aeea			 
aeea					NEXTW 
aeea c3 1d 9e			jp macro_next 
aeed				endm 
# End of macro NEXTW
aeed			.DO: 
aeed				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
aeed 21				db WORD_SYS_CORE+13             
aeee 14 b0			dw .LOOP            
aef0 03				db 2 + 1 
aef1 .. 00			db "DO",0              
aef4				endm 
# End of macro CWHEAD
aef4			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
aef4			 
aef4					if DEBUG_FORTH_WORDS_KEY 
aef4						DMARK "DO." 
aef4 f5				push af  
aef5 3a 09 af			ld a, (.dmark)  
aef8 32 6b ee			ld (debug_mark),a  
aefb 3a 0a af			ld a, (.dmark+1)  
aefe 32 6c ee			ld (debug_mark+1),a  
af01 3a 0b af			ld a, (.dmark+2)  
af04 32 6d ee			ld (debug_mark+2),a  
af07 18 03			jr .pastdmark  
af09 ..			.dmark: db "DO."  
af0c f1			.pastdmark: pop af  
af0d			endm  
# End of macro DMARK
af0d						CALLMONITOR 
af0d cd 6f ee			call debug_vector  
af10				endm  
# End of macro CALLMONITOR
af10					endif 
af10			;  push pc to rsp stack past the DO 
af10			 
af10 2a c2 e5				ld hl, (os_tok_ptr) 
af13 23					inc hl   ; D 
af14 23					inc hl  ; O 
af15 23					inc hl   ; null 
af16					if DEBUG_FORTH_WORDS 
af16						DMARK "DO2" 
af16 f5				push af  
af17 3a 2b af			ld a, (.dmark)  
af1a 32 6b ee			ld (debug_mark),a  
af1d 3a 2c af			ld a, (.dmark+1)  
af20 32 6c ee			ld (debug_mark+1),a  
af23 3a 2d af			ld a, (.dmark+2)  
af26 32 6d ee			ld (debug_mark+2),a  
af29 18 03			jr .pastdmark  
af2b ..			.dmark: db "DO2"  
af2e f1			.pastdmark: pop af  
af2f			endm  
# End of macro DMARK
af2f						CALLMONITOR 
af2f cd 6f ee			call debug_vector  
af32				endm  
# End of macro CALLMONITOR
af32					endif 
af32					FORTH_RSP_NEXT 
af32 cd 09 9a			call macro_forth_rsp_next 
af35				endm 
# End of macro FORTH_RSP_NEXT
af35					if DEBUG_FORTH_WORDS 
af35						DMARK "DO3" 
af35 f5				push af  
af36 3a 4a af			ld a, (.dmark)  
af39 32 6b ee			ld (debug_mark),a  
af3c 3a 4b af			ld a, (.dmark+1)  
af3f 32 6c ee			ld (debug_mark+1),a  
af42 3a 4c af			ld a, (.dmark+2)  
af45 32 6d ee			ld (debug_mark+2),a  
af48 18 03			jr .pastdmark  
af4a ..			.dmark: db "DO3"  
af4d f1			.pastdmark: pop af  
af4e			endm  
# End of macro DMARK
af4e						CALLMONITOR 
af4e cd 6f ee			call debug_vector  
af51				endm  
# End of macro CALLMONITOR
af51					endif 
af51			 
af51					;if DEBUG_FORTH_WORDS 
af51				;		push hl 
af51			;		endif  
af51			 
af51			; get counters from data stack 
af51			 
af51			 
af51					FORTH_DSP_VALUEHL 
af51 cd 67 9c			call macro_dsp_valuehl 
af54				endm 
# End of macro FORTH_DSP_VALUEHL
af54 e5					push hl		 ; hl now has starting counter which needs to be tos 
af55			 
af55					if DEBUG_FORTH_WORDS 
af55						DMARK "DO4" 
af55 f5				push af  
af56 3a 6a af			ld a, (.dmark)  
af59 32 6b ee			ld (debug_mark),a  
af5c 3a 6b af			ld a, (.dmark+1)  
af5f 32 6c ee			ld (debug_mark+1),a  
af62 3a 6c af			ld a, (.dmark+2)  
af65 32 6d ee			ld (debug_mark+2),a  
af68 18 03			jr .pastdmark  
af6a ..			.dmark: db "DO4"  
af6d f1			.pastdmark: pop af  
af6e			endm  
# End of macro DMARK
af6e						CALLMONITOR 
af6e cd 6f ee			call debug_vector  
af71				endm  
# End of macro CALLMONITOR
af71					endif 
af71					FORTH_DSP_POP 
af71 cd 1f 9d			call macro_forth_dsp_pop 
af74				endm 
# End of macro FORTH_DSP_POP
af74			 
af74					if DEBUG_FORTH_WORDS 
af74						DMARK "DO5" 
af74 f5				push af  
af75 3a 89 af			ld a, (.dmark)  
af78 32 6b ee			ld (debug_mark),a  
af7b 3a 8a af			ld a, (.dmark+1)  
af7e 32 6c ee			ld (debug_mark+1),a  
af81 3a 8b af			ld a, (.dmark+2)  
af84 32 6d ee			ld (debug_mark+2),a  
af87 18 03			jr .pastdmark  
af89 ..			.dmark: db "DO5"  
af8c f1			.pastdmark: pop af  
af8d			endm  
# End of macro DMARK
af8d						CALLMONITOR 
af8d cd 6f ee			call debug_vector  
af90				endm  
# End of macro CALLMONITOR
af90					endif 
af90			 
af90					FORTH_DSP_VALUEHL 
af90 cd 67 9c			call macro_dsp_valuehl 
af93				endm 
# End of macro FORTH_DSP_VALUEHL
af93			;		push hl		 ; hl now has starting limit counter 
af93			 
af93					if DEBUG_FORTH_WORDS 
af93						DMARK "DO6" 
af93 f5				push af  
af94 3a a8 af			ld a, (.dmark)  
af97 32 6b ee			ld (debug_mark),a  
af9a 3a a9 af			ld a, (.dmark+1)  
af9d 32 6c ee			ld (debug_mark+1),a  
afa0 3a aa af			ld a, (.dmark+2)  
afa3 32 6d ee			ld (debug_mark+2),a  
afa6 18 03			jr .pastdmark  
afa8 ..			.dmark: db "DO6"  
afab f1			.pastdmark: pop af  
afac			endm  
# End of macro DMARK
afac						CALLMONITOR 
afac cd 6f ee			call debug_vector  
afaf				endm  
# End of macro CALLMONITOR
afaf					endif 
afaf					FORTH_DSP_POP 
afaf cd 1f 9d			call macro_forth_dsp_pop 
afb2				endm 
# End of macro FORTH_DSP_POP
afb2			 
afb2			; put counters on the loop stack 
afb2			 
afb2			;		pop hl			 ; limit counter 
afb2 d1					pop de			; start counter 
afb3			 
afb3					; push limit counter 
afb3			 
afb3					if DEBUG_FORTH_WORDS 
afb3						DMARK "DO7" 
afb3 f5				push af  
afb4 3a c8 af			ld a, (.dmark)  
afb7 32 6b ee			ld (debug_mark),a  
afba 3a c9 af			ld a, (.dmark+1)  
afbd 32 6c ee			ld (debug_mark+1),a  
afc0 3a ca af			ld a, (.dmark+2)  
afc3 32 6d ee			ld (debug_mark+2),a  
afc6 18 03			jr .pastdmark  
afc8 ..			.dmark: db "DO7"  
afcb f1			.pastdmark: pop af  
afcc			endm  
# End of macro DMARK
afcc						CALLMONITOR 
afcc cd 6f ee			call debug_vector  
afcf				endm  
# End of macro CALLMONITOR
afcf					endif 
afcf					FORTH_LOOP_NEXT 
afcf cd 98 9c			call macro_forth_loop_next 
afd2				endm 
# End of macro FORTH_LOOP_NEXT
afd2			 
afd2					; push start counter 
afd2			 
afd2 eb					ex de, hl 
afd3					if DEBUG_FORTH_WORDS 
afd3						DMARK "DO7" 
afd3 f5				push af  
afd4 3a e8 af			ld a, (.dmark)  
afd7 32 6b ee			ld (debug_mark),a  
afda 3a e9 af			ld a, (.dmark+1)  
afdd 32 6c ee			ld (debug_mark+1),a  
afe0 3a ea af			ld a, (.dmark+2)  
afe3 32 6d ee			ld (debug_mark+2),a  
afe6 18 03			jr .pastdmark  
afe8 ..			.dmark: db "DO7"  
afeb f1			.pastdmark: pop af  
afec			endm  
# End of macro DMARK
afec						CALLMONITOR 
afec cd 6f ee			call debug_vector  
afef				endm  
# End of macro CALLMONITOR
afef					endif 
afef					FORTH_LOOP_NEXT 
afef cd 98 9c			call macro_forth_loop_next 
aff2				endm 
# End of macro FORTH_LOOP_NEXT
aff2			 
aff2			 
aff2					; init first round of I counter 
aff2			 
aff2 22 e6 e5				ld (os_current_i), hl 
aff5			 
aff5					if DEBUG_FORTH_WORDS 
aff5						DMARK "DO8" 
aff5 f5				push af  
aff6 3a 0a b0			ld a, (.dmark)  
aff9 32 6b ee			ld (debug_mark),a  
affc 3a 0b b0			ld a, (.dmark+1)  
afff 32 6c ee			ld (debug_mark+1),a  
b002 3a 0c b0			ld a, (.dmark+2)  
b005 32 6d ee			ld (debug_mark+2),a  
b008 18 03			jr .pastdmark  
b00a ..			.dmark: db "DO8"  
b00d f1			.pastdmark: pop af  
b00e			endm  
# End of macro DMARK
b00e						CALLMONITOR 
b00e cd 6f ee			call debug_vector  
b011				endm  
# End of macro CALLMONITOR
b011					endif 
b011			 
b011					NEXTW 
b011 c3 1d 9e			jp macro_next 
b014				endm 
# End of macro NEXTW
b014			.LOOP: 
b014				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b014 22				db WORD_SYS_CORE+14             
b015 2c b1			dw .I            
b017 05				db 4 + 1 
b018 .. 00			db "LOOP",0              
b01d				endm 
# End of macro CWHEAD
b01d			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b01d			 
b01d				; pop tos as current loop count to hl 
b01d			 
b01d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b01d			 
b01d				FORTH_LOOP_TOS 
b01d cd cb 9c			call macro_forth_loop_tos 
b020				endm 
# End of macro FORTH_LOOP_TOS
b020 e5				push hl 
b021			 
b021					if DEBUG_FORTH_WORDS_KEY 
b021						DMARK "LOP" 
b021 f5				push af  
b022 3a 36 b0			ld a, (.dmark)  
b025 32 6b ee			ld (debug_mark),a  
b028 3a 37 b0			ld a, (.dmark+1)  
b02b 32 6c ee			ld (debug_mark+1),a  
b02e 3a 38 b0			ld a, (.dmark+2)  
b031 32 6d ee			ld (debug_mark+2),a  
b034 18 03			jr .pastdmark  
b036 ..			.dmark: db "LOP"  
b039 f1			.pastdmark: pop af  
b03a			endm  
# End of macro DMARK
b03a						CALLMONITOR 
b03a cd 6f ee			call debug_vector  
b03d				endm  
# End of macro CALLMONITOR
b03d					endif 
b03d				; next item on the stack is the limit. get it 
b03d			 
b03d			 
b03d				FORTH_LOOP_POP 
b03d cd d5 9c			call macro_forth_loop_pop 
b040				endm 
# End of macro FORTH_LOOP_POP
b040			 
b040				FORTH_LOOP_TOS 
b040 cd cb 9c			call macro_forth_loop_tos 
b043				endm 
# End of macro FORTH_LOOP_TOS
b043			 
b043 d1				pop de		 ; de = i, hl = limit 
b044			 
b044					if DEBUG_FORTH_WORDS 
b044						DMARK "LP1" 
b044 f5				push af  
b045 3a 59 b0			ld a, (.dmark)  
b048 32 6b ee			ld (debug_mark),a  
b04b 3a 5a b0			ld a, (.dmark+1)  
b04e 32 6c ee			ld (debug_mark+1),a  
b051 3a 5b b0			ld a, (.dmark+2)  
b054 32 6d ee			ld (debug_mark+2),a  
b057 18 03			jr .pastdmark  
b059 ..			.dmark: db "LP1"  
b05c f1			.pastdmark: pop af  
b05d			endm  
# End of macro DMARK
b05d						CALLMONITOR 
b05d cd 6f ee			call debug_vector  
b060				endm  
# End of macro CALLMONITOR
b060					endif 
b060			 
b060				; go back to previous word 
b060			 
b060 d5				push de    ; save I for inc later 
b061			 
b061			 
b061				; get limit 
b061				;  is I at limit? 
b061			 
b061			 
b061					if DEBUG_FORTH_WORDS 
b061						DMARK "LP1" 
b061 f5				push af  
b062 3a 76 b0			ld a, (.dmark)  
b065 32 6b ee			ld (debug_mark),a  
b068 3a 77 b0			ld a, (.dmark+1)  
b06b 32 6c ee			ld (debug_mark+1),a  
b06e 3a 78 b0			ld a, (.dmark+2)  
b071 32 6d ee			ld (debug_mark+2),a  
b074 18 03			jr .pastdmark  
b076 ..			.dmark: db "LP1"  
b079 f1			.pastdmark: pop af  
b07a			endm  
# End of macro DMARK
b07a						CALLMONITOR 
b07a cd 6f ee			call debug_vector  
b07d				endm  
# End of macro CALLMONITOR
b07d					endif 
b07d			 
b07d ed 52			sbc hl, de 
b07f			 
b07f			 
b07f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b07f			 
b07f 20 26				jr nz, .loopnotdone 
b081			 
b081 e1				pop hl   ; get rid of saved I 
b082				FORTH_LOOP_POP     ; get rid of limit 
b082 cd d5 9c			call macro_forth_loop_pop 
b085				endm 
# End of macro FORTH_LOOP_POP
b085			 
b085				FORTH_RSP_POP     ; get rid of DO ptr 
b085 cd 2a 9a			call macro_forth_rsp_pop 
b088				endm 
# End of macro FORTH_RSP_POP
b088			 
b088			if DEBUG_FORTH_WORDS 
b088						DMARK "LP>" 
b088 f5				push af  
b089 3a 9d b0			ld a, (.dmark)  
b08c 32 6b ee			ld (debug_mark),a  
b08f 3a 9e b0			ld a, (.dmark+1)  
b092 32 6c ee			ld (debug_mark+1),a  
b095 3a 9f b0			ld a, (.dmark+2)  
b098 32 6d ee			ld (debug_mark+2),a  
b09b 18 03			jr .pastdmark  
b09d ..			.dmark: db "LP>"  
b0a0 f1			.pastdmark: pop af  
b0a1			endm  
# End of macro DMARK
b0a1				CALLMONITOR 
b0a1 cd 6f ee			call debug_vector  
b0a4				endm  
# End of macro CALLMONITOR
b0a4			endif 
b0a4			 
b0a4					NEXTW 
b0a4 c3 1d 9e			jp macro_next 
b0a7				endm 
# End of macro NEXTW
b0a7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b0a7			 
b0a7			.loopnotdone: 
b0a7			 
b0a7 e1				pop hl    ; get I 
b0a8 23				inc hl 
b0a9			 
b0a9			   	; save new I 
b0a9			 
b0a9			 
b0a9					; set I counter 
b0a9			 
b0a9 22 e6 e5				ld (os_current_i), hl 
b0ac			 
b0ac					if DEBUG_FORTH_WORDS 
b0ac						DMARK "LPN" 
b0ac f5				push af  
b0ad 3a c1 b0			ld a, (.dmark)  
b0b0 32 6b ee			ld (debug_mark),a  
b0b3 3a c2 b0			ld a, (.dmark+1)  
b0b6 32 6c ee			ld (debug_mark+1),a  
b0b9 3a c3 b0			ld a, (.dmark+2)  
b0bc 32 6d ee			ld (debug_mark+2),a  
b0bf 18 03			jr .pastdmark  
b0c1 ..			.dmark: db "LPN"  
b0c4 f1			.pastdmark: pop af  
b0c5			endm  
# End of macro DMARK
b0c5					CALLMONITOR 
b0c5 cd 6f ee			call debug_vector  
b0c8				endm  
# End of macro CALLMONITOR
b0c8					endif 
b0c8					 
b0c8				FORTH_LOOP_NEXT 
b0c8 cd 98 9c			call macro_forth_loop_next 
b0cb				endm 
# End of macro FORTH_LOOP_NEXT
b0cb			 
b0cb			 
b0cb					if DEBUG_FORTH_WORDS 
b0cb eb						ex de,hl 
b0cc					endif 
b0cc			 
b0cc			;	; get DO ptr 
b0cc			; 
b0cc					if DEBUG_FORTH_WORDS 
b0cc						DMARK "LP7" 
b0cc f5				push af  
b0cd 3a e1 b0			ld a, (.dmark)  
b0d0 32 6b ee			ld (debug_mark),a  
b0d3 3a e2 b0			ld a, (.dmark+1)  
b0d6 32 6c ee			ld (debug_mark+1),a  
b0d9 3a e3 b0			ld a, (.dmark+2)  
b0dc 32 6d ee			ld (debug_mark+2),a  
b0df 18 03			jr .pastdmark  
b0e1 ..			.dmark: db "LP7"  
b0e4 f1			.pastdmark: pop af  
b0e5			endm  
# End of macro DMARK
b0e5					CALLMONITOR 
b0e5 cd 6f ee			call debug_vector  
b0e8				endm  
# End of macro CALLMONITOR
b0e8					endif 
b0e8				FORTH_RSP_TOS 
b0e8 cd 20 9a			call macro_forth_rsp_tos 
b0eb				endm 
# End of macro FORTH_RSP_TOS
b0eb			 
b0eb					if DEBUG_FORTH_WORDS 
b0eb						DMARK "LP8" 
b0eb f5				push af  
b0ec 3a 00 b1			ld a, (.dmark)  
b0ef 32 6b ee			ld (debug_mark),a  
b0f2 3a 01 b1			ld a, (.dmark+1)  
b0f5 32 6c ee			ld (debug_mark+1),a  
b0f8 3a 02 b1			ld a, (.dmark+2)  
b0fb 32 6d ee			ld (debug_mark+2),a  
b0fe 18 03			jr .pastdmark  
b100 ..			.dmark: db "LP8"  
b103 f1			.pastdmark: pop af  
b104			endm  
# End of macro DMARK
b104					CALLMONITOR 
b104 cd 6f ee			call debug_vector  
b107				endm  
# End of macro CALLMONITOR
b107					endif 
b107				;push hl 
b107			 
b107				; not going to DO any more 
b107				; get rid of the RSP pointer as DO will add it back in 
b107				;FORTH_RSP_POP 
b107				;pop hl 
b107			 
b107				;ld hl,(cli_ret_sp) 
b107				;ld e, (hl) 
b107				;inc hl 
b107				;ld d, (hl) 
b107				;ex de,hl 
b107 22 c2 e5			ld (os_tok_ptr), hl 
b10a					if DEBUG_FORTH_WORDS 
b10a						DMARK "LP<" 
b10a f5				push af  
b10b 3a 1f b1			ld a, (.dmark)  
b10e 32 6b ee			ld (debug_mark),a  
b111 3a 20 b1			ld a, (.dmark+1)  
b114 32 6c ee			ld (debug_mark+1),a  
b117 3a 21 b1			ld a, (.dmark+2)  
b11a 32 6d ee			ld (debug_mark+2),a  
b11d 18 03			jr .pastdmark  
b11f ..			.dmark: db "LP<"  
b122 f1			.pastdmark: pop af  
b123			endm  
# End of macro DMARK
b123					CALLMONITOR 
b123 cd 6f ee			call debug_vector  
b126				endm  
# End of macro CALLMONITOR
b126				endif 
b126 c3 ae 9e			jp exec1 
b129			 
b129					 
b129			 
b129			 
b129					NEXTW 
b129 c3 1d 9e			jp macro_next 
b12c				endm 
# End of macro NEXTW
b12c			.I:  
b12c			 
b12c				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b12c 5e				db WORD_SYS_CORE+74             
b12d 57 b1			dw .DLOOP            
b12f 02				db 1 + 1 
b130 .. 00			db "I",0              
b132				endm 
# End of macro CWHEAD
b132			; | I ( -- ) Current loop counter | DONE 
b132					if DEBUG_FORTH_WORDS_KEY 
b132						DMARK "I.." 
b132 f5				push af  
b133 3a 47 b1			ld a, (.dmark)  
b136 32 6b ee			ld (debug_mark),a  
b139 3a 48 b1			ld a, (.dmark+1)  
b13c 32 6c ee			ld (debug_mark+1),a  
b13f 3a 49 b1			ld a, (.dmark+2)  
b142 32 6d ee			ld (debug_mark+2),a  
b145 18 03			jr .pastdmark  
b147 ..			.dmark: db "I.."  
b14a f1			.pastdmark: pop af  
b14b			endm  
# End of macro DMARK
b14b						CALLMONITOR 
b14b cd 6f ee			call debug_vector  
b14e				endm  
# End of macro CALLMONITOR
b14e					endif 
b14e			 
b14e 2a e6 e5				ld hl,(os_current_i) 
b151 cd 62 9a				call forth_push_numhl 
b154			 
b154					NEXTW 
b154 c3 1d 9e			jp macro_next 
b157				endm 
# End of macro NEXTW
b157			.DLOOP: 
b157				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b157 5f				db WORD_SYS_CORE+75             
b158 38 b2			dw .REPEAT            
b15a 06				db 5 + 1 
b15b .. 00			db "-LOOP",0              
b161				endm 
# End of macro CWHEAD
b161			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b161				; pop tos as current loop count to hl 
b161					if DEBUG_FORTH_WORDS_KEY 
b161						DMARK "-LP" 
b161 f5				push af  
b162 3a 76 b1			ld a, (.dmark)  
b165 32 6b ee			ld (debug_mark),a  
b168 3a 77 b1			ld a, (.dmark+1)  
b16b 32 6c ee			ld (debug_mark+1),a  
b16e 3a 78 b1			ld a, (.dmark+2)  
b171 32 6d ee			ld (debug_mark+2),a  
b174 18 03			jr .pastdmark  
b176 ..			.dmark: db "-LP"  
b179 f1			.pastdmark: pop af  
b17a			endm  
# End of macro DMARK
b17a						CALLMONITOR 
b17a cd 6f ee			call debug_vector  
b17d				endm  
# End of macro CALLMONITOR
b17d					endif 
b17d			 
b17d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b17d			 
b17d				FORTH_LOOP_TOS 
b17d cd cb 9c			call macro_forth_loop_tos 
b180				endm 
# End of macro FORTH_LOOP_TOS
b180 e5				push hl 
b181			 
b181					if DEBUG_FORTH_WORDS 
b181						DMARK "-LP" 
b181 f5				push af  
b182 3a 96 b1			ld a, (.dmark)  
b185 32 6b ee			ld (debug_mark),a  
b188 3a 97 b1			ld a, (.dmark+1)  
b18b 32 6c ee			ld (debug_mark+1),a  
b18e 3a 98 b1			ld a, (.dmark+2)  
b191 32 6d ee			ld (debug_mark+2),a  
b194 18 03			jr .pastdmark  
b196 ..			.dmark: db "-LP"  
b199 f1			.pastdmark: pop af  
b19a			endm  
# End of macro DMARK
b19a						CALLMONITOR 
b19a cd 6f ee			call debug_vector  
b19d				endm  
# End of macro CALLMONITOR
b19d					endif 
b19d				; next item on the stack is the limit. get it 
b19d			 
b19d			 
b19d				FORTH_LOOP_POP 
b19d cd d5 9c			call macro_forth_loop_pop 
b1a0				endm 
# End of macro FORTH_LOOP_POP
b1a0			 
b1a0				FORTH_LOOP_TOS 
b1a0 cd cb 9c			call macro_forth_loop_tos 
b1a3				endm 
# End of macro FORTH_LOOP_TOS
b1a3			 
b1a3 d1				pop de		 ; de = i, hl = limit 
b1a4			 
b1a4					if DEBUG_FORTH_WORDS 
b1a4						DMARK "-L1" 
b1a4 f5				push af  
b1a5 3a b9 b1			ld a, (.dmark)  
b1a8 32 6b ee			ld (debug_mark),a  
b1ab 3a ba b1			ld a, (.dmark+1)  
b1ae 32 6c ee			ld (debug_mark+1),a  
b1b1 3a bb b1			ld a, (.dmark+2)  
b1b4 32 6d ee			ld (debug_mark+2),a  
b1b7 18 03			jr .pastdmark  
b1b9 ..			.dmark: db "-L1"  
b1bc f1			.pastdmark: pop af  
b1bd			endm  
# End of macro DMARK
b1bd						CALLMONITOR 
b1bd cd 6f ee			call debug_vector  
b1c0				endm  
# End of macro CALLMONITOR
b1c0					endif 
b1c0			 
b1c0				; go back to previous word 
b1c0			 
b1c0 d5				push de    ; save I for inc later 
b1c1			 
b1c1			 
b1c1				; get limit 
b1c1				;  is I at limit? 
b1c1			 
b1c1			 
b1c1					if DEBUG_FORTH_WORDS 
b1c1						DMARK "-L1" 
b1c1 f5				push af  
b1c2 3a d6 b1			ld a, (.dmark)  
b1c5 32 6b ee			ld (debug_mark),a  
b1c8 3a d7 b1			ld a, (.dmark+1)  
b1cb 32 6c ee			ld (debug_mark+1),a  
b1ce 3a d8 b1			ld a, (.dmark+2)  
b1d1 32 6d ee			ld (debug_mark+2),a  
b1d4 18 03			jr .pastdmark  
b1d6 ..			.dmark: db "-L1"  
b1d9 f1			.pastdmark: pop af  
b1da			endm  
# End of macro DMARK
b1da						CALLMONITOR 
b1da cd 6f ee			call debug_vector  
b1dd				endm  
# End of macro CALLMONITOR
b1dd					endif 
b1dd			 
b1dd ed 52			sbc hl, de 
b1df			 
b1df			 
b1df				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b1df			 
b1df 20 26				jr nz, .mloopnotdone 
b1e1			 
b1e1 e1				pop hl   ; get rid of saved I 
b1e2				FORTH_LOOP_POP     ; get rid of limit 
b1e2 cd d5 9c			call macro_forth_loop_pop 
b1e5				endm 
# End of macro FORTH_LOOP_POP
b1e5			 
b1e5				FORTH_RSP_POP     ; get rid of DO ptr 
b1e5 cd 2a 9a			call macro_forth_rsp_pop 
b1e8				endm 
# End of macro FORTH_RSP_POP
b1e8			 
b1e8			if DEBUG_FORTH_WORDS 
b1e8						DMARK "-L>" 
b1e8 f5				push af  
b1e9 3a fd b1			ld a, (.dmark)  
b1ec 32 6b ee			ld (debug_mark),a  
b1ef 3a fe b1			ld a, (.dmark+1)  
b1f2 32 6c ee			ld (debug_mark+1),a  
b1f5 3a ff b1			ld a, (.dmark+2)  
b1f8 32 6d ee			ld (debug_mark+2),a  
b1fb 18 03			jr .pastdmark  
b1fd ..			.dmark: db "-L>"  
b200 f1			.pastdmark: pop af  
b201			endm  
# End of macro DMARK
b201				CALLMONITOR 
b201 cd 6f ee			call debug_vector  
b204				endm  
# End of macro CALLMONITOR
b204			endif 
b204			 
b204					NEXTW 
b204 c3 1d 9e			jp macro_next 
b207				endm 
# End of macro NEXTW
b207				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b207			 
b207			.mloopnotdone: 
b207			 
b207 e1				pop hl    ; get I 
b208 2b				dec hl 
b209			 
b209			   	; save new I 
b209			 
b209			 
b209					; set I counter 
b209			 
b209 22 e6 e5				ld (os_current_i), hl 
b20c			 
b20c					 
b20c				FORTH_LOOP_NEXT 
b20c cd 98 9c			call macro_forth_loop_next 
b20f				endm 
# End of macro FORTH_LOOP_NEXT
b20f			 
b20f			 
b20f					if DEBUG_FORTH_WORDS 
b20f eb						ex de,hl 
b210					endif 
b210			 
b210			;	; get DO ptr 
b210			; 
b210				FORTH_RSP_TOS 
b210 cd 20 9a			call macro_forth_rsp_tos 
b213				endm 
# End of macro FORTH_RSP_TOS
b213			 
b213				;push hl 
b213			 
b213				; not going to DO any more 
b213				; get rid of the RSP pointer as DO will add it back in 
b213				;FORTH_RSP_POP 
b213				;pop hl 
b213			 
b213			 
b213 22 c2 e5			ld (os_tok_ptr), hl 
b216					if DEBUG_FORTH_WORDS 
b216						DMARK "-L<" 
b216 f5				push af  
b217 3a 2b b2			ld a, (.dmark)  
b21a 32 6b ee			ld (debug_mark),a  
b21d 3a 2c b2			ld a, (.dmark+1)  
b220 32 6c ee			ld (debug_mark+1),a  
b223 3a 2d b2			ld a, (.dmark+2)  
b226 32 6d ee			ld (debug_mark+2),a  
b229 18 03			jr .pastdmark  
b22b ..			.dmark: db "-L<"  
b22e f1			.pastdmark: pop af  
b22f			endm  
# End of macro DMARK
b22f					CALLMONITOR 
b22f cd 6f ee			call debug_vector  
b232				endm  
# End of macro CALLMONITOR
b232				endif 
b232 c3 ae 9e			jp exec1 
b235			 
b235					 
b235			 
b235			 
b235			 
b235				NEXTW 
b235 c3 1d 9e			jp macro_next 
b238				endm 
# End of macro NEXTW
b238			 
b238			 
b238			 
b238			 
b238			.REPEAT: 
b238				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b238 71				db WORD_SYS_CORE+93             
b239 8b b2			dw .UNTIL            
b23b 06				db 5 + 1 
b23c .. 00			db "REPEAT",0              
b243				endm 
# End of macro CWHEAD
b243			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b243			;  push pc to rsp stack past the REPEAT 
b243					if DEBUG_FORTH_WORDS_KEY 
b243						DMARK "REP" 
b243 f5				push af  
b244 3a 58 b2			ld a, (.dmark)  
b247 32 6b ee			ld (debug_mark),a  
b24a 3a 59 b2			ld a, (.dmark+1)  
b24d 32 6c ee			ld (debug_mark+1),a  
b250 3a 5a b2			ld a, (.dmark+2)  
b253 32 6d ee			ld (debug_mark+2),a  
b256 18 03			jr .pastdmark  
b258 ..			.dmark: db "REP"  
b25b f1			.pastdmark: pop af  
b25c			endm  
# End of macro DMARK
b25c						CALLMONITOR 
b25c cd 6f ee			call debug_vector  
b25f				endm  
# End of macro CALLMONITOR
b25f					endif 
b25f			 
b25f 2a c2 e5				ld hl, (os_tok_ptr) 
b262 23					inc hl   ; R 
b263 23					inc hl  ; E 
b264 23					inc hl   ; P 
b265 23					inc hl   ; E 
b266 23					inc hl   ; A 
b267 23					inc hl   ; T 
b268 23					inc hl   ; zero 
b269					FORTH_RSP_NEXT 
b269 cd 09 9a			call macro_forth_rsp_next 
b26c				endm 
# End of macro FORTH_RSP_NEXT
b26c			 
b26c			 
b26c					if DEBUG_FORTH_WORDS 
b26c						DMARK "REP" 
b26c f5				push af  
b26d 3a 81 b2			ld a, (.dmark)  
b270 32 6b ee			ld (debug_mark),a  
b273 3a 82 b2			ld a, (.dmark+1)  
b276 32 6c ee			ld (debug_mark+1),a  
b279 3a 83 b2			ld a, (.dmark+2)  
b27c 32 6d ee			ld (debug_mark+2),a  
b27f 18 03			jr .pastdmark  
b281 ..			.dmark: db "REP"  
b284 f1			.pastdmark: pop af  
b285			endm  
# End of macro DMARK
b285						;pop bc    ; TODO BUG ?????? what is this for???? 
b285						CALLMONITOR 
b285 cd 6f ee			call debug_vector  
b288				endm  
# End of macro CALLMONITOR
b288					endif 
b288			 
b288					NEXTW 
b288 c3 1d 9e			jp macro_next 
b28b				endm 
# End of macro NEXTW
b28b			;	       NEXTW 
b28b			 
b28b			.UNTIL: 
b28b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b28b 72				db WORD_SYS_CORE+94             
b28c 22 b3			dw .ENDFLOW            
b28e 06				db 5 + 1 
b28f .. 00			db "UNTIL",0              
b295				endm 
# End of macro CWHEAD
b295			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b295			 
b295				; pop tos as check 
b295			 
b295				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b295			 
b295				FORTH_DSP_VALUEHL 
b295 cd 67 9c			call macro_dsp_valuehl 
b298				endm 
# End of macro FORTH_DSP_VALUEHL
b298			 
b298					if DEBUG_FORTH_WORDS_KEY 
b298						DMARK "UNT" 
b298 f5				push af  
b299 3a ad b2			ld a, (.dmark)  
b29c 32 6b ee			ld (debug_mark),a  
b29f 3a ae b2			ld a, (.dmark+1)  
b2a2 32 6c ee			ld (debug_mark+1),a  
b2a5 3a af b2			ld a, (.dmark+2)  
b2a8 32 6d ee			ld (debug_mark+2),a  
b2ab 18 03			jr .pastdmark  
b2ad ..			.dmark: db "UNT"  
b2b0 f1			.pastdmark: pop af  
b2b1			endm  
# End of macro DMARK
b2b1						CALLMONITOR 
b2b1 cd 6f ee			call debug_vector  
b2b4				endm  
# End of macro CALLMONITOR
b2b4					endif 
b2b4			 
b2b4			;	push hl 
b2b4				FORTH_DSP_POP 
b2b4 cd 1f 9d			call macro_forth_dsp_pop 
b2b7				endm 
# End of macro FORTH_DSP_POP
b2b7			 
b2b7			;	pop hl 
b2b7			 
b2b7				; test if true 
b2b7			 
b2b7 cd 04 8d			call ishlzero 
b2ba			;	ld a,l 
b2ba			;	add h 
b2ba			; 
b2ba			;	cp 0 
b2ba			 
b2ba 20 3e			jr nz, .untilnotdone 
b2bc			 
b2bc					if DEBUG_FORTH_WORDS 
b2bc						DMARK "UNf" 
b2bc f5				push af  
b2bd 3a d1 b2			ld a, (.dmark)  
b2c0 32 6b ee			ld (debug_mark),a  
b2c3 3a d2 b2			ld a, (.dmark+1)  
b2c6 32 6c ee			ld (debug_mark+1),a  
b2c9 3a d3 b2			ld a, (.dmark+2)  
b2cc 32 6d ee			ld (debug_mark+2),a  
b2cf 18 03			jr .pastdmark  
b2d1 ..			.dmark: db "UNf"  
b2d4 f1			.pastdmark: pop af  
b2d5			endm  
# End of macro DMARK
b2d5						CALLMONITOR 
b2d5 cd 6f ee			call debug_vector  
b2d8				endm  
# End of macro CALLMONITOR
b2d8					endif 
b2d8			 
b2d8			 
b2d8			 
b2d8				FORTH_RSP_POP     ; get rid of DO ptr 
b2d8 cd 2a 9a			call macro_forth_rsp_pop 
b2db				endm 
# End of macro FORTH_RSP_POP
b2db			 
b2db			if DEBUG_FORTH_WORDS 
b2db						DMARK "UN>" 
b2db f5				push af  
b2dc 3a f0 b2			ld a, (.dmark)  
b2df 32 6b ee			ld (debug_mark),a  
b2e2 3a f1 b2			ld a, (.dmark+1)  
b2e5 32 6c ee			ld (debug_mark+1),a  
b2e8 3a f2 b2			ld a, (.dmark+2)  
b2eb 32 6d ee			ld (debug_mark+2),a  
b2ee 18 03			jr .pastdmark  
b2f0 ..			.dmark: db "UN>"  
b2f3 f1			.pastdmark: pop af  
b2f4			endm  
# End of macro DMARK
b2f4				CALLMONITOR 
b2f4 cd 6f ee			call debug_vector  
b2f7				endm  
# End of macro CALLMONITOR
b2f7			endif 
b2f7			 
b2f7					NEXTW 
b2f7 c3 1d 9e			jp macro_next 
b2fa				endm 
# End of macro NEXTW
b2fa				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b2fa			 
b2fa			.untilnotdone: 
b2fa			 
b2fa			 
b2fa			;	; get DO ptr 
b2fa			; 
b2fa				FORTH_RSP_TOS 
b2fa cd 20 9a			call macro_forth_rsp_tos 
b2fd				endm 
# End of macro FORTH_RSP_TOS
b2fd			 
b2fd				;push hl 
b2fd			 
b2fd				; not going to DO any more 
b2fd				; get rid of the RSP pointer as DO will add it back in 
b2fd				;FORTH_RSP_POP 
b2fd				;pop hl 
b2fd			 
b2fd			 
b2fd 22 c2 e5			ld (os_tok_ptr), hl 
b300					if DEBUG_FORTH_WORDS 
b300						DMARK "UN<" 
b300 f5				push af  
b301 3a 15 b3			ld a, (.dmark)  
b304 32 6b ee			ld (debug_mark),a  
b307 3a 16 b3			ld a, (.dmark+1)  
b30a 32 6c ee			ld (debug_mark+1),a  
b30d 3a 17 b3			ld a, (.dmark+2)  
b310 32 6d ee			ld (debug_mark+2),a  
b313 18 03			jr .pastdmark  
b315 ..			.dmark: db "UN<"  
b318 f1			.pastdmark: pop af  
b319			endm  
# End of macro DMARK
b319					CALLMONITOR 
b319 cd 6f ee			call debug_vector  
b31c				endm  
# End of macro CALLMONITOR
b31c				endif 
b31c c3 ae 9e			jp exec1 
b31f			 
b31f					 
b31f			 
b31f			 
b31f					NEXTW 
b31f c3 1d 9e			jp macro_next 
b322				endm 
# End of macro NEXTW
b322			 
b322			 
b322			.ENDFLOW: 
b322			 
b322			; eof 
b322			 
# End of file forth_words_flow.asm
b322			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b322			include "forth_words_logic.asm" 
b322			 
b322			; | ## Logic Words 
b322			 
b322			.NOT: 
b322				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b322 2d				db WORD_SYS_CORE+25             
b323 6a b3			dw .IS            
b325 04				db 3 + 1 
b326 .. 00			db "NOT",0              
b32a				endm 
# End of macro CWHEAD
b32a			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b32a					if DEBUG_FORTH_WORDS_KEY 
b32a						DMARK "NOT" 
b32a f5				push af  
b32b 3a 3f b3			ld a, (.dmark)  
b32e 32 6b ee			ld (debug_mark),a  
b331 3a 40 b3			ld a, (.dmark+1)  
b334 32 6c ee			ld (debug_mark+1),a  
b337 3a 41 b3			ld a, (.dmark+2)  
b33a 32 6d ee			ld (debug_mark+2),a  
b33d 18 03			jr .pastdmark  
b33f ..			.dmark: db "NOT"  
b342 f1			.pastdmark: pop af  
b343			endm  
# End of macro DMARK
b343						CALLMONITOR 
b343 cd 6f ee			call debug_vector  
b346				endm  
# End of macro CALLMONITOR
b346					endif 
b346					FORTH_DSP 
b346 cd 2d 9c			call macro_forth_dsp 
b349				endm 
# End of macro FORTH_DSP
b349 7e					ld a,(hl)	; get type of value on TOS 
b34a fe 02				cp DS_TYPE_INUM  
b34c 28 03				jr z, .noti 
b34e					NEXTW 
b34e c3 1d 9e			jp macro_next 
b351				endm 
# End of macro NEXTW
b351			.noti:          FORTH_DSP_VALUEHL 
b351 cd 67 9c			call macro_dsp_valuehl 
b354				endm 
# End of macro FORTH_DSP_VALUEHL
b354			;		push hl 
b354					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b354 cd 1f 9d			call macro_forth_dsp_pop 
b357				endm 
# End of macro FORTH_DSP_POP
b357			;		pop hl 
b357 3e 00				ld a,0 
b359 bd					cp l 
b35a 28 04				jr z, .not2t 
b35c 2e 00				ld l, 0 
b35e 18 02				jr .notip 
b360			 
b360 2e ff		.not2t:		ld l, 255 
b362			 
b362 26 00		.notip:		ld h, 0	 
b364			 
b364 cd 62 9a				call forth_push_numhl 
b367					NEXTW 
b367 c3 1d 9e			jp macro_next 
b36a				endm 
# End of macro NEXTW
b36a			 
b36a			.IS: 
b36a				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b36a 2d				db WORD_SYS_CORE+25             
b36b 90 b3			dw .LZERO            
b36d 03				db 2 + 1 
b36e .. 00			db "IS",0              
b371				endm 
# End of macro CWHEAD
b371			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b371					if DEBUG_FORTH_WORDS_KEY 
b371						DMARK "IS." 
b371 f5				push af  
b372 3a 86 b3			ld a, (.dmark)  
b375 32 6b ee			ld (debug_mark),a  
b378 3a 87 b3			ld a, (.dmark+1)  
b37b 32 6c ee			ld (debug_mark+1),a  
b37e 3a 88 b3			ld a, (.dmark+2)  
b381 32 6d ee			ld (debug_mark+2),a  
b384 18 03			jr .pastdmark  
b386 ..			.dmark: db "IS."  
b389 f1			.pastdmark: pop af  
b38a			endm  
# End of macro DMARK
b38a						CALLMONITOR 
b38a cd 6f ee			call debug_vector  
b38d				endm  
# End of macro CALLMONITOR
b38d					endif 
b38d					NEXTW 
b38d c3 1d 9e			jp macro_next 
b390				endm 
# End of macro NEXTW
b390			.LZERO: 
b390				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b390 2d				db WORD_SYS_CORE+25             
b391 9a b3			dw .TZERO            
b393 03				db 2 + 1 
b394 .. 00			db "0<",0              
b397				endm 
# End of macro CWHEAD
b397			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b397					NEXTW 
b397 c3 1d 9e			jp macro_next 
b39a				endm 
# End of macro NEXTW
b39a			.TZERO: 
b39a				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b39a 2e				db WORD_SYS_CORE+26             
b39b e1 b3			dw .LESS            
b39d 03				db 2 + 1 
b39e .. 00			db "0=",0              
b3a1				endm 
# End of macro CWHEAD
b3a1			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b3a1				; TODO add floating point number detection 
b3a1					;v5 FORTH_DSP_VALUE 
b3a1					if DEBUG_FORTH_WORDS_KEY 
b3a1						DMARK "0=." 
b3a1 f5				push af  
b3a2 3a b6 b3			ld a, (.dmark)  
b3a5 32 6b ee			ld (debug_mark),a  
b3a8 3a b7 b3			ld a, (.dmark+1)  
b3ab 32 6c ee			ld (debug_mark+1),a  
b3ae 3a b8 b3			ld a, (.dmark+2)  
b3b1 32 6d ee			ld (debug_mark+2),a  
b3b4 18 03			jr .pastdmark  
b3b6 ..			.dmark: db "0=."  
b3b9 f1			.pastdmark: pop af  
b3ba			endm  
# End of macro DMARK
b3ba						CALLMONITOR 
b3ba cd 6f ee			call debug_vector  
b3bd				endm  
# End of macro CALLMONITOR
b3bd					endif 
b3bd					FORTH_DSP 
b3bd cd 2d 9c			call macro_forth_dsp 
b3c0				endm 
# End of macro FORTH_DSP
b3c0 7e					ld a,(hl)	; get type of value on TOS 
b3c1 fe 02				cp DS_TYPE_INUM  
b3c3 28 00				jr z, .tz_inum 
b3c5			 
b3c5				if FORTH_ENABLE_FLOATMATH 
b3c5					jr .tz_done 
b3c5			 
b3c5				endif 
b3c5					 
b3c5			 
b3c5			.tz_inum: 
b3c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3c5 cd 67 9c			call macro_dsp_valuehl 
b3c8				endm 
# End of macro FORTH_DSP_VALUEHL
b3c8			 
b3c8			;		push hl 
b3c8			 
b3c8					; destroy value TOS 
b3c8			 
b3c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3c8 cd 1f 9d			call macro_forth_dsp_pop 
b3cb				endm 
# End of macro FORTH_DSP_POP
b3cb			 
b3cb			;		pop hl 
b3cb			 
b3cb 3e 00				ld a,0 
b3cd			 
b3cd bd					cp l 
b3ce 20 08				jr nz, .tz_notzero 
b3d0			 
b3d0 bc					cp h 
b3d1			 
b3d1 20 05				jr nz, .tz_notzero 
b3d3			 
b3d3			 
b3d3 21 01 00				ld hl, FORTH_TRUE 
b3d6 18 03				jr .tz_done 
b3d8			 
b3d8 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b3db			 
b3db					; push value back onto stack for another op etc 
b3db			 
b3db			.tz_done: 
b3db cd 62 9a				call forth_push_numhl 
b3de			 
b3de					NEXTW 
b3de c3 1d 9e			jp macro_next 
b3e1				endm 
# End of macro NEXTW
b3e1			.LESS: 
b3e1				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b3e1 2f				db WORD_SYS_CORE+27             
b3e2 4a b4			dw .GT            
b3e4 02				db 1 + 1 
b3e5 .. 00			db "<",0              
b3e7				endm 
# End of macro CWHEAD
b3e7			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b3e7				; TODO add floating point number detection 
b3e7					if DEBUG_FORTH_WORDS_KEY 
b3e7						DMARK "LES" 
b3e7 f5				push af  
b3e8 3a fc b3			ld a, (.dmark)  
b3eb 32 6b ee			ld (debug_mark),a  
b3ee 3a fd b3			ld a, (.dmark+1)  
b3f1 32 6c ee			ld (debug_mark+1),a  
b3f4 3a fe b3			ld a, (.dmark+2)  
b3f7 32 6d ee			ld (debug_mark+2),a  
b3fa 18 03			jr .pastdmark  
b3fc ..			.dmark: db "LES"  
b3ff f1			.pastdmark: pop af  
b400			endm  
# End of macro DMARK
b400						CALLMONITOR 
b400 cd 6f ee			call debug_vector  
b403				endm  
# End of macro CALLMONITOR
b403					endif 
b403					FORTH_DSP 
b403 cd 2d 9c			call macro_forth_dsp 
b406				endm 
# End of macro FORTH_DSP
b406					;v5 FORTH_DSP_VALUE 
b406 7e					ld a,(hl)	; get type of value on TOS 
b407 fe 02				cp DS_TYPE_INUM  
b409 28 00				jr z, .less_inum 
b40b			 
b40b				if FORTH_ENABLE_FLOATMATH 
b40b					jr .less_done 
b40b			 
b40b				endif 
b40b					 
b40b			 
b40b			.less_inum: 
b40b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b40b cd 67 9c			call macro_dsp_valuehl 
b40e				endm 
# End of macro FORTH_DSP_VALUEHL
b40e			 
b40e e5					push hl  ; u2 
b40f			 
b40f					; destroy value TOS 
b40f			 
b40f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b40f cd 1f 9d			call macro_forth_dsp_pop 
b412				endm 
# End of macro FORTH_DSP_POP
b412			 
b412			 
b412					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b412 cd 67 9c			call macro_dsp_valuehl 
b415				endm 
# End of macro FORTH_DSP_VALUEHL
b415			 
b415 e5					push hl    ; u1 
b416			 
b416					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b416 cd 1f 9d			call macro_forth_dsp_pop 
b419				endm 
# End of macro FORTH_DSP_POP
b419			 
b419			 
b419 b7			 or a      ;clear carry flag 
b41a 01 00 00		 ld bc, FORTH_FALSE 
b41d e1			  pop hl    ; u1 
b41e d1			  pop de    ; u2 
b41f ed 52		  sbc hl,de 
b421 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b423			 
b423 01 01 00		 ld bc, FORTH_TRUE 
b426			.lscont:  
b426 c5					push bc 
b427 e1					pop hl 
b428			 
b428					if DEBUG_FORTH_WORDS 
b428						DMARK "LT1" 
b428 f5				push af  
b429 3a 3d b4			ld a, (.dmark)  
b42c 32 6b ee			ld (debug_mark),a  
b42f 3a 3e b4			ld a, (.dmark+1)  
b432 32 6c ee			ld (debug_mark+1),a  
b435 3a 3f b4			ld a, (.dmark+2)  
b438 32 6d ee			ld (debug_mark+2),a  
b43b 18 03			jr .pastdmark  
b43d ..			.dmark: db "LT1"  
b440 f1			.pastdmark: pop af  
b441			endm  
# End of macro DMARK
b441						CALLMONITOR 
b441 cd 6f ee			call debug_vector  
b444				endm  
# End of macro CALLMONITOR
b444					endif 
b444 cd 62 9a				call forth_push_numhl 
b447			 
b447					NEXTW 
b447 c3 1d 9e			jp macro_next 
b44a				endm 
# End of macro NEXTW
b44a			.GT: 
b44a				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b44a 30				db WORD_SYS_CORE+28             
b44b b3 b4			dw .EQUAL            
b44d 02				db 1 + 1 
b44e .. 00			db ">",0              
b450				endm 
# End of macro CWHEAD
b450			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b450				; TODO add floating point number detection 
b450					if DEBUG_FORTH_WORDS_KEY 
b450						DMARK "GRT" 
b450 f5				push af  
b451 3a 65 b4			ld a, (.dmark)  
b454 32 6b ee			ld (debug_mark),a  
b457 3a 66 b4			ld a, (.dmark+1)  
b45a 32 6c ee			ld (debug_mark+1),a  
b45d 3a 67 b4			ld a, (.dmark+2)  
b460 32 6d ee			ld (debug_mark+2),a  
b463 18 03			jr .pastdmark  
b465 ..			.dmark: db "GRT"  
b468 f1			.pastdmark: pop af  
b469			endm  
# End of macro DMARK
b469						CALLMONITOR 
b469 cd 6f ee			call debug_vector  
b46c				endm  
# End of macro CALLMONITOR
b46c					endif 
b46c					FORTH_DSP 
b46c cd 2d 9c			call macro_forth_dsp 
b46f				endm 
# End of macro FORTH_DSP
b46f					;FORTH_DSP_VALUE 
b46f 7e					ld a,(hl)	; get type of value on TOS 
b470 fe 02				cp DS_TYPE_INUM  
b472 28 00				jr z, .gt_inum 
b474			 
b474				if FORTH_ENABLE_FLOATMATH 
b474					jr .gt_done 
b474			 
b474				endif 
b474					 
b474			 
b474			.gt_inum: 
b474					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b474 cd 67 9c			call macro_dsp_valuehl 
b477				endm 
# End of macro FORTH_DSP_VALUEHL
b477			 
b477 e5					push hl  ; u2 
b478			 
b478					; destroy value TOS 
b478			 
b478					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b478 cd 1f 9d			call macro_forth_dsp_pop 
b47b				endm 
# End of macro FORTH_DSP_POP
b47b			 
b47b			 
b47b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b47b cd 67 9c			call macro_dsp_valuehl 
b47e				endm 
# End of macro FORTH_DSP_VALUEHL
b47e			 
b47e e5					push hl    ; u1 
b47f			 
b47f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b47f cd 1f 9d			call macro_forth_dsp_pop 
b482				endm 
# End of macro FORTH_DSP_POP
b482			 
b482			 
b482 b7			 or a      ;clear carry flag 
b483 01 00 00		 ld bc, FORTH_FALSE 
b486 e1			  pop hl    ; u1 
b487 d1			  pop de    ; u2 
b488 ed 52		  sbc hl,de 
b48a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b48c			 
b48c 01 01 00		 ld bc, FORTH_TRUE 
b48f			.gtcont:  
b48f c5					push bc 
b490 e1					pop hl 
b491			 
b491					if DEBUG_FORTH_WORDS 
b491						DMARK "GT1" 
b491 f5				push af  
b492 3a a6 b4			ld a, (.dmark)  
b495 32 6b ee			ld (debug_mark),a  
b498 3a a7 b4			ld a, (.dmark+1)  
b49b 32 6c ee			ld (debug_mark+1),a  
b49e 3a a8 b4			ld a, (.dmark+2)  
b4a1 32 6d ee			ld (debug_mark+2),a  
b4a4 18 03			jr .pastdmark  
b4a6 ..			.dmark: db "GT1"  
b4a9 f1			.pastdmark: pop af  
b4aa			endm  
# End of macro DMARK
b4aa						CALLMONITOR 
b4aa cd 6f ee			call debug_vector  
b4ad				endm  
# End of macro CALLMONITOR
b4ad					endif 
b4ad cd 62 9a				call forth_push_numhl 
b4b0			 
b4b0					NEXTW 
b4b0 c3 1d 9e			jp macro_next 
b4b3				endm 
# End of macro NEXTW
b4b3			.EQUAL: 
b4b3				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b4b3 31				db WORD_SYS_CORE+29             
b4b4 1e b5			dw .ENDLOGIC            
b4b6 02				db 1 + 1 
b4b7 .. 00			db "=",0              
b4b9				endm 
# End of macro CWHEAD
b4b9			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b4b9				; TODO add floating point number detection 
b4b9					if DEBUG_FORTH_WORDS_KEY 
b4b9						DMARK "EQ." 
b4b9 f5				push af  
b4ba 3a ce b4			ld a, (.dmark)  
b4bd 32 6b ee			ld (debug_mark),a  
b4c0 3a cf b4			ld a, (.dmark+1)  
b4c3 32 6c ee			ld (debug_mark+1),a  
b4c6 3a d0 b4			ld a, (.dmark+2)  
b4c9 32 6d ee			ld (debug_mark+2),a  
b4cc 18 03			jr .pastdmark  
b4ce ..			.dmark: db "EQ."  
b4d1 f1			.pastdmark: pop af  
b4d2			endm  
# End of macro DMARK
b4d2						CALLMONITOR 
b4d2 cd 6f ee			call debug_vector  
b4d5				endm  
# End of macro CALLMONITOR
b4d5					endif 
b4d5					FORTH_DSP 
b4d5 cd 2d 9c			call macro_forth_dsp 
b4d8				endm 
# End of macro FORTH_DSP
b4d8					;v5 FORTH_DSP_VALUE 
b4d8 7e					ld a,(hl)	; get type of value on TOS 
b4d9 fe 02				cp DS_TYPE_INUM  
b4db 28 00				jr z, .eq_inum 
b4dd			 
b4dd				if FORTH_ENABLE_FLOATMATH 
b4dd					jr .eq_done 
b4dd			 
b4dd				endif 
b4dd					 
b4dd			 
b4dd			.eq_inum: 
b4dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4dd cd 67 9c			call macro_dsp_valuehl 
b4e0				endm 
# End of macro FORTH_DSP_VALUEHL
b4e0			 
b4e0 e5					push hl 
b4e1			 
b4e1					; destroy value TOS 
b4e1			 
b4e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4e1 cd 1f 9d			call macro_forth_dsp_pop 
b4e4				endm 
# End of macro FORTH_DSP_POP
b4e4			 
b4e4			 
b4e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4e4 cd 67 9c			call macro_dsp_valuehl 
b4e7				endm 
# End of macro FORTH_DSP_VALUEHL
b4e7			 
b4e7					; one value on hl get other one back 
b4e7			 
b4e7 e5					push hl 
b4e8			 
b4e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4e8 cd 1f 9d			call macro_forth_dsp_pop 
b4eb				endm 
# End of macro FORTH_DSP_POP
b4eb			 
b4eb 0e 00				ld c, FORTH_FALSE 
b4ed			 
b4ed e1					pop hl 
b4ee d1					pop de 
b4ef			 
b4ef 7b					ld a, e 
b4f0 bd					cp l 
b4f1			 
b4f1 20 06				jr nz, .eq_done 
b4f3			 
b4f3 7a					ld a, d 
b4f4 bc					cp h 
b4f5			 
b4f5 20 02				jr nz, .eq_done 
b4f7			 
b4f7 0e 01				ld c, FORTH_TRUE 
b4f9					 
b4f9			 
b4f9			 
b4f9			.eq_done: 
b4f9			 
b4f9					; TODO push value back onto stack for another op etc 
b4f9			 
b4f9 26 00				ld h, 0 
b4fb 69					ld l, c 
b4fc					if DEBUG_FORTH_WORDS 
b4fc						DMARK "EQ1" 
b4fc f5				push af  
b4fd 3a 11 b5			ld a, (.dmark)  
b500 32 6b ee			ld (debug_mark),a  
b503 3a 12 b5			ld a, (.dmark+1)  
b506 32 6c ee			ld (debug_mark+1),a  
b509 3a 13 b5			ld a, (.dmark+2)  
b50c 32 6d ee			ld (debug_mark+2),a  
b50f 18 03			jr .pastdmark  
b511 ..			.dmark: db "EQ1"  
b514 f1			.pastdmark: pop af  
b515			endm  
# End of macro DMARK
b515						CALLMONITOR 
b515 cd 6f ee			call debug_vector  
b518				endm  
# End of macro CALLMONITOR
b518					endif 
b518 cd 62 9a				call forth_push_numhl 
b51b			 
b51b					NEXTW 
b51b c3 1d 9e			jp macro_next 
b51e				endm 
# End of macro NEXTW
b51e			 
b51e			 
b51e			.ENDLOGIC: 
b51e			; eof 
b51e			 
b51e			 
# End of file forth_words_logic.asm
b51e			include "forth_words_maths.asm" 
b51e			 
b51e			; | ## Maths Words 
b51e			 
b51e			.PLUS:	 
b51e				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b51e 15				db WORD_SYS_CORE+1             
b51f 7c b5			dw .NEG            
b521 02				db 1 + 1 
b522 .. 00			db "+",0              
b524				endm 
# End of macro CWHEAD
b524			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b524					if DEBUG_FORTH_WORDS_KEY 
b524						DMARK "PLU" 
b524 f5				push af  
b525 3a 39 b5			ld a, (.dmark)  
b528 32 6b ee			ld (debug_mark),a  
b52b 3a 3a b5			ld a, (.dmark+1)  
b52e 32 6c ee			ld (debug_mark+1),a  
b531 3a 3b b5			ld a, (.dmark+2)  
b534 32 6d ee			ld (debug_mark+2),a  
b537 18 03			jr .pastdmark  
b539 ..			.dmark: db "PLU"  
b53c f1			.pastdmark: pop af  
b53d			endm  
# End of macro DMARK
b53d						CALLMONITOR 
b53d cd 6f ee			call debug_vector  
b540				endm  
# End of macro CALLMONITOR
b540					endif 
b540					; add top two values and push back result 
b540			 
b540					;for v5 FORTH_DSP_VALUE 
b540					FORTH_DSP 
b540 cd 2d 9c			call macro_forth_dsp 
b543				endm 
# End of macro FORTH_DSP
b543 7e					ld a,(hl)	; get type of value on TOS 
b544 fe 02				cp DS_TYPE_INUM  
b546 28 03				jr z, .dot_inum 
b548			 
b548					NEXTW 
b548 c3 1d 9e			jp macro_next 
b54b				endm 
# End of macro NEXTW
b54b			 
b54b			; float maths 
b54b			 
b54b				if FORTH_ENABLE_FLOATMATH 
b54b						inc hl      ; now at start of numeric as string 
b54b			 
b54b					if DEBUG_FORTH_MATHS 
b54b						DMARK "ADD" 
b54b				CALLMONITOR 
b54b					endif 
b54b			 
b54b					;ld ix, hl 
b54b					call CON 
b54b			 
b54b			 
b54b					push hl 
b54b					 
b54b					 
b54b			 
b54b						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b54b			 
b54b					; get next number 
b54b			 
b54b						FORTH_DSP_VALUE 
b54b			 
b54b						inc hl      ; now at start of numeric as string 
b54b			 
b54b					;ld ix, hl 
b54b					call CON 
b54b			 
b54b					push hl 
b54b			 
b54b			 
b54b						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b54b			 
b54b						; TODO do add 
b54b			 
b54b						call IADD 
b54b			 
b54b						; TODO get result back as ascii 
b54b			 
b54b						; TODO push result  
b54b			 
b54b			 
b54b			 
b54b						jr .dot_done 
b54b				endif 
b54b			 
b54b			.dot_inum: 
b54b			 
b54b			 
b54b					if DEBUG_FORTH_DOT 
b54b						DMARK "+IT" 
b54b f5				push af  
b54c 3a 60 b5			ld a, (.dmark)  
b54f 32 6b ee			ld (debug_mark),a  
b552 3a 61 b5			ld a, (.dmark+1)  
b555 32 6c ee			ld (debug_mark+1),a  
b558 3a 62 b5			ld a, (.dmark+2)  
b55b 32 6d ee			ld (debug_mark+2),a  
b55e 18 03			jr .pastdmark  
b560 ..			.dmark: db "+IT"  
b563 f1			.pastdmark: pop af  
b564			endm  
# End of macro DMARK
b564				CALLMONITOR 
b564 cd 6f ee			call debug_vector  
b567				endm  
# End of macro CALLMONITOR
b567					endif 
b567			 
b567					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b567 cd 67 9c			call macro_dsp_valuehl 
b56a				endm 
# End of macro FORTH_DSP_VALUEHL
b56a			 
b56a				; TODO add floating point number detection 
b56a			 
b56a e5					push hl 
b56b			 
b56b					; destroy value TOS 
b56b			 
b56b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b56b cd 1f 9d			call macro_forth_dsp_pop 
b56e				endm 
# End of macro FORTH_DSP_POP
b56e			 
b56e			 
b56e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b56e cd 67 9c			call macro_dsp_valuehl 
b571				endm 
# End of macro FORTH_DSP_VALUEHL
b571			 
b571					; one value on hl get other one back 
b571			 
b571 d1					pop de 
b572			 
b572					; do the add 
b572			 
b572 19					add hl,de 
b573			 
b573					; save it 
b573			 
b573			;		push hl	 
b573			 
b573					; 
b573			 
b573					; destroy value TOS 
b573			 
b573					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b573 cd 1f 9d			call macro_forth_dsp_pop 
b576				endm 
# End of macro FORTH_DSP_POP
b576			 
b576					; TODO push value back onto stack for another op etc 
b576			 
b576			;		pop hl 
b576			 
b576			.dot_done: 
b576 cd 62 9a				call forth_push_numhl 
b579			 
b579					NEXTW 
b579 c3 1d 9e			jp macro_next 
b57c				endm 
# End of macro NEXTW
b57c			.NEG: 
b57c			 
b57c				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b57c 17				db WORD_SYS_CORE+3             
b57d bf b5			dw .DIV            
b57f 02				db 1 + 1 
b580 .. 00			db "-",0              
b582				endm 
# End of macro CWHEAD
b582			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b582					if DEBUG_FORTH_WORDS_KEY 
b582						DMARK "SUB" 
b582 f5				push af  
b583 3a 97 b5			ld a, (.dmark)  
b586 32 6b ee			ld (debug_mark),a  
b589 3a 98 b5			ld a, (.dmark+1)  
b58c 32 6c ee			ld (debug_mark+1),a  
b58f 3a 99 b5			ld a, (.dmark+2)  
b592 32 6d ee			ld (debug_mark+2),a  
b595 18 03			jr .pastdmark  
b597 ..			.dmark: db "SUB"  
b59a f1			.pastdmark: pop af  
b59b			endm  
# End of macro DMARK
b59b						CALLMONITOR 
b59b cd 6f ee			call debug_vector  
b59e				endm  
# End of macro CALLMONITOR
b59e					endif 
b59e			 
b59e			 
b59e				; TODO add floating point number detection 
b59e					; v5 FORTH_DSP_VALUE 
b59e					FORTH_DSP 
b59e cd 2d 9c			call macro_forth_dsp 
b5a1				endm 
# End of macro FORTH_DSP
b5a1 7e					ld a,(hl)	; get type of value on TOS 
b5a2 fe 02				cp DS_TYPE_INUM  
b5a4 28 03				jr z, .neg_inum 
b5a6			 
b5a6					NEXTW 
b5a6 c3 1d 9e			jp macro_next 
b5a9				endm 
# End of macro NEXTW
b5a9			 
b5a9			; float maths 
b5a9			 
b5a9				if FORTH_ENABLE_FLOATMATH 
b5a9					jr .neg_done 
b5a9			 
b5a9				endif 
b5a9					 
b5a9			 
b5a9			.neg_inum: 
b5a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a9 cd 67 9c			call macro_dsp_valuehl 
b5ac				endm 
# End of macro FORTH_DSP_VALUEHL
b5ac			 
b5ac e5					push hl 
b5ad			 
b5ad					; destroy value TOS 
b5ad			 
b5ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5ad cd 1f 9d			call macro_forth_dsp_pop 
b5b0				endm 
# End of macro FORTH_DSP_POP
b5b0			 
b5b0			 
b5b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5b0 cd 67 9c			call macro_dsp_valuehl 
b5b3				endm 
# End of macro FORTH_DSP_VALUEHL
b5b3			 
b5b3					; one value on hl get other one back 
b5b3			 
b5b3 d1					pop de 
b5b4			 
b5b4					; do the sub 
b5b4			;		ex de, hl 
b5b4			 
b5b4 ed 52				sbc hl,de 
b5b6			 
b5b6					; save it 
b5b6			 
b5b6			;		push hl	 
b5b6			 
b5b6					; 
b5b6			 
b5b6					; destroy value TOS 
b5b6			 
b5b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5b6 cd 1f 9d			call macro_forth_dsp_pop 
b5b9				endm 
# End of macro FORTH_DSP_POP
b5b9			 
b5b9					; TODO push value back onto stack for another op etc 
b5b9			 
b5b9			;		pop hl 
b5b9			 
b5b9 cd 62 9a				call forth_push_numhl 
b5bc			.neg_done: 
b5bc			 
b5bc					NEXTW 
b5bc c3 1d 9e			jp macro_next 
b5bf				endm 
# End of macro NEXTW
b5bf			.DIV: 
b5bf				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b5bf 18				db WORD_SYS_CORE+4             
b5c0 0c b6			dw .MUL            
b5c2 02				db 1 + 1 
b5c3 .. 00			db "/",0              
b5c5				endm 
# End of macro CWHEAD
b5c5			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b5c5					if DEBUG_FORTH_WORDS_KEY 
b5c5						DMARK "DIV" 
b5c5 f5				push af  
b5c6 3a da b5			ld a, (.dmark)  
b5c9 32 6b ee			ld (debug_mark),a  
b5cc 3a db b5			ld a, (.dmark+1)  
b5cf 32 6c ee			ld (debug_mark+1),a  
b5d2 3a dc b5			ld a, (.dmark+2)  
b5d5 32 6d ee			ld (debug_mark+2),a  
b5d8 18 03			jr .pastdmark  
b5da ..			.dmark: db "DIV"  
b5dd f1			.pastdmark: pop af  
b5de			endm  
# End of macro DMARK
b5de						CALLMONITOR 
b5de cd 6f ee			call debug_vector  
b5e1				endm  
# End of macro CALLMONITOR
b5e1					endif 
b5e1				; TODO add floating point number detection 
b5e1					; v5 FORTH_DSP_VALUE 
b5e1					FORTH_DSP 
b5e1 cd 2d 9c			call macro_forth_dsp 
b5e4				endm 
# End of macro FORTH_DSP
b5e4 7e					ld a,(hl)	; get type of value on TOS 
b5e5 fe 02				cp DS_TYPE_INUM  
b5e7 28 03				jr z, .div_inum 
b5e9			 
b5e9				if FORTH_ENABLE_FLOATMATH 
b5e9					jr .div_done 
b5e9			 
b5e9				endif 
b5e9					NEXTW 
b5e9 c3 1d 9e			jp macro_next 
b5ec				endm 
# End of macro NEXTW
b5ec			.div_inum: 
b5ec			 
b5ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5ec cd 67 9c			call macro_dsp_valuehl 
b5ef				endm 
# End of macro FORTH_DSP_VALUEHL
b5ef			 
b5ef e5					push hl    ; to go to bc 
b5f0			 
b5f0					; destroy value TOS 
b5f0			 
b5f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5f0 cd 1f 9d			call macro_forth_dsp_pop 
b5f3				endm 
# End of macro FORTH_DSP_POP
b5f3			 
b5f3			 
b5f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5f3 cd 67 9c			call macro_dsp_valuehl 
b5f6				endm 
# End of macro FORTH_DSP_VALUEHL
b5f6			 
b5f6					; hl to go to de 
b5f6			 
b5f6 e5					push hl 
b5f7			 
b5f7 c1					pop bc 
b5f8 d1					pop de		 
b5f9			 
b5f9			 
b5f9					if DEBUG_FORTH_MATHS 
b5f9						DMARK "DIV" 
b5f9				CALLMONITOR 
b5f9					endif 
b5f9					; one value on hl but move to a get other one back 
b5f9			 
b5f9			        
b5f9 cd 38 8c			call Div16 
b5fc			 
b5fc			;	push af	 
b5fc e5				push hl 
b5fd c5				push bc 
b5fe			 
b5fe					if DEBUG_FORTH_MATHS 
b5fe						DMARK "DI1" 
b5fe				CALLMONITOR 
b5fe					endif 
b5fe			 
b5fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5fe cd 1f 9d			call macro_forth_dsp_pop 
b601				endm 
# End of macro FORTH_DSP_POP
b601			 
b601			 
b601			 
b601 e1					pop hl    ; result 
b602			 
b602 cd 62 9a				call forth_push_numhl 
b605			 
b605 e1					pop hl    ; reminder 
b606			;		ld h,0 
b606			;		ld l,d 
b606			 
b606 cd 62 9a				call forth_push_numhl 
b609			.div_done: 
b609					NEXTW 
b609 c3 1d 9e			jp macro_next 
b60c				endm 
# End of macro NEXTW
b60c			.MUL: 
b60c				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b60c 19				db WORD_SYS_CORE+5             
b60d 51 b6			dw .MIN            
b60f 02				db 1 + 1 
b610 .. 00			db "*",0              
b612				endm 
# End of macro CWHEAD
b612			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b612				; TODO add floating point number detection 
b612					if DEBUG_FORTH_WORDS_KEY 
b612						DMARK "MUL" 
b612 f5				push af  
b613 3a 27 b6			ld a, (.dmark)  
b616 32 6b ee			ld (debug_mark),a  
b619 3a 28 b6			ld a, (.dmark+1)  
b61c 32 6c ee			ld (debug_mark+1),a  
b61f 3a 29 b6			ld a, (.dmark+2)  
b622 32 6d ee			ld (debug_mark+2),a  
b625 18 03			jr .pastdmark  
b627 ..			.dmark: db "MUL"  
b62a f1			.pastdmark: pop af  
b62b			endm  
# End of macro DMARK
b62b						CALLMONITOR 
b62b cd 6f ee			call debug_vector  
b62e				endm  
# End of macro CALLMONITOR
b62e					endif 
b62e					FORTH_DSP 
b62e cd 2d 9c			call macro_forth_dsp 
b631				endm 
# End of macro FORTH_DSP
b631					; v5 FORTH_DSP_VALUE 
b631 7e					ld a,(hl)	; get type of value on TOS 
b632 fe 02				cp DS_TYPE_INUM  
b634 28 03				jr z, .mul_inum 
b636			 
b636				if FORTH_ENABLE_FLOATMATH 
b636					jr .mul_done 
b636			 
b636				endif 
b636			 
b636					NEXTW 
b636 c3 1d 9e			jp macro_next 
b639				endm 
# End of macro NEXTW
b639			.mul_inum:	 
b639			 
b639					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b639 cd 67 9c			call macro_dsp_valuehl 
b63c				endm 
# End of macro FORTH_DSP_VALUEHL
b63c			 
b63c e5					push hl 
b63d			 
b63d					; destroy value TOS 
b63d			 
b63d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b63d cd 1f 9d			call macro_forth_dsp_pop 
b640				endm 
# End of macro FORTH_DSP_POP
b640			 
b640			 
b640					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b640 cd 67 9c			call macro_dsp_valuehl 
b643				endm 
# End of macro FORTH_DSP_VALUEHL
b643			 
b643					; one value on hl but move to a get other one back 
b643			 
b643 7d					ld a, l 
b644			 
b644 d1					pop de 
b645			 
b645					; do the mull 
b645			;		ex de, hl 
b645			 
b645 cd 5e 8c				call Mult16 
b648					; save it 
b648			 
b648			;		push hl	 
b648			 
b648					; 
b648			 
b648					; destroy value TOS 
b648			 
b648					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b648 cd 1f 9d			call macro_forth_dsp_pop 
b64b				endm 
# End of macro FORTH_DSP_POP
b64b			 
b64b					; TODO push value back onto stack for another op etc 
b64b			 
b64b			;		pop hl 
b64b			 
b64b cd 62 9a				call forth_push_numhl 
b64e			 
b64e			.mul_done: 
b64e					NEXTW 
b64e c3 1d 9e			jp macro_next 
b651				endm 
# End of macro NEXTW
b651			 
b651			 
b651			 
b651			 
b651			.MIN: 
b651				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b651 49				db WORD_SYS_CORE+53             
b652 d2 b6			dw .MAX            
b654 04				db 3 + 1 
b655 .. 00			db "MIN",0              
b659				endm 
# End of macro CWHEAD
b659			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b659					if DEBUG_FORTH_WORDS_KEY 
b659						DMARK "MIN" 
b659 f5				push af  
b65a 3a 6e b6			ld a, (.dmark)  
b65d 32 6b ee			ld (debug_mark),a  
b660 3a 6f b6			ld a, (.dmark+1)  
b663 32 6c ee			ld (debug_mark+1),a  
b666 3a 70 b6			ld a, (.dmark+2)  
b669 32 6d ee			ld (debug_mark+2),a  
b66c 18 03			jr .pastdmark  
b66e ..			.dmark: db "MIN"  
b671 f1			.pastdmark: pop af  
b672			endm  
# End of macro DMARK
b672						CALLMONITOR 
b672 cd 6f ee			call debug_vector  
b675				endm  
# End of macro CALLMONITOR
b675					endif 
b675					; get u2 
b675			 
b675					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b675 cd 67 9c			call macro_dsp_valuehl 
b678				endm 
# End of macro FORTH_DSP_VALUEHL
b678			 
b678 e5					push hl   ; u2 
b679			 
b679					; destroy value TOS 
b679			 
b679					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b679 cd 1f 9d			call macro_forth_dsp_pop 
b67c				endm 
# End of macro FORTH_DSP_POP
b67c			 
b67c					; get u1 
b67c			 
b67c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b67c cd 67 9c			call macro_dsp_valuehl 
b67f				endm 
# End of macro FORTH_DSP_VALUEHL
b67f			 
b67f e5					push hl  ; u1 
b680			 
b680					; destroy value TOS 
b680			 
b680					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b680 cd 1f 9d			call macro_forth_dsp_pop 
b683				endm 
# End of macro FORTH_DSP_POP
b683			 
b683 b7			 or a      ;clear carry flag 
b684 e1			  pop hl    ; u1 
b685 d1			  pop de    ; u2 
b686 e5				push hl   ; saved in case hl is lowest 
b687 ed 52		  sbc hl,de 
b689 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b68b			 
b68b e1				pop hl 
b68c					if DEBUG_FORTH_WORDS 
b68c						DMARK "MIN" 
b68c f5				push af  
b68d 3a a1 b6			ld a, (.dmark)  
b690 32 6b ee			ld (debug_mark),a  
b693 3a a2 b6			ld a, (.dmark+1)  
b696 32 6c ee			ld (debug_mark+1),a  
b699 3a a3 b6			ld a, (.dmark+2)  
b69c 32 6d ee			ld (debug_mark+2),a  
b69f 18 03			jr .pastdmark  
b6a1 ..			.dmark: db "MIN"  
b6a4 f1			.pastdmark: pop af  
b6a5			endm  
# End of macro DMARK
b6a5						CALLMONITOR 
b6a5 cd 6f ee			call debug_vector  
b6a8				endm  
# End of macro CALLMONITOR
b6a8					endif 
b6a8 cd 62 9a				call forth_push_numhl 
b6ab			 
b6ab				       NEXTW 
b6ab c3 1d 9e			jp macro_next 
b6ae				endm 
# End of macro NEXTW
b6ae			 
b6ae			.mincont:  
b6ae c1				pop bc   ; tidy up 
b6af eb				ex de , hl  
b6b0					if DEBUG_FORTH_WORDS 
b6b0						DMARK "MI1" 
b6b0 f5				push af  
b6b1 3a c5 b6			ld a, (.dmark)  
b6b4 32 6b ee			ld (debug_mark),a  
b6b7 3a c6 b6			ld a, (.dmark+1)  
b6ba 32 6c ee			ld (debug_mark+1),a  
b6bd 3a c7 b6			ld a, (.dmark+2)  
b6c0 32 6d ee			ld (debug_mark+2),a  
b6c3 18 03			jr .pastdmark  
b6c5 ..			.dmark: db "MI1"  
b6c8 f1			.pastdmark: pop af  
b6c9			endm  
# End of macro DMARK
b6c9						CALLMONITOR 
b6c9 cd 6f ee			call debug_vector  
b6cc				endm  
# End of macro CALLMONITOR
b6cc					endif 
b6cc cd 62 9a				call forth_push_numhl 
b6cf			 
b6cf				       NEXTW 
b6cf c3 1d 9e			jp macro_next 
b6d2				endm 
# End of macro NEXTW
b6d2			.MAX: 
b6d2				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b6d2 4a				db WORD_SYS_CORE+54             
b6d3 53 b7			dw .RND16            
b6d5 04				db 3 + 1 
b6d6 .. 00			db "MAX",0              
b6da				endm 
# End of macro CWHEAD
b6da			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b6da					if DEBUG_FORTH_WORDS_KEY 
b6da						DMARK "MAX" 
b6da f5				push af  
b6db 3a ef b6			ld a, (.dmark)  
b6de 32 6b ee			ld (debug_mark),a  
b6e1 3a f0 b6			ld a, (.dmark+1)  
b6e4 32 6c ee			ld (debug_mark+1),a  
b6e7 3a f1 b6			ld a, (.dmark+2)  
b6ea 32 6d ee			ld (debug_mark+2),a  
b6ed 18 03			jr .pastdmark  
b6ef ..			.dmark: db "MAX"  
b6f2 f1			.pastdmark: pop af  
b6f3			endm  
# End of macro DMARK
b6f3						CALLMONITOR 
b6f3 cd 6f ee			call debug_vector  
b6f6				endm  
# End of macro CALLMONITOR
b6f6					endif 
b6f6					; get u2 
b6f6			 
b6f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6f6 cd 67 9c			call macro_dsp_valuehl 
b6f9				endm 
# End of macro FORTH_DSP_VALUEHL
b6f9			 
b6f9 e5					push hl   ; u2 
b6fa			 
b6fa					; destroy value TOS 
b6fa			 
b6fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6fa cd 1f 9d			call macro_forth_dsp_pop 
b6fd				endm 
# End of macro FORTH_DSP_POP
b6fd			 
b6fd					; get u1 
b6fd			 
b6fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6fd cd 67 9c			call macro_dsp_valuehl 
b700				endm 
# End of macro FORTH_DSP_VALUEHL
b700			 
b700 e5					push hl  ; u1 
b701			 
b701					; destroy value TOS 
b701			 
b701					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b701 cd 1f 9d			call macro_forth_dsp_pop 
b704				endm 
# End of macro FORTH_DSP_POP
b704			 
b704 b7			 or a      ;clear carry flag 
b705 e1			  pop hl    ; u1 
b706 d1			  pop de    ; u2 
b707 e5				push hl   ; saved in case hl is lowest 
b708 ed 52		  sbc hl,de 
b70a 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b70c			 
b70c e1				pop hl 
b70d					if DEBUG_FORTH_WORDS 
b70d						DMARK "MAX" 
b70d f5				push af  
b70e 3a 22 b7			ld a, (.dmark)  
b711 32 6b ee			ld (debug_mark),a  
b714 3a 23 b7			ld a, (.dmark+1)  
b717 32 6c ee			ld (debug_mark+1),a  
b71a 3a 24 b7			ld a, (.dmark+2)  
b71d 32 6d ee			ld (debug_mark+2),a  
b720 18 03			jr .pastdmark  
b722 ..			.dmark: db "MAX"  
b725 f1			.pastdmark: pop af  
b726			endm  
# End of macro DMARK
b726						CALLMONITOR 
b726 cd 6f ee			call debug_vector  
b729				endm  
# End of macro CALLMONITOR
b729					endif 
b729 cd 62 9a				call forth_push_numhl 
b72c			 
b72c				       NEXTW 
b72c c3 1d 9e			jp macro_next 
b72f				endm 
# End of macro NEXTW
b72f			 
b72f			.maxcont:  
b72f c1				pop bc   ; tidy up 
b730 eb				ex de , hl  
b731					if DEBUG_FORTH_WORDS 
b731						DMARK "MA1" 
b731 f5				push af  
b732 3a 46 b7			ld a, (.dmark)  
b735 32 6b ee			ld (debug_mark),a  
b738 3a 47 b7			ld a, (.dmark+1)  
b73b 32 6c ee			ld (debug_mark+1),a  
b73e 3a 48 b7			ld a, (.dmark+2)  
b741 32 6d ee			ld (debug_mark+2),a  
b744 18 03			jr .pastdmark  
b746 ..			.dmark: db "MA1"  
b749 f1			.pastdmark: pop af  
b74a			endm  
# End of macro DMARK
b74a						CALLMONITOR 
b74a cd 6f ee			call debug_vector  
b74d				endm  
# End of macro CALLMONITOR
b74d					endif 
b74d cd 62 9a				call forth_push_numhl 
b750				       NEXTW 
b750 c3 1d 9e			jp macro_next 
b753				endm 
# End of macro NEXTW
b753			 
b753			.RND16: 
b753				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b753 4e				db WORD_SYS_CORE+58             
b754 82 b7			dw .RND8            
b756 06				db 5 + 1 
b757 .. 00			db "RND16",0              
b75d				endm 
# End of macro CWHEAD
b75d			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b75d					if DEBUG_FORTH_WORDS_KEY 
b75d						DMARK "R16" 
b75d f5				push af  
b75e 3a 72 b7			ld a, (.dmark)  
b761 32 6b ee			ld (debug_mark),a  
b764 3a 73 b7			ld a, (.dmark+1)  
b767 32 6c ee			ld (debug_mark+1),a  
b76a 3a 74 b7			ld a, (.dmark+2)  
b76d 32 6d ee			ld (debug_mark+2),a  
b770 18 03			jr .pastdmark  
b772 ..			.dmark: db "R16"  
b775 f1			.pastdmark: pop af  
b776			endm  
# End of macro DMARK
b776						CALLMONITOR 
b776 cd 6f ee			call debug_vector  
b779				endm  
# End of macro CALLMONITOR
b779					endif 
b779 cd 02 8c				call prng16  
b77c cd 62 9a				call forth_push_numhl 
b77f				       NEXTW 
b77f c3 1d 9e			jp macro_next 
b782				endm 
# End of macro NEXTW
b782			.RND8: 
b782				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b782 60				db WORD_SYS_CORE+76             
b783 b7 b7			dw .RND            
b785 05				db 4 + 1 
b786 .. 00			db "RND8",0              
b78b				endm 
# End of macro CWHEAD
b78b			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b78b					if DEBUG_FORTH_WORDS_KEY 
b78b						DMARK "RN8" 
b78b f5				push af  
b78c 3a a0 b7			ld a, (.dmark)  
b78f 32 6b ee			ld (debug_mark),a  
b792 3a a1 b7			ld a, (.dmark+1)  
b795 32 6c ee			ld (debug_mark+1),a  
b798 3a a2 b7			ld a, (.dmark+2)  
b79b 32 6d ee			ld (debug_mark+2),a  
b79e 18 03			jr .pastdmark  
b7a0 ..			.dmark: db "RN8"  
b7a3 f1			.pastdmark: pop af  
b7a4			endm  
# End of macro DMARK
b7a4						CALLMONITOR 
b7a4 cd 6f ee			call debug_vector  
b7a7				endm  
# End of macro CALLMONITOR
b7a7					endif 
b7a7 2a a9 eb				ld hl,(xrandc) 
b7aa 23					inc hl 
b7ab cd 1c 8c				call xrnd 
b7ae 6f					ld l,a	 
b7af 26 00				ld h,0 
b7b1 cd 62 9a				call forth_push_numhl 
b7b4				       NEXTW 
b7b4 c3 1d 9e			jp macro_next 
b7b7				endm 
# End of macro NEXTW
b7b7			.RND: 
b7b7				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b7b7 60				db WORD_SYS_CORE+76             
b7b8 bd b8			dw .ENDMATHS            
b7ba 04				db 3 + 1 
b7bb .. 00			db "RND",0              
b7bf				endm 
# End of macro CWHEAD
b7bf			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b7bf			 
b7bf					if DEBUG_FORTH_WORDS_KEY 
b7bf						DMARK "RND" 
b7bf f5				push af  
b7c0 3a d4 b7			ld a, (.dmark)  
b7c3 32 6b ee			ld (debug_mark),a  
b7c6 3a d5 b7			ld a, (.dmark+1)  
b7c9 32 6c ee			ld (debug_mark+1),a  
b7cc 3a d6 b7			ld a, (.dmark+2)  
b7cf 32 6d ee			ld (debug_mark+2),a  
b7d2 18 03			jr .pastdmark  
b7d4 ..			.dmark: db "RND"  
b7d7 f1			.pastdmark: pop af  
b7d8			endm  
# End of macro DMARK
b7d8						CALLMONITOR 
b7d8 cd 6f ee			call debug_vector  
b7db				endm  
# End of macro CALLMONITOR
b7db					endif 
b7db					 
b7db					FORTH_DSP_VALUEHL    ; upper range 
b7db cd 67 9c			call macro_dsp_valuehl 
b7de				endm 
# End of macro FORTH_DSP_VALUEHL
b7de			 
b7de 22 ad eb				ld (LFSRSeed), hl	 
b7e1			 
b7e1					if DEBUG_FORTH_WORDS 
b7e1						DMARK "RN1" 
b7e1 f5				push af  
b7e2 3a f6 b7			ld a, (.dmark)  
b7e5 32 6b ee			ld (debug_mark),a  
b7e8 3a f7 b7			ld a, (.dmark+1)  
b7eb 32 6c ee			ld (debug_mark+1),a  
b7ee 3a f8 b7			ld a, (.dmark+2)  
b7f1 32 6d ee			ld (debug_mark+2),a  
b7f4 18 03			jr .pastdmark  
b7f6 ..			.dmark: db "RN1"  
b7f9 f1			.pastdmark: pop af  
b7fa			endm  
# End of macro DMARK
b7fa						CALLMONITOR 
b7fa cd 6f ee			call debug_vector  
b7fd				endm  
# End of macro CALLMONITOR
b7fd					endif 
b7fd					FORTH_DSP_POP 
b7fd cd 1f 9d			call macro_forth_dsp_pop 
b800				endm 
# End of macro FORTH_DSP_POP
b800			 
b800					FORTH_DSP_VALUEHL    ; low range 
b800 cd 67 9c			call macro_dsp_valuehl 
b803				endm 
# End of macro FORTH_DSP_VALUEHL
b803			 
b803					if DEBUG_FORTH_WORDS 
b803						DMARK "RN2" 
b803 f5				push af  
b804 3a 18 b8			ld a, (.dmark)  
b807 32 6b ee			ld (debug_mark),a  
b80a 3a 19 b8			ld a, (.dmark+1)  
b80d 32 6c ee			ld (debug_mark+1),a  
b810 3a 1a b8			ld a, (.dmark+2)  
b813 32 6d ee			ld (debug_mark+2),a  
b816 18 03			jr .pastdmark  
b818 ..			.dmark: db "RN2"  
b81b f1			.pastdmark: pop af  
b81c			endm  
# End of macro DMARK
b81c						CALLMONITOR 
b81c cd 6f ee			call debug_vector  
b81f				endm  
# End of macro CALLMONITOR
b81f					endif 
b81f 22 af eb				ld (LFSRSeed+2), hl 
b822			 
b822					FORTH_DSP_POP 
b822 cd 1f 9d			call macro_forth_dsp_pop 
b825				endm 
# End of macro FORTH_DSP_POP
b825			 
b825 e5					push hl 
b826			 
b826 e1			.inrange:	pop hl 
b827 cd 02 8c				call prng16  
b82a					if DEBUG_FORTH_WORDS 
b82a						DMARK "RN3" 
b82a f5				push af  
b82b 3a 3f b8			ld a, (.dmark)  
b82e 32 6b ee			ld (debug_mark),a  
b831 3a 40 b8			ld a, (.dmark+1)  
b834 32 6c ee			ld (debug_mark+1),a  
b837 3a 41 b8			ld a, (.dmark+2)  
b83a 32 6d ee			ld (debug_mark+2),a  
b83d 18 03			jr .pastdmark  
b83f ..			.dmark: db "RN3"  
b842 f1			.pastdmark: pop af  
b843			endm  
# End of macro DMARK
b843						CALLMONITOR 
b843 cd 6f ee			call debug_vector  
b846				endm  
# End of macro CALLMONITOR
b846					endif 
b846					 
b846					; if the range is 8bit knock out the high byte 
b846			 
b846 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
b84a			 
b84a 3e 00				ld a, 0 
b84c ba					cp d  
b84d 20 1e				jr nz, .hirange 
b84f 26 00				ld h, 0   ; knock it down to 8bit 
b851			 
b851					if DEBUG_FORTH_WORDS 
b851						DMARK "RNk" 
b851 f5				push af  
b852 3a 66 b8			ld a, (.dmark)  
b855 32 6b ee			ld (debug_mark),a  
b858 3a 67 b8			ld a, (.dmark+1)  
b85b 32 6c ee			ld (debug_mark+1),a  
b85e 3a 68 b8			ld a, (.dmark+2)  
b861 32 6d ee			ld (debug_mark+2),a  
b864 18 03			jr .pastdmark  
b866 ..			.dmark: db "RNk"  
b869 f1			.pastdmark: pop af  
b86a			endm  
# End of macro DMARK
b86a						CALLMONITOR 
b86a cd 6f ee			call debug_vector  
b86d				endm  
# End of macro CALLMONITOR
b86d					endif 
b86d			.hirange:   
b86d e5					push hl  
b86e b7					or a  
b86f ed 52		                sbc hl, de 
b871			 
b871					;call cmp16 
b871			 
b871 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b873 e1					pop hl 
b874 e5					push hl 
b875			 
b875					if DEBUG_FORTH_WORDS 
b875						DMARK "RN4" 
b875 f5				push af  
b876 3a 8a b8			ld a, (.dmark)  
b879 32 6b ee			ld (debug_mark),a  
b87c 3a 8b b8			ld a, (.dmark+1)  
b87f 32 6c ee			ld (debug_mark+1),a  
b882 3a 8c b8			ld a, (.dmark+2)  
b885 32 6d ee			ld (debug_mark+2),a  
b888 18 03			jr .pastdmark  
b88a ..			.dmark: db "RN4"  
b88d f1			.pastdmark: pop af  
b88e			endm  
# End of macro DMARK
b88e						CALLMONITOR 
b88e cd 6f ee			call debug_vector  
b891				endm  
# End of macro CALLMONITOR
b891					endif 
b891 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
b895					;call cmp16 
b895				 
b895 b7					or a  
b896 ed 52		                sbc hl, de 
b898 38 8c				jr c, .inrange 
b89a			 
b89a e1					pop hl 
b89b					 
b89b					if DEBUG_FORTH_WORDS 
b89b						DMARK "RNd" 
b89b f5				push af  
b89c 3a b0 b8			ld a, (.dmark)  
b89f 32 6b ee			ld (debug_mark),a  
b8a2 3a b1 b8			ld a, (.dmark+1)  
b8a5 32 6c ee			ld (debug_mark+1),a  
b8a8 3a b2 b8			ld a, (.dmark+2)  
b8ab 32 6d ee			ld (debug_mark+2),a  
b8ae 18 03			jr .pastdmark  
b8b0 ..			.dmark: db "RNd"  
b8b3 f1			.pastdmark: pop af  
b8b4			endm  
# End of macro DMARK
b8b4						CALLMONITOR 
b8b4 cd 6f ee			call debug_vector  
b8b7				endm  
# End of macro CALLMONITOR
b8b7					endif 
b8b7			 
b8b7			 
b8b7 cd 62 9a				call forth_push_numhl 
b8ba				       NEXTW 
b8ba c3 1d 9e			jp macro_next 
b8bd				endm 
# End of macro NEXTW
b8bd			 
b8bd			.ENDMATHS: 
b8bd			 
b8bd			; eof 
b8bd			 
# End of file forth_words_maths.asm
b8bd			include "forth_words_display.asm" 
b8bd			 
b8bd			; | ## Display Words 
b8bd			 
b8bd			.ACT: 
b8bd			 
b8bd				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b8bd 62				db WORD_SYS_CORE+78             
b8be 09 b9			dw .INFO            
b8c0 07				db 6 + 1 
b8c1 .. 00			db "ACTIVE",0              
b8c8				endm 
# End of macro CWHEAD
b8c8			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b8c8			;  
b8c8			; | | To display a pulsing activity indicator in a processing loop do this... 
b8c8			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
b8c8			 
b8c8					if DEBUG_FORTH_WORDS_KEY 
b8c8						DMARK "ACT" 
b8c8 f5				push af  
b8c9 3a dd b8			ld a, (.dmark)  
b8cc 32 6b ee			ld (debug_mark),a  
b8cf 3a de b8			ld a, (.dmark+1)  
b8d2 32 6c ee			ld (debug_mark+1),a  
b8d5 3a df b8			ld a, (.dmark+2)  
b8d8 32 6d ee			ld (debug_mark+2),a  
b8db 18 03			jr .pastdmark  
b8dd ..			.dmark: db "ACT"  
b8e0 f1			.pastdmark: pop af  
b8e1			endm  
# End of macro DMARK
b8e1						CALLMONITOR 
b8e1 cd 6f ee			call debug_vector  
b8e4				endm  
# End of macro CALLMONITOR
b8e4					endif 
b8e4 cd 05 8a				call active 
b8e7					if DEBUG_FORTH_WORDS 
b8e7						DMARK "ACp" 
b8e7 f5				push af  
b8e8 3a fc b8			ld a, (.dmark)  
b8eb 32 6b ee			ld (debug_mark),a  
b8ee 3a fd b8			ld a, (.dmark+1)  
b8f1 32 6c ee			ld (debug_mark+1),a  
b8f4 3a fe b8			ld a, (.dmark+2)  
b8f7 32 6d ee			ld (debug_mark+2),a  
b8fa 18 03			jr .pastdmark  
b8fc ..			.dmark: db "ACp"  
b8ff f1			.pastdmark: pop af  
b900			endm  
# End of macro DMARK
b900						CALLMONITOR 
b900 cd 6f ee			call debug_vector  
b903				endm  
# End of macro CALLMONITOR
b903					endif 
b903 cd d0 9a				call forth_push_str 
b906			 
b906					NEXTW 
b906 c3 1d 9e			jp macro_next 
b909				endm 
# End of macro NEXTW
b909			.INFO: 
b909			 
b909				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b909 62				db WORD_SYS_CORE+78             
b90a 26 b9			dw .ATP            
b90c 05				db 4 + 1 
b90d .. 00			db "INFO",0              
b912				endm 
# End of macro CWHEAD
b912			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b912					FORTH_DSP_VALUEHL 
b912 cd 67 9c			call macro_dsp_valuehl 
b915				endm 
# End of macro FORTH_DSP_VALUEHL
b915			 
b915					FORTH_DSP_POP 
b915 cd 1f 9d			call macro_forth_dsp_pop 
b918				endm 
# End of macro FORTH_DSP_POP
b918			 
b918 e5					push hl 
b919			 
b919					FORTH_DSP_VALUEHL 
b919 cd 67 9c			call macro_dsp_valuehl 
b91c				endm 
# End of macro FORTH_DSP_VALUEHL
b91c			 
b91c					FORTH_DSP_POP 
b91c cd 1f 9d			call macro_forth_dsp_pop 
b91f				endm 
# End of macro FORTH_DSP_POP
b91f			 
b91f d1					pop de 
b920			 
b920 cd 3f 8a				call info_panel 
b923			 
b923			 
b923					NEXTW 
b923 c3 1d 9e			jp macro_next 
b926				endm 
# End of macro NEXTW
b926			.ATP: 
b926				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b926 62				db WORD_SYS_CORE+78             
b927 9d b9			dw .FB            
b929 04				db 3 + 1 
b92a .. 00			db "AT?",0              
b92e				endm 
# End of macro CWHEAD
b92e			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b92e					if DEBUG_FORTH_WORDS_KEY 
b92e						DMARK "AT?" 
b92e f5				push af  
b92f 3a 43 b9			ld a, (.dmark)  
b932 32 6b ee			ld (debug_mark),a  
b935 3a 44 b9			ld a, (.dmark+1)  
b938 32 6c ee			ld (debug_mark+1),a  
b93b 3a 45 b9			ld a, (.dmark+2)  
b93e 32 6d ee			ld (debug_mark+2),a  
b941 18 03			jr .pastdmark  
b943 ..			.dmark: db "AT?"  
b946 f1			.pastdmark: pop af  
b947			endm  
# End of macro DMARK
b947						CALLMONITOR 
b947 cd 6f ee			call debug_vector  
b94a				endm  
# End of macro CALLMONITOR
b94a					endif 
b94a 3a 5e ea				ld a, (f_cursor_ptr) 
b94d			 
b94d			if DEBUG_FORTH_WORDS 
b94d				DMARK "AT?" 
b94d f5				push af  
b94e 3a 62 b9			ld a, (.dmark)  
b951 32 6b ee			ld (debug_mark),a  
b954 3a 63 b9			ld a, (.dmark+1)  
b957 32 6c ee			ld (debug_mark+1),a  
b95a 3a 64 b9			ld a, (.dmark+2)  
b95d 32 6d ee			ld (debug_mark+2),a  
b960 18 03			jr .pastdmark  
b962 ..			.dmark: db "AT?"  
b965 f1			.pastdmark: pop af  
b966			endm  
# End of macro DMARK
b966				CALLMONITOR 
b966 cd 6f ee			call debug_vector  
b969				endm  
# End of macro CALLMONITOR
b969			endif	 
b969					; count the number of rows 
b969			 
b969 06 00				ld b, 0 
b96b 4f			.atpr:		ld c, a    ; save in case we go below zero 
b96c d6 28				sub display_cols 
b96e f2 74 b9				jp p, .atprunder 
b971 04					inc b 
b972 18 f7				jr .atpr 
b974			.atprunder:	 
b974			if DEBUG_FORTH_WORDS 
b974				DMARK "A?2" 
b974 f5				push af  
b975 3a 89 b9			ld a, (.dmark)  
b978 32 6b ee			ld (debug_mark),a  
b97b 3a 8a b9			ld a, (.dmark+1)  
b97e 32 6c ee			ld (debug_mark+1),a  
b981 3a 8b b9			ld a, (.dmark+2)  
b984 32 6d ee			ld (debug_mark+2),a  
b987 18 03			jr .pastdmark  
b989 ..			.dmark: db "A?2"  
b98c f1			.pastdmark: pop af  
b98d			endm  
# End of macro DMARK
b98d				CALLMONITOR 
b98d cd 6f ee			call debug_vector  
b990				endm  
# End of macro CALLMONITOR
b990			endif	 
b990 26 00				ld h, 0 
b992 69					ld l, c 
b993 cd 62 9a				call forth_push_numhl 
b996 68					ld l, b  
b997 cd 62 9a				call forth_push_numhl 
b99a			 
b99a			 
b99a				NEXTW 
b99a c3 1d 9e			jp macro_next 
b99d				endm 
# End of macro NEXTW
b99d			 
b99d			.FB: 
b99d				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b99d 1b				db WORD_SYS_CORE+7             
b99e eb b9			dw .EMIT            
b9a0 03				db 2 + 1 
b9a1 .. 00			db "FB",0              
b9a4				endm 
# End of macro CWHEAD
b9a4			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b9a4			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b9a4			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b9a4			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b9a4					if DEBUG_FORTH_WORDS_KEY 
b9a4						DMARK "FB." 
b9a4 f5				push af  
b9a5 3a b9 b9			ld a, (.dmark)  
b9a8 32 6b ee			ld (debug_mark),a  
b9ab 3a ba b9			ld a, (.dmark+1)  
b9ae 32 6c ee			ld (debug_mark+1),a  
b9b1 3a bb b9			ld a, (.dmark+2)  
b9b4 32 6d ee			ld (debug_mark+2),a  
b9b7 18 03			jr .pastdmark  
b9b9 ..			.dmark: db "FB."  
b9bc f1			.pastdmark: pop af  
b9bd			endm  
# End of macro DMARK
b9bd						CALLMONITOR 
b9bd cd 6f ee			call debug_vector  
b9c0				endm  
# End of macro CALLMONITOR
b9c0					endif 
b9c0			 
b9c0					FORTH_DSP_VALUEHL 
b9c0 cd 67 9c			call macro_dsp_valuehl 
b9c3				endm 
# End of macro FORTH_DSP_VALUEHL
b9c3			 
b9c3 7d					ld a, l 
b9c4 fe 01				cp 1 
b9c6 20 05				jr nz, .fbn1 
b9c8 21 10 ed				ld hl, display_fb1 
b9cb 18 15				jr .fbset 
b9cd fe 02		.fbn1:		cp 2 
b9cf 20 05				jr nz, .fbn2 
b9d1 21 ce eb				ld hl, display_fb2 
b9d4 18 0c				jr .fbset 
b9d6 fe 03		.fbn2:		cp 3 
b9d8 20 05				jr nz, .fbn3 
b9da 21 6f ec				ld hl, display_fb3 
b9dd 18 03				jr .fbset 
b9df			.fbn3:		 ; if invalid number select first 
b9df 21 10 ed				ld hl, display_fb1 
b9e2 22 cc eb		.fbset:		ld (display_fb_active), hl 
b9e5			 
b9e5					FORTH_DSP_POP 
b9e5 cd 1f 9d			call macro_forth_dsp_pop 
b9e8				endm 
# End of macro FORTH_DSP_POP
b9e8			 
b9e8					NEXTW 
b9e8 c3 1d 9e			jp macro_next 
b9eb				endm 
# End of macro NEXTW
b9eb			 
b9eb			 
b9eb			.EMIT: 
b9eb				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b9eb 1b				db WORD_SYS_CORE+7             
b9ec 3c ba			dw .DOTH            
b9ee 05				db 4 + 1 
b9ef .. 00			db "EMIT",0              
b9f4				endm 
# End of macro CWHEAD
b9f4			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b9f4					; get value off TOS and display it 
b9f4			 
b9f4					if DEBUG_FORTH_WORDS_KEY 
b9f4						DMARK "EMT" 
b9f4 f5				push af  
b9f5 3a 09 ba			ld a, (.dmark)  
b9f8 32 6b ee			ld (debug_mark),a  
b9fb 3a 0a ba			ld a, (.dmark+1)  
b9fe 32 6c ee			ld (debug_mark+1),a  
ba01 3a 0b ba			ld a, (.dmark+2)  
ba04 32 6d ee			ld (debug_mark+2),a  
ba07 18 03			jr .pastdmark  
ba09 ..			.dmark: db "EMT"  
ba0c f1			.pastdmark: pop af  
ba0d			endm  
# End of macro DMARK
ba0d						CALLMONITOR 
ba0d cd 6f ee			call debug_vector  
ba10				endm  
# End of macro CALLMONITOR
ba10					endif 
ba10			 
ba10					FORTH_DSP_VALUEHL 
ba10 cd 67 9c			call macro_dsp_valuehl 
ba13				endm 
# End of macro FORTH_DSP_VALUEHL
ba13			 
ba13 7d					ld a,l 
ba14			 
ba14					; TODO write to display 
ba14			 
ba14 32 bf e4				ld (os_input), a 
ba17 3e 00				ld a, 0 
ba19 32 c0 e4				ld (os_input+1), a 
ba1c					 
ba1c 3a 5e ea				ld a, (f_cursor_ptr) 
ba1f 11 bf e4				ld de, os_input 
ba22 cd c1 8a				call str_at_display 
ba25			 
ba25			 
ba25 3a 3c ea				ld a,(cli_autodisplay) 
ba28 fe 00				cp 0 
ba2a 28 03				jr z, .enoupdate 
ba2c cd d1 8a						call update_display 
ba2f					.enoupdate: 
ba2f			 
ba2f 3a 5e ea				ld a, (f_cursor_ptr) 
ba32 3c					inc a 
ba33 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
ba36			 
ba36			 
ba36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba36 cd 1f 9d			call macro_forth_dsp_pop 
ba39				endm 
# End of macro FORTH_DSP_POP
ba39			  
ba39			 
ba39					NEXTW 
ba39 c3 1d 9e			jp macro_next 
ba3c				endm 
# End of macro NEXTW
ba3c			.DOTH: 
ba3c				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
ba3c 1c				db WORD_SYS_CORE+8             
ba3d 6c ba			dw .DOTF            
ba3f 03				db 2 + 1 
ba40 .. 00			db ".-",0              
ba43				endm 
# End of macro CWHEAD
ba43			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
ba43					; get value off TOS and display it 
ba43					if DEBUG_FORTH_WORDS_KEY 
ba43						DMARK "DTD" 
ba43 f5				push af  
ba44 3a 58 ba			ld a, (.dmark)  
ba47 32 6b ee			ld (debug_mark),a  
ba4a 3a 59 ba			ld a, (.dmark+1)  
ba4d 32 6c ee			ld (debug_mark+1),a  
ba50 3a 5a ba			ld a, (.dmark+2)  
ba53 32 6d ee			ld (debug_mark+2),a  
ba56 18 03			jr .pastdmark  
ba58 ..			.dmark: db "DTD"  
ba5b f1			.pastdmark: pop af  
ba5c			endm  
# End of macro DMARK
ba5c						CALLMONITOR 
ba5c cd 6f ee			call debug_vector  
ba5f				endm  
# End of macro CALLMONITOR
ba5f					endif 
ba5f 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
ba61 3e 00			ld a, 0 
ba63 32 3d ea			ld (cli_mvdot), a 
ba66 c3 c3 ba			jp .dotgo 
ba69				NEXTW 
ba69 c3 1d 9e			jp macro_next 
ba6c				endm 
# End of macro NEXTW
ba6c			.DOTF: 
ba6c				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
ba6c 1c				db WORD_SYS_CORE+8             
ba6d 9a ba			dw .DOT            
ba6f 03				db 2 + 1 
ba70 .. 00			db ".>",0              
ba73				endm 
# End of macro CWHEAD
ba73			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
ba73					; get value off TOS and display it 
ba73			        ; TODO BUG adds extra spaces 
ba73			        ; TODO BUG handle numerics? 
ba73					if DEBUG_FORTH_WORDS_KEY 
ba73						DMARK "DTC" 
ba73 f5				push af  
ba74 3a 88 ba			ld a, (.dmark)  
ba77 32 6b ee			ld (debug_mark),a  
ba7a 3a 89 ba			ld a, (.dmark+1)  
ba7d 32 6c ee			ld (debug_mark+1),a  
ba80 3a 8a ba			ld a, (.dmark+2)  
ba83 32 6d ee			ld (debug_mark+2),a  
ba86 18 03			jr .pastdmark  
ba88 ..			.dmark: db "DTC"  
ba8b f1			.pastdmark: pop af  
ba8c			endm  
# End of macro DMARK
ba8c						CALLMONITOR 
ba8c cd 6f ee			call debug_vector  
ba8f				endm  
# End of macro CALLMONITOR
ba8f					endif 
ba8f 3e 01			ld a, 1 
ba91 32 3d ea			ld (cli_mvdot), a 
ba94 c3 c3 ba			jp .dotgo 
ba97				NEXTW 
ba97 c3 1d 9e			jp macro_next 
ba9a				endm 
# End of macro NEXTW
ba9a			 
ba9a			.DOT: 
ba9a				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
ba9a 1c				db WORD_SYS_CORE+8             
ba9b 76 bc			dw .CLS            
ba9d 02				db 1 + 1 
ba9e .. 00			db ".",0              
baa0				endm 
# End of macro CWHEAD
baa0			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
baa0					; get value off TOS and display it 
baa0			 
baa0					if DEBUG_FORTH_WORDS_KEY 
baa0						DMARK "DOT" 
baa0 f5				push af  
baa1 3a b5 ba			ld a, (.dmark)  
baa4 32 6b ee			ld (debug_mark),a  
baa7 3a b6 ba			ld a, (.dmark+1)  
baaa 32 6c ee			ld (debug_mark+1),a  
baad 3a b7 ba			ld a, (.dmark+2)  
bab0 32 6d ee			ld (debug_mark+2),a  
bab3 18 03			jr .pastdmark  
bab5 ..			.dmark: db "DOT"  
bab8 f1			.pastdmark: pop af  
bab9			endm  
# End of macro DMARK
bab9						CALLMONITOR 
bab9 cd 6f ee			call debug_vector  
babc				endm  
# End of macro CALLMONITOR
babc					endif 
babc 3e 00			ld a, 0 
babe 32 3d ea			ld (cli_mvdot), a 
bac1 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bac3				 
bac3			 
bac3			.dotgo: 
bac3			 
bac3			; move up type to on stack for parserv5 
bac3					FORTH_DSP 
bac3 cd 2d 9c			call macro_forth_dsp 
bac6				endm 
# End of macro FORTH_DSP
bac6				;FORTH_DSP_VALUE  
bac6			 
bac6			if DEBUG_FORTH_DOT 
bac6				DMARK "DOT" 
bac6 f5				push af  
bac7 3a db ba			ld a, (.dmark)  
baca 32 6b ee			ld (debug_mark),a  
bacd 3a dc ba			ld a, (.dmark+1)  
bad0 32 6c ee			ld (debug_mark+1),a  
bad3 3a dd ba			ld a, (.dmark+2)  
bad6 32 6d ee			ld (debug_mark+2),a  
bad9 18 03			jr .pastdmark  
badb ..			.dmark: db "DOT"  
bade f1			.pastdmark: pop af  
badf			endm  
# End of macro DMARK
badf				CALLMONITOR 
badf cd 6f ee			call debug_vector  
bae2				endm  
# End of macro CALLMONITOR
bae2			endif	 
bae2			;		.print: 
bae2			 
bae2 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bae3 23				inc hl   ; position to the actual value 
bae4 fe 01			cp DS_TYPE_STR 
bae6 20 06			jr nz, .dotnum1  
bae8			 
bae8			; display string 
bae8				FORTH_DSP_VALUE  
bae8 cd 50 9c			call macro_forth_dsp_value 
baeb				endm 
# End of macro FORTH_DSP_VALUE
baeb eb				ex de,hl 
baec 18 49			jr .dotwrite 
baee			 
baee			.dotnum1: 
baee fe 02			cp DS_TYPE_INUM 
baf0 20 44			jr nz, .dotflot 
baf2			 
baf2			 
baf2			; display number 
baf2			 
baf2			;	push hl 
baf2			;	call clear_display 
baf2			;	pop hl 
baf2			 
baf2 5e				ld e, (hl) 
baf3 23				inc hl 
baf4 56				ld d, (hl) 
baf5 21 c1 e2			ld hl, scratch 
baf8			if DEBUG_FORTH_DOT 
baf8				DMARK "DT1" 
baf8 f5				push af  
baf9 3a 0d bb			ld a, (.dmark)  
bafc 32 6b ee			ld (debug_mark),a  
baff 3a 0e bb			ld a, (.dmark+1)  
bb02 32 6c ee			ld (debug_mark+1),a  
bb05 3a 0f bb			ld a, (.dmark+2)  
bb08 32 6d ee			ld (debug_mark+2),a  
bb0b 18 03			jr .pastdmark  
bb0d ..			.dmark: db "DT1"  
bb10 f1			.pastdmark: pop af  
bb11			endm  
# End of macro DMARK
bb11				CALLMONITOR 
bb11 cd 6f ee			call debug_vector  
bb14				endm  
# End of macro CALLMONITOR
bb14			endif	 
bb14			 
bb14 cd f0 8f			call uitoa_16 
bb17 eb				ex de,hl 
bb18			 
bb18			if DEBUG_FORTH_DOT 
bb18				DMARK "DT2" 
bb18 f5				push af  
bb19 3a 2d bb			ld a, (.dmark)  
bb1c 32 6b ee			ld (debug_mark),a  
bb1f 3a 2e bb			ld a, (.dmark+1)  
bb22 32 6c ee			ld (debug_mark+1),a  
bb25 3a 2f bb			ld a, (.dmark+2)  
bb28 32 6d ee			ld (debug_mark+2),a  
bb2b 18 03			jr .pastdmark  
bb2d ..			.dmark: db "DT2"  
bb30 f1			.pastdmark: pop af  
bb31			endm  
# End of macro DMARK
bb31				CALLMONITOR 
bb31 cd 6f ee			call debug_vector  
bb34				endm  
# End of macro CALLMONITOR
bb34			endif	 
bb34			 
bb34			;	ld de, os_word_scratch 
bb34 18 01			jr .dotwrite 
bb36			 
bb36 00			.dotflot:   nop 
bb37			; TODO print floating point number 
bb37			 
bb37			.dotwrite:		 
bb37			 
bb37					; if c is set then set all '-' to spaces 
bb37					; need to also take into account .>  
bb37			 
bb37 3e 01				ld a, 1 
bb39 b9					cp c 
bb3a 20 67				jr nz, .nodashswap 
bb3c			 
bb3c					; DE has the string to write, working with HL 
bb3c			 
bb3c 06 ff				ld b, 255 
bb3e d5					push de 
bb3f e1					pop hl 
bb40			 
bb40			if DEBUG_FORTH_DOT 
bb40				DMARK "DT-" 
bb40 f5				push af  
bb41 3a 55 bb			ld a, (.dmark)  
bb44 32 6b ee			ld (debug_mark),a  
bb47 3a 56 bb			ld a, (.dmark+1)  
bb4a 32 6c ee			ld (debug_mark+1),a  
bb4d 3a 57 bb			ld a, (.dmark+2)  
bb50 32 6d ee			ld (debug_mark+2),a  
bb53 18 03			jr .pastdmark  
bb55 ..			.dmark: db "DT-"  
bb58 f1			.pastdmark: pop af  
bb59			endm  
# End of macro DMARK
bb59				CALLMONITOR 
bb59 cd 6f ee			call debug_vector  
bb5c				endm  
# End of macro CALLMONITOR
bb5c			endif	 
bb5c 7e			.dashscan:	ld a, (hl) 
bb5d fe 00				cp 0 
bb5f 28 42				jr z, .nodashswap 
bb61 fe 2d				cp '-' 
bb63 20 03				jr nz, .dashskip 
bb65 3e 20				ld a, ' ' 
bb67 77					ld (hl), a 
bb68 23			.dashskip:	inc hl 
bb69			if DEBUG_FORTH_DOT 
bb69				DMARK "D-2" 
bb69 f5				push af  
bb6a 3a 7e bb			ld a, (.dmark)  
bb6d 32 6b ee			ld (debug_mark),a  
bb70 3a 7f bb			ld a, (.dmark+1)  
bb73 32 6c ee			ld (debug_mark+1),a  
bb76 3a 80 bb			ld a, (.dmark+2)  
bb79 32 6d ee			ld (debug_mark+2),a  
bb7c 18 03			jr .pastdmark  
bb7e ..			.dmark: db "D-2"  
bb81 f1			.pastdmark: pop af  
bb82			endm  
# End of macro DMARK
bb82				CALLMONITOR 
bb82 cd 6f ee			call debug_vector  
bb85				endm  
# End of macro CALLMONITOR
bb85			endif	 
bb85 10 d5				djnz .dashscan 
bb87			 
bb87			if DEBUG_FORTH_DOT 
bb87				DMARK "D-1" 
bb87 f5				push af  
bb88 3a 9c bb			ld a, (.dmark)  
bb8b 32 6b ee			ld (debug_mark),a  
bb8e 3a 9d bb			ld a, (.dmark+1)  
bb91 32 6c ee			ld (debug_mark+1),a  
bb94 3a 9e bb			ld a, (.dmark+2)  
bb97 32 6d ee			ld (debug_mark+2),a  
bb9a 18 03			jr .pastdmark  
bb9c ..			.dmark: db "D-1"  
bb9f f1			.pastdmark: pop af  
bba0			endm  
# End of macro DMARK
bba0				CALLMONITOR 
bba0 cd 6f ee			call debug_vector  
bba3				endm  
# End of macro CALLMONITOR
bba3			endif	 
bba3			 
bba3			.nodashswap: 
bba3			 
bba3			if DEBUG_FORTH_DOT 
bba3				DMARK "D-o" 
bba3 f5				push af  
bba4 3a b8 bb			ld a, (.dmark)  
bba7 32 6b ee			ld (debug_mark),a  
bbaa 3a b9 bb			ld a, (.dmark+1)  
bbad 32 6c ee			ld (debug_mark+1),a  
bbb0 3a ba bb			ld a, (.dmark+2)  
bbb3 32 6d ee			ld (debug_mark+2),a  
bbb6 18 03			jr .pastdmark  
bbb8 ..			.dmark: db "D-o"  
bbbb f1			.pastdmark: pop af  
bbbc			endm  
# End of macro DMARK
bbbc				CALLMONITOR 
bbbc cd 6f ee			call debug_vector  
bbbf				endm  
# End of macro CALLMONITOR
bbbf			endif	 
bbbf			 
bbbf d5					push de   ; save string start in case we need to advance print 
bbc0			 
bbc0 3a 5e ea				ld a, (f_cursor_ptr) 
bbc3 cd c1 8a				call str_at_display 
bbc6 3a 3c ea				ld a,(cli_autodisplay) 
bbc9 fe 00				cp 0 
bbcb 28 03				jr z, .noupdate 
bbcd cd d1 8a						call update_display 
bbd0					.noupdate: 
bbd0			 
bbd0			 
bbd0					; see if we need to advance the print position 
bbd0			 
bbd0 e1					pop hl   ; get back string 
bbd1			;		ex de,hl 
bbd1			 
bbd1 3a 3d ea				ld a, (cli_mvdot) 
bbd4			if DEBUG_FORTH_DOT 
bbd4			;		ld e,a 
bbd4				DMARK "D>1" 
bbd4 f5				push af  
bbd5 3a e9 bb			ld a, (.dmark)  
bbd8 32 6b ee			ld (debug_mark),a  
bbdb 3a ea bb			ld a, (.dmark+1)  
bbde 32 6c ee			ld (debug_mark+1),a  
bbe1 3a eb bb			ld a, (.dmark+2)  
bbe4 32 6d ee			ld (debug_mark+2),a  
bbe7 18 03			jr .pastdmark  
bbe9 ..			.dmark: db "D>1"  
bbec f1			.pastdmark: pop af  
bbed			endm  
# End of macro DMARK
bbed				CALLMONITOR 
bbed cd 6f ee			call debug_vector  
bbf0				endm  
# End of macro CALLMONITOR
bbf0			endif	 
bbf0 fe 00				cp 0 
bbf2 28 44				jr z, .noadv 
bbf4					; yes, lets advance the print position 
bbf4 3e 00				ld a, 0 
bbf6 cd 4c 90				call strlent 
bbf9			if DEBUG_FORTH_DOT 
bbf9				DMARK "D-?" 
bbf9 f5				push af  
bbfa 3a 0e bc			ld a, (.dmark)  
bbfd 32 6b ee			ld (debug_mark),a  
bc00 3a 0f bc			ld a, (.dmark+1)  
bc03 32 6c ee			ld (debug_mark+1),a  
bc06 3a 10 bc			ld a, (.dmark+2)  
bc09 32 6d ee			ld (debug_mark+2),a  
bc0c 18 03			jr .pastdmark  
bc0e ..			.dmark: db "D-?"  
bc11 f1			.pastdmark: pop af  
bc12			endm  
# End of macro DMARK
bc12				CALLMONITOR 
bc12 cd 6f ee			call debug_vector  
bc15				endm  
# End of macro CALLMONITOR
bc15			endif	 
bc15 3a 5e ea				ld a, (f_cursor_ptr) 
bc18 85					add a,l 
bc19					;call addatohl 
bc19					;ld a, l 
bc19 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bc1c			 
bc1c			if DEBUG_FORTH_DOT 
bc1c				DMARK "D->" 
bc1c f5				push af  
bc1d 3a 31 bc			ld a, (.dmark)  
bc20 32 6b ee			ld (debug_mark),a  
bc23 3a 32 bc			ld a, (.dmark+1)  
bc26 32 6c ee			ld (debug_mark+1),a  
bc29 3a 33 bc			ld a, (.dmark+2)  
bc2c 32 6d ee			ld (debug_mark+2),a  
bc2f 18 03			jr .pastdmark  
bc31 ..			.dmark: db "D->"  
bc34 f1			.pastdmark: pop af  
bc35			endm  
# End of macro DMARK
bc35				CALLMONITOR 
bc35 cd 6f ee			call debug_vector  
bc38				endm  
# End of macro CALLMONITOR
bc38			endif	 
bc38			 
bc38			.noadv:	 
bc38			 
bc38					if DEBUG_FORTH_DOT_WAIT 
bc38							call next_page_prompt 
bc38					endif	 
bc38			; TODO this pop off the stack causes a crash. i dont know why 
bc38			 
bc38			 
bc38			if DEBUG_FORTH_DOT 
bc38				DMARK "DTh" 
bc38 f5				push af  
bc39 3a 4d bc			ld a, (.dmark)  
bc3c 32 6b ee			ld (debug_mark),a  
bc3f 3a 4e bc			ld a, (.dmark+1)  
bc42 32 6c ee			ld (debug_mark+1),a  
bc45 3a 4f bc			ld a, (.dmark+2)  
bc48 32 6d ee			ld (debug_mark+2),a  
bc4b 18 03			jr .pastdmark  
bc4d ..			.dmark: db "DTh"  
bc50 f1			.pastdmark: pop af  
bc51			endm  
# End of macro DMARK
bc51				CALLMONITOR 
bc51 cd 6f ee			call debug_vector  
bc54				endm  
# End of macro CALLMONITOR
bc54			endif	 
bc54			 
bc54					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc54 cd 1f 9d			call macro_forth_dsp_pop 
bc57				endm 
# End of macro FORTH_DSP_POP
bc57			 
bc57			if DEBUG_FORTH_DOT 
bc57				DMARK "DTi" 
bc57 f5				push af  
bc58 3a 6c bc			ld a, (.dmark)  
bc5b 32 6b ee			ld (debug_mark),a  
bc5e 3a 6d bc			ld a, (.dmark+1)  
bc61 32 6c ee			ld (debug_mark+1),a  
bc64 3a 6e bc			ld a, (.dmark+2)  
bc67 32 6d ee			ld (debug_mark+2),a  
bc6a 18 03			jr .pastdmark  
bc6c ..			.dmark: db "DTi"  
bc6f f1			.pastdmark: pop af  
bc70			endm  
# End of macro DMARK
bc70				CALLMONITOR 
bc70 cd 6f ee			call debug_vector  
bc73				endm  
# End of macro CALLMONITOR
bc73			endif	 
bc73			 
bc73			 
bc73					NEXTW 
bc73 c3 1d 9e			jp macro_next 
bc76				endm 
# End of macro NEXTW
bc76			 
bc76			.CLS: 
bc76				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bc76 35				db WORD_SYS_CORE+33             
bc77 a3 bc			dw .DRAW            
bc79 04				db 3 + 1 
bc7a .. 00			db "CLS",0              
bc7e				endm 
# End of macro CWHEAD
bc7e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bc7e					if DEBUG_FORTH_WORDS_KEY 
bc7e						DMARK "CLS" 
bc7e f5				push af  
bc7f 3a 93 bc			ld a, (.dmark)  
bc82 32 6b ee			ld (debug_mark),a  
bc85 3a 94 bc			ld a, (.dmark+1)  
bc88 32 6c ee			ld (debug_mark+1),a  
bc8b 3a 95 bc			ld a, (.dmark+2)  
bc8e 32 6d ee			ld (debug_mark+2),a  
bc91 18 03			jr .pastdmark  
bc93 ..			.dmark: db "CLS"  
bc96 f1			.pastdmark: pop af  
bc97			endm  
# End of macro DMARK
bc97						CALLMONITOR 
bc97 cd 6f ee			call debug_vector  
bc9a				endm  
# End of macro CALLMONITOR
bc9a					endif 
bc9a cd ae 8a				call clear_display 
bc9d c3 b1 bd				jp .home		; and home cursor 
bca0					NEXTW 
bca0 c3 1d 9e			jp macro_next 
bca3				endm 
# End of macro NEXTW
bca3			 
bca3			.DRAW: 
bca3				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bca3 36				db WORD_SYS_CORE+34             
bca4 ce bc			dw .DUMP            
bca6 05				db 4 + 1 
bca7 .. 00			db "DRAW",0              
bcac				endm 
# End of macro CWHEAD
bcac			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bcac					if DEBUG_FORTH_WORDS_KEY 
bcac						DMARK "DRW" 
bcac f5				push af  
bcad 3a c1 bc			ld a, (.dmark)  
bcb0 32 6b ee			ld (debug_mark),a  
bcb3 3a c2 bc			ld a, (.dmark+1)  
bcb6 32 6c ee			ld (debug_mark+1),a  
bcb9 3a c3 bc			ld a, (.dmark+2)  
bcbc 32 6d ee			ld (debug_mark+2),a  
bcbf 18 03			jr .pastdmark  
bcc1 ..			.dmark: db "DRW"  
bcc4 f1			.pastdmark: pop af  
bcc5			endm  
# End of macro DMARK
bcc5						CALLMONITOR 
bcc5 cd 6f ee			call debug_vector  
bcc8				endm  
# End of macro CALLMONITOR
bcc8					endif 
bcc8 cd d1 8a				call update_display 
bccb					NEXTW 
bccb c3 1d 9e			jp macro_next 
bcce				endm 
# End of macro NEXTW
bcce			 
bcce			.DUMP: 
bcce				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bcce 37				db WORD_SYS_CORE+35             
bccf 06 bd			dw .CDUMP            
bcd1 05				db 4 + 1 
bcd2 .. 00			db "DUMP",0              
bcd7				endm 
# End of macro CWHEAD
bcd7			; | DUMP ( x -- ) With address x display dump   | DONE 
bcd7			; TODO pop address to use off of the stack 
bcd7					if DEBUG_FORTH_WORDS_KEY 
bcd7						DMARK "DUM" 
bcd7 f5				push af  
bcd8 3a ec bc			ld a, (.dmark)  
bcdb 32 6b ee			ld (debug_mark),a  
bcde 3a ed bc			ld a, (.dmark+1)  
bce1 32 6c ee			ld (debug_mark+1),a  
bce4 3a ee bc			ld a, (.dmark+2)  
bce7 32 6d ee			ld (debug_mark+2),a  
bcea 18 03			jr .pastdmark  
bcec ..			.dmark: db "DUM"  
bcef f1			.pastdmark: pop af  
bcf0			endm  
# End of macro DMARK
bcf0						CALLMONITOR 
bcf0 cd 6f ee			call debug_vector  
bcf3				endm  
# End of macro CALLMONITOR
bcf3					endif 
bcf3 cd ae 8a				call clear_display 
bcf6			 
bcf6					; get address 
bcf6			 
bcf6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bcf6 cd 67 9c			call macro_dsp_valuehl 
bcf9				endm 
# End of macro FORTH_DSP_VALUEHL
bcf9				 
bcf9					; save it for cdump 
bcf9			 
bcf9 22 e4 e5				ld (os_cur_ptr),hl 
bcfc			 
bcfc					; destroy value TOS 
bcfc			 
bcfc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bcfc cd 1f 9d			call macro_forth_dsp_pop 
bcff				endm 
# End of macro FORTH_DSP_POP
bcff			 
bcff cd e2 98				call dumpcont	; skip old style of param parsing	 
bd02 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bd03					NEXTW 
bd03 c3 1d 9e			jp macro_next 
bd06				endm 
# End of macro NEXTW
bd06			.CDUMP: 
bd06				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bd06 38				db WORD_SYS_CORE+36             
bd07 36 bd			dw .DAT            
bd09 06				db 5 + 1 
bd0a .. 00			db "CDUMP",0              
bd10				endm 
# End of macro CWHEAD
bd10			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bd10					if DEBUG_FORTH_WORDS_KEY 
bd10						DMARK "CDP" 
bd10 f5				push af  
bd11 3a 25 bd			ld a, (.dmark)  
bd14 32 6b ee			ld (debug_mark),a  
bd17 3a 26 bd			ld a, (.dmark+1)  
bd1a 32 6c ee			ld (debug_mark+1),a  
bd1d 3a 27 bd			ld a, (.dmark+2)  
bd20 32 6d ee			ld (debug_mark+2),a  
bd23 18 03			jr .pastdmark  
bd25 ..			.dmark: db "CDP"  
bd28 f1			.pastdmark: pop af  
bd29			endm  
# End of macro DMARK
bd29						CALLMONITOR 
bd29 cd 6f ee			call debug_vector  
bd2c				endm  
# End of macro CALLMONITOR
bd2c					endif 
bd2c cd ae 8a				call clear_display 
bd2f cd e2 98				call dumpcont	 
bd32 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bd33					NEXTW 
bd33 c3 1d 9e			jp macro_next 
bd36				endm 
# End of macro NEXTW
bd36			 
bd36			 
bd36			 
bd36			 
bd36			.DAT: 
bd36				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bd36 3d				db WORD_SYS_CORE+41             
bd37 8c bd			dw .HOME            
bd39 03				db 2 + 1 
bd3a .. 00			db "AT",0              
bd3d				endm 
# End of macro CWHEAD
bd3d			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bd3d					if DEBUG_FORTH_WORDS_KEY 
bd3d						DMARK "AT." 
bd3d f5				push af  
bd3e 3a 52 bd			ld a, (.dmark)  
bd41 32 6b ee			ld (debug_mark),a  
bd44 3a 53 bd			ld a, (.dmark+1)  
bd47 32 6c ee			ld (debug_mark+1),a  
bd4a 3a 54 bd			ld a, (.dmark+2)  
bd4d 32 6d ee			ld (debug_mark+2),a  
bd50 18 03			jr .pastdmark  
bd52 ..			.dmark: db "AT."  
bd55 f1			.pastdmark: pop af  
bd56			endm  
# End of macro DMARK
bd56						CALLMONITOR 
bd56 cd 6f ee			call debug_vector  
bd59				endm  
# End of macro CALLMONITOR
bd59					endif 
bd59					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd59 cd 67 9c			call macro_dsp_valuehl 
bd5c				endm 
# End of macro FORTH_DSP_VALUEHL
bd5c			 
bd5c			 
bd5c					; TODO save cursor row 
bd5c 7d					ld a,l 
bd5d fe 02				cp 2 
bd5f 20 04				jr nz, .crow3 
bd61 3e 28				ld a, display_row_2 
bd63 18 12				jr .ccol1 
bd65 fe 03		.crow3:		cp 3 
bd67 20 04				jr nz, .crow4 
bd69 3e 50				ld a, display_row_3 
bd6b 18 0a				jr .ccol1 
bd6d fe 04		.crow4:		cp 4 
bd6f 20 04				jr nz, .crow1 
bd71 3e 78				ld a, display_row_4 
bd73 18 02				jr .ccol1 
bd75 3e 00		.crow1:		ld a,display_row_1 
bd77 f5			.ccol1:		push af			; got row offset 
bd78 6f					ld l,a 
bd79 26 00				ld h,0 
bd7b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd7b cd 1f 9d			call macro_forth_dsp_pop 
bd7e				endm 
# End of macro FORTH_DSP_POP
bd7e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd7e cd 67 9c			call macro_dsp_valuehl 
bd81				endm 
# End of macro FORTH_DSP_VALUEHL
bd81					; TODO save cursor col 
bd81 f1					pop af 
bd82 85					add l		; add col offset 
bd83 32 5e ea				ld (f_cursor_ptr), a 
bd86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd86 cd 1f 9d			call macro_forth_dsp_pop 
bd89				endm 
# End of macro FORTH_DSP_POP
bd89			 
bd89					; calculate  
bd89			 
bd89					NEXTW 
bd89 c3 1d 9e			jp macro_next 
bd8c				endm 
# End of macro NEXTW
bd8c			 
bd8c			 
bd8c			.HOME: 
bd8c				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
bd8c 41				db WORD_SYS_CORE+45             
bd8d b9 bd			dw .CR            
bd8f 05				db 4 + 1 
bd90 .. 00			db "HOME",0              
bd95				endm 
# End of macro CWHEAD
bd95			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bd95					if DEBUG_FORTH_WORDS_KEY 
bd95						DMARK "HOM" 
bd95 f5				push af  
bd96 3a aa bd			ld a, (.dmark)  
bd99 32 6b ee			ld (debug_mark),a  
bd9c 3a ab bd			ld a, (.dmark+1)  
bd9f 32 6c ee			ld (debug_mark+1),a  
bda2 3a ac bd			ld a, (.dmark+2)  
bda5 32 6d ee			ld (debug_mark+2),a  
bda8 18 03			jr .pastdmark  
bdaa ..			.dmark: db "HOM"  
bdad f1			.pastdmark: pop af  
bdae			endm  
# End of macro DMARK
bdae						CALLMONITOR 
bdae cd 6f ee			call debug_vector  
bdb1				endm  
# End of macro CALLMONITOR
bdb1					endif 
bdb1 3e 00		.home:		ld a, 0		; and home cursor 
bdb3 32 5e ea				ld (f_cursor_ptr), a 
bdb6					NEXTW 
bdb6 c3 1d 9e			jp macro_next 
bdb9				endm 
# End of macro NEXTW
bdb9			 
bdb9			 
bdb9			.CR: 
bdb9				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
bdb9 46				db WORD_SYS_CORE+50             
bdba f4 bd			dw .SPACE            
bdbc 03				db 2 + 1 
bdbd .. 00			db "CR",0              
bdc0				endm 
# End of macro CWHEAD
bdc0			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
bdc0					if DEBUG_FORTH_WORDS_KEY 
bdc0						DMARK "CR." 
bdc0 f5				push af  
bdc1 3a d5 bd			ld a, (.dmark)  
bdc4 32 6b ee			ld (debug_mark),a  
bdc7 3a d6 bd			ld a, (.dmark+1)  
bdca 32 6c ee			ld (debug_mark+1),a  
bdcd 3a d7 bd			ld a, (.dmark+2)  
bdd0 32 6d ee			ld (debug_mark+2),a  
bdd3 18 03			jr .pastdmark  
bdd5 ..			.dmark: db "CR."  
bdd8 f1			.pastdmark: pop af  
bdd9			endm  
# End of macro DMARK
bdd9						CALLMONITOR 
bdd9 cd 6f ee			call debug_vector  
bddc				endm  
# End of macro CALLMONITOR
bddc					endif 
bddc 3e 0d				ld a, 13 
bdde 32 c1 e2				ld (scratch),a 
bde1 3e 0a				ld a, 10 
bde3 32 c2 e2				ld (scratch+1),a 
bde6 3e 00				ld a, 0 
bde8 32 c3 e2				ld (scratch+2),a 
bdeb 21 c1 e2				ld hl, scratch 
bdee cd d0 9a				call forth_push_str 
bdf1					 
bdf1				       NEXTW 
bdf1 c3 1d 9e			jp macro_next 
bdf4				endm 
# End of macro NEXTW
bdf4			.SPACE: 
bdf4				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
bdf4 46				db WORD_SYS_CORE+50             
bdf5 2a be			dw .SPACES            
bdf7 03				db 2 + 1 
bdf8 .. 00			db "BL",0              
bdfb				endm 
# End of macro CWHEAD
bdfb			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bdfb					if DEBUG_FORTH_WORDS_KEY 
bdfb						DMARK "BL." 
bdfb f5				push af  
bdfc 3a 10 be			ld a, (.dmark)  
bdff 32 6b ee			ld (debug_mark),a  
be02 3a 11 be			ld a, (.dmark+1)  
be05 32 6c ee			ld (debug_mark+1),a  
be08 3a 12 be			ld a, (.dmark+2)  
be0b 32 6d ee			ld (debug_mark+2),a  
be0e 18 03			jr .pastdmark  
be10 ..			.dmark: db "BL."  
be13 f1			.pastdmark: pop af  
be14			endm  
# End of macro DMARK
be14						CALLMONITOR 
be14 cd 6f ee			call debug_vector  
be17				endm  
# End of macro CALLMONITOR
be17					endif 
be17 3e 20				ld a, " " 
be19 32 c1 e2				ld (scratch),a 
be1c 3e 00				ld a, 0 
be1e 32 c2 e2				ld (scratch+1),a 
be21 21 c1 e2				ld hl, scratch 
be24 cd d0 9a				call forth_push_str 
be27					 
be27				       NEXTW 
be27 c3 1d 9e			jp macro_next 
be2a				endm 
# End of macro NEXTW
be2a			 
be2a			;.blstr: db " ", 0 
be2a			 
be2a			.SPACES: 
be2a				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be2a 47				db WORD_SYS_CORE+51             
be2b c5 be			dw .SCROLL            
be2d 07				db 6 + 1 
be2e .. 00			db "SPACES",0              
be35				endm 
# End of macro CWHEAD
be35			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be35					if DEBUG_FORTH_WORDS_KEY 
be35						DMARK "SPS" 
be35 f5				push af  
be36 3a 4a be			ld a, (.dmark)  
be39 32 6b ee			ld (debug_mark),a  
be3c 3a 4b be			ld a, (.dmark+1)  
be3f 32 6c ee			ld (debug_mark+1),a  
be42 3a 4c be			ld a, (.dmark+2)  
be45 32 6d ee			ld (debug_mark+2),a  
be48 18 03			jr .pastdmark  
be4a ..			.dmark: db "SPS"  
be4d f1			.pastdmark: pop af  
be4e			endm  
# End of macro DMARK
be4e						CALLMONITOR 
be4e cd 6f ee			call debug_vector  
be51				endm  
# End of macro CALLMONITOR
be51					endif 
be51			 
be51			 
be51					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be51 cd 67 9c			call macro_dsp_valuehl 
be54				endm 
# End of macro FORTH_DSP_VALUEHL
be54			 
be54 e5					push hl    ; u 
be55					if DEBUG_FORTH_WORDS 
be55						DMARK "SPA" 
be55 f5				push af  
be56 3a 6a be			ld a, (.dmark)  
be59 32 6b ee			ld (debug_mark),a  
be5c 3a 6b be			ld a, (.dmark+1)  
be5f 32 6c ee			ld (debug_mark+1),a  
be62 3a 6c be			ld a, (.dmark+2)  
be65 32 6d ee			ld (debug_mark+2),a  
be68 18 03			jr .pastdmark  
be6a ..			.dmark: db "SPA"  
be6d f1			.pastdmark: pop af  
be6e			endm  
# End of macro DMARK
be6e						CALLMONITOR 
be6e cd 6f ee			call debug_vector  
be71				endm  
# End of macro CALLMONITOR
be71					endif 
be71			 
be71					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be71 cd 1f 9d			call macro_forth_dsp_pop 
be74				endm 
# End of macro FORTH_DSP_POP
be74 e1					pop hl 
be75 0e 00				ld c, 0 
be77 45					ld b, l 
be78 21 c1 e2				ld hl, scratch  
be7b			 
be7b					if DEBUG_FORTH_WORDS 
be7b						DMARK "SP2" 
be7b f5				push af  
be7c 3a 90 be			ld a, (.dmark)  
be7f 32 6b ee			ld (debug_mark),a  
be82 3a 91 be			ld a, (.dmark+1)  
be85 32 6c ee			ld (debug_mark+1),a  
be88 3a 92 be			ld a, (.dmark+2)  
be8b 32 6d ee			ld (debug_mark+2),a  
be8e 18 03			jr .pastdmark  
be90 ..			.dmark: db "SP2"  
be93 f1			.pastdmark: pop af  
be94			endm  
# End of macro DMARK
be94						CALLMONITOR 
be94 cd 6f ee			call debug_vector  
be97				endm  
# End of macro CALLMONITOR
be97					endif 
be97 3e 20				ld a, ' ' 
be99			.spaces1:	 
be99 77					ld (hl),a 
be9a 23					inc hl 
be9b					 
be9b 10 fc				djnz .spaces1 
be9d 3e 00				ld a,0 
be9f 77					ld (hl),a 
bea0 21 c1 e2				ld hl, scratch 
bea3					if DEBUG_FORTH_WORDS 
bea3						DMARK "SP3" 
bea3 f5				push af  
bea4 3a b8 be			ld a, (.dmark)  
bea7 32 6b ee			ld (debug_mark),a  
beaa 3a b9 be			ld a, (.dmark+1)  
bead 32 6c ee			ld (debug_mark+1),a  
beb0 3a ba be			ld a, (.dmark+2)  
beb3 32 6d ee			ld (debug_mark+2),a  
beb6 18 03			jr .pastdmark  
beb8 ..			.dmark: db "SP3"  
bebb f1			.pastdmark: pop af  
bebc			endm  
# End of macro DMARK
bebc						CALLMONITOR 
bebc cd 6f ee			call debug_vector  
bebf				endm  
# End of macro CALLMONITOR
bebf					endif 
bebf cd d0 9a				call forth_push_str 
bec2			 
bec2				       NEXTW 
bec2 c3 1d 9e			jp macro_next 
bec5				endm 
# End of macro NEXTW
bec5			 
bec5			 
bec5			 
bec5			.SCROLL: 
bec5				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bec5 53				db WORD_SYS_CORE+63             
bec6 f2 be			dw .SCROLLD            
bec8 07				db 6 + 1 
bec9 .. 00			db "SCROLL",0              
bed0				endm 
# End of macro CWHEAD
bed0			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bed0					if DEBUG_FORTH_WORDS_KEY 
bed0						DMARK "SCR" 
bed0 f5				push af  
bed1 3a e5 be			ld a, (.dmark)  
bed4 32 6b ee			ld (debug_mark),a  
bed7 3a e6 be			ld a, (.dmark+1)  
beda 32 6c ee			ld (debug_mark+1),a  
bedd 3a e7 be			ld a, (.dmark+2)  
bee0 32 6d ee			ld (debug_mark+2),a  
bee3 18 03			jr .pastdmark  
bee5 ..			.dmark: db "SCR"  
bee8 f1			.pastdmark: pop af  
bee9			endm  
# End of macro DMARK
bee9						CALLMONITOR 
bee9 cd 6f ee			call debug_vector  
beec				endm  
# End of macro CALLMONITOR
beec					endif 
beec			 
beec cd 70 8a			call scroll_up 
beef			;	call update_display 
beef			 
beef					NEXTW 
beef c3 1d 9e			jp macro_next 
bef2				endm 
# End of macro NEXTW
bef2			 
bef2			 
bef2			 
bef2			;		; get dir 
bef2			; 
bef2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bef2			; 
bef2			;		push hl 
bef2			; 
bef2			;		; destroy value TOS 
bef2			; 
bef2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bef2			; 
bef2			;		; get count 
bef2			; 
bef2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bef2			; 
bef2			;		push hl 
bef2			; 
bef2			;		; destroy value TOS 
bef2			; 
bef2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bef2			; 
bef2			;		; one value on hl get other one back 
bef2			; 
bef2			;		pop bc    ; count 
bef2			; 
bef2			;		pop de   ; dir 
bef2			; 
bef2			; 
bef2			;		ld b, c 
bef2			; 
bef2			;.scrolldir:     push bc 
bef2			;		push de 
bef2			; 
bef2			;		ld a, 0 
bef2			;		cp e 
bef2			;		jr z, .scrollup  
bef2			;		call scroll_down 
bef2			;		jr .scrollnext 
bef2			;.scrollup:	call scroll_up 
bef2			; 
bef2			;		 
bef2			;.scrollnext: 
bef2			;		pop de 
bef2			;		pop bc 
bef2			;		djnz .scrolldir 
bef2			; 
bef2			; 
bef2			; 
bef2			; 
bef2			; 
bef2			;		NEXTW 
bef2			 
bef2			.SCROLLD: 
bef2				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bef2 53				db WORD_SYS_CORE+63             
bef3 20 bf			dw .ATQ            
bef5 08				db 7 + 1 
bef6 .. 00			db "SCROLLD",0              
befe				endm 
# End of macro CWHEAD
befe			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
befe					if DEBUG_FORTH_WORDS_KEY 
befe						DMARK "SCD" 
befe f5				push af  
beff 3a 13 bf			ld a, (.dmark)  
bf02 32 6b ee			ld (debug_mark),a  
bf05 3a 14 bf			ld a, (.dmark+1)  
bf08 32 6c ee			ld (debug_mark+1),a  
bf0b 3a 15 bf			ld a, (.dmark+2)  
bf0e 32 6d ee			ld (debug_mark+2),a  
bf11 18 03			jr .pastdmark  
bf13 ..			.dmark: db "SCD"  
bf16 f1			.pastdmark: pop af  
bf17			endm  
# End of macro DMARK
bf17						CALLMONITOR 
bf17 cd 6f ee			call debug_vector  
bf1a				endm  
# End of macro CALLMONITOR
bf1a					endif 
bf1a			 
bf1a cd 94 8a			call scroll_down 
bf1d			;	call update_display 
bf1d			 
bf1d					NEXTW 
bf1d c3 1d 9e			jp macro_next 
bf20				endm 
# End of macro NEXTW
bf20			 
bf20			 
bf20			.ATQ: 
bf20				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf20 62				db WORD_SYS_CORE+78             
bf21 7e bf			dw .AUTODSP            
bf23 04				db 3 + 1 
bf24 .. 00			db "AT@",0              
bf28				endm 
# End of macro CWHEAD
bf28			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf28					if DEBUG_FORTH_WORDS_KEY 
bf28						DMARK "ATA" 
bf28 f5				push af  
bf29 3a 3d bf			ld a, (.dmark)  
bf2c 32 6b ee			ld (debug_mark),a  
bf2f 3a 3e bf			ld a, (.dmark+1)  
bf32 32 6c ee			ld (debug_mark+1),a  
bf35 3a 3f bf			ld a, (.dmark+2)  
bf38 32 6d ee			ld (debug_mark+2),a  
bf3b 18 03			jr .pastdmark  
bf3d ..			.dmark: db "ATA"  
bf40 f1			.pastdmark: pop af  
bf41			endm  
# End of macro DMARK
bf41						CALLMONITOR 
bf41 cd 6f ee			call debug_vector  
bf44				endm  
# End of macro CALLMONITOR
bf44					endif 
bf44			 
bf44			 
bf44					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf44 cd 67 9c			call macro_dsp_valuehl 
bf47				endm 
# End of macro FORTH_DSP_VALUEHL
bf47			 
bf47					; TODO save cursor row 
bf47 7d					ld a,l 
bf48 fe 02				cp 2 
bf4a 20 04				jr nz, .crow3aq 
bf4c 3e 28				ld a, display_row_2 
bf4e 18 12				jr .ccol1aq 
bf50 fe 03		.crow3aq:		cp 3 
bf52 20 04				jr nz, .crow4aq 
bf54 3e 50				ld a, display_row_3 
bf56 18 0a				jr .ccol1aq 
bf58 fe 04		.crow4aq:		cp 4 
bf5a 20 04				jr nz, .crow1aq 
bf5c 3e 78				ld a, display_row_4 
bf5e 18 02				jr .ccol1aq 
bf60 3e 00		.crow1aq:		ld a,display_row_1 
bf62 f5			.ccol1aq:		push af			; got row offset 
bf63 6f					ld l,a 
bf64 26 00				ld h,0 
bf66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf66 cd 1f 9d			call macro_forth_dsp_pop 
bf69				endm 
# End of macro FORTH_DSP_POP
bf69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf69 cd 67 9c			call macro_dsp_valuehl 
bf6c				endm 
# End of macro FORTH_DSP_VALUEHL
bf6c					; TODO save cursor col 
bf6c f1					pop af 
bf6d 85					add l		; add col offset 
bf6e			 
bf6e					; add current frame buffer address 
bf6e 2a cc eb				ld hl, (display_fb_active) 
bf71 cd db 8c				call addatohl 
bf74			 
bf74			 
bf74			 
bf74			 
bf74					; get char frame buffer location offset in hl 
bf74			 
bf74 7e					ld a,(hl) 
bf75 26 00				ld h, 0 
bf77 6f					ld l, a 
bf78			 
bf78 cd 62 9a				call forth_push_numhl 
bf7b			 
bf7b			 
bf7b					NEXTW 
bf7b c3 1d 9e			jp macro_next 
bf7e				endm 
# End of macro NEXTW
bf7e			 
bf7e			.AUTODSP: 
bf7e				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bf7e 63				db WORD_SYS_CORE+79             
bf7f 94 bf			dw .MENU            
bf81 05				db 4 + 1 
bf82 .. 00			db "ADSP",0              
bf87				endm 
# End of macro CWHEAD
bf87			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bf87			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bf87			 
bf87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf87 cd 67 9c			call macro_dsp_valuehl 
bf8a				endm 
# End of macro FORTH_DSP_VALUEHL
bf8a			 
bf8a			;		push hl 
bf8a			 
bf8a					; destroy value TOS 
bf8a			 
bf8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf8a cd 1f 9d			call macro_forth_dsp_pop 
bf8d				endm 
# End of macro FORTH_DSP_POP
bf8d			 
bf8d			;		pop hl 
bf8d			 
bf8d 7d					ld a,l 
bf8e 32 3c ea				ld (cli_autodisplay), a 
bf91				       NEXTW 
bf91 c3 1d 9e			jp macro_next 
bf94				endm 
# End of macro NEXTW
bf94			 
bf94			.MENU: 
bf94				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bf94 70				db WORD_SYS_CORE+92             
bf95 3d c0			dw .ENDDISPLAY            
bf97 05				db 4 + 1 
bf98 .. 00			db "MENU",0              
bf9d				endm 
# End of macro CWHEAD
bf9d			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
bf9d			 
bf9d			;		; get number of items on the stack 
bf9d			; 
bf9d				 
bf9d					FORTH_DSP_VALUEHL 
bf9d cd 67 9c			call macro_dsp_valuehl 
bfa0				endm 
# End of macro FORTH_DSP_VALUEHL
bfa0				 
bfa0					if DEBUG_FORTH_WORDS_KEY 
bfa0						DMARK "MNU" 
bfa0 f5				push af  
bfa1 3a b5 bf			ld a, (.dmark)  
bfa4 32 6b ee			ld (debug_mark),a  
bfa7 3a b6 bf			ld a, (.dmark+1)  
bfaa 32 6c ee			ld (debug_mark+1),a  
bfad 3a b7 bf			ld a, (.dmark+2)  
bfb0 32 6d ee			ld (debug_mark+2),a  
bfb3 18 03			jr .pastdmark  
bfb5 ..			.dmark: db "MNU"  
bfb8 f1			.pastdmark: pop af  
bfb9			endm  
# End of macro DMARK
bfb9						CALLMONITOR 
bfb9 cd 6f ee			call debug_vector  
bfbc				endm  
# End of macro CALLMONITOR
bfbc					endif 
bfbc			 
bfbc 45					ld b, l	 
bfbd 05					dec b 
bfbe			 
bfbe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfbe cd 1f 9d			call macro_forth_dsp_pop 
bfc1				endm 
# End of macro FORTH_DSP_POP
bfc1			 
bfc1			 
bfc1					; go directly through the stack to pluck out the string pointers and build an array 
bfc1			 
bfc1			;		FORTH_DSP 
bfc1			 
bfc1					; hl contains top most stack item 
bfc1				 
bfc1 11 c1 e2				ld de, scratch 
bfc4			 
bfc4			.mbuild: 
bfc4			 
bfc4					FORTH_DSP_VALUEHL 
bfc4 cd 67 9c			call macro_dsp_valuehl 
bfc7				endm 
# End of macro FORTH_DSP_VALUEHL
bfc7			 
bfc7					if DEBUG_FORTH_WORDS 
bfc7						DMARK "MN3" 
bfc7 f5				push af  
bfc8 3a dc bf			ld a, (.dmark)  
bfcb 32 6b ee			ld (debug_mark),a  
bfce 3a dd bf			ld a, (.dmark+1)  
bfd1 32 6c ee			ld (debug_mark+1),a  
bfd4 3a de bf			ld a, (.dmark+2)  
bfd7 32 6d ee			ld (debug_mark+2),a  
bfda 18 03			jr .pastdmark  
bfdc ..			.dmark: db "MN3"  
bfdf f1			.pastdmark: pop af  
bfe0			endm  
# End of macro DMARK
bfe0						CALLMONITOR 
bfe0 cd 6f ee			call debug_vector  
bfe3				endm  
# End of macro CALLMONITOR
bfe3					endif 
bfe3 eb					ex de, hl 
bfe4 73					ld (hl), e 
bfe5 23					inc hl 
bfe6 72					ld (hl), d 
bfe7 23					inc hl 
bfe8 eb					ex de, hl 
bfe9			 
bfe9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfe9 cd 1f 9d			call macro_forth_dsp_pop 
bfec				endm 
# End of macro FORTH_DSP_POP
bfec			 
bfec 10 d6				djnz .mbuild 
bfee			 
bfee					; done add term 
bfee			 
bfee eb					ex de, hl 
bfef 36 00				ld (hl), 0 
bff1 23					inc hl 
bff2 36 00				ld (hl), 0 
bff4			 
bff4				 
bff4					 
bff4 21 c1 e2				ld hl, scratch 
bff7			 
bff7					if DEBUG_FORTH_WORDS 
bff7						DMARK "MNx" 
bff7 f5				push af  
bff8 3a 0c c0			ld a, (.dmark)  
bffb 32 6b ee			ld (debug_mark),a  
bffe 3a 0d c0			ld a, (.dmark+1)  
c001 32 6c ee			ld (debug_mark+1),a  
c004 3a 0e c0			ld a, (.dmark+2)  
c007 32 6d ee			ld (debug_mark+2),a  
c00a 18 03			jr .pastdmark  
c00c ..			.dmark: db "MNx"  
c00f f1			.pastdmark: pop af  
c010			endm  
# End of macro DMARK
c010						CALLMONITOR 
c010 cd 6f ee			call debug_vector  
c013				endm  
# End of macro CALLMONITOR
c013					endif 
c013			 
c013			 
c013			 
c013 3e 00				ld a, 0 
c015 cd df 8a				call menu 
c018			 
c018			 
c018 6f					ld l, a 
c019 26 00				ld h, 0 
c01b			 
c01b					if DEBUG_FORTH_WORDS 
c01b						DMARK "MNr" 
c01b f5				push af  
c01c 3a 30 c0			ld a, (.dmark)  
c01f 32 6b ee			ld (debug_mark),a  
c022 3a 31 c0			ld a, (.dmark+1)  
c025 32 6c ee			ld (debug_mark+1),a  
c028 3a 32 c0			ld a, (.dmark+2)  
c02b 32 6d ee			ld (debug_mark+2),a  
c02e 18 03			jr .pastdmark  
c030 ..			.dmark: db "MNr"  
c033 f1			.pastdmark: pop af  
c034			endm  
# End of macro DMARK
c034						CALLMONITOR 
c034 cd 6f ee			call debug_vector  
c037				endm  
# End of macro CALLMONITOR
c037					endif 
c037			 
c037 cd 62 9a				call forth_push_numhl 
c03a			 
c03a			 
c03a			 
c03a			 
c03a				       NEXTW 
c03a c3 1d 9e			jp macro_next 
c03d				endm 
# End of macro NEXTW
c03d			 
c03d			 
c03d			.ENDDISPLAY: 
c03d			 
c03d			; eof 
# End of file forth_words_display.asm
c03d			include "forth_words_str.asm" 
c03d			 
c03d			; | ## String Words 
c03d			 
c03d			.PTR:   
c03d			 
c03d				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c03d 48				db WORD_SYS_CORE+52             
c03e 6a c0			dw .STYPE            
c040 04				db 3 + 1 
c041 .. 00			db "PTR",0              
c045				endm 
# End of macro CWHEAD
c045			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c045			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c045			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c045			 
c045					if DEBUG_FORTH_WORDS_KEY 
c045						DMARK "PTR" 
c045 f5				push af  
c046 3a 5a c0			ld a, (.dmark)  
c049 32 6b ee			ld (debug_mark),a  
c04c 3a 5b c0			ld a, (.dmark+1)  
c04f 32 6c ee			ld (debug_mark+1),a  
c052 3a 5c c0			ld a, (.dmark+2)  
c055 32 6d ee			ld (debug_mark+2),a  
c058 18 03			jr .pastdmark  
c05a ..			.dmark: db "PTR"  
c05d f1			.pastdmark: pop af  
c05e			endm  
# End of macro DMARK
c05e						CALLMONITOR 
c05e cd 6f ee			call debug_vector  
c061				endm  
# End of macro CALLMONITOR
c061					endif 
c061					FORTH_DSP_VALUEHL 
c061 cd 67 9c			call macro_dsp_valuehl 
c064				endm 
# End of macro FORTH_DSP_VALUEHL
c064 cd 62 9a				call forth_push_numhl 
c067			 
c067			 
c067					NEXTW 
c067 c3 1d 9e			jp macro_next 
c06a				endm 
# End of macro NEXTW
c06a			.STYPE: 
c06a				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c06a 48				db WORD_SYS_CORE+52             
c06b b9 c0			dw .UPPER            
c06d 06				db 5 + 1 
c06e .. 00			db "STYPE",0              
c074				endm 
# End of macro CWHEAD
c074			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c074					if DEBUG_FORTH_WORDS_KEY 
c074						DMARK "STY" 
c074 f5				push af  
c075 3a 89 c0			ld a, (.dmark)  
c078 32 6b ee			ld (debug_mark),a  
c07b 3a 8a c0			ld a, (.dmark+1)  
c07e 32 6c ee			ld (debug_mark+1),a  
c081 3a 8b c0			ld a, (.dmark+2)  
c084 32 6d ee			ld (debug_mark+2),a  
c087 18 03			jr .pastdmark  
c089 ..			.dmark: db "STY"  
c08c f1			.pastdmark: pop af  
c08d			endm  
# End of macro DMARK
c08d						CALLMONITOR 
c08d cd 6f ee			call debug_vector  
c090				endm  
# End of macro CALLMONITOR
c090					endif 
c090					FORTH_DSP 
c090 cd 2d 9c			call macro_forth_dsp 
c093				endm 
# End of macro FORTH_DSP
c093					;v5 FORTH_DSP_VALUE 
c093			 
c093 7e					ld a, (hl) 
c094			 
c094 f5					push af 
c095			 
c095			; Dont destroy TOS		FORTH_DSP_POP 
c095			 
c095 f1					pop af 
c096			 
c096 fe 01				cp DS_TYPE_STR 
c098 28 09				jr z, .typestr 
c09a			 
c09a fe 02				cp DS_TYPE_INUM 
c09c 28 0a				jr z, .typeinum 
c09e			 
c09e 21 b7 c0				ld hl, .tna 
c0a1 18 0a				jr .tpush 
c0a3			 
c0a3 21 b3 c0		.typestr:	ld hl, .tstr 
c0a6 18 05				jr .tpush 
c0a8 21 b5 c0		.typeinum:	ld hl, .tinum 
c0ab 18 00				jr .tpush 
c0ad			 
c0ad			.tpush: 
c0ad			 
c0ad cd d0 9a				call forth_push_str 
c0b0			 
c0b0					NEXTW 
c0b0 c3 1d 9e			jp macro_next 
c0b3				endm 
# End of macro NEXTW
c0b3 .. 00		.tstr:	db "s",0 
c0b5 .. 00		.tinum:  db "i",0 
c0b7 .. 00		.tna:   db "?", 0 
c0b9			 
c0b9			 
c0b9			.UPPER: 
c0b9				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c0b9 48				db WORD_SYS_CORE+52             
c0ba f4 c0			dw .LOWER            
c0bc 06				db 5 + 1 
c0bd .. 00			db "UPPER",0              
c0c3				endm 
# End of macro CWHEAD
c0c3			; | UPPER ( s -- s ) Upper case string s  | DONE 
c0c3					if DEBUG_FORTH_WORDS_KEY 
c0c3						DMARK "UPR" 
c0c3 f5				push af  
c0c4 3a d8 c0			ld a, (.dmark)  
c0c7 32 6b ee			ld (debug_mark),a  
c0ca 3a d9 c0			ld a, (.dmark+1)  
c0cd 32 6c ee			ld (debug_mark+1),a  
c0d0 3a da c0			ld a, (.dmark+2)  
c0d3 32 6d ee			ld (debug_mark+2),a  
c0d6 18 03			jr .pastdmark  
c0d8 ..			.dmark: db "UPR"  
c0db f1			.pastdmark: pop af  
c0dc			endm  
# End of macro DMARK
c0dc						CALLMONITOR 
c0dc cd 6f ee			call debug_vector  
c0df				endm  
# End of macro CALLMONITOR
c0df					endif 
c0df			 
c0df					FORTH_DSP 
c0df cd 2d 9c			call macro_forth_dsp 
c0e2				endm 
# End of macro FORTH_DSP
c0e2					 
c0e2			; TODO check is string type 
c0e2			 
c0e2					FORTH_DSP_VALUEHL 
c0e2 cd 67 9c			call macro_dsp_valuehl 
c0e5				endm 
# End of macro FORTH_DSP_VALUEHL
c0e5			; get pointer to string in hl 
c0e5			 
c0e5 7e			.toup:		ld a, (hl) 
c0e6 fe 00				cp 0 
c0e8 28 07				jr z, .toupdone 
c0ea			 
c0ea cd 50 8f				call to_upper 
c0ed			 
c0ed 77					ld (hl), a 
c0ee 23					inc hl 
c0ef 18 f4				jr .toup 
c0f1			 
c0f1					 
c0f1			 
c0f1			 
c0f1			; for each char convert to upper 
c0f1					 
c0f1			.toupdone: 
c0f1			 
c0f1			 
c0f1					NEXTW 
c0f1 c3 1d 9e			jp macro_next 
c0f4				endm 
# End of macro NEXTW
c0f4			.LOWER: 
c0f4				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c0f4 48				db WORD_SYS_CORE+52             
c0f5 2f c1			dw .TCASE            
c0f7 06				db 5 + 1 
c0f8 .. 00			db "LOWER",0              
c0fe				endm 
# End of macro CWHEAD
c0fe			; | LOWER ( s -- s ) Lower case string s  | DONE 
c0fe					if DEBUG_FORTH_WORDS_KEY 
c0fe						DMARK "LWR" 
c0fe f5				push af  
c0ff 3a 13 c1			ld a, (.dmark)  
c102 32 6b ee			ld (debug_mark),a  
c105 3a 14 c1			ld a, (.dmark+1)  
c108 32 6c ee			ld (debug_mark+1),a  
c10b 3a 15 c1			ld a, (.dmark+2)  
c10e 32 6d ee			ld (debug_mark+2),a  
c111 18 03			jr .pastdmark  
c113 ..			.dmark: db "LWR"  
c116 f1			.pastdmark: pop af  
c117			endm  
# End of macro DMARK
c117						CALLMONITOR 
c117 cd 6f ee			call debug_vector  
c11a				endm  
# End of macro CALLMONITOR
c11a					endif 
c11a			 
c11a					FORTH_DSP 
c11a cd 2d 9c			call macro_forth_dsp 
c11d				endm 
# End of macro FORTH_DSP
c11d					 
c11d			; TODO check is string type 
c11d			 
c11d					FORTH_DSP_VALUEHL 
c11d cd 67 9c			call macro_dsp_valuehl 
c120				endm 
# End of macro FORTH_DSP_VALUEHL
c120			; get pointer to string in hl 
c120			 
c120 7e			.tolow:		ld a, (hl) 
c121 fe 00				cp 0 
c123 28 07				jr z, .tolowdone 
c125			 
c125 cd 59 8f				call to_lower 
c128			 
c128 77					ld (hl), a 
c129 23					inc hl 
c12a 18 f4				jr .tolow 
c12c			 
c12c					 
c12c			 
c12c			 
c12c			; for each char convert to low 
c12c					 
c12c			.tolowdone: 
c12c					NEXTW 
c12c c3 1d 9e			jp macro_next 
c12f				endm 
# End of macro NEXTW
c12f			.TCASE: 
c12f				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c12f 48				db WORD_SYS_CORE+52             
c130 65 c2			dw .SUBSTR            
c132 06				db 5 + 1 
c133 .. 00			db "TCASE",0              
c139				endm 
# End of macro CWHEAD
c139			; | TCASE ( s -- s ) Title case string s  | DONE 
c139					if DEBUG_FORTH_WORDS_KEY 
c139						DMARK "TCS" 
c139 f5				push af  
c13a 3a 4e c1			ld a, (.dmark)  
c13d 32 6b ee			ld (debug_mark),a  
c140 3a 4f c1			ld a, (.dmark+1)  
c143 32 6c ee			ld (debug_mark+1),a  
c146 3a 50 c1			ld a, (.dmark+2)  
c149 32 6d ee			ld (debug_mark+2),a  
c14c 18 03			jr .pastdmark  
c14e ..			.dmark: db "TCS"  
c151 f1			.pastdmark: pop af  
c152			endm  
# End of macro DMARK
c152						CALLMONITOR 
c152 cd 6f ee			call debug_vector  
c155				endm  
# End of macro CALLMONITOR
c155					endif 
c155			 
c155					FORTH_DSP 
c155 cd 2d 9c			call macro_forth_dsp 
c158				endm 
# End of macro FORTH_DSP
c158					 
c158			; TODO check is string type 
c158			 
c158					FORTH_DSP_VALUEHL 
c158 cd 67 9c			call macro_dsp_valuehl 
c15b				endm 
# End of macro FORTH_DSP_VALUEHL
c15b			; get pointer to string in hl 
c15b			 
c15b					if DEBUG_FORTH_WORDS 
c15b						DMARK "TC1" 
c15b f5				push af  
c15c 3a 70 c1			ld a, (.dmark)  
c15f 32 6b ee			ld (debug_mark),a  
c162 3a 71 c1			ld a, (.dmark+1)  
c165 32 6c ee			ld (debug_mark+1),a  
c168 3a 72 c1			ld a, (.dmark+2)  
c16b 32 6d ee			ld (debug_mark+2),a  
c16e 18 03			jr .pastdmark  
c170 ..			.dmark: db "TC1"  
c173 f1			.pastdmark: pop af  
c174			endm  
# End of macro DMARK
c174						CALLMONITOR 
c174 cd 6f ee			call debug_vector  
c177				endm  
# End of macro CALLMONITOR
c177					endif 
c177			 
c177					; first time in turn to upper case first char 
c177			 
c177 7e					ld a, (hl) 
c178 c3 02 c2				jp .totsiptou 
c17b			 
c17b			 
c17b 7e			.tot:		ld a, (hl) 
c17c fe 00				cp 0 
c17e ca 46 c2				jp z, .totdone 
c181			 
c181					if DEBUG_FORTH_WORDS 
c181						DMARK "TC2" 
c181 f5				push af  
c182 3a 96 c1			ld a, (.dmark)  
c185 32 6b ee			ld (debug_mark),a  
c188 3a 97 c1			ld a, (.dmark+1)  
c18b 32 6c ee			ld (debug_mark+1),a  
c18e 3a 98 c1			ld a, (.dmark+2)  
c191 32 6d ee			ld (debug_mark+2),a  
c194 18 03			jr .pastdmark  
c196 ..			.dmark: db "TC2"  
c199 f1			.pastdmark: pop af  
c19a			endm  
# End of macro DMARK
c19a						CALLMONITOR 
c19a cd 6f ee			call debug_vector  
c19d				endm  
# End of macro CALLMONITOR
c19d					endif 
c19d					; check to see if current char is a space 
c19d			 
c19d fe 20				cp ' ' 
c19f 28 21				jr z, .totsp 
c1a1 cd 59 8f				call to_lower 
c1a4					if DEBUG_FORTH_WORDS 
c1a4						DMARK "TC3" 
c1a4 f5				push af  
c1a5 3a b9 c1			ld a, (.dmark)  
c1a8 32 6b ee			ld (debug_mark),a  
c1ab 3a ba c1			ld a, (.dmark+1)  
c1ae 32 6c ee			ld (debug_mark+1),a  
c1b1 3a bb c1			ld a, (.dmark+2)  
c1b4 32 6d ee			ld (debug_mark+2),a  
c1b7 18 03			jr .pastdmark  
c1b9 ..			.dmark: db "TC3"  
c1bc f1			.pastdmark: pop af  
c1bd			endm  
# End of macro DMARK
c1bd						CALLMONITOR 
c1bd cd 6f ee			call debug_vector  
c1c0				endm  
# End of macro CALLMONITOR
c1c0					endif 
c1c0 18 63				jr .totnxt 
c1c2			 
c1c2			.totsp:         ; on a space, find next char which should be upper 
c1c2			 
c1c2					if DEBUG_FORTH_WORDS 
c1c2						DMARK "TC4" 
c1c2 f5				push af  
c1c3 3a d7 c1			ld a, (.dmark)  
c1c6 32 6b ee			ld (debug_mark),a  
c1c9 3a d8 c1			ld a, (.dmark+1)  
c1cc 32 6c ee			ld (debug_mark+1),a  
c1cf 3a d9 c1			ld a, (.dmark+2)  
c1d2 32 6d ee			ld (debug_mark+2),a  
c1d5 18 03			jr .pastdmark  
c1d7 ..			.dmark: db "TC4"  
c1da f1			.pastdmark: pop af  
c1db			endm  
# End of macro DMARK
c1db						CALLMONITOR 
c1db cd 6f ee			call debug_vector  
c1de				endm  
# End of macro CALLMONITOR
c1de					endif 
c1de					;; 
c1de			 
c1de fe 20				cp ' ' 
c1e0 20 20				jr nz, .totsiptou 
c1e2 23					inc hl 
c1e3 7e					ld a, (hl) 
c1e4					if DEBUG_FORTH_WORDS 
c1e4						DMARK "TC5" 
c1e4 f5				push af  
c1e5 3a f9 c1			ld a, (.dmark)  
c1e8 32 6b ee			ld (debug_mark),a  
c1eb 3a fa c1			ld a, (.dmark+1)  
c1ee 32 6c ee			ld (debug_mark+1),a  
c1f1 3a fb c1			ld a, (.dmark+2)  
c1f4 32 6d ee			ld (debug_mark+2),a  
c1f7 18 03			jr .pastdmark  
c1f9 ..			.dmark: db "TC5"  
c1fc f1			.pastdmark: pop af  
c1fd			endm  
# End of macro DMARK
c1fd						CALLMONITOR 
c1fd cd 6f ee			call debug_vector  
c200				endm  
# End of macro CALLMONITOR
c200					endif 
c200 18 c0				jr .totsp 
c202 fe 00		.totsiptou:    cp 0 
c204 28 40				jr z, .totdone 
c206					; not space and not zero term so upper case it 
c206 cd 50 8f				call to_upper 
c209			 
c209					if DEBUG_FORTH_WORDS 
c209						DMARK "TC6" 
c209 f5				push af  
c20a 3a 1e c2			ld a, (.dmark)  
c20d 32 6b ee			ld (debug_mark),a  
c210 3a 1f c2			ld a, (.dmark+1)  
c213 32 6c ee			ld (debug_mark+1),a  
c216 3a 20 c2			ld a, (.dmark+2)  
c219 32 6d ee			ld (debug_mark+2),a  
c21c 18 03			jr .pastdmark  
c21e ..			.dmark: db "TC6"  
c221 f1			.pastdmark: pop af  
c222			endm  
# End of macro DMARK
c222						CALLMONITOR 
c222 cd 6f ee			call debug_vector  
c225				endm  
# End of macro CALLMONITOR
c225					endif 
c225			 
c225			 
c225			.totnxt: 
c225			 
c225 77					ld (hl), a 
c226 23					inc hl 
c227					if DEBUG_FORTH_WORDS 
c227						DMARK "TC7" 
c227 f5				push af  
c228 3a 3c c2			ld a, (.dmark)  
c22b 32 6b ee			ld (debug_mark),a  
c22e 3a 3d c2			ld a, (.dmark+1)  
c231 32 6c ee			ld (debug_mark+1),a  
c234 3a 3e c2			ld a, (.dmark+2)  
c237 32 6d ee			ld (debug_mark+2),a  
c23a 18 03			jr .pastdmark  
c23c ..			.dmark: db "TC7"  
c23f f1			.pastdmark: pop af  
c240			endm  
# End of macro DMARK
c240						CALLMONITOR 
c240 cd 6f ee			call debug_vector  
c243				endm  
# End of macro CALLMONITOR
c243					endif 
c243 c3 7b c1				jp .tot 
c246			 
c246					 
c246			 
c246			 
c246			; for each char convert to low 
c246					 
c246			.totdone: 
c246					if DEBUG_FORTH_WORDS 
c246						DMARK "TCd" 
c246 f5				push af  
c247 3a 5b c2			ld a, (.dmark)  
c24a 32 6b ee			ld (debug_mark),a  
c24d 3a 5c c2			ld a, (.dmark+1)  
c250 32 6c ee			ld (debug_mark+1),a  
c253 3a 5d c2			ld a, (.dmark+2)  
c256 32 6d ee			ld (debug_mark+2),a  
c259 18 03			jr .pastdmark  
c25b ..			.dmark: db "TCd"  
c25e f1			.pastdmark: pop af  
c25f			endm  
# End of macro DMARK
c25f						CALLMONITOR 
c25f cd 6f ee			call debug_vector  
c262				endm  
# End of macro CALLMONITOR
c262					endif 
c262					NEXTW 
c262 c3 1d 9e			jp macro_next 
c265				endm 
# End of macro NEXTW
c265			 
c265			.SUBSTR: 
c265				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c265 48				db WORD_SYS_CORE+52             
c266 c3 c2			dw .LEFT            
c268 07				db 6 + 1 
c269 .. 00			db "SUBSTR",0              
c270				endm 
# End of macro CWHEAD
c270			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c270			 
c270					if DEBUG_FORTH_WORDS_KEY 
c270						DMARK "SST" 
c270 f5				push af  
c271 3a 85 c2			ld a, (.dmark)  
c274 32 6b ee			ld (debug_mark),a  
c277 3a 86 c2			ld a, (.dmark+1)  
c27a 32 6c ee			ld (debug_mark+1),a  
c27d 3a 87 c2			ld a, (.dmark+2)  
c280 32 6d ee			ld (debug_mark+2),a  
c283 18 03			jr .pastdmark  
c285 ..			.dmark: db "SST"  
c288 f1			.pastdmark: pop af  
c289			endm  
# End of macro DMARK
c289						CALLMONITOR 
c289 cd 6f ee			call debug_vector  
c28c				endm  
# End of macro CALLMONITOR
c28c					endif 
c28c			; TODO check string type 
c28c					FORTH_DSP_VALUEHL 
c28c cd 67 9c			call macro_dsp_valuehl 
c28f				endm 
# End of macro FORTH_DSP_VALUEHL
c28f			 
c28f e5					push hl      ; string length 
c290			 
c290					FORTH_DSP_POP 
c290 cd 1f 9d			call macro_forth_dsp_pop 
c293				endm 
# End of macro FORTH_DSP_POP
c293			 
c293					FORTH_DSP_VALUEHL 
c293 cd 67 9c			call macro_dsp_valuehl 
c296				endm 
# End of macro FORTH_DSP_VALUEHL
c296			 
c296 e5					push hl     ; start char 
c297			 
c297					FORTH_DSP_POP 
c297 cd 1f 9d			call macro_forth_dsp_pop 
c29a				endm 
# End of macro FORTH_DSP_POP
c29a			 
c29a			 
c29a					FORTH_DSP_VALUE 
c29a cd 50 9c			call macro_forth_dsp_value 
c29d				endm 
# End of macro FORTH_DSP_VALUE
c29d			 
c29d d1					pop de    ; get start post offset 
c29e			 
c29e 19					add hl, de    ; starting offset 
c29f			 
c29f c1					pop bc 
c2a0 c5					push bc      ; grab size of string 
c2a1			 
c2a1 e5					push hl    ; save string start  
c2a2			 
c2a2 26 00				ld h, 0 
c2a4 69					ld l, c 
c2a5 23					inc hl 
c2a6 23					inc hl 
c2a7			 
c2a7 cd b6 90				call malloc 
c2aa				if DEBUG_FORTH_MALLOC_GUARD 
c2aa cc dd cb				call z,malloc_error 
c2ad				endif 
c2ad			 
c2ad eb					ex de, hl      ; save malloc area for string copy 
c2ae e1					pop hl    ; get back source 
c2af c1					pop bc    ; get length of string back 
c2b0			 
c2b0 d5					push de    ; save malloc area for after we push 
c2b1 ed b0				ldir     ; copy substr 
c2b3			 
c2b3			 
c2b3 eb					ex de, hl 
c2b4 3e 00				ld a, 0 
c2b6 77					ld (hl), a   ; term substr 
c2b7			 
c2b7					 
c2b7 e1					pop hl    ; get malloc so we can push it 
c2b8 e5					push hl   ; save so we can free it afterwards 
c2b9			 
c2b9 cd d0 9a				call forth_push_str 
c2bc			 
c2bc e1					pop hl 
c2bd cd 80 91				call free 
c2c0			 
c2c0					 
c2c0					 
c2c0			 
c2c0			 
c2c0					NEXTW 
c2c0 c3 1d 9e			jp macro_next 
c2c3				endm 
# End of macro NEXTW
c2c3			 
c2c3			.LEFT: 
c2c3				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c2c3 48				db WORD_SYS_CORE+52             
c2c4 eb c2			dw .RIGHT            
c2c6 05				db 4 + 1 
c2c7 .. 00			db "LEFT",0              
c2cc				endm 
# End of macro CWHEAD
c2cc			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c2cc					if DEBUG_FORTH_WORDS_KEY 
c2cc						DMARK "LEF" 
c2cc f5				push af  
c2cd 3a e1 c2			ld a, (.dmark)  
c2d0 32 6b ee			ld (debug_mark),a  
c2d3 3a e2 c2			ld a, (.dmark+1)  
c2d6 32 6c ee			ld (debug_mark+1),a  
c2d9 3a e3 c2			ld a, (.dmark+2)  
c2dc 32 6d ee			ld (debug_mark+2),a  
c2df 18 03			jr .pastdmark  
c2e1 ..			.dmark: db "LEF"  
c2e4 f1			.pastdmark: pop af  
c2e5			endm  
# End of macro DMARK
c2e5						CALLMONITOR 
c2e5 cd 6f ee			call debug_vector  
c2e8				endm  
# End of macro CALLMONITOR
c2e8					endif 
c2e8			 
c2e8					NEXTW 
c2e8 c3 1d 9e			jp macro_next 
c2eb				endm 
# End of macro NEXTW
c2eb			.RIGHT: 
c2eb				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c2eb 48				db WORD_SYS_CORE+52             
c2ec 14 c3			dw .STR2NUM            
c2ee 06				db 5 + 1 
c2ef .. 00			db "RIGHT",0              
c2f5				endm 
# End of macro CWHEAD
c2f5			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c2f5					if DEBUG_FORTH_WORDS_KEY 
c2f5						DMARK "RIG" 
c2f5 f5				push af  
c2f6 3a 0a c3			ld a, (.dmark)  
c2f9 32 6b ee			ld (debug_mark),a  
c2fc 3a 0b c3			ld a, (.dmark+1)  
c2ff 32 6c ee			ld (debug_mark+1),a  
c302 3a 0c c3			ld a, (.dmark+2)  
c305 32 6d ee			ld (debug_mark+2),a  
c308 18 03			jr .pastdmark  
c30a ..			.dmark: db "RIG"  
c30d f1			.pastdmark: pop af  
c30e			endm  
# End of macro DMARK
c30e						CALLMONITOR 
c30e cd 6f ee			call debug_vector  
c311				endm  
# End of macro CALLMONITOR
c311					endif 
c311			 
c311					NEXTW 
c311 c3 1d 9e			jp macro_next 
c314				endm 
# End of macro NEXTW
c314			 
c314			 
c314			.STR2NUM: 
c314				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c314 48				db WORD_SYS_CORE+52             
c315 a0 c3			dw .NUM2STR            
c317 08				db 7 + 1 
c318 .. 00			db "STR2NUM",0              
c320				endm 
# End of macro CWHEAD
c320			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c320			 
c320			 
c320			; TODO STR type check to do 
c320					if DEBUG_FORTH_WORDS_KEY 
c320						DMARK "S2N" 
c320 f5				push af  
c321 3a 35 c3			ld a, (.dmark)  
c324 32 6b ee			ld (debug_mark),a  
c327 3a 36 c3			ld a, (.dmark+1)  
c32a 32 6c ee			ld (debug_mark+1),a  
c32d 3a 37 c3			ld a, (.dmark+2)  
c330 32 6d ee			ld (debug_mark+2),a  
c333 18 03			jr .pastdmark  
c335 ..			.dmark: db "S2N"  
c338 f1			.pastdmark: pop af  
c339			endm  
# End of macro DMARK
c339						CALLMONITOR 
c339 cd 6f ee			call debug_vector  
c33c				endm  
# End of macro CALLMONITOR
c33c					endif 
c33c			 
c33c					;FORTH_DSP 
c33c					FORTH_DSP_VALUE 
c33c cd 50 9c			call macro_forth_dsp_value 
c33f				endm 
# End of macro FORTH_DSP_VALUE
c33f					;inc hl 
c33f			 
c33f eb					ex de, hl 
c340					if DEBUG_FORTH_WORDS 
c340						DMARK "S2a" 
c340 f5				push af  
c341 3a 55 c3			ld a, (.dmark)  
c344 32 6b ee			ld (debug_mark),a  
c347 3a 56 c3			ld a, (.dmark+1)  
c34a 32 6c ee			ld (debug_mark+1),a  
c34d 3a 57 c3			ld a, (.dmark+2)  
c350 32 6d ee			ld (debug_mark+2),a  
c353 18 03			jr .pastdmark  
c355 ..			.dmark: db "S2a"  
c358 f1			.pastdmark: pop af  
c359			endm  
# End of macro DMARK
c359						CALLMONITOR 
c359 cd 6f ee			call debug_vector  
c35c				endm  
# End of macro CALLMONITOR
c35c					endif 
c35c cd d8 8f				call string_to_uint16 
c35f			 
c35f					if DEBUG_FORTH_WORDS 
c35f						DMARK "S2b" 
c35f f5				push af  
c360 3a 74 c3			ld a, (.dmark)  
c363 32 6b ee			ld (debug_mark),a  
c366 3a 75 c3			ld a, (.dmark+1)  
c369 32 6c ee			ld (debug_mark+1),a  
c36c 3a 76 c3			ld a, (.dmark+2)  
c36f 32 6d ee			ld (debug_mark+2),a  
c372 18 03			jr .pastdmark  
c374 ..			.dmark: db "S2b"  
c377 f1			.pastdmark: pop af  
c378			endm  
# End of macro DMARK
c378						CALLMONITOR 
c378 cd 6f ee			call debug_vector  
c37b				endm  
# End of macro CALLMONITOR
c37b					endif 
c37b			;		push hl 
c37b					FORTH_DSP_POP 
c37b cd 1f 9d			call macro_forth_dsp_pop 
c37e				endm 
# End of macro FORTH_DSP_POP
c37e			;		pop hl 
c37e					 
c37e					if DEBUG_FORTH_WORDS 
c37e						DMARK "S2b" 
c37e f5				push af  
c37f 3a 93 c3			ld a, (.dmark)  
c382 32 6b ee			ld (debug_mark),a  
c385 3a 94 c3			ld a, (.dmark+1)  
c388 32 6c ee			ld (debug_mark+1),a  
c38b 3a 95 c3			ld a, (.dmark+2)  
c38e 32 6d ee			ld (debug_mark+2),a  
c391 18 03			jr .pastdmark  
c393 ..			.dmark: db "S2b"  
c396 f1			.pastdmark: pop af  
c397			endm  
# End of macro DMARK
c397						CALLMONITOR 
c397 cd 6f ee			call debug_vector  
c39a				endm  
# End of macro CALLMONITOR
c39a					endif 
c39a cd 62 9a				call forth_push_numhl	 
c39d			 
c39d				 
c39d				       NEXTW 
c39d c3 1d 9e			jp macro_next 
c3a0				endm 
# End of macro NEXTW
c3a0			.NUM2STR: 
c3a0				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c3a0 48				db WORD_SYS_CORE+52             
c3a1 af c3			dw .CONCAT            
c3a3 08				db 7 + 1 
c3a4 .. 00			db "NUM2STR",0              
c3ac				endm 
# End of macro CWHEAD
c3ac			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
c3ac			 
c3ac			;		; malloc a string to target 
c3ac			;		ld hl, 10     ; TODO max string size should be fine 
c3ac			;		call malloc 
c3ac			;		push hl    ; save malloc location 
c3ac			; 
c3ac			; 
c3ac			;; TODO check int type 
c3ac			;		FORTH_DSP_VALUEHL 
c3ac			;		ld a, l 
c3ac			;		call DispAToASCII   
c3ac			;;TODO need to chage above call to dump into string 
c3ac			; 
c3ac			; 
c3ac			 
c3ac				       NEXTW 
c3ac c3 1d 9e			jp macro_next 
c3af				endm 
# End of macro NEXTW
c3af			 
c3af			.CONCAT: 
c3af				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c3af 48				db WORD_SYS_CORE+52             
c3b0 62 c4			dw .FIND            
c3b2 07				db 6 + 1 
c3b3 .. 00			db "CONCAT",0              
c3ba				endm 
# End of macro CWHEAD
c3ba			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c3ba			 
c3ba			; TODO check string type 
c3ba			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c3ba			 
c3ba					if DEBUG_FORTH_WORDS_KEY 
c3ba						DMARK "CON" 
c3ba f5				push af  
c3bb 3a cf c3			ld a, (.dmark)  
c3be 32 6b ee			ld (debug_mark),a  
c3c1 3a d0 c3			ld a, (.dmark+1)  
c3c4 32 6c ee			ld (debug_mark+1),a  
c3c7 3a d1 c3			ld a, (.dmark+2)  
c3ca 32 6d ee			ld (debug_mark+2),a  
c3cd 18 03			jr .pastdmark  
c3cf ..			.dmark: db "CON"  
c3d2 f1			.pastdmark: pop af  
c3d3			endm  
# End of macro DMARK
c3d3						CALLMONITOR 
c3d3 cd 6f ee			call debug_vector  
c3d6				endm  
# End of macro CALLMONITOR
c3d6					endif 
c3d6			 
c3d6			 
c3d6					FORTH_DSP_VALUE 
c3d6 cd 50 9c			call macro_forth_dsp_value 
c3d9				endm 
# End of macro FORTH_DSP_VALUE
c3d9 e5					push hl   ; s2 
c3da			 
c3da					FORTH_DSP_POP 
c3da cd 1f 9d			call macro_forth_dsp_pop 
c3dd				endm 
# End of macro FORTH_DSP_POP
c3dd			 
c3dd					FORTH_DSP_VALUE 
c3dd cd 50 9c			call macro_forth_dsp_value 
c3e0				endm 
# End of macro FORTH_DSP_VALUE
c3e0			 
c3e0 e5					push hl   ; s1 
c3e1			 
c3e1					FORTH_DSP_POP 
c3e1 cd 1f 9d			call macro_forth_dsp_pop 
c3e4				endm 
# End of macro FORTH_DSP_POP
c3e4					 
c3e4			 
c3e4					; copy s1 
c3e4			 
c3e4				 
c3e4					; save ptr 
c3e4 e1					pop hl  
c3e5 e5					push hl 
c3e6 3e 00				ld a, 0 
c3e8 cd 4c 90				call strlent 
c3eb					;inc hl    ; zer0 
c3eb 06 00				ld b, 0 
c3ed 4d					ld c, l 
c3ee e1					pop hl		 
c3ef 11 c1 e2				ld de, scratch	 
c3f2					if DEBUG_FORTH_WORDS 
c3f2						DMARK "CO1" 
c3f2 f5				push af  
c3f3 3a 07 c4			ld a, (.dmark)  
c3f6 32 6b ee			ld (debug_mark),a  
c3f9 3a 08 c4			ld a, (.dmark+1)  
c3fc 32 6c ee			ld (debug_mark+1),a  
c3ff 3a 09 c4			ld a, (.dmark+2)  
c402 32 6d ee			ld (debug_mark+2),a  
c405 18 03			jr .pastdmark  
c407 ..			.dmark: db "CO1"  
c40a f1			.pastdmark: pop af  
c40b			endm  
# End of macro DMARK
c40b						CALLMONITOR 
c40b cd 6f ee			call debug_vector  
c40e				endm  
# End of macro CALLMONITOR
c40e					endif 
c40e ed b0				ldir 
c410			 
c410 e1					pop hl 
c411 e5					push hl 
c412 d5					push de 
c413			 
c413			 
c413 3e 00				ld a, 0 
c415 cd 4c 90				call strlent 
c418 23					inc hl    ; zer0 
c419 23					inc hl 
c41a 06 00				ld b, 0 
c41c 4d					ld c, l 
c41d d1					pop de 
c41e e1					pop hl		 
c41f					if DEBUG_FORTH_WORDS 
c41f						DMARK "CO2" 
c41f f5				push af  
c420 3a 34 c4			ld a, (.dmark)  
c423 32 6b ee			ld (debug_mark),a  
c426 3a 35 c4			ld a, (.dmark+1)  
c429 32 6c ee			ld (debug_mark+1),a  
c42c 3a 36 c4			ld a, (.dmark+2)  
c42f 32 6d ee			ld (debug_mark+2),a  
c432 18 03			jr .pastdmark  
c434 ..			.dmark: db "CO2"  
c437 f1			.pastdmark: pop af  
c438			endm  
# End of macro DMARK
c438						CALLMONITOR 
c438 cd 6f ee			call debug_vector  
c43b				endm  
# End of macro CALLMONITOR
c43b					endif 
c43b ed b0				ldir 
c43d			 
c43d			 
c43d			 
c43d 21 c1 e2				ld hl, scratch 
c440					if DEBUG_FORTH_WORDS 
c440						DMARK "CO5" 
c440 f5				push af  
c441 3a 55 c4			ld a, (.dmark)  
c444 32 6b ee			ld (debug_mark),a  
c447 3a 56 c4			ld a, (.dmark+1)  
c44a 32 6c ee			ld (debug_mark+1),a  
c44d 3a 57 c4			ld a, (.dmark+2)  
c450 32 6d ee			ld (debug_mark+2),a  
c453 18 03			jr .pastdmark  
c455 ..			.dmark: db "CO5"  
c458 f1			.pastdmark: pop af  
c459			endm  
# End of macro DMARK
c459						CALLMONITOR 
c459 cd 6f ee			call debug_vector  
c45c				endm  
# End of macro CALLMONITOR
c45c					endif 
c45c			 
c45c cd d0 9a				call forth_push_str 
c45f			 
c45f			 
c45f			 
c45f			 
c45f				       NEXTW 
c45f c3 1d 9e			jp macro_next 
c462				endm 
# End of macro NEXTW
c462			 
c462			 
c462			.FIND: 
c462				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c462 4b				db WORD_SYS_CORE+55             
c463 20 c5			dw .LEN            
c465 05				db 4 + 1 
c466 .. 00			db "FIND",0              
c46b				endm 
# End of macro CWHEAD
c46b			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c46b			 
c46b					if DEBUG_FORTH_WORDS_KEY 
c46b						DMARK "FND" 
c46b f5				push af  
c46c 3a 80 c4			ld a, (.dmark)  
c46f 32 6b ee			ld (debug_mark),a  
c472 3a 81 c4			ld a, (.dmark+1)  
c475 32 6c ee			ld (debug_mark+1),a  
c478 3a 82 c4			ld a, (.dmark+2)  
c47b 32 6d ee			ld (debug_mark+2),a  
c47e 18 03			jr .pastdmark  
c480 ..			.dmark: db "FND"  
c483 f1			.pastdmark: pop af  
c484			endm  
# End of macro DMARK
c484						CALLMONITOR 
c484 cd 6f ee			call debug_vector  
c487				endm  
# End of macro CALLMONITOR
c487					endif 
c487			 
c487			; TODO check string type 
c487					FORTH_DSP_VALUE 
c487 cd 50 9c			call macro_forth_dsp_value 
c48a				endm 
# End of macro FORTH_DSP_VALUE
c48a			 
c48a e5					push hl    
c48b 7e					ld a,(hl)    ; char to find   
c48c			; TODO change char to substr 
c48c			 
c48c f5					push af 
c48d					 
c48d			 
c48d			 
c48d					if DEBUG_FORTH_WORDS 
c48d						DMARK "FN1" 
c48d f5				push af  
c48e 3a a2 c4			ld a, (.dmark)  
c491 32 6b ee			ld (debug_mark),a  
c494 3a a3 c4			ld a, (.dmark+1)  
c497 32 6c ee			ld (debug_mark+1),a  
c49a 3a a4 c4			ld a, (.dmark+2)  
c49d 32 6d ee			ld (debug_mark+2),a  
c4a0 18 03			jr .pastdmark  
c4a2 ..			.dmark: db "FN1"  
c4a5 f1			.pastdmark: pop af  
c4a6			endm  
# End of macro DMARK
c4a6						CALLMONITOR 
c4a6 cd 6f ee			call debug_vector  
c4a9				endm  
# End of macro CALLMONITOR
c4a9					endif 
c4a9			 
c4a9					FORTH_DSP_POP 
c4a9 cd 1f 9d			call macro_forth_dsp_pop 
c4ac				endm 
# End of macro FORTH_DSP_POP
c4ac			 
c4ac					; string to search 
c4ac			 
c4ac					FORTH_DSP_VALUE 
c4ac cd 50 9c			call macro_forth_dsp_value 
c4af				endm 
# End of macro FORTH_DSP_VALUE
c4af			 
c4af d1					pop de  ; d is char to find  
c4b0			 
c4b0					if DEBUG_FORTH_WORDS 
c4b0						DMARK "FN2" 
c4b0 f5				push af  
c4b1 3a c5 c4			ld a, (.dmark)  
c4b4 32 6b ee			ld (debug_mark),a  
c4b7 3a c6 c4			ld a, (.dmark+1)  
c4ba 32 6c ee			ld (debug_mark+1),a  
c4bd 3a c7 c4			ld a, (.dmark+2)  
c4c0 32 6d ee			ld (debug_mark+2),a  
c4c3 18 03			jr .pastdmark  
c4c5 ..			.dmark: db "FN2"  
c4c8 f1			.pastdmark: pop af  
c4c9			endm  
# End of macro DMARK
c4c9						CALLMONITOR 
c4c9 cd 6f ee			call debug_vector  
c4cc				endm  
# End of macro CALLMONITOR
c4cc					endif 
c4cc					 
c4cc 01 00 00				ld bc, 0 
c4cf 7e			.findchar:      ld a,(hl) 
c4d0 fe 00				cp 0   		 
c4d2 28 27				jr z, .finddone     
c4d4 ba					cp d 
c4d5 28 20				jr z, .foundchar 
c4d7 03					inc bc 
c4d8 23					inc hl 
c4d9					if DEBUG_FORTH_WORDS 
c4d9						DMARK "FN3" 
c4d9 f5				push af  
c4da 3a ee c4			ld a, (.dmark)  
c4dd 32 6b ee			ld (debug_mark),a  
c4e0 3a ef c4			ld a, (.dmark+1)  
c4e3 32 6c ee			ld (debug_mark+1),a  
c4e6 3a f0 c4			ld a, (.dmark+2)  
c4e9 32 6d ee			ld (debug_mark+2),a  
c4ec 18 03			jr .pastdmark  
c4ee ..			.dmark: db "FN3"  
c4f1 f1			.pastdmark: pop af  
c4f2			endm  
# End of macro DMARK
c4f2						CALLMONITOR 
c4f2 cd 6f ee			call debug_vector  
c4f5				endm  
# End of macro CALLMONITOR
c4f5					endif 
c4f5 18 d8				jr .findchar 
c4f7			 
c4f7			 
c4f7 c5			.foundchar:	push bc 
c4f8 e1					pop hl 
c4f9 18 03				jr .findexit 
c4fb			 
c4fb			 
c4fb							 
c4fb			 
c4fb			.finddone:     ; got to end of string with no find 
c4fb 21 00 00				ld hl, 0 
c4fe			.findexit: 
c4fe			 
c4fe					if DEBUG_FORTH_WORDS 
c4fe						DMARK "FNd" 
c4fe f5				push af  
c4ff 3a 13 c5			ld a, (.dmark)  
c502 32 6b ee			ld (debug_mark),a  
c505 3a 14 c5			ld a, (.dmark+1)  
c508 32 6c ee			ld (debug_mark+1),a  
c50b 3a 15 c5			ld a, (.dmark+2)  
c50e 32 6d ee			ld (debug_mark+2),a  
c511 18 03			jr .pastdmark  
c513 ..			.dmark: db "FNd"  
c516 f1			.pastdmark: pop af  
c517			endm  
# End of macro DMARK
c517						CALLMONITOR 
c517 cd 6f ee			call debug_vector  
c51a				endm  
# End of macro CALLMONITOR
c51a					endif 
c51a cd 62 9a			call forth_push_numhl 
c51d			 
c51d				       NEXTW 
c51d c3 1d 9e			jp macro_next 
c520				endm 
# End of macro NEXTW
c520			 
c520			.LEN: 
c520				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c520 4c				db WORD_SYS_CORE+56             
c521 8a c5			dw .ASC            
c523 06				db 5 + 1 
c524 .. 00			db "COUNT",0              
c52a				endm 
# End of macro CWHEAD
c52a			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c52a			 
c52a					if DEBUG_FORTH_WORDS_KEY 
c52a						DMARK "CNT" 
c52a f5				push af  
c52b 3a 3f c5			ld a, (.dmark)  
c52e 32 6b ee			ld (debug_mark),a  
c531 3a 40 c5			ld a, (.dmark+1)  
c534 32 6c ee			ld (debug_mark+1),a  
c537 3a 41 c5			ld a, (.dmark+2)  
c53a 32 6d ee			ld (debug_mark+2),a  
c53d 18 03			jr .pastdmark  
c53f ..			.dmark: db "CNT"  
c542 f1			.pastdmark: pop af  
c543			endm  
# End of macro DMARK
c543						CALLMONITOR 
c543 cd 6f ee			call debug_vector  
c546				endm  
# End of macro CALLMONITOR
c546					endif 
c546			; TODO check string type 
c546					FORTH_DSP_VALUE 
c546 cd 50 9c			call macro_forth_dsp_value 
c549				endm 
# End of macro FORTH_DSP_VALUE
c549			 
c549			 
c549					if DEBUG_FORTH_WORDS 
c549						DMARK "CN?" 
c549 f5				push af  
c54a 3a 5e c5			ld a, (.dmark)  
c54d 32 6b ee			ld (debug_mark),a  
c550 3a 5f c5			ld a, (.dmark+1)  
c553 32 6c ee			ld (debug_mark+1),a  
c556 3a 60 c5			ld a, (.dmark+2)  
c559 32 6d ee			ld (debug_mark+2),a  
c55c 18 03			jr .pastdmark  
c55e ..			.dmark: db "CN?"  
c561 f1			.pastdmark: pop af  
c562			endm  
# End of macro DMARK
c562						CALLMONITOR 
c562 cd 6f ee			call debug_vector  
c565				endm  
# End of macro CALLMONITOR
c565					endif 
c565 cd 41 90				call strlenz 
c568					if DEBUG_FORTH_WORDS 
c568						DMARK "CNl" 
c568 f5				push af  
c569 3a 7d c5			ld a, (.dmark)  
c56c 32 6b ee			ld (debug_mark),a  
c56f 3a 7e c5			ld a, (.dmark+1)  
c572 32 6c ee			ld (debug_mark+1),a  
c575 3a 7f c5			ld a, (.dmark+2)  
c578 32 6d ee			ld (debug_mark+2),a  
c57b 18 03			jr .pastdmark  
c57d ..			.dmark: db "CNl"  
c580 f1			.pastdmark: pop af  
c581			endm  
# End of macro DMARK
c581						CALLMONITOR 
c581 cd 6f ee			call debug_vector  
c584				endm  
# End of macro CALLMONITOR
c584					endif 
c584			 
c584 cd 62 9a				call forth_push_numhl 
c587			 
c587			 
c587			 
c587				       NEXTW 
c587 c3 1d 9e			jp macro_next 
c58a				endm 
# End of macro NEXTW
c58a			.ASC: 
c58a				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c58a 4d				db WORD_SYS_CORE+57             
c58b f8 c5			dw .CHR            
c58d 04				db 3 + 1 
c58e .. 00			db "ASC",0              
c592				endm 
# End of macro CWHEAD
c592			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
c592					if DEBUG_FORTH_WORDS_KEY 
c592						DMARK "ASC" 
c592 f5				push af  
c593 3a a7 c5			ld a, (.dmark)  
c596 32 6b ee			ld (debug_mark),a  
c599 3a a8 c5			ld a, (.dmark+1)  
c59c 32 6c ee			ld (debug_mark+1),a  
c59f 3a a9 c5			ld a, (.dmark+2)  
c5a2 32 6d ee			ld (debug_mark+2),a  
c5a5 18 03			jr .pastdmark  
c5a7 ..			.dmark: db "ASC"  
c5aa f1			.pastdmark: pop af  
c5ab			endm  
# End of macro DMARK
c5ab						CALLMONITOR 
c5ab cd 6f ee			call debug_vector  
c5ae				endm  
# End of macro CALLMONITOR
c5ae					endif 
c5ae					FORTH_DSP_VALUE 
c5ae cd 50 9c			call macro_forth_dsp_value 
c5b1				endm 
# End of macro FORTH_DSP_VALUE
c5b1					;v5 FORTH_DSP_VALUE 
c5b1			;		inc hl      ; now at start of numeric as string 
c5b1			 
c5b1 e5					push hl 
c5b2			 
c5b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5b2 cd 1f 9d			call macro_forth_dsp_pop 
c5b5				endm 
# End of macro FORTH_DSP_POP
c5b5			 
c5b5 e1					pop hl 
c5b6			 
c5b6					if DEBUG_FORTH_WORDS 
c5b6						DMARK "AS1" 
c5b6 f5				push af  
c5b7 3a cb c5			ld a, (.dmark)  
c5ba 32 6b ee			ld (debug_mark),a  
c5bd 3a cc c5			ld a, (.dmark+1)  
c5c0 32 6c ee			ld (debug_mark+1),a  
c5c3 3a cd c5			ld a, (.dmark+2)  
c5c6 32 6d ee			ld (debug_mark+2),a  
c5c9 18 03			jr .pastdmark  
c5cb ..			.dmark: db "AS1"  
c5ce f1			.pastdmark: pop af  
c5cf			endm  
# End of macro DMARK
c5cf						CALLMONITOR 
c5cf cd 6f ee			call debug_vector  
c5d2				endm  
# End of macro CALLMONITOR
c5d2					endif 
c5d2					; push the content of a onto the stack as a value 
c5d2			 
c5d2 7e					ld a,(hl)   ; get char 
c5d3 26 00				ld h,0 
c5d5 6f					ld l,a 
c5d6					if DEBUG_FORTH_WORDS 
c5d6						DMARK "AS2" 
c5d6 f5				push af  
c5d7 3a eb c5			ld a, (.dmark)  
c5da 32 6b ee			ld (debug_mark),a  
c5dd 3a ec c5			ld a, (.dmark+1)  
c5e0 32 6c ee			ld (debug_mark+1),a  
c5e3 3a ed c5			ld a, (.dmark+2)  
c5e6 32 6d ee			ld (debug_mark+2),a  
c5e9 18 03			jr .pastdmark  
c5eb ..			.dmark: db "AS2"  
c5ee f1			.pastdmark: pop af  
c5ef			endm  
# End of macro DMARK
c5ef						CALLMONITOR 
c5ef cd 6f ee			call debug_vector  
c5f2				endm  
# End of macro CALLMONITOR
c5f2					endif 
c5f2 cd 62 9a				call forth_push_numhl 
c5f5			 
c5f5				       NEXTW 
c5f5 c3 1d 9e			jp macro_next 
c5f8				endm 
# End of macro NEXTW
c5f8			 
c5f8			.CHR: 
c5f8				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c5f8 4d				db WORD_SYS_CORE+57             
c5f9 34 c6			dw .ENDSTR            
c5fb 04				db 3 + 1 
c5fc .. 00			db "CHR",0              
c600				endm 
# End of macro CWHEAD
c600			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c600					if DEBUG_FORTH_WORDS_KEY 
c600						DMARK "CHR" 
c600 f5				push af  
c601 3a 15 c6			ld a, (.dmark)  
c604 32 6b ee			ld (debug_mark),a  
c607 3a 16 c6			ld a, (.dmark+1)  
c60a 32 6c ee			ld (debug_mark+1),a  
c60d 3a 17 c6			ld a, (.dmark+2)  
c610 32 6d ee			ld (debug_mark+2),a  
c613 18 03			jr .pastdmark  
c615 ..			.dmark: db "CHR"  
c618 f1			.pastdmark: pop af  
c619			endm  
# End of macro DMARK
c619						CALLMONITOR 
c619 cd 6f ee			call debug_vector  
c61c				endm  
# End of macro CALLMONITOR
c61c					endif 
c61c					FORTH_DSP_VALUEHL 
c61c cd 67 9c			call macro_dsp_valuehl 
c61f				endm 
# End of macro FORTH_DSP_VALUEHL
c61f			 
c61f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c61f cd 1f 9d			call macro_forth_dsp_pop 
c622				endm 
# End of macro FORTH_DSP_POP
c622			 
c622					; save asci byte as a zero term string and push string 
c622			 
c622 7d					ld a,l 
c623 32 c1 e2				ld (scratch), a 
c626			 
c626 3e 00				ld a, 0 
c628 32 c2 e2				ld (scratch+1), a 
c62b			 
c62b 21 c1 e2				ld hl, scratch 
c62e cd d0 9a				call forth_push_str 
c631			 
c631			 
c631				       NEXTW 
c631 c3 1d 9e			jp macro_next 
c634				endm 
# End of macro NEXTW
c634			 
c634			 
c634			 
c634			 
c634			.ENDSTR: 
c634			; eof 
c634			 
# End of file forth_words_str.asm
c634			include "forth_words_key.asm" 
c634			 
c634			; | ## Keyboard Words 
c634			 
c634			.KEY: 
c634				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c634 3e				db WORD_SYS_CORE+42             
c635 64 c6			dw .WAITK            
c637 04				db 3 + 1 
c638 .. 00			db "KEY",0              
c63c				endm 
# End of macro CWHEAD
c63c			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c63c			 
c63c					if DEBUG_FORTH_WORDS_KEY 
c63c						DMARK "KEY" 
c63c f5				push af  
c63d 3a 51 c6			ld a, (.dmark)  
c640 32 6b ee			ld (debug_mark),a  
c643 3a 52 c6			ld a, (.dmark+1)  
c646 32 6c ee			ld (debug_mark+1),a  
c649 3a 53 c6			ld a, (.dmark+2)  
c64c 32 6d ee			ld (debug_mark+2),a  
c64f 18 03			jr .pastdmark  
c651 ..			.dmark: db "KEY"  
c654 f1			.pastdmark: pop af  
c655			endm  
# End of macro DMARK
c655						CALLMONITOR 
c655 cd 6f ee			call debug_vector  
c658				endm  
# End of macro CALLMONITOR
c658					endif 
c658			; TODO currently waits 
c658 cd 02 dd				call cin 
c65b					;call cin_wait 
c65b 6f					ld l, a 
c65c 26 00				ld h, 0 
c65e cd 62 9a				call forth_push_numhl 
c661					NEXTW 
c661 c3 1d 9e			jp macro_next 
c664				endm 
# End of macro NEXTW
c664			.WAITK: 
c664				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c664 3f				db WORD_SYS_CORE+43             
c665 96 c6			dw .ACCEPT            
c667 06				db 5 + 1 
c668 .. 00			db "WAITK",0              
c66e				endm 
# End of macro CWHEAD
c66e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c66e					if DEBUG_FORTH_WORDS_KEY 
c66e						DMARK "WAI" 
c66e f5				push af  
c66f 3a 83 c6			ld a, (.dmark)  
c672 32 6b ee			ld (debug_mark),a  
c675 3a 84 c6			ld a, (.dmark+1)  
c678 32 6c ee			ld (debug_mark+1),a  
c67b 3a 85 c6			ld a, (.dmark+2)  
c67e 32 6d ee			ld (debug_mark+2),a  
c681 18 03			jr .pastdmark  
c683 ..			.dmark: db "WAI"  
c686 f1			.pastdmark: pop af  
c687			endm  
# End of macro DMARK
c687						CALLMONITOR 
c687 cd 6f ee			call debug_vector  
c68a				endm  
# End of macro CALLMONITOR
c68a					endif 
c68a cd fc dc				call cin_wait 
c68d 6f					ld l, a 
c68e 26 00				ld h, 0 
c690 cd 62 9a				call forth_push_numhl 
c693					NEXTW 
c693 c3 1d 9e			jp macro_next 
c696				endm 
# End of macro NEXTW
c696			.ACCEPT: 
c696				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c696 40				db WORD_SYS_CORE+44             
c697 f4 c6			dw .EDIT            
c699 07				db 6 + 1 
c69a .. 00			db "ACCEPT",0              
c6a1				endm 
# End of macro CWHEAD
c6a1			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c6a1					; TODO crashes on push 
c6a1					if DEBUG_FORTH_WORDS_KEY 
c6a1						DMARK "ACC" 
c6a1 f5				push af  
c6a2 3a b6 c6			ld a, (.dmark)  
c6a5 32 6b ee			ld (debug_mark),a  
c6a8 3a b7 c6			ld a, (.dmark+1)  
c6ab 32 6c ee			ld (debug_mark+1),a  
c6ae 3a b8 c6			ld a, (.dmark+2)  
c6b1 32 6d ee			ld (debug_mark+2),a  
c6b4 18 03			jr .pastdmark  
c6b6 ..			.dmark: db "ACC"  
c6b9 f1			.pastdmark: pop af  
c6ba			endm  
# End of macro DMARK
c6ba						CALLMONITOR 
c6ba cd 6f ee			call debug_vector  
c6bd				endm  
# End of macro CALLMONITOR
c6bd					endif 
c6bd 21 bf e4				ld hl, os_input 
c6c0 3e 00				ld a, 0 
c6c2 77					ld (hl),a 
c6c3 3a 5e ea				ld a,(f_cursor_ptr) 
c6c6 16 64				ld d, 100 
c6c8 0e 00				ld c, 0 
c6ca 1e 28				ld e, 40 
c6cc cd 08 8d				call input_str 
c6cf					; TODO perhaps do a type check and wrap in quotes if not a number 
c6cf 21 bf e4				ld hl, os_input 
c6d2					if DEBUG_FORTH_WORDS 
c6d2						DMARK "AC1" 
c6d2 f5				push af  
c6d3 3a e7 c6			ld a, (.dmark)  
c6d6 32 6b ee			ld (debug_mark),a  
c6d9 3a e8 c6			ld a, (.dmark+1)  
c6dc 32 6c ee			ld (debug_mark+1),a  
c6df 3a e9 c6			ld a, (.dmark+2)  
c6e2 32 6d ee			ld (debug_mark+2),a  
c6e5 18 03			jr .pastdmark  
c6e7 ..			.dmark: db "AC1"  
c6ea f1			.pastdmark: pop af  
c6eb			endm  
# End of macro DMARK
c6eb						CALLMONITOR 
c6eb cd 6f ee			call debug_vector  
c6ee				endm  
# End of macro CALLMONITOR
c6ee					endif 
c6ee cd d0 9a				call forth_push_str 
c6f1					NEXTW 
c6f1 c3 1d 9e			jp macro_next 
c6f4				endm 
# End of macro NEXTW
c6f4			 
c6f4			.EDIT: 
c6f4				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c6f4 40				db WORD_SYS_CORE+44             
c6f5 96 c7			dw .DEDIT            
c6f7 05				db 4 + 1 
c6f8 .. 00			db "EDIT",0              
c6fd				endm 
# End of macro CWHEAD
c6fd			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c6fd			 
c6fd					; TODO does not copy from stack 
c6fd					if DEBUG_FORTH_WORDS_KEY 
c6fd						DMARK "EDT" 
c6fd f5				push af  
c6fe 3a 12 c7			ld a, (.dmark)  
c701 32 6b ee			ld (debug_mark),a  
c704 3a 13 c7			ld a, (.dmark+1)  
c707 32 6c ee			ld (debug_mark+1),a  
c70a 3a 14 c7			ld a, (.dmark+2)  
c70d 32 6d ee			ld (debug_mark+2),a  
c710 18 03			jr .pastdmark  
c712 ..			.dmark: db "EDT"  
c715 f1			.pastdmark: pop af  
c716			endm  
# End of macro DMARK
c716						CALLMONITOR 
c716 cd 6f ee			call debug_vector  
c719				endm  
# End of macro CALLMONITOR
c719					endif 
c719			 
c719					;FORTH_DSP 
c719					FORTH_DSP_VALUEHL 
c719 cd 67 9c			call macro_dsp_valuehl 
c71c				endm 
# End of macro FORTH_DSP_VALUEHL
c71c			;		inc hl    ; TODO do type check 
c71c			 
c71c			;		call get_word_hl 
c71c e5					push hl 
c71d					if DEBUG_FORTH_WORDS 
c71d						DMARK "EDp" 
c71d f5				push af  
c71e 3a 32 c7			ld a, (.dmark)  
c721 32 6b ee			ld (debug_mark),a  
c724 3a 33 c7			ld a, (.dmark+1)  
c727 32 6c ee			ld (debug_mark+1),a  
c72a 3a 34 c7			ld a, (.dmark+2)  
c72d 32 6d ee			ld (debug_mark+2),a  
c730 18 03			jr .pastdmark  
c732 ..			.dmark: db "EDp"  
c735 f1			.pastdmark: pop af  
c736			endm  
# End of macro DMARK
c736						CALLMONITOR 
c736 cd 6f ee			call debug_vector  
c739				endm  
# End of macro CALLMONITOR
c739					endif 
c739				;	ld a, 0 
c739 cd 41 90				call strlenz 
c73c 23					inc hl 
c73d			 
c73d 06 00				ld b, 0 
c73f 4d					ld c, l 
c740			 
c740 e1					pop hl 
c741 11 bf e4				ld de, os_input 
c744					if DEBUG_FORTH_WORDS_KEY 
c744						DMARK "EDc" 
c744 f5				push af  
c745 3a 59 c7			ld a, (.dmark)  
c748 32 6b ee			ld (debug_mark),a  
c74b 3a 5a c7			ld a, (.dmark+1)  
c74e 32 6c ee			ld (debug_mark+1),a  
c751 3a 5b c7			ld a, (.dmark+2)  
c754 32 6d ee			ld (debug_mark+2),a  
c757 18 03			jr .pastdmark  
c759 ..			.dmark: db "EDc"  
c75c f1			.pastdmark: pop af  
c75d			endm  
# End of macro DMARK
c75d						CALLMONITOR 
c75d cd 6f ee			call debug_vector  
c760				endm  
# End of macro CALLMONITOR
c760					endif 
c760 ed b0				ldir 
c762			 
c762			 
c762 21 bf e4				ld hl, os_input 
c765					;ld a, 0 
c765					;ld (hl),a 
c765 3a 5e ea				ld a,(f_cursor_ptr) 
c768 16 64				ld d, 100 
c76a 0e 00				ld c, 0 
c76c 1e 28				ld e, 40 
c76e cd 08 8d				call input_str 
c771					; TODO perhaps do a type check and wrap in quotes if not a number 
c771 21 bf e4				ld hl, os_input 
c774					if DEBUG_FORTH_WORDS 
c774						DMARK "ED1" 
c774 f5				push af  
c775 3a 89 c7			ld a, (.dmark)  
c778 32 6b ee			ld (debug_mark),a  
c77b 3a 8a c7			ld a, (.dmark+1)  
c77e 32 6c ee			ld (debug_mark+1),a  
c781 3a 8b c7			ld a, (.dmark+2)  
c784 32 6d ee			ld (debug_mark+2),a  
c787 18 03			jr .pastdmark  
c789 ..			.dmark: db "ED1"  
c78c f1			.pastdmark: pop af  
c78d			endm  
# End of macro DMARK
c78d						CALLMONITOR 
c78d cd 6f ee			call debug_vector  
c790				endm  
# End of macro CALLMONITOR
c790					endif 
c790 cd d0 9a				call forth_push_str 
c793					NEXTW 
c793 c3 1d 9e			jp macro_next 
c796				endm 
# End of macro NEXTW
c796			 
c796			.DEDIT: 
c796				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c796 40				db WORD_SYS_CORE+44             
c797 f8 c7			dw .ENDKEY            
c799 06				db 5 + 1 
c79a .. 00			db "DEDIT",0              
c7a0				endm 
# End of macro CWHEAD
c7a0			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c7a0			 
c7a0					; TODO does not copy from stack 
c7a0					if DEBUG_FORTH_WORDS_KEY 
c7a0						DMARK "DED" 
c7a0 f5				push af  
c7a1 3a b5 c7			ld a, (.dmark)  
c7a4 32 6b ee			ld (debug_mark),a  
c7a7 3a b6 c7			ld a, (.dmark+1)  
c7aa 32 6c ee			ld (debug_mark+1),a  
c7ad 3a b7 c7			ld a, (.dmark+2)  
c7b0 32 6d ee			ld (debug_mark+2),a  
c7b3 18 03			jr .pastdmark  
c7b5 ..			.dmark: db "DED"  
c7b8 f1			.pastdmark: pop af  
c7b9			endm  
# End of macro DMARK
c7b9						CALLMONITOR 
c7b9 cd 6f ee			call debug_vector  
c7bc				endm  
# End of macro CALLMONITOR
c7bc					endif 
c7bc			 
c7bc					;FORTH_DSP 
c7bc					FORTH_DSP_VALUEHL 
c7bc cd 67 9c			call macro_dsp_valuehl 
c7bf				endm 
# End of macro FORTH_DSP_VALUEHL
c7bf			;		inc hl    ; TODO do type check 
c7bf			 
c7bf			;		call get_word_hl 
c7bf e5					push hl 
c7c0 e5					push hl 
c7c1					FORTH_DSP_POP 
c7c1 cd 1f 9d			call macro_forth_dsp_pop 
c7c4				endm 
# End of macro FORTH_DSP_POP
c7c4 e1					pop hl 
c7c5					if DEBUG_FORTH_WORDS 
c7c5						DMARK "EDp" 
c7c5 f5				push af  
c7c6 3a da c7			ld a, (.dmark)  
c7c9 32 6b ee			ld (debug_mark),a  
c7cc 3a db c7			ld a, (.dmark+1)  
c7cf 32 6c ee			ld (debug_mark+1),a  
c7d2 3a dc c7			ld a, (.dmark+2)  
c7d5 32 6d ee			ld (debug_mark+2),a  
c7d8 18 03			jr .pastdmark  
c7da ..			.dmark: db "EDp"  
c7dd f1			.pastdmark: pop af  
c7de			endm  
# End of macro DMARK
c7de						CALLMONITOR 
c7de cd 6f ee			call debug_vector  
c7e1				endm  
# End of macro CALLMONITOR
c7e1					endif 
c7e1				;	ld a, 0 
c7e1 cd 41 90				call strlenz 
c7e4 23					inc hl 
c7e5			 
c7e5 06 00				ld b, 0 
c7e7 4d					ld c, l 
c7e8			 
c7e8 e1					pop hl 
c7e9			 
c7e9					;ld a, 0 
c7e9					;ld (hl),a 
c7e9 3a 5e ea				ld a,(f_cursor_ptr) 
c7ec 16 64				ld d, 100 
c7ee 0e 00				ld c, 0 
c7f0 1e 28				ld e, 40 
c7f2 cd 08 8d				call input_str 
c7f5					; TODO perhaps do a type check and wrap in quotes if not a number 
c7f5					NEXTW 
c7f5 c3 1d 9e			jp macro_next 
c7f8				endm 
# End of macro NEXTW
c7f8			 
c7f8			 
c7f8			.ENDKEY: 
c7f8			; eof 
c7f8			 
# End of file forth_words_key.asm
c7f8			include "forth_words_const.asm" 
c7f8			 
c7f8			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c7f8			 
c7f8			 
c7f8			.SPITIME: 
c7f8				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c7f8 77				db WORD_SYS_CORE+99             
c7f9 0d c8			dw .VA            
c7fb 08				db 7 + 1 
c7fc .. 00			db "SPITIME",0              
c804				endm 
# End of macro CWHEAD
c804			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
c804			; 
c804			; | | If using BANK devices then leave as is. 
c804			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
c804			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
c804			 
c804 21 64 ea				ld hl, spi_clktime  
c807 cd 62 9a				call forth_push_numhl 
c80a			 
c80a					NEXTW 
c80a c3 1d 9e			jp macro_next 
c80d				endm 
# End of macro NEXTW
c80d			 
c80d			 
c80d			.VA: 
c80d				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c80d 77				db WORD_SYS_CORE+99             
c80e 1d c8			dw .SYMBOL            
c810 03				db 2 + 1 
c811 .. 00			db "VA",0              
c814				endm 
# End of macro CWHEAD
c814			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
c814 21 28 ea				ld hl, cli_var_array 
c817 cd 62 9a				call forth_push_numhl 
c81a			 
c81a					NEXTW 
c81a c3 1d 9e			jp macro_next 
c81d				endm 
# End of macro NEXTW
c81d			 
c81d			.SYMBOL: 
c81d				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c81d 77				db WORD_SYS_CORE+99             
c81e 27 c9			dw .ENDCONST            
c820 07				db 6 + 1 
c821 .. 00			db "SYMBOL",0              
c828				endm 
# End of macro CWHEAD
c828			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c828			; | 
c828			; | | The value is the number reference and the final address is pushed to stack 
c828			 
c828			; | | ``` 
c828			; | | dw sym_table 
c828			; | | dw nmi_vector 
c828			; | | dw cli_autodisplay 
c828			; | | dw cli_data_sp 
c828			; | | dw cli_data_stack 
c828			; | | dw cli_loop_sp 
c828			; | | dw cli_loop_stack 
c828			; | | dw cli_var_array 
c828			; | | dw cursor_col 
c828			; | | dw cursor_ptr 
c828			; | | ; 10 
c828			; | | dw cursor_row 
c828			; | | dw debug_mark 
c828			; | | dw display_fb0 
c828			; | | dw display_fb1 
c828			; | | dw display_fb2 
c828			; | | dw display_fb3 
c828			; | | dw display_fb_active 
c828			; | | dw execscratch 
c828			; | | dw f_cursor_ptr 
c828			; | | dw hardware_word 
c828			; | | ;20 
c828			; | | dw input_at_cursor 
c828			; | | dw input_at_pos 
c828			; | | dw input_cur_flash 
c828			; | | dw input_cur_onoff 
c828			; | | dw input_cursor 
c828			; | | dw input_display_size 
c828			; | | dw input_len 
c828			; | | dw input_ptr 
c828			; | | dw input_size 
c828			; | | dw input_start 
c828			; | | ; 30 
c828			; | | dw input_str 
c828			; | | dw input_under_cursor 
c828			; | | dw os_cli_cmd 
c828			; | | dw os_cur_ptr 
c828			; | | dw os_current_i 
c828			; | | dw os_input 
c828			; | | dw os_last_cmd 
c828			; | | dw os_last_new_uword 
c828			; | | dw debug_vector 
c828			; | | dw os_view_hl 
c828			; | | ;40 
c828			; | | dw os_word_scratch 
c828			; | | dw portbctl 
c828			; | | dw portbdata 
c828			; | | dw spi_cartdev 
c828			; | | dw spi_cartdev2 
c828			; | | dw spi_clktime 
c828			; | | dw spi_device 
c828			; | | dw spi_device_id 
c828			; | | dw spi_portbyte 
c828			; | | dw stackstore 
c828			; | | ; 50 
c828			; | | if STORAGE_SE 
c828			; | | dw storage_actl 
c828			; | | dw storage_adata 
c828			; | | else 
c828			; | | dw 0 
c828			; | | dw 0 
c828			; | | endif 
c828			; | | dw storage_append 
c828			; | | if STORAGE_SE 
c828			; | | dw storage_bctl 
c828			; | | else 
c828			; | | dw 0 
c828			; | | endif 
c828			; | | dw store_bank_active 
c828			; | | dw store_filecache 
c828			; | | dw store_longread 
c828			; | | dw store_openaddr 
c828			; | | dw store_openext 
c828			; | | dw store_openmaxext 
c828			; | | ; 60 
c828			; | | dw store_page 
c828			; | | dw store_readbuf 
c828			; | | dw store_readcont 
c828			; | | dw store_readptr 
c828			; | | dw store_tmpext 
c828			; | | dw store_tmpid 
c828			; | | dw store_tmppageid 
c828			; | | dw malloc 
c828			; | | dw free 
c828			; | | dw cin 
c828			; | | ; 70 
c828			; | | dw cin_wait 
c828			; | | dw forth_push_numhl 
c828			; | | dw forth_push_str 
c828			; | | ``` 
c828			 
c828					if DEBUG_FORTH_WORDS_KEY 
c828						DMARK "SYM" 
c828 f5				push af  
c829 3a 3d c8			ld a, (.dmark)  
c82c 32 6b ee			ld (debug_mark),a  
c82f 3a 3e c8			ld a, (.dmark+1)  
c832 32 6c ee			ld (debug_mark+1),a  
c835 3a 3f c8			ld a, (.dmark+2)  
c838 32 6d ee			ld (debug_mark+2),a  
c83b 18 03			jr .pastdmark  
c83d ..			.dmark: db "SYM"  
c840 f1			.pastdmark: pop af  
c841			endm  
# End of macro DMARK
c841						CALLMONITOR 
c841 cd 6f ee			call debug_vector  
c844				endm  
# End of macro CALLMONITOR
c844					endif 
c844			 
c844					FORTH_DSP_VALUEHL 
c844 cd 67 9c			call macro_dsp_valuehl 
c847				endm 
# End of macro FORTH_DSP_VALUEHL
c847			 
c847 7d					ld a, l     
c848			 
c848			 
c848					if DEBUG_FORTH_WORDS 
c848						DMARK "SY1" 
c848 f5				push af  
c849 3a 5d c8			ld a, (.dmark)  
c84c 32 6b ee			ld (debug_mark),a  
c84f 3a 5e c8			ld a, (.dmark+1)  
c852 32 6c ee			ld (debug_mark+1),a  
c855 3a 5f c8			ld a, (.dmark+2)  
c858 32 6d ee			ld (debug_mark+2),a  
c85b 18 03			jr .pastdmark  
c85d ..			.dmark: db "SY1"  
c860 f1			.pastdmark: pop af  
c861			endm  
# End of macro DMARK
c861						CALLMONITOR 
c861 cd 6f ee			call debug_vector  
c864				endm  
# End of macro CALLMONITOR
c864					endif 
c864					 
c864 f5					push af	 
c865					FORTH_DSP_POP 
c865 cd 1f 9d			call macro_forth_dsp_pop 
c868				endm 
# End of macro FORTH_DSP_POP
c868 f1					pop af 
c869			 
c869 cb 27				sla a  
c86b				 
c86b					 
c86b					if DEBUG_FORTH_WORDS 
c86b						DMARK "SY" 
c86b f5				push af  
c86c 3a 80 c8			ld a, (.dmark)  
c86f 32 6b ee			ld (debug_mark),a  
c872 3a 81 c8			ld a, (.dmark+1)  
c875 32 6c ee			ld (debug_mark+1),a  
c878 3a 82 c8			ld a, (.dmark+2)  
c87b 32 6d ee			ld (debug_mark+2),a  
c87e 18 02			jr .pastdmark  
c880 ..			.dmark: db "SY"  
c882 f1			.pastdmark: pop af  
c883			endm  
# End of macro DMARK
c883						CALLMONITOR 
c883 cd 6f ee			call debug_vector  
c886				endm  
# End of macro CALLMONITOR
c886					endif 
c886			 
c886 21 95 c8				ld hl, sym_table 
c889 cd db 8c				call addatohl 
c88c cd 9f 9d				call loadwordinhl 
c88f cd 62 9a				call forth_push_numhl 
c892			 
c892			 
c892				       NEXTW 
c892 c3 1d 9e			jp macro_next 
c895				endm 
# End of macro NEXTW
c895			 
c895			sym_table: 
c895			 
c895			; 0 
c895 95 c8		dw sym_table 
c897 72 ee		dw nmi_vector 
c899 3c ea		dw cli_autodisplay 
c89b ee e9		dw cli_data_sp 
c89d 28 e8		dw cli_data_stack 
c89f f0 e9		dw cli_loop_sp 
c8a1 2a e9		dw cli_loop_stack 
c8a3 28 ea		dw cli_var_array 
c8a5 c5 eb		dw cursor_col 
c8a7 c3 eb		dw cursor_ptr 
c8a9			; 10 
c8a9 c4 eb		dw cursor_row 
c8ab 6b ee		dw debug_mark 
c8ad b1 ed		dw display_fb0 
c8af 10 ed		dw display_fb1 
c8b1 ce eb		dw display_fb2 
c8b3 6f ec		dw display_fb3 
c8b5 cc eb		dw display_fb_active 
c8b7 c0 e3		dw execscratch 
c8b9 5e ea		dw f_cursor_ptr 
c8bb 75 ee		dw hardware_word 
c8bd			;20 
c8bd 62 ee		dw input_at_cursor 
c8bf 64 ee		dw input_at_pos 
c8c1 60 ee		dw input_cur_flash 
c8c3 5f ee		dw input_cur_onoff 
c8c5 55 ee		dw input_cursor 
c8c7 65 ee		dw input_display_size 
c8c9 5a ee		dw input_len 
c8cb 69 ee		dw input_ptr 
c8cd 66 ee		dw input_size 
c8cf 67 ee		dw input_start 
c8d1			; 30 
c8d1 08 8d		dw input_str 
c8d3 63 ee		dw input_under_cursor 
c8d5 e8 e5		dw os_cli_cmd 
c8d7 e4 e5		dw os_cur_ptr 
c8d9 e6 e5		dw os_current_i 
c8db bf e4		dw os_input 
c8dd e7 e6		dw os_last_cmd 
c8df be e5		dw os_last_new_uword 
c8e1 6f ee		dw debug_vector 
c8e3 a3 e2		dw os_view_hl 
c8e5			;40 
c8e5 c6 e5		dw os_word_scratch 
c8e7 c3 00		dw portbctl 
c8e9 c1 00		dw portbdata 
c8eb 63 ea		dw spi_cartdev 
c8ed 62 ea		dw spi_cartdev2 
c8ef 64 ea		dw spi_clktime 
c8f1 60 ea		dw spi_device 
c8f3 5f ea		dw spi_device_id 
c8f5 61 ea		dw spi_portbyte 
c8f7 a7 eb		dw stackstore 
c8f9			; 50 
c8f9			if STORAGE_SE 
c8f9			dw storage_actl 
c8f9			dw storage_adata 
c8f9			else 
c8f9 00 00		dw 0 
c8fb 00 00		dw 0 
c8fd			endif 
c8fd 68 88		dw storage_append 
c8ff			if STORAGE_SE 
c8ff			dw storage_bctl 
c8ff			else 
c8ff 00 00		dw 0 
c901			endif 
c901 93 eb		dw store_bank_active 
c903 67 ea		dw store_filecache 
c905 75 ea		dw store_longread 
c907 6b ea		dw store_openaddr 
c909 6a ea		dw store_openext 
c90b 69 ea		dw store_openmaxext 
c90d			; 60 
c90d 7a ea		dw store_page 
c90f 76 ea		dw store_readbuf 
c911 6d ea		dw store_readcont 
c913 78 ea		dw store_readptr 
c915 6d ea		dw store_tmpext 
c917 6e ea		dw store_tmpid 
c919 65 ea		dw store_tmppageid 
c91b b6 90		dw malloc 
c91d 80 91		dw free 
c91f 02 dd		dw cin 
c921			; 70 
c921 fc dc		dw cin_wait 
c923 62 9a		dw forth_push_numhl 
c925 d0 9a		dw forth_push_str 
c927			 
c927			 
c927			.ENDCONST: 
c927			 
c927			; eof 
c927			 
c927			 
# End of file forth_words_const.asm
c927			 
c927			if STORAGE_SE 
c927			   	include "forth_words_storage.asm" 
c927			endif 
c927				include "forth_words_device.asm" 
c927			; Device related words 
c927			 
c927			; | ## Device Words 
c927			 
c927			;if SOUND_ENABLE 
c927			;.NOTE: 
c927			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c927			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
c927			;		if DEBUG_FORTH_WORDS_KEY 
c927			;			DMARK "NTE" 
c927			;			CALLMONITOR 
c927			;		endif 
c927			; 
c927			;	 
c927			; 
c927			;		NEXTW 
c927			;.AFTERSOUND: 
c927			;endif 
c927			 
c927			 
c927			USE_GPIO: equ 0 
c927			 
c927			if USE_GPIO 
c927			.GP1: 
c927				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c927			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
c927					NEXTW 
c927			.GP2: 
c927				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c927			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
c927			 
c927					NEXTW 
c927			 
c927			.GP3: 
c927				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c927			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
c927			 
c927					NEXTW 
c927			 
c927			.GP4: 
c927				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c927			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
c927			 
c927					NEXTW 
c927			.SIN: 
c927			 
c927			 
c927			endif 
c927			 
c927			 
c927				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c927 33				db WORD_SYS_CORE+31             
c928 5c c9			dw .SOUT            
c92a 03				db 2 + 1 
c92b .. 00			db "IN",0              
c92e				endm 
# End of macro CWHEAD
c92e			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c92e					if DEBUG_FORTH_WORDS_KEY 
c92e						DMARK "IN." 
c92e f5				push af  
c92f 3a 43 c9			ld a, (.dmark)  
c932 32 6b ee			ld (debug_mark),a  
c935 3a 44 c9			ld a, (.dmark+1)  
c938 32 6c ee			ld (debug_mark+1),a  
c93b 3a 45 c9			ld a, (.dmark+2)  
c93e 32 6d ee			ld (debug_mark+2),a  
c941 18 03			jr .pastdmark  
c943 ..			.dmark: db "IN."  
c946 f1			.pastdmark: pop af  
c947			endm  
# End of macro DMARK
c947						CALLMONITOR 
c947 cd 6f ee			call debug_vector  
c94a				endm  
# End of macro CALLMONITOR
c94a					endif 
c94a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c94a cd 67 9c			call macro_dsp_valuehl 
c94d				endm 
# End of macro FORTH_DSP_VALUEHL
c94d			 
c94d e5					push hl 
c94e			 
c94e					; destroy value TOS 
c94e			 
c94e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c94e cd 1f 9d			call macro_forth_dsp_pop 
c951				endm 
# End of macro FORTH_DSP_POP
c951			 
c951					; one value on hl get other one back 
c951			 
c951 c1					pop bc 
c952			 
c952					; do the sub 
c952			;		ex de, hl 
c952			 
c952 ed 68				in l,(c) 
c954			 
c954					; save it 
c954			 
c954 26 00				ld h,0 
c956			 
c956					; TODO push value back onto stack for another op etc 
c956			 
c956 cd 62 9a				call forth_push_numhl 
c959					NEXTW 
c959 c3 1d 9e			jp macro_next 
c95c				endm 
# End of macro NEXTW
c95c			.SOUT: 
c95c				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c95c 34				db WORD_SYS_CORE+32             
c95d af c9			dw .SPIO            
c95f 04				db 3 + 1 
c960 .. 00			db "OUT",0              
c964				endm 
# End of macro CWHEAD
c964			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c964					if DEBUG_FORTH_WORDS_KEY 
c964						DMARK "OUT" 
c964 f5				push af  
c965 3a 79 c9			ld a, (.dmark)  
c968 32 6b ee			ld (debug_mark),a  
c96b 3a 7a c9			ld a, (.dmark+1)  
c96e 32 6c ee			ld (debug_mark+1),a  
c971 3a 7b c9			ld a, (.dmark+2)  
c974 32 6d ee			ld (debug_mark+2),a  
c977 18 03			jr .pastdmark  
c979 ..			.dmark: db "OUT"  
c97c f1			.pastdmark: pop af  
c97d			endm  
# End of macro DMARK
c97d						CALLMONITOR 
c97d cd 6f ee			call debug_vector  
c980				endm  
# End of macro CALLMONITOR
c980					endif 
c980			 
c980					; get port 
c980			 
c980					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c980 cd 67 9c			call macro_dsp_valuehl 
c983				endm 
# End of macro FORTH_DSP_VALUEHL
c983			 
c983 e5					push hl 
c984			 
c984					; destroy value TOS 
c984			 
c984					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c984 cd 1f 9d			call macro_forth_dsp_pop 
c987				endm 
# End of macro FORTH_DSP_POP
c987			 
c987					; get byte to send 
c987			 
c987					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c987 cd 67 9c			call macro_dsp_valuehl 
c98a				endm 
# End of macro FORTH_DSP_VALUEHL
c98a			 
c98a			;		push hl 
c98a			 
c98a					; destroy value TOS 
c98a			 
c98a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c98a cd 1f 9d			call macro_forth_dsp_pop 
c98d				endm 
# End of macro FORTH_DSP_POP
c98d			 
c98d					; one value on hl get other one back 
c98d			 
c98d			;		pop hl 
c98d			 
c98d c1					pop bc 
c98e			 
c98e					if DEBUG_FORTH_WORDS 
c98e						DMARK "OUT" 
c98e f5				push af  
c98f 3a a3 c9			ld a, (.dmark)  
c992 32 6b ee			ld (debug_mark),a  
c995 3a a4 c9			ld a, (.dmark+1)  
c998 32 6c ee			ld (debug_mark+1),a  
c99b 3a a5 c9			ld a, (.dmark+2)  
c99e 32 6d ee			ld (debug_mark+2),a  
c9a1 18 03			jr .pastdmark  
c9a3 ..			.dmark: db "OUT"  
c9a6 f1			.pastdmark: pop af  
c9a7			endm  
# End of macro DMARK
c9a7						CALLMONITOR 
c9a7 cd 6f ee			call debug_vector  
c9aa				endm  
# End of macro CALLMONITOR
c9aa					endif 
c9aa			 
c9aa ed 69				out (c), l 
c9ac			 
c9ac					NEXTW 
c9ac c3 1d 9e			jp macro_next 
c9af				endm 
# End of macro NEXTW
c9af			 
c9af			 
c9af			.SPIO: 
c9af			 
c9af			if STORAGE_SE 
c9af				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c9af			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c9af			 
c9af					call spi_ce_low 
c9af			    NEXTW 
c9af			 
c9af			.SPICEH: 
c9af				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c9af			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c9af			 
c9af					call spi_ce_high 
c9af			    NEXTW 
c9af			 
c9af			 
c9af			.SPIOb: 
c9af			 
c9af				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c9af			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c9af			 
c9af					if DEBUG_FORTH_WORDS_KEY 
c9af						DMARK "SPo" 
c9af						CALLMONITOR 
c9af					endif 
c9af					; get port 
c9af			 
c9af			 
c9af					; get byte to send 
c9af			 
c9af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9af			 
c9af			;		push hl    ; u1  
c9af			 
c9af					; destroy value TOS 
c9af			 
c9af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9af			 
c9af					; one value on hl get other one back 
c9af			 
c9af			;		pop hl   ; u2 - addr 
c9af			 
c9af					; TODO Send SPI byte 
c9af			 
c9af			;		push hl 
c9af			;		call spi_ce_low 
c9af			;		pop hl 
c9af					ld a, l 
c9af					call spi_send_byte 
c9af			;		call spi_ce_high 
c9af			 
c9af					NEXTW 
c9af			 
c9af			.SPII: 
c9af				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c9af			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c9af					if DEBUG_FORTH_WORDS_KEY 
c9af						DMARK "SPi" 
c9af						CALLMONITOR 
c9af					endif 
c9af			 
c9af					; TODO Get SPI byte 
c9af			 
c9af					call spi_read_byte 
c9af			 
c9af					if DEBUG_FORTH_WORDS 
c9af						DMARK "Si2" 
c9af						CALLMONITOR 
c9af					endif 
c9af					ld h, 0 
c9af					ld l, a 
c9af					if DEBUG_FORTH_WORDS 
c9af						DMARK "Si3" 
c9af						CALLMONITOR 
c9af					endif 
c9af					call forth_push_numhl 
c9af			 
c9af					NEXTW 
c9af			 
c9af			 
c9af			 
c9af			.SESEL: 
c9af				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c9af			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c9af					if DEBUG_FORTH_WORDS_KEY 
c9af						DMARK "BNK" 
c9af						CALLMONITOR 
c9af					endif 
c9af			 
c9af					ld a, 255 
c9af					ld (spi_cartdev), a 
c9af			 
c9af					; get bank 
c9af			 
c9af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9af			 
c9af			;		push hl 
c9af			 
c9af					; destroy value TOS 
c9af			 
c9af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9af			 
c9af					; one value on hl get other one back 
c9af			 
c9af			;		pop hl 
c9af			 
c9af			 
c9af					ld c, SPI_CE_HIGH 
c9af					ld b, '0'    ; human readable bank number 
c9af			 
c9af					ld a, l 
c9af			 
c9af					if DEBUG_FORTH_WORDS 
c9af						DMARK "BNK" 
c9af						CALLMONITOR 
c9af					endif 
c9af			 
c9af					; active low 
c9af			 
c9af					cp 0 
c9af					jr z, .bset 
c9af					cp 1 
c9af					jr nz, .b2 
c9af					res 0, c 
c9af					ld b, '1'    ; human readable bank number 
c9af			.b2:		cp 2 
c9af					jr nz, .b3 
c9af					res 1, c 
c9af					ld b, '2'    ; human readable bank number 
c9af			.b3:		cp 3 
c9af					jr nz, .b4 
c9af					res 2, c 
c9af					ld b, '3'    ; human readable bank number 
c9af			.b4:		cp 4 
c9af					jr nz, .b5 
c9af					res 3, c 
c9af					ld b, '4'    ; human readable bank number 
c9af			.b5:		cp 5 
c9af					jr nz, .bset 
c9af					res 4, c 
c9af					ld b, '5'    ; human readable bank number 
c9af			 
c9af			.bset: 
c9af					ld a, c 
c9af					ld (spi_device),a 
c9af					ld a, b 
c9af					ld (spi_device_id),a 
c9af					if DEBUG_FORTH_WORDS 
c9af						DMARK "BN2" 
c9af						CALLMONITOR 
c9af					endif 
c9af			 
c9af					; set default SPI clk pulse time as disabled for BANK use 
c9af			 
c9af					ld a, 0 
c9af					ld (spi_clktime), a 
c9af			 
c9af					NEXTW 
c9af			 
c9af			.CARTDEV: 
c9af				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c9af			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c9af					if DEBUG_FORTH_WORDS_KEY 
c9af						DMARK "CDV" 
c9af						CALLMONITOR 
c9af					endif 
c9af			 
c9af					; disable se storage bank selection 
c9af			 
c9af					ld a, SPI_CE_HIGH		; ce high 
c9af					ld (spi_device), a 
c9af			 
c9af					; get bank 
c9af			 
c9af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9af			 
c9af			;		push hl 
c9af			 
c9af					; destroy value TOS 
c9af			 
c9af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9af			 
c9af					; one value on hl get other one back 
c9af			 
c9af			;		pop hl 
c9af			 
c9af					; active low 
c9af			 
c9af					ld c, 255 
c9af			 
c9af					ld a, l 
c9af					if DEBUG_FORTH_WORDS 
c9af						DMARK "CDV" 
c9af						CALLMONITOR 
c9af					endif 
c9af					cp 0 
c9af					jr z, .cset 
c9af					cp 1 
c9af					jr nz, .c2 
c9af					res 0, c 
c9af			.c2:		cp 2 
c9af					jr nz, .c3 
c9af					res 1, c 
c9af			.c3:		cp 3 
c9af					jr nz, .c4 
c9af					res 2, c 
c9af			.c4:		cp 4 
c9af					jr nz, .c5 
c9af					res 3, c 
c9af			.c5:		cp 5 
c9af					jr nz, .c6 
c9af					res 4, c 
c9af			.c6:		cp 6 
c9af					jr nz, .c7 
c9af					res 5, c 
c9af			.c7:		cp 7 
c9af					jr nz, .c8 
c9af					res 6, c 
c9af			.c8:		cp 8 
c9af					jr nz, .cset 
c9af					res 7, c 
c9af			.cset:		ld a, c 
c9af					ld (spi_cartdev),a 
c9af			 
c9af					if DEBUG_FORTH_WORDS 
c9af						DMARK "CD2" 
c9af						CALLMONITOR 
c9af					endif 
c9af			 
c9af					; set default SPI clk pulse time as 10ms for CARTDEV use 
c9af			 
c9af					ld a, $0a 
c9af					ld (spi_clktime), a 
c9af					NEXTW 
c9af			endif 
c9af			 
c9af			.ENDDEVICE: 
c9af			; eof 
c9af			 
# End of file forth_words_device.asm
c9af			 
c9af			; var handler 
c9af			 
c9af			 
c9af			.VARS: 
c9af				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c9af 77				db WORD_SYS_CORE+99             
c9b0 60 ca			dw .V0            
c9b2 04				db 3 + 1 
c9b3 .. 00			db "VAR",0              
c9b7				endm 
# End of macro CWHEAD
c9b7			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
c9b7			;| 
c9b7			;| The variable name should consist of a single letter. e.g. "a" 
c9b7			;! If a full string is passed then only the first char is looked at 
c9b7			;| Any other char could exceed bounds checks!  
c9b7			 
c9b7					if DEBUG_FORTH_WORDS_KEY 
c9b7						DMARK "VAR" 
c9b7 f5				push af  
c9b8 3a cc c9			ld a, (.dmark)  
c9bb 32 6b ee			ld (debug_mark),a  
c9be 3a cd c9			ld a, (.dmark+1)  
c9c1 32 6c ee			ld (debug_mark+1),a  
c9c4 3a ce c9			ld a, (.dmark+2)  
c9c7 32 6d ee			ld (debug_mark+2),a  
c9ca 18 03			jr .pastdmark  
c9cc ..			.dmark: db "VAR"  
c9cf f1			.pastdmark: pop af  
c9d0			endm  
# End of macro DMARK
c9d0						CALLMONITOR 
c9d0 cd 6f ee			call debug_vector  
c9d3				endm  
# End of macro CALLMONITOR
c9d3					endif 
c9d3			 
c9d3					FORTH_DSP_VALUEHL 
c9d3 cd 67 9c			call macro_dsp_valuehl 
c9d6				endm 
# End of macro FORTH_DSP_VALUEHL
c9d6			 
c9d6 7e					ld a, (hl)    ; get first char on of the string 
c9d7			 
c9d7			 
c9d7					if DEBUG_FORTH_WORDS 
c9d7						DMARK "VR1" 
c9d7 f5				push af  
c9d8 3a ec c9			ld a, (.dmark)  
c9db 32 6b ee			ld (debug_mark),a  
c9de 3a ed c9			ld a, (.dmark+1)  
c9e1 32 6c ee			ld (debug_mark+1),a  
c9e4 3a ee c9			ld a, (.dmark+2)  
c9e7 32 6d ee			ld (debug_mark+2),a  
c9ea 18 03			jr .pastdmark  
c9ec ..			.dmark: db "VR1"  
c9ef f1			.pastdmark: pop af  
c9f0			endm  
# End of macro DMARK
c9f0						CALLMONITOR 
c9f0 cd 6f ee			call debug_vector  
c9f3				endm  
# End of macro CALLMONITOR
c9f3					endif 
c9f3					 
c9f3 f5					push af	 
c9f4					FORTH_DSP_POP 
c9f4 cd 1f 9d			call macro_forth_dsp_pop 
c9f7				endm 
# End of macro FORTH_DSP_POP
c9f7 f1					pop af 
c9f8			 
c9f8					; convert to upper 
c9f8			 
c9f8 cd 50 8f				call to_upper 
c9fb					if DEBUG_FORTH_WORDS 
c9fb						DMARK "Vaa" 
c9fb f5				push af  
c9fc 3a 10 ca			ld a, (.dmark)  
c9ff 32 6b ee			ld (debug_mark),a  
ca02 3a 11 ca			ld a, (.dmark+1)  
ca05 32 6c ee			ld (debug_mark+1),a  
ca08 3a 12 ca			ld a, (.dmark+2)  
ca0b 32 6d ee			ld (debug_mark+2),a  
ca0e 18 03			jr .pastdmark  
ca10 ..			.dmark: db "Vaa"  
ca13 f1			.pastdmark: pop af  
ca14			endm  
# End of macro DMARK
ca14						CALLMONITOR 
ca14 cd 6f ee			call debug_vector  
ca17				endm  
# End of macro CALLMONITOR
ca17					endif 
ca17 06 41				ld b, 'A' 
ca19 90					sub b			; set offset 
ca1a					if DEBUG_FORTH_WORDS 
ca1a						DMARK "Vbb" 
ca1a f5				push af  
ca1b 3a 2f ca			ld a, (.dmark)  
ca1e 32 6b ee			ld (debug_mark),a  
ca21 3a 30 ca			ld a, (.dmark+1)  
ca24 32 6c ee			ld (debug_mark+1),a  
ca27 3a 31 ca			ld a, (.dmark+2)  
ca2a 32 6d ee			ld (debug_mark+2),a  
ca2d 18 03			jr .pastdmark  
ca2f ..			.dmark: db "Vbb"  
ca32 f1			.pastdmark: pop af  
ca33			endm  
# End of macro DMARK
ca33						CALLMONITOR 
ca33 cd 6f ee			call debug_vector  
ca36				endm  
# End of macro CALLMONITOR
ca36					endif 
ca36 cb 27				sla a  
ca38				 
ca38					 
ca38					if DEBUG_FORTH_WORDS 
ca38						DMARK "VR2" 
ca38 f5				push af  
ca39 3a 4d ca			ld a, (.dmark)  
ca3c 32 6b ee			ld (debug_mark),a  
ca3f 3a 4e ca			ld a, (.dmark+1)  
ca42 32 6c ee			ld (debug_mark+1),a  
ca45 3a 4f ca			ld a, (.dmark+2)  
ca48 32 6d ee			ld (debug_mark+2),a  
ca4b 18 03			jr .pastdmark  
ca4d ..			.dmark: db "VR2"  
ca50 f1			.pastdmark: pop af  
ca51			endm  
# End of macro DMARK
ca51						CALLMONITOR 
ca51 cd 6f ee			call debug_vector  
ca54				endm  
# End of macro CALLMONITOR
ca54					endif 
ca54			 
ca54 21 f4 e9				ld hl, cli_var_array2 
ca57 cd db 8c				call addatohl 
ca5a cd 62 9a				call forth_push_numhl 
ca5d			 
ca5d			 
ca5d				       NEXTW 
ca5d c3 1d 9e			jp macro_next 
ca60				endm 
# End of macro NEXTW
ca60			.V0: 
ca60				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
ca60 78				db WORD_SYS_CORE+100             
ca61 78 ca			dw .V0Q            
ca63 04				db 3 + 1 
ca64 .. 00			db "V0!",0              
ca68				endm 
# End of macro CWHEAD
ca68			;| V0! ( u1 -- )  Store value to v0  | DONE 
ca68			 
ca68					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca68 cd 67 9c			call macro_dsp_valuehl 
ca6b				endm 
# End of macro FORTH_DSP_VALUEHL
ca6b			 
ca6b 11 28 ea				ld de, cli_var_array 
ca6e			 
ca6e eb					ex de, hl 
ca6f 73					ld (hl), e 
ca70 23					inc hl 
ca71 72					ld (hl), d 
ca72			 
ca72					; destroy value TOS 
ca72			 
ca72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca72 cd 1f 9d			call macro_forth_dsp_pop 
ca75				endm 
# End of macro FORTH_DSP_POP
ca75			 
ca75				       NEXTW 
ca75 c3 1d 9e			jp macro_next 
ca78				endm 
# End of macro NEXTW
ca78			.V0Q: 
ca78				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
ca78 79				db WORD_SYS_CORE+101             
ca79 89 ca			dw .V1S            
ca7b 04				db 3 + 1 
ca7c .. 00			db "V0@",0              
ca80				endm 
# End of macro CWHEAD
ca80			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
ca80 2a 28 ea				ld hl, (cli_var_array) 
ca83 cd 62 9a				call forth_push_numhl 
ca86			 
ca86				       NEXTW 
ca86 c3 1d 9e			jp macro_next 
ca89				endm 
# End of macro NEXTW
ca89			.V1S: 
ca89				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
ca89 7a				db WORD_SYS_CORE+102             
ca8a a1 ca			dw .V1Q            
ca8c 04				db 3 + 1 
ca8d .. 00			db "V1!",0              
ca91				endm 
# End of macro CWHEAD
ca91			;| V1! ( u1 -- )  Store value to v1 | DONE 
ca91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca91 cd 67 9c			call macro_dsp_valuehl 
ca94				endm 
# End of macro FORTH_DSP_VALUEHL
ca94			 
ca94 11 2a ea				ld de, cli_var_array+2 
ca97				 
ca97 eb					ex de, hl 
ca98 73					ld (hl), e 
ca99 23					inc hl 
ca9a 72					ld (hl), d 
ca9b			 
ca9b					; destroy value TOS 
ca9b			 
ca9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca9b cd 1f 9d			call macro_forth_dsp_pop 
ca9e				endm 
# End of macro FORTH_DSP_POP
ca9e				       NEXTW 
ca9e c3 1d 9e			jp macro_next 
caa1				endm 
# End of macro NEXTW
caa1			.V1Q: 
caa1				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
caa1 7b				db WORD_SYS_CORE+103             
caa2 b2 ca			dw .V2S            
caa4 04				db 3 + 1 
caa5 .. 00			db "V1@",0              
caa9				endm 
# End of macro CWHEAD
caa9			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
caa9 2a 2a ea				ld hl, (cli_var_array+2) 
caac cd 62 9a				call forth_push_numhl 
caaf				       NEXTW 
caaf c3 1d 9e			jp macro_next 
cab2				endm 
# End of macro NEXTW
cab2			.V2S: 
cab2				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cab2 7c				db WORD_SYS_CORE+104             
cab3 ca ca			dw .V2Q            
cab5 04				db 3 + 1 
cab6 .. 00			db "V2!",0              
caba				endm 
# End of macro CWHEAD
caba			;| V2! ( u1 -- )  Store value to v2 | DONE 
caba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
caba cd 67 9c			call macro_dsp_valuehl 
cabd				endm 
# End of macro FORTH_DSP_VALUEHL
cabd			 
cabd 11 2c ea				ld de, cli_var_array+4 
cac0				 
cac0 eb					ex de, hl 
cac1 73					ld (hl), e 
cac2 23					inc hl 
cac3 72					ld (hl), d 
cac4			 
cac4					; destroy value TOS 
cac4			 
cac4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cac4 cd 1f 9d			call macro_forth_dsp_pop 
cac7				endm 
# End of macro FORTH_DSP_POP
cac7				       NEXTW 
cac7 c3 1d 9e			jp macro_next 
caca				endm 
# End of macro NEXTW
caca			.V2Q: 
caca				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
caca 7d				db WORD_SYS_CORE+105             
cacb db ca			dw .V3S            
cacd 04				db 3 + 1 
cace .. 00			db "V2@",0              
cad2				endm 
# End of macro CWHEAD
cad2			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cad2 2a 2c ea				ld hl, (cli_var_array+4) 
cad5 cd 62 9a				call forth_push_numhl 
cad8				       NEXTW 
cad8 c3 1d 9e			jp macro_next 
cadb				endm 
# End of macro NEXTW
cadb			.V3S: 
cadb				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cadb 7c				db WORD_SYS_CORE+104             
cadc f3 ca			dw .V3Q            
cade 04				db 3 + 1 
cadf .. 00			db "V3!",0              
cae3				endm 
# End of macro CWHEAD
cae3			;| V3! ( u1 -- )  Store value to v3 | DONE 
cae3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cae3 cd 67 9c			call macro_dsp_valuehl 
cae6				endm 
# End of macro FORTH_DSP_VALUEHL
cae6			 
cae6 11 2e ea				ld de, cli_var_array+6 
cae9				 
cae9 eb					ex de, hl 
caea 73					ld (hl), e 
caeb 23					inc hl 
caec 72					ld (hl), d 
caed			 
caed					; destroy value TOS 
caed			 
caed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
caed cd 1f 9d			call macro_forth_dsp_pop 
caf0				endm 
# End of macro FORTH_DSP_POP
caf0				       NEXTW 
caf0 c3 1d 9e			jp macro_next 
caf3				endm 
# End of macro NEXTW
caf3			.V3Q: 
caf3				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
caf3 7d				db WORD_SYS_CORE+105             
caf4 04 cb			dw .END            
caf6 04				db 3 + 1 
caf7 .. 00			db "V3@",0              
cafb				endm 
# End of macro CWHEAD
cafb			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cafb 2a 2e ea				ld hl, (cli_var_array+6) 
cafe cd 62 9a				call forth_push_numhl 
cb01				       NEXTW 
cb01 c3 1d 9e			jp macro_next 
cb04				endm 
# End of macro NEXTW
cb04			 
cb04			 
cb04			 
cb04			 
cb04			 
cb04			; end of dict marker 
cb04			 
cb04 00			.END:    db WORD_SYS_END 
cb05 00 00			dw 0 
cb07 00				db 0 
cb08			 
cb08			; use to jp here for user dict words to save on macro expansion  
cb08			 
cb08			user_dict_next: 
cb08				NEXTW 
cb08 c3 1d 9e			jp macro_next 
cb0b				endm 
# End of macro NEXTW
cb0b			 
cb0b			 
cb0b			user_exec: 
cb0b				;    ld hl, <word code> 
cb0b				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb0b				;    call forthexec 
cb0b				;    jp user_dict_next   (NEXT) 
cb0b			        ;    <word code bytes> 
cb0b eb				ex de, hl 
cb0c 2a c2 e5			ld hl,(os_tok_ptr) 
cb0f				 
cb0f				FORTH_RSP_NEXT 
cb0f cd 09 9a			call macro_forth_rsp_next 
cb12				endm 
# End of macro FORTH_RSP_NEXT
cb12			 
cb12			if DEBUG_FORTH_UWORD 
cb12						DMARK "UEX" 
cb12 f5				push af  
cb13 3a 27 cb			ld a, (.dmark)  
cb16 32 6b ee			ld (debug_mark),a  
cb19 3a 28 cb			ld a, (.dmark+1)  
cb1c 32 6c ee			ld (debug_mark+1),a  
cb1f 3a 29 cb			ld a, (.dmark+2)  
cb22 32 6d ee			ld (debug_mark+2),a  
cb25 18 03			jr .pastdmark  
cb27 ..			.dmark: db "UEX"  
cb2a f1			.pastdmark: pop af  
cb2b			endm  
# End of macro DMARK
cb2b				CALLMONITOR 
cb2b cd 6f ee			call debug_vector  
cb2e				endm  
# End of macro CALLMONITOR
cb2e			endif 
cb2e			 
cb2e			 
cb2e			 
cb2e eb				ex de, hl 
cb2f 22 c2 e5			ld (os_tok_ptr), hl 
cb32				 
cb32				; Don't use next - Skips the first word in uword. 
cb32			 
cb32 c3 ae 9e			jp exec1 
cb35			;	NEXT 
cb35			 
cb35			 
cb35			; eof 
# End of file forth_wordsv4.asm
cb35			endif 
cb35			;;;;;;;;;;;;;; Debug code 
cb35			 
cb35			 
cb35			;if DEBUG_FORTH_PARSE 
cb35 .. 00		.nowordfound: db "No match",0 
cb3e .. 00		.compword:	db "Comparing word ",0 
cb4e .. 00		.nextwordat:	db "Next word at",0 
cb5b .. 00		.charmatch:	db "Char match",0 
cb66			;endif 
cb66			if DEBUG_FORTH_JP 
cb66			.foundword:	db "Word match. Exec..",0 
cb66			endif 
cb66			;if DEBUG_FORTH_PUSH 
cb66 .. 00		.enddict:	db "Dict end. Push.",0 
cb76 .. 00		.push_str:	db "Pushing string",0 
cb85 .. 00		.push_num:	db "Pushing number",0 
cb94 .. 00		.data_sp:	db "SP:",0 
cb98 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cbaa .. 00		.wordinde:	db "Word in DE (3/0):",0 
cbbc .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cbce			;endif 
cbce			;if DEBUG_FORTH_MALLOC 
cbce .. 00		.push_malloc:	db "Malloc address",0 
cbdd			;endif 
cbdd			 
cbdd			 
cbdd			 
cbdd			; display malloc address and current data stack pointer  
cbdd			 
cbdd			malloc_error: 
cbdd d5				push de 
cbde f5				push af 
cbdf e5				push hl 
cbe0 cd ae 8a			call clear_display 
cbe3 11 03 cc			ld de, .mallocerr 
cbe6 3e 00			ld a,0 
cbe8			;	ld de,os_word_scratch 
cbe8 cd c1 8a			call str_at_display 
cbeb 3e 11			ld a, display_row_1+17 
cbed 11 6b ee			ld de, debug_mark 
cbf0 cd c1 8a			call str_at_display 
cbf3 cd d1 8a			call update_display 
cbf6				;call break_point_state 
cbf6 cd fc dc			call cin_wait 
cbf9			 
cbf9			;	ld a, ' ' 
cbf9			;	ld (os_view_disable), a 
cbf9 cd e5 93			call bp_on 
cbfc e1				pop hl 
cbfd f1				pop af 
cbfe d1				pop de	 
cbff				CALLMONITOR 
cbff cd 6f ee			call debug_vector  
cc02				endm  
# End of macro CALLMONITOR
cc02 c9				ret 
cc03			 
cc03 .. 00		.mallocerr: 	db "Malloc Error",0 
cc10			;if DEBUG_FORTH_PUSH 
cc10			display_data_sp: 
cc10 f5				push af 
cc11			 
cc11				; see if disabled 
cc11			 
cc11			 
cc11 3a 6f ee			ld a, (debug_vector) 
cc14 fe c9			cp $C9  ; RET 
cc16				;ld a, (os_view_disable) 
cc16				;cp '*' 
cc16 28 67			jr z, .skipdsp 
cc18			 
cc18 e5				push hl 
cc19 e5				push hl 
cc1a e5			push hl 
cc1b cd ae 8a			call clear_display 
cc1e e1			pop hl 
cc1f 7c				ld a,h 
cc20 21 c6 e5			ld hl, os_word_scratch 
cc23 cd e4 8e			call hexout 
cc26 e1				pop hl 
cc27 7d				ld a,l 
cc28 21 c8 e5			ld hl, os_word_scratch+2 
cc2b cd e4 8e			call hexout 
cc2e 21 ca e5			ld hl, os_word_scratch+4 
cc31 3e 00			ld a,0 
cc33 77				ld (hl),a 
cc34 11 c6 e5			ld de,os_word_scratch 
cc37 3e 28				ld a, display_row_2 
cc39 cd c1 8a				call str_at_display 
cc3c 11 98 cb			ld de, .wordinhl 
cc3f 3e 00			ld a, display_row_1 
cc41			 
cc41 cd c1 8a				call str_at_display 
cc44 11 6b ee			ld de, debug_mark 
cc47 3e 11			ld a, display_row_1+17 
cc49			 
cc49 cd c1 8a				call str_at_display 
cc4c			 
cc4c				; display current data stack pointer 
cc4c 11 94 cb			ld de,.data_sp 
cc4f 3e 30				ld a, display_row_2 + 8 
cc51 cd c1 8a				call str_at_display 
cc54			 
cc54 2a ee e9			ld hl,(cli_data_sp) 
cc57 e5				push hl 
cc58 7c				ld a,h 
cc59 21 c6 e5			ld hl, os_word_scratch 
cc5c cd e4 8e			call hexout 
cc5f e1				pop hl 
cc60 7d				ld a,l 
cc61 21 c8 e5			ld hl, os_word_scratch+2 
cc64 cd e4 8e			call hexout 
cc67 21 ca e5			ld hl, os_word_scratch+4 
cc6a 3e 00			ld a,0 
cc6c 77				ld (hl),a 
cc6d 11 c6 e5			ld de,os_word_scratch 
cc70 3e 33				ld a, display_row_2 + 11 
cc72 cd c1 8a				call str_at_display 
cc75			 
cc75			 
cc75 cd d1 8a			call update_display 
cc78 cd f1 89			call delay1s 
cc7b cd f1 89			call delay1s 
cc7e e1				pop hl 
cc7f			.skipdsp: 
cc7f f1				pop af 
cc80 c9				ret 
cc81			 
cc81			display_data_malloc: 
cc81			 
cc81 f5				push af 
cc82 e5				push hl 
cc83 e5				push hl 
cc84 e5			push hl 
cc85 cd ae 8a			call clear_display 
cc88 e1			pop hl 
cc89 7c				ld a,h 
cc8a 21 c6 e5			ld hl, os_word_scratch 
cc8d cd e4 8e			call hexout 
cc90 e1				pop hl 
cc91 7d				ld a,l 
cc92 21 c8 e5			ld hl, os_word_scratch+2 
cc95 cd e4 8e			call hexout 
cc98 21 ca e5			ld hl, os_word_scratch+4 
cc9b 3e 00			ld a,0 
cc9d 77				ld (hl),a 
cc9e 11 c6 e5			ld de,os_word_scratch 
cca1 3e 28				ld a, display_row_2 
cca3 cd c1 8a				call str_at_display 
cca6 11 ce cb			ld de, .push_malloc 
cca9 3e 00			ld a, display_row_1 
ccab			 
ccab cd c1 8a				call str_at_display 
ccae			 
ccae				; display current data stack pointer 
ccae 11 94 cb			ld de,.data_sp 
ccb1 3e 30				ld a, display_row_2 + 8 
ccb3 cd c1 8a				call str_at_display 
ccb6			 
ccb6 2a ee e9			ld hl,(cli_data_sp) 
ccb9 e5				push hl 
ccba 7c				ld a,h 
ccbb 21 c6 e5			ld hl, os_word_scratch 
ccbe cd e4 8e			call hexout 
ccc1 e1				pop hl 
ccc2 7d				ld a,l 
ccc3 21 c8 e5			ld hl, os_word_scratch+2 
ccc6 cd e4 8e			call hexout 
ccc9 21 ca e5			ld hl, os_word_scratch+4 
cccc 3e 00			ld a,0 
ccce 77				ld (hl),a 
cccf 11 c6 e5			ld de,os_word_scratch 
ccd2 3e 33				ld a, display_row_2 + 11 
ccd4 cd c1 8a				call str_at_display 
ccd7			 
ccd7 cd d1 8a			call update_display 
ccda cd f1 89			call delay1s 
ccdd cd f1 89			call delay1s 
cce0 e1				pop hl 
cce1 f1				pop af 
cce2 c9				ret 
cce3			;endif 
cce3			 
cce3			include "forth_autostart.asm" 
cce3			; list of commands to perform at system start up 
cce3			 
cce3			startcmds: 
cce3			;	dw test11 
cce3			;	dw test12 
cce3			;	dw test13 
cce3			;	dw test14 
cce3			;	dw test15 
cce3			;	dw test16 
cce3			;	dw test17 
cce3			;	dw ifthtest1 
cce3			;	dw ifthtest2 
cce3			;	dw ifthtest3 
cce3			;	dw mmtest1 
cce3			;	dw mmtest2 
cce3			;	dw mmtest3 
cce3			;	dw mmtest4 
cce3			;	dw mmtest5 
cce3			;	dw mmtest6 
cce3			;	dw iftest1 
cce3			;	dw iftest2 
cce3			;	dw iftest3 
cce3			;	dw looptest1 
cce3			;	dw looptest2 
cce3			;	dw test1 
cce3			;	dw test2 
cce3			;	dw test3 
cce3			;	dw test4 
cce3			;	dw game2r 
cce3			;	dw game2b1 
cce3			;	dw game2b2 
cce3			 
cce3				; start up words that are actually useful 
cce3			 
cce3			;    dw spi1 
cce3			;    dw spi2 
cce3			;    dw spi3 
cce3			;    dw spi4 
cce3			;    dw spi5 
cce3			;    dw spi6 
cce3			;    dw spi7 
cce3			; 
cce3			;    dw spi8 
cce3			;    dw spi9 
cce3			;    dw spi10 
cce3			 
cce3			; file editor 
cce3			;	dw edit1 
cce3			;	dw edit2 
cce3			;	dw edit3 
cce3			 
cce3			;	dw longread 
cce3 03 d1			dw clrstack 
cce5 37 d1			dw type 
cce7			;	dw stest 
cce7 5c d1			dw strncpy 
cce9			;	dw list 
cce9 bd d1			dw start1 
cceb cd d1			dw start2 
cced			;	dw start3 
cced			;	dw start3b 
cced			;	dw start3c 
cced			 
cced				; (unit) testing words 
cced			 
cced			;	dw mtesta 
cced			;	dw mtestb 
cced			;	dw mtestc 
cced			;	dw mtestd 
cced			;	dw mteste 
cced			 
cced				; demo/game words 
cced			 
cced			;        dw game3w 
cced			;        dw game3p 
cced			;        dw game3sc 
cced			;        dw game3vsi 
cced			;        dw game3vs 
cced				 
cced			;	dw game2b 
cced			;	dw game2bf 
cced			;	dw game2mba 
cced			;	dw game2mbas 
cced			;	dw game2mb 
cced			 
cced ea d4			dw game1 
ccef fb d4			dw game1a 
ccf1 5d d5			dw game1b 
ccf3 92 d5			dw game1c 
ccf5 c8 d5			dw game1d 
ccf7 f9 d5			dw game1s 
ccf9 0d d6			dw game1t 
ccfb 22 d6			dw game1f 
ccfd 56 d6			dw game1z 
ccff 9a d6			dw game1zz 
cd01			 
cd01 23 d3			dw test5 
cd03 5b d3			dw test6 
cd05 93 d3			dw test7 
cd07 a7 d3			dw test8 
cd09 d3 d3			dw test9 
cd0b e9 d3			dw test10 
cd0d				 
cd0d 71 d7		        dw ssv5 
cd0f 55 d7		        dw ssv4 
cd11 39 d7		        dw ssv3 
cd13 03 d7		        dw ssv2 
cd15 8a d7		        dw ssv1 
cd17 d2 d7		        dw ssv1cpm 
cd19			;	dw keyup 
cd19			;	dw keydown 
cd19			;	dw keyleft 
cd19			;	dw keyright 
cd19			;	dw 	keyf1 
cd19			;	dw keyf2 
cd19			;	dw keyf3 
cd19			;	dw keyf4 
cd19			;	dw keyf5 
cd19			;	dw keyf6 
cd19			;	dw keyf7 
cd19			;	dw keyf8 
cd19			;	dw keyf9 
cd19			;	dw keyf10 
cd19			;	dw keyf11 
cd19			;	dw keyf12 
cd19			;	dw keytab 
cd19			;	dw keycr 
cd19			;	dw keyhome 
cd19			;	dw keyend 
cd19			;	dw keybs 
cd19 00 00			db 0, 0	 
cd1b			 
cd1b			 
cd1b			; File Editor 
cd1b			 
cd1b			; ( id - ) use 'e' to edit the displayed line 
cd1b .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cd3c .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd71			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd71 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
cda9			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
cda9			 
cda9			; SPI Net support words 
cda9			 
cda9			; v0! = node to send to 
cda9			; ( str count - ) 
cda9 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce02			 
ce02			; spiputc ( char node - ) 
ce02 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
ce36			; spiputc ( u node - ) 
ce36 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
ce64			 
ce64			; spigetc ( - n ) 
ce64 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
ce8d			 
ce8d			; getnode ( - n ) 
ce8d .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
ceba			 
ceba			; ( str node - )  
ceba .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf20			; store string ( str i - ) 
cf20			 
cf20			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf20 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cf75			 
cf75			; get string ( addr i -  )    TO FIX 
cf75			 
cf75 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
cfcd			 
cfcd			 
cfcd			; NETCHAT (TODO) 
cfcd			; Program to allow two nodes to chat with eachother 
cfcd			; 
cfcd			; v0 - target node 
cfcd			;  
cfcd			; accept input at 0,0 
cfcd			; if input is string send spitype to target node 
cfcd			; starting at row 2,0 , while spigetchr is not zero ->  
cfcd			; 
cfcd			; 
cfcd			; TODO add paging of get request 
cfcd			 
cfcd			; ( node - ) 
cfcd .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
cfec .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d044 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d0bc			 
d0bc			 
d0bc			; Long read of currently open file 
d0bc .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d103			 
d103			; clear stack  
d103			 
d103 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d137			 
d137			; type ( addr count - ) 
d137 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d15c			 
d15c			; some direct memory words 
d15c			; strncpy ( len t f -- t ) 
d15c			 
d15c .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d1bd			 
d1bd .. 00		start1:     	db ": bpon $00 bp ;",0 
d1cd .. 00		start2:     	db ": bpoff $01 bp ;",0 
d1de .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d259 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d2b9			 
d2b9			 
d2b9			; a handy word to list items on the stack 
d2b9			 
d2b9 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d323			 
d323			 
d323			; test stack  
d323			; rnd8 stest 
d323			 
d323			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d323			 
d323			; random malloc and free cycles 
d323			 
d323			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d323			 
d323			; fixed malloc and free cycles 
d323			 
d323			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d323			 
d323			; fixed double string push and drop cycle  
d323			 
d323			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d323			 
d323			; consistent fixed string push and drop cycle  
d323			 
d323			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d323			 
d323			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d323			 
d323			;test1:		db ": aa 1 2 3 ;", 0 
d323			;test2:     	db "111 aa 888 999",0 
d323			;test3:     	db ": bb 77 ;",0 
d323			;test4:     	db "$02 $01 do i . loop bb",0 
d323			 
d323 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d35b .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d393 .. 00		test7:     	db ": box hline vline ;",0 
d3a7 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d3d3 .. 00		test9:     	db ": sw $01 adsp world ;",0 
d3e9 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d40e			;test11:     	db "hello create .",0 
d40e			;test12:     	db "hello2 create .",0 
d40e			 
d40e			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d40e			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d40e			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d40e			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d40e			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d40e			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d40e			 
d40e			;iftest1:     	db "$0001 IF cls .",0 
d40e			;iftest2:     	db "$0000 IF cls .",0 
d40e			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d40e			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d40e			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d40e			 
d40e			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d40e			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d40e			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d40e			 
d40e			 
d40e .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d432 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d462 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d487 .. 00		sound4: db ": cha $00 ; ",0 
d494 .. 00		sound5: db ": chb $20 ; ",0 
d4a1 .. 00		sound6: db ": chc $40 ; ",0 
d4ae .. 00		sound7: db ": chd $60 ; ",0 
d4bb .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d4d3 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d4ea			 
d4ea			 
d4ea			 
d4ea			 
d4ea			; a small guess the number game 
d4ea			 
d4ea .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d4fb .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d55d			 
d55d .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d592 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d5c8 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d5f9 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d60d .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d622 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d656 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d69a			 
d69a			; Using 'ga' save a high score across multiple runs using external storage 
d69a			 
d69a .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
d703			 
d703			 
d703			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
d703			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
d703			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
d703			 
d703			; simple screen saver to test code memory reuse to destruction 
d703			 
d703 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
d739 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
d755 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d771 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d78a .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d7d2 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d829			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d829			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d829			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d829			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d829			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d829			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d829			 
d829			 
d829			 
d829			; minesweeper/battleship finding game 
d829			; draws a game board of random ship/mine positions 
d829			; user enters coords to see if it hits on 
d829			; game ends when all are hit 
d829			; when hit or miss says how many may be in the area 
d829			 
d829			; setup the game board and then hide it 
d829			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d829			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d829			;; prompt for where to target 
d829			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d829			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d829			;; TODO see if the entered coords hits or misses pushes char hit of miss 
d829			;game2mbht:      db ": mbckht nop ;",0 
d829			;game2mbms:      db ": mbcms nop ;",0 
d829			; TODO how many might be near by 
d829			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d829			 
d829			; Game 3 
d829			 
d829			; Vert scroller ski game - avoid the trees! 
d829			 
d829			; v0 score (ie turns) 
d829			; v1 player pos 
d829			; v2 left wall 
d829			; v3 right wall 
d829			 
d829			; Draw side walls randomly 
d829			 
d829			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d829			 
d829			; Draw player 
d829			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d829			 
d829			; TODO Get Key 
d829			 
d829			; TODO Move left right 
d829			 
d829			; scroll and move walls a bit 
d829			 
d829			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d829			 
d829			; main game loop 
d829			 
d829			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d829			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d829			 
d829			; key board defs 
d829			 
d829 .. 00		keyup:       db ": keyup $05 ;",0 
d837 .. 00		keydown:       db ": keydown $0a ;",0 
d847 .. 00		keyleft:       db ": keyleft $0b ;",0 
d857 .. 00		keyright:       db ": keyright $0c ;",0 
d868 .. 00		keyf1:       db ": keyf1 $10 ;",0 
d876 .. 00		keyf2:       db ": keyf2 $11 ;",0 
d884 .. 00		keyf3:       db ": keyf3 $12 ;",0 
d892 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d8a0 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d8ae .. 00		keyf6:       db ": keyf6 $15 ;",0 
d8bc .. 00		keyf7:       db ": keyf7 $16 ;",0 
d8ca .. 00		keyf8:       db ": keyf8 $17 ;",0 
d8d8 .. 00		keyf9:       db ": keyf9 $18 ;",0 
d8e6 .. 00		keyf10:       db ": keyf10 $19 ;",0 
d8f5 .. 00		keyf11:       db ": keyf11 $1a ;",0 
d904 .. 00		keyf12:       db ": keyf12 $1b ;",0 
d913			 
d913 .. 00		keytab:       db ": keytab $09 ;",0 
d922 .. 00		keycr:       db ": keycr $0d ;",0 
d930 .. 00		keyhome:       db ": keyhome $0e ;",0 
d940 .. 00		keyend:       db ": keyend $0f ;",0 
d94f .. 00		keybs:       db ": keybs $08 ;",0 
d95d			 
d95d			   
d95d			 
d95d			 
d95d			 
d95d			; eof 
# End of file forth_autostart.asm
d95d			 
d95d			 
d95d			 
d95d			; stack over and underflow checks 
d95d			 
d95d			; init the words to detect the under/overflow 
d95d			 
d95d			chk_stk_init: 
d95d				; a vague random number to check so we dont get any "lucky" hits 
d95d 3e 2d			ld a, 45 
d95f 6f				ld l, a 
d960 00				nop 
d961 3e 17			ld a, 23 
d963 67				ld h, a 
d964			 
d964 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
d967			 
d967			;	ld (chk_stund), hl	; stack points.... 
d967 22 00 ef			ld (chk_stovr), hl 
d96a 22 ec e9			ld (chk_ret_und), hl 
d96d 22 aa e9			ld (chk_ret_ovr), hl 
d970 22 28 e9			ld (chk_loop_ovr), hl 
d973 22 26 e8			ld (chk_data_ovr), hl 
d976 c9				ret 
d977				 
d977			check_stacks: 
d977				; check all stack words 
d977			 
d977 e5				push hl 
d978 d5				push de 
d979			 
d979			;	ld de,(chk_word) 
d979			;	ld hl, (chk_stund)	; stack points.... 
d979			;	if DEBUG_STK_FAULT 
d979			;		DMARK "FAa" 
d979			;		CALLMONITOR 
d979			;	endif 
d979			;	call cmp16 
d979			;	jp z, .chk_faulta 
d979			; 
d979			;	ld de, sfaultsu 
d979			;	jp .chk_fault 
d979			 
d979 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d97c ed 5b 9d e2		ld de,(chk_word) 
d980				if DEBUG_STK_FAULT 
d980					DMARK "FAb" 
d980					CALLMONITOR 
d980				endif 
d980 cd f9 8c			call cmp16 
d983 28 06			jr z, .chk_fault1 
d985 11 26 da			ld de, sfaultso 
d988 c3 da d9			jp .chk_fault 
d98b			.chk_fault1:  
d98b 2a ec e9			ld hl, (chk_ret_und) 
d98e ed 5b 9d e2		ld de,(chk_word) 
d992				if DEBUG_STK_FAULT 
d992					DMARK "FAU" 
d992					CALLMONITOR 
d992				endif 
d992 cd f9 8c			call cmp16 
d995 ca 9e d9			jp z, .chk_fault2 
d998 11 36 da			ld de, sfaultru 
d99b c3 da d9			jp .chk_fault 
d99e			.chk_fault2:  
d99e 2a aa e9			ld hl, (chk_ret_ovr) 
d9a1 ed 5b 9d e2		ld de,(chk_word) 
d9a5				if DEBUG_STK_FAULT 
d9a5					DMARK "FA1" 
d9a5					CALLMONITOR 
d9a5				endif 
d9a5 cd f9 8c			call cmp16 
d9a8 ca b1 d9			jp z, .chk_fault3 
d9ab 11 44 da			ld de, sfaultro 
d9ae c3 da d9			jp .chk_fault 
d9b1			.chk_fault3:  
d9b1 2a 28 e9			ld hl, (chk_loop_ovr) 
d9b4 ed 5b 9d e2		ld de,(chk_word) 
d9b8				if DEBUG_STK_FAULT 
d9b8					DMARK "FA2" 
d9b8					CALLMONITOR 
d9b8				endif 
d9b8 cd f9 8c			call cmp16 
d9bb ca c4 d9			jp z, .chk_fault4 
d9be 11 5e da			ld de, sfaultlo 
d9c1 c3 da d9			jp .chk_fault 
d9c4			.chk_fault4:  
d9c4 2a 26 e8			ld hl, (chk_data_ovr) 
d9c7 ed 5b 9d e2		ld de,(chk_word) 
d9cb				if DEBUG_STK_FAULT 
d9cb					DMARK "FA3" 
d9cb					CALLMONITOR 
d9cb				endif 
d9cb cd f9 8c			call cmp16 
d9ce ca d7 d9			jp z, .chk_fault5 
d9d1 11 78 da			ld de, sfaultdo 
d9d4 c3 da d9			jp .chk_fault 
d9d7			 
d9d7			 
d9d7			.chk_fault5:  
d9d7 d1				pop de 
d9d8 e1				pop hl 
d9d9			 
d9d9 c9				ret 
d9da			 
d9da cd ae 8a		.chk_fault: 	call clear_display 
d9dd 3e 28				ld a, display_row_2 
d9df cd c1 8a				call str_at_display 
d9e2 11 08 da				   ld de, .stackfault 
d9e5 3e 00				ld a, display_row_1 
d9e7 cd c1 8a				call str_at_display 
d9ea 11 6b ee				    ld de, debug_mark 
d9ed 3e 11				ld a, display_row_1+17 
d9ef cd c1 8a				call str_at_display 
d9f2 cd d1 8a				call update_display 
d9f5			 
d9f5				; prompt before entering montior for investigating issue 
d9f5			 
d9f5 3e 78			ld a, display_row_4 
d9f7 11 54 97			ld de, endprog 
d9fa			 
d9fa cd d1 8a			call update_display		 
d9fd			 
d9fd cd da 99			call next_page_prompt 
da00			 
da00 d1				pop de 
da01 e1				pop hl 
da02 cd a8 97				call monitor 
da05 c3 9e 96				jp warmstart 
da08					;jp 0 
da08					;halt 
da08			 
da08			 
da08			 
da08 .. 00		.stackfault: 	db "Stack fault:",0 
da15			 
da15 .. 00		sfaultsu: 	db	"Stack under flow",0 
da26 .. 00		sfaultso: 	db	"Stack over flow",0 
da36 .. 00		sfaultru:	db "RTS underflow",0 
da44 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
da5e .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
da78 .. 00		sfaultdo:	db "DTS overflow", 0 
da85			 
da85			 
da85			fault_dsp_under: 
da85 11 97 da			ld de, .dsp_under 
da88 c3 47 db			jp .show_fault 
da8b			 
da8b			fault_rsp_under: 
da8b 11 a5 da			ld de, .rsp_under 
da8e c3 47 db			jp .show_fault 
da91			fault_loop_under: 
da91 11 b3 da			ld de, .loop_under 
da94 c3 47 db			jp .show_fault 
da97			 
da97 .. 00		.dsp_under: db "DSP Underflow",0 
daa5 .. 00		.rsp_under: db "RSP Underflow",0 
dab3 .. 00		.loop_under: db "LOOP Underflow",0 
dac2			 
dac2			 
dac2 d5			type_faultn: 	push de 
dac3 e5					push hl 
dac4 cd ae 8a				call clear_display 
dac7 11 ee da				   ld de, .typefaultn 
daca 3e 00				ld a, display_row_1 
dacc cd c1 8a				call str_at_display 
dacf 11 6b ee				    ld de, debug_mark 
dad2 3e 11				ld a, display_row_1+17 
dad4 cd c1 8a				call str_at_display 
dad7 cd d1 8a				call update_display 
dada			 
dada				; prompt before entering montior for investigating issue 
dada			 
dada 3e 78			ld a, display_row_4 
dadc 11 54 97			ld de, endprog 
dadf			 
dadf cd d1 8a			call update_display		 
dae2			 
dae2 cd da 99			call next_page_prompt 
dae5			 
dae5 e5					push hl 
dae6 d5					push de 
dae7 cd a8 97				call monitor 
daea c3 9e 96				jp warmstart 
daed 76					halt 
daee			 
daee			 
daee .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
db05			 
db05 d5			type_faults: 	push de 
db06 e5					push hl 
db07 cd ae 8a				call clear_display 
db0a 11 30 db				   ld de, .typefaults 
db0d 3e 00				ld a, display_row_1 
db0f cd c1 8a				call str_at_display 
db12 11 6b ee				    ld de, debug_mark 
db15 3e 11				ld a, display_row_1+17 
db17 cd c1 8a				call str_at_display 
db1a cd d1 8a				call update_display 
db1d			 
db1d				; prompt before entering montior for investigating issue 
db1d			 
db1d 3e 78			ld a, display_row_4 
db1f 11 54 97			ld de, endprog 
db22			 
db22 cd d1 8a			call update_display		 
db25			 
db25 cd da 99			call next_page_prompt 
db28			 
db28 e1					pop hl 
db29 d1					pop de 
db2a cd a8 97				call monitor 
db2d c3 9e 96				jp warmstart 
db30			 
db30			 
db30 .. 00		.typefaults: db "STR Type Expected TOS!",0 
db47			 
db47			.show_fault: 	 
db47 d5					push de 
db48 cd ae 8a				call clear_display 
db4b d1					pop de 
db4c 3e 00				ld a, display_row_1 
db4e cd c1 8a				call str_at_display 
db51 11 6b ee				    ld de, debug_mark 
db54 3e 11				ld a, display_row_1+17 
db56 cd c1 8a				call str_at_display 
db59 cd d1 8a				call update_display 
db5c			 
db5c				; prompt before entering montior for investigating issue 
db5c			 
db5c 3e 78			ld a, display_row_4 
db5e 11 54 97			ld de, endprog 
db61			 
db61 cd d1 8a			call update_display		 
db64			 
db64 cd da 99			call next_page_prompt 
db67			 
db67 e1					pop hl 
db68 d1					pop de 
db69 cd a8 97				call monitor 
db6c			; do a dump to cli and not warmstart so we preserve all of the uwords.  
db6c			; TODO Make optional fault restart to cli or warm boot? 
db6c					;jp warmstart 
db6c c3 e8 96				jp cli 
db6f 76					halt 
db70			 
db70			; handle the auto run of code from files in storage 
db70			 
db70			 
db70			include "forth_startup.asm" 
db70			; Which startup method to use? 
db70			; 
db70			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
db70			; followed by loading of a list of scripts in eeprom 
db70			 
db70			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
db70			; from eeprom 
db70			 
db70			; Select with define in main stubs 
db70			 
db70			if STARTUP_V1 
db70				include "forth_startupv1.asm" 
db70			; Startup script loading version 1 
db70			 
db70			; If SE storage is available first stage is to use the selected file 
db70			; then go through the eeprom list 
db70			 
db70 .. 00		sprompt1: db "Startup load...",0 
db80 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
db96			 
db96			 
db96			 
db96			 
db96			forth_startup: 
db96 21 e3 cc			ld hl, startcmds 
db99 3e 00			ld a, 0 
db9b 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
db9e			 
db9e e5			.start1:	push hl 
db9f cd ae 8a			call clear_display 
dba2 11 70 db			ld de, sprompt1 
dba5 3e 00		        ld a, display_row_1 
dba7 cd c1 8a			call str_at_display 
dbaa 11 80 db			ld de, sprompt2 
dbad 3e 28		        ld a, display_row_2 
dbaf cd c1 8a			call str_at_display 
dbb2 e1				pop hl 
dbb3 e5				push hl 
dbb4 5e				ld e,(hl) 
dbb5 23				inc hl 
dbb6 56				ld d,(hl) 
dbb7 3e 50		        ld a, display_row_3 
dbb9 cd c1 8a			call str_at_display 
dbbc cd d1 8a			call update_display 
dbbf			 
dbbf			 
dbbf 3a e7 e6			ld a, (os_last_cmd) 
dbc2 fe 00			cp 0 
dbc4 28 05			jr z, .startprompt 
dbc6 cd e5 89			call delay250ms 
dbc9 18 24			jr .startdo 
dbcb				 
dbcb				 
dbcb			 
dbcb			.startprompt: 
dbcb			 
dbcb 3e 9f			ld a,display_row_4 + display_cols - 1 
dbcd 11 d8 99		        ld de, endprg 
dbd0 cd c1 8a			call str_at_display 
dbd3 cd d1 8a			call update_display 
dbd6 cd f1 89			call delay1s 
dbd9 cd fc dc			call cin_wait 
dbdc						 
dbdc fe 2a			cp '*' 
dbde 28 5e			jr z, .startupend1 
dbe0 fe 23			cp '#' 
dbe2 20 07			jr nz, .startno 
dbe4 3e 01			ld a, 1 
dbe6 32 e7 e6			ld (os_last_cmd),a 
dbe9 18 04			jr .startdo 
dbeb fe 31		.startno:	cp '1' 
dbed 28 3a			jr z,.startnxt  
dbef			 
dbef				; exec startup line 
dbef			.startdo:	 
dbef e1				pop hl 
dbf0 e5				push hl 
dbf1				 
dbf1 5e				ld e,(hl) 
dbf2 23				inc hl 
dbf3 56				ld d,(hl) 
dbf4 eb				ex de,hl 
dbf5			 
dbf5 e5				push hl 
dbf6			 
dbf6 3e 00			ld a, 0 
dbf8				;ld a, FORTH_END_BUFFER 
dbf8 cd 4c 90			call strlent 
dbfb 23				inc hl   ; include zero term to copy 
dbfc 06 00			ld b,0 
dbfe 4d				ld c,l 
dbff e1				pop hl 
dc00 11 c1 e2			ld de, scratch 
dc03 ed b0			ldir 
dc05			 
dc05			 
dc05 21 c1 e2			ld hl, scratch 
dc08 cd 6b 9e			call forthparse 
dc0b cd ab 9e			call forthexec 
dc0e cd bd 9d			call forthexec_cleanup 
dc11			 
dc11 3e 78			ld a, display_row_4 
dc13 11 54 97			ld de, endprog 
dc16			 
dc16 cd d1 8a			call update_display		 
dc19			 
dc19 3a e7 e6			ld a, (os_last_cmd) 
dc1c fe 00			cp 0 
dc1e 20 09			jr nz, .startnxt 
dc20 cd da 99			call next_page_prompt 
dc23 cd ae 8a		        call clear_display 
dc26 cd d1 8a			call update_display		 
dc29			 
dc29				; move onto next startup line? 
dc29			.startnxt: 
dc29			 
dc29 cd e5 89			call delay250ms 
dc2c e1				pop hl 
dc2d			 
dc2d 23				inc hl 
dc2e 23				inc hl 
dc2f			 
dc2f e5				push hl 
dc30 5e				ld e, (hl) 
dc31 23				inc hl 
dc32 56				ld d, (hl) 
dc33 e1				pop hl 
dc34				; TODO replace 0 test 
dc34			 
dc34 eb				ex de, hl 
dc35 cd 04 8d			call ishlzero 
dc38			;	ld a,e 
dc38			;	add d 
dc38			;	cp 0    ; any left to do? 
dc38 eb				ex de, hl 
dc39 c2 9e db			jp nz, .start1 
dc3c 18 01			jr .startupend 
dc3e			 
dc3e e1			.startupend1: pop hl 
dc3f			.startupend: 
dc3f			 
dc3f cd ae 8a			call clear_display 
dc42 cd d1 8a			call update_display 
dc45 c9				ret 
dc46			if STORAGE_SE 
dc46			 
dc46			sprompt3: db "Loading from start-up file?:",0 
dc46			sprompt4: db "(Y=Any key/N=No)",0 
dc46			 
dc46			 
dc46			forth_autoload: 
dc46			 
dc46				; load block 0 of store 1 
dc46				 
dc46				ld a, $fe      ; bit 0 clear 
dc46				ld (spi_device), a 
dc46			 
dc46				call storage_get_block_0 
dc46			 
dc46				ld a, (store_page+STORE_0_AUTOFILE) 
dc46			 
dc46				cp 0 
dc46				ret z     ; auto start not enabled 
dc46			 
dc46				call clear_display 
dc46			 
dc46				; set bank 
dc46			 
dc46					ld a, (store_page+STORE_0_BANKRUN) 
dc46					ld (spi_device), a 
dc46			 
dc46				; get file id to load from and get the file name to display 
dc46			 
dc46					ld a, (store_page+STORE_0_FILERUN) 
dc46			 
dc46					ld l, 0 
dc46					ld h, a 
dc46					ld de, store_page 
dc46			 
dc46					if DEBUG_FORTH_WORDS 
dc46						DMARK "ASp" 
dc46						CALLMONITOR 
dc46					endif 
dc46					call storage_read 
dc46			 
dc46					if DEBUG_FORTH_WORDS 
dc46						DMARK "ASr" 
dc46						CALLMONITOR 
dc46					endif 
dc46			 
dc46					call ishlzero 
dc46					ret z             ; file not found 
dc46			 
dc46					ld a, display_row_2 + 10 
dc46					ld de, store_page+3 
dc46					call str_at_display 
dc46				 
dc46			; 
dc46			 
dc46				ld a, display_row_1+5 
dc46				ld de, sprompt3 
dc46				call str_at_display 
dc46				ld a, display_row_3+15 
dc46				ld de, sprompt4 
dc46				call str_at_display 
dc46			 
dc46				call update_display 
dc46			 
dc46				call cin_wait 
dc46				cp 'n' 
dc46				ret z 
dc46				cp 'N' 
dc46				ret z 
dc46			 
dc46				call delay1s 
dc46			 
dc46				ld a, (store_page+2) 
dc46				ld (store_openmaxext), a    ; save count of ext 
dc46				ld a, 1  
dc46				ld (store_openext), a    ; save count of ext 
dc46			 
dc46			.autof:  
dc46				ld l , a 
dc46				 
dc46				ld a, (store_page) 
dc46				ld h, a	 
dc46				ld de, store_page 
dc46					if DEBUG_FORTH_WORDS 
dc46						DMARK "ASl" 
dc46						CALLMONITOR 
dc46					endif 
dc46					call storage_read 
dc46				call ishlzero 
dc46				ret z 
dc46			;	jr z, .autoend 
dc46			 
dc46					if DEBUG_FORTH_WORDS 
dc46						DMARK "ASc" 
dc46						CALLMONITOR 
dc46					endif 
dc46				ld de, store_page+2 
dc46				ld a, display_row_4 
dc46				call str_at_display 
dc46			 
dc46				call update_display 
dc46				call delay250ms 
dc46			 
dc46			 
dc46			 
dc46				ld hl, store_page+2 
dc46				call forthparse 
dc46				call forthexec 
dc46				call forthexec_cleanup 
dc46			 
dc46				 
dc46				ld a, (store_openext) 
dc46				inc a 
dc46				ld (store_openext), a    ; save count of ext 
dc46			 
dc46				jr .autof 
dc46			;.autofdone: 
dc46			; 
dc46			;		if DEBUG_FORTH_WORDS 
dc46			;			DMARK "ASx" 
dc46			;			CALLMONITOR 
dc46			;		endif 
dc46			;;	call clear_display 
dc46			;	ret 
dc46			 
dc46			 
dc46			 
dc46			endif 
# End of file forth_startupv1.asm
dc46			endif 
dc46			if STARTUP_V2 
dc46				include "forth_startupv2.asm" 
dc46			endif 
dc46			 
# End of file forth_startup.asm
dc46			 
dc46			; eof 
# End of file forth_kernel.asm
dc46			;include "nascombasic.asm" 
dc46			 
dc46			 
dc46			; find out where the code ends if loaded into RAM (for SC114) 
dc46			;endofcode:  
dc46			;	nop 
dc46			 
dc46			 
dc46			; jump to nmi vector 
dc46			 
dc46			init_nmi: 
dc46 3e c9			ld a, $c9   ; RET 
dc48 32 72 ee			ld (nmi_vector), a 
dc4b c9				ret 
dc4c			nmi: 
dc4c e5				push hl 
dc4d d5				push de 
dc4e c5				push bc 
dc4f f5				push af 
dc50 cd 72 ee			call nmi_vector 
dc53 f5				push af 
dc54 c5				push bc 
dc55 d5				push de 
dc56 e5				push hl 
dc57 ed 4d			reti 
dc59			 
dc59			 
dc59			; eof 
dc59			 
# End of file main.asm
dc59			;include "firmware_lcd_4x40.asm" 
dc59			;;include "firmware_lcd_4x20.asm" 
dc59			include "firmware_serial_display.asm" 
dc59			 
dc59			; Serial display interface for SC114 
dc59			 
dc59			 
dc59			display_row_1: equ 0 
dc59			display_row_2: equ display_row_1+display_cols 
dc59			display_row_3: equ display_row_2 + display_cols 
dc59			display_row_4: equ display_row_3 + display_cols 
dc59			 
dc59			kLCDWidth:  EQU display_cols             ;Width in characters 
dc59			kLCD_Line1: EQU 0x00  
dc59			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
dc59			; E1 
dc59			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
dc59			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
dc59			 
dc59			lcd_init: 
dc59				; no init as handled by the SCM bios 
dc59 c9				ret 
dc5a			 
dc5a			 
dc5a			; low level functions for direct screen writes 
dc5a			 
dc5a			; output char at pos? 
dc5a			fLCD_Str: 
dc5a			        ;out (SC114_SIO_1_OUT),a 
dc5a c5				push bc 
dc5b 0e 02			ld c, $02 
dc5d f7				rst $30 
dc5e c1				pop bc 
dc5f c9				ret 
dc60			 
dc60			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
dc60			fLCD_Pos: 
dc60				; use ASCII escape to position 
dc60			        ;out (SC114_SIO_1_OUT),a 
dc60 c5				push bc 
dc61 0e 02			ld c, $02 
dc63 f7				rst $30 
dc64 c1				pop bc 
dc65			 
dc65 c9				ret 
dc66			 
dc66			; output char at pos 
dc66			fLCD_Data: 
dc66			      ;  out (SC114_SIO_1_OUT),a 
dc66 c5				push bc 
dc67 0e 02			ld c, $02 
dc69 f7				rst $30 
dc6a c1				pop bc 
dc6b			 
dc6b c9				ret 
dc6c			 
dc6c			; ascii cls  
dc6c			 
dc6c 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
dc70			 
dc70			; write the frame buffer given in hl to hardware  
dc70			write_display: 
dc70			 
dc70			API: equ 0 
dc70			 
dc70			if API 
dc70				push bc 
dc70				ld b, 4 
dc70			 
dc70			        ld (display_write_tmp), hl 	  
dc70			 
dc70				; clear and home cursor 
dc70			 
dc70				ld c, 6 
dc70				ld de, .cls 
dc70				rst $30 
dc70			 
dc70			 
dc70			.writeln: 
dc70			 
dc70				ld de, (display_write_tmp) 
dc70				ld c, 6 
dc70				rst $30 
dc70				ld c, 7 
dc70				rst $30 
dc70			 
dc70				ld hl, (display_write_tmp) 
dc70				ld de, display_cols 
dc70				add hl,de 
dc70				ld (display_write_tmp),hl 
dc70			 
dc70				djnz  .writeln 
dc70			 
dc70				pop bc 
dc70			 
dc70			 
dc70				ret 
dc70			endif 
dc70 e5				push hl 
dc71 c5				push bc 
dc72 d5				push de 
dc73			 
dc73			;	ld c, 2 
dc73			;	;ld de, .cls 
dc73			;	ld a, 27 
dc73			;	rst $30 
dc73			;	ld c, 2 
dc73			;	;ld de, .cls 
dc73			;	ld a, '[' 
dc73			;	rst $30 
dc73			; 
dc73			;	ld c, 2 
dc73			;	;ld de, .cls 
dc73			;	ld a, 'H' 
dc73			;	rst $30 
dc73			; 
dc73			 
dc73 0e 02			ld c, 2 
dc75				;ld de, .cls 
dc75 3e 1b			ld a, 27 
dc77 f7				rst $30 
dc78			 
dc78			 
dc78 0e 02			ld c, 2 
dc7a				;ld de, .cls 
dc7a 3e 5b			ld a, '[' 
dc7c f7				rst $30 
dc7d 0e 02			ld c, 2 
dc7f				;ld de, .cls 
dc7f 3e 32			ld a, '2' 
dc81 f7				rst $30 
dc82 0e 02			ld c, 2 
dc84				;ld de, .cls 
dc84 3e 4a			ld a, 'J' 
dc86 f7				rst $30 
dc87 d1				pop de 
dc88 c1				pop bc 
dc89 e1				pop hl 
dc8a			 
dc8a			 
dc8a 22 c9 eb		        ld (display_write_tmp), hl 	  
dc8d 3e 00			ld a, kLCD_Line1 
dc8f			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
dc8f 06 28			ld b, display_cols 
dc91 ed 5b c9 eb		ld de, (display_write_tmp) 
dc95 cd f3 dc			call write_len_string 
dc98				 
dc98			 
dc98 e5			push hl 
dc99 d5			push de 
dc9a c5			push bc 
dc9b 0e 07			ld c, 7 
dc9d f7				rst $30 
dc9e c1			pop bc 
dc9f d1			pop de 
dca0 e1			pop hl 
dca1			 
dca1				 
dca1 2a c9 eb			ld hl, (display_write_tmp) 
dca4 11 28 00			ld de, display_cols 
dca7 19				add hl,de 
dca8 22 c9 eb			ld (display_write_tmp),hl 
dcab			 
dcab				 
dcab 3e 28			ld a, kLCD_Line2 
dcad			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
dcad 06 28			ld b, display_cols 
dcaf ed 5b c9 eb		ld de, (display_write_tmp) 
dcb3 cd f3 dc			call write_len_string 
dcb6				 
dcb6 2a c9 eb			ld hl, (display_write_tmp) 
dcb9 11 28 00			ld de, display_cols 
dcbc 19				add hl,de 
dcbd 22 c9 eb			ld (display_write_tmp),hl 
dcc0			 
dcc0 e5			push hl 
dcc1 d5			push de 
dcc2 c5			push bc 
dcc3 0e 07			ld c, 7 
dcc5 f7				rst $30 
dcc6 c1			pop bc 
dcc7 d1			pop de 
dcc8 e1			pop hl 
dcc9			 
dcc9				 
dcc9 3e 50			ld a, kLCD_Line3 
dccb			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
dccb 06 28			ld b, display_cols 
dccd ed 5b c9 eb		ld de, (display_write_tmp) 
dcd1 cd f3 dc			call write_len_string 
dcd4				 
dcd4 2a c9 eb			ld hl, (display_write_tmp) 
dcd7 11 28 00			ld de, display_cols 
dcda 19				add hl,de 
dcdb 22 c9 eb			ld (display_write_tmp),hl 
dcde			 
dcde e5			push hl 
dcdf d5			push de 
dce0 c5			push bc 
dce1 0e 07			ld c, 7 
dce3 f7				rst $30 
dce4 c1			pop bc 
dce5 d1			pop de 
dce6 e1			pop hl 
dce7			 
dce7				 
dce7 3e 78			ld a, kLCD_Line4 
dce9			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
dce9 06 28			ld b, display_cols 
dceb ed 5b c9 eb		ld de, (display_write_tmp) 
dcef cd f3 dc			call write_len_string 
dcf2 c9					ret 
dcf3			 
dcf3			 
dcf3				; write out a fixed length string given in b from de 
dcf3			 
dcf3 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
dcf4 cd 66 dc		            CALL fLCD_Data      ;Write character to display 
dcf7 13				inc de 
dcf8 10 f9			djnz write_len_string 
dcfa c9				ret 
dcfb			 
dcfb			 
dcfb			; eof 
# End of file firmware_serial_display.asm
dcfb			;include "firmware_key_5x10.asm" 
dcfb			;;include "firmware_key_4x10.asm" 
dcfb			include "firmware_key_serial.asm" 
dcfb			; Serial keyboard interface for SC114 
dcfb			 
dcfb			key_init: 
dcfb				; no init as handled by the SCM bios 
dcfb c9				ret 
dcfc			 
dcfc			 
dcfc			cin_wait: 
dcfc			;	ld a, 0 
dcfc			;	ret 
dcfc			 
dcfc				;in a,(SC114_SIO_1_IN) 
dcfc			        ; Use SCM API to get from whatever console device we are using 
dcfc c5				push bc 
dcfd 0e 01			ld c, $01 
dcff f7				rst $30 
dd00 c1				pop bc 
dd01 c9				ret 
dd02			 
dd02			cin: 
dd02			 
dd02			 
dd02 c5				push bc 
dd03			 
dd03				; any key waiting to process? 
dd03 0e 03			ld c, $03 
dd05 f7				rst $30 
dd06 28 05			jr z, .cin_skip 
dd08			 
dd08				; yep, get it 
dd08			 
dd08 0e 01			ld c, $01 
dd0a f7				rst $30 
dd0b c1				pop bc 
dd0c c9				ret 
dd0d			.cin_skip: 
dd0d 3e 00			ld a, 0 
dd0f c1				pop bc 
dd10 c9				ret 
dd11			 
dd11			 
dd11			 
dd11			 
# End of file firmware_key_serial.asm
dd11			endofcode:  
dd11			baseram:  
dd11 00				nop 
dd12			 
dd12			heap_start: equ baseram+15  ; Starting address of heap 
dd12			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
dd12			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
dd12			;VDU:  EQU     endofcode           ; BASIC Work space 
dd12			; eof 
dd12			 
# End of file os_mega_sc114.asm
dd12
