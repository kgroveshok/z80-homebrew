# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 96 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 1  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
001c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd 18 0d				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd 18 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd 18 0d				call clear_display  
0037			  
0037			  
0037 cd 43 70				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd da 72			call key_init  
003d cd fe 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd ef 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd ac 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd 3b 0d			call update_display  
0049 cd 95 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd 1d 0d			call fill_display  
0051 cd 3b 0d			call update_display  
0054 cd 95 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd 1d 0d			call fill_display  
005c cd 3b 0d			call update_display  
005f cd 95 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd 1d 0d			call fill_display  
0067 cd 3b 0d			call update_display  
006a cd 95 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 c9 1a			ld de, prom_bootmsg  
0072 cd 2b 0d			call str_at_display  
0075 cd 3b 0d			call update_display  
0078			  
0078			  
0078 cd 95 0c			call delay1s  
007b cd 95 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 de 1a			ld de, prom_bootmsg1  
0083 cd 2b 0d			call str_at_display  
0086 cd 3b 0d			call update_display  
0089 cd 95 0c			call delay1s  
008c cd 95 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			;  Perform SCLK wait pulse 
00a0			 
00a0			spi_clk: 
00a0 f5				push af 
00a1 3a 6b fa			ld a, (spi_clktime) 
00a4 fe 00			cp 0 
00a6 28 03			jr z, .scskip 
00a8 cd 7a 0c			call aDelayInMS 
00ab			.scskip: 
00ab f1				pop af 
00ac c9				ret 
00ad			 
00ad			 
00ad			 
00ad			; TODO store port id for spi device ie dev c 
00ad			; TODO store pin for SO 
00ad			; TODO store pin for SI 
00ad			; TODO store pin for SCLK 
00ad			 
00ad			; 
00ad			 
00ad			; ensure that spi bus is in a stable state with default pins  
00ad			 
00ad			se_stable_spi:   
00ad			 
00ad				 ; set DI high, CE high , SCLK low 
00ad				;ld a, SPI_DI | SPI_CE0 
00ad 3e 07			ld a, SPI_DI  
00af cd b9 01			call spi_ce_high 
00b2 d3 80			 out (storage_adata),a 
00b4 32 68 fa			ld (spi_portbyte),a 
00b7			 
00b7				if DEBUG_SPI 
00b7					push hl 
00b7					ld l, a 
00b7					DMARK "SPI" 
00b7					CALLMONITOR 
00b7					pop hl 
00b7				endif 
00b7 c9				ret 
00b8			 
00b8			; byte to send in a 
00b8			 
00b8			spi_send_byte: 
00b8				; save byte to send for bit mask shift out 
00b8 4f			        ld c,a 
00b9 3a 68 fa			ld a,(spi_portbyte) 
00bc				  
00bc				; clock out	each bit of the byte msb first 
00bc			 
00bc 06 08			ld b, 8 
00be			.ssb1: 
00be				; clear so bit  
00be cb bf			res SPI_DI, a 
00c0 cb 11			rl c 
00c2				; if bit 7 is set then carry is set 
00c2 30 02			jr nc, .ssb2 
00c4 cb ff			set SPI_DI,a 
00c6			.ssb2:  ; output bit to ensure it is stable 
00c6 d3 80			out (storage_adata),a 
00c8 00				nop 
00c9				; clock bit high 
00c9 cb ef			set SPI_SCLK,a 
00cb d3 80			out (storage_adata),a 
00cd 00				nop 
00ce cd a0 00			call spi_clk 
00d1				; then low 
00d1 cb af			res SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6 cd a0 00			call spi_clk 
00d9 10 e3			djnz .ssb1 
00db			 
00db 32 68 fa			ld (spi_portbyte),a 
00de c9				ret 
00df			 
00df			; TODO low level get byte into A on spi 
00df			 
00df			spi_read_byte:  
00df			 
00df				; save byte to send for bit mask shift out 
00df 0e 00		    ld c,0 
00e1 3a 68 fa			ld a,(spi_portbyte) 
00e4				  
00e4				; clock out	each bit of the byte msb first 
00e4			 
00e4			 
00e4				; clock bit high 
00e4 cb ef			set SPI_SCLK,a 
00e6 d3 80			out (storage_adata),a 
00e8 00				nop 
00e9 cd a0 00			call spi_clk 
00ec			 
00ec			    ; read DO  
00ec			 
00ec cb f9		    set 7,c 
00ee db 80			in a,(storage_adata) 
00f0 cb 77		    bit SPI_DO,a 
00f2 20 02		    jr nz, .b7 
00f4 cb b9		    res 7,c 
00f6			.b7: 
00f6				; then low 
00f6 cb af			res SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb cd a0 00			call spi_clk 
00fe			     
00fe			 
00fe				; clock bit high 
00fe cb ef			set SPI_SCLK,a 
0100 d3 80			out (storage_adata),a 
0102 00				nop 
0103 cd a0 00			call spi_clk 
0106			 
0106			    ; read DO  
0106			 
0106 cb f1		    set 6,c 
0108 db 80			in a,(storage_adata) 
010a cb 77		    bit SPI_DO,a 
010c 20 02		    jr nz, .b6 
010e cb b1		    res 6,c 
0110			.b6: 
0110				; then low 
0110 cb af			res SPI_SCLK,a 
0112 d3 80			out (storage_adata),a 
0114 00				nop 
0115 cd a0 00			call spi_clk 
0118			 
0118				; clock bit high 
0118 cb ef			set SPI_SCLK,a 
011a d3 80			out (storage_adata),a 
011c 00				nop 
011d cd a0 00			call spi_clk 
0120			 
0120			 
0120			    ; read DO  
0120			 
0120 cb e9		    set 5,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b5 
0128 cb a9		    res 5,c 
012a			.b5: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f cd a0 00			call spi_clk 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137 cd a0 00			call spi_clk 
013a			 
013a			    ; read DO  
013a			 
013a cb e1		    set 4,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b4 
0142 cb a1		    res 4,c 
0144			.b4: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149 cd a0 00			call spi_clk 
014c				; clock bit high 
014c cb ef			set SPI_SCLK,a 
014e d3 80			out (storage_adata),a 
0150 00				nop 
0151 cd a0 00			call spi_clk 
0154			 
0154			    ; read DO  
0154			 
0154 cb d9		    set 3,c 
0156 db 80			in a,(storage_adata) 
0158 cb 77		    bit SPI_DO,a 
015a 20 02		    jr nz, .b3 
015c cb 99		    res 3,c 
015e			.b3: 
015e				; then low 
015e cb af			res SPI_SCLK,a 
0160 d3 80			out (storage_adata),a 
0162 00				nop 
0163 cd a0 00			call spi_clk 
0166				; clock bit high 
0166 cb ef			set SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b cd a0 00			call spi_clk 
016e			 
016e			    ; read DO  
016e			 
016e cb d1		    set 2,c 
0170 db 80			in a,(storage_adata) 
0172 cb 77		    bit SPI_DO,a 
0174 20 02		    jr nz, .b2 
0176 cb 91		    res 2,c 
0178			.b2: 
0178				; then low 
0178 cb af			res SPI_SCLK,a 
017a d3 80			out (storage_adata),a 
017c 00				nop 
017d cd a0 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184 00				nop 
0185 cd a0 00			call spi_clk 
0188			 
0188			    ; read DO  
0188			 
0188 cb c9		    set 1,c 
018a db 80			in a,(storage_adata) 
018c cb 77		    bit SPI_DO,a 
018e 20 02		    jr nz, .b1 
0190 cb 89		    res 1,c 
0192			.b1: 
0192				; then low 
0192 cb af			res SPI_SCLK,a 
0194 d3 80			out (storage_adata),a 
0196 00				nop 
0197 cd a0 00			call spi_clk 
019a				; clock bit high 
019a cb ef			set SPI_SCLK,a 
019c d3 80			out (storage_adata),a 
019e 00				nop 
019f cd a0 00			call spi_clk 
01a2			 
01a2			    ; read DO  
01a2			 
01a2 cb c1		    set 0,c 
01a4 db 80			in a,(storage_adata) 
01a6 cb 77		    bit SPI_DO,a 
01a8 20 02		    jr nz, .b0 
01aa cb 81		    res 0,c 
01ac			.b0: 
01ac				; then low 
01ac cb af			res SPI_SCLK,a 
01ae d3 80			out (storage_adata),a 
01b0 00				nop 
01b1 cd a0 00			call spi_clk 
01b4			 
01b4			 
01b4 32 68 fa			ld (spi_portbyte),a 
01b7			 
01b7			    ; return byte 
01b7 79			    ld a,c 
01b8			 
01b8			 
01b8 c9				ret 
01b9			 
01b9			 
01b9			 
01b9			spi_ce_high: 
01b9			 
01b9				if DEBUG_SPI_HARD_CE0 
01b9			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b9					ret 
01b9			 
01b9				endif 
01b9			 
01b9			 
01b9 f5				push af 
01ba			 
01ba				; send direct ce to port b 
01ba 3e ff			ld a, 255 
01bc d3 81			out (storage_bdata), a 
01be			 
01be f1				pop af 
01bf			 
01bf				; for port a that shares with spi lines AND the mask 
01bf			  
01bf				if DEBUG_SPI 
01bf					push hl 
01bf					ld h, a 
01bf				endif 
01bf			;	ld c, SPI_CE_HIGH 
01bf			;	and c 
01bf cb c7			set SPI_CE0, a 
01c1 cb cf			set SPI_CE1, a 
01c3 cb d7			set SPI_CE2, a 
01c5 cb df			set SPI_CE3, a 
01c7 cb e7			set SPI_CE4, a 
01c9			 
01c9				if DEBUG_SPI 
01c9					ld l, a 
01c9					DMARK "CEh" 
01c9					CALLMONITOR 
01c9					pop hl 
01c9				endif 
01c9 c9				ret 
01ca			 
01ca			 
01ca			spi_ce_low: 
01ca			 
01ca				if DEBUG_SPI_HARD_CE0 
01ca			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ca					ret 
01ca			 
01ca				endif 
01ca			 
01ca c5				push bc 
01cb f5				push af 
01cc			 
01cc				; send direct ce to port b 
01cc 3a 6a fa			ld a, (spi_cartdev) 
01cf d3 81			out (storage_bdata), a 
01d1			 
01d1			 
01d1			 
01d1				; for port a that shares with spi lines AND the mask 
01d1			 
01d1 3a 67 fa			ld a, (spi_device)  
01d4 4f				ld c, a 
01d5			 
01d5 f1				pop af 
01d6			 
01d6				; detect CEx 
01d6			 
01d6				if DEBUG_SPI 
01d6					push hl 
01d6					ld h, a 
01d6				endif 
01d6			 
01d6 cb 41			bit SPI_CE0, c 
01d8 20 04			jr nz, .cel1 
01da cb 87			res SPI_CE0, a 
01dc 18 1e			jr .celn 
01de			.cel1: 
01de cb 49			bit SPI_CE1, c 
01e0 20 04			jr nz, .cel2 
01e2 cb 8f			res SPI_CE1, a 
01e4 18 16			jr .celn 
01e6			.cel2: 
01e6 cb 51			bit SPI_CE2, c 
01e8 20 04			jr nz, .cel3 
01ea cb 97			res SPI_CE2, a 
01ec 18 0e			jr .celn 
01ee			.cel3: 
01ee cb 59			bit SPI_CE3, c 
01f0 20 04			jr nz, .cel4 
01f2 cb 9f			res SPI_CE3, a 
01f4 18 06			jr .celn 
01f6			.cel4: 
01f6 cb 61			bit SPI_CE4, c 
01f8 20 02			jr nz, .celn 
01fa cb a7			res SPI_CE4, a 
01fc			.celn: 
01fc			 
01fc			 
01fc			 
01fc			;	add c 
01fc			 
01fc				if DEBUG_SPI 
01fc					ld l, a 
01fc					DMARK "CEl" 
01fc					CALLMONITOR 
01fc					pop hl 
01fc				endif 
01fc c1				pop bc 
01fd c9				ret 
01fe			 
01fe			 
01fe			 
01fe			; eof 
01fe			 
01fe			 
01fe			 
01fe			 
01fe			 
# End of file firmware_spi.asm
01fe				include "firmware_seeprom.asm"  
01fe			; 
01fe			; persisent storage interface via microchip serial eeprom 
01fe			 
01fe			; port a pio 2 
01fe			; pa 7 - si 
01fe			; pa 6 - sclk  
01fe			; pa 5 - so 
01fe			; pa 4 - cs 
01fe			; pa 3 - cs 
01fe			; pa 2 - cs 
01fe			; pa 1 - cs 
01fe			; pa 0 - cs 
01fe			; 
01fe			; TODO get block 
01fe			; TODO save block 
01fe			; TODO load file 
01fe			; TODO save file 
01fe			; TODO get dir  
01fe			 
01fe			;  
01fe			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fe			storage_actl: equ Device_C+2     ; device c port a 
01fe			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fe			storage_bctl: equ Device_C+3     ; device c port b 
01fe			 
01fe			 
01fe			; TODO move these to hardware driver file 
01fe			 
01fe			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fe			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fe			; storage bank file system format 
01fe			; 
01fe			; first page of bank: 
01fe			; 	addr 0 - status check 
01fe			;       addr 1 - write protect flag 
01fe			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fe			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fe			;         TODO see if scanning whole of for available next file id is fast enough 
01fe			;	addr 4 > zero term string of bank label 
01fe			; 
01fe			;        
01fe			;  
01fe			; first page of any file: 
01fe			;      byte 0 - file id  
01fe			;      byte 1-17 - fixed file name  
01fe			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fe			; 
01fe			; other pages of any file: 
01fe			;      byte 0 - file id 
01fe			;      byte 1> - file data 
01fe			; 
01fe			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fe			;  
01fe			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fe			 
01fe			 
01fe			;storage_so_bit: 5 
01fe			;storage_si_bit: 7 
01fe			;storage_sclk_bit: 6 
01fe			  
01fe			 
01fe			; init storage pio 
01fe			 
01fe			storage_init: 
01fe			 
01fe			 
01fe					; set default SPI clk pulse time as disabled 
01fe			 
01fe 3e 00				ld a, 0 
0200 32 6b fa				ld (spi_clktime), a 
0203			 
0203					; init hardware 
0203			 
0203 3e cf		            LD   A, 11001111b 
0205 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0207 3e 00		            LD   A, 00000000b 
0209 cb f7			set SPI_DO,a 
020b			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
020b d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020d			 
020d 3e cf		            LD   A, 11001111b 
020f d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0211 3e 00		            LD   A, 00000000b 
0213 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0215			 
0215				; set all external spi devices off  
0215 3e ff			ld a, 255 
0217 32 67 fa			ld (spi_device), a 
021a 32 6a fa			ld (spi_cartdev), a 
021d			 
021d					; ensure the spi bus is in a default stable state 
021d cd ad 00				call se_stable_spi 
0220			 
0220			; TODO scan spi bus and gather which storage banks are present 
0220			 
0220			; populate store_bank_active  
0220			; for each ce line activate and attempt to write first byte of bank and read back 
0220			; if zero is returned then bank is empty 
0220			;   
0220			; 
0220			 
0220					; init file extent cache to save on slow reads 
0220			 
0220			;	ld hl, store_filecache 
0220			;	ld de, 0 
0220			;	ld hl,(de)	 
0220			 
0220			 
0220 c9			    ret 
0221			 
0221			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0221			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0221			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0221			 
0221			; INSTRUCTION SET 
0221			; READ 0000 0011 Read data from memory array beginning at selected address 
0221			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0221			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0221			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0221			; RDSR 0000 0101 Read STATUS register 
0221			; WRSR 0000 0001 Write STATUS register 
0221			; PE 0100 0010 Page Erase – erase one page in memory array 
0221			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0221			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0221			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0221			 
0221			; TODO send byte steam for page without setting the address for every single byte 
0221			; TODO read byte  
0221			 
0221			; byte in a 
0221			; address in hl  
0221			se_writebyte: 
0221			        
0221			    ;   ld c, a 
0221 f5			        push af 
0222 e5			        push hl 
0223			 
0223			    ; initi write mode 
0223			    ; 
0223			    ;CS low 
0223			 
0223 3a 68 fa		       ld a,(spi_portbyte) 
0226 cd ca 01			call spi_ce_low 
0229			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0229 d3 80		       out (storage_adata),a 
022b 32 68 fa		       ld (spi_portbyte), a 
022e			 
022e			    ;clock out wren instruction 
022e			 
022e 3e 06		    ld a, store_wren_ins 
0230 cd b8 00		    call spi_send_byte  
0233			 
0233			    ;cs high to enable write latch 
0233			 
0233 3a 68 fa		       ld a,(spi_portbyte) 
0236 cd b9 01			call spi_ce_high 
0239			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0239 d3 80		       out (storage_adata),a 
023b 32 68 fa		       ld (spi_portbyte), a 
023e			 
023e 00				nop 
023f			    ; 
023f			    ; intial write data 
023f			    ; 
023f			    ; cs low 
023f			     
023f 3a 68 fa		       ld a,(spi_portbyte) 
0242 cd ca 01			call spi_ce_low 
0245			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0245 d3 80		       out (storage_adata),a 
0247 32 68 fa		       ld (spi_portbyte), a 
024a			 
024a			    ; clock out write instruction 
024a			     
024a 3e 02		    ld a, store_write_ins  
024c cd b8 00		    call spi_send_byte  
024f			 
024f			    ; clock out address (depending on address size) 
024f			     
024f e1			    pop hl 
0250 7c			    ld a,h    ; address out msb first 
0251 cd b8 00		    call spi_send_byte  
0254 7d			    ld a,l 
0255 cd b8 00		    call spi_send_byte  
0258			 
0258			    ; clock out byte(s) for page 
0258			 
0258 f1			    pop af 
0259 cd b8 00		    call spi_send_byte  
025c			 
025c			    ; end write with ce high 
025c 3a 68 fa		       ld a,(spi_portbyte) 
025f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025f cd b9 01			call spi_ce_high 
0262 d3 80		       out (storage_adata),a 
0264 32 68 fa		       ld (spi_portbyte), a 
0267			 
0267				; pause for internal write cycle 
0267 3e 0a			ld a, 10 
0269 cd 7a 0c			call aDelayInMS 
026c c9			    ret 
026d			 
026d			; buffer to write in de 
026d			; address in hl  
026d			se_writepage: 
026d			        
026d			    ;   ld c, a 
026d d5				push de 
026e e5			        push hl 
026f			 
026f			    ; initi write mode 
026f			    ; 
026f			    ;CS low 
026f			 
026f 3a 68 fa		       ld a,(spi_portbyte) 
0272 cd ca 01			call spi_ce_low 
0275			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0275 d3 80		       out (storage_adata),a 
0277 32 68 fa		       ld (spi_portbyte), a 
027a			 
027a			    ;clock out wren instruction 
027a			 
027a 3e 06		    ld a, store_wren_ins 
027c cd b8 00		    call spi_send_byte  
027f			 
027f			    ;cs high to enable write latch 
027f			 
027f 3a 68 fa		       ld a,(spi_portbyte) 
0282 cd b9 01			call spi_ce_high 
0285			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 68 fa		       ld (spi_portbyte), a 
028a			 
028a 00				nop 
028b			    ; 
028b			    ; intial write data 
028b			    ; 
028b			    ; cs low 
028b			     
028b 3a 68 fa		       ld a,(spi_portbyte) 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e cd ca 01			call spi_ce_low 
0291 d3 80		       out (storage_adata),a 
0293 32 68 fa		       ld (spi_portbyte), a 
0296			 
0296			    ; clock out write instruction 
0296			     
0296 3e 02		    ld a, store_write_ins  
0298 cd b8 00		    call spi_send_byte  
029b			 
029b			    ; clock out address (depending on address size) 
029b			     
029b e1			    pop hl 
029c 7c			    ld a,h    ; address out msb first 
029d cd b8 00		    call spi_send_byte  
02a0 7d			    ld a,l 
02a1 cd b8 00		    call spi_send_byte  
02a4			 
02a4			    ; clock out byte(s) for page 
02a4			 
02a4 e1				pop hl 
02a5 06 40			ld b, STORE_BLOCK_PHY 
02a7			.bytewrite: 
02a7			 
02a7 7e				ld a,(hl) 
02a8 e5			    push hl 
02a9 c5				push bc 
02aa cd b8 00		    call spi_send_byte  
02ad c1				pop bc 
02ae e1				pop hl 
02af			 
02af			    ; end write with ce high 
02af 3a 68 fa		       ld a,(spi_portbyte) 
02b2 cd b9 01			call spi_ce_high 
02b5			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b5 d3 80		       out (storage_adata),a 
02b7 32 68 fa		       ld (spi_portbyte), a 
02ba			 
02ba 23				inc hl 
02bb 10 ea			djnz .bytewrite 
02bd			 
02bd				; pause for internal write cycle 
02bd 3e 64			ld a, 100 
02bf cd 7a 0c			call aDelayInMS 
02c2 c9			    ret 
02c3			; returns byte in a 
02c3			; address in hl  
02c3			se_readbyte: 
02c3 d5				push de 
02c4 c5				push bc 
02c5			 
02c5			    ;   ld c, a 
02c5 e5			        push hl 
02c6			 
02c6			    ; initi write mode 
02c6			    ; 
02c6			    ;CS low 
02c6			 
02c6 3a 68 fa		       ld a,(spi_portbyte) 
02c9 cd ca 01			call spi_ce_low 
02cc			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cc d3 80		       out (storage_adata),a 
02ce 32 68 fa		       ld (spi_portbyte), a 
02d1			 
02d1			    ;clock out wren instruction 
02d1			 
02d1 3e 03		    ld a, store_read_ins 
02d3 cd b8 00		    call spi_send_byte  
02d6			 
02d6			 
02d6			    ; clock out address (depending on address size) 
02d6			     
02d6 e1			    pop hl 
02d7 7c			    ld a,h    ; address out msb first 
02d8 cd b8 00		    call spi_send_byte  
02db 7d			    ld a,l 
02dc cd b8 00		    call spi_send_byte  
02df			 
02df			    ; clock in byte(s) for page 
02df			 
02df cd df 00		    call spi_read_byte  
02e2 f5				push af 
02e3			 
02e3			    ; end write with ce high 
02e3 3a 68 fa		       ld a,(spi_portbyte) 
02e6			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e6 cd b9 01			call spi_ce_high 
02e9 d3 80		       out (storage_adata),a 
02eb 32 68 fa		       ld (spi_portbyte), a 
02ee			 
02ee f1				pop af 
02ef			 
02ef c1				pop bc 
02f0 d1				pop de 
02f1			 
02f1 c9			    ret 
02f2			 
02f2			if DEBUG_STORESE 
02f2			 
02f2			storageput:  
02f2			 
02f2			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02f2			 
02f2 21 ca f1			ld hl,scratch+2 
02f5 cd 03 13			call get_word_hl 
02f8			 
02f8				; stuff it here for the moment as it will be overwritten later anyway 
02f8			 
02f8 22 eb f4			ld (os_cur_ptr),hl	 
02fb			 
02fb			 
02fb			; get pointer to start of string 
02fb			 
02fb 21 cf f1			ld hl, scratch+7 
02fe			 
02fe			; loop writing char of string to eeprom 
02fe			 
02fe 7e			.writestr:	ld a,(hl) 
02ff fe 00				cp 0 
0301 28 12				jr z, .wsdone		; done writing 
0303 e5					push hl 
0304 2a eb f4				ld hl,(os_cur_ptr) 
0307 cd 21 02				call se_writebyte 
030a			 
030a 2a eb f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030d 23					inc hl 
030e 22 eb f4				ld (os_cur_ptr),hl 
0311			 
0311					; restore string pointer and get next char 
0311			 
0311 e1					pop hl 
0312 23					inc hl 
0313 18 e9				jr .writestr 
0315			 
0315			 
0315			 
0315			.wsdone: 
0315			 
0315			 
0315			; when done load first page into a buffer  
0315			 
0315 21 00 80				ld hl,08000h		; start in ram 
0318 22 eb f4				ld (os_cur_ptr),hl 
031b 21 00 00				ld hl, 0		 ; start of page 
031e 22 f0 f1				ld (scratch+40),hl	; hang on to it 
0321			 
0321 06 80				ld b, 128		; actually get more then one page 
0323 c5			.wsload:	push bc 
0324 2a f0 f1				ld hl,(scratch+40) 
0327 e5					push hl 
0328 cd c3 02				call se_readbyte 
032b			 
032b					; a now as the byte 
032b			 
032b 2a eb f4				ld hl,(os_cur_ptr) 
032e 77					ld (hl),a 
032f					; inc next buffer area 
032f 23					inc hl 
0330 22 eb f4				ld (os_cur_ptr),hl 
0333			 
0333					; get eeprom position, inc and save for next round 
0333 e1					pop hl		 
0334 23					inc hl 
0335 22 f0 f1				ld (scratch+40),hl 
0338 c1					pop bc 
0339 10 e8				djnz .wsload 
033b			 
033b			; set 'd' pointer to start of buffer 
033b			 
033b 21 00 80				ld hl,08000h 
033e 22 eb f4				ld (os_cur_ptr),hl 
0341			 
0341			 
0341 c9			ret 
0342			 
0342			 
0342 c9			storageread: ret 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			endif 
0343			 
0343			 
0343			 
# End of file firmware_seeprom.asm
0343			else  
0343			   ; create some stubs for the labels  
0343			se_readbyte: ret  
0343			se_writebyte: ret  
0343			storage_init: ret  
0343			  
0343			endif  
0343			  
0343			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0343			;include "firmware_cf.asm"  
0343			  
0343			; load up high level storage hardward abstractions  
0343			include "firmware_storage.asm"  
0343			 
0343			; persisent storage hardware abstraction layer  
0343			 
0343			 
0343			 
0343			; Block 0 on storage is a config state 
0343			 
0343			 
0343			 
0343			; TODO add read phy block and write phy block functions 
0343			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0343			 
0343			; Abstraction layer  
0343			 
0343			; Logocial block size is same size as physical size - using tape concept 
0343			 
0343			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0343			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0343			 
0343			 
0343			 
0343			; Filesystem layout (Logical layout) 
0343			; 
0343			; Block 0 - Bank config  
0343			; 
0343			;      Byte - 0 file id counter 
0343			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0343			;      Byte - 3-20 zero terminated bank label 
0343			; 
0343			; Block 1 > File storage 
0343			; 
0343			;      Byte 0 file id    - block 0 file details 
0343			;      Byte 1 block id - block 0 is file  
0343			;            Byte 2-15 - File name 
0343			; 
0343			;       - to end of block data 
0343			; 
0343			 
0343			; Get ID for the file named in pointer held HL 
0343			; Returns ID in HL = 255 if no file found 
0343			 
0343			storage_getid: 
0343			 
0343 22 7a fa			ld (store_tmp1), hl 
0346			 
0346				if DEBUG_STORESE 
0346					DMARK "SGI" 
0346 f5				push af  
0347 3a 5b 03			ld a, (.dmark)  
034a 32 6e fe			ld (debug_mark),a  
034d 3a 5c 03			ld a, (.dmark+1)  
0350 32 6f fe			ld (debug_mark+1),a  
0353 3a 5d 03			ld a, (.dmark+2)  
0356 32 70 fe			ld (debug_mark+2),a  
0359 18 03			jr .pastdmark  
035b ..			.dmark: db "SGI"  
035e f1			.pastdmark: pop af  
035f			endm  
# End of macro DMARK
035f					CALLMONITOR 
035f cd f3 18			call break_point_state  
0362				endm  
# End of macro CALLMONITOR
0362				endif 
0362				; get block 0 and set counter for number of files to scan 
0362			 
0362 cd cd 04			call storage_get_block_0 
0365			 
0365 3a 81 fa			ld a, (store_page) 
0368 47				ld b, a 
0369			 
0369				; get extent 0 of each file id 
0369			 
0369				if DEBUG_STORESE 
0369					DMARK "SGc" 
0369 f5				push af  
036a 3a 7e 03			ld a, (.dmark)  
036d 32 6e fe			ld (debug_mark),a  
0370 3a 7f 03			ld a, (.dmark+1)  
0373 32 6f fe			ld (debug_mark+1),a  
0376 3a 80 03			ld a, (.dmark+2)  
0379 32 70 fe			ld (debug_mark+2),a  
037c 18 03			jr .pastdmark  
037e ..			.dmark: db "SGc"  
0381 f1			.pastdmark: pop af  
0382			endm  
# End of macro DMARK
0382					CALLMONITOR 
0382 cd f3 18			call break_point_state  
0385				endm  
# End of macro CALLMONITOR
0385				endif 
0385 60			.getloop:	ld h, b 
0386 2e 00				ld l, 0 
0388 c5					push bc 
0389			 
0389 11 81 fa				ld de, store_page 
038c				if DEBUG_STORESE 
038c					DMARK "SGr" 
038c f5				push af  
038d 3a a1 03			ld a, (.dmark)  
0390 32 6e fe			ld (debug_mark),a  
0393 3a a2 03			ld a, (.dmark+1)  
0396 32 6f fe			ld (debug_mark+1),a  
0399 3a a3 03			ld a, (.dmark+2)  
039c 32 70 fe			ld (debug_mark+2),a  
039f 18 03			jr .pastdmark  
03a1 ..			.dmark: db "SGr"  
03a4 f1			.pastdmark: pop af  
03a5			endm  
# End of macro DMARK
03a5					CALLMONITOR 
03a5 cd f3 18			call break_point_state  
03a8				endm  
# End of macro CALLMONITOR
03a8				endif 
03a8 cd 75 09				call storage_read 
03ab cd 75 0f				call ishlzero 
03ae 28 2d				jr z, .gap 
03b0					 
03b0					; have a file name read. Is it one we want. 
03b0			 
03b0 2a 7a fa				ld hl, (store_tmp1) 
03b3 11 84 fa				ld de, store_page+3   ; file name 
03b6			 
03b6				if DEBUG_STORESE 
03b6					DMARK "SGc" 
03b6 f5				push af  
03b7 3a cb 03			ld a, (.dmark)  
03ba 32 6e fe			ld (debug_mark),a  
03bd 3a cc 03			ld a, (.dmark+1)  
03c0 32 6f fe			ld (debug_mark+1),a  
03c3 3a cd 03			ld a, (.dmark+2)  
03c6 32 70 fe			ld (debug_mark+2),a  
03c9 18 03			jr .pastdmark  
03cb ..			.dmark: db "SGc"  
03ce f1			.pastdmark: pop af  
03cf			endm  
# End of macro DMARK
03cf					CALLMONITOR 
03cf cd f3 18			call break_point_state  
03d2				endm  
# End of macro CALLMONITOR
03d2				endif 
03d2 cd e2 13				call strcmp 
03d5 20 06				jr nz, .gap   ; not this one 
03d7			 
03d7 c1				        pop bc 
03d8			 
03d8 26 00				ld h, 0 
03da 68					ld l, b 
03db 18 22				jr .getdone 
03dd						 
03dd			 
03dd			 
03dd			 
03dd			.gap: 
03dd				if DEBUG_STORESE 
03dd					DMARK "SGg" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6e fe			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6f fe			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 70 fe			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SGg"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6					CALLMONITOR 
03f6 cd f3 18			call break_point_state  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 c1					pop bc 
03fa 10 89				djnz .getloop 
03fc 21 ff 00				ld hl, 255 
03ff			.getdone: 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGe" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 6e fe			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 6f fe			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 70 fe			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGe"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd f3 18			call break_point_state  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b			 
041b c9				ret 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			; Read Block 
041c			; ---------- 
041c			; 
041c			; With current bank 
041c			;  
041c			; Get block number to read 
041c			; Load physical blocks starting at start block into buffer 
041c			 
041c			; de points to buffer to use 
041c			; hl holds logical block number  
041c			 
041c			storage_read_block: 
041c			 
041c				; TODO bank selection 
041c			 
041c				; for each of the physical blocks read it into the buffer 
041c 06 40			ld b, STORE_BLOCK_PHY 
041e			 
041e				if DEBUG_STORESE 
041e d5					push de 
041f				endif 
041f				 
041f			.rl1:    
041f			 
041f				; read physical block at hl into de 
041f			        ; increment hl and de to next read position on exit 
041f			 
041f e5				push hl 
0420 d5				push de	 
0421 c5				push bc 
0422			;	if DEBUG_STORESE 
0422			;		push af 
0422			;		ld a, 'R' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 cd c3 02			call se_readbyte 
0425			;	if DEBUG_STORESE 
0425			;		ld a,(spi_portbyte) 
0425			;		ld l, a 
0425			;		push af 
0425			;		ld a, '1' 
0425			;		ld (debug_mark),a 
0425			;		pop af 
0425			;		CALLMONITOR 
0425			;	endif 
0425 c1				pop bc 
0426 d1				pop de 
0427 e1				pop hl 
0428 12				ld (de),a 
0429 23				inc hl 
042a 13				inc de 
042b			 
042b			;	if DEBUG_STORESE 
042b			;		push af 
042b			;		ld a, 'r' 
042b			;		ld (debug_mark),a 
042b			;		pop af 
042b			;		CALLMONITOR 
042b			;	endif 
042b			 
042b 10 f2			djnz .rl1 
042d			 
042d				if DEBUG_STORESE 
042d					DMARK "SRB" 
042d f5				push af  
042e 3a 42 04			ld a, (.dmark)  
0431 32 6e fe			ld (debug_mark),a  
0434 3a 43 04			ld a, (.dmark+1)  
0437 32 6f fe			ld (debug_mark+1),a  
043a 3a 44 04			ld a, (.dmark+2)  
043d 32 70 fe			ld (debug_mark+2),a  
0440 18 03			jr .pastdmark  
0442 ..			.dmark: db "SRB"  
0445 f1			.pastdmark: pop af  
0446			endm  
# End of macro DMARK
0446 d1					pop de 
0447			; 
0447			;		push af 
0447			;		ld a, 'R' 
0447			;		ld (debug_mark),a 
0447			;		pop af 
0447					CALLMONITOR 
0447 cd f3 18			call break_point_state  
044a				endm  
# End of macro CALLMONITOR
044a				endif 
044a c9				ret	 
044b				 
044b			 
044b			; File Size 
044b			; --------- 
044b			; 
044b			;   hl file id 
044b			; 
044b			;  returns in hl the number of blocks 
044b			 
044b			storage_file_size: 
044b 5d				ld e, l 
044c 16 00			ld d, 0 
044e 21 40 00			ld hl, STORE_BLOCK_PHY 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "SIZ" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 6e fe			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 6f fe			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 70 fe			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "SIZ"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd f3 18			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 4f 07			call storage_findnextid 
0470			 
0470 cd 75 0f			call ishlzero 
0473			;	ld a, l 
0473			;	add h 
0473			;	cp 0 
0473 c8				ret z			; block not found so EOF 
0474			 
0474 11 81 fa			ld de, store_page 
0477 cd 1c 04			call storage_read_block 
047a			 
047a 3a 83 fa			ld a, (store_page+2)	 ; get extent count 
047d 6f				ld l, a 
047e 26 00			ld h, 0 
0480 c9			 	ret 
0481			 
0481			 
0481			; Write Block 
0481			; ----------- 
0481			; 
0481			; With current bank 
0481			;  
0481			; Get block number to write 
0481			; Write physical blocks starting at start block from buffer 
0481			  
0481			storage_write_block: 
0481				; TODO bank selection 
0481			 
0481				; for each of the physical blocks read it into the buffer 
0481 06 40			ld b, STORE_BLOCK_PHY 
0483			 
0483				if DEBUG_STORESE 
0483					DMARK "SWB" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 6e fe			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 6f fe			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 70 fe			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "SWB"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c			 
049c					;push af 
049c					;ld a, 'W' 
049c					;ld (debug_mark),a 
049c					;pop af 
049c					CALLMONITOR 
049c cd f3 18			call break_point_state  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f			 
049f			; might not be working 
049f			;	call se_writepage 
049f			 
049f			;	ret 
049f			; 
049f			 
049f			 
049f			 
049f			.wl1:    
049f			 
049f				; read physical block at hl into de 
049f			        ; increment hl and de to next read position on exit 
049f			 
049f e5				push hl 
04a0 d5				push de	 
04a1 c5				push bc 
04a2 1a				ld a,(de) 
04a3				;if DEBUG_STORESE 
04a3			;		push af 
04a3			;		ld a, 'W' 
04a3			;		ld (debug_mark),a 
04a3			;		pop af 
04a3			;		CALLMONITOR 
04a3			;	endif 
04a3 cd 21 02			call se_writebyte 
04a6			;	call delay250ms 
04a6 00				nop 
04a7 00				nop 
04a8 00				nop 
04a9			;	if DEBUG_STORESE 
04a9			;		push af 
04a9			;		ld a, 'w' 
04a9			;		ld (debug_mark),a 
04a9			;		pop af 
04a9			;		CALLMONITOR 
04a9			;	endif 
04a9 c1				pop bc 
04aa d1				pop de 
04ab e1				pop hl 
04ac 23				inc hl 
04ad 13				inc de 
04ae			 
04ae			 
04ae 10 ef			djnz .wl1 
04b0			 
04b0				if DEBUG_STORESE 
04b0					DMARK "SW2" 
04b0 f5				push af  
04b1 3a c5 04			ld a, (.dmark)  
04b4 32 6e fe			ld (debug_mark),a  
04b7 3a c6 04			ld a, (.dmark+1)  
04ba 32 6f fe			ld (debug_mark+1),a  
04bd 3a c7 04			ld a, (.dmark+2)  
04c0 32 70 fe			ld (debug_mark+2),a  
04c3 18 03			jr .pastdmark  
04c5 ..			.dmark: db "SW2"  
04c8 f1			.pastdmark: pop af  
04c9			endm  
# End of macro DMARK
04c9			 
04c9					;push af 
04c9					;ld a, 'W' 
04c9					;ld (debug_mark),a 
04c9					;pop af 
04c9					CALLMONITOR 
04c9 cd f3 18			call break_point_state  
04cc				endm  
# End of macro CALLMONITOR
04cc				endif 
04cc c9				ret	 
04cd			 
04cd			; Init bank 
04cd			; --------- 
04cd			; 
04cd			; With current bank 
04cd			; 
04cd			; Setup block 0 config 
04cd			;     Set 0 file id counter 
04cd			;     Set formatted byte pattern 
04cd			;     Zero out bank label 
04cd			;      
04cd			; For every logical block write 0-1 byte as null 
04cd			 
04cd			storage_get_block_0: 
04cd			 
04cd				; TODO check presence 
04cd			 
04cd				; get block 0 config 
04cd			 
04cd 21 00 00			ld hl, 0 
04d0 11 81 fa			ld de, store_page 
04d3 cd 1c 04			call storage_read_block 
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "SB0" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 6e fe			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 6f fe			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 70 fe			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "SB0"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef 11 81 fa				ld de, store_page 
04f2			;		push af 
04f2			;		ld a, 'i' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2					CALLMONITOR 
04f2 cd f3 18			call break_point_state  
04f5				endm  
# End of macro CALLMONITOR
04f5				endif 
04f5			 
04f5				; is this area formatted? 
04f5			 
04f5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f5 2a 82 fa			ld hl, (store_page+1) 
04f8 3e 80			ld a,0x80 
04fa bd				cp l 
04fb 20 22			jr nz, .ininotformatted 
04fd				; do a double check 
04fd 3e 27			ld a, 0x27 
04ff bc				cp h 
0500 20 1d			jr nz, .ininotformatted 
0502			 
0502				; formatted then 
0502			 
0502				if DEBUG_STORESE 
0502					DMARK "SB1" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 6e fe			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 6f fe			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 70 fe			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "SB1"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					;push af 
051b					;ld a, 'I' 
051b					;ld (debug_mark),a 
051b					;pop af 
051b					CALLMONITOR 
051b cd f3 18			call break_point_state  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e c9				ret 
051f			 
051f			.ininotformatted: 
051f				; bank not formatted so poke various bits to make sure 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB2" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 6e fe			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 6f fe			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 70 fe			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB2"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538					;push af 
0538					;ld a, 'f' 
0538					;ld (debug_mark),a 
0538					;pop af 
0538					CALLMONITOR 
0538 cd f3 18			call break_point_state  
053b				endm  
# End of macro CALLMONITOR
053b				endif 
053b			 
053b cd 58 0c			call storage_clear_page 
053e			 
053e 21 81 fa			ld hl, store_page 
0541 3e 00			ld a, 0 
0543				 
0543 77				ld (hl),a   ; reset file counter 
0544			 
0544 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0547 22 82 fa		 	ld (store_page+1), hl	 
054a			 
054a				; set default label 
054a			 
054a 21 e6 05			ld hl, .defaultbanklabl 
054d 11 84 fa		 	ld de, store_page+3 
0550 01 0f 00			ld bc, 15 
0553 ed b0			ldir 
0555			 
0555				; Append the current bank id 
0555 21 8d fa			ld hl, store_page+3+9 
0558 3a 66 fa			ld a, (spi_device_id) 
055b 77				ld (hl), a 
055c			 
055c				; save default page 0 
055c			 
055c 21 00 00			ld hl, 0 
055f 11 81 fa			ld de, store_page 
0562				if DEBUG_STORESE 
0562					DMARK "SB3" 
0562 f5				push af  
0563 3a 77 05			ld a, (.dmark)  
0566 32 6e fe			ld (debug_mark),a  
0569 3a 78 05			ld a, (.dmark+1)  
056c 32 6f fe			ld (debug_mark+1),a  
056f 3a 79 05			ld a, (.dmark+2)  
0572 32 70 fe			ld (debug_mark+2),a  
0575 18 03			jr .pastdmark  
0577 ..			.dmark: db "SB3"  
057a f1			.pastdmark: pop af  
057b			endm  
# End of macro DMARK
057b			;		push af 
057b			;		ld a, 'F' 
057b			;		ld (debug_mark),a 
057b			;		pop af 
057b					CALLMONITOR 
057b cd f3 18			call break_point_state  
057e				endm  
# End of macro CALLMONITOR
057e				endif 
057e cd 81 04			call storage_write_block 
0581				if DEBUG_STORESE 
0581					DMARK "SB4" 
0581 f5				push af  
0582 3a 96 05			ld a, (.dmark)  
0585 32 6e fe			ld (debug_mark),a  
0588 3a 97 05			ld a, (.dmark+1)  
058b 32 6f fe			ld (debug_mark+1),a  
058e 3a 98 05			ld a, (.dmark+2)  
0591 32 70 fe			ld (debug_mark+2),a  
0594 18 03			jr .pastdmark  
0596 ..			.dmark: db "SB4"  
0599 f1			.pastdmark: pop af  
059a			endm  
# End of macro DMARK
059a			;		push af 
059a			;		ld a, '>' 
059a			;		ld (debug_mark),a 
059a			;		pop af 
059a					CALLMONITOR 
059a cd f3 18			call break_point_state  
059d				endm  
# End of macro CALLMONITOR
059d				endif 
059d			 
059d 00				nop 
059e 00				nop 
059f 00				nop 
05a0			 
05a0				; now set 0 in every page to mark as a free block 
05a0			 
05a0 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05a2 21 40 00			ld hl, STORE_BLOCK_PHY 
05a5			 
05a5 3e 00		.setmark1:   	ld a,0 
05a7 e5					push hl 
05a8 c5					push bc 
05a9 cd 21 02				call se_writebyte 
05ac 3e 0a			ld a, 10 
05ae cd 7a 0c			call aDelayInMS 
05b1 23				inc hl 
05b2 cd 21 02				call se_writebyte 
05b5 3e 0a			ld a, 10 
05b7 cd 7a 0c			call aDelayInMS 
05ba 2b				dec hl 
05bb c1					pop bc 
05bc e1					pop hl 
05bd 3e 40				ld a, STORE_BLOCK_PHY 
05bf cd 4c 0f				call addatohl 
05c2 10 e1				djnz .setmark1 
05c4			 
05c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c6 3e 00		.setmark2:   	ld a,0 
05c8 e5					push hl 
05c9 c5					push bc 
05ca cd 21 02				call se_writebyte 
05cd 3e 0a			ld a, 10 
05cf cd 7a 0c			call aDelayInMS 
05d2 23				inc hl 
05d3 cd 21 02				call se_writebyte 
05d6 3e 0a			ld a, 10 
05d8 cd 7a 0c			call aDelayInMS 
05db 2b				dec hl 
05dc c1					pop bc 
05dd e1					pop hl 
05de 3e 40				ld a, STORE_BLOCK_PHY 
05e0 cd 4c 0f				call addatohl 
05e3 10 e1				djnz .setmark2 
05e5			 
05e5					 
05e5			 
05e5			 
05e5 c9				ret 
05e6			 
05e6			 
05e6			 
05e6			 
05e6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05f1			 
05f1			 
05f1			 
05f1			; Label Bank 
05f1			; ---------- 
05f1			; 
05f1			; With current bank 
05f1			; Read block 0 
05f1			; Set label 
05f1			; Write block 0 
05f1			 
05f1			; label str pointer in hl 
05f1			 
05f1			storage_label:     
05f1			 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBL" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 6e fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 6f fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 70 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBL"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd f3 18			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d			 
060d e5				push hl 
060e			 
060e cd cd 04			call storage_get_block_0 
0611			 
0611				; set default label 
0611			 
0611 e1				pop hl 
0612			 
0612 11 84 fa		 	ld de, store_page+3 
0615 01 0f 00			ld bc, 15 
0618				if DEBUG_STORESE 
0618					DMARK "LB3" 
0618 f5				push af  
0619 3a 2d 06			ld a, (.dmark)  
061c 32 6e fe			ld (debug_mark),a  
061f 3a 2e 06			ld a, (.dmark+1)  
0622 32 6f fe			ld (debug_mark+1),a  
0625 3a 2f 06			ld a, (.dmark+2)  
0628 32 70 fe			ld (debug_mark+2),a  
062b 18 03			jr .pastdmark  
062d ..			.dmark: db "LB3"  
0630 f1			.pastdmark: pop af  
0631			endm  
# End of macro DMARK
0631					CALLMONITOR 
0631 cd f3 18			call break_point_state  
0634				endm  
# End of macro CALLMONITOR
0634				endif 
0634 ed b0			ldir 
0636				; save default page 0 
0636			 
0636 21 00 00			ld hl, 0 
0639 11 81 fa			ld de, store_page 
063c				if DEBUG_STORESE 
063c					DMARK "LBW" 
063c f5				push af  
063d 3a 51 06			ld a, (.dmark)  
0640 32 6e fe			ld (debug_mark),a  
0643 3a 52 06			ld a, (.dmark+1)  
0646 32 6f fe			ld (debug_mark+1),a  
0649 3a 53 06			ld a, (.dmark+2)  
064c 32 70 fe			ld (debug_mark+2),a  
064f 18 03			jr .pastdmark  
0651 ..			.dmark: db "LBW"  
0654 f1			.pastdmark: pop af  
0655			endm  
# End of macro DMARK
0655					CALLMONITOR 
0655 cd f3 18			call break_point_state  
0658				endm  
# End of macro CALLMONITOR
0658				endif 
0658 cd 81 04			call storage_write_block 
065b			 
065b c9				ret 
065c			 
065c			 
065c			 
065c			; Read Block 0 - Config 
065c			; --------------------- 
065c			; 
065c			; With current bank 
065c			; Call presence test 
065c			;    If not present format/init bank  
065c			; Read block 0  
065c			;  
065c			 
065c			 
065c			; Dir 
065c			; --- 
065c			; 
065c			; With current bank 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block read byte 2 
065c			;      if first block of file 
065c			;         Display file name 
065c			;         Display type flags for file 
065c			;        
065c			 
065c			; moving to words as this requires stack control 
065c			 
065c			 
065c			; Delete File 
065c			; ----------- 
065c			; 
065c			; With current bank 
065c			; 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block file id 
065c			;      If first block of file and dont have file id 
065c			;         if file to delete 
065c			;         Save file id 
065c			;         Null file id 
065c			;         Write this block back 
065c			;      If file id is one saved 
065c			;         Null file id 
065c			;         Write this block back 
065c			 
065c			 
065c			.se_done: 
065c e1				pop hl 
065d c9				ret 
065e			 
065e			storage_erase: 
065e			 
065e				; hl contains the file id 
065e			 
065e 5d				ld e, l 
065f 16 00			ld d, 0 
0661 21 40 00			ld hl, STORE_BLOCK_PHY 
0664					if DEBUG_FORTH_WORDS 
0664						DMARK "ERA" 
0664 f5				push af  
0665 3a 79 06			ld a, (.dmark)  
0668 32 6e fe			ld (debug_mark),a  
066b 3a 7a 06			ld a, (.dmark+1)  
066e 32 6f fe			ld (debug_mark+1),a  
0671 3a 7b 06			ld a, (.dmark+2)  
0674 32 70 fe			ld (debug_mark+2),a  
0677 18 03			jr .pastdmark  
0679 ..			.dmark: db "ERA"  
067c f1			.pastdmark: pop af  
067d			endm  
# End of macro DMARK
067d						CALLMONITOR 
067d cd f3 18			call break_point_state  
0680				endm  
# End of macro CALLMONITOR
0680					endif 
0680 cd 4f 07			call storage_findnextid 
0683 cd 75 0f			call ishlzero 
0686 c8				ret z 
0687			 
0687 e5				push hl 
0688			 
0688				; TODO check file not found 
0688			 
0688 11 81 fa			ld de, store_page 
068b cd 1c 04			call storage_read_block 
068e			 
068e cd 75 0f			call ishlzero 
0691 ca 5c 06			jp z,.se_done 
0694			 
0694					if DEBUG_FORTH_WORDS 
0694						DMARK "ER1" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 6e fe			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 6f fe			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 70 fe			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "ER1"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad						CALLMONITOR 
06ad cd f3 18			call break_point_state  
06b0				endm  
# End of macro CALLMONITOR
06b0					endif 
06b0 3a 81 fa			ld a, (store_page)	; get file id 
06b3 32 75 fa			ld (store_tmpid), a 
06b6			 
06b6 3a 83 fa			ld a, (store_page+2)    ; get count of extends 
06b9 32 74 fa			ld (store_tmpext), a 
06bc			 
06bc				; wipe file header 
06bc			 
06bc e1				pop hl 
06bd 3e 00			ld a, 0 
06bf 32 81 fa			ld (store_page), a 
06c2 32 82 fa			ld (store_page+1),a 
06c5 11 81 fa			ld de, store_page 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER2" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 6e fe			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 6f fe			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 70 fe			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER2"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd f3 18			call break_point_state  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 cd 81 04			call storage_write_block 
06e7			 
06e7			 
06e7				; wipe file extents 
06e7			 
06e7 3a 74 fa			ld a, (store_tmpext) 
06ea 47				ld b, a 
06eb			 
06eb			.eraext:	  
06eb c5				push bc 
06ec			 
06ec 21 40 00			ld hl, STORE_BLOCK_PHY 
06ef 3a 75 fa			ld a,(store_tmpid) 
06f2 5f				ld e, a 
06f3 50				ld d, b	 
06f4					if DEBUG_FORTH_WORDS 
06f4						DMARK "ER3" 
06f4 f5				push af  
06f5 3a 09 07			ld a, (.dmark)  
06f8 32 6e fe			ld (debug_mark),a  
06fb 3a 0a 07			ld a, (.dmark+1)  
06fe 32 6f fe			ld (debug_mark+1),a  
0701 3a 0b 07			ld a, (.dmark+2)  
0704 32 70 fe			ld (debug_mark+2),a  
0707 18 03			jr .pastdmark  
0709 ..			.dmark: db "ER3"  
070c f1			.pastdmark: pop af  
070d			endm  
# End of macro DMARK
070d						CALLMONITOR 
070d cd f3 18			call break_point_state  
0710				endm  
# End of macro CALLMONITOR
0710					endif 
0710 cd 4f 07			call storage_findnextid 
0713 cd 75 0f			call ishlzero 
0716 ca 5c 06			jp z,.se_done 
0719			 
0719 e5				push hl 
071a 11 81 fa			ld de, store_page 
071d cd 1c 04			call storage_read_block 
0720			 
0720				; free block	 
0720			 
0720 3e 00			ld a, 0 
0722 32 81 fa			ld (store_page), a 
0725 32 82 fa			ld (store_page+1),a 
0728 11 81 fa			ld de, store_page 
072b e1				pop hl 
072c					if DEBUG_FORTH_WORDS 
072c						DMARK "ER4" 
072c f5				push af  
072d 3a 41 07			ld a, (.dmark)  
0730 32 6e fe			ld (debug_mark),a  
0733 3a 42 07			ld a, (.dmark+1)  
0736 32 6f fe			ld (debug_mark+1),a  
0739 3a 43 07			ld a, (.dmark+2)  
073c 32 70 fe			ld (debug_mark+2),a  
073f 18 03			jr .pastdmark  
0741 ..			.dmark: db "ER4"  
0744 f1			.pastdmark: pop af  
0745			endm  
# End of macro DMARK
0745						CALLMONITOR 
0745 cd f3 18			call break_point_state  
0748				endm  
# End of macro CALLMONITOR
0748					endif 
0748 cd 81 04			call storage_write_block 
074b			 
074b c1				pop bc 
074c 10 9d			djnz .eraext 
074e			 
074e c9				ret 
074f			 
074f			 
074f			; Find Free Block 
074f			; --------------- 
074f			; 
074f			; With current bank 
074f			;  
074f			; From given starting logical block 
074f			;    Read block  
074f			;    If no file id 
074f			;         Return block id 
074f			 
074f			 
074f			; hl starting page number 
074f			; hl contains free page number or zero if no pages free 
074f			; e contains the file id to locate 
074f			; d contains the block number 
074f			 
074f			; TODO change to find file id and use zero for free block 
074f			 
074f			storage_findnextid: 
074f			 
074f				; now locate first 0 page to mark as a free block 
074f			 
074f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0751			;	ld hl, STORE_BLOCK_PHY 
0751			 
0751					if DEBUG_FORTH_WORDS 
0751					DMARK "FNI" 
0751 f5				push af  
0752 3a 66 07			ld a, (.dmark)  
0755 32 6e fe			ld (debug_mark),a  
0758 3a 67 07			ld a, (.dmark+1)  
075b 32 6f fe			ld (debug_mark+1),a  
075e 3a 68 07			ld a, (.dmark+2)  
0761 32 70 fe			ld (debug_mark+2),a  
0764 18 03			jr .pastdmark  
0766 ..			.dmark: db "FNI"  
0769 f1			.pastdmark: pop af  
076a			endm  
# End of macro DMARK
076a						CALLMONITOR 
076a cd f3 18			call break_point_state  
076d				endm  
# End of macro CALLMONITOR
076d					endif 
076d			.ff1:   	 
076d e5					push hl 
076e c5					push bc 
076f d5					push de 
0770 cd c3 02				call se_readbyte 
0773 5f					ld e,a 
0774 23					inc hl 
0775 cd c3 02				call se_readbyte 
0778 57					ld d, a 
0779 e1					pop hl 
077a e5					push hl 
077b cd 6a 0f				call cmp16 
077e 28 49				jr z, .fffound 
0780			 
0780 d1					pop de 
0781 c1					pop bc 
0782 e1					pop hl 
0783			 
0783					; is found? 
0783					;cp e 
0783					;ret z 
0783			 
0783 3e 40				ld a, STORE_BLOCK_PHY 
0785 cd 4c 0f				call addatohl 
0788 10 e3				djnz .ff1 
078a			 
078a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
078c			.ff2:   	 
078c			 
078c e5					push hl 
078d c5					push bc 
078e d5					push de 
078f cd c3 02				call se_readbyte 
0792 5f					ld e,a 
0793 23					inc hl 
0794 cd c3 02				call se_readbyte 
0797 57					ld d, a 
0798			 
0798 e1					pop hl 
0799 e5					push hl 
079a cd 6a 0f				call cmp16 
079d 28 2a				jr z, .fffound 
079f			 
079f d1					pop de 
07a0 c1					pop bc 
07a1 e1					pop hl 
07a2					; is found? 
07a2					;cp e 
07a2					;ret z 
07a2			 
07a2 3e 40				ld a, STORE_BLOCK_PHY 
07a4 cd 4c 0f				call addatohl 
07a7 10 e3				djnz .ff2 
07a9			 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FN-" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 6e fe			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 6f fe			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 70 fe			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FN-"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2					;	push af 
07c2					;	ld a, 'n' 
07c2					;	ld (debug_mark),a 
07c2					;	pop af 
07c2						CALLMONITOR 
07c2 cd f3 18			call break_point_state  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5				; no free marks! 
07c5 21 00 00				ld hl, 0 
07c8 c9				ret 
07c9			.fffound: 
07c9				 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc					if DEBUG_FORTH_WORDS 
07cc					DMARK "FNF" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 6e fe			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 6f fe			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 70 fe			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "FNF"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;	push af 
07e5					;	ld a, 'n' 
07e5					;	ld (debug_mark),a 
07e5					;	pop af 
07e5						CALLMONITOR 
07e5 cd f3 18			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8					endif 
07e8 c9				ret 
07e9			 
07e9			 
07e9			 
07e9			; Free Space 
07e9			; ---------- 
07e9			; 
07e9			; With current bank 
07e9			; 
07e9			; Set block count to zero 
07e9			; Starting with first logical block 
07e9			;      Find free block  
07e9			;      If block id given, increment block count 
07e9			; 
07e9			;  
07e9			 
07e9			 
07e9			; hl contains count of free blocks 
07e9			 
07e9			storage_freeblocks: 
07e9			 
07e9				; now locate first 0 page to mark as a free block 
07e9			 
07e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07eb 21 40 00			ld hl, STORE_BLOCK_PHY 
07ee 11 00 00			ld de, 0 
07f1			 
07f1			.fb1:   	 
07f1 e5					push hl 
07f2 c5					push bc 
07f3 d5					push de 
07f4 cd c3 02				call se_readbyte 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa			 
07fa					; is free? 
07fa fe 00				cp 0 
07fc 20 01				jr nz, .ff1cont 
07fe 13					inc de 
07ff			 
07ff			.ff1cont: 
07ff			 
07ff			 
07ff 3e 40				ld a, STORE_BLOCK_PHY 
0801 cd 4c 0f				call addatohl 
0804 10 eb				djnz .fb1 
0806			 
0806 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0808			.fb2:   	 
0808 e5					push hl 
0809 c5					push bc 
080a d5					push de 
080b cd c3 02				call se_readbyte 
080e d1					pop de 
080f c1					pop bc 
0810 e1					pop hl 
0811			 
0811					; is free? 
0811 fe 00				cp 0 
0813 20 01				jr nz, .ff2cont 
0815 13					inc de 
0816			 
0816			.ff2cont: 
0816			 
0816 3e 40				ld a, STORE_BLOCK_PHY 
0818 cd 4c 0f				call addatohl 
081b 10 eb				djnz .fb2 
081d			 
081d eb				ex de, hl 
081e c9				ret 
081f			 
081f			; Get File ID 
081f			; ----------- 
081f			; 
081f			; With current bank 
081f			;  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; For each logical block 
081f			;    Read block file id 
081f			;      If first block of file and dont have file id 
081f			;         if file get id and exit 
081f			 
081f			 
081f			 
081f			 
081f			; Create File 
081f			; ----------- 
081f			; 
081f			; With current bank  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; Increment file id number 
081f			; Save Config 
081f			; Find free block 
081f			; Set buffer with file name and file id 
081f			; Write buffer to free block  
081f			 
081f			 
081f			; hl point to file name 
081f			; hl returns file id 
081f			 
081f			; file format: 
081f			; byte 0 - file id 
081f			; byte 1 - extent number 
081f			; byte 2-> data 
081f			 
081f			; format for extent number 0: 
081f			; 
081f			; byte 0 - file id 
081f			; byte 1 - extent 0 
081f			; byte 2 - extent count 
081f			; byte 3 -> file name and meta data 
081f			 
081f			 
081f			storage_create: 
081f				if DEBUG_STORESE 
081f					DMARK "SCR" 
081f f5				push af  
0820 3a 34 08			ld a, (.dmark)  
0823 32 6e fe			ld (debug_mark),a  
0826 3a 35 08			ld a, (.dmark+1)  
0829 32 6f fe			ld (debug_mark+1),a  
082c 3a 36 08			ld a, (.dmark+2)  
082f 32 70 fe			ld (debug_mark+2),a  
0832 18 03			jr .pastdmark  
0834 ..			.dmark: db "SCR"  
0837 f1			.pastdmark: pop af  
0838			endm  
# End of macro DMARK
0838					CALLMONITOR 
0838 cd f3 18			call break_point_state  
083b				endm  
# End of macro CALLMONITOR
083b				endif 
083b			 
083b e5				push hl		; save file name pointer 
083c			 
083c cd cd 04			call storage_get_block_0 
083f			 
083f 3a 81 fa			ld a,(store_page)	; get current file id 
0842 3c				inc a 
0843 32 81 fa			ld (store_page),a 
0846				 
0846 32 75 fa			ld (store_tmpid),a			; save id 
0849			 
0849 21 00 00			ld hl, 0 
084c 11 81 fa			ld de, store_page 
084f				if DEBUG_STORESE 
084f					DMARK "SCw" 
084f f5				push af  
0850 3a 64 08			ld a, (.dmark)  
0853 32 6e fe			ld (debug_mark),a  
0856 3a 65 08			ld a, (.dmark+1)  
0859 32 6f fe			ld (debug_mark+1),a  
085c 3a 66 08			ld a, (.dmark+2)  
085f 32 70 fe			ld (debug_mark+2),a  
0862 18 03			jr .pastdmark  
0864 ..			.dmark: db "SCw"  
0867 f1			.pastdmark: pop af  
0868			endm  
# End of macro DMARK
0868					CALLMONITOR 
0868 cd f3 18			call break_point_state  
086b				endm  
# End of macro CALLMONITOR
086b				endif 
086b cd 81 04			call storage_write_block	 ; save update 
086e			 
086e				if DEBUG_STORESE 
086e 11 81 fa				ld de, store_page 
0871					DMARK "SCC" 
0871 f5				push af  
0872 3a 86 08			ld a, (.dmark)  
0875 32 6e fe			ld (debug_mark),a  
0878 3a 87 08			ld a, (.dmark+1)  
087b 32 6f fe			ld (debug_mark+1),a  
087e 3a 88 08			ld a, (.dmark+2)  
0881 32 70 fe			ld (debug_mark+2),a  
0884 18 03			jr .pastdmark  
0886 ..			.dmark: db "SCC"  
0889 f1			.pastdmark: pop af  
088a			endm  
# End of macro DMARK
088a					CALLMONITOR 
088a cd f3 18			call break_point_state  
088d				endm  
# End of macro CALLMONITOR
088d				endif 
088d				;  
088d				 
088d 21 40 00			ld hl, STORE_BLOCK_PHY 
0890 11 00 00			ld de, 0 
0893 cd 4f 07			call storage_findnextid 
0896			 
0896 22 6c fa			ld (store_tmppageid), hl    ; save page to use  
0899			 
0899				; TODO detect 0 = no spare blocks 
0899			 
0899				; hl now contains the free page to use for the file header page 
0899			 
0899				if DEBUG_STORESE 
0899				DMARK "SCF" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 6e fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 6f fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 70 fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCF"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd f3 18			call break_point_state  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5			 
08b5 22 6c fa			ld (store_tmppageid), hl 
08b8				 
08b8 3a 75 fa			ld a,(store_tmpid)    ; get file id 
08bb			;	ld a, (store_filecache)			; save to cache 
08bb			 
08bb 32 81 fa			ld (store_page),a    ; set page id 
08be 3e 00			ld a, 0			 ; extent 0 is file header 
08c0 32 82 fa			ld (store_page+1), a   ; set file extent 
08c3			 
08c3 32 83 fa			ld (store_page+2), a   ; extent count for the file 
08c6			 
08c6			;	inc hl 		; init block 0 of file 
08c6			;	inc hl   		; skip file and extent id 
08c6			 ;       ld a, 0 
08c6			;	ld (hl),a 
08c6			;	ld a, (store_filecache+1)  	; save to cache 
08c6			 
08c6			;	inc hl    ; file name 
08c6				 
08c6				 
08c6 11 84 fa			ld de, store_page+3    ; get buffer for term string to use as file name 
08c9				if DEBUG_STORESE 
08c9					DMARK "SCc" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 6e fe			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 6f fe			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 70 fe			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCc"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd f3 18			call break_point_state  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5 e1				pop hl    ; get zero term string 
08e6 e5				push hl 
08e7 3e 00			ld a, 0 
08e9 cd b5 13			call strlent 
08ec 23				inc hl   ; cover zero term 
08ed 06 00			ld b,0 
08ef 4d				ld c,l 
08f0 e1				pop hl 
08f1				;ex de, hl 
08f1				if DEBUG_STORESE 
08f1					DMARK "SCa" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 6e fe			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 6f fe			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 70 fe			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCa"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					;push af 
090a					;ld a, 'a' 
090a					;ld (debug_mark),a 
090a					;pop af 
090a					CALLMONITOR 
090a cd f3 18			call break_point_state  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d ed b0			ldir    ; copy zero term string 
090f				if DEBUG_STORESE 
090f					DMARK "SCA" 
090f f5				push af  
0910 3a 24 09			ld a, (.dmark)  
0913 32 6e fe			ld (debug_mark),a  
0916 3a 25 09			ld a, (.dmark+1)  
0919 32 6f fe			ld (debug_mark+1),a  
091c 3a 26 09			ld a, (.dmark+2)  
091f 32 70 fe			ld (debug_mark+2),a  
0922 18 03			jr .pastdmark  
0924 ..			.dmark: db "SCA"  
0927 f1			.pastdmark: pop af  
0928			endm  
# End of macro DMARK
0928					CALLMONITOR 
0928 cd f3 18			call break_point_state  
092b				endm  
# End of macro CALLMONITOR
092b				endif 
092b			 
092b				; write file header page 
092b			 
092b 2a 6c fa			ld hl,(store_tmppageid) 
092e 11 81 fa			ld de, store_page 
0931				if DEBUG_STORESE 
0931					DMARK "SCb" 
0931 f5				push af  
0932 3a 46 09			ld a, (.dmark)  
0935 32 6e fe			ld (debug_mark),a  
0938 3a 47 09			ld a, (.dmark+1)  
093b 32 6f fe			ld (debug_mark+1),a  
093e 3a 48 09			ld a, (.dmark+2)  
0941 32 70 fe			ld (debug_mark+2),a  
0944 18 03			jr .pastdmark  
0946 ..			.dmark: db "SCb"  
0949 f1			.pastdmark: pop af  
094a			endm  
# End of macro DMARK
094a					;push af 
094a					;ld a, 'b' 
094a					;ld (debug_mark),a 
094a					;pop af 
094a					CALLMONITOR 
094a cd f3 18			call break_point_state  
094d				endm  
# End of macro CALLMONITOR
094d				endif 
094d cd 81 04			call storage_write_block 
0950			 
0950 3a 75 fa			ld a, (store_tmpid) 
0953 6f				ld l, a 
0954 26 00			ld h,0 
0956				if DEBUG_STORESE 
0956					DMARK "SCz" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 6e fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 6f fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 70 fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "SCz"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd f3 18			call break_point_state  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 c9				ret 
0973				 
0973			 
0973			 
0973			; 
0973			; Read File 
0973			; 
0973			; h - file id to locate 
0973			; l - extent to locate 
0973			; de - pointer to string to read into 
0973			; 
0973			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0973			 
0973			.sr_fail: 
0973 d1				pop de 
0974 c9				ret 
0975			 
0975			storage_read: 
0975			 
0975			 
0975 d5				push de 
0976			 
0976			; TODO BUG the above push is it popped before the RET Z? 
0976			 
0976			; TODO how to handle multiple part blocks 
0976			 
0976				; locate file extent to read 
0976			 
0976 5c				ld e, h 
0977 55				ld d, l 
0978			 
0978			.srext: 
0978 22 7f fa			ld (store_readptr), hl     ; save the current extent to load 
097b ed 53 7d fa		ld (store_readbuf), de     ; save the current buffer to load in to 
097f			 
097f 21 40 00			ld hl, STORE_BLOCK_PHY 
0982				if DEBUG_STORESE 
0982					DMARK "sre" 
0982 f5				push af  
0983 3a 97 09			ld a, (.dmark)  
0986 32 6e fe			ld (debug_mark),a  
0989 3a 98 09			ld a, (.dmark+1)  
098c 32 6f fe			ld (debug_mark+1),a  
098f 3a 99 09			ld a, (.dmark+2)  
0992 32 70 fe			ld (debug_mark+2),a  
0995 18 03			jr .pastdmark  
0997 ..			.dmark: db "sre"  
099a f1			.pastdmark: pop af  
099b			endm  
# End of macro DMARK
099b					CALLMONITOR 
099b cd f3 18			call break_point_state  
099e				endm  
# End of macro CALLMONITOR
099e				endif 
099e cd 4f 07			call storage_findnextid 
09a1			 
09a1				if DEBUG_STORESE 
09a1					DMARK "srf" 
09a1 f5				push af  
09a2 3a b6 09			ld a, (.dmark)  
09a5 32 6e fe			ld (debug_mark),a  
09a8 3a b7 09			ld a, (.dmark+1)  
09ab 32 6f fe			ld (debug_mark+1),a  
09ae 3a b8 09			ld a, (.dmark+2)  
09b1 32 70 fe			ld (debug_mark+2),a  
09b4 18 03			jr .pastdmark  
09b6 ..			.dmark: db "srf"  
09b9 f1			.pastdmark: pop af  
09ba			endm  
# End of macro DMARK
09ba					CALLMONITOR 
09ba cd f3 18			call break_point_state  
09bd				endm  
# End of macro CALLMONITOR
09bd				endif 
09bd cd 75 0f			call ishlzero 
09c0			;	ld a, l 
09c0			;	add h 
09c0			;	cp 0 
09c0 28 b1			jr z,.sr_fail			; block not found so EOF 
09c2			 
09c2				; save current address for use by higher level words etc 
09c2			 
09c2 22 72 fa			ld (store_openaddr),hl 
09c5			 
09c5			 
09c5				; hl contains page number to load 
09c5 d1				pop de   ; get storage 
09c6 ed 53 7d fa		ld (store_readbuf), de     ; current buffer to load in to 
09ca d5				push de 
09cb				if DEBUG_STORESE 
09cb					DMARK "srg" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 6e fe			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 6f fe			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 70 fe			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "srg"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd f3 18			call break_point_state  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 1c 04			call storage_read_block 
09ea			 
09ea				; if this a continuation read??? 
09ea			 
09ea 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09ed			 
09ed 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ef cd 4c 0f			call addatohl 
09f2 7e				ld a,(hl) 
09f3 fe 00			cp 0 
09f5 28 02			jr z, .markiscont 
09f7 3e ff			ld a, 255 
09f9			 
09f9			.markiscont: 
09f9 32 74 fa			ld (store_readcont), a 
09fc			 
09fc				if DEBUG_STORESE 
09fc					DMARK "srC" 
09fc f5				push af  
09fd 3a 11 0a			ld a, (.dmark)  
0a00 32 6e fe			ld (debug_mark),a  
0a03 3a 12 0a			ld a, (.dmark+1)  
0a06 32 6f fe			ld (debug_mark+1),a  
0a09 3a 13 0a			ld a, (.dmark+2)  
0a0c 32 70 fe			ld (debug_mark+2),a  
0a0f 18 03			jr .pastdmark  
0a11 ..			.dmark: db "srC"  
0a14 f1			.pastdmark: pop af  
0a15			endm  
# End of macro DMARK
0a15					CALLMONITOR 
0a15 cd f3 18			call break_point_state  
0a18				endm  
# End of macro CALLMONITOR
0a18				endif 
0a18				; only short reads enabled 
0a18			 
0a18 3a 7c fa			ld a, (store_longread) 
0a1b fe 00			cp 0 
0a1d ca ea 0a			jp z, .readdone 
0a20			 
0a20			; TODO if block has no zeros then need to read next block  
0a20			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a20			; check last byte of physical block. 
0a20			; if not zero then the next block needs to be loaded 
0a20			 
0a20			 
0a20 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a23			 
0a23 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a25 cd 4c 0f			call addatohl 
0a28				;dec hl 
0a28 7e				ld a,(hl) 
0a29				if DEBUG_STORESE 
0a29					DMARK "sr?" 
0a29 f5				push af  
0a2a 3a 3e 0a			ld a, (.dmark)  
0a2d 32 6e fe			ld (debug_mark),a  
0a30 3a 3f 0a			ld a, (.dmark+1)  
0a33 32 6f fe			ld (debug_mark+1),a  
0a36 3a 40 0a			ld a, (.dmark+2)  
0a39 32 70 fe			ld (debug_mark+2),a  
0a3c 18 03			jr .pastdmark  
0a3e ..			.dmark: db "sr?"  
0a41 f1			.pastdmark: pop af  
0a42			endm  
# End of macro DMARK
0a42					CALLMONITOR 
0a42 cd f3 18			call break_point_state  
0a45				endm  
# End of macro CALLMONITOR
0a45				endif 
0a45 fe 00			cp 0 
0a47 ca ea 0a			jp z, .readdone 
0a4a			 
0a4a				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a4a			 
0a4a 23				inc hl 
0a4b			 
0a4b 22 7d fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4e			 
0a4e ed 5b 7f fa		ld de, (store_readptr)     ; save the current extent to load 
0a52			 
0a52 eb				ex de, hl 
0a53			 
0a53				; next ext 
0a53			 
0a53 23				inc hl 
0a54 22 7f fa			ld  (store_readptr), hl     ; save the current extent to load 
0a57			 
0a57				if DEBUG_STORESE 
0a57					DMARK "sF2" 
0a57 f5				push af  
0a58 3a 6c 0a			ld a, (.dmark)  
0a5b 32 6e fe			ld (debug_mark),a  
0a5e 3a 6d 0a			ld a, (.dmark+1)  
0a61 32 6f fe			ld (debug_mark+1),a  
0a64 3a 6e 0a			ld a, (.dmark+2)  
0a67 32 70 fe			ld (debug_mark+2),a  
0a6a 18 03			jr .pastdmark  
0a6c ..			.dmark: db "sF2"  
0a6f f1			.pastdmark: pop af  
0a70			endm  
# End of macro DMARK
0a70					CALLMONITOR 
0a70 cd f3 18			call break_point_state  
0a73				endm  
# End of macro CALLMONITOR
0a73				endif 
0a73			 
0a73				; get and load block 
0a73			 
0a73 cd 4f 07			call storage_findnextid 
0a76			 
0a76				if DEBUG_STORESE 
0a76					DMARK "sf2" 
0a76 f5				push af  
0a77 3a 8b 0a			ld a, (.dmark)  
0a7a 32 6e fe			ld (debug_mark),a  
0a7d 3a 8c 0a			ld a, (.dmark+1)  
0a80 32 6f fe			ld (debug_mark+1),a  
0a83 3a 8d 0a			ld a, (.dmark+2)  
0a86 32 70 fe			ld (debug_mark+2),a  
0a89 18 03			jr .pastdmark  
0a8b ..			.dmark: db "sf2"  
0a8e f1			.pastdmark: pop af  
0a8f			endm  
# End of macro DMARK
0a8f					CALLMONITOR 
0a8f cd f3 18			call break_point_state  
0a92				endm  
# End of macro CALLMONITOR
0a92				endif 
0a92 cd 75 0f			call ishlzero 
0a95			;	ld a, l 
0a95			;	add h 
0a95			;	cp 0 
0a95 ca 73 09			jp z,.sr_fail			; block not found so EOF 
0a98				 
0a98				; save current address for use by higher level words etc 
0a98			 
0a98 22 72 fa			ld (store_openaddr),hl 
0a9b			 
0a9b cd 1c 04			call storage_read_block 
0a9e			 
0a9e				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9e				; we need to pull everything back  
0a9e			 
0a9e ed 5b 7d fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aa2 2a 7d fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa5 23				inc hl 
0aa6 23				inc hl     ; skip id and ext 
0aa7 01 40 00			ld bc, STORE_BLOCK_PHY 
0aaa				if DEBUG_STORESE 
0aaa					DMARK "SR<" 
0aaa f5				push af  
0aab 3a bf 0a			ld a, (.dmark)  
0aae 32 6e fe			ld (debug_mark),a  
0ab1 3a c0 0a			ld a, (.dmark+1)  
0ab4 32 6f fe			ld (debug_mark+1),a  
0ab7 3a c1 0a			ld a, (.dmark+2)  
0aba 32 70 fe			ld (debug_mark+2),a  
0abd 18 03			jr .pastdmark  
0abf ..			.dmark: db "SR<"  
0ac2 f1			.pastdmark: pop af  
0ac3			endm  
# End of macro DMARK
0ac3					CALLMONITOR 
0ac3 cd f3 18			call break_point_state  
0ac6				endm  
# End of macro CALLMONITOR
0ac6				endif 
0ac6 ed b0			ldir     ; copy data 
0ac8			 
0ac8				; move the pointer back and pretend we have a full buffer for next recheck 
0ac8			 
0ac8 1b				dec de 
0ac9 1b				dec de 
0aca			 
0aca			; TODO do pop below now short circuit loop????? 
0aca c1				pop bc     ; get rid of spare de on stack 
0acb				if DEBUG_STORESE 
0acb					DMARK "SR>" 
0acb f5				push af  
0acc 3a e0 0a			ld a, (.dmark)  
0acf 32 6e fe			ld (debug_mark),a  
0ad2 3a e1 0a			ld a, (.dmark+1)  
0ad5 32 6f fe			ld (debug_mark+1),a  
0ad8 3a e2 0a			ld a, (.dmark+2)  
0adb 32 70 fe			ld (debug_mark+2),a  
0ade 18 03			jr .pastdmark  
0ae0 ..			.dmark: db "SR>"  
0ae3 f1			.pastdmark: pop af  
0ae4			endm  
# End of macro DMARK
0ae4					CALLMONITOR 
0ae4 cd f3 18			call break_point_state  
0ae7				endm  
# End of macro CALLMONITOR
0ae7				endif 
0ae7 c3 78 09			jp .srext 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			.readdone:		 
0aea e1				pop hl 		 ; return start of data to show as not EOF 
0aeb 23				inc hl   ; past file id 
0aec 23				inc hl   ; past ext 
0aed				if DEBUG_STORESE 
0aed					DMARK "SRe" 
0aed f5				push af  
0aee 3a 02 0b			ld a, (.dmark)  
0af1 32 6e fe			ld (debug_mark),a  
0af4 3a 03 0b			ld a, (.dmark+1)  
0af7 32 6f fe			ld (debug_mark+1),a  
0afa 3a 04 0b			ld a, (.dmark+2)  
0afd 32 70 fe			ld (debug_mark+2),a  
0b00 18 03			jr .pastdmark  
0b02 ..			.dmark: db "SRe"  
0b05 f1			.pastdmark: pop af  
0b06			endm  
# End of macro DMARK
0b06					CALLMONITOR 
0b06 cd f3 18			call break_point_state  
0b09				endm  
# End of macro CALLMONITOR
0b09				endif 
0b09 c9					ret 
0b0a			 
0b0a			 
0b0a			 
0b0a			; 
0b0a			; Append File 
0b0a			; 
0b0a			; hl - file id to locate 
0b0a			; de - pointer to (multi block) string to write 
0b0a			 
0b0a			.sa_notfound: 
0b0a d1				pop de 
0b0b c9				ret 
0b0c			 
0b0c			 
0b0c			storage_append: 
0b0c				; hl -  file id to append to 
0b0c				; de - string to append 
0b0c			 
0b0c d5				push de 
0b0d				 
0b0d				if DEBUG_STORESE 
0b0d					DMARK "AP1" 
0b0d f5				push af  
0b0e 3a 22 0b			ld a, (.dmark)  
0b11 32 6e fe			ld (debug_mark),a  
0b14 3a 23 0b			ld a, (.dmark+1)  
0b17 32 6f fe			ld (debug_mark+1),a  
0b1a 3a 24 0b			ld a, (.dmark+2)  
0b1d 32 70 fe			ld (debug_mark+2),a  
0b20 18 03			jr .pastdmark  
0b22 ..			.dmark: db "AP1"  
0b25 f1			.pastdmark: pop af  
0b26			endm  
# End of macro DMARK
0b26					CALLMONITOR 
0b26 cd f3 18			call break_point_state  
0b29				endm  
# End of macro CALLMONITOR
0b29				endif 
0b29			 
0b29 7d				ld a, l 
0b2a 32 75 fa			ld (store_tmpid), a 
0b2d			 
0b2d				; get file header  
0b2d			 
0b2d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2f 3a 75 fa			ld a, (store_tmpid) 
0b32 5f				ld e, a 
0b33			 
0b33 21 40 00				ld hl, STORE_BLOCK_PHY 
0b36 cd 4f 07				call storage_findnextid 
0b39			 
0b39 cd 75 0f			call ishlzero 
0b3c 28 cc			jr z, .sa_notfound 
0b3e			 
0b3e 22 6c fa			ld (store_tmppageid), hl 
0b41			 
0b41				; TODO handle file id not found 
0b41			 
0b41				if DEBUG_STORESE 
0b41					DMARK "AP2" 
0b41 f5				push af  
0b42 3a 56 0b			ld a, (.dmark)  
0b45 32 6e fe			ld (debug_mark),a  
0b48 3a 57 0b			ld a, (.dmark+1)  
0b4b 32 6f fe			ld (debug_mark+1),a  
0b4e 3a 58 0b			ld a, (.dmark+2)  
0b51 32 70 fe			ld (debug_mark+2),a  
0b54 18 03			jr .pastdmark  
0b56 ..			.dmark: db "AP2"  
0b59 f1			.pastdmark: pop af  
0b5a			endm  
# End of macro DMARK
0b5a					CALLMONITOR 
0b5a cd f3 18			call break_point_state  
0b5d				endm  
# End of macro CALLMONITOR
0b5d				endif 
0b5d			 
0b5d				; update file extent count 
0b5d			 
0b5d 11 81 fa			ld de, store_page 
0b60			 
0b60 cd 1c 04			call storage_read_block 
0b63			 
0b63				if DEBUG_STORESE 
0b63					DMARK "AP3" 
0b63 f5				push af  
0b64 3a 78 0b			ld a, (.dmark)  
0b67 32 6e fe			ld (debug_mark),a  
0b6a 3a 79 0b			ld a, (.dmark+1)  
0b6d 32 6f fe			ld (debug_mark+1),a  
0b70 3a 7a 0b			ld a, (.dmark+2)  
0b73 32 70 fe			ld (debug_mark+2),a  
0b76 18 03			jr .pastdmark  
0b78 ..			.dmark: db "AP3"  
0b7b f1			.pastdmark: pop af  
0b7c			endm  
# End of macro DMARK
0b7c					CALLMONITOR 
0b7c cd f3 18			call break_point_state  
0b7f				endm  
# End of macro CALLMONITOR
0b7f				endif 
0b7f			;	ld (store_tmppageid), hl 
0b7f			 
0b7f 3a 83 fa			ld a, (store_page+2) 
0b82 3c				inc a 
0b83 32 83 fa			ld (store_page+2), a 
0b86 32 74 fa			ld (store_tmpext), a 
0b89				 
0b89				if DEBUG_STORESE 
0b89					DMARK "AP3" 
0b89 f5				push af  
0b8a 3a 9e 0b			ld a, (.dmark)  
0b8d 32 6e fe			ld (debug_mark),a  
0b90 3a 9f 0b			ld a, (.dmark+1)  
0b93 32 6f fe			ld (debug_mark+1),a  
0b96 3a a0 0b			ld a, (.dmark+2)  
0b99 32 70 fe			ld (debug_mark+2),a  
0b9c 18 03			jr .pastdmark  
0b9e ..			.dmark: db "AP3"  
0ba1 f1			.pastdmark: pop af  
0ba2			endm  
# End of macro DMARK
0ba2					CALLMONITOR 
0ba2 cd f3 18			call break_point_state  
0ba5				endm  
# End of macro CALLMONITOR
0ba5				endif 
0ba5 2a 6c fa			ld hl, (store_tmppageid) 
0ba8 11 81 fa			ld de, store_page 
0bab cd 81 04			call storage_write_block 
0bae			 
0bae				; find free block 
0bae			 
0bae 11 00 00			ld de, 0			 ; file extent to locate 
0bb1			 
0bb1 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb4 cd 4f 07				call storage_findnextid 
0bb7 cd 75 0f			call ishlzero 
0bba ca 0a 0b			jp z, .sa_notfound 
0bbd			 
0bbd					; TODO handle no space left 
0bbd					 
0bbd 22 6c fa				ld (store_tmppageid), hl 
0bc0			 
0bc0				if DEBUG_STORESE 
0bc0					DMARK "AP4" 
0bc0 f5				push af  
0bc1 3a d5 0b			ld a, (.dmark)  
0bc4 32 6e fe			ld (debug_mark),a  
0bc7 3a d6 0b			ld a, (.dmark+1)  
0bca 32 6f fe			ld (debug_mark+1),a  
0bcd 3a d7 0b			ld a, (.dmark+2)  
0bd0 32 70 fe			ld (debug_mark+2),a  
0bd3 18 03			jr .pastdmark  
0bd5 ..			.dmark: db "AP4"  
0bd8 f1			.pastdmark: pop af  
0bd9			endm  
# End of macro DMARK
0bd9					CALLMONITOR 
0bd9 cd f3 18			call break_point_state  
0bdc				endm  
# End of macro CALLMONITOR
0bdc				endif 
0bdc					; init the buffer with zeros so we can id if the buffer is full or not 
0bdc			 
0bdc e5					push hl 
0bdd c5					push bc 
0bde			 
0bde 21 81 fa				ld hl, store_page 
0be1 06 40				ld b, STORE_BLOCK_PHY 
0be3 3e 00				ld a, 0 
0be5 77			.zeroblock:	ld (hl), a 
0be6 23					inc hl 
0be7 10 fc				djnz .zeroblock 
0be9			 
0be9 c1					pop bc 
0bea e1					pop hl 
0beb			 
0beb					; construct block 
0beb			 
0beb 3a 75 fa				ld a, (store_tmpid) 
0bee 32 81 fa				ld (store_page), a   ; file id 
0bf1 3a 74 fa				ld a, (store_tmpext)   ; extent for this block 
0bf4 32 82 fa				ld (store_page+1), a 
0bf7			 
0bf7 e1					pop hl    ; get string to write 
0bf8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bfa 11 83 fa				ld de, store_page+2 
0bfd			 
0bfd				if DEBUG_STORESE 
0bfd					DMARK "AP5" 
0bfd f5				push af  
0bfe 3a 12 0c			ld a, (.dmark)  
0c01 32 6e fe			ld (debug_mark),a  
0c04 3a 13 0c			ld a, (.dmark+1)  
0c07 32 6f fe			ld (debug_mark+1),a  
0c0a 3a 14 0c			ld a, (.dmark+2)  
0c0d 32 70 fe			ld (debug_mark+2),a  
0c10 18 03			jr .pastdmark  
0c12 ..			.dmark: db "AP5"  
0c15 f1			.pastdmark: pop af  
0c16			endm  
# End of macro DMARK
0c16					CALLMONITOR 
0c16 cd f3 18			call break_point_state  
0c19				endm  
# End of macro CALLMONITOR
0c19				endif 
0c19			 
0c19			 
0c19			 
0c19					; fill buffer with data until end of string or full block 
0c19			 
0c19 7e			.appd:		ld a, (hl) 
0c1a 12					ld (de), a 
0c1b fe 00				cp 0 
0c1d 28 04				jr z, .appdone 
0c1f 23					inc hl 
0c20 13					inc de 
0c21 10 f6				djnz .appd 
0c23			 
0c23 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c24 f5					push af   		; save last byte dumped 
0c25			 
0c25			 
0c25 2a 6c fa			ld hl, (store_tmppageid) 
0c28 11 81 fa			ld de, store_page 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP6" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 6e fe			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 6f fe			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 70 fe			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP6"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd f3 18			call break_point_state  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47 cd 81 04				call storage_write_block 
0c4a			 
0c4a			 
0c4a				; was that a full block of data written? 
0c4a				; any more to write out? 
0c4a			 
0c4a				; if yes then set vars and jump to start of function again 
0c4a			 
0c4a f1					pop af 
0c4b d1					pop de 
0c4c			 
0c4c fe 00				cp 0		 ; no, string was fully written 
0c4e c8					ret z 
0c4f			 
0c4f					; setup vars for next cycle 
0c4f			 
0c4f 3a 75 fa				ld a, (store_tmpid) 
0c52 6f					ld l, a 
0c53 26 00				ld h, 0 
0c55			 
0c55 c3 0c 0b			 	jp storage_append	 ; yes, need to write out some more 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			if DEBUG_STORECF 
0c58			storageput:	 
0c58					ret 
0c58			storageread: 
0c58					ld hl, store_page 
0c58					ld b, 200 
0c58					ld a,0 
0c58			.src:		ld (hl),a 
0c58					inc hl 
0c58					djnz .src 
0c58					 
0c58			 
0c58					ld de, 0 
0c58					ld bc, 1 
0c58					ld hl, store_page 
0c58					call cfRead 
0c58			 
0c58				call cfGetError 
0c58				ld hl,scratch 
0c58				call hexout 
0c58				ld hl, scratch+2 
0c58				ld a, 0 
0c58				ld (hl),a 
0c58				ld de, scratch 
0c58				ld a,display_row_1 
0c58				call str_at_display 
0c58				call update_display 
0c58			 
0c58					ld hl, store_page 
0c58					ld (os_cur_ptr),hl 
0c58			 
0c58					ret 
0c58			endif 
0c58			 
0c58			 
0c58			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c58			 
0c58			storage_clear_page: 
0c58 e5				push hl 
0c59 d5				push de 
0c5a c5				push bc 
0c5b 21 81 fa			ld hl, store_page 
0c5e 3e 00			ld a, 0 
0c60 77				ld (hl), a 
0c61			 
0c61 11 82 fa			ld de, store_page+1 
0c64 01 18 01			ld bc, STORE_BLOCK_LOG 
0c67			 
0c67 ed b0			ldir 
0c69				 
0c69 c1				pop bc 
0c6a d1				pop de 
0c6b e1				pop hl 
0c6c c9				ret 
0c6d			 
0c6d			; eof 
# End of file firmware_storage.asm
0c6d			  
0c6d			; support routines for above hardware abstraction layer  
0c6d			  
0c6d			include "firmware_general.asm"        ; general support functions  
0c6d			 
0c6d			; word look up 
0c6d			 
0c6d			; in 
0c6d			; a is the index 
0c6d			; hl is pointer start of array 
0c6d			; 
0c6d			; returns 
0c6d			; hl to the word 
0c6d			; 
0c6d			 
0c6d			table_lookup:  
0c6d d5					push de 
0c6e eb					ex de, hl 
0c6f			 
0c6f 6f					ld l, a 
0c70 26 00				ld h, 0 
0c72 29					add hl, hl 
0c73 19					add hl, de 
0c74 7e					ld a, (hl) 
0c75 23					inc hl 
0c76 66					ld h,(hl) 
0c77 6f					ld l, a 
0c78			 
0c78 d1					pop de 
0c79 c9					ret 
0c7a			 
0c7a			; Delay loops 
0c7a			 
0c7a			 
0c7a			 
0c7a			aDelayInMS: 
0c7a c5				push bc 
0c7b 47				ld b,a 
0c7c			msdelay: 
0c7c c5				push bc 
0c7d				 
0c7d			 
0c7d 01 41 00			ld bc,041h 
0c80 cd 98 0c			call delayloop 
0c83 c1				pop bc 
0c84 05				dec b 
0c85 20 f5			jr nz,msdelay 
0c87			 
0c87			;if CPU_CLOCK_8MHZ 
0c87			;msdelay8: 
0c87			;	push bc 
0c87			;	 
0c87			; 
0c87			;	ld bc,041h 
0c87			;	call delayloop 
0c87			;	pop bc 
0c87			;	dec b 
0c87			;	jr nz,msdelay8 
0c87			;endif 
0c87			 
0c87			 
0c87 c1				pop bc 
0c88 c9				ret 
0c89			 
0c89			 
0c89			delay250ms: 
0c89				;push de 
0c89 01 00 40			ld bc, 04000h 
0c8c c3 98 0c			jp delayloop 
0c8f			delay500ms: 
0c8f				;push de 
0c8f 01 00 80			ld bc, 08000h 
0c92 c3 98 0c			jp delayloop 
0c95			delay1s: 
0c95				;push bc 
0c95			   ; Clobbers A, d and e 
0c95 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c98			delayloop: 
0c98 c5			    push bc 
0c99			 
0c99			if BASE_CPM 
0c99				ld bc, CPM_DELAY_TUNE 
0c99			.cpmloop: 
0c99				push bc 
0c99			 
0c99			endif 
0c99			 
0c99			 
0c99			 
0c99			delayloopi: 
0c99			;	push bc 
0c99			;.dl: 
0c99 cb 47		    bit     0,a    	; 8 
0c9b cb 47		    bit     0,a    	; 8 
0c9d cb 47		    bit     0,a    	; 8 
0c9f e6 ff		    and     255  	; 7 
0ca1 0b			    dec     bc      	; 6 
0ca2 79			    ld      a,c     	; 4 
0ca3 b0			    or      b     	; 4 
0ca4 c2 99 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca7			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca7				;pop de 
0ca7			;pop bc 
0ca7			 
0ca7			if BASE_CPM 
0ca7				pop bc 
0ca7				 
0ca7			    dec     bc      	; 6 
0ca7			    ld      a,c     	; 4 
0ca7			    or      b     	; 4 
0ca7			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca7				 
0ca7			 
0ca7			endif 
0ca7			;if CPU_CLOCK_8MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7			 
0ca7			;if CPU_CLOCK_10MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7 c1			    pop bc 
0ca8			 
0ca8 c9				ret 
0ca9			 
0ca9			 
0ca9			 
0ca9			; eof 
# End of file firmware_general.asm
0ca9			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca9			; display routines that use the physical hardware abstraction layer 
0ca9			 
0ca9			 
0ca9			; information window 
0ca9			 
0ca9			; pass hl with 1st string to display 
0ca9			; pass de with 2nd string to display 
0ca9			 
0ca9			info_panel: 
0ca9 e5				push hl 
0caa			 
0caa 2a cf fb			ld hl, (display_fb_active) 
0cad e5				push hl    ; future de destination 
0cae 21 b4 fd				ld hl, display_fb0 
0cb1 22 cf fb				ld (display_fb_active), hl 
0cb4			 
0cb4			;	call clear_display 
0cb4			 
0cb4				if BASE_CPM 
0cb4				ld a, '.' 
0cb4				else 
0cb4 3e a5			ld a, 165 
0cb6				endif 
0cb6 cd 1d 0d			call fill_display 
0cb9			 
0cb9			 
0cb9 3e 55			ld a, display_row_3 + 5 
0cbb cd 2b 0d			call str_at_display 
0cbe			 
0cbe e1				pop hl 
0cbf d1				pop de 
0cc0			 
0cc0 e5				push hl 
0cc1			 
0cc1			 
0cc1 3e 2d			ld a, display_row_2 + 5 
0cc3 cd 2b 0d			call str_at_display 
0cc6			 
0cc6			 
0cc6 cd 3b 0d			call update_display 
0cc9 cd df 1e			call next_page_prompt 
0ccc cd 18 0d			call clear_display 
0ccf			 
0ccf				 
0ccf 21 13 fd				ld hl, display_fb1 
0cd2 22 cf fb				ld (display_fb_active), hl 
0cd5 cd 3b 0d			call update_display 
0cd8			 
0cd8 e1				pop hl 
0cd9			 
0cd9 c9				ret 
0cda			 
0cda			 
0cda			 
0cda			 
0cda			; TODO windowing? 
0cda			 
0cda			; TODO scroll line up 
0cda			 
0cda			scroll_up: 
0cda			 
0cda e5				push hl 
0cdb d5				push de 
0cdc c5				push bc 
0cdd			 
0cdd				; get frame buffer  
0cdd			 
0cdd 2a cf fb			ld hl, (display_fb_active) 
0ce0 e5				push hl    ; future de destination 
0ce1			 
0ce1 11 28 00			ld  de, display_cols 
0ce4 19				add hl, de 
0ce5			 
0ce5 d1				pop de 
0ce6			 
0ce6				;ex de, hl 
0ce6 01 9f 00			ld bc, display_fb_len -1  
0ce9			;if DEBUG_FORTH_WORDS 
0ce9			;	DMARK "SCL" 
0ce9			;	CALLMONITOR 
0ce9			;endif	 
0ce9 ed b0			ldir 
0ceb			 
0ceb				; wipe bottom row 
0ceb			 
0ceb			 
0ceb 2a cf fb			ld hl, (display_fb_active) 
0cee 11 a0 00			ld de, display_cols*display_rows 
0cf1 19				add hl, de 
0cf2 06 28			ld b, display_cols 
0cf4 3e 20			ld a, ' ' 
0cf6			.scwipe: 
0cf6 77				ld (hl), a 
0cf7 2b				dec hl 
0cf8 10 fc			djnz .scwipe 
0cfa			 
0cfa				;pop hl 
0cfa			 
0cfa c1				pop bc 
0cfb d1				pop de 
0cfc e1				pop hl 
0cfd			 
0cfd c9				ret 
0cfe			 
0cfe			 
0cfe			;scroll_upo: 
0cfe			;	ld de, display_row_1 
0cfe			 ;	ld hl, display_row_2 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_2 
0cfe			 ;	ld hl, display_row_3 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_3 
0cfe			 ;	ld hl, display_row_4 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			 
0cfe			; TODO clear row 4 
0cfe			 
0cfe			;	ret 
0cfe			 
0cfe				 
0cfe			scroll_down: 
0cfe			 
0cfe e5				push hl 
0cff d5				push de 
0d00 c5				push bc 
0d01			 
0d01				; get frame buffer  
0d01			 
0d01 2a cf fb			ld hl, (display_fb_active) 
0d04			 
0d04 11 9f 00			ld de, display_fb_len - 1 
0d07 19				add hl, de 
0d08			 
0d08 e5			push hl    ; future de destination 
0d09			 
0d09 11 28 00			ld  de, display_cols 
0d0c ed 52			sbc hl, de 
0d0e			 
0d0e			 
0d0e d1				pop de 
0d0f			 
0d0f			;	ex de, hl 
0d0f 01 9f 00			ld bc, display_fb_len -1  
0d12			 
0d12			 
0d12				 
0d12			 
0d12 ed b0			ldir 
0d14			 
0d14				; wipe bottom row 
0d14			 
0d14			 
0d14			;	ld hl, (display_fb_active) 
0d14			;;	ld de, display_cols*display_rows 
0d14			;;	add hl, de 
0d14			;	ld b, display_cols 
0d14			;	ld a, ' ' 
0d14			;.scwiped: 
0d14			;	ld (hl), a 
0d14			;	dec hl 
0d14			;	djnz .scwiped 
0d14			 
0d14				;pop hl 
0d14			 
0d14 c1				pop bc 
0d15 d1				pop de 
0d16 e1				pop hl 
0d17			 
0d17 c9				ret 
0d18			;scroll_down: 
0d18			;	ld de, display_row_4 
0d18			;	ld hl, display_row_3 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_3 
0d18			; 	ld hl, display_row_2 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_2 
0d18			;	ld hl, display_row_1 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;;; TODO clear row 1 
0d18			;	ret 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			; clear active frame buffer 
0d18			 
0d18			clear_display: 
0d18 3e 20			ld a, ' ' 
0d1a c3 1d 0d			jp fill_display 
0d1d			 
0d1d			; fill active frame buffer with a char in A 
0d1d			 
0d1d			fill_display: 
0d1d 06 a0			ld b,display_fb_len 
0d1f 2a cf fb			ld hl, (display_fb_active) 
0d22 77			.fd1:	ld (hl),a 
0d23 23				inc hl 
0d24 10 fc			djnz .fd1 
0d26 23				inc hl 
0d27 3e 00			ld a,0 
0d29 77				ld (hl),a 
0d2a			 
0d2a			 
0d2a c9				ret 
0d2b			; Write string (DE) at pos (A) to active frame buffer 
0d2b			 
0d2b 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0d2e 06 00					ld b,0 
0d30 4f					ld c,a 
0d31 09					add hl,bc 
0d32 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d33 b7			            OR   A              ;Null terminator? 
0d34 c8			            RET  Z              ;Yes, so finished 
0d35 77					ld (hl),a 
0d36 23				inc hl 
0d37 13			            INC  DE             ;Point to next character 
0d38 18 f8		            JR   .sad1     ;Repeat 
0d3a c9					ret 
0d3b			 
0d3b			; using current frame buffer write to physical display 
0d3b			 
0d3b			update_display: 
0d3b e5				push hl 
0d3c 2a cf fb			ld hl, (display_fb_active) 
0d3f cd 6f 70			call write_display 
0d42 e1				pop hl 
0d43 c9				ret 
0d44			 
0d44			; TODO scrolling 
0d44			 
0d44			 
0d44			; move cursor right one char 
0d44			cursor_right: 
0d44			 
0d44				; TODO shift right 
0d44				; TODO if beyond max col 
0d44				; TODO       cursor_next_line 
0d44			 
0d44 c9				ret 
0d45			 
0d45			 
0d45			cursor_next_line: 
0d45				; TODO first char 
0d45				; TODO line down 
0d45				; TODO if past last row 
0d45				; TODO    scroll up 
0d45			 
0d45 c9				ret 
0d46			 
0d46			cursor_left: 
0d46				; TODO shift left 
0d46				; TODO if beyond left  
0d46				; TODO     cursor prev line 
0d46				 
0d46 c9				ret 
0d47			 
0d47			cursor_prev_line: 
0d47				; TODO last char 
0d47				; TODO line up 
0d47				; TODO if past first row 
0d47				; TODO   scroll down 
0d47			 
0d47 c9				ret 
0d48			 
0d48			 
0d48			cout: 
0d48				; A - char 
0d48 c9				ret 
0d49			 
0d49			 
0d49			; Display a menu and allow item selection (optional toggle items) 
0d49			; 
0d49			; format: 
0d49			; hl pointer to word array with zero term for items 
0d49			; e.g.    db item1 
0d49			;         db .... 
0d49			;         db 0 
0d49			; 
0d49			; a = starting menu item  
0d49			; 
0d49			; de = pointer item toggle array   (todo) 
0d49			; 
0d49			; returns item selected in a 1-... 
0d49			; returns 0 if back button pressed 
0d49			; 
0d49			; NOTE: Uses system frame buffer to display 
0d49			; 
0d49			; LEFT, Q = go back 
0d49			; RIGHT, SPACE, CR = select 
0d49			; UP, A - Up 
0d49			; DOWN, Z - Down 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			menu: 
0d49			 
0d49					; keep array pointer 
0d49			 
0d49 22 7a fa				ld (store_tmp1), hl 
0d4c 32 78 fa				ld (store_tmp2), a 
0d4f			 
0d4f					; check for key bounce 
0d4f			 
0d4f			if BASE_KEV 
0d4f			 
0d4f cd ba 73		.mbounce:	call cin 
0d52 fe 00				cp 0 
0d54 20 f9				jr nz, .mbounce 
0d56			endif 
0d56					; for ease use ex 
0d56			 
0d56					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d56 21 b4 fd				ld hl, display_fb0 
0d59 22 cf fb				ld (display_fb_active), hl 
0d5c			 
0d5c cd 18 0d		.mloop:		call clear_display 
0d5f cd 3b 0d				call update_display 
0d62			 
0d62					; draw selection id '>' at 1 
0d62			 
0d62					; init start of list display 
0d62			 
0d62 3e 05				ld a, 5 
0d64 32 76 fa				ld (store_tmp3), a   ; display row count 
0d67 3a 78 fa				ld a,( store_tmp2) 
0d6a 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d6d			 
0d6d					 
0d6d			.mitem:	 
0d6d			 
0d6d			 
0d6d 3a 79 fa				ld a,(store_tmp2+1) 
0d70 6f					ld l, a 
0d71 26 00				ld h, 0 
0d73 29					add hl, hl 
0d74 ed 5b 7a fa			ld de, (store_tmp1) 
0d78 19					add hl, de 
0d79 7e					ld a, (hl) 
0d7a 23					inc hl 
0d7b 66					ld h,(hl) 
0d7c 6f					ld l, a 
0d7d			 
0d7d cd 75 0f				call ishlzero 
0d80 28 1a				jr z, .mdone 
0d82			 
0d82 eb					ex de, hl 
0d83 3a 76 fa				ld a, (store_tmp3) 
0d86 cd 2b 0d				call str_at_display 
0d89					 
0d89			 
0d89					; next item 
0d89 3a 79 fa				ld a, (store_tmp2+1) 
0d8c 3c					inc a 
0d8d 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d90			 
0d90			 		; next row 
0d90			 
0d90 3a 76 fa				ld a, (store_tmp3) 
0d93 c6 28				add display_cols 
0d95 32 76 fa				ld (store_tmp3), a 
0d98			 
0d98					; at end of screen? 
0d98			 
0d98 fe 10				cp display_rows*4 
0d9a 20 d1				jr nz, .mitem 
0d9c			 
0d9c			 
0d9c			.mdone: 
0d9c cd 75 0f				call ishlzero 
0d9f 28 08				jr z, .nodn 
0da1			 
0da1 3e 78				ld a, display_row_4 
0da3 11 22 0e				ld de, .mdown 
0da6 cd 2b 0d				call str_at_display 
0da9			 
0da9					; draw options to fill the screens with active item on line 1 
0da9					; if current option is 2 or more then display ^ in top 
0da9			 
0da9 3a 78 fa		.nodn:		ld a, (store_tmp2) 
0dac fe 00				cp 0 
0dae 28 08				jr z, .noup 
0db0			 
0db0 3e 00				ld a, 0 
0db2 11 20 0e				ld de, .mup 
0db5 cd 2b 0d				call str_at_display 
0db8			 
0db8 3e 02		.noup:		ld a, 2 
0dba 11 1e 0e				ld de, .msel 
0dbd cd 2b 0d				call str_at_display 
0dc0			 
0dc0					; if current option + 1 is not null then display V in bottom 
0dc0					; get key 
0dc0 cd 3b 0d				call update_display 
0dc3			 
0dc3			 
0dc3					; handle key 
0dc3			 
0dc3 cd a9 73				call cin_wait 
0dc6			 
0dc6 fe 05				cp KEY_UP 
0dc8 28 2b				jr z, .mgoup 
0dca fe 61				cp 'a' 
0dcc 28 27				jr z, .mgoup 
0dce fe 0a				cp KEY_DOWN 
0dd0 28 32				jr z, .mgod 
0dd2 fe 7a				cp 'z' 
0dd4 28 2e				jr z, .mgod 
0dd6 fe 20				cp ' ' 
0dd8 28 34				jr z, .goend 
0dda fe 0c				cp KEY_RIGHT 
0ddc 28 30				jr z, .goend 
0dde fe 0d				cp KEY_CR 
0de0 28 2c				jr z, .goend 
0de2 fe 71				cp 'q' 
0de4 28 0b				jr z, .goback 
0de6			 
0de6 fe 0b				cp KEY_LEFT 
0de8 28 07				jr z, .goback 
0dea fe 08				cp KEY_BS 
0dec 28 03				jr z, .goback 
0dee c3 5c 0d				jp .mloop 
0df1			 
0df1			.goback: 
0df1 3e 00			ld a, 0 
0df3 18 1d			jr .goend2 
0df5			 
0df5				; move up one 
0df5			.mgoup: 
0df5 3a 78 fa				ld a, (store_tmp2) 
0df8 fe 00				cp 0 
0dfa ca 5c 0d				jp z, .mloop 
0dfd 3d					dec a 
0dfe 32 78 fa				ld (store_tmp2), a 
0e01 c3 5c 0d				jp .mloop 
0e04			 
0e04				; move down one 
0e04			.mgod: 
0e04 3a 78 fa				ld a, (store_tmp2) 
0e07 3c					inc a 
0e08 32 78 fa				ld (store_tmp2), a 
0e0b c3 5c 0d				jp .mloop 
0e0e			 
0e0e			 
0e0e			.goend: 
0e0e					; get selected item number 
0e0e			 
0e0e 3a 78 fa				ld a, (store_tmp2) 
0e11 3c					inc a 
0e12			 
0e12			.goend2: 
0e12 f5					push af 
0e13			 
0e13					; restore active fb 
0e13					; TODO BUG assumes fb1 
0e13			 
0e13 21 13 fd				ld hl, display_fb1 
0e16 22 cf fb				ld (display_fb_active), hl 
0e19			 
0e19					; restore main regs 
0e19			 
0e19			 
0e19 cd 3b 0d				call update_display 
0e1c			 
0e1c f1					pop af 
0e1d			 
0e1d c9				ret 
0e1e			 
0e1e .. 00		.msel:   db ">",0 
0e20 .. 00		.mup:   db "^",0 
0e22 .. 00		.mdown:   db "v",0 
0e24			 
0e24			 
0e24			; eof 
0e24			 
# End of file firmware_display.asm
0e24			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e24			; random number generators 
0e24			 
0e24			 
0e24			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e24			 
0e24			 
0e24			;-----> Generate a random number 
0e24			; output a=answer 0<=a<=255 
0e24			; all registers are preserved except: af 
0e24			random: 
0e24 e5			        push    hl 
0e25 d5			        push    de 
0e26 2a b1 fb		        ld      hl,(randData) 
0e29 ed 5f		        ld      a,r 
0e2b 57			        ld      d,a 
0e2c 5e			        ld      e,(hl) 
0e2d 19			        add     hl,de 
0e2e 85			        add     a,l 
0e2f ac			        xor     h 
0e30 22 b1 fb		        ld      (randData),hl 
0e33 d1			        pop     de 
0e34 e1			        pop     hl 
0e35 c9			        ret 
0e36			 
0e36			 
0e36			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e36			 
0e36			 
0e36			 
0e36			;------LFSR------ 
0e36			;James Montelongo 
0e36			;optimized by Spencer Putt 
0e36			;out: 
0e36			; a = 8 bit random number 
0e36			RandLFSR: 
0e36 21 b7 fb		        ld hl,LFSRSeed+4 
0e39 5e			        ld e,(hl) 
0e3a 23			        inc hl 
0e3b 56			        ld d,(hl) 
0e3c 23			        inc hl 
0e3d 4e			        ld c,(hl) 
0e3e 23			        inc hl 
0e3f 7e			        ld a,(hl) 
0e40 47			        ld b,a 
0e41 cb 13		        rl e  
0e43 cb 12			rl d 
0e45 cb 11		        rl c  
0e47 17				rla 
0e48 cb 13		        rl e  
0e4a cb 12			rl d 
0e4c cb 11		        rl c  
0e4e 17				rla 
0e4f cb 13		        rl e  
0e51 cb 12			rl d 
0e53 cb 11		        rl c  
0e55 17				rla 
0e56 67			        ld h,a 
0e57 cb 13		        rl e  
0e59 cb 12			rl d 
0e5b cb 11		        rl c  
0e5d 17				rla 
0e5e a8			        xor b 
0e5f cb 13		        rl e  
0e61 cb 12			rl d 
0e63 ac			        xor h 
0e64 a9			        xor c 
0e65 aa			        xor d 
0e66 21 b9 fb		        ld hl,LFSRSeed+6 
0e69 11 ba fb		        ld de,LFSRSeed+7 
0e6c 01 07 00		        ld bc,7 
0e6f ed b8		        lddr 
0e71 12			        ld (de),a 
0e72 c9			        ret 
0e73			 
0e73			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e73			 
0e73			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e73			 
0e73			 
0e73			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e73			 
0e73			prng16: 
0e73			;Inputs: 
0e73			;   (seed1) contains a 16-bit seed value 
0e73			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e73			;Outputs: 
0e73			;   HL is the result 
0e73			;   BC is the result of the LCG, so not that great of quality 
0e73			;   DE is preserved 
0e73			;Destroys: 
0e73			;   AF 
0e73			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e73			;160cc 
0e73			;26 bytes 
0e73 2a ab fb		    ld hl,(seed1) 
0e76 44			    ld b,h 
0e77 4d			    ld c,l 
0e78 29			    add hl,hl 
0e79 29			    add hl,hl 
0e7a 2c			    inc l 
0e7b 09			    add hl,bc 
0e7c 22 ab fb		    ld (seed1),hl 
0e7f 2a a9 fb		    ld hl,(seed2) 
0e82 29			    add hl,hl 
0e83 9f			    sbc a,a 
0e84 e6 2d		    and %00101101 
0e86 ad			    xor l 
0e87 6f			    ld l,a 
0e88 22 a9 fb		    ld (seed2),hl 
0e8b 09			    add hl,bc 
0e8c c9			    ret 
0e8d			 
0e8d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e8d			 
0e8d			rand32: 
0e8d			;Inputs: 
0e8d			;   (seed1_0) holds the lower 16 bits of the first seed 
0e8d			;   (seed1_1) holds the upper 16 bits of the first seed 
0e8d			;   (seed2_0) holds the lower 16 bits of the second seed 
0e8d			;   (seed2_1) holds the upper 16 bits of the second seed 
0e8d			;   **NOTE: seed2 must be non-zero 
0e8d			;Outputs: 
0e8d			;   HL is the result 
0e8d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e8d			;Destroys: 
0e8d			;   AF 
0e8d			;Tested and passes all CAcert tests 
0e8d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e8d			;it has a period of 18,446,744,069,414,584,320 
0e8d			;roughly 18.4 quintillion. 
0e8d			;LFSR taps: 0,2,6,7  = 11000101 
0e8d			;291cc 
0e8d			;seed1_0=$+1 
0e8d			;    ld hl,12345 
0e8d			;seed1_1=$+1 
0e8d			;    ld de,6789 
0e8d			;    ld b,h 
0e8d			;    ld c,l 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    inc l 
0e8d			;    add hl,bc 
0e8d			;    ld (seed1_0),hl 
0e8d			;    ld hl,(seed1_1) 
0e8d			;    adc hl,de 
0e8d			;    ld (seed1_1),hl 
0e8d			;    ex de,hl 
0e8d			;seed2_0=$+1 
0e8d			;    ld hl,9876 
0e8d			;seed2_1=$+1 
0e8d			;    ld bc,54321 
0e8d			;    add hl,hl \ rl c \ rl b 
0e8d			;    ld (seed2_1),bc 
0e8d			;    sbc a,a 
0e8d			;    and %11000101 
0e8d			;    xor l 
0e8d			;    ld l,a 
0e8d			;    ld (seed2_0),hl 
0e8d			;    ex de,hl 
0e8d			;    add hl,bc 
0e8d			;    ret 
0e8d			; 
0e8d			 
0e8d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e8d			; 20 bytes, 86 cycles (excluding ret) 
0e8d			 
0e8d			; returns   hl = pseudorandom number 
0e8d			; corrupts   a 
0e8d			 
0e8d			; generates 16-bit pseudorandom numbers with a period of 65535 
0e8d			; using the xorshift method: 
0e8d			 
0e8d			; hl ^= hl << 7 
0e8d			; hl ^= hl >> 9 
0e8d			; hl ^= hl << 8 
0e8d			 
0e8d			; some alternative shift triplets which also perform well are: 
0e8d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e8d			 
0e8d			;  org 32768 
0e8d			 
0e8d			xrnd: 
0e8d 2a af fb		  ld hl,(xrandc)       ; seed must not be 0 
0e90 3e 00		  ld a,0 
0e92 bd			  cp l 
0e93 20 02		  jr nz, .xrnd1 
0e95 2e 01		  ld l, 1 
0e97			.xrnd1: 
0e97			 
0e97 7c			  ld a,h 
0e98 1f			  rra 
0e99 7d			  ld a,l 
0e9a 1f			  rra 
0e9b ac			  xor h 
0e9c 67			  ld h,a 
0e9d 7d			  ld a,l 
0e9e 1f			  rra 
0e9f 7c			  ld a,h 
0ea0 1f			  rra 
0ea1 ad			  xor l 
0ea2 6f			  ld l,a 
0ea3 ac			  xor h 
0ea4 67			  ld h,a 
0ea5			 
0ea5 22 af fb		  ld (xrandc),hl 
0ea8			 
0ea8 c9			  ret 
0ea9			;  
0ea9			 
0ea9			 
0ea9			;;;; int maths 
0ea9			 
0ea9			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ea9			; Divide 16-bit values (with 16-bit result) 
0ea9			; In: Divide BC by divider DE 
0ea9			; Out: BC = result, HL = rest 
0ea9			; 
0ea9			Div16: 
0ea9 21 00 00		    ld hl,0 
0eac 78			    ld a,b 
0ead 06 08		    ld b,8 
0eaf			Div16_Loop1: 
0eaf 17			    rla 
0eb0 ed 6a		    adc hl,hl 
0eb2 ed 52		    sbc hl,de 
0eb4 30 01		    jr nc,Div16_NoAdd1 
0eb6 19			    add hl,de 
0eb7			Div16_NoAdd1: 
0eb7 10 f6		    djnz Div16_Loop1 
0eb9 17			    rla 
0eba 2f			    cpl 
0ebb 47			    ld b,a 
0ebc 79			    ld a,c 
0ebd 48			    ld c,b 
0ebe 06 08		    ld b,8 
0ec0			Div16_Loop2: 
0ec0 17			    rla 
0ec1 ed 6a		    adc hl,hl 
0ec3 ed 52		    sbc hl,de 
0ec5 30 01		    jr nc,Div16_NoAdd2 
0ec7 19			    add hl,de 
0ec8			Div16_NoAdd2: 
0ec8 10 f6		    djnz Div16_Loop2 
0eca 17			    rla 
0ecb 2f			    cpl 
0ecc 41			    ld b,c 
0ecd 4f			    ld c,a 
0ece c9			ret 
0ecf			 
0ecf			 
0ecf			;http://z80-heaven.wikidot.com/math 
0ecf			; 
0ecf			;Inputs: 
0ecf			;     DE and A are factors 
0ecf			;Outputs: 
0ecf			;     A is not changed 
0ecf			;     B is 0 
0ecf			;     C is not changed 
0ecf			;     DE is not changed 
0ecf			;     HL is the product 
0ecf			;Time: 
0ecf			;     342+6x 
0ecf			; 
0ecf			Mult16: 
0ecf			 
0ecf 06 08		     ld b,8          ;7           7 
0ed1 21 00 00		     ld hl,0         ;10         10 
0ed4 29			       add hl,hl     ;11*8       88 
0ed5 07			       rlca          ;4*8        32 
0ed6 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ed8 19			         add hl,de   ;--         -- 
0ed9 10 f9		       djnz $-5      ;13*7+8     99 
0edb c9			ret 
0edc			 
0edc			; 
0edc			; Square root of 16-bit value 
0edc			; In:  HL = value 
0edc			; Out:  D = result (rounded down) 
0edc			; 
0edc			;Sqr16: 
0edc			;    ld de,#0040 
0edc			;    ld a,l 
0edc			;    ld l,h 
0edc			;    ld h,d 
0edc			;    or a 
0edc			;    ld b,8 
0edc			;Sqr16_Loop: 
0edc			;    sbc hl,de 
0edc			;    jr nc,Sqr16_Skip 
0edc			;    add hl,de 
0edc			;Sqr16_Skip: 
0edc			;    ccf 
0edc			;    rl d 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    djnz Sqr16_Loop 
0edc			;    ret 
0edc			; 
0edc			; 
0edc			; Divide 8-bit values 
0edc			; In: Divide E by divider C 
0edc			; Out: A = result, B = rest 
0edc			; 
0edc			Div8: 
0edc af			    xor a 
0edd 06 08		    ld b,8 
0edf			Div8_Loop: 
0edf cb 13		    rl e 
0ee1 17			    rla 
0ee2 91			    sub c 
0ee3 30 01		    jr nc,Div8_NoAdd 
0ee5 81			    add a,c 
0ee6			Div8_NoAdd: 
0ee6 10 f7		    djnz Div8_Loop 
0ee8 47			    ld b,a 
0ee9 7b			    ld a,e 
0eea 17			    rla 
0eeb 2f			    cpl 
0eec c9			    ret 
0eed			 
0eed			; 
0eed			; Multiply 8-bit value with a 16-bit value (unrolled) 
0eed			; In: Multiply A with DE 
0eed			; Out: HL = result 
0eed			; 
0eed			Mult12U: 
0eed 2e 00		    ld l,0 
0eef 87			    add a,a 
0ef0 30 01		    jr nc,Mult12U_NoAdd0 
0ef2 19			    add hl,de 
0ef3			Mult12U_NoAdd0: 
0ef3 29			    add hl,hl 
0ef4 87			    add a,a 
0ef5 30 01		    jr nc,Mult12U_NoAdd1 
0ef7 19			    add hl,de 
0ef8			Mult12U_NoAdd1: 
0ef8 29			    add hl,hl 
0ef9 87			    add a,a 
0efa 30 01		    jr nc,Mult12U_NoAdd2 
0efc 19			    add hl,de 
0efd			Mult12U_NoAdd2: 
0efd 29			    add hl,hl 
0efe 87			    add a,a 
0eff 30 01		    jr nc,Mult12U_NoAdd3 
0f01 19			    add hl,de 
0f02			Mult12U_NoAdd3: 
0f02 29			    add hl,hl 
0f03 87			    add a,a 
0f04 30 01		    jr nc,Mult12U_NoAdd4 
0f06 19			    add hl,de 
0f07			Mult12U_NoAdd4: 
0f07 29			    add hl,hl 
0f08 87			    add a,a 
0f09 30 01		    jr nc,Mult12U_NoAdd5 
0f0b 19			    add hl,de 
0f0c			Mult12U_NoAdd5: 
0f0c 29			    add hl,hl 
0f0d 87			    add a,a 
0f0e 30 01		    jr nc,Mult12U_NoAdd6 
0f10 19			    add hl,de 
0f11			Mult12U_NoAdd6: 
0f11 29			    add hl,hl 
0f12 87			    add a,a 
0f13 d0			    ret nc 
0f14 19			    add hl,de 
0f15 c9			    ret 
0f16			 
0f16			; 
0f16			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f16			; In: Multiply A with DE 
0f16			;      Put lowest value in A for most efficient calculation 
0f16			; Out: HL = result 
0f16			; 
0f16			Mult12R: 
0f16 21 00 00		    ld hl,0 
0f19			Mult12R_Loop: 
0f19 cb 3f		    srl a 
0f1b 30 01		    jr nc,Mult12R_NoAdd 
0f1d 19			    add hl,de 
0f1e			Mult12R_NoAdd: 
0f1e cb 23		    sla e 
0f20 cb 12		    rl d 
0f22 b7			    or a 
0f23 c2 19 0f		    jp nz,Mult12R_Loop 
0f26 c9			    ret 
0f27			 
0f27			; 
0f27			; Multiply 16-bit values (with 32-bit result) 
0f27			; In: Multiply BC with DE 
0f27			; Out: BCHL = result 
0f27			; 
0f27			Mult32: 
0f27 79			    ld a,c 
0f28 48			    ld c,b 
0f29 21 00 00		    ld hl,0 
0f2c 06 10		    ld b,16 
0f2e			Mult32_Loop: 
0f2e 29			    add hl,hl 
0f2f 17			    rla 
0f30 cb 11		    rl c 
0f32 30 07		    jr nc,Mult32_NoAdd 
0f34 19			    add hl,de 
0f35 ce 00		    adc a,0 
0f37 d2 3b 0f		    jp nc,Mult32_NoAdd 
0f3a 0c			    inc c 
0f3b			Mult32_NoAdd: 
0f3b 10 f1		    djnz Mult32_Loop 
0f3d 41			    ld b,c 
0f3e 4f			    ld c,a 
0f3f c9			    ret 
0f40			 
0f40			 
0f40			 
0f40			; 
0f40			; Multiply 8-bit values 
0f40			; In:  Multiply H with E 
0f40			; Out: HL = result 
0f40			; 
0f40			Mult8: 
0f40 16 00		    ld d,0 
0f42 6a			    ld l,d 
0f43 06 08		    ld b,8 
0f45			Mult8_Loop: 
0f45 29			    add hl,hl 
0f46 30 01		    jr nc,Mult8_NoAdd 
0f48 19			    add hl,de 
0f49			Mult8_NoAdd: 
0f49 10 fa		    djnz Mult8_Loop 
0f4b c9			    ret 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			;;http://z80-heaven.wikidot.com/math 
0f4c			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f4c			; 
0f4c			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f4c			;     ld a,16        ;7 
0f4c			;     ld hl,0        ;10 
0f4c			;     jp $+5         ;10 
0f4c			;.DivLoop: 
0f4c			;       add hl,bc    ;-- 
0f4c			;       dec a        ;64 
0f4c			;       jr z,.DivLoopEnd        ;86 
0f4c			; 
0f4c			;       sla e        ;128 
0f4c			;       rl d         ;128 
0f4c			;       adc hl,hl    ;240 
0f4c			;       sbc hl,bc    ;240 
0f4c			;       jr nc,.DivLoop ;23|21 
0f4c			;       inc e        ;-- 
0f4c			;       jp .DivLoop+1 
0f4c			; 
0f4c			;.DivLoopEnd: 
0f4c			 
0f4c			;HL_Div_C: 
0f4c			;Inputs: 
0f4c			;     HL is the numerator 
0f4c			;     C is the denominator 
0f4c			;Outputs: 
0f4c			;     A is the remainder 
0f4c			;     B is 0 
0f4c			;     C is not changed 
0f4c			;     DE is not changed 
0f4c			;     HL is the quotient 
0f4c			; 
0f4c			;       ld b,16 
0f4c			;       xor a 
0f4c			;         add hl,hl 
0f4c			;         rla 
0f4c			;         cp c 
0f4c			;         jr c,$+4 
0f4c			;           inc l 
0f4c			;           sub c 
0f4c			;         djnz $-7 
0f4c			 
0f4c			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f4c			 
0f4c			addatohl: 
0f4c 85			    add   a, l    ; A = A+L 
0f4d 6f			    ld    l, a    ; L = A+L 
0f4e 8c			    adc   a, h    ; A = A+L+H+carry 
0f4f 95			    sub   l       ; A = H+carry 
0f50 67			    ld    h, a    ; H = H+carry 
0f51 c9			ret 
0f52			 
0f52			addatode: 
0f52 83			    add   a, e    ; A = A+L 
0f53 5f			    ld    e, a    ; L = A+L 
0f54 8a			    adc   a, d    ; A = A+L+H+carry 
0f55 93			    sub   e       ; A = H+carry 
0f56 57			    ld    d, a    ; H = H+carry 
0f57 c9			ret 
0f58			 
0f58			 
0f58			addatobc: 
0f58 81			    add   a, c    ; A = A+L 
0f59 4f			    ld    c, a    ; L = A+L 
0f5a 88			    adc   a, b    ; A = A+L+H+carry 
0f5b 91			    sub   c       ; A = H+carry 
0f5c 47			    ld    b, a    ; H = H+carry 
0f5d c9			ret 
0f5e			 
0f5e			subafromhl: 
0f5e			   ; If A=0 do nothing 
0f5e			    ; Otherwise flip A's sign. Since 
0f5e			    ; the upper byte becomes -1, also 
0f5e			    ; substract 1 from H. 
0f5e ed 44		    neg 
0f60 ca 69 0f		    jp    z, Skip 
0f63 25			    dec   h 
0f64			     
0f64			    ; Now add the low byte as usual 
0f64			    ; Two's complement takes care of 
0f64			    ; ensuring the result is correct 
0f64 85			    add   a, l 
0f65 6f			    ld    l, a 
0f66 8c			    adc   a, h 
0f67 95			    sub   l 
0f68 67			    ld    h, a 
0f69			Skip: 
0f69 c9				ret 
0f6a			 
0f6a			 
0f6a			; compare hl and de 
0f6a			; returns:  
0f6a			; if hl = de, z=1, s=0, c0=0 
0f6a			; if hl > de, z=0, s=0, c=0 
0f6a			; if hl < de, z=0, s=1, c=1 
0f6a			cmp16:	 
0f6a b7				or a 
0f6b ed 52			sbc hl,de 
0f6d e0				ret po 
0f6e 7c				ld a,h 
0f6f 1f				rra 
0f70 ee 40			xor 01000000B 
0f72 37				scf 
0f73 8f				adc a,a 
0f74 c9				ret 
0f75			 
0f75			 
0f75			; test if hl contains zero   - A is destroyed 
0f75			 
0f75			ishlzero:    
0f75 b7				or a     ; reset flags 
0f76 7c				ld a, h 
0f77 b5				or l        	 
0f78			 
0f78 c9				ret 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			if FORTH_ENABLE_FLOATMATH 
0f79			;include "float/bbcmath.z80" 
0f79			include "float/lpfpcalc.asm" 
0f79			endif 
0f79			 
0f79			 
0f79			; eof 
0f79			 
# End of file firmware_maths.asm
0f79			include "firmware_strings.asm"   ; string handling  
0f79			 
0f79			 
0f79			; TODO string len 
0f79			; input text string, end on cr with zero term 
0f79			; a offset into frame buffer to start prompt 
0f79			; d is max length 
0f79			; e is display size TODO 
0f79			; c is current cursor position 
0f79			; hl is ptr to where string will be stored 
0f79			 
0f79			 
0f79			; TODO check limit of buffer for new inserts 
0f79			; TODO check insert does not push beyond buffer 
0f79			; TODO scroll in a limited display area 
0f79			; TODO scroll whole screen on page wrap 
0f79			 
0f79			 
0f79			; TODO handle KEY_PREVWORD 
0f79			; TODO handle KEY_NEXTWORD 
0f79			; TODO handle KEY_HOME 
0f79			; TODO handle KEY_END 
0f79			; TODO use LCD cursor? 
0f79			 
0f79 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f7c 81					add c 
0f7d 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f80 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0f83 79					ld a, c 
0f84 cd 4c 0f				call addatohl 
0f87 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f8a 7a					ld a,d 
0f8b 32 69 fe			        ld (input_size), a       ; save length of input area 
0f8e 79					ld a, c 
0f8f 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0f92 7b					ld a,e 
0f93 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f96					 
0f96					 
0f96			 
0f96			;		ld a,(input_ptr) 
0f96			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f96			 
0f96			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f96					; init cursor shape if not set by the cin routines 
0f96 21 c7 fb				ld hl, cursor_shape 
0f99 3e ff				ld a, 255 
0f9b 77					ld (hl), a 
0f9c 23					inc hl 
0f9d 3e 00				ld a, 0 
0f9f 77					ld (hl), a 
0fa0			 
0fa0 3e 0f				ld a, CUR_BLINK_RATE 
0fa2 32 63 fe				ld (input_cur_flash), a 
0fa5 3e 01				ld a, 1 
0fa7 32 62 fe				ld (input_cur_onoff),a 
0faa			 
0faa			;	if DEBUG_INPUT 
0faa			;		push af 
0faa			;		ld a, 'I' 
0faa			;		ld (debug_mark),a 
0faa			;		pop af 
0faa			;		CALLMONITOR 
0faa			;	endif 
0faa			.is1:		; main entry loop 
0faa			 
0faa			 
0faa			 
0faa					; pause 1ms 
0faa			 
0faa 3e 01				ld a, 1 
0fac cd 7a 0c				call aDelayInMS 
0faf			 
0faf					; dec flash counter 
0faf 3a 63 fe				ld a, (input_cur_flash) 
0fb2 3d					dec a 
0fb3 32 63 fe				ld (input_cur_flash), a 
0fb6 fe 00				cp 0 
0fb8 20 0d				jr nz, .nochgstate 
0fba			 
0fba			 
0fba					; change state 
0fba 3a 62 fe				ld a,(input_cur_onoff) 
0fbd ed 44				neg 
0fbf 32 62 fe				ld (input_cur_onoff),a 
0fc2			 
0fc2			 
0fc2					; reset on change of state 
0fc2 3e 0f				ld a, CUR_BLINK_RATE 
0fc4 32 63 fe				ld (input_cur_flash), a 
0fc7			 
0fc7			.nochgstate: 
0fc7					 
0fc7					 
0fc7			 
0fc7					; display cursor  
0fc7			 
0fc7			;		ld hl, (input_start) 
0fc7			;		ld a, (input_cursor) 
0fc7			;		call addatohl 
0fc7			 
0fc7					; get char under cursor and replace with cursor 
0fc7 2a 6c fe		ld hl, (input_ptr) 
0fca			;		ld a, (hl) 
0fca			;		ld (input_under_cursor),a 
0fca			;		ld a, '_' 
0fca			;		ld (hl), a 
0fca			 
0fca					; display string 
0fca			 
0fca ed 5b 6a fe			ld de, (input_start) 
0fce 3a 67 fe				ld a, (input_at_pos) 
0fd1 cd 2b 0d				call str_at_display 
0fd4			;	        call update_display 
0fd4			 
0fd4					; find place to put the cursor 
0fd4			;		add h 
0fd4			;		ld l, display_row_1 
0fd4			;		sub l 
0fd4			; (input_at_pos) 
0fd4					;ld c, a 
0fd4			;		ld a, (input_cursor) 
0fd4			;		ld l, (input_at_pos) 
0fd4			;		;ld b, h 
0fd4			;		add l 
0fd4			;		ld (input_at_cursor),a 
0fd4					;ld l,h 
0fd4			 
0fd4			;		ld h, 0 
0fd4			;		ld l,(input_at_pos) 
0fd4			;		ld a, (input_cursor) 
0fd4			;		call addatohl 
0fd4			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd4			;		call subafromhl 
0fd4			;		ld a,l 
0fd4			;		ld (input_at_cursor), a 
0fd4			 
0fd4				if DEBUG_INPUT 
0fd4					ld a, (hardware_diag) 
0fd4					cp 0 
0fd4					jr z, .skip_input_diag 
0fd4			 
0fd4					ld a,(input_at_pos) 
0fd4					ld hl, LFSRSeed 
0fd4					call hexout 
0fd4					ld a, (input_cursor) 
0fd4					ld hl, LFSRSeed+2 
0fd4					call hexout 
0fd4					ld a,(input_at_cursor) 
0fd4					ld hl, LFSRSeed+4 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_onoff) 
0fd4					ld hl, LFSRSeed+6 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_flash) 
0fd4					ld hl, LFSRSeed+8 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_len) 
0fd4					ld hl, LFSRSeed+10 
0fd4					call hexout 
0fd4					ld hl, LFSRSeed+12 
0fd4					ld a, 0 
0fd4					ld (hl),a 
0fd4					ld a, display_row_4 
0fd4					ld de, LFSRSeed 
0fd4					call str_at_display 
0fd4					.skip_input_diag: 
0fd4				endif 
0fd4			 
0fd4					; decide on if we are showing the cursor this time round 
0fd4			 
0fd4 3a 62 fe				ld a, (input_cur_onoff) 
0fd7 fe ff				cp 255 
0fd9 28 13				jr z, .skipcur 
0fdb			 
0fdb			 
0fdb 3a 65 fe				ld a,(input_at_cursor) 
0fde 11 c7 fb				ld de, cursor_shape 
0fe1 cd 2b 0d				call str_at_display 
0fe4			 
0fe4					; save length of current input string 
0fe4 2a 6a fe				ld hl, (input_start) 
0fe7 cd aa 13				call strlenz 
0fea 7d					ld a,l 
0feb 32 5d fe				ld (input_len),a 
0fee			 
0fee			.skipcur: 
0fee			 
0fee cd 3b 0d			        call update_display 
0ff1					 
0ff1			 
0ff1			 
0ff1					; wait 
0ff1				 
0ff1					; TODO loop without wait to flash the cursor and char under cursor	 
0ff1 cd ba 73				call cin    ; _wait 
0ff4			 
0ff4 fe 00				cp 0 
0ff6 ca aa 0f				jp z, .is1 
0ff9			 
0ff9					; get ptr to char to input into 
0ff9			 
0ff9 4f					ld c,a 
0ffa 2a 6a fe				ld hl, (input_start) 
0ffd 3a 58 fe				ld a, (input_cursor) 
1000 cd 4c 0f				call addatohl 
1003 22 6c fe				ld (input_ptr), hl 
1006 79					ld a,c 
1007			 
1007					; replace char under cursor 
1007			 
1007			;		ld hl, (input_ptr) 
1007			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1007			;		ld (hl), a 
1007			 
1007			;	if DEBUG_INPUT 
1007			;		push af 
1007			;		ld a, 'i' 
1007			;		ld (debug_mark),a 
1007			;		pop af 
1007			;		CALLMONITOR 
1007			;	endif 
1007 fe 0e				cp KEY_HOME 
1009 20 0e				jr nz, .iske 
100b			 
100b 3a 67 fe				ld a, (input_at_pos) 
100e 32 65 fe				ld (input_at_cursor),a 
1011 3e 00				ld a, 0 
1013 32 58 fe				ld (input_cursor), a 
1016 c3 aa 0f				jp .is1 
1019					 
1019 fe 0f		.iske:		cp KEY_END 
101b 20 03				jr nz, .isknw 
101d c3 aa 0f				jp .is1 
1020			 
1020 fe 06		.isknw:		cp KEY_NEXTWORD 
1022 20 1b				jr nz, .iskpw 
1024			 
1024 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
1027 7e					ld a,(hl)	 
1028 fe 00				cp 0 
102a ca aa 0f				jp z, .is1    ; end of string 
102d fe 20				cp ' ' 
102f ca aa 0f				jp z, .is1    ; end of word 
1032 23					inc hl 
1033 22 6c fe				ld (input_ptr), hl 
1036 3a 65 fe				ld a, (input_at_cursor) 
1039 3c					inc a 
103a 32 65 fe				ld (input_at_cursor), a 
103d 18 e5				jr .isknwm 
103f			 
103f fe 07		.iskpw:		cp KEY_PREVWORD 
1041 20 1b				jr nz, .iskl 
1043			.iskpwm:	 
1043 2a 6c fe				ld hl, (input_ptr) 
1046 7e					ld a,(hl)	 
1047 fe 00				cp 0  
1049 ca aa 0f				jp z, .is1    ; end of string 
104c fe 20				cp ' ' 
104e ca aa 0f				jp z, .is1    ; end of word 
1051 2b					dec hl 
1052 22 6c fe				ld (input_ptr), hl 
1055 3a 65 fe				ld a, (input_at_cursor) 
1058 3d					dec a 
1059 32 65 fe				ld (input_at_cursor), a 
105c 18 e5				jr .iskpwm 
105e			 
105e			 
105e fe 0b		.iskl:		cp KEY_LEFT 
1060 20 27				jr nz, .isk1 
1062			 
1062 3a 58 fe				ld a, (input_cursor) 
1065			 
1065 fe 00				cp 0 
1067 ca aa 0f				jp z, .is1 		; at start of line to ignore  
106a			 
106a 3d					dec  a 		; TODO check underflow 
106b 32 58 fe				ld (input_cursor), a 
106e			 
106e 2a 6c fe				ld hl, (input_ptr) 
1071 2b					dec hl 
1072 22 6c fe				ld (input_ptr), hl 
1075					 
1075 3a 65 fe				ld a, (input_at_cursor) 
1078 3d					dec a 
1079 32 65 fe				ld (input_at_cursor), a 
107c			 
107c 3e 01				ld a, 1		; show cursor moving 
107e 32 62 fe				ld (input_cur_onoff),a 
1081 3e 0f				ld a, CUR_BLINK_RATE 
1083 32 63 fe				ld (input_cur_flash), a 
1086			 
1086 c3 aa 0f				jp .is1 
1089			 
1089 fe 0c		.isk1:		cp KEY_RIGHT 
108b 20 2a				jr nz, .isk2 
108d			 
108d 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1090 5f					ld e,a 
1091 3a 58 fe				ld a, (input_cursor) 
1094 bb					cp e 
1095 ca aa 0f				jp z, .is1		; at the end of string so dont go right 
1098			 
1098 3c					inc  a 		; TODO check overflow 
1099 32 58 fe				ld (input_cursor), a 
109c			 
109c 3a 65 fe				ld a, (input_at_cursor) 
109f 3c					inc a 
10a0 32 65 fe				ld (input_at_cursor), a 
10a3			 
10a3 2a 6c fe				ld hl, (input_ptr) 
10a6 23					inc hl 
10a7 22 6c fe				ld (input_ptr), hl 
10aa			 
10aa 3e 01				ld a, 1		; show cursor moving 
10ac 32 62 fe				ld (input_cur_onoff),a 
10af 3e 0f				ld a, CUR_BLINK_RATE 
10b1 32 63 fe				ld (input_cur_flash), a 
10b4			 
10b4 c3 aa 0f				jp .is1 
10b7			 
10b7 fe 05		.isk2:		cp KEY_UP 
10b9			 
10b9 20 26				jr nz, .isk3 
10bb			 
10bb					; swap last command with the current on 
10bb			 
10bb					; move cursor to start of string 
10bb 2a 6a fe				ld hl, (input_start) 
10be 22 6c fe				ld (input_ptr), hl 
10c1			 
10c1 3a 67 fe				ld a, (input_at_pos) 
10c4 32 65 fe				ld (input_at_cursor), a 
10c7			 
10c7 3e 00				ld a, 0 
10c9 32 58 fe				ld (input_cursor), a 
10cc					 
10cc					; swap input and last command buffers 
10cc			 
10cc 21 ef f4				ld hl, os_cli_cmd 
10cf 11 ee f5				ld de, os_last_cmd 
10d2 06 ff				ld b, 255 
10d4 7e			.swap1:		ld a, (hl) 
10d5 4f					ld c,a 
10d6 1a					ld a, (de) 
10d7 77					ld (hl), a 
10d8 79					ld a,c 
10d9 12					ld (de),a 
10da 23					inc hl 
10db 13					inc de 
10dc 10 f6				djnz .swap1 
10de			 
10de			 
10de			 
10de			 
10de			 
10de c3 aa 0f				jp .is1 
10e1			 
10e1 fe 08		.isk3:		cp KEY_BS 
10e3 20 3c				jr nz, .isk4 
10e5			 
10e5 3a 58 fe				ld a, (input_cursor) 
10e8			 
10e8 fe 00				cp 0 
10ea ca aa 0f				jp z, .is1 		; at start of line to ignore  
10ed			 
10ed 3d					dec  a 		; TODO check underflow 
10ee 32 58 fe				ld (input_cursor), a 
10f1			 
10f1					; hl is source 
10f1					; de needs to be source - 1 
10f1			 
10f1			;		ld a, 0 
10f1			;		dec hl 
10f1			;		ld (hl), a 
10f1			 
10f1 2a 6c fe				ld hl, (input_ptr) 
10f4 2b					dec hl 
10f5 22 6c fe				ld (input_ptr), hl 
10f8			 
10f8					; shift all data 
10f8			 
10f8 e5					push hl 
10f9 23					inc hl 
10fa d1					pop de 
10fb 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10fe 4f					ld c,a 
10ff 06 00				ld b,0 
1101 ed b0				ldir  
1103			 
1103			 
1103			 
1103			 
1103 3a 65 fe				ld a, (input_at_cursor) 
1106 3d					dec a 
1107 32 65 fe				ld (input_at_cursor), a 
110a			 
110a			 
110a 3e 01				ld a, 1		; show cursor moving 
110c 32 62 fe				ld (input_cur_onoff),a 
110f 3e 0f				ld a, CUR_BLINK_RATE 
1111 32 63 fe				ld (input_cur_flash), a 
1114			 
1114					; remove char 
1114 3a 65 fe				ld a, (input_at_cursor) 
1117 3c					inc a 
1118 11 a2 11				ld de,.iblank 
111b cd 2b 0d				call str_at_display 
111e			 
111e c3 aa 0f				jp .is1 
1121			 
1121 fe 0d		.isk4:		cp KEY_CR 
1123 28 6c				jr z, .endinput 
1125			 
1125					; else add the key press to the end 
1125			 
1125 4f					ld c, a			; save key pressed 
1126			 
1126 7e					ld a,(hl)		; get what is currently under char 
1127			 
1127 fe 00				cp 0			; we are at the end of the string 
1129 20 2f				jr nz, .onchar 
112b					 
112b					; add a char to the end of the string 
112b				 
112b 71					ld (hl),c 
112c 23					inc hl 
112d			;		ld a,' ' 
112d			;		ld (hl),a 
112d			;		inc hl 
112d 3e 00				ld a,0 
112f 77					ld (hl),a 
1130 2b					dec hl 
1131			 
1131 3a 58 fe				ld a, (input_cursor) 
1134 3c					inc a				; TODO check max string length and scroll  
1135 32 58 fe				ld (input_cursor), a		; inc cursor pos 
1138							 
1138 3a 65 fe				ld a, (input_at_cursor) 
113b 3c					inc a 
113c 32 65 fe				ld (input_at_cursor), a 
113f			 
113f 2a 6c fe				ld hl, (input_ptr) 
1142 23					inc hl 
1143 22 6c fe				ld (input_ptr), hl 
1146			 
1146 2a 6c fe				ld hl, (input_ptr) 
1149 23					inc hl 
114a 22 6c fe				ld (input_ptr), hl 
114d			;	if DEBUG_INPUT 
114d			;		push af 
114d			;		ld a, '+' 
114d			;		ld (debug_mark),a 
114d			;		pop af 
114d			;		CALLMONITOR 
114d			;	endif 
114d 3e 01				ld a, 1		; show cursor moving 
114f 32 62 fe				ld (input_cur_onoff),a 
1152 3e 0f				ld a, CUR_BLINK_RATE 
1154 32 63 fe				ld (input_cur_flash), a 
1157 c3 aa 0f				jp .is1 
115a					 
115a			 
115a			 
115a					; if on a char then insert 
115a			.onchar: 
115a			 
115a					; TODO over flow check: make sure insert does not blow out buffer 
115a			 
115a					; need to do some maths to use lddr 
115a			 
115a e5					push hl   ; save char pos 
115b c5					push bc 
115c			 
115c 2a 6a fe				ld hl, (input_start) 
115f 3a 5d fe				ld a, (input_len) 
1162 cd 4c 0f				call addatohl  		; end of string 
1165 23					inc hl 
1166 23					inc hl		; past zero term 
1167 e5					push hl 
1168 23					inc hl 
1169 e5					push hl  
116a			 
116a								; start and end of lddr set, now how much to move? 
116a			 
116a							 
116a 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
116d 47					ld b,a 
116e 3a 5d fe				ld a,(input_len) 
1171 5f					ld e,a 
1172 90					sub b 
1173 3c					inc a		;?? 
1174 3c					inc a		;?? 
1175 3c					inc a		;?? 
1176			 
1176 06 00				ld b,0 
1178 4f					ld c,a 
1179			 
1179				if DEBUG_INPUT 
1179					push af 
1179					ld a, 'i' 
1179					ld (debug_mark),a 
1179					pop af 
1179			;		CALLMONITOR 
1179				endif 
1179 d1					pop de 
117a e1					pop hl 
117b				if DEBUG_INPUT 
117b					push af 
117b					ld a, 'I' 
117b					ld (debug_mark),a 
117b					pop af 
117b			;		CALLMONITOR 
117b				endif 
117b ed b8				lddr 
117d				 
117d			 
117d			 
117d					; TODO have a key for insert/overwrite mode???? 
117d c1					pop bc 
117e e1					pop hl 
117f 71					ld (hl), c		; otherwise overwrite current char 
1180					 
1180			 
1180			 
1180			 
1180 3a 58 fe				ld a, (input_cursor) 
1183 3c					inc  a 		; TODO check overflow 
1184 32 58 fe				ld (input_cursor), a 
1187			 
1187 3a 65 fe				ld a, (input_at_cursor) 
118a 3c					inc a 
118b 32 65 fe				ld (input_at_cursor), a 
118e			 
118e c3 aa 0f				jp .is1 
1191			 
1191			.endinput:	; TODO look for end of string 
1191			 
1191					; add trailing space for end of token 
1191			 
1191 2a 6a fe				ld hl, (input_start) 
1194 3a 5d fe				ld a,(input_len) 
1197 cd 4c 0f				call addatohl 
119a 3e 20				ld a, ' ' 
119c 77					ld (hl),a 
119d					; TODO eof of parse marker 
119d			 
119d 23					inc hl 
119e 3e 00				ld a, 0 
11a0 77					ld (hl),a 
11a1			 
11a1			 
11a1 c9					ret 
11a2			 
11a2 .. 00		.iblank: db " ",0 
11a4			 
11a4			 
11a4 32 67 fe		input_str_prev:	ld (input_at_pos), a 
11a7 22 6a fe				ld (input_start), hl 
11aa 3e 01				ld a,1			; add cursor 
11ac 77					ld (hl),a 
11ad 23					inc hl 
11ae 3e 00				ld a,0 
11b0 77					ld (hl),a 
11b1 22 6c fe				ld (input_ptr), hl 
11b4 7a					ld a,d 
11b5 32 69 fe				ld (input_size), a 
11b8 3e 00				ld a,0 
11ba 32 58 fe				ld (input_cursor),a 
11bd			.instr1:	 
11bd			 
11bd					; TODO do block cursor 
11bd					; TODO switch cursor depending on the modifer key 
11bd			 
11bd					; update cursor shape change on key hold 
11bd			 
11bd 2a 6c fe				ld hl, (input_ptr) 
11c0 2b					dec hl 
11c1 3a c7 fb				ld a,(cursor_shape) 
11c4 77					ld (hl), a 
11c5			 
11c5					; display entered text 
11c5 3a 67 fe				ld a,(input_at_pos) 
11c8 cd 7e 71		            	CALL fLCD_Pos       ;Position cursor to location in A 
11cb ed 5b 6a fe	            	LD   de, (input_start) 
11cf cd a0 71		            	CALL fLCD_Str       ;Display string pointed to by DE 
11d2			 
11d2 cd ba 73				call cin 
11d5 fe 00				cp 0 
11d7 28 e4				jr z, .instr1 
11d9			 
11d9					; proecess keyboard controls first 
11d9			 
11d9 2a 6c fe				ld hl,(input_ptr) 
11dc			 
11dc fe 0d				cp KEY_CR	 ; pressing enter ends input 
11de 28 5a				jr z, .instrcr 
11e0			 
11e0 fe 08				cp KEY_BS 	; back space 
11e2 20 0f				jr nz, .instr2 
11e4					; process back space 
11e4			 
11e4					; TODO stop back space if at start of string 
11e4 2b					dec hl 
11e5 2b					dec hl ; to over write cursor 
11e6 3a c7 fb				ld a,(cursor_shape) 
11e9					;ld a,0 
11e9 77					ld (hl),a 
11ea 23					inc hl 
11eb 3e 20				ld a," " 
11ed 77					ld (hl),a 
11ee 22 6c fe				ld (input_ptr),hl 
11f1					 
11f1			 
11f1 18 ca				jr .instr1 
11f3			 
11f3 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11f5 20 06				jr nz, .instr3 
11f7 2b					dec hl 
11f8 22 6c fe				ld (input_ptr),hl 
11fb 18 c0				jr .instr1 
11fd				 
11fd fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11ff 20 06				jr nz, .instr4 
1201 23					inc hl 
1202 22 6c fe				ld (input_ptr),hl 
1205 18 b6				jr .instr1 
1207			 
1207 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1209 20 06				jr nz, .instr5 
120b 2b					dec hl 
120c 22 6c fe				ld (input_ptr),hl 
120f 18 ac				jr .instr1 
1211			 
1211 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1213 20 06				jr nz, .instr6 
1215 2b					dec hl 
1216 22 6c fe				ld (input_ptr),hl 
1219 18 a2				jr .instr1 
121b fe 05		.instr6:        cp KEY_UP      ; recall last command 
121d 20 0b				jr nz, .instrnew 
121f			 
121f 21 c8 f1			ld hl, scratch 
1222 11 ee f5			ld de, os_last_cmd 
1225 cd 43 12			call strcpy 
1228 18 93				jr .instr1 
122a			 
122a			 
122a			.instrnew:	; no special key pressed to see if we have room to store it 
122a			 
122a					; TODO do string size test 
122a			 
122a 2b					dec hl ; to over write cursor 
122b 77					ld (hl),a 
122c 23					inc hl 
122d 3a c7 fb				ld a,(cursor_shape) 
1230 77					ld (hl),a 
1231 23					inc hl 
1232 3e 00				ld a,0 
1234 77					ld (hl),a 
1235			 
1235 22 6c fe				ld (input_ptr),hl 
1238					 
1238 18 83				jr .instr1 
123a 2b			.instrcr:	dec hl		; remove cursor 
123b 3e 20				ld a,' '	; TODO add a trailing space for safety 
123d 77					ld (hl),a 
123e 23					inc hl 
123f 3e 00				ld a,0 
1241 77					ld (hl),a 
1242			 
1242			 
1242					; if at end of line scroll up    
1242					; TODO detecting only end of line 4 for scroll up  
1242			 
1242					;ld   
1242			 
1242 c9					ret 
1243			 
1243			 
1243			; strcpy hl = dest, de source 
1243			 
1243 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1244 b7			            OR   A              ;Null terminator? 
1245 c8			            RET  Z              ;Yes, so finished 
1246 1a					ld a,(de) 
1247 77					ld (hl),a 
1248 13			            INC  DE             ;Point to next character 
1249 23					inc hl 
124a 18 f7		            JR   strcpy       ;Repeat 
124c c9					ret 
124d			 
124d			 
124d			; TODO string_at  
124d			; pass string which starts with lcd offset address and then null term string 
124d			 
124d			; TODO string to dec 
124d			; TODO string to hex 
124d			; TODO byte to string hex 
124d			; TODO byte to string dec 
124d			 
124d			 
124d			 
124d			; from z80uartmonitor 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
124d			; pass hl for where to put the text 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d c5			hexout:	PUSH BC 
124e f5					PUSH AF 
124f 47					LD B, A 
1250					; Upper nybble 
1250 cb 3f				SRL A 
1252 cb 3f				SRL A 
1254 cb 3f				SRL A 
1256 cb 3f				SRL A 
1258 cd 68 12				CALL tohex 
125b 77					ld (hl),a 
125c 23					inc hl	 
125d					 
125d					; Lower nybble 
125d 78					LD A, B 
125e e6 0f				AND 0FH 
1260 cd 68 12				CALL tohex 
1263 77					ld (hl),a 
1264 23					inc hl	 
1265					 
1265 f1					POP AF 
1266 c1					POP BC 
1267 c9					RET 
1268					 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			tohex: 
1268 e5					PUSH HL 
1269 d5					PUSH DE 
126a 16 00				LD D, 0 
126c 5f					LD E, A 
126d 21 75 12				LD HL, .DATA 
1270 19					ADD HL, DE 
1271 7e					LD A, (HL) 
1272 d1					POP DE 
1273 e1					POP HL 
1274 c9					RET 
1275			 
1275			.DATA: 
1275 30					DEFB	30h	; 0 
1276 31					DEFB	31h	; 1 
1277 32					DEFB	32h	; 2 
1278 33					DEFB	33h	; 3 
1279 34					DEFB	34h	; 4 
127a 35					DEFB	35h	; 5 
127b 36					DEFB	36h	; 6 
127c 37					DEFB	37h	; 7 
127d 38					DEFB	38h	; 8 
127e 39					DEFB	39h	; 9 
127f 41					DEFB	41h	; A 
1280 42					DEFB	42h	; B 
1281 43					DEFB	43h	; C 
1282 44					DEFB	44h	; D 
1283 45					DEFB	45h	; E 
1284 46					DEFB	46h	; F 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1285			;;    subtract $30, if result > 9 then subtract $7 more 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			atohex: 
1285 d6 30				SUB $30 
1287 fe 0a				CP 10 
1289 f8					RET M		; If result negative it was 0-9 so we're done 
128a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
128c c9					RET		 
128d			 
128d			 
128d			 
128d			 
128d			; Get 2 ASCII characters as hex byte from pointer in hl 
128d			 
128d			BYTERD: 
128d 16 00			LD	D,00h		;Set up 
128f cd 97 12			CALL	HEXCON		;Get byte and convert to hex 
1292 87				ADD	A,A		;First nibble so 
1293 87				ADD	A,A		;multiply by 16 
1294 87				ADD	A,A		; 
1295 87				ADD	A,A		; 
1296 57				LD	D,A		;Save hi nibble in D 
1297			HEXCON: 
1297 7e				ld a, (hl)		;Get next chr 
1298 23				inc hl 
1299 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
129b fe 0a			CP	00Ah		;Is it 0-9 ? 
129d 38 02			JR	C,NALPHA	;If so miss next bit 
129f d6 07			SUB	007h		;Else convert alpha 
12a1			NALPHA: 
12a1 b2				OR	D		;Add hi nibble back 
12a2 c9				RET			; 
12a3			 
12a3			 
12a3			; 
12a3			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12a3			; Since the routines get_byte and therefore get_nibble are called, only valid 
12a3			; characters (0-9a-f) are accepted. 
12a3			; 
12a3			;get_word        push    af 
12a3			;                call    get_byte        ; Get the upper byte 
12a3			;                ld      h, a 
12a3			;                call    get_byte        ; Get the lower byte 
12a3			;                ld      l, a 
12a3			;                pop     af 
12a3			;                ret 
12a3			; 
12a3			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12a3			; the routine get_nibble is used only valid characters are accepted - the  
12a3			; input routine only accepts characters 0-9a-f. 
12a3			; 
12a3 c5			get_byte:        push    bc              ; Save contents of B (and C) 
12a4 7e					ld a,(hl) 
12a5 23					inc hl 
12a6 cd cb 12		                call    nibble2val      ; Get upper nibble 
12a9 cb 07		                rlc     a 
12ab cb 07		                rlc     a 
12ad cb 07		                rlc     a 
12af cb 07		                rlc     a 
12b1 47			                ld      b, a            ; Save upper four bits 
12b2 7e					ld a,(hl) 
12b3 cd cb 12		                call    nibble2val      ; Get lower nibble 
12b6 b0			                or      b               ; Combine both nibbles 
12b7 c1			                pop     bc              ; Restore B (and C) 
12b8 c9			                ret 
12b9			; 
12b9			; Get a hexadecimal digit from the serial line. This routine blocks until 
12b9			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12b9			; to the serial line interface. The lower 4 bits of A contain the value of  
12b9			; that particular digit. 
12b9			; 
12b9			;get_nibble      ld a,(hl)           ; Read a character 
12b9			;                call    to_upper        ; Convert to upper case 
12b9			;                call    is_hex          ; Was it a hex digit? 
12b9			;                jr      nc, get_nibble  ; No, get another character 
12b9			 ;               call    nibble2val      ; Convert nibble to value 
12b9			 ;               call    print_nibble 
12b9			 ;               ret 
12b9			; 
12b9			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12b9			; A valid hexadecimal digit is denoted by a set C flag. 
12b9			; 
12b9			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12b9			;                ret     nc              ; Yes 
12b9			;                cp      '0'             ; Less than '0'? 
12b9			;                jr      nc, is_hex_1    ; No, continue 
12b9			;                ccf                     ; Complement carry (i.e. clear it) 
12b9			;                ret 
12b9			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12b9			;                ret     c               ; Yes 
12b9			;                cp      'A'             ; Less than 'A'? 
12b9			;                jr      nc, is_hex_2    ; No, continue 
12b9			;                ccf                     ; Yes - clear carry and return 
12b9			;                ret 
12b9			;is_hex_2        scf                     ; Set carry 
12b9			;                ret 
12b9			; 
12b9			; Convert a single character contained in A to upper case: 
12b9			; 
12b9 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12bb d8			                ret     c 
12bc fe 7b		                cp      'z' + 1         ; > 'z'? 
12be d0			                ret     nc              ; Nothing to do, either 
12bf e6 5f		                and     $5f             ; Convert to upper case 
12c1 c9			                ret 
12c2			 
12c2			 
12c2			to_lower: 
12c2			 
12c2			   ; if char is in [A-Z] make it lower case 
12c2			 
12c2			   ; enter : a = char 
12c2			   ; exit  : a = lower case char 
12c2			   ; uses  : af 
12c2			 
12c2 fe 41		   cp 'A' 
12c4 d8			   ret c 
12c5			    
12c5 fe 5b		   cp 'Z'+1 
12c7 d0			   ret nc 
12c8			    
12c8 f6 20		   or $20 
12ca c9			   ret 
12cb			 
12cb			; 
12cb			; Expects a hexadecimal digit (upper case!) in A and returns the 
12cb			; corresponding value in A. 
12cb			; 
12cb fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12cd 38 02		                jr      c, nibble2val_1 ; Yes 
12cf d6 07		                sub     7               ; Adjust for A-F 
12d1 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12d3 e6 0f		                and     $f              ; Only return lower 4 bits 
12d5 c9			                ret 
12d6			; 
12d6			; Print_nibble prints a single hex nibble which is contained in the lower  
12d6			; four bits of A: 
12d6			; 
12d6			;print_nibble    push    af              ; We won't destroy the contents of A 
12d6			;                and     $f              ; Just in case... 
12d6			;                add     a, '0'             ; If we have a digit we are done here. 
12d6			;                cp      '9' + 1         ; Is the result > 9? 
12d6			;                jr      c, print_nibble_1 
12d6			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12d6			;print_nibble_1  call    putc            ; Print the nibble and 
12d6			;                pop     af              ; restore the original value of A 
12d6			;                ret 
12d6			;; 
12d6			;; Send a CR/LF pair: 
12d6			; 
12d6			;crlf            push    af 
12d6			;                ld      a, cr 
12d6			;                call    putc 
12d6			;                ld      a, lf 
12d6			;                call    putc 
12d6			;                pop     af 
12d6			;                ret 
12d6			; 
12d6			; Print_word prints the four hex digits of a word to the serial line. The  
12d6			; word is expected to be in HL. 
12d6			; 
12d6			;print_word      push    hl 
12d6			;                push    af 
12d6			;                ld      a, h 
12d6			;                call    print_byte 
12d6			;                ld      a, l 
12d6			;                call    print_byte 
12d6			;                pop     af 
12d6			;                pop     hl 
12d6			;                ret 
12d6			; 
12d6			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12d6			; The byte to be printed is expected to be in A. 
12d6			; 
12d6			;print_byte      push    af              ; Save the contents of the registers 
12d6			;                push    bc 
12d6			;                ld      b, a 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                call    print_nibble    ; Print high nibble 
12d6			;                ld      a, b 
12d6			;                call    print_nibble    ; Print low nibble 
12d6			;                pop     bc              ; Restore original register contents 
12d6			;                pop     af 
12d6			;                ret 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			fourehexhl:  
12d6 7e				ld a,(hl) 
12d7 cd 85 12			call atohex 
12da cb 3f				SRL A 
12dc cb 3f				SRL A 
12de cb 3f				SRL A 
12e0 cb 3f				SRL A 
12e2 47				ld b, a 
12e3 23				inc hl 
12e4 7e				ld a,(hl) 
12e5 23				inc hl 
12e6 cd 85 12			call atohex 
12e9 80				add b 
12ea 57				ld d,a 
12eb 7e				ld a,(hl) 
12ec cd 85 12			call atohex 
12ef cb 3f				SRL A 
12f1 cb 3f				SRL A 
12f3 cb 3f				SRL A 
12f5 cb 3f				SRL A 
12f7 47				ld b, a 
12f8 23				inc hl 
12f9 7e				ld a,(hl) 
12fa 23				inc hl 
12fb cd 85 12			call atohex 
12fe 80				add b 
12ff 5f				ld e, a 
1300 d5				push de 
1301 e1				pop hl 
1302 c9				ret 
1303			 
1303			; pass hl. returns z set if the byte at hl is a digit 
1303			;isdigithl:  
1303			;	push bc 
1303			;	ld a,(hl) 
1303			;	cp ':' 
1303			;	jr nc, .isdf 		; > 
1303			;	cp '0' 
1303			;	jr c, .isdf		; < 
1303			; 
1303			;	; TODO find a better way to set z 
1303			; 
1303			;	ld b,a 
1303			;	cp b 
1303			;	pop bc 
1303			;	ret 
1303			; 
1303			;.isdf:	; not digit so clear z 
1303			; 
1303			;	; TODO find a better way to unset z 
1303			; 
1303			;	ld b,a 
1303			;	inc b 
1303			;	cp b 
1303			; 
1303			;	pop bc 
1303			;	ret 
1303				 
1303				 
1303			 
1303			 
1303			; pass hl as the four byte address to load 
1303			 
1303			get_word_hl:  
1303 e5				push hl 
1304 cd a3 12			call get_byte 
1307				 
1307 47				ld b, a 
1308			 
1308 e1				pop hl 
1309 23				inc hl 
130a 23				inc hl 
130b			 
130b			; TODO not able to handle a-f  
130b 7e				ld a,(hl) 
130c			;	;cp ':' 
130c			;	cp 'g' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp 'G' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp '0' 
130c			;	jr c, .single_byte_hl		; < 
130c			 
130c				;call isdigithl 
130c fe 00			cp 0 
130e 28 06			jr z, .single_byte_hl 
1310			 
1310			.getwhln:   ; hex word so get next byte 
1310			 
1310 cd a3 12			call get_byte 
1313 6f				ld l, a 
1314 60				ld h,b 
1315 c9				ret 
1316 68			.single_byte_hl:   ld l,b 
1317 26 00				ld h,0 
1319 c9					ret 
131a			 
131a			 
131a			 
131a			 
131a 21 7e 1c			ld hl,asc+1 
131d			;	ld a, (hl) 
131d			;	call nibble2val 
131d cd a3 12			call get_byte 
1320			 
1320			;	call fourehexhl 
1320 32 fc f1			ld (scratch+52),a 
1323				 
1323 21 fa f1			ld hl,scratch+50 
1326 22 eb f4			ld (os_cur_ptr),hl 
1329			 
1329 c9				ret 
132a			 
132a			 
132a			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
132a			 
132a			; Decimal Unsigned Version 
132a			 
132a			;Number in a to decimal ASCII 
132a			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
132a			;Example: display a=56 as "056" 
132a			;input: a = number 
132a			;Output: a=0,value of a in the screen 
132a			;destroys af,bc (don't know about hl and de) 
132a			DispAToASCII: 
132a 0e 9c			ld	c,-100 
132c cd 36 13			call	.Na1 
132f 0e f6			ld	c,-10 
1331 cd 36 13			call	.Na1 
1334 0e ff			ld	c,-1 
1336 06 2f		.Na1:	ld	b,'0'-1 
1338 04			.Na2:	inc	b 
1339 81				add	a,c 
133a 38 fc			jr	c,.Na2 
133c 91				sub	c		;works as add 100/10/1 
133d f5				push af		;safer than ld c,a 
133e 78				ld	a,b		;char is in b 
133f			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
133f f1				pop af		;safer than ld a,c 
1340 c9				ret 
1341			 
1341			; Decimal Signed Version 
1341			 
1341			; DispA 
1341			; -------------------------------------------------------------- 
1341			; Converts a signed integer value to a zero-terminated ASCII 
1341			; string representative of that value (using radix 10). 
1341			; -------------------------------------------------------------- 
1341			; INPUTS: 
1341			;     HL     Value to convert (two's complement integer). 
1341			;     DE     Base address of string destination. (pointer). 
1341			; -------------------------------------------------------------- 
1341			; OUTPUTS: 
1341			;     None 
1341			; -------------------------------------------------------------- 
1341			; REGISTERS/MEMORY DESTROYED 
1341			; AF HL 
1341			; -------------------------------------------------------------- 
1341			 
1341			;DispHLToASCII: 
1341			;   push    de 
1341			;   push    bc 
1341			; 
1341			;; Detect sign of HL. 
1341			;    bit    7, h 
1341			;    jr     z, ._DoConvert 
1341			; 
1341			;; HL is negative. Output '-' to string and negate HL. 
1341			;    ld     a, '-' 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			; 
1341			;; Negate HL (using two's complement) 
1341			;    xor    a 
1341			;    sub    l 
1341			;    ld     l, a 
1341			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1341			;    sbc    a, h 
1341			;    ld     h, a 
1341			; 
1341			;; Convert HL to digit characters 
1341			;._DoConvert: 
1341			;    ld     b, 0     ; B will count character length of number 
1341			;-   ld     a, 10 
1341			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1341			;    push   af 
1341			;    inc    b 
1341			;    ld     a, h 
1341			;    or     l 
1341			;    jr     nz, - 
1341			; 
1341			;; Retrieve digits from stack 
1341			;-   pop    af 
1341			;    or     $30 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			;    djnz   - 
1341			; 
1341			;; Terminate string with NULL 
1341			;    xor    a 
1341			;    ld     (de), a 
1341			; 
1341			;    pop    bc 
1341			;    pop    de 
1341			;    ret 
1341			 
1341			;Comments 
1341			; 
1341			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1341			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1341			;    Note that the output string will not be fixed-width. 
1341			; 
1341			;Example Usage 
1341			; 
1341			;    ld    hl, -1004 
1341			;    ld    de, OP1 
1341			;    call  DispA 
1341			;    ld    hl, OP1 
1341			;    syscall  PutS 
1341			 
1341			 
1341			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1341			 
1341			 
1341			;Converts an ASCII string to an unsigned 16-bit integer 
1341			;Quits when it reaches a non-decimal digit 
1341			 
1341			string_to_uint16: 
1341			atoui_16: 
1341			;Input: 
1341			;     DE points to the string 
1341			;Outputs: 
1341			;     HL is the result 
1341			;     A is the 8-bit value of the number 
1341			;     DE points to the byte after the number 
1341			;Destroys: 
1341			;     BC 
1341			;       if the string is non-empty, BC is HL/10 
1341			;Size:  24 bytes 
1341			;Speed: 42+d(104+{0,9}) 
1341			;       d is the number of digits in the number 
1341			;       max is 640 cycles for a 5 digit number 
1341			;Assuming no leading zeros: 
1341			;1 digit:  146cc 
1341			;2 digit:  250cc 
1341			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1341			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1341			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1341			;avg: 544.81158447265625cc (544+13297/16384) 
1341			;=============================================================== 
1341 21 00 00		  ld hl,0 
1344			.u16a: 
1344 1a			  ld a,(de) 
1345 d6 30		  sub 30h 
1347 fe 0a		  cp 10 
1349 d0			  ret nc 
134a 13			  inc de 
134b 44			  ld b,h 
134c 4d			  ld c,l 
134d 29			  add hl,hl 
134e 29			  add hl,hl 
134f 09			  add hl,bc 
1350 29			  add hl,hl 
1351 85			  add a,l 
1352 6f			  ld l,a 
1353 30 ef		  jr nc,.u16a 
1355 24			  inc h 
1356 c3 44 13		  jp .u16a 
1359			 
1359			 
1359			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1359			 
1359			;written by Zeda 
1359			;Converts a 16-bit unsigned integer to an ASCII string. 
1359			 
1359			uitoa_16: 
1359			;Input: 
1359			;   DE is the number to convert 
1359			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1359			;Output: 
1359			;   HL points to the null-terminated ASCII string 
1359			;      NOTE: This isn't necessarily the same as the input HL. 
1359 d5			  push de 
135a c5			  push bc 
135b f5			  push af 
135c eb			  ex de,hl 
135d			 
135d 01 f0 d8		  ld bc,-10000 
1360 3e 2f		  ld a,'0'-1 
1362 3c			  inc a 
1363 09			  add hl,bc  
1364 38 fc		   jr c,$-2 
1366 12			  ld (de),a 
1367 13			  inc de 
1368			 
1368 01 e8 03		  ld bc,1000 
136b 3e 3a		  ld a,'9'+1 
136d 3d			  dec a  
136e 09			  add hl,bc  
136f 30 fc		   jr nc,$-2 
1371 12			  ld (de),a 
1372 13			  inc de 
1373			 
1373 01 9c ff		  ld bc,-100 
1376 3e 2f		  ld a,'0'-1 
1378 3c			  inc a  
1379 09			  add hl,bc  
137a 38 fc		   jr c,$-2 
137c 12			  ld (de),a 
137d 13			  inc de 
137e			 
137e 7d			  ld a,l 
137f 26 3a		  ld h,'9'+1 
1381 25			  dec h  
1382 c6 0a		  add a,10  
1384 30 fb		   jr nc,$-3 
1386 c6 30		  add a,'0' 
1388 eb			  ex de,hl 
1389 72			  ld (hl),d 
138a 23			  inc hl 
138b 77			  ld (hl),a 
138c 23			  inc hl 
138d 36 00		  ld (hl),0 
138f			 
138f			;Now strip the leading zeros 
138f 0e fa		  ld c,-6 
1391 09			  add hl,bc 
1392 3e 30		  ld a,'0' 
1394 23			  inc hl  
1395 be			  cp (hl)  
1396 28 fc		  jr z,$-2 
1398			 
1398			;Make sure that the string is non-empty! 
1398 7e			  ld a,(hl) 
1399 b7			  or a 
139a 20 01		  jr nz,.atoub 
139c 2b			  dec hl 
139d			.atoub: 
139d			 
139d f1			  pop af 
139e c1			  pop bc 
139f d1			  pop de 
13a0 c9			  ret 
13a1			 
13a1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
13a1			 
13a1			toUpper: 
13a1			;A is the char. 
13a1			;If A is a lowercase letter, this sets it to the matching uppercase 
13a1			;18cc or 30cc or 41cc 
13a1			;avg: 26.75cc 
13a1 fe 61		  cp 'a' 
13a3 d8			  ret c 
13a4 fe 7b		  cp 'z'+1 
13a6 d0			  ret nc 
13a7 d6 20		  sub 'a'-'A' 
13a9 c9			  ret 
13aa			 
13aa			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13aa			 
13aa			; String Length 
13aa			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13aa			 
13aa			; Get the length of the null-terminated string starting at $8000 hl 
13aa			;    LD     HL, $8000 
13aa			 
13aa			strlenz: 
13aa			 
13aa af			    XOR    A               ; Zero is the value we are looking for. 
13ab 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13ac 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13ad			                           ; 65, 536 bytes (the entire addressable memory space). 
13ad ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13af			 
13af			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13af 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13b0 6f			    LD     L, A             ; number of bytes 
13b1 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13b3 2b			    DEC    HL              ; Compensate for null. 
13b4 c9				ret 
13b5			 
13b5			; Get the length of the A terminated string starting at $8000 hl 
13b5			;    LD     HL, $8000 
13b5			 
13b5			strlent: 
13b5			 
13b5			                  ; A is the value we are looking for. 
13b5 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13b7 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13b9			                           ; 65, 536 bytes (the entire addressable memory space). 
13b9 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13bb			 
13bb			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13bb 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13bd 2e 00		    LD     L, 0             ; number of bytes 
13bf ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13c1 2b			    DEC    HL              ; Compensate for null. 
13c2 c9				ret 
13c3			 
13c3			 
13c3			;Comparing Strings 
13c3			 
13c3			;IN    HL     Address of string1. 
13c3			;      DE     Address of string2. 
13c3			 
13c3			; doc given but wrong??? 
13c3			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13c3			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13c3			; tested 
13c3			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13c3			 
13c3			strcmp_old: 
13c3 e5			    PUSH   HL 
13c4 d5			    PUSH   DE 
13c5			 
13c5 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13c6 be			    CP     (HL)            ; (want to minimize work). 
13c7 38 01		    JR     C, Str1IsBigger 
13c9 7e			    LD     A, (HL) 
13ca			 
13ca			Str1IsBigger: 
13ca 4f			    LD     C, A             ; Put length in BC 
13cb 06 00		    LD     B, 0 
13cd 13			    INC    DE              ; Increment pointers to meat of string. 
13ce 23			    INC    HL 
13cf			 
13cf			CmpLoop: 
13cf 1a			    LD     A, (DE)          ; Compare bytes. 
13d0 ed a1		    CPI 
13d2 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13d4 13			    INC    DE              ; Update pointer. 
13d5 ea cf 13		    JP     PE, CmpLoop 
13d8			 
13d8 d1			    POP    DE 
13d9 e1			    POP    HL 
13da 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13db be			    CP     (HL) 
13dc c9			    RET 
13dd			 
13dd			NoMatch: 
13dd 2b			    DEC    HL 
13de be			    CP     (HL)            ; Compare again to affect carry. 
13df d1			    POP    DE 
13e0 e1			    POP    HL 
13e1 c9			    RET 
13e2			 
13e2			;; test strmp 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr z, .z1 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z1: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr z, .z2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr c, .c1 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c1: 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr c, .c2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;	NEXTW 
13e2			;.str1:   db "string1",0 
13e2			;.str2:   db "string2",0 
13e2			 
13e2			; only care about direct match or not 
13e2			; hl and de strings 
13e2			; zero set if the same 
13e2			 
13e2			strcmp: 
13e2 1a				ld a, (de) 
13e3 be				cp (hl) 
13e4 28 02			jr z, .ssame 
13e6 b7				or a 
13e7 c9				ret 
13e8			 
13e8			.ssame:  
13e8 fe 00			cp 0 
13ea c8				ret z 
13eb			 
13eb 23				inc hl 
13ec 13				inc de 
13ed 18 f3			jr strcmp 
13ef				 
13ef				 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			; eof 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
# End of file firmware_strings.asm
13ef			include "firmware_memory.asm"   ; malloc and free  
13ef			 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			.mallocsize: db "Wants malloc >256",0 
13ef			.mallocasize: db "MALLOC gives >256",0 
13ef			.malloczero: db "MALLOC gives zero",0 
13ef			 
13ef			malloc_guard_zerolen: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef				ld de, 0 
13ef			        call cmp16 
13ef				jr nz, .lowalloz 
13ef			 
13ef				push hl 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .malloczero 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef			.lowalloz: 
13ef			 
13ef			 
13ef				pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_entry: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowalloc 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocsize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdone 
13ef			.lowalloc: 
13ef			 
13ef			 
13ef				pop hl 
13ef			.lowdone:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_exit: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowallocx 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocasize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdonex 
13ef			.lowallocx: 
13ef			 
13ef				pop hl 
13ef			.lowdonex:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			endif 
13ef			 
13ef			if MALLOC_2 
13ef			; Z80 Malloc and Free Functions 
13ef			 
13ef			; Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc: 
13ef				 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_entry 
13ef			endif 
13ef			 
13ef			 
13ef			 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "mal" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of size into A 
13ef			    or h               ; Check if size is zero 
13ef			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13ef			 
13ef			    ; Allocate memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma1" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    call malloc_internal ; Call internal malloc function 
13ef			    pop af             ; Restore AF register 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret                ; Return 
13ef			 
13ef			; Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free: 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of pointer into A 
13ef			    or h               ; Check if pointer is NULL 
13ef			    jp z, free_exit    ; If pointer is NULL, exit 
13ef			 
13ef			    ; Free memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef			    call free_internal  ; Call internal free function 
13ef			    pop af             ; Restore AF register 
13ef			    ret                ; Return 
13ef			 
13ef			; Internal Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc_internal: 
13ef			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to requested size 
13ef			    ex de, hl          ; Save total size in DE, and keep it in HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			 
13ef			    ; Search for free memory block 
13ef			    ld de, (heap_end)  ; Load end of heap into DE 
13ef			    ld bc, 0           ; Initialize counter 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			malloc_search_loop: 
13ef			    ; Check if current block is free 
13ef			    ld a, (hl)         ; Load current block's status (free or used) 
13ef			    cp 0               ; Compare with zero (free) 
13ef			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13ef			 
13ef			    ; Check if current block is large enough 
13ef			    ld a, (hl+1)       ; Load high byte of block size 
13ef			    cp l               ; Compare with low byte of requested size 
13ef			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13ef			 
13ef			    ld a, (hl+2)       ; Load low byte of block size 
13ef			    cp h               ; Compare with high byte of requested size 
13ef			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13ef			 
13ef			    ; Mark block as used 
13ef			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13ef			 
13ef			    ; Calculate remaining space in block 
13ef			    ld bc, 0           ; Clear BC 
13ef			    add hl, bc         ; Increment HL to point to start of data block 
13ef			    add hl, de         ; HL = HL + DE (total size) 
13ef			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to start of data block 
13ef			 
13ef			    ; Save pointer to allocated block in HL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma5" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			malloc_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3           ; Size of management overhead 
13ef			    add hl, bc         ; Move to the next block 
13ef			    inc de             ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e            ; Load low byte of heap end address 
13ef			    cp (hl)            ; Compare with low byte of current address 
13ef			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13ef			    ld a, d            ; Load high byte of heap end address 
13ef			    cp 0               ; Check if it's zero (end of memory) 
13ef			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, allocation failed 
13ef			    xor a              ; Set result to NULL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma6" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			malloc_exit: 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma7" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			; Internal Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free_internal: 
13ef			    ld de, (heap_start) ; Load start of heap into DE 
13ef			    ld bc, 0            ; Initialize counter 
13ef			 
13ef			free_search_loop: 
13ef			    ; Check if current block contains the pointer 
13ef			    ld a, l             ; Load low byte of pointer 
13ef			    cp (hl+1)           ; Compare with high byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			    ld a, h             ; Load high byte of pointer 
13ef			    cp (hl+2)           ; Compare with low byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			 
13ef			    ; Mark block as free 
13ef			    ld (hl), 0          ; Set status byte to indicate free block 
13ef			    ret                 ; Return 
13ef			 
13ef			free_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3            ; Size of management overhead 
13ef			    add hl, bc          ; Move to the next block 
13ef			    inc de              ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e             ; Load low byte of heap end address 
13ef			    cp (hl)             ; Compare with low byte of current address 
13ef			    jr nz, free_search_loop  ; If not equal, continue searching 
13ef			    ld a, d             ; Load high byte of heap end address 
13ef			    cp 0                ; Check if it's zero (end of memory) 
13ef			    jr nz, free_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, pointer is not found in heap 
13ef			    ret 
13ef			 
13ef			free_exit: 
13ef			    ret                 ; Return 
13ef			 
13ef			; Define heap start and end addresses 
13ef			;heap_start:    .dw 0xC000   ; Start of heap 
13ef			;heap_end:      .dw 0xE000   ; End of heap 
13ef			 
13ef			endif 
13ef			 
13ef			 
13ef			if MALLOC_1 
13ef			 
13ef			 
13ef			 
13ef			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13ef			 
13ef			;moved to firmware.asm 
13ef			;heap_start        .equ  0x9000      ; Starting address of heap 
13ef			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13ef			 
13ef			;      .org 0 
13ef			;      jp    main 
13ef			 
13ef			 
13ef			;      .org  0x100 
13ef			;main: 
13ef			;      ld    HL, 0x8100 
13ef			;      ld    SP, HL 
13ef			; 
13ef			;      call  heap_init 
13ef			; 
13ef			;      ; Make some allocations 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9004 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9014 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9024 
13ef			; 
13ef			;      ; Free some allocations 
13ef			;      ld    HL, 0x9014 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9004 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9024 
13ef			;      call  free 
13ef			; 
13ef			; 
13ef			;      halt 
13ef			 
13ef			 
13ef			;------------------------------------------------------------------------------ 
13ef			;     heap_init                                                               : 
13ef			;                                                                             : 
13ef			; Description                                                                 : 
13ef			;     Initialise the heap and make it ready for malloc and free operations.   : 
13ef			;                                                                             : 
13ef			;     The heap is maintained as a linked list, starting with an initial       : 
13ef			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13ef			;     the first free block in the heap. Each block then points to the next    : 
13ef			;     free block within the heap, and the free list ends at the first block   : 
13ef			;     with a null pointer to the next free block.                             : 
13ef			;                                                                             : 
13ef			; Parameters                                                                  : 
13ef			;     Inputs are compile-time only. Two defines which specify the starting    : 
13ef			;     address of the heap and its size are required, along with a memory      : 
13ef			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13ef			;     principally stores a pointer to the first free block in the heap.       : 
13ef			;                                                                             : 
13ef			; Returns                                                                     : 
13ef			;     Nothing                                                                 : 
13ef			;------------------------------------------------------------------------------ 
13ef			heap_init: 
13ef e5			      push  HL 
13f0			 
13f0			      ; Initialise free list struct 
13f0 21 0e 80		      ld    HL, heap_start 
13f3 22 0a 80		      ld    (free_list), HL 
13f6 21 00 00		      ld    HL, 0 
13f9 22 0c 80		      ld    (free_list+2), HL 
13fc			 
13fc			      ; Insert first free block at bottom of heap, consumes entire heap 
13fc 21 aa f1		      ld    HL, heap_start+heap_size-4 
13ff 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1402 21 9c 71		      ld    HL, heap_size-4 
1405 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1408			 
1408			      ; Insert end of free list block at top of heap - two null words will 
1408			      ; terminate the free list 
1408 21 00 00		      ld    HL, 0 
140b 22 ac f1		      ld    (heap_start+heap_size-2), HL 
140e 22 aa f1		      ld    (heap_start+heap_size-4), HL 
1411			 
1411 e1			      pop   HL 
1412			 
1412 c9			      ret 
1413			 
1413			 
1413			;------------------------------------------------------------------------------ 
1413			;     malloc                                                                  : 
1413			;                                                                             : 
1413			; Description                                                                 : 
1413			;     Allocates the wanted space from the heap and returns the address of the : 
1413			;     first useable byte of the allocation.                                   : 
1413			;                                                                             : 
1413			;     Allocations can happen in one of two ways:                              : 
1413			;                                                                             : 
1413			;     1. A free block may be found which is the exact size wanted. In this    : 
1413			;        case the block is removed from the free list and retuedn to the      : 
1413			;        caller.                                                              : 
1413			;     2. A free block may be found which is larger than the size wanted. In   : 
1413			;        this case, the larger block is split into two. The first portion of  : 
1413			;        this block will become the requested space by the malloc call and    : 
1413			;        is returned to the caller. The second portion becomes a new free     : 
1413			;        block, and the free list is adjusted to maintain continuity via this : 
1413			;        newly created block.                                                 : 
1413			;                                                                             : 
1413			;     malloc does not set any initial value in the allocated space, the       : 
1413			;     caller is required to do this as required.                              : 
1413			;                                                                             : 
1413			;     This implementation of malloc uses the stack exclusively, and is        : 
1413			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1413			;     advisable to disable interrupts before calling malloc, and recommended  : 
1413			;     to avoid the use of malloc inside ISRs in general.                      : 
1413			;                                                                             : 
1413			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1413			;                                                                             : 
1413			; Parameters                                                                  : 
1413			;     HL  Number of bytes wanted                                              : 
1413			;                                                                             : 
1413			; Returns                                                                     : 
1413			;     HL  Address of the first useable byte of the allocation                 : 
1413			;                                                                             : 
1413			; Flags                                                                       : 
1413			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1413			;                                                                             : 
1413			; Stack frame                                                                 : 
1413			;       |             |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     BC      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     DE      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     IX      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |  prev_free  |                                                       : 
1413			;   +4  +-------------+                                                       : 
1413			;       |  this_free  |                                                       : 
1413			;   +2  +-------------+                                                       : 
1413			;       |  next_free  |                                                       : 
1413			;   +0  +-------------+                                                       : 
1413			;       |             |                                                       : 
1413			;                                                                             : 
1413			;------------------------------------------------------------------------------ 
1413			 
1413			 
1413			;malloc: 
1413			; 
1413			;	SAVESP ON 1 
1413			; 
1413			;	call malloc_code 
1413			; 
1413			;	CHECKSP ON 1 
1413			;	ret 
1413			 
1413			 
1413			malloc: 
1413 c5			      push  BC 
1414 d5			      push  DE 
1415 dd e5		      push  IX 
1417			if DEBUG_FORTH_MALLOC_HIGH 
1417			call malloc_guard_entry 
1417			endif 
1417			 
1417					if DEBUG_FORTH_MALLOC 
1417						DMARK "mal" 
1417						CALLMONITOR 
1417					endif 
1417 7c			      ld    A, H                    ; Exit if no space requested 
1418 b5			      or    L 
1419 ca d8 14		      jp    Z, malloc_early_exit 
141c			 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			; 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			 
141c			 
141c			 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "maA" 
141c						CALLMONITOR 
141c					endif 
141c			      ; Set up stack frame 
141c eb			      ex    DE, HL 
141d 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1420 39			      add   HL, SP 
1421 f9			      ld    SP, HL 
1422 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1426 dd 39		      add   IX, SP 
1428			 
1428			      ; Setup initial state 
1428 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
142b 19			      add   HL, DE 
142c			 
142c 44			      ld    B, H                    ; Move want to BC 
142d 4d			      ld    C, L 
142e			 
142e 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1431 dd 75 04		      ld    (IX+4), L 
1434 dd 74 05		      ld    (IX+5), H 
1437			 
1437 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1438 23			      inc   HL 
1439 56			      ld    D, (HL) 
143a dd 73 02		      ld    (IX+2), E 
143d dd 72 03		      ld    (IX+3), D 
1440 eb			      ex    DE, HL                  ; this_free ptr into HL 
1441			 
1441					if DEBUG_FORTH_MALLOC 
1441						DMARK "maB" 
1441						CALLMONITOR 
1441					endif 
1441			      ; Loop through free block list to find some space 
1441			malloc_find_space: 
1441 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1442 23			      inc   HL 
1443 56			      ld    D, (HL) 
1444			 
1444 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1445 b3			      or    E 
1446 ca d2 14		      jp    Z, malloc_no_space 
1449			 
1449 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
144c dd 72 01		      ld    (IX+1), D 
144f			 
144f			      ; Does this block have enough space to make the allocation? 
144f 23			      inc   HL                      ; Load free block size into DE 
1450 5e			      ld    E, (HL) 
1451 23			      inc   HL 
1452 56			      ld    D, (HL) 
1453			 
1453 eb			      ex    DE, HL                  ; Check size of block against want 
1454 b7			      or    A                       ; Ensure carry flag clear 
1455 ed 42		      sbc   HL, BC 
1457 e5			      push  HL                      ; Store the result for later (new block size) 
1458			 
1458 ca a7 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
145b 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
145d			 
145d			      ; this_free block is not big enough, setup ptrs to test next free block 
145d e1			      pop   HL                      ; Discard previous result 
145e			 
145e dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1461 dd 66 03		      ld    H, (IX+3) 
1464 dd 75 04		      ld    (IX+4), L 
1467 dd 74 05		      ld    (IX+5), H 
146a			 
146a dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
146d dd 66 01		      ld    H, (IX+1) 
1470 dd 75 02		      ld    (IX+2), L 
1473 dd 74 03		      ld    (IX+3), H 
1476			 
1476					if DEBUG_FORTH_MALLOC 
1476						DMARK "MA>" 
1476						CALLMONITOR 
1476					endif 
1476 18 c9		      jr    malloc_find_space 
1478			 
1478			      ; split a bigger block into two - requested size and remaining size 
1478			malloc_alloc_split: 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAs" 
1478						CALLMONITOR 
1478					endif 
1478 eb			      ex    DE, HL                  ; Calculate address of new free block 
1479 2b			      dec   HL 
147a 2b			      dec   HL 
147b 2b			      dec   HL 
147c 09			      add   HL, BC 
147d			 
147d			      ; Create a new block and point it at next_free 
147d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1480 dd 56 01		      ld    D, (IX+1) 
1483			 
1483 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1484 23			      inc   HL 
1485 72			      ld    (HL), D 
1486			 
1486 d1			      pop   DE                      ; Store size of new block into new block 
1487 23			      inc   HL 
1488 73			      ld    (HL), E 
1489 23			      inc   HL 
148a 72			      ld    (HL), D 
148b			 
148b			      ; Update this_free ptr to point to new block 
148b 2b			      dec   HL 
148c 2b			      dec   HL 
148d 2b			      dec   HL 
148e			 
148e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1491 dd 56 03		      ld    D, (IX+3) 
1494			 
1494 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1497 dd 74 03		      ld    (IX+3), H 
149a			 
149a			      ; Modify this_free block to be allocation 
149a eb			      ex    DE, HL 
149b af			      xor   A                       ; Null the next block ptr of allocated block 
149c 77			      ld    (HL), A 
149d 23			      inc   HL 
149e 77			      ld    (HL), A 
149f			 
149f 23			      inc   HL                      ; Store want size into allocated block 
14a0 71			      ld    (HL), C 
14a1 23			      inc   HL 
14a2 70			      ld    (HL), B 
14a3 23			      inc   HL 
14a4 e5			      push  HL                      ; Address of allocation to return 
14a5			 
14a5 18 19		      jr    malloc_update_links 
14a7			 
14a7			malloc_alloc_fit: 
14a7 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14a8			 
14a8					if DEBUG_FORTH_MALLOC 
14a8						DMARK "MAf" 
14a8						CALLMONITOR 
14a8					endif 
14a8			      ; Modify this_free block to be allocation 
14a8 eb			      ex    DE, HL 
14a9 2b			      dec   HL 
14aa 2b			      dec   HL 
14ab 2b			      dec   HL 
14ac			 
14ac af			      xor   A                       ; Null the next block ptr of allocated block 
14ad 77			      ld    (HL), A 
14ae 23			      inc   HL 
14af 77			      ld    (HL), A 
14b0			 
14b0 23			      inc   HL                      ; Store address of allocation to return 
14b1 23			      inc   HL 
14b2 23			      inc   HL 
14b3 e5			      push  HL 
14b4			 
14b4			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14b4 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14b7 dd 66 01		      ld    H, (IX+1) 
14ba			 
14ba dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14bd dd 74 03		      ld    (IX+3), H 
14c0			 
14c0			 
14c0			malloc_update_links: 
14c0			      ; Update prev_free ptr to point to this_free 
14c0 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14c3 dd 66 05		      ld    H, (IX+5) 
14c6			 
14c6 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14c9 dd 56 03		      ld    D, (IX+3) 
14cc			 
14cc 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14cd 23			      inc   HL 
14ce 72			      ld    (HL), D 
14cf			 
14cf					if DEBUG_FORTH_MALLOC 
14cf						DMARK "Mul" 
14cf						CALLMONITOR 
14cf					endif 
14cf			      ; Clear the Z flag to indicate successful allocation 
14cf 7a			      ld    A, D 
14d0 b3			      or    E 
14d1			 
14d1 d1			      pop   DE                      ; Address of allocation 
14d2					if DEBUG_FORTH_MALLOC 
14d2						DMARK "MAu" 
14d2						CALLMONITOR 
14d2					endif 
14d2			 
14d2			malloc_no_space: 
14d2 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14d5 39			      add   HL, SP 
14d6 f9			      ld    SP, HL 
14d7			 
14d7 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAN" 
14d8						CALLMONITOR 
14d8					endif 
14d8			 
14d8			malloc_early_exit: 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAx" 
14d8						CALLMONITOR 
14d8					endif 
14d8 dd e1		      pop   IX 
14da d1			      pop   DE 
14db c1			      pop   BC 
14dc			 
14dc			if DEBUG_FORTH_MALLOC_HIGH 
14dc			call malloc_guard_exit 
14dc			call malloc_guard_zerolen 
14dc			endif 
14dc c9			      ret 
14dd			 
14dd			 
14dd			;------------------------------------------------------------------------------ 
14dd			;     free                                                                    : 
14dd			;                                                                             : 
14dd			; Description                                                                 : 
14dd			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14dd			;     returned by malloc, otherwise the behaviour is undefined.               : 
14dd			;                                                                             : 
14dd			;     Where possible, directly adjacent free blocks will be merged together   : 
14dd			;     into larger blocks to help ensure that the heap does not become         : 
14dd			;     excessively fragmented.                                                 : 
14dd			;                                                                             : 
14dd			;     free does not clear or set any other value into the freed space, and    : 
14dd			;     therefore its contents may be visible through subsequent malloc's. The  : 
14dd			;     caller should clear the freed space as required.                        : 
14dd			;                                                                             : 
14dd			;     This implementation of free uses the stack exclusively, and is          : 
14dd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14dd			;     advisable to disable interrupts before calling free, and recommended    : 
14dd			;     to avoid the use of free inside ISRs in general.                        : 
14dd			;                                                                             : 
14dd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14dd			;                                                                             : 
14dd			; Parameters                                                                  : 
14dd			;     HL  Pointer to address of first byte of allocation to be freed          : 
14dd			;                                                                             : 
14dd			; Returns                                                                     : 
14dd			;     Nothing                                                                 : 
14dd			;                                                                             : 
14dd			; Stack frame                                                                 : 
14dd			;       |             |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     BC      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     DE      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     IX      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |  prev_free  |                                                       : 
14dd			;   +2  +-------------+                                                       : 
14dd			;       |  next_free  |                                                       : 
14dd			;   +0  +-------------+                                                       : 
14dd			;       |             |                                                       : 
14dd			;                                                                             : 
14dd			;------------------------------------------------------------------------------ 
14dd			free: 
14dd c5			      push  BC 
14de d5			      push  DE 
14df dd e5		      push  IX 
14e1			 
14e1 7c			      ld    A, H                    ; Exit if ptr is null 
14e2 b5			      or    L 
14e3 ca a7 15		      jp    Z, free_early_exit 
14e6			 
14e6			      ; Set up stack frame 
14e6 eb			      ex    DE, HL 
14e7 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14ea 39			      add   HL, SP 
14eb f9			      ld    SP, HL 
14ec dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14f0 dd 39		      add   IX, SP 
14f2			 
14f2			      ; The address in HL points to the start of the useable allocated space, 
14f2			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14f2			      ; address of the block itself. 
14f2 eb			      ex    DE, HL 
14f3 11 fc ff		      ld    DE, -4 
14f6 19			      add   HL, DE 
14f7			 
14f7			      ; An allocated block must have a null next block pointer in it 
14f7 7e			      ld    A, (HL) 
14f8 23			      inc   HL 
14f9 b6			      or    (HL) 
14fa c2 a2 15		      jp    NZ, free_done 
14fd			 
14fd 2b			      dec   HL 
14fe			 
14fe 44			      ld    B, H                    ; Copy HL to BC 
14ff 4d			      ld    C, L 
1500			 
1500			      ; Loop through the free list to find the first block with an address 
1500			      ; higher than the block being freed 
1500 21 0a 80		      ld    HL, free_list 
1503			 
1503			free_find_higher_block: 
1503 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1504 23			      inc   HL 
1505 56			      ld    D, (HL) 
1506 2b			      dec   HL 
1507			 
1507 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
150a dd 72 01		      ld    (IX+1), D 
150d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1510 dd 74 03		      ld    (IX+3), H 
1513			 
1513 78			      ld    A, B                    ; Check if DE is greater than BC 
1514 ba			      cp    D                       ; Compare MSB first 
1515 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1517 30 04		      jr    NC, free_find_higher_block_skip 
1519 79			      ld    A, C 
151a bb			      cp    E                       ; Then compare LSB 
151b 38 08		      jr    C, free_found_higher_block 
151d			 
151d			free_find_higher_block_skip: 
151d 7a			      ld    A, D                    ; Reached the end of the free list? 
151e b3			      or    E 
151f ca a2 15		      jp    Z, free_done 
1522			 
1522 eb			      ex    DE, HL 
1523			 
1523 18 de		      jr    free_find_higher_block 
1525			 
1525			free_found_higher_block: 
1525			      ; Insert freed block between prev and next free blocks 
1525 71			      ld    (HL), C                 ; Point prev free block to freed block 
1526 23			      inc   HL 
1527 70			      ld    (HL), B 
1528			 
1528 60			      ld    H, B                    ; Point freed block at next free block 
1529 69			      ld    L, C 
152a 73			      ld    (HL), E 
152b 23			      inc   HL 
152c 72			      ld    (HL), D 
152d			 
152d			      ; Check if the freed block is adjacent to the next free block 
152d 23			      inc   HL                      ; Load size of freed block into HL 
152e 5e			      ld    E, (HL) 
152f 23			      inc   HL 
1530 56			      ld    D, (HL) 
1531 eb			      ex    DE, HL 
1532			 
1532 09			      add   HL, BC                  ; Add addr of freed block and its size 
1533			 
1533 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1536 dd 56 01		      ld    D, (IX+1) 
1539			 
1539 b7			      or    A                       ; Clear the carry flag 
153a ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
153c 20 22		      jr    NZ, free_check_adjacent_to_prev 
153e			 
153e			      ; Freed block is adjacent to next, merge into one bigger block 
153e eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
153f 5e			      ld    E, (HL) 
1540 23			      inc   HL 
1541 56			      ld    D, (HL) 
1542 e5			      push  HL                      ; Save ptr to next block for later 
1543			 
1543 60			      ld    H, B                    ; Store ptr from next block into freed block 
1544 69			      ld    L, C 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548 e1			      pop   HL                      ; Restore ptr to next block 
1549 23			      inc   HL                      ; Load size of next block into DE 
154a 5e			      ld    E, (HL) 
154b 23			      inc   HL 
154c 56			      ld    D, (HL) 
154d d5			      push  DE                      ; Save next block size for later 
154e			 
154e 60			      ld    H, B                    ; Load size of freed block into HL 
154f 69			      ld    L, C 
1550 23			      inc   HL 
1551 23			      inc   HL 
1552 5e			      ld    E, (HL) 
1553 23			      inc   HL 
1554 56			      ld    D, (HL) 
1555 eb			      ex    DE, HL 
1556			 
1556 d1			      pop   DE                      ; Restore size of next block 
1557 19			      add   HL, DE                  ; Add sizes of both blocks 
1558 eb			      ex    DE, HL 
1559			 
1559 60			      ld    H, B                    ; Store new bigger size into freed block 
155a 69			      ld    L, C 
155b 23			      inc   HL 
155c 23			      inc   HL 
155d 73			      ld    (HL), E 
155e 23			      inc   HL 
155f 72			      ld    (HL), D 
1560			 
1560			free_check_adjacent_to_prev: 
1560			      ; Check if the freed block is adjacent to the prev free block 
1560 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1563 dd 66 03		      ld    H, (IX+3) 
1566			 
1566 23			      inc   HL                      ; Size of prev free block into DE 
1567 23			      inc   HL 
1568 5e			      ld    E, (HL) 
1569 23			      inc   HL 
156a 56			      ld    D, (HL) 
156b 2b			      dec   HL 
156c 2b			      dec   HL 
156d 2b			      dec   HL 
156e			 
156e 19			      add   HL, DE                  ; Add prev block addr and size 
156f			 
156f b7			      or    A                       ; Clear the carry flag 
1570 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1572 20 2e		      jr    NZ, free_done 
1574			 
1574			      ; Freed block is adjacent to prev, merge into one bigger block 
1574 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1575 69			      ld    L, C 
1576 5e			      ld    E, (HL) 
1577 23			      inc   HL 
1578 56			      ld    D, (HL) 
1579 e5			      push  HL                      ; Save freed block ptr for later 
157a			 
157a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
157d dd 66 03		      ld    H, (IX+3) 
1580 73			      ld    (HL), E 
1581 23			      inc   HL 
1582 72			      ld    (HL), D 
1583			 
1583 e1			      pop   HL                      ; Restore freed block ptr 
1584 23			      inc   HL                      ; Load size of freed block into DE 
1585 5e			      ld    E, (HL) 
1586 23			      inc   HL 
1587 56			      ld    D, (HL) 
1588 d5			      push  DE                      ; Save freed block size for later 
1589			 
1589 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
158c dd 66 03		      ld    H, (IX+3) 
158f 23			      inc   HL 
1590 23			      inc   HL 
1591 5e			      ld    E, (HL) 
1592 23			      inc   HL 
1593 56			      ld    D, (HL) 
1594			 
1594 e1			      pop   HL                      ; Add sizes of both blocks 
1595 19			      add   HL, DE 
1596 eb			      ex    DE, HL 
1597			 
1597 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
159a dd 66 03		      ld    H, (IX+3) 
159d 23			      inc   HL 
159e 23			      inc   HL 
159f 73			      ld    (HL), E 
15a0 23			      inc   HL 
15a1 72			      ld    (HL), D 
15a2			 
15a2			free_done: 
15a2 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15a5 39			      add   HL, SP 
15a6 f9			      ld    SP, HL 
15a7			 
15a7			free_early_exit: 
15a7 dd e1		      pop   IX 
15a9 d1			      pop   DE 
15aa c1			      pop   BC 
15ab			 
15ab c9			      ret 
15ac			 
15ac			; moved to firmware.asm 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			;                  .dw   0 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_3 
15ac			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15ac			;heap_start        .equ  0x9000      ; Starting address of heap 
15ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15ac			; 
15ac			 ;     .org 0 
15ac			  ;    jp    main 
15ac			; 
15ac			; 
15ac			 ;     .org  0x100 
15ac			;main: 
15ac			 ;     ld    HL, 0x8100 
15ac			  ;    ld    SP, HL 
15ac			; 
15ac			;      call  heap_init 
15ac			 
15ac			      ; Make some allocations 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9004 
15ac			; 
15ac			 ;     ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9014 
15ac			 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9024 
15ac			 
15ac			      ; Free some allocations 
15ac			;      ld    HL, 0x9014 
15ac			;      call  free 
15ac			 
15ac			;      ld    HL, 0x9004 
15ac			;      call  free 
15ac			; 
15ac			;      ld    HL, 0x9024 
15ac			;      call  free 
15ac			 
15ac			 
15ac			 ;     halt 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     heap_init                                                               : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
15ac			;                                                                             : 
15ac			;     The heap is maintained as a linked list, starting with an initial       : 
15ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15ac			;     the first free block in the heap. Each block then points to the next    : 
15ac			;     free block within the heap, and the free list ends at the first block   : 
15ac			;     with a null pointer to the next free block.                             : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
15ac			;     address of the heap and its size are required, along with a memory      : 
15ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15ac			;     principally stores a pointer to the first free block in the heap.       : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;------------------------------------------------------------------------------ 
15ac			heap_init: 
15ac			      push  HL 
15ac			 
15ac			      ; Initialise free list struct 
15ac			      ld    HL, heap_start 
15ac			      ld    (free_list), HL 
15ac			      ld    HL, 0 
15ac			      ld    (free_list+2), HL 
15ac			 
15ac			      ; Insert first free block at bottom of heap, consumes entire heap 
15ac			      ld    HL, heap_start+heap_size-4 
15ac			      ld    (heap_start), HL        ; Next block (end of free list) 
15ac			      ld    HL, heap_size-4 
15ac			      ld    (heap_start+2), HL      ; Block size 
15ac			 
15ac			      ; Insert end of free list block at top of heap - two null words will 
15ac			      ; terminate the free list 
15ac			      ld    HL, 0 
15ac			      ld    (heap_start+heap_size-2), HL 
15ac			      ld    (heap_start+heap_size-4), HL 
15ac			 
15ac			      pop   HL 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     malloc                                                                  : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Allocates the wanted space from the heap and returns the address of the : 
15ac			;     first useable byte of the allocation.                                   : 
15ac			;                                                                             : 
15ac			;     Allocations can happen in one of two ways:                              : 
15ac			;                                                                             : 
15ac			;     1. A free block may be found which is the exact size wanted. In this    : 
15ac			;        case the block is removed from the free list and retuedn to the      : 
15ac			;        caller.                                                              : 
15ac			;     2. A free block may be found which is larger than the size wanted. In   : 
15ac			;        this case, the larger block is split into two. The first portion of  : 
15ac			;        this block will become the requested space by the malloc call and    : 
15ac			;        is returned to the caller. The second portion becomes a new free     : 
15ac			;        block, and the free list is adjusted to maintain continuity via this : 
15ac			;        newly created block.                                                 : 
15ac			;                                                                             : 
15ac			;     malloc does not set any initial value in the allocated space, the       : 
15ac			;     caller is required to do this as required.                              : 
15ac			;                                                                             : 
15ac			;     This implementation of malloc uses the stack exclusively, and is        : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling malloc, and recommended  : 
15ac			;     to avoid the use of malloc inside ISRs in general.                      : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Number of bytes wanted                                              : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     HL  Address of the first useable byte of the allocation                 : 
15ac			;                                                                             : 
15ac			; Flags                                                                       : 
15ac			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +4  +-------------+                                                       : 
15ac			;       |  this_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			malloc: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if no space requested 
15ac			      or    L 
15ac			      jp    Z, malloc_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; Setup initial state 
15ac			      ld    HL, 4                   ; want must also include space used by block struct 
15ac			      add   HL, DE 
15ac			 
15ac			      ld    B, H                    ; Move want to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ld    HL, free_list           ; Store prev_free ptr to stack 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    E, (HL)                 ; Store this_free ptr to stack 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ld    (IX+2), E 
15ac			      ld    (IX+3), D 
15ac			      ex    DE, HL                  ; this_free ptr into HL 
15ac			 
15ac			      ; Loop through free block list to find some space 
15ac			malloc_find_space: 
15ac			      ld    E, (HL)                 ; Load next_free ptr into DE 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15ac			      or    E 
15ac			      jp    Z, malloc_no_space 
15ac			 
15ac			      ld    (IX+0), E               ; Store next_free ptr to stack 
15ac			      ld    (IX+1), D 
15ac			 
15ac			      ; Does this block have enough space to make the allocation? 
15ac			      inc   HL                      ; Load free block size into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ex    DE, HL                  ; Check size of block against want 
15ac			      or    A                       ; Ensure carry flag clear 
15ac			      sbc   HL, BC 
15ac			      push  HL                      ; Store the result for later (new block size) 
15ac			 
15ac			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15ac			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15ac			 
15ac			      ; this_free block is not big enough, setup ptrs to test next free block 
15ac			      pop   HL                      ; Discard previous result 
15ac			 
15ac			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15ac			      ld    H, (IX+3) 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15ac			      ld    H, (IX+1) 
15ac			      ld    (IX+2), L 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      jr    malloc_find_space 
15ac			 
15ac			      ; split a bigger block into two - requested size and remaining size 
15ac			malloc_alloc_split: 
15ac			      ex    DE, HL                  ; Calculate address of new free block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      add   HL, BC 
15ac			 
15ac			      ; Create a new block and point it at next_free 
15ac			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      ld    (HL), E                 ; Store next_free ptr into new block 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   DE                      ; Store size of new block into new block 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Update this_free ptr to point to new block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store want size into allocated block 
15ac			      ld    (HL), C 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			      inc   HL 
15ac			      push  HL                      ; Address of allocation to return 
15ac			 
15ac			      jr    malloc_update_links 
15ac			 
15ac			malloc_alloc_fit: 
15ac			      pop   HL                      ; Dont need new block size, want is exact fit 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store address of allocation to return 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      push  HL 
15ac			 
15ac			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15ac			      ld    L, (IX+0)               ; next_free to HL 
15ac			      ld    H, (IX+1) 
15ac			 
15ac			      ld    (IX+2), L               ; HL to this_free 
15ac			      ld    (IX+3), H 
15ac			 
15ac			 
15ac			malloc_update_links: 
15ac			      ; Update prev_free ptr to point to this_free 
15ac			      ld    L, (IX+4)               ; prev_free ptr to HL 
15ac			      ld    H, (IX+5) 
15ac			 
15ac			      ld    E, (IX+2)               ; this_free ptr to DE 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (HL), E                 ; this_free ptr into prev_free 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Clear the Z flag to indicate successful allocation 
15ac			      ld    A, D 
15ac			      or    E 
15ac			 
15ac			      pop   DE                      ; Address of allocation 
15ac			 
15ac			malloc_no_space: 
15ac			      ld    HL, 6                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			      ex    DE, HL                  ; Alloc addr into HL for return 
15ac			 
15ac			malloc_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     free                                                                    : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15ac			;     returned by malloc, otherwise the behaviour is undefined.               : 
15ac			;                                                                             : 
15ac			;     Where possible, directly adjacent free blocks will be merged together   : 
15ac			;     into larger blocks to help ensure that the heap does not become         : 
15ac			;     excessively fragmented.                                                 : 
15ac			;                                                                             : 
15ac			;     free does not clear or set any other value into the freed space, and    : 
15ac			;     therefore its contents may be visible through subsequent malloc's. The  : 
15ac			;     caller should clear the freed space as required.                        : 
15ac			;                                                                             : 
15ac			;     This implementation of free uses the stack exclusively, and is          : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling free, and recommended    : 
15ac			;     to avoid the use of free inside ISRs in general.                        : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Pointer to address of first byte of allocation to be freed          : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			free: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if ptr is null 
15ac			      or    L 
15ac			      jp    Z, free_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; The address in HL points to the start of the useable allocated space, 
15ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15ac			      ; address of the block itself. 
15ac			      ex    DE, HL 
15ac			      ld    DE, -4 
15ac			      add   HL, DE 
15ac			 
15ac			      ; An allocated block must have a null next block pointer in it 
15ac			      ld    A, (HL) 
15ac			      inc   HL 
15ac			      or    (HL) 
15ac			      jp    NZ, free_done 
15ac			 
15ac			      dec   HL 
15ac			 
15ac			      ld    B, H                    ; Copy HL to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ; Loop through the free list to find the first block with an address 
15ac			      ; higher than the block being freed 
15ac			      ld    HL, free_list 
15ac			 
15ac			free_find_higher_block: 
15ac			      ld    E, (HL)                 ; Load next ptr from free block 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			 
15ac			      ld    (IX+0), E               ; Save ptr to next free block 
15ac			      ld    (IX+1), D 
15ac			      ld    (IX+2), L               ; Save ptr to prev free block 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ld    A, B                    ; Check if DE is greater than BC 
15ac			      cp    D                       ; Compare MSB first 
15ac			      jr    Z, $+4                  ; MSB the same, compare LSB 
15ac			      jr    NC, free_find_higher_block_skip 
15ac			      ld    A, C 
15ac			      cp    E                       ; Then compare LSB 
15ac			      jr    C, free_found_higher_block 
15ac			 
15ac			free_find_higher_block_skip: 
15ac			      ld    A, D                    ; Reached the end of the free list? 
15ac			      or    E 
15ac			      jp    Z, free_done 
15ac			 
15ac			      ex    DE, HL 
15ac			 
15ac			      jr    free_find_higher_block 
15ac			 
15ac			free_found_higher_block: 
15ac			      ; Insert freed block between prev and next free blocks 
15ac			      ld    (HL), C                 ; Point prev free block to freed block 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			 
15ac			      ld    H, B                    ; Point freed block at next free block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Check if the freed block is adjacent to the next free block 
15ac			      inc   HL                      ; Load size of freed block into HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      add   HL, BC                  ; Add addr of freed block and its size 
15ac			 
15ac			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_check_adjacent_to_prev 
15ac			 
15ac			      ; Freed block is adjacent to next, merge into one bigger block 
15ac			      ex    DE, HL                  ; Load next ptr from next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save ptr to next block for later 
15ac			 
15ac			      ld    H, B                    ; Store ptr from next block into freed block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore ptr to next block 
15ac			      inc   HL                      ; Load size of next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save next block size for later 
15ac			 
15ac			      ld    H, B                    ; Load size of freed block into HL 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      pop   DE                      ; Restore size of next block 
15ac			      add   HL, DE                  ; Add sizes of both blocks 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    H, B                    ; Store new bigger size into freed block 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_check_adjacent_to_prev: 
15ac			      ; Check if the freed block is adjacent to the prev free block 
15ac			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15ac			      ld    H, (IX+3) 
15ac			 
15ac			      inc   HL                      ; Size of prev free block into DE 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      add   HL, DE                  ; Add prev block addr and size 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_done 
15ac			 
15ac			      ; Freed block is adjacent to prev, merge into one bigger block 
15ac			      ld    H, B                    ; Load next ptr from freed block into DE 
15ac			      ld    L, C 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save freed block ptr for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15ac			      ld    H, (IX+3) 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore freed block ptr 
15ac			      inc   HL                      ; Load size of freed block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save freed block size for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Load size of prev block into DE 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      pop   HL                      ; Add sizes of both blocks 
15ac			      add   HL, DE 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_done: 
15ac			      ld    HL, 4                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			free_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;      .org 0x8000 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			 ;                 .dw   0 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_4 
15ac			 
15ac			; My memory allocation code. Very very simple.... 
15ac			; allocate space under 250 chars 
15ac			 
15ac			heap_init: 
15ac				; init start of heap as zero 
15ac				;  
15ac			 
15ac				ld hl, heap_start 
15ac				ld a, 0 
15ac				ld (hl), a      ; empty block 
15ac				inc hl 
15ac				ld a, 0 
15ac				ld (hl), a      ; length of block 
15ac				; write end of list 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				 
15ac			 
15ac				; init some malloc vars 
15ac			 
15ac				ld hl, 0 
15ac				ld (free_list), hl       ; store last malloc location 
15ac			 
15ac				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15ac				ld a, 0 
15ac				ld (hl), a 
15ac			 
15ac			 
15ac				ld hl, heap_start 
15ac				;  
15ac				  
15ac				ret 
15ac			 
15ac			 
15ac			;    free block marker 
15ac			;    requested size  
15ac			;    pointer to next block 
15ac			;    .... 
15ac			;    next block marker 
15ac			 
15ac			 
15ac			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15ac			; 
15ac			 
15ac			 
15ac			malloc:  
15ac				push de 
15ac				push bc 
15ac				push af 
15ac			 
15ac				; hl space required 
15ac				 
15ac				ld c, l    ; hold space   (TODO only a max of 255) 
15ac			 
15ac			;	inc c     ; TODO BUG need to fix memory leak on push str 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			 
15ac			 
15ac			 
15ac				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15ac			 
15ac				ld a, (free_list+3) 
15ac				cp 0 
15ac				jr z, .contheap 
15ac			 
15ac				ld hl, (free_list)     ; get last alloc 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mrs" 
15ac						CALLMONITOR 
15ac					endif 
15ac				jr .startalloc 
15ac			 
15ac			.contheap: 
15ac				ld hl, heap_start 
15ac			 
15ac			.startalloc: 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mym" 
15ac						CALLMONITOR 
15ac					endif 
15ac			.findblock: 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmf" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac				ld a,(hl)  
15ac				; if byte is zero then clear to use 
15ac			 
15ac				cp 0 
15ac				jr z, .foundemptyblock 
15ac			 
15ac				; if byte is not clear 
15ac				;     then byte is offset to next block 
15ac			 
15ac				inc hl 
15ac				ld a, (hl) ; get size 
15ac			.nextblock:	inc hl 
15ac					ld e, (hl) 
15ac					inc hl 
15ac					ld d, (hl) 
15ac					ex de, hl 
15ac			;	inc hl  ; move past the store space 
15ac			;	inc hl  ; move past zero index  
15ac			 
15ac				; TODO detect no more space 
15ac			 
15ac				push hl 
15ac				ld de, heap_end 
15ac				call cmp16 
15ac				pop hl 
15ac				jr nc, .nospace 
15ac			 
15ac				jr .findblock 
15ac			 
15ac			.nospace: ld hl, 0 
15ac				jp .exit 
15ac			 
15ac			 
15ac			.foundemptyblock:	 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mme" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; TODO has block enough space if reusing??? 
15ac			 
15ac				;  
15ac			 
15ac			; see if this block has been previously used 
15ac				inc hl 
15ac				ld a, (hl) 
15ac				dec hl 
15ac				cp 0 
15ac				jr z, .newblock 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meR" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; no reusing previously allocated block 
15ac			 
15ac			; is it smaller than previously used? 
15ac				 
15ac				inc hl    ; move to size 
15ac				ld a, c 
15ac				sub (hl)        ; we want c < (hl) 
15ac				dec hl    ; move back to marker 
15ac			        jr z, .findblock 
15ac			 
15ac				; update with the new size which should be lower 
15ac			 
15ac			        ;inc  hl   ; negate next move. move back to size  
15ac			 
15ac			.newblock: 
15ac				; need to be at marker here 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meN" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			 
15ac				ld a, c 
15ac			 
15ac				ld (free_list+3), a	 ; flag resume from last malloc  
15ac				ld (free_list), hl    ; save out last location 
15ac			 
15ac			 
15ac				;inc a     ; space for length byte 
15ac				ld (hl), a     ; save block in use marker 
15ac			 
15ac				inc hl   ; move to space marker 
15ac				ld (hl), a    ; save new space 
15ac			 
15ac				inc hl   ; move to start of allocated area 
15ac				 
15ac			;	push hl     ; save where we are - 1  
15ac			 
15ac			;	inc hl  ; move past zero index  
15ac				; skip space to set down new marker 
15ac			 
15ac				; provide some extra space for now 
15ac			 
15ac				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15ac				inc a 
15ac				inc a 
15ac			 
15ac				push hl   ; save where we are in the node block 
15ac			 
15ac				call addatohl 
15ac			 
15ac				; write linked list point 
15ac			 
15ac				pop de     ; get our node position 
15ac				ex de, hl 
15ac			 
15ac				ld (hl), e 
15ac				inc hl 
15ac				ld (hl), d 
15ac			 
15ac				inc hl 
15ac			 
15ac				; now at start of allocated data so save pointer 
15ac			 
15ac				push hl 
15ac			 
15ac				; jump to position of next node and setup empty header in DE 
15ac			 
15ac				ex de, hl 
15ac			 
15ac			;	inc hl ; move past end of block 
15ac			 
15ac				ld a, 0 
15ac				ld (hl), a   ; empty marker 
15ac				inc hl 
15ac				ld (hl), a   ; size 
15ac				inc hl  
15ac				ld (hl), a   ; ptr 
15ac				inc hl 
15ac				ld (hl), a   ; ptr 
15ac			 
15ac			 
15ac				pop hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmr" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			.exit: 
15ac				pop af 
15ac				pop bc 
15ac				pop de  
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			 
15ac			free:  
15ac				push hl 
15ac				push af 
15ac				; get address in hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "fre" 
15ac						CALLMONITOR 
15ac					endif 
15ac				; data is at hl - move to block count 
15ac				dec hl 
15ac				dec hl    ; get past pointer 
15ac				dec hl 
15ac			 
15ac				ld a, (hl)    ; need this for a validation check 
15ac			 
15ac				dec hl    ; move to block marker 
15ac			 
15ac				; now check that the block count and block marker are the same  
15ac			        ; this checks that we are on a malloc node and not random memory 
15ac			        ; OK a faint chance this could be a problem but rare - famous last words! 
15ac			 
15ac				ld c, a 
15ac				ld a, (hl)    
15ac			 
15ac				cp c 
15ac				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15ac			 
15ac				; yes good chance we are on a malloc node 
15ac			 
15ac				ld a, 0      
15ac				ld (hl), a   ; mark as free 
15ac			 
15ac				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15ac			 
15ac			.freeignore:  
15ac			 
15ac				pop af 
15ac				pop hl 
15ac			 
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			; eof 
# End of file firmware_memory.asm
15ac			  
15ac			; device C  
15ac			if SOUND_ENABLE  
15ac				include "firmware_sound.asm"  
15ac			; Sound abstraction layer 
15ac			 
15ac			; support different sound chips through common interface 
15ac			 
15ac			SOUND_DEVICE_AY: equ 0 
15ac			 
15ac			SOUND_DEVICE: equ Device_A 
15ac			 
15ac			 
15ac			 
15ac			if SOUND_DEVICE_AY 
15ac				include "firmware_sound_ay38910.asm" 
15ac			else 
15ac				include "firmware_sound_sn76489an.asm" 
15ac			 
15ac			; Device support for SN76489AN sound chip 
15ac			 
15ac			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
15ac			; http://danceswithferrets.org/geekblog/?p=93 
15ac			; https://www.smspower.org/Development/SN76489 
15ac			 
15ac			; D0 [ 3] 
15ac			; D1 [ 2] 
15ac			; D2 [ 1] 
15ac			; D3 [15] 
15ac			; D4 [13] 
15ac			; D5 [12] 
15ac			; D6 [11] 
15ac			; D7 [10] 
15ac			; /WE [ 5] 
15ac			; CLK [14] 
15ac			; /OE [ 6] 
15ac			; AUDIO [ 7] 
15ac			; GND 8 
15ac			; +5 16 
15ac			; 
15ac			 
15ac			; Write sequence: 
15ac			; CE low 
15ac			; Data bus 
15ac			; WE low then high 
15ac			; 32 clock cycles / 8ns write time at 4mhz 
15ac			; 
15ac			; https://github.com/jblang/SN76489 
15ac			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
15ac			; Tried: 
15ac			; 
15ac			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
15ac			; 
15ac			; Connected WE to OR too 
15ac			;  
15ac			; That enabled the clock when required 
15ac			; However still random bus corruption. Need further investigation 
15ac			 
15ac			 
15ac			SOUND_LATCH: equ 10000000B 
15ac			SOUND_DATA: equ 0B 
15ac			SOUND_CH0:  equ 0B    ; Tone 
15ac			SOUND_CH1: equ 0100000B        ; Tone 
15ac			SOUND_CH2: equ 1000000B   ; Tone 
15ac			SOUND_CH3: equ 1100000B    ; Noise 
15ac			SOUND_VOL: equ 10000B 
15ac			SOUND_TONE: equ 0B 
15ac			 
15ac			 
15ac			sound_init: 
15ac 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
15ae cd c3 15			call note_send_byte 
15b1 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
15b3 cd c3 15			call note_send_byte 
15b6 cd 89 0c			call delay250ms 
15b9 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
15bb cd c3 15			call note_send_byte 
15be cd 89 0c			call delay250ms 
15c1 c9				ret 
15c2			 
15c2			; Play a note 
15c2			; h = note 
15c2			; l = duration 
15c2			; a = channel 
15c2			 
15c2			 
15c2			;  frequ = clock / ( 2 x reg valu x 32 )  
15c2			 
15c2			note:  
15c2				 
15c2			 
15c2 c9				ret 
15c3			 
15c3			note_send_byte: 
15c3				; byte in a 
15c3			 
15c3				; we high 
15c3 d3 40			out (Device_B), a 
15c5			;	ld a, 1 
15c5			;	call aDelayInMS 
15c5 00				nop  
15c6 00				nop  
15c7 00				nop  
15c8 00				nop  
15c9				; we low 
15c9 d3 40			out (Device_B), a 
15cb			;	ld a, 1 
15cb			;	call aDelayInMS 
15cb 00				nop  
15cc 00				nop  
15cd 00				nop  
15ce 00				nop  
15cf				; we high 
15cf d3 40			out (Device_B), a 
15d1			;	ld a, 1 
15d1			;	call aDelayInMS 
15d1 00				nop  
15d2 00				nop  
15d3 00				nop  
15d4 00				nop  
15d5			 
15d5			 
15d5 c9				ret 
15d6			 
15d6			;void SilenceAllChannels() 
15d6			;{ 
15d6			;  SendByte(0x9f); 
15d6			;  SendByte(0xbf); 
15d6			;  SendByte(0xdf); 
15d6			;  SendByte(0xff); 
15d6			;} 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound_sn76489an.asm
15d6			endif 
15d6			 
15d6			 
15d6			; Abstraction entry points 
15d6			 
15d6			; init  
15d6			 
15d6			; sound_init in specific hardware files 
15d6			 
15d6			; Play a note 
15d6			; h = note 
15d6			; l = duration 
15d6			; a = channel 
15d6			 
15d6			;note:     
15d6			;	ret 
15d6			 
15d6			 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound.asm
15d6			endif  
15d6			  
15d6			include "firmware_diags.asm"  
15d6			; Hardware diags menu 
15d6			 
15d6			 
15d6			config: 
15d6			 
15d6 3e 00			ld a, 0 
15d8 21 06 16			ld hl, .configmn 
15db cd 49 0d			call menu 
15de			 
15de fe 00			cp 0 
15e0 c8				ret z 
15e1			 
15e1 fe 01			cp 1 
15e3 cc df 16			call z, .savetostore 
15e6			 
15e6 fe 02			cp 2 
15e8 cc 2d 16			call z, .selautoload 
15eb fe 03			cp 3 
15ed cc 16 16			call z, .disautoload 
15f0 fe 04			cp 4 
15f2 cc dd 16			call z, .selbank 
15f5 fe 05			cp 5 
15f7 cc ba 17			call z, .debug_tog 
15fa fe 06			cp 6 
15fc cc fd 18			call z, .bpsgo 
15ff fe 07			cp 7 
1601 cc e0 17			call z, hardware_diags 
1604			 
1604 18 d0			jr config 
1606			 
1606			.configmn: 
1606 ee 1a			dw prom_c3 
1608 05 1b			dw prom_c2 
160a 1a 1b			dw prom_c2a 
160c 30 1b			dw prom_c2b 
160e			;	dw prom_c4 
160e 4d 1b			dw prom_m4 
1610 68 1b			dw prom_m4b 
1612 70 1b			dw prom_c1 
1614 00 00			dw 0 
1616				 
1616			 
1616			 
1616			 
1616			.disautoload: 
1616				if STORAGE_SE 
1616 3e fe			ld a, $fe      ; bit 0 clear 
1618 32 67 fa			ld (spi_device), a 
161b			 
161b cd cd 04			call storage_get_block_0 
161e			 
161e 3e 00			ld a, 0 
1620 32 a2 fa			ld (store_page+STORE_0_AUTOFILE), a 
1623			 
1623 21 00 00				ld hl, 0 
1626 11 81 fa				ld de, store_page 
1629 cd 81 04			call storage_write_block	 ; save update 
162c				else 
162c			 
162c				ld hl, prom_notav 
162c				ld de, prom_empty 
162c				call info_panel 
162c				endif 
162c			 
162c			 
162c c9				ret 
162d			 
162d			 
162d			 
162d			; Select auto start 
162d			 
162d			.selautoload: 
162d			 
162d				 
162d				if STORAGE_SE 
162d			 
162d cd 04 17				call config_dir 
1630 21 c8 f1			        ld hl, scratch 
1633 3e 00				ld a, 0 
1635 cd 49 0d				call menu 
1638			 
1638 fe 00				cp 0 
163a c8					ret z 
163b			 
163b 3d					dec a 
163c			 
163c			 
163c					; locate menu option 
163c			 
163c 21 c8 f1				ld hl, scratch 
163f cd 6d 0c				call table_lookup 
1642			 
1642					if DEBUG_FORTH_WORDS 
1642						DMARK "ALl" 
1642 f5				push af  
1643 3a 57 16			ld a, (.dmark)  
1646 32 6e fe			ld (debug_mark),a  
1649 3a 58 16			ld a, (.dmark+1)  
164c 32 6f fe			ld (debug_mark+1),a  
164f 3a 59 16			ld a, (.dmark+2)  
1652 32 70 fe			ld (debug_mark+2),a  
1655 18 03			jr .pastdmark  
1657 ..			.dmark: db "ALl"  
165a f1			.pastdmark: pop af  
165b			endm  
# End of macro DMARK
165b						CALLMONITOR 
165b cd f3 18			call break_point_state  
165e				endm  
# End of macro CALLMONITOR
165e					endif 
165e					; with the pointer to the menu it, the byte following the zero term is the file id 
165e			 
165e 3e 00				ld a, 0 
1660 01 32 00				ld bc, 50   ; max of bytes to look at 
1663 ed b1				cpir  
1665			 
1665					if DEBUG_FORTH_WORDS 
1665						DMARK "ALb" 
1665 f5				push af  
1666 3a 7a 16			ld a, (.dmark)  
1669 32 6e fe			ld (debug_mark),a  
166c 3a 7b 16			ld a, (.dmark+1)  
166f 32 6f fe			ld (debug_mark+1),a  
1672 3a 7c 16			ld a, (.dmark+2)  
1675 32 70 fe			ld (debug_mark+2),a  
1678 18 03			jr .pastdmark  
167a ..			.dmark: db "ALb"  
167d f1			.pastdmark: pop af  
167e			endm  
# End of macro DMARK
167e						CALLMONITOR 
167e cd f3 18			call break_point_state  
1681				endm  
# End of macro CALLMONITOR
1681					endif 
1681					;inc hl 
1681			 
1681 7e					ld a, (hl)   ; file id 
1682					 
1682				        ; save bank and file ids 
1682			 
1682 f5					push af 
1683			 
1683			; TODO need to save to block 0 on bank 1	 
1683			 
1683 cd cd 04				call storage_get_block_0 
1686			 
1686					if DEBUG_FORTH_WORDS 
1686						DMARK "AL0" 
1686 f5				push af  
1687 3a 9b 16			ld a, (.dmark)  
168a 32 6e fe			ld (debug_mark),a  
168d 3a 9c 16			ld a, (.dmark+1)  
1690 32 6f fe			ld (debug_mark+1),a  
1693 3a 9d 16			ld a, (.dmark+2)  
1696 32 70 fe			ld (debug_mark+2),a  
1699 18 03			jr .pastdmark  
169b ..			.dmark: db "AL0"  
169e f1			.pastdmark: pop af  
169f			endm  
# End of macro DMARK
169f						CALLMONITOR 
169f cd f3 18			call break_point_state  
16a2				endm  
# End of macro CALLMONITOR
16a2					endif 
16a2 f1					pop af 
16a3			 
16a3 32 a5 fa				ld (store_page+STORE_0_FILERUN),a 
16a6					 
16a6					; save bank id 
16a6			 
16a6 3a 67 fa				ld a,(spi_device) 
16a9 32 a4 fa				ld (store_page+STORE_0_BANKRUN),a 
16ac			 
16ac					; enable auto run of store file 
16ac			 
16ac 3e 01				ld a, 1 
16ae 32 a2 fa				ld (store_page+STORE_0_AUTOFILE),a 
16b1			 
16b1					; save buffer 
16b1			 
16b1 21 00 00				ld hl, 0 
16b4 11 81 fa				ld de, store_page 
16b7					if DEBUG_FORTH_WORDS 
16b7						DMARK "ALw" 
16b7 f5				push af  
16b8 3a cc 16			ld a, (.dmark)  
16bb 32 6e fe			ld (debug_mark),a  
16be 3a cd 16			ld a, (.dmark+1)  
16c1 32 6f fe			ld (debug_mark+1),a  
16c4 3a ce 16			ld a, (.dmark+2)  
16c7 32 70 fe			ld (debug_mark+2),a  
16ca 18 03			jr .pastdmark  
16cc ..			.dmark: db "ALw"  
16cf f1			.pastdmark: pop af  
16d0			endm  
# End of macro DMARK
16d0						CALLMONITOR 
16d0 cd f3 18			call break_point_state  
16d3				endm  
# End of macro CALLMONITOR
16d3					endif 
16d3 cd 81 04			call storage_write_block	 ; save update 
16d6			  
16d6			 
16d6			 
16d6			 
16d6 21 c8 f1				ld hl, scratch 
16d9 cd f1 16				call config_fdir 
16dc			 
16dc				else 
16dc			 
16dc				ld hl, prom_notav 
16dc				ld de, prom_empty 
16dc				call info_panel 
16dc			 
16dc				endif 
16dc c9				ret 
16dd			 
16dd			 
16dd			 
16dd			; Select storage bank 
16dd			 
16dd			.selbank: 
16dd			 
16dd				if STORAGE_SE 
16dd				else 
16dd			 
16dd				ld hl, prom_notav 
16dd				ld de, prom_empty 
16dd				call info_panel 
16dd				endif 
16dd				 
16dd c9				ret 
16de			 
16de			if STORAGE_SE 
16de			 
16de			.config_ldir:   
16de				; Load storage bank labels into menu array 
16de			 
16de				 
16de			 
16de			 
16de c9				ret 
16df			 
16df			 
16df			endif 
16df			 
16df			 
16df			; Save user words to storage 
16df			 
16df			.savetostore: 
16df			 
16df				if STORAGE_SE 
16df			 
16df cd 04 17				call config_dir 
16e2 21 c8 f1			        ld hl, scratch 
16e5 3e 00				ld a, 0 
16e7 cd 49 0d				call menu 
16ea					 
16ea 21 c8 f1				ld hl, scratch 
16ed cd f1 16				call config_fdir 
16f0			 
16f0				else 
16f0			 
16f0				ld hl, prom_notav 
16f0				ld de, prom_empty 
16f0				call info_panel 
16f0			 
16f0				endif 
16f0			 
16f0 c9				ret 
16f1			 
16f1			 
16f1			 
16f1			if STORAGE_SE 
16f1			 
16f1			config_fdir: 
16f1				; using the scratch dir go through and release the memory allocated for each string 
16f1				 
16f1 21 c8 f1			ld hl, scratch 
16f4 5e			.cfdir:	ld e,(hl) 
16f5 23				inc hl 
16f6 56				ld d,(hl) 
16f7 23				inc hl 
16f8			 
16f8 eb				ex de, hl 
16f9 cd 75 0f			call ishlzero 
16fc c8				ret z     ; return on null pointer 
16fd cd dd 14			call free 
1700 eb				ex de, hl 
1701 18 f1			jr .cfdir 
1703			 
1703			 
1703 c9				ret 
1704			 
1704			 
1704			config_dir: 
1704			 
1704				; for the config menus that need to build a directory of storage call this routine 
1704				; it will construct a menu in scratch to pass to menu 
1704			 
1704				; open storage device 
1704			 
1704				; execute DIR to build a list of files and their ids into scratch in menu format 
1704				; once the menu has finished then will need to call config_fdir to release the strings 
1704				 
1704				; c = number items 
1704			 
1704				 
1704 cd cd 04			call storage_get_block_0 
1707			 
1707 21 81 fa			ld hl, store_page     ; get current id count 
170a 46				ld b, (hl) 
170b 0e 00			ld c, 0    ; count of files   
170d			 
170d			 
170d 21 c8 f1			ld hl, scratch 
1710 22 78 fa			ld (store_tmp2), hl    ; location to poke strings 
1713			 
1713				; check for empty drive 
1713			 
1713 3e 00			ld a, 0 
1715 b8				cp b 
1716 ca b0 17			jp z, .dirdone 
1719			 
1719				 
1719					if DEBUG_FORTH_WORDS 
1719						DMARK "Cdc" 
1719 f5				push af  
171a 3a 2e 17			ld a, (.dmark)  
171d 32 6e fe			ld (debug_mark),a  
1720 3a 2f 17			ld a, (.dmark+1)  
1723 32 6f fe			ld (debug_mark+1),a  
1726 3a 30 17			ld a, (.dmark+2)  
1729 32 70 fe			ld (debug_mark+2),a  
172c 18 03			jr .pastdmark  
172e ..			.dmark: db "Cdc"  
1731 f1			.pastdmark: pop af  
1732			endm  
# End of macro DMARK
1732						CALLMONITOR 
1732 cd f3 18			call break_point_state  
1735				endm  
# End of macro CALLMONITOR
1735					endif 
1735			 
1735			 
1735			.diritem:	 
1735 c5				push bc 
1736				; for each of the current ids do a search for them and if found push to stack 
1736			 
1736 21 40 00				ld hl, STORE_BLOCK_PHY 
1739 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
173b 58					ld e,b 
173c			 
173c cd 4f 07				call storage_findnextid 
173f			 
173f			 
173f					; if found hl will be non zero 
173f			 
173f cd 75 0f				call ishlzero 
1742 28 69				jr z, .dirnotfound 
1744			 
1744					; increase count 
1744			 
1744 c1					pop bc	 
1745 0c					inc c 
1746 c5					push bc 
1747					 
1747			 
1747					; get file header and push the file name 
1747			 
1747 11 81 fa				ld de, store_page 
174a cd 1c 04				call storage_read_block 
174d			 
174d					; push file id to stack 
174d				 
174d 3a 81 fa				ld a, (store_page) 
1750 26 00				ld h, 0 
1752 6f					ld l, a 
1753			 
1753					;call forth_push_numhl 
1753					; TODO store id 
1753			 
1753 e5					push hl 
1754			 
1754					; push extent count to stack  
1754				 
1754 21 84 fa				ld hl, store_page+3 
1757			 
1757					; get file name length 
1757			 
1757 cd aa 13				call strlenz   
175a			 
175a 23					inc hl   ; cover zero term 
175b 23					inc hl  ; stick the id at the end of the area 
175c			 
175c e5					push hl 
175d c1					pop bc    ; move length to bc 
175e			 
175e cd 13 14				call malloc 
1761			 
1761					; TODO save malloc area to scratch 
1761			 
1761 eb					ex de, hl 
1762 2a 78 fa				ld hl, (store_tmp2) 
1765 73					ld (hl), e 
1766 23					inc hl 
1767 72					ld (hl), d 
1768 23					inc hl 
1769 22 78 fa				ld (store_tmp2), hl 
176c			 
176c					 
176c			 
176c					;pop hl   ; get source 
176c			;		ex de, hl    ; swap aronund	 
176c			 
176c 21 84 fa				ld hl, store_page+3 
176f					if DEBUG_FORTH_WORDS 
176f						DMARK "CFd" 
176f f5				push af  
1770 3a 84 17			ld a, (.dmark)  
1773 32 6e fe			ld (debug_mark),a  
1776 3a 85 17			ld a, (.dmark+1)  
1779 32 6f fe			ld (debug_mark+1),a  
177c 3a 86 17			ld a, (.dmark+2)  
177f 32 70 fe			ld (debug_mark+2),a  
1782 18 03			jr .pastdmark  
1784 ..			.dmark: db "CFd"  
1787 f1			.pastdmark: pop af  
1788			endm  
# End of macro DMARK
1788						CALLMONITOR 
1788 cd f3 18			call break_point_state  
178b				endm  
# End of macro CALLMONITOR
178b					endif 
178b ed b0				ldir 
178d			 
178d					; de is past string, move back one and store id 
178d					 
178d 1b					dec de 
178e			 
178e					; store file id 
178e			 
178e e1					pop hl 
178f eb					ex de,hl 
1790 73					ld (hl), e 
1791			 
1791					if DEBUG_FORTH_WORDS 
1791						DMARK "Cdi" 
1791 f5				push af  
1792 3a a6 17			ld a, (.dmark)  
1795 32 6e fe			ld (debug_mark),a  
1798 3a a7 17			ld a, (.dmark+1)  
179b 32 6f fe			ld (debug_mark+1),a  
179e 3a a8 17			ld a, (.dmark+2)  
17a1 32 70 fe			ld (debug_mark+2),a  
17a4 18 03			jr .pastdmark  
17a6 ..			.dmark: db "Cdi"  
17a9 f1			.pastdmark: pop af  
17aa			endm  
# End of macro DMARK
17aa						CALLMONITOR 
17aa cd f3 18			call break_point_state  
17ad				endm  
# End of macro CALLMONITOR
17ad					endif 
17ad					 
17ad			.dirnotfound: 
17ad c1					pop bc     
17ae 10 85				djnz .diritem 
17b0				 
17b0			.dirdone:	 
17b0			 
17b0 3e 00				ld a, 0 
17b2 2a 78 fa				ld hl, (store_tmp2) 
17b5 77					ld (hl), a 
17b6 23					inc hl 
17b7 77					ld (hl), a 
17b8 23					inc hl 
17b9					; push a count of the dir items found 
17b9			 
17b9			;		ld h, 0 
17b9			;		ld l, c 
17b9			 
17b9 c9				ret 
17ba			 
17ba			endif 
17ba			 
17ba			 
17ba			; Settings 
17ba			; Run  
17ba			 
17ba			 
17ba			 
17ba			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
17ba			;;hd_menu2:   db "        2: Editor",0   
17ba			;hd_menu2:   db "        2: Editor       6: Menu",0   
17ba			;hd_menu3:   db "        3: Storage",0 
17ba			;hd_menu4:   db "0=quit  4: Debug",0 
17ba			;hd_don:     db "ON",0 
17ba			;hd_doff:     db "OFF",0 
17ba			; 
17ba			; 
17ba			; 
17ba			;hardware_diags_old:       
17ba			; 
17ba			;.diagmenu: 
17ba			;	call clear_display 
17ba			;	ld a, display_row_1 
17ba			;	ld de, hd_menu1 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a, display_row_2 
17ba			;	ld de, hd_menu2 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a, display_row_3 
17ba			;	ld de, hd_menu3 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a,  display_row_4 
17ba			;	ld de, hd_menu4 
17ba			;	call str_at_display 
17ba			; 
17ba			;	; display debug state 
17ba			; 
17ba			;	ld de, hd_don 
17ba			;	ld a, (os_view_disable) 
17ba			;	cp 0 
17ba			;	jr z, .distog 
17ba			;	ld de, hd_doff 
17ba			;.distog: ld a, display_row_4+17 
17ba			;	call str_at_display 
17ba			; 
17ba			;	call update_display 
17ba			; 
17ba			;	call cin_wait 
17ba			; 
17ba			; 
17ba			; 
17ba			;	cp '4' 
17ba			;	jr nz, .diagn1 
17ba			; 
17ba			;	; debug toggle 
17ba			; 
17ba			;	ld a, (os_view_disable) 
17ba			;	ld b, '*' 
17ba			;	cp 0 
17ba			;	jr z, .debtog 
17ba			;	ld b, 0 
17ba			;.debtog:	 
17ba			;	ld a,b 
17ba			;	ld (os_view_disable),a 
17ba			; 
17ba			;.diagn1: cp '0' 
17ba			;	 ret z 
17ba			; 
17ba			;;	cp '1' 
17ba			;;       jp z, matrix	 
17ba			;;   TODO keyboard matrix test 
17ba			; 
17ba			;	cp '2' 
17ba			;	jp z, .diagedit 
17ba			; 
17ba			;;	cp '6' 
17ba			;;	jp z, .menutest 
17ba			;;if ENABLE_BASIC 
17ba			;;	cp '6' 
17ba			;;	jp z, basic 
17ba			;;endif 
17ba			 ; 
17ba			;	jp .diagmenu 
17ba			; 
17ba			; 
17ba			;	ret 
17ba			 
17ba			 
17ba			.debug_tog: 
17ba 21 01 18			ld hl, .menudebug 
17bd				 
17bd 3a b9 f1			ld a, (os_view_disable) 
17c0 fe 2a			cp '*' 
17c2 20 04			jr nz,.tdon  
17c4 3e 01			ld a, 1 
17c6 18 02			jr .tog1 
17c8 3e 00		.tdon: ld a, 0 
17ca			 
17ca			.tog1: 
17ca cd 49 0d			call menu 
17cd fe 00			cp 0 
17cf c8				ret z 
17d0 fe 01			cp 1    ; disable debug 
17d2 28 04			jr z, .dtog0 
17d4 3e 2a			ld a, '*' 
17d6 18 02			jr .dtogset 
17d8 3e 00		.dtog0: ld a, 0 
17da 32 b9 f1		.dtogset:  ld (os_view_disable), a 
17dd c3 ba 17			jp .debug_tog 
17e0			 
17e0			 
17e0			hardware_diags:       
17e0			 
17e0			.diagm: 
17e0 21 f3 17			ld hl, .menuitems 
17e3 3e 00			ld a, 0 
17e5 cd 49 0d			call menu 
17e8			 
17e8 fe 00		         cp 0 
17ea c8				 ret z 
17eb			 
17eb fe 02			cp 2 
17ed ca 4c 18			jp z, .diagedit 
17f0			 
17f0			;	cp '6' 
17f0			;	jp z, .menutest 
17f0			;if ENABLE_BASIC 
17f0			;	cp '6' 
17f0			;	jp z, basic 
17f0			;endif 
17f0			  
17f0 c3 e0 17			jp .diagm 
17f3			 
17f3				 
17f3 07 18		.menuitems:   	dw .m1 
17f5 12 18				dw .m2 
17f7 19 18				dw .m3 
17f9 21 18				dw .m5 
17fb 27 18				dw .m5a 
17fd 30 18				dw .m5b 
17ff 00 00				dw 0 
1801			 
1801			.menudebug: 
1801 39 18				dw .m6 
1803 42 18				dw .m7 
1805 00 00				dw 0 
1807			 
1807 .. 00		.m1:   db "Key Matrix",0 
1812 .. 00		.m2:   db "Editor",0 
1819 .. 00		.m3:   db "Storage",0 
1821 .. 00		.m5:   db "Sound",0 
1827 .. 00		.m5a:  db "RAM Test",0 
1830 .. 00		.m5b:  db "LCD Test",0 
1839			 
1839 .. 00		.m6:   db "Debug ON",0 
1842 .. 00		.m7:   db "Debug OFF",0 
184c			 
184c			; debug editor 
184c			 
184c			.diagedit: 
184c			 
184c 21 c8 f1			ld hl, scratch 
184f			;	ld bc, 250 
184f			;	ldir 
184f				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
184f 3e 00			ld a, 0 
1851 77				ld (hl), a 
1852 23				inc hl 
1853 77				ld (hl), a 
1854 23				inc hl 
1855 77				ld (hl), a 
1856			 
1856 cd 18 0d		        call clear_display 
1859 cd 3b 0d			call update_display 
185c				;ld a, 1 
185c				;ld (hardware_diag), a 
185c			.diloop: 
185c 3e 00			ld a, display_row_1 
185e 0e 00			ld c, 0 
1860 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1862 1e 28			ld e, 40 
1864			 
1864 21 c8 f1			ld hl, scratch	 
1867 cd 79 0f			call input_str 
186a			 
186a 3e 28			ld a, display_row_2 
186c 11 c8 f1			ld de, scratch 
186f cd 2b 0d			call str_at_display 
1872 cd 3b 0d			call update_display 
1875			 
1875 c3 5c 18			jp .diloop 
1878			 
1878			 
1878			; pass word in hl 
1878			; a has display location 
1878			display_word_at: 
1878 f5				push af 
1879 e5				push hl 
187a 7c				ld a,h 
187b 21 cd f4			ld hl, os_word_scratch 
187e cd 4d 12			call hexout 
1881 e1				pop hl 
1882 7d				ld a,l 
1883 21 cf f4			ld hl, os_word_scratch+2 
1886 cd 4d 12			call hexout 
1889 21 d1 f4			ld hl, os_word_scratch+4 
188c 3e 00			ld a,0 
188e 77				ld (hl),a 
188f 11 cd f4			ld de,os_word_scratch 
1892 f1				pop af 
1893 cd 2b 0d				call str_at_display 
1896 c9				ret 
1897			 
1897			display_ptr_state: 
1897			 
1897				; to restore afterwards 
1897			 
1897 d5				push de 
1898 c5				push bc 
1899 e5				push hl 
189a f5				push af 
189b			 
189b				; for use in here 
189b			 
189b			;	push bc 
189b			;	push de 
189b			;	push hl 
189b			;	push af 
189b			 
189b cd 18 0d			call clear_display 
189e			 
189e 11 71 1a			ld de, .ptrstate 
18a1 3e 00			ld a, display_row_1 
18a3 cd 2b 0d			call str_at_display 
18a6			 
18a6				; display debug step 
18a6			 
18a6			 
18a6 11 6e fe			ld de, debug_mark 
18a9 3e 26			ld a, display_row_1+display_cols-2 
18ab cd 2b 0d			call str_at_display 
18ae			 
18ae				; display a 
18ae 11 7b 1a			ld de, .ptrcliptr 
18b1 3e 28			ld a, display_row_2 
18b3 cd 2b 0d			call str_at_display 
18b6			 
18b6 f1				pop af 
18b7 2a 47 fa			ld hl,(cli_ptr) 
18ba 3e 30			ld a, display_row_2+8 
18bc cd 78 18			call display_word_at 
18bf			 
18bf			 
18bf				; display hl 
18bf			 
18bf			 
18bf 11 83 1a			ld de, .ptrclioptr 
18c2 3e 32			ld a, display_row_2+10 
18c4 cd 2b 0d			call str_at_display 
18c7			; 
18c7			;	pop hl 
18c7 3e 35			ld a, display_row_2+13 
18c9 2a 45 fa			ld hl,(cli_origptr) 
18cc cd 78 18			call display_word_at 
18cf			; 
18cf			;	 
18cf			;	; display de 
18cf			 
18cf			;	ld de, .regstatede 
18cf			;	ld a, display_row_3 
18cf			;	call str_at_display 
18cf			 
18cf			;	pop de 
18cf			;	ld h,d 
18cf			;	ld l, e 
18cf			;	ld a, display_row_3+3 
18cf			;	call display_word_at 
18cf			 
18cf			 
18cf				; display bc 
18cf			 
18cf			;	ld de, .regstatebc 
18cf			;	ld a, display_row_3+10 
18cf			;	call str_at_display 
18cf			 
18cf			;	pop bc 
18cf			;	ld h,b 
18cf			;	ld l, c 
18cf			;	ld a, display_row_3+13 
18cf			;	call display_word_at 
18cf			 
18cf			 
18cf				; display dsp 
18cf			 
18cf			;	ld de, .regstatedsp 
18cf			;	ld a, display_row_4 
18cf			;	call str_at_display 
18cf			 
18cf				 
18cf			;	ld hl,(cli_data_sp) 
18cf			;	ld a, display_row_4+4 
18cf			;	call display_word_at 
18cf			 
18cf				; display rsp 
18cf			 
18cf 11 b2 1a			ld de, .regstatersp 
18d2 3e 82			ld a, display_row_4+10 
18d4 cd 2b 0d			call str_at_display 
18d7			 
18d7				 
18d7 2a f9 f9			ld hl,(cli_ret_sp) 
18da 3e 86			ld a, display_row_4+14 
18dc cd 78 18			call display_word_at 
18df			 
18df cd 3b 0d			call update_display 
18e2			 
18e2 cd 95 0c			call delay1s 
18e5 cd 95 0c			call delay1s 
18e8 cd 95 0c			call delay1s 
18eb			 
18eb			 
18eb cd df 1e			call next_page_prompt 
18ee			 
18ee				; restore  
18ee			 
18ee f1				pop af 
18ef e1				pop hl 
18f0 c1				pop bc 
18f1 d1				pop de 
18f2 c9				ret 
18f3			 
18f3			break_point_state: 
18f3 f5				push af 
18f4			 
18f4				; see if disabled 
18f4			 
18f4 3a b9 f1			ld a, (os_view_disable) 
18f7 fe 2a			cp '*' 
18f9 20 02			jr nz, .bpsgo 
18fb f1				pop af 
18fc c9				ret 
18fd			 
18fd			.bpsgo: 
18fd f1				pop af 
18fe f5				push af 
18ff 22 b5 f1			ld (os_view_hl), hl 
1902 ed 53 b3 f1		ld (os_view_de), de 
1906 ed 43 b1 f1		ld (os_view_bc), bc 
190a e5				push hl 
190b 6f				ld l, a 
190c 26 00			ld h, 0 
190e 22 b7 f1			ld (os_view_af),hl 
1911			 
1911 21 b4 fd				ld hl, display_fb0 
1914 22 cf fb				ld (display_fb_active), hl 
1917 e1				pop hl	 
1918			 
1918 3e 31			ld a, '1' 
191a fe 2a		.bps1:  cp '*' 
191c 20 03			jr nz, .bps1b 
191e 32 b9 f1			ld (os_view_disable),a 
1921 fe 31		.bps1b:  cp '1' 
1923 20 14			jr nz, .bps2 
1925			 
1925				; display reg 
1925			 
1925				 
1925			 
1925 3a b7 f1			ld a, (os_view_af) 
1928 2a b5 f1			ld hl, (os_view_hl) 
192b ed 5b b3 f1		ld de, (os_view_de) 
192f ed 4b b1 f1		ld bc, (os_view_bc) 
1933 cd cd 19			call display_reg_state 
1936 c3 b9 19			jp .bpschk 
1939			 
1939 fe 32		.bps2:  cp '2' 
193b 20 08			jr nz, .bps3 
193d				 
193d				; display hl 
193d 2a b5 f1			ld hl, (os_view_hl) 
1940 cd b7 1a			call display_dump_at_hl 
1943			 
1943 18 74			jr .bpschk 
1945			 
1945 fe 33		.bps3:  cp '3' 
1947 20 08			jr nz, .bps4 
1949			 
1949			        ; display de 
1949 2a b3 f1			ld hl, (os_view_de) 
194c cd b7 1a			call display_dump_at_hl 
194f			 
194f 18 68			jr .bpschk 
1951 fe 34		.bps4:  cp '4' 
1953 20 08			jr nz, .bps5 
1955			 
1955			        ; display bc 
1955 2a b1 f1			ld hl, (os_view_bc) 
1958 cd b7 1a			call display_dump_at_hl 
195b			 
195b 18 5c			jr .bpschk 
195d fe 35		.bps5:  cp '5' 
195f 20 08		        jr nz, .bps7 
1961			 
1961				; display cur ptr 
1961 2a 47 fa			ld hl, (cli_ptr) 
1964 cd b7 1a			call display_dump_at_hl 
1967			 
1967 18 50			jr .bpschk 
1969 fe 36		.bps7:  cp '6' 
196b 20 08			jr nz, .bps8b 
196d				 
196d				; display cur orig ptr 
196d 2a 45 fa			ld hl, (cli_origptr) 
1970 cd b7 1a			call display_dump_at_hl 
1973 18 44			jr .bpschk 
1975 fe 37		.bps8b:  cp '7' 
1977 20 08			jr nz, .bps9 
1979				 
1979				; display dsp 
1979 2a f5 f9			ld hl, (cli_data_sp) 
197c cd b7 1a			call display_dump_at_hl 
197f			 
197f 18 38			jr .bpschk 
1981 fe 39		.bps9:  cp '9' 
1983 20 05			jr nz, .bps8c 
1985				 
1985				; display SP 
1985			;	ld hl, sp 
1985 cd b7 1a			call display_dump_at_hl 
1988			 
1988 18 2f			jr .bpschk 
198a fe 38		.bps8c:  cp '8' 
198c 20 08			jr nz, .bps8d 
198e				 
198e				; display rsp 
198e 2a f9 f9			ld hl, (cli_ret_sp) 
1991 cd b7 1a			call display_dump_at_hl 
1994			 
1994 18 23			jr .bpschk 
1996 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1998 20 05			jr nz, .bps8 
199a cd d5 1c			call monitor 
199d			 
199d 18 1a			jr .bpschk 
199f fe 30		.bps8:  cp '0' 
19a1 20 16			jr nz, .bpschk 
19a3			 
19a3 21 13 fd				ld hl, display_fb1 
19a6 22 cf fb				ld (display_fb_active), hl 
19a9 cd 3b 0d				call update_display 
19ac			 
19ac				;ld a, (os_view_af) 
19ac 2a b5 f1			ld hl, (os_view_hl) 
19af ed 5b b3 f1		ld de, (os_view_de) 
19b3 ed 4b b1 f1		ld bc, (os_view_bc) 
19b7 f1				pop af 
19b8 c9				ret 
19b9			 
19b9			.bpschk:   
19b9 cd 95 0c			call delay1s 
19bc 3e 9f		ld a,display_row_4 + display_cols - 1 
19be 11 dd 1e		        ld de, endprg 
19c1 cd 2b 0d			call str_at_display 
19c4 cd 3b 0d			call update_display 
19c7 cd a9 73			call cin_wait 
19ca			 
19ca c3 1a 19			jp .bps1 
19cd			 
19cd			 
19cd			display_reg_state: 
19cd			 
19cd				; to restore afterwards 
19cd			 
19cd d5				push de 
19ce c5				push bc 
19cf e5				push hl 
19d0 f5				push af 
19d1			 
19d1				; for use in here 
19d1			 
19d1 c5				push bc 
19d2 d5				push de 
19d3 e5				push hl 
19d4 f5				push af 
19d5			 
19d5 cd 18 0d			call clear_display 
19d8			 
19d8 11 8d 1a			ld de, .regstate 
19db 3e 00			ld a, display_row_1 
19dd cd 2b 0d			call str_at_display 
19e0			 
19e0				; display debug step 
19e0			 
19e0			 
19e0 11 6e fe			ld de, debug_mark 
19e3 3e 25			ld a, display_row_1+display_cols-3 
19e5 cd 2b 0d			call str_at_display 
19e8			 
19e8				; display a 
19e8 11 a9 1a			ld de, .regstatea 
19eb 3e 28			ld a, display_row_2 
19ed cd 2b 0d			call str_at_display 
19f0			 
19f0 e1				pop hl 
19f1			;	ld h,0 
19f1			;	ld l, a 
19f1 3e 2b			ld a, display_row_2+3 
19f3 cd 78 18			call display_word_at 
19f6			 
19f6			 
19f6				; display hl 
19f6			 
19f6			 
19f6 11 9d 1a			ld de, .regstatehl 
19f9 3e 32			ld a, display_row_2+10 
19fb cd 2b 0d			call str_at_display 
19fe			 
19fe e1				pop hl 
19ff 3e 35			ld a, display_row_2+13 
1a01 cd 78 18			call display_word_at 
1a04			 
1a04				 
1a04				; display de 
1a04			 
1a04 11 a1 1a			ld de, .regstatede 
1a07 3e 50			ld a, display_row_3 
1a09 cd 2b 0d			call str_at_display 
1a0c			 
1a0c e1				pop hl 
1a0d			;	ld h,d 
1a0d			;	ld l, e 
1a0d 3e 53			ld a, display_row_3+3 
1a0f cd 78 18			call display_word_at 
1a12			 
1a12			 
1a12				; display bc 
1a12			 
1a12 11 a5 1a			ld de, .regstatebc 
1a15 3e 5a			ld a, display_row_3+10 
1a17 cd 2b 0d			call str_at_display 
1a1a			 
1a1a e1				pop hl 
1a1b			;	ld h,b 
1a1b			;	ld l, c 
1a1b 3e 5d			ld a, display_row_3+13 
1a1d cd 78 18			call display_word_at 
1a20			 
1a20			 
1a20				; display dsp 
1a20			 
1a20 11 ad 1a			ld de, .regstatedsp 
1a23 3e 78			ld a, display_row_4 
1a25 cd 2b 0d			call str_at_display 
1a28			 
1a28				 
1a28 2a f5 f9			ld hl,(cli_data_sp) 
1a2b 3e 7c			ld a, display_row_4+4 
1a2d cd 78 18			call display_word_at 
1a30			 
1a30				; display rsp 
1a30			 
1a30 11 b2 1a			ld de, .regstatersp 
1a33 3e 82			ld a, display_row_4+10 
1a35 cd 2b 0d			call str_at_display 
1a38			 
1a38				 
1a38 2a f9 f9			ld hl,(cli_ret_sp) 
1a3b 3e 86			ld a, display_row_4+14 
1a3d cd 78 18			call display_word_at 
1a40			 
1a40 cd 3b 0d			call update_display 
1a43			 
1a43			;	call delay1s 
1a43			;	call delay1s 
1a43			;	call delay1s 
1a43			 
1a43			 
1a43			;	call next_page_prompt 
1a43			 
1a43				; restore  
1a43			 
1a43 f1				pop af 
1a44 e1				pop hl 
1a45 c1				pop bc 
1a46 d1				pop de 
1a47 c9				ret 
1a48			 
1a48 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a5c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a71 .. 00		.ptrstate:	db "Ptr State",0 
1a7b .. 00		.ptrcliptr:     db "cli_ptr",0 
1a83 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a8d .. 00		.regstate:	db "Reg State (1/0)",0 
1a9d .. 00		.regstatehl:	db "HL:",0 
1aa1 .. 00		.regstatede:	db "DE:",0 
1aa5 .. 00		.regstatebc:	db "BC:",0 
1aa9 .. 00		.regstatea:	db "A :",0 
1aad .. 00		.regstatedsp:	db "DSP:",0 
1ab2 .. 00		.regstatersp:	db "RSP:",0 
1ab7			 
1ab7			display_dump_at_hl: 
1ab7 e5				push hl 
1ab8 d5				push de 
1ab9 c5				push bc 
1aba f5				push af 
1abb			 
1abb 22 eb f4			ld (os_cur_ptr),hl	 
1abe cd 18 0d			call clear_display 
1ac1 cd e7 1d			call dumpcont 
1ac4			;	call delay1s 
1ac4			;	call next_page_prompt 
1ac4			 
1ac4			 
1ac4 f1				pop af 
1ac5 c1				pop bc 
1ac6 d1				pop de 
1ac7 e1				pop hl 
1ac8 c9				ret 
1ac9			 
1ac9			;if ENABLE_BASIC 
1ac9			;	include "nascombasic.asm" 
1ac9			;	basic: 
1ac9			;	include "forth/FORTH.ASM" 
1ac9			;endif 
1ac9			 
1ac9			; eof 
1ac9			 
1ac9			 
# End of file firmware_diags.asm
1ac9			  
1ac9			include "firmware_prompts.asm"  
1ac9			; Prompts  
1ac9			 
1ac9			; boot messages 
1ac9			 
1ac9 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1ade .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1aee			 
1aee			 
1aee			; config menus 
1aee			 
1aee .. 00		prom_c3: db "Add Dictionary To File",0 
1b05 .. 00		prom_c2: db "Select Autoload File",0 
1b1a .. 00		prom_c2a: db "Disable Autoload File", 0 
1b30 .. 00		prom_c2b: db "Select Storage Bank",0 
1b44 .. 00		prom_c4: db "Settings",0 
1b4d .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b68 .. 00		prom_m4b:   db "Monitor",0 
1b70 .. 00		prom_c1: db "Hardware Diags",0 
1b7f			 
1b7f			 
1b7f .. 00		prom_notav:    db "Feature not available",0 
1b95 .. 00		prom_empty:    db "",0 
1b96			 
1b96			; eof 
1b96			 
# End of file firmware_prompts.asm
1b96			  
1b96			  
1b96			; eof  
1b96			  
# End of file firmware.asm
1b96			 
1b96			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b96			;if BASE_KEV  
1b96			;baseram: equ 08000h 
1b96			;endif 
1b96			 
1b96			;if BASE_SC114 
1b96			;baseram:     equ    endofcode 
1b96			;endif 
1b96			 
1b96			 
1b96			; start system 
1b96			 
1b96			coldstart: 
1b96				; set sp 
1b96				; di/ei 
1b96			 
1b96 f3				di 
1b97 31 fd ff			ld sp, tos 
1b9a			;	ei 
1b9a			 
1b9a			 
1b9a				; disable breakpoint by default 
1b9a			 
1b9a 3e 2a			ld a,'*' 
1b9c 32 b9 f1			ld (os_view_disable),a 
1b9f			 
1b9f				; init hardware 
1b9f			 
1b9f				; init keyboard and screen hardware 
1b9f			 
1b9f cd 1c 00			call hardware_init 
1ba2			 
1ba2			 
1ba2 cd 95 0c			call delay1s 
1ba5 3e 58			ld a, display_row_3+8 
1ba7 11 03 00			ld de, buildtime 
1baa cd 2b 0d			call str_at_display 
1bad cd 3b 0d			call update_display 
1bb0			 
1bb0 cd 95 0c			call delay1s 
1bb3 cd 95 0c			call delay1s 
1bb6 cd 95 0c			call delay1s 
1bb9			 
1bb9				; detect if any keys are held down to enable breakpoints at start up 
1bb9			 
1bb9 cd ba 73			call cin  
1bbc fe 00			cp 0 
1bbe 28 03			jr z, .nokeys 
1bc0			 
1bc0				;call hardware_diags 
1bc0 cd d6 15			call config 
1bc3			 
1bc3			;	ld de, .bpen 
1bc3			;	ld a, display_row_4 
1bc3			;	call str_at_display 
1bc3			;	call update_display 
1bc3			; 
1bc3			;	ld a,0 
1bc3			;	ld (os_view_disable),a 
1bc3			; 
1bc3			;.bpwait: 
1bc3			;	call cin 
1bc3			;	cp 0 
1bc3			;	jr z, .bpwait 
1bc3			;	jr .nokeys 
1bc3			; 
1bc3			; 
1bc3			;.bpen:  db "Break points enabled!",0 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			.nokeys: 
1bc3			 
1bc3			 
1bc3				 
1bc3			 
1bc3			;jp  testkey 
1bc3			 
1bc3			;call storage_get_block_0 
1bc3			; 
1bc3			;ld hl, 0 
1bc3			;ld de, store_page 
1bc3			;call storage_read_block 
1bc3			 
1bc3				 
1bc3			;ld hl, 10 
1bc3			;ld de, store_page 
1bc3			;call storage_read_block 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			;stop:	nop 
1bc3			;	jp stop 
1bc3			 
1bc3			 
1bc3			 
1bc3			main: 
1bc3 cd 18 0d			call clear_display 
1bc6 cd 3b 0d			call update_display 
1bc9			 
1bc9			 
1bc9			 
1bc9			;	call testlcd 
1bc9			 
1bc9			 
1bc9			 
1bc9 cd dd 22			call forth_init 
1bcc			 
1bcc			 
1bcc			warmstart: 
1bcc cd b3 22			call forth_warmstart 
1bcf			 
1bcf				; run startup word load 
1bcf			        ; TODO prevent this running at warmstart after crash  
1bcf			 
1bcf				if STARTUP_ENABLE 
1bcf					if STORAGE_SE 
1bcf cd 48 6f					call forth_autoload 
1bd2					endif 
1bd2 cd 57 6c				call forth_startup 
1bd5			 
1bd5			 
1bd5				endif 
1bd5			 
1bd5				; show free memory after boot 
1bd5 11 6f 1c			ld de, freeram 
1bd8 3e 00			ld a, display_row_1 
1bda cd 2b 0d			call str_at_display 
1bdd			 
1bdd			; Or use heap_size word???? 
1bdd 21 ae f1			ld hl, heap_end 
1be0 11 0e 80			ld de, heap_start 
1be3 ed 52			sbc hl, de 
1be5 e5				push hl 
1be6 7c				ld a,h	         	 
1be7 21 cd f4			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bea cd 4d 12			call hexout 
1bed e1			   	pop hl 
1bee			 
1bee 7d				ld a,l 
1bef 21 cf f4			ld hl, os_word_scratch+2 
1bf2 cd 4d 12			call hexout 
1bf5 21 d1 f4			ld hl, os_word_scratch+4 
1bf8 3e 00			ld a, 0 
1bfa 77				ld (hl),a 
1bfb 11 cd f4			ld de, os_word_scratch 
1bfe 3e 0d			ld a, display_row_1 + 13 
1c00 cd 2b 0d			call str_at_display 
1c03 cd 3b 0d			call update_display 
1c06			 
1c06			 
1c06				;call demo 
1c06			 
1c06			 
1c06				; init scratch input area for cli commands 
1c06			 
1c06 21 ef f4			ld hl, os_cli_cmd 
1c09 3e 00			ld a,0 
1c0b 77				ld (hl),a 
1c0c 23				inc hl 
1c0d 77				ld (hl),a 
1c0e			 
1c0e 3e 00			ld a,0 
1c10 32 ee f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1c13			 
1c13 32 eb f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1c16 32 ec f4			ld (os_cur_ptr+1),a	 
1c19			 
1c19 32 cd f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1c1c 32 ce f4			ld (os_word_scratch+1),a	 
1c1f				 
1c1f			 
1c1f				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c1f 21 ef f4			ld hl, os_cli_cmd 
1c22			 
1c22 3e 00			ld a, 0		 ; init cli input 
1c24 77				ld (hl), a 
1c25 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c27			cli: 
1c27				; show cli prompt 
1c27				;push af 
1c27				;ld a, 0 
1c27				;ld de, prompt 
1c27				;call str_at_display 
1c27			 
1c27				;call update_display 
1c27				;pop af 
1c27				;inc a 
1c27				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c27 0e 00			ld c, 0 
1c29 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1c2b 1e 28			ld e, 40 
1c2d			 
1c2d 21 ef f4			ld hl, os_cli_cmd 
1c30			 
1c30				STACKFRAME OFF $fefe $9f9f 
1c30				if DEBUG_STACK_IMB 
1c30					if OFF 
1c30						exx 
1c30						ld de, $fefe 
1c30						ld a, d 
1c30						ld hl, curframe 
1c30						call hexout 
1c30						ld a, e 
1c30						ld hl, curframe+2 
1c30						call hexout 
1c30						ld hl, $fefe 
1c30						push hl 
1c30						ld hl, $9f9f 
1c30						push hl 
1c30						exx 
1c30					endif 
1c30				endif 
1c30			endm 
# End of macro STACKFRAME
1c30			 
1c30 cd 79 0f			call input_str 
1c33			 
1c33				STACKFRAMECHK OFF $fefe $9f9f 
1c33				if DEBUG_STACK_IMB 
1c33					if OFF 
1c33						exx 
1c33						ld hl, $9f9f 
1c33						pop de   ; $9f9f 
1c33						call cmp16 
1c33						jr nz, .spnosame 
1c33						ld hl, $fefe 
1c33						pop de   ; $fefe 
1c33						call cmp16 
1c33						jr z, .spfrsame 
1c33						.spnosame: call showsperror 
1c33						.spfrsame: nop 
1c33						exx 
1c33					endif 
1c33				endif 
1c33			endm 
# End of macro STACKFRAMECHK
1c33			 
1c33				; copy input to last command 
1c33			 
1c33 21 ef f4			ld hl, os_cli_cmd 
1c36 11 ee f5			ld de, os_last_cmd 
1c39 01 ff 00			ld bc, 255 
1c3c ed b0			ldir 
1c3e			 
1c3e				; wipe current buffer 
1c3e			 
1c3e			;	ld a, 0 
1c3e			;	ld hl, os_cli_cmd 
1c3e			;	ld de, os_cli_cmd+1 
1c3e			;	ld bc, 254 
1c3e			;	ldir 
1c3e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1c3e			;	call strcpy 
1c3e			;	ld a, 0 
1c3e			;	ld (hl), a 
1c3e			;	inc hl 
1c3e			;	ld (hl), a 
1c3e			;	inc hl 
1c3e			;	ld (hl), a 
1c3e			 
1c3e				; switch frame buffer to program  
1c3e			 
1c3e 21 13 fd				ld hl, display_fb1 
1c41 22 cf fb				ld (display_fb_active), hl 
1c44			 
1c44			;	nop 
1c44				STACKFRAME ON $fbfe $8f9f 
1c44				if DEBUG_STACK_IMB 
1c44					if ON 
1c44						exx 
1c44						ld de, $fbfe 
1c44						ld a, d 
1c44						ld hl, curframe 
1c44						call hexout 
1c44						ld a, e 
1c44						ld hl, curframe+2 
1c44						call hexout 
1c44						ld hl, $fbfe 
1c44						push hl 
1c44						ld hl, $8f9f 
1c44						push hl 
1c44						exx 
1c44					endif 
1c44				endif 
1c44			endm 
# End of macro STACKFRAME
1c44				; first time into the parser so pass over the current scratch pad 
1c44 21 ef f4			ld hl,os_cli_cmd 
1c47				; tokenise the entered statement(s) in HL 
1c47 cd 5b 23			call forthparse 
1c4a			        ; exec forth statements in top of return stack 
1c4a cd 9b 23			call forthexec 
1c4d				;call forthexec_cleanup 
1c4d			;	call parsenext 
1c4d			 
1c4d				STACKFRAMECHK ON $fbfe $8f9f 
1c4d				if DEBUG_STACK_IMB 
1c4d					if ON 
1c4d						exx 
1c4d						ld hl, $8f9f 
1c4d						pop de   ; $8f9f 
1c4d						call cmp16 
1c4d						jr nz, .spnosame 
1c4d						ld hl, $fbfe 
1c4d						pop de   ; $fbfe 
1c4d						call cmp16 
1c4d						jr z, .spfrsame 
1c4d						.spnosame: call showsperror 
1c4d						.spfrsame: nop 
1c4d						exx 
1c4d					endif 
1c4d				endif 
1c4d			endm 
# End of macro STACKFRAMECHK
1c4d				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1c4d			 
1c4d 3e 78			ld a, display_row_4 
1c4f 11 81 1c			ld de, endprog 
1c52			 
1c52 cd 3b 0d			call update_display		 
1c55			 
1c55 cd df 1e			call next_page_prompt 
1c58			 
1c58				; switch frame buffer to cli 
1c58			 
1c58 21 b4 fd				ld hl, display_fb0 
1c5b 22 cf fb				ld (display_fb_active), hl 
1c5e			 
1c5e			 
1c5e cd 18 0d		        call clear_display 
1c61 cd 3b 0d			call update_display		 
1c64			 
1c64 21 ef f4			ld hl, os_cli_cmd 
1c67			 
1c67 3e 00			ld a, 0		 ; init cli input 
1c69 77				ld (hl), a 
1c6a			 
1c6a				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c6a			 
1c6a				; now on last line 
1c6a			 
1c6a				; TODO scroll screen up 
1c6a			 
1c6a				; TODO instead just clear screen and place at top of screen 
1c6a			 
1c6a			;	ld a, 0 
1c6a			;	ld (f_cursor_ptr),a 
1c6a			 
1c6a				;call clear_display 
1c6a				;call update_display 
1c6a			 
1c6a				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c6a 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c6c c3 27 1c			jp cli 
1c6f			 
1c6f .. 00		freeram: db "Free bytes: $",0 
1c7d ..			asc: db "1A2F" 
1c81 .. 00		endprog: db "End prog...",0 
1c8d			 
1c8d			testenter2:   
1c8d 21 fa f1			ld hl,scratch+50 
1c90 22 eb f4			ld (os_cur_ptr),hl 
1c93 c3 27 1c			jp cli 
1c96			 
1c96			testenter:  
1c96			 
1c96 21 7d 1c			ld hl,asc 
1c99			;	ld a,(hl) 
1c99			;	call nibble2val 
1c99 cd a3 12			call get_byte 
1c9c			 
1c9c			 
1c9c			;	ld a,(hl) 
1c9c			;	call atohex 
1c9c			 
1c9c			;	call fourehexhl 
1c9c 32 fa f1			ld (scratch+50),a 
1c9f			 
1c9f			 
1c9f			 
1c9f 21 7f 1c			ld hl,asc+2 
1ca2			;	ld a, (hl) 
1ca2			;	call nibble2val 
1ca2 cd a3 12			call get_byte 
1ca5			 
1ca5			;	call fourehexhl 
1ca5 32 fc f1			ld (scratch+52),a 
1ca8				 
1ca8 21 fa f1			ld hl,scratch+50 
1cab 22 eb f4			ld (os_cur_ptr),hl 
1cae c3 27 1c			jp cli 
1cb1			 
1cb1			enter:	 
1cb1 3a cc f1			ld a,(scratch+4) 
1cb4 fe 00			cp 0 
1cb6 28 0c			jr z, .entercont 
1cb8				; no, not a null term line so has an address to work out.... 
1cb8			 
1cb8 21 ca f1			ld hl,scratch+2 
1cbb cd 03 13			call get_word_hl 
1cbe			 
1cbe 22 eb f4			ld (os_cur_ptr),hl	 
1cc1 c3 27 1c			jp cli 
1cc4			 
1cc4			 
1cc4			.entercont:  
1cc4			 
1cc4 21 ca f1			ld hl, scratch+2 
1cc7 cd a3 12			call get_byte 
1cca			 
1cca 2a eb f4		   	ld hl,(os_cur_ptr) 
1ccd 77					ld (hl),a 
1cce 23					inc hl 
1ccf 22 eb f4				ld (os_cur_ptr),hl 
1cd2				 
1cd2			; get byte  
1cd2			 
1cd2			 
1cd2 c3 27 1c			jp cli 
1cd5			 
1cd5			 
1cd5			; basic monitor support 
1cd5			 
1cd5			monitor: 
1cd5				;  
1cd5 cd 18 0d			call clear_display 
1cd8 3e 00			ld a, 0 
1cda 11 22 1d			ld de, .monprompt 
1cdd cd 2b 0d			call str_at_display 
1ce0 cd 3b 0d			call update_display 
1ce3			 
1ce3				; get a monitor command 
1ce3			 
1ce3 0e 00			ld c, 0     ; entry at top left 
1ce5 16 64			ld d, 100   ; max buffer size 
1ce7 1e 0f			ld e, 15    ; input scroll area 
1ce9 3e 00			ld a, 0     ; init string 
1ceb 21 c6 f3			ld hl, os_input 
1cee 77				ld (hl), a 
1cef 23				inc hl 
1cf0 77				ld (hl), a 
1cf1 21 c6 f3			ld hl, os_input 
1cf4 3e 01			ld a, 1     ; init string 
1cf6 cd 79 0f			call input_str 
1cf9			 
1cf9 cd 18 0d		        call clear_display 
1cfc cd 3b 0d			call update_display		 
1cff			 
1cff 3a c6 f3			ld a, (os_input) 
1d02 cd a1 13			call toUpper 
1d05 fe 48		        cp 'H' 
1d07 28 6f		        jr z, .monhelp 
1d09 fe 44			cp 'D'		; dump 
1d0b ca 99 1d			jp z, .mondump	 
1d0e fe 43			cp 'C'		; dump 
1d10 ca b3 1d			jp z, .moncdump	 
1d13 fe 4d			cp 'M'		; dump 
1d15 ca 24 1d			jp z, .moneditstart 
1d18 fe 55			cp 'U'		; dump 
1d1a 28 14			jr z, .monedit	 
1d1c fe 51			cp 'Q'		; dump 
1d1e c8				ret z	 
1d1f			 
1d1f			 
1d1f				; TODO "S" to access symbol by name and not need the address 
1d1f				; TODO "F" to find a string in memory 
1d1f			 
1d1f c3 d5 1c			jp monitor 
1d22			 
1d22 .. 00		.monprompt: db ">", 0 
1d24			 
1d24			.moneditstart: 
1d24				; get starting address 
1d24			 
1d24 21 c8 f3			ld hl,os_input+2 
1d27 cd 03 13			call get_word_hl 
1d2a			 
1d2a 22 eb f4			ld (os_cur_ptr),hl	 
1d2d			 
1d2d c3 d5 1c			jp monitor 
1d30			 
1d30			.monedit: 
1d30				; get byte to load 
1d30			 
1d30 21 c8 f3			ld hl,os_input+2 
1d33 cd a3 12			call get_byte 
1d36			 
1d36				; get address to update 
1d36 2a eb f4			ld hl, (os_cur_ptr) 
1d39			 
1d39				; update byte 
1d39			 
1d39 77				ld (hl), a 
1d3a			 
1d3a				; move to next address and save it 
1d3a			 
1d3a 23				inc hl 
1d3b 22 eb f4			ld (os_cur_ptr),hl	 
1d3e			 
1d3e c3 d5 1c			jp monitor 
1d41			 
1d41			 
1d41 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d55 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d71 .. 00		.monhelptext3:  db "Q-Quit",0 
1d78			        
1d78			.monhelp: 
1d78 3e 00			ld a, display_row_1 
1d7a 11 41 1d		        ld de, .monhelptext1 
1d7d			 
1d7d cd 2b 0d			call str_at_display 
1d80 3e 28			ld a, display_row_2 
1d82 11 55 1d		        ld de, .monhelptext2 
1d85					 
1d85 cd 2b 0d			call str_at_display 
1d88 3e 50			ld a, display_row_3 
1d8a 11 71 1d		        ld de, .monhelptext3 
1d8d					 
1d8d cd 2b 0d			call str_at_display 
1d90 cd 3b 0d			call update_display		 
1d93			 
1d93 cd df 1e			call next_page_prompt 
1d96 c3 d5 1c			jp monitor 
1d99			 
1d99			.mondump:    
1d99 21 c8 f3			ld hl,os_input+2 
1d9c cd 03 13			call get_word_hl 
1d9f			 
1d9f 22 eb f4			ld (os_cur_ptr),hl	 
1da2 cd e7 1d			call dumpcont 
1da5 3e 78			ld a, display_row_4 
1da7 11 81 1c			ld de, endprog 
1daa			 
1daa cd 3b 0d			call update_display		 
1dad			 
1dad cd df 1e			call next_page_prompt 
1db0 c3 d5 1c			jp monitor 
1db3			.moncdump: 
1db3 cd e7 1d			call dumpcont 
1db6 3e 78			ld a, display_row_4 
1db8 11 81 1c			ld de, endprog 
1dbb			 
1dbb cd 3b 0d			call update_display		 
1dbe			 
1dbe cd df 1e			call next_page_prompt 
1dc1 c3 d5 1c			jp monitor 
1dc4			 
1dc4			 
1dc4			; TODO symbol access  
1dc4			 
1dc4			.symbols:     ;; A list of symbols that can be called up  
1dc4 b4 fd			dw display_fb0 
1dc6 .. 00			db "fb0",0  
1dca 81 fa		     	dw store_page 
1dcc .. 00			db "store_page",0 
1dd7			 
1dd7			 
1dd7			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1dd7			 
1dd7 3a c9 f1			ld a,(scratch+1) 
1dda fe 00			cp 0 
1ddc 28 09			jr z, dumpcont 
1dde			 
1dde				; no, not a null term line so has an address to work out.... 
1dde			 
1dde 21 ca f1			ld hl,scratch+2 
1de1 cd 03 13			call get_word_hl 
1de4			 
1de4 22 eb f4			ld (os_cur_ptr),hl	 
1de7			 
1de7			 
1de7			 
1de7			dumpcont: 
1de7			 
1de7				; dump bytes at ptr 
1de7			 
1de7			 
1de7 3e 00			ld a, display_row_1 
1de9 2a cf fb			ld hl, (display_fb_active) 
1dec cd 4c 0f			call addatohl 
1def cd 17 1e			call .dumpbyterow 
1df2			 
1df2 3e 28			ld a, display_row_2 
1df4 2a cf fb			ld hl, (display_fb_active) 
1df7 cd 4c 0f			call addatohl 
1dfa cd 17 1e			call .dumpbyterow 
1dfd			 
1dfd			 
1dfd 3e 50			ld a, display_row_3 
1dff 2a cf fb			ld hl, (display_fb_active) 
1e02 cd 4c 0f			call addatohl 
1e05 cd 17 1e			call .dumpbyterow 
1e08			 
1e08 3e 78			ld a, display_row_4 
1e0a 2a cf fb			ld hl, (display_fb_active) 
1e0d cd 4c 0f			call addatohl 
1e10 cd 17 1e			call .dumpbyterow 
1e13			 
1e13 cd 3b 0d			call update_display 
1e16			;		jp cli 
1e16 c9				ret 
1e17			 
1e17			.dumpbyterow: 
1e17			 
1e17				;push af 
1e17			 
1e17 e5				push hl 
1e18			 
1e18				; calc where to poke the ascii 
1e18			if display_cols == 20 
1e18				ld a, 16 
1e18			else 
1e18 3e 1f			ld a, 31 
1e1a			endif 
1e1a			 
1e1a cd 4c 0f			call addatohl 
1e1d 22 cd f4			ld (os_word_scratch),hl  		; save pos for later 
1e20			 
1e20			 
1e20			; display decoding address 
1e20 2a eb f4		   	ld hl,(os_cur_ptr) 
1e23			 
1e23 7c				ld a,h 
1e24 e1				pop hl 
1e25 e5				push hl 
1e26			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1e26 cd 4d 12			call hexout 
1e29 2a eb f4		   	ld hl,(os_cur_ptr) 
1e2c			 
1e2c 7d				ld a,l 
1e2d e1				pop hl 
1e2e 23				inc hl 
1e2f 23				inc hl 
1e30 e5				push hl 
1e31			;	ld hl, os_word_scratch+2 
1e31 cd 4d 12			call hexout 
1e34 e1				pop hl 
1e35 23				inc hl 
1e36 23				inc hl 
1e37				;ld hl, os_word_scratch+4 
1e37 3e 3a			ld a, ':' 
1e39 77				ld (hl),a 
1e3a 23				inc hl 
1e3b				;ld a, 0 
1e3b				;ld (hl),a 
1e3b				;ld de, os_word_scratch 
1e3b				;pop af 
1e3b				;push af 
1e3b			;		ld a, display_row_2 
1e3b			;		call str_at_display 
1e3b			;		call update_display 
1e3b			 
1e3b			 
1e3b			;pop af 
1e3b			;	add 5 
1e3b			 
1e3b			if display_cols == 20 
1e3b				ld b, 4 
1e3b			else 
1e3b 06 08			ld b, 8 
1e3d			endif	 
1e3d			 
1e3d			.dumpbyte: 
1e3d c5				push bc 
1e3e e5				push hl 
1e3f			 
1e3f			 
1e3f 2a eb f4		   	ld hl,(os_cur_ptr) 
1e42 7e					ld a,(hl) 
1e43			 
1e43					; poke the ascii to display 
1e43 2a cd f4				ld hl,(os_word_scratch) 
1e46 77					ld (hl),a 
1e47 23					inc hl 
1e48 22 cd f4				ld (os_word_scratch),hl 
1e4b			 
1e4b					 
1e4b			 
1e4b			 
1e4b e1					pop hl 
1e4c e5					push hl 
1e4d			 
1e4d cd 4d 12				call hexout 
1e50			 
1e50					 
1e50 2a eb f4		   	ld hl,(os_cur_ptr) 
1e53 23				inc hl 
1e54 22 eb f4		   	ld (os_cur_ptr),hl 
1e57			 
1e57 e1					pop hl 
1e58 23					inc hl 
1e59 23					inc hl 
1e5a 23					inc hl 
1e5b			 
1e5b			 
1e5b			 
1e5b					;ld a,0 
1e5b					;ld (os_word_scratch+2),a 
1e5b					;pop af 
1e5b					;push af 
1e5b			 
1e5b					;ld de, os_word_scratch 
1e5b					;call str_at_display 
1e5b			;		call update_display 
1e5b			;		pop af 
1e5b c1					pop bc 
1e5c c6 03				add 3 
1e5e 10 dd			djnz .dumpbyte 
1e60			 
1e60				 
1e60			 
1e60 c9				ret 
1e61			 
1e61			jump:	 
1e61			 
1e61 21 ca f1			ld hl,scratch+2 
1e64 cd 03 13			call get_word_hl 
1e67				;ld hl,(scratch+2) 
1e67				;call fourehexhl 
1e67			 
1e67 22 eb f4			ld (os_cur_ptr),hl	 
1e6a			 
1e6a e9				jp (hl) 
1e6b			 
1e6b			 
1e6b			 
1e6b			; TODO implement a basic monitor mode to start with 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			; testing and demo code during development 
1e6b			 
1e6b			 
1e6b .. 00		str1: db "Enter some text...",0 
1e7e .. 00		clear: db "                    ",0 
1e93			 
1e93			demo: 
1e93			 
1e93			 
1e93			 
1e93			;	call update_display 
1e93			 
1e93				; init scratch input area for testing 
1e93 21 c8 f1			ld hl, scratch	 
1e96 3e 00			ld a,0 
1e98 77				ld (hl),a 
1e99			 
1e99			 
1e99 3e 28		            LD   A, display_row_2 
1e9b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e9b 11 6b 1e		            LD   DE, str1 
1e9e cd 2b 0d			call str_at_display 
1ea1			 
1ea1			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ea1			cloop:	 
1ea1 3e 50		            LD   A, display_row_3 
1ea3			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ea3 11 7e 1e		            LD   DE, clear 
1ea6			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1ea6 cd 2b 0d				call str_at_display 
1ea9 3e 78			ld a, display_row_4 
1eab 11 db 1e			ld de, prompt 
1eae			 
1eae cd 2b 0d				call str_at_display 
1eb1 cd 3b 0d			call update_display 
1eb4			 
1eb4 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1eb6 16 0a			ld d, 10 
1eb8 21 c8 f1			ld hl, scratch	 
1ebb cd 79 0f			call input_str 
1ebe			 
1ebe			;	call clear_display 
1ebe			;'	call update_display 
1ebe			 
1ebe 3e 00		            LD   A, display_row_1 
1ec0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ec0 11 7e 1e		            LD   DE, clear 
1ec3 cd 2b 0d				call str_at_display 
1ec6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ec6 3e 00		            LD   A, display_row_1 
1ec8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ec8 11 c8 f1		            LD   DE, scratch 
1ecb			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ecb cd 2b 0d				call str_at_display 
1ece cd 3b 0d			call update_display 
1ed1			 
1ed1 3e 00				ld a,0 
1ed3 21 c8 f1			ld hl, scratch 
1ed6 77				ld (hl),a 
1ed7			 
1ed7 00				nop 
1ed8 c3 a1 1e			jp cloop 
1edb			 
1edb			 
1edb			 
1edb			; OS Prompt 
1edb			 
1edb .. 00		prompt: db ">",0 
1edd .. 00		endprg: db "?",0 
1edf			 
1edf			 
1edf			; handy next page prompt 
1edf			next_page_prompt: 
1edf e5				push hl 
1ee0 d5				push de 
1ee1 f5				push af 
1ee2 c5				push bc 
1ee3			 
1ee3 3e 9f			ld a,display_row_4 + display_cols - 1 
1ee5 11 dd 1e		        ld de, endprg 
1ee8 cd 2b 0d			call str_at_display 
1eeb cd 3b 0d			call update_display 
1eee cd a9 73			call cin_wait 
1ef1 c1				pop bc 
1ef2 f1				pop af 
1ef3 d1				pop de 
1ef4 e1				pop hl 
1ef5			 
1ef5			 
1ef5 c9				ret 
1ef6			 
1ef6			 
1ef6			; forth parser 
1ef6			 
1ef6			; My forth kernel 
1ef6			include "forth_kernel.asm" 
1ef6			; 
1ef6			; kernel to the forth OS 
1ef6			 
1ef6			DS_TYPE_STR: equ 1     ; string type 
1ef6			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1ef6			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1ef6			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1ef6			 
1ef6			FORTH_PARSEV1: equ 0 
1ef6			FORTH_PARSEV2: equ 0 
1ef6			FORTH_PARSEV3: equ 0 
1ef6			FORTH_PARSEV4: equ 0 
1ef6			FORTH_PARSEV5: equ 1 
1ef6			 
1ef6			;if FORTH_PARSEV5 
1ef6			;	FORTH_END_BUFFER: equ 0 
1ef6			;else 
1ef6			FORTH_END_BUFFER: equ 127 
1ef6			;endif 
1ef6			 
1ef6			FORTH_TRUE: equ 1 
1ef6			FORTH_FALSE: equ 0 
1ef6			 
1ef6			if FORTH_PARSEV4 
1ef6			include "forth_stackops.asm" 
1ef6			endif 
1ef6			 
1ef6			if FORTH_PARSEV5 
1ef6			include "forth_stackopsv5.asm" 
1ef6			 
1ef6			; Stack operations for v5 parser on wards 
1ef6			; * DATA stack 
1ef6			; * LOOP stack 
1ef6			; * RETURN stack 
1ef6			 
1ef6			 
1ef6			 
1ef6			FORTH_CHK_DSP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_data_sp) 
1ef6				ld de, cli_data_stack 
1ef6				call cmp16 
1ef6				jp c, fault_dsp_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			FORTH_CHK_RSP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_ret_sp) 
1ef6				ld de, cli_ret_stack 
1ef6				call cmp16 
1ef6				jp c, fault_rsp_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			FORTH_CHK_LOOP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_loop_sp) 
1ef6				ld de, cli_loop_stack 
1ef6				call cmp16 
1ef6				jp c, fault_loop_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			FORTH_ERR_TOS_NOTSTR: macro 
1ef6				; TOSO might need more for checks when used 
1ef6				push af 
1ef6				ld a,(hl) 
1ef6				cp DS_TYPE_STR 
1ef6				jp nz, type_faultn   
1ef6				pop af 
1ef6				endm 
1ef6			 
1ef6			FORTH_ERR_TOS_NOTNUM: macro 
1ef6				push af 
1ef6				ld a,(hl) 
1ef6				cp DS_TYPE_INUM 
1ef6				jp nz, type_faultn   
1ef6				pop af 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			; increase data stack pointer and save hl to it 
1ef6				 
1ef6			FORTH_DSP_NEXT: macro 
1ef6				call macro_forth_dsp_next 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			macro_forth_dsp_next: 
1ef6				if DEBUG_FORTH_STACK_GUARD 
1ef6 cd 21 6d				call check_stacks 
1ef9				endif 
1ef9 e5				push hl 
1efa d5				push de 
1efb eb				ex de,hl 
1efc 2a f5 f9			ld hl,(cli_data_sp) 
1eff 23				inc hl 
1f00 23				inc hl 
1f01			 
1f01			; PARSEV5 
1f01 23				inc hl 
1f02 22 f5 f9			ld (cli_data_sp),hl 
1f05 73				ld (hl), e 
1f06 23				inc hl 
1f07 72				ld (hl), d 
1f08 d1				pop de 
1f09 e1				pop hl 
1f0a				if DEBUG_FORTH_STACK_GUARD 
1f0a cd 21 6d				call check_stacks 
1f0d				endif 
1f0d c9				ret 
1f0e			 
1f0e			 
1f0e			; increase ret stack pointer and save hl to it 
1f0e				 
1f0e			FORTH_RSP_NEXT: macro 
1f0e				call macro_forth_rsp_next 
1f0e				endm 
1f0e			 
1f0e			macro_forth_rsp_next: 
1f0e				if DEBUG_FORTH_STACK_GUARD 
1f0e cd 21 6d				call check_stacks 
1f11				endif 
1f11 e5				push hl 
1f12 d5				push de 
1f13 eb				ex de,hl 
1f14 2a f9 f9			ld hl,(cli_ret_sp) 
1f17 23				inc hl 
1f18 23				inc hl 
1f19 22 f9 f9			ld (cli_ret_sp),hl 
1f1c 73				ld (hl), e 
1f1d 23				inc hl 
1f1e 72				ld (hl), d 
1f1f d1				pop de 
1f20 e1				pop hl 
1f21				if DEBUG_FORTH_STACK_GUARD 
1f21 cd 21 6d				call check_stacks 
1f24				endif 
1f24 c9				ret 
1f25			 
1f25			; get current ret stack pointer and save to hl  
1f25				 
1f25			FORTH_RSP_TOS: macro 
1f25				call macro_forth_rsp_tos 
1f25				endm 
1f25			 
1f25			macro_forth_rsp_tos: 
1f25				;push de 
1f25 2a f9 f9			ld hl,(cli_ret_sp) 
1f28 cd 60 1f			call loadhlptrtohl 
1f2b				;ld e, (hl) 
1f2b				;inc hl 
1f2b				;ld d, (hl) 
1f2b				;ex de, hl 
1f2b					if DEBUG_FORTH_WORDS 
1f2b			;			DMARK "RST" 
1f2b						CALLMONITOR 
1f2b cd f3 18			call break_point_state  
1f2e				endm  
# End of macro CALLMONITOR
1f2e					endif 
1f2e				;pop de 
1f2e c9				ret 
1f2f			 
1f2f			; pop ret stack pointer 
1f2f				 
1f2f			FORTH_RSP_POP: macro 
1f2f				call macro_forth_rsp_pop 
1f2f				endm 
1f2f			 
1f2f			 
1f2f			macro_forth_rsp_pop: 
1f2f				if DEBUG_FORTH_STACK_GUARD 
1f2f			;		DMARK "RPP" 
1f2f cd 21 6d				call check_stacks 
1f32					FORTH_CHK_RSP_UNDER 
1f32 e5				push hl 
1f33 d5				push de 
1f34 2a f9 f9			ld hl,(cli_ret_sp) 
1f37 11 b3 f9			ld de, cli_ret_stack 
1f3a cd 6a 0f			call cmp16 
1f3d da 35 6e			jp c, fault_rsp_under 
1f40 d1				pop de 
1f41 e1				pop hl 
1f42				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f42				endif 
1f42 e5				push hl 
1f43 2a f9 f9			ld hl,(cli_ret_sp) 
1f46			 
1f46			 
1f46				if FORTH_ENABLE_FREE 
1f46			 
1f46					; get pointer 
1f46			 
1f46					push de 
1f46					push hl 
1f46			 
1f46					ld e, (hl) 
1f46					inc hl 
1f46					ld d, (hl) 
1f46			 
1f46					ex de, hl 
1f46					call free 
1f46			 
1f46					pop hl 
1f46					pop de 
1f46			 
1f46			 
1f46				endif 
1f46			 
1f46			 
1f46 2b				dec hl 
1f47 2b				dec hl 
1f48 22 f9 f9			ld (cli_ret_sp), hl 
1f4b				; do stack underflow checks 
1f4b e1				pop hl 
1f4c				if DEBUG_FORTH_STACK_GUARD 
1f4c cd 21 6d				call check_stacks 
1f4f					FORTH_CHK_RSP_UNDER 
1f4f e5				push hl 
1f50 d5				push de 
1f51 2a f9 f9			ld hl,(cli_ret_sp) 
1f54 11 b3 f9			ld de, cli_ret_stack 
1f57 cd 6a 0f			call cmp16 
1f5a da 35 6e			jp c, fault_rsp_under 
1f5d d1				pop de 
1f5e e1				pop hl 
1f5f				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f5f				endif 
1f5f c9				ret 
1f60			 
1f60			 
1f60			 
1f60			; routine to load word pointed to by hl into hl 
1f60			 
1f60			loadhlptrtohl: 
1f60			 
1f60 d5				push de 
1f61 5e				ld e, (hl) 
1f62 23				inc hl 
1f63 56				ld d, (hl) 
1f64 eb				ex de, hl 
1f65 d1				pop de 
1f66			 
1f66 c9				ret 
1f67			 
1f67			 
1f67			 
1f67			 
1f67			 
1f67			; push a number held in HL onto the data stack 
1f67			; entry point for pushing a value when already in hl used in function above 
1f67			 
1f67			forth_push_numhl: 
1f67			 
1f67 e5				push hl    ; save value to push 
1f68			 
1f68			if DEBUG_FORTH_PUSH 
1f68				; see if disabled 
1f68			 
1f68			 
1f68 f5				push af 
1f69 3a b9 f1			ld a, (os_view_disable) 
1f6c fe 2a			cp '*' 
1f6e 28 34			jr z, .pskip2 
1f70 e5				push hl 
1f71 e5			push hl 
1f72 cd 18 0d			call clear_display 
1f75 e1			pop hl 
1f76 7c				ld a,h 
1f77 21 cd f4			ld hl, os_word_scratch 
1f7a cd 4d 12			call hexout 
1f7d e1				pop hl 
1f7e 7d				ld a,l 
1f7f 21 cf f4			ld hl, os_word_scratch+2 
1f82 cd 4d 12			call hexout 
1f85			 
1f85 21 d1 f4			ld hl, os_word_scratch+4 
1f88 3e 00			ld a,0 
1f8a 77				ld (hl),a 
1f8b 11 cd f4			ld de,os_word_scratch 
1f8e 3e 28				ld a, display_row_2 
1f90 cd 2b 0d				call str_at_display 
1f93 11 bd 58			ld de, .push_num 
1f96 3e 00			ld a, display_row_1 
1f98			 
1f98 cd 2b 0d				call str_at_display 
1f9b			 
1f9b			 
1f9b cd 3b 0d			call update_display 
1f9e cd 95 0c			call delay1s 
1fa1 cd 95 0c			call delay1s 
1fa4			.pskip2:  
1fa4			 
1fa4 f1				pop af 
1fa5			endif	 
1fa5			 
1fa5			 
1fa5				FORTH_DSP_NEXT 
1fa5 cd f6 1e			call macro_forth_dsp_next 
1fa8				endm 
# End of macro FORTH_DSP_NEXT
1fa8			 
1fa8 2a f5 f9			ld hl, (cli_data_sp) 
1fab			 
1fab				; save item type 
1fab 3e 02			ld a,  DS_TYPE_INUM 
1fad 77				ld (hl), a 
1fae 23				inc hl 
1faf			 
1faf				; get word off stack 
1faf d1				pop de 
1fb0 7b				ld a,e 
1fb1 77				ld (hl), a 
1fb2 23				inc hl 
1fb3 7a				ld a,d 
1fb4 77				ld (hl), a 
1fb5			 
1fb5			if DEBUG_FORTH_PUSH 
1fb5 2b				dec hl 
1fb6 2b				dec hl 
1fb7 2b				dec hl 
1fb8						DMARK "PH5" 
1fb8 f5				push af  
1fb9 3a cd 1f			ld a, (.dmark)  
1fbc 32 6e fe			ld (debug_mark),a  
1fbf 3a ce 1f			ld a, (.dmark+1)  
1fc2 32 6f fe			ld (debug_mark+1),a  
1fc5 3a cf 1f			ld a, (.dmark+2)  
1fc8 32 70 fe			ld (debug_mark+2),a  
1fcb 18 03			jr .pastdmark  
1fcd ..			.dmark: db "PH5"  
1fd0 f1			.pastdmark: pop af  
1fd1			endm  
# End of macro DMARK
1fd1				CALLMONITOR 
1fd1 cd f3 18			call break_point_state  
1fd4				endm  
# End of macro CALLMONITOR
1fd4			endif	 
1fd4			 
1fd4 c9				ret 
1fd5			 
1fd5			 
1fd5			; Push a string to stack pointed to by hl 
1fd5			 
1fd5			forth_push_str: 
1fd5			 
1fd5			if DEBUG_FORTH_PUSH 
1fd5						DMARK "PSQ" 
1fd5 f5				push af  
1fd6 3a ea 1f			ld a, (.dmark)  
1fd9 32 6e fe			ld (debug_mark),a  
1fdc 3a eb 1f			ld a, (.dmark+1)  
1fdf 32 6f fe			ld (debug_mark+1),a  
1fe2 3a ec 1f			ld a, (.dmark+2)  
1fe5 32 70 fe			ld (debug_mark+2),a  
1fe8 18 03			jr .pastdmark  
1fea ..			.dmark: db "PSQ"  
1fed f1			.pastdmark: pop af  
1fee			endm  
# End of macro DMARK
1fee				CALLMONITOR 
1fee cd f3 18			call break_point_state  
1ff1				endm  
# End of macro CALLMONITOR
1ff1			endif	 
1ff1			    
1ff1 e5				push hl 
1ff2 e5				push hl 
1ff3			 
1ff3			;	ld a, 0   ; find end of string 
1ff3 cd aa 13			call strlenz 
1ff6			if DEBUG_FORTH_PUSH 
1ff6						DMARK "PQ2" 
1ff6 f5				push af  
1ff7 3a 0b 20			ld a, (.dmark)  
1ffa 32 6e fe			ld (debug_mark),a  
1ffd 3a 0c 20			ld a, (.dmark+1)  
2000 32 6f fe			ld (debug_mark+1),a  
2003 3a 0d 20			ld a, (.dmark+2)  
2006 32 70 fe			ld (debug_mark+2),a  
2009 18 03			jr .pastdmark  
200b ..			.dmark: db "PQ2"  
200e f1			.pastdmark: pop af  
200f			endm  
# End of macro DMARK
200f				CALLMONITOR 
200f cd f3 18			call break_point_state  
2012				endm  
# End of macro CALLMONITOR
2012			endif	 
2012 eb				ex de, hl 
2013 e1				pop hl   ; get ptr to start of string 
2014			if DEBUG_FORTH_PUSH 
2014						DMARK "PQ3" 
2014 f5				push af  
2015 3a 29 20			ld a, (.dmark)  
2018 32 6e fe			ld (debug_mark),a  
201b 3a 2a 20			ld a, (.dmark+1)  
201e 32 6f fe			ld (debug_mark+1),a  
2021 3a 2b 20			ld a, (.dmark+2)  
2024 32 70 fe			ld (debug_mark+2),a  
2027 18 03			jr .pastdmark  
2029 ..			.dmark: db "PQ3"  
202c f1			.pastdmark: pop af  
202d			endm  
# End of macro DMARK
202d				CALLMONITOR 
202d cd f3 18			call break_point_state  
2030				endm  
# End of macro CALLMONITOR
2030			endif	 
2030 19				add hl,de 
2031			if DEBUG_FORTH_PUSH 
2031						DMARK "PQE" 
2031 f5				push af  
2032 3a 46 20			ld a, (.dmark)  
2035 32 6e fe			ld (debug_mark),a  
2038 3a 47 20			ld a, (.dmark+1)  
203b 32 6f fe			ld (debug_mark+1),a  
203e 3a 48 20			ld a, (.dmark+2)  
2041 32 70 fe			ld (debug_mark+2),a  
2044 18 03			jr .pastdmark  
2046 ..			.dmark: db "PQE"  
2049 f1			.pastdmark: pop af  
204a			endm  
# End of macro DMARK
204a				CALLMONITOR 
204a cd f3 18			call break_point_state  
204d				endm  
# End of macro CALLMONITOR
204d			endif	 
204d			 
204d 2b				dec hl    ; see if there is an optional trailing double quote 
204e 7e				ld a,(hl) 
204f fe 22			cp '"' 
2051 20 03			jr nz, .strnoq 
2053 3e 00			ld a, 0      ; get rid of double quote 
2055 77				ld (hl), a 
2056 23			.strnoq: inc hl 
2057			 
2057 3e 00			ld a, 0 
2059 77				ld (hl), a     ; add null term and get rid of trailing double quote 
205a			 
205a 13				inc de ; add one for the type string 
205b 13				inc de ; add one for null term??? 
205c			 
205c				; tos is get string pointer again 
205c				; de contains space to allocate 
205c				 
205c d5				push de 
205d			 
205d eb				ex de, hl 
205e			 
205e				;push af 
205e			 
205e			if DEBUG_FORTH_PUSH 
205e						DMARK "PHm" 
205e f5				push af  
205f 3a 73 20			ld a, (.dmark)  
2062 32 6e fe			ld (debug_mark),a  
2065 3a 74 20			ld a, (.dmark+1)  
2068 32 6f fe			ld (debug_mark+1),a  
206b 3a 75 20			ld a, (.dmark+2)  
206e 32 70 fe			ld (debug_mark+2),a  
2071 18 03			jr .pastdmark  
2073 ..			.dmark: db "PHm"  
2076 f1			.pastdmark: pop af  
2077			endm  
# End of macro DMARK
2077				CALLMONITOR 
2077 cd f3 18			call break_point_state  
207a				endm  
# End of macro CALLMONITOR
207a			endif	 
207a cd 13 14			call malloc	; on ret hl now contains allocated memory 
207d				if DEBUG_FORTH_MALLOC_GUARD 
207d cc 15 59				call z,malloc_error 
2080				endif 
2080			 
2080				 
2080 c1				pop bc    ; get length 
2081 d1				pop de   ;  get string start    
2082			 
2082				; hl has destination from malloc 
2082			 
2082 eb				ex de, hl    ; prep for ldir 
2083			 
2083 d5				push de   ; save malloc area for DSP later 
2084				;push hl   ; save malloc area for DSP later 
2084			 
2084			if DEBUG_FORTH_PUSH 
2084						DMARK "PHc" 
2084 f5				push af  
2085 3a 99 20			ld a, (.dmark)  
2088 32 6e fe			ld (debug_mark),a  
208b 3a 9a 20			ld a, (.dmark+1)  
208e 32 6f fe			ld (debug_mark+1),a  
2091 3a 9b 20			ld a, (.dmark+2)  
2094 32 70 fe			ld (debug_mark+2),a  
2097 18 03			jr .pastdmark  
2099 ..			.dmark: db "PHc"  
209c f1			.pastdmark: pop af  
209d			endm  
# End of macro DMARK
209d				CALLMONITOR 
209d cd f3 18			call break_point_state  
20a0				endm  
# End of macro CALLMONITOR
20a0			endif	 
20a0			 
20a0			 
20a0 ed b0			ldir 
20a2			 
20a2			 
20a2				; push malloc to data stack     macro?????  
20a2			 
20a2				FORTH_DSP_NEXT 
20a2 cd f6 1e			call macro_forth_dsp_next 
20a5				endm 
# End of macro FORTH_DSP_NEXT
20a5			 
20a5				; save value and type 
20a5			 
20a5 2a f5 f9			ld hl, (cli_data_sp) 
20a8			 
20a8				; save item type 
20a8 3e 01			ld a,  DS_TYPE_STR 
20aa 77				ld (hl), a 
20ab 23				inc hl 
20ac			 
20ac				; get malloc word off stack 
20ac d1				pop de 
20ad 73				ld (hl), e 
20ae 23				inc hl 
20af 72				ld (hl), d 
20b0			 
20b0			 
20b0			 
20b0			if DEBUG_FORTH_PUSH 
20b0 2a f5 f9			ld hl, (cli_data_sp) 
20b3						DMARK "PHS" 
20b3 f5				push af  
20b4 3a c8 20			ld a, (.dmark)  
20b7 32 6e fe			ld (debug_mark),a  
20ba 3a c9 20			ld a, (.dmark+1)  
20bd 32 6f fe			ld (debug_mark+1),a  
20c0 3a ca 20			ld a, (.dmark+2)  
20c3 32 70 fe			ld (debug_mark+2),a  
20c6 18 03			jr .pastdmark  
20c8 ..			.dmark: db "PHS"  
20cb f1			.pastdmark: pop af  
20cc			endm  
# End of macro DMARK
20cc				CALLMONITOR 
20cc cd f3 18			call break_point_state  
20cf				endm  
# End of macro CALLMONITOR
20cf			;	ex de,hl 
20cf			endif	 
20cf				; in case of spaces, skip the ptr past the copied string 
20cf				;pop af 
20cf				;ld (cli_origptr),hl 
20cf			 
20cf c9				ret 
20d0			 
20d0			 
20d0			 
20d0			; TODO ascii push input onto stack given hl to start of input 
20d0			 
20d0			; identify type 
20d0			; if starts with a " then a string 
20d0			; otherwise it is a number 
20d0			;  
20d0			; if a string 
20d0			;     scan for ending " to get length of string to malloc for + 1 
20d0			;     malloc 
20d0			;     put pointer to string on stack first byte flags as string 
20d0			; 
20d0			; else a number 
20d0			;    look for number format identifier 
20d0			;    $xx hex 
20d0			;    %xxxxx bin 
20d0			;    xxxxx decimal 
20d0			;    convert number to 16bit word.  
20d0			;    malloc word + 1 with flag to identiy as num 
20d0			;    put pointer to number on stack 
20d0			;   
20d0			;  
20d0			  
20d0			forth_apush: 
20d0				; kernel push 
20d0			 
20d0			if DEBUG_FORTH_PUSH 
20d0						DMARK "PSH" 
20d0 f5				push af  
20d1 3a e5 20			ld a, (.dmark)  
20d4 32 6e fe			ld (debug_mark),a  
20d7 3a e6 20			ld a, (.dmark+1)  
20da 32 6f fe			ld (debug_mark+1),a  
20dd 3a e7 20			ld a, (.dmark+2)  
20e0 32 70 fe			ld (debug_mark+2),a  
20e3 18 03			jr .pastdmark  
20e5 ..			.dmark: db "PSH"  
20e8 f1			.pastdmark: pop af  
20e9			endm  
# End of macro DMARK
20e9				CALLMONITOR 
20e9 cd f3 18			call break_point_state  
20ec				endm  
# End of macro CALLMONITOR
20ec			endif	 
20ec				; identify input type 
20ec			 
20ec 7e				ld a,(hl) 
20ed fe 22			cp '"' 
20ef 28 0a			jr z, .fapstr 
20f1 fe 24			cp '$' 
20f3 ca 1b 21			jp z, .faphex 
20f6 fe 25			cp '%' 
20f8 ca 03 21			jp z, .fapbin 
20fb			;	cp 'b' 
20fb			;	jp z, .fabin 
20fb				; else decimal 
20fb			 
20fb				; TODO do decimal conversion 
20fb				; decimal is stored as a 16bit word 
20fb			 
20fb				; by default everything is a string if type is not detected 
20fb			.fapstr: ; 
20fb fe 22			cp '"' 
20fd 20 01			jr nz, .strnoqu 
20ff 23				inc hl 
2100			.strnoqu: 
2100 c3 d5 1f			jp forth_push_str 
2103			 
2103			 
2103			 
2103			.fapbin:    ; push a binary string.  
2103 11 00 00			ld de, 0   ; hold a 16bit value 
2106			 
2106 23			.fapbinshift:	inc hl  
2107 7e				ld a,(hl) 
2108 fe 00			cp 0     ; done scanning  
210a 28 0b			jr z, .fapbdone  	; got it in HL so push  
210c			 
210c				; left shift de 
210c eb				ex de, hl	 
210d 29				add hl, hl 
210e			 
210e				; is 1 
210e fe 31			cp '1' 
2110 20 02			jr nz, .binzero 
2112 cb 4d			bit 1, l 
2114			.binzero: 
2114 eb				ex de, hl	 ; save current de 
2115 18 ef			jr .fapbinshift 
2117			 
2117			.fapbdone: 
2117 eb				ex de, hl 
2118 c3 67 1f			jp forth_push_numhl 
211b			 
211b			 
211b			.faphex:   ; hex is always stored as a 16bit word 
211b				; skip number prefix 
211b 23				inc hl 
211c				; turn ascii into number 
211c cd 03 13			call get_word_hl	; ret 16bit word in hl 
211f			 
211f c3 67 1f			jp forth_push_numhl 
2122			 
2122 00				 nop 
2123			 
2123			.fabin:   ; TODO bin conversion 
2123			 
2123			 
2123 c9				ret 
2124			 
2124			 
2124			; get either a string ptr or a 16bit word from the data stack 
2124			 
2124			FORTH_DSP: macro 
2124				call macro_forth_dsp 
2124				endm 
2124			 
2124			macro_forth_dsp: 
2124				; data stack pointer points to current word on tos 
2124			 
2124 2a f5 f9			ld hl,(cli_data_sp) 
2127			 
2127				if DEBUG_FORTH_PUSH 
2127						DMARK "DSP" 
2127 f5				push af  
2128 3a 3c 21			ld a, (.dmark)  
212b 32 6e fe			ld (debug_mark),a  
212e 3a 3d 21			ld a, (.dmark+1)  
2131 32 6f fe			ld (debug_mark+1),a  
2134 3a 3e 21			ld a, (.dmark+2)  
2137 32 70 fe			ld (debug_mark+2),a  
213a 18 03			jr .pastdmark  
213c ..			.dmark: db "DSP"  
213f f1			.pastdmark: pop af  
2140			endm  
# End of macro DMARK
2140			 
2140 cd 4a 59				call display_data_sp 
2143				;call break_point_state 
2143				;rst 030h 
2143				CALLMONITOR 
2143 cd f3 18			call break_point_state  
2146				endm  
# End of macro CALLMONITOR
2146				endif 
2146			 
2146 c9				ret 
2147			 
2147			; return hl to start of value on stack 
2147			 
2147			FORTH_DSP_VALUE: macro 
2147				call macro_forth_dsp_value 
2147				endm 
2147			 
2147			macro_forth_dsp_value: 
2147			 
2147				FORTH_DSP 
2147 cd 24 21			call macro_forth_dsp 
214a				endm 
# End of macro FORTH_DSP
214a			 
214a d5				push de 
214b			 
214b 23				inc hl ; skip type 
214c			 
214c 5e				ld e, (hl) 
214d 23				inc hl 
214e 56				ld d, (hl) 
214f eb				ex de,hl  
2150			 
2150 d1				pop de 
2151			 
2151 c9				ret 
2152			 
2152			; return hl to start of value to second item on stack 
2152			 
2152			FORTH_DSP_VALUEM1: macro 
2152				call macro_forth_dsp_value_m1 
2152				endm 
2152			 
2152			macro_forth_dsp_value_m1: 
2152			 
2152				FORTH_DSP 
2152 cd 24 21			call macro_forth_dsp 
2155				endm 
# End of macro FORTH_DSP
2155			 
2155 2b				dec hl 
2156 2b				dec hl 
2157			;	dec hl 
2157			 
2157 d5				push de 
2158			 
2158 5e				ld e, (hl) 
2159 23				inc hl 
215a 56				ld d, (hl) 
215b eb				ex de,hl  
215c			 
215c d1				pop de 
215d			 
215d c9				ret 
215e			 
215e				 
215e			 
215e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
215e			 
215e			FORTH_DSP_POP: macro 
215e				call macro_forth_dsp_pop 
215e				endm 
215e			 
215e			 
215e			; get the tos data type 
215e			 
215e			FORTH_DSP_TYPE:   macro 
215e			 
215e				;FORTH_DSP_VALUE 
215e				FORTH_DSP 
215e				 
215e				; hl points to value 
215e				; check type 
215e			 
215e				ld a,(hl) 
215e			 
215e				endm 
215e			 
215e			; load the tos value into hl 
215e			 
215e			 
215e			FORTH_DSP_VALUEHL:  macro 
215e				call macro_dsp_valuehl 
215e				endm 
215e			 
215e			 
215e			 
215e			macro_dsp_valuehl: 
215e				FORTH_DSP_VALUE 
215e cd 47 21			call macro_forth_dsp_value 
2161				endm 
# End of macro FORTH_DSP_VALUE
2161			 
2161				;FORTH_ERR_TOS_NOTNUM 
2161			 
2161				;inc hl   ; skip type id 
2161			 
2161			;	push de 
2161			; 
2161			;	ld e, (hl) 
2161			;	inc hl 
2161			;	ld d, (hl) 
2161			;	ex de,hl  
2161			 
2161			;	pop de 
2161			 
2161				if DEBUG_FORTH_PUSH 
2161						DMARK "DVL" 
2161 f5				push af  
2162 3a 76 21			ld a, (.dmark)  
2165 32 6e fe			ld (debug_mark),a  
2168 3a 77 21			ld a, (.dmark+1)  
216b 32 6f fe			ld (debug_mark+1),a  
216e 3a 78 21			ld a, (.dmark+2)  
2171 32 70 fe			ld (debug_mark+2),a  
2174 18 03			jr .pastdmark  
2176 ..			.dmark: db "DVL"  
2179 f1			.pastdmark: pop af  
217a			endm  
# End of macro DMARK
217a				CALLMONITOR 
217a cd f3 18			call break_point_state  
217d				endm  
# End of macro CALLMONITOR
217d				endif 
217d c9				ret 
217e			 
217e			forth_apushstrhl:      
217e				; push of string requires use of cli_origptr 
217e				; bodge use 
217e			 
217e				; get current cli_origptr, save, update with temp pointer  
217e ed 5b 45 fa		ld de, (cli_origptr) 
2182 22 45 fa			ld (cli_origptr), hl 
2185 d5				push de 
2186 cd d0 20			call forth_apush 
2189 d1				pop de 
218a ed 53 45 fa		ld (cli_origptr), de 
218e c9			        ret	 
218f			 
218f			 
218f			; increase loop stack pointer and save hl to it 
218f				 
218f			FORTH_LOOP_NEXT: macro 
218f				call macro_forth_loop_next 
218f				;nop 
218f				endm 
218f			 
218f			macro_forth_loop_next: 
218f				if DEBUG_FORTH_STACK_GUARD 
218f cd 21 6d				call check_stacks 
2192				endif 
2192 e5				push hl 
2193 d5				push de 
2194 eb				ex de,hl 
2195 2a f7 f9			ld hl,(cli_loop_sp) 
2198 23				inc hl 
2199 23				inc hl 
219a					if DEBUG_FORTH_WORDS 
219a						DMARK "LNX" 
219a f5				push af  
219b 3a af 21			ld a, (.dmark)  
219e 32 6e fe			ld (debug_mark),a  
21a1 3a b0 21			ld a, (.dmark+1)  
21a4 32 6f fe			ld (debug_mark+1),a  
21a7 3a b1 21			ld a, (.dmark+2)  
21aa 32 70 fe			ld (debug_mark+2),a  
21ad 18 03			jr .pastdmark  
21af ..			.dmark: db "LNX"  
21b2 f1			.pastdmark: pop af  
21b3			endm  
# End of macro DMARK
21b3						CALLMONITOR 
21b3 cd f3 18			call break_point_state  
21b6				endm  
# End of macro CALLMONITOR
21b6					endif 
21b6 22 f7 f9			ld (cli_loop_sp),hl 
21b9 73				ld (hl), e 
21ba 23				inc hl 
21bb 72				ld (hl), d 
21bc d1				pop de    ; been reversed so save a swap on restore 
21bd e1				pop hl 
21be				if DEBUG_FORTH_STACK_GUARD 
21be cd 21 6d				call check_stacks 
21c1				endif 
21c1 c9				ret 
21c2			 
21c2			; get current ret stack pointer and save to hl  
21c2				 
21c2			FORTH_LOOP_TOS: macro 
21c2				call macro_forth_loop_tos 
21c2				endm 
21c2			 
21c2			macro_forth_loop_tos: 
21c2 d5				push de 
21c3 2a f7 f9			ld hl,(cli_loop_sp) 
21c6 5e				ld e, (hl) 
21c7 23				inc hl 
21c8 56				ld d, (hl) 
21c9 eb				ex de, hl 
21ca d1				pop de 
21cb c9				ret 
21cc			 
21cc			; pop loop stack pointer 
21cc				 
21cc			FORTH_LOOP_POP: macro 
21cc				call macro_forth_loop_pop 
21cc				endm 
21cc			 
21cc			 
21cc			macro_forth_loop_pop: 
21cc				if DEBUG_FORTH_STACK_GUARD 
21cc					DMARK "LPP" 
21cc f5				push af  
21cd 3a e1 21			ld a, (.dmark)  
21d0 32 6e fe			ld (debug_mark),a  
21d3 3a e2 21			ld a, (.dmark+1)  
21d6 32 6f fe			ld (debug_mark+1),a  
21d9 3a e3 21			ld a, (.dmark+2)  
21dc 32 70 fe			ld (debug_mark+2),a  
21df 18 03			jr .pastdmark  
21e1 ..			.dmark: db "LPP"  
21e4 f1			.pastdmark: pop af  
21e5			endm  
# End of macro DMARK
21e5 cd 21 6d				call check_stacks 
21e8					FORTH_CHK_LOOP_UNDER 
21e8 e5				push hl 
21e9 d5				push de 
21ea 2a f7 f9			ld hl,(cli_loop_sp) 
21ed 11 31 f9			ld de, cli_loop_stack 
21f0 cd 6a 0f			call cmp16 
21f3 da 3b 6e			jp c, fault_loop_under 
21f6 d1				pop de 
21f7 e1				pop hl 
21f8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21f8				endif 
21f8 e5				push hl 
21f9 2a f7 f9			ld hl,(cli_loop_sp) 
21fc 2b				dec hl 
21fd 2b				dec hl 
21fe 22 f7 f9			ld (cli_loop_sp), hl 
2201				; TODO do stack underflow checks 
2201 e1				pop hl 
2202				if DEBUG_FORTH_STACK_GUARD 
2202 cd 21 6d				call check_stacks 
2205					FORTH_CHK_LOOP_UNDER 
2205 e5				push hl 
2206 d5				push de 
2207 2a f7 f9			ld hl,(cli_loop_sp) 
220a 11 31 f9			ld de, cli_loop_stack 
220d cd 6a 0f			call cmp16 
2210 da 3b 6e			jp c, fault_loop_under 
2213 d1				pop de 
2214 e1				pop hl 
2215				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2215				endif 
2215 c9				ret 
2216			 
2216			macro_forth_dsp_pop: 
2216			 
2216 e5				push hl 
2217			 
2217				; release malloc data 
2217			 
2217				if DEBUG_FORTH_STACK_GUARD 
2217 cd 21 6d				call check_stacks 
221a					FORTH_CHK_DSP_UNDER 
221a e5				push hl 
221b d5				push de 
221c 2a f5 f9			ld hl,(cli_data_sp) 
221f 11 2f f7			ld de, cli_data_stack 
2222 cd 6a 0f			call cmp16 
2225 da 2f 6e			jp c, fault_dsp_under 
2228 d1				pop de 
2229 e1				pop hl 
222a				endm 
# End of macro FORTH_CHK_DSP_UNDER
222a				endif 
222a				;ld hl,(cli_data_sp) 
222a			if DEBUG_FORTH_DOT 
222a				DMARK "DPP" 
222a f5				push af  
222b 3a 3f 22			ld a, (.dmark)  
222e 32 6e fe			ld (debug_mark),a  
2231 3a 40 22			ld a, (.dmark+1)  
2234 32 6f fe			ld (debug_mark+1),a  
2237 3a 41 22			ld a, (.dmark+2)  
223a 32 70 fe			ld (debug_mark+2),a  
223d 18 03			jr .pastdmark  
223f ..			.dmark: db "DPP"  
2242 f1			.pastdmark: pop af  
2243			endm  
# End of macro DMARK
2243				CALLMONITOR 
2243 cd f3 18			call break_point_state  
2246				endm  
# End of macro CALLMONITOR
2246			endif	 
2246			 
2246			 
2246			if FORTH_ENABLE_DSPPOPFREE 
2246			 
2246				FORTH_DSP 
2246 cd 24 21			call macro_forth_dsp 
2249				endm 
# End of macro FORTH_DSP
2249			 
2249 7e				ld a, (hl) 
224a fe 01			cp DS_TYPE_STR 
224c 20 23			jr nz, .skippopfree 
224e			 
224e				FORTH_DSP_VALUEHL 
224e cd 5e 21			call macro_dsp_valuehl 
2251				endm 
# End of macro FORTH_DSP_VALUEHL
2251 00				nop 
2252			if DEBUG_FORTH_DOT 
2252				DMARK "DPf" 
2252 f5				push af  
2253 3a 67 22			ld a, (.dmark)  
2256 32 6e fe			ld (debug_mark),a  
2259 3a 68 22			ld a, (.dmark+1)  
225c 32 6f fe			ld (debug_mark+1),a  
225f 3a 69 22			ld a, (.dmark+2)  
2262 32 70 fe			ld (debug_mark+2),a  
2265 18 03			jr .pastdmark  
2267 ..			.dmark: db "DPf"  
226a f1			.pastdmark: pop af  
226b			endm  
# End of macro DMARK
226b				CALLMONITOR 
226b cd f3 18			call break_point_state  
226e				endm  
# End of macro CALLMONITOR
226e			endif	 
226e cd dd 14			call free 
2271			.skippopfree: 
2271				 
2271			 
2271			endif 
2271			 
2271			if DEBUG_FORTH_DOT_KEY 
2271				DMARK "DP2" 
2271				CALLMONITOR 
2271			endif	 
2271			 
2271				; move pointer down 
2271			 
2271 2a f5 f9			ld hl,(cli_data_sp) 
2274 2b				dec hl 
2275 2b				dec hl 
2276			; PARSEV5 
2276 2b				dec hl 
2277 22 f5 f9			ld (cli_data_sp), hl 
227a			 
227a				if DEBUG_FORTH_STACK_GUARD 
227a cd 21 6d				call check_stacks 
227d					FORTH_CHK_DSP_UNDER 
227d e5				push hl 
227e d5				push de 
227f 2a f5 f9			ld hl,(cli_data_sp) 
2282 11 2f f7			ld de, cli_data_stack 
2285 cd 6a 0f			call cmp16 
2288 da 2f 6e			jp c, fault_dsp_under 
228b d1				pop de 
228c e1				pop hl 
228d				endm 
# End of macro FORTH_CHK_DSP_UNDER
228d				endif 
228d			 
228d e1				pop hl 
228e			 
228e c9				ret 
228f			 
228f			getwordathl: 
228f				; hl points to an address 
228f				; load hl with the word at that address 
228f			 
228f d5				push de 
2290			 
2290 5e				ld e, (hl) 
2291 23				inc hl 
2292 56				ld d, (hl) 
2293 eb				ex de, hl 
2294			 
2294 d1				pop de 
2295 c9				ret 
2296			 
2296			 
2296			 
2296			 
2296			 
2296			; eof 
2296			 
# End of file forth_stackopsv5.asm
2296			endif 
2296			 
2296			user_word_eol:  
2296				; hl contains the pointer to where to create a linked list item from the end 
2296				; of the user dict to continue on at the system word dict 
2296				 
2296				; poke the stub of the word list linked list to repoint to rom words 
2296			 
2296				; stub format 
2296				; db   word id 
2296				; dw    link to next word 
2296			        ; db char length of token 
2296				; db string + 0 term 
2296				; db exec code....  
2296			 
2296 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2298 77				ld (hl), a		; word id 
2299 23				inc hl 
229a			 
229a 11 65 24			ld de, sysdict 
229d 73				ld (hl), e		; next word link ie system dict 
229e 23				inc hl 
229f 72				ld (hl), d		; next word link ie system dict 
22a0 23				inc hl	 
22a1			 
22a1			;	ld (hl), sysdict		; next word link ie system dict 
22a1			;	inc hl 
22a1			;	inc hl 
22a1			 
22a1			;	inc hl 
22a1			;	inc hl 
22a1			 
22a1 3e 02			ld a, 2			; word length is 0 
22a3 77				ld (hl), a	 
22a4 23				inc hl 
22a5			 
22a5 3e 7e			ld a, '~'			; word length is 0 
22a7 77				ld (hl), a	 
22a8 23				inc hl 
22a9 3e 00			ld a, 0			; save empty word 
22ab 77				ld (hl), a 
22ac			 
22ac c9				ret 
22ad			 
22ad				 
22ad			 
22ad			forthexec_cleanup: 
22ad				FORTH_RSP_POP 
22ad cd 2f 1f			call macro_forth_rsp_pop 
22b0				endm 
# End of macro FORTH_RSP_POP
22b0 c9				ret 
22b1			 
22b1			forth_call_hl: 
22b1				; taking hl 
22b1 e5				push hl 
22b2 c9				ret 
22b3			 
22b3			; this is called to reset Forth system but keep existing uwords etc 
22b3			 
22b3			forth_warmstart: 
22b3				; setup stack over/under flow checks 
22b3				if DEBUG_FORTH_STACK_GUARD 
22b3 cd 07 6d				call chk_stk_init 
22b6				endif 
22b6			 
22b6				; init stack pointers  - * these stacks go upwards *  
22b6 21 b3 f9			ld hl, cli_ret_stack 
22b9 22 f9 f9			ld (cli_ret_sp), hl	 
22bc				; set bottom of stack 
22bc 3e 00			ld a,0 
22be 77				ld (hl),a 
22bf 23				inc hl 
22c0 77				ld (hl),a 
22c1			 
22c1 21 2f f7			ld hl, cli_data_stack 
22c4 22 f5 f9			ld (cli_data_sp), hl	 
22c7				; set bottom of stack 
22c7 3e 00			ld a,0 
22c9 77				ld (hl),a 
22ca 23				inc hl 
22cb 77				ld (hl),a 
22cc			 
22cc 21 31 f9			ld hl, cli_loop_stack 
22cf 22 f7 f9			ld (cli_loop_sp), hl	 
22d2				; set bottom of stack 
22d2 3e 00			ld a,0 
22d4 77				ld (hl),a 
22d5 23				inc hl 
22d6 77				ld (hl),a 
22d7			 
22d7				; init extent of current open file 
22d7			 
22d7 3e 00			ld a, 0 
22d9 32 71 fa			ld (store_openext), a 
22dc			 
22dc c9				ret 
22dd			 
22dd			 
22dd			; Cold Start - this is called to setup the whole Forth system 
22dd			 
22dd			forth_init: 
22dd			 
22dd				; setup stack over/under flow checks 
22dd			 
22dd			;	if DEBUG_FORTH_STACK_GUARD 
22dd			;		call chk_stk_init 
22dd			;	endif 
22dd			 
22dd				; enable auto display updates (slow.....) 
22dd			 
22dd 3e 01			ld a, 1 
22df 32 43 fa			ld (cli_autodisplay), a 
22e2			 
22e2				; if storage is in use disable long reads for now 
22e2 3e 00			ld a, 0 
22e4 32 7c fa			ld (store_longread), a 
22e7			 
22e7			 
22e7				; show start up screen 
22e7			 
22e7 cd 18 0d			call clear_display 
22ea			 
22ea 3e 00			ld a,0 
22ec 32 65 fa			ld (f_cursor_ptr), a 
22ef			 
22ef				; set start of word list in start of ram - for use when creating user words 
22ef			 
22ef 21 00 80			ld hl, baseram 
22f2 22 c5 f4			ld (os_last_new_uword), hl 
22f5 cd 96 22			call user_word_eol 
22f8				 
22f8			;		call display_data_sp 
22f8			;		call next_page_prompt 
22f8			 
22f8			 
22f8			 
22f8			 
22f8 c9				ret 
22f9			 
22f9 .. 00		.bootforth: db " Forth Kernel Init ",0 
230d			 
230d			; TODO push to stack 
230d			 
230d			;  
230d			 
230d			if FORTH_PARSEV2 
230d			 
230d			 
230d				include "forth_parserv2.asm" 
230d			 
230d			endif 
230d			 
230d			 
230d			; parse cli version 1 
230d			 
230d			if FORTH_PARSEV1 
230d			 
230d			 
230d			 
230d			      include "forth_parserv1.asm" 
230d			endif 
230d				 
230d			if FORTH_PARSEV3 
230d			 
230d			 
230d			 
230d			      include "forth_parserv3.asm" 
230d				include "forth_wordsv3.asm" 
230d			endif 
230d			 
230d			if FORTH_PARSEV4 
230d			 
230d			 
230d			 
230d			      include "forth_parserv4.asm" 
230d				include "forth_wordsv4.asm" 
230d			endif 
230d			 
230d			if FORTH_PARSEV5 
230d			 
230d			 
230d			 
230d			      include "forth_parserv5.asm" 
230d			 
230d			 
230d			; A better parser without using malloc and string copies all over the place.  
230d			; Exec in situ should be faster 
230d			 
230d			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
230d			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
230d			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
230d			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
230d			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
230d			WORD_SYS_END: equ 0   ; Opcode for all user words 
230d			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
230d			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
230d			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
230d			 
230d			; Core word preamble macro 
230d			 
230d			CWHEAD:   macro nxtword opcode lit len opflags 
230d				db WORD_SYS_CORE+opcode             
230d				; internal op code number 
230d				dw nxtword            
230d				; link to next dict word block 
230d				db len + 1 
230d				; literal length of dict word inc zero term 
230d				db lit,0              
230d				; literal dict word 
230d			        ; TODO db opflags        
230d				endm 
230d			 
230d			 
230d			NEXTW: macro  
230d				jp macro_next 
230d				endm 
230d			 
230d			macro_next: 
230d			if DEBUG_FORTH_PARSE_KEY 
230d				DMARK "NXT" 
230d				CALLMONITOR 
230d			endif	 
230d			;	inc hl  ; skip token null term  
230d ed 4b 47 fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2311 ed 5b 45 fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2315 2a c9 f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2318			if DEBUG_FORTH_PARSE_KEY 
2318				DMARK "}AA" 
2318				CALLMONITOR 
2318			endif	 
2318 c3 1b 24			jp execnext 
231b				;jp exec1 
231b			       
231b			 
231b			 
231b			; Another go at the parser to compile  
231b			 
231b			 
231b			; TODO rework parser to change all of the string words to byte tokens 
231b			; TODO do a search for  
231b			 
231b			; TODO first run normal parser to zero term sections 
231b			; TODO for each word do a token look up to get the op code 
231b			; TODO need some means to flag to the exec that this is a byte code form    
231b			 
231b			 
231b			forthcompile: 
231b			 
231b			; 
231b			; line parse: 
231b			;       parse raw input buffer 
231b			;       tokenise the words 
231b			;       malloc new copy (for looping etc) 
231b			;       copy to malloc + current pc in line to start of string and add line term 
231b			;       save on new rsp 
231b			; 
231b			 
231b			; hl to point to the line to tokenise 
231b			 
231b			;	push hl 
231b 22 c9 f4			ld (os_tok_ptr), hl  ; save ptr to string 
231e			 
231e			;	ld a,0		; string term on input 
231e			;	call strlent 
231e			 
231e			;	ld (os_tok_len), hl	 ; save string length 
231e			 
231e			;if DEBUG_FORTH_TOK 
231e			;	ex de,hl		 
231e			;endif 
231e			 
231e			;	pop hl 		; get back string pointer 
231e			 
231e			if DEBUG_FORTH_TOK 
231e						DMARK "TOc" 
231e				CALLMONITOR 
231e			endif 
231e 7e			.cptoken2:    ld a,(hl) 
231f 23				inc hl 
2320 fe 7f			cp FORTH_END_BUFFER 
2322 28 29			jr z, .cptokendone2 
2324 fe 00			cp 0 
2326 28 25			jr z, .cptokendone2 
2328 fe 22			cp '"' 
232a 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
232c fe 20			cp ' ' 
232e 20 ee			jr nz,  .cptoken2 
2330			 
2330			; TODO consume comments held between ( and ) 
2330			 
2330				; we have a space so change to zero term for dict match later 
2330 2b				dec hl 
2331 3e 00			ld a,0 
2333 77				ld (hl), a 
2334 23				inc hl 
2335 18 e7			jr .cptoken2 
2337				 
2337			 
2337			.cptokenstr2: 
2337				; skip all white space until either eol (because forgot to term) or end double quote 
2337			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2337				;inc hl ; skip current double quote 
2337 7e				ld a,(hl) 
2338 23				inc hl 
2339 fe 22			cp '"' 
233b 28 e1			jr z, .cptoken2 
233d fe 7f			cp FORTH_END_BUFFER 
233f 28 0c			jr z, .cptokendone2 
2341 fe 00			cp 0 
2343 28 08			jr z, .cptokendone2 
2345 fe 20			cp ' ' 
2347 28 02			jr z, .cptmp2 
2349 18 ec			jr .cptokenstr2 
234b			 
234b			.cptmp2:	; we have a space so change to zero term for dict match later 
234b				;dec hl 
234b				;ld a,"-"	; TODO remove this when working 
234b				;ld (hl), a 
234b				;inc hl 
234b 18 ea			jr .cptokenstr2 
234d			 
234d			.cptokendone2: 
234d				;inc hl 
234d 3e 7f			ld a, FORTH_END_BUFFER 
234f 77				ld (hl),a 
2350 23				inc hl 
2351 3e 21			ld a, '!' 
2353 77				ld (hl),a 
2354			 
2354 2a c9 f4			ld hl,(os_tok_ptr) 
2357			         
2357			if DEBUG_FORTH_TOK 
2357						DMARK "Tc1" 
2357				CALLMONITOR 
2357			endif 
2357			 
2357				; push exec string to top of return stack 
2357				FORTH_RSP_NEXT 
2357 cd 0e 1f			call macro_forth_rsp_next 
235a				endm 
# End of macro FORTH_RSP_NEXT
235a c9				ret 
235b			 
235b			; Another go at the parser need to simplify the process 
235b			 
235b			forthparse: 
235b			 
235b			; 
235b			; line parse: 
235b			;       parse raw input buffer 
235b			;       tokenise the words 
235b			;       malloc new copy (for looping etc) 
235b			;       copy to malloc + current pc in line to start of string and add line term 
235b			;       save on new rsp 
235b			; 
235b			 
235b			; hl to point to the line to tokenise 
235b			 
235b			;	push hl 
235b 22 c9 f4			ld (os_tok_ptr), hl  ; save ptr to string 
235e			 
235e			;	ld a,0		; string term on input 
235e			;	call strlent 
235e			 
235e			;	ld (os_tok_len), hl	 ; save string length 
235e			 
235e			;if DEBUG_FORTH_TOK 
235e			;	ex de,hl		 
235e			;endif 
235e			 
235e			;	pop hl 		; get back string pointer 
235e			 
235e			if DEBUG_FORTH_TOK 
235e						DMARK "TOK" 
235e				CALLMONITOR 
235e			endif 
235e 7e			.ptoken2:    ld a,(hl) 
235f 23				inc hl 
2360 fe 7f			cp FORTH_END_BUFFER 
2362 28 29			jr z, .ptokendone2 
2364 fe 00			cp 0 
2366 28 25			jr z, .ptokendone2 
2368 fe 22			cp '"' 
236a 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
236c fe 20			cp ' ' 
236e 20 ee			jr nz,  .ptoken2 
2370			 
2370			; TODO consume comments held between ( and ) 
2370			 
2370				; we have a space so change to zero term for dict match later 
2370 2b				dec hl 
2371 3e 00			ld a,0 
2373 77				ld (hl), a 
2374 23				inc hl 
2375 18 e7			jr .ptoken2 
2377				 
2377			 
2377			.ptokenstr2: 
2377				; skip all white space until either eol (because forgot to term) or end double quote 
2377			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2377				;inc hl ; skip current double quote 
2377 7e				ld a,(hl) 
2378 23				inc hl 
2379 fe 22			cp '"' 
237b 28 e1			jr z, .ptoken2 
237d fe 7f			cp FORTH_END_BUFFER 
237f 28 0c			jr z, .ptokendone2 
2381 fe 00			cp 0 
2383 28 08			jr z, .ptokendone2 
2385 fe 20			cp ' ' 
2387 28 02			jr z, .ptmp2 
2389 18 ec			jr .ptokenstr2 
238b			 
238b			.ptmp2:	; we have a space so change to zero term for dict match later 
238b				;dec hl 
238b				;ld a,"-"	; TODO remove this when working 
238b				;ld (hl), a 
238b				;inc hl 
238b 18 ea			jr .ptokenstr2 
238d			 
238d			.ptokendone2: 
238d				;inc hl 
238d 3e 7f			ld a, FORTH_END_BUFFER 
238f 77				ld (hl),a 
2390 23				inc hl 
2391 3e 21			ld a, '!' 
2393 77				ld (hl),a 
2394			 
2394 2a c9 f4			ld hl,(os_tok_ptr) 
2397			         
2397			if DEBUG_FORTH_TOK 
2397						DMARK "TK1" 
2397				CALLMONITOR 
2397			endif 
2397			 
2397				; push exec string to top of return stack 
2397				FORTH_RSP_NEXT 
2397 cd 0e 1f			call macro_forth_rsp_next 
239a				endm 
# End of macro FORTH_RSP_NEXT
239a c9				ret 
239b			 
239b			; 
239b			;	; malloc size + buffer pointer + if is loop flag 
239b			;	ld hl,(os_tok_len) 		 ; get string length 
239b			; 
239b			;	ld a,l 
239b			; 
239b			;	cp 0			; we dont want to use a null string 
239b			;	ret z 
239b			; 
239b			;;	add 3    ; prefix malloc with buffer for current word ptr 
239b			; 
239b			;	add 5     ; TODO when certain not over writing memory remove 
239b			; 
239b			;		 
239b			; 
239b			;if DEBUG_FORTH_TOK 
239b			;			DMARK "TKE" 
239b			;	CALLMONITOR 
239b			;endif 
239b			; 
239b			;	ld l,a 
239b			;	ld h,0 
239b			;;	push hl   ; save required space for the copy later 
239b			;	call malloc 
239b			;if DEBUG_FORTH_TOK 
239b			;			DMARK "TKM" 
239b			;	CALLMONITOR 
239b			;endif 
239b			;	if DEBUG_FORTH_MALLOC_GUARD 
239b			;		push af 
239b			;		call ishlzero 
239b			;;		ld a, l 
239b			;;		add h 
239b			;;		cp 0 
239b			;		pop af 
239b			;		 
239b			;		call z,malloc_error 
239b			;	endif 
239b			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
239b			; 
239b			; 
239b			;if DEBUG_FORTH_TOK 
239b			;			DMARK "TKR" 
239b			;	CALLMONITOR 
239b			;endif 
239b			; 
239b			;	FORTH_RSP_NEXT 
239b			; 
239b			;	;inc hl	 ; go past current buffer pointer 
239b			;	;inc hl 
239b			;	;inc hl   ; and past if loop flag 
239b			;		; TODO Need to set flag  
239b			; 
239b			;	 
239b			;	 
239b			;	ex de,hl	; malloc is dest 
239b			;	ld hl, (os_tok_len) 
239b			;;	pop bc 
239b			;	ld c, l                
239b			;	ld b,0 
239b			;	ld hl, (os_tok_ptr) 
239b			; 
239b			;if DEBUG_FORTH_TOK 
239b			;			DMARK "TKT" 
239b			;	CALLMONITOR 
239b			;endif 
239b			; 
239b			;	; do str cpy 
239b			; 
239b			;	ldir      ; copy byte in hl to de 
239b			; 
239b			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
239b			; 
239b			;if DEBUG_FORTH_TOK 
239b			; 
239b			;			DMARK "TKY" 
239b			;	CALLMONITOR 
239b			;endif 
239b			;	;ld a,0 
239b			;	;ld a,FORTH_END_BUFFER 
239b			;	ex de, hl 
239b			;	;dec hl			 ; go back over the space delim at the end of word 
239b			;	;ld (hl),a 
239b			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
239b			;	ld a,FORTH_END_BUFFER 
239b			;	ld (hl),a 
239b			;	inc hl 
239b			;	ld a,FORTH_END_BUFFER 
239b			;	ld (hl),a 
239b			; 
239b			;	; init the malloc area data 
239b			;	; set pc for in current area 
239b			;	;ld hl, (os_tok_malloc) 
239b			;	;inc hl 
239b			;	;inc hl 
239b			;	;inc hl 
239b			;	;ex de,hl 
239b			;	;ld hl, (os_tok_malloc) 
239b			;	;ld (hl),e 
239b			;	;inc hl 
239b			;	;ld (hl),d 
239b			; 
239b			; 
239b			;	ld hl,(os_tok_malloc) 
239b			;if DEBUG_FORTH_PARSE_KEY 
239b			;			DMARK "TKU" 
239b			;	CALLMONITOR 
239b			;endif 
239b			; 
239b			;	ret 
239b			 
239b			forthexec: 
239b			 
239b			; line exec: 
239b			; forth parser 
239b			 
239b			; 
239b			;       get current exec line on rsp 
239b			 
239b				FORTH_RSP_TOS 
239b cd 25 1f			call macro_forth_rsp_tos 
239e				endm 
# End of macro FORTH_RSP_TOS
239e			 
239e			;       restore current pc - hl points to malloc of data 
239e			 
239e				;ld e, (hl) 
239e				;inc hl 
239e				;ld d, (hl) 
239e				;ex de,hl 
239e			 
239e			 
239e			exec1: 
239e 22 c9 f4			ld (os_tok_ptr), hl 
23a1			 
23a1				; copy our PC to working vars  
23a1 22 47 fa			ld (cli_ptr), hl 
23a4 22 45 fa			ld (cli_origptr), hl 
23a7			 
23a7 7e				ld a,(hl) 
23a8 fe 7f			cp FORTH_END_BUFFER 
23aa c8				ret z 
23ab			 
23ab				; skip any nulls 
23ab			 
23ab fe 00			cp 0 
23ad 20 03			jr nz, .execword 
23af 23				inc hl 
23b0 18 ec			jr exec1 
23b2			 
23b2			 
23b2			.execword: 
23b2			 
23b2			 
23b2			 
23b2			if DEBUG_FORTH_PARSE_KEY 
23b2						DMARK "KYQ" 
23b2				CALLMONITOR 
23b2			endif 
23b2			;       while at start of word: 
23b2			; get start of dict (in user area first) 
23b2			 
23b2 21 00 80		ld hl, baseram 
23b5			;ld hl, sysdict 
23b5 22 49 fa		ld (cli_nextword),hl 
23b8			;           match word at pc 
23b8			;           exec word 
23b8			;           or push to dsp 
23b8			;           forward to next token 
23b8			;           if line term pop rsp and exit 
23b8			;        
23b8			 
23b8			if DEBUG_FORTH_PARSE_KEY 
23b8						DMARK "KYq" 
23b8				CALLMONITOR 
23b8			endif 
23b8			 
23b8			; 
23b8			; word comp 
23b8			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
23b8			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
23b8			;    move to start of word  
23b8			;    compare word to cli_token 
23b8			 
23b8			.execpnword:	; HL at start of a word in the dictionary to check 
23b8			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
23b8			;	ld (cli_ptr), hl 
23b8			 
23b8 2a 49 fa			ld hl,(cli_nextword) 
23bb			 
23bb cd 5e 24			call forth_tok_next 
23be			; tok next start here 
23be			;	; TODO skip compiled symbol for now 
23be			;	inc hl 
23be			; 
23be			;	; save pointer to next word 
23be			; 
23be			;	; hl now points to the address of the next word pointer  
23be			;	ld e, (hl) 
23be			;	inc hl 
23be			;	ld d, (hl) 
23be			;	inc l 
23be			; 
23be			;	ex de,hl 
23be			;if DEBUG_FORTH_PARSE_NEXTWORD 
23be			;	push bc 
23be			;	ld bc, (cli_nextword) 
23be			;			DMARK "NXW" 
23be			;	CALLMONITOR 
23be			;	pop bc 
23be			;endif 
23be			; tok next end here 
23be 22 49 fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
23c1 eb				ex de, hl 
23c2			 
23c2			 
23c2				; save the pointer of the current token - 1 to check against 
23c2				 
23c2 22 4d fa			ld (cli_token), hl   
23c5				; TODO maybe remove below save if no debug 
23c5				; save token string ptr for any debug later 
23c5 23				inc hl  
23c6 22 4f fa			ld (cli_origtoken), hl 
23c9 2b				dec hl 
23ca				; save pointer to the start of the next dictionay word 
23ca 7e				ld a,(hl)   ; get string length 
23cb 47				ld b,a 
23cc			.execpnwordinc:  
23cc 23				inc hl 
23cd 10 fd			djnz .execpnwordinc 
23cf 22 4b fa			ld (cli_execword), hl      ; save start of this words code 
23d2			 
23d2				; now check the word token against the string being parsed 
23d2			 
23d2 2a 4d fa			ld hl,(cli_token) 
23d5 23				inc hl     ; skip string length (use zero term instead to end) 
23d6 22 4d fa			ld (cli_token), hl 
23d9			 
23d9			if DEBUG_FORTH_PARSE_KEY 
23d9						DMARK "KY2" 
23d9			endif 
23d9			if DEBUG_FORTH_PARSE_EXEC 
23d9				; see if disabled 
23d9			 
23d9				ld a, (os_view_disable) 
23d9				cp '*' 
23d9				jr z, .skip 
23d9			 
23d9				push hl 
23d9				push hl 
23d9				call clear_display 
23d9				ld de, .compword 
23d9				ld a, display_row_1 
23d9				call str_at_display 
23d9				pop de 
23d9				ld a, display_row_2 
23d9				call str_at_display 
23d9				ld hl,(cli_ptr) 
23d9				ld a,(hl) 
23d9			        ld hl, os_word_scratch 
23d9				ld (hl),a 
23d9				ld a,0 
23d9				inc hl 
23d9				ld (hl),a 	 
23d9				ld de, os_word_scratch 
23d9				ld a, display_row_2+10 
23d9				call str_at_display 
23d9				call update_display 
23d9				ld a, 100 
23d9				call aDelayInMS 
23d9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23d9				call delay250ms 
23d9				endif 
23d9				pop hl 
23d9			.skip:  
23d9			endif	 
23d9			.execpnchar:    ; compare char between token and string to parse 
23d9			 
23d9			if DEBUG_FORTH_PARSE_KEY 
23d9						DMARK "Ky3" 
23d9			endif 
23d9			if DEBUG_FORTH_PARSE_EXEC 
23d9				; see if disabled 
23d9			 
23d9				ld a, (os_view_disable) 
23d9				cp '*' 
23d9				jr z, .skip2 
23d9			 
23d9			;	call clear_display 
23d9			ld hl,(cli_token) 
23d9			ld a,(hl) 
23d9			ld (os_word_scratch),a 
23d9				ld hl,(cli_ptr) 
23d9			ld a,(hl) 
23d9				ld (os_word_scratch+1),a 
23d9				ld a,0 
23d9				ld (os_word_scratch+2),a 
23d9				ld de,os_word_scratch 
23d9				ld a,display_row_4 
23d9				call str_at_display 
23d9				call update_display 
23d9			.skip2:  
23d9			endif 
23d9 2a 4d fa			ld hl,(cli_token) 
23dc 7e				ld a, (hl)	 ; char in word token 
23dd 23				inc hl 		; move to next char 
23de 22 4d fa			ld (cli_token), hl ; and save it 
23e1 47				ld b,a 
23e2			 
23e2 2a 47 fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
23e5 7e				ld a,(hl) 
23e6 23				inc hl 
23e7 22 47 fa			ld (cli_ptr), hl		; move to next char 
23ea cd a1 13			call toUpper 		; make sure the input string matches case 
23ed			 
23ed			if DEBUG_FORTH_PARSE 
23ed			endif 
23ed			 
23ed				; input stream end of token is a space so get rid of it 
23ed			 
23ed			;	cp ' ' 
23ed			;	jr nz, .pnskipspace 
23ed			; 
23ed			;	ld a, 0		; make same term as word token term 
23ed			; 
23ed			;.pnskipspace: 
23ed			 
23ed			if DEBUG_FORTH_PARSE_KEY 
23ed						DMARK "KY7" 
23ed			endif 
23ed b8				cp b 
23ee c2 04 24			jp nz, .execpnskipword	 ; no match so move to next word 
23f1				 
23f1			;    if same 
23f1			;       scan for string terms 0 for token and 32 for input 
23f1			 
23f1				 
23f1			if DEBUG_FORTH_PARSE_KEY 
23f1						DMARK "KY8" 
23f1			endif 
23f1			 
23f1 80				add b			 
23f2 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
23f4							; TODO need to make sure last word in zero term string is accounted for 
23f4 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
23f6			 
23f6			 
23f6				; at end of both strings so both are exact match 
23f6			 
23f6			;       skip ptr for next word 
23f6			 
23f6 2a 47 fa			ld hl,(cli_ptr) 	; at input string term 
23f9 23				inc hl			 ; at next char 
23fa 22 47 fa			ld (cli_ptr), hl     ; save for next round of the parser 
23fd 22 45 fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2400				 
2400				 
2400			if DEBUG_FORTH_PARSE_KEY 
2400						DMARK "KY3" 
2400			endif 
2400			 
2400			 
2400			 
2400			;       exec code block 
2400			if DEBUG_FORTH_JP 
2400				call clear_display 
2400				call update_display 
2400				call delay1s 
2400				ld hl, (cli_execword)     ; save for next check if no match on this word 
2400				ld a,h 
2400				ld hl, os_word_scratch 
2400				call hexout 
2400				ld hl, (cli_execword)     ; save for next check if no match on this word 
2400				ld a,l 
2400				ld hl, os_word_scratch+2 
2400				call hexout 
2400				ld hl, os_word_scratch+4 
2400				ld a,0 
2400				ld (hl),a 
2400				ld de,os_word_scratch 
2400				call str_at_display 
2400					ld a, display_row_2 
2400					call str_at_display 
2400				ld de, (cli_origtoken) 
2400				ld a, display_row_1+10 
2400					call str_at_display 
2400			 
2400				ld a,display_row_1 
2400				ld de, .foundword 
2400				ld a, display_row_3 
2400				call str_at_display 
2400				call update_display 
2400				call delay1s 
2400				call delay1s 
2400				call delay1s 
2400			endif 
2400			 
2400			if DEBUG_FORTH_PARSE_KEY 
2400						DMARK "KYj" 
2400			endif 
2400				; TODO save the word pointer in this exec 
2400			 
2400 2a 4b fa			ld hl,(cli_execword) 
2403 e9				jp (hl) 
2404			 
2404			 
2404			;    if not same 
2404			;	scan for zero term 
2404			;	get ptr for next word 
2404			;	goto word comp 
2404			 
2404			.execpnskipword:	; get pointer to next word 
2404 2a 49 fa			ld hl,(cli_nextword) 
2407			 
2407 7e				ld a,(hl) 
2408 fe 00			cp WORD_SYS_END 
240a			;	cp 0 
240a 28 09			jr z, .execendofdict			 ; at end of words 
240c			 
240c			if DEBUG_FORTH_PARSE_KEY 
240c						DMARK "KY4" 
240c			endif 
240c			if DEBUG_FORTH_PARSE_EXEC 
240c			 
240c				; see if disabled 
240c			 
240c				ld a, (os_view_disable) 
240c				cp '*' 
240c				jr z, .noskip 
240c			 
240c			 
240c				ld de, .nowordfound 
240c				ld a, display_row_3 
240c				call str_at_display 
240c				call update_display 
240c				ld a, 100 
240c				call aDelayInMS 
240c				 
240c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
240c					call delay250ms 
240c				endif 
240c			.noskip:  
240c			 
240c			endif	 
240c			 
240c 2a 45 fa			ld hl,(cli_origptr) 
240f 22 47 fa			ld (cli_ptr),hl 
2412			 
2412			if DEBUG_FORTH_PARSE_KEY 
2412						DMARK "KY5" 
2412			endif 
2412 c3 b8 23			jp .execpnword			; else go to next word 
2415			 
2415			.execendofdict:  
2415			 
2415			if DEBUG_FORTH_PARSE_KEY 
2415						DMARK "KYe" 
2415			endif 
2415			if DEBUG_FORTH_PARSE_EXEC 
2415				; see if disabled 
2415			 
2415				ld a, (os_view_disable) 
2415				cp '*' 
2415				jr z, .ispskip 
2415			 
2415				call clear_display 
2415				call update_display 
2415				call delay1s 
2415				ld de, (cli_origptr) 
2415				ld a, display_row_1 
2415				call str_at_display 
2415				 
2415				ld de, .enddict 
2415				ld a, display_row_3 
2415				call str_at_display 
2415				call update_display 
2415				ld a, 100 
2415				call aDelayInMS 
2415				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2415				call delay1s 
2415				call delay1s 
2415				call delay1s 
2415				endif 
2415			.ispskip:  
2415				 
2415			endif	 
2415			 
2415			 
2415			 
2415				; if the word is not a keyword then must be a literal so push it to stack 
2415			 
2415			; push token to stack to end of word 
2415			 
2415				STACKFRAME ON $1efe $2f9f 
2415				if DEBUG_STACK_IMB 
2415					if ON 
2415						exx 
2415						ld de, $1efe 
2415						ld a, d 
2415						ld hl, curframe 
2415						call hexout 
2415						ld a, e 
2415						ld hl, curframe+2 
2415						call hexout 
2415						ld hl, $1efe 
2415						push hl 
2415						ld hl, $2f9f 
2415						push hl 
2415						exx 
2415					endif 
2415				endif 
2415			endm 
# End of macro STACKFRAME
2415			 
2415 2a c9 f4		ld hl,(os_tok_ptr) 
2418 cd d0 20		call forth_apush 
241b			 
241b				STACKFRAMECHK ON $1efe $2f9f 
241b				if DEBUG_STACK_IMB 
241b					if ON 
241b						exx 
241b						ld hl, $2f9f 
241b						pop de   ; $2f9f 
241b						call cmp16 
241b						jr nz, .spnosame 
241b						ld hl, $1efe 
241b						pop de   ; $1efe 
241b						call cmp16 
241b						jr z, .spfrsame 
241b						.spnosame: call showsperror 
241b						.spfrsame: nop 
241b						exx 
241b					endif 
241b				endif 
241b			endm 
# End of macro STACKFRAMECHK
241b			 
241b			execnext: 
241b			 
241b			if DEBUG_FORTH_PARSE_KEY 
241b						DMARK "KY>" 
241b			endif 
241b			; move past token to next word 
241b			 
241b 2a c9 f4		ld hl, (os_tok_ptr) 
241e 3e 00		ld a, 0 
2420 01 ff 00		ld bc, 255     ; input buffer size 
2423 ed b1		cpir 
2425			 
2425			if DEBUG_FORTH_PARSE_KEY 
2425						DMARK "KY!" 
2425				CALLMONITOR 
2425			endif	 
2425			; TODO this might place hl on the null, so will need to forward on??? 
2425			;inc hl   ; see if this gets onto the next item 
2425			 
2425			 
2425			; TODO pass a pointer to the buffer to push 
2425			; TODO call function to push 
2425			 
2425			; look for end of input 
2425			 
2425			;inc hl 
2425			;ld a,(hl) 
2425			;cp FORTH_END_BUFFER 
2425			;ret z 
2425			 
2425			 
2425 c3 9e 23		jp exec1 
2428			 
2428			 
2428			 
2428			 
2428			 
2428			 
2428			 
2428			 
2428			 
2428			findnexttok: 
2428			 
2428				; hl is pointer to move 
2428				; de is the token to locate 
2428			 
2428					if DEBUG_FORTH 
2428						DMARK "NTK" 
2428						CALLMONITOR 
2428					endif 
2428 d5				push de 
2429			 
2429			.fnt1:	 
2429				; find first char of token to locate 
2429			 
2429 1a				ld a, (de) 
242a 4f				ld c,a 
242b 7e				ld a,(hl) 
242c cd a1 13			call toUpper 
242f					if DEBUG_FORTH 
242f						DMARK "NT1" 
242f						CALLMONITOR 
242f					endif 
242f b9				cp c 
2430			 
2430 28 03			jr z, .fnt2cmpmorefirst	 
2432			 
2432				; first char not found move to next char 
2432			 
2432 23				inc hl 
2433 18 f4			jr .fnt1 
2435			 
2435			.fnt2cmpmorefirst:	 
2435				; first char of token found.  
2435			 
2435 e5				push hl     ; save start of token just in case it is the right one 
2436 d9				exx 
2437 e1				pop hl        ; save it to hl' 
2438 d9				exx 
2439			 
2439			 
2439			.fnt2cmpmore:	 
2439				; compare the rest 
2439				 
2439 23				inc hl 
243a 13				inc de 
243b				 
243b 1a				ld a, (de) 
243c 4f				ld c,a 
243d 7e				ld a,(hl) 
243e cd a1 13			call toUpper 
2441			 
2441					if DEBUG_FORTH 
2441						DMARK "NT2" 
2441						CALLMONITOR 
2441					endif 
2441				; c has the token to find char 
2441				; a has the mem to scan char 
2441			 
2441 b9				cp c 
2442 28 04			jr z,.fntmatch1 
2444			 
2444				; they are not the same 
2444			 
2444					if DEBUG_FORTH 
2444						DMARK "NT3" 
2444						CALLMONITOR 
2444					endif 
2444 d1				pop de	; reset de token to look for 
2445 d5				push de 
2446 18 e1			jr .fnt1 
2448				 
2448			.fntmatch1: 
2448			 
2448				; is the same char a null which means we might have a full hit? 
2448					if DEBUG_FORTH 
2448						DMARK "NT4" 
2448						CALLMONITOR 
2448					endif 
2448			 
2448 fe 00			cp 0 
244a 28 0b			jr z, .fntmatchyes 
244c			 
244c				; are we at the end of the token to find? 
244c			 
244c					if DEBUG_FORTH 
244c						DMARK "NT5" 
244c						CALLMONITOR 
244c					endif 
244c 3e 00			ld a, 0 
244e b9				cp c 
244f			 
244f c2 39 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2452			 
2452					if DEBUG_FORTH 
2452						DMARK "NT6" 
2452						CALLMONITOR 
2452					endif 
2452				; token to find is exhusted but no match to stream 
2452			 
2452				; restore tok pointer and continue on 
2452 d1				pop de 
2453 d5				push de 
2454 c3 29 24			jp .fnt1 
2457			 
2457			 
2457			.fntmatchyes: 
2457			 
2457				; hl now contains the end of the found token 
2457			 
2457				; get rid of saved token pointer to find 
2457			 
2457 d1				pop de 
2458			 
2458					if DEBUG_FORTH 
2458						DMARK "NT9" 
2458						CALLMONITOR 
2458					endif 
2458			 
2458				; hl will be on the null term so forward on 
2458			 
2458				; get back the saved start of the token 
2458			 
2458 d9				exx 
2459 e5				push hl     ; save start of token just in case it is the right one 
245a d9				exx 
245b e1				pop hl        ; save it to hl 
245c			 
245c c9				ret 
245d			 
245d			 
245d			; LIST needs to find a specific token   
245d			; FORGET needs to find a spefici token 
245d			 
245d			; SAVE needs to find all tokens by flag 
245d			; WORDS just needs to scan through all  by flag 
245d			; UWORDS needs to scan through all by flag 
245d			 
245d			 
245d			; given hl as pointer to start of dict look up string 
245d			; return hl as pointer to start of word block 
245d			; or 0 if not found 
245d			 
245d			forth_find_tok: 
245d c9				ret 
245e			 
245e			; given hl as pointer to dict structure 
245e			; move to the next dict block structure 
245e			 
245e			forth_tok_next: 
245e				; hl now points to the address of the next word pointer  
245e				; TODO skip compiled symbol for now 
245e			;	push de 
245e 23				inc hl 
245f 5e				ld e, (hl) 
2460 23				inc hl 
2461 56				ld d, (hl) 
2462 23				inc hl 
2463			 
2463 eb				ex de,hl 
2464			if DEBUG_FORTH_PARSE_NEXTWORD 
2464				push bc 
2464				ld bc, (cli_nextword) 
2464						DMARK "NXW" 
2464				CALLMONITOR 
2464				pop bc 
2464			endif 
2464			;	pop de	 
2464 c9				ret 
2465			 
2465			 
2465			 
2465			; eof 
# End of file forth_parserv5.asm
2465				include "forth_wordsv4.asm" 
2465			 
2465			; the core word dictionary v4 
2465			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2465			 
2465			; this is a linked list for each of the system words used 
2465			; user defined words will follow the same format but will be in ram 
2465			 
2465			 
2465			; 
2465			; 
2465			; define linked list: 
2465			; 
2465			; 1. compiled byte op code 
2465			; 2. len of text word 
2465			; 3. text word 
2465			; 4. ptr to next dictionary word 
2465			; 5. asm, calls etc for the word 
2465			; 
2465			;  if 1 == 0 then last word in dict  
2465			;   
2465			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2465			;  
2465			;  
2465			; create basic standard set of words 
2465			; 
2465			;  
2465			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2465			; 2DUP 2DROP 2SWAP  
2465			; @ C@ - get byte  
2465			; ! C! - store byte 
2465			; 0< true if less than zero 
2465			; 0= true if zero 
2465			; < >  
2465			; = true if same 
2465			; variables 
2465			 
2465			 
2465			; Hardware specific words I may need 
2465			; 
2465			; IN OUT  
2465			; calls to key util functions 
2465			; calls to hardward abstraction stuff 
2465			; easy control of frame buffers and lcd i/o 
2465			; keyboard  
2465			 
2465			 
2465			;DICT: macro 
2465			; op_code, len, word, next 
2465			;    word: 
2465			;    db op_code 
2465			;    ds word zero term 
2465			;    dw next 
2465			;    endm 
2465			 
2465			 
2465			 
2465			 
2465			; op code 1 is a flag for user define words which are to be handled differently 
2465			 
2465			 
2465			; 
2465			; 
2465			;    TODO on entry to a word this should be the expected environment 
2465			;    hl - tos value if number then held, if string this is the ptr 
2465			;    de -  
2465			 
2465			 
2465			; opcode ranges 
2465			; 0 - end of word dict 
2465			; 255 - user define words 
2465			 
2465			sysdict: 
2465			include "forth_opcodes.asm" 
2465			; op codes for forth keywords 
2465			; free to use code 0  
2465				OPCODE_HEAP: equ  1 
2465				OPCODE_EXEC: equ 2 
2465				OPCODE_DUP: equ 3 
2465				OPCODE_SWAP: equ 4 
2465				OPCODE_COLN: equ 5 
2465				OPCODE_SCOLN: equ 6 
2465				OPCODE_DROP: equ 7 
2465				OPCODE_DUP2: equ 8 
2465				OPCODE_DROP2: equ 9 
2465				OPCODE_SWAP2: equ 10 
2465				OPCODE_AT: equ 11 
2465				OPCODE_CAT: equ 12 
2465				OPCODE_BANG: equ 13 
2465				OPCODE_CBANG: equ 14 
2465				OPCODE_SCALL: equ 15 
2465				OPCODE_DEPTH: equ 16 
2465				OPCODE_OVER: equ 17 
2465				OPCODE_PAUSE: equ 18 
2465				OPCODE_PAUSES: equ 19 
2465				OPCODE_ROT: equ 20 
2465			;free to reuse	OPCODE_WORDS: equ 21 
2465			        OPCODE_NOT: equ 21 
2465				OPCODE_UWORDS: equ 22 
2465				OPCODE_BP: equ 23 
2465				OPCODE_MONITOR: equ 24  
2465				OPCODE_MALLOC: equ 25 
2465				OPCODE_FREE: equ 26 
2465				OPCODE_LIST: equ 27 
2465				OPCODE_FORGET: equ 28 
2465				OPCODE_NOP: equ 29 
2465				OPCODE_COMO: equ 30 
2465				OPCODE_COMC: equ 31 
2465			;free to reuse	OPCODE_ENDCORE: equ 32 
2465				OPCODE_AFTERSOUND: equ 33 
2465				OPCODE_GP2: equ 34 
2465				OPCODE_GP3: equ 35 
2465				OPCODE_GP4: equ 36 
2465				OPCODE_SIN: equ 37 
2465				OPCODE_SOUT: equ 38 
2465				OPCODE_SPIO: equ 39 
2465				OPCODE_SPICEH: equ 40 
2465				OPCODE_SPIOb: equ 41 
2465				OPCODE_SPII: equ 42 
2465				OPCODE_SESEL: equ 43 
2465				OPCODE_CARTDEV: equ 44 
2465			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2465				OPCODE_FB: equ 46 
2465				OPCODE_EMIT: equ 47 
2465				OPCODE_DOTH: equ 48 
2465				OPCODE_DOTF: equ 49 
2465				OPCODE_DOT: equ 50 
2465				OPCODE_CLS: equ 51 
2465				OPCODE_DRAW: equ 52 
2465				OPCODE_DUMP: equ 53 
2465				OPCODE_CDUMP: equ 54 
2465				OPCODE_DAT: equ 55 
2465				OPCODE_HOME: equ 56 
2465				OPCODE_SPACE: equ 57 
2465				OPCODE_SPACES: equ 58 
2465				OPCODE_SCROLL: equ 59 
2465				OPCODE_ATQ: equ 60 
2465				OPCODE_AUTODSP: equ 61 
2465				OPCODE_MENU: equ 62 
2465			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2465				OPCODE_THEN: equ 64 
2465				OPCODE_ELSE: equ 65 
2465				OPCODE_DO: equ 66 
2465				OPCODE_LOOP: equ 67 
2465				OPCODE_I: equ 68 
2465				OPCODE_DLOOP: equ 69  
2465				OPCODE_REPEAT: equ 70  
2465				OPCODE_UNTIL: equ 71 
2465				OPCODE_ENDFLOW: equ 72 
2465				OPCODE_WAITK: equ 73 
2465				OPCODE_ACCEPT: equ 74 
2465				OPCODE_EDIT: equ 75 
2465			;free to reuse	OPCODE_ENDKEY: equ 76 
2465				OPCODE_LZERO: equ 77 
2465				OPCODE_TZERO: equ 78 
2465				OPCODE_LESS: equ 79 
2465				OPCODE_GT: equ 80 
2465				OPCODE_EQUAL: equ 81  
2465			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2465				OPCODE_NEG: equ 83 
2465				OPCODE_DIV: equ 84 
2465				OPCODE_MUL: equ 85 
2465				OPCODE_MIN: equ 86 
2465				OPCODE_MAX: equ 87 
2465				OPCODE_RND16: equ 88 
2465				OPCODE_RND8: equ 89 
2465				OPCODE_RND: equ 90 
2465			;free to reuse	OPCODE_ENDMATHS: equ 91  
2465				OPCODE_BYNAME: equ 92 
2465				OPCODE_DIR: equ 93 
2465				OPCODE_SAVE: equ 94 
2465				OPCODE_LOAD: equ 95 
2465				OPCODE_BSAVE: equ 96 
2465				OPCODE_BLOAD: equ 97 
2465				OPCODE_SEO: equ 98  
2465				OPCODE_SEI: equ 99 
2465				OPCODE_SFREE: equ 100 
2465				OPCODE_SIZE: equ 101 
2465				OPCODE_CREATE: equ 102 
2465				OPCODE_APPEND: equ 103 
2465				OPCODE_SDEL: equ 104 
2465				OPCODE_OPEN: equ 105 
2465				OPCODE_READ: equ 106 
2465				OPCODE_EOF: equ 106 
2465				OPCODE_FORMAT: equ 107 
2465				OPCODE_LABEL: equ 108 
2465				OPCODE_LABELS: equ 109 
2465			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2465				OPCODE_UPPER: equ 111 
2465				OPCODE_LOWER: equ 112 
2465				OPCODE_SUBSTR: equ 113 
2465				OPCODE_LEFT: equ 114 
2465				OPCODE_RIGHT: equ 115 
2465				OPCODE_STR2NUM: equ 116 
2465				OPCODE_NUM2STR: equ 117 
2465				OPCODE_CONCAT: equ 118 
2465				OPCODE_FIND: equ 119 
2465				OPCODE_LEN: equ 120 
2465				OPCODE_CHAR: equ 121 
2465			; free to reuse	OPCODE_STRLEN: equ 122 
2465			; free to reuse	OPCODE_ENDSTR: equ 123 
2465				OPCODE_V0S: equ 124 
2465				OPCODE_V0Q: equ 125 
2465				OPCODE_V1S: equ 126 
2465				OPCODE_V1Q: equ 127 
2465				OPCODE_V2S: equ 128 
2465				OPCODE_V2Q: equ 129 
2465				OPCODE_V3S: equ 130 
2465				OPCODE_V3Q: equ 131 
2465			;free to reuse	OPCODE_END: equ 132 
2465				OPCODE_ZDUP: equ 133 
2465			 
2465			; eof 
# End of file forth_opcodes.asm
2465			 
2465			include "forth_words_core.asm" 
2465			 
2465			; | ## Core Words 
2465			 
2465			;if MALLOC_4 
2465			 
2465			.HEAP: 
2465				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2465 15				db WORD_SYS_CORE+OPCODE_HEAP             
2466 a4 24			dw .EXEC            
2468 05				db 4 + 1 
2469 .. 00			db "HEAP",0              
246e				endm 
# End of macro CWHEAD
246e			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
246e			; | | u1 - Current number of bytes in the heap 
246e			; | | u2 - Remaining bytes left on the heap 
246e			; | |  
246e			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
246e			 
246e			 
246e					if DEBUG_FORTH_WORDS_KEY 
246e						DMARK "HEP" 
246e f5				push af  
246f 3a 83 24			ld a, (.dmark)  
2472 32 6e fe			ld (debug_mark),a  
2475 3a 84 24			ld a, (.dmark+1)  
2478 32 6f fe			ld (debug_mark+1),a  
247b 3a 85 24			ld a, (.dmark+2)  
247e 32 70 fe			ld (debug_mark+2),a  
2481 18 03			jr .pastdmark  
2483 ..			.dmark: db "HEP"  
2486 f1			.pastdmark: pop af  
2487			endm  
# End of macro DMARK
2487						CALLMONITOR 
2487 cd f3 18			call break_point_state  
248a				endm  
# End of macro CALLMONITOR
248a					endif 
248a 2a 0a 80				ld hl, (free_list )      
248d 11 0e 80				ld de, heap_start 
2490			 
2490 ed 52				sbc hl, de  
2492			 
2492 cd 67 1f				call forth_push_numhl 
2495			 
2495			 
2495 ed 5b 0a 80			ld de, (free_list )      
2499 21 ae f1				ld hl, heap_end 
249c			 
249c ed 52				sbc hl, de 
249e			 
249e cd 67 1f				call forth_push_numhl 
24a1					 
24a1			 
24a1					 
24a1			 
24a1			 
24a1			 
24a1					NEXTW 
24a1 c3 0d 23			jp macro_next 
24a4				endm 
# End of macro NEXTW
24a4			;endif 
24a4			 
24a4			.EXEC: 
24a4			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
24a4			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
24a4			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
24a4			;; > > 
24a4			;; > >   
24a4			;	STACKFRAME OFF $5efe $5f9f 
24a4			; 
24a4			;		if DEBUG_FORTH_WORDS_KEY 
24a4			;			DMARK "EXE" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			; 
24a4			;	FORTH_DSP_VALUEHL 
24a4			; 
24a4			;	FORTH_DSP_POP 
24a4			; 
24a4			;		if DEBUG_FORTH_WORDS 
24a4			;			DMARK "EX1" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			;;	ld e,(hl) 
24a4			;;	inc hl 
24a4			;;	ld d,(hl) 
24a4			;;	ex de,hl 
24a4			; 
24a4			;;		if DEBUG_FORTH_WORDS 
24a4			;;			DMARK "EX2" 
24a4			;;			CALLMONITOR 
24a4			;;		endif 
24a4			;	push hl 
24a4			; 
24a4			;	;ld a, 0 
24a4			;	;ld a, FORTH_END_BUFFER 
24a4			;	call strlenz 
24a4			;	inc hl   ; include zero term to copy 
24a4			;	inc hl   ; include term 
24a4			;	inc hl   ; include term 
24a4			;	ld b,0 
24a4			;	ld c,l 
24a4			;	pop hl 
24a4			;	ld de, execscratch 
24a4			;		if DEBUG_FORTH_WORDS 
24a4			;			DMARK "EX3" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			;	ldir 
24a4			; 
24a4			; 
24a4			;	ld hl, execscratch 
24a4			; 
24a4			;		if DEBUG_FORTH_WORDS 
24a4			;			DMARK "EXe" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			; 
24a4			;	call forthparse 
24a4			;	call forthexec 
24a4			;;	call forthexec_cleanup 
24a4			;;	call forthparse 
24a4			;;	call forthexec 
24a4			; 
24a4			;	STACKFRAMECHK OFF $5efe $5f9f 
24a4			; 
24a4			;	; an immediate word so no need to process any more words 
24a4			;	ret 
24a4			;	NEXTW 
24a4			 
24a4			; dead code - old version  
24a4			;	FORTH_RSP_NEXT 
24a4			 
24a4			;  
24a4			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24a4			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24a4			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24a4			;	push hl 
24a4			;	push de 
24a4			;	push bc 
24a4			; 
24a4			; 
24a4			;		if DEBUG_FORTH_WORDS_KEY 
24a4			;			DMARK "EXR" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			; 
24a4			; 
24a4			; 
24a4			;	;v5 FORTH_DSP_VALUE 
24a4			;	FORTH_DSP_VALUEHL 
24a4			; 
24a4			;	; TODO do string type checks 
24a4			; 
24a4			;;v5	inc hl   ; skip type 
24a4			; 
24a4			;	push hl  ; source code  
24a4			;		if DEBUG_FORTH_WORDS 
24a4			;			DMARK "EX1" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			;	ld a, 0 
24a4			;	call strlent 
24a4			; 
24a4			;	inc hl 
24a4			;	inc hl 
24a4			;	inc hl 
24a4			;	inc hl 
24a4			; 
24a4			;	push hl    ; size 
24a4			; 
24a4			;		if DEBUG_FORTH_WORDS 
24a4			;			DMARK "EX2" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			;	call malloc 
24a4			; 
24a4			;	ex de, hl    ; de now contains malloc area 
24a4			;	pop bc   	; get byte count 
24a4			;	pop hl      ; get string to copy 
24a4			; 
24a4			;	push de     ; save malloc for free later 
24a4			; 
24a4			;		if DEBUG_FORTH_WORDS 
24a4			;			DMARK "EX3" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			;	ldir       ; duplicate string 
24a4			; 
24a4			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
24a4			;	 
24a4			;	; TODO fix the parse would be better than this...  
24a4			;	ex de, hl 
24a4			;	dec hl 
24a4			;	ld a, 0 
24a4			;	ld (hl), a 
24a4			;	dec hl 
24a4			;	ld a, ' ' 
24a4			;	ld (hl), a 
24a4			;	dec hl 
24a4			;	ld (hl), a 
24a4			; 
24a4			;	dec hl 
24a4			;	ld (hl), a 
24a4			; 
24a4			; 
24a4			;	FORTH_DSP_POP  
24a4			; 
24a4			;	pop hl     
24a4			;	push hl    ; save malloc area 
24a4			; 
24a4			;		if DEBUG_FORTH_WORDS 
24a4			;			DMARK "EX4" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			; 
24a4			;	call forthparse 
24a4			;	call forthexec 
24a4			;	 
24a4			;	pop hl 
24a4			;	if DEBUG_FORTH_WORDS 
24a4			;		DMARK "EX5" 
24a4			;		CALLMONITOR 
24a4			;	endif 
24a4			; 
24a4			;	if FORTH_ENABLE_FREE 
24a4			;	call free 
24a4			;	endif 
24a4			; 
24a4			;	if DEBUG_FORTH_WORDS 
24a4			;		DMARK "EX6" 
24a4			;		CALLMONITOR 
24a4			;	endif 
24a4			; 
24a4			;	pop bc 
24a4			;	pop de 
24a4			;	pop hl 
24a4			;;	FORTH_RSP_POP	  
24a4			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
24a4			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
24a4			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
24a4			; 
24a4			;	if DEBUG_FORTH_WORDS 
24a4			;		DMARK "EX7" 
24a4			;		CALLMONITOR 
24a4			;	endif 
24a4			;	NEXTW 
24a4			 
24a4			;.STKEXEC: 
24a4			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
24a4			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
24a4			; 
24a4			; 
24a4			;		if DEBUG_FORTH_WORDS_KEY 
24a4			;			DMARK "STX" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			; 
24a4			;	FORTH_DSP_VALUEHL 
24a4			; 
24a4			;	ld (store_tmp1), hl    ; count 
24a4			; 
24a4			;	FORTH_DSP_POP 
24a4			;.stkexec1: 
24a4			;	ld hl, (store_tmp1)   ; count 
24a4			;	ld a, 0 
24a4			;	cp l 
24a4			;	ret z 
24a4			; 
24a4			;	dec hl 
24a4			;	ld (store_tmp1), hl    ; count 
24a4			;	 
24a4			;	FORTH_DSP_VALUEHL 
24a4			;	push hl 
24a4			;	 
24a4			;		if DEBUG_FORTH_WORDS 
24a4			;			DMARK "EXp" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			;	FORTH_DSP_POP 
24a4			; 
24a4			;	call strlenz 
24a4			;	inc hl   ; include zero term to copy 
24a4			;	inc hl   ; include zero term to copy 
24a4			;	inc hl   ; include zero term to copy 
24a4			;	ld b,0 
24a4			;	ld c,l 
24a4			;	pop hl 
24a4			;	ld de, execscratch 
24a4			;		if DEBUG_FORTH_WORDS 
24a4			;			DMARK "EX3" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			;	ldir 
24a4			; 
24a4			; 
24a4			;	ld hl, execscratch 
24a4			; 
24a4			;		if DEBUG_FORTH_WORDS 
24a4			;			DMARK "EXP" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			; 
24a4			;	call forthparse 
24a4			;	ld hl, execscratch 
24a4			;		if DEBUG_FORTH_WORDS 
24a4			;			DMARK "EXx" 
24a4			;			CALLMONITOR 
24a4			;		endif 
24a4			;	call forthexec 
24a4			; 
24a4			;	jp .stkexec1 
24a4			; 
24a4			;	ret 
24a4			 
24a4			 
24a4			.DUP: 
24a4				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
24a4 17				db WORD_SYS_CORE+OPCODE_DUP             
24a5 1a 25			dw .ZDUP            
24a7 04				db 3 + 1 
24a8 .. 00			db "DUP",0              
24ac				endm 
# End of macro CWHEAD
24ac			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
24ac			 
24ac					if DEBUG_FORTH_WORDS_KEY 
24ac						DMARK "DUP" 
24ac f5				push af  
24ad 3a c1 24			ld a, (.dmark)  
24b0 32 6e fe			ld (debug_mark),a  
24b3 3a c2 24			ld a, (.dmark+1)  
24b6 32 6f fe			ld (debug_mark+1),a  
24b9 3a c3 24			ld a, (.dmark+2)  
24bc 32 70 fe			ld (debug_mark+2),a  
24bf 18 03			jr .pastdmark  
24c1 ..			.dmark: db "DUP"  
24c4 f1			.pastdmark: pop af  
24c5			endm  
# End of macro DMARK
24c5						CALLMONITOR 
24c5 cd f3 18			call break_point_state  
24c8				endm  
# End of macro CALLMONITOR
24c8					endif 
24c8			 
24c8					FORTH_DSP 
24c8 cd 24 21			call macro_forth_dsp 
24cb				endm 
# End of macro FORTH_DSP
24cb			 
24cb 7e					ld a, (HL) 
24cc fe 01				cp DS_TYPE_STR 
24ce 20 25				jr nz, .dupinum 
24d0			 
24d0					; push another string 
24d0			 
24d0					FORTH_DSP_VALUEHL     		 
24d0 cd 5e 21			call macro_dsp_valuehl 
24d3				endm 
# End of macro FORTH_DSP_VALUEHL
24d3			 
24d3				if DEBUG_FORTH_WORDS 
24d3					DMARK "DUs" 
24d3 f5				push af  
24d4 3a e8 24			ld a, (.dmark)  
24d7 32 6e fe			ld (debug_mark),a  
24da 3a e9 24			ld a, (.dmark+1)  
24dd 32 6f fe			ld (debug_mark+1),a  
24e0 3a ea 24			ld a, (.dmark+2)  
24e3 32 70 fe			ld (debug_mark+2),a  
24e6 18 03			jr .pastdmark  
24e8 ..			.dmark: db "DUs"  
24eb f1			.pastdmark: pop af  
24ec			endm  
# End of macro DMARK
24ec					CALLMONITOR 
24ec cd f3 18			call break_point_state  
24ef				endm  
# End of macro CALLMONITOR
24ef				endif 
24ef cd d5 1f				call forth_push_str 
24f2			 
24f2					NEXTW 
24f2 c3 0d 23			jp macro_next 
24f5				endm 
# End of macro NEXTW
24f5			 
24f5			 
24f5			.dupinum: 
24f5					 
24f5			 
24f5			 
24f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24f5 cd 5e 21			call macro_dsp_valuehl 
24f8				endm 
# End of macro FORTH_DSP_VALUEHL
24f8			 
24f8				; TODO add floating point number detection 
24f8			 
24f8				if DEBUG_FORTH_WORDS 
24f8					DMARK "DUi" 
24f8 f5				push af  
24f9 3a 0d 25			ld a, (.dmark)  
24fc 32 6e fe			ld (debug_mark),a  
24ff 3a 0e 25			ld a, (.dmark+1)  
2502 32 6f fe			ld (debug_mark+1),a  
2505 3a 0f 25			ld a, (.dmark+2)  
2508 32 70 fe			ld (debug_mark+2),a  
250b 18 03			jr .pastdmark  
250d ..			.dmark: db "DUi"  
2510 f1			.pastdmark: pop af  
2511			endm  
# End of macro DMARK
2511					CALLMONITOR 
2511 cd f3 18			call break_point_state  
2514				endm  
# End of macro CALLMONITOR
2514				endif 
2514			 
2514 cd 67 1f				call forth_push_numhl 
2517					NEXTW 
2517 c3 0d 23			jp macro_next 
251a				endm 
# End of macro NEXTW
251a			.ZDUP: 
251a				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
251a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
251b 52 25			dw .SWAP            
251d 05				db 4 + 1 
251e .. 00			db "?DUP",0              
2523				endm 
# End of macro CWHEAD
2523			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2523			 
2523					if DEBUG_FORTH_WORDS_KEY 
2523						DMARK "qDU" 
2523 f5				push af  
2524 3a 38 25			ld a, (.dmark)  
2527 32 6e fe			ld (debug_mark),a  
252a 3a 39 25			ld a, (.dmark+1)  
252d 32 6f fe			ld (debug_mark+1),a  
2530 3a 3a 25			ld a, (.dmark+2)  
2533 32 70 fe			ld (debug_mark+2),a  
2536 18 03			jr .pastdmark  
2538 ..			.dmark: db "qDU"  
253b f1			.pastdmark: pop af  
253c			endm  
# End of macro DMARK
253c						CALLMONITOR 
253c cd f3 18			call break_point_state  
253f				endm  
# End of macro CALLMONITOR
253f					endif 
253f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
253f cd 5e 21			call macro_dsp_valuehl 
2542				endm 
# End of macro FORTH_DSP_VALUEHL
2542			 
2542 e5					push hl 
2543			 
2543					; is it a zero? 
2543			 
2543 3e 00				ld a, 0 
2545 84					add h 
2546 85					add l 
2547			 
2547 e1					pop hl 
2548			 
2548 fe 00				cp 0 
254a 28 03				jr z, .dup2orig 
254c			 
254c			 
254c cd 67 1f				call forth_push_numhl 
254f			 
254f			 
254f				; TODO add floating point number detection 
254f			 
254f			.dup2orig: 
254f			 
254f					NEXTW 
254f c3 0d 23			jp macro_next 
2552				endm 
# End of macro NEXTW
2552			.SWAP: 
2552				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2552 18				db WORD_SYS_CORE+OPCODE_SWAP             
2553 91 25			dw .COLN            
2555 05				db 4 + 1 
2556 .. 00			db "SWAP",0              
255b				endm 
# End of macro CWHEAD
255b			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
255b					if DEBUG_FORTH_WORDS_KEY 
255b						DMARK "SWP" 
255b f5				push af  
255c 3a 70 25			ld a, (.dmark)  
255f 32 6e fe			ld (debug_mark),a  
2562 3a 71 25			ld a, (.dmark+1)  
2565 32 6f fe			ld (debug_mark+1),a  
2568 3a 72 25			ld a, (.dmark+2)  
256b 32 70 fe			ld (debug_mark+2),a  
256e 18 03			jr .pastdmark  
2570 ..			.dmark: db "SWP"  
2573 f1			.pastdmark: pop af  
2574			endm  
# End of macro DMARK
2574						CALLMONITOR 
2574 cd f3 18			call break_point_state  
2577				endm  
# End of macro CALLMONITOR
2577					endif 
2577			 
2577					FORTH_DSP_VALUEHL 
2577 cd 5e 21			call macro_dsp_valuehl 
257a				endm 
# End of macro FORTH_DSP_VALUEHL
257a e5					push hl     ; w2 
257b			 
257b					FORTH_DSP_POP 
257b cd 16 22			call macro_forth_dsp_pop 
257e				endm 
# End of macro FORTH_DSP_POP
257e			 
257e					FORTH_DSP_VALUEHL 
257e cd 5e 21			call macro_dsp_valuehl 
2581				endm 
# End of macro FORTH_DSP_VALUEHL
2581			 
2581					FORTH_DSP_POP 
2581 cd 16 22			call macro_forth_dsp_pop 
2584				endm 
# End of macro FORTH_DSP_POP
2584			 
2584 d1					pop de     ; w2	, hl = w1 
2585			 
2585 eb					ex de, hl 
2586 d5					push de 
2587			 
2587 cd 67 1f				call forth_push_numhl 
258a			 
258a e1					pop hl 
258b			 
258b cd 67 1f				call forth_push_numhl 
258e					 
258e			 
258e					NEXTW 
258e c3 0d 23			jp macro_next 
2591				endm 
# End of macro NEXTW
2591			.COLN: 
2591				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2591 19				db WORD_SYS_CORE+OPCODE_COLN             
2592 1d 27			dw .SCOLN            
2594 02				db 1 + 1 
2595 .. 00			db ":",0              
2597				endm 
# End of macro CWHEAD
2597			; | : ( -- )         Create new word | DONE 
2597			 
2597					if DEBUG_FORTH_WORDS_KEY 
2597						DMARK "CLN" 
2597 f5				push af  
2598 3a ac 25			ld a, (.dmark)  
259b 32 6e fe			ld (debug_mark),a  
259e 3a ad 25			ld a, (.dmark+1)  
25a1 32 6f fe			ld (debug_mark+1),a  
25a4 3a ae 25			ld a, (.dmark+2)  
25a7 32 70 fe			ld (debug_mark+2),a  
25aa 18 03			jr .pastdmark  
25ac ..			.dmark: db "CLN"  
25af f1			.pastdmark: pop af  
25b0			endm  
# End of macro DMARK
25b0						CALLMONITOR 
25b0 cd f3 18			call break_point_state  
25b3				endm  
# End of macro CALLMONITOR
25b3					endif 
25b3				STACKFRAME OFF $8efe $989f 
25b3				if DEBUG_STACK_IMB 
25b3					if OFF 
25b3						exx 
25b3						ld de, $8efe 
25b3						ld a, d 
25b3						ld hl, curframe 
25b3						call hexout 
25b3						ld a, e 
25b3						ld hl, curframe+2 
25b3						call hexout 
25b3						ld hl, $8efe 
25b3						push hl 
25b3						ld hl, $989f 
25b3						push hl 
25b3						exx 
25b3					endif 
25b3				endif 
25b3			endm 
# End of macro STACKFRAME
25b3				; get parser buffer length  of new word 
25b3			 
25b3				 
25b3			 
25b3					; move tok past this to start of name defintition 
25b3					; TODO get word to define 
25b3					; TODO Move past word token 
25b3					; TODO get length of string up to the ';' 
25b3			 
25b3 2a c9 f4			ld hl, (os_tok_ptr) 
25b6 23				inc hl 
25b7 23				inc hl 
25b8			 
25b8 3e 3b			ld a, ';' 
25ba cd b5 13			call strlent 
25bd			 
25bd 7d				ld a,l 
25be 32 c4 f1			ld (os_new_parse_len), a 
25c1			 
25c1			 
25c1			if DEBUG_FORTH_UWORD 
25c1 ed 5b c9 f4		ld de, (os_tok_ptr) 
25c5						DMARK ":01" 
25c5 f5				push af  
25c6 3a da 25			ld a, (.dmark)  
25c9 32 6e fe			ld (debug_mark),a  
25cc 3a db 25			ld a, (.dmark+1)  
25cf 32 6f fe			ld (debug_mark+1),a  
25d2 3a dc 25			ld a, (.dmark+2)  
25d5 32 70 fe			ld (debug_mark+2),a  
25d8 18 03			jr .pastdmark  
25da ..			.dmark: db ":01"  
25dd f1			.pastdmark: pop af  
25de			endm  
# End of macro DMARK
25de				CALLMONITOR 
25de cd f3 18			call break_point_state  
25e1				endm  
# End of macro CALLMONITOR
25e1			endif 
25e1			 
25e1			; 
25e1			;  new word memory layout: 
25e1			;  
25e1			;    : adg 6666 ;  
25e1			; 
25e1			;    db   1     ; user defined word  
25e1 23				inc hl    
25e2			;    dw   sysdict 
25e2 23				inc hl 
25e3 23				inc hl 
25e4			;    db <word len>+1 (for null) 
25e4 23				inc hl 
25e5			;    db .... <word> 
25e5			; 
25e5			 
25e5 23				inc hl    ; some extras for the word preamble before the above 
25e6 23				inc hl 
25e7 23				inc hl 
25e8 23				inc hl 
25e9 23				inc hl 
25ea 23				inc hl 
25eb 23				inc hl  
25ec 23				inc hl 
25ed 23				inc hl 
25ee 23				inc hl 
25ef 23				inc hl 
25f0 23				inc hl 
25f1 23				inc hl 
25f2 23				inc hl     ; TODO how many do we really need?     maybe only 6 
25f3			;       exec word buffer 
25f3			;	<ptr word>   
25f3 23				inc hl 
25f4 23				inc hl 
25f5			;       <word list><null term> 7F final term 
25f5			 
25f5			 
25f5			if DEBUG_FORTH_UWORD 
25f5						DMARK ":02" 
25f5 f5				push af  
25f6 3a 0a 26			ld a, (.dmark)  
25f9 32 6e fe			ld (debug_mark),a  
25fc 3a 0b 26			ld a, (.dmark+1)  
25ff 32 6f fe			ld (debug_mark+1),a  
2602 3a 0c 26			ld a, (.dmark+2)  
2605 32 70 fe			ld (debug_mark+2),a  
2608 18 03			jr .pastdmark  
260a ..			.dmark: db ":02"  
260d f1			.pastdmark: pop af  
260e			endm  
# End of macro DMARK
260e				CALLMONITOR 
260e cd f3 18			call break_point_state  
2611				endm  
# End of macro CALLMONITOR
2611			endif 
2611			 
2611				 
2611					; malloc the size 
2611			 
2611 cd 13 14				call malloc 
2614 22 c6 f1				ld (os_new_malloc), hl     ; save malloc start 
2617			 
2617			;    db   1     ; user defined word  
2617 3e 01				ld a, WORD_SYS_UWORD  
2619 77					ld (hl), a 
261a				 
261a 23				inc hl    
261b			;    dw   sysdict 
261b 11 65 24			ld de, sysdict       ; continue on with the scan to the system dict 
261e 73				ld (hl), e 
261f 23				inc hl 
2620 72				ld (hl), d 
2621 23				inc hl 
2622			 
2622			 
2622			;    Setup dict word 
2622			 
2622 23				inc hl 
2623 22 c0 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
2626			 
2626				; 1. get length of dict word 
2626			 
2626			 
2626 2a c9 f4			ld hl, (os_tok_ptr) 
2629 23				inc hl 
262a 23				inc hl    ; position to start of dict word 
262b 3e 00			ld a, 0 
262d cd b5 13			call strlent 
2630			 
2630			 
2630 23				inc hl    ; to include null??? 
2631			 
2631				; write length of dict word 
2631			 
2631 ed 5b c0 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2635 1b				dec de 
2636 eb				ex de, hl 
2637 73				ld (hl), e 
2638 eb				ex de, hl 
2639			 
2639				 
2639			 
2639				; copy  
2639 4d				ld c, l 
263a 06 00			ld b, 0 
263c ed 5b c0 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2640 2a c9 f4			ld hl, (os_tok_ptr) 
2643 23				inc hl 
2644 23				inc hl    ; position to start of dict word 
2645				 
2645			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2645				 
2645				; TODO need to convert word to upper case 
2645			 
2645			ucasetok:	 
2645 7e				ld a,(hl) 
2646 cd a1 13			call toUpper 
2649 77				ld (hl),a 
264a ed a0			ldi 
264c f2 45 26		 	jp p, ucasetok 
264f			 
264f			 
264f			 
264f				; de now points to start of where the word body code should be placed 
264f ed 53 c0 f1		ld (os_new_work_ptr), de 
2653				; hl now points to the words to throw at forthexec which needs to be copied 
2653 22 be f1			ld (os_new_src_ptr), hl 
2656			 
2656				; TODO add 'call to forthexec' 
2656			 
2656			if DEBUG_FORTH_UWORD 
2656 c5				push bc 
2657 ed 4b c6 f1		ld bc, (os_new_malloc) 
265b						DMARK ":0x" 
265b f5				push af  
265c 3a 70 26			ld a, (.dmark)  
265f 32 6e fe			ld (debug_mark),a  
2662 3a 71 26			ld a, (.dmark+1)  
2665 32 6f fe			ld (debug_mark+1),a  
2668 3a 72 26			ld a, (.dmark+2)  
266b 32 70 fe			ld (debug_mark+2),a  
266e 18 03			jr .pastdmark  
2670 ..			.dmark: db ":0x"  
2673 f1			.pastdmark: pop af  
2674			endm  
# End of macro DMARK
2674				CALLMONITOR 
2674 cd f3 18			call break_point_state  
2677				endm  
# End of macro CALLMONITOR
2677 c1				pop bc 
2678			endif 
2678			 
2678			 
2678				; create word preamble which should be: 
2678			 
2678			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2678			 
2678				;    ld hl, <word code> 
2678				;    jp user_exec 
2678			        ;    <word code bytes> 
2678			 
2678			 
2678			;	inc de     ; TODO ??? or are we already past the word's null 
2678 eb				ex de, hl 
2679			 
2679 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
267b			 
267b 23				inc hl 
267c 22 ba f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
267f 23				inc hl 
2680			 
2680 23				inc hl 
2681 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2683			 
2683 01 43 58			ld bc, user_exec 
2686 23				inc hl 
2687 71				ld (hl), c     ; poke address of user_exec 
2688 23				inc hl 
2689 70				ld (hl), b     
268a			 ; 
268a			;	inc hl 
268a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
268a			; 
268a			; 
268a			;	ld bc, macro_forth_rsp_next 
268a			;	inc hl 
268a			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
268a			;	inc hl 
268a			;	ld (hl), b     
268a			 ; 
268a			;	inc hl 
268a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
268a			; 
268a			; 
268a			;	inc hl 
268a			;	ld bc, forthexec 
268a			;	ld (hl), c     ; poke address of forthexec 
268a			;	inc hl 
268a			;	ld (hl), b      
268a			; 
268a			;	inc hl 
268a			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
268a			; 
268a			;	ld bc, user_dict_next 
268a			;	inc hl 
268a			;	ld (hl), c     ; poke address of forthexec 
268a			;	inc hl 
268a			;	ld (hl), b      
268a			 
268a				; hl is now where we need to copy the word byte data to save this 
268a			 
268a 23				inc hl 
268b 22 bc f1			ld (os_new_exec), hl 
268e				 
268e				; copy definition 
268e			 
268e eb				ex de, hl 
268f			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
268f			;	inc de    ; skip the PC for this parse 
268f 3a c4 f1			ld a, (os_new_parse_len) 
2692 4f				ld c, a 
2693 06 00			ld b, 0 
2695 ed b0			ldir		 ; copy defintion 
2697			 
2697			 
2697				; poke the address of where the new word bytes live for forthexec 
2697			 
2697 2a ba f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
269a			 
269a ed 5b bc f1		ld de, (os_new_exec)      
269e				 
269e 73				ld (hl), e 
269f 23				inc hl 
26a0 72				ld (hl), d 
26a1			 
26a1					; TODO copy last user dict word next link to this word 
26a1					; TODO update last user dict word to point to this word 
26a1			; 
26a1			; hl f923 de 812a ; bc 811a 
26a1			 
26a1			if DEBUG_FORTH_UWORD 
26a1 c5				push bc 
26a2 ed 4b c6 f1		ld bc, (os_new_malloc) 
26a6						DMARK ":0A" 
26a6 f5				push af  
26a7 3a bb 26			ld a, (.dmark)  
26aa 32 6e fe			ld (debug_mark),a  
26ad 3a bc 26			ld a, (.dmark+1)  
26b0 32 6f fe			ld (debug_mark+1),a  
26b3 3a bd 26			ld a, (.dmark+2)  
26b6 32 70 fe			ld (debug_mark+2),a  
26b9 18 03			jr .pastdmark  
26bb ..			.dmark: db ":0A"  
26be f1			.pastdmark: pop af  
26bf			endm  
# End of macro DMARK
26bf				CALLMONITOR 
26bf cd f3 18			call break_point_state  
26c2				endm  
# End of macro CALLMONITOR
26c2 c1				pop bc 
26c3			endif 
26c3			if DEBUG_FORTH_UWORD 
26c3 c5				push bc 
26c4 ed 4b c6 f1		ld bc, (os_new_malloc) 
26c8 03				inc bc 
26c9 03				inc bc 
26ca 03				inc bc 
26cb 03				inc bc 
26cc 03				inc bc 
26cd 03				inc bc 
26ce 03				inc bc 
26cf 03				inc bc 
26d0			 
26d0						DMARK ":0B" 
26d0 f5				push af  
26d1 3a e5 26			ld a, (.dmark)  
26d4 32 6e fe			ld (debug_mark),a  
26d7 3a e6 26			ld a, (.dmark+1)  
26da 32 6f fe			ld (debug_mark+1),a  
26dd 3a e7 26			ld a, (.dmark+2)  
26e0 32 70 fe			ld (debug_mark+2),a  
26e3 18 03			jr .pastdmark  
26e5 ..			.dmark: db ":0B"  
26e8 f1			.pastdmark: pop af  
26e9			endm  
# End of macro DMARK
26e9				CALLMONITOR 
26e9 cd f3 18			call break_point_state  
26ec				endm  
# End of macro CALLMONITOR
26ec c1				pop bc 
26ed			endif 
26ed			 
26ed			; update word dict linked list for new word 
26ed			 
26ed			 
26ed 2a c5 f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
26f0 23			inc hl     ; move to next work linked list ptr 
26f1			 
26f1 ed 5b c6 f1	ld de, (os_new_malloc)		 ; new next word 
26f5 73			ld (hl), e 
26f6 23			inc hl 
26f7 72			ld (hl), d 
26f8			 
26f8			if DEBUG_FORTH_UWORD 
26f8 ed 4b c5 f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
26fc			endif 
26fc			 
26fc ed 53 c5 f4	ld (os_last_new_uword), de      ; update last new uword ptr 
2700			 
2700			 
2700			if DEBUG_FORTH_UWORD 
2700						DMARK ":0+" 
2700 f5				push af  
2701 3a 15 27			ld a, (.dmark)  
2704 32 6e fe			ld (debug_mark),a  
2707 3a 16 27			ld a, (.dmark+1)  
270a 32 6f fe			ld (debug_mark+1),a  
270d 3a 17 27			ld a, (.dmark+2)  
2710 32 70 fe			ld (debug_mark+2),a  
2713 18 03			jr .pastdmark  
2715 ..			.dmark: db ":0+"  
2718 f1			.pastdmark: pop af  
2719			endm  
# End of macro DMARK
2719				CALLMONITOR 
2719 cd f3 18			call break_point_state  
271c				endm  
# End of macro CALLMONITOR
271c			endif 
271c			 
271c				STACKFRAMECHK OFF $8efe $989f 
271c				if DEBUG_STACK_IMB 
271c					if OFF 
271c						exx 
271c						ld hl, $989f 
271c						pop de   ; $989f 
271c						call cmp16 
271c						jr nz, .spnosame 
271c						ld hl, $8efe 
271c						pop de   ; $8efe 
271c						call cmp16 
271c						jr z, .spfrsame 
271c						.spnosame: call showsperror 
271c						.spfrsame: nop 
271c						exx 
271c					endif 
271c				endif 
271c			endm 
# End of macro STACKFRAMECHK
271c			 
271c c9			ret    ; dont process any remaining parser tokens as they form new word 
271d			 
271d			 
271d			 
271d			 
271d			;		NEXT 
271d			.SCOLN: 
271d			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
271d 06				db OPCODE_SCOLN 
271e 69 27			dw .DROP 
2720 02				db 2 
2721 .. 00			db ";",0           
2723			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2723					if DEBUG_FORTH_WORDS_KEY 
2723						DMARK "SCN" 
2723 f5				push af  
2724 3a 38 27			ld a, (.dmark)  
2727 32 6e fe			ld (debug_mark),a  
272a 3a 39 27			ld a, (.dmark+1)  
272d 32 6f fe			ld (debug_mark+1),a  
2730 3a 3a 27			ld a, (.dmark+2)  
2733 32 70 fe			ld (debug_mark+2),a  
2736 18 03			jr .pastdmark  
2738 ..			.dmark: db "SCN"  
273b f1			.pastdmark: pop af  
273c			endm  
# End of macro DMARK
273c						CALLMONITOR 
273c cd f3 18			call break_point_state  
273f				endm  
# End of macro CALLMONITOR
273f					endif 
273f					FORTH_RSP_TOS 
273f cd 25 1f			call macro_forth_rsp_tos 
2742				endm 
# End of macro FORTH_RSP_TOS
2742 e5					push hl 
2743					FORTH_RSP_POP 
2743 cd 2f 1f			call macro_forth_rsp_pop 
2746				endm 
# End of macro FORTH_RSP_POP
2746 e1					pop hl 
2747			;		ex de,hl 
2747 22 c9 f4				ld (os_tok_ptr),hl 
274a			 
274a			if DEBUG_FORTH_UWORD 
274a						DMARK "SCL" 
274a f5				push af  
274b 3a 5f 27			ld a, (.dmark)  
274e 32 6e fe			ld (debug_mark),a  
2751 3a 60 27			ld a, (.dmark+1)  
2754 32 6f fe			ld (debug_mark+1),a  
2757 3a 61 27			ld a, (.dmark+2)  
275a 32 70 fe			ld (debug_mark+2),a  
275d 18 03			jr .pastdmark  
275f ..			.dmark: db "SCL"  
2762 f1			.pastdmark: pop af  
2763			endm  
# End of macro DMARK
2763				CALLMONITOR 
2763 cd f3 18			call break_point_state  
2766				endm  
# End of macro CALLMONITOR
2766			endif 
2766					NEXTW 
2766 c3 0d 23			jp macro_next 
2769				endm 
# End of macro NEXTW
2769			 
2769			.DROP: 
2769				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2769 1b				db WORD_SYS_CORE+OPCODE_DROP             
276a 94 27			dw .DUP2            
276c 05				db 4 + 1 
276d .. 00			db "DROP",0              
2772				endm 
# End of macro CWHEAD
2772			; | DROP ( w -- )   drop the TOS item   | DONE 
2772					if DEBUG_FORTH_WORDS_KEY 
2772						DMARK "DRP" 
2772 f5				push af  
2773 3a 87 27			ld a, (.dmark)  
2776 32 6e fe			ld (debug_mark),a  
2779 3a 88 27			ld a, (.dmark+1)  
277c 32 6f fe			ld (debug_mark+1),a  
277f 3a 89 27			ld a, (.dmark+2)  
2782 32 70 fe			ld (debug_mark+2),a  
2785 18 03			jr .pastdmark  
2787 ..			.dmark: db "DRP"  
278a f1			.pastdmark: pop af  
278b			endm  
# End of macro DMARK
278b						CALLMONITOR 
278b cd f3 18			call break_point_state  
278e				endm  
# End of macro CALLMONITOR
278e					endif 
278e					FORTH_DSP_POP 
278e cd 16 22			call macro_forth_dsp_pop 
2791				endm 
# End of macro FORTH_DSP_POP
2791					NEXTW 
2791 c3 0d 23			jp macro_next 
2794				endm 
# End of macro NEXTW
2794			.DUP2: 
2794				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2794 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2795 d9 27			dw .DROP2            
2797 05				db 4 + 1 
2798 .. 00			db "2DUP",0              
279d				endm 
# End of macro CWHEAD
279d			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
279d					if DEBUG_FORTH_WORDS_KEY 
279d						DMARK "2DU" 
279d f5				push af  
279e 3a b2 27			ld a, (.dmark)  
27a1 32 6e fe			ld (debug_mark),a  
27a4 3a b3 27			ld a, (.dmark+1)  
27a7 32 6f fe			ld (debug_mark+1),a  
27aa 3a b4 27			ld a, (.dmark+2)  
27ad 32 70 fe			ld (debug_mark+2),a  
27b0 18 03			jr .pastdmark  
27b2 ..			.dmark: db "2DU"  
27b5 f1			.pastdmark: pop af  
27b6			endm  
# End of macro DMARK
27b6						CALLMONITOR 
27b6 cd f3 18			call break_point_state  
27b9				endm  
# End of macro CALLMONITOR
27b9					endif 
27b9					FORTH_DSP_VALUEHL 
27b9 cd 5e 21			call macro_dsp_valuehl 
27bc				endm 
# End of macro FORTH_DSP_VALUEHL
27bc e5					push hl      ; 2 
27bd			 
27bd					FORTH_DSP_POP 
27bd cd 16 22			call macro_forth_dsp_pop 
27c0				endm 
# End of macro FORTH_DSP_POP
27c0					 
27c0					FORTH_DSP_VALUEHL 
27c0 cd 5e 21			call macro_dsp_valuehl 
27c3				endm 
# End of macro FORTH_DSP_VALUEHL
27c3			;		push hl      ; 1 
27c3			 
27c3					FORTH_DSP_POP 
27c3 cd 16 22			call macro_forth_dsp_pop 
27c6				endm 
# End of macro FORTH_DSP_POP
27c6			 
27c6			;		pop hl       ; 1 
27c6 d1					pop de       ; 2 
27c7			 
27c7 cd 67 1f				call forth_push_numhl 
27ca eb					ex de, hl 
27cb cd 67 1f				call forth_push_numhl 
27ce			 
27ce					 
27ce eb					ex de, hl 
27cf			 
27cf cd 67 1f				call forth_push_numhl 
27d2 eb					ex de, hl 
27d3 cd 67 1f				call forth_push_numhl 
27d6			 
27d6			 
27d6					NEXTW 
27d6 c3 0d 23			jp macro_next 
27d9				endm 
# End of macro NEXTW
27d9			.DROP2: 
27d9				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
27d9 1d				db WORD_SYS_CORE+OPCODE_DROP2             
27da 08 28			dw .SWAP2            
27dc 06				db 5 + 1 
27dd .. 00			db "2DROP",0              
27e3				endm 
# End of macro CWHEAD
27e3			; | 2DROP ( w w -- )    Double drop | DONE 
27e3					if DEBUG_FORTH_WORDS_KEY 
27e3						DMARK "2DR" 
27e3 f5				push af  
27e4 3a f8 27			ld a, (.dmark)  
27e7 32 6e fe			ld (debug_mark),a  
27ea 3a f9 27			ld a, (.dmark+1)  
27ed 32 6f fe			ld (debug_mark+1),a  
27f0 3a fa 27			ld a, (.dmark+2)  
27f3 32 70 fe			ld (debug_mark+2),a  
27f6 18 03			jr .pastdmark  
27f8 ..			.dmark: db "2DR"  
27fb f1			.pastdmark: pop af  
27fc			endm  
# End of macro DMARK
27fc						CALLMONITOR 
27fc cd f3 18			call break_point_state  
27ff				endm  
# End of macro CALLMONITOR
27ff					endif 
27ff					FORTH_DSP_POP 
27ff cd 16 22			call macro_forth_dsp_pop 
2802				endm 
# End of macro FORTH_DSP_POP
2802					FORTH_DSP_POP 
2802 cd 16 22			call macro_forth_dsp_pop 
2805				endm 
# End of macro FORTH_DSP_POP
2805					NEXTW 
2805 c3 0d 23			jp macro_next 
2808				endm 
# End of macro NEXTW
2808			.SWAP2: 
2808				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2808 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2809 31 28			dw .AT            
280b 06				db 5 + 1 
280c .. 00			db "2SWAP",0              
2812				endm 
# End of macro CWHEAD
2812			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2812					if DEBUG_FORTH_WORDS_KEY 
2812						DMARK "2SW" 
2812 f5				push af  
2813 3a 27 28			ld a, (.dmark)  
2816 32 6e fe			ld (debug_mark),a  
2819 3a 28 28			ld a, (.dmark+1)  
281c 32 6f fe			ld (debug_mark+1),a  
281f 3a 29 28			ld a, (.dmark+2)  
2822 32 70 fe			ld (debug_mark+2),a  
2825 18 03			jr .pastdmark  
2827 ..			.dmark: db "2SW"  
282a f1			.pastdmark: pop af  
282b			endm  
# End of macro DMARK
282b						CALLMONITOR 
282b cd f3 18			call break_point_state  
282e				endm  
# End of macro CALLMONITOR
282e					endif 
282e					NEXTW 
282e c3 0d 23			jp macro_next 
2831				endm 
# End of macro NEXTW
2831			.AT: 
2831				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2831 1f				db WORD_SYS_CORE+OPCODE_AT             
2832 63 28			dw .CAT            
2834 02				db 1 + 1 
2835 .. 00			db "@",0              
2837				endm 
# End of macro CWHEAD
2837			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2837			 
2837					if DEBUG_FORTH_WORDS_KEY 
2837						DMARK "AT." 
2837 f5				push af  
2838 3a 4c 28			ld a, (.dmark)  
283b 32 6e fe			ld (debug_mark),a  
283e 3a 4d 28			ld a, (.dmark+1)  
2841 32 6f fe			ld (debug_mark+1),a  
2844 3a 4e 28			ld a, (.dmark+2)  
2847 32 70 fe			ld (debug_mark+2),a  
284a 18 03			jr .pastdmark  
284c ..			.dmark: db "AT."  
284f f1			.pastdmark: pop af  
2850			endm  
# End of macro DMARK
2850						CALLMONITOR 
2850 cd f3 18			call break_point_state  
2853				endm  
# End of macro CALLMONITOR
2853					endif 
2853			.getbyteat:	 
2853					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2853 cd 5e 21			call macro_dsp_valuehl 
2856				endm 
# End of macro FORTH_DSP_VALUEHL
2856					 
2856			;		push hl 
2856				 
2856					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2856 cd 16 22			call macro_forth_dsp_pop 
2859				endm 
# End of macro FORTH_DSP_POP
2859			 
2859			;		pop hl 
2859			 
2859 7e					ld a, (hl) 
285a			 
285a 6f					ld l, a 
285b 26 00				ld h, 0 
285d cd 67 1f				call forth_push_numhl 
2860			 
2860					NEXTW 
2860 c3 0d 23			jp macro_next 
2863				endm 
# End of macro NEXTW
2863			.CAT: 
2863				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2863 20				db WORD_SYS_CORE+OPCODE_CAT             
2864 8c 28			dw .BANG            
2866 03				db 2 + 1 
2867 .. 00			db "C@",0              
286a				endm 
# End of macro CWHEAD
286a			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
286a					if DEBUG_FORTH_WORDS_KEY 
286a						DMARK "CAA" 
286a f5				push af  
286b 3a 7f 28			ld a, (.dmark)  
286e 32 6e fe			ld (debug_mark),a  
2871 3a 80 28			ld a, (.dmark+1)  
2874 32 6f fe			ld (debug_mark+1),a  
2877 3a 81 28			ld a, (.dmark+2)  
287a 32 70 fe			ld (debug_mark+2),a  
287d 18 03			jr .pastdmark  
287f ..			.dmark: db "CAA"  
2882 f1			.pastdmark: pop af  
2883			endm  
# End of macro DMARK
2883						CALLMONITOR 
2883 cd f3 18			call break_point_state  
2886				endm  
# End of macro CALLMONITOR
2886					endif 
2886 c3 53 28				jp .getbyteat 
2889					NEXTW 
2889 c3 0d 23			jp macro_next 
288c				endm 
# End of macro NEXTW
288c			.BANG: 
288c				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
288c 21				db WORD_SYS_CORE+OPCODE_BANG             
288d c2 28			dw .CBANG            
288f 02				db 1 + 1 
2890 .. 00			db "!",0              
2892				endm 
# End of macro CWHEAD
2892			; | ! ( x w -- ) Store x at address w      | DONE 
2892					if DEBUG_FORTH_WORDS_KEY 
2892						DMARK "BNG" 
2892 f5				push af  
2893 3a a7 28			ld a, (.dmark)  
2896 32 6e fe			ld (debug_mark),a  
2899 3a a8 28			ld a, (.dmark+1)  
289c 32 6f fe			ld (debug_mark+1),a  
289f 3a a9 28			ld a, (.dmark+2)  
28a2 32 70 fe			ld (debug_mark+2),a  
28a5 18 03			jr .pastdmark  
28a7 ..			.dmark: db "BNG"  
28aa f1			.pastdmark: pop af  
28ab			endm  
# End of macro DMARK
28ab						CALLMONITOR 
28ab cd f3 18			call break_point_state  
28ae				endm  
# End of macro CALLMONITOR
28ae					endif 
28ae			 
28ae			.storebyteat:		 
28ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28ae cd 5e 21			call macro_dsp_valuehl 
28b1				endm 
# End of macro FORTH_DSP_VALUEHL
28b1					 
28b1 e5					push hl 
28b2				 
28b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28b2 cd 16 22			call macro_forth_dsp_pop 
28b5				endm 
# End of macro FORTH_DSP_POP
28b5			 
28b5					; get byte to poke 
28b5			 
28b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28b5 cd 5e 21			call macro_dsp_valuehl 
28b8				endm 
# End of macro FORTH_DSP_VALUEHL
28b8 e5					push hl 
28b9			 
28b9			 
28b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28b9 cd 16 22			call macro_forth_dsp_pop 
28bc				endm 
# End of macro FORTH_DSP_POP
28bc			 
28bc			 
28bc d1					pop de 
28bd e1					pop hl 
28be			 
28be 73					ld (hl),e 
28bf			 
28bf			 
28bf					NEXTW 
28bf c3 0d 23			jp macro_next 
28c2				endm 
# End of macro NEXTW
28c2			.CBANG: 
28c2				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
28c2 22				db WORD_SYS_CORE+OPCODE_CBANG             
28c3 eb 28			dw .SCALL            
28c5 03				db 2 + 1 
28c6 .. 00			db "C!",0              
28c9				endm 
# End of macro CWHEAD
28c9			; | C!  ( x w -- ) Store x at address w  | DONE 
28c9					if DEBUG_FORTH_WORDS_KEY 
28c9						DMARK "CBA" 
28c9 f5				push af  
28ca 3a de 28			ld a, (.dmark)  
28cd 32 6e fe			ld (debug_mark),a  
28d0 3a df 28			ld a, (.dmark+1)  
28d3 32 6f fe			ld (debug_mark+1),a  
28d6 3a e0 28			ld a, (.dmark+2)  
28d9 32 70 fe			ld (debug_mark+2),a  
28dc 18 03			jr .pastdmark  
28de ..			.dmark: db "CBA"  
28e1 f1			.pastdmark: pop af  
28e2			endm  
# End of macro DMARK
28e2						CALLMONITOR 
28e2 cd f3 18			call break_point_state  
28e5				endm  
# End of macro CALLMONITOR
28e5					endif 
28e5 c3 ae 28				jp .storebyteat 
28e8					NEXTW 
28e8 c3 0d 23			jp macro_next 
28eb				endm 
# End of macro NEXTW
28eb			.SCALL: 
28eb				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
28eb 23				db WORD_SYS_CORE+OPCODE_SCALL             
28ec 1f 29			dw .DEPTH            
28ee 05				db 4 + 1 
28ef .. 00			db "CALL",0              
28f4				endm 
# End of macro CWHEAD
28f4			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
28f4					if DEBUG_FORTH_WORDS_KEY 
28f4						DMARK "CLL" 
28f4 f5				push af  
28f5 3a 09 29			ld a, (.dmark)  
28f8 32 6e fe			ld (debug_mark),a  
28fb 3a 0a 29			ld a, (.dmark+1)  
28fe 32 6f fe			ld (debug_mark+1),a  
2901 3a 0b 29			ld a, (.dmark+2)  
2904 32 70 fe			ld (debug_mark+2),a  
2907 18 03			jr .pastdmark  
2909 ..			.dmark: db "CLL"  
290c f1			.pastdmark: pop af  
290d			endm  
# End of macro DMARK
290d						CALLMONITOR 
290d cd f3 18			call break_point_state  
2910				endm  
# End of macro CALLMONITOR
2910					endif 
2910			 
2910					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2910 cd 5e 21			call macro_dsp_valuehl 
2913				endm 
# End of macro FORTH_DSP_VALUEHL
2913			 
2913			;		push hl 
2913			 
2913					; destroy value TOS 
2913			 
2913					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2913 cd 16 22			call macro_forth_dsp_pop 
2916				endm 
# End of macro FORTH_DSP_POP
2916			 
2916						 
2916			;		pop hl 
2916			 
2916					; how to do a call with hl???? save SP? 
2916 cd b1 22				call forth_call_hl 
2919			 
2919			 
2919					; TODO push value back onto stack for another op etc 
2919			 
2919 cd 67 1f				call forth_push_numhl 
291c					NEXTW 
291c c3 0d 23			jp macro_next 
291f				endm 
# End of macro NEXTW
291f			.DEPTH: 
291f				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
291f 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2920 5c 29			dw .OVER            
2922 06				db 5 + 1 
2923 .. 00			db "DEPTH",0              
2929				endm 
# End of macro CWHEAD
2929			; | DEPTH ( -- u ) Push count of stack | DONE 
2929					; take current TOS and remove from base value div by two to get count 
2929					if DEBUG_FORTH_WORDS_KEY 
2929						DMARK "DEP" 
2929 f5				push af  
292a 3a 3e 29			ld a, (.dmark)  
292d 32 6e fe			ld (debug_mark),a  
2930 3a 3f 29			ld a, (.dmark+1)  
2933 32 6f fe			ld (debug_mark+1),a  
2936 3a 40 29			ld a, (.dmark+2)  
2939 32 70 fe			ld (debug_mark+2),a  
293c 18 03			jr .pastdmark  
293e ..			.dmark: db "DEP"  
2941 f1			.pastdmark: pop af  
2942			endm  
# End of macro DMARK
2942						CALLMONITOR 
2942 cd f3 18			call break_point_state  
2945				endm  
# End of macro CALLMONITOR
2945					endif 
2945			 
2945			 
2945 2a f5 f9			ld hl, (cli_data_sp) 
2948 11 2f f7			ld de, cli_data_stack 
294b ed 52			sbc hl,de 
294d				 
294d				; div by size of stack item 
294d			 
294d 5d				ld e,l 
294e 0e 03			ld c, 3 
2950 cd dc 0e			call Div8 
2953			 
2953 6f				ld l,a 
2954 26 00			ld h,0 
2956			 
2956				;srl h 
2956				;rr l 
2956			 
2956 cd 67 1f				call forth_push_numhl 
2959					NEXTW 
2959 c3 0d 23			jp macro_next 
295c				endm 
# End of macro NEXTW
295c			.OVER: 
295c				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
295c 42				db WORD_SYS_CORE+46             
295d a3 29			dw .PAUSE            
295f 05				db 4 + 1 
2960 .. 00			db "OVER",0              
2965				endm 
# End of macro CWHEAD
2965			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2965					if DEBUG_FORTH_WORDS_KEY 
2965						DMARK "OVR" 
2965 f5				push af  
2966 3a 7a 29			ld a, (.dmark)  
2969 32 6e fe			ld (debug_mark),a  
296c 3a 7b 29			ld a, (.dmark+1)  
296f 32 6f fe			ld (debug_mark+1),a  
2972 3a 7c 29			ld a, (.dmark+2)  
2975 32 70 fe			ld (debug_mark+2),a  
2978 18 03			jr .pastdmark  
297a ..			.dmark: db "OVR"  
297d f1			.pastdmark: pop af  
297e			endm  
# End of macro DMARK
297e						CALLMONITOR 
297e cd f3 18			call break_point_state  
2981				endm  
# End of macro CALLMONITOR
2981					endif 
2981			 
2981					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2981 cd 5e 21			call macro_dsp_valuehl 
2984				endm 
# End of macro FORTH_DSP_VALUEHL
2984 e5					push hl    ; n2 
2985					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2985 cd 16 22			call macro_forth_dsp_pop 
2988				endm 
# End of macro FORTH_DSP_POP
2988			 
2988					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2988 cd 5e 21			call macro_dsp_valuehl 
298b				endm 
# End of macro FORTH_DSP_VALUEHL
298b e5					push hl    ; n1 
298c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
298c cd 16 22			call macro_forth_dsp_pop 
298f				endm 
# End of macro FORTH_DSP_POP
298f			 
298f d1					pop de     ; n1 
2990 e1					pop hl     ; n2 
2991			 
2991 d5					push de 
2992 e5					push hl 
2993 d5					push de 
2994			 
2994					; push back  
2994			 
2994 e1					pop hl 
2995 cd 67 1f				call forth_push_numhl 
2998 e1					pop hl 
2999 cd 67 1f				call forth_push_numhl 
299c e1					pop hl 
299d cd 67 1f				call forth_push_numhl 
29a0					NEXTW 
29a0 c3 0d 23			jp macro_next 
29a3				endm 
# End of macro NEXTW
29a3			 
29a3			.PAUSE: 
29a3				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
29a3 43				db WORD_SYS_CORE+47             
29a4 d8 29			dw .PAUSES            
29a6 08				db 7 + 1 
29a7 .. 00			db "PAUSEMS",0              
29af				endm 
# End of macro CWHEAD
29af			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
29af					if DEBUG_FORTH_WORDS_KEY 
29af						DMARK "PMS" 
29af f5				push af  
29b0 3a c4 29			ld a, (.dmark)  
29b3 32 6e fe			ld (debug_mark),a  
29b6 3a c5 29			ld a, (.dmark+1)  
29b9 32 6f fe			ld (debug_mark+1),a  
29bc 3a c6 29			ld a, (.dmark+2)  
29bf 32 70 fe			ld (debug_mark+2),a  
29c2 18 03			jr .pastdmark  
29c4 ..			.dmark: db "PMS"  
29c7 f1			.pastdmark: pop af  
29c8			endm  
# End of macro DMARK
29c8						CALLMONITOR 
29c8 cd f3 18			call break_point_state  
29cb				endm  
# End of macro CALLMONITOR
29cb					endif 
29cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29cb cd 5e 21			call macro_dsp_valuehl 
29ce				endm 
# End of macro FORTH_DSP_VALUEHL
29ce			;		push hl    ; n2 
29ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29ce cd 16 22			call macro_forth_dsp_pop 
29d1				endm 
# End of macro FORTH_DSP_POP
29d1			;		pop hl 
29d1			 
29d1 7d					ld a, l 
29d2 cd 7a 0c				call aDelayInMS 
29d5				       NEXTW 
29d5 c3 0d 23			jp macro_next 
29d8				endm 
# End of macro NEXTW
29d8			.PAUSES:  
29d8				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
29d8 44				db WORD_SYS_CORE+48             
29d9 47 2a			dw .ROT            
29db 06				db 5 + 1 
29dc .. 00			db "PAUSE",0              
29e2				endm 
# End of macro CWHEAD
29e2			; | PAUSE ( n -- )  Pause for n seconds | DONE 
29e2					if DEBUG_FORTH_WORDS_KEY 
29e2						DMARK "PAU" 
29e2 f5				push af  
29e3 3a f7 29			ld a, (.dmark)  
29e6 32 6e fe			ld (debug_mark),a  
29e9 3a f8 29			ld a, (.dmark+1)  
29ec 32 6f fe			ld (debug_mark+1),a  
29ef 3a f9 29			ld a, (.dmark+2)  
29f2 32 70 fe			ld (debug_mark+2),a  
29f5 18 03			jr .pastdmark  
29f7 ..			.dmark: db "PAU"  
29fa f1			.pastdmark: pop af  
29fb			endm  
# End of macro DMARK
29fb						CALLMONITOR 
29fb cd f3 18			call break_point_state  
29fe				endm  
# End of macro CALLMONITOR
29fe					endif 
29fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29fe cd 5e 21			call macro_dsp_valuehl 
2a01				endm 
# End of macro FORTH_DSP_VALUEHL
2a01			;		push hl    ; n2 
2a01					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a01 cd 16 22			call macro_forth_dsp_pop 
2a04				endm 
# End of macro FORTH_DSP_POP
2a04			;		pop hl 
2a04 45					ld b, l 
2a05					if DEBUG_FORTH_WORDS 
2a05						DMARK "PAU" 
2a05 f5				push af  
2a06 3a 1a 2a			ld a, (.dmark)  
2a09 32 6e fe			ld (debug_mark),a  
2a0c 3a 1b 2a			ld a, (.dmark+1)  
2a0f 32 6f fe			ld (debug_mark+1),a  
2a12 3a 1c 2a			ld a, (.dmark+2)  
2a15 32 70 fe			ld (debug_mark+2),a  
2a18 18 03			jr .pastdmark  
2a1a ..			.dmark: db "PAU"  
2a1d f1			.pastdmark: pop af  
2a1e			endm  
# End of macro DMARK
2a1e						CALLMONITOR 
2a1e cd f3 18			call break_point_state  
2a21				endm  
# End of macro CALLMONITOR
2a21					endif 
2a21 c5			.pauses1:	push bc 
2a22 cd 95 0c				call delay1s 
2a25 c1					pop bc 
2a26					if DEBUG_FORTH_WORDS 
2a26						DMARK "PA1" 
2a26 f5				push af  
2a27 3a 3b 2a			ld a, (.dmark)  
2a2a 32 6e fe			ld (debug_mark),a  
2a2d 3a 3c 2a			ld a, (.dmark+1)  
2a30 32 6f fe			ld (debug_mark+1),a  
2a33 3a 3d 2a			ld a, (.dmark+2)  
2a36 32 70 fe			ld (debug_mark+2),a  
2a39 18 03			jr .pastdmark  
2a3b ..			.dmark: db "PA1"  
2a3e f1			.pastdmark: pop af  
2a3f			endm  
# End of macro DMARK
2a3f						CALLMONITOR 
2a3f cd f3 18			call break_point_state  
2a42				endm  
# End of macro CALLMONITOR
2a42					endif 
2a42 10 dd				djnz .pauses1 
2a44			 
2a44				       NEXTW 
2a44 c3 0d 23			jp macro_next 
2a47				endm 
# End of macro NEXTW
2a47			.ROT: 
2a47				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2a47 45				db WORD_SYS_CORE+49             
2a48 95 2a			dw .UWORDS            
2a4a 04				db 3 + 1 
2a4b .. 00			db "ROT",0              
2a4f				endm 
# End of macro CWHEAD
2a4f			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2a4f					if DEBUG_FORTH_WORDS_KEY 
2a4f						DMARK "ROT" 
2a4f f5				push af  
2a50 3a 64 2a			ld a, (.dmark)  
2a53 32 6e fe			ld (debug_mark),a  
2a56 3a 65 2a			ld a, (.dmark+1)  
2a59 32 6f fe			ld (debug_mark+1),a  
2a5c 3a 66 2a			ld a, (.dmark+2)  
2a5f 32 70 fe			ld (debug_mark+2),a  
2a62 18 03			jr .pastdmark  
2a64 ..			.dmark: db "ROT"  
2a67 f1			.pastdmark: pop af  
2a68			endm  
# End of macro DMARK
2a68						CALLMONITOR 
2a68 cd f3 18			call break_point_state  
2a6b				endm  
# End of macro CALLMONITOR
2a6b					endif 
2a6b			 
2a6b					FORTH_DSP_VALUEHL 
2a6b cd 5e 21			call macro_dsp_valuehl 
2a6e				endm 
# End of macro FORTH_DSP_VALUEHL
2a6e e5					push hl    ; u3  
2a6f			 
2a6f					FORTH_DSP_POP 
2a6f cd 16 22			call macro_forth_dsp_pop 
2a72				endm 
# End of macro FORTH_DSP_POP
2a72			   
2a72					FORTH_DSP_VALUEHL 
2a72 cd 5e 21			call macro_dsp_valuehl 
2a75				endm 
# End of macro FORTH_DSP_VALUEHL
2a75 e5					push hl     ; u2 
2a76			 
2a76					FORTH_DSP_POP 
2a76 cd 16 22			call macro_forth_dsp_pop 
2a79				endm 
# End of macro FORTH_DSP_POP
2a79			 
2a79					FORTH_DSP_VALUEHL 
2a79 cd 5e 21			call macro_dsp_valuehl 
2a7c				endm 
# End of macro FORTH_DSP_VALUEHL
2a7c e5					push hl     ; u1 
2a7d			 
2a7d					FORTH_DSP_POP 
2a7d cd 16 22			call macro_forth_dsp_pop 
2a80				endm 
# End of macro FORTH_DSP_POP
2a80			 
2a80 c1					pop bc      ; u1 
2a81 e1					pop hl      ; u2 
2a82 d1					pop de      ; u3 
2a83			 
2a83			 
2a83 c5					push bc 
2a84 d5					push de 
2a85 e5					push hl 
2a86			 
2a86			 
2a86 e1					pop hl 
2a87 cd 67 1f				call forth_push_numhl 
2a8a			 
2a8a e1					pop hl 
2a8b cd 67 1f				call forth_push_numhl 
2a8e			 
2a8e e1					pop hl 
2a8f cd 67 1f				call forth_push_numhl 
2a92					 
2a92			 
2a92			 
2a92			 
2a92			 
2a92			 
2a92				       NEXTW 
2a92 c3 0d 23			jp macro_next 
2a95				endm 
# End of macro NEXTW
2a95			 
2a95			.UWORDS: 
2a95				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2a95 50				db WORD_SYS_CORE+60             
2a96 57 2b			dw .BP            
2a98 07				db 6 + 1 
2a99 .. 00			db "UWORDS",0              
2aa0				endm 
# End of macro CWHEAD
2aa0			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2aa0			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2aa0			; | | Following the count are the individual words. 
2aa0			; | | 
2aa0			; | | e.g. UWORDS 
2aa0			; | | BOX DIRLIST 2 
2aa0			; | |  
2aa0			; | | Can be used to save the words to storage via: 
2aa0			; | | UWORDS $01 DO $01 APPEND LOOP 
2aa0				if DEBUG_FORTH_WORDS_KEY 
2aa0					DMARK "UWR" 
2aa0 f5				push af  
2aa1 3a b5 2a			ld a, (.dmark)  
2aa4 32 6e fe			ld (debug_mark),a  
2aa7 3a b6 2a			ld a, (.dmark+1)  
2aaa 32 6f fe			ld (debug_mark+1),a  
2aad 3a b7 2a			ld a, (.dmark+2)  
2ab0 32 70 fe			ld (debug_mark+2),a  
2ab3 18 03			jr .pastdmark  
2ab5 ..			.dmark: db "UWR"  
2ab8 f1			.pastdmark: pop af  
2ab9			endm  
# End of macro DMARK
2ab9					CALLMONITOR 
2ab9 cd f3 18			call break_point_state  
2abc				endm  
# End of macro CALLMONITOR
2abc				endif 
2abc 21 00 80				ld hl, baseram 
2abf					;ld hl, baseusermem 
2abf 01 00 00				ld bc, 0    ; start a counter 
2ac2			 
2ac2				; skip dict stub 
2ac2			 
2ac2 cd 5e 24				call forth_tok_next 
2ac5			 
2ac5			 
2ac5			; while we have words to look for 
2ac5			 
2ac5 7e			.douscan:	ld a, (hl)      
2ac6				if DEBUG_FORTH_WORDS 
2ac6					DMARK "UWs" 
2ac6 f5				push af  
2ac7 3a db 2a			ld a, (.dmark)  
2aca 32 6e fe			ld (debug_mark),a  
2acd 3a dc 2a			ld a, (.dmark+1)  
2ad0 32 6f fe			ld (debug_mark+1),a  
2ad3 3a dd 2a			ld a, (.dmark+2)  
2ad6 32 70 fe			ld (debug_mark+2),a  
2ad9 18 03			jr .pastdmark  
2adb ..			.dmark: db "UWs"  
2ade f1			.pastdmark: pop af  
2adf			endm  
# End of macro DMARK
2adf					CALLMONITOR 
2adf cd f3 18			call break_point_state  
2ae2				endm  
# End of macro CALLMONITOR
2ae2				endif 
2ae2 fe 00				cp WORD_SYS_END 
2ae4 28 4d				jr z, .udone 
2ae6 fe 01				cp WORD_SYS_UWORD 
2ae8 20 44				jr nz, .nuword 
2aea			 
2aea				if DEBUG_FORTH_WORDS 
2aea					DMARK "UWu" 
2aea f5				push af  
2aeb 3a ff 2a			ld a, (.dmark)  
2aee 32 6e fe			ld (debug_mark),a  
2af1 3a 00 2b			ld a, (.dmark+1)  
2af4 32 6f fe			ld (debug_mark+1),a  
2af7 3a 01 2b			ld a, (.dmark+2)  
2afa 32 70 fe			ld (debug_mark+2),a  
2afd 18 03			jr .pastdmark  
2aff ..			.dmark: db "UWu"  
2b02 f1			.pastdmark: pop af  
2b03			endm  
# End of macro DMARK
2b03					CALLMONITOR 
2b03 cd f3 18			call break_point_state  
2b06				endm  
# End of macro CALLMONITOR
2b06				endif 
2b06					; we have a uword so push its name to the stack 
2b06			 
2b06 e5				   	push hl  ; save so we can move to next dict block 
2b07			 
2b07					; skip opcode 
2b07 23					inc hl  
2b08					; skip next ptr 
2b08 23					inc hl  
2b09 23					inc hl 
2b0a					; skip len 
2b0a 23					inc hl 
2b0b				if DEBUG_FORTH_WORDS 
2b0b					DMARK "UWt" 
2b0b f5				push af  
2b0c 3a 20 2b			ld a, (.dmark)  
2b0f 32 6e fe			ld (debug_mark),a  
2b12 3a 21 2b			ld a, (.dmark+1)  
2b15 32 6f fe			ld (debug_mark+1),a  
2b18 3a 22 2b			ld a, (.dmark+2)  
2b1b 32 70 fe			ld (debug_mark+2),a  
2b1e 18 03			jr .pastdmark  
2b20 ..			.dmark: db "UWt"  
2b23 f1			.pastdmark: pop af  
2b24			endm  
# End of macro DMARK
2b24					CALLMONITOR 
2b24 cd f3 18			call break_point_state  
2b27				endm  
# End of macro CALLMONITOR
2b27				endif 
2b27 03					inc bc 
2b28			 
2b28 c5					push bc 
2b29 cd d5 1f				call forth_push_str 
2b2c c1					pop bc 
2b2d			 
2b2d e1					pop hl 	 
2b2e			 
2b2e cd 5e 24		.nuword:	call forth_tok_next 
2b31 18 92				jr .douscan  
2b33			 
2b33			.udone:		 ; push count of uwords found 
2b33 c5					push bc 
2b34 e1					pop hl 
2b35			 
2b35				if DEBUG_FORTH_WORDS 
2b35					DMARK "UWc" 
2b35 f5				push af  
2b36 3a 4a 2b			ld a, (.dmark)  
2b39 32 6e fe			ld (debug_mark),a  
2b3c 3a 4b 2b			ld a, (.dmark+1)  
2b3f 32 6f fe			ld (debug_mark+1),a  
2b42 3a 4c 2b			ld a, (.dmark+2)  
2b45 32 70 fe			ld (debug_mark+2),a  
2b48 18 03			jr .pastdmark  
2b4a ..			.dmark: db "UWc"  
2b4d f1			.pastdmark: pop af  
2b4e			endm  
# End of macro DMARK
2b4e					CALLMONITOR 
2b4e cd f3 18			call break_point_state  
2b51				endm  
# End of macro CALLMONITOR
2b51				endif 
2b51 cd 67 1f				call forth_push_numhl 
2b54			 
2b54			 
2b54				       NEXTW 
2b54 c3 0d 23			jp macro_next 
2b57				endm 
# End of macro NEXTW
2b57			 
2b57			.BP: 
2b57				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2b57 54				db WORD_SYS_CORE+64             
2b58 8d 2b			dw .MONITOR            
2b5a 03				db 2 + 1 
2b5b .. 00			db "BP",0              
2b5e				endm 
# End of macro CWHEAD
2b5e			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2b5e			; | | $00 Will enable the break points within specific code paths 
2b5e			; | | $01 Will disable break points 
2b5e			; | |  
2b5e			; | | By default break points are off. Either the above can be used to enable them 
2b5e			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2b5e			; | | and on release of the pressed key a message will be disaplayed to notify 
2b5e			; | | that break points are enabled. Pressing any key will then continue boot process. 
2b5e					; get byte count 
2b5e					if DEBUG_FORTH_WORDS_KEY 
2b5e						DMARK "BP." 
2b5e f5				push af  
2b5f 3a 73 2b			ld a, (.dmark)  
2b62 32 6e fe			ld (debug_mark),a  
2b65 3a 74 2b			ld a, (.dmark+1)  
2b68 32 6f fe			ld (debug_mark+1),a  
2b6b 3a 75 2b			ld a, (.dmark+2)  
2b6e 32 70 fe			ld (debug_mark+2),a  
2b71 18 03			jr .pastdmark  
2b73 ..			.dmark: db "BP."  
2b76 f1			.pastdmark: pop af  
2b77			endm  
# End of macro DMARK
2b77						CALLMONITOR 
2b77 cd f3 18			call break_point_state  
2b7a				endm  
# End of macro CALLMONITOR
2b7a					endif 
2b7a			 
2b7a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b7a cd 5e 21			call macro_dsp_valuehl 
2b7d				endm 
# End of macro FORTH_DSP_VALUEHL
2b7d			 
2b7d			;		push hl 
2b7d			 
2b7d					; destroy value TOS 
2b7d			 
2b7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b7d cd 16 22			call macro_forth_dsp_pop 
2b80				endm 
# End of macro FORTH_DSP_POP
2b80			 
2b80			;		pop hl 
2b80			 
2b80 3e 00				ld a,0 
2b82 bd					cp l 
2b83 28 02				jr z, .bpset 
2b85 3e 2a				ld a, '*' 
2b87			 
2b87 32 b9 f1		.bpset:		ld (os_view_disable), a 
2b8a			 
2b8a			 
2b8a					NEXTW 
2b8a c3 0d 23			jp macro_next 
2b8d				endm 
# End of macro NEXTW
2b8d			 
2b8d			 
2b8d			.MONITOR: 
2b8d				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2b8d 55				db WORD_SYS_CORE+65             
2b8e c0 2b			dw .MALLOC            
2b90 08				db 7 + 1 
2b91 .. 00			db "MONITOR",0              
2b99				endm 
# End of macro CWHEAD
2b99			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2b99			; | | At start the current various registers will be displayed with contents. 
2b99			; | | Top right corner will show the most recent debug marker seen. 
2b99			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2b99			; | | and the return stack pointer (RSP). 
2b99			; | | Pressing: 
2b99			; | |    1 - Initial screen 
2b99			; | |    2 - Display a data dump of HL 
2b99			; | |    3 - Display a data dump of DE 
2b99			; | |    4 - Display a data dump of BC 
2b99			; | |    5 - Display a data dump of HL 
2b99			; | |    6 - Display a data dump of DSP 
2b99			; | |    7 - Display a data dump of RSP 
2b99			; | |    8 - Display a data dump of what is at DSP 
2b99			; | |    9 - Display a data dump of what is at RSP 
2b99			; | |    0 - Exit monitor and continue running. This will also enable break points 
2b99			; | |    * - Disable break points 
2b99			; | |    # - Enter traditional monitor mode 
2b99			; | | 
2b99			; | | Monitor Mode 
2b99			; | | ------------ 
2b99			; | | A prompt of '>' will be shown for various commands: 
2b99			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2b99			; | |    C - Continue display a data dump from the last set address 
2b99			; | |    M xxxx - Set start of memory edit at address xx 
2b99			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2b99			; | |    Q - Return to previous 
2b99					if DEBUG_FORTH_WORDS_KEY 
2b99						DMARK "MON" 
2b99 f5				push af  
2b9a 3a ae 2b			ld a, (.dmark)  
2b9d 32 6e fe			ld (debug_mark),a  
2ba0 3a af 2b			ld a, (.dmark+1)  
2ba3 32 6f fe			ld (debug_mark+1),a  
2ba6 3a b0 2b			ld a, (.dmark+2)  
2ba9 32 70 fe			ld (debug_mark+2),a  
2bac 18 03			jr .pastdmark  
2bae ..			.dmark: db "MON"  
2bb1 f1			.pastdmark: pop af  
2bb2			endm  
# End of macro DMARK
2bb2						CALLMONITOR 
2bb2 cd f3 18			call break_point_state  
2bb5				endm  
# End of macro CALLMONITOR
2bb5					endif 
2bb5 3e 00				ld a, 0 
2bb7 32 b9 f1				ld (os_view_disable), a 
2bba			 
2bba					CALLMONITOR 
2bba cd f3 18			call break_point_state  
2bbd				endm  
# End of macro CALLMONITOR
2bbd			 
2bbd			;	call monitor 
2bbd			 
2bbd					NEXTW 
2bbd c3 0d 23			jp macro_next 
2bc0				endm 
# End of macro NEXTW
2bc0			 
2bc0			 
2bc0			.MALLOC: 
2bc0				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2bc0 56				db WORD_SYS_CORE+66             
2bc1 e9 2b			dw .MALLOC2            
2bc3 06				db 5 + 1 
2bc4 .. 00			db "ALLOT",0              
2bca				endm 
# End of macro CWHEAD
2bca			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2bca					if DEBUG_FORTH_WORDS_KEY 
2bca						DMARK "ALL" 
2bca f5				push af  
2bcb 3a df 2b			ld a, (.dmark)  
2bce 32 6e fe			ld (debug_mark),a  
2bd1 3a e0 2b			ld a, (.dmark+1)  
2bd4 32 6f fe			ld (debug_mark+1),a  
2bd7 3a e1 2b			ld a, (.dmark+2)  
2bda 32 70 fe			ld (debug_mark+2),a  
2bdd 18 03			jr .pastdmark  
2bdf ..			.dmark: db "ALL"  
2be2 f1			.pastdmark: pop af  
2be3			endm  
# End of macro DMARK
2be3						CALLMONITOR 
2be3 cd f3 18			call break_point_state  
2be6				endm  
# End of macro CALLMONITOR
2be6					endif 
2be6 c3 10 2c				jp .mallocc 
2be9			.MALLOC2: 
2be9				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2be9 56				db WORD_SYS_CORE+66             
2bea 27 2c			dw .FREE            
2bec 07				db 6 + 1 
2bed .. 00			db "MALLOC",0              
2bf4				endm 
# End of macro CWHEAD
2bf4			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2bf4					; get byte count 
2bf4					if DEBUG_FORTH_WORDS_KEY 
2bf4						DMARK "MAL" 
2bf4 f5				push af  
2bf5 3a 09 2c			ld a, (.dmark)  
2bf8 32 6e fe			ld (debug_mark),a  
2bfb 3a 0a 2c			ld a, (.dmark+1)  
2bfe 32 6f fe			ld (debug_mark+1),a  
2c01 3a 0b 2c			ld a, (.dmark+2)  
2c04 32 70 fe			ld (debug_mark+2),a  
2c07 18 03			jr .pastdmark  
2c09 ..			.dmark: db "MAL"  
2c0c f1			.pastdmark: pop af  
2c0d			endm  
# End of macro DMARK
2c0d						CALLMONITOR 
2c0d cd f3 18			call break_point_state  
2c10				endm  
# End of macro CALLMONITOR
2c10					endif 
2c10			.mallocc: 
2c10					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c10 cd 5e 21			call macro_dsp_valuehl 
2c13				endm 
# End of macro FORTH_DSP_VALUEHL
2c13			 
2c13			;		push hl 
2c13			 
2c13					; destroy value TOS 
2c13			 
2c13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c13 cd 16 22			call macro_forth_dsp_pop 
2c16				endm 
# End of macro FORTH_DSP_POP
2c16			 
2c16			;		pop hl 
2c16 cd 13 14				call malloc 
2c19				if DEBUG_FORTH_MALLOC_GUARD 
2c19 f5					push af 
2c1a cd 75 0f				call ishlzero 
2c1d			;		ld a, l 
2c1d			;		add h 
2c1d			;		cp 0 
2c1d f1					pop af 
2c1e					 
2c1e cc 15 59				call z,malloc_error 
2c21				endif 
2c21			 
2c21 cd 67 1f				call forth_push_numhl 
2c24					NEXTW 
2c24 c3 0d 23			jp macro_next 
2c27				endm 
# End of macro NEXTW
2c27			 
2c27			.FREE: 
2c27				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2c27 57				db WORD_SYS_CORE+67             
2c28 58 2c			dw .LIST            
2c2a 05				db 4 + 1 
2c2b .. 00			db "FREE",0              
2c30				endm 
# End of macro CWHEAD
2c30			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2c30					if DEBUG_FORTH_WORDS_KEY 
2c30						DMARK "FRE" 
2c30 f5				push af  
2c31 3a 45 2c			ld a, (.dmark)  
2c34 32 6e fe			ld (debug_mark),a  
2c37 3a 46 2c			ld a, (.dmark+1)  
2c3a 32 6f fe			ld (debug_mark+1),a  
2c3d 3a 47 2c			ld a, (.dmark+2)  
2c40 32 70 fe			ld (debug_mark+2),a  
2c43 18 03			jr .pastdmark  
2c45 ..			.dmark: db "FRE"  
2c48 f1			.pastdmark: pop af  
2c49			endm  
# End of macro DMARK
2c49						CALLMONITOR 
2c49 cd f3 18			call break_point_state  
2c4c				endm  
# End of macro CALLMONITOR
2c4c					endif 
2c4c					; get address 
2c4c			 
2c4c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c4c cd 5e 21			call macro_dsp_valuehl 
2c4f				endm 
# End of macro FORTH_DSP_VALUEHL
2c4f			 
2c4f			;		push hl 
2c4f			 
2c4f					; destroy value TOS 
2c4f			 
2c4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c4f cd 16 22			call macro_forth_dsp_pop 
2c52				endm 
# End of macro FORTH_DSP_POP
2c52			 
2c52			;		pop hl 
2c52			if FORTH_ENABLE_MALLOCFREE 
2c52 cd dd 14				call free 
2c55			endif 
2c55					NEXTW 
2c55 c3 0d 23			jp macro_next 
2c58				endm 
# End of macro NEXTW
2c58			.LIST: 
2c58				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2c58 5c				db WORD_SYS_CORE+72             
2c59 46 2e			dw .FORGET            
2c5b 05				db 4 + 1 
2c5c .. 00			db "LIST",0              
2c61				endm 
# End of macro CWHEAD
2c61			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2c61			; | | The quoted word must be in upper case. 
2c61				if DEBUG_FORTH_WORDS_KEY 
2c61					DMARK "LST" 
2c61 f5				push af  
2c62 3a 76 2c			ld a, (.dmark)  
2c65 32 6e fe			ld (debug_mark),a  
2c68 3a 77 2c			ld a, (.dmark+1)  
2c6b 32 6f fe			ld (debug_mark+1),a  
2c6e 3a 78 2c			ld a, (.dmark+2)  
2c71 32 70 fe			ld (debug_mark+2),a  
2c74 18 03			jr .pastdmark  
2c76 ..			.dmark: db "LST"  
2c79 f1			.pastdmark: pop af  
2c7a			endm  
# End of macro DMARK
2c7a					CALLMONITOR 
2c7a cd f3 18			call break_point_state  
2c7d				endm  
# End of macro CALLMONITOR
2c7d				endif 
2c7d			 
2c7d					FORTH_DSP_VALUEHL 
2c7d cd 5e 21			call macro_dsp_valuehl 
2c80				endm 
# End of macro FORTH_DSP_VALUEHL
2c80			 
2c80 e5					push hl 
2c81					FORTH_DSP_POP 
2c81 cd 16 22			call macro_forth_dsp_pop 
2c84				endm 
# End of macro FORTH_DSP_POP
2c84 c1					pop bc 
2c85			 
2c85			; Start format of scratch string 
2c85			 
2c85 21 c8 f1				ld hl, scratch 
2c88			 
2c88 3e 3a				ld a, ':' 
2c8a 77					ld (hl),a 
2c8b 23					inc hl 
2c8c 3e 20				ld a, ' ' 
2c8e 77					ld (hl), a 
2c8f			 
2c8f					; Get ptr to the word we need to look up 
2c8f			 
2c8f			;		FORTH_DSP_VALUEHL 
2c8f					;v5 FORTH_DSP_VALUE 
2c8f				; TODO type check 
2c8f			;		inc hl    ; Skip type check  
2c8f			;		push hl 
2c8f			;		ex de, hl    ; put into DE 
2c8f			 
2c8f			 
2c8f 21 00 80				ld hl, baseram 
2c92					;ld hl, baseusermem 
2c92			 
2c92 e5			push hl   ; sacreifical push 
2c93			 
2c93			.ldouscanm: 
2c93 e1				pop hl 
2c94			.ldouscan: 
2c94				if DEBUG_FORTH_WORDS 
2c94					DMARK "LSs" 
2c94 f5				push af  
2c95 3a a9 2c			ld a, (.dmark)  
2c98 32 6e fe			ld (debug_mark),a  
2c9b 3a aa 2c			ld a, (.dmark+1)  
2c9e 32 6f fe			ld (debug_mark+1),a  
2ca1 3a ab 2c			ld a, (.dmark+2)  
2ca4 32 70 fe			ld (debug_mark+2),a  
2ca7 18 03			jr .pastdmark  
2ca9 ..			.dmark: db "LSs"  
2cac f1			.pastdmark: pop af  
2cad			endm  
# End of macro DMARK
2cad					CALLMONITOR 
2cad cd f3 18			call break_point_state  
2cb0				endm  
# End of macro CALLMONITOR
2cb0				endif 
2cb0				; skip dict stub 
2cb0 cd 5e 24				call forth_tok_next 
2cb3			 
2cb3			 
2cb3			; while we have words to look for 
2cb3			 
2cb3 7e				ld a, (hl)      
2cb4				if DEBUG_FORTH_WORDS 
2cb4					DMARK "LSk" 
2cb4 f5				push af  
2cb5 3a c9 2c			ld a, (.dmark)  
2cb8 32 6e fe			ld (debug_mark),a  
2cbb 3a ca 2c			ld a, (.dmark+1)  
2cbe 32 6f fe			ld (debug_mark+1),a  
2cc1 3a cb 2c			ld a, (.dmark+2)  
2cc4 32 70 fe			ld (debug_mark+2),a  
2cc7 18 03			jr .pastdmark  
2cc9 ..			.dmark: db "LSk"  
2ccc f1			.pastdmark: pop af  
2ccd			endm  
# End of macro DMARK
2ccd					CALLMONITOR 
2ccd cd f3 18			call break_point_state  
2cd0				endm  
# End of macro CALLMONITOR
2cd0				endif 
2cd0					;cp WORD_SYS_END 
2cd0					;jp z, .lunotfound 
2cd0			 
2cd0					; if we hit non uwords then gone too far 
2cd0 fe 01				cp WORD_SYS_UWORD 
2cd2 c2 02 2e				jp nz, .lunotfound 
2cd5			 
2cd5				if DEBUG_FORTH_WORDS 
2cd5					DMARK "LSu" 
2cd5 f5				push af  
2cd6 3a ea 2c			ld a, (.dmark)  
2cd9 32 6e fe			ld (debug_mark),a  
2cdc 3a eb 2c			ld a, (.dmark+1)  
2cdf 32 6f fe			ld (debug_mark+1),a  
2ce2 3a ec 2c			ld a, (.dmark+2)  
2ce5 32 70 fe			ld (debug_mark+2),a  
2ce8 18 03			jr .pastdmark  
2cea ..			.dmark: db "LSu"  
2ced f1			.pastdmark: pop af  
2cee			endm  
# End of macro DMARK
2cee					CALLMONITOR 
2cee cd f3 18			call break_point_state  
2cf1				endm  
# End of macro CALLMONITOR
2cf1				endif 
2cf1			 
2cf1					; found a uword but is it the one we want... 
2cf1			 
2cf1 c5					push bc     ; uword to find is on bc 
2cf2 d1					pop de 
2cf3			 
2cf3 e5					push hl  ; to save the ptr 
2cf4			 
2cf4					; skip opcode 
2cf4 23					inc hl  
2cf5					; skip next ptr 
2cf5 23					inc hl  
2cf6 23					inc hl 
2cf7					; skip len 
2cf7 23					inc hl 
2cf8			 
2cf8				if DEBUG_FORTH_WORDS 
2cf8					DMARK "LSc" 
2cf8 f5				push af  
2cf9 3a 0d 2d			ld a, (.dmark)  
2cfc 32 6e fe			ld (debug_mark),a  
2cff 3a 0e 2d			ld a, (.dmark+1)  
2d02 32 6f fe			ld (debug_mark+1),a  
2d05 3a 0f 2d			ld a, (.dmark+2)  
2d08 32 70 fe			ld (debug_mark+2),a  
2d0b 18 03			jr .pastdmark  
2d0d ..			.dmark: db "LSc"  
2d10 f1			.pastdmark: pop af  
2d11			endm  
# End of macro DMARK
2d11					CALLMONITOR 
2d11 cd f3 18			call break_point_state  
2d14				endm  
# End of macro CALLMONITOR
2d14				endif 
2d14 cd e2 13				call strcmp 
2d17 c2 93 2c				jp nz, .ldouscanm 
2d1a				 
2d1a			 
2d1a			 
2d1a					; we have a uword so push its name to the stack 
2d1a			 
2d1a			;	   	push hl  ; save so we can move to next dict block 
2d1a e1			pop hl 
2d1b			 
2d1b				if DEBUG_FORTH_WORDS 
2d1b					DMARK "LSm" 
2d1b f5				push af  
2d1c 3a 30 2d			ld a, (.dmark)  
2d1f 32 6e fe			ld (debug_mark),a  
2d22 3a 31 2d			ld a, (.dmark+1)  
2d25 32 6f fe			ld (debug_mark+1),a  
2d28 3a 32 2d			ld a, (.dmark+2)  
2d2b 32 70 fe			ld (debug_mark+2),a  
2d2e 18 03			jr .pastdmark  
2d30 ..			.dmark: db "LSm"  
2d33 f1			.pastdmark: pop af  
2d34			endm  
# End of macro DMARK
2d34					CALLMONITOR 
2d34 cd f3 18			call break_point_state  
2d37				endm  
# End of macro CALLMONITOR
2d37				endif 
2d37			 
2d37					; skip opcode 
2d37 23					inc hl  
2d38					; skip next ptr 
2d38 23					inc hl  
2d39 23					inc hl 
2d3a					; skip len 
2d3a 7e					ld a, (hl)   ; save length to add 
2d3b				if DEBUG_FORTH_WORDS 
2d3b					DMARK "LS2" 
2d3b f5				push af  
2d3c 3a 50 2d			ld a, (.dmark)  
2d3f 32 6e fe			ld (debug_mark),a  
2d42 3a 51 2d			ld a, (.dmark+1)  
2d45 32 6f fe			ld (debug_mark+1),a  
2d48 3a 52 2d			ld a, (.dmark+2)  
2d4b 32 70 fe			ld (debug_mark+2),a  
2d4e 18 03			jr .pastdmark  
2d50 ..			.dmark: db "LS2"  
2d53 f1			.pastdmark: pop af  
2d54			endm  
# End of macro DMARK
2d54					CALLMONITOR 
2d54 cd f3 18			call break_point_state  
2d57				endm  
# End of macro CALLMONITOR
2d57				endif 
2d57			 
2d57					; save this location 
2d57				 
2d57 e5					push hl 
2d58			 
2d58 23					inc hl 
2d59 11 ca f1				ld de, scratch+2 
2d5c 4f					ld c, a 
2d5d 06 00				ld b, 0 
2d5f			 
2d5f				if DEBUG_FORTH_WORDS 
2d5f					DMARK "LSn" 
2d5f f5				push af  
2d60 3a 74 2d			ld a, (.dmark)  
2d63 32 6e fe			ld (debug_mark),a  
2d66 3a 75 2d			ld a, (.dmark+1)  
2d69 32 6f fe			ld (debug_mark+1),a  
2d6c 3a 76 2d			ld a, (.dmark+2)  
2d6f 32 70 fe			ld (debug_mark+2),a  
2d72 18 03			jr .pastdmark  
2d74 ..			.dmark: db "LSn"  
2d77 f1			.pastdmark: pop af  
2d78			endm  
# End of macro DMARK
2d78					CALLMONITOR 
2d78 cd f3 18			call break_point_state  
2d7b				endm  
# End of macro CALLMONITOR
2d7b				endif 
2d7b			 
2d7b					; copy uword name to scratch 
2d7b			 
2d7b ed b0				ldir 
2d7d			 
2d7d 1b					dec de 
2d7e 3e 20				ld a, ' '    ; change null to space 
2d80 12					ld (de), a 
2d81			 
2d81 13					inc de 
2d82			 
2d82 d5					push de 
2d83 c1					pop bc     ; move scratch pointer to end of word name and save it 
2d84			 
2d84 e1					pop hl 
2d85 7e					ld a, (hl) 
2d86					;inc hl 
2d86					; skip word string 
2d86 cd 4c 0f				call addatohl 
2d89			 
2d89 23					inc hl 
2d8a			 
2d8a				if DEBUG_FORTH_WORDS 
2d8a					DMARK "LS3" 
2d8a f5				push af  
2d8b 3a 9f 2d			ld a, (.dmark)  
2d8e 32 6e fe			ld (debug_mark),a  
2d91 3a a0 2d			ld a, (.dmark+1)  
2d94 32 6f fe			ld (debug_mark+1),a  
2d97 3a a1 2d			ld a, (.dmark+2)  
2d9a 32 70 fe			ld (debug_mark+2),a  
2d9d 18 03			jr .pastdmark  
2d9f ..			.dmark: db "LS3"  
2da2 f1			.pastdmark: pop af  
2da3			endm  
# End of macro DMARK
2da3					CALLMONITOR 
2da3 cd f3 18			call break_point_state  
2da6				endm  
# End of macro CALLMONITOR
2da6				endif 
2da6					; should now be at the start of the machine code to setup the eval of the uword 
2da6					; now locate the ptr to the string defintion 
2da6			 
2da6					; skip ld hl, 
2da6					; then load the ptr 
2da6			; TODO use get from hl ptr 
2da6 23					inc hl 
2da7 5e					ld e, (hl) 
2da8 23					inc hl 
2da9 56					ld d, (hl) 
2daa eb					ex de, hl 
2dab			 
2dab			 
2dab				if DEBUG_FORTH_WORDS 
2dab					DMARK "LSt" 
2dab f5				push af  
2dac 3a c0 2d			ld a, (.dmark)  
2daf 32 6e fe			ld (debug_mark),a  
2db2 3a c1 2d			ld a, (.dmark+1)  
2db5 32 6f fe			ld (debug_mark+1),a  
2db8 3a c2 2d			ld a, (.dmark+2)  
2dbb 32 70 fe			ld (debug_mark+2),a  
2dbe 18 03			jr .pastdmark  
2dc0 ..			.dmark: db "LSt"  
2dc3 f1			.pastdmark: pop af  
2dc4			endm  
# End of macro DMARK
2dc4					CALLMONITOR 
2dc4 cd f3 18			call break_point_state  
2dc7				endm  
# End of macro CALLMONITOR
2dc7				endif 
2dc7			 
2dc7			; cant push right now due to tokenised strings  
2dc7			 
2dc7			; get the destination of where to copy this definition to. 
2dc7			 
2dc7 c5					push bc 
2dc8 d1					pop de 
2dc9			 
2dc9 7e			.listl:         ld a,(hl) 
2dca fe 00				cp 0 
2dcc 28 09				jr z, .lreplsp     ; replace zero with space 
2dce					;cp FORTH_END_BUFFER 
2dce fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2dd0 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2dd2				 
2dd2					; just copy this char as is then 
2dd2			 
2dd2 12					ld (de), a 
2dd3			 
2dd3 23			.listnxt:	inc hl 
2dd4 13					inc de 
2dd5 18 f2				jr .listl 
2dd7			 
2dd7 3e 20		.lreplsp:	ld a,' ' 
2dd9 12					ld (de), a 
2dda 18 f7				jr .listnxt 
2ddc			 
2ddc			; close up uword def 
2ddc			 
2ddc			.listdone: 
2ddc 12					ld (de), a 
2ddd 13					inc de 
2dde 3e 00				ld a, 0 
2de0 12					ld (de), a 
2de1			 
2de1			; now have def so clean up and push to stack 
2de1			 
2de1 21 c8 f1				ld hl, scratch 
2de4				if DEBUG_FORTH_WORDS 
2de4					DMARK "Ltp" 
2de4 f5				push af  
2de5 3a f9 2d			ld a, (.dmark)  
2de8 32 6e fe			ld (debug_mark),a  
2deb 3a fa 2d			ld a, (.dmark+1)  
2dee 32 6f fe			ld (debug_mark+1),a  
2df1 3a fb 2d			ld a, (.dmark+2)  
2df4 32 70 fe			ld (debug_mark+2),a  
2df7 18 03			jr .pastdmark  
2df9 ..			.dmark: db "Ltp"  
2dfc f1			.pastdmark: pop af  
2dfd			endm  
# End of macro DMARK
2dfd					CALLMONITOR 
2dfd cd f3 18			call break_point_state  
2e00				endm  
# End of macro CALLMONITOR
2e00				endif 
2e00			 
2e00 18 1f			jr .listpush 
2e02			 
2e02			;.lnuword:	pop hl 
2e02			;		call forth_tok_next 
2e02			;		jp .ldouscan  
2e02			 
2e02			.lunotfound:		  
2e02			 
2e02				if DEBUG_FORTH_WORDS 
2e02					DMARK "LSn" 
2e02 f5				push af  
2e03 3a 17 2e			ld a, (.dmark)  
2e06 32 6e fe			ld (debug_mark),a  
2e09 3a 18 2e			ld a, (.dmark+1)  
2e0c 32 6f fe			ld (debug_mark+1),a  
2e0f 3a 19 2e			ld a, (.dmark+2)  
2e12 32 70 fe			ld (debug_mark+2),a  
2e15 18 03			jr .pastdmark  
2e17 ..			.dmark: db "LSn"  
2e1a f1			.pastdmark: pop af  
2e1b			endm  
# End of macro DMARK
2e1b					CALLMONITOR 
2e1b cd f3 18			call break_point_state  
2e1e				endm  
# End of macro CALLMONITOR
2e1e				endif 
2e1e			 
2e1e					 
2e1e			;		FORTH_DSP_POP 
2e1e			;		ld hl, .luno 
2e1e			 
2e1e					NEXTW			 
2e1e c3 0d 23			jp macro_next 
2e21				endm 
# End of macro NEXTW
2e21			 
2e21			.listpush: 
2e21				if DEBUG_FORTH_WORDS 
2e21					DMARK "LS>" 
2e21 f5				push af  
2e22 3a 36 2e			ld a, (.dmark)  
2e25 32 6e fe			ld (debug_mark),a  
2e28 3a 37 2e			ld a, (.dmark+1)  
2e2b 32 6f fe			ld (debug_mark+1),a  
2e2e 3a 38 2e			ld a, (.dmark+2)  
2e31 32 70 fe			ld (debug_mark+2),a  
2e34 18 03			jr .pastdmark  
2e36 ..			.dmark: db "LS>"  
2e39 f1			.pastdmark: pop af  
2e3a			endm  
# End of macro DMARK
2e3a					CALLMONITOR 
2e3a cd f3 18			call break_point_state  
2e3d				endm  
# End of macro CALLMONITOR
2e3d				endif 
2e3d cd d5 1f				call forth_push_str 
2e40			 
2e40			 
2e40			 
2e40					NEXTW 
2e40 c3 0d 23			jp macro_next 
2e43				endm 
# End of macro NEXTW
2e43			 
2e43			;.luno:    db "Word not found",0 
2e43			 
2e43			 
2e43			 
2e43			 
2e43			 
2e43			;		push hl   ; save pointer to start of uword def string 
2e43			; 
2e43			;; look for FORTH_EOL_LINE 
2e43			;		ld a, FORTH_END_BUFFER 
2e43			;		call strlent 
2e43			; 
2e43			;		inc hl		 ; space for coln def 
2e43			;		inc hl 
2e43			;		inc hl          ; space for terms 
2e43			;		inc hl 
2e43			; 
2e43			;		ld a, 20   ; TODO get actual length 
2e43			;		call addatohl    ; include a random amount of room for the uword name 
2e43			; 
2e43			;		 
2e43			;	if DEBUG_FORTH_WORDS 
2e43			;		DMARK "Lt1" 
2e43			;		CALLMONITOR 
2e43			;	endif 
2e43			;		 
2e43			; 
2e43			;; malloc space for the string because we cant change it 
2e43			; 
2e43			;		call malloc 
2e43			;	if DEBUG_FORTH_MALLOC_GUARD 
2e43			;		push af 
2e43			;		call ishlzero 
2e43			;		pop af 
2e43			;		 
2e43			;		call z,malloc_error 
2e43			;	endif 
2e43			; 
2e43			;	if DEBUG_FORTH_WORDS 
2e43			;		DMARK "Lt2" 
2e43			;		CALLMONITOR 
2e43			;	endif 
2e43			;		pop de 
2e43			;		push hl    ; push the malloc to release later 
2e43			;		push hl   ;  push back a copy for the later stack push 
2e43			;		 
2e43			;; copy the string swapping out the zero terms for spaces 
2e43			; 
2e43			;		; de has our source 
2e43			;		; hl has our dest 
2e43			; 
2e43			;; add the coln def 
2e43			; 
2e43			;		ld a, ':' 
2e43			;		ld (hl), a 
2e43			;		inc hl 
2e43			;		ld a, ' ' 
2e43			;		ld (hl), a 
2e43			;		inc hl 
2e43			; 
2e43			;; add the uname word 
2e43			;		push de   ; save our string for now 
2e43			;		ex de, hl 
2e43			; 
2e43			;		FORTH_DSP_VALUE 
2e43			;		;v5 FORTH_DSP_VALUE 
2e43			; 
2e43			;		inc hl   ; skip type but we know by now this is OK 
2e43			; 
2e43			;.luword:	ld a,(hl) 
2e43			;		cp 0 
2e43			;		jr z, .luword2 
2e43			;		ld (de), a 
2e43			;		inc de 
2e43			;		inc hl 
2e43			;		jr .luword 
2e43			; 
2e43			;.luword2:	ld a, ' ' 
2e43			;		ld (de), a 
2e43			;;		inc hl 
2e43			;;		inc de 
2e43			;;		ld (de), a 
2e43			;;		inc hl 
2e43			;		inc de 
2e43			; 
2e43			;		ex de, hl 
2e43			;		pop de 
2e43			;		 
2e43			;		 
2e43			; 
2e43			;; detoken that string and copy it 
2e43			; 
2e43			;	if DEBUG_FORTH_WORDS 
2e43			;		DMARK "Lt2" 
2e43			;		CALLMONITOR 
2e43			;	endif 
2e43			;.ldetok:	ld a, (de) 
2e43			;		cp FORTH_END_BUFFER 
2e43			;		jr z, .ldetokend 
2e43			;		; swap out any zero term for space 
2e43			;		cp 0 
2e43			;		jr nz, .ldetoknext 
2e43			;		ld a, ' ' 
2e43			; 
2e43			;	if DEBUG_FORTH_WORDS 
2e43			;		DMARK "LtS" 
2e43			;		CALLMONITOR 
2e43			;	endif 
2e43			;.ldetoknext:	ld (hl), a 
2e43			;		inc de 
2e43			;		inc hl 
2e43			;		jr .ldetok 
2e43			; 
2e43			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2e43			;		ld (hl), a  
2e43			; 
2e43			;; free that temp malloc 
2e43			; 
2e43			;		pop hl    
2e43			; 
2e43			;	if DEBUG_FORTH_WORDS 
2e43			;		DMARK "Lt4" 
2e43			;		CALLMONITOR 
2e43			;	endif 
2e43			;		call forth_apushstrhl 
2e43			; 
2e43			;		; get rid of temp malloc area 
2e43			; 
2e43			;		pop hl 
2e43			;		call free 
2e43			; 
2e43			;		jr .ludone 
2e43			; 
2e43			;.lnuword:	pop hl 
2e43			;		call forth_tok_next 
2e43			;		jp .ldouscan  
2e43			; 
2e43			;.ludone:		 pop hl 
2e43			; 
2e43					NEXTW 
2e43 c3 0d 23			jp macro_next 
2e46				endm 
# End of macro NEXTW
2e46			 
2e46			.FORGET: 
2e46				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2e46 5d				db WORD_SYS_CORE+73             
2e47 bf 2e			dw .NOP            
2e49 07				db 6 + 1 
2e4a .. 00			db "FORGET",0              
2e51				endm 
# End of macro CWHEAD
2e51			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2e51			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2e51			; | |  
2e51			; | | e.g. "MORE" forget 
2e51					if DEBUG_FORTH_WORDS_KEY 
2e51						DMARK "FRG" 
2e51 f5				push af  
2e52 3a 66 2e			ld a, (.dmark)  
2e55 32 6e fe			ld (debug_mark),a  
2e58 3a 67 2e			ld a, (.dmark+1)  
2e5b 32 6f fe			ld (debug_mark+1),a  
2e5e 3a 68 2e			ld a, (.dmark+2)  
2e61 32 70 fe			ld (debug_mark+2),a  
2e64 18 03			jr .pastdmark  
2e66 ..			.dmark: db "FRG"  
2e69 f1			.pastdmark: pop af  
2e6a			endm  
# End of macro DMARK
2e6a						CALLMONITOR 
2e6a cd f3 18			call break_point_state  
2e6d				endm  
# End of macro CALLMONITOR
2e6d					endif 
2e6d			 
2e6d				; find uword 
2e6d			        ; update start of word with "_" 
2e6d				; replace uword with deleted flag 
2e6d			 
2e6d			 
2e6d			;	if DEBUG_FORTH_WORDS 
2e6d			;		DMARK "FOG" 
2e6d			;		CALLMONITOR 
2e6d			;	endif 
2e6d			 
2e6d			 
2e6d					; Get ptr to the word we need to look up 
2e6d			 
2e6d					FORTH_DSP_VALUEHL 
2e6d cd 5e 21			call macro_dsp_valuehl 
2e70				endm 
# End of macro FORTH_DSP_VALUEHL
2e70					;v5 FORTH_DSP_VALUE 
2e70				; TODO type check 
2e70			;		inc hl    ; Skip type check  
2e70 e5					push hl 
2e71 c1					pop bc 
2e72			;		ex de, hl    ; put into DE 
2e72			 
2e72			 
2e72 21 00 80				ld hl, baseram 
2e75					;ld hl, baseusermem 
2e75			 
2e75				; skip dict stub 
2e75			;	call forth_tok_next 
2e75 e5			push hl   ; sacreifical push 
2e76			 
2e76			.fldouscanm: 
2e76 e1				pop hl 
2e77			.fldouscan: 
2e77			;	if DEBUG_FORTH_WORDS 
2e77			;		DMARK "LSs" 
2e77			;		CALLMONITOR 
2e77			;	endif 
2e77				; skip dict stub 
2e77 cd 5e 24				call forth_tok_next 
2e7a			 
2e7a			 
2e7a			; while we have words to look for 
2e7a			 
2e7a 7e				ld a, (hl)      
2e7b			;	if DEBUG_FORTH_WORDS 
2e7b			;		DMARK "LSk" 
2e7b			;		CALLMONITOR 
2e7b			;	endif 
2e7b fe 00				cp WORD_SYS_END 
2e7d ca b9 2e				jp z, .flunotfound 
2e80 fe 01				cp WORD_SYS_UWORD 
2e82 c2 77 2e				jp nz, .fldouscan 
2e85			 
2e85			;	if DEBUG_FORTH_WORDS 
2e85			;		DMARK "LSu" 
2e85			;		CALLMONITOR 
2e85			;	endif 
2e85			 
2e85					; found a uword but is it the one we want... 
2e85			 
2e85 c5					push bc     ; uword to find is on bc 
2e86 d1					pop de 
2e87			 
2e87 e5					push hl  ; to save the ptr 
2e88			 
2e88					; skip opcode 
2e88 23					inc hl  
2e89					; skip next ptr 
2e89 23					inc hl  
2e8a 23					inc hl 
2e8b					; skip len 
2e8b 23					inc hl 
2e8c			 
2e8c			;	if DEBUG_FORTH_WORDS 
2e8c			;		DMARK "LSc" 
2e8c			;		CALLMONITOR 
2e8c			;	endif 
2e8c cd e2 13				call strcmp 
2e8f c2 76 2e				jp nz, .fldouscanm 
2e92			; 
2e92			; 
2e92			;; while we have words to look for 
2e92			; 
2e92			;.fdouscan:	ld a, (hl)      
2e92			;	if DEBUG_FORTH_WORDS 
2e92			;		DMARK "LSs" 
2e92			;		CALLMONITOR 
2e92			;	endif 
2e92			;		cp WORD_SYS_END 
2e92			;		jp z, .fudone 
2e92			;		cp WORD_SYS_UWORD 
2e92			;		jp nz, .fnuword 
2e92			; 
2e92			;	if DEBUG_FORTH_WORDS 
2e92			;		DMARK "FGu" 
2e92			;		CALLMONITOR 
2e92			;	endif 
2e92			; 
2e92			;		; found a uword but is it the one we want... 
2e92			; 
2e92			; 
2e92			;	        pop de   ; get back the dsp name 
2e92			;		push de 
2e92			; 
2e92			;		push hl  ; to save the ptr 
2e92			; 
2e92			;		; skip opcode 
2e92			;		inc hl  
2e92			;		; skip next ptr 
2e92			;		inc hl  
2e92			;		inc hl 
2e92			;		; skip len 
2e92			;		inc hl 
2e92			; 
2e92			;	if DEBUG_FORTH_WORDS 
2e92			;		DMARK "FGc" 
2e92			;		CALLMONITOR 
2e92			;	endif 
2e92			;		call strcmp 
2e92			;		jp nz, .fnuword 
2e92			 
2e92			 
2e92 e1			pop hl 
2e93			 
2e93				 
2e93				if DEBUG_FORTH_WORDS 
2e93					DMARK "FGm" 
2e93 f5				push af  
2e94 3a a8 2e			ld a, (.dmark)  
2e97 32 6e fe			ld (debug_mark),a  
2e9a 3a a9 2e			ld a, (.dmark+1)  
2e9d 32 6f fe			ld (debug_mark+1),a  
2ea0 3a aa 2e			ld a, (.dmark+2)  
2ea3 32 70 fe			ld (debug_mark+2),a  
2ea6 18 03			jr .pastdmark  
2ea8 ..			.dmark: db "FGm"  
2eab f1			.pastdmark: pop af  
2eac			endm  
# End of macro DMARK
2eac					CALLMONITOR 
2eac cd f3 18			call break_point_state  
2eaf				endm  
# End of macro CALLMONITOR
2eaf				endif 
2eaf			 
2eaf			 
2eaf			 
2eaf					; we have a uword so push its name to the stack 
2eaf			 
2eaf			;	   	push hl  ; save so we can move to next dict block 
2eaf			;pop hl 
2eaf			 
2eaf					; update opcode to deleted 
2eaf 3e 03				ld a, WORD_SYS_DELETED 
2eb1 77					ld (hl), a 
2eb2			 
2eb2 23					inc hl  
2eb3					; skip next ptr 
2eb3 23					inc hl  
2eb4 23					inc hl 
2eb5					; skip len 
2eb5 23					inc hl 
2eb6			 
2eb6					; TODO change parser to skip deleted words but for now mark it out 
2eb6 3e 5f				ld a, "_" 
2eb8 77					ld  (hl),a 
2eb9			 
2eb9			;		jr .fudone 
2eb9			; 
2eb9			;.fnuword:	pop hl 
2eb9			;		call forth_tok_next 
2eb9			;		jp .fdouscan  
2eb9			 
2eb9			.flunotfound:		  
2eb9			 
2eb9			 
2eb9					 
2eb9					FORTH_DSP_POP 
2eb9 cd 16 22			call macro_forth_dsp_pop 
2ebc				endm 
# End of macro FORTH_DSP_POP
2ebc			;		ld hl, .luno 
2ebc			;.fudone:		 pop hl 
2ebc					NEXTW 
2ebc c3 0d 23			jp macro_next 
2ebf				endm 
# End of macro NEXTW
2ebf			.NOP: 
2ebf				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ebf 61				db WORD_SYS_CORE+77             
2ec0 e6 2e			dw .COMO            
2ec2 04				db 3 + 1 
2ec3 .. 00			db "NOP",0              
2ec7				endm 
# End of macro CWHEAD
2ec7			; | NOP (  --  ) Do nothing | DONE 
2ec7					if DEBUG_FORTH_WORDS_KEY 
2ec7						DMARK "NOP" 
2ec7 f5				push af  
2ec8 3a dc 2e			ld a, (.dmark)  
2ecb 32 6e fe			ld (debug_mark),a  
2ece 3a dd 2e			ld a, (.dmark+1)  
2ed1 32 6f fe			ld (debug_mark+1),a  
2ed4 3a de 2e			ld a, (.dmark+2)  
2ed7 32 70 fe			ld (debug_mark+2),a  
2eda 18 03			jr .pastdmark  
2edc ..			.dmark: db "NOP"  
2edf f1			.pastdmark: pop af  
2ee0			endm  
# End of macro DMARK
2ee0						CALLMONITOR 
2ee0 cd f3 18			call break_point_state  
2ee3				endm  
# End of macro CALLMONITOR
2ee3					endif 
2ee3				       NEXTW 
2ee3 c3 0d 23			jp macro_next 
2ee6				endm 
# End of macro NEXTW
2ee6			.COMO: 
2ee6				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2ee6 6e				db WORD_SYS_CORE+90             
2ee7 38 2f			dw .COMC            
2ee9 02				db 1 + 1 
2eea .. 00			db "(",0              
2eec				endm 
# End of macro CWHEAD
2eec			; | ( ( -- )  Start of comment | DONE 
2eec			 
2eec			 
2eec 2a c9 f4				ld hl, ( os_tok_ptr) 
2eef 11 33 2f			ld de, .closepar 
2ef2					 
2ef2					if DEBUG_FORTH_WORDS 
2ef2						DMARK ").." 
2ef2 f5				push af  
2ef3 3a 07 2f			ld a, (.dmark)  
2ef6 32 6e fe			ld (debug_mark),a  
2ef9 3a 08 2f			ld a, (.dmark+1)  
2efc 32 6f fe			ld (debug_mark+1),a  
2eff 3a 09 2f			ld a, (.dmark+2)  
2f02 32 70 fe			ld (debug_mark+2),a  
2f05 18 03			jr .pastdmark  
2f07 ..			.dmark: db ").."  
2f0a f1			.pastdmark: pop af  
2f0b			endm  
# End of macro DMARK
2f0b						CALLMONITOR 
2f0b cd f3 18			call break_point_state  
2f0e				endm  
# End of macro CALLMONITOR
2f0e					endif 
2f0e cd 28 24			call findnexttok  
2f11			 
2f11					if DEBUG_FORTH_WORDS 
2f11						DMARK "IF5" 
2f11 f5				push af  
2f12 3a 26 2f			ld a, (.dmark)  
2f15 32 6e fe			ld (debug_mark),a  
2f18 3a 27 2f			ld a, (.dmark+1)  
2f1b 32 6f fe			ld (debug_mark+1),a  
2f1e 3a 28 2f			ld a, (.dmark+2)  
2f21 32 70 fe			ld (debug_mark+2),a  
2f24 18 03			jr .pastdmark  
2f26 ..			.dmark: db "IF5"  
2f29 f1			.pastdmark: pop af  
2f2a			endm  
# End of macro DMARK
2f2a						CALLMONITOR 
2f2a cd f3 18			call break_point_state  
2f2d				endm  
# End of macro CALLMONITOR
2f2d					endif 
2f2d				; replace below with ) exec using tok_ptr 
2f2d 22 c9 f4			ld (os_tok_ptr), hl 
2f30 c3 9e 23			jp exec1 
2f33			 
2f33 .. 00			.closepar:   db ")",0 
2f35			 
2f35				       NEXTW 
2f35 c3 0d 23			jp macro_next 
2f38				endm 
# End of macro NEXTW
2f38			.COMC: 
2f38				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2f38 6f				db WORD_SYS_CORE+91             
2f39 41 2f			dw .SCRATCH            
2f3b 02				db 1 + 1 
2f3c .. 00			db ")",0              
2f3e				endm 
# End of macro CWHEAD
2f3e			; | ) ( -- )  End of comment |  DONE  
2f3e				       NEXTW 
2f3e c3 0d 23			jp macro_next 
2f41				endm 
# End of macro NEXTW
2f41			 
2f41			.SCRATCH: 
2f41				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2f41 6f				db WORD_SYS_CORE+91             
2f42 7c 2f			dw .INC            
2f44 08				db 7 + 1 
2f45 .. 00			db "SCRATCH",0              
2f4d				endm 
# End of macro CWHEAD
2f4d			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2f4d			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2f4d			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2f4d			; | |  
2f4d			; | | e.g.    : score $00 scratch ; 
2f4d			; | |  
2f4d			; | | $00 score ! 
2f4d			; | | $01 score +! 
2f4d			; | |  
2f4d			; | | e.g.   : varword $0a scratch ;  
2f4d			; | | 
2f4d			; | | $8000 varword ! 
2f4d					if DEBUG_FORTH_WORDS_KEY 
2f4d						DMARK "SCR" 
2f4d f5				push af  
2f4e 3a 62 2f			ld a, (.dmark)  
2f51 32 6e fe			ld (debug_mark),a  
2f54 3a 63 2f			ld a, (.dmark+1)  
2f57 32 6f fe			ld (debug_mark+1),a  
2f5a 3a 64 2f			ld a, (.dmark+2)  
2f5d 32 70 fe			ld (debug_mark+2),a  
2f60 18 03			jr .pastdmark  
2f62 ..			.dmark: db "SCR"  
2f65 f1			.pastdmark: pop af  
2f66			endm  
# End of macro DMARK
2f66						CALLMONITOR 
2f66 cd f3 18			call break_point_state  
2f69				endm  
# End of macro CALLMONITOR
2f69					endif 
2f69			 
2f69					FORTH_DSP_VALUEHL 
2f69 cd 5e 21			call macro_dsp_valuehl 
2f6c				endm 
# End of macro FORTH_DSP_VALUEHL
2f6c				 
2f6c					FORTH_DSP_POP 
2f6c cd 16 22			call macro_forth_dsp_pop 
2f6f				endm 
# End of macro FORTH_DSP_POP
2f6f			 
2f6f 7d					ld a, l 
2f70 21 ed f6				ld hl, os_var_array 
2f73 cd 4c 0f				call addatohl 
2f76			 
2f76 cd 67 1f				call forth_push_numhl 
2f79			 
2f79				       NEXTW 
2f79 c3 0d 23			jp macro_next 
2f7c				endm 
# End of macro NEXTW
2f7c			 
2f7c			.INC: 
2f7c				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2f7c 6f				db WORD_SYS_CORE+91             
2f7d d0 2f			dw .DEC            
2f7f 03				db 2 + 1 
2f80 .. 00			db "+!",0              
2f83				endm 
# End of macro CWHEAD
2f83			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2f83					if DEBUG_FORTH_WORDS_KEY 
2f83						DMARK "+s_" 
2f83 f5				push af  
2f84 3a 98 2f			ld a, (.dmark)  
2f87 32 6e fe			ld (debug_mark),a  
2f8a 3a 99 2f			ld a, (.dmark+1)  
2f8d 32 6f fe			ld (debug_mark+1),a  
2f90 3a 9a 2f			ld a, (.dmark+2)  
2f93 32 70 fe			ld (debug_mark+2),a  
2f96 18 03			jr .pastdmark  
2f98 ..			.dmark: db "+s_"  
2f9b f1			.pastdmark: pop af  
2f9c			endm  
# End of macro DMARK
2f9c						CALLMONITOR 
2f9c cd f3 18			call break_point_state  
2f9f				endm  
# End of macro CALLMONITOR
2f9f					endif 
2f9f			 
2f9f					FORTH_DSP_VALUEHL 
2f9f cd 5e 21			call macro_dsp_valuehl 
2fa2				endm 
# End of macro FORTH_DSP_VALUEHL
2fa2			 
2fa2 e5					push hl   ; save address 
2fa3			 
2fa3					FORTH_DSP_POP 
2fa3 cd 16 22			call macro_forth_dsp_pop 
2fa6				endm 
# End of macro FORTH_DSP_POP
2fa6			 
2fa6					FORTH_DSP_VALUEHL 
2fa6 cd 5e 21			call macro_dsp_valuehl 
2fa9				endm 
# End of macro FORTH_DSP_VALUEHL
2fa9			 
2fa9					FORTH_DSP_POP 
2fa9 cd 16 22			call macro_forth_dsp_pop 
2fac				endm 
# End of macro FORTH_DSP_POP
2fac			 
2fac					; hl contains value to add to byte at a 
2fac				 
2fac eb					ex de, hl 
2fad			 
2fad e1					pop hl 
2fae			 
2fae					if DEBUG_FORTH_WORDS 
2fae						DMARK "INC" 
2fae f5				push af  
2faf 3a c3 2f			ld a, (.dmark)  
2fb2 32 6e fe			ld (debug_mark),a  
2fb5 3a c4 2f			ld a, (.dmark+1)  
2fb8 32 6f fe			ld (debug_mark+1),a  
2fbb 3a c5 2f			ld a, (.dmark+2)  
2fbe 32 70 fe			ld (debug_mark+2),a  
2fc1 18 03			jr .pastdmark  
2fc3 ..			.dmark: db "INC"  
2fc6 f1			.pastdmark: pop af  
2fc7			endm  
# End of macro DMARK
2fc7						CALLMONITOR 
2fc7 cd f3 18			call break_point_state  
2fca				endm  
# End of macro CALLMONITOR
2fca					endif 
2fca			 
2fca 7e					ld a,(hl) 
2fcb 83					add e 
2fcc 77					ld (hl),a 
2fcd			 
2fcd			 
2fcd			 
2fcd				       NEXTW 
2fcd c3 0d 23			jp macro_next 
2fd0				endm 
# End of macro NEXTW
2fd0			 
2fd0			.DEC: 
2fd0				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2fd0 6f				db WORD_SYS_CORE+91             
2fd1 21 30			dw .INC2            
2fd3 03				db 2 + 1 
2fd4 .. 00			db "-!",0              
2fd7				endm 
# End of macro CWHEAD
2fd7			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2fd7					if DEBUG_FORTH_WORDS_KEY 
2fd7						DMARK "-s_" 
2fd7 f5				push af  
2fd8 3a ec 2f			ld a, (.dmark)  
2fdb 32 6e fe			ld (debug_mark),a  
2fde 3a ed 2f			ld a, (.dmark+1)  
2fe1 32 6f fe			ld (debug_mark+1),a  
2fe4 3a ee 2f			ld a, (.dmark+2)  
2fe7 32 70 fe			ld (debug_mark+2),a  
2fea 18 03			jr .pastdmark  
2fec ..			.dmark: db "-s_"  
2fef f1			.pastdmark: pop af  
2ff0			endm  
# End of macro DMARK
2ff0						CALLMONITOR 
2ff0 cd f3 18			call break_point_state  
2ff3				endm  
# End of macro CALLMONITOR
2ff3					endif 
2ff3			 
2ff3					FORTH_DSP_VALUEHL 
2ff3 cd 5e 21			call macro_dsp_valuehl 
2ff6				endm 
# End of macro FORTH_DSP_VALUEHL
2ff6			 
2ff6 e5					push hl   ; save address 
2ff7			 
2ff7					FORTH_DSP_POP 
2ff7 cd 16 22			call macro_forth_dsp_pop 
2ffa				endm 
# End of macro FORTH_DSP_POP
2ffa			 
2ffa					FORTH_DSP_VALUEHL 
2ffa cd 5e 21			call macro_dsp_valuehl 
2ffd				endm 
# End of macro FORTH_DSP_VALUEHL
2ffd			 
2ffd					; hl contains value to add to byte at a 
2ffd				 
2ffd eb					ex de, hl 
2ffe			 
2ffe e1					pop hl 
2fff			 
2fff					if DEBUG_FORTH_WORDS 
2fff						DMARK "DEC" 
2fff f5				push af  
3000 3a 14 30			ld a, (.dmark)  
3003 32 6e fe			ld (debug_mark),a  
3006 3a 15 30			ld a, (.dmark+1)  
3009 32 6f fe			ld (debug_mark+1),a  
300c 3a 16 30			ld a, (.dmark+2)  
300f 32 70 fe			ld (debug_mark+2),a  
3012 18 03			jr .pastdmark  
3014 ..			.dmark: db "DEC"  
3017 f1			.pastdmark: pop af  
3018			endm  
# End of macro DMARK
3018						CALLMONITOR 
3018 cd f3 18			call break_point_state  
301b				endm  
# End of macro CALLMONITOR
301b					endif 
301b			 
301b 7e					ld a,(hl) 
301c 93					sub e 
301d 77					ld (hl),a 
301e			 
301e			 
301e			 
301e				       NEXTW 
301e c3 0d 23			jp macro_next 
3021				endm 
# End of macro NEXTW
3021			 
3021			.INC2: 
3021				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
3021 6f				db WORD_SYS_CORE+91             
3022 cb 30			dw .DEC2            
3024 04				db 3 + 1 
3025 .. 00			db "+2!",0              
3029				endm 
# End of macro CWHEAD
3029			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3029			 
3029					if DEBUG_FORTH_WORDS_KEY 
3029						DMARK "+2s" 
3029 f5				push af  
302a 3a 3e 30			ld a, (.dmark)  
302d 32 6e fe			ld (debug_mark),a  
3030 3a 3f 30			ld a, (.dmark+1)  
3033 32 6f fe			ld (debug_mark+1),a  
3036 3a 40 30			ld a, (.dmark+2)  
3039 32 70 fe			ld (debug_mark+2),a  
303c 18 03			jr .pastdmark  
303e ..			.dmark: db "+2s"  
3041 f1			.pastdmark: pop af  
3042			endm  
# End of macro DMARK
3042						CALLMONITOR 
3042 cd f3 18			call break_point_state  
3045				endm  
# End of macro CALLMONITOR
3045					endif 
3045			 
3045					; Address 
3045			 
3045					FORTH_DSP_VALUEHL 
3045 cd 5e 21			call macro_dsp_valuehl 
3048				endm 
# End of macro FORTH_DSP_VALUEHL
3048			 
3048 e5					push hl    ; save address 
3049			 
3049					; load content into de 
3049			 
3049 5e					ld e,(hl) 
304a 23					inc hl 
304b 56					ld d, (hl) 
304c			 
304c					if DEBUG_FORTH_WORDS 
304c						DMARK "+2a" 
304c f5				push af  
304d 3a 61 30			ld a, (.dmark)  
3050 32 6e fe			ld (debug_mark),a  
3053 3a 62 30			ld a, (.dmark+1)  
3056 32 6f fe			ld (debug_mark+1),a  
3059 3a 63 30			ld a, (.dmark+2)  
305c 32 70 fe			ld (debug_mark+2),a  
305f 18 03			jr .pastdmark  
3061 ..			.dmark: db "+2a"  
3064 f1			.pastdmark: pop af  
3065			endm  
# End of macro DMARK
3065						CALLMONITOR 
3065 cd f3 18			call break_point_state  
3068				endm  
# End of macro CALLMONITOR
3068					endif 
3068			 
3068					FORTH_DSP_POP 
3068 cd 16 22			call macro_forth_dsp_pop 
306b				endm 
# End of macro FORTH_DSP_POP
306b			 
306b					; Get value to add 
306b			 
306b					FORTH_DSP_VALUE 
306b cd 47 21			call macro_forth_dsp_value 
306e				endm 
# End of macro FORTH_DSP_VALUE
306e			 
306e					if DEBUG_FORTH_WORDS 
306e						DMARK "+2v" 
306e f5				push af  
306f 3a 83 30			ld a, (.dmark)  
3072 32 6e fe			ld (debug_mark),a  
3075 3a 84 30			ld a, (.dmark+1)  
3078 32 6f fe			ld (debug_mark+1),a  
307b 3a 85 30			ld a, (.dmark+2)  
307e 32 70 fe			ld (debug_mark+2),a  
3081 18 03			jr .pastdmark  
3083 ..			.dmark: db "+2v"  
3086 f1			.pastdmark: pop af  
3087			endm  
# End of macro DMARK
3087						CALLMONITOR 
3087 cd f3 18			call break_point_state  
308a				endm  
# End of macro CALLMONITOR
308a					endif 
308a			 
308a 19					add hl, de 
308b			 
308b					if DEBUG_FORTH_WORDS 
308b						DMARK "+2+" 
308b f5				push af  
308c 3a a0 30			ld a, (.dmark)  
308f 32 6e fe			ld (debug_mark),a  
3092 3a a1 30			ld a, (.dmark+1)  
3095 32 6f fe			ld (debug_mark+1),a  
3098 3a a2 30			ld a, (.dmark+2)  
309b 32 70 fe			ld (debug_mark+2),a  
309e 18 03			jr .pastdmark  
30a0 ..			.dmark: db "+2+"  
30a3 f1			.pastdmark: pop af  
30a4			endm  
# End of macro DMARK
30a4						CALLMONITOR 
30a4 cd f3 18			call break_point_state  
30a7				endm  
# End of macro CALLMONITOR
30a7					endif 
30a7			 
30a7					; move result to de 
30a7			 
30a7 eb					ex de, hl 
30a8			 
30a8					; Address 
30a8			 
30a8 e1					pop hl 
30a9			 
30a9					; save it back 
30a9			 
30a9 73					ld (hl), e 
30aa 23					inc hl 
30ab 72					ld (hl), d 
30ac			 
30ac					if DEBUG_FORTH_WORDS 
30ac						DMARK "+2e" 
30ac f5				push af  
30ad 3a c1 30			ld a, (.dmark)  
30b0 32 6e fe			ld (debug_mark),a  
30b3 3a c2 30			ld a, (.dmark+1)  
30b6 32 6f fe			ld (debug_mark+1),a  
30b9 3a c3 30			ld a, (.dmark+2)  
30bc 32 70 fe			ld (debug_mark+2),a  
30bf 18 03			jr .pastdmark  
30c1 ..			.dmark: db "+2e"  
30c4 f1			.pastdmark: pop af  
30c5			endm  
# End of macro DMARK
30c5						CALLMONITOR 
30c5 cd f3 18			call break_point_state  
30c8				endm  
# End of macro CALLMONITOR
30c8					endif 
30c8			 
30c8			 
30c8			 
30c8			 
30c8			 
30c8				       NEXTW 
30c8 c3 0d 23			jp macro_next 
30cb				endm 
# End of macro NEXTW
30cb			 
30cb			.DEC2: 
30cb				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
30cb 6f				db WORD_SYS_CORE+91             
30cc 77 31			dw .GET2            
30ce 04				db 3 + 1 
30cf .. 00			db "-2!",0              
30d3				endm 
# End of macro CWHEAD
30d3			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
30d3			 
30d3			 
30d3					if DEBUG_FORTH_WORDS_KEY 
30d3						DMARK "-2s" 
30d3 f5				push af  
30d4 3a e8 30			ld a, (.dmark)  
30d7 32 6e fe			ld (debug_mark),a  
30da 3a e9 30			ld a, (.dmark+1)  
30dd 32 6f fe			ld (debug_mark+1),a  
30e0 3a ea 30			ld a, (.dmark+2)  
30e3 32 70 fe			ld (debug_mark+2),a  
30e6 18 03			jr .pastdmark  
30e8 ..			.dmark: db "-2s"  
30eb f1			.pastdmark: pop af  
30ec			endm  
# End of macro DMARK
30ec						CALLMONITOR 
30ec cd f3 18			call break_point_state  
30ef				endm  
# End of macro CALLMONITOR
30ef					endif 
30ef			 
30ef					; Address 
30ef			 
30ef					FORTH_DSP_VALUEHL 
30ef cd 5e 21			call macro_dsp_valuehl 
30f2				endm 
# End of macro FORTH_DSP_VALUEHL
30f2			 
30f2 e5					push hl    ; save address 
30f3			 
30f3					; load content into de 
30f3			 
30f3 5e					ld e,(hl) 
30f4 23					inc hl 
30f5 56					ld d, (hl) 
30f6			 
30f6					if DEBUG_FORTH_WORDS 
30f6						DMARK "-2a" 
30f6 f5				push af  
30f7 3a 0b 31			ld a, (.dmark)  
30fa 32 6e fe			ld (debug_mark),a  
30fd 3a 0c 31			ld a, (.dmark+1)  
3100 32 6f fe			ld (debug_mark+1),a  
3103 3a 0d 31			ld a, (.dmark+2)  
3106 32 70 fe			ld (debug_mark+2),a  
3109 18 03			jr .pastdmark  
310b ..			.dmark: db "-2a"  
310e f1			.pastdmark: pop af  
310f			endm  
# End of macro DMARK
310f						CALLMONITOR 
310f cd f3 18			call break_point_state  
3112				endm  
# End of macro CALLMONITOR
3112					endif 
3112			 
3112					FORTH_DSP_POP 
3112 cd 16 22			call macro_forth_dsp_pop 
3115				endm 
# End of macro FORTH_DSP_POP
3115			 
3115					; Get value to remove 
3115			 
3115					FORTH_DSP_VALUE 
3115 cd 47 21			call macro_forth_dsp_value 
3118				endm 
# End of macro FORTH_DSP_VALUE
3118			 
3118					if DEBUG_FORTH_WORDS 
3118						DMARK "-2v" 
3118 f5				push af  
3119 3a 2d 31			ld a, (.dmark)  
311c 32 6e fe			ld (debug_mark),a  
311f 3a 2e 31			ld a, (.dmark+1)  
3122 32 6f fe			ld (debug_mark+1),a  
3125 3a 2f 31			ld a, (.dmark+2)  
3128 32 70 fe			ld (debug_mark+2),a  
312b 18 03			jr .pastdmark  
312d ..			.dmark: db "-2v"  
3130 f1			.pastdmark: pop af  
3131			endm  
# End of macro DMARK
3131						CALLMONITOR 
3131 cd f3 18			call break_point_state  
3134				endm  
# End of macro CALLMONITOR
3134					endif 
3134			 
3134 eb					ex de, hl 
3135 ed 52				sbc hl, de 
3137			 
3137					if DEBUG_FORTH_WORDS 
3137						DMARK "-2d" 
3137 f5				push af  
3138 3a 4c 31			ld a, (.dmark)  
313b 32 6e fe			ld (debug_mark),a  
313e 3a 4d 31			ld a, (.dmark+1)  
3141 32 6f fe			ld (debug_mark+1),a  
3144 3a 4e 31			ld a, (.dmark+2)  
3147 32 70 fe			ld (debug_mark+2),a  
314a 18 03			jr .pastdmark  
314c ..			.dmark: db "-2d"  
314f f1			.pastdmark: pop af  
3150			endm  
# End of macro DMARK
3150						CALLMONITOR 
3150 cd f3 18			call break_point_state  
3153				endm  
# End of macro CALLMONITOR
3153					endif 
3153			 
3153					; move result to de 
3153			 
3153 eb					ex de, hl 
3154			 
3154					; Address 
3154			 
3154 e1					pop hl 
3155			 
3155					; save it back 
3155			 
3155 73					ld (hl), e 
3156 23					inc hl 
3157 72					ld (hl), d 
3158			 
3158					if DEBUG_FORTH_WORDS 
3158						DMARK "-2e" 
3158 f5				push af  
3159 3a 6d 31			ld a, (.dmark)  
315c 32 6e fe			ld (debug_mark),a  
315f 3a 6e 31			ld a, (.dmark+1)  
3162 32 6f fe			ld (debug_mark+1),a  
3165 3a 6f 31			ld a, (.dmark+2)  
3168 32 70 fe			ld (debug_mark+2),a  
316b 18 03			jr .pastdmark  
316d ..			.dmark: db "-2e"  
3170 f1			.pastdmark: pop af  
3171			endm  
# End of macro DMARK
3171						CALLMONITOR 
3171 cd f3 18			call break_point_state  
3174				endm  
# End of macro CALLMONITOR
3174					endif 
3174			 
3174			 
3174			 
3174			 
3174			 
3174				       NEXTW 
3174 c3 0d 23			jp macro_next 
3177				endm 
# End of macro NEXTW
3177			.GET2: 
3177				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3177 6f				db WORD_SYS_CORE+91             
3178 a7 31			dw .BANG2            
317a 03				db 2 + 1 
317b .. 00			db "2@",0              
317e				endm 
# End of macro CWHEAD
317e			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
317e					if DEBUG_FORTH_WORDS_KEY 
317e						DMARK "2A_" 
317e f5				push af  
317f 3a 93 31			ld a, (.dmark)  
3182 32 6e fe			ld (debug_mark),a  
3185 3a 94 31			ld a, (.dmark+1)  
3188 32 6f fe			ld (debug_mark+1),a  
318b 3a 95 31			ld a, (.dmark+2)  
318e 32 70 fe			ld (debug_mark+2),a  
3191 18 03			jr .pastdmark  
3193 ..			.dmark: db "2A_"  
3196 f1			.pastdmark: pop af  
3197			endm  
# End of macro DMARK
3197						CALLMONITOR 
3197 cd f3 18			call break_point_state  
319a				endm  
# End of macro CALLMONITOR
319a					endif 
319a			 
319a					FORTH_DSP_VALUEHL 
319a cd 5e 21			call macro_dsp_valuehl 
319d				endm 
# End of macro FORTH_DSP_VALUEHL
319d			 
319d 5e					ld e, (hl) 
319e 23					inc hl 
319f 56					ld d, (hl) 
31a0			 
31a0 eb					ex de, hl 
31a1			 
31a1 cd 67 1f				call forth_push_numhl 
31a4			 
31a4				       NEXTW 
31a4 c3 0d 23			jp macro_next 
31a7				endm 
# End of macro NEXTW
31a7			.BANG2: 
31a7				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
31a7 6f				db WORD_SYS_CORE+91             
31a8 df 31			dw .CONFIG            
31aa 03				db 2 + 1 
31ab .. 00			db "2!",0              
31ae				endm 
# End of macro CWHEAD
31ae			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
31ae					if DEBUG_FORTH_WORDS_KEY 
31ae						DMARK "2S_" 
31ae f5				push af  
31af 3a c3 31			ld a, (.dmark)  
31b2 32 6e fe			ld (debug_mark),a  
31b5 3a c4 31			ld a, (.dmark+1)  
31b8 32 6f fe			ld (debug_mark+1),a  
31bb 3a c5 31			ld a, (.dmark+2)  
31be 32 70 fe			ld (debug_mark+2),a  
31c1 18 03			jr .pastdmark  
31c3 ..			.dmark: db "2S_"  
31c6 f1			.pastdmark: pop af  
31c7			endm  
# End of macro DMARK
31c7						CALLMONITOR 
31c7 cd f3 18			call break_point_state  
31ca				endm  
# End of macro CALLMONITOR
31ca					endif 
31ca			 
31ca					FORTH_DSP_VALUEHL 
31ca cd 5e 21			call macro_dsp_valuehl 
31cd				endm 
# End of macro FORTH_DSP_VALUEHL
31cd			 
31cd e5					push hl   ; save address 
31ce			 
31ce			 
31ce					FORTH_DSP_POP 
31ce cd 16 22			call macro_forth_dsp_pop 
31d1				endm 
# End of macro FORTH_DSP_POP
31d1			 
31d1					 
31d1					FORTH_DSP_VALUEHL 
31d1 cd 5e 21			call macro_dsp_valuehl 
31d4				endm 
# End of macro FORTH_DSP_VALUEHL
31d4			 
31d4					FORTH_DSP_POP 
31d4 cd 16 22			call macro_forth_dsp_pop 
31d7				endm 
# End of macro FORTH_DSP_POP
31d7			 
31d7 eb					ex de, hl    ; value now in de 
31d8			 
31d8 e1					pop hl 
31d9			 
31d9 73					ld (hl), e 
31da			 
31da 23					inc hl 
31db			 
31db 72					ld (hl), d 
31dc			 
31dc			 
31dc				       NEXTW 
31dc c3 0d 23			jp macro_next 
31df				endm 
# End of macro NEXTW
31df			.CONFIG: 
31df				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
31df 6f				db WORD_SYS_CORE+91             
31e0 f0 31			dw .ENDCORE            
31e2 07				db 6 + 1 
31e3 .. 00			db "CONFIG",0              
31ea				endm 
# End of macro CWHEAD
31ea			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
31ea			 
31ea cd d6 15				call config 
31ed					NEXTW 
31ed c3 0d 23			jp macro_next 
31f0				endm 
# End of macro NEXTW
31f0			.ENDCORE: 
31f0			 
31f0			; eof 
31f0			 
31f0			 
# End of file forth_words_core.asm
31f0			include "forth_words_flow.asm" 
31f0			 
31f0			; | ## Program Flow Words 
31f0			 
31f0			.IF: 
31f0				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
31f0 1e				db WORD_SYS_CORE+10             
31f1 e5 32			dw .THEN            
31f3 03				db 2 + 1 
31f4 .. 00			db "IF",0              
31f7				endm 
# End of macro CWHEAD
31f7			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
31f7			; 
31f7					if DEBUG_FORTH_WORDS_KEY 
31f7						DMARK "IF." 
31f7 f5				push af  
31f8 3a 0c 32			ld a, (.dmark)  
31fb 32 6e fe			ld (debug_mark),a  
31fe 3a 0d 32			ld a, (.dmark+1)  
3201 32 6f fe			ld (debug_mark+1),a  
3204 3a 0e 32			ld a, (.dmark+2)  
3207 32 70 fe			ld (debug_mark+2),a  
320a 18 03			jr .pastdmark  
320c ..			.dmark: db "IF."  
320f f1			.pastdmark: pop af  
3210			endm  
# End of macro DMARK
3210						CALLMONITOR 
3210 cd f3 18			call break_point_state  
3213				endm  
# End of macro CALLMONITOR
3213					endif 
3213			; eval TOS 
3213			 
3213				FORTH_DSP_VALUEHL 
3213 cd 5e 21			call macro_dsp_valuehl 
3216				endm 
# End of macro FORTH_DSP_VALUEHL
3216			 
3216			;	push hl 
3216				FORTH_DSP_POP 
3216 cd 16 22			call macro_forth_dsp_pop 
3219				endm 
# End of macro FORTH_DSP_POP
3219			;	pop hl 
3219			 
3219					if DEBUG_FORTH_WORDS 
3219						DMARK "IF1" 
3219 f5				push af  
321a 3a 2e 32			ld a, (.dmark)  
321d 32 6e fe			ld (debug_mark),a  
3220 3a 2f 32			ld a, (.dmark+1)  
3223 32 6f fe			ld (debug_mark+1),a  
3226 3a 30 32			ld a, (.dmark+2)  
3229 32 70 fe			ld (debug_mark+2),a  
322c 18 03			jr .pastdmark  
322e ..			.dmark: db "IF1"  
3231 f1			.pastdmark: pop af  
3232			endm  
# End of macro DMARK
3232						CALLMONITOR 
3232 cd f3 18			call break_point_state  
3235				endm  
# End of macro CALLMONITOR
3235					endif 
3235 b7				or a        ; clear carry flag 
3236 11 00 00			ld de, 0 
3239 eb				ex de,hl 
323a ed 52			sbc hl, de 
323c c2 c6 32			jp nz, .iftrue 
323f			 
323f					if DEBUG_FORTH_WORDS 
323f						DMARK "IF2" 
323f f5				push af  
3240 3a 54 32			ld a, (.dmark)  
3243 32 6e fe			ld (debug_mark),a  
3246 3a 55 32			ld a, (.dmark+1)  
3249 32 6f fe			ld (debug_mark+1),a  
324c 3a 56 32			ld a, (.dmark+2)  
324f 32 70 fe			ld (debug_mark+2),a  
3252 18 03			jr .pastdmark  
3254 ..			.dmark: db "IF2"  
3257 f1			.pastdmark: pop af  
3258			endm  
# End of macro DMARK
3258						CALLMONITOR 
3258 cd f3 18			call break_point_state  
325b				endm  
# End of macro CALLMONITOR
325b					endif 
325b			 
325b			; if not true then skip to THEN 
325b			 
325b				; TODO get tok_ptr 
325b				; TODO consume toks until we get to THEN 
325b			 
325b 2a c9 f4			ld hl, (os_tok_ptr) 
325e					if DEBUG_FORTH_WORDS 
325e						DMARK "IF3" 
325e f5				push af  
325f 3a 73 32			ld a, (.dmark)  
3262 32 6e fe			ld (debug_mark),a  
3265 3a 74 32			ld a, (.dmark+1)  
3268 32 6f fe			ld (debug_mark+1),a  
326b 3a 75 32			ld a, (.dmark+2)  
326e 32 70 fe			ld (debug_mark+2),a  
3271 18 03			jr .pastdmark  
3273 ..			.dmark: db "IF3"  
3276 f1			.pastdmark: pop af  
3277			endm  
# End of macro DMARK
3277						CALLMONITOR 
3277 cd f3 18			call break_point_state  
327a				endm  
# End of macro CALLMONITOR
327a						 
327a					endif 
327a 11 c1 32			ld de, .ifthen 
327d					if DEBUG_FORTH_WORDS 
327d						DMARK "IF4" 
327d f5				push af  
327e 3a 92 32			ld a, (.dmark)  
3281 32 6e fe			ld (debug_mark),a  
3284 3a 93 32			ld a, (.dmark+1)  
3287 32 6f fe			ld (debug_mark+1),a  
328a 3a 94 32			ld a, (.dmark+2)  
328d 32 70 fe			ld (debug_mark+2),a  
3290 18 03			jr .pastdmark  
3292 ..			.dmark: db "IF4"  
3295 f1			.pastdmark: pop af  
3296			endm  
# End of macro DMARK
3296						CALLMONITOR 
3296 cd f3 18			call break_point_state  
3299				endm  
# End of macro CALLMONITOR
3299					endif 
3299 cd 28 24			call findnexttok  
329c			 
329c					if DEBUG_FORTH_WORDS 
329c						DMARK "IF5" 
329c f5				push af  
329d 3a b1 32			ld a, (.dmark)  
32a0 32 6e fe			ld (debug_mark),a  
32a3 3a b2 32			ld a, (.dmark+1)  
32a6 32 6f fe			ld (debug_mark+1),a  
32a9 3a b3 32			ld a, (.dmark+2)  
32ac 32 70 fe			ld (debug_mark+2),a  
32af 18 03			jr .pastdmark  
32b1 ..			.dmark: db "IF5"  
32b4 f1			.pastdmark: pop af  
32b5			endm  
# End of macro DMARK
32b5						CALLMONITOR 
32b5 cd f3 18			call break_point_state  
32b8				endm  
# End of macro CALLMONITOR
32b8					endif 
32b8				; TODO replace below with ; exec using tok_ptr 
32b8 22 c9 f4			ld (os_tok_ptr), hl 
32bb c3 9e 23			jp exec1 
32be				NEXTW 
32be c3 0d 23			jp macro_next 
32c1				endm 
# End of macro NEXTW
32c1			 
32c1 .. 00		.ifthen:  db "THEN",0 
32c6			 
32c6			.iftrue:		 
32c6				; Exec next words normally 
32c6			 
32c6				; if true then exec following IF as normal 
32c6					if DEBUG_FORTH_WORDS 
32c6						DMARK "IFT" 
32c6 f5				push af  
32c7 3a db 32			ld a, (.dmark)  
32ca 32 6e fe			ld (debug_mark),a  
32cd 3a dc 32			ld a, (.dmark+1)  
32d0 32 6f fe			ld (debug_mark+1),a  
32d3 3a dd 32			ld a, (.dmark+2)  
32d6 32 70 fe			ld (debug_mark+2),a  
32d9 18 03			jr .pastdmark  
32db ..			.dmark: db "IFT"  
32de f1			.pastdmark: pop af  
32df			endm  
# End of macro DMARK
32df						CALLMONITOR 
32df cd f3 18			call break_point_state  
32e2				endm  
# End of macro CALLMONITOR
32e2					endif 
32e2			 
32e2					NEXTW 
32e2 c3 0d 23			jp macro_next 
32e5				endm 
# End of macro NEXTW
32e5			.THEN: 
32e5				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
32e5 1f				db WORD_SYS_CORE+11             
32e6 0d 33			dw .ELSE            
32e8 05				db 4 + 1 
32e9 .. 00			db "THEN",0              
32ee				endm 
# End of macro CWHEAD
32ee			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
32ee					if DEBUG_FORTH_WORDS_KEY 
32ee						DMARK "THN" 
32ee f5				push af  
32ef 3a 03 33			ld a, (.dmark)  
32f2 32 6e fe			ld (debug_mark),a  
32f5 3a 04 33			ld a, (.dmark+1)  
32f8 32 6f fe			ld (debug_mark+1),a  
32fb 3a 05 33			ld a, (.dmark+2)  
32fe 32 70 fe			ld (debug_mark+2),a  
3301 18 03			jr .pastdmark  
3303 ..			.dmark: db "THN"  
3306 f1			.pastdmark: pop af  
3307			endm  
# End of macro DMARK
3307						CALLMONITOR 
3307 cd f3 18			call break_point_state  
330a				endm  
# End of macro CALLMONITOR
330a					endif 
330a					NEXTW 
330a c3 0d 23			jp macro_next 
330d				endm 
# End of macro NEXTW
330d			.ELSE: 
330d				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
330d 20				db WORD_SYS_CORE+12             
330e 35 33			dw .DO            
3310 03				db 2 + 1 
3311 .. 00			db "ELSE",0              
3316				endm 
# End of macro CWHEAD
3316			; | ELSE ( -- ) Not supported - does nothing | TODO 
3316			 
3316					if DEBUG_FORTH_WORDS_KEY 
3316						DMARK "ELS" 
3316 f5				push af  
3317 3a 2b 33			ld a, (.dmark)  
331a 32 6e fe			ld (debug_mark),a  
331d 3a 2c 33			ld a, (.dmark+1)  
3320 32 6f fe			ld (debug_mark+1),a  
3323 3a 2d 33			ld a, (.dmark+2)  
3326 32 70 fe			ld (debug_mark+2),a  
3329 18 03			jr .pastdmark  
332b ..			.dmark: db "ELS"  
332e f1			.pastdmark: pop af  
332f			endm  
# End of macro DMARK
332f						CALLMONITOR 
332f cd f3 18			call break_point_state  
3332				endm  
# End of macro CALLMONITOR
3332					endif 
3332			 
3332			 
3332					NEXTW 
3332 c3 0d 23			jp macro_next 
3335				endm 
# End of macro NEXTW
3335			.DO: 
3335				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3335 21				db WORD_SYS_CORE+13             
3336 5c 34			dw .LOOP            
3338 03				db 2 + 1 
3339 .. 00			db "DO",0              
333c				endm 
# End of macro CWHEAD
333c			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
333c			 
333c					if DEBUG_FORTH_WORDS_KEY 
333c						DMARK "DO." 
333c f5				push af  
333d 3a 51 33			ld a, (.dmark)  
3340 32 6e fe			ld (debug_mark),a  
3343 3a 52 33			ld a, (.dmark+1)  
3346 32 6f fe			ld (debug_mark+1),a  
3349 3a 53 33			ld a, (.dmark+2)  
334c 32 70 fe			ld (debug_mark+2),a  
334f 18 03			jr .pastdmark  
3351 ..			.dmark: db "DO."  
3354 f1			.pastdmark: pop af  
3355			endm  
# End of macro DMARK
3355						CALLMONITOR 
3355 cd f3 18			call break_point_state  
3358				endm  
# End of macro CALLMONITOR
3358					endif 
3358			;  push pc to rsp stack past the DO 
3358			 
3358 2a c9 f4				ld hl, (os_tok_ptr) 
335b 23					inc hl   ; D 
335c 23					inc hl  ; O 
335d 23					inc hl   ; null 
335e					if DEBUG_FORTH_WORDS 
335e						DMARK "DO2" 
335e f5				push af  
335f 3a 73 33			ld a, (.dmark)  
3362 32 6e fe			ld (debug_mark),a  
3365 3a 74 33			ld a, (.dmark+1)  
3368 32 6f fe			ld (debug_mark+1),a  
336b 3a 75 33			ld a, (.dmark+2)  
336e 32 70 fe			ld (debug_mark+2),a  
3371 18 03			jr .pastdmark  
3373 ..			.dmark: db "DO2"  
3376 f1			.pastdmark: pop af  
3377			endm  
# End of macro DMARK
3377						CALLMONITOR 
3377 cd f3 18			call break_point_state  
337a				endm  
# End of macro CALLMONITOR
337a					endif 
337a					FORTH_RSP_NEXT 
337a cd 0e 1f			call macro_forth_rsp_next 
337d				endm 
# End of macro FORTH_RSP_NEXT
337d					if DEBUG_FORTH_WORDS 
337d						DMARK "DO3" 
337d f5				push af  
337e 3a 92 33			ld a, (.dmark)  
3381 32 6e fe			ld (debug_mark),a  
3384 3a 93 33			ld a, (.dmark+1)  
3387 32 6f fe			ld (debug_mark+1),a  
338a 3a 94 33			ld a, (.dmark+2)  
338d 32 70 fe			ld (debug_mark+2),a  
3390 18 03			jr .pastdmark  
3392 ..			.dmark: db "DO3"  
3395 f1			.pastdmark: pop af  
3396			endm  
# End of macro DMARK
3396						CALLMONITOR 
3396 cd f3 18			call break_point_state  
3399				endm  
# End of macro CALLMONITOR
3399					endif 
3399			 
3399					;if DEBUG_FORTH_WORDS 
3399				;		push hl 
3399			;		endif  
3399			 
3399			; get counters from data stack 
3399			 
3399			 
3399					FORTH_DSP_VALUEHL 
3399 cd 5e 21			call macro_dsp_valuehl 
339c				endm 
# End of macro FORTH_DSP_VALUEHL
339c e5					push hl		 ; hl now has starting counter which needs to be tos 
339d			 
339d					if DEBUG_FORTH_WORDS 
339d						DMARK "DO4" 
339d f5				push af  
339e 3a b2 33			ld a, (.dmark)  
33a1 32 6e fe			ld (debug_mark),a  
33a4 3a b3 33			ld a, (.dmark+1)  
33a7 32 6f fe			ld (debug_mark+1),a  
33aa 3a b4 33			ld a, (.dmark+2)  
33ad 32 70 fe			ld (debug_mark+2),a  
33b0 18 03			jr .pastdmark  
33b2 ..			.dmark: db "DO4"  
33b5 f1			.pastdmark: pop af  
33b6			endm  
# End of macro DMARK
33b6						CALLMONITOR 
33b6 cd f3 18			call break_point_state  
33b9				endm  
# End of macro CALLMONITOR
33b9					endif 
33b9					FORTH_DSP_POP 
33b9 cd 16 22			call macro_forth_dsp_pop 
33bc				endm 
# End of macro FORTH_DSP_POP
33bc			 
33bc					if DEBUG_FORTH_WORDS 
33bc						DMARK "DO5" 
33bc f5				push af  
33bd 3a d1 33			ld a, (.dmark)  
33c0 32 6e fe			ld (debug_mark),a  
33c3 3a d2 33			ld a, (.dmark+1)  
33c6 32 6f fe			ld (debug_mark+1),a  
33c9 3a d3 33			ld a, (.dmark+2)  
33cc 32 70 fe			ld (debug_mark+2),a  
33cf 18 03			jr .pastdmark  
33d1 ..			.dmark: db "DO5"  
33d4 f1			.pastdmark: pop af  
33d5			endm  
# End of macro DMARK
33d5						CALLMONITOR 
33d5 cd f3 18			call break_point_state  
33d8				endm  
# End of macro CALLMONITOR
33d8					endif 
33d8			 
33d8					FORTH_DSP_VALUEHL 
33d8 cd 5e 21			call macro_dsp_valuehl 
33db				endm 
# End of macro FORTH_DSP_VALUEHL
33db			;		push hl		 ; hl now has starting limit counter 
33db			 
33db					if DEBUG_FORTH_WORDS 
33db						DMARK "DO6" 
33db f5				push af  
33dc 3a f0 33			ld a, (.dmark)  
33df 32 6e fe			ld (debug_mark),a  
33e2 3a f1 33			ld a, (.dmark+1)  
33e5 32 6f fe			ld (debug_mark+1),a  
33e8 3a f2 33			ld a, (.dmark+2)  
33eb 32 70 fe			ld (debug_mark+2),a  
33ee 18 03			jr .pastdmark  
33f0 ..			.dmark: db "DO6"  
33f3 f1			.pastdmark: pop af  
33f4			endm  
# End of macro DMARK
33f4						CALLMONITOR 
33f4 cd f3 18			call break_point_state  
33f7				endm  
# End of macro CALLMONITOR
33f7					endif 
33f7					FORTH_DSP_POP 
33f7 cd 16 22			call macro_forth_dsp_pop 
33fa				endm 
# End of macro FORTH_DSP_POP
33fa			 
33fa			; put counters on the loop stack 
33fa			 
33fa			;		pop hl			 ; limit counter 
33fa d1					pop de			; start counter 
33fb			 
33fb					; push limit counter 
33fb			 
33fb					if DEBUG_FORTH_WORDS 
33fb						DMARK "DO7" 
33fb f5				push af  
33fc 3a 10 34			ld a, (.dmark)  
33ff 32 6e fe			ld (debug_mark),a  
3402 3a 11 34			ld a, (.dmark+1)  
3405 32 6f fe			ld (debug_mark+1),a  
3408 3a 12 34			ld a, (.dmark+2)  
340b 32 70 fe			ld (debug_mark+2),a  
340e 18 03			jr .pastdmark  
3410 ..			.dmark: db "DO7"  
3413 f1			.pastdmark: pop af  
3414			endm  
# End of macro DMARK
3414						CALLMONITOR 
3414 cd f3 18			call break_point_state  
3417				endm  
# End of macro CALLMONITOR
3417					endif 
3417					FORTH_LOOP_NEXT 
3417 cd 8f 21			call macro_forth_loop_next 
341a				endm 
# End of macro FORTH_LOOP_NEXT
341a			 
341a					; push start counter 
341a			 
341a eb					ex de, hl 
341b					if DEBUG_FORTH_WORDS 
341b						DMARK "DO7" 
341b f5				push af  
341c 3a 30 34			ld a, (.dmark)  
341f 32 6e fe			ld (debug_mark),a  
3422 3a 31 34			ld a, (.dmark+1)  
3425 32 6f fe			ld (debug_mark+1),a  
3428 3a 32 34			ld a, (.dmark+2)  
342b 32 70 fe			ld (debug_mark+2),a  
342e 18 03			jr .pastdmark  
3430 ..			.dmark: db "DO7"  
3433 f1			.pastdmark: pop af  
3434			endm  
# End of macro DMARK
3434						CALLMONITOR 
3434 cd f3 18			call break_point_state  
3437				endm  
# End of macro CALLMONITOR
3437					endif 
3437					FORTH_LOOP_NEXT 
3437 cd 8f 21			call macro_forth_loop_next 
343a				endm 
# End of macro FORTH_LOOP_NEXT
343a			 
343a			 
343a					; init first round of I counter 
343a			 
343a 22 ed f4				ld (os_current_i), hl 
343d			 
343d					if DEBUG_FORTH_WORDS 
343d						DMARK "DO8" 
343d f5				push af  
343e 3a 52 34			ld a, (.dmark)  
3441 32 6e fe			ld (debug_mark),a  
3444 3a 53 34			ld a, (.dmark+1)  
3447 32 6f fe			ld (debug_mark+1),a  
344a 3a 54 34			ld a, (.dmark+2)  
344d 32 70 fe			ld (debug_mark+2),a  
3450 18 03			jr .pastdmark  
3452 ..			.dmark: db "DO8"  
3455 f1			.pastdmark: pop af  
3456			endm  
# End of macro DMARK
3456						CALLMONITOR 
3456 cd f3 18			call break_point_state  
3459				endm  
# End of macro CALLMONITOR
3459					endif 
3459			 
3459					NEXTW 
3459 c3 0d 23			jp macro_next 
345c				endm 
# End of macro NEXTW
345c			.LOOP: 
345c				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
345c 22				db WORD_SYS_CORE+14             
345d 74 35			dw .I            
345f 05				db 4 + 1 
3460 .. 00			db "LOOP",0              
3465				endm 
# End of macro CWHEAD
3465			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3465			 
3465				; pop tos as current loop count to hl 
3465			 
3465				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3465			 
3465				FORTH_LOOP_TOS 
3465 cd c2 21			call macro_forth_loop_tos 
3468				endm 
# End of macro FORTH_LOOP_TOS
3468 e5				push hl 
3469			 
3469					if DEBUG_FORTH_WORDS_KEY 
3469						DMARK "LOP" 
3469 f5				push af  
346a 3a 7e 34			ld a, (.dmark)  
346d 32 6e fe			ld (debug_mark),a  
3470 3a 7f 34			ld a, (.dmark+1)  
3473 32 6f fe			ld (debug_mark+1),a  
3476 3a 80 34			ld a, (.dmark+2)  
3479 32 70 fe			ld (debug_mark+2),a  
347c 18 03			jr .pastdmark  
347e ..			.dmark: db "LOP"  
3481 f1			.pastdmark: pop af  
3482			endm  
# End of macro DMARK
3482						CALLMONITOR 
3482 cd f3 18			call break_point_state  
3485				endm  
# End of macro CALLMONITOR
3485					endif 
3485				; next item on the stack is the limit. get it 
3485			 
3485			 
3485				FORTH_LOOP_POP 
3485 cd cc 21			call macro_forth_loop_pop 
3488				endm 
# End of macro FORTH_LOOP_POP
3488			 
3488				FORTH_LOOP_TOS 
3488 cd c2 21			call macro_forth_loop_tos 
348b				endm 
# End of macro FORTH_LOOP_TOS
348b			 
348b d1				pop de		 ; de = i, hl = limit 
348c			 
348c					if DEBUG_FORTH_WORDS 
348c						DMARK "LP1" 
348c f5				push af  
348d 3a a1 34			ld a, (.dmark)  
3490 32 6e fe			ld (debug_mark),a  
3493 3a a2 34			ld a, (.dmark+1)  
3496 32 6f fe			ld (debug_mark+1),a  
3499 3a a3 34			ld a, (.dmark+2)  
349c 32 70 fe			ld (debug_mark+2),a  
349f 18 03			jr .pastdmark  
34a1 ..			.dmark: db "LP1"  
34a4 f1			.pastdmark: pop af  
34a5			endm  
# End of macro DMARK
34a5						CALLMONITOR 
34a5 cd f3 18			call break_point_state  
34a8				endm  
# End of macro CALLMONITOR
34a8					endif 
34a8			 
34a8				; go back to previous word 
34a8			 
34a8 d5				push de    ; save I for inc later 
34a9			 
34a9			 
34a9				; get limit 
34a9				;  is I at limit? 
34a9			 
34a9			 
34a9					if DEBUG_FORTH_WORDS 
34a9						DMARK "LP1" 
34a9 f5				push af  
34aa 3a be 34			ld a, (.dmark)  
34ad 32 6e fe			ld (debug_mark),a  
34b0 3a bf 34			ld a, (.dmark+1)  
34b3 32 6f fe			ld (debug_mark+1),a  
34b6 3a c0 34			ld a, (.dmark+2)  
34b9 32 70 fe			ld (debug_mark+2),a  
34bc 18 03			jr .pastdmark  
34be ..			.dmark: db "LP1"  
34c1 f1			.pastdmark: pop af  
34c2			endm  
# End of macro DMARK
34c2						CALLMONITOR 
34c2 cd f3 18			call break_point_state  
34c5				endm  
# End of macro CALLMONITOR
34c5					endif 
34c5			 
34c5 ed 52			sbc hl, de 
34c7			 
34c7			 
34c7				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
34c7			 
34c7 20 26				jr nz, .loopnotdone 
34c9			 
34c9 e1				pop hl   ; get rid of saved I 
34ca				FORTH_LOOP_POP     ; get rid of limit 
34ca cd cc 21			call macro_forth_loop_pop 
34cd				endm 
# End of macro FORTH_LOOP_POP
34cd			 
34cd				FORTH_RSP_POP     ; get rid of DO ptr 
34cd cd 2f 1f			call macro_forth_rsp_pop 
34d0				endm 
# End of macro FORTH_RSP_POP
34d0			 
34d0			if DEBUG_FORTH_WORDS 
34d0						DMARK "LP>" 
34d0 f5				push af  
34d1 3a e5 34			ld a, (.dmark)  
34d4 32 6e fe			ld (debug_mark),a  
34d7 3a e6 34			ld a, (.dmark+1)  
34da 32 6f fe			ld (debug_mark+1),a  
34dd 3a e7 34			ld a, (.dmark+2)  
34e0 32 70 fe			ld (debug_mark+2),a  
34e3 18 03			jr .pastdmark  
34e5 ..			.dmark: db "LP>"  
34e8 f1			.pastdmark: pop af  
34e9			endm  
# End of macro DMARK
34e9				CALLMONITOR 
34e9 cd f3 18			call break_point_state  
34ec				endm  
# End of macro CALLMONITOR
34ec			endif 
34ec			 
34ec					NEXTW 
34ec c3 0d 23			jp macro_next 
34ef				endm 
# End of macro NEXTW
34ef				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34ef			 
34ef			.loopnotdone: 
34ef			 
34ef e1				pop hl    ; get I 
34f0 23				inc hl 
34f1			 
34f1			   	; save new I 
34f1			 
34f1			 
34f1					; set I counter 
34f1			 
34f1 22 ed f4				ld (os_current_i), hl 
34f4			 
34f4					if DEBUG_FORTH_WORDS 
34f4						DMARK "LPN" 
34f4 f5				push af  
34f5 3a 09 35			ld a, (.dmark)  
34f8 32 6e fe			ld (debug_mark),a  
34fb 3a 0a 35			ld a, (.dmark+1)  
34fe 32 6f fe			ld (debug_mark+1),a  
3501 3a 0b 35			ld a, (.dmark+2)  
3504 32 70 fe			ld (debug_mark+2),a  
3507 18 03			jr .pastdmark  
3509 ..			.dmark: db "LPN"  
350c f1			.pastdmark: pop af  
350d			endm  
# End of macro DMARK
350d					CALLMONITOR 
350d cd f3 18			call break_point_state  
3510				endm  
# End of macro CALLMONITOR
3510					endif 
3510					 
3510				FORTH_LOOP_NEXT 
3510 cd 8f 21			call macro_forth_loop_next 
3513				endm 
# End of macro FORTH_LOOP_NEXT
3513			 
3513			 
3513					if DEBUG_FORTH_WORDS 
3513 eb						ex de,hl 
3514					endif 
3514			 
3514			;	; get DO ptr 
3514			; 
3514					if DEBUG_FORTH_WORDS 
3514						DMARK "LP7" 
3514 f5				push af  
3515 3a 29 35			ld a, (.dmark)  
3518 32 6e fe			ld (debug_mark),a  
351b 3a 2a 35			ld a, (.dmark+1)  
351e 32 6f fe			ld (debug_mark+1),a  
3521 3a 2b 35			ld a, (.dmark+2)  
3524 32 70 fe			ld (debug_mark+2),a  
3527 18 03			jr .pastdmark  
3529 ..			.dmark: db "LP7"  
352c f1			.pastdmark: pop af  
352d			endm  
# End of macro DMARK
352d					CALLMONITOR 
352d cd f3 18			call break_point_state  
3530				endm  
# End of macro CALLMONITOR
3530					endif 
3530				FORTH_RSP_TOS 
3530 cd 25 1f			call macro_forth_rsp_tos 
3533				endm 
# End of macro FORTH_RSP_TOS
3533			 
3533					if DEBUG_FORTH_WORDS 
3533						DMARK "LP8" 
3533 f5				push af  
3534 3a 48 35			ld a, (.dmark)  
3537 32 6e fe			ld (debug_mark),a  
353a 3a 49 35			ld a, (.dmark+1)  
353d 32 6f fe			ld (debug_mark+1),a  
3540 3a 4a 35			ld a, (.dmark+2)  
3543 32 70 fe			ld (debug_mark+2),a  
3546 18 03			jr .pastdmark  
3548 ..			.dmark: db "LP8"  
354b f1			.pastdmark: pop af  
354c			endm  
# End of macro DMARK
354c					CALLMONITOR 
354c cd f3 18			call break_point_state  
354f				endm  
# End of macro CALLMONITOR
354f					endif 
354f				;push hl 
354f			 
354f				; not going to DO any more 
354f				; get rid of the RSP pointer as DO will add it back in 
354f				;FORTH_RSP_POP 
354f				;pop hl 
354f			 
354f				;ld hl,(cli_ret_sp) 
354f				;ld e, (hl) 
354f				;inc hl 
354f				;ld d, (hl) 
354f				;ex de,hl 
354f 22 c9 f4			ld (os_tok_ptr), hl 
3552					if DEBUG_FORTH_WORDS 
3552						DMARK "LP<" 
3552 f5				push af  
3553 3a 67 35			ld a, (.dmark)  
3556 32 6e fe			ld (debug_mark),a  
3559 3a 68 35			ld a, (.dmark+1)  
355c 32 6f fe			ld (debug_mark+1),a  
355f 3a 69 35			ld a, (.dmark+2)  
3562 32 70 fe			ld (debug_mark+2),a  
3565 18 03			jr .pastdmark  
3567 ..			.dmark: db "LP<"  
356a f1			.pastdmark: pop af  
356b			endm  
# End of macro DMARK
356b					CALLMONITOR 
356b cd f3 18			call break_point_state  
356e				endm  
# End of macro CALLMONITOR
356e				endif 
356e c3 9e 23			jp exec1 
3571			 
3571					 
3571			 
3571			 
3571					NEXTW 
3571 c3 0d 23			jp macro_next 
3574				endm 
# End of macro NEXTW
3574			.I:  
3574			 
3574				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3574 5e				db WORD_SYS_CORE+74             
3575 9f 35			dw .DLOOP            
3577 02				db 1 + 1 
3578 .. 00			db "I",0              
357a				endm 
# End of macro CWHEAD
357a			; | I ( -- ) Current loop counter | DONE 
357a					if DEBUG_FORTH_WORDS_KEY 
357a						DMARK "I.." 
357a f5				push af  
357b 3a 8f 35			ld a, (.dmark)  
357e 32 6e fe			ld (debug_mark),a  
3581 3a 90 35			ld a, (.dmark+1)  
3584 32 6f fe			ld (debug_mark+1),a  
3587 3a 91 35			ld a, (.dmark+2)  
358a 32 70 fe			ld (debug_mark+2),a  
358d 18 03			jr .pastdmark  
358f ..			.dmark: db "I.."  
3592 f1			.pastdmark: pop af  
3593			endm  
# End of macro DMARK
3593						CALLMONITOR 
3593 cd f3 18			call break_point_state  
3596				endm  
# End of macro CALLMONITOR
3596					endif 
3596			 
3596 2a ed f4				ld hl,(os_current_i) 
3599 cd 67 1f				call forth_push_numhl 
359c			 
359c					NEXTW 
359c c3 0d 23			jp macro_next 
359f				endm 
# End of macro NEXTW
359f			.DLOOP: 
359f				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
359f 5f				db WORD_SYS_CORE+75             
35a0 80 36			dw .REPEAT            
35a2 06				db 5 + 1 
35a3 .. 00			db "-LOOP",0              
35a9				endm 
# End of macro CWHEAD
35a9			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
35a9				; pop tos as current loop count to hl 
35a9					if DEBUG_FORTH_WORDS_KEY 
35a9						DMARK "-LP" 
35a9 f5				push af  
35aa 3a be 35			ld a, (.dmark)  
35ad 32 6e fe			ld (debug_mark),a  
35b0 3a bf 35			ld a, (.dmark+1)  
35b3 32 6f fe			ld (debug_mark+1),a  
35b6 3a c0 35			ld a, (.dmark+2)  
35b9 32 70 fe			ld (debug_mark+2),a  
35bc 18 03			jr .pastdmark  
35be ..			.dmark: db "-LP"  
35c1 f1			.pastdmark: pop af  
35c2			endm  
# End of macro DMARK
35c2						CALLMONITOR 
35c2 cd f3 18			call break_point_state  
35c5				endm  
# End of macro CALLMONITOR
35c5					endif 
35c5			 
35c5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35c5			 
35c5				FORTH_LOOP_TOS 
35c5 cd c2 21			call macro_forth_loop_tos 
35c8				endm 
# End of macro FORTH_LOOP_TOS
35c8 e5				push hl 
35c9			 
35c9					if DEBUG_FORTH_WORDS 
35c9						DMARK "-LP" 
35c9 f5				push af  
35ca 3a de 35			ld a, (.dmark)  
35cd 32 6e fe			ld (debug_mark),a  
35d0 3a df 35			ld a, (.dmark+1)  
35d3 32 6f fe			ld (debug_mark+1),a  
35d6 3a e0 35			ld a, (.dmark+2)  
35d9 32 70 fe			ld (debug_mark+2),a  
35dc 18 03			jr .pastdmark  
35de ..			.dmark: db "-LP"  
35e1 f1			.pastdmark: pop af  
35e2			endm  
# End of macro DMARK
35e2						CALLMONITOR 
35e2 cd f3 18			call break_point_state  
35e5				endm  
# End of macro CALLMONITOR
35e5					endif 
35e5				; next item on the stack is the limit. get it 
35e5			 
35e5			 
35e5				FORTH_LOOP_POP 
35e5 cd cc 21			call macro_forth_loop_pop 
35e8				endm 
# End of macro FORTH_LOOP_POP
35e8			 
35e8				FORTH_LOOP_TOS 
35e8 cd c2 21			call macro_forth_loop_tos 
35eb				endm 
# End of macro FORTH_LOOP_TOS
35eb			 
35eb d1				pop de		 ; de = i, hl = limit 
35ec			 
35ec					if DEBUG_FORTH_WORDS 
35ec						DMARK "-L1" 
35ec f5				push af  
35ed 3a 01 36			ld a, (.dmark)  
35f0 32 6e fe			ld (debug_mark),a  
35f3 3a 02 36			ld a, (.dmark+1)  
35f6 32 6f fe			ld (debug_mark+1),a  
35f9 3a 03 36			ld a, (.dmark+2)  
35fc 32 70 fe			ld (debug_mark+2),a  
35ff 18 03			jr .pastdmark  
3601 ..			.dmark: db "-L1"  
3604 f1			.pastdmark: pop af  
3605			endm  
# End of macro DMARK
3605						CALLMONITOR 
3605 cd f3 18			call break_point_state  
3608				endm  
# End of macro CALLMONITOR
3608					endif 
3608			 
3608				; go back to previous word 
3608			 
3608 d5				push de    ; save I for inc later 
3609			 
3609			 
3609				; get limit 
3609				;  is I at limit? 
3609			 
3609			 
3609					if DEBUG_FORTH_WORDS 
3609						DMARK "-L1" 
3609 f5				push af  
360a 3a 1e 36			ld a, (.dmark)  
360d 32 6e fe			ld (debug_mark),a  
3610 3a 1f 36			ld a, (.dmark+1)  
3613 32 6f fe			ld (debug_mark+1),a  
3616 3a 20 36			ld a, (.dmark+2)  
3619 32 70 fe			ld (debug_mark+2),a  
361c 18 03			jr .pastdmark  
361e ..			.dmark: db "-L1"  
3621 f1			.pastdmark: pop af  
3622			endm  
# End of macro DMARK
3622						CALLMONITOR 
3622 cd f3 18			call break_point_state  
3625				endm  
# End of macro CALLMONITOR
3625					endif 
3625			 
3625 ed 52			sbc hl, de 
3627			 
3627			 
3627				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3627			 
3627 20 26				jr nz, .mloopnotdone 
3629			 
3629 e1				pop hl   ; get rid of saved I 
362a				FORTH_LOOP_POP     ; get rid of limit 
362a cd cc 21			call macro_forth_loop_pop 
362d				endm 
# End of macro FORTH_LOOP_POP
362d			 
362d				FORTH_RSP_POP     ; get rid of DO ptr 
362d cd 2f 1f			call macro_forth_rsp_pop 
3630				endm 
# End of macro FORTH_RSP_POP
3630			 
3630			if DEBUG_FORTH_WORDS 
3630						DMARK "-L>" 
3630 f5				push af  
3631 3a 45 36			ld a, (.dmark)  
3634 32 6e fe			ld (debug_mark),a  
3637 3a 46 36			ld a, (.dmark+1)  
363a 32 6f fe			ld (debug_mark+1),a  
363d 3a 47 36			ld a, (.dmark+2)  
3640 32 70 fe			ld (debug_mark+2),a  
3643 18 03			jr .pastdmark  
3645 ..			.dmark: db "-L>"  
3648 f1			.pastdmark: pop af  
3649			endm  
# End of macro DMARK
3649				CALLMONITOR 
3649 cd f3 18			call break_point_state  
364c				endm  
# End of macro CALLMONITOR
364c			endif 
364c			 
364c					NEXTW 
364c c3 0d 23			jp macro_next 
364f				endm 
# End of macro NEXTW
364f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
364f			 
364f			.mloopnotdone: 
364f			 
364f e1				pop hl    ; get I 
3650 2b				dec hl 
3651			 
3651			   	; save new I 
3651			 
3651			 
3651					; set I counter 
3651			 
3651 22 ed f4				ld (os_current_i), hl 
3654			 
3654					 
3654				FORTH_LOOP_NEXT 
3654 cd 8f 21			call macro_forth_loop_next 
3657				endm 
# End of macro FORTH_LOOP_NEXT
3657			 
3657			 
3657					if DEBUG_FORTH_WORDS 
3657 eb						ex de,hl 
3658					endif 
3658			 
3658			;	; get DO ptr 
3658			; 
3658				FORTH_RSP_TOS 
3658 cd 25 1f			call macro_forth_rsp_tos 
365b				endm 
# End of macro FORTH_RSP_TOS
365b			 
365b				;push hl 
365b			 
365b				; not going to DO any more 
365b				; get rid of the RSP pointer as DO will add it back in 
365b				;FORTH_RSP_POP 
365b				;pop hl 
365b			 
365b			 
365b 22 c9 f4			ld (os_tok_ptr), hl 
365e					if DEBUG_FORTH_WORDS 
365e						DMARK "-L<" 
365e f5				push af  
365f 3a 73 36			ld a, (.dmark)  
3662 32 6e fe			ld (debug_mark),a  
3665 3a 74 36			ld a, (.dmark+1)  
3668 32 6f fe			ld (debug_mark+1),a  
366b 3a 75 36			ld a, (.dmark+2)  
366e 32 70 fe			ld (debug_mark+2),a  
3671 18 03			jr .pastdmark  
3673 ..			.dmark: db "-L<"  
3676 f1			.pastdmark: pop af  
3677			endm  
# End of macro DMARK
3677					CALLMONITOR 
3677 cd f3 18			call break_point_state  
367a				endm  
# End of macro CALLMONITOR
367a				endif 
367a c3 9e 23			jp exec1 
367d			 
367d					 
367d			 
367d			 
367d			 
367d				NEXTW 
367d c3 0d 23			jp macro_next 
3680				endm 
# End of macro NEXTW
3680			 
3680			 
3680			 
3680			 
3680			.REPEAT: 
3680				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3680 71				db WORD_SYS_CORE+93             
3681 d3 36			dw .UNTIL            
3683 06				db 5 + 1 
3684 .. 00			db "REPEAT",0              
368b				endm 
# End of macro CWHEAD
368b			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
368b			;  push pc to rsp stack past the REPEAT 
368b					if DEBUG_FORTH_WORDS_KEY 
368b						DMARK "REP" 
368b f5				push af  
368c 3a a0 36			ld a, (.dmark)  
368f 32 6e fe			ld (debug_mark),a  
3692 3a a1 36			ld a, (.dmark+1)  
3695 32 6f fe			ld (debug_mark+1),a  
3698 3a a2 36			ld a, (.dmark+2)  
369b 32 70 fe			ld (debug_mark+2),a  
369e 18 03			jr .pastdmark  
36a0 ..			.dmark: db "REP"  
36a3 f1			.pastdmark: pop af  
36a4			endm  
# End of macro DMARK
36a4						CALLMONITOR 
36a4 cd f3 18			call break_point_state  
36a7				endm  
# End of macro CALLMONITOR
36a7					endif 
36a7			 
36a7 2a c9 f4				ld hl, (os_tok_ptr) 
36aa 23					inc hl   ; R 
36ab 23					inc hl  ; E 
36ac 23					inc hl   ; P 
36ad 23					inc hl   ; E 
36ae 23					inc hl   ; A 
36af 23					inc hl   ; T 
36b0 23					inc hl   ; zero 
36b1					FORTH_RSP_NEXT 
36b1 cd 0e 1f			call macro_forth_rsp_next 
36b4				endm 
# End of macro FORTH_RSP_NEXT
36b4			 
36b4			 
36b4					if DEBUG_FORTH_WORDS 
36b4						DMARK "REP" 
36b4 f5				push af  
36b5 3a c9 36			ld a, (.dmark)  
36b8 32 6e fe			ld (debug_mark),a  
36bb 3a ca 36			ld a, (.dmark+1)  
36be 32 6f fe			ld (debug_mark+1),a  
36c1 3a cb 36			ld a, (.dmark+2)  
36c4 32 70 fe			ld (debug_mark+2),a  
36c7 18 03			jr .pastdmark  
36c9 ..			.dmark: db "REP"  
36cc f1			.pastdmark: pop af  
36cd			endm  
# End of macro DMARK
36cd						;pop bc    ; TODO BUG ?????? what is this for???? 
36cd						CALLMONITOR 
36cd cd f3 18			call break_point_state  
36d0				endm  
# End of macro CALLMONITOR
36d0					endif 
36d0			 
36d0					NEXTW 
36d0 c3 0d 23			jp macro_next 
36d3				endm 
# End of macro NEXTW
36d3			;	       NEXTW 
36d3			 
36d3			.UNTIL: 
36d3				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
36d3 72				db WORD_SYS_CORE+94             
36d4 6a 37			dw .ENDFLOW            
36d6 06				db 5 + 1 
36d7 .. 00			db "UNTIL",0              
36dd				endm 
# End of macro CWHEAD
36dd			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36dd			 
36dd				; pop tos as check 
36dd			 
36dd				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36dd			 
36dd				FORTH_DSP_VALUEHL 
36dd cd 5e 21			call macro_dsp_valuehl 
36e0				endm 
# End of macro FORTH_DSP_VALUEHL
36e0			 
36e0					if DEBUG_FORTH_WORDS_KEY 
36e0						DMARK "UNT" 
36e0 f5				push af  
36e1 3a f5 36			ld a, (.dmark)  
36e4 32 6e fe			ld (debug_mark),a  
36e7 3a f6 36			ld a, (.dmark+1)  
36ea 32 6f fe			ld (debug_mark+1),a  
36ed 3a f7 36			ld a, (.dmark+2)  
36f0 32 70 fe			ld (debug_mark+2),a  
36f3 18 03			jr .pastdmark  
36f5 ..			.dmark: db "UNT"  
36f8 f1			.pastdmark: pop af  
36f9			endm  
# End of macro DMARK
36f9						CALLMONITOR 
36f9 cd f3 18			call break_point_state  
36fc				endm  
# End of macro CALLMONITOR
36fc					endif 
36fc			 
36fc			;	push hl 
36fc				FORTH_DSP_POP 
36fc cd 16 22			call macro_forth_dsp_pop 
36ff				endm 
# End of macro FORTH_DSP_POP
36ff			 
36ff			;	pop hl 
36ff			 
36ff				; test if true 
36ff			 
36ff cd 75 0f			call ishlzero 
3702			;	ld a,l 
3702			;	add h 
3702			; 
3702			;	cp 0 
3702			 
3702 20 3e			jr nz, .untilnotdone 
3704			 
3704					if DEBUG_FORTH_WORDS 
3704						DMARK "UNf" 
3704 f5				push af  
3705 3a 19 37			ld a, (.dmark)  
3708 32 6e fe			ld (debug_mark),a  
370b 3a 1a 37			ld a, (.dmark+1)  
370e 32 6f fe			ld (debug_mark+1),a  
3711 3a 1b 37			ld a, (.dmark+2)  
3714 32 70 fe			ld (debug_mark+2),a  
3717 18 03			jr .pastdmark  
3719 ..			.dmark: db "UNf"  
371c f1			.pastdmark: pop af  
371d			endm  
# End of macro DMARK
371d						CALLMONITOR 
371d cd f3 18			call break_point_state  
3720				endm  
# End of macro CALLMONITOR
3720					endif 
3720			 
3720			 
3720			 
3720				FORTH_RSP_POP     ; get rid of DO ptr 
3720 cd 2f 1f			call macro_forth_rsp_pop 
3723				endm 
# End of macro FORTH_RSP_POP
3723			 
3723			if DEBUG_FORTH_WORDS 
3723						DMARK "UN>" 
3723 f5				push af  
3724 3a 38 37			ld a, (.dmark)  
3727 32 6e fe			ld (debug_mark),a  
372a 3a 39 37			ld a, (.dmark+1)  
372d 32 6f fe			ld (debug_mark+1),a  
3730 3a 3a 37			ld a, (.dmark+2)  
3733 32 70 fe			ld (debug_mark+2),a  
3736 18 03			jr .pastdmark  
3738 ..			.dmark: db "UN>"  
373b f1			.pastdmark: pop af  
373c			endm  
# End of macro DMARK
373c				CALLMONITOR 
373c cd f3 18			call break_point_state  
373f				endm  
# End of macro CALLMONITOR
373f			endif 
373f			 
373f					NEXTW 
373f c3 0d 23			jp macro_next 
3742				endm 
# End of macro NEXTW
3742				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3742			 
3742			.untilnotdone: 
3742			 
3742			 
3742			;	; get DO ptr 
3742			; 
3742				FORTH_RSP_TOS 
3742 cd 25 1f			call macro_forth_rsp_tos 
3745				endm 
# End of macro FORTH_RSP_TOS
3745			 
3745				;push hl 
3745			 
3745				; not going to DO any more 
3745				; get rid of the RSP pointer as DO will add it back in 
3745				;FORTH_RSP_POP 
3745				;pop hl 
3745			 
3745			 
3745 22 c9 f4			ld (os_tok_ptr), hl 
3748					if DEBUG_FORTH_WORDS 
3748						DMARK "UN<" 
3748 f5				push af  
3749 3a 5d 37			ld a, (.dmark)  
374c 32 6e fe			ld (debug_mark),a  
374f 3a 5e 37			ld a, (.dmark+1)  
3752 32 6f fe			ld (debug_mark+1),a  
3755 3a 5f 37			ld a, (.dmark+2)  
3758 32 70 fe			ld (debug_mark+2),a  
375b 18 03			jr .pastdmark  
375d ..			.dmark: db "UN<"  
3760 f1			.pastdmark: pop af  
3761			endm  
# End of macro DMARK
3761					CALLMONITOR 
3761 cd f3 18			call break_point_state  
3764				endm  
# End of macro CALLMONITOR
3764				endif 
3764 c3 9e 23			jp exec1 
3767			 
3767					 
3767			 
3767			 
3767					NEXTW 
3767 c3 0d 23			jp macro_next 
376a				endm 
# End of macro NEXTW
376a			 
376a			 
376a			.ENDFLOW: 
376a			 
376a			; eof 
376a			 
# End of file forth_words_flow.asm
376a			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
376a			include "forth_words_logic.asm" 
376a			 
376a			; | ## Logic Words 
376a			 
376a			.NOT: 
376a				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
376a 2d				db WORD_SYS_CORE+25             
376b b2 37			dw .IS            
376d 04				db 3 + 1 
376e .. 00			db "NOT",0              
3772				endm 
# End of macro CWHEAD
3772			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3772					if DEBUG_FORTH_WORDS_KEY 
3772						DMARK "NOT" 
3772 f5				push af  
3773 3a 87 37			ld a, (.dmark)  
3776 32 6e fe			ld (debug_mark),a  
3779 3a 88 37			ld a, (.dmark+1)  
377c 32 6f fe			ld (debug_mark+1),a  
377f 3a 89 37			ld a, (.dmark+2)  
3782 32 70 fe			ld (debug_mark+2),a  
3785 18 03			jr .pastdmark  
3787 ..			.dmark: db "NOT"  
378a f1			.pastdmark: pop af  
378b			endm  
# End of macro DMARK
378b						CALLMONITOR 
378b cd f3 18			call break_point_state  
378e				endm  
# End of macro CALLMONITOR
378e					endif 
378e					FORTH_DSP 
378e cd 24 21			call macro_forth_dsp 
3791				endm 
# End of macro FORTH_DSP
3791 7e					ld a,(hl)	; get type of value on TOS 
3792 fe 02				cp DS_TYPE_INUM  
3794 28 03				jr z, .noti 
3796					NEXTW 
3796 c3 0d 23			jp macro_next 
3799				endm 
# End of macro NEXTW
3799			.noti:          FORTH_DSP_VALUEHL 
3799 cd 5e 21			call macro_dsp_valuehl 
379c				endm 
# End of macro FORTH_DSP_VALUEHL
379c			;		push hl 
379c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
379c cd 16 22			call macro_forth_dsp_pop 
379f				endm 
# End of macro FORTH_DSP_POP
379f			;		pop hl 
379f 3e 00				ld a,0 
37a1 bd					cp l 
37a2 28 04				jr z, .not2t 
37a4 2e 00				ld l, 0 
37a6 18 02				jr .notip 
37a8			 
37a8 2e ff		.not2t:		ld l, 255 
37aa			 
37aa 26 00		.notip:		ld h, 0	 
37ac			 
37ac cd 67 1f				call forth_push_numhl 
37af					NEXTW 
37af c3 0d 23			jp macro_next 
37b2				endm 
# End of macro NEXTW
37b2			 
37b2			.IS: 
37b2				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
37b2 2d				db WORD_SYS_CORE+25             
37b3 d8 37			dw .LZERO            
37b5 03				db 2 + 1 
37b6 .. 00			db "IS",0              
37b9				endm 
# End of macro CWHEAD
37b9			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
37b9					if DEBUG_FORTH_WORDS_KEY 
37b9						DMARK "IS." 
37b9 f5				push af  
37ba 3a ce 37			ld a, (.dmark)  
37bd 32 6e fe			ld (debug_mark),a  
37c0 3a cf 37			ld a, (.dmark+1)  
37c3 32 6f fe			ld (debug_mark+1),a  
37c6 3a d0 37			ld a, (.dmark+2)  
37c9 32 70 fe			ld (debug_mark+2),a  
37cc 18 03			jr .pastdmark  
37ce ..			.dmark: db "IS."  
37d1 f1			.pastdmark: pop af  
37d2			endm  
# End of macro DMARK
37d2						CALLMONITOR 
37d2 cd f3 18			call break_point_state  
37d5				endm  
# End of macro CALLMONITOR
37d5					endif 
37d5					NEXTW 
37d5 c3 0d 23			jp macro_next 
37d8				endm 
# End of macro NEXTW
37d8			.LZERO: 
37d8				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
37d8 2d				db WORD_SYS_CORE+25             
37d9 e2 37			dw .TZERO            
37db 03				db 2 + 1 
37dc .. 00			db "0<",0              
37df				endm 
# End of macro CWHEAD
37df			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
37df					NEXTW 
37df c3 0d 23			jp macro_next 
37e2				endm 
# End of macro NEXTW
37e2			.TZERO: 
37e2				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
37e2 2e				db WORD_SYS_CORE+26             
37e3 29 38			dw .LESS            
37e5 03				db 2 + 1 
37e6 .. 00			db "0=",0              
37e9				endm 
# End of macro CWHEAD
37e9			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
37e9				; TODO add floating point number detection 
37e9					;v5 FORTH_DSP_VALUE 
37e9					if DEBUG_FORTH_WORDS_KEY 
37e9						DMARK "0=." 
37e9 f5				push af  
37ea 3a fe 37			ld a, (.dmark)  
37ed 32 6e fe			ld (debug_mark),a  
37f0 3a ff 37			ld a, (.dmark+1)  
37f3 32 6f fe			ld (debug_mark+1),a  
37f6 3a 00 38			ld a, (.dmark+2)  
37f9 32 70 fe			ld (debug_mark+2),a  
37fc 18 03			jr .pastdmark  
37fe ..			.dmark: db "0=."  
3801 f1			.pastdmark: pop af  
3802			endm  
# End of macro DMARK
3802						CALLMONITOR 
3802 cd f3 18			call break_point_state  
3805				endm  
# End of macro CALLMONITOR
3805					endif 
3805					FORTH_DSP 
3805 cd 24 21			call macro_forth_dsp 
3808				endm 
# End of macro FORTH_DSP
3808 7e					ld a,(hl)	; get type of value on TOS 
3809 fe 02				cp DS_TYPE_INUM  
380b 28 00				jr z, .tz_inum 
380d			 
380d				if FORTH_ENABLE_FLOATMATH 
380d					jr .tz_done 
380d			 
380d				endif 
380d					 
380d			 
380d			.tz_inum: 
380d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380d cd 5e 21			call macro_dsp_valuehl 
3810				endm 
# End of macro FORTH_DSP_VALUEHL
3810			 
3810			;		push hl 
3810			 
3810					; destroy value TOS 
3810			 
3810					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3810 cd 16 22			call macro_forth_dsp_pop 
3813				endm 
# End of macro FORTH_DSP_POP
3813			 
3813			;		pop hl 
3813			 
3813 3e 00				ld a,0 
3815			 
3815 bd					cp l 
3816 20 08				jr nz, .tz_notzero 
3818			 
3818 bc					cp h 
3819			 
3819 20 05				jr nz, .tz_notzero 
381b			 
381b			 
381b 21 01 00				ld hl, FORTH_TRUE 
381e 18 03				jr .tz_done 
3820			 
3820 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3823			 
3823					; push value back onto stack for another op etc 
3823			 
3823			.tz_done: 
3823 cd 67 1f				call forth_push_numhl 
3826			 
3826					NEXTW 
3826 c3 0d 23			jp macro_next 
3829				endm 
# End of macro NEXTW
3829			.LESS: 
3829				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3829 2f				db WORD_SYS_CORE+27             
382a 92 38			dw .GT            
382c 02				db 1 + 1 
382d .. 00			db "<",0              
382f				endm 
# End of macro CWHEAD
382f			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
382f				; TODO add floating point number detection 
382f					if DEBUG_FORTH_WORDS_KEY 
382f						DMARK "LES" 
382f f5				push af  
3830 3a 44 38			ld a, (.dmark)  
3833 32 6e fe			ld (debug_mark),a  
3836 3a 45 38			ld a, (.dmark+1)  
3839 32 6f fe			ld (debug_mark+1),a  
383c 3a 46 38			ld a, (.dmark+2)  
383f 32 70 fe			ld (debug_mark+2),a  
3842 18 03			jr .pastdmark  
3844 ..			.dmark: db "LES"  
3847 f1			.pastdmark: pop af  
3848			endm  
# End of macro DMARK
3848						CALLMONITOR 
3848 cd f3 18			call break_point_state  
384b				endm  
# End of macro CALLMONITOR
384b					endif 
384b					FORTH_DSP 
384b cd 24 21			call macro_forth_dsp 
384e				endm 
# End of macro FORTH_DSP
384e					;v5 FORTH_DSP_VALUE 
384e 7e					ld a,(hl)	; get type of value on TOS 
384f fe 02				cp DS_TYPE_INUM  
3851 28 00				jr z, .less_inum 
3853			 
3853				if FORTH_ENABLE_FLOATMATH 
3853					jr .less_done 
3853			 
3853				endif 
3853					 
3853			 
3853			.less_inum: 
3853					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3853 cd 5e 21			call macro_dsp_valuehl 
3856				endm 
# End of macro FORTH_DSP_VALUEHL
3856			 
3856 e5					push hl  ; u2 
3857			 
3857					; destroy value TOS 
3857			 
3857					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3857 cd 16 22			call macro_forth_dsp_pop 
385a				endm 
# End of macro FORTH_DSP_POP
385a			 
385a			 
385a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
385a cd 5e 21			call macro_dsp_valuehl 
385d				endm 
# End of macro FORTH_DSP_VALUEHL
385d			 
385d e5					push hl    ; u1 
385e			 
385e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
385e cd 16 22			call macro_forth_dsp_pop 
3861				endm 
# End of macro FORTH_DSP_POP
3861			 
3861			 
3861 b7			 or a      ;clear carry flag 
3862 01 00 00		 ld bc, FORTH_FALSE 
3865 e1			  pop hl    ; u1 
3866 d1			  pop de    ; u2 
3867 ed 52		  sbc hl,de 
3869 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
386b			 
386b 01 01 00		 ld bc, FORTH_TRUE 
386e			.lscont:  
386e c5					push bc 
386f e1					pop hl 
3870			 
3870					if DEBUG_FORTH_WORDS 
3870						DMARK "LT1" 
3870 f5				push af  
3871 3a 85 38			ld a, (.dmark)  
3874 32 6e fe			ld (debug_mark),a  
3877 3a 86 38			ld a, (.dmark+1)  
387a 32 6f fe			ld (debug_mark+1),a  
387d 3a 87 38			ld a, (.dmark+2)  
3880 32 70 fe			ld (debug_mark+2),a  
3883 18 03			jr .pastdmark  
3885 ..			.dmark: db "LT1"  
3888 f1			.pastdmark: pop af  
3889			endm  
# End of macro DMARK
3889						CALLMONITOR 
3889 cd f3 18			call break_point_state  
388c				endm  
# End of macro CALLMONITOR
388c					endif 
388c cd 67 1f				call forth_push_numhl 
388f			 
388f					NEXTW 
388f c3 0d 23			jp macro_next 
3892				endm 
# End of macro NEXTW
3892			.GT: 
3892				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3892 30				db WORD_SYS_CORE+28             
3893 fb 38			dw .EQUAL            
3895 02				db 1 + 1 
3896 .. 00			db ">",0              
3898				endm 
# End of macro CWHEAD
3898			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3898				; TODO add floating point number detection 
3898					if DEBUG_FORTH_WORDS_KEY 
3898						DMARK "GRT" 
3898 f5				push af  
3899 3a ad 38			ld a, (.dmark)  
389c 32 6e fe			ld (debug_mark),a  
389f 3a ae 38			ld a, (.dmark+1)  
38a2 32 6f fe			ld (debug_mark+1),a  
38a5 3a af 38			ld a, (.dmark+2)  
38a8 32 70 fe			ld (debug_mark+2),a  
38ab 18 03			jr .pastdmark  
38ad ..			.dmark: db "GRT"  
38b0 f1			.pastdmark: pop af  
38b1			endm  
# End of macro DMARK
38b1						CALLMONITOR 
38b1 cd f3 18			call break_point_state  
38b4				endm  
# End of macro CALLMONITOR
38b4					endif 
38b4					FORTH_DSP 
38b4 cd 24 21			call macro_forth_dsp 
38b7				endm 
# End of macro FORTH_DSP
38b7					;FORTH_DSP_VALUE 
38b7 7e					ld a,(hl)	; get type of value on TOS 
38b8 fe 02				cp DS_TYPE_INUM  
38ba 28 00				jr z, .gt_inum 
38bc			 
38bc				if FORTH_ENABLE_FLOATMATH 
38bc					jr .gt_done 
38bc			 
38bc				endif 
38bc					 
38bc			 
38bc			.gt_inum: 
38bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38bc cd 5e 21			call macro_dsp_valuehl 
38bf				endm 
# End of macro FORTH_DSP_VALUEHL
38bf			 
38bf e5					push hl  ; u2 
38c0			 
38c0					; destroy value TOS 
38c0			 
38c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c0 cd 16 22			call macro_forth_dsp_pop 
38c3				endm 
# End of macro FORTH_DSP_POP
38c3			 
38c3			 
38c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38c3 cd 5e 21			call macro_dsp_valuehl 
38c6				endm 
# End of macro FORTH_DSP_VALUEHL
38c6			 
38c6 e5					push hl    ; u1 
38c7			 
38c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c7 cd 16 22			call macro_forth_dsp_pop 
38ca				endm 
# End of macro FORTH_DSP_POP
38ca			 
38ca			 
38ca b7			 or a      ;clear carry flag 
38cb 01 00 00		 ld bc, FORTH_FALSE 
38ce e1			  pop hl    ; u1 
38cf d1			  pop de    ; u2 
38d0 ed 52		  sbc hl,de 
38d2 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
38d4			 
38d4 01 01 00		 ld bc, FORTH_TRUE 
38d7			.gtcont:  
38d7 c5					push bc 
38d8 e1					pop hl 
38d9			 
38d9					if DEBUG_FORTH_WORDS 
38d9						DMARK "GT1" 
38d9 f5				push af  
38da 3a ee 38			ld a, (.dmark)  
38dd 32 6e fe			ld (debug_mark),a  
38e0 3a ef 38			ld a, (.dmark+1)  
38e3 32 6f fe			ld (debug_mark+1),a  
38e6 3a f0 38			ld a, (.dmark+2)  
38e9 32 70 fe			ld (debug_mark+2),a  
38ec 18 03			jr .pastdmark  
38ee ..			.dmark: db "GT1"  
38f1 f1			.pastdmark: pop af  
38f2			endm  
# End of macro DMARK
38f2						CALLMONITOR 
38f2 cd f3 18			call break_point_state  
38f5				endm  
# End of macro CALLMONITOR
38f5					endif 
38f5 cd 67 1f				call forth_push_numhl 
38f8			 
38f8					NEXTW 
38f8 c3 0d 23			jp macro_next 
38fb				endm 
# End of macro NEXTW
38fb			.EQUAL: 
38fb				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
38fb 31				db WORD_SYS_CORE+29             
38fc 66 39			dw .ENDLOGIC            
38fe 02				db 1 + 1 
38ff .. 00			db "=",0              
3901				endm 
# End of macro CWHEAD
3901			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3901				; TODO add floating point number detection 
3901					if DEBUG_FORTH_WORDS_KEY 
3901						DMARK "EQ." 
3901 f5				push af  
3902 3a 16 39			ld a, (.dmark)  
3905 32 6e fe			ld (debug_mark),a  
3908 3a 17 39			ld a, (.dmark+1)  
390b 32 6f fe			ld (debug_mark+1),a  
390e 3a 18 39			ld a, (.dmark+2)  
3911 32 70 fe			ld (debug_mark+2),a  
3914 18 03			jr .pastdmark  
3916 ..			.dmark: db "EQ."  
3919 f1			.pastdmark: pop af  
391a			endm  
# End of macro DMARK
391a						CALLMONITOR 
391a cd f3 18			call break_point_state  
391d				endm  
# End of macro CALLMONITOR
391d					endif 
391d					FORTH_DSP 
391d cd 24 21			call macro_forth_dsp 
3920				endm 
# End of macro FORTH_DSP
3920					;v5 FORTH_DSP_VALUE 
3920 7e					ld a,(hl)	; get type of value on TOS 
3921 fe 02				cp DS_TYPE_INUM  
3923 28 00				jr z, .eq_inum 
3925			 
3925				if FORTH_ENABLE_FLOATMATH 
3925					jr .eq_done 
3925			 
3925				endif 
3925					 
3925			 
3925			.eq_inum: 
3925					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3925 cd 5e 21			call macro_dsp_valuehl 
3928				endm 
# End of macro FORTH_DSP_VALUEHL
3928			 
3928 e5					push hl 
3929			 
3929					; destroy value TOS 
3929			 
3929					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3929 cd 16 22			call macro_forth_dsp_pop 
392c				endm 
# End of macro FORTH_DSP_POP
392c			 
392c			 
392c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
392c cd 5e 21			call macro_dsp_valuehl 
392f				endm 
# End of macro FORTH_DSP_VALUEHL
392f			 
392f					; one value on hl get other one back 
392f			 
392f e5					push hl 
3930			 
3930					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3930 cd 16 22			call macro_forth_dsp_pop 
3933				endm 
# End of macro FORTH_DSP_POP
3933			 
3933 0e 00				ld c, FORTH_FALSE 
3935			 
3935 e1					pop hl 
3936 d1					pop de 
3937			 
3937 7b					ld a, e 
3938 bd					cp l 
3939			 
3939 20 06				jr nz, .eq_done 
393b			 
393b 7a					ld a, d 
393c bc					cp h 
393d			 
393d 20 02				jr nz, .eq_done 
393f			 
393f 0e 01				ld c, FORTH_TRUE 
3941					 
3941			 
3941			 
3941			.eq_done: 
3941			 
3941					; TODO push value back onto stack for another op etc 
3941			 
3941 26 00				ld h, 0 
3943 69					ld l, c 
3944					if DEBUG_FORTH_WORDS 
3944						DMARK "EQ1" 
3944 f5				push af  
3945 3a 59 39			ld a, (.dmark)  
3948 32 6e fe			ld (debug_mark),a  
394b 3a 5a 39			ld a, (.dmark+1)  
394e 32 6f fe			ld (debug_mark+1),a  
3951 3a 5b 39			ld a, (.dmark+2)  
3954 32 70 fe			ld (debug_mark+2),a  
3957 18 03			jr .pastdmark  
3959 ..			.dmark: db "EQ1"  
395c f1			.pastdmark: pop af  
395d			endm  
# End of macro DMARK
395d						CALLMONITOR 
395d cd f3 18			call break_point_state  
3960				endm  
# End of macro CALLMONITOR
3960					endif 
3960 cd 67 1f				call forth_push_numhl 
3963			 
3963					NEXTW 
3963 c3 0d 23			jp macro_next 
3966				endm 
# End of macro NEXTW
3966			 
3966			 
3966			.ENDLOGIC: 
3966			; eof 
3966			 
3966			 
# End of file forth_words_logic.asm
3966			include "forth_words_maths.asm" 
3966			 
3966			; | ## Maths Words 
3966			 
3966			.PLUS:	 
3966				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3966 15				db WORD_SYS_CORE+1             
3967 c4 39			dw .NEG            
3969 02				db 1 + 1 
396a .. 00			db "+",0              
396c				endm 
# End of macro CWHEAD
396c			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
396c					if DEBUG_FORTH_WORDS_KEY 
396c						DMARK "PLU" 
396c f5				push af  
396d 3a 81 39			ld a, (.dmark)  
3970 32 6e fe			ld (debug_mark),a  
3973 3a 82 39			ld a, (.dmark+1)  
3976 32 6f fe			ld (debug_mark+1),a  
3979 3a 83 39			ld a, (.dmark+2)  
397c 32 70 fe			ld (debug_mark+2),a  
397f 18 03			jr .pastdmark  
3981 ..			.dmark: db "PLU"  
3984 f1			.pastdmark: pop af  
3985			endm  
# End of macro DMARK
3985						CALLMONITOR 
3985 cd f3 18			call break_point_state  
3988				endm  
# End of macro CALLMONITOR
3988					endif 
3988					; add top two values and push back result 
3988			 
3988					;for v5 FORTH_DSP_VALUE 
3988					FORTH_DSP 
3988 cd 24 21			call macro_forth_dsp 
398b				endm 
# End of macro FORTH_DSP
398b 7e					ld a,(hl)	; get type of value on TOS 
398c fe 02				cp DS_TYPE_INUM  
398e 28 03				jr z, .dot_inum 
3990			 
3990					NEXTW 
3990 c3 0d 23			jp macro_next 
3993				endm 
# End of macro NEXTW
3993			 
3993			; float maths 
3993			 
3993				if FORTH_ENABLE_FLOATMATH 
3993						inc hl      ; now at start of numeric as string 
3993			 
3993					if DEBUG_FORTH_MATHS 
3993						DMARK "ADD" 
3993				CALLMONITOR 
3993					endif 
3993			 
3993					;ld ix, hl 
3993					call CON 
3993			 
3993			 
3993					push hl 
3993					 
3993					 
3993			 
3993						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3993			 
3993					; get next number 
3993			 
3993						FORTH_DSP_VALUE 
3993			 
3993						inc hl      ; now at start of numeric as string 
3993			 
3993					;ld ix, hl 
3993					call CON 
3993			 
3993					push hl 
3993			 
3993			 
3993						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3993			 
3993						; TODO do add 
3993			 
3993						call IADD 
3993			 
3993						; TODO get result back as ascii 
3993			 
3993						; TODO push result  
3993			 
3993			 
3993			 
3993						jr .dot_done 
3993				endif 
3993			 
3993			.dot_inum: 
3993			 
3993			 
3993					if DEBUG_FORTH_DOT 
3993						DMARK "+IT" 
3993 f5				push af  
3994 3a a8 39			ld a, (.dmark)  
3997 32 6e fe			ld (debug_mark),a  
399a 3a a9 39			ld a, (.dmark+1)  
399d 32 6f fe			ld (debug_mark+1),a  
39a0 3a aa 39			ld a, (.dmark+2)  
39a3 32 70 fe			ld (debug_mark+2),a  
39a6 18 03			jr .pastdmark  
39a8 ..			.dmark: db "+IT"  
39ab f1			.pastdmark: pop af  
39ac			endm  
# End of macro DMARK
39ac				CALLMONITOR 
39ac cd f3 18			call break_point_state  
39af				endm  
# End of macro CALLMONITOR
39af					endif 
39af			 
39af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39af cd 5e 21			call macro_dsp_valuehl 
39b2				endm 
# End of macro FORTH_DSP_VALUEHL
39b2			 
39b2				; TODO add floating point number detection 
39b2			 
39b2 e5					push hl 
39b3			 
39b3					; destroy value TOS 
39b3			 
39b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39b3 cd 16 22			call macro_forth_dsp_pop 
39b6				endm 
# End of macro FORTH_DSP_POP
39b6			 
39b6			 
39b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b6 cd 5e 21			call macro_dsp_valuehl 
39b9				endm 
# End of macro FORTH_DSP_VALUEHL
39b9			 
39b9					; one value on hl get other one back 
39b9			 
39b9 d1					pop de 
39ba			 
39ba					; do the add 
39ba			 
39ba 19					add hl,de 
39bb			 
39bb					; save it 
39bb			 
39bb			;		push hl	 
39bb			 
39bb					; 
39bb			 
39bb					; destroy value TOS 
39bb			 
39bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39bb cd 16 22			call macro_forth_dsp_pop 
39be				endm 
# End of macro FORTH_DSP_POP
39be			 
39be					; TODO push value back onto stack for another op etc 
39be			 
39be			;		pop hl 
39be			 
39be			.dot_done: 
39be cd 67 1f				call forth_push_numhl 
39c1			 
39c1					NEXTW 
39c1 c3 0d 23			jp macro_next 
39c4				endm 
# End of macro NEXTW
39c4			.NEG: 
39c4			 
39c4				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
39c4 17				db WORD_SYS_CORE+3             
39c5 07 3a			dw .DIV            
39c7 02				db 1 + 1 
39c8 .. 00			db "-",0              
39ca				endm 
# End of macro CWHEAD
39ca			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
39ca					if DEBUG_FORTH_WORDS_KEY 
39ca						DMARK "SUB" 
39ca f5				push af  
39cb 3a df 39			ld a, (.dmark)  
39ce 32 6e fe			ld (debug_mark),a  
39d1 3a e0 39			ld a, (.dmark+1)  
39d4 32 6f fe			ld (debug_mark+1),a  
39d7 3a e1 39			ld a, (.dmark+2)  
39da 32 70 fe			ld (debug_mark+2),a  
39dd 18 03			jr .pastdmark  
39df ..			.dmark: db "SUB"  
39e2 f1			.pastdmark: pop af  
39e3			endm  
# End of macro DMARK
39e3						CALLMONITOR 
39e3 cd f3 18			call break_point_state  
39e6				endm  
# End of macro CALLMONITOR
39e6					endif 
39e6			 
39e6			 
39e6				; TODO add floating point number detection 
39e6					; v5 FORTH_DSP_VALUE 
39e6					FORTH_DSP 
39e6 cd 24 21			call macro_forth_dsp 
39e9				endm 
# End of macro FORTH_DSP
39e9 7e					ld a,(hl)	; get type of value on TOS 
39ea fe 02				cp DS_TYPE_INUM  
39ec 28 03				jr z, .neg_inum 
39ee			 
39ee					NEXTW 
39ee c3 0d 23			jp macro_next 
39f1				endm 
# End of macro NEXTW
39f1			 
39f1			; float maths 
39f1			 
39f1				if FORTH_ENABLE_FLOATMATH 
39f1					jr .neg_done 
39f1			 
39f1				endif 
39f1					 
39f1			 
39f1			.neg_inum: 
39f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39f1 cd 5e 21			call macro_dsp_valuehl 
39f4				endm 
# End of macro FORTH_DSP_VALUEHL
39f4			 
39f4 e5					push hl 
39f5			 
39f5					; destroy value TOS 
39f5			 
39f5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f5 cd 16 22			call macro_forth_dsp_pop 
39f8				endm 
# End of macro FORTH_DSP_POP
39f8			 
39f8			 
39f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39f8 cd 5e 21			call macro_dsp_valuehl 
39fb				endm 
# End of macro FORTH_DSP_VALUEHL
39fb			 
39fb					; one value on hl get other one back 
39fb			 
39fb d1					pop de 
39fc			 
39fc					; do the sub 
39fc			;		ex de, hl 
39fc			 
39fc ed 52				sbc hl,de 
39fe			 
39fe					; save it 
39fe			 
39fe			;		push hl	 
39fe			 
39fe					; 
39fe			 
39fe					; destroy value TOS 
39fe			 
39fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39fe cd 16 22			call macro_forth_dsp_pop 
3a01				endm 
# End of macro FORTH_DSP_POP
3a01			 
3a01					; TODO push value back onto stack for another op etc 
3a01			 
3a01			;		pop hl 
3a01			 
3a01 cd 67 1f				call forth_push_numhl 
3a04			.neg_done: 
3a04			 
3a04					NEXTW 
3a04 c3 0d 23			jp macro_next 
3a07				endm 
# End of macro NEXTW
3a07			.DIV: 
3a07				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3a07 18				db WORD_SYS_CORE+4             
3a08 54 3a			dw .MUL            
3a0a 02				db 1 + 1 
3a0b .. 00			db "/",0              
3a0d				endm 
# End of macro CWHEAD
3a0d			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3a0d					if DEBUG_FORTH_WORDS_KEY 
3a0d						DMARK "DIV" 
3a0d f5				push af  
3a0e 3a 22 3a			ld a, (.dmark)  
3a11 32 6e fe			ld (debug_mark),a  
3a14 3a 23 3a			ld a, (.dmark+1)  
3a17 32 6f fe			ld (debug_mark+1),a  
3a1a 3a 24 3a			ld a, (.dmark+2)  
3a1d 32 70 fe			ld (debug_mark+2),a  
3a20 18 03			jr .pastdmark  
3a22 ..			.dmark: db "DIV"  
3a25 f1			.pastdmark: pop af  
3a26			endm  
# End of macro DMARK
3a26						CALLMONITOR 
3a26 cd f3 18			call break_point_state  
3a29				endm  
# End of macro CALLMONITOR
3a29					endif 
3a29				; TODO add floating point number detection 
3a29					; v5 FORTH_DSP_VALUE 
3a29					FORTH_DSP 
3a29 cd 24 21			call macro_forth_dsp 
3a2c				endm 
# End of macro FORTH_DSP
3a2c 7e					ld a,(hl)	; get type of value on TOS 
3a2d fe 02				cp DS_TYPE_INUM  
3a2f 28 03				jr z, .div_inum 
3a31			 
3a31				if FORTH_ENABLE_FLOATMATH 
3a31					jr .div_done 
3a31			 
3a31				endif 
3a31					NEXTW 
3a31 c3 0d 23			jp macro_next 
3a34				endm 
# End of macro NEXTW
3a34			.div_inum: 
3a34			 
3a34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a34 cd 5e 21			call macro_dsp_valuehl 
3a37				endm 
# End of macro FORTH_DSP_VALUEHL
3a37			 
3a37 e5					push hl    ; to go to bc 
3a38			 
3a38					; destroy value TOS 
3a38			 
3a38					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a38 cd 16 22			call macro_forth_dsp_pop 
3a3b				endm 
# End of macro FORTH_DSP_POP
3a3b			 
3a3b			 
3a3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a3b cd 5e 21			call macro_dsp_valuehl 
3a3e				endm 
# End of macro FORTH_DSP_VALUEHL
3a3e			 
3a3e					; hl to go to de 
3a3e			 
3a3e e5					push hl 
3a3f			 
3a3f c1					pop bc 
3a40 d1					pop de		 
3a41			 
3a41			 
3a41					if DEBUG_FORTH_MATHS 
3a41						DMARK "DIV" 
3a41				CALLMONITOR 
3a41					endif 
3a41					; one value on hl but move to a get other one back 
3a41			 
3a41			        
3a41 cd a9 0e			call Div16 
3a44			 
3a44			;	push af	 
3a44 e5				push hl 
3a45 c5				push bc 
3a46			 
3a46					if DEBUG_FORTH_MATHS 
3a46						DMARK "DI1" 
3a46				CALLMONITOR 
3a46					endif 
3a46			 
3a46					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a46 cd 16 22			call macro_forth_dsp_pop 
3a49				endm 
# End of macro FORTH_DSP_POP
3a49			 
3a49			 
3a49			 
3a49 e1					pop hl    ; result 
3a4a			 
3a4a cd 67 1f				call forth_push_numhl 
3a4d			 
3a4d e1					pop hl    ; reminder 
3a4e			;		ld h,0 
3a4e			;		ld l,d 
3a4e			 
3a4e cd 67 1f				call forth_push_numhl 
3a51			.div_done: 
3a51					NEXTW 
3a51 c3 0d 23			jp macro_next 
3a54				endm 
# End of macro NEXTW
3a54			.MUL: 
3a54				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a54 19				db WORD_SYS_CORE+5             
3a55 99 3a			dw .MIN            
3a57 02				db 1 + 1 
3a58 .. 00			db "*",0              
3a5a				endm 
# End of macro CWHEAD
3a5a			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a5a				; TODO add floating point number detection 
3a5a					if DEBUG_FORTH_WORDS_KEY 
3a5a						DMARK "MUL" 
3a5a f5				push af  
3a5b 3a 6f 3a			ld a, (.dmark)  
3a5e 32 6e fe			ld (debug_mark),a  
3a61 3a 70 3a			ld a, (.dmark+1)  
3a64 32 6f fe			ld (debug_mark+1),a  
3a67 3a 71 3a			ld a, (.dmark+2)  
3a6a 32 70 fe			ld (debug_mark+2),a  
3a6d 18 03			jr .pastdmark  
3a6f ..			.dmark: db "MUL"  
3a72 f1			.pastdmark: pop af  
3a73			endm  
# End of macro DMARK
3a73						CALLMONITOR 
3a73 cd f3 18			call break_point_state  
3a76				endm  
# End of macro CALLMONITOR
3a76					endif 
3a76					FORTH_DSP 
3a76 cd 24 21			call macro_forth_dsp 
3a79				endm 
# End of macro FORTH_DSP
3a79					; v5 FORTH_DSP_VALUE 
3a79 7e					ld a,(hl)	; get type of value on TOS 
3a7a fe 02				cp DS_TYPE_INUM  
3a7c 28 03				jr z, .mul_inum 
3a7e			 
3a7e				if FORTH_ENABLE_FLOATMATH 
3a7e					jr .mul_done 
3a7e			 
3a7e				endif 
3a7e			 
3a7e					NEXTW 
3a7e c3 0d 23			jp macro_next 
3a81				endm 
# End of macro NEXTW
3a81			.mul_inum:	 
3a81			 
3a81					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a81 cd 5e 21			call macro_dsp_valuehl 
3a84				endm 
# End of macro FORTH_DSP_VALUEHL
3a84			 
3a84 e5					push hl 
3a85			 
3a85					; destroy value TOS 
3a85			 
3a85					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a85 cd 16 22			call macro_forth_dsp_pop 
3a88				endm 
# End of macro FORTH_DSP_POP
3a88			 
3a88			 
3a88					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a88 cd 5e 21			call macro_dsp_valuehl 
3a8b				endm 
# End of macro FORTH_DSP_VALUEHL
3a8b			 
3a8b					; one value on hl but move to a get other one back 
3a8b			 
3a8b 7d					ld a, l 
3a8c			 
3a8c d1					pop de 
3a8d			 
3a8d					; do the mull 
3a8d			;		ex de, hl 
3a8d			 
3a8d cd cf 0e				call Mult16 
3a90					; save it 
3a90			 
3a90			;		push hl	 
3a90			 
3a90					; 
3a90			 
3a90					; destroy value TOS 
3a90			 
3a90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a90 cd 16 22			call macro_forth_dsp_pop 
3a93				endm 
# End of macro FORTH_DSP_POP
3a93			 
3a93					; TODO push value back onto stack for another op etc 
3a93			 
3a93			;		pop hl 
3a93			 
3a93 cd 67 1f				call forth_push_numhl 
3a96			 
3a96			.mul_done: 
3a96					NEXTW 
3a96 c3 0d 23			jp macro_next 
3a99				endm 
# End of macro NEXTW
3a99			 
3a99			 
3a99			 
3a99			 
3a99			.MIN: 
3a99				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3a99 49				db WORD_SYS_CORE+53             
3a9a 1a 3b			dw .MAX            
3a9c 04				db 3 + 1 
3a9d .. 00			db "MIN",0              
3aa1				endm 
# End of macro CWHEAD
3aa1			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3aa1					if DEBUG_FORTH_WORDS_KEY 
3aa1						DMARK "MIN" 
3aa1 f5				push af  
3aa2 3a b6 3a			ld a, (.dmark)  
3aa5 32 6e fe			ld (debug_mark),a  
3aa8 3a b7 3a			ld a, (.dmark+1)  
3aab 32 6f fe			ld (debug_mark+1),a  
3aae 3a b8 3a			ld a, (.dmark+2)  
3ab1 32 70 fe			ld (debug_mark+2),a  
3ab4 18 03			jr .pastdmark  
3ab6 ..			.dmark: db "MIN"  
3ab9 f1			.pastdmark: pop af  
3aba			endm  
# End of macro DMARK
3aba						CALLMONITOR 
3aba cd f3 18			call break_point_state  
3abd				endm  
# End of macro CALLMONITOR
3abd					endif 
3abd					; get u2 
3abd			 
3abd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3abd cd 5e 21			call macro_dsp_valuehl 
3ac0				endm 
# End of macro FORTH_DSP_VALUEHL
3ac0			 
3ac0 e5					push hl   ; u2 
3ac1			 
3ac1					; destroy value TOS 
3ac1			 
3ac1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac1 cd 16 22			call macro_forth_dsp_pop 
3ac4				endm 
# End of macro FORTH_DSP_POP
3ac4			 
3ac4					; get u1 
3ac4			 
3ac4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac4 cd 5e 21			call macro_dsp_valuehl 
3ac7				endm 
# End of macro FORTH_DSP_VALUEHL
3ac7			 
3ac7 e5					push hl  ; u1 
3ac8			 
3ac8					; destroy value TOS 
3ac8			 
3ac8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac8 cd 16 22			call macro_forth_dsp_pop 
3acb				endm 
# End of macro FORTH_DSP_POP
3acb			 
3acb b7			 or a      ;clear carry flag 
3acc e1			  pop hl    ; u1 
3acd d1			  pop de    ; u2 
3ace e5				push hl   ; saved in case hl is lowest 
3acf ed 52		  sbc hl,de 
3ad1 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3ad3			 
3ad3 e1				pop hl 
3ad4					if DEBUG_FORTH_WORDS 
3ad4						DMARK "MIN" 
3ad4 f5				push af  
3ad5 3a e9 3a			ld a, (.dmark)  
3ad8 32 6e fe			ld (debug_mark),a  
3adb 3a ea 3a			ld a, (.dmark+1)  
3ade 32 6f fe			ld (debug_mark+1),a  
3ae1 3a eb 3a			ld a, (.dmark+2)  
3ae4 32 70 fe			ld (debug_mark+2),a  
3ae7 18 03			jr .pastdmark  
3ae9 ..			.dmark: db "MIN"  
3aec f1			.pastdmark: pop af  
3aed			endm  
# End of macro DMARK
3aed						CALLMONITOR 
3aed cd f3 18			call break_point_state  
3af0				endm  
# End of macro CALLMONITOR
3af0					endif 
3af0 cd 67 1f				call forth_push_numhl 
3af3			 
3af3				       NEXTW 
3af3 c3 0d 23			jp macro_next 
3af6				endm 
# End of macro NEXTW
3af6			 
3af6			.mincont:  
3af6 c1				pop bc   ; tidy up 
3af7 eb				ex de , hl  
3af8					if DEBUG_FORTH_WORDS 
3af8						DMARK "MI1" 
3af8 f5				push af  
3af9 3a 0d 3b			ld a, (.dmark)  
3afc 32 6e fe			ld (debug_mark),a  
3aff 3a 0e 3b			ld a, (.dmark+1)  
3b02 32 6f fe			ld (debug_mark+1),a  
3b05 3a 0f 3b			ld a, (.dmark+2)  
3b08 32 70 fe			ld (debug_mark+2),a  
3b0b 18 03			jr .pastdmark  
3b0d ..			.dmark: db "MI1"  
3b10 f1			.pastdmark: pop af  
3b11			endm  
# End of macro DMARK
3b11						CALLMONITOR 
3b11 cd f3 18			call break_point_state  
3b14				endm  
# End of macro CALLMONITOR
3b14					endif 
3b14 cd 67 1f				call forth_push_numhl 
3b17			 
3b17				       NEXTW 
3b17 c3 0d 23			jp macro_next 
3b1a				endm 
# End of macro NEXTW
3b1a			.MAX: 
3b1a				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3b1a 4a				db WORD_SYS_CORE+54             
3b1b 9b 3b			dw .RND16            
3b1d 04				db 3 + 1 
3b1e .. 00			db "MAX",0              
3b22				endm 
# End of macro CWHEAD
3b22			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3b22					if DEBUG_FORTH_WORDS_KEY 
3b22						DMARK "MAX" 
3b22 f5				push af  
3b23 3a 37 3b			ld a, (.dmark)  
3b26 32 6e fe			ld (debug_mark),a  
3b29 3a 38 3b			ld a, (.dmark+1)  
3b2c 32 6f fe			ld (debug_mark+1),a  
3b2f 3a 39 3b			ld a, (.dmark+2)  
3b32 32 70 fe			ld (debug_mark+2),a  
3b35 18 03			jr .pastdmark  
3b37 ..			.dmark: db "MAX"  
3b3a f1			.pastdmark: pop af  
3b3b			endm  
# End of macro DMARK
3b3b						CALLMONITOR 
3b3b cd f3 18			call break_point_state  
3b3e				endm  
# End of macro CALLMONITOR
3b3e					endif 
3b3e					; get u2 
3b3e			 
3b3e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b3e cd 5e 21			call macro_dsp_valuehl 
3b41				endm 
# End of macro FORTH_DSP_VALUEHL
3b41			 
3b41 e5					push hl   ; u2 
3b42			 
3b42					; destroy value TOS 
3b42			 
3b42					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b42 cd 16 22			call macro_forth_dsp_pop 
3b45				endm 
# End of macro FORTH_DSP_POP
3b45			 
3b45					; get u1 
3b45			 
3b45					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b45 cd 5e 21			call macro_dsp_valuehl 
3b48				endm 
# End of macro FORTH_DSP_VALUEHL
3b48			 
3b48 e5					push hl  ; u1 
3b49			 
3b49					; destroy value TOS 
3b49			 
3b49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b49 cd 16 22			call macro_forth_dsp_pop 
3b4c				endm 
# End of macro FORTH_DSP_POP
3b4c			 
3b4c b7			 or a      ;clear carry flag 
3b4d e1			  pop hl    ; u1 
3b4e d1			  pop de    ; u2 
3b4f e5				push hl   ; saved in case hl is lowest 
3b50 ed 52		  sbc hl,de 
3b52 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b54			 
3b54 e1				pop hl 
3b55					if DEBUG_FORTH_WORDS 
3b55						DMARK "MAX" 
3b55 f5				push af  
3b56 3a 6a 3b			ld a, (.dmark)  
3b59 32 6e fe			ld (debug_mark),a  
3b5c 3a 6b 3b			ld a, (.dmark+1)  
3b5f 32 6f fe			ld (debug_mark+1),a  
3b62 3a 6c 3b			ld a, (.dmark+2)  
3b65 32 70 fe			ld (debug_mark+2),a  
3b68 18 03			jr .pastdmark  
3b6a ..			.dmark: db "MAX"  
3b6d f1			.pastdmark: pop af  
3b6e			endm  
# End of macro DMARK
3b6e						CALLMONITOR 
3b6e cd f3 18			call break_point_state  
3b71				endm  
# End of macro CALLMONITOR
3b71					endif 
3b71 cd 67 1f				call forth_push_numhl 
3b74			 
3b74				       NEXTW 
3b74 c3 0d 23			jp macro_next 
3b77				endm 
# End of macro NEXTW
3b77			 
3b77			.maxcont:  
3b77 c1				pop bc   ; tidy up 
3b78 eb				ex de , hl  
3b79					if DEBUG_FORTH_WORDS 
3b79						DMARK "MA1" 
3b79 f5				push af  
3b7a 3a 8e 3b			ld a, (.dmark)  
3b7d 32 6e fe			ld (debug_mark),a  
3b80 3a 8f 3b			ld a, (.dmark+1)  
3b83 32 6f fe			ld (debug_mark+1),a  
3b86 3a 90 3b			ld a, (.dmark+2)  
3b89 32 70 fe			ld (debug_mark+2),a  
3b8c 18 03			jr .pastdmark  
3b8e ..			.dmark: db "MA1"  
3b91 f1			.pastdmark: pop af  
3b92			endm  
# End of macro DMARK
3b92						CALLMONITOR 
3b92 cd f3 18			call break_point_state  
3b95				endm  
# End of macro CALLMONITOR
3b95					endif 
3b95 cd 67 1f				call forth_push_numhl 
3b98				       NEXTW 
3b98 c3 0d 23			jp macro_next 
3b9b				endm 
# End of macro NEXTW
3b9b			 
3b9b			.RND16: 
3b9b				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3b9b 4e				db WORD_SYS_CORE+58             
3b9c ca 3b			dw .RND8            
3b9e 06				db 5 + 1 
3b9f .. 00			db "RND16",0              
3ba5				endm 
# End of macro CWHEAD
3ba5			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3ba5					if DEBUG_FORTH_WORDS_KEY 
3ba5						DMARK "R16" 
3ba5 f5				push af  
3ba6 3a ba 3b			ld a, (.dmark)  
3ba9 32 6e fe			ld (debug_mark),a  
3bac 3a bb 3b			ld a, (.dmark+1)  
3baf 32 6f fe			ld (debug_mark+1),a  
3bb2 3a bc 3b			ld a, (.dmark+2)  
3bb5 32 70 fe			ld (debug_mark+2),a  
3bb8 18 03			jr .pastdmark  
3bba ..			.dmark: db "R16"  
3bbd f1			.pastdmark: pop af  
3bbe			endm  
# End of macro DMARK
3bbe						CALLMONITOR 
3bbe cd f3 18			call break_point_state  
3bc1				endm  
# End of macro CALLMONITOR
3bc1					endif 
3bc1 cd 73 0e				call prng16  
3bc4 cd 67 1f				call forth_push_numhl 
3bc7				       NEXTW 
3bc7 c3 0d 23			jp macro_next 
3bca				endm 
# End of macro NEXTW
3bca			.RND8: 
3bca				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3bca 60				db WORD_SYS_CORE+76             
3bcb ff 3b			dw .RND            
3bcd 05				db 4 + 1 
3bce .. 00			db "RND8",0              
3bd3				endm 
# End of macro CWHEAD
3bd3			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3bd3					if DEBUG_FORTH_WORDS_KEY 
3bd3						DMARK "RN8" 
3bd3 f5				push af  
3bd4 3a e8 3b			ld a, (.dmark)  
3bd7 32 6e fe			ld (debug_mark),a  
3bda 3a e9 3b			ld a, (.dmark+1)  
3bdd 32 6f fe			ld (debug_mark+1),a  
3be0 3a ea 3b			ld a, (.dmark+2)  
3be3 32 70 fe			ld (debug_mark+2),a  
3be6 18 03			jr .pastdmark  
3be8 ..			.dmark: db "RN8"  
3beb f1			.pastdmark: pop af  
3bec			endm  
# End of macro DMARK
3bec						CALLMONITOR 
3bec cd f3 18			call break_point_state  
3bef				endm  
# End of macro CALLMONITOR
3bef					endif 
3bef 2a af fb				ld hl,(xrandc) 
3bf2 23					inc hl 
3bf3 cd 8d 0e				call xrnd 
3bf6 6f					ld l,a	 
3bf7 26 00				ld h,0 
3bf9 cd 67 1f				call forth_push_numhl 
3bfc				       NEXTW 
3bfc c3 0d 23			jp macro_next 
3bff				endm 
# End of macro NEXTW
3bff			.RND: 
3bff				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3bff 60				db WORD_SYS_CORE+76             
3c00 05 3d			dw .ENDMATHS            
3c02 04				db 3 + 1 
3c03 .. 00			db "RND",0              
3c07				endm 
# End of macro CWHEAD
3c07			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3c07			 
3c07					if DEBUG_FORTH_WORDS_KEY 
3c07						DMARK "RND" 
3c07 f5				push af  
3c08 3a 1c 3c			ld a, (.dmark)  
3c0b 32 6e fe			ld (debug_mark),a  
3c0e 3a 1d 3c			ld a, (.dmark+1)  
3c11 32 6f fe			ld (debug_mark+1),a  
3c14 3a 1e 3c			ld a, (.dmark+2)  
3c17 32 70 fe			ld (debug_mark+2),a  
3c1a 18 03			jr .pastdmark  
3c1c ..			.dmark: db "RND"  
3c1f f1			.pastdmark: pop af  
3c20			endm  
# End of macro DMARK
3c20						CALLMONITOR 
3c20 cd f3 18			call break_point_state  
3c23				endm  
# End of macro CALLMONITOR
3c23					endif 
3c23					 
3c23					FORTH_DSP_VALUEHL    ; upper range 
3c23 cd 5e 21			call macro_dsp_valuehl 
3c26				endm 
# End of macro FORTH_DSP_VALUEHL
3c26			 
3c26 22 b3 fb				ld (LFSRSeed), hl	 
3c29			 
3c29					if DEBUG_FORTH_WORDS 
3c29						DMARK "RN1" 
3c29 f5				push af  
3c2a 3a 3e 3c			ld a, (.dmark)  
3c2d 32 6e fe			ld (debug_mark),a  
3c30 3a 3f 3c			ld a, (.dmark+1)  
3c33 32 6f fe			ld (debug_mark+1),a  
3c36 3a 40 3c			ld a, (.dmark+2)  
3c39 32 70 fe			ld (debug_mark+2),a  
3c3c 18 03			jr .pastdmark  
3c3e ..			.dmark: db "RN1"  
3c41 f1			.pastdmark: pop af  
3c42			endm  
# End of macro DMARK
3c42						CALLMONITOR 
3c42 cd f3 18			call break_point_state  
3c45				endm  
# End of macro CALLMONITOR
3c45					endif 
3c45					FORTH_DSP_POP 
3c45 cd 16 22			call macro_forth_dsp_pop 
3c48				endm 
# End of macro FORTH_DSP_POP
3c48			 
3c48					FORTH_DSP_VALUEHL    ; low range 
3c48 cd 5e 21			call macro_dsp_valuehl 
3c4b				endm 
# End of macro FORTH_DSP_VALUEHL
3c4b			 
3c4b					if DEBUG_FORTH_WORDS 
3c4b						DMARK "RN2" 
3c4b f5				push af  
3c4c 3a 60 3c			ld a, (.dmark)  
3c4f 32 6e fe			ld (debug_mark),a  
3c52 3a 61 3c			ld a, (.dmark+1)  
3c55 32 6f fe			ld (debug_mark+1),a  
3c58 3a 62 3c			ld a, (.dmark+2)  
3c5b 32 70 fe			ld (debug_mark+2),a  
3c5e 18 03			jr .pastdmark  
3c60 ..			.dmark: db "RN2"  
3c63 f1			.pastdmark: pop af  
3c64			endm  
# End of macro DMARK
3c64						CALLMONITOR 
3c64 cd f3 18			call break_point_state  
3c67				endm  
# End of macro CALLMONITOR
3c67					endif 
3c67 22 b5 fb				ld (LFSRSeed+2), hl 
3c6a			 
3c6a					FORTH_DSP_POP 
3c6a cd 16 22			call macro_forth_dsp_pop 
3c6d				endm 
# End of macro FORTH_DSP_POP
3c6d			 
3c6d e5					push hl 
3c6e			 
3c6e e1			.inrange:	pop hl 
3c6f cd 73 0e				call prng16  
3c72					if DEBUG_FORTH_WORDS 
3c72						DMARK "RN3" 
3c72 f5				push af  
3c73 3a 87 3c			ld a, (.dmark)  
3c76 32 6e fe			ld (debug_mark),a  
3c79 3a 88 3c			ld a, (.dmark+1)  
3c7c 32 6f fe			ld (debug_mark+1),a  
3c7f 3a 89 3c			ld a, (.dmark+2)  
3c82 32 70 fe			ld (debug_mark+2),a  
3c85 18 03			jr .pastdmark  
3c87 ..			.dmark: db "RN3"  
3c8a f1			.pastdmark: pop af  
3c8b			endm  
# End of macro DMARK
3c8b						CALLMONITOR 
3c8b cd f3 18			call break_point_state  
3c8e				endm  
# End of macro CALLMONITOR
3c8e					endif 
3c8e					 
3c8e					; if the range is 8bit knock out the high byte 
3c8e			 
3c8e ed 5b b3 fb			ld de, (LFSRSeed)     ; check high level 
3c92			 
3c92 3e 00				ld a, 0 
3c94 ba					cp d  
3c95 20 1e				jr nz, .hirange 
3c97 26 00				ld h, 0   ; knock it down to 8bit 
3c99			 
3c99					if DEBUG_FORTH_WORDS 
3c99						DMARK "RNk" 
3c99 f5				push af  
3c9a 3a ae 3c			ld a, (.dmark)  
3c9d 32 6e fe			ld (debug_mark),a  
3ca0 3a af 3c			ld a, (.dmark+1)  
3ca3 32 6f fe			ld (debug_mark+1),a  
3ca6 3a b0 3c			ld a, (.dmark+2)  
3ca9 32 70 fe			ld (debug_mark+2),a  
3cac 18 03			jr .pastdmark  
3cae ..			.dmark: db "RNk"  
3cb1 f1			.pastdmark: pop af  
3cb2			endm  
# End of macro DMARK
3cb2						CALLMONITOR 
3cb2 cd f3 18			call break_point_state  
3cb5				endm  
# End of macro CALLMONITOR
3cb5					endif 
3cb5			.hirange:   
3cb5 e5					push hl  
3cb6 b7					or a  
3cb7 ed 52		                sbc hl, de 
3cb9			 
3cb9					;call cmp16 
3cb9			 
3cb9 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3cbb e1					pop hl 
3cbc e5					push hl 
3cbd			 
3cbd					if DEBUG_FORTH_WORDS 
3cbd						DMARK "RN4" 
3cbd f5				push af  
3cbe 3a d2 3c			ld a, (.dmark)  
3cc1 32 6e fe			ld (debug_mark),a  
3cc4 3a d3 3c			ld a, (.dmark+1)  
3cc7 32 6f fe			ld (debug_mark+1),a  
3cca 3a d4 3c			ld a, (.dmark+2)  
3ccd 32 70 fe			ld (debug_mark+2),a  
3cd0 18 03			jr .pastdmark  
3cd2 ..			.dmark: db "RN4"  
3cd5 f1			.pastdmark: pop af  
3cd6			endm  
# End of macro DMARK
3cd6						CALLMONITOR 
3cd6 cd f3 18			call break_point_state  
3cd9				endm  
# End of macro CALLMONITOR
3cd9					endif 
3cd9 ed 5b b5 fb			ld de, (LFSRSeed+2)   ; check low range 
3cdd					;call cmp16 
3cdd				 
3cdd b7					or a  
3cde ed 52		                sbc hl, de 
3ce0 38 8c				jr c, .inrange 
3ce2			 
3ce2 e1					pop hl 
3ce3					 
3ce3					if DEBUG_FORTH_WORDS 
3ce3						DMARK "RNd" 
3ce3 f5				push af  
3ce4 3a f8 3c			ld a, (.dmark)  
3ce7 32 6e fe			ld (debug_mark),a  
3cea 3a f9 3c			ld a, (.dmark+1)  
3ced 32 6f fe			ld (debug_mark+1),a  
3cf0 3a fa 3c			ld a, (.dmark+2)  
3cf3 32 70 fe			ld (debug_mark+2),a  
3cf6 18 03			jr .pastdmark  
3cf8 ..			.dmark: db "RNd"  
3cfb f1			.pastdmark: pop af  
3cfc			endm  
# End of macro DMARK
3cfc						CALLMONITOR 
3cfc cd f3 18			call break_point_state  
3cff				endm  
# End of macro CALLMONITOR
3cff					endif 
3cff			 
3cff			 
3cff cd 67 1f				call forth_push_numhl 
3d02				       NEXTW 
3d02 c3 0d 23			jp macro_next 
3d05				endm 
# End of macro NEXTW
3d05			 
3d05			.ENDMATHS: 
3d05			 
3d05			; eof 
3d05			 
# End of file forth_words_maths.asm
3d05			include "forth_words_display.asm" 
3d05			 
3d05			; | ## Display Words 
3d05			 
3d05			.INFO: 
3d05			 
3d05				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3d05 62				db WORD_SYS_CORE+78             
3d06 22 3d			dw .ATP            
3d08 05				db 4 + 1 
3d09 .. 00			db "INFO",0              
3d0e				endm 
# End of macro CWHEAD
3d0e			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3d0e					FORTH_DSP_VALUEHL 
3d0e cd 5e 21			call macro_dsp_valuehl 
3d11				endm 
# End of macro FORTH_DSP_VALUEHL
3d11			 
3d11					FORTH_DSP_POP 
3d11 cd 16 22			call macro_forth_dsp_pop 
3d14				endm 
# End of macro FORTH_DSP_POP
3d14			 
3d14 e5					push hl 
3d15			 
3d15					FORTH_DSP_VALUEHL 
3d15 cd 5e 21			call macro_dsp_valuehl 
3d18				endm 
# End of macro FORTH_DSP_VALUEHL
3d18			 
3d18					FORTH_DSP_POP 
3d18 cd 16 22			call macro_forth_dsp_pop 
3d1b				endm 
# End of macro FORTH_DSP_POP
3d1b			 
3d1b d1					pop de 
3d1c			 
3d1c cd a9 0c				call info_panel 
3d1f			 
3d1f			 
3d1f					NEXTW 
3d1f c3 0d 23			jp macro_next 
3d22				endm 
# End of macro NEXTW
3d22			.ATP: 
3d22				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3d22 62				db WORD_SYS_CORE+78             
3d23 99 3d			dw .FB            
3d25 04				db 3 + 1 
3d26 .. 00			db "AT?",0              
3d2a				endm 
# End of macro CWHEAD
3d2a			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3d2a					if DEBUG_FORTH_WORDS_KEY 
3d2a						DMARK "AT?" 
3d2a f5				push af  
3d2b 3a 3f 3d			ld a, (.dmark)  
3d2e 32 6e fe			ld (debug_mark),a  
3d31 3a 40 3d			ld a, (.dmark+1)  
3d34 32 6f fe			ld (debug_mark+1),a  
3d37 3a 41 3d			ld a, (.dmark+2)  
3d3a 32 70 fe			ld (debug_mark+2),a  
3d3d 18 03			jr .pastdmark  
3d3f ..			.dmark: db "AT?"  
3d42 f1			.pastdmark: pop af  
3d43			endm  
# End of macro DMARK
3d43						CALLMONITOR 
3d43 cd f3 18			call break_point_state  
3d46				endm  
# End of macro CALLMONITOR
3d46					endif 
3d46 3a 65 fa				ld a, (f_cursor_ptr) 
3d49			 
3d49			if DEBUG_FORTH_WORDS 
3d49				DMARK "AT?" 
3d49 f5				push af  
3d4a 3a 5e 3d			ld a, (.dmark)  
3d4d 32 6e fe			ld (debug_mark),a  
3d50 3a 5f 3d			ld a, (.dmark+1)  
3d53 32 6f fe			ld (debug_mark+1),a  
3d56 3a 60 3d			ld a, (.dmark+2)  
3d59 32 70 fe			ld (debug_mark+2),a  
3d5c 18 03			jr .pastdmark  
3d5e ..			.dmark: db "AT?"  
3d61 f1			.pastdmark: pop af  
3d62			endm  
# End of macro DMARK
3d62				CALLMONITOR 
3d62 cd f3 18			call break_point_state  
3d65				endm  
# End of macro CALLMONITOR
3d65			endif	 
3d65					; count the number of rows 
3d65			 
3d65 06 00				ld b, 0 
3d67 4f			.atpr:		ld c, a    ; save in case we go below zero 
3d68 d6 28				sub display_cols 
3d6a f2 70 3d				jp p, .atprunder 
3d6d 04					inc b 
3d6e 18 f7				jr .atpr 
3d70			.atprunder:	 
3d70			if DEBUG_FORTH_WORDS 
3d70				DMARK "A?2" 
3d70 f5				push af  
3d71 3a 85 3d			ld a, (.dmark)  
3d74 32 6e fe			ld (debug_mark),a  
3d77 3a 86 3d			ld a, (.dmark+1)  
3d7a 32 6f fe			ld (debug_mark+1),a  
3d7d 3a 87 3d			ld a, (.dmark+2)  
3d80 32 70 fe			ld (debug_mark+2),a  
3d83 18 03			jr .pastdmark  
3d85 ..			.dmark: db "A?2"  
3d88 f1			.pastdmark: pop af  
3d89			endm  
# End of macro DMARK
3d89				CALLMONITOR 
3d89 cd f3 18			call break_point_state  
3d8c				endm  
# End of macro CALLMONITOR
3d8c			endif	 
3d8c 26 00				ld h, 0 
3d8e 69					ld l, c 
3d8f cd 67 1f				call forth_push_numhl 
3d92 68					ld l, b  
3d93 cd 67 1f				call forth_push_numhl 
3d96			 
3d96			 
3d96				NEXTW 
3d96 c3 0d 23			jp macro_next 
3d99				endm 
# End of macro NEXTW
3d99			 
3d99			.FB: 
3d99				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3d99 1b				db WORD_SYS_CORE+7             
3d9a e7 3d			dw .EMIT            
3d9c 03				db 2 + 1 
3d9d .. 00			db "FB",0              
3da0				endm 
# End of macro CWHEAD
3da0			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3da0			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3da0			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3da0			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3da0					if DEBUG_FORTH_WORDS_KEY 
3da0						DMARK "FB." 
3da0 f5				push af  
3da1 3a b5 3d			ld a, (.dmark)  
3da4 32 6e fe			ld (debug_mark),a  
3da7 3a b6 3d			ld a, (.dmark+1)  
3daa 32 6f fe			ld (debug_mark+1),a  
3dad 3a b7 3d			ld a, (.dmark+2)  
3db0 32 70 fe			ld (debug_mark+2),a  
3db3 18 03			jr .pastdmark  
3db5 ..			.dmark: db "FB."  
3db8 f1			.pastdmark: pop af  
3db9			endm  
# End of macro DMARK
3db9						CALLMONITOR 
3db9 cd f3 18			call break_point_state  
3dbc				endm  
# End of macro CALLMONITOR
3dbc					endif 
3dbc			 
3dbc					FORTH_DSP_VALUEHL 
3dbc cd 5e 21			call macro_dsp_valuehl 
3dbf				endm 
# End of macro FORTH_DSP_VALUEHL
3dbf			 
3dbf 7d					ld a, l 
3dc0 fe 01				cp 1 
3dc2 20 05				jr nz, .fbn1 
3dc4 21 13 fd				ld hl, display_fb1 
3dc7 18 15				jr .fbset 
3dc9 fe 02		.fbn1:		cp 2 
3dcb 20 05				jr nz, .fbn2 
3dcd 21 d1 fb				ld hl, display_fb2 
3dd0 18 0c				jr .fbset 
3dd2 fe 03		.fbn2:		cp 3 
3dd4 20 05				jr nz, .fbn3 
3dd6 21 72 fc				ld hl, display_fb3 
3dd9 18 03				jr .fbset 
3ddb			.fbn3:		 ; if invalid number select first 
3ddb 21 13 fd				ld hl, display_fb1 
3dde 22 cf fb		.fbset:		ld (display_fb_active), hl 
3de1			 
3de1					FORTH_DSP_POP 
3de1 cd 16 22			call macro_forth_dsp_pop 
3de4				endm 
# End of macro FORTH_DSP_POP
3de4			 
3de4					NEXTW 
3de4 c3 0d 23			jp macro_next 
3de7				endm 
# End of macro NEXTW
3de7			 
3de7			 
3de7			.EMIT: 
3de7				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3de7 1b				db WORD_SYS_CORE+7             
3de8 38 3e			dw .DOTH            
3dea 05				db 4 + 1 
3deb .. 00			db "EMIT",0              
3df0				endm 
# End of macro CWHEAD
3df0			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3df0					; get value off TOS and display it 
3df0			 
3df0					if DEBUG_FORTH_WORDS_KEY 
3df0						DMARK "EMT" 
3df0 f5				push af  
3df1 3a 05 3e			ld a, (.dmark)  
3df4 32 6e fe			ld (debug_mark),a  
3df7 3a 06 3e			ld a, (.dmark+1)  
3dfa 32 6f fe			ld (debug_mark+1),a  
3dfd 3a 07 3e			ld a, (.dmark+2)  
3e00 32 70 fe			ld (debug_mark+2),a  
3e03 18 03			jr .pastdmark  
3e05 ..			.dmark: db "EMT"  
3e08 f1			.pastdmark: pop af  
3e09			endm  
# End of macro DMARK
3e09						CALLMONITOR 
3e09 cd f3 18			call break_point_state  
3e0c				endm  
# End of macro CALLMONITOR
3e0c					endif 
3e0c			 
3e0c					FORTH_DSP_VALUEHL 
3e0c cd 5e 21			call macro_dsp_valuehl 
3e0f				endm 
# End of macro FORTH_DSP_VALUEHL
3e0f			 
3e0f 7d					ld a,l 
3e10			 
3e10					; TODO write to display 
3e10			 
3e10 32 c6 f3				ld (os_input), a 
3e13 3e 00				ld a, 0 
3e15 32 c7 f3				ld (os_input+1), a 
3e18					 
3e18 3a 65 fa				ld a, (f_cursor_ptr) 
3e1b 11 c6 f3				ld de, os_input 
3e1e cd 2b 0d				call str_at_display 
3e21			 
3e21			 
3e21 3a 43 fa				ld a,(cli_autodisplay) 
3e24 fe 00				cp 0 
3e26 28 03				jr z, .enoupdate 
3e28 cd 3b 0d						call update_display 
3e2b					.enoupdate: 
3e2b			 
3e2b 3a 65 fa				ld a, (f_cursor_ptr) 
3e2e 3c					inc a 
3e2f 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
3e32			 
3e32			 
3e32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e32 cd 16 22			call macro_forth_dsp_pop 
3e35				endm 
# End of macro FORTH_DSP_POP
3e35			  
3e35			 
3e35					NEXTW 
3e35 c3 0d 23			jp macro_next 
3e38				endm 
# End of macro NEXTW
3e38			.DOTH: 
3e38				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3e38 1c				db WORD_SYS_CORE+8             
3e39 68 3e			dw .DOTF            
3e3b 03				db 2 + 1 
3e3c .. 00			db ".-",0              
3e3f				endm 
# End of macro CWHEAD
3e3f			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3e3f					; get value off TOS and display it 
3e3f					if DEBUG_FORTH_WORDS_KEY 
3e3f						DMARK "DTD" 
3e3f f5				push af  
3e40 3a 54 3e			ld a, (.dmark)  
3e43 32 6e fe			ld (debug_mark),a  
3e46 3a 55 3e			ld a, (.dmark+1)  
3e49 32 6f fe			ld (debug_mark+1),a  
3e4c 3a 56 3e			ld a, (.dmark+2)  
3e4f 32 70 fe			ld (debug_mark+2),a  
3e52 18 03			jr .pastdmark  
3e54 ..			.dmark: db "DTD"  
3e57 f1			.pastdmark: pop af  
3e58			endm  
# End of macro DMARK
3e58						CALLMONITOR 
3e58 cd f3 18			call break_point_state  
3e5b				endm  
# End of macro CALLMONITOR
3e5b					endif 
3e5b 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3e5d 3e 00			ld a, 0 
3e5f 32 44 fa			ld (cli_mvdot), a 
3e62 c3 bf 3e			jp .dotgo 
3e65				NEXTW 
3e65 c3 0d 23			jp macro_next 
3e68				endm 
# End of macro NEXTW
3e68			.DOTF: 
3e68				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3e68 1c				db WORD_SYS_CORE+8             
3e69 96 3e			dw .DOT            
3e6b 03				db 2 + 1 
3e6c .. 00			db ".>",0              
3e6f				endm 
# End of macro CWHEAD
3e6f			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3e6f					; get value off TOS and display it 
3e6f			        ; TODO BUG adds extra spaces 
3e6f			        ; TODO BUG handle numerics? 
3e6f					if DEBUG_FORTH_WORDS_KEY 
3e6f						DMARK "DTC" 
3e6f f5				push af  
3e70 3a 84 3e			ld a, (.dmark)  
3e73 32 6e fe			ld (debug_mark),a  
3e76 3a 85 3e			ld a, (.dmark+1)  
3e79 32 6f fe			ld (debug_mark+1),a  
3e7c 3a 86 3e			ld a, (.dmark+2)  
3e7f 32 70 fe			ld (debug_mark+2),a  
3e82 18 03			jr .pastdmark  
3e84 ..			.dmark: db "DTC"  
3e87 f1			.pastdmark: pop af  
3e88			endm  
# End of macro DMARK
3e88						CALLMONITOR 
3e88 cd f3 18			call break_point_state  
3e8b				endm  
# End of macro CALLMONITOR
3e8b					endif 
3e8b 3e 01			ld a, 1 
3e8d 32 44 fa			ld (cli_mvdot), a 
3e90 c3 bf 3e			jp .dotgo 
3e93				NEXTW 
3e93 c3 0d 23			jp macro_next 
3e96				endm 
# End of macro NEXTW
3e96			 
3e96			.DOT: 
3e96				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3e96 1c				db WORD_SYS_CORE+8             
3e97 72 40			dw .CLS            
3e99 02				db 1 + 1 
3e9a .. 00			db ".",0              
3e9c				endm 
# End of macro CWHEAD
3e9c			        ; | . ( u -- ) Display TOS | DONE 
3e9c					; get value off TOS and display it 
3e9c			 
3e9c					if DEBUG_FORTH_WORDS_KEY 
3e9c						DMARK "DOT" 
3e9c f5				push af  
3e9d 3a b1 3e			ld a, (.dmark)  
3ea0 32 6e fe			ld (debug_mark),a  
3ea3 3a b2 3e			ld a, (.dmark+1)  
3ea6 32 6f fe			ld (debug_mark+1),a  
3ea9 3a b3 3e			ld a, (.dmark+2)  
3eac 32 70 fe			ld (debug_mark+2),a  
3eaf 18 03			jr .pastdmark  
3eb1 ..			.dmark: db "DOT"  
3eb4 f1			.pastdmark: pop af  
3eb5			endm  
# End of macro DMARK
3eb5						CALLMONITOR 
3eb5 cd f3 18			call break_point_state  
3eb8				endm  
# End of macro CALLMONITOR
3eb8					endif 
3eb8 3e 00			ld a, 0 
3eba 32 44 fa			ld (cli_mvdot), a 
3ebd 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3ebf				 
3ebf			 
3ebf			.dotgo: 
3ebf			 
3ebf			; move up type to on stack for parserv5 
3ebf					FORTH_DSP 
3ebf cd 24 21			call macro_forth_dsp 
3ec2				endm 
# End of macro FORTH_DSP
3ec2				;FORTH_DSP_VALUE  
3ec2			 
3ec2			if DEBUG_FORTH_DOT 
3ec2				DMARK "DOT" 
3ec2 f5				push af  
3ec3 3a d7 3e			ld a, (.dmark)  
3ec6 32 6e fe			ld (debug_mark),a  
3ec9 3a d8 3e			ld a, (.dmark+1)  
3ecc 32 6f fe			ld (debug_mark+1),a  
3ecf 3a d9 3e			ld a, (.dmark+2)  
3ed2 32 70 fe			ld (debug_mark+2),a  
3ed5 18 03			jr .pastdmark  
3ed7 ..			.dmark: db "DOT"  
3eda f1			.pastdmark: pop af  
3edb			endm  
# End of macro DMARK
3edb				CALLMONITOR 
3edb cd f3 18			call break_point_state  
3ede				endm  
# End of macro CALLMONITOR
3ede			endif	 
3ede			;		.print: 
3ede			 
3ede 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3edf 23				inc hl   ; position to the actual value 
3ee0 fe 01			cp DS_TYPE_STR 
3ee2 20 06			jr nz, .dotnum1  
3ee4			 
3ee4			; display string 
3ee4				FORTH_DSP_VALUE  
3ee4 cd 47 21			call macro_forth_dsp_value 
3ee7				endm 
# End of macro FORTH_DSP_VALUE
3ee7 eb				ex de,hl 
3ee8 18 49			jr .dotwrite 
3eea			 
3eea			.dotnum1: 
3eea fe 02			cp DS_TYPE_INUM 
3eec 20 44			jr nz, .dotflot 
3eee			 
3eee			 
3eee			; display number 
3eee			 
3eee			;	push hl 
3eee			;	call clear_display 
3eee			;	pop hl 
3eee			 
3eee 5e				ld e, (hl) 
3eef 23				inc hl 
3ef0 56				ld d, (hl) 
3ef1 21 c8 f1			ld hl, scratch 
3ef4			if DEBUG_FORTH_DOT 
3ef4				DMARK "DT1" 
3ef4 f5				push af  
3ef5 3a 09 3f			ld a, (.dmark)  
3ef8 32 6e fe			ld (debug_mark),a  
3efb 3a 0a 3f			ld a, (.dmark+1)  
3efe 32 6f fe			ld (debug_mark+1),a  
3f01 3a 0b 3f			ld a, (.dmark+2)  
3f04 32 70 fe			ld (debug_mark+2),a  
3f07 18 03			jr .pastdmark  
3f09 ..			.dmark: db "DT1"  
3f0c f1			.pastdmark: pop af  
3f0d			endm  
# End of macro DMARK
3f0d				CALLMONITOR 
3f0d cd f3 18			call break_point_state  
3f10				endm  
# End of macro CALLMONITOR
3f10			endif	 
3f10			 
3f10 cd 59 13			call uitoa_16 
3f13 eb				ex de,hl 
3f14			 
3f14			if DEBUG_FORTH_DOT 
3f14				DMARK "DT2" 
3f14 f5				push af  
3f15 3a 29 3f			ld a, (.dmark)  
3f18 32 6e fe			ld (debug_mark),a  
3f1b 3a 2a 3f			ld a, (.dmark+1)  
3f1e 32 6f fe			ld (debug_mark+1),a  
3f21 3a 2b 3f			ld a, (.dmark+2)  
3f24 32 70 fe			ld (debug_mark+2),a  
3f27 18 03			jr .pastdmark  
3f29 ..			.dmark: db "DT2"  
3f2c f1			.pastdmark: pop af  
3f2d			endm  
# End of macro DMARK
3f2d				CALLMONITOR 
3f2d cd f3 18			call break_point_state  
3f30				endm  
# End of macro CALLMONITOR
3f30			endif	 
3f30			 
3f30			;	ld de, os_word_scratch 
3f30 18 01			jr .dotwrite 
3f32			 
3f32 00			.dotflot:   nop 
3f33			; TODO print floating point number 
3f33			 
3f33			.dotwrite:		 
3f33			 
3f33					; if c is set then set all '-' to spaces 
3f33					; need to also take into account .>  
3f33			 
3f33 3e 01				ld a, 1 
3f35 b9					cp c 
3f36 20 67				jr nz, .nodashswap 
3f38			 
3f38					; DE has the string to write, working with HL 
3f38			 
3f38 06 ff				ld b, 255 
3f3a d5					push de 
3f3b e1					pop hl 
3f3c			 
3f3c			if DEBUG_FORTH_DOT 
3f3c				DMARK "DT-" 
3f3c f5				push af  
3f3d 3a 51 3f			ld a, (.dmark)  
3f40 32 6e fe			ld (debug_mark),a  
3f43 3a 52 3f			ld a, (.dmark+1)  
3f46 32 6f fe			ld (debug_mark+1),a  
3f49 3a 53 3f			ld a, (.dmark+2)  
3f4c 32 70 fe			ld (debug_mark+2),a  
3f4f 18 03			jr .pastdmark  
3f51 ..			.dmark: db "DT-"  
3f54 f1			.pastdmark: pop af  
3f55			endm  
# End of macro DMARK
3f55				CALLMONITOR 
3f55 cd f3 18			call break_point_state  
3f58				endm  
# End of macro CALLMONITOR
3f58			endif	 
3f58 7e			.dashscan:	ld a, (hl) 
3f59 fe 00				cp 0 
3f5b 28 42				jr z, .nodashswap 
3f5d fe 2d				cp '-' 
3f5f 20 03				jr nz, .dashskip 
3f61 3e 20				ld a, ' ' 
3f63 77					ld (hl), a 
3f64 23			.dashskip:	inc hl 
3f65			if DEBUG_FORTH_DOT 
3f65				DMARK "D-2" 
3f65 f5				push af  
3f66 3a 7a 3f			ld a, (.dmark)  
3f69 32 6e fe			ld (debug_mark),a  
3f6c 3a 7b 3f			ld a, (.dmark+1)  
3f6f 32 6f fe			ld (debug_mark+1),a  
3f72 3a 7c 3f			ld a, (.dmark+2)  
3f75 32 70 fe			ld (debug_mark+2),a  
3f78 18 03			jr .pastdmark  
3f7a ..			.dmark: db "D-2"  
3f7d f1			.pastdmark: pop af  
3f7e			endm  
# End of macro DMARK
3f7e				CALLMONITOR 
3f7e cd f3 18			call break_point_state  
3f81				endm  
# End of macro CALLMONITOR
3f81			endif	 
3f81 10 d5				djnz .dashscan 
3f83			 
3f83			if DEBUG_FORTH_DOT 
3f83				DMARK "D-1" 
3f83 f5				push af  
3f84 3a 98 3f			ld a, (.dmark)  
3f87 32 6e fe			ld (debug_mark),a  
3f8a 3a 99 3f			ld a, (.dmark+1)  
3f8d 32 6f fe			ld (debug_mark+1),a  
3f90 3a 9a 3f			ld a, (.dmark+2)  
3f93 32 70 fe			ld (debug_mark+2),a  
3f96 18 03			jr .pastdmark  
3f98 ..			.dmark: db "D-1"  
3f9b f1			.pastdmark: pop af  
3f9c			endm  
# End of macro DMARK
3f9c				CALLMONITOR 
3f9c cd f3 18			call break_point_state  
3f9f				endm  
# End of macro CALLMONITOR
3f9f			endif	 
3f9f			 
3f9f			.nodashswap: 
3f9f			 
3f9f			if DEBUG_FORTH_DOT 
3f9f				DMARK "D-o" 
3f9f f5				push af  
3fa0 3a b4 3f			ld a, (.dmark)  
3fa3 32 6e fe			ld (debug_mark),a  
3fa6 3a b5 3f			ld a, (.dmark+1)  
3fa9 32 6f fe			ld (debug_mark+1),a  
3fac 3a b6 3f			ld a, (.dmark+2)  
3faf 32 70 fe			ld (debug_mark+2),a  
3fb2 18 03			jr .pastdmark  
3fb4 ..			.dmark: db "D-o"  
3fb7 f1			.pastdmark: pop af  
3fb8			endm  
# End of macro DMARK
3fb8				CALLMONITOR 
3fb8 cd f3 18			call break_point_state  
3fbb				endm  
# End of macro CALLMONITOR
3fbb			endif	 
3fbb			 
3fbb d5					push de   ; save string start in case we need to advance print 
3fbc			 
3fbc 3a 65 fa				ld a, (f_cursor_ptr) 
3fbf cd 2b 0d				call str_at_display 
3fc2 3a 43 fa				ld a,(cli_autodisplay) 
3fc5 fe 00				cp 0 
3fc7 28 03				jr z, .noupdate 
3fc9 cd 3b 0d						call update_display 
3fcc					.noupdate: 
3fcc			 
3fcc			 
3fcc					; see if we need to advance the print position 
3fcc			 
3fcc e1					pop hl   ; get back string 
3fcd			;		ex de,hl 
3fcd			 
3fcd 3a 44 fa				ld a, (cli_mvdot) 
3fd0			if DEBUG_FORTH_DOT 
3fd0			;		ld e,a 
3fd0				DMARK "D>1" 
3fd0 f5				push af  
3fd1 3a e5 3f			ld a, (.dmark)  
3fd4 32 6e fe			ld (debug_mark),a  
3fd7 3a e6 3f			ld a, (.dmark+1)  
3fda 32 6f fe			ld (debug_mark+1),a  
3fdd 3a e7 3f			ld a, (.dmark+2)  
3fe0 32 70 fe			ld (debug_mark+2),a  
3fe3 18 03			jr .pastdmark  
3fe5 ..			.dmark: db "D>1"  
3fe8 f1			.pastdmark: pop af  
3fe9			endm  
# End of macro DMARK
3fe9				CALLMONITOR 
3fe9 cd f3 18			call break_point_state  
3fec				endm  
# End of macro CALLMONITOR
3fec			endif	 
3fec fe 00				cp 0 
3fee 28 44				jr z, .noadv 
3ff0					; yes, lets advance the print position 
3ff0 3e 00				ld a, 0 
3ff2 cd b5 13				call strlent 
3ff5			if DEBUG_FORTH_DOT 
3ff5				DMARK "D-?" 
3ff5 f5				push af  
3ff6 3a 0a 40			ld a, (.dmark)  
3ff9 32 6e fe			ld (debug_mark),a  
3ffc 3a 0b 40			ld a, (.dmark+1)  
3fff 32 6f fe			ld (debug_mark+1),a  
4002 3a 0c 40			ld a, (.dmark+2)  
4005 32 70 fe			ld (debug_mark+2),a  
4008 18 03			jr .pastdmark  
400a ..			.dmark: db "D-?"  
400d f1			.pastdmark: pop af  
400e			endm  
# End of macro DMARK
400e				CALLMONITOR 
400e cd f3 18			call break_point_state  
4011				endm  
# End of macro CALLMONITOR
4011			endif	 
4011 3a 65 fa				ld a, (f_cursor_ptr) 
4014 85					add a,l 
4015					;call addatohl 
4015					;ld a, l 
4015 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
4018			 
4018			if DEBUG_FORTH_DOT 
4018				DMARK "D->" 
4018 f5				push af  
4019 3a 2d 40			ld a, (.dmark)  
401c 32 6e fe			ld (debug_mark),a  
401f 3a 2e 40			ld a, (.dmark+1)  
4022 32 6f fe			ld (debug_mark+1),a  
4025 3a 2f 40			ld a, (.dmark+2)  
4028 32 70 fe			ld (debug_mark+2),a  
402b 18 03			jr .pastdmark  
402d ..			.dmark: db "D->"  
4030 f1			.pastdmark: pop af  
4031			endm  
# End of macro DMARK
4031				CALLMONITOR 
4031 cd f3 18			call break_point_state  
4034				endm  
# End of macro CALLMONITOR
4034			endif	 
4034			 
4034			.noadv:	 
4034			 
4034					if DEBUG_FORTH_DOT_WAIT 
4034							call next_page_prompt 
4034					endif	 
4034			; TODO this pop off the stack causes a crash. i dont know why 
4034			 
4034			 
4034			if DEBUG_FORTH_DOT 
4034				DMARK "DTh" 
4034 f5				push af  
4035 3a 49 40			ld a, (.dmark)  
4038 32 6e fe			ld (debug_mark),a  
403b 3a 4a 40			ld a, (.dmark+1)  
403e 32 6f fe			ld (debug_mark+1),a  
4041 3a 4b 40			ld a, (.dmark+2)  
4044 32 70 fe			ld (debug_mark+2),a  
4047 18 03			jr .pastdmark  
4049 ..			.dmark: db "DTh"  
404c f1			.pastdmark: pop af  
404d			endm  
# End of macro DMARK
404d				CALLMONITOR 
404d cd f3 18			call break_point_state  
4050				endm  
# End of macro CALLMONITOR
4050			endif	 
4050			 
4050					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4050 cd 16 22			call macro_forth_dsp_pop 
4053				endm 
# End of macro FORTH_DSP_POP
4053			 
4053			if DEBUG_FORTH_DOT 
4053				DMARK "DTi" 
4053 f5				push af  
4054 3a 68 40			ld a, (.dmark)  
4057 32 6e fe			ld (debug_mark),a  
405a 3a 69 40			ld a, (.dmark+1)  
405d 32 6f fe			ld (debug_mark+1),a  
4060 3a 6a 40			ld a, (.dmark+2)  
4063 32 70 fe			ld (debug_mark+2),a  
4066 18 03			jr .pastdmark  
4068 ..			.dmark: db "DTi"  
406b f1			.pastdmark: pop af  
406c			endm  
# End of macro DMARK
406c				CALLMONITOR 
406c cd f3 18			call break_point_state  
406f				endm  
# End of macro CALLMONITOR
406f			endif	 
406f			 
406f			 
406f					NEXTW 
406f c3 0d 23			jp macro_next 
4072				endm 
# End of macro NEXTW
4072			 
4072			.CLS: 
4072				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4072 35				db WORD_SYS_CORE+33             
4073 9f 40			dw .DRAW            
4075 04				db 3 + 1 
4076 .. 00			db "CLS",0              
407a				endm 
# End of macro CWHEAD
407a			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
407a					if DEBUG_FORTH_WORDS_KEY 
407a						DMARK "CLS" 
407a f5				push af  
407b 3a 8f 40			ld a, (.dmark)  
407e 32 6e fe			ld (debug_mark),a  
4081 3a 90 40			ld a, (.dmark+1)  
4084 32 6f fe			ld (debug_mark+1),a  
4087 3a 91 40			ld a, (.dmark+2)  
408a 32 70 fe			ld (debug_mark+2),a  
408d 18 03			jr .pastdmark  
408f ..			.dmark: db "CLS"  
4092 f1			.pastdmark: pop af  
4093			endm  
# End of macro DMARK
4093						CALLMONITOR 
4093 cd f3 18			call break_point_state  
4096				endm  
# End of macro CALLMONITOR
4096					endif 
4096 cd 18 0d				call clear_display 
4099 c3 ad 41				jp .home		; and home cursor 
409c					NEXTW 
409c c3 0d 23			jp macro_next 
409f				endm 
# End of macro NEXTW
409f			 
409f			.DRAW: 
409f				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
409f 36				db WORD_SYS_CORE+34             
40a0 ca 40			dw .DUMP            
40a2 05				db 4 + 1 
40a3 .. 00			db "DRAW",0              
40a8				endm 
# End of macro CWHEAD
40a8			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
40a8					if DEBUG_FORTH_WORDS_KEY 
40a8						DMARK "DRW" 
40a8 f5				push af  
40a9 3a bd 40			ld a, (.dmark)  
40ac 32 6e fe			ld (debug_mark),a  
40af 3a be 40			ld a, (.dmark+1)  
40b2 32 6f fe			ld (debug_mark+1),a  
40b5 3a bf 40			ld a, (.dmark+2)  
40b8 32 70 fe			ld (debug_mark+2),a  
40bb 18 03			jr .pastdmark  
40bd ..			.dmark: db "DRW"  
40c0 f1			.pastdmark: pop af  
40c1			endm  
# End of macro DMARK
40c1						CALLMONITOR 
40c1 cd f3 18			call break_point_state  
40c4				endm  
# End of macro CALLMONITOR
40c4					endif 
40c4 cd 3b 0d				call update_display 
40c7					NEXTW 
40c7 c3 0d 23			jp macro_next 
40ca				endm 
# End of macro NEXTW
40ca			 
40ca			.DUMP: 
40ca				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
40ca 37				db WORD_SYS_CORE+35             
40cb 02 41			dw .CDUMP            
40cd 05				db 4 + 1 
40ce .. 00			db "DUMP",0              
40d3				endm 
# End of macro CWHEAD
40d3			; | DUMP ( x -- ) With address x display dump   | DONE 
40d3			; TODO pop address to use off of the stack 
40d3					if DEBUG_FORTH_WORDS_KEY 
40d3						DMARK "DUM" 
40d3 f5				push af  
40d4 3a e8 40			ld a, (.dmark)  
40d7 32 6e fe			ld (debug_mark),a  
40da 3a e9 40			ld a, (.dmark+1)  
40dd 32 6f fe			ld (debug_mark+1),a  
40e0 3a ea 40			ld a, (.dmark+2)  
40e3 32 70 fe			ld (debug_mark+2),a  
40e6 18 03			jr .pastdmark  
40e8 ..			.dmark: db "DUM"  
40eb f1			.pastdmark: pop af  
40ec			endm  
# End of macro DMARK
40ec						CALLMONITOR 
40ec cd f3 18			call break_point_state  
40ef				endm  
# End of macro CALLMONITOR
40ef					endif 
40ef cd 18 0d				call clear_display 
40f2			 
40f2					; get address 
40f2			 
40f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40f2 cd 5e 21			call macro_dsp_valuehl 
40f5				endm 
# End of macro FORTH_DSP_VALUEHL
40f5				 
40f5					; save it for cdump 
40f5			 
40f5 22 eb f4				ld (os_cur_ptr),hl 
40f8			 
40f8					; destroy value TOS 
40f8			 
40f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40f8 cd 16 22			call macro_forth_dsp_pop 
40fb				endm 
# End of macro FORTH_DSP_POP
40fb			 
40fb cd e7 1d				call dumpcont	; skip old style of param parsing	 
40fe c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
40ff					NEXTW 
40ff c3 0d 23			jp macro_next 
4102				endm 
# End of macro NEXTW
4102			.CDUMP: 
4102				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4102 38				db WORD_SYS_CORE+36             
4103 32 41			dw .DAT            
4105 06				db 5 + 1 
4106 .. 00			db "CDUMP",0              
410c				endm 
# End of macro CWHEAD
410c			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
410c					if DEBUG_FORTH_WORDS_KEY 
410c						DMARK "CDP" 
410c f5				push af  
410d 3a 21 41			ld a, (.dmark)  
4110 32 6e fe			ld (debug_mark),a  
4113 3a 22 41			ld a, (.dmark+1)  
4116 32 6f fe			ld (debug_mark+1),a  
4119 3a 23 41			ld a, (.dmark+2)  
411c 32 70 fe			ld (debug_mark+2),a  
411f 18 03			jr .pastdmark  
4121 ..			.dmark: db "CDP"  
4124 f1			.pastdmark: pop af  
4125			endm  
# End of macro DMARK
4125						CALLMONITOR 
4125 cd f3 18			call break_point_state  
4128				endm  
# End of macro CALLMONITOR
4128					endif 
4128 cd 18 0d				call clear_display 
412b cd e7 1d				call dumpcont	 
412e c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
412f					NEXTW 
412f c3 0d 23			jp macro_next 
4132				endm 
# End of macro NEXTW
4132			 
4132			 
4132			 
4132			 
4132			.DAT: 
4132				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4132 3d				db WORD_SYS_CORE+41             
4133 88 41			dw .HOME            
4135 03				db 2 + 1 
4136 .. 00			db "AT",0              
4139				endm 
# End of macro CWHEAD
4139			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4139					if DEBUG_FORTH_WORDS_KEY 
4139						DMARK "AT." 
4139 f5				push af  
413a 3a 4e 41			ld a, (.dmark)  
413d 32 6e fe			ld (debug_mark),a  
4140 3a 4f 41			ld a, (.dmark+1)  
4143 32 6f fe			ld (debug_mark+1),a  
4146 3a 50 41			ld a, (.dmark+2)  
4149 32 70 fe			ld (debug_mark+2),a  
414c 18 03			jr .pastdmark  
414e ..			.dmark: db "AT."  
4151 f1			.pastdmark: pop af  
4152			endm  
# End of macro DMARK
4152						CALLMONITOR 
4152 cd f3 18			call break_point_state  
4155				endm  
# End of macro CALLMONITOR
4155					endif 
4155					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4155 cd 5e 21			call macro_dsp_valuehl 
4158				endm 
# End of macro FORTH_DSP_VALUEHL
4158			 
4158			 
4158					; TODO save cursor row 
4158 7d					ld a,l 
4159 fe 02				cp 2 
415b 20 04				jr nz, .crow3 
415d 3e 28				ld a, display_row_2 
415f 18 12				jr .ccol1 
4161 fe 03		.crow3:		cp 3 
4163 20 04				jr nz, .crow4 
4165 3e 50				ld a, display_row_3 
4167 18 0a				jr .ccol1 
4169 fe 04		.crow4:		cp 4 
416b 20 04				jr nz, .crow1 
416d 3e 78				ld a, display_row_4 
416f 18 02				jr .ccol1 
4171 3e 00		.crow1:		ld a,display_row_1 
4173 f5			.ccol1:		push af			; got row offset 
4174 6f					ld l,a 
4175 26 00				ld h,0 
4177					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4177 cd 16 22			call macro_forth_dsp_pop 
417a				endm 
# End of macro FORTH_DSP_POP
417a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
417a cd 5e 21			call macro_dsp_valuehl 
417d				endm 
# End of macro FORTH_DSP_VALUEHL
417d					; TODO save cursor col 
417d f1					pop af 
417e 85					add l		; add col offset 
417f 32 65 fa				ld (f_cursor_ptr), a 
4182					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4182 cd 16 22			call macro_forth_dsp_pop 
4185				endm 
# End of macro FORTH_DSP_POP
4185			 
4185					; calculate  
4185			 
4185					NEXTW 
4185 c3 0d 23			jp macro_next 
4188				endm 
# End of macro NEXTW
4188			 
4188			 
4188			.HOME: 
4188				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
4188 41				db WORD_SYS_CORE+45             
4189 b5 41			dw .SPACE            
418b 05				db 4 + 1 
418c .. 00			db "HOME",0              
4191				endm 
# End of macro CWHEAD
4191			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4191					if DEBUG_FORTH_WORDS_KEY 
4191						DMARK "HOM" 
4191 f5				push af  
4192 3a a6 41			ld a, (.dmark)  
4195 32 6e fe			ld (debug_mark),a  
4198 3a a7 41			ld a, (.dmark+1)  
419b 32 6f fe			ld (debug_mark+1),a  
419e 3a a8 41			ld a, (.dmark+2)  
41a1 32 70 fe			ld (debug_mark+2),a  
41a4 18 03			jr .pastdmark  
41a6 ..			.dmark: db "HOM"  
41a9 f1			.pastdmark: pop af  
41aa			endm  
# End of macro DMARK
41aa						CALLMONITOR 
41aa cd f3 18			call break_point_state  
41ad				endm  
# End of macro CALLMONITOR
41ad					endif 
41ad 3e 00		.home:		ld a, 0		; and home cursor 
41af 32 65 fa				ld (f_cursor_ptr), a 
41b2					NEXTW 
41b2 c3 0d 23			jp macro_next 
41b5				endm 
# End of macro NEXTW
41b5			 
41b5			 
41b5			.SPACE: 
41b5				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
41b5 46				db WORD_SYS_CORE+50             
41b6 e3 41			dw .SPACES            
41b8 03				db 2 + 1 
41b9 .. 00			db "BL",0              
41bc				endm 
# End of macro CWHEAD
41bc			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
41bc					if DEBUG_FORTH_WORDS_KEY 
41bc						DMARK "BL." 
41bc f5				push af  
41bd 3a d1 41			ld a, (.dmark)  
41c0 32 6e fe			ld (debug_mark),a  
41c3 3a d2 41			ld a, (.dmark+1)  
41c6 32 6f fe			ld (debug_mark+1),a  
41c9 3a d3 41			ld a, (.dmark+2)  
41cc 32 70 fe			ld (debug_mark+2),a  
41cf 18 03			jr .pastdmark  
41d1 ..			.dmark: db "BL."  
41d4 f1			.pastdmark: pop af  
41d5			endm  
# End of macro DMARK
41d5						CALLMONITOR 
41d5 cd f3 18			call break_point_state  
41d8				endm  
# End of macro CALLMONITOR
41d8					endif 
41d8 21 e1 41				ld hl, .blstr 
41db cd d5 1f				call forth_push_str 
41de					 
41de				       NEXTW 
41de c3 0d 23			jp macro_next 
41e1				endm 
# End of macro NEXTW
41e1			 
41e1 .. 00		.blstr: db " ", 0 
41e3			 
41e3			.SPACES: 
41e3				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
41e3 47				db WORD_SYS_CORE+51             
41e4 7e 42			dw .SCROLL            
41e6 07				db 6 + 1 
41e7 .. 00			db "SPACES",0              
41ee				endm 
# End of macro CWHEAD
41ee			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
41ee					if DEBUG_FORTH_WORDS_KEY 
41ee						DMARK "SPS" 
41ee f5				push af  
41ef 3a 03 42			ld a, (.dmark)  
41f2 32 6e fe			ld (debug_mark),a  
41f5 3a 04 42			ld a, (.dmark+1)  
41f8 32 6f fe			ld (debug_mark+1),a  
41fb 3a 05 42			ld a, (.dmark+2)  
41fe 32 70 fe			ld (debug_mark+2),a  
4201 18 03			jr .pastdmark  
4203 ..			.dmark: db "SPS"  
4206 f1			.pastdmark: pop af  
4207			endm  
# End of macro DMARK
4207						CALLMONITOR 
4207 cd f3 18			call break_point_state  
420a				endm  
# End of macro CALLMONITOR
420a					endif 
420a			 
420a			 
420a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
420a cd 5e 21			call macro_dsp_valuehl 
420d				endm 
# End of macro FORTH_DSP_VALUEHL
420d			 
420d			;		push hl    ; u 
420d					if DEBUG_FORTH_WORDS 
420d						DMARK "SPA" 
420d f5				push af  
420e 3a 22 42			ld a, (.dmark)  
4211 32 6e fe			ld (debug_mark),a  
4214 3a 23 42			ld a, (.dmark+1)  
4217 32 6f fe			ld (debug_mark+1),a  
421a 3a 24 42			ld a, (.dmark+2)  
421d 32 70 fe			ld (debug_mark+2),a  
4220 18 03			jr .pastdmark  
4222 ..			.dmark: db "SPA"  
4225 f1			.pastdmark: pop af  
4226			endm  
# End of macro DMARK
4226						CALLMONITOR 
4226 cd f3 18			call break_point_state  
4229				endm  
# End of macro CALLMONITOR
4229					endif 
4229			 
4229					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4229 cd 16 22			call macro_forth_dsp_pop 
422c				endm 
# End of macro FORTH_DSP_POP
422c			;		pop hl 
422c 4d					ld c, l 
422d 06 00				ld b, 0 
422f 21 c8 f1				ld hl, scratch  
4232			 
4232					if DEBUG_FORTH_WORDS 
4232						DMARK "SP2" 
4232 f5				push af  
4233 3a 47 42			ld a, (.dmark)  
4236 32 6e fe			ld (debug_mark),a  
4239 3a 48 42			ld a, (.dmark+1)  
423c 32 6f fe			ld (debug_mark+1),a  
423f 3a 49 42			ld a, (.dmark+2)  
4242 32 70 fe			ld (debug_mark+2),a  
4245 18 03			jr .pastdmark  
4247 ..			.dmark: db "SP2"  
424a f1			.pastdmark: pop af  
424b			endm  
# End of macro DMARK
424b						CALLMONITOR 
424b cd f3 18			call break_point_state  
424e				endm  
# End of macro CALLMONITOR
424e					endif 
424e 3e 20				ld a, ' ' 
4250 c5			.spaces1:	push bc 
4251 77					ld (hl),a 
4252 23					inc hl 
4253 c1					pop bc 
4254 10 fa				djnz .spaces1 
4256 3e 00				ld a,0 
4258 77					ld (hl),a 
4259 21 c8 f1				ld hl, scratch 
425c					if DEBUG_FORTH_WORDS 
425c						DMARK "SP3" 
425c f5				push af  
425d 3a 71 42			ld a, (.dmark)  
4260 32 6e fe			ld (debug_mark),a  
4263 3a 72 42			ld a, (.dmark+1)  
4266 32 6f fe			ld (debug_mark+1),a  
4269 3a 73 42			ld a, (.dmark+2)  
426c 32 70 fe			ld (debug_mark+2),a  
426f 18 03			jr .pastdmark  
4271 ..			.dmark: db "SP3"  
4274 f1			.pastdmark: pop af  
4275			endm  
# End of macro DMARK
4275						CALLMONITOR 
4275 cd f3 18			call break_point_state  
4278				endm  
# End of macro CALLMONITOR
4278					endif 
4278 cd d0 20				call forth_apush 
427b			 
427b				       NEXTW 
427b c3 0d 23			jp macro_next 
427e				endm 
# End of macro NEXTW
427e			 
427e			 
427e			 
427e			.SCROLL: 
427e				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
427e 53				db WORD_SYS_CORE+63             
427f ab 42			dw .SCROLLD            
4281 07				db 6 + 1 
4282 .. 00			db "SCROLL",0              
4289				endm 
# End of macro CWHEAD
4289			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4289					if DEBUG_FORTH_WORDS_KEY 
4289						DMARK "SCR" 
4289 f5				push af  
428a 3a 9e 42			ld a, (.dmark)  
428d 32 6e fe			ld (debug_mark),a  
4290 3a 9f 42			ld a, (.dmark+1)  
4293 32 6f fe			ld (debug_mark+1),a  
4296 3a a0 42			ld a, (.dmark+2)  
4299 32 70 fe			ld (debug_mark+2),a  
429c 18 03			jr .pastdmark  
429e ..			.dmark: db "SCR"  
42a1 f1			.pastdmark: pop af  
42a2			endm  
# End of macro DMARK
42a2						CALLMONITOR 
42a2 cd f3 18			call break_point_state  
42a5				endm  
# End of macro CALLMONITOR
42a5					endif 
42a5			 
42a5 cd da 0c			call scroll_up 
42a8			;	call update_display 
42a8			 
42a8					NEXTW 
42a8 c3 0d 23			jp macro_next 
42ab				endm 
# End of macro NEXTW
42ab			 
42ab			 
42ab			 
42ab			;		; get dir 
42ab			; 
42ab			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42ab			; 
42ab			;		push hl 
42ab			; 
42ab			;		; destroy value TOS 
42ab			; 
42ab			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42ab			; 
42ab			;		; get count 
42ab			; 
42ab			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42ab			; 
42ab			;		push hl 
42ab			; 
42ab			;		; destroy value TOS 
42ab			; 
42ab			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42ab			; 
42ab			;		; one value on hl get other one back 
42ab			; 
42ab			;		pop bc    ; count 
42ab			; 
42ab			;		pop de   ; dir 
42ab			; 
42ab			; 
42ab			;		ld b, c 
42ab			; 
42ab			;.scrolldir:     push bc 
42ab			;		push de 
42ab			; 
42ab			;		ld a, 0 
42ab			;		cp e 
42ab			;		jr z, .scrollup  
42ab			;		call scroll_down 
42ab			;		jr .scrollnext 
42ab			;.scrollup:	call scroll_up 
42ab			; 
42ab			;		 
42ab			;.scrollnext: 
42ab			;		pop de 
42ab			;		pop bc 
42ab			;		djnz .scrolldir 
42ab			; 
42ab			; 
42ab			; 
42ab			; 
42ab			; 
42ab			;		NEXTW 
42ab			 
42ab			.SCROLLD: 
42ab				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
42ab 53				db WORD_SYS_CORE+63             
42ac d9 42			dw .ATQ            
42ae 08				db 7 + 1 
42af .. 00			db "SCROLLD",0              
42b7				endm 
# End of macro CWHEAD
42b7			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
42b7					if DEBUG_FORTH_WORDS_KEY 
42b7						DMARK "SCD" 
42b7 f5				push af  
42b8 3a cc 42			ld a, (.dmark)  
42bb 32 6e fe			ld (debug_mark),a  
42be 3a cd 42			ld a, (.dmark+1)  
42c1 32 6f fe			ld (debug_mark+1),a  
42c4 3a ce 42			ld a, (.dmark+2)  
42c7 32 70 fe			ld (debug_mark+2),a  
42ca 18 03			jr .pastdmark  
42cc ..			.dmark: db "SCD"  
42cf f1			.pastdmark: pop af  
42d0			endm  
# End of macro DMARK
42d0						CALLMONITOR 
42d0 cd f3 18			call break_point_state  
42d3				endm  
# End of macro CALLMONITOR
42d3					endif 
42d3			 
42d3 cd fe 0c			call scroll_down 
42d6			;	call update_display 
42d6			 
42d6					NEXTW 
42d6 c3 0d 23			jp macro_next 
42d9				endm 
# End of macro NEXTW
42d9			 
42d9			 
42d9			.ATQ: 
42d9				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
42d9 62				db WORD_SYS_CORE+78             
42da 37 43			dw .AUTODSP            
42dc 04				db 3 + 1 
42dd .. 00			db "AT@",0              
42e1				endm 
# End of macro CWHEAD
42e1			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
42e1					if DEBUG_FORTH_WORDS_KEY 
42e1						DMARK "ATA" 
42e1 f5				push af  
42e2 3a f6 42			ld a, (.dmark)  
42e5 32 6e fe			ld (debug_mark),a  
42e8 3a f7 42			ld a, (.dmark+1)  
42eb 32 6f fe			ld (debug_mark+1),a  
42ee 3a f8 42			ld a, (.dmark+2)  
42f1 32 70 fe			ld (debug_mark+2),a  
42f4 18 03			jr .pastdmark  
42f6 ..			.dmark: db "ATA"  
42f9 f1			.pastdmark: pop af  
42fa			endm  
# End of macro DMARK
42fa						CALLMONITOR 
42fa cd f3 18			call break_point_state  
42fd				endm  
# End of macro CALLMONITOR
42fd					endif 
42fd			 
42fd			 
42fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42fd cd 5e 21			call macro_dsp_valuehl 
4300				endm 
# End of macro FORTH_DSP_VALUEHL
4300			 
4300					; TODO save cursor row 
4300 7d					ld a,l 
4301 fe 02				cp 2 
4303 20 04				jr nz, .crow3aq 
4305 3e 28				ld a, display_row_2 
4307 18 12				jr .ccol1aq 
4309 fe 03		.crow3aq:		cp 3 
430b 20 04				jr nz, .crow4aq 
430d 3e 50				ld a, display_row_3 
430f 18 0a				jr .ccol1aq 
4311 fe 04		.crow4aq:		cp 4 
4313 20 04				jr nz, .crow1aq 
4315 3e 78				ld a, display_row_4 
4317 18 02				jr .ccol1aq 
4319 3e 00		.crow1aq:		ld a,display_row_1 
431b f5			.ccol1aq:		push af			; got row offset 
431c 6f					ld l,a 
431d 26 00				ld h,0 
431f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
431f cd 16 22			call macro_forth_dsp_pop 
4322				endm 
# End of macro FORTH_DSP_POP
4322					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4322 cd 5e 21			call macro_dsp_valuehl 
4325				endm 
# End of macro FORTH_DSP_VALUEHL
4325					; TODO save cursor col 
4325 f1					pop af 
4326 85					add l		; add col offset 
4327			 
4327					; add current frame buffer address 
4327 2a cf fb				ld hl, (display_fb_active) 
432a cd 4c 0f				call addatohl 
432d			 
432d			 
432d			 
432d			 
432d					; get char frame buffer location offset in hl 
432d			 
432d 7e					ld a,(hl) 
432e 26 00				ld h, 0 
4330 6f					ld l, a 
4331			 
4331 cd 67 1f				call forth_push_numhl 
4334			 
4334			 
4334					NEXTW 
4334 c3 0d 23			jp macro_next 
4337				endm 
# End of macro NEXTW
4337			 
4337			.AUTODSP: 
4337				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4337 63				db WORD_SYS_CORE+79             
4338 4d 43			dw .MENU            
433a 05				db 4 + 1 
433b .. 00			db "ADSP",0              
4340				endm 
# End of macro CWHEAD
4340			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4340			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4340			 
4340					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4340 cd 5e 21			call macro_dsp_valuehl 
4343				endm 
# End of macro FORTH_DSP_VALUEHL
4343			 
4343			;		push hl 
4343			 
4343					; destroy value TOS 
4343			 
4343					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4343 cd 16 22			call macro_forth_dsp_pop 
4346				endm 
# End of macro FORTH_DSP_POP
4346			 
4346			;		pop hl 
4346			 
4346 7d					ld a,l 
4347 32 43 fa				ld (cli_autodisplay), a 
434a				       NEXTW 
434a c3 0d 23			jp macro_next 
434d				endm 
# End of macro NEXTW
434d			 
434d			.MENU: 
434d				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
434d 70				db WORD_SYS_CORE+92             
434e f6 43			dw .ENDDISPLAY            
4350 05				db 4 + 1 
4351 .. 00			db "MENU",0              
4356				endm 
# End of macro CWHEAD
4356			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4356			 
4356			;		; get number of items on the stack 
4356			; 
4356				 
4356					FORTH_DSP_VALUEHL 
4356 cd 5e 21			call macro_dsp_valuehl 
4359				endm 
# End of macro FORTH_DSP_VALUEHL
4359				 
4359					if DEBUG_FORTH_WORDS_KEY 
4359						DMARK "MNU" 
4359 f5				push af  
435a 3a 6e 43			ld a, (.dmark)  
435d 32 6e fe			ld (debug_mark),a  
4360 3a 6f 43			ld a, (.dmark+1)  
4363 32 6f fe			ld (debug_mark+1),a  
4366 3a 70 43			ld a, (.dmark+2)  
4369 32 70 fe			ld (debug_mark+2),a  
436c 18 03			jr .pastdmark  
436e ..			.dmark: db "MNU"  
4371 f1			.pastdmark: pop af  
4372			endm  
# End of macro DMARK
4372						CALLMONITOR 
4372 cd f3 18			call break_point_state  
4375				endm  
# End of macro CALLMONITOR
4375					endif 
4375			 
4375 45					ld b, l	 
4376 05					dec b 
4377			 
4377					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4377 cd 16 22			call macro_forth_dsp_pop 
437a				endm 
# End of macro FORTH_DSP_POP
437a			 
437a			 
437a					; go directly through the stack to pluck out the string pointers and build an array 
437a			 
437a			;		FORTH_DSP 
437a			 
437a					; hl contains top most stack item 
437a				 
437a 11 c8 f1				ld de, scratch 
437d			 
437d			.mbuild: 
437d			 
437d					FORTH_DSP_VALUEHL 
437d cd 5e 21			call macro_dsp_valuehl 
4380				endm 
# End of macro FORTH_DSP_VALUEHL
4380			 
4380					if DEBUG_FORTH_WORDS 
4380						DMARK "MN3" 
4380 f5				push af  
4381 3a 95 43			ld a, (.dmark)  
4384 32 6e fe			ld (debug_mark),a  
4387 3a 96 43			ld a, (.dmark+1)  
438a 32 6f fe			ld (debug_mark+1),a  
438d 3a 97 43			ld a, (.dmark+2)  
4390 32 70 fe			ld (debug_mark+2),a  
4393 18 03			jr .pastdmark  
4395 ..			.dmark: db "MN3"  
4398 f1			.pastdmark: pop af  
4399			endm  
# End of macro DMARK
4399						CALLMONITOR 
4399 cd f3 18			call break_point_state  
439c				endm  
# End of macro CALLMONITOR
439c					endif 
439c eb					ex de, hl 
439d 73					ld (hl), e 
439e 23					inc hl 
439f 72					ld (hl), d 
43a0 23					inc hl 
43a1 eb					ex de, hl 
43a2			 
43a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43a2 cd 16 22			call macro_forth_dsp_pop 
43a5				endm 
# End of macro FORTH_DSP_POP
43a5			 
43a5 10 d6				djnz .mbuild 
43a7			 
43a7					; done add term 
43a7			 
43a7 eb					ex de, hl 
43a8 36 00				ld (hl), 0 
43aa 23					inc hl 
43ab 36 00				ld (hl), 0 
43ad			 
43ad				 
43ad					 
43ad 21 c8 f1				ld hl, scratch 
43b0			 
43b0					if DEBUG_FORTH_WORDS 
43b0						DMARK "MNx" 
43b0 f5				push af  
43b1 3a c5 43			ld a, (.dmark)  
43b4 32 6e fe			ld (debug_mark),a  
43b7 3a c6 43			ld a, (.dmark+1)  
43ba 32 6f fe			ld (debug_mark+1),a  
43bd 3a c7 43			ld a, (.dmark+2)  
43c0 32 70 fe			ld (debug_mark+2),a  
43c3 18 03			jr .pastdmark  
43c5 ..			.dmark: db "MNx"  
43c8 f1			.pastdmark: pop af  
43c9			endm  
# End of macro DMARK
43c9						CALLMONITOR 
43c9 cd f3 18			call break_point_state  
43cc				endm  
# End of macro CALLMONITOR
43cc					endif 
43cc			 
43cc			 
43cc			 
43cc 3e 00				ld a, 0 
43ce cd 49 0d				call menu 
43d1			 
43d1			 
43d1 6f					ld l, a 
43d2 26 00				ld h, 0 
43d4			 
43d4					if DEBUG_FORTH_WORDS 
43d4						DMARK "MNr" 
43d4 f5				push af  
43d5 3a e9 43			ld a, (.dmark)  
43d8 32 6e fe			ld (debug_mark),a  
43db 3a ea 43			ld a, (.dmark+1)  
43de 32 6f fe			ld (debug_mark+1),a  
43e1 3a eb 43			ld a, (.dmark+2)  
43e4 32 70 fe			ld (debug_mark+2),a  
43e7 18 03			jr .pastdmark  
43e9 ..			.dmark: db "MNr"  
43ec f1			.pastdmark: pop af  
43ed			endm  
# End of macro DMARK
43ed						CALLMONITOR 
43ed cd f3 18			call break_point_state  
43f0				endm  
# End of macro CALLMONITOR
43f0					endif 
43f0			 
43f0 cd 67 1f				call forth_push_numhl 
43f3			 
43f3			 
43f3			 
43f3			 
43f3				       NEXTW 
43f3 c3 0d 23			jp macro_next 
43f6				endm 
# End of macro NEXTW
43f6			 
43f6			 
43f6			.ENDDISPLAY: 
43f6			 
43f6			; eof 
# End of file forth_words_display.asm
43f6			include "forth_words_str.asm" 
43f6			 
43f6			; | ## String Words 
43f6			 
43f6			.PTR:   
43f6			 
43f6				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
43f6 48				db WORD_SYS_CORE+52             
43f7 23 44			dw .STYPE            
43f9 04				db 3 + 1 
43fa .. 00			db "PTR",0              
43fe				endm 
# End of macro CWHEAD
43fe			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
43fe			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
43fe			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
43fe			 
43fe					if DEBUG_FORTH_WORDS_KEY 
43fe						DMARK "PTR" 
43fe f5				push af  
43ff 3a 13 44			ld a, (.dmark)  
4402 32 6e fe			ld (debug_mark),a  
4405 3a 14 44			ld a, (.dmark+1)  
4408 32 6f fe			ld (debug_mark+1),a  
440b 3a 15 44			ld a, (.dmark+2)  
440e 32 70 fe			ld (debug_mark+2),a  
4411 18 03			jr .pastdmark  
4413 ..			.dmark: db "PTR"  
4416 f1			.pastdmark: pop af  
4417			endm  
# End of macro DMARK
4417						CALLMONITOR 
4417 cd f3 18			call break_point_state  
441a				endm  
# End of macro CALLMONITOR
441a					endif 
441a					FORTH_DSP_VALUEHL 
441a cd 5e 21			call macro_dsp_valuehl 
441d				endm 
# End of macro FORTH_DSP_VALUEHL
441d cd 67 1f				call forth_push_numhl 
4420			 
4420			 
4420					NEXTW 
4420 c3 0d 23			jp macro_next 
4423				endm 
# End of macro NEXTW
4423			.STYPE: 
4423				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4423 48				db WORD_SYS_CORE+52             
4424 72 44			dw .UPPER            
4426 06				db 5 + 1 
4427 .. 00			db "STYPE",0              
442d				endm 
# End of macro CWHEAD
442d			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
442d					if DEBUG_FORTH_WORDS_KEY 
442d						DMARK "STY" 
442d f5				push af  
442e 3a 42 44			ld a, (.dmark)  
4431 32 6e fe			ld (debug_mark),a  
4434 3a 43 44			ld a, (.dmark+1)  
4437 32 6f fe			ld (debug_mark+1),a  
443a 3a 44 44			ld a, (.dmark+2)  
443d 32 70 fe			ld (debug_mark+2),a  
4440 18 03			jr .pastdmark  
4442 ..			.dmark: db "STY"  
4445 f1			.pastdmark: pop af  
4446			endm  
# End of macro DMARK
4446						CALLMONITOR 
4446 cd f3 18			call break_point_state  
4449				endm  
# End of macro CALLMONITOR
4449					endif 
4449					FORTH_DSP 
4449 cd 24 21			call macro_forth_dsp 
444c				endm 
# End of macro FORTH_DSP
444c					;v5 FORTH_DSP_VALUE 
444c			 
444c 7e					ld a, (hl) 
444d			 
444d f5					push af 
444e			 
444e			; Dont destroy TOS		FORTH_DSP_POP 
444e			 
444e f1					pop af 
444f			 
444f fe 01				cp DS_TYPE_STR 
4451 28 09				jr z, .typestr 
4453			 
4453 fe 02				cp DS_TYPE_INUM 
4455 28 0a				jr z, .typeinum 
4457			 
4457 21 70 44				ld hl, .tna 
445a 18 0a				jr .tpush 
445c			 
445c 21 6c 44		.typestr:	ld hl, .tstr 
445f 18 05				jr .tpush 
4461 21 6e 44		.typeinum:	ld hl, .tinum 
4464 18 00				jr .tpush 
4466			 
4466			.tpush: 
4466			 
4466 cd d5 1f				call forth_push_str 
4469			 
4469					NEXTW 
4469 c3 0d 23			jp macro_next 
446c				endm 
# End of macro NEXTW
446c .. 00		.tstr:	db "s",0 
446e .. 00		.tinum:  db "i",0 
4470 .. 00		.tna:   db "?", 0 
4472			 
4472			 
4472			.UPPER: 
4472				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4472 48				db WORD_SYS_CORE+52             
4473 ad 44			dw .LOWER            
4475 06				db 5 + 1 
4476 .. 00			db "UPPER",0              
447c				endm 
# End of macro CWHEAD
447c			; | UPPER ( s -- s ) Upper case string s  | DONE 
447c					if DEBUG_FORTH_WORDS_KEY 
447c						DMARK "UPR" 
447c f5				push af  
447d 3a 91 44			ld a, (.dmark)  
4480 32 6e fe			ld (debug_mark),a  
4483 3a 92 44			ld a, (.dmark+1)  
4486 32 6f fe			ld (debug_mark+1),a  
4489 3a 93 44			ld a, (.dmark+2)  
448c 32 70 fe			ld (debug_mark+2),a  
448f 18 03			jr .pastdmark  
4491 ..			.dmark: db "UPR"  
4494 f1			.pastdmark: pop af  
4495			endm  
# End of macro DMARK
4495						CALLMONITOR 
4495 cd f3 18			call break_point_state  
4498				endm  
# End of macro CALLMONITOR
4498					endif 
4498			 
4498					FORTH_DSP 
4498 cd 24 21			call macro_forth_dsp 
449b				endm 
# End of macro FORTH_DSP
449b					 
449b			; TODO check is string type 
449b			 
449b					FORTH_DSP_VALUEHL 
449b cd 5e 21			call macro_dsp_valuehl 
449e				endm 
# End of macro FORTH_DSP_VALUEHL
449e			; get pointer to string in hl 
449e			 
449e 7e			.toup:		ld a, (hl) 
449f fe 00				cp 0 
44a1 28 07				jr z, .toupdone 
44a3			 
44a3 cd b9 12				call to_upper 
44a6			 
44a6 77					ld (hl), a 
44a7 23					inc hl 
44a8 18 f4				jr .toup 
44aa			 
44aa					 
44aa			 
44aa			 
44aa			; for each char convert to upper 
44aa					 
44aa			.toupdone: 
44aa			 
44aa			 
44aa					NEXTW 
44aa c3 0d 23			jp macro_next 
44ad				endm 
# End of macro NEXTW
44ad			.LOWER: 
44ad				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
44ad 48				db WORD_SYS_CORE+52             
44ae e8 44			dw .TCASE            
44b0 06				db 5 + 1 
44b1 .. 00			db "LOWER",0              
44b7				endm 
# End of macro CWHEAD
44b7			; | LOWER ( s -- s ) Lower case string s  | DONE 
44b7					if DEBUG_FORTH_WORDS_KEY 
44b7						DMARK "LWR" 
44b7 f5				push af  
44b8 3a cc 44			ld a, (.dmark)  
44bb 32 6e fe			ld (debug_mark),a  
44be 3a cd 44			ld a, (.dmark+1)  
44c1 32 6f fe			ld (debug_mark+1),a  
44c4 3a ce 44			ld a, (.dmark+2)  
44c7 32 70 fe			ld (debug_mark+2),a  
44ca 18 03			jr .pastdmark  
44cc ..			.dmark: db "LWR"  
44cf f1			.pastdmark: pop af  
44d0			endm  
# End of macro DMARK
44d0						CALLMONITOR 
44d0 cd f3 18			call break_point_state  
44d3				endm  
# End of macro CALLMONITOR
44d3					endif 
44d3			 
44d3					FORTH_DSP 
44d3 cd 24 21			call macro_forth_dsp 
44d6				endm 
# End of macro FORTH_DSP
44d6					 
44d6			; TODO check is string type 
44d6			 
44d6					FORTH_DSP_VALUEHL 
44d6 cd 5e 21			call macro_dsp_valuehl 
44d9				endm 
# End of macro FORTH_DSP_VALUEHL
44d9			; get pointer to string in hl 
44d9			 
44d9 7e			.tolow:		ld a, (hl) 
44da fe 00				cp 0 
44dc 28 07				jr z, .tolowdone 
44de			 
44de cd c2 12				call to_lower 
44e1			 
44e1 77					ld (hl), a 
44e2 23					inc hl 
44e3 18 f4				jr .tolow 
44e5			 
44e5					 
44e5			 
44e5			 
44e5			; for each char convert to low 
44e5					 
44e5			.tolowdone: 
44e5					NEXTW 
44e5 c3 0d 23			jp macro_next 
44e8				endm 
# End of macro NEXTW
44e8			.TCASE: 
44e8				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
44e8 48				db WORD_SYS_CORE+52             
44e9 1e 46			dw .SUBSTR            
44eb 06				db 5 + 1 
44ec .. 00			db "TCASE",0              
44f2				endm 
# End of macro CWHEAD
44f2			; | TCASE ( s -- s ) Title case string s  | DONE 
44f2					if DEBUG_FORTH_WORDS_KEY 
44f2						DMARK "TCS" 
44f2 f5				push af  
44f3 3a 07 45			ld a, (.dmark)  
44f6 32 6e fe			ld (debug_mark),a  
44f9 3a 08 45			ld a, (.dmark+1)  
44fc 32 6f fe			ld (debug_mark+1),a  
44ff 3a 09 45			ld a, (.dmark+2)  
4502 32 70 fe			ld (debug_mark+2),a  
4505 18 03			jr .pastdmark  
4507 ..			.dmark: db "TCS"  
450a f1			.pastdmark: pop af  
450b			endm  
# End of macro DMARK
450b						CALLMONITOR 
450b cd f3 18			call break_point_state  
450e				endm  
# End of macro CALLMONITOR
450e					endif 
450e			 
450e					FORTH_DSP 
450e cd 24 21			call macro_forth_dsp 
4511				endm 
# End of macro FORTH_DSP
4511					 
4511			; TODO check is string type 
4511			 
4511					FORTH_DSP_VALUEHL 
4511 cd 5e 21			call macro_dsp_valuehl 
4514				endm 
# End of macro FORTH_DSP_VALUEHL
4514			; get pointer to string in hl 
4514			 
4514					if DEBUG_FORTH_WORDS 
4514						DMARK "TC1" 
4514 f5				push af  
4515 3a 29 45			ld a, (.dmark)  
4518 32 6e fe			ld (debug_mark),a  
451b 3a 2a 45			ld a, (.dmark+1)  
451e 32 6f fe			ld (debug_mark+1),a  
4521 3a 2b 45			ld a, (.dmark+2)  
4524 32 70 fe			ld (debug_mark+2),a  
4527 18 03			jr .pastdmark  
4529 ..			.dmark: db "TC1"  
452c f1			.pastdmark: pop af  
452d			endm  
# End of macro DMARK
452d						CALLMONITOR 
452d cd f3 18			call break_point_state  
4530				endm  
# End of macro CALLMONITOR
4530					endif 
4530			 
4530					; first time in turn to upper case first char 
4530			 
4530 7e					ld a, (hl) 
4531 c3 bb 45				jp .totsiptou 
4534			 
4534			 
4534 7e			.tot:		ld a, (hl) 
4535 fe 00				cp 0 
4537 ca ff 45				jp z, .totdone 
453a			 
453a					if DEBUG_FORTH_WORDS 
453a						DMARK "TC2" 
453a f5				push af  
453b 3a 4f 45			ld a, (.dmark)  
453e 32 6e fe			ld (debug_mark),a  
4541 3a 50 45			ld a, (.dmark+1)  
4544 32 6f fe			ld (debug_mark+1),a  
4547 3a 51 45			ld a, (.dmark+2)  
454a 32 70 fe			ld (debug_mark+2),a  
454d 18 03			jr .pastdmark  
454f ..			.dmark: db "TC2"  
4552 f1			.pastdmark: pop af  
4553			endm  
# End of macro DMARK
4553						CALLMONITOR 
4553 cd f3 18			call break_point_state  
4556				endm  
# End of macro CALLMONITOR
4556					endif 
4556					; check to see if current char is a space 
4556			 
4556 fe 20				cp ' ' 
4558 28 21				jr z, .totsp 
455a cd c2 12				call to_lower 
455d					if DEBUG_FORTH_WORDS 
455d						DMARK "TC3" 
455d f5				push af  
455e 3a 72 45			ld a, (.dmark)  
4561 32 6e fe			ld (debug_mark),a  
4564 3a 73 45			ld a, (.dmark+1)  
4567 32 6f fe			ld (debug_mark+1),a  
456a 3a 74 45			ld a, (.dmark+2)  
456d 32 70 fe			ld (debug_mark+2),a  
4570 18 03			jr .pastdmark  
4572 ..			.dmark: db "TC3"  
4575 f1			.pastdmark: pop af  
4576			endm  
# End of macro DMARK
4576						CALLMONITOR 
4576 cd f3 18			call break_point_state  
4579				endm  
# End of macro CALLMONITOR
4579					endif 
4579 18 63				jr .totnxt 
457b			 
457b			.totsp:         ; on a space, find next char which should be upper 
457b			 
457b					if DEBUG_FORTH_WORDS 
457b						DMARK "TC4" 
457b f5				push af  
457c 3a 90 45			ld a, (.dmark)  
457f 32 6e fe			ld (debug_mark),a  
4582 3a 91 45			ld a, (.dmark+1)  
4585 32 6f fe			ld (debug_mark+1),a  
4588 3a 92 45			ld a, (.dmark+2)  
458b 32 70 fe			ld (debug_mark+2),a  
458e 18 03			jr .pastdmark  
4590 ..			.dmark: db "TC4"  
4593 f1			.pastdmark: pop af  
4594			endm  
# End of macro DMARK
4594						CALLMONITOR 
4594 cd f3 18			call break_point_state  
4597				endm  
# End of macro CALLMONITOR
4597					endif 
4597					;; 
4597			 
4597 fe 20				cp ' ' 
4599 20 20				jr nz, .totsiptou 
459b 23					inc hl 
459c 7e					ld a, (hl) 
459d					if DEBUG_FORTH_WORDS 
459d						DMARK "TC5" 
459d f5				push af  
459e 3a b2 45			ld a, (.dmark)  
45a1 32 6e fe			ld (debug_mark),a  
45a4 3a b3 45			ld a, (.dmark+1)  
45a7 32 6f fe			ld (debug_mark+1),a  
45aa 3a b4 45			ld a, (.dmark+2)  
45ad 32 70 fe			ld (debug_mark+2),a  
45b0 18 03			jr .pastdmark  
45b2 ..			.dmark: db "TC5"  
45b5 f1			.pastdmark: pop af  
45b6			endm  
# End of macro DMARK
45b6						CALLMONITOR 
45b6 cd f3 18			call break_point_state  
45b9				endm  
# End of macro CALLMONITOR
45b9					endif 
45b9 18 c0				jr .totsp 
45bb fe 00		.totsiptou:    cp 0 
45bd 28 40				jr z, .totdone 
45bf					; not space and not zero term so upper case it 
45bf cd b9 12				call to_upper 
45c2			 
45c2					if DEBUG_FORTH_WORDS 
45c2						DMARK "TC6" 
45c2 f5				push af  
45c3 3a d7 45			ld a, (.dmark)  
45c6 32 6e fe			ld (debug_mark),a  
45c9 3a d8 45			ld a, (.dmark+1)  
45cc 32 6f fe			ld (debug_mark+1),a  
45cf 3a d9 45			ld a, (.dmark+2)  
45d2 32 70 fe			ld (debug_mark+2),a  
45d5 18 03			jr .pastdmark  
45d7 ..			.dmark: db "TC6"  
45da f1			.pastdmark: pop af  
45db			endm  
# End of macro DMARK
45db						CALLMONITOR 
45db cd f3 18			call break_point_state  
45de				endm  
# End of macro CALLMONITOR
45de					endif 
45de			 
45de			 
45de			.totnxt: 
45de			 
45de 77					ld (hl), a 
45df 23					inc hl 
45e0					if DEBUG_FORTH_WORDS 
45e0						DMARK "TC7" 
45e0 f5				push af  
45e1 3a f5 45			ld a, (.dmark)  
45e4 32 6e fe			ld (debug_mark),a  
45e7 3a f6 45			ld a, (.dmark+1)  
45ea 32 6f fe			ld (debug_mark+1),a  
45ed 3a f7 45			ld a, (.dmark+2)  
45f0 32 70 fe			ld (debug_mark+2),a  
45f3 18 03			jr .pastdmark  
45f5 ..			.dmark: db "TC7"  
45f8 f1			.pastdmark: pop af  
45f9			endm  
# End of macro DMARK
45f9						CALLMONITOR 
45f9 cd f3 18			call break_point_state  
45fc				endm  
# End of macro CALLMONITOR
45fc					endif 
45fc c3 34 45				jp .tot 
45ff			 
45ff					 
45ff			 
45ff			 
45ff			; for each char convert to low 
45ff					 
45ff			.totdone: 
45ff					if DEBUG_FORTH_WORDS 
45ff						DMARK "TCd" 
45ff f5				push af  
4600 3a 14 46			ld a, (.dmark)  
4603 32 6e fe			ld (debug_mark),a  
4606 3a 15 46			ld a, (.dmark+1)  
4609 32 6f fe			ld (debug_mark+1),a  
460c 3a 16 46			ld a, (.dmark+2)  
460f 32 70 fe			ld (debug_mark+2),a  
4612 18 03			jr .pastdmark  
4614 ..			.dmark: db "TCd"  
4617 f1			.pastdmark: pop af  
4618			endm  
# End of macro DMARK
4618						CALLMONITOR 
4618 cd f3 18			call break_point_state  
461b				endm  
# End of macro CALLMONITOR
461b					endif 
461b					NEXTW 
461b c3 0d 23			jp macro_next 
461e				endm 
# End of macro NEXTW
461e			 
461e			.SUBSTR: 
461e				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
461e 48				db WORD_SYS_CORE+52             
461f 7c 46			dw .LEFT            
4621 07				db 6 + 1 
4622 .. 00			db "SUBSTR",0              
4629				endm 
# End of macro CWHEAD
4629			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4629			 
4629					if DEBUG_FORTH_WORDS_KEY 
4629						DMARK "SST" 
4629 f5				push af  
462a 3a 3e 46			ld a, (.dmark)  
462d 32 6e fe			ld (debug_mark),a  
4630 3a 3f 46			ld a, (.dmark+1)  
4633 32 6f fe			ld (debug_mark+1),a  
4636 3a 40 46			ld a, (.dmark+2)  
4639 32 70 fe			ld (debug_mark+2),a  
463c 18 03			jr .pastdmark  
463e ..			.dmark: db "SST"  
4641 f1			.pastdmark: pop af  
4642			endm  
# End of macro DMARK
4642						CALLMONITOR 
4642 cd f3 18			call break_point_state  
4645				endm  
# End of macro CALLMONITOR
4645					endif 
4645			; TODO check string type 
4645					FORTH_DSP_VALUEHL 
4645 cd 5e 21			call macro_dsp_valuehl 
4648				endm 
# End of macro FORTH_DSP_VALUEHL
4648			 
4648 e5					push hl      ; string length 
4649			 
4649					FORTH_DSP_POP 
4649 cd 16 22			call macro_forth_dsp_pop 
464c				endm 
# End of macro FORTH_DSP_POP
464c			 
464c					FORTH_DSP_VALUEHL 
464c cd 5e 21			call macro_dsp_valuehl 
464f				endm 
# End of macro FORTH_DSP_VALUEHL
464f			 
464f e5					push hl     ; start char 
4650			 
4650					FORTH_DSP_POP 
4650 cd 16 22			call macro_forth_dsp_pop 
4653				endm 
# End of macro FORTH_DSP_POP
4653			 
4653			 
4653					FORTH_DSP_VALUE 
4653 cd 47 21			call macro_forth_dsp_value 
4656				endm 
# End of macro FORTH_DSP_VALUE
4656			 
4656 d1					pop de    ; get start post offset 
4657			 
4657 19					add hl, de    ; starting offset 
4658			 
4658 c1					pop bc 
4659 c5					push bc      ; grab size of string 
465a			 
465a e5					push hl    ; save string start  
465b			 
465b 26 00				ld h, 0 
465d 69					ld l, c 
465e 23					inc hl 
465f 23					inc hl 
4660			 
4660 cd 13 14				call malloc 
4663				if DEBUG_FORTH_MALLOC_GUARD 
4663 cc 15 59				call z,malloc_error 
4666				endif 
4666			 
4666 eb					ex de, hl      ; save malloc area for string copy 
4667 e1					pop hl    ; get back source 
4668 c1					pop bc    ; get length of string back 
4669			 
4669 d5					push de    ; save malloc area for after we push 
466a ed b0				ldir     ; copy substr 
466c			 
466c			 
466c eb					ex de, hl 
466d 3e 00				ld a, 0 
466f 77					ld (hl), a   ; term substr 
4670			 
4670					 
4670 e1					pop hl    ; get malloc so we can push it 
4671 e5					push hl   ; save so we can free it afterwards 
4672			 
4672 cd d5 1f				call forth_push_str 
4675			 
4675 e1					pop hl 
4676 cd dd 14				call free 
4679			 
4679					 
4679					 
4679			 
4679			 
4679					NEXTW 
4679 c3 0d 23			jp macro_next 
467c				endm 
# End of macro NEXTW
467c			 
467c			.LEFT: 
467c				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
467c 48				db WORD_SYS_CORE+52             
467d a4 46			dw .RIGHT            
467f 05				db 4 + 1 
4680 .. 00			db "LEFT",0              
4685				endm 
# End of macro CWHEAD
4685			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4685					if DEBUG_FORTH_WORDS_KEY 
4685						DMARK "LEF" 
4685 f5				push af  
4686 3a 9a 46			ld a, (.dmark)  
4689 32 6e fe			ld (debug_mark),a  
468c 3a 9b 46			ld a, (.dmark+1)  
468f 32 6f fe			ld (debug_mark+1),a  
4692 3a 9c 46			ld a, (.dmark+2)  
4695 32 70 fe			ld (debug_mark+2),a  
4698 18 03			jr .pastdmark  
469a ..			.dmark: db "LEF"  
469d f1			.pastdmark: pop af  
469e			endm  
# End of macro DMARK
469e						CALLMONITOR 
469e cd f3 18			call break_point_state  
46a1				endm  
# End of macro CALLMONITOR
46a1					endif 
46a1			 
46a1					NEXTW 
46a1 c3 0d 23			jp macro_next 
46a4				endm 
# End of macro NEXTW
46a4			.RIGHT: 
46a4				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
46a4 48				db WORD_SYS_CORE+52             
46a5 cd 46			dw .STR2NUM            
46a7 06				db 5 + 1 
46a8 .. 00			db "RIGHT",0              
46ae				endm 
# End of macro CWHEAD
46ae			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
46ae					if DEBUG_FORTH_WORDS_KEY 
46ae						DMARK "RIG" 
46ae f5				push af  
46af 3a c3 46			ld a, (.dmark)  
46b2 32 6e fe			ld (debug_mark),a  
46b5 3a c4 46			ld a, (.dmark+1)  
46b8 32 6f fe			ld (debug_mark+1),a  
46bb 3a c5 46			ld a, (.dmark+2)  
46be 32 70 fe			ld (debug_mark+2),a  
46c1 18 03			jr .pastdmark  
46c3 ..			.dmark: db "RIG"  
46c6 f1			.pastdmark: pop af  
46c7			endm  
# End of macro DMARK
46c7						CALLMONITOR 
46c7 cd f3 18			call break_point_state  
46ca				endm  
# End of macro CALLMONITOR
46ca					endif 
46ca			 
46ca					NEXTW 
46ca c3 0d 23			jp macro_next 
46cd				endm 
# End of macro NEXTW
46cd			 
46cd			 
46cd			.STR2NUM: 
46cd				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
46cd 48				db WORD_SYS_CORE+52             
46ce 59 47			dw .NUM2STR            
46d0 08				db 7 + 1 
46d1 .. 00			db "STR2NUM",0              
46d9				endm 
# End of macro CWHEAD
46d9			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
46d9			 
46d9			 
46d9			; TODO STR type check to do 
46d9					if DEBUG_FORTH_WORDS_KEY 
46d9						DMARK "S2N" 
46d9 f5				push af  
46da 3a ee 46			ld a, (.dmark)  
46dd 32 6e fe			ld (debug_mark),a  
46e0 3a ef 46			ld a, (.dmark+1)  
46e3 32 6f fe			ld (debug_mark+1),a  
46e6 3a f0 46			ld a, (.dmark+2)  
46e9 32 70 fe			ld (debug_mark+2),a  
46ec 18 03			jr .pastdmark  
46ee ..			.dmark: db "S2N"  
46f1 f1			.pastdmark: pop af  
46f2			endm  
# End of macro DMARK
46f2						CALLMONITOR 
46f2 cd f3 18			call break_point_state  
46f5				endm  
# End of macro CALLMONITOR
46f5					endif 
46f5			 
46f5					;FORTH_DSP 
46f5					FORTH_DSP_VALUE 
46f5 cd 47 21			call macro_forth_dsp_value 
46f8				endm 
# End of macro FORTH_DSP_VALUE
46f8					;inc hl 
46f8			 
46f8 eb					ex de, hl 
46f9					if DEBUG_FORTH_WORDS 
46f9						DMARK "S2a" 
46f9 f5				push af  
46fa 3a 0e 47			ld a, (.dmark)  
46fd 32 6e fe			ld (debug_mark),a  
4700 3a 0f 47			ld a, (.dmark+1)  
4703 32 6f fe			ld (debug_mark+1),a  
4706 3a 10 47			ld a, (.dmark+2)  
4709 32 70 fe			ld (debug_mark+2),a  
470c 18 03			jr .pastdmark  
470e ..			.dmark: db "S2a"  
4711 f1			.pastdmark: pop af  
4712			endm  
# End of macro DMARK
4712						CALLMONITOR 
4712 cd f3 18			call break_point_state  
4715				endm  
# End of macro CALLMONITOR
4715					endif 
4715 cd 41 13				call string_to_uint16 
4718			 
4718					if DEBUG_FORTH_WORDS 
4718						DMARK "S2b" 
4718 f5				push af  
4719 3a 2d 47			ld a, (.dmark)  
471c 32 6e fe			ld (debug_mark),a  
471f 3a 2e 47			ld a, (.dmark+1)  
4722 32 6f fe			ld (debug_mark+1),a  
4725 3a 2f 47			ld a, (.dmark+2)  
4728 32 70 fe			ld (debug_mark+2),a  
472b 18 03			jr .pastdmark  
472d ..			.dmark: db "S2b"  
4730 f1			.pastdmark: pop af  
4731			endm  
# End of macro DMARK
4731						CALLMONITOR 
4731 cd f3 18			call break_point_state  
4734				endm  
# End of macro CALLMONITOR
4734					endif 
4734			;		push hl 
4734					FORTH_DSP_POP 
4734 cd 16 22			call macro_forth_dsp_pop 
4737				endm 
# End of macro FORTH_DSP_POP
4737			;		pop hl 
4737					 
4737					if DEBUG_FORTH_WORDS 
4737						DMARK "S2b" 
4737 f5				push af  
4738 3a 4c 47			ld a, (.dmark)  
473b 32 6e fe			ld (debug_mark),a  
473e 3a 4d 47			ld a, (.dmark+1)  
4741 32 6f fe			ld (debug_mark+1),a  
4744 3a 4e 47			ld a, (.dmark+2)  
4747 32 70 fe			ld (debug_mark+2),a  
474a 18 03			jr .pastdmark  
474c ..			.dmark: db "S2b"  
474f f1			.pastdmark: pop af  
4750			endm  
# End of macro DMARK
4750						CALLMONITOR 
4750 cd f3 18			call break_point_state  
4753				endm  
# End of macro CALLMONITOR
4753					endif 
4753 cd 67 1f				call forth_push_numhl	 
4756			 
4756				 
4756				       NEXTW 
4756 c3 0d 23			jp macro_next 
4759				endm 
# End of macro NEXTW
4759			.NUM2STR: 
4759				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4759 48				db WORD_SYS_CORE+52             
475a 68 47			dw .CONCAT            
475c 08				db 7 + 1 
475d .. 00			db "NUM2STR",0              
4765				endm 
# End of macro CWHEAD
4765			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4765			 
4765			;		; malloc a string to target 
4765			;		ld hl, 10     ; TODO max string size should be fine 
4765			;		call malloc 
4765			;		push hl    ; save malloc location 
4765			; 
4765			; 
4765			;; TODO check int type 
4765			;		FORTH_DSP_VALUEHL 
4765			;		ld a, l 
4765			;		call DispAToASCII   
4765			;;TODO need to chage above call to dump into string 
4765			; 
4765			; 
4765			 
4765				       NEXTW 
4765 c3 0d 23			jp macro_next 
4768				endm 
# End of macro NEXTW
4768			 
4768			.CONCAT: 
4768				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4768 48				db WORD_SYS_CORE+52             
4769 1b 48			dw .FIND            
476b 07				db 6 + 1 
476c .. 00			db "CONCAT",0              
4773				endm 
# End of macro CWHEAD
4773			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4773			 
4773			; TODO check string type 
4773			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4773			 
4773					if DEBUG_FORTH_WORDS_KEY 
4773						DMARK "CON" 
4773 f5				push af  
4774 3a 88 47			ld a, (.dmark)  
4777 32 6e fe			ld (debug_mark),a  
477a 3a 89 47			ld a, (.dmark+1)  
477d 32 6f fe			ld (debug_mark+1),a  
4780 3a 8a 47			ld a, (.dmark+2)  
4783 32 70 fe			ld (debug_mark+2),a  
4786 18 03			jr .pastdmark  
4788 ..			.dmark: db "CON"  
478b f1			.pastdmark: pop af  
478c			endm  
# End of macro DMARK
478c						CALLMONITOR 
478c cd f3 18			call break_point_state  
478f				endm  
# End of macro CALLMONITOR
478f					endif 
478f			 
478f			 
478f					FORTH_DSP_VALUE 
478f cd 47 21			call macro_forth_dsp_value 
4792				endm 
# End of macro FORTH_DSP_VALUE
4792 e5					push hl   ; s2 
4793			 
4793					FORTH_DSP_POP 
4793 cd 16 22			call macro_forth_dsp_pop 
4796				endm 
# End of macro FORTH_DSP_POP
4796			 
4796					FORTH_DSP_VALUE 
4796 cd 47 21			call macro_forth_dsp_value 
4799				endm 
# End of macro FORTH_DSP_VALUE
4799			 
4799 e5					push hl   ; s1 
479a			 
479a					FORTH_DSP_POP 
479a cd 16 22			call macro_forth_dsp_pop 
479d				endm 
# End of macro FORTH_DSP_POP
479d					 
479d			 
479d					; copy s1 
479d			 
479d				 
479d					; save ptr 
479d e1					pop hl  
479e e5					push hl 
479f 3e 00				ld a, 0 
47a1 cd b5 13				call strlent 
47a4					;inc hl    ; zer0 
47a4 06 00				ld b, 0 
47a6 4d					ld c, l 
47a7 e1					pop hl		 
47a8 11 c8 f1				ld de, scratch	 
47ab					if DEBUG_FORTH_WORDS 
47ab						DMARK "CO1" 
47ab f5				push af  
47ac 3a c0 47			ld a, (.dmark)  
47af 32 6e fe			ld (debug_mark),a  
47b2 3a c1 47			ld a, (.dmark+1)  
47b5 32 6f fe			ld (debug_mark+1),a  
47b8 3a c2 47			ld a, (.dmark+2)  
47bb 32 70 fe			ld (debug_mark+2),a  
47be 18 03			jr .pastdmark  
47c0 ..			.dmark: db "CO1"  
47c3 f1			.pastdmark: pop af  
47c4			endm  
# End of macro DMARK
47c4						CALLMONITOR 
47c4 cd f3 18			call break_point_state  
47c7				endm  
# End of macro CALLMONITOR
47c7					endif 
47c7 ed b0				ldir 
47c9			 
47c9 e1					pop hl 
47ca e5					push hl 
47cb d5					push de 
47cc			 
47cc			 
47cc 3e 00				ld a, 0 
47ce cd b5 13				call strlent 
47d1 23					inc hl    ; zer0 
47d2 23					inc hl 
47d3 06 00				ld b, 0 
47d5 4d					ld c, l 
47d6 d1					pop de 
47d7 e1					pop hl		 
47d8					if DEBUG_FORTH_WORDS 
47d8						DMARK "CO2" 
47d8 f5				push af  
47d9 3a ed 47			ld a, (.dmark)  
47dc 32 6e fe			ld (debug_mark),a  
47df 3a ee 47			ld a, (.dmark+1)  
47e2 32 6f fe			ld (debug_mark+1),a  
47e5 3a ef 47			ld a, (.dmark+2)  
47e8 32 70 fe			ld (debug_mark+2),a  
47eb 18 03			jr .pastdmark  
47ed ..			.dmark: db "CO2"  
47f0 f1			.pastdmark: pop af  
47f1			endm  
# End of macro DMARK
47f1						CALLMONITOR 
47f1 cd f3 18			call break_point_state  
47f4				endm  
# End of macro CALLMONITOR
47f4					endif 
47f4 ed b0				ldir 
47f6			 
47f6			 
47f6			 
47f6 21 c8 f1				ld hl, scratch 
47f9					if DEBUG_FORTH_WORDS 
47f9						DMARK "CO5" 
47f9 f5				push af  
47fa 3a 0e 48			ld a, (.dmark)  
47fd 32 6e fe			ld (debug_mark),a  
4800 3a 0f 48			ld a, (.dmark+1)  
4803 32 6f fe			ld (debug_mark+1),a  
4806 3a 10 48			ld a, (.dmark+2)  
4809 32 70 fe			ld (debug_mark+2),a  
480c 18 03			jr .pastdmark  
480e ..			.dmark: db "CO5"  
4811 f1			.pastdmark: pop af  
4812			endm  
# End of macro DMARK
4812						CALLMONITOR 
4812 cd f3 18			call break_point_state  
4815				endm  
# End of macro CALLMONITOR
4815					endif 
4815			 
4815 cd d5 1f				call forth_push_str 
4818			 
4818			 
4818			 
4818			 
4818				       NEXTW 
4818 c3 0d 23			jp macro_next 
481b				endm 
# End of macro NEXTW
481b			 
481b			 
481b			.FIND: 
481b				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
481b 4b				db WORD_SYS_CORE+55             
481c d9 48			dw .LEN            
481e 05				db 4 + 1 
481f .. 00			db "FIND",0              
4824				endm 
# End of macro CWHEAD
4824			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4824			 
4824					if DEBUG_FORTH_WORDS_KEY 
4824						DMARK "FND" 
4824 f5				push af  
4825 3a 39 48			ld a, (.dmark)  
4828 32 6e fe			ld (debug_mark),a  
482b 3a 3a 48			ld a, (.dmark+1)  
482e 32 6f fe			ld (debug_mark+1),a  
4831 3a 3b 48			ld a, (.dmark+2)  
4834 32 70 fe			ld (debug_mark+2),a  
4837 18 03			jr .pastdmark  
4839 ..			.dmark: db "FND"  
483c f1			.pastdmark: pop af  
483d			endm  
# End of macro DMARK
483d						CALLMONITOR 
483d cd f3 18			call break_point_state  
4840				endm  
# End of macro CALLMONITOR
4840					endif 
4840			 
4840			; TODO check string type 
4840					FORTH_DSP_VALUE 
4840 cd 47 21			call macro_forth_dsp_value 
4843				endm 
# End of macro FORTH_DSP_VALUE
4843			 
4843 e5					push hl    
4844 7e					ld a,(hl)    ; char to find   
4845			; TODO change char to substr 
4845			 
4845 f5					push af 
4846					 
4846			 
4846			 
4846					if DEBUG_FORTH_WORDS 
4846						DMARK "FN1" 
4846 f5				push af  
4847 3a 5b 48			ld a, (.dmark)  
484a 32 6e fe			ld (debug_mark),a  
484d 3a 5c 48			ld a, (.dmark+1)  
4850 32 6f fe			ld (debug_mark+1),a  
4853 3a 5d 48			ld a, (.dmark+2)  
4856 32 70 fe			ld (debug_mark+2),a  
4859 18 03			jr .pastdmark  
485b ..			.dmark: db "FN1"  
485e f1			.pastdmark: pop af  
485f			endm  
# End of macro DMARK
485f						CALLMONITOR 
485f cd f3 18			call break_point_state  
4862				endm  
# End of macro CALLMONITOR
4862					endif 
4862			 
4862					FORTH_DSP_POP 
4862 cd 16 22			call macro_forth_dsp_pop 
4865				endm 
# End of macro FORTH_DSP_POP
4865			 
4865					; string to search 
4865			 
4865					FORTH_DSP_VALUE 
4865 cd 47 21			call macro_forth_dsp_value 
4868				endm 
# End of macro FORTH_DSP_VALUE
4868			 
4868 d1					pop de  ; d is char to find  
4869			 
4869					if DEBUG_FORTH_WORDS 
4869						DMARK "FN2" 
4869 f5				push af  
486a 3a 7e 48			ld a, (.dmark)  
486d 32 6e fe			ld (debug_mark),a  
4870 3a 7f 48			ld a, (.dmark+1)  
4873 32 6f fe			ld (debug_mark+1),a  
4876 3a 80 48			ld a, (.dmark+2)  
4879 32 70 fe			ld (debug_mark+2),a  
487c 18 03			jr .pastdmark  
487e ..			.dmark: db "FN2"  
4881 f1			.pastdmark: pop af  
4882			endm  
# End of macro DMARK
4882						CALLMONITOR 
4882 cd f3 18			call break_point_state  
4885				endm  
# End of macro CALLMONITOR
4885					endif 
4885					 
4885 01 00 00				ld bc, 0 
4888 7e			.findchar:      ld a,(hl) 
4889 fe 00				cp 0   		 
488b 28 27				jr z, .finddone     
488d ba					cp d 
488e 28 20				jr z, .foundchar 
4890 03					inc bc 
4891 23					inc hl 
4892					if DEBUG_FORTH_WORDS 
4892						DMARK "FN3" 
4892 f5				push af  
4893 3a a7 48			ld a, (.dmark)  
4896 32 6e fe			ld (debug_mark),a  
4899 3a a8 48			ld a, (.dmark+1)  
489c 32 6f fe			ld (debug_mark+1),a  
489f 3a a9 48			ld a, (.dmark+2)  
48a2 32 70 fe			ld (debug_mark+2),a  
48a5 18 03			jr .pastdmark  
48a7 ..			.dmark: db "FN3"  
48aa f1			.pastdmark: pop af  
48ab			endm  
# End of macro DMARK
48ab						CALLMONITOR 
48ab cd f3 18			call break_point_state  
48ae				endm  
# End of macro CALLMONITOR
48ae					endif 
48ae 18 d8				jr .findchar 
48b0			 
48b0			 
48b0 c5			.foundchar:	push bc 
48b1 e1					pop hl 
48b2 18 03				jr .findexit 
48b4			 
48b4			 
48b4							 
48b4			 
48b4			.finddone:     ; got to end of string with no find 
48b4 21 00 00				ld hl, 0 
48b7			.findexit: 
48b7			 
48b7					if DEBUG_FORTH_WORDS 
48b7						DMARK "FNd" 
48b7 f5				push af  
48b8 3a cc 48			ld a, (.dmark)  
48bb 32 6e fe			ld (debug_mark),a  
48be 3a cd 48			ld a, (.dmark+1)  
48c1 32 6f fe			ld (debug_mark+1),a  
48c4 3a ce 48			ld a, (.dmark+2)  
48c7 32 70 fe			ld (debug_mark+2),a  
48ca 18 03			jr .pastdmark  
48cc ..			.dmark: db "FNd"  
48cf f1			.pastdmark: pop af  
48d0			endm  
# End of macro DMARK
48d0						CALLMONITOR 
48d0 cd f3 18			call break_point_state  
48d3				endm  
# End of macro CALLMONITOR
48d3					endif 
48d3 cd 67 1f			call forth_push_numhl 
48d6			 
48d6				       NEXTW 
48d6 c3 0d 23			jp macro_next 
48d9				endm 
# End of macro NEXTW
48d9			 
48d9			.LEN: 
48d9				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
48d9 4c				db WORD_SYS_CORE+56             
48da 43 49			dw .ASC            
48dc 06				db 5 + 1 
48dd .. 00			db "COUNT",0              
48e3				endm 
# End of macro CWHEAD
48e3			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
48e3			 
48e3					if DEBUG_FORTH_WORDS_KEY 
48e3						DMARK "CNT" 
48e3 f5				push af  
48e4 3a f8 48			ld a, (.dmark)  
48e7 32 6e fe			ld (debug_mark),a  
48ea 3a f9 48			ld a, (.dmark+1)  
48ed 32 6f fe			ld (debug_mark+1),a  
48f0 3a fa 48			ld a, (.dmark+2)  
48f3 32 70 fe			ld (debug_mark+2),a  
48f6 18 03			jr .pastdmark  
48f8 ..			.dmark: db "CNT"  
48fb f1			.pastdmark: pop af  
48fc			endm  
# End of macro DMARK
48fc						CALLMONITOR 
48fc cd f3 18			call break_point_state  
48ff				endm  
# End of macro CALLMONITOR
48ff					endif 
48ff			; TODO check string type 
48ff					FORTH_DSP_VALUE 
48ff cd 47 21			call macro_forth_dsp_value 
4902				endm 
# End of macro FORTH_DSP_VALUE
4902			 
4902			 
4902					if DEBUG_FORTH_WORDS 
4902						DMARK "CN?" 
4902 f5				push af  
4903 3a 17 49			ld a, (.dmark)  
4906 32 6e fe			ld (debug_mark),a  
4909 3a 18 49			ld a, (.dmark+1)  
490c 32 6f fe			ld (debug_mark+1),a  
490f 3a 19 49			ld a, (.dmark+2)  
4912 32 70 fe			ld (debug_mark+2),a  
4915 18 03			jr .pastdmark  
4917 ..			.dmark: db "CN?"  
491a f1			.pastdmark: pop af  
491b			endm  
# End of macro DMARK
491b						CALLMONITOR 
491b cd f3 18			call break_point_state  
491e				endm  
# End of macro CALLMONITOR
491e					endif 
491e cd aa 13				call strlenz 
4921					if DEBUG_FORTH_WORDS 
4921						DMARK "CNl" 
4921 f5				push af  
4922 3a 36 49			ld a, (.dmark)  
4925 32 6e fe			ld (debug_mark),a  
4928 3a 37 49			ld a, (.dmark+1)  
492b 32 6f fe			ld (debug_mark+1),a  
492e 3a 38 49			ld a, (.dmark+2)  
4931 32 70 fe			ld (debug_mark+2),a  
4934 18 03			jr .pastdmark  
4936 ..			.dmark: db "CNl"  
4939 f1			.pastdmark: pop af  
493a			endm  
# End of macro DMARK
493a						CALLMONITOR 
493a cd f3 18			call break_point_state  
493d				endm  
# End of macro CALLMONITOR
493d					endif 
493d			 
493d cd 67 1f				call forth_push_numhl 
4940			 
4940			 
4940			 
4940				       NEXTW 
4940 c3 0d 23			jp macro_next 
4943				endm 
# End of macro NEXTW
4943			.ASC: 
4943				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4943 4d				db WORD_SYS_CORE+57             
4944 78 49			dw .CHR            
4946 04				db 3 + 1 
4947 .. 00			db "ASC",0              
494b				endm 
# End of macro CWHEAD
494b			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
494b					if DEBUG_FORTH_WORDS_KEY 
494b						DMARK "ASC" 
494b f5				push af  
494c 3a 60 49			ld a, (.dmark)  
494f 32 6e fe			ld (debug_mark),a  
4952 3a 61 49			ld a, (.dmark+1)  
4955 32 6f fe			ld (debug_mark+1),a  
4958 3a 62 49			ld a, (.dmark+2)  
495b 32 70 fe			ld (debug_mark+2),a  
495e 18 03			jr .pastdmark  
4960 ..			.dmark: db "ASC"  
4963 f1			.pastdmark: pop af  
4964			endm  
# End of macro DMARK
4964						CALLMONITOR 
4964 cd f3 18			call break_point_state  
4967				endm  
# End of macro CALLMONITOR
4967					endif 
4967					FORTH_DSP 
4967 cd 24 21			call macro_forth_dsp 
496a				endm 
# End of macro FORTH_DSP
496a					;v5 FORTH_DSP_VALUE 
496a 23					inc hl      ; now at start of numeric as string 
496b			 
496b			;		push hl 
496b			 
496b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
496b cd 16 22			call macro_forth_dsp_pop 
496e				endm 
# End of macro FORTH_DSP_POP
496e			 
496e			;		pop hl 
496e			 
496e					; push the content of a onto the stack as a value 
496e			 
496e 7e					ld a,(hl)   ; get char 
496f 26 00				ld h,0 
4971 6f					ld l,a 
4972 cd 67 1f				call forth_push_numhl 
4975			 
4975				       NEXTW 
4975 c3 0d 23			jp macro_next 
4978				endm 
# End of macro NEXTW
4978			 
4978			.CHR: 
4978				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4978 4d				db WORD_SYS_CORE+57             
4979 b4 49			dw .ENDSTR            
497b 04				db 3 + 1 
497c .. 00			db "CHR",0              
4980				endm 
# End of macro CWHEAD
4980			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4980					if DEBUG_FORTH_WORDS_KEY 
4980						DMARK "CHR" 
4980 f5				push af  
4981 3a 95 49			ld a, (.dmark)  
4984 32 6e fe			ld (debug_mark),a  
4987 3a 96 49			ld a, (.dmark+1)  
498a 32 6f fe			ld (debug_mark+1),a  
498d 3a 97 49			ld a, (.dmark+2)  
4990 32 70 fe			ld (debug_mark+2),a  
4993 18 03			jr .pastdmark  
4995 ..			.dmark: db "CHR"  
4998 f1			.pastdmark: pop af  
4999			endm  
# End of macro DMARK
4999						CALLMONITOR 
4999 cd f3 18			call break_point_state  
499c				endm  
# End of macro CALLMONITOR
499c					endif 
499c					FORTH_DSP_VALUEHL 
499c cd 5e 21			call macro_dsp_valuehl 
499f				endm 
# End of macro FORTH_DSP_VALUEHL
499f			 
499f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
499f cd 16 22			call macro_forth_dsp_pop 
49a2				endm 
# End of macro FORTH_DSP_POP
49a2			 
49a2					; save asci byte as a zero term string and push string 
49a2			 
49a2 7d					ld a,l 
49a3 32 c8 f1				ld (scratch), a 
49a6			 
49a6 3e 00				ld a, 0 
49a8 32 c9 f1				ld (scratch+1), a 
49ab			 
49ab 21 c8 f1				ld hl, scratch 
49ae cd d5 1f				call forth_push_str 
49b1			 
49b1			 
49b1				       NEXTW 
49b1 c3 0d 23			jp macro_next 
49b4				endm 
# End of macro NEXTW
49b4			 
49b4			 
49b4			 
49b4			 
49b4			.ENDSTR: 
49b4			; eof 
49b4			 
# End of file forth_words_str.asm
49b4			include "forth_words_key.asm" 
49b4			 
49b4			; | ## Keyboard Words 
49b4			 
49b4			.KEY: 
49b4				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
49b4 3e				db WORD_SYS_CORE+42             
49b5 e4 49			dw .WAITK            
49b7 04				db 3 + 1 
49b8 .. 00			db "KEY",0              
49bc				endm 
# End of macro CWHEAD
49bc			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
49bc			 
49bc					if DEBUG_FORTH_WORDS_KEY 
49bc						DMARK "KEY" 
49bc f5				push af  
49bd 3a d1 49			ld a, (.dmark)  
49c0 32 6e fe			ld (debug_mark),a  
49c3 3a d2 49			ld a, (.dmark+1)  
49c6 32 6f fe			ld (debug_mark+1),a  
49c9 3a d3 49			ld a, (.dmark+2)  
49cc 32 70 fe			ld (debug_mark+2),a  
49cf 18 03			jr .pastdmark  
49d1 ..			.dmark: db "KEY"  
49d4 f1			.pastdmark: pop af  
49d5			endm  
# End of macro DMARK
49d5						CALLMONITOR 
49d5 cd f3 18			call break_point_state  
49d8				endm  
# End of macro CALLMONITOR
49d8					endif 
49d8			; TODO currently waits 
49d8 cd ba 73				call cin 
49db					;call cin_wait 
49db 6f					ld l, a 
49dc 26 00				ld h, 0 
49de cd 67 1f				call forth_push_numhl 
49e1					NEXTW 
49e1 c3 0d 23			jp macro_next 
49e4				endm 
# End of macro NEXTW
49e4			.WAITK: 
49e4				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
49e4 3f				db WORD_SYS_CORE+43             
49e5 16 4a			dw .ACCEPT            
49e7 06				db 5 + 1 
49e8 .. 00			db "WAITK",0              
49ee				endm 
# End of macro CWHEAD
49ee			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
49ee					if DEBUG_FORTH_WORDS_KEY 
49ee						DMARK "WAI" 
49ee f5				push af  
49ef 3a 03 4a			ld a, (.dmark)  
49f2 32 6e fe			ld (debug_mark),a  
49f5 3a 04 4a			ld a, (.dmark+1)  
49f8 32 6f fe			ld (debug_mark+1),a  
49fb 3a 05 4a			ld a, (.dmark+2)  
49fe 32 70 fe			ld (debug_mark+2),a  
4a01 18 03			jr .pastdmark  
4a03 ..			.dmark: db "WAI"  
4a06 f1			.pastdmark: pop af  
4a07			endm  
# End of macro DMARK
4a07						CALLMONITOR 
4a07 cd f3 18			call break_point_state  
4a0a				endm  
# End of macro CALLMONITOR
4a0a					endif 
4a0a cd a9 73				call cin_wait 
4a0d 6f					ld l, a 
4a0e 26 00				ld h, 0 
4a10 cd 67 1f				call forth_push_numhl 
4a13					NEXTW 
4a13 c3 0d 23			jp macro_next 
4a16				endm 
# End of macro NEXTW
4a16			.ACCEPT: 
4a16				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4a16 40				db WORD_SYS_CORE+44             
4a17 74 4a			dw .EDIT            
4a19 07				db 6 + 1 
4a1a .. 00			db "ACCEPT",0              
4a21				endm 
# End of macro CWHEAD
4a21			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4a21					; TODO crashes on push 
4a21					if DEBUG_FORTH_WORDS_KEY 
4a21						DMARK "ACC" 
4a21 f5				push af  
4a22 3a 36 4a			ld a, (.dmark)  
4a25 32 6e fe			ld (debug_mark),a  
4a28 3a 37 4a			ld a, (.dmark+1)  
4a2b 32 6f fe			ld (debug_mark+1),a  
4a2e 3a 38 4a			ld a, (.dmark+2)  
4a31 32 70 fe			ld (debug_mark+2),a  
4a34 18 03			jr .pastdmark  
4a36 ..			.dmark: db "ACC"  
4a39 f1			.pastdmark: pop af  
4a3a			endm  
# End of macro DMARK
4a3a						CALLMONITOR 
4a3a cd f3 18			call break_point_state  
4a3d				endm  
# End of macro CALLMONITOR
4a3d					endif 
4a3d 21 c6 f3				ld hl, os_input 
4a40 3e 00				ld a, 0 
4a42 77					ld (hl),a 
4a43 3a 65 fa				ld a,(f_cursor_ptr) 
4a46 16 64				ld d, 100 
4a48 0e 00				ld c, 0 
4a4a 1e 28				ld e, 40 
4a4c cd 79 0f				call input_str 
4a4f					; TODO perhaps do a type check and wrap in quotes if not a number 
4a4f 21 c6 f3				ld hl, os_input 
4a52					if DEBUG_FORTH_WORDS 
4a52						DMARK "AC1" 
4a52 f5				push af  
4a53 3a 67 4a			ld a, (.dmark)  
4a56 32 6e fe			ld (debug_mark),a  
4a59 3a 68 4a			ld a, (.dmark+1)  
4a5c 32 6f fe			ld (debug_mark+1),a  
4a5f 3a 69 4a			ld a, (.dmark+2)  
4a62 32 70 fe			ld (debug_mark+2),a  
4a65 18 03			jr .pastdmark  
4a67 ..			.dmark: db "AC1"  
4a6a f1			.pastdmark: pop af  
4a6b			endm  
# End of macro DMARK
4a6b						CALLMONITOR 
4a6b cd f3 18			call break_point_state  
4a6e				endm  
# End of macro CALLMONITOR
4a6e					endif 
4a6e cd d5 1f				call forth_push_str 
4a71					NEXTW 
4a71 c3 0d 23			jp macro_next 
4a74				endm 
# End of macro NEXTW
4a74			 
4a74			.EDIT: 
4a74				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4a74 40				db WORD_SYS_CORE+44             
4a75 16 4b			dw .ENDKEY            
4a77 05				db 4 + 1 
4a78 .. 00			db "EDIT",0              
4a7d				endm 
# End of macro CWHEAD
4a7d			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4a7d			 
4a7d					; TODO does not copy from stack 
4a7d					if DEBUG_FORTH_WORDS_KEY 
4a7d						DMARK "EDT" 
4a7d f5				push af  
4a7e 3a 92 4a			ld a, (.dmark)  
4a81 32 6e fe			ld (debug_mark),a  
4a84 3a 93 4a			ld a, (.dmark+1)  
4a87 32 6f fe			ld (debug_mark+1),a  
4a8a 3a 94 4a			ld a, (.dmark+2)  
4a8d 32 70 fe			ld (debug_mark+2),a  
4a90 18 03			jr .pastdmark  
4a92 ..			.dmark: db "EDT"  
4a95 f1			.pastdmark: pop af  
4a96			endm  
# End of macro DMARK
4a96						CALLMONITOR 
4a96 cd f3 18			call break_point_state  
4a99				endm  
# End of macro CALLMONITOR
4a99					endif 
4a99			 
4a99					;FORTH_DSP 
4a99					FORTH_DSP_VALUEHL 
4a99 cd 5e 21			call macro_dsp_valuehl 
4a9c				endm 
# End of macro FORTH_DSP_VALUEHL
4a9c			;		inc hl    ; TODO do type check 
4a9c			 
4a9c			;		call get_word_hl 
4a9c e5					push hl 
4a9d					if DEBUG_FORTH_WORDS 
4a9d						DMARK "EDp" 
4a9d f5				push af  
4a9e 3a b2 4a			ld a, (.dmark)  
4aa1 32 6e fe			ld (debug_mark),a  
4aa4 3a b3 4a			ld a, (.dmark+1)  
4aa7 32 6f fe			ld (debug_mark+1),a  
4aaa 3a b4 4a			ld a, (.dmark+2)  
4aad 32 70 fe			ld (debug_mark+2),a  
4ab0 18 03			jr .pastdmark  
4ab2 ..			.dmark: db "EDp"  
4ab5 f1			.pastdmark: pop af  
4ab6			endm  
# End of macro DMARK
4ab6						CALLMONITOR 
4ab6 cd f3 18			call break_point_state  
4ab9				endm  
# End of macro CALLMONITOR
4ab9					endif 
4ab9				;	ld a, 0 
4ab9 cd aa 13				call strlenz 
4abc 23					inc hl 
4abd			 
4abd 06 00				ld b, 0 
4abf 4d					ld c, l 
4ac0			 
4ac0 e1					pop hl 
4ac1 11 c6 f3				ld de, os_input 
4ac4					if DEBUG_FORTH_WORDS_KEY 
4ac4						DMARK "EDc" 
4ac4 f5				push af  
4ac5 3a d9 4a			ld a, (.dmark)  
4ac8 32 6e fe			ld (debug_mark),a  
4acb 3a da 4a			ld a, (.dmark+1)  
4ace 32 6f fe			ld (debug_mark+1),a  
4ad1 3a db 4a			ld a, (.dmark+2)  
4ad4 32 70 fe			ld (debug_mark+2),a  
4ad7 18 03			jr .pastdmark  
4ad9 ..			.dmark: db "EDc"  
4adc f1			.pastdmark: pop af  
4add			endm  
# End of macro DMARK
4add						CALLMONITOR 
4add cd f3 18			call break_point_state  
4ae0				endm  
# End of macro CALLMONITOR
4ae0					endif 
4ae0 ed b0				ldir 
4ae2			 
4ae2			 
4ae2 21 c6 f3				ld hl, os_input 
4ae5					;ld a, 0 
4ae5					;ld (hl),a 
4ae5 3a 65 fa				ld a,(f_cursor_ptr) 
4ae8 16 64				ld d, 100 
4aea 0e 00				ld c, 0 
4aec 1e 28				ld e, 40 
4aee cd 79 0f				call input_str 
4af1					; TODO perhaps do a type check and wrap in quotes if not a number 
4af1 21 c6 f3				ld hl, os_input 
4af4					if DEBUG_FORTH_WORDS 
4af4						DMARK "ED1" 
4af4 f5				push af  
4af5 3a 09 4b			ld a, (.dmark)  
4af8 32 6e fe			ld (debug_mark),a  
4afb 3a 0a 4b			ld a, (.dmark+1)  
4afe 32 6f fe			ld (debug_mark+1),a  
4b01 3a 0b 4b			ld a, (.dmark+2)  
4b04 32 70 fe			ld (debug_mark+2),a  
4b07 18 03			jr .pastdmark  
4b09 ..			.dmark: db "ED1"  
4b0c f1			.pastdmark: pop af  
4b0d			endm  
# End of macro DMARK
4b0d						CALLMONITOR 
4b0d cd f3 18			call break_point_state  
4b10				endm  
# End of macro CALLMONITOR
4b10					endif 
4b10 cd d5 1f				call forth_push_str 
4b13					NEXTW 
4b13 c3 0d 23			jp macro_next 
4b16				endm 
# End of macro NEXTW
4b16			 
4b16			 
4b16			 
4b16			.ENDKEY: 
4b16			; eof 
4b16			 
# End of file forth_words_key.asm
4b16			include "forth_words_const.asm" 
4b16			 
4b16			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4b16			 
4b16			 
4b16			.SPITIME: 
4b16				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4b16 77				db WORD_SYS_CORE+99             
4b17 2b 4b			dw .VA            
4b19 08				db 7 + 1 
4b1a .. 00			db "SPITIME",0              
4b22				endm 
# End of macro CWHEAD
4b22			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4b22			; 
4b22			; | If using BANK devices then leave as is. 
4b22			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4b22			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4b22			 
4b22 21 6b fa				ld hl, spi_clktime  
4b25 cd 67 1f				call forth_push_numhl 
4b28			 
4b28					NEXTW 
4b28 c3 0d 23			jp macro_next 
4b2b				endm 
# End of macro NEXTW
4b2b			 
4b2b			 
4b2b			.VA: 
4b2b				CWHEAD .ENDCONST 99 "VA" 2 WORD_FLAG_CODE 
4b2b 77				db WORD_SYS_CORE+99             
4b2c 3b 4b			dw .ENDCONST            
4b2e 03				db 2 + 1 
4b2f .. 00			db "VA",0              
4b32				endm 
# End of macro CWHEAD
4b32			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4b32 21 2f fa				ld hl, cli_var_array 
4b35 cd 67 1f				call forth_push_numhl 
4b38			 
4b38					NEXTW 
4b38 c3 0d 23			jp macro_next 
4b3b				endm 
# End of macro NEXTW
4b3b			 
4b3b			 
4b3b			;endif 
4b3b			 
4b3b			;LFSRSeed:	equ $fbb3 
4b3b			;chk_data_ovr:	equ $f761 
4b3b			;chk_loop_ovr:	equ $f963 
4b3b			;chk_ret_ovr:	equ $f9e5 
4b3b			;chk_ret_und:	equ $fa27 
4b3b			;chk_stovr:	equ $fefd 
4b3b			;chk_stund:	equ $ffff 
4b3b			;cli_autodisplay:	equ $fa43 
4b3b			;cli_buffer:	equ $fa51 
4b3b			;cli_data_sp:	equ $fa29 
4b3b			;cli_data_stack:	equ $f763 
4b3b			;cli_execword:	equ $fa4b 
4b3b			;cli_loop_sp:	equ $fa2b 
4b3b			;cli_loop_stack:	equ $f965 
4b3b			;cli_mvdot:	equ $fa44 
4b3b			;cli_nextword:	equ $fa49 
4b3b			;cli_origptr:	equ $fa45 
4b3b			;cli_origtoken:	equ $fa4f 
4b3b			;cli_ptr:	equ $fa47 
4b3b			;cli_ret_sp:	equ $fa2d 
4b3b			;cli_ret_stack:	equ $f9e7 
4b3b			;cli_token:	equ $fa4d 
4b3b			;cli_var_array:	equ $fa2f 
4b3b			;cursor_col:	equ $fbcb 
4b3b			;cursor_ptr:	equ $fbc9 
4b3b			;cursor_row:	equ $fbca 
4b3b			;cursor_shape:	equ $fbc7 
4b3b			;debug_mark:	equ $fe6e 
4b3b			;display_fb0:	equ $fdb4 
4b3b			;display_fb1:	equ $fd13 
4b3b			;display_fb2:	equ $fbd1 
4b3b			;display_fb3:	equ $fc72 
4b3b			;display_fb_active:	equ $fbcf 
4b3b			;display_lcde1e2:	equ $fbce 
4b3b			;execscratch:	equ $f2fb 
4b3b			;f_cursor_ptr:	equ $fa65 
4b3b			;hardware_word:	equ $fe72 
4b3b			;heap_start:	equ $800e 
4b3b			;iErrorNum:	equ $fba8 
4b3b			;iErrorReg:	equ $fba7 
4b3b			;iErrorVer:	equ $fba6 
4b3b			;input_at_cursor:	equ $fe65 
4b3b			;input_at_pos:	equ $fe67 
4b3b			;input_cur_flash:	equ $fe63 
4b3b			;input_cur_onoff:	equ $fe62 
4b3b			;input_cursor:	equ $fe58 
4b3b			;input_display_size:	equ $fe68 
4b3b			;input_len:	equ $fe5d 
4b3b			;input_ptr:	equ $fe6c 
4b3b			;input_size:	equ $fe69 
4b3b			;input_start:	equ $fe6a 
4b3b			;input_str:	equ $0f79 
4b3b			;input_under_cursor:	equ $fe66 
4b3b			;key_actual_pressed:	equ $fe57 
4b3b			;key_fa:	equ $fe82 
4b3b			;key_face_held:	equ $fe7e 
4b3b			;key_fb:	equ $fe81 
4b3b			;key_fc:	equ $fe80 
4b3b			;key_fd:	equ $fe7f 
4b3b			;key_held:	equ $fe88 
4b3b			;key_held_prev:	equ $fe87 
4b3b			;key_init:	equ $7060 
4b3b			;key_repeat_ct:	equ $fe83 
4b3b			;key_rows:	equ $0005 
4b3b			;key_shift:	equ $fe55 
4b3b			;key_symbol:	equ $fe56 
4b3b			;keyscan_scancol:	equ $fe89 
4b3b			;keyscan_table:	equ $fe93 
4b3b			;keyscan_table_row1:	equ $fef2 
4b3b			;keyscan_table_row2:	equ $fee7 
4b3b			;keyscan_table_row3:	equ $fedc 
4b3b			;keyscan_table_row4:	equ $fed1 
4b3b			;keyscan_table_row5:	equ $fec6 
4b3b			;os_cli_cmd:	equ $f523 
4b3b			;os_cur_ptr:	equ $f51f 
4b3b			;os_current_i:	equ $f521 
4b3b			;os_input:	equ $f3fa 
4b3b			;os_last_cmd:	equ $f622 
4b3b			;os_last_new_uword:	equ $f4f9 
4b3b			;os_new_exec:	equ $f1f0 
4b3b			;os_new_exec_ptr:	equ $f1ee 
4b3b			;os_new_malloc:	equ $f1fa 
4b3b			;os_new_parse_len:	equ $f1f8 
4b3b			;os_new_src_ptr:	equ $f1f2 
4b3b			;os_new_word_len:	equ $f1f6 
4b3b			;os_new_work_ptr:	equ $f1f4 
4b3b			;os_tok_len:	equ $f4ff 
4b3b			;os_tok_malloc:	equ $f4fb 
4b3b			;os_tok_ptr:	equ $f4fd 
4b3b			;os_var_array:	equ $f721 
4b3b			;os_view_af:	equ $f1eb 
4b3b			;os_view_bc:	equ $f1e5 
4b3b			;os_view_de:	equ $f1e7 
4b3b			;os_view_disable:	equ $f1ed 
4b3b			;os_view_hl:	equ $f1e9 
4b3b			;os_word_scratch:	equ $f501 
4b3b			;portbctl:	equ $00c3 
4b3b			;portbdata:	equ $00c1 
4b3b			;prng16:	equ $0e73 
4b3b			;prom_bootmsg:	equ $1ac9 
4b3b			;prom_bootmsg1:	equ $1ade 
4b3b			;randData:	equ $fbb1 
4b3b			;scratch:	equ $f1fc 
4b3b			;seed1:	equ $fbab 
4b3b			;seed2:	equ $fba9 
4b3b			;spi_cartdev:	equ $fa6a 
4b3b			;spi_cartdev2:	equ $fa69 
4b3b			;spi_clktime:	equ $fa6b 
4b3b			;spi_device:	equ $fa67 
4b3b			;spi_device_id:	equ $fa66 
4b3b			;spi_portbyte:	equ $fa68 
4b3b			;stackstore:	equ $fbad 
4b3b			;;start1:	equ $5bfc 
4b3b			;;start2:	equ $5c0e 
4b3b			;;start3b:	equ $5c21 
4b3b			;;start3c:	equ $5c9d 
4b3b			;;startcmds:	equ $57a3 
4b3b			;;stest:	equ $5d67 
4b3b			;;storage_actl:	equ $0082 
4b3b			;;storage_adata:	equ $0080 
4b3b			;;storage_append:	equ $0b0c 
4b3b			;;storage_bctl:	equ $0083 
4b3b			;store_bank_active:	equ $fb99 
4b3b			;store_filecache:	equ $fa6e 
4b3b			;store_longread:	equ $fa7c 
4b3b			;store_openaddr:	equ $fa72 
4b3b			;store_openext:	equ $fa71 
4b3b			;store_openmaxext:	equ $fa70 
4b3b			;store_page:	equ $fa81 
4b3b			;store_readbuf:	equ $fa7d 
4b3b			;store_readcont:	equ $fa74 
4b3b			;store_readptr:	equ $fa7f 
4b3b			;store_tmp1:	equ $fa7a 
4b3b			;store_tmp2:	equ $fa78 
4b3b			;store_tmp3:	equ $fa76 
4b3b			;store_tmpext:	equ $fa74 
4b3b			;store_tmpid:	equ $fa75 
4b3b			;store_tmppageid:	equ $fa6c 
4b3b			;tos:	equ $fffd 
4b3b			;type:	equ $5b77 
4b3b			;xrandc:	equ $fbaf 
4b3b			 
4b3b			 
4b3b			.ENDCONST: 
4b3b			 
4b3b			; eof 
4b3b			 
4b3b			 
# End of file forth_words_const.asm
4b3b			 
4b3b			if STORAGE_SE 
4b3b			   	include "forth_words_storage.asm" 
4b3b			 
4b3b			; | ## Fixed Storage Words 
4b3b			 
4b3b			.RECORD: 
4b3b			  
4b3b				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4b3b 3a				db WORD_SYS_CORE+38             
4b3c df 4b			dw .BREAD            
4b3e 07				db 6 + 1 
4b3f .. 00			db "RECORD",0              
4b46				endm 
# End of macro CWHEAD
4b46			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4b46			 
4b46					if DEBUG_FORTH_WORDS_KEY 
4b46						DMARK "REC" 
4b46 f5				push af  
4b47 3a 5b 4b			ld a, (.dmark)  
4b4a 32 6e fe			ld (debug_mark),a  
4b4d 3a 5c 4b			ld a, (.dmark+1)  
4b50 32 6f fe			ld (debug_mark+1),a  
4b53 3a 5d 4b			ld a, (.dmark+2)  
4b56 32 70 fe			ld (debug_mark+2),a  
4b59 18 03			jr .pastdmark  
4b5b ..			.dmark: db "REC"  
4b5e f1			.pastdmark: pop af  
4b5f			endm  
# End of macro DMARK
4b5f						CALLMONITOR 
4b5f cd f3 18			call break_point_state  
4b62				endm  
# End of macro CALLMONITOR
4b62					endif 
4b62			 
4b62					FORTH_DSP_VALUEHL 
4b62 cd 5e 21			call macro_dsp_valuehl 
4b65				endm 
# End of macro FORTH_DSP_VALUEHL
4b65			 
4b65 e5					push hl    ; id 
4b66			 
4b66					FORTH_DSP_POP 
4b66 cd 16 22			call macro_forth_dsp_pop 
4b69				endm 
# End of macro FORTH_DSP_POP
4b69			 
4b69					FORTH_DSP_VALUEHL 
4b69 cd 5e 21			call macro_dsp_valuehl 
4b6c				endm 
# End of macro FORTH_DSP_VALUEHL
4b6c			 
4b6c					FORTH_DSP_POP 
4b6c cd 16 22			call macro_forth_dsp_pop 
4b6f				endm 
# End of macro FORTH_DSP_POP
4b6f			 
4b6f d1					pop de     ; get file id 
4b70			 
4b70					; e = file id 
4b70					; l = file extent 
4b70			 
4b70			 
4b70					; construct request to access file extent 
4b70			 
4b70			;		ld a, e 
4b70 63					ld h, e 
4b71					 
4b71					 
4b71					 
4b71			 
4b71					; e has id 
4b71			 
4b71 11 81 fa			ld de, store_page 
4b74					if DEBUG_FORTH_WORDS 
4b74						DMARK "REr" 
4b74 f5				push af  
4b75 3a 89 4b			ld a, (.dmark)  
4b78 32 6e fe			ld (debug_mark),a  
4b7b 3a 8a 4b			ld a, (.dmark+1)  
4b7e 32 6f fe			ld (debug_mark+1),a  
4b81 3a 8b 4b			ld a, (.dmark+2)  
4b84 32 70 fe			ld (debug_mark+2),a  
4b87 18 03			jr .pastdmark  
4b89 ..			.dmark: db "REr"  
4b8c f1			.pastdmark: pop af  
4b8d			endm  
# End of macro DMARK
4b8d						CALLMONITOR 
4b8d cd f3 18			call break_point_state  
4b90				endm  
# End of macro CALLMONITOR
4b90					endif 
4b90 cd 75 09				call storage_read 
4b93 cd 75 0f			call ishlzero 
4b96 28 22			jr z, .recnotfound 
4b98			 
4b98			 
4b98					if DEBUG_FORTH_WORDS 
4b98						DMARK "REe" 
4b98 f5				push af  
4b99 3a ad 4b			ld a, (.dmark)  
4b9c 32 6e fe			ld (debug_mark),a  
4b9f 3a ae 4b			ld a, (.dmark+1)  
4ba2 32 6f fe			ld (debug_mark+1),a  
4ba5 3a af 4b			ld a, (.dmark+2)  
4ba8 32 70 fe			ld (debug_mark+2),a  
4bab 18 03			jr .pastdmark  
4bad ..			.dmark: db "REe"  
4bb0 f1			.pastdmark: pop af  
4bb1			endm  
# End of macro DMARK
4bb1						CALLMONITOR 
4bb1 cd f3 18			call break_point_state  
4bb4				endm  
# End of macro CALLMONITOR
4bb4					endif 
4bb4 cd d5 1f			call forth_push_str 
4bb7			 
4bb7					NEXTW 
4bb7 c3 0d 23			jp macro_next 
4bba				endm 
# End of macro NEXTW
4bba			 
4bba			.recnotfound: 
4bba					if DEBUG_FORTH_WORDS 
4bba						DMARK "REf" 
4bba f5				push af  
4bbb 3a cf 4b			ld a, (.dmark)  
4bbe 32 6e fe			ld (debug_mark),a  
4bc1 3a d0 4b			ld a, (.dmark+1)  
4bc4 32 6f fe			ld (debug_mark+1),a  
4bc7 3a d1 4b			ld a, (.dmark+2)  
4bca 32 70 fe			ld (debug_mark+2),a  
4bcd 18 03			jr .pastdmark  
4bcf ..			.dmark: db "REf"  
4bd2 f1			.pastdmark: pop af  
4bd3			endm  
# End of macro DMARK
4bd3						CALLMONITOR 
4bd3 cd f3 18			call break_point_state  
4bd6				endm  
# End of macro CALLMONITOR
4bd6					endif 
4bd6 21 ff 00			ld hl, 255 
4bd9 cd 67 1f			call forth_push_numhl 
4bdc				NEXTW 
4bdc c3 0d 23			jp macro_next 
4bdf				endm 
# End of macro NEXTW
4bdf			 
4bdf			 
4bdf			.BREAD: 
4bdf			  
4bdf				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4bdf 3a				db WORD_SYS_CORE+38             
4be0 62 4c			dw .BWRITE            
4be2 06				db 5 + 1 
4be3 .. 00			db "BREAD",0              
4be9				endm 
# End of macro CWHEAD
4be9			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4be9				 
4be9					if DEBUG_FORTH_WORDS_KEY 
4be9						DMARK "BRD" 
4be9 f5				push af  
4bea 3a fe 4b			ld a, (.dmark)  
4bed 32 6e fe			ld (debug_mark),a  
4bf0 3a ff 4b			ld a, (.dmark+1)  
4bf3 32 6f fe			ld (debug_mark+1),a  
4bf6 3a 00 4c			ld a, (.dmark+2)  
4bf9 32 70 fe			ld (debug_mark+2),a  
4bfc 18 03			jr .pastdmark  
4bfe ..			.dmark: db "BRD"  
4c01 f1			.pastdmark: pop af  
4c02			endm  
# End of macro DMARK
4c02						CALLMONITOR 
4c02 cd f3 18			call break_point_state  
4c05				endm  
# End of macro CALLMONITOR
4c05					endif 
4c05			 
4c05				FORTH_DSP_VALUEHL 
4c05 cd 5e 21			call macro_dsp_valuehl 
4c08				endm 
# End of macro FORTH_DSP_VALUEHL
4c08			 
4c08				FORTH_DSP_POP 
4c08 cd 16 22			call macro_forth_dsp_pop 
4c0b				endm 
# End of macro FORTH_DSP_POP
4c0b			 
4c0b				; calc block address 
4c0b			 
4c0b eb				ex de, hl 
4c0c 3e 40			ld a, STORE_BLOCK_PHY 
4c0e cd cf 0e			call Mult16 
4c11			 
4c11			 
4c11 11 81 fa			ld de, store_page 
4c14			 
4c14					if DEBUG_FORTH_WORDS 
4c14						DMARK "BR1" 
4c14 f5				push af  
4c15 3a 29 4c			ld a, (.dmark)  
4c18 32 6e fe			ld (debug_mark),a  
4c1b 3a 2a 4c			ld a, (.dmark+1)  
4c1e 32 6f fe			ld (debug_mark+1),a  
4c21 3a 2b 4c			ld a, (.dmark+2)  
4c24 32 70 fe			ld (debug_mark+2),a  
4c27 18 03			jr .pastdmark  
4c29 ..			.dmark: db "BR1"  
4c2c f1			.pastdmark: pop af  
4c2d			endm  
# End of macro DMARK
4c2d						CALLMONITOR 
4c2d cd f3 18			call break_point_state  
4c30				endm  
# End of macro CALLMONITOR
4c30					endif 
4c30			 
4c30 cd 1c 04			call storage_read_block 
4c33			 
4c33 cd 75 0f			call ishlzero 
4c36 20 05			jr nz, .brfound 
4c38			 
4c38 cd 67 1f			call forth_push_numhl 
4c3b 18 22			jr .brdone 
4c3d			 
4c3d			 
4c3d			.brfound: 
4c3d 21 83 fa		        ld hl, store_page+2 
4c40			 
4c40					if DEBUG_FORTH_WORDS 
4c40						DMARK "BR2" 
4c40 f5				push af  
4c41 3a 55 4c			ld a, (.dmark)  
4c44 32 6e fe			ld (debug_mark),a  
4c47 3a 56 4c			ld a, (.dmark+1)  
4c4a 32 6f fe			ld (debug_mark+1),a  
4c4d 3a 57 4c			ld a, (.dmark+2)  
4c50 32 70 fe			ld (debug_mark+2),a  
4c53 18 03			jr .pastdmark  
4c55 ..			.dmark: db "BR2"  
4c58 f1			.pastdmark: pop af  
4c59			endm  
# End of macro DMARK
4c59						CALLMONITOR 
4c59 cd f3 18			call break_point_state  
4c5c				endm  
# End of macro CALLMONITOR
4c5c					endif 
4c5c			 
4c5c cd d5 1f			call forth_push_str 
4c5f			 
4c5f			 
4c5f			.brdone: 
4c5f			 
4c5f					NEXTW 
4c5f c3 0d 23			jp macro_next 
4c62				endm 
# End of macro NEXTW
4c62			.BWRITE: 
4c62				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4c62 3a				db WORD_SYS_CORE+38             
4c63 f7 4c			dw .BUPD            
4c65 07				db 6 + 1 
4c66 .. 00			db "BWRITE",0              
4c6d				endm 
# End of macro CWHEAD
4c6d			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
4c6d			 
4c6d					if DEBUG_FORTH_WORDS_KEY 
4c6d						DMARK "BWR" 
4c6d f5				push af  
4c6e 3a 82 4c			ld a, (.dmark)  
4c71 32 6e fe			ld (debug_mark),a  
4c74 3a 83 4c			ld a, (.dmark+1)  
4c77 32 6f fe			ld (debug_mark+1),a  
4c7a 3a 84 4c			ld a, (.dmark+2)  
4c7d 32 70 fe			ld (debug_mark+2),a  
4c80 18 03			jr .pastdmark  
4c82 ..			.dmark: db "BWR"  
4c85 f1			.pastdmark: pop af  
4c86			endm  
# End of macro DMARK
4c86						CALLMONITOR 
4c86 cd f3 18			call break_point_state  
4c89				endm  
# End of macro CALLMONITOR
4c89					endif 
4c89			 
4c89				FORTH_DSP_VALUEHL 
4c89 cd 5e 21			call macro_dsp_valuehl 
4c8c				endm 
# End of macro FORTH_DSP_VALUEHL
4c8c			 
4c8c				; calc block address 
4c8c			 
4c8c eb				ex de, hl 
4c8d 3e 40			ld a, STORE_BLOCK_PHY 
4c8f cd cf 0e			call Mult16 
4c92			 
4c92 e5				push hl         ; address 
4c93			 
4c93				FORTH_DSP_POP 
4c93 cd 16 22			call macro_forth_dsp_pop 
4c96				endm 
# End of macro FORTH_DSP_POP
4c96			 
4c96				FORTH_DSP_VALUEHL 
4c96 cd 5e 21			call macro_dsp_valuehl 
4c99				endm 
# End of macro FORTH_DSP_VALUEHL
4c99			 
4c99				FORTH_DSP_POP 
4c99 cd 16 22			call macro_forth_dsp_pop 
4c9c				endm 
# End of macro FORTH_DSP_POP
4c9c			 
4c9c cd 58 0c			call storage_clear_page 
4c9f			 
4c9f				; copy string to store page 
4c9f			 
4c9f e5				push hl     ; save string address 
4ca0			 
4ca0 3e 00			ld a, 0 
4ca2 cd b5 13			call strlent 
4ca5			 
4ca5 23				inc hl 
4ca6			 
4ca6 4d				ld c, l 
4ca7 06 00			ld b, 0 
4ca9			 
4ca9 e1				pop hl 
4caa 11 83 fa			ld de, store_page + 2 
4cad					if DEBUG_FORTH_WORDS 
4cad						DMARK "BW1" 
4cad f5				push af  
4cae 3a c2 4c			ld a, (.dmark)  
4cb1 32 6e fe			ld (debug_mark),a  
4cb4 3a c3 4c			ld a, (.dmark+1)  
4cb7 32 6f fe			ld (debug_mark+1),a  
4cba 3a c4 4c			ld a, (.dmark+2)  
4cbd 32 70 fe			ld (debug_mark+2),a  
4cc0 18 03			jr .pastdmark  
4cc2 ..			.dmark: db "BW1"  
4cc5 f1			.pastdmark: pop af  
4cc6			endm  
# End of macro DMARK
4cc6						CALLMONITOR 
4cc6 cd f3 18			call break_point_state  
4cc9				endm  
# End of macro CALLMONITOR
4cc9					endif 
4cc9 ed b0			ldir 
4ccb			 
4ccb			 
4ccb				; poke the start of the block with flags to prevent high level file ops hitting the block 
4ccb			 
4ccb 21 ff ff			ld hl, $ffff 
4cce			 
4cce 22 81 fa			ld (store_page), hl	 
4cd1				 
4cd1 e1				pop hl    ; get address 
4cd2 11 81 fa			ld de, store_page 
4cd5			 
4cd5					if DEBUG_FORTH_WORDS 
4cd5						DMARK "BW2" 
4cd5 f5				push af  
4cd6 3a ea 4c			ld a, (.dmark)  
4cd9 32 6e fe			ld (debug_mark),a  
4cdc 3a eb 4c			ld a, (.dmark+1)  
4cdf 32 6f fe			ld (debug_mark+1),a  
4ce2 3a ec 4c			ld a, (.dmark+2)  
4ce5 32 70 fe			ld (debug_mark+2),a  
4ce8 18 03			jr .pastdmark  
4cea ..			.dmark: db "BW2"  
4ced f1			.pastdmark: pop af  
4cee			endm  
# End of macro DMARK
4cee						CALLMONITOR 
4cee cd f3 18			call break_point_state  
4cf1				endm  
# End of macro CALLMONITOR
4cf1					endif 
4cf1			 
4cf1 cd 81 04			call storage_write_block 
4cf4			 
4cf4					NEXTW 
4cf4 c3 0d 23			jp macro_next 
4cf7				endm 
# End of macro NEXTW
4cf7			 
4cf7			.BUPD: 
4cf7				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4cf7 3a				db WORD_SYS_CORE+38             
4cf8 4d 4d			dw .BYID            
4cfa 05				db 4 + 1 
4cfb .. 00			db "BUPD",0              
4d00				endm 
# End of macro CWHEAD
4d00			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4d00			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4d00			; | | or completely different file system structure. 
4d00			 
4d00					if DEBUG_FORTH_WORDS_KEY 
4d00						DMARK "BUD" 
4d00 f5				push af  
4d01 3a 15 4d			ld a, (.dmark)  
4d04 32 6e fe			ld (debug_mark),a  
4d07 3a 16 4d			ld a, (.dmark+1)  
4d0a 32 6f fe			ld (debug_mark+1),a  
4d0d 3a 17 4d			ld a, (.dmark+2)  
4d10 32 70 fe			ld (debug_mark+2),a  
4d13 18 03			jr .pastdmark  
4d15 ..			.dmark: db "BUD"  
4d18 f1			.pastdmark: pop af  
4d19			endm  
# End of macro DMARK
4d19						CALLMONITOR 
4d19 cd f3 18			call break_point_state  
4d1c				endm  
# End of macro CALLMONITOR
4d1c					endif 
4d1c			 
4d1c				FORTH_DSP_VALUEHL 
4d1c cd 5e 21			call macro_dsp_valuehl 
4d1f				endm 
# End of macro FORTH_DSP_VALUEHL
4d1f			 
4d1f				; calc block address 
4d1f			 
4d1f eb				ex de, hl 
4d20 3e 40			ld a, STORE_BLOCK_PHY 
4d22 cd cf 0e			call Mult16 
4d25			 
4d25				FORTH_DSP_POP 
4d25 cd 16 22			call macro_forth_dsp_pop 
4d28				endm 
# End of macro FORTH_DSP_POP
4d28			 
4d28			 
4d28 11 81 fa			ld de, store_page 
4d2b			 
4d2b					if DEBUG_FORTH_WORDS 
4d2b						DMARK "BUe" 
4d2b f5				push af  
4d2c 3a 40 4d			ld a, (.dmark)  
4d2f 32 6e fe			ld (debug_mark),a  
4d32 3a 41 4d			ld a, (.dmark+1)  
4d35 32 6f fe			ld (debug_mark+1),a  
4d38 3a 42 4d			ld a, (.dmark+2)  
4d3b 32 70 fe			ld (debug_mark+2),a  
4d3e 18 03			jr .pastdmark  
4d40 ..			.dmark: db "BUe"  
4d43 f1			.pastdmark: pop af  
4d44			endm  
# End of macro DMARK
4d44						CALLMONITOR 
4d44 cd f3 18			call break_point_state  
4d47				endm  
# End of macro CALLMONITOR
4d47					endif 
4d47			 
4d47 cd 81 04			call storage_write_block 
4d4a			 
4d4a					NEXTW 
4d4a c3 0d 23			jp macro_next 
4d4d				endm 
# End of macro NEXTW
4d4d			 
4d4d			.BYID: 
4d4d			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4d4d			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4d4d			; 
4d4d			;		 
4d4d			;		if DEBUG_FORTH_WORDS_KEY 
4d4d			;			DMARK "BYID" 
4d4d			;			CALLMONITOR 
4d4d			;		endif 
4d4d			; 
4d4d			;		; get direct address 
4d4d			; 
4d4d			;		FORTH_DSP_VALUEHL 
4d4d			; 
4d4d			;		FORTH_DSP_POP 
4d4d			; 
4d4d			;	; calc block address 
4d4d			; 
4d4d			;	ex de, hl 
4d4d			;	ld a, STORE_BLOCK_PHY 
4d4d			;	call Mult16 
4d4d			;	;	do BREAD with number as param 
4d4d			;	; push the file name	 
4d4d			;	ld de, store_page 
4d4d			;	call storage_read_block 
4d4d			 ;       ld hl, store_page+2 
4d4d			; 
4d4d			; 
4d4d			;		NEXTW 
4d4d			;.BYNAME: 
4d4d				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4d4d 3a				db WORD_SYS_CORE+38             
4d4e 66 4d			dw .DIR            
4d50 06				db 5 + 1 
4d51 .. 00			db "GETID",0              
4d57				endm 
# End of macro CWHEAD
4d57			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4d57			 
4d57					; get pointer to file name to seek 
4d57			 
4d57					FORTH_DSP_VALUEHL 
4d57 cd 5e 21			call macro_dsp_valuehl 
4d5a				endm 
# End of macro FORTH_DSP_VALUEHL
4d5a			 
4d5a			 
4d5a cd 43 03				call storage_getid  
4d5d			 
4d5d					FORTH_DSP_POP 
4d5d cd 16 22			call macro_forth_dsp_pop 
4d60				endm 
# End of macro FORTH_DSP_POP
4d60			 
4d60 cd 67 1f				call forth_push_numhl 
4d63			 
4d63					NEXTW 
4d63 c3 0d 23			jp macro_next 
4d66				endm 
# End of macro NEXTW
4d66			; 
4d66			.DIR: 
4d66				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4d66 3a				db WORD_SYS_CORE+38             
4d67 6a 4e			dw .SAVE            
4d69 04				db 3 + 1 
4d6a .. 00			db "DIR",0              
4d6e				endm 
# End of macro CWHEAD
4d6e			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4d6e			 
4d6e					if DEBUG_FORTH_WORDS_KEY 
4d6e						DMARK "DIR" 
4d6e f5				push af  
4d6f 3a 83 4d			ld a, (.dmark)  
4d72 32 6e fe			ld (debug_mark),a  
4d75 3a 84 4d			ld a, (.dmark+1)  
4d78 32 6f fe			ld (debug_mark+1),a  
4d7b 3a 85 4d			ld a, (.dmark+2)  
4d7e 32 70 fe			ld (debug_mark+2),a  
4d81 18 03			jr .pastdmark  
4d83 ..			.dmark: db "DIR"  
4d86 f1			.pastdmark: pop af  
4d87			endm  
# End of macro DMARK
4d87						CALLMONITOR 
4d87 cd f3 18			call break_point_state  
4d8a				endm  
# End of macro CALLMONITOR
4d8a					endif 
4d8a cd cd 04			call storage_get_block_0 
4d8d			 
4d8d 21 81 fa			ld hl, store_page     ; get current id count 
4d90 46				ld b, (hl) 
4d91 0e 00			ld c, 0    ; count of files   
4d93					if DEBUG_FORTH_WORDS 
4d93						DMARK "DI1" 
4d93 f5				push af  
4d94 3a a8 4d			ld a, (.dmark)  
4d97 32 6e fe			ld (debug_mark),a  
4d9a 3a a9 4d			ld a, (.dmark+1)  
4d9d 32 6f fe			ld (debug_mark+1),a  
4da0 3a aa 4d			ld a, (.dmark+2)  
4da3 32 70 fe			ld (debug_mark+2),a  
4da6 18 03			jr .pastdmark  
4da8 ..			.dmark: db "DI1"  
4dab f1			.pastdmark: pop af  
4dac			endm  
# End of macro DMARK
4dac						CALLMONITOR 
4dac cd f3 18			call break_point_state  
4daf				endm  
# End of macro CALLMONITOR
4daf					endif 
4daf			 
4daf				; check for empty drive 
4daf			 
4daf 3e 00			ld a, 0 
4db1 b8				cp b 
4db2 ca 20 4e			jp z, .dirdone 
4db5			 
4db5				; for each of the current ids do a search for them and if found push to stack 
4db5			 
4db5 c5			.diritem:	push bc 
4db6 21 40 00				ld hl, STORE_BLOCK_PHY 
4db9 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4dbb 58					ld e,b 
4dbc			 
4dbc			;		if DEBUG_FORTH_WORDS 
4dbc			;			DMARK "DI2" 
4dbc			;			CALLMONITOR 
4dbc			;		endif 
4dbc			 
4dbc cd 4f 07				call storage_findnextid 
4dbf			 
4dbf			;		if DEBUG_FORTH_WORDS 
4dbf			;			DMARK "DI3" 
4dbf			;			CALLMONITOR 
4dbf			;		endif 
4dbf			 
4dbf					; if found hl will be non zero 
4dbf			 
4dbf cd 75 0f				call ishlzero 
4dc2			;		ld a, l 
4dc2			;		add h 
4dc2			; 
4dc2			;		cp 0 
4dc2 28 59				jr z, .dirnotfound 
4dc4			 
4dc4					; increase count 
4dc4			 
4dc4 c1					pop bc	 
4dc5 0c					inc c 
4dc6 c5					push bc 
4dc7					 
4dc7			 
4dc7					; get file header and push the file name 
4dc7			 
4dc7 11 81 fa				ld de, store_page 
4dca cd 1c 04				call storage_read_block 
4dcd			 
4dcd					; push file id to stack 
4dcd				 
4dcd 3a 81 fa				ld a, (store_page) 
4dd0 26 00				ld h, 0 
4dd2 6f					ld l, a 
4dd3 cd 67 1f				call forth_push_numhl 
4dd6			 
4dd6					; push extent count to stack  
4dd6				 
4dd6 3a 83 fa				ld a, (store_page+2) 
4dd9 26 00				ld h, 0 
4ddb 6f					ld l, a 
4ddc cd 67 1f				call forth_push_numhl 
4ddf			 
4ddf					; push file name 
4ddf			 
4ddf 21 84 fa				ld hl, store_page+3 
4de2					if DEBUG_FORTH_WORDS 
4de2						DMARK "DI5" 
4de2 f5				push af  
4de3 3a f7 4d			ld a, (.dmark)  
4de6 32 6e fe			ld (debug_mark),a  
4de9 3a f8 4d			ld a, (.dmark+1)  
4dec 32 6f fe			ld (debug_mark+1),a  
4def 3a f9 4d			ld a, (.dmark+2)  
4df2 32 70 fe			ld (debug_mark+2),a  
4df5 18 03			jr .pastdmark  
4df7 ..			.dmark: db "DI5"  
4dfa f1			.pastdmark: pop af  
4dfb			endm  
# End of macro DMARK
4dfb						CALLMONITOR 
4dfb cd f3 18			call break_point_state  
4dfe				endm  
# End of macro CALLMONITOR
4dfe					endif 
4dfe cd d5 1f				call forth_push_str 
4e01					if DEBUG_FORTH_WORDS 
4e01						DMARK "DI6" 
4e01 f5				push af  
4e02 3a 16 4e			ld a, (.dmark)  
4e05 32 6e fe			ld (debug_mark),a  
4e08 3a 17 4e			ld a, (.dmark+1)  
4e0b 32 6f fe			ld (debug_mark+1),a  
4e0e 3a 18 4e			ld a, (.dmark+2)  
4e11 32 70 fe			ld (debug_mark+2),a  
4e14 18 03			jr .pastdmark  
4e16 ..			.dmark: db "DI6"  
4e19 f1			.pastdmark: pop af  
4e1a			endm  
# End of macro DMARK
4e1a						CALLMONITOR 
4e1a cd f3 18			call break_point_state  
4e1d				endm  
# End of macro CALLMONITOR
4e1d					endif 
4e1d			.dirnotfound: 
4e1d c1					pop bc     
4e1e 10 95				djnz .diritem 
4e20				 
4e20			.dirdone:	 
4e20					if DEBUG_FORTH_WORDS 
4e20						DMARK "DI7" 
4e20 f5				push af  
4e21 3a 35 4e			ld a, (.dmark)  
4e24 32 6e fe			ld (debug_mark),a  
4e27 3a 36 4e			ld a, (.dmark+1)  
4e2a 32 6f fe			ld (debug_mark+1),a  
4e2d 3a 37 4e			ld a, (.dmark+2)  
4e30 32 70 fe			ld (debug_mark+2),a  
4e33 18 03			jr .pastdmark  
4e35 ..			.dmark: db "DI7"  
4e38 f1			.pastdmark: pop af  
4e39			endm  
# End of macro DMARK
4e39						CALLMONITOR 
4e39 cd f3 18			call break_point_state  
4e3c				endm  
# End of macro CALLMONITOR
4e3c					endif 
4e3c			 
4e3c					; push a count of the dir items found 
4e3c			 
4e3c 26 00				ld h, 0 
4e3e 69					ld l, c 
4e3f cd 67 1f				call forth_push_numhl 
4e42			 
4e42					; push the bank label 
4e42			 
4e42 cd cd 04				call storage_get_block_0 
4e45			 
4e45				 
4e45 21 84 fa		 		ld hl, store_page+3 
4e48			 
4e48					if DEBUG_FORTH_WORDS 
4e48						DMARK "DI8" 
4e48 f5				push af  
4e49 3a 5d 4e			ld a, (.dmark)  
4e4c 32 6e fe			ld (debug_mark),a  
4e4f 3a 5e 4e			ld a, (.dmark+1)  
4e52 32 6f fe			ld (debug_mark+1),a  
4e55 3a 5f 4e			ld a, (.dmark+2)  
4e58 32 70 fe			ld (debug_mark+2),a  
4e5b 18 03			jr .pastdmark  
4e5d ..			.dmark: db "DI8"  
4e60 f1			.pastdmark: pop af  
4e61			endm  
# End of macro DMARK
4e61						CALLMONITOR 
4e61 cd f3 18			call break_point_state  
4e64				endm  
# End of macro CALLMONITOR
4e64					endif 
4e64 cd d5 1f				call forth_push_str 
4e67			 
4e67			 
4e67				 
4e67					NEXTW 
4e67 c3 0d 23			jp macro_next 
4e6a				endm 
# End of macro NEXTW
4e6a			.SAVE: 
4e6a			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4e6a			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4e6a			;		NEXTW 
4e6a			;.LOAD: 
4e6a			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4e6a			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4e6a			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4e6a			;; > > The LOAD command can not be used in any user words or compound lines. 
4e6a			; 
4e6a			;		; store_openext use it. If zero it is EOF 
4e6a			; 
4e6a			;		; read block from current stream id 
4e6a			;		; if the block does not contain zero term keep reading blocks until zero found 
4e6a			;		; push the block to stack 
4e6a			;		; save the block id to stream 
4e6a			; 
4e6a			; 
4e6a			;		FORTH_DSP_VALUEHL 
4e6a			; 
4e6a			;;		push hl 
4e6a			; 
4e6a			;	if DEBUG_STORESE 
4e6a			;		DMARK "LOA" 
4e6a			;		CALLMONITOR 
4e6a			;	endif 
4e6a			;		FORTH_DSP_POP 
4e6a			; 
4e6a			;;		pop hl 
4e6a			; 
4e6a			;		ld h, l 
4e6a			;		ld l, 0 
4e6a			; 
4e6a			;		push hl     ; stack holds current file id and extent to work with 
4e6a			; 
4e6a			; 
4e6a			;		ld de, store_page      ; get block zero of file 
4e6a			;	if DEBUG_STORESE 
4e6a			;		DMARK "LO0" 
4e6a			;		CALLMONITOR 
4e6a			;	endif 
4e6a			;		call storage_read 
4e6a			; 
4e6a			;		ld a, (store_page+2)    ; max extents for this file 
4e6a			;		ld  (store_openmaxext),a   ; get our limit 
4e6a			; 
4e6a			;	if DEBUG_STORESE 
4e6a			;		DMARK "LOE" 
4e6a			;		CALLMONITOR 
4e6a			;	endif 
4e6a			; 
4e6a			;; TODO dont know why max extents are not present 
4e6a			;;		cp 0 
4e6a			;;		jp z, .loadeof     ; dont read past eof 
4e6a			; 
4e6a			;;		ld a, 1   ; start from the head of the file 
4e6a			; 
4e6a			;.loadline:	pop hl 
4e6a			;		inc hl 
4e6a			;		ld  a, (store_openmaxext)   ; get our limit 
4e6a			;	if DEBUG_STORESE 
4e6a			;		DMARK "LOx" 
4e6a			;		CALLMONITOR 
4e6a			;	endif 
4e6a			;		inc a 
4e6a			;		cp l 
4e6a			;		jp z, .loadeof 
4e6a			;		push hl    ; save current extent 
4e6a			; 
4e6a			;		ld de, store_page 
4e6a			; 
4e6a			;	if DEBUG_STORESE 
4e6a			;		DMARK "LO1" 
4e6a			;		CALLMONITOR 
4e6a			;	endif 
4e6a			;		call storage_read 
4e6a			; 
4e6a			;	if DEBUG_STORESE 
4e6a			;		DMARK "LO2" 
4e6a			;		CALLMONITOR 
4e6a			;	endif 
4e6a			;	call ishlzero 
4e6a			;	ld a, l 
4e6a			;	add h 
4e6a			;	cp 0 
4e6a			;	jr z, .loadeof 
4e6a			; 
4e6a			;	; not eof so hl should point to data to exec 
4e6a			; 
4e6a			;	; will need to add the FORTH_END_BUFFER flag 
4e6a			 ; 
4e6a			;	ld hl, store_page+2 
4e6a			;	ld bc, 255 
4e6a			;	ld a, 0 
4e6a			;	cpir 
4e6a			;	if DEBUG_STORESE 
4e6a			;		DMARK "LOt" 
4e6a			;		CALLMONITOR 
4e6a			;	endif 
4e6a			;	dec hl 
4e6a			;	ld a, ' ' 
4e6a			;	ld (hl), a 
4e6a			;	inc hl 
4e6a			;	ld (hl), a 
4e6a			;	inc hl 
4e6a			;	ld (hl), a 
4e6a			;	inc hl 
4e6a			;	ld a, FORTH_END_BUFFER 
4e6a			;	ld (hl), a 
4e6a			; 
4e6a			;	; TODO handle more than a single block read 
4e6a			; 
4e6a			; 
4e6a			;	ld hl, store_page+2 
4e6a			; 
4e6a			;	ld (os_tok_ptr), hl 
4e6a			; 
4e6a			;	if DEBUG_STORESE 
4e6a			;		DMARK "LO3" 
4e6a			;		CALLMONITOR 
4e6a			;	endif 
4e6a			; 
4e6a			;	call forthparse 
4e6a			;	call forthexec 
4e6a			;	call forthexec_cleanup 
4e6a			; 
4e6a			;	; go to next extent 
4e6a			; 
4e6a			;	; get next block  or mark as eof 
4e6a			;	jp .loadline 
4e6a			; 
4e6a			; 
4e6a			; 
4e6a			;	       NEXTW 
4e6a			;.loadeof:	ld a, 0 
4e6a			;		ld (store_openext), a 
4e6a			; 
4e6a			;	if DEBUG_STORESE 
4e6a			;		DMARK "LOF" 
4e6a			;		CALLMONITOR 
4e6a			;	endif 
4e6a			;		ret 
4e6a			;		;NEXTW 
4e6a			;.BSAVE:   
4e6a			; 
4e6a			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4e6a			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4e6a			;		NEXTW 
4e6a			;.BLOAD: 
4e6a			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4e6a			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4e6a			;		NEXTW 
4e6a			;;;; counter gap 
4e6a			 
4e6a			 
4e6a			.SEO: 
4e6a				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4e6a 64				db WORD_SYS_CORE+80             
4e6b 89 4e			dw .SEI            
4e6d 04				db 3 + 1 
4e6e .. 00			db "SEO",0              
4e72				endm 
# End of macro CWHEAD
4e72			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4e72			 
4e72					; get port 
4e72			 
4e72					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e72 cd 5e 21			call macro_dsp_valuehl 
4e75				endm 
# End of macro FORTH_DSP_VALUEHL
4e75			 
4e75 e5					push hl    ; u2 - byte 
4e76			 
4e76					; destroy value TOS 
4e76			 
4e76					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e76 cd 16 22			call macro_forth_dsp_pop 
4e79				endm 
# End of macro FORTH_DSP_POP
4e79			 
4e79					; get byte to send 
4e79			 
4e79					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e79 cd 5e 21			call macro_dsp_valuehl 
4e7c				endm 
# End of macro FORTH_DSP_VALUEHL
4e7c			 
4e7c e5					push hl    ; u1 - addr 
4e7d			 
4e7d					; destroy value TOS 
4e7d			 
4e7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e7d cd 16 22			call macro_forth_dsp_pop 
4e80				endm 
# End of macro FORTH_DSP_POP
4e80			 
4e80					; one value on hl get other one back 
4e80			 
4e80 d1					pop de   ; u1 - byte 
4e81			 
4e81 e1					pop hl   ; u2 - addr 
4e82			 
4e82					; TODO Send SPI byte 
4e82			 
4e82			 
4e82 7b					ld a, e 
4e83 cd 21 02				call se_writebyte 
4e86			 
4e86					 
4e86			 
4e86					NEXTW 
4e86 c3 0d 23			jp macro_next 
4e89				endm 
# End of macro NEXTW
4e89			 
4e89			.SEI: 
4e89				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4e89 65				db WORD_SYS_CORE+81             
4e8a a3 4e			dw .SFREE            
4e8c 04				db 3 + 1 
4e8d .. 00			db "SEI",0              
4e91				endm 
# End of macro CWHEAD
4e91			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4e91			 
4e91					; get port 
4e91			 
4e91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e91 cd 5e 21			call macro_dsp_valuehl 
4e94				endm 
# End of macro FORTH_DSP_VALUEHL
4e94			 
4e94			;		push hl 
4e94			 
4e94					; destroy value TOS 
4e94			 
4e94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e94 cd 16 22			call macro_forth_dsp_pop 
4e97				endm 
# End of macro FORTH_DSP_POP
4e97			 
4e97					; one value on hl get other one back 
4e97			 
4e97			;		pop hl 
4e97			 
4e97			 
4e97					; TODO Get SPI byte 
4e97			 
4e97 cd c3 02				call se_readbyte 
4e9a			 
4e9a 26 00				ld h, 0 
4e9c 6f					ld l, a 
4e9d cd 67 1f				call forth_push_numhl 
4ea0			 
4ea0					NEXTW 
4ea0 c3 0d 23			jp macro_next 
4ea3				endm 
# End of macro NEXTW
4ea3			 
4ea3			.SFREE: 
4ea3				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4ea3 67				db WORD_SYS_CORE+83             
4ea4 d2 4e			dw .SIZE            
4ea6 06				db 5 + 1 
4ea7 .. 00			db "FFREE",0              
4ead				endm 
# End of macro CWHEAD
4ead			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4ead					if DEBUG_FORTH_WORDS_KEY 
4ead						DMARK "FFR" 
4ead f5				push af  
4eae 3a c2 4e			ld a, (.dmark)  
4eb1 32 6e fe			ld (debug_mark),a  
4eb4 3a c3 4e			ld a, (.dmark+1)  
4eb7 32 6f fe			ld (debug_mark+1),a  
4eba 3a c4 4e			ld a, (.dmark+2)  
4ebd 32 70 fe			ld (debug_mark+2),a  
4ec0 18 03			jr .pastdmark  
4ec2 ..			.dmark: db "FFR"  
4ec5 f1			.pastdmark: pop af  
4ec6			endm  
# End of macro DMARK
4ec6						CALLMONITOR 
4ec6 cd f3 18			call break_point_state  
4ec9				endm  
# End of macro CALLMONITOR
4ec9					endif 
4ec9			 
4ec9 cd e9 07				call storage_freeblocks 
4ecc			 
4ecc cd 67 1f				call forth_push_numhl 
4ecf			 
4ecf				       NEXTW 
4ecf c3 0d 23			jp macro_next 
4ed2				endm 
# End of macro NEXTW
4ed2			.SIZE: 
4ed2				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4ed2 67				db WORD_SYS_CORE+83             
4ed3 06 4f			dw .CREATE            
4ed5 05				db 4 + 1 
4ed6 .. 00			db "SIZE",0              
4edb				endm 
# End of macro CWHEAD
4edb			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4edb					if DEBUG_FORTH_WORDS_KEY 
4edb						DMARK "SIZ" 
4edb f5				push af  
4edc 3a f0 4e			ld a, (.dmark)  
4edf 32 6e fe			ld (debug_mark),a  
4ee2 3a f1 4e			ld a, (.dmark+1)  
4ee5 32 6f fe			ld (debug_mark+1),a  
4ee8 3a f2 4e			ld a, (.dmark+2)  
4eeb 32 70 fe			ld (debug_mark+2),a  
4eee 18 03			jr .pastdmark  
4ef0 ..			.dmark: db "SIZ"  
4ef3 f1			.pastdmark: pop af  
4ef4			endm  
# End of macro DMARK
4ef4						CALLMONITOR 
4ef4 cd f3 18			call break_point_state  
4ef7				endm  
# End of macro CALLMONITOR
4ef7					endif 
4ef7			 
4ef7					FORTH_DSP_VALUEHL 
4ef7 cd 5e 21			call macro_dsp_valuehl 
4efa				endm 
# End of macro FORTH_DSP_VALUEHL
4efa			;		push hl 
4efa					FORTH_DSP_POP 
4efa cd 16 22			call macro_forth_dsp_pop 
4efd				endm 
# End of macro FORTH_DSP_POP
4efd			;		pop hl 
4efd cd 4b 04				call storage_file_size 
4f00			 
4f00 cd 67 1f				call forth_push_numhl 
4f03			  
4f03			 
4f03				       NEXTW 
4f03 c3 0d 23			jp macro_next 
4f06				endm 
# End of macro NEXTW
4f06			 
4f06			.CREATE: 
4f06				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4f06 68				db WORD_SYS_CORE+84             
4f07 74 4f			dw .APPEND            
4f09 07				db 6 + 1 
4f0a .. 00			db "CREATE",0              
4f11				endm 
# End of macro CWHEAD
4f11			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4f11			; | | e.g.  
4f11			; | | TestProgram CREATE 
4f11			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4f11			; | |  
4f11			; | | Max file IDs are 255. 
4f11			; | |  
4f11					 
4f11					if DEBUG_FORTH_WORDS_KEY 
4f11						DMARK "CRT" 
4f11 f5				push af  
4f12 3a 26 4f			ld a, (.dmark)  
4f15 32 6e fe			ld (debug_mark),a  
4f18 3a 27 4f			ld a, (.dmark+1)  
4f1b 32 6f fe			ld (debug_mark+1),a  
4f1e 3a 28 4f			ld a, (.dmark+2)  
4f21 32 70 fe			ld (debug_mark+2),a  
4f24 18 03			jr .pastdmark  
4f26 ..			.dmark: db "CRT"  
4f29 f1			.pastdmark: pop af  
4f2a			endm  
# End of macro DMARK
4f2a						CALLMONITOR 
4f2a cd f3 18			call break_point_state  
4f2d				endm  
# End of macro CALLMONITOR
4f2d					endif 
4f2d			;		call storage_get_block_0 
4f2d			 
4f2d					; TODO pop hl 
4f2d			 
4f2d					;v5 FORTH_DSP_VALUE 
4f2d					FORTH_DSP_VALUE 
4f2d cd 47 21			call macro_forth_dsp_value 
4f30				endm 
# End of macro FORTH_DSP_VALUE
4f30			 
4f30				if DEBUG_STORESE 
4f30					DMARK "CR1" 
4f30 f5				push af  
4f31 3a 45 4f			ld a, (.dmark)  
4f34 32 6e fe			ld (debug_mark),a  
4f37 3a 46 4f			ld a, (.dmark+1)  
4f3a 32 6f fe			ld (debug_mark+1),a  
4f3d 3a 47 4f			ld a, (.dmark+2)  
4f40 32 70 fe			ld (debug_mark+2),a  
4f43 18 03			jr .pastdmark  
4f45 ..			.dmark: db "CR1"  
4f48 f1			.pastdmark: pop af  
4f49			endm  
# End of macro DMARK
4f49					CALLMONITOR 
4f49 cd f3 18			call break_point_state  
4f4c				endm  
# End of macro CALLMONITOR
4f4c				endif 
4f4c			;		push hl 
4f4c			;		FORTH_DSP_POP 
4f4c			;		pop hl 
4f4c			 
4f4c			;		inc hl   ; move past the type marker 
4f4c			 
4f4c cd 1f 08				call storage_create 
4f4f			 
4f4f				if DEBUG_STORESE 
4f4f					DMARK "CT1" 
4f4f f5				push af  
4f50 3a 64 4f			ld a, (.dmark)  
4f53 32 6e fe			ld (debug_mark),a  
4f56 3a 65 4f			ld a, (.dmark+1)  
4f59 32 6f fe			ld (debug_mark+1),a  
4f5c 3a 66 4f			ld a, (.dmark+2)  
4f5f 32 70 fe			ld (debug_mark+2),a  
4f62 18 03			jr .pastdmark  
4f64 ..			.dmark: db "CT1"  
4f67 f1			.pastdmark: pop af  
4f68			endm  
# End of macro DMARK
4f68					CALLMONITOR 
4f68 cd f3 18			call break_point_state  
4f6b				endm  
# End of macro CALLMONITOR
4f6b				endif 
4f6b			;		push hl 
4f6b					FORTH_DSP_POP 
4f6b cd 16 22			call macro_forth_dsp_pop 
4f6e				endm 
# End of macro FORTH_DSP_POP
4f6e			;		pop hl 
4f6e					; push file id to stack 
4f6e cd 67 1f				call forth_push_numhl 
4f71			 
4f71			 
4f71			 
4f71				       NEXTW 
4f71 c3 0d 23			jp macro_next 
4f74				endm 
# End of macro NEXTW
4f74			 
4f74			.APPEND: 
4f74				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4f74 69				db WORD_SYS_CORE+85             
4f75 05 50			dw .SDEL            
4f77 07				db 6 + 1 
4f78 .. 00			db "APPEND",0              
4f7f				endm 
# End of macro CWHEAD
4f7f			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4f7f			; | | e.g. 
4f7f			; | | Test CREATE      -> $01 
4f7f			; | | "A string to add to file" $01 APPEND 
4f7f			; | |  
4f7f			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4f7f					if DEBUG_FORTH_WORDS_KEY 
4f7f						DMARK "APP" 
4f7f f5				push af  
4f80 3a 94 4f			ld a, (.dmark)  
4f83 32 6e fe			ld (debug_mark),a  
4f86 3a 95 4f			ld a, (.dmark+1)  
4f89 32 6f fe			ld (debug_mark+1),a  
4f8c 3a 96 4f			ld a, (.dmark+2)  
4f8f 32 70 fe			ld (debug_mark+2),a  
4f92 18 03			jr .pastdmark  
4f94 ..			.dmark: db "APP"  
4f97 f1			.pastdmark: pop af  
4f98			endm  
# End of macro DMARK
4f98						CALLMONITOR 
4f98 cd f3 18			call break_point_state  
4f9b				endm  
# End of macro CALLMONITOR
4f9b					endif 
4f9b			 
4f9b					FORTH_DSP_VALUEHL 
4f9b cd 5e 21			call macro_dsp_valuehl 
4f9e				endm 
# End of macro FORTH_DSP_VALUEHL
4f9e e5					push hl 	; save file id 
4f9f			 
4f9f				if DEBUG_STORESE 
4f9f					DMARK "AP1" 
4f9f f5				push af  
4fa0 3a b4 4f			ld a, (.dmark)  
4fa3 32 6e fe			ld (debug_mark),a  
4fa6 3a b5 4f			ld a, (.dmark+1)  
4fa9 32 6f fe			ld (debug_mark+1),a  
4fac 3a b6 4f			ld a, (.dmark+2)  
4faf 32 70 fe			ld (debug_mark+2),a  
4fb2 18 03			jr .pastdmark  
4fb4 ..			.dmark: db "AP1"  
4fb7 f1			.pastdmark: pop af  
4fb8			endm  
# End of macro DMARK
4fb8					CALLMONITOR 
4fb8 cd f3 18			call break_point_state  
4fbb				endm  
# End of macro CALLMONITOR
4fbb				endif 
4fbb					FORTH_DSP_POP 
4fbb cd 16 22			call macro_forth_dsp_pop 
4fbe				endm 
# End of macro FORTH_DSP_POP
4fbe			 
4fbe					FORTH_DSP_VALUEHL 
4fbe cd 5e 21			call macro_dsp_valuehl 
4fc1				endm 
# End of macro FORTH_DSP_VALUEHL
4fc1					;v5 FORTH_DSP_VALUE 
4fc1 e5					push hl 	; save ptr to string to save 
4fc2			 
4fc2				if DEBUG_STORESE 
4fc2					DMARK "AP1" 
4fc2 f5				push af  
4fc3 3a d7 4f			ld a, (.dmark)  
4fc6 32 6e fe			ld (debug_mark),a  
4fc9 3a d8 4f			ld a, (.dmark+1)  
4fcc 32 6f fe			ld (debug_mark+1),a  
4fcf 3a d9 4f			ld a, (.dmark+2)  
4fd2 32 70 fe			ld (debug_mark+2),a  
4fd5 18 03			jr .pastdmark  
4fd7 ..			.dmark: db "AP1"  
4fda f1			.pastdmark: pop af  
4fdb			endm  
# End of macro DMARK
4fdb					CALLMONITOR 
4fdb cd f3 18			call break_point_state  
4fde				endm  
# End of macro CALLMONITOR
4fde				endif 
4fde					FORTH_DSP_POP 
4fde cd 16 22			call macro_forth_dsp_pop 
4fe1				endm 
# End of macro FORTH_DSP_POP
4fe1			 
4fe1 d1					pop de 
4fe2 e1					pop hl 
4fe3				if DEBUG_STORESE 
4fe3					DMARK "AP2" 
4fe3 f5				push af  
4fe4 3a f8 4f			ld a, (.dmark)  
4fe7 32 6e fe			ld (debug_mark),a  
4fea 3a f9 4f			ld a, (.dmark+1)  
4fed 32 6f fe			ld (debug_mark+1),a  
4ff0 3a fa 4f			ld a, (.dmark+2)  
4ff3 32 70 fe			ld (debug_mark+2),a  
4ff6 18 03			jr .pastdmark  
4ff8 ..			.dmark: db "AP2"  
4ffb f1			.pastdmark: pop af  
4ffc			endm  
# End of macro DMARK
4ffc					CALLMONITOR 
4ffc cd f3 18			call break_point_state  
4fff				endm  
# End of macro CALLMONITOR
4fff				endif 
4fff					;inc de ; skip var type indicator 
4fff			 
4fff					; TODO how to append numerics???? 
4fff			 
4fff cd 0c 0b				call storage_append		 
5002			 
5002				       NEXTW 
5002 c3 0d 23			jp macro_next 
5005				endm 
# End of macro NEXTW
5005			.SDEL: 
5005				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5005 6a				db WORD_SYS_CORE+86             
5006 51 50			dw .OPEN            
5008 05				db 4 + 1 
5009 .. 00			db "ERA",0              
500d				endm 
# End of macro CWHEAD
500d			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
500d					FORTH_DSP_VALUEHL 
500d cd 5e 21			call macro_dsp_valuehl 
5010				endm 
# End of macro FORTH_DSP_VALUEHL
5010			;		push hl 	; save file id 
5010			 
5010					if DEBUG_FORTH_WORDS_KEY 
5010						DMARK "ERA" 
5010 f5				push af  
5011 3a 25 50			ld a, (.dmark)  
5014 32 6e fe			ld (debug_mark),a  
5017 3a 26 50			ld a, (.dmark+1)  
501a 32 6f fe			ld (debug_mark+1),a  
501d 3a 27 50			ld a, (.dmark+2)  
5020 32 70 fe			ld (debug_mark+2),a  
5023 18 03			jr .pastdmark  
5025 ..			.dmark: db "ERA"  
5028 f1			.pastdmark: pop af  
5029			endm  
# End of macro DMARK
5029						CALLMONITOR 
5029 cd f3 18			call break_point_state  
502c				endm  
# End of macro CALLMONITOR
502c					endif 
502c				if DEBUG_STORESE 
502c					DMARK "ER1" 
502c f5				push af  
502d 3a 41 50			ld a, (.dmark)  
5030 32 6e fe			ld (debug_mark),a  
5033 3a 42 50			ld a, (.dmark+1)  
5036 32 6f fe			ld (debug_mark+1),a  
5039 3a 43 50			ld a, (.dmark+2)  
503c 32 70 fe			ld (debug_mark+2),a  
503f 18 03			jr .pastdmark  
5041 ..			.dmark: db "ER1"  
5044 f1			.pastdmark: pop af  
5045			endm  
# End of macro DMARK
5045					CALLMONITOR 
5045 cd f3 18			call break_point_state  
5048				endm  
# End of macro CALLMONITOR
5048				endif 
5048					FORTH_DSP_POP 
5048 cd 16 22			call macro_forth_dsp_pop 
504b				endm 
# End of macro FORTH_DSP_POP
504b			 
504b			;		pop hl 
504b			 
504b cd 5e 06				call storage_erase 
504e				       NEXTW 
504e c3 0d 23			jp macro_next 
5051				endm 
# End of macro NEXTW
5051			 
5051			.OPEN: 
5051				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5051 6b				db WORD_SYS_CORE+87             
5052 e5 50			dw .READ            
5054 05				db 4 + 1 
5055 .. 00			db "OPEN",0              
505a				endm 
# End of macro CWHEAD
505a			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
505a			; | | e.g. 
505a			; | | $01 OPEN $01 DO $01 READ . LOOP 
505a			; | | 
505a			; | | Will return with 255 blocks if the file does not exist 
505a			 
505a					if DEBUG_FORTH_WORDS_KEY 
505a						DMARK "OPN" 
505a f5				push af  
505b 3a 6f 50			ld a, (.dmark)  
505e 32 6e fe			ld (debug_mark),a  
5061 3a 70 50			ld a, (.dmark+1)  
5064 32 6f fe			ld (debug_mark+1),a  
5067 3a 71 50			ld a, (.dmark+2)  
506a 32 70 fe			ld (debug_mark+2),a  
506d 18 03			jr .pastdmark  
506f ..			.dmark: db "OPN"  
5072 f1			.pastdmark: pop af  
5073			endm  
# End of macro DMARK
5073						CALLMONITOR 
5073 cd f3 18			call break_point_state  
5076				endm  
# End of macro CALLMONITOR
5076					endif 
5076					; TODO handle multiple file opens 
5076			 
5076 3e 01			       	ld a, 1 
5078 32 71 fa				ld (store_openext), a 
507b			 
507b					; get max extents for this file 
507b				 
507b								 
507b					FORTH_DSP_VALUEHL 
507b cd 5e 21			call macro_dsp_valuehl 
507e				endm 
# End of macro FORTH_DSP_VALUEHL
507e			 
507e 65					ld h, l 
507f 2e 00				ld l, 0 
5081			 
5081					; store file id 
5081			 
5081 7c					ld a, h 
5082 32 6e fa				ld (store_filecache), a 
5085			 
5085				if DEBUG_STORESE 
5085					DMARK "OPN" 
5085 f5				push af  
5086 3a 9a 50			ld a, (.dmark)  
5089 32 6e fe			ld (debug_mark),a  
508c 3a 9b 50			ld a, (.dmark+1)  
508f 32 6f fe			ld (debug_mark+1),a  
5092 3a 9c 50			ld a, (.dmark+2)  
5095 32 70 fe			ld (debug_mark+2),a  
5098 18 03			jr .pastdmark  
509a ..			.dmark: db "OPN"  
509d f1			.pastdmark: pop af  
509e			endm  
# End of macro DMARK
509e					CALLMONITOR 
509e cd f3 18			call break_point_state  
50a1				endm  
# End of macro CALLMONITOR
50a1				endif 
50a1			;		push hl 
50a1					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
50a1 cd 16 22			call macro_forth_dsp_pop 
50a4				endm 
# End of macro FORTH_DSP_POP
50a4			;		pop hl 
50a4						 
50a4 11 81 fa				ld de, store_page      ; get block zero of file 
50a7 cd 75 09				call storage_read 
50aa cd 75 0f			call ishlzero 
50ad 20 04			jr nz, .opfound 
50af			 
50af				; file does not exist so indicate with 255 extents in use 
50af			 
50af 3e ff			ld a, 255 
50b1 18 29			jr .skipopeneof 
50b3			 
50b3			 
50b3			.opfound: 
50b3			 
50b3			 
50b3 3a 83 fa				ld a, (store_page+2)    ; max extents for this file 
50b6 32 70 fa				ld  (store_openmaxext), a   ; get our limit and push 
50b9					 
50b9				if DEBUG_STORESE 
50b9					DMARK "OPx" 
50b9 f5				push af  
50ba 3a ce 50			ld a, (.dmark)  
50bd 32 6e fe			ld (debug_mark),a  
50c0 3a cf 50			ld a, (.dmark+1)  
50c3 32 6f fe			ld (debug_mark+1),a  
50c6 3a d0 50			ld a, (.dmark+2)  
50c9 32 70 fe			ld (debug_mark+2),a  
50cc 18 03			jr .pastdmark  
50ce ..			.dmark: db "OPx"  
50d1 f1			.pastdmark: pop af  
50d2			endm  
# End of macro DMARK
50d2					CALLMONITOR 
50d2 cd f3 18			call break_point_state  
50d5				endm  
# End of macro CALLMONITOR
50d5				endif 
50d5 fe 00				cp 0 
50d7 20 03				jr nz, .skipopeneof 
50d9					; have opened an empty file 
50d9					 
50d9 32 71 fa				ld (store_openext), a 
50dc			 
50dc			.skipopeneof: 
50dc			 
50dc 6f					ld l, a 
50dd 26 00				ld h, 0 
50df cd 67 1f				call forth_push_numhl 
50e2			 
50e2			 
50e2				       NEXTW 
50e2 c3 0d 23			jp macro_next 
50e5				endm 
# End of macro NEXTW
50e5			.READ: 
50e5				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
50e5 6c				db WORD_SYS_CORE+88             
50e6 0f 52			dw .EOF            
50e8 05				db 4 + 1 
50e9 .. 00			db "READ",0              
50ee				endm 
# End of macro CWHEAD
50ee			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
50ee			; | | e.g. 
50ee			; | | $01 OPEN $01 DO READ . LOOP 
50ee			; | | 
50ee			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
50ee			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
50ee			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
50ee			; | | two bytes contain the file id and extent. 
50ee			; | |  
50ee			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
50ee			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
50ee			 
50ee					if DEBUG_FORTH_WORDS_KEY 
50ee						DMARK "REA" 
50ee f5				push af  
50ef 3a 03 51			ld a, (.dmark)  
50f2 32 6e fe			ld (debug_mark),a  
50f5 3a 04 51			ld a, (.dmark+1)  
50f8 32 6f fe			ld (debug_mark+1),a  
50fb 3a 05 51			ld a, (.dmark+2)  
50fe 32 70 fe			ld (debug_mark+2),a  
5101 18 03			jr .pastdmark  
5103 ..			.dmark: db "REA"  
5106 f1			.pastdmark: pop af  
5107			endm  
# End of macro DMARK
5107						CALLMONITOR 
5107 cd f3 18			call break_point_state  
510a				endm  
# End of macro CALLMONITOR
510a					endif 
510a					; store_openext use it. If zero it is EOF 
510a			 
510a					; read block from current stream id 
510a					; if the block does not contain zero term keep reading blocks until zero found 
510a					; push the block to stack 
510a					; save the block id to stream 
510a			 
510a			 
510a cd 3c 52				call .testeof 
510d 3e 01				ld a, 1 
510f bd					cp l 
5110 ca eb 51				jp z, .ateof 
5113			 
5113			 
5113			;		FORTH_DSP_VALUEHL 
5113			 
5113			;		push hl 
5113			 
5113			;	if DEBUG_STORESE 
5113			;		DMARK "REA" 
5113			;		CALLMONITOR 
5113			;	endif 
5113			;		FORTH_DSP_POP 
5113			 
5113			;		pop hl 
5113				 
5113 3a 6e fa				ld a, (store_filecache) 
5116 67					ld h,a 
5117			 
5117 3a 71 fa				ld a, (store_openext) 
511a 6f					ld l, a 
511b					 
511b fe 00				cp 0 
511d ca eb 51				jp z, .ateof     ; dont read past eof 
5120			 
5120 cd 58 0c				call storage_clear_page 
5123			 
5123 11 81 fa				ld de, store_page 
5126				if DEBUG_STORESE 
5126					DMARK "RE1" 
5126 f5				push af  
5127 3a 3b 51			ld a, (.dmark)  
512a 32 6e fe			ld (debug_mark),a  
512d 3a 3c 51			ld a, (.dmark+1)  
5130 32 6f fe			ld (debug_mark+1),a  
5133 3a 3d 51			ld a, (.dmark+2)  
5136 32 70 fe			ld (debug_mark+2),a  
5139 18 03			jr .pastdmark  
513b ..			.dmark: db "RE1"  
513e f1			.pastdmark: pop af  
513f			endm  
# End of macro DMARK
513f					CALLMONITOR 
513f cd f3 18			call break_point_state  
5142				endm  
# End of macro CALLMONITOR
5142				endif 
5142 cd 75 09				call storage_read 
5145			 
5145				if DEBUG_STORESE 
5145					DMARK "RE2" 
5145 f5				push af  
5146 3a 5a 51			ld a, (.dmark)  
5149 32 6e fe			ld (debug_mark),a  
514c 3a 5b 51			ld a, (.dmark+1)  
514f 32 6f fe			ld (debug_mark+1),a  
5152 3a 5c 51			ld a, (.dmark+2)  
5155 32 70 fe			ld (debug_mark+2),a  
5158 18 03			jr .pastdmark  
515a ..			.dmark: db "RE2"  
515d f1			.pastdmark: pop af  
515e			endm  
# End of macro DMARK
515e					CALLMONITOR 
515e cd f3 18			call break_point_state  
5161				endm  
# End of macro CALLMONITOR
5161				endif 
5161 cd 75 0f			call ishlzero 
5164			;	ld a, l 
5164			;	add h 
5164			;	cp 0 
5164 ca eb 51			jp z, .readeof 
5167			 
5167				; not eof so hl should point to data to push to stack 
5167			 
5167				if DEBUG_STORESE 
5167					DMARK "RE3" 
5167 f5				push af  
5168 3a 7c 51			ld a, (.dmark)  
516b 32 6e fe			ld (debug_mark),a  
516e 3a 7d 51			ld a, (.dmark+1)  
5171 32 6f fe			ld (debug_mark+1),a  
5174 3a 7e 51			ld a, (.dmark+2)  
5177 32 70 fe			ld (debug_mark+2),a  
517a 18 03			jr .pastdmark  
517c ..			.dmark: db "RE3"  
517f f1			.pastdmark: pop af  
5180			endm  
# End of macro DMARK
5180					CALLMONITOR 
5180 cd f3 18			call break_point_state  
5183				endm  
# End of macro CALLMONITOR
5183				endif 
5183 cd d5 1f			call forth_push_str 
5186			 
5186				if DEBUG_STORESE 
5186					DMARK "RE4" 
5186 f5				push af  
5187 3a 9b 51			ld a, (.dmark)  
518a 32 6e fe			ld (debug_mark),a  
518d 3a 9c 51			ld a, (.dmark+1)  
5190 32 6f fe			ld (debug_mark+1),a  
5193 3a 9d 51			ld a, (.dmark+2)  
5196 32 70 fe			ld (debug_mark+2),a  
5199 18 03			jr .pastdmark  
519b ..			.dmark: db "RE4"  
519e f1			.pastdmark: pop af  
519f			endm  
# End of macro DMARK
519f					CALLMONITOR 
519f cd f3 18			call break_point_state  
51a2				endm  
# End of macro CALLMONITOR
51a2				endif 
51a2				; get next block  or mark as eof 
51a2			 
51a2 3a 70 fa			ld a, (store_openmaxext)   ; get our limit 
51a5 4f				ld c, a	 
51a6 3a 71 fa			ld a, (store_openext) 
51a9			 
51a9				if DEBUG_STORESE 
51a9					DMARK "RE5" 
51a9 f5				push af  
51aa 3a be 51			ld a, (.dmark)  
51ad 32 6e fe			ld (debug_mark),a  
51b0 3a bf 51			ld a, (.dmark+1)  
51b3 32 6f fe			ld (debug_mark+1),a  
51b6 3a c0 51			ld a, (.dmark+2)  
51b9 32 70 fe			ld (debug_mark+2),a  
51bc 18 03			jr .pastdmark  
51be ..			.dmark: db "RE5"  
51c1 f1			.pastdmark: pop af  
51c2			endm  
# End of macro DMARK
51c2					CALLMONITOR 
51c2 cd f3 18			call break_point_state  
51c5				endm  
# End of macro CALLMONITOR
51c5				endif 
51c5 b9				cp c 
51c6 28 23			jr z, .readeof     ; at last extent 
51c8			 
51c8 3c					inc a 
51c9 32 71 fa				ld (store_openext), a 
51cc			 
51cc				if DEBUG_STORESE 
51cc					DMARK "RE6" 
51cc f5				push af  
51cd 3a e1 51			ld a, (.dmark)  
51d0 32 6e fe			ld (debug_mark),a  
51d3 3a e2 51			ld a, (.dmark+1)  
51d6 32 6f fe			ld (debug_mark+1),a  
51d9 3a e3 51			ld a, (.dmark+2)  
51dc 32 70 fe			ld (debug_mark+2),a  
51df 18 03			jr .pastdmark  
51e1 ..			.dmark: db "RE6"  
51e4 f1			.pastdmark: pop af  
51e5			endm  
# End of macro DMARK
51e5					CALLMONITOR 
51e5 cd f3 18			call break_point_state  
51e8				endm  
# End of macro CALLMONITOR
51e8				endif 
51e8			 
51e8			 
51e8				       NEXTW 
51e8 c3 0d 23			jp macro_next 
51eb				endm 
# End of macro NEXTW
51eb			.ateof: 
51eb				;	ld hl, .showeof 
51eb				;	call forth_push_str 
51eb 3e 00		.readeof:	ld a, 0 
51ed 32 71 fa				ld (store_openext), a 
51f0			 
51f0					 
51f0				if DEBUG_STORESE 
51f0					DMARK "REF" 
51f0 f5				push af  
51f1 3a 05 52			ld a, (.dmark)  
51f4 32 6e fe			ld (debug_mark),a  
51f7 3a 06 52			ld a, (.dmark+1)  
51fa 32 6f fe			ld (debug_mark+1),a  
51fd 3a 07 52			ld a, (.dmark+2)  
5200 32 70 fe			ld (debug_mark+2),a  
5203 18 03			jr .pastdmark  
5205 ..			.dmark: db "REF"  
5208 f1			.pastdmark: pop af  
5209			endm  
# End of macro DMARK
5209					CALLMONITOR 
5209 cd f3 18			call break_point_state  
520c				endm  
# End of macro CALLMONITOR
520c				endif 
520c				       NEXTW 
520c c3 0d 23			jp macro_next 
520f				endm 
# End of macro NEXTW
520f			 
520f			;.showeof:   db "eof", 0 
520f			 
520f			 
520f			.EOF: 
520f				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
520f 6d				db WORD_SYS_CORE+89             
5210 51 52			dw .FORMAT            
5212 04				db 3 + 1 
5213 .. 00			db "EOF",0              
5217				endm 
# End of macro CWHEAD
5217			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5217			; | | e.g. 
5217			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5217					; TODO if current block id for stream is zero then push true else false 
5217			 
5217					if DEBUG_FORTH_WORDS_KEY 
5217						DMARK "EOF" 
5217 f5				push af  
5218 3a 2c 52			ld a, (.dmark)  
521b 32 6e fe			ld (debug_mark),a  
521e 3a 2d 52			ld a, (.dmark+1)  
5221 32 6f fe			ld (debug_mark+1),a  
5224 3a 2e 52			ld a, (.dmark+2)  
5227 32 70 fe			ld (debug_mark+2),a  
522a 18 03			jr .pastdmark  
522c ..			.dmark: db "EOF"  
522f f1			.pastdmark: pop af  
5230			endm  
# End of macro DMARK
5230						CALLMONITOR 
5230 cd f3 18			call break_point_state  
5233				endm  
# End of macro CALLMONITOR
5233					endif 
5233			 
5233					; TODO handlue multiple file streams 
5233			 
5233			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5233 cd 3c 52				call .testeof 
5236 cd 67 1f				call forth_push_numhl 
5239			 
5239			 
5239				       NEXTW 
5239 c3 0d 23			jp macro_next 
523c				endm 
# End of macro NEXTW
523c			 
523c			.testeof: 
523c 2e 01				ld l, 1 
523e 3a 70 fa				ld a, (store_openmaxext) 
5241 fe 00				cp 0 
5243 28 09				jr  z, .eofdone   ; empty file 
5245 3a 71 fa				ld a, (store_openext) 
5248 fe 00				cp 0 
524a 28 02				jr  z, .eofdone 
524c 2e 00				ld l, 0 
524e 26 00		.eofdone:	ld h, 0 
5250 c9					ret 
5251			 
5251			 
5251			 
5251			 
5251			.FORMAT: 
5251				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5251 6d				db WORD_SYS_CORE+89             
5252 a2 52			dw .LABEL            
5254 07				db 6 + 1 
5255 .. 00			db "FORMAT",0              
525c				endm 
# End of macro CWHEAD
525c			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
525c					; TODO if current block id for stream is zero then push true else false 
525c				 
525c				if DEBUG_STORESE 
525c					DMARK "FOR" 
525c f5				push af  
525d 3a 71 52			ld a, (.dmark)  
5260 32 6e fe			ld (debug_mark),a  
5263 3a 72 52			ld a, (.dmark+1)  
5266 32 6f fe			ld (debug_mark+1),a  
5269 3a 73 52			ld a, (.dmark+2)  
526c 32 70 fe			ld (debug_mark+2),a  
526f 18 03			jr .pastdmark  
5271 ..			.dmark: db "FOR"  
5274 f1			.pastdmark: pop af  
5275			endm  
# End of macro DMARK
5275					CALLMONITOR 
5275 cd f3 18			call break_point_state  
5278				endm  
# End of macro CALLMONITOR
5278				endif 
5278					; Wipes the bank check flags to cause a reformat on next block 0 read 
5278			 
5278 21 01 00				ld hl, 1 
527b 3e 00				ld a, 0 
527d cd 21 02				call se_writebyte 
5280			 
5280				if DEBUG_STORESE 
5280					DMARK "FO0" 
5280 f5				push af  
5281 3a 95 52			ld a, (.dmark)  
5284 32 6e fe			ld (debug_mark),a  
5287 3a 96 52			ld a, (.dmark+1)  
528a 32 6f fe			ld (debug_mark+1),a  
528d 3a 97 52			ld a, (.dmark+2)  
5290 32 70 fe			ld (debug_mark+2),a  
5293 18 03			jr .pastdmark  
5295 ..			.dmark: db "FO0"  
5298 f1			.pastdmark: pop af  
5299			endm  
# End of macro DMARK
5299					CALLMONITOR 
5299 cd f3 18			call break_point_state  
529c				endm  
# End of macro CALLMONITOR
529c				endif 
529c					; force bank init 
529c			 
529c cd cd 04				call storage_get_block_0 
529f					 
529f				       NEXTW 
529f c3 0d 23			jp macro_next 
52a2				endm 
# End of macro NEXTW
52a2			.LABEL: 
52a2				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
52a2 6d				db WORD_SYS_CORE+89             
52a3 f0 52			dw .STOREPAGE            
52a5 06				db 5 + 1 
52a6 .. 00			db "LABEL",0              
52ac				endm 
# End of macro CWHEAD
52ac			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
52ac					; TODO test to see if bank is selected 
52ac				 
52ac					if DEBUG_FORTH_WORDS_KEY 
52ac						DMARK "LBL" 
52ac f5				push af  
52ad 3a c1 52			ld a, (.dmark)  
52b0 32 6e fe			ld (debug_mark),a  
52b3 3a c2 52			ld a, (.dmark+1)  
52b6 32 6f fe			ld (debug_mark+1),a  
52b9 3a c3 52			ld a, (.dmark+2)  
52bc 32 70 fe			ld (debug_mark+2),a  
52bf 18 03			jr .pastdmark  
52c1 ..			.dmark: db "LBL"  
52c4 f1			.pastdmark: pop af  
52c5			endm  
# End of macro DMARK
52c5						CALLMONITOR 
52c5 cd f3 18			call break_point_state  
52c8				endm  
# End of macro CALLMONITOR
52c8					endif 
52c8			;	if DEBUG_STORESE 
52c8			;		DMARK "LBL" 
52c8			;		CALLMONITOR 
52c8			;	endif 
52c8					FORTH_DSP_VALUEHL 
52c8 cd 5e 21			call macro_dsp_valuehl 
52cb				endm 
# End of macro FORTH_DSP_VALUEHL
52cb					;v5FORTH_DSP_VALUE 
52cb					 
52cb			;		push hl 
52cb					FORTH_DSP_POP 
52cb cd 16 22			call macro_forth_dsp_pop 
52ce				endm 
# End of macro FORTH_DSP_POP
52ce			;		pop hl 
52ce			 
52ce			;v5		inc hl   ; move past the type marker 
52ce			 
52ce				if DEBUG_STORESE 
52ce					DMARK "LBl" 
52ce f5				push af  
52cf 3a e3 52			ld a, (.dmark)  
52d2 32 6e fe			ld (debug_mark),a  
52d5 3a e4 52			ld a, (.dmark+1)  
52d8 32 6f fe			ld (debug_mark+1),a  
52db 3a e5 52			ld a, (.dmark+2)  
52de 32 70 fe			ld (debug_mark+2),a  
52e1 18 03			jr .pastdmark  
52e3 ..			.dmark: db "LBl"  
52e6 f1			.pastdmark: pop af  
52e7			endm  
# End of macro DMARK
52e7					CALLMONITOR 
52e7 cd f3 18			call break_point_state  
52ea				endm  
# End of macro CALLMONITOR
52ea				endif 
52ea cd f1 05				call storage_label 
52ed			 
52ed				       NEXTW 
52ed c3 0d 23			jp macro_next 
52f0				endm 
# End of macro NEXTW
52f0			.STOREPAGE: 
52f0				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
52f0 6d				db WORD_SYS_CORE+89             
52f1 23 53			dw .LABELS            
52f3 0a				db 9 + 1 
52f4 .. 00			db "STOREPAGE",0              
52fe				endm 
# End of macro CWHEAD
52fe			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
52fe					; TODO test to see if bank is selected 
52fe				 
52fe					if DEBUG_FORTH_WORDS_KEY 
52fe						DMARK "STP" 
52fe f5				push af  
52ff 3a 13 53			ld a, (.dmark)  
5302 32 6e fe			ld (debug_mark),a  
5305 3a 14 53			ld a, (.dmark+1)  
5308 32 6f fe			ld (debug_mark+1),a  
530b 3a 15 53			ld a, (.dmark+2)  
530e 32 70 fe			ld (debug_mark+2),a  
5311 18 03			jr .pastdmark  
5313 ..			.dmark: db "STP"  
5316 f1			.pastdmark: pop af  
5317			endm  
# End of macro DMARK
5317						CALLMONITOR 
5317 cd f3 18			call break_point_state  
531a				endm  
# End of macro CALLMONITOR
531a					endif 
531a			;	if DEBUG_STORESE 
531a			;		DMARK "STP" 
531a			;		CALLMONITOR 
531a			;	endif 
531a			 
531a 21 81 fa			ld hl, store_page 
531d cd 67 1f			call forth_push_numhl 
5320			 
5320			 
5320				       NEXTW 
5320 c3 0d 23			jp macro_next 
5323				endm 
# End of macro NEXTW
5323			.LABELS: 
5323				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5323 6d				db WORD_SYS_CORE+89             
5324 ad 53			dw .SCONST1            
5326 07				db 6 + 1 
5327 .. 00			db "LABELS",0              
532e				endm 
# End of macro CWHEAD
532e			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
532e					;  
532e			 
532e					; save the current device selected to restore afterwards 
532e				 
532e 3a 67 fa				ld a, (spi_device) 
5331 f5					push af 
5332			 
5332			 
5332					; run through each of the banks 
5332			 
5332 21 01 00				ld hl, 1 
5335 cd 67 1f				call forth_push_numhl 
5338 3e ff				ld a, SPI_CE_HIGH 
533a cb 87				res SPI_CE0, a 
533c 32 67 fa				ld (spi_device), a 
533f cd cd 04				call storage_get_block_0 
5342 21 84 fa				ld hl, store_page+3 
5345 cd d5 1f				call forth_push_str 
5348			 
5348					 
5348 21 02 00				ld hl, 2 
534b cd 67 1f				call forth_push_numhl 
534e 3e ff				ld a, SPI_CE_HIGH 
5350 cb 8f				res SPI_CE1, a 
5352 32 67 fa				ld (spi_device), a 
5355 cd cd 04				call storage_get_block_0 
5358 21 84 fa				ld hl, store_page+3 
535b cd d5 1f				call forth_push_str 
535e			 
535e					 
535e 21 03 00				ld hl, 3 
5361 cd 67 1f				call forth_push_numhl 
5364 3e ff				ld a, SPI_CE_HIGH 
5366 cb 97				res SPI_CE2, a 
5368 32 67 fa				ld (spi_device), a 
536b cd cd 04				call storage_get_block_0 
536e 21 84 fa				ld hl, store_page+3 
5371 cd d5 1f				call forth_push_str 
5374			 
5374			 
5374 21 04 00				ld hl, 4 
5377 cd 67 1f				call forth_push_numhl 
537a 3e ff				ld a, SPI_CE_HIGH 
537c cb 9f				res SPI_CE3, a 
537e 32 67 fa				ld (spi_device), a 
5381 cd cd 04				call storage_get_block_0 
5384 21 84 fa				ld hl, store_page+3 
5387 cd d5 1f				call forth_push_str 
538a			 
538a					 
538a			 
538a 21 05 00				ld hl, 5 
538d cd 67 1f				call forth_push_numhl 
5390 3e ff				ld a, SPI_CE_HIGH 
5392 cb a7				res SPI_CE4, a 
5394 32 67 fa				ld (spi_device), a 
5397 cd cd 04				call storage_get_block_0 
539a 21 84 fa				ld hl, store_page+3 
539d cd d5 1f				call forth_push_str 
53a0			 
53a0					 
53a0					; push fixed count of storage devices (on board) for now 
53a0			 
53a0 21 05 00				ld hl, 5 
53a3 cd 67 1f				call forth_push_numhl 
53a6			 
53a6					; restore selected device  
53a6				 
53a6 f1					pop af 
53a7 32 67 fa				ld (spi_device), a 
53aa			 
53aa				       NEXTW 
53aa c3 0d 23			jp macro_next 
53ad				endm 
# End of macro NEXTW
53ad			 
53ad			.SCONST1: 
53ad				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
53ad 6d				db WORD_SYS_CORE+89             
53ae c4 53			dw .SCONST2            
53b0 07				db 6 + 1 
53b1 .. 00			db "FILEID",0              
53b8				endm 
# End of macro CWHEAD
53b8			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
53b8 3a 6e fa				ld a, (store_filecache) 
53bb 26 00				ld h, 0 
53bd 6f					ld l, a 
53be cd 67 1f				call forth_push_numhl 
53c1					NEXTW 
53c1 c3 0d 23			jp macro_next 
53c4				endm 
# End of macro NEXTW
53c4			.SCONST2: 
53c4				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
53c4 6d				db WORD_SYS_CORE+89             
53c5 dc 53			dw .SCONST3            
53c7 08				db 7 + 1 
53c8 .. 00			db "FILEEXT",0              
53d0				endm 
# End of macro CWHEAD
53d0			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
53d0 3a 71 fa				ld a, (store_openext) 
53d3 26 00				ld h, 0 
53d5 6f					ld l, a 
53d6 cd 67 1f				call forth_push_numhl 
53d9					NEXTW 
53d9 c3 0d 23			jp macro_next 
53dc				endm 
# End of macro NEXTW
53dc			.SCONST3: 
53dc				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
53dc 6d				db WORD_SYS_CORE+89             
53dd f4 53			dw .SCONST4            
53df 08				db 7 + 1 
53e0 .. 00			db "FILEMAX",0              
53e8				endm 
# End of macro CWHEAD
53e8			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
53e8 3a 70 fa				ld a, (store_openmaxext) 
53eb 26 00				ld h, 0 
53ed 6f					ld l, a 
53ee cd 67 1f				call forth_push_numhl 
53f1					NEXTW 
53f1 c3 0d 23			jp macro_next 
53f4				endm 
# End of macro NEXTW
53f4			.SCONST4: 
53f4				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
53f4 6d				db WORD_SYS_CORE+89             
53f5 0a 54			dw .SCONST5            
53f7 09				db 8 + 1 
53f8 .. 00			db "FILEADDR",0              
5401				endm 
# End of macro CWHEAD
5401			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
5401 2a 72 fa				ld hl, (store_openaddr) 
5404 cd 67 1f				call forth_push_numhl 
5407					NEXTW 
5407 c3 0d 23			jp macro_next 
540a				endm 
# End of macro NEXTW
540a			.SCONST5: 
540a				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
540a 6d				db WORD_SYS_CORE+89             
540b 23 54			dw .ENDSTORAGE            
540d 09				db 8 + 1 
540e .. 00			db "READCONT",0              
5417				endm 
# End of macro CWHEAD
5417			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5417			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5417			; | | a further read should, if applicable, be CONCAT to the previous read. 
5417 3a 74 fa				ld a, (store_readcont) 
541a 26 00				ld h, 0 
541c 6f					ld l, a 
541d cd 67 1f				call forth_push_numhl 
5420					NEXTW 
5420 c3 0d 23			jp macro_next 
5423				endm 
# End of macro NEXTW
5423			.ENDSTORAGE: 
5423			; eof 
# End of file forth_words_storage.asm
5423			endif 
5423				include "forth_words_device.asm" 
5423			; Device related words 
5423			 
5423			; | ## Device Words 
5423			 
5423			if SOUND_ENABLE 
5423			.NOTE: 
5423				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5423 33				db WORD_SYS_CORE+31             
5424 4b 54			dw .AFTERSOUND            
5426 05				db 4 + 1 
5427 .. 00			db "NOTE",0              
542c				endm 
# End of macro CWHEAD
542c			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
542c					if DEBUG_FORTH_WORDS_KEY 
542c						DMARK "NTE" 
542c f5				push af  
542d 3a 41 54			ld a, (.dmark)  
5430 32 6e fe			ld (debug_mark),a  
5433 3a 42 54			ld a, (.dmark+1)  
5436 32 6f fe			ld (debug_mark+1),a  
5439 3a 43 54			ld a, (.dmark+2)  
543c 32 70 fe			ld (debug_mark+2),a  
543f 18 03			jr .pastdmark  
5441 ..			.dmark: db "NTE"  
5444 f1			.pastdmark: pop af  
5445			endm  
# End of macro DMARK
5445						CALLMONITOR 
5445 cd f3 18			call break_point_state  
5448				endm  
# End of macro CALLMONITOR
5448					endif 
5448			 
5448				 
5448			 
5448					NEXTW 
5448 c3 0d 23			jp macro_next 
544b				endm 
# End of macro NEXTW
544b			.AFTERSOUND: 
544b			endif 
544b			 
544b			 
544b			USE_GPIO: equ 0 
544b			 
544b			if USE_GPIO 
544b			.GP1: 
544b				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
544b			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
544b					NEXTW 
544b			.GP2: 
544b				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
544b			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
544b			 
544b					NEXTW 
544b			 
544b			.GP3: 
544b				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
544b			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
544b			 
544b					NEXTW 
544b			 
544b			.GP4: 
544b				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
544b			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
544b			 
544b					NEXTW 
544b			.SIN: 
544b			 
544b			 
544b			endif 
544b			 
544b			 
544b				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
544b 33				db WORD_SYS_CORE+31             
544c 80 54			dw .SOUT            
544e 03				db 2 + 1 
544f .. 00			db "IN",0              
5452				endm 
# End of macro CWHEAD
5452			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5452					if DEBUG_FORTH_WORDS_KEY 
5452						DMARK "IN." 
5452 f5				push af  
5453 3a 67 54			ld a, (.dmark)  
5456 32 6e fe			ld (debug_mark),a  
5459 3a 68 54			ld a, (.dmark+1)  
545c 32 6f fe			ld (debug_mark+1),a  
545f 3a 69 54			ld a, (.dmark+2)  
5462 32 70 fe			ld (debug_mark+2),a  
5465 18 03			jr .pastdmark  
5467 ..			.dmark: db "IN."  
546a f1			.pastdmark: pop af  
546b			endm  
# End of macro DMARK
546b						CALLMONITOR 
546b cd f3 18			call break_point_state  
546e				endm  
# End of macro CALLMONITOR
546e					endif 
546e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
546e cd 5e 21			call macro_dsp_valuehl 
5471				endm 
# End of macro FORTH_DSP_VALUEHL
5471			 
5471 e5					push hl 
5472			 
5472					; destroy value TOS 
5472			 
5472					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5472 cd 16 22			call macro_forth_dsp_pop 
5475				endm 
# End of macro FORTH_DSP_POP
5475			 
5475					; one value on hl get other one back 
5475			 
5475 c1					pop bc 
5476			 
5476					; do the sub 
5476			;		ex de, hl 
5476			 
5476 ed 68				in l,(c) 
5478			 
5478					; save it 
5478			 
5478 26 00				ld h,0 
547a			 
547a					; TODO push value back onto stack for another op etc 
547a			 
547a cd 67 1f				call forth_push_numhl 
547d					NEXTW 
547d c3 0d 23			jp macro_next 
5480				endm 
# End of macro NEXTW
5480			.SOUT: 
5480				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5480 34				db WORD_SYS_CORE+32             
5481 d3 54			dw .SPIO            
5483 04				db 3 + 1 
5484 .. 00			db "OUT",0              
5488				endm 
# End of macro CWHEAD
5488			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5488					if DEBUG_FORTH_WORDS_KEY 
5488						DMARK "OUT" 
5488 f5				push af  
5489 3a 9d 54			ld a, (.dmark)  
548c 32 6e fe			ld (debug_mark),a  
548f 3a 9e 54			ld a, (.dmark+1)  
5492 32 6f fe			ld (debug_mark+1),a  
5495 3a 9f 54			ld a, (.dmark+2)  
5498 32 70 fe			ld (debug_mark+2),a  
549b 18 03			jr .pastdmark  
549d ..			.dmark: db "OUT"  
54a0 f1			.pastdmark: pop af  
54a1			endm  
# End of macro DMARK
54a1						CALLMONITOR 
54a1 cd f3 18			call break_point_state  
54a4				endm  
# End of macro CALLMONITOR
54a4					endif 
54a4			 
54a4					; get port 
54a4			 
54a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
54a4 cd 5e 21			call macro_dsp_valuehl 
54a7				endm 
# End of macro FORTH_DSP_VALUEHL
54a7			 
54a7 e5					push hl 
54a8			 
54a8					; destroy value TOS 
54a8			 
54a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
54a8 cd 16 22			call macro_forth_dsp_pop 
54ab				endm 
# End of macro FORTH_DSP_POP
54ab			 
54ab					; get byte to send 
54ab			 
54ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
54ab cd 5e 21			call macro_dsp_valuehl 
54ae				endm 
# End of macro FORTH_DSP_VALUEHL
54ae			 
54ae			;		push hl 
54ae			 
54ae					; destroy value TOS 
54ae			 
54ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
54ae cd 16 22			call macro_forth_dsp_pop 
54b1				endm 
# End of macro FORTH_DSP_POP
54b1			 
54b1					; one value on hl get other one back 
54b1			 
54b1			;		pop hl 
54b1			 
54b1 c1					pop bc 
54b2			 
54b2					if DEBUG_FORTH_WORDS 
54b2						DMARK "OUT" 
54b2 f5				push af  
54b3 3a c7 54			ld a, (.dmark)  
54b6 32 6e fe			ld (debug_mark),a  
54b9 3a c8 54			ld a, (.dmark+1)  
54bc 32 6f fe			ld (debug_mark+1),a  
54bf 3a c9 54			ld a, (.dmark+2)  
54c2 32 70 fe			ld (debug_mark+2),a  
54c5 18 03			jr .pastdmark  
54c7 ..			.dmark: db "OUT"  
54ca f1			.pastdmark: pop af  
54cb			endm  
# End of macro DMARK
54cb						CALLMONITOR 
54cb cd f3 18			call break_point_state  
54ce				endm  
# End of macro CALLMONITOR
54ce					endif 
54ce			 
54ce ed 69				out (c), l 
54d0			 
54d0					NEXTW 
54d0 c3 0d 23			jp macro_next 
54d3				endm 
# End of macro NEXTW
54d3			 
54d3			 
54d3			.SPIO: 
54d3			 
54d3			if STORAGE_SE 
54d3				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
54d3 51				db WORD_SYS_CORE+61             
54d4 e4 54			dw .SPICEH            
54d6 07				db 6 + 1 
54d7 .. 00			db "SPICEL",0              
54de				endm 
# End of macro CWHEAD
54de			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
54de			 
54de cd ca 01				call spi_ce_low 
54e1			    NEXTW 
54e1 c3 0d 23			jp macro_next 
54e4				endm 
# End of macro NEXTW
54e4			 
54e4			.SPICEH: 
54e4				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
54e4 51				db WORD_SYS_CORE+61             
54e5 f5 54			dw .SPIOb            
54e7 07				db 6 + 1 
54e8 .. 00			db "SPICEH",0              
54ef				endm 
# End of macro CWHEAD
54ef			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
54ef			 
54ef cd b9 01				call spi_ce_high 
54f2			    NEXTW 
54f2 c3 0d 23			jp macro_next 
54f5				endm 
# End of macro NEXTW
54f5			 
54f5			 
54f5			.SPIOb: 
54f5			 
54f5				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
54f5 51				db WORD_SYS_CORE+61             
54f6 27 55			dw .SPII            
54f8 05				db 4 + 1 
54f9 .. 00			db "SPIO",0              
54fe				endm 
# End of macro CWHEAD
54fe			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
54fe			 
54fe					if DEBUG_FORTH_WORDS_KEY 
54fe						DMARK "SPo" 
54fe f5				push af  
54ff 3a 13 55			ld a, (.dmark)  
5502 32 6e fe			ld (debug_mark),a  
5505 3a 14 55			ld a, (.dmark+1)  
5508 32 6f fe			ld (debug_mark+1),a  
550b 3a 15 55			ld a, (.dmark+2)  
550e 32 70 fe			ld (debug_mark+2),a  
5511 18 03			jr .pastdmark  
5513 ..			.dmark: db "SPo"  
5516 f1			.pastdmark: pop af  
5517			endm  
# End of macro DMARK
5517						CALLMONITOR 
5517 cd f3 18			call break_point_state  
551a				endm  
# End of macro CALLMONITOR
551a					endif 
551a					; get port 
551a			 
551a			 
551a					; get byte to send 
551a			 
551a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
551a cd 5e 21			call macro_dsp_valuehl 
551d				endm 
# End of macro FORTH_DSP_VALUEHL
551d			 
551d			;		push hl    ; u1  
551d			 
551d					; destroy value TOS 
551d			 
551d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
551d cd 16 22			call macro_forth_dsp_pop 
5520				endm 
# End of macro FORTH_DSP_POP
5520			 
5520					; one value on hl get other one back 
5520			 
5520			;		pop hl   ; u2 - addr 
5520			 
5520					; TODO Send SPI byte 
5520			 
5520			;		push hl 
5520			;		call spi_ce_low 
5520			;		pop hl 
5520 7d					ld a, l 
5521 cd b8 00				call spi_send_byte 
5524			;		call spi_ce_high 
5524			 
5524					NEXTW 
5524 c3 0d 23			jp macro_next 
5527				endm 
# End of macro NEXTW
5527			 
5527			.SPII: 
5527				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5527 52				db WORD_SYS_CORE+62             
5528 90 55			dw .SESEL            
552a 06				db 5 + 1 
552b .. 00			db "SPII",0              
5530				endm 
# End of macro CWHEAD
5530			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5530					if DEBUG_FORTH_WORDS_KEY 
5530						DMARK "SPi" 
5530 f5				push af  
5531 3a 45 55			ld a, (.dmark)  
5534 32 6e fe			ld (debug_mark),a  
5537 3a 46 55			ld a, (.dmark+1)  
553a 32 6f fe			ld (debug_mark+1),a  
553d 3a 47 55			ld a, (.dmark+2)  
5540 32 70 fe			ld (debug_mark+2),a  
5543 18 03			jr .pastdmark  
5545 ..			.dmark: db "SPi"  
5548 f1			.pastdmark: pop af  
5549			endm  
# End of macro DMARK
5549						CALLMONITOR 
5549 cd f3 18			call break_point_state  
554c				endm  
# End of macro CALLMONITOR
554c					endif 
554c			 
554c					; TODO Get SPI byte 
554c			 
554c cd df 00				call spi_read_byte 
554f			 
554f					if DEBUG_FORTH_WORDS 
554f						DMARK "Si2" 
554f f5				push af  
5550 3a 64 55			ld a, (.dmark)  
5553 32 6e fe			ld (debug_mark),a  
5556 3a 65 55			ld a, (.dmark+1)  
5559 32 6f fe			ld (debug_mark+1),a  
555c 3a 66 55			ld a, (.dmark+2)  
555f 32 70 fe			ld (debug_mark+2),a  
5562 18 03			jr .pastdmark  
5564 ..			.dmark: db "Si2"  
5567 f1			.pastdmark: pop af  
5568			endm  
# End of macro DMARK
5568						CALLMONITOR 
5568 cd f3 18			call break_point_state  
556b				endm  
# End of macro CALLMONITOR
556b					endif 
556b 26 00				ld h, 0 
556d 6f					ld l, a 
556e					if DEBUG_FORTH_WORDS 
556e						DMARK "Si3" 
556e f5				push af  
556f 3a 83 55			ld a, (.dmark)  
5572 32 6e fe			ld (debug_mark),a  
5575 3a 84 55			ld a, (.dmark+1)  
5578 32 6f fe			ld (debug_mark+1),a  
557b 3a 85 55			ld a, (.dmark+2)  
557e 32 70 fe			ld (debug_mark+2),a  
5581 18 03			jr .pastdmark  
5583 ..			.dmark: db "Si3"  
5586 f1			.pastdmark: pop af  
5587			endm  
# End of macro DMARK
5587						CALLMONITOR 
5587 cd f3 18			call break_point_state  
558a				endm  
# End of macro CALLMONITOR
558a					endif 
558a cd 67 1f				call forth_push_numhl 
558d			 
558d					NEXTW 
558d c3 0d 23			jp macro_next 
5590				endm 
# End of macro NEXTW
5590			 
5590			 
5590			 
5590			.SESEL: 
5590				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5590 66				db WORD_SYS_CORE+82             
5591 39 56			dw .CARTDEV            
5593 05				db 4 + 1 
5594 .. 00			db "BANK",0              
5599				endm 
# End of macro CWHEAD
5599			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5599					if DEBUG_FORTH_WORDS_KEY 
5599						DMARK "BNK" 
5599 f5				push af  
559a 3a ae 55			ld a, (.dmark)  
559d 32 6e fe			ld (debug_mark),a  
55a0 3a af 55			ld a, (.dmark+1)  
55a3 32 6f fe			ld (debug_mark+1),a  
55a6 3a b0 55			ld a, (.dmark+2)  
55a9 32 70 fe			ld (debug_mark+2),a  
55ac 18 03			jr .pastdmark  
55ae ..			.dmark: db "BNK"  
55b1 f1			.pastdmark: pop af  
55b2			endm  
# End of macro DMARK
55b2						CALLMONITOR 
55b2 cd f3 18			call break_point_state  
55b5				endm  
# End of macro CALLMONITOR
55b5					endif 
55b5			 
55b5 3e ff				ld a, 255 
55b7 32 6a fa				ld (spi_cartdev), a 
55ba			 
55ba					; get bank 
55ba			 
55ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
55ba cd 5e 21			call macro_dsp_valuehl 
55bd				endm 
# End of macro FORTH_DSP_VALUEHL
55bd			 
55bd			;		push hl 
55bd			 
55bd					; destroy value TOS 
55bd			 
55bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
55bd cd 16 22			call macro_forth_dsp_pop 
55c0				endm 
# End of macro FORTH_DSP_POP
55c0			 
55c0					; one value on hl get other one back 
55c0			 
55c0			;		pop hl 
55c0			 
55c0			 
55c0 0e ff				ld c, SPI_CE_HIGH 
55c2 06 30				ld b, '0'    ; human readable bank number 
55c4			 
55c4 7d					ld a, l 
55c5			 
55c5					if DEBUG_FORTH_WORDS 
55c5						DMARK "BNK" 
55c5 f5				push af  
55c6 3a da 55			ld a, (.dmark)  
55c9 32 6e fe			ld (debug_mark),a  
55cc 3a db 55			ld a, (.dmark+1)  
55cf 32 6f fe			ld (debug_mark+1),a  
55d2 3a dc 55			ld a, (.dmark+2)  
55d5 32 70 fe			ld (debug_mark+2),a  
55d8 18 03			jr .pastdmark  
55da ..			.dmark: db "BNK"  
55dd f1			.pastdmark: pop af  
55de			endm  
# End of macro DMARK
55de						CALLMONITOR 
55de cd f3 18			call break_point_state  
55e1				endm  
# End of macro CALLMONITOR
55e1					endif 
55e1			 
55e1					; active low 
55e1			 
55e1 fe 00				cp 0 
55e3 28 28				jr z, .bset 
55e5 fe 01				cp 1 
55e7 20 04				jr nz, .b2 
55e9 cb 81				res 0, c 
55eb 06 31				ld b, '1'    ; human readable bank number 
55ed fe 02		.b2:		cp 2 
55ef 20 04				jr nz, .b3 
55f1 cb 89				res 1, c 
55f3 06 32				ld b, '2'    ; human readable bank number 
55f5 fe 03		.b3:		cp 3 
55f7 20 04				jr nz, .b4 
55f9 cb 91				res 2, c 
55fb 06 33				ld b, '3'    ; human readable bank number 
55fd fe 04		.b4:		cp 4 
55ff 20 04				jr nz, .b5 
5601 cb 99				res 3, c 
5603 06 34				ld b, '4'    ; human readable bank number 
5605 fe 05		.b5:		cp 5 
5607 20 04				jr nz, .bset 
5609 cb a1				res 4, c 
560b 06 35				ld b, '5'    ; human readable bank number 
560d			 
560d			.bset: 
560d 79					ld a, c 
560e 32 67 fa				ld (spi_device),a 
5611 78					ld a, b 
5612 32 66 fa				ld (spi_device_id),a 
5615					if DEBUG_FORTH_WORDS 
5615						DMARK "BN2" 
5615 f5				push af  
5616 3a 2a 56			ld a, (.dmark)  
5619 32 6e fe			ld (debug_mark),a  
561c 3a 2b 56			ld a, (.dmark+1)  
561f 32 6f fe			ld (debug_mark+1),a  
5622 3a 2c 56			ld a, (.dmark+2)  
5625 32 70 fe			ld (debug_mark+2),a  
5628 18 03			jr .pastdmark  
562a ..			.dmark: db "BN2"  
562d f1			.pastdmark: pop af  
562e			endm  
# End of macro DMARK
562e						CALLMONITOR 
562e cd f3 18			call break_point_state  
5631				endm  
# End of macro CALLMONITOR
5631					endif 
5631			 
5631					; set default SPI clk pulse time as disabled for BANK use 
5631			 
5631 3e 00				ld a, 0 
5633 32 6b fa				ld (spi_clktime), a 
5636			 
5636					NEXTW 
5636 c3 0d 23			jp macro_next 
5639				endm 
# End of macro NEXTW
5639			 
5639			.CARTDEV: 
5639				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5639 66				db WORD_SYS_CORE+82             
563a e7 56			dw .ENDDEVICE            
563c 08				db 7 + 1 
563d .. 00			db "CARTDEV",0              
5645				endm 
# End of macro CWHEAD
5645			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5645					if DEBUG_FORTH_WORDS_KEY 
5645						DMARK "CDV" 
5645 f5				push af  
5646 3a 5a 56			ld a, (.dmark)  
5649 32 6e fe			ld (debug_mark),a  
564c 3a 5b 56			ld a, (.dmark+1)  
564f 32 6f fe			ld (debug_mark+1),a  
5652 3a 5c 56			ld a, (.dmark+2)  
5655 32 70 fe			ld (debug_mark+2),a  
5658 18 03			jr .pastdmark  
565a ..			.dmark: db "CDV"  
565d f1			.pastdmark: pop af  
565e			endm  
# End of macro DMARK
565e						CALLMONITOR 
565e cd f3 18			call break_point_state  
5661				endm  
# End of macro CALLMONITOR
5661					endif 
5661			 
5661					; disable se storage bank selection 
5661			 
5661 3e ff				ld a, SPI_CE_HIGH		; ce high 
5663 32 67 fa				ld (spi_device), a 
5666			 
5666					; get bank 
5666			 
5666					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5666 cd 5e 21			call macro_dsp_valuehl 
5669				endm 
# End of macro FORTH_DSP_VALUEHL
5669			 
5669			;		push hl 
5669			 
5669					; destroy value TOS 
5669			 
5669					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5669 cd 16 22			call macro_forth_dsp_pop 
566c				endm 
# End of macro FORTH_DSP_POP
566c			 
566c					; one value on hl get other one back 
566c			 
566c			;		pop hl 
566c			 
566c					; active low 
566c			 
566c 0e ff				ld c, 255 
566e			 
566e 7d					ld a, l 
566f					if DEBUG_FORTH_WORDS 
566f						DMARK "CDV" 
566f f5				push af  
5670 3a 84 56			ld a, (.dmark)  
5673 32 6e fe			ld (debug_mark),a  
5676 3a 85 56			ld a, (.dmark+1)  
5679 32 6f fe			ld (debug_mark+1),a  
567c 3a 86 56			ld a, (.dmark+2)  
567f 32 70 fe			ld (debug_mark+2),a  
5682 18 03			jr .pastdmark  
5684 ..			.dmark: db "CDV"  
5687 f1			.pastdmark: pop af  
5688			endm  
# End of macro DMARK
5688						CALLMONITOR 
5688 cd f3 18			call break_point_state  
568b				endm  
# End of macro CALLMONITOR
568b					endif 
568b fe 00				cp 0 
568d 28 30				jr z, .cset 
568f fe 01				cp 1 
5691 20 02				jr nz, .c2 
5693 cb 81				res 0, c 
5695 fe 02		.c2:		cp 2 
5697 20 02				jr nz, .c3 
5699 cb 89				res 1, c 
569b fe 03		.c3:		cp 3 
569d 20 02				jr nz, .c4 
569f cb 91				res 2, c 
56a1 fe 04		.c4:		cp 4 
56a3 20 02				jr nz, .c5 
56a5 cb 99				res 3, c 
56a7 fe 05		.c5:		cp 5 
56a9 20 02				jr nz, .c6 
56ab cb a1				res 4, c 
56ad fe 06		.c6:		cp 6 
56af 20 02				jr nz, .c7 
56b1 cb a9				res 5, c 
56b3 fe 07		.c7:		cp 7 
56b5 20 02				jr nz, .c8 
56b7 cb b1				res 6, c 
56b9 fe 08		.c8:		cp 8 
56bb 20 02				jr nz, .cset 
56bd cb b9				res 7, c 
56bf 79			.cset:		ld a, c 
56c0 32 6a fa				ld (spi_cartdev),a 
56c3			 
56c3					if DEBUG_FORTH_WORDS 
56c3						DMARK "CD2" 
56c3 f5				push af  
56c4 3a d8 56			ld a, (.dmark)  
56c7 32 6e fe			ld (debug_mark),a  
56ca 3a d9 56			ld a, (.dmark+1)  
56cd 32 6f fe			ld (debug_mark+1),a  
56d0 3a da 56			ld a, (.dmark+2)  
56d3 32 70 fe			ld (debug_mark+2),a  
56d6 18 03			jr .pastdmark  
56d8 ..			.dmark: db "CD2"  
56db f1			.pastdmark: pop af  
56dc			endm  
# End of macro DMARK
56dc						CALLMONITOR 
56dc cd f3 18			call break_point_state  
56df				endm  
# End of macro CALLMONITOR
56df					endif 
56df			 
56df					; set default SPI clk pulse time as 10ms for CARTDEV use 
56df			 
56df 3e 0a				ld a, $0a 
56e1 32 6b fa				ld (spi_clktime), a 
56e4					NEXTW 
56e4 c3 0d 23			jp macro_next 
56e7				endm 
# End of macro NEXTW
56e7			endif 
56e7			 
56e7			.ENDDEVICE: 
56e7			; eof 
56e7			 
# End of file forth_words_device.asm
56e7			 
56e7			; var handler 
56e7			 
56e7			 
56e7			.VARS: 
56e7				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
56e7 77				db WORD_SYS_CORE+99             
56e8 98 57			dw .V0            
56ea 04				db 3 + 1 
56eb .. 00			db "VAR",0              
56ef				endm 
# End of macro CWHEAD
56ef			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
56ef			;| 
56ef			;| The variable name should consist of a single letter. e.g. "a" 
56ef			;! If a full string is passed then only the first char is looked at 
56ef			;| Any other char could exceed bounds checks!  
56ef			 
56ef					if DEBUG_FORTH_WORDS_KEY 
56ef						DMARK "VAR" 
56ef f5				push af  
56f0 3a 04 57			ld a, (.dmark)  
56f3 32 6e fe			ld (debug_mark),a  
56f6 3a 05 57			ld a, (.dmark+1)  
56f9 32 6f fe			ld (debug_mark+1),a  
56fc 3a 06 57			ld a, (.dmark+2)  
56ff 32 70 fe			ld (debug_mark+2),a  
5702 18 03			jr .pastdmark  
5704 ..			.dmark: db "VAR"  
5707 f1			.pastdmark: pop af  
5708			endm  
# End of macro DMARK
5708						CALLMONITOR 
5708 cd f3 18			call break_point_state  
570b				endm  
# End of macro CALLMONITOR
570b					endif 
570b			 
570b					FORTH_DSP_VALUEHL 
570b cd 5e 21			call macro_dsp_valuehl 
570e				endm 
# End of macro FORTH_DSP_VALUEHL
570e			 
570e 7e					ld a, (hl)    ; get first char on of the string 
570f			 
570f			 
570f					if DEBUG_FORTH_WORDS 
570f						DMARK "VR1" 
570f f5				push af  
5710 3a 24 57			ld a, (.dmark)  
5713 32 6e fe			ld (debug_mark),a  
5716 3a 25 57			ld a, (.dmark+1)  
5719 32 6f fe			ld (debug_mark+1),a  
571c 3a 26 57			ld a, (.dmark+2)  
571f 32 70 fe			ld (debug_mark+2),a  
5722 18 03			jr .pastdmark  
5724 ..			.dmark: db "VR1"  
5727 f1			.pastdmark: pop af  
5728			endm  
# End of macro DMARK
5728						CALLMONITOR 
5728 cd f3 18			call break_point_state  
572b				endm  
# End of macro CALLMONITOR
572b					endif 
572b					 
572b f5					push af	 
572c					FORTH_DSP_POP 
572c cd 16 22			call macro_forth_dsp_pop 
572f				endm 
# End of macro FORTH_DSP_POP
572f f1					pop af 
5730			 
5730					; convert to upper 
5730			 
5730 cd b9 12				call to_upper 
5733					if DEBUG_FORTH_WORDS 
5733						DMARK "Vaa" 
5733 f5				push af  
5734 3a 48 57			ld a, (.dmark)  
5737 32 6e fe			ld (debug_mark),a  
573a 3a 49 57			ld a, (.dmark+1)  
573d 32 6f fe			ld (debug_mark+1),a  
5740 3a 4a 57			ld a, (.dmark+2)  
5743 32 70 fe			ld (debug_mark+2),a  
5746 18 03			jr .pastdmark  
5748 ..			.dmark: db "Vaa"  
574b f1			.pastdmark: pop af  
574c			endm  
# End of macro DMARK
574c						CALLMONITOR 
574c cd f3 18			call break_point_state  
574f				endm  
# End of macro CALLMONITOR
574f					endif 
574f 06 41				ld b, 'A' 
5751 90					sub b			; set offset 
5752					if DEBUG_FORTH_WORDS 
5752						DMARK "Vbb" 
5752 f5				push af  
5753 3a 67 57			ld a, (.dmark)  
5756 32 6e fe			ld (debug_mark),a  
5759 3a 68 57			ld a, (.dmark+1)  
575c 32 6f fe			ld (debug_mark+1),a  
575f 3a 69 57			ld a, (.dmark+2)  
5762 32 70 fe			ld (debug_mark+2),a  
5765 18 03			jr .pastdmark  
5767 ..			.dmark: db "Vbb"  
576a f1			.pastdmark: pop af  
576b			endm  
# End of macro DMARK
576b						CALLMONITOR 
576b cd f3 18			call break_point_state  
576e				endm  
# End of macro CALLMONITOR
576e					endif 
576e cb 27				sla a  
5770				 
5770					 
5770					if DEBUG_FORTH_WORDS 
5770						DMARK "VR2" 
5770 f5				push af  
5771 3a 85 57			ld a, (.dmark)  
5774 32 6e fe			ld (debug_mark),a  
5777 3a 86 57			ld a, (.dmark+1)  
577a 32 6f fe			ld (debug_mark+1),a  
577d 3a 87 57			ld a, (.dmark+2)  
5780 32 70 fe			ld (debug_mark+2),a  
5783 18 03			jr .pastdmark  
5785 ..			.dmark: db "VR2"  
5788 f1			.pastdmark: pop af  
5789			endm  
# End of macro DMARK
5789						CALLMONITOR 
5789 cd f3 18			call break_point_state  
578c				endm  
# End of macro CALLMONITOR
578c					endif 
578c			 
578c 21 fb f9				ld hl, cli_var_array2 
578f cd 4c 0f				call addatohl 
5792 cd 67 1f				call forth_push_numhl 
5795			 
5795			 
5795				       NEXTW 
5795 c3 0d 23			jp macro_next 
5798				endm 
# End of macro NEXTW
5798			.V0: 
5798				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5798 78				db WORD_SYS_CORE+100             
5799 b0 57			dw .V0Q            
579b 04				db 3 + 1 
579c .. 00			db "V0!",0              
57a0				endm 
# End of macro CWHEAD
57a0			;| V0! ( u1 -- )  Store value to v0  | DONE 
57a0			 
57a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
57a0 cd 5e 21			call macro_dsp_valuehl 
57a3				endm 
# End of macro FORTH_DSP_VALUEHL
57a3			 
57a3 11 2f fa				ld de, cli_var_array 
57a6			 
57a6 eb					ex de, hl 
57a7 73					ld (hl), e 
57a8 23					inc hl 
57a9 72					ld (hl), d 
57aa			 
57aa					; destroy value TOS 
57aa			 
57aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
57aa cd 16 22			call macro_forth_dsp_pop 
57ad				endm 
# End of macro FORTH_DSP_POP
57ad			 
57ad				       NEXTW 
57ad c3 0d 23			jp macro_next 
57b0				endm 
# End of macro NEXTW
57b0			.V0Q: 
57b0				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
57b0 79				db WORD_SYS_CORE+101             
57b1 c1 57			dw .V1S            
57b3 04				db 3 + 1 
57b4 .. 00			db "V0@",0              
57b8				endm 
# End of macro CWHEAD
57b8			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
57b8 2a 2f fa				ld hl, (cli_var_array) 
57bb cd 67 1f				call forth_push_numhl 
57be			 
57be				       NEXTW 
57be c3 0d 23			jp macro_next 
57c1				endm 
# End of macro NEXTW
57c1			.V1S: 
57c1				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
57c1 7a				db WORD_SYS_CORE+102             
57c2 d9 57			dw .V1Q            
57c4 04				db 3 + 1 
57c5 .. 00			db "V1!",0              
57c9				endm 
# End of macro CWHEAD
57c9			;| V1! ( u1 -- )  Store value to v1 | DONE 
57c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
57c9 cd 5e 21			call macro_dsp_valuehl 
57cc				endm 
# End of macro FORTH_DSP_VALUEHL
57cc			 
57cc 11 31 fa				ld de, cli_var_array+2 
57cf				 
57cf eb					ex de, hl 
57d0 73					ld (hl), e 
57d1 23					inc hl 
57d2 72					ld (hl), d 
57d3			 
57d3					; destroy value TOS 
57d3			 
57d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
57d3 cd 16 22			call macro_forth_dsp_pop 
57d6				endm 
# End of macro FORTH_DSP_POP
57d6				       NEXTW 
57d6 c3 0d 23			jp macro_next 
57d9				endm 
# End of macro NEXTW
57d9			.V1Q: 
57d9				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
57d9 7b				db WORD_SYS_CORE+103             
57da ea 57			dw .V2S            
57dc 04				db 3 + 1 
57dd .. 00			db "V1@",0              
57e1				endm 
# End of macro CWHEAD
57e1			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
57e1 2a 31 fa				ld hl, (cli_var_array+2) 
57e4 cd 67 1f				call forth_push_numhl 
57e7				       NEXTW 
57e7 c3 0d 23			jp macro_next 
57ea				endm 
# End of macro NEXTW
57ea			.V2S: 
57ea				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
57ea 7c				db WORD_SYS_CORE+104             
57eb 02 58			dw .V2Q            
57ed 04				db 3 + 1 
57ee .. 00			db "V2!",0              
57f2				endm 
# End of macro CWHEAD
57f2			;| V2! ( u1 -- )  Store value to v2 | DONE 
57f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
57f2 cd 5e 21			call macro_dsp_valuehl 
57f5				endm 
# End of macro FORTH_DSP_VALUEHL
57f5			 
57f5 11 33 fa				ld de, cli_var_array+4 
57f8				 
57f8 eb					ex de, hl 
57f9 73					ld (hl), e 
57fa 23					inc hl 
57fb 72					ld (hl), d 
57fc			 
57fc					; destroy value TOS 
57fc			 
57fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
57fc cd 16 22			call macro_forth_dsp_pop 
57ff				endm 
# End of macro FORTH_DSP_POP
57ff				       NEXTW 
57ff c3 0d 23			jp macro_next 
5802				endm 
# End of macro NEXTW
5802			.V2Q: 
5802				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5802 7d				db WORD_SYS_CORE+105             
5803 13 58			dw .V3S            
5805 04				db 3 + 1 
5806 .. 00			db "V2@",0              
580a				endm 
# End of macro CWHEAD
580a			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
580a 2a 33 fa				ld hl, (cli_var_array+4) 
580d cd 67 1f				call forth_push_numhl 
5810				       NEXTW 
5810 c3 0d 23			jp macro_next 
5813				endm 
# End of macro NEXTW
5813			.V3S: 
5813				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5813 7c				db WORD_SYS_CORE+104             
5814 2b 58			dw .V3Q            
5816 04				db 3 + 1 
5817 .. 00			db "V3!",0              
581b				endm 
# End of macro CWHEAD
581b			;| V3! ( u1 -- )  Store value to v3 | DONE 
581b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
581b cd 5e 21			call macro_dsp_valuehl 
581e				endm 
# End of macro FORTH_DSP_VALUEHL
581e			 
581e 11 35 fa				ld de, cli_var_array+6 
5821				 
5821 eb					ex de, hl 
5822 73					ld (hl), e 
5823 23					inc hl 
5824 72					ld (hl), d 
5825			 
5825					; destroy value TOS 
5825			 
5825					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5825 cd 16 22			call macro_forth_dsp_pop 
5828				endm 
# End of macro FORTH_DSP_POP
5828				       NEXTW 
5828 c3 0d 23			jp macro_next 
582b				endm 
# End of macro NEXTW
582b			.V3Q: 
582b				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
582b 7d				db WORD_SYS_CORE+105             
582c 3c 58			dw .END            
582e 04				db 3 + 1 
582f .. 00			db "V3@",0              
5833				endm 
# End of macro CWHEAD
5833			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5833 2a 35 fa				ld hl, (cli_var_array+6) 
5836 cd 67 1f				call forth_push_numhl 
5839				       NEXTW 
5839 c3 0d 23			jp macro_next 
583c				endm 
# End of macro NEXTW
583c			 
583c			 
583c			 
583c			 
583c			 
583c			; end of dict marker 
583c			 
583c 00			.END:    db WORD_SYS_END 
583d 00 00			dw 0 
583f 00				db 0 
5840			 
5840			; use to jp here for user dict words to save on macro expansion  
5840			 
5840			user_dict_next: 
5840				NEXTW 
5840 c3 0d 23			jp macro_next 
5843				endm 
# End of macro NEXTW
5843			 
5843			 
5843			user_exec: 
5843				;    ld hl, <word code> 
5843				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5843				;    call forthexec 
5843				;    jp user_dict_next   (NEXT) 
5843			        ;    <word code bytes> 
5843 eb				ex de, hl 
5844 2a c9 f4			ld hl,(os_tok_ptr) 
5847				 
5847				FORTH_RSP_NEXT 
5847 cd 0e 1f			call macro_forth_rsp_next 
584a				endm 
# End of macro FORTH_RSP_NEXT
584a			 
584a			if DEBUG_FORTH_UWORD 
584a						DMARK "UEX" 
584a f5				push af  
584b 3a 5f 58			ld a, (.dmark)  
584e 32 6e fe			ld (debug_mark),a  
5851 3a 60 58			ld a, (.dmark+1)  
5854 32 6f fe			ld (debug_mark+1),a  
5857 3a 61 58			ld a, (.dmark+2)  
585a 32 70 fe			ld (debug_mark+2),a  
585d 18 03			jr .pastdmark  
585f ..			.dmark: db "UEX"  
5862 f1			.pastdmark: pop af  
5863			endm  
# End of macro DMARK
5863				CALLMONITOR 
5863 cd f3 18			call break_point_state  
5866				endm  
# End of macro CALLMONITOR
5866			endif 
5866			 
5866			 
5866			 
5866 eb				ex de, hl 
5867 22 c9 f4			ld (os_tok_ptr), hl 
586a				 
586a				; Don't use next - Skips the first word in uword. 
586a			 
586a c3 9e 23			jp exec1 
586d			;	NEXT 
586d			 
586d			 
586d			; eof 
# End of file forth_wordsv4.asm
586d			endif 
586d			;;;;;;;;;;;;;; Debug code 
586d			 
586d			 
586d			;if DEBUG_FORTH_PARSE 
586d .. 00		.nowordfound: db "No match",0 
5876 .. 00		.compword:	db "Comparing word ",0 
5886 .. 00		.nextwordat:	db "Next word at",0 
5893 .. 00		.charmatch:	db "Char match",0 
589e			;endif 
589e			if DEBUG_FORTH_JP 
589e			.foundword:	db "Word match. Exec..",0 
589e			endif 
589e			;if DEBUG_FORTH_PUSH 
589e .. 00		.enddict:	db "Dict end. Push.",0 
58ae .. 00		.push_str:	db "Pushing string",0 
58bd .. 00		.push_num:	db "Pushing number",0 
58cc .. 00		.data_sp:	db "SP:",0 
58d0 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
58e2 .. 00		.wordinde:	db "Word in DE (3/0):",0 
58f4 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5906			;endif 
5906			;if DEBUG_FORTH_MALLOC 
5906 .. 00		.push_malloc:	db "Malloc address",0 
5915			;endif 
5915			 
5915			 
5915			 
5915			; display malloc address and current data stack pointer  
5915			 
5915			malloc_error: 
5915 d5				push de 
5916 f5				push af 
5917 e5				push hl 
5918 cd 18 0d			call clear_display 
591b 11 3d 59			ld de, .mallocerr 
591e 3e 00			ld a,0 
5920			;	ld de,os_word_scratch 
5920 cd 2b 0d			call str_at_display 
5923 3e 11			ld a, display_row_1+17 
5925 11 6e fe			ld de, debug_mark 
5928 cd 2b 0d			call str_at_display 
592b cd 3b 0d			call update_display 
592e				;call break_point_state 
592e cd a9 73			call cin_wait 
5931			 
5931 3e 20			ld a, ' ' 
5933 32 b9 f1			ld (os_view_disable), a 
5936 e1				pop hl 
5937 f1				pop af 
5938 d1				pop de	 
5939				CALLMONITOR 
5939 cd f3 18			call break_point_state  
593c				endm  
# End of macro CALLMONITOR
593c c9				ret 
593d			 
593d .. 00		.mallocerr: 	db "Malloc Error",0 
594a			;if DEBUG_FORTH_PUSH 
594a			display_data_sp: 
594a f5				push af 
594b			 
594b				; see if disabled 
594b			 
594b 3a b9 f1			ld a, (os_view_disable) 
594e fe 2a			cp '*' 
5950 28 67			jr z, .skipdsp 
5952			 
5952 e5				push hl 
5953 e5				push hl 
5954 e5			push hl 
5955 cd 18 0d			call clear_display 
5958 e1			pop hl 
5959 7c				ld a,h 
595a 21 cd f4			ld hl, os_word_scratch 
595d cd 4d 12			call hexout 
5960 e1				pop hl 
5961 7d				ld a,l 
5962 21 cf f4			ld hl, os_word_scratch+2 
5965 cd 4d 12			call hexout 
5968 21 d1 f4			ld hl, os_word_scratch+4 
596b 3e 00			ld a,0 
596d 77				ld (hl),a 
596e 11 cd f4			ld de,os_word_scratch 
5971 3e 28				ld a, display_row_2 
5973 cd 2b 0d				call str_at_display 
5976 11 d0 58			ld de, .wordinhl 
5979 3e 00			ld a, display_row_1 
597b			 
597b cd 2b 0d				call str_at_display 
597e 11 6e fe			ld de, debug_mark 
5981 3e 11			ld a, display_row_1+17 
5983			 
5983 cd 2b 0d				call str_at_display 
5986			 
5986				; display current data stack pointer 
5986 11 cc 58			ld de,.data_sp 
5989 3e 30				ld a, display_row_2 + 8 
598b cd 2b 0d				call str_at_display 
598e			 
598e 2a f5 f9			ld hl,(cli_data_sp) 
5991 e5				push hl 
5992 7c				ld a,h 
5993 21 cd f4			ld hl, os_word_scratch 
5996 cd 4d 12			call hexout 
5999 e1				pop hl 
599a 7d				ld a,l 
599b 21 cf f4			ld hl, os_word_scratch+2 
599e cd 4d 12			call hexout 
59a1 21 d1 f4			ld hl, os_word_scratch+4 
59a4 3e 00			ld a,0 
59a6 77				ld (hl),a 
59a7 11 cd f4			ld de,os_word_scratch 
59aa 3e 33				ld a, display_row_2 + 11 
59ac cd 2b 0d				call str_at_display 
59af			 
59af			 
59af cd 3b 0d			call update_display 
59b2 cd 95 0c			call delay1s 
59b5 cd 95 0c			call delay1s 
59b8 e1				pop hl 
59b9			.skipdsp: 
59b9 f1				pop af 
59ba c9				ret 
59bb			 
59bb			display_data_malloc: 
59bb			 
59bb f5				push af 
59bc e5				push hl 
59bd e5				push hl 
59be e5			push hl 
59bf cd 18 0d			call clear_display 
59c2 e1			pop hl 
59c3 7c				ld a,h 
59c4 21 cd f4			ld hl, os_word_scratch 
59c7 cd 4d 12			call hexout 
59ca e1				pop hl 
59cb 7d				ld a,l 
59cc 21 cf f4			ld hl, os_word_scratch+2 
59cf cd 4d 12			call hexout 
59d2 21 d1 f4			ld hl, os_word_scratch+4 
59d5 3e 00			ld a,0 
59d7 77				ld (hl),a 
59d8 11 cd f4			ld de,os_word_scratch 
59db 3e 28				ld a, display_row_2 
59dd cd 2b 0d				call str_at_display 
59e0 11 06 59			ld de, .push_malloc 
59e3 3e 00			ld a, display_row_1 
59e5			 
59e5 cd 2b 0d				call str_at_display 
59e8			 
59e8				; display current data stack pointer 
59e8 11 cc 58			ld de,.data_sp 
59eb 3e 30				ld a, display_row_2 + 8 
59ed cd 2b 0d				call str_at_display 
59f0			 
59f0 2a f5 f9			ld hl,(cli_data_sp) 
59f3 e5				push hl 
59f4 7c				ld a,h 
59f5 21 cd f4			ld hl, os_word_scratch 
59f8 cd 4d 12			call hexout 
59fb e1				pop hl 
59fc 7d				ld a,l 
59fd 21 cf f4			ld hl, os_word_scratch+2 
5a00 cd 4d 12			call hexout 
5a03 21 d1 f4			ld hl, os_word_scratch+4 
5a06 3e 00			ld a,0 
5a08 77				ld (hl),a 
5a09 11 cd f4			ld de,os_word_scratch 
5a0c 3e 33				ld a, display_row_2 + 11 
5a0e cd 2b 0d				call str_at_display 
5a11			 
5a11 cd 3b 0d			call update_display 
5a14 cd 95 0c			call delay1s 
5a17 cd 95 0c			call delay1s 
5a1a e1				pop hl 
5a1b f1				pop af 
5a1c c9				ret 
5a1d			;endif 
5a1d			 
5a1d			include "forth_autostart.asm" 
5a1d			; list of commands to perform at system start up 
5a1d			 
5a1d			startcmds: 
5a1d			;	dw test11 
5a1d			;	dw test12 
5a1d			;	dw test13 
5a1d			;	dw test14 
5a1d			;	dw test15 
5a1d			;	dw test16 
5a1d			;	dw test17 
5a1d			;	dw ifthtest1 
5a1d			;	dw ifthtest2 
5a1d			;	dw ifthtest3 
5a1d			;	dw mmtest1 
5a1d			;	dw mmtest2 
5a1d			;	dw mmtest3 
5a1d			;	dw mmtest4 
5a1d			;	dw mmtest5 
5a1d			;	dw mmtest6 
5a1d			;	dw iftest1 
5a1d			;	dw iftest2 
5a1d			;	dw iftest3 
5a1d			;	dw looptest1 
5a1d			;	dw looptest2 
5a1d			;	dw test1 
5a1d			;	dw test2 
5a1d			;	dw test3 
5a1d			;	dw test4 
5a1d			;	dw game2r 
5a1d			;	dw game2b1 
5a1d			;	dw game2b2 
5a1d			 
5a1d				; start up words that are actually useful 
5a1d			 
5a1d 91 5a		    dw spi1 
5a1f ec 5a		    dw spi2 
5a21 7a 5b		    dw spi3 
5a23 22 5b		    dw spi4 
5a25 4d 5b		    dw spi5 
5a27 e0 5b		    dw spi6 
5a29 35 5c		    dw spi7 
5a2b			 
5a2b 8d 5c		    dw spi8 
5a2d ac 5c		    dw spi9 
5a2f 04 5d		    dw spi10 
5a31			 
5a31 77 5d			dw longread 
5a33 be 5d			dw clrstack 
5a35 f1 5d			dw type 
5a37 e1 5f			dw stest 
5a39 15 5e			dw strncpy 
5a3b 77 5f			dw list 
5a3d 76 5e			dw start1 
5a3f 88 5e			dw start2 
5a41			;	dw start3 
5a41 9b 5e			dw start3b 
5a43 17 5f			dw start3c 
5a45			 
5a45				; (unit) testing words 
5a45			 
5a45 58 60			dw mtesta 
5a47 0d 61			dw mtestb 
5a49 b0 61			dw mtestc 
5a4b 65 62			dw mtestd 
5a4d 09 63			dw mteste 
5a4f			 
5a4f				; demo/game words 
5a4f			 
5a4f 15 6a		        dw game3w 
5a51 43 6a		        dw game3p 
5a53 61 6a		        dw game3sc 
5a55 92 6a		        dw game3vsi 
5a57 be 6a		        dw game3vs 
5a59				 
5a59 08 68			dw game2b 
5a5b 76 68			dw game2bf 
5a5d c0 68			dw game2mba 
5a5f 56 69			dw game2mbas 
5a61 98 69			dw game2mb 
5a63			 
5a63 c9 64			dw game1 
5a65 da 64			dw game1a 
5a67 3c 65			dw game1b 
5a69 71 65			dw game1c 
5a6b a7 65			dw game1d 
5a6d d8 65			dw game1s 
5a6f ec 65			dw game1t 
5a71 01 66			dw game1f 
5a73 35 66			dw game1z 
5a75 79 66			dw game1zz 
5a77			 
5a77 bf 63			dw test5 
5a79 f7 63			dw test6 
5a7b 2f 64			dw test7 
5a7d 43 64			dw test8 
5a7f 6f 64			dw test9 
5a81 85 64			dw test10 
5a83				 
5a83 50 67		        dw ssv5 
5a85 34 67		        dw ssv4 
5a87 18 67		        dw ssv3 
5a89 e2 66		        dw ssv2 
5a8b 69 67		        dw ssv1 
5a8d b1 67		        dw ssv1cpm 
5a8f			;	dw keyup 
5a8f			;	dw keydown 
5a8f			;	dw keyleft 
5a8f			;	dw keyright 
5a8f			;	dw 	keyf1 
5a8f			;	dw keyf2 
5a8f			;	dw keyf3 
5a8f			;	dw keyf4 
5a8f			;	dw keyf5 
5a8f			;	dw keyf6 
5a8f			;	dw keyf7 
5a8f			;	dw keyf8 
5a8f			;	dw keyf9 
5a8f			;	dw keyf10 
5a8f			;	dw keyf11 
5a8f			;	dw keyf12 
5a8f			;	dw keytab 
5a8f			;	dw keycr 
5a8f			;	dw keyhome 
5a8f			;	dw keyend 
5a8f			;	dw keybs 
5a8f 00 00			db 0, 0	 
5a91			 
5a91			; SPI Net support words 
5a91			 
5a91			; v0! = node to send to 
5a91			; ( str count - ) 
5a91 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5aec			 
5aec			; spiputchr ( char node - ) 
5aec .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
5b22			 
5b22			; spigetchr ( - n ) 
5b22 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
5b4d			 
5b4d			; getnode ( - n ) 
5b4d .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5b7a			 
5b7a			; ( str node - )  
5b7a .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5be0			; store string ( str i - ) 
5be0			 
5be0			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5be0 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5c35			 
5c35			; get string ( addr i -  )    TO FIX 
5c35			 
5c35 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5c8d			 
5c8d			 
5c8d			; NETCHAT (TODO) 
5c8d			; Program to allow two nodes to chat with eachother 
5c8d			; 
5c8d			; v0 - target node 
5c8d			;  
5c8d			; accept input at 0,0 
5c8d			; if input is string send spitype to target node 
5c8d			; starting at row 2,0 , while spigetchr is not zero ->  
5c8d			; 
5c8d			; 
5c8d			; TODO add paging of get request 
5c8d			 
5c8d			; ( node - ) 
5c8d .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5cac .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5d04 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
5d77			 
5d77			 
5d77			; Long read of currently open file 
5d77 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5dbe			 
5dbe			; clear stack  
5dbe			 
5dbe .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5df1			 
5df1			; type ( addr count - ) 
5df1 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5e15			 
5e15			; some direct memory words 
5e15			; strncpy ( len t f -- t ) 
5e15			 
5e15 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5e76			 
5e76 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5e88 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5e9b .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5f17 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5f77			 
5f77			 
5f77			; a handy word to list items on the stack 
5f77			 
5f77 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5fe1			 
5fe1			 
5fe1			; test stack  
5fe1			; rnd8 stest 
5fe1			 
5fe1 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
6058			 
6058			; random malloc and free cycles 
6058			 
6058 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
610d			 
610d			; fixed malloc and free cycles 
610d			 
610d .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
61b0			 
61b0			; fixed double string push and drop cycle  
61b0			 
61b0 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6265			 
6265			; consistent fixed string push and drop cycle  
6265			 
6265 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6309			 
6309 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
63bf			 
63bf			;test1:		db ": aa 1 2 3 ;", 0 
63bf			;test2:     	db "111 aa 888 999",0 
63bf			;test3:     	db ": bb 77 ;",0 
63bf			;test4:     	db "$02 $01 do i . loop bb",0 
63bf			 
63bf .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
63f7 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
642f .. 00		test7:     	db ": box hline vline ;",0 
6443 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
646f .. 00		test9:     	db ": sw $01 adsp world ;",0 
6485 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
64aa .. 00		test11:     	db "hello create .",0 
64b9 .. 00		test12:     	db "hello2 create .",0 
64c9			 
64c9			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
64c9			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
64c9			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
64c9			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
64c9			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
64c9			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
64c9			 
64c9			;iftest1:     	db "$0001 IF cls .",0 
64c9			;iftest2:     	db "$0000 IF cls .",0 
64c9			;iftest3:     	db "$0002 $0003 - IF cls .",0 
64c9			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
64c9			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
64c9			 
64c9			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
64c9			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
64c9			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
64c9			 
64c9			 
64c9			 
64c9			; a small guess the number game 
64c9			 
64c9 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
64da .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
653c			 
653c .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6571 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
65a7 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
65d8 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
65ec .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6601 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6635 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6679			 
6679			; Using 'ga' save a high score across multiple runs using external storage 
6679			 
6679 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
66e2			 
66e2			 
66e2			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
66e2			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
66e2			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
66e2			 
66e2			; simple screen saver to test code memory reuse to destruction 
66e2			 
66e2 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6718 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6734 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6750 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6769 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
67b1 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6808			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6808			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6808			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6808			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6808			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6808			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6808			 
6808			 
6808			 
6808			; minesweeper/battleship finding game 
6808			; draws a game board of random ship/mine positions 
6808			; user enters coords to see if it hits on 
6808			; game ends when all are hit 
6808			; when hit or miss says how many may be in the area 
6808			 
6808			; setup the game board and then hide it 
6808 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6876 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
68c0			; prompt for where to target 
68c0 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6956 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
697b			; TODO see if the entered coords hits or misses pushes char hit of miss 
697b .. 00		game2mbht:      db ": mbckht nop ;",0 
698a .. 00		game2mbms:      db ": mbcms nop ;",0 
6998			; TODO how many might be near by 
6998 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6a15			 
6a15			; Game 3 
6a15			 
6a15			; Vert scroller ski game - avoid the trees! 
6a15			 
6a15			; v0 score (ie turns) 
6a15			; v1 player pos 
6a15			; v2 left wall 
6a15			; v3 right wall 
6a15			 
6a15			; Draw side walls randomly 
6a15			 
6a15 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6a43			 
6a43			; Draw player 
6a43 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6a61			 
6a61			; TODO Get Key 
6a61			 
6a61			; TODO Move left right 
6a61			 
6a61			; scroll and move walls a bit 
6a61			 
6a61 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6a92			 
6a92			; main game loop 
6a92			 
6a92 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6abe .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6afd			 
6afd			; key board defs 
6afd			 
6afd .. 00		keyup:       db ": keyup $05 ;",0 
6b0b .. 00		keydown:       db ": keydown $0a ;",0 
6b1b .. 00		keyleft:       db ": keyleft $0b ;",0 
6b2b .. 00		keyright:       db ": keyright $0c ;",0 
6b3c .. 00		keyf1:       db ": keyf1 $10 ;",0 
6b4a .. 00		keyf2:       db ": keyf2 $11 ;",0 
6b58 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6b66 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6b74 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6b82 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6b90 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6b9e .. 00		keyf8:       db ": keyf8 $17 ;",0 
6bac .. 00		keyf9:       db ": keyf9 $18 ;",0 
6bba .. 00		keyf10:       db ": keyf10 $19 ;",0 
6bc9 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6bd8 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6be7			 
6be7 .. 00		keytab:       db ": keytab $09 ;",0 
6bf6 .. 00		keycr:       db ": keycr $0d ;",0 
6c04 .. 00		keyhome:       db ": keyhome $0e ;",0 
6c14 .. 00		keyend:       db ": keyend $0f ;",0 
6c23 .. 00		keybs:       db ": keybs $08 ;",0 
6c31			 
6c31			   
6c31			 
6c31			 
6c31			 
6c31			; eof 
# End of file forth_autostart.asm
6c31			 
6c31 .. 00		sprompt1: db "Startup load...",0 
6c41 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6c57			 
6c57			 
6c57			 
6c57			 
6c57			forth_startup: 
6c57 21 1d 5a			ld hl, startcmds 
6c5a 3e 00			ld a, 0 
6c5c 32 ee f5			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6c5f			 
6c5f e5			.start1:	push hl 
6c60 cd 18 0d			call clear_display 
6c63 11 31 6c			ld de, sprompt1 
6c66 3e 00		        ld a, display_row_1 
6c68 cd 2b 0d			call str_at_display 
6c6b 11 41 6c			ld de, sprompt2 
6c6e 3e 28		        ld a, display_row_2 
6c70 cd 2b 0d			call str_at_display 
6c73 e1				pop hl 
6c74 e5				push hl 
6c75 5e				ld e,(hl) 
6c76 23				inc hl 
6c77 56				ld d,(hl) 
6c78 3e 50		        ld a, display_row_3 
6c7a cd 2b 0d			call str_at_display 
6c7d cd 3b 0d			call update_display 
6c80			 
6c80			 
6c80 3a ee f5			ld a, (os_last_cmd) 
6c83 fe 00			cp 0 
6c85 28 05			jr z, .startprompt 
6c87 cd 89 0c			call delay250ms 
6c8a 18 24			jr .startdo 
6c8c				 
6c8c				 
6c8c			 
6c8c			.startprompt: 
6c8c			 
6c8c 3e 9f			ld a,display_row_4 + display_cols - 1 
6c8e 11 dd 1e		        ld de, endprg 
6c91 cd 2b 0d			call str_at_display 
6c94 cd 3b 0d			call update_display 
6c97 cd 95 0c			call delay1s 
6c9a cd a9 73			call cin_wait 
6c9d						 
6c9d fe 2a			cp '*' 
6c9f 28 5e			jr z, .startupend1 
6ca1 fe 23			cp '#' 
6ca3 20 07			jr nz, .startno 
6ca5 3e 01			ld a, 1 
6ca7 32 ee f5			ld (os_last_cmd),a 
6caa 18 04			jr .startdo 
6cac fe 31		.startno:	cp '1' 
6cae 28 3a			jr z,.startnxt  
6cb0			 
6cb0				; exec startup line 
6cb0			.startdo:	 
6cb0 e1				pop hl 
6cb1 e5				push hl 
6cb2				 
6cb2 5e				ld e,(hl) 
6cb3 23				inc hl 
6cb4 56				ld d,(hl) 
6cb5 eb				ex de,hl 
6cb6			 
6cb6 e5				push hl 
6cb7			 
6cb7 3e 00			ld a, 0 
6cb9				;ld a, FORTH_END_BUFFER 
6cb9 cd b5 13			call strlent 
6cbc 23				inc hl   ; include zero term to copy 
6cbd 06 00			ld b,0 
6cbf 4d				ld c,l 
6cc0 e1				pop hl 
6cc1 11 c8 f1			ld de, scratch 
6cc4 ed b0			ldir 
6cc6			 
6cc6			 
6cc6 21 c8 f1			ld hl, scratch 
6cc9 cd 5b 23			call forthparse 
6ccc cd 9b 23			call forthexec 
6ccf cd ad 22			call forthexec_cleanup 
6cd2			 
6cd2 3e 78			ld a, display_row_4 
6cd4 11 81 1c			ld de, endprog 
6cd7			 
6cd7 cd 3b 0d			call update_display		 
6cda			 
6cda 3a ee f5			ld a, (os_last_cmd) 
6cdd fe 00			cp 0 
6cdf 20 09			jr nz, .startnxt 
6ce1 cd df 1e			call next_page_prompt 
6ce4 cd 18 0d		        call clear_display 
6ce7 cd 3b 0d			call update_display		 
6cea			 
6cea				; move onto next startup line? 
6cea			.startnxt: 
6cea			 
6cea cd 89 0c			call delay250ms 
6ced e1				pop hl 
6cee			 
6cee 23				inc hl 
6cef 23				inc hl 
6cf0			 
6cf0 e5				push hl 
6cf1 5e				ld e, (hl) 
6cf2 23				inc hl 
6cf3 56				ld d, (hl) 
6cf4 e1				pop hl 
6cf5				; TODO replace 0 test 
6cf5			 
6cf5 eb				ex de, hl 
6cf6 cd 75 0f			call ishlzero 
6cf9			;	ld a,e 
6cf9			;	add d 
6cf9			;	cp 0    ; any left to do? 
6cf9 eb				ex de, hl 
6cfa c2 5f 6c			jp nz, .start1 
6cfd 18 01			jr .startupend 
6cff			 
6cff e1			.startupend1: pop hl 
6d00			.startupend: 
6d00			 
6d00 cd 18 0d			call clear_display 
6d03 cd 3b 0d			call update_display 
6d06 c9				ret 
6d07			 
6d07			 
6d07			; stack over and underflow checks 
6d07			 
6d07			; init the words to detect the under/overflow 
6d07			 
6d07			chk_stk_init: 
6d07				; a vague random number to check so we dont get any "lucky" hits 
6d07 3e 2d			ld a, 45 
6d09 6f				ld l, a 
6d0a 00				nop 
6d0b 3e 17			ld a, 23 
6d0d 67				ld h, a 
6d0e			 
6d0e 22 af f1			ld (chk_word), hl     ; the word we need to check against 
6d11			 
6d11			;	ld (chk_stund), hl	; stack points.... 
6d11 22 fd fe			ld (chk_stovr), hl 
6d14 22 f3 f9			ld (chk_ret_und), hl 
6d17 22 b1 f9			ld (chk_ret_ovr), hl 
6d1a 22 2f f9			ld (chk_loop_ovr), hl 
6d1d 22 2d f7			ld (chk_data_ovr), hl 
6d20 c9				ret 
6d21				 
6d21			check_stacks: 
6d21				; check all stack words 
6d21			 
6d21 e5				push hl 
6d22 d5				push de 
6d23			 
6d23			;	ld de,(chk_word) 
6d23			;	ld hl, (chk_stund)	; stack points.... 
6d23			;	if DEBUG_STK_FAULT 
6d23			;		DMARK "FAa" 
6d23			;		CALLMONITOR 
6d23			;	endif 
6d23			;	call cmp16 
6d23			;	jp z, .chk_faulta 
6d23			; 
6d23			;	ld de, sfaultsu 
6d23			;	jp .chk_fault 
6d23			 
6d23 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6d26 ed 5b af f1		ld de,(chk_word) 
6d2a				if DEBUG_STK_FAULT 
6d2a					DMARK "FAb" 
6d2a					CALLMONITOR 
6d2a				endif 
6d2a cd 6a 0f			call cmp16 
6d2d 28 06			jr z, .chk_fault1 
6d2f 11 d0 6d			ld de, sfaultso 
6d32 c3 84 6d			jp .chk_fault 
6d35			.chk_fault1:  
6d35 2a f3 f9			ld hl, (chk_ret_und) 
6d38 ed 5b af f1		ld de,(chk_word) 
6d3c				if DEBUG_STK_FAULT 
6d3c					DMARK "FAU" 
6d3c					CALLMONITOR 
6d3c				endif 
6d3c cd 6a 0f			call cmp16 
6d3f ca 48 6d			jp z, .chk_fault2 
6d42 11 e0 6d			ld de, sfaultru 
6d45 c3 84 6d			jp .chk_fault 
6d48			.chk_fault2:  
6d48 2a b1 f9			ld hl, (chk_ret_ovr) 
6d4b ed 5b af f1		ld de,(chk_word) 
6d4f				if DEBUG_STK_FAULT 
6d4f					DMARK "FA1" 
6d4f					CALLMONITOR 
6d4f				endif 
6d4f cd 6a 0f			call cmp16 
6d52 ca 5b 6d			jp z, .chk_fault3 
6d55 11 ee 6d			ld de, sfaultro 
6d58 c3 84 6d			jp .chk_fault 
6d5b			.chk_fault3:  
6d5b 2a 2f f9			ld hl, (chk_loop_ovr) 
6d5e ed 5b af f1		ld de,(chk_word) 
6d62				if DEBUG_STK_FAULT 
6d62					DMARK "FA2" 
6d62					CALLMONITOR 
6d62				endif 
6d62 cd 6a 0f			call cmp16 
6d65 ca 6e 6d			jp z, .chk_fault4 
6d68 11 08 6e			ld de, sfaultlo 
6d6b c3 84 6d			jp .chk_fault 
6d6e			.chk_fault4:  
6d6e 2a 2d f7			ld hl, (chk_data_ovr) 
6d71 ed 5b af f1		ld de,(chk_word) 
6d75				if DEBUG_STK_FAULT 
6d75					DMARK "FA3" 
6d75					CALLMONITOR 
6d75				endif 
6d75 cd 6a 0f			call cmp16 
6d78 ca 81 6d			jp z, .chk_fault5 
6d7b 11 22 6e			ld de, sfaultdo 
6d7e c3 84 6d			jp .chk_fault 
6d81			 
6d81			 
6d81			.chk_fault5:  
6d81 d1				pop de 
6d82 e1				pop hl 
6d83			 
6d83 c9				ret 
6d84			 
6d84 cd 18 0d		.chk_fault: 	call clear_display 
6d87 3e 28				ld a, display_row_2 
6d89 cd 2b 0d				call str_at_display 
6d8c 11 b2 6d				   ld de, .stackfault 
6d8f 3e 00				ld a, display_row_1 
6d91 cd 2b 0d				call str_at_display 
6d94 11 6e fe				    ld de, debug_mark 
6d97 3e 11				ld a, display_row_1+17 
6d99 cd 2b 0d				call str_at_display 
6d9c cd 3b 0d				call update_display 
6d9f			 
6d9f				; prompt before entering montior for investigating issue 
6d9f			 
6d9f 3e 78			ld a, display_row_4 
6da1 11 81 1c			ld de, endprog 
6da4			 
6da4 cd 3b 0d			call update_display		 
6da7			 
6da7 cd df 1e			call next_page_prompt 
6daa			 
6daa d1				pop de 
6dab e1				pop hl 
6dac cd d5 1c				call monitor 
6daf c3 cc 1b				jp warmstart 
6db2					;jp 0 
6db2					;halt 
6db2			 
6db2			 
6db2			 
6db2 .. 00		.stackfault: 	db "Stack fault:",0 
6dbf			 
6dbf .. 00		sfaultsu: 	db	"Stack under flow",0 
6dd0 .. 00		sfaultso: 	db	"Stack over flow",0 
6de0 .. 00		sfaultru:	db "RTS underflow",0 
6dee .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6e08 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6e22 .. 00		sfaultdo:	db "DTS overflow", 0 
6e2f			 
6e2f			 
6e2f			fault_dsp_under: 
6e2f 11 41 6e			ld de, .dsp_under 
6e32 c3 f1 6e			jp .show_fault 
6e35			 
6e35			fault_rsp_under: 
6e35 11 4f 6e			ld de, .rsp_under 
6e38 c3 f1 6e			jp .show_fault 
6e3b			fault_loop_under: 
6e3b 11 5d 6e			ld de, .loop_under 
6e3e c3 f1 6e			jp .show_fault 
6e41			 
6e41 .. 00		.dsp_under: db "DSP Underflow",0 
6e4f .. 00		.rsp_under: db "RSP Underflow",0 
6e5d .. 00		.loop_under: db "LOOP Underflow",0 
6e6c			 
6e6c			 
6e6c d5			type_faultn: 	push de 
6e6d e5					push hl 
6e6e cd 18 0d				call clear_display 
6e71 11 98 6e				   ld de, .typefaultn 
6e74 3e 00				ld a, display_row_1 
6e76 cd 2b 0d				call str_at_display 
6e79 11 6e fe				    ld de, debug_mark 
6e7c 3e 11				ld a, display_row_1+17 
6e7e cd 2b 0d				call str_at_display 
6e81 cd 3b 0d				call update_display 
6e84			 
6e84				; prompt before entering montior for investigating issue 
6e84			 
6e84 3e 78			ld a, display_row_4 
6e86 11 81 1c			ld de, endprog 
6e89			 
6e89 cd 3b 0d			call update_display		 
6e8c			 
6e8c cd df 1e			call next_page_prompt 
6e8f			 
6e8f e5					push hl 
6e90 d5					push de 
6e91 cd d5 1c				call monitor 
6e94 c3 cc 1b				jp warmstart 
6e97 76					halt 
6e98			 
6e98			 
6e98 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6eaf			 
6eaf d5			type_faults: 	push de 
6eb0 e5					push hl 
6eb1 cd 18 0d				call clear_display 
6eb4 11 da 6e				   ld de, .typefaults 
6eb7 3e 00				ld a, display_row_1 
6eb9 cd 2b 0d				call str_at_display 
6ebc 11 6e fe				    ld de, debug_mark 
6ebf 3e 11				ld a, display_row_1+17 
6ec1 cd 2b 0d				call str_at_display 
6ec4 cd 3b 0d				call update_display 
6ec7			 
6ec7				; prompt before entering montior for investigating issue 
6ec7			 
6ec7 3e 78			ld a, display_row_4 
6ec9 11 81 1c			ld de, endprog 
6ecc			 
6ecc cd 3b 0d			call update_display		 
6ecf			 
6ecf cd df 1e			call next_page_prompt 
6ed2			 
6ed2 e1					pop hl 
6ed3 d1					pop de 
6ed4 cd d5 1c				call monitor 
6ed7 c3 cc 1b				jp warmstart 
6eda			 
6eda			 
6eda .. 00		.typefaults: db "STR Type Expected TOS!",0 
6ef1			 
6ef1			.show_fault: 	 
6ef1 d5					push de 
6ef2 cd 18 0d				call clear_display 
6ef5 d1					pop de 
6ef6 3e 00				ld a, display_row_1 
6ef8 cd 2b 0d				call str_at_display 
6efb 11 6e fe				    ld de, debug_mark 
6efe 3e 11				ld a, display_row_1+17 
6f00 cd 2b 0d				call str_at_display 
6f03 cd 3b 0d				call update_display 
6f06			 
6f06				; prompt before entering montior for investigating issue 
6f06			 
6f06 3e 78			ld a, display_row_4 
6f08 11 81 1c			ld de, endprog 
6f0b			 
6f0b cd 3b 0d			call update_display		 
6f0e			 
6f0e cd df 1e			call next_page_prompt 
6f11			 
6f11 e1					pop hl 
6f12 d1					pop de 
6f13 cd d5 1c				call monitor 
6f16			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6f16			; TODO Make optional fault restart to cli or warm boot? 
6f16					;jp warmstart 
6f16 c3 27 1c				jp cli 
6f19 76					halt 
6f1a			 
6f1a			; handle the auto run of code from files in storage 
6f1a			 
6f1a			 
6f1a			if STORAGE_SE 
6f1a			 
6f1a .. 00		sprompt3: db "Loading from start-up file?:",0 
6f37 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6f48			 
6f48			 
6f48			forth_autoload: 
6f48			 
6f48				; load block 0 of store 1 
6f48				 
6f48 3e fe			ld a, $fe      ; bit 0 clear 
6f4a 32 67 fa			ld (spi_device), a 
6f4d			 
6f4d cd cd 04			call storage_get_block_0 
6f50			 
6f50 3a a2 fa			ld a, (store_page+STORE_0_AUTOFILE) 
6f53			 
6f53 fe 00			cp 0 
6f55 c8				ret z     ; auto start not enabled 
6f56			 
6f56 cd 18 0d			call clear_display 
6f59			 
6f59				; set bank 
6f59			 
6f59 3a a4 fa				ld a, (store_page+STORE_0_BANKRUN) 
6f5c 32 67 fa				ld (spi_device), a 
6f5f			 
6f5f				; get file id to load from and get the file name to display 
6f5f			 
6f5f 3a a5 fa				ld a, (store_page+STORE_0_FILERUN) 
6f62			 
6f62 2e 00				ld l, 0 
6f64 67					ld h, a 
6f65 11 81 fa				ld de, store_page 
6f68			 
6f68					if DEBUG_FORTH_WORDS 
6f68						DMARK "ASp" 
6f68 f5				push af  
6f69 3a 7d 6f			ld a, (.dmark)  
6f6c 32 6e fe			ld (debug_mark),a  
6f6f 3a 7e 6f			ld a, (.dmark+1)  
6f72 32 6f fe			ld (debug_mark+1),a  
6f75 3a 7f 6f			ld a, (.dmark+2)  
6f78 32 70 fe			ld (debug_mark+2),a  
6f7b 18 03			jr .pastdmark  
6f7d ..			.dmark: db "ASp"  
6f80 f1			.pastdmark: pop af  
6f81			endm  
# End of macro DMARK
6f81						CALLMONITOR 
6f81 cd f3 18			call break_point_state  
6f84				endm  
# End of macro CALLMONITOR
6f84					endif 
6f84 cd 75 09				call storage_read 
6f87			 
6f87					if DEBUG_FORTH_WORDS 
6f87						DMARK "ASr" 
6f87 f5				push af  
6f88 3a 9c 6f			ld a, (.dmark)  
6f8b 32 6e fe			ld (debug_mark),a  
6f8e 3a 9d 6f			ld a, (.dmark+1)  
6f91 32 6f fe			ld (debug_mark+1),a  
6f94 3a 9e 6f			ld a, (.dmark+2)  
6f97 32 70 fe			ld (debug_mark+2),a  
6f9a 18 03			jr .pastdmark  
6f9c ..			.dmark: db "ASr"  
6f9f f1			.pastdmark: pop af  
6fa0			endm  
# End of macro DMARK
6fa0						CALLMONITOR 
6fa0 cd f3 18			call break_point_state  
6fa3				endm  
# End of macro CALLMONITOR
6fa3					endif 
6fa3			 
6fa3 cd 75 0f				call ishlzero 
6fa6 c8					ret z             ; file not found 
6fa7			 
6fa7 3e 32				ld a, display_row_2 + 10 
6fa9 11 84 fa				ld de, store_page+3 
6fac cd 2b 0d				call str_at_display 
6faf				 
6faf			; 
6faf			 
6faf 3e 05			ld a, display_row_1+5 
6fb1 11 1a 6f			ld de, sprompt3 
6fb4 cd 2b 0d			call str_at_display 
6fb7 3e 5f			ld a, display_row_3+15 
6fb9 11 37 6f			ld de, sprompt4 
6fbc cd 2b 0d			call str_at_display 
6fbf			 
6fbf cd 3b 0d			call update_display 
6fc2			 
6fc2 cd a9 73			call cin_wait 
6fc5 fe 6e			cp 'n' 
6fc7 c8				ret z 
6fc8 fe 4e			cp 'N' 
6fca c8				ret z 
6fcb			 
6fcb cd 95 0c			call delay1s 
6fce			 
6fce 3a 83 fa			ld a, (store_page+2) 
6fd1 32 70 fa			ld (store_openmaxext), a    ; save count of ext 
6fd4 3e 01			ld a, 1  
6fd6 32 71 fa			ld (store_openext), a    ; save count of ext 
6fd9			 
6fd9			.autof:  
6fd9 6f				ld l , a 
6fda				 
6fda 3a 81 fa			ld a, (store_page) 
6fdd 67				ld h, a	 
6fde 11 81 fa			ld de, store_page 
6fe1					if DEBUG_FORTH_WORDS 
6fe1						DMARK "ASl" 
6fe1 f5				push af  
6fe2 3a f6 6f			ld a, (.dmark)  
6fe5 32 6e fe			ld (debug_mark),a  
6fe8 3a f7 6f			ld a, (.dmark+1)  
6feb 32 6f fe			ld (debug_mark+1),a  
6fee 3a f8 6f			ld a, (.dmark+2)  
6ff1 32 70 fe			ld (debug_mark+2),a  
6ff4 18 03			jr .pastdmark  
6ff6 ..			.dmark: db "ASl"  
6ff9 f1			.pastdmark: pop af  
6ffa			endm  
# End of macro DMARK
6ffa						CALLMONITOR 
6ffa cd f3 18			call break_point_state  
6ffd				endm  
# End of macro CALLMONITOR
6ffd					endif 
6ffd cd 75 09				call storage_read 
7000 cd 75 0f			call ishlzero 
7003 c8				ret z 
7004			;	jr z, .autoend 
7004			 
7004					if DEBUG_FORTH_WORDS 
7004						DMARK "ASc" 
7004 f5				push af  
7005 3a 19 70			ld a, (.dmark)  
7008 32 6e fe			ld (debug_mark),a  
700b 3a 1a 70			ld a, (.dmark+1)  
700e 32 6f fe			ld (debug_mark+1),a  
7011 3a 1b 70			ld a, (.dmark+2)  
7014 32 70 fe			ld (debug_mark+2),a  
7017 18 03			jr .pastdmark  
7019 ..			.dmark: db "ASc"  
701c f1			.pastdmark: pop af  
701d			endm  
# End of macro DMARK
701d						CALLMONITOR 
701d cd f3 18			call break_point_state  
7020				endm  
# End of macro CALLMONITOR
7020					endif 
7020 11 83 fa			ld de, store_page+2 
7023 3e 78			ld a, display_row_4 
7025 cd 2b 0d			call str_at_display 
7028			 
7028 cd 3b 0d			call update_display 
702b cd 89 0c			call delay250ms 
702e			 
702e			 
702e			 
702e 21 83 fa			ld hl, store_page+2 
7031 cd 5b 23			call forthparse 
7034 cd 9b 23			call forthexec 
7037 cd ad 22			call forthexec_cleanup 
703a			 
703a				 
703a 3a 71 fa			ld a, (store_openext) 
703d 3c				inc a 
703e 32 71 fa			ld (store_openext), a    ; save count of ext 
7041			 
7041 18 96			jr .autof 
7043			;.autofdone: 
7043			; 
7043			;		if DEBUG_FORTH_WORDS 
7043			;			DMARK "ASx" 
7043			;			CALLMONITOR 
7043			;		endif 
7043			;;	call clear_display 
7043			;	ret 
7043			 
7043			 
7043			 
7043			endif 
7043			 
7043			 
7043			; eof 
# End of file forth_kernel.asm
7043			;include "nascombasic.asm" 
7043			 
7043			 
7043			; find out where the code ends if loaded into RAM (for SC114) 
7043			;endofcode:  
7043			;	nop 
7043			 
7043			 
7043			; eof 
7043			 
# End of file main.asm
7043			include "firmware_lcd_4x40.asm" 
7043			; **********************************************************************  
7043			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
7043			; **********************************************************************  
7043			;  
7043			; **  Written as a Small Computer Monitor App  
7043			; **  www.scc.me.uk  
7043			;  
7043			; History  
7043			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
7043			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
7043			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
7043			;  
7043			; **********************************************************************  
7043			;  
7043			; This program is an example of one of the methods of interfacing an   
7043			; alphanumeric LCD module.   
7043			;  
7043			; In this example the display is connected to either a Z80 PIO or a   
7043			; simple 8-bit output port.   
7043			;  
7043			; This interfacing method uses 4-bit data mode and uses time delays  
7043			; rather than polling the display's ready status. As a result the   
7043			; interface only requires 6 simple output lines:  
7043			;   Output bit 0 = not used  
7043			;   Output bit 1 = not used  
7043			;   Output bit 2 = RS         High = data, Low = instruction  
7043			;   Output bit 3 = E          Active high  
7043			;   Output bit 4 = DB4  
7043			;   Output bit 5 = DB5  
7043			;   Output bit 6 = DB6  
7043			;   Output bit 7 = DB7  
7043			; Display's R/W is connected to 0v so it is always in write mode  
7043			;  
7043			; This set up should work with any system supporting the RC2014 bus  
7043			  
7043			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
7043			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
7043			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
7043			;  
7043			; **********************************************************************  
7043			  
7043			; Additonal for 4x40. E1 and E2 instead of just E   
7043			; TODO swipe vidout signal on port a to activate E2  
7043			  
7043			; **********************************************************************  
7043			; **  Constants  
7043			; **********************************************************************  
7043			; LCD constants required by LCD support module  
7043			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
7043			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
7043			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
7043			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
7043			; TODO Decide which E is being set  
7043			kLCDWidth:  EQU display_cols             ;Width in characters  
7043			  
7043			; **********************************************************************  
7043			; **  Code library usage  
7043			; **********************************************************************  
7043			  
7043			; send character to current cursor position  
7043			; wraps and/or scrolls screen automatically  
7043			  
7043			  
7043			  
7043			lcd_init:  
7043			  
7043			; SCMonAPI functions used  
7043			  
7043			; Alphanumeric LCD functions used  
7043			; no need to specify specific functions for this module  
7043			  
7043 3e cf		            LD   A, 11001111b  
7045 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7047 3e 00		            LD   A, 00000000b  
7049 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
704b			  
704b			; Initialise alphanumeric LCD module  
704b 3e 00				ld a, 0  
704d 32 ce fb				ld (display_lcde1e2), a  
7050 cd d1 70		            CALL fLCD_Init      ;Initialise LCD module  
7053 3e 01				ld a, 1  
7055 32 ce fb				ld (display_lcde1e2), a  
7058 cd d1 70		            CALL fLCD_Init      ;Initialise LCD module  
705b			  
705b c9				ret  
705c			  
705c			;  
705c			;;  
705c			; lcd functions  
705c			;  
705c			;  
705c			  
705c			; what is at cursor position   
705c			  
705c			;get_cursor:	ld de, (cursor_row)   ;  row + col  
705c			;		call curptr  
705c			;		ret  
705c			  
705c			  
705c			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
705c			  
705c			curptr:  
705c c5				push bc  
705d 21 b4 fd			ld hl, display_fb0  
7060			cpr:	  
7060				; loop for cursor whole row  
7060 0e 28			ld c, display_cols  
7062 23			cpr1:	inc hl  
7063 0d				dec c  
7064 20 fc			jr nz, cpr1  
7066 05				dec b  
7067 20 f7			jr nz, cpr  
7069			  
7069				; add col	  
7069			  
7069 23			cpr2:	inc hl  
706a 1d				dec e  
706b 20 fc			jr nz, cpr2  
706d			  
706d c1				pop bc  
706e c9				ret  
706f				  
706f			  
706f			  
706f			  
706f			  
706f			; write the frame buffer given in hl to hardware   
706f 22 cc fb		write_display: ld (display_write_tmp), hl 	   
7072 3e 00			ld a, kLCD_Line1  
7074 cd 7e 71		            CALL fLCD_Pos       ;Position cursor to location in A  
7077 06 28			ld b, display_cols  
7079 ed 5b cc fb		ld de, (display_write_tmp)  
707d cd c9 70			call write_len_string  
7080				  
7080				  
7080 2a cc fb			ld hl, (display_write_tmp)  
7083 11 28 00			ld de, display_cols  
7086 19				add hl,de  
7087 22 cc fb			ld (display_write_tmp),hl  
708a			  
708a				  
708a 3e 28			ld a, kLCD_Line2  
708c cd 7e 71		            CALL fLCD_Pos       ;Position cursor to location in A  
708f 06 28			ld b, display_cols  
7091 ed 5b cc fb		ld de, (display_write_tmp)  
7095 cd c9 70			call write_len_string  
7098				  
7098 2a cc fb			ld hl, (display_write_tmp)  
709b 11 28 00			ld de, display_cols  
709e 19				add hl,de  
709f 22 cc fb			ld (display_write_tmp),hl  
70a2			  
70a2				  
70a2 3e 50			ld a, kLCD_Line3  
70a4 cd 7e 71		            CALL fLCD_Pos       ;Position cursor to location in A  
70a7 06 28			ld b, display_cols  
70a9 ed 5b cc fb		ld de, (display_write_tmp)  
70ad cd c9 70			call write_len_string  
70b0				  
70b0 2a cc fb			ld hl, (display_write_tmp)  
70b3 11 28 00			ld de, display_cols  
70b6 19				add hl,de  
70b7 22 cc fb			ld (display_write_tmp),hl  
70ba			  
70ba				  
70ba 3e 78			ld a, kLCD_Line4  
70bc cd 7e 71		            CALL fLCD_Pos       ;Position cursor to location in A  
70bf 06 28			ld b, display_cols  
70c1 ed 5b cc fb		ld de, (display_write_tmp)  
70c5 cd c9 70			call write_len_string  
70c8 c9					ret  
70c9				  
70c9				; write out a fixed length string given in b from de  
70c9			  
70c9 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
70ca cd 36 71		            CALL fLCD_Data      ;Write character to display  
70cd 13				inc de  
70ce 10 f9			djnz write_len_string  
70d0 c9				ret  
70d1			  
70d1			; Some other things to do  
70d1			;            LD   A, kLCD_Clear ;Display clear  
70d1			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
70d1			;            LD   A, kLCD_Under ;Display on with underscore cursor  
70d1			;            LD   A, kLCD_On     ;Display on with no cursor  
70d1			;            ;LD   A, kLCD_Off   ;Display off  
70d1			;            CALL fLCD_Inst      ;Send instruction to display  
70d1			;  
70d1			;  
70d1			;            halt  
70d1			;  
70d1			;  
70d1			;MsgHello:   DB  "Hello World!",0  
70d1			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
70d1			  
70d1			; Custom characters 5 pixels wide by 8 pixels high  
70d1			; Up to 8 custom characters can be defined  
70d1			;BitMaps:      
70d1			;; Character 0x00 = Battery icon  
70d1			;            DB  01110b  
70d1			;            DB  11011b  
70d1			;            DB  10001b  
70d1			;            DB  10001b  
70d1			;            DB  11111b  
70d1			;            DB  11111b  
70d1			;            DB  11111b  
70d1			;            DB  11111b  
70d1			;; Character 0x01 = Bluetooth icon  
70d1			;            DB  01100b  
70d1			;            DB  01010b  
70d1			;            DB  11100b  
70d1			;            DB  01000b  
70d1			;            DB  11100b  
70d1			;            DB  01010b  
70d1			;            DB  01100b  
70d1			;            DB  00000b  
70d1			;  
70d1			  
70d1			  
70d1			; **********************************************************************  
70d1			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
70d1			; **********************************************************************  
70d1			;  
70d1			; **  Written as a Small Computer Monitor App   
70d1			; **  Version 0.1 SCC 2018-05-16  
70d1			; **  www.scc.me.uk  
70d1			;  
70d1			; **********************************************************************  
70d1			;  
70d1			; This module provides support for alphanumeric LCD modules using with  
70d1			; *  HD44780 (or compatible) controller  
70d1			; *  5 x 7 pixel fonts  
70d1			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
70d1			; *  Interface via six digital outputs to the display (see below)  
70d1			;  
70d1			; LCD module pinout:  
70d1			;   1  Vss   0v supply  
70d1			;   2  Vdd   5v supply  
70d1			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
70d1			;   4  RS    High = data, Low = instruction  
70d1			;   5  R/W   High = Read, Low = Write  
70d1			;   6  E     Enable signal (active high)  
70d1			;   7  DB0   Data bit 0  
70d1			;   8  DB1   Data bit 1  
70d1			;   9  DB2   Data bit 2  
70d1			;  10  DB3   Data bit 3  
70d1			;  11  DB4   Data bit 4  
70d1			;  12  DB5   Data bit 5  
70d1			;  13  DB6   Data bit 6  
70d1			;  14  DB7   Data bit 7  
70d1			;  15  A     Backlight anode (+)  
70d1			;  16  K     Backlight cathode (-)  
70d1			;  
70d1			; This interfacing method uses 4-bit data mode and uses time delays  
70d1			; rather than polling the display's ready status. As a result the   
70d1			; interface only requires 6 simple output lines:  
70d1			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
70d1			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
70d1			;   LCD DB4 = Microcomputer output port bit 4  
70d1			;   LCD DB5 = Microcomputer output port bit 5  
70d1			;   LCD DB6 = Microcomputer output port bit 6  
70d1			;   LCD DB7 = Microcomputer output port bit 7  
70d1			; Display's R/W is connected to 0v so it is always in write mode  
70d1			; All 6 connections must be on the same port address <kLCDPrt>  
70d1			; This method also allows a decent length of cable from micro to LCD  
70d1			;  
70d1			; **********************************************************************  
70d1			;  
70d1			; To include the code for any given function provided by this module,   
70d1			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
70d1			; the parent source file.  
70d1			; For example:  #REQUIRES   uHexPrefix  
70d1			;  
70d1			; Also #INCLUDE this file at some point after the #REQUIRES statements  
70d1			; in the parent source file.  
70d1			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
70d1			;  
70d1			; These are the function names provided by this module:  
70d1			; fLCD_Init                     ;Initialise LCD  
70d1			; fLCD_Inst                     ;Send instruction to LCD  
70d1			; fLCD_Data                     ;Send data byte to LCD  
70d1			; fLCD_Pos                      ;Position cursor  
70d1			; fLCD_Str                      ;Display string  
70d1			; fLCD_Def                      ;Define custom character  
70d1			;  
70d1			; **********************************************************************  
70d1			;  
70d1			; Requires SCMonAPI.asm to also be included in the project  
70d1			;  
70d1			  
70d1			  
70d1			; **********************************************************************  
70d1			; **  Constants  
70d1			; **********************************************************************  
70d1			  
70d1			; Constants that must be defined externally  
70d1			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
70d1			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
70d1			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
70d1			;kLCDWidth: EQU 20             ;Width in characters  
70d1			  
70d1			; general line offsets in any frame buffer  
70d1			  
70d1			  
70d1			display_row_1: equ 0  
70d1			display_row_2: equ display_row_1+display_cols  
70d1			display_row_3: equ display_row_2 + display_cols  
70d1			display_row_4: equ display_row_3 + display_cols  
70d1			;display_row_4_eol:   
70d1			  
70d1			  
70d1			; Cursor position values for the start of each line  
70d1			  
70d1			; E  
70d1			kLCD_Line1: EQU 0x00   
70d1			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
70d1			; E1  
70d1			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
70d1			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
70d1			  
70d1			; Instructions to send as A register to fLCD_Inst  
70d1			kLCD_Clear: EQU 00000001b     ;LCD clear  
70d1			kLCD_Off:   EQU 00001000b     ;LCD off  
70d1			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
70d1			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
70d1			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
70d1			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
70d1			  
70d1			; Constants used by this code module  
70d1			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
70d1			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
70d1			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
70d1			  
70d1			  
70d1			  
70d1			; **********************************************************************  
70d1			; **  LCD support functions  
70d1			; **********************************************************************  
70d1			  
70d1			; Initialise alphanumeric LCD module  
70d1			; LCD control register codes:  
70d1			;   DL   0 = 4-bit mode        1 = 8-bit mode  
70d1			;   N    0 = 1-line mode       1 = 2-line mode  
70d1			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
70d1			;   D    0 = Display off       1 = Display on  
70d1			;   C    0 = Cursor off        1 = Cursor on  
70d1			;   B    0 = Blinking off      1 = Blinking on  
70d1			;   ID   0 = Decrement mode    1 = Increment mode  
70d1			;   SH   0 = Entire shift off  1 = Entire shift on  
70d1 3e 28		fLCD_Init:  LD   A, 40  
70d3 cd f8 71		            CALL LCDDelay       ;Delay 40ms after power up  
70d6			; For reliable reset set 8-bit mode - 3 times  
70d6 cd c8 71		            CALL WrFn8bit       ;Function = 8-bit mode  
70d9 cd c8 71		            CALL WrFn8bit       ;Function = 8-bit mode  
70dc cd c8 71		            CALL WrFn8bit       ;Function = 8-bit mode  
70df			; Set 4-bit mode  
70df cd c4 71		            CALL WrFn4bit       ;Function = 4-bit mode  
70e2 cd f6 71		            CALL LCDDelay1      ;Delay 37 us or more  
70e5			; Function set  
70e5 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
70e7 cd fa 70		            CALL fLCD_Inst      ;2 line, display on  
70ea			; Display On/Off control  
70ea 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
70ec cd fa 70		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
70ef			; Display Clear  
70ef 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
70f1 cd fa 70		            CALL fLCD_Inst      ;Clear display  
70f4			; Entry mode  
70f4 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
70f6 cd fa 70		            CALL fLCD_Inst      ;Increment mode, shift off  
70f9			; Display module now initialised  
70f9 c9			            RET  
70fa			; ok to here  
70fa			  
70fa			; Write instruction to LCD  
70fa			;   On entry: A = Instruction byte to be written  
70fa			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
70fa f5			fLCD_Inst:  PUSH AF  
70fb f5			            PUSH AF  
70fc cd 0e 71		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
70ff f1			            POP  AF  
7100 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7101 17			            RLA  
7102 17			            RLA  
7103 17			            RLA  
7104 cd 0e 71		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7107 3e 02		            LD   A, 2  
7109 cd f8 71		            CALL LCDDelay       ;Delay 2 ms to complete   
710c f1			            POP  AF  
710d c9			            RET  
710e			Wr4bits:   
710e f5					push af  
710f 3a ce fb				ld a, (display_lcde1e2)  
7112 fe 00				cp 0     ; e  
7114 20 10				jr nz, .wea2	  
7116 f1					pop af  
7117 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7119 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
711b cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
711d cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
711f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7121 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7123 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7125 c9			            RET  
7126 f1			.wea2:		pop af  
7127 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7129 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
712b cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
712d cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
712f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7131 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7133 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7135 c9			            RET  
7136			  
7136			  
7136			; Write data to LCD  
7136			;   On entry: A = Data byte to be written  
7136			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7136 f5			fLCD_Data:  PUSH AF  
7137 f5			            PUSH AF  
7138 cd 4a 71		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
713b f1			            POP  AF  
713c 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
713d 17			            RLA  
713e 17			            RLA  
713f 17			            RLA  
7140 cd 4a 71		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7143 3e 96		            LD   A, 150  
7145 3d			Wait:      DEC  A              ;Wait a while to allow data   
7146 20 fd		            JR   NZ, Wait      ;  write to complete  
7148 f1			            POP  AF  
7149 c9			            RET  
714a			Wr4bitsa:     
714a f5					push af  
714b 3a ce fb				ld a, (display_lcde1e2)  
714e fe 00				cp 0     ; e1  
7150 20 16				jr nz, .we2	  
7152 f1					pop af  
7153 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7155 cb d7		            SET  kLCDBitRS, A  
7157 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7159 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
715b cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
715d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
715f cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7161 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7163 cb 97		            RES  kLCDBitRS, A  
7165 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7167 c9			            RET  
7168 f1			.we2:		pop af  
7169 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
716b cb d7		            SET  kLCDBitRS, A  
716d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
716f cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7171 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7173 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7175 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7177 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7179 cb 97		            RES  kLCDBitRS, A  
717b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
717d c9			            RET  
717e			  
717e			  
717e			; Position cursor to specified location  
717e			;   On entry: A = Cursor position  
717e			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
717e f5			fLCD_Pos:   PUSH AF  
717f					; at this point set the E1 or E2 flag depending on position  
717f			  
717f c5					push bc  
7180			;		push af  
7180 06 00				ld b, 0  
7182 4f					ld c, a  
7183 3e 4f				ld a, kLCD_Line3-1  
7185 b7			 		or a      ;clear carry flag  
7186 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
7187 38 04				jr c, .pe1  
7189			  
7189					; E selection  
7189 cb 80				res 0, b         ; bit 0 unset e  
718b			;		pop af    ; before line 3 so recover orig pos  
718b			;		ld c, a    ; save for poking back  
718b 18 06				jr .peset	          
718d			.pe1:          	; E2 selection  
718d cb c0				set 0, b         ; bit 0 set e1  
718f 79					ld a, c  
7190 de 4f				sbc a, kLCD_Line3-1  
7192 4f					ld c, a	         ; save caculated offset  
7193			;		pop af     ; bin this original value now we have calculated form  
7193			  
7193			.peset:		; set bit  
7193 78					ld a, b  
7194 32 ce fb				ld (display_lcde1e2), a 	  
7197 79					ld a, c  
7198 c1					pop bc  
7199			  
7199 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
719b cd fa 70		            CALL fLCD_Inst      ;Write instruction to LCD  
719e f1			            POP  AF  
719f c9			            RET  
71a0			  
71a0			  
71a0			; Output text string to LCD  
71a0			;   On entry: DE = Pointer to null terminated text string  
71a0			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
71a0 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
71a1 b7			            OR   A              ;Null terminator?  
71a2 c8			            RET  Z              ;Yes, so finished  
71a3 cd 36 71		            CALL fLCD_Data      ;Write character to display  
71a6 13			            INC  DE             ;Point to next character  
71a7 18 f7		            JR   fLCD_Str       ;Repeat  
71a9 c9					ret  
71aa			  
71aa			; Define custom character  
71aa			;   On entry: A = Character number (0 to 7)  
71aa			;             DE = Pointer to character bitmap data  
71aa			;   On exit:  A = Next character number  
71aa			;             DE = Next location following bitmap  
71aa			;             BC HL IX IY I AF' BC' DE' HL' preserved  
71aa			; Character is   
71aa c5			fLCD_Def:   PUSH BC  
71ab f5			            PUSH AF  
71ac 07			            RLCA                ;Calculate location  
71ad 07			            RLCA                ;  for bitmap data  
71ae 07			            RLCA                ;  = 8 x CharacterNumber  
71af f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
71b1 cd fa 70		            CALL fLCD_Inst      ;Write instruction to LCD  
71b4 06 00		            LD   B, 0  
71b6 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
71b7 cd 36 71		            CALL fLCD_Data      ;Write byte to display  
71ba 13			            INC  DE             ;Point to next byte  
71bb 04			            INC  B              ;Count bytes  
71bc cb 58		            BIT  3, B           ;Finish all 8 bytes?  
71be 28 f6		            JR   Z, Loop       ;No, so repeat  
71c0 f1			            POP  AF  
71c1 3c			            INC  A              ;Increment character number  
71c2 c1			            POP  BC  
71c3 c9			            RET  
71c4			  
71c4			  
71c4			; **********************************************************************  
71c4			; **  Private functions  
71c4			; **********************************************************************  
71c4			  
71c4			; Write function to LCD  
71c4			;   On entry: A = Function byte to be written  
71c4			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
71c4 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
71c6 18 02		            JR   WrFunc  
71c8 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
71ca f5			WrFunc:     PUSH AF  
71cb f5					push af  
71cc 3a ce fb				ld a, (display_lcde1e2)  
71cf fe 00				cp 0     ; e1  
71d1 20 0f				jr nz, .wfea2	  
71d3 f1					pop af  
71d4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
71d6 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
71d8 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
71da d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
71dc cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
71de d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
71e0 18 0d			jr .wfskip  
71e2 f1			.wfea2:		pop af  
71e3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
71e5 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
71e7 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
71e9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
71eb cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
71ed d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
71ef 3e 05		.wfskip:            LD  A, 5  
71f1 cd f8 71		            CALL LCDDelay       ;Delay 5 ms to complete  
71f4 f1			            POP  AF  
71f5 c9			            RET  
71f6			  
71f6			  
71f6			; Delay in milliseconds  
71f6			;   On entry: A = Number of milliseconds delay  
71f6			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
71f6 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
71f8 d5			LCDDelay:   PUSH DE  
71f9 5f			            LD   E, A           ;Delay by 'A' ms  
71fa 16 00		            LD   D, 0  
71fc cd 7a 0c		            CALL aDelayInMS  
71ff d1			            POP  DE  
7200 c9			            RET  
7201			  
7201			  
7201			testlcd:  
7201 3e 00			ld a, kLCD_Line1  
7203 cd 7e 71			call fLCD_Pos  
7206 06 28			ld b, 40  
7208 11 36 72			ld de, .ttext1  
720b cd c9 70			call write_len_string  
720e			  
720e 3e 28			ld a, kLCD_Line2  
7210 cd 7e 71			call fLCD_Pos  
7213 06 28			ld b, 40  
7215 11 5f 72			ld de, .ttext2  
7218 cd c9 70			call write_len_string  
721b 3e 50			ld a, kLCD_Line3  
721d cd 7e 71			call fLCD_Pos  
7220 06 28			ld b, 40  
7222 11 88 72			ld de, .ttext3  
7225 cd c9 70			call write_len_string  
7228 3e 78			ld a, kLCD_Line4  
722a cd 7e 71			call fLCD_Pos  
722d 06 28			ld b, 40  
722f 11 b1 72			ld de, .ttext4  
7232 cd c9 70			call write_len_string  
7235			  
7235 76				halt  
7236			  
7236			  
7236 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
725f .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
7288 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
72b1 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
72da			   
72da			  
72da			  
72da			; eof  
72da			  
# End of file firmware_lcd_4x40.asm
72da			;include "firmware_lcd_4x20.asm" 
72da			include "firmware_key_5x10.asm" 
72da			; 5 x 10 decade counter scanner  
72da			  
72da			  
72da			; TODO do cursor shape change for shift keys  
72da			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
72da			  
72da			  
72da			; bit mask for each scan column and row for teing the matrix  
72da			  
72da			  
72da			key_init:  
72da			  
72da			; SCMonAPI functions used  
72da			  
72da			; Alphanumeric LCD functions used  
72da			; no need to specify specific functions for this module  
72da			  
72da			  
72da 3e cf		            LD   A, 11001111b  
72dc d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
72de			;            LD   A, 00000000b  
72de 3e 1f		            LD   A, 00011111b  
72e0 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
72e2			  
72e2			  
72e2				; TODO Configure cursor shapes  
72e2			  
72e2				; Load cursor shapes   
72e2 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
72e4 11 f4 72		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
72e7 06 02		            LD   B, 2           ;Number of characters to define  
72e9 cd aa 71		.DefLoop:   CALL fLCD_Def       ;Define custom character  
72ec 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
72ee			  
72ee 3e 01				ld a, 1  
72f0 32 c7 fb			ld (cursor_shape),a  
72f3 c9				ret  
72f4			  
72f4			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
72f4			; Up to 8 custom characters can be defined  
72f4			.cursor_shapes:      
72f4			;; Character 0x00 = Normal  
72f4 1f			            DB  11111b  
72f5 1f			            DB  11111b  
72f6 1f			            DB  11111b  
72f7 1f			            DB  11111b  
72f8 1f			            DB  11111b  
72f9 1f			            DB  11111b  
72fa 1f			            DB  11111b  
72fb 1f			            DB  11111b  
72fc			;; Character 0x01 = Modifier  
72fc 1f			            DB  11111b  
72fd 1b			            DB  11011b  
72fe 1b			            DB  11011b  
72ff 1b			            DB  11011b  
7300 1b			            DB  11011b  
7301 1f			            DB  11111b  
7302 1b			            DB  11011b  
7303 1f			            DB  11111b  
7304			  
7304			  
7304			  
7304			  
7304			; Display custom character 0  
7304			;            LD   A, kLCD_Line1+14  
7304			;            CALL fLCD_Pos       ;Position cursor to location in A  
7304			;            LD   A, 0  
7304			;            CALL fLCD_Data      ;Write character in A at cursor  
7304			  
7304			; Display custom character 1  
7304			;            LD   A, kLCD_Line2+14  
7304			;            CALL fLCD_Pos      ;Position cursor to location in A  
7304			;            LD   A, 1  
7304			;            CALL fLCD_Data     ;Write character in A at cursor  
7304			  
7304			; keyboard scanning   
7304			  
7304			; character in from keyboard  
7304			  
7304			; mapping for the pcb layout  
7304			  
7304			.matrix_to_char:  
7304 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
730f .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
731a 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7325 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7330 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
733b			.matrix_to_shift:  
733b			  
733b .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7346 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7351 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
735c 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7367 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7372			  
7372			.matrix_to_symbolshift:  
7372			  
7372 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
737d .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7388 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7393			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7393 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
739e .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
73a9			  
73a9			  
73a9			  
73a9			; mapping for a simple straight through breadboard layout  
73a9			  
73a9			;.matrix_to_char:  
73a9			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
73a9			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
73a9			;		db "asdfghjkl",KEY_CR,0  
73a9			;		db "qwertyuiop",0  
73a9			;		 db "1234567890",0  
73a9			;.matrix_to_shift:  
73a9			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
73a9			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
73a9			;		db "ASDFGHJKL",KEY_CR,0  
73a9			;		db "QWERTYUIOP",0  
73a9			;		 db "!",'"',"#$%^&*()",0  
73a9			;.matrix_to_symbolshift:  
73a9			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
73a9			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
73a9			;		db "_?*fghjk=",KEY_CR,0  
73a9			;		db "-/+*[]{}@#",0  
73a9			;		 db "1234567890",0  
73a9			  
73a9			;.matrix_to_char: db "D#0*C987B654A321"  
73a9			  
73a9			  
73a9				  
73a9			  
73a9			; add cin and cin_wait  
73a9			  
73a9 cd ba 73		cin_wait: 	call cin  
73ac						if DEBUG_KEYCINWAIT  
73ac							push af  
73ac							  
73ac							ld hl,key_repeat_ct  
73ac							ld (hl),a  
73ac							inc hl  
73ac							call hexout  
73ac							ld hl,key_repeat_ct+3  
73ac							ld a,0  
73ac							ld (hl),a  
73ac			  
73ac							    LD   A, kLCD_Line1+11  
73ac							    CALL fLCD_Pos       ;Position cursor to location in A  
73ac							    LD   DE, key_repeat_ct  
73ac							    ;LD   DE, MsgHello  
73ac							    CALL fLCD_Str       ;Display string pointed to by DE  
73ac			  
73ac			  
73ac			  
73ac							pop af  
73ac						endif  
73ac fe 00			cp 0  
73ae 28 f9			jr z, cin_wait   ; block until key press  
73b0			  
73b0							if DEBUG_KEYCINWAIT  
73b0								push af  
73b0			  
73b0								ld a, 'A'	  
73b0								ld hl,key_repeat_ct  
73b0								ld (hl),a  
73b0								inc hl  
73b0								ld a,0  
73b0								ld (hl),a  
73b0			  
73b0								    LD   A, kLCD_Line2+11  
73b0								    CALL fLCD_Pos       ;Position cursor to location in A  
73b0								    LD   DE, key_repeat_ct  
73b0								    ;LD   DE, MsgHello  
73b0								    CALL fLCD_Str       ;Display string pointed to by DE  
73b0			  
73b0							call delay500ms  
73b0			  
73b0								pop af  
73b0							endif  
73b0 f5				push af   ; save key pressed  
73b1			  
73b1			.cin_wait1:	  
73b1							if DEBUG_KEYCINWAIT  
73b1								push af  
73b1			  
73b1								ld a, 'b'	  
73b1								ld hl,key_repeat_ct  
73b1								ld (hl),a  
73b1								inc hl  
73b1								ld a,0  
73b1								ld (hl),a  
73b1			  
73b1								    LD   A, kLCD_Line2+11  
73b1								    CALL fLCD_Pos       ;Position cursor to location in A  
73b1								    LD   DE, key_repeat_ct  
73b1								    ;LD   DE, MsgHello  
73b1								    CALL fLCD_Str       ;Display string pointed to by DE  
73b1			  
73b1			  
73b1							call delay500ms  
73b1			  
73b1								pop af  
73b1							endif  
73b1			  
73b1 cd ba 73		call cin  
73b4 fe 00			cp 0  
73b6 20 f9			jr nz, .cin_wait1  	; wait for key release  
73b8			if DEBUG_KEYCINWAIT  
73b8				push af  
73b8			  
73b8				ld a, '3'	  
73b8				ld hl,key_repeat_ct  
73b8				ld (hl),a  
73b8				inc hl  
73b8				ld a,0  
73b8				ld (hl),a  
73b8			  
73b8			            LD   A, kLCD_Line2+11  
73b8			            CALL fLCD_Pos       ;Position cursor to location in A  
73b8			            LD   DE, key_repeat_ct  
73b8			            ;LD   DE, MsgHello  
73b8			            CALL fLCD_Str       ;Display string pointed to by DE  
73b8			  
73b8			  
73b8			call delay500ms  
73b8			  
73b8				pop af  
73b8			endif  
73b8			  
73b8 f1				pop af   ; get key  
73b9 c9				ret  
73ba			  
73ba			  
73ba cd ce 73		cin: 	call .mtoc  
73bd			  
73bd			if DEBUG_KEYCIN  
73bd				push af  
73bd				  
73bd				ld hl,key_repeat_ct  
73bd				ld (hl),a  
73bd				inc hl  
73bd				call hexout  
73bd				ld hl,key_repeat_ct+3  
73bd				ld a,0  
73bd				ld (hl),a  
73bd			  
73bd			            LD   A, kLCD_Line3+15  
73bd			            CALL fLCD_Pos       ;Position cursor to location in A  
73bd			            LD   DE, key_repeat_ct  
73bd			            ;LD   DE, MsgHello  
73bd			            CALL fLCD_Str       ;Display string pointed to by DE  
73bd			  
73bd			  
73bd			call delay500ms  
73bd			  
73bd				pop af  
73bd			endif  
73bd			  
73bd			  
73bd				; no key held  
73bd fe 00			cp 0  
73bf c8				ret z  
73c0			  
73c0			if DEBUG_KEYCIN  
73c0				push af  
73c0			  
73c0				ld a, '1'	  
73c0				ld hl,key_repeat_ct  
73c0				ld (hl),a  
73c0				inc hl  
73c0				ld a,0  
73c0				ld (hl),a  
73c0			  
73c0			            LD   A, kLCD_Line4+15  
73c0			            CALL fLCD_Pos       ;Position cursor to location in A  
73c0			            LD   DE, key_repeat_ct  
73c0			            ;LD   DE, MsgHello  
73c0			            CALL fLCD_Str       ;Display string pointed to by DE  
73c0			  
73c0			  
73c0			call delay500ms  
73c0			  
73c0				pop af  
73c0			endif  
73c0			  
73c0				; stop key bounce  
73c0			  
73c0 32 88 fe			ld (key_held),a		 ; save it  
73c3 47				ld b, a  
73c4			  
73c4 c5			.cina1:	push bc  
73c5			if DEBUG_KEYCIN  
73c5				push af  
73c5			  
73c5				ld hl,key_repeat_ct  
73c5				inc hl  
73c5				call hexout  
73c5				ld hl,key_repeat_ct+3  
73c5				ld a,0  
73c5				ld (hl),a  
73c5				ld hl,key_repeat_ct  
73c5				ld a, '2'	  
73c5				ld (hl),a  
73c5			  
73c5			            LD   A, kLCD_Line4+15  
73c5			            CALL fLCD_Pos       ;Position cursor to location in A  
73c5			            LD   DE, key_repeat_ct  
73c5			            ;LD   DE, MsgHello  
73c5			            CALL fLCD_Str       ;Display string pointed to by DE  
73c5			  
73c5				pop af  
73c5			endif  
73c5 cd ce 73			call .mtoc  
73c8 c1				pop bc  
73c9 b8				cp b  
73ca 28 f8			jr z, .cina1  
73cc 78				ld a,b		  
73cd			if DEBUG_KEYCIN  
73cd				push af  
73cd			  
73cd				ld hl,key_repeat_ct  
73cd				inc hl  
73cd				call hexout  
73cd				ld hl,key_repeat_ct+3  
73cd				ld a,0  
73cd				ld (hl),a  
73cd				ld hl,key_repeat_ct  
73cd				ld a, '3'	  
73cd				ld (hl),a  
73cd			  
73cd			            LD   A, kLCD_Line4+15  
73cd			            CALL fLCD_Pos       ;Position cursor to location in A  
73cd			            LD   DE, key_repeat_ct  
73cd			            ;LD   DE, MsgHello  
73cd			            CALL fLCD_Str       ;Display string pointed to by DE  
73cd			  
73cd				pop af  
73cd			endif  
73cd c9				ret  
73ce			  
73ce			; detect keyboard modifier key press and apply new overlay to the face key held  
73ce			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
73ce			  
73ce			;.cin_map_modifier:   
73ce			;	ld a, (hl)  
73ce			;	and 255  
73ce			;	ret NZ		; modifier key not flagged  
73ce			;  
73ce			;	; get key face  
73ce			;  
73ce			;	ld b,(key_face_held)  
73ce			;  
73ce			;	ld b, key_cols * key_rows  
73ce			;  
73ce			;	push de  
73ce			;	pop hl  
73ce			;  
73ce			;.mmod1: ld a,(hl)   ; get map test  
73ce			;	cp b  
73ce			;	jr z, .mmod2  
73ce			;  
73ce			;  
73ce			;  
73ce			;.mmod2: inc hl    ;   
73ce			;  
73ce			;	  
73ce			;  
73ce			;	  
73ce			;  
73ce			;	ld hl,key_actual_pressed  
73ce			;	ld (hl),a,  
73ce			;	ret  
73ce			  
73ce			; map matrix key held to char on face of key  
73ce			  
73ce			.mtoc:  
73ce			  
73ce			; test decade counter strobes  
73ce			  
73ce			;.decadetest1:  
73ce			  
73ce			; reset counter  
73ce			;ld a, 128  
73ce			;out (portbdata),a  
73ce			  
73ce			  
73ce			;ld b, 5  
73ce			;.dec1:  
73ce			;ld a, 0  
73ce			;out (portbdata),a  
73ce			;call delay1s  
73ce			  
73ce			;ld a, 32  
73ce			;out (portbdata),a  
73ce			;call delay1s  
73ce			;call delay1s  
73ce			;call delay1s  
73ce			;  
73ce			;ld a, 64+32  
73ce			;out (portbdata),a  
73ce			;call delay1s  
73ce			;;djnz .dec1  
73ce			;  
73ce			;jp .decadetest1  
73ce			  
73ce			  
73ce			  
73ce			  
73ce			  
73ce			  
73ce			  
73ce			  
73ce			  
73ce			  
73ce				; scan keyboard matrix and generate raw scan map  
73ce cd 61 74			call matrix  
73d1			  
73d1				; reuse c bit 0 left modifer button - ie shift  
73d1			        ; reuse c bit 1 for right modifer button - ie symbol shift  
73d1				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
73d1			  
73d1 0e 00			ld c, 0  
73d3			  
73d3				; TODO set flags for modifer key presses   
73d3				; TODO do a search for modifer key...  
73d3			  
73d3				;ld hl,keyscan_table_row4  
73d3 21 e7 fe			ld hl,keyscan_table_row2  
73d6			  
73d6 7e				ld a, (hl)  
73d7 fe 23			cp '#'  
73d9 20 07			jr nz, .nextmodcheck  
73db cb c1			set 0, c  
73dd 21 3b 73			ld hl, .matrix_to_shift  
73e0 18 21			jr .dokeymap  
73e2				; TODO for now igonre  
73e2			.nextmodcheck:  
73e2 21 dc fe			ld hl,keyscan_table_row3  
73e5			  
73e5 7e				ld a, (hl)  
73e6 fe 23			cp '#'  
73e8 20 07			jr nz, .nextmodcheck2  
73ea cb c9			set 1, c   
73ec 21 72 73			ld hl, .matrix_to_symbolshift  
73ef 18 12			jr .dokeymap  
73f1			.nextmodcheck2:  
73f1 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
73f4			  
73f4 7e				ld a, (hl)  
73f5 fe 23			cp '#'  
73f7 20 07			jr nz, .donemodcheck  
73f9 cb c9			set 1, c   
73fb 21 3b 73			ld hl, .matrix_to_shift  
73fe 18 03			jr .dokeymap  
7400			  
7400				; no modifer found so just map to normal keys  
7400				; get mtoc map matrix to respective keys  
7400			;	ld hl, .matrix_to_char  
7400			;	ld hl, .matrix_to_char  
7400			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7400			;	ld a, KEY_SHIFT  
7400			;	call findchar  
7400			;  
7400			;	; got offset to key modifer in b  
7400			;  
7400			;	ld hl,keyscan_table_row5  
7400			;  
7400			;	ld a,b  
7400			;	call addatohl  
7400			;	ld a,(hl)  
7400			;  
7400			;	cp '#'  
7400			;	jr nz, .nextmodcheck  
7400			;	set 0, c  
7400			;	ld hl, .matrix_to_char  
7400			;	jr .dokeymap  
7400			;	; TODO for now igonre  
7400			;.nextmodcheck:  
7400			;	ld hl, .matrix_to_symbolshift  
7400			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7400			;	ld a, KEY_SYMBOLSHIFT  
7400			;	call findchar  
7400			;  
7400			;  
7400			;	; got offset to key modifer in b  
7400			;  
7400			;	ld hl,keyscan_table_row5  
7400			;  
7400			;	ld a,b  
7400			;	call addatohl  
7400			;	ld a,(hl)  
7400			;  
7400			;	cp '#'  
7400			;	jr nz, .donemodcheck  
7400			;	set 1, c   
7400			;	ld hl, .matrix_to_symbolshift  
7400			;	jr .dokeymap  
7400			  
7400			  
7400			  
7400			.donemodcheck:  
7400				; no modifer found so just map to normal keys  
7400				; get mtoc map matrix to respective keys  
7400 21 04 73			ld hl, .matrix_to_char  
7403			  
7403			.dokeymap:  
7403				;ld (key_fa), c   
7403 cd 1c 74			call .mapkeys  
7406			  
7406			  
7406			if DEBUG_KEY  
7406			  
7406			; Display text on first line  
7406			            LD   A, kLCD_Line1  
7406			            CALL fLCD_Pos       ;Position cursor to location in A  
7406			            LD   DE, keyscan_table_row1  
7406			            ;LD   DE, MsgHello  
7406			            CALL fLCD_Str       ;Display string pointed to by DE  
7406			  
7406			; Display text on second line  
7406			            LD   A, kLCD_Line2  
7406			            CALL fLCD_Pos       ;Position cursor to location in A  
7406			            LD   DE, keyscan_table_row2  
7406			            CALL fLCD_Str       ;Display string pointed to by DE  
7406			            LD   A, kLCD_Line3  
7406			            CALL fLCD_Pos       ;Position cursor to location in A  
7406			            LD   DE, keyscan_table_row3  
7406			            CALL fLCD_Str       ;Display string pointed to by DE  
7406			            LD   A, kLCD_Line4  
7406			            CALL fLCD_Pos       ;Position cursor to location in A  
7406			            LD   DE, keyscan_table_row4  
7406			            CALL fLCD_Str       ;Display string pointed to by DE  
7406			            LD   A, kLCD_Line1+10  
7406			            CALL fLCD_Pos       ;Position cursor to location in A  
7406			            LD   DE, keyscan_table_row5  
7406			            CALL fLCD_Str       ;Display string pointed to by DE  
7406			  
7406				;call delay250ms  
7406			endif  
7406			;	jp testkey  
7406			  
7406			; get first char reported  
7406			  
7406 21 c6 fe			ld hl,keyscan_table_row5  
7409			  
7409				;ld b, 46   ; 30 keys to remap + 8 nulls   
7409 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
740b			.findkey:  
740b 7e				ld a,(hl)  
740c fe 00			cp 0  
740e 28 04			jr z, .nextkey  
7410 fe 7e			cp KEY_MATRIX_NO_PRESS  
7412 20 06			jr nz, .foundkey  
7414			.nextkey:  
7414 23				inc hl  
7415 10 f4			djnz .findkey  
7417 3e 00			ld a,0  
7419 c9				ret  
741a			.foundkey:  
741a 7e				ld a,(hl)  
741b c9				ret  
741c				  
741c			  
741c			; convert the raw key map given hl for destination key  
741c			.mapkeys:  
741c 11 c6 fe			ld de,keyscan_table_row5  
741f			  
741f 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7421			.remap:  
7421 1a				ld a,(de)  
7422 fe 23			cp '#'  
7424 20 02			jr nz, .remapnext  
7426				;CALLMONITOR  
7426 7e				ld a,(hl)  
7427 12				ld (de),a  
7428			  
7428			  
7428			  
7428			.remapnext:  
7428 23				inc hl  
7429 13				inc de  
742a 10 f5			djnz .remap  
742c				  
742c c9				ret  
742d			  
742d			  
742d			  
742d			.mtocold2:  
742d			  
742d			;	; flag if key D is held down and remove from reporting  
742d			;	ld bc, .key_map_fd    
742d			;	ld hl, keyscan_table  
742d			;	ld de, key_fd  
742d			;	call .key_shift_hold  
742d			;	cp 255  
742d			;	jr z, .cinmap  
742d			;	; flag if key C is held down and remove from reporting  
742d			;	ld bc, .key_map_fc    
742d			;	ld hl, keyscan_table+key_cols  
742d			;	ld de, key_fc  
742d			;	call .key_shift_hold  
742d			;	cp 255  
742d			;	jr z, .cinmap  
742d			;	; flag if key B is held down and remove from reporting  
742d			;	ld bc, .key_map_fb    
742d			;	ld hl, keyscan_table+(key_cols*2)  
742d			;	ld de, key_fb  
742d			;	call .key_shift_hold  
742d			;	cp 255  
742d			;	jr z, .cinmap  
742d			;	; flag if key A is held down and remove from reporting  
742d			;	ld bc, .key_map_fa    
742d			;	ld hl, keyscan_table+(key_cols*3)  
742d			;	ld de, key_fa  
742d			;	call .key_shift_hold  
742d			;	cp 255  
742d			;	jr z, .cinmap  
742d			  
742d 11 04 73			ld de, .matrix_to_char  
7430			  
7430			  
7430			.cinmap1:   
7430				if DEBUG_KEY  
7430			            LD   A, kLCD_Line4  
7430			            CALL fLCD_Pos       ;Position cursor to location in A  
7430					push de  
7430			            LD   DE, keyscan_table  
7430			            CALL fLCD_Str       ;Display string pointed to by DE  
7430					pop de  
7430				endif  
7430			  
7430				; scan key matrix table for any held key  
7430			  
7430				; de holds either the default matrix or one selected above  
7430			  
7430 21 93 fe			ld hl, keyscan_table  
7433 06 32			ld b,key_cols*key_rows  
7435			  
7435 7e			.cin11:	ld a,(hl)  
7436 fe 23			cp '#'  
7438 28 08			jr z, .cinhit1  
743a 23				inc hl  
743b 13				inc de  
743c 05				dec b  
743d 20 f6			jr nz, .cin11  
743f				; no key found held  
743f 3e 00			ld a,0  
7441 c9				ret  
7442 d5			.cinhit1: push de  
7443 e1				pop hl  
7444 7e				ld a,(hl)  
7445 c9				ret  
7446			  
7446			; flag a control key is held   
7446			; hl is key pin, de is flag indicator  
7446			  
7446			.key_shift_hold1:  
7446 c5				push bc  
7447 3e 01			ld a, 1  
7449 32 c7 fb			ld (cursor_shape),a  
744c 06 00			ld b, 0  
744e 7e				ld a, (hl)  
744f fe 2e			cp '.'  
7451 28 0a			jr z, .key_shift11  
7453 06 ff			ld b, 255  
7455 3e 2b			ld a, '+'    ; hide key from later scans  
7457 77				ld (hl),a  
7458 3e 02			ld a, 2  
745a 32 c7 fb			ld (cursor_shape),a  
745d			.key_shift11:  
745d				; write flag indicator  
745d 78				ld a,b  
745e 12				ld (de),a  
745f			  
745f d1				pop de    ; de now holds the key map ptr  
7460 c9				ret  
7461			  
7461				  
7461			  
7461			; scans keyboard matrix and flags key press in memory array	  
7461				  
7461			matrix:  
7461				;call matrix  
7461				; TODO optimise the code....  
7461			  
7461			  
7461			;ld hl, keyscan_table_row1  
7461			;ld de, keyscan_table_row1+1  
7461			;ld bc,46  
7461			;ld a,KEY_MATRIX_NO_PRESS  
7461			;ldir  
7461			  
7461			  
7461			  
7461			; reset counter  
7461 3e 80		ld a, 128  
7463 d3 c1		out (portbdata),a  
7465			  
7465 06 0a		ld b, 10  
7467 0e 00		ld c, 0       ; current clock toggle  
7469			  
7469			.colscan:  
7469			  
7469			; set current column  
7469			; disable clock enable and set clock low  
7469			  
7469			;ld a, 0  
7469			;out (portbdata),a  
7469			  
7469			; For each column scan for switches  
7469			  
7469 c5			push bc  
746a 21 89 fe		ld hl, keyscan_scancol  
746d cd 76 75		call .rowscan  
7470 c1			pop bc  
7471			  
7471			  
7471			; get back current column  
7471			  
7471			; translate the row scan  
7471			  
7471			;   
7471			; row 1  
7471			  
7471 78			ld a,b  
7472			  
7472 21 fc fe		LD   hl, keyscan_table_row1+10  
7475			  
7475 cd 5e 0f		call subafromhl  
7478			;call addatohl  
7478			  
7478 11 89 fe		ld de, keyscan_scancol  
747b			  
747b 1a			ld a,(de)  
747c 77			ld (hl),a  
747d			  
747d			  
747d			  
747d			  
747d			; row 2  
747d			  
747d 78			ld a,b  
747e			  
747e 21 f1 fe		LD   hl, keyscan_table_row2+10  
7481			  
7481			;call addatohl  
7481 cd 5e 0f		call subafromhl  
7484			  
7484			  
7484 11 8a fe		ld de, keyscan_scancol+1  
7487			  
7487 1a			ld a,(de)  
7488 77			ld (hl),a  
7489			  
7489			  
7489			; row 3  
7489			  
7489 78			ld a,b  
748a			  
748a 21 e6 fe		LD   hl, keyscan_table_row3+10  
748d			  
748d			;call addatohl  
748d cd 5e 0f		call subafromhl  
7490			  
7490 11 8b fe		ld de, keyscan_scancol+2  
7493			  
7493 1a			ld a,(de)  
7494 77			ld (hl),a  
7495			  
7495			  
7495			  
7495			; row 4  
7495			  
7495 78			ld a,b  
7496			  
7496 21 db fe		LD   hl, keyscan_table_row4+10  
7499			  
7499			;call addatohl  
7499 cd 5e 0f		call subafromhl  
749c			  
749c 11 8c fe		ld de, keyscan_scancol+3  
749f			  
749f 1a			ld a,(de)  
74a0 77			ld (hl),a  
74a1			  
74a1			; row 5  
74a1			  
74a1 78			ld a,b  
74a2			  
74a2 21 d0 fe		LD   hl, keyscan_table_row5+10  
74a5			  
74a5			;call addatohl  
74a5 cd 5e 0f		call subafromhl  
74a8			  
74a8 11 8d fe		ld de, keyscan_scancol+4  
74ab			  
74ab 1a			ld a,(de)  
74ac 77			ld (hl),a  
74ad			  
74ad			; handshake next column  
74ad			  
74ad			  
74ad 3e 40		ld a, 64  
74af d3 c1		out (portbdata),a  
74b1			  
74b1 3e 00		ld a, 0  
74b3 d3 c1		out (portbdata),a  
74b5			  
74b5			; toggle clk and move to next column  
74b5			;ld a, 64  
74b5			;cp c  
74b5			;  
74b5			;jr z, .coltoglow  
74b5			;ld c, a  
74b5			;jr .coltog  
74b5			;.coltoglow:  
74b5			;ld c, 0  
74b5			;.coltog:  
74b5			;ld a, c  
74b5			;out (portbdata),a  
74b5			  
74b5 10 b2		djnz .colscan  
74b7			  
74b7 3e 0a		ld a,10  
74b9 21 f2 fe		LD   hl, keyscan_table_row1  
74bc cd 4c 0f		call addatohl  
74bf 3e 00		ld a, 0  
74c1 77			ld (hl), a  
74c2			  
74c2			  
74c2 3e 0a		ld a,10  
74c4 21 e7 fe		LD   hl, keyscan_table_row2  
74c7 cd 4c 0f		call addatohl  
74ca 3e 00		ld a, 0  
74cc 77			ld (hl), a  
74cd			  
74cd 3e 0a		ld a,10  
74cf 21 dc fe		LD   hl, keyscan_table_row3  
74d2 cd 4c 0f		call addatohl  
74d5 3e 00		ld a, 0  
74d7 77			ld (hl), a  
74d8			  
74d8 3e 0a		ld a,10  
74da 21 d1 fe		LD   hl, keyscan_table_row4  
74dd cd 4c 0f		call addatohl  
74e0 3e 00		ld a, 0  
74e2 77			ld (hl), a  
74e3			  
74e3 3e 0a		ld a,10  
74e5 21 c6 fe		LD   hl, keyscan_table_row5  
74e8 cd 4c 0f		call addatohl  
74eb 3e 00		ld a, 0  
74ed 77			ld (hl), a  
74ee			  
74ee			if DEBUG_KEY_MATRIX  
74ee			  
74ee			; Display text on first line  
74ee			            LD   A, kLCD_Line1  
74ee			            CALL fLCD_Pos       ;Position cursor to location in A  
74ee			            LD   DE, keyscan_table_row1  
74ee			            ;LD   DE, MsgHello  
74ee			            CALL fLCD_Str       ;Display string pointed to by DE  
74ee			  
74ee			; Display text on second line  
74ee			            LD   A, kLCD_Line2  
74ee			            CALL fLCD_Pos       ;Position cursor to location in A  
74ee			            LD   DE, keyscan_table_row2  
74ee			            CALL fLCD_Str       ;Display string pointed to by DE  
74ee			            LD   A, kLCD_Line3  
74ee			            CALL fLCD_Pos       ;Position cursor to location in A  
74ee			            LD   DE, keyscan_table_row3  
74ee			            CALL fLCD_Str       ;Display string pointed to by DE  
74ee			            LD   A, kLCD_Line4  
74ee			            CALL fLCD_Pos       ;Position cursor to location in A  
74ee			            LD   DE, keyscan_table_row4  
74ee			            CALL fLCD_Str       ;Display string pointed to by DE  
74ee			            LD   A, kLCD_Line4+10  
74ee			            CALL fLCD_Pos       ;Position cursor to location in A  
74ee			            LD   DE, keyscan_table_row5  
74ee			            CALL fLCD_Str       ;Display string pointed to by DE  
74ee			  
74ee			;call delay250ms  
74ee				jp matrix  
74ee			endif  
74ee c9			ret  
74ef			  
74ef			; using decade counter....  
74ef			  
74ef			  
74ef			; TODO reset decade counter to start of scan  
74ef			  
74ef			; reset 15  
74ef			; clock 14  
74ef			; ce 13  
74ef			  
74ef			; 1 - q5  
74ef			; 2 - q1  
74ef			; 3 - q0  
74ef			; 4 - q2  
74ef			; 5 - q6  
74ef			; 6 - q7  
74ef			; 7 - q3  
74ef			; 8 - vss  
74ef			; 9 - q8  
74ef			; 10 - q4  
74ef			; 11 - q9  
74ef			; 12 - cout  
74ef			; 16 - vdd  
74ef			  
74ef			; clock      ce       reset     output  
74ef			; 0          x        0         n  
74ef			; x          1        0         n  
74ef			; x          x        1         q0  
74ef			; rising     0        0         n+1  
74ef			; falling    x        0         n  
74ef			; x          rising   0         n  
74ef			; 1          falling  0         x+1  
74ef			;  
74ef			; x = dont care, if n < 5 carry = 1 otherwise 0  
74ef			  
74ef			;   
74ef			; reset   
74ef			; 13=0, 14=0, 15=1 .. 15=0  
74ef			;  
74ef			; handshake line  
74ef			; 14=1.... read line 14=0  
74ef			  
74ef			  
74ef			  
74ef			  
74ef			  
74ef			; TODO hand shake clock for next column scan  
74ef			; TODO detect each row  
74ef			  
74ef			  
74ef			  
74ef			  
74ef			; reset 128  
74ef			; clock 64  
74ef			; ce 32  
74ef			  
74ef			  
74ef			.cyclestart:  
74ef			  
74ef			; reset counter  
74ef 3e 80		ld a, 128  
74f1 d3 c1		out (portbdata),a  
74f3			  
74f3			; loop leds  
74f3 06 0a		ld b,10  
74f5			  
74f5			.cycle1:  
74f5 c5			push bc  
74f6 3e 00		ld a, 0  
74f8 d3 c1		out (portbdata),a  
74fa cd 89 0c		call delay250ms  
74fd			  
74fd 3e 40		ld a, 64  
74ff d3 c1		out (portbdata),a  
7501 cd 89 0c		call delay250ms  
7504			  
7504 3e 00		ld a, 0  
7506 d3 c1		out (portbdata),a  
7508 cd 89 0c		call delay250ms  
750b			  
750b c1			pop bc  
750c 10 e7		djnz .cycle1  
750e			  
750e			  
750e 18 df		jr .cyclestart  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			; map matrix key held to char on face of key  
7510			  
7510			;.mtocold:  
7510			;  
7510			;  
7510			;; reset counter  
7510			;ld a, 128  
7510			;out (portbdata),a  
7510			;  
7510			;  
7510			;; scan keyboard row 1  
7510			;ld a, 0  
7510			;out (portbdata),a  
7510			;;ld a, 64  
7510			;;out (portbdata),a  
7510			;  
7510			;  
7510			;	ld a, 128  
7510			;	ld hl, keyscan_table  
7510			;	call .rowscan  
7510			;  
7510			;;ld a, 0  
7510			;;out (portbdata),a  
7510			;ld a, 64  
7510			;out (portbdata),a  
7510			;  
7510			;	ld a, 64  
7510			;	ld hl, keyscan_table+key_cols  
7510			;	call .rowscan  
7510			;  
7510			;ld a, 0  
7510			;out (portbdata),a  
7510			;;ld a, 64  
7510			;;out (portbdata),a  
7510			;	ld a, 32  
7510			;	ld hl, keyscan_table+(key_cols*2)  
7510			;	call .rowscan  
7510			;  
7510			;  
7510			;;ld a, 0  
7510			;;out (portbdata),a  
7510			;ld a, 64  
7510			;out (portbdata),a  
7510			;  
7510			;	ld a, 16  
7510			;	ld hl, keyscan_table+(key_cols*3)  
7510			;	call .rowscan  
7510			;  
7510			;  
7510			;	; flag if key D is held down and remove from reporting  
7510			;	ld bc, .key_map_fd    
7510			;	ld hl, keyscan_table  
7510			;	ld de, key_fd  
7510			;	call .key_shift_hold  
7510			;	cp 255  
7510			;	jr z, .cinmap  
7510			;	; flag if key C is held down and remove from reporting  
7510			;	ld bc, .key_map_fc    
7510			;	ld hl, keyscan_table+key_cols  
7510			;	ld de, key_fc  
7510			;	call .key_shift_hold  
7510			;	cp 255  
7510			;	jr z, .cinmap  
7510			;	; flag if key B is held down and remove from reporting  
7510			;	ld bc, .key_map_fb    
7510			;	ld hl, keyscan_table+(key_cols*2)  
7510			;	ld de, key_fb  
7510			;	call .key_shift_hold  
7510			;	cp 255  
7510			;	jr z, .cinmap  
7510			;	; flag if key A is held down and remove from reporting  
7510			;	ld bc, .key_map_fa    
7510			;	ld hl, keyscan_table+(key_cols*3)  
7510			;	ld de, key_fa  
7510			;	call .key_shift_hold  
7510			;	cp 255  
7510			;	jr z, .cinmap  
7510			;  
7510			;	ld de, .matrix_to_char  
7510			;  
7510			;  
7510			;.cinmap:   
7510			;	if DEBUG_KEY  
7510			;            LD   A, kLCD_Line4  
7510			;            CALL fLCD_Pos       ;Position cursor to location in A  
7510			;		push de  
7510			;            LD   DE, keyscan_table  
7510			;            CALL fLCD_Str       ;Display string pointed to by DE  
7510			;		pop de  
7510			;	endif  
7510			  
7510				; scan key matrix table for any held key  
7510			  
7510				; de holds either the default matrix or one selected above  
7510			  
7510			;	ld hl, keyscan_table  
7510			;	ld b,key_cols*key_rows  
7510			;  
7510			;.cin1:	ld a,(hl)  
7510			;	cp '#'  
7510			;	jr z, .cinhit  
7510			;	inc hl  
7510			;	inc de  
7510			;	dec b  
7510			;	jr nz, .cin1  
7510			;	; no key found held  
7510			;	ld a,0  
7510			;	ret  
7510			;.cinhit: push de  
7510			;	pop hl  
7510			;	ld a,(hl)  
7510			;	ret  
7510			  
7510			; flag a control key is held   
7510			; hl is key pin, de is flag indicator  
7510			  
7510			;.key_shift_hold:  
7510			;	push bc  
7510			;	ld a, 1  
7510			;	ld (cursor_shape),a  
7510			;	ld b, 0  
7510			;	ld a, (hl)  
7510			;	cp '.'  
7510			;	jr z, .key_shift1  
7510			;	ld b, 255  
7510			;	ld a, '+'    ; hide key from later scans  
7510			;	ld (hl),a  
7510			;	ld a, 2  
7510			;	ld (cursor_shape),a  
7510			;.key_shift1:  
7510			;	; write flag indicator  
7510			;	ld a,b  
7510			;	ld (de),a  
7510			;  
7510			;	pop de    ; de now holds the key map ptr  
7510			;	ret  
7510			  
7510				  
7510				  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			  
7510			;	push hl  
7510			;	push de  
7510			;	push bc  
7510			;	call keyscan  
7510			;	; map key matrix to ascii value of key face  
7510			;  
7510			;	ld hl, key_face_map  
7510			;	ld de, keyscan_table  
7510			;  
7510			;	; get how many keys to look at  
7510			;	ld b, keyscan_table_len  
7510			;	  
7510			;  
7510			;	; at this stage fall out on first key hit  
7510			;	; TODO handle multiple key press  
7510			;  
7510			;map1:	ld a,(hl)  
7510			;	cp '#'  
7510			;	jr z, keyhit  
7510			;	inc hl  
7510			;	inc de  
7510			;	dec b  
7510			;	jr nz, map1  
7510			;nohit:	ld a, 0  
7510			;	jr keydone  
7510			;keyhit: push de  
7510			;	pop hl  
7510			;	ld a,(hl)  
7510			;keydone:  
7510			;	push bc  
7510			;	push de  
7510			; 	push hl  
7510			;	ret   
7510			;  
7510			  
7510			  
7510			  
7510			  
7510			; scan physical key matrix  
7510			  
7510			  
7510			;keyscan:  
7510			;  
7510			;; for each key_row use keyscanr bit mask for out  
7510			;; then read in for keyscanc bitmask  
7510			;; save result of row scan to keyscantable  
7510			;  
7510			;; scan keyboard row 1  
7510			;  
7510			;	ld b, key_rows  
7510			;	ld hl, key_scanr  
7510			;	ld de, keyscan_table  
7510			;  
7510			;rowloop:  
7510			;  
7510			;	ld a,(hl)		; out bit mask to energise keyboard row  
7510			;	call rowscan  
7510			;	inc hl  
7510			;	dec b  
7510			;	jr nz, rowloop  
7510			;  
7510			;	ret  
7510			;  
7510			;  
7510			;; pass a out bitmask, b row number  
7510			;arowscan:   
7510			;	push bc  
7510			;  
7510			;	ld d, b  
7510			;  
7510			;	; calculate buffer location for this row  
7510			;  
7510			;	ld hl, keyscan_table	  
7510			;kbufr:  ld e, key_cols  
7510			;kbufc:	inc hl  
7510			;	dec e  
7510			;	jr nz, kbufc  
7510			;	dec d  
7510			;	jr nz, kbufr  
7510			;  
7510			;	; energise row and read columns  
7510			;  
7510			;	out (portbdata),a  
7510			;	in a,(portbdata)  
7510			;	ld c,a  
7510			;  
7510			;  
7510			;	; save buffer loc  
7510			;  
7510			;	ld (keybufptr), hl  
7510			;  
7510			;	ld hl, key_scanc  
7510			;	ld d, key_cols  
7510			;  
7510			;	; for each column check each bit mask  
7510			;  
7510			;colloop:  
7510			;	  
7510			;  
7510			;	; reset flags for the row   
7510			;  
7510			;	ld b,'.'  
7510			;	and (hl)  
7510			;	jr z, maskskip  
7510			;	ld b,'#'  
7510			;maskskip:  
7510			;	; save  key state  
7510			;	push hl  
7510			;	ld hl, (keybufptr)  
7510			;	ld (hl), b  
7510			;	inc hl  
7510			;	ld (keybufptr), hl  
7510			;  
7510			;	; move to next bit mask  
7510			;	pop hl  
7510			;	inc hl  
7510			;  
7510			;	dec d  
7510			;	jr nz, colloop  
7510			;  
7510			;	ret  
7510			;  
7510			;  
7510			;;  
7510			; lcd functions  
7510			;  
7510			;  
7510			  
7510			;if DEBUG_KEY_MATRIX  
7510			  
7510			; test function to display hardware view of matrix state  
7510			  
7510			matrixold:  
7510			  
7510			  
7510			  
7510			; reset counter  
7510 3e 80		ld a, 128  
7512 d3 c1		out (portbdata),a  
7514			; scan keyboard row 1  
7514 3e 00		ld a, 0  
7516 d3 c1		out (portbdata),a  
7518			;ld a, 64  
7518			;out (portbdata),a  
7518 3e 80			ld a, 128  
751a 21 f2 fe			ld hl, keyscan_table_row1  
751d cd 76 75			call .rowscan  
7520			  
7520			;ld a, 0  
7520			;out (portbdata),a  
7520 3e 40		ld a, 64  
7522 d3 c1		out (portbdata),a  
7524 3e 40			ld a, 64  
7526 21 e7 fe			ld hl, keyscan_table_row2  
7529 cd 76 75			call .rowscan  
752c			  
752c 3e 00		ld a, 0  
752e d3 c1		out (portbdata),a  
7530			;ld a, 64  
7530			;out (portbdata),a  
7530 3e 20			ld a, 32  
7532 21 dc fe			ld hl, keyscan_table_row3  
7535 cd 76 75			call .rowscan  
7538			  
7538			;ld a, 0  
7538			;out (portbdata),a  
7538 3e 40		ld a, 64  
753a d3 c1		out (portbdata),a  
753c 3e 10			ld a, 16  
753e 21 d1 fe			ld hl, keyscan_table_row4  
7541 cd 76 75			call .rowscan  
7544			  
7544			; Display text on first line  
7544 3e 00		            LD   A, kLCD_Line1  
7546 cd 7e 71		            CALL fLCD_Pos       ;Position cursor to location in A  
7549 11 f2 fe		            LD   DE, keyscan_table_row1  
754c			            ;LD   DE, MsgHello  
754c cd a0 71		            CALL fLCD_Str       ;Display string pointed to by DE  
754f			  
754f			; Display text on second line  
754f 3e 28		            LD   A, kLCD_Line2  
7551 cd 7e 71		            CALL fLCD_Pos       ;Position cursor to location in A  
7554 11 e7 fe		            LD   DE, keyscan_table_row2  
7557 cd a0 71		            CALL fLCD_Str       ;Display string pointed to by DE  
755a 3e 50		            LD   A, kLCD_Line3  
755c cd 7e 71		            CALL fLCD_Pos       ;Position cursor to location in A  
755f 11 dc fe		            LD   DE, keyscan_table_row3  
7562 cd a0 71		            CALL fLCD_Str       ;Display string pointed to by DE  
7565 3e 78		            LD   A, kLCD_Line4  
7567 cd 7e 71		            CALL fLCD_Pos       ;Position cursor to location in A  
756a 11 d1 fe		            LD   DE, keyscan_table_row4  
756d cd a0 71		            CALL fLCD_Str       ;Display string pointed to by DE  
7570			  
7570 cd 89 0c			call delay250ms  
7573 c3 61 74			jp matrix  
7576			  
7576			; pass de as row display flags  
7576			.rowscan:   
7576			;	out (portbdata),a  
7576 db c1			in a,(portbdata)  
7578 4f				ld c,a  
7579				; reset flags for the row   
7579 06 7e			ld b,KEY_MATRIX_NO_PRESS  
757b e6 01			and 1  
757d 28 02			jr z, .p1on  
757f 06 23			ld b,'#'  
7581			.p1on:  
7581 70				ld (hl), b  
7582 23				inc hl  
7583			  
7583 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7585 79				ld a,c  
7586 e6 02			and 2  
7588			;	bit 0,a  
7588 28 02			jr z, .p2on  
758a 06 23			ld b,'#'  
758c			.p2on:  
758c 70				ld (hl), b  
758d 23				inc hl  
758e			;  
758e 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7590 79				ld a,c  
7591 e6 04			and 4  
7593			;;	bit 0,a  
7593 28 02			jr z, .p3on  
7595 06 23			ld b,'#'  
7597			.p3on:  
7597 70				ld (hl), b  
7598 23				inc hl  
7599			;;  
7599 06 7e			ld b,KEY_MATRIX_NO_PRESS  
759b			;;	bit 0,a  
759b 79				ld a,c  
759c e6 08			and 8  
759e 28 02			jr z, .p4on  
75a0 06 23			ld b,'#'  
75a2			.p4on:  
75a2 70				ld (hl), b  
75a3 23				inc hl  
75a4			  
75a4 06 7e			ld b,KEY_MATRIX_NO_PRESS  
75a6			;;	bit 0,a  
75a6 79				ld a,c  
75a7 e6 10			and 16  
75a9 28 02			jr z, .p5on  
75ab 06 23			ld b,'#'  
75ad			.p5on:  
75ad 70				ld (hl), b  
75ae 23				inc hl  
75af			; zero term  
75af 06 00			ld b,0  
75b1 70				ld (hl), b  
75b2			  
75b2 c9			.rscandone: ret  
75b3			  
75b3			;addatohl:  
75b3			;  
75b3			 ;add   a, l    ; A = A+L  
75b3			  ;  ld    l, a    ; L = A+L  
75b3			   ; adc   a, h    ; A = A+L+H+carry  
75b3			   ; sub   l       ; A = H+carry  
75b3			   ; ld    h, a    ; H = H+carry  
75b3			  
75b3			;ret  
75b3			; eof  
# End of file firmware_key_5x10.asm
75b3			;include "firmware_key_4x10.asm" 
75b3			 
75b3			heap_size:    equ heap_end - heap_start 
75b3			;eof 
# End of file os_mega.asm
75b3
