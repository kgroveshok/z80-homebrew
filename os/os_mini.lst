# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 21 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 0  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 f9 fd				ld hl, display_fb1  
001f 22 55 fd				ld (display_fb_active), hl  
0022			  
0022 cd cd 0c				call clear_display  
0025			  
0025 21 57 fd				ld hl, display_fb2  
0028 22 55 fd				ld (display_fb_active), hl  
002b			  
002b cd cd 0c				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 4a fe				ld hl, display_fb0  
0031 22 55 fd				ld (display_fb_active), hl  
0034			  
0034 cd cd 0c				call clear_display  
0037			  
0037			  
0037 cd 85 69				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd ce 6a			call key_init  
003d cd b8 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd a4 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043					call sound_init  
0043				endif  
0043			  
0043				; lcd test sequence  
0043					  
0043 cd f0 0c			call update_display  
0046 cd 4a 0c			call delay1s  
0049 3e 2b			ld a,'+'  
004b cd d2 0c			call fill_display  
004e cd f0 0c			call update_display  
0051 cd 4a 0c			call delay1s  
0054 3e 2a			ld a,'*'  
0056 cd d2 0c			call fill_display  
0059 cd f0 0c			call update_display  
005c cd 4a 0c			call delay1s  
005f 3e 2d			ld a,'-'  
0061 cd d2 0c			call fill_display  
0064 cd f0 0c			call update_display  
0067 cd 4a 0c			call delay1s  
006a			  
006a			; boot splash screen  
006a			if display_cols == 20	  
006a 3e 00		        ld a, display_row_1    
006c			else  
006c			        ld a, display_row_1 +10   
006c			endif  
006c 11 54 1a			ld de, prom_bootmsg  
006f cd e0 0c			call str_at_display  
0072 cd f0 0c			call update_display  
0075			  
0075			  
0075 cd 4a 0c			call delay1s  
0078 cd 4a 0c			call delay1s  
007b			if display_cols == 20	  
007b 3e 2a		            LD   A, display_row_3+2  
007d			else  
007d			            LD   A, display_row_3+12  
007d			endif  
007d 11 69 1a			ld de, prom_bootmsg1  
0080 cd e0 0c			call str_at_display  
0083 cd f0 0c			call update_display  
0086 cd 4a 0c			call delay1s  
0089 cd 4a 0c			call delay1s  
008c			  
008c			;	ld a, display_row_4+3  
008c			;	ld de, bootmsg2  
008c			;	call str_at_display  
008c			;	call update_display  
008c			;	call delay1s  
008c			;	call delay1s  
008c			  
008c			; debug mark setup  
008c			  
008c 3e 5f		ld a, '_'  
008e 32 b4 fe		ld (debug_mark),a  
0091 32 b5 fe		ld (debug_mark+1),a  
0094 32 b6 fe		ld (debug_mark+2),a  
0097 3e 00		ld a,0  
0099 32 b7 fe		ld (debug_mark+3),a  
009c			  
009c c9					ret  
009d			  
009d			  
009d			;bootmsg2:	db "Firmware v0.1",0  
009d			  
009d			; a 4x20 lcd  
009d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
009d			  
009d			;if display_cols == 20  
009d			;	include "firmware_lcd_4x20.asm"  
009d			;endif  
009d			  
009d			;if display_cols == 40  
009d			;	include "firmware_lcd_4x40.asm"  
009d			;endif  
009d			  
009d			;  
009d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
009d			; TODO abstract the bit bang video out interface for dual display  
009d			; TODO wire video out to tx pin on rc2014 bus  
009d			  
009d			; must supply cin, and cin_wait for low level hardware abstraction   
009d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
009d			; test scancode  
009d			  
009d			;;;;;  
009d			;;;  
009d			; Moved out to mini and maxi versions  
009d			;  
009d			; include "firmware_key_4x4.asm"  
009d			; using existing 4 wire x 4 resistor array for input  
009d			;include "firmware_key_4x10.asm"  
009d			; need to mod the board for 5 rows due to resistor array  
009d			;include "firmware_key_5x10.asm"  
009d			  
009d			; storage hardware interface  
009d			  
009d			; use microchip serial eeprom for storage  
009d			  
009d			  
009d			if STORAGE_SE  
009d				include "firmware_spi.asm"  
009d			; my spi protocol (used by storage) 
009d			 
009d			; SPI pins 
009d			 
009d			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
009d			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
009d			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
009d			 
009d			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
009d			; chip pin 4 gnd 
009d			 
009d			 
009d			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
009d			SPI_CE1: equ 1      ;    port a1 pin 14  
009d			SPI_CE2: equ 2      ;    port a2 pin pin 13 
009d			SPI_CE3: equ 3      ; port    a3 pin pin 12 
009d			SPI_CE4: equ 4      ; port a4     pin 10 
009d			 
009d			; active low AND masks 
009d			 
009d			;SPI_CE0_MASK: equ    255-1 
009d			;SPI_CE1_MASK: equ   255-2 
009d			;SPI_CE2_MASK: equ   255-4 
009d			;SPI_CE3_MASK: equ   255-8 
009d			;SPI_CE4_MASK: equ   255-16 
009d			SPI_CE_HIGH:  equ 255 
009d			 
009d			 
009d			 
009d			 
009d			; TODO store port id for spi device ie dev c 
009d			; TODO store pin for SO 
009d			; TODO store pin for SI 
009d			; TODO store pin for SCLK 
009d			 
009d			; 
009d			 
009d			; ensure that spi bus is in a stable state with default pins  
009d			 
009d			se_stable_spi:   
009d			 
009d				 ; set DI high, CE high , SCLK low 
009d				;ld a, SPI_DI | SPI_CE0 
009d 3e 07			ld a, SPI_DI  
009f cd 73 01			call spi_ce_high 
00a2 d3 80			 out (storage_adata),a 
00a4 32 ef fb			ld (spi_portbyte),a 
00a7			 
00a7				if DEBUG_SPI 
00a7					push hl 
00a7					ld l, a 
00a7					DMARK "SPI" 
00a7					CALLMONITOR 
00a7					pop hl 
00a7				endif 
00a7 c9				ret 
00a8			 
00a8			; byte to send in a 
00a8			 
00a8			spi_send_byte: 
00a8				; save byte to send for bit mask shift out 
00a8 4f			        ld c,a 
00a9 3a ef fb			ld a,(spi_portbyte) 
00ac				  
00ac				; clock out	each bit of the byte msb first 
00ac			 
00ac 06 08			ld b, 8 
00ae			.ssb1: 
00ae				; clear so bit  
00ae cb bf			res SPI_DI, a 
00b0 cb 11			rl c 
00b2				; if bit 7 is set then carry is set 
00b2 30 02			jr nc, .ssb2 
00b4 cb ff			set SPI_DI,a 
00b6			.ssb2:  ; output bit to ensure it is stable 
00b6 d3 80			out (storage_adata),a 
00b8 00				nop 
00b9				; clock bit high 
00b9 cb ef			set SPI_SCLK,a 
00bb d3 80			out (storage_adata),a 
00bd 00				nop 
00be				; then low 
00be cb af			res SPI_SCLK,a 
00c0 d3 80			out (storage_adata),a 
00c2 00				nop 
00c3 10 e9			djnz .ssb1 
00c5			 
00c5 32 ef fb			ld (spi_portbyte),a 
00c8 c9				ret 
00c9			 
00c9			; TODO low level get byte into A on spi 
00c9			 
00c9			spi_read_byte:  
00c9			 
00c9				; save byte to send for bit mask shift out 
00c9 0e 00		    ld c,0 
00cb 3a ef fb			ld a,(spi_portbyte) 
00ce				  
00ce				; clock out	each bit of the byte msb first 
00ce			 
00ce			 
00ce				; clock bit high 
00ce cb ef			set SPI_SCLK,a 
00d0 d3 80			out (storage_adata),a 
00d2 00				nop 
00d3			 
00d3			    ; read DO  
00d3			 
00d3 cb f9		    set 7,c 
00d5 db 80			in a,(storage_adata) 
00d7 cb 77		    bit SPI_DO,a 
00d9 20 02		    jr nz, .b7 
00db cb b9		    res 7,c 
00dd			.b7: 
00dd				; then low 
00dd cb af			res SPI_SCLK,a 
00df d3 80			out (storage_adata),a 
00e1 00				nop 
00e2			     
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f1		    set 6,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b6 
00ef cb b1		    res 6,c 
00f1			.b6: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb e9		    set 5,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b5 
0103 cb a9		    res 5,c 
0105			.b5: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			    ; read DO  
010f			 
010f cb e1		    set 4,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b4 
0117 cb a1		    res 4,c 
0119			.b4: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb d9		    set 3,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b3 
012b cb 99		    res 3,c 
012d			.b3: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d1		    set 2,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b2 
013f cb 91		    res 2,c 
0141			.b2: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb c9		    set 1,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b1 
0153 cb 89		    res 1,c 
0155			.b1: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c1		    set 0,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b0 
0167 cb 81		    res 0,c 
0169			.b0: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e			 
016e			 
016e 32 ef fb			ld (spi_portbyte),a 
0171			 
0171			    ; return byte 
0171 79			    ld a,c 
0172			 
0172			 
0172 c9				ret 
0173			 
0173			 
0173			 
0173			spi_ce_high: 
0173			 
0173				if DEBUG_SPI_HARD_CE0 
0173			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0173					ret 
0173			 
0173				endif 
0173			 
0173			 
0173 f5				push af 
0174			 
0174				; send direct ce to port b 
0174 3e ff			ld a, 255 
0176 d3 81			out (storage_bdata), a 
0178			 
0178 f1				pop af 
0179			 
0179				; for port a that shares with spi lines AND the mask 
0179			  
0179				if DEBUG_SPI 
0179					push hl 
0179					ld h, a 
0179				endif 
0179			;	ld c, SPI_CE_HIGH 
0179			;	and c 
0179 cb c7			set SPI_CE0, a 
017b cb cf			set SPI_CE1, a 
017d cb d7			set SPI_CE2, a 
017f cb df			set SPI_CE3, a 
0181 cb e7			set SPI_CE4, a 
0183			 
0183				if DEBUG_SPI 
0183					ld l, a 
0183					DMARK "CEh" 
0183					CALLMONITOR 
0183					pop hl 
0183				endif 
0183 c9				ret 
0184			 
0184			 
0184			spi_ce_low: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184 c5				push bc 
0185 f5				push af 
0186			 
0186				; send direct ce to port b 
0186 3a f1 fb			ld a, (spi_cartdev) 
0189 d3 81			out (storage_bdata), a 
018b			 
018b			 
018b			 
018b				; for port a that shares with spi lines AND the mask 
018b			 
018b 3a ee fb			ld a, (spi_device)  
018e 4f				ld c, a 
018f			 
018f f1				pop af 
0190			 
0190				; detect CEx 
0190			 
0190				if DEBUG_SPI 
0190					push hl 
0190					ld h, a 
0190				endif 
0190			 
0190 cb 41			bit SPI_CE0, c 
0192 20 04			jr nz, .cel1 
0194 cb 87			res SPI_CE0, a 
0196 18 1e			jr .celn 
0198			.cel1: 
0198 cb 49			bit SPI_CE1, c 
019a 20 04			jr nz, .cel2 
019c cb 8f			res SPI_CE1, a 
019e 18 16			jr .celn 
01a0			.cel2: 
01a0 cb 51			bit SPI_CE2, c 
01a2 20 04			jr nz, .cel3 
01a4 cb 97			res SPI_CE2, a 
01a6 18 0e			jr .celn 
01a8			.cel3: 
01a8 cb 59			bit SPI_CE3, c 
01aa 20 04			jr nz, .cel4 
01ac cb 9f			res SPI_CE3, a 
01ae 18 06			jr .celn 
01b0			.cel4: 
01b0 cb 61			bit SPI_CE4, c 
01b2 20 02			jr nz, .celn 
01b4 cb a7			res SPI_CE4, a 
01b6			.celn: 
01b6			 
01b6			 
01b6			 
01b6			;	add c 
01b6			 
01b6				if DEBUG_SPI 
01b6					ld l, a 
01b6					DMARK "CEl" 
01b6					CALLMONITOR 
01b6					pop hl 
01b6				endif 
01b6 c1				pop bc 
01b7 c9				ret 
01b8			 
01b8			 
01b8			 
01b8			; eof 
01b8			 
01b8			 
01b8			 
01b8			 
01b8			 
# End of file firmware_spi.asm
01b8				include "firmware_seeprom.asm"  
01b8			; 
01b8			; persisent storage interface via microchip serial eeprom 
01b8			 
01b8			; port a pio 2 
01b8			; pa 7 - si 
01b8			; pa 6 - sclk  
01b8			; pa 5 - so 
01b8			; pa 4 - cs 
01b8			; pa 3 - cs 
01b8			; pa 2 - cs 
01b8			; pa 1 - cs 
01b8			; pa 0 - cs 
01b8			; 
01b8			; TODO get block 
01b8			; TODO save block 
01b8			; TODO load file 
01b8			; TODO save file 
01b8			; TODO get dir  
01b8			 
01b8			;  
01b8			storage_adata: equ Device_C    ; device c port a - onboard storage 
01b8			storage_actl: equ Device_C+2     ; device c port a 
01b8			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01b8			storage_bctl: equ Device_C+3     ; device c port b 
01b8			 
01b8			 
01b8			; TODO move these to hardware driver file 
01b8			 
01b8			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01b8			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01b8			; storage bank file system format 
01b8			; 
01b8			; first page of bank: 
01b8			; 	addr 0 - status check 
01b8			;       addr 1 - write protect flag 
01b8			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01b8			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01b8			;         TODO see if scanning whole of for available next file id is fast enough 
01b8			;	addr 4 > zero term string of bank label 
01b8			; 
01b8			;        
01b8			;  
01b8			; first page of any file: 
01b8			;      byte 0 - file id  
01b8			;      byte 1-17 - fixed file name  
01b8			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01b8			; 
01b8			; other pages of any file: 
01b8			;      byte 0 - file id 
01b8			;      byte 1> - file data 
01b8			; 
01b8			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01b8			;  
01b8			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01b8			 
01b8			 
01b8			;storage_so_bit: 5 
01b8			;storage_si_bit: 7 
01b8			;storage_sclk_bit: 6 
01b8			  
01b8			 
01b8			; init storage pio 
01b8			 
01b8			storage_init: 
01b8			 
01b8 3e cf		            LD   A, 11001111b 
01ba d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01bc 3e 00		            LD   A, 00000000b 
01be cb f7			set SPI_DO,a 
01c0			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01c0 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01c2			 
01c2 3e cf		            LD   A, 11001111b 
01c4 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01c6 3e 00		            LD   A, 00000000b 
01c8 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01ca			 
01ca				; set all external spi devices off 
01ca 3e 00			ld a, 0 
01cc 32 ee fb			ld (spi_device), a 
01cf 32 f1 fb			ld (spi_cartdev), a 
01d2			 
01d2					; ensure the spi bus is in a default stable state 
01d2 cd 9d 00				call se_stable_spi 
01d5			 
01d5			; TODO scan spi bus and gather which storage banks are present 
01d5			 
01d5			; populate store_bank_active  
01d5			; for each ce line activate and attempt to write first byte of bank and read back 
01d5			; if zero is returned then bank is empty 
01d5			;   
01d5			; 
01d5			 
01d5					; init file extent cache to save on slow reads 
01d5			 
01d5			;	ld hl, store_filecache 
01d5			;	ld de, 0 
01d5			;	ld hl,(de)	 
01d5			 
01d5			 
01d5 c9			    ret 
01d6			 
01d6			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01d6			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01d6			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01d6			 
01d6			; INSTRUCTION SET 
01d6			; READ 0000 0011 Read data from memory array beginning at selected address 
01d6			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01d6			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01d6			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01d6			; RDSR 0000 0101 Read STATUS register 
01d6			; WRSR 0000 0001 Write STATUS register 
01d6			; PE 0100 0010 Page Erase – erase one page in memory array 
01d6			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01d6			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01d6			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01d6			 
01d6			; TODO send byte steam for page without setting the address for every single byte 
01d6			; TODO read byte  
01d6			 
01d6			; byte in a 
01d6			; address in hl  
01d6			se_writebyte: 
01d6			        
01d6			    ;   ld c, a 
01d6 f5			        push af 
01d7 e5			        push hl 
01d8			 
01d8			    ; initi write mode 
01d8			    ; 
01d8			    ;CS low 
01d8			 
01d8 3a ef fb		       ld a,(spi_portbyte) 
01db cd 84 01			call spi_ce_low 
01de			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01de d3 80		       out (storage_adata),a 
01e0 32 ef fb		       ld (spi_portbyte), a 
01e3			 
01e3			    ;clock out wren instruction 
01e3			 
01e3 3e 06		    ld a, store_wren_ins 
01e5 cd a8 00		    call spi_send_byte  
01e8			 
01e8			    ;cs high to enable write latch 
01e8			 
01e8 3a ef fb		       ld a,(spi_portbyte) 
01eb cd 73 01			call spi_ce_high 
01ee			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ee d3 80		       out (storage_adata),a 
01f0 32 ef fb		       ld (spi_portbyte), a 
01f3			 
01f3 00				nop 
01f4			    ; 
01f4			    ; intial write data 
01f4			    ; 
01f4			    ; cs low 
01f4			     
01f4 3a ef fb		       ld a,(spi_portbyte) 
01f7 cd 84 01			call spi_ce_low 
01fa			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fa d3 80		       out (storage_adata),a 
01fc 32 ef fb		       ld (spi_portbyte), a 
01ff			 
01ff			    ; clock out write instruction 
01ff			     
01ff 3e 02		    ld a, store_write_ins  
0201 cd a8 00		    call spi_send_byte  
0204			 
0204			    ; clock out address (depending on address size) 
0204			     
0204 e1			    pop hl 
0205 7c			    ld a,h    ; address out msb first 
0206 cd a8 00		    call spi_send_byte  
0209 7d			    ld a,l 
020a cd a8 00		    call spi_send_byte  
020d			 
020d			    ; clock out byte(s) for page 
020d			 
020d f1			    pop af 
020e cd a8 00		    call spi_send_byte  
0211			 
0211			    ; end write with ce high 
0211 3a ef fb		       ld a,(spi_portbyte) 
0214			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0214 cd 73 01			call spi_ce_high 
0217 d3 80		       out (storage_adata),a 
0219 32 ef fb		       ld (spi_portbyte), a 
021c			 
021c				; pause for internal write cycle 
021c 3e 0a			ld a, 10 
021e cd 2f 0c			call aDelayInMS 
0221 c9			    ret 
0222			 
0222			; buffer to write in de 
0222			; address in hl  
0222			se_writepage: 
0222			        
0222			    ;   ld c, a 
0222 d5				push de 
0223 e5			        push hl 
0224			 
0224			    ; initi write mode 
0224			    ; 
0224			    ;CS low 
0224			 
0224 3a ef fb		       ld a,(spi_portbyte) 
0227 cd 84 01			call spi_ce_low 
022a			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022a d3 80		       out (storage_adata),a 
022c 32 ef fb		       ld (spi_portbyte), a 
022f			 
022f			    ;clock out wren instruction 
022f			 
022f 3e 06		    ld a, store_wren_ins 
0231 cd a8 00		    call spi_send_byte  
0234			 
0234			    ;cs high to enable write latch 
0234			 
0234 3a ef fb		       ld a,(spi_portbyte) 
0237 cd 73 01			call spi_ce_high 
023a			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
023a d3 80		       out (storage_adata),a 
023c 32 ef fb		       ld (spi_portbyte), a 
023f			 
023f 00				nop 
0240			    ; 
0240			    ; intial write data 
0240			    ; 
0240			    ; cs low 
0240			     
0240 3a ef fb		       ld a,(spi_portbyte) 
0243			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0243 cd 84 01			call spi_ce_low 
0246 d3 80		       out (storage_adata),a 
0248 32 ef fb		       ld (spi_portbyte), a 
024b			 
024b			    ; clock out write instruction 
024b			     
024b 3e 02		    ld a, store_write_ins  
024d cd a8 00		    call spi_send_byte  
0250			 
0250			    ; clock out address (depending on address size) 
0250			     
0250 e1			    pop hl 
0251 7c			    ld a,h    ; address out msb first 
0252 cd a8 00		    call spi_send_byte  
0255 7d			    ld a,l 
0256 cd a8 00		    call spi_send_byte  
0259			 
0259			    ; clock out byte(s) for page 
0259			 
0259 e1				pop hl 
025a 06 40			ld b, STORE_BLOCK_PHY 
025c			.bytewrite: 
025c			 
025c 7e				ld a,(hl) 
025d e5			    push hl 
025e c5				push bc 
025f cd a8 00		    call spi_send_byte  
0262 c1				pop bc 
0263 e1				pop hl 
0264			 
0264			    ; end write with ce high 
0264 3a ef fb		       ld a,(spi_portbyte) 
0267 cd 73 01			call spi_ce_high 
026a			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
026a d3 80		       out (storage_adata),a 
026c 32 ef fb		       ld (spi_portbyte), a 
026f			 
026f 23				inc hl 
0270 10 ea			djnz .bytewrite 
0272			 
0272				; pause for internal write cycle 
0272 3e 64			ld a, 100 
0274 cd 2f 0c			call aDelayInMS 
0277 c9			    ret 
0278			; returns byte in a 
0278			; address in hl  
0278			se_readbyte: 
0278 d5				push de 
0279 c5				push bc 
027a			 
027a			    ;   ld c, a 
027a e5			        push hl 
027b			 
027b			    ; initi write mode 
027b			    ; 
027b			    ;CS low 
027b			 
027b 3a ef fb		       ld a,(spi_portbyte) 
027e cd 84 01			call spi_ce_low 
0281			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0281 d3 80		       out (storage_adata),a 
0283 32 ef fb		       ld (spi_portbyte), a 
0286			 
0286			    ;clock out wren instruction 
0286			 
0286 3e 03		    ld a, store_read_ins 
0288 cd a8 00		    call spi_send_byte  
028b			 
028b			 
028b			    ; clock out address (depending on address size) 
028b			     
028b e1			    pop hl 
028c 7c			    ld a,h    ; address out msb first 
028d cd a8 00		    call spi_send_byte  
0290 7d			    ld a,l 
0291 cd a8 00		    call spi_send_byte  
0294			 
0294			    ; clock in byte(s) for page 
0294			 
0294 cd c9 00		    call spi_read_byte  
0297 f5				push af 
0298			 
0298			    ; end write with ce high 
0298 3a ef fb		       ld a,(spi_portbyte) 
029b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
029b cd 73 01			call spi_ce_high 
029e d3 80		       out (storage_adata),a 
02a0 32 ef fb		       ld (spi_portbyte), a 
02a3			 
02a3 f1				pop af 
02a4			 
02a4 c1				pop bc 
02a5 d1				pop de 
02a6			 
02a6 c9			    ret 
02a7			 
02a7			if DEBUG_STORESE 
02a7			 
02a7			storageput:  
02a7			 
02a7			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02a7			 
02a7 21 85 f3			ld hl,scratch+2 
02aa cd b8 12			call get_word_hl 
02ad			 
02ad				; stuff it here for the moment as it will be overwritten later anyway 
02ad			 
02ad 22 a6 f6			ld (os_cur_ptr),hl	 
02b0			 
02b0			 
02b0			; get pointer to start of string 
02b0			 
02b0 21 8a f3			ld hl, scratch+7 
02b3			 
02b3			; loop writing char of string to eeprom 
02b3			 
02b3 7e			.writestr:	ld a,(hl) 
02b4 fe 00				cp 0 
02b6 28 12				jr z, .wsdone		; done writing 
02b8 e5					push hl 
02b9 2a a6 f6				ld hl,(os_cur_ptr) 
02bc cd d6 01				call se_writebyte 
02bf			 
02bf 2a a6 f6				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02c2 23					inc hl 
02c3 22 a6 f6				ld (os_cur_ptr),hl 
02c6			 
02c6					; restore string pointer and get next char 
02c6			 
02c6 e1					pop hl 
02c7 23					inc hl 
02c8 18 e9				jr .writestr 
02ca			 
02ca			 
02ca			 
02ca			.wsdone: 
02ca			 
02ca			 
02ca			; when done load first page into a buffer  
02ca			 
02ca 21 00 80				ld hl,08000h		; start in ram 
02cd 22 a6 f6				ld (os_cur_ptr),hl 
02d0 21 00 00				ld hl, 0		 ; start of page 
02d3 22 ab f3				ld (scratch+40),hl	; hang on to it 
02d6			 
02d6 06 80				ld b, 128		; actually get more then one page 
02d8 c5			.wsload:	push bc 
02d9 2a ab f3				ld hl,(scratch+40) 
02dc e5					push hl 
02dd cd 78 02				call se_readbyte 
02e0			 
02e0					; a now as the byte 
02e0			 
02e0 2a a6 f6				ld hl,(os_cur_ptr) 
02e3 77					ld (hl),a 
02e4					; inc next buffer area 
02e4 23					inc hl 
02e5 22 a6 f6				ld (os_cur_ptr),hl 
02e8			 
02e8					; get eeprom position, inc and save for next round 
02e8 e1					pop hl		 
02e9 23					inc hl 
02ea 22 ab f3				ld (scratch+40),hl 
02ed c1					pop bc 
02ee 10 e8				djnz .wsload 
02f0			 
02f0			; set 'd' pointer to start of buffer 
02f0			 
02f0 21 00 80				ld hl,08000h 
02f3 22 a6 f6				ld (os_cur_ptr),hl 
02f6			 
02f6			 
02f6 c9			ret 
02f7			 
02f7			 
02f7 c9			storageread: ret 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			endif 
02f8			 
02f8			 
02f8			 
# End of file firmware_seeprom.asm
02f8			else  
02f8			   ; create some stubs for the labels  
02f8			se_readbyte: ret  
02f8			se_writebyte: ret  
02f8			storage_init: ret  
02f8			  
02f8			endif  
02f8			  
02f8			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02f8			;include "firmware_cf.asm"  
02f8			  
02f8			; load up high level storage hardward abstractions  
02f8			include "firmware_storage.asm"  
02f8			 
02f8			; persisent storage hardware abstraction layer  
02f8			 
02f8			 
02f8			 
02f8			; Block 0 on storage is a config state 
02f8			 
02f8			 
02f8			 
02f8			; TODO add read phy block and write phy block functions 
02f8			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02f8			 
02f8			; Abstraction layer  
02f8			 
02f8			; Logocial block size is same size as physical size - using tape concept 
02f8			 
02f8			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02f8			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02f8			 
02f8			 
02f8			 
02f8			; Filesystem layout (Logical layout) 
02f8			; 
02f8			; Block 0 - Bank config  
02f8			; 
02f8			;      Byte - 0 file id counter 
02f8			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02f8			;      Byte - 3-20 zero terminated bank label 
02f8			; 
02f8			; Block 1 > File storage 
02f8			; 
02f8			;      Byte 0 file id    - block 0 file details 
02f8			;      Byte 1 block id - block 0 is file  
02f8			;            Byte 2-15 - File name 
02f8			; 
02f8			;       - to end of block data 
02f8			; 
02f8			 
02f8			; Get ID for the file named in pointer held HL 
02f8			; Returns ID in HL = 255 if no file found 
02f8			 
02f8			storage_getid: 
02f8			 
02f8 22 00 fc			ld (store_tmp1), hl 
02fb			 
02fb				if DEBUG_STORESE 
02fb					DMARK "SGI" 
02fb f5				push af  
02fc 3a 10 03			ld a, (.dmark)  
02ff 32 b4 fe			ld (debug_mark),a  
0302 3a 11 03			ld a, (.dmark+1)  
0305 32 b5 fe			ld (debug_mark+1),a  
0308 3a 12 03			ld a, (.dmark+2)  
030b 32 b6 fe			ld (debug_mark+2),a  
030e 18 03			jr .pastdmark  
0310 ..			.dmark: db "SGI"  
0313 f1			.pastdmark: pop af  
0314			endm  
# End of macro DMARK
0314					CALLMONITOR 
0314 cd 7e 18			call break_point_state  
0317				endm  
# End of macro CALLMONITOR
0317				endif 
0317				; get block 0 and set counter for number of files to scan 
0317			 
0317 cd 82 04			call storage_get_block_0 
031a			 
031a 3a 07 fc			ld a, (store_page) 
031d 47				ld b, a 
031e			 
031e				; get extent 0 of each file id 
031e			 
031e				if DEBUG_STORESE 
031e					DMARK "SGc" 
031e f5				push af  
031f 3a 33 03			ld a, (.dmark)  
0322 32 b4 fe			ld (debug_mark),a  
0325 3a 34 03			ld a, (.dmark+1)  
0328 32 b5 fe			ld (debug_mark+1),a  
032b 3a 35 03			ld a, (.dmark+2)  
032e 32 b6 fe			ld (debug_mark+2),a  
0331 18 03			jr .pastdmark  
0333 ..			.dmark: db "SGc"  
0336 f1			.pastdmark: pop af  
0337			endm  
# End of macro DMARK
0337					CALLMONITOR 
0337 cd 7e 18			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a 60			.getloop:	ld h, b 
033b 2e 00				ld l, 0 
033d c5					push bc 
033e			 
033e 11 07 fc				ld de, store_page 
0341				if DEBUG_STORESE 
0341					DMARK "SGr" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 b4 fe			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 b5 fe			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 b6 fe			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SGr"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a					CALLMONITOR 
035a cd 7e 18			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d				endif 
035d cd 2a 09				call storage_read 
0360 cd 2a 0f				call ishlzero 
0363 28 2d				jr z, .gap 
0365					 
0365					; have a file name read. Is it one we want. 
0365			 
0365 2a 00 fc				ld hl, (store_tmp1) 
0368 11 0a fc				ld de, store_page+3   ; file name 
036b			 
036b				if DEBUG_STORESE 
036b					DMARK "SGc" 
036b f5				push af  
036c 3a 80 03			ld a, (.dmark)  
036f 32 b4 fe			ld (debug_mark),a  
0372 3a 81 03			ld a, (.dmark+1)  
0375 32 b5 fe			ld (debug_mark+1),a  
0378 3a 82 03			ld a, (.dmark+2)  
037b 32 b6 fe			ld (debug_mark+2),a  
037e 18 03			jr .pastdmark  
0380 ..			.dmark: db "SGc"  
0383 f1			.pastdmark: pop af  
0384			endm  
# End of macro DMARK
0384					CALLMONITOR 
0384 cd 7e 18			call break_point_state  
0387				endm  
# End of macro CALLMONITOR
0387				endif 
0387 cd 97 13				call strcmp 
038a 20 06				jr nz, .gap   ; not this one 
038c			 
038c c1				        pop bc 
038d			 
038d 26 00				ld h, 0 
038f 68					ld l, b 
0390 18 22				jr .getdone 
0392						 
0392			 
0392			 
0392			 
0392			.gap: 
0392				if DEBUG_STORESE 
0392					DMARK "SGg" 
0392 f5				push af  
0393 3a a7 03			ld a, (.dmark)  
0396 32 b4 fe			ld (debug_mark),a  
0399 3a a8 03			ld a, (.dmark+1)  
039c 32 b5 fe			ld (debug_mark+1),a  
039f 3a a9 03			ld a, (.dmark+2)  
03a2 32 b6 fe			ld (debug_mark+2),a  
03a5 18 03			jr .pastdmark  
03a7 ..			.dmark: db "SGg"  
03aa f1			.pastdmark: pop af  
03ab			endm  
# End of macro DMARK
03ab					CALLMONITOR 
03ab cd 7e 18			call break_point_state  
03ae				endm  
# End of macro CALLMONITOR
03ae				endif 
03ae			 
03ae c1					pop bc 
03af 10 89				djnz .getloop 
03b1 21 ff 00				ld hl, 255 
03b4			.getdone: 
03b4			 
03b4				if DEBUG_STORESE 
03b4					DMARK "SGe" 
03b4 f5				push af  
03b5 3a c9 03			ld a, (.dmark)  
03b8 32 b4 fe			ld (debug_mark),a  
03bb 3a ca 03			ld a, (.dmark+1)  
03be 32 b5 fe			ld (debug_mark+1),a  
03c1 3a cb 03			ld a, (.dmark+2)  
03c4 32 b6 fe			ld (debug_mark+2),a  
03c7 18 03			jr .pastdmark  
03c9 ..			.dmark: db "SGe"  
03cc f1			.pastdmark: pop af  
03cd			endm  
# End of macro DMARK
03cd					CALLMONITOR 
03cd cd 7e 18			call break_point_state  
03d0				endm  
# End of macro CALLMONITOR
03d0				endif 
03d0			 
03d0 c9				ret 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			; Read Block 
03d1			; ---------- 
03d1			; 
03d1			; With current bank 
03d1			;  
03d1			; Get block number to read 
03d1			; Load physical blocks starting at start block into buffer 
03d1			 
03d1			; de points to buffer to use 
03d1			; hl holds logical block number  
03d1			 
03d1			storage_read_block: 
03d1			 
03d1				; TODO bank selection 
03d1			 
03d1				; for each of the physical blocks read it into the buffer 
03d1 06 40			ld b, STORE_BLOCK_PHY 
03d3			 
03d3				if DEBUG_STORESE 
03d3 d5					push de 
03d4				endif 
03d4				 
03d4			.rl1:    
03d4			 
03d4				; read physical block at hl into de 
03d4			        ; increment hl and de to next read position on exit 
03d4			 
03d4 e5				push hl 
03d5 d5				push de	 
03d6 c5				push bc 
03d7			;	if DEBUG_STORESE 
03d7			;		push af 
03d7			;		ld a, 'R' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7			;		CALLMONITOR 
03d7			;	endif 
03d7 cd 78 02			call se_readbyte 
03da			;	if DEBUG_STORESE 
03da			;		ld a,(spi_portbyte) 
03da			;		ld l, a 
03da			;		push af 
03da			;		ld a, '1' 
03da			;		ld (debug_mark),a 
03da			;		pop af 
03da			;		CALLMONITOR 
03da			;	endif 
03da c1				pop bc 
03db d1				pop de 
03dc e1				pop hl 
03dd 12				ld (de),a 
03de 23				inc hl 
03df 13				inc de 
03e0			 
03e0			;	if DEBUG_STORESE 
03e0			;		push af 
03e0			;		ld a, 'r' 
03e0			;		ld (debug_mark),a 
03e0			;		pop af 
03e0			;		CALLMONITOR 
03e0			;	endif 
03e0			 
03e0 10 f2			djnz .rl1 
03e2			 
03e2				if DEBUG_STORESE 
03e2					DMARK "SRB" 
03e2 f5				push af  
03e3 3a f7 03			ld a, (.dmark)  
03e6 32 b4 fe			ld (debug_mark),a  
03e9 3a f8 03			ld a, (.dmark+1)  
03ec 32 b5 fe			ld (debug_mark+1),a  
03ef 3a f9 03			ld a, (.dmark+2)  
03f2 32 b6 fe			ld (debug_mark+2),a  
03f5 18 03			jr .pastdmark  
03f7 ..			.dmark: db "SRB"  
03fa f1			.pastdmark: pop af  
03fb			endm  
# End of macro DMARK
03fb d1					pop de 
03fc			; 
03fc			;		push af 
03fc			;		ld a, 'R' 
03fc			;		ld (debug_mark),a 
03fc			;		pop af 
03fc					CALLMONITOR 
03fc cd 7e 18			call break_point_state  
03ff				endm  
# End of macro CALLMONITOR
03ff				endif 
03ff c9				ret	 
0400				 
0400			 
0400			; File Size 
0400			; --------- 
0400			; 
0400			;   hl file id 
0400			; 
0400			;  returns in hl the number of blocks 
0400			 
0400			storage_file_size: 
0400 5d				ld e, l 
0401 16 00			ld d, 0 
0403 21 40 00			ld hl, STORE_BLOCK_PHY 
0406					if DEBUG_FORTH_WORDS 
0406						DMARK "SIZ" 
0406 f5				push af  
0407 3a 1b 04			ld a, (.dmark)  
040a 32 b4 fe			ld (debug_mark),a  
040d 3a 1c 04			ld a, (.dmark+1)  
0410 32 b5 fe			ld (debug_mark+1),a  
0413 3a 1d 04			ld a, (.dmark+2)  
0416 32 b6 fe			ld (debug_mark+2),a  
0419 18 03			jr .pastdmark  
041b ..			.dmark: db "SIZ"  
041e f1			.pastdmark: pop af  
041f			endm  
# End of macro DMARK
041f						CALLMONITOR 
041f cd 7e 18			call break_point_state  
0422				endm  
# End of macro CALLMONITOR
0422					endif 
0422 cd 04 07			call storage_findnextid 
0425			 
0425 cd 2a 0f			call ishlzero 
0428			;	ld a, l 
0428			;	add h 
0428			;	cp 0 
0428 c8				ret z			; block not found so EOF 
0429			 
0429 11 07 fc			ld de, store_page 
042c cd d1 03			call storage_read_block 
042f			 
042f 3a 09 fc			ld a, (store_page+2)	 ; get extent count 
0432 6f				ld l, a 
0433 26 00			ld h, 0 
0435 c9			 	ret 
0436			 
0436			 
0436			; Write Block 
0436			; ----------- 
0436			; 
0436			; With current bank 
0436			;  
0436			; Get block number to write 
0436			; Write physical blocks starting at start block from buffer 
0436			  
0436			storage_write_block: 
0436				; TODO bank selection 
0436			 
0436				; for each of the physical blocks read it into the buffer 
0436 06 40			ld b, STORE_BLOCK_PHY 
0438			 
0438				if DEBUG_STORESE 
0438					DMARK "SWB" 
0438 f5				push af  
0439 3a 4d 04			ld a, (.dmark)  
043c 32 b4 fe			ld (debug_mark),a  
043f 3a 4e 04			ld a, (.dmark+1)  
0442 32 b5 fe			ld (debug_mark+1),a  
0445 3a 4f 04			ld a, (.dmark+2)  
0448 32 b6 fe			ld (debug_mark+2),a  
044b 18 03			jr .pastdmark  
044d ..			.dmark: db "SWB"  
0450 f1			.pastdmark: pop af  
0451			endm  
# End of macro DMARK
0451			 
0451					;push af 
0451					;ld a, 'W' 
0451					;ld (debug_mark),a 
0451					;pop af 
0451					CALLMONITOR 
0451 cd 7e 18			call break_point_state  
0454				endm  
# End of macro CALLMONITOR
0454				endif 
0454			 
0454			; might not be working 
0454			;	call se_writepage 
0454			 
0454			;	ret 
0454			; 
0454			 
0454			 
0454			 
0454			.wl1:    
0454			 
0454				; read physical block at hl into de 
0454			        ; increment hl and de to next read position on exit 
0454			 
0454 e5				push hl 
0455 d5				push de	 
0456 c5				push bc 
0457 1a				ld a,(de) 
0458				;if DEBUG_STORESE 
0458			;		push af 
0458			;		ld a, 'W' 
0458			;		ld (debug_mark),a 
0458			;		pop af 
0458			;		CALLMONITOR 
0458			;	endif 
0458 cd d6 01			call se_writebyte 
045b			;	call delay250ms 
045b 00				nop 
045c 00				nop 
045d 00				nop 
045e			;	if DEBUG_STORESE 
045e			;		push af 
045e			;		ld a, 'w' 
045e			;		ld (debug_mark),a 
045e			;		pop af 
045e			;		CALLMONITOR 
045e			;	endif 
045e c1				pop bc 
045f d1				pop de 
0460 e1				pop hl 
0461 23				inc hl 
0462 13				inc de 
0463			 
0463			 
0463 10 ef			djnz .wl1 
0465			 
0465				if DEBUG_STORESE 
0465					DMARK "SW2" 
0465 f5				push af  
0466 3a 7a 04			ld a, (.dmark)  
0469 32 b4 fe			ld (debug_mark),a  
046c 3a 7b 04			ld a, (.dmark+1)  
046f 32 b5 fe			ld (debug_mark+1),a  
0472 3a 7c 04			ld a, (.dmark+2)  
0475 32 b6 fe			ld (debug_mark+2),a  
0478 18 03			jr .pastdmark  
047a ..			.dmark: db "SW2"  
047d f1			.pastdmark: pop af  
047e			endm  
# End of macro DMARK
047e			 
047e					;push af 
047e					;ld a, 'W' 
047e					;ld (debug_mark),a 
047e					;pop af 
047e					CALLMONITOR 
047e cd 7e 18			call break_point_state  
0481				endm  
# End of macro CALLMONITOR
0481				endif 
0481 c9				ret	 
0482			 
0482			; Init bank 
0482			; --------- 
0482			; 
0482			; With current bank 
0482			; 
0482			; Setup block 0 config 
0482			;     Set 0 file id counter 
0482			;     Set formatted byte pattern 
0482			;     Zero out bank label 
0482			;      
0482			; For every logical block write 0-1 byte as null 
0482			 
0482			storage_get_block_0: 
0482			 
0482				; TODO check presence 
0482			 
0482				; get block 0 config 
0482			 
0482 21 00 00			ld hl, 0 
0485 11 07 fc			ld de, store_page 
0488 cd d1 03			call storage_read_block 
048b			 
048b				if DEBUG_STORESE 
048b					DMARK "SB0" 
048b f5				push af  
048c 3a a0 04			ld a, (.dmark)  
048f 32 b4 fe			ld (debug_mark),a  
0492 3a a1 04			ld a, (.dmark+1)  
0495 32 b5 fe			ld (debug_mark+1),a  
0498 3a a2 04			ld a, (.dmark+2)  
049b 32 b6 fe			ld (debug_mark+2),a  
049e 18 03			jr .pastdmark  
04a0 ..			.dmark: db "SB0"  
04a3 f1			.pastdmark: pop af  
04a4			endm  
# End of macro DMARK
04a4 11 07 fc				ld de, store_page 
04a7			;		push af 
04a7			;		ld a, 'i' 
04a7			;		ld (debug_mark),a 
04a7			;		pop af 
04a7					CALLMONITOR 
04a7 cd 7e 18			call break_point_state  
04aa				endm  
# End of macro CALLMONITOR
04aa				endif 
04aa			 
04aa				; is this area formatted? 
04aa			 
04aa			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04aa 2a 08 fc			ld hl, (store_page+1) 
04ad 3e 80			ld a,0x80 
04af bd				cp l 
04b0 20 22			jr nz, .ininotformatted 
04b2				; do a double check 
04b2 3e 27			ld a, 0x27 
04b4 bc				cp h 
04b5 20 1d			jr nz, .ininotformatted 
04b7			 
04b7				; formatted then 
04b7			 
04b7				if DEBUG_STORESE 
04b7					DMARK "SB1" 
04b7 f5				push af  
04b8 3a cc 04			ld a, (.dmark)  
04bb 32 b4 fe			ld (debug_mark),a  
04be 3a cd 04			ld a, (.dmark+1)  
04c1 32 b5 fe			ld (debug_mark+1),a  
04c4 3a ce 04			ld a, (.dmark+2)  
04c7 32 b6 fe			ld (debug_mark+2),a  
04ca 18 03			jr .pastdmark  
04cc ..			.dmark: db "SB1"  
04cf f1			.pastdmark: pop af  
04d0			endm  
# End of macro DMARK
04d0					;push af 
04d0					;ld a, 'I' 
04d0					;ld (debug_mark),a 
04d0					;pop af 
04d0					CALLMONITOR 
04d0 cd 7e 18			call break_point_state  
04d3				endm  
# End of macro CALLMONITOR
04d3				endif 
04d3 c9				ret 
04d4			 
04d4			.ininotformatted: 
04d4				; bank not formatted so poke various bits to make sure 
04d4			 
04d4				if DEBUG_STORESE 
04d4					DMARK "SB2" 
04d4 f5				push af  
04d5 3a e9 04			ld a, (.dmark)  
04d8 32 b4 fe			ld (debug_mark),a  
04db 3a ea 04			ld a, (.dmark+1)  
04de 32 b5 fe			ld (debug_mark+1),a  
04e1 3a eb 04			ld a, (.dmark+2)  
04e4 32 b6 fe			ld (debug_mark+2),a  
04e7 18 03			jr .pastdmark  
04e9 ..			.dmark: db "SB2"  
04ec f1			.pastdmark: pop af  
04ed			endm  
# End of macro DMARK
04ed					;push af 
04ed					;ld a, 'f' 
04ed					;ld (debug_mark),a 
04ed					;pop af 
04ed					CALLMONITOR 
04ed cd 7e 18			call break_point_state  
04f0				endm  
# End of macro CALLMONITOR
04f0				endif 
04f0			 
04f0 cd 0d 0c			call storage_clear_page 
04f3			 
04f3 21 07 fc			ld hl, store_page 
04f6 3e 00			ld a, 0 
04f8				 
04f8 77				ld (hl),a   ; reset file counter 
04f9			 
04f9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04fc 22 08 fc		 	ld (store_page+1), hl	 
04ff			 
04ff				; set default label 
04ff			 
04ff 21 9b 05			ld hl, .defaultbanklabl 
0502 11 0a fc		 	ld de, store_page+3 
0505 01 0f 00			ld bc, 15 
0508 ed b0			ldir 
050a			 
050a				; Append the current bank id 
050a 21 13 fc			ld hl, store_page+3+9 
050d 3a ed fb			ld a, (spi_device_id) 
0510 77				ld (hl), a 
0511			 
0511				; save default page 0 
0511			 
0511 21 00 00			ld hl, 0 
0514 11 07 fc			ld de, store_page 
0517				if DEBUG_STORESE 
0517					DMARK "SB3" 
0517 f5				push af  
0518 3a 2c 05			ld a, (.dmark)  
051b 32 b4 fe			ld (debug_mark),a  
051e 3a 2d 05			ld a, (.dmark+1)  
0521 32 b5 fe			ld (debug_mark+1),a  
0524 3a 2e 05			ld a, (.dmark+2)  
0527 32 b6 fe			ld (debug_mark+2),a  
052a 18 03			jr .pastdmark  
052c ..			.dmark: db "SB3"  
052f f1			.pastdmark: pop af  
0530			endm  
# End of macro DMARK
0530			;		push af 
0530			;		ld a, 'F' 
0530			;		ld (debug_mark),a 
0530			;		pop af 
0530					CALLMONITOR 
0530 cd 7e 18			call break_point_state  
0533				endm  
# End of macro CALLMONITOR
0533				endif 
0533 cd 36 04			call storage_write_block 
0536				if DEBUG_STORESE 
0536					DMARK "SB4" 
0536 f5				push af  
0537 3a 4b 05			ld a, (.dmark)  
053a 32 b4 fe			ld (debug_mark),a  
053d 3a 4c 05			ld a, (.dmark+1)  
0540 32 b5 fe			ld (debug_mark+1),a  
0543 3a 4d 05			ld a, (.dmark+2)  
0546 32 b6 fe			ld (debug_mark+2),a  
0549 18 03			jr .pastdmark  
054b ..			.dmark: db "SB4"  
054e f1			.pastdmark: pop af  
054f			endm  
# End of macro DMARK
054f			;		push af 
054f			;		ld a, '>' 
054f			;		ld (debug_mark),a 
054f			;		pop af 
054f					CALLMONITOR 
054f cd 7e 18			call break_point_state  
0552				endm  
# End of macro CALLMONITOR
0552				endif 
0552			 
0552 00				nop 
0553 00				nop 
0554 00				nop 
0555			 
0555				; now set 0 in every page to mark as a free block 
0555			 
0555 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0557 21 40 00			ld hl, STORE_BLOCK_PHY 
055a			 
055a 3e 00		.setmark1:   	ld a,0 
055c e5					push hl 
055d c5					push bc 
055e cd d6 01				call se_writebyte 
0561 3e 0a			ld a, 10 
0563 cd 2f 0c			call aDelayInMS 
0566 23				inc hl 
0567 cd d6 01				call se_writebyte 
056a 3e 0a			ld a, 10 
056c cd 2f 0c			call aDelayInMS 
056f 2b				dec hl 
0570 c1					pop bc 
0571 e1					pop hl 
0572 3e 40				ld a, STORE_BLOCK_PHY 
0574 cd 01 0f				call addatohl 
0577 10 e1				djnz .setmark1 
0579			 
0579 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
057b 3e 00		.setmark2:   	ld a,0 
057d e5					push hl 
057e c5					push bc 
057f cd d6 01				call se_writebyte 
0582 3e 0a			ld a, 10 
0584 cd 2f 0c			call aDelayInMS 
0587 23				inc hl 
0588 cd d6 01				call se_writebyte 
058b 3e 0a			ld a, 10 
058d cd 2f 0c			call aDelayInMS 
0590 2b				dec hl 
0591 c1					pop bc 
0592 e1					pop hl 
0593 3e 40				ld a, STORE_BLOCK_PHY 
0595 cd 01 0f				call addatohl 
0598 10 e1				djnz .setmark2 
059a			 
059a					 
059a			 
059a			 
059a c9				ret 
059b			 
059b			 
059b			 
059b			 
059b .. 00		.defaultbanklabl:   db "BankLabel_",0 
05a6			 
05a6			 
05a6			 
05a6			; Label Bank 
05a6			; ---------- 
05a6			; 
05a6			; With current bank 
05a6			; Read block 0 
05a6			; Set label 
05a6			; Write block 0 
05a6			 
05a6			; label str pointer in hl 
05a6			 
05a6			storage_label:     
05a6			 
05a6				if DEBUG_STORESE 
05a6					DMARK "LBL" 
05a6 f5				push af  
05a7 3a bb 05			ld a, (.dmark)  
05aa 32 b4 fe			ld (debug_mark),a  
05ad 3a bc 05			ld a, (.dmark+1)  
05b0 32 b5 fe			ld (debug_mark+1),a  
05b3 3a bd 05			ld a, (.dmark+2)  
05b6 32 b6 fe			ld (debug_mark+2),a  
05b9 18 03			jr .pastdmark  
05bb ..			.dmark: db "LBL"  
05be f1			.pastdmark: pop af  
05bf			endm  
# End of macro DMARK
05bf					CALLMONITOR 
05bf cd 7e 18			call break_point_state  
05c2				endm  
# End of macro CALLMONITOR
05c2				endif 
05c2			 
05c2 e5				push hl 
05c3			 
05c3 cd 82 04			call storage_get_block_0 
05c6			 
05c6				; set default label 
05c6			 
05c6 e1				pop hl 
05c7			 
05c7 11 0a fc		 	ld de, store_page+3 
05ca 01 0f 00			ld bc, 15 
05cd				if DEBUG_STORESE 
05cd					DMARK "LB3" 
05cd f5				push af  
05ce 3a e2 05			ld a, (.dmark)  
05d1 32 b4 fe			ld (debug_mark),a  
05d4 3a e3 05			ld a, (.dmark+1)  
05d7 32 b5 fe			ld (debug_mark+1),a  
05da 3a e4 05			ld a, (.dmark+2)  
05dd 32 b6 fe			ld (debug_mark+2),a  
05e0 18 03			jr .pastdmark  
05e2 ..			.dmark: db "LB3"  
05e5 f1			.pastdmark: pop af  
05e6			endm  
# End of macro DMARK
05e6					CALLMONITOR 
05e6 cd 7e 18			call break_point_state  
05e9				endm  
# End of macro CALLMONITOR
05e9				endif 
05e9 ed b0			ldir 
05eb				; save default page 0 
05eb			 
05eb 21 00 00			ld hl, 0 
05ee 11 07 fc			ld de, store_page 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBW" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 b4 fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 b5 fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 b6 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBW"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd 7e 18			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d cd 36 04			call storage_write_block 
0610			 
0610 c9				ret 
0611			 
0611			 
0611			 
0611			; Read Block 0 - Config 
0611			; --------------------- 
0611			; 
0611			; With current bank 
0611			; Call presence test 
0611			;    If not present format/init bank  
0611			; Read block 0  
0611			;  
0611			 
0611			 
0611			; Dir 
0611			; --- 
0611			; 
0611			; With current bank 
0611			; Load Block 0 Config 
0611			; Get max file id number 
0611			; For each logical block 
0611			;    Read block read byte 2 
0611			;      if first block of file 
0611			;         Display file name 
0611			;         Display type flags for file 
0611			;        
0611			 
0611			; moving to words as this requires stack control 
0611			 
0611			 
0611			; Delete File 
0611			; ----------- 
0611			; 
0611			; With current bank 
0611			; 
0611			; Load Block 0 Config 
0611			; Get max file id number 
0611			; For each logical block 
0611			;    Read block file id 
0611			;      If first block of file and dont have file id 
0611			;         if file to delete 
0611			;         Save file id 
0611			;         Null file id 
0611			;         Write this block back 
0611			;      If file id is one saved 
0611			;         Null file id 
0611			;         Write this block back 
0611			 
0611			 
0611			.se_done: 
0611 e1				pop hl 
0612 c9				ret 
0613			 
0613			storage_erase: 
0613			 
0613				; hl contains the file id 
0613			 
0613 5d				ld e, l 
0614 16 00			ld d, 0 
0616 21 40 00			ld hl, STORE_BLOCK_PHY 
0619					if DEBUG_FORTH_WORDS 
0619						DMARK "ERA" 
0619 f5				push af  
061a 3a 2e 06			ld a, (.dmark)  
061d 32 b4 fe			ld (debug_mark),a  
0620 3a 2f 06			ld a, (.dmark+1)  
0623 32 b5 fe			ld (debug_mark+1),a  
0626 3a 30 06			ld a, (.dmark+2)  
0629 32 b6 fe			ld (debug_mark+2),a  
062c 18 03			jr .pastdmark  
062e ..			.dmark: db "ERA"  
0631 f1			.pastdmark: pop af  
0632			endm  
# End of macro DMARK
0632						CALLMONITOR 
0632 cd 7e 18			call break_point_state  
0635				endm  
# End of macro CALLMONITOR
0635					endif 
0635 cd 04 07			call storage_findnextid 
0638 cd 2a 0f			call ishlzero 
063b c8				ret z 
063c			 
063c e5				push hl 
063d			 
063d				; TODO check file not found 
063d			 
063d 11 07 fc			ld de, store_page 
0640 cd d1 03			call storage_read_block 
0643			 
0643 cd 2a 0f			call ishlzero 
0646 ca 11 06			jp z,.se_done 
0649			 
0649					if DEBUG_FORTH_WORDS 
0649						DMARK "ER1" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 b4 fe			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 b5 fe			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 b6 fe			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "ER1"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662						CALLMONITOR 
0662 cd 7e 18			call break_point_state  
0665				endm  
# End of macro CALLMONITOR
0665					endif 
0665 3a 07 fc			ld a, (store_page)	; get file id 
0668 32 fb fb			ld (store_tmpid), a 
066b			 
066b 3a 09 fc			ld a, (store_page+2)    ; get count of extends 
066e 32 fa fb			ld (store_tmpext), a 
0671			 
0671				; wipe file header 
0671			 
0671 e1				pop hl 
0672 3e 00			ld a, 0 
0674 32 07 fc			ld (store_page), a 
0677 32 08 fc			ld (store_page+1),a 
067a 11 07 fc			ld de, store_page 
067d					if DEBUG_FORTH_WORDS 
067d						DMARK "ER2" 
067d f5				push af  
067e 3a 92 06			ld a, (.dmark)  
0681 32 b4 fe			ld (debug_mark),a  
0684 3a 93 06			ld a, (.dmark+1)  
0687 32 b5 fe			ld (debug_mark+1),a  
068a 3a 94 06			ld a, (.dmark+2)  
068d 32 b6 fe			ld (debug_mark+2),a  
0690 18 03			jr .pastdmark  
0692 ..			.dmark: db "ER2"  
0695 f1			.pastdmark: pop af  
0696			endm  
# End of macro DMARK
0696						CALLMONITOR 
0696 cd 7e 18			call break_point_state  
0699				endm  
# End of macro CALLMONITOR
0699					endif 
0699 cd 36 04			call storage_write_block 
069c			 
069c			 
069c				; wipe file extents 
069c			 
069c 3a fa fb			ld a, (store_tmpext) 
069f 47				ld b, a 
06a0			 
06a0			.eraext:	  
06a0 c5				push bc 
06a1			 
06a1 21 40 00			ld hl, STORE_BLOCK_PHY 
06a4 3a fb fb			ld a,(store_tmpid) 
06a7 5f				ld e, a 
06a8 50				ld d, b	 
06a9					if DEBUG_FORTH_WORDS 
06a9						DMARK "ER3" 
06a9 f5				push af  
06aa 3a be 06			ld a, (.dmark)  
06ad 32 b4 fe			ld (debug_mark),a  
06b0 3a bf 06			ld a, (.dmark+1)  
06b3 32 b5 fe			ld (debug_mark+1),a  
06b6 3a c0 06			ld a, (.dmark+2)  
06b9 32 b6 fe			ld (debug_mark+2),a  
06bc 18 03			jr .pastdmark  
06be ..			.dmark: db "ER3"  
06c1 f1			.pastdmark: pop af  
06c2			endm  
# End of macro DMARK
06c2						CALLMONITOR 
06c2 cd 7e 18			call break_point_state  
06c5				endm  
# End of macro CALLMONITOR
06c5					endif 
06c5 cd 04 07			call storage_findnextid 
06c8 cd 2a 0f			call ishlzero 
06cb ca 11 06			jp z,.se_done 
06ce			 
06ce e5				push hl 
06cf 11 07 fc			ld de, store_page 
06d2 cd d1 03			call storage_read_block 
06d5			 
06d5				; free block	 
06d5			 
06d5 3e 00			ld a, 0 
06d7 32 07 fc			ld (store_page), a 
06da 32 08 fc			ld (store_page+1),a 
06dd 11 07 fc			ld de, store_page 
06e0 e1				pop hl 
06e1					if DEBUG_FORTH_WORDS 
06e1						DMARK "ER4" 
06e1 f5				push af  
06e2 3a f6 06			ld a, (.dmark)  
06e5 32 b4 fe			ld (debug_mark),a  
06e8 3a f7 06			ld a, (.dmark+1)  
06eb 32 b5 fe			ld (debug_mark+1),a  
06ee 3a f8 06			ld a, (.dmark+2)  
06f1 32 b6 fe			ld (debug_mark+2),a  
06f4 18 03			jr .pastdmark  
06f6 ..			.dmark: db "ER4"  
06f9 f1			.pastdmark: pop af  
06fa			endm  
# End of macro DMARK
06fa						CALLMONITOR 
06fa cd 7e 18			call break_point_state  
06fd				endm  
# End of macro CALLMONITOR
06fd					endif 
06fd cd 36 04			call storage_write_block 
0700			 
0700 c1				pop bc 
0701 10 9d			djnz .eraext 
0703			 
0703 c9				ret 
0704			 
0704			 
0704			; Find Free Block 
0704			; --------------- 
0704			; 
0704			; With current bank 
0704			;  
0704			; From given starting logical block 
0704			;    Read block  
0704			;    If no file id 
0704			;         Return block id 
0704			 
0704			 
0704			; hl starting page number 
0704			; hl contains free page number or zero if no pages free 
0704			; e contains the file id to locate 
0704			; d contains the block number 
0704			 
0704			; TODO change to find file id and use zero for free block 
0704			 
0704			storage_findnextid: 
0704			 
0704				; now locate first 0 page to mark as a free block 
0704			 
0704 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0706			;	ld hl, STORE_BLOCK_PHY 
0706			 
0706					if DEBUG_FORTH_WORDS 
0706					DMARK "FNI" 
0706 f5				push af  
0707 3a 1b 07			ld a, (.dmark)  
070a 32 b4 fe			ld (debug_mark),a  
070d 3a 1c 07			ld a, (.dmark+1)  
0710 32 b5 fe			ld (debug_mark+1),a  
0713 3a 1d 07			ld a, (.dmark+2)  
0716 32 b6 fe			ld (debug_mark+2),a  
0719 18 03			jr .pastdmark  
071b ..			.dmark: db "FNI"  
071e f1			.pastdmark: pop af  
071f			endm  
# End of macro DMARK
071f						CALLMONITOR 
071f cd 7e 18			call break_point_state  
0722				endm  
# End of macro CALLMONITOR
0722					endif 
0722			.ff1:   	 
0722 e5					push hl 
0723 c5					push bc 
0724 d5					push de 
0725 cd 78 02				call se_readbyte 
0728 5f					ld e,a 
0729 23					inc hl 
072a cd 78 02				call se_readbyte 
072d 57					ld d, a 
072e e1					pop hl 
072f e5					push hl 
0730 cd 1f 0f				call cmp16 
0733 28 49				jr z, .fffound 
0735			 
0735 d1					pop de 
0736 c1					pop bc 
0737 e1					pop hl 
0738			 
0738					; is found? 
0738					;cp e 
0738					;ret z 
0738			 
0738 3e 40				ld a, STORE_BLOCK_PHY 
073a cd 01 0f				call addatohl 
073d 10 e3				djnz .ff1 
073f			 
073f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0741			.ff2:   	 
0741			 
0741 e5					push hl 
0742 c5					push bc 
0743 d5					push de 
0744 cd 78 02				call se_readbyte 
0747 5f					ld e,a 
0748 23					inc hl 
0749 cd 78 02				call se_readbyte 
074c 57					ld d, a 
074d			 
074d e1					pop hl 
074e e5					push hl 
074f cd 1f 0f				call cmp16 
0752 28 2a				jr z, .fffound 
0754			 
0754 d1					pop de 
0755 c1					pop bc 
0756 e1					pop hl 
0757					; is found? 
0757					;cp e 
0757					;ret z 
0757			 
0757 3e 40				ld a, STORE_BLOCK_PHY 
0759 cd 01 0f				call addatohl 
075c 10 e3				djnz .ff2 
075e			 
075e			 
075e					if DEBUG_FORTH_WORDS 
075e					DMARK "FN-" 
075e f5				push af  
075f 3a 73 07			ld a, (.dmark)  
0762 32 b4 fe			ld (debug_mark),a  
0765 3a 74 07			ld a, (.dmark+1)  
0768 32 b5 fe			ld (debug_mark+1),a  
076b 3a 75 07			ld a, (.dmark+2)  
076e 32 b6 fe			ld (debug_mark+2),a  
0771 18 03			jr .pastdmark  
0773 ..			.dmark: db "FN-"  
0776 f1			.pastdmark: pop af  
0777			endm  
# End of macro DMARK
0777					;	push af 
0777					;	ld a, 'n' 
0777					;	ld (debug_mark),a 
0777					;	pop af 
0777						CALLMONITOR 
0777 cd 7e 18			call break_point_state  
077a				endm  
# End of macro CALLMONITOR
077a					endif 
077a				; no free marks! 
077a 21 00 00				ld hl, 0 
077d c9				ret 
077e			.fffound: 
077e				 
077e			 
077e d1					pop de 
077f c1					pop bc 
0780 e1					pop hl 
0781					if DEBUG_FORTH_WORDS 
0781					DMARK "FNF" 
0781 f5				push af  
0782 3a 96 07			ld a, (.dmark)  
0785 32 b4 fe			ld (debug_mark),a  
0788 3a 97 07			ld a, (.dmark+1)  
078b 32 b5 fe			ld (debug_mark+1),a  
078e 3a 98 07			ld a, (.dmark+2)  
0791 32 b6 fe			ld (debug_mark+2),a  
0794 18 03			jr .pastdmark  
0796 ..			.dmark: db "FNF"  
0799 f1			.pastdmark: pop af  
079a			endm  
# End of macro DMARK
079a					;	push af 
079a					;	ld a, 'n' 
079a					;	ld (debug_mark),a 
079a					;	pop af 
079a						CALLMONITOR 
079a cd 7e 18			call break_point_state  
079d				endm  
# End of macro CALLMONITOR
079d					endif 
079d c9				ret 
079e			 
079e			 
079e			 
079e			; Free Space 
079e			; ---------- 
079e			; 
079e			; With current bank 
079e			; 
079e			; Set block count to zero 
079e			; Starting with first logical block 
079e			;      Find free block  
079e			;      If block id given, increment block count 
079e			; 
079e			;  
079e			 
079e			 
079e			; hl contains count of free blocks 
079e			 
079e			storage_freeblocks: 
079e			 
079e				; now locate first 0 page to mark as a free block 
079e			 
079e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a0 21 40 00			ld hl, STORE_BLOCK_PHY 
07a3 11 00 00			ld de, 0 
07a6			 
07a6			.fb1:   	 
07a6 e5					push hl 
07a7 c5					push bc 
07a8 d5					push de 
07a9 cd 78 02				call se_readbyte 
07ac d1					pop de 
07ad c1					pop bc 
07ae e1					pop hl 
07af			 
07af					; is free? 
07af fe 00				cp 0 
07b1 20 01				jr nz, .ff1cont 
07b3 13					inc de 
07b4			 
07b4			.ff1cont: 
07b4			 
07b4			 
07b4 3e 40				ld a, STORE_BLOCK_PHY 
07b6 cd 01 0f				call addatohl 
07b9 10 eb				djnz .fb1 
07bb			 
07bb 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07bd			.fb2:   	 
07bd e5					push hl 
07be c5					push bc 
07bf d5					push de 
07c0 cd 78 02				call se_readbyte 
07c3 d1					pop de 
07c4 c1					pop bc 
07c5 e1					pop hl 
07c6			 
07c6					; is free? 
07c6 fe 00				cp 0 
07c8 20 01				jr nz, .ff2cont 
07ca 13					inc de 
07cb			 
07cb			.ff2cont: 
07cb			 
07cb 3e 40				ld a, STORE_BLOCK_PHY 
07cd cd 01 0f				call addatohl 
07d0 10 eb				djnz .fb2 
07d2			 
07d2 eb				ex de, hl 
07d3 c9				ret 
07d4			 
07d4			; Get File ID 
07d4			; ----------- 
07d4			; 
07d4			; With current bank 
07d4			;  
07d4			; Load Block 0 Config 
07d4			; Get max file id number 
07d4			; For each logical block 
07d4			;    Read block file id 
07d4			;      If first block of file and dont have file id 
07d4			;         if file get id and exit 
07d4			 
07d4			 
07d4			 
07d4			 
07d4			; Create File 
07d4			; ----------- 
07d4			; 
07d4			; With current bank  
07d4			; Load Block 0 Config 
07d4			; Get max file id number 
07d4			; Increment file id number 
07d4			; Save Config 
07d4			; Find free block 
07d4			; Set buffer with file name and file id 
07d4			; Write buffer to free block  
07d4			 
07d4			 
07d4			; hl point to file name 
07d4			; hl returns file id 
07d4			 
07d4			; file format: 
07d4			; byte 0 - file id 
07d4			; byte 1 - extent number 
07d4			; byte 2-> data 
07d4			 
07d4			; format for extent number 0: 
07d4			; 
07d4			; byte 0 - file id 
07d4			; byte 1 - extent 0 
07d4			; byte 2 - extent count 
07d4			; byte 3 -> file name and meta data 
07d4			 
07d4			 
07d4			storage_create: 
07d4				if DEBUG_STORESE 
07d4					DMARK "SCR" 
07d4 f5				push af  
07d5 3a e9 07			ld a, (.dmark)  
07d8 32 b4 fe			ld (debug_mark),a  
07db 3a ea 07			ld a, (.dmark+1)  
07de 32 b5 fe			ld (debug_mark+1),a  
07e1 3a eb 07			ld a, (.dmark+2)  
07e4 32 b6 fe			ld (debug_mark+2),a  
07e7 18 03			jr .pastdmark  
07e9 ..			.dmark: db "SCR"  
07ec f1			.pastdmark: pop af  
07ed			endm  
# End of macro DMARK
07ed					CALLMONITOR 
07ed cd 7e 18			call break_point_state  
07f0				endm  
# End of macro CALLMONITOR
07f0				endif 
07f0			 
07f0 e5				push hl		; save file name pointer 
07f1			 
07f1 cd 82 04			call storage_get_block_0 
07f4			 
07f4 3a 07 fc			ld a,(store_page)	; get current file id 
07f7 3c				inc a 
07f8 32 07 fc			ld (store_page),a 
07fb				 
07fb 32 fb fb			ld (store_tmpid),a			; save id 
07fe			 
07fe 21 00 00			ld hl, 0 
0801 11 07 fc			ld de, store_page 
0804				if DEBUG_STORESE 
0804					DMARK "SCw" 
0804 f5				push af  
0805 3a 19 08			ld a, (.dmark)  
0808 32 b4 fe			ld (debug_mark),a  
080b 3a 1a 08			ld a, (.dmark+1)  
080e 32 b5 fe			ld (debug_mark+1),a  
0811 3a 1b 08			ld a, (.dmark+2)  
0814 32 b6 fe			ld (debug_mark+2),a  
0817 18 03			jr .pastdmark  
0819 ..			.dmark: db "SCw"  
081c f1			.pastdmark: pop af  
081d			endm  
# End of macro DMARK
081d					CALLMONITOR 
081d cd 7e 18			call break_point_state  
0820				endm  
# End of macro CALLMONITOR
0820				endif 
0820 cd 36 04			call storage_write_block	 ; save update 
0823			 
0823				if DEBUG_STORESE 
0823 11 07 fc				ld de, store_page 
0826					DMARK "SCC" 
0826 f5				push af  
0827 3a 3b 08			ld a, (.dmark)  
082a 32 b4 fe			ld (debug_mark),a  
082d 3a 3c 08			ld a, (.dmark+1)  
0830 32 b5 fe			ld (debug_mark+1),a  
0833 3a 3d 08			ld a, (.dmark+2)  
0836 32 b6 fe			ld (debug_mark+2),a  
0839 18 03			jr .pastdmark  
083b ..			.dmark: db "SCC"  
083e f1			.pastdmark: pop af  
083f			endm  
# End of macro DMARK
083f					CALLMONITOR 
083f cd 7e 18			call break_point_state  
0842				endm  
# End of macro CALLMONITOR
0842				endif 
0842				;  
0842				 
0842 21 40 00			ld hl, STORE_BLOCK_PHY 
0845 11 00 00			ld de, 0 
0848 cd 04 07			call storage_findnextid 
084b			 
084b 22 f2 fb			ld (store_tmppageid), hl    ; save page to use  
084e			 
084e				; TODO detect 0 = no spare blocks 
084e			 
084e				; hl now contains the free page to use for the file header page 
084e			 
084e				if DEBUG_STORESE 
084e				DMARK "SCF" 
084e f5				push af  
084f 3a 63 08			ld a, (.dmark)  
0852 32 b4 fe			ld (debug_mark),a  
0855 3a 64 08			ld a, (.dmark+1)  
0858 32 b5 fe			ld (debug_mark+1),a  
085b 3a 65 08			ld a, (.dmark+2)  
085e 32 b6 fe			ld (debug_mark+2),a  
0861 18 03			jr .pastdmark  
0863 ..			.dmark: db "SCF"  
0866 f1			.pastdmark: pop af  
0867			endm  
# End of macro DMARK
0867					CALLMONITOR 
0867 cd 7e 18			call break_point_state  
086a				endm  
# End of macro CALLMONITOR
086a				endif 
086a			 
086a 22 f2 fb			ld (store_tmppageid), hl 
086d				 
086d 3a fb fb			ld a,(store_tmpid)    ; get file id 
0870			;	ld a, (store_filecache)			; save to cache 
0870			 
0870 32 07 fc			ld (store_page),a    ; set page id 
0873 3e 00			ld a, 0			 ; extent 0 is file header 
0875 32 08 fc			ld (store_page+1), a   ; set file extent 
0878			 
0878 32 09 fc			ld (store_page+2), a   ; extent count for the file 
087b			 
087b			;	inc hl 		; init block 0 of file 
087b			;	inc hl   		; skip file and extent id 
087b			 ;       ld a, 0 
087b			;	ld (hl),a 
087b			;	ld a, (store_filecache+1)  	; save to cache 
087b			 
087b			;	inc hl    ; file name 
087b				 
087b				 
087b 11 0a fc			ld de, store_page+3    ; get buffer for term string to use as file name 
087e				if DEBUG_STORESE 
087e					DMARK "SCc" 
087e f5				push af  
087f 3a 93 08			ld a, (.dmark)  
0882 32 b4 fe			ld (debug_mark),a  
0885 3a 94 08			ld a, (.dmark+1)  
0888 32 b5 fe			ld (debug_mark+1),a  
088b 3a 95 08			ld a, (.dmark+2)  
088e 32 b6 fe			ld (debug_mark+2),a  
0891 18 03			jr .pastdmark  
0893 ..			.dmark: db "SCc"  
0896 f1			.pastdmark: pop af  
0897			endm  
# End of macro DMARK
0897					CALLMONITOR 
0897 cd 7e 18			call break_point_state  
089a				endm  
# End of macro CALLMONITOR
089a				endif 
089a e1				pop hl    ; get zero term string 
089b e5				push hl 
089c 3e 00			ld a, 0 
089e cd 6a 13			call strlent 
08a1 23				inc hl   ; cover zero term 
08a2 06 00			ld b,0 
08a4 4d				ld c,l 
08a5 e1				pop hl 
08a6				;ex de, hl 
08a6				if DEBUG_STORESE 
08a6					DMARK "SCa" 
08a6 f5				push af  
08a7 3a bb 08			ld a, (.dmark)  
08aa 32 b4 fe			ld (debug_mark),a  
08ad 3a bc 08			ld a, (.dmark+1)  
08b0 32 b5 fe			ld (debug_mark+1),a  
08b3 3a bd 08			ld a, (.dmark+2)  
08b6 32 b6 fe			ld (debug_mark+2),a  
08b9 18 03			jr .pastdmark  
08bb ..			.dmark: db "SCa"  
08be f1			.pastdmark: pop af  
08bf			endm  
# End of macro DMARK
08bf					;push af 
08bf					;ld a, 'a' 
08bf					;ld (debug_mark),a 
08bf					;pop af 
08bf					CALLMONITOR 
08bf cd 7e 18			call break_point_state  
08c2				endm  
# End of macro CALLMONITOR
08c2				endif 
08c2 ed b0			ldir    ; copy zero term string 
08c4				if DEBUG_STORESE 
08c4					DMARK "SCA" 
08c4 f5				push af  
08c5 3a d9 08			ld a, (.dmark)  
08c8 32 b4 fe			ld (debug_mark),a  
08cb 3a da 08			ld a, (.dmark+1)  
08ce 32 b5 fe			ld (debug_mark+1),a  
08d1 3a db 08			ld a, (.dmark+2)  
08d4 32 b6 fe			ld (debug_mark+2),a  
08d7 18 03			jr .pastdmark  
08d9 ..			.dmark: db "SCA"  
08dc f1			.pastdmark: pop af  
08dd			endm  
# End of macro DMARK
08dd					CALLMONITOR 
08dd cd 7e 18			call break_point_state  
08e0				endm  
# End of macro CALLMONITOR
08e0				endif 
08e0			 
08e0				; write file header page 
08e0			 
08e0 2a f2 fb			ld hl,(store_tmppageid) 
08e3 11 07 fc			ld de, store_page 
08e6				if DEBUG_STORESE 
08e6					DMARK "SCb" 
08e6 f5				push af  
08e7 3a fb 08			ld a, (.dmark)  
08ea 32 b4 fe			ld (debug_mark),a  
08ed 3a fc 08			ld a, (.dmark+1)  
08f0 32 b5 fe			ld (debug_mark+1),a  
08f3 3a fd 08			ld a, (.dmark+2)  
08f6 32 b6 fe			ld (debug_mark+2),a  
08f9 18 03			jr .pastdmark  
08fb ..			.dmark: db "SCb"  
08fe f1			.pastdmark: pop af  
08ff			endm  
# End of macro DMARK
08ff					;push af 
08ff					;ld a, 'b' 
08ff					;ld (debug_mark),a 
08ff					;pop af 
08ff					CALLMONITOR 
08ff cd 7e 18			call break_point_state  
0902				endm  
# End of macro CALLMONITOR
0902				endif 
0902 cd 36 04			call storage_write_block 
0905			 
0905 3a fb fb			ld a, (store_tmpid) 
0908 6f				ld l, a 
0909 26 00			ld h,0 
090b				if DEBUG_STORESE 
090b					DMARK "SCz" 
090b f5				push af  
090c 3a 20 09			ld a, (.dmark)  
090f 32 b4 fe			ld (debug_mark),a  
0912 3a 21 09			ld a, (.dmark+1)  
0915 32 b5 fe			ld (debug_mark+1),a  
0918 3a 22 09			ld a, (.dmark+2)  
091b 32 b6 fe			ld (debug_mark+2),a  
091e 18 03			jr .pastdmark  
0920 ..			.dmark: db "SCz"  
0923 f1			.pastdmark: pop af  
0924			endm  
# End of macro DMARK
0924					CALLMONITOR 
0924 cd 7e 18			call break_point_state  
0927				endm  
# End of macro CALLMONITOR
0927				endif 
0927 c9				ret 
0928				 
0928			 
0928			 
0928			; 
0928			; Read File 
0928			; 
0928			; h - file id to locate 
0928			; l - extent to locate 
0928			; de - pointer to string to read into 
0928			; 
0928			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0928			 
0928			.sr_fail: 
0928 d1				pop de 
0929 c9				ret 
092a			 
092a			storage_read: 
092a			 
092a			 
092a d5				push de 
092b			 
092b			; TODO BUG the above push is it popped before the RET Z? 
092b			 
092b			; TODO how to handle multiple part blocks 
092b			 
092b				; locate file extent to read 
092b			 
092b 5c				ld e, h 
092c 55				ld d, l 
092d			 
092d			.srext: 
092d 22 05 fc			ld (store_readptr), hl     ; save the current extent to load 
0930 ed 53 03 fc		ld (store_readbuf), de     ; save the current buffer to load in to 
0934			 
0934 21 40 00			ld hl, STORE_BLOCK_PHY 
0937				if DEBUG_STORESE 
0937					DMARK "sre" 
0937 f5				push af  
0938 3a 4c 09			ld a, (.dmark)  
093b 32 b4 fe			ld (debug_mark),a  
093e 3a 4d 09			ld a, (.dmark+1)  
0941 32 b5 fe			ld (debug_mark+1),a  
0944 3a 4e 09			ld a, (.dmark+2)  
0947 32 b6 fe			ld (debug_mark+2),a  
094a 18 03			jr .pastdmark  
094c ..			.dmark: db "sre"  
094f f1			.pastdmark: pop af  
0950			endm  
# End of macro DMARK
0950					CALLMONITOR 
0950 cd 7e 18			call break_point_state  
0953				endm  
# End of macro CALLMONITOR
0953				endif 
0953 cd 04 07			call storage_findnextid 
0956			 
0956				if DEBUG_STORESE 
0956					DMARK "srf" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 b4 fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 b5 fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 b6 fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "srf"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd 7e 18			call break_point_state  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 cd 2a 0f			call ishlzero 
0975			;	ld a, l 
0975			;	add h 
0975			;	cp 0 
0975 28 b1			jr z,.sr_fail			; block not found so EOF 
0977			 
0977				; save current address for use by higher level words etc 
0977			 
0977 22 f8 fb			ld (store_openaddr),hl 
097a			 
097a			 
097a				; hl contains page number to load 
097a d1				pop de   ; get storage 
097b ed 53 03 fc		ld (store_readbuf), de     ; current buffer to load in to 
097f d5				push de 
0980				if DEBUG_STORESE 
0980					DMARK "srg" 
0980 f5				push af  
0981 3a 95 09			ld a, (.dmark)  
0984 32 b4 fe			ld (debug_mark),a  
0987 3a 96 09			ld a, (.dmark+1)  
098a 32 b5 fe			ld (debug_mark+1),a  
098d 3a 97 09			ld a, (.dmark+2)  
0990 32 b6 fe			ld (debug_mark+2),a  
0993 18 03			jr .pastdmark  
0995 ..			.dmark: db "srg"  
0998 f1			.pastdmark: pop af  
0999			endm  
# End of macro DMARK
0999					CALLMONITOR 
0999 cd 7e 18			call break_point_state  
099c				endm  
# End of macro CALLMONITOR
099c				endif 
099c cd d1 03			call storage_read_block 
099f			 
099f				; if this a continuation read??? 
099f			 
099f 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
09a2			 
09a2 3e 3f			ld a, STORE_BLOCK_PHY-1 
09a4 cd 01 0f			call addatohl 
09a7 7e				ld a,(hl) 
09a8 fe 00			cp 0 
09aa 28 02			jr z, .markiscont 
09ac 3e ff			ld a, 255 
09ae			 
09ae			.markiscont: 
09ae 32 fa fb			ld (store_readcont), a 
09b1			 
09b1				if DEBUG_STORESE 
09b1					DMARK "srC" 
09b1 f5				push af  
09b2 3a c6 09			ld a, (.dmark)  
09b5 32 b4 fe			ld (debug_mark),a  
09b8 3a c7 09			ld a, (.dmark+1)  
09bb 32 b5 fe			ld (debug_mark+1),a  
09be 3a c8 09			ld a, (.dmark+2)  
09c1 32 b6 fe			ld (debug_mark+2),a  
09c4 18 03			jr .pastdmark  
09c6 ..			.dmark: db "srC"  
09c9 f1			.pastdmark: pop af  
09ca			endm  
# End of macro DMARK
09ca					CALLMONITOR 
09ca cd 7e 18			call break_point_state  
09cd				endm  
# End of macro CALLMONITOR
09cd				endif 
09cd				; only short reads enabled 
09cd			 
09cd 3a 02 fc			ld a, (store_longread) 
09d0 fe 00			cp 0 
09d2 ca 9f 0a			jp z, .readdone 
09d5			 
09d5			; TODO if block has no zeros then need to read next block  
09d5			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
09d5			; check last byte of physical block. 
09d5			; if not zero then the next block needs to be loaded 
09d5			 
09d5			 
09d5 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
09d8			 
09d8 3e 3f			ld a, STORE_BLOCK_PHY-1 
09da cd 01 0f			call addatohl 
09dd				;dec hl 
09dd 7e				ld a,(hl) 
09de				if DEBUG_STORESE 
09de					DMARK "sr?" 
09de f5				push af  
09df 3a f3 09			ld a, (.dmark)  
09e2 32 b4 fe			ld (debug_mark),a  
09e5 3a f4 09			ld a, (.dmark+1)  
09e8 32 b5 fe			ld (debug_mark+1),a  
09eb 3a f5 09			ld a, (.dmark+2)  
09ee 32 b6 fe			ld (debug_mark+2),a  
09f1 18 03			jr .pastdmark  
09f3 ..			.dmark: db "sr?"  
09f6 f1			.pastdmark: pop af  
09f7			endm  
# End of macro DMARK
09f7					CALLMONITOR 
09f7 cd 7e 18			call break_point_state  
09fa				endm  
# End of macro CALLMONITOR
09fa				endif 
09fa fe 00			cp 0 
09fc ca 9f 0a			jp z, .readdone 
09ff			 
09ff				; last byte is not zero so there is more in the next extent. Load it on the end.	 
09ff			 
09ff 23				inc hl 
0a00			 
0a00 22 03 fc			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a03			 
0a03 ed 5b 05 fc		ld de, (store_readptr)     ; save the current extent to load 
0a07			 
0a07 eb				ex de, hl 
0a08			 
0a08				; next ext 
0a08			 
0a08 23				inc hl 
0a09 22 05 fc			ld  (store_readptr), hl     ; save the current extent to load 
0a0c			 
0a0c				if DEBUG_STORESE 
0a0c					DMARK "sF2" 
0a0c f5				push af  
0a0d 3a 21 0a			ld a, (.dmark)  
0a10 32 b4 fe			ld (debug_mark),a  
0a13 3a 22 0a			ld a, (.dmark+1)  
0a16 32 b5 fe			ld (debug_mark+1),a  
0a19 3a 23 0a			ld a, (.dmark+2)  
0a1c 32 b6 fe			ld (debug_mark+2),a  
0a1f 18 03			jr .pastdmark  
0a21 ..			.dmark: db "sF2"  
0a24 f1			.pastdmark: pop af  
0a25			endm  
# End of macro DMARK
0a25					CALLMONITOR 
0a25 cd 7e 18			call break_point_state  
0a28				endm  
# End of macro CALLMONITOR
0a28				endif 
0a28			 
0a28				; get and load block 
0a28			 
0a28 cd 04 07			call storage_findnextid 
0a2b			 
0a2b				if DEBUG_STORESE 
0a2b					DMARK "sf2" 
0a2b f5				push af  
0a2c 3a 40 0a			ld a, (.dmark)  
0a2f 32 b4 fe			ld (debug_mark),a  
0a32 3a 41 0a			ld a, (.dmark+1)  
0a35 32 b5 fe			ld (debug_mark+1),a  
0a38 3a 42 0a			ld a, (.dmark+2)  
0a3b 32 b6 fe			ld (debug_mark+2),a  
0a3e 18 03			jr .pastdmark  
0a40 ..			.dmark: db "sf2"  
0a43 f1			.pastdmark: pop af  
0a44			endm  
# End of macro DMARK
0a44					CALLMONITOR 
0a44 cd 7e 18			call break_point_state  
0a47				endm  
# End of macro CALLMONITOR
0a47				endif 
0a47 cd 2a 0f			call ishlzero 
0a4a			;	ld a, l 
0a4a			;	add h 
0a4a			;	cp 0 
0a4a ca 28 09			jp z,.sr_fail			; block not found so EOF 
0a4d				 
0a4d				; save current address for use by higher level words etc 
0a4d			 
0a4d 22 f8 fb			ld (store_openaddr),hl 
0a50			 
0a50 cd d1 03			call storage_read_block 
0a53			 
0a53				; on a continuation block, we now have the file id and ext in the middle of the block 
0a53				; we need to pull everything back  
0a53			 
0a53 ed 5b 03 fc		ld de, (store_readbuf)     ; current buffer to nudge into 
0a57 2a 03 fc			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0a5a 23				inc hl 
0a5b 23				inc hl     ; skip id and ext 
0a5c 01 40 00			ld bc, STORE_BLOCK_PHY 
0a5f				if DEBUG_STORESE 
0a5f					DMARK "SR<" 
0a5f f5				push af  
0a60 3a 74 0a			ld a, (.dmark)  
0a63 32 b4 fe			ld (debug_mark),a  
0a66 3a 75 0a			ld a, (.dmark+1)  
0a69 32 b5 fe			ld (debug_mark+1),a  
0a6c 3a 76 0a			ld a, (.dmark+2)  
0a6f 32 b6 fe			ld (debug_mark+2),a  
0a72 18 03			jr .pastdmark  
0a74 ..			.dmark: db "SR<"  
0a77 f1			.pastdmark: pop af  
0a78			endm  
# End of macro DMARK
0a78					CALLMONITOR 
0a78 cd 7e 18			call break_point_state  
0a7b				endm  
# End of macro CALLMONITOR
0a7b				endif 
0a7b ed b0			ldir     ; copy data 
0a7d			 
0a7d				; move the pointer back and pretend we have a full buffer for next recheck 
0a7d			 
0a7d 1b				dec de 
0a7e 1b				dec de 
0a7f			 
0a7f			; TODO do pop below now short circuit loop????? 
0a7f c1				pop bc     ; get rid of spare de on stack 
0a80				if DEBUG_STORESE 
0a80					DMARK "SR>" 
0a80 f5				push af  
0a81 3a 95 0a			ld a, (.dmark)  
0a84 32 b4 fe			ld (debug_mark),a  
0a87 3a 96 0a			ld a, (.dmark+1)  
0a8a 32 b5 fe			ld (debug_mark+1),a  
0a8d 3a 97 0a			ld a, (.dmark+2)  
0a90 32 b6 fe			ld (debug_mark+2),a  
0a93 18 03			jr .pastdmark  
0a95 ..			.dmark: db "SR>"  
0a98 f1			.pastdmark: pop af  
0a99			endm  
# End of macro DMARK
0a99					CALLMONITOR 
0a99 cd 7e 18			call break_point_state  
0a9c				endm  
# End of macro CALLMONITOR
0a9c				endif 
0a9c c3 2d 09			jp .srext 
0a9f			 
0a9f			 
0a9f			 
0a9f			 
0a9f			 
0a9f			.readdone:		 
0a9f e1				pop hl 		 ; return start of data to show as not EOF 
0aa0 23				inc hl   ; past file id 
0aa1 23				inc hl   ; past ext 
0aa2				if DEBUG_STORESE 
0aa2					DMARK "SRe" 
0aa2 f5				push af  
0aa3 3a b7 0a			ld a, (.dmark)  
0aa6 32 b4 fe			ld (debug_mark),a  
0aa9 3a b8 0a			ld a, (.dmark+1)  
0aac 32 b5 fe			ld (debug_mark+1),a  
0aaf 3a b9 0a			ld a, (.dmark+2)  
0ab2 32 b6 fe			ld (debug_mark+2),a  
0ab5 18 03			jr .pastdmark  
0ab7 ..			.dmark: db "SRe"  
0aba f1			.pastdmark: pop af  
0abb			endm  
# End of macro DMARK
0abb					CALLMONITOR 
0abb cd 7e 18			call break_point_state  
0abe				endm  
# End of macro CALLMONITOR
0abe				endif 
0abe c9					ret 
0abf			 
0abf			 
0abf			 
0abf			; 
0abf			; Append File 
0abf			; 
0abf			; hl - file id to locate 
0abf			; de - pointer to (multi block) string to write 
0abf			 
0abf			.sa_notfound: 
0abf d1				pop de 
0ac0 c9				ret 
0ac1			 
0ac1			 
0ac1			storage_append: 
0ac1				; hl -  file id to append to 
0ac1				; de - string to append 
0ac1			 
0ac1 d5				push de 
0ac2				 
0ac2				if DEBUG_STORESE 
0ac2					DMARK "AP1" 
0ac2 f5				push af  
0ac3 3a d7 0a			ld a, (.dmark)  
0ac6 32 b4 fe			ld (debug_mark),a  
0ac9 3a d8 0a			ld a, (.dmark+1)  
0acc 32 b5 fe			ld (debug_mark+1),a  
0acf 3a d9 0a			ld a, (.dmark+2)  
0ad2 32 b6 fe			ld (debug_mark+2),a  
0ad5 18 03			jr .pastdmark  
0ad7 ..			.dmark: db "AP1"  
0ada f1			.pastdmark: pop af  
0adb			endm  
# End of macro DMARK
0adb					CALLMONITOR 
0adb cd 7e 18			call break_point_state  
0ade				endm  
# End of macro CALLMONITOR
0ade				endif 
0ade			 
0ade 7d				ld a, l 
0adf 32 fb fb			ld (store_tmpid), a 
0ae2			 
0ae2				; get file header  
0ae2			 
0ae2 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0ae4 3a fb fb			ld a, (store_tmpid) 
0ae7 5f				ld e, a 
0ae8			 
0ae8 21 40 00				ld hl, STORE_BLOCK_PHY 
0aeb cd 04 07				call storage_findnextid 
0aee			 
0aee cd 2a 0f			call ishlzero 
0af1 28 cc			jr z, .sa_notfound 
0af3			 
0af3 22 f2 fb			ld (store_tmppageid), hl 
0af6			 
0af6				; TODO handle file id not found 
0af6			 
0af6				if DEBUG_STORESE 
0af6					DMARK "AP2" 
0af6 f5				push af  
0af7 3a 0b 0b			ld a, (.dmark)  
0afa 32 b4 fe			ld (debug_mark),a  
0afd 3a 0c 0b			ld a, (.dmark+1)  
0b00 32 b5 fe			ld (debug_mark+1),a  
0b03 3a 0d 0b			ld a, (.dmark+2)  
0b06 32 b6 fe			ld (debug_mark+2),a  
0b09 18 03			jr .pastdmark  
0b0b ..			.dmark: db "AP2"  
0b0e f1			.pastdmark: pop af  
0b0f			endm  
# End of macro DMARK
0b0f					CALLMONITOR 
0b0f cd 7e 18			call break_point_state  
0b12				endm  
# End of macro CALLMONITOR
0b12				endif 
0b12			 
0b12				; update file extent count 
0b12			 
0b12 11 07 fc			ld de, store_page 
0b15			 
0b15 cd d1 03			call storage_read_block 
0b18			 
0b18				if DEBUG_STORESE 
0b18					DMARK "AP3" 
0b18 f5				push af  
0b19 3a 2d 0b			ld a, (.dmark)  
0b1c 32 b4 fe			ld (debug_mark),a  
0b1f 3a 2e 0b			ld a, (.dmark+1)  
0b22 32 b5 fe			ld (debug_mark+1),a  
0b25 3a 2f 0b			ld a, (.dmark+2)  
0b28 32 b6 fe			ld (debug_mark+2),a  
0b2b 18 03			jr .pastdmark  
0b2d ..			.dmark: db "AP3"  
0b30 f1			.pastdmark: pop af  
0b31			endm  
# End of macro DMARK
0b31					CALLMONITOR 
0b31 cd 7e 18			call break_point_state  
0b34				endm  
# End of macro CALLMONITOR
0b34				endif 
0b34			;	ld (store_tmppageid), hl 
0b34			 
0b34 3a 09 fc			ld a, (store_page+2) 
0b37 3c				inc a 
0b38 32 09 fc			ld (store_page+2), a 
0b3b 32 fa fb			ld (store_tmpext), a 
0b3e				 
0b3e				if DEBUG_STORESE 
0b3e					DMARK "AP3" 
0b3e f5				push af  
0b3f 3a 53 0b			ld a, (.dmark)  
0b42 32 b4 fe			ld (debug_mark),a  
0b45 3a 54 0b			ld a, (.dmark+1)  
0b48 32 b5 fe			ld (debug_mark+1),a  
0b4b 3a 55 0b			ld a, (.dmark+2)  
0b4e 32 b6 fe			ld (debug_mark+2),a  
0b51 18 03			jr .pastdmark  
0b53 ..			.dmark: db "AP3"  
0b56 f1			.pastdmark: pop af  
0b57			endm  
# End of macro DMARK
0b57					CALLMONITOR 
0b57 cd 7e 18			call break_point_state  
0b5a				endm  
# End of macro CALLMONITOR
0b5a				endif 
0b5a 2a f2 fb			ld hl, (store_tmppageid) 
0b5d 11 07 fc			ld de, store_page 
0b60 cd 36 04			call storage_write_block 
0b63			 
0b63				; find free block 
0b63			 
0b63 11 00 00			ld de, 0			 ; file extent to locate 
0b66			 
0b66 21 40 00				ld hl, STORE_BLOCK_PHY 
0b69 cd 04 07				call storage_findnextid 
0b6c cd 2a 0f			call ishlzero 
0b6f ca bf 0a			jp z, .sa_notfound 
0b72			 
0b72					; TODO handle no space left 
0b72					 
0b72 22 f2 fb				ld (store_tmppageid), hl 
0b75			 
0b75				if DEBUG_STORESE 
0b75					DMARK "AP4" 
0b75 f5				push af  
0b76 3a 8a 0b			ld a, (.dmark)  
0b79 32 b4 fe			ld (debug_mark),a  
0b7c 3a 8b 0b			ld a, (.dmark+1)  
0b7f 32 b5 fe			ld (debug_mark+1),a  
0b82 3a 8c 0b			ld a, (.dmark+2)  
0b85 32 b6 fe			ld (debug_mark+2),a  
0b88 18 03			jr .pastdmark  
0b8a ..			.dmark: db "AP4"  
0b8d f1			.pastdmark: pop af  
0b8e			endm  
# End of macro DMARK
0b8e					CALLMONITOR 
0b8e cd 7e 18			call break_point_state  
0b91				endm  
# End of macro CALLMONITOR
0b91				endif 
0b91					; init the buffer with zeros so we can id if the buffer is full or not 
0b91			 
0b91 e5					push hl 
0b92 c5					push bc 
0b93			 
0b93 21 07 fc				ld hl, store_page 
0b96 06 40				ld b, STORE_BLOCK_PHY 
0b98 3e 00				ld a, 0 
0b9a 77			.zeroblock:	ld (hl), a 
0b9b 23					inc hl 
0b9c 10 fc				djnz .zeroblock 
0b9e			 
0b9e c1					pop bc 
0b9f e1					pop hl 
0ba0			 
0ba0					; construct block 
0ba0			 
0ba0 3a fb fb				ld a, (store_tmpid) 
0ba3 32 07 fc				ld (store_page), a   ; file id 
0ba6 3a fa fb				ld a, (store_tmpext)   ; extent for this block 
0ba9 32 08 fc				ld (store_page+1), a 
0bac			 
0bac e1					pop hl    ; get string to write 
0bad 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0baf 11 09 fc				ld de, store_page+2 
0bb2			 
0bb2				if DEBUG_STORESE 
0bb2					DMARK "AP5" 
0bb2 f5				push af  
0bb3 3a c7 0b			ld a, (.dmark)  
0bb6 32 b4 fe			ld (debug_mark),a  
0bb9 3a c8 0b			ld a, (.dmark+1)  
0bbc 32 b5 fe			ld (debug_mark+1),a  
0bbf 3a c9 0b			ld a, (.dmark+2)  
0bc2 32 b6 fe			ld (debug_mark+2),a  
0bc5 18 03			jr .pastdmark  
0bc7 ..			.dmark: db "AP5"  
0bca f1			.pastdmark: pop af  
0bcb			endm  
# End of macro DMARK
0bcb					CALLMONITOR 
0bcb cd 7e 18			call break_point_state  
0bce				endm  
# End of macro CALLMONITOR
0bce				endif 
0bce			 
0bce			 
0bce			 
0bce					; fill buffer with data until end of string or full block 
0bce			 
0bce 7e			.appd:		ld a, (hl) 
0bcf 12					ld (de), a 
0bd0 fe 00				cp 0 
0bd2 28 04				jr z, .appdone 
0bd4 23					inc hl 
0bd5 13					inc de 
0bd6 10 f6				djnz .appd 
0bd8			 
0bd8 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0bd9 f5					push af   		; save last byte dumped 
0bda			 
0bda			 
0bda 2a f2 fb			ld hl, (store_tmppageid) 
0bdd 11 07 fc			ld de, store_page 
0be0				if DEBUG_STORESE 
0be0					DMARK "AP6" 
0be0 f5				push af  
0be1 3a f5 0b			ld a, (.dmark)  
0be4 32 b4 fe			ld (debug_mark),a  
0be7 3a f6 0b			ld a, (.dmark+1)  
0bea 32 b5 fe			ld (debug_mark+1),a  
0bed 3a f7 0b			ld a, (.dmark+2)  
0bf0 32 b6 fe			ld (debug_mark+2),a  
0bf3 18 03			jr .pastdmark  
0bf5 ..			.dmark: db "AP6"  
0bf8 f1			.pastdmark: pop af  
0bf9			endm  
# End of macro DMARK
0bf9					CALLMONITOR 
0bf9 cd 7e 18			call break_point_state  
0bfc				endm  
# End of macro CALLMONITOR
0bfc				endif 
0bfc cd 36 04				call storage_write_block 
0bff			 
0bff			 
0bff				; was that a full block of data written? 
0bff				; any more to write out? 
0bff			 
0bff				; if yes then set vars and jump to start of function again 
0bff			 
0bff f1					pop af 
0c00 d1					pop de 
0c01			 
0c01 fe 00				cp 0		 ; no, string was fully written 
0c03 c8					ret z 
0c04			 
0c04					; setup vars for next cycle 
0c04			 
0c04 3a fb fb				ld a, (store_tmpid) 
0c07 6f					ld l, a 
0c08 26 00				ld h, 0 
0c0a			 
0c0a c3 c1 0a			 	jp storage_append	 ; yes, need to write out some more 
0c0d			 
0c0d			 
0c0d			 
0c0d			 
0c0d			 
0c0d			 
0c0d			 
0c0d			if DEBUG_STORECF 
0c0d			storageput:	 
0c0d					ret 
0c0d			storageread: 
0c0d					ld hl, store_page 
0c0d					ld b, 200 
0c0d					ld a,0 
0c0d			.src:		ld (hl),a 
0c0d					inc hl 
0c0d					djnz .src 
0c0d					 
0c0d			 
0c0d					ld de, 0 
0c0d					ld bc, 1 
0c0d					ld hl, store_page 
0c0d					call cfRead 
0c0d			 
0c0d				call cfGetError 
0c0d				ld hl,scratch 
0c0d				call hexout 
0c0d				ld hl, scratch+2 
0c0d				ld a, 0 
0c0d				ld (hl),a 
0c0d				ld de, scratch 
0c0d				ld a,display_row_1 
0c0d				call str_at_display 
0c0d				call update_display 
0c0d			 
0c0d					ld hl, store_page 
0c0d					ld (os_cur_ptr),hl 
0c0d			 
0c0d					ret 
0c0d			endif 
0c0d			 
0c0d			 
0c0d			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c0d			 
0c0d			storage_clear_page: 
0c0d e5				push hl 
0c0e d5				push de 
0c0f c5				push bc 
0c10 21 07 fc			ld hl, store_page 
0c13 3e 00			ld a, 0 
0c15 77				ld (hl), a 
0c16			 
0c16 11 08 fc			ld de, store_page+1 
0c19 01 18 01			ld bc, STORE_BLOCK_LOG 
0c1c			 
0c1c ed b0			ldir 
0c1e				 
0c1e c1				pop bc 
0c1f d1				pop de 
0c20 e1				pop hl 
0c21 c9				ret 
0c22			 
0c22			; eof 
# End of file firmware_storage.asm
0c22			  
0c22			; support routines for above hardware abstraction layer  
0c22			  
0c22			include "firmware_general.asm"        ; general support functions  
0c22			 
0c22			; word look up 
0c22			 
0c22			; in 
0c22			; a is the index 
0c22			; hl is pointer start of array 
0c22			; 
0c22			; returns 
0c22			; hl to the word 
0c22			; 
0c22			 
0c22			table_lookup:  
0c22 d5					push de 
0c23 eb					ex de, hl 
0c24			 
0c24 6f					ld l, a 
0c25 26 00				ld h, 0 
0c27 29					add hl, hl 
0c28 19					add hl, de 
0c29 7e					ld a, (hl) 
0c2a 23					inc hl 
0c2b 66					ld h,(hl) 
0c2c 6f					ld l, a 
0c2d			 
0c2d d1					pop de 
0c2e c9					ret 
0c2f			 
0c2f			; Delay loops 
0c2f			 
0c2f			 
0c2f			 
0c2f			aDelayInMS: 
0c2f c5				push bc 
0c30 47				ld b,a 
0c31			msdelay: 
0c31 c5				push bc 
0c32				 
0c32			 
0c32 01 41 00			ld bc,041h 
0c35 cd 4d 0c			call delayloop 
0c38 c1				pop bc 
0c39 05				dec b 
0c3a 20 f5			jr nz,msdelay 
0c3c			 
0c3c			;if CPU_CLOCK_8MHZ 
0c3c			;msdelay8: 
0c3c			;	push bc 
0c3c			;	 
0c3c			; 
0c3c			;	ld bc,041h 
0c3c			;	call delayloop 
0c3c			;	pop bc 
0c3c			;	dec b 
0c3c			;	jr nz,msdelay8 
0c3c			;endif 
0c3c			 
0c3c			 
0c3c c1				pop bc 
0c3d c9				ret 
0c3e			 
0c3e			 
0c3e			delay250ms: 
0c3e				;push de 
0c3e 01 00 40			ld bc, 04000h 
0c41 c3 4d 0c			jp delayloop 
0c44			delay500ms: 
0c44				;push de 
0c44 01 00 80			ld bc, 08000h 
0c47 c3 4d 0c			jp delayloop 
0c4a			delay1s: 
0c4a				;push bc 
0c4a			   ; Clobbers A, d and e 
0c4a 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c4d			delayloop: 
0c4d c5			    push bc 
0c4e			 
0c4e			if BASE_CPM 
0c4e				ld bc, CPM_DELAY_TUNE 
0c4e			.cpmloop: 
0c4e				push bc 
0c4e			 
0c4e			endif 
0c4e			 
0c4e			 
0c4e			 
0c4e			delayloopi: 
0c4e			;	push bc 
0c4e			;.dl: 
0c4e cb 47		    bit     0,a    	; 8 
0c50 cb 47		    bit     0,a    	; 8 
0c52 cb 47		    bit     0,a    	; 8 
0c54 e6 ff		    and     255  	; 7 
0c56 0b			    dec     bc      	; 6 
0c57 79			    ld      a,c     	; 4 
0c58 b0			    or      b     	; 4 
0c59 c2 4e 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0c5c			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0c5c				;pop de 
0c5c			;pop bc 
0c5c			 
0c5c			if BASE_CPM 
0c5c				pop bc 
0c5c				 
0c5c			    dec     bc      	; 6 
0c5c			    ld      a,c     	; 4 
0c5c			    or      b     	; 4 
0c5c			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0c5c				 
0c5c			 
0c5c			endif 
0c5c			;if CPU_CLOCK_8MHZ 
0c5c			;    pop bc 
0c5c			;    push bc 
0c5c			;.dl8: 
0c5c			;    bit     0,a    	; 8 
0c5c			;    bit     0,a    	; 8 
0c5c			;    bit     0,a    	; 8 
0c5c			;    and     255  	; 7 
0c5c			;    dec     bc      	; 6 
0c5c			;    ld      a,c     	; 4 
0c5c			;    or      b     	; 4 
0c5c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c5c			;endif 
0c5c			 
0c5c			;if CPU_CLOCK_10MHZ 
0c5c			;    pop bc 
0c5c			;    push bc 
0c5c			;.dl8: 
0c5c			;    bit     0,a    	; 8 
0c5c			;    bit     0,a    	; 8 
0c5c			;    bit     0,a    	; 8 
0c5c			;    and     255  	; 7 
0c5c			;    dec     bc      	; 6 
0c5c			;    ld      a,c     	; 4 
0c5c			;    or      b     	; 4 
0c5c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c5c			;endif 
0c5c c1			    pop bc 
0c5d			 
0c5d c9				ret 
0c5e			 
0c5e			 
0c5e			 
0c5e			; eof 
# End of file firmware_general.asm
0c5e			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0c5e			; display routines that use the physical hardware abstraction layer 
0c5e			 
0c5e			 
0c5e			; information window 
0c5e			 
0c5e			; pass hl with 1st string to display 
0c5e			; pass de with 2nd string to display 
0c5e			 
0c5e			info_panel: 
0c5e e5				push hl 
0c5f			 
0c5f 2a 55 fd			ld hl, (display_fb_active) 
0c62 e5				push hl    ; future de destination 
0c63 21 4a fe				ld hl, display_fb0 
0c66 22 55 fd				ld (display_fb_active), hl 
0c69			 
0c69			;	call clear_display 
0c69			 
0c69				if BASE_CPM 
0c69				ld a, '.' 
0c69				else 
0c69 3e a5			ld a, 165 
0c6b				endif 
0c6b cd d2 0c			call fill_display 
0c6e			 
0c6e			 
0c6e 3e 2d			ld a, display_row_3 + 5 
0c70 cd e0 0c			call str_at_display 
0c73			 
0c73 e1				pop hl 
0c74 d1				pop de 
0c75			 
0c75 e5				push hl 
0c76			 
0c76			 
0c76 3e 19			ld a, display_row_2 + 5 
0c78 cd e0 0c			call str_at_display 
0c7b			 
0c7b			 
0c7b cd f0 0c			call update_display 
0c7e cd 6a 1e			call next_page_prompt 
0c81 cd cd 0c			call clear_display 
0c84			 
0c84				 
0c84 21 f9 fd				ld hl, display_fb1 
0c87 22 55 fd				ld (display_fb_active), hl 
0c8a cd f0 0c			call update_display 
0c8d			 
0c8d e1				pop hl 
0c8e			 
0c8e c9				ret 
0c8f			 
0c8f			 
0c8f			 
0c8f			 
0c8f			; TODO windowing? 
0c8f			 
0c8f			; TODO scroll line up 
0c8f			 
0c8f			scroll_up: 
0c8f			 
0c8f e5				push hl 
0c90 d5				push de 
0c91 c5				push bc 
0c92			 
0c92				; get frame buffer  
0c92			 
0c92 2a 55 fd			ld hl, (display_fb_active) 
0c95 e5				push hl    ; future de destination 
0c96			 
0c96 11 14 00			ld  de, display_cols 
0c99 19				add hl, de 
0c9a			 
0c9a d1				pop de 
0c9b			 
0c9b				;ex de, hl 
0c9b 01 4f 00			ld bc, display_fb_len -1  
0c9e			;if DEBUG_FORTH_WORDS 
0c9e			;	DMARK "SCL" 
0c9e			;	CALLMONITOR 
0c9e			;endif	 
0c9e ed b0			ldir 
0ca0			 
0ca0				; wipe bottom row 
0ca0			 
0ca0			 
0ca0 2a 55 fd			ld hl, (display_fb_active) 
0ca3 11 50 00			ld de, display_cols*display_rows 
0ca6 19				add hl, de 
0ca7 06 14			ld b, display_cols 
0ca9 3e 20			ld a, ' ' 
0cab			.scwipe: 
0cab 77				ld (hl), a 
0cac 2b				dec hl 
0cad 10 fc			djnz .scwipe 
0caf			 
0caf				;pop hl 
0caf			 
0caf c1				pop bc 
0cb0 d1				pop de 
0cb1 e1				pop hl 
0cb2			 
0cb2 c9				ret 
0cb3			 
0cb3			 
0cb3			;scroll_upo: 
0cb3			;	ld de, display_row_1 
0cb3			 ;	ld hl, display_row_2 
0cb3			;	ld bc, display_cols 
0cb3			;	ldir 
0cb3			;	ld de, display_row_2 
0cb3			 ;	ld hl, display_row_3 
0cb3			;	ld bc, display_cols 
0cb3			;	ldir 
0cb3			;	ld de, display_row_3 
0cb3			 ;	ld hl, display_row_4 
0cb3			;	ld bc, display_cols 
0cb3			;	ldir 
0cb3			 
0cb3			; TODO clear row 4 
0cb3			 
0cb3			;	ret 
0cb3			 
0cb3				 
0cb3			scroll_down: 
0cb3			 
0cb3 e5				push hl 
0cb4 d5				push de 
0cb5 c5				push bc 
0cb6			 
0cb6				; get frame buffer  
0cb6			 
0cb6 2a 55 fd			ld hl, (display_fb_active) 
0cb9			 
0cb9 11 4f 00			ld de, display_fb_len - 1 
0cbc 19				add hl, de 
0cbd			 
0cbd e5			push hl    ; future de destination 
0cbe			 
0cbe 11 14 00			ld  de, display_cols 
0cc1 ed 52			sbc hl, de 
0cc3			 
0cc3			 
0cc3 d1				pop de 
0cc4			 
0cc4			;	ex de, hl 
0cc4 01 4f 00			ld bc, display_fb_len -1  
0cc7			 
0cc7			 
0cc7				 
0cc7			 
0cc7 ed b0			ldir 
0cc9			 
0cc9				; wipe bottom row 
0cc9			 
0cc9			 
0cc9			;	ld hl, (display_fb_active) 
0cc9			;;	ld de, display_cols*display_rows 
0cc9			;;	add hl, de 
0cc9			;	ld b, display_cols 
0cc9			;	ld a, ' ' 
0cc9			;.scwiped: 
0cc9			;	ld (hl), a 
0cc9			;	dec hl 
0cc9			;	djnz .scwiped 
0cc9			 
0cc9				;pop hl 
0cc9			 
0cc9 c1				pop bc 
0cca d1				pop de 
0ccb e1				pop hl 
0ccc			 
0ccc c9				ret 
0ccd			;scroll_down: 
0ccd			;	ld de, display_row_4 
0ccd			;	ld hl, display_row_3 
0ccd			;	ld bc, display_cols 
0ccd			;	ldir 
0ccd			;	ld de, display_row_3 
0ccd			; 	ld hl, display_row_2 
0ccd			;	ld bc, display_cols 
0ccd			;	ldir 
0ccd			;	ld de, display_row_2 
0ccd			;	ld hl, display_row_1 
0ccd			;	ld bc, display_cols 
0ccd			;	ldir 
0ccd			;;; TODO clear row 1 
0ccd			;	ret 
0ccd			 
0ccd			 
0ccd			 
0ccd			 
0ccd			 
0ccd			; clear active frame buffer 
0ccd			 
0ccd			clear_display: 
0ccd 3e 20			ld a, ' ' 
0ccf c3 d2 0c			jp fill_display 
0cd2			 
0cd2			; fill active frame buffer with a char in A 
0cd2			 
0cd2			fill_display: 
0cd2 06 50			ld b,display_fb_len 
0cd4 2a 55 fd			ld hl, (display_fb_active) 
0cd7 77			.fd1:	ld (hl),a 
0cd8 23				inc hl 
0cd9 10 fc			djnz .fd1 
0cdb 23				inc hl 
0cdc 3e 00			ld a,0 
0cde 77				ld (hl),a 
0cdf			 
0cdf			 
0cdf c9				ret 
0ce0			; Write string (DE) at pos (A) to active frame buffer 
0ce0			 
0ce0 2a 55 fd		str_at_display:    ld hl,(display_fb_active) 
0ce3 06 00					ld b,0 
0ce5 4f					ld c,a 
0ce6 09					add hl,bc 
0ce7 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0ce8 b7			            OR   A              ;Null terminator? 
0ce9 c8			            RET  Z              ;Yes, so finished 
0cea 77					ld (hl),a 
0ceb 23				inc hl 
0cec 13			            INC  DE             ;Point to next character 
0ced 18 f8		            JR   .sad1     ;Repeat 
0cef c9					ret 
0cf0			 
0cf0			; using current frame buffer write to physical display 
0cf0			 
0cf0			update_display: 
0cf0 e5				push hl 
0cf1 2a 55 fd			ld hl, (display_fb_active) 
0cf4 cd a4 69			call write_display 
0cf7 e1				pop hl 
0cf8 c9				ret 
0cf9			 
0cf9			; TODO scrolling 
0cf9			 
0cf9			 
0cf9			; move cursor right one char 
0cf9			cursor_right: 
0cf9			 
0cf9				; TODO shift right 
0cf9				; TODO if beyond max col 
0cf9				; TODO       cursor_next_line 
0cf9			 
0cf9 c9				ret 
0cfa			 
0cfa			 
0cfa			cursor_next_line: 
0cfa				; TODO first char 
0cfa				; TODO line down 
0cfa				; TODO if past last row 
0cfa				; TODO    scroll up 
0cfa			 
0cfa c9				ret 
0cfb			 
0cfb			cursor_left: 
0cfb				; TODO shift left 
0cfb				; TODO if beyond left  
0cfb				; TODO     cursor prev line 
0cfb				 
0cfb c9				ret 
0cfc			 
0cfc			cursor_prev_line: 
0cfc				; TODO last char 
0cfc				; TODO line up 
0cfc				; TODO if past first row 
0cfc				; TODO   scroll down 
0cfc			 
0cfc c9				ret 
0cfd			 
0cfd			 
0cfd			cout: 
0cfd				; A - char 
0cfd c9				ret 
0cfe			 
0cfe			 
0cfe			; Display a menu and allow item selection (optional toggle items) 
0cfe			; 
0cfe			; format: 
0cfe			; hl pointer to word array with zero term for items 
0cfe			; e.g.    db item1 
0cfe			;         db .... 
0cfe			;         db 0 
0cfe			; 
0cfe			; a = starting menu item  
0cfe			; 
0cfe			; de = pointer item toggle array   (todo) 
0cfe			; 
0cfe			; returns item selected in a 1-... 
0cfe			; returns 0 if back button pressed 
0cfe			; 
0cfe			; NOTE: Uses system frame buffer to display 
0cfe			; 
0cfe			; LEFT, Q = go back 
0cfe			; RIGHT, SPACE, CR = select 
0cfe			; UP, A - Up 
0cfe			; DOWN, Z - Down 
0cfe			 
0cfe			 
0cfe			 
0cfe			 
0cfe			 
0cfe			menu: 
0cfe			 
0cfe					; keep array pointer 
0cfe			 
0cfe 22 00 fc				ld (store_tmp1), hl 
0d01 32 fe fb				ld (store_tmp2), a 
0d04			 
0d04					; check for key bounce 
0d04			 
0d04			if BASE_KEV 
0d04			 
0d04 cd 59 6b		.mbounce:	call cin 
0d07 fe 00				cp 0 
0d09 20 f9				jr nz, .mbounce 
0d0b			endif 
0d0b					; for ease use ex 
0d0b			 
0d0b					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d0b 21 4a fe				ld hl, display_fb0 
0d0e 22 55 fd				ld (display_fb_active), hl 
0d11			 
0d11 cd cd 0c		.mloop:		call clear_display 
0d14 cd f0 0c				call update_display 
0d17			 
0d17					; draw selection id '>' at 1 
0d17			 
0d17					; init start of list display 
0d17			 
0d17 3e 05				ld a, 5 
0d19 32 fc fb				ld (store_tmp3), a   ; display row count 
0d1c 3a fe fb				ld a,( store_tmp2) 
0d1f 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d22			 
0d22					 
0d22			.mitem:	 
0d22			 
0d22			 
0d22 3a ff fb				ld a,(store_tmp2+1) 
0d25 6f					ld l, a 
0d26 26 00				ld h, 0 
0d28 29					add hl, hl 
0d29 ed 5b 00 fc			ld de, (store_tmp1) 
0d2d 19					add hl, de 
0d2e 7e					ld a, (hl) 
0d2f 23					inc hl 
0d30 66					ld h,(hl) 
0d31 6f					ld l, a 
0d32			 
0d32 cd 2a 0f				call ishlzero 
0d35 28 1a				jr z, .mdone 
0d37			 
0d37 eb					ex de, hl 
0d38 3a fc fb				ld a, (store_tmp3) 
0d3b cd e0 0c				call str_at_display 
0d3e					 
0d3e			 
0d3e					; next item 
0d3e 3a ff fb				ld a, (store_tmp2+1) 
0d41 3c					inc a 
0d42 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d45			 
0d45			 		; next row 
0d45			 
0d45 3a fc fb				ld a, (store_tmp3) 
0d48 c6 14				add display_cols 
0d4a 32 fc fb				ld (store_tmp3), a 
0d4d			 
0d4d					; at end of screen? 
0d4d			 
0d4d fe 10				cp display_rows*4 
0d4f 20 d1				jr nz, .mitem 
0d51			 
0d51			 
0d51			.mdone: 
0d51 cd 2a 0f				call ishlzero 
0d54 28 08				jr z, .nodn 
0d56			 
0d56 3e 3c				ld a, display_row_4 
0d58 11 d7 0d				ld de, .mdown 
0d5b cd e0 0c				call str_at_display 
0d5e			 
0d5e					; draw options to fill the screens with active item on line 1 
0d5e					; if current option is 2 or more then display ^ in top 
0d5e			 
0d5e 3a fe fb		.nodn:		ld a, (store_tmp2) 
0d61 fe 00				cp 0 
0d63 28 08				jr z, .noup 
0d65			 
0d65 3e 00				ld a, 0 
0d67 11 d5 0d				ld de, .mup 
0d6a cd e0 0c				call str_at_display 
0d6d			 
0d6d 3e 02		.noup:		ld a, 2 
0d6f 11 d3 0d				ld de, .msel 
0d72 cd e0 0c				call str_at_display 
0d75			 
0d75					; if current option + 1 is not null then display V in bottom 
0d75					; get key 
0d75 cd f0 0c				call update_display 
0d78			 
0d78			 
0d78					; handle key 
0d78			 
0d78 cd 48 6b				call cin_wait 
0d7b			 
0d7b fe 05				cp KEY_UP 
0d7d 28 2b				jr z, .mgoup 
0d7f fe 61				cp 'a' 
0d81 28 27				jr z, .mgoup 
0d83 fe 0a				cp KEY_DOWN 
0d85 28 32				jr z, .mgod 
0d87 fe 7a				cp 'z' 
0d89 28 2e				jr z, .mgod 
0d8b fe 20				cp ' ' 
0d8d 28 34				jr z, .goend 
0d8f fe 0c				cp KEY_RIGHT 
0d91 28 30				jr z, .goend 
0d93 fe 0d				cp KEY_CR 
0d95 28 2c				jr z, .goend 
0d97 fe 71				cp 'q' 
0d99 28 0b				jr z, .goback 
0d9b			 
0d9b fe 0b				cp KEY_LEFT 
0d9d 28 07				jr z, .goback 
0d9f fe 08				cp KEY_BS 
0da1 28 03				jr z, .goback 
0da3 c3 11 0d				jp .mloop 
0da6			 
0da6			.goback: 
0da6 3e 00			ld a, 0 
0da8 18 1d			jr .goend2 
0daa			 
0daa				; move up one 
0daa			.mgoup: 
0daa 3a fe fb				ld a, (store_tmp2) 
0dad fe 00				cp 0 
0daf ca 11 0d				jp z, .mloop 
0db2 3d					dec a 
0db3 32 fe fb				ld (store_tmp2), a 
0db6 c3 11 0d				jp .mloop 
0db9			 
0db9				; move down one 
0db9			.mgod: 
0db9 3a fe fb				ld a, (store_tmp2) 
0dbc 3c					inc a 
0dbd 32 fe fb				ld (store_tmp2), a 
0dc0 c3 11 0d				jp .mloop 
0dc3			 
0dc3			 
0dc3			.goend: 
0dc3					; get selected item number 
0dc3			 
0dc3 3a fe fb				ld a, (store_tmp2) 
0dc6 3c					inc a 
0dc7			 
0dc7			.goend2: 
0dc7 f5					push af 
0dc8			 
0dc8					; restore active fb 
0dc8					; TODO BUG assumes fb1 
0dc8			 
0dc8 21 f9 fd				ld hl, display_fb1 
0dcb 22 55 fd				ld (display_fb_active), hl 
0dce			 
0dce					; restore main regs 
0dce			 
0dce			 
0dce cd f0 0c				call update_display 
0dd1			 
0dd1 f1					pop af 
0dd2			 
0dd2 c9				ret 
0dd3			 
0dd3 .. 00		.msel:   db ">",0 
0dd5 .. 00		.mup:   db "^",0 
0dd7 .. 00		.mdown:   db "v",0 
0dd9			 
0dd9			 
0dd9			; eof 
0dd9			 
# End of file firmware_display.asm
0dd9			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0dd9			; random number generators 
0dd9			 
0dd9			 
0dd9			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0dd9			 
0dd9			 
0dd9			;-----> Generate a random number 
0dd9			; output a=answer 0<=a<=255 
0dd9			; all registers are preserved except: af 
0dd9			random: 
0dd9 e5			        push    hl 
0dda d5			        push    de 
0ddb 2a 37 fd		        ld      hl,(randData) 
0dde ed 5f		        ld      a,r 
0de0 57			        ld      d,a 
0de1 5e			        ld      e,(hl) 
0de2 19			        add     hl,de 
0de3 85			        add     a,l 
0de4 ac			        xor     h 
0de5 22 37 fd		        ld      (randData),hl 
0de8 d1			        pop     de 
0de9 e1			        pop     hl 
0dea c9			        ret 
0deb			 
0deb			 
0deb			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0deb			 
0deb			 
0deb			 
0deb			;------LFSR------ 
0deb			;James Montelongo 
0deb			;optimized by Spencer Putt 
0deb			;out: 
0deb			; a = 8 bit random number 
0deb			RandLFSR: 
0deb 21 3d fd		        ld hl,LFSRSeed+4 
0dee 5e			        ld e,(hl) 
0def 23			        inc hl 
0df0 56			        ld d,(hl) 
0df1 23			        inc hl 
0df2 4e			        ld c,(hl) 
0df3 23			        inc hl 
0df4 7e			        ld a,(hl) 
0df5 47			        ld b,a 
0df6 cb 13		        rl e  
0df8 cb 12			rl d 
0dfa cb 11		        rl c  
0dfc 17				rla 
0dfd cb 13		        rl e  
0dff cb 12			rl d 
0e01 cb 11		        rl c  
0e03 17				rla 
0e04 cb 13		        rl e  
0e06 cb 12			rl d 
0e08 cb 11		        rl c  
0e0a 17				rla 
0e0b 67			        ld h,a 
0e0c cb 13		        rl e  
0e0e cb 12			rl d 
0e10 cb 11		        rl c  
0e12 17				rla 
0e13 a8			        xor b 
0e14 cb 13		        rl e  
0e16 cb 12			rl d 
0e18 ac			        xor h 
0e19 a9			        xor c 
0e1a aa			        xor d 
0e1b 21 3f fd		        ld hl,LFSRSeed+6 
0e1e 11 40 fd		        ld de,LFSRSeed+7 
0e21 01 07 00		        ld bc,7 
0e24 ed b8		        lddr 
0e26 12			        ld (de),a 
0e27 c9			        ret 
0e28			 
0e28			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e28			 
0e28			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e28			 
0e28			 
0e28			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e28			 
0e28			prng16: 
0e28			;Inputs: 
0e28			;   (seed1) contains a 16-bit seed value 
0e28			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e28			;Outputs: 
0e28			;   HL is the result 
0e28			;   BC is the result of the LCG, so not that great of quality 
0e28			;   DE is preserved 
0e28			;Destroys: 
0e28			;   AF 
0e28			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e28			;160cc 
0e28			;26 bytes 
0e28 2a 31 fd		    ld hl,(seed1) 
0e2b 44			    ld b,h 
0e2c 4d			    ld c,l 
0e2d 29			    add hl,hl 
0e2e 29			    add hl,hl 
0e2f 2c			    inc l 
0e30 09			    add hl,bc 
0e31 22 31 fd		    ld (seed1),hl 
0e34 2a 2f fd		    ld hl,(seed2) 
0e37 29			    add hl,hl 
0e38 9f			    sbc a,a 
0e39 e6 2d		    and %00101101 
0e3b ad			    xor l 
0e3c 6f			    ld l,a 
0e3d 22 2f fd		    ld (seed2),hl 
0e40 09			    add hl,bc 
0e41 c9			    ret 
0e42			 
0e42			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e42			 
0e42			rand32: 
0e42			;Inputs: 
0e42			;   (seed1_0) holds the lower 16 bits of the first seed 
0e42			;   (seed1_1) holds the upper 16 bits of the first seed 
0e42			;   (seed2_0) holds the lower 16 bits of the second seed 
0e42			;   (seed2_1) holds the upper 16 bits of the second seed 
0e42			;   **NOTE: seed2 must be non-zero 
0e42			;Outputs: 
0e42			;   HL is the result 
0e42			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e42			;Destroys: 
0e42			;   AF 
0e42			;Tested and passes all CAcert tests 
0e42			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e42			;it has a period of 18,446,744,069,414,584,320 
0e42			;roughly 18.4 quintillion. 
0e42			;LFSR taps: 0,2,6,7  = 11000101 
0e42			;291cc 
0e42			;seed1_0=$+1 
0e42			;    ld hl,12345 
0e42			;seed1_1=$+1 
0e42			;    ld de,6789 
0e42			;    ld b,h 
0e42			;    ld c,l 
0e42			;    add hl,hl \ rl e \ rl d 
0e42			;    add hl,hl \ rl e \ rl d 
0e42			;    inc l 
0e42			;    add hl,bc 
0e42			;    ld (seed1_0),hl 
0e42			;    ld hl,(seed1_1) 
0e42			;    adc hl,de 
0e42			;    ld (seed1_1),hl 
0e42			;    ex de,hl 
0e42			;seed2_0=$+1 
0e42			;    ld hl,9876 
0e42			;seed2_1=$+1 
0e42			;    ld bc,54321 
0e42			;    add hl,hl \ rl c \ rl b 
0e42			;    ld (seed2_1),bc 
0e42			;    sbc a,a 
0e42			;    and %11000101 
0e42			;    xor l 
0e42			;    ld l,a 
0e42			;    ld (seed2_0),hl 
0e42			;    ex de,hl 
0e42			;    add hl,bc 
0e42			;    ret 
0e42			; 
0e42			 
0e42			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e42			; 20 bytes, 86 cycles (excluding ret) 
0e42			 
0e42			; returns   hl = pseudorandom number 
0e42			; corrupts   a 
0e42			 
0e42			; generates 16-bit pseudorandom numbers with a period of 65535 
0e42			; using the xorshift method: 
0e42			 
0e42			; hl ^= hl << 7 
0e42			; hl ^= hl >> 9 
0e42			; hl ^= hl << 8 
0e42			 
0e42			; some alternative shift triplets which also perform well are: 
0e42			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e42			 
0e42			;  org 32768 
0e42			 
0e42			xrnd: 
0e42 2a 35 fd		  ld hl,(xrandc)       ; seed must not be 0 
0e45 3e 00		  ld a,0 
0e47 bd			  cp l 
0e48 20 02		  jr nz, .xrnd1 
0e4a 2e 01		  ld l, 1 
0e4c			.xrnd1: 
0e4c			 
0e4c 7c			  ld a,h 
0e4d 1f			  rra 
0e4e 7d			  ld a,l 
0e4f 1f			  rra 
0e50 ac			  xor h 
0e51 67			  ld h,a 
0e52 7d			  ld a,l 
0e53 1f			  rra 
0e54 7c			  ld a,h 
0e55 1f			  rra 
0e56 ad			  xor l 
0e57 6f			  ld l,a 
0e58 ac			  xor h 
0e59 67			  ld h,a 
0e5a			 
0e5a 22 35 fd		  ld (xrandc),hl 
0e5d			 
0e5d c9			  ret 
0e5e			;  
0e5e			 
0e5e			 
0e5e			;;;; int maths 
0e5e			 
0e5e			; https://map.grauw.nl/articles/mult_div_shifts.php 
0e5e			; Divide 16-bit values (with 16-bit result) 
0e5e			; In: Divide BC by divider DE 
0e5e			; Out: BC = result, HL = rest 
0e5e			; 
0e5e			Div16: 
0e5e 21 00 00		    ld hl,0 
0e61 78			    ld a,b 
0e62 06 08		    ld b,8 
0e64			Div16_Loop1: 
0e64 17			    rla 
0e65 ed 6a		    adc hl,hl 
0e67 ed 52		    sbc hl,de 
0e69 30 01		    jr nc,Div16_NoAdd1 
0e6b 19			    add hl,de 
0e6c			Div16_NoAdd1: 
0e6c 10 f6		    djnz Div16_Loop1 
0e6e 17			    rla 
0e6f 2f			    cpl 
0e70 47			    ld b,a 
0e71 79			    ld a,c 
0e72 48			    ld c,b 
0e73 06 08		    ld b,8 
0e75			Div16_Loop2: 
0e75 17			    rla 
0e76 ed 6a		    adc hl,hl 
0e78 ed 52		    sbc hl,de 
0e7a 30 01		    jr nc,Div16_NoAdd2 
0e7c 19			    add hl,de 
0e7d			Div16_NoAdd2: 
0e7d 10 f6		    djnz Div16_Loop2 
0e7f 17			    rla 
0e80 2f			    cpl 
0e81 41			    ld b,c 
0e82 4f			    ld c,a 
0e83 c9			ret 
0e84			 
0e84			 
0e84			;http://z80-heaven.wikidot.com/math 
0e84			; 
0e84			;Inputs: 
0e84			;     DE and A are factors 
0e84			;Outputs: 
0e84			;     A is not changed 
0e84			;     B is 0 
0e84			;     C is not changed 
0e84			;     DE is not changed 
0e84			;     HL is the product 
0e84			;Time: 
0e84			;     342+6x 
0e84			; 
0e84			Mult16: 
0e84			 
0e84 06 08		     ld b,8          ;7           7 
0e86 21 00 00		     ld hl,0         ;10         10 
0e89 29			       add hl,hl     ;11*8       88 
0e8a 07			       rlca          ;4*8        32 
0e8b 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0e8d 19			         add hl,de   ;--         -- 
0e8e 10 f9		       djnz $-5      ;13*7+8     99 
0e90 c9			ret 
0e91			 
0e91			; 
0e91			; Square root of 16-bit value 
0e91			; In:  HL = value 
0e91			; Out:  D = result (rounded down) 
0e91			; 
0e91			;Sqr16: 
0e91			;    ld de,#0040 
0e91			;    ld a,l 
0e91			;    ld l,h 
0e91			;    ld h,d 
0e91			;    or a 
0e91			;    ld b,8 
0e91			;Sqr16_Loop: 
0e91			;    sbc hl,de 
0e91			;    jr nc,Sqr16_Skip 
0e91			;    add hl,de 
0e91			;Sqr16_Skip: 
0e91			;    ccf 
0e91			;    rl d 
0e91			;    add a,a 
0e91			;    adc hl,hl 
0e91			;    add a,a 
0e91			;    adc hl,hl 
0e91			;    djnz Sqr16_Loop 
0e91			;    ret 
0e91			; 
0e91			; 
0e91			; Divide 8-bit values 
0e91			; In: Divide E by divider C 
0e91			; Out: A = result, B = rest 
0e91			; 
0e91			Div8: 
0e91 af			    xor a 
0e92 06 08		    ld b,8 
0e94			Div8_Loop: 
0e94 cb 13		    rl e 
0e96 17			    rla 
0e97 91			    sub c 
0e98 30 01		    jr nc,Div8_NoAdd 
0e9a 81			    add a,c 
0e9b			Div8_NoAdd: 
0e9b 10 f7		    djnz Div8_Loop 
0e9d 47			    ld b,a 
0e9e 7b			    ld a,e 
0e9f 17			    rla 
0ea0 2f			    cpl 
0ea1 c9			    ret 
0ea2			 
0ea2			; 
0ea2			; Multiply 8-bit value with a 16-bit value (unrolled) 
0ea2			; In: Multiply A with DE 
0ea2			; Out: HL = result 
0ea2			; 
0ea2			Mult12U: 
0ea2 2e 00		    ld l,0 
0ea4 87			    add a,a 
0ea5 30 01		    jr nc,Mult12U_NoAdd0 
0ea7 19			    add hl,de 
0ea8			Mult12U_NoAdd0: 
0ea8 29			    add hl,hl 
0ea9 87			    add a,a 
0eaa 30 01		    jr nc,Mult12U_NoAdd1 
0eac 19			    add hl,de 
0ead			Mult12U_NoAdd1: 
0ead 29			    add hl,hl 
0eae 87			    add a,a 
0eaf 30 01		    jr nc,Mult12U_NoAdd2 
0eb1 19			    add hl,de 
0eb2			Mult12U_NoAdd2: 
0eb2 29			    add hl,hl 
0eb3 87			    add a,a 
0eb4 30 01		    jr nc,Mult12U_NoAdd3 
0eb6 19			    add hl,de 
0eb7			Mult12U_NoAdd3: 
0eb7 29			    add hl,hl 
0eb8 87			    add a,a 
0eb9 30 01		    jr nc,Mult12U_NoAdd4 
0ebb 19			    add hl,de 
0ebc			Mult12U_NoAdd4: 
0ebc 29			    add hl,hl 
0ebd 87			    add a,a 
0ebe 30 01		    jr nc,Mult12U_NoAdd5 
0ec0 19			    add hl,de 
0ec1			Mult12U_NoAdd5: 
0ec1 29			    add hl,hl 
0ec2 87			    add a,a 
0ec3 30 01		    jr nc,Mult12U_NoAdd6 
0ec5 19			    add hl,de 
0ec6			Mult12U_NoAdd6: 
0ec6 29			    add hl,hl 
0ec7 87			    add a,a 
0ec8 d0			    ret nc 
0ec9 19			    add hl,de 
0eca c9			    ret 
0ecb			 
0ecb			; 
0ecb			; Multiply 8-bit value with a 16-bit value (right rotating) 
0ecb			; In: Multiply A with DE 
0ecb			;      Put lowest value in A for most efficient calculation 
0ecb			; Out: HL = result 
0ecb			; 
0ecb			Mult12R: 
0ecb 21 00 00		    ld hl,0 
0ece			Mult12R_Loop: 
0ece cb 3f		    srl a 
0ed0 30 01		    jr nc,Mult12R_NoAdd 
0ed2 19			    add hl,de 
0ed3			Mult12R_NoAdd: 
0ed3 cb 23		    sla e 
0ed5 cb 12		    rl d 
0ed7 b7			    or a 
0ed8 c2 ce 0e		    jp nz,Mult12R_Loop 
0edb c9			    ret 
0edc			 
0edc			; 
0edc			; Multiply 16-bit values (with 32-bit result) 
0edc			; In: Multiply BC with DE 
0edc			; Out: BCHL = result 
0edc			; 
0edc			Mult32: 
0edc 79			    ld a,c 
0edd 48			    ld c,b 
0ede 21 00 00		    ld hl,0 
0ee1 06 10		    ld b,16 
0ee3			Mult32_Loop: 
0ee3 29			    add hl,hl 
0ee4 17			    rla 
0ee5 cb 11		    rl c 
0ee7 30 07		    jr nc,Mult32_NoAdd 
0ee9 19			    add hl,de 
0eea ce 00		    adc a,0 
0eec d2 f0 0e		    jp nc,Mult32_NoAdd 
0eef 0c			    inc c 
0ef0			Mult32_NoAdd: 
0ef0 10 f1		    djnz Mult32_Loop 
0ef2 41			    ld b,c 
0ef3 4f			    ld c,a 
0ef4 c9			    ret 
0ef5			 
0ef5			 
0ef5			 
0ef5			; 
0ef5			; Multiply 8-bit values 
0ef5			; In:  Multiply H with E 
0ef5			; Out: HL = result 
0ef5			; 
0ef5			Mult8: 
0ef5 16 00		    ld d,0 
0ef7 6a			    ld l,d 
0ef8 06 08		    ld b,8 
0efa			Mult8_Loop: 
0efa 29			    add hl,hl 
0efb 30 01		    jr nc,Mult8_NoAdd 
0efd 19			    add hl,de 
0efe			Mult8_NoAdd: 
0efe 10 fa		    djnz Mult8_Loop 
0f00 c9			    ret 
0f01			 
0f01			 
0f01			 
0f01			 
0f01			 
0f01			 
0f01			 
0f01			 
0f01			;;http://z80-heaven.wikidot.com/math 
0f01			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f01			; 
0f01			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f01			;     ld a,16        ;7 
0f01			;     ld hl,0        ;10 
0f01			;     jp $+5         ;10 
0f01			;.DivLoop: 
0f01			;       add hl,bc    ;-- 
0f01			;       dec a        ;64 
0f01			;       jr z,.DivLoopEnd        ;86 
0f01			; 
0f01			;       sla e        ;128 
0f01			;       rl d         ;128 
0f01			;       adc hl,hl    ;240 
0f01			;       sbc hl,bc    ;240 
0f01			;       jr nc,.DivLoop ;23|21 
0f01			;       inc e        ;-- 
0f01			;       jp .DivLoop+1 
0f01			; 
0f01			;.DivLoopEnd: 
0f01			 
0f01			;HL_Div_C: 
0f01			;Inputs: 
0f01			;     HL is the numerator 
0f01			;     C is the denominator 
0f01			;Outputs: 
0f01			;     A is the remainder 
0f01			;     B is 0 
0f01			;     C is not changed 
0f01			;     DE is not changed 
0f01			;     HL is the quotient 
0f01			; 
0f01			;       ld b,16 
0f01			;       xor a 
0f01			;         add hl,hl 
0f01			;         rla 
0f01			;         cp c 
0f01			;         jr c,$+4 
0f01			;           inc l 
0f01			;           sub c 
0f01			;         djnz $-7 
0f01			 
0f01			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f01			 
0f01			addatohl: 
0f01 85			    add   a, l    ; A = A+L 
0f02 6f			    ld    l, a    ; L = A+L 
0f03 8c			    adc   a, h    ; A = A+L+H+carry 
0f04 95			    sub   l       ; A = H+carry 
0f05 67			    ld    h, a    ; H = H+carry 
0f06 c9			ret 
0f07			 
0f07			addatode: 
0f07 83			    add   a, e    ; A = A+L 
0f08 5f			    ld    e, a    ; L = A+L 
0f09 8a			    adc   a, d    ; A = A+L+H+carry 
0f0a 93			    sub   e       ; A = H+carry 
0f0b 57			    ld    d, a    ; H = H+carry 
0f0c c9			ret 
0f0d			 
0f0d			 
0f0d			addatobc: 
0f0d 81			    add   a, c    ; A = A+L 
0f0e 4f			    ld    c, a    ; L = A+L 
0f0f 88			    adc   a, b    ; A = A+L+H+carry 
0f10 91			    sub   c       ; A = H+carry 
0f11 47			    ld    b, a    ; H = H+carry 
0f12 c9			ret 
0f13			 
0f13			subafromhl: 
0f13			   ; If A=0 do nothing 
0f13			    ; Otherwise flip A's sign. Since 
0f13			    ; the upper byte becomes -1, also 
0f13			    ; substract 1 from H. 
0f13 ed 44		    neg 
0f15 ca 1e 0f		    jp    z, Skip 
0f18 25			    dec   h 
0f19			     
0f19			    ; Now add the low byte as usual 
0f19			    ; Two's complement takes care of 
0f19			    ; ensuring the result is correct 
0f19 85			    add   a, l 
0f1a 6f			    ld    l, a 
0f1b 8c			    adc   a, h 
0f1c 95			    sub   l 
0f1d 67			    ld    h, a 
0f1e			Skip: 
0f1e c9				ret 
0f1f			 
0f1f			 
0f1f			; compare hl and de 
0f1f			; returns:  
0f1f			; if hl = de, z=1, s=0, c0=0 
0f1f			; if hl > de, z=0, s=0, c=0 
0f1f			; if hl < de, z=0, s=1, c=1 
0f1f			cmp16:	 
0f1f b7				or a 
0f20 ed 52			sbc hl,de 
0f22 e0				ret po 
0f23 7c				ld a,h 
0f24 1f				rra 
0f25 ee 40			xor 01000000B 
0f27 37				scf 
0f28 8f				adc a,a 
0f29 c9				ret 
0f2a			 
0f2a			 
0f2a			; test if hl contains zero   - A is destroyed 
0f2a			 
0f2a			ishlzero:    
0f2a b7				or a     ; reset flags 
0f2b 7c				ld a, h 
0f2c b5				or l        	 
0f2d			 
0f2d c9				ret 
0f2e			 
0f2e			 
0f2e			 
0f2e			 
0f2e			if FORTH_ENABLE_FLOATMATH 
0f2e			;include "float/bbcmath.z80" 
0f2e			include "float/lpfpcalc.asm" 
0f2e			endif 
0f2e			 
0f2e			 
0f2e			; eof 
0f2e			 
# End of file firmware_maths.asm
0f2e			include "firmware_strings.asm"   ; string handling  
0f2e			 
0f2e			 
0f2e			; TODO string len 
0f2e			; input text string, end on cr with zero term 
0f2e			; a offset into frame buffer to start prompt 
0f2e			; d is max length 
0f2e			; e is display size TODO 
0f2e			; c is current cursor position 
0f2e			; hl is ptr to where string will be stored 
0f2e			 
0f2e			 
0f2e			; TODO check limit of buffer for new inserts 
0f2e			; TODO check insert does not push beyond buffer 
0f2e			; TODO scroll in a limited display area 
0f2e			; TODO scroll whole screen on page wrap 
0f2e			 
0f2e			 
0f2e			; TODO handle KEY_PREVWORD 
0f2e			; TODO handle KEY_NEXTWORD 
0f2e			; TODO handle KEY_HOME 
0f2e			; TODO handle KEY_END 
0f2e			; TODO use LCD cursor? 
0f2e			 
0f2e 32 ad fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f31 81					add c 
0f32 32 ab fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f35 22 b0 fe				ld (input_start), hl     ; save ptr to buffer 
0f38 79					ld a, c 
0f39 cd 01 0f				call addatohl 
0f3c 22 b2 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f3f 7a					ld a,d 
0f40 32 af fe			        ld (input_size), a       ; save length of input area 
0f43 79					ld a, c 
0f44 32 9e fe				ld (input_cursor),a      ; init cursor start position  
0f47 7b					ld a,e 
0f48 32 ae fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f4b					 
0f4b					 
0f4b			 
0f4b			;		ld a,(input_ptr) 
0f4b			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f4b			 
0f4b			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f4b					; init cursor shape if not set by the cin routines 
0f4b 21 4d fd				ld hl, cursor_shape 
0f4e 3e ff				ld a, 255 
0f50 77					ld (hl), a 
0f51 23					inc hl 
0f52 3e 00				ld a, 0 
0f54 77					ld (hl), a 
0f55			 
0f55 3e 0f				ld a, CUR_BLINK_RATE 
0f57 32 a9 fe				ld (input_cur_flash), a 
0f5a 3e 01				ld a, 1 
0f5c 32 a8 fe				ld (input_cur_onoff),a 
0f5f			 
0f5f			;	if DEBUG_INPUT 
0f5f			;		push af 
0f5f			;		ld a, 'I' 
0f5f			;		ld (debug_mark),a 
0f5f			;		pop af 
0f5f			;		CALLMONITOR 
0f5f			;	endif 
0f5f			.is1:		; main entry loop 
0f5f			 
0f5f			 
0f5f			 
0f5f					; pause 1ms 
0f5f			 
0f5f 3e 01				ld a, 1 
0f61 cd 2f 0c				call aDelayInMS 
0f64			 
0f64					; dec flash counter 
0f64 3a a9 fe				ld a, (input_cur_flash) 
0f67 3d					dec a 
0f68 32 a9 fe				ld (input_cur_flash), a 
0f6b fe 00				cp 0 
0f6d 20 0d				jr nz, .nochgstate 
0f6f			 
0f6f			 
0f6f					; change state 
0f6f 3a a8 fe				ld a,(input_cur_onoff) 
0f72 ed 44				neg 
0f74 32 a8 fe				ld (input_cur_onoff),a 
0f77			 
0f77			 
0f77					; reset on change of state 
0f77 3e 0f				ld a, CUR_BLINK_RATE 
0f79 32 a9 fe				ld (input_cur_flash), a 
0f7c			 
0f7c			.nochgstate: 
0f7c					 
0f7c					 
0f7c			 
0f7c					; display cursor  
0f7c			 
0f7c			;		ld hl, (input_start) 
0f7c			;		ld a, (input_cursor) 
0f7c			;		call addatohl 
0f7c			 
0f7c					; get char under cursor and replace with cursor 
0f7c 2a b2 fe		ld hl, (input_ptr) 
0f7f			;		ld a, (hl) 
0f7f			;		ld (input_under_cursor),a 
0f7f			;		ld a, '_' 
0f7f			;		ld (hl), a 
0f7f			 
0f7f					; display string 
0f7f			 
0f7f ed 5b b0 fe			ld de, (input_start) 
0f83 3a ad fe				ld a, (input_at_pos) 
0f86 cd e0 0c				call str_at_display 
0f89			;	        call update_display 
0f89			 
0f89					; find place to put the cursor 
0f89			;		add h 
0f89			;		ld l, display_row_1 
0f89			;		sub l 
0f89			; (input_at_pos) 
0f89					;ld c, a 
0f89			;		ld a, (input_cursor) 
0f89			;		ld l, (input_at_pos) 
0f89			;		;ld b, h 
0f89			;		add l 
0f89			;		ld (input_at_cursor),a 
0f89					;ld l,h 
0f89			 
0f89			;		ld h, 0 
0f89			;		ld l,(input_at_pos) 
0f89			;		ld a, (input_cursor) 
0f89			;		call addatohl 
0f89			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0f89			;		call subafromhl 
0f89			;		ld a,l 
0f89			;		ld (input_at_cursor), a 
0f89			 
0f89				if DEBUG_INPUT 
0f89					ld a, (hardware_diag) 
0f89					cp 0 
0f89					jr z, .skip_input_diag 
0f89			 
0f89					ld a,(input_at_pos) 
0f89					ld hl, LFSRSeed 
0f89					call hexout 
0f89					ld a, (input_cursor) 
0f89					ld hl, LFSRSeed+2 
0f89					call hexout 
0f89					ld a,(input_at_cursor) 
0f89					ld hl, LFSRSeed+4 
0f89					call hexout 
0f89			 
0f89					ld a,(input_cur_onoff) 
0f89					ld hl, LFSRSeed+6 
0f89					call hexout 
0f89			 
0f89					ld a,(input_cur_flash) 
0f89					ld hl, LFSRSeed+8 
0f89					call hexout 
0f89			 
0f89					ld a,(input_len) 
0f89					ld hl, LFSRSeed+10 
0f89					call hexout 
0f89					ld hl, LFSRSeed+12 
0f89					ld a, 0 
0f89					ld (hl),a 
0f89					ld a, display_row_4 
0f89					ld de, LFSRSeed 
0f89					call str_at_display 
0f89					.skip_input_diag: 
0f89				endif 
0f89			 
0f89					; decide on if we are showing the cursor this time round 
0f89			 
0f89 3a a8 fe				ld a, (input_cur_onoff) 
0f8c fe ff				cp 255 
0f8e 28 13				jr z, .skipcur 
0f90			 
0f90			 
0f90 3a ab fe				ld a,(input_at_cursor) 
0f93 11 4d fd				ld de, cursor_shape 
0f96 cd e0 0c				call str_at_display 
0f99			 
0f99					; save length of current input string 
0f99 2a b0 fe				ld hl, (input_start) 
0f9c cd 5f 13				call strlenz 
0f9f 7d					ld a,l 
0fa0 32 a3 fe				ld (input_len),a 
0fa3			 
0fa3			.skipcur: 
0fa3			 
0fa3 cd f0 0c			        call update_display 
0fa6					 
0fa6			 
0fa6			 
0fa6					; wait 
0fa6				 
0fa6					; TODO loop without wait to flash the cursor and char under cursor	 
0fa6 cd 59 6b				call cin    ; _wait 
0fa9			 
0fa9 fe 00				cp 0 
0fab ca 5f 0f				jp z, .is1 
0fae			 
0fae					; get ptr to char to input into 
0fae			 
0fae 4f					ld c,a 
0faf 2a b0 fe				ld hl, (input_start) 
0fb2 3a 9e fe				ld a, (input_cursor) 
0fb5 cd 01 0f				call addatohl 
0fb8 22 b2 fe				ld (input_ptr), hl 
0fbb 79					ld a,c 
0fbc			 
0fbc					; replace char under cursor 
0fbc			 
0fbc			;		ld hl, (input_ptr) 
0fbc			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0fbc			;		ld (hl), a 
0fbc			 
0fbc			;	if DEBUG_INPUT 
0fbc			;		push af 
0fbc			;		ld a, 'i' 
0fbc			;		ld (debug_mark),a 
0fbc			;		pop af 
0fbc			;		CALLMONITOR 
0fbc			;	endif 
0fbc fe 0e				cp KEY_HOME 
0fbe 20 0e				jr nz, .iske 
0fc0			 
0fc0 3a ad fe				ld a, (input_at_pos) 
0fc3 32 ab fe				ld (input_at_cursor),a 
0fc6 3e 00				ld a, 0 
0fc8 32 9e fe				ld (input_cursor), a 
0fcb c3 5f 0f				jp .is1 
0fce					 
0fce fe 0f		.iske:		cp KEY_END 
0fd0 20 03				jr nz, .isknw 
0fd2 c3 5f 0f				jp .is1 
0fd5			 
0fd5 fe 06		.isknw:		cp KEY_NEXTWORD 
0fd7 20 1b				jr nz, .iskpw 
0fd9			 
0fd9 2a b2 fe		.isknwm:	ld hl, (input_ptr) 
0fdc 7e					ld a,(hl)	 
0fdd fe 00				cp 0 
0fdf ca 5f 0f				jp z, .is1    ; end of string 
0fe2 fe 20				cp ' ' 
0fe4 ca 5f 0f				jp z, .is1    ; end of word 
0fe7 23					inc hl 
0fe8 22 b2 fe				ld (input_ptr), hl 
0feb 3a ab fe				ld a, (input_at_cursor) 
0fee 3c					inc a 
0fef 32 ab fe				ld (input_at_cursor), a 
0ff2 18 e5				jr .isknwm 
0ff4			 
0ff4 fe 07		.iskpw:		cp KEY_PREVWORD 
0ff6 20 1b				jr nz, .iskl 
0ff8			.iskpwm:	 
0ff8 2a b2 fe				ld hl, (input_ptr) 
0ffb 7e					ld a,(hl)	 
0ffc fe 00				cp 0  
0ffe ca 5f 0f				jp z, .is1    ; end of string 
1001 fe 20				cp ' ' 
1003 ca 5f 0f				jp z, .is1    ; end of word 
1006 2b					dec hl 
1007 22 b2 fe				ld (input_ptr), hl 
100a 3a ab fe				ld a, (input_at_cursor) 
100d 3d					dec a 
100e 32 ab fe				ld (input_at_cursor), a 
1011 18 e5				jr .iskpwm 
1013			 
1013			 
1013 fe 0b		.iskl:		cp KEY_LEFT 
1015 20 27				jr nz, .isk1 
1017			 
1017 3a 9e fe				ld a, (input_cursor) 
101a			 
101a fe 00				cp 0 
101c ca 5f 0f				jp z, .is1 		; at start of line to ignore  
101f			 
101f 3d					dec  a 		; TODO check underflow 
1020 32 9e fe				ld (input_cursor), a 
1023			 
1023 2a b2 fe				ld hl, (input_ptr) 
1026 2b					dec hl 
1027 22 b2 fe				ld (input_ptr), hl 
102a					 
102a 3a ab fe				ld a, (input_at_cursor) 
102d 3d					dec a 
102e 32 ab fe				ld (input_at_cursor), a 
1031			 
1031 3e 01				ld a, 1		; show cursor moving 
1033 32 a8 fe				ld (input_cur_onoff),a 
1036 3e 0f				ld a, CUR_BLINK_RATE 
1038 32 a9 fe				ld (input_cur_flash), a 
103b			 
103b c3 5f 0f				jp .is1 
103e			 
103e fe 0c		.isk1:		cp KEY_RIGHT 
1040 20 2a				jr nz, .isk2 
1042			 
1042 3a a3 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1045 5f					ld e,a 
1046 3a 9e fe				ld a, (input_cursor) 
1049 bb					cp e 
104a ca 5f 0f				jp z, .is1		; at the end of string so dont go right 
104d			 
104d 3c					inc  a 		; TODO check overflow 
104e 32 9e fe				ld (input_cursor), a 
1051			 
1051 3a ab fe				ld a, (input_at_cursor) 
1054 3c					inc a 
1055 32 ab fe				ld (input_at_cursor), a 
1058			 
1058 2a b2 fe				ld hl, (input_ptr) 
105b 23					inc hl 
105c 22 b2 fe				ld (input_ptr), hl 
105f			 
105f 3e 01				ld a, 1		; show cursor moving 
1061 32 a8 fe				ld (input_cur_onoff),a 
1064 3e 0f				ld a, CUR_BLINK_RATE 
1066 32 a9 fe				ld (input_cur_flash), a 
1069			 
1069 c3 5f 0f				jp .is1 
106c			 
106c fe 05		.isk2:		cp KEY_UP 
106e			 
106e 20 26				jr nz, .isk3 
1070			 
1070					; swap last command with the current on 
1070			 
1070					; move cursor to start of string 
1070 2a b0 fe				ld hl, (input_start) 
1073 22 b2 fe				ld (input_ptr), hl 
1076			 
1076 3a ad fe				ld a, (input_at_pos) 
1079 32 ab fe				ld (input_at_cursor), a 
107c			 
107c 3e 00				ld a, 0 
107e 32 9e fe				ld (input_cursor), a 
1081					 
1081					; swap input and last command buffers 
1081			 
1081 21 aa f6				ld hl, os_cli_cmd 
1084 11 a9 f7				ld de, os_last_cmd 
1087 06 ff				ld b, 255 
1089 7e			.swap1:		ld a, (hl) 
108a 4f					ld c,a 
108b 1a					ld a, (de) 
108c 77					ld (hl), a 
108d 79					ld a,c 
108e 12					ld (de),a 
108f 23					inc hl 
1090 13					inc de 
1091 10 f6				djnz .swap1 
1093			 
1093			 
1093			 
1093			 
1093			 
1093 c3 5f 0f				jp .is1 
1096			 
1096 fe 08		.isk3:		cp KEY_BS 
1098 20 3c				jr nz, .isk4 
109a			 
109a 3a 9e fe				ld a, (input_cursor) 
109d			 
109d fe 00				cp 0 
109f ca 5f 0f				jp z, .is1 		; at start of line to ignore  
10a2			 
10a2 3d					dec  a 		; TODO check underflow 
10a3 32 9e fe				ld (input_cursor), a 
10a6			 
10a6					; hl is source 
10a6					; de needs to be source - 1 
10a6			 
10a6			;		ld a, 0 
10a6			;		dec hl 
10a6			;		ld (hl), a 
10a6			 
10a6 2a b2 fe				ld hl, (input_ptr) 
10a9 2b					dec hl 
10aa 22 b2 fe				ld (input_ptr), hl 
10ad			 
10ad					; shift all data 
10ad			 
10ad e5					push hl 
10ae 23					inc hl 
10af d1					pop de 
10b0 3a a3 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10b3 4f					ld c,a 
10b4 06 00				ld b,0 
10b6 ed b0				ldir  
10b8			 
10b8			 
10b8			 
10b8			 
10b8 3a ab fe				ld a, (input_at_cursor) 
10bb 3d					dec a 
10bc 32 ab fe				ld (input_at_cursor), a 
10bf			 
10bf			 
10bf 3e 01				ld a, 1		; show cursor moving 
10c1 32 a8 fe				ld (input_cur_onoff),a 
10c4 3e 0f				ld a, CUR_BLINK_RATE 
10c6 32 a9 fe				ld (input_cur_flash), a 
10c9			 
10c9					; remove char 
10c9 3a ab fe				ld a, (input_at_cursor) 
10cc 3c					inc a 
10cd 11 57 11				ld de,.iblank 
10d0 cd e0 0c				call str_at_display 
10d3			 
10d3 c3 5f 0f				jp .is1 
10d6			 
10d6 fe 0d		.isk4:		cp KEY_CR 
10d8 28 6c				jr z, .endinput 
10da			 
10da					; else add the key press to the end 
10da			 
10da 4f					ld c, a			; save key pressed 
10db			 
10db 7e					ld a,(hl)		; get what is currently under char 
10dc			 
10dc fe 00				cp 0			; we are at the end of the string 
10de 20 2f				jr nz, .onchar 
10e0					 
10e0					; add a char to the end of the string 
10e0				 
10e0 71					ld (hl),c 
10e1 23					inc hl 
10e2			;		ld a,' ' 
10e2			;		ld (hl),a 
10e2			;		inc hl 
10e2 3e 00				ld a,0 
10e4 77					ld (hl),a 
10e5 2b					dec hl 
10e6			 
10e6 3a 9e fe				ld a, (input_cursor) 
10e9 3c					inc a				; TODO check max string length and scroll  
10ea 32 9e fe				ld (input_cursor), a		; inc cursor pos 
10ed							 
10ed 3a ab fe				ld a, (input_at_cursor) 
10f0 3c					inc a 
10f1 32 ab fe				ld (input_at_cursor), a 
10f4			 
10f4 2a b2 fe				ld hl, (input_ptr) 
10f7 23					inc hl 
10f8 22 b2 fe				ld (input_ptr), hl 
10fb			 
10fb 2a b2 fe				ld hl, (input_ptr) 
10fe 23					inc hl 
10ff 22 b2 fe				ld (input_ptr), hl 
1102			;	if DEBUG_INPUT 
1102			;		push af 
1102			;		ld a, '+' 
1102			;		ld (debug_mark),a 
1102			;		pop af 
1102			;		CALLMONITOR 
1102			;	endif 
1102 3e 01				ld a, 1		; show cursor moving 
1104 32 a8 fe				ld (input_cur_onoff),a 
1107 3e 0f				ld a, CUR_BLINK_RATE 
1109 32 a9 fe				ld (input_cur_flash), a 
110c c3 5f 0f				jp .is1 
110f					 
110f			 
110f			 
110f					; if on a char then insert 
110f			.onchar: 
110f			 
110f					; TODO over flow check: make sure insert does not blow out buffer 
110f			 
110f					; need to do some maths to use lddr 
110f			 
110f e5					push hl   ; save char pos 
1110 c5					push bc 
1111			 
1111 2a b0 fe				ld hl, (input_start) 
1114 3a a3 fe				ld a, (input_len) 
1117 cd 01 0f				call addatohl  		; end of string 
111a 23					inc hl 
111b 23					inc hl		; past zero term 
111c e5					push hl 
111d 23					inc hl 
111e e5					push hl  
111f			 
111f								; start and end of lddr set, now how much to move? 
111f			 
111f							 
111f 3a 9e fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1122 47					ld b,a 
1123 3a a3 fe				ld a,(input_len) 
1126 5f					ld e,a 
1127 90					sub b 
1128 3c					inc a		;?? 
1129 3c					inc a		;?? 
112a 3c					inc a		;?? 
112b			 
112b 06 00				ld b,0 
112d 4f					ld c,a 
112e			 
112e				if DEBUG_INPUT 
112e					push af 
112e					ld a, 'i' 
112e					ld (debug_mark),a 
112e					pop af 
112e			;		CALLMONITOR 
112e				endif 
112e d1					pop de 
112f e1					pop hl 
1130				if DEBUG_INPUT 
1130					push af 
1130					ld a, 'I' 
1130					ld (debug_mark),a 
1130					pop af 
1130			;		CALLMONITOR 
1130				endif 
1130 ed b8				lddr 
1132				 
1132			 
1132			 
1132					; TODO have a key for insert/overwrite mode???? 
1132 c1					pop bc 
1133 e1					pop hl 
1134 71					ld (hl), c		; otherwise overwrite current char 
1135					 
1135			 
1135			 
1135			 
1135 3a 9e fe				ld a, (input_cursor) 
1138 3c					inc  a 		; TODO check overflow 
1139 32 9e fe				ld (input_cursor), a 
113c			 
113c 3a ab fe				ld a, (input_at_cursor) 
113f 3c					inc a 
1140 32 ab fe				ld (input_at_cursor), a 
1143			 
1143 c3 5f 0f				jp .is1 
1146			 
1146			.endinput:	; TODO look for end of string 
1146			 
1146					; add trailing space for end of token 
1146			 
1146 2a b0 fe				ld hl, (input_start) 
1149 3a a3 fe				ld a,(input_len) 
114c cd 01 0f				call addatohl 
114f 3e 20				ld a, ' ' 
1151 77					ld (hl),a 
1152					; TODO eof of parse marker 
1152			 
1152 23					inc hl 
1153 3e 00				ld a, 0 
1155 77					ld (hl),a 
1156			 
1156			 
1156 c9					ret 
1157			 
1157 .. 00		.iblank: db " ",0 
1159			 
1159			 
1159 32 ad fe		input_str_prev:	ld (input_at_pos), a 
115c 22 b0 fe				ld (input_start), hl 
115f 3e 01				ld a,1			; add cursor 
1161 77					ld (hl),a 
1162 23					inc hl 
1163 3e 00				ld a,0 
1165 77					ld (hl),a 
1166 22 b2 fe				ld (input_ptr), hl 
1169 7a					ld a,d 
116a 32 af fe				ld (input_size), a 
116d 3e 00				ld a,0 
116f 32 9e fe				ld (input_cursor),a 
1172			.instr1:	 
1172			 
1172					; TODO do block cursor 
1172					; TODO switch cursor depending on the modifer key 
1172			 
1172					; update cursor shape change on key hold 
1172			 
1172 2a b2 fe				ld hl, (input_ptr) 
1175 2b					dec hl 
1176 3a 4d fd				ld a,(cursor_shape) 
1179 77					ld (hl), a 
117a			 
117a					; display entered text 
117a 3a ad fe				ld a,(input_at_pos) 
117d cd 77 6a		            	CALL fLCD_Pos       ;Position cursor to location in A 
1180 ed 5b b0 fe	            	LD   de, (input_start) 
1184 cd 7f 6a		            	CALL fLCD_Str       ;Display string pointed to by DE 
1187			 
1187 cd 59 6b				call cin 
118a fe 00				cp 0 
118c 28 e4				jr z, .instr1 
118e			 
118e					; proecess keyboard controls first 
118e			 
118e 2a b2 fe				ld hl,(input_ptr) 
1191			 
1191 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1193 28 5a				jr z, .instrcr 
1195			 
1195 fe 08				cp KEY_BS 	; back space 
1197 20 0f				jr nz, .instr2 
1199					; process back space 
1199			 
1199					; TODO stop back space if at start of string 
1199 2b					dec hl 
119a 2b					dec hl ; to over write cursor 
119b 3a 4d fd				ld a,(cursor_shape) 
119e					;ld a,0 
119e 77					ld (hl),a 
119f 23					inc hl 
11a0 3e 20				ld a," " 
11a2 77					ld (hl),a 
11a3 22 b2 fe				ld (input_ptr),hl 
11a6					 
11a6			 
11a6 18 ca				jr .instr1 
11a8			 
11a8 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11aa 20 06				jr nz, .instr3 
11ac 2b					dec hl 
11ad 22 b2 fe				ld (input_ptr),hl 
11b0 18 c0				jr .instr1 
11b2				 
11b2 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11b4 20 06				jr nz, .instr4 
11b6 23					inc hl 
11b7 22 b2 fe				ld (input_ptr),hl 
11ba 18 b6				jr .instr1 
11bc			 
11bc fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
11be 20 06				jr nz, .instr5 
11c0 2b					dec hl 
11c1 22 b2 fe				ld (input_ptr),hl 
11c4 18 ac				jr .instr1 
11c6			 
11c6 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
11c8 20 06				jr nz, .instr6 
11ca 2b					dec hl 
11cb 22 b2 fe				ld (input_ptr),hl 
11ce 18 a2				jr .instr1 
11d0 fe 05		.instr6:        cp KEY_UP      ; recall last command 
11d2 20 0b				jr nz, .instrnew 
11d4			 
11d4 21 83 f3			ld hl, scratch 
11d7 11 a9 f7			ld de, os_last_cmd 
11da cd f8 11			call strcpy 
11dd 18 93				jr .instr1 
11df			 
11df			 
11df			.instrnew:	; no special key pressed to see if we have room to store it 
11df			 
11df					; TODO do string size test 
11df			 
11df 2b					dec hl ; to over write cursor 
11e0 77					ld (hl),a 
11e1 23					inc hl 
11e2 3a 4d fd				ld a,(cursor_shape) 
11e5 77					ld (hl),a 
11e6 23					inc hl 
11e7 3e 00				ld a,0 
11e9 77					ld (hl),a 
11ea			 
11ea 22 b2 fe				ld (input_ptr),hl 
11ed					 
11ed 18 83				jr .instr1 
11ef 2b			.instrcr:	dec hl		; remove cursor 
11f0 3e 20				ld a,' '	; TODO add a trailing space for safety 
11f2 77					ld (hl),a 
11f3 23					inc hl 
11f4 3e 00				ld a,0 
11f6 77					ld (hl),a 
11f7			 
11f7			 
11f7					; if at end of line scroll up    
11f7					; TODO detecting only end of line 4 for scroll up  
11f7			 
11f7					;ld   
11f7			 
11f7 c9					ret 
11f8			 
11f8			 
11f8			; strcpy hl = dest, de source 
11f8			 
11f8 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11f9 b7			            OR   A              ;Null terminator? 
11fa c8			            RET  Z              ;Yes, so finished 
11fb 1a					ld a,(de) 
11fc 77					ld (hl),a 
11fd 13			            INC  DE             ;Point to next character 
11fe 23					inc hl 
11ff 18 f7		            JR   strcpy       ;Repeat 
1201 c9					ret 
1202			 
1202			 
1202			; TODO string_at  
1202			; pass string which starts with lcd offset address and then null term string 
1202			 
1202			; TODO string to dec 
1202			; TODO string to hex 
1202			; TODO byte to string hex 
1202			; TODO byte to string dec 
1202			 
1202			 
1202			 
1202			; from z80uartmonitor 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1202			; pass hl for where to put the text 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202 c5			hexout:	PUSH BC 
1203 f5					PUSH AF 
1204 47					LD B, A 
1205					; Upper nybble 
1205 cb 3f				SRL A 
1207 cb 3f				SRL A 
1209 cb 3f				SRL A 
120b cb 3f				SRL A 
120d cd 1d 12				CALL tohex 
1210 77					ld (hl),a 
1211 23					inc hl	 
1212					 
1212					; Lower nybble 
1212 78					LD A, B 
1213 e6 0f				AND 0FH 
1215 cd 1d 12				CALL tohex 
1218 77					ld (hl),a 
1219 23					inc hl	 
121a					 
121a f1					POP AF 
121b c1					POP BC 
121c c9					RET 
121d					 
121d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
121d			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
121d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
121d			tohex: 
121d e5					PUSH HL 
121e d5					PUSH DE 
121f 16 00				LD D, 0 
1221 5f					LD E, A 
1222 21 2a 12				LD HL, .DATA 
1225 19					ADD HL, DE 
1226 7e					LD A, (HL) 
1227 d1					POP DE 
1228 e1					POP HL 
1229 c9					RET 
122a			 
122a			.DATA: 
122a 30					DEFB	30h	; 0 
122b 31					DEFB	31h	; 1 
122c 32					DEFB	32h	; 2 
122d 33					DEFB	33h	; 3 
122e 34					DEFB	34h	; 4 
122f 35					DEFB	35h	; 5 
1230 36					DEFB	36h	; 6 
1231 37					DEFB	37h	; 7 
1232 38					DEFB	38h	; 8 
1233 39					DEFB	39h	; 9 
1234 41					DEFB	41h	; A 
1235 42					DEFB	42h	; B 
1236 43					DEFB	43h	; C 
1237 44					DEFB	44h	; D 
1238 45					DEFB	45h	; E 
1239 46					DEFB	46h	; F 
123a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
123a			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
123a			;;    subtract $30, if result > 9 then subtract $7 more 
123a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
123a			atohex: 
123a d6 30				SUB $30 
123c fe 0a				CP 10 
123e f8					RET M		; If result negative it was 0-9 so we're done 
123f d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1241 c9					RET		 
1242			 
1242			 
1242			 
1242			 
1242			; Get 2 ASCII characters as hex byte from pointer in hl 
1242			 
1242			BYTERD: 
1242 16 00			LD	D,00h		;Set up 
1244 cd 4c 12			CALL	HEXCON		;Get byte and convert to hex 
1247 87				ADD	A,A		;First nibble so 
1248 87				ADD	A,A		;multiply by 16 
1249 87				ADD	A,A		; 
124a 87				ADD	A,A		; 
124b 57				LD	D,A		;Save hi nibble in D 
124c			HEXCON: 
124c 7e				ld a, (hl)		;Get next chr 
124d 23				inc hl 
124e d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1250 fe 0a			CP	00Ah		;Is it 0-9 ? 
1252 38 02			JR	C,NALPHA	;If so miss next bit 
1254 d6 07			SUB	007h		;Else convert alpha 
1256			NALPHA: 
1256 b2				OR	D		;Add hi nibble back 
1257 c9				RET			; 
1258			 
1258			 
1258			; 
1258			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1258			; Since the routines get_byte and therefore get_nibble are called, only valid 
1258			; characters (0-9a-f) are accepted. 
1258			; 
1258			;get_word        push    af 
1258			;                call    get_byte        ; Get the upper byte 
1258			;                ld      h, a 
1258			;                call    get_byte        ; Get the lower byte 
1258			;                ld      l, a 
1258			;                pop     af 
1258			;                ret 
1258			; 
1258			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1258			; the routine get_nibble is used only valid characters are accepted - the  
1258			; input routine only accepts characters 0-9a-f. 
1258			; 
1258 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1259 7e					ld a,(hl) 
125a 23					inc hl 
125b cd 80 12		                call    nibble2val      ; Get upper nibble 
125e cb 07		                rlc     a 
1260 cb 07		                rlc     a 
1262 cb 07		                rlc     a 
1264 cb 07		                rlc     a 
1266 47			                ld      b, a            ; Save upper four bits 
1267 7e					ld a,(hl) 
1268 cd 80 12		                call    nibble2val      ; Get lower nibble 
126b b0			                or      b               ; Combine both nibbles 
126c c1			                pop     bc              ; Restore B (and C) 
126d c9			                ret 
126e			; 
126e			; Get a hexadecimal digit from the serial line. This routine blocks until 
126e			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
126e			; to the serial line interface. The lower 4 bits of A contain the value of  
126e			; that particular digit. 
126e			; 
126e			;get_nibble      ld a,(hl)           ; Read a character 
126e			;                call    to_upper        ; Convert to upper case 
126e			;                call    is_hex          ; Was it a hex digit? 
126e			;                jr      nc, get_nibble  ; No, get another character 
126e			 ;               call    nibble2val      ; Convert nibble to value 
126e			 ;               call    print_nibble 
126e			 ;               ret 
126e			; 
126e			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
126e			; A valid hexadecimal digit is denoted by a set C flag. 
126e			; 
126e			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
126e			;                ret     nc              ; Yes 
126e			;                cp      '0'             ; Less than '0'? 
126e			;                jr      nc, is_hex_1    ; No, continue 
126e			;                ccf                     ; Complement carry (i.e. clear it) 
126e			;                ret 
126e			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
126e			;                ret     c               ; Yes 
126e			;                cp      'A'             ; Less than 'A'? 
126e			;                jr      nc, is_hex_2    ; No, continue 
126e			;                ccf                     ; Yes - clear carry and return 
126e			;                ret 
126e			;is_hex_2        scf                     ; Set carry 
126e			;                ret 
126e			; 
126e			; Convert a single character contained in A to upper case: 
126e			; 
126e fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1270 d8			                ret     c 
1271 fe 7b		                cp      'z' + 1         ; > 'z'? 
1273 d0			                ret     nc              ; Nothing to do, either 
1274 e6 5f		                and     $5f             ; Convert to upper case 
1276 c9			                ret 
1277			 
1277			 
1277			to_lower: 
1277			 
1277			   ; if char is in [A-Z] make it lower case 
1277			 
1277			   ; enter : a = char 
1277			   ; exit  : a = lower case char 
1277			   ; uses  : af 
1277			 
1277 fe 41		   cp 'A' 
1279 d8			   ret c 
127a			    
127a fe 5b		   cp 'Z'+1 
127c d0			   ret nc 
127d			    
127d f6 20		   or $20 
127f c9			   ret 
1280			 
1280			; 
1280			; Expects a hexadecimal digit (upper case!) in A and returns the 
1280			; corresponding value in A. 
1280			; 
1280 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1282 38 02		                jr      c, nibble2val_1 ; Yes 
1284 d6 07		                sub     7               ; Adjust for A-F 
1286 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1288 e6 0f		                and     $f              ; Only return lower 4 bits 
128a c9			                ret 
128b			; 
128b			; Print_nibble prints a single hex nibble which is contained in the lower  
128b			; four bits of A: 
128b			; 
128b			;print_nibble    push    af              ; We won't destroy the contents of A 
128b			;                and     $f              ; Just in case... 
128b			;                add     a, '0'             ; If we have a digit we are done here. 
128b			;                cp      '9' + 1         ; Is the result > 9? 
128b			;                jr      c, print_nibble_1 
128b			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
128b			;print_nibble_1  call    putc            ; Print the nibble and 
128b			;                pop     af              ; restore the original value of A 
128b			;                ret 
128b			;; 
128b			;; Send a CR/LF pair: 
128b			; 
128b			;crlf            push    af 
128b			;                ld      a, cr 
128b			;                call    putc 
128b			;                ld      a, lf 
128b			;                call    putc 
128b			;                pop     af 
128b			;                ret 
128b			; 
128b			; Print_word prints the four hex digits of a word to the serial line. The  
128b			; word is expected to be in HL. 
128b			; 
128b			;print_word      push    hl 
128b			;                push    af 
128b			;                ld      a, h 
128b			;                call    print_byte 
128b			;                ld      a, l 
128b			;                call    print_byte 
128b			;                pop     af 
128b			;                pop     hl 
128b			;                ret 
128b			; 
128b			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
128b			; The byte to be printed is expected to be in A. 
128b			; 
128b			;print_byte      push    af              ; Save the contents of the registers 
128b			;                push    bc 
128b			;                ld      b, a 
128b			;                rrca 
128b			;                rrca 
128b			;                rrca 
128b			;                rrca 
128b			;                call    print_nibble    ; Print high nibble 
128b			;                ld      a, b 
128b			;                call    print_nibble    ; Print low nibble 
128b			;                pop     bc              ; Restore original register contents 
128b			;                pop     af 
128b			;                ret 
128b			 
128b			 
128b			 
128b			 
128b			 
128b			fourehexhl:  
128b 7e				ld a,(hl) 
128c cd 3a 12			call atohex 
128f cb 3f				SRL A 
1291 cb 3f				SRL A 
1293 cb 3f				SRL A 
1295 cb 3f				SRL A 
1297 47				ld b, a 
1298 23				inc hl 
1299 7e				ld a,(hl) 
129a 23				inc hl 
129b cd 3a 12			call atohex 
129e 80				add b 
129f 57				ld d,a 
12a0 7e				ld a,(hl) 
12a1 cd 3a 12			call atohex 
12a4 cb 3f				SRL A 
12a6 cb 3f				SRL A 
12a8 cb 3f				SRL A 
12aa cb 3f				SRL A 
12ac 47				ld b, a 
12ad 23				inc hl 
12ae 7e				ld a,(hl) 
12af 23				inc hl 
12b0 cd 3a 12			call atohex 
12b3 80				add b 
12b4 5f				ld e, a 
12b5 d5				push de 
12b6 e1				pop hl 
12b7 c9				ret 
12b8			 
12b8			; pass hl. returns z set if the byte at hl is a digit 
12b8			;isdigithl:  
12b8			;	push bc 
12b8			;	ld a,(hl) 
12b8			;	cp ':' 
12b8			;	jr nc, .isdf 		; > 
12b8			;	cp '0' 
12b8			;	jr c, .isdf		; < 
12b8			; 
12b8			;	; TODO find a better way to set z 
12b8			; 
12b8			;	ld b,a 
12b8			;	cp b 
12b8			;	pop bc 
12b8			;	ret 
12b8			; 
12b8			;.isdf:	; not digit so clear z 
12b8			; 
12b8			;	; TODO find a better way to unset z 
12b8			; 
12b8			;	ld b,a 
12b8			;	inc b 
12b8			;	cp b 
12b8			; 
12b8			;	pop bc 
12b8			;	ret 
12b8				 
12b8				 
12b8			 
12b8			 
12b8			; pass hl as the four byte address to load 
12b8			 
12b8			get_word_hl:  
12b8 e5				push hl 
12b9 cd 58 12			call get_byte 
12bc				 
12bc 47				ld b, a 
12bd			 
12bd e1				pop hl 
12be 23				inc hl 
12bf 23				inc hl 
12c0			 
12c0			; TODO not able to handle a-f  
12c0 7e				ld a,(hl) 
12c1			;	;cp ':' 
12c1			;	cp 'g' 
12c1			;	jr nc, .single_byte_hl 		; > 
12c1			;	cp 'G' 
12c1			;	jr nc, .single_byte_hl 		; > 
12c1			;	cp '0' 
12c1			;	jr c, .single_byte_hl		; < 
12c1			 
12c1				;call isdigithl 
12c1 fe 00			cp 0 
12c3 28 06			jr z, .single_byte_hl 
12c5			 
12c5			.getwhln:   ; hex word so get next byte 
12c5			 
12c5 cd 58 12			call get_byte 
12c8 6f				ld l, a 
12c9 60				ld h,b 
12ca c9				ret 
12cb 68			.single_byte_hl:   ld l,b 
12cc 26 00				ld h,0 
12ce c9					ret 
12cf			 
12cf			 
12cf			 
12cf			 
12cf 21 09 1c			ld hl,asc+1 
12d2			;	ld a, (hl) 
12d2			;	call nibble2val 
12d2 cd 58 12			call get_byte 
12d5			 
12d5			;	call fourehexhl 
12d5 32 b7 f3			ld (scratch+52),a 
12d8				 
12d8 21 b5 f3			ld hl,scratch+50 
12db 22 a6 f6			ld (os_cur_ptr),hl 
12de			 
12de c9				ret 
12df			 
12df			 
12df			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12df			 
12df			; Decimal Unsigned Version 
12df			 
12df			;Number in a to decimal ASCII 
12df			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12df			;Example: display a=56 as "056" 
12df			;input: a = number 
12df			;Output: a=0,value of a in the screen 
12df			;destroys af,bc (don't know about hl and de) 
12df			DispAToASCII: 
12df 0e 9c			ld	c,-100 
12e1 cd eb 12			call	.Na1 
12e4 0e f6			ld	c,-10 
12e6 cd eb 12			call	.Na1 
12e9 0e ff			ld	c,-1 
12eb 06 2f		.Na1:	ld	b,'0'-1 
12ed 04			.Na2:	inc	b 
12ee 81				add	a,c 
12ef 38 fc			jr	c,.Na2 
12f1 91				sub	c		;works as add 100/10/1 
12f2 f5				push af		;safer than ld c,a 
12f3 78				ld	a,b		;char is in b 
12f4			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12f4 f1				pop af		;safer than ld a,c 
12f5 c9				ret 
12f6			 
12f6			; Decimal Signed Version 
12f6			 
12f6			; DispA 
12f6			; -------------------------------------------------------------- 
12f6			; Converts a signed integer value to a zero-terminated ASCII 
12f6			; string representative of that value (using radix 10). 
12f6			; -------------------------------------------------------------- 
12f6			; INPUTS: 
12f6			;     HL     Value to convert (two's complement integer). 
12f6			;     DE     Base address of string destination. (pointer). 
12f6			; -------------------------------------------------------------- 
12f6			; OUTPUTS: 
12f6			;     None 
12f6			; -------------------------------------------------------------- 
12f6			; REGISTERS/MEMORY DESTROYED 
12f6			; AF HL 
12f6			; -------------------------------------------------------------- 
12f6			 
12f6			;DispHLToASCII: 
12f6			;   push    de 
12f6			;   push    bc 
12f6			; 
12f6			;; Detect sign of HL. 
12f6			;    bit    7, h 
12f6			;    jr     z, ._DoConvert 
12f6			; 
12f6			;; HL is negative. Output '-' to string and negate HL. 
12f6			;    ld     a, '-' 
12f6			;    ld     (de), a 
12f6			;    inc    de 
12f6			; 
12f6			;; Negate HL (using two's complement) 
12f6			;    xor    a 
12f6			;    sub    l 
12f6			;    ld     l, a 
12f6			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12f6			;    sbc    a, h 
12f6			;    ld     h, a 
12f6			; 
12f6			;; Convert HL to digit characters 
12f6			;._DoConvert: 
12f6			;    ld     b, 0     ; B will count character length of number 
12f6			;-   ld     a, 10 
12f6			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12f6			;    push   af 
12f6			;    inc    b 
12f6			;    ld     a, h 
12f6			;    or     l 
12f6			;    jr     nz, - 
12f6			; 
12f6			;; Retrieve digits from stack 
12f6			;-   pop    af 
12f6			;    or     $30 
12f6			;    ld     (de), a 
12f6			;    inc    de 
12f6			;    djnz   - 
12f6			; 
12f6			;; Terminate string with NULL 
12f6			;    xor    a 
12f6			;    ld     (de), a 
12f6			; 
12f6			;    pop    bc 
12f6			;    pop    de 
12f6			;    ret 
12f6			 
12f6			;Comments 
12f6			; 
12f6			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12f6			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12f6			;    Note that the output string will not be fixed-width. 
12f6			; 
12f6			;Example Usage 
12f6			; 
12f6			;    ld    hl, -1004 
12f6			;    ld    de, OP1 
12f6			;    call  DispA 
12f6			;    ld    hl, OP1 
12f6			;    syscall  PutS 
12f6			 
12f6			 
12f6			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f6			 
12f6			 
12f6			;Converts an ASCII string to an unsigned 16-bit integer 
12f6			;Quits when it reaches a non-decimal digit 
12f6			 
12f6			string_to_uint16: 
12f6			atoui_16: 
12f6			;Input: 
12f6			;     DE points to the string 
12f6			;Outputs: 
12f6			;     HL is the result 
12f6			;     A is the 8-bit value of the number 
12f6			;     DE points to the byte after the number 
12f6			;Destroys: 
12f6			;     BC 
12f6			;       if the string is non-empty, BC is HL/10 
12f6			;Size:  24 bytes 
12f6			;Speed: 42+d(104+{0,9}) 
12f6			;       d is the number of digits in the number 
12f6			;       max is 640 cycles for a 5 digit number 
12f6			;Assuming no leading zeros: 
12f6			;1 digit:  146cc 
12f6			;2 digit:  250cc 
12f6			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12f6			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12f6			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12f6			;avg: 544.81158447265625cc (544+13297/16384) 
12f6			;=============================================================== 
12f6 21 00 00		  ld hl,0 
12f9			.u16a: 
12f9 1a			  ld a,(de) 
12fa d6 30		  sub 30h 
12fc fe 0a		  cp 10 
12fe d0			  ret nc 
12ff 13			  inc de 
1300 44			  ld b,h 
1301 4d			  ld c,l 
1302 29			  add hl,hl 
1303 29			  add hl,hl 
1304 09			  add hl,bc 
1305 29			  add hl,hl 
1306 85			  add a,l 
1307 6f			  ld l,a 
1308 30 ef		  jr nc,.u16a 
130a 24			  inc h 
130b c3 f9 12		  jp .u16a 
130e			 
130e			 
130e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
130e			 
130e			;written by Zeda 
130e			;Converts a 16-bit unsigned integer to an ASCII string. 
130e			 
130e			uitoa_16: 
130e			;Input: 
130e			;   DE is the number to convert 
130e			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
130e			;Output: 
130e			;   HL points to the null-terminated ASCII string 
130e			;      NOTE: This isn't necessarily the same as the input HL. 
130e d5			  push de 
130f c5			  push bc 
1310 f5			  push af 
1311 eb			  ex de,hl 
1312			 
1312 01 f0 d8		  ld bc,-10000 
1315 3e 2f		  ld a,'0'-1 
1317 3c			  inc a 
1318 09			  add hl,bc  
1319 38 fc		   jr c,$-2 
131b 12			  ld (de),a 
131c 13			  inc de 
131d			 
131d 01 e8 03		  ld bc,1000 
1320 3e 3a		  ld a,'9'+1 
1322 3d			  dec a  
1323 09			  add hl,bc  
1324 30 fc		   jr nc,$-2 
1326 12			  ld (de),a 
1327 13			  inc de 
1328			 
1328 01 9c ff		  ld bc,-100 
132b 3e 2f		  ld a,'0'-1 
132d 3c			  inc a  
132e 09			  add hl,bc  
132f 38 fc		   jr c,$-2 
1331 12			  ld (de),a 
1332 13			  inc de 
1333			 
1333 7d			  ld a,l 
1334 26 3a		  ld h,'9'+1 
1336 25			  dec h  
1337 c6 0a		  add a,10  
1339 30 fb		   jr nc,$-3 
133b c6 30		  add a,'0' 
133d eb			  ex de,hl 
133e 72			  ld (hl),d 
133f 23			  inc hl 
1340 77			  ld (hl),a 
1341 23			  inc hl 
1342 36 00		  ld (hl),0 
1344			 
1344			;Now strip the leading zeros 
1344 0e fa		  ld c,-6 
1346 09			  add hl,bc 
1347 3e 30		  ld a,'0' 
1349 23			  inc hl  
134a be			  cp (hl)  
134b 28 fc		  jr z,$-2 
134d			 
134d			;Make sure that the string is non-empty! 
134d 7e			  ld a,(hl) 
134e b7			  or a 
134f 20 01		  jr nz,.atoub 
1351 2b			  dec hl 
1352			.atoub: 
1352			 
1352 f1			  pop af 
1353 c1			  pop bc 
1354 d1			  pop de 
1355 c9			  ret 
1356			 
1356			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1356			 
1356			toUpper: 
1356			;A is the char. 
1356			;If A is a lowercase letter, this sets it to the matching uppercase 
1356			;18cc or 30cc or 41cc 
1356			;avg: 26.75cc 
1356 fe 61		  cp 'a' 
1358 d8			  ret c 
1359 fe 7b		  cp 'z'+1 
135b d0			  ret nc 
135c d6 20		  sub 'a'-'A' 
135e c9			  ret 
135f			 
135f			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
135f			 
135f			; String Length 
135f			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
135f			 
135f			; Get the length of the null-terminated string starting at $8000 hl 
135f			;    LD     HL, $8000 
135f			 
135f			strlenz: 
135f			 
135f af			    XOR    A               ; Zero is the value we are looking for. 
1360 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1361 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1362			                           ; 65, 536 bytes (the entire addressable memory space). 
1362 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1364			 
1364			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1364 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1365 6f			    LD     L, A             ; number of bytes 
1366 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1368 2b			    DEC    HL              ; Compensate for null. 
1369 c9				ret 
136a			 
136a			; Get the length of the A terminated string starting at $8000 hl 
136a			;    LD     HL, $8000 
136a			 
136a			strlent: 
136a			 
136a			                  ; A is the value we are looking for. 
136a 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
136c 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
136e			                           ; 65, 536 bytes (the entire addressable memory space). 
136e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1370			 
1370			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1370 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1372 2e 00		    LD     L, 0             ; number of bytes 
1374 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1376 2b			    DEC    HL              ; Compensate for null. 
1377 c9				ret 
1378			 
1378			 
1378			;Comparing Strings 
1378			 
1378			;IN    HL     Address of string1. 
1378			;      DE     Address of string2. 
1378			 
1378			; doc given but wrong??? 
1378			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1378			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1378			; tested 
1378			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1378			 
1378			strcmp_old: 
1378 e5			    PUSH   HL 
1379 d5			    PUSH   DE 
137a			 
137a 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
137b be			    CP     (HL)            ; (want to minimize work). 
137c 38 01		    JR     C, Str1IsBigger 
137e 7e			    LD     A, (HL) 
137f			 
137f			Str1IsBigger: 
137f 4f			    LD     C, A             ; Put length in BC 
1380 06 00		    LD     B, 0 
1382 13			    INC    DE              ; Increment pointers to meat of string. 
1383 23			    INC    HL 
1384			 
1384			CmpLoop: 
1384 1a			    LD     A, (DE)          ; Compare bytes. 
1385 ed a1		    CPI 
1387 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1389 13			    INC    DE              ; Update pointer. 
138a ea 84 13		    JP     PE, CmpLoop 
138d			 
138d d1			    POP    DE 
138e e1			    POP    HL 
138f 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1390 be			    CP     (HL) 
1391 c9			    RET 
1392			 
1392			NoMatch: 
1392 2b			    DEC    HL 
1393 be			    CP     (HL)            ; Compare again to affect carry. 
1394 d1			    POP    DE 
1395 e1			    POP    HL 
1396 c9			    RET 
1397			 
1397			;; test strmp 
1397			; 
1397			;ld de, .str1 
1397			;ld hl, .str2 
1397			;call strcmp 
1397			;jr z, .z1 
1397			;;this 
1397			;	if DEBUG_FORTH_WORDS 
1397			;		DMARK "NZ1" 
1397			;		CALLMONITOR 
1397			;	endif 
1397			;.z1: 
1397			; 
1397			;	if DEBUG_FORTH_WORDS 
1397			;		DMARK "ZZ1" 
1397			;		CALLMONITOR 
1397			;	endif 
1397			; 
1397			;ld de, .str1 
1397			;ld hl, .str1 
1397			;call strcmp 
1397			;jr z, .z2 
1397			;;this 
1397			;	if DEBUG_FORTH_WORDS 
1397			;		DMARK "NZ2" 
1397			;		CALLMONITOR 
1397			;	endif 
1397			;.z2: 
1397			; 
1397			;	if DEBUG_FORTH_WORDS 
1397			;		DMARK "ZZ2" 
1397			;		CALLMONITOR 
1397			;	endif 
1397			; 
1397			;ld de, .str1 
1397			;ld hl, .str2 
1397			;call strcmp 
1397			;jr c, .c1 
1397			; 
1397			;	if DEBUG_FORTH_WORDS 
1397			;		DMARK "Nc1" 
1397			;		CALLMONITOR 
1397			;	endif 
1397			;.c1: 
1397			;;this 
1397			;	if DEBUG_FORTH_WORDS 
1397			;		DMARK "cc1" 
1397			;		CALLMONITOR 
1397			;	endif 
1397			; 
1397			;ld de, .str1 
1397			;ld hl, .str1 
1397			;call strcmp 
1397			;jr c, .c2 
1397			;;this 
1397			;	if DEBUG_FORTH_WORDS 
1397			;		DMARK "Nc2" 
1397			;		CALLMONITOR 
1397			;	endif 
1397			;.c2: 
1397			; 
1397			;	if DEBUG_FORTH_WORDS 
1397			;		DMARK "cc2" 
1397			;		CALLMONITOR 
1397			;	endif 
1397			;	NEXTW 
1397			;.str1:   db "string1",0 
1397			;.str2:   db "string2",0 
1397			 
1397			; only care about direct match or not 
1397			; hl and de strings 
1397			; zero set if the same 
1397			 
1397			strcmp: 
1397 1a				ld a, (de) 
1398 be				cp (hl) 
1399 28 02			jr z, .ssame 
139b b7				or a 
139c c9				ret 
139d			 
139d			.ssame:  
139d fe 00			cp 0 
139f c8				ret z 
13a0			 
13a0 23				inc hl 
13a1 13				inc de 
13a2 18 f3			jr strcmp 
13a4				 
13a4				 
13a4			 
13a4			 
13a4			 
13a4			 
13a4			; eof 
13a4			 
13a4			 
13a4			 
13a4			 
13a4			 
13a4			 
# End of file firmware_strings.asm
13a4			include "firmware_memory.asm"   ; malloc and free  
13a4			 
13a4			if DEBUG_FORTH_MALLOC_HIGH 
13a4			.mallocsize: db "Wants malloc >256",0 
13a4			.mallocasize: db "MALLOC gives >256",0 
13a4			.malloczero: db "MALLOC gives zero",0 
13a4			 
13a4			malloc_guard_zerolen: 
13a4				push hl 
13a4				push de 
13a4				push af 
13a4			 
13a4				ld de, 0 
13a4			        call cmp16 
13a4				jr nz, .lowalloz 
13a4			 
13a4				push hl 
13a4				push de 
13a4					ld hl, display_fb0 
13a4					ld (display_fb_active), hl 
13a4				call clear_display 
13a4				ld a, 0 
13a4				ld de, .malloczero 
13a4				call str_at_display 
13a4				call update_display 
13a4				call delay1s 
13a4				call delay1s 
13a4				ld a, 0 
13a4				ld (os_view_disable), a 
13a4			 
13a4				pop de 
13a4				pop hl 
13a4			 
13a4				 
13a4			 
13a4				CALLMONITOR 
13a4			.lowalloz: 
13a4			 
13a4			 
13a4				pop af 
13a4				pop de 
13a4				pop hl 
13a4			ret 
13a4			 
13a4			malloc_guard_entry: 
13a4				push hl 
13a4				push de 
13a4				push af 
13a4			 
13a4			 	or a      ;clear carry flag 
13a4				push hl 
13a4				ld de, 255 
13a4				sbc hl, de 
13a4				jr c, .lowalloc 
13a4			 
13a4				push de 
13a4					ld hl, display_fb0 
13a4					ld (display_fb_active), hl 
13a4				call clear_display 
13a4				ld a, 0 
13a4				ld de, .mallocsize 
13a4				call str_at_display 
13a4				call update_display 
13a4				call delay1s 
13a4				call delay1s 
13a4				ld a, 0 
13a4				ld (os_view_disable), a 
13a4			 
13a4				pop de 
13a4				pop hl 
13a4			 
13a4				 
13a4			 
13a4				CALLMONITOR 
13a4				jr .lowdone 
13a4			.lowalloc: 
13a4			 
13a4			 
13a4				pop hl 
13a4			.lowdone:	pop af 
13a4				pop de 
13a4				pop hl 
13a4			ret 
13a4			 
13a4			malloc_guard_exit: 
13a4				push hl 
13a4				push de 
13a4				push af 
13a4			 
13a4			 	or a      ;clear carry flag 
13a4				push hl 
13a4				ld de, 255 
13a4				sbc hl, de 
13a4				jr c, .lowallocx 
13a4			 
13a4				push de 
13a4					ld hl, display_fb0 
13a4					ld (display_fb_active), hl 
13a4				call clear_display 
13a4				ld a, 0 
13a4				ld de, .mallocasize 
13a4				call str_at_display 
13a4				call update_display 
13a4				call delay1s 
13a4				call delay1s 
13a4				ld a, 0 
13a4				ld (os_view_disable), a 
13a4				pop de 
13a4				pop hl 
13a4			 
13a4				CALLMONITOR 
13a4				jr .lowdonex 
13a4			.lowallocx: 
13a4			 
13a4				pop hl 
13a4			.lowdonex:	pop af 
13a4				pop de 
13a4				pop hl 
13a4			ret 
13a4			endif 
13a4			 
13a4			if MALLOC_2 
13a4			; Z80 Malloc and Free Functions 
13a4			 
13a4			; Malloc Function: 
13a4			; Input: 
13a4			;   HL: Size of block to allocate 
13a4			; Output: 
13a4			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13a4			 
13a4			malloc: 
13a4				 
13a4			if DEBUG_FORTH_MALLOC_HIGH 
13a4			call malloc_guard_entry 
13a4			endif 
13a4			 
13a4			 
13a4			 
13a4			 
13a4					if DEBUG_FORTH_MALLOC 
13a4						DMARK "mal" 
13a4						CALLMONITOR 
13a4					endif 
13a4			    push af            ; Save AF register 
13a4			    ld a, l            ; Load low byte of size into A 
13a4			    or h               ; Check if size is zero 
13a4			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13a4			 
13a4			    ; Allocate memory 
13a4			    ld hl, (heap_start) ; Load start of heap into HL 
13a4					if DEBUG_FORTH_MALLOC 
13a4						DMARK "ma1" 
13a4						CALLMONITOR 
13a4					endif 
13a4			    call malloc_internal ; Call internal malloc function 
13a4			    pop af             ; Restore AF register 
13a4			if DEBUG_FORTH_MALLOC_HIGH 
13a4			call malloc_guard_exit 
13a4			call malloc_guard_zerolen 
13a4			endif 
13a4			    ret                ; Return 
13a4			 
13a4			; Free Function: 
13a4			; Input: 
13a4			;   HL: Pointer to memory block to free 
13a4			; Output: 
13a4			;   None 
13a4			 
13a4			free: 
13a4			    push af            ; Save AF register 
13a4			    ld a, l            ; Load low byte of pointer into A 
13a4			    or h               ; Check if pointer is NULL 
13a4			    jp z, free_exit    ; If pointer is NULL, exit 
13a4			 
13a4			    ; Free memory 
13a4			    ld hl, (heap_start) ; Load start of heap into HL 
13a4			    call free_internal  ; Call internal free function 
13a4			    pop af             ; Restore AF register 
13a4			    ret                ; Return 
13a4			 
13a4			; Internal Malloc Function: 
13a4			; Input: 
13a4			;   HL: Size of block to allocate 
13a4			; Output: 
13a4			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13a4			 
13a4			malloc_internal: 
13a4			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13a4			    add hl, bc         ; Add management overhead to requested size 
13a4			    ex de, hl          ; Save total size in DE, and keep it in HL 
13a4					if DEBUG_FORTH_MALLOC 
13a4						DMARK "ma2" 
13a4						CALLMONITOR 
13a4					endif 
13a4			 
13a4			    ; Search for free memory block 
13a4			    ld de, (heap_end)  ; Load end of heap into DE 
13a4			    ld bc, 0           ; Initialize counter 
13a4			 
13a4					if DEBUG_FORTH_MALLOC 
13a4						DMARK "ma2" 
13a4						CALLMONITOR 
13a4					endif 
13a4			malloc_search_loop: 
13a4			    ; Check if current block is free 
13a4			    ld a, (hl)         ; Load current block's status (free or used) 
13a4			    cp 0               ; Compare with zero (free) 
13a4			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13a4			 
13a4			    ; Check if current block is large enough 
13a4			    ld a, (hl+1)       ; Load high byte of block size 
13a4			    cp l               ; Compare with low byte of requested size 
13a4			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13a4			 
13a4			    ld a, (hl+2)       ; Load low byte of block size 
13a4			    cp h               ; Compare with high byte of requested size 
13a4			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13a4			 
13a4			    ; Mark block as used 
13a4			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13a4			 
13a4			    ; Calculate remaining space in block 
13a4			    ld bc, 0           ; Clear BC 
13a4			    add hl, bc         ; Increment HL to point to start of data block 
13a4			    add hl, de         ; HL = HL + DE (total size) 
13a4			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13a4			    add hl, bc         ; Add management overhead to start of data block 
13a4			 
13a4			    ; Save pointer to allocated block in HL 
13a4			if DEBUG_FORTH_MALLOC_HIGH 
13a4						DMARK "ma5" 
13a4			call malloc_guard_exit 
13a4			call malloc_guard_zerolen 
13a4			endif 
13a4			    ret 
13a4			 
13a4			malloc_skip_block_check: 
13a4			    ; Move to the next block 
13a4			    ld bc, 3           ; Size of management overhead 
13a4			    add hl, bc         ; Move to the next block 
13a4			    inc de             ; Increment counter 
13a4			 
13a4			    ; Check if we have reached the end of heap 
13a4			    ld a, e            ; Load low byte of heap end address 
13a4			    cp (hl)            ; Compare with low byte of current address 
13a4			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13a4			    ld a, d            ; Load high byte of heap end address 
13a4			    cp 0               ; Check if it's zero (end of memory) 
13a4			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13a4			 
13a4			    ; If we reached here, allocation failed 
13a4			    xor a              ; Set result to NULL 
13a4			if DEBUG_FORTH_MALLOC_HIGH 
13a4						DMARK "ma6" 
13a4			call malloc_guard_exit 
13a4			call malloc_guard_zerolen 
13a4			endif 
13a4			    ret 
13a4			malloc_exit: 
13a4			if DEBUG_FORTH_MALLOC_HIGH 
13a4						DMARK "ma7" 
13a4			call malloc_guard_exit 
13a4			call malloc_guard_zerolen 
13a4			endif 
13a4			    ret 
13a4			 
13a4			; Internal Free Function: 
13a4			; Input: 
13a4			;   HL: Pointer to memory block to free 
13a4			; Output: 
13a4			;   None 
13a4			 
13a4			free_internal: 
13a4			    ld de, (heap_start) ; Load start of heap into DE 
13a4			    ld bc, 0            ; Initialize counter 
13a4			 
13a4			free_search_loop: 
13a4			    ; Check if current block contains the pointer 
13a4			    ld a, l             ; Load low byte of pointer 
13a4			    cp (hl+1)           ; Compare with high byte of current block's address 
13a4			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13a4			    ld a, h             ; Load high byte of pointer 
13a4			    cp (hl+2)           ; Compare with low byte of current block's address 
13a4			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13a4			 
13a4			    ; Mark block as free 
13a4			    ld (hl), 0          ; Set status byte to indicate free block 
13a4			    ret                 ; Return 
13a4			 
13a4			free_skip_block_check: 
13a4			    ; Move to the next block 
13a4			    ld bc, 3            ; Size of management overhead 
13a4			    add hl, bc          ; Move to the next block 
13a4			    inc de              ; Increment counter 
13a4			 
13a4			    ; Check if we have reached the end of heap 
13a4			    ld a, e             ; Load low byte of heap end address 
13a4			    cp (hl)             ; Compare with low byte of current address 
13a4			    jr nz, free_search_loop  ; If not equal, continue searching 
13a4			    ld a, d             ; Load high byte of heap end address 
13a4			    cp 0                ; Check if it's zero (end of memory) 
13a4			    jr nz, free_search_loop  ; If not zero, continue searching 
13a4			 
13a4			    ; If we reached here, pointer is not found in heap 
13a4			    ret 
13a4			 
13a4			free_exit: 
13a4			    ret                 ; Return 
13a4			 
13a4			; Define heap start and end addresses 
13a4			;heap_start:    .dw 0xC000   ; Start of heap 
13a4			;heap_end:      .dw 0xE000   ; End of heap 
13a4			 
13a4			endif 
13a4			 
13a4			 
13a4			if MALLOC_1 
13a4			 
13a4			 
13a4			 
13a4			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13a4			 
13a4			;moved to firmware.asm 
13a4			;heap_start        .equ  0x9000      ; Starting address of heap 
13a4			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13a4			 
13a4			;      .org 0 
13a4			;      jp    main 
13a4			 
13a4			 
13a4			;      .org  0x100 
13a4			;main: 
13a4			;      ld    HL, 0x8100 
13a4			;      ld    SP, HL 
13a4			; 
13a4			;      call  heap_init 
13a4			; 
13a4			;      ; Make some allocations 
13a4			;      ld    HL, 12 
13a4			;      call  malloc            ; Allocates 0x9004 
13a4			; 
13a4			;      ld    HL, 12 
13a4			;      call  malloc            ; Allocates 0x9014 
13a4			; 
13a4			;      ld    HL, 12 
13a4			;      call  malloc            ; Allocates 0x9024 
13a4			; 
13a4			;      ; Free some allocations 
13a4			;      ld    HL, 0x9014 
13a4			;      call  free 
13a4			; 
13a4			;      ld    HL, 0x9004 
13a4			;      call  free 
13a4			; 
13a4			;      ld    HL, 0x9024 
13a4			;      call  free 
13a4			; 
13a4			; 
13a4			;      halt 
13a4			 
13a4			 
13a4			;------------------------------------------------------------------------------ 
13a4			;     heap_init                                                               : 
13a4			;                                                                             : 
13a4			; Description                                                                 : 
13a4			;     Initialise the heap and make it ready for malloc and free operations.   : 
13a4			;                                                                             : 
13a4			;     The heap is maintained as a linked list, starting with an initial       : 
13a4			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13a4			;     the first free block in the heap. Each block then points to the next    : 
13a4			;     free block within the heap, and the free list ends at the first block   : 
13a4			;     with a null pointer to the next free block.                             : 
13a4			;                                                                             : 
13a4			; Parameters                                                                  : 
13a4			;     Inputs are compile-time only. Two defines which specify the starting    : 
13a4			;     address of the heap and its size are required, along with a memory      : 
13a4			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13a4			;     principally stores a pointer to the first free block in the heap.       : 
13a4			;                                                                             : 
13a4			; Returns                                                                     : 
13a4			;     Nothing                                                                 : 
13a4			;------------------------------------------------------------------------------ 
13a4			heap_init: 
13a4 e5			      push  HL 
13a5			 
13a5			      ; Initialise free list struct 
13a5 21 0e 80		      ld    HL, heap_start 
13a8 22 0a 80		      ld    (free_list), HL 
13ab 21 00 00		      ld    HL, 0 
13ae 22 0c 80		      ld    (free_list+2), HL 
13b1			 
13b1			      ; Insert first free block at bottom of heap, consumes entire heap 
13b1 21 0a 80		      ld    HL, heap_start+heap_size-4 
13b4 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13b7 21 fc ff		      ld    HL, heap_size-4 
13ba 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13bd			 
13bd			      ; Insert end of free list block at top of heap - two null words will 
13bd			      ; terminate the free list 
13bd 21 00 00		      ld    HL, 0 
13c0 22 0c 80		      ld    (heap_start+heap_size-2), HL 
13c3 22 0a 80		      ld    (heap_start+heap_size-4), HL 
13c6			 
13c6 e1			      pop   HL 
13c7			 
13c7 c9			      ret 
13c8			 
13c8			 
13c8			;------------------------------------------------------------------------------ 
13c8			;     malloc                                                                  : 
13c8			;                                                                             : 
13c8			; Description                                                                 : 
13c8			;     Allocates the wanted space from the heap and returns the address of the : 
13c8			;     first useable byte of the allocation.                                   : 
13c8			;                                                                             : 
13c8			;     Allocations can happen in one of two ways:                              : 
13c8			;                                                                             : 
13c8			;     1. A free block may be found which is the exact size wanted. In this    : 
13c8			;        case the block is removed from the free list and retuedn to the      : 
13c8			;        caller.                                                              : 
13c8			;     2. A free block may be found which is larger than the size wanted. In   : 
13c8			;        this case, the larger block is split into two. The first portion of  : 
13c8			;        this block will become the requested space by the malloc call and    : 
13c8			;        is returned to the caller. The second portion becomes a new free     : 
13c8			;        block, and the free list is adjusted to maintain continuity via this : 
13c8			;        newly created block.                                                 : 
13c8			;                                                                             : 
13c8			;     malloc does not set any initial value in the allocated space, the       : 
13c8			;     caller is required to do this as required.                              : 
13c8			;                                                                             : 
13c8			;     This implementation of malloc uses the stack exclusively, and is        : 
13c8			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13c8			;     advisable to disable interrupts before calling malloc, and recommended  : 
13c8			;     to avoid the use of malloc inside ISRs in general.                      : 
13c8			;                                                                             : 
13c8			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13c8			;                                                                             : 
13c8			; Parameters                                                                  : 
13c8			;     HL  Number of bytes wanted                                              : 
13c8			;                                                                             : 
13c8			; Returns                                                                     : 
13c8			;     HL  Address of the first useable byte of the allocation                 : 
13c8			;                                                                             : 
13c8			; Flags                                                                       : 
13c8			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13c8			;                                                                             : 
13c8			; Stack frame                                                                 : 
13c8			;       |             |                                                       : 
13c8			;       +-------------+                                                       : 
13c8			;       |     BC      |                                                       : 
13c8			;       +-------------+                                                       : 
13c8			;       |     DE      |                                                       : 
13c8			;       +-------------+                                                       : 
13c8			;       |     IX      |                                                       : 
13c8			;       +-------------+                                                       : 
13c8			;       |  prev_free  |                                                       : 
13c8			;   +4  +-------------+                                                       : 
13c8			;       |  this_free  |                                                       : 
13c8			;   +2  +-------------+                                                       : 
13c8			;       |  next_free  |                                                       : 
13c8			;   +0  +-------------+                                                       : 
13c8			;       |             |                                                       : 
13c8			;                                                                             : 
13c8			;------------------------------------------------------------------------------ 
13c8			 
13c8			 
13c8			;malloc: 
13c8			; 
13c8			;	SAVESP ON 1 
13c8			; 
13c8			;	call malloc_code 
13c8			; 
13c8			;	CHECKSP ON 1 
13c8			;	ret 
13c8			 
13c8			 
13c8			malloc: 
13c8 c5			      push  BC 
13c9 d5			      push  DE 
13ca dd e5		      push  IX 
13cc			if DEBUG_FORTH_MALLOC_HIGH 
13cc			call malloc_guard_entry 
13cc			endif 
13cc			 
13cc					if DEBUG_FORTH_MALLOC 
13cc						DMARK "mal" 
13cc						CALLMONITOR 
13cc					endif 
13cc 7c			      ld    A, H                    ; Exit if no space requested 
13cd b5			      or    L 
13ce ca 8d 14		      jp    Z, malloc_early_exit 
13d1			 
13d1			;inc hl 
13d1			;inc hl 
13d1			;inc hl 
13d1			; 
13d1			;inc hl 
13d1			;inc hl 
13d1			;inc hl 
13d1			;inc hl 
13d1			;inc hl 
13d1			;inc hl 
13d1			;inc hl 
13d1			;inc hl 
13d1			;inc hl 
13d1			 
13d1			 
13d1			 
13d1			 
13d1					if DEBUG_FORTH_MALLOC 
13d1						DMARK "maA" 
13d1						CALLMONITOR 
13d1					endif 
13d1			      ; Set up stack frame 
13d1 eb			      ex    DE, HL 
13d2 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13d5 39			      add   HL, SP 
13d6 f9			      ld    SP, HL 
13d7 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13db dd 39		      add   IX, SP 
13dd			 
13dd			      ; Setup initial state 
13dd 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13e0 19			      add   HL, DE 
13e1			 
13e1 44			      ld    B, H                    ; Move want to BC 
13e2 4d			      ld    C, L 
13e3			 
13e3 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13e6 dd 75 04		      ld    (IX+4), L 
13e9 dd 74 05		      ld    (IX+5), H 
13ec			 
13ec 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13ed 23			      inc   HL 
13ee 56			      ld    D, (HL) 
13ef dd 73 02		      ld    (IX+2), E 
13f2 dd 72 03		      ld    (IX+3), D 
13f5 eb			      ex    DE, HL                  ; this_free ptr into HL 
13f6			 
13f6					if DEBUG_FORTH_MALLOC 
13f6						DMARK "maB" 
13f6						CALLMONITOR 
13f6					endif 
13f6			      ; Loop through free block list to find some space 
13f6			malloc_find_space: 
13f6 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13f7 23			      inc   HL 
13f8 56			      ld    D, (HL) 
13f9			 
13f9 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13fa b3			      or    E 
13fb ca 87 14		      jp    Z, malloc_no_space 
13fe			 
13fe dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1401 dd 72 01		      ld    (IX+1), D 
1404			 
1404			      ; Does this block have enough space to make the allocation? 
1404 23			      inc   HL                      ; Load free block size into DE 
1405 5e			      ld    E, (HL) 
1406 23			      inc   HL 
1407 56			      ld    D, (HL) 
1408			 
1408 eb			      ex    DE, HL                  ; Check size of block against want 
1409 b7			      or    A                       ; Ensure carry flag clear 
140a ed 42		      sbc   HL, BC 
140c e5			      push  HL                      ; Store the result for later (new block size) 
140d			 
140d ca 5c 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1410 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1412			 
1412			      ; this_free block is not big enough, setup ptrs to test next free block 
1412 e1			      pop   HL                      ; Discard previous result 
1413			 
1413 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1416 dd 66 03		      ld    H, (IX+3) 
1419 dd 75 04		      ld    (IX+4), L 
141c dd 74 05		      ld    (IX+5), H 
141f			 
141f dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1422 dd 66 01		      ld    H, (IX+1) 
1425 dd 75 02		      ld    (IX+2), L 
1428 dd 74 03		      ld    (IX+3), H 
142b			 
142b					if DEBUG_FORTH_MALLOC 
142b						DMARK "MA>" 
142b						CALLMONITOR 
142b					endif 
142b 18 c9		      jr    malloc_find_space 
142d			 
142d			      ; split a bigger block into two - requested size and remaining size 
142d			malloc_alloc_split: 
142d					if DEBUG_FORTH_MALLOC 
142d						DMARK "MAs" 
142d						CALLMONITOR 
142d					endif 
142d eb			      ex    DE, HL                  ; Calculate address of new free block 
142e 2b			      dec   HL 
142f 2b			      dec   HL 
1430 2b			      dec   HL 
1431 09			      add   HL, BC 
1432			 
1432			      ; Create a new block and point it at next_free 
1432 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1435 dd 56 01		      ld    D, (IX+1) 
1438			 
1438 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1439 23			      inc   HL 
143a 72			      ld    (HL), D 
143b			 
143b d1			      pop   DE                      ; Store size of new block into new block 
143c 23			      inc   HL 
143d 73			      ld    (HL), E 
143e 23			      inc   HL 
143f 72			      ld    (HL), D 
1440			 
1440			      ; Update this_free ptr to point to new block 
1440 2b			      dec   HL 
1441 2b			      dec   HL 
1442 2b			      dec   HL 
1443			 
1443 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1446 dd 56 03		      ld    D, (IX+3) 
1449			 
1449 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
144c dd 74 03		      ld    (IX+3), H 
144f			 
144f			      ; Modify this_free block to be allocation 
144f eb			      ex    DE, HL 
1450 af			      xor   A                       ; Null the next block ptr of allocated block 
1451 77			      ld    (HL), A 
1452 23			      inc   HL 
1453 77			      ld    (HL), A 
1454			 
1454 23			      inc   HL                      ; Store want size into allocated block 
1455 71			      ld    (HL), C 
1456 23			      inc   HL 
1457 70			      ld    (HL), B 
1458 23			      inc   HL 
1459 e5			      push  HL                      ; Address of allocation to return 
145a			 
145a 18 19		      jr    malloc_update_links 
145c			 
145c			malloc_alloc_fit: 
145c e1			      pop   HL                      ; Dont need new block size, want is exact fit 
145d			 
145d					if DEBUG_FORTH_MALLOC 
145d						DMARK "MAf" 
145d						CALLMONITOR 
145d					endif 
145d			      ; Modify this_free block to be allocation 
145d eb			      ex    DE, HL 
145e 2b			      dec   HL 
145f 2b			      dec   HL 
1460 2b			      dec   HL 
1461			 
1461 af			      xor   A                       ; Null the next block ptr of allocated block 
1462 77			      ld    (HL), A 
1463 23			      inc   HL 
1464 77			      ld    (HL), A 
1465			 
1465 23			      inc   HL                      ; Store address of allocation to return 
1466 23			      inc   HL 
1467 23			      inc   HL 
1468 e5			      push  HL 
1469			 
1469			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1469 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
146c dd 66 01		      ld    H, (IX+1) 
146f			 
146f dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1472 dd 74 03		      ld    (IX+3), H 
1475			 
1475			 
1475			malloc_update_links: 
1475			      ; Update prev_free ptr to point to this_free 
1475 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1478 dd 66 05		      ld    H, (IX+5) 
147b			 
147b dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
147e dd 56 03		      ld    D, (IX+3) 
1481			 
1481 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1482 23			      inc   HL 
1483 72			      ld    (HL), D 
1484			 
1484					if DEBUG_FORTH_MALLOC 
1484						DMARK "Mul" 
1484						CALLMONITOR 
1484					endif 
1484			      ; Clear the Z flag to indicate successful allocation 
1484 7a			      ld    A, D 
1485 b3			      or    E 
1486			 
1486 d1			      pop   DE                      ; Address of allocation 
1487					if DEBUG_FORTH_MALLOC 
1487						DMARK "MAu" 
1487						CALLMONITOR 
1487					endif 
1487			 
1487			malloc_no_space: 
1487 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
148a 39			      add   HL, SP 
148b f9			      ld    SP, HL 
148c			 
148c eb			      ex    DE, HL                  ; Alloc addr into HL for return 
148d					if DEBUG_FORTH_MALLOC 
148d						DMARK "MAN" 
148d						CALLMONITOR 
148d					endif 
148d			 
148d			malloc_early_exit: 
148d					if DEBUG_FORTH_MALLOC 
148d						DMARK "MAx" 
148d						CALLMONITOR 
148d					endif 
148d dd e1		      pop   IX 
148f d1			      pop   DE 
1490 c1			      pop   BC 
1491			 
1491			if DEBUG_FORTH_MALLOC_HIGH 
1491			call malloc_guard_exit 
1491			call malloc_guard_zerolen 
1491			endif 
1491 c9			      ret 
1492			 
1492			 
1492			;------------------------------------------------------------------------------ 
1492			;     free                                                                    : 
1492			;                                                                             : 
1492			; Description                                                                 : 
1492			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1492			;     returned by malloc, otherwise the behaviour is undefined.               : 
1492			;                                                                             : 
1492			;     Where possible, directly adjacent free blocks will be merged together   : 
1492			;     into larger blocks to help ensure that the heap does not become         : 
1492			;     excessively fragmented.                                                 : 
1492			;                                                                             : 
1492			;     free does not clear or set any other value into the freed space, and    : 
1492			;     therefore its contents may be visible through subsequent malloc's. The  : 
1492			;     caller should clear the freed space as required.                        : 
1492			;                                                                             : 
1492			;     This implementation of free uses the stack exclusively, and is          : 
1492			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1492			;     advisable to disable interrupts before calling free, and recommended    : 
1492			;     to avoid the use of free inside ISRs in general.                        : 
1492			;                                                                             : 
1492			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1492			;                                                                             : 
1492			; Parameters                                                                  : 
1492			;     HL  Pointer to address of first byte of allocation to be freed          : 
1492			;                                                                             : 
1492			; Returns                                                                     : 
1492			;     Nothing                                                                 : 
1492			;                                                                             : 
1492			; Stack frame                                                                 : 
1492			;       |             |                                                       : 
1492			;       +-------------+                                                       : 
1492			;       |     BC      |                                                       : 
1492			;       +-------------+                                                       : 
1492			;       |     DE      |                                                       : 
1492			;       +-------------+                                                       : 
1492			;       |     IX      |                                                       : 
1492			;       +-------------+                                                       : 
1492			;       |  prev_free  |                                                       : 
1492			;   +2  +-------------+                                                       : 
1492			;       |  next_free  |                                                       : 
1492			;   +0  +-------------+                                                       : 
1492			;       |             |                                                       : 
1492			;                                                                             : 
1492			;------------------------------------------------------------------------------ 
1492			free: 
1492 c5			      push  BC 
1493 d5			      push  DE 
1494 dd e5		      push  IX 
1496			 
1496 7c			      ld    A, H                    ; Exit if ptr is null 
1497 b5			      or    L 
1498 ca 5c 15		      jp    Z, free_early_exit 
149b			 
149b			      ; Set up stack frame 
149b eb			      ex    DE, HL 
149c 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
149f 39			      add   HL, SP 
14a0 f9			      ld    SP, HL 
14a1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14a5 dd 39		      add   IX, SP 
14a7			 
14a7			      ; The address in HL points to the start of the useable allocated space, 
14a7			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14a7			      ; address of the block itself. 
14a7 eb			      ex    DE, HL 
14a8 11 fc ff		      ld    DE, -4 
14ab 19			      add   HL, DE 
14ac			 
14ac			      ; An allocated block must have a null next block pointer in it 
14ac 7e			      ld    A, (HL) 
14ad 23			      inc   HL 
14ae b6			      or    (HL) 
14af c2 57 15		      jp    NZ, free_done 
14b2			 
14b2 2b			      dec   HL 
14b3			 
14b3 44			      ld    B, H                    ; Copy HL to BC 
14b4 4d			      ld    C, L 
14b5			 
14b5			      ; Loop through the free list to find the first block with an address 
14b5			      ; higher than the block being freed 
14b5 21 0a 80		      ld    HL, free_list 
14b8			 
14b8			free_find_higher_block: 
14b8 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14b9 23			      inc   HL 
14ba 56			      ld    D, (HL) 
14bb 2b			      dec   HL 
14bc			 
14bc dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14bf dd 72 01		      ld    (IX+1), D 
14c2 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14c5 dd 74 03		      ld    (IX+3), H 
14c8			 
14c8 78			      ld    A, B                    ; Check if DE is greater than BC 
14c9 ba			      cp    D                       ; Compare MSB first 
14ca 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14cc 30 04		      jr    NC, free_find_higher_block_skip 
14ce 79			      ld    A, C 
14cf bb			      cp    E                       ; Then compare LSB 
14d0 38 08		      jr    C, free_found_higher_block 
14d2			 
14d2			free_find_higher_block_skip: 
14d2 7a			      ld    A, D                    ; Reached the end of the free list? 
14d3 b3			      or    E 
14d4 ca 57 15		      jp    Z, free_done 
14d7			 
14d7 eb			      ex    DE, HL 
14d8			 
14d8 18 de		      jr    free_find_higher_block 
14da			 
14da			free_found_higher_block: 
14da			      ; Insert freed block between prev and next free blocks 
14da 71			      ld    (HL), C                 ; Point prev free block to freed block 
14db 23			      inc   HL 
14dc 70			      ld    (HL), B 
14dd			 
14dd 60			      ld    H, B                    ; Point freed block at next free block 
14de 69			      ld    L, C 
14df 73			      ld    (HL), E 
14e0 23			      inc   HL 
14e1 72			      ld    (HL), D 
14e2			 
14e2			      ; Check if the freed block is adjacent to the next free block 
14e2 23			      inc   HL                      ; Load size of freed block into HL 
14e3 5e			      ld    E, (HL) 
14e4 23			      inc   HL 
14e5 56			      ld    D, (HL) 
14e6 eb			      ex    DE, HL 
14e7			 
14e7 09			      add   HL, BC                  ; Add addr of freed block and its size 
14e8			 
14e8 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14eb dd 56 01		      ld    D, (IX+1) 
14ee			 
14ee b7			      or    A                       ; Clear the carry flag 
14ef ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14f1 20 22		      jr    NZ, free_check_adjacent_to_prev 
14f3			 
14f3			      ; Freed block is adjacent to next, merge into one bigger block 
14f3 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14f4 5e			      ld    E, (HL) 
14f5 23			      inc   HL 
14f6 56			      ld    D, (HL) 
14f7 e5			      push  HL                      ; Save ptr to next block for later 
14f8			 
14f8 60			      ld    H, B                    ; Store ptr from next block into freed block 
14f9 69			      ld    L, C 
14fa 73			      ld    (HL), E 
14fb 23			      inc   HL 
14fc 72			      ld    (HL), D 
14fd			 
14fd e1			      pop   HL                      ; Restore ptr to next block 
14fe 23			      inc   HL                      ; Load size of next block into DE 
14ff 5e			      ld    E, (HL) 
1500 23			      inc   HL 
1501 56			      ld    D, (HL) 
1502 d5			      push  DE                      ; Save next block size for later 
1503			 
1503 60			      ld    H, B                    ; Load size of freed block into HL 
1504 69			      ld    L, C 
1505 23			      inc   HL 
1506 23			      inc   HL 
1507 5e			      ld    E, (HL) 
1508 23			      inc   HL 
1509 56			      ld    D, (HL) 
150a eb			      ex    DE, HL 
150b			 
150b d1			      pop   DE                      ; Restore size of next block 
150c 19			      add   HL, DE                  ; Add sizes of both blocks 
150d eb			      ex    DE, HL 
150e			 
150e 60			      ld    H, B                    ; Store new bigger size into freed block 
150f 69			      ld    L, C 
1510 23			      inc   HL 
1511 23			      inc   HL 
1512 73			      ld    (HL), E 
1513 23			      inc   HL 
1514 72			      ld    (HL), D 
1515			 
1515			free_check_adjacent_to_prev: 
1515			      ; Check if the freed block is adjacent to the prev free block 
1515 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1518 dd 66 03		      ld    H, (IX+3) 
151b			 
151b 23			      inc   HL                      ; Size of prev free block into DE 
151c 23			      inc   HL 
151d 5e			      ld    E, (HL) 
151e 23			      inc   HL 
151f 56			      ld    D, (HL) 
1520 2b			      dec   HL 
1521 2b			      dec   HL 
1522 2b			      dec   HL 
1523			 
1523 19			      add   HL, DE                  ; Add prev block addr and size 
1524			 
1524 b7			      or    A                       ; Clear the carry flag 
1525 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1527 20 2e		      jr    NZ, free_done 
1529			 
1529			      ; Freed block is adjacent to prev, merge into one bigger block 
1529 60			      ld    H, B                    ; Load next ptr from freed block into DE 
152a 69			      ld    L, C 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e e5			      push  HL                      ; Save freed block ptr for later 
152f			 
152f dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1532 dd 66 03		      ld    H, (IX+3) 
1535 73			      ld    (HL), E 
1536 23			      inc   HL 
1537 72			      ld    (HL), D 
1538			 
1538 e1			      pop   HL                      ; Restore freed block ptr 
1539 23			      inc   HL                      ; Load size of freed block into DE 
153a 5e			      ld    E, (HL) 
153b 23			      inc   HL 
153c 56			      ld    D, (HL) 
153d d5			      push  DE                      ; Save freed block size for later 
153e			 
153e dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1541 dd 66 03		      ld    H, (IX+3) 
1544 23			      inc   HL 
1545 23			      inc   HL 
1546 5e			      ld    E, (HL) 
1547 23			      inc   HL 
1548 56			      ld    D, (HL) 
1549			 
1549 e1			      pop   HL                      ; Add sizes of both blocks 
154a 19			      add   HL, DE 
154b eb			      ex    DE, HL 
154c			 
154c dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
154f dd 66 03		      ld    H, (IX+3) 
1552 23			      inc   HL 
1553 23			      inc   HL 
1554 73			      ld    (HL), E 
1555 23			      inc   HL 
1556 72			      ld    (HL), D 
1557			 
1557			free_done: 
1557 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
155a 39			      add   HL, SP 
155b f9			      ld    SP, HL 
155c			 
155c			free_early_exit: 
155c dd e1		      pop   IX 
155e d1			      pop   DE 
155f c1			      pop   BC 
1560			 
1560 c9			      ret 
1561			 
1561			; moved to firmware.asm 
1561			; 
1561			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1561			;                  .dw   0 
1561			 
1561			 
1561			endif 
1561			 
1561			 
1561			if MALLOC_3 
1561			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1561			;heap_start        .equ  0x9000      ; Starting address of heap 
1561			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1561			; 
1561			 ;     .org 0 
1561			  ;    jp    main 
1561			; 
1561			; 
1561			 ;     .org  0x100 
1561			;main: 
1561			 ;     ld    HL, 0x8100 
1561			  ;    ld    SP, HL 
1561			; 
1561			;      call  heap_init 
1561			 
1561			      ; Make some allocations 
1561			;      ld    HL, 12 
1561			;      call  malloc            ; Allocates 0x9004 
1561			; 
1561			 ;     ld    HL, 12 
1561			;      call  malloc            ; Allocates 0x9014 
1561			 
1561			;      ld    HL, 12 
1561			;      call  malloc            ; Allocates 0x9024 
1561			 
1561			      ; Free some allocations 
1561			;      ld    HL, 0x9014 
1561			;      call  free 
1561			 
1561			;      ld    HL, 0x9004 
1561			;      call  free 
1561			; 
1561			;      ld    HL, 0x9024 
1561			;      call  free 
1561			 
1561			 
1561			 ;     halt 
1561			 
1561			 
1561			;------------------------------------------------------------------------------ 
1561			;     heap_init                                                               : 
1561			;                                                                             : 
1561			; Description                                                                 : 
1561			;     Initialise the heap and make it ready for malloc and free operations.   : 
1561			;                                                                             : 
1561			;     The heap is maintained as a linked list, starting with an initial       : 
1561			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1561			;     the first free block in the heap. Each block then points to the next    : 
1561			;     free block within the heap, and the free list ends at the first block   : 
1561			;     with a null pointer to the next free block.                             : 
1561			;                                                                             : 
1561			; Parameters                                                                  : 
1561			;     Inputs are compile-time only. Two defines which specify the starting    : 
1561			;     address of the heap and its size are required, along with a memory      : 
1561			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1561			;     principally stores a pointer to the first free block in the heap.       : 
1561			;                                                                             : 
1561			; Returns                                                                     : 
1561			;     Nothing                                                                 : 
1561			;------------------------------------------------------------------------------ 
1561			heap_init: 
1561			      push  HL 
1561			 
1561			      ; Initialise free list struct 
1561			      ld    HL, heap_start 
1561			      ld    (free_list), HL 
1561			      ld    HL, 0 
1561			      ld    (free_list+2), HL 
1561			 
1561			      ; Insert first free block at bottom of heap, consumes entire heap 
1561			      ld    HL, heap_start+heap_size-4 
1561			      ld    (heap_start), HL        ; Next block (end of free list) 
1561			      ld    HL, heap_size-4 
1561			      ld    (heap_start+2), HL      ; Block size 
1561			 
1561			      ; Insert end of free list block at top of heap - two null words will 
1561			      ; terminate the free list 
1561			      ld    HL, 0 
1561			      ld    (heap_start+heap_size-2), HL 
1561			      ld    (heap_start+heap_size-4), HL 
1561			 
1561			      pop   HL 
1561			 
1561			      ret 
1561			 
1561			 
1561			;------------------------------------------------------------------------------ 
1561			;     malloc                                                                  : 
1561			;                                                                             : 
1561			; Description                                                                 : 
1561			;     Allocates the wanted space from the heap and returns the address of the : 
1561			;     first useable byte of the allocation.                                   : 
1561			;                                                                             : 
1561			;     Allocations can happen in one of two ways:                              : 
1561			;                                                                             : 
1561			;     1. A free block may be found which is the exact size wanted. In this    : 
1561			;        case the block is removed from the free list and retuedn to the      : 
1561			;        caller.                                                              : 
1561			;     2. A free block may be found which is larger than the size wanted. In   : 
1561			;        this case, the larger block is split into two. The first portion of  : 
1561			;        this block will become the requested space by the malloc call and    : 
1561			;        is returned to the caller. The second portion becomes a new free     : 
1561			;        block, and the free list is adjusted to maintain continuity via this : 
1561			;        newly created block.                                                 : 
1561			;                                                                             : 
1561			;     malloc does not set any initial value in the allocated space, the       : 
1561			;     caller is required to do this as required.                              : 
1561			;                                                                             : 
1561			;     This implementation of malloc uses the stack exclusively, and is        : 
1561			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1561			;     advisable to disable interrupts before calling malloc, and recommended  : 
1561			;     to avoid the use of malloc inside ISRs in general.                      : 
1561			;                                                                             : 
1561			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1561			;                                                                             : 
1561			; Parameters                                                                  : 
1561			;     HL  Number of bytes wanted                                              : 
1561			;                                                                             : 
1561			; Returns                                                                     : 
1561			;     HL  Address of the first useable byte of the allocation                 : 
1561			;                                                                             : 
1561			; Flags                                                                       : 
1561			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1561			;                                                                             : 
1561			; Stack frame                                                                 : 
1561			;       |             |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     BC      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     DE      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     IX      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |  prev_free  |                                                       : 
1561			;   +4  +-------------+                                                       : 
1561			;       |  this_free  |                                                       : 
1561			;   +2  +-------------+                                                       : 
1561			;       |  next_free  |                                                       : 
1561			;   +0  +-------------+                                                       : 
1561			;       |             |                                                       : 
1561			;                                                                             : 
1561			;------------------------------------------------------------------------------ 
1561			malloc: 
1561			      push  BC 
1561			      push  DE 
1561			      push  IX 
1561			 
1561			      ld    A, H                    ; Exit if no space requested 
1561			      or    L 
1561			      jp    Z, malloc_early_exit 
1561			 
1561			      ; Set up stack frame 
1561			      ex    DE, HL 
1561			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1561			      add   HL, SP 
1561			      ld    SP, HL 
1561			      ld    IX, 0                   ; Use IX as a frame pointer 
1561			      add   IX, SP 
1561			 
1561			      ; Setup initial state 
1561			      ld    HL, 4                   ; want must also include space used by block struct 
1561			      add   HL, DE 
1561			 
1561			      ld    B, H                    ; Move want to BC 
1561			      ld    C, L 
1561			 
1561			      ld    HL, free_list           ; Store prev_free ptr to stack 
1561			      ld    (IX+4), L 
1561			      ld    (IX+5), H 
1561			 
1561			      ld    E, (HL)                 ; Store this_free ptr to stack 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			      ld    (IX+2), E 
1561			      ld    (IX+3), D 
1561			      ex    DE, HL                  ; this_free ptr into HL 
1561			 
1561			      ; Loop through free block list to find some space 
1561			malloc_find_space: 
1561			      ld    E, (HL)                 ; Load next_free ptr into DE 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			 
1561			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1561			      or    E 
1561			      jp    Z, malloc_no_space 
1561			 
1561			      ld    (IX+0), E               ; Store next_free ptr to stack 
1561			      ld    (IX+1), D 
1561			 
1561			      ; Does this block have enough space to make the allocation? 
1561			      inc   HL                      ; Load free block size into DE 
1561			      ld    E, (HL) 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			 
1561			      ex    DE, HL                  ; Check size of block against want 
1561			      or    A                       ; Ensure carry flag clear 
1561			      sbc   HL, BC 
1561			      push  HL                      ; Store the result for later (new block size) 
1561			 
1561			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1561			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1561			 
1561			      ; this_free block is not big enough, setup ptrs to test next free block 
1561			      pop   HL                      ; Discard previous result 
1561			 
1561			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1561			      ld    H, (IX+3) 
1561			      ld    (IX+4), L 
1561			      ld    (IX+5), H 
1561			 
1561			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1561			      ld    H, (IX+1) 
1561			      ld    (IX+2), L 
1561			      ld    (IX+3), H 
1561			 
1561			      jr    malloc_find_space 
1561			 
1561			      ; split a bigger block into two - requested size and remaining size 
1561			malloc_alloc_split: 
1561			      ex    DE, HL                  ; Calculate address of new free block 
1561			      dec   HL 
1561			      dec   HL 
1561			      dec   HL 
1561			      add   HL, BC 
1561			 
1561			      ; Create a new block and point it at next_free 
1561			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1561			      ld    D, (IX+1) 
1561			 
1561			      ld    (HL), E                 ; Store next_free ptr into new block 
1561			      inc   HL 
1561			      ld    (HL), D 
1561			 
1561			      pop   DE                      ; Store size of new block into new block 
1561			      inc   HL 
1561			      ld    (HL), E 
1561			      inc   HL 
1561			      ld    (HL), D 
1561			 
1561			      ; Update this_free ptr to point to new block 
1561			      dec   HL 
1561			      dec   HL 
1561			      dec   HL 
1561			 
1561			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1561			      ld    D, (IX+3) 
1561			 
1561			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1561			      ld    (IX+3), H 
1561			 
1561			      ; Modify this_free block to be allocation 
1561			      ex    DE, HL 
1561			      xor   A                       ; Null the next block ptr of allocated block 
1561			      ld    (HL), A 
1561			      inc   HL 
1561			      ld    (HL), A 
1561			 
1561			      inc   HL                      ; Store want size into allocated block 
1561			      ld    (HL), C 
1561			      inc   HL 
1561			      ld    (HL), B 
1561			      inc   HL 
1561			      push  HL                      ; Address of allocation to return 
1561			 
1561			      jr    malloc_update_links 
1561			 
1561			malloc_alloc_fit: 
1561			      pop   HL                      ; Dont need new block size, want is exact fit 
1561			 
1561			      ; Modify this_free block to be allocation 
1561			      ex    DE, HL 
1561			      dec   HL 
1561			      dec   HL 
1561			      dec   HL 
1561			 
1561			      xor   A                       ; Null the next block ptr of allocated block 
1561			      ld    (HL), A 
1561			      inc   HL 
1561			      ld    (HL), A 
1561			 
1561			      inc   HL                      ; Store address of allocation to return 
1561			      inc   HL 
1561			      inc   HL 
1561			      push  HL 
1561			 
1561			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1561			      ld    L, (IX+0)               ; next_free to HL 
1561			      ld    H, (IX+1) 
1561			 
1561			      ld    (IX+2), L               ; HL to this_free 
1561			      ld    (IX+3), H 
1561			 
1561			 
1561			malloc_update_links: 
1561			      ; Update prev_free ptr to point to this_free 
1561			      ld    L, (IX+4)               ; prev_free ptr to HL 
1561			      ld    H, (IX+5) 
1561			 
1561			      ld    E, (IX+2)               ; this_free ptr to DE 
1561			      ld    D, (IX+3) 
1561			 
1561			      ld    (HL), E                 ; this_free ptr into prev_free 
1561			      inc   HL 
1561			      ld    (HL), D 
1561			 
1561			      ; Clear the Z flag to indicate successful allocation 
1561			      ld    A, D 
1561			      or    E 
1561			 
1561			      pop   DE                      ; Address of allocation 
1561			 
1561			malloc_no_space: 
1561			      ld    HL, 6                   ; Clean up stack frame 
1561			      add   HL, SP 
1561			      ld    SP, HL 
1561			 
1561			      ex    DE, HL                  ; Alloc addr into HL for return 
1561			 
1561			malloc_early_exit: 
1561			      pop   IX 
1561			      pop   DE 
1561			      pop   BC 
1561			 
1561			      ret 
1561			 
1561			 
1561			;------------------------------------------------------------------------------ 
1561			;     free                                                                    : 
1561			;                                                                             : 
1561			; Description                                                                 : 
1561			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1561			;     returned by malloc, otherwise the behaviour is undefined.               : 
1561			;                                                                             : 
1561			;     Where possible, directly adjacent free blocks will be merged together   : 
1561			;     into larger blocks to help ensure that the heap does not become         : 
1561			;     excessively fragmented.                                                 : 
1561			;                                                                             : 
1561			;     free does not clear or set any other value into the freed space, and    : 
1561			;     therefore its contents may be visible through subsequent malloc's. The  : 
1561			;     caller should clear the freed space as required.                        : 
1561			;                                                                             : 
1561			;     This implementation of free uses the stack exclusively, and is          : 
1561			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1561			;     advisable to disable interrupts before calling free, and recommended    : 
1561			;     to avoid the use of free inside ISRs in general.                        : 
1561			;                                                                             : 
1561			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1561			;                                                                             : 
1561			; Parameters                                                                  : 
1561			;     HL  Pointer to address of first byte of allocation to be freed          : 
1561			;                                                                             : 
1561			; Returns                                                                     : 
1561			;     Nothing                                                                 : 
1561			;                                                                             : 
1561			; Stack frame                                                                 : 
1561			;       |             |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     BC      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     DE      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     IX      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |  prev_free  |                                                       : 
1561			;   +2  +-------------+                                                       : 
1561			;       |  next_free  |                                                       : 
1561			;   +0  +-------------+                                                       : 
1561			;       |             |                                                       : 
1561			;                                                                             : 
1561			;------------------------------------------------------------------------------ 
1561			free: 
1561			      push  BC 
1561			      push  DE 
1561			      push  IX 
1561			 
1561			      ld    A, H                    ; Exit if ptr is null 
1561			      or    L 
1561			      jp    Z, free_early_exit 
1561			 
1561			      ; Set up stack frame 
1561			      ex    DE, HL 
1561			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1561			      add   HL, SP 
1561			      ld    SP, HL 
1561			      ld    IX, 0                   ; Use IX as a frame pointer 
1561			      add   IX, SP 
1561			 
1561			      ; The address in HL points to the start of the useable allocated space, 
1561			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1561			      ; address of the block itself. 
1561			      ex    DE, HL 
1561			      ld    DE, -4 
1561			      add   HL, DE 
1561			 
1561			      ; An allocated block must have a null next block pointer in it 
1561			      ld    A, (HL) 
1561			      inc   HL 
1561			      or    (HL) 
1561			      jp    NZ, free_done 
1561			 
1561			      dec   HL 
1561			 
1561			      ld    B, H                    ; Copy HL to BC 
1561			      ld    C, L 
1561			 
1561			      ; Loop through the free list to find the first block with an address 
1561			      ; higher than the block being freed 
1561			      ld    HL, free_list 
1561			 
1561			free_find_higher_block: 
1561			      ld    E, (HL)                 ; Load next ptr from free block 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			      dec   HL 
1561			 
1561			      ld    (IX+0), E               ; Save ptr to next free block 
1561			      ld    (IX+1), D 
1561			      ld    (IX+2), L               ; Save ptr to prev free block 
1561			      ld    (IX+3), H 
1561			 
1561			      ld    A, B                    ; Check if DE is greater than BC 
1561			      cp    D                       ; Compare MSB first 
1561			      jr    Z, $+4                  ; MSB the same, compare LSB 
1561			      jr    NC, free_find_higher_block_skip 
1561			      ld    A, C 
1561			      cp    E                       ; Then compare LSB 
1561			      jr    C, free_found_higher_block 
1561			 
1561			free_find_higher_block_skip: 
1561			      ld    A, D                    ; Reached the end of the free list? 
1561			      or    E 
1561			      jp    Z, free_done 
1561			 
1561			      ex    DE, HL 
1561			 
1561			      jr    free_find_higher_block 
1561			 
1561			free_found_higher_block: 
1561			      ; Insert freed block between prev and next free blocks 
1561			      ld    (HL), C                 ; Point prev free block to freed block 
1561			      inc   HL 
1561			      ld    (HL), B 
1561			 
1561			      ld    H, B                    ; Point freed block at next free block 
1561			      ld    L, C 
1561			      ld    (HL), E 
1561			      inc   HL 
1561			      ld    (HL), D 
1561			 
1561			      ; Check if the freed block is adjacent to the next free block 
1561			      inc   HL                      ; Load size of freed block into HL 
1561			      ld    E, (HL) 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			      ex    DE, HL 
1561			 
1561			      add   HL, BC                  ; Add addr of freed block and its size 
1561			 
1561			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1561			      ld    D, (IX+1) 
1561			 
1561			      or    A                       ; Clear the carry flag 
1561			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1561			      jr    NZ, free_check_adjacent_to_prev 
1561			 
1561			      ; Freed block is adjacent to next, merge into one bigger block 
1561			      ex    DE, HL                  ; Load next ptr from next block into DE 
1561			      ld    E, (HL) 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			      push  HL                      ; Save ptr to next block for later 
1561			 
1561			      ld    H, B                    ; Store ptr from next block into freed block 
1561			      ld    L, C 
1561			      ld    (HL), E 
1561			      inc   HL 
1561			      ld    (HL), D 
1561			 
1561			      pop   HL                      ; Restore ptr to next block 
1561			      inc   HL                      ; Load size of next block into DE 
1561			      ld    E, (HL) 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			      push  DE                      ; Save next block size for later 
1561			 
1561			      ld    H, B                    ; Load size of freed block into HL 
1561			      ld    L, C 
1561			      inc   HL 
1561			      inc   HL 
1561			      ld    E, (HL) 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			      ex    DE, HL 
1561			 
1561			      pop   DE                      ; Restore size of next block 
1561			      add   HL, DE                  ; Add sizes of both blocks 
1561			      ex    DE, HL 
1561			 
1561			      ld    H, B                    ; Store new bigger size into freed block 
1561			      ld    L, C 
1561			      inc   HL 
1561			      inc   HL 
1561			      ld    (HL), E 
1561			      inc   HL 
1561			      ld    (HL), D 
1561			 
1561			free_check_adjacent_to_prev: 
1561			      ; Check if the freed block is adjacent to the prev free block 
1561			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1561			      ld    H, (IX+3) 
1561			 
1561			      inc   HL                      ; Size of prev free block into DE 
1561			      inc   HL 
1561			      ld    E, (HL) 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			      dec   HL 
1561			      dec   HL 
1561			      dec   HL 
1561			 
1561			      add   HL, DE                  ; Add prev block addr and size 
1561			 
1561			      or    A                       ; Clear the carry flag 
1561			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1561			      jr    NZ, free_done 
1561			 
1561			      ; Freed block is adjacent to prev, merge into one bigger block 
1561			      ld    H, B                    ; Load next ptr from freed block into DE 
1561			      ld    L, C 
1561			      ld    E, (HL) 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			      push  HL                      ; Save freed block ptr for later 
1561			 
1561			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1561			      ld    H, (IX+3) 
1561			      ld    (HL), E 
1561			      inc   HL 
1561			      ld    (HL), D 
1561			 
1561			      pop   HL                      ; Restore freed block ptr 
1561			      inc   HL                      ; Load size of freed block into DE 
1561			      ld    E, (HL) 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			      push  DE                      ; Save freed block size for later 
1561			 
1561			      ld    L, (IX+2)               ; Load size of prev block into DE 
1561			      ld    H, (IX+3) 
1561			      inc   HL 
1561			      inc   HL 
1561			      ld    E, (HL) 
1561			      inc   HL 
1561			      ld    D, (HL) 
1561			 
1561			      pop   HL                      ; Add sizes of both blocks 
1561			      add   HL, DE 
1561			      ex    DE, HL 
1561			 
1561			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1561			      ld    H, (IX+3) 
1561			      inc   HL 
1561			      inc   HL 
1561			      ld    (HL), E 
1561			      inc   HL 
1561			      ld    (HL), D 
1561			 
1561			free_done: 
1561			      ld    HL, 4                   ; Clean up stack frame 
1561			      add   HL, SP 
1561			      ld    SP, HL 
1561			 
1561			free_early_exit: 
1561			      pop   IX 
1561			      pop   DE 
1561			      pop   BC 
1561			 
1561			      ret 
1561			 
1561			 
1561			;      .org 0x8000 
1561			; 
1561			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1561			 ;                 .dw   0 
1561			 
1561			endif 
1561			 
1561			 
1561			if MALLOC_4 
1561			 
1561			; My memory allocation code. Very very simple.... 
1561			; allocate space under 250 chars 
1561			 
1561			heap_init: 
1561				; init start of heap as zero 
1561				;  
1561			 
1561				ld hl, heap_start 
1561				ld a, 0 
1561				ld (hl), a      ; empty block 
1561				inc hl 
1561				ld a, 0 
1561				ld (hl), a      ; length of block 
1561				; write end of list 
1561				inc hl 
1561				ld a,(hl) 
1561				inc hl 
1561				ld a,(hl) 
1561				 
1561			 
1561				; init some malloc vars 
1561			 
1561				ld hl, 0 
1561				ld (free_list), hl       ; store last malloc location 
1561			 
1561				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1561				ld a, 0 
1561				ld (hl), a 
1561			 
1561			 
1561				ld hl, heap_start 
1561				;  
1561				  
1561				ret 
1561			 
1561			 
1561			;    free block marker 
1561			;    requested size  
1561			;    pointer to next block 
1561			;    .... 
1561			;    next block marker 
1561			 
1561			 
1561			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1561			; 
1561			 
1561			 
1561			malloc:  
1561				push de 
1561				push bc 
1561				push af 
1561			 
1561				; hl space required 
1561				 
1561				ld c, l    ; hold space   (TODO only a max of 255) 
1561			 
1561			;	inc c     ; TODO BUG need to fix memory leak on push str 
1561			;	inc c 
1561			;	inc c 
1561			;	inc c 
1561			;	inc c 
1561			;	inc c 
1561			;	inc c 
1561			 
1561			 
1561			 
1561				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1561			 
1561				ld a, (free_list+3) 
1561				cp 0 
1561				jr z, .contheap 
1561			 
1561				ld hl, (free_list)     ; get last alloc 
1561					if DEBUG_FORTH_MALLOC_INT 
1561						DMARK "mrs" 
1561						CALLMONITOR 
1561					endif 
1561				jr .startalloc 
1561			 
1561			.contheap: 
1561				ld hl, heap_start 
1561			 
1561			.startalloc: 
1561			 
1561					if DEBUG_FORTH_MALLOC_INT 
1561						DMARK "mym" 
1561						CALLMONITOR 
1561					endif 
1561			.findblock: 
1561					if DEBUG_FORTH_MALLOC_INT 
1561						DMARK "mmf" 
1561						CALLMONITOR 
1561					endif 
1561			 
1561				ld a,(hl)  
1561				; if byte is zero then clear to use 
1561			 
1561				cp 0 
1561				jr z, .foundemptyblock 
1561			 
1561				; if byte is not clear 
1561				;     then byte is offset to next block 
1561			 
1561				inc hl 
1561				ld a, (hl) ; get size 
1561			.nextblock:	inc hl 
1561					ld e, (hl) 
1561					inc hl 
1561					ld d, (hl) 
1561					ex de, hl 
1561			;	inc hl  ; move past the store space 
1561			;	inc hl  ; move past zero index  
1561			 
1561				; TODO detect no more space 
1561			 
1561				push hl 
1561				ld de, heap_end 
1561				call cmp16 
1561				pop hl 
1561				jr nc, .nospace 
1561			 
1561				jr .findblock 
1561			 
1561			.nospace: ld hl, 0 
1561				jp .exit 
1561			 
1561			 
1561			.foundemptyblock:	 
1561					if DEBUG_FORTH_MALLOC_INT 
1561						DMARK "mme" 
1561						CALLMONITOR 
1561					endif 
1561			 
1561			; TODO has block enough space if reusing??? 
1561			 
1561				;  
1561			 
1561			; see if this block has been previously used 
1561				inc hl 
1561				ld a, (hl) 
1561				dec hl 
1561				cp 0 
1561				jr z, .newblock 
1561			 
1561					if DEBUG_FORTH_MALLOC_INT 
1561						DMARK "meR" 
1561						CALLMONITOR 
1561					endif 
1561			 
1561			; no reusing previously allocated block 
1561			 
1561			; is it smaller than previously used? 
1561				 
1561				inc hl    ; move to size 
1561				ld a, c 
1561				sub (hl)        ; we want c < (hl) 
1561				dec hl    ; move back to marker 
1561			        jr z, .findblock 
1561			 
1561				; update with the new size which should be lower 
1561			 
1561			        ;inc  hl   ; negate next move. move back to size  
1561			 
1561			.newblock: 
1561				; need to be at marker here 
1561			 
1561					if DEBUG_FORTH_MALLOC_INT 
1561						DMARK "meN" 
1561						CALLMONITOR 
1561					endif 
1561			 
1561			 
1561				ld a, c 
1561			 
1561				ld (free_list+3), a	 ; flag resume from last malloc  
1561				ld (free_list), hl    ; save out last location 
1561			 
1561			 
1561				;inc a     ; space for length byte 
1561				ld (hl), a     ; save block in use marker 
1561			 
1561				inc hl   ; move to space marker 
1561				ld (hl), a    ; save new space 
1561			 
1561				inc hl   ; move to start of allocated area 
1561				 
1561			;	push hl     ; save where we are - 1  
1561			 
1561			;	inc hl  ; move past zero index  
1561				; skip space to set down new marker 
1561			 
1561				; provide some extra space for now 
1561			 
1561				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1561				inc a 
1561				inc a 
1561			 
1561				push hl   ; save where we are in the node block 
1561			 
1561				call addatohl 
1561			 
1561				; write linked list point 
1561			 
1561				pop de     ; get our node position 
1561				ex de, hl 
1561			 
1561				ld (hl), e 
1561				inc hl 
1561				ld (hl), d 
1561			 
1561				inc hl 
1561			 
1561				; now at start of allocated data so save pointer 
1561			 
1561				push hl 
1561			 
1561				; jump to position of next node and setup empty header in DE 
1561			 
1561				ex de, hl 
1561			 
1561			;	inc hl ; move past end of block 
1561			 
1561				ld a, 0 
1561				ld (hl), a   ; empty marker 
1561				inc hl 
1561				ld (hl), a   ; size 
1561				inc hl  
1561				ld (hl), a   ; ptr 
1561				inc hl 
1561				ld (hl), a   ; ptr 
1561			 
1561			 
1561				pop hl 
1561			 
1561					if DEBUG_FORTH_MALLOC_INT 
1561						DMARK "mmr" 
1561						CALLMONITOR 
1561					endif 
1561			 
1561			.exit: 
1561				pop af 
1561				pop bc 
1561				pop de  
1561				ret 
1561			 
1561			 
1561			 
1561			 
1561			free:  
1561				push hl 
1561				push af 
1561				; get address in hl 
1561			 
1561					if DEBUG_FORTH_MALLOC_INT 
1561						DMARK "fre" 
1561						CALLMONITOR 
1561					endif 
1561				; data is at hl - move to block count 
1561				dec hl 
1561				dec hl    ; get past pointer 
1561				dec hl 
1561			 
1561				ld a, (hl)    ; need this for a validation check 
1561			 
1561				dec hl    ; move to block marker 
1561			 
1561				; now check that the block count and block marker are the same  
1561			        ; this checks that we are on a malloc node and not random memory 
1561			        ; OK a faint chance this could be a problem but rare - famous last words! 
1561			 
1561				ld c, a 
1561				ld a, (hl)    
1561			 
1561				cp c 
1561				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1561			 
1561				; yes good chance we are on a malloc node 
1561			 
1561				ld a, 0      
1561				ld (hl), a   ; mark as free 
1561			 
1561				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1561			 
1561			.freeignore:  
1561			 
1561				pop af 
1561				pop hl 
1561			 
1561				ret 
1561			 
1561			 
1561			 
1561			endif 
1561			 
1561			; eof 
# End of file firmware_memory.asm
1561			  
1561			; device C  
1561			if SOUND_ENABLE  
1561				include "firmware_sound.asm"  
1561			endif  
1561			  
1561			include "firmware_diags.asm"  
1561			; Hardware diags menu 
1561			 
1561			 
1561			config: 
1561			 
1561 3e 00			ld a, 0 
1563 21 91 15			ld hl, .configmn 
1566 cd fe 0c			call menu 
1569			 
1569 fe 00			cp 0 
156b c8				ret z 
156c			 
156c fe 01			cp 1 
156e cc 6a 16			call z, .savetostore 
1571			 
1571 fe 02			cp 2 
1573 cc b8 15			call z, .selautoload 
1576 fe 03			cp 3 
1578 cc a1 15			call z, .disautoload 
157b fe 04			cp 4 
157d cc 68 16			call z, .selbank 
1580 fe 05			cp 5 
1582 cc 45 17			call z, .debug_tog 
1585 fe 06			cp 6 
1587 cc 88 18			call z, .bpsgo 
158a fe 07			cp 7 
158c cc 6b 17			call z, hardware_diags 
158f			 
158f 18 d0			jr config 
1591			 
1591			.configmn: 
1591 79 1a			dw prom_c3 
1593 90 1a			dw prom_c2 
1595 a5 1a			dw prom_c2a 
1597 bb 1a			dw prom_c2b 
1599			;	dw prom_c4 
1599 d8 1a			dw prom_m4 
159b f3 1a			dw prom_m4b 
159d fb 1a			dw prom_c1 
159f 00 00			dw 0 
15a1				 
15a1			 
15a1			 
15a1			 
15a1			.disautoload: 
15a1				if STORAGE_SE 
15a1 3e fe			ld a, $fe      ; bit 0 clear 
15a3 32 ee fb			ld (spi_device), a 
15a6			 
15a6 cd 82 04			call storage_get_block_0 
15a9			 
15a9 3e 00			ld a, 0 
15ab 32 28 fc			ld (store_page+STORE_0_AUTOFILE), a 
15ae			 
15ae 21 00 00				ld hl, 0 
15b1 11 07 fc				ld de, store_page 
15b4 cd 36 04			call storage_write_block	 ; save update 
15b7				else 
15b7			 
15b7				ld hl, prom_notav 
15b7				ld de, prom_empty 
15b7				call info_panel 
15b7				endif 
15b7			 
15b7			 
15b7 c9				ret 
15b8			 
15b8			 
15b8			 
15b8			; Select auto start 
15b8			 
15b8			.selautoload: 
15b8			 
15b8				 
15b8				if STORAGE_SE 
15b8			 
15b8 cd 8f 16				call config_dir 
15bb 21 83 f3			        ld hl, scratch 
15be 3e 00				ld a, 0 
15c0 cd fe 0c				call menu 
15c3			 
15c3 fe 00				cp 0 
15c5 c8					ret z 
15c6			 
15c6 3d					dec a 
15c7			 
15c7			 
15c7					; locate menu option 
15c7			 
15c7 21 83 f3				ld hl, scratch 
15ca cd 22 0c				call table_lookup 
15cd			 
15cd					if DEBUG_FORTH_WORDS 
15cd						DMARK "ALl" 
15cd f5				push af  
15ce 3a e2 15			ld a, (.dmark)  
15d1 32 b4 fe			ld (debug_mark),a  
15d4 3a e3 15			ld a, (.dmark+1)  
15d7 32 b5 fe			ld (debug_mark+1),a  
15da 3a e4 15			ld a, (.dmark+2)  
15dd 32 b6 fe			ld (debug_mark+2),a  
15e0 18 03			jr .pastdmark  
15e2 ..			.dmark: db "ALl"  
15e5 f1			.pastdmark: pop af  
15e6			endm  
# End of macro DMARK
15e6						CALLMONITOR 
15e6 cd 7e 18			call break_point_state  
15e9				endm  
# End of macro CALLMONITOR
15e9					endif 
15e9					; with the pointer to the menu it, the byte following the zero term is the file id 
15e9			 
15e9 3e 00				ld a, 0 
15eb 01 32 00				ld bc, 50   ; max of bytes to look at 
15ee ed b1				cpir  
15f0			 
15f0					if DEBUG_FORTH_WORDS 
15f0						DMARK "ALb" 
15f0 f5				push af  
15f1 3a 05 16			ld a, (.dmark)  
15f4 32 b4 fe			ld (debug_mark),a  
15f7 3a 06 16			ld a, (.dmark+1)  
15fa 32 b5 fe			ld (debug_mark+1),a  
15fd 3a 07 16			ld a, (.dmark+2)  
1600 32 b6 fe			ld (debug_mark+2),a  
1603 18 03			jr .pastdmark  
1605 ..			.dmark: db "ALb"  
1608 f1			.pastdmark: pop af  
1609			endm  
# End of macro DMARK
1609						CALLMONITOR 
1609 cd 7e 18			call break_point_state  
160c				endm  
# End of macro CALLMONITOR
160c					endif 
160c					;inc hl 
160c			 
160c 7e					ld a, (hl)   ; file id 
160d					 
160d				        ; save bank and file ids 
160d			 
160d f5					push af 
160e			 
160e			; TODO need to save to block 0 on bank 1	 
160e			 
160e cd 82 04				call storage_get_block_0 
1611			 
1611					if DEBUG_FORTH_WORDS 
1611						DMARK "AL0" 
1611 f5				push af  
1612 3a 26 16			ld a, (.dmark)  
1615 32 b4 fe			ld (debug_mark),a  
1618 3a 27 16			ld a, (.dmark+1)  
161b 32 b5 fe			ld (debug_mark+1),a  
161e 3a 28 16			ld a, (.dmark+2)  
1621 32 b6 fe			ld (debug_mark+2),a  
1624 18 03			jr .pastdmark  
1626 ..			.dmark: db "AL0"  
1629 f1			.pastdmark: pop af  
162a			endm  
# End of macro DMARK
162a						CALLMONITOR 
162a cd 7e 18			call break_point_state  
162d				endm  
# End of macro CALLMONITOR
162d					endif 
162d f1					pop af 
162e			 
162e 32 2b fc				ld (store_page+STORE_0_FILERUN),a 
1631					 
1631					; save bank id 
1631			 
1631 3a ee fb				ld a,(spi_device) 
1634 32 2a fc				ld (store_page+STORE_0_BANKRUN),a 
1637			 
1637					; enable auto run of store file 
1637			 
1637 3e 01				ld a, 1 
1639 32 28 fc				ld (store_page+STORE_0_AUTOFILE),a 
163c			 
163c					; save buffer 
163c			 
163c 21 00 00				ld hl, 0 
163f 11 07 fc				ld de, store_page 
1642					if DEBUG_FORTH_WORDS 
1642						DMARK "ALw" 
1642 f5				push af  
1643 3a 57 16			ld a, (.dmark)  
1646 32 b4 fe			ld (debug_mark),a  
1649 3a 58 16			ld a, (.dmark+1)  
164c 32 b5 fe			ld (debug_mark+1),a  
164f 3a 59 16			ld a, (.dmark+2)  
1652 32 b6 fe			ld (debug_mark+2),a  
1655 18 03			jr .pastdmark  
1657 ..			.dmark: db "ALw"  
165a f1			.pastdmark: pop af  
165b			endm  
# End of macro DMARK
165b						CALLMONITOR 
165b cd 7e 18			call break_point_state  
165e				endm  
# End of macro CALLMONITOR
165e					endif 
165e cd 36 04			call storage_write_block	 ; save update 
1661			  
1661			 
1661			 
1661			 
1661 21 83 f3				ld hl, scratch 
1664 cd 7c 16				call config_fdir 
1667			 
1667				else 
1667			 
1667				ld hl, prom_notav 
1667				ld de, prom_empty 
1667				call info_panel 
1667			 
1667				endif 
1667 c9				ret 
1668			 
1668			 
1668			 
1668			; Select storage bank 
1668			 
1668			.selbank: 
1668			 
1668				if STORAGE_SE 
1668				else 
1668			 
1668				ld hl, prom_notav 
1668				ld de, prom_empty 
1668				call info_panel 
1668				endif 
1668				 
1668 c9				ret 
1669			 
1669			if STORAGE_SE 
1669			 
1669			.config_ldir:   
1669				; Load storage bank labels into menu array 
1669			 
1669				 
1669			 
1669			 
1669 c9				ret 
166a			 
166a			 
166a			endif 
166a			 
166a			 
166a			; Save user words to storage 
166a			 
166a			.savetostore: 
166a			 
166a				if STORAGE_SE 
166a			 
166a cd 8f 16				call config_dir 
166d 21 83 f3			        ld hl, scratch 
1670 3e 00				ld a, 0 
1672 cd fe 0c				call menu 
1675					 
1675 21 83 f3				ld hl, scratch 
1678 cd 7c 16				call config_fdir 
167b			 
167b				else 
167b			 
167b				ld hl, prom_notav 
167b				ld de, prom_empty 
167b				call info_panel 
167b			 
167b				endif 
167b			 
167b c9				ret 
167c			 
167c			 
167c			 
167c			if STORAGE_SE 
167c			 
167c			config_fdir: 
167c				; using the scratch dir go through and release the memory allocated for each string 
167c				 
167c 21 83 f3			ld hl, scratch 
167f 5e			.cfdir:	ld e,(hl) 
1680 23				inc hl 
1681 56				ld d,(hl) 
1682 23				inc hl 
1683			 
1683 eb				ex de, hl 
1684 cd 2a 0f			call ishlzero 
1687 c8				ret z     ; return on null pointer 
1688 cd 92 14			call free 
168b eb				ex de, hl 
168c 18 f1			jr .cfdir 
168e			 
168e			 
168e c9				ret 
168f			 
168f			 
168f			config_dir: 
168f			 
168f				; for the config menus that need to build a directory of storage call this routine 
168f				; it will construct a menu in scratch to pass to menu 
168f			 
168f				; open storage device 
168f			 
168f				; execute DIR to build a list of files and their ids into scratch in menu format 
168f				; once the menu has finished then will need to call config_fdir to release the strings 
168f				 
168f				; c = number items 
168f			 
168f				 
168f cd 82 04			call storage_get_block_0 
1692			 
1692 21 07 fc			ld hl, store_page     ; get current id count 
1695 46				ld b, (hl) 
1696 0e 00			ld c, 0    ; count of files   
1698			 
1698			 
1698 21 83 f3			ld hl, scratch 
169b 22 fe fb			ld (store_tmp2), hl    ; location to poke strings 
169e			 
169e				; check for empty drive 
169e			 
169e 3e 00			ld a, 0 
16a0 b8				cp b 
16a1 ca 3b 17			jp z, .dirdone 
16a4			 
16a4				 
16a4					if DEBUG_FORTH_WORDS 
16a4						DMARK "Cdc" 
16a4 f5				push af  
16a5 3a b9 16			ld a, (.dmark)  
16a8 32 b4 fe			ld (debug_mark),a  
16ab 3a ba 16			ld a, (.dmark+1)  
16ae 32 b5 fe			ld (debug_mark+1),a  
16b1 3a bb 16			ld a, (.dmark+2)  
16b4 32 b6 fe			ld (debug_mark+2),a  
16b7 18 03			jr .pastdmark  
16b9 ..			.dmark: db "Cdc"  
16bc f1			.pastdmark: pop af  
16bd			endm  
# End of macro DMARK
16bd						CALLMONITOR 
16bd cd 7e 18			call break_point_state  
16c0				endm  
# End of macro CALLMONITOR
16c0					endif 
16c0			 
16c0			 
16c0			.diritem:	 
16c0 c5				push bc 
16c1				; for each of the current ids do a search for them and if found push to stack 
16c1			 
16c1 21 40 00				ld hl, STORE_BLOCK_PHY 
16c4 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
16c6 58					ld e,b 
16c7			 
16c7 cd 04 07				call storage_findnextid 
16ca			 
16ca			 
16ca					; if found hl will be non zero 
16ca			 
16ca cd 2a 0f				call ishlzero 
16cd 28 69				jr z, .dirnotfound 
16cf			 
16cf					; increase count 
16cf			 
16cf c1					pop bc	 
16d0 0c					inc c 
16d1 c5					push bc 
16d2					 
16d2			 
16d2					; get file header and push the file name 
16d2			 
16d2 11 07 fc				ld de, store_page 
16d5 cd d1 03				call storage_read_block 
16d8			 
16d8					; push file id to stack 
16d8				 
16d8 3a 07 fc				ld a, (store_page) 
16db 26 00				ld h, 0 
16dd 6f					ld l, a 
16de			 
16de					;call forth_push_numhl 
16de					; TODO store id 
16de			 
16de e5					push hl 
16df			 
16df					; push extent count to stack  
16df				 
16df 21 0a fc				ld hl, store_page+3 
16e2			 
16e2					; get file name length 
16e2			 
16e2 cd 5f 13				call strlenz   
16e5			 
16e5 23					inc hl   ; cover zero term 
16e6 23					inc hl  ; stick the id at the end of the area 
16e7			 
16e7 e5					push hl 
16e8 c1					pop bc    ; move length to bc 
16e9			 
16e9 cd c8 13				call malloc 
16ec			 
16ec					; TODO save malloc area to scratch 
16ec			 
16ec eb					ex de, hl 
16ed 2a fe fb				ld hl, (store_tmp2) 
16f0 73					ld (hl), e 
16f1 23					inc hl 
16f2 72					ld (hl), d 
16f3 23					inc hl 
16f4 22 fe fb				ld (store_tmp2), hl 
16f7			 
16f7					 
16f7			 
16f7					;pop hl   ; get source 
16f7			;		ex de, hl    ; swap aronund	 
16f7			 
16f7 21 0a fc				ld hl, store_page+3 
16fa					if DEBUG_FORTH_WORDS 
16fa						DMARK "CFd" 
16fa f5				push af  
16fb 3a 0f 17			ld a, (.dmark)  
16fe 32 b4 fe			ld (debug_mark),a  
1701 3a 10 17			ld a, (.dmark+1)  
1704 32 b5 fe			ld (debug_mark+1),a  
1707 3a 11 17			ld a, (.dmark+2)  
170a 32 b6 fe			ld (debug_mark+2),a  
170d 18 03			jr .pastdmark  
170f ..			.dmark: db "CFd"  
1712 f1			.pastdmark: pop af  
1713			endm  
# End of macro DMARK
1713						CALLMONITOR 
1713 cd 7e 18			call break_point_state  
1716				endm  
# End of macro CALLMONITOR
1716					endif 
1716 ed b0				ldir 
1718			 
1718					; de is past string, move back one and store id 
1718					 
1718 1b					dec de 
1719			 
1719					; store file id 
1719			 
1719 e1					pop hl 
171a eb					ex de,hl 
171b 73					ld (hl), e 
171c			 
171c					if DEBUG_FORTH_WORDS 
171c						DMARK "Cdi" 
171c f5				push af  
171d 3a 31 17			ld a, (.dmark)  
1720 32 b4 fe			ld (debug_mark),a  
1723 3a 32 17			ld a, (.dmark+1)  
1726 32 b5 fe			ld (debug_mark+1),a  
1729 3a 33 17			ld a, (.dmark+2)  
172c 32 b6 fe			ld (debug_mark+2),a  
172f 18 03			jr .pastdmark  
1731 ..			.dmark: db "Cdi"  
1734 f1			.pastdmark: pop af  
1735			endm  
# End of macro DMARK
1735						CALLMONITOR 
1735 cd 7e 18			call break_point_state  
1738				endm  
# End of macro CALLMONITOR
1738					endif 
1738					 
1738			.dirnotfound: 
1738 c1					pop bc     
1739 10 85				djnz .diritem 
173b				 
173b			.dirdone:	 
173b			 
173b 3e 00				ld a, 0 
173d 2a fe fb				ld hl, (store_tmp2) 
1740 77					ld (hl), a 
1741 23					inc hl 
1742 77					ld (hl), a 
1743 23					inc hl 
1744					; push a count of the dir items found 
1744			 
1744			;		ld h, 0 
1744			;		ld l, c 
1744			 
1744 c9				ret 
1745			 
1745			endif 
1745			 
1745			 
1745			; Settings 
1745			; Run  
1745			 
1745			 
1745			 
1745			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1745			;;hd_menu2:   db "        2: Editor",0   
1745			;hd_menu2:   db "        2: Editor       6: Menu",0   
1745			;hd_menu3:   db "        3: Storage",0 
1745			;hd_menu4:   db "0=quit  4: Debug",0 
1745			;hd_don:     db "ON",0 
1745			;hd_doff:     db "OFF",0 
1745			; 
1745			; 
1745			; 
1745			;hardware_diags_old:       
1745			; 
1745			;.diagmenu: 
1745			;	call clear_display 
1745			;	ld a, display_row_1 
1745			;	ld de, hd_menu1 
1745			;	call str_at_display 
1745			; 
1745			;	ld a, display_row_2 
1745			;	ld de, hd_menu2 
1745			;	call str_at_display 
1745			; 
1745			;	ld a, display_row_3 
1745			;	ld de, hd_menu3 
1745			;	call str_at_display 
1745			; 
1745			;	ld a,  display_row_4 
1745			;	ld de, hd_menu4 
1745			;	call str_at_display 
1745			; 
1745			;	; display debug state 
1745			; 
1745			;	ld de, hd_don 
1745			;	ld a, (os_view_disable) 
1745			;	cp 0 
1745			;	jr z, .distog 
1745			;	ld de, hd_doff 
1745			;.distog: ld a, display_row_4+17 
1745			;	call str_at_display 
1745			; 
1745			;	call update_display 
1745			; 
1745			;	call cin_wait 
1745			; 
1745			; 
1745			; 
1745			;	cp '4' 
1745			;	jr nz, .diagn1 
1745			; 
1745			;	; debug toggle 
1745			; 
1745			;	ld a, (os_view_disable) 
1745			;	ld b, '*' 
1745			;	cp 0 
1745			;	jr z, .debtog 
1745			;	ld b, 0 
1745			;.debtog:	 
1745			;	ld a,b 
1745			;	ld (os_view_disable),a 
1745			; 
1745			;.diagn1: cp '0' 
1745			;	 ret z 
1745			; 
1745			;;	cp '1' 
1745			;;       jp z, matrix	 
1745			;;   TODO keyboard matrix test 
1745			; 
1745			;	cp '2' 
1745			;	jp z, .diagedit 
1745			; 
1745			;;	cp '6' 
1745			;;	jp z, .menutest 
1745			;;if ENABLE_BASIC 
1745			;;	cp '6' 
1745			;;	jp z, basic 
1745			;;endif 
1745			 ; 
1745			;	jp .diagmenu 
1745			; 
1745			; 
1745			;	ret 
1745			 
1745			 
1745			.debug_tog: 
1745 21 8c 17			ld hl, .menudebug 
1748				 
1748 3a 74 f3			ld a, (os_view_disable) 
174b fe 2a			cp '*' 
174d 20 04			jr nz,.tdon  
174f 3e 01			ld a, 1 
1751 18 02			jr .tog1 
1753 3e 00		.tdon: ld a, 0 
1755			 
1755			.tog1: 
1755 cd fe 0c			call menu 
1758 fe 00			cp 0 
175a c8				ret z 
175b fe 01			cp 1    ; disable debug 
175d 28 04			jr z, .dtog0 
175f 3e 2a			ld a, '*' 
1761 18 02			jr .dtogset 
1763 3e 00		.dtog0: ld a, 0 
1765 32 74 f3		.dtogset:  ld (os_view_disable), a 
1768 c3 45 17			jp .debug_tog 
176b			 
176b			 
176b			hardware_diags:       
176b			 
176b			.diagm: 
176b 21 7e 17			ld hl, .menuitems 
176e 3e 00			ld a, 0 
1770 cd fe 0c			call menu 
1773			 
1773 fe 00		         cp 0 
1775 c8				 ret z 
1776			 
1776 fe 02			cp 2 
1778 ca d7 17			jp z, .diagedit 
177b			 
177b			;	cp '6' 
177b			;	jp z, .menutest 
177b			;if ENABLE_BASIC 
177b			;	cp '6' 
177b			;	jp z, basic 
177b			;endif 
177b			  
177b c3 6b 17			jp .diagm 
177e			 
177e				 
177e 92 17		.menuitems:   	dw .m1 
1780 9d 17				dw .m2 
1782 a4 17				dw .m3 
1784 ac 17				dw .m5 
1786 b2 17				dw .m5a 
1788 bb 17				dw .m5b 
178a 00 00				dw 0 
178c			 
178c			.menudebug: 
178c c4 17				dw .m6 
178e cd 17				dw .m7 
1790 00 00				dw 0 
1792			 
1792 .. 00		.m1:   db "Key Matrix",0 
179d .. 00		.m2:   db "Editor",0 
17a4 .. 00		.m3:   db "Storage",0 
17ac .. 00		.m5:   db "Sound",0 
17b2 .. 00		.m5a:  db "RAM Test",0 
17bb .. 00		.m5b:  db "LCD Test",0 
17c4			 
17c4 .. 00		.m6:   db "Debug ON",0 
17cd .. 00		.m7:   db "Debug OFF",0 
17d7			 
17d7			; debug editor 
17d7			 
17d7			.diagedit: 
17d7			 
17d7 21 83 f3			ld hl, scratch 
17da			;	ld bc, 250 
17da			;	ldir 
17da				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
17da 3e 00			ld a, 0 
17dc 77				ld (hl), a 
17dd 23				inc hl 
17de 77				ld (hl), a 
17df 23				inc hl 
17e0 77				ld (hl), a 
17e1			 
17e1 cd cd 0c		        call clear_display 
17e4 cd f0 0c			call update_display 
17e7				;ld a, 1 
17e7				;ld (hardware_diag), a 
17e7			.diloop: 
17e7 3e 00			ld a, display_row_1 
17e9 0e 00			ld c, 0 
17eb 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
17ed 1e 28			ld e, 40 
17ef			 
17ef 21 83 f3			ld hl, scratch	 
17f2 cd 2e 0f			call input_str 
17f5			 
17f5 3e 14			ld a, display_row_2 
17f7 11 83 f3			ld de, scratch 
17fa cd e0 0c			call str_at_display 
17fd cd f0 0c			call update_display 
1800			 
1800 c3 e7 17			jp .diloop 
1803			 
1803			 
1803			; pass word in hl 
1803			; a has display location 
1803			display_word_at: 
1803 f5				push af 
1804 e5				push hl 
1805 7c				ld a,h 
1806 21 88 f6			ld hl, os_word_scratch 
1809 cd 02 12			call hexout 
180c e1				pop hl 
180d 7d				ld a,l 
180e 21 8a f6			ld hl, os_word_scratch+2 
1811 cd 02 12			call hexout 
1814 21 8c f6			ld hl, os_word_scratch+4 
1817 3e 00			ld a,0 
1819 77				ld (hl),a 
181a 11 88 f6			ld de,os_word_scratch 
181d f1				pop af 
181e cd e0 0c				call str_at_display 
1821 c9				ret 
1822			 
1822			display_ptr_state: 
1822			 
1822				; to restore afterwards 
1822			 
1822 d5				push de 
1823 c5				push bc 
1824 e5				push hl 
1825 f5				push af 
1826			 
1826				; for use in here 
1826			 
1826			;	push bc 
1826			;	push de 
1826			;	push hl 
1826			;	push af 
1826			 
1826 cd cd 0c			call clear_display 
1829			 
1829 11 fc 19			ld de, .ptrstate 
182c 3e 00			ld a, display_row_1 
182e cd e0 0c			call str_at_display 
1831			 
1831				; display debug step 
1831			 
1831			 
1831 11 b4 fe			ld de, debug_mark 
1834 3e 12			ld a, display_row_1+display_cols-2 
1836 cd e0 0c			call str_at_display 
1839			 
1839				; display a 
1839 11 06 1a			ld de, .ptrcliptr 
183c 3e 14			ld a, display_row_2 
183e cd e0 0c			call str_at_display 
1841			 
1841 f1				pop af 
1842 2a ce fb			ld hl,(cli_ptr) 
1845 3e 1c			ld a, display_row_2+8 
1847 cd 03 18			call display_word_at 
184a			 
184a			 
184a				; display hl 
184a			 
184a			 
184a 11 0e 1a			ld de, .ptrclioptr 
184d 3e 1e			ld a, display_row_2+10 
184f cd e0 0c			call str_at_display 
1852			; 
1852			;	pop hl 
1852 3e 21			ld a, display_row_2+13 
1854 2a cc fb			ld hl,(cli_origptr) 
1857 cd 03 18			call display_word_at 
185a			; 
185a			;	 
185a			;	; display de 
185a			 
185a			;	ld de, .regstatede 
185a			;	ld a, display_row_3 
185a			;	call str_at_display 
185a			 
185a			;	pop de 
185a			;	ld h,d 
185a			;	ld l, e 
185a			;	ld a, display_row_3+3 
185a			;	call display_word_at 
185a			 
185a			 
185a				; display bc 
185a			 
185a			;	ld de, .regstatebc 
185a			;	ld a, display_row_3+10 
185a			;	call str_at_display 
185a			 
185a			;	pop bc 
185a			;	ld h,b 
185a			;	ld l, c 
185a			;	ld a, display_row_3+13 
185a			;	call display_word_at 
185a			 
185a			 
185a				; display dsp 
185a			 
185a			;	ld de, .regstatedsp 
185a			;	ld a, display_row_4 
185a			;	call str_at_display 
185a			 
185a				 
185a			;	ld hl,(cli_data_sp) 
185a			;	ld a, display_row_4+4 
185a			;	call display_word_at 
185a			 
185a				; display rsp 
185a			 
185a 11 3d 1a			ld de, .regstatersp 
185d 3e 46			ld a, display_row_4+10 
185f cd e0 0c			call str_at_display 
1862			 
1862				 
1862 2a b4 fb			ld hl,(cli_ret_sp) 
1865 3e 4a			ld a, display_row_4+14 
1867 cd 03 18			call display_word_at 
186a			 
186a cd f0 0c			call update_display 
186d			 
186d cd 4a 0c			call delay1s 
1870 cd 4a 0c			call delay1s 
1873 cd 4a 0c			call delay1s 
1876			 
1876			 
1876 cd 6a 1e			call next_page_prompt 
1879			 
1879				; restore  
1879			 
1879 f1				pop af 
187a e1				pop hl 
187b c1				pop bc 
187c d1				pop de 
187d c9				ret 
187e			 
187e			break_point_state: 
187e f5				push af 
187f			 
187f				; see if disabled 
187f			 
187f 3a 74 f3			ld a, (os_view_disable) 
1882 fe 2a			cp '*' 
1884 20 02			jr nz, .bpsgo 
1886 f1				pop af 
1887 c9				ret 
1888			 
1888			.bpsgo: 
1888 f1				pop af 
1889 f5				push af 
188a 22 70 f3			ld (os_view_hl), hl 
188d ed 53 6e f3		ld (os_view_de), de 
1891 ed 43 6c f3		ld (os_view_bc), bc 
1895 e5				push hl 
1896 6f				ld l, a 
1897 26 00			ld h, 0 
1899 22 72 f3			ld (os_view_af),hl 
189c			 
189c 21 4a fe				ld hl, display_fb0 
189f 22 55 fd				ld (display_fb_active), hl 
18a2 e1				pop hl	 
18a3			 
18a3 3e 31			ld a, '1' 
18a5 fe 2a		.bps1:  cp '*' 
18a7 20 03			jr nz, .bps1b 
18a9 32 74 f3			ld (os_view_disable),a 
18ac fe 31		.bps1b:  cp '1' 
18ae 20 14			jr nz, .bps2 
18b0			 
18b0				; display reg 
18b0			 
18b0				 
18b0			 
18b0 3a 72 f3			ld a, (os_view_af) 
18b3 2a 70 f3			ld hl, (os_view_hl) 
18b6 ed 5b 6e f3		ld de, (os_view_de) 
18ba ed 4b 6c f3		ld bc, (os_view_bc) 
18be cd 58 19			call display_reg_state 
18c1 c3 44 19			jp .bpschk 
18c4			 
18c4 fe 32		.bps2:  cp '2' 
18c6 20 08			jr nz, .bps3 
18c8				 
18c8				; display hl 
18c8 2a 70 f3			ld hl, (os_view_hl) 
18cb cd 42 1a			call display_dump_at_hl 
18ce			 
18ce 18 74			jr .bpschk 
18d0			 
18d0 fe 33		.bps3:  cp '3' 
18d2 20 08			jr nz, .bps4 
18d4			 
18d4			        ; display de 
18d4 2a 6e f3			ld hl, (os_view_de) 
18d7 cd 42 1a			call display_dump_at_hl 
18da			 
18da 18 68			jr .bpschk 
18dc fe 34		.bps4:  cp '4' 
18de 20 08			jr nz, .bps5 
18e0			 
18e0			        ; display bc 
18e0 2a 6c f3			ld hl, (os_view_bc) 
18e3 cd 42 1a			call display_dump_at_hl 
18e6			 
18e6 18 5c			jr .bpschk 
18e8 fe 35		.bps5:  cp '5' 
18ea 20 08		        jr nz, .bps7 
18ec			 
18ec				; display cur ptr 
18ec 2a ce fb			ld hl, (cli_ptr) 
18ef cd 42 1a			call display_dump_at_hl 
18f2			 
18f2 18 50			jr .bpschk 
18f4 fe 36		.bps7:  cp '6' 
18f6 20 08			jr nz, .bps8b 
18f8				 
18f8				; display cur orig ptr 
18f8 2a cc fb			ld hl, (cli_origptr) 
18fb cd 42 1a			call display_dump_at_hl 
18fe 18 44			jr .bpschk 
1900 fe 37		.bps8b:  cp '7' 
1902 20 08			jr nz, .bps9 
1904				 
1904				; display dsp 
1904 2a b0 fb			ld hl, (cli_data_sp) 
1907 cd 42 1a			call display_dump_at_hl 
190a			 
190a 18 38			jr .bpschk 
190c fe 39		.bps9:  cp '9' 
190e 20 05			jr nz, .bps8c 
1910				 
1910				; display SP 
1910			;	ld hl, sp 
1910 cd 42 1a			call display_dump_at_hl 
1913			 
1913 18 2f			jr .bpschk 
1915 fe 38		.bps8c:  cp '8' 
1917 20 08			jr nz, .bps8d 
1919				 
1919				; display rsp 
1919 2a b4 fb			ld hl, (cli_ret_sp) 
191c cd 42 1a			call display_dump_at_hl 
191f			 
191f 18 23			jr .bpschk 
1921 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1923 20 05			jr nz, .bps8 
1925 cd 60 1c			call monitor 
1928			 
1928 18 1a			jr .bpschk 
192a fe 30		.bps8:  cp '0' 
192c 20 16			jr nz, .bpschk 
192e			 
192e 21 f9 fd				ld hl, display_fb1 
1931 22 55 fd				ld (display_fb_active), hl 
1934 cd f0 0c				call update_display 
1937			 
1937				;ld a, (os_view_af) 
1937 2a 70 f3			ld hl, (os_view_hl) 
193a ed 5b 6e f3		ld de, (os_view_de) 
193e ed 4b 6c f3		ld bc, (os_view_bc) 
1942 f1				pop af 
1943 c9				ret 
1944			 
1944			.bpschk:   
1944 cd 4a 0c			call delay1s 
1947 3e 4f		ld a,display_row_4 + display_cols - 1 
1949 11 68 1e		        ld de, endprg 
194c cd e0 0c			call str_at_display 
194f cd f0 0c			call update_display 
1952 cd 48 6b			call cin_wait 
1955			 
1955 c3 a5 18			jp .bps1 
1958			 
1958			 
1958			display_reg_state: 
1958			 
1958				; to restore afterwards 
1958			 
1958 d5				push de 
1959 c5				push bc 
195a e5				push hl 
195b f5				push af 
195c			 
195c				; for use in here 
195c			 
195c c5				push bc 
195d d5				push de 
195e e5				push hl 
195f f5				push af 
1960			 
1960 cd cd 0c			call clear_display 
1963			 
1963 11 18 1a			ld de, .regstate 
1966 3e 00			ld a, display_row_1 
1968 cd e0 0c			call str_at_display 
196b			 
196b				; display debug step 
196b			 
196b			 
196b 11 b4 fe			ld de, debug_mark 
196e 3e 11			ld a, display_row_1+display_cols-3 
1970 cd e0 0c			call str_at_display 
1973			 
1973				; display a 
1973 11 34 1a			ld de, .regstatea 
1976 3e 14			ld a, display_row_2 
1978 cd e0 0c			call str_at_display 
197b			 
197b e1				pop hl 
197c			;	ld h,0 
197c			;	ld l, a 
197c 3e 17			ld a, display_row_2+3 
197e cd 03 18			call display_word_at 
1981			 
1981			 
1981				; display hl 
1981			 
1981			 
1981 11 28 1a			ld de, .regstatehl 
1984 3e 1e			ld a, display_row_2+10 
1986 cd e0 0c			call str_at_display 
1989			 
1989 e1				pop hl 
198a 3e 21			ld a, display_row_2+13 
198c cd 03 18			call display_word_at 
198f			 
198f				 
198f				; display de 
198f			 
198f 11 2c 1a			ld de, .regstatede 
1992 3e 28			ld a, display_row_3 
1994 cd e0 0c			call str_at_display 
1997			 
1997 e1				pop hl 
1998			;	ld h,d 
1998			;	ld l, e 
1998 3e 2b			ld a, display_row_3+3 
199a cd 03 18			call display_word_at 
199d			 
199d			 
199d				; display bc 
199d			 
199d 11 30 1a			ld de, .regstatebc 
19a0 3e 32			ld a, display_row_3+10 
19a2 cd e0 0c			call str_at_display 
19a5			 
19a5 e1				pop hl 
19a6			;	ld h,b 
19a6			;	ld l, c 
19a6 3e 35			ld a, display_row_3+13 
19a8 cd 03 18			call display_word_at 
19ab			 
19ab			 
19ab				; display dsp 
19ab			 
19ab 11 38 1a			ld de, .regstatedsp 
19ae 3e 3c			ld a, display_row_4 
19b0 cd e0 0c			call str_at_display 
19b3			 
19b3				 
19b3 2a b0 fb			ld hl,(cli_data_sp) 
19b6 3e 40			ld a, display_row_4+4 
19b8 cd 03 18			call display_word_at 
19bb			 
19bb				; display rsp 
19bb			 
19bb 11 3d 1a			ld de, .regstatersp 
19be 3e 46			ld a, display_row_4+10 
19c0 cd e0 0c			call str_at_display 
19c3			 
19c3				 
19c3 2a b4 fb			ld hl,(cli_ret_sp) 
19c6 3e 4a			ld a, display_row_4+14 
19c8 cd 03 18			call display_word_at 
19cb			 
19cb cd f0 0c			call update_display 
19ce			 
19ce			;	call delay1s 
19ce			;	call delay1s 
19ce			;	call delay1s 
19ce			 
19ce			 
19ce			;	call next_page_prompt 
19ce			 
19ce				; restore  
19ce			 
19ce f1				pop af 
19cf e1				pop hl 
19d0 c1				pop bc 
19d1 d1				pop de 
19d2 c9				ret 
19d3			 
19d3 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
19e7 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
19fc .. 00		.ptrstate:	db "Ptr State",0 
1a06 .. 00		.ptrcliptr:     db "cli_ptr",0 
1a0e .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a18 .. 00		.regstate:	db "Reg State (1/0)",0 
1a28 .. 00		.regstatehl:	db "HL:",0 
1a2c .. 00		.regstatede:	db "DE:",0 
1a30 .. 00		.regstatebc:	db "BC:",0 
1a34 .. 00		.regstatea:	db "A :",0 
1a38 .. 00		.regstatedsp:	db "DSP:",0 
1a3d .. 00		.regstatersp:	db "RSP:",0 
1a42			 
1a42			display_dump_at_hl: 
1a42 e5				push hl 
1a43 d5				push de 
1a44 c5				push bc 
1a45 f5				push af 
1a46			 
1a46 22 a6 f6			ld (os_cur_ptr),hl	 
1a49 cd cd 0c			call clear_display 
1a4c cd 72 1d			call dumpcont 
1a4f			;	call delay1s 
1a4f			;	call next_page_prompt 
1a4f			 
1a4f			 
1a4f f1				pop af 
1a50 c1				pop bc 
1a51 d1				pop de 
1a52 e1				pop hl 
1a53 c9				ret 
1a54			 
1a54			;if ENABLE_BASIC 
1a54			;	include "nascombasic.asm" 
1a54			;	basic: 
1a54			;	include "forth/FORTH.ASM" 
1a54			;endif 
1a54			 
1a54			; eof 
1a54			 
1a54			 
# End of file firmware_diags.asm
1a54			  
1a54			include "firmware_prompts.asm"  
1a54			; Prompts  
1a54			 
1a54			; boot messages 
1a54			 
1a54 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1a69 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1a79			 
1a79			 
1a79			; config menus 
1a79			 
1a79 .. 00		prom_c3: db "Add Dictionary To File",0 
1a90 .. 00		prom_c2: db "Select Autoload File",0 
1aa5 .. 00		prom_c2a: db "Disable Autoload File", 0 
1abb .. 00		prom_c2b: db "Select Storage Bank",0 
1acf .. 00		prom_c4: db "Settings",0 
1ad8 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1af3 .. 00		prom_m4b:   db "Monitor",0 
1afb .. 00		prom_c1: db "Hardware Diags",0 
1b0a			 
1b0a			 
1b0a .. 00		prom_notav:    db "Feature not available",0 
1b20 .. 00		prom_empty:    db "",0 
1b21			 
1b21			; eof 
1b21			 
# End of file firmware_prompts.asm
1b21			  
1b21			  
1b21			; eof  
1b21			  
# End of file firmware.asm
1b21			 
1b21			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b21			;if BASE_KEV  
1b21			;baseram: equ 08000h 
1b21			;endif 
1b21			 
1b21			;if BASE_SC114 
1b21			;baseram:     equ    endofcode 
1b21			;endif 
1b21			 
1b21			 
1b21			; start system 
1b21			 
1b21			coldstart: 
1b21				; set sp 
1b21				; di/ei 
1b21			 
1b21 f3				di 
1b22 31 fd ff			ld sp, tos 
1b25			;	ei 
1b25			 
1b25			 
1b25				; disable breakpoint by default 
1b25			 
1b25 3e 2a			ld a,'*' 
1b27 32 74 f3			ld (os_view_disable),a 
1b2a			 
1b2a				; init hardware 
1b2a			 
1b2a				; init keyboard and screen hardware 
1b2a			 
1b2a cd 1c 00			call hardware_init 
1b2d			 
1b2d			 
1b2d cd 4a 0c			call delay1s 
1b30 3e 30			ld a, display_row_3+8 
1b32 11 03 00			ld de, buildtime 
1b35 cd e0 0c			call str_at_display 
1b38 cd f0 0c			call update_display 
1b3b			 
1b3b cd 4a 0c			call delay1s 
1b3e cd 4a 0c			call delay1s 
1b41 cd 4a 0c			call delay1s 
1b44			 
1b44				; detect if any keys are held down to enable breakpoints at start up 
1b44			 
1b44 cd 59 6b			call cin  
1b47 fe 00			cp 0 
1b49 28 03			jr z, .nokeys 
1b4b			 
1b4b				;call hardware_diags 
1b4b cd 61 15			call config 
1b4e			 
1b4e			;	ld de, .bpen 
1b4e			;	ld a, display_row_4 
1b4e			;	call str_at_display 
1b4e			;	call update_display 
1b4e			; 
1b4e			;	ld a,0 
1b4e			;	ld (os_view_disable),a 
1b4e			; 
1b4e			;.bpwait: 
1b4e			;	call cin 
1b4e			;	cp 0 
1b4e			;	jr z, .bpwait 
1b4e			;	jr .nokeys 
1b4e			; 
1b4e			; 
1b4e			;.bpen:  db "Break points enabled!",0 
1b4e			 
1b4e			 
1b4e			 
1b4e			 
1b4e			 
1b4e			 
1b4e			.nokeys: 
1b4e			 
1b4e			 
1b4e				 
1b4e			 
1b4e			;jp  testkey 
1b4e			 
1b4e			;call storage_get_block_0 
1b4e			; 
1b4e			;ld hl, 0 
1b4e			;ld de, store_page 
1b4e			;call storage_read_block 
1b4e			 
1b4e				 
1b4e			;ld hl, 10 
1b4e			;ld de, store_page 
1b4e			;call storage_read_block 
1b4e			 
1b4e			 
1b4e			 
1b4e			 
1b4e			 
1b4e			;stop:	nop 
1b4e			;	jp stop 
1b4e			 
1b4e			 
1b4e			 
1b4e			main: 
1b4e cd cd 0c			call clear_display 
1b51 cd f0 0c			call update_display 
1b54			 
1b54			 
1b54			 
1b54			;	call testlcd 
1b54			 
1b54			 
1b54			 
1b54 cd 30 22			call forth_init 
1b57			 
1b57			 
1b57			warmstart: 
1b57 cd 06 22			call forth_warmstart 
1b5a			 
1b5a				; run startup word load 
1b5a			        ; TODO prevent this running at warmstart after crash  
1b5a			 
1b5a				if STARTUP_ENABLE 
1b5a					if STORAGE_SE 
1b5a cd 8a 68					call forth_autoload 
1b5d					endif 
1b5d cd 99 65				call forth_startup 
1b60			 
1b60			 
1b60				endif 
1b60			 
1b60				; show free memory after boot 
1b60 11 fa 1b			ld de, freeram 
1b63 3e 00			ld a, display_row_1 
1b65 cd e0 0c			call str_at_display 
1b68			 
1b68			; Or use heap_size word???? 
1b68 21 69 f3			ld hl, heap_end 
1b6b 11 0e 80			ld de, heap_start 
1b6e ed 52			sbc hl, de 
1b70 e5				push hl 
1b71 7c				ld a,h	         	 
1b72 21 88 f6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b75 cd 02 12			call hexout 
1b78 e1			   	pop hl 
1b79			 
1b79 7d				ld a,l 
1b7a 21 8a f6			ld hl, os_word_scratch+2 
1b7d cd 02 12			call hexout 
1b80 21 8c f6			ld hl, os_word_scratch+4 
1b83 3e 00			ld a, 0 
1b85 77				ld (hl),a 
1b86 11 88 f6			ld de, os_word_scratch 
1b89 3e 0d			ld a, display_row_1 + 13 
1b8b cd e0 0c			call str_at_display 
1b8e cd f0 0c			call update_display 
1b91			 
1b91			 
1b91				;call demo 
1b91			 
1b91			 
1b91				; init scratch input area for cli commands 
1b91			 
1b91 21 aa f6			ld hl, os_cli_cmd 
1b94 3e 00			ld a,0 
1b96 77				ld (hl),a 
1b97 23				inc hl 
1b98 77				ld (hl),a 
1b99			 
1b99 3e 00			ld a,0 
1b9b 32 a9 f7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1b9e			 
1b9e 32 a6 f6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1ba1 32 a7 f6			ld (os_cur_ptr+1),a	 
1ba4			 
1ba4 32 88 f6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1ba7 32 89 f6			ld (os_word_scratch+1),a	 
1baa				 
1baa			 
1baa				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1baa 21 aa f6			ld hl, os_cli_cmd 
1bad			 
1bad 3e 00			ld a, 0		 ; init cli input 
1baf 77				ld (hl), a 
1bb0 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bb2			cli: 
1bb2				; show cli prompt 
1bb2				;push af 
1bb2				;ld a, 0 
1bb2				;ld de, prompt 
1bb2				;call str_at_display 
1bb2			 
1bb2				;call update_display 
1bb2				;pop af 
1bb2				;inc a 
1bb2				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bb2 0e 00			ld c, 0 
1bb4 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1bb6 1e 28			ld e, 40 
1bb8			 
1bb8 21 aa f6			ld hl, os_cli_cmd 
1bbb			 
1bbb				STACKFRAME OFF $fefe $9f9f 
1bbb				if DEBUG_STACK_IMB 
1bbb					if OFF 
1bbb						exx 
1bbb						ld de, $fefe 
1bbb						ld a, d 
1bbb						ld hl, curframe 
1bbb						call hexout 
1bbb						ld a, e 
1bbb						ld hl, curframe+2 
1bbb						call hexout 
1bbb						ld hl, $fefe 
1bbb						push hl 
1bbb						ld hl, $9f9f 
1bbb						push hl 
1bbb						exx 
1bbb					endif 
1bbb				endif 
1bbb			endm 
# End of macro STACKFRAME
1bbb			 
1bbb cd 2e 0f			call input_str 
1bbe			 
1bbe				STACKFRAMECHK OFF $fefe $9f9f 
1bbe				if DEBUG_STACK_IMB 
1bbe					if OFF 
1bbe						exx 
1bbe						ld hl, $9f9f 
1bbe						pop de   ; $9f9f 
1bbe						call cmp16 
1bbe						jr nz, .spnosame 
1bbe						ld hl, $fefe 
1bbe						pop de   ; $fefe 
1bbe						call cmp16 
1bbe						jr z, .spfrsame 
1bbe						.spnosame: call showsperror 
1bbe						.spfrsame: nop 
1bbe						exx 
1bbe					endif 
1bbe				endif 
1bbe			endm 
# End of macro STACKFRAMECHK
1bbe			 
1bbe				; copy input to last command 
1bbe			 
1bbe 21 aa f6			ld hl, os_cli_cmd 
1bc1 11 a9 f7			ld de, os_last_cmd 
1bc4 01 ff 00			ld bc, 255 
1bc7 ed b0			ldir 
1bc9			 
1bc9				; wipe current buffer 
1bc9			 
1bc9			;	ld a, 0 
1bc9			;	ld hl, os_cli_cmd 
1bc9			;	ld de, os_cli_cmd+1 
1bc9			;	ld bc, 254 
1bc9			;	ldir 
1bc9				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1bc9			;	call strcpy 
1bc9			;	ld a, 0 
1bc9			;	ld (hl), a 
1bc9			;	inc hl 
1bc9			;	ld (hl), a 
1bc9			;	inc hl 
1bc9			;	ld (hl), a 
1bc9			 
1bc9				; switch frame buffer to program  
1bc9			 
1bc9 21 f9 fd				ld hl, display_fb1 
1bcc 22 55 fd				ld (display_fb_active), hl 
1bcf			 
1bcf			;	nop 
1bcf				STACKFRAME ON $fbfe $8f9f 
1bcf				if DEBUG_STACK_IMB 
1bcf					if ON 
1bcf						exx 
1bcf						ld de, $fbfe 
1bcf						ld a, d 
1bcf						ld hl, curframe 
1bcf						call hexout 
1bcf						ld a, e 
1bcf						ld hl, curframe+2 
1bcf						call hexout 
1bcf						ld hl, $fbfe 
1bcf						push hl 
1bcf						ld hl, $8f9f 
1bcf						push hl 
1bcf						exx 
1bcf					endif 
1bcf				endif 
1bcf			endm 
# End of macro STACKFRAME
1bcf				; first time into the parser so pass over the current scratch pad 
1bcf 21 aa f6			ld hl,os_cli_cmd 
1bd2				; tokenise the entered statement(s) in HL 
1bd2 cd ae 22			call forthparse 
1bd5			        ; exec forth statements in top of return stack 
1bd5 cd ee 22			call forthexec 
1bd8				;call forthexec_cleanup 
1bd8			;	call parsenext 
1bd8			 
1bd8				STACKFRAMECHK ON $fbfe $8f9f 
1bd8				if DEBUG_STACK_IMB 
1bd8					if ON 
1bd8						exx 
1bd8						ld hl, $8f9f 
1bd8						pop de   ; $8f9f 
1bd8						call cmp16 
1bd8						jr nz, .spnosame 
1bd8						ld hl, $fbfe 
1bd8						pop de   ; $fbfe 
1bd8						call cmp16 
1bd8						jr z, .spfrsame 
1bd8						.spnosame: call showsperror 
1bd8						.spfrsame: nop 
1bd8						exx 
1bd8					endif 
1bd8				endif 
1bd8			endm 
# End of macro STACKFRAMECHK
1bd8				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1bd8			 
1bd8 3e 3c			ld a, display_row_4 
1bda 11 0c 1c			ld de, endprog 
1bdd			 
1bdd cd f0 0c			call update_display		 
1be0			 
1be0 cd 6a 1e			call next_page_prompt 
1be3			 
1be3				; switch frame buffer to cli 
1be3			 
1be3 21 4a fe				ld hl, display_fb0 
1be6 22 55 fd				ld (display_fb_active), hl 
1be9			 
1be9			 
1be9 cd cd 0c		        call clear_display 
1bec cd f0 0c			call update_display		 
1bef			 
1bef 21 aa f6			ld hl, os_cli_cmd 
1bf2			 
1bf2 3e 00			ld a, 0		 ; init cli input 
1bf4 77				ld (hl), a 
1bf5			 
1bf5				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1bf5			 
1bf5				; now on last line 
1bf5			 
1bf5				; TODO scroll screen up 
1bf5			 
1bf5				; TODO instead just clear screen and place at top of screen 
1bf5			 
1bf5			;	ld a, 0 
1bf5			;	ld (f_cursor_ptr),a 
1bf5			 
1bf5				;call clear_display 
1bf5				;call update_display 
1bf5			 
1bf5				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bf5 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bf7 c3 b2 1b			jp cli 
1bfa			 
1bfa .. 00		freeram: db "Free bytes: $",0 
1c08 ..			asc: db "1A2F" 
1c0c .. 00		endprog: db "End prog...",0 
1c18			 
1c18			testenter2:   
1c18 21 b5 f3			ld hl,scratch+50 
1c1b 22 a6 f6			ld (os_cur_ptr),hl 
1c1e c3 b2 1b			jp cli 
1c21			 
1c21			testenter:  
1c21			 
1c21 21 08 1c			ld hl,asc 
1c24			;	ld a,(hl) 
1c24			;	call nibble2val 
1c24 cd 58 12			call get_byte 
1c27			 
1c27			 
1c27			;	ld a,(hl) 
1c27			;	call atohex 
1c27			 
1c27			;	call fourehexhl 
1c27 32 b5 f3			ld (scratch+50),a 
1c2a			 
1c2a			 
1c2a			 
1c2a 21 0a 1c			ld hl,asc+2 
1c2d			;	ld a, (hl) 
1c2d			;	call nibble2val 
1c2d cd 58 12			call get_byte 
1c30			 
1c30			;	call fourehexhl 
1c30 32 b7 f3			ld (scratch+52),a 
1c33				 
1c33 21 b5 f3			ld hl,scratch+50 
1c36 22 a6 f6			ld (os_cur_ptr),hl 
1c39 c3 b2 1b			jp cli 
1c3c			 
1c3c			enter:	 
1c3c 3a 87 f3			ld a,(scratch+4) 
1c3f fe 00			cp 0 
1c41 28 0c			jr z, .entercont 
1c43				; no, not a null term line so has an address to work out.... 
1c43			 
1c43 21 85 f3			ld hl,scratch+2 
1c46 cd b8 12			call get_word_hl 
1c49			 
1c49 22 a6 f6			ld (os_cur_ptr),hl	 
1c4c c3 b2 1b			jp cli 
1c4f			 
1c4f			 
1c4f			.entercont:  
1c4f			 
1c4f 21 85 f3			ld hl, scratch+2 
1c52 cd 58 12			call get_byte 
1c55			 
1c55 2a a6 f6		   	ld hl,(os_cur_ptr) 
1c58 77					ld (hl),a 
1c59 23					inc hl 
1c5a 22 a6 f6				ld (os_cur_ptr),hl 
1c5d				 
1c5d			; get byte  
1c5d			 
1c5d			 
1c5d c3 b2 1b			jp cli 
1c60			 
1c60			 
1c60			; basic monitor support 
1c60			 
1c60			monitor: 
1c60				;  
1c60 cd cd 0c			call clear_display 
1c63 3e 00			ld a, 0 
1c65 11 ad 1c			ld de, .monprompt 
1c68 cd e0 0c			call str_at_display 
1c6b cd f0 0c			call update_display 
1c6e			 
1c6e				; get a monitor command 
1c6e			 
1c6e 0e 00			ld c, 0     ; entry at top left 
1c70 16 64			ld d, 100   ; max buffer size 
1c72 1e 0f			ld e, 15    ; input scroll area 
1c74 3e 00			ld a, 0     ; init string 
1c76 21 81 f5			ld hl, os_input 
1c79 77				ld (hl), a 
1c7a 23				inc hl 
1c7b 77				ld (hl), a 
1c7c 21 81 f5			ld hl, os_input 
1c7f 3e 01			ld a, 1     ; init string 
1c81 cd 2e 0f			call input_str 
1c84			 
1c84 cd cd 0c		        call clear_display 
1c87 cd f0 0c			call update_display		 
1c8a			 
1c8a 3a 81 f5			ld a, (os_input) 
1c8d cd 56 13			call toUpper 
1c90 fe 48		        cp 'H' 
1c92 28 6f		        jr z, .monhelp 
1c94 fe 44			cp 'D'		; dump 
1c96 ca 24 1d			jp z, .mondump	 
1c99 fe 43			cp 'C'		; dump 
1c9b ca 3e 1d			jp z, .moncdump	 
1c9e fe 4d			cp 'M'		; dump 
1ca0 ca af 1c			jp z, .moneditstart 
1ca3 fe 55			cp 'U'		; dump 
1ca5 28 14			jr z, .monedit	 
1ca7 fe 51			cp 'Q'		; dump 
1ca9 c8				ret z	 
1caa			 
1caa			 
1caa				; TODO "S" to access symbol by name and not need the address 
1caa				; TODO "F" to find a string in memory 
1caa			 
1caa c3 60 1c			jp monitor 
1cad			 
1cad .. 00		.monprompt: db ">", 0 
1caf			 
1caf			.moneditstart: 
1caf				; get starting address 
1caf			 
1caf 21 83 f5			ld hl,os_input+2 
1cb2 cd b8 12			call get_word_hl 
1cb5			 
1cb5 22 a6 f6			ld (os_cur_ptr),hl	 
1cb8			 
1cb8 c3 60 1c			jp monitor 
1cbb			 
1cbb			.monedit: 
1cbb				; get byte to load 
1cbb			 
1cbb 21 83 f5			ld hl,os_input+2 
1cbe cd 58 12			call get_byte 
1cc1			 
1cc1				; get address to update 
1cc1 2a a6 f6			ld hl, (os_cur_ptr) 
1cc4			 
1cc4				; update byte 
1cc4			 
1cc4 77				ld (hl), a 
1cc5			 
1cc5				; move to next address and save it 
1cc5			 
1cc5 23				inc hl 
1cc6 22 a6 f6			ld (os_cur_ptr),hl	 
1cc9			 
1cc9 c3 60 1c			jp monitor 
1ccc			 
1ccc			 
1ccc .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ce0 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1cfc .. 00		.monhelptext3:  db "Q-Quit",0 
1d03			        
1d03			.monhelp: 
1d03 3e 00			ld a, display_row_1 
1d05 11 cc 1c		        ld de, .monhelptext1 
1d08			 
1d08 cd e0 0c			call str_at_display 
1d0b 3e 14			ld a, display_row_2 
1d0d 11 e0 1c		        ld de, .monhelptext2 
1d10					 
1d10 cd e0 0c			call str_at_display 
1d13 3e 28			ld a, display_row_3 
1d15 11 fc 1c		        ld de, .monhelptext3 
1d18					 
1d18 cd e0 0c			call str_at_display 
1d1b cd f0 0c			call update_display		 
1d1e			 
1d1e cd 6a 1e			call next_page_prompt 
1d21 c3 60 1c			jp monitor 
1d24			 
1d24			.mondump:    
1d24 21 83 f5			ld hl,os_input+2 
1d27 cd b8 12			call get_word_hl 
1d2a			 
1d2a 22 a6 f6			ld (os_cur_ptr),hl	 
1d2d cd 72 1d			call dumpcont 
1d30 3e 3c			ld a, display_row_4 
1d32 11 0c 1c			ld de, endprog 
1d35			 
1d35 cd f0 0c			call update_display		 
1d38			 
1d38 cd 6a 1e			call next_page_prompt 
1d3b c3 60 1c			jp monitor 
1d3e			.moncdump: 
1d3e cd 72 1d			call dumpcont 
1d41 3e 3c			ld a, display_row_4 
1d43 11 0c 1c			ld de, endprog 
1d46			 
1d46 cd f0 0c			call update_display		 
1d49			 
1d49 cd 6a 1e			call next_page_prompt 
1d4c c3 60 1c			jp monitor 
1d4f			 
1d4f			 
1d4f			; TODO symbol access  
1d4f			 
1d4f			.symbols:     ;; A list of symbols that can be called up  
1d4f 4a fe			dw display_fb0 
1d51 .. 00			db "fb0",0  
1d55 07 fc		     	dw store_page 
1d57 .. 00			db "store_page",0 
1d62			 
1d62			 
1d62			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1d62			 
1d62 3a 84 f3			ld a,(scratch+1) 
1d65 fe 00			cp 0 
1d67 28 09			jr z, dumpcont 
1d69			 
1d69				; no, not a null term line so has an address to work out.... 
1d69			 
1d69 21 85 f3			ld hl,scratch+2 
1d6c cd b8 12			call get_word_hl 
1d6f			 
1d6f 22 a6 f6			ld (os_cur_ptr),hl	 
1d72			 
1d72			 
1d72			 
1d72			dumpcont: 
1d72			 
1d72				; dump bytes at ptr 
1d72			 
1d72			 
1d72 3e 00			ld a, display_row_1 
1d74 2a 55 fd			ld hl, (display_fb_active) 
1d77 cd 01 0f			call addatohl 
1d7a cd a2 1d			call .dumpbyterow 
1d7d			 
1d7d 3e 14			ld a, display_row_2 
1d7f 2a 55 fd			ld hl, (display_fb_active) 
1d82 cd 01 0f			call addatohl 
1d85 cd a2 1d			call .dumpbyterow 
1d88			 
1d88			 
1d88 3e 28			ld a, display_row_3 
1d8a 2a 55 fd			ld hl, (display_fb_active) 
1d8d cd 01 0f			call addatohl 
1d90 cd a2 1d			call .dumpbyterow 
1d93			 
1d93 3e 3c			ld a, display_row_4 
1d95 2a 55 fd			ld hl, (display_fb_active) 
1d98 cd 01 0f			call addatohl 
1d9b cd a2 1d			call .dumpbyterow 
1d9e			 
1d9e cd f0 0c			call update_display 
1da1			;		jp cli 
1da1 c9				ret 
1da2			 
1da2			.dumpbyterow: 
1da2			 
1da2				;push af 
1da2			 
1da2 e5				push hl 
1da3			 
1da3				; calc where to poke the ascii 
1da3			if display_cols == 20 
1da3 3e 10			ld a, 16 
1da5			else 
1da5				ld a, 31 
1da5			endif 
1da5			 
1da5 cd 01 0f			call addatohl 
1da8 22 88 f6			ld (os_word_scratch),hl  		; save pos for later 
1dab			 
1dab			 
1dab			; display decoding address 
1dab 2a a6 f6		   	ld hl,(os_cur_ptr) 
1dae			 
1dae 7c				ld a,h 
1daf e1				pop hl 
1db0 e5				push hl 
1db1			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1db1 cd 02 12			call hexout 
1db4 2a a6 f6		   	ld hl,(os_cur_ptr) 
1db7			 
1db7 7d				ld a,l 
1db8 e1				pop hl 
1db9 23				inc hl 
1dba 23				inc hl 
1dbb e5				push hl 
1dbc			;	ld hl, os_word_scratch+2 
1dbc cd 02 12			call hexout 
1dbf e1				pop hl 
1dc0 23				inc hl 
1dc1 23				inc hl 
1dc2				;ld hl, os_word_scratch+4 
1dc2 3e 3a			ld a, ':' 
1dc4 77				ld (hl),a 
1dc5 23				inc hl 
1dc6				;ld a, 0 
1dc6				;ld (hl),a 
1dc6				;ld de, os_word_scratch 
1dc6				;pop af 
1dc6				;push af 
1dc6			;		ld a, display_row_2 
1dc6			;		call str_at_display 
1dc6			;		call update_display 
1dc6			 
1dc6			 
1dc6			;pop af 
1dc6			;	add 5 
1dc6			 
1dc6			if display_cols == 20 
1dc6 06 04			ld b, 4 
1dc8			else 
1dc8				ld b, 8 
1dc8			endif	 
1dc8			 
1dc8			.dumpbyte: 
1dc8 c5				push bc 
1dc9 e5				push hl 
1dca			 
1dca			 
1dca 2a a6 f6		   	ld hl,(os_cur_ptr) 
1dcd 7e					ld a,(hl) 
1dce			 
1dce					; poke the ascii to display 
1dce 2a 88 f6				ld hl,(os_word_scratch) 
1dd1 77					ld (hl),a 
1dd2 23					inc hl 
1dd3 22 88 f6				ld (os_word_scratch),hl 
1dd6			 
1dd6					 
1dd6			 
1dd6			 
1dd6 e1					pop hl 
1dd7 e5					push hl 
1dd8			 
1dd8 cd 02 12				call hexout 
1ddb			 
1ddb					 
1ddb 2a a6 f6		   	ld hl,(os_cur_ptr) 
1dde 23				inc hl 
1ddf 22 a6 f6		   	ld (os_cur_ptr),hl 
1de2			 
1de2 e1					pop hl 
1de3 23					inc hl 
1de4 23					inc hl 
1de5 23					inc hl 
1de6			 
1de6			 
1de6			 
1de6					;ld a,0 
1de6					;ld (os_word_scratch+2),a 
1de6					;pop af 
1de6					;push af 
1de6			 
1de6					;ld de, os_word_scratch 
1de6					;call str_at_display 
1de6			;		call update_display 
1de6			;		pop af 
1de6 c1					pop bc 
1de7 c6 03				add 3 
1de9 10 dd			djnz .dumpbyte 
1deb			 
1deb				 
1deb			 
1deb c9				ret 
1dec			 
1dec			jump:	 
1dec			 
1dec 21 85 f3			ld hl,scratch+2 
1def cd b8 12			call get_word_hl 
1df2				;ld hl,(scratch+2) 
1df2				;call fourehexhl 
1df2			 
1df2 22 a6 f6			ld (os_cur_ptr),hl	 
1df5			 
1df5 e9				jp (hl) 
1df6			 
1df6			 
1df6			 
1df6			; TODO implement a basic monitor mode to start with 
1df6			 
1df6			 
1df6			 
1df6			 
1df6			 
1df6			 
1df6			 
1df6			 
1df6			 
1df6			; testing and demo code during development 
1df6			 
1df6			 
1df6 .. 00		str1: db "Enter some text...",0 
1e09 .. 00		clear: db "                    ",0 
1e1e			 
1e1e			demo: 
1e1e			 
1e1e			 
1e1e			 
1e1e			;	call update_display 
1e1e			 
1e1e				; init scratch input area for testing 
1e1e 21 83 f3			ld hl, scratch	 
1e21 3e 00			ld a,0 
1e23 77				ld (hl),a 
1e24			 
1e24			 
1e24 3e 14		            LD   A, display_row_2 
1e26			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e26 11 f6 1d		            LD   DE, str1 
1e29 cd e0 0c			call str_at_display 
1e2c			 
1e2c			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e2c			cloop:	 
1e2c 3e 28		            LD   A, display_row_3 
1e2e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e2e 11 09 1e		            LD   DE, clear 
1e31			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1e31 cd e0 0c				call str_at_display 
1e34 3e 3c			ld a, display_row_4 
1e36 11 66 1e			ld de, prompt 
1e39			 
1e39 cd e0 0c				call str_at_display 
1e3c cd f0 0c			call update_display 
1e3f			 
1e3f 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1e41 16 0a			ld d, 10 
1e43 21 83 f3			ld hl, scratch	 
1e46 cd 2e 0f			call input_str 
1e49			 
1e49			;	call clear_display 
1e49			;'	call update_display 
1e49			 
1e49 3e 00		            LD   A, display_row_1 
1e4b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e4b 11 09 1e		            LD   DE, clear 
1e4e cd e0 0c				call str_at_display 
1e51			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e51 3e 00		            LD   A, display_row_1 
1e53			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e53 11 83 f3		            LD   DE, scratch 
1e56			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e56 cd e0 0c				call str_at_display 
1e59 cd f0 0c			call update_display 
1e5c			 
1e5c 3e 00				ld a,0 
1e5e 21 83 f3			ld hl, scratch 
1e61 77				ld (hl),a 
1e62			 
1e62 00				nop 
1e63 c3 2c 1e			jp cloop 
1e66			 
1e66			 
1e66			 
1e66			; OS Prompt 
1e66			 
1e66 .. 00		prompt: db ">",0 
1e68 .. 00		endprg: db "?",0 
1e6a			 
1e6a			 
1e6a			; handy next page prompt 
1e6a			next_page_prompt: 
1e6a e5				push hl 
1e6b d5				push de 
1e6c f5				push af 
1e6d c5				push bc 
1e6e			 
1e6e 3e 4f			ld a,display_row_4 + display_cols - 1 
1e70 11 68 1e		        ld de, endprg 
1e73 cd e0 0c			call str_at_display 
1e76 cd f0 0c			call update_display 
1e79 cd 48 6b			call cin_wait 
1e7c c1				pop bc 
1e7d f1				pop af 
1e7e d1				pop de 
1e7f e1				pop hl 
1e80			 
1e80			 
1e80 c9				ret 
1e81			 
1e81			 
1e81			; forth parser 
1e81			 
1e81			; My forth kernel 
1e81			include "forth_kernel.asm" 
1e81			; 
1e81			; kernel to the forth OS 
1e81			 
1e81			DS_TYPE_STR: equ 1     ; string type 
1e81			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1e81			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1e81			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1e81			 
1e81			FORTH_PARSEV1: equ 0 
1e81			FORTH_PARSEV2: equ 0 
1e81			FORTH_PARSEV3: equ 0 
1e81			FORTH_PARSEV4: equ 0 
1e81			FORTH_PARSEV5: equ 1 
1e81			 
1e81			;if FORTH_PARSEV5 
1e81			;	FORTH_END_BUFFER: equ 0 
1e81			;else 
1e81			FORTH_END_BUFFER: equ 127 
1e81			;endif 
1e81			 
1e81			FORTH_TRUE: equ 1 
1e81			FORTH_FALSE: equ 0 
1e81			 
1e81			if FORTH_PARSEV4 
1e81			include "forth_stackops.asm" 
1e81			endif 
1e81			 
1e81			if FORTH_PARSEV5 
1e81			include "forth_stackopsv5.asm" 
1e81			 
1e81			; Stack operations for v5 parser on wards 
1e81			; * DATA stack 
1e81			; * LOOP stack 
1e81			; * RETURN stack 
1e81			 
1e81			 
1e81			 
1e81			FORTH_CHK_DSP_UNDER: macro 
1e81				push hl 
1e81				push de 
1e81				ld hl,(cli_data_sp) 
1e81				ld de, cli_data_stack 
1e81				call cmp16 
1e81				jp c, fault_dsp_under 
1e81				pop de 
1e81				pop hl 
1e81				endm 
1e81			 
1e81			 
1e81			FORTH_CHK_RSP_UNDER: macro 
1e81				push hl 
1e81				push de 
1e81				ld hl,(cli_ret_sp) 
1e81				ld de, cli_ret_stack 
1e81				call cmp16 
1e81				jp c, fault_rsp_under 
1e81				pop de 
1e81				pop hl 
1e81				endm 
1e81			 
1e81			FORTH_CHK_LOOP_UNDER: macro 
1e81				push hl 
1e81				push de 
1e81				ld hl,(cli_loop_sp) 
1e81				ld de, cli_loop_stack 
1e81				call cmp16 
1e81				jp c, fault_loop_under 
1e81				pop de 
1e81				pop hl 
1e81				endm 
1e81			 
1e81			FORTH_ERR_TOS_NOTSTR: macro 
1e81				; TOSO might need more for checks when used 
1e81				push af 
1e81				ld a,(hl) 
1e81				cp DS_TYPE_STR 
1e81				jp nz, type_faultn   
1e81				pop af 
1e81				endm 
1e81			 
1e81			FORTH_ERR_TOS_NOTNUM: macro 
1e81				push af 
1e81				ld a,(hl) 
1e81				cp DS_TYPE_INUM 
1e81				jp nz, type_faultn   
1e81				pop af 
1e81				endm 
1e81			 
1e81			 
1e81			; increase data stack pointer and save hl to it 
1e81				 
1e81			FORTH_DSP_NEXT: macro 
1e81				call macro_forth_dsp_next 
1e81				endm 
1e81			 
1e81			 
1e81			macro_forth_dsp_next: 
1e81				if DEBUG_FORTH_STACK_GUARD 
1e81 cd 63 66				call check_stacks 
1e84				endif 
1e84 e5				push hl 
1e85 d5				push de 
1e86 eb				ex de,hl 
1e87 2a b0 fb			ld hl,(cli_data_sp) 
1e8a 23				inc hl 
1e8b 23				inc hl 
1e8c			 
1e8c			; PARSEV5 
1e8c 23				inc hl 
1e8d 22 b0 fb			ld (cli_data_sp),hl 
1e90 73				ld (hl), e 
1e91 23				inc hl 
1e92 72				ld (hl), d 
1e93 d1				pop de 
1e94 e1				pop hl 
1e95				if DEBUG_FORTH_STACK_GUARD 
1e95 cd 63 66				call check_stacks 
1e98				endif 
1e98 c9				ret 
1e99			 
1e99			 
1e99			; increase ret stack pointer and save hl to it 
1e99				 
1e99			FORTH_RSP_NEXT: macro 
1e99				call macro_forth_rsp_next 
1e99				endm 
1e99			 
1e99			macro_forth_rsp_next: 
1e99				if DEBUG_FORTH_STACK_GUARD 
1e99 cd 63 66				call check_stacks 
1e9c				endif 
1e9c e5				push hl 
1e9d d5				push de 
1e9e eb				ex de,hl 
1e9f 2a b4 fb			ld hl,(cli_ret_sp) 
1ea2 23				inc hl 
1ea3 23				inc hl 
1ea4 22 b4 fb			ld (cli_ret_sp),hl 
1ea7 73				ld (hl), e 
1ea8 23				inc hl 
1ea9 72				ld (hl), d 
1eaa d1				pop de 
1eab e1				pop hl 
1eac				if DEBUG_FORTH_STACK_GUARD 
1eac cd 63 66				call check_stacks 
1eaf				endif 
1eaf c9				ret 
1eb0			 
1eb0			; get current ret stack pointer and save to hl  
1eb0				 
1eb0			FORTH_RSP_TOS: macro 
1eb0				call macro_forth_rsp_tos 
1eb0				endm 
1eb0			 
1eb0			macro_forth_rsp_tos: 
1eb0				;push de 
1eb0 2a b4 fb			ld hl,(cli_ret_sp) 
1eb3 cd eb 1e			call loadhlptrtohl 
1eb6				;ld e, (hl) 
1eb6				;inc hl 
1eb6				;ld d, (hl) 
1eb6				;ex de, hl 
1eb6					if DEBUG_FORTH_WORDS 
1eb6			;			DMARK "RST" 
1eb6						CALLMONITOR 
1eb6 cd 7e 18			call break_point_state  
1eb9				endm  
# End of macro CALLMONITOR
1eb9					endif 
1eb9				;pop de 
1eb9 c9				ret 
1eba			 
1eba			; pop ret stack pointer 
1eba				 
1eba			FORTH_RSP_POP: macro 
1eba				call macro_forth_rsp_pop 
1eba				endm 
1eba			 
1eba			 
1eba			macro_forth_rsp_pop: 
1eba				if DEBUG_FORTH_STACK_GUARD 
1eba			;		DMARK "RPP" 
1eba cd 63 66				call check_stacks 
1ebd					FORTH_CHK_RSP_UNDER 
1ebd e5				push hl 
1ebe d5				push de 
1ebf 2a b4 fb			ld hl,(cli_ret_sp) 
1ec2 11 6e fb			ld de, cli_ret_stack 
1ec5 cd 1f 0f			call cmp16 
1ec8 da 77 67			jp c, fault_rsp_under 
1ecb d1				pop de 
1ecc e1				pop hl 
1ecd				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ecd				endif 
1ecd e5				push hl 
1ece 2a b4 fb			ld hl,(cli_ret_sp) 
1ed1			 
1ed1			 
1ed1				if FORTH_ENABLE_FREE 
1ed1			 
1ed1					; get pointer 
1ed1			 
1ed1					push de 
1ed1					push hl 
1ed1			 
1ed1					ld e, (hl) 
1ed1					inc hl 
1ed1					ld d, (hl) 
1ed1			 
1ed1					ex de, hl 
1ed1					call free 
1ed1			 
1ed1					pop hl 
1ed1					pop de 
1ed1			 
1ed1			 
1ed1				endif 
1ed1			 
1ed1			 
1ed1 2b				dec hl 
1ed2 2b				dec hl 
1ed3 22 b4 fb			ld (cli_ret_sp), hl 
1ed6				; do stack underflow checks 
1ed6 e1				pop hl 
1ed7				if DEBUG_FORTH_STACK_GUARD 
1ed7 cd 63 66				call check_stacks 
1eda					FORTH_CHK_RSP_UNDER 
1eda e5				push hl 
1edb d5				push de 
1edc 2a b4 fb			ld hl,(cli_ret_sp) 
1edf 11 6e fb			ld de, cli_ret_stack 
1ee2 cd 1f 0f			call cmp16 
1ee5 da 77 67			jp c, fault_rsp_under 
1ee8 d1				pop de 
1ee9 e1				pop hl 
1eea				endm 
# End of macro FORTH_CHK_RSP_UNDER
1eea				endif 
1eea c9				ret 
1eeb			 
1eeb			 
1eeb			 
1eeb			; routine to load word pointed to by hl into hl 
1eeb			 
1eeb			loadhlptrtohl: 
1eeb			 
1eeb d5				push de 
1eec 5e				ld e, (hl) 
1eed 23				inc hl 
1eee 56				ld d, (hl) 
1eef eb				ex de, hl 
1ef0 d1				pop de 
1ef1			 
1ef1 c9				ret 
1ef2			 
1ef2			 
1ef2			 
1ef2			 
1ef2			 
1ef2			; push a number held in HL onto the data stack 
1ef2			; entry point for pushing a value when already in hl used in function above 
1ef2			 
1ef2			forth_push_numhl: 
1ef2			 
1ef2 e5				push hl    ; save value to push 
1ef3			 
1ef3			if DEBUG_FORTH_PUSH 
1ef3				; see if disabled 
1ef3			 
1ef3			 
1ef3 f5				push af 
1ef4 3a 74 f3			ld a, (os_view_disable) 
1ef7 fe 2a			cp '*' 
1ef9 28 34			jr z, .pskip2 
1efb e5				push hl 
1efc e5			push hl 
1efd cd cd 0c			call clear_display 
1f00 e1			pop hl 
1f01 7c				ld a,h 
1f02 21 88 f6			ld hl, os_word_scratch 
1f05 cd 02 12			call hexout 
1f08 e1				pop hl 
1f09 7d				ld a,l 
1f0a 21 8a f6			ld hl, os_word_scratch+2 
1f0d cd 02 12			call hexout 
1f10			 
1f10 21 8c f6			ld hl, os_word_scratch+4 
1f13 3e 00			ld a,0 
1f15 77				ld (hl),a 
1f16 11 88 f6			ld de,os_word_scratch 
1f19 3e 14				ld a, display_row_2 
1f1b cd e0 0c				call str_at_display 
1f1e 11 f9 54			ld de, .push_num 
1f21 3e 00			ld a, display_row_1 
1f23			 
1f23 cd e0 0c				call str_at_display 
1f26			 
1f26			 
1f26 cd f0 0c			call update_display 
1f29 cd 4a 0c			call delay1s 
1f2c cd 4a 0c			call delay1s 
1f2f			.pskip2:  
1f2f			 
1f2f f1				pop af 
1f30			endif	 
1f30			 
1f30			 
1f30				FORTH_DSP_NEXT 
1f30 cd 81 1e			call macro_forth_dsp_next 
1f33				endm 
# End of macro FORTH_DSP_NEXT
1f33			 
1f33 2a b0 fb			ld hl, (cli_data_sp) 
1f36			 
1f36				; save item type 
1f36 3e 02			ld a,  DS_TYPE_INUM 
1f38 77				ld (hl), a 
1f39 23				inc hl 
1f3a			 
1f3a				; get word off stack 
1f3a d1				pop de 
1f3b 7b				ld a,e 
1f3c 77				ld (hl), a 
1f3d 23				inc hl 
1f3e 7a				ld a,d 
1f3f 77				ld (hl), a 
1f40			 
1f40			if DEBUG_FORTH_PUSH 
1f40 2b				dec hl 
1f41 2b				dec hl 
1f42 2b				dec hl 
1f43						DMARK "PH5" 
1f43 f5				push af  
1f44 3a 58 1f			ld a, (.dmark)  
1f47 32 b4 fe			ld (debug_mark),a  
1f4a 3a 59 1f			ld a, (.dmark+1)  
1f4d 32 b5 fe			ld (debug_mark+1),a  
1f50 3a 5a 1f			ld a, (.dmark+2)  
1f53 32 b6 fe			ld (debug_mark+2),a  
1f56 18 03			jr .pastdmark  
1f58 ..			.dmark: db "PH5"  
1f5b f1			.pastdmark: pop af  
1f5c			endm  
# End of macro DMARK
1f5c				CALLMONITOR 
1f5c cd 7e 18			call break_point_state  
1f5f				endm  
# End of macro CALLMONITOR
1f5f			endif	 
1f5f			 
1f5f c9				ret 
1f60			 
1f60			 
1f60			; Push a string to stack pointed to by hl 
1f60			 
1f60			forth_push_str: 
1f60			 
1f60			if DEBUG_FORTH_PUSH 
1f60						DMARK "PSQ" 
1f60 f5				push af  
1f61 3a 75 1f			ld a, (.dmark)  
1f64 32 b4 fe			ld (debug_mark),a  
1f67 3a 76 1f			ld a, (.dmark+1)  
1f6a 32 b5 fe			ld (debug_mark+1),a  
1f6d 3a 77 1f			ld a, (.dmark+2)  
1f70 32 b6 fe			ld (debug_mark+2),a  
1f73 18 03			jr .pastdmark  
1f75 ..			.dmark: db "PSQ"  
1f78 f1			.pastdmark: pop af  
1f79			endm  
# End of macro DMARK
1f79				CALLMONITOR 
1f79 cd 7e 18			call break_point_state  
1f7c				endm  
# End of macro CALLMONITOR
1f7c			endif	 
1f7c			    
1f7c e5				push hl 
1f7d e5				push hl 
1f7e			 
1f7e			;	ld a, 0   ; find end of string 
1f7e cd 5f 13			call strlenz 
1f81			if DEBUG_FORTH_PUSH 
1f81						DMARK "PQ2" 
1f81 f5				push af  
1f82 3a 96 1f			ld a, (.dmark)  
1f85 32 b4 fe			ld (debug_mark),a  
1f88 3a 97 1f			ld a, (.dmark+1)  
1f8b 32 b5 fe			ld (debug_mark+1),a  
1f8e 3a 98 1f			ld a, (.dmark+2)  
1f91 32 b6 fe			ld (debug_mark+2),a  
1f94 18 03			jr .pastdmark  
1f96 ..			.dmark: db "PQ2"  
1f99 f1			.pastdmark: pop af  
1f9a			endm  
# End of macro DMARK
1f9a				CALLMONITOR 
1f9a cd 7e 18			call break_point_state  
1f9d				endm  
# End of macro CALLMONITOR
1f9d			endif	 
1f9d eb				ex de, hl 
1f9e e1				pop hl   ; get ptr to start of string 
1f9f			if DEBUG_FORTH_PUSH 
1f9f						DMARK "PQ3" 
1f9f f5				push af  
1fa0 3a b4 1f			ld a, (.dmark)  
1fa3 32 b4 fe			ld (debug_mark),a  
1fa6 3a b5 1f			ld a, (.dmark+1)  
1fa9 32 b5 fe			ld (debug_mark+1),a  
1fac 3a b6 1f			ld a, (.dmark+2)  
1faf 32 b6 fe			ld (debug_mark+2),a  
1fb2 18 03			jr .pastdmark  
1fb4 ..			.dmark: db "PQ3"  
1fb7 f1			.pastdmark: pop af  
1fb8			endm  
# End of macro DMARK
1fb8				CALLMONITOR 
1fb8 cd 7e 18			call break_point_state  
1fbb				endm  
# End of macro CALLMONITOR
1fbb			endif	 
1fbb 19				add hl,de 
1fbc			if DEBUG_FORTH_PUSH 
1fbc						DMARK "PQE" 
1fbc f5				push af  
1fbd 3a d1 1f			ld a, (.dmark)  
1fc0 32 b4 fe			ld (debug_mark),a  
1fc3 3a d2 1f			ld a, (.dmark+1)  
1fc6 32 b5 fe			ld (debug_mark+1),a  
1fc9 3a d3 1f			ld a, (.dmark+2)  
1fcc 32 b6 fe			ld (debug_mark+2),a  
1fcf 18 03			jr .pastdmark  
1fd1 ..			.dmark: db "PQE"  
1fd4 f1			.pastdmark: pop af  
1fd5			endm  
# End of macro DMARK
1fd5				CALLMONITOR 
1fd5 cd 7e 18			call break_point_state  
1fd8				endm  
# End of macro CALLMONITOR
1fd8			endif	 
1fd8			 
1fd8 2b				dec hl    ; see if there is an optional trailing double quote 
1fd9 7e				ld a,(hl) 
1fda fe 22			cp '"' 
1fdc 20 03			jr nz, .strnoq 
1fde 3e 00			ld a, 0      ; get rid of double quote 
1fe0 77				ld (hl), a 
1fe1 23			.strnoq: inc hl 
1fe2			 
1fe2 3e 00			ld a, 0 
1fe4 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1fe5			 
1fe5 13				inc de ; add one for the type string 
1fe6 13				inc de ; add one for null term??? 
1fe7			 
1fe7				; tos is get string pointer again 
1fe7				; de contains space to allocate 
1fe7				 
1fe7 d5				push de 
1fe8			 
1fe8 eb				ex de, hl 
1fe9			 
1fe9				;push af 
1fe9			 
1fe9			if DEBUG_FORTH_PUSH 
1fe9						DMARK "PHm" 
1fe9 f5				push af  
1fea 3a fe 1f			ld a, (.dmark)  
1fed 32 b4 fe			ld (debug_mark),a  
1ff0 3a ff 1f			ld a, (.dmark+1)  
1ff3 32 b5 fe			ld (debug_mark+1),a  
1ff6 3a 00 20			ld a, (.dmark+2)  
1ff9 32 b6 fe			ld (debug_mark+2),a  
1ffc 18 03			jr .pastdmark  
1ffe ..			.dmark: db "PHm"  
2001 f1			.pastdmark: pop af  
2002			endm  
# End of macro DMARK
2002				CALLMONITOR 
2002 cd 7e 18			call break_point_state  
2005				endm  
# End of macro CALLMONITOR
2005			endif	 
2005 cd c8 13			call malloc	; on ret hl now contains allocated memory 
2008				if DEBUG_FORTH_MALLOC_GUARD 
2008 cc 51 55				call z,malloc_error 
200b				endif 
200b			 
200b				 
200b c1				pop bc    ; get length 
200c d1				pop de   ;  get string start    
200d			 
200d				; hl has destination from malloc 
200d			 
200d eb				ex de, hl    ; prep for ldir 
200e			 
200e d5				push de   ; save malloc area for DSP later 
200f				;push hl   ; save malloc area for DSP later 
200f			 
200f			if DEBUG_FORTH_PUSH 
200f						DMARK "PHc" 
200f f5				push af  
2010 3a 24 20			ld a, (.dmark)  
2013 32 b4 fe			ld (debug_mark),a  
2016 3a 25 20			ld a, (.dmark+1)  
2019 32 b5 fe			ld (debug_mark+1),a  
201c 3a 26 20			ld a, (.dmark+2)  
201f 32 b6 fe			ld (debug_mark+2),a  
2022 18 03			jr .pastdmark  
2024 ..			.dmark: db "PHc"  
2027 f1			.pastdmark: pop af  
2028			endm  
# End of macro DMARK
2028				CALLMONITOR 
2028 cd 7e 18			call break_point_state  
202b				endm  
# End of macro CALLMONITOR
202b			endif	 
202b			 
202b			 
202b ed b0			ldir 
202d			 
202d			 
202d				; push malloc to data stack     macro?????  
202d			 
202d				FORTH_DSP_NEXT 
202d cd 81 1e			call macro_forth_dsp_next 
2030				endm 
# End of macro FORTH_DSP_NEXT
2030			 
2030				; save value and type 
2030			 
2030 2a b0 fb			ld hl, (cli_data_sp) 
2033			 
2033				; save item type 
2033 3e 01			ld a,  DS_TYPE_STR 
2035 77				ld (hl), a 
2036 23				inc hl 
2037			 
2037				; get malloc word off stack 
2037 d1				pop de 
2038 73				ld (hl), e 
2039 23				inc hl 
203a 72				ld (hl), d 
203b			 
203b			 
203b			 
203b			if DEBUG_FORTH_PUSH 
203b 2a b0 fb			ld hl, (cli_data_sp) 
203e						DMARK "PHS" 
203e f5				push af  
203f 3a 53 20			ld a, (.dmark)  
2042 32 b4 fe			ld (debug_mark),a  
2045 3a 54 20			ld a, (.dmark+1)  
2048 32 b5 fe			ld (debug_mark+1),a  
204b 3a 55 20			ld a, (.dmark+2)  
204e 32 b6 fe			ld (debug_mark+2),a  
2051 18 03			jr .pastdmark  
2053 ..			.dmark: db "PHS"  
2056 f1			.pastdmark: pop af  
2057			endm  
# End of macro DMARK
2057				CALLMONITOR 
2057 cd 7e 18			call break_point_state  
205a				endm  
# End of macro CALLMONITOR
205a			;	ex de,hl 
205a			endif	 
205a				; in case of spaces, skip the ptr past the copied string 
205a				;pop af 
205a				;ld (cli_origptr),hl 
205a			 
205a c9				ret 
205b			 
205b			 
205b			 
205b			; TODO ascii push input onto stack given hl to start of input 
205b			 
205b			; identify type 
205b			; if starts with a " then a string 
205b			; otherwise it is a number 
205b			;  
205b			; if a string 
205b			;     scan for ending " to get length of string to malloc for + 1 
205b			;     malloc 
205b			;     put pointer to string on stack first byte flags as string 
205b			; 
205b			; else a number 
205b			;    look for number format identifier 
205b			;    $xx hex 
205b			;    %xxxxx bin 
205b			;    xxxxx decimal 
205b			;    convert number to 16bit word.  
205b			;    malloc word + 1 with flag to identiy as num 
205b			;    put pointer to number on stack 
205b			;   
205b			;  
205b			  
205b			forth_apush: 
205b				; kernel push 
205b			 
205b			if DEBUG_FORTH_PUSH 
205b						DMARK "PSH" 
205b f5				push af  
205c 3a 70 20			ld a, (.dmark)  
205f 32 b4 fe			ld (debug_mark),a  
2062 3a 71 20			ld a, (.dmark+1)  
2065 32 b5 fe			ld (debug_mark+1),a  
2068 3a 72 20			ld a, (.dmark+2)  
206b 32 b6 fe			ld (debug_mark+2),a  
206e 18 03			jr .pastdmark  
2070 ..			.dmark: db "PSH"  
2073 f1			.pastdmark: pop af  
2074			endm  
# End of macro DMARK
2074				CALLMONITOR 
2074 cd 7e 18			call break_point_state  
2077				endm  
# End of macro CALLMONITOR
2077			endif	 
2077				; identify input type 
2077			 
2077 7e				ld a,(hl) 
2078 fe 22			cp '"' 
207a 28 0a			jr z, .fapstr 
207c fe 24			cp '$' 
207e ca a6 20			jp z, .faphex 
2081 fe 25			cp '%' 
2083 ca 8e 20			jp z, .fapbin 
2086			;	cp 'b' 
2086			;	jp z, .fabin 
2086				; else decimal 
2086			 
2086				; TODO do decimal conversion 
2086				; decimal is stored as a 16bit word 
2086			 
2086				; by default everything is a string if type is not detected 
2086			.fapstr: ; 
2086 fe 22			cp '"' 
2088 20 01			jr nz, .strnoqu 
208a 23				inc hl 
208b			.strnoqu: 
208b c3 60 1f			jp forth_push_str 
208e			 
208e			 
208e			 
208e			.fapbin:    ; push a binary string.  
208e 11 00 00			ld de, 0   ; hold a 16bit value 
2091			 
2091 23			.fapbinshift:	inc hl  
2092 7e				ld a,(hl) 
2093 fe 00			cp 0     ; done scanning  
2095 28 0b			jr z, .fapbdone  	; got it in HL so push  
2097			 
2097				; left shift de 
2097 eb				ex de, hl	 
2098 29				add hl, hl 
2099			 
2099				; is 1 
2099 fe 31			cp '1' 
209b 20 02			jr nz, .binzero 
209d cb 4d			bit 1, l 
209f			.binzero: 
209f eb				ex de, hl	 ; save current de 
20a0 18 ef			jr .fapbinshift 
20a2			 
20a2			.fapbdone: 
20a2 eb				ex de, hl 
20a3 c3 f2 1e			jp forth_push_numhl 
20a6			 
20a6			 
20a6			.faphex:   ; hex is always stored as a 16bit word 
20a6				; skip number prefix 
20a6 23				inc hl 
20a7				; turn ascii into number 
20a7 cd b8 12			call get_word_hl	; ret 16bit word in hl 
20aa			 
20aa c3 f2 1e			jp forth_push_numhl 
20ad			 
20ad 00				 nop 
20ae			 
20ae			.fabin:   ; TODO bin conversion 
20ae			 
20ae			 
20ae c9				ret 
20af			 
20af			 
20af			; get either a string ptr or a 16bit word from the data stack 
20af			 
20af			FORTH_DSP: macro 
20af				call macro_forth_dsp 
20af				endm 
20af			 
20af			macro_forth_dsp: 
20af				; data stack pointer points to current word on tos 
20af			 
20af 2a b0 fb			ld hl,(cli_data_sp) 
20b2			 
20b2				if DEBUG_FORTH_PUSH 
20b2						DMARK "DSP" 
20b2 f5				push af  
20b3 3a c7 20			ld a, (.dmark)  
20b6 32 b4 fe			ld (debug_mark),a  
20b9 3a c8 20			ld a, (.dmark+1)  
20bc 32 b5 fe			ld (debug_mark+1),a  
20bf 3a c9 20			ld a, (.dmark+2)  
20c2 32 b6 fe			ld (debug_mark+2),a  
20c5 18 03			jr .pastdmark  
20c7 ..			.dmark: db "DSP"  
20ca f1			.pastdmark: pop af  
20cb			endm  
# End of macro DMARK
20cb			 
20cb cd 86 55				call display_data_sp 
20ce				;call break_point_state 
20ce				;rst 030h 
20ce				CALLMONITOR 
20ce cd 7e 18			call break_point_state  
20d1				endm  
# End of macro CALLMONITOR
20d1				endif 
20d1			 
20d1 c9				ret 
20d2			 
20d2			; return hl to start of value on stack 
20d2			 
20d2			FORTH_DSP_VALUE: macro 
20d2				call macro_forth_dsp_value 
20d2				endm 
20d2			 
20d2			macro_forth_dsp_value: 
20d2			 
20d2				FORTH_DSP 
20d2 cd af 20			call macro_forth_dsp 
20d5				endm 
# End of macro FORTH_DSP
20d5			 
20d5 d5				push de 
20d6			 
20d6 23				inc hl ; skip type 
20d7			 
20d7 5e				ld e, (hl) 
20d8 23				inc hl 
20d9 56				ld d, (hl) 
20da eb				ex de,hl  
20db			 
20db d1				pop de 
20dc			 
20dc c9				ret 
20dd			 
20dd			; return hl to start of value to second item on stack 
20dd			 
20dd			FORTH_DSP_VALUEM1: macro 
20dd				call macro_forth_dsp_value_m1 
20dd				endm 
20dd			 
20dd			macro_forth_dsp_value_m1: 
20dd			 
20dd				FORTH_DSP 
20dd cd af 20			call macro_forth_dsp 
20e0				endm 
# End of macro FORTH_DSP
20e0			 
20e0 2b				dec hl 
20e1 2b				dec hl 
20e2			;	dec hl 
20e2			 
20e2 d5				push de 
20e3			 
20e3 5e				ld e, (hl) 
20e4 23				inc hl 
20e5 56				ld d, (hl) 
20e6 eb				ex de,hl  
20e7			 
20e7 d1				pop de 
20e8			 
20e8 c9				ret 
20e9			 
20e9				 
20e9			 
20e9			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
20e9			 
20e9			FORTH_DSP_POP: macro 
20e9				call macro_forth_dsp_pop 
20e9				endm 
20e9			 
20e9			 
20e9			; get the tos data type 
20e9			 
20e9			FORTH_DSP_TYPE:   macro 
20e9			 
20e9				;FORTH_DSP_VALUE 
20e9				FORTH_DSP 
20e9				 
20e9				; hl points to value 
20e9				; check type 
20e9			 
20e9				ld a,(hl) 
20e9			 
20e9				endm 
20e9			 
20e9			; load the tos value into hl 
20e9			 
20e9			 
20e9			FORTH_DSP_VALUEHL:  macro 
20e9				call macro_dsp_valuehl 
20e9				endm 
20e9			 
20e9			 
20e9			 
20e9			macro_dsp_valuehl: 
20e9				FORTH_DSP_VALUE 
20e9 cd d2 20			call macro_forth_dsp_value 
20ec				endm 
# End of macro FORTH_DSP_VALUE
20ec			 
20ec				;FORTH_ERR_TOS_NOTNUM 
20ec			 
20ec				;inc hl   ; skip type id 
20ec			 
20ec			;	push de 
20ec			; 
20ec			;	ld e, (hl) 
20ec			;	inc hl 
20ec			;	ld d, (hl) 
20ec			;	ex de,hl  
20ec			 
20ec			;	pop de 
20ec			 
20ec				if DEBUG_FORTH_PUSH 
20ec						DMARK "DVL" 
20ec f5				push af  
20ed 3a 01 21			ld a, (.dmark)  
20f0 32 b4 fe			ld (debug_mark),a  
20f3 3a 02 21			ld a, (.dmark+1)  
20f6 32 b5 fe			ld (debug_mark+1),a  
20f9 3a 03 21			ld a, (.dmark+2)  
20fc 32 b6 fe			ld (debug_mark+2),a  
20ff 18 03			jr .pastdmark  
2101 ..			.dmark: db "DVL"  
2104 f1			.pastdmark: pop af  
2105			endm  
# End of macro DMARK
2105				CALLMONITOR 
2105 cd 7e 18			call break_point_state  
2108				endm  
# End of macro CALLMONITOR
2108				endif 
2108 c9				ret 
2109			 
2109			forth_apushstrhl:      
2109				; push of string requires use of cli_origptr 
2109				; bodge use 
2109			 
2109				; get current cli_origptr, save, update with temp pointer  
2109 ed 5b cc fb		ld de, (cli_origptr) 
210d 22 cc fb			ld (cli_origptr), hl 
2110 d5				push de 
2111 cd 5b 20			call forth_apush 
2114 d1				pop de 
2115 ed 53 cc fb		ld (cli_origptr), de 
2119 c9			        ret	 
211a			 
211a			 
211a			; increase loop stack pointer and save hl to it 
211a				 
211a			FORTH_LOOP_NEXT: macro 
211a				call macro_forth_loop_next 
211a				;nop 
211a				endm 
211a			 
211a			macro_forth_loop_next: 
211a				if DEBUG_FORTH_STACK_GUARD 
211a cd 63 66				call check_stacks 
211d				endif 
211d e5				push hl 
211e d5				push de 
211f eb				ex de,hl 
2120 2a b2 fb			ld hl,(cli_loop_sp) 
2123 23				inc hl 
2124 23				inc hl 
2125					if DEBUG_FORTH_WORDS 
2125						DMARK "LNX" 
2125 f5				push af  
2126 3a 3a 21			ld a, (.dmark)  
2129 32 b4 fe			ld (debug_mark),a  
212c 3a 3b 21			ld a, (.dmark+1)  
212f 32 b5 fe			ld (debug_mark+1),a  
2132 3a 3c 21			ld a, (.dmark+2)  
2135 32 b6 fe			ld (debug_mark+2),a  
2138 18 03			jr .pastdmark  
213a ..			.dmark: db "LNX"  
213d f1			.pastdmark: pop af  
213e			endm  
# End of macro DMARK
213e						CALLMONITOR 
213e cd 7e 18			call break_point_state  
2141				endm  
# End of macro CALLMONITOR
2141					endif 
2141 22 b2 fb			ld (cli_loop_sp),hl 
2144 73				ld (hl), e 
2145 23				inc hl 
2146 72				ld (hl), d 
2147 d1				pop de    ; been reversed so save a swap on restore 
2148 e1				pop hl 
2149				if DEBUG_FORTH_STACK_GUARD 
2149 cd 63 66				call check_stacks 
214c				endif 
214c c9				ret 
214d			 
214d			; get current ret stack pointer and save to hl  
214d				 
214d			FORTH_LOOP_TOS: macro 
214d				call macro_forth_loop_tos 
214d				endm 
214d			 
214d			macro_forth_loop_tos: 
214d d5				push de 
214e 2a b2 fb			ld hl,(cli_loop_sp) 
2151 5e				ld e, (hl) 
2152 23				inc hl 
2153 56				ld d, (hl) 
2154 eb				ex de, hl 
2155 d1				pop de 
2156 c9				ret 
2157			 
2157			; pop loop stack pointer 
2157				 
2157			FORTH_LOOP_POP: macro 
2157				call macro_forth_loop_pop 
2157				endm 
2157			 
2157			 
2157			macro_forth_loop_pop: 
2157				if DEBUG_FORTH_STACK_GUARD 
2157					DMARK "LPP" 
2157 f5				push af  
2158 3a 6c 21			ld a, (.dmark)  
215b 32 b4 fe			ld (debug_mark),a  
215e 3a 6d 21			ld a, (.dmark+1)  
2161 32 b5 fe			ld (debug_mark+1),a  
2164 3a 6e 21			ld a, (.dmark+2)  
2167 32 b6 fe			ld (debug_mark+2),a  
216a 18 03			jr .pastdmark  
216c ..			.dmark: db "LPP"  
216f f1			.pastdmark: pop af  
2170			endm  
# End of macro DMARK
2170 cd 63 66				call check_stacks 
2173					FORTH_CHK_LOOP_UNDER 
2173 e5				push hl 
2174 d5				push de 
2175 2a b2 fb			ld hl,(cli_loop_sp) 
2178 11 ec fa			ld de, cli_loop_stack 
217b cd 1f 0f			call cmp16 
217e da 7d 67			jp c, fault_loop_under 
2181 d1				pop de 
2182 e1				pop hl 
2183				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2183				endif 
2183 e5				push hl 
2184 2a b2 fb			ld hl,(cli_loop_sp) 
2187 2b				dec hl 
2188 2b				dec hl 
2189 22 b2 fb			ld (cli_loop_sp), hl 
218c				; TODO do stack underflow checks 
218c e1				pop hl 
218d				if DEBUG_FORTH_STACK_GUARD 
218d cd 63 66				call check_stacks 
2190					FORTH_CHK_LOOP_UNDER 
2190 e5				push hl 
2191 d5				push de 
2192 2a b2 fb			ld hl,(cli_loop_sp) 
2195 11 ec fa			ld de, cli_loop_stack 
2198 cd 1f 0f			call cmp16 
219b da 7d 67			jp c, fault_loop_under 
219e d1				pop de 
219f e1				pop hl 
21a0				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21a0				endif 
21a0 c9				ret 
21a1			 
21a1			macro_forth_dsp_pop: 
21a1			 
21a1 e5				push hl 
21a2			 
21a2				; release malloc data 
21a2			 
21a2				if DEBUG_FORTH_STACK_GUARD 
21a2 cd 63 66				call check_stacks 
21a5					FORTH_CHK_DSP_UNDER 
21a5 e5				push hl 
21a6 d5				push de 
21a7 2a b0 fb			ld hl,(cli_data_sp) 
21aa 11 ea f8			ld de, cli_data_stack 
21ad cd 1f 0f			call cmp16 
21b0 da 71 67			jp c, fault_dsp_under 
21b3 d1				pop de 
21b4 e1				pop hl 
21b5				endm 
# End of macro FORTH_CHK_DSP_UNDER
21b5				endif 
21b5				;ld hl,(cli_data_sp) 
21b5			if DEBUG_FORTH_DOT 
21b5				DMARK "DPP" 
21b5				CALLMONITOR 
21b5			endif	 
21b5			 
21b5			 
21b5			if FORTH_ENABLE_DSPPOPFREE 
21b5			 
21b5				FORTH_DSP 
21b5 cd af 20			call macro_forth_dsp 
21b8				endm 
# End of macro FORTH_DSP
21b8			 
21b8 7e				ld a, (hl) 
21b9 fe 01			cp DS_TYPE_STR 
21bb 20 07			jr nz, .skippopfree 
21bd			 
21bd				FORTH_DSP_VALUEHL 
21bd cd e9 20			call macro_dsp_valuehl 
21c0				endm 
# End of macro FORTH_DSP_VALUEHL
21c0 00				nop 
21c1			if DEBUG_FORTH_DOT 
21c1				DMARK "DPf" 
21c1				CALLMONITOR 
21c1			endif	 
21c1 cd 92 14			call free 
21c4			.skippopfree: 
21c4				 
21c4			 
21c4			endif 
21c4			 
21c4			if DEBUG_FORTH_DOT_KEY 
21c4				DMARK "DP2" 
21c4				CALLMONITOR 
21c4			endif	 
21c4			 
21c4				; move pointer down 
21c4			 
21c4 2a b0 fb			ld hl,(cli_data_sp) 
21c7 2b				dec hl 
21c8 2b				dec hl 
21c9			; PARSEV5 
21c9 2b				dec hl 
21ca 22 b0 fb			ld (cli_data_sp), hl 
21cd			 
21cd				if DEBUG_FORTH_STACK_GUARD 
21cd cd 63 66				call check_stacks 
21d0					FORTH_CHK_DSP_UNDER 
21d0 e5				push hl 
21d1 d5				push de 
21d2 2a b0 fb			ld hl,(cli_data_sp) 
21d5 11 ea f8			ld de, cli_data_stack 
21d8 cd 1f 0f			call cmp16 
21db da 71 67			jp c, fault_dsp_under 
21de d1				pop de 
21df e1				pop hl 
21e0				endm 
# End of macro FORTH_CHK_DSP_UNDER
21e0				endif 
21e0			 
21e0 e1				pop hl 
21e1			 
21e1 c9				ret 
21e2			 
21e2			getwordathl: 
21e2				; hl points to an address 
21e2				; load hl with the word at that address 
21e2			 
21e2 d5				push de 
21e3			 
21e3 5e				ld e, (hl) 
21e4 23				inc hl 
21e5 56				ld d, (hl) 
21e6 eb				ex de, hl 
21e7			 
21e7 d1				pop de 
21e8 c9				ret 
21e9			 
21e9			 
21e9			 
21e9			 
21e9			 
21e9			; eof 
21e9			 
# End of file forth_stackopsv5.asm
21e9			endif 
21e9			 
21e9			user_word_eol:  
21e9				; hl contains the pointer to where to create a linked list item from the end 
21e9				; of the user dict to continue on at the system word dict 
21e9				 
21e9				; poke the stub of the word list linked list to repoint to rom words 
21e9			 
21e9				; stub format 
21e9				; db   word id 
21e9				; dw    link to next word 
21e9			        ; db char length of token 
21e9				; db string + 0 term 
21e9				; db exec code....  
21e9			 
21e9 3e 00			ld a, WORD_SYS_ROOT     ; root word 
21eb 77				ld (hl), a		; word id 
21ec 23				inc hl 
21ed			 
21ed 11 b8 23			ld de, sysdict 
21f0 73				ld (hl), e		; next word link ie system dict 
21f1 23				inc hl 
21f2 72				ld (hl), d		; next word link ie system dict 
21f3 23				inc hl	 
21f4			 
21f4			;	ld (hl), sysdict		; next word link ie system dict 
21f4			;	inc hl 
21f4			;	inc hl 
21f4			 
21f4			;	inc hl 
21f4			;	inc hl 
21f4			 
21f4 3e 02			ld a, 2			; word length is 0 
21f6 77				ld (hl), a	 
21f7 23				inc hl 
21f8			 
21f8 3e 7e			ld a, '~'			; word length is 0 
21fa 77				ld (hl), a	 
21fb 23				inc hl 
21fc 3e 00			ld a, 0			; save empty word 
21fe 77				ld (hl), a 
21ff			 
21ff c9				ret 
2200			 
2200				 
2200			 
2200			forthexec_cleanup: 
2200				FORTH_RSP_POP 
2200 cd ba 1e			call macro_forth_rsp_pop 
2203				endm 
# End of macro FORTH_RSP_POP
2203 c9				ret 
2204			 
2204			forth_call_hl: 
2204				; taking hl 
2204 e5				push hl 
2205 c9				ret 
2206			 
2206			; this is called to reset Forth system but keep existing uwords etc 
2206			 
2206			forth_warmstart: 
2206				; setup stack over/under flow checks 
2206				if DEBUG_FORTH_STACK_GUARD 
2206 cd 49 66				call chk_stk_init 
2209				endif 
2209			 
2209				; init stack pointers  - * these stacks go upwards *  
2209 21 6e fb			ld hl, cli_ret_stack 
220c 22 b4 fb			ld (cli_ret_sp), hl	 
220f				; set bottom of stack 
220f 3e 00			ld a,0 
2211 77				ld (hl),a 
2212 23				inc hl 
2213 77				ld (hl),a 
2214			 
2214 21 ea f8			ld hl, cli_data_stack 
2217 22 b0 fb			ld (cli_data_sp), hl	 
221a				; set bottom of stack 
221a 3e 00			ld a,0 
221c 77				ld (hl),a 
221d 23				inc hl 
221e 77				ld (hl),a 
221f			 
221f 21 ec fa			ld hl, cli_loop_stack 
2222 22 b2 fb			ld (cli_loop_sp), hl	 
2225				; set bottom of stack 
2225 3e 00			ld a,0 
2227 77				ld (hl),a 
2228 23				inc hl 
2229 77				ld (hl),a 
222a			 
222a				; init extent of current open file 
222a			 
222a 3e 00			ld a, 0 
222c 32 f7 fb			ld (store_openext), a 
222f			 
222f c9				ret 
2230			 
2230			 
2230			; Cold Start - this is called to setup the whole Forth system 
2230			 
2230			forth_init: 
2230			 
2230				; setup stack over/under flow checks 
2230			 
2230			;	if DEBUG_FORTH_STACK_GUARD 
2230			;		call chk_stk_init 
2230			;	endif 
2230			 
2230				; enable auto display updates (slow.....) 
2230			 
2230 3e 01			ld a, 1 
2232 32 ca fb			ld (cli_autodisplay), a 
2235			 
2235				; if storage is in use disable long reads for now 
2235 3e 00			ld a, 0 
2237 32 02 fc			ld (store_longread), a 
223a			 
223a			 
223a				; show start up screen 
223a			 
223a cd cd 0c			call clear_display 
223d			 
223d 3e 00			ld a,0 
223f 32 ec fb			ld (f_cursor_ptr), a 
2242			 
2242				; set start of word list in start of ram - for use when creating user words 
2242			 
2242 21 00 80			ld hl, baseram 
2245 22 80 f6			ld (os_last_new_uword), hl 
2248 cd e9 21			call user_word_eol 
224b				 
224b			;		call display_data_sp 
224b			;		call next_page_prompt 
224b			 
224b			 
224b			 
224b			 
224b c9				ret 
224c			 
224c .. 00		.bootforth: db " Forth Kernel Init ",0 
2260			 
2260			; TODO push to stack 
2260			 
2260			;  
2260			 
2260			if FORTH_PARSEV2 
2260			 
2260			 
2260				include "forth_parserv2.asm" 
2260			 
2260			endif 
2260			 
2260			 
2260			; parse cli version 1 
2260			 
2260			if FORTH_PARSEV1 
2260			 
2260			 
2260			 
2260			      include "forth_parserv1.asm" 
2260			endif 
2260				 
2260			if FORTH_PARSEV3 
2260			 
2260			 
2260			 
2260			      include "forth_parserv3.asm" 
2260				include "forth_wordsv3.asm" 
2260			endif 
2260			 
2260			if FORTH_PARSEV4 
2260			 
2260			 
2260			 
2260			      include "forth_parserv4.asm" 
2260				include "forth_wordsv4.asm" 
2260			endif 
2260			 
2260			if FORTH_PARSEV5 
2260			 
2260			 
2260			 
2260			      include "forth_parserv5.asm" 
2260			 
2260			 
2260			; A better parser without using malloc and string copies all over the place.  
2260			; Exec in situ should be faster 
2260			 
2260			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2260			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2260			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2260			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2260			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2260			WORD_SYS_END: equ 0   ; Opcode for all user words 
2260			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2260			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2260			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2260			 
2260			; Core word preamble macro 
2260			 
2260			CWHEAD:   macro nxtword opcode lit len opflags 
2260				db WORD_SYS_CORE+opcode             
2260				; internal op code number 
2260				dw nxtword            
2260				; link to next dict word block 
2260				db len + 1 
2260				; literal length of dict word inc zero term 
2260				db lit,0              
2260				; literal dict word 
2260			        ; TODO db opflags        
2260				endm 
2260			 
2260			 
2260			NEXTW: macro  
2260				jp macro_next 
2260				endm 
2260			 
2260			macro_next: 
2260			if DEBUG_FORTH_PARSE_KEY 
2260				DMARK "NXT" 
2260				CALLMONITOR 
2260			endif	 
2260			;	inc hl  ; skip token null term  
2260 ed 4b ce fb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2264 ed 5b cc fb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2268 2a 84 f6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
226b			if DEBUG_FORTH_PARSE_KEY 
226b				DMARK "}AA" 
226b				CALLMONITOR 
226b			endif	 
226b c3 6e 23			jp execnext 
226e				;jp exec1 
226e			       
226e			 
226e			 
226e			; Another go at the parser to compile  
226e			 
226e			 
226e			; TODO rework parser to change all of the string words to byte tokens 
226e			; TODO do a search for  
226e			 
226e			; TODO first run normal parser to zero term sections 
226e			; TODO for each word do a token look up to get the op code 
226e			; TODO need some means to flag to the exec that this is a byte code form    
226e			 
226e			 
226e			forthcompile: 
226e			 
226e			; 
226e			; line parse: 
226e			;       parse raw input buffer 
226e			;       tokenise the words 
226e			;       malloc new copy (for looping etc) 
226e			;       copy to malloc + current pc in line to start of string and add line term 
226e			;       save on new rsp 
226e			; 
226e			 
226e			; hl to point to the line to tokenise 
226e			 
226e			;	push hl 
226e 22 84 f6			ld (os_tok_ptr), hl  ; save ptr to string 
2271			 
2271			;	ld a,0		; string term on input 
2271			;	call strlent 
2271			 
2271			;	ld (os_tok_len), hl	 ; save string length 
2271			 
2271			;if DEBUG_FORTH_TOK 
2271			;	ex de,hl		 
2271			;endif 
2271			 
2271			;	pop hl 		; get back string pointer 
2271			 
2271			if DEBUG_FORTH_TOK 
2271						DMARK "TOc" 
2271				CALLMONITOR 
2271			endif 
2271 7e			.cptoken2:    ld a,(hl) 
2272 23				inc hl 
2273 fe 7f			cp FORTH_END_BUFFER 
2275 28 29			jr z, .cptokendone2 
2277 fe 00			cp 0 
2279 28 25			jr z, .cptokendone2 
227b fe 22			cp '"' 
227d 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
227f fe 20			cp ' ' 
2281 20 ee			jr nz,  .cptoken2 
2283			 
2283			; TODO consume comments held between ( and ) 
2283			 
2283				; we have a space so change to zero term for dict match later 
2283 2b				dec hl 
2284 3e 00			ld a,0 
2286 77				ld (hl), a 
2287 23				inc hl 
2288 18 e7			jr .cptoken2 
228a				 
228a			 
228a			.cptokenstr2: 
228a				; skip all white space until either eol (because forgot to term) or end double quote 
228a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
228a				;inc hl ; skip current double quote 
228a 7e				ld a,(hl) 
228b 23				inc hl 
228c fe 22			cp '"' 
228e 28 e1			jr z, .cptoken2 
2290 fe 7f			cp FORTH_END_BUFFER 
2292 28 0c			jr z, .cptokendone2 
2294 fe 00			cp 0 
2296 28 08			jr z, .cptokendone2 
2298 fe 20			cp ' ' 
229a 28 02			jr z, .cptmp2 
229c 18 ec			jr .cptokenstr2 
229e			 
229e			.cptmp2:	; we have a space so change to zero term for dict match later 
229e				;dec hl 
229e				;ld a,"-"	; TODO remove this when working 
229e				;ld (hl), a 
229e				;inc hl 
229e 18 ea			jr .cptokenstr2 
22a0			 
22a0			.cptokendone2: 
22a0				;inc hl 
22a0 3e 7f			ld a, FORTH_END_BUFFER 
22a2 77				ld (hl),a 
22a3 23				inc hl 
22a4 3e 21			ld a, '!' 
22a6 77				ld (hl),a 
22a7			 
22a7 2a 84 f6			ld hl,(os_tok_ptr) 
22aa			         
22aa			if DEBUG_FORTH_TOK 
22aa						DMARK "Tc1" 
22aa				CALLMONITOR 
22aa			endif 
22aa			 
22aa				; push exec string to top of return stack 
22aa				FORTH_RSP_NEXT 
22aa cd 99 1e			call macro_forth_rsp_next 
22ad				endm 
# End of macro FORTH_RSP_NEXT
22ad c9				ret 
22ae			 
22ae			; Another go at the parser need to simplify the process 
22ae			 
22ae			forthparse: 
22ae			 
22ae			; 
22ae			; line parse: 
22ae			;       parse raw input buffer 
22ae			;       tokenise the words 
22ae			;       malloc new copy (for looping etc) 
22ae			;       copy to malloc + current pc in line to start of string and add line term 
22ae			;       save on new rsp 
22ae			; 
22ae			 
22ae			; hl to point to the line to tokenise 
22ae			 
22ae			;	push hl 
22ae 22 84 f6			ld (os_tok_ptr), hl  ; save ptr to string 
22b1			 
22b1			;	ld a,0		; string term on input 
22b1			;	call strlent 
22b1			 
22b1			;	ld (os_tok_len), hl	 ; save string length 
22b1			 
22b1			;if DEBUG_FORTH_TOK 
22b1			;	ex de,hl		 
22b1			;endif 
22b1			 
22b1			;	pop hl 		; get back string pointer 
22b1			 
22b1			if DEBUG_FORTH_TOK 
22b1						DMARK "TOK" 
22b1				CALLMONITOR 
22b1			endif 
22b1 7e			.ptoken2:    ld a,(hl) 
22b2 23				inc hl 
22b3 fe 7f			cp FORTH_END_BUFFER 
22b5 28 29			jr z, .ptokendone2 
22b7 fe 00			cp 0 
22b9 28 25			jr z, .ptokendone2 
22bb fe 22			cp '"' 
22bd 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
22bf fe 20			cp ' ' 
22c1 20 ee			jr nz,  .ptoken2 
22c3			 
22c3			; TODO consume comments held between ( and ) 
22c3			 
22c3				; we have a space so change to zero term for dict match later 
22c3 2b				dec hl 
22c4 3e 00			ld a,0 
22c6 77				ld (hl), a 
22c7 23				inc hl 
22c8 18 e7			jr .ptoken2 
22ca				 
22ca			 
22ca			.ptokenstr2: 
22ca				; skip all white space until either eol (because forgot to term) or end double quote 
22ca			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
22ca				;inc hl ; skip current double quote 
22ca 7e				ld a,(hl) 
22cb 23				inc hl 
22cc fe 22			cp '"' 
22ce 28 e1			jr z, .ptoken2 
22d0 fe 7f			cp FORTH_END_BUFFER 
22d2 28 0c			jr z, .ptokendone2 
22d4 fe 00			cp 0 
22d6 28 08			jr z, .ptokendone2 
22d8 fe 20			cp ' ' 
22da 28 02			jr z, .ptmp2 
22dc 18 ec			jr .ptokenstr2 
22de			 
22de			.ptmp2:	; we have a space so change to zero term for dict match later 
22de				;dec hl 
22de				;ld a,"-"	; TODO remove this when working 
22de				;ld (hl), a 
22de				;inc hl 
22de 18 ea			jr .ptokenstr2 
22e0			 
22e0			.ptokendone2: 
22e0				;inc hl 
22e0 3e 7f			ld a, FORTH_END_BUFFER 
22e2 77				ld (hl),a 
22e3 23				inc hl 
22e4 3e 21			ld a, '!' 
22e6 77				ld (hl),a 
22e7			 
22e7 2a 84 f6			ld hl,(os_tok_ptr) 
22ea			         
22ea			if DEBUG_FORTH_TOK 
22ea						DMARK "TK1" 
22ea				CALLMONITOR 
22ea			endif 
22ea			 
22ea				; push exec string to top of return stack 
22ea				FORTH_RSP_NEXT 
22ea cd 99 1e			call macro_forth_rsp_next 
22ed				endm 
# End of macro FORTH_RSP_NEXT
22ed c9				ret 
22ee			 
22ee			; 
22ee			;	; malloc size + buffer pointer + if is loop flag 
22ee			;	ld hl,(os_tok_len) 		 ; get string length 
22ee			; 
22ee			;	ld a,l 
22ee			; 
22ee			;	cp 0			; we dont want to use a null string 
22ee			;	ret z 
22ee			; 
22ee			;;	add 3    ; prefix malloc with buffer for current word ptr 
22ee			; 
22ee			;	add 5     ; TODO when certain not over writing memory remove 
22ee			; 
22ee			;		 
22ee			; 
22ee			;if DEBUG_FORTH_TOK 
22ee			;			DMARK "TKE" 
22ee			;	CALLMONITOR 
22ee			;endif 
22ee			; 
22ee			;	ld l,a 
22ee			;	ld h,0 
22ee			;;	push hl   ; save required space for the copy later 
22ee			;	call malloc 
22ee			;if DEBUG_FORTH_TOK 
22ee			;			DMARK "TKM" 
22ee			;	CALLMONITOR 
22ee			;endif 
22ee			;	if DEBUG_FORTH_MALLOC_GUARD 
22ee			;		push af 
22ee			;		call ishlzero 
22ee			;;		ld a, l 
22ee			;;		add h 
22ee			;;		cp 0 
22ee			;		pop af 
22ee			;		 
22ee			;		call z,malloc_error 
22ee			;	endif 
22ee			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
22ee			; 
22ee			; 
22ee			;if DEBUG_FORTH_TOK 
22ee			;			DMARK "TKR" 
22ee			;	CALLMONITOR 
22ee			;endif 
22ee			; 
22ee			;	FORTH_RSP_NEXT 
22ee			; 
22ee			;	;inc hl	 ; go past current buffer pointer 
22ee			;	;inc hl 
22ee			;	;inc hl   ; and past if loop flag 
22ee			;		; TODO Need to set flag  
22ee			; 
22ee			;	 
22ee			;	 
22ee			;	ex de,hl	; malloc is dest 
22ee			;	ld hl, (os_tok_len) 
22ee			;;	pop bc 
22ee			;	ld c, l                
22ee			;	ld b,0 
22ee			;	ld hl, (os_tok_ptr) 
22ee			; 
22ee			;if DEBUG_FORTH_TOK 
22ee			;			DMARK "TKT" 
22ee			;	CALLMONITOR 
22ee			;endif 
22ee			; 
22ee			;	; do str cpy 
22ee			; 
22ee			;	ldir      ; copy byte in hl to de 
22ee			; 
22ee			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
22ee			; 
22ee			;if DEBUG_FORTH_TOK 
22ee			; 
22ee			;			DMARK "TKY" 
22ee			;	CALLMONITOR 
22ee			;endif 
22ee			;	;ld a,0 
22ee			;	;ld a,FORTH_END_BUFFER 
22ee			;	ex de, hl 
22ee			;	;dec hl			 ; go back over the space delim at the end of word 
22ee			;	;ld (hl),a 
22ee			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
22ee			;	ld a,FORTH_END_BUFFER 
22ee			;	ld (hl),a 
22ee			;	inc hl 
22ee			;	ld a,FORTH_END_BUFFER 
22ee			;	ld (hl),a 
22ee			; 
22ee			;	; init the malloc area data 
22ee			;	; set pc for in current area 
22ee			;	;ld hl, (os_tok_malloc) 
22ee			;	;inc hl 
22ee			;	;inc hl 
22ee			;	;inc hl 
22ee			;	;ex de,hl 
22ee			;	;ld hl, (os_tok_malloc) 
22ee			;	;ld (hl),e 
22ee			;	;inc hl 
22ee			;	;ld (hl),d 
22ee			; 
22ee			; 
22ee			;	ld hl,(os_tok_malloc) 
22ee			;if DEBUG_FORTH_PARSE_KEY 
22ee			;			DMARK "TKU" 
22ee			;	CALLMONITOR 
22ee			;endif 
22ee			; 
22ee			;	ret 
22ee			 
22ee			forthexec: 
22ee			 
22ee			; line exec: 
22ee			; forth parser 
22ee			 
22ee			; 
22ee			;       get current exec line on rsp 
22ee			 
22ee				FORTH_RSP_TOS 
22ee cd b0 1e			call macro_forth_rsp_tos 
22f1				endm 
# End of macro FORTH_RSP_TOS
22f1			 
22f1			;       restore current pc - hl points to malloc of data 
22f1			 
22f1				;ld e, (hl) 
22f1				;inc hl 
22f1				;ld d, (hl) 
22f1				;ex de,hl 
22f1			 
22f1			 
22f1			exec1: 
22f1 22 84 f6			ld (os_tok_ptr), hl 
22f4			 
22f4				; copy our PC to working vars  
22f4 22 ce fb			ld (cli_ptr), hl 
22f7 22 cc fb			ld (cli_origptr), hl 
22fa			 
22fa 7e				ld a,(hl) 
22fb fe 7f			cp FORTH_END_BUFFER 
22fd c8				ret z 
22fe			 
22fe				; skip any nulls 
22fe			 
22fe fe 00			cp 0 
2300 20 03			jr nz, .execword 
2302 23				inc hl 
2303 18 ec			jr exec1 
2305			 
2305			 
2305			.execword: 
2305			 
2305			 
2305			 
2305			if DEBUG_FORTH_PARSE_KEY 
2305						DMARK "KYQ" 
2305				CALLMONITOR 
2305			endif 
2305			;       while at start of word: 
2305			; get start of dict (in user area first) 
2305			 
2305 21 00 80		ld hl, baseram 
2308			;ld hl, sysdict 
2308 22 d0 fb		ld (cli_nextword),hl 
230b			;           match word at pc 
230b			;           exec word 
230b			;           or push to dsp 
230b			;           forward to next token 
230b			;           if line term pop rsp and exit 
230b			;        
230b			 
230b			if DEBUG_FORTH_PARSE_KEY 
230b						DMARK "KYq" 
230b				CALLMONITOR 
230b			endif 
230b			 
230b			; 
230b			; word comp 
230b			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
230b			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
230b			;    move to start of word  
230b			;    compare word to cli_token 
230b			 
230b			.execpnword:	; HL at start of a word in the dictionary to check 
230b			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
230b			;	ld (cli_ptr), hl 
230b			 
230b 2a d0 fb			ld hl,(cli_nextword) 
230e			 
230e cd b1 23			call forth_tok_next 
2311			; tok next start here 
2311			;	; TODO skip compiled symbol for now 
2311			;	inc hl 
2311			; 
2311			;	; save pointer to next word 
2311			; 
2311			;	; hl now points to the address of the next word pointer  
2311			;	ld e, (hl) 
2311			;	inc hl 
2311			;	ld d, (hl) 
2311			;	inc l 
2311			; 
2311			;	ex de,hl 
2311			;if DEBUG_FORTH_PARSE_NEXTWORD 
2311			;	push bc 
2311			;	ld bc, (cli_nextword) 
2311			;			DMARK "NXW" 
2311			;	CALLMONITOR 
2311			;	pop bc 
2311			;endif 
2311			; tok next end here 
2311 22 d0 fb			ld (cli_nextword), hl     ; save for next check if no match on this word 
2314 eb				ex de, hl 
2315			 
2315			 
2315				; save the pointer of the current token - 1 to check against 
2315				 
2315 22 d4 fb			ld (cli_token), hl   
2318				; TODO maybe remove below save if no debug 
2318				; save token string ptr for any debug later 
2318 23				inc hl  
2319 22 d6 fb			ld (cli_origtoken), hl 
231c 2b				dec hl 
231d				; save pointer to the start of the next dictionay word 
231d 7e				ld a,(hl)   ; get string length 
231e 47				ld b,a 
231f			.execpnwordinc:  
231f 23				inc hl 
2320 10 fd			djnz .execpnwordinc 
2322 22 d2 fb			ld (cli_execword), hl      ; save start of this words code 
2325			 
2325				; now check the word token against the string being parsed 
2325			 
2325 2a d4 fb			ld hl,(cli_token) 
2328 23				inc hl     ; skip string length (use zero term instead to end) 
2329 22 d4 fb			ld (cli_token), hl 
232c			 
232c			if DEBUG_FORTH_PARSE_KEY 
232c						DMARK "KY2" 
232c			endif 
232c			if DEBUG_FORTH_PARSE_EXEC 
232c				; see if disabled 
232c			 
232c				ld a, (os_view_disable) 
232c				cp '*' 
232c				jr z, .skip 
232c			 
232c				push hl 
232c				push hl 
232c				call clear_display 
232c				ld de, .compword 
232c				ld a, display_row_1 
232c				call str_at_display 
232c				pop de 
232c				ld a, display_row_2 
232c				call str_at_display 
232c				ld hl,(cli_ptr) 
232c				ld a,(hl) 
232c			        ld hl, os_word_scratch 
232c				ld (hl),a 
232c				ld a,0 
232c				inc hl 
232c				ld (hl),a 	 
232c				ld de, os_word_scratch 
232c				ld a, display_row_2+10 
232c				call str_at_display 
232c				call update_display 
232c				ld a, 100 
232c				call aDelayInMS 
232c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
232c				call delay250ms 
232c				endif 
232c				pop hl 
232c			.skip:  
232c			endif	 
232c			.execpnchar:    ; compare char between token and string to parse 
232c			 
232c			if DEBUG_FORTH_PARSE_KEY 
232c						DMARK "Ky3" 
232c			endif 
232c			if DEBUG_FORTH_PARSE_EXEC 
232c				; see if disabled 
232c			 
232c				ld a, (os_view_disable) 
232c				cp '*' 
232c				jr z, .skip2 
232c			 
232c			;	call clear_display 
232c			ld hl,(cli_token) 
232c			ld a,(hl) 
232c			ld (os_word_scratch),a 
232c				ld hl,(cli_ptr) 
232c			ld a,(hl) 
232c				ld (os_word_scratch+1),a 
232c				ld a,0 
232c				ld (os_word_scratch+2),a 
232c				ld de,os_word_scratch 
232c				ld a,display_row_4 
232c				call str_at_display 
232c				call update_display 
232c			.skip2:  
232c			endif 
232c 2a d4 fb			ld hl,(cli_token) 
232f 7e				ld a, (hl)	 ; char in word token 
2330 23				inc hl 		; move to next char 
2331 22 d4 fb			ld (cli_token), hl ; and save it 
2334 47				ld b,a 
2335			 
2335 2a ce fb			ld hl,(cli_ptr) ;	get the char from the string to parse 
2338 7e				ld a,(hl) 
2339 23				inc hl 
233a 22 ce fb			ld (cli_ptr), hl		; move to next char 
233d cd 56 13			call toUpper 		; make sure the input string matches case 
2340			 
2340			if DEBUG_FORTH_PARSE 
2340			endif 
2340			 
2340				; input stream end of token is a space so get rid of it 
2340			 
2340			;	cp ' ' 
2340			;	jr nz, .pnskipspace 
2340			; 
2340			;	ld a, 0		; make same term as word token term 
2340			; 
2340			;.pnskipspace: 
2340			 
2340			if DEBUG_FORTH_PARSE_KEY 
2340						DMARK "KY7" 
2340			endif 
2340 b8				cp b 
2341 c2 57 23			jp nz, .execpnskipword	 ; no match so move to next word 
2344				 
2344			;    if same 
2344			;       scan for string terms 0 for token and 32 for input 
2344			 
2344				 
2344			if DEBUG_FORTH_PARSE_KEY 
2344						DMARK "KY8" 
2344			endif 
2344			 
2344 80				add b			 
2345 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2347							; TODO need to make sure last word in zero term string is accounted for 
2347 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2349			 
2349			 
2349				; at end of both strings so both are exact match 
2349			 
2349			;       skip ptr for next word 
2349			 
2349 2a ce fb			ld hl,(cli_ptr) 	; at input string term 
234c 23				inc hl			 ; at next char 
234d 22 ce fb			ld (cli_ptr), hl     ; save for next round of the parser 
2350 22 cc fb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2353				 
2353				 
2353			if DEBUG_FORTH_PARSE_KEY 
2353						DMARK "KY3" 
2353			endif 
2353			 
2353			 
2353			 
2353			;       exec code block 
2353			if DEBUG_FORTH_JP 
2353				call clear_display 
2353				call update_display 
2353				call delay1s 
2353				ld hl, (cli_execword)     ; save for next check if no match on this word 
2353				ld a,h 
2353				ld hl, os_word_scratch 
2353				call hexout 
2353				ld hl, (cli_execword)     ; save for next check if no match on this word 
2353				ld a,l 
2353				ld hl, os_word_scratch+2 
2353				call hexout 
2353				ld hl, os_word_scratch+4 
2353				ld a,0 
2353				ld (hl),a 
2353				ld de,os_word_scratch 
2353				call str_at_display 
2353					ld a, display_row_2 
2353					call str_at_display 
2353				ld de, (cli_origtoken) 
2353				ld a, display_row_1+10 
2353					call str_at_display 
2353			 
2353				ld a,display_row_1 
2353				ld de, .foundword 
2353				ld a, display_row_3 
2353				call str_at_display 
2353				call update_display 
2353				call delay1s 
2353				call delay1s 
2353				call delay1s 
2353			endif 
2353			 
2353			if DEBUG_FORTH_PARSE_KEY 
2353						DMARK "KYj" 
2353			endif 
2353				; TODO save the word pointer in this exec 
2353			 
2353 2a d2 fb			ld hl,(cli_execword) 
2356 e9				jp (hl) 
2357			 
2357			 
2357			;    if not same 
2357			;	scan for zero term 
2357			;	get ptr for next word 
2357			;	goto word comp 
2357			 
2357			.execpnskipword:	; get pointer to next word 
2357 2a d0 fb			ld hl,(cli_nextword) 
235a			 
235a 7e				ld a,(hl) 
235b fe 00			cp WORD_SYS_END 
235d			;	cp 0 
235d 28 09			jr z, .execendofdict			 ; at end of words 
235f			 
235f			if DEBUG_FORTH_PARSE_KEY 
235f						DMARK "KY4" 
235f			endif 
235f			if DEBUG_FORTH_PARSE_EXEC 
235f			 
235f				; see if disabled 
235f			 
235f				ld a, (os_view_disable) 
235f				cp '*' 
235f				jr z, .noskip 
235f			 
235f			 
235f				ld de, .nowordfound 
235f				ld a, display_row_3 
235f				call str_at_display 
235f				call update_display 
235f				ld a, 100 
235f				call aDelayInMS 
235f				 
235f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
235f					call delay250ms 
235f				endif 
235f			.noskip:  
235f			 
235f			endif	 
235f			 
235f 2a cc fb			ld hl,(cli_origptr) 
2362 22 ce fb			ld (cli_ptr),hl 
2365			 
2365			if DEBUG_FORTH_PARSE_KEY 
2365						DMARK "KY5" 
2365			endif 
2365 c3 0b 23			jp .execpnword			; else go to next word 
2368			 
2368			.execendofdict:  
2368			 
2368			if DEBUG_FORTH_PARSE_KEY 
2368						DMARK "KYe" 
2368			endif 
2368			if DEBUG_FORTH_PARSE_EXEC 
2368				; see if disabled 
2368			 
2368				ld a, (os_view_disable) 
2368				cp '*' 
2368				jr z, .ispskip 
2368			 
2368				call clear_display 
2368				call update_display 
2368				call delay1s 
2368				ld de, (cli_origptr) 
2368				ld a, display_row_1 
2368				call str_at_display 
2368				 
2368				ld de, .enddict 
2368				ld a, display_row_3 
2368				call str_at_display 
2368				call update_display 
2368				ld a, 100 
2368				call aDelayInMS 
2368				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2368				call delay1s 
2368				call delay1s 
2368				call delay1s 
2368				endif 
2368			.ispskip:  
2368				 
2368			endif	 
2368			 
2368			 
2368			 
2368				; if the word is not a keyword then must be a literal so push it to stack 
2368			 
2368			; push token to stack to end of word 
2368			 
2368				STACKFRAME ON $1efe $2f9f 
2368				if DEBUG_STACK_IMB 
2368					if ON 
2368						exx 
2368						ld de, $1efe 
2368						ld a, d 
2368						ld hl, curframe 
2368						call hexout 
2368						ld a, e 
2368						ld hl, curframe+2 
2368						call hexout 
2368						ld hl, $1efe 
2368						push hl 
2368						ld hl, $2f9f 
2368						push hl 
2368						exx 
2368					endif 
2368				endif 
2368			endm 
# End of macro STACKFRAME
2368			 
2368 2a 84 f6		ld hl,(os_tok_ptr) 
236b cd 5b 20		call forth_apush 
236e			 
236e				STACKFRAMECHK ON $1efe $2f9f 
236e				if DEBUG_STACK_IMB 
236e					if ON 
236e						exx 
236e						ld hl, $2f9f 
236e						pop de   ; $2f9f 
236e						call cmp16 
236e						jr nz, .spnosame 
236e						ld hl, $1efe 
236e						pop de   ; $1efe 
236e						call cmp16 
236e						jr z, .spfrsame 
236e						.spnosame: call showsperror 
236e						.spfrsame: nop 
236e						exx 
236e					endif 
236e				endif 
236e			endm 
# End of macro STACKFRAMECHK
236e			 
236e			execnext: 
236e			 
236e			if DEBUG_FORTH_PARSE_KEY 
236e						DMARK "KY>" 
236e			endif 
236e			; move past token to next word 
236e			 
236e 2a 84 f6		ld hl, (os_tok_ptr) 
2371 3e 00		ld a, 0 
2373 01 ff 00		ld bc, 255     ; input buffer size 
2376 ed b1		cpir 
2378			 
2378			if DEBUG_FORTH_PARSE_KEY 
2378						DMARK "KY!" 
2378				CALLMONITOR 
2378			endif	 
2378			; TODO this might place hl on the null, so will need to forward on??? 
2378			;inc hl   ; see if this gets onto the next item 
2378			 
2378			 
2378			; TODO pass a pointer to the buffer to push 
2378			; TODO call function to push 
2378			 
2378			; look for end of input 
2378			 
2378			;inc hl 
2378			;ld a,(hl) 
2378			;cp FORTH_END_BUFFER 
2378			;ret z 
2378			 
2378			 
2378 c3 f1 22		jp exec1 
237b			 
237b			 
237b			 
237b			 
237b			 
237b			 
237b			 
237b			 
237b			 
237b			findnexttok: 
237b			 
237b				; hl is pointer to move 
237b				; de is the token to locate 
237b			 
237b					if DEBUG_FORTH 
237b						DMARK "NTK" 
237b						CALLMONITOR 
237b					endif 
237b d5				push de 
237c			 
237c			.fnt1:	 
237c				; find first char of token to locate 
237c			 
237c 1a				ld a, (de) 
237d 4f				ld c,a 
237e 7e				ld a,(hl) 
237f cd 56 13			call toUpper 
2382					if DEBUG_FORTH 
2382						DMARK "NT1" 
2382						CALLMONITOR 
2382					endif 
2382 b9				cp c 
2383			 
2383 28 03			jr z, .fnt2cmpmorefirst	 
2385			 
2385				; first char not found move to next char 
2385			 
2385 23				inc hl 
2386 18 f4			jr .fnt1 
2388			 
2388			.fnt2cmpmorefirst:	 
2388				; first char of token found.  
2388			 
2388 e5				push hl     ; save start of token just in case it is the right one 
2389 d9				exx 
238a e1				pop hl        ; save it to hl' 
238b d9				exx 
238c			 
238c			 
238c			.fnt2cmpmore:	 
238c				; compare the rest 
238c				 
238c 23				inc hl 
238d 13				inc de 
238e				 
238e 1a				ld a, (de) 
238f 4f				ld c,a 
2390 7e				ld a,(hl) 
2391 cd 56 13			call toUpper 
2394			 
2394					if DEBUG_FORTH 
2394						DMARK "NT2" 
2394						CALLMONITOR 
2394					endif 
2394				; c has the token to find char 
2394				; a has the mem to scan char 
2394			 
2394 b9				cp c 
2395 28 04			jr z,.fntmatch1 
2397			 
2397				; they are not the same 
2397			 
2397					if DEBUG_FORTH 
2397						DMARK "NT3" 
2397						CALLMONITOR 
2397					endif 
2397 d1				pop de	; reset de token to look for 
2398 d5				push de 
2399 18 e1			jr .fnt1 
239b				 
239b			.fntmatch1: 
239b			 
239b				; is the same char a null which means we might have a full hit? 
239b					if DEBUG_FORTH 
239b						DMARK "NT4" 
239b						CALLMONITOR 
239b					endif 
239b			 
239b fe 00			cp 0 
239d 28 0b			jr z, .fntmatchyes 
239f			 
239f				; are we at the end of the token to find? 
239f			 
239f					if DEBUG_FORTH 
239f						DMARK "NT5" 
239f						CALLMONITOR 
239f					endif 
239f 3e 00			ld a, 0 
23a1 b9				cp c 
23a2			 
23a2 c2 8c 23			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
23a5			 
23a5					if DEBUG_FORTH 
23a5						DMARK "NT6" 
23a5						CALLMONITOR 
23a5					endif 
23a5				; token to find is exhusted but no match to stream 
23a5			 
23a5				; restore tok pointer and continue on 
23a5 d1				pop de 
23a6 d5				push de 
23a7 c3 7c 23			jp .fnt1 
23aa			 
23aa			 
23aa			.fntmatchyes: 
23aa			 
23aa				; hl now contains the end of the found token 
23aa			 
23aa				; get rid of saved token pointer to find 
23aa			 
23aa d1				pop de 
23ab			 
23ab					if DEBUG_FORTH 
23ab						DMARK "NT9" 
23ab						CALLMONITOR 
23ab					endif 
23ab			 
23ab				; hl will be on the null term so forward on 
23ab			 
23ab				; get back the saved start of the token 
23ab			 
23ab d9				exx 
23ac e5				push hl     ; save start of token just in case it is the right one 
23ad d9				exx 
23ae e1				pop hl        ; save it to hl 
23af			 
23af c9				ret 
23b0			 
23b0			 
23b0			; LIST needs to find a specific token   
23b0			; FORGET needs to find a spefici token 
23b0			 
23b0			; SAVE needs to find all tokens by flag 
23b0			; WORDS just needs to scan through all  by flag 
23b0			; UWORDS needs to scan through all by flag 
23b0			 
23b0			 
23b0			; given hl as pointer to start of dict look up string 
23b0			; return hl as pointer to start of word block 
23b0			; or 0 if not found 
23b0			 
23b0			forth_find_tok: 
23b0 c9				ret 
23b1			 
23b1			; given hl as pointer to dict structure 
23b1			; move to the next dict block structure 
23b1			 
23b1			forth_tok_next: 
23b1				; hl now points to the address of the next word pointer  
23b1				; TODO skip compiled symbol for now 
23b1			;	push de 
23b1 23				inc hl 
23b2 5e				ld e, (hl) 
23b3 23				inc hl 
23b4 56				ld d, (hl) 
23b5 23				inc hl 
23b6			 
23b6 eb				ex de,hl 
23b7			if DEBUG_FORTH_PARSE_NEXTWORD 
23b7				push bc 
23b7				ld bc, (cli_nextword) 
23b7						DMARK "NXW" 
23b7				CALLMONITOR 
23b7				pop bc 
23b7			endif 
23b7			;	pop de	 
23b7 c9				ret 
23b8			 
23b8			 
23b8			 
23b8			; eof 
# End of file forth_parserv5.asm
23b8				include "forth_wordsv4.asm" 
23b8			 
23b8			; the core word dictionary v4 
23b8			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
23b8			 
23b8			; this is a linked list for each of the system words used 
23b8			; user defined words will follow the same format but will be in ram 
23b8			 
23b8			 
23b8			; 
23b8			; 
23b8			; define linked list: 
23b8			; 
23b8			; 1. compiled byte op code 
23b8			; 2. len of text word 
23b8			; 3. text word 
23b8			; 4. ptr to next dictionary word 
23b8			; 5. asm, calls etc for the word 
23b8			; 
23b8			;  if 1 == 0 then last word in dict  
23b8			;   
23b8			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
23b8			;  
23b8			;  
23b8			; create basic standard set of words 
23b8			; 
23b8			;  
23b8			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
23b8			; 2DUP 2DROP 2SWAP  
23b8			; @ C@ - get byte  
23b8			; ! C! - store byte 
23b8			; 0< true if less than zero 
23b8			; 0= true if zero 
23b8			; < >  
23b8			; = true if same 
23b8			; variables 
23b8			 
23b8			 
23b8			; Hardware specific words I may need 
23b8			; 
23b8			; IN OUT  
23b8			; calls to key util functions 
23b8			; calls to hardward abstraction stuff 
23b8			; easy control of frame buffers and lcd i/o 
23b8			; keyboard  
23b8			 
23b8			 
23b8			;DICT: macro 
23b8			; op_code, len, word, next 
23b8			;    word: 
23b8			;    db op_code 
23b8			;    ds word zero term 
23b8			;    dw next 
23b8			;    endm 
23b8			 
23b8			 
23b8			 
23b8			 
23b8			; op code 1 is a flag for user define words which are to be handled differently 
23b8			 
23b8			 
23b8			; 
23b8			; 
23b8			;    TODO on entry to a word this should be the expected environment 
23b8			;    hl - tos value if number then held, if string this is the ptr 
23b8			;    de -  
23b8			 
23b8			 
23b8			; opcode ranges 
23b8			; 0 - end of word dict 
23b8			; 255 - user define words 
23b8			 
23b8			sysdict: 
23b8			include "forth_opcodes.asm" 
23b8			; op codes for forth keywords 
23b8			; free to use code 0  
23b8				OPCODE_HEAP: equ  1 
23b8				OPCODE_EXEC: equ 2 
23b8				OPCODE_DUP: equ 3 
23b8				OPCODE_SWAP: equ 4 
23b8				OPCODE_COLN: equ 5 
23b8				OPCODE_SCOLN: equ 6 
23b8				OPCODE_DROP: equ 7 
23b8				OPCODE_DUP2: equ 8 
23b8				OPCODE_DROP2: equ 9 
23b8				OPCODE_SWAP2: equ 10 
23b8				OPCODE_AT: equ 11 
23b8				OPCODE_CAT: equ 12 
23b8				OPCODE_BANG: equ 13 
23b8				OPCODE_CBANG: equ 14 
23b8				OPCODE_SCALL: equ 15 
23b8				OPCODE_DEPTH: equ 16 
23b8				OPCODE_OVER: equ 17 
23b8				OPCODE_PAUSE: equ 18 
23b8				OPCODE_PAUSES: equ 19 
23b8				OPCODE_ROT: equ 20 
23b8			;free to reuse	OPCODE_WORDS: equ 21 
23b8			        OPCODE_NOT: equ 21 
23b8				OPCODE_UWORDS: equ 22 
23b8				OPCODE_BP: equ 23 
23b8				OPCODE_MONITOR: equ 24  
23b8				OPCODE_MALLOC: equ 25 
23b8				OPCODE_FREE: equ 26 
23b8				OPCODE_LIST: equ 27 
23b8				OPCODE_FORGET: equ 28 
23b8				OPCODE_NOP: equ 29 
23b8				OPCODE_COMO: equ 30 
23b8				OPCODE_COMC: equ 31 
23b8			;free to reuse	OPCODE_ENDCORE: equ 32 
23b8				OPCODE_AFTERSOUND: equ 33 
23b8				OPCODE_GP2: equ 34 
23b8				OPCODE_GP3: equ 35 
23b8				OPCODE_GP4: equ 36 
23b8				OPCODE_SIN: equ 37 
23b8				OPCODE_SOUT: equ 38 
23b8				OPCODE_SPIO: equ 39 
23b8				OPCODE_SPICEH: equ 40 
23b8				OPCODE_SPIOb: equ 41 
23b8				OPCODE_SPII: equ 42 
23b8				OPCODE_SESEL: equ 43 
23b8				OPCODE_CARTDEV: equ 44 
23b8			; free to reuse	OPCODE_ENDDEVICE: equ 45 
23b8				OPCODE_FB: equ 46 
23b8				OPCODE_EMIT: equ 47 
23b8				OPCODE_DOTH: equ 48 
23b8				OPCODE_DOTF: equ 49 
23b8				OPCODE_DOT: equ 50 
23b8				OPCODE_CLS: equ 51 
23b8				OPCODE_DRAW: equ 52 
23b8				OPCODE_DUMP: equ 53 
23b8				OPCODE_CDUMP: equ 54 
23b8				OPCODE_DAT: equ 55 
23b8				OPCODE_HOME: equ 56 
23b8				OPCODE_SPACE: equ 57 
23b8				OPCODE_SPACES: equ 58 
23b8				OPCODE_SCROLL: equ 59 
23b8				OPCODE_ATQ: equ 60 
23b8				OPCODE_AUTODSP: equ 61 
23b8				OPCODE_MENU: equ 62 
23b8			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
23b8				OPCODE_THEN: equ 64 
23b8				OPCODE_ELSE: equ 65 
23b8				OPCODE_DO: equ 66 
23b8				OPCODE_LOOP: equ 67 
23b8				OPCODE_I: equ 68 
23b8				OPCODE_DLOOP: equ 69  
23b8				OPCODE_REPEAT: equ 70  
23b8				OPCODE_UNTIL: equ 71 
23b8				OPCODE_ENDFLOW: equ 72 
23b8				OPCODE_WAITK: equ 73 
23b8				OPCODE_ACCEPT: equ 74 
23b8				OPCODE_EDIT: equ 75 
23b8			;free to reuse	OPCODE_ENDKEY: equ 76 
23b8				OPCODE_LZERO: equ 77 
23b8				OPCODE_TZERO: equ 78 
23b8				OPCODE_LESS: equ 79 
23b8				OPCODE_GT: equ 80 
23b8				OPCODE_EQUAL: equ 81  
23b8			;free to reuse	OPCODE_ENDLOGIC: equ 82 
23b8				OPCODE_NEG: equ 83 
23b8				OPCODE_DIV: equ 84 
23b8				OPCODE_MUL: equ 85 
23b8				OPCODE_MIN: equ 86 
23b8				OPCODE_MAX: equ 87 
23b8				OPCODE_RND16: equ 88 
23b8				OPCODE_RND8: equ 89 
23b8				OPCODE_RND: equ 90 
23b8			;free to reuse	OPCODE_ENDMATHS: equ 91  
23b8				OPCODE_BYNAME: equ 92 
23b8				OPCODE_DIR: equ 93 
23b8				OPCODE_SAVE: equ 94 
23b8				OPCODE_LOAD: equ 95 
23b8				OPCODE_BSAVE: equ 96 
23b8				OPCODE_BLOAD: equ 97 
23b8				OPCODE_SEO: equ 98  
23b8				OPCODE_SEI: equ 99 
23b8				OPCODE_SFREE: equ 100 
23b8				OPCODE_SIZE: equ 101 
23b8				OPCODE_CREATE: equ 102 
23b8				OPCODE_APPEND: equ 103 
23b8				OPCODE_SDEL: equ 104 
23b8				OPCODE_OPEN: equ 105 
23b8				OPCODE_READ: equ 106 
23b8				OPCODE_EOF: equ 106 
23b8				OPCODE_FORMAT: equ 107 
23b8				OPCODE_LABEL: equ 108 
23b8				OPCODE_LABELS: equ 109 
23b8			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
23b8				OPCODE_UPPER: equ 111 
23b8				OPCODE_LOWER: equ 112 
23b8				OPCODE_SUBSTR: equ 113 
23b8				OPCODE_LEFT: equ 114 
23b8				OPCODE_RIGHT: equ 115 
23b8				OPCODE_STR2NUM: equ 116 
23b8				OPCODE_NUM2STR: equ 117 
23b8				OPCODE_CONCAT: equ 118 
23b8				OPCODE_FIND: equ 119 
23b8				OPCODE_LEN: equ 120 
23b8				OPCODE_CHAR: equ 121 
23b8			; free to reuse	OPCODE_STRLEN: equ 122 
23b8			; free to reuse	OPCODE_ENDSTR: equ 123 
23b8				OPCODE_V0S: equ 124 
23b8				OPCODE_V0Q: equ 125 
23b8				OPCODE_V1S: equ 126 
23b8				OPCODE_V1Q: equ 127 
23b8				OPCODE_V2S: equ 128 
23b8				OPCODE_V2Q: equ 129 
23b8				OPCODE_V3S: equ 130 
23b8				OPCODE_V3Q: equ 131 
23b8			;free to reuse	OPCODE_END: equ 132 
23b8				OPCODE_ZDUP: equ 133 
23b8			 
23b8			; eof 
# End of file forth_opcodes.asm
23b8			 
23b8			include "forth_words_core.asm" 
23b8			 
23b8			; | ## Core Words 
23b8			 
23b8			;if MALLOC_4 
23b8			 
23b8			.HEAP: 
23b8				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
23b8 15				db WORD_SYS_CORE+OPCODE_HEAP             
23b9 f7 23			dw .EXEC            
23bb 05				db 4 + 1 
23bc .. 00			db "HEAP",0              
23c1				endm 
# End of macro CWHEAD
23c1			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
23c1			; | | u1 - Current number of bytes in the heap 
23c1			; | | u2 - Remaining bytes left on the heap 
23c1			; | |  
23c1			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
23c1			 
23c1			 
23c1					if DEBUG_FORTH_WORDS_KEY 
23c1						DMARK "HEP" 
23c1 f5				push af  
23c2 3a d6 23			ld a, (.dmark)  
23c5 32 b4 fe			ld (debug_mark),a  
23c8 3a d7 23			ld a, (.dmark+1)  
23cb 32 b5 fe			ld (debug_mark+1),a  
23ce 3a d8 23			ld a, (.dmark+2)  
23d1 32 b6 fe			ld (debug_mark+2),a  
23d4 18 03			jr .pastdmark  
23d6 ..			.dmark: db "HEP"  
23d9 f1			.pastdmark: pop af  
23da			endm  
# End of macro DMARK
23da						CALLMONITOR 
23da cd 7e 18			call break_point_state  
23dd				endm  
# End of macro CALLMONITOR
23dd					endif 
23dd 2a 0a 80				ld hl, (free_list )      
23e0 11 0e 80				ld de, heap_start 
23e3			 
23e3 ed 52				sbc hl, de  
23e5			 
23e5 cd f2 1e				call forth_push_numhl 
23e8			 
23e8			 
23e8 ed 5b 0a 80			ld de, (free_list )      
23ec 21 69 f3				ld hl, heap_end 
23ef			 
23ef ed 52				sbc hl, de 
23f1			 
23f1 cd f2 1e				call forth_push_numhl 
23f4					 
23f4			 
23f4					 
23f4			 
23f4			 
23f4			 
23f4					NEXTW 
23f4 c3 60 22			jp macro_next 
23f7				endm 
# End of macro NEXTW
23f7			;endif 
23f7			 
23f7			.EXEC: 
23f7			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
23f7			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
23f7			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
23f7			;; > > 
23f7			;; > >   
23f7			;	STACKFRAME OFF $5efe $5f9f 
23f7			; 
23f7			;		if DEBUG_FORTH_WORDS_KEY 
23f7			;			DMARK "EXE" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			; 
23f7			;	FORTH_DSP_VALUEHL 
23f7			; 
23f7			;	FORTH_DSP_POP 
23f7			; 
23f7			;		if DEBUG_FORTH_WORDS 
23f7			;			DMARK "EX1" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			;;	ld e,(hl) 
23f7			;;	inc hl 
23f7			;;	ld d,(hl) 
23f7			;;	ex de,hl 
23f7			; 
23f7			;;		if DEBUG_FORTH_WORDS 
23f7			;;			DMARK "EX2" 
23f7			;;			CALLMONITOR 
23f7			;;		endif 
23f7			;	push hl 
23f7			; 
23f7			;	;ld a, 0 
23f7			;	;ld a, FORTH_END_BUFFER 
23f7			;	call strlenz 
23f7			;	inc hl   ; include zero term to copy 
23f7			;	inc hl   ; include term 
23f7			;	inc hl   ; include term 
23f7			;	ld b,0 
23f7			;	ld c,l 
23f7			;	pop hl 
23f7			;	ld de, execscratch 
23f7			;		if DEBUG_FORTH_WORDS 
23f7			;			DMARK "EX3" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			;	ldir 
23f7			; 
23f7			; 
23f7			;	ld hl, execscratch 
23f7			; 
23f7			;		if DEBUG_FORTH_WORDS 
23f7			;			DMARK "EXe" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			; 
23f7			;	call forthparse 
23f7			;	call forthexec 
23f7			;;	call forthexec_cleanup 
23f7			;;	call forthparse 
23f7			;;	call forthexec 
23f7			; 
23f7			;	STACKFRAMECHK OFF $5efe $5f9f 
23f7			; 
23f7			;	; an immediate word so no need to process any more words 
23f7			;	ret 
23f7			;	NEXTW 
23f7			 
23f7			; dead code - old version  
23f7			;	FORTH_RSP_NEXT 
23f7			 
23f7			;  
23f7			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23f7			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23f7			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
23f7			;	push hl 
23f7			;	push de 
23f7			;	push bc 
23f7			; 
23f7			; 
23f7			;		if DEBUG_FORTH_WORDS_KEY 
23f7			;			DMARK "EXR" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			; 
23f7			; 
23f7			; 
23f7			;	;v5 FORTH_DSP_VALUE 
23f7			;	FORTH_DSP_VALUEHL 
23f7			; 
23f7			;	; TODO do string type checks 
23f7			; 
23f7			;;v5	inc hl   ; skip type 
23f7			; 
23f7			;	push hl  ; source code  
23f7			;		if DEBUG_FORTH_WORDS 
23f7			;			DMARK "EX1" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			;	ld a, 0 
23f7			;	call strlent 
23f7			; 
23f7			;	inc hl 
23f7			;	inc hl 
23f7			;	inc hl 
23f7			;	inc hl 
23f7			; 
23f7			;	push hl    ; size 
23f7			; 
23f7			;		if DEBUG_FORTH_WORDS 
23f7			;			DMARK "EX2" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			;	call malloc 
23f7			; 
23f7			;	ex de, hl    ; de now contains malloc area 
23f7			;	pop bc   	; get byte count 
23f7			;	pop hl      ; get string to copy 
23f7			; 
23f7			;	push de     ; save malloc for free later 
23f7			; 
23f7			;		if DEBUG_FORTH_WORDS 
23f7			;			DMARK "EX3" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			;	ldir       ; duplicate string 
23f7			; 
23f7			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
23f7			;	 
23f7			;	; TODO fix the parse would be better than this...  
23f7			;	ex de, hl 
23f7			;	dec hl 
23f7			;	ld a, 0 
23f7			;	ld (hl), a 
23f7			;	dec hl 
23f7			;	ld a, ' ' 
23f7			;	ld (hl), a 
23f7			;	dec hl 
23f7			;	ld (hl), a 
23f7			; 
23f7			;	dec hl 
23f7			;	ld (hl), a 
23f7			; 
23f7			; 
23f7			;	FORTH_DSP_POP  
23f7			; 
23f7			;	pop hl     
23f7			;	push hl    ; save malloc area 
23f7			; 
23f7			;		if DEBUG_FORTH_WORDS 
23f7			;			DMARK "EX4" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			; 
23f7			;	call forthparse 
23f7			;	call forthexec 
23f7			;	 
23f7			;	pop hl 
23f7			;	if DEBUG_FORTH_WORDS 
23f7			;		DMARK "EX5" 
23f7			;		CALLMONITOR 
23f7			;	endif 
23f7			; 
23f7			;	if FORTH_ENABLE_FREE 
23f7			;	call free 
23f7			;	endif 
23f7			; 
23f7			;	if DEBUG_FORTH_WORDS 
23f7			;		DMARK "EX6" 
23f7			;		CALLMONITOR 
23f7			;	endif 
23f7			; 
23f7			;	pop bc 
23f7			;	pop de 
23f7			;	pop hl 
23f7			;;	FORTH_RSP_POP	  
23f7			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
23f7			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
23f7			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
23f7			; 
23f7			;	if DEBUG_FORTH_WORDS 
23f7			;		DMARK "EX7" 
23f7			;		CALLMONITOR 
23f7			;	endif 
23f7			;	NEXTW 
23f7			 
23f7			;.STKEXEC: 
23f7			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
23f7			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
23f7			; 
23f7			; 
23f7			;		if DEBUG_FORTH_WORDS_KEY 
23f7			;			DMARK "STX" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			; 
23f7			;	FORTH_DSP_VALUEHL 
23f7			; 
23f7			;	ld (store_tmp1), hl    ; count 
23f7			; 
23f7			;	FORTH_DSP_POP 
23f7			;.stkexec1: 
23f7			;	ld hl, (store_tmp1)   ; count 
23f7			;	ld a, 0 
23f7			;	cp l 
23f7			;	ret z 
23f7			; 
23f7			;	dec hl 
23f7			;	ld (store_tmp1), hl    ; count 
23f7			;	 
23f7			;	FORTH_DSP_VALUEHL 
23f7			;	push hl 
23f7			;	 
23f7			;		if DEBUG_FORTH_WORDS 
23f7			;			DMARK "EXp" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			;	FORTH_DSP_POP 
23f7			; 
23f7			;	call strlenz 
23f7			;	inc hl   ; include zero term to copy 
23f7			;	inc hl   ; include zero term to copy 
23f7			;	inc hl   ; include zero term to copy 
23f7			;	ld b,0 
23f7			;	ld c,l 
23f7			;	pop hl 
23f7			;	ld de, execscratch 
23f7			;		if DEBUG_FORTH_WORDS 
23f7			;			DMARK "EX3" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			;	ldir 
23f7			; 
23f7			; 
23f7			;	ld hl, execscratch 
23f7			; 
23f7			;		if DEBUG_FORTH_WORDS 
23f7			;			DMARK "EXP" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			; 
23f7			;	call forthparse 
23f7			;	ld hl, execscratch 
23f7			;		if DEBUG_FORTH_WORDS 
23f7			;			DMARK "EXx" 
23f7			;			CALLMONITOR 
23f7			;		endif 
23f7			;	call forthexec 
23f7			; 
23f7			;	jp .stkexec1 
23f7			; 
23f7			;	ret 
23f7			 
23f7			 
23f7			.DUP: 
23f7				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
23f7 17				db WORD_SYS_CORE+OPCODE_DUP             
23f8 6d 24			dw .ZDUP            
23fa 04				db 3 + 1 
23fb .. 00			db "DUP",0              
23ff				endm 
# End of macro CWHEAD
23ff			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
23ff			 
23ff					if DEBUG_FORTH_WORDS_KEY 
23ff						DMARK "DUP" 
23ff f5				push af  
2400 3a 14 24			ld a, (.dmark)  
2403 32 b4 fe			ld (debug_mark),a  
2406 3a 15 24			ld a, (.dmark+1)  
2409 32 b5 fe			ld (debug_mark+1),a  
240c 3a 16 24			ld a, (.dmark+2)  
240f 32 b6 fe			ld (debug_mark+2),a  
2412 18 03			jr .pastdmark  
2414 ..			.dmark: db "DUP"  
2417 f1			.pastdmark: pop af  
2418			endm  
# End of macro DMARK
2418						CALLMONITOR 
2418 cd 7e 18			call break_point_state  
241b				endm  
# End of macro CALLMONITOR
241b					endif 
241b			 
241b					FORTH_DSP 
241b cd af 20			call macro_forth_dsp 
241e				endm 
# End of macro FORTH_DSP
241e			 
241e 7e					ld a, (HL) 
241f fe 01				cp DS_TYPE_STR 
2421 20 25				jr nz, .dupinum 
2423			 
2423					; push another string 
2423			 
2423					FORTH_DSP_VALUEHL     		 
2423 cd e9 20			call macro_dsp_valuehl 
2426				endm 
# End of macro FORTH_DSP_VALUEHL
2426			 
2426				if DEBUG_FORTH_WORDS 
2426					DMARK "DUs" 
2426 f5				push af  
2427 3a 3b 24			ld a, (.dmark)  
242a 32 b4 fe			ld (debug_mark),a  
242d 3a 3c 24			ld a, (.dmark+1)  
2430 32 b5 fe			ld (debug_mark+1),a  
2433 3a 3d 24			ld a, (.dmark+2)  
2436 32 b6 fe			ld (debug_mark+2),a  
2439 18 03			jr .pastdmark  
243b ..			.dmark: db "DUs"  
243e f1			.pastdmark: pop af  
243f			endm  
# End of macro DMARK
243f					CALLMONITOR 
243f cd 7e 18			call break_point_state  
2442				endm  
# End of macro CALLMONITOR
2442				endif 
2442 cd 60 1f				call forth_push_str 
2445			 
2445					NEXTW 
2445 c3 60 22			jp macro_next 
2448				endm 
# End of macro NEXTW
2448			 
2448			 
2448			.dupinum: 
2448					 
2448			 
2448			 
2448					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2448 cd e9 20			call macro_dsp_valuehl 
244b				endm 
# End of macro FORTH_DSP_VALUEHL
244b			 
244b				; TODO add floating point number detection 
244b			 
244b				if DEBUG_FORTH_WORDS 
244b					DMARK "DUi" 
244b f5				push af  
244c 3a 60 24			ld a, (.dmark)  
244f 32 b4 fe			ld (debug_mark),a  
2452 3a 61 24			ld a, (.dmark+1)  
2455 32 b5 fe			ld (debug_mark+1),a  
2458 3a 62 24			ld a, (.dmark+2)  
245b 32 b6 fe			ld (debug_mark+2),a  
245e 18 03			jr .pastdmark  
2460 ..			.dmark: db "DUi"  
2463 f1			.pastdmark: pop af  
2464			endm  
# End of macro DMARK
2464					CALLMONITOR 
2464 cd 7e 18			call break_point_state  
2467				endm  
# End of macro CALLMONITOR
2467				endif 
2467			 
2467 cd f2 1e				call forth_push_numhl 
246a					NEXTW 
246a c3 60 22			jp macro_next 
246d				endm 
# End of macro NEXTW
246d			.ZDUP: 
246d				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
246d 99				db WORD_SYS_CORE+OPCODE_ZDUP             
246e a5 24			dw .SWAP            
2470 05				db 4 + 1 
2471 .. 00			db "?DUP",0              
2476				endm 
# End of macro CWHEAD
2476			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2476			 
2476					if DEBUG_FORTH_WORDS_KEY 
2476						DMARK "qDU" 
2476 f5				push af  
2477 3a 8b 24			ld a, (.dmark)  
247a 32 b4 fe			ld (debug_mark),a  
247d 3a 8c 24			ld a, (.dmark+1)  
2480 32 b5 fe			ld (debug_mark+1),a  
2483 3a 8d 24			ld a, (.dmark+2)  
2486 32 b6 fe			ld (debug_mark+2),a  
2489 18 03			jr .pastdmark  
248b ..			.dmark: db "qDU"  
248e f1			.pastdmark: pop af  
248f			endm  
# End of macro DMARK
248f						CALLMONITOR 
248f cd 7e 18			call break_point_state  
2492				endm  
# End of macro CALLMONITOR
2492					endif 
2492					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2492 cd e9 20			call macro_dsp_valuehl 
2495				endm 
# End of macro FORTH_DSP_VALUEHL
2495			 
2495 e5					push hl 
2496			 
2496					; is it a zero? 
2496			 
2496 3e 00				ld a, 0 
2498 84					add h 
2499 85					add l 
249a			 
249a e1					pop hl 
249b			 
249b fe 00				cp 0 
249d 28 03				jr z, .dup2orig 
249f			 
249f			 
249f cd f2 1e				call forth_push_numhl 
24a2			 
24a2			 
24a2				; TODO add floating point number detection 
24a2			 
24a2			.dup2orig: 
24a2			 
24a2					NEXTW 
24a2 c3 60 22			jp macro_next 
24a5				endm 
# End of macro NEXTW
24a5			.SWAP: 
24a5				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
24a5 18				db WORD_SYS_CORE+OPCODE_SWAP             
24a6 e4 24			dw .COLN            
24a8 05				db 4 + 1 
24a9 .. 00			db "SWAP",0              
24ae				endm 
# End of macro CWHEAD
24ae			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
24ae					if DEBUG_FORTH_WORDS_KEY 
24ae						DMARK "SWP" 
24ae f5				push af  
24af 3a c3 24			ld a, (.dmark)  
24b2 32 b4 fe			ld (debug_mark),a  
24b5 3a c4 24			ld a, (.dmark+1)  
24b8 32 b5 fe			ld (debug_mark+1),a  
24bb 3a c5 24			ld a, (.dmark+2)  
24be 32 b6 fe			ld (debug_mark+2),a  
24c1 18 03			jr .pastdmark  
24c3 ..			.dmark: db "SWP"  
24c6 f1			.pastdmark: pop af  
24c7			endm  
# End of macro DMARK
24c7						CALLMONITOR 
24c7 cd 7e 18			call break_point_state  
24ca				endm  
# End of macro CALLMONITOR
24ca					endif 
24ca			 
24ca					FORTH_DSP_VALUEHL 
24ca cd e9 20			call macro_dsp_valuehl 
24cd				endm 
# End of macro FORTH_DSP_VALUEHL
24cd e5					push hl     ; w2 
24ce			 
24ce					FORTH_DSP_POP 
24ce cd a1 21			call macro_forth_dsp_pop 
24d1				endm 
# End of macro FORTH_DSP_POP
24d1			 
24d1					FORTH_DSP_VALUEHL 
24d1 cd e9 20			call macro_dsp_valuehl 
24d4				endm 
# End of macro FORTH_DSP_VALUEHL
24d4			 
24d4					FORTH_DSP_POP 
24d4 cd a1 21			call macro_forth_dsp_pop 
24d7				endm 
# End of macro FORTH_DSP_POP
24d7			 
24d7 d1					pop de     ; w2	, hl = w1 
24d8			 
24d8 eb					ex de, hl 
24d9 d5					push de 
24da			 
24da cd f2 1e				call forth_push_numhl 
24dd			 
24dd e1					pop hl 
24de			 
24de cd f2 1e				call forth_push_numhl 
24e1					 
24e1			 
24e1					NEXTW 
24e1 c3 60 22			jp macro_next 
24e4				endm 
# End of macro NEXTW
24e4			.COLN: 
24e4				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
24e4 19				db WORD_SYS_CORE+OPCODE_COLN             
24e5 70 26			dw .SCOLN            
24e7 02				db 1 + 1 
24e8 .. 00			db ":",0              
24ea				endm 
# End of macro CWHEAD
24ea			; | : ( -- )         Create new word | DONE 
24ea			 
24ea					if DEBUG_FORTH_WORDS_KEY 
24ea						DMARK "CLN" 
24ea f5				push af  
24eb 3a ff 24			ld a, (.dmark)  
24ee 32 b4 fe			ld (debug_mark),a  
24f1 3a 00 25			ld a, (.dmark+1)  
24f4 32 b5 fe			ld (debug_mark+1),a  
24f7 3a 01 25			ld a, (.dmark+2)  
24fa 32 b6 fe			ld (debug_mark+2),a  
24fd 18 03			jr .pastdmark  
24ff ..			.dmark: db "CLN"  
2502 f1			.pastdmark: pop af  
2503			endm  
# End of macro DMARK
2503						CALLMONITOR 
2503 cd 7e 18			call break_point_state  
2506				endm  
# End of macro CALLMONITOR
2506					endif 
2506				STACKFRAME OFF $8efe $989f 
2506				if DEBUG_STACK_IMB 
2506					if OFF 
2506						exx 
2506						ld de, $8efe 
2506						ld a, d 
2506						ld hl, curframe 
2506						call hexout 
2506						ld a, e 
2506						ld hl, curframe+2 
2506						call hexout 
2506						ld hl, $8efe 
2506						push hl 
2506						ld hl, $989f 
2506						push hl 
2506						exx 
2506					endif 
2506				endif 
2506			endm 
# End of macro STACKFRAME
2506				; get parser buffer length  of new word 
2506			 
2506				 
2506			 
2506					; move tok past this to start of name defintition 
2506					; TODO get word to define 
2506					; TODO Move past word token 
2506					; TODO get length of string up to the ';' 
2506			 
2506 2a 84 f6			ld hl, (os_tok_ptr) 
2509 23				inc hl 
250a 23				inc hl 
250b			 
250b 3e 3b			ld a, ';' 
250d cd 6a 13			call strlent 
2510			 
2510 7d				ld a,l 
2511 32 7f f3			ld (os_new_parse_len), a 
2514			 
2514			 
2514			if DEBUG_FORTH_UWORD 
2514 ed 5b 84 f6		ld de, (os_tok_ptr) 
2518						DMARK ":01" 
2518 f5				push af  
2519 3a 2d 25			ld a, (.dmark)  
251c 32 b4 fe			ld (debug_mark),a  
251f 3a 2e 25			ld a, (.dmark+1)  
2522 32 b5 fe			ld (debug_mark+1),a  
2525 3a 2f 25			ld a, (.dmark+2)  
2528 32 b6 fe			ld (debug_mark+2),a  
252b 18 03			jr .pastdmark  
252d ..			.dmark: db ":01"  
2530 f1			.pastdmark: pop af  
2531			endm  
# End of macro DMARK
2531				CALLMONITOR 
2531 cd 7e 18			call break_point_state  
2534				endm  
# End of macro CALLMONITOR
2534			endif 
2534			 
2534			; 
2534			;  new word memory layout: 
2534			;  
2534			;    : adg 6666 ;  
2534			; 
2534			;    db   1     ; user defined word  
2534 23				inc hl    
2535			;    dw   sysdict 
2535 23				inc hl 
2536 23				inc hl 
2537			;    db <word len>+1 (for null) 
2537 23				inc hl 
2538			;    db .... <word> 
2538			; 
2538			 
2538 23				inc hl    ; some extras for the word preamble before the above 
2539 23				inc hl 
253a 23				inc hl 
253b 23				inc hl 
253c 23				inc hl 
253d 23				inc hl 
253e 23				inc hl  
253f 23				inc hl 
2540 23				inc hl 
2541 23				inc hl 
2542 23				inc hl 
2543 23				inc hl 
2544 23				inc hl 
2545 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2546			;       exec word buffer 
2546			;	<ptr word>   
2546 23				inc hl 
2547 23				inc hl 
2548			;       <word list><null term> 7F final term 
2548			 
2548			 
2548			if DEBUG_FORTH_UWORD 
2548						DMARK ":02" 
2548 f5				push af  
2549 3a 5d 25			ld a, (.dmark)  
254c 32 b4 fe			ld (debug_mark),a  
254f 3a 5e 25			ld a, (.dmark+1)  
2552 32 b5 fe			ld (debug_mark+1),a  
2555 3a 5f 25			ld a, (.dmark+2)  
2558 32 b6 fe			ld (debug_mark+2),a  
255b 18 03			jr .pastdmark  
255d ..			.dmark: db ":02"  
2560 f1			.pastdmark: pop af  
2561			endm  
# End of macro DMARK
2561				CALLMONITOR 
2561 cd 7e 18			call break_point_state  
2564				endm  
# End of macro CALLMONITOR
2564			endif 
2564			 
2564				 
2564					; malloc the size 
2564			 
2564 cd c8 13				call malloc 
2567 22 81 f3				ld (os_new_malloc), hl     ; save malloc start 
256a			 
256a			;    db   1     ; user defined word  
256a 3e 01				ld a, WORD_SYS_UWORD  
256c 77					ld (hl), a 
256d				 
256d 23				inc hl    
256e			;    dw   sysdict 
256e 11 b8 23			ld de, sysdict       ; continue on with the scan to the system dict 
2571 73				ld (hl), e 
2572 23				inc hl 
2573 72				ld (hl), d 
2574 23				inc hl 
2575			 
2575			 
2575			;    Setup dict word 
2575			 
2575 23				inc hl 
2576 22 7b f3			ld (os_new_work_ptr), hl     ; save start of dict word  
2579			 
2579				; 1. get length of dict word 
2579			 
2579			 
2579 2a 84 f6			ld hl, (os_tok_ptr) 
257c 23				inc hl 
257d 23				inc hl    ; position to start of dict word 
257e 3e 00			ld a, 0 
2580 cd 6a 13			call strlent 
2583			 
2583			 
2583 23				inc hl    ; to include null??? 
2584			 
2584				; write length of dict word 
2584			 
2584 ed 5b 7b f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2588 1b				dec de 
2589 eb				ex de, hl 
258a 73				ld (hl), e 
258b eb				ex de, hl 
258c			 
258c				 
258c			 
258c				; copy  
258c 4d				ld c, l 
258d 06 00			ld b, 0 
258f ed 5b 7b f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2593 2a 84 f6			ld hl, (os_tok_ptr) 
2596 23				inc hl 
2597 23				inc hl    ; position to start of dict word 
2598				 
2598			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2598				 
2598				; TODO need to convert word to upper case 
2598			 
2598			ucasetok:	 
2598 7e				ld a,(hl) 
2599 cd 56 13			call toUpper 
259c 77				ld (hl),a 
259d ed a0			ldi 
259f f2 98 25		 	jp p, ucasetok 
25a2			 
25a2			 
25a2			 
25a2				; de now points to start of where the word body code should be placed 
25a2 ed 53 7b f3		ld (os_new_work_ptr), de 
25a6				; hl now points to the words to throw at forthexec which needs to be copied 
25a6 22 79 f3			ld (os_new_src_ptr), hl 
25a9			 
25a9				; TODO add 'call to forthexec' 
25a9			 
25a9			if DEBUG_FORTH_UWORD 
25a9 c5				push bc 
25aa ed 4b 81 f3		ld bc, (os_new_malloc) 
25ae						DMARK ":0x" 
25ae f5				push af  
25af 3a c3 25			ld a, (.dmark)  
25b2 32 b4 fe			ld (debug_mark),a  
25b5 3a c4 25			ld a, (.dmark+1)  
25b8 32 b5 fe			ld (debug_mark+1),a  
25bb 3a c5 25			ld a, (.dmark+2)  
25be 32 b6 fe			ld (debug_mark+2),a  
25c1 18 03			jr .pastdmark  
25c3 ..			.dmark: db ":0x"  
25c6 f1			.pastdmark: pop af  
25c7			endm  
# End of macro DMARK
25c7				CALLMONITOR 
25c7 cd 7e 18			call break_point_state  
25ca				endm  
# End of macro CALLMONITOR
25ca c1				pop bc 
25cb			endif 
25cb			 
25cb			 
25cb				; create word preamble which should be: 
25cb			 
25cb			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
25cb			 
25cb				;    ld hl, <word code> 
25cb				;    jp user_exec 
25cb			        ;    <word code bytes> 
25cb			 
25cb			 
25cb			;	inc de     ; TODO ??? or are we already past the word's null 
25cb eb				ex de, hl 
25cc			 
25cc 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
25ce			 
25ce 23				inc hl 
25cf 22 75 f3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
25d2 23				inc hl 
25d3			 
25d3 23				inc hl 
25d4 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
25d6			 
25d6 01 7f 54			ld bc, user_exec 
25d9 23				inc hl 
25da 71				ld (hl), c     ; poke address of user_exec 
25db 23				inc hl 
25dc 70				ld (hl), b     
25dd			 ; 
25dd			;	inc hl 
25dd			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
25dd			; 
25dd			; 
25dd			;	ld bc, macro_forth_rsp_next 
25dd			;	inc hl 
25dd			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
25dd			;	inc hl 
25dd			;	ld (hl), b     
25dd			 ; 
25dd			;	inc hl 
25dd			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
25dd			; 
25dd			; 
25dd			;	inc hl 
25dd			;	ld bc, forthexec 
25dd			;	ld (hl), c     ; poke address of forthexec 
25dd			;	inc hl 
25dd			;	ld (hl), b      
25dd			; 
25dd			;	inc hl 
25dd			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
25dd			; 
25dd			;	ld bc, user_dict_next 
25dd			;	inc hl 
25dd			;	ld (hl), c     ; poke address of forthexec 
25dd			;	inc hl 
25dd			;	ld (hl), b      
25dd			 
25dd				; hl is now where we need to copy the word byte data to save this 
25dd			 
25dd 23				inc hl 
25de 22 77 f3			ld (os_new_exec), hl 
25e1				 
25e1				; copy definition 
25e1			 
25e1 eb				ex de, hl 
25e2			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
25e2			;	inc de    ; skip the PC for this parse 
25e2 3a 7f f3			ld a, (os_new_parse_len) 
25e5 4f				ld c, a 
25e6 06 00			ld b, 0 
25e8 ed b0			ldir		 ; copy defintion 
25ea			 
25ea			 
25ea				; poke the address of where the new word bytes live for forthexec 
25ea			 
25ea 2a 75 f3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
25ed			 
25ed ed 5b 77 f3		ld de, (os_new_exec)      
25f1				 
25f1 73				ld (hl), e 
25f2 23				inc hl 
25f3 72				ld (hl), d 
25f4			 
25f4					; TODO copy last user dict word next link to this word 
25f4					; TODO update last user dict word to point to this word 
25f4			; 
25f4			; hl f923 de 812a ; bc 811a 
25f4			 
25f4			if DEBUG_FORTH_UWORD 
25f4 c5				push bc 
25f5 ed 4b 81 f3		ld bc, (os_new_malloc) 
25f9						DMARK ":0A" 
25f9 f5				push af  
25fa 3a 0e 26			ld a, (.dmark)  
25fd 32 b4 fe			ld (debug_mark),a  
2600 3a 0f 26			ld a, (.dmark+1)  
2603 32 b5 fe			ld (debug_mark+1),a  
2606 3a 10 26			ld a, (.dmark+2)  
2609 32 b6 fe			ld (debug_mark+2),a  
260c 18 03			jr .pastdmark  
260e ..			.dmark: db ":0A"  
2611 f1			.pastdmark: pop af  
2612			endm  
# End of macro DMARK
2612				CALLMONITOR 
2612 cd 7e 18			call break_point_state  
2615				endm  
# End of macro CALLMONITOR
2615 c1				pop bc 
2616			endif 
2616			if DEBUG_FORTH_UWORD 
2616 c5				push bc 
2617 ed 4b 81 f3		ld bc, (os_new_malloc) 
261b 03				inc bc 
261c 03				inc bc 
261d 03				inc bc 
261e 03				inc bc 
261f 03				inc bc 
2620 03				inc bc 
2621 03				inc bc 
2622 03				inc bc 
2623			 
2623						DMARK ":0B" 
2623 f5				push af  
2624 3a 38 26			ld a, (.dmark)  
2627 32 b4 fe			ld (debug_mark),a  
262a 3a 39 26			ld a, (.dmark+1)  
262d 32 b5 fe			ld (debug_mark+1),a  
2630 3a 3a 26			ld a, (.dmark+2)  
2633 32 b6 fe			ld (debug_mark+2),a  
2636 18 03			jr .pastdmark  
2638 ..			.dmark: db ":0B"  
263b f1			.pastdmark: pop af  
263c			endm  
# End of macro DMARK
263c				CALLMONITOR 
263c cd 7e 18			call break_point_state  
263f				endm  
# End of macro CALLMONITOR
263f c1				pop bc 
2640			endif 
2640			 
2640			; update word dict linked list for new word 
2640			 
2640			 
2640 2a 80 f6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2643 23			inc hl     ; move to next work linked list ptr 
2644			 
2644 ed 5b 81 f3	ld de, (os_new_malloc)		 ; new next word 
2648 73			ld (hl), e 
2649 23			inc hl 
264a 72			ld (hl), d 
264b			 
264b			if DEBUG_FORTH_UWORD 
264b ed 4b 80 f6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
264f			endif 
264f			 
264f ed 53 80 f6	ld (os_last_new_uword), de      ; update last new uword ptr 
2653			 
2653			 
2653			if DEBUG_FORTH_UWORD 
2653						DMARK ":0+" 
2653 f5				push af  
2654 3a 68 26			ld a, (.dmark)  
2657 32 b4 fe			ld (debug_mark),a  
265a 3a 69 26			ld a, (.dmark+1)  
265d 32 b5 fe			ld (debug_mark+1),a  
2660 3a 6a 26			ld a, (.dmark+2)  
2663 32 b6 fe			ld (debug_mark+2),a  
2666 18 03			jr .pastdmark  
2668 ..			.dmark: db ":0+"  
266b f1			.pastdmark: pop af  
266c			endm  
# End of macro DMARK
266c				CALLMONITOR 
266c cd 7e 18			call break_point_state  
266f				endm  
# End of macro CALLMONITOR
266f			endif 
266f			 
266f				STACKFRAMECHK OFF $8efe $989f 
266f				if DEBUG_STACK_IMB 
266f					if OFF 
266f						exx 
266f						ld hl, $989f 
266f						pop de   ; $989f 
266f						call cmp16 
266f						jr nz, .spnosame 
266f						ld hl, $8efe 
266f						pop de   ; $8efe 
266f						call cmp16 
266f						jr z, .spfrsame 
266f						.spnosame: call showsperror 
266f						.spfrsame: nop 
266f						exx 
266f					endif 
266f				endif 
266f			endm 
# End of macro STACKFRAMECHK
266f			 
266f c9			ret    ; dont process any remaining parser tokens as they form new word 
2670			 
2670			 
2670			 
2670			 
2670			;		NEXT 
2670			.SCOLN: 
2670			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2670 06				db OPCODE_SCOLN 
2671 bc 26			dw .DROP 
2673 02				db 2 
2674 .. 00			db ";",0           
2676			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2676					if DEBUG_FORTH_WORDS_KEY 
2676						DMARK "SCN" 
2676 f5				push af  
2677 3a 8b 26			ld a, (.dmark)  
267a 32 b4 fe			ld (debug_mark),a  
267d 3a 8c 26			ld a, (.dmark+1)  
2680 32 b5 fe			ld (debug_mark+1),a  
2683 3a 8d 26			ld a, (.dmark+2)  
2686 32 b6 fe			ld (debug_mark+2),a  
2689 18 03			jr .pastdmark  
268b ..			.dmark: db "SCN"  
268e f1			.pastdmark: pop af  
268f			endm  
# End of macro DMARK
268f						CALLMONITOR 
268f cd 7e 18			call break_point_state  
2692				endm  
# End of macro CALLMONITOR
2692					endif 
2692					FORTH_RSP_TOS 
2692 cd b0 1e			call macro_forth_rsp_tos 
2695				endm 
# End of macro FORTH_RSP_TOS
2695 e5					push hl 
2696					FORTH_RSP_POP 
2696 cd ba 1e			call macro_forth_rsp_pop 
2699				endm 
# End of macro FORTH_RSP_POP
2699 e1					pop hl 
269a			;		ex de,hl 
269a 22 84 f6				ld (os_tok_ptr),hl 
269d			 
269d			if DEBUG_FORTH_UWORD 
269d						DMARK "SCL" 
269d f5				push af  
269e 3a b2 26			ld a, (.dmark)  
26a1 32 b4 fe			ld (debug_mark),a  
26a4 3a b3 26			ld a, (.dmark+1)  
26a7 32 b5 fe			ld (debug_mark+1),a  
26aa 3a b4 26			ld a, (.dmark+2)  
26ad 32 b6 fe			ld (debug_mark+2),a  
26b0 18 03			jr .pastdmark  
26b2 ..			.dmark: db "SCL"  
26b5 f1			.pastdmark: pop af  
26b6			endm  
# End of macro DMARK
26b6				CALLMONITOR 
26b6 cd 7e 18			call break_point_state  
26b9				endm  
# End of macro CALLMONITOR
26b9			endif 
26b9					NEXTW 
26b9 c3 60 22			jp macro_next 
26bc				endm 
# End of macro NEXTW
26bc			 
26bc			.DROP: 
26bc				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
26bc 1b				db WORD_SYS_CORE+OPCODE_DROP             
26bd e7 26			dw .DUP2            
26bf 05				db 4 + 1 
26c0 .. 00			db "DROP",0              
26c5				endm 
# End of macro CWHEAD
26c5			; | DROP ( w -- )   drop the TOS item   | DONE 
26c5					if DEBUG_FORTH_WORDS_KEY 
26c5						DMARK "DRP" 
26c5 f5				push af  
26c6 3a da 26			ld a, (.dmark)  
26c9 32 b4 fe			ld (debug_mark),a  
26cc 3a db 26			ld a, (.dmark+1)  
26cf 32 b5 fe			ld (debug_mark+1),a  
26d2 3a dc 26			ld a, (.dmark+2)  
26d5 32 b6 fe			ld (debug_mark+2),a  
26d8 18 03			jr .pastdmark  
26da ..			.dmark: db "DRP"  
26dd f1			.pastdmark: pop af  
26de			endm  
# End of macro DMARK
26de						CALLMONITOR 
26de cd 7e 18			call break_point_state  
26e1				endm  
# End of macro CALLMONITOR
26e1					endif 
26e1					FORTH_DSP_POP 
26e1 cd a1 21			call macro_forth_dsp_pop 
26e4				endm 
# End of macro FORTH_DSP_POP
26e4					NEXTW 
26e4 c3 60 22			jp macro_next 
26e7				endm 
# End of macro NEXTW
26e7			.DUP2: 
26e7				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
26e7 1c				db WORD_SYS_CORE+OPCODE_DUP2             
26e8 2c 27			dw .DROP2            
26ea 05				db 4 + 1 
26eb .. 00			db "2DUP",0              
26f0				endm 
# End of macro CWHEAD
26f0			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
26f0					if DEBUG_FORTH_WORDS_KEY 
26f0						DMARK "2DU" 
26f0 f5				push af  
26f1 3a 05 27			ld a, (.dmark)  
26f4 32 b4 fe			ld (debug_mark),a  
26f7 3a 06 27			ld a, (.dmark+1)  
26fa 32 b5 fe			ld (debug_mark+1),a  
26fd 3a 07 27			ld a, (.dmark+2)  
2700 32 b6 fe			ld (debug_mark+2),a  
2703 18 03			jr .pastdmark  
2705 ..			.dmark: db "2DU"  
2708 f1			.pastdmark: pop af  
2709			endm  
# End of macro DMARK
2709						CALLMONITOR 
2709 cd 7e 18			call break_point_state  
270c				endm  
# End of macro CALLMONITOR
270c					endif 
270c					FORTH_DSP_VALUEHL 
270c cd e9 20			call macro_dsp_valuehl 
270f				endm 
# End of macro FORTH_DSP_VALUEHL
270f e5					push hl      ; 2 
2710			 
2710					FORTH_DSP_POP 
2710 cd a1 21			call macro_forth_dsp_pop 
2713				endm 
# End of macro FORTH_DSP_POP
2713					 
2713					FORTH_DSP_VALUEHL 
2713 cd e9 20			call macro_dsp_valuehl 
2716				endm 
# End of macro FORTH_DSP_VALUEHL
2716			;		push hl      ; 1 
2716			 
2716					FORTH_DSP_POP 
2716 cd a1 21			call macro_forth_dsp_pop 
2719				endm 
# End of macro FORTH_DSP_POP
2719			 
2719			;		pop hl       ; 1 
2719 d1					pop de       ; 2 
271a			 
271a cd f2 1e				call forth_push_numhl 
271d eb					ex de, hl 
271e cd f2 1e				call forth_push_numhl 
2721			 
2721					 
2721 eb					ex de, hl 
2722			 
2722 cd f2 1e				call forth_push_numhl 
2725 eb					ex de, hl 
2726 cd f2 1e				call forth_push_numhl 
2729			 
2729			 
2729					NEXTW 
2729 c3 60 22			jp macro_next 
272c				endm 
# End of macro NEXTW
272c			.DROP2: 
272c				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
272c 1d				db WORD_SYS_CORE+OPCODE_DROP2             
272d 5b 27			dw .SWAP2            
272f 06				db 5 + 1 
2730 .. 00			db "2DROP",0              
2736				endm 
# End of macro CWHEAD
2736			; | 2DROP ( w w -- )    Double drop | DONE 
2736					if DEBUG_FORTH_WORDS_KEY 
2736						DMARK "2DR" 
2736 f5				push af  
2737 3a 4b 27			ld a, (.dmark)  
273a 32 b4 fe			ld (debug_mark),a  
273d 3a 4c 27			ld a, (.dmark+1)  
2740 32 b5 fe			ld (debug_mark+1),a  
2743 3a 4d 27			ld a, (.dmark+2)  
2746 32 b6 fe			ld (debug_mark+2),a  
2749 18 03			jr .pastdmark  
274b ..			.dmark: db "2DR"  
274e f1			.pastdmark: pop af  
274f			endm  
# End of macro DMARK
274f						CALLMONITOR 
274f cd 7e 18			call break_point_state  
2752				endm  
# End of macro CALLMONITOR
2752					endif 
2752					FORTH_DSP_POP 
2752 cd a1 21			call macro_forth_dsp_pop 
2755				endm 
# End of macro FORTH_DSP_POP
2755					FORTH_DSP_POP 
2755 cd a1 21			call macro_forth_dsp_pop 
2758				endm 
# End of macro FORTH_DSP_POP
2758					NEXTW 
2758 c3 60 22			jp macro_next 
275b				endm 
# End of macro NEXTW
275b			.SWAP2: 
275b				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
275b 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
275c 84 27			dw .AT            
275e 06				db 5 + 1 
275f .. 00			db "2SWAP",0              
2765				endm 
# End of macro CWHEAD
2765			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2765					if DEBUG_FORTH_WORDS_KEY 
2765						DMARK "2SW" 
2765 f5				push af  
2766 3a 7a 27			ld a, (.dmark)  
2769 32 b4 fe			ld (debug_mark),a  
276c 3a 7b 27			ld a, (.dmark+1)  
276f 32 b5 fe			ld (debug_mark+1),a  
2772 3a 7c 27			ld a, (.dmark+2)  
2775 32 b6 fe			ld (debug_mark+2),a  
2778 18 03			jr .pastdmark  
277a ..			.dmark: db "2SW"  
277d f1			.pastdmark: pop af  
277e			endm  
# End of macro DMARK
277e						CALLMONITOR 
277e cd 7e 18			call break_point_state  
2781				endm  
# End of macro CALLMONITOR
2781					endif 
2781					NEXTW 
2781 c3 60 22			jp macro_next 
2784				endm 
# End of macro NEXTW
2784			.AT: 
2784				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2784 1f				db WORD_SYS_CORE+OPCODE_AT             
2785 b6 27			dw .CAT            
2787 02				db 1 + 1 
2788 .. 00			db "@",0              
278a				endm 
# End of macro CWHEAD
278a			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
278a			 
278a					if DEBUG_FORTH_WORDS_KEY 
278a						DMARK "AT." 
278a f5				push af  
278b 3a 9f 27			ld a, (.dmark)  
278e 32 b4 fe			ld (debug_mark),a  
2791 3a a0 27			ld a, (.dmark+1)  
2794 32 b5 fe			ld (debug_mark+1),a  
2797 3a a1 27			ld a, (.dmark+2)  
279a 32 b6 fe			ld (debug_mark+2),a  
279d 18 03			jr .pastdmark  
279f ..			.dmark: db "AT."  
27a2 f1			.pastdmark: pop af  
27a3			endm  
# End of macro DMARK
27a3						CALLMONITOR 
27a3 cd 7e 18			call break_point_state  
27a6				endm  
# End of macro CALLMONITOR
27a6					endif 
27a6			.getbyteat:	 
27a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27a6 cd e9 20			call macro_dsp_valuehl 
27a9				endm 
# End of macro FORTH_DSP_VALUEHL
27a9					 
27a9			;		push hl 
27a9				 
27a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27a9 cd a1 21			call macro_forth_dsp_pop 
27ac				endm 
# End of macro FORTH_DSP_POP
27ac			 
27ac			;		pop hl 
27ac			 
27ac 7e					ld a, (hl) 
27ad			 
27ad 6f					ld l, a 
27ae 26 00				ld h, 0 
27b0 cd f2 1e				call forth_push_numhl 
27b3			 
27b3					NEXTW 
27b3 c3 60 22			jp macro_next 
27b6				endm 
# End of macro NEXTW
27b6			.CAT: 
27b6				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
27b6 20				db WORD_SYS_CORE+OPCODE_CAT             
27b7 df 27			dw .BANG            
27b9 03				db 2 + 1 
27ba .. 00			db "C@",0              
27bd				endm 
# End of macro CWHEAD
27bd			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
27bd					if DEBUG_FORTH_WORDS_KEY 
27bd						DMARK "CAA" 
27bd f5				push af  
27be 3a d2 27			ld a, (.dmark)  
27c1 32 b4 fe			ld (debug_mark),a  
27c4 3a d3 27			ld a, (.dmark+1)  
27c7 32 b5 fe			ld (debug_mark+1),a  
27ca 3a d4 27			ld a, (.dmark+2)  
27cd 32 b6 fe			ld (debug_mark+2),a  
27d0 18 03			jr .pastdmark  
27d2 ..			.dmark: db "CAA"  
27d5 f1			.pastdmark: pop af  
27d6			endm  
# End of macro DMARK
27d6						CALLMONITOR 
27d6 cd 7e 18			call break_point_state  
27d9				endm  
# End of macro CALLMONITOR
27d9					endif 
27d9 c3 a6 27				jp .getbyteat 
27dc					NEXTW 
27dc c3 60 22			jp macro_next 
27df				endm 
# End of macro NEXTW
27df			.BANG: 
27df				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
27df 21				db WORD_SYS_CORE+OPCODE_BANG             
27e0 15 28			dw .CBANG            
27e2 02				db 1 + 1 
27e3 .. 00			db "!",0              
27e5				endm 
# End of macro CWHEAD
27e5			; | ! ( x w -- ) Store x at address w      | DONE 
27e5					if DEBUG_FORTH_WORDS_KEY 
27e5						DMARK "BNG" 
27e5 f5				push af  
27e6 3a fa 27			ld a, (.dmark)  
27e9 32 b4 fe			ld (debug_mark),a  
27ec 3a fb 27			ld a, (.dmark+1)  
27ef 32 b5 fe			ld (debug_mark+1),a  
27f2 3a fc 27			ld a, (.dmark+2)  
27f5 32 b6 fe			ld (debug_mark+2),a  
27f8 18 03			jr .pastdmark  
27fa ..			.dmark: db "BNG"  
27fd f1			.pastdmark: pop af  
27fe			endm  
# End of macro DMARK
27fe						CALLMONITOR 
27fe cd 7e 18			call break_point_state  
2801				endm  
# End of macro CALLMONITOR
2801					endif 
2801			 
2801			.storebyteat:		 
2801					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2801 cd e9 20			call macro_dsp_valuehl 
2804				endm 
# End of macro FORTH_DSP_VALUEHL
2804					 
2804 e5					push hl 
2805				 
2805					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2805 cd a1 21			call macro_forth_dsp_pop 
2808				endm 
# End of macro FORTH_DSP_POP
2808			 
2808					; get byte to poke 
2808			 
2808					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2808 cd e9 20			call macro_dsp_valuehl 
280b				endm 
# End of macro FORTH_DSP_VALUEHL
280b e5					push hl 
280c			 
280c			 
280c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
280c cd a1 21			call macro_forth_dsp_pop 
280f				endm 
# End of macro FORTH_DSP_POP
280f			 
280f			 
280f d1					pop de 
2810 e1					pop hl 
2811			 
2811 73					ld (hl),e 
2812			 
2812			 
2812					NEXTW 
2812 c3 60 22			jp macro_next 
2815				endm 
# End of macro NEXTW
2815			.CBANG: 
2815				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2815 22				db WORD_SYS_CORE+OPCODE_CBANG             
2816 3e 28			dw .SCALL            
2818 03				db 2 + 1 
2819 .. 00			db "C!",0              
281c				endm 
# End of macro CWHEAD
281c			; | C!  ( x w -- ) Store x at address w  | DONE 
281c					if DEBUG_FORTH_WORDS_KEY 
281c						DMARK "CBA" 
281c f5				push af  
281d 3a 31 28			ld a, (.dmark)  
2820 32 b4 fe			ld (debug_mark),a  
2823 3a 32 28			ld a, (.dmark+1)  
2826 32 b5 fe			ld (debug_mark+1),a  
2829 3a 33 28			ld a, (.dmark+2)  
282c 32 b6 fe			ld (debug_mark+2),a  
282f 18 03			jr .pastdmark  
2831 ..			.dmark: db "CBA"  
2834 f1			.pastdmark: pop af  
2835			endm  
# End of macro DMARK
2835						CALLMONITOR 
2835 cd 7e 18			call break_point_state  
2838				endm  
# End of macro CALLMONITOR
2838					endif 
2838 c3 01 28				jp .storebyteat 
283b					NEXTW 
283b c3 60 22			jp macro_next 
283e				endm 
# End of macro NEXTW
283e			.SCALL: 
283e				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
283e 23				db WORD_SYS_CORE+OPCODE_SCALL             
283f 72 28			dw .DEPTH            
2841 05				db 4 + 1 
2842 .. 00			db "CALL",0              
2847				endm 
# End of macro CWHEAD
2847			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2847					if DEBUG_FORTH_WORDS_KEY 
2847						DMARK "CLL" 
2847 f5				push af  
2848 3a 5c 28			ld a, (.dmark)  
284b 32 b4 fe			ld (debug_mark),a  
284e 3a 5d 28			ld a, (.dmark+1)  
2851 32 b5 fe			ld (debug_mark+1),a  
2854 3a 5e 28			ld a, (.dmark+2)  
2857 32 b6 fe			ld (debug_mark+2),a  
285a 18 03			jr .pastdmark  
285c ..			.dmark: db "CLL"  
285f f1			.pastdmark: pop af  
2860			endm  
# End of macro DMARK
2860						CALLMONITOR 
2860 cd 7e 18			call break_point_state  
2863				endm  
# End of macro CALLMONITOR
2863					endif 
2863			 
2863					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2863 cd e9 20			call macro_dsp_valuehl 
2866				endm 
# End of macro FORTH_DSP_VALUEHL
2866			 
2866			;		push hl 
2866			 
2866					; destroy value TOS 
2866			 
2866					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2866 cd a1 21			call macro_forth_dsp_pop 
2869				endm 
# End of macro FORTH_DSP_POP
2869			 
2869						 
2869			;		pop hl 
2869			 
2869					; how to do a call with hl???? save SP? 
2869 cd 04 22				call forth_call_hl 
286c			 
286c			 
286c					; TODO push value back onto stack for another op etc 
286c			 
286c cd f2 1e				call forth_push_numhl 
286f					NEXTW 
286f c3 60 22			jp macro_next 
2872				endm 
# End of macro NEXTW
2872			.DEPTH: 
2872				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2872 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2873 af 28			dw .OVER            
2875 06				db 5 + 1 
2876 .. 00			db "DEPTH",0              
287c				endm 
# End of macro CWHEAD
287c			; | DEPTH ( -- u ) Push count of stack | DONE 
287c					; take current TOS and remove from base value div by two to get count 
287c					if DEBUG_FORTH_WORDS_KEY 
287c						DMARK "DEP" 
287c f5				push af  
287d 3a 91 28			ld a, (.dmark)  
2880 32 b4 fe			ld (debug_mark),a  
2883 3a 92 28			ld a, (.dmark+1)  
2886 32 b5 fe			ld (debug_mark+1),a  
2889 3a 93 28			ld a, (.dmark+2)  
288c 32 b6 fe			ld (debug_mark+2),a  
288f 18 03			jr .pastdmark  
2891 ..			.dmark: db "DEP"  
2894 f1			.pastdmark: pop af  
2895			endm  
# End of macro DMARK
2895						CALLMONITOR 
2895 cd 7e 18			call break_point_state  
2898				endm  
# End of macro CALLMONITOR
2898					endif 
2898			 
2898			 
2898 2a b0 fb			ld hl, (cli_data_sp) 
289b 11 ea f8			ld de, cli_data_stack 
289e ed 52			sbc hl,de 
28a0				 
28a0				; div by size of stack item 
28a0			 
28a0 5d				ld e,l 
28a1 0e 03			ld c, 3 
28a3 cd 91 0e			call Div8 
28a6			 
28a6 6f				ld l,a 
28a7 26 00			ld h,0 
28a9			 
28a9				;srl h 
28a9				;rr l 
28a9			 
28a9 cd f2 1e				call forth_push_numhl 
28ac					NEXTW 
28ac c3 60 22			jp macro_next 
28af				endm 
# End of macro NEXTW
28af			.OVER: 
28af				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
28af 42				db WORD_SYS_CORE+46             
28b0 f6 28			dw .PAUSE            
28b2 05				db 4 + 1 
28b3 .. 00			db "OVER",0              
28b8				endm 
# End of macro CWHEAD
28b8			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
28b8					if DEBUG_FORTH_WORDS_KEY 
28b8						DMARK "OVR" 
28b8 f5				push af  
28b9 3a cd 28			ld a, (.dmark)  
28bc 32 b4 fe			ld (debug_mark),a  
28bf 3a ce 28			ld a, (.dmark+1)  
28c2 32 b5 fe			ld (debug_mark+1),a  
28c5 3a cf 28			ld a, (.dmark+2)  
28c8 32 b6 fe			ld (debug_mark+2),a  
28cb 18 03			jr .pastdmark  
28cd ..			.dmark: db "OVR"  
28d0 f1			.pastdmark: pop af  
28d1			endm  
# End of macro DMARK
28d1						CALLMONITOR 
28d1 cd 7e 18			call break_point_state  
28d4				endm  
# End of macro CALLMONITOR
28d4					endif 
28d4			 
28d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28d4 cd e9 20			call macro_dsp_valuehl 
28d7				endm 
# End of macro FORTH_DSP_VALUEHL
28d7 e5					push hl    ; n2 
28d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28d8 cd a1 21			call macro_forth_dsp_pop 
28db				endm 
# End of macro FORTH_DSP_POP
28db			 
28db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28db cd e9 20			call macro_dsp_valuehl 
28de				endm 
# End of macro FORTH_DSP_VALUEHL
28de e5					push hl    ; n1 
28df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28df cd a1 21			call macro_forth_dsp_pop 
28e2				endm 
# End of macro FORTH_DSP_POP
28e2			 
28e2 d1					pop de     ; n1 
28e3 e1					pop hl     ; n2 
28e4			 
28e4 d5					push de 
28e5 e5					push hl 
28e6 d5					push de 
28e7			 
28e7					; push back  
28e7			 
28e7 e1					pop hl 
28e8 cd f2 1e				call forth_push_numhl 
28eb e1					pop hl 
28ec cd f2 1e				call forth_push_numhl 
28ef e1					pop hl 
28f0 cd f2 1e				call forth_push_numhl 
28f3					NEXTW 
28f3 c3 60 22			jp macro_next 
28f6				endm 
# End of macro NEXTW
28f6			 
28f6			.PAUSE: 
28f6				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
28f6 43				db WORD_SYS_CORE+47             
28f7 2b 29			dw .PAUSES            
28f9 08				db 7 + 1 
28fa .. 00			db "PAUSEMS",0              
2902				endm 
# End of macro CWHEAD
2902			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2902					if DEBUG_FORTH_WORDS_KEY 
2902						DMARK "PMS" 
2902 f5				push af  
2903 3a 17 29			ld a, (.dmark)  
2906 32 b4 fe			ld (debug_mark),a  
2909 3a 18 29			ld a, (.dmark+1)  
290c 32 b5 fe			ld (debug_mark+1),a  
290f 3a 19 29			ld a, (.dmark+2)  
2912 32 b6 fe			ld (debug_mark+2),a  
2915 18 03			jr .pastdmark  
2917 ..			.dmark: db "PMS"  
291a f1			.pastdmark: pop af  
291b			endm  
# End of macro DMARK
291b						CALLMONITOR 
291b cd 7e 18			call break_point_state  
291e				endm  
# End of macro CALLMONITOR
291e					endif 
291e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
291e cd e9 20			call macro_dsp_valuehl 
2921				endm 
# End of macro FORTH_DSP_VALUEHL
2921			;		push hl    ; n2 
2921					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2921 cd a1 21			call macro_forth_dsp_pop 
2924				endm 
# End of macro FORTH_DSP_POP
2924			;		pop hl 
2924			 
2924 7d					ld a, l 
2925 cd 2f 0c				call aDelayInMS 
2928				       NEXTW 
2928 c3 60 22			jp macro_next 
292b				endm 
# End of macro NEXTW
292b			.PAUSES:  
292b				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
292b 44				db WORD_SYS_CORE+48             
292c 9a 29			dw .ROT            
292e 06				db 5 + 1 
292f .. 00			db "PAUSE",0              
2935				endm 
# End of macro CWHEAD
2935			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2935					if DEBUG_FORTH_WORDS_KEY 
2935						DMARK "PAU" 
2935 f5				push af  
2936 3a 4a 29			ld a, (.dmark)  
2939 32 b4 fe			ld (debug_mark),a  
293c 3a 4b 29			ld a, (.dmark+1)  
293f 32 b5 fe			ld (debug_mark+1),a  
2942 3a 4c 29			ld a, (.dmark+2)  
2945 32 b6 fe			ld (debug_mark+2),a  
2948 18 03			jr .pastdmark  
294a ..			.dmark: db "PAU"  
294d f1			.pastdmark: pop af  
294e			endm  
# End of macro DMARK
294e						CALLMONITOR 
294e cd 7e 18			call break_point_state  
2951				endm  
# End of macro CALLMONITOR
2951					endif 
2951					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2951 cd e9 20			call macro_dsp_valuehl 
2954				endm 
# End of macro FORTH_DSP_VALUEHL
2954			;		push hl    ; n2 
2954					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2954 cd a1 21			call macro_forth_dsp_pop 
2957				endm 
# End of macro FORTH_DSP_POP
2957			;		pop hl 
2957 45					ld b, l 
2958					if DEBUG_FORTH_WORDS 
2958						DMARK "PAU" 
2958 f5				push af  
2959 3a 6d 29			ld a, (.dmark)  
295c 32 b4 fe			ld (debug_mark),a  
295f 3a 6e 29			ld a, (.dmark+1)  
2962 32 b5 fe			ld (debug_mark+1),a  
2965 3a 6f 29			ld a, (.dmark+2)  
2968 32 b6 fe			ld (debug_mark+2),a  
296b 18 03			jr .pastdmark  
296d ..			.dmark: db "PAU"  
2970 f1			.pastdmark: pop af  
2971			endm  
# End of macro DMARK
2971						CALLMONITOR 
2971 cd 7e 18			call break_point_state  
2974				endm  
# End of macro CALLMONITOR
2974					endif 
2974 c5			.pauses1:	push bc 
2975 cd 4a 0c				call delay1s 
2978 c1					pop bc 
2979					if DEBUG_FORTH_WORDS 
2979						DMARK "PA1" 
2979 f5				push af  
297a 3a 8e 29			ld a, (.dmark)  
297d 32 b4 fe			ld (debug_mark),a  
2980 3a 8f 29			ld a, (.dmark+1)  
2983 32 b5 fe			ld (debug_mark+1),a  
2986 3a 90 29			ld a, (.dmark+2)  
2989 32 b6 fe			ld (debug_mark+2),a  
298c 18 03			jr .pastdmark  
298e ..			.dmark: db "PA1"  
2991 f1			.pastdmark: pop af  
2992			endm  
# End of macro DMARK
2992						CALLMONITOR 
2992 cd 7e 18			call break_point_state  
2995				endm  
# End of macro CALLMONITOR
2995					endif 
2995 10 dd				djnz .pauses1 
2997			 
2997				       NEXTW 
2997 c3 60 22			jp macro_next 
299a				endm 
# End of macro NEXTW
299a			.ROT: 
299a				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
299a 45				db WORD_SYS_CORE+49             
299b e8 29			dw .UWORDS            
299d 04				db 3 + 1 
299e .. 00			db "ROT",0              
29a2				endm 
# End of macro CWHEAD
29a2			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
29a2					if DEBUG_FORTH_WORDS_KEY 
29a2						DMARK "ROT" 
29a2 f5				push af  
29a3 3a b7 29			ld a, (.dmark)  
29a6 32 b4 fe			ld (debug_mark),a  
29a9 3a b8 29			ld a, (.dmark+1)  
29ac 32 b5 fe			ld (debug_mark+1),a  
29af 3a b9 29			ld a, (.dmark+2)  
29b2 32 b6 fe			ld (debug_mark+2),a  
29b5 18 03			jr .pastdmark  
29b7 ..			.dmark: db "ROT"  
29ba f1			.pastdmark: pop af  
29bb			endm  
# End of macro DMARK
29bb						CALLMONITOR 
29bb cd 7e 18			call break_point_state  
29be				endm  
# End of macro CALLMONITOR
29be					endif 
29be			 
29be					FORTH_DSP_VALUEHL 
29be cd e9 20			call macro_dsp_valuehl 
29c1				endm 
# End of macro FORTH_DSP_VALUEHL
29c1 e5					push hl    ; u3  
29c2			 
29c2					FORTH_DSP_POP 
29c2 cd a1 21			call macro_forth_dsp_pop 
29c5				endm 
# End of macro FORTH_DSP_POP
29c5			   
29c5					FORTH_DSP_VALUEHL 
29c5 cd e9 20			call macro_dsp_valuehl 
29c8				endm 
# End of macro FORTH_DSP_VALUEHL
29c8 e5					push hl     ; u2 
29c9			 
29c9					FORTH_DSP_POP 
29c9 cd a1 21			call macro_forth_dsp_pop 
29cc				endm 
# End of macro FORTH_DSP_POP
29cc			 
29cc					FORTH_DSP_VALUEHL 
29cc cd e9 20			call macro_dsp_valuehl 
29cf				endm 
# End of macro FORTH_DSP_VALUEHL
29cf e5					push hl     ; u1 
29d0			 
29d0					FORTH_DSP_POP 
29d0 cd a1 21			call macro_forth_dsp_pop 
29d3				endm 
# End of macro FORTH_DSP_POP
29d3			 
29d3 c1					pop bc      ; u1 
29d4 e1					pop hl      ; u2 
29d5 d1					pop de      ; u3 
29d6			 
29d6			 
29d6 c5					push bc 
29d7 d5					push de 
29d8 e5					push hl 
29d9			 
29d9			 
29d9 e1					pop hl 
29da cd f2 1e				call forth_push_numhl 
29dd			 
29dd e1					pop hl 
29de cd f2 1e				call forth_push_numhl 
29e1			 
29e1 e1					pop hl 
29e2 cd f2 1e				call forth_push_numhl 
29e5					 
29e5			 
29e5			 
29e5			 
29e5			 
29e5			 
29e5				       NEXTW 
29e5 c3 60 22			jp macro_next 
29e8				endm 
# End of macro NEXTW
29e8			 
29e8			.UWORDS: 
29e8				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
29e8 50				db WORD_SYS_CORE+60             
29e9 aa 2a			dw .BP            
29eb 07				db 6 + 1 
29ec .. 00			db "UWORDS",0              
29f3				endm 
# End of macro CWHEAD
29f3			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
29f3			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
29f3			; | | Following the count are the individual words. 
29f3			; | | 
29f3			; | | e.g. UWORDS 
29f3			; | | BOX DIRLIST 2 
29f3			; | |  
29f3			; | | Can be used to save the words to storage via: 
29f3			; | | UWORDS $01 DO $01 APPEND LOOP 
29f3				if DEBUG_FORTH_WORDS_KEY 
29f3					DMARK "UWR" 
29f3 f5				push af  
29f4 3a 08 2a			ld a, (.dmark)  
29f7 32 b4 fe			ld (debug_mark),a  
29fa 3a 09 2a			ld a, (.dmark+1)  
29fd 32 b5 fe			ld (debug_mark+1),a  
2a00 3a 0a 2a			ld a, (.dmark+2)  
2a03 32 b6 fe			ld (debug_mark+2),a  
2a06 18 03			jr .pastdmark  
2a08 ..			.dmark: db "UWR"  
2a0b f1			.pastdmark: pop af  
2a0c			endm  
# End of macro DMARK
2a0c					CALLMONITOR 
2a0c cd 7e 18			call break_point_state  
2a0f				endm  
# End of macro CALLMONITOR
2a0f				endif 
2a0f 21 00 80				ld hl, baseram 
2a12					;ld hl, baseusermem 
2a12 01 00 00				ld bc, 0    ; start a counter 
2a15			 
2a15				; skip dict stub 
2a15			 
2a15 cd b1 23				call forth_tok_next 
2a18			 
2a18			 
2a18			; while we have words to look for 
2a18			 
2a18 7e			.douscan:	ld a, (hl)      
2a19				if DEBUG_FORTH_WORDS 
2a19					DMARK "UWs" 
2a19 f5				push af  
2a1a 3a 2e 2a			ld a, (.dmark)  
2a1d 32 b4 fe			ld (debug_mark),a  
2a20 3a 2f 2a			ld a, (.dmark+1)  
2a23 32 b5 fe			ld (debug_mark+1),a  
2a26 3a 30 2a			ld a, (.dmark+2)  
2a29 32 b6 fe			ld (debug_mark+2),a  
2a2c 18 03			jr .pastdmark  
2a2e ..			.dmark: db "UWs"  
2a31 f1			.pastdmark: pop af  
2a32			endm  
# End of macro DMARK
2a32					CALLMONITOR 
2a32 cd 7e 18			call break_point_state  
2a35				endm  
# End of macro CALLMONITOR
2a35				endif 
2a35 fe 00				cp WORD_SYS_END 
2a37 28 4d				jr z, .udone 
2a39 fe 01				cp WORD_SYS_UWORD 
2a3b 20 44				jr nz, .nuword 
2a3d			 
2a3d				if DEBUG_FORTH_WORDS 
2a3d					DMARK "UWu" 
2a3d f5				push af  
2a3e 3a 52 2a			ld a, (.dmark)  
2a41 32 b4 fe			ld (debug_mark),a  
2a44 3a 53 2a			ld a, (.dmark+1)  
2a47 32 b5 fe			ld (debug_mark+1),a  
2a4a 3a 54 2a			ld a, (.dmark+2)  
2a4d 32 b6 fe			ld (debug_mark+2),a  
2a50 18 03			jr .pastdmark  
2a52 ..			.dmark: db "UWu"  
2a55 f1			.pastdmark: pop af  
2a56			endm  
# End of macro DMARK
2a56					CALLMONITOR 
2a56 cd 7e 18			call break_point_state  
2a59				endm  
# End of macro CALLMONITOR
2a59				endif 
2a59					; we have a uword so push its name to the stack 
2a59			 
2a59 e5				   	push hl  ; save so we can move to next dict block 
2a5a			 
2a5a					; skip opcode 
2a5a 23					inc hl  
2a5b					; skip next ptr 
2a5b 23					inc hl  
2a5c 23					inc hl 
2a5d					; skip len 
2a5d 23					inc hl 
2a5e				if DEBUG_FORTH_WORDS 
2a5e					DMARK "UWt" 
2a5e f5				push af  
2a5f 3a 73 2a			ld a, (.dmark)  
2a62 32 b4 fe			ld (debug_mark),a  
2a65 3a 74 2a			ld a, (.dmark+1)  
2a68 32 b5 fe			ld (debug_mark+1),a  
2a6b 3a 75 2a			ld a, (.dmark+2)  
2a6e 32 b6 fe			ld (debug_mark+2),a  
2a71 18 03			jr .pastdmark  
2a73 ..			.dmark: db "UWt"  
2a76 f1			.pastdmark: pop af  
2a77			endm  
# End of macro DMARK
2a77					CALLMONITOR 
2a77 cd 7e 18			call break_point_state  
2a7a				endm  
# End of macro CALLMONITOR
2a7a				endif 
2a7a 03					inc bc 
2a7b			 
2a7b c5					push bc 
2a7c cd 60 1f				call forth_push_str 
2a7f c1					pop bc 
2a80			 
2a80 e1					pop hl 	 
2a81			 
2a81 cd b1 23		.nuword:	call forth_tok_next 
2a84 18 92				jr .douscan  
2a86			 
2a86			.udone:		 ; push count of uwords found 
2a86 c5					push bc 
2a87 e1					pop hl 
2a88			 
2a88				if DEBUG_FORTH_WORDS 
2a88					DMARK "UWc" 
2a88 f5				push af  
2a89 3a 9d 2a			ld a, (.dmark)  
2a8c 32 b4 fe			ld (debug_mark),a  
2a8f 3a 9e 2a			ld a, (.dmark+1)  
2a92 32 b5 fe			ld (debug_mark+1),a  
2a95 3a 9f 2a			ld a, (.dmark+2)  
2a98 32 b6 fe			ld (debug_mark+2),a  
2a9b 18 03			jr .pastdmark  
2a9d ..			.dmark: db "UWc"  
2aa0 f1			.pastdmark: pop af  
2aa1			endm  
# End of macro DMARK
2aa1					CALLMONITOR 
2aa1 cd 7e 18			call break_point_state  
2aa4				endm  
# End of macro CALLMONITOR
2aa4				endif 
2aa4 cd f2 1e				call forth_push_numhl 
2aa7			 
2aa7			 
2aa7				       NEXTW 
2aa7 c3 60 22			jp macro_next 
2aaa				endm 
# End of macro NEXTW
2aaa			 
2aaa			.BP: 
2aaa				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2aaa 54				db WORD_SYS_CORE+64             
2aab e0 2a			dw .MONITOR            
2aad 03				db 2 + 1 
2aae .. 00			db "BP",0              
2ab1				endm 
# End of macro CWHEAD
2ab1			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2ab1			; | | $00 Will enable the break points within specific code paths 
2ab1			; | | $01 Will disable break points 
2ab1			; | |  
2ab1			; | | By default break points are off. Either the above can be used to enable them 
2ab1			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2ab1			; | | and on release of the pressed key a message will be disaplayed to notify 
2ab1			; | | that break points are enabled. Pressing any key will then continue boot process. 
2ab1					; get byte count 
2ab1					if DEBUG_FORTH_WORDS_KEY 
2ab1						DMARK "BP." 
2ab1 f5				push af  
2ab2 3a c6 2a			ld a, (.dmark)  
2ab5 32 b4 fe			ld (debug_mark),a  
2ab8 3a c7 2a			ld a, (.dmark+1)  
2abb 32 b5 fe			ld (debug_mark+1),a  
2abe 3a c8 2a			ld a, (.dmark+2)  
2ac1 32 b6 fe			ld (debug_mark+2),a  
2ac4 18 03			jr .pastdmark  
2ac6 ..			.dmark: db "BP."  
2ac9 f1			.pastdmark: pop af  
2aca			endm  
# End of macro DMARK
2aca						CALLMONITOR 
2aca cd 7e 18			call break_point_state  
2acd				endm  
# End of macro CALLMONITOR
2acd					endif 
2acd			 
2acd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2acd cd e9 20			call macro_dsp_valuehl 
2ad0				endm 
# End of macro FORTH_DSP_VALUEHL
2ad0			 
2ad0			;		push hl 
2ad0			 
2ad0					; destroy value TOS 
2ad0			 
2ad0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ad0 cd a1 21			call macro_forth_dsp_pop 
2ad3				endm 
# End of macro FORTH_DSP_POP
2ad3			 
2ad3			;		pop hl 
2ad3			 
2ad3 3e 00				ld a,0 
2ad5 bd					cp l 
2ad6 28 02				jr z, .bpset 
2ad8 3e 2a				ld a, '*' 
2ada			 
2ada 32 74 f3		.bpset:		ld (os_view_disable), a 
2add			 
2add			 
2add					NEXTW 
2add c3 60 22			jp macro_next 
2ae0				endm 
# End of macro NEXTW
2ae0			 
2ae0			 
2ae0			.MONITOR: 
2ae0				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2ae0 55				db WORD_SYS_CORE+65             
2ae1 13 2b			dw .MALLOC            
2ae3 08				db 7 + 1 
2ae4 .. 00			db "MONITOR",0              
2aec				endm 
# End of macro CWHEAD
2aec			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2aec			; | | At start the current various registers will be displayed with contents. 
2aec			; | | Top right corner will show the most recent debug marker seen. 
2aec			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2aec			; | | and the return stack pointer (RSP). 
2aec			; | | Pressing: 
2aec			; | |    1 - Initial screen 
2aec			; | |    2 - Display a data dump of HL 
2aec			; | |    3 - Display a data dump of DE 
2aec			; | |    4 - Display a data dump of BC 
2aec			; | |    5 - Display a data dump of HL 
2aec			; | |    6 - Display a data dump of DSP 
2aec			; | |    7 - Display a data dump of RSP 
2aec			; | |    8 - Display a data dump of what is at DSP 
2aec			; | |    9 - Display a data dump of what is at RSP 
2aec			; | |    0 - Exit monitor and continue running. This will also enable break points 
2aec			; | |    * - Disable break points 
2aec			; | |    # - Enter traditional monitor mode 
2aec			; | | 
2aec			; | | Monitor Mode 
2aec			; | | ------------ 
2aec			; | | A prompt of '>' will be shown for various commands: 
2aec			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2aec			; | |    C - Continue display a data dump from the last set address 
2aec			; | |    M xxxx - Set start of memory edit at address xx 
2aec			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2aec			; | |    Q - Return to previous 
2aec					if DEBUG_FORTH_WORDS_KEY 
2aec						DMARK "MON" 
2aec f5				push af  
2aed 3a 01 2b			ld a, (.dmark)  
2af0 32 b4 fe			ld (debug_mark),a  
2af3 3a 02 2b			ld a, (.dmark+1)  
2af6 32 b5 fe			ld (debug_mark+1),a  
2af9 3a 03 2b			ld a, (.dmark+2)  
2afc 32 b6 fe			ld (debug_mark+2),a  
2aff 18 03			jr .pastdmark  
2b01 ..			.dmark: db "MON"  
2b04 f1			.pastdmark: pop af  
2b05			endm  
# End of macro DMARK
2b05						CALLMONITOR 
2b05 cd 7e 18			call break_point_state  
2b08				endm  
# End of macro CALLMONITOR
2b08					endif 
2b08 3e 00				ld a, 0 
2b0a 32 74 f3				ld (os_view_disable), a 
2b0d			 
2b0d					CALLMONITOR 
2b0d cd 7e 18			call break_point_state  
2b10				endm  
# End of macro CALLMONITOR
2b10			 
2b10			;	call monitor 
2b10			 
2b10					NEXTW 
2b10 c3 60 22			jp macro_next 
2b13				endm 
# End of macro NEXTW
2b13			 
2b13			 
2b13			.MALLOC: 
2b13				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2b13 56				db WORD_SYS_CORE+66             
2b14 3c 2b			dw .MALLOC2            
2b16 06				db 5 + 1 
2b17 .. 00			db "ALLOT",0              
2b1d				endm 
# End of macro CWHEAD
2b1d			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b1d					if DEBUG_FORTH_WORDS_KEY 
2b1d						DMARK "ALL" 
2b1d f5				push af  
2b1e 3a 32 2b			ld a, (.dmark)  
2b21 32 b4 fe			ld (debug_mark),a  
2b24 3a 33 2b			ld a, (.dmark+1)  
2b27 32 b5 fe			ld (debug_mark+1),a  
2b2a 3a 34 2b			ld a, (.dmark+2)  
2b2d 32 b6 fe			ld (debug_mark+2),a  
2b30 18 03			jr .pastdmark  
2b32 ..			.dmark: db "ALL"  
2b35 f1			.pastdmark: pop af  
2b36			endm  
# End of macro DMARK
2b36						CALLMONITOR 
2b36 cd 7e 18			call break_point_state  
2b39				endm  
# End of macro CALLMONITOR
2b39					endif 
2b39 c3 63 2b				jp .mallocc 
2b3c			.MALLOC2: 
2b3c				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2b3c 56				db WORD_SYS_CORE+66             
2b3d 7a 2b			dw .FREE            
2b3f 07				db 6 + 1 
2b40 .. 00			db "MALLOC",0              
2b47				endm 
# End of macro CWHEAD
2b47			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b47					; get byte count 
2b47					if DEBUG_FORTH_WORDS_KEY 
2b47						DMARK "MAL" 
2b47 f5				push af  
2b48 3a 5c 2b			ld a, (.dmark)  
2b4b 32 b4 fe			ld (debug_mark),a  
2b4e 3a 5d 2b			ld a, (.dmark+1)  
2b51 32 b5 fe			ld (debug_mark+1),a  
2b54 3a 5e 2b			ld a, (.dmark+2)  
2b57 32 b6 fe			ld (debug_mark+2),a  
2b5a 18 03			jr .pastdmark  
2b5c ..			.dmark: db "MAL"  
2b5f f1			.pastdmark: pop af  
2b60			endm  
# End of macro DMARK
2b60						CALLMONITOR 
2b60 cd 7e 18			call break_point_state  
2b63				endm  
# End of macro CALLMONITOR
2b63					endif 
2b63			.mallocc: 
2b63					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b63 cd e9 20			call macro_dsp_valuehl 
2b66				endm 
# End of macro FORTH_DSP_VALUEHL
2b66			 
2b66			;		push hl 
2b66			 
2b66					; destroy value TOS 
2b66			 
2b66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b66 cd a1 21			call macro_forth_dsp_pop 
2b69				endm 
# End of macro FORTH_DSP_POP
2b69			 
2b69			;		pop hl 
2b69 cd c8 13				call malloc 
2b6c				if DEBUG_FORTH_MALLOC_GUARD 
2b6c f5					push af 
2b6d cd 2a 0f				call ishlzero 
2b70			;		ld a, l 
2b70			;		add h 
2b70			;		cp 0 
2b70 f1					pop af 
2b71					 
2b71 cc 51 55				call z,malloc_error 
2b74				endif 
2b74			 
2b74 cd f2 1e				call forth_push_numhl 
2b77					NEXTW 
2b77 c3 60 22			jp macro_next 
2b7a				endm 
# End of macro NEXTW
2b7a			 
2b7a			.FREE: 
2b7a				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2b7a 57				db WORD_SYS_CORE+67             
2b7b ab 2b			dw .LIST            
2b7d 05				db 4 + 1 
2b7e .. 00			db "FREE",0              
2b83				endm 
# End of macro CWHEAD
2b83			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2b83					if DEBUG_FORTH_WORDS_KEY 
2b83						DMARK "FRE" 
2b83 f5				push af  
2b84 3a 98 2b			ld a, (.dmark)  
2b87 32 b4 fe			ld (debug_mark),a  
2b8a 3a 99 2b			ld a, (.dmark+1)  
2b8d 32 b5 fe			ld (debug_mark+1),a  
2b90 3a 9a 2b			ld a, (.dmark+2)  
2b93 32 b6 fe			ld (debug_mark+2),a  
2b96 18 03			jr .pastdmark  
2b98 ..			.dmark: db "FRE"  
2b9b f1			.pastdmark: pop af  
2b9c			endm  
# End of macro DMARK
2b9c						CALLMONITOR 
2b9c cd 7e 18			call break_point_state  
2b9f				endm  
# End of macro CALLMONITOR
2b9f					endif 
2b9f					; get address 
2b9f			 
2b9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b9f cd e9 20			call macro_dsp_valuehl 
2ba2				endm 
# End of macro FORTH_DSP_VALUEHL
2ba2			 
2ba2			;		push hl 
2ba2			 
2ba2					; destroy value TOS 
2ba2			 
2ba2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ba2 cd a1 21			call macro_forth_dsp_pop 
2ba5				endm 
# End of macro FORTH_DSP_POP
2ba5			 
2ba5			;		pop hl 
2ba5			if FORTH_ENABLE_MALLOCFREE 
2ba5 cd 92 14				call free 
2ba8			endif 
2ba8					NEXTW 
2ba8 c3 60 22			jp macro_next 
2bab				endm 
# End of macro NEXTW
2bab			.LIST: 
2bab				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2bab 5c				db WORD_SYS_CORE+72             
2bac 99 2d			dw .FORGET            
2bae 05				db 4 + 1 
2baf .. 00			db "LIST",0              
2bb4				endm 
# End of macro CWHEAD
2bb4			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2bb4			; | | The quoted word must be in upper case. 
2bb4				if DEBUG_FORTH_WORDS_KEY 
2bb4					DMARK "LST" 
2bb4 f5				push af  
2bb5 3a c9 2b			ld a, (.dmark)  
2bb8 32 b4 fe			ld (debug_mark),a  
2bbb 3a ca 2b			ld a, (.dmark+1)  
2bbe 32 b5 fe			ld (debug_mark+1),a  
2bc1 3a cb 2b			ld a, (.dmark+2)  
2bc4 32 b6 fe			ld (debug_mark+2),a  
2bc7 18 03			jr .pastdmark  
2bc9 ..			.dmark: db "LST"  
2bcc f1			.pastdmark: pop af  
2bcd			endm  
# End of macro DMARK
2bcd					CALLMONITOR 
2bcd cd 7e 18			call break_point_state  
2bd0				endm  
# End of macro CALLMONITOR
2bd0				endif 
2bd0			 
2bd0					FORTH_DSP_VALUEHL 
2bd0 cd e9 20			call macro_dsp_valuehl 
2bd3				endm 
# End of macro FORTH_DSP_VALUEHL
2bd3			 
2bd3 e5					push hl 
2bd4					FORTH_DSP_POP 
2bd4 cd a1 21			call macro_forth_dsp_pop 
2bd7				endm 
# End of macro FORTH_DSP_POP
2bd7 c1					pop bc 
2bd8			 
2bd8			; Start format of scratch string 
2bd8			 
2bd8 21 83 f3				ld hl, scratch 
2bdb			 
2bdb 3e 3a				ld a, ':' 
2bdd 77					ld (hl),a 
2bde 23					inc hl 
2bdf 3e 20				ld a, ' ' 
2be1 77					ld (hl), a 
2be2			 
2be2					; Get ptr to the word we need to look up 
2be2			 
2be2			;		FORTH_DSP_VALUEHL 
2be2					;v5 FORTH_DSP_VALUE 
2be2				; TODO type check 
2be2			;		inc hl    ; Skip type check  
2be2			;		push hl 
2be2			;		ex de, hl    ; put into DE 
2be2			 
2be2			 
2be2 21 00 80				ld hl, baseram 
2be5					;ld hl, baseusermem 
2be5			 
2be5 e5			push hl   ; sacreifical push 
2be6			 
2be6			.ldouscanm: 
2be6 e1				pop hl 
2be7			.ldouscan: 
2be7				if DEBUG_FORTH_WORDS 
2be7					DMARK "LSs" 
2be7 f5				push af  
2be8 3a fc 2b			ld a, (.dmark)  
2beb 32 b4 fe			ld (debug_mark),a  
2bee 3a fd 2b			ld a, (.dmark+1)  
2bf1 32 b5 fe			ld (debug_mark+1),a  
2bf4 3a fe 2b			ld a, (.dmark+2)  
2bf7 32 b6 fe			ld (debug_mark+2),a  
2bfa 18 03			jr .pastdmark  
2bfc ..			.dmark: db "LSs"  
2bff f1			.pastdmark: pop af  
2c00			endm  
# End of macro DMARK
2c00					CALLMONITOR 
2c00 cd 7e 18			call break_point_state  
2c03				endm  
# End of macro CALLMONITOR
2c03				endif 
2c03				; skip dict stub 
2c03 cd b1 23				call forth_tok_next 
2c06			 
2c06			 
2c06			; while we have words to look for 
2c06			 
2c06 7e				ld a, (hl)      
2c07				if DEBUG_FORTH_WORDS 
2c07					DMARK "LSk" 
2c07 f5				push af  
2c08 3a 1c 2c			ld a, (.dmark)  
2c0b 32 b4 fe			ld (debug_mark),a  
2c0e 3a 1d 2c			ld a, (.dmark+1)  
2c11 32 b5 fe			ld (debug_mark+1),a  
2c14 3a 1e 2c			ld a, (.dmark+2)  
2c17 32 b6 fe			ld (debug_mark+2),a  
2c1a 18 03			jr .pastdmark  
2c1c ..			.dmark: db "LSk"  
2c1f f1			.pastdmark: pop af  
2c20			endm  
# End of macro DMARK
2c20					CALLMONITOR 
2c20 cd 7e 18			call break_point_state  
2c23				endm  
# End of macro CALLMONITOR
2c23				endif 
2c23					;cp WORD_SYS_END 
2c23					;jp z, .lunotfound 
2c23			 
2c23					; if we hit non uwords then gone too far 
2c23 fe 01				cp WORD_SYS_UWORD 
2c25 c2 55 2d				jp nz, .lunotfound 
2c28			 
2c28				if DEBUG_FORTH_WORDS 
2c28					DMARK "LSu" 
2c28 f5				push af  
2c29 3a 3d 2c			ld a, (.dmark)  
2c2c 32 b4 fe			ld (debug_mark),a  
2c2f 3a 3e 2c			ld a, (.dmark+1)  
2c32 32 b5 fe			ld (debug_mark+1),a  
2c35 3a 3f 2c			ld a, (.dmark+2)  
2c38 32 b6 fe			ld (debug_mark+2),a  
2c3b 18 03			jr .pastdmark  
2c3d ..			.dmark: db "LSu"  
2c40 f1			.pastdmark: pop af  
2c41			endm  
# End of macro DMARK
2c41					CALLMONITOR 
2c41 cd 7e 18			call break_point_state  
2c44				endm  
# End of macro CALLMONITOR
2c44				endif 
2c44			 
2c44					; found a uword but is it the one we want... 
2c44			 
2c44 c5					push bc     ; uword to find is on bc 
2c45 d1					pop de 
2c46			 
2c46 e5					push hl  ; to save the ptr 
2c47			 
2c47					; skip opcode 
2c47 23					inc hl  
2c48					; skip next ptr 
2c48 23					inc hl  
2c49 23					inc hl 
2c4a					; skip len 
2c4a 23					inc hl 
2c4b			 
2c4b				if DEBUG_FORTH_WORDS 
2c4b					DMARK "LSc" 
2c4b f5				push af  
2c4c 3a 60 2c			ld a, (.dmark)  
2c4f 32 b4 fe			ld (debug_mark),a  
2c52 3a 61 2c			ld a, (.dmark+1)  
2c55 32 b5 fe			ld (debug_mark+1),a  
2c58 3a 62 2c			ld a, (.dmark+2)  
2c5b 32 b6 fe			ld (debug_mark+2),a  
2c5e 18 03			jr .pastdmark  
2c60 ..			.dmark: db "LSc"  
2c63 f1			.pastdmark: pop af  
2c64			endm  
# End of macro DMARK
2c64					CALLMONITOR 
2c64 cd 7e 18			call break_point_state  
2c67				endm  
# End of macro CALLMONITOR
2c67				endif 
2c67 cd 97 13				call strcmp 
2c6a c2 e6 2b				jp nz, .ldouscanm 
2c6d				 
2c6d			 
2c6d			 
2c6d					; we have a uword so push its name to the stack 
2c6d			 
2c6d			;	   	push hl  ; save so we can move to next dict block 
2c6d e1			pop hl 
2c6e			 
2c6e				if DEBUG_FORTH_WORDS 
2c6e					DMARK "LSm" 
2c6e f5				push af  
2c6f 3a 83 2c			ld a, (.dmark)  
2c72 32 b4 fe			ld (debug_mark),a  
2c75 3a 84 2c			ld a, (.dmark+1)  
2c78 32 b5 fe			ld (debug_mark+1),a  
2c7b 3a 85 2c			ld a, (.dmark+2)  
2c7e 32 b6 fe			ld (debug_mark+2),a  
2c81 18 03			jr .pastdmark  
2c83 ..			.dmark: db "LSm"  
2c86 f1			.pastdmark: pop af  
2c87			endm  
# End of macro DMARK
2c87					CALLMONITOR 
2c87 cd 7e 18			call break_point_state  
2c8a				endm  
# End of macro CALLMONITOR
2c8a				endif 
2c8a			 
2c8a					; skip opcode 
2c8a 23					inc hl  
2c8b					; skip next ptr 
2c8b 23					inc hl  
2c8c 23					inc hl 
2c8d					; skip len 
2c8d 7e					ld a, (hl)   ; save length to add 
2c8e				if DEBUG_FORTH_WORDS 
2c8e					DMARK "LS2" 
2c8e f5				push af  
2c8f 3a a3 2c			ld a, (.dmark)  
2c92 32 b4 fe			ld (debug_mark),a  
2c95 3a a4 2c			ld a, (.dmark+1)  
2c98 32 b5 fe			ld (debug_mark+1),a  
2c9b 3a a5 2c			ld a, (.dmark+2)  
2c9e 32 b6 fe			ld (debug_mark+2),a  
2ca1 18 03			jr .pastdmark  
2ca3 ..			.dmark: db "LS2"  
2ca6 f1			.pastdmark: pop af  
2ca7			endm  
# End of macro DMARK
2ca7					CALLMONITOR 
2ca7 cd 7e 18			call break_point_state  
2caa				endm  
# End of macro CALLMONITOR
2caa				endif 
2caa			 
2caa					; save this location 
2caa				 
2caa e5					push hl 
2cab			 
2cab 23					inc hl 
2cac 11 85 f3				ld de, scratch+2 
2caf 4f					ld c, a 
2cb0 06 00				ld b, 0 
2cb2			 
2cb2				if DEBUG_FORTH_WORDS 
2cb2					DMARK "LSn" 
2cb2 f5				push af  
2cb3 3a c7 2c			ld a, (.dmark)  
2cb6 32 b4 fe			ld (debug_mark),a  
2cb9 3a c8 2c			ld a, (.dmark+1)  
2cbc 32 b5 fe			ld (debug_mark+1),a  
2cbf 3a c9 2c			ld a, (.dmark+2)  
2cc2 32 b6 fe			ld (debug_mark+2),a  
2cc5 18 03			jr .pastdmark  
2cc7 ..			.dmark: db "LSn"  
2cca f1			.pastdmark: pop af  
2ccb			endm  
# End of macro DMARK
2ccb					CALLMONITOR 
2ccb cd 7e 18			call break_point_state  
2cce				endm  
# End of macro CALLMONITOR
2cce				endif 
2cce			 
2cce					; copy uword name to scratch 
2cce			 
2cce ed b0				ldir 
2cd0			 
2cd0 1b					dec de 
2cd1 3e 20				ld a, ' '    ; change null to space 
2cd3 12					ld (de), a 
2cd4			 
2cd4 13					inc de 
2cd5			 
2cd5 d5					push de 
2cd6 c1					pop bc     ; move scratch pointer to end of word name and save it 
2cd7			 
2cd7 e1					pop hl 
2cd8 7e					ld a, (hl) 
2cd9					;inc hl 
2cd9					; skip word string 
2cd9 cd 01 0f				call addatohl 
2cdc			 
2cdc 23					inc hl 
2cdd			 
2cdd				if DEBUG_FORTH_WORDS 
2cdd					DMARK "LS3" 
2cdd f5				push af  
2cde 3a f2 2c			ld a, (.dmark)  
2ce1 32 b4 fe			ld (debug_mark),a  
2ce4 3a f3 2c			ld a, (.dmark+1)  
2ce7 32 b5 fe			ld (debug_mark+1),a  
2cea 3a f4 2c			ld a, (.dmark+2)  
2ced 32 b6 fe			ld (debug_mark+2),a  
2cf0 18 03			jr .pastdmark  
2cf2 ..			.dmark: db "LS3"  
2cf5 f1			.pastdmark: pop af  
2cf6			endm  
# End of macro DMARK
2cf6					CALLMONITOR 
2cf6 cd 7e 18			call break_point_state  
2cf9				endm  
# End of macro CALLMONITOR
2cf9				endif 
2cf9					; should now be at the start of the machine code to setup the eval of the uword 
2cf9					; now locate the ptr to the string defintion 
2cf9			 
2cf9					; skip ld hl, 
2cf9					; then load the ptr 
2cf9			; TODO use get from hl ptr 
2cf9 23					inc hl 
2cfa 5e					ld e, (hl) 
2cfb 23					inc hl 
2cfc 56					ld d, (hl) 
2cfd eb					ex de, hl 
2cfe			 
2cfe			 
2cfe				if DEBUG_FORTH_WORDS 
2cfe					DMARK "LSt" 
2cfe f5				push af  
2cff 3a 13 2d			ld a, (.dmark)  
2d02 32 b4 fe			ld (debug_mark),a  
2d05 3a 14 2d			ld a, (.dmark+1)  
2d08 32 b5 fe			ld (debug_mark+1),a  
2d0b 3a 15 2d			ld a, (.dmark+2)  
2d0e 32 b6 fe			ld (debug_mark+2),a  
2d11 18 03			jr .pastdmark  
2d13 ..			.dmark: db "LSt"  
2d16 f1			.pastdmark: pop af  
2d17			endm  
# End of macro DMARK
2d17					CALLMONITOR 
2d17 cd 7e 18			call break_point_state  
2d1a				endm  
# End of macro CALLMONITOR
2d1a				endif 
2d1a			 
2d1a			; cant push right now due to tokenised strings  
2d1a			 
2d1a			; get the destination of where to copy this definition to. 
2d1a			 
2d1a c5					push bc 
2d1b d1					pop de 
2d1c			 
2d1c 7e			.listl:         ld a,(hl) 
2d1d fe 00				cp 0 
2d1f 28 09				jr z, .lreplsp     ; replace zero with space 
2d21					;cp FORTH_END_BUFFER 
2d21 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2d23 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2d25				 
2d25					; just copy this char as is then 
2d25			 
2d25 12					ld (de), a 
2d26			 
2d26 23			.listnxt:	inc hl 
2d27 13					inc de 
2d28 18 f2				jr .listl 
2d2a			 
2d2a 3e 20		.lreplsp:	ld a,' ' 
2d2c 12					ld (de), a 
2d2d 18 f7				jr .listnxt 
2d2f			 
2d2f			; close up uword def 
2d2f			 
2d2f			.listdone: 
2d2f 12					ld (de), a 
2d30 13					inc de 
2d31 3e 00				ld a, 0 
2d33 12					ld (de), a 
2d34			 
2d34			; now have def so clean up and push to stack 
2d34			 
2d34 21 83 f3				ld hl, scratch 
2d37				if DEBUG_FORTH_WORDS 
2d37					DMARK "Ltp" 
2d37 f5				push af  
2d38 3a 4c 2d			ld a, (.dmark)  
2d3b 32 b4 fe			ld (debug_mark),a  
2d3e 3a 4d 2d			ld a, (.dmark+1)  
2d41 32 b5 fe			ld (debug_mark+1),a  
2d44 3a 4e 2d			ld a, (.dmark+2)  
2d47 32 b6 fe			ld (debug_mark+2),a  
2d4a 18 03			jr .pastdmark  
2d4c ..			.dmark: db "Ltp"  
2d4f f1			.pastdmark: pop af  
2d50			endm  
# End of macro DMARK
2d50					CALLMONITOR 
2d50 cd 7e 18			call break_point_state  
2d53				endm  
# End of macro CALLMONITOR
2d53				endif 
2d53			 
2d53 18 1f			jr .listpush 
2d55			 
2d55			;.lnuword:	pop hl 
2d55			;		call forth_tok_next 
2d55			;		jp .ldouscan  
2d55			 
2d55			.lunotfound:		  
2d55			 
2d55				if DEBUG_FORTH_WORDS 
2d55					DMARK "LSn" 
2d55 f5				push af  
2d56 3a 6a 2d			ld a, (.dmark)  
2d59 32 b4 fe			ld (debug_mark),a  
2d5c 3a 6b 2d			ld a, (.dmark+1)  
2d5f 32 b5 fe			ld (debug_mark+1),a  
2d62 3a 6c 2d			ld a, (.dmark+2)  
2d65 32 b6 fe			ld (debug_mark+2),a  
2d68 18 03			jr .pastdmark  
2d6a ..			.dmark: db "LSn"  
2d6d f1			.pastdmark: pop af  
2d6e			endm  
# End of macro DMARK
2d6e					CALLMONITOR 
2d6e cd 7e 18			call break_point_state  
2d71				endm  
# End of macro CALLMONITOR
2d71				endif 
2d71			 
2d71					 
2d71			;		FORTH_DSP_POP 
2d71			;		ld hl, .luno 
2d71			 
2d71					NEXTW			 
2d71 c3 60 22			jp macro_next 
2d74				endm 
# End of macro NEXTW
2d74			 
2d74			.listpush: 
2d74				if DEBUG_FORTH_WORDS 
2d74					DMARK "LS>" 
2d74 f5				push af  
2d75 3a 89 2d			ld a, (.dmark)  
2d78 32 b4 fe			ld (debug_mark),a  
2d7b 3a 8a 2d			ld a, (.dmark+1)  
2d7e 32 b5 fe			ld (debug_mark+1),a  
2d81 3a 8b 2d			ld a, (.dmark+2)  
2d84 32 b6 fe			ld (debug_mark+2),a  
2d87 18 03			jr .pastdmark  
2d89 ..			.dmark: db "LS>"  
2d8c f1			.pastdmark: pop af  
2d8d			endm  
# End of macro DMARK
2d8d					CALLMONITOR 
2d8d cd 7e 18			call break_point_state  
2d90				endm  
# End of macro CALLMONITOR
2d90				endif 
2d90 cd 60 1f				call forth_push_str 
2d93			 
2d93			 
2d93			 
2d93					NEXTW 
2d93 c3 60 22			jp macro_next 
2d96				endm 
# End of macro NEXTW
2d96			 
2d96			;.luno:    db "Word not found",0 
2d96			 
2d96			 
2d96			 
2d96			 
2d96			 
2d96			;		push hl   ; save pointer to start of uword def string 
2d96			; 
2d96			;; look for FORTH_EOL_LINE 
2d96			;		ld a, FORTH_END_BUFFER 
2d96			;		call strlent 
2d96			; 
2d96			;		inc hl		 ; space for coln def 
2d96			;		inc hl 
2d96			;		inc hl          ; space for terms 
2d96			;		inc hl 
2d96			; 
2d96			;		ld a, 20   ; TODO get actual length 
2d96			;		call addatohl    ; include a random amount of room for the uword name 
2d96			; 
2d96			;		 
2d96			;	if DEBUG_FORTH_WORDS 
2d96			;		DMARK "Lt1" 
2d96			;		CALLMONITOR 
2d96			;	endif 
2d96			;		 
2d96			; 
2d96			;; malloc space for the string because we cant change it 
2d96			; 
2d96			;		call malloc 
2d96			;	if DEBUG_FORTH_MALLOC_GUARD 
2d96			;		push af 
2d96			;		call ishlzero 
2d96			;		pop af 
2d96			;		 
2d96			;		call z,malloc_error 
2d96			;	endif 
2d96			; 
2d96			;	if DEBUG_FORTH_WORDS 
2d96			;		DMARK "Lt2" 
2d96			;		CALLMONITOR 
2d96			;	endif 
2d96			;		pop de 
2d96			;		push hl    ; push the malloc to release later 
2d96			;		push hl   ;  push back a copy for the later stack push 
2d96			;		 
2d96			;; copy the string swapping out the zero terms for spaces 
2d96			; 
2d96			;		; de has our source 
2d96			;		; hl has our dest 
2d96			; 
2d96			;; add the coln def 
2d96			; 
2d96			;		ld a, ':' 
2d96			;		ld (hl), a 
2d96			;		inc hl 
2d96			;		ld a, ' ' 
2d96			;		ld (hl), a 
2d96			;		inc hl 
2d96			; 
2d96			;; add the uname word 
2d96			;		push de   ; save our string for now 
2d96			;		ex de, hl 
2d96			; 
2d96			;		FORTH_DSP_VALUE 
2d96			;		;v5 FORTH_DSP_VALUE 
2d96			; 
2d96			;		inc hl   ; skip type but we know by now this is OK 
2d96			; 
2d96			;.luword:	ld a,(hl) 
2d96			;		cp 0 
2d96			;		jr z, .luword2 
2d96			;		ld (de), a 
2d96			;		inc de 
2d96			;		inc hl 
2d96			;		jr .luword 
2d96			; 
2d96			;.luword2:	ld a, ' ' 
2d96			;		ld (de), a 
2d96			;;		inc hl 
2d96			;;		inc de 
2d96			;;		ld (de), a 
2d96			;;		inc hl 
2d96			;		inc de 
2d96			; 
2d96			;		ex de, hl 
2d96			;		pop de 
2d96			;		 
2d96			;		 
2d96			; 
2d96			;; detoken that string and copy it 
2d96			; 
2d96			;	if DEBUG_FORTH_WORDS 
2d96			;		DMARK "Lt2" 
2d96			;		CALLMONITOR 
2d96			;	endif 
2d96			;.ldetok:	ld a, (de) 
2d96			;		cp FORTH_END_BUFFER 
2d96			;		jr z, .ldetokend 
2d96			;		; swap out any zero term for space 
2d96			;		cp 0 
2d96			;		jr nz, .ldetoknext 
2d96			;		ld a, ' ' 
2d96			; 
2d96			;	if DEBUG_FORTH_WORDS 
2d96			;		DMARK "LtS" 
2d96			;		CALLMONITOR 
2d96			;	endif 
2d96			;.ldetoknext:	ld (hl), a 
2d96			;		inc de 
2d96			;		inc hl 
2d96			;		jr .ldetok 
2d96			; 
2d96			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2d96			;		ld (hl), a  
2d96			; 
2d96			;; free that temp malloc 
2d96			; 
2d96			;		pop hl    
2d96			; 
2d96			;	if DEBUG_FORTH_WORDS 
2d96			;		DMARK "Lt4" 
2d96			;		CALLMONITOR 
2d96			;	endif 
2d96			;		call forth_apushstrhl 
2d96			; 
2d96			;		; get rid of temp malloc area 
2d96			; 
2d96			;		pop hl 
2d96			;		call free 
2d96			; 
2d96			;		jr .ludone 
2d96			; 
2d96			;.lnuword:	pop hl 
2d96			;		call forth_tok_next 
2d96			;		jp .ldouscan  
2d96			; 
2d96			;.ludone:		 pop hl 
2d96			; 
2d96					NEXTW 
2d96 c3 60 22			jp macro_next 
2d99				endm 
# End of macro NEXTW
2d99			 
2d99			.FORGET: 
2d99				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2d99 5d				db WORD_SYS_CORE+73             
2d9a 12 2e			dw .NOP            
2d9c 07				db 6 + 1 
2d9d .. 00			db "FORGET",0              
2da4				endm 
# End of macro CWHEAD
2da4			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2da4			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2da4			; | |  
2da4			; | | e.g. "MORE" forget 
2da4					if DEBUG_FORTH_WORDS_KEY 
2da4						DMARK "FRG" 
2da4 f5				push af  
2da5 3a b9 2d			ld a, (.dmark)  
2da8 32 b4 fe			ld (debug_mark),a  
2dab 3a ba 2d			ld a, (.dmark+1)  
2dae 32 b5 fe			ld (debug_mark+1),a  
2db1 3a bb 2d			ld a, (.dmark+2)  
2db4 32 b6 fe			ld (debug_mark+2),a  
2db7 18 03			jr .pastdmark  
2db9 ..			.dmark: db "FRG"  
2dbc f1			.pastdmark: pop af  
2dbd			endm  
# End of macro DMARK
2dbd						CALLMONITOR 
2dbd cd 7e 18			call break_point_state  
2dc0				endm  
# End of macro CALLMONITOR
2dc0					endif 
2dc0			 
2dc0				; find uword 
2dc0			        ; update start of word with "_" 
2dc0				; replace uword with deleted flag 
2dc0			 
2dc0			 
2dc0			;	if DEBUG_FORTH_WORDS 
2dc0			;		DMARK "FOG" 
2dc0			;		CALLMONITOR 
2dc0			;	endif 
2dc0			 
2dc0			 
2dc0					; Get ptr to the word we need to look up 
2dc0			 
2dc0					FORTH_DSP_VALUEHL 
2dc0 cd e9 20			call macro_dsp_valuehl 
2dc3				endm 
# End of macro FORTH_DSP_VALUEHL
2dc3					;v5 FORTH_DSP_VALUE 
2dc3				; TODO type check 
2dc3			;		inc hl    ; Skip type check  
2dc3 e5					push hl 
2dc4 c1					pop bc 
2dc5			;		ex de, hl    ; put into DE 
2dc5			 
2dc5			 
2dc5 21 00 80				ld hl, baseram 
2dc8					;ld hl, baseusermem 
2dc8			 
2dc8				; skip dict stub 
2dc8			;	call forth_tok_next 
2dc8 e5			push hl   ; sacreifical push 
2dc9			 
2dc9			.fldouscanm: 
2dc9 e1				pop hl 
2dca			.fldouscan: 
2dca			;	if DEBUG_FORTH_WORDS 
2dca			;		DMARK "LSs" 
2dca			;		CALLMONITOR 
2dca			;	endif 
2dca				; skip dict stub 
2dca cd b1 23				call forth_tok_next 
2dcd			 
2dcd			 
2dcd			; while we have words to look for 
2dcd			 
2dcd 7e				ld a, (hl)      
2dce			;	if DEBUG_FORTH_WORDS 
2dce			;		DMARK "LSk" 
2dce			;		CALLMONITOR 
2dce			;	endif 
2dce fe 00				cp WORD_SYS_END 
2dd0 ca 0c 2e				jp z, .flunotfound 
2dd3 fe 01				cp WORD_SYS_UWORD 
2dd5 c2 ca 2d				jp nz, .fldouscan 
2dd8			 
2dd8			;	if DEBUG_FORTH_WORDS 
2dd8			;		DMARK "LSu" 
2dd8			;		CALLMONITOR 
2dd8			;	endif 
2dd8			 
2dd8					; found a uword but is it the one we want... 
2dd8			 
2dd8 c5					push bc     ; uword to find is on bc 
2dd9 d1					pop de 
2dda			 
2dda e5					push hl  ; to save the ptr 
2ddb			 
2ddb					; skip opcode 
2ddb 23					inc hl  
2ddc					; skip next ptr 
2ddc 23					inc hl  
2ddd 23					inc hl 
2dde					; skip len 
2dde 23					inc hl 
2ddf			 
2ddf			;	if DEBUG_FORTH_WORDS 
2ddf			;		DMARK "LSc" 
2ddf			;		CALLMONITOR 
2ddf			;	endif 
2ddf cd 97 13				call strcmp 
2de2 c2 c9 2d				jp nz, .fldouscanm 
2de5			; 
2de5			; 
2de5			;; while we have words to look for 
2de5			; 
2de5			;.fdouscan:	ld a, (hl)      
2de5			;	if DEBUG_FORTH_WORDS 
2de5			;		DMARK "LSs" 
2de5			;		CALLMONITOR 
2de5			;	endif 
2de5			;		cp WORD_SYS_END 
2de5			;		jp z, .fudone 
2de5			;		cp WORD_SYS_UWORD 
2de5			;		jp nz, .fnuword 
2de5			; 
2de5			;	if DEBUG_FORTH_WORDS 
2de5			;		DMARK "FGu" 
2de5			;		CALLMONITOR 
2de5			;	endif 
2de5			; 
2de5			;		; found a uword but is it the one we want... 
2de5			; 
2de5			; 
2de5			;	        pop de   ; get back the dsp name 
2de5			;		push de 
2de5			; 
2de5			;		push hl  ; to save the ptr 
2de5			; 
2de5			;		; skip opcode 
2de5			;		inc hl  
2de5			;		; skip next ptr 
2de5			;		inc hl  
2de5			;		inc hl 
2de5			;		; skip len 
2de5			;		inc hl 
2de5			; 
2de5			;	if DEBUG_FORTH_WORDS 
2de5			;		DMARK "FGc" 
2de5			;		CALLMONITOR 
2de5			;	endif 
2de5			;		call strcmp 
2de5			;		jp nz, .fnuword 
2de5			 
2de5			 
2de5 e1			pop hl 
2de6			 
2de6				 
2de6				if DEBUG_FORTH_WORDS 
2de6					DMARK "FGm" 
2de6 f5				push af  
2de7 3a fb 2d			ld a, (.dmark)  
2dea 32 b4 fe			ld (debug_mark),a  
2ded 3a fc 2d			ld a, (.dmark+1)  
2df0 32 b5 fe			ld (debug_mark+1),a  
2df3 3a fd 2d			ld a, (.dmark+2)  
2df6 32 b6 fe			ld (debug_mark+2),a  
2df9 18 03			jr .pastdmark  
2dfb ..			.dmark: db "FGm"  
2dfe f1			.pastdmark: pop af  
2dff			endm  
# End of macro DMARK
2dff					CALLMONITOR 
2dff cd 7e 18			call break_point_state  
2e02				endm  
# End of macro CALLMONITOR
2e02				endif 
2e02			 
2e02			 
2e02			 
2e02					; we have a uword so push its name to the stack 
2e02			 
2e02			;	   	push hl  ; save so we can move to next dict block 
2e02			;pop hl 
2e02			 
2e02					; update opcode to deleted 
2e02 3e 03				ld a, WORD_SYS_DELETED 
2e04 77					ld (hl), a 
2e05			 
2e05 23					inc hl  
2e06					; skip next ptr 
2e06 23					inc hl  
2e07 23					inc hl 
2e08					; skip len 
2e08 23					inc hl 
2e09			 
2e09					; TODO change parser to skip deleted words but for now mark it out 
2e09 3e 5f				ld a, "_" 
2e0b 77					ld  (hl),a 
2e0c			 
2e0c			;		jr .fudone 
2e0c			; 
2e0c			;.fnuword:	pop hl 
2e0c			;		call forth_tok_next 
2e0c			;		jp .fdouscan  
2e0c			 
2e0c			.flunotfound:		  
2e0c			 
2e0c			 
2e0c					 
2e0c					FORTH_DSP_POP 
2e0c cd a1 21			call macro_forth_dsp_pop 
2e0f				endm 
# End of macro FORTH_DSP_POP
2e0f			;		ld hl, .luno 
2e0f			;.fudone:		 pop hl 
2e0f					NEXTW 
2e0f c3 60 22			jp macro_next 
2e12				endm 
# End of macro NEXTW
2e12			.NOP: 
2e12				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2e12 61				db WORD_SYS_CORE+77             
2e13 39 2e			dw .COMO            
2e15 04				db 3 + 1 
2e16 .. 00			db "NOP",0              
2e1a				endm 
# End of macro CWHEAD
2e1a			; | NOP (  --  ) Do nothing | DONE 
2e1a					if DEBUG_FORTH_WORDS_KEY 
2e1a						DMARK "NOP" 
2e1a f5				push af  
2e1b 3a 2f 2e			ld a, (.dmark)  
2e1e 32 b4 fe			ld (debug_mark),a  
2e21 3a 30 2e			ld a, (.dmark+1)  
2e24 32 b5 fe			ld (debug_mark+1),a  
2e27 3a 31 2e			ld a, (.dmark+2)  
2e2a 32 b6 fe			ld (debug_mark+2),a  
2e2d 18 03			jr .pastdmark  
2e2f ..			.dmark: db "NOP"  
2e32 f1			.pastdmark: pop af  
2e33			endm  
# End of macro DMARK
2e33						CALLMONITOR 
2e33 cd 7e 18			call break_point_state  
2e36				endm  
# End of macro CALLMONITOR
2e36					endif 
2e36				       NEXTW 
2e36 c3 60 22			jp macro_next 
2e39				endm 
# End of macro NEXTW
2e39			.COMO: 
2e39				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2e39 6e				db WORD_SYS_CORE+90             
2e3a 8b 2e			dw .COMC            
2e3c 02				db 1 + 1 
2e3d .. 00			db "(",0              
2e3f				endm 
# End of macro CWHEAD
2e3f			; | ( ( -- )  Start of comment | DONE 
2e3f			 
2e3f			 
2e3f 2a 84 f6				ld hl, ( os_tok_ptr) 
2e42 11 86 2e			ld de, .closepar 
2e45					 
2e45					if DEBUG_FORTH_WORDS 
2e45						DMARK ").." 
2e45 f5				push af  
2e46 3a 5a 2e			ld a, (.dmark)  
2e49 32 b4 fe			ld (debug_mark),a  
2e4c 3a 5b 2e			ld a, (.dmark+1)  
2e4f 32 b5 fe			ld (debug_mark+1),a  
2e52 3a 5c 2e			ld a, (.dmark+2)  
2e55 32 b6 fe			ld (debug_mark+2),a  
2e58 18 03			jr .pastdmark  
2e5a ..			.dmark: db ").."  
2e5d f1			.pastdmark: pop af  
2e5e			endm  
# End of macro DMARK
2e5e						CALLMONITOR 
2e5e cd 7e 18			call break_point_state  
2e61				endm  
# End of macro CALLMONITOR
2e61					endif 
2e61 cd 7b 23			call findnexttok  
2e64			 
2e64					if DEBUG_FORTH_WORDS 
2e64						DMARK "IF5" 
2e64 f5				push af  
2e65 3a 79 2e			ld a, (.dmark)  
2e68 32 b4 fe			ld (debug_mark),a  
2e6b 3a 7a 2e			ld a, (.dmark+1)  
2e6e 32 b5 fe			ld (debug_mark+1),a  
2e71 3a 7b 2e			ld a, (.dmark+2)  
2e74 32 b6 fe			ld (debug_mark+2),a  
2e77 18 03			jr .pastdmark  
2e79 ..			.dmark: db "IF5"  
2e7c f1			.pastdmark: pop af  
2e7d			endm  
# End of macro DMARK
2e7d						CALLMONITOR 
2e7d cd 7e 18			call break_point_state  
2e80				endm  
# End of macro CALLMONITOR
2e80					endif 
2e80				; replace below with ) exec using tok_ptr 
2e80 22 84 f6			ld (os_tok_ptr), hl 
2e83 c3 f1 22			jp exec1 
2e86			 
2e86 .. 00			.closepar:   db ")",0 
2e88			 
2e88				       NEXTW 
2e88 c3 60 22			jp macro_next 
2e8b				endm 
# End of macro NEXTW
2e8b			.COMC: 
2e8b				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2e8b 6f				db WORD_SYS_CORE+91             
2e8c 94 2e			dw .SCRATCH            
2e8e 02				db 1 + 1 
2e8f .. 00			db ")",0              
2e91				endm 
# End of macro CWHEAD
2e91			; | ) ( -- )  End of comment |  DONE  
2e91				       NEXTW 
2e91 c3 60 22			jp macro_next 
2e94				endm 
# End of macro NEXTW
2e94			 
2e94			.SCRATCH: 
2e94				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2e94 6f				db WORD_SYS_CORE+91             
2e95 cf 2e			dw .INC            
2e97 08				db 7 + 1 
2e98 .. 00			db "SCRATCH",0              
2ea0				endm 
# End of macro CWHEAD
2ea0			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2ea0			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2ea0			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2ea0			; | |  
2ea0			; | | e.g.    : score $00 scratch ; 
2ea0			; | |  
2ea0			; | | $00 score ! 
2ea0			; | | $01 score +! 
2ea0			; | |  
2ea0			; | | e.g.   : varword $0a scratch ;  
2ea0			; | | 
2ea0			; | | $8000 varword ! 
2ea0					if DEBUG_FORTH_WORDS_KEY 
2ea0						DMARK "SCR" 
2ea0 f5				push af  
2ea1 3a b5 2e			ld a, (.dmark)  
2ea4 32 b4 fe			ld (debug_mark),a  
2ea7 3a b6 2e			ld a, (.dmark+1)  
2eaa 32 b5 fe			ld (debug_mark+1),a  
2ead 3a b7 2e			ld a, (.dmark+2)  
2eb0 32 b6 fe			ld (debug_mark+2),a  
2eb3 18 03			jr .pastdmark  
2eb5 ..			.dmark: db "SCR"  
2eb8 f1			.pastdmark: pop af  
2eb9			endm  
# End of macro DMARK
2eb9						CALLMONITOR 
2eb9 cd 7e 18			call break_point_state  
2ebc				endm  
# End of macro CALLMONITOR
2ebc					endif 
2ebc			 
2ebc					FORTH_DSP_VALUEHL 
2ebc cd e9 20			call macro_dsp_valuehl 
2ebf				endm 
# End of macro FORTH_DSP_VALUEHL
2ebf				 
2ebf					FORTH_DSP_POP 
2ebf cd a1 21			call macro_forth_dsp_pop 
2ec2				endm 
# End of macro FORTH_DSP_POP
2ec2			 
2ec2 7d					ld a, l 
2ec3 21 a8 f8				ld hl, os_var_array 
2ec6 cd 01 0f				call addatohl 
2ec9			 
2ec9 cd f2 1e				call forth_push_numhl 
2ecc			 
2ecc				       NEXTW 
2ecc c3 60 22			jp macro_next 
2ecf				endm 
# End of macro NEXTW
2ecf			 
2ecf			.INC: 
2ecf				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ecf 6f				db WORD_SYS_CORE+91             
2ed0 23 2f			dw .DEC            
2ed2 03				db 2 + 1 
2ed3 .. 00			db "+!",0              
2ed6				endm 
# End of macro CWHEAD
2ed6			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2ed6					if DEBUG_FORTH_WORDS_KEY 
2ed6						DMARK "+s_" 
2ed6 f5				push af  
2ed7 3a eb 2e			ld a, (.dmark)  
2eda 32 b4 fe			ld (debug_mark),a  
2edd 3a ec 2e			ld a, (.dmark+1)  
2ee0 32 b5 fe			ld (debug_mark+1),a  
2ee3 3a ed 2e			ld a, (.dmark+2)  
2ee6 32 b6 fe			ld (debug_mark+2),a  
2ee9 18 03			jr .pastdmark  
2eeb ..			.dmark: db "+s_"  
2eee f1			.pastdmark: pop af  
2eef			endm  
# End of macro DMARK
2eef						CALLMONITOR 
2eef cd 7e 18			call break_point_state  
2ef2				endm  
# End of macro CALLMONITOR
2ef2					endif 
2ef2			 
2ef2					FORTH_DSP_VALUEHL 
2ef2 cd e9 20			call macro_dsp_valuehl 
2ef5				endm 
# End of macro FORTH_DSP_VALUEHL
2ef5			 
2ef5 e5					push hl   ; save address 
2ef6			 
2ef6					FORTH_DSP_POP 
2ef6 cd a1 21			call macro_forth_dsp_pop 
2ef9				endm 
# End of macro FORTH_DSP_POP
2ef9			 
2ef9					FORTH_DSP_VALUEHL 
2ef9 cd e9 20			call macro_dsp_valuehl 
2efc				endm 
# End of macro FORTH_DSP_VALUEHL
2efc			 
2efc					FORTH_DSP_POP 
2efc cd a1 21			call macro_forth_dsp_pop 
2eff				endm 
# End of macro FORTH_DSP_POP
2eff			 
2eff					; hl contains value to add to byte at a 
2eff				 
2eff eb					ex de, hl 
2f00			 
2f00 e1					pop hl 
2f01			 
2f01					if DEBUG_FORTH_WORDS 
2f01						DMARK "INC" 
2f01 f5				push af  
2f02 3a 16 2f			ld a, (.dmark)  
2f05 32 b4 fe			ld (debug_mark),a  
2f08 3a 17 2f			ld a, (.dmark+1)  
2f0b 32 b5 fe			ld (debug_mark+1),a  
2f0e 3a 18 2f			ld a, (.dmark+2)  
2f11 32 b6 fe			ld (debug_mark+2),a  
2f14 18 03			jr .pastdmark  
2f16 ..			.dmark: db "INC"  
2f19 f1			.pastdmark: pop af  
2f1a			endm  
# End of macro DMARK
2f1a						CALLMONITOR 
2f1a cd 7e 18			call break_point_state  
2f1d				endm  
# End of macro CALLMONITOR
2f1d					endif 
2f1d			 
2f1d 7e					ld a,(hl) 
2f1e 83					add e 
2f1f 77					ld (hl),a 
2f20			 
2f20			 
2f20			 
2f20				       NEXTW 
2f20 c3 60 22			jp macro_next 
2f23				endm 
# End of macro NEXTW
2f23			 
2f23			.DEC: 
2f23				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2f23 6f				db WORD_SYS_CORE+91             
2f24 74 2f			dw .INC2            
2f26 03				db 2 + 1 
2f27 .. 00			db "-!",0              
2f2a				endm 
# End of macro CWHEAD
2f2a			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2f2a					if DEBUG_FORTH_WORDS_KEY 
2f2a						DMARK "-s_" 
2f2a f5				push af  
2f2b 3a 3f 2f			ld a, (.dmark)  
2f2e 32 b4 fe			ld (debug_mark),a  
2f31 3a 40 2f			ld a, (.dmark+1)  
2f34 32 b5 fe			ld (debug_mark+1),a  
2f37 3a 41 2f			ld a, (.dmark+2)  
2f3a 32 b6 fe			ld (debug_mark+2),a  
2f3d 18 03			jr .pastdmark  
2f3f ..			.dmark: db "-s_"  
2f42 f1			.pastdmark: pop af  
2f43			endm  
# End of macro DMARK
2f43						CALLMONITOR 
2f43 cd 7e 18			call break_point_state  
2f46				endm  
# End of macro CALLMONITOR
2f46					endif 
2f46			 
2f46					FORTH_DSP_VALUEHL 
2f46 cd e9 20			call macro_dsp_valuehl 
2f49				endm 
# End of macro FORTH_DSP_VALUEHL
2f49			 
2f49 e5					push hl   ; save address 
2f4a			 
2f4a					FORTH_DSP_POP 
2f4a cd a1 21			call macro_forth_dsp_pop 
2f4d				endm 
# End of macro FORTH_DSP_POP
2f4d			 
2f4d					FORTH_DSP_VALUEHL 
2f4d cd e9 20			call macro_dsp_valuehl 
2f50				endm 
# End of macro FORTH_DSP_VALUEHL
2f50			 
2f50					; hl contains value to add to byte at a 
2f50				 
2f50 eb					ex de, hl 
2f51			 
2f51 e1					pop hl 
2f52			 
2f52					if DEBUG_FORTH_WORDS 
2f52						DMARK "DEC" 
2f52 f5				push af  
2f53 3a 67 2f			ld a, (.dmark)  
2f56 32 b4 fe			ld (debug_mark),a  
2f59 3a 68 2f			ld a, (.dmark+1)  
2f5c 32 b5 fe			ld (debug_mark+1),a  
2f5f 3a 69 2f			ld a, (.dmark+2)  
2f62 32 b6 fe			ld (debug_mark+2),a  
2f65 18 03			jr .pastdmark  
2f67 ..			.dmark: db "DEC"  
2f6a f1			.pastdmark: pop af  
2f6b			endm  
# End of macro DMARK
2f6b						CALLMONITOR 
2f6b cd 7e 18			call break_point_state  
2f6e				endm  
# End of macro CALLMONITOR
2f6e					endif 
2f6e			 
2f6e 7e					ld a,(hl) 
2f6f 93					sub e 
2f70 77					ld (hl),a 
2f71			 
2f71			 
2f71			 
2f71				       NEXTW 
2f71 c3 60 22			jp macro_next 
2f74				endm 
# End of macro NEXTW
2f74			 
2f74			.INC2: 
2f74				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2f74 6f				db WORD_SYS_CORE+91             
2f75 1e 30			dw .DEC2            
2f77 04				db 3 + 1 
2f78 .. 00			db "+2!",0              
2f7c				endm 
# End of macro CWHEAD
2f7c			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2f7c			 
2f7c					if DEBUG_FORTH_WORDS_KEY 
2f7c						DMARK "+2s" 
2f7c f5				push af  
2f7d 3a 91 2f			ld a, (.dmark)  
2f80 32 b4 fe			ld (debug_mark),a  
2f83 3a 92 2f			ld a, (.dmark+1)  
2f86 32 b5 fe			ld (debug_mark+1),a  
2f89 3a 93 2f			ld a, (.dmark+2)  
2f8c 32 b6 fe			ld (debug_mark+2),a  
2f8f 18 03			jr .pastdmark  
2f91 ..			.dmark: db "+2s"  
2f94 f1			.pastdmark: pop af  
2f95			endm  
# End of macro DMARK
2f95						CALLMONITOR 
2f95 cd 7e 18			call break_point_state  
2f98				endm  
# End of macro CALLMONITOR
2f98					endif 
2f98			 
2f98					; Address 
2f98			 
2f98					FORTH_DSP_VALUEHL 
2f98 cd e9 20			call macro_dsp_valuehl 
2f9b				endm 
# End of macro FORTH_DSP_VALUEHL
2f9b			 
2f9b e5					push hl    ; save address 
2f9c			 
2f9c					; load content into de 
2f9c			 
2f9c 5e					ld e,(hl) 
2f9d 23					inc hl 
2f9e 56					ld d, (hl) 
2f9f			 
2f9f					if DEBUG_FORTH_WORDS 
2f9f						DMARK "+2a" 
2f9f f5				push af  
2fa0 3a b4 2f			ld a, (.dmark)  
2fa3 32 b4 fe			ld (debug_mark),a  
2fa6 3a b5 2f			ld a, (.dmark+1)  
2fa9 32 b5 fe			ld (debug_mark+1),a  
2fac 3a b6 2f			ld a, (.dmark+2)  
2faf 32 b6 fe			ld (debug_mark+2),a  
2fb2 18 03			jr .pastdmark  
2fb4 ..			.dmark: db "+2a"  
2fb7 f1			.pastdmark: pop af  
2fb8			endm  
# End of macro DMARK
2fb8						CALLMONITOR 
2fb8 cd 7e 18			call break_point_state  
2fbb				endm  
# End of macro CALLMONITOR
2fbb					endif 
2fbb			 
2fbb					FORTH_DSP_POP 
2fbb cd a1 21			call macro_forth_dsp_pop 
2fbe				endm 
# End of macro FORTH_DSP_POP
2fbe			 
2fbe					; Get value to add 
2fbe			 
2fbe					FORTH_DSP_VALUE 
2fbe cd d2 20			call macro_forth_dsp_value 
2fc1				endm 
# End of macro FORTH_DSP_VALUE
2fc1			 
2fc1					if DEBUG_FORTH_WORDS 
2fc1						DMARK "+2v" 
2fc1 f5				push af  
2fc2 3a d6 2f			ld a, (.dmark)  
2fc5 32 b4 fe			ld (debug_mark),a  
2fc8 3a d7 2f			ld a, (.dmark+1)  
2fcb 32 b5 fe			ld (debug_mark+1),a  
2fce 3a d8 2f			ld a, (.dmark+2)  
2fd1 32 b6 fe			ld (debug_mark+2),a  
2fd4 18 03			jr .pastdmark  
2fd6 ..			.dmark: db "+2v"  
2fd9 f1			.pastdmark: pop af  
2fda			endm  
# End of macro DMARK
2fda						CALLMONITOR 
2fda cd 7e 18			call break_point_state  
2fdd				endm  
# End of macro CALLMONITOR
2fdd					endif 
2fdd			 
2fdd 19					add hl, de 
2fde			 
2fde					if DEBUG_FORTH_WORDS 
2fde						DMARK "+2+" 
2fde f5				push af  
2fdf 3a f3 2f			ld a, (.dmark)  
2fe2 32 b4 fe			ld (debug_mark),a  
2fe5 3a f4 2f			ld a, (.dmark+1)  
2fe8 32 b5 fe			ld (debug_mark+1),a  
2feb 3a f5 2f			ld a, (.dmark+2)  
2fee 32 b6 fe			ld (debug_mark+2),a  
2ff1 18 03			jr .pastdmark  
2ff3 ..			.dmark: db "+2+"  
2ff6 f1			.pastdmark: pop af  
2ff7			endm  
# End of macro DMARK
2ff7						CALLMONITOR 
2ff7 cd 7e 18			call break_point_state  
2ffa				endm  
# End of macro CALLMONITOR
2ffa					endif 
2ffa			 
2ffa					; move result to de 
2ffa			 
2ffa eb					ex de, hl 
2ffb			 
2ffb					; Address 
2ffb			 
2ffb e1					pop hl 
2ffc			 
2ffc					; save it back 
2ffc			 
2ffc 73					ld (hl), e 
2ffd 23					inc hl 
2ffe 72					ld (hl), d 
2fff			 
2fff					if DEBUG_FORTH_WORDS 
2fff						DMARK "+2e" 
2fff f5				push af  
3000 3a 14 30			ld a, (.dmark)  
3003 32 b4 fe			ld (debug_mark),a  
3006 3a 15 30			ld a, (.dmark+1)  
3009 32 b5 fe			ld (debug_mark+1),a  
300c 3a 16 30			ld a, (.dmark+2)  
300f 32 b6 fe			ld (debug_mark+2),a  
3012 18 03			jr .pastdmark  
3014 ..			.dmark: db "+2e"  
3017 f1			.pastdmark: pop af  
3018			endm  
# End of macro DMARK
3018						CALLMONITOR 
3018 cd 7e 18			call break_point_state  
301b				endm  
# End of macro CALLMONITOR
301b					endif 
301b			 
301b			 
301b			 
301b			 
301b			 
301b				       NEXTW 
301b c3 60 22			jp macro_next 
301e				endm 
# End of macro NEXTW
301e			 
301e			.DEC2: 
301e				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
301e 6f				db WORD_SYS_CORE+91             
301f ca 30			dw .GET2            
3021 04				db 3 + 1 
3022 .. 00			db "-2!",0              
3026				endm 
# End of macro CWHEAD
3026			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3026			 
3026			 
3026					if DEBUG_FORTH_WORDS_KEY 
3026						DMARK "-2s" 
3026 f5				push af  
3027 3a 3b 30			ld a, (.dmark)  
302a 32 b4 fe			ld (debug_mark),a  
302d 3a 3c 30			ld a, (.dmark+1)  
3030 32 b5 fe			ld (debug_mark+1),a  
3033 3a 3d 30			ld a, (.dmark+2)  
3036 32 b6 fe			ld (debug_mark+2),a  
3039 18 03			jr .pastdmark  
303b ..			.dmark: db "-2s"  
303e f1			.pastdmark: pop af  
303f			endm  
# End of macro DMARK
303f						CALLMONITOR 
303f cd 7e 18			call break_point_state  
3042				endm  
# End of macro CALLMONITOR
3042					endif 
3042			 
3042					; Address 
3042			 
3042					FORTH_DSP_VALUEHL 
3042 cd e9 20			call macro_dsp_valuehl 
3045				endm 
# End of macro FORTH_DSP_VALUEHL
3045			 
3045 e5					push hl    ; save address 
3046			 
3046					; load content into de 
3046			 
3046 5e					ld e,(hl) 
3047 23					inc hl 
3048 56					ld d, (hl) 
3049			 
3049					if DEBUG_FORTH_WORDS 
3049						DMARK "-2a" 
3049 f5				push af  
304a 3a 5e 30			ld a, (.dmark)  
304d 32 b4 fe			ld (debug_mark),a  
3050 3a 5f 30			ld a, (.dmark+1)  
3053 32 b5 fe			ld (debug_mark+1),a  
3056 3a 60 30			ld a, (.dmark+2)  
3059 32 b6 fe			ld (debug_mark+2),a  
305c 18 03			jr .pastdmark  
305e ..			.dmark: db "-2a"  
3061 f1			.pastdmark: pop af  
3062			endm  
# End of macro DMARK
3062						CALLMONITOR 
3062 cd 7e 18			call break_point_state  
3065				endm  
# End of macro CALLMONITOR
3065					endif 
3065			 
3065					FORTH_DSP_POP 
3065 cd a1 21			call macro_forth_dsp_pop 
3068				endm 
# End of macro FORTH_DSP_POP
3068			 
3068					; Get value to remove 
3068			 
3068					FORTH_DSP_VALUE 
3068 cd d2 20			call macro_forth_dsp_value 
306b				endm 
# End of macro FORTH_DSP_VALUE
306b			 
306b					if DEBUG_FORTH_WORDS 
306b						DMARK "-2v" 
306b f5				push af  
306c 3a 80 30			ld a, (.dmark)  
306f 32 b4 fe			ld (debug_mark),a  
3072 3a 81 30			ld a, (.dmark+1)  
3075 32 b5 fe			ld (debug_mark+1),a  
3078 3a 82 30			ld a, (.dmark+2)  
307b 32 b6 fe			ld (debug_mark+2),a  
307e 18 03			jr .pastdmark  
3080 ..			.dmark: db "-2v"  
3083 f1			.pastdmark: pop af  
3084			endm  
# End of macro DMARK
3084						CALLMONITOR 
3084 cd 7e 18			call break_point_state  
3087				endm  
# End of macro CALLMONITOR
3087					endif 
3087			 
3087 eb					ex de, hl 
3088 ed 52				sbc hl, de 
308a			 
308a					if DEBUG_FORTH_WORDS 
308a						DMARK "-2d" 
308a f5				push af  
308b 3a 9f 30			ld a, (.dmark)  
308e 32 b4 fe			ld (debug_mark),a  
3091 3a a0 30			ld a, (.dmark+1)  
3094 32 b5 fe			ld (debug_mark+1),a  
3097 3a a1 30			ld a, (.dmark+2)  
309a 32 b6 fe			ld (debug_mark+2),a  
309d 18 03			jr .pastdmark  
309f ..			.dmark: db "-2d"  
30a2 f1			.pastdmark: pop af  
30a3			endm  
# End of macro DMARK
30a3						CALLMONITOR 
30a3 cd 7e 18			call break_point_state  
30a6				endm  
# End of macro CALLMONITOR
30a6					endif 
30a6			 
30a6					; move result to de 
30a6			 
30a6 eb					ex de, hl 
30a7			 
30a7					; Address 
30a7			 
30a7 e1					pop hl 
30a8			 
30a8					; save it back 
30a8			 
30a8 73					ld (hl), e 
30a9 23					inc hl 
30aa 72					ld (hl), d 
30ab			 
30ab					if DEBUG_FORTH_WORDS 
30ab						DMARK "-2e" 
30ab f5				push af  
30ac 3a c0 30			ld a, (.dmark)  
30af 32 b4 fe			ld (debug_mark),a  
30b2 3a c1 30			ld a, (.dmark+1)  
30b5 32 b5 fe			ld (debug_mark+1),a  
30b8 3a c2 30			ld a, (.dmark+2)  
30bb 32 b6 fe			ld (debug_mark+2),a  
30be 18 03			jr .pastdmark  
30c0 ..			.dmark: db "-2e"  
30c3 f1			.pastdmark: pop af  
30c4			endm  
# End of macro DMARK
30c4						CALLMONITOR 
30c4 cd 7e 18			call break_point_state  
30c7				endm  
# End of macro CALLMONITOR
30c7					endif 
30c7			 
30c7			 
30c7			 
30c7			 
30c7			 
30c7				       NEXTW 
30c7 c3 60 22			jp macro_next 
30ca				endm 
# End of macro NEXTW
30ca			.GET2: 
30ca				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
30ca 6f				db WORD_SYS_CORE+91             
30cb fa 30			dw .BANG2            
30cd 03				db 2 + 1 
30ce .. 00			db "2@",0              
30d1				endm 
# End of macro CWHEAD
30d1			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
30d1					if DEBUG_FORTH_WORDS_KEY 
30d1						DMARK "2A_" 
30d1 f5				push af  
30d2 3a e6 30			ld a, (.dmark)  
30d5 32 b4 fe			ld (debug_mark),a  
30d8 3a e7 30			ld a, (.dmark+1)  
30db 32 b5 fe			ld (debug_mark+1),a  
30de 3a e8 30			ld a, (.dmark+2)  
30e1 32 b6 fe			ld (debug_mark+2),a  
30e4 18 03			jr .pastdmark  
30e6 ..			.dmark: db "2A_"  
30e9 f1			.pastdmark: pop af  
30ea			endm  
# End of macro DMARK
30ea						CALLMONITOR 
30ea cd 7e 18			call break_point_state  
30ed				endm  
# End of macro CALLMONITOR
30ed					endif 
30ed			 
30ed					FORTH_DSP_VALUEHL 
30ed cd e9 20			call macro_dsp_valuehl 
30f0				endm 
# End of macro FORTH_DSP_VALUEHL
30f0			 
30f0 5e					ld e, (hl) 
30f1 23					inc hl 
30f2 56					ld d, (hl) 
30f3			 
30f3 eb					ex de, hl 
30f4			 
30f4 cd f2 1e				call forth_push_numhl 
30f7			 
30f7				       NEXTW 
30f7 c3 60 22			jp macro_next 
30fa				endm 
# End of macro NEXTW
30fa			.BANG2: 
30fa				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
30fa 6f				db WORD_SYS_CORE+91             
30fb 32 31			dw .CONFIG            
30fd 03				db 2 + 1 
30fe .. 00			db "2!",0              
3101				endm 
# End of macro CWHEAD
3101			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3101					if DEBUG_FORTH_WORDS_KEY 
3101						DMARK "2S_" 
3101 f5				push af  
3102 3a 16 31			ld a, (.dmark)  
3105 32 b4 fe			ld (debug_mark),a  
3108 3a 17 31			ld a, (.dmark+1)  
310b 32 b5 fe			ld (debug_mark+1),a  
310e 3a 18 31			ld a, (.dmark+2)  
3111 32 b6 fe			ld (debug_mark+2),a  
3114 18 03			jr .pastdmark  
3116 ..			.dmark: db "2S_"  
3119 f1			.pastdmark: pop af  
311a			endm  
# End of macro DMARK
311a						CALLMONITOR 
311a cd 7e 18			call break_point_state  
311d				endm  
# End of macro CALLMONITOR
311d					endif 
311d			 
311d					FORTH_DSP_VALUEHL 
311d cd e9 20			call macro_dsp_valuehl 
3120				endm 
# End of macro FORTH_DSP_VALUEHL
3120			 
3120 e5					push hl   ; save address 
3121			 
3121			 
3121					FORTH_DSP_POP 
3121 cd a1 21			call macro_forth_dsp_pop 
3124				endm 
# End of macro FORTH_DSP_POP
3124			 
3124					 
3124					FORTH_DSP_VALUEHL 
3124 cd e9 20			call macro_dsp_valuehl 
3127				endm 
# End of macro FORTH_DSP_VALUEHL
3127			 
3127					FORTH_DSP_POP 
3127 cd a1 21			call macro_forth_dsp_pop 
312a				endm 
# End of macro FORTH_DSP_POP
312a			 
312a eb					ex de, hl    ; value now in de 
312b			 
312b e1					pop hl 
312c			 
312c 73					ld (hl), e 
312d			 
312d 23					inc hl 
312e			 
312e 72					ld (hl), d 
312f			 
312f			 
312f				       NEXTW 
312f c3 60 22			jp macro_next 
3132				endm 
# End of macro NEXTW
3132			.CONFIG: 
3132				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
3132 6f				db WORD_SYS_CORE+91             
3133 43 31			dw .ENDCORE            
3135 07				db 6 + 1 
3136 .. 00			db "CONFIG",0              
313d				endm 
# End of macro CWHEAD
313d			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
313d			 
313d cd 61 15				call config 
3140					NEXTW 
3140 c3 60 22			jp macro_next 
3143				endm 
# End of macro NEXTW
3143			.ENDCORE: 
3143			 
3143			; eof 
3143			 
3143			 
# End of file forth_words_core.asm
3143			include "forth_words_flow.asm" 
3143			 
3143			; | ## Program Flow Words 
3143			 
3143			.IF: 
3143				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3143 1e				db WORD_SYS_CORE+10             
3144 38 32			dw .THEN            
3146 03				db 2 + 1 
3147 .. 00			db "IF",0              
314a				endm 
# End of macro CWHEAD
314a			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
314a			; 
314a					if DEBUG_FORTH_WORDS_KEY 
314a						DMARK "IF." 
314a f5				push af  
314b 3a 5f 31			ld a, (.dmark)  
314e 32 b4 fe			ld (debug_mark),a  
3151 3a 60 31			ld a, (.dmark+1)  
3154 32 b5 fe			ld (debug_mark+1),a  
3157 3a 61 31			ld a, (.dmark+2)  
315a 32 b6 fe			ld (debug_mark+2),a  
315d 18 03			jr .pastdmark  
315f ..			.dmark: db "IF."  
3162 f1			.pastdmark: pop af  
3163			endm  
# End of macro DMARK
3163						CALLMONITOR 
3163 cd 7e 18			call break_point_state  
3166				endm  
# End of macro CALLMONITOR
3166					endif 
3166			; eval TOS 
3166			 
3166				FORTH_DSP_VALUEHL 
3166 cd e9 20			call macro_dsp_valuehl 
3169				endm 
# End of macro FORTH_DSP_VALUEHL
3169			 
3169			;	push hl 
3169				FORTH_DSP_POP 
3169 cd a1 21			call macro_forth_dsp_pop 
316c				endm 
# End of macro FORTH_DSP_POP
316c			;	pop hl 
316c			 
316c					if DEBUG_FORTH_WORDS 
316c						DMARK "IF1" 
316c f5				push af  
316d 3a 81 31			ld a, (.dmark)  
3170 32 b4 fe			ld (debug_mark),a  
3173 3a 82 31			ld a, (.dmark+1)  
3176 32 b5 fe			ld (debug_mark+1),a  
3179 3a 83 31			ld a, (.dmark+2)  
317c 32 b6 fe			ld (debug_mark+2),a  
317f 18 03			jr .pastdmark  
3181 ..			.dmark: db "IF1"  
3184 f1			.pastdmark: pop af  
3185			endm  
# End of macro DMARK
3185						CALLMONITOR 
3185 cd 7e 18			call break_point_state  
3188				endm  
# End of macro CALLMONITOR
3188					endif 
3188 b7				or a        ; clear carry flag 
3189 11 00 00			ld de, 0 
318c eb				ex de,hl 
318d ed 52			sbc hl, de 
318f c2 19 32			jp nz, .iftrue 
3192			 
3192					if DEBUG_FORTH_WORDS 
3192						DMARK "IF2" 
3192 f5				push af  
3193 3a a7 31			ld a, (.dmark)  
3196 32 b4 fe			ld (debug_mark),a  
3199 3a a8 31			ld a, (.dmark+1)  
319c 32 b5 fe			ld (debug_mark+1),a  
319f 3a a9 31			ld a, (.dmark+2)  
31a2 32 b6 fe			ld (debug_mark+2),a  
31a5 18 03			jr .pastdmark  
31a7 ..			.dmark: db "IF2"  
31aa f1			.pastdmark: pop af  
31ab			endm  
# End of macro DMARK
31ab						CALLMONITOR 
31ab cd 7e 18			call break_point_state  
31ae				endm  
# End of macro CALLMONITOR
31ae					endif 
31ae			 
31ae			; if not true then skip to THEN 
31ae			 
31ae				; TODO get tok_ptr 
31ae				; TODO consume toks until we get to THEN 
31ae			 
31ae 2a 84 f6			ld hl, (os_tok_ptr) 
31b1					if DEBUG_FORTH_WORDS 
31b1						DMARK "IF3" 
31b1 f5				push af  
31b2 3a c6 31			ld a, (.dmark)  
31b5 32 b4 fe			ld (debug_mark),a  
31b8 3a c7 31			ld a, (.dmark+1)  
31bb 32 b5 fe			ld (debug_mark+1),a  
31be 3a c8 31			ld a, (.dmark+2)  
31c1 32 b6 fe			ld (debug_mark+2),a  
31c4 18 03			jr .pastdmark  
31c6 ..			.dmark: db "IF3"  
31c9 f1			.pastdmark: pop af  
31ca			endm  
# End of macro DMARK
31ca						CALLMONITOR 
31ca cd 7e 18			call break_point_state  
31cd				endm  
# End of macro CALLMONITOR
31cd						 
31cd					endif 
31cd 11 14 32			ld de, .ifthen 
31d0					if DEBUG_FORTH_WORDS 
31d0						DMARK "IF4" 
31d0 f5				push af  
31d1 3a e5 31			ld a, (.dmark)  
31d4 32 b4 fe			ld (debug_mark),a  
31d7 3a e6 31			ld a, (.dmark+1)  
31da 32 b5 fe			ld (debug_mark+1),a  
31dd 3a e7 31			ld a, (.dmark+2)  
31e0 32 b6 fe			ld (debug_mark+2),a  
31e3 18 03			jr .pastdmark  
31e5 ..			.dmark: db "IF4"  
31e8 f1			.pastdmark: pop af  
31e9			endm  
# End of macro DMARK
31e9						CALLMONITOR 
31e9 cd 7e 18			call break_point_state  
31ec				endm  
# End of macro CALLMONITOR
31ec					endif 
31ec cd 7b 23			call findnexttok  
31ef			 
31ef					if DEBUG_FORTH_WORDS 
31ef						DMARK "IF5" 
31ef f5				push af  
31f0 3a 04 32			ld a, (.dmark)  
31f3 32 b4 fe			ld (debug_mark),a  
31f6 3a 05 32			ld a, (.dmark+1)  
31f9 32 b5 fe			ld (debug_mark+1),a  
31fc 3a 06 32			ld a, (.dmark+2)  
31ff 32 b6 fe			ld (debug_mark+2),a  
3202 18 03			jr .pastdmark  
3204 ..			.dmark: db "IF5"  
3207 f1			.pastdmark: pop af  
3208			endm  
# End of macro DMARK
3208						CALLMONITOR 
3208 cd 7e 18			call break_point_state  
320b				endm  
# End of macro CALLMONITOR
320b					endif 
320b				; TODO replace below with ; exec using tok_ptr 
320b 22 84 f6			ld (os_tok_ptr), hl 
320e c3 f1 22			jp exec1 
3211				NEXTW 
3211 c3 60 22			jp macro_next 
3214				endm 
# End of macro NEXTW
3214			 
3214 .. 00		.ifthen:  db "THEN",0 
3219			 
3219			.iftrue:		 
3219				; Exec next words normally 
3219			 
3219				; if true then exec following IF as normal 
3219					if DEBUG_FORTH_WORDS 
3219						DMARK "IFT" 
3219 f5				push af  
321a 3a 2e 32			ld a, (.dmark)  
321d 32 b4 fe			ld (debug_mark),a  
3220 3a 2f 32			ld a, (.dmark+1)  
3223 32 b5 fe			ld (debug_mark+1),a  
3226 3a 30 32			ld a, (.dmark+2)  
3229 32 b6 fe			ld (debug_mark+2),a  
322c 18 03			jr .pastdmark  
322e ..			.dmark: db "IFT"  
3231 f1			.pastdmark: pop af  
3232			endm  
# End of macro DMARK
3232						CALLMONITOR 
3232 cd 7e 18			call break_point_state  
3235				endm  
# End of macro CALLMONITOR
3235					endif 
3235			 
3235					NEXTW 
3235 c3 60 22			jp macro_next 
3238				endm 
# End of macro NEXTW
3238			.THEN: 
3238				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3238 1f				db WORD_SYS_CORE+11             
3239 60 32			dw .ELSE            
323b 05				db 4 + 1 
323c .. 00			db "THEN",0              
3241				endm 
# End of macro CWHEAD
3241			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3241					if DEBUG_FORTH_WORDS_KEY 
3241						DMARK "THN" 
3241 f5				push af  
3242 3a 56 32			ld a, (.dmark)  
3245 32 b4 fe			ld (debug_mark),a  
3248 3a 57 32			ld a, (.dmark+1)  
324b 32 b5 fe			ld (debug_mark+1),a  
324e 3a 58 32			ld a, (.dmark+2)  
3251 32 b6 fe			ld (debug_mark+2),a  
3254 18 03			jr .pastdmark  
3256 ..			.dmark: db "THN"  
3259 f1			.pastdmark: pop af  
325a			endm  
# End of macro DMARK
325a						CALLMONITOR 
325a cd 7e 18			call break_point_state  
325d				endm  
# End of macro CALLMONITOR
325d					endif 
325d					NEXTW 
325d c3 60 22			jp macro_next 
3260				endm 
# End of macro NEXTW
3260			.ELSE: 
3260				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3260 20				db WORD_SYS_CORE+12             
3261 88 32			dw .DO            
3263 03				db 2 + 1 
3264 .. 00			db "ELSE",0              
3269				endm 
# End of macro CWHEAD
3269			; | ELSE ( -- ) Not supported - does nothing | TODO 
3269			 
3269					if DEBUG_FORTH_WORDS_KEY 
3269						DMARK "ELS" 
3269 f5				push af  
326a 3a 7e 32			ld a, (.dmark)  
326d 32 b4 fe			ld (debug_mark),a  
3270 3a 7f 32			ld a, (.dmark+1)  
3273 32 b5 fe			ld (debug_mark+1),a  
3276 3a 80 32			ld a, (.dmark+2)  
3279 32 b6 fe			ld (debug_mark+2),a  
327c 18 03			jr .pastdmark  
327e ..			.dmark: db "ELS"  
3281 f1			.pastdmark: pop af  
3282			endm  
# End of macro DMARK
3282						CALLMONITOR 
3282 cd 7e 18			call break_point_state  
3285				endm  
# End of macro CALLMONITOR
3285					endif 
3285			 
3285			 
3285					NEXTW 
3285 c3 60 22			jp macro_next 
3288				endm 
# End of macro NEXTW
3288			.DO: 
3288				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3288 21				db WORD_SYS_CORE+13             
3289 af 33			dw .LOOP            
328b 03				db 2 + 1 
328c .. 00			db "DO",0              
328f				endm 
# End of macro CWHEAD
328f			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
328f			 
328f					if DEBUG_FORTH_WORDS_KEY 
328f						DMARK "DO." 
328f f5				push af  
3290 3a a4 32			ld a, (.dmark)  
3293 32 b4 fe			ld (debug_mark),a  
3296 3a a5 32			ld a, (.dmark+1)  
3299 32 b5 fe			ld (debug_mark+1),a  
329c 3a a6 32			ld a, (.dmark+2)  
329f 32 b6 fe			ld (debug_mark+2),a  
32a2 18 03			jr .pastdmark  
32a4 ..			.dmark: db "DO."  
32a7 f1			.pastdmark: pop af  
32a8			endm  
# End of macro DMARK
32a8						CALLMONITOR 
32a8 cd 7e 18			call break_point_state  
32ab				endm  
# End of macro CALLMONITOR
32ab					endif 
32ab			;  push pc to rsp stack past the DO 
32ab			 
32ab 2a 84 f6				ld hl, (os_tok_ptr) 
32ae 23					inc hl   ; D 
32af 23					inc hl  ; O 
32b0 23					inc hl   ; null 
32b1					if DEBUG_FORTH_WORDS 
32b1						DMARK "DO2" 
32b1 f5				push af  
32b2 3a c6 32			ld a, (.dmark)  
32b5 32 b4 fe			ld (debug_mark),a  
32b8 3a c7 32			ld a, (.dmark+1)  
32bb 32 b5 fe			ld (debug_mark+1),a  
32be 3a c8 32			ld a, (.dmark+2)  
32c1 32 b6 fe			ld (debug_mark+2),a  
32c4 18 03			jr .pastdmark  
32c6 ..			.dmark: db "DO2"  
32c9 f1			.pastdmark: pop af  
32ca			endm  
# End of macro DMARK
32ca						CALLMONITOR 
32ca cd 7e 18			call break_point_state  
32cd				endm  
# End of macro CALLMONITOR
32cd					endif 
32cd					FORTH_RSP_NEXT 
32cd cd 99 1e			call macro_forth_rsp_next 
32d0				endm 
# End of macro FORTH_RSP_NEXT
32d0					if DEBUG_FORTH_WORDS 
32d0						DMARK "DO3" 
32d0 f5				push af  
32d1 3a e5 32			ld a, (.dmark)  
32d4 32 b4 fe			ld (debug_mark),a  
32d7 3a e6 32			ld a, (.dmark+1)  
32da 32 b5 fe			ld (debug_mark+1),a  
32dd 3a e7 32			ld a, (.dmark+2)  
32e0 32 b6 fe			ld (debug_mark+2),a  
32e3 18 03			jr .pastdmark  
32e5 ..			.dmark: db "DO3"  
32e8 f1			.pastdmark: pop af  
32e9			endm  
# End of macro DMARK
32e9						CALLMONITOR 
32e9 cd 7e 18			call break_point_state  
32ec				endm  
# End of macro CALLMONITOR
32ec					endif 
32ec			 
32ec					;if DEBUG_FORTH_WORDS 
32ec				;		push hl 
32ec			;		endif  
32ec			 
32ec			; get counters from data stack 
32ec			 
32ec			 
32ec					FORTH_DSP_VALUEHL 
32ec cd e9 20			call macro_dsp_valuehl 
32ef				endm 
# End of macro FORTH_DSP_VALUEHL
32ef e5					push hl		 ; hl now has starting counter which needs to be tos 
32f0			 
32f0					if DEBUG_FORTH_WORDS 
32f0						DMARK "DO4" 
32f0 f5				push af  
32f1 3a 05 33			ld a, (.dmark)  
32f4 32 b4 fe			ld (debug_mark),a  
32f7 3a 06 33			ld a, (.dmark+1)  
32fa 32 b5 fe			ld (debug_mark+1),a  
32fd 3a 07 33			ld a, (.dmark+2)  
3300 32 b6 fe			ld (debug_mark+2),a  
3303 18 03			jr .pastdmark  
3305 ..			.dmark: db "DO4"  
3308 f1			.pastdmark: pop af  
3309			endm  
# End of macro DMARK
3309						CALLMONITOR 
3309 cd 7e 18			call break_point_state  
330c				endm  
# End of macro CALLMONITOR
330c					endif 
330c					FORTH_DSP_POP 
330c cd a1 21			call macro_forth_dsp_pop 
330f				endm 
# End of macro FORTH_DSP_POP
330f			 
330f					if DEBUG_FORTH_WORDS 
330f						DMARK "DO5" 
330f f5				push af  
3310 3a 24 33			ld a, (.dmark)  
3313 32 b4 fe			ld (debug_mark),a  
3316 3a 25 33			ld a, (.dmark+1)  
3319 32 b5 fe			ld (debug_mark+1),a  
331c 3a 26 33			ld a, (.dmark+2)  
331f 32 b6 fe			ld (debug_mark+2),a  
3322 18 03			jr .pastdmark  
3324 ..			.dmark: db "DO5"  
3327 f1			.pastdmark: pop af  
3328			endm  
# End of macro DMARK
3328						CALLMONITOR 
3328 cd 7e 18			call break_point_state  
332b				endm  
# End of macro CALLMONITOR
332b					endif 
332b			 
332b					FORTH_DSP_VALUEHL 
332b cd e9 20			call macro_dsp_valuehl 
332e				endm 
# End of macro FORTH_DSP_VALUEHL
332e			;		push hl		 ; hl now has starting limit counter 
332e			 
332e					if DEBUG_FORTH_WORDS 
332e						DMARK "DO6" 
332e f5				push af  
332f 3a 43 33			ld a, (.dmark)  
3332 32 b4 fe			ld (debug_mark),a  
3335 3a 44 33			ld a, (.dmark+1)  
3338 32 b5 fe			ld (debug_mark+1),a  
333b 3a 45 33			ld a, (.dmark+2)  
333e 32 b6 fe			ld (debug_mark+2),a  
3341 18 03			jr .pastdmark  
3343 ..			.dmark: db "DO6"  
3346 f1			.pastdmark: pop af  
3347			endm  
# End of macro DMARK
3347						CALLMONITOR 
3347 cd 7e 18			call break_point_state  
334a				endm  
# End of macro CALLMONITOR
334a					endif 
334a					FORTH_DSP_POP 
334a cd a1 21			call macro_forth_dsp_pop 
334d				endm 
# End of macro FORTH_DSP_POP
334d			 
334d			; put counters on the loop stack 
334d			 
334d			;		pop hl			 ; limit counter 
334d d1					pop de			; start counter 
334e			 
334e					; push limit counter 
334e			 
334e					if DEBUG_FORTH_WORDS 
334e						DMARK "DO7" 
334e f5				push af  
334f 3a 63 33			ld a, (.dmark)  
3352 32 b4 fe			ld (debug_mark),a  
3355 3a 64 33			ld a, (.dmark+1)  
3358 32 b5 fe			ld (debug_mark+1),a  
335b 3a 65 33			ld a, (.dmark+2)  
335e 32 b6 fe			ld (debug_mark+2),a  
3361 18 03			jr .pastdmark  
3363 ..			.dmark: db "DO7"  
3366 f1			.pastdmark: pop af  
3367			endm  
# End of macro DMARK
3367						CALLMONITOR 
3367 cd 7e 18			call break_point_state  
336a				endm  
# End of macro CALLMONITOR
336a					endif 
336a					FORTH_LOOP_NEXT 
336a cd 1a 21			call macro_forth_loop_next 
336d				endm 
# End of macro FORTH_LOOP_NEXT
336d			 
336d					; push start counter 
336d			 
336d eb					ex de, hl 
336e					if DEBUG_FORTH_WORDS 
336e						DMARK "DO7" 
336e f5				push af  
336f 3a 83 33			ld a, (.dmark)  
3372 32 b4 fe			ld (debug_mark),a  
3375 3a 84 33			ld a, (.dmark+1)  
3378 32 b5 fe			ld (debug_mark+1),a  
337b 3a 85 33			ld a, (.dmark+2)  
337e 32 b6 fe			ld (debug_mark+2),a  
3381 18 03			jr .pastdmark  
3383 ..			.dmark: db "DO7"  
3386 f1			.pastdmark: pop af  
3387			endm  
# End of macro DMARK
3387						CALLMONITOR 
3387 cd 7e 18			call break_point_state  
338a				endm  
# End of macro CALLMONITOR
338a					endif 
338a					FORTH_LOOP_NEXT 
338a cd 1a 21			call macro_forth_loop_next 
338d				endm 
# End of macro FORTH_LOOP_NEXT
338d			 
338d			 
338d					; init first round of I counter 
338d			 
338d 22 a8 f6				ld (os_current_i), hl 
3390			 
3390					if DEBUG_FORTH_WORDS 
3390						DMARK "DO8" 
3390 f5				push af  
3391 3a a5 33			ld a, (.dmark)  
3394 32 b4 fe			ld (debug_mark),a  
3397 3a a6 33			ld a, (.dmark+1)  
339a 32 b5 fe			ld (debug_mark+1),a  
339d 3a a7 33			ld a, (.dmark+2)  
33a0 32 b6 fe			ld (debug_mark+2),a  
33a3 18 03			jr .pastdmark  
33a5 ..			.dmark: db "DO8"  
33a8 f1			.pastdmark: pop af  
33a9			endm  
# End of macro DMARK
33a9						CALLMONITOR 
33a9 cd 7e 18			call break_point_state  
33ac				endm  
# End of macro CALLMONITOR
33ac					endif 
33ac			 
33ac					NEXTW 
33ac c3 60 22			jp macro_next 
33af				endm 
# End of macro NEXTW
33af			.LOOP: 
33af				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
33af 22				db WORD_SYS_CORE+14             
33b0 c7 34			dw .I            
33b2 05				db 4 + 1 
33b3 .. 00			db "LOOP",0              
33b8				endm 
# End of macro CWHEAD
33b8			; | LOOP ( -- ) Increment and test loop counter  | DONE 
33b8			 
33b8				; pop tos as current loop count to hl 
33b8			 
33b8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33b8			 
33b8				FORTH_LOOP_TOS 
33b8 cd 4d 21			call macro_forth_loop_tos 
33bb				endm 
# End of macro FORTH_LOOP_TOS
33bb e5				push hl 
33bc			 
33bc					if DEBUG_FORTH_WORDS_KEY 
33bc						DMARK "LOP" 
33bc f5				push af  
33bd 3a d1 33			ld a, (.dmark)  
33c0 32 b4 fe			ld (debug_mark),a  
33c3 3a d2 33			ld a, (.dmark+1)  
33c6 32 b5 fe			ld (debug_mark+1),a  
33c9 3a d3 33			ld a, (.dmark+2)  
33cc 32 b6 fe			ld (debug_mark+2),a  
33cf 18 03			jr .pastdmark  
33d1 ..			.dmark: db "LOP"  
33d4 f1			.pastdmark: pop af  
33d5			endm  
# End of macro DMARK
33d5						CALLMONITOR 
33d5 cd 7e 18			call break_point_state  
33d8				endm  
# End of macro CALLMONITOR
33d8					endif 
33d8				; next item on the stack is the limit. get it 
33d8			 
33d8			 
33d8				FORTH_LOOP_POP 
33d8 cd 57 21			call macro_forth_loop_pop 
33db				endm 
# End of macro FORTH_LOOP_POP
33db			 
33db				FORTH_LOOP_TOS 
33db cd 4d 21			call macro_forth_loop_tos 
33de				endm 
# End of macro FORTH_LOOP_TOS
33de			 
33de d1				pop de		 ; de = i, hl = limit 
33df			 
33df					if DEBUG_FORTH_WORDS 
33df						DMARK "LP1" 
33df f5				push af  
33e0 3a f4 33			ld a, (.dmark)  
33e3 32 b4 fe			ld (debug_mark),a  
33e6 3a f5 33			ld a, (.dmark+1)  
33e9 32 b5 fe			ld (debug_mark+1),a  
33ec 3a f6 33			ld a, (.dmark+2)  
33ef 32 b6 fe			ld (debug_mark+2),a  
33f2 18 03			jr .pastdmark  
33f4 ..			.dmark: db "LP1"  
33f7 f1			.pastdmark: pop af  
33f8			endm  
# End of macro DMARK
33f8						CALLMONITOR 
33f8 cd 7e 18			call break_point_state  
33fb				endm  
# End of macro CALLMONITOR
33fb					endif 
33fb			 
33fb				; go back to previous word 
33fb			 
33fb d5				push de    ; save I for inc later 
33fc			 
33fc			 
33fc				; get limit 
33fc				;  is I at limit? 
33fc			 
33fc			 
33fc					if DEBUG_FORTH_WORDS 
33fc						DMARK "LP1" 
33fc f5				push af  
33fd 3a 11 34			ld a, (.dmark)  
3400 32 b4 fe			ld (debug_mark),a  
3403 3a 12 34			ld a, (.dmark+1)  
3406 32 b5 fe			ld (debug_mark+1),a  
3409 3a 13 34			ld a, (.dmark+2)  
340c 32 b6 fe			ld (debug_mark+2),a  
340f 18 03			jr .pastdmark  
3411 ..			.dmark: db "LP1"  
3414 f1			.pastdmark: pop af  
3415			endm  
# End of macro DMARK
3415						CALLMONITOR 
3415 cd 7e 18			call break_point_state  
3418				endm  
# End of macro CALLMONITOR
3418					endif 
3418			 
3418 ed 52			sbc hl, de 
341a			 
341a			 
341a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
341a			 
341a 20 26				jr nz, .loopnotdone 
341c			 
341c e1				pop hl   ; get rid of saved I 
341d				FORTH_LOOP_POP     ; get rid of limit 
341d cd 57 21			call macro_forth_loop_pop 
3420				endm 
# End of macro FORTH_LOOP_POP
3420			 
3420				FORTH_RSP_POP     ; get rid of DO ptr 
3420 cd ba 1e			call macro_forth_rsp_pop 
3423				endm 
# End of macro FORTH_RSP_POP
3423			 
3423			if DEBUG_FORTH_WORDS 
3423						DMARK "LP>" 
3423 f5				push af  
3424 3a 38 34			ld a, (.dmark)  
3427 32 b4 fe			ld (debug_mark),a  
342a 3a 39 34			ld a, (.dmark+1)  
342d 32 b5 fe			ld (debug_mark+1),a  
3430 3a 3a 34			ld a, (.dmark+2)  
3433 32 b6 fe			ld (debug_mark+2),a  
3436 18 03			jr .pastdmark  
3438 ..			.dmark: db "LP>"  
343b f1			.pastdmark: pop af  
343c			endm  
# End of macro DMARK
343c				CALLMONITOR 
343c cd 7e 18			call break_point_state  
343f				endm  
# End of macro CALLMONITOR
343f			endif 
343f			 
343f					NEXTW 
343f c3 60 22			jp macro_next 
3442				endm 
# End of macro NEXTW
3442				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3442			 
3442			.loopnotdone: 
3442			 
3442 e1				pop hl    ; get I 
3443 23				inc hl 
3444			 
3444			   	; save new I 
3444			 
3444			 
3444					; set I counter 
3444			 
3444 22 a8 f6				ld (os_current_i), hl 
3447			 
3447					if DEBUG_FORTH_WORDS 
3447						DMARK "LPN" 
3447 f5				push af  
3448 3a 5c 34			ld a, (.dmark)  
344b 32 b4 fe			ld (debug_mark),a  
344e 3a 5d 34			ld a, (.dmark+1)  
3451 32 b5 fe			ld (debug_mark+1),a  
3454 3a 5e 34			ld a, (.dmark+2)  
3457 32 b6 fe			ld (debug_mark+2),a  
345a 18 03			jr .pastdmark  
345c ..			.dmark: db "LPN"  
345f f1			.pastdmark: pop af  
3460			endm  
# End of macro DMARK
3460					CALLMONITOR 
3460 cd 7e 18			call break_point_state  
3463				endm  
# End of macro CALLMONITOR
3463					endif 
3463					 
3463				FORTH_LOOP_NEXT 
3463 cd 1a 21			call macro_forth_loop_next 
3466				endm 
# End of macro FORTH_LOOP_NEXT
3466			 
3466			 
3466					if DEBUG_FORTH_WORDS 
3466 eb						ex de,hl 
3467					endif 
3467			 
3467			;	; get DO ptr 
3467			; 
3467					if DEBUG_FORTH_WORDS 
3467						DMARK "LP7" 
3467 f5				push af  
3468 3a 7c 34			ld a, (.dmark)  
346b 32 b4 fe			ld (debug_mark),a  
346e 3a 7d 34			ld a, (.dmark+1)  
3471 32 b5 fe			ld (debug_mark+1),a  
3474 3a 7e 34			ld a, (.dmark+2)  
3477 32 b6 fe			ld (debug_mark+2),a  
347a 18 03			jr .pastdmark  
347c ..			.dmark: db "LP7"  
347f f1			.pastdmark: pop af  
3480			endm  
# End of macro DMARK
3480					CALLMONITOR 
3480 cd 7e 18			call break_point_state  
3483				endm  
# End of macro CALLMONITOR
3483					endif 
3483				FORTH_RSP_TOS 
3483 cd b0 1e			call macro_forth_rsp_tos 
3486				endm 
# End of macro FORTH_RSP_TOS
3486			 
3486					if DEBUG_FORTH_WORDS 
3486						DMARK "LP8" 
3486 f5				push af  
3487 3a 9b 34			ld a, (.dmark)  
348a 32 b4 fe			ld (debug_mark),a  
348d 3a 9c 34			ld a, (.dmark+1)  
3490 32 b5 fe			ld (debug_mark+1),a  
3493 3a 9d 34			ld a, (.dmark+2)  
3496 32 b6 fe			ld (debug_mark+2),a  
3499 18 03			jr .pastdmark  
349b ..			.dmark: db "LP8"  
349e f1			.pastdmark: pop af  
349f			endm  
# End of macro DMARK
349f					CALLMONITOR 
349f cd 7e 18			call break_point_state  
34a2				endm  
# End of macro CALLMONITOR
34a2					endif 
34a2				;push hl 
34a2			 
34a2				; not going to DO any more 
34a2				; get rid of the RSP pointer as DO will add it back in 
34a2				;FORTH_RSP_POP 
34a2				;pop hl 
34a2			 
34a2				;ld hl,(cli_ret_sp) 
34a2				;ld e, (hl) 
34a2				;inc hl 
34a2				;ld d, (hl) 
34a2				;ex de,hl 
34a2 22 84 f6			ld (os_tok_ptr), hl 
34a5					if DEBUG_FORTH_WORDS 
34a5						DMARK "LP<" 
34a5 f5				push af  
34a6 3a ba 34			ld a, (.dmark)  
34a9 32 b4 fe			ld (debug_mark),a  
34ac 3a bb 34			ld a, (.dmark+1)  
34af 32 b5 fe			ld (debug_mark+1),a  
34b2 3a bc 34			ld a, (.dmark+2)  
34b5 32 b6 fe			ld (debug_mark+2),a  
34b8 18 03			jr .pastdmark  
34ba ..			.dmark: db "LP<"  
34bd f1			.pastdmark: pop af  
34be			endm  
# End of macro DMARK
34be					CALLMONITOR 
34be cd 7e 18			call break_point_state  
34c1				endm  
# End of macro CALLMONITOR
34c1				endif 
34c1 c3 f1 22			jp exec1 
34c4			 
34c4					 
34c4			 
34c4			 
34c4					NEXTW 
34c4 c3 60 22			jp macro_next 
34c7				endm 
# End of macro NEXTW
34c7			.I:  
34c7			 
34c7				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
34c7 5e				db WORD_SYS_CORE+74             
34c8 f2 34			dw .DLOOP            
34ca 02				db 1 + 1 
34cb .. 00			db "I",0              
34cd				endm 
# End of macro CWHEAD
34cd			; | I ( -- ) Current loop counter | DONE 
34cd					if DEBUG_FORTH_WORDS_KEY 
34cd						DMARK "I.." 
34cd f5				push af  
34ce 3a e2 34			ld a, (.dmark)  
34d1 32 b4 fe			ld (debug_mark),a  
34d4 3a e3 34			ld a, (.dmark+1)  
34d7 32 b5 fe			ld (debug_mark+1),a  
34da 3a e4 34			ld a, (.dmark+2)  
34dd 32 b6 fe			ld (debug_mark+2),a  
34e0 18 03			jr .pastdmark  
34e2 ..			.dmark: db "I.."  
34e5 f1			.pastdmark: pop af  
34e6			endm  
# End of macro DMARK
34e6						CALLMONITOR 
34e6 cd 7e 18			call break_point_state  
34e9				endm  
# End of macro CALLMONITOR
34e9					endif 
34e9			 
34e9 2a a8 f6				ld hl,(os_current_i) 
34ec cd f2 1e				call forth_push_numhl 
34ef			 
34ef					NEXTW 
34ef c3 60 22			jp macro_next 
34f2				endm 
# End of macro NEXTW
34f2			.DLOOP: 
34f2				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
34f2 5f				db WORD_SYS_CORE+75             
34f3 d3 35			dw .REPEAT            
34f5 06				db 5 + 1 
34f6 .. 00			db "-LOOP",0              
34fc				endm 
# End of macro CWHEAD
34fc			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
34fc				; pop tos as current loop count to hl 
34fc					if DEBUG_FORTH_WORDS_KEY 
34fc						DMARK "-LP" 
34fc f5				push af  
34fd 3a 11 35			ld a, (.dmark)  
3500 32 b4 fe			ld (debug_mark),a  
3503 3a 12 35			ld a, (.dmark+1)  
3506 32 b5 fe			ld (debug_mark+1),a  
3509 3a 13 35			ld a, (.dmark+2)  
350c 32 b6 fe			ld (debug_mark+2),a  
350f 18 03			jr .pastdmark  
3511 ..			.dmark: db "-LP"  
3514 f1			.pastdmark: pop af  
3515			endm  
# End of macro DMARK
3515						CALLMONITOR 
3515 cd 7e 18			call break_point_state  
3518				endm  
# End of macro CALLMONITOR
3518					endif 
3518			 
3518				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3518			 
3518				FORTH_LOOP_TOS 
3518 cd 4d 21			call macro_forth_loop_tos 
351b				endm 
# End of macro FORTH_LOOP_TOS
351b e5				push hl 
351c			 
351c					if DEBUG_FORTH_WORDS 
351c						DMARK "-LP" 
351c f5				push af  
351d 3a 31 35			ld a, (.dmark)  
3520 32 b4 fe			ld (debug_mark),a  
3523 3a 32 35			ld a, (.dmark+1)  
3526 32 b5 fe			ld (debug_mark+1),a  
3529 3a 33 35			ld a, (.dmark+2)  
352c 32 b6 fe			ld (debug_mark+2),a  
352f 18 03			jr .pastdmark  
3531 ..			.dmark: db "-LP"  
3534 f1			.pastdmark: pop af  
3535			endm  
# End of macro DMARK
3535						CALLMONITOR 
3535 cd 7e 18			call break_point_state  
3538				endm  
# End of macro CALLMONITOR
3538					endif 
3538				; next item on the stack is the limit. get it 
3538			 
3538			 
3538				FORTH_LOOP_POP 
3538 cd 57 21			call macro_forth_loop_pop 
353b				endm 
# End of macro FORTH_LOOP_POP
353b			 
353b				FORTH_LOOP_TOS 
353b cd 4d 21			call macro_forth_loop_tos 
353e				endm 
# End of macro FORTH_LOOP_TOS
353e			 
353e d1				pop de		 ; de = i, hl = limit 
353f			 
353f					if DEBUG_FORTH_WORDS 
353f						DMARK "-L1" 
353f f5				push af  
3540 3a 54 35			ld a, (.dmark)  
3543 32 b4 fe			ld (debug_mark),a  
3546 3a 55 35			ld a, (.dmark+1)  
3549 32 b5 fe			ld (debug_mark+1),a  
354c 3a 56 35			ld a, (.dmark+2)  
354f 32 b6 fe			ld (debug_mark+2),a  
3552 18 03			jr .pastdmark  
3554 ..			.dmark: db "-L1"  
3557 f1			.pastdmark: pop af  
3558			endm  
# End of macro DMARK
3558						CALLMONITOR 
3558 cd 7e 18			call break_point_state  
355b				endm  
# End of macro CALLMONITOR
355b					endif 
355b			 
355b				; go back to previous word 
355b			 
355b d5				push de    ; save I for inc later 
355c			 
355c			 
355c				; get limit 
355c				;  is I at limit? 
355c			 
355c			 
355c					if DEBUG_FORTH_WORDS 
355c						DMARK "-L1" 
355c f5				push af  
355d 3a 71 35			ld a, (.dmark)  
3560 32 b4 fe			ld (debug_mark),a  
3563 3a 72 35			ld a, (.dmark+1)  
3566 32 b5 fe			ld (debug_mark+1),a  
3569 3a 73 35			ld a, (.dmark+2)  
356c 32 b6 fe			ld (debug_mark+2),a  
356f 18 03			jr .pastdmark  
3571 ..			.dmark: db "-L1"  
3574 f1			.pastdmark: pop af  
3575			endm  
# End of macro DMARK
3575						CALLMONITOR 
3575 cd 7e 18			call break_point_state  
3578				endm  
# End of macro CALLMONITOR
3578					endif 
3578			 
3578 ed 52			sbc hl, de 
357a			 
357a			 
357a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
357a			 
357a 20 26				jr nz, .mloopnotdone 
357c			 
357c e1				pop hl   ; get rid of saved I 
357d				FORTH_LOOP_POP     ; get rid of limit 
357d cd 57 21			call macro_forth_loop_pop 
3580				endm 
# End of macro FORTH_LOOP_POP
3580			 
3580				FORTH_RSP_POP     ; get rid of DO ptr 
3580 cd ba 1e			call macro_forth_rsp_pop 
3583				endm 
# End of macro FORTH_RSP_POP
3583			 
3583			if DEBUG_FORTH_WORDS 
3583						DMARK "-L>" 
3583 f5				push af  
3584 3a 98 35			ld a, (.dmark)  
3587 32 b4 fe			ld (debug_mark),a  
358a 3a 99 35			ld a, (.dmark+1)  
358d 32 b5 fe			ld (debug_mark+1),a  
3590 3a 9a 35			ld a, (.dmark+2)  
3593 32 b6 fe			ld (debug_mark+2),a  
3596 18 03			jr .pastdmark  
3598 ..			.dmark: db "-L>"  
359b f1			.pastdmark: pop af  
359c			endm  
# End of macro DMARK
359c				CALLMONITOR 
359c cd 7e 18			call break_point_state  
359f				endm  
# End of macro CALLMONITOR
359f			endif 
359f			 
359f					NEXTW 
359f c3 60 22			jp macro_next 
35a2				endm 
# End of macro NEXTW
35a2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
35a2			 
35a2			.mloopnotdone: 
35a2			 
35a2 e1				pop hl    ; get I 
35a3 2b				dec hl 
35a4			 
35a4			   	; save new I 
35a4			 
35a4			 
35a4					; set I counter 
35a4			 
35a4 22 a8 f6				ld (os_current_i), hl 
35a7			 
35a7					 
35a7				FORTH_LOOP_NEXT 
35a7 cd 1a 21			call macro_forth_loop_next 
35aa				endm 
# End of macro FORTH_LOOP_NEXT
35aa			 
35aa			 
35aa					if DEBUG_FORTH_WORDS 
35aa eb						ex de,hl 
35ab					endif 
35ab			 
35ab			;	; get DO ptr 
35ab			; 
35ab				FORTH_RSP_TOS 
35ab cd b0 1e			call macro_forth_rsp_tos 
35ae				endm 
# End of macro FORTH_RSP_TOS
35ae			 
35ae				;push hl 
35ae			 
35ae				; not going to DO any more 
35ae				; get rid of the RSP pointer as DO will add it back in 
35ae				;FORTH_RSP_POP 
35ae				;pop hl 
35ae			 
35ae			 
35ae 22 84 f6			ld (os_tok_ptr), hl 
35b1					if DEBUG_FORTH_WORDS 
35b1						DMARK "-L<" 
35b1 f5				push af  
35b2 3a c6 35			ld a, (.dmark)  
35b5 32 b4 fe			ld (debug_mark),a  
35b8 3a c7 35			ld a, (.dmark+1)  
35bb 32 b5 fe			ld (debug_mark+1),a  
35be 3a c8 35			ld a, (.dmark+2)  
35c1 32 b6 fe			ld (debug_mark+2),a  
35c4 18 03			jr .pastdmark  
35c6 ..			.dmark: db "-L<"  
35c9 f1			.pastdmark: pop af  
35ca			endm  
# End of macro DMARK
35ca					CALLMONITOR 
35ca cd 7e 18			call break_point_state  
35cd				endm  
# End of macro CALLMONITOR
35cd				endif 
35cd c3 f1 22			jp exec1 
35d0			 
35d0					 
35d0			 
35d0			 
35d0			 
35d0				NEXTW 
35d0 c3 60 22			jp macro_next 
35d3				endm 
# End of macro NEXTW
35d3			 
35d3			 
35d3			 
35d3			 
35d3			.REPEAT: 
35d3				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
35d3 71				db WORD_SYS_CORE+93             
35d4 26 36			dw .UNTIL            
35d6 06				db 5 + 1 
35d7 .. 00			db "REPEAT",0              
35de				endm 
# End of macro CWHEAD
35de			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
35de			;  push pc to rsp stack past the REPEAT 
35de					if DEBUG_FORTH_WORDS_KEY 
35de						DMARK "REP" 
35de f5				push af  
35df 3a f3 35			ld a, (.dmark)  
35e2 32 b4 fe			ld (debug_mark),a  
35e5 3a f4 35			ld a, (.dmark+1)  
35e8 32 b5 fe			ld (debug_mark+1),a  
35eb 3a f5 35			ld a, (.dmark+2)  
35ee 32 b6 fe			ld (debug_mark+2),a  
35f1 18 03			jr .pastdmark  
35f3 ..			.dmark: db "REP"  
35f6 f1			.pastdmark: pop af  
35f7			endm  
# End of macro DMARK
35f7						CALLMONITOR 
35f7 cd 7e 18			call break_point_state  
35fa				endm  
# End of macro CALLMONITOR
35fa					endif 
35fa			 
35fa 2a 84 f6				ld hl, (os_tok_ptr) 
35fd 23					inc hl   ; R 
35fe 23					inc hl  ; E 
35ff 23					inc hl   ; P 
3600 23					inc hl   ; E 
3601 23					inc hl   ; A 
3602 23					inc hl   ; T 
3603 23					inc hl   ; zero 
3604					FORTH_RSP_NEXT 
3604 cd 99 1e			call macro_forth_rsp_next 
3607				endm 
# End of macro FORTH_RSP_NEXT
3607			 
3607			 
3607					if DEBUG_FORTH_WORDS 
3607						DMARK "REP" 
3607 f5				push af  
3608 3a 1c 36			ld a, (.dmark)  
360b 32 b4 fe			ld (debug_mark),a  
360e 3a 1d 36			ld a, (.dmark+1)  
3611 32 b5 fe			ld (debug_mark+1),a  
3614 3a 1e 36			ld a, (.dmark+2)  
3617 32 b6 fe			ld (debug_mark+2),a  
361a 18 03			jr .pastdmark  
361c ..			.dmark: db "REP"  
361f f1			.pastdmark: pop af  
3620			endm  
# End of macro DMARK
3620						;pop bc    ; TODO BUG ?????? what is this for???? 
3620						CALLMONITOR 
3620 cd 7e 18			call break_point_state  
3623				endm  
# End of macro CALLMONITOR
3623					endif 
3623			 
3623					NEXTW 
3623 c3 60 22			jp macro_next 
3626				endm 
# End of macro NEXTW
3626			;	       NEXTW 
3626			 
3626			.UNTIL: 
3626				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3626 72				db WORD_SYS_CORE+94             
3627 bd 36			dw .ENDFLOW            
3629 06				db 5 + 1 
362a .. 00			db "UNTIL",0              
3630				endm 
# End of macro CWHEAD
3630			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3630			 
3630				; pop tos as check 
3630			 
3630				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3630			 
3630				FORTH_DSP_VALUEHL 
3630 cd e9 20			call macro_dsp_valuehl 
3633				endm 
# End of macro FORTH_DSP_VALUEHL
3633			 
3633					if DEBUG_FORTH_WORDS_KEY 
3633						DMARK "UNT" 
3633 f5				push af  
3634 3a 48 36			ld a, (.dmark)  
3637 32 b4 fe			ld (debug_mark),a  
363a 3a 49 36			ld a, (.dmark+1)  
363d 32 b5 fe			ld (debug_mark+1),a  
3640 3a 4a 36			ld a, (.dmark+2)  
3643 32 b6 fe			ld (debug_mark+2),a  
3646 18 03			jr .pastdmark  
3648 ..			.dmark: db "UNT"  
364b f1			.pastdmark: pop af  
364c			endm  
# End of macro DMARK
364c						CALLMONITOR 
364c cd 7e 18			call break_point_state  
364f				endm  
# End of macro CALLMONITOR
364f					endif 
364f			 
364f			;	push hl 
364f				FORTH_DSP_POP 
364f cd a1 21			call macro_forth_dsp_pop 
3652				endm 
# End of macro FORTH_DSP_POP
3652			 
3652			;	pop hl 
3652			 
3652				; test if true 
3652			 
3652 cd 2a 0f			call ishlzero 
3655			;	ld a,l 
3655			;	add h 
3655			; 
3655			;	cp 0 
3655			 
3655 20 3e			jr nz, .untilnotdone 
3657			 
3657					if DEBUG_FORTH_WORDS 
3657						DMARK "UNf" 
3657 f5				push af  
3658 3a 6c 36			ld a, (.dmark)  
365b 32 b4 fe			ld (debug_mark),a  
365e 3a 6d 36			ld a, (.dmark+1)  
3661 32 b5 fe			ld (debug_mark+1),a  
3664 3a 6e 36			ld a, (.dmark+2)  
3667 32 b6 fe			ld (debug_mark+2),a  
366a 18 03			jr .pastdmark  
366c ..			.dmark: db "UNf"  
366f f1			.pastdmark: pop af  
3670			endm  
# End of macro DMARK
3670						CALLMONITOR 
3670 cd 7e 18			call break_point_state  
3673				endm  
# End of macro CALLMONITOR
3673					endif 
3673			 
3673			 
3673			 
3673				FORTH_RSP_POP     ; get rid of DO ptr 
3673 cd ba 1e			call macro_forth_rsp_pop 
3676				endm 
# End of macro FORTH_RSP_POP
3676			 
3676			if DEBUG_FORTH_WORDS 
3676						DMARK "UN>" 
3676 f5				push af  
3677 3a 8b 36			ld a, (.dmark)  
367a 32 b4 fe			ld (debug_mark),a  
367d 3a 8c 36			ld a, (.dmark+1)  
3680 32 b5 fe			ld (debug_mark+1),a  
3683 3a 8d 36			ld a, (.dmark+2)  
3686 32 b6 fe			ld (debug_mark+2),a  
3689 18 03			jr .pastdmark  
368b ..			.dmark: db "UN>"  
368e f1			.pastdmark: pop af  
368f			endm  
# End of macro DMARK
368f				CALLMONITOR 
368f cd 7e 18			call break_point_state  
3692				endm  
# End of macro CALLMONITOR
3692			endif 
3692			 
3692					NEXTW 
3692 c3 60 22			jp macro_next 
3695				endm 
# End of macro NEXTW
3695				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3695			 
3695			.untilnotdone: 
3695			 
3695			 
3695			;	; get DO ptr 
3695			; 
3695				FORTH_RSP_TOS 
3695 cd b0 1e			call macro_forth_rsp_tos 
3698				endm 
# End of macro FORTH_RSP_TOS
3698			 
3698				;push hl 
3698			 
3698				; not going to DO any more 
3698				; get rid of the RSP pointer as DO will add it back in 
3698				;FORTH_RSP_POP 
3698				;pop hl 
3698			 
3698			 
3698 22 84 f6			ld (os_tok_ptr), hl 
369b					if DEBUG_FORTH_WORDS 
369b						DMARK "UN<" 
369b f5				push af  
369c 3a b0 36			ld a, (.dmark)  
369f 32 b4 fe			ld (debug_mark),a  
36a2 3a b1 36			ld a, (.dmark+1)  
36a5 32 b5 fe			ld (debug_mark+1),a  
36a8 3a b2 36			ld a, (.dmark+2)  
36ab 32 b6 fe			ld (debug_mark+2),a  
36ae 18 03			jr .pastdmark  
36b0 ..			.dmark: db "UN<"  
36b3 f1			.pastdmark: pop af  
36b4			endm  
# End of macro DMARK
36b4					CALLMONITOR 
36b4 cd 7e 18			call break_point_state  
36b7				endm  
# End of macro CALLMONITOR
36b7				endif 
36b7 c3 f1 22			jp exec1 
36ba			 
36ba					 
36ba			 
36ba			 
36ba					NEXTW 
36ba c3 60 22			jp macro_next 
36bd				endm 
# End of macro NEXTW
36bd			 
36bd			 
36bd			.ENDFLOW: 
36bd			 
36bd			; eof 
36bd			 
# End of file forth_words_flow.asm
36bd			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
36bd			include "forth_words_logic.asm" 
36bd			 
36bd			; | ## Logic Words 
36bd			 
36bd			.NOT: 
36bd				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
36bd 2d				db WORD_SYS_CORE+25             
36be 05 37			dw .IS            
36c0 04				db 3 + 1 
36c1 .. 00			db "NOT",0              
36c5				endm 
# End of macro CWHEAD
36c5			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
36c5					if DEBUG_FORTH_WORDS_KEY 
36c5						DMARK "NOT" 
36c5 f5				push af  
36c6 3a da 36			ld a, (.dmark)  
36c9 32 b4 fe			ld (debug_mark),a  
36cc 3a db 36			ld a, (.dmark+1)  
36cf 32 b5 fe			ld (debug_mark+1),a  
36d2 3a dc 36			ld a, (.dmark+2)  
36d5 32 b6 fe			ld (debug_mark+2),a  
36d8 18 03			jr .pastdmark  
36da ..			.dmark: db "NOT"  
36dd f1			.pastdmark: pop af  
36de			endm  
# End of macro DMARK
36de						CALLMONITOR 
36de cd 7e 18			call break_point_state  
36e1				endm  
# End of macro CALLMONITOR
36e1					endif 
36e1					FORTH_DSP 
36e1 cd af 20			call macro_forth_dsp 
36e4				endm 
# End of macro FORTH_DSP
36e4 7e					ld a,(hl)	; get type of value on TOS 
36e5 fe 02				cp DS_TYPE_INUM  
36e7 28 03				jr z, .noti 
36e9					NEXTW 
36e9 c3 60 22			jp macro_next 
36ec				endm 
# End of macro NEXTW
36ec			.noti:          FORTH_DSP_VALUEHL 
36ec cd e9 20			call macro_dsp_valuehl 
36ef				endm 
# End of macro FORTH_DSP_VALUEHL
36ef			;		push hl 
36ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ef cd a1 21			call macro_forth_dsp_pop 
36f2				endm 
# End of macro FORTH_DSP_POP
36f2			;		pop hl 
36f2 3e 00				ld a,0 
36f4 bd					cp l 
36f5 28 04				jr z, .not2t 
36f7 2e 00				ld l, 0 
36f9 18 02				jr .notip 
36fb			 
36fb 2e ff		.not2t:		ld l, 255 
36fd			 
36fd 26 00		.notip:		ld h, 0	 
36ff			 
36ff cd f2 1e				call forth_push_numhl 
3702					NEXTW 
3702 c3 60 22			jp macro_next 
3705				endm 
# End of macro NEXTW
3705			 
3705			.IS: 
3705				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3705 2d				db WORD_SYS_CORE+25             
3706 2b 37			dw .LZERO            
3708 03				db 2 + 1 
3709 .. 00			db "IS",0              
370c				endm 
# End of macro CWHEAD
370c			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
370c					if DEBUG_FORTH_WORDS_KEY 
370c						DMARK "IS." 
370c f5				push af  
370d 3a 21 37			ld a, (.dmark)  
3710 32 b4 fe			ld (debug_mark),a  
3713 3a 22 37			ld a, (.dmark+1)  
3716 32 b5 fe			ld (debug_mark+1),a  
3719 3a 23 37			ld a, (.dmark+2)  
371c 32 b6 fe			ld (debug_mark+2),a  
371f 18 03			jr .pastdmark  
3721 ..			.dmark: db "IS."  
3724 f1			.pastdmark: pop af  
3725			endm  
# End of macro DMARK
3725						CALLMONITOR 
3725 cd 7e 18			call break_point_state  
3728				endm  
# End of macro CALLMONITOR
3728					endif 
3728					NEXTW 
3728 c3 60 22			jp macro_next 
372b				endm 
# End of macro NEXTW
372b			.LZERO: 
372b				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
372b 2d				db WORD_SYS_CORE+25             
372c 35 37			dw .TZERO            
372e 03				db 2 + 1 
372f .. 00			db "0<",0              
3732				endm 
# End of macro CWHEAD
3732			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3732					NEXTW 
3732 c3 60 22			jp macro_next 
3735				endm 
# End of macro NEXTW
3735			.TZERO: 
3735				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3735 2e				db WORD_SYS_CORE+26             
3736 7c 37			dw .LESS            
3738 03				db 2 + 1 
3739 .. 00			db "0=",0              
373c				endm 
# End of macro CWHEAD
373c			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
373c				; TODO add floating point number detection 
373c					;v5 FORTH_DSP_VALUE 
373c					if DEBUG_FORTH_WORDS_KEY 
373c						DMARK "0=." 
373c f5				push af  
373d 3a 51 37			ld a, (.dmark)  
3740 32 b4 fe			ld (debug_mark),a  
3743 3a 52 37			ld a, (.dmark+1)  
3746 32 b5 fe			ld (debug_mark+1),a  
3749 3a 53 37			ld a, (.dmark+2)  
374c 32 b6 fe			ld (debug_mark+2),a  
374f 18 03			jr .pastdmark  
3751 ..			.dmark: db "0=."  
3754 f1			.pastdmark: pop af  
3755			endm  
# End of macro DMARK
3755						CALLMONITOR 
3755 cd 7e 18			call break_point_state  
3758				endm  
# End of macro CALLMONITOR
3758					endif 
3758					FORTH_DSP 
3758 cd af 20			call macro_forth_dsp 
375b				endm 
# End of macro FORTH_DSP
375b 7e					ld a,(hl)	; get type of value on TOS 
375c fe 02				cp DS_TYPE_INUM  
375e 28 00				jr z, .tz_inum 
3760			 
3760				if FORTH_ENABLE_FLOATMATH 
3760					jr .tz_done 
3760			 
3760				endif 
3760					 
3760			 
3760			.tz_inum: 
3760					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3760 cd e9 20			call macro_dsp_valuehl 
3763				endm 
# End of macro FORTH_DSP_VALUEHL
3763			 
3763			;		push hl 
3763			 
3763					; destroy value TOS 
3763			 
3763					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3763 cd a1 21			call macro_forth_dsp_pop 
3766				endm 
# End of macro FORTH_DSP_POP
3766			 
3766			;		pop hl 
3766			 
3766 3e 00				ld a,0 
3768			 
3768 bd					cp l 
3769 20 08				jr nz, .tz_notzero 
376b			 
376b bc					cp h 
376c			 
376c 20 05				jr nz, .tz_notzero 
376e			 
376e			 
376e 21 01 00				ld hl, FORTH_TRUE 
3771 18 03				jr .tz_done 
3773			 
3773 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3776			 
3776					; push value back onto stack for another op etc 
3776			 
3776			.tz_done: 
3776 cd f2 1e				call forth_push_numhl 
3779			 
3779					NEXTW 
3779 c3 60 22			jp macro_next 
377c				endm 
# End of macro NEXTW
377c			.LESS: 
377c				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
377c 2f				db WORD_SYS_CORE+27             
377d e5 37			dw .GT            
377f 02				db 1 + 1 
3780 .. 00			db "<",0              
3782				endm 
# End of macro CWHEAD
3782			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3782				; TODO add floating point number detection 
3782					if DEBUG_FORTH_WORDS_KEY 
3782						DMARK "LES" 
3782 f5				push af  
3783 3a 97 37			ld a, (.dmark)  
3786 32 b4 fe			ld (debug_mark),a  
3789 3a 98 37			ld a, (.dmark+1)  
378c 32 b5 fe			ld (debug_mark+1),a  
378f 3a 99 37			ld a, (.dmark+2)  
3792 32 b6 fe			ld (debug_mark+2),a  
3795 18 03			jr .pastdmark  
3797 ..			.dmark: db "LES"  
379a f1			.pastdmark: pop af  
379b			endm  
# End of macro DMARK
379b						CALLMONITOR 
379b cd 7e 18			call break_point_state  
379e				endm  
# End of macro CALLMONITOR
379e					endif 
379e					FORTH_DSP 
379e cd af 20			call macro_forth_dsp 
37a1				endm 
# End of macro FORTH_DSP
37a1					;v5 FORTH_DSP_VALUE 
37a1 7e					ld a,(hl)	; get type of value on TOS 
37a2 fe 02				cp DS_TYPE_INUM  
37a4 28 00				jr z, .less_inum 
37a6			 
37a6				if FORTH_ENABLE_FLOATMATH 
37a6					jr .less_done 
37a6			 
37a6				endif 
37a6					 
37a6			 
37a6			.less_inum: 
37a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a6 cd e9 20			call macro_dsp_valuehl 
37a9				endm 
# End of macro FORTH_DSP_VALUEHL
37a9			 
37a9 e5					push hl  ; u2 
37aa			 
37aa					; destroy value TOS 
37aa			 
37aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37aa cd a1 21			call macro_forth_dsp_pop 
37ad				endm 
# End of macro FORTH_DSP_POP
37ad			 
37ad			 
37ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ad cd e9 20			call macro_dsp_valuehl 
37b0				endm 
# End of macro FORTH_DSP_VALUEHL
37b0			 
37b0 e5					push hl    ; u1 
37b1			 
37b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b1 cd a1 21			call macro_forth_dsp_pop 
37b4				endm 
# End of macro FORTH_DSP_POP
37b4			 
37b4			 
37b4 b7			 or a      ;clear carry flag 
37b5 01 00 00		 ld bc, FORTH_FALSE 
37b8 e1			  pop hl    ; u1 
37b9 d1			  pop de    ; u2 
37ba ed 52		  sbc hl,de 
37bc 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
37be			 
37be 01 01 00		 ld bc, FORTH_TRUE 
37c1			.lscont:  
37c1 c5					push bc 
37c2 e1					pop hl 
37c3			 
37c3					if DEBUG_FORTH_WORDS 
37c3						DMARK "LT1" 
37c3 f5				push af  
37c4 3a d8 37			ld a, (.dmark)  
37c7 32 b4 fe			ld (debug_mark),a  
37ca 3a d9 37			ld a, (.dmark+1)  
37cd 32 b5 fe			ld (debug_mark+1),a  
37d0 3a da 37			ld a, (.dmark+2)  
37d3 32 b6 fe			ld (debug_mark+2),a  
37d6 18 03			jr .pastdmark  
37d8 ..			.dmark: db "LT1"  
37db f1			.pastdmark: pop af  
37dc			endm  
# End of macro DMARK
37dc						CALLMONITOR 
37dc cd 7e 18			call break_point_state  
37df				endm  
# End of macro CALLMONITOR
37df					endif 
37df cd f2 1e				call forth_push_numhl 
37e2			 
37e2					NEXTW 
37e2 c3 60 22			jp macro_next 
37e5				endm 
# End of macro NEXTW
37e5			.GT: 
37e5				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
37e5 30				db WORD_SYS_CORE+28             
37e6 4e 38			dw .EQUAL            
37e8 02				db 1 + 1 
37e9 .. 00			db ">",0              
37eb				endm 
# End of macro CWHEAD
37eb			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
37eb				; TODO add floating point number detection 
37eb					if DEBUG_FORTH_WORDS_KEY 
37eb						DMARK "GRT" 
37eb f5				push af  
37ec 3a 00 38			ld a, (.dmark)  
37ef 32 b4 fe			ld (debug_mark),a  
37f2 3a 01 38			ld a, (.dmark+1)  
37f5 32 b5 fe			ld (debug_mark+1),a  
37f8 3a 02 38			ld a, (.dmark+2)  
37fb 32 b6 fe			ld (debug_mark+2),a  
37fe 18 03			jr .pastdmark  
3800 ..			.dmark: db "GRT"  
3803 f1			.pastdmark: pop af  
3804			endm  
# End of macro DMARK
3804						CALLMONITOR 
3804 cd 7e 18			call break_point_state  
3807				endm  
# End of macro CALLMONITOR
3807					endif 
3807					FORTH_DSP 
3807 cd af 20			call macro_forth_dsp 
380a				endm 
# End of macro FORTH_DSP
380a					;FORTH_DSP_VALUE 
380a 7e					ld a,(hl)	; get type of value on TOS 
380b fe 02				cp DS_TYPE_INUM  
380d 28 00				jr z, .gt_inum 
380f			 
380f				if FORTH_ENABLE_FLOATMATH 
380f					jr .gt_done 
380f			 
380f				endif 
380f					 
380f			 
380f			.gt_inum: 
380f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380f cd e9 20			call macro_dsp_valuehl 
3812				endm 
# End of macro FORTH_DSP_VALUEHL
3812			 
3812 e5					push hl  ; u2 
3813			 
3813					; destroy value TOS 
3813			 
3813					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3813 cd a1 21			call macro_forth_dsp_pop 
3816				endm 
# End of macro FORTH_DSP_POP
3816			 
3816			 
3816					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3816 cd e9 20			call macro_dsp_valuehl 
3819				endm 
# End of macro FORTH_DSP_VALUEHL
3819			 
3819 e5					push hl    ; u1 
381a			 
381a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
381a cd a1 21			call macro_forth_dsp_pop 
381d				endm 
# End of macro FORTH_DSP_POP
381d			 
381d			 
381d b7			 or a      ;clear carry flag 
381e 01 00 00		 ld bc, FORTH_FALSE 
3821 e1			  pop hl    ; u1 
3822 d1			  pop de    ; u2 
3823 ed 52		  sbc hl,de 
3825 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3827			 
3827 01 01 00		 ld bc, FORTH_TRUE 
382a			.gtcont:  
382a c5					push bc 
382b e1					pop hl 
382c			 
382c					if DEBUG_FORTH_WORDS 
382c						DMARK "GT1" 
382c f5				push af  
382d 3a 41 38			ld a, (.dmark)  
3830 32 b4 fe			ld (debug_mark),a  
3833 3a 42 38			ld a, (.dmark+1)  
3836 32 b5 fe			ld (debug_mark+1),a  
3839 3a 43 38			ld a, (.dmark+2)  
383c 32 b6 fe			ld (debug_mark+2),a  
383f 18 03			jr .pastdmark  
3841 ..			.dmark: db "GT1"  
3844 f1			.pastdmark: pop af  
3845			endm  
# End of macro DMARK
3845						CALLMONITOR 
3845 cd 7e 18			call break_point_state  
3848				endm  
# End of macro CALLMONITOR
3848					endif 
3848 cd f2 1e				call forth_push_numhl 
384b			 
384b					NEXTW 
384b c3 60 22			jp macro_next 
384e				endm 
# End of macro NEXTW
384e			.EQUAL: 
384e				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
384e 31				db WORD_SYS_CORE+29             
384f b9 38			dw .ENDLOGIC            
3851 02				db 1 + 1 
3852 .. 00			db "=",0              
3854				endm 
# End of macro CWHEAD
3854			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3854				; TODO add floating point number detection 
3854					if DEBUG_FORTH_WORDS_KEY 
3854						DMARK "EQ." 
3854 f5				push af  
3855 3a 69 38			ld a, (.dmark)  
3858 32 b4 fe			ld (debug_mark),a  
385b 3a 6a 38			ld a, (.dmark+1)  
385e 32 b5 fe			ld (debug_mark+1),a  
3861 3a 6b 38			ld a, (.dmark+2)  
3864 32 b6 fe			ld (debug_mark+2),a  
3867 18 03			jr .pastdmark  
3869 ..			.dmark: db "EQ."  
386c f1			.pastdmark: pop af  
386d			endm  
# End of macro DMARK
386d						CALLMONITOR 
386d cd 7e 18			call break_point_state  
3870				endm  
# End of macro CALLMONITOR
3870					endif 
3870					FORTH_DSP 
3870 cd af 20			call macro_forth_dsp 
3873				endm 
# End of macro FORTH_DSP
3873					;v5 FORTH_DSP_VALUE 
3873 7e					ld a,(hl)	; get type of value on TOS 
3874 fe 02				cp DS_TYPE_INUM  
3876 28 00				jr z, .eq_inum 
3878			 
3878				if FORTH_ENABLE_FLOATMATH 
3878					jr .eq_done 
3878			 
3878				endif 
3878					 
3878			 
3878			.eq_inum: 
3878					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3878 cd e9 20			call macro_dsp_valuehl 
387b				endm 
# End of macro FORTH_DSP_VALUEHL
387b			 
387b e5					push hl 
387c			 
387c					; destroy value TOS 
387c			 
387c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
387c cd a1 21			call macro_forth_dsp_pop 
387f				endm 
# End of macro FORTH_DSP_POP
387f			 
387f			 
387f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
387f cd e9 20			call macro_dsp_valuehl 
3882				endm 
# End of macro FORTH_DSP_VALUEHL
3882			 
3882					; one value on hl get other one back 
3882			 
3882 e5					push hl 
3883			 
3883					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3883 cd a1 21			call macro_forth_dsp_pop 
3886				endm 
# End of macro FORTH_DSP_POP
3886			 
3886 0e 00				ld c, FORTH_FALSE 
3888			 
3888 e1					pop hl 
3889 d1					pop de 
388a			 
388a 7b					ld a, e 
388b bd					cp l 
388c			 
388c 20 06				jr nz, .eq_done 
388e			 
388e 7a					ld a, d 
388f bc					cp h 
3890			 
3890 20 02				jr nz, .eq_done 
3892			 
3892 0e 01				ld c, FORTH_TRUE 
3894					 
3894			 
3894			 
3894			.eq_done: 
3894			 
3894					; TODO push value back onto stack for another op etc 
3894			 
3894 26 00				ld h, 0 
3896 69					ld l, c 
3897					if DEBUG_FORTH_WORDS 
3897						DMARK "EQ1" 
3897 f5				push af  
3898 3a ac 38			ld a, (.dmark)  
389b 32 b4 fe			ld (debug_mark),a  
389e 3a ad 38			ld a, (.dmark+1)  
38a1 32 b5 fe			ld (debug_mark+1),a  
38a4 3a ae 38			ld a, (.dmark+2)  
38a7 32 b6 fe			ld (debug_mark+2),a  
38aa 18 03			jr .pastdmark  
38ac ..			.dmark: db "EQ1"  
38af f1			.pastdmark: pop af  
38b0			endm  
# End of macro DMARK
38b0						CALLMONITOR 
38b0 cd 7e 18			call break_point_state  
38b3				endm  
# End of macro CALLMONITOR
38b3					endif 
38b3 cd f2 1e				call forth_push_numhl 
38b6			 
38b6					NEXTW 
38b6 c3 60 22			jp macro_next 
38b9				endm 
# End of macro NEXTW
38b9			 
38b9			 
38b9			.ENDLOGIC: 
38b9			; eof 
38b9			 
38b9			 
# End of file forth_words_logic.asm
38b9			include "forth_words_maths.asm" 
38b9			 
38b9			; | ## Maths Words 
38b9			 
38b9			.PLUS:	 
38b9				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
38b9 15				db WORD_SYS_CORE+1             
38ba fb 38			dw .NEG            
38bc 02				db 1 + 1 
38bd .. 00			db "+",0              
38bf				endm 
# End of macro CWHEAD
38bf			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
38bf					if DEBUG_FORTH_WORDS_KEY 
38bf						DMARK "PLU" 
38bf f5				push af  
38c0 3a d4 38			ld a, (.dmark)  
38c3 32 b4 fe			ld (debug_mark),a  
38c6 3a d5 38			ld a, (.dmark+1)  
38c9 32 b5 fe			ld (debug_mark+1),a  
38cc 3a d6 38			ld a, (.dmark+2)  
38cf 32 b6 fe			ld (debug_mark+2),a  
38d2 18 03			jr .pastdmark  
38d4 ..			.dmark: db "PLU"  
38d7 f1			.pastdmark: pop af  
38d8			endm  
# End of macro DMARK
38d8						CALLMONITOR 
38d8 cd 7e 18			call break_point_state  
38db				endm  
# End of macro CALLMONITOR
38db					endif 
38db					; add top two values and push back result 
38db			 
38db					;for v5 FORTH_DSP_VALUE 
38db					FORTH_DSP 
38db cd af 20			call macro_forth_dsp 
38de				endm 
# End of macro FORTH_DSP
38de 7e					ld a,(hl)	; get type of value on TOS 
38df fe 02				cp DS_TYPE_INUM  
38e1 28 03				jr z, .dot_inum 
38e3			 
38e3					NEXTW 
38e3 c3 60 22			jp macro_next 
38e6				endm 
# End of macro NEXTW
38e6			 
38e6			; float maths 
38e6			 
38e6				if FORTH_ENABLE_FLOATMATH 
38e6						inc hl      ; now at start of numeric as string 
38e6			 
38e6					if DEBUG_FORTH_MATHS 
38e6						DMARK "ADD" 
38e6				CALLMONITOR 
38e6					endif 
38e6			 
38e6					;ld ix, hl 
38e6					call CON 
38e6			 
38e6			 
38e6					push hl 
38e6					 
38e6					 
38e6			 
38e6						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
38e6			 
38e6					; get next number 
38e6			 
38e6						FORTH_DSP_VALUE 
38e6			 
38e6						inc hl      ; now at start of numeric as string 
38e6			 
38e6					;ld ix, hl 
38e6					call CON 
38e6			 
38e6					push hl 
38e6			 
38e6			 
38e6						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e6			 
38e6						; TODO do add 
38e6			 
38e6						call IADD 
38e6			 
38e6						; TODO get result back as ascii 
38e6			 
38e6						; TODO push result  
38e6			 
38e6			 
38e6			 
38e6						jr .dot_done 
38e6				endif 
38e6			 
38e6			.dot_inum: 
38e6			 
38e6			 
38e6					if DEBUG_FORTH_DOT 
38e6						DMARK "+IT" 
38e6				CALLMONITOR 
38e6					endif 
38e6			 
38e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38e6 cd e9 20			call macro_dsp_valuehl 
38e9				endm 
# End of macro FORTH_DSP_VALUEHL
38e9			 
38e9				; TODO add floating point number detection 
38e9			 
38e9 e5					push hl 
38ea			 
38ea					; destroy value TOS 
38ea			 
38ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ea cd a1 21			call macro_forth_dsp_pop 
38ed				endm 
# End of macro FORTH_DSP_POP
38ed			 
38ed			 
38ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ed cd e9 20			call macro_dsp_valuehl 
38f0				endm 
# End of macro FORTH_DSP_VALUEHL
38f0			 
38f0					; one value on hl get other one back 
38f0			 
38f0 d1					pop de 
38f1			 
38f1					; do the add 
38f1			 
38f1 19					add hl,de 
38f2			 
38f2					; save it 
38f2			 
38f2			;		push hl	 
38f2			 
38f2					; 
38f2			 
38f2					; destroy value TOS 
38f2			 
38f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38f2 cd a1 21			call macro_forth_dsp_pop 
38f5				endm 
# End of macro FORTH_DSP_POP
38f5			 
38f5					; TODO push value back onto stack for another op etc 
38f5			 
38f5			;		pop hl 
38f5			 
38f5			.dot_done: 
38f5 cd f2 1e				call forth_push_numhl 
38f8			 
38f8					NEXTW 
38f8 c3 60 22			jp macro_next 
38fb				endm 
# End of macro NEXTW
38fb			.NEG: 
38fb			 
38fb				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
38fb 17				db WORD_SYS_CORE+3             
38fc 3e 39			dw .DIV            
38fe 02				db 1 + 1 
38ff .. 00			db "-",0              
3901				endm 
# End of macro CWHEAD
3901			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3901					if DEBUG_FORTH_WORDS_KEY 
3901						DMARK "SUB" 
3901 f5				push af  
3902 3a 16 39			ld a, (.dmark)  
3905 32 b4 fe			ld (debug_mark),a  
3908 3a 17 39			ld a, (.dmark+1)  
390b 32 b5 fe			ld (debug_mark+1),a  
390e 3a 18 39			ld a, (.dmark+2)  
3911 32 b6 fe			ld (debug_mark+2),a  
3914 18 03			jr .pastdmark  
3916 ..			.dmark: db "SUB"  
3919 f1			.pastdmark: pop af  
391a			endm  
# End of macro DMARK
391a						CALLMONITOR 
391a cd 7e 18			call break_point_state  
391d				endm  
# End of macro CALLMONITOR
391d					endif 
391d			 
391d			 
391d				; TODO add floating point number detection 
391d					; v5 FORTH_DSP_VALUE 
391d					FORTH_DSP 
391d cd af 20			call macro_forth_dsp 
3920				endm 
# End of macro FORTH_DSP
3920 7e					ld a,(hl)	; get type of value on TOS 
3921 fe 02				cp DS_TYPE_INUM  
3923 28 03				jr z, .neg_inum 
3925			 
3925					NEXTW 
3925 c3 60 22			jp macro_next 
3928				endm 
# End of macro NEXTW
3928			 
3928			; float maths 
3928			 
3928				if FORTH_ENABLE_FLOATMATH 
3928					jr .neg_done 
3928			 
3928				endif 
3928					 
3928			 
3928			.neg_inum: 
3928					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3928 cd e9 20			call macro_dsp_valuehl 
392b				endm 
# End of macro FORTH_DSP_VALUEHL
392b			 
392b e5					push hl 
392c			 
392c					; destroy value TOS 
392c			 
392c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
392c cd a1 21			call macro_forth_dsp_pop 
392f				endm 
# End of macro FORTH_DSP_POP
392f			 
392f			 
392f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
392f cd e9 20			call macro_dsp_valuehl 
3932				endm 
# End of macro FORTH_DSP_VALUEHL
3932			 
3932					; one value on hl get other one back 
3932			 
3932 d1					pop de 
3933			 
3933					; do the sub 
3933			;		ex de, hl 
3933			 
3933 ed 52				sbc hl,de 
3935			 
3935					; save it 
3935			 
3935			;		push hl	 
3935			 
3935					; 
3935			 
3935					; destroy value TOS 
3935			 
3935					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3935 cd a1 21			call macro_forth_dsp_pop 
3938				endm 
# End of macro FORTH_DSP_POP
3938			 
3938					; TODO push value back onto stack for another op etc 
3938			 
3938			;		pop hl 
3938			 
3938 cd f2 1e				call forth_push_numhl 
393b			.neg_done: 
393b			 
393b					NEXTW 
393b c3 60 22			jp macro_next 
393e				endm 
# End of macro NEXTW
393e			.DIV: 
393e				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
393e 18				db WORD_SYS_CORE+4             
393f 8b 39			dw .MUL            
3941 02				db 1 + 1 
3942 .. 00			db "/",0              
3944				endm 
# End of macro CWHEAD
3944			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3944					if DEBUG_FORTH_WORDS_KEY 
3944						DMARK "DIV" 
3944 f5				push af  
3945 3a 59 39			ld a, (.dmark)  
3948 32 b4 fe			ld (debug_mark),a  
394b 3a 5a 39			ld a, (.dmark+1)  
394e 32 b5 fe			ld (debug_mark+1),a  
3951 3a 5b 39			ld a, (.dmark+2)  
3954 32 b6 fe			ld (debug_mark+2),a  
3957 18 03			jr .pastdmark  
3959 ..			.dmark: db "DIV"  
395c f1			.pastdmark: pop af  
395d			endm  
# End of macro DMARK
395d						CALLMONITOR 
395d cd 7e 18			call break_point_state  
3960				endm  
# End of macro CALLMONITOR
3960					endif 
3960				; TODO add floating point number detection 
3960					; v5 FORTH_DSP_VALUE 
3960					FORTH_DSP 
3960 cd af 20			call macro_forth_dsp 
3963				endm 
# End of macro FORTH_DSP
3963 7e					ld a,(hl)	; get type of value on TOS 
3964 fe 02				cp DS_TYPE_INUM  
3966 28 03				jr z, .div_inum 
3968			 
3968				if FORTH_ENABLE_FLOATMATH 
3968					jr .div_done 
3968			 
3968				endif 
3968					NEXTW 
3968 c3 60 22			jp macro_next 
396b				endm 
# End of macro NEXTW
396b			.div_inum: 
396b			 
396b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
396b cd e9 20			call macro_dsp_valuehl 
396e				endm 
# End of macro FORTH_DSP_VALUEHL
396e			 
396e e5					push hl    ; to go to bc 
396f			 
396f					; destroy value TOS 
396f			 
396f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
396f cd a1 21			call macro_forth_dsp_pop 
3972				endm 
# End of macro FORTH_DSP_POP
3972			 
3972			 
3972					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3972 cd e9 20			call macro_dsp_valuehl 
3975				endm 
# End of macro FORTH_DSP_VALUEHL
3975			 
3975					; hl to go to de 
3975			 
3975 e5					push hl 
3976			 
3976 c1					pop bc 
3977 d1					pop de		 
3978			 
3978			 
3978					if DEBUG_FORTH_MATHS 
3978						DMARK "DIV" 
3978				CALLMONITOR 
3978					endif 
3978					; one value on hl but move to a get other one back 
3978			 
3978			        
3978 cd 5e 0e			call Div16 
397b			 
397b			;	push af	 
397b e5				push hl 
397c c5				push bc 
397d			 
397d					if DEBUG_FORTH_MATHS 
397d						DMARK "DI1" 
397d				CALLMONITOR 
397d					endif 
397d			 
397d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
397d cd a1 21			call macro_forth_dsp_pop 
3980				endm 
# End of macro FORTH_DSP_POP
3980			 
3980			 
3980			 
3980 e1					pop hl    ; result 
3981			 
3981 cd f2 1e				call forth_push_numhl 
3984			 
3984 e1					pop hl    ; reminder 
3985			;		ld h,0 
3985			;		ld l,d 
3985			 
3985 cd f2 1e				call forth_push_numhl 
3988			.div_done: 
3988					NEXTW 
3988 c3 60 22			jp macro_next 
398b				endm 
# End of macro NEXTW
398b			.MUL: 
398b				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
398b 19				db WORD_SYS_CORE+5             
398c d0 39			dw .MIN            
398e 02				db 1 + 1 
398f .. 00			db "*",0              
3991				endm 
# End of macro CWHEAD
3991			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3991				; TODO add floating point number detection 
3991					if DEBUG_FORTH_WORDS_KEY 
3991						DMARK "MUL" 
3991 f5				push af  
3992 3a a6 39			ld a, (.dmark)  
3995 32 b4 fe			ld (debug_mark),a  
3998 3a a7 39			ld a, (.dmark+1)  
399b 32 b5 fe			ld (debug_mark+1),a  
399e 3a a8 39			ld a, (.dmark+2)  
39a1 32 b6 fe			ld (debug_mark+2),a  
39a4 18 03			jr .pastdmark  
39a6 ..			.dmark: db "MUL"  
39a9 f1			.pastdmark: pop af  
39aa			endm  
# End of macro DMARK
39aa						CALLMONITOR 
39aa cd 7e 18			call break_point_state  
39ad				endm  
# End of macro CALLMONITOR
39ad					endif 
39ad					FORTH_DSP 
39ad cd af 20			call macro_forth_dsp 
39b0				endm 
# End of macro FORTH_DSP
39b0					; v5 FORTH_DSP_VALUE 
39b0 7e					ld a,(hl)	; get type of value on TOS 
39b1 fe 02				cp DS_TYPE_INUM  
39b3 28 03				jr z, .mul_inum 
39b5			 
39b5				if FORTH_ENABLE_FLOATMATH 
39b5					jr .mul_done 
39b5			 
39b5				endif 
39b5			 
39b5					NEXTW 
39b5 c3 60 22			jp macro_next 
39b8				endm 
# End of macro NEXTW
39b8			.mul_inum:	 
39b8			 
39b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b8 cd e9 20			call macro_dsp_valuehl 
39bb				endm 
# End of macro FORTH_DSP_VALUEHL
39bb			 
39bb e5					push hl 
39bc			 
39bc					; destroy value TOS 
39bc			 
39bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39bc cd a1 21			call macro_forth_dsp_pop 
39bf				endm 
# End of macro FORTH_DSP_POP
39bf			 
39bf			 
39bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39bf cd e9 20			call macro_dsp_valuehl 
39c2				endm 
# End of macro FORTH_DSP_VALUEHL
39c2			 
39c2					; one value on hl but move to a get other one back 
39c2			 
39c2 7d					ld a, l 
39c3			 
39c3 d1					pop de 
39c4			 
39c4					; do the mull 
39c4			;		ex de, hl 
39c4			 
39c4 cd 84 0e				call Mult16 
39c7					; save it 
39c7			 
39c7			;		push hl	 
39c7			 
39c7					; 
39c7			 
39c7					; destroy value TOS 
39c7			 
39c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c7 cd a1 21			call macro_forth_dsp_pop 
39ca				endm 
# End of macro FORTH_DSP_POP
39ca			 
39ca					; TODO push value back onto stack for another op etc 
39ca			 
39ca			;		pop hl 
39ca			 
39ca cd f2 1e				call forth_push_numhl 
39cd			 
39cd			.mul_done: 
39cd					NEXTW 
39cd c3 60 22			jp macro_next 
39d0				endm 
# End of macro NEXTW
39d0			 
39d0			 
39d0			 
39d0			 
39d0			.MIN: 
39d0				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
39d0 49				db WORD_SYS_CORE+53             
39d1 51 3a			dw .MAX            
39d3 04				db 3 + 1 
39d4 .. 00			db "MIN",0              
39d8				endm 
# End of macro CWHEAD
39d8			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
39d8					if DEBUG_FORTH_WORDS_KEY 
39d8						DMARK "MIN" 
39d8 f5				push af  
39d9 3a ed 39			ld a, (.dmark)  
39dc 32 b4 fe			ld (debug_mark),a  
39df 3a ee 39			ld a, (.dmark+1)  
39e2 32 b5 fe			ld (debug_mark+1),a  
39e5 3a ef 39			ld a, (.dmark+2)  
39e8 32 b6 fe			ld (debug_mark+2),a  
39eb 18 03			jr .pastdmark  
39ed ..			.dmark: db "MIN"  
39f0 f1			.pastdmark: pop af  
39f1			endm  
# End of macro DMARK
39f1						CALLMONITOR 
39f1 cd 7e 18			call break_point_state  
39f4				endm  
# End of macro CALLMONITOR
39f4					endif 
39f4					; get u2 
39f4			 
39f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39f4 cd e9 20			call macro_dsp_valuehl 
39f7				endm 
# End of macro FORTH_DSP_VALUEHL
39f7			 
39f7 e5					push hl   ; u2 
39f8			 
39f8					; destroy value TOS 
39f8			 
39f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f8 cd a1 21			call macro_forth_dsp_pop 
39fb				endm 
# End of macro FORTH_DSP_POP
39fb			 
39fb					; get u1 
39fb			 
39fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39fb cd e9 20			call macro_dsp_valuehl 
39fe				endm 
# End of macro FORTH_DSP_VALUEHL
39fe			 
39fe e5					push hl  ; u1 
39ff			 
39ff					; destroy value TOS 
39ff			 
39ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ff cd a1 21			call macro_forth_dsp_pop 
3a02				endm 
# End of macro FORTH_DSP_POP
3a02			 
3a02 b7			 or a      ;clear carry flag 
3a03 e1			  pop hl    ; u1 
3a04 d1			  pop de    ; u2 
3a05 e5				push hl   ; saved in case hl is lowest 
3a06 ed 52		  sbc hl,de 
3a08 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3a0a			 
3a0a e1				pop hl 
3a0b					if DEBUG_FORTH_WORDS 
3a0b						DMARK "MIN" 
3a0b f5				push af  
3a0c 3a 20 3a			ld a, (.dmark)  
3a0f 32 b4 fe			ld (debug_mark),a  
3a12 3a 21 3a			ld a, (.dmark+1)  
3a15 32 b5 fe			ld (debug_mark+1),a  
3a18 3a 22 3a			ld a, (.dmark+2)  
3a1b 32 b6 fe			ld (debug_mark+2),a  
3a1e 18 03			jr .pastdmark  
3a20 ..			.dmark: db "MIN"  
3a23 f1			.pastdmark: pop af  
3a24			endm  
# End of macro DMARK
3a24						CALLMONITOR 
3a24 cd 7e 18			call break_point_state  
3a27				endm  
# End of macro CALLMONITOR
3a27					endif 
3a27 cd f2 1e				call forth_push_numhl 
3a2a			 
3a2a				       NEXTW 
3a2a c3 60 22			jp macro_next 
3a2d				endm 
# End of macro NEXTW
3a2d			 
3a2d			.mincont:  
3a2d c1				pop bc   ; tidy up 
3a2e eb				ex de , hl  
3a2f					if DEBUG_FORTH_WORDS 
3a2f						DMARK "MI1" 
3a2f f5				push af  
3a30 3a 44 3a			ld a, (.dmark)  
3a33 32 b4 fe			ld (debug_mark),a  
3a36 3a 45 3a			ld a, (.dmark+1)  
3a39 32 b5 fe			ld (debug_mark+1),a  
3a3c 3a 46 3a			ld a, (.dmark+2)  
3a3f 32 b6 fe			ld (debug_mark+2),a  
3a42 18 03			jr .pastdmark  
3a44 ..			.dmark: db "MI1"  
3a47 f1			.pastdmark: pop af  
3a48			endm  
# End of macro DMARK
3a48						CALLMONITOR 
3a48 cd 7e 18			call break_point_state  
3a4b				endm  
# End of macro CALLMONITOR
3a4b					endif 
3a4b cd f2 1e				call forth_push_numhl 
3a4e			 
3a4e				       NEXTW 
3a4e c3 60 22			jp macro_next 
3a51				endm 
# End of macro NEXTW
3a51			.MAX: 
3a51				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3a51 4a				db WORD_SYS_CORE+54             
3a52 d2 3a			dw .RND16            
3a54 04				db 3 + 1 
3a55 .. 00			db "MAX",0              
3a59				endm 
# End of macro CWHEAD
3a59			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3a59					if DEBUG_FORTH_WORDS_KEY 
3a59						DMARK "MAX" 
3a59 f5				push af  
3a5a 3a 6e 3a			ld a, (.dmark)  
3a5d 32 b4 fe			ld (debug_mark),a  
3a60 3a 6f 3a			ld a, (.dmark+1)  
3a63 32 b5 fe			ld (debug_mark+1),a  
3a66 3a 70 3a			ld a, (.dmark+2)  
3a69 32 b6 fe			ld (debug_mark+2),a  
3a6c 18 03			jr .pastdmark  
3a6e ..			.dmark: db "MAX"  
3a71 f1			.pastdmark: pop af  
3a72			endm  
# End of macro DMARK
3a72						CALLMONITOR 
3a72 cd 7e 18			call break_point_state  
3a75				endm  
# End of macro CALLMONITOR
3a75					endif 
3a75					; get u2 
3a75			 
3a75					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a75 cd e9 20			call macro_dsp_valuehl 
3a78				endm 
# End of macro FORTH_DSP_VALUEHL
3a78			 
3a78 e5					push hl   ; u2 
3a79			 
3a79					; destroy value TOS 
3a79			 
3a79					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a79 cd a1 21			call macro_forth_dsp_pop 
3a7c				endm 
# End of macro FORTH_DSP_POP
3a7c			 
3a7c					; get u1 
3a7c			 
3a7c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a7c cd e9 20			call macro_dsp_valuehl 
3a7f				endm 
# End of macro FORTH_DSP_VALUEHL
3a7f			 
3a7f e5					push hl  ; u1 
3a80			 
3a80					; destroy value TOS 
3a80			 
3a80					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a80 cd a1 21			call macro_forth_dsp_pop 
3a83				endm 
# End of macro FORTH_DSP_POP
3a83			 
3a83 b7			 or a      ;clear carry flag 
3a84 e1			  pop hl    ; u1 
3a85 d1			  pop de    ; u2 
3a86 e5				push hl   ; saved in case hl is lowest 
3a87 ed 52		  sbc hl,de 
3a89 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3a8b			 
3a8b e1				pop hl 
3a8c					if DEBUG_FORTH_WORDS 
3a8c						DMARK "MAX" 
3a8c f5				push af  
3a8d 3a a1 3a			ld a, (.dmark)  
3a90 32 b4 fe			ld (debug_mark),a  
3a93 3a a2 3a			ld a, (.dmark+1)  
3a96 32 b5 fe			ld (debug_mark+1),a  
3a99 3a a3 3a			ld a, (.dmark+2)  
3a9c 32 b6 fe			ld (debug_mark+2),a  
3a9f 18 03			jr .pastdmark  
3aa1 ..			.dmark: db "MAX"  
3aa4 f1			.pastdmark: pop af  
3aa5			endm  
# End of macro DMARK
3aa5						CALLMONITOR 
3aa5 cd 7e 18			call break_point_state  
3aa8				endm  
# End of macro CALLMONITOR
3aa8					endif 
3aa8 cd f2 1e				call forth_push_numhl 
3aab			 
3aab				       NEXTW 
3aab c3 60 22			jp macro_next 
3aae				endm 
# End of macro NEXTW
3aae			 
3aae			.maxcont:  
3aae c1				pop bc   ; tidy up 
3aaf eb				ex de , hl  
3ab0					if DEBUG_FORTH_WORDS 
3ab0						DMARK "MA1" 
3ab0 f5				push af  
3ab1 3a c5 3a			ld a, (.dmark)  
3ab4 32 b4 fe			ld (debug_mark),a  
3ab7 3a c6 3a			ld a, (.dmark+1)  
3aba 32 b5 fe			ld (debug_mark+1),a  
3abd 3a c7 3a			ld a, (.dmark+2)  
3ac0 32 b6 fe			ld (debug_mark+2),a  
3ac3 18 03			jr .pastdmark  
3ac5 ..			.dmark: db "MA1"  
3ac8 f1			.pastdmark: pop af  
3ac9			endm  
# End of macro DMARK
3ac9						CALLMONITOR 
3ac9 cd 7e 18			call break_point_state  
3acc				endm  
# End of macro CALLMONITOR
3acc					endif 
3acc cd f2 1e				call forth_push_numhl 
3acf				       NEXTW 
3acf c3 60 22			jp macro_next 
3ad2				endm 
# End of macro NEXTW
3ad2			 
3ad2			.RND16: 
3ad2				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3ad2 4e				db WORD_SYS_CORE+58             
3ad3 01 3b			dw .RND8            
3ad5 06				db 5 + 1 
3ad6 .. 00			db "RND16",0              
3adc				endm 
# End of macro CWHEAD
3adc			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3adc					if DEBUG_FORTH_WORDS_KEY 
3adc						DMARK "R16" 
3adc f5				push af  
3add 3a f1 3a			ld a, (.dmark)  
3ae0 32 b4 fe			ld (debug_mark),a  
3ae3 3a f2 3a			ld a, (.dmark+1)  
3ae6 32 b5 fe			ld (debug_mark+1),a  
3ae9 3a f3 3a			ld a, (.dmark+2)  
3aec 32 b6 fe			ld (debug_mark+2),a  
3aef 18 03			jr .pastdmark  
3af1 ..			.dmark: db "R16"  
3af4 f1			.pastdmark: pop af  
3af5			endm  
# End of macro DMARK
3af5						CALLMONITOR 
3af5 cd 7e 18			call break_point_state  
3af8				endm  
# End of macro CALLMONITOR
3af8					endif 
3af8 cd 28 0e				call prng16  
3afb cd f2 1e				call forth_push_numhl 
3afe				       NEXTW 
3afe c3 60 22			jp macro_next 
3b01				endm 
# End of macro NEXTW
3b01			.RND8: 
3b01				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3b01 60				db WORD_SYS_CORE+76             
3b02 36 3b			dw .RND            
3b04 05				db 4 + 1 
3b05 .. 00			db "RND8",0              
3b0a				endm 
# End of macro CWHEAD
3b0a			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3b0a					if DEBUG_FORTH_WORDS_KEY 
3b0a						DMARK "RN8" 
3b0a f5				push af  
3b0b 3a 1f 3b			ld a, (.dmark)  
3b0e 32 b4 fe			ld (debug_mark),a  
3b11 3a 20 3b			ld a, (.dmark+1)  
3b14 32 b5 fe			ld (debug_mark+1),a  
3b17 3a 21 3b			ld a, (.dmark+2)  
3b1a 32 b6 fe			ld (debug_mark+2),a  
3b1d 18 03			jr .pastdmark  
3b1f ..			.dmark: db "RN8"  
3b22 f1			.pastdmark: pop af  
3b23			endm  
# End of macro DMARK
3b23						CALLMONITOR 
3b23 cd 7e 18			call break_point_state  
3b26				endm  
# End of macro CALLMONITOR
3b26					endif 
3b26 2a 35 fd				ld hl,(xrandc) 
3b29 23					inc hl 
3b2a cd 42 0e				call xrnd 
3b2d 6f					ld l,a	 
3b2e 26 00				ld h,0 
3b30 cd f2 1e				call forth_push_numhl 
3b33				       NEXTW 
3b33 c3 60 22			jp macro_next 
3b36				endm 
# End of macro NEXTW
3b36			.RND: 
3b36				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3b36 60				db WORD_SYS_CORE+76             
3b37 3c 3c			dw .ENDMATHS            
3b39 04				db 3 + 1 
3b3a .. 00			db "RND",0              
3b3e				endm 
# End of macro CWHEAD
3b3e			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3b3e			 
3b3e					if DEBUG_FORTH_WORDS_KEY 
3b3e						DMARK "RND" 
3b3e f5				push af  
3b3f 3a 53 3b			ld a, (.dmark)  
3b42 32 b4 fe			ld (debug_mark),a  
3b45 3a 54 3b			ld a, (.dmark+1)  
3b48 32 b5 fe			ld (debug_mark+1),a  
3b4b 3a 55 3b			ld a, (.dmark+2)  
3b4e 32 b6 fe			ld (debug_mark+2),a  
3b51 18 03			jr .pastdmark  
3b53 ..			.dmark: db "RND"  
3b56 f1			.pastdmark: pop af  
3b57			endm  
# End of macro DMARK
3b57						CALLMONITOR 
3b57 cd 7e 18			call break_point_state  
3b5a				endm  
# End of macro CALLMONITOR
3b5a					endif 
3b5a					 
3b5a					FORTH_DSP_VALUEHL    ; upper range 
3b5a cd e9 20			call macro_dsp_valuehl 
3b5d				endm 
# End of macro FORTH_DSP_VALUEHL
3b5d			 
3b5d 22 39 fd				ld (LFSRSeed), hl	 
3b60			 
3b60					if DEBUG_FORTH_WORDS 
3b60						DMARK "RN1" 
3b60 f5				push af  
3b61 3a 75 3b			ld a, (.dmark)  
3b64 32 b4 fe			ld (debug_mark),a  
3b67 3a 76 3b			ld a, (.dmark+1)  
3b6a 32 b5 fe			ld (debug_mark+1),a  
3b6d 3a 77 3b			ld a, (.dmark+2)  
3b70 32 b6 fe			ld (debug_mark+2),a  
3b73 18 03			jr .pastdmark  
3b75 ..			.dmark: db "RN1"  
3b78 f1			.pastdmark: pop af  
3b79			endm  
# End of macro DMARK
3b79						CALLMONITOR 
3b79 cd 7e 18			call break_point_state  
3b7c				endm  
# End of macro CALLMONITOR
3b7c					endif 
3b7c					FORTH_DSP_POP 
3b7c cd a1 21			call macro_forth_dsp_pop 
3b7f				endm 
# End of macro FORTH_DSP_POP
3b7f			 
3b7f					FORTH_DSP_VALUEHL    ; low range 
3b7f cd e9 20			call macro_dsp_valuehl 
3b82				endm 
# End of macro FORTH_DSP_VALUEHL
3b82			 
3b82					if DEBUG_FORTH_WORDS 
3b82						DMARK "RN2" 
3b82 f5				push af  
3b83 3a 97 3b			ld a, (.dmark)  
3b86 32 b4 fe			ld (debug_mark),a  
3b89 3a 98 3b			ld a, (.dmark+1)  
3b8c 32 b5 fe			ld (debug_mark+1),a  
3b8f 3a 99 3b			ld a, (.dmark+2)  
3b92 32 b6 fe			ld (debug_mark+2),a  
3b95 18 03			jr .pastdmark  
3b97 ..			.dmark: db "RN2"  
3b9a f1			.pastdmark: pop af  
3b9b			endm  
# End of macro DMARK
3b9b						CALLMONITOR 
3b9b cd 7e 18			call break_point_state  
3b9e				endm  
# End of macro CALLMONITOR
3b9e					endif 
3b9e 22 3b fd				ld (LFSRSeed+2), hl 
3ba1			 
3ba1					FORTH_DSP_POP 
3ba1 cd a1 21			call macro_forth_dsp_pop 
3ba4				endm 
# End of macro FORTH_DSP_POP
3ba4			 
3ba4 e5					push hl 
3ba5			 
3ba5 e1			.inrange:	pop hl 
3ba6 cd 28 0e				call prng16  
3ba9					if DEBUG_FORTH_WORDS 
3ba9						DMARK "RN3" 
3ba9 f5				push af  
3baa 3a be 3b			ld a, (.dmark)  
3bad 32 b4 fe			ld (debug_mark),a  
3bb0 3a bf 3b			ld a, (.dmark+1)  
3bb3 32 b5 fe			ld (debug_mark+1),a  
3bb6 3a c0 3b			ld a, (.dmark+2)  
3bb9 32 b6 fe			ld (debug_mark+2),a  
3bbc 18 03			jr .pastdmark  
3bbe ..			.dmark: db "RN3"  
3bc1 f1			.pastdmark: pop af  
3bc2			endm  
# End of macro DMARK
3bc2						CALLMONITOR 
3bc2 cd 7e 18			call break_point_state  
3bc5				endm  
# End of macro CALLMONITOR
3bc5					endif 
3bc5					 
3bc5					; if the range is 8bit knock out the high byte 
3bc5			 
3bc5 ed 5b 39 fd			ld de, (LFSRSeed)     ; check high level 
3bc9			 
3bc9 3e 00				ld a, 0 
3bcb ba					cp d  
3bcc 20 1e				jr nz, .hirange 
3bce 26 00				ld h, 0   ; knock it down to 8bit 
3bd0			 
3bd0					if DEBUG_FORTH_WORDS 
3bd0						DMARK "RNk" 
3bd0 f5				push af  
3bd1 3a e5 3b			ld a, (.dmark)  
3bd4 32 b4 fe			ld (debug_mark),a  
3bd7 3a e6 3b			ld a, (.dmark+1)  
3bda 32 b5 fe			ld (debug_mark+1),a  
3bdd 3a e7 3b			ld a, (.dmark+2)  
3be0 32 b6 fe			ld (debug_mark+2),a  
3be3 18 03			jr .pastdmark  
3be5 ..			.dmark: db "RNk"  
3be8 f1			.pastdmark: pop af  
3be9			endm  
# End of macro DMARK
3be9						CALLMONITOR 
3be9 cd 7e 18			call break_point_state  
3bec				endm  
# End of macro CALLMONITOR
3bec					endif 
3bec			.hirange:   
3bec e5					push hl  
3bed b7					or a  
3bee ed 52		                sbc hl, de 
3bf0			 
3bf0					;call cmp16 
3bf0			 
3bf0 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3bf2 e1					pop hl 
3bf3 e5					push hl 
3bf4			 
3bf4					if DEBUG_FORTH_WORDS 
3bf4						DMARK "RN4" 
3bf4 f5				push af  
3bf5 3a 09 3c			ld a, (.dmark)  
3bf8 32 b4 fe			ld (debug_mark),a  
3bfb 3a 0a 3c			ld a, (.dmark+1)  
3bfe 32 b5 fe			ld (debug_mark+1),a  
3c01 3a 0b 3c			ld a, (.dmark+2)  
3c04 32 b6 fe			ld (debug_mark+2),a  
3c07 18 03			jr .pastdmark  
3c09 ..			.dmark: db "RN4"  
3c0c f1			.pastdmark: pop af  
3c0d			endm  
# End of macro DMARK
3c0d						CALLMONITOR 
3c0d cd 7e 18			call break_point_state  
3c10				endm  
# End of macro CALLMONITOR
3c10					endif 
3c10 ed 5b 3b fd			ld de, (LFSRSeed+2)   ; check low range 
3c14					;call cmp16 
3c14				 
3c14 b7					or a  
3c15 ed 52		                sbc hl, de 
3c17 38 8c				jr c, .inrange 
3c19			 
3c19 e1					pop hl 
3c1a					 
3c1a					if DEBUG_FORTH_WORDS 
3c1a						DMARK "RNd" 
3c1a f5				push af  
3c1b 3a 2f 3c			ld a, (.dmark)  
3c1e 32 b4 fe			ld (debug_mark),a  
3c21 3a 30 3c			ld a, (.dmark+1)  
3c24 32 b5 fe			ld (debug_mark+1),a  
3c27 3a 31 3c			ld a, (.dmark+2)  
3c2a 32 b6 fe			ld (debug_mark+2),a  
3c2d 18 03			jr .pastdmark  
3c2f ..			.dmark: db "RNd"  
3c32 f1			.pastdmark: pop af  
3c33			endm  
# End of macro DMARK
3c33						CALLMONITOR 
3c33 cd 7e 18			call break_point_state  
3c36				endm  
# End of macro CALLMONITOR
3c36					endif 
3c36			 
3c36			 
3c36 cd f2 1e				call forth_push_numhl 
3c39				       NEXTW 
3c39 c3 60 22			jp macro_next 
3c3c				endm 
# End of macro NEXTW
3c3c			 
3c3c			.ENDMATHS: 
3c3c			 
3c3c			; eof 
3c3c			 
# End of file forth_words_maths.asm
3c3c			include "forth_words_display.asm" 
3c3c			 
3c3c			; | ## Display Words 
3c3c			 
3c3c			.INFO: 
3c3c			 
3c3c				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3c3c 62				db WORD_SYS_CORE+78             
3c3d 59 3c			dw .ATP            
3c3f 05				db 4 + 1 
3c40 .. 00			db "INFO",0              
3c45				endm 
# End of macro CWHEAD
3c45			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3c45					FORTH_DSP_VALUEHL 
3c45 cd e9 20			call macro_dsp_valuehl 
3c48				endm 
# End of macro FORTH_DSP_VALUEHL
3c48			 
3c48					FORTH_DSP_POP 
3c48 cd a1 21			call macro_forth_dsp_pop 
3c4b				endm 
# End of macro FORTH_DSP_POP
3c4b			 
3c4b e5					push hl 
3c4c			 
3c4c					FORTH_DSP_VALUEHL 
3c4c cd e9 20			call macro_dsp_valuehl 
3c4f				endm 
# End of macro FORTH_DSP_VALUEHL
3c4f			 
3c4f					FORTH_DSP_POP 
3c4f cd a1 21			call macro_forth_dsp_pop 
3c52				endm 
# End of macro FORTH_DSP_POP
3c52			 
3c52 d1					pop de 
3c53			 
3c53 cd 5e 0c				call info_panel 
3c56			 
3c56			 
3c56					NEXTW 
3c56 c3 60 22			jp macro_next 
3c59				endm 
# End of macro NEXTW
3c59			.ATP: 
3c59				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3c59 62				db WORD_SYS_CORE+78             
3c5a d0 3c			dw .FB            
3c5c 04				db 3 + 1 
3c5d .. 00			db "AT?",0              
3c61				endm 
# End of macro CWHEAD
3c61			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3c61					if DEBUG_FORTH_WORDS_KEY 
3c61						DMARK "AT?" 
3c61 f5				push af  
3c62 3a 76 3c			ld a, (.dmark)  
3c65 32 b4 fe			ld (debug_mark),a  
3c68 3a 77 3c			ld a, (.dmark+1)  
3c6b 32 b5 fe			ld (debug_mark+1),a  
3c6e 3a 78 3c			ld a, (.dmark+2)  
3c71 32 b6 fe			ld (debug_mark+2),a  
3c74 18 03			jr .pastdmark  
3c76 ..			.dmark: db "AT?"  
3c79 f1			.pastdmark: pop af  
3c7a			endm  
# End of macro DMARK
3c7a						CALLMONITOR 
3c7a cd 7e 18			call break_point_state  
3c7d				endm  
# End of macro CALLMONITOR
3c7d					endif 
3c7d 3a ec fb				ld a, (f_cursor_ptr) 
3c80			 
3c80			if DEBUG_FORTH_WORDS 
3c80				DMARK "AT?" 
3c80 f5				push af  
3c81 3a 95 3c			ld a, (.dmark)  
3c84 32 b4 fe			ld (debug_mark),a  
3c87 3a 96 3c			ld a, (.dmark+1)  
3c8a 32 b5 fe			ld (debug_mark+1),a  
3c8d 3a 97 3c			ld a, (.dmark+2)  
3c90 32 b6 fe			ld (debug_mark+2),a  
3c93 18 03			jr .pastdmark  
3c95 ..			.dmark: db "AT?"  
3c98 f1			.pastdmark: pop af  
3c99			endm  
# End of macro DMARK
3c99				CALLMONITOR 
3c99 cd 7e 18			call break_point_state  
3c9c				endm  
# End of macro CALLMONITOR
3c9c			endif	 
3c9c					; count the number of rows 
3c9c			 
3c9c 06 00				ld b, 0 
3c9e 4f			.atpr:		ld c, a    ; save in case we go below zero 
3c9f d6 14				sub display_cols 
3ca1 f2 a7 3c				jp p, .atprunder 
3ca4 04					inc b 
3ca5 18 f7				jr .atpr 
3ca7			.atprunder:	 
3ca7			if DEBUG_FORTH_WORDS 
3ca7				DMARK "A?2" 
3ca7 f5				push af  
3ca8 3a bc 3c			ld a, (.dmark)  
3cab 32 b4 fe			ld (debug_mark),a  
3cae 3a bd 3c			ld a, (.dmark+1)  
3cb1 32 b5 fe			ld (debug_mark+1),a  
3cb4 3a be 3c			ld a, (.dmark+2)  
3cb7 32 b6 fe			ld (debug_mark+2),a  
3cba 18 03			jr .pastdmark  
3cbc ..			.dmark: db "A?2"  
3cbf f1			.pastdmark: pop af  
3cc0			endm  
# End of macro DMARK
3cc0				CALLMONITOR 
3cc0 cd 7e 18			call break_point_state  
3cc3				endm  
# End of macro CALLMONITOR
3cc3			endif	 
3cc3 26 00				ld h, 0 
3cc5 69					ld l, c 
3cc6 cd f2 1e				call forth_push_numhl 
3cc9 68					ld l, b  
3cca cd f2 1e				call forth_push_numhl 
3ccd			 
3ccd			 
3ccd				NEXTW 
3ccd c3 60 22			jp macro_next 
3cd0				endm 
# End of macro NEXTW
3cd0			 
3cd0			.FB: 
3cd0				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3cd0 1b				db WORD_SYS_CORE+7             
3cd1 1e 3d			dw .EMIT            
3cd3 03				db 2 + 1 
3cd4 .. 00			db "FB",0              
3cd7				endm 
# End of macro CWHEAD
3cd7			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3cd7			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3cd7			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3cd7			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3cd7					if DEBUG_FORTH_WORDS_KEY 
3cd7						DMARK "FB." 
3cd7 f5				push af  
3cd8 3a ec 3c			ld a, (.dmark)  
3cdb 32 b4 fe			ld (debug_mark),a  
3cde 3a ed 3c			ld a, (.dmark+1)  
3ce1 32 b5 fe			ld (debug_mark+1),a  
3ce4 3a ee 3c			ld a, (.dmark+2)  
3ce7 32 b6 fe			ld (debug_mark+2),a  
3cea 18 03			jr .pastdmark  
3cec ..			.dmark: db "FB."  
3cef f1			.pastdmark: pop af  
3cf0			endm  
# End of macro DMARK
3cf0						CALLMONITOR 
3cf0 cd 7e 18			call break_point_state  
3cf3				endm  
# End of macro CALLMONITOR
3cf3					endif 
3cf3			 
3cf3					FORTH_DSP_VALUEHL 
3cf3 cd e9 20			call macro_dsp_valuehl 
3cf6				endm 
# End of macro FORTH_DSP_VALUEHL
3cf6			 
3cf6 7d					ld a, l 
3cf7 fe 01				cp 1 
3cf9 20 05				jr nz, .fbn1 
3cfb 21 f9 fd				ld hl, display_fb1 
3cfe 18 15				jr .fbset 
3d00 fe 02		.fbn1:		cp 2 
3d02 20 05				jr nz, .fbn2 
3d04 21 57 fd				ld hl, display_fb2 
3d07 18 0c				jr .fbset 
3d09 fe 03		.fbn2:		cp 3 
3d0b 20 05				jr nz, .fbn3 
3d0d 21 a8 fd				ld hl, display_fb3 
3d10 18 03				jr .fbset 
3d12			.fbn3:		 ; if invalid number select first 
3d12 21 f9 fd				ld hl, display_fb1 
3d15 22 55 fd		.fbset:		ld (display_fb_active), hl 
3d18			 
3d18					FORTH_DSP_POP 
3d18 cd a1 21			call macro_forth_dsp_pop 
3d1b				endm 
# End of macro FORTH_DSP_POP
3d1b			 
3d1b					NEXTW 
3d1b c3 60 22			jp macro_next 
3d1e				endm 
# End of macro NEXTW
3d1e			 
3d1e			 
3d1e			.EMIT: 
3d1e				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3d1e 1b				db WORD_SYS_CORE+7             
3d1f 6f 3d			dw .DOTH            
3d21 05				db 4 + 1 
3d22 .. 00			db "EMIT",0              
3d27				endm 
# End of macro CWHEAD
3d27			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3d27					; get value off TOS and display it 
3d27			 
3d27					if DEBUG_FORTH_WORDS_KEY 
3d27						DMARK "EMT" 
3d27 f5				push af  
3d28 3a 3c 3d			ld a, (.dmark)  
3d2b 32 b4 fe			ld (debug_mark),a  
3d2e 3a 3d 3d			ld a, (.dmark+1)  
3d31 32 b5 fe			ld (debug_mark+1),a  
3d34 3a 3e 3d			ld a, (.dmark+2)  
3d37 32 b6 fe			ld (debug_mark+2),a  
3d3a 18 03			jr .pastdmark  
3d3c ..			.dmark: db "EMT"  
3d3f f1			.pastdmark: pop af  
3d40			endm  
# End of macro DMARK
3d40						CALLMONITOR 
3d40 cd 7e 18			call break_point_state  
3d43				endm  
# End of macro CALLMONITOR
3d43					endif 
3d43			 
3d43					FORTH_DSP_VALUEHL 
3d43 cd e9 20			call macro_dsp_valuehl 
3d46				endm 
# End of macro FORTH_DSP_VALUEHL
3d46			 
3d46 7d					ld a,l 
3d47			 
3d47					; TODO write to display 
3d47			 
3d47 32 81 f5				ld (os_input), a 
3d4a 3e 00				ld a, 0 
3d4c 32 82 f5				ld (os_input+1), a 
3d4f					 
3d4f 3a ec fb				ld a, (f_cursor_ptr) 
3d52 11 81 f5				ld de, os_input 
3d55 cd e0 0c				call str_at_display 
3d58			 
3d58			 
3d58 3a ca fb				ld a,(cli_autodisplay) 
3d5b fe 00				cp 0 
3d5d 28 03				jr z, .enoupdate 
3d5f cd f0 0c						call update_display 
3d62					.enoupdate: 
3d62			 
3d62 3a ec fb				ld a, (f_cursor_ptr) 
3d65 3c					inc a 
3d66 32 ec fb				ld (f_cursor_ptr), a   ; save new pos 
3d69			 
3d69			 
3d69					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d69 cd a1 21			call macro_forth_dsp_pop 
3d6c				endm 
# End of macro FORTH_DSP_POP
3d6c			  
3d6c			 
3d6c					NEXTW 
3d6c c3 60 22			jp macro_next 
3d6f				endm 
# End of macro NEXTW
3d6f			.DOTH: 
3d6f				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3d6f 1c				db WORD_SYS_CORE+8             
3d70 9f 3d			dw .DOTF            
3d72 03				db 2 + 1 
3d73 .. 00			db ".-",0              
3d76				endm 
# End of macro CWHEAD
3d76			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3d76					; get value off TOS and display it 
3d76					if DEBUG_FORTH_WORDS_KEY 
3d76						DMARK "DTD" 
3d76 f5				push af  
3d77 3a 8b 3d			ld a, (.dmark)  
3d7a 32 b4 fe			ld (debug_mark),a  
3d7d 3a 8c 3d			ld a, (.dmark+1)  
3d80 32 b5 fe			ld (debug_mark+1),a  
3d83 3a 8d 3d			ld a, (.dmark+2)  
3d86 32 b6 fe			ld (debug_mark+2),a  
3d89 18 03			jr .pastdmark  
3d8b ..			.dmark: db "DTD"  
3d8e f1			.pastdmark: pop af  
3d8f			endm  
# End of macro DMARK
3d8f						CALLMONITOR 
3d8f cd 7e 18			call break_point_state  
3d92				endm  
# End of macro CALLMONITOR
3d92					endif 
3d92 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3d94 3e 00			ld a, 0 
3d96 32 cb fb			ld (cli_mvdot), a 
3d99 c3 f6 3d			jp .dotgo 
3d9c				NEXTW 
3d9c c3 60 22			jp macro_next 
3d9f				endm 
# End of macro NEXTW
3d9f			.DOTF: 
3d9f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3d9f 1c				db WORD_SYS_CORE+8             
3da0 cd 3d			dw .DOT            
3da2 03				db 2 + 1 
3da3 .. 00			db ".>",0              
3da6				endm 
# End of macro CWHEAD
3da6			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3da6					; get value off TOS and display it 
3da6			        ; TODO BUG adds extra spaces 
3da6			        ; TODO BUG handle numerics? 
3da6					if DEBUG_FORTH_WORDS_KEY 
3da6						DMARK "DTC" 
3da6 f5				push af  
3da7 3a bb 3d			ld a, (.dmark)  
3daa 32 b4 fe			ld (debug_mark),a  
3dad 3a bc 3d			ld a, (.dmark+1)  
3db0 32 b5 fe			ld (debug_mark+1),a  
3db3 3a bd 3d			ld a, (.dmark+2)  
3db6 32 b6 fe			ld (debug_mark+2),a  
3db9 18 03			jr .pastdmark  
3dbb ..			.dmark: db "DTC"  
3dbe f1			.pastdmark: pop af  
3dbf			endm  
# End of macro DMARK
3dbf						CALLMONITOR 
3dbf cd 7e 18			call break_point_state  
3dc2				endm  
# End of macro CALLMONITOR
3dc2					endif 
3dc2 3e 01			ld a, 1 
3dc4 32 cb fb			ld (cli_mvdot), a 
3dc7 c3 f6 3d			jp .dotgo 
3dca				NEXTW 
3dca c3 60 22			jp macro_next 
3dcd				endm 
# End of macro NEXTW
3dcd			 
3dcd			.DOT: 
3dcd				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3dcd 1c				db WORD_SYS_CORE+8             
3dce 59 3e			dw .CLS            
3dd0 02				db 1 + 1 
3dd1 .. 00			db ".",0              
3dd3				endm 
# End of macro CWHEAD
3dd3			        ; | . ( u -- ) Display TOS | DONE 
3dd3					; get value off TOS and display it 
3dd3			 
3dd3					if DEBUG_FORTH_WORDS_KEY 
3dd3						DMARK "DOT" 
3dd3 f5				push af  
3dd4 3a e8 3d			ld a, (.dmark)  
3dd7 32 b4 fe			ld (debug_mark),a  
3dda 3a e9 3d			ld a, (.dmark+1)  
3ddd 32 b5 fe			ld (debug_mark+1),a  
3de0 3a ea 3d			ld a, (.dmark+2)  
3de3 32 b6 fe			ld (debug_mark+2),a  
3de6 18 03			jr .pastdmark  
3de8 ..			.dmark: db "DOT"  
3deb f1			.pastdmark: pop af  
3dec			endm  
# End of macro DMARK
3dec						CALLMONITOR 
3dec cd 7e 18			call break_point_state  
3def				endm  
# End of macro CALLMONITOR
3def					endif 
3def 3e 00			ld a, 0 
3df1 32 cb fb			ld (cli_mvdot), a 
3df4 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3df6				 
3df6			 
3df6			.dotgo: 
3df6			 
3df6			; move up type to on stack for parserv5 
3df6					FORTH_DSP 
3df6 cd af 20			call macro_forth_dsp 
3df9				endm 
# End of macro FORTH_DSP
3df9				;FORTH_DSP_VALUE  
3df9			 
3df9			if DEBUG_FORTH_DOT 
3df9				DMARK "DOT" 
3df9				CALLMONITOR 
3df9			endif	 
3df9			;		.print: 
3df9			 
3df9 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3dfa 23				inc hl   ; position to the actual value 
3dfb fe 01			cp DS_TYPE_STR 
3dfd 20 06			jr nz, .dotnum1  
3dff			 
3dff			; display string 
3dff				FORTH_DSP_VALUE  
3dff cd d2 20			call macro_forth_dsp_value 
3e02				endm 
# End of macro FORTH_DSP_VALUE
3e02 eb				ex de,hl 
3e03 18 11			jr .dotwrite 
3e05			 
3e05			.dotnum1: 
3e05 fe 02			cp DS_TYPE_INUM 
3e07 20 0c			jr nz, .dotflot 
3e09			 
3e09			 
3e09			; display number 
3e09			 
3e09			;	push hl 
3e09			;	call clear_display 
3e09			;	pop hl 
3e09			 
3e09 5e				ld e, (hl) 
3e0a 23				inc hl 
3e0b 56				ld d, (hl) 
3e0c 21 83 f3			ld hl, scratch 
3e0f			if DEBUG_FORTH_DOT 
3e0f				DMARK "DT1" 
3e0f				CALLMONITOR 
3e0f			endif	 
3e0f			 
3e0f cd 0e 13			call uitoa_16 
3e12 eb				ex de,hl 
3e13			 
3e13			if DEBUG_FORTH_DOT 
3e13				DMARK "DT2" 
3e13				CALLMONITOR 
3e13			endif	 
3e13			 
3e13			;	ld de, os_word_scratch 
3e13 18 01			jr .dotwrite 
3e15			 
3e15 00			.dotflot:   nop 
3e16			; TODO print floating point number 
3e16			 
3e16			.dotwrite:		 
3e16			 
3e16					; if c is set then set all '-' to spaces 
3e16					; need to also take into account .>  
3e16			 
3e16 3e 01				ld a, 1 
3e18 b9					cp c 
3e19 20 13				jr nz, .nodashswap 
3e1b			 
3e1b					; DE has the string to write, working with HL 
3e1b			 
3e1b 06 ff				ld b, 255 
3e1d d5					push de 
3e1e e1					pop hl 
3e1f			 
3e1f			if DEBUG_FORTH_DOT 
3e1f				DMARK "DT-" 
3e1f				CALLMONITOR 
3e1f			endif	 
3e1f 7e			.dashscan:	ld a, (hl) 
3e20 fe 00				cp 0 
3e22 28 0a				jr z, .nodashswap 
3e24 fe 2d				cp '-' 
3e26 20 03				jr nz, .dashskip 
3e28 3e 20				ld a, ' ' 
3e2a 77					ld (hl), a 
3e2b 23			.dashskip:	inc hl 
3e2c			if DEBUG_FORTH_DOT 
3e2c				DMARK "D-2" 
3e2c				CALLMONITOR 
3e2c			endif	 
3e2c 10 f1				djnz .dashscan 
3e2e			 
3e2e			if DEBUG_FORTH_DOT 
3e2e				DMARK "D-1" 
3e2e				CALLMONITOR 
3e2e			endif	 
3e2e			 
3e2e			.nodashswap: 
3e2e			 
3e2e e5					push hl   ; save string start in case we need to advance print 
3e2f			 
3e2f 3a ec fb				ld a, (f_cursor_ptr) 
3e32 cd e0 0c				call str_at_display 
3e35 3a ca fb				ld a,(cli_autodisplay) 
3e38 fe 00				cp 0 
3e3a 28 03				jr z, .noupdate 
3e3c cd f0 0c						call update_display 
3e3f					.noupdate: 
3e3f			 
3e3f			 
3e3f					; see if we need to advance the print position 
3e3f			 
3e3f e1					pop hl   ; get back string 
3e40			 
3e40 3a cb fb				ld a, (cli_mvdot) 
3e43			if DEBUG_FORTH_DOT 
3e43					ld e,a 
3e43				DMARK "D>1" 
3e43				CALLMONITOR 
3e43			endif	 
3e43 fe 00				cp 0 
3e45 28 0c				jr z, .noadv 
3e47					; yes, lets advance the print position 
3e47 3e 00				ld a, 0 
3e49 cd 6a 13				call strlent 
3e4c 3a ec fb				ld a, (f_cursor_ptr) 
3e4f 85					add a,l 
3e50					;call addatohl 
3e50					;ld a, l 
3e50 32 ec fb				ld (f_cursor_ptr), a   ; save new pos 
3e53			 
3e53			if DEBUG_FORTH_DOT 
3e53				DMARK "D->" 
3e53				CALLMONITOR 
3e53			endif	 
3e53			 
3e53			.noadv:	 
3e53			 
3e53					if DEBUG_FORTH_DOT_WAIT 
3e53							call next_page_prompt 
3e53					endif	 
3e53			; TODO this pop off the stack causes a crash. i dont know why 
3e53			 
3e53			 
3e53			if DEBUG_FORTH_DOT 
3e53				DMARK "DTh" 
3e53				CALLMONITOR 
3e53			endif	 
3e53			 
3e53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e53 cd a1 21			call macro_forth_dsp_pop 
3e56				endm 
# End of macro FORTH_DSP_POP
3e56			 
3e56			if DEBUG_FORTH_DOT 
3e56				DMARK "DTi" 
3e56				CALLMONITOR 
3e56			endif	 
3e56			 
3e56			 
3e56					NEXTW 
3e56 c3 60 22			jp macro_next 
3e59				endm 
# End of macro NEXTW
3e59			 
3e59			.CLS: 
3e59				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e59 35				db WORD_SYS_CORE+33             
3e5a 86 3e			dw .DRAW            
3e5c 04				db 3 + 1 
3e5d .. 00			db "CLS",0              
3e61				endm 
# End of macro CWHEAD
3e61			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e61					if DEBUG_FORTH_WORDS_KEY 
3e61						DMARK "CLS" 
3e61 f5				push af  
3e62 3a 76 3e			ld a, (.dmark)  
3e65 32 b4 fe			ld (debug_mark),a  
3e68 3a 77 3e			ld a, (.dmark+1)  
3e6b 32 b5 fe			ld (debug_mark+1),a  
3e6e 3a 78 3e			ld a, (.dmark+2)  
3e71 32 b6 fe			ld (debug_mark+2),a  
3e74 18 03			jr .pastdmark  
3e76 ..			.dmark: db "CLS"  
3e79 f1			.pastdmark: pop af  
3e7a			endm  
# End of macro DMARK
3e7a						CALLMONITOR 
3e7a cd 7e 18			call break_point_state  
3e7d				endm  
# End of macro CALLMONITOR
3e7d					endif 
3e7d cd cd 0c				call clear_display 
3e80 c3 94 3f				jp .home		; and home cursor 
3e83					NEXTW 
3e83 c3 60 22			jp macro_next 
3e86				endm 
# End of macro NEXTW
3e86			 
3e86			.DRAW: 
3e86				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e86 36				db WORD_SYS_CORE+34             
3e87 b1 3e			dw .DUMP            
3e89 05				db 4 + 1 
3e8a .. 00			db "DRAW",0              
3e8f				endm 
# End of macro CWHEAD
3e8f			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e8f					if DEBUG_FORTH_WORDS_KEY 
3e8f						DMARK "DRW" 
3e8f f5				push af  
3e90 3a a4 3e			ld a, (.dmark)  
3e93 32 b4 fe			ld (debug_mark),a  
3e96 3a a5 3e			ld a, (.dmark+1)  
3e99 32 b5 fe			ld (debug_mark+1),a  
3e9c 3a a6 3e			ld a, (.dmark+2)  
3e9f 32 b6 fe			ld (debug_mark+2),a  
3ea2 18 03			jr .pastdmark  
3ea4 ..			.dmark: db "DRW"  
3ea7 f1			.pastdmark: pop af  
3ea8			endm  
# End of macro DMARK
3ea8						CALLMONITOR 
3ea8 cd 7e 18			call break_point_state  
3eab				endm  
# End of macro CALLMONITOR
3eab					endif 
3eab cd f0 0c				call update_display 
3eae					NEXTW 
3eae c3 60 22			jp macro_next 
3eb1				endm 
# End of macro NEXTW
3eb1			 
3eb1			.DUMP: 
3eb1				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3eb1 37				db WORD_SYS_CORE+35             
3eb2 e9 3e			dw .CDUMP            
3eb4 05				db 4 + 1 
3eb5 .. 00			db "DUMP",0              
3eba				endm 
# End of macro CWHEAD
3eba			; | DUMP ( x -- ) With address x display dump   | DONE 
3eba			; TODO pop address to use off of the stack 
3eba					if DEBUG_FORTH_WORDS_KEY 
3eba						DMARK "DUM" 
3eba f5				push af  
3ebb 3a cf 3e			ld a, (.dmark)  
3ebe 32 b4 fe			ld (debug_mark),a  
3ec1 3a d0 3e			ld a, (.dmark+1)  
3ec4 32 b5 fe			ld (debug_mark+1),a  
3ec7 3a d1 3e			ld a, (.dmark+2)  
3eca 32 b6 fe			ld (debug_mark+2),a  
3ecd 18 03			jr .pastdmark  
3ecf ..			.dmark: db "DUM"  
3ed2 f1			.pastdmark: pop af  
3ed3			endm  
# End of macro DMARK
3ed3						CALLMONITOR 
3ed3 cd 7e 18			call break_point_state  
3ed6				endm  
# End of macro CALLMONITOR
3ed6					endif 
3ed6 cd cd 0c				call clear_display 
3ed9			 
3ed9					; get address 
3ed9			 
3ed9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ed9 cd e9 20			call macro_dsp_valuehl 
3edc				endm 
# End of macro FORTH_DSP_VALUEHL
3edc				 
3edc					; save it for cdump 
3edc			 
3edc 22 a6 f6				ld (os_cur_ptr),hl 
3edf			 
3edf					; destroy value TOS 
3edf			 
3edf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3edf cd a1 21			call macro_forth_dsp_pop 
3ee2				endm 
# End of macro FORTH_DSP_POP
3ee2			 
3ee2 cd 72 1d				call dumpcont	; skip old style of param parsing	 
3ee5 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3ee6					NEXTW 
3ee6 c3 60 22			jp macro_next 
3ee9				endm 
# End of macro NEXTW
3ee9			.CDUMP: 
3ee9				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3ee9 38				db WORD_SYS_CORE+36             
3eea 19 3f			dw .DAT            
3eec 06				db 5 + 1 
3eed .. 00			db "CDUMP",0              
3ef3				endm 
# End of macro CWHEAD
3ef3			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3ef3					if DEBUG_FORTH_WORDS_KEY 
3ef3						DMARK "CDP" 
3ef3 f5				push af  
3ef4 3a 08 3f			ld a, (.dmark)  
3ef7 32 b4 fe			ld (debug_mark),a  
3efa 3a 09 3f			ld a, (.dmark+1)  
3efd 32 b5 fe			ld (debug_mark+1),a  
3f00 3a 0a 3f			ld a, (.dmark+2)  
3f03 32 b6 fe			ld (debug_mark+2),a  
3f06 18 03			jr .pastdmark  
3f08 ..			.dmark: db "CDP"  
3f0b f1			.pastdmark: pop af  
3f0c			endm  
# End of macro DMARK
3f0c						CALLMONITOR 
3f0c cd 7e 18			call break_point_state  
3f0f				endm  
# End of macro CALLMONITOR
3f0f					endif 
3f0f cd cd 0c				call clear_display 
3f12 cd 72 1d				call dumpcont	 
3f15 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3f16					NEXTW 
3f16 c3 60 22			jp macro_next 
3f19				endm 
# End of macro NEXTW
3f19			 
3f19			 
3f19			 
3f19			 
3f19			.DAT: 
3f19				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3f19 3d				db WORD_SYS_CORE+41             
3f1a 6f 3f			dw .HOME            
3f1c 03				db 2 + 1 
3f1d .. 00			db "AT",0              
3f20				endm 
# End of macro CWHEAD
3f20			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3f20					if DEBUG_FORTH_WORDS_KEY 
3f20						DMARK "AT." 
3f20 f5				push af  
3f21 3a 35 3f			ld a, (.dmark)  
3f24 32 b4 fe			ld (debug_mark),a  
3f27 3a 36 3f			ld a, (.dmark+1)  
3f2a 32 b5 fe			ld (debug_mark+1),a  
3f2d 3a 37 3f			ld a, (.dmark+2)  
3f30 32 b6 fe			ld (debug_mark+2),a  
3f33 18 03			jr .pastdmark  
3f35 ..			.dmark: db "AT."  
3f38 f1			.pastdmark: pop af  
3f39			endm  
# End of macro DMARK
3f39						CALLMONITOR 
3f39 cd 7e 18			call break_point_state  
3f3c				endm  
# End of macro CALLMONITOR
3f3c					endif 
3f3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f3c cd e9 20			call macro_dsp_valuehl 
3f3f				endm 
# End of macro FORTH_DSP_VALUEHL
3f3f			 
3f3f			 
3f3f					; TODO save cursor row 
3f3f 7d					ld a,l 
3f40 fe 02				cp 2 
3f42 20 04				jr nz, .crow3 
3f44 3e 14				ld a, display_row_2 
3f46 18 12				jr .ccol1 
3f48 fe 03		.crow3:		cp 3 
3f4a 20 04				jr nz, .crow4 
3f4c 3e 28				ld a, display_row_3 
3f4e 18 0a				jr .ccol1 
3f50 fe 04		.crow4:		cp 4 
3f52 20 04				jr nz, .crow1 
3f54 3e 3c				ld a, display_row_4 
3f56 18 02				jr .ccol1 
3f58 3e 00		.crow1:		ld a,display_row_1 
3f5a f5			.ccol1:		push af			; got row offset 
3f5b 6f					ld l,a 
3f5c 26 00				ld h,0 
3f5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f5e cd a1 21			call macro_forth_dsp_pop 
3f61				endm 
# End of macro FORTH_DSP_POP
3f61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f61 cd e9 20			call macro_dsp_valuehl 
3f64				endm 
# End of macro FORTH_DSP_VALUEHL
3f64					; TODO save cursor col 
3f64 f1					pop af 
3f65 85					add l		; add col offset 
3f66 32 ec fb				ld (f_cursor_ptr), a 
3f69					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f69 cd a1 21			call macro_forth_dsp_pop 
3f6c				endm 
# End of macro FORTH_DSP_POP
3f6c			 
3f6c					; calculate  
3f6c			 
3f6c					NEXTW 
3f6c c3 60 22			jp macro_next 
3f6f				endm 
# End of macro NEXTW
3f6f			 
3f6f			 
3f6f			.HOME: 
3f6f				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3f6f 41				db WORD_SYS_CORE+45             
3f70 9c 3f			dw .SPACE            
3f72 05				db 4 + 1 
3f73 .. 00			db "HOME",0              
3f78				endm 
# End of macro CWHEAD
3f78			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f78					if DEBUG_FORTH_WORDS_KEY 
3f78						DMARK "HOM" 
3f78 f5				push af  
3f79 3a 8d 3f			ld a, (.dmark)  
3f7c 32 b4 fe			ld (debug_mark),a  
3f7f 3a 8e 3f			ld a, (.dmark+1)  
3f82 32 b5 fe			ld (debug_mark+1),a  
3f85 3a 8f 3f			ld a, (.dmark+2)  
3f88 32 b6 fe			ld (debug_mark+2),a  
3f8b 18 03			jr .pastdmark  
3f8d ..			.dmark: db "HOM"  
3f90 f1			.pastdmark: pop af  
3f91			endm  
# End of macro DMARK
3f91						CALLMONITOR 
3f91 cd 7e 18			call break_point_state  
3f94				endm  
# End of macro CALLMONITOR
3f94					endif 
3f94 3e 00		.home:		ld a, 0		; and home cursor 
3f96 32 ec fb				ld (f_cursor_ptr), a 
3f99					NEXTW 
3f99 c3 60 22			jp macro_next 
3f9c				endm 
# End of macro NEXTW
3f9c			 
3f9c			 
3f9c			.SPACE: 
3f9c				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f9c 46				db WORD_SYS_CORE+50             
3f9d ca 3f			dw .SPACES            
3f9f 03				db 2 + 1 
3fa0 .. 00			db "BL",0              
3fa3				endm 
# End of macro CWHEAD
3fa3			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3fa3					if DEBUG_FORTH_WORDS_KEY 
3fa3						DMARK "BL." 
3fa3 f5				push af  
3fa4 3a b8 3f			ld a, (.dmark)  
3fa7 32 b4 fe			ld (debug_mark),a  
3faa 3a b9 3f			ld a, (.dmark+1)  
3fad 32 b5 fe			ld (debug_mark+1),a  
3fb0 3a ba 3f			ld a, (.dmark+2)  
3fb3 32 b6 fe			ld (debug_mark+2),a  
3fb6 18 03			jr .pastdmark  
3fb8 ..			.dmark: db "BL."  
3fbb f1			.pastdmark: pop af  
3fbc			endm  
# End of macro DMARK
3fbc						CALLMONITOR 
3fbc cd 7e 18			call break_point_state  
3fbf				endm  
# End of macro CALLMONITOR
3fbf					endif 
3fbf 21 c8 3f				ld hl, .blstr 
3fc2 cd 60 1f				call forth_push_str 
3fc5					 
3fc5				       NEXTW 
3fc5 c3 60 22			jp macro_next 
3fc8				endm 
# End of macro NEXTW
3fc8			 
3fc8 .. 00		.blstr: db " ", 0 
3fca			 
3fca			.SPACES: 
3fca				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3fca 47				db WORD_SYS_CORE+51             
3fcb 65 40			dw .SCROLL            
3fcd 07				db 6 + 1 
3fce .. 00			db "SPACES",0              
3fd5				endm 
# End of macro CWHEAD
3fd5			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3fd5					if DEBUG_FORTH_WORDS_KEY 
3fd5						DMARK "SPS" 
3fd5 f5				push af  
3fd6 3a ea 3f			ld a, (.dmark)  
3fd9 32 b4 fe			ld (debug_mark),a  
3fdc 3a eb 3f			ld a, (.dmark+1)  
3fdf 32 b5 fe			ld (debug_mark+1),a  
3fe2 3a ec 3f			ld a, (.dmark+2)  
3fe5 32 b6 fe			ld (debug_mark+2),a  
3fe8 18 03			jr .pastdmark  
3fea ..			.dmark: db "SPS"  
3fed f1			.pastdmark: pop af  
3fee			endm  
# End of macro DMARK
3fee						CALLMONITOR 
3fee cd 7e 18			call break_point_state  
3ff1				endm  
# End of macro CALLMONITOR
3ff1					endif 
3ff1			 
3ff1			 
3ff1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff1 cd e9 20			call macro_dsp_valuehl 
3ff4				endm 
# End of macro FORTH_DSP_VALUEHL
3ff4			 
3ff4			;		push hl    ; u 
3ff4					if DEBUG_FORTH_WORDS 
3ff4						DMARK "SPA" 
3ff4 f5				push af  
3ff5 3a 09 40			ld a, (.dmark)  
3ff8 32 b4 fe			ld (debug_mark),a  
3ffb 3a 0a 40			ld a, (.dmark+1)  
3ffe 32 b5 fe			ld (debug_mark+1),a  
4001 3a 0b 40			ld a, (.dmark+2)  
4004 32 b6 fe			ld (debug_mark+2),a  
4007 18 03			jr .pastdmark  
4009 ..			.dmark: db "SPA"  
400c f1			.pastdmark: pop af  
400d			endm  
# End of macro DMARK
400d						CALLMONITOR 
400d cd 7e 18			call break_point_state  
4010				endm  
# End of macro CALLMONITOR
4010					endif 
4010			 
4010					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4010 cd a1 21			call macro_forth_dsp_pop 
4013				endm 
# End of macro FORTH_DSP_POP
4013			;		pop hl 
4013 4d					ld c, l 
4014 06 00				ld b, 0 
4016 21 83 f3				ld hl, scratch  
4019			 
4019					if DEBUG_FORTH_WORDS 
4019						DMARK "SP2" 
4019 f5				push af  
401a 3a 2e 40			ld a, (.dmark)  
401d 32 b4 fe			ld (debug_mark),a  
4020 3a 2f 40			ld a, (.dmark+1)  
4023 32 b5 fe			ld (debug_mark+1),a  
4026 3a 30 40			ld a, (.dmark+2)  
4029 32 b6 fe			ld (debug_mark+2),a  
402c 18 03			jr .pastdmark  
402e ..			.dmark: db "SP2"  
4031 f1			.pastdmark: pop af  
4032			endm  
# End of macro DMARK
4032						CALLMONITOR 
4032 cd 7e 18			call break_point_state  
4035				endm  
# End of macro CALLMONITOR
4035					endif 
4035 3e 20				ld a, ' ' 
4037 c5			.spaces1:	push bc 
4038 77					ld (hl),a 
4039 23					inc hl 
403a c1					pop bc 
403b 10 fa				djnz .spaces1 
403d 3e 00				ld a,0 
403f 77					ld (hl),a 
4040 21 83 f3				ld hl, scratch 
4043					if DEBUG_FORTH_WORDS 
4043						DMARK "SP3" 
4043 f5				push af  
4044 3a 58 40			ld a, (.dmark)  
4047 32 b4 fe			ld (debug_mark),a  
404a 3a 59 40			ld a, (.dmark+1)  
404d 32 b5 fe			ld (debug_mark+1),a  
4050 3a 5a 40			ld a, (.dmark+2)  
4053 32 b6 fe			ld (debug_mark+2),a  
4056 18 03			jr .pastdmark  
4058 ..			.dmark: db "SP3"  
405b f1			.pastdmark: pop af  
405c			endm  
# End of macro DMARK
405c						CALLMONITOR 
405c cd 7e 18			call break_point_state  
405f				endm  
# End of macro CALLMONITOR
405f					endif 
405f cd 5b 20				call forth_apush 
4062			 
4062				       NEXTW 
4062 c3 60 22			jp macro_next 
4065				endm 
# End of macro NEXTW
4065			 
4065			 
4065			 
4065			.SCROLL: 
4065				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4065 53				db WORD_SYS_CORE+63             
4066 92 40			dw .SCROLLD            
4068 07				db 6 + 1 
4069 .. 00			db "SCROLL",0              
4070				endm 
# End of macro CWHEAD
4070			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4070					if DEBUG_FORTH_WORDS_KEY 
4070						DMARK "SCR" 
4070 f5				push af  
4071 3a 85 40			ld a, (.dmark)  
4074 32 b4 fe			ld (debug_mark),a  
4077 3a 86 40			ld a, (.dmark+1)  
407a 32 b5 fe			ld (debug_mark+1),a  
407d 3a 87 40			ld a, (.dmark+2)  
4080 32 b6 fe			ld (debug_mark+2),a  
4083 18 03			jr .pastdmark  
4085 ..			.dmark: db "SCR"  
4088 f1			.pastdmark: pop af  
4089			endm  
# End of macro DMARK
4089						CALLMONITOR 
4089 cd 7e 18			call break_point_state  
408c				endm  
# End of macro CALLMONITOR
408c					endif 
408c			 
408c cd 8f 0c			call scroll_up 
408f			;	call update_display 
408f			 
408f					NEXTW 
408f c3 60 22			jp macro_next 
4092				endm 
# End of macro NEXTW
4092			 
4092			 
4092			 
4092			;		; get dir 
4092			; 
4092			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4092			; 
4092			;		push hl 
4092			; 
4092			;		; destroy value TOS 
4092			; 
4092			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4092			; 
4092			;		; get count 
4092			; 
4092			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4092			; 
4092			;		push hl 
4092			; 
4092			;		; destroy value TOS 
4092			; 
4092			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4092			; 
4092			;		; one value on hl get other one back 
4092			; 
4092			;		pop bc    ; count 
4092			; 
4092			;		pop de   ; dir 
4092			; 
4092			; 
4092			;		ld b, c 
4092			; 
4092			;.scrolldir:     push bc 
4092			;		push de 
4092			; 
4092			;		ld a, 0 
4092			;		cp e 
4092			;		jr z, .scrollup  
4092			;		call scroll_down 
4092			;		jr .scrollnext 
4092			;.scrollup:	call scroll_up 
4092			; 
4092			;		 
4092			;.scrollnext: 
4092			;		pop de 
4092			;		pop bc 
4092			;		djnz .scrolldir 
4092			; 
4092			; 
4092			; 
4092			; 
4092			; 
4092			;		NEXTW 
4092			 
4092			.SCROLLD: 
4092				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4092 53				db WORD_SYS_CORE+63             
4093 c0 40			dw .ATQ            
4095 08				db 7 + 1 
4096 .. 00			db "SCROLLD",0              
409e				endm 
# End of macro CWHEAD
409e			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
409e					if DEBUG_FORTH_WORDS_KEY 
409e						DMARK "SCD" 
409e f5				push af  
409f 3a b3 40			ld a, (.dmark)  
40a2 32 b4 fe			ld (debug_mark),a  
40a5 3a b4 40			ld a, (.dmark+1)  
40a8 32 b5 fe			ld (debug_mark+1),a  
40ab 3a b5 40			ld a, (.dmark+2)  
40ae 32 b6 fe			ld (debug_mark+2),a  
40b1 18 03			jr .pastdmark  
40b3 ..			.dmark: db "SCD"  
40b6 f1			.pastdmark: pop af  
40b7			endm  
# End of macro DMARK
40b7						CALLMONITOR 
40b7 cd 7e 18			call break_point_state  
40ba				endm  
# End of macro CALLMONITOR
40ba					endif 
40ba			 
40ba cd b3 0c			call scroll_down 
40bd			;	call update_display 
40bd			 
40bd					NEXTW 
40bd c3 60 22			jp macro_next 
40c0				endm 
# End of macro NEXTW
40c0			 
40c0			 
40c0			.ATQ: 
40c0				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
40c0 62				db WORD_SYS_CORE+78             
40c1 1e 41			dw .AUTODSP            
40c3 04				db 3 + 1 
40c4 .. 00			db "AT@",0              
40c8				endm 
# End of macro CWHEAD
40c8			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
40c8					if DEBUG_FORTH_WORDS_KEY 
40c8						DMARK "ATA" 
40c8 f5				push af  
40c9 3a dd 40			ld a, (.dmark)  
40cc 32 b4 fe			ld (debug_mark),a  
40cf 3a de 40			ld a, (.dmark+1)  
40d2 32 b5 fe			ld (debug_mark+1),a  
40d5 3a df 40			ld a, (.dmark+2)  
40d8 32 b6 fe			ld (debug_mark+2),a  
40db 18 03			jr .pastdmark  
40dd ..			.dmark: db "ATA"  
40e0 f1			.pastdmark: pop af  
40e1			endm  
# End of macro DMARK
40e1						CALLMONITOR 
40e1 cd 7e 18			call break_point_state  
40e4				endm  
# End of macro CALLMONITOR
40e4					endif 
40e4			 
40e4			 
40e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40e4 cd e9 20			call macro_dsp_valuehl 
40e7				endm 
# End of macro FORTH_DSP_VALUEHL
40e7			 
40e7					; TODO save cursor row 
40e7 7d					ld a,l 
40e8 fe 02				cp 2 
40ea 20 04				jr nz, .crow3aq 
40ec 3e 14				ld a, display_row_2 
40ee 18 12				jr .ccol1aq 
40f0 fe 03		.crow3aq:		cp 3 
40f2 20 04				jr nz, .crow4aq 
40f4 3e 28				ld a, display_row_3 
40f6 18 0a				jr .ccol1aq 
40f8 fe 04		.crow4aq:		cp 4 
40fa 20 04				jr nz, .crow1aq 
40fc 3e 3c				ld a, display_row_4 
40fe 18 02				jr .ccol1aq 
4100 3e 00		.crow1aq:		ld a,display_row_1 
4102 f5			.ccol1aq:		push af			; got row offset 
4103 6f					ld l,a 
4104 26 00				ld h,0 
4106					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4106 cd a1 21			call macro_forth_dsp_pop 
4109				endm 
# End of macro FORTH_DSP_POP
4109					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4109 cd e9 20			call macro_dsp_valuehl 
410c				endm 
# End of macro FORTH_DSP_VALUEHL
410c					; TODO save cursor col 
410c f1					pop af 
410d 85					add l		; add col offset 
410e			 
410e					; add current frame buffer address 
410e 2a 55 fd				ld hl, (display_fb_active) 
4111 cd 01 0f				call addatohl 
4114			 
4114			 
4114			 
4114			 
4114					; get char frame buffer location offset in hl 
4114			 
4114 7e					ld a,(hl) 
4115 26 00				ld h, 0 
4117 6f					ld l, a 
4118			 
4118 cd f2 1e				call forth_push_numhl 
411b			 
411b			 
411b					NEXTW 
411b c3 60 22			jp macro_next 
411e				endm 
# End of macro NEXTW
411e			 
411e			.AUTODSP: 
411e				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
411e 63				db WORD_SYS_CORE+79             
411f 34 41			dw .MENU            
4121 05				db 4 + 1 
4122 .. 00			db "ADSP",0              
4127				endm 
# End of macro CWHEAD
4127			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4127			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4127			 
4127					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4127 cd e9 20			call macro_dsp_valuehl 
412a				endm 
# End of macro FORTH_DSP_VALUEHL
412a			 
412a			;		push hl 
412a			 
412a					; destroy value TOS 
412a			 
412a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
412a cd a1 21			call macro_forth_dsp_pop 
412d				endm 
# End of macro FORTH_DSP_POP
412d			 
412d			;		pop hl 
412d			 
412d 7d					ld a,l 
412e 32 ca fb				ld (cli_autodisplay), a 
4131				       NEXTW 
4131 c3 60 22			jp macro_next 
4134				endm 
# End of macro NEXTW
4134			 
4134			.MENU: 
4134				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4134 70				db WORD_SYS_CORE+92             
4135 dd 41			dw .ENDDISPLAY            
4137 05				db 4 + 1 
4138 .. 00			db "MENU",0              
413d				endm 
# End of macro CWHEAD
413d			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
413d			 
413d			;		; get number of items on the stack 
413d			; 
413d				 
413d					FORTH_DSP_VALUEHL 
413d cd e9 20			call macro_dsp_valuehl 
4140				endm 
# End of macro FORTH_DSP_VALUEHL
4140				 
4140					if DEBUG_FORTH_WORDS_KEY 
4140						DMARK "MNU" 
4140 f5				push af  
4141 3a 55 41			ld a, (.dmark)  
4144 32 b4 fe			ld (debug_mark),a  
4147 3a 56 41			ld a, (.dmark+1)  
414a 32 b5 fe			ld (debug_mark+1),a  
414d 3a 57 41			ld a, (.dmark+2)  
4150 32 b6 fe			ld (debug_mark+2),a  
4153 18 03			jr .pastdmark  
4155 ..			.dmark: db "MNU"  
4158 f1			.pastdmark: pop af  
4159			endm  
# End of macro DMARK
4159						CALLMONITOR 
4159 cd 7e 18			call break_point_state  
415c				endm  
# End of macro CALLMONITOR
415c					endif 
415c			 
415c 45					ld b, l	 
415d 05					dec b 
415e			 
415e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
415e cd a1 21			call macro_forth_dsp_pop 
4161				endm 
# End of macro FORTH_DSP_POP
4161			 
4161			 
4161					; go directly through the stack to pluck out the string pointers and build an array 
4161			 
4161			;		FORTH_DSP 
4161			 
4161					; hl contains top most stack item 
4161				 
4161 11 83 f3				ld de, scratch 
4164			 
4164			.mbuild: 
4164			 
4164					FORTH_DSP_VALUEHL 
4164 cd e9 20			call macro_dsp_valuehl 
4167				endm 
# End of macro FORTH_DSP_VALUEHL
4167			 
4167					if DEBUG_FORTH_WORDS 
4167						DMARK "MN3" 
4167 f5				push af  
4168 3a 7c 41			ld a, (.dmark)  
416b 32 b4 fe			ld (debug_mark),a  
416e 3a 7d 41			ld a, (.dmark+1)  
4171 32 b5 fe			ld (debug_mark+1),a  
4174 3a 7e 41			ld a, (.dmark+2)  
4177 32 b6 fe			ld (debug_mark+2),a  
417a 18 03			jr .pastdmark  
417c ..			.dmark: db "MN3"  
417f f1			.pastdmark: pop af  
4180			endm  
# End of macro DMARK
4180						CALLMONITOR 
4180 cd 7e 18			call break_point_state  
4183				endm  
# End of macro CALLMONITOR
4183					endif 
4183 eb					ex de, hl 
4184 73					ld (hl), e 
4185 23					inc hl 
4186 72					ld (hl), d 
4187 23					inc hl 
4188 eb					ex de, hl 
4189			 
4189					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4189 cd a1 21			call macro_forth_dsp_pop 
418c				endm 
# End of macro FORTH_DSP_POP
418c			 
418c 10 d6				djnz .mbuild 
418e			 
418e					; done add term 
418e			 
418e eb					ex de, hl 
418f 36 00				ld (hl), 0 
4191 23					inc hl 
4192 36 00				ld (hl), 0 
4194			 
4194				 
4194					 
4194 21 83 f3				ld hl, scratch 
4197			 
4197					if DEBUG_FORTH_WORDS 
4197						DMARK "MNx" 
4197 f5				push af  
4198 3a ac 41			ld a, (.dmark)  
419b 32 b4 fe			ld (debug_mark),a  
419e 3a ad 41			ld a, (.dmark+1)  
41a1 32 b5 fe			ld (debug_mark+1),a  
41a4 3a ae 41			ld a, (.dmark+2)  
41a7 32 b6 fe			ld (debug_mark+2),a  
41aa 18 03			jr .pastdmark  
41ac ..			.dmark: db "MNx"  
41af f1			.pastdmark: pop af  
41b0			endm  
# End of macro DMARK
41b0						CALLMONITOR 
41b0 cd 7e 18			call break_point_state  
41b3				endm  
# End of macro CALLMONITOR
41b3					endif 
41b3			 
41b3			 
41b3			 
41b3 3e 00				ld a, 0 
41b5 cd fe 0c				call menu 
41b8			 
41b8			 
41b8 6f					ld l, a 
41b9 26 00				ld h, 0 
41bb			 
41bb					if DEBUG_FORTH_WORDS 
41bb						DMARK "MNr" 
41bb f5				push af  
41bc 3a d0 41			ld a, (.dmark)  
41bf 32 b4 fe			ld (debug_mark),a  
41c2 3a d1 41			ld a, (.dmark+1)  
41c5 32 b5 fe			ld (debug_mark+1),a  
41c8 3a d2 41			ld a, (.dmark+2)  
41cb 32 b6 fe			ld (debug_mark+2),a  
41ce 18 03			jr .pastdmark  
41d0 ..			.dmark: db "MNr"  
41d3 f1			.pastdmark: pop af  
41d4			endm  
# End of macro DMARK
41d4						CALLMONITOR 
41d4 cd 7e 18			call break_point_state  
41d7				endm  
# End of macro CALLMONITOR
41d7					endif 
41d7			 
41d7 cd f2 1e				call forth_push_numhl 
41da			 
41da			 
41da			 
41da			 
41da				       NEXTW 
41da c3 60 22			jp macro_next 
41dd				endm 
# End of macro NEXTW
41dd			 
41dd			 
41dd			.ENDDISPLAY: 
41dd			 
41dd			; eof 
# End of file forth_words_display.asm
41dd			include "forth_words_str.asm" 
41dd			 
41dd			; | ## String Words 
41dd			 
41dd			.PTR:   
41dd			 
41dd				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
41dd 48				db WORD_SYS_CORE+52             
41de 0a 42			dw .STYPE            
41e0 04				db 3 + 1 
41e1 .. 00			db "PTR",0              
41e5				endm 
# End of macro CWHEAD
41e5			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
41e5			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
41e5			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
41e5			 
41e5					if DEBUG_FORTH_WORDS_KEY 
41e5						DMARK "PTR" 
41e5 f5				push af  
41e6 3a fa 41			ld a, (.dmark)  
41e9 32 b4 fe			ld (debug_mark),a  
41ec 3a fb 41			ld a, (.dmark+1)  
41ef 32 b5 fe			ld (debug_mark+1),a  
41f2 3a fc 41			ld a, (.dmark+2)  
41f5 32 b6 fe			ld (debug_mark+2),a  
41f8 18 03			jr .pastdmark  
41fa ..			.dmark: db "PTR"  
41fd f1			.pastdmark: pop af  
41fe			endm  
# End of macro DMARK
41fe						CALLMONITOR 
41fe cd 7e 18			call break_point_state  
4201				endm  
# End of macro CALLMONITOR
4201					endif 
4201					FORTH_DSP_VALUEHL 
4201 cd e9 20			call macro_dsp_valuehl 
4204				endm 
# End of macro FORTH_DSP_VALUEHL
4204 cd f2 1e				call forth_push_numhl 
4207			 
4207			 
4207					NEXTW 
4207 c3 60 22			jp macro_next 
420a				endm 
# End of macro NEXTW
420a			.STYPE: 
420a				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
420a 48				db WORD_SYS_CORE+52             
420b 59 42			dw .UPPER            
420d 06				db 5 + 1 
420e .. 00			db "STYPE",0              
4214				endm 
# End of macro CWHEAD
4214			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4214					if DEBUG_FORTH_WORDS_KEY 
4214						DMARK "STY" 
4214 f5				push af  
4215 3a 29 42			ld a, (.dmark)  
4218 32 b4 fe			ld (debug_mark),a  
421b 3a 2a 42			ld a, (.dmark+1)  
421e 32 b5 fe			ld (debug_mark+1),a  
4221 3a 2b 42			ld a, (.dmark+2)  
4224 32 b6 fe			ld (debug_mark+2),a  
4227 18 03			jr .pastdmark  
4229 ..			.dmark: db "STY"  
422c f1			.pastdmark: pop af  
422d			endm  
# End of macro DMARK
422d						CALLMONITOR 
422d cd 7e 18			call break_point_state  
4230				endm  
# End of macro CALLMONITOR
4230					endif 
4230					FORTH_DSP 
4230 cd af 20			call macro_forth_dsp 
4233				endm 
# End of macro FORTH_DSP
4233					;v5 FORTH_DSP_VALUE 
4233			 
4233 7e					ld a, (hl) 
4234			 
4234 f5					push af 
4235			 
4235			; Dont destroy TOS		FORTH_DSP_POP 
4235			 
4235 f1					pop af 
4236			 
4236 fe 01				cp DS_TYPE_STR 
4238 28 09				jr z, .typestr 
423a			 
423a fe 02				cp DS_TYPE_INUM 
423c 28 0a				jr z, .typeinum 
423e			 
423e 21 57 42				ld hl, .tna 
4241 18 0a				jr .tpush 
4243			 
4243 21 53 42		.typestr:	ld hl, .tstr 
4246 18 05				jr .tpush 
4248 21 55 42		.typeinum:	ld hl, .tinum 
424b 18 00				jr .tpush 
424d			 
424d			.tpush: 
424d			 
424d cd 60 1f				call forth_push_str 
4250			 
4250					NEXTW 
4250 c3 60 22			jp macro_next 
4253				endm 
# End of macro NEXTW
4253 .. 00		.tstr:	db "s",0 
4255 .. 00		.tinum:  db "i",0 
4257 .. 00		.tna:   db "?", 0 
4259			 
4259			 
4259			.UPPER: 
4259				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4259 48				db WORD_SYS_CORE+52             
425a 94 42			dw .LOWER            
425c 06				db 5 + 1 
425d .. 00			db "UPPER",0              
4263				endm 
# End of macro CWHEAD
4263			; | UPPER ( s -- s ) Upper case string s  | DONE 
4263					if DEBUG_FORTH_WORDS_KEY 
4263						DMARK "UPR" 
4263 f5				push af  
4264 3a 78 42			ld a, (.dmark)  
4267 32 b4 fe			ld (debug_mark),a  
426a 3a 79 42			ld a, (.dmark+1)  
426d 32 b5 fe			ld (debug_mark+1),a  
4270 3a 7a 42			ld a, (.dmark+2)  
4273 32 b6 fe			ld (debug_mark+2),a  
4276 18 03			jr .pastdmark  
4278 ..			.dmark: db "UPR"  
427b f1			.pastdmark: pop af  
427c			endm  
# End of macro DMARK
427c						CALLMONITOR 
427c cd 7e 18			call break_point_state  
427f				endm  
# End of macro CALLMONITOR
427f					endif 
427f			 
427f					FORTH_DSP 
427f cd af 20			call macro_forth_dsp 
4282				endm 
# End of macro FORTH_DSP
4282					 
4282			; TODO check is string type 
4282			 
4282					FORTH_DSP_VALUEHL 
4282 cd e9 20			call macro_dsp_valuehl 
4285				endm 
# End of macro FORTH_DSP_VALUEHL
4285			; get pointer to string in hl 
4285			 
4285 7e			.toup:		ld a, (hl) 
4286 fe 00				cp 0 
4288 28 07				jr z, .toupdone 
428a			 
428a cd 6e 12				call to_upper 
428d			 
428d 77					ld (hl), a 
428e 23					inc hl 
428f 18 f4				jr .toup 
4291			 
4291					 
4291			 
4291			 
4291			; for each char convert to upper 
4291					 
4291			.toupdone: 
4291			 
4291			 
4291					NEXTW 
4291 c3 60 22			jp macro_next 
4294				endm 
# End of macro NEXTW
4294			.LOWER: 
4294				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4294 48				db WORD_SYS_CORE+52             
4295 cf 42			dw .TCASE            
4297 06				db 5 + 1 
4298 .. 00			db "LOWER",0              
429e				endm 
# End of macro CWHEAD
429e			; | LOWER ( s -- s ) Lower case string s  | DONE 
429e					if DEBUG_FORTH_WORDS_KEY 
429e						DMARK "LWR" 
429e f5				push af  
429f 3a b3 42			ld a, (.dmark)  
42a2 32 b4 fe			ld (debug_mark),a  
42a5 3a b4 42			ld a, (.dmark+1)  
42a8 32 b5 fe			ld (debug_mark+1),a  
42ab 3a b5 42			ld a, (.dmark+2)  
42ae 32 b6 fe			ld (debug_mark+2),a  
42b1 18 03			jr .pastdmark  
42b3 ..			.dmark: db "LWR"  
42b6 f1			.pastdmark: pop af  
42b7			endm  
# End of macro DMARK
42b7						CALLMONITOR 
42b7 cd 7e 18			call break_point_state  
42ba				endm  
# End of macro CALLMONITOR
42ba					endif 
42ba			 
42ba					FORTH_DSP 
42ba cd af 20			call macro_forth_dsp 
42bd				endm 
# End of macro FORTH_DSP
42bd					 
42bd			; TODO check is string type 
42bd			 
42bd					FORTH_DSP_VALUEHL 
42bd cd e9 20			call macro_dsp_valuehl 
42c0				endm 
# End of macro FORTH_DSP_VALUEHL
42c0			; get pointer to string in hl 
42c0			 
42c0 7e			.tolow:		ld a, (hl) 
42c1 fe 00				cp 0 
42c3 28 07				jr z, .tolowdone 
42c5			 
42c5 cd 77 12				call to_lower 
42c8			 
42c8 77					ld (hl), a 
42c9 23					inc hl 
42ca 18 f4				jr .tolow 
42cc			 
42cc					 
42cc			 
42cc			 
42cc			; for each char convert to low 
42cc					 
42cc			.tolowdone: 
42cc					NEXTW 
42cc c3 60 22			jp macro_next 
42cf				endm 
# End of macro NEXTW
42cf			.TCASE: 
42cf				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
42cf 48				db WORD_SYS_CORE+52             
42d0 05 44			dw .SUBSTR            
42d2 06				db 5 + 1 
42d3 .. 00			db "TCASE",0              
42d9				endm 
# End of macro CWHEAD
42d9			; | TCASE ( s -- s ) Title case string s  | DONE 
42d9					if DEBUG_FORTH_WORDS_KEY 
42d9						DMARK "TCS" 
42d9 f5				push af  
42da 3a ee 42			ld a, (.dmark)  
42dd 32 b4 fe			ld (debug_mark),a  
42e0 3a ef 42			ld a, (.dmark+1)  
42e3 32 b5 fe			ld (debug_mark+1),a  
42e6 3a f0 42			ld a, (.dmark+2)  
42e9 32 b6 fe			ld (debug_mark+2),a  
42ec 18 03			jr .pastdmark  
42ee ..			.dmark: db "TCS"  
42f1 f1			.pastdmark: pop af  
42f2			endm  
# End of macro DMARK
42f2						CALLMONITOR 
42f2 cd 7e 18			call break_point_state  
42f5				endm  
# End of macro CALLMONITOR
42f5					endif 
42f5			 
42f5					FORTH_DSP 
42f5 cd af 20			call macro_forth_dsp 
42f8				endm 
# End of macro FORTH_DSP
42f8					 
42f8			; TODO check is string type 
42f8			 
42f8					FORTH_DSP_VALUEHL 
42f8 cd e9 20			call macro_dsp_valuehl 
42fb				endm 
# End of macro FORTH_DSP_VALUEHL
42fb			; get pointer to string in hl 
42fb			 
42fb					if DEBUG_FORTH_WORDS 
42fb						DMARK "TC1" 
42fb f5				push af  
42fc 3a 10 43			ld a, (.dmark)  
42ff 32 b4 fe			ld (debug_mark),a  
4302 3a 11 43			ld a, (.dmark+1)  
4305 32 b5 fe			ld (debug_mark+1),a  
4308 3a 12 43			ld a, (.dmark+2)  
430b 32 b6 fe			ld (debug_mark+2),a  
430e 18 03			jr .pastdmark  
4310 ..			.dmark: db "TC1"  
4313 f1			.pastdmark: pop af  
4314			endm  
# End of macro DMARK
4314						CALLMONITOR 
4314 cd 7e 18			call break_point_state  
4317				endm  
# End of macro CALLMONITOR
4317					endif 
4317			 
4317					; first time in turn to upper case first char 
4317			 
4317 7e					ld a, (hl) 
4318 c3 a2 43				jp .totsiptou 
431b			 
431b			 
431b 7e			.tot:		ld a, (hl) 
431c fe 00				cp 0 
431e ca e6 43				jp z, .totdone 
4321			 
4321					if DEBUG_FORTH_WORDS 
4321						DMARK "TC2" 
4321 f5				push af  
4322 3a 36 43			ld a, (.dmark)  
4325 32 b4 fe			ld (debug_mark),a  
4328 3a 37 43			ld a, (.dmark+1)  
432b 32 b5 fe			ld (debug_mark+1),a  
432e 3a 38 43			ld a, (.dmark+2)  
4331 32 b6 fe			ld (debug_mark+2),a  
4334 18 03			jr .pastdmark  
4336 ..			.dmark: db "TC2"  
4339 f1			.pastdmark: pop af  
433a			endm  
# End of macro DMARK
433a						CALLMONITOR 
433a cd 7e 18			call break_point_state  
433d				endm  
# End of macro CALLMONITOR
433d					endif 
433d					; check to see if current char is a space 
433d			 
433d fe 20				cp ' ' 
433f 28 21				jr z, .totsp 
4341 cd 77 12				call to_lower 
4344					if DEBUG_FORTH_WORDS 
4344						DMARK "TC3" 
4344 f5				push af  
4345 3a 59 43			ld a, (.dmark)  
4348 32 b4 fe			ld (debug_mark),a  
434b 3a 5a 43			ld a, (.dmark+1)  
434e 32 b5 fe			ld (debug_mark+1),a  
4351 3a 5b 43			ld a, (.dmark+2)  
4354 32 b6 fe			ld (debug_mark+2),a  
4357 18 03			jr .pastdmark  
4359 ..			.dmark: db "TC3"  
435c f1			.pastdmark: pop af  
435d			endm  
# End of macro DMARK
435d						CALLMONITOR 
435d cd 7e 18			call break_point_state  
4360				endm  
# End of macro CALLMONITOR
4360					endif 
4360 18 63				jr .totnxt 
4362			 
4362			.totsp:         ; on a space, find next char which should be upper 
4362			 
4362					if DEBUG_FORTH_WORDS 
4362						DMARK "TC4" 
4362 f5				push af  
4363 3a 77 43			ld a, (.dmark)  
4366 32 b4 fe			ld (debug_mark),a  
4369 3a 78 43			ld a, (.dmark+1)  
436c 32 b5 fe			ld (debug_mark+1),a  
436f 3a 79 43			ld a, (.dmark+2)  
4372 32 b6 fe			ld (debug_mark+2),a  
4375 18 03			jr .pastdmark  
4377 ..			.dmark: db "TC4"  
437a f1			.pastdmark: pop af  
437b			endm  
# End of macro DMARK
437b						CALLMONITOR 
437b cd 7e 18			call break_point_state  
437e				endm  
# End of macro CALLMONITOR
437e					endif 
437e					;; 
437e			 
437e fe 20				cp ' ' 
4380 20 20				jr nz, .totsiptou 
4382 23					inc hl 
4383 7e					ld a, (hl) 
4384					if DEBUG_FORTH_WORDS 
4384						DMARK "TC5" 
4384 f5				push af  
4385 3a 99 43			ld a, (.dmark)  
4388 32 b4 fe			ld (debug_mark),a  
438b 3a 9a 43			ld a, (.dmark+1)  
438e 32 b5 fe			ld (debug_mark+1),a  
4391 3a 9b 43			ld a, (.dmark+2)  
4394 32 b6 fe			ld (debug_mark+2),a  
4397 18 03			jr .pastdmark  
4399 ..			.dmark: db "TC5"  
439c f1			.pastdmark: pop af  
439d			endm  
# End of macro DMARK
439d						CALLMONITOR 
439d cd 7e 18			call break_point_state  
43a0				endm  
# End of macro CALLMONITOR
43a0					endif 
43a0 18 c0				jr .totsp 
43a2 fe 00		.totsiptou:    cp 0 
43a4 28 40				jr z, .totdone 
43a6					; not space and not zero term so upper case it 
43a6 cd 6e 12				call to_upper 
43a9			 
43a9					if DEBUG_FORTH_WORDS 
43a9						DMARK "TC6" 
43a9 f5				push af  
43aa 3a be 43			ld a, (.dmark)  
43ad 32 b4 fe			ld (debug_mark),a  
43b0 3a bf 43			ld a, (.dmark+1)  
43b3 32 b5 fe			ld (debug_mark+1),a  
43b6 3a c0 43			ld a, (.dmark+2)  
43b9 32 b6 fe			ld (debug_mark+2),a  
43bc 18 03			jr .pastdmark  
43be ..			.dmark: db "TC6"  
43c1 f1			.pastdmark: pop af  
43c2			endm  
# End of macro DMARK
43c2						CALLMONITOR 
43c2 cd 7e 18			call break_point_state  
43c5				endm  
# End of macro CALLMONITOR
43c5					endif 
43c5			 
43c5			 
43c5			.totnxt: 
43c5			 
43c5 77					ld (hl), a 
43c6 23					inc hl 
43c7					if DEBUG_FORTH_WORDS 
43c7						DMARK "TC7" 
43c7 f5				push af  
43c8 3a dc 43			ld a, (.dmark)  
43cb 32 b4 fe			ld (debug_mark),a  
43ce 3a dd 43			ld a, (.dmark+1)  
43d1 32 b5 fe			ld (debug_mark+1),a  
43d4 3a de 43			ld a, (.dmark+2)  
43d7 32 b6 fe			ld (debug_mark+2),a  
43da 18 03			jr .pastdmark  
43dc ..			.dmark: db "TC7"  
43df f1			.pastdmark: pop af  
43e0			endm  
# End of macro DMARK
43e0						CALLMONITOR 
43e0 cd 7e 18			call break_point_state  
43e3				endm  
# End of macro CALLMONITOR
43e3					endif 
43e3 c3 1b 43				jp .tot 
43e6			 
43e6					 
43e6			 
43e6			 
43e6			; for each char convert to low 
43e6					 
43e6			.totdone: 
43e6					if DEBUG_FORTH_WORDS 
43e6						DMARK "TCd" 
43e6 f5				push af  
43e7 3a fb 43			ld a, (.dmark)  
43ea 32 b4 fe			ld (debug_mark),a  
43ed 3a fc 43			ld a, (.dmark+1)  
43f0 32 b5 fe			ld (debug_mark+1),a  
43f3 3a fd 43			ld a, (.dmark+2)  
43f6 32 b6 fe			ld (debug_mark+2),a  
43f9 18 03			jr .pastdmark  
43fb ..			.dmark: db "TCd"  
43fe f1			.pastdmark: pop af  
43ff			endm  
# End of macro DMARK
43ff						CALLMONITOR 
43ff cd 7e 18			call break_point_state  
4402				endm  
# End of macro CALLMONITOR
4402					endif 
4402					NEXTW 
4402 c3 60 22			jp macro_next 
4405				endm 
# End of macro NEXTW
4405			 
4405			.SUBSTR: 
4405				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4405 48				db WORD_SYS_CORE+52             
4406 63 44			dw .LEFT            
4408 07				db 6 + 1 
4409 .. 00			db "SUBSTR",0              
4410				endm 
# End of macro CWHEAD
4410			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4410			 
4410					if DEBUG_FORTH_WORDS_KEY 
4410						DMARK "SST" 
4410 f5				push af  
4411 3a 25 44			ld a, (.dmark)  
4414 32 b4 fe			ld (debug_mark),a  
4417 3a 26 44			ld a, (.dmark+1)  
441a 32 b5 fe			ld (debug_mark+1),a  
441d 3a 27 44			ld a, (.dmark+2)  
4420 32 b6 fe			ld (debug_mark+2),a  
4423 18 03			jr .pastdmark  
4425 ..			.dmark: db "SST"  
4428 f1			.pastdmark: pop af  
4429			endm  
# End of macro DMARK
4429						CALLMONITOR 
4429 cd 7e 18			call break_point_state  
442c				endm  
# End of macro CALLMONITOR
442c					endif 
442c			; TODO check string type 
442c					FORTH_DSP_VALUEHL 
442c cd e9 20			call macro_dsp_valuehl 
442f				endm 
# End of macro FORTH_DSP_VALUEHL
442f			 
442f e5					push hl      ; string length 
4430			 
4430					FORTH_DSP_POP 
4430 cd a1 21			call macro_forth_dsp_pop 
4433				endm 
# End of macro FORTH_DSP_POP
4433			 
4433					FORTH_DSP_VALUEHL 
4433 cd e9 20			call macro_dsp_valuehl 
4436				endm 
# End of macro FORTH_DSP_VALUEHL
4436			 
4436 e5					push hl     ; start char 
4437			 
4437					FORTH_DSP_POP 
4437 cd a1 21			call macro_forth_dsp_pop 
443a				endm 
# End of macro FORTH_DSP_POP
443a			 
443a			 
443a					FORTH_DSP_VALUE 
443a cd d2 20			call macro_forth_dsp_value 
443d				endm 
# End of macro FORTH_DSP_VALUE
443d			 
443d d1					pop de    ; get start post offset 
443e			 
443e 19					add hl, de    ; starting offset 
443f			 
443f c1					pop bc 
4440 c5					push bc      ; grab size of string 
4441			 
4441 e5					push hl    ; save string start  
4442			 
4442 26 00				ld h, 0 
4444 69					ld l, c 
4445 23					inc hl 
4446 23					inc hl 
4447			 
4447 cd c8 13				call malloc 
444a				if DEBUG_FORTH_MALLOC_GUARD 
444a cc 51 55				call z,malloc_error 
444d				endif 
444d			 
444d eb					ex de, hl      ; save malloc area for string copy 
444e e1					pop hl    ; get back source 
444f c1					pop bc    ; get length of string back 
4450			 
4450 d5					push de    ; save malloc area for after we push 
4451 ed b0				ldir     ; copy substr 
4453			 
4453			 
4453 eb					ex de, hl 
4454 3e 00				ld a, 0 
4456 77					ld (hl), a   ; term substr 
4457			 
4457					 
4457 e1					pop hl    ; get malloc so we can push it 
4458 e5					push hl   ; save so we can free it afterwards 
4459			 
4459 cd 60 1f				call forth_push_str 
445c			 
445c e1					pop hl 
445d cd 92 14				call free 
4460			 
4460					 
4460					 
4460			 
4460			 
4460					NEXTW 
4460 c3 60 22			jp macro_next 
4463				endm 
# End of macro NEXTW
4463			 
4463			.LEFT: 
4463				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4463 48				db WORD_SYS_CORE+52             
4464 8b 44			dw .RIGHT            
4466 05				db 4 + 1 
4467 .. 00			db "LEFT",0              
446c				endm 
# End of macro CWHEAD
446c			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
446c					if DEBUG_FORTH_WORDS_KEY 
446c						DMARK "LEF" 
446c f5				push af  
446d 3a 81 44			ld a, (.dmark)  
4470 32 b4 fe			ld (debug_mark),a  
4473 3a 82 44			ld a, (.dmark+1)  
4476 32 b5 fe			ld (debug_mark+1),a  
4479 3a 83 44			ld a, (.dmark+2)  
447c 32 b6 fe			ld (debug_mark+2),a  
447f 18 03			jr .pastdmark  
4481 ..			.dmark: db "LEF"  
4484 f1			.pastdmark: pop af  
4485			endm  
# End of macro DMARK
4485						CALLMONITOR 
4485 cd 7e 18			call break_point_state  
4488				endm  
# End of macro CALLMONITOR
4488					endif 
4488			 
4488					NEXTW 
4488 c3 60 22			jp macro_next 
448b				endm 
# End of macro NEXTW
448b			.RIGHT: 
448b				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
448b 48				db WORD_SYS_CORE+52             
448c b4 44			dw .STR2NUM            
448e 06				db 5 + 1 
448f .. 00			db "RIGHT",0              
4495				endm 
# End of macro CWHEAD
4495			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4495					if DEBUG_FORTH_WORDS_KEY 
4495						DMARK "RIG" 
4495 f5				push af  
4496 3a aa 44			ld a, (.dmark)  
4499 32 b4 fe			ld (debug_mark),a  
449c 3a ab 44			ld a, (.dmark+1)  
449f 32 b5 fe			ld (debug_mark+1),a  
44a2 3a ac 44			ld a, (.dmark+2)  
44a5 32 b6 fe			ld (debug_mark+2),a  
44a8 18 03			jr .pastdmark  
44aa ..			.dmark: db "RIG"  
44ad f1			.pastdmark: pop af  
44ae			endm  
# End of macro DMARK
44ae						CALLMONITOR 
44ae cd 7e 18			call break_point_state  
44b1				endm  
# End of macro CALLMONITOR
44b1					endif 
44b1			 
44b1					NEXTW 
44b1 c3 60 22			jp macro_next 
44b4				endm 
# End of macro NEXTW
44b4			 
44b4			 
44b4			.STR2NUM: 
44b4				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
44b4 48				db WORD_SYS_CORE+52             
44b5 40 45			dw .NUM2STR            
44b7 08				db 7 + 1 
44b8 .. 00			db "STR2NUM",0              
44c0				endm 
# End of macro CWHEAD
44c0			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
44c0			 
44c0			 
44c0			; TODO STR type check to do 
44c0					if DEBUG_FORTH_WORDS_KEY 
44c0						DMARK "S2N" 
44c0 f5				push af  
44c1 3a d5 44			ld a, (.dmark)  
44c4 32 b4 fe			ld (debug_mark),a  
44c7 3a d6 44			ld a, (.dmark+1)  
44ca 32 b5 fe			ld (debug_mark+1),a  
44cd 3a d7 44			ld a, (.dmark+2)  
44d0 32 b6 fe			ld (debug_mark+2),a  
44d3 18 03			jr .pastdmark  
44d5 ..			.dmark: db "S2N"  
44d8 f1			.pastdmark: pop af  
44d9			endm  
# End of macro DMARK
44d9						CALLMONITOR 
44d9 cd 7e 18			call break_point_state  
44dc				endm  
# End of macro CALLMONITOR
44dc					endif 
44dc			 
44dc					;FORTH_DSP 
44dc					FORTH_DSP_VALUE 
44dc cd d2 20			call macro_forth_dsp_value 
44df				endm 
# End of macro FORTH_DSP_VALUE
44df					;inc hl 
44df			 
44df eb					ex de, hl 
44e0					if DEBUG_FORTH_WORDS 
44e0						DMARK "S2a" 
44e0 f5				push af  
44e1 3a f5 44			ld a, (.dmark)  
44e4 32 b4 fe			ld (debug_mark),a  
44e7 3a f6 44			ld a, (.dmark+1)  
44ea 32 b5 fe			ld (debug_mark+1),a  
44ed 3a f7 44			ld a, (.dmark+2)  
44f0 32 b6 fe			ld (debug_mark+2),a  
44f3 18 03			jr .pastdmark  
44f5 ..			.dmark: db "S2a"  
44f8 f1			.pastdmark: pop af  
44f9			endm  
# End of macro DMARK
44f9						CALLMONITOR 
44f9 cd 7e 18			call break_point_state  
44fc				endm  
# End of macro CALLMONITOR
44fc					endif 
44fc cd f6 12				call string_to_uint16 
44ff			 
44ff					if DEBUG_FORTH_WORDS 
44ff						DMARK "S2b" 
44ff f5				push af  
4500 3a 14 45			ld a, (.dmark)  
4503 32 b4 fe			ld (debug_mark),a  
4506 3a 15 45			ld a, (.dmark+1)  
4509 32 b5 fe			ld (debug_mark+1),a  
450c 3a 16 45			ld a, (.dmark+2)  
450f 32 b6 fe			ld (debug_mark+2),a  
4512 18 03			jr .pastdmark  
4514 ..			.dmark: db "S2b"  
4517 f1			.pastdmark: pop af  
4518			endm  
# End of macro DMARK
4518						CALLMONITOR 
4518 cd 7e 18			call break_point_state  
451b				endm  
# End of macro CALLMONITOR
451b					endif 
451b			;		push hl 
451b					FORTH_DSP_POP 
451b cd a1 21			call macro_forth_dsp_pop 
451e				endm 
# End of macro FORTH_DSP_POP
451e			;		pop hl 
451e					 
451e					if DEBUG_FORTH_WORDS 
451e						DMARK "S2b" 
451e f5				push af  
451f 3a 33 45			ld a, (.dmark)  
4522 32 b4 fe			ld (debug_mark),a  
4525 3a 34 45			ld a, (.dmark+1)  
4528 32 b5 fe			ld (debug_mark+1),a  
452b 3a 35 45			ld a, (.dmark+2)  
452e 32 b6 fe			ld (debug_mark+2),a  
4531 18 03			jr .pastdmark  
4533 ..			.dmark: db "S2b"  
4536 f1			.pastdmark: pop af  
4537			endm  
# End of macro DMARK
4537						CALLMONITOR 
4537 cd 7e 18			call break_point_state  
453a				endm  
# End of macro CALLMONITOR
453a					endif 
453a cd f2 1e				call forth_push_numhl	 
453d			 
453d				 
453d				       NEXTW 
453d c3 60 22			jp macro_next 
4540				endm 
# End of macro NEXTW
4540			.NUM2STR: 
4540				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4540 48				db WORD_SYS_CORE+52             
4541 4f 45			dw .CONCAT            
4543 08				db 7 + 1 
4544 .. 00			db "NUM2STR",0              
454c				endm 
# End of macro CWHEAD
454c			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
454c			 
454c			;		; malloc a string to target 
454c			;		ld hl, 10     ; TODO max string size should be fine 
454c			;		call malloc 
454c			;		push hl    ; save malloc location 
454c			; 
454c			; 
454c			;; TODO check int type 
454c			;		FORTH_DSP_VALUEHL 
454c			;		ld a, l 
454c			;		call DispAToASCII   
454c			;;TODO need to chage above call to dump into string 
454c			; 
454c			; 
454c			 
454c				       NEXTW 
454c c3 60 22			jp macro_next 
454f				endm 
# End of macro NEXTW
454f			 
454f			.CONCAT: 
454f				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
454f 48				db WORD_SYS_CORE+52             
4550 02 46			dw .FIND            
4552 07				db 6 + 1 
4553 .. 00			db "CONCAT",0              
455a				endm 
# End of macro CWHEAD
455a			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
455a			 
455a			; TODO check string type 
455a			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
455a			 
455a					if DEBUG_FORTH_WORDS_KEY 
455a						DMARK "CON" 
455a f5				push af  
455b 3a 6f 45			ld a, (.dmark)  
455e 32 b4 fe			ld (debug_mark),a  
4561 3a 70 45			ld a, (.dmark+1)  
4564 32 b5 fe			ld (debug_mark+1),a  
4567 3a 71 45			ld a, (.dmark+2)  
456a 32 b6 fe			ld (debug_mark+2),a  
456d 18 03			jr .pastdmark  
456f ..			.dmark: db "CON"  
4572 f1			.pastdmark: pop af  
4573			endm  
# End of macro DMARK
4573						CALLMONITOR 
4573 cd 7e 18			call break_point_state  
4576				endm  
# End of macro CALLMONITOR
4576					endif 
4576			 
4576			 
4576					FORTH_DSP_VALUE 
4576 cd d2 20			call macro_forth_dsp_value 
4579				endm 
# End of macro FORTH_DSP_VALUE
4579 e5					push hl   ; s2 
457a			 
457a					FORTH_DSP_POP 
457a cd a1 21			call macro_forth_dsp_pop 
457d				endm 
# End of macro FORTH_DSP_POP
457d			 
457d					FORTH_DSP_VALUE 
457d cd d2 20			call macro_forth_dsp_value 
4580				endm 
# End of macro FORTH_DSP_VALUE
4580			 
4580 e5					push hl   ; s1 
4581			 
4581					FORTH_DSP_POP 
4581 cd a1 21			call macro_forth_dsp_pop 
4584				endm 
# End of macro FORTH_DSP_POP
4584					 
4584			 
4584					; copy s1 
4584			 
4584				 
4584					; save ptr 
4584 e1					pop hl  
4585 e5					push hl 
4586 3e 00				ld a, 0 
4588 cd 6a 13				call strlent 
458b					;inc hl    ; zer0 
458b 06 00				ld b, 0 
458d 4d					ld c, l 
458e e1					pop hl		 
458f 11 83 f3				ld de, scratch	 
4592					if DEBUG_FORTH_WORDS 
4592						DMARK "CO1" 
4592 f5				push af  
4593 3a a7 45			ld a, (.dmark)  
4596 32 b4 fe			ld (debug_mark),a  
4599 3a a8 45			ld a, (.dmark+1)  
459c 32 b5 fe			ld (debug_mark+1),a  
459f 3a a9 45			ld a, (.dmark+2)  
45a2 32 b6 fe			ld (debug_mark+2),a  
45a5 18 03			jr .pastdmark  
45a7 ..			.dmark: db "CO1"  
45aa f1			.pastdmark: pop af  
45ab			endm  
# End of macro DMARK
45ab						CALLMONITOR 
45ab cd 7e 18			call break_point_state  
45ae				endm  
# End of macro CALLMONITOR
45ae					endif 
45ae ed b0				ldir 
45b0			 
45b0 e1					pop hl 
45b1 e5					push hl 
45b2 d5					push de 
45b3			 
45b3			 
45b3 3e 00				ld a, 0 
45b5 cd 6a 13				call strlent 
45b8 23					inc hl    ; zer0 
45b9 23					inc hl 
45ba 06 00				ld b, 0 
45bc 4d					ld c, l 
45bd d1					pop de 
45be e1					pop hl		 
45bf					if DEBUG_FORTH_WORDS 
45bf						DMARK "CO2" 
45bf f5				push af  
45c0 3a d4 45			ld a, (.dmark)  
45c3 32 b4 fe			ld (debug_mark),a  
45c6 3a d5 45			ld a, (.dmark+1)  
45c9 32 b5 fe			ld (debug_mark+1),a  
45cc 3a d6 45			ld a, (.dmark+2)  
45cf 32 b6 fe			ld (debug_mark+2),a  
45d2 18 03			jr .pastdmark  
45d4 ..			.dmark: db "CO2"  
45d7 f1			.pastdmark: pop af  
45d8			endm  
# End of macro DMARK
45d8						CALLMONITOR 
45d8 cd 7e 18			call break_point_state  
45db				endm  
# End of macro CALLMONITOR
45db					endif 
45db ed b0				ldir 
45dd			 
45dd			 
45dd			 
45dd 21 83 f3				ld hl, scratch 
45e0					if DEBUG_FORTH_WORDS 
45e0						DMARK "CO5" 
45e0 f5				push af  
45e1 3a f5 45			ld a, (.dmark)  
45e4 32 b4 fe			ld (debug_mark),a  
45e7 3a f6 45			ld a, (.dmark+1)  
45ea 32 b5 fe			ld (debug_mark+1),a  
45ed 3a f7 45			ld a, (.dmark+2)  
45f0 32 b6 fe			ld (debug_mark+2),a  
45f3 18 03			jr .pastdmark  
45f5 ..			.dmark: db "CO5"  
45f8 f1			.pastdmark: pop af  
45f9			endm  
# End of macro DMARK
45f9						CALLMONITOR 
45f9 cd 7e 18			call break_point_state  
45fc				endm  
# End of macro CALLMONITOR
45fc					endif 
45fc			 
45fc cd 60 1f				call forth_push_str 
45ff			 
45ff			 
45ff			 
45ff			 
45ff				       NEXTW 
45ff c3 60 22			jp macro_next 
4602				endm 
# End of macro NEXTW
4602			 
4602			 
4602			.FIND: 
4602				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4602 4b				db WORD_SYS_CORE+55             
4603 c0 46			dw .LEN            
4605 05				db 4 + 1 
4606 .. 00			db "FIND",0              
460b				endm 
# End of macro CWHEAD
460b			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
460b			 
460b					if DEBUG_FORTH_WORDS_KEY 
460b						DMARK "FND" 
460b f5				push af  
460c 3a 20 46			ld a, (.dmark)  
460f 32 b4 fe			ld (debug_mark),a  
4612 3a 21 46			ld a, (.dmark+1)  
4615 32 b5 fe			ld (debug_mark+1),a  
4618 3a 22 46			ld a, (.dmark+2)  
461b 32 b6 fe			ld (debug_mark+2),a  
461e 18 03			jr .pastdmark  
4620 ..			.dmark: db "FND"  
4623 f1			.pastdmark: pop af  
4624			endm  
# End of macro DMARK
4624						CALLMONITOR 
4624 cd 7e 18			call break_point_state  
4627				endm  
# End of macro CALLMONITOR
4627					endif 
4627			 
4627			; TODO check string type 
4627					FORTH_DSP_VALUE 
4627 cd d2 20			call macro_forth_dsp_value 
462a				endm 
# End of macro FORTH_DSP_VALUE
462a			 
462a e5					push hl    
462b 7e					ld a,(hl)    ; char to find   
462c			; TODO change char to substr 
462c			 
462c f5					push af 
462d					 
462d			 
462d			 
462d					if DEBUG_FORTH_WORDS 
462d						DMARK "FN1" 
462d f5				push af  
462e 3a 42 46			ld a, (.dmark)  
4631 32 b4 fe			ld (debug_mark),a  
4634 3a 43 46			ld a, (.dmark+1)  
4637 32 b5 fe			ld (debug_mark+1),a  
463a 3a 44 46			ld a, (.dmark+2)  
463d 32 b6 fe			ld (debug_mark+2),a  
4640 18 03			jr .pastdmark  
4642 ..			.dmark: db "FN1"  
4645 f1			.pastdmark: pop af  
4646			endm  
# End of macro DMARK
4646						CALLMONITOR 
4646 cd 7e 18			call break_point_state  
4649				endm  
# End of macro CALLMONITOR
4649					endif 
4649			 
4649					FORTH_DSP_POP 
4649 cd a1 21			call macro_forth_dsp_pop 
464c				endm 
# End of macro FORTH_DSP_POP
464c			 
464c					; string to search 
464c			 
464c					FORTH_DSP_VALUE 
464c cd d2 20			call macro_forth_dsp_value 
464f				endm 
# End of macro FORTH_DSP_VALUE
464f			 
464f d1					pop de  ; d is char to find  
4650			 
4650					if DEBUG_FORTH_WORDS 
4650						DMARK "FN2" 
4650 f5				push af  
4651 3a 65 46			ld a, (.dmark)  
4654 32 b4 fe			ld (debug_mark),a  
4657 3a 66 46			ld a, (.dmark+1)  
465a 32 b5 fe			ld (debug_mark+1),a  
465d 3a 67 46			ld a, (.dmark+2)  
4660 32 b6 fe			ld (debug_mark+2),a  
4663 18 03			jr .pastdmark  
4665 ..			.dmark: db "FN2"  
4668 f1			.pastdmark: pop af  
4669			endm  
# End of macro DMARK
4669						CALLMONITOR 
4669 cd 7e 18			call break_point_state  
466c				endm  
# End of macro CALLMONITOR
466c					endif 
466c					 
466c 01 00 00				ld bc, 0 
466f 7e			.findchar:      ld a,(hl) 
4670 fe 00				cp 0   		 
4672 28 27				jr z, .finddone     
4674 ba					cp d 
4675 28 20				jr z, .foundchar 
4677 03					inc bc 
4678 23					inc hl 
4679					if DEBUG_FORTH_WORDS 
4679						DMARK "FN3" 
4679 f5				push af  
467a 3a 8e 46			ld a, (.dmark)  
467d 32 b4 fe			ld (debug_mark),a  
4680 3a 8f 46			ld a, (.dmark+1)  
4683 32 b5 fe			ld (debug_mark+1),a  
4686 3a 90 46			ld a, (.dmark+2)  
4689 32 b6 fe			ld (debug_mark+2),a  
468c 18 03			jr .pastdmark  
468e ..			.dmark: db "FN3"  
4691 f1			.pastdmark: pop af  
4692			endm  
# End of macro DMARK
4692						CALLMONITOR 
4692 cd 7e 18			call break_point_state  
4695				endm  
# End of macro CALLMONITOR
4695					endif 
4695 18 d8				jr .findchar 
4697			 
4697			 
4697 c5			.foundchar:	push bc 
4698 e1					pop hl 
4699 18 03				jr .findexit 
469b			 
469b			 
469b							 
469b			 
469b			.finddone:     ; got to end of string with no find 
469b 21 00 00				ld hl, 0 
469e			.findexit: 
469e			 
469e					if DEBUG_FORTH_WORDS 
469e						DMARK "FNd" 
469e f5				push af  
469f 3a b3 46			ld a, (.dmark)  
46a2 32 b4 fe			ld (debug_mark),a  
46a5 3a b4 46			ld a, (.dmark+1)  
46a8 32 b5 fe			ld (debug_mark+1),a  
46ab 3a b5 46			ld a, (.dmark+2)  
46ae 32 b6 fe			ld (debug_mark+2),a  
46b1 18 03			jr .pastdmark  
46b3 ..			.dmark: db "FNd"  
46b6 f1			.pastdmark: pop af  
46b7			endm  
# End of macro DMARK
46b7						CALLMONITOR 
46b7 cd 7e 18			call break_point_state  
46ba				endm  
# End of macro CALLMONITOR
46ba					endif 
46ba cd f2 1e			call forth_push_numhl 
46bd			 
46bd				       NEXTW 
46bd c3 60 22			jp macro_next 
46c0				endm 
# End of macro NEXTW
46c0			 
46c0			.LEN: 
46c0				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
46c0 4c				db WORD_SYS_CORE+56             
46c1 2a 47			dw .CHAR            
46c3 06				db 5 + 1 
46c4 .. 00			db "COUNT",0              
46ca				endm 
# End of macro CWHEAD
46ca			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
46ca			 
46ca					if DEBUG_FORTH_WORDS_KEY 
46ca						DMARK "CNT" 
46ca f5				push af  
46cb 3a df 46			ld a, (.dmark)  
46ce 32 b4 fe			ld (debug_mark),a  
46d1 3a e0 46			ld a, (.dmark+1)  
46d4 32 b5 fe			ld (debug_mark+1),a  
46d7 3a e1 46			ld a, (.dmark+2)  
46da 32 b6 fe			ld (debug_mark+2),a  
46dd 18 03			jr .pastdmark  
46df ..			.dmark: db "CNT"  
46e2 f1			.pastdmark: pop af  
46e3			endm  
# End of macro DMARK
46e3						CALLMONITOR 
46e3 cd 7e 18			call break_point_state  
46e6				endm  
# End of macro CALLMONITOR
46e6					endif 
46e6			; TODO check string type 
46e6					FORTH_DSP_VALUE 
46e6 cd d2 20			call macro_forth_dsp_value 
46e9				endm 
# End of macro FORTH_DSP_VALUE
46e9			 
46e9			 
46e9					if DEBUG_FORTH_WORDS 
46e9						DMARK "CN?" 
46e9 f5				push af  
46ea 3a fe 46			ld a, (.dmark)  
46ed 32 b4 fe			ld (debug_mark),a  
46f0 3a ff 46			ld a, (.dmark+1)  
46f3 32 b5 fe			ld (debug_mark+1),a  
46f6 3a 00 47			ld a, (.dmark+2)  
46f9 32 b6 fe			ld (debug_mark+2),a  
46fc 18 03			jr .pastdmark  
46fe ..			.dmark: db "CN?"  
4701 f1			.pastdmark: pop af  
4702			endm  
# End of macro DMARK
4702						CALLMONITOR 
4702 cd 7e 18			call break_point_state  
4705				endm  
# End of macro CALLMONITOR
4705					endif 
4705 cd 5f 13				call strlenz 
4708					if DEBUG_FORTH_WORDS 
4708						DMARK "CNl" 
4708 f5				push af  
4709 3a 1d 47			ld a, (.dmark)  
470c 32 b4 fe			ld (debug_mark),a  
470f 3a 1e 47			ld a, (.dmark+1)  
4712 32 b5 fe			ld (debug_mark+1),a  
4715 3a 1f 47			ld a, (.dmark+2)  
4718 32 b6 fe			ld (debug_mark+2),a  
471b 18 03			jr .pastdmark  
471d ..			.dmark: db "CNl"  
4720 f1			.pastdmark: pop af  
4721			endm  
# End of macro DMARK
4721						CALLMONITOR 
4721 cd 7e 18			call break_point_state  
4724				endm  
# End of macro CALLMONITOR
4724					endif 
4724			 
4724 cd f2 1e				call forth_push_numhl 
4727			 
4727			 
4727			 
4727				       NEXTW 
4727 c3 60 22			jp macro_next 
472a				endm 
# End of macro NEXTW
472a			.CHAR: 
472a				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
472a 4d				db WORD_SYS_CORE+57             
472b 60 47			dw .ENDSTR            
472d 05				db 4 + 1 
472e .. 00			db "CHAR",0              
4733				endm 
# End of macro CWHEAD
4733			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4733					if DEBUG_FORTH_WORDS_KEY 
4733						DMARK "CHR" 
4733 f5				push af  
4734 3a 48 47			ld a, (.dmark)  
4737 32 b4 fe			ld (debug_mark),a  
473a 3a 49 47			ld a, (.dmark+1)  
473d 32 b5 fe			ld (debug_mark+1),a  
4740 3a 4a 47			ld a, (.dmark+2)  
4743 32 b6 fe			ld (debug_mark+2),a  
4746 18 03			jr .pastdmark  
4748 ..			.dmark: db "CHR"  
474b f1			.pastdmark: pop af  
474c			endm  
# End of macro DMARK
474c						CALLMONITOR 
474c cd 7e 18			call break_point_state  
474f				endm  
# End of macro CALLMONITOR
474f					endif 
474f					FORTH_DSP 
474f cd af 20			call macro_forth_dsp 
4752				endm 
# End of macro FORTH_DSP
4752					;v5 FORTH_DSP_VALUE 
4752 23					inc hl      ; now at start of numeric as string 
4753			 
4753			;		push hl 
4753			 
4753					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4753 cd a1 21			call macro_forth_dsp_pop 
4756				endm 
# End of macro FORTH_DSP_POP
4756			 
4756			;		pop hl 
4756			 
4756					; push the content of a onto the stack as a value 
4756			 
4756 7e					ld a,(hl)   ; get char 
4757 26 00				ld h,0 
4759 6f					ld l,a 
475a cd f2 1e				call forth_push_numhl 
475d			 
475d				       NEXTW 
475d c3 60 22			jp macro_next 
4760				endm 
# End of macro NEXTW
4760			 
4760			 
4760			 
4760			 
4760			.ENDSTR: 
4760			; eof 
4760			 
# End of file forth_words_str.asm
4760			include "forth_words_key.asm" 
4760			 
4760			; | ## Keyboard Words 
4760			 
4760			.KEY: 
4760				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4760 3e				db WORD_SYS_CORE+42             
4761 90 47			dw .WAITK            
4763 04				db 3 + 1 
4764 .. 00			db "KEY",0              
4768				endm 
# End of macro CWHEAD
4768			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4768			 
4768					if DEBUG_FORTH_WORDS_KEY 
4768						DMARK "KEY" 
4768 f5				push af  
4769 3a 7d 47			ld a, (.dmark)  
476c 32 b4 fe			ld (debug_mark),a  
476f 3a 7e 47			ld a, (.dmark+1)  
4772 32 b5 fe			ld (debug_mark+1),a  
4775 3a 7f 47			ld a, (.dmark+2)  
4778 32 b6 fe			ld (debug_mark+2),a  
477b 18 03			jr .pastdmark  
477d ..			.dmark: db "KEY"  
4780 f1			.pastdmark: pop af  
4781			endm  
# End of macro DMARK
4781						CALLMONITOR 
4781 cd 7e 18			call break_point_state  
4784				endm  
# End of macro CALLMONITOR
4784					endif 
4784			; TODO currently waits 
4784 cd 59 6b				call cin 
4787					;call cin_wait 
4787 6f					ld l, a 
4788 26 00				ld h, 0 
478a cd f2 1e				call forth_push_numhl 
478d					NEXTW 
478d c3 60 22			jp macro_next 
4790				endm 
# End of macro NEXTW
4790			.WAITK: 
4790				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4790 3f				db WORD_SYS_CORE+43             
4791 c2 47			dw .ACCEPT            
4793 06				db 5 + 1 
4794 .. 00			db "WAITK",0              
479a				endm 
# End of macro CWHEAD
479a			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
479a					if DEBUG_FORTH_WORDS_KEY 
479a						DMARK "WAI" 
479a f5				push af  
479b 3a af 47			ld a, (.dmark)  
479e 32 b4 fe			ld (debug_mark),a  
47a1 3a b0 47			ld a, (.dmark+1)  
47a4 32 b5 fe			ld (debug_mark+1),a  
47a7 3a b1 47			ld a, (.dmark+2)  
47aa 32 b6 fe			ld (debug_mark+2),a  
47ad 18 03			jr .pastdmark  
47af ..			.dmark: db "WAI"  
47b2 f1			.pastdmark: pop af  
47b3			endm  
# End of macro DMARK
47b3						CALLMONITOR 
47b3 cd 7e 18			call break_point_state  
47b6				endm  
# End of macro CALLMONITOR
47b6					endif 
47b6 cd 48 6b				call cin_wait 
47b9 6f					ld l, a 
47ba 26 00				ld h, 0 
47bc cd f2 1e				call forth_push_numhl 
47bf					NEXTW 
47bf c3 60 22			jp macro_next 
47c2				endm 
# End of macro NEXTW
47c2			.ACCEPT: 
47c2				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47c2 40				db WORD_SYS_CORE+44             
47c3 20 48			dw .EDIT            
47c5 07				db 6 + 1 
47c6 .. 00			db "ACCEPT",0              
47cd				endm 
# End of macro CWHEAD
47cd			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47cd					; TODO crashes on push 
47cd					if DEBUG_FORTH_WORDS_KEY 
47cd						DMARK "ACC" 
47cd f5				push af  
47ce 3a e2 47			ld a, (.dmark)  
47d1 32 b4 fe			ld (debug_mark),a  
47d4 3a e3 47			ld a, (.dmark+1)  
47d7 32 b5 fe			ld (debug_mark+1),a  
47da 3a e4 47			ld a, (.dmark+2)  
47dd 32 b6 fe			ld (debug_mark+2),a  
47e0 18 03			jr .pastdmark  
47e2 ..			.dmark: db "ACC"  
47e5 f1			.pastdmark: pop af  
47e6			endm  
# End of macro DMARK
47e6						CALLMONITOR 
47e6 cd 7e 18			call break_point_state  
47e9				endm  
# End of macro CALLMONITOR
47e9					endif 
47e9 21 81 f5				ld hl, os_input 
47ec 3e 00				ld a, 0 
47ee 77					ld (hl),a 
47ef 3a ec fb				ld a,(f_cursor_ptr) 
47f2 16 64				ld d, 100 
47f4 0e 00				ld c, 0 
47f6 1e 28				ld e, 40 
47f8 cd 2e 0f				call input_str 
47fb					; TODO perhaps do a type check and wrap in quotes if not a number 
47fb 21 81 f5				ld hl, os_input 
47fe					if DEBUG_FORTH_WORDS 
47fe						DMARK "AC1" 
47fe f5				push af  
47ff 3a 13 48			ld a, (.dmark)  
4802 32 b4 fe			ld (debug_mark),a  
4805 3a 14 48			ld a, (.dmark+1)  
4808 32 b5 fe			ld (debug_mark+1),a  
480b 3a 15 48			ld a, (.dmark+2)  
480e 32 b6 fe			ld (debug_mark+2),a  
4811 18 03			jr .pastdmark  
4813 ..			.dmark: db "AC1"  
4816 f1			.pastdmark: pop af  
4817			endm  
# End of macro DMARK
4817						CALLMONITOR 
4817 cd 7e 18			call break_point_state  
481a				endm  
# End of macro CALLMONITOR
481a					endif 
481a cd 60 1f				call forth_push_str 
481d					NEXTW 
481d c3 60 22			jp macro_next 
4820				endm 
# End of macro NEXTW
4820			 
4820			.EDIT: 
4820				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4820 40				db WORD_SYS_CORE+44             
4821 c2 48			dw .ENDKEY            
4823 05				db 4 + 1 
4824 .. 00			db "EDIT",0              
4829				endm 
# End of macro CWHEAD
4829			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4829			 
4829					; TODO does not copy from stack 
4829					if DEBUG_FORTH_WORDS_KEY 
4829						DMARK "EDT" 
4829 f5				push af  
482a 3a 3e 48			ld a, (.dmark)  
482d 32 b4 fe			ld (debug_mark),a  
4830 3a 3f 48			ld a, (.dmark+1)  
4833 32 b5 fe			ld (debug_mark+1),a  
4836 3a 40 48			ld a, (.dmark+2)  
4839 32 b6 fe			ld (debug_mark+2),a  
483c 18 03			jr .pastdmark  
483e ..			.dmark: db "EDT"  
4841 f1			.pastdmark: pop af  
4842			endm  
# End of macro DMARK
4842						CALLMONITOR 
4842 cd 7e 18			call break_point_state  
4845				endm  
# End of macro CALLMONITOR
4845					endif 
4845			 
4845					;FORTH_DSP 
4845					FORTH_DSP_VALUEHL 
4845 cd e9 20			call macro_dsp_valuehl 
4848				endm 
# End of macro FORTH_DSP_VALUEHL
4848			;		inc hl    ; TODO do type check 
4848			 
4848			;		call get_word_hl 
4848 e5					push hl 
4849					if DEBUG_FORTH_WORDS 
4849						DMARK "EDp" 
4849 f5				push af  
484a 3a 5e 48			ld a, (.dmark)  
484d 32 b4 fe			ld (debug_mark),a  
4850 3a 5f 48			ld a, (.dmark+1)  
4853 32 b5 fe			ld (debug_mark+1),a  
4856 3a 60 48			ld a, (.dmark+2)  
4859 32 b6 fe			ld (debug_mark+2),a  
485c 18 03			jr .pastdmark  
485e ..			.dmark: db "EDp"  
4861 f1			.pastdmark: pop af  
4862			endm  
# End of macro DMARK
4862						CALLMONITOR 
4862 cd 7e 18			call break_point_state  
4865				endm  
# End of macro CALLMONITOR
4865					endif 
4865				;	ld a, 0 
4865 cd 5f 13				call strlenz 
4868 23					inc hl 
4869			 
4869 06 00				ld b, 0 
486b 4d					ld c, l 
486c			 
486c e1					pop hl 
486d 11 81 f5				ld de, os_input 
4870					if DEBUG_FORTH_WORDS_KEY 
4870						DMARK "EDc" 
4870 f5				push af  
4871 3a 85 48			ld a, (.dmark)  
4874 32 b4 fe			ld (debug_mark),a  
4877 3a 86 48			ld a, (.dmark+1)  
487a 32 b5 fe			ld (debug_mark+1),a  
487d 3a 87 48			ld a, (.dmark+2)  
4880 32 b6 fe			ld (debug_mark+2),a  
4883 18 03			jr .pastdmark  
4885 ..			.dmark: db "EDc"  
4888 f1			.pastdmark: pop af  
4889			endm  
# End of macro DMARK
4889						CALLMONITOR 
4889 cd 7e 18			call break_point_state  
488c				endm  
# End of macro CALLMONITOR
488c					endif 
488c ed b0				ldir 
488e			 
488e			 
488e 21 81 f5				ld hl, os_input 
4891					;ld a, 0 
4891					;ld (hl),a 
4891 3a ec fb				ld a,(f_cursor_ptr) 
4894 16 64				ld d, 100 
4896 0e 00				ld c, 0 
4898 1e 28				ld e, 40 
489a cd 2e 0f				call input_str 
489d					; TODO perhaps do a type check and wrap in quotes if not a number 
489d 21 81 f5				ld hl, os_input 
48a0					if DEBUG_FORTH_WORDS 
48a0						DMARK "ED1" 
48a0 f5				push af  
48a1 3a b5 48			ld a, (.dmark)  
48a4 32 b4 fe			ld (debug_mark),a  
48a7 3a b6 48			ld a, (.dmark+1)  
48aa 32 b5 fe			ld (debug_mark+1),a  
48ad 3a b7 48			ld a, (.dmark+2)  
48b0 32 b6 fe			ld (debug_mark+2),a  
48b3 18 03			jr .pastdmark  
48b5 ..			.dmark: db "ED1"  
48b8 f1			.pastdmark: pop af  
48b9			endm  
# End of macro DMARK
48b9						CALLMONITOR 
48b9 cd 7e 18			call break_point_state  
48bc				endm  
# End of macro CALLMONITOR
48bc					endif 
48bc cd 60 1f				call forth_push_str 
48bf					NEXTW 
48bf c3 60 22			jp macro_next 
48c2				endm 
# End of macro NEXTW
48c2			 
48c2			 
48c2			 
48c2			.ENDKEY: 
48c2			; eof 
48c2			 
# End of file forth_words_key.asm
48c2			 
48c2			if STORAGE_SE 
48c2			   	include "forth_words_storage.asm" 
48c2			 
48c2			; | ## Fixed Storage Words 
48c2			 
48c2			.RECORD: 
48c2			  
48c2				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
48c2 3a				db WORD_SYS_CORE+38             
48c3 66 49			dw .BREAD            
48c5 07				db 6 + 1 
48c6 .. 00			db "RECORD",0              
48cd				endm 
# End of macro CWHEAD
48cd			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
48cd			 
48cd					if DEBUG_FORTH_WORDS_KEY 
48cd						DMARK "REC" 
48cd f5				push af  
48ce 3a e2 48			ld a, (.dmark)  
48d1 32 b4 fe			ld (debug_mark),a  
48d4 3a e3 48			ld a, (.dmark+1)  
48d7 32 b5 fe			ld (debug_mark+1),a  
48da 3a e4 48			ld a, (.dmark+2)  
48dd 32 b6 fe			ld (debug_mark+2),a  
48e0 18 03			jr .pastdmark  
48e2 ..			.dmark: db "REC"  
48e5 f1			.pastdmark: pop af  
48e6			endm  
# End of macro DMARK
48e6						CALLMONITOR 
48e6 cd 7e 18			call break_point_state  
48e9				endm  
# End of macro CALLMONITOR
48e9					endif 
48e9			 
48e9					FORTH_DSP_VALUEHL 
48e9 cd e9 20			call macro_dsp_valuehl 
48ec				endm 
# End of macro FORTH_DSP_VALUEHL
48ec			 
48ec e5					push hl    ; id 
48ed			 
48ed					FORTH_DSP_POP 
48ed cd a1 21			call macro_forth_dsp_pop 
48f0				endm 
# End of macro FORTH_DSP_POP
48f0			 
48f0					FORTH_DSP_VALUEHL 
48f0 cd e9 20			call macro_dsp_valuehl 
48f3				endm 
# End of macro FORTH_DSP_VALUEHL
48f3			 
48f3					FORTH_DSP_POP 
48f3 cd a1 21			call macro_forth_dsp_pop 
48f6				endm 
# End of macro FORTH_DSP_POP
48f6			 
48f6 d1					pop de     ; get file id 
48f7			 
48f7					; e = file id 
48f7					; l = file extent 
48f7			 
48f7			 
48f7					; construct request to access file extent 
48f7			 
48f7			;		ld a, e 
48f7 63					ld h, e 
48f8					 
48f8					 
48f8					 
48f8			 
48f8					; e has id 
48f8			 
48f8 11 07 fc			ld de, store_page 
48fb					if DEBUG_FORTH_WORDS 
48fb						DMARK "REr" 
48fb f5				push af  
48fc 3a 10 49			ld a, (.dmark)  
48ff 32 b4 fe			ld (debug_mark),a  
4902 3a 11 49			ld a, (.dmark+1)  
4905 32 b5 fe			ld (debug_mark+1),a  
4908 3a 12 49			ld a, (.dmark+2)  
490b 32 b6 fe			ld (debug_mark+2),a  
490e 18 03			jr .pastdmark  
4910 ..			.dmark: db "REr"  
4913 f1			.pastdmark: pop af  
4914			endm  
# End of macro DMARK
4914						CALLMONITOR 
4914 cd 7e 18			call break_point_state  
4917				endm  
# End of macro CALLMONITOR
4917					endif 
4917 cd 2a 09				call storage_read 
491a cd 2a 0f			call ishlzero 
491d 28 22			jr z, .recnotfound 
491f			 
491f			 
491f					if DEBUG_FORTH_WORDS 
491f						DMARK "REe" 
491f f5				push af  
4920 3a 34 49			ld a, (.dmark)  
4923 32 b4 fe			ld (debug_mark),a  
4926 3a 35 49			ld a, (.dmark+1)  
4929 32 b5 fe			ld (debug_mark+1),a  
492c 3a 36 49			ld a, (.dmark+2)  
492f 32 b6 fe			ld (debug_mark+2),a  
4932 18 03			jr .pastdmark  
4934 ..			.dmark: db "REe"  
4937 f1			.pastdmark: pop af  
4938			endm  
# End of macro DMARK
4938						CALLMONITOR 
4938 cd 7e 18			call break_point_state  
493b				endm  
# End of macro CALLMONITOR
493b					endif 
493b cd 60 1f			call forth_push_str 
493e			 
493e					NEXTW 
493e c3 60 22			jp macro_next 
4941				endm 
# End of macro NEXTW
4941			 
4941			.recnotfound: 
4941					if DEBUG_FORTH_WORDS 
4941						DMARK "REf" 
4941 f5				push af  
4942 3a 56 49			ld a, (.dmark)  
4945 32 b4 fe			ld (debug_mark),a  
4948 3a 57 49			ld a, (.dmark+1)  
494b 32 b5 fe			ld (debug_mark+1),a  
494e 3a 58 49			ld a, (.dmark+2)  
4951 32 b6 fe			ld (debug_mark+2),a  
4954 18 03			jr .pastdmark  
4956 ..			.dmark: db "REf"  
4959 f1			.pastdmark: pop af  
495a			endm  
# End of macro DMARK
495a						CALLMONITOR 
495a cd 7e 18			call break_point_state  
495d				endm  
# End of macro CALLMONITOR
495d					endif 
495d 21 ff 00			ld hl, 255 
4960 cd f2 1e			call forth_push_numhl 
4963				NEXTW 
4963 c3 60 22			jp macro_next 
4966				endm 
# End of macro NEXTW
4966			 
4966			 
4966			.BREAD: 
4966			  
4966				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4966 3a				db WORD_SYS_CORE+38             
4967 e9 49			dw .BWRITE            
4969 06				db 5 + 1 
496a .. 00			db "BREAD",0              
4970				endm 
# End of macro CWHEAD
4970			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4970				 
4970					if DEBUG_FORTH_WORDS_KEY 
4970						DMARK "BRD" 
4970 f5				push af  
4971 3a 85 49			ld a, (.dmark)  
4974 32 b4 fe			ld (debug_mark),a  
4977 3a 86 49			ld a, (.dmark+1)  
497a 32 b5 fe			ld (debug_mark+1),a  
497d 3a 87 49			ld a, (.dmark+2)  
4980 32 b6 fe			ld (debug_mark+2),a  
4983 18 03			jr .pastdmark  
4985 ..			.dmark: db "BRD"  
4988 f1			.pastdmark: pop af  
4989			endm  
# End of macro DMARK
4989						CALLMONITOR 
4989 cd 7e 18			call break_point_state  
498c				endm  
# End of macro CALLMONITOR
498c					endif 
498c			 
498c				FORTH_DSP_VALUEHL 
498c cd e9 20			call macro_dsp_valuehl 
498f				endm 
# End of macro FORTH_DSP_VALUEHL
498f			 
498f				FORTH_DSP_POP 
498f cd a1 21			call macro_forth_dsp_pop 
4992				endm 
# End of macro FORTH_DSP_POP
4992			 
4992				; calc block address 
4992			 
4992 eb				ex de, hl 
4993 3e 40			ld a, STORE_BLOCK_PHY 
4995 cd 84 0e			call Mult16 
4998			 
4998			 
4998 11 07 fc			ld de, store_page 
499b			 
499b					if DEBUG_FORTH_WORDS 
499b						DMARK "BR1" 
499b f5				push af  
499c 3a b0 49			ld a, (.dmark)  
499f 32 b4 fe			ld (debug_mark),a  
49a2 3a b1 49			ld a, (.dmark+1)  
49a5 32 b5 fe			ld (debug_mark+1),a  
49a8 3a b2 49			ld a, (.dmark+2)  
49ab 32 b6 fe			ld (debug_mark+2),a  
49ae 18 03			jr .pastdmark  
49b0 ..			.dmark: db "BR1"  
49b3 f1			.pastdmark: pop af  
49b4			endm  
# End of macro DMARK
49b4						CALLMONITOR 
49b4 cd 7e 18			call break_point_state  
49b7				endm  
# End of macro CALLMONITOR
49b7					endif 
49b7			 
49b7 cd d1 03			call storage_read_block 
49ba			 
49ba cd 2a 0f			call ishlzero 
49bd 20 05			jr nz, .brfound 
49bf			 
49bf cd f2 1e			call forth_push_numhl 
49c2 18 22			jr .brdone 
49c4			 
49c4			 
49c4			.brfound: 
49c4 21 09 fc		        ld hl, store_page+2 
49c7			 
49c7					if DEBUG_FORTH_WORDS 
49c7						DMARK "BR2" 
49c7 f5				push af  
49c8 3a dc 49			ld a, (.dmark)  
49cb 32 b4 fe			ld (debug_mark),a  
49ce 3a dd 49			ld a, (.dmark+1)  
49d1 32 b5 fe			ld (debug_mark+1),a  
49d4 3a de 49			ld a, (.dmark+2)  
49d7 32 b6 fe			ld (debug_mark+2),a  
49da 18 03			jr .pastdmark  
49dc ..			.dmark: db "BR2"  
49df f1			.pastdmark: pop af  
49e0			endm  
# End of macro DMARK
49e0						CALLMONITOR 
49e0 cd 7e 18			call break_point_state  
49e3				endm  
# End of macro CALLMONITOR
49e3					endif 
49e3			 
49e3 cd 60 1f			call forth_push_str 
49e6			 
49e6			 
49e6			.brdone: 
49e6			 
49e6					NEXTW 
49e6 c3 60 22			jp macro_next 
49e9				endm 
# End of macro NEXTW
49e9			.BWRITE: 
49e9				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
49e9 3a				db WORD_SYS_CORE+38             
49ea 7e 4a			dw .BUPD            
49ec 07				db 6 + 1 
49ed .. 00			db "BWRITE",0              
49f4				endm 
# End of macro CWHEAD
49f4			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
49f4			 
49f4					if DEBUG_FORTH_WORDS_KEY 
49f4						DMARK "BWR" 
49f4 f5				push af  
49f5 3a 09 4a			ld a, (.dmark)  
49f8 32 b4 fe			ld (debug_mark),a  
49fb 3a 0a 4a			ld a, (.dmark+1)  
49fe 32 b5 fe			ld (debug_mark+1),a  
4a01 3a 0b 4a			ld a, (.dmark+2)  
4a04 32 b6 fe			ld (debug_mark+2),a  
4a07 18 03			jr .pastdmark  
4a09 ..			.dmark: db "BWR"  
4a0c f1			.pastdmark: pop af  
4a0d			endm  
# End of macro DMARK
4a0d						CALLMONITOR 
4a0d cd 7e 18			call break_point_state  
4a10				endm  
# End of macro CALLMONITOR
4a10					endif 
4a10			 
4a10				FORTH_DSP_VALUEHL 
4a10 cd e9 20			call macro_dsp_valuehl 
4a13				endm 
# End of macro FORTH_DSP_VALUEHL
4a13			 
4a13				; calc block address 
4a13			 
4a13 eb				ex de, hl 
4a14 3e 40			ld a, STORE_BLOCK_PHY 
4a16 cd 84 0e			call Mult16 
4a19			 
4a19 e5				push hl         ; address 
4a1a			 
4a1a				FORTH_DSP_POP 
4a1a cd a1 21			call macro_forth_dsp_pop 
4a1d				endm 
# End of macro FORTH_DSP_POP
4a1d			 
4a1d				FORTH_DSP_VALUEHL 
4a1d cd e9 20			call macro_dsp_valuehl 
4a20				endm 
# End of macro FORTH_DSP_VALUEHL
4a20			 
4a20				FORTH_DSP_POP 
4a20 cd a1 21			call macro_forth_dsp_pop 
4a23				endm 
# End of macro FORTH_DSP_POP
4a23			 
4a23 cd 0d 0c			call storage_clear_page 
4a26			 
4a26				; copy string to store page 
4a26			 
4a26 e5				push hl     ; save string address 
4a27			 
4a27 3e 00			ld a, 0 
4a29 cd 6a 13			call strlent 
4a2c			 
4a2c 23				inc hl 
4a2d			 
4a2d 4d				ld c, l 
4a2e 06 00			ld b, 0 
4a30			 
4a30 e1				pop hl 
4a31 11 09 fc			ld de, store_page + 2 
4a34					if DEBUG_FORTH_WORDS 
4a34						DMARK "BW1" 
4a34 f5				push af  
4a35 3a 49 4a			ld a, (.dmark)  
4a38 32 b4 fe			ld (debug_mark),a  
4a3b 3a 4a 4a			ld a, (.dmark+1)  
4a3e 32 b5 fe			ld (debug_mark+1),a  
4a41 3a 4b 4a			ld a, (.dmark+2)  
4a44 32 b6 fe			ld (debug_mark+2),a  
4a47 18 03			jr .pastdmark  
4a49 ..			.dmark: db "BW1"  
4a4c f1			.pastdmark: pop af  
4a4d			endm  
# End of macro DMARK
4a4d						CALLMONITOR 
4a4d cd 7e 18			call break_point_state  
4a50				endm  
# End of macro CALLMONITOR
4a50					endif 
4a50 ed b0			ldir 
4a52			 
4a52			 
4a52				; poke the start of the block with flags to prevent high level file ops hitting the block 
4a52			 
4a52 21 ff ff			ld hl, $ffff 
4a55			 
4a55 22 07 fc			ld (store_page), hl	 
4a58				 
4a58 e1				pop hl    ; get address 
4a59 11 07 fc			ld de, store_page 
4a5c			 
4a5c					if DEBUG_FORTH_WORDS 
4a5c						DMARK "BW2" 
4a5c f5				push af  
4a5d 3a 71 4a			ld a, (.dmark)  
4a60 32 b4 fe			ld (debug_mark),a  
4a63 3a 72 4a			ld a, (.dmark+1)  
4a66 32 b5 fe			ld (debug_mark+1),a  
4a69 3a 73 4a			ld a, (.dmark+2)  
4a6c 32 b6 fe			ld (debug_mark+2),a  
4a6f 18 03			jr .pastdmark  
4a71 ..			.dmark: db "BW2"  
4a74 f1			.pastdmark: pop af  
4a75			endm  
# End of macro DMARK
4a75						CALLMONITOR 
4a75 cd 7e 18			call break_point_state  
4a78				endm  
# End of macro CALLMONITOR
4a78					endif 
4a78			 
4a78 cd 36 04			call storage_write_block 
4a7b			 
4a7b					NEXTW 
4a7b c3 60 22			jp macro_next 
4a7e				endm 
# End of macro NEXTW
4a7e			 
4a7e			.BUPD: 
4a7e				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4a7e 3a				db WORD_SYS_CORE+38             
4a7f d4 4a			dw .BYID            
4a81 05				db 4 + 1 
4a82 .. 00			db "BUPD",0              
4a87				endm 
# End of macro CWHEAD
4a87			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4a87			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4a87			; | | or completely different file system structure. 
4a87			 
4a87					if DEBUG_FORTH_WORDS_KEY 
4a87						DMARK "BUD" 
4a87 f5				push af  
4a88 3a 9c 4a			ld a, (.dmark)  
4a8b 32 b4 fe			ld (debug_mark),a  
4a8e 3a 9d 4a			ld a, (.dmark+1)  
4a91 32 b5 fe			ld (debug_mark+1),a  
4a94 3a 9e 4a			ld a, (.dmark+2)  
4a97 32 b6 fe			ld (debug_mark+2),a  
4a9a 18 03			jr .pastdmark  
4a9c ..			.dmark: db "BUD"  
4a9f f1			.pastdmark: pop af  
4aa0			endm  
# End of macro DMARK
4aa0						CALLMONITOR 
4aa0 cd 7e 18			call break_point_state  
4aa3				endm  
# End of macro CALLMONITOR
4aa3					endif 
4aa3			 
4aa3				FORTH_DSP_VALUEHL 
4aa3 cd e9 20			call macro_dsp_valuehl 
4aa6				endm 
# End of macro FORTH_DSP_VALUEHL
4aa6			 
4aa6				; calc block address 
4aa6			 
4aa6 eb				ex de, hl 
4aa7 3e 40			ld a, STORE_BLOCK_PHY 
4aa9 cd 84 0e			call Mult16 
4aac			 
4aac				FORTH_DSP_POP 
4aac cd a1 21			call macro_forth_dsp_pop 
4aaf				endm 
# End of macro FORTH_DSP_POP
4aaf			 
4aaf			 
4aaf 11 07 fc			ld de, store_page 
4ab2			 
4ab2					if DEBUG_FORTH_WORDS 
4ab2						DMARK "BUe" 
4ab2 f5				push af  
4ab3 3a c7 4a			ld a, (.dmark)  
4ab6 32 b4 fe			ld (debug_mark),a  
4ab9 3a c8 4a			ld a, (.dmark+1)  
4abc 32 b5 fe			ld (debug_mark+1),a  
4abf 3a c9 4a			ld a, (.dmark+2)  
4ac2 32 b6 fe			ld (debug_mark+2),a  
4ac5 18 03			jr .pastdmark  
4ac7 ..			.dmark: db "BUe"  
4aca f1			.pastdmark: pop af  
4acb			endm  
# End of macro DMARK
4acb						CALLMONITOR 
4acb cd 7e 18			call break_point_state  
4ace				endm  
# End of macro CALLMONITOR
4ace					endif 
4ace			 
4ace cd 36 04			call storage_write_block 
4ad1			 
4ad1					NEXTW 
4ad1 c3 60 22			jp macro_next 
4ad4				endm 
# End of macro NEXTW
4ad4			 
4ad4			.BYID: 
4ad4			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4ad4			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4ad4			; 
4ad4			;		 
4ad4			;		if DEBUG_FORTH_WORDS_KEY 
4ad4			;			DMARK "BYID" 
4ad4			;			CALLMONITOR 
4ad4			;		endif 
4ad4			; 
4ad4			;		; get direct address 
4ad4			; 
4ad4			;		FORTH_DSP_VALUEHL 
4ad4			; 
4ad4			;		FORTH_DSP_POP 
4ad4			; 
4ad4			;	; calc block address 
4ad4			; 
4ad4			;	ex de, hl 
4ad4			;	ld a, STORE_BLOCK_PHY 
4ad4			;	call Mult16 
4ad4			;	;	do BREAD with number as param 
4ad4			;	; push the file name	 
4ad4			;	ld de, store_page 
4ad4			;	call storage_read_block 
4ad4			 ;       ld hl, store_page+2 
4ad4			; 
4ad4			; 
4ad4			;		NEXTW 
4ad4			;.BYNAME: 
4ad4				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4ad4 3a				db WORD_SYS_CORE+38             
4ad5 ed 4a			dw .DIR            
4ad7 06				db 5 + 1 
4ad8 .. 00			db "GETID",0              
4ade				endm 
# End of macro CWHEAD
4ade			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4ade			 
4ade					; get pointer to file name to seek 
4ade			 
4ade					FORTH_DSP_VALUEHL 
4ade cd e9 20			call macro_dsp_valuehl 
4ae1				endm 
# End of macro FORTH_DSP_VALUEHL
4ae1			 
4ae1			 
4ae1 cd f8 02				call storage_getid  
4ae4			 
4ae4					FORTH_DSP_POP 
4ae4 cd a1 21			call macro_forth_dsp_pop 
4ae7				endm 
# End of macro FORTH_DSP_POP
4ae7			 
4ae7 cd f2 1e				call forth_push_numhl 
4aea			 
4aea					NEXTW 
4aea c3 60 22			jp macro_next 
4aed				endm 
# End of macro NEXTW
4aed			; 
4aed			.DIR: 
4aed				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4aed 3a				db WORD_SYS_CORE+38             
4aee f1 4b			dw .SAVE            
4af0 04				db 3 + 1 
4af1 .. 00			db "DIR",0              
4af5				endm 
# End of macro CWHEAD
4af5			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4af5			 
4af5					if DEBUG_FORTH_WORDS_KEY 
4af5						DMARK "DIR" 
4af5 f5				push af  
4af6 3a 0a 4b			ld a, (.dmark)  
4af9 32 b4 fe			ld (debug_mark),a  
4afc 3a 0b 4b			ld a, (.dmark+1)  
4aff 32 b5 fe			ld (debug_mark+1),a  
4b02 3a 0c 4b			ld a, (.dmark+2)  
4b05 32 b6 fe			ld (debug_mark+2),a  
4b08 18 03			jr .pastdmark  
4b0a ..			.dmark: db "DIR"  
4b0d f1			.pastdmark: pop af  
4b0e			endm  
# End of macro DMARK
4b0e						CALLMONITOR 
4b0e cd 7e 18			call break_point_state  
4b11				endm  
# End of macro CALLMONITOR
4b11					endif 
4b11 cd 82 04			call storage_get_block_0 
4b14			 
4b14 21 07 fc			ld hl, store_page     ; get current id count 
4b17 46				ld b, (hl) 
4b18 0e 00			ld c, 0    ; count of files   
4b1a					if DEBUG_FORTH_WORDS 
4b1a						DMARK "DI1" 
4b1a f5				push af  
4b1b 3a 2f 4b			ld a, (.dmark)  
4b1e 32 b4 fe			ld (debug_mark),a  
4b21 3a 30 4b			ld a, (.dmark+1)  
4b24 32 b5 fe			ld (debug_mark+1),a  
4b27 3a 31 4b			ld a, (.dmark+2)  
4b2a 32 b6 fe			ld (debug_mark+2),a  
4b2d 18 03			jr .pastdmark  
4b2f ..			.dmark: db "DI1"  
4b32 f1			.pastdmark: pop af  
4b33			endm  
# End of macro DMARK
4b33						CALLMONITOR 
4b33 cd 7e 18			call break_point_state  
4b36				endm  
# End of macro CALLMONITOR
4b36					endif 
4b36			 
4b36				; check for empty drive 
4b36			 
4b36 3e 00			ld a, 0 
4b38 b8				cp b 
4b39 ca a7 4b			jp z, .dirdone 
4b3c			 
4b3c				; for each of the current ids do a search for them and if found push to stack 
4b3c			 
4b3c c5			.diritem:	push bc 
4b3d 21 40 00				ld hl, STORE_BLOCK_PHY 
4b40 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4b42 58					ld e,b 
4b43			 
4b43			;		if DEBUG_FORTH_WORDS 
4b43			;			DMARK "DI2" 
4b43			;			CALLMONITOR 
4b43			;		endif 
4b43			 
4b43 cd 04 07				call storage_findnextid 
4b46			 
4b46			;		if DEBUG_FORTH_WORDS 
4b46			;			DMARK "DI3" 
4b46			;			CALLMONITOR 
4b46			;		endif 
4b46			 
4b46					; if found hl will be non zero 
4b46			 
4b46 cd 2a 0f				call ishlzero 
4b49			;		ld a, l 
4b49			;		add h 
4b49			; 
4b49			;		cp 0 
4b49 28 59				jr z, .dirnotfound 
4b4b			 
4b4b					; increase count 
4b4b			 
4b4b c1					pop bc	 
4b4c 0c					inc c 
4b4d c5					push bc 
4b4e					 
4b4e			 
4b4e					; get file header and push the file name 
4b4e			 
4b4e 11 07 fc				ld de, store_page 
4b51 cd d1 03				call storage_read_block 
4b54			 
4b54					; push file id to stack 
4b54				 
4b54 3a 07 fc				ld a, (store_page) 
4b57 26 00				ld h, 0 
4b59 6f					ld l, a 
4b5a cd f2 1e				call forth_push_numhl 
4b5d			 
4b5d					; push extent count to stack  
4b5d				 
4b5d 3a 09 fc				ld a, (store_page+2) 
4b60 26 00				ld h, 0 
4b62 6f					ld l, a 
4b63 cd f2 1e				call forth_push_numhl 
4b66			 
4b66					; push file name 
4b66			 
4b66 21 0a fc				ld hl, store_page+3 
4b69					if DEBUG_FORTH_WORDS 
4b69						DMARK "DI5" 
4b69 f5				push af  
4b6a 3a 7e 4b			ld a, (.dmark)  
4b6d 32 b4 fe			ld (debug_mark),a  
4b70 3a 7f 4b			ld a, (.dmark+1)  
4b73 32 b5 fe			ld (debug_mark+1),a  
4b76 3a 80 4b			ld a, (.dmark+2)  
4b79 32 b6 fe			ld (debug_mark+2),a  
4b7c 18 03			jr .pastdmark  
4b7e ..			.dmark: db "DI5"  
4b81 f1			.pastdmark: pop af  
4b82			endm  
# End of macro DMARK
4b82						CALLMONITOR 
4b82 cd 7e 18			call break_point_state  
4b85				endm  
# End of macro CALLMONITOR
4b85					endif 
4b85 cd 60 1f				call forth_push_str 
4b88					if DEBUG_FORTH_WORDS 
4b88						DMARK "DI6" 
4b88 f5				push af  
4b89 3a 9d 4b			ld a, (.dmark)  
4b8c 32 b4 fe			ld (debug_mark),a  
4b8f 3a 9e 4b			ld a, (.dmark+1)  
4b92 32 b5 fe			ld (debug_mark+1),a  
4b95 3a 9f 4b			ld a, (.dmark+2)  
4b98 32 b6 fe			ld (debug_mark+2),a  
4b9b 18 03			jr .pastdmark  
4b9d ..			.dmark: db "DI6"  
4ba0 f1			.pastdmark: pop af  
4ba1			endm  
# End of macro DMARK
4ba1						CALLMONITOR 
4ba1 cd 7e 18			call break_point_state  
4ba4				endm  
# End of macro CALLMONITOR
4ba4					endif 
4ba4			.dirnotfound: 
4ba4 c1					pop bc     
4ba5 10 95				djnz .diritem 
4ba7				 
4ba7			.dirdone:	 
4ba7					if DEBUG_FORTH_WORDS 
4ba7						DMARK "DI7" 
4ba7 f5				push af  
4ba8 3a bc 4b			ld a, (.dmark)  
4bab 32 b4 fe			ld (debug_mark),a  
4bae 3a bd 4b			ld a, (.dmark+1)  
4bb1 32 b5 fe			ld (debug_mark+1),a  
4bb4 3a be 4b			ld a, (.dmark+2)  
4bb7 32 b6 fe			ld (debug_mark+2),a  
4bba 18 03			jr .pastdmark  
4bbc ..			.dmark: db "DI7"  
4bbf f1			.pastdmark: pop af  
4bc0			endm  
# End of macro DMARK
4bc0						CALLMONITOR 
4bc0 cd 7e 18			call break_point_state  
4bc3				endm  
# End of macro CALLMONITOR
4bc3					endif 
4bc3			 
4bc3					; push a count of the dir items found 
4bc3			 
4bc3 26 00				ld h, 0 
4bc5 69					ld l, c 
4bc6 cd f2 1e				call forth_push_numhl 
4bc9			 
4bc9					; push the bank label 
4bc9			 
4bc9 cd 82 04				call storage_get_block_0 
4bcc			 
4bcc				 
4bcc 21 0a fc		 		ld hl, store_page+3 
4bcf			 
4bcf					if DEBUG_FORTH_WORDS 
4bcf						DMARK "DI8" 
4bcf f5				push af  
4bd0 3a e4 4b			ld a, (.dmark)  
4bd3 32 b4 fe			ld (debug_mark),a  
4bd6 3a e5 4b			ld a, (.dmark+1)  
4bd9 32 b5 fe			ld (debug_mark+1),a  
4bdc 3a e6 4b			ld a, (.dmark+2)  
4bdf 32 b6 fe			ld (debug_mark+2),a  
4be2 18 03			jr .pastdmark  
4be4 ..			.dmark: db "DI8"  
4be7 f1			.pastdmark: pop af  
4be8			endm  
# End of macro DMARK
4be8						CALLMONITOR 
4be8 cd 7e 18			call break_point_state  
4beb				endm  
# End of macro CALLMONITOR
4beb					endif 
4beb cd 60 1f				call forth_push_str 
4bee			 
4bee			 
4bee				 
4bee					NEXTW 
4bee c3 60 22			jp macro_next 
4bf1				endm 
# End of macro NEXTW
4bf1			.SAVE: 
4bf1			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4bf1			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4bf1			;		NEXTW 
4bf1			;.LOAD: 
4bf1			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4bf1			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4bf1			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4bf1			;; > > The LOAD command can not be used in any user words or compound lines. 
4bf1			; 
4bf1			;		; store_openext use it. If zero it is EOF 
4bf1			; 
4bf1			;		; read block from current stream id 
4bf1			;		; if the block does not contain zero term keep reading blocks until zero found 
4bf1			;		; push the block to stack 
4bf1			;		; save the block id to stream 
4bf1			; 
4bf1			; 
4bf1			;		FORTH_DSP_VALUEHL 
4bf1			; 
4bf1			;;		push hl 
4bf1			; 
4bf1			;	if DEBUG_STORESE 
4bf1			;		DMARK "LOA" 
4bf1			;		CALLMONITOR 
4bf1			;	endif 
4bf1			;		FORTH_DSP_POP 
4bf1			; 
4bf1			;;		pop hl 
4bf1			; 
4bf1			;		ld h, l 
4bf1			;		ld l, 0 
4bf1			; 
4bf1			;		push hl     ; stack holds current file id and extent to work with 
4bf1			; 
4bf1			; 
4bf1			;		ld de, store_page      ; get block zero of file 
4bf1			;	if DEBUG_STORESE 
4bf1			;		DMARK "LO0" 
4bf1			;		CALLMONITOR 
4bf1			;	endif 
4bf1			;		call storage_read 
4bf1			; 
4bf1			;		ld a, (store_page+2)    ; max extents for this file 
4bf1			;		ld  (store_openmaxext),a   ; get our limit 
4bf1			; 
4bf1			;	if DEBUG_STORESE 
4bf1			;		DMARK "LOE" 
4bf1			;		CALLMONITOR 
4bf1			;	endif 
4bf1			; 
4bf1			;; TODO dont know why max extents are not present 
4bf1			;;		cp 0 
4bf1			;;		jp z, .loadeof     ; dont read past eof 
4bf1			; 
4bf1			;;		ld a, 1   ; start from the head of the file 
4bf1			; 
4bf1			;.loadline:	pop hl 
4bf1			;		inc hl 
4bf1			;		ld  a, (store_openmaxext)   ; get our limit 
4bf1			;	if DEBUG_STORESE 
4bf1			;		DMARK "LOx" 
4bf1			;		CALLMONITOR 
4bf1			;	endif 
4bf1			;		inc a 
4bf1			;		cp l 
4bf1			;		jp z, .loadeof 
4bf1			;		push hl    ; save current extent 
4bf1			; 
4bf1			;		ld de, store_page 
4bf1			; 
4bf1			;	if DEBUG_STORESE 
4bf1			;		DMARK "LO1" 
4bf1			;		CALLMONITOR 
4bf1			;	endif 
4bf1			;		call storage_read 
4bf1			; 
4bf1			;	if DEBUG_STORESE 
4bf1			;		DMARK "LO2" 
4bf1			;		CALLMONITOR 
4bf1			;	endif 
4bf1			;	call ishlzero 
4bf1			;	ld a, l 
4bf1			;	add h 
4bf1			;	cp 0 
4bf1			;	jr z, .loadeof 
4bf1			; 
4bf1			;	; not eof so hl should point to data to exec 
4bf1			; 
4bf1			;	; will need to add the FORTH_END_BUFFER flag 
4bf1			 ; 
4bf1			;	ld hl, store_page+2 
4bf1			;	ld bc, 255 
4bf1			;	ld a, 0 
4bf1			;	cpir 
4bf1			;	if DEBUG_STORESE 
4bf1			;		DMARK "LOt" 
4bf1			;		CALLMONITOR 
4bf1			;	endif 
4bf1			;	dec hl 
4bf1			;	ld a, ' ' 
4bf1			;	ld (hl), a 
4bf1			;	inc hl 
4bf1			;	ld (hl), a 
4bf1			;	inc hl 
4bf1			;	ld (hl), a 
4bf1			;	inc hl 
4bf1			;	ld a, FORTH_END_BUFFER 
4bf1			;	ld (hl), a 
4bf1			; 
4bf1			;	; TODO handle more than a single block read 
4bf1			; 
4bf1			; 
4bf1			;	ld hl, store_page+2 
4bf1			; 
4bf1			;	ld (os_tok_ptr), hl 
4bf1			; 
4bf1			;	if DEBUG_STORESE 
4bf1			;		DMARK "LO3" 
4bf1			;		CALLMONITOR 
4bf1			;	endif 
4bf1			; 
4bf1			;	call forthparse 
4bf1			;	call forthexec 
4bf1			;	call forthexec_cleanup 
4bf1			; 
4bf1			;	; go to next extent 
4bf1			; 
4bf1			;	; get next block  or mark as eof 
4bf1			;	jp .loadline 
4bf1			; 
4bf1			; 
4bf1			; 
4bf1			;	       NEXTW 
4bf1			;.loadeof:	ld a, 0 
4bf1			;		ld (store_openext), a 
4bf1			; 
4bf1			;	if DEBUG_STORESE 
4bf1			;		DMARK "LOF" 
4bf1			;		CALLMONITOR 
4bf1			;	endif 
4bf1			;		ret 
4bf1			;		;NEXTW 
4bf1			;.BSAVE:   
4bf1			; 
4bf1			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4bf1			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4bf1			;		NEXTW 
4bf1			;.BLOAD: 
4bf1			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4bf1			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4bf1			;		NEXTW 
4bf1			;;;; counter gap 
4bf1			 
4bf1			 
4bf1			.SEO: 
4bf1				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4bf1 64				db WORD_SYS_CORE+80             
4bf2 10 4c			dw .SEI            
4bf4 04				db 3 + 1 
4bf5 .. 00			db "SEO",0              
4bf9				endm 
# End of macro CWHEAD
4bf9			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4bf9			 
4bf9					; get port 
4bf9			 
4bf9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bf9 cd e9 20			call macro_dsp_valuehl 
4bfc				endm 
# End of macro FORTH_DSP_VALUEHL
4bfc			 
4bfc e5					push hl    ; u2 - byte 
4bfd			 
4bfd					; destroy value TOS 
4bfd			 
4bfd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bfd cd a1 21			call macro_forth_dsp_pop 
4c00				endm 
# End of macro FORTH_DSP_POP
4c00			 
4c00					; get byte to send 
4c00			 
4c00					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c00 cd e9 20			call macro_dsp_valuehl 
4c03				endm 
# End of macro FORTH_DSP_VALUEHL
4c03			 
4c03 e5					push hl    ; u1 - addr 
4c04			 
4c04					; destroy value TOS 
4c04			 
4c04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c04 cd a1 21			call macro_forth_dsp_pop 
4c07				endm 
# End of macro FORTH_DSP_POP
4c07			 
4c07					; one value on hl get other one back 
4c07			 
4c07 d1					pop de   ; u1 - byte 
4c08			 
4c08 e1					pop hl   ; u2 - addr 
4c09			 
4c09					; TODO Send SPI byte 
4c09			 
4c09			 
4c09 7b					ld a, e 
4c0a cd d6 01				call se_writebyte 
4c0d			 
4c0d					 
4c0d			 
4c0d					NEXTW 
4c0d c3 60 22			jp macro_next 
4c10				endm 
# End of macro NEXTW
4c10			 
4c10			.SEI: 
4c10				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4c10 65				db WORD_SYS_CORE+81             
4c11 2a 4c			dw .SFREE            
4c13 04				db 3 + 1 
4c14 .. 00			db "SEI",0              
4c18				endm 
# End of macro CWHEAD
4c18			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4c18			 
4c18					; get port 
4c18			 
4c18					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c18 cd e9 20			call macro_dsp_valuehl 
4c1b				endm 
# End of macro FORTH_DSP_VALUEHL
4c1b			 
4c1b			;		push hl 
4c1b			 
4c1b					; destroy value TOS 
4c1b			 
4c1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c1b cd a1 21			call macro_forth_dsp_pop 
4c1e				endm 
# End of macro FORTH_DSP_POP
4c1e			 
4c1e					; one value on hl get other one back 
4c1e			 
4c1e			;		pop hl 
4c1e			 
4c1e			 
4c1e					; TODO Get SPI byte 
4c1e			 
4c1e cd 78 02				call se_readbyte 
4c21			 
4c21 26 00				ld h, 0 
4c23 6f					ld l, a 
4c24 cd f2 1e				call forth_push_numhl 
4c27			 
4c27					NEXTW 
4c27 c3 60 22			jp macro_next 
4c2a				endm 
# End of macro NEXTW
4c2a			 
4c2a			.SFREE: 
4c2a				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4c2a 67				db WORD_SYS_CORE+83             
4c2b 59 4c			dw .SIZE            
4c2d 06				db 5 + 1 
4c2e .. 00			db "FFREE",0              
4c34				endm 
# End of macro CWHEAD
4c34			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4c34					if DEBUG_FORTH_WORDS_KEY 
4c34						DMARK "FFR" 
4c34 f5				push af  
4c35 3a 49 4c			ld a, (.dmark)  
4c38 32 b4 fe			ld (debug_mark),a  
4c3b 3a 4a 4c			ld a, (.dmark+1)  
4c3e 32 b5 fe			ld (debug_mark+1),a  
4c41 3a 4b 4c			ld a, (.dmark+2)  
4c44 32 b6 fe			ld (debug_mark+2),a  
4c47 18 03			jr .pastdmark  
4c49 ..			.dmark: db "FFR"  
4c4c f1			.pastdmark: pop af  
4c4d			endm  
# End of macro DMARK
4c4d						CALLMONITOR 
4c4d cd 7e 18			call break_point_state  
4c50				endm  
# End of macro CALLMONITOR
4c50					endif 
4c50			 
4c50 cd 9e 07				call storage_freeblocks 
4c53			 
4c53 cd f2 1e				call forth_push_numhl 
4c56			 
4c56				       NEXTW 
4c56 c3 60 22			jp macro_next 
4c59				endm 
# End of macro NEXTW
4c59			.SIZE: 
4c59				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4c59 67				db WORD_SYS_CORE+83             
4c5a 8d 4c			dw .CREATE            
4c5c 05				db 4 + 1 
4c5d .. 00			db "SIZE",0              
4c62				endm 
# End of macro CWHEAD
4c62			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4c62					if DEBUG_FORTH_WORDS_KEY 
4c62						DMARK "SIZ" 
4c62 f5				push af  
4c63 3a 77 4c			ld a, (.dmark)  
4c66 32 b4 fe			ld (debug_mark),a  
4c69 3a 78 4c			ld a, (.dmark+1)  
4c6c 32 b5 fe			ld (debug_mark+1),a  
4c6f 3a 79 4c			ld a, (.dmark+2)  
4c72 32 b6 fe			ld (debug_mark+2),a  
4c75 18 03			jr .pastdmark  
4c77 ..			.dmark: db "SIZ"  
4c7a f1			.pastdmark: pop af  
4c7b			endm  
# End of macro DMARK
4c7b						CALLMONITOR 
4c7b cd 7e 18			call break_point_state  
4c7e				endm  
# End of macro CALLMONITOR
4c7e					endif 
4c7e			 
4c7e					FORTH_DSP_VALUEHL 
4c7e cd e9 20			call macro_dsp_valuehl 
4c81				endm 
# End of macro FORTH_DSP_VALUEHL
4c81			;		push hl 
4c81					FORTH_DSP_POP 
4c81 cd a1 21			call macro_forth_dsp_pop 
4c84				endm 
# End of macro FORTH_DSP_POP
4c84			;		pop hl 
4c84 cd 00 04				call storage_file_size 
4c87			 
4c87 cd f2 1e				call forth_push_numhl 
4c8a			  
4c8a			 
4c8a				       NEXTW 
4c8a c3 60 22			jp macro_next 
4c8d				endm 
# End of macro NEXTW
4c8d			 
4c8d			.CREATE: 
4c8d				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4c8d 68				db WORD_SYS_CORE+84             
4c8e fb 4c			dw .APPEND            
4c90 07				db 6 + 1 
4c91 .. 00			db "CREATE",0              
4c98				endm 
# End of macro CWHEAD
4c98			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4c98			; | | e.g.  
4c98			; | | TestProgram CREATE 
4c98			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4c98			; | |  
4c98			; | | Max file IDs are 255. 
4c98			; | |  
4c98					 
4c98					if DEBUG_FORTH_WORDS_KEY 
4c98						DMARK "CRT" 
4c98 f5				push af  
4c99 3a ad 4c			ld a, (.dmark)  
4c9c 32 b4 fe			ld (debug_mark),a  
4c9f 3a ae 4c			ld a, (.dmark+1)  
4ca2 32 b5 fe			ld (debug_mark+1),a  
4ca5 3a af 4c			ld a, (.dmark+2)  
4ca8 32 b6 fe			ld (debug_mark+2),a  
4cab 18 03			jr .pastdmark  
4cad ..			.dmark: db "CRT"  
4cb0 f1			.pastdmark: pop af  
4cb1			endm  
# End of macro DMARK
4cb1						CALLMONITOR 
4cb1 cd 7e 18			call break_point_state  
4cb4				endm  
# End of macro CALLMONITOR
4cb4					endif 
4cb4			;		call storage_get_block_0 
4cb4			 
4cb4					; TODO pop hl 
4cb4			 
4cb4					;v5 FORTH_DSP_VALUE 
4cb4					FORTH_DSP_VALUE 
4cb4 cd d2 20			call macro_forth_dsp_value 
4cb7				endm 
# End of macro FORTH_DSP_VALUE
4cb7			 
4cb7				if DEBUG_STORESE 
4cb7					DMARK "CR1" 
4cb7 f5				push af  
4cb8 3a cc 4c			ld a, (.dmark)  
4cbb 32 b4 fe			ld (debug_mark),a  
4cbe 3a cd 4c			ld a, (.dmark+1)  
4cc1 32 b5 fe			ld (debug_mark+1),a  
4cc4 3a ce 4c			ld a, (.dmark+2)  
4cc7 32 b6 fe			ld (debug_mark+2),a  
4cca 18 03			jr .pastdmark  
4ccc ..			.dmark: db "CR1"  
4ccf f1			.pastdmark: pop af  
4cd0			endm  
# End of macro DMARK
4cd0					CALLMONITOR 
4cd0 cd 7e 18			call break_point_state  
4cd3				endm  
# End of macro CALLMONITOR
4cd3				endif 
4cd3			;		push hl 
4cd3			;		FORTH_DSP_POP 
4cd3			;		pop hl 
4cd3			 
4cd3			;		inc hl   ; move past the type marker 
4cd3			 
4cd3 cd d4 07				call storage_create 
4cd6			 
4cd6				if DEBUG_STORESE 
4cd6					DMARK "CT1" 
4cd6 f5				push af  
4cd7 3a eb 4c			ld a, (.dmark)  
4cda 32 b4 fe			ld (debug_mark),a  
4cdd 3a ec 4c			ld a, (.dmark+1)  
4ce0 32 b5 fe			ld (debug_mark+1),a  
4ce3 3a ed 4c			ld a, (.dmark+2)  
4ce6 32 b6 fe			ld (debug_mark+2),a  
4ce9 18 03			jr .pastdmark  
4ceb ..			.dmark: db "CT1"  
4cee f1			.pastdmark: pop af  
4cef			endm  
# End of macro DMARK
4cef					CALLMONITOR 
4cef cd 7e 18			call break_point_state  
4cf2				endm  
# End of macro CALLMONITOR
4cf2				endif 
4cf2			;		push hl 
4cf2					FORTH_DSP_POP 
4cf2 cd a1 21			call macro_forth_dsp_pop 
4cf5				endm 
# End of macro FORTH_DSP_POP
4cf5			;		pop hl 
4cf5					; push file id to stack 
4cf5 cd f2 1e				call forth_push_numhl 
4cf8			 
4cf8			 
4cf8			 
4cf8				       NEXTW 
4cf8 c3 60 22			jp macro_next 
4cfb				endm 
# End of macro NEXTW
4cfb			 
4cfb			.APPEND: 
4cfb				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4cfb 69				db WORD_SYS_CORE+85             
4cfc 8c 4d			dw .SDEL            
4cfe 07				db 6 + 1 
4cff .. 00			db "APPEND",0              
4d06				endm 
# End of macro CWHEAD
4d06			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4d06			; | | e.g. 
4d06			; | | Test CREATE      -> $01 
4d06			; | | "A string to add to file" $01 APPEND 
4d06			; | |  
4d06			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4d06					if DEBUG_FORTH_WORDS_KEY 
4d06						DMARK "APP" 
4d06 f5				push af  
4d07 3a 1b 4d			ld a, (.dmark)  
4d0a 32 b4 fe			ld (debug_mark),a  
4d0d 3a 1c 4d			ld a, (.dmark+1)  
4d10 32 b5 fe			ld (debug_mark+1),a  
4d13 3a 1d 4d			ld a, (.dmark+2)  
4d16 32 b6 fe			ld (debug_mark+2),a  
4d19 18 03			jr .pastdmark  
4d1b ..			.dmark: db "APP"  
4d1e f1			.pastdmark: pop af  
4d1f			endm  
# End of macro DMARK
4d1f						CALLMONITOR 
4d1f cd 7e 18			call break_point_state  
4d22				endm  
# End of macro CALLMONITOR
4d22					endif 
4d22			 
4d22					FORTH_DSP_VALUEHL 
4d22 cd e9 20			call macro_dsp_valuehl 
4d25				endm 
# End of macro FORTH_DSP_VALUEHL
4d25 e5					push hl 	; save file id 
4d26			 
4d26				if DEBUG_STORESE 
4d26					DMARK "AP1" 
4d26 f5				push af  
4d27 3a 3b 4d			ld a, (.dmark)  
4d2a 32 b4 fe			ld (debug_mark),a  
4d2d 3a 3c 4d			ld a, (.dmark+1)  
4d30 32 b5 fe			ld (debug_mark+1),a  
4d33 3a 3d 4d			ld a, (.dmark+2)  
4d36 32 b6 fe			ld (debug_mark+2),a  
4d39 18 03			jr .pastdmark  
4d3b ..			.dmark: db "AP1"  
4d3e f1			.pastdmark: pop af  
4d3f			endm  
# End of macro DMARK
4d3f					CALLMONITOR 
4d3f cd 7e 18			call break_point_state  
4d42				endm  
# End of macro CALLMONITOR
4d42				endif 
4d42					FORTH_DSP_POP 
4d42 cd a1 21			call macro_forth_dsp_pop 
4d45				endm 
# End of macro FORTH_DSP_POP
4d45			 
4d45					FORTH_DSP_VALUEHL 
4d45 cd e9 20			call macro_dsp_valuehl 
4d48				endm 
# End of macro FORTH_DSP_VALUEHL
4d48					;v5 FORTH_DSP_VALUE 
4d48 e5					push hl 	; save ptr to string to save 
4d49			 
4d49				if DEBUG_STORESE 
4d49					DMARK "AP1" 
4d49 f5				push af  
4d4a 3a 5e 4d			ld a, (.dmark)  
4d4d 32 b4 fe			ld (debug_mark),a  
4d50 3a 5f 4d			ld a, (.dmark+1)  
4d53 32 b5 fe			ld (debug_mark+1),a  
4d56 3a 60 4d			ld a, (.dmark+2)  
4d59 32 b6 fe			ld (debug_mark+2),a  
4d5c 18 03			jr .pastdmark  
4d5e ..			.dmark: db "AP1"  
4d61 f1			.pastdmark: pop af  
4d62			endm  
# End of macro DMARK
4d62					CALLMONITOR 
4d62 cd 7e 18			call break_point_state  
4d65				endm  
# End of macro CALLMONITOR
4d65				endif 
4d65					FORTH_DSP_POP 
4d65 cd a1 21			call macro_forth_dsp_pop 
4d68				endm 
# End of macro FORTH_DSP_POP
4d68			 
4d68 d1					pop de 
4d69 e1					pop hl 
4d6a				if DEBUG_STORESE 
4d6a					DMARK "AP2" 
4d6a f5				push af  
4d6b 3a 7f 4d			ld a, (.dmark)  
4d6e 32 b4 fe			ld (debug_mark),a  
4d71 3a 80 4d			ld a, (.dmark+1)  
4d74 32 b5 fe			ld (debug_mark+1),a  
4d77 3a 81 4d			ld a, (.dmark+2)  
4d7a 32 b6 fe			ld (debug_mark+2),a  
4d7d 18 03			jr .pastdmark  
4d7f ..			.dmark: db "AP2"  
4d82 f1			.pastdmark: pop af  
4d83			endm  
# End of macro DMARK
4d83					CALLMONITOR 
4d83 cd 7e 18			call break_point_state  
4d86				endm  
# End of macro CALLMONITOR
4d86				endif 
4d86					;inc de ; skip var type indicator 
4d86			 
4d86					; TODO how to append numerics???? 
4d86			 
4d86 cd c1 0a				call storage_append		 
4d89			 
4d89				       NEXTW 
4d89 c3 60 22			jp macro_next 
4d8c				endm 
# End of macro NEXTW
4d8c			.SDEL: 
4d8c				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4d8c 6a				db WORD_SYS_CORE+86             
4d8d d8 4d			dw .OPEN            
4d8f 05				db 4 + 1 
4d90 .. 00			db "ERA",0              
4d94				endm 
# End of macro CWHEAD
4d94			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4d94					FORTH_DSP_VALUEHL 
4d94 cd e9 20			call macro_dsp_valuehl 
4d97				endm 
# End of macro FORTH_DSP_VALUEHL
4d97			;		push hl 	; save file id 
4d97			 
4d97					if DEBUG_FORTH_WORDS_KEY 
4d97						DMARK "ERA" 
4d97 f5				push af  
4d98 3a ac 4d			ld a, (.dmark)  
4d9b 32 b4 fe			ld (debug_mark),a  
4d9e 3a ad 4d			ld a, (.dmark+1)  
4da1 32 b5 fe			ld (debug_mark+1),a  
4da4 3a ae 4d			ld a, (.dmark+2)  
4da7 32 b6 fe			ld (debug_mark+2),a  
4daa 18 03			jr .pastdmark  
4dac ..			.dmark: db "ERA"  
4daf f1			.pastdmark: pop af  
4db0			endm  
# End of macro DMARK
4db0						CALLMONITOR 
4db0 cd 7e 18			call break_point_state  
4db3				endm  
# End of macro CALLMONITOR
4db3					endif 
4db3				if DEBUG_STORESE 
4db3					DMARK "ER1" 
4db3 f5				push af  
4db4 3a c8 4d			ld a, (.dmark)  
4db7 32 b4 fe			ld (debug_mark),a  
4dba 3a c9 4d			ld a, (.dmark+1)  
4dbd 32 b5 fe			ld (debug_mark+1),a  
4dc0 3a ca 4d			ld a, (.dmark+2)  
4dc3 32 b6 fe			ld (debug_mark+2),a  
4dc6 18 03			jr .pastdmark  
4dc8 ..			.dmark: db "ER1"  
4dcb f1			.pastdmark: pop af  
4dcc			endm  
# End of macro DMARK
4dcc					CALLMONITOR 
4dcc cd 7e 18			call break_point_state  
4dcf				endm  
# End of macro CALLMONITOR
4dcf				endif 
4dcf					FORTH_DSP_POP 
4dcf cd a1 21			call macro_forth_dsp_pop 
4dd2				endm 
# End of macro FORTH_DSP_POP
4dd2			 
4dd2			;		pop hl 
4dd2			 
4dd2 cd 13 06				call storage_erase 
4dd5				       NEXTW 
4dd5 c3 60 22			jp macro_next 
4dd8				endm 
# End of macro NEXTW
4dd8			 
4dd8			.OPEN: 
4dd8				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4dd8 6b				db WORD_SYS_CORE+87             
4dd9 6c 4e			dw .READ            
4ddb 05				db 4 + 1 
4ddc .. 00			db "OPEN",0              
4de1				endm 
# End of macro CWHEAD
4de1			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4de1			; | | e.g. 
4de1			; | | $01 OPEN $01 DO $01 READ . LOOP 
4de1			; | | 
4de1			; | | Will return with 255 blocks if the file does not exist 
4de1			 
4de1					if DEBUG_FORTH_WORDS_KEY 
4de1						DMARK "OPN" 
4de1 f5				push af  
4de2 3a f6 4d			ld a, (.dmark)  
4de5 32 b4 fe			ld (debug_mark),a  
4de8 3a f7 4d			ld a, (.dmark+1)  
4deb 32 b5 fe			ld (debug_mark+1),a  
4dee 3a f8 4d			ld a, (.dmark+2)  
4df1 32 b6 fe			ld (debug_mark+2),a  
4df4 18 03			jr .pastdmark  
4df6 ..			.dmark: db "OPN"  
4df9 f1			.pastdmark: pop af  
4dfa			endm  
# End of macro DMARK
4dfa						CALLMONITOR 
4dfa cd 7e 18			call break_point_state  
4dfd				endm  
# End of macro CALLMONITOR
4dfd					endif 
4dfd					; TODO handle multiple file opens 
4dfd			 
4dfd 3e 01			       	ld a, 1 
4dff 32 f7 fb				ld (store_openext), a 
4e02			 
4e02					; get max extents for this file 
4e02				 
4e02								 
4e02					FORTH_DSP_VALUEHL 
4e02 cd e9 20			call macro_dsp_valuehl 
4e05				endm 
# End of macro FORTH_DSP_VALUEHL
4e05			 
4e05 65					ld h, l 
4e06 2e 00				ld l, 0 
4e08			 
4e08					; store file id 
4e08			 
4e08 7c					ld a, h 
4e09 32 f4 fb				ld (store_filecache), a 
4e0c			 
4e0c				if DEBUG_STORESE 
4e0c					DMARK "OPN" 
4e0c f5				push af  
4e0d 3a 21 4e			ld a, (.dmark)  
4e10 32 b4 fe			ld (debug_mark),a  
4e13 3a 22 4e			ld a, (.dmark+1)  
4e16 32 b5 fe			ld (debug_mark+1),a  
4e19 3a 23 4e			ld a, (.dmark+2)  
4e1c 32 b6 fe			ld (debug_mark+2),a  
4e1f 18 03			jr .pastdmark  
4e21 ..			.dmark: db "OPN"  
4e24 f1			.pastdmark: pop af  
4e25			endm  
# End of macro DMARK
4e25					CALLMONITOR 
4e25 cd 7e 18			call break_point_state  
4e28				endm  
# End of macro CALLMONITOR
4e28				endif 
4e28			;		push hl 
4e28					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4e28 cd a1 21			call macro_forth_dsp_pop 
4e2b				endm 
# End of macro FORTH_DSP_POP
4e2b			;		pop hl 
4e2b						 
4e2b 11 07 fc				ld de, store_page      ; get block zero of file 
4e2e cd 2a 09				call storage_read 
4e31 cd 2a 0f			call ishlzero 
4e34 20 04			jr nz, .opfound 
4e36			 
4e36				; file does not exist so indicate with 255 extents in use 
4e36			 
4e36 3e ff			ld a, 255 
4e38 18 29			jr .skipopeneof 
4e3a			 
4e3a			 
4e3a			.opfound: 
4e3a			 
4e3a			 
4e3a 3a 09 fc				ld a, (store_page+2)    ; max extents for this file 
4e3d 32 f6 fb				ld  (store_openmaxext), a   ; get our limit and push 
4e40					 
4e40				if DEBUG_STORESE 
4e40					DMARK "OPx" 
4e40 f5				push af  
4e41 3a 55 4e			ld a, (.dmark)  
4e44 32 b4 fe			ld (debug_mark),a  
4e47 3a 56 4e			ld a, (.dmark+1)  
4e4a 32 b5 fe			ld (debug_mark+1),a  
4e4d 3a 57 4e			ld a, (.dmark+2)  
4e50 32 b6 fe			ld (debug_mark+2),a  
4e53 18 03			jr .pastdmark  
4e55 ..			.dmark: db "OPx"  
4e58 f1			.pastdmark: pop af  
4e59			endm  
# End of macro DMARK
4e59					CALLMONITOR 
4e59 cd 7e 18			call break_point_state  
4e5c				endm  
# End of macro CALLMONITOR
4e5c				endif 
4e5c fe 00				cp 0 
4e5e 20 03				jr nz, .skipopeneof 
4e60					; have opened an empty file 
4e60					 
4e60 32 f7 fb				ld (store_openext), a 
4e63			 
4e63			.skipopeneof: 
4e63			 
4e63 6f					ld l, a 
4e64 26 00				ld h, 0 
4e66 cd f2 1e				call forth_push_numhl 
4e69			 
4e69			 
4e69				       NEXTW 
4e69 c3 60 22			jp macro_next 
4e6c				endm 
# End of macro NEXTW
4e6c			.READ: 
4e6c				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4e6c 6c				db WORD_SYS_CORE+88             
4e6d 96 4f			dw .EOF            
4e6f 05				db 4 + 1 
4e70 .. 00			db "READ",0              
4e75				endm 
# End of macro CWHEAD
4e75			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
4e75			; | | e.g. 
4e75			; | | $01 OPEN $01 DO READ . LOOP 
4e75			; | | 
4e75			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
4e75			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
4e75			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
4e75			; | | two bytes contain the file id and extent. 
4e75			; | |  
4e75			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
4e75			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
4e75			 
4e75					if DEBUG_FORTH_WORDS_KEY 
4e75						DMARK "REA" 
4e75 f5				push af  
4e76 3a 8a 4e			ld a, (.dmark)  
4e79 32 b4 fe			ld (debug_mark),a  
4e7c 3a 8b 4e			ld a, (.dmark+1)  
4e7f 32 b5 fe			ld (debug_mark+1),a  
4e82 3a 8c 4e			ld a, (.dmark+2)  
4e85 32 b6 fe			ld (debug_mark+2),a  
4e88 18 03			jr .pastdmark  
4e8a ..			.dmark: db "REA"  
4e8d f1			.pastdmark: pop af  
4e8e			endm  
# End of macro DMARK
4e8e						CALLMONITOR 
4e8e cd 7e 18			call break_point_state  
4e91				endm  
# End of macro CALLMONITOR
4e91					endif 
4e91					; store_openext use it. If zero it is EOF 
4e91			 
4e91					; read block from current stream id 
4e91					; if the block does not contain zero term keep reading blocks until zero found 
4e91					; push the block to stack 
4e91					; save the block id to stream 
4e91			 
4e91			 
4e91 cd c3 4f				call .testeof 
4e94 3e 01				ld a, 1 
4e96 bd					cp l 
4e97 ca 72 4f				jp z, .ateof 
4e9a			 
4e9a			 
4e9a			;		FORTH_DSP_VALUEHL 
4e9a			 
4e9a			;		push hl 
4e9a			 
4e9a			;	if DEBUG_STORESE 
4e9a			;		DMARK "REA" 
4e9a			;		CALLMONITOR 
4e9a			;	endif 
4e9a			;		FORTH_DSP_POP 
4e9a			 
4e9a			;		pop hl 
4e9a				 
4e9a 3a f4 fb				ld a, (store_filecache) 
4e9d 67					ld h,a 
4e9e			 
4e9e 3a f7 fb				ld a, (store_openext) 
4ea1 6f					ld l, a 
4ea2					 
4ea2 fe 00				cp 0 
4ea4 ca 72 4f				jp z, .ateof     ; dont read past eof 
4ea7			 
4ea7 cd 0d 0c				call storage_clear_page 
4eaa			 
4eaa 11 07 fc				ld de, store_page 
4ead				if DEBUG_STORESE 
4ead					DMARK "RE1" 
4ead f5				push af  
4eae 3a c2 4e			ld a, (.dmark)  
4eb1 32 b4 fe			ld (debug_mark),a  
4eb4 3a c3 4e			ld a, (.dmark+1)  
4eb7 32 b5 fe			ld (debug_mark+1),a  
4eba 3a c4 4e			ld a, (.dmark+2)  
4ebd 32 b6 fe			ld (debug_mark+2),a  
4ec0 18 03			jr .pastdmark  
4ec2 ..			.dmark: db "RE1"  
4ec5 f1			.pastdmark: pop af  
4ec6			endm  
# End of macro DMARK
4ec6					CALLMONITOR 
4ec6 cd 7e 18			call break_point_state  
4ec9				endm  
# End of macro CALLMONITOR
4ec9				endif 
4ec9 cd 2a 09				call storage_read 
4ecc			 
4ecc				if DEBUG_STORESE 
4ecc					DMARK "RE2" 
4ecc f5				push af  
4ecd 3a e1 4e			ld a, (.dmark)  
4ed0 32 b4 fe			ld (debug_mark),a  
4ed3 3a e2 4e			ld a, (.dmark+1)  
4ed6 32 b5 fe			ld (debug_mark+1),a  
4ed9 3a e3 4e			ld a, (.dmark+2)  
4edc 32 b6 fe			ld (debug_mark+2),a  
4edf 18 03			jr .pastdmark  
4ee1 ..			.dmark: db "RE2"  
4ee4 f1			.pastdmark: pop af  
4ee5			endm  
# End of macro DMARK
4ee5					CALLMONITOR 
4ee5 cd 7e 18			call break_point_state  
4ee8				endm  
# End of macro CALLMONITOR
4ee8				endif 
4ee8 cd 2a 0f			call ishlzero 
4eeb			;	ld a, l 
4eeb			;	add h 
4eeb			;	cp 0 
4eeb ca 72 4f			jp z, .readeof 
4eee			 
4eee				; not eof so hl should point to data to push to stack 
4eee			 
4eee				if DEBUG_STORESE 
4eee					DMARK "RE3" 
4eee f5				push af  
4eef 3a 03 4f			ld a, (.dmark)  
4ef2 32 b4 fe			ld (debug_mark),a  
4ef5 3a 04 4f			ld a, (.dmark+1)  
4ef8 32 b5 fe			ld (debug_mark+1),a  
4efb 3a 05 4f			ld a, (.dmark+2)  
4efe 32 b6 fe			ld (debug_mark+2),a  
4f01 18 03			jr .pastdmark  
4f03 ..			.dmark: db "RE3"  
4f06 f1			.pastdmark: pop af  
4f07			endm  
# End of macro DMARK
4f07					CALLMONITOR 
4f07 cd 7e 18			call break_point_state  
4f0a				endm  
# End of macro CALLMONITOR
4f0a				endif 
4f0a cd 60 1f			call forth_push_str 
4f0d			 
4f0d				if DEBUG_STORESE 
4f0d					DMARK "RE4" 
4f0d f5				push af  
4f0e 3a 22 4f			ld a, (.dmark)  
4f11 32 b4 fe			ld (debug_mark),a  
4f14 3a 23 4f			ld a, (.dmark+1)  
4f17 32 b5 fe			ld (debug_mark+1),a  
4f1a 3a 24 4f			ld a, (.dmark+2)  
4f1d 32 b6 fe			ld (debug_mark+2),a  
4f20 18 03			jr .pastdmark  
4f22 ..			.dmark: db "RE4"  
4f25 f1			.pastdmark: pop af  
4f26			endm  
# End of macro DMARK
4f26					CALLMONITOR 
4f26 cd 7e 18			call break_point_state  
4f29				endm  
# End of macro CALLMONITOR
4f29				endif 
4f29				; get next block  or mark as eof 
4f29			 
4f29 3a f6 fb			ld a, (store_openmaxext)   ; get our limit 
4f2c 4f				ld c, a	 
4f2d 3a f7 fb			ld a, (store_openext) 
4f30			 
4f30				if DEBUG_STORESE 
4f30					DMARK "RE5" 
4f30 f5				push af  
4f31 3a 45 4f			ld a, (.dmark)  
4f34 32 b4 fe			ld (debug_mark),a  
4f37 3a 46 4f			ld a, (.dmark+1)  
4f3a 32 b5 fe			ld (debug_mark+1),a  
4f3d 3a 47 4f			ld a, (.dmark+2)  
4f40 32 b6 fe			ld (debug_mark+2),a  
4f43 18 03			jr .pastdmark  
4f45 ..			.dmark: db "RE5"  
4f48 f1			.pastdmark: pop af  
4f49			endm  
# End of macro DMARK
4f49					CALLMONITOR 
4f49 cd 7e 18			call break_point_state  
4f4c				endm  
# End of macro CALLMONITOR
4f4c				endif 
4f4c b9				cp c 
4f4d 28 23			jr z, .readeof     ; at last extent 
4f4f			 
4f4f 3c					inc a 
4f50 32 f7 fb				ld (store_openext), a 
4f53			 
4f53				if DEBUG_STORESE 
4f53					DMARK "RE6" 
4f53 f5				push af  
4f54 3a 68 4f			ld a, (.dmark)  
4f57 32 b4 fe			ld (debug_mark),a  
4f5a 3a 69 4f			ld a, (.dmark+1)  
4f5d 32 b5 fe			ld (debug_mark+1),a  
4f60 3a 6a 4f			ld a, (.dmark+2)  
4f63 32 b6 fe			ld (debug_mark+2),a  
4f66 18 03			jr .pastdmark  
4f68 ..			.dmark: db "RE6"  
4f6b f1			.pastdmark: pop af  
4f6c			endm  
# End of macro DMARK
4f6c					CALLMONITOR 
4f6c cd 7e 18			call break_point_state  
4f6f				endm  
# End of macro CALLMONITOR
4f6f				endif 
4f6f			 
4f6f			 
4f6f				       NEXTW 
4f6f c3 60 22			jp macro_next 
4f72				endm 
# End of macro NEXTW
4f72			.ateof: 
4f72				;	ld hl, .showeof 
4f72				;	call forth_push_str 
4f72 3e 00		.readeof:	ld a, 0 
4f74 32 f7 fb				ld (store_openext), a 
4f77			 
4f77					 
4f77				if DEBUG_STORESE 
4f77					DMARK "REF" 
4f77 f5				push af  
4f78 3a 8c 4f			ld a, (.dmark)  
4f7b 32 b4 fe			ld (debug_mark),a  
4f7e 3a 8d 4f			ld a, (.dmark+1)  
4f81 32 b5 fe			ld (debug_mark+1),a  
4f84 3a 8e 4f			ld a, (.dmark+2)  
4f87 32 b6 fe			ld (debug_mark+2),a  
4f8a 18 03			jr .pastdmark  
4f8c ..			.dmark: db "REF"  
4f8f f1			.pastdmark: pop af  
4f90			endm  
# End of macro DMARK
4f90					CALLMONITOR 
4f90 cd 7e 18			call break_point_state  
4f93				endm  
# End of macro CALLMONITOR
4f93				endif 
4f93				       NEXTW 
4f93 c3 60 22			jp macro_next 
4f96				endm 
# End of macro NEXTW
4f96			 
4f96			;.showeof:   db "eof", 0 
4f96			 
4f96			 
4f96			.EOF: 
4f96				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4f96 6d				db WORD_SYS_CORE+89             
4f97 d8 4f			dw .FORMAT            
4f99 04				db 3 + 1 
4f9a .. 00			db "EOF",0              
4f9e				endm 
# End of macro CWHEAD
4f9e			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
4f9e			; | | e.g. 
4f9e			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
4f9e					; TODO if current block id for stream is zero then push true else false 
4f9e			 
4f9e					if DEBUG_FORTH_WORDS_KEY 
4f9e						DMARK "EOF" 
4f9e f5				push af  
4f9f 3a b3 4f			ld a, (.dmark)  
4fa2 32 b4 fe			ld (debug_mark),a  
4fa5 3a b4 4f			ld a, (.dmark+1)  
4fa8 32 b5 fe			ld (debug_mark+1),a  
4fab 3a b5 4f			ld a, (.dmark+2)  
4fae 32 b6 fe			ld (debug_mark+2),a  
4fb1 18 03			jr .pastdmark  
4fb3 ..			.dmark: db "EOF"  
4fb6 f1			.pastdmark: pop af  
4fb7			endm  
# End of macro DMARK
4fb7						CALLMONITOR 
4fb7 cd 7e 18			call break_point_state  
4fba				endm  
# End of macro CALLMONITOR
4fba					endif 
4fba			 
4fba					; TODO handlue multiple file streams 
4fba			 
4fba			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
4fba cd c3 4f				call .testeof 
4fbd cd f2 1e				call forth_push_numhl 
4fc0			 
4fc0			 
4fc0				       NEXTW 
4fc0 c3 60 22			jp macro_next 
4fc3				endm 
# End of macro NEXTW
4fc3			 
4fc3			.testeof: 
4fc3 2e 01				ld l, 1 
4fc5 3a f6 fb				ld a, (store_openmaxext) 
4fc8 fe 00				cp 0 
4fca 28 09				jr  z, .eofdone   ; empty file 
4fcc 3a f7 fb				ld a, (store_openext) 
4fcf fe 00				cp 0 
4fd1 28 02				jr  z, .eofdone 
4fd3 2e 00				ld l, 0 
4fd5 26 00		.eofdone:	ld h, 0 
4fd7 c9					ret 
4fd8			 
4fd8			 
4fd8			 
4fd8			 
4fd8			.FORMAT: 
4fd8				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4fd8 6d				db WORD_SYS_CORE+89             
4fd9 29 50			dw .LABEL            
4fdb 07				db 6 + 1 
4fdc .. 00			db "FORMAT",0              
4fe3				endm 
# End of macro CWHEAD
4fe3			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4fe3					; TODO if current block id for stream is zero then push true else false 
4fe3				 
4fe3				if DEBUG_STORESE 
4fe3					DMARK "FOR" 
4fe3 f5				push af  
4fe4 3a f8 4f			ld a, (.dmark)  
4fe7 32 b4 fe			ld (debug_mark),a  
4fea 3a f9 4f			ld a, (.dmark+1)  
4fed 32 b5 fe			ld (debug_mark+1),a  
4ff0 3a fa 4f			ld a, (.dmark+2)  
4ff3 32 b6 fe			ld (debug_mark+2),a  
4ff6 18 03			jr .pastdmark  
4ff8 ..			.dmark: db "FOR"  
4ffb f1			.pastdmark: pop af  
4ffc			endm  
# End of macro DMARK
4ffc					CALLMONITOR 
4ffc cd 7e 18			call break_point_state  
4fff				endm  
# End of macro CALLMONITOR
4fff				endif 
4fff					; Wipes the bank check flags to cause a reformat on next block 0 read 
4fff			 
4fff 21 01 00				ld hl, 1 
5002 3e 00				ld a, 0 
5004 cd d6 01				call se_writebyte 
5007			 
5007				if DEBUG_STORESE 
5007					DMARK "FO0" 
5007 f5				push af  
5008 3a 1c 50			ld a, (.dmark)  
500b 32 b4 fe			ld (debug_mark),a  
500e 3a 1d 50			ld a, (.dmark+1)  
5011 32 b5 fe			ld (debug_mark+1),a  
5014 3a 1e 50			ld a, (.dmark+2)  
5017 32 b6 fe			ld (debug_mark+2),a  
501a 18 03			jr .pastdmark  
501c ..			.dmark: db "FO0"  
501f f1			.pastdmark: pop af  
5020			endm  
# End of macro DMARK
5020					CALLMONITOR 
5020 cd 7e 18			call break_point_state  
5023				endm  
# End of macro CALLMONITOR
5023				endif 
5023					; force bank init 
5023			 
5023 cd 82 04				call storage_get_block_0 
5026					 
5026				       NEXTW 
5026 c3 60 22			jp macro_next 
5029				endm 
# End of macro NEXTW
5029			.LABEL: 
5029				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5029 6d				db WORD_SYS_CORE+89             
502a 77 50			dw .STOREPAGE            
502c 06				db 5 + 1 
502d .. 00			db "LABEL",0              
5033				endm 
# End of macro CWHEAD
5033			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5033					; TODO test to see if bank is selected 
5033				 
5033					if DEBUG_FORTH_WORDS_KEY 
5033						DMARK "LBL" 
5033 f5				push af  
5034 3a 48 50			ld a, (.dmark)  
5037 32 b4 fe			ld (debug_mark),a  
503a 3a 49 50			ld a, (.dmark+1)  
503d 32 b5 fe			ld (debug_mark+1),a  
5040 3a 4a 50			ld a, (.dmark+2)  
5043 32 b6 fe			ld (debug_mark+2),a  
5046 18 03			jr .pastdmark  
5048 ..			.dmark: db "LBL"  
504b f1			.pastdmark: pop af  
504c			endm  
# End of macro DMARK
504c						CALLMONITOR 
504c cd 7e 18			call break_point_state  
504f				endm  
# End of macro CALLMONITOR
504f					endif 
504f			;	if DEBUG_STORESE 
504f			;		DMARK "LBL" 
504f			;		CALLMONITOR 
504f			;	endif 
504f					FORTH_DSP_VALUEHL 
504f cd e9 20			call macro_dsp_valuehl 
5052				endm 
# End of macro FORTH_DSP_VALUEHL
5052					;v5FORTH_DSP_VALUE 
5052					 
5052			;		push hl 
5052					FORTH_DSP_POP 
5052 cd a1 21			call macro_forth_dsp_pop 
5055				endm 
# End of macro FORTH_DSP_POP
5055			;		pop hl 
5055			 
5055			;v5		inc hl   ; move past the type marker 
5055			 
5055				if DEBUG_STORESE 
5055					DMARK "LBl" 
5055 f5				push af  
5056 3a 6a 50			ld a, (.dmark)  
5059 32 b4 fe			ld (debug_mark),a  
505c 3a 6b 50			ld a, (.dmark+1)  
505f 32 b5 fe			ld (debug_mark+1),a  
5062 3a 6c 50			ld a, (.dmark+2)  
5065 32 b6 fe			ld (debug_mark+2),a  
5068 18 03			jr .pastdmark  
506a ..			.dmark: db "LBl"  
506d f1			.pastdmark: pop af  
506e			endm  
# End of macro DMARK
506e					CALLMONITOR 
506e cd 7e 18			call break_point_state  
5071				endm  
# End of macro CALLMONITOR
5071				endif 
5071 cd a6 05				call storage_label 
5074			 
5074				       NEXTW 
5074 c3 60 22			jp macro_next 
5077				endm 
# End of macro NEXTW
5077			.STOREPAGE: 
5077				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5077 6d				db WORD_SYS_CORE+89             
5078 aa 50			dw .LABELS            
507a 0a				db 9 + 1 
507b .. 00			db "STOREPAGE",0              
5085				endm 
# End of macro CWHEAD
5085			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5085					; TODO test to see if bank is selected 
5085				 
5085					if DEBUG_FORTH_WORDS_KEY 
5085						DMARK "STP" 
5085 f5				push af  
5086 3a 9a 50			ld a, (.dmark)  
5089 32 b4 fe			ld (debug_mark),a  
508c 3a 9b 50			ld a, (.dmark+1)  
508f 32 b5 fe			ld (debug_mark+1),a  
5092 3a 9c 50			ld a, (.dmark+2)  
5095 32 b6 fe			ld (debug_mark+2),a  
5098 18 03			jr .pastdmark  
509a ..			.dmark: db "STP"  
509d f1			.pastdmark: pop af  
509e			endm  
# End of macro DMARK
509e						CALLMONITOR 
509e cd 7e 18			call break_point_state  
50a1				endm  
# End of macro CALLMONITOR
50a1					endif 
50a1			;	if DEBUG_STORESE 
50a1			;		DMARK "STP" 
50a1			;		CALLMONITOR 
50a1			;	endif 
50a1			 
50a1 21 07 fc			ld hl, store_page 
50a4 cd f2 1e			call forth_push_numhl 
50a7			 
50a7			 
50a7				       NEXTW 
50a7 c3 60 22			jp macro_next 
50aa				endm 
# End of macro NEXTW
50aa			.LABELS: 
50aa				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
50aa 6d				db WORD_SYS_CORE+89             
50ab 34 51			dw .SCONST1            
50ad 07				db 6 + 1 
50ae .. 00			db "LABELS",0              
50b5				endm 
# End of macro CWHEAD
50b5			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
50b5					;  
50b5			 
50b5					; save the current device selected to restore afterwards 
50b5				 
50b5 3a ee fb				ld a, (spi_device) 
50b8 f5					push af 
50b9			 
50b9			 
50b9					; run through each of the banks 
50b9			 
50b9 21 01 00				ld hl, 1 
50bc cd f2 1e				call forth_push_numhl 
50bf 3e ff				ld a, SPI_CE_HIGH 
50c1 cb 87				res SPI_CE0, a 
50c3 32 ee fb				ld (spi_device), a 
50c6 cd 82 04				call storage_get_block_0 
50c9 21 0a fc				ld hl, store_page+3 
50cc cd 60 1f				call forth_push_str 
50cf			 
50cf					 
50cf 21 02 00				ld hl, 2 
50d2 cd f2 1e				call forth_push_numhl 
50d5 3e ff				ld a, SPI_CE_HIGH 
50d7 cb 8f				res SPI_CE1, a 
50d9 32 ee fb				ld (spi_device), a 
50dc cd 82 04				call storage_get_block_0 
50df 21 0a fc				ld hl, store_page+3 
50e2 cd 60 1f				call forth_push_str 
50e5			 
50e5					 
50e5 21 03 00				ld hl, 3 
50e8 cd f2 1e				call forth_push_numhl 
50eb 3e ff				ld a, SPI_CE_HIGH 
50ed cb 97				res SPI_CE2, a 
50ef 32 ee fb				ld (spi_device), a 
50f2 cd 82 04				call storage_get_block_0 
50f5 21 0a fc				ld hl, store_page+3 
50f8 cd 60 1f				call forth_push_str 
50fb			 
50fb			 
50fb 21 04 00				ld hl, 4 
50fe cd f2 1e				call forth_push_numhl 
5101 3e ff				ld a, SPI_CE_HIGH 
5103 cb 9f				res SPI_CE3, a 
5105 32 ee fb				ld (spi_device), a 
5108 cd 82 04				call storage_get_block_0 
510b 21 0a fc				ld hl, store_page+3 
510e cd 60 1f				call forth_push_str 
5111			 
5111					 
5111			 
5111 21 05 00				ld hl, 5 
5114 cd f2 1e				call forth_push_numhl 
5117 3e ff				ld a, SPI_CE_HIGH 
5119 cb a7				res SPI_CE4, a 
511b 32 ee fb				ld (spi_device), a 
511e cd 82 04				call storage_get_block_0 
5121 21 0a fc				ld hl, store_page+3 
5124 cd 60 1f				call forth_push_str 
5127			 
5127					 
5127					; push fixed count of storage devices (on board) for now 
5127			 
5127 21 05 00				ld hl, 5 
512a cd f2 1e				call forth_push_numhl 
512d			 
512d					; restore selected device  
512d				 
512d f1					pop af 
512e 32 ee fb				ld (spi_device), a 
5131			 
5131				       NEXTW 
5131 c3 60 22			jp macro_next 
5134				endm 
# End of macro NEXTW
5134			 
5134			.SCONST1: 
5134				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5134 6d				db WORD_SYS_CORE+89             
5135 4b 51			dw .SCONST2            
5137 07				db 6 + 1 
5138 .. 00			db "FILEID",0              
513f				endm 
# End of macro CWHEAD
513f			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
513f 3a f4 fb				ld a, (store_filecache) 
5142 26 00				ld h, 0 
5144 6f					ld l, a 
5145 cd f2 1e				call forth_push_numhl 
5148					NEXTW 
5148 c3 60 22			jp macro_next 
514b				endm 
# End of macro NEXTW
514b			.SCONST2: 
514b				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
514b 6d				db WORD_SYS_CORE+89             
514c 63 51			dw .SCONST3            
514e 08				db 7 + 1 
514f .. 00			db "FILEEXT",0              
5157				endm 
# End of macro CWHEAD
5157			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5157 3a f7 fb				ld a, (store_openext) 
515a 26 00				ld h, 0 
515c 6f					ld l, a 
515d cd f2 1e				call forth_push_numhl 
5160					NEXTW 
5160 c3 60 22			jp macro_next 
5163				endm 
# End of macro NEXTW
5163			.SCONST3: 
5163				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5163 6d				db WORD_SYS_CORE+89             
5164 7b 51			dw .SCONST4            
5166 08				db 7 + 1 
5167 .. 00			db "FILEMAX",0              
516f				endm 
# End of macro CWHEAD
516f			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
516f 3a f6 fb				ld a, (store_openmaxext) 
5172 26 00				ld h, 0 
5174 6f					ld l, a 
5175 cd f2 1e				call forth_push_numhl 
5178					NEXTW 
5178 c3 60 22			jp macro_next 
517b				endm 
# End of macro NEXTW
517b			.SCONST4: 
517b				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
517b 6d				db WORD_SYS_CORE+89             
517c 91 51			dw .SCONST5            
517e 09				db 8 + 1 
517f .. 00			db "FILEADDR",0              
5188				endm 
# End of macro CWHEAD
5188			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
5188 2a f8 fb				ld hl, (store_openaddr) 
518b cd f2 1e				call forth_push_numhl 
518e					NEXTW 
518e c3 60 22			jp macro_next 
5191				endm 
# End of macro NEXTW
5191			.SCONST5: 
5191				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5191 6d				db WORD_SYS_CORE+89             
5192 aa 51			dw .ENDSTORAGE            
5194 09				db 8 + 1 
5195 .. 00			db "READCONT",0              
519e				endm 
# End of macro CWHEAD
519e			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
519e			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
519e			; | | a further read should, if applicable, be CONCAT to the previous read. 
519e 3a fa fb				ld a, (store_readcont) 
51a1 26 00				ld h, 0 
51a3 6f					ld l, a 
51a4 cd f2 1e				call forth_push_numhl 
51a7					NEXTW 
51a7 c3 60 22			jp macro_next 
51aa				endm 
# End of macro NEXTW
51aa			.ENDSTORAGE: 
51aa			; eof 
# End of file forth_words_storage.asm
51aa			endif 
51aa				include "forth_words_device.asm" 
51aa			; Device related words 
51aa			 
51aa			; | ## Device Words 
51aa			 
51aa			if SOUND_ENABLE 
51aa			.NOTE: 
51aa				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
51aa			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
51aa					if DEBUG_FORTH_WORDS_KEY 
51aa						DMARK "NTE" 
51aa						CALLMONITOR 
51aa					endif 
51aa			 
51aa				 
51aa			 
51aa					NEXTW 
51aa			.AFTERSOUND: 
51aa			endif 
51aa			 
51aa			 
51aa			USE_GPIO: equ 0 
51aa			 
51aa			if USE_GPIO 
51aa			.GP1: 
51aa				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
51aa			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
51aa					NEXTW 
51aa			.GP2: 
51aa				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
51aa			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
51aa			 
51aa					NEXTW 
51aa			 
51aa			.GP3: 
51aa				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
51aa			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
51aa			 
51aa					NEXTW 
51aa			 
51aa			.GP4: 
51aa				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
51aa			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
51aa			 
51aa					NEXTW 
51aa			.SIN: 
51aa			 
51aa			 
51aa			endif 
51aa			 
51aa			 
51aa				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
51aa 33				db WORD_SYS_CORE+31             
51ab df 51			dw .SOUT            
51ad 03				db 2 + 1 
51ae .. 00			db "IN",0              
51b1				endm 
# End of macro CWHEAD
51b1			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
51b1					if DEBUG_FORTH_WORDS_KEY 
51b1						DMARK "IN." 
51b1 f5				push af  
51b2 3a c6 51			ld a, (.dmark)  
51b5 32 b4 fe			ld (debug_mark),a  
51b8 3a c7 51			ld a, (.dmark+1)  
51bb 32 b5 fe			ld (debug_mark+1),a  
51be 3a c8 51			ld a, (.dmark+2)  
51c1 32 b6 fe			ld (debug_mark+2),a  
51c4 18 03			jr .pastdmark  
51c6 ..			.dmark: db "IN."  
51c9 f1			.pastdmark: pop af  
51ca			endm  
# End of macro DMARK
51ca						CALLMONITOR 
51ca cd 7e 18			call break_point_state  
51cd				endm  
# End of macro CALLMONITOR
51cd					endif 
51cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51cd cd e9 20			call macro_dsp_valuehl 
51d0				endm 
# End of macro FORTH_DSP_VALUEHL
51d0			 
51d0 e5					push hl 
51d1			 
51d1					; destroy value TOS 
51d1			 
51d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51d1 cd a1 21			call macro_forth_dsp_pop 
51d4				endm 
# End of macro FORTH_DSP_POP
51d4			 
51d4					; one value on hl get other one back 
51d4			 
51d4 c1					pop bc 
51d5			 
51d5					; do the sub 
51d5			;		ex de, hl 
51d5			 
51d5 ed 68				in l,(c) 
51d7			 
51d7					; save it 
51d7			 
51d7 26 00				ld h,0 
51d9			 
51d9					; TODO push value back onto stack for another op etc 
51d9			 
51d9 cd f2 1e				call forth_push_numhl 
51dc					NEXTW 
51dc c3 60 22			jp macro_next 
51df				endm 
# End of macro NEXTW
51df			.SOUT: 
51df				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
51df 34				db WORD_SYS_CORE+32             
51e0 32 52			dw .SPIO            
51e2 04				db 3 + 1 
51e3 .. 00			db "OUT",0              
51e7				endm 
# End of macro CWHEAD
51e7			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
51e7					if DEBUG_FORTH_WORDS_KEY 
51e7						DMARK "OUT" 
51e7 f5				push af  
51e8 3a fc 51			ld a, (.dmark)  
51eb 32 b4 fe			ld (debug_mark),a  
51ee 3a fd 51			ld a, (.dmark+1)  
51f1 32 b5 fe			ld (debug_mark+1),a  
51f4 3a fe 51			ld a, (.dmark+2)  
51f7 32 b6 fe			ld (debug_mark+2),a  
51fa 18 03			jr .pastdmark  
51fc ..			.dmark: db "OUT"  
51ff f1			.pastdmark: pop af  
5200			endm  
# End of macro DMARK
5200						CALLMONITOR 
5200 cd 7e 18			call break_point_state  
5203				endm  
# End of macro CALLMONITOR
5203					endif 
5203			 
5203					; get port 
5203			 
5203					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5203 cd e9 20			call macro_dsp_valuehl 
5206				endm 
# End of macro FORTH_DSP_VALUEHL
5206			 
5206 e5					push hl 
5207			 
5207					; destroy value TOS 
5207			 
5207					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5207 cd a1 21			call macro_forth_dsp_pop 
520a				endm 
# End of macro FORTH_DSP_POP
520a			 
520a					; get byte to send 
520a			 
520a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
520a cd e9 20			call macro_dsp_valuehl 
520d				endm 
# End of macro FORTH_DSP_VALUEHL
520d			 
520d			;		push hl 
520d			 
520d					; destroy value TOS 
520d			 
520d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
520d cd a1 21			call macro_forth_dsp_pop 
5210				endm 
# End of macro FORTH_DSP_POP
5210			 
5210					; one value on hl get other one back 
5210			 
5210			;		pop hl 
5210			 
5210 c1					pop bc 
5211			 
5211					if DEBUG_FORTH_WORDS 
5211						DMARK "OUT" 
5211 f5				push af  
5212 3a 26 52			ld a, (.dmark)  
5215 32 b4 fe			ld (debug_mark),a  
5218 3a 27 52			ld a, (.dmark+1)  
521b 32 b5 fe			ld (debug_mark+1),a  
521e 3a 28 52			ld a, (.dmark+2)  
5221 32 b6 fe			ld (debug_mark+2),a  
5224 18 03			jr .pastdmark  
5226 ..			.dmark: db "OUT"  
5229 f1			.pastdmark: pop af  
522a			endm  
# End of macro DMARK
522a						CALLMONITOR 
522a cd 7e 18			call break_point_state  
522d				endm  
# End of macro CALLMONITOR
522d					endif 
522d			 
522d ed 69				out (c), l 
522f			 
522f					NEXTW 
522f c3 60 22			jp macro_next 
5232				endm 
# End of macro NEXTW
5232			 
5232			 
5232			.SPIO: 
5232			 
5232			if STORAGE_SE 
5232				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5232 51				db WORD_SYS_CORE+61             
5233 43 52			dw .SPICEH            
5235 07				db 6 + 1 
5236 .. 00			db "SPICEL",0              
523d				endm 
# End of macro CWHEAD
523d			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
523d			 
523d cd 84 01				call spi_ce_low 
5240			    NEXTW 
5240 c3 60 22			jp macro_next 
5243				endm 
# End of macro NEXTW
5243			 
5243			.SPICEH: 
5243				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5243 51				db WORD_SYS_CORE+61             
5244 54 52			dw .SPIOb            
5246 07				db 6 + 1 
5247 .. 00			db "SPICEH",0              
524e				endm 
# End of macro CWHEAD
524e			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
524e			 
524e cd 73 01				call spi_ce_high 
5251			    NEXTW 
5251 c3 60 22			jp macro_next 
5254				endm 
# End of macro NEXTW
5254			 
5254			 
5254			.SPIOb: 
5254			 
5254				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5254 51				db WORD_SYS_CORE+61             
5255 72 52			dw .SPII            
5257 05				db 4 + 1 
5258 .. 00			db "SPIO",0              
525d				endm 
# End of macro CWHEAD
525d			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
525d			 
525d					; get port 
525d			 
525d			 
525d					; get byte to send 
525d			 
525d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
525d cd e9 20			call macro_dsp_valuehl 
5260				endm 
# End of macro FORTH_DSP_VALUEHL
5260			 
5260			;		push hl    ; u1  
5260			 
5260					; destroy value TOS 
5260			 
5260					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5260 cd a1 21			call macro_forth_dsp_pop 
5263				endm 
# End of macro FORTH_DSP_POP
5263			 
5263					; one value on hl get other one back 
5263			 
5263			;		pop hl   ; u2 - addr 
5263			 
5263					; TODO Send SPI byte 
5263			 
5263 e5					push hl 
5264 cd 84 01				call spi_ce_low 
5267 e1					pop hl 
5268 7d					ld a, l 
5269 cd a8 00				call spi_send_byte 
526c cd 73 01				call spi_ce_high 
526f			 
526f					NEXTW 
526f c3 60 22			jp macro_next 
5272				endm 
# End of macro NEXTW
5272			 
5272			.SPII: 
5272				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5272 52				db WORD_SYS_CORE+62             
5273 87 52			dw .SESEL            
5275 06				db 5 + 1 
5276 .. 00			db "SPII",0              
527b				endm 
# End of macro CWHEAD
527b			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
527b			 
527b					; TODO Get SPI byte 
527b			 
527b cd c9 00				call spi_read_byte 
527e			 
527e 26 00				ld h, 0 
5280 6f					ld l, a 
5281 cd f2 1e				call forth_push_numhl 
5284			 
5284					NEXTW 
5284 c3 60 22			jp macro_next 
5287				endm 
# End of macro NEXTW
5287			 
5287			 
5287			 
5287			.SESEL: 
5287				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5287 66				db WORD_SYS_CORE+82             
5288 2b 53			dw .CARTDEV            
528a 05				db 4 + 1 
528b .. 00			db "BANK",0              
5290				endm 
# End of macro CWHEAD
5290			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5290					if DEBUG_FORTH_WORDS_KEY 
5290						DMARK "BNK" 
5290 f5				push af  
5291 3a a5 52			ld a, (.dmark)  
5294 32 b4 fe			ld (debug_mark),a  
5297 3a a6 52			ld a, (.dmark+1)  
529a 32 b5 fe			ld (debug_mark+1),a  
529d 3a a7 52			ld a, (.dmark+2)  
52a0 32 b6 fe			ld (debug_mark+2),a  
52a3 18 03			jr .pastdmark  
52a5 ..			.dmark: db "BNK"  
52a8 f1			.pastdmark: pop af  
52a9			endm  
# End of macro DMARK
52a9						CALLMONITOR 
52a9 cd 7e 18			call break_point_state  
52ac				endm  
# End of macro CALLMONITOR
52ac					endif 
52ac			 
52ac 3e ff				ld a, 255 
52ae 32 f1 fb				ld (spi_cartdev), a 
52b1			 
52b1					; get bank 
52b1			 
52b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52b1 cd e9 20			call macro_dsp_valuehl 
52b4				endm 
# End of macro FORTH_DSP_VALUEHL
52b4			 
52b4			;		push hl 
52b4			 
52b4					; destroy value TOS 
52b4			 
52b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52b4 cd a1 21			call macro_forth_dsp_pop 
52b7				endm 
# End of macro FORTH_DSP_POP
52b7			 
52b7					; one value on hl get other one back 
52b7			 
52b7			;		pop hl 
52b7			 
52b7			 
52b7 0e ff				ld c, SPI_CE_HIGH 
52b9 06 30				ld b, '0'    ; human readable bank number 
52bb			 
52bb 7d					ld a, l 
52bc			 
52bc					if DEBUG_FORTH_WORDS 
52bc						DMARK "BNK" 
52bc f5				push af  
52bd 3a d1 52			ld a, (.dmark)  
52c0 32 b4 fe			ld (debug_mark),a  
52c3 3a d2 52			ld a, (.dmark+1)  
52c6 32 b5 fe			ld (debug_mark+1),a  
52c9 3a d3 52			ld a, (.dmark+2)  
52cc 32 b6 fe			ld (debug_mark+2),a  
52cf 18 03			jr .pastdmark  
52d1 ..			.dmark: db "BNK"  
52d4 f1			.pastdmark: pop af  
52d5			endm  
# End of macro DMARK
52d5						CALLMONITOR 
52d5 cd 7e 18			call break_point_state  
52d8				endm  
# End of macro CALLMONITOR
52d8					endif 
52d8			 
52d8					; active low 
52d8			 
52d8 fe 00				cp 0 
52da 28 28				jr z, .bset 
52dc fe 01				cp 1 
52de 20 04				jr nz, .b2 
52e0 cb 81				res 0, c 
52e2 06 31				ld b, '1'    ; human readable bank number 
52e4 fe 02		.b2:		cp 2 
52e6 20 04				jr nz, .b3 
52e8 cb 89				res 1, c 
52ea 06 32				ld b, '2'    ; human readable bank number 
52ec fe 03		.b3:		cp 3 
52ee 20 04				jr nz, .b4 
52f0 cb 91				res 2, c 
52f2 06 33				ld b, '3'    ; human readable bank number 
52f4 fe 04		.b4:		cp 4 
52f6 20 04				jr nz, .b5 
52f8 cb 99				res 3, c 
52fa 06 34				ld b, '4'    ; human readable bank number 
52fc fe 05		.b5:		cp 5 
52fe 20 04				jr nz, .bset 
5300 cb a1				res 4, c 
5302 06 35				ld b, '5'    ; human readable bank number 
5304			 
5304			.bset: 
5304 79					ld a, c 
5305 32 ee fb				ld (spi_device),a 
5308 78					ld a, b 
5309 32 ed fb				ld (spi_device_id),a 
530c					if DEBUG_FORTH_WORDS 
530c						DMARK "BN2" 
530c f5				push af  
530d 3a 21 53			ld a, (.dmark)  
5310 32 b4 fe			ld (debug_mark),a  
5313 3a 22 53			ld a, (.dmark+1)  
5316 32 b5 fe			ld (debug_mark+1),a  
5319 3a 23 53			ld a, (.dmark+2)  
531c 32 b6 fe			ld (debug_mark+2),a  
531f 18 03			jr .pastdmark  
5321 ..			.dmark: db "BN2"  
5324 f1			.pastdmark: pop af  
5325			endm  
# End of macro DMARK
5325						CALLMONITOR 
5325 cd 7e 18			call break_point_state  
5328				endm  
# End of macro CALLMONITOR
5328					endif 
5328			 
5328					NEXTW 
5328 c3 60 22			jp macro_next 
532b				endm 
# End of macro NEXTW
532b			 
532b			.CARTDEV: 
532b				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
532b 66				db WORD_SYS_CORE+82             
532c d4 53			dw .ENDDEVICE            
532e 08				db 7 + 1 
532f .. 00			db "CARTDEV",0              
5337				endm 
# End of macro CWHEAD
5337			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5337					if DEBUG_FORTH_WORDS_KEY 
5337						DMARK "CDV" 
5337 f5				push af  
5338 3a 4c 53			ld a, (.dmark)  
533b 32 b4 fe			ld (debug_mark),a  
533e 3a 4d 53			ld a, (.dmark+1)  
5341 32 b5 fe			ld (debug_mark+1),a  
5344 3a 4e 53			ld a, (.dmark+2)  
5347 32 b6 fe			ld (debug_mark+2),a  
534a 18 03			jr .pastdmark  
534c ..			.dmark: db "CDV"  
534f f1			.pastdmark: pop af  
5350			endm  
# End of macro DMARK
5350						CALLMONITOR 
5350 cd 7e 18			call break_point_state  
5353				endm  
# End of macro CALLMONITOR
5353					endif 
5353			 
5353					; disable se storage bank selection 
5353			 
5353 3e ff				ld a, SPI_CE_HIGH		; ce high 
5355 32 ee fb				ld (spi_device), a 
5358			 
5358					; get bank 
5358			 
5358					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5358 cd e9 20			call macro_dsp_valuehl 
535b				endm 
# End of macro FORTH_DSP_VALUEHL
535b			 
535b			;		push hl 
535b			 
535b					; destroy value TOS 
535b			 
535b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
535b cd a1 21			call macro_forth_dsp_pop 
535e				endm 
# End of macro FORTH_DSP_POP
535e			 
535e					; one value on hl get other one back 
535e			 
535e			;		pop hl 
535e			 
535e					; active low 
535e			 
535e 0e ff				ld c, 255 
5360			 
5360 7d					ld a, l 
5361					if DEBUG_FORTH_WORDS 
5361						DMARK "CDV" 
5361 f5				push af  
5362 3a 76 53			ld a, (.dmark)  
5365 32 b4 fe			ld (debug_mark),a  
5368 3a 77 53			ld a, (.dmark+1)  
536b 32 b5 fe			ld (debug_mark+1),a  
536e 3a 78 53			ld a, (.dmark+2)  
5371 32 b6 fe			ld (debug_mark+2),a  
5374 18 03			jr .pastdmark  
5376 ..			.dmark: db "CDV"  
5379 f1			.pastdmark: pop af  
537a			endm  
# End of macro DMARK
537a						CALLMONITOR 
537a cd 7e 18			call break_point_state  
537d				endm  
# End of macro CALLMONITOR
537d					endif 
537d fe 00				cp 0 
537f 28 30				jr z, .cset 
5381 fe 01				cp 1 
5383 20 02				jr nz, .c2 
5385 cb 81				res 0, c 
5387 fe 02		.c2:		cp 2 
5389 20 02				jr nz, .c3 
538b cb 89				res 1, c 
538d fe 03		.c3:		cp 3 
538f 20 02				jr nz, .c4 
5391 cb 91				res 2, c 
5393 fe 04		.c4:		cp 4 
5395 20 02				jr nz, .c5 
5397 cb 99				res 3, c 
5399 fe 05		.c5:		cp 5 
539b 20 02				jr nz, .c6 
539d cb a1				res 4, c 
539f fe 06		.c6:		cp 6 
53a1 20 02				jr nz, .c7 
53a3 cb a9				res 5, c 
53a5 fe 07		.c7:		cp 7 
53a7 20 02				jr nz, .c8 
53a9 cb b1				res 6, c 
53ab fe 08		.c8:		cp 8 
53ad 20 02				jr nz, .cset 
53af cb b9				res 7, c 
53b1 79			.cset:		ld a, c 
53b2 32 f1 fb				ld (spi_cartdev),a 
53b5			 
53b5					if DEBUG_FORTH_WORDS 
53b5						DMARK "CD2" 
53b5 f5				push af  
53b6 3a ca 53			ld a, (.dmark)  
53b9 32 b4 fe			ld (debug_mark),a  
53bc 3a cb 53			ld a, (.dmark+1)  
53bf 32 b5 fe			ld (debug_mark+1),a  
53c2 3a cc 53			ld a, (.dmark+2)  
53c5 32 b6 fe			ld (debug_mark+2),a  
53c8 18 03			jr .pastdmark  
53ca ..			.dmark: db "CD2"  
53cd f1			.pastdmark: pop af  
53ce			endm  
# End of macro DMARK
53ce						CALLMONITOR 
53ce cd 7e 18			call break_point_state  
53d1				endm  
# End of macro CALLMONITOR
53d1					endif 
53d1					NEXTW 
53d1 c3 60 22			jp macro_next 
53d4				endm 
# End of macro NEXTW
53d4			endif 
53d4			 
53d4			.ENDDEVICE: 
53d4			; eof 
53d4			 
# End of file forth_words_device.asm
53d4			 
53d4			; var handler 
53d4			 
53d4			 
53d4			.VARS: 
53d4				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
53d4 78				db WORD_SYS_CORE+100             
53d5 ec 53			dw .V0Q            
53d7 04				db 3 + 1 
53d8 .. 00			db "V0!",0              
53dc				endm 
# End of macro CWHEAD
53dc			;| V0! ( u1 -- )  Store value to v0  | DONE 
53dc			 
53dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53dc cd e9 20			call macro_dsp_valuehl 
53df				endm 
# End of macro FORTH_DSP_VALUEHL
53df			 
53df 11 b6 fb				ld de, cli_var_array 
53e2			 
53e2 eb					ex de, hl 
53e3 73					ld (hl), e 
53e4 23					inc hl 
53e5 72					ld (hl), d 
53e6			 
53e6					; destroy value TOS 
53e6			 
53e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53e6 cd a1 21			call macro_forth_dsp_pop 
53e9				endm 
# End of macro FORTH_DSP_POP
53e9			 
53e9				       NEXTW 
53e9 c3 60 22			jp macro_next 
53ec				endm 
# End of macro NEXTW
53ec			.V0Q: 
53ec				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
53ec 79				db WORD_SYS_CORE+101             
53ed fd 53			dw .V1S            
53ef 04				db 3 + 1 
53f0 .. 00			db "V0@",0              
53f4				endm 
# End of macro CWHEAD
53f4			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
53f4 2a b6 fb				ld hl, (cli_var_array) 
53f7 cd f2 1e				call forth_push_numhl 
53fa			 
53fa				       NEXTW 
53fa c3 60 22			jp macro_next 
53fd				endm 
# End of macro NEXTW
53fd			.V1S: 
53fd				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
53fd 7a				db WORD_SYS_CORE+102             
53fe 15 54			dw .V1Q            
5400 04				db 3 + 1 
5401 .. 00			db "V1!",0              
5405				endm 
# End of macro CWHEAD
5405			;| V1! ( u1 -- )  Store value to v1 | DONE 
5405					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5405 cd e9 20			call macro_dsp_valuehl 
5408				endm 
# End of macro FORTH_DSP_VALUEHL
5408			 
5408 11 b8 fb				ld de, cli_var_array+2 
540b				 
540b eb					ex de, hl 
540c 73					ld (hl), e 
540d 23					inc hl 
540e 72					ld (hl), d 
540f			 
540f					; destroy value TOS 
540f			 
540f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
540f cd a1 21			call macro_forth_dsp_pop 
5412				endm 
# End of macro FORTH_DSP_POP
5412				       NEXTW 
5412 c3 60 22			jp macro_next 
5415				endm 
# End of macro NEXTW
5415			.V1Q: 
5415				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5415 7b				db WORD_SYS_CORE+103             
5416 26 54			dw .V2S            
5418 04				db 3 + 1 
5419 .. 00			db "V1@",0              
541d				endm 
# End of macro CWHEAD
541d			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
541d 2a b8 fb				ld hl, (cli_var_array+2) 
5420 cd f2 1e				call forth_push_numhl 
5423				       NEXTW 
5423 c3 60 22			jp macro_next 
5426				endm 
# End of macro NEXTW
5426			.V2S: 
5426				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5426 7c				db WORD_SYS_CORE+104             
5427 3e 54			dw .V2Q            
5429 04				db 3 + 1 
542a .. 00			db "V2!",0              
542e				endm 
# End of macro CWHEAD
542e			;| V2! ( u1 -- )  Store value to v2 | DONE 
542e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
542e cd e9 20			call macro_dsp_valuehl 
5431				endm 
# End of macro FORTH_DSP_VALUEHL
5431			 
5431 11 ba fb				ld de, cli_var_array+4 
5434				 
5434 eb					ex de, hl 
5435 73					ld (hl), e 
5436 23					inc hl 
5437 72					ld (hl), d 
5438			 
5438					; destroy value TOS 
5438			 
5438					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5438 cd a1 21			call macro_forth_dsp_pop 
543b				endm 
# End of macro FORTH_DSP_POP
543b				       NEXTW 
543b c3 60 22			jp macro_next 
543e				endm 
# End of macro NEXTW
543e			.V2Q: 
543e				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
543e 7d				db WORD_SYS_CORE+105             
543f 4f 54			dw .V3S            
5441 04				db 3 + 1 
5442 .. 00			db "V2@",0              
5446				endm 
# End of macro CWHEAD
5446			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5446 2a ba fb				ld hl, (cli_var_array+4) 
5449 cd f2 1e				call forth_push_numhl 
544c				       NEXTW 
544c c3 60 22			jp macro_next 
544f				endm 
# End of macro NEXTW
544f			.V3S: 
544f				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
544f 7c				db WORD_SYS_CORE+104             
5450 67 54			dw .V3Q            
5452 04				db 3 + 1 
5453 .. 00			db "V3!",0              
5457				endm 
# End of macro CWHEAD
5457			;| V3! ( u1 -- )  Store value to v3 | DONE 
5457					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5457 cd e9 20			call macro_dsp_valuehl 
545a				endm 
# End of macro FORTH_DSP_VALUEHL
545a			 
545a 11 bc fb				ld de, cli_var_array+6 
545d				 
545d eb					ex de, hl 
545e 73					ld (hl), e 
545f 23					inc hl 
5460 72					ld (hl), d 
5461			 
5461					; destroy value TOS 
5461			 
5461					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5461 cd a1 21			call macro_forth_dsp_pop 
5464				endm 
# End of macro FORTH_DSP_POP
5464				       NEXTW 
5464 c3 60 22			jp macro_next 
5467				endm 
# End of macro NEXTW
5467			.V3Q: 
5467				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5467 7d				db WORD_SYS_CORE+105             
5468 78 54			dw .END            
546a 04				db 3 + 1 
546b .. 00			db "V3@",0              
546f				endm 
# End of macro CWHEAD
546f			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
546f 2a bc fb				ld hl, (cli_var_array+6) 
5472 cd f2 1e				call forth_push_numhl 
5475				       NEXTW 
5475 c3 60 22			jp macro_next 
5478				endm 
# End of macro NEXTW
5478			 
5478			 
5478			 
5478			 
5478			 
5478			; end of dict marker 
5478			 
5478 00			.END:    db WORD_SYS_END 
5479 00 00			dw 0 
547b 00				db 0 
547c			 
547c			; use to jp here for user dict words to save on macro expansion  
547c			 
547c			user_dict_next: 
547c				NEXTW 
547c c3 60 22			jp macro_next 
547f				endm 
# End of macro NEXTW
547f			 
547f			 
547f			user_exec: 
547f				;    ld hl, <word code> 
547f				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
547f				;    call forthexec 
547f				;    jp user_dict_next   (NEXT) 
547f			        ;    <word code bytes> 
547f eb				ex de, hl 
5480 2a 84 f6			ld hl,(os_tok_ptr) 
5483				 
5483				FORTH_RSP_NEXT 
5483 cd 99 1e			call macro_forth_rsp_next 
5486				endm 
# End of macro FORTH_RSP_NEXT
5486			 
5486			if DEBUG_FORTH_UWORD 
5486						DMARK "UEX" 
5486 f5				push af  
5487 3a 9b 54			ld a, (.dmark)  
548a 32 b4 fe			ld (debug_mark),a  
548d 3a 9c 54			ld a, (.dmark+1)  
5490 32 b5 fe			ld (debug_mark+1),a  
5493 3a 9d 54			ld a, (.dmark+2)  
5496 32 b6 fe			ld (debug_mark+2),a  
5499 18 03			jr .pastdmark  
549b ..			.dmark: db "UEX"  
549e f1			.pastdmark: pop af  
549f			endm  
# End of macro DMARK
549f				CALLMONITOR 
549f cd 7e 18			call break_point_state  
54a2				endm  
# End of macro CALLMONITOR
54a2			endif 
54a2			 
54a2			 
54a2			 
54a2 eb				ex de, hl 
54a3 22 84 f6			ld (os_tok_ptr), hl 
54a6				 
54a6				; Don't use next - Skips the first word in uword. 
54a6			 
54a6 c3 f1 22			jp exec1 
54a9			;	NEXT 
54a9			 
54a9			 
54a9			; eof 
# End of file forth_wordsv4.asm
54a9			endif 
54a9			;;;;;;;;;;;;;; Debug code 
54a9			 
54a9			 
54a9			;if DEBUG_FORTH_PARSE 
54a9 .. 00		.nowordfound: db "No match",0 
54b2 .. 00		.compword:	db "Comparing word ",0 
54c2 .. 00		.nextwordat:	db "Next word at",0 
54cf .. 00		.charmatch:	db "Char match",0 
54da			;endif 
54da			if DEBUG_FORTH_JP 
54da			.foundword:	db "Word match. Exec..",0 
54da			endif 
54da			;if DEBUG_FORTH_PUSH 
54da .. 00		.enddict:	db "Dict end. Push.",0 
54ea .. 00		.push_str:	db "Pushing string",0 
54f9 .. 00		.push_num:	db "Pushing number",0 
5508 .. 00		.data_sp:	db "SP:",0 
550c .. 00		.wordinhl:	db "Word in HL (2/0):",0 
551e .. 00		.wordinde:	db "Word in DE (3/0):",0 
5530 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5542			;endif 
5542			;if DEBUG_FORTH_MALLOC 
5542 .. 00		.push_malloc:	db "Malloc address",0 
5551			;endif 
5551			 
5551			 
5551			 
5551			; display malloc address and current data stack pointer  
5551			 
5551			malloc_error: 
5551 d5				push de 
5552 f5				push af 
5553 e5				push hl 
5554 cd cd 0c			call clear_display 
5557 11 79 55			ld de, .mallocerr 
555a 3e 00			ld a,0 
555c			;	ld de,os_word_scratch 
555c cd e0 0c			call str_at_display 
555f 3e 11			ld a, display_row_1+17 
5561 11 b4 fe			ld de, debug_mark 
5564 cd e0 0c			call str_at_display 
5567 cd f0 0c			call update_display 
556a				;call break_point_state 
556a cd 48 6b			call cin_wait 
556d			 
556d 3e 20			ld a, ' ' 
556f 32 74 f3			ld (os_view_disable), a 
5572 e1				pop hl 
5573 f1				pop af 
5574 d1				pop de	 
5575				CALLMONITOR 
5575 cd 7e 18			call break_point_state  
5578				endm  
# End of macro CALLMONITOR
5578 c9				ret 
5579			 
5579 .. 00		.mallocerr: 	db "Malloc Error",0 
5586			;if DEBUG_FORTH_PUSH 
5586			display_data_sp: 
5586 f5				push af 
5587			 
5587				; see if disabled 
5587			 
5587 3a 74 f3			ld a, (os_view_disable) 
558a fe 2a			cp '*' 
558c 28 67			jr z, .skipdsp 
558e			 
558e e5				push hl 
558f e5				push hl 
5590 e5			push hl 
5591 cd cd 0c			call clear_display 
5594 e1			pop hl 
5595 7c				ld a,h 
5596 21 88 f6			ld hl, os_word_scratch 
5599 cd 02 12			call hexout 
559c e1				pop hl 
559d 7d				ld a,l 
559e 21 8a f6			ld hl, os_word_scratch+2 
55a1 cd 02 12			call hexout 
55a4 21 8c f6			ld hl, os_word_scratch+4 
55a7 3e 00			ld a,0 
55a9 77				ld (hl),a 
55aa 11 88 f6			ld de,os_word_scratch 
55ad 3e 14				ld a, display_row_2 
55af cd e0 0c				call str_at_display 
55b2 11 0c 55			ld de, .wordinhl 
55b5 3e 00			ld a, display_row_1 
55b7			 
55b7 cd e0 0c				call str_at_display 
55ba 11 b4 fe			ld de, debug_mark 
55bd 3e 11			ld a, display_row_1+17 
55bf			 
55bf cd e0 0c				call str_at_display 
55c2			 
55c2				; display current data stack pointer 
55c2 11 08 55			ld de,.data_sp 
55c5 3e 1c				ld a, display_row_2 + 8 
55c7 cd e0 0c				call str_at_display 
55ca			 
55ca 2a b0 fb			ld hl,(cli_data_sp) 
55cd e5				push hl 
55ce 7c				ld a,h 
55cf 21 88 f6			ld hl, os_word_scratch 
55d2 cd 02 12			call hexout 
55d5 e1				pop hl 
55d6 7d				ld a,l 
55d7 21 8a f6			ld hl, os_word_scratch+2 
55da cd 02 12			call hexout 
55dd 21 8c f6			ld hl, os_word_scratch+4 
55e0 3e 00			ld a,0 
55e2 77				ld (hl),a 
55e3 11 88 f6			ld de,os_word_scratch 
55e6 3e 1f				ld a, display_row_2 + 11 
55e8 cd e0 0c				call str_at_display 
55eb			 
55eb			 
55eb cd f0 0c			call update_display 
55ee cd 4a 0c			call delay1s 
55f1 cd 4a 0c			call delay1s 
55f4 e1				pop hl 
55f5			.skipdsp: 
55f5 f1				pop af 
55f6 c9				ret 
55f7			 
55f7			display_data_malloc: 
55f7			 
55f7 f5				push af 
55f8 e5				push hl 
55f9 e5				push hl 
55fa e5			push hl 
55fb cd cd 0c			call clear_display 
55fe e1			pop hl 
55ff 7c				ld a,h 
5600 21 88 f6			ld hl, os_word_scratch 
5603 cd 02 12			call hexout 
5606 e1				pop hl 
5607 7d				ld a,l 
5608 21 8a f6			ld hl, os_word_scratch+2 
560b cd 02 12			call hexout 
560e 21 8c f6			ld hl, os_word_scratch+4 
5611 3e 00			ld a,0 
5613 77				ld (hl),a 
5614 11 88 f6			ld de,os_word_scratch 
5617 3e 14				ld a, display_row_2 
5619 cd e0 0c				call str_at_display 
561c 11 42 55			ld de, .push_malloc 
561f 3e 00			ld a, display_row_1 
5621			 
5621 cd e0 0c				call str_at_display 
5624			 
5624				; display current data stack pointer 
5624 11 08 55			ld de,.data_sp 
5627 3e 1c				ld a, display_row_2 + 8 
5629 cd e0 0c				call str_at_display 
562c			 
562c 2a b0 fb			ld hl,(cli_data_sp) 
562f e5				push hl 
5630 7c				ld a,h 
5631 21 88 f6			ld hl, os_word_scratch 
5634 cd 02 12			call hexout 
5637 e1				pop hl 
5638 7d				ld a,l 
5639 21 8a f6			ld hl, os_word_scratch+2 
563c cd 02 12			call hexout 
563f 21 8c f6			ld hl, os_word_scratch+4 
5642 3e 00			ld a,0 
5644 77				ld (hl),a 
5645 11 88 f6			ld de,os_word_scratch 
5648 3e 1f				ld a, display_row_2 + 11 
564a cd e0 0c				call str_at_display 
564d			 
564d cd f0 0c			call update_display 
5650 cd 4a 0c			call delay1s 
5653 cd 4a 0c			call delay1s 
5656 e1				pop hl 
5657 f1				pop af 
5658 c9				ret 
5659			;endif 
5659			 
5659			include "forth_autostart.asm" 
5659			; list of commands to perform at system start up 
5659			 
5659			startcmds: 
5659			;	dw test11 
5659			;	dw test12 
5659			;	dw test13 
5659			;	dw test14 
5659			;	dw test15 
5659			;	dw test16 
5659			;	dw test17 
5659			;	dw ifthtest1 
5659			;	dw ifthtest2 
5659			;	dw ifthtest3 
5659			;	dw mmtest1 
5659			;	dw mmtest2 
5659			;	dw mmtest3 
5659			;	dw mmtest4 
5659			;	dw mmtest5 
5659			;	dw mmtest6 
5659			;	dw iftest1 
5659			;	dw iftest2 
5659			;	dw iftest3 
5659			;	dw looptest1 
5659			;	dw looptest2 
5659			;	dw test1 
5659			;	dw test2 
5659			;	dw test3 
5659			;	dw test4 
5659			;	dw game2r 
5659			;	dw game2b1 
5659			;	dw game2b2 
5659			 
5659				; start up words that are actually useful 
5659			 
5659 b9 56			dw longread 
565b 00 57			dw clrstack 
565d 33 57			dw type 
565f 23 59			dw stest 
5661 57 57			dw strncpy 
5663 b9 58			dw list 
5665 b8 57			dw start1 
5667 ca 57			dw start2 
5669			;	dw start3 
5669 dd 57			dw start3b 
566b 59 58			dw start3c 
566d			 
566d				; (unit) testing words 
566d			 
566d 9a 59			dw mtesta 
566f 4f 5a			dw mtestb 
5671 f2 5a			dw mtestc 
5673 a7 5b			dw mtestd 
5675 4b 5c			dw mteste 
5677			 
5677				; demo/game words 
5677			 
5677 57 63		        dw game3w 
5679 85 63		        dw game3p 
567b a3 63		        dw game3sc 
567d d4 63		        dw game3vsi 
567f 00 64		        dw game3vs 
5681				 
5681 4a 61			dw game2b 
5683 b8 61			dw game2bf 
5685 02 62			dw game2mba 
5687 98 62			dw game2mbas 
5689 da 62			dw game2mb 
568b			 
568b 0b 5e			dw game1 
568d 1c 5e			dw game1a 
568f 7e 5e			dw game1b 
5691 b3 5e			dw game1c 
5693 e9 5e			dw game1d 
5695 1a 5f			dw game1s 
5697 2e 5f			dw game1t 
5699 43 5f			dw game1f 
569b 77 5f			dw game1z 
569d bb 5f			dw game1zz 
569f			 
569f 01 5d			dw test5 
56a1 39 5d			dw test6 
56a3 71 5d			dw test7 
56a5 85 5d			dw test8 
56a7 b1 5d			dw test9 
56a9 c7 5d			dw test10 
56ab				 
56ab 92 60		        dw ssv5 
56ad 76 60		        dw ssv4 
56af 5a 60		        dw ssv3 
56b1 24 60		        dw ssv2 
56b3 ab 60		        dw ssv1 
56b5 f3 60		        dw ssv1cpm 
56b7			;	dw keyup 
56b7			;	dw keydown 
56b7			;	dw keyleft 
56b7			;	dw keyright 
56b7			;	dw 	keyf1 
56b7			;	dw keyf2 
56b7			;	dw keyf3 
56b7			;	dw keyf4 
56b7			;	dw keyf5 
56b7			;	dw keyf6 
56b7			;	dw keyf7 
56b7			;	dw keyf8 
56b7			;	dw keyf9 
56b7			;	dw keyf10 
56b7			;	dw keyf11 
56b7			;	dw keyf12 
56b7			;	dw keytab 
56b7			;	dw keycr 
56b7			;	dw keyhome 
56b7			;	dw keyend 
56b7			;	dw keybs 
56b7 00 00			db 0, 0	 
56b9			 
56b9			 
56b9			; Long read of currently open file 
56b9 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5700			 
5700			; clear stack  
5700			 
5700 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5733			 
5733			; type ( addr count - ) 
5733 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5757			 
5757			; some direct memory words 
5757			; strncpy ( len t f -- t ) 
5757			 
5757 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
57b8			 
57b8 .. 00		start1:     	db ": bpon $0000 bp ;",0 
57ca .. 00		start2:     	db ": bpoff $0001 bp ;",0 
57dd .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5859 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
58b9			 
58b9			 
58b9			; a handy word to list items on the stack 
58b9			 
58b9 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5923			 
5923			 
5923			; test stack  
5923			; rnd8 stest 
5923			 
5923 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
599a			 
599a			; random malloc and free cycles 
599a			 
599a .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5a4f			 
5a4f			; fixed malloc and free cycles 
5a4f			 
5a4f .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5af2			 
5af2			; fixed double string push and drop cycle  
5af2			 
5af2 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5ba7			 
5ba7			; consistent fixed string push and drop cycle  
5ba7			 
5ba7 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5c4b			 
5c4b .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5d01			 
5d01			;test1:		db ": aa 1 2 3 ;", 0 
5d01			;test2:     	db "111 aa 888 999",0 
5d01			;test3:     	db ": bb 77 ;",0 
5d01			;test4:     	db "$02 $01 do i . loop bb",0 
5d01			 
5d01 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5d39 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5d71 .. 00		test7:     	db ": box hline vline ;",0 
5d85 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5db1 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5dc7 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5dec .. 00		test11:     	db "hello create .",0 
5dfb .. 00		test12:     	db "hello2 create .",0 
5e0b			 
5e0b			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5e0b			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5e0b			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5e0b			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5e0b			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5e0b			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5e0b			 
5e0b			;iftest1:     	db "$0001 IF cls .",0 
5e0b			;iftest2:     	db "$0000 IF cls .",0 
5e0b			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5e0b			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5e0b			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5e0b			 
5e0b			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e0b			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e0b			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e0b			 
5e0b			 
5e0b			 
5e0b			; a small guess the number game 
5e0b			 
5e0b .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5e1c .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5e7e			 
5e7e .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5eb3 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5ee9 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5f1a .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5f2e .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5f43 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5f77 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5fbb			 
5fbb			; Using 'ga' save a high score across multiple runs using external storage 
5fbb			 
5fbb .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6024			 
6024			 
6024			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6024			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6024			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6024			 
6024			; simple screen saver to test code memory reuse to destruction 
6024			 
6024 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
605a .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6076 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6092 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
60ab .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
60f3 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
614a			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
614a			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
614a			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
614a			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
614a			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
614a			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
614a			 
614a			 
614a			 
614a			; minesweeper/battleship finding game 
614a			; draws a game board of random ship/mine positions 
614a			; user enters coords to see if it hits on 
614a			; game ends when all are hit 
614a			; when hit or miss says how many may be in the area 
614a			 
614a			; setup the game board and then hide it 
614a .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
61b8 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6202			; prompt for where to target 
6202 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6298 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
62bd			; TODO see if the entered coords hits or misses pushes char hit of miss 
62bd .. 00		game2mbht:      db ": mbckht nop ;",0 
62cc .. 00		game2mbms:      db ": mbcms nop ;",0 
62da			; TODO how many might be near by 
62da .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6357			 
6357			; Game 3 
6357			 
6357			; Vert scroller ski game - avoid the trees! 
6357			 
6357			; v0 score (ie turns) 
6357			; v1 player pos 
6357			; v2 left wall 
6357			; v3 right wall 
6357			 
6357			; Draw side walls randomly 
6357			 
6357 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6385			 
6385			; Draw player 
6385 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
63a3			 
63a3			; TODO Get Key 
63a3			 
63a3			; TODO Move left right 
63a3			 
63a3			; scroll and move walls a bit 
63a3			 
63a3 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
63d4			 
63d4			; main game loop 
63d4			 
63d4 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6400 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
643f			 
643f			; key board defs 
643f			 
643f .. 00		keyup:       db ": keyup $05 ;",0 
644d .. 00		keydown:       db ": keydown $0a ;",0 
645d .. 00		keyleft:       db ": keyleft $0b ;",0 
646d .. 00		keyright:       db ": keyright $0c ;",0 
647e .. 00		keyf1:       db ": keyf1 $10 ;",0 
648c .. 00		keyf2:       db ": keyf2 $11 ;",0 
649a .. 00		keyf3:       db ": keyf3 $12 ;",0 
64a8 .. 00		keyf4:       db ": keyf4 $13 ;",0 
64b6 .. 00		keyf5:       db ": keyf5 $14 ;",0 
64c4 .. 00		keyf6:       db ": keyf6 $15 ;",0 
64d2 .. 00		keyf7:       db ": keyf7 $16 ;",0 
64e0 .. 00		keyf8:       db ": keyf8 $17 ;",0 
64ee .. 00		keyf9:       db ": keyf9 $18 ;",0 
64fc .. 00		keyf10:       db ": keyf10 $19 ;",0 
650b .. 00		keyf11:       db ": keyf11 $1a ;",0 
651a .. 00		keyf12:       db ": keyf12 $1b ;",0 
6529			 
6529 .. 00		keytab:       db ": keytab $09 ;",0 
6538 .. 00		keycr:       db ": keycr $0d ;",0 
6546 .. 00		keyhome:       db ": keyhome $0e ;",0 
6556 .. 00		keyend:       db ": keyend $0f ;",0 
6565 .. 00		keybs:       db ": keybs $08 ;",0 
6573			 
6573			   
6573			 
6573			 
6573			 
6573			; eof 
# End of file forth_autostart.asm
6573			 
6573 .. 00		sprompt1: db "Startup load...",0 
6583 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6599			 
6599			 
6599			 
6599			 
6599			forth_startup: 
6599 21 59 56			ld hl, startcmds 
659c 3e 00			ld a, 0 
659e 32 a9 f7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
65a1			 
65a1 e5			.start1:	push hl 
65a2 cd cd 0c			call clear_display 
65a5 11 73 65			ld de, sprompt1 
65a8 3e 00		        ld a, display_row_1 
65aa cd e0 0c			call str_at_display 
65ad 11 83 65			ld de, sprompt2 
65b0 3e 14		        ld a, display_row_2 
65b2 cd e0 0c			call str_at_display 
65b5 e1				pop hl 
65b6 e5				push hl 
65b7 5e				ld e,(hl) 
65b8 23				inc hl 
65b9 56				ld d,(hl) 
65ba 3e 28		        ld a, display_row_3 
65bc cd e0 0c			call str_at_display 
65bf cd f0 0c			call update_display 
65c2			 
65c2			 
65c2 3a a9 f7			ld a, (os_last_cmd) 
65c5 fe 00			cp 0 
65c7 28 05			jr z, .startprompt 
65c9 cd 3e 0c			call delay250ms 
65cc 18 24			jr .startdo 
65ce				 
65ce				 
65ce			 
65ce			.startprompt: 
65ce			 
65ce 3e 4f			ld a,display_row_4 + display_cols - 1 
65d0 11 68 1e		        ld de, endprg 
65d3 cd e0 0c			call str_at_display 
65d6 cd f0 0c			call update_display 
65d9 cd 4a 0c			call delay1s 
65dc cd 48 6b			call cin_wait 
65df						 
65df fe 2a			cp '*' 
65e1 28 5e			jr z, .startupend1 
65e3 fe 23			cp '#' 
65e5 20 07			jr nz, .startno 
65e7 3e 01			ld a, 1 
65e9 32 a9 f7			ld (os_last_cmd),a 
65ec 18 04			jr .startdo 
65ee fe 31		.startno:	cp '1' 
65f0 28 3a			jr z,.startnxt  
65f2			 
65f2				; exec startup line 
65f2			.startdo:	 
65f2 e1				pop hl 
65f3 e5				push hl 
65f4				 
65f4 5e				ld e,(hl) 
65f5 23				inc hl 
65f6 56				ld d,(hl) 
65f7 eb				ex de,hl 
65f8			 
65f8 e5				push hl 
65f9			 
65f9 3e 00			ld a, 0 
65fb				;ld a, FORTH_END_BUFFER 
65fb cd 6a 13			call strlent 
65fe 23				inc hl   ; include zero term to copy 
65ff 06 00			ld b,0 
6601 4d				ld c,l 
6602 e1				pop hl 
6603 11 83 f3			ld de, scratch 
6606 ed b0			ldir 
6608			 
6608			 
6608 21 83 f3			ld hl, scratch 
660b cd ae 22			call forthparse 
660e cd ee 22			call forthexec 
6611 cd 00 22			call forthexec_cleanup 
6614			 
6614 3e 3c			ld a, display_row_4 
6616 11 0c 1c			ld de, endprog 
6619			 
6619 cd f0 0c			call update_display		 
661c			 
661c 3a a9 f7			ld a, (os_last_cmd) 
661f fe 00			cp 0 
6621 20 09			jr nz, .startnxt 
6623 cd 6a 1e			call next_page_prompt 
6626 cd cd 0c		        call clear_display 
6629 cd f0 0c			call update_display		 
662c			 
662c				; move onto next startup line? 
662c			.startnxt: 
662c			 
662c cd 3e 0c			call delay250ms 
662f e1				pop hl 
6630			 
6630 23				inc hl 
6631 23				inc hl 
6632			 
6632 e5				push hl 
6633 5e				ld e, (hl) 
6634 23				inc hl 
6635 56				ld d, (hl) 
6636 e1				pop hl 
6637				; TODO replace 0 test 
6637			 
6637 eb				ex de, hl 
6638 cd 2a 0f			call ishlzero 
663b			;	ld a,e 
663b			;	add d 
663b			;	cp 0    ; any left to do? 
663b eb				ex de, hl 
663c c2 a1 65			jp nz, .start1 
663f 18 01			jr .startupend 
6641			 
6641 e1			.startupend1: pop hl 
6642			.startupend: 
6642			 
6642 cd cd 0c			call clear_display 
6645 cd f0 0c			call update_display 
6648 c9				ret 
6649			 
6649			 
6649			; stack over and underflow checks 
6649			 
6649			; init the words to detect the under/overflow 
6649			 
6649			chk_stk_init: 
6649				; a vague random number to check so we dont get any "lucky" hits 
6649 3e 2d			ld a, 45 
664b 6f				ld l, a 
664c 00				nop 
664d 3e 17			ld a, 23 
664f 67				ld h, a 
6650			 
6650 22 6a f3			ld (chk_word), hl     ; the word we need to check against 
6653			 
6653			;	ld (chk_stund), hl	; stack points.... 
6653 22 fd fe			ld (chk_stovr), hl 
6656 22 ae fb			ld (chk_ret_und), hl 
6659 22 6c fb			ld (chk_ret_ovr), hl 
665c 22 ea fa			ld (chk_loop_ovr), hl 
665f 22 e8 f8			ld (chk_data_ovr), hl 
6662 c9				ret 
6663				 
6663			check_stacks: 
6663				; check all stack words 
6663			 
6663 e5				push hl 
6664 d5				push de 
6665			 
6665			;	ld de,(chk_word) 
6665			;	ld hl, (chk_stund)	; stack points.... 
6665			;	if DEBUG_STK_FAULT 
6665			;		DMARK "FAa" 
6665			;		CALLMONITOR 
6665			;	endif 
6665			;	call cmp16 
6665			;	jp z, .chk_faulta 
6665			; 
6665			;	ld de, sfaultsu 
6665			;	jp .chk_fault 
6665			 
6665 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6668 ed 5b 6a f3		ld de,(chk_word) 
666c				if DEBUG_STK_FAULT 
666c					DMARK "FAb" 
666c					CALLMONITOR 
666c				endif 
666c cd 1f 0f			call cmp16 
666f 28 06			jr z, .chk_fault1 
6671 11 12 67			ld de, sfaultso 
6674 c3 c6 66			jp .chk_fault 
6677			.chk_fault1:  
6677 2a ae fb			ld hl, (chk_ret_und) 
667a ed 5b 6a f3		ld de,(chk_word) 
667e				if DEBUG_STK_FAULT 
667e					DMARK "FAU" 
667e					CALLMONITOR 
667e				endif 
667e cd 1f 0f			call cmp16 
6681 ca 8a 66			jp z, .chk_fault2 
6684 11 22 67			ld de, sfaultru 
6687 c3 c6 66			jp .chk_fault 
668a			.chk_fault2:  
668a 2a 6c fb			ld hl, (chk_ret_ovr) 
668d ed 5b 6a f3		ld de,(chk_word) 
6691				if DEBUG_STK_FAULT 
6691					DMARK "FA1" 
6691					CALLMONITOR 
6691				endif 
6691 cd 1f 0f			call cmp16 
6694 ca 9d 66			jp z, .chk_fault3 
6697 11 30 67			ld de, sfaultro 
669a c3 c6 66			jp .chk_fault 
669d			.chk_fault3:  
669d 2a ea fa			ld hl, (chk_loop_ovr) 
66a0 ed 5b 6a f3		ld de,(chk_word) 
66a4				if DEBUG_STK_FAULT 
66a4					DMARK "FA2" 
66a4					CALLMONITOR 
66a4				endif 
66a4 cd 1f 0f			call cmp16 
66a7 ca b0 66			jp z, .chk_fault4 
66aa 11 4a 67			ld de, sfaultlo 
66ad c3 c6 66			jp .chk_fault 
66b0			.chk_fault4:  
66b0 2a e8 f8			ld hl, (chk_data_ovr) 
66b3 ed 5b 6a f3		ld de,(chk_word) 
66b7				if DEBUG_STK_FAULT 
66b7					DMARK "FA3" 
66b7					CALLMONITOR 
66b7				endif 
66b7 cd 1f 0f			call cmp16 
66ba ca c3 66			jp z, .chk_fault5 
66bd 11 64 67			ld de, sfaultdo 
66c0 c3 c6 66			jp .chk_fault 
66c3			 
66c3			 
66c3			.chk_fault5:  
66c3 d1				pop de 
66c4 e1				pop hl 
66c5			 
66c5 c9				ret 
66c6			 
66c6 cd cd 0c		.chk_fault: 	call clear_display 
66c9 3e 14				ld a, display_row_2 
66cb cd e0 0c				call str_at_display 
66ce 11 f4 66				   ld de, .stackfault 
66d1 3e 00				ld a, display_row_1 
66d3 cd e0 0c				call str_at_display 
66d6 11 b4 fe				    ld de, debug_mark 
66d9 3e 11				ld a, display_row_1+17 
66db cd e0 0c				call str_at_display 
66de cd f0 0c				call update_display 
66e1			 
66e1				; prompt before entering montior for investigating issue 
66e1			 
66e1 3e 3c			ld a, display_row_4 
66e3 11 0c 1c			ld de, endprog 
66e6			 
66e6 cd f0 0c			call update_display		 
66e9			 
66e9 cd 6a 1e			call next_page_prompt 
66ec			 
66ec d1				pop de 
66ed e1				pop hl 
66ee cd 60 1c				call monitor 
66f1 c3 57 1b				jp warmstart 
66f4					;jp 0 
66f4					;halt 
66f4			 
66f4			 
66f4			 
66f4 .. 00		.stackfault: 	db "Stack fault:",0 
6701			 
6701 .. 00		sfaultsu: 	db	"Stack under flow",0 
6712 .. 00		sfaultso: 	db	"Stack over flow",0 
6722 .. 00		sfaultru:	db "RTS underflow",0 
6730 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
674a .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6764 .. 00		sfaultdo:	db "DTS overflow", 0 
6771			 
6771			 
6771			fault_dsp_under: 
6771 11 83 67			ld de, .dsp_under 
6774 c3 33 68			jp .show_fault 
6777			 
6777			fault_rsp_under: 
6777 11 91 67			ld de, .rsp_under 
677a c3 33 68			jp .show_fault 
677d			fault_loop_under: 
677d 11 9f 67			ld de, .loop_under 
6780 c3 33 68			jp .show_fault 
6783			 
6783 .. 00		.dsp_under: db "DSP Underflow",0 
6791 .. 00		.rsp_under: db "RSP Underflow",0 
679f .. 00		.loop_under: db "LOOP Underflow",0 
67ae			 
67ae			 
67ae d5			type_faultn: 	push de 
67af e5					push hl 
67b0 cd cd 0c				call clear_display 
67b3 11 da 67				   ld de, .typefaultn 
67b6 3e 00				ld a, display_row_1 
67b8 cd e0 0c				call str_at_display 
67bb 11 b4 fe				    ld de, debug_mark 
67be 3e 11				ld a, display_row_1+17 
67c0 cd e0 0c				call str_at_display 
67c3 cd f0 0c				call update_display 
67c6			 
67c6				; prompt before entering montior for investigating issue 
67c6			 
67c6 3e 3c			ld a, display_row_4 
67c8 11 0c 1c			ld de, endprog 
67cb			 
67cb cd f0 0c			call update_display		 
67ce			 
67ce cd 6a 1e			call next_page_prompt 
67d1			 
67d1 e5					push hl 
67d2 d5					push de 
67d3 cd 60 1c				call monitor 
67d6 c3 57 1b				jp warmstart 
67d9 76					halt 
67da			 
67da			 
67da .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
67f1			 
67f1 d5			type_faults: 	push de 
67f2 e5					push hl 
67f3 cd cd 0c				call clear_display 
67f6 11 1c 68				   ld de, .typefaults 
67f9 3e 00				ld a, display_row_1 
67fb cd e0 0c				call str_at_display 
67fe 11 b4 fe				    ld de, debug_mark 
6801 3e 11				ld a, display_row_1+17 
6803 cd e0 0c				call str_at_display 
6806 cd f0 0c				call update_display 
6809			 
6809				; prompt before entering montior for investigating issue 
6809			 
6809 3e 3c			ld a, display_row_4 
680b 11 0c 1c			ld de, endprog 
680e			 
680e cd f0 0c			call update_display		 
6811			 
6811 cd 6a 1e			call next_page_prompt 
6814			 
6814 e1					pop hl 
6815 d1					pop de 
6816 cd 60 1c				call monitor 
6819 c3 57 1b				jp warmstart 
681c			 
681c			 
681c .. 00		.typefaults: db "STR Type Expected TOS!",0 
6833			 
6833			.show_fault: 	 
6833 d5					push de 
6834 cd cd 0c				call clear_display 
6837 d1					pop de 
6838 3e 00				ld a, display_row_1 
683a cd e0 0c				call str_at_display 
683d 11 b4 fe				    ld de, debug_mark 
6840 3e 11				ld a, display_row_1+17 
6842 cd e0 0c				call str_at_display 
6845 cd f0 0c				call update_display 
6848			 
6848				; prompt before entering montior for investigating issue 
6848			 
6848 3e 3c			ld a, display_row_4 
684a 11 0c 1c			ld de, endprog 
684d			 
684d cd f0 0c			call update_display		 
6850			 
6850 cd 6a 1e			call next_page_prompt 
6853			 
6853 e1					pop hl 
6854 d1					pop de 
6855 cd 60 1c				call monitor 
6858			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6858			; TODO Make optional fault restart to cli or warm boot? 
6858					;jp warmstart 
6858 c3 b2 1b				jp cli 
685b 76					halt 
685c			 
685c			; handle the auto run of code from files in storage 
685c			 
685c			 
685c			if STORAGE_SE 
685c			 
685c .. 00		sprompt3: db "Loading from start-up file?:",0 
6879 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
688a			 
688a			 
688a			forth_autoload: 
688a			 
688a				; load block 0 of store 1 
688a				 
688a 3e fe			ld a, $fe      ; bit 0 clear 
688c 32 ee fb			ld (spi_device), a 
688f			 
688f cd 82 04			call storage_get_block_0 
6892			 
6892 3a 28 fc			ld a, (store_page+STORE_0_AUTOFILE) 
6895			 
6895 fe 00			cp 0 
6897 c8				ret z     ; auto start not enabled 
6898			 
6898 cd cd 0c			call clear_display 
689b			 
689b				; set bank 
689b			 
689b 3a 2a fc				ld a, (store_page+STORE_0_BANKRUN) 
689e 32 ee fb				ld (spi_device), a 
68a1			 
68a1				; get file id to load from and get the file name to display 
68a1			 
68a1 3a 2b fc				ld a, (store_page+STORE_0_FILERUN) 
68a4			 
68a4 2e 00				ld l, 0 
68a6 67					ld h, a 
68a7 11 07 fc				ld de, store_page 
68aa			 
68aa					if DEBUG_FORTH_WORDS 
68aa						DMARK "ASp" 
68aa f5				push af  
68ab 3a bf 68			ld a, (.dmark)  
68ae 32 b4 fe			ld (debug_mark),a  
68b1 3a c0 68			ld a, (.dmark+1)  
68b4 32 b5 fe			ld (debug_mark+1),a  
68b7 3a c1 68			ld a, (.dmark+2)  
68ba 32 b6 fe			ld (debug_mark+2),a  
68bd 18 03			jr .pastdmark  
68bf ..			.dmark: db "ASp"  
68c2 f1			.pastdmark: pop af  
68c3			endm  
# End of macro DMARK
68c3						CALLMONITOR 
68c3 cd 7e 18			call break_point_state  
68c6				endm  
# End of macro CALLMONITOR
68c6					endif 
68c6 cd 2a 09				call storage_read 
68c9			 
68c9					if DEBUG_FORTH_WORDS 
68c9						DMARK "ASr" 
68c9 f5				push af  
68ca 3a de 68			ld a, (.dmark)  
68cd 32 b4 fe			ld (debug_mark),a  
68d0 3a df 68			ld a, (.dmark+1)  
68d3 32 b5 fe			ld (debug_mark+1),a  
68d6 3a e0 68			ld a, (.dmark+2)  
68d9 32 b6 fe			ld (debug_mark+2),a  
68dc 18 03			jr .pastdmark  
68de ..			.dmark: db "ASr"  
68e1 f1			.pastdmark: pop af  
68e2			endm  
# End of macro DMARK
68e2						CALLMONITOR 
68e2 cd 7e 18			call break_point_state  
68e5				endm  
# End of macro CALLMONITOR
68e5					endif 
68e5			 
68e5 cd 2a 0f				call ishlzero 
68e8 c8					ret z             ; file not found 
68e9			 
68e9 3e 1e				ld a, display_row_2 + 10 
68eb 11 0a fc				ld de, store_page+3 
68ee cd e0 0c				call str_at_display 
68f1				 
68f1			; 
68f1			 
68f1 3e 05			ld a, display_row_1+5 
68f3 11 5c 68			ld de, sprompt3 
68f6 cd e0 0c			call str_at_display 
68f9 3e 37			ld a, display_row_3+15 
68fb 11 79 68			ld de, sprompt4 
68fe cd e0 0c			call str_at_display 
6901			 
6901 cd f0 0c			call update_display 
6904			 
6904 cd 48 6b			call cin_wait 
6907 fe 6e			cp 'n' 
6909 c8				ret z 
690a fe 4e			cp 'N' 
690c c8				ret z 
690d			 
690d cd 4a 0c			call delay1s 
6910			 
6910 3a 09 fc			ld a, (store_page+2) 
6913 32 f6 fb			ld (store_openmaxext), a    ; save count of ext 
6916 3e 01			ld a, 1  
6918 32 f7 fb			ld (store_openext), a    ; save count of ext 
691b			 
691b			.autof:  
691b 6f				ld l , a 
691c				 
691c 3a 07 fc			ld a, (store_page) 
691f 67				ld h, a	 
6920 11 07 fc			ld de, store_page 
6923					if DEBUG_FORTH_WORDS 
6923						DMARK "ASl" 
6923 f5				push af  
6924 3a 38 69			ld a, (.dmark)  
6927 32 b4 fe			ld (debug_mark),a  
692a 3a 39 69			ld a, (.dmark+1)  
692d 32 b5 fe			ld (debug_mark+1),a  
6930 3a 3a 69			ld a, (.dmark+2)  
6933 32 b6 fe			ld (debug_mark+2),a  
6936 18 03			jr .pastdmark  
6938 ..			.dmark: db "ASl"  
693b f1			.pastdmark: pop af  
693c			endm  
# End of macro DMARK
693c						CALLMONITOR 
693c cd 7e 18			call break_point_state  
693f				endm  
# End of macro CALLMONITOR
693f					endif 
693f cd 2a 09				call storage_read 
6942 cd 2a 0f			call ishlzero 
6945 c8				ret z 
6946			;	jr z, .autoend 
6946			 
6946					if DEBUG_FORTH_WORDS 
6946						DMARK "ASc" 
6946 f5				push af  
6947 3a 5b 69			ld a, (.dmark)  
694a 32 b4 fe			ld (debug_mark),a  
694d 3a 5c 69			ld a, (.dmark+1)  
6950 32 b5 fe			ld (debug_mark+1),a  
6953 3a 5d 69			ld a, (.dmark+2)  
6956 32 b6 fe			ld (debug_mark+2),a  
6959 18 03			jr .pastdmark  
695b ..			.dmark: db "ASc"  
695e f1			.pastdmark: pop af  
695f			endm  
# End of macro DMARK
695f						CALLMONITOR 
695f cd 7e 18			call break_point_state  
6962				endm  
# End of macro CALLMONITOR
6962					endif 
6962 11 09 fc			ld de, store_page+2 
6965 3e 3c			ld a, display_row_4 
6967 cd e0 0c			call str_at_display 
696a			 
696a cd f0 0c			call update_display 
696d cd 3e 0c			call delay250ms 
6970			 
6970			 
6970			 
6970 21 09 fc			ld hl, store_page+2 
6973 cd ae 22			call forthparse 
6976 cd ee 22			call forthexec 
6979 cd 00 22			call forthexec_cleanup 
697c			 
697c				 
697c 3a f7 fb			ld a, (store_openext) 
697f 3c				inc a 
6980 32 f7 fb			ld (store_openext), a    ; save count of ext 
6983			 
6983 18 96			jr .autof 
6985			;.autofdone: 
6985			; 
6985			;		if DEBUG_FORTH_WORDS 
6985			;			DMARK "ASx" 
6985			;			CALLMONITOR 
6985			;		endif 
6985			;;	call clear_display 
6985			;	ret 
6985			 
6985			 
6985			 
6985			endif 
6985			 
6985			 
6985			; eof 
# End of file forth_kernel.asm
6985			;include "nascombasic.asm" 
6985			 
6985			 
6985			; find out where the code ends if loaded into RAM (for SC114) 
6985			;endofcode:  
6985			;	nop 
6985			 
6985			 
6985			; eof 
6985			 
# End of file main.asm
6985			include "firmware_lcd_4x20.asm" 
6985			; **********************************************************************  
6985			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6985			; **********************************************************************  
6985			;  
6985			; **  Written as a Small Computer Monitor App  
6985			; **  www.scc.me.uk  
6985			;  
6985			; History  
6985			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6985			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6985			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6985			;  
6985			; **********************************************************************  
6985			;  
6985			; This program is an example of one of the methods of interfacing an   
6985			; alphanumeric LCD module.   
6985			;  
6985			; In this example the display is connected to either a Z80 PIO or a   
6985			; simple 8-bit output port.   
6985			;  
6985			; This interfacing method uses 4-bit data mode and uses time delays  
6985			; rather than polling the display's ready status. As a result the   
6985			; interface only requires 6 simple output lines:  
6985			;   Output bit 0 = not used  
6985			;   Output bit 1 = not used  
6985			;   Output bit 2 = RS         High = data, Low = instruction  
6985			;   Output bit 3 = E          Active high  
6985			;   Output bit 4 = DB4  
6985			;   Output bit 5 = DB5  
6985			;   Output bit 6 = DB6  
6985			;   Output bit 7 = DB7  
6985			; Display's R/W is connected to 0v so it is always in write mode  
6985			;  
6985			; This set up should work with any system supporting the RC2014 bus  
6985			  
6985			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6985			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6985			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6985			;  
6985			; **********************************************************************  
6985			  
6985			; **********************************************************************  
6985			; **  Constants  
6985			; **********************************************************************  
6985			; LCD constants required by LCD support module  
6985			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6985			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6985			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6985			kLCDWidth:  EQU display_cols             ;Width in characters  
6985			  
6985			; **********************************************************************  
6985			; **  Code library usage  
6985			; **********************************************************************  
6985			  
6985			; send character to current cursor position  
6985			; wraps and/or scrolls screen automatically  
6985			  
6985			  
6985			lcd_init:  
6985			  
6985			; SCMonAPI functions used  
6985			  
6985			; Alphanumeric LCD functions used  
6985			; no need to specify specific functions for this module  
6985			  
6985 3e cf		            LD   A, 11001111b  
6987 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6989 3e 00		            LD   A, 00000000b  
698b d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
698d			  
698d			; Initialise alphanumeric LCD module  
698d cd 06 6a		            CALL fLCD_Init      ;Initialise LCD module  
6990			  
6990 c9				ret  
6991			  
6991			;  
6991			;;  
6991			; lcd functions  
6991			;  
6991			;  
6991			  
6991			; what is at cursor position   
6991			  
6991			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6991			;		call curptr  
6991			;		ret  
6991			  
6991			  
6991			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6991			  
6991			curptr:  
6991 c5				push bc  
6992 21 4a fe			ld hl, display_fb0  
6995			cpr:	  
6995				; loop for cursor whole row  
6995 0e 14			ld c, display_cols  
6997 23			cpr1:	inc hl  
6998 0d				dec c  
6999 20 fc			jr nz, cpr1  
699b 05				dec b  
699c 20 f7			jr nz, cpr  
699e			  
699e				; add col	  
699e			  
699e 23			cpr2:	inc hl  
699f 1d				dec e  
69a0 20 fc			jr nz, cpr2  
69a2			  
69a2 c1				pop bc  
69a3 c9				ret  
69a4				  
69a4			  
69a4			  
69a4			  
69a4			  
69a4			; write the frame buffer given in hl to hardware   
69a4 22 52 fd		write_display: ld (display_write_tmp), hl 	   
69a7 3e 00			ld a, kLCD_Line1  
69a9 cd 77 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
69ac 06 14			ld b, display_cols  
69ae ed 5b 52 fd		ld de, (display_write_tmp)  
69b2 cd fe 69			call write_len_string  
69b5				  
69b5				  
69b5 2a 52 fd			ld hl, (display_write_tmp)  
69b8 11 14 00			ld de, display_cols  
69bb 19				add hl,de  
69bc 22 52 fd			ld (display_write_tmp),hl  
69bf			  
69bf				  
69bf 3e 40			ld a, kLCD_Line2  
69c1 cd 77 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
69c4 06 14			ld b, display_cols  
69c6 ed 5b 52 fd		ld de, (display_write_tmp)  
69ca cd fe 69			call write_len_string  
69cd				  
69cd 2a 52 fd			ld hl, (display_write_tmp)  
69d0 11 14 00			ld de, display_cols  
69d3 19				add hl,de  
69d4 22 52 fd			ld (display_write_tmp),hl  
69d7			  
69d7				  
69d7 3e 14			ld a, kLCD_Line3  
69d9 cd 77 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
69dc 06 14			ld b, display_cols  
69de ed 5b 52 fd		ld de, (display_write_tmp)  
69e2 cd fe 69			call write_len_string  
69e5				  
69e5 2a 52 fd			ld hl, (display_write_tmp)  
69e8 11 14 00			ld de, display_cols  
69eb 19				add hl,de  
69ec 22 52 fd			ld (display_write_tmp),hl  
69ef			  
69ef				  
69ef 3e 54			ld a, kLCD_Line4  
69f1 cd 77 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
69f4 06 14			ld b, display_cols  
69f6 ed 5b 52 fd		ld de, (display_write_tmp)  
69fa cd fe 69			call write_len_string  
69fd c9					ret  
69fe				  
69fe				; write out a fixed length string given in b from de  
69fe			  
69fe 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
69ff cd 50 6a		            CALL fLCD_Data      ;Write character to display  
6a02 13				inc de  
6a03 10 f9			djnz write_len_string  
6a05 c9				ret  
6a06			  
6a06			; Some other things to do  
6a06			;            LD   A, kLCD_Clear ;Display clear  
6a06			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6a06			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6a06			;            LD   A, kLCD_On     ;Display on with no cursor  
6a06			;            ;LD   A, kLCD_Off   ;Display off  
6a06			;            CALL fLCD_Inst      ;Send instruction to display  
6a06			;  
6a06			;  
6a06			;            halt  
6a06			;  
6a06			;  
6a06			;MsgHello:   DB  "Hello World!",0  
6a06			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6a06			  
6a06			; Custom characters 5 pixels wide by 8 pixels high  
6a06			; Up to 8 custom characters can be defined  
6a06			;BitMaps:      
6a06			;; Character 0x00 = Battery icon  
6a06			;            DB  01110b  
6a06			;            DB  11011b  
6a06			;            DB  10001b  
6a06			;            DB  10001b  
6a06			;            DB  11111b  
6a06			;            DB  11111b  
6a06			;            DB  11111b  
6a06			;            DB  11111b  
6a06			;; Character 0x01 = Bluetooth icon  
6a06			;            DB  01100b  
6a06			;            DB  01010b  
6a06			;            DB  11100b  
6a06			;            DB  01000b  
6a06			;            DB  11100b  
6a06			;            DB  01010b  
6a06			;            DB  01100b  
6a06			;            DB  00000b  
6a06			;  
6a06			  
6a06			  
6a06			; **********************************************************************  
6a06			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6a06			; **********************************************************************  
6a06			;  
6a06			; **  Written as a Small Computer Monitor App   
6a06			; **  Version 0.1 SCC 2018-05-16  
6a06			; **  www.scc.me.uk  
6a06			;  
6a06			; **********************************************************************  
6a06			;  
6a06			; This module provides support for alphanumeric LCD modules using with  
6a06			; *  HD44780 (or compatible) controller  
6a06			; *  5 x 7 pixel fonts  
6a06			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6a06			; *  Interface via six digital outputs to the display (see below)  
6a06			;  
6a06			; LCD module pinout:  
6a06			;   1  Vss   0v supply  
6a06			;   2  Vdd   5v supply  
6a06			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6a06			;   4  RS    High = data, Low = instruction  
6a06			;   5  R/W   High = Read, Low = Write  
6a06			;   6  E     Enable signal (active high)  
6a06			;   7  DB0   Data bit 0  
6a06			;   8  DB1   Data bit 1  
6a06			;   9  DB2   Data bit 2  
6a06			;  10  DB3   Data bit 3  
6a06			;  11  DB4   Data bit 4  
6a06			;  12  DB5   Data bit 5  
6a06			;  13  DB6   Data bit 6  
6a06			;  14  DB7   Data bit 7  
6a06			;  15  A     Backlight anode (+)  
6a06			;  16  K     Backlight cathode (-)  
6a06			;  
6a06			; This interfacing method uses 4-bit data mode and uses time delays  
6a06			; rather than polling the display's ready status. As a result the   
6a06			; interface only requires 6 simple output lines:  
6a06			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6a06			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6a06			;   LCD DB4 = Microcomputer output port bit 4  
6a06			;   LCD DB5 = Microcomputer output port bit 5  
6a06			;   LCD DB6 = Microcomputer output port bit 6  
6a06			;   LCD DB7 = Microcomputer output port bit 7  
6a06			; Display's R/W is connected to 0v so it is always in write mode  
6a06			; All 6 connections must be on the same port address <kLCDPrt>  
6a06			; This method also allows a decent length of cable from micro to LCD  
6a06			;  
6a06			; **********************************************************************  
6a06			;  
6a06			; To include the code for any given function provided by this module,   
6a06			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6a06			; the parent source file.  
6a06			; For example:  #REQUIRES   uHexPrefix  
6a06			;  
6a06			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6a06			; in the parent source file.  
6a06			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6a06			;  
6a06			; These are the function names provided by this module:  
6a06			; fLCD_Init                     ;Initialise LCD  
6a06			; fLCD_Inst                     ;Send instruction to LCD  
6a06			; fLCD_Data                     ;Send data byte to LCD  
6a06			; fLCD_Pos                      ;Position cursor  
6a06			; fLCD_Str                      ;Display string  
6a06			; fLCD_Def                      ;Define custom character  
6a06			;  
6a06			; **********************************************************************  
6a06			;  
6a06			; Requires SCMonAPI.asm to also be included in the project  
6a06			;  
6a06			  
6a06			  
6a06			; **********************************************************************  
6a06			; **  Constants  
6a06			; **********************************************************************  
6a06			  
6a06			; Constants that must be defined externally  
6a06			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6a06			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6a06			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6a06			;kLCDWidth: EQU 20             ;Width in characters  
6a06			  
6a06			; general line offsets in any frame buffer  
6a06			  
6a06			  
6a06			display_row_1: equ 0  
6a06			display_row_2: equ display_row_1+display_cols  
6a06			display_row_3: equ display_row_2 + display_cols  
6a06			display_row_4: equ display_row_3 + display_cols  
6a06			;display_row_4_eol:   
6a06			  
6a06			  
6a06			; Cursor position values for the start of each line  
6a06			kLCD_Line1: EQU 0x00   
6a06			kLCD_Line2: EQU 0x40    
6a06			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
6a06			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
6a06			  
6a06			; Instructions to send as A register to fLCD_Inst  
6a06			kLCD_Clear: EQU 00000001b     ;LCD clear  
6a06			kLCD_Off:   EQU 00001000b     ;LCD off  
6a06			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6a06			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6a06			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6a06			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6a06			  
6a06			; Constants used by this code module  
6a06			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6a06			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6a06			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6a06			  
6a06			  
6a06			  
6a06			; **********************************************************************  
6a06			; **  LCD support functions  
6a06			; **********************************************************************  
6a06			  
6a06			; Initialise alphanumeric LCD module  
6a06			; LCD control register codes:  
6a06			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6a06			;   N    0 = 1-line mode       1 = 2-line mode  
6a06			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6a06			;   D    0 = Display off       1 = Display on  
6a06			;   C    0 = Cursor off        1 = Cursor on  
6a06			;   B    0 = Blinking off      1 = Blinking on  
6a06			;   ID   0 = Decrement mode    1 = Increment mode  
6a06			;   SH   0 = Entire shift off  1 = Entire shift on  
6a06 3e 28		fLCD_Init:  LD   A, 40  
6a08 cd bd 6a		            CALL LCDDelay       ;Delay 40ms after power up  
6a0b			; For reliable reset set 8-bit mode - 3 times  
6a0b cd a7 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
6a0e cd a7 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
6a11 cd a7 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
6a14			; Set 4-bit mode  
6a14 cd a3 6a		            CALL WrFn4bit       ;Function = 4-bit mode  
6a17 cd bb 6a		            CALL LCDDelay1      ;Delay 37 us or more  
6a1a			; Function set  
6a1a 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6a1c cd 2f 6a		            CALL fLCD_Inst      ;2 line, display on  
6a1f			; Display On/Off control  
6a1f 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6a21 cd 2f 6a		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6a24			; Display Clear  
6a24 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6a26 cd 2f 6a		            CALL fLCD_Inst      ;Clear display  
6a29			; Entry mode  
6a29 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6a2b cd 2f 6a		            CALL fLCD_Inst      ;Increment mode, shift off  
6a2e			; Display module now initialised  
6a2e c9			            RET  
6a2f			; ok to here  
6a2f			  
6a2f			; Write instruction to LCD  
6a2f			;   On entry: A = Instruction byte to be written  
6a2f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a2f f5			fLCD_Inst:  PUSH AF  
6a30 f5			            PUSH AF  
6a31 cd 43 6a		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6a34 f1			            POP  AF  
6a35 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6a36 17			            RLA  
6a37 17			            RLA  
6a38 17			            RLA  
6a39 cd 43 6a		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6a3c 3e 02		            LD   A, 2  
6a3e cd bd 6a		            CALL LCDDelay       ;Delay 2 ms to complete   
6a41 f1			            POP  AF  
6a42 c9			            RET  
6a43 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
6a45 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a47 cb df		            SET  kLCDBitE, A  
6a49 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6a4b cb 9f		            RES  kLCDBitE, A  
6a4d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a4f c9			            RET  
6a50			  
6a50			  
6a50			; Write data to LCD  
6a50			;   On entry: A = Data byte to be written  
6a50			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a50 f5			fLCD_Data:  PUSH AF  
6a51 f5			            PUSH AF  
6a52 cd 64 6a		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6a55 f1			            POP  AF  
6a56 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6a57 17			            RLA  
6a58 17			            RLA  
6a59 17			            RLA  
6a5a cd 64 6a		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6a5d 3e 96		            LD   A, 150  
6a5f 3d			Wait:      DEC  A              ;Wait a while to allow data   
6a60 20 fd		            JR   NZ, Wait      ;  write to complete  
6a62 f1			            POP  AF  
6a63 c9			            RET  
6a64 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
6a66 cb d7		            SET  kLCDBitRS, A  
6a68 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6a6a cb df		            SET  kLCDBitE, A  
6a6c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6a6e cb 9f		            RES  kLCDBitE, A  
6a70 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6a72 cb 97		            RES  kLCDBitRS, A  
6a74 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a76 c9			            RET  
6a77			  
6a77			  
6a77			; Position cursor to specified location  
6a77			;   On entry: A = Cursor position  
6a77			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a77 f5			fLCD_Pos:   PUSH AF  
6a78 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6a7a cd 2f 6a		            CALL fLCD_Inst      ;Write instruction to LCD  
6a7d f1			            POP  AF  
6a7e c9			            RET  
6a7f			  
6a7f			  
6a7f			; Output text string to LCD  
6a7f			;   On entry: DE = Pointer to null terminated text string  
6a7f			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6a7f 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6a80 b7			            OR   A              ;Null terminator?  
6a81 c8			            RET  Z              ;Yes, so finished  
6a82 cd 50 6a		            CALL fLCD_Data      ;Write character to display  
6a85 13			            INC  DE             ;Point to next character  
6a86 18 f7		            JR   fLCD_Str       ;Repeat  
6a88 c9					ret  
6a89			  
6a89			; Define custom character  
6a89			;   On entry: A = Character number (0 to 7)  
6a89			;             DE = Pointer to character bitmap data  
6a89			;   On exit:  A = Next character number  
6a89			;             DE = Next location following bitmap  
6a89			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6a89			; Character is   
6a89 c5			fLCD_Def:   PUSH BC  
6a8a f5			            PUSH AF  
6a8b 07			            RLCA                ;Calculate location  
6a8c 07			            RLCA                ;  for bitmap data  
6a8d 07			            RLCA                ;  = 8 x CharacterNumber  
6a8e f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6a90 cd 2f 6a		            CALL fLCD_Inst      ;Write instruction to LCD  
6a93 06 00		            LD   B, 0  
6a95 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6a96 cd 50 6a		            CALL fLCD_Data      ;Write byte to display  
6a99 13			            INC  DE             ;Point to next byte  
6a9a 04			            INC  B              ;Count bytes  
6a9b cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6a9d 28 f6		            JR   Z, Loop       ;No, so repeat  
6a9f f1			            POP  AF  
6aa0 3c			            INC  A              ;Increment character number  
6aa1 c1			            POP  BC  
6aa2 c9			            RET  
6aa3			  
6aa3			  
6aa3			; **********************************************************************  
6aa3			; **  Private functions  
6aa3			; **********************************************************************  
6aa3			  
6aa3			; Write function to LCD  
6aa3			;   On entry: A = Function byte to be written  
6aa3			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6aa3 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6aa5 18 02		            JR   WrFunc  
6aa7 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6aa9 f5			WrFunc:     PUSH AF  
6aaa d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6aac cb df		            SET  kLCDBitE, A  
6aae d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6ab0 cb 9f		            RES  kLCDBitE, A  
6ab2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6ab4 3e 05		            LD   A, 5  
6ab6 cd bd 6a		            CALL LCDDelay       ;Delay 5 ms to complete  
6ab9 f1			            POP  AF  
6aba c9			            RET  
6abb			  
6abb			  
6abb			; Delay in milliseconds  
6abb			;   On entry: A = Number of milliseconds delay  
6abb			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6abb 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6abd d5			LCDDelay:   PUSH DE  
6abe 5f			            LD   E, A           ;Delay by 'A' ms  
6abf 16 00		            LD   D, 0  
6ac1 cd 2f 0c		            CALL aDelayInMS  
6ac4 d1			            POP  DE  
6ac5 c9			            RET  
6ac6			  
6ac6			  
6ac6			  
6ac6			  
6ac6			; eof  
6ac6			  
# End of file firmware_lcd_4x20.asm
6ac6			include "firmware_key_4x4.asm" 
6ac6			  
6ac6			  
6ac6			; bit mask for each scan column and row for teing the matrix  
6ac6			  
6ac6			; out   
6ac6 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
6aca			; in  
6aca 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
6ace			  
6ace			; row/col to character map  
6ace			  
6ace			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
6ace			;    
6ace			  
6ace			; physical key matrix map to face of key  
6ace			  
6ace			  
6ace			;      	1	2	3	A  
6ace			;   	abc”	def&	ghi$	s1  
6ace			;			  
6ace			;	4	5	6	B  
6ace			; 	jkl,	mno.	pqr:	s2  
6ace			;			  
6ace			; 	7	8	9	C  
6ace			;	stu;	vwx@	yz?!	s3  
6ace			;			  
6ace			; 	*	0	#	D  
6ace			; 	shift lck '	Space < >	Enter ( )	s4  
6ace			;       tab bs 		  
6ace			  
6ace			  
6ace			  
6ace			  
6ace			key_init:  
6ace			  
6ace			; SCMonAPI functions used  
6ace			  
6ace			; Alphanumeric LCD functions used  
6ace			; no need to specify specific functions for this module  
6ace			  
6ace			  
6ace 3e cf		            LD   A, 11001111b  
6ad0 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6ad2			;            LD   A, 00000000b  
6ad2 3e 0f		            LD   A, 00001111b  
6ad4 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6ad6			  
6ad6			  
6ad6				; TODO Configure cursor shapes  
6ad6			  
6ad6				; Load cursor shapes   
6ad6 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6ad8 11 e8 6a		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6adb 06 02		            LD   B, 2           ;Number of characters to define  
6add cd 89 6a		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6ae0 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6ae2			  
6ae2 3e 01				ld a, 1  
6ae4 32 4d fd			ld (cursor_shape),a  
6ae7 c9				ret  
6ae8			  
6ae8			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6ae8			; Up to 8 custom characters can be defined  
6ae8			.cursor_shapes:      
6ae8			;; Character 0x00 = Normal  
6ae8 1f			            DB  11111b  
6ae9 1f			            DB  11111b  
6aea 1f			            DB  11111b  
6aeb 1f			            DB  11111b  
6aec 1f			            DB  11111b  
6aed 1f			            DB  11111b  
6aee 1f			            DB  11111b  
6aef 1f			            DB  11111b  
6af0			;; Character 0x01 = Modifier  
6af0 1f			            DB  11111b  
6af1 1b			            DB  11011b  
6af2 1b			            DB  11011b  
6af3 1b			            DB  11011b  
6af4 1b			            DB  11011b  
6af5 1f			            DB  11111b  
6af6 1b			            DB  11011b  
6af7 1f			            DB  11111b  
6af8			  
6af8			  
6af8			  
6af8			  
6af8			; Display custom character 0  
6af8			;            LD   A, kLCD_Line1+14  
6af8			;            CALL fLCD_Pos       ;Position cursor to location in A  
6af8			;            LD   A, 0  
6af8			;            CALL fLCD_Data      ;Write character in A at cursor  
6af8			  
6af8			; Display custom character 1  
6af8			;            LD   A, kLCD_Line2+14  
6af8			;            CALL fLCD_Pos      ;Position cursor to location in A  
6af8			;            LD   A, 1  
6af8			;            CALL fLCD_Data     ;Write character in A at cursor  
6af8			  
6af8			; keyboard scanning   
6af8			  
6af8			  
6af8			; key_rows: equ 4  
6af8			; key_cols: equ 4  
6af8			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
6af8			  
6af8			; key_scanr: equ key_row_bitmask  
6af8			; key_scanc: equ key_col_bitmask  
6af8			  
6af8			; key_char_map: equ key_map  
6af8			  
6af8			  
6af8			  
6af8			; character in from keyboard  
6af8			  
6af8 ..			.matrix_to_char: db "D#0*C987B654A321"  
6b08			  
6b08			  
6b08			; map the physical key to a char dependant on state  
6b08			  
6b08			.key_map_fa:   
6b08			  
6b08 ..					db 'D'  
6b09 0d					db KEY_CR    ; cr  
6b0a ..					db ' '  
6b0b 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
6b0c ..					db 'C'  
6b0d ..					db 'y'  
6b0e ..					db 'v'  
6b0f ..					db 's'  
6b10 ..					db 'B'  
6b11 ..					db 'p'  
6b12 ..					db 'm'  
6b13 ..					db 'j'  
6b14 ..					db 'A'  
6b15 ..					db 'g'  
6b16 ..					db 'd'  
6b17 ..					db 'a'  
6b18			  
6b18			.key_map_fb:  
6b18			  
6b18 ..					db 'A'  
6b19 ..					db '+'   
6b1a ..					db '<'  
6b1b ..					db  "'"    
6b1c			  
6b1c ..					db 'A'  
6b1d ..					db 'z'  
6b1e ..					db 'w'  
6b1f ..					db 't'  
6b20 ..					db 'A'  
6b21 ..					db 'q'  
6b22 ..					db 'n'  
6b23 ..					db 'k'  
6b24 ..					db 'A'  
6b25 ..					db 'h'  
6b26 ..					db 'e'  
6b27 ..			 		db 'b'  
6b28			  
6b28			.key_map_fc:   
6b28			  
6b28			  
6b28 ..					db 'A'  
6b29 ..					db '-'   
6b2a ..					db '>'  
6b2b ..					db  '='   	  
6b2c ..					db 'A'  
6b2d ..					db '?'  
6b2e ..					db 'x'  
6b2f ..					db 'u'  
6b30 ..					db 'A'  
6b31 ..					db 'r'  
6b32 ..					db 'o'  
6b33 ..					db 'l'  
6b34 ..					db 'A'  
6b35 ..					db 'i'  
6b36 ..					db 'f'  
6b37 ..					db 'c'  
6b38			  
6b38				  
6b38			.key_map_fd:  
6b38			  
6b38 ..					db 'A'  
6b39 ..					db '/'   
6b3a ..					db '%'   
6b3b 08					db KEY_BS  ; back space  
6b3c ..					db 'A'  
6b3d ..					db '!'  
6b3e ..					db '@'  
6b3f ..					db ';'  
6b40 ..					db 'A'  
6b41 ..					db ':'  
6b42 ..					db '.'  
6b43 ..					db ','  
6b44 ..					db 'A'  
6b45 ..					db '$'  
6b46 ..					db '&'  
6b47 ..				 	db '"'  
6b48			  
6b48					  
6b48				  
6b48			  
6b48			; add cin and cin_wait  
6b48			  
6b48 cd 59 6b		cin_wait: 	call cin  
6b4b fe 00			cp 0  
6b4d 28 f9			jr z, cin_wait   ; block until key press  
6b4f			  
6b4f f5				push af   ; save key pressed  
6b50			  
6b50 cd 59 6b		.cin_wait1:	call cin  
6b53 fe 00			cp 0  
6b55 20 f9			jr nz, .cin_wait1  	; wait for key release  
6b57			  
6b57 f1				pop af   ; get key  
6b58 c9				ret  
6b59			  
6b59			  
6b59 cd 6a 6b		cin: 	call .mtoc  
6b5c			  
6b5c				; no key held  
6b5c fe 00			cp 0  
6b5e c8				ret z  
6b5f			  
6b5f				; stop key bounce  
6b5f			  
6b5f			;	ld (key_held),a		 ; save it  
6b5f 47				ld b, a  
6b60			  
6b60 c5			.cina1:	push bc  
6b61 cd 6a 6b			call .mtoc  
6b64 c1				pop bc  
6b65 b8				cp b  
6b66 28 f8			jr z, .cina1  
6b68 78				ld a,b		  
6b69 c9				ret  
6b6a			  
6b6a			; detect keyboard modifier key press and apply new overlay to the face key held  
6b6a			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6b6a			  
6b6a			;.cin_map_modifier:   
6b6a			;	ld a, (hl)  
6b6a			;	and 255  
6b6a			;	ret NZ		; modifier key not flagged  
6b6a			;  
6b6a			;	; get key face  
6b6a			;  
6b6a			;	ld b,(key_face_held)  
6b6a			;  
6b6a			;	ld b, key_cols * key_rows  
6b6a			;  
6b6a			;	push de  
6b6a			;	pop hl  
6b6a			;  
6b6a			;.mmod1: ld a,(hl)   ; get map test  
6b6a			;	cp b  
6b6a			;	jr z, .mmod2  
6b6a			;  
6b6a			;  
6b6a			;  
6b6a			;.mmod2: inc hl    ;   
6b6a			;  
6b6a			;	  
6b6a			;  
6b6a			;	  
6b6a			;  
6b6a			;	ld hl,key_actual_pressed  
6b6a			;	ld (hl),a,  
6b6a			;	ret  
6b6a			  
6b6a				  
6b6a			  
6b6a			; map matrix key held to char on face of key  
6b6a			  
6b6a			.mtoc:  
6b6a			  
6b6a			  
6b6a				; TODO optimise the code....  
6b6a			  
6b6a			; scan keyboard row 1  
6b6a 3e 80			ld a, 128  
6b6c 21 d3 fe			ld hl, keyscan_table  
6b6f cd 51 6c			call .rowscan  
6b72			  
6b72				   
6b72			  
6b72 3e 40			ld a, 64  
6b74 21 d7 fe			ld hl, keyscan_table+key_cols  
6b77 cd 51 6c			call .rowscan  
6b7a			  
6b7a			  
6b7a			  
6b7a			  
6b7a 3e 20			ld a, 32  
6b7c 21 db fe			ld hl, keyscan_table+(key_cols*2)  
6b7f cd 51 6c			call .rowscan  
6b82			  
6b82			  
6b82			  
6b82 3e 10			ld a, 16  
6b84 21 df fe			ld hl, keyscan_table+(key_cols*3)  
6b87 cd 51 6c			call .rowscan  
6b8a			  
6b8a			  
6b8a				; flag if key D is held down and remove from reporting  
6b8a 01 38 6b			ld bc, .key_map_fd    
6b8d 21 d3 fe			ld hl, keyscan_table  
6b90 11 c5 fe			ld de, key_fd  
6b93 cd e3 6b			call .key_shift_hold  
6b96 fe ff			cp 255  
6b98 28 33			jr z, .cinmap  
6b9a				; flag if key C is held down and remove from reporting  
6b9a 01 28 6b			ld bc, .key_map_fc    
6b9d 21 d7 fe			ld hl, keyscan_table+key_cols  
6ba0 11 c6 fe			ld de, key_fc  
6ba3 cd e3 6b			call .key_shift_hold  
6ba6 fe ff			cp 255  
6ba8 28 23			jr z, .cinmap  
6baa				; flag if key B is held down and remove from reporting  
6baa 01 18 6b			ld bc, .key_map_fb    
6bad 21 db fe			ld hl, keyscan_table+(key_cols*2)  
6bb0 11 c7 fe			ld de, key_fb  
6bb3 cd e3 6b			call .key_shift_hold  
6bb6 fe ff			cp 255  
6bb8 28 13			jr z, .cinmap  
6bba				; flag if key A is held down and remove from reporting  
6bba 01 08 6b			ld bc, .key_map_fa    
6bbd 21 df fe			ld hl, keyscan_table+(key_cols*3)  
6bc0 11 c8 fe			ld de, key_fa  
6bc3 cd e3 6b			call .key_shift_hold  
6bc6 fe ff			cp 255  
6bc8 28 03			jr z, .cinmap  
6bca			  
6bca 11 f8 6a			ld de, .matrix_to_char  
6bcd			  
6bcd			  
6bcd			.cinmap:   
6bcd				if DEBUG_KEY  
6bcd			            LD   A, kLCD_Line4  
6bcd			            CALL fLCD_Pos       ;Position cursor to location in A  
6bcd					push de  
6bcd			            LD   DE, keyscan_table  
6bcd			            CALL fLCD_Str       ;Display string pointed to by DE  
6bcd					pop de  
6bcd				endif  
6bcd			  
6bcd				; scan key matrix table for any held key  
6bcd			  
6bcd				; de holds either the default matrix or one selected above  
6bcd			  
6bcd 21 d3 fe			ld hl, keyscan_table  
6bd0 06 10			ld b,key_cols*key_rows  
6bd2			  
6bd2 7e			.cin1:	ld a,(hl)  
6bd3 fe 23			cp '#'  
6bd5 28 08			jr z, .cinhit  
6bd7 23				inc hl  
6bd8 13				inc de  
6bd9 05				dec b  
6bda 20 f6			jr nz, .cin1  
6bdc				; no key found held  
6bdc 3e 00			ld a,0  
6bde c9				ret  
6bdf d5			.cinhit: push de  
6be0 e1				pop hl  
6be1 7e				ld a,(hl)  
6be2 c9				ret  
6be3			  
6be3			; flag a control key is held   
6be3			; hl is key pin, de is flag indicator  
6be3			  
6be3			.key_shift_hold:  
6be3 c5				push bc  
6be4 3e 01			ld a, 1  
6be6 32 4d fd			ld (cursor_shape),a  
6be9 06 00			ld b, 0  
6beb 7e				ld a, (hl)  
6bec fe 2e			cp '.'  
6bee 28 0a			jr z, .key_shift1  
6bf0 06 ff			ld b, 255  
6bf2 3e 2b			ld a, '+'    ; hide key from later scans  
6bf4 77				ld (hl),a  
6bf5 3e 02			ld a, 2  
6bf7 32 4d fd			ld (cursor_shape),a  
6bfa			.key_shift1:  
6bfa				; write flag indicator  
6bfa 78				ld a,b  
6bfb 12				ld (de),a  
6bfc			  
6bfc d1				pop de    ; de now holds the key map ptr  
6bfd c9				ret  
6bfe			  
6bfe				  
6bfe				  
6bfe			  
6bfe			  
6bfe			  
6bfe			  
6bfe			  
6bfe			  
6bfe			  
6bfe			  
6bfe			  
6bfe			  
6bfe c9				ret  
6bff			  
6bff			;	push hl  
6bff			;	push de  
6bff			;	push bc  
6bff			;	call keyscan  
6bff			;	; map key matrix to ascii value of key face  
6bff			;  
6bff			;	ld hl, key_face_map  
6bff			;	ld de, keyscan_table  
6bff			;  
6bff			;	; get how many keys to look at  
6bff			;	ld b, keyscan_table_len  
6bff			;	  
6bff			;  
6bff			;	; at this stage fall out on first key hit  
6bff			;	; TODO handle multiple key press  
6bff			;  
6bff			;map1:	ld a,(hl)  
6bff			;	cp '#'  
6bff			;	jr z, keyhit  
6bff			;	inc hl  
6bff			;	inc de  
6bff			;	dec b  
6bff			;	jr nz, map1  
6bff			;nohit:	ld a, 0  
6bff			;	jr keydone  
6bff			;keyhit: push de  
6bff			;	pop hl  
6bff			;	ld a,(hl)  
6bff			;keydone:  
6bff			;	push bc  
6bff			;	push de  
6bff			; 	push hl  
6bff			;	ret   
6bff			;  
6bff			  
6bff			  
6bff			  
6bff			  
6bff			; scan physical key matrix  
6bff			  
6bff			  
6bff			;keyscan:  
6bff			;  
6bff			;; for each key_row use keyscanr bit mask for out  
6bff			;; then read in for keyscanc bitmask  
6bff			;; save result of row scan to keyscantable  
6bff			;  
6bff			;; scan keyboard row 1  
6bff			;  
6bff			;	ld b, key_rows  
6bff			;	ld hl, key_scanr  
6bff			;	ld de, keyscan_table  
6bff			;  
6bff			;rowloop:  
6bff			;  
6bff			;	ld a,(hl)		; out bit mask to energise keyboard row  
6bff			;	call rowscan  
6bff			;	inc hl  
6bff			;	dec b  
6bff			;	jr nz, rowloop  
6bff			;  
6bff			;	ret  
6bff			;  
6bff			;  
6bff			;; pass a out bitmask, b row number  
6bff			;arowscan:   
6bff			;	push bc  
6bff			;  
6bff			;	ld d, b  
6bff			;  
6bff			;	; calculate buffer location for this row  
6bff			;  
6bff			;	ld hl, keyscan_table	  
6bff			;kbufr:  ld e, key_cols  
6bff			;kbufc:	inc hl  
6bff			;	dec e  
6bff			;	jr nz, kbufc  
6bff			;	dec d  
6bff			;	jr nz, kbufr  
6bff			;  
6bff			;	; energise row and read columns  
6bff			;  
6bff			;	out (portbdata),a  
6bff			;	in a,(portbdata)  
6bff			;	ld c,a  
6bff			;  
6bff			;  
6bff			;	; save buffer loc  
6bff			;  
6bff			;	ld (keybufptr), hl  
6bff			;  
6bff			;	ld hl, key_scanc  
6bff			;	ld d, key_cols  
6bff			;  
6bff			;	; for each column check each bit mask  
6bff			;  
6bff			;colloop:  
6bff			;	  
6bff			;  
6bff			;	; reset flags for the row   
6bff			;  
6bff			;	ld b,'.'  
6bff			;	and (hl)  
6bff			;	jr z, maskskip  
6bff			;	ld b,'#'  
6bff			;maskskip:  
6bff			;	; save  key state  
6bff			;	push hl  
6bff			;	ld hl, (keybufptr)  
6bff			;	ld (hl), b  
6bff			;	inc hl  
6bff			;	ld (keybufptr), hl  
6bff			;  
6bff			;	; move to next bit mask  
6bff			;	pop hl  
6bff			;	inc hl  
6bff			;  
6bff			;	dec d  
6bff			;	jr nz, colloop  
6bff			;  
6bff			;	ret  
6bff			;  
6bff			;  
6bff			;;  
6bff			; lcd functions  
6bff			;  
6bff			;  
6bff			  
6bff			;if DEBUG_KEY_MATRIX  
6bff			  
6bff			; test function to display hardware view of matrix state  
6bff			  
6bff			matrix:  
6bff			  
6bff			  
6bff			  
6bff			; scan keyboard row 1  
6bff 3e 80			ld a, 128  
6c01 21 f8 fe			ld hl, keyscan_table_row1  
6c04 cd 51 6c			call .rowscan  
6c07			  
6c07 3e 40			ld a, 64  
6c09 21 f3 fe			ld hl, keyscan_table_row2  
6c0c cd 51 6c			call .rowscan  
6c0f			  
6c0f 3e 20			ld a, 32  
6c11 21 ee fe			ld hl, keyscan_table_row3  
6c14 cd 51 6c			call .rowscan  
6c17			  
6c17 3e 10			ld a, 16  
6c19 21 e9 fe			ld hl, keyscan_table_row4  
6c1c cd 51 6c			call .rowscan  
6c1f			  
6c1f			; Display text on first line  
6c1f 3e 00		            LD   A, kLCD_Line1  
6c21 cd 77 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6c24 11 f8 fe		            LD   DE, keyscan_table_row1  
6c27			            ;LD   DE, MsgHello  
6c27 cd 7f 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6c2a			  
6c2a			; Display text on second line  
6c2a 3e 40		            LD   A, kLCD_Line2  
6c2c cd 77 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6c2f 11 f3 fe		            LD   DE, keyscan_table_row2  
6c32 cd 7f 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6c35 3e 14		            LD   A, kLCD_Line3  
6c37 cd 77 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6c3a 11 ee fe		            LD   DE, keyscan_table_row3  
6c3d cd 7f 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6c40 3e 54		            LD   A, kLCD_Line4  
6c42 cd 77 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6c45 11 e9 fe		            LD   DE, keyscan_table_row4  
6c48 cd 7f 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6c4b			  
6c4b cd 3e 0c			call delay250ms  
6c4e c3 ff 6b			jp matrix  
6c51			  
6c51			; pass de as row display flags  
6c51			.rowscan:   
6c51 d3 c1			out (portbdata),a  
6c53 db c1			in a,(portbdata)  
6c55 4f				ld c,a  
6c56				; reset flags for the row   
6c56 06 2e			ld b,'.'  
6c58 e6 01			and 1  
6c5a 28 02			jr z, .p1on  
6c5c 06 23			ld b,'#'  
6c5e			.p1on:  
6c5e 70				ld (hl), b  
6c5f 23				inc hl  
6c60			  
6c60 06 2e			ld b,'.'  
6c62 79				ld a,c  
6c63 e6 02			and 2  
6c65			;	bit 0,a  
6c65 28 02			jr z, .p2on  
6c67 06 23			ld b,'#'  
6c69			.p2on:  
6c69 70				ld (hl), b  
6c6a 23				inc hl  
6c6b			;  
6c6b 06 2e			ld b,'.'  
6c6d 79				ld a,c  
6c6e e6 04			and 4  
6c70			;;	bit 0,a  
6c70 28 02			jr z, .p3on  
6c72 06 23			ld b,'#'  
6c74			.p3on:  
6c74 70				ld (hl), b  
6c75 23				inc hl  
6c76			;;  
6c76 06 2e			ld b,'.'  
6c78			;;	bit 0,a  
6c78 79				ld a,c  
6c79 e6 08			and 8  
6c7b 28 02			jr z, .p4on  
6c7d 06 23			ld b,'#'  
6c7f			.p4on:  
6c7f 70				ld (hl), b  
6c80 23				inc hl  
6c81			  
6c81			; zero term  
6c81 06 00			ld b,0  
6c83 70				ld (hl), b  
6c84			  
6c84 c9			.rscandone: ret  
6c85			  
6c85			  
6c85			  
6c85			;endif  
6c85			  
6c85			  
6c85			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6c85
