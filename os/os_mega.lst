# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 0e 1d			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-06 16:16' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b			 
001b			 
001b			 
001b			;        nop  
001b			;        nop 
001b			;;	org 05h		; null out bdos call 
001b			; 
001b			;        nop  
001b			;        nop  
001b			;        nop 
001b			;;	org 08h 
001b			;;; 
001b			;;	jp cin		; rst 8 - char in 
001b			;;; 
001b			; 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;	org 010h 
001b			;; 
001b			;	jp cout		; rest 010h  - char out 
001b			;; 
001b			;	org 01bh   
001b			; 
001b			;	;jp  		; rst 01bh   - write string to display 
001b			;	jp str_at_display 
001b			; 
001b			; 
001b			;	org 020h 
001b			; 
001b			;	; jp		 ; rst 020h - read char at screen location 
001b			; 
001b			;	org 028h 
001b			 
001b				; jp		 ; rst 028h  - storage i/o 
001b			 
001b			; 	org 030h 
001b			;	jp break_point_state 
001b			  
001b			; $30  
001b			; org 038h 
001b			; $38 
001b			 
001b			; TODO any more important entry points to add to jump table for easier coding use? 
001b			 
001b			if BASE_KEV = 1  
001b			 
001b				; need to be at $66 for nmi support 
001b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0021 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0027 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0033 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0039 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0045 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0051 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0057 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0063 00 ff			db 0,255 
0065 c3 b4 76			jp nmi 
0068			endif 
0068			 
0068			include "firmware.asm" 
0068			  
0068			; main constants (used here and in firmware)  
0068			  
0068			; TODO have page 0 of storage as bios  
0068			  
0068			Device_A: equ 0h  
0068			Device_B: equ 040h          ; Sound  
0068			  
0068			if BASE_KEV  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_SC114  
0068			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			; TODO fixup for CPM  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			Device_D: equ 0c0h             ; Keyboard and LCD  
0068			  
0068			; Odd specific debug points for testing hardware dev  
0068			  
0068			DEBUG_SOUND: equ 0       
0068			DEBUG_STK_FAULT: equ 0  
0068			DEBUG_INPUT: equ 0     ; Debug input entry code  
0068			DEBUG_KEYCINWAIT: equ 0  
0068			DEBUG_KEYCIN: equ 0  
0068			DEBUG_KEY: equ 0  
0068			DEBUG_KEY_MATRIX: equ 0  
0068			DEBUG_STORECF: equ 0  
0068			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0068			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0068			DEBUG_SPI: equ 0    ; low level spi tests  
0068			  
0068			; Enable many break points  
0068			  
0068			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0068			DEBUG_FORTH_JP: equ 0    ; 4  
0068			DEBUG_FORTH_MALLOC: equ 0  
0068			DEBUG_FORTH_MALLOC_INT: equ 0  
0068			DEBUG_FORTH_DOT: equ 1  
0068			DEBUG_FORTH_DOT_WAIT: equ 0  
0068			DEBUG_FORTH_MATHS: equ 0  
0068			DEBUG_FORTH_TOK: equ 0    ; 4  
0068			DEBUG_FORTH_PARSE: equ 0    ; 3  
0068			DEBUG_FORTH: equ 0  ;2  
0068			DEBUG_FORTH_WORDS: equ 1   ; 1  
0068			DEBUG_FORTH_PUSH: equ 1   ; 1  
0068			DEBUG_FORTH_UWORD: equ 1   ; 1  
0068			  
0068			; Enable key point breakpoints  
0068			  
0068			DEBUG_FORTH_DOT_KEY: equ 0  
0068			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0068			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0068			  
0068			; Debug stack imbalances  
0068			  
0068			ON: equ 1  
0068			OFF: equ 0  
0068			  
0068			DEBUG_STACK_IMB: equ 0  
0068			STACK_IMB_STORE: equ 20  
0068			  
0068			; House keeping and protections  
0068			  
0068			DEBUG_FORTH_STACK_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0068			FORTH_ENABLE_FREE: equ 0  
0068			FORTH_ENABLE_MALLOCFREE: equ 1  
0068			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0068			FORTH_ENABLE_FLOATMATH: equ 0  
0068			  
0068			  
0068			CALLMONITOR: macro  
0068			;	call break_point_state  
0068			; now use the break point debug vector  
0068				call debug_vector  
0068				endm  
0068			  
0068			MALLOC_1: equ 1        ; from dk88   
0068			MALLOC_2: equ 0           ; broke  
0068			MALLOC_3: equ 0           ; really broke  
0068			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0068			  
0068			if BASE_KEV   
0068			stacksize: equ 256  
0068			  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 512  
0068			endif  
0068			if BASE_SC114  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			;if STORAGE_SE == 0  
0068			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0068			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0068			;endif  
0068			  
0068			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0068			  
0068			STORE_0_AUTORUN: equ $20  
0068			  
0068			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0068			  
0068			STORE_0_AUTOFILE: equ $21  
0068			STORE_0_BANKRUN: equ $23  
0068			STORE_0_FILERUN: equ $24  
0068			  
0068			; Block 0 offsets for settings  
0068			  
0068			; if set then skip prompt for start up and accept all  
0068			  
0068			STORE_0_QUICKSTART: equ $25  
0068			  
0068			; Blocks where directory table is held  
0068			  
0068			; Reducing the number of entries increases the max file size  
0068			  
0068			;STORE_DIR_START: equ 1  
0068			;STORE_DIR_END: equ 33  
0068			  
0068			; Blocks from where file data is stored  
0068			  
0068			;STORE_DATA_START: equ STORE_DIR_END + 1  
0068			  
0068			; Block indicators (<32 are data files)  
0068			  
0068			;STORE_BLOCK_CFG: equ $8f       ; config block  
0068			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0068			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0068			;STORE_BLOCK_FREE: equ $85       ; data block free  
0068			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0068			  
0068			  
0068			  
0068			; Directory entry flags  
0068			  
0068			;STORE_DIR_FREE: equ 0  
0068			;STORE_DIR_FILE:  equ 1  
0068			  
0068			; Structure offsets to directory entries  
0068			;STORE_DE_FLAG: equ 0  
0068			;STORE_DE_MAXEXT: equ 1  
0068			;STORE_DE_FILENAME: equ 2  
0068			  
0068			; Structure offsets to block 0  
0068			  
0068			;STORE_BK0_ISFOR: equ 1  
0068			;STORE_BK0_LABEL: equ 3  
0068			  
0068			; memory allocation   
0068			  
0068			chk_stund: equ tos+2           ; underflow check word  
0068			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0068			  
0068			; keyscan table needs rows x cols buffer  
0068			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0068			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0068			  
0068			keyscan_table_row1: equ chk_stovr -key_cols-1  
0068			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0068			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0068			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0068			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0068			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0068			keyscan_scancol: equ keyscan_table-key_cols  
0068			;keyscan_table_len: equ key_rows*key_cols  
0068			;keybufptr: equ keyscan_table - 2  
0068			;keysymbol: equ keybufptr - 1  
0068			key_held: equ keyscan_scancol-1	; currently held  
0068			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0068			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0068			key_fa: equ key_repeat_ct -1 ;  
0068			key_fb: equ key_fa -1 ;  
0068			key_fc: equ key_fb -1 ;  
0068			key_fd: equ key_fc -1 ;  
0068			key_face_held: equ key_fd - 1   
0068			  
0068			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0068			  
0068			hardware_config: equ key_face_held - 10  
0068			  
0068			; hardware config switches  
0068			; TODO add bitmasks on includes for hardware  
0068			; high byte for expansion ids  
0068			;     0000 0000  no card inserted  
0068			;     0000 0001  storage card inserted  
0068			;     0000 0010  spi sd card active  
0068			  
0068			;       
0068			; low byte:  
0068			;     0000 0001   4x4 keypad  
0068			;     0000 0010   full keyboard  
0068			;     0000 0011   spi/ext keyboard  
0068			;     0000 0100   20x4 lcd  
0068			;     0000 1000   40x4 lcd  
0068			;     0000 1100   spi/ext display  
0068			;     0001 0000   ide interface available  
0068			  
0068			hardware_word: equ hardware_config - 2  
0068			  
0068			; debug marker - optional display of debug point on the debug screens  
0068			  
0068			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0068			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0068			  
0068			debug_mark: equ debug_vector - 4  
0068			  
0068			; input_str vars  
0068			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0068			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0068			input_size: equ input_start -1  ; number of chars  
0068			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0068			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0068			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0068			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0068			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0068			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0068			input_len: equ input_cur_onoff - 5 ; length of current input  
0068			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0068			  
0068			CUR_BLINK_RATE: equ 15  
0068			  
0068			key_actual_pressed: equ input_cursor - 1   
0068			key_symbol: equ key_actual_pressed - 1   
0068			key_shift: equ key_symbol - 1   
0068			  
0068			; Display allocation  
0068			  
0068			;display_rows: equ 4     ; move out to mini and mega files  
0068			;display_cols: equ 20  
0068			  
0068			display_fb_len: equ display_rows*display_cols  
0068			  
0068			; primary frame buffer     
0068			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0068			; working frame buffers  
0068			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0068			display_fb3: equ  display_fb1-display_fb_len - 1  
0068			display_fb2: equ  display_fb3-display_fb_len - 1  
0068			;  
0068			; pointer to active frame buffer  
0068			display_fb_active: equ display_fb2 - 2  
0068			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0068			display_write_tmp: equ display_lcde1e2 - 2  
0068			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0068			  
0068			;  
0068			  
0068			;; can load into de directory  
0068			cursor_col: equ display_active-1  
0068			cursor_row: equ cursor_col-1  
0068			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0068			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0068			  
0068			; maths vars  
0068			  
0068			LFSRSeed: equ cursor_shape -20   
0068			randData: equ LFSRSeed - 2  
0068			xrandc: equ randData - 2  
0068			stackstore: equ xrandc - 2  
0068			seed1: equ  stackstore -2   
0068			seed2: equ seed1 - 2  
0068			  
0068			; cf storage vars  
0068			  
0068			iErrorNum:  equ seed2-1         ;Error number  
0068			iErrorReg:  equ iErrorNum -1              ;Error register  
0068			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0068			  
0068			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0068			  
0068			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0068			  
0068			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0068			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0068			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0068			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0068			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0068			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0068			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0068			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0068			store_tmpid: equ store_tmp3 - 1		; page temp id  
0068			store_tmpext: equ store_tmpid - 1		; file extent temp  
0068			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0068			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0068			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0068			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0068			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0068			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0068			;  
0068			; spi vars  
0068			  
0068			  
0068			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0068			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0068			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0068			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0068			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0068			spi_device_id: equ spi_device - 1    ; human readable bank number  
0068			  
0068			;;;;; forth cli params  
0068			  
0068			; TODO use a different frame buffer for forth???  
0068			  
0068			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0068			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0068			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0068			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0068			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0068			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0068			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0068			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0068			  
0068			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0068			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0068			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0068			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0068			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0068			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0068			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0068			  
0068			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0068			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0068			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0068			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0068			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0068			  
0068			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0068			  
0068			; os/forth token vars  
0068			  
0068			os_last_cmd: equ os_var_array-255  
0068			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0068			os_current_i: equ os_cli_cmd-2  
0068			os_cur_ptr: equ os_current_i-2  
0068			os_word_scratch: equ os_cur_ptr-30  
0068			os_tok_len: equ os_word_scratch - 2  
0068			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0068			os_tok_malloc: equ os_tok_ptr - 2  
0068			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0068			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0068			execscratch: equ os_input-255        ; exec cmd eval buffer  
0068			scratch: equ execscratch-255  
0068			  
0068			os_stack_1: equ scratch - 3       ; stack holding area 1  
0068			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
0068			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
0068			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
0068			  
0068			  
0068			; temp locations for new word processing to save on adding more   
0068			  
0068			os_new_malloc: equ os_stack_4-2  
0068			os_new_parse_len: equ os_new_malloc - 2  
0068			os_new_word_len: equ os_new_parse_len - 2  
0068			os_new_work_ptr: equ os_new_word_len - 2  
0068			os_new_src_ptr: equ os_new_work_ptr - 2  
0068			os_new_exec: equ os_new_src_ptr - 2  
0068			os_new_exec_ptr: equ os_new_exec - 2  
0068			  
0068			; resume memory alloocations....  
0068			  
0068			;os_view_disable: equ os_new_exec_ptr - 1  
0068			os_view_af: equ os_new_exec_ptr - 2  
0068			os_view_hl: equ os_view_af -2  
0068			os_view_de: equ os_view_hl - 2  
0068			os_view_bc: equ os_view_de - 2  
0068			  
0068			; stack checksum word  
0068			if DEBUG_STACK_IMB  
0068				curframe: equ  os_view_de - 5  
0068				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0068				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			else  
0068				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			endif  
0068			  
0068			; with data stack could see memory filled with junk. need some memory management   
0068			; malloc and free entry points added  
0068			  
0068			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0068			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			;heap_end: equ free_list-1  ; Starting address of heap  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			heap_end: equ chk_word-1  ; Starting address of heap  
0068			  
0068			  
0068			;if BASE_KEV   
0068			;heap_start: equ 0800eh  ; Starting address of heap  
0068			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;heap_start: equ baseram+15  ; Starting address of heap  
0068			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;endif  
0068			  
0068			  
0068			;;;;  
0068			  
0068			  
0068			; change below to point to last memory alloc above  
0068			topusermem:  equ   heap_start  
0068			  
0068			;if BASE_KEV   
0068			;baseusermem: equ 08000h  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;;aseusermem:     equ    12  
0068			;baseusermem:     equ    prompt  
0068			;;baseusermem:     equ    endofcode  
0068			;endif  
0068			  
0068			  
0068			; **********************************************************************  
0068			; **  Constants  
0068			; **********************************************************************  
0068			  
0068			; Constants used by this code module  
0068			kDataReg:   EQU Device_D           ;PIO port A data register  
0068			kContReg:   EQU Device_D+2           ;PIO port A control register  
0068			  
0068			  
0068			portbdata:  equ Device_D+1    ; port b data  
0068			portbctl:   equ Device_D+3    ; port b control  
0068			  
0068			  
0068			;KEY_SHIFT:   equ 5  
0068			;KEY_SYMBOLSHIFT:  equ 6  
0068			  
0068			KEY_SHIFTLOCK: equ 4  
0068			  
0068			  
0068			KEY_UP: equ 5  
0068			KEY_NEXTWORD: equ 6  
0068			KEY_PREVWORD: equ 7  
0068			KEY_BS: equ 8  
0068			KEY_TAB:  equ 9  
0068			KEY_DOWN: equ 10  
0068			KEY_LEFT: equ 11  
0068			KEY_RIGHT: equ 12  
0068			KEY_CR:   equ 13  
0068			KEY_HOME: equ 14  
0068			KEY_END: equ 15  
0068			  
0068			KEY_F1: equ 16  
0068			KEY_F2: equ 17  
0068			KEY_F3: equ 18  
0068			KEY_F4: equ 19  
0068			  
0068			KEY_F5: equ 20  
0068			KEY_F6: equ 21  
0068			KEY_F7: equ 22  
0068			KEY_F8: equ 23  
0068			  
0068			KEY_F9: equ 24  
0068			KEY_F10: equ 25  
0068			KEY_F11: equ 26  
0068			KEY_F12: equ 27  
0068			  
0068			;if DEBUG_KEY  
0068			;	KEY_MATRIX_NO_PRESS: equ '.'  
0068			;	KEY_SHIFT:   equ '.'  
0068			;	KEY_SYMBOLSHIFT:  equ '.'  
0068			;else  
0068				KEY_SHIFT:   equ '~'  
0068				KEY_SYMBOLSHIFT:  equ '~'  
0068				KEY_MATRIX_NO_PRESS: equ '~'  
0068			;endi  
0068			  
0068			  
0068			  
0068			  
0068			; Macro to make adding debug marks easier  
0068			  
0068			DMARK: macro str  
0068				push af  
0068				ld a, (.dmark)  
0068				ld (debug_mark),a  
0068				ld a, (.dmark+1)  
0068				ld (debug_mark+1),a  
0068				ld a, (.dmark+2)  
0068				ld (debug_mark+2),a  
0068				jr .pastdmark  
0068			.dmark: db str  
0068			.pastdmark: pop af  
0068			  
0068			endm  
0068			  
0068			  
0068			; macro to detect for stack imbalances  
0068			  
0068			include "stackimbal.asm"  
0068			; Macro and code to detect stock imbalances 
0068			 
0068			SPPUSH: equ 0 
0068			 
0068			; Add a stack frame which can be checked before return 
0068			 
0068			STACKFRAME: macro onoff frame1 frame2 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068						exx 
0068			 
0068						ld de, frame1 
0068						ld a, d 
0068						ld hl, curframe 
0068						call hexout 
0068						ld a, e 
0068						ld hl, curframe+2 
0068						call hexout 
0068			  
0068						ld hl, frame1 
0068						push hl 
0068						ld hl, frame2 
0068						push hl 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			endm 
0068			 
0068			STACKFRAMECHK: macro onoff frame1 frame2 
0068			 
0068					 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						exx 
0068						; check stack frame SP 
0068			 
0068						ld hl, frame2 
0068						pop de   ; frame2 
0068			 
0068						call cmp16 
0068						jr nz, .spnosame 
0068						 
0068			 
0068						ld hl, frame1 
0068						pop de   ; frame1 
0068			 
0068						call cmp16 
0068						jr z, .spfrsame 
0068			 
0068						.spnosame: call showsperror 
0068			 
0068						.spfrsame: nop 
0068			 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			 
0068			 
0068			endm 
0068			 
0068			 
0068			; for a sub routine, wrap SP collection and comparisons 
0068			 
0068			; Usage: 
0068			; 
0068			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0068			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0068			 
0068			SAVESP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068			 
0068						ld (store_sp+(storeword*4)), sp 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			CHECKSP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068			 
0068						; save SP after last save 
0068				 
0068						ld (store_sp+(storeword*4)+2), sp 
0068			 
0068						push hl 
0068						ld hl, store_sp+(storeword*4) 
0068						call check_stack_sp  
0068						pop hl 
0068			 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			if DEBUG_STACK_IMB 
0068			 
0068			check_stack_sp: 
0068					push de 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					push de 
0068			 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					pop hl 
0068			 
0068			 
0068					; check to see if the same 
0068			 
0068					call cmp16 
0068					jr z, .spsame 
0068			 
0068					; not same 
0068			 
0068					call showsperror 
0068			.spsame: 
0068			 
0068					pop de 
0068			 
0068					ret 
0068			 
0068			.sperr:  db "Stack imbalance",0 
0068			 
0068			 
0068			showsperror: 
0068			 
0068			 
0068				push hl 
0068				push af 
0068				push de 
0068				call clear_display 
0068				ld de, .sperr 
0068				ld a,0 
0068			;	ld de,os_word_scratch 
0068				call str_at_display 
0068				ld a, display_row_1+17 
0068				ld de, debug_mark 
0068				call str_at_display 
0068				ld a, 0 
0068				ld (curframe+4),a 
0068				ld hl, curframe 
0068				ld de, os_word_scratch 
0068				ld a, display_row_4 
0068				call str_at_display 
0068				call update_display 
0068				;call break_point_state 
0068				call cin_wait 
0068			 
0068			;	ld a, ' ' 
0068			;	ld (os_view_disable), a 
0068				call bp_on 
0068				pop de	 
0068				pop af 
0068				pop hl 
0068				CALLMONITOR 
0068				ret 
0068			 
0068			endif 
0068			 
0068			 
0068			 
0068			; eof 
# End of file stackimbal.asm
0068			  
0068			;TODO macro to calc col and row offset into screen  
0068			  
0068			  
0068			  
0068			hardware_init:  
0068			  
0068				  
0068			  
0068					;ld a, 0  
0068					;ld (hardware_diag), a  
0068			  
0068					; clear all the buffers  
0068			  
0068 21 0d fd				ld hl, display_fb1  
006b 22 c9 fb				ld (display_fb_active), hl  
006e			  
006e cd 9b 0d				call clear_display  
0071			  
0071 21 cb fb				ld hl, display_fb2  
0074 22 c9 fb				ld (display_fb_active), hl  
0077			  
0077 cd 9b 0d				call clear_display  
007a			  
007a					; init primary frame buffer area  
007a 21 ae fd				ld hl, display_fb0  
007d 22 c9 fb				ld (display_fb_active), hl  
0080			  
0080 cd 9b 0d				call clear_display  
0083			  
0083			  
0083 cd c1 76				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0086			  
0086 cd 58 79			call key_init  
0089 cd 47 02			call storage_init  
008c			  
008c				; setup malloc functions  
008c			  
008c				if MALLOC_1  
008c cd 72 14				call  heap_init  
008f				endif  
008f				if MALLOC_4  
008f					call  heap_init  
008f				endif  
008f			  
008f				; init sound hardware if present  
008f			  
008f				if SOUND_ENABLE  
008f					call sound_init  
008f				endif  
008f			  
008f				; lcd test sequence  
008f					  
008f cd be 0d			call update_display  
0092 cd de 0c			call delay1s  
0095 3e 2b			ld a,'+'  
0097 cd a0 0d			call fill_display  
009a cd be 0d			call update_display  
009d cd de 0c			call delay1s  
00a0 3e 2a			ld a,'*'  
00a2 cd a0 0d			call fill_display  
00a5 cd be 0d			call update_display  
00a8 cd de 0c			call delay1s  
00ab 3e 2d			ld a,'-'  
00ad cd a0 0d			call fill_display  
00b0 cd be 0d			call update_display  
00b3 cd de 0c			call delay1s  
00b6			  
00b6			; boot splash screen  
00b6			if display_cols == 20	  
00b6			        ld a, display_row_1    
00b6			else  
00b6 3e 0a		        ld a, display_row_1 +10   
00b8			endif  
00b8 11 08 1c			ld de, prom_bootmsg  
00bb cd ae 0d			call str_at_display  
00be cd be 0d			call update_display  
00c1			  
00c1			  
00c1 cd de 0c			call delay1s  
00c4 cd de 0c			call delay1s  
00c7			if display_cols == 20	  
00c7			            LD   A, display_row_3+2  
00c7			else  
00c7 3e 5c		            LD   A, display_row_3+12  
00c9			endif  
00c9 11 1d 1c			ld de, prom_bootmsg1  
00cc cd ae 0d			call str_at_display  
00cf cd be 0d			call update_display  
00d2 cd de 0c			call delay1s  
00d5 cd de 0c			call delay1s  
00d8			  
00d8			;	ld a, display_row_4+3  
00d8			;	ld de, bootmsg2  
00d8			;	call str_at_display  
00d8			;	call update_display  
00d8			;	call delay1s  
00d8			;	call delay1s  
00d8			  
00d8			; debug mark setup  
00d8			  
00d8 3e 5f		ld a, '_'  
00da 32 68 fe		ld (debug_mark),a  
00dd 32 69 fe		ld (debug_mark+1),a  
00e0 32 6a fe		ld (debug_mark+2),a  
00e3 3e 00		ld a,0  
00e5 32 6b fe		ld (debug_mark+3),a  
00e8			  
00e8 c9					ret  
00e9			  
00e9			  
00e9			;bootmsg2:	db "Firmware v0.1",0  
00e9			  
00e9			; a 4x20 lcd  
00e9			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00e9			  
00e9			;if display_cols == 20  
00e9			;	include "firmware_lcd_4x20.asm"  
00e9			;endif  
00e9			  
00e9			;if display_cols == 40  
00e9			;	include "firmware_lcd_4x40.asm"  
00e9			;endif  
00e9			  
00e9			;  
00e9			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00e9			; TODO abstract the bit bang video out interface for dual display  
00e9			; TODO wire video out to tx pin on rc2014 bus  
00e9			  
00e9			; must supply cin, and cin_wait for low level hardware abstraction   
00e9			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00e9			; test scancode  
00e9			  
00e9			;;;;;  
00e9			;;;  
00e9			; Moved out to mini and maxi versions  
00e9			;  
00e9			; include "firmware_key_4x4.asm"  
00e9			; using existing 4 wire x 4 resistor array for input  
00e9			;include "firmware_key_4x10.asm"  
00e9			; need to mod the board for 5 rows due to resistor array  
00e9			;include "firmware_key_5x10.asm"  
00e9			  
00e9			; storage hardware interface  
00e9			  
00e9			; use microchip serial eeprom for storage  
00e9			  
00e9			  
00e9			if STORAGE_SE  
00e9				include "firmware_spi.asm"  
00e9			; my spi protocol (used by storage) 
00e9			 
00e9			; SPI pins 
00e9			 
00e9			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00e9			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00e9			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00e9			 
00e9			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00e9			; chip pin 4 gnd 
00e9			 
00e9			 
00e9			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00e9			SPI_CE1: equ 1      ;    port a1 pin 14  
00e9			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00e9			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00e9			SPI_CE4: equ 4      ; port a4     pin 10 
00e9			 
00e9			; active low AND masks 
00e9			 
00e9			;SPI_CE0_MASK: equ    255-1 
00e9			;SPI_CE1_MASK: equ   255-2 
00e9			;SPI_CE2_MASK: equ   255-4 
00e9			;SPI_CE3_MASK: equ   255-8 
00e9			;SPI_CE4_MASK: equ   255-16 
00e9			SPI_CE_HIGH:  equ 255 
00e9			 
00e9			 
00e9			 
00e9			;  Perform SCLK wait pulse 
00e9			 
00e9			spi_clk: 
00e9 f5				push af 
00ea 3a 61 fa			ld a, (spi_clktime) 
00ed fe 00			cp 0 
00ef 28 03			jr z, .scskip 
00f1 cd c3 0c			call aDelayInMS 
00f4			.scskip: 
00f4 f1				pop af 
00f5 c9				ret 
00f6			 
00f6			 
00f6			 
00f6			; TODO store port id for spi device ie dev c 
00f6			; TODO store pin for SO 
00f6			; TODO store pin for SI 
00f6			; TODO store pin for SCLK 
00f6			 
00f6			; 
00f6			 
00f6			; ensure that spi bus is in a stable state with default pins  
00f6			 
00f6			se_stable_spi:   
00f6			 
00f6				 ; set DI high, CE high , SCLK low 
00f6				;ld a, SPI_DI | SPI_CE0 
00f6 3e 07			ld a, SPI_DI  
00f8 cd 02 02			call spi_ce_high 
00fb d3 80			 out (storage_adata),a 
00fd 32 5e fa			ld (spi_portbyte),a 
0100			 
0100				if DEBUG_SPI 
0100					push hl 
0100					ld l, a 
0100					DMARK "SPI" 
0100					CALLMONITOR 
0100					pop hl 
0100				endif 
0100 c9				ret 
0101			 
0101			; byte to send in a 
0101			 
0101			spi_send_byte: 
0101				; save byte to send for bit mask shift out 
0101 4f			        ld c,a 
0102 3a 5e fa			ld a,(spi_portbyte) 
0105				  
0105				; clock out	each bit of the byte msb first 
0105			 
0105 06 08			ld b, 8 
0107			.ssb1: 
0107				; clear so bit  
0107 cb bf			res SPI_DI, a 
0109 cb 11			rl c 
010b				; if bit 7 is set then carry is set 
010b 30 02			jr nc, .ssb2 
010d cb ff			set SPI_DI,a 
010f			.ssb2:  ; output bit to ensure it is stable 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112				; clock bit high 
0112 cb ef			set SPI_SCLK,a 
0114 d3 80			out (storage_adata),a 
0116 00				nop 
0117 cd e9 00			call spi_clk 
011a				; then low 
011a cb af			res SPI_SCLK,a 
011c d3 80			out (storage_adata),a 
011e 00				nop 
011f cd e9 00			call spi_clk 
0122 10 e3			djnz .ssb1 
0124			 
0124 32 5e fa			ld (spi_portbyte),a 
0127 c9				ret 
0128			 
0128			; TODO low level get byte into A on spi 
0128			 
0128			spi_read_byte:  
0128			 
0128				; save byte to send for bit mask shift out 
0128 0e 00		    ld c,0 
012a 3a 5e fa			ld a,(spi_portbyte) 
012d				  
012d				; clock out	each bit of the byte msb first 
012d			 
012d			 
012d				; clock bit high 
012d cb ef			set SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132 cd e9 00			call spi_clk 
0135			 
0135			    ; read DO  
0135			 
0135 cb f9		    set 7,c 
0137 db 80			in a,(storage_adata) 
0139 cb 77		    bit SPI_DO,a 
013b 20 02		    jr nz, .b7 
013d cb b9		    res 7,c 
013f			.b7: 
013f				; then low 
013f cb af			res SPI_SCLK,a 
0141 d3 80			out (storage_adata),a 
0143 00				nop 
0144 cd e9 00			call spi_clk 
0147			     
0147			 
0147				; clock bit high 
0147 cb ef			set SPI_SCLK,a 
0149 d3 80			out (storage_adata),a 
014b 00				nop 
014c cd e9 00			call spi_clk 
014f			 
014f			    ; read DO  
014f			 
014f cb f1		    set 6,c 
0151 db 80			in a,(storage_adata) 
0153 cb 77		    bit SPI_DO,a 
0155 20 02		    jr nz, .b6 
0157 cb b1		    res 6,c 
0159			.b6: 
0159				; then low 
0159 cb af			res SPI_SCLK,a 
015b d3 80			out (storage_adata),a 
015d 00				nop 
015e cd e9 00			call spi_clk 
0161			 
0161				; clock bit high 
0161 cb ef			set SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165 00				nop 
0166 cd e9 00			call spi_clk 
0169			 
0169			 
0169			    ; read DO  
0169			 
0169 cb e9		    set 5,c 
016b db 80			in a,(storage_adata) 
016d cb 77		    bit SPI_DO,a 
016f 20 02		    jr nz, .b5 
0171 cb a9		    res 5,c 
0173			.b5: 
0173				; then low 
0173 cb af			res SPI_SCLK,a 
0175 d3 80			out (storage_adata),a 
0177 00				nop 
0178 cd e9 00			call spi_clk 
017b				; clock bit high 
017b cb ef			set SPI_SCLK,a 
017d d3 80			out (storage_adata),a 
017f 00				nop 
0180 cd e9 00			call spi_clk 
0183			 
0183			    ; read DO  
0183			 
0183 cb e1		    set 4,c 
0185 db 80			in a,(storage_adata) 
0187 cb 77		    bit SPI_DO,a 
0189 20 02		    jr nz, .b4 
018b cb a1		    res 4,c 
018d			.b4: 
018d				; then low 
018d cb af			res SPI_SCLK,a 
018f d3 80			out (storage_adata),a 
0191 00				nop 
0192 cd e9 00			call spi_clk 
0195				; clock bit high 
0195 cb ef			set SPI_SCLK,a 
0197 d3 80			out (storage_adata),a 
0199 00				nop 
019a cd e9 00			call spi_clk 
019d			 
019d			    ; read DO  
019d			 
019d cb d9		    set 3,c 
019f db 80			in a,(storage_adata) 
01a1 cb 77		    bit SPI_DO,a 
01a3 20 02		    jr nz, .b3 
01a5 cb 99		    res 3,c 
01a7			.b3: 
01a7				; then low 
01a7 cb af			res SPI_SCLK,a 
01a9 d3 80			out (storage_adata),a 
01ab 00				nop 
01ac cd e9 00			call spi_clk 
01af				; clock bit high 
01af cb ef			set SPI_SCLK,a 
01b1 d3 80			out (storage_adata),a 
01b3 00				nop 
01b4 cd e9 00			call spi_clk 
01b7			 
01b7			    ; read DO  
01b7			 
01b7 cb d1		    set 2,c 
01b9 db 80			in a,(storage_adata) 
01bb cb 77		    bit SPI_DO,a 
01bd 20 02		    jr nz, .b2 
01bf cb 91		    res 2,c 
01c1			.b2: 
01c1				; then low 
01c1 cb af			res SPI_SCLK,a 
01c3 d3 80			out (storage_adata),a 
01c5 00				nop 
01c6 cd e9 00			call spi_clk 
01c9				; clock bit high 
01c9 cb ef			set SPI_SCLK,a 
01cb d3 80			out (storage_adata),a 
01cd 00				nop 
01ce cd e9 00			call spi_clk 
01d1			 
01d1			    ; read DO  
01d1			 
01d1 cb c9		    set 1,c 
01d3 db 80			in a,(storage_adata) 
01d5 cb 77		    bit SPI_DO,a 
01d7 20 02		    jr nz, .b1 
01d9 cb 89		    res 1,c 
01db			.b1: 
01db				; then low 
01db cb af			res SPI_SCLK,a 
01dd d3 80			out (storage_adata),a 
01df 00				nop 
01e0 cd e9 00			call spi_clk 
01e3				; clock bit high 
01e3 cb ef			set SPI_SCLK,a 
01e5 d3 80			out (storage_adata),a 
01e7 00				nop 
01e8 cd e9 00			call spi_clk 
01eb			 
01eb			    ; read DO  
01eb			 
01eb cb c1		    set 0,c 
01ed db 80			in a,(storage_adata) 
01ef cb 77		    bit SPI_DO,a 
01f1 20 02		    jr nz, .b0 
01f3 cb 81		    res 0,c 
01f5			.b0: 
01f5				; then low 
01f5 cb af			res SPI_SCLK,a 
01f7 d3 80			out (storage_adata),a 
01f9 00				nop 
01fa cd e9 00			call spi_clk 
01fd			 
01fd			 
01fd 32 5e fa			ld (spi_portbyte),a 
0200			 
0200			    ; return byte 
0200 79			    ld a,c 
0201			 
0201			 
0201 c9				ret 
0202			 
0202			 
0202			 
0202			spi_ce_high: 
0202			 
0202				if DEBUG_SPI_HARD_CE0 
0202			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202					ret 
0202			 
0202				endif 
0202			 
0202			 
0202 f5				push af 
0203			 
0203				; send direct ce to port b 
0203 3e ff			ld a, 255 
0205 d3 81			out (storage_bdata), a 
0207			 
0207 f1				pop af 
0208			 
0208				; for port a that shares with spi lines AND the mask 
0208			  
0208				if DEBUG_SPI 
0208					push hl 
0208					ld h, a 
0208				endif 
0208			;	ld c, SPI_CE_HIGH 
0208			;	and c 
0208 cb c7			set SPI_CE0, a 
020a cb cf			set SPI_CE1, a 
020c cb d7			set SPI_CE2, a 
020e cb df			set SPI_CE3, a 
0210 cb e7			set SPI_CE4, a 
0212			 
0212				if DEBUG_SPI 
0212					ld l, a 
0212					DMARK "CEh" 
0212					CALLMONITOR 
0212					pop hl 
0212				endif 
0212 c9				ret 
0213			 
0213			 
0213			spi_ce_low: 
0213			 
0213				if DEBUG_SPI_HARD_CE0 
0213			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0213					ret 
0213			 
0213				endif 
0213			 
0213 c5				push bc 
0214 f5				push af 
0215			 
0215				; send direct ce to port b 
0215 3a 60 fa			ld a, (spi_cartdev) 
0218 d3 81			out (storage_bdata), a 
021a			 
021a			 
021a			 
021a				; for port a that shares with spi lines AND the mask 
021a			 
021a 3a 5d fa			ld a, (spi_device)  
021d 4f				ld c, a 
021e			 
021e f1				pop af 
021f			 
021f				; detect CEx 
021f			 
021f				if DEBUG_SPI 
021f					push hl 
021f					ld h, a 
021f				endif 
021f			 
021f cb 41			bit SPI_CE0, c 
0221 20 04			jr nz, .cel1 
0223 cb 87			res SPI_CE0, a 
0225 18 1e			jr .celn 
0227			.cel1: 
0227 cb 49			bit SPI_CE1, c 
0229 20 04			jr nz, .cel2 
022b cb 8f			res SPI_CE1, a 
022d 18 16			jr .celn 
022f			.cel2: 
022f cb 51			bit SPI_CE2, c 
0231 20 04			jr nz, .cel3 
0233 cb 97			res SPI_CE2, a 
0235 18 0e			jr .celn 
0237			.cel3: 
0237 cb 59			bit SPI_CE3, c 
0239 20 04			jr nz, .cel4 
023b cb 9f			res SPI_CE3, a 
023d 18 06			jr .celn 
023f			.cel4: 
023f cb 61			bit SPI_CE4, c 
0241 20 02			jr nz, .celn 
0243 cb a7			res SPI_CE4, a 
0245			.celn: 
0245			 
0245			 
0245			 
0245			;	add c 
0245			 
0245				if DEBUG_SPI 
0245					ld l, a 
0245					DMARK "CEl" 
0245					CALLMONITOR 
0245					pop hl 
0245				endif 
0245 c1				pop bc 
0246 c9				ret 
0247			 
0247			 
0247			 
0247			; eof 
0247			 
0247			 
0247			 
0247			 
0247			 
# End of file firmware_spi.asm
0247				include "firmware_seeprom.asm"  
0247			; 
0247			; persisent storage interface via microchip serial eeprom 
0247			 
0247			; port a pio 2 
0247			; pa 7 - si 
0247			; pa 6 - sclk  
0247			; pa 5 - so 
0247			; pa 4 - cs 
0247			; pa 3 - cs 
0247			; pa 2 - cs 
0247			; pa 1 - cs 
0247			; pa 0 - cs 
0247			; 
0247			; TODO get block 
0247			; TODO save block 
0247			; TODO load file 
0247			; TODO save file 
0247			; TODO get dir  
0247			 
0247			;  
0247			storage_adata: equ Device_C    ; device c port a - onboard storage 
0247			storage_actl: equ Device_C+2     ; device c port a 
0247			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0247			storage_bctl: equ Device_C+3     ; device c port b 
0247			 
0247			 
0247			; TODO move these to hardware driver file 
0247			 
0247			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0247			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0247			; storage bank file system format 
0247			; 
0247			; first page of bank: 
0247			; 	addr 0 - status check 
0247			;       addr 1 - write protect flag 
0247			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0247			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0247			;         TODO see if scanning whole of for available next file id is fast enough 
0247			;	addr 4 > zero term string of bank label 
0247			; 
0247			;        
0247			;  
0247			; first page of any file: 
0247			;      byte 0 - file id  
0247			;      byte 1-17 - fixed file name  
0247			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0247			; 
0247			; other pages of any file: 
0247			;      byte 0 - file id 
0247			;      byte 1> - file data 
0247			; 
0247			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0247			;  
0247			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0247			 
0247			 
0247			;storage_so_bit: 5 
0247			;storage_si_bit: 7 
0247			;storage_sclk_bit: 6 
0247			  
0247			 
0247			; init storage pio 
0247			 
0247			storage_init: 
0247			 
0247			 
0247					; set default SPI clk pulse time as disabled 
0247			 
0247 3e 00				ld a, 0 
0249 32 61 fa				ld (spi_clktime), a 
024c			 
024c					; init hardware 
024c			 
024c 3e cf		            LD   A, 11001111b 
024e d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0250 3e 00		            LD   A, 00000000b 
0252 cb f7			set SPI_DO,a 
0254			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0254 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0256			 
0256 3e cf		            LD   A, 11001111b 
0258 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025a 3e 00		            LD   A, 00000000b 
025c d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025e			 
025e				; set all external spi devices off  
025e 3e ff			ld a, 255 
0260 32 5d fa			ld (spi_device), a 
0263 32 60 fa			ld (spi_cartdev), a 
0266			 
0266					; ensure the spi bus is in a default stable state 
0266 cd f6 00				call se_stable_spi 
0269			 
0269			; TODO scan spi bus and gather which storage banks are present 
0269			 
0269			; populate store_bank_active  
0269			; for each ce line activate and attempt to write first byte of bank and read back 
0269			; if zero is returned then bank is empty 
0269			;   
0269			; 
0269			 
0269					; init file extent cache to save on slow reads 
0269			 
0269			;	ld hl, store_filecache 
0269			;	ld de, 0 
0269			;	ld hl,(de)	 
0269			 
0269			 
0269 c9			    ret 
026a			 
026a			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026a			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026a			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026a			 
026a			; INSTRUCTION SET 
026a			; READ 0000 0011 Read data from memory array beginning at selected address 
026a			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026a			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026a			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026a			; RDSR 0000 0101 Read STATUS register 
026a			; WRSR 0000 0001 Write STATUS register 
026a			; PE 0100 0010 Page Erase – erase one page in memory array 
026a			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026a			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026a			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026a			 
026a			; TODO send byte steam for page without setting the address for every single byte 
026a			; TODO read byte  
026a			 
026a			; byte in a 
026a			; address in hl  
026a			se_writebyte: 
026a			        
026a			    ;   ld c, a 
026a f5			        push af 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a 5e fa		       ld a,(spi_portbyte) 
026f cd 13 02			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 5e fa		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd 01 01		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a 5e fa		       ld a,(spi_portbyte) 
027f cd 02 02			call spi_ce_high 
0282			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 5e fa		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a 5e fa		       ld a,(spi_portbyte) 
028b cd 13 02			call spi_ce_low 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e d3 80		       out (storage_adata),a 
0290 32 5e fa		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd 01 01		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd 01 01		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd 01 01		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 f1			    pop af 
02a2 cd 01 01		    call spi_send_byte  
02a5			 
02a5			    ; end write with ce high 
02a5 3a 5e fa		       ld a,(spi_portbyte) 
02a8			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a8 cd 02 02			call spi_ce_high 
02ab d3 80		       out (storage_adata),a 
02ad 32 5e fa		       ld (spi_portbyte), a 
02b0			 
02b0				; pause for internal write cycle 
02b0 3e 0a			ld a, 10 
02b2 cd c3 0c			call aDelayInMS 
02b5 c9			    ret 
02b6			 
02b6			; buffer to write in de 
02b6			; address in hl  
02b6			se_writepage: 
02b6			        
02b6			    ;   ld c, a 
02b6 d5				push de 
02b7 e5			        push hl 
02b8			 
02b8			    ; initi write mode 
02b8			    ; 
02b8			    ;CS low 
02b8			 
02b8 3a 5e fa		       ld a,(spi_portbyte) 
02bb cd 13 02			call spi_ce_low 
02be			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02be d3 80		       out (storage_adata),a 
02c0 32 5e fa		       ld (spi_portbyte), a 
02c3			 
02c3			    ;clock out wren instruction 
02c3			 
02c3 3e 06		    ld a, store_wren_ins 
02c5 cd 01 01		    call spi_send_byte  
02c8			 
02c8			    ;cs high to enable write latch 
02c8			 
02c8 3a 5e fa		       ld a,(spi_portbyte) 
02cb cd 02 02			call spi_ce_high 
02ce			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ce d3 80		       out (storage_adata),a 
02d0 32 5e fa		       ld (spi_portbyte), a 
02d3			 
02d3 00				nop 
02d4			    ; 
02d4			    ; intial write data 
02d4			    ; 
02d4			    ; cs low 
02d4			     
02d4 3a 5e fa		       ld a,(spi_portbyte) 
02d7			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d7 cd 13 02			call spi_ce_low 
02da d3 80		       out (storage_adata),a 
02dc 32 5e fa		       ld (spi_portbyte), a 
02df			 
02df			    ; clock out write instruction 
02df			     
02df 3e 02		    ld a, store_write_ins  
02e1 cd 01 01		    call spi_send_byte  
02e4			 
02e4			    ; clock out address (depending on address size) 
02e4			     
02e4 e1			    pop hl 
02e5 7c			    ld a,h    ; address out msb first 
02e6 cd 01 01		    call spi_send_byte  
02e9 7d			    ld a,l 
02ea cd 01 01		    call spi_send_byte  
02ed			 
02ed			    ; clock out byte(s) for page 
02ed			 
02ed e1				pop hl 
02ee 06 40			ld b, STORE_BLOCK_PHY 
02f0			.bytewrite: 
02f0			 
02f0 7e				ld a,(hl) 
02f1 e5			    push hl 
02f2 c5				push bc 
02f3 cd 01 01		    call spi_send_byte  
02f6 c1				pop bc 
02f7 e1				pop hl 
02f8			 
02f8			    ; end write with ce high 
02f8 3a 5e fa		       ld a,(spi_portbyte) 
02fb cd 02 02			call spi_ce_high 
02fe			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02fe d3 80		       out (storage_adata),a 
0300 32 5e fa		       ld (spi_portbyte), a 
0303			 
0303 23				inc hl 
0304 10 ea			djnz .bytewrite 
0306			 
0306				; pause for internal write cycle 
0306 3e 64			ld a, 100 
0308 cd c3 0c			call aDelayInMS 
030b c9			    ret 
030c			; returns byte in a 
030c			; address in hl  
030c			se_readbyte: 
030c d5				push de 
030d c5				push bc 
030e			 
030e			    ;   ld c, a 
030e e5			        push hl 
030f			 
030f			    ; initi write mode 
030f			    ; 
030f			    ;CS low 
030f			 
030f 3a 5e fa		       ld a,(spi_portbyte) 
0312 cd 13 02			call spi_ce_low 
0315			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0315 d3 80		       out (storage_adata),a 
0317 32 5e fa		       ld (spi_portbyte), a 
031a			 
031a			    ;clock out wren instruction 
031a			 
031a 3e 03		    ld a, store_read_ins 
031c cd 01 01		    call spi_send_byte  
031f			 
031f			 
031f			    ; clock out address (depending on address size) 
031f			     
031f e1			    pop hl 
0320 7c			    ld a,h    ; address out msb first 
0321 cd 01 01		    call spi_send_byte  
0324 7d			    ld a,l 
0325 cd 01 01		    call spi_send_byte  
0328			 
0328			    ; clock in byte(s) for page 
0328			 
0328 cd 28 01		    call spi_read_byte  
032b f5				push af 
032c			 
032c			    ; end write with ce high 
032c 3a 5e fa		       ld a,(spi_portbyte) 
032f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
032f cd 02 02			call spi_ce_high 
0332 d3 80		       out (storage_adata),a 
0334 32 5e fa		       ld (spi_portbyte), a 
0337			 
0337 f1				pop af 
0338			 
0338 c1				pop bc 
0339 d1				pop de 
033a			 
033a c9			    ret 
033b			 
033b			if DEBUG_STORESE 
033b			 
033b			storageput:  
033b			 
033b			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033b			 
033b 21 c0 f1			ld hl,scratch+2 
033e cd 86 13			call get_word_hl 
0341			 
0341				; stuff it here for the moment as it will be overwritten later anyway 
0341			 
0341 22 e1 f4			ld (os_cur_ptr),hl	 
0344			 
0344			 
0344			; get pointer to start of string 
0344			 
0344 21 c5 f1			ld hl, scratch+7 
0347			 
0347			; loop writing char of string to eeprom 
0347			 
0347 7e			.writestr:	ld a,(hl) 
0348 fe 00				cp 0 
034a 28 12				jr z, .wsdone		; done writing 
034c e5					push hl 
034d 2a e1 f4				ld hl,(os_cur_ptr) 
0350 cd 6a 02				call se_writebyte 
0353			 
0353 2a e1 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0356 23					inc hl 
0357 22 e1 f4				ld (os_cur_ptr),hl 
035a			 
035a					; restore string pointer and get next char 
035a			 
035a e1					pop hl 
035b 23					inc hl 
035c 18 e9				jr .writestr 
035e			 
035e			 
035e			 
035e			.wsdone: 
035e			 
035e			 
035e			; when done load first page into a buffer  
035e			 
035e 21 00 80				ld hl,08000h		; start in ram 
0361 22 e1 f4				ld (os_cur_ptr),hl 
0364 21 00 00				ld hl, 0		 ; start of page 
0367 22 e6 f1				ld (scratch+40),hl	; hang on to it 
036a			 
036a 06 80				ld b, 128		; actually get more then one page 
036c c5			.wsload:	push bc 
036d 2a e6 f1				ld hl,(scratch+40) 
0370 e5					push hl 
0371 cd 0c 03				call se_readbyte 
0374			 
0374					; a now as the byte 
0374			 
0374 2a e1 f4				ld hl,(os_cur_ptr) 
0377 77					ld (hl),a 
0378					; inc next buffer area 
0378 23					inc hl 
0379 22 e1 f4				ld (os_cur_ptr),hl 
037c			 
037c					; get eeprom position, inc and save for next round 
037c e1					pop hl		 
037d 23					inc hl 
037e 22 e6 f1				ld (scratch+40),hl 
0381 c1					pop bc 
0382 10 e8				djnz .wsload 
0384			 
0384			; set 'd' pointer to start of buffer 
0384			 
0384 21 00 80				ld hl,08000h 
0387 22 e1 f4				ld (os_cur_ptr),hl 
038a			 
038a			 
038a c9			ret 
038b			 
038b			 
038b c9			storageread: ret 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			endif 
038c			 
038c			 
038c			 
# End of file firmware_seeprom.asm
038c			else  
038c			   ; create some stubs for the labels  
038c			se_readbyte: ret  
038c			se_writebyte: ret  
038c			storage_init: ret  
038c			  
038c			endif  
038c			  
038c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038c			;include "firmware_cf.asm"  
038c			  
038c			; load up high level storage hardward abstractions  
038c			include "firmware_storage.asm"  
038c			 
038c			; persisent storage hardware abstraction layer  
038c			 
038c			 
038c			 
038c			; Block 0 on storage is a config state 
038c			 
038c			 
038c			 
038c			; TODO add read phy block and write phy block functions 
038c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038c			 
038c			; Abstraction layer  
038c			 
038c			; Logocial block size is same size as physical size - using tape concept 
038c			 
038c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038c			 
038c			 
038c			 
038c			; Filesystem layout (Logical layout) 
038c			; 
038c			; Block 0 - Bank config  
038c			; 
038c			;      Byte - 0 file id counter 
038c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038c			;      Byte - 3-20 zero terminated bank label 
038c			; 
038c			; Block 1 > File storage 
038c			; 
038c			;      Byte 0 file id    - block 0 file details 
038c			;      Byte 1 block id - block 0 is file  
038c			;            Byte 2-15 - File name 
038c			; 
038c			;       - to end of block data 
038c			; 
038c			 
038c			; Get ID for the file named in pointer held HL 
038c			; Returns ID in HL = 255 if no file found 
038c			 
038c			storage_getid: 
038c			 
038c 22 70 fa			ld (store_tmp1), hl 
038f			 
038f				if DEBUG_STORESE 
038f					DMARK "SGI" 
038f f5				push af  
0390 3a a4 03			ld a, (.dmark)  
0393 32 68 fe			ld (debug_mark),a  
0396 3a a5 03			ld a, (.dmark+1)  
0399 32 69 fe			ld (debug_mark+1),a  
039c 3a a6 03			ld a, (.dmark+2)  
039f 32 6a fe			ld (debug_mark+2),a  
03a2 18 03			jr .pastdmark  
03a4 ..			.dmark: db "SGI"  
03a7 f1			.pastdmark: pop af  
03a8			endm  
# End of macro DMARK
03a8					CALLMONITOR 
03a8 cd 6c fe			call debug_vector  
03ab				endm  
# End of macro CALLMONITOR
03ab				endif 
03ab				; get block 0 and set counter for number of files to scan 
03ab			 
03ab cd 16 05			call storage_get_block_0 
03ae			 
03ae 3a 77 fa			ld a, (store_page) 
03b1 47				ld b, a 
03b2			 
03b2				; get extent 0 of each file id 
03b2			 
03b2				if DEBUG_STORESE 
03b2					DMARK "SGc" 
03b2 f5				push af  
03b3 3a c7 03			ld a, (.dmark)  
03b6 32 68 fe			ld (debug_mark),a  
03b9 3a c8 03			ld a, (.dmark+1)  
03bc 32 69 fe			ld (debug_mark+1),a  
03bf 3a c9 03			ld a, (.dmark+2)  
03c2 32 6a fe			ld (debug_mark+2),a  
03c5 18 03			jr .pastdmark  
03c7 ..			.dmark: db "SGc"  
03ca f1			.pastdmark: pop af  
03cb			endm  
# End of macro DMARK
03cb					CALLMONITOR 
03cb cd 6c fe			call debug_vector  
03ce				endm  
# End of macro CALLMONITOR
03ce				endif 
03ce 60			.getloop:	ld h, b 
03cf 2e 00				ld l, 0 
03d1 c5					push bc 
03d2			 
03d2 11 77 fa				ld de, store_page 
03d5				if DEBUG_STORESE 
03d5					DMARK "SGr" 
03d5 f5				push af  
03d6 3a ea 03			ld a, (.dmark)  
03d9 32 68 fe			ld (debug_mark),a  
03dc 3a eb 03			ld a, (.dmark+1)  
03df 32 69 fe			ld (debug_mark+1),a  
03e2 3a ec 03			ld a, (.dmark+2)  
03e5 32 6a fe			ld (debug_mark+2),a  
03e8 18 03			jr .pastdmark  
03ea ..			.dmark: db "SGr"  
03ed f1			.pastdmark: pop af  
03ee			endm  
# End of macro DMARK
03ee					CALLMONITOR 
03ee cd 6c fe			call debug_vector  
03f1				endm  
# End of macro CALLMONITOR
03f1				endif 
03f1 cd be 09				call storage_read 
03f4 cd f8 0f				call ishlzero 
03f7 28 2d				jr z, .gap 
03f9					 
03f9					; have a file name read. Is it one we want. 
03f9			 
03f9 2a 70 fa				ld hl, (store_tmp1) 
03fc 11 7a fa				ld de, store_page+3   ; file name 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGc" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 68 fe			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 69 fe			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 6a fe			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGc"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd 6c fe			call debug_vector  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b cd 65 14				call strcmp 
041e 20 06				jr nz, .gap   ; not this one 
0420			 
0420 c1				        pop bc 
0421			 
0421 26 00				ld h, 0 
0423 68					ld l, b 
0424 18 22				jr .getdone 
0426						 
0426			 
0426			 
0426			 
0426			.gap: 
0426				if DEBUG_STORESE 
0426					DMARK "SGg" 
0426 f5				push af  
0427 3a 3b 04			ld a, (.dmark)  
042a 32 68 fe			ld (debug_mark),a  
042d 3a 3c 04			ld a, (.dmark+1)  
0430 32 69 fe			ld (debug_mark+1),a  
0433 3a 3d 04			ld a, (.dmark+2)  
0436 32 6a fe			ld (debug_mark+2),a  
0439 18 03			jr .pastdmark  
043b ..			.dmark: db "SGg"  
043e f1			.pastdmark: pop af  
043f			endm  
# End of macro DMARK
043f					CALLMONITOR 
043f cd 6c fe			call debug_vector  
0442				endm  
# End of macro CALLMONITOR
0442				endif 
0442			 
0442 c1					pop bc 
0443 10 89				djnz .getloop 
0445 21 ff 00				ld hl, 255 
0448			.getdone: 
0448			 
0448				if DEBUG_STORESE 
0448					DMARK "SGe" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 68 fe			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 69 fe			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 6a fe			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SGe"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461					CALLMONITOR 
0461 cd 6c fe			call debug_vector  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464			 
0464 c9				ret 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			; Read Block 
0465			; ---------- 
0465			; 
0465			; With current bank 
0465			;  
0465			; Get block number to read 
0465			; Load physical blocks starting at start block into buffer 
0465			 
0465			; de points to buffer to use 
0465			; hl holds logical block number  
0465			 
0465			storage_read_block: 
0465			 
0465				; TODO bank selection 
0465			 
0465				; for each of the physical blocks read it into the buffer 
0465 06 40			ld b, STORE_BLOCK_PHY 
0467			 
0467				if DEBUG_STORESE 
0467 d5					push de 
0468				endif 
0468				 
0468			.rl1:    
0468			 
0468				; read physical block at hl into de 
0468			        ; increment hl and de to next read position on exit 
0468			 
0468 e5				push hl 
0469 d5				push de	 
046a c5				push bc 
046b			;	if DEBUG_STORESE 
046b			;		push af 
046b			;		ld a, 'R' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b			;		CALLMONITOR 
046b			;	endif 
046b cd 0c 03			call se_readbyte 
046e			;	if DEBUG_STORESE 
046e			;		ld a,(spi_portbyte) 
046e			;		ld l, a 
046e			;		push af 
046e			;		ld a, '1' 
046e			;		ld (debug_mark),a 
046e			;		pop af 
046e			;		CALLMONITOR 
046e			;	endif 
046e c1				pop bc 
046f d1				pop de 
0470 e1				pop hl 
0471 12				ld (de),a 
0472 23				inc hl 
0473 13				inc de 
0474			 
0474			;	if DEBUG_STORESE 
0474			;		push af 
0474			;		ld a, 'r' 
0474			;		ld (debug_mark),a 
0474			;		pop af 
0474			;		CALLMONITOR 
0474			;	endif 
0474			 
0474 10 f2			djnz .rl1 
0476			 
0476				if DEBUG_STORESE 
0476					DMARK "SRB" 
0476 f5				push af  
0477 3a 8b 04			ld a, (.dmark)  
047a 32 68 fe			ld (debug_mark),a  
047d 3a 8c 04			ld a, (.dmark+1)  
0480 32 69 fe			ld (debug_mark+1),a  
0483 3a 8d 04			ld a, (.dmark+2)  
0486 32 6a fe			ld (debug_mark+2),a  
0489 18 03			jr .pastdmark  
048b ..			.dmark: db "SRB"  
048e f1			.pastdmark: pop af  
048f			endm  
# End of macro DMARK
048f d1					pop de 
0490			; 
0490			;		push af 
0490			;		ld a, 'R' 
0490			;		ld (debug_mark),a 
0490			;		pop af 
0490					CALLMONITOR 
0490 cd 6c fe			call debug_vector  
0493				endm  
# End of macro CALLMONITOR
0493				endif 
0493 c9				ret	 
0494				 
0494			 
0494			; File Size 
0494			; --------- 
0494			; 
0494			;   hl file id 
0494			; 
0494			;  returns in hl the number of blocks 
0494			 
0494			storage_file_size: 
0494 5d				ld e, l 
0495 16 00			ld d, 0 
0497 21 40 00			ld hl, STORE_BLOCK_PHY 
049a					if DEBUG_FORTH_WORDS 
049a						DMARK "SIZ" 
049a f5				push af  
049b 3a af 04			ld a, (.dmark)  
049e 32 68 fe			ld (debug_mark),a  
04a1 3a b0 04			ld a, (.dmark+1)  
04a4 32 69 fe			ld (debug_mark+1),a  
04a7 3a b1 04			ld a, (.dmark+2)  
04aa 32 6a fe			ld (debug_mark+2),a  
04ad 18 03			jr .pastdmark  
04af ..			.dmark: db "SIZ"  
04b2 f1			.pastdmark: pop af  
04b3			endm  
# End of macro DMARK
04b3						CALLMONITOR 
04b3 cd 6c fe			call debug_vector  
04b6				endm  
# End of macro CALLMONITOR
04b6					endif 
04b6 cd 98 07			call storage_findnextid 
04b9			 
04b9 cd f8 0f			call ishlzero 
04bc			;	ld a, l 
04bc			;	add h 
04bc			;	cp 0 
04bc c8				ret z			; block not found so EOF 
04bd			 
04bd 11 77 fa			ld de, store_page 
04c0 cd 65 04			call storage_read_block 
04c3			 
04c3 3a 79 fa			ld a, (store_page+2)	 ; get extent count 
04c6 6f				ld l, a 
04c7 26 00			ld h, 0 
04c9 c9			 	ret 
04ca			 
04ca			 
04ca			; Write Block 
04ca			; ----------- 
04ca			; 
04ca			; With current bank 
04ca			;  
04ca			; Get block number to write 
04ca			; Write physical blocks starting at start block from buffer 
04ca			  
04ca			storage_write_block: 
04ca				; TODO bank selection 
04ca			 
04ca				; for each of the physical blocks read it into the buffer 
04ca 06 40			ld b, STORE_BLOCK_PHY 
04cc			 
04cc				if DEBUG_STORESE 
04cc					DMARK "SWB" 
04cc f5				push af  
04cd 3a e1 04			ld a, (.dmark)  
04d0 32 68 fe			ld (debug_mark),a  
04d3 3a e2 04			ld a, (.dmark+1)  
04d6 32 69 fe			ld (debug_mark+1),a  
04d9 3a e3 04			ld a, (.dmark+2)  
04dc 32 6a fe			ld (debug_mark+2),a  
04df 18 03			jr .pastdmark  
04e1 ..			.dmark: db "SWB"  
04e4 f1			.pastdmark: pop af  
04e5			endm  
# End of macro DMARK
04e5			 
04e5					;push af 
04e5					;ld a, 'W' 
04e5					;ld (debug_mark),a 
04e5					;pop af 
04e5					CALLMONITOR 
04e5 cd 6c fe			call debug_vector  
04e8				endm  
# End of macro CALLMONITOR
04e8				endif 
04e8			 
04e8			; might not be working 
04e8			;	call se_writepage 
04e8			 
04e8			;	ret 
04e8			; 
04e8			 
04e8			 
04e8			 
04e8			.wl1:    
04e8			 
04e8				; read physical block at hl into de 
04e8			        ; increment hl and de to next read position on exit 
04e8			 
04e8 e5				push hl 
04e9 d5				push de	 
04ea c5				push bc 
04eb 1a				ld a,(de) 
04ec				;if DEBUG_STORESE 
04ec			;		push af 
04ec			;		ld a, 'W' 
04ec			;		ld (debug_mark),a 
04ec			;		pop af 
04ec			;		CALLMONITOR 
04ec			;	endif 
04ec cd 6a 02			call se_writebyte 
04ef			;	call delay250ms 
04ef 00				nop 
04f0 00				nop 
04f1 00				nop 
04f2			;	if DEBUG_STORESE 
04f2			;		push af 
04f2			;		ld a, 'w' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2			;		CALLMONITOR 
04f2			;	endif 
04f2 c1				pop bc 
04f3 d1				pop de 
04f4 e1				pop hl 
04f5 23				inc hl 
04f6 13				inc de 
04f7			 
04f7			 
04f7 10 ef			djnz .wl1 
04f9			 
04f9				if DEBUG_STORESE 
04f9					DMARK "SW2" 
04f9 f5				push af  
04fa 3a 0e 05			ld a, (.dmark)  
04fd 32 68 fe			ld (debug_mark),a  
0500 3a 0f 05			ld a, (.dmark+1)  
0503 32 69 fe			ld (debug_mark+1),a  
0506 3a 10 05			ld a, (.dmark+2)  
0509 32 6a fe			ld (debug_mark+2),a  
050c 18 03			jr .pastdmark  
050e ..			.dmark: db "SW2"  
0511 f1			.pastdmark: pop af  
0512			endm  
# End of macro DMARK
0512			 
0512					;push af 
0512					;ld a, 'W' 
0512					;ld (debug_mark),a 
0512					;pop af 
0512					CALLMONITOR 
0512 cd 6c fe			call debug_vector  
0515				endm  
# End of macro CALLMONITOR
0515				endif 
0515 c9				ret	 
0516			 
0516			; Init bank 
0516			; --------- 
0516			; 
0516			; With current bank 
0516			; 
0516			; Setup block 0 config 
0516			;     Set 0 file id counter 
0516			;     Set formatted byte pattern 
0516			;     Zero out bank label 
0516			;      
0516			; For every logical block write 0-1 byte as null 
0516			 
0516			storage_get_block_0: 
0516			 
0516				; TODO check presence 
0516			 
0516				; get block 0 config 
0516			 
0516 21 00 00			ld hl, 0 
0519 11 77 fa			ld de, store_page 
051c cd 65 04			call storage_read_block 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB0" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 68 fe			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 69 fe			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 6a fe			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB0"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538 11 77 fa				ld de, store_page 
053b			;		push af 
053b			;		ld a, 'i' 
053b			;		ld (debug_mark),a 
053b			;		pop af 
053b					CALLMONITOR 
053b cd 6c fe			call debug_vector  
053e				endm  
# End of macro CALLMONITOR
053e				endif 
053e			 
053e				; is this area formatted? 
053e			 
053e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053e 2a 78 fa			ld hl, (store_page+1) 
0541 3e 80			ld a,0x80 
0543 bd				cp l 
0544 20 22			jr nz, .ininotformatted 
0546				; do a double check 
0546 3e 27			ld a, 0x27 
0548 bc				cp h 
0549 20 1d			jr nz, .ininotformatted 
054b			 
054b				; formatted then 
054b			 
054b				if DEBUG_STORESE 
054b					DMARK "SB1" 
054b f5				push af  
054c 3a 60 05			ld a, (.dmark)  
054f 32 68 fe			ld (debug_mark),a  
0552 3a 61 05			ld a, (.dmark+1)  
0555 32 69 fe			ld (debug_mark+1),a  
0558 3a 62 05			ld a, (.dmark+2)  
055b 32 6a fe			ld (debug_mark+2),a  
055e 18 03			jr .pastdmark  
0560 ..			.dmark: db "SB1"  
0563 f1			.pastdmark: pop af  
0564			endm  
# End of macro DMARK
0564					;push af 
0564					;ld a, 'I' 
0564					;ld (debug_mark),a 
0564					;pop af 
0564					CALLMONITOR 
0564 cd 6c fe			call debug_vector  
0567				endm  
# End of macro CALLMONITOR
0567				endif 
0567 c9				ret 
0568			 
0568			.ininotformatted: 
0568				; bank not formatted so poke various bits to make sure 
0568			 
0568				if DEBUG_STORESE 
0568					DMARK "SB2" 
0568 f5				push af  
0569 3a 7d 05			ld a, (.dmark)  
056c 32 68 fe			ld (debug_mark),a  
056f 3a 7e 05			ld a, (.dmark+1)  
0572 32 69 fe			ld (debug_mark+1),a  
0575 3a 7f 05			ld a, (.dmark+2)  
0578 32 6a fe			ld (debug_mark+2),a  
057b 18 03			jr .pastdmark  
057d ..			.dmark: db "SB2"  
0580 f1			.pastdmark: pop af  
0581			endm  
# End of macro DMARK
0581					;push af 
0581					;ld a, 'f' 
0581					;ld (debug_mark),a 
0581					;pop af 
0581					CALLMONITOR 
0581 cd 6c fe			call debug_vector  
0584				endm  
# End of macro CALLMONITOR
0584				endif 
0584			 
0584 cd a1 0c			call storage_clear_page 
0587			 
0587 21 77 fa			ld hl, store_page 
058a 3e 00			ld a, 0 
058c				 
058c 77				ld (hl),a   ; reset file counter 
058d			 
058d 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0590 22 78 fa		 	ld (store_page+1), hl	 
0593			 
0593				; set default label 
0593			 
0593 21 2f 06			ld hl, .defaultbanklabl 
0596 11 7a fa		 	ld de, store_page+3 
0599 01 0f 00			ld bc, 15 
059c ed b0			ldir 
059e			 
059e				; Append the current bank id 
059e 21 83 fa			ld hl, store_page+3+9 
05a1 3a 5c fa			ld a, (spi_device_id) 
05a4 77				ld (hl), a 
05a5			 
05a5				; save default page 0 
05a5			 
05a5 21 00 00			ld hl, 0 
05a8 11 77 fa			ld de, store_page 
05ab				if DEBUG_STORESE 
05ab					DMARK "SB3" 
05ab f5				push af  
05ac 3a c0 05			ld a, (.dmark)  
05af 32 68 fe			ld (debug_mark),a  
05b2 3a c1 05			ld a, (.dmark+1)  
05b5 32 69 fe			ld (debug_mark+1),a  
05b8 3a c2 05			ld a, (.dmark+2)  
05bb 32 6a fe			ld (debug_mark+2),a  
05be 18 03			jr .pastdmark  
05c0 ..			.dmark: db "SB3"  
05c3 f1			.pastdmark: pop af  
05c4			endm  
# End of macro DMARK
05c4			;		push af 
05c4			;		ld a, 'F' 
05c4			;		ld (debug_mark),a 
05c4			;		pop af 
05c4					CALLMONITOR 
05c4 cd 6c fe			call debug_vector  
05c7				endm  
# End of macro CALLMONITOR
05c7				endif 
05c7 cd ca 04			call storage_write_block 
05ca				if DEBUG_STORESE 
05ca					DMARK "SB4" 
05ca f5				push af  
05cb 3a df 05			ld a, (.dmark)  
05ce 32 68 fe			ld (debug_mark),a  
05d1 3a e0 05			ld a, (.dmark+1)  
05d4 32 69 fe			ld (debug_mark+1),a  
05d7 3a e1 05			ld a, (.dmark+2)  
05da 32 6a fe			ld (debug_mark+2),a  
05dd 18 03			jr .pastdmark  
05df ..			.dmark: db "SB4"  
05e2 f1			.pastdmark: pop af  
05e3			endm  
# End of macro DMARK
05e3			;		push af 
05e3			;		ld a, '>' 
05e3			;		ld (debug_mark),a 
05e3			;		pop af 
05e3					CALLMONITOR 
05e3 cd 6c fe			call debug_vector  
05e6				endm  
# End of macro CALLMONITOR
05e6				endif 
05e6			 
05e6 00				nop 
05e7 00				nop 
05e8 00				nop 
05e9			 
05e9				; now set 0 in every page to mark as a free block 
05e9			 
05e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05eb 21 40 00			ld hl, STORE_BLOCK_PHY 
05ee			 
05ee 3e 00		.setmark1:   	ld a,0 
05f0 e5					push hl 
05f1 c5					push bc 
05f2 cd 6a 02				call se_writebyte 
05f5 3e 0a			ld a, 10 
05f7 cd c3 0c			call aDelayInMS 
05fa 23				inc hl 
05fb cd 6a 02				call se_writebyte 
05fe 3e 0a			ld a, 10 
0600 cd c3 0c			call aDelayInMS 
0603 2b				dec hl 
0604 c1					pop bc 
0605 e1					pop hl 
0606 3e 40				ld a, STORE_BLOCK_PHY 
0608 cd cf 0f				call addatohl 
060b 10 e1				djnz .setmark1 
060d			 
060d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
060f 3e 00		.setmark2:   	ld a,0 
0611 e5					push hl 
0612 c5					push bc 
0613 cd 6a 02				call se_writebyte 
0616 3e 0a			ld a, 10 
0618 cd c3 0c			call aDelayInMS 
061b 23				inc hl 
061c cd 6a 02				call se_writebyte 
061f 3e 0a			ld a, 10 
0621 cd c3 0c			call aDelayInMS 
0624 2b				dec hl 
0625 c1					pop bc 
0626 e1					pop hl 
0627 3e 40				ld a, STORE_BLOCK_PHY 
0629 cd cf 0f				call addatohl 
062c 10 e1				djnz .setmark2 
062e			 
062e					 
062e			 
062e			 
062e c9				ret 
062f			 
062f			 
062f			 
062f			 
062f .. 00		.defaultbanklabl:   db "BankLabel_",0 
063a			 
063a			 
063a			 
063a			; Label Bank 
063a			; ---------- 
063a			; 
063a			; With current bank 
063a			; Read block 0 
063a			; Set label 
063a			; Write block 0 
063a			 
063a			; label str pointer in hl 
063a			 
063a			storage_label:     
063a			 
063a				if DEBUG_STORESE 
063a					DMARK "LBL" 
063a f5				push af  
063b 3a 4f 06			ld a, (.dmark)  
063e 32 68 fe			ld (debug_mark),a  
0641 3a 50 06			ld a, (.dmark+1)  
0644 32 69 fe			ld (debug_mark+1),a  
0647 3a 51 06			ld a, (.dmark+2)  
064a 32 6a fe			ld (debug_mark+2),a  
064d 18 03			jr .pastdmark  
064f ..			.dmark: db "LBL"  
0652 f1			.pastdmark: pop af  
0653			endm  
# End of macro DMARK
0653					CALLMONITOR 
0653 cd 6c fe			call debug_vector  
0656				endm  
# End of macro CALLMONITOR
0656				endif 
0656			 
0656 e5				push hl 
0657			 
0657 cd 16 05			call storage_get_block_0 
065a			 
065a				; set default label 
065a			 
065a e1				pop hl 
065b			 
065b 11 7a fa		 	ld de, store_page+3 
065e 01 0f 00			ld bc, 15 
0661				if DEBUG_STORESE 
0661					DMARK "LB3" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 68 fe			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 69 fe			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 6a fe			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "LB3"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a					CALLMONITOR 
067a cd 6c fe			call debug_vector  
067d				endm  
# End of macro CALLMONITOR
067d				endif 
067d ed b0			ldir 
067f				; save default page 0 
067f			 
067f 21 00 00			ld hl, 0 
0682 11 77 fa			ld de, store_page 
0685				if DEBUG_STORESE 
0685					DMARK "LBW" 
0685 f5				push af  
0686 3a 9a 06			ld a, (.dmark)  
0689 32 68 fe			ld (debug_mark),a  
068c 3a 9b 06			ld a, (.dmark+1)  
068f 32 69 fe			ld (debug_mark+1),a  
0692 3a 9c 06			ld a, (.dmark+2)  
0695 32 6a fe			ld (debug_mark+2),a  
0698 18 03			jr .pastdmark  
069a ..			.dmark: db "LBW"  
069d f1			.pastdmark: pop af  
069e			endm  
# End of macro DMARK
069e					CALLMONITOR 
069e cd 6c fe			call debug_vector  
06a1				endm  
# End of macro CALLMONITOR
06a1				endif 
06a1 cd ca 04			call storage_write_block 
06a4			 
06a4 c9				ret 
06a5			 
06a5			 
06a5			 
06a5			; Read Block 0 - Config 
06a5			; --------------------- 
06a5			; 
06a5			; With current bank 
06a5			; Call presence test 
06a5			;    If not present format/init bank  
06a5			; Read block 0  
06a5			;  
06a5			 
06a5			 
06a5			; Dir 
06a5			; --- 
06a5			; 
06a5			; With current bank 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block read byte 2 
06a5			;      if first block of file 
06a5			;         Display file name 
06a5			;         Display type flags for file 
06a5			;        
06a5			 
06a5			; moving to words as this requires stack control 
06a5			 
06a5			 
06a5			; Delete File 
06a5			; ----------- 
06a5			; 
06a5			; With current bank 
06a5			; 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block file id 
06a5			;      If first block of file and dont have file id 
06a5			;         if file to delete 
06a5			;         Save file id 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			;      If file id is one saved 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			 
06a5			 
06a5			.se_done: 
06a5 e1				pop hl 
06a6 c9				ret 
06a7			 
06a7			storage_erase: 
06a7			 
06a7				; hl contains the file id 
06a7			 
06a7 5d				ld e, l 
06a8 16 00			ld d, 0 
06aa 21 40 00			ld hl, STORE_BLOCK_PHY 
06ad					if DEBUG_FORTH_WORDS 
06ad						DMARK "ERA" 
06ad f5				push af  
06ae 3a c2 06			ld a, (.dmark)  
06b1 32 68 fe			ld (debug_mark),a  
06b4 3a c3 06			ld a, (.dmark+1)  
06b7 32 69 fe			ld (debug_mark+1),a  
06ba 3a c4 06			ld a, (.dmark+2)  
06bd 32 6a fe			ld (debug_mark+2),a  
06c0 18 03			jr .pastdmark  
06c2 ..			.dmark: db "ERA"  
06c5 f1			.pastdmark: pop af  
06c6			endm  
# End of macro DMARK
06c6						CALLMONITOR 
06c6 cd 6c fe			call debug_vector  
06c9				endm  
# End of macro CALLMONITOR
06c9					endif 
06c9 cd 98 07			call storage_findnextid 
06cc cd f8 0f			call ishlzero 
06cf c8				ret z 
06d0			 
06d0 e5				push hl 
06d1			 
06d1				; TODO check file not found 
06d1			 
06d1 11 77 fa			ld de, store_page 
06d4 cd 65 04			call storage_read_block 
06d7			 
06d7 cd f8 0f			call ishlzero 
06da ca a5 06			jp z,.se_done 
06dd			 
06dd					if DEBUG_FORTH_WORDS 
06dd						DMARK "ER1" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 68 fe			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 69 fe			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 6a fe			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "ER1"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6						CALLMONITOR 
06f6 cd 6c fe			call debug_vector  
06f9				endm  
# End of macro CALLMONITOR
06f9					endif 
06f9 3a 77 fa			ld a, (store_page)	; get file id 
06fc 32 6b fa			ld (store_tmpid), a 
06ff			 
06ff 3a 79 fa			ld a, (store_page+2)    ; get count of extends 
0702 32 6a fa			ld (store_tmpext), a 
0705			 
0705				; wipe file header 
0705			 
0705 e1				pop hl 
0706 3e 00			ld a, 0 
0708 32 77 fa			ld (store_page), a 
070b 32 78 fa			ld (store_page+1),a 
070e 11 77 fa			ld de, store_page 
0711					if DEBUG_FORTH_WORDS 
0711						DMARK "ER2" 
0711 f5				push af  
0712 3a 26 07			ld a, (.dmark)  
0715 32 68 fe			ld (debug_mark),a  
0718 3a 27 07			ld a, (.dmark+1)  
071b 32 69 fe			ld (debug_mark+1),a  
071e 3a 28 07			ld a, (.dmark+2)  
0721 32 6a fe			ld (debug_mark+2),a  
0724 18 03			jr .pastdmark  
0726 ..			.dmark: db "ER2"  
0729 f1			.pastdmark: pop af  
072a			endm  
# End of macro DMARK
072a						CALLMONITOR 
072a cd 6c fe			call debug_vector  
072d				endm  
# End of macro CALLMONITOR
072d					endif 
072d cd ca 04			call storage_write_block 
0730			 
0730			 
0730				; wipe file extents 
0730			 
0730 3a 6a fa			ld a, (store_tmpext) 
0733 47				ld b, a 
0734			 
0734			.eraext:	  
0734 c5				push bc 
0735			 
0735 21 40 00			ld hl, STORE_BLOCK_PHY 
0738 3a 6b fa			ld a,(store_tmpid) 
073b 5f				ld e, a 
073c 50				ld d, b	 
073d					if DEBUG_FORTH_WORDS 
073d						DMARK "ER3" 
073d f5				push af  
073e 3a 52 07			ld a, (.dmark)  
0741 32 68 fe			ld (debug_mark),a  
0744 3a 53 07			ld a, (.dmark+1)  
0747 32 69 fe			ld (debug_mark+1),a  
074a 3a 54 07			ld a, (.dmark+2)  
074d 32 6a fe			ld (debug_mark+2),a  
0750 18 03			jr .pastdmark  
0752 ..			.dmark: db "ER3"  
0755 f1			.pastdmark: pop af  
0756			endm  
# End of macro DMARK
0756						CALLMONITOR 
0756 cd 6c fe			call debug_vector  
0759				endm  
# End of macro CALLMONITOR
0759					endif 
0759 cd 98 07			call storage_findnextid 
075c cd f8 0f			call ishlzero 
075f ca a5 06			jp z,.se_done 
0762			 
0762 e5				push hl 
0763 11 77 fa			ld de, store_page 
0766 cd 65 04			call storage_read_block 
0769			 
0769				; free block	 
0769			 
0769 3e 00			ld a, 0 
076b 32 77 fa			ld (store_page), a 
076e 32 78 fa			ld (store_page+1),a 
0771 11 77 fa			ld de, store_page 
0774 e1				pop hl 
0775					if DEBUG_FORTH_WORDS 
0775						DMARK "ER4" 
0775 f5				push af  
0776 3a 8a 07			ld a, (.dmark)  
0779 32 68 fe			ld (debug_mark),a  
077c 3a 8b 07			ld a, (.dmark+1)  
077f 32 69 fe			ld (debug_mark+1),a  
0782 3a 8c 07			ld a, (.dmark+2)  
0785 32 6a fe			ld (debug_mark+2),a  
0788 18 03			jr .pastdmark  
078a ..			.dmark: db "ER4"  
078d f1			.pastdmark: pop af  
078e			endm  
# End of macro DMARK
078e						CALLMONITOR 
078e cd 6c fe			call debug_vector  
0791				endm  
# End of macro CALLMONITOR
0791					endif 
0791 cd ca 04			call storage_write_block 
0794			 
0794 c1				pop bc 
0795 10 9d			djnz .eraext 
0797			 
0797 c9				ret 
0798			 
0798			 
0798			; Find Free Block 
0798			; --------------- 
0798			; 
0798			; With current bank 
0798			;  
0798			; From given starting logical block 
0798			;    Read block  
0798			;    If no file id 
0798			;         Return block id 
0798			 
0798			 
0798			; hl starting page number 
0798			; hl contains free page number or zero if no pages free 
0798			; e contains the file id to locate 
0798			; d contains the block number 
0798			 
0798			; TODO change to find file id and use zero for free block 
0798			 
0798			storage_findnextid: 
0798			 
0798				; now locate first 0 page to mark as a free block 
0798			 
0798 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079a			;	ld hl, STORE_BLOCK_PHY 
079a			 
079a					if DEBUG_FORTH_WORDS 
079a					DMARK "FNI" 
079a f5				push af  
079b 3a af 07			ld a, (.dmark)  
079e 32 68 fe			ld (debug_mark),a  
07a1 3a b0 07			ld a, (.dmark+1)  
07a4 32 69 fe			ld (debug_mark+1),a  
07a7 3a b1 07			ld a, (.dmark+2)  
07aa 32 6a fe			ld (debug_mark+2),a  
07ad 18 03			jr .pastdmark  
07af ..			.dmark: db "FNI"  
07b2 f1			.pastdmark: pop af  
07b3			endm  
# End of macro DMARK
07b3						CALLMONITOR 
07b3 cd 6c fe			call debug_vector  
07b6				endm  
# End of macro CALLMONITOR
07b6					endif 
07b6			.ff1:   	 
07b6 e5					push hl 
07b7 c5					push bc 
07b8 d5					push de 
07b9 cd 0c 03				call se_readbyte 
07bc 5f					ld e,a 
07bd 23					inc hl 
07be cd 0c 03				call se_readbyte 
07c1 57					ld d, a 
07c2 e1					pop hl 
07c3 e5					push hl 
07c4 cd ed 0f				call cmp16 
07c7 28 49				jr z, .fffound 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc			 
07cc					; is found? 
07cc					;cp e 
07cc					;ret z 
07cc			 
07cc 3e 40				ld a, STORE_BLOCK_PHY 
07ce cd cf 0f				call addatohl 
07d1 10 e3				djnz .ff1 
07d3			 
07d3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d5			.ff2:   	 
07d5			 
07d5 e5					push hl 
07d6 c5					push bc 
07d7 d5					push de 
07d8 cd 0c 03				call se_readbyte 
07db 5f					ld e,a 
07dc 23					inc hl 
07dd cd 0c 03				call se_readbyte 
07e0 57					ld d, a 
07e1			 
07e1 e1					pop hl 
07e2 e5					push hl 
07e3 cd ed 0f				call cmp16 
07e6 28 2a				jr z, .fffound 
07e8			 
07e8 d1					pop de 
07e9 c1					pop bc 
07ea e1					pop hl 
07eb					; is found? 
07eb					;cp e 
07eb					;ret z 
07eb			 
07eb 3e 40				ld a, STORE_BLOCK_PHY 
07ed cd cf 0f				call addatohl 
07f0 10 e3				djnz .ff2 
07f2			 
07f2			 
07f2					if DEBUG_FORTH_WORDS 
07f2					DMARK "FN-" 
07f2 f5				push af  
07f3 3a 07 08			ld a, (.dmark)  
07f6 32 68 fe			ld (debug_mark),a  
07f9 3a 08 08			ld a, (.dmark+1)  
07fc 32 69 fe			ld (debug_mark+1),a  
07ff 3a 09 08			ld a, (.dmark+2)  
0802 32 6a fe			ld (debug_mark+2),a  
0805 18 03			jr .pastdmark  
0807 ..			.dmark: db "FN-"  
080a f1			.pastdmark: pop af  
080b			endm  
# End of macro DMARK
080b					;	push af 
080b					;	ld a, 'n' 
080b					;	ld (debug_mark),a 
080b					;	pop af 
080b						CALLMONITOR 
080b cd 6c fe			call debug_vector  
080e				endm  
# End of macro CALLMONITOR
080e					endif 
080e				; no free marks! 
080e 21 00 00				ld hl, 0 
0811 c9				ret 
0812			.fffound: 
0812				 
0812			 
0812 d1					pop de 
0813 c1					pop bc 
0814 e1					pop hl 
0815					if DEBUG_FORTH_WORDS 
0815					DMARK "FNF" 
0815 f5				push af  
0816 3a 2a 08			ld a, (.dmark)  
0819 32 68 fe			ld (debug_mark),a  
081c 3a 2b 08			ld a, (.dmark+1)  
081f 32 69 fe			ld (debug_mark+1),a  
0822 3a 2c 08			ld a, (.dmark+2)  
0825 32 6a fe			ld (debug_mark+2),a  
0828 18 03			jr .pastdmark  
082a ..			.dmark: db "FNF"  
082d f1			.pastdmark: pop af  
082e			endm  
# End of macro DMARK
082e					;	push af 
082e					;	ld a, 'n' 
082e					;	ld (debug_mark),a 
082e					;	pop af 
082e						CALLMONITOR 
082e cd 6c fe			call debug_vector  
0831				endm  
# End of macro CALLMONITOR
0831					endif 
0831 c9				ret 
0832			 
0832			 
0832			 
0832			; Free Space 
0832			; ---------- 
0832			; 
0832			; With current bank 
0832			; 
0832			; Set block count to zero 
0832			; Starting with first logical block 
0832			;      Find free block  
0832			;      If block id given, increment block count 
0832			; 
0832			;  
0832			 
0832			 
0832			; hl contains count of free blocks 
0832			 
0832			storage_freeblocks: 
0832			 
0832				; now locate first 0 page to mark as a free block 
0832			 
0832 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0834 21 40 00			ld hl, STORE_BLOCK_PHY 
0837 11 00 00			ld de, 0 
083a			 
083a			.fb1:   	 
083a e5					push hl 
083b c5					push bc 
083c d5					push de 
083d cd 0c 03				call se_readbyte 
0840 d1					pop de 
0841 c1					pop bc 
0842 e1					pop hl 
0843			 
0843					; is free? 
0843 fe 00				cp 0 
0845 20 01				jr nz, .ff1cont 
0847 13					inc de 
0848			 
0848			.ff1cont: 
0848			 
0848			 
0848 3e 40				ld a, STORE_BLOCK_PHY 
084a cd cf 0f				call addatohl 
084d 10 eb				djnz .fb1 
084f			 
084f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0851			.fb2:   	 
0851 e5					push hl 
0852 c5					push bc 
0853 d5					push de 
0854 cd 0c 03				call se_readbyte 
0857 d1					pop de 
0858 c1					pop bc 
0859 e1					pop hl 
085a			 
085a					; is free? 
085a fe 00				cp 0 
085c 20 01				jr nz, .ff2cont 
085e 13					inc de 
085f			 
085f			.ff2cont: 
085f			 
085f 3e 40				ld a, STORE_BLOCK_PHY 
0861 cd cf 0f				call addatohl 
0864 10 eb				djnz .fb2 
0866			 
0866 eb				ex de, hl 
0867 c9				ret 
0868			 
0868			; Get File ID 
0868			; ----------- 
0868			; 
0868			; With current bank 
0868			;  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; For each logical block 
0868			;    Read block file id 
0868			;      If first block of file and dont have file id 
0868			;         if file get id and exit 
0868			 
0868			 
0868			 
0868			 
0868			; Create File 
0868			; ----------- 
0868			; 
0868			; With current bank  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; Increment file id number 
0868			; Save Config 
0868			; Find free block 
0868			; Set buffer with file name and file id 
0868			; Write buffer to free block  
0868			 
0868			 
0868			; hl point to file name 
0868			; hl returns file id 
0868			 
0868			; file format: 
0868			; byte 0 - file id 
0868			; byte 1 - extent number 
0868			; byte 2-> data 
0868			 
0868			; format for extent number 0: 
0868			; 
0868			; byte 0 - file id 
0868			; byte 1 - extent 0 
0868			; byte 2 - extent count 
0868			; byte 3 -> file name and meta data 
0868			 
0868			 
0868			storage_create: 
0868				if DEBUG_STORESE 
0868					DMARK "SCR" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 68 fe			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 69 fe			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 6a fe			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SCR"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd 6c fe			call debug_vector  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884			 
0884 e5				push hl		; save file name pointer 
0885			 
0885 cd 16 05			call storage_get_block_0 
0888			 
0888 3a 77 fa			ld a,(store_page)	; get current file id 
088b 3c				inc a 
088c 32 77 fa			ld (store_page),a 
088f				 
088f 32 6b fa			ld (store_tmpid),a			; save id 
0892			 
0892 21 00 00			ld hl, 0 
0895 11 77 fa			ld de, store_page 
0898				if DEBUG_STORESE 
0898					DMARK "SCw" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 68 fe			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 69 fe			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 6a fe			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SCw"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd 6c fe			call debug_vector  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd ca 04			call storage_write_block	 ; save update 
08b7			 
08b7				if DEBUG_STORESE 
08b7 11 77 fa				ld de, store_page 
08ba					DMARK "SCC" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 68 fe			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 69 fe			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 6a fe			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SCC"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd 6c fe			call debug_vector  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6				;  
08d6				 
08d6 21 40 00			ld hl, STORE_BLOCK_PHY 
08d9 11 00 00			ld de, 0 
08dc cd 98 07			call storage_findnextid 
08df			 
08df 22 62 fa			ld (store_tmppageid), hl    ; save page to use  
08e2			 
08e2				; TODO detect 0 = no spare blocks 
08e2			 
08e2				; hl now contains the free page to use for the file header page 
08e2			 
08e2				if DEBUG_STORESE 
08e2				DMARK "SCF" 
08e2 f5				push af  
08e3 3a f7 08			ld a, (.dmark)  
08e6 32 68 fe			ld (debug_mark),a  
08e9 3a f8 08			ld a, (.dmark+1)  
08ec 32 69 fe			ld (debug_mark+1),a  
08ef 3a f9 08			ld a, (.dmark+2)  
08f2 32 6a fe			ld (debug_mark+2),a  
08f5 18 03			jr .pastdmark  
08f7 ..			.dmark: db "SCF"  
08fa f1			.pastdmark: pop af  
08fb			endm  
# End of macro DMARK
08fb					CALLMONITOR 
08fb cd 6c fe			call debug_vector  
08fe				endm  
# End of macro CALLMONITOR
08fe				endif 
08fe			 
08fe 22 62 fa			ld (store_tmppageid), hl 
0901				 
0901 3a 6b fa			ld a,(store_tmpid)    ; get file id 
0904			;	ld a, (store_filecache)			; save to cache 
0904			 
0904 32 77 fa			ld (store_page),a    ; set page id 
0907 3e 00			ld a, 0			 ; extent 0 is file header 
0909 32 78 fa			ld (store_page+1), a   ; set file extent 
090c			 
090c 32 79 fa			ld (store_page+2), a   ; extent count for the file 
090f			 
090f			;	inc hl 		; init block 0 of file 
090f			;	inc hl   		; skip file and extent id 
090f			 ;       ld a, 0 
090f			;	ld (hl),a 
090f			;	ld a, (store_filecache+1)  	; save to cache 
090f			 
090f			;	inc hl    ; file name 
090f				 
090f				 
090f 11 7a fa			ld de, store_page+3    ; get buffer for term string to use as file name 
0912				if DEBUG_STORESE 
0912					DMARK "SCc" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 68 fe			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 69 fe			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 6a fe			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "SCc"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd 6c fe			call debug_vector  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e e1				pop hl    ; get zero term string 
092f e5				push hl 
0930 3e 00			ld a, 0 
0932 cd 38 14			call strlent 
0935 23				inc hl   ; cover zero term 
0936 06 00			ld b,0 
0938 4d				ld c,l 
0939 e1				pop hl 
093a				;ex de, hl 
093a				if DEBUG_STORESE 
093a					DMARK "SCa" 
093a f5				push af  
093b 3a 4f 09			ld a, (.dmark)  
093e 32 68 fe			ld (debug_mark),a  
0941 3a 50 09			ld a, (.dmark+1)  
0944 32 69 fe			ld (debug_mark+1),a  
0947 3a 51 09			ld a, (.dmark+2)  
094a 32 6a fe			ld (debug_mark+2),a  
094d 18 03			jr .pastdmark  
094f ..			.dmark: db "SCa"  
0952 f1			.pastdmark: pop af  
0953			endm  
# End of macro DMARK
0953					;push af 
0953					;ld a, 'a' 
0953					;ld (debug_mark),a 
0953					;pop af 
0953					CALLMONITOR 
0953 cd 6c fe			call debug_vector  
0956				endm  
# End of macro CALLMONITOR
0956				endif 
0956 ed b0			ldir    ; copy zero term string 
0958				if DEBUG_STORESE 
0958					DMARK "SCA" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 68 fe			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 69 fe			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 6a fe			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SCA"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd 6c fe			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974			 
0974				; write file header page 
0974			 
0974 2a 62 fa			ld hl,(store_tmppageid) 
0977 11 77 fa			ld de, store_page 
097a				if DEBUG_STORESE 
097a					DMARK "SCb" 
097a f5				push af  
097b 3a 8f 09			ld a, (.dmark)  
097e 32 68 fe			ld (debug_mark),a  
0981 3a 90 09			ld a, (.dmark+1)  
0984 32 69 fe			ld (debug_mark+1),a  
0987 3a 91 09			ld a, (.dmark+2)  
098a 32 6a fe			ld (debug_mark+2),a  
098d 18 03			jr .pastdmark  
098f ..			.dmark: db "SCb"  
0992 f1			.pastdmark: pop af  
0993			endm  
# End of macro DMARK
0993					;push af 
0993					;ld a, 'b' 
0993					;ld (debug_mark),a 
0993					;pop af 
0993					CALLMONITOR 
0993 cd 6c fe			call debug_vector  
0996				endm  
# End of macro CALLMONITOR
0996				endif 
0996 cd ca 04			call storage_write_block 
0999			 
0999 3a 6b fa			ld a, (store_tmpid) 
099c 6f				ld l, a 
099d 26 00			ld h,0 
099f				if DEBUG_STORESE 
099f					DMARK "SCz" 
099f f5				push af  
09a0 3a b4 09			ld a, (.dmark)  
09a3 32 68 fe			ld (debug_mark),a  
09a6 3a b5 09			ld a, (.dmark+1)  
09a9 32 69 fe			ld (debug_mark+1),a  
09ac 3a b6 09			ld a, (.dmark+2)  
09af 32 6a fe			ld (debug_mark+2),a  
09b2 18 03			jr .pastdmark  
09b4 ..			.dmark: db "SCz"  
09b7 f1			.pastdmark: pop af  
09b8			endm  
# End of macro DMARK
09b8					CALLMONITOR 
09b8 cd 6c fe			call debug_vector  
09bb				endm  
# End of macro CALLMONITOR
09bb				endif 
09bb c9				ret 
09bc				 
09bc			 
09bc			 
09bc			; 
09bc			; Read File 
09bc			; 
09bc			; h - file id to locate 
09bc			; l - extent to locate 
09bc			; de - pointer to string to read into 
09bc			; 
09bc			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bc			 
09bc			.sr_fail: 
09bc d1				pop de 
09bd c9				ret 
09be			 
09be			storage_read: 
09be			 
09be			 
09be d5				push de 
09bf			 
09bf			; TODO BUG the above push is it popped before the RET Z? 
09bf			 
09bf			; TODO how to handle multiple part blocks 
09bf			 
09bf				; locate file extent to read 
09bf			 
09bf 5c				ld e, h 
09c0 55				ld d, l 
09c1			 
09c1			.srext: 
09c1 22 75 fa			ld (store_readptr), hl     ; save the current extent to load 
09c4 ed 53 73 fa		ld (store_readbuf), de     ; save the current buffer to load in to 
09c8			 
09c8 21 40 00			ld hl, STORE_BLOCK_PHY 
09cb				if DEBUG_STORESE 
09cb					DMARK "sre" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 68 fe			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 69 fe			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 6a fe			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "sre"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd 6c fe			call debug_vector  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 98 07			call storage_findnextid 
09ea			 
09ea				if DEBUG_STORESE 
09ea					DMARK "srf" 
09ea f5				push af  
09eb 3a ff 09			ld a, (.dmark)  
09ee 32 68 fe			ld (debug_mark),a  
09f1 3a 00 0a			ld a, (.dmark+1)  
09f4 32 69 fe			ld (debug_mark+1),a  
09f7 3a 01 0a			ld a, (.dmark+2)  
09fa 32 6a fe			ld (debug_mark+2),a  
09fd 18 03			jr .pastdmark  
09ff ..			.dmark: db "srf"  
0a02 f1			.pastdmark: pop af  
0a03			endm  
# End of macro DMARK
0a03					CALLMONITOR 
0a03 cd 6c fe			call debug_vector  
0a06				endm  
# End of macro CALLMONITOR
0a06				endif 
0a06 cd f8 0f			call ishlzero 
0a09			;	ld a, l 
0a09			;	add h 
0a09			;	cp 0 
0a09 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0b			 
0a0b				; save current address for use by higher level words etc 
0a0b			 
0a0b 22 68 fa			ld (store_openaddr),hl 
0a0e			 
0a0e			 
0a0e				; hl contains page number to load 
0a0e d1				pop de   ; get storage 
0a0f ed 53 73 fa		ld (store_readbuf), de     ; current buffer to load in to 
0a13 d5				push de 
0a14				if DEBUG_STORESE 
0a14					DMARK "srg" 
0a14 f5				push af  
0a15 3a 29 0a			ld a, (.dmark)  
0a18 32 68 fe			ld (debug_mark),a  
0a1b 3a 2a 0a			ld a, (.dmark+1)  
0a1e 32 69 fe			ld (debug_mark+1),a  
0a21 3a 2b 0a			ld a, (.dmark+2)  
0a24 32 6a fe			ld (debug_mark+2),a  
0a27 18 03			jr .pastdmark  
0a29 ..			.dmark: db "srg"  
0a2c f1			.pastdmark: pop af  
0a2d			endm  
# End of macro DMARK
0a2d					CALLMONITOR 
0a2d cd 6c fe			call debug_vector  
0a30				endm  
# End of macro CALLMONITOR
0a30				endif 
0a30 cd 65 04			call storage_read_block 
0a33			 
0a33				; if this a continuation read??? 
0a33			 
0a33 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a36			 
0a36 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a38 cd cf 0f			call addatohl 
0a3b 7e				ld a,(hl) 
0a3c fe 00			cp 0 
0a3e 28 02			jr z, .markiscont 
0a40 3e ff			ld a, 255 
0a42			 
0a42			.markiscont: 
0a42 32 6a fa			ld (store_readcont), a 
0a45			 
0a45				if DEBUG_STORESE 
0a45					DMARK "srC" 
0a45 f5				push af  
0a46 3a 5a 0a			ld a, (.dmark)  
0a49 32 68 fe			ld (debug_mark),a  
0a4c 3a 5b 0a			ld a, (.dmark+1)  
0a4f 32 69 fe			ld (debug_mark+1),a  
0a52 3a 5c 0a			ld a, (.dmark+2)  
0a55 32 6a fe			ld (debug_mark+2),a  
0a58 18 03			jr .pastdmark  
0a5a ..			.dmark: db "srC"  
0a5d f1			.pastdmark: pop af  
0a5e			endm  
# End of macro DMARK
0a5e					CALLMONITOR 
0a5e cd 6c fe			call debug_vector  
0a61				endm  
# End of macro CALLMONITOR
0a61				endif 
0a61				; only short reads enabled 
0a61			 
0a61 3a 72 fa			ld a, (store_longread) 
0a64 fe 00			cp 0 
0a66 ca 33 0b			jp z, .readdone 
0a69			 
0a69			; TODO if block has no zeros then need to read next block  
0a69			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a69			; check last byte of physical block. 
0a69			; if not zero then the next block needs to be loaded 
0a69			 
0a69			 
0a69 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6c			 
0a6c 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6e cd cf 0f			call addatohl 
0a71				;dec hl 
0a71 7e				ld a,(hl) 
0a72				if DEBUG_STORESE 
0a72					DMARK "sr?" 
0a72 f5				push af  
0a73 3a 87 0a			ld a, (.dmark)  
0a76 32 68 fe			ld (debug_mark),a  
0a79 3a 88 0a			ld a, (.dmark+1)  
0a7c 32 69 fe			ld (debug_mark+1),a  
0a7f 3a 89 0a			ld a, (.dmark+2)  
0a82 32 6a fe			ld (debug_mark+2),a  
0a85 18 03			jr .pastdmark  
0a87 ..			.dmark: db "sr?"  
0a8a f1			.pastdmark: pop af  
0a8b			endm  
# End of macro DMARK
0a8b					CALLMONITOR 
0a8b cd 6c fe			call debug_vector  
0a8e				endm  
# End of macro CALLMONITOR
0a8e				endif 
0a8e fe 00			cp 0 
0a90 ca 33 0b			jp z, .readdone 
0a93			 
0a93				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a93			 
0a93 23				inc hl 
0a94			 
0a94 22 73 fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a97			 
0a97 ed 5b 75 fa		ld de, (store_readptr)     ; save the current extent to load 
0a9b			 
0a9b eb				ex de, hl 
0a9c			 
0a9c				; next ext 
0a9c			 
0a9c 23				inc hl 
0a9d 22 75 fa			ld  (store_readptr), hl     ; save the current extent to load 
0aa0			 
0aa0				if DEBUG_STORESE 
0aa0					DMARK "sF2" 
0aa0 f5				push af  
0aa1 3a b5 0a			ld a, (.dmark)  
0aa4 32 68 fe			ld (debug_mark),a  
0aa7 3a b6 0a			ld a, (.dmark+1)  
0aaa 32 69 fe			ld (debug_mark+1),a  
0aad 3a b7 0a			ld a, (.dmark+2)  
0ab0 32 6a fe			ld (debug_mark+2),a  
0ab3 18 03			jr .pastdmark  
0ab5 ..			.dmark: db "sF2"  
0ab8 f1			.pastdmark: pop af  
0ab9			endm  
# End of macro DMARK
0ab9					CALLMONITOR 
0ab9 cd 6c fe			call debug_vector  
0abc				endm  
# End of macro CALLMONITOR
0abc				endif 
0abc			 
0abc				; get and load block 
0abc			 
0abc cd 98 07			call storage_findnextid 
0abf			 
0abf				if DEBUG_STORESE 
0abf					DMARK "sf2" 
0abf f5				push af  
0ac0 3a d4 0a			ld a, (.dmark)  
0ac3 32 68 fe			ld (debug_mark),a  
0ac6 3a d5 0a			ld a, (.dmark+1)  
0ac9 32 69 fe			ld (debug_mark+1),a  
0acc 3a d6 0a			ld a, (.dmark+2)  
0acf 32 6a fe			ld (debug_mark+2),a  
0ad2 18 03			jr .pastdmark  
0ad4 ..			.dmark: db "sf2"  
0ad7 f1			.pastdmark: pop af  
0ad8			endm  
# End of macro DMARK
0ad8					CALLMONITOR 
0ad8 cd 6c fe			call debug_vector  
0adb				endm  
# End of macro CALLMONITOR
0adb				endif 
0adb cd f8 0f			call ishlzero 
0ade			;	ld a, l 
0ade			;	add h 
0ade			;	cp 0 
0ade ca bc 09			jp z,.sr_fail			; block not found so EOF 
0ae1				 
0ae1				; save current address for use by higher level words etc 
0ae1			 
0ae1 22 68 fa			ld (store_openaddr),hl 
0ae4			 
0ae4 cd 65 04			call storage_read_block 
0ae7			 
0ae7				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae7				; we need to pull everything back  
0ae7			 
0ae7 ed 5b 73 fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aeb 2a 73 fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aee 23				inc hl 
0aef 23				inc hl     ; skip id and ext 
0af0 01 40 00			ld bc, STORE_BLOCK_PHY 
0af3				if DEBUG_STORESE 
0af3					DMARK "SR<" 
0af3 f5				push af  
0af4 3a 08 0b			ld a, (.dmark)  
0af7 32 68 fe			ld (debug_mark),a  
0afa 3a 09 0b			ld a, (.dmark+1)  
0afd 32 69 fe			ld (debug_mark+1),a  
0b00 3a 0a 0b			ld a, (.dmark+2)  
0b03 32 6a fe			ld (debug_mark+2),a  
0b06 18 03			jr .pastdmark  
0b08 ..			.dmark: db "SR<"  
0b0b f1			.pastdmark: pop af  
0b0c			endm  
# End of macro DMARK
0b0c					CALLMONITOR 
0b0c cd 6c fe			call debug_vector  
0b0f				endm  
# End of macro CALLMONITOR
0b0f				endif 
0b0f ed b0			ldir     ; copy data 
0b11			 
0b11				; move the pointer back and pretend we have a full buffer for next recheck 
0b11			 
0b11 1b				dec de 
0b12 1b				dec de 
0b13			 
0b13			; TODO do pop below now short circuit loop????? 
0b13 c1				pop bc     ; get rid of spare de on stack 
0b14				if DEBUG_STORESE 
0b14					DMARK "SR>" 
0b14 f5				push af  
0b15 3a 29 0b			ld a, (.dmark)  
0b18 32 68 fe			ld (debug_mark),a  
0b1b 3a 2a 0b			ld a, (.dmark+1)  
0b1e 32 69 fe			ld (debug_mark+1),a  
0b21 3a 2b 0b			ld a, (.dmark+2)  
0b24 32 6a fe			ld (debug_mark+2),a  
0b27 18 03			jr .pastdmark  
0b29 ..			.dmark: db "SR>"  
0b2c f1			.pastdmark: pop af  
0b2d			endm  
# End of macro DMARK
0b2d					CALLMONITOR 
0b2d cd 6c fe			call debug_vector  
0b30				endm  
# End of macro CALLMONITOR
0b30				endif 
0b30 c3 c1 09			jp .srext 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			.readdone:		 
0b33 e1				pop hl 		 ; return start of data to show as not EOF 
0b34 23				inc hl   ; past file id 
0b35 23				inc hl   ; past ext 
0b36				if DEBUG_STORESE 
0b36					DMARK "SRe" 
0b36 f5				push af  
0b37 3a 4b 0b			ld a, (.dmark)  
0b3a 32 68 fe			ld (debug_mark),a  
0b3d 3a 4c 0b			ld a, (.dmark+1)  
0b40 32 69 fe			ld (debug_mark+1),a  
0b43 3a 4d 0b			ld a, (.dmark+2)  
0b46 32 6a fe			ld (debug_mark+2),a  
0b49 18 03			jr .pastdmark  
0b4b ..			.dmark: db "SRe"  
0b4e f1			.pastdmark: pop af  
0b4f			endm  
# End of macro DMARK
0b4f					CALLMONITOR 
0b4f cd 6c fe			call debug_vector  
0b52				endm  
# End of macro CALLMONITOR
0b52				endif 
0b52 c9					ret 
0b53			 
0b53			 
0b53			 
0b53			; 
0b53			; Append File 
0b53			; 
0b53			; hl - file id to locate 
0b53			; de - pointer to (multi block) string to write 
0b53			 
0b53			.sa_notfound: 
0b53 d1				pop de 
0b54 c9				ret 
0b55			 
0b55			 
0b55			storage_append: 
0b55				; hl -  file id to append to 
0b55				; de - string to append 
0b55			 
0b55 d5				push de 
0b56				 
0b56				if DEBUG_STORESE 
0b56					DMARK "AP1" 
0b56 f5				push af  
0b57 3a 6b 0b			ld a, (.dmark)  
0b5a 32 68 fe			ld (debug_mark),a  
0b5d 3a 6c 0b			ld a, (.dmark+1)  
0b60 32 69 fe			ld (debug_mark+1),a  
0b63 3a 6d 0b			ld a, (.dmark+2)  
0b66 32 6a fe			ld (debug_mark+2),a  
0b69 18 03			jr .pastdmark  
0b6b ..			.dmark: db "AP1"  
0b6e f1			.pastdmark: pop af  
0b6f			endm  
# End of macro DMARK
0b6f					CALLMONITOR 
0b6f cd 6c fe			call debug_vector  
0b72				endm  
# End of macro CALLMONITOR
0b72				endif 
0b72			 
0b72 7d				ld a, l 
0b73 32 6b fa			ld (store_tmpid), a 
0b76			 
0b76				; get file header  
0b76			 
0b76 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b78 3a 6b fa			ld a, (store_tmpid) 
0b7b 5f				ld e, a 
0b7c			 
0b7c 21 40 00				ld hl, STORE_BLOCK_PHY 
0b7f cd 98 07				call storage_findnextid 
0b82			 
0b82 cd f8 0f			call ishlzero 
0b85 28 cc			jr z, .sa_notfound 
0b87			 
0b87 22 62 fa			ld (store_tmppageid), hl 
0b8a			 
0b8a				; TODO handle file id not found 
0b8a			 
0b8a				if DEBUG_STORESE 
0b8a					DMARK "AP2" 
0b8a f5				push af  
0b8b 3a 9f 0b			ld a, (.dmark)  
0b8e 32 68 fe			ld (debug_mark),a  
0b91 3a a0 0b			ld a, (.dmark+1)  
0b94 32 69 fe			ld (debug_mark+1),a  
0b97 3a a1 0b			ld a, (.dmark+2)  
0b9a 32 6a fe			ld (debug_mark+2),a  
0b9d 18 03			jr .pastdmark  
0b9f ..			.dmark: db "AP2"  
0ba2 f1			.pastdmark: pop af  
0ba3			endm  
# End of macro DMARK
0ba3					CALLMONITOR 
0ba3 cd 6c fe			call debug_vector  
0ba6				endm  
# End of macro CALLMONITOR
0ba6				endif 
0ba6			 
0ba6				; update file extent count 
0ba6			 
0ba6 11 77 fa			ld de, store_page 
0ba9			 
0ba9 cd 65 04			call storage_read_block 
0bac			 
0bac				if DEBUG_STORESE 
0bac					DMARK "AP3" 
0bac f5				push af  
0bad 3a c1 0b			ld a, (.dmark)  
0bb0 32 68 fe			ld (debug_mark),a  
0bb3 3a c2 0b			ld a, (.dmark+1)  
0bb6 32 69 fe			ld (debug_mark+1),a  
0bb9 3a c3 0b			ld a, (.dmark+2)  
0bbc 32 6a fe			ld (debug_mark+2),a  
0bbf 18 03			jr .pastdmark  
0bc1 ..			.dmark: db "AP3"  
0bc4 f1			.pastdmark: pop af  
0bc5			endm  
# End of macro DMARK
0bc5					CALLMONITOR 
0bc5 cd 6c fe			call debug_vector  
0bc8				endm  
# End of macro CALLMONITOR
0bc8				endif 
0bc8			;	ld (store_tmppageid), hl 
0bc8			 
0bc8 3a 79 fa			ld a, (store_page+2) 
0bcb 3c				inc a 
0bcc 32 79 fa			ld (store_page+2), a 
0bcf 32 6a fa			ld (store_tmpext), a 
0bd2				 
0bd2				if DEBUG_STORESE 
0bd2					DMARK "AP3" 
0bd2 f5				push af  
0bd3 3a e7 0b			ld a, (.dmark)  
0bd6 32 68 fe			ld (debug_mark),a  
0bd9 3a e8 0b			ld a, (.dmark+1)  
0bdc 32 69 fe			ld (debug_mark+1),a  
0bdf 3a e9 0b			ld a, (.dmark+2)  
0be2 32 6a fe			ld (debug_mark+2),a  
0be5 18 03			jr .pastdmark  
0be7 ..			.dmark: db "AP3"  
0bea f1			.pastdmark: pop af  
0beb			endm  
# End of macro DMARK
0beb					CALLMONITOR 
0beb cd 6c fe			call debug_vector  
0bee				endm  
# End of macro CALLMONITOR
0bee				endif 
0bee 2a 62 fa			ld hl, (store_tmppageid) 
0bf1 11 77 fa			ld de, store_page 
0bf4 cd ca 04			call storage_write_block 
0bf7			 
0bf7				; find free block 
0bf7			 
0bf7 11 00 00			ld de, 0			 ; file extent to locate 
0bfa			 
0bfa 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfd cd 98 07				call storage_findnextid 
0c00 cd f8 0f			call ishlzero 
0c03 ca 53 0b			jp z, .sa_notfound 
0c06			 
0c06					; TODO handle no space left 
0c06					 
0c06 22 62 fa				ld (store_tmppageid), hl 
0c09			 
0c09				if DEBUG_STORESE 
0c09					DMARK "AP4" 
0c09 f5				push af  
0c0a 3a 1e 0c			ld a, (.dmark)  
0c0d 32 68 fe			ld (debug_mark),a  
0c10 3a 1f 0c			ld a, (.dmark+1)  
0c13 32 69 fe			ld (debug_mark+1),a  
0c16 3a 20 0c			ld a, (.dmark+2)  
0c19 32 6a fe			ld (debug_mark+2),a  
0c1c 18 03			jr .pastdmark  
0c1e ..			.dmark: db "AP4"  
0c21 f1			.pastdmark: pop af  
0c22			endm  
# End of macro DMARK
0c22					CALLMONITOR 
0c22 cd 6c fe			call debug_vector  
0c25				endm  
# End of macro CALLMONITOR
0c25				endif 
0c25					; init the buffer with zeros so we can id if the buffer is full or not 
0c25			 
0c25 e5					push hl 
0c26 c5					push bc 
0c27			 
0c27 21 77 fa				ld hl, store_page 
0c2a 06 40				ld b, STORE_BLOCK_PHY 
0c2c 3e 00				ld a, 0 
0c2e 77			.zeroblock:	ld (hl), a 
0c2f 23					inc hl 
0c30 10 fc				djnz .zeroblock 
0c32			 
0c32 c1					pop bc 
0c33 e1					pop hl 
0c34			 
0c34					; construct block 
0c34			 
0c34 3a 6b fa				ld a, (store_tmpid) 
0c37 32 77 fa				ld (store_page), a   ; file id 
0c3a 3a 6a fa				ld a, (store_tmpext)   ; extent for this block 
0c3d 32 78 fa				ld (store_page+1), a 
0c40			 
0c40 e1					pop hl    ; get string to write 
0c41 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c43 11 79 fa				ld de, store_page+2 
0c46			 
0c46				if DEBUG_STORESE 
0c46					DMARK "AP5" 
0c46 f5				push af  
0c47 3a 5b 0c			ld a, (.dmark)  
0c4a 32 68 fe			ld (debug_mark),a  
0c4d 3a 5c 0c			ld a, (.dmark+1)  
0c50 32 69 fe			ld (debug_mark+1),a  
0c53 3a 5d 0c			ld a, (.dmark+2)  
0c56 32 6a fe			ld (debug_mark+2),a  
0c59 18 03			jr .pastdmark  
0c5b ..			.dmark: db "AP5"  
0c5e f1			.pastdmark: pop af  
0c5f			endm  
# End of macro DMARK
0c5f					CALLMONITOR 
0c5f cd 6c fe			call debug_vector  
0c62				endm  
# End of macro CALLMONITOR
0c62				endif 
0c62			 
0c62			 
0c62			 
0c62					; fill buffer with data until end of string or full block 
0c62			 
0c62 7e			.appd:		ld a, (hl) 
0c63 12					ld (de), a 
0c64 fe 00				cp 0 
0c66 28 04				jr z, .appdone 
0c68 23					inc hl 
0c69 13					inc de 
0c6a 10 f6				djnz .appd 
0c6c			 
0c6c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6d f5					push af   		; save last byte dumped 
0c6e			 
0c6e			 
0c6e 2a 62 fa			ld hl, (store_tmppageid) 
0c71 11 77 fa			ld de, store_page 
0c74				if DEBUG_STORESE 
0c74					DMARK "AP6" 
0c74 f5				push af  
0c75 3a 89 0c			ld a, (.dmark)  
0c78 32 68 fe			ld (debug_mark),a  
0c7b 3a 8a 0c			ld a, (.dmark+1)  
0c7e 32 69 fe			ld (debug_mark+1),a  
0c81 3a 8b 0c			ld a, (.dmark+2)  
0c84 32 6a fe			ld (debug_mark+2),a  
0c87 18 03			jr .pastdmark  
0c89 ..			.dmark: db "AP6"  
0c8c f1			.pastdmark: pop af  
0c8d			endm  
# End of macro DMARK
0c8d					CALLMONITOR 
0c8d cd 6c fe			call debug_vector  
0c90				endm  
# End of macro CALLMONITOR
0c90				endif 
0c90 cd ca 04				call storage_write_block 
0c93			 
0c93			 
0c93				; was that a full block of data written? 
0c93				; any more to write out? 
0c93			 
0c93				; if yes then set vars and jump to start of function again 
0c93			 
0c93 f1					pop af 
0c94 d1					pop de 
0c95			 
0c95 fe 00				cp 0		 ; no, string was fully written 
0c97 c8					ret z 
0c98			 
0c98					; setup vars for next cycle 
0c98			 
0c98 3a 6b fa				ld a, (store_tmpid) 
0c9b 6f					ld l, a 
0c9c 26 00				ld h, 0 
0c9e			 
0c9e c3 55 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			if DEBUG_STORECF 
0ca1			storageput:	 
0ca1					ret 
0ca1			storageread: 
0ca1					ld hl, store_page 
0ca1					ld b, 200 
0ca1					ld a,0 
0ca1			.src:		ld (hl),a 
0ca1					inc hl 
0ca1					djnz .src 
0ca1					 
0ca1			 
0ca1					ld de, 0 
0ca1					ld bc, 1 
0ca1					ld hl, store_page 
0ca1					call cfRead 
0ca1			 
0ca1				call cfGetError 
0ca1				ld hl,scratch 
0ca1				call hexout 
0ca1				ld hl, scratch+2 
0ca1				ld a, 0 
0ca1				ld (hl),a 
0ca1				ld de, scratch 
0ca1				ld a,display_row_1 
0ca1				call str_at_display 
0ca1				call update_display 
0ca1			 
0ca1					ld hl, store_page 
0ca1					ld (os_cur_ptr),hl 
0ca1			 
0ca1					ret 
0ca1			endif 
0ca1			 
0ca1			 
0ca1			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca1			 
0ca1			storage_clear_page: 
0ca1 e5				push hl 
0ca2 d5				push de 
0ca3 c5				push bc 
0ca4 21 77 fa			ld hl, store_page 
0ca7 3e 00			ld a, 0 
0ca9 77				ld (hl), a 
0caa			 
0caa 11 78 fa			ld de, store_page+1 
0cad 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb0			 
0cb0 ed b0			ldir 
0cb2				 
0cb2 c1				pop bc 
0cb3 d1				pop de 
0cb4 e1				pop hl 
0cb5 c9				ret 
0cb6			 
0cb6			; eof 
# End of file firmware_storage.asm
0cb6			  
0cb6			; support routines for above hardware abstraction layer  
0cb6			  
0cb6			include "firmware_general.asm"        ; general support functions  
0cb6			 
0cb6			; word look up 
0cb6			 
0cb6			; in 
0cb6			; a is the index 
0cb6			; hl is pointer start of array 
0cb6			; 
0cb6			; returns 
0cb6			; hl to the word 
0cb6			; 
0cb6			 
0cb6			table_lookup:  
0cb6 d5					push de 
0cb7 eb					ex de, hl 
0cb8			 
0cb8 6f					ld l, a 
0cb9 26 00				ld h, 0 
0cbb 29					add hl, hl 
0cbc 19					add hl, de 
0cbd 7e					ld a, (hl) 
0cbe 23					inc hl 
0cbf 66					ld h,(hl) 
0cc0 6f					ld l, a 
0cc1			 
0cc1 d1					pop de 
0cc2 c9					ret 
0cc3			 
0cc3			; Delay loops 
0cc3			 
0cc3			 
0cc3			 
0cc3			aDelayInMS: 
0cc3 c5				push bc 
0cc4 47				ld b,a 
0cc5			msdelay: 
0cc5 c5				push bc 
0cc6				 
0cc6			 
0cc6 01 41 00			ld bc,041h 
0cc9 cd e1 0c			call delayloop 
0ccc c1				pop bc 
0ccd 05				dec b 
0cce 20 f5			jr nz,msdelay 
0cd0			 
0cd0			;if CPU_CLOCK_8MHZ 
0cd0			;msdelay8: 
0cd0			;	push bc 
0cd0			;	 
0cd0			; 
0cd0			;	ld bc,041h 
0cd0			;	call delayloop 
0cd0			;	pop bc 
0cd0			;	dec b 
0cd0			;	jr nz,msdelay8 
0cd0			;endif 
0cd0			 
0cd0			 
0cd0 c1				pop bc 
0cd1 c9				ret 
0cd2			 
0cd2			 
0cd2			delay250ms: 
0cd2				;push de 
0cd2 01 00 40			ld bc, 04000h 
0cd5 c3 e1 0c			jp delayloop 
0cd8			delay500ms: 
0cd8				;push de 
0cd8 01 00 80			ld bc, 08000h 
0cdb c3 e1 0c			jp delayloop 
0cde			delay1s: 
0cde				;push bc 
0cde			   ; Clobbers A, d and e 
0cde 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce1			delayloop: 
0ce1 c5			    push bc 
0ce2			 
0ce2			if BASE_CPM 
0ce2				ld bc, CPM_DELAY_TUNE 
0ce2			.cpmloop: 
0ce2				push bc 
0ce2			 
0ce2			endif 
0ce2			 
0ce2			 
0ce2			 
0ce2			delayloopi: 
0ce2			;	push bc 
0ce2			;.dl: 
0ce2 cb 47		    bit     0,a    	; 8 
0ce4 cb 47		    bit     0,a    	; 8 
0ce6 cb 47		    bit     0,a    	; 8 
0ce8 e6 ff		    and     255  	; 7 
0cea 0b			    dec     bc      	; 6 
0ceb 79			    ld      a,c     	; 4 
0cec b0			    or      b     	; 4 
0ced c2 e2 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf0			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf0				;pop de 
0cf0			;pop bc 
0cf0			 
0cf0			if BASE_CPM 
0cf0				pop bc 
0cf0				 
0cf0			    dec     bc      	; 6 
0cf0			    ld      a,c     	; 4 
0cf0			    or      b     	; 4 
0cf0			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf0				 
0cf0			 
0cf0			endif 
0cf0			;if CPU_CLOCK_8MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0			 
0cf0			;if CPU_CLOCK_10MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0 c1			    pop bc 
0cf1			 
0cf1 c9				ret 
0cf2			 
0cf2			 
0cf2			 
0cf2			; eof 
# End of file firmware_general.asm
0cf2			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf2			; display routines that use the physical hardware abstraction layer 
0cf2			 
0cf2			 
0cf2			; Display an activity indicator 
0cf2			; Each call returns the new char pointed to in hl 
0cf2			 
0cf2			active: 
0cf2 3a c3 fb			ld a, (display_active) 
0cf5 fe 06			cp 6 
0cf7			 
0cf7 20 02			jr nz, .sne 
0cf9				; gone past the last one reset sequence 
0cf9 3e ff			ld a, 255 
0cfb			 
0cfb			.sne:   
0cfb				; get the next char in seq 
0cfb 3c				inc a 
0cfc 32 c3 fb			ld (display_active), a 
0cff			 
0cff				; look up the string in the table 
0cff 21 16 0d			ld hl, actseq 
0d02 cb 27			sla a 
0d04 cd cf 0f			call addatohl 
0d07 cd 2a 24			call loadwordinhl 
0d0a			 
0d0a				; forth will write the to string when pushing so move from rom to ram 
0d0a			 
0d0a 11 c4 fb			ld de, display_active+1 
0d0d 01 02 00			ld bc, 2 
0d10 ed b0			ldir 
0d12			 
0d12 21 c4 fb			ld hl, display_active+1 
0d15 c9				ret 
0d16				 
0d16				 
0d16			 
0d16			 
0d16			;db "|/-\|-\" 
0d16			 
0d16			actseq: 
0d16			 
0d16 24 0d		dw spin0 
0d18 26 0d		dw spin1 
0d1a 28 0d		dw spin2 
0d1c 2a 0d		dw spin3 
0d1e 28 0d		dw spin2 
0d20 26 0d		dw spin1 
0d22 24 0d		dw spin0 
0d24			 
0d24 .. 00		spin0: db " ", 0 
0d26 .. 00		spin1: db "-", 0 
0d28 .. 00		spin2: db "+", 0 
0d2a .. 00		spin3: db "#", 0 
0d2c			 
0d2c			 
0d2c			; information window 
0d2c			 
0d2c			; pass hl with 1st string to display 
0d2c			; pass de with 2nd string to display 
0d2c			 
0d2c			info_panel: 
0d2c e5				push hl 
0d2d			 
0d2d 2a c9 fb			ld hl, (display_fb_active) 
0d30 e5				push hl    ; future de destination 
0d31 21 ae fd				ld hl, display_fb0 
0d34 22 c9 fb				ld (display_fb_active), hl 
0d37			 
0d37			;	call clear_display 
0d37			 
0d37				if BASE_CPM 
0d37				ld a, '.' 
0d37				else 
0d37 3e a5			ld a, 165 
0d39				endif 
0d39 cd a0 0d			call fill_display 
0d3c			 
0d3c			 
0d3c 3e 55			ld a, display_row_3 + 5 
0d3e cd ae 0d			call str_at_display 
0d41			 
0d41 e1				pop hl 
0d42 d1				pop de 
0d43			 
0d43 e5				push hl 
0d44			 
0d44			 
0d44 3e 2d			ld a, display_row_2 + 5 
0d46 cd ae 0d			call str_at_display 
0d49			 
0d49			 
0d49 cd be 0d			call update_display 
0d4c cd 73 20			call next_page_prompt 
0d4f cd 9b 0d			call clear_display 
0d52			 
0d52				 
0d52 21 0d fd				ld hl, display_fb1 
0d55 22 c9 fb				ld (display_fb_active), hl 
0d58 cd be 0d			call update_display 
0d5b			 
0d5b e1				pop hl 
0d5c			 
0d5c c9				ret 
0d5d			 
0d5d			 
0d5d			 
0d5d			 
0d5d			; TODO windowing? 
0d5d			 
0d5d			; TODO scroll line up 
0d5d			 
0d5d			scroll_up: 
0d5d			 
0d5d e5				push hl 
0d5e d5				push de 
0d5f c5				push bc 
0d60			 
0d60				; get frame buffer  
0d60			 
0d60 2a c9 fb			ld hl, (display_fb_active) 
0d63 e5				push hl    ; future de destination 
0d64			 
0d64 11 28 00			ld  de, display_cols 
0d67 19				add hl, de 
0d68			 
0d68 d1				pop de 
0d69			 
0d69				;ex de, hl 
0d69 01 9f 00			ld bc, display_fb_len -1  
0d6c			;if DEBUG_FORTH_WORDS 
0d6c			;	DMARK "SCL" 
0d6c			;	CALLMONITOR 
0d6c			;endif	 
0d6c ed b0			ldir 
0d6e			 
0d6e				; wipe bottom row 
0d6e			 
0d6e			 
0d6e 2a c9 fb			ld hl, (display_fb_active) 
0d71 11 a0 00			ld de, display_cols*display_rows 
0d74 19				add hl, de 
0d75 06 28			ld b, display_cols 
0d77 3e 20			ld a, ' ' 
0d79			.scwipe: 
0d79 77				ld (hl), a 
0d7a 2b				dec hl 
0d7b 10 fc			djnz .scwipe 
0d7d			 
0d7d				;pop hl 
0d7d			 
0d7d c1				pop bc 
0d7e d1				pop de 
0d7f e1				pop hl 
0d80			 
0d80 c9				ret 
0d81			 
0d81			 
0d81			;scroll_upo: 
0d81			;	ld de, display_row_1 
0d81			 ;	ld hl, display_row_2 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_2 
0d81			 ;	ld hl, display_row_3 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_3 
0d81			 ;	ld hl, display_row_4 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			 
0d81			; TODO clear row 4 
0d81			 
0d81			;	ret 
0d81			 
0d81				 
0d81			scroll_down: 
0d81			 
0d81 e5				push hl 
0d82 d5				push de 
0d83 c5				push bc 
0d84			 
0d84				; get frame buffer  
0d84			 
0d84 2a c9 fb			ld hl, (display_fb_active) 
0d87			 
0d87 11 9f 00			ld de, display_fb_len - 1 
0d8a 19				add hl, de 
0d8b			 
0d8b e5			push hl    ; future de destination 
0d8c			 
0d8c 11 28 00			ld  de, display_cols 
0d8f ed 52			sbc hl, de 
0d91			 
0d91			 
0d91 d1				pop de 
0d92			 
0d92			;	ex de, hl 
0d92 01 9f 00			ld bc, display_fb_len -1  
0d95			 
0d95			 
0d95				 
0d95			 
0d95 ed b0			ldir 
0d97			 
0d97				; wipe bottom row 
0d97			 
0d97			 
0d97			;	ld hl, (display_fb_active) 
0d97			;;	ld de, display_cols*display_rows 
0d97			;;	add hl, de 
0d97			;	ld b, display_cols 
0d97			;	ld a, ' ' 
0d97			;.scwiped: 
0d97			;	ld (hl), a 
0d97			;	dec hl 
0d97			;	djnz .scwiped 
0d97			 
0d97				;pop hl 
0d97			 
0d97 c1				pop bc 
0d98 d1				pop de 
0d99 e1				pop hl 
0d9a			 
0d9a c9				ret 
0d9b			;scroll_down: 
0d9b			;	ld de, display_row_4 
0d9b			;	ld hl, display_row_3 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_3 
0d9b			; 	ld hl, display_row_2 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_2 
0d9b			;	ld hl, display_row_1 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;;; TODO clear row 1 
0d9b			;	ret 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			; clear active frame buffer 
0d9b			 
0d9b			clear_display: 
0d9b 3e 20			ld a, ' ' 
0d9d c3 a0 0d			jp fill_display 
0da0			 
0da0			; fill active frame buffer with a char in A 
0da0			 
0da0			fill_display: 
0da0 06 a0			ld b,display_fb_len 
0da2 2a c9 fb			ld hl, (display_fb_active) 
0da5 77			.fd1:	ld (hl),a 
0da6 23				inc hl 
0da7 10 fc			djnz .fd1 
0da9 23				inc hl 
0daa 3e 00			ld a,0 
0dac 77				ld (hl),a 
0dad			 
0dad			 
0dad c9				ret 
0dae			; Write string (DE) at pos (A) to active frame buffer 
0dae			 
0dae 2a c9 fb		str_at_display:    ld hl,(display_fb_active) 
0db1 06 00					ld b,0 
0db3 4f					ld c,a 
0db4 09					add hl,bc 
0db5 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db6 b7			            OR   A              ;Null terminator? 
0db7 c8			            RET  Z              ;Yes, so finished 
0db8 77					ld (hl),a 
0db9 23				inc hl 
0dba 13			            INC  DE             ;Point to next character 
0dbb 18 f8		            JR   .sad1     ;Repeat 
0dbd c9					ret 
0dbe			 
0dbe			; using current frame buffer write to physical display 
0dbe			 
0dbe			update_display: 
0dbe e5				push hl 
0dbf 2a c9 fb			ld hl, (display_fb_active) 
0dc2 cd ed 76			call write_display 
0dc5 e1				pop hl 
0dc6 c9				ret 
0dc7			 
0dc7			; TODO scrolling 
0dc7			 
0dc7			 
0dc7			; move cursor right one char 
0dc7			cursor_right: 
0dc7			 
0dc7				; TODO shift right 
0dc7				; TODO if beyond max col 
0dc7				; TODO       cursor_next_line 
0dc7			 
0dc7 c9				ret 
0dc8			 
0dc8			 
0dc8			cursor_next_line: 
0dc8				; TODO first char 
0dc8				; TODO line down 
0dc8				; TODO if past last row 
0dc8				; TODO    scroll up 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			cursor_left: 
0dc9				; TODO shift left 
0dc9				; TODO if beyond left  
0dc9				; TODO     cursor prev line 
0dc9				 
0dc9 c9				ret 
0dca			 
0dca			cursor_prev_line: 
0dca				; TODO last char 
0dca				; TODO line up 
0dca				; TODO if past first row 
0dca				; TODO   scroll down 
0dca			 
0dca c9				ret 
0dcb			 
0dcb			 
0dcb			cout: 
0dcb				; A - char 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			; Display a menu and allow item selection (optional toggle items) 
0dcc			; 
0dcc			; format: 
0dcc			; hl pointer to word array with zero term for items 
0dcc			; e.g.    db item1 
0dcc			;         db .... 
0dcc			;         db 0 
0dcc			; 
0dcc			; a = starting menu item  
0dcc			; 
0dcc			; de = pointer item toggle array   (todo) 
0dcc			; 
0dcc			; returns item selected in a 1-... 
0dcc			; returns 0 if back button pressed 
0dcc			; 
0dcc			; NOTE: Uses system frame buffer to display 
0dcc			; 
0dcc			; LEFT, Q = go back 
0dcc			; RIGHT, SPACE, CR = select 
0dcc			; UP, A - Up 
0dcc			; DOWN, Z - Down 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			menu: 
0dcc			 
0dcc					; keep array pointer 
0dcc			 
0dcc 22 70 fa				ld (store_tmp1), hl 
0dcf 32 6e fa				ld (store_tmp2), a 
0dd2			 
0dd2					; check for key bounce 
0dd2			 
0dd2			if BASE_KEV 
0dd2			 
0dd2 cd 38 7a		.mbounce:	call cin 
0dd5 fe 00				cp 0 
0dd7 20 f9				jr nz, .mbounce 
0dd9			endif 
0dd9					; for ease use ex 
0dd9			 
0dd9					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dd9 21 ae fd				ld hl, display_fb0 
0ddc 22 c9 fb				ld (display_fb_active), hl 
0ddf			 
0ddf cd 9b 0d		.mloop:		call clear_display 
0de2 cd be 0d				call update_display 
0de5			 
0de5					; draw selection id '>' at 1 
0de5			 
0de5					; init start of list display 
0de5			 
0de5 3e 05				ld a, 5 
0de7 32 6c fa				ld (store_tmp3), a   ; display row count 
0dea 3a 6e fa				ld a,( store_tmp2) 
0ded 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0df0			 
0df0					 
0df0			.mitem:	 
0df0			 
0df0			 
0df0 3a 6f fa				ld a,(store_tmp2+1) 
0df3 6f					ld l, a 
0df4 26 00				ld h, 0 
0df6 29					add hl, hl 
0df7 ed 5b 70 fa			ld de, (store_tmp1) 
0dfb 19					add hl, de 
0dfc 7e					ld a, (hl) 
0dfd 23					inc hl 
0dfe 66					ld h,(hl) 
0dff 6f					ld l, a 
0e00			 
0e00 cd f8 0f				call ishlzero 
0e03 28 1a				jr z, .mdone 
0e05			 
0e05 eb					ex de, hl 
0e06 3a 6c fa				ld a, (store_tmp3) 
0e09 cd ae 0d				call str_at_display 
0e0c					 
0e0c			 
0e0c					; next item 
0e0c 3a 6f fa				ld a, (store_tmp2+1) 
0e0f 3c					inc a 
0e10 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0e13			 
0e13			 		; next row 
0e13			 
0e13 3a 6c fa				ld a, (store_tmp3) 
0e16 c6 28				add display_cols 
0e18 32 6c fa				ld (store_tmp3), a 
0e1b			 
0e1b					; at end of screen? 
0e1b			 
0e1b fe 10				cp display_rows*4 
0e1d 20 d1				jr nz, .mitem 
0e1f			 
0e1f			 
0e1f			.mdone: 
0e1f cd f8 0f				call ishlzero 
0e22 28 08				jr z, .nodn 
0e24			 
0e24 3e 78				ld a, display_row_4 
0e26 11 a5 0e				ld de, .mdown 
0e29 cd ae 0d				call str_at_display 
0e2c			 
0e2c					; draw options to fill the screens with active item on line 1 
0e2c					; if current option is 2 or more then display ^ in top 
0e2c			 
0e2c 3a 6e fa		.nodn:		ld a, (store_tmp2) 
0e2f fe 00				cp 0 
0e31 28 08				jr z, .noup 
0e33			 
0e33 3e 00				ld a, 0 
0e35 11 a3 0e				ld de, .mup 
0e38 cd ae 0d				call str_at_display 
0e3b			 
0e3b 3e 02		.noup:		ld a, 2 
0e3d 11 a1 0e				ld de, .msel 
0e40 cd ae 0d				call str_at_display 
0e43			 
0e43					; if current option + 1 is not null then display V in bottom 
0e43					; get key 
0e43 cd be 0d				call update_display 
0e46			 
0e46			 
0e46					; handle key 
0e46			 
0e46 cd 27 7a				call cin_wait 
0e49			 
0e49 fe 05				cp KEY_UP 
0e4b 28 2b				jr z, .mgoup 
0e4d fe 61				cp 'a' 
0e4f 28 27				jr z, .mgoup 
0e51 fe 0a				cp KEY_DOWN 
0e53 28 32				jr z, .mgod 
0e55 fe 7a				cp 'z' 
0e57 28 2e				jr z, .mgod 
0e59 fe 20				cp ' ' 
0e5b 28 34				jr z, .goend 
0e5d fe 0c				cp KEY_RIGHT 
0e5f 28 30				jr z, .goend 
0e61 fe 0d				cp KEY_CR 
0e63 28 2c				jr z, .goend 
0e65 fe 71				cp 'q' 
0e67 28 0b				jr z, .goback 
0e69			 
0e69 fe 0b				cp KEY_LEFT 
0e6b 28 07				jr z, .goback 
0e6d fe 08				cp KEY_BS 
0e6f 28 03				jr z, .goback 
0e71 c3 df 0d				jp .mloop 
0e74			 
0e74			.goback: 
0e74 3e 00			ld a, 0 
0e76 18 1d			jr .goend2 
0e78			 
0e78				; move up one 
0e78			.mgoup: 
0e78 3a 6e fa				ld a, (store_tmp2) 
0e7b fe 00				cp 0 
0e7d ca df 0d				jp z, .mloop 
0e80 3d					dec a 
0e81 32 6e fa				ld (store_tmp2), a 
0e84 c3 df 0d				jp .mloop 
0e87			 
0e87				; move down one 
0e87			.mgod: 
0e87 3a 6e fa				ld a, (store_tmp2) 
0e8a 3c					inc a 
0e8b 32 6e fa				ld (store_tmp2), a 
0e8e c3 df 0d				jp .mloop 
0e91			 
0e91			 
0e91			.goend: 
0e91					; get selected item number 
0e91			 
0e91 3a 6e fa				ld a, (store_tmp2) 
0e94 3c					inc a 
0e95			 
0e95			.goend2: 
0e95 f5					push af 
0e96			 
0e96					; restore active fb 
0e96					; TODO BUG assumes fb1 
0e96			 
0e96 21 0d fd				ld hl, display_fb1 
0e99 22 c9 fb				ld (display_fb_active), hl 
0e9c			 
0e9c					; restore main regs 
0e9c			 
0e9c			 
0e9c cd be 0d				call update_display 
0e9f			 
0e9f f1					pop af 
0ea0			 
0ea0 c9				ret 
0ea1			 
0ea1 .. 00		.msel:   db ">",0 
0ea3 .. 00		.mup:   db "^",0 
0ea5 .. 00		.mdown:   db "v",0 
0ea7			 
0ea7			 
0ea7			; eof 
0ea7			 
# End of file firmware_display.asm
0ea7			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea7			; random number generators 
0ea7			 
0ea7			 
0ea7			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea7			 
0ea7			 
0ea7			;-----> Generate a random number 
0ea7			; output a=answer 0<=a<=255 
0ea7			; all registers are preserved except: af 
0ea7			random: 
0ea7 e5			        push    hl 
0ea8 d5			        push    de 
0ea9 2a a8 fb		        ld      hl,(randData) 
0eac ed 5f		        ld      a,r 
0eae 57			        ld      d,a 
0eaf 5e			        ld      e,(hl) 
0eb0 19			        add     hl,de 
0eb1 85			        add     a,l 
0eb2 ac			        xor     h 
0eb3 22 a8 fb		        ld      (randData),hl 
0eb6 d1			        pop     de 
0eb7 e1			        pop     hl 
0eb8 c9			        ret 
0eb9			 
0eb9			 
0eb9			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eb9			 
0eb9			 
0eb9			 
0eb9			;------LFSR------ 
0eb9			;James Montelongo 
0eb9			;optimized by Spencer Putt 
0eb9			;out: 
0eb9			; a = 8 bit random number 
0eb9			RandLFSR: 
0eb9 21 ae fb		        ld hl,LFSRSeed+4 
0ebc 5e			        ld e,(hl) 
0ebd 23			        inc hl 
0ebe 56			        ld d,(hl) 
0ebf 23			        inc hl 
0ec0 4e			        ld c,(hl) 
0ec1 23			        inc hl 
0ec2 7e			        ld a,(hl) 
0ec3 47			        ld b,a 
0ec4 cb 13		        rl e  
0ec6 cb 12			rl d 
0ec8 cb 11		        rl c  
0eca 17				rla 
0ecb cb 13		        rl e  
0ecd cb 12			rl d 
0ecf cb 11		        rl c  
0ed1 17				rla 
0ed2 cb 13		        rl e  
0ed4 cb 12			rl d 
0ed6 cb 11		        rl c  
0ed8 17				rla 
0ed9 67			        ld h,a 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 a8			        xor b 
0ee2 cb 13		        rl e  
0ee4 cb 12			rl d 
0ee6 ac			        xor h 
0ee7 a9			        xor c 
0ee8 aa			        xor d 
0ee9 21 b0 fb		        ld hl,LFSRSeed+6 
0eec 11 b1 fb		        ld de,LFSRSeed+7 
0eef 01 07 00		        ld bc,7 
0ef2 ed b8		        lddr 
0ef4 12			        ld (de),a 
0ef5 c9			        ret 
0ef6			 
0ef6			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef6			 
0ef6			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef6			 
0ef6			 
0ef6			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef6			 
0ef6			prng16: 
0ef6			;Inputs: 
0ef6			;   (seed1) contains a 16-bit seed value 
0ef6			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef6			;Outputs: 
0ef6			;   HL is the result 
0ef6			;   BC is the result of the LCG, so not that great of quality 
0ef6			;   DE is preserved 
0ef6			;Destroys: 
0ef6			;   AF 
0ef6			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef6			;160cc 
0ef6			;26 bytes 
0ef6 2a a2 fb		    ld hl,(seed1) 
0ef9 44			    ld b,h 
0efa 4d			    ld c,l 
0efb 29			    add hl,hl 
0efc 29			    add hl,hl 
0efd 2c			    inc l 
0efe 09			    add hl,bc 
0eff 22 a2 fb		    ld (seed1),hl 
0f02 2a a0 fb		    ld hl,(seed2) 
0f05 29			    add hl,hl 
0f06 9f			    sbc a,a 
0f07 e6 2d		    and %00101101 
0f09 ad			    xor l 
0f0a 6f			    ld l,a 
0f0b 22 a0 fb		    ld (seed2),hl 
0f0e 09			    add hl,bc 
0f0f c9			    ret 
0f10			 
0f10			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f10			 
0f10			rand32: 
0f10			;Inputs: 
0f10			;   (seed1_0) holds the lower 16 bits of the first seed 
0f10			;   (seed1_1) holds the upper 16 bits of the first seed 
0f10			;   (seed2_0) holds the lower 16 bits of the second seed 
0f10			;   (seed2_1) holds the upper 16 bits of the second seed 
0f10			;   **NOTE: seed2 must be non-zero 
0f10			;Outputs: 
0f10			;   HL is the result 
0f10			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f10			;Destroys: 
0f10			;   AF 
0f10			;Tested and passes all CAcert tests 
0f10			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f10			;it has a period of 18,446,744,069,414,584,320 
0f10			;roughly 18.4 quintillion. 
0f10			;LFSR taps: 0,2,6,7  = 11000101 
0f10			;291cc 
0f10			;seed1_0=$+1 
0f10			;    ld hl,12345 
0f10			;seed1_1=$+1 
0f10			;    ld de,6789 
0f10			;    ld b,h 
0f10			;    ld c,l 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    inc l 
0f10			;    add hl,bc 
0f10			;    ld (seed1_0),hl 
0f10			;    ld hl,(seed1_1) 
0f10			;    adc hl,de 
0f10			;    ld (seed1_1),hl 
0f10			;    ex de,hl 
0f10			;seed2_0=$+1 
0f10			;    ld hl,9876 
0f10			;seed2_1=$+1 
0f10			;    ld bc,54321 
0f10			;    add hl,hl \ rl c \ rl b 
0f10			;    ld (seed2_1),bc 
0f10			;    sbc a,a 
0f10			;    and %11000101 
0f10			;    xor l 
0f10			;    ld l,a 
0f10			;    ld (seed2_0),hl 
0f10			;    ex de,hl 
0f10			;    add hl,bc 
0f10			;    ret 
0f10			; 
0f10			 
0f10			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f10			; 20 bytes, 86 cycles (excluding ret) 
0f10			 
0f10			; returns   hl = pseudorandom number 
0f10			; corrupts   a 
0f10			 
0f10			; generates 16-bit pseudorandom numbers with a period of 65535 
0f10			; using the xorshift method: 
0f10			 
0f10			; hl ^= hl << 7 
0f10			; hl ^= hl >> 9 
0f10			; hl ^= hl << 8 
0f10			 
0f10			; some alternative shift triplets which also perform well are: 
0f10			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f10			 
0f10			;  org 32768 
0f10			 
0f10			xrnd: 
0f10 2a a6 fb		  ld hl,(xrandc)       ; seed must not be 0 
0f13 3e 00		  ld a,0 
0f15 bd			  cp l 
0f16 20 02		  jr nz, .xrnd1 
0f18 2e 01		  ld l, 1 
0f1a			.xrnd1: 
0f1a			 
0f1a 7c			  ld a,h 
0f1b 1f			  rra 
0f1c 7d			  ld a,l 
0f1d 1f			  rra 
0f1e ac			  xor h 
0f1f 67			  ld h,a 
0f20 7d			  ld a,l 
0f21 1f			  rra 
0f22 7c			  ld a,h 
0f23 1f			  rra 
0f24 ad			  xor l 
0f25 6f			  ld l,a 
0f26 ac			  xor h 
0f27 67			  ld h,a 
0f28			 
0f28 22 a6 fb		  ld (xrandc),hl 
0f2b			 
0f2b c9			  ret 
0f2c			;  
0f2c			 
0f2c			 
0f2c			;;;; int maths 
0f2c			 
0f2c			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2c			; Divide 16-bit values (with 16-bit result) 
0f2c			; In: Divide BC by divider DE 
0f2c			; Out: BC = result, HL = rest 
0f2c			; 
0f2c			Div16: 
0f2c 21 00 00		    ld hl,0 
0f2f 78			    ld a,b 
0f30 06 08		    ld b,8 
0f32			Div16_Loop1: 
0f32 17			    rla 
0f33 ed 6a		    adc hl,hl 
0f35 ed 52		    sbc hl,de 
0f37 30 01		    jr nc,Div16_NoAdd1 
0f39 19			    add hl,de 
0f3a			Div16_NoAdd1: 
0f3a 10 f6		    djnz Div16_Loop1 
0f3c 17			    rla 
0f3d 2f			    cpl 
0f3e 47			    ld b,a 
0f3f 79			    ld a,c 
0f40 48			    ld c,b 
0f41 06 08		    ld b,8 
0f43			Div16_Loop2: 
0f43 17			    rla 
0f44 ed 6a		    adc hl,hl 
0f46 ed 52		    sbc hl,de 
0f48 30 01		    jr nc,Div16_NoAdd2 
0f4a 19			    add hl,de 
0f4b			Div16_NoAdd2: 
0f4b 10 f6		    djnz Div16_Loop2 
0f4d 17			    rla 
0f4e 2f			    cpl 
0f4f 41			    ld b,c 
0f50 4f			    ld c,a 
0f51 c9			ret 
0f52			 
0f52			 
0f52			;http://z80-heaven.wikidot.com/math 
0f52			; 
0f52			;Inputs: 
0f52			;     DE and A are factors 
0f52			;Outputs: 
0f52			;     A is not changed 
0f52			;     B is 0 
0f52			;     C is not changed 
0f52			;     DE is not changed 
0f52			;     HL is the product 
0f52			;Time: 
0f52			;     342+6x 
0f52			; 
0f52			Mult16: 
0f52			 
0f52 06 08		     ld b,8          ;7           7 
0f54 21 00 00		     ld hl,0         ;10         10 
0f57 29			       add hl,hl     ;11*8       88 
0f58 07			       rlca          ;4*8        32 
0f59 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5b 19			         add hl,de   ;--         -- 
0f5c 10 f9		       djnz $-5      ;13*7+8     99 
0f5e c9			ret 
0f5f			 
0f5f			; 
0f5f			; Square root of 16-bit value 
0f5f			; In:  HL = value 
0f5f			; Out:  D = result (rounded down) 
0f5f			; 
0f5f			;Sqr16: 
0f5f			;    ld de,#0040 
0f5f			;    ld a,l 
0f5f			;    ld l,h 
0f5f			;    ld h,d 
0f5f			;    or a 
0f5f			;    ld b,8 
0f5f			;Sqr16_Loop: 
0f5f			;    sbc hl,de 
0f5f			;    jr nc,Sqr16_Skip 
0f5f			;    add hl,de 
0f5f			;Sqr16_Skip: 
0f5f			;    ccf 
0f5f			;    rl d 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    djnz Sqr16_Loop 
0f5f			;    ret 
0f5f			; 
0f5f			; 
0f5f			; Divide 8-bit values 
0f5f			; In: Divide E by divider C 
0f5f			; Out: A = result, B = rest 
0f5f			; 
0f5f			Div8: 
0f5f af			    xor a 
0f60 06 08		    ld b,8 
0f62			Div8_Loop: 
0f62 cb 13		    rl e 
0f64 17			    rla 
0f65 91			    sub c 
0f66 30 01		    jr nc,Div8_NoAdd 
0f68 81			    add a,c 
0f69			Div8_NoAdd: 
0f69 10 f7		    djnz Div8_Loop 
0f6b 47			    ld b,a 
0f6c 7b			    ld a,e 
0f6d 17			    rla 
0f6e 2f			    cpl 
0f6f c9			    ret 
0f70			 
0f70			; 
0f70			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f70			; In: Multiply A with DE 
0f70			; Out: HL = result 
0f70			; 
0f70			Mult12U: 
0f70 2e 00		    ld l,0 
0f72 87			    add a,a 
0f73 30 01		    jr nc,Mult12U_NoAdd0 
0f75 19			    add hl,de 
0f76			Mult12U_NoAdd0: 
0f76 29			    add hl,hl 
0f77 87			    add a,a 
0f78 30 01		    jr nc,Mult12U_NoAdd1 
0f7a 19			    add hl,de 
0f7b			Mult12U_NoAdd1: 
0f7b 29			    add hl,hl 
0f7c 87			    add a,a 
0f7d 30 01		    jr nc,Mult12U_NoAdd2 
0f7f 19			    add hl,de 
0f80			Mult12U_NoAdd2: 
0f80 29			    add hl,hl 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd3 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd3: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd4 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd4: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd5 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd5: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd6 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd6: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 d0			    ret nc 
0f97 19			    add hl,de 
0f98 c9			    ret 
0f99			 
0f99			; 
0f99			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f99			; In: Multiply A with DE 
0f99			;      Put lowest value in A for most efficient calculation 
0f99			; Out: HL = result 
0f99			; 
0f99			Mult12R: 
0f99 21 00 00		    ld hl,0 
0f9c			Mult12R_Loop: 
0f9c cb 3f		    srl a 
0f9e 30 01		    jr nc,Mult12R_NoAdd 
0fa0 19			    add hl,de 
0fa1			Mult12R_NoAdd: 
0fa1 cb 23		    sla e 
0fa3 cb 12		    rl d 
0fa5 b7			    or a 
0fa6 c2 9c 0f		    jp nz,Mult12R_Loop 
0fa9 c9			    ret 
0faa			 
0faa			; 
0faa			; Multiply 16-bit values (with 32-bit result) 
0faa			; In: Multiply BC with DE 
0faa			; Out: BCHL = result 
0faa			; 
0faa			Mult32: 
0faa 79			    ld a,c 
0fab 48			    ld c,b 
0fac 21 00 00		    ld hl,0 
0faf 06 10		    ld b,16 
0fb1			Mult32_Loop: 
0fb1 29			    add hl,hl 
0fb2 17			    rla 
0fb3 cb 11		    rl c 
0fb5 30 07		    jr nc,Mult32_NoAdd 
0fb7 19			    add hl,de 
0fb8 ce 00		    adc a,0 
0fba d2 be 0f		    jp nc,Mult32_NoAdd 
0fbd 0c			    inc c 
0fbe			Mult32_NoAdd: 
0fbe 10 f1		    djnz Mult32_Loop 
0fc0 41			    ld b,c 
0fc1 4f			    ld c,a 
0fc2 c9			    ret 
0fc3			 
0fc3			 
0fc3			 
0fc3			; 
0fc3			; Multiply 8-bit values 
0fc3			; In:  Multiply H with E 
0fc3			; Out: HL = result 
0fc3			; 
0fc3			Mult8: 
0fc3 16 00		    ld d,0 
0fc5 6a			    ld l,d 
0fc6 06 08		    ld b,8 
0fc8			Mult8_Loop: 
0fc8 29			    add hl,hl 
0fc9 30 01		    jr nc,Mult8_NoAdd 
0fcb 19			    add hl,de 
0fcc			Mult8_NoAdd: 
0fcc 10 fa		    djnz Mult8_Loop 
0fce c9			    ret 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			;;http://z80-heaven.wikidot.com/math 
0fcf			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fcf			; 
0fcf			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fcf			;     ld a,16        ;7 
0fcf			;     ld hl,0        ;10 
0fcf			;     jp $+5         ;10 
0fcf			;.DivLoop: 
0fcf			;       add hl,bc    ;-- 
0fcf			;       dec a        ;64 
0fcf			;       jr z,.DivLoopEnd        ;86 
0fcf			; 
0fcf			;       sla e        ;128 
0fcf			;       rl d         ;128 
0fcf			;       adc hl,hl    ;240 
0fcf			;       sbc hl,bc    ;240 
0fcf			;       jr nc,.DivLoop ;23|21 
0fcf			;       inc e        ;-- 
0fcf			;       jp .DivLoop+1 
0fcf			; 
0fcf			;.DivLoopEnd: 
0fcf			 
0fcf			;HL_Div_C: 
0fcf			;Inputs: 
0fcf			;     HL is the numerator 
0fcf			;     C is the denominator 
0fcf			;Outputs: 
0fcf			;     A is the remainder 
0fcf			;     B is 0 
0fcf			;     C is not changed 
0fcf			;     DE is not changed 
0fcf			;     HL is the quotient 
0fcf			; 
0fcf			;       ld b,16 
0fcf			;       xor a 
0fcf			;         add hl,hl 
0fcf			;         rla 
0fcf			;         cp c 
0fcf			;         jr c,$+4 
0fcf			;           inc l 
0fcf			;           sub c 
0fcf			;         djnz $-7 
0fcf			 
0fcf			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fcf			 
0fcf			addatohl: 
0fcf 85			    add   a, l    ; A = A+L 
0fd0 6f			    ld    l, a    ; L = A+L 
0fd1 8c			    adc   a, h    ; A = A+L+H+carry 
0fd2 95			    sub   l       ; A = H+carry 
0fd3 67			    ld    h, a    ; H = H+carry 
0fd4 c9			ret 
0fd5			 
0fd5			addatode: 
0fd5 83			    add   a, e    ; A = A+L 
0fd6 5f			    ld    e, a    ; L = A+L 
0fd7 8a			    adc   a, d    ; A = A+L+H+carry 
0fd8 93			    sub   e       ; A = H+carry 
0fd9 57			    ld    d, a    ; H = H+carry 
0fda c9			ret 
0fdb			 
0fdb			 
0fdb			addatobc: 
0fdb 81			    add   a, c    ; A = A+L 
0fdc 4f			    ld    c, a    ; L = A+L 
0fdd 88			    adc   a, b    ; A = A+L+H+carry 
0fde 91			    sub   c       ; A = H+carry 
0fdf 47			    ld    b, a    ; H = H+carry 
0fe0 c9			ret 
0fe1			 
0fe1			subafromhl: 
0fe1			   ; If A=0 do nothing 
0fe1			    ; Otherwise flip A's sign. Since 
0fe1			    ; the upper byte becomes -1, also 
0fe1			    ; substract 1 from H. 
0fe1 ed 44		    neg 
0fe3 ca ec 0f		    jp    z, Skip 
0fe6 25			    dec   h 
0fe7			     
0fe7			    ; Now add the low byte as usual 
0fe7			    ; Two's complement takes care of 
0fe7			    ; ensuring the result is correct 
0fe7 85			    add   a, l 
0fe8 6f			    ld    l, a 
0fe9 8c			    adc   a, h 
0fea 95			    sub   l 
0feb 67			    ld    h, a 
0fec			Skip: 
0fec c9				ret 
0fed			 
0fed			 
0fed			; compare hl and de 
0fed			; returns:  
0fed			; if hl = de, z=1, s=0, c0=0 
0fed			; if hl > de, z=0, s=0, c=0 
0fed			; if hl < de, z=0, s=1, c=1 
0fed			cmp16:	 
0fed b7				or a 
0fee ed 52			sbc hl,de 
0ff0 e0				ret po 
0ff1 7c				ld a,h 
0ff2 1f				rra 
0ff3 ee 40			xor 01000000B 
0ff5 37				scf 
0ff6 8f				adc a,a 
0ff7 c9				ret 
0ff8			 
0ff8			 
0ff8			; test if hl contains zero   - A is destroyed 
0ff8			 
0ff8			ishlzero:    
0ff8 b7				or a     ; reset flags 
0ff9 7c				ld a, h 
0ffa b5				or l        	 
0ffb			 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			 
0ffc			 
0ffc			if FORTH_ENABLE_FLOATMATH 
0ffc			;include "float/bbcmath.z80" 
0ffc			include "float/lpfpcalc.asm" 
0ffc			endif 
0ffc			 
0ffc			 
0ffc			; eof 
0ffc			 
# End of file firmware_maths.asm
0ffc			include "firmware_strings.asm"   ; string handling  
0ffc			 
0ffc			 
0ffc			; TODO string len 
0ffc			; input text string, end on cr with zero term 
0ffc			; a offset into frame buffer to start prompt 
0ffc			; d is max length 
0ffc			; e is display size TODO 
0ffc			; c is current cursor position 
0ffc			; hl is ptr to where string will be stored 
0ffc			 
0ffc			 
0ffc			; TODO check limit of buffer for new inserts 
0ffc			; TODO check insert does not push beyond buffer 
0ffc			; TODO scroll in a limited display area 
0ffc			; TODO scroll whole screen on page wrap 
0ffc			 
0ffc			 
0ffc			; TODO handle KEY_PREVWORD 
0ffc			; TODO handle KEY_NEXTWORD 
0ffc			; TODO handle KEY_HOME 
0ffc			; TODO handle KEY_END 
0ffc			; TODO use LCD cursor? 
0ffc			 
0ffc 32 61 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0fff 81					add c 
1000 32 5f fe				ld (input_at_cursor),a	; save draw pos of cursor 
1003 22 64 fe				ld (input_start), hl     ; save ptr to buffer 
1006 79					ld a, c 
1007 cd cf 0f				call addatohl 
100a 22 66 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
100d 7a					ld a,d 
100e 32 63 fe			        ld (input_size), a       ; save length of input area 
1011 79					ld a, c 
1012 32 52 fe				ld (input_cursor),a      ; init cursor start position  
1015 7b					ld a,e 
1016 32 62 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
1019					 
1019					 
1019			 
1019			;		ld a,(input_ptr) 
1019			;		ld (input_under_cursor),a 	; save what is under the cursor 
1019			 
1019			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
1019					; init cursor shape if not set by the cin routines 
1019 21 be fb				ld hl, cursor_shape 
101c 3e ff				ld a, 255 
101e 77					ld (hl), a 
101f 23					inc hl 
1020 3e 00				ld a, 0 
1022 77					ld (hl), a 
1023			 
1023 3e 0f				ld a, CUR_BLINK_RATE 
1025 32 5d fe				ld (input_cur_flash), a 
1028 3e 01				ld a, 1 
102a 32 5c fe				ld (input_cur_onoff),a 
102d			 
102d			;	if DEBUG_INPUT 
102d			;		push af 
102d			;		ld a, 'I' 
102d			;		ld (debug_mark),a 
102d			;		pop af 
102d			;		CALLMONITOR 
102d			;	endif 
102d			.is1:		; main entry loop 
102d			 
102d			 
102d			 
102d					; pause 1ms 
102d			 
102d 3e 01				ld a, 1 
102f cd c3 0c				call aDelayInMS 
1032			 
1032					; dec flash counter 
1032 3a 5d fe				ld a, (input_cur_flash) 
1035 3d					dec a 
1036 32 5d fe				ld (input_cur_flash), a 
1039 fe 00				cp 0 
103b 20 0d				jr nz, .nochgstate 
103d			 
103d			 
103d					; change state 
103d 3a 5c fe				ld a,(input_cur_onoff) 
1040 ed 44				neg 
1042 32 5c fe				ld (input_cur_onoff),a 
1045			 
1045			 
1045					; reset on change of state 
1045 3e 0f				ld a, CUR_BLINK_RATE 
1047 32 5d fe				ld (input_cur_flash), a 
104a			 
104a			.nochgstate: 
104a					 
104a					 
104a			 
104a					; display cursor  
104a			 
104a			;		ld hl, (input_start) 
104a			;		ld a, (input_cursor) 
104a			;		call addatohl 
104a			 
104a					; get char under cursor and replace with cursor 
104a 2a 66 fe		ld hl, (input_ptr) 
104d			;		ld a, (hl) 
104d			;		ld (input_under_cursor),a 
104d			;		ld a, '_' 
104d			;		ld (hl), a 
104d			 
104d					; display string 
104d			 
104d ed 5b 64 fe			ld de, (input_start) 
1051 3a 61 fe				ld a, (input_at_pos) 
1054 cd ae 0d				call str_at_display 
1057			;	        call update_display 
1057			 
1057					; find place to put the cursor 
1057			;		add h 
1057			;		ld l, display_row_1 
1057			;		sub l 
1057			; (input_at_pos) 
1057					;ld c, a 
1057			;		ld a, (input_cursor) 
1057			;		ld l, (input_at_pos) 
1057			;		;ld b, h 
1057			;		add l 
1057			;		ld (input_at_cursor),a 
1057					;ld l,h 
1057			 
1057			;		ld h, 0 
1057			;		ld l,(input_at_pos) 
1057			;		ld a, (input_cursor) 
1057			;		call addatohl 
1057			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
1057			;		call subafromhl 
1057			;		ld a,l 
1057			;		ld (input_at_cursor), a 
1057			 
1057				if DEBUG_INPUT 
1057					ld a, (hardware_diag) 
1057					cp 0 
1057					jr z, .skip_input_diag 
1057			 
1057					ld a,(input_at_pos) 
1057					ld hl, LFSRSeed 
1057					call hexout 
1057					ld a, (input_cursor) 
1057					ld hl, LFSRSeed+2 
1057					call hexout 
1057					ld a,(input_at_cursor) 
1057					ld hl, LFSRSeed+4 
1057					call hexout 
1057			 
1057					ld a,(input_cur_onoff) 
1057					ld hl, LFSRSeed+6 
1057					call hexout 
1057			 
1057					ld a,(input_cur_flash) 
1057					ld hl, LFSRSeed+8 
1057					call hexout 
1057			 
1057					ld a,(input_len) 
1057					ld hl, LFSRSeed+10 
1057					call hexout 
1057					ld hl, LFSRSeed+12 
1057					ld a, 0 
1057					ld (hl),a 
1057					ld a, display_row_4 
1057					ld de, LFSRSeed 
1057					call str_at_display 
1057					.skip_input_diag: 
1057				endif 
1057			 
1057					; decide on if we are showing the cursor this time round 
1057			 
1057 3a 5c fe				ld a, (input_cur_onoff) 
105a fe ff				cp 255 
105c 28 13				jr z, .skipcur 
105e			 
105e			 
105e 3a 5f fe				ld a,(input_at_cursor) 
1061 11 be fb				ld de, cursor_shape 
1064 cd ae 0d				call str_at_display 
1067			 
1067					; save length of current input string 
1067 2a 64 fe				ld hl, (input_start) 
106a cd 2d 14				call strlenz 
106d 7d					ld a,l 
106e 32 57 fe				ld (input_len),a 
1071			 
1071			.skipcur: 
1071			 
1071 cd be 0d			        call update_display 
1074					 
1074			 
1074			 
1074					; wait 
1074				 
1074					; TODO loop without wait to flash the cursor and char under cursor	 
1074 cd 38 7a				call cin    ; _wait 
1077			 
1077 fe 00				cp 0 
1079 ca 2d 10				jp z, .is1 
107c			 
107c					; get ptr to char to input into 
107c			 
107c 4f					ld c,a 
107d 2a 64 fe				ld hl, (input_start) 
1080 3a 52 fe				ld a, (input_cursor) 
1083 cd cf 0f				call addatohl 
1086 22 66 fe				ld (input_ptr), hl 
1089 79					ld a,c 
108a			 
108a					; replace char under cursor 
108a			 
108a			;		ld hl, (input_ptr) 
108a			;		ld a, (input_under_cursor) 	; get what is under the cursor 
108a			;		ld (hl), a 
108a			 
108a			;	if DEBUG_INPUT 
108a			;		push af 
108a			;		ld a, 'i' 
108a			;		ld (debug_mark),a 
108a			;		pop af 
108a			;		CALLMONITOR 
108a			;	endif 
108a fe 0e				cp KEY_HOME 
108c 20 0e				jr nz, .iske 
108e			 
108e 3a 61 fe				ld a, (input_at_pos) 
1091 32 5f fe				ld (input_at_cursor),a 
1094 3e 00				ld a, 0 
1096 32 52 fe				ld (input_cursor), a 
1099 c3 2d 10				jp .is1 
109c					 
109c fe 0f		.iske:		cp KEY_END 
109e 20 03				jr nz, .isknw 
10a0 c3 2d 10				jp .is1 
10a3			 
10a3 fe 06		.isknw:		cp KEY_NEXTWORD 
10a5 20 1b				jr nz, .iskpw 
10a7			 
10a7 2a 66 fe		.isknwm:	ld hl, (input_ptr) 
10aa 7e					ld a,(hl)	 
10ab fe 00				cp 0 
10ad ca 2d 10				jp z, .is1    ; end of string 
10b0 fe 20				cp ' ' 
10b2 ca 2d 10				jp z, .is1    ; end of word 
10b5 23					inc hl 
10b6 22 66 fe				ld (input_ptr), hl 
10b9 3a 5f fe				ld a, (input_at_cursor) 
10bc 3c					inc a 
10bd 32 5f fe				ld (input_at_cursor), a 
10c0 18 e5				jr .isknwm 
10c2			 
10c2 fe 07		.iskpw:		cp KEY_PREVWORD 
10c4 20 1b				jr nz, .iskl 
10c6			.iskpwm:	 
10c6 2a 66 fe				ld hl, (input_ptr) 
10c9 7e					ld a,(hl)	 
10ca fe 00				cp 0  
10cc ca 2d 10				jp z, .is1    ; end of string 
10cf fe 20				cp ' ' 
10d1 ca 2d 10				jp z, .is1    ; end of word 
10d4 2b					dec hl 
10d5 22 66 fe				ld (input_ptr), hl 
10d8 3a 5f fe				ld a, (input_at_cursor) 
10db 3d					dec a 
10dc 32 5f fe				ld (input_at_cursor), a 
10df 18 e5				jr .iskpwm 
10e1			 
10e1			 
10e1 fe 0b		.iskl:		cp KEY_LEFT 
10e3 20 27				jr nz, .isk1 
10e5			 
10e5 3a 52 fe				ld a, (input_cursor) 
10e8			 
10e8 fe 00				cp 0 
10ea ca 2d 10				jp z, .is1 		; at start of line to ignore  
10ed			 
10ed 3d					dec  a 		; TODO check underflow 
10ee 32 52 fe				ld (input_cursor), a 
10f1			 
10f1 2a 66 fe				ld hl, (input_ptr) 
10f4 2b					dec hl 
10f5 22 66 fe				ld (input_ptr), hl 
10f8					 
10f8 3a 5f fe				ld a, (input_at_cursor) 
10fb 3d					dec a 
10fc 32 5f fe				ld (input_at_cursor), a 
10ff			 
10ff 3e 01				ld a, 1		; show cursor moving 
1101 32 5c fe				ld (input_cur_onoff),a 
1104 3e 0f				ld a, CUR_BLINK_RATE 
1106 32 5d fe				ld (input_cur_flash), a 
1109			 
1109 c3 2d 10				jp .is1 
110c			 
110c fe 0c		.isk1:		cp KEY_RIGHT 
110e 20 2a				jr nz, .isk2 
1110			 
1110 3a 57 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1113 5f					ld e,a 
1114 3a 52 fe				ld a, (input_cursor) 
1117 bb					cp e 
1118 ca 2d 10				jp z, .is1		; at the end of string so dont go right 
111b			 
111b 3c					inc  a 		; TODO check overflow 
111c 32 52 fe				ld (input_cursor), a 
111f			 
111f 3a 5f fe				ld a, (input_at_cursor) 
1122 3c					inc a 
1123 32 5f fe				ld (input_at_cursor), a 
1126			 
1126 2a 66 fe				ld hl, (input_ptr) 
1129 23					inc hl 
112a 22 66 fe				ld (input_ptr), hl 
112d			 
112d 3e 01				ld a, 1		; show cursor moving 
112f 32 5c fe				ld (input_cur_onoff),a 
1132 3e 0f				ld a, CUR_BLINK_RATE 
1134 32 5d fe				ld (input_cur_flash), a 
1137			 
1137 c3 2d 10				jp .is1 
113a			 
113a fe 05		.isk2:		cp KEY_UP 
113c			 
113c 20 26				jr nz, .isk3 
113e			 
113e					; swap last command with the current on 
113e			 
113e					; move cursor to start of string 
113e 2a 64 fe				ld hl, (input_start) 
1141 22 66 fe				ld (input_ptr), hl 
1144			 
1144 3a 61 fe				ld a, (input_at_pos) 
1147 32 5f fe				ld (input_at_cursor), a 
114a			 
114a 3e 00				ld a, 0 
114c 32 52 fe				ld (input_cursor), a 
114f					 
114f					; swap input and last command buffers 
114f			 
114f 21 e5 f4				ld hl, os_cli_cmd 
1152 11 e4 f5				ld de, os_last_cmd 
1155 06 ff				ld b, 255 
1157 7e			.swap1:		ld a, (hl) 
1158 4f					ld c,a 
1159 1a					ld a, (de) 
115a 77					ld (hl), a 
115b 79					ld a,c 
115c 12					ld (de),a 
115d 23					inc hl 
115e 13					inc de 
115f 10 f6				djnz .swap1 
1161			 
1161			 
1161			 
1161			 
1161			 
1161 c3 2d 10				jp .is1 
1164			 
1164 fe 08		.isk3:		cp KEY_BS 
1166 20 3c				jr nz, .isk4 
1168			 
1168 3a 52 fe				ld a, (input_cursor) 
116b			 
116b fe 00				cp 0 
116d ca 2d 10				jp z, .is1 		; at start of line to ignore  
1170			 
1170 3d					dec  a 		; TODO check underflow 
1171 32 52 fe				ld (input_cursor), a 
1174			 
1174					; hl is source 
1174					; de needs to be source - 1 
1174			 
1174			;		ld a, 0 
1174			;		dec hl 
1174			;		ld (hl), a 
1174			 
1174 2a 66 fe				ld hl, (input_ptr) 
1177 2b					dec hl 
1178 22 66 fe				ld (input_ptr), hl 
117b			 
117b					; shift all data 
117b			 
117b e5					push hl 
117c 23					inc hl 
117d d1					pop de 
117e 3a 57 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1181 4f					ld c,a 
1182 06 00				ld b,0 
1184 ed b0				ldir  
1186			 
1186			 
1186			 
1186			 
1186 3a 5f fe				ld a, (input_at_cursor) 
1189 3d					dec a 
118a 32 5f fe				ld (input_at_cursor), a 
118d			 
118d			 
118d 3e 01				ld a, 1		; show cursor moving 
118f 32 5c fe				ld (input_cur_onoff),a 
1192 3e 0f				ld a, CUR_BLINK_RATE 
1194 32 5d fe				ld (input_cur_flash), a 
1197			 
1197					; remove char 
1197 3a 5f fe				ld a, (input_at_cursor) 
119a 3c					inc a 
119b 11 25 12				ld de,.iblank 
119e cd ae 0d				call str_at_display 
11a1			 
11a1 c3 2d 10				jp .is1 
11a4			 
11a4 fe 0d		.isk4:		cp KEY_CR 
11a6 28 6c				jr z, .endinput 
11a8			 
11a8					; else add the key press to the end 
11a8			 
11a8 4f					ld c, a			; save key pressed 
11a9			 
11a9 7e					ld a,(hl)		; get what is currently under char 
11aa			 
11aa fe 00				cp 0			; we are at the end of the string 
11ac 20 2f				jr nz, .onchar 
11ae					 
11ae					; add a char to the end of the string 
11ae				 
11ae 71					ld (hl),c 
11af 23					inc hl 
11b0			;		ld a,' ' 
11b0			;		ld (hl),a 
11b0			;		inc hl 
11b0 3e 00				ld a,0 
11b2 77					ld (hl),a 
11b3 2b					dec hl 
11b4			 
11b4 3a 52 fe				ld a, (input_cursor) 
11b7 3c					inc a				; TODO check max string length and scroll  
11b8 32 52 fe				ld (input_cursor), a		; inc cursor pos 
11bb							 
11bb 3a 5f fe				ld a, (input_at_cursor) 
11be 3c					inc a 
11bf 32 5f fe				ld (input_at_cursor), a 
11c2			 
11c2 2a 66 fe				ld hl, (input_ptr) 
11c5 23					inc hl 
11c6 22 66 fe				ld (input_ptr), hl 
11c9			 
11c9 2a 66 fe				ld hl, (input_ptr) 
11cc 23					inc hl 
11cd 22 66 fe				ld (input_ptr), hl 
11d0			;	if DEBUG_INPUT 
11d0			;		push af 
11d0			;		ld a, '+' 
11d0			;		ld (debug_mark),a 
11d0			;		pop af 
11d0			;		CALLMONITOR 
11d0			;	endif 
11d0 3e 01				ld a, 1		; show cursor moving 
11d2 32 5c fe				ld (input_cur_onoff),a 
11d5 3e 0f				ld a, CUR_BLINK_RATE 
11d7 32 5d fe				ld (input_cur_flash), a 
11da c3 2d 10				jp .is1 
11dd					 
11dd			 
11dd			 
11dd					; if on a char then insert 
11dd			.onchar: 
11dd			 
11dd					; TODO over flow check: make sure insert does not blow out buffer 
11dd			 
11dd					; need to do some maths to use lddr 
11dd			 
11dd e5					push hl   ; save char pos 
11de c5					push bc 
11df			 
11df 2a 64 fe				ld hl, (input_start) 
11e2 3a 57 fe				ld a, (input_len) 
11e5 cd cf 0f				call addatohl  		; end of string 
11e8 23					inc hl 
11e9 23					inc hl		; past zero term 
11ea e5					push hl 
11eb 23					inc hl 
11ec e5					push hl  
11ed			 
11ed								; start and end of lddr set, now how much to move? 
11ed			 
11ed							 
11ed 3a 52 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11f0 47					ld b,a 
11f1 3a 57 fe				ld a,(input_len) 
11f4 5f					ld e,a 
11f5 90					sub b 
11f6 3c					inc a		;?? 
11f7 3c					inc a		;?? 
11f8 3c					inc a		;?? 
11f9			 
11f9 06 00				ld b,0 
11fb 4f					ld c,a 
11fc			 
11fc				if DEBUG_INPUT 
11fc					push af 
11fc					ld a, 'i' 
11fc					ld (debug_mark),a 
11fc					pop af 
11fc			;		CALLMONITOR 
11fc				endif 
11fc d1					pop de 
11fd e1					pop hl 
11fe				if DEBUG_INPUT 
11fe					push af 
11fe					ld a, 'I' 
11fe					ld (debug_mark),a 
11fe					pop af 
11fe			;		CALLMONITOR 
11fe				endif 
11fe ed b8				lddr 
1200				 
1200			 
1200			 
1200					; TODO have a key for insert/overwrite mode???? 
1200 c1					pop bc 
1201 e1					pop hl 
1202 71					ld (hl), c		; otherwise overwrite current char 
1203					 
1203			 
1203			 
1203			 
1203 3a 52 fe				ld a, (input_cursor) 
1206 3c					inc  a 		; TODO check overflow 
1207 32 52 fe				ld (input_cursor), a 
120a			 
120a 3a 5f fe				ld a, (input_at_cursor) 
120d 3c					inc a 
120e 32 5f fe				ld (input_at_cursor), a 
1211			 
1211 c3 2d 10				jp .is1 
1214			 
1214			.endinput:	; TODO look for end of string 
1214			 
1214					; add trailing space for end of token 
1214			 
1214 2a 64 fe				ld hl, (input_start) 
1217 3a 57 fe				ld a,(input_len) 
121a cd cf 0f				call addatohl 
121d 3e 20				ld a, ' ' 
121f 77					ld (hl),a 
1220					; TODO eof of parse marker 
1220			 
1220 23					inc hl 
1221 3e 00				ld a, 0 
1223 77					ld (hl),a 
1224			 
1224			 
1224 c9					ret 
1225			 
1225 .. 00		.iblank: db " ",0 
1227			 
1227			 
1227 32 61 fe		input_str_prev:	ld (input_at_pos), a 
122a 22 64 fe				ld (input_start), hl 
122d 3e 01				ld a,1			; add cursor 
122f 77					ld (hl),a 
1230 23					inc hl 
1231 3e 00				ld a,0 
1233 77					ld (hl),a 
1234 22 66 fe				ld (input_ptr), hl 
1237 7a					ld a,d 
1238 32 63 fe				ld (input_size), a 
123b 3e 00				ld a,0 
123d 32 52 fe				ld (input_cursor),a 
1240			.instr1:	 
1240			 
1240					; TODO do block cursor 
1240					; TODO switch cursor depending on the modifer key 
1240			 
1240					; update cursor shape change on key hold 
1240			 
1240 2a 66 fe				ld hl, (input_ptr) 
1243 2b					dec hl 
1244 3a be fb				ld a,(cursor_shape) 
1247 77					ld (hl), a 
1248			 
1248					; display entered text 
1248 3a 61 fe				ld a,(input_at_pos) 
124b cd fc 77		            	CALL fLCD_Pos       ;Position cursor to location in A 
124e ed 5b 64 fe	            	LD   de, (input_start) 
1252 cd 1e 78		            	CALL fLCD_Str       ;Display string pointed to by DE 
1255			 
1255 cd 38 7a				call cin 
1258 fe 00				cp 0 
125a 28 e4				jr z, .instr1 
125c			 
125c					; proecess keyboard controls first 
125c			 
125c 2a 66 fe				ld hl,(input_ptr) 
125f			 
125f fe 0d				cp KEY_CR	 ; pressing enter ends input 
1261 28 5a				jr z, .instrcr 
1263			 
1263 fe 08				cp KEY_BS 	; back space 
1265 20 0f				jr nz, .instr2 
1267					; process back space 
1267			 
1267					; TODO stop back space if at start of string 
1267 2b					dec hl 
1268 2b					dec hl ; to over write cursor 
1269 3a be fb				ld a,(cursor_shape) 
126c					;ld a,0 
126c 77					ld (hl),a 
126d 23					inc hl 
126e 3e 20				ld a," " 
1270 77					ld (hl),a 
1271 22 66 fe				ld (input_ptr),hl 
1274					 
1274			 
1274 18 ca				jr .instr1 
1276			 
1276 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1278 20 06				jr nz, .instr3 
127a 2b					dec hl 
127b 22 66 fe				ld (input_ptr),hl 
127e 18 c0				jr .instr1 
1280				 
1280 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1282 20 06				jr nz, .instr4 
1284 23					inc hl 
1285 22 66 fe				ld (input_ptr),hl 
1288 18 b6				jr .instr1 
128a			 
128a fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
128c 20 06				jr nz, .instr5 
128e 2b					dec hl 
128f 22 66 fe				ld (input_ptr),hl 
1292 18 ac				jr .instr1 
1294			 
1294 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1296 20 06				jr nz, .instr6 
1298 2b					dec hl 
1299 22 66 fe				ld (input_ptr),hl 
129c 18 a2				jr .instr1 
129e fe 05		.instr6:        cp KEY_UP      ; recall last command 
12a0 20 0b				jr nz, .instrnew 
12a2			 
12a2 21 be f1			ld hl, scratch 
12a5 11 e4 f5			ld de, os_last_cmd 
12a8 cd c6 12			call strcpy 
12ab 18 93				jr .instr1 
12ad			 
12ad			 
12ad			.instrnew:	; no special key pressed to see if we have room to store it 
12ad			 
12ad					; TODO do string size test 
12ad			 
12ad 2b					dec hl ; to over write cursor 
12ae 77					ld (hl),a 
12af 23					inc hl 
12b0 3a be fb				ld a,(cursor_shape) 
12b3 77					ld (hl),a 
12b4 23					inc hl 
12b5 3e 00				ld a,0 
12b7 77					ld (hl),a 
12b8			 
12b8 22 66 fe				ld (input_ptr),hl 
12bb					 
12bb 18 83				jr .instr1 
12bd 2b			.instrcr:	dec hl		; remove cursor 
12be 3e 20				ld a,' '	; TODO add a trailing space for safety 
12c0 77					ld (hl),a 
12c1 23					inc hl 
12c2 3e 00				ld a,0 
12c4 77					ld (hl),a 
12c5			 
12c5			 
12c5					; if at end of line scroll up    
12c5					; TODO detecting only end of line 4 for scroll up  
12c5			 
12c5					;ld   
12c5			 
12c5 c9					ret 
12c6			 
12c6			 
12c6			; strcpy hl = dest, de source 
12c6			 
12c6 1a			strcpy:   LD   A, (DE)        ;Get character from string 
12c7 b7			            OR   A              ;Null terminator? 
12c8 c8			            RET  Z              ;Yes, so finished 
12c9 1a					ld a,(de) 
12ca 77					ld (hl),a 
12cb 13			            INC  DE             ;Point to next character 
12cc 23					inc hl 
12cd 18 f7		            JR   strcpy       ;Repeat 
12cf c9					ret 
12d0			 
12d0			 
12d0			; TODO string_at  
12d0			; pass string which starts with lcd offset address and then null term string 
12d0			 
12d0			; TODO string to dec 
12d0			; TODO string to hex 
12d0			; TODO byte to string hex 
12d0			; TODO byte to string dec 
12d0			 
12d0			 
12d0			 
12d0			; from z80uartmonitor 
12d0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d0			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
12d0			; pass hl for where to put the text 
12d0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d0 c5			hexout:	PUSH BC 
12d1 f5					PUSH AF 
12d2 47					LD B, A 
12d3					; Upper nybble 
12d3 cb 3f				SRL A 
12d5 cb 3f				SRL A 
12d7 cb 3f				SRL A 
12d9 cb 3f				SRL A 
12db cd eb 12				CALL tohex 
12de 77					ld (hl),a 
12df 23					inc hl	 
12e0					 
12e0					; Lower nybble 
12e0 78					LD A, B 
12e1 e6 0f				AND 0FH 
12e3 cd eb 12				CALL tohex 
12e6 77					ld (hl),a 
12e7 23					inc hl	 
12e8					 
12e8 f1					POP AF 
12e9 c1					POP BC 
12ea c9					RET 
12eb					 
12eb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12eb			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
12eb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12eb			tohex: 
12eb e5					PUSH HL 
12ec d5					PUSH DE 
12ed 16 00				LD D, 0 
12ef 5f					LD E, A 
12f0 21 f8 12				LD HL, .DATA 
12f3 19					ADD HL, DE 
12f4 7e					LD A, (HL) 
12f5 d1					POP DE 
12f6 e1					POP HL 
12f7 c9					RET 
12f8			 
12f8			.DATA: 
12f8 30					DEFB	30h	; 0 
12f9 31					DEFB	31h	; 1 
12fa 32					DEFB	32h	; 2 
12fb 33					DEFB	33h	; 3 
12fc 34					DEFB	34h	; 4 
12fd 35					DEFB	35h	; 5 
12fe 36					DEFB	36h	; 6 
12ff 37					DEFB	37h	; 7 
1300 38					DEFB	38h	; 8 
1301 39					DEFB	39h	; 9 
1302 41					DEFB	41h	; A 
1303 42					DEFB	42h	; B 
1304 43					DEFB	43h	; C 
1305 44					DEFB	44h	; D 
1306 45					DEFB	45h	; E 
1307 46					DEFB	46h	; F 
1308			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1308			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1308			;;    subtract $30, if result > 9 then subtract $7 more 
1308			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1308			atohex: 
1308 d6 30				SUB $30 
130a fe 0a				CP 10 
130c f8					RET M		; If result negative it was 0-9 so we're done 
130d d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
130f c9					RET		 
1310			 
1310			 
1310			 
1310			 
1310			; Get 2 ASCII characters as hex byte from pointer in hl 
1310			 
1310			BYTERD: 
1310 16 00			LD	D,00h		;Set up 
1312 cd 1a 13			CALL	HEXCON		;Get byte and convert to hex 
1315 87				ADD	A,A		;First nibble so 
1316 87				ADD	A,A		;multiply by 16 
1317 87				ADD	A,A		; 
1318 87				ADD	A,A		; 
1319 57				LD	D,A		;Save hi nibble in D 
131a			HEXCON: 
131a 7e				ld a, (hl)		;Get next chr 
131b 23				inc hl 
131c d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
131e fe 0a			CP	00Ah		;Is it 0-9 ? 
1320 38 02			JR	C,NALPHA	;If so miss next bit 
1322 d6 07			SUB	007h		;Else convert alpha 
1324			NALPHA: 
1324 b2				OR	D		;Add hi nibble back 
1325 c9				RET			; 
1326			 
1326			 
1326			; 
1326			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1326			; Since the routines get_byte and therefore get_nibble are called, only valid 
1326			; characters (0-9a-f) are accepted. 
1326			; 
1326			;get_word        push    af 
1326			;                call    get_byte        ; Get the upper byte 
1326			;                ld      h, a 
1326			;                call    get_byte        ; Get the lower byte 
1326			;                ld      l, a 
1326			;                pop     af 
1326			;                ret 
1326			; 
1326			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1326			; the routine get_nibble is used only valid characters are accepted - the  
1326			; input routine only accepts characters 0-9a-f. 
1326			; 
1326 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1327 7e					ld a,(hl) 
1328 23					inc hl 
1329 cd 4e 13		                call    nibble2val      ; Get upper nibble 
132c cb 07		                rlc     a 
132e cb 07		                rlc     a 
1330 cb 07		                rlc     a 
1332 cb 07		                rlc     a 
1334 47			                ld      b, a            ; Save upper four bits 
1335 7e					ld a,(hl) 
1336 cd 4e 13		                call    nibble2val      ; Get lower nibble 
1339 b0			                or      b               ; Combine both nibbles 
133a c1			                pop     bc              ; Restore B (and C) 
133b c9			                ret 
133c			; 
133c			; Get a hexadecimal digit from the serial line. This routine blocks until 
133c			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
133c			; to the serial line interface. The lower 4 bits of A contain the value of  
133c			; that particular digit. 
133c			; 
133c			;get_nibble      ld a,(hl)           ; Read a character 
133c			;                call    to_upper        ; Convert to upper case 
133c			;                call    is_hex          ; Was it a hex digit? 
133c			;                jr      nc, get_nibble  ; No, get another character 
133c			 ;               call    nibble2val      ; Convert nibble to value 
133c			 ;               call    print_nibble 
133c			 ;               ret 
133c			; 
133c			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
133c			; A valid hexadecimal digit is denoted by a set C flag. 
133c			; 
133c			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
133c			;                ret     nc              ; Yes 
133c			;                cp      '0'             ; Less than '0'? 
133c			;                jr      nc, is_hex_1    ; No, continue 
133c			;                ccf                     ; Complement carry (i.e. clear it) 
133c			;                ret 
133c			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
133c			;                ret     c               ; Yes 
133c			;                cp      'A'             ; Less than 'A'? 
133c			;                jr      nc, is_hex_2    ; No, continue 
133c			;                ccf                     ; Yes - clear carry and return 
133c			;                ret 
133c			;is_hex_2        scf                     ; Set carry 
133c			;                ret 
133c			; 
133c			; Convert a single character contained in A to upper case: 
133c			; 
133c fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
133e d8			                ret     c 
133f fe 7b		                cp      'z' + 1         ; > 'z'? 
1341 d0			                ret     nc              ; Nothing to do, either 
1342 e6 5f		                and     $5f             ; Convert to upper case 
1344 c9			                ret 
1345			 
1345			 
1345			to_lower: 
1345			 
1345			   ; if char is in [A-Z] make it lower case 
1345			 
1345			   ; enter : a = char 
1345			   ; exit  : a = lower case char 
1345			   ; uses  : af 
1345			 
1345 fe 41		   cp 'A' 
1347 d8			   ret c 
1348			    
1348 fe 5b		   cp 'Z'+1 
134a d0			   ret nc 
134b			    
134b f6 20		   or $20 
134d c9			   ret 
134e			 
134e			; 
134e			; Expects a hexadecimal digit (upper case!) in A and returns the 
134e			; corresponding value in A. 
134e			; 
134e fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1350 38 02		                jr      c, nibble2val_1 ; Yes 
1352 d6 07		                sub     7               ; Adjust for A-F 
1354 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1356 e6 0f		                and     $f              ; Only return lower 4 bits 
1358 c9			                ret 
1359			; 
1359			; Print_nibble prints a single hex nibble which is contained in the lower  
1359			; four bits of A: 
1359			; 
1359			;print_nibble    push    af              ; We won't destroy the contents of A 
1359			;                and     $f              ; Just in case... 
1359			;                add     a, '0'             ; If we have a digit we are done here. 
1359			;                cp      '9' + 1         ; Is the result > 9? 
1359			;                jr      c, print_nibble_1 
1359			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1359			;print_nibble_1  call    putc            ; Print the nibble and 
1359			;                pop     af              ; restore the original value of A 
1359			;                ret 
1359			;; 
1359			;; Send a CR/LF pair: 
1359			; 
1359			;crlf            push    af 
1359			;                ld      a, cr 
1359			;                call    putc 
1359			;                ld      a, lf 
1359			;                call    putc 
1359			;                pop     af 
1359			;                ret 
1359			; 
1359			; Print_word prints the four hex digits of a word to the serial line. The  
1359			; word is expected to be in HL. 
1359			; 
1359			;print_word      push    hl 
1359			;                push    af 
1359			;                ld      a, h 
1359			;                call    print_byte 
1359			;                ld      a, l 
1359			;                call    print_byte 
1359			;                pop     af 
1359			;                pop     hl 
1359			;                ret 
1359			; 
1359			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1359			; The byte to be printed is expected to be in A. 
1359			; 
1359			;print_byte      push    af              ; Save the contents of the registers 
1359			;                push    bc 
1359			;                ld      b, a 
1359			;                rrca 
1359			;                rrca 
1359			;                rrca 
1359			;                rrca 
1359			;                call    print_nibble    ; Print high nibble 
1359			;                ld      a, b 
1359			;                call    print_nibble    ; Print low nibble 
1359			;                pop     bc              ; Restore original register contents 
1359			;                pop     af 
1359			;                ret 
1359			 
1359			 
1359			 
1359			 
1359			 
1359			fourehexhl:  
1359 7e				ld a,(hl) 
135a cd 08 13			call atohex 
135d cb 3f				SRL A 
135f cb 3f				SRL A 
1361 cb 3f				SRL A 
1363 cb 3f				SRL A 
1365 47				ld b, a 
1366 23				inc hl 
1367 7e				ld a,(hl) 
1368 23				inc hl 
1369 cd 08 13			call atohex 
136c 80				add b 
136d 57				ld d,a 
136e 7e				ld a,(hl) 
136f cd 08 13			call atohex 
1372 cb 3f				SRL A 
1374 cb 3f				SRL A 
1376 cb 3f				SRL A 
1378 cb 3f				SRL A 
137a 47				ld b, a 
137b 23				inc hl 
137c 7e				ld a,(hl) 
137d 23				inc hl 
137e cd 08 13			call atohex 
1381 80				add b 
1382 5f				ld e, a 
1383 d5				push de 
1384 e1				pop hl 
1385 c9				ret 
1386			 
1386			; pass hl. returns z set if the byte at hl is a digit 
1386			;isdigithl:  
1386			;	push bc 
1386			;	ld a,(hl) 
1386			;	cp ':' 
1386			;	jr nc, .isdf 		; > 
1386			;	cp '0' 
1386			;	jr c, .isdf		; < 
1386			; 
1386			;	; TODO find a better way to set z 
1386			; 
1386			;	ld b,a 
1386			;	cp b 
1386			;	pop bc 
1386			;	ret 
1386			; 
1386			;.isdf:	; not digit so clear z 
1386			; 
1386			;	; TODO find a better way to unset z 
1386			; 
1386			;	ld b,a 
1386			;	inc b 
1386			;	cp b 
1386			; 
1386			;	pop bc 
1386			;	ret 
1386				 
1386				 
1386			 
1386			 
1386			; pass hl as the four byte address to load 
1386			 
1386			get_word_hl:  
1386 e5				push hl 
1387 cd 26 13			call get_byte 
138a				 
138a 47				ld b, a 
138b			 
138b e1				pop hl 
138c 23				inc hl 
138d 23				inc hl 
138e			 
138e			; TODO not able to handle a-f  
138e 7e				ld a,(hl) 
138f			;	;cp ':' 
138f			;	cp 'g' 
138f			;	jr nc, .single_byte_hl 		; > 
138f			;	cp 'G' 
138f			;	jr nc, .single_byte_hl 		; > 
138f			;	cp '0' 
138f			;	jr c, .single_byte_hl		; < 
138f			 
138f				;call isdigithl 
138f fe 00			cp 0 
1391 28 06			jr z, .single_byte_hl 
1393			 
1393			.getwhln:   ; hex word so get next byte 
1393			 
1393 cd 26 13			call get_byte 
1396 6f				ld l, a 
1397 60				ld h,b 
1398 c9				ret 
1399 68			.single_byte_hl:   ld l,b 
139a 26 00				ld h,0 
139c c9					ret 
139d			 
139d			 
139d			 
139d			 
139d 21 ea 1d			ld hl,asc+1 
13a0			;	ld a, (hl) 
13a0			;	call nibble2val 
13a0 cd 26 13			call get_byte 
13a3			 
13a3			;	call fourehexhl 
13a3 32 f2 f1			ld (scratch+52),a 
13a6				 
13a6 21 f0 f1			ld hl,scratch+50 
13a9 22 e1 f4			ld (os_cur_ptr),hl 
13ac			 
13ac c9				ret 
13ad			 
13ad			 
13ad			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
13ad			 
13ad			; Decimal Unsigned Version 
13ad			 
13ad			;Number in a to decimal ASCII 
13ad			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
13ad			;Example: display a=56 as "056" 
13ad			;input: a = number 
13ad			;Output: a=0,value of a in the screen 
13ad			;destroys af,bc (don't know about hl and de) 
13ad			DispAToASCII: 
13ad 0e 9c			ld	c,-100 
13af cd b9 13			call	.Na1 
13b2 0e f6			ld	c,-10 
13b4 cd b9 13			call	.Na1 
13b7 0e ff			ld	c,-1 
13b9 06 2f		.Na1:	ld	b,'0'-1 
13bb 04			.Na2:	inc	b 
13bc 81				add	a,c 
13bd 38 fc			jr	c,.Na2 
13bf 91				sub	c		;works as add 100/10/1 
13c0 f5				push af		;safer than ld c,a 
13c1 78				ld	a,b		;char is in b 
13c2			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
13c2 f1				pop af		;safer than ld a,c 
13c3 c9				ret 
13c4			 
13c4			; Decimal Signed Version 
13c4			 
13c4			; DispA 
13c4			; -------------------------------------------------------------- 
13c4			; Converts a signed integer value to a zero-terminated ASCII 
13c4			; string representative of that value (using radix 10). 
13c4			; -------------------------------------------------------------- 
13c4			; INPUTS: 
13c4			;     HL     Value to convert (two's complement integer). 
13c4			;     DE     Base address of string destination. (pointer). 
13c4			; -------------------------------------------------------------- 
13c4			; OUTPUTS: 
13c4			;     None 
13c4			; -------------------------------------------------------------- 
13c4			; REGISTERS/MEMORY DESTROYED 
13c4			; AF HL 
13c4			; -------------------------------------------------------------- 
13c4			 
13c4			;DispHLToASCII: 
13c4			;   push    de 
13c4			;   push    bc 
13c4			; 
13c4			;; Detect sign of HL. 
13c4			;    bit    7, h 
13c4			;    jr     z, ._DoConvert 
13c4			; 
13c4			;; HL is negative. Output '-' to string and negate HL. 
13c4			;    ld     a, '-' 
13c4			;    ld     (de), a 
13c4			;    inc    de 
13c4			; 
13c4			;; Negate HL (using two's complement) 
13c4			;    xor    a 
13c4			;    sub    l 
13c4			;    ld     l, a 
13c4			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
13c4			;    sbc    a, h 
13c4			;    ld     h, a 
13c4			; 
13c4			;; Convert HL to digit characters 
13c4			;._DoConvert: 
13c4			;    ld     b, 0     ; B will count character length of number 
13c4			;-   ld     a, 10 
13c4			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
13c4			;    push   af 
13c4			;    inc    b 
13c4			;    ld     a, h 
13c4			;    or     l 
13c4			;    jr     nz, - 
13c4			; 
13c4			;; Retrieve digits from stack 
13c4			;-   pop    af 
13c4			;    or     $30 
13c4			;    ld     (de), a 
13c4			;    inc    de 
13c4			;    djnz   - 
13c4			; 
13c4			;; Terminate string with NULL 
13c4			;    xor    a 
13c4			;    ld     (de), a 
13c4			; 
13c4			;    pop    bc 
13c4			;    pop    de 
13c4			;    ret 
13c4			 
13c4			;Comments 
13c4			; 
13c4			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
13c4			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
13c4			;    Note that the output string will not be fixed-width. 
13c4			; 
13c4			;Example Usage 
13c4			; 
13c4			;    ld    hl, -1004 
13c4			;    ld    de, OP1 
13c4			;    call  DispA 
13c4			;    ld    hl, OP1 
13c4			;    syscall  PutS 
13c4			 
13c4			 
13c4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13c4			 
13c4			 
13c4			;Converts an ASCII string to an unsigned 16-bit integer 
13c4			;Quits when it reaches a non-decimal digit 
13c4			 
13c4			string_to_uint16: 
13c4			atoui_16: 
13c4			;Input: 
13c4			;     DE points to the string 
13c4			;Outputs: 
13c4			;     HL is the result 
13c4			;     A is the 8-bit value of the number 
13c4			;     DE points to the byte after the number 
13c4			;Destroys: 
13c4			;     BC 
13c4			;       if the string is non-empty, BC is HL/10 
13c4			;Size:  24 bytes 
13c4			;Speed: 42+d(104+{0,9}) 
13c4			;       d is the number of digits in the number 
13c4			;       max is 640 cycles for a 5 digit number 
13c4			;Assuming no leading zeros: 
13c4			;1 digit:  146cc 
13c4			;2 digit:  250cc 
13c4			;3 digit:  354cc or 363cc (avg: 354.126cc) 
13c4			;4 digit:  458cc or 467cc (avg: 458.27cc) 
13c4			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
13c4			;avg: 544.81158447265625cc (544+13297/16384) 
13c4			;=============================================================== 
13c4 21 00 00		  ld hl,0 
13c7			.u16a: 
13c7 1a			  ld a,(de) 
13c8 d6 30		  sub 30h 
13ca fe 0a		  cp 10 
13cc d0			  ret nc 
13cd 13			  inc de 
13ce 44			  ld b,h 
13cf 4d			  ld c,l 
13d0 29			  add hl,hl 
13d1 29			  add hl,hl 
13d2 09			  add hl,bc 
13d3 29			  add hl,hl 
13d4 85			  add a,l 
13d5 6f			  ld l,a 
13d6 30 ef		  jr nc,.u16a 
13d8 24			  inc h 
13d9 c3 c7 13		  jp .u16a 
13dc			 
13dc			 
13dc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13dc			 
13dc			;written by Zeda 
13dc			;Converts a 16-bit unsigned integer to an ASCII string. 
13dc			 
13dc			uitoa_16: 
13dc			;Input: 
13dc			;   DE is the number to convert 
13dc			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
13dc			;Output: 
13dc			;   HL points to the null-terminated ASCII string 
13dc			;      NOTE: This isn't necessarily the same as the input HL. 
13dc d5			  push de 
13dd c5			  push bc 
13de f5			  push af 
13df eb			  ex de,hl 
13e0			 
13e0 01 f0 d8		  ld bc,-10000 
13e3 3e 2f		  ld a,'0'-1 
13e5 3c			  inc a 
13e6 09			  add hl,bc  
13e7 38 fc		   jr c,$-2 
13e9 12			  ld (de),a 
13ea 13			  inc de 
13eb			 
13eb 01 e8 03		  ld bc,1000 
13ee 3e 3a		  ld a,'9'+1 
13f0 3d			  dec a  
13f1 09			  add hl,bc  
13f2 30 fc		   jr nc,$-2 
13f4 12			  ld (de),a 
13f5 13			  inc de 
13f6			 
13f6 01 9c ff		  ld bc,-100 
13f9 3e 2f		  ld a,'0'-1 
13fb 3c			  inc a  
13fc 09			  add hl,bc  
13fd 38 fc		   jr c,$-2 
13ff 12			  ld (de),a 
1400 13			  inc de 
1401			 
1401 7d			  ld a,l 
1402 26 3a		  ld h,'9'+1 
1404 25			  dec h  
1405 c6 0a		  add a,10  
1407 30 fb		   jr nc,$-3 
1409 c6 30		  add a,'0' 
140b eb			  ex de,hl 
140c 72			  ld (hl),d 
140d 23			  inc hl 
140e 77			  ld (hl),a 
140f 23			  inc hl 
1410 36 00		  ld (hl),0 
1412			 
1412			;Now strip the leading zeros 
1412 0e fa		  ld c,-6 
1414 09			  add hl,bc 
1415 3e 30		  ld a,'0' 
1417 23			  inc hl  
1418 be			  cp (hl)  
1419 28 fc		  jr z,$-2 
141b			 
141b			;Make sure that the string is non-empty! 
141b 7e			  ld a,(hl) 
141c b7			  or a 
141d 20 01		  jr nz,.atoub 
141f 2b			  dec hl 
1420			.atoub: 
1420			 
1420 f1			  pop af 
1421 c1			  pop bc 
1422 d1			  pop de 
1423 c9			  ret 
1424			 
1424			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1424			 
1424			toUpper: 
1424			;A is the char. 
1424			;If A is a lowercase letter, this sets it to the matching uppercase 
1424			;18cc or 30cc or 41cc 
1424			;avg: 26.75cc 
1424 fe 61		  cp 'a' 
1426 d8			  ret c 
1427 fe 7b		  cp 'z'+1 
1429 d0			  ret nc 
142a d6 20		  sub 'a'-'A' 
142c c9			  ret 
142d			 
142d			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
142d			 
142d			; String Length 
142d			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
142d			 
142d			; Get the length of the null-terminated string starting at $8000 hl 
142d			;    LD     HL, $8000 
142d			 
142d			strlenz: 
142d			 
142d af			    XOR    A               ; Zero is the value we are looking for. 
142e 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
142f 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1430			                           ; 65, 536 bytes (the entire addressable memory space). 
1430 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1432			 
1432			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1432 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1433 6f			    LD     L, A             ; number of bytes 
1434 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1436 2b			    DEC    HL              ; Compensate for null. 
1437 c9				ret 
1438			 
1438			; Get the length of the A terminated string starting at $8000 hl 
1438			;    LD     HL, $8000 
1438			 
1438			strlent: 
1438			 
1438			                  ; A is the value we are looking for. 
1438 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
143a 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
143c			                           ; 65, 536 bytes (the entire addressable memory space). 
143c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
143e			 
143e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
143e 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1440 2e 00		    LD     L, 0             ; number of bytes 
1442 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1444 2b			    DEC    HL              ; Compensate for null. 
1445 c9				ret 
1446			 
1446			 
1446			;Comparing Strings 
1446			 
1446			;IN    HL     Address of string1. 
1446			;      DE     Address of string2. 
1446			 
1446			; doc given but wrong??? 
1446			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1446			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1446			; tested 
1446			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1446			 
1446			strcmp_old: 
1446 e5			    PUSH   HL 
1447 d5			    PUSH   DE 
1448			 
1448 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1449 be			    CP     (HL)            ; (want to minimize work). 
144a 38 01		    JR     C, Str1IsBigger 
144c 7e			    LD     A, (HL) 
144d			 
144d			Str1IsBigger: 
144d 4f			    LD     C, A             ; Put length in BC 
144e 06 00		    LD     B, 0 
1450 13			    INC    DE              ; Increment pointers to meat of string. 
1451 23			    INC    HL 
1452			 
1452			CmpLoop: 
1452 1a			    LD     A, (DE)          ; Compare bytes. 
1453 ed a1		    CPI 
1455 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1457 13			    INC    DE              ; Update pointer. 
1458 ea 52 14		    JP     PE, CmpLoop 
145b			 
145b d1			    POP    DE 
145c e1			    POP    HL 
145d 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
145e be			    CP     (HL) 
145f c9			    RET 
1460			 
1460			NoMatch: 
1460 2b			    DEC    HL 
1461 be			    CP     (HL)            ; Compare again to affect carry. 
1462 d1			    POP    DE 
1463 e1			    POP    HL 
1464 c9			    RET 
1465			 
1465			;; test strmp 
1465			; 
1465			;ld de, .str1 
1465			;ld hl, .str2 
1465			;call strcmp 
1465			;jr z, .z1 
1465			;;this 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "NZ1" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			;.z1: 
1465			; 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "ZZ1" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			; 
1465			;ld de, .str1 
1465			;ld hl, .str1 
1465			;call strcmp 
1465			;jr z, .z2 
1465			;;this 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "NZ2" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			;.z2: 
1465			; 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "ZZ2" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			; 
1465			;ld de, .str1 
1465			;ld hl, .str2 
1465			;call strcmp 
1465			;jr c, .c1 
1465			; 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "Nc1" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			;.c1: 
1465			;;this 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "cc1" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			; 
1465			;ld de, .str1 
1465			;ld hl, .str1 
1465			;call strcmp 
1465			;jr c, .c2 
1465			;;this 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "Nc2" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			;.c2: 
1465			; 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "cc2" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			;	NEXTW 
1465			;.str1:   db "string1",0 
1465			;.str2:   db "string2",0 
1465			 
1465			; only care about direct match or not 
1465			; hl and de strings 
1465			; zero set if the same 
1465			 
1465			strcmp: 
1465 1a				ld a, (de) 
1466 be				cp (hl) 
1467 28 02			jr z, .ssame 
1469 b7				or a 
146a c9				ret 
146b			 
146b			.ssame:  
146b fe 00			cp 0 
146d c8				ret z 
146e			 
146e 23				inc hl 
146f 13				inc de 
1470 18 f3			jr strcmp 
1472				 
1472				 
1472			 
1472			 
1472			 
1472			 
1472			; eof 
1472			 
1472			 
1472			 
1472			 
1472			 
1472			 
# End of file firmware_strings.asm
1472			include "firmware_memory.asm"   ; malloc and free  
1472			 
1472			if DEBUG_FORTH_MALLOC_HIGH 
1472			.mallocsize: db "Wants malloc >256",0 
1472			.mallocasize: db "MALLOC gives >256",0 
1472			.malloczero: db "MALLOC gives zero",0 
1472			 
1472			malloc_guard_zerolen: 
1472				push hl 
1472				push de 
1472				push af 
1472			 
1472				ld de, 0 
1472			        call cmp16 
1472				jr nz, .lowalloz 
1472			 
1472				push hl 
1472				push de 
1472					ld hl, display_fb0 
1472					ld (display_fb_active), hl 
1472				call clear_display 
1472				ld a, 0 
1472				ld de, .malloczero 
1472				call str_at_display 
1472				call update_display 
1472				call delay1s 
1472				call delay1s 
1472				call bp_on 
1472			;	ld a, 0 
1472			;	ld (os_view_disable), a 
1472			 
1472				pop de 
1472				pop hl 
1472			 
1472				 
1472			 
1472				CALLMONITOR 
1472			.lowalloz: 
1472			 
1472			 
1472				pop af 
1472				pop de 
1472				pop hl 
1472			ret 
1472			 
1472			malloc_guard_entry: 
1472				push hl 
1472				push de 
1472				push af 
1472			 
1472			 	or a      ;clear carry flag 
1472				push hl 
1472				ld de, 255 
1472				sbc hl, de 
1472				jr c, .lowalloc 
1472			 
1472				push de 
1472					ld hl, display_fb0 
1472					ld (display_fb_active), hl 
1472				call clear_display 
1472				ld a, 0 
1472				ld de, .mallocsize 
1472				call str_at_display 
1472				call update_display 
1472				call delay1s 
1472				call delay1s 
1472			;	ld a, 0 
1472			;	ld (os_view_disable), a 
1472				call bp_on 
1472			 
1472				pop de 
1472				pop hl 
1472			 
1472				 
1472			 
1472				CALLMONITOR 
1472				jr .lowdone 
1472			.lowalloc: 
1472			 
1472			 
1472				pop hl 
1472			.lowdone:	pop af 
1472				pop de 
1472				pop hl 
1472			ret 
1472			 
1472			malloc_guard_exit: 
1472				push hl 
1472				push de 
1472				push af 
1472			 
1472			 	or a      ;clear carry flag 
1472				push hl 
1472				ld de, 255 
1472				sbc hl, de 
1472				jr c, .lowallocx 
1472			 
1472				push de 
1472					ld hl, display_fb0 
1472					ld (display_fb_active), hl 
1472				call clear_display 
1472				ld a, 0 
1472				ld de, .mallocasize 
1472				call str_at_display 
1472				call update_display 
1472				call delay1s 
1472				call delay1s 
1472			;	ld a, 0 
1472			;	ld (os_view_disable), a 
1472				call bp_on 
1472				pop de 
1472				pop hl 
1472			 
1472				CALLMONITOR 
1472				jr .lowdonex 
1472			.lowallocx: 
1472			 
1472				pop hl 
1472			.lowdonex:	pop af 
1472				pop de 
1472				pop hl 
1472			ret 
1472			endif 
1472			 
1472			if MALLOC_2 
1472			; Z80 Malloc and Free Functions 
1472			 
1472			; Malloc Function: 
1472			; Input: 
1472			;   HL: Size of block to allocate 
1472			; Output: 
1472			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1472			 
1472			malloc: 
1472				 
1472			if DEBUG_FORTH_MALLOC_HIGH 
1472			call malloc_guard_entry 
1472			endif 
1472			 
1472			 
1472			 
1472			 
1472					if DEBUG_FORTH_MALLOC 
1472						DMARK "mal" 
1472						CALLMONITOR 
1472					endif 
1472			    push af            ; Save AF register 
1472			    ld a, l            ; Load low byte of size into A 
1472			    or h               ; Check if size is zero 
1472			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1472			 
1472			    ; Allocate memory 
1472			    ld hl, (heap_start) ; Load start of heap into HL 
1472					if DEBUG_FORTH_MALLOC 
1472						DMARK "ma1" 
1472						CALLMONITOR 
1472					endif 
1472			    call malloc_internal ; Call internal malloc function 
1472			    pop af             ; Restore AF register 
1472			if DEBUG_FORTH_MALLOC_HIGH 
1472			call malloc_guard_exit 
1472			call malloc_guard_zerolen 
1472			endif 
1472			    ret                ; Return 
1472			 
1472			; Free Function: 
1472			; Input: 
1472			;   HL: Pointer to memory block to free 
1472			; Output: 
1472			;   None 
1472			 
1472			free: 
1472			    push af            ; Save AF register 
1472			    ld a, l            ; Load low byte of pointer into A 
1472			    or h               ; Check if pointer is NULL 
1472			    jp z, free_exit    ; If pointer is NULL, exit 
1472			 
1472			    ; Free memory 
1472			    ld hl, (heap_start) ; Load start of heap into HL 
1472			    call free_internal  ; Call internal free function 
1472			    pop af             ; Restore AF register 
1472			    ret                ; Return 
1472			 
1472			; Internal Malloc Function: 
1472			; Input: 
1472			;   HL: Size of block to allocate 
1472			; Output: 
1472			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1472			 
1472			malloc_internal: 
1472			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1472			    add hl, bc         ; Add management overhead to requested size 
1472			    ex de, hl          ; Save total size in DE, and keep it in HL 
1472					if DEBUG_FORTH_MALLOC 
1472						DMARK "ma2" 
1472						CALLMONITOR 
1472					endif 
1472			 
1472			    ; Search for free memory block 
1472			    ld de, (heap_end)  ; Load end of heap into DE 
1472			    ld bc, 0           ; Initialize counter 
1472			 
1472					if DEBUG_FORTH_MALLOC 
1472						DMARK "ma2" 
1472						CALLMONITOR 
1472					endif 
1472			malloc_search_loop: 
1472			    ; Check if current block is free 
1472			    ld a, (hl)         ; Load current block's status (free or used) 
1472			    cp 0               ; Compare with zero (free) 
1472			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1472			 
1472			    ; Check if current block is large enough 
1472			    ld a, (hl+1)       ; Load high byte of block size 
1472			    cp l               ; Compare with low byte of requested size 
1472			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1472			 
1472			    ld a, (hl+2)       ; Load low byte of block size 
1472			    cp h               ; Compare with high byte of requested size 
1472			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1472			 
1472			    ; Mark block as used 
1472			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1472			 
1472			    ; Calculate remaining space in block 
1472			    ld bc, 0           ; Clear BC 
1472			    add hl, bc         ; Increment HL to point to start of data block 
1472			    add hl, de         ; HL = HL + DE (total size) 
1472			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1472			    add hl, bc         ; Add management overhead to start of data block 
1472			 
1472			    ; Save pointer to allocated block in HL 
1472			if DEBUG_FORTH_MALLOC_HIGH 
1472						DMARK "ma5" 
1472			call malloc_guard_exit 
1472			call malloc_guard_zerolen 
1472			endif 
1472			    ret 
1472			 
1472			malloc_skip_block_check: 
1472			    ; Move to the next block 
1472			    ld bc, 3           ; Size of management overhead 
1472			    add hl, bc         ; Move to the next block 
1472			    inc de             ; Increment counter 
1472			 
1472			    ; Check if we have reached the end of heap 
1472			    ld a, e            ; Load low byte of heap end address 
1472			    cp (hl)            ; Compare with low byte of current address 
1472			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1472			    ld a, d            ; Load high byte of heap end address 
1472			    cp 0               ; Check if it's zero (end of memory) 
1472			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1472			 
1472			    ; If we reached here, allocation failed 
1472			    xor a              ; Set result to NULL 
1472			if DEBUG_FORTH_MALLOC_HIGH 
1472						DMARK "ma6" 
1472			call malloc_guard_exit 
1472			call malloc_guard_zerolen 
1472			endif 
1472			    ret 
1472			malloc_exit: 
1472			if DEBUG_FORTH_MALLOC_HIGH 
1472						DMARK "ma7" 
1472			call malloc_guard_exit 
1472			call malloc_guard_zerolen 
1472			endif 
1472			    ret 
1472			 
1472			; Internal Free Function: 
1472			; Input: 
1472			;   HL: Pointer to memory block to free 
1472			; Output: 
1472			;   None 
1472			 
1472			free_internal: 
1472			    ld de, (heap_start) ; Load start of heap into DE 
1472			    ld bc, 0            ; Initialize counter 
1472			 
1472			free_search_loop: 
1472			    ; Check if current block contains the pointer 
1472			    ld a, l             ; Load low byte of pointer 
1472			    cp (hl+1)           ; Compare with high byte of current block's address 
1472			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1472			    ld a, h             ; Load high byte of pointer 
1472			    cp (hl+2)           ; Compare with low byte of current block's address 
1472			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1472			 
1472			    ; Mark block as free 
1472			    ld (hl), 0          ; Set status byte to indicate free block 
1472			    ret                 ; Return 
1472			 
1472			free_skip_block_check: 
1472			    ; Move to the next block 
1472			    ld bc, 3            ; Size of management overhead 
1472			    add hl, bc          ; Move to the next block 
1472			    inc de              ; Increment counter 
1472			 
1472			    ; Check if we have reached the end of heap 
1472			    ld a, e             ; Load low byte of heap end address 
1472			    cp (hl)             ; Compare with low byte of current address 
1472			    jr nz, free_search_loop  ; If not equal, continue searching 
1472			    ld a, d             ; Load high byte of heap end address 
1472			    cp 0                ; Check if it's zero (end of memory) 
1472			    jr nz, free_search_loop  ; If not zero, continue searching 
1472			 
1472			    ; If we reached here, pointer is not found in heap 
1472			    ret 
1472			 
1472			free_exit: 
1472			    ret                 ; Return 
1472			 
1472			; Define heap start and end addresses 
1472			;heap_start:    .dw 0xC000   ; Start of heap 
1472			;heap_end:      .dw 0xE000   ; End of heap 
1472			 
1472			endif 
1472			 
1472			 
1472			if MALLOC_1 
1472			 
1472			 
1472			 
1472			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1472			 
1472			;moved to firmware.asm 
1472			;heap_start        .equ  0x9000      ; Starting address of heap 
1472			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1472			 
1472			;      .org 0 
1472			;      jp    main 
1472			 
1472			 
1472			;      .org  0x100 
1472			;main: 
1472			;      ld    HL, 0x8100 
1472			;      ld    SP, HL 
1472			; 
1472			;      call  heap_init 
1472			; 
1472			;      ; Make some allocations 
1472			;      ld    HL, 12 
1472			;      call  malloc            ; Allocates 0x9004 
1472			; 
1472			;      ld    HL, 12 
1472			;      call  malloc            ; Allocates 0x9014 
1472			; 
1472			;      ld    HL, 12 
1472			;      call  malloc            ; Allocates 0x9024 
1472			; 
1472			;      ; Free some allocations 
1472			;      ld    HL, 0x9014 
1472			;      call  free 
1472			; 
1472			;      ld    HL, 0x9004 
1472			;      call  free 
1472			; 
1472			;      ld    HL, 0x9024 
1472			;      call  free 
1472			; 
1472			; 
1472			;      halt 
1472			 
1472			 
1472			;------------------------------------------------------------------------------ 
1472			;     heap_init                                                               : 
1472			;                                                                             : 
1472			; Description                                                                 : 
1472			;     Initialise the heap and make it ready for malloc and free operations.   : 
1472			;                                                                             : 
1472			;     The heap is maintained as a linked list, starting with an initial       : 
1472			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1472			;     the first free block in the heap. Each block then points to the next    : 
1472			;     free block within the heap, and the free list ends at the first block   : 
1472			;     with a null pointer to the next free block.                             : 
1472			;                                                                             : 
1472			; Parameters                                                                  : 
1472			;     Inputs are compile-time only. Two defines which specify the starting    : 
1472			;     address of the heap and its size are required, along with a memory      : 
1472			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1472			;     principally stores a pointer to the first free block in the heap.       : 
1472			;                                                                             : 
1472			; Returns                                                                     : 
1472			;     Nothing                                                                 : 
1472			;------------------------------------------------------------------------------ 
1472			heap_init: 
1472 e5			      push  HL 
1473			 
1473			      ; Initialise free list struct 
1473 21 0e 80		      ld    HL, heap_start 
1476 22 0a 80		      ld    (free_list), HL 
1479 21 00 00		      ld    HL, 0 
147c 22 0c 80		      ld    (free_list+2), HL 
147f			 
147f			      ; Insert first free block at bottom of heap, consumes entire heap 
147f 21 95 f1		      ld    HL, heap_start+heap_size-4 
1482 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1485 21 87 71		      ld    HL, heap_size-4 
1488 22 10 80		      ld    (heap_start+2), HL      ; Block size 
148b			 
148b			      ; Insert end of free list block at top of heap - two null words will 
148b			      ; terminate the free list 
148b 21 00 00		      ld    HL, 0 
148e 22 97 f1		      ld    (heap_start+heap_size-2), HL 
1491 22 95 f1		      ld    (heap_start+heap_size-4), HL 
1494			 
1494 e1			      pop   HL 
1495			 
1495 c9			      ret 
1496			 
1496			 
1496			;------------------------------------------------------------------------------ 
1496			;     malloc                                                                  : 
1496			;                                                                             : 
1496			; Description                                                                 : 
1496			;     Allocates the wanted space from the heap and returns the address of the : 
1496			;     first useable byte of the allocation.                                   : 
1496			;                                                                             : 
1496			;     Allocations can happen in one of two ways:                              : 
1496			;                                                                             : 
1496			;     1. A free block may be found which is the exact size wanted. In this    : 
1496			;        case the block is removed from the free list and retuedn to the      : 
1496			;        caller.                                                              : 
1496			;     2. A free block may be found which is larger than the size wanted. In   : 
1496			;        this case, the larger block is split into two. The first portion of  : 
1496			;        this block will become the requested space by the malloc call and    : 
1496			;        is returned to the caller. The second portion becomes a new free     : 
1496			;        block, and the free list is adjusted to maintain continuity via this : 
1496			;        newly created block.                                                 : 
1496			;                                                                             : 
1496			;     malloc does not set any initial value in the allocated space, the       : 
1496			;     caller is required to do this as required.                              : 
1496			;                                                                             : 
1496			;     This implementation of malloc uses the stack exclusively, and is        : 
1496			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1496			;     advisable to disable interrupts before calling malloc, and recommended  : 
1496			;     to avoid the use of malloc inside ISRs in general.                      : 
1496			;                                                                             : 
1496			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1496			;                                                                             : 
1496			; Parameters                                                                  : 
1496			;     HL  Number of bytes wanted                                              : 
1496			;                                                                             : 
1496			; Returns                                                                     : 
1496			;     HL  Address of the first useable byte of the allocation                 : 
1496			;                                                                             : 
1496			; Flags                                                                       : 
1496			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1496			;                                                                             : 
1496			; Stack frame                                                                 : 
1496			;       |             |                                                       : 
1496			;       +-------------+                                                       : 
1496			;       |     BC      |                                                       : 
1496			;       +-------------+                                                       : 
1496			;       |     DE      |                                                       : 
1496			;       +-------------+                                                       : 
1496			;       |     IX      |                                                       : 
1496			;       +-------------+                                                       : 
1496			;       |  prev_free  |                                                       : 
1496			;   +4  +-------------+                                                       : 
1496			;       |  this_free  |                                                       : 
1496			;   +2  +-------------+                                                       : 
1496			;       |  next_free  |                                                       : 
1496			;   +0  +-------------+                                                       : 
1496			;       |             |                                                       : 
1496			;                                                                             : 
1496			;------------------------------------------------------------------------------ 
1496			 
1496			 
1496			;malloc: 
1496			; 
1496			;	SAVESP ON 1 
1496			; 
1496			;	call malloc_code 
1496			; 
1496			;	CHECKSP ON 1 
1496			;	ret 
1496			 
1496			 
1496			malloc: 
1496 c5			      push  BC 
1497 d5			      push  DE 
1498 dd e5		      push  IX 
149a			if DEBUG_FORTH_MALLOC_HIGH 
149a			call malloc_guard_entry 
149a			endif 
149a			 
149a					if DEBUG_FORTH_MALLOC 
149a						DMARK "mal" 
149a						CALLMONITOR 
149a					endif 
149a 7c			      ld    A, H                    ; Exit if no space requested 
149b b5			      or    L 
149c ca 5b 15		      jp    Z, malloc_early_exit 
149f			 
149f			;inc hl 
149f			;inc hl 
149f			;inc hl 
149f			; 
149f			;inc hl 
149f			;inc hl 
149f			;inc hl 
149f			;inc hl 
149f			;inc hl 
149f			;inc hl 
149f			;inc hl 
149f			;inc hl 
149f			;inc hl 
149f			 
149f			 
149f			 
149f			 
149f					if DEBUG_FORTH_MALLOC 
149f						DMARK "maA" 
149f						CALLMONITOR 
149f					endif 
149f			      ; Set up stack frame 
149f eb			      ex    DE, HL 
14a0 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
14a3 39			      add   HL, SP 
14a4 f9			      ld    SP, HL 
14a5 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14a9 dd 39		      add   IX, SP 
14ab			 
14ab			      ; Setup initial state 
14ab 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
14ae 19			      add   HL, DE 
14af			 
14af 44			      ld    B, H                    ; Move want to BC 
14b0 4d			      ld    C, L 
14b1			 
14b1 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
14b4 dd 75 04		      ld    (IX+4), L 
14b7 dd 74 05		      ld    (IX+5), H 
14ba			 
14ba 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
14bb 23			      inc   HL 
14bc 56			      ld    D, (HL) 
14bd dd 73 02		      ld    (IX+2), E 
14c0 dd 72 03		      ld    (IX+3), D 
14c3 eb			      ex    DE, HL                  ; this_free ptr into HL 
14c4			 
14c4					if DEBUG_FORTH_MALLOC 
14c4						DMARK "maB" 
14c4						CALLMONITOR 
14c4					endif 
14c4			      ; Loop through free block list to find some space 
14c4			malloc_find_space: 
14c4 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
14c5 23			      inc   HL 
14c6 56			      ld    D, (HL) 
14c7			 
14c7 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
14c8 b3			      or    E 
14c9 ca 55 15		      jp    Z, malloc_no_space 
14cc			 
14cc dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
14cf dd 72 01		      ld    (IX+1), D 
14d2			 
14d2			      ; Does this block have enough space to make the allocation? 
14d2 23			      inc   HL                      ; Load free block size into DE 
14d3 5e			      ld    E, (HL) 
14d4 23			      inc   HL 
14d5 56			      ld    D, (HL) 
14d6			 
14d6 eb			      ex    DE, HL                  ; Check size of block against want 
14d7 b7			      or    A                       ; Ensure carry flag clear 
14d8 ed 42		      sbc   HL, BC 
14da e5			      push  HL                      ; Store the result for later (new block size) 
14db			 
14db ca 2a 15		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
14de 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
14e0			 
14e0			      ; this_free block is not big enough, setup ptrs to test next free block 
14e0 e1			      pop   HL                      ; Discard previous result 
14e1			 
14e1 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
14e4 dd 66 03		      ld    H, (IX+3) 
14e7 dd 75 04		      ld    (IX+4), L 
14ea dd 74 05		      ld    (IX+5), H 
14ed			 
14ed dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
14f0 dd 66 01		      ld    H, (IX+1) 
14f3 dd 75 02		      ld    (IX+2), L 
14f6 dd 74 03		      ld    (IX+3), H 
14f9			 
14f9					if DEBUG_FORTH_MALLOC 
14f9						DMARK "MA>" 
14f9						CALLMONITOR 
14f9					endif 
14f9 18 c9		      jr    malloc_find_space 
14fb			 
14fb			      ; split a bigger block into two - requested size and remaining size 
14fb			malloc_alloc_split: 
14fb					if DEBUG_FORTH_MALLOC 
14fb						DMARK "MAs" 
14fb						CALLMONITOR 
14fb					endif 
14fb eb			      ex    DE, HL                  ; Calculate address of new free block 
14fc 2b			      dec   HL 
14fd 2b			      dec   HL 
14fe 2b			      dec   HL 
14ff 09			      add   HL, BC 
1500			 
1500			      ; Create a new block and point it at next_free 
1500 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1503 dd 56 01		      ld    D, (IX+1) 
1506			 
1506 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1507 23			      inc   HL 
1508 72			      ld    (HL), D 
1509			 
1509 d1			      pop   DE                      ; Store size of new block into new block 
150a 23			      inc   HL 
150b 73			      ld    (HL), E 
150c 23			      inc   HL 
150d 72			      ld    (HL), D 
150e			 
150e			      ; Update this_free ptr to point to new block 
150e 2b			      dec   HL 
150f 2b			      dec   HL 
1510 2b			      dec   HL 
1511			 
1511 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1514 dd 56 03		      ld    D, (IX+3) 
1517			 
1517 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
151a dd 74 03		      ld    (IX+3), H 
151d			 
151d			      ; Modify this_free block to be allocation 
151d eb			      ex    DE, HL 
151e af			      xor   A                       ; Null the next block ptr of allocated block 
151f 77			      ld    (HL), A 
1520 23			      inc   HL 
1521 77			      ld    (HL), A 
1522			 
1522 23			      inc   HL                      ; Store want size into allocated block 
1523 71			      ld    (HL), C 
1524 23			      inc   HL 
1525 70			      ld    (HL), B 
1526 23			      inc   HL 
1527 e5			      push  HL                      ; Address of allocation to return 
1528			 
1528 18 19		      jr    malloc_update_links 
152a			 
152a			malloc_alloc_fit: 
152a e1			      pop   HL                      ; Dont need new block size, want is exact fit 
152b			 
152b					if DEBUG_FORTH_MALLOC 
152b						DMARK "MAf" 
152b						CALLMONITOR 
152b					endif 
152b			      ; Modify this_free block to be allocation 
152b eb			      ex    DE, HL 
152c 2b			      dec   HL 
152d 2b			      dec   HL 
152e 2b			      dec   HL 
152f			 
152f af			      xor   A                       ; Null the next block ptr of allocated block 
1530 77			      ld    (HL), A 
1531 23			      inc   HL 
1532 77			      ld    (HL), A 
1533			 
1533 23			      inc   HL                      ; Store address of allocation to return 
1534 23			      inc   HL 
1535 23			      inc   HL 
1536 e5			      push  HL 
1537			 
1537			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1537 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
153a dd 66 01		      ld    H, (IX+1) 
153d			 
153d dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1540 dd 74 03		      ld    (IX+3), H 
1543			 
1543			 
1543			malloc_update_links: 
1543			      ; Update prev_free ptr to point to this_free 
1543 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1546 dd 66 05		      ld    H, (IX+5) 
1549			 
1549 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
154c dd 56 03		      ld    D, (IX+3) 
154f			 
154f 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1550 23			      inc   HL 
1551 72			      ld    (HL), D 
1552			 
1552					if DEBUG_FORTH_MALLOC 
1552						DMARK "Mul" 
1552						CALLMONITOR 
1552					endif 
1552			      ; Clear the Z flag to indicate successful allocation 
1552 7a			      ld    A, D 
1553 b3			      or    E 
1554			 
1554 d1			      pop   DE                      ; Address of allocation 
1555					if DEBUG_FORTH_MALLOC 
1555						DMARK "MAu" 
1555						CALLMONITOR 
1555					endif 
1555			 
1555			malloc_no_space: 
1555 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1558 39			      add   HL, SP 
1559 f9			      ld    SP, HL 
155a			 
155a eb			      ex    DE, HL                  ; Alloc addr into HL for return 
155b					if DEBUG_FORTH_MALLOC 
155b						DMARK "MAN" 
155b						CALLMONITOR 
155b					endif 
155b			 
155b			malloc_early_exit: 
155b					if DEBUG_FORTH_MALLOC 
155b						DMARK "MAx" 
155b						CALLMONITOR 
155b					endif 
155b dd e1		      pop   IX 
155d d1			      pop   DE 
155e c1			      pop   BC 
155f			 
155f			if DEBUG_FORTH_MALLOC_HIGH 
155f			call malloc_guard_exit 
155f			call malloc_guard_zerolen 
155f			endif 
155f c9			      ret 
1560			 
1560			 
1560			;------------------------------------------------------------------------------ 
1560			;     free                                                                    : 
1560			;                                                                             : 
1560			; Description                                                                 : 
1560			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1560			;     returned by malloc, otherwise the behaviour is undefined.               : 
1560			;                                                                             : 
1560			;     Where possible, directly adjacent free blocks will be merged together   : 
1560			;     into larger blocks to help ensure that the heap does not become         : 
1560			;     excessively fragmented.                                                 : 
1560			;                                                                             : 
1560			;     free does not clear or set any other value into the freed space, and    : 
1560			;     therefore its contents may be visible through subsequent malloc's. The  : 
1560			;     caller should clear the freed space as required.                        : 
1560			;                                                                             : 
1560			;     This implementation of free uses the stack exclusively, and is          : 
1560			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1560			;     advisable to disable interrupts before calling free, and recommended    : 
1560			;     to avoid the use of free inside ISRs in general.                        : 
1560			;                                                                             : 
1560			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1560			;                                                                             : 
1560			; Parameters                                                                  : 
1560			;     HL  Pointer to address of first byte of allocation to be freed          : 
1560			;                                                                             : 
1560			; Returns                                                                     : 
1560			;     Nothing                                                                 : 
1560			;                                                                             : 
1560			; Stack frame                                                                 : 
1560			;       |             |                                                       : 
1560			;       +-------------+                                                       : 
1560			;       |     BC      |                                                       : 
1560			;       +-------------+                                                       : 
1560			;       |     DE      |                                                       : 
1560			;       +-------------+                                                       : 
1560			;       |     IX      |                                                       : 
1560			;       +-------------+                                                       : 
1560			;       |  prev_free  |                                                       : 
1560			;   +2  +-------------+                                                       : 
1560			;       |  next_free  |                                                       : 
1560			;   +0  +-------------+                                                       : 
1560			;       |             |                                                       : 
1560			;                                                                             : 
1560			;------------------------------------------------------------------------------ 
1560			free: 
1560 c5			      push  BC 
1561 d5			      push  DE 
1562 dd e5		      push  IX 
1564			 
1564 7c			      ld    A, H                    ; Exit if ptr is null 
1565 b5			      or    L 
1566 ca 2a 16		      jp    Z, free_early_exit 
1569			 
1569			      ; Set up stack frame 
1569 eb			      ex    DE, HL 
156a 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
156d 39			      add   HL, SP 
156e f9			      ld    SP, HL 
156f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1573 dd 39		      add   IX, SP 
1575			 
1575			      ; The address in HL points to the start of the useable allocated space, 
1575			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1575			      ; address of the block itself. 
1575 eb			      ex    DE, HL 
1576 11 fc ff		      ld    DE, -4 
1579 19			      add   HL, DE 
157a			 
157a			      ; An allocated block must have a null next block pointer in it 
157a 7e			      ld    A, (HL) 
157b 23			      inc   HL 
157c b6			      or    (HL) 
157d c2 25 16		      jp    NZ, free_done 
1580			 
1580 2b			      dec   HL 
1581			 
1581 44			      ld    B, H                    ; Copy HL to BC 
1582 4d			      ld    C, L 
1583			 
1583			      ; Loop through the free list to find the first block with an address 
1583			      ; higher than the block being freed 
1583 21 0a 80		      ld    HL, free_list 
1586			 
1586			free_find_higher_block: 
1586 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1587 23			      inc   HL 
1588 56			      ld    D, (HL) 
1589 2b			      dec   HL 
158a			 
158a dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
158d dd 72 01		      ld    (IX+1), D 
1590 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1593 dd 74 03		      ld    (IX+3), H 
1596			 
1596 78			      ld    A, B                    ; Check if DE is greater than BC 
1597 ba			      cp    D                       ; Compare MSB first 
1598 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
159a 30 04		      jr    NC, free_find_higher_block_skip 
159c 79			      ld    A, C 
159d bb			      cp    E                       ; Then compare LSB 
159e 38 08		      jr    C, free_found_higher_block 
15a0			 
15a0			free_find_higher_block_skip: 
15a0 7a			      ld    A, D                    ; Reached the end of the free list? 
15a1 b3			      or    E 
15a2 ca 25 16		      jp    Z, free_done 
15a5			 
15a5 eb			      ex    DE, HL 
15a6			 
15a6 18 de		      jr    free_find_higher_block 
15a8			 
15a8			free_found_higher_block: 
15a8			      ; Insert freed block between prev and next free blocks 
15a8 71			      ld    (HL), C                 ; Point prev free block to freed block 
15a9 23			      inc   HL 
15aa 70			      ld    (HL), B 
15ab			 
15ab 60			      ld    H, B                    ; Point freed block at next free block 
15ac 69			      ld    L, C 
15ad 73			      ld    (HL), E 
15ae 23			      inc   HL 
15af 72			      ld    (HL), D 
15b0			 
15b0			      ; Check if the freed block is adjacent to the next free block 
15b0 23			      inc   HL                      ; Load size of freed block into HL 
15b1 5e			      ld    E, (HL) 
15b2 23			      inc   HL 
15b3 56			      ld    D, (HL) 
15b4 eb			      ex    DE, HL 
15b5			 
15b5 09			      add   HL, BC                  ; Add addr of freed block and its size 
15b6			 
15b6 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
15b9 dd 56 01		      ld    D, (IX+1) 
15bc			 
15bc b7			      or    A                       ; Clear the carry flag 
15bd ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15bf 20 22		      jr    NZ, free_check_adjacent_to_prev 
15c1			 
15c1			      ; Freed block is adjacent to next, merge into one bigger block 
15c1 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
15c2 5e			      ld    E, (HL) 
15c3 23			      inc   HL 
15c4 56			      ld    D, (HL) 
15c5 e5			      push  HL                      ; Save ptr to next block for later 
15c6			 
15c6 60			      ld    H, B                    ; Store ptr from next block into freed block 
15c7 69			      ld    L, C 
15c8 73			      ld    (HL), E 
15c9 23			      inc   HL 
15ca 72			      ld    (HL), D 
15cb			 
15cb e1			      pop   HL                      ; Restore ptr to next block 
15cc 23			      inc   HL                      ; Load size of next block into DE 
15cd 5e			      ld    E, (HL) 
15ce 23			      inc   HL 
15cf 56			      ld    D, (HL) 
15d0 d5			      push  DE                      ; Save next block size for later 
15d1			 
15d1 60			      ld    H, B                    ; Load size of freed block into HL 
15d2 69			      ld    L, C 
15d3 23			      inc   HL 
15d4 23			      inc   HL 
15d5 5e			      ld    E, (HL) 
15d6 23			      inc   HL 
15d7 56			      ld    D, (HL) 
15d8 eb			      ex    DE, HL 
15d9			 
15d9 d1			      pop   DE                      ; Restore size of next block 
15da 19			      add   HL, DE                  ; Add sizes of both blocks 
15db eb			      ex    DE, HL 
15dc			 
15dc 60			      ld    H, B                    ; Store new bigger size into freed block 
15dd 69			      ld    L, C 
15de 23			      inc   HL 
15df 23			      inc   HL 
15e0 73			      ld    (HL), E 
15e1 23			      inc   HL 
15e2 72			      ld    (HL), D 
15e3			 
15e3			free_check_adjacent_to_prev: 
15e3			      ; Check if the freed block is adjacent to the prev free block 
15e3 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
15e6 dd 66 03		      ld    H, (IX+3) 
15e9			 
15e9 23			      inc   HL                      ; Size of prev free block into DE 
15ea 23			      inc   HL 
15eb 5e			      ld    E, (HL) 
15ec 23			      inc   HL 
15ed 56			      ld    D, (HL) 
15ee 2b			      dec   HL 
15ef 2b			      dec   HL 
15f0 2b			      dec   HL 
15f1			 
15f1 19			      add   HL, DE                  ; Add prev block addr and size 
15f2			 
15f2 b7			      or    A                       ; Clear the carry flag 
15f3 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15f5 20 2e		      jr    NZ, free_done 
15f7			 
15f7			      ; Freed block is adjacent to prev, merge into one bigger block 
15f7 60			      ld    H, B                    ; Load next ptr from freed block into DE 
15f8 69			      ld    L, C 
15f9 5e			      ld    E, (HL) 
15fa 23			      inc   HL 
15fb 56			      ld    D, (HL) 
15fc e5			      push  HL                      ; Save freed block ptr for later 
15fd			 
15fd dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1600 dd 66 03		      ld    H, (IX+3) 
1603 73			      ld    (HL), E 
1604 23			      inc   HL 
1605 72			      ld    (HL), D 
1606			 
1606 e1			      pop   HL                      ; Restore freed block ptr 
1607 23			      inc   HL                      ; Load size of freed block into DE 
1608 5e			      ld    E, (HL) 
1609 23			      inc   HL 
160a 56			      ld    D, (HL) 
160b d5			      push  DE                      ; Save freed block size for later 
160c			 
160c dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
160f dd 66 03		      ld    H, (IX+3) 
1612 23			      inc   HL 
1613 23			      inc   HL 
1614 5e			      ld    E, (HL) 
1615 23			      inc   HL 
1616 56			      ld    D, (HL) 
1617			 
1617 e1			      pop   HL                      ; Add sizes of both blocks 
1618 19			      add   HL, DE 
1619 eb			      ex    DE, HL 
161a			 
161a dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
161d dd 66 03		      ld    H, (IX+3) 
1620 23			      inc   HL 
1621 23			      inc   HL 
1622 73			      ld    (HL), E 
1623 23			      inc   HL 
1624 72			      ld    (HL), D 
1625			 
1625			free_done: 
1625 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1628 39			      add   HL, SP 
1629 f9			      ld    SP, HL 
162a			 
162a			free_early_exit: 
162a dd e1		      pop   IX 
162c d1			      pop   DE 
162d c1			      pop   BC 
162e			 
162e c9			      ret 
162f			 
162f			; moved to firmware.asm 
162f			; 
162f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
162f			;                  .dw   0 
162f			 
162f			 
162f			endif 
162f			 
162f			 
162f			if MALLOC_3 
162f			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
162f			;heap_start        .equ  0x9000      ; Starting address of heap 
162f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
162f			; 
162f			 ;     .org 0 
162f			  ;    jp    main 
162f			; 
162f			; 
162f			 ;     .org  0x100 
162f			;main: 
162f			 ;     ld    HL, 0x8100 
162f			  ;    ld    SP, HL 
162f			; 
162f			;      call  heap_init 
162f			 
162f			      ; Make some allocations 
162f			;      ld    HL, 12 
162f			;      call  malloc            ; Allocates 0x9004 
162f			; 
162f			 ;     ld    HL, 12 
162f			;      call  malloc            ; Allocates 0x9014 
162f			 
162f			;      ld    HL, 12 
162f			;      call  malloc            ; Allocates 0x9024 
162f			 
162f			      ; Free some allocations 
162f			;      ld    HL, 0x9014 
162f			;      call  free 
162f			 
162f			;      ld    HL, 0x9004 
162f			;      call  free 
162f			; 
162f			;      ld    HL, 0x9024 
162f			;      call  free 
162f			 
162f			 
162f			 ;     halt 
162f			 
162f			 
162f			;------------------------------------------------------------------------------ 
162f			;     heap_init                                                               : 
162f			;                                                                             : 
162f			; Description                                                                 : 
162f			;     Initialise the heap and make it ready for malloc and free operations.   : 
162f			;                                                                             : 
162f			;     The heap is maintained as a linked list, starting with an initial       : 
162f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
162f			;     the first free block in the heap. Each block then points to the next    : 
162f			;     free block within the heap, and the free list ends at the first block   : 
162f			;     with a null pointer to the next free block.                             : 
162f			;                                                                             : 
162f			; Parameters                                                                  : 
162f			;     Inputs are compile-time only. Two defines which specify the starting    : 
162f			;     address of the heap and its size are required, along with a memory      : 
162f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
162f			;     principally stores a pointer to the first free block in the heap.       : 
162f			;                                                                             : 
162f			; Returns                                                                     : 
162f			;     Nothing                                                                 : 
162f			;------------------------------------------------------------------------------ 
162f			heap_init: 
162f			      push  HL 
162f			 
162f			      ; Initialise free list struct 
162f			      ld    HL, heap_start 
162f			      ld    (free_list), HL 
162f			      ld    HL, 0 
162f			      ld    (free_list+2), HL 
162f			 
162f			      ; Insert first free block at bottom of heap, consumes entire heap 
162f			      ld    HL, heap_start+heap_size-4 
162f			      ld    (heap_start), HL        ; Next block (end of free list) 
162f			      ld    HL, heap_size-4 
162f			      ld    (heap_start+2), HL      ; Block size 
162f			 
162f			      ; Insert end of free list block at top of heap - two null words will 
162f			      ; terminate the free list 
162f			      ld    HL, 0 
162f			      ld    (heap_start+heap_size-2), HL 
162f			      ld    (heap_start+heap_size-4), HL 
162f			 
162f			      pop   HL 
162f			 
162f			      ret 
162f			 
162f			 
162f			;------------------------------------------------------------------------------ 
162f			;     malloc                                                                  : 
162f			;                                                                             : 
162f			; Description                                                                 : 
162f			;     Allocates the wanted space from the heap and returns the address of the : 
162f			;     first useable byte of the allocation.                                   : 
162f			;                                                                             : 
162f			;     Allocations can happen in one of two ways:                              : 
162f			;                                                                             : 
162f			;     1. A free block may be found which is the exact size wanted. In this    : 
162f			;        case the block is removed from the free list and retuedn to the      : 
162f			;        caller.                                                              : 
162f			;     2. A free block may be found which is larger than the size wanted. In   : 
162f			;        this case, the larger block is split into two. The first portion of  : 
162f			;        this block will become the requested space by the malloc call and    : 
162f			;        is returned to the caller. The second portion becomes a new free     : 
162f			;        block, and the free list is adjusted to maintain continuity via this : 
162f			;        newly created block.                                                 : 
162f			;                                                                             : 
162f			;     malloc does not set any initial value in the allocated space, the       : 
162f			;     caller is required to do this as required.                              : 
162f			;                                                                             : 
162f			;     This implementation of malloc uses the stack exclusively, and is        : 
162f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
162f			;     advisable to disable interrupts before calling malloc, and recommended  : 
162f			;     to avoid the use of malloc inside ISRs in general.                      : 
162f			;                                                                             : 
162f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
162f			;                                                                             : 
162f			; Parameters                                                                  : 
162f			;     HL  Number of bytes wanted                                              : 
162f			;                                                                             : 
162f			; Returns                                                                     : 
162f			;     HL  Address of the first useable byte of the allocation                 : 
162f			;                                                                             : 
162f			; Flags                                                                       : 
162f			;     Z   Set if the allocation did not succeed, clear otherwise              : 
162f			;                                                                             : 
162f			; Stack frame                                                                 : 
162f			;       |             |                                                       : 
162f			;       +-------------+                                                       : 
162f			;       |     BC      |                                                       : 
162f			;       +-------------+                                                       : 
162f			;       |     DE      |                                                       : 
162f			;       +-------------+                                                       : 
162f			;       |     IX      |                                                       : 
162f			;       +-------------+                                                       : 
162f			;       |  prev_free  |                                                       : 
162f			;   +4  +-------------+                                                       : 
162f			;       |  this_free  |                                                       : 
162f			;   +2  +-------------+                                                       : 
162f			;       |  next_free  |                                                       : 
162f			;   +0  +-------------+                                                       : 
162f			;       |             |                                                       : 
162f			;                                                                             : 
162f			;------------------------------------------------------------------------------ 
162f			malloc: 
162f			      push  BC 
162f			      push  DE 
162f			      push  IX 
162f			 
162f			      ld    A, H                    ; Exit if no space requested 
162f			      or    L 
162f			      jp    Z, malloc_early_exit 
162f			 
162f			      ; Set up stack frame 
162f			      ex    DE, HL 
162f			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
162f			      add   HL, SP 
162f			      ld    SP, HL 
162f			      ld    IX, 0                   ; Use IX as a frame pointer 
162f			      add   IX, SP 
162f			 
162f			      ; Setup initial state 
162f			      ld    HL, 4                   ; want must also include space used by block struct 
162f			      add   HL, DE 
162f			 
162f			      ld    B, H                    ; Move want to BC 
162f			      ld    C, L 
162f			 
162f			      ld    HL, free_list           ; Store prev_free ptr to stack 
162f			      ld    (IX+4), L 
162f			      ld    (IX+5), H 
162f			 
162f			      ld    E, (HL)                 ; Store this_free ptr to stack 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			      ld    (IX+2), E 
162f			      ld    (IX+3), D 
162f			      ex    DE, HL                  ; this_free ptr into HL 
162f			 
162f			      ; Loop through free block list to find some space 
162f			malloc_find_space: 
162f			      ld    E, (HL)                 ; Load next_free ptr into DE 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			 
162f			      ld    A, D                    ; Check for null next_free ptr - end of free list 
162f			      or    E 
162f			      jp    Z, malloc_no_space 
162f			 
162f			      ld    (IX+0), E               ; Store next_free ptr to stack 
162f			      ld    (IX+1), D 
162f			 
162f			      ; Does this block have enough space to make the allocation? 
162f			      inc   HL                      ; Load free block size into DE 
162f			      ld    E, (HL) 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			 
162f			      ex    DE, HL                  ; Check size of block against want 
162f			      or    A                       ; Ensure carry flag clear 
162f			      sbc   HL, BC 
162f			      push  HL                      ; Store the result for later (new block size) 
162f			 
162f			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
162f			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
162f			 
162f			      ; this_free block is not big enough, setup ptrs to test next free block 
162f			      pop   HL                      ; Discard previous result 
162f			 
162f			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
162f			      ld    H, (IX+3) 
162f			      ld    (IX+4), L 
162f			      ld    (IX+5), H 
162f			 
162f			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
162f			      ld    H, (IX+1) 
162f			      ld    (IX+2), L 
162f			      ld    (IX+3), H 
162f			 
162f			      jr    malloc_find_space 
162f			 
162f			      ; split a bigger block into two - requested size and remaining size 
162f			malloc_alloc_split: 
162f			      ex    DE, HL                  ; Calculate address of new free block 
162f			      dec   HL 
162f			      dec   HL 
162f			      dec   HL 
162f			      add   HL, BC 
162f			 
162f			      ; Create a new block and point it at next_free 
162f			      ld    E, (IX+0)               ; Load next_free ptr into DE 
162f			      ld    D, (IX+1) 
162f			 
162f			      ld    (HL), E                 ; Store next_free ptr into new block 
162f			      inc   HL 
162f			      ld    (HL), D 
162f			 
162f			      pop   DE                      ; Store size of new block into new block 
162f			      inc   HL 
162f			      ld    (HL), E 
162f			      inc   HL 
162f			      ld    (HL), D 
162f			 
162f			      ; Update this_free ptr to point to new block 
162f			      dec   HL 
162f			      dec   HL 
162f			      dec   HL 
162f			 
162f			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
162f			      ld    D, (IX+3) 
162f			 
162f			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
162f			      ld    (IX+3), H 
162f			 
162f			      ; Modify this_free block to be allocation 
162f			      ex    DE, HL 
162f			      xor   A                       ; Null the next block ptr of allocated block 
162f			      ld    (HL), A 
162f			      inc   HL 
162f			      ld    (HL), A 
162f			 
162f			      inc   HL                      ; Store want size into allocated block 
162f			      ld    (HL), C 
162f			      inc   HL 
162f			      ld    (HL), B 
162f			      inc   HL 
162f			      push  HL                      ; Address of allocation to return 
162f			 
162f			      jr    malloc_update_links 
162f			 
162f			malloc_alloc_fit: 
162f			      pop   HL                      ; Dont need new block size, want is exact fit 
162f			 
162f			      ; Modify this_free block to be allocation 
162f			      ex    DE, HL 
162f			      dec   HL 
162f			      dec   HL 
162f			      dec   HL 
162f			 
162f			      xor   A                       ; Null the next block ptr of allocated block 
162f			      ld    (HL), A 
162f			      inc   HL 
162f			      ld    (HL), A 
162f			 
162f			      inc   HL                      ; Store address of allocation to return 
162f			      inc   HL 
162f			      inc   HL 
162f			      push  HL 
162f			 
162f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
162f			      ld    L, (IX+0)               ; next_free to HL 
162f			      ld    H, (IX+1) 
162f			 
162f			      ld    (IX+2), L               ; HL to this_free 
162f			      ld    (IX+3), H 
162f			 
162f			 
162f			malloc_update_links: 
162f			      ; Update prev_free ptr to point to this_free 
162f			      ld    L, (IX+4)               ; prev_free ptr to HL 
162f			      ld    H, (IX+5) 
162f			 
162f			      ld    E, (IX+2)               ; this_free ptr to DE 
162f			      ld    D, (IX+3) 
162f			 
162f			      ld    (HL), E                 ; this_free ptr into prev_free 
162f			      inc   HL 
162f			      ld    (HL), D 
162f			 
162f			      ; Clear the Z flag to indicate successful allocation 
162f			      ld    A, D 
162f			      or    E 
162f			 
162f			      pop   DE                      ; Address of allocation 
162f			 
162f			malloc_no_space: 
162f			      ld    HL, 6                   ; Clean up stack frame 
162f			      add   HL, SP 
162f			      ld    SP, HL 
162f			 
162f			      ex    DE, HL                  ; Alloc addr into HL for return 
162f			 
162f			malloc_early_exit: 
162f			      pop   IX 
162f			      pop   DE 
162f			      pop   BC 
162f			 
162f			      ret 
162f			 
162f			 
162f			;------------------------------------------------------------------------------ 
162f			;     free                                                                    : 
162f			;                                                                             : 
162f			; Description                                                                 : 
162f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
162f			;     returned by malloc, otherwise the behaviour is undefined.               : 
162f			;                                                                             : 
162f			;     Where possible, directly adjacent free blocks will be merged together   : 
162f			;     into larger blocks to help ensure that the heap does not become         : 
162f			;     excessively fragmented.                                                 : 
162f			;                                                                             : 
162f			;     free does not clear or set any other value into the freed space, and    : 
162f			;     therefore its contents may be visible through subsequent malloc's. The  : 
162f			;     caller should clear the freed space as required.                        : 
162f			;                                                                             : 
162f			;     This implementation of free uses the stack exclusively, and is          : 
162f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
162f			;     advisable to disable interrupts before calling free, and recommended    : 
162f			;     to avoid the use of free inside ISRs in general.                        : 
162f			;                                                                             : 
162f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
162f			;                                                                             : 
162f			; Parameters                                                                  : 
162f			;     HL  Pointer to address of first byte of allocation to be freed          : 
162f			;                                                                             : 
162f			; Returns                                                                     : 
162f			;     Nothing                                                                 : 
162f			;                                                                             : 
162f			; Stack frame                                                                 : 
162f			;       |             |                                                       : 
162f			;       +-------------+                                                       : 
162f			;       |     BC      |                                                       : 
162f			;       +-------------+                                                       : 
162f			;       |     DE      |                                                       : 
162f			;       +-------------+                                                       : 
162f			;       |     IX      |                                                       : 
162f			;       +-------------+                                                       : 
162f			;       |  prev_free  |                                                       : 
162f			;   +2  +-------------+                                                       : 
162f			;       |  next_free  |                                                       : 
162f			;   +0  +-------------+                                                       : 
162f			;       |             |                                                       : 
162f			;                                                                             : 
162f			;------------------------------------------------------------------------------ 
162f			free: 
162f			      push  BC 
162f			      push  DE 
162f			      push  IX 
162f			 
162f			      ld    A, H                    ; Exit if ptr is null 
162f			      or    L 
162f			      jp    Z, free_early_exit 
162f			 
162f			      ; Set up stack frame 
162f			      ex    DE, HL 
162f			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
162f			      add   HL, SP 
162f			      ld    SP, HL 
162f			      ld    IX, 0                   ; Use IX as a frame pointer 
162f			      add   IX, SP 
162f			 
162f			      ; The address in HL points to the start of the useable allocated space, 
162f			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
162f			      ; address of the block itself. 
162f			      ex    DE, HL 
162f			      ld    DE, -4 
162f			      add   HL, DE 
162f			 
162f			      ; An allocated block must have a null next block pointer in it 
162f			      ld    A, (HL) 
162f			      inc   HL 
162f			      or    (HL) 
162f			      jp    NZ, free_done 
162f			 
162f			      dec   HL 
162f			 
162f			      ld    B, H                    ; Copy HL to BC 
162f			      ld    C, L 
162f			 
162f			      ; Loop through the free list to find the first block with an address 
162f			      ; higher than the block being freed 
162f			      ld    HL, free_list 
162f			 
162f			free_find_higher_block: 
162f			      ld    E, (HL)                 ; Load next ptr from free block 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			      dec   HL 
162f			 
162f			      ld    (IX+0), E               ; Save ptr to next free block 
162f			      ld    (IX+1), D 
162f			      ld    (IX+2), L               ; Save ptr to prev free block 
162f			      ld    (IX+3), H 
162f			 
162f			      ld    A, B                    ; Check if DE is greater than BC 
162f			      cp    D                       ; Compare MSB first 
162f			      jr    Z, $+4                  ; MSB the same, compare LSB 
162f			      jr    NC, free_find_higher_block_skip 
162f			      ld    A, C 
162f			      cp    E                       ; Then compare LSB 
162f			      jr    C, free_found_higher_block 
162f			 
162f			free_find_higher_block_skip: 
162f			      ld    A, D                    ; Reached the end of the free list? 
162f			      or    E 
162f			      jp    Z, free_done 
162f			 
162f			      ex    DE, HL 
162f			 
162f			      jr    free_find_higher_block 
162f			 
162f			free_found_higher_block: 
162f			      ; Insert freed block between prev and next free blocks 
162f			      ld    (HL), C                 ; Point prev free block to freed block 
162f			      inc   HL 
162f			      ld    (HL), B 
162f			 
162f			      ld    H, B                    ; Point freed block at next free block 
162f			      ld    L, C 
162f			      ld    (HL), E 
162f			      inc   HL 
162f			      ld    (HL), D 
162f			 
162f			      ; Check if the freed block is adjacent to the next free block 
162f			      inc   HL                      ; Load size of freed block into HL 
162f			      ld    E, (HL) 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			      ex    DE, HL 
162f			 
162f			      add   HL, BC                  ; Add addr of freed block and its size 
162f			 
162f			      ld    E, (IX+0)               ; Load addr of next free block into DE 
162f			      ld    D, (IX+1) 
162f			 
162f			      or    A                       ; Clear the carry flag 
162f			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
162f			      jr    NZ, free_check_adjacent_to_prev 
162f			 
162f			      ; Freed block is adjacent to next, merge into one bigger block 
162f			      ex    DE, HL                  ; Load next ptr from next block into DE 
162f			      ld    E, (HL) 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			      push  HL                      ; Save ptr to next block for later 
162f			 
162f			      ld    H, B                    ; Store ptr from next block into freed block 
162f			      ld    L, C 
162f			      ld    (HL), E 
162f			      inc   HL 
162f			      ld    (HL), D 
162f			 
162f			      pop   HL                      ; Restore ptr to next block 
162f			      inc   HL                      ; Load size of next block into DE 
162f			      ld    E, (HL) 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			      push  DE                      ; Save next block size for later 
162f			 
162f			      ld    H, B                    ; Load size of freed block into HL 
162f			      ld    L, C 
162f			      inc   HL 
162f			      inc   HL 
162f			      ld    E, (HL) 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			      ex    DE, HL 
162f			 
162f			      pop   DE                      ; Restore size of next block 
162f			      add   HL, DE                  ; Add sizes of both blocks 
162f			      ex    DE, HL 
162f			 
162f			      ld    H, B                    ; Store new bigger size into freed block 
162f			      ld    L, C 
162f			      inc   HL 
162f			      inc   HL 
162f			      ld    (HL), E 
162f			      inc   HL 
162f			      ld    (HL), D 
162f			 
162f			free_check_adjacent_to_prev: 
162f			      ; Check if the freed block is adjacent to the prev free block 
162f			      ld    L, (IX+2)               ; Prev free block ptr into HL 
162f			      ld    H, (IX+3) 
162f			 
162f			      inc   HL                      ; Size of prev free block into DE 
162f			      inc   HL 
162f			      ld    E, (HL) 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			      dec   HL 
162f			      dec   HL 
162f			      dec   HL 
162f			 
162f			      add   HL, DE                  ; Add prev block addr and size 
162f			 
162f			      or    A                       ; Clear the carry flag 
162f			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
162f			      jr    NZ, free_done 
162f			 
162f			      ; Freed block is adjacent to prev, merge into one bigger block 
162f			      ld    H, B                    ; Load next ptr from freed block into DE 
162f			      ld    L, C 
162f			      ld    E, (HL) 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			      push  HL                      ; Save freed block ptr for later 
162f			 
162f			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
162f			      ld    H, (IX+3) 
162f			      ld    (HL), E 
162f			      inc   HL 
162f			      ld    (HL), D 
162f			 
162f			      pop   HL                      ; Restore freed block ptr 
162f			      inc   HL                      ; Load size of freed block into DE 
162f			      ld    E, (HL) 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			      push  DE                      ; Save freed block size for later 
162f			 
162f			      ld    L, (IX+2)               ; Load size of prev block into DE 
162f			      ld    H, (IX+3) 
162f			      inc   HL 
162f			      inc   HL 
162f			      ld    E, (HL) 
162f			      inc   HL 
162f			      ld    D, (HL) 
162f			 
162f			      pop   HL                      ; Add sizes of both blocks 
162f			      add   HL, DE 
162f			      ex    DE, HL 
162f			 
162f			      ld    L, (IX+2)               ; Store new bigger size into prev block 
162f			      ld    H, (IX+3) 
162f			      inc   HL 
162f			      inc   HL 
162f			      ld    (HL), E 
162f			      inc   HL 
162f			      ld    (HL), D 
162f			 
162f			free_done: 
162f			      ld    HL, 4                   ; Clean up stack frame 
162f			      add   HL, SP 
162f			      ld    SP, HL 
162f			 
162f			free_early_exit: 
162f			      pop   IX 
162f			      pop   DE 
162f			      pop   BC 
162f			 
162f			      ret 
162f			 
162f			 
162f			;      .org 0x8000 
162f			; 
162f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
162f			 ;                 .dw   0 
162f			 
162f			endif 
162f			 
162f			 
162f			if MALLOC_4 
162f			 
162f			; My memory allocation code. Very very simple.... 
162f			; allocate space under 250 chars 
162f			 
162f			heap_init: 
162f				; init start of heap as zero 
162f				;  
162f			 
162f				ld hl, heap_start 
162f				ld a, 0 
162f				ld (hl), a      ; empty block 
162f				inc hl 
162f				ld a, 0 
162f				ld (hl), a      ; length of block 
162f				; write end of list 
162f				inc hl 
162f				ld a,(hl) 
162f				inc hl 
162f				ld a,(hl) 
162f				 
162f			 
162f				; init some malloc vars 
162f			 
162f				ld hl, 0 
162f				ld (free_list), hl       ; store last malloc location 
162f			 
162f				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
162f				ld a, 0 
162f				ld (hl), a 
162f			 
162f			 
162f				ld hl, heap_start 
162f				;  
162f				  
162f				ret 
162f			 
162f			 
162f			;    free block marker 
162f			;    requested size  
162f			;    pointer to next block 
162f			;    .... 
162f			;    next block marker 
162f			 
162f			 
162f			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
162f			; 
162f			 
162f			 
162f			malloc:  
162f				push de 
162f				push bc 
162f				push af 
162f			 
162f				; hl space required 
162f				 
162f				ld c, l    ; hold space   (TODO only a max of 255) 
162f			 
162f			;	inc c     ; TODO BUG need to fix memory leak on push str 
162f			;	inc c 
162f			;	inc c 
162f			;	inc c 
162f			;	inc c 
162f			;	inc c 
162f			;	inc c 
162f			 
162f			 
162f			 
162f				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
162f			 
162f				ld a, (free_list+3) 
162f				cp 0 
162f				jr z, .contheap 
162f			 
162f				ld hl, (free_list)     ; get last alloc 
162f					if DEBUG_FORTH_MALLOC_INT 
162f						DMARK "mrs" 
162f						CALLMONITOR 
162f					endif 
162f				jr .startalloc 
162f			 
162f			.contheap: 
162f				ld hl, heap_start 
162f			 
162f			.startalloc: 
162f			 
162f					if DEBUG_FORTH_MALLOC_INT 
162f						DMARK "mym" 
162f						CALLMONITOR 
162f					endif 
162f			.findblock: 
162f					if DEBUG_FORTH_MALLOC_INT 
162f						DMARK "mmf" 
162f						CALLMONITOR 
162f					endif 
162f			 
162f				ld a,(hl)  
162f				; if byte is zero then clear to use 
162f			 
162f				cp 0 
162f				jr z, .foundemptyblock 
162f			 
162f				; if byte is not clear 
162f				;     then byte is offset to next block 
162f			 
162f				inc hl 
162f				ld a, (hl) ; get size 
162f			.nextblock:	inc hl 
162f					ld e, (hl) 
162f					inc hl 
162f					ld d, (hl) 
162f					ex de, hl 
162f			;	inc hl  ; move past the store space 
162f			;	inc hl  ; move past zero index  
162f			 
162f				; TODO detect no more space 
162f			 
162f				push hl 
162f				ld de, heap_end 
162f				call cmp16 
162f				pop hl 
162f				jr nc, .nospace 
162f			 
162f				jr .findblock 
162f			 
162f			.nospace: ld hl, 0 
162f				jp .exit 
162f			 
162f			 
162f			.foundemptyblock:	 
162f					if DEBUG_FORTH_MALLOC_INT 
162f						DMARK "mme" 
162f						CALLMONITOR 
162f					endif 
162f			 
162f			; TODO has block enough space if reusing??? 
162f			 
162f				;  
162f			 
162f			; see if this block has been previously used 
162f				inc hl 
162f				ld a, (hl) 
162f				dec hl 
162f				cp 0 
162f				jr z, .newblock 
162f			 
162f					if DEBUG_FORTH_MALLOC_INT 
162f						DMARK "meR" 
162f						CALLMONITOR 
162f					endif 
162f			 
162f			; no reusing previously allocated block 
162f			 
162f			; is it smaller than previously used? 
162f				 
162f				inc hl    ; move to size 
162f				ld a, c 
162f				sub (hl)        ; we want c < (hl) 
162f				dec hl    ; move back to marker 
162f			        jr z, .findblock 
162f			 
162f				; update with the new size which should be lower 
162f			 
162f			        ;inc  hl   ; negate next move. move back to size  
162f			 
162f			.newblock: 
162f				; need to be at marker here 
162f			 
162f					if DEBUG_FORTH_MALLOC_INT 
162f						DMARK "meN" 
162f						CALLMONITOR 
162f					endif 
162f			 
162f			 
162f				ld a, c 
162f			 
162f				ld (free_list+3), a	 ; flag resume from last malloc  
162f				ld (free_list), hl    ; save out last location 
162f			 
162f			 
162f				;inc a     ; space for length byte 
162f				ld (hl), a     ; save block in use marker 
162f			 
162f				inc hl   ; move to space marker 
162f				ld (hl), a    ; save new space 
162f			 
162f				inc hl   ; move to start of allocated area 
162f				 
162f			;	push hl     ; save where we are - 1  
162f			 
162f			;	inc hl  ; move past zero index  
162f				; skip space to set down new marker 
162f			 
162f				; provide some extra space for now 
162f			 
162f				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
162f				inc a 
162f				inc a 
162f			 
162f				push hl   ; save where we are in the node block 
162f			 
162f				call addatohl 
162f			 
162f				; write linked list point 
162f			 
162f				pop de     ; get our node position 
162f				ex de, hl 
162f			 
162f				ld (hl), e 
162f				inc hl 
162f				ld (hl), d 
162f			 
162f				inc hl 
162f			 
162f				; now at start of allocated data so save pointer 
162f			 
162f				push hl 
162f			 
162f				; jump to position of next node and setup empty header in DE 
162f			 
162f				ex de, hl 
162f			 
162f			;	inc hl ; move past end of block 
162f			 
162f				ld a, 0 
162f				ld (hl), a   ; empty marker 
162f				inc hl 
162f				ld (hl), a   ; size 
162f				inc hl  
162f				ld (hl), a   ; ptr 
162f				inc hl 
162f				ld (hl), a   ; ptr 
162f			 
162f			 
162f				pop hl 
162f			 
162f					if DEBUG_FORTH_MALLOC_INT 
162f						DMARK "mmr" 
162f						CALLMONITOR 
162f					endif 
162f			 
162f			.exit: 
162f				pop af 
162f				pop bc 
162f				pop de  
162f				ret 
162f			 
162f			 
162f			 
162f			 
162f			free:  
162f				push hl 
162f				push af 
162f				; get address in hl 
162f			 
162f					if DEBUG_FORTH_MALLOC_INT 
162f						DMARK "fre" 
162f						CALLMONITOR 
162f					endif 
162f				; data is at hl - move to block count 
162f				dec hl 
162f				dec hl    ; get past pointer 
162f				dec hl 
162f			 
162f				ld a, (hl)    ; need this for a validation check 
162f			 
162f				dec hl    ; move to block marker 
162f			 
162f				; now check that the block count and block marker are the same  
162f			        ; this checks that we are on a malloc node and not random memory 
162f			        ; OK a faint chance this could be a problem but rare - famous last words! 
162f			 
162f				ld c, a 
162f				ld a, (hl)    
162f			 
162f				cp c 
162f				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
162f			 
162f				; yes good chance we are on a malloc node 
162f			 
162f				ld a, 0      
162f				ld (hl), a   ; mark as free 
162f			 
162f				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
162f			 
162f			.freeignore:  
162f			 
162f				pop af 
162f				pop hl 
162f			 
162f				ret 
162f			 
162f			 
162f			 
162f			endif 
162f			 
162f			; eof 
# End of file firmware_memory.asm
162f			  
162f			; device C  
162f			; Now handled by SPI  
162f			;if SOUND_ENABLE  
162f			;	include "firmware_sound.asm"  
162f			;endif  
162f			  
162f			include "firmware_diags.asm"  
162f			; Hardware diags menu 
162f			 
162f			 
162f			config: 
162f			 
162f 3e 00			ld a, 0 
1631 21 5a 16			ld hl, .configmn 
1634 cd cc 0d			call menu 
1637			 
1637 fe 00			cp 0 
1639 c8				ret z 
163a			 
163a			;	cp 1 
163a			;	call z, .savetostore 
163a			 
163a fe 01			cp 1 
163c			if STARTUP_V1 
163c				call z, .selautoload 
163c			endif 
163c			 
163c			if STARTUP_V2 
163c cc 68 16			call z, .enautoload 
163f			endif 
163f fe 02			cp 2 
1641 cc 7f 16			call z, .disautoload 
1644			;	cp 3 
1644			;	call z, .selbank 
1644 fe 03			cp 3 
1646 cc f1 18			call z, .debug_tog 
1649 fe 04			cp 4 
164b cc 3f 1a			call z, .bpsgo 
164e fe 05			cp 5 
1650 cc 1a 19			call z, hardware_diags 
1653			if STARTUP_V2 
1653 fe 06			cp 6 
1655 cc ab 16			call z, create_startup 
1658			endif 
1658 18 d5			jr config 
165a			 
165a			.configmn: 
165a			;	dw prom_c3 
165a 2d 1c			dw prom_c2 
165c 43 1c			dw prom_c2a 
165e			;	dw prom_c2b 
165e			;	dw prom_c4 
165e b0 1c			dw prom_m4 
1660 cb 1c			dw prom_m4b 
1662 d3 1c			dw prom_c1 
1664			if STARTUP_V2 
1664 e2 1c			dw prom_c9 
1666			endif 
1666 00 00			dw 0 
1668				 
1668			 
1668			if STARTUP_V2 
1668			.enautoload: 
1668				if STORAGE_SE 
1668 3e fe			ld a, $fe      ; bit 0 clear 
166a 32 5d fa			ld (spi_device), a 
166d			 
166d cd 16 05			call storage_get_block_0 
1670			 
1670 3e 01			ld a, 1 
1672 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
1675			 
1675 21 00 00				ld hl, 0 
1678 11 77 fa				ld de, store_page 
167b cd ca 04			call storage_write_block	 ; save update 
167e				else 
167e			 
167e				ld hl, prom_notav 
167e				ld de, prom_empty 
167e				call info_panel 
167e				endif 
167e			 
167e			 
167e c9				ret 
167f			endif 
167f			 
167f			.disautoload: 
167f				if STORAGE_SE 
167f 3e fe			ld a, $fe      ; bit 0 clear 
1681 32 5d fa			ld (spi_device), a 
1684			 
1684 cd 16 05			call storage_get_block_0 
1687			 
1687 3e 00			ld a, 0 
1689 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
168c			 
168c 21 00 00				ld hl, 0 
168f 11 77 fa				ld de, store_page 
1692 cd ca 04			call storage_write_block	 ; save update 
1695				else 
1695			 
1695				ld hl, prom_notav 
1695				ld de, prom_empty 
1695				call info_panel 
1695				endif 
1695			 
1695			 
1695 c9				ret 
1696			 
1696			if STARTUP_V1 
1696			 
1696			; Select auto start 
1696			 
1696			.selautoload: 
1696			 
1696				 
1696				if STORAGE_SE 
1696			 
1696					call config_dir 
1696				        ld hl, scratch 
1696					ld a, 0 
1696					call menu 
1696			 
1696					cp 0 
1696					ret z 
1696			 
1696					dec a 
1696			 
1696			 
1696					; locate menu option 
1696			 
1696					ld hl, scratch 
1696					call table_lookup 
1696			 
1696					if DEBUG_FORTH_WORDS 
1696						DMARK "ALl" 
1696						CALLMONITOR 
1696					endif 
1696					; with the pointer to the menu it, the byte following the zero term is the file id 
1696			 
1696					ld a, 0 
1696					ld bc, 50   ; max of bytes to look at 
1696					cpir  
1696			 
1696					if DEBUG_FORTH_WORDS 
1696						DMARK "ALb" 
1696						CALLMONITOR 
1696					endif 
1696					;inc hl 
1696			 
1696					ld a, (hl)   ; file id 
1696					 
1696				        ; save bank and file ids 
1696			 
1696					push af 
1696			 
1696			; TODO need to save to block 0 on bank 1	 
1696			 
1696					call storage_get_block_0 
1696			 
1696					if DEBUG_FORTH_WORDS 
1696						DMARK "AL0" 
1696						CALLMONITOR 
1696					endif 
1696					pop af 
1696			 
1696					ld (store_page+STORE_0_FILERUN),a 
1696					 
1696					; save bank id 
1696			 
1696					ld a,(spi_device) 
1696					ld (store_page+STORE_0_BANKRUN),a 
1696			 
1696					; enable auto run of store file 
1696			 
1696					ld a, 1 
1696					ld (store_page+STORE_0_AUTOFILE),a 
1696			 
1696					; save buffer 
1696			 
1696					ld hl, 0 
1696					ld de, store_page 
1696					if DEBUG_FORTH_WORDS 
1696						DMARK "ALw" 
1696						CALLMONITOR 
1696					endif 
1696				call storage_write_block	 ; save update 
1696			  
1696			 
1696			 
1696			 
1696					ld hl, scratch 
1696					call config_fdir 
1696			 
1696				else 
1696			 
1696				ld hl, prom_notav 
1696				ld de, prom_empty 
1696				call info_panel 
1696			 
1696				endif 
1696				ret 
1696			endif 
1696			 
1696			 
1696			; Select storage bank 
1696			 
1696			.selbank: 
1696			 
1696			;	if STORAGE_SE 
1696			;	else 
1696			 
1696 21 f7 1c			ld hl, prom_notav 
1699 11 0d 1d			ld de, prom_empty 
169c cd 2c 0d			call info_panel 
169f			;	endif 
169f				 
169f c9				ret 
16a0			 
16a0			if STORAGE_SE 
16a0			 
16a0			.config_ldir:   
16a0				; Load storage bank labels into menu array 
16a0			 
16a0				 
16a0			 
16a0			 
16a0 c9				ret 
16a1			 
16a1			 
16a1			endif 
16a1			 
16a1			 
16a1			; Save user words to storage 
16a1			 
16a1			.savetostore: 
16a1			 
16a1			;	if STORAGE_SE 
16a1			; 
16a1			;		call config_dir 
16a1			;	        ld hl, scratch 
16a1			;		ld a, 0 
16a1			;		call menu 
16a1			;		 
16a1			;		ld hl, scratch 
16a1			;		call config_fdir 
16a1			; 
16a1			;	else 
16a1			 
16a1 21 f7 1c			ld hl, prom_notav 
16a4 11 0d 1d			ld de, prom_empty 
16a7 cd 2c 0d			call info_panel 
16aa			 
16aa			;	endif 
16aa			 
16aa c9				ret 
16ab			 
16ab			if STARTUP_V2 
16ab			 
16ab			create_startup: 
16ab			 
16ab 3e 00			ld a, 0 
16ad 21 18 18			ld hl, .crstart 
16b0 cd cc 0d			call menu 
16b3			 
16b3 fe 00			cp 0 
16b5 c8				ret z 
16b6			 
16b6 fe 01			cp 1 
16b8 cc e5 16			call z, .genlsword 
16bb fe 02			cp 2 
16bd cc ef 16			call z, .genedword 
16c0			 
16c0 fe 03			cp 3 
16c2 cc f9 16			call z, .gendemword 
16c5			 
16c5 fe 04			cp 4 
16c7 cc 03 17			call z, .genutlword 
16ca fe 05			cp 5 
16cc cc 0d 17			call z, .genspiword 
16cf fe 06			cp 6 
16d1 cc 17 17			call z, .genkeyword 
16d4 fe 07			cp 7 
16d6 cc db 16			call z, .gensoundword 
16d9 18 d0			jr create_startup 
16db			 
16db			.gensoundword: 
16db 21 9b 1c			ld hl, crs_sound 
16de 11 64 17			ld de, .soundworddef 
16e1 cd 21 17			call .genfile 
16e4 c9				ret 
16e5			.genlsword: 
16e5 21 5a 1c			ld hl, crs_s1 
16e8 11 8c 17			ld de, .lsworddef 
16eb cd 21 17			call .genfile 
16ee c9				ret 
16ef			 
16ef			.genedword: 
16ef 11 90 17			ld de, .edworddef 
16f2 21 63 1c			ld hl, crs_s2 
16f5 cd 21 17			call .genfile 
16f8 c9				ret 
16f9			 
16f9			.gendemword: 
16f9 11 98 17			ld de, .demoworddef 
16fc 21 6c 1c			ld hl, crs_s3 
16ff cd 21 17			call .genfile 
1702 c9				ret 
1703			 
1703			.genutlword: 
1703 21 7b 1c			ld hl, crs_s4 
1706 11 78 17			ld de, .utilwordef 
1709 cd 21 17			call .genfile 
170c c9				ret 
170d			.genspiword: 
170d 21 82 1c			ld hl, crs_s5 
1710 11 de 17			ld de, .spiworddef 
1713 cd 21 17			call .genfile 
1716 c9				ret 
1717			.genkeyword: 
1717 21 8c 1c			ld hl, crs_s6 
171a 11 ec 17			ld de, .keyworddef 
171d cd 21 17			call .genfile 
1720 c9				ret 
1721			 
1721			; hl - points to file name 
1721			; de - points to strings to add to file 
1721			 
1721			.genfile: 
1721 e5				push hl 
1722 d5				push de 
1723			 
1723 cd 9b 0d			call clear_display 
1726 3e 00			ld a, display_row_1 
1728 11 53 17			ld de, .genfiletxt 
172b cd ae 0d			call str_at_display 
172e cd be 0d			call update_display 
1731			 
1731 d1				pop de 
1732 e1				pop hl 
1733			 
1733			 
1733 d5				push de 
1734 cd 68 08			call storage_create 
1737				; id in hl 
1737 d1				pop de   ; table of strings to add 
1738			 
1738			.genloop: 
1738			 
1738 e5				push hl ; save id for next time around 
1739 d5				push de ; save de for next time around 
173a			 
173a eb				ex de, hl 
173b cd 2a 24			call loadwordinhl 
173e eb				ex de, hl 
173f			 
173f				; need hl to be the id 
173f				; need de to be the string ptr 
173f				 
173f cd 55 0b			call storage_append 
1742			 
1742 d1				pop de 
1743 e1				pop hl 
1744			 
1744 13				inc de 
1745 13				inc de 
1746			 
1746 1a				ld a,(de) 
1747 fe 00			cp 0 
1749 20 ed			jr nz, .genloop 
174b 13				inc de 
174c 1a				ld a, (de) 
174d 1b				dec de 
174e fe 00			cp 0 
1750 20 e6			jr nz, .genloop	 
1752			 
1752 c9				ret 
1753			 
1753 .. 00		.genfiletxt:  db "Creating file...",0 
1764			 
1764			.soundworddef: 
1764 76 6a			dw sound1 
1766 9a 6a			dw sound2 
1768 ca 6a			dw sound3 
176a ef 6a			dw sound4 
176c fc 6a			dw sound5 
176e 09 6b			dw sound6 
1770 16 6b			dw sound7 
1772 23 6b			dw sound8 
1774 3b 6b			dw sound9 
1776 00 00			dw 0 
1778			 
1778			.utilwordef: 
1778 c7 63			dw strncpy 
177a a2 63			dw type 
177c 6e 63			dw clrstack 
177e 27 63			dw longread 
1780 28 64			dw start1 
1782 38 64			dw start2 
1784 49 64			dw start3b 
1786 c4 64			dw start3c 
1788 24 65			dw list 
178a 00 00			dw 0 
178c			 
178c			.lsworddef: 
178c 49 64			dw start3b 
178e 00 00			dw 0 
1790			 
1790			.edworddef: 
1790 86 5f			dw edit1 
1792 a7 5f			dw edit2 
1794 dc 5f			dw edit3 
1796 00 00			dw 0 
1798			 
1798			.demoworddef: 
1798 6c 69			dw test5 
179a a4 69			dw test6 
179c dc 69			dw test7 
179e f0 69			dw test8 
17a0 1c 6a			dw test9 
17a2 32 6a			dw test10 
17a4 52 6b			dw game1 
17a6 63 6b			dw game1a 
17a8 c5 6b			dw game1b 
17aa fa 6b			dw game1c 
17ac 30 6c			dw game1d 
17ae 61 6c			dw game1s 
17b0 75 6c			dw game1t 
17b2 8a 6c			dw game1f 
17b4 be 6c			dw game1z 
17b6 02 6d			dw game1zz 
17b8 6b 6d			dw ssv2 
17ba a1 6d			dw ssv3 
17bc bd 6d			dw ssv4 
17be d9 6d			dw ssv5 
17c0 f2 6d			dw ssv1 
17c2 3a 6e			dw ssv1cpm	 
17c4 91 6e			dw game2b 
17c6 ff 6e			dw game2bf 
17c8 49 6f			dw game2mba 
17ca df 6f			dw game2mbas	 
17cc 04 70			dw game2mbht 
17ce 13 70			dw game2mbms 
17d0 21 70			dw game2mb 
17d2 9e 70			dw game3w 
17d4 cc 70			dw game3p 
17d6 ea 70			dw game3sc 
17d8 1b 71			dw game3vsi 
17da 47 71			dw game3vs 
17dc 00 00			dw 0 
17de			 
17de			 
17de			.spiworddef: 
17de			 
17de 14 60		    dw spi1 
17e0 6d 60		    dw spi2 
17e2 a1 60		    dw spi2b 
17e4 25 61		    dw spi3 
17e6 cf 60		    dw spi4 
17e8 f8 60		    dw spi5 
17ea			;    dw spi6 
17ea			;    dw spi7 
17ea			 
17ea			;    dw spi8 
17ea			;    dw spi9 
17ea			;    dw spi10 
17ea 00 00		    dw 0 
17ec			 
17ec			.keyworddef: 
17ec			 
17ec 86 71			dw keyup 
17ee 94 71			dw keydown 
17f0 a4 71			dw keyleft 
17f2 b4 71			dw keyright 
17f4 c5 71			dw 	keyf1 
17f6 d3 71			dw keyf2 
17f8 e1 71			dw keyf3 
17fa ef 71			dw keyf4 
17fc fd 71			dw keyf5 
17fe 0b 72			dw keyf6 
1800 19 72			dw keyf7 
1802 27 72			dw keyf8 
1804 35 72			dw keyf9 
1806 43 72			dw keyf10 
1808 52 72			dw keyf11 
180a 61 72			dw keyf12 
180c 70 72			dw keytab 
180e 7f 72			dw keycr 
1810 8d 72			dw keyhome 
1812 9d 72			dw keyend 
1814 ac 72			dw keybs 
1816 00 00			dw 0 
1818			 
1818			.crstart: 
1818 5a 1c			dw crs_s1 
181a 63 1c			dw crs_s2 
181c 6c 1c			dw crs_s3 
181e 7b 1c			dw crs_s4 
1820 82 1c			dw crs_s5 
1822 8c 1c			dw crs_s6 
1824 9b 1c			dw crs_sound 
1826 00 00			dw 0 
1828			 
1828			endif 
1828			 
1828			 
1828			if STORAGE_SE 
1828			 
1828			config_fdir: 
1828				; using the scratch dir go through and release the memory allocated for each string 
1828				 
1828 21 be f1			ld hl, scratch 
182b 5e			.cfdir:	ld e,(hl) 
182c 23				inc hl 
182d 56				ld d,(hl) 
182e 23				inc hl 
182f			 
182f eb				ex de, hl 
1830 cd f8 0f			call ishlzero 
1833 c8				ret z     ; return on null pointer 
1834 cd 60 15			call free 
1837 eb				ex de, hl 
1838 18 f1			jr .cfdir 
183a			 
183a			 
183a c9				ret 
183b			 
183b			 
183b			config_dir: 
183b			 
183b				; for the config menus that need to build a directory of storage call this routine 
183b				; it will construct a menu in scratch to pass to menu 
183b			 
183b				; open storage device 
183b			 
183b				; execute DIR to build a list of files and their ids into scratch in menu format 
183b				; once the menu has finished then will need to call config_fdir to release the strings 
183b				 
183b				; c = number items 
183b			 
183b				 
183b cd 16 05			call storage_get_block_0 
183e			 
183e 21 77 fa			ld hl, store_page     ; get current id count 
1841 46				ld b, (hl) 
1842 0e 00			ld c, 0    ; count of files   
1844			 
1844			 
1844 21 be f1			ld hl, scratch 
1847 22 6e fa			ld (store_tmp2), hl    ; location to poke strings 
184a			 
184a				; check for empty drive 
184a			 
184a 3e 00			ld a, 0 
184c b8				cp b 
184d ca e7 18			jp z, .dirdone 
1850			 
1850				 
1850					if DEBUG_FORTH_WORDS 
1850						DMARK "Cdc" 
1850 f5				push af  
1851 3a 65 18			ld a, (.dmark)  
1854 32 68 fe			ld (debug_mark),a  
1857 3a 66 18			ld a, (.dmark+1)  
185a 32 69 fe			ld (debug_mark+1),a  
185d 3a 67 18			ld a, (.dmark+2)  
1860 32 6a fe			ld (debug_mark+2),a  
1863 18 03			jr .pastdmark  
1865 ..			.dmark: db "Cdc"  
1868 f1			.pastdmark: pop af  
1869			endm  
# End of macro DMARK
1869						CALLMONITOR 
1869 cd 6c fe			call debug_vector  
186c				endm  
# End of macro CALLMONITOR
186c					endif 
186c			 
186c			 
186c			.diritem:	 
186c c5				push bc 
186d				; for each of the current ids do a search for them and if found push to stack 
186d			 
186d 21 40 00				ld hl, STORE_BLOCK_PHY 
1870 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1872 58					ld e,b 
1873			 
1873 cd 98 07				call storage_findnextid 
1876			 
1876			 
1876					; if found hl will be non zero 
1876			 
1876 cd f8 0f				call ishlzero 
1879 28 69				jr z, .dirnotfound 
187b			 
187b					; increase count 
187b			 
187b c1					pop bc	 
187c 0c					inc c 
187d c5					push bc 
187e					 
187e			 
187e					; get file header and push the file name 
187e			 
187e 11 77 fa				ld de, store_page 
1881 cd 65 04				call storage_read_block 
1884			 
1884					; push file id to stack 
1884				 
1884 3a 77 fa				ld a, (store_page) 
1887 26 00				ld h, 0 
1889 6f					ld l, a 
188a			 
188a					;call forth_push_numhl 
188a					; TODO store id 
188a			 
188a e5					push hl 
188b			 
188b					; push extent count to stack  
188b				 
188b 21 7a fa				ld hl, store_page+3 
188e			 
188e					; get file name length 
188e			 
188e cd 2d 14				call strlenz   
1891			 
1891 23					inc hl   ; cover zero term 
1892 23					inc hl  ; stick the id at the end of the area 
1893			 
1893 e5					push hl 
1894 c1					pop bc    ; move length to bc 
1895			 
1895 cd 96 14				call malloc 
1898			 
1898					; TODO save malloc area to scratch 
1898			 
1898 eb					ex de, hl 
1899 2a 6e fa				ld hl, (store_tmp2) 
189c 73					ld (hl), e 
189d 23					inc hl 
189e 72					ld (hl), d 
189f 23					inc hl 
18a0 22 6e fa				ld (store_tmp2), hl 
18a3			 
18a3					 
18a3			 
18a3					;pop hl   ; get source 
18a3			;		ex de, hl    ; swap aronund	 
18a3			 
18a3 21 7a fa				ld hl, store_page+3 
18a6					if DEBUG_FORTH_WORDS 
18a6						DMARK "CFd" 
18a6 f5				push af  
18a7 3a bb 18			ld a, (.dmark)  
18aa 32 68 fe			ld (debug_mark),a  
18ad 3a bc 18			ld a, (.dmark+1)  
18b0 32 69 fe			ld (debug_mark+1),a  
18b3 3a bd 18			ld a, (.dmark+2)  
18b6 32 6a fe			ld (debug_mark+2),a  
18b9 18 03			jr .pastdmark  
18bb ..			.dmark: db "CFd"  
18be f1			.pastdmark: pop af  
18bf			endm  
# End of macro DMARK
18bf						CALLMONITOR 
18bf cd 6c fe			call debug_vector  
18c2				endm  
# End of macro CALLMONITOR
18c2					endif 
18c2 ed b0				ldir 
18c4			 
18c4					; de is past string, move back one and store id 
18c4					 
18c4 1b					dec de 
18c5			 
18c5					; store file id 
18c5			 
18c5 e1					pop hl 
18c6 eb					ex de,hl 
18c7 73					ld (hl), e 
18c8			 
18c8					if DEBUG_FORTH_WORDS 
18c8						DMARK "Cdi" 
18c8 f5				push af  
18c9 3a dd 18			ld a, (.dmark)  
18cc 32 68 fe			ld (debug_mark),a  
18cf 3a de 18			ld a, (.dmark+1)  
18d2 32 69 fe			ld (debug_mark+1),a  
18d5 3a df 18			ld a, (.dmark+2)  
18d8 32 6a fe			ld (debug_mark+2),a  
18db 18 03			jr .pastdmark  
18dd ..			.dmark: db "Cdi"  
18e0 f1			.pastdmark: pop af  
18e1			endm  
# End of macro DMARK
18e1						CALLMONITOR 
18e1 cd 6c fe			call debug_vector  
18e4				endm  
# End of macro CALLMONITOR
18e4					endif 
18e4					 
18e4			.dirnotfound: 
18e4 c1					pop bc     
18e5 10 85				djnz .diritem 
18e7				 
18e7			.dirdone:	 
18e7			 
18e7 3e 00				ld a, 0 
18e9 2a 6e fa				ld hl, (store_tmp2) 
18ec 77					ld (hl), a 
18ed 23					inc hl 
18ee 77					ld (hl), a 
18ef 23					inc hl 
18f0					; push a count of the dir items found 
18f0			 
18f0			;		ld h, 0 
18f0			;		ld l, c 
18f0			 
18f0 c9				ret 
18f1			 
18f1			endif 
18f1			 
18f1			 
18f1			; Settings 
18f1			; Run  
18f1			 
18f1			 
18f1			 
18f1			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
18f1			;;hd_menu2:   db "        2: Editor",0   
18f1			;hd_menu2:   db "        2: Editor       6: Menu",0   
18f1			;hd_menu3:   db "        3: Storage",0 
18f1			;hd_menu4:   db "0=quit  4: Debug",0 
18f1			;hd_don:     db "ON",0 
18f1			;hd_doff:     db "OFF",0 
18f1			; 
18f1			; 
18f1			; 
18f1			;hardware_diags_old:       
18f1			; 
18f1			;.diagmenu: 
18f1			;	call clear_display 
18f1			;	ld a, display_row_1 
18f1			;	ld de, hd_menu1 
18f1			;	call str_at_display 
18f1			; 
18f1			;	ld a, display_row_2 
18f1			;	ld de, hd_menu2 
18f1			;	call str_at_display 
18f1			; 
18f1			;	ld a, display_row_3 
18f1			;	ld de, hd_menu3 
18f1			;	call str_at_display 
18f1			; 
18f1			;	ld a,  display_row_4 
18f1			;	ld de, hd_menu4 
18f1			;	call str_at_display 
18f1			; 
18f1			;	; display debug state 
18f1			; 
18f1			;	ld de, hd_don 
18f1			;	ld a, (os_view_disable) 
18f1			;	cp 0 
18f1			;	jr z, .distog 
18f1			;	ld de, hd_doff 
18f1			;.distog: ld a, display_row_4+17 
18f1			;	call str_at_display 
18f1			; 
18f1			;	call update_display 
18f1			; 
18f1			;	call cin_wait 
18f1			; 
18f1			; 
18f1			; 
18f1			;	cp '4' 
18f1			;	jr nz, .diagn1 
18f1			; 
18f1			;	; debug toggle 
18f1			; 
18f1			;	ld a, (os_view_disable) 
18f1			;	ld b, '*' 
18f1			;	cp 0 
18f1			;	jr z, .debtog 
18f1			;	ld b, 0 
18f1			;.debtog:	 
18f1			;	ld a,b 
18f1			;	ld (os_view_disable),a 
18f1			; 
18f1			;.diagn1: cp '0' 
18f1			;	 ret z 
18f1			; 
18f1			;;	cp '1' 
18f1			;;       jp z, matrix	 
18f1			;;   TODO keyboard matrix test 
18f1			; 
18f1			;	cp '2' 
18f1			;	jp z, .diagedit 
18f1			; 
18f1			;;	cp '6' 
18f1			;;	jp z, .menutest 
18f1			;;if ENABLE_BASIC 
18f1			;;	cp '6' 
18f1			;;	jp z, basic 
18f1			;;endif 
18f1			 ; 
18f1			;	jp .diagmenu 
18f1			; 
18f1			; 
18f1			;	ret 
18f1			 
18f1			 
18f1			.debug_tog: 
18f1 21 3b 19			ld hl, .menudebug 
18f4				 
18f4			;	ld a, (os_view_disable) 
18f4			;	cp '*' 
18f4 3a 6c fe			ld a,(debug_vector) 
18f7 fe c9			cp $C9   ; RET 
18f9 20 04			jr nz,.tdon  
18fb 3e 01			ld a, 1 
18fd 18 02			jr .tog1 
18ff 3e 00		.tdon: ld a, 0 
1901			 
1901			.tog1: 
1901 cd cc 0d			call menu 
1904 fe 00			cp 0 
1906 c8				ret z 
1907 fe 01			cp 1    ; disable debug 
1909 28 04			jr z, .dtog0 
190b 3e 2a			ld a, '*' 
190d 18 05			jr .dtogset 
190f			.dtog0:  
190f				;ld a, 0 
190f cd 2d 1a			call bp_on 
1912 18 dd			jr .debug_tog 
1914			.dtogset:  
1914				; ld (os_view_disable), a 
1914 cd 39 1a			call bp_off 
1917 c3 f1 18			jp .debug_tog 
191a			 
191a			 
191a			hardware_diags:       
191a			 
191a			.diagm: 
191a 21 2d 19			ld hl, .menuitems 
191d 3e 00			ld a, 0 
191f cd cc 0d			call menu 
1922			 
1922 fe 00		         cp 0 
1924 c8				 ret z 
1925			 
1925 fe 02			cp 2 
1927 ca 86 19			jp z, .diagedit 
192a			 
192a			;	cp '6' 
192a			;	jp z, .menutest 
192a			;if ENABLE_BASIC 
192a			;	cp '6' 
192a			;	jp z, basic 
192a			;endif 
192a			  
192a c3 1a 19			jp .diagm 
192d			 
192d				 
192d 41 19		.menuitems:   	dw .m1 
192f 4c 19				dw .m2 
1931 53 19				dw .m3 
1933 5b 19				dw .m5 
1935 61 19				dw .m5a 
1937 6a 19				dw .m5b 
1939 00 00				dw 0 
193b			 
193b			.menudebug: 
193b 73 19				dw .m6 
193d 7c 19				dw .m7 
193f 00 00				dw 0 
1941			 
1941 .. 00		.m1:   db "Key Matrix",0 
194c .. 00		.m2:   db "Editor",0 
1953 .. 00		.m3:   db "Storage",0 
195b .. 00		.m5:   db "Sound",0 
1961 .. 00		.m5a:  db "RAM Test",0 
196a .. 00		.m5b:  db "LCD Test",0 
1973			 
1973 .. 00		.m6:   db "Debug ON",0 
197c .. 00		.m7:   db "Debug OFF",0 
1986			 
1986			; debug editor 
1986			 
1986			.diagedit: 
1986			 
1986 21 be f1			ld hl, scratch 
1989			;	ld bc, 250 
1989			;	ldir 
1989				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1989 3e 00			ld a, 0 
198b 77				ld (hl), a 
198c 23				inc hl 
198d 77				ld (hl), a 
198e 23				inc hl 
198f 77				ld (hl), a 
1990			 
1990 cd 9b 0d		        call clear_display 
1993 cd be 0d			call update_display 
1996				;ld a, 1 
1996				;ld (hardware_diag), a 
1996			.diloop: 
1996 3e 00			ld a, display_row_1 
1998 0e 00			ld c, 0 
199a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
199c 1e 28			ld e, 40 
199e			 
199e 21 be f1			ld hl, scratch	 
19a1 cd fc 0f			call input_str 
19a4			 
19a4 3e 28			ld a, display_row_2 
19a6 11 be f1			ld de, scratch 
19a9 cd ae 0d			call str_at_display 
19ac cd be 0d			call update_display 
19af			 
19af c3 96 19			jp .diloop 
19b2			 
19b2			 
19b2			; pass word in hl 
19b2			; a has display location 
19b2			display_word_at: 
19b2 f5				push af 
19b3 e5				push hl 
19b4 7c				ld a,h 
19b5 21 c3 f4			ld hl, os_word_scratch 
19b8 cd d0 12			call hexout 
19bb e1				pop hl 
19bc 7d				ld a,l 
19bd 21 c5 f4			ld hl, os_word_scratch+2 
19c0 cd d0 12			call hexout 
19c3 21 c7 f4			ld hl, os_word_scratch+4 
19c6 3e 00			ld a,0 
19c8 77				ld (hl),a 
19c9 11 c3 f4			ld de,os_word_scratch 
19cc f1				pop af 
19cd cd ae 0d				call str_at_display 
19d0 c9				ret 
19d1			 
19d1			display_ptr_state: 
19d1			 
19d1				; to restore afterwards 
19d1			 
19d1 d5				push de 
19d2 c5				push bc 
19d3 e5				push hl 
19d4 f5				push af 
19d5			 
19d5				; for use in here 
19d5			 
19d5			;	push bc 
19d5			;	push de 
19d5			;	push hl 
19d5			;	push af 
19d5			 
19d5 cd 9b 0d			call clear_display 
19d8			 
19d8 11 b0 1b			ld de, .ptrstate 
19db 3e 00			ld a, display_row_1 
19dd cd ae 0d			call str_at_display 
19e0			 
19e0				; display debug step 
19e0			 
19e0			 
19e0 11 68 fe			ld de, debug_mark 
19e3 3e 26			ld a, display_row_1+display_cols-2 
19e5 cd ae 0d			call str_at_display 
19e8			 
19e8				; display a 
19e8 11 ba 1b			ld de, .ptrcliptr 
19eb 3e 28			ld a, display_row_2 
19ed cd ae 0d			call str_at_display 
19f0			 
19f0 f1				pop af 
19f1 2a 3d fa			ld hl,(cli_ptr) 
19f4 3e 30			ld a, display_row_2+8 
19f6 cd b2 19			call display_word_at 
19f9			 
19f9			 
19f9				; display hl 
19f9			 
19f9			 
19f9 11 c2 1b			ld de, .ptrclioptr 
19fc 3e 32			ld a, display_row_2+10 
19fe cd ae 0d			call str_at_display 
1a01			; 
1a01			;	pop hl 
1a01 3e 35			ld a, display_row_2+13 
1a03 2a 3b fa			ld hl,(cli_origptr) 
1a06 cd b2 19			call display_word_at 
1a09			; 
1a09			;	 
1a09			;	; display de 
1a09			 
1a09			;	ld de, .regstatede 
1a09			;	ld a, display_row_3 
1a09			;	call str_at_display 
1a09			 
1a09			;	pop de 
1a09			;	ld h,d 
1a09			;	ld l, e 
1a09			;	ld a, display_row_3+3 
1a09			;	call display_word_at 
1a09			 
1a09			 
1a09				; display bc 
1a09			 
1a09			;	ld de, .regstatebc 
1a09			;	ld a, display_row_3+10 
1a09			;	call str_at_display 
1a09			 
1a09			;	pop bc 
1a09			;	ld h,b 
1a09			;	ld l, c 
1a09			;	ld a, display_row_3+13 
1a09			;	call display_word_at 
1a09			 
1a09			 
1a09				; display dsp 
1a09			 
1a09			;	ld de, .regstatedsp 
1a09			;	ld a, display_row_4 
1a09			;	call str_at_display 
1a09			 
1a09				 
1a09			;	ld hl,(cli_data_sp) 
1a09			;	ld a, display_row_4+4 
1a09			;	call display_word_at 
1a09			 
1a09				; display rsp 
1a09			 
1a09 11 f1 1b			ld de, .regstatersp 
1a0c 3e 82			ld a, display_row_4+10 
1a0e cd ae 0d			call str_at_display 
1a11			 
1a11				 
1a11 2a ef f9			ld hl,(cli_ret_sp) 
1a14 3e 86			ld a, display_row_4+14 
1a16 cd b2 19			call display_word_at 
1a19			 
1a19 cd be 0d			call update_display 
1a1c			 
1a1c cd de 0c			call delay1s 
1a1f cd de 0c			call delay1s 
1a22 cd de 0c			call delay1s 
1a25			 
1a25			 
1a25 cd 73 20			call next_page_prompt 
1a28			 
1a28				; restore  
1a28			 
1a28 f1				pop af 
1a29 e1				pop hl 
1a2a c1				pop bc 
1a2b d1				pop de 
1a2c c9				ret 
1a2d			 
1a2d			; Update the break point vector so that the user can hook a new routine 
1a2d			 
1a2d			bp_on: 
1a2d 3e c3			ld a, $c3    ; JP 
1a2f 32 6c fe			ld (debug_vector), a 
1a32 21 3f 1a			ld hl, break_point_state 
1a35 22 6d fe			ld (debug_vector+1), hl 
1a38 c9				ret 
1a39			 
1a39			bp_off: 
1a39 3e c9			ld a, $c9    ; RET 
1a3b 32 6c fe			ld (debug_vector), a 
1a3e c9				ret 
1a3f			 
1a3f			 
1a3f			break_point_state: 
1a3f			;	push af 
1a3f			; 
1a3f			;	; see if disabled 
1a3f			; 
1a3f			;	ld a, (os_view_disable) 
1a3f			;	cp '*' 
1a3f			;	jr nz, .bpsgo 
1a3f			;	pop af 
1a3f			;	ret 
1a3f			 
1a3f			.bpsgo: 
1a3f			;	pop af 
1a3f f5				push af 
1a40 22 a0 f1			ld (os_view_hl), hl 
1a43 ed 53 9e f1		ld (os_view_de), de 
1a47 ed 43 9c f1		ld (os_view_bc), bc 
1a4b e5				push hl 
1a4c 6f				ld l, a 
1a4d 26 00			ld h, 0 
1a4f 22 a2 f1			ld (os_view_af),hl 
1a52			 
1a52 21 ae fd				ld hl, display_fb0 
1a55 22 c9 fb				ld (display_fb_active), hl 
1a58 e1				pop hl	 
1a59			 
1a59 3e 31			ld a, '1' 
1a5b fe 2a		.bps1:  cp '*' 
1a5d cc 39 1a			call z, bp_off 
1a60			;	jr nz, .bps1b 
1a60			;	ld (os_view_disable),a 
1a60 fe 31		.bps1b:  cp '1' 
1a62 20 14			jr nz, .bps2 
1a64			 
1a64				; display reg 
1a64			 
1a64				 
1a64			 
1a64 3a a2 f1			ld a, (os_view_af) 
1a67 2a a0 f1			ld hl, (os_view_hl) 
1a6a ed 5b 9e f1		ld de, (os_view_de) 
1a6e ed 4b 9c f1		ld bc, (os_view_bc) 
1a72 cd 0c 1b			call display_reg_state 
1a75 c3 f8 1a			jp .bpschk 
1a78			 
1a78 fe 32		.bps2:  cp '2' 
1a7a 20 08			jr nz, .bps3 
1a7c				 
1a7c				; display hl 
1a7c 2a a0 f1			ld hl, (os_view_hl) 
1a7f cd f6 1b			call display_dump_at_hl 
1a82			 
1a82 18 74			jr .bpschk 
1a84			 
1a84 fe 33		.bps3:  cp '3' 
1a86 20 08			jr nz, .bps4 
1a88			 
1a88			        ; display de 
1a88 2a 9e f1			ld hl, (os_view_de) 
1a8b cd f6 1b			call display_dump_at_hl 
1a8e			 
1a8e 18 68			jr .bpschk 
1a90 fe 34		.bps4:  cp '4' 
1a92 20 08			jr nz, .bps5 
1a94			 
1a94			        ; display bc 
1a94 2a 9c f1			ld hl, (os_view_bc) 
1a97 cd f6 1b			call display_dump_at_hl 
1a9a			 
1a9a 18 5c			jr .bpschk 
1a9c fe 35		.bps5:  cp '5' 
1a9e 20 08		        jr nz, .bps7 
1aa0			 
1aa0				; display cur ptr 
1aa0 2a 3d fa			ld hl, (cli_ptr) 
1aa3 cd f6 1b			call display_dump_at_hl 
1aa6			 
1aa6 18 50			jr .bpschk 
1aa8 fe 36		.bps7:  cp '6' 
1aaa 20 08			jr nz, .bps8b 
1aac				 
1aac				; display cur orig ptr 
1aac 2a 3b fa			ld hl, (cli_origptr) 
1aaf cd f6 1b			call display_dump_at_hl 
1ab2 18 44			jr .bpschk 
1ab4 fe 37		.bps8b:  cp '7' 
1ab6 20 08			jr nz, .bps9 
1ab8				 
1ab8				; display dsp 
1ab8 2a eb f9			ld hl, (cli_data_sp) 
1abb cd f6 1b			call display_dump_at_hl 
1abe			 
1abe 18 38			jr .bpschk 
1ac0 fe 39		.bps9:  cp '9' 
1ac2 20 05			jr nz, .bps8c 
1ac4				 
1ac4				; display SP 
1ac4			;	ld hl, sp 
1ac4 cd f6 1b			call display_dump_at_hl 
1ac7			 
1ac7 18 2f			jr .bpschk 
1ac9 fe 38		.bps8c:  cp '8' 
1acb 20 08			jr nz, .bps8d 
1acd				 
1acd				; display rsp 
1acd 2a ef f9			ld hl, (cli_ret_sp) 
1ad0 cd f6 1b			call display_dump_at_hl 
1ad3			 
1ad3 18 23			jr .bpschk 
1ad5 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1ad7 20 05			jr nz, .bps8 
1ad9 cd 41 1e			call monitor 
1adc			 
1adc 18 1a			jr .bpschk 
1ade fe 30		.bps8:  cp '0' 
1ae0 20 16			jr nz, .bpschk 
1ae2			 
1ae2 21 0d fd				ld hl, display_fb1 
1ae5 22 c9 fb				ld (display_fb_active), hl 
1ae8 cd be 0d				call update_display 
1aeb			 
1aeb				;ld a, (os_view_af) 
1aeb 2a a0 f1			ld hl, (os_view_hl) 
1aee ed 5b 9e f1		ld de, (os_view_de) 
1af2 ed 4b 9c f1		ld bc, (os_view_bc) 
1af6 f1				pop af 
1af7 c9				ret 
1af8			 
1af8			.bpschk:   
1af8 cd de 0c			call delay1s 
1afb 3e 9f		ld a,display_row_4 + display_cols - 1 
1afd 11 71 20		        ld de, endprg 
1b00 cd ae 0d			call str_at_display 
1b03 cd be 0d			call update_display 
1b06 cd 27 7a			call cin_wait 
1b09			 
1b09 c3 5b 1a			jp .bps1 
1b0c			 
1b0c			 
1b0c			display_reg_state: 
1b0c			 
1b0c				; to restore afterwards 
1b0c			 
1b0c d5				push de 
1b0d c5				push bc 
1b0e e5				push hl 
1b0f f5				push af 
1b10			 
1b10				; for use in here 
1b10			 
1b10 c5				push bc 
1b11 d5				push de 
1b12 e5				push hl 
1b13 f5				push af 
1b14			 
1b14 cd 9b 0d			call clear_display 
1b17			 
1b17 11 cc 1b			ld de, .regstate 
1b1a 3e 00			ld a, display_row_1 
1b1c cd ae 0d			call str_at_display 
1b1f			 
1b1f				; display debug step 
1b1f			 
1b1f			 
1b1f 11 68 fe			ld de, debug_mark 
1b22 3e 25			ld a, display_row_1+display_cols-3 
1b24 cd ae 0d			call str_at_display 
1b27			 
1b27				; display a 
1b27 11 e8 1b			ld de, .regstatea 
1b2a 3e 28			ld a, display_row_2 
1b2c cd ae 0d			call str_at_display 
1b2f			 
1b2f e1				pop hl 
1b30			;	ld h,0 
1b30			;	ld l, a 
1b30 3e 2b			ld a, display_row_2+3 
1b32 cd b2 19			call display_word_at 
1b35			 
1b35			 
1b35				; display hl 
1b35			 
1b35			 
1b35 11 dc 1b			ld de, .regstatehl 
1b38 3e 32			ld a, display_row_2+10 
1b3a cd ae 0d			call str_at_display 
1b3d			 
1b3d e1				pop hl 
1b3e 3e 35			ld a, display_row_2+13 
1b40 cd b2 19			call display_word_at 
1b43			 
1b43				 
1b43				; display de 
1b43			 
1b43 11 e0 1b			ld de, .regstatede 
1b46 3e 50			ld a, display_row_3 
1b48 cd ae 0d			call str_at_display 
1b4b			 
1b4b e1				pop hl 
1b4c			;	ld h,d 
1b4c			;	ld l, e 
1b4c 3e 53			ld a, display_row_3+3 
1b4e cd b2 19			call display_word_at 
1b51			 
1b51			 
1b51				; display bc 
1b51			 
1b51 11 e4 1b			ld de, .regstatebc 
1b54 3e 5a			ld a, display_row_3+10 
1b56 cd ae 0d			call str_at_display 
1b59			 
1b59 e1				pop hl 
1b5a			;	ld h,b 
1b5a			;	ld l, c 
1b5a 3e 5d			ld a, display_row_3+13 
1b5c cd b2 19			call display_word_at 
1b5f			 
1b5f			 
1b5f				; display dsp 
1b5f			 
1b5f 11 ec 1b			ld de, .regstatedsp 
1b62 3e 78			ld a, display_row_4 
1b64 cd ae 0d			call str_at_display 
1b67			 
1b67				 
1b67 2a eb f9			ld hl,(cli_data_sp) 
1b6a 3e 7c			ld a, display_row_4+4 
1b6c cd b2 19			call display_word_at 
1b6f			 
1b6f				; display rsp 
1b6f			 
1b6f 11 f1 1b			ld de, .regstatersp 
1b72 3e 82			ld a, display_row_4+10 
1b74 cd ae 0d			call str_at_display 
1b77			 
1b77				 
1b77 2a ef f9			ld hl,(cli_ret_sp) 
1b7a 3e 86			ld a, display_row_4+14 
1b7c cd b2 19			call display_word_at 
1b7f			 
1b7f cd be 0d			call update_display 
1b82			 
1b82			;	call delay1s 
1b82			;	call delay1s 
1b82			;	call delay1s 
1b82			 
1b82			 
1b82			;	call next_page_prompt 
1b82			 
1b82				; restore  
1b82			 
1b82 f1				pop af 
1b83 e1				pop hl 
1b84 c1				pop bc 
1b85 d1				pop de 
1b86 c9				ret 
1b87			 
1b87 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1b9b .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1bb0 .. 00		.ptrstate:	db "Ptr State",0 
1bba .. 00		.ptrcliptr:     db "cli_ptr",0 
1bc2 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1bcc .. 00		.regstate:	db "Reg State (1/0)",0 
1bdc .. 00		.regstatehl:	db "HL:",0 
1be0 .. 00		.regstatede:	db "DE:",0 
1be4 .. 00		.regstatebc:	db "BC:",0 
1be8 .. 00		.regstatea:	db "A :",0 
1bec .. 00		.regstatedsp:	db "DSP:",0 
1bf1 .. 00		.regstatersp:	db "RSP:",0 
1bf6			 
1bf6			display_dump_at_hl: 
1bf6 e5				push hl 
1bf7 d5				push de 
1bf8 c5				push bc 
1bf9 f5				push af 
1bfa			 
1bfa 22 e1 f4			ld (os_cur_ptr),hl	 
1bfd cd 9b 0d			call clear_display 
1c00 cd 7b 1f			call dumpcont 
1c03			;	call delay1s 
1c03			;	call next_page_prompt 
1c03			 
1c03			 
1c03 f1				pop af 
1c04 c1				pop bc 
1c05 d1				pop de 
1c06 e1				pop hl 
1c07 c9				ret 
1c08			 
1c08			;if ENABLE_BASIC 
1c08			;	include "nascombasic.asm" 
1c08			;	basic: 
1c08			;	include "forth/FORTH.ASM" 
1c08			;endif 
1c08			 
1c08			; eof 
1c08			 
1c08			 
# End of file firmware_diags.asm
1c08			  
1c08			include "firmware_prompts.asm"  
1c08			; Prompts  
1c08			 
1c08			; boot messages 
1c08			 
1c08 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1c1d .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1c2d			 
1c2d			 
1c2d			; config menus 
1c2d			 
1c2d			;prom_c3: db "Add Dictionary To File",0 
1c2d			 
1c2d			if STARTUP_V1 
1c2d			prom_c2: db "Select Autoload File",0 
1c2d			prom_c2a: db "Disable Autoload File", 0 
1c2d			endif 
1c2d			 
1c2d			if STARTUP_V2 
1c2d .. 00		prom_c2: db "Enable Autoload Files",0 
1c43 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1c5a			 
1c5a .. 00		crs_s1: db "*ls-word", 0 
1c63 .. 00		crs_s2: db "*ed-word", 0 
1c6c .. 00		crs_s3: db "*Demo-Programs", 0 
1c7b .. 00		crs_s4: db "*Utils", 0 
1c82 .. 00		crs_s5: db "*SPI-Util", 0 
1c8c .. 00		crs_s6: db "*Key-constants", 0 
1c9b .. 00		crs_sound: db "*Sound-Util", 0 
1ca7			 
1ca7			 
1ca7			 
1ca7			endif 
1ca7			;prom_c2b: db "Select Storage Bank",0 
1ca7 .. 00		prom_c4: db "Settings",0 
1cb0 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1ccb .. 00		prom_m4b:   db "Monitor",0 
1cd3 .. 00		prom_c1: db "Hardware Diags",0 
1ce2			 
1ce2			 
1ce2			if STARTUP_V2 
1ce2 .. 00		prom_c9: db "Create Startup Files",0 
1cf7			endif 
1cf7			 
1cf7 .. 00		prom_notav:    db "Feature not available",0 
1d0d .. 00		prom_empty:    db "",0 
1d0e			 
1d0e			; eof 
1d0e			 
# End of file firmware_prompts.asm
1d0e			  
1d0e			  
1d0e			; eof  
1d0e			  
# End of file firmware.asm
1d0e			 
1d0e			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1d0e			;if BASE_KEV  
1d0e			;baseram: equ 08000h 
1d0e			;endif 
1d0e			 
1d0e			;if BASE_SC114 
1d0e			;baseram:     equ    endofcode 
1d0e			;endif 
1d0e			 
1d0e			 
1d0e			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1d0e			 
1d0e			; start system 
1d0e			 
1d0e			coldstart: 
1d0e				; set sp 
1d0e				; di/ei 
1d0e			 
1d0e f3				di 
1d0f 31 fd ff			ld sp, tos 
1d12 cd ae 76			call init_nmi 
1d15			;	ei 
1d15			 
1d15				; init spinner 
1d15 3e 00			ld a,0 
1d17 32 c3 fb			ld (display_active), a 
1d1a			 
1d1a				; disable breakpoint by default 
1d1a			 
1d1a				;ld a,'*' 
1d1a			;	ld a,' ' 
1d1a			;	ld (os_view_disable),a 
1d1a			 
1d1a				; set break point vector as new break point on or off 
1d1a cd 39 1a			call bp_off 
1d1d			 
1d1d				; init hardware 
1d1d			 
1d1d				; init keyboard and screen hardware 
1d1d			 
1d1d cd 68 00			call hardware_init 
1d20			 
1d20			 
1d20 cd de 0c			call delay1s 
1d23 3e 58			ld a, display_row_3+8 
1d25 11 03 00			ld de, buildtime 
1d28 cd ae 0d			call str_at_display 
1d2b cd be 0d			call update_display 
1d2e			 
1d2e cd de 0c			call delay1s 
1d31 cd de 0c			call delay1s 
1d34 cd de 0c			call delay1s 
1d37			 
1d37				; detect if any keys are held down to enable breakpoints at start up 
1d37			 
1d37 cd 38 7a			call cin  
1d3a fe 00			cp 0 
1d3c 28 03			jr z, .nokeys 
1d3e			 
1d3e				;call hardware_diags 
1d3e cd 2f 16			call config 
1d41			 
1d41			;	ld de, .bpen 
1d41			;	ld a, display_row_4 
1d41			;	call str_at_display 
1d41			;	call update_display 
1d41			; 
1d41			;	ld a,0 
1d41			;	ld (os_view_disable),a 
1d41			; 
1d41			;.bpwait: 
1d41			;	call cin 
1d41			;	cp 0 
1d41			;	jr z, .bpwait 
1d41			;	jr .nokeys 
1d41			; 
1d41			; 
1d41			;.bpen:  db "Break points enabled!",0 
1d41			 
1d41			 
1d41			 
1d41			 
1d41			 
1d41			 
1d41			.nokeys: 
1d41			 
1d41			 
1d41				 
1d41			 
1d41			;jp  testkey 
1d41			 
1d41			;call storage_get_block_0 
1d41			; 
1d41			;ld hl, 0 
1d41			;ld de, store_page 
1d41			;call storage_read_block 
1d41			 
1d41				 
1d41			;ld hl, 10 
1d41			;ld de, store_page 
1d41			;call storage_read_block 
1d41			 
1d41			 
1d41			 
1d41			 
1d41			 
1d41			;stop:	nop 
1d41			;	jp stop 
1d41			 
1d41			 
1d41			 
1d41			main: 
1d41 cd 9b 0d			call clear_display 
1d44 cd be 0d			call update_display 
1d47			 
1d47			 
1d47			 
1d47			;	call testlcd 
1d47			 
1d47			 
1d47			 
1d47 cd 78 24			call forth_init 
1d4a			 
1d4a			 
1d4a			warmstart: 
1d4a cd 4e 24			call forth_warmstart 
1d4d			 
1d4d				; run startup word load 
1d4d			        ; TODO prevent this running at warmstart after crash  
1d4d			 
1d4d				if STARTUP_ENABLE 
1d4d			 
1d4d					if STARTUP_V1 
1d4d			 
1d4d						if STORAGE_SE 
1d4d							call forth_autoload 
1d4d						endif 
1d4d						call forth_startup 
1d4d					endif 
1d4d			 
1d4d					if STARTUP_V2 
1d4d			 
1d4d						if STORAGE_SE 
1d4d cd dc 74						call forth_autoload 
1d50						else 
1d50							call forth_startup 
1d50						endif 
1d50			 
1d50			 
1d50					endif 
1d50			 
1d50				endif 
1d50			 
1d50				; show free memory after boot 
1d50 11 dc 1d			ld de, freeram 
1d53 3e 00			ld a, display_row_1 
1d55 cd ae 0d			call str_at_display 
1d58			 
1d58				; get current heap start after loading any uwords 
1d58			 
1d58				;ld de, (os_last_new_uword) 
1d58				;ex de, hl 
1d58			 
1d58			; Or use heap_size word???? 
1d58				;ld hl, heap_end 
1d58				;ld hl, heap_size 
1d58				;ld de, topusermem 
1d58				;ld de, heap_start 
1d58 ed 5b 0a 80			ld de, (free_list )      
1d5c 21 99 f1				ld hl, heap_end 
1d5f ed 52			sbc hl, de 
1d61				;push hl 
1d61				;ld a,h	         	 
1d61				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d61				;call hexout 
1d61			   	;pop hl 
1d61			; 
1d61			;	ld a,l 
1d61			;	ld hl, os_word_scratch+2 
1d61			;	call hexout 
1d61			;	ld hl, os_word_scratch+4 
1d61			;	ld a, 0 
1d61			;	ld (hl),a 
1d61 eb				ex de, hl 
1d62 21 c3 f4			ld hl, os_word_scratch 
1d65 cd dc 13			call uitoa_16 
1d68			 
1d68			 
1d68 11 c3 f4			ld de, os_word_scratch 
1d6b 3e 0d			ld a, display_row_1 + 13 
1d6d cd ae 0d			call str_at_display 
1d70 cd be 0d			call update_display 
1d73			 
1d73			 
1d73				;call demo 
1d73			 
1d73			 
1d73				; init scratch input area for cli commands 
1d73			 
1d73 21 e5 f4			ld hl, os_cli_cmd 
1d76 3e 00			ld a,0 
1d78 77				ld (hl),a 
1d79 23				inc hl 
1d7a 77				ld (hl),a 
1d7b			 
1d7b 3e 00			ld a,0 
1d7d 32 e4 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d80			 
1d80 32 e1 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d83 32 e2 f4			ld (os_cur_ptr+1),a	 
1d86			 
1d86 32 c3 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1d89 32 c4 f4			ld (os_word_scratch+1),a	 
1d8c				 
1d8c			 
1d8c				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d8c 21 e5 f4			ld hl, os_cli_cmd 
1d8f			 
1d8f 3e 00			ld a, 0		 ; init cli input 
1d91 77				ld (hl), a 
1d92 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d94			cli: 
1d94				; show cli prompt 
1d94				;push af 
1d94				;ld a, 0 
1d94				;ld de, prompt 
1d94				;call str_at_display 
1d94			 
1d94				;call update_display 
1d94				;pop af 
1d94				;inc a 
1d94				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d94 0e 00			ld c, 0 
1d96 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1d98 1e 28			ld e, 40 
1d9a			 
1d9a 21 e5 f4			ld hl, os_cli_cmd 
1d9d			 
1d9d				STACKFRAME OFF $fefe $9f9f 
1d9d				if DEBUG_STACK_IMB 
1d9d					if OFF 
1d9d						exx 
1d9d						ld de, $fefe 
1d9d						ld a, d 
1d9d						ld hl, curframe 
1d9d						call hexout 
1d9d						ld a, e 
1d9d						ld hl, curframe+2 
1d9d						call hexout 
1d9d						ld hl, $fefe 
1d9d						push hl 
1d9d						ld hl, $9f9f 
1d9d						push hl 
1d9d						exx 
1d9d					endif 
1d9d				endif 
1d9d			endm 
# End of macro STACKFRAME
1d9d			 
1d9d cd fc 0f			call input_str 
1da0			 
1da0				STACKFRAMECHK OFF $fefe $9f9f 
1da0				if DEBUG_STACK_IMB 
1da0					if OFF 
1da0						exx 
1da0						ld hl, $9f9f 
1da0						pop de   ; $9f9f 
1da0						call cmp16 
1da0						jr nz, .spnosame 
1da0						ld hl, $fefe 
1da0						pop de   ; $fefe 
1da0						call cmp16 
1da0						jr z, .spfrsame 
1da0						.spnosame: call showsperror 
1da0						.spfrsame: nop 
1da0						exx 
1da0					endif 
1da0				endif 
1da0			endm 
# End of macro STACKFRAMECHK
1da0			 
1da0				; copy input to last command 
1da0			 
1da0 21 e5 f4			ld hl, os_cli_cmd 
1da3 11 e4 f5			ld de, os_last_cmd 
1da6 01 ff 00			ld bc, 255 
1da9 ed b0			ldir 
1dab			 
1dab				; wipe current buffer 
1dab			 
1dab			;	ld a, 0 
1dab			;	ld hl, os_cli_cmd 
1dab			;	ld de, os_cli_cmd+1 
1dab			;	ld bc, 254 
1dab			;	ldir 
1dab				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1dab			;	call strcpy 
1dab			;	ld a, 0 
1dab			;	ld (hl), a 
1dab			;	inc hl 
1dab			;	ld (hl), a 
1dab			;	inc hl 
1dab			;	ld (hl), a 
1dab			 
1dab				; switch frame buffer to program  
1dab			 
1dab 21 0d fd				ld hl, display_fb1 
1dae 22 c9 fb				ld (display_fb_active), hl 
1db1			 
1db1			;	nop 
1db1				STACKFRAME ON $fbfe $8f9f 
1db1				if DEBUG_STACK_IMB 
1db1					if ON 
1db1						exx 
1db1						ld de, $fbfe 
1db1						ld a, d 
1db1						ld hl, curframe 
1db1						call hexout 
1db1						ld a, e 
1db1						ld hl, curframe+2 
1db1						call hexout 
1db1						ld hl, $fbfe 
1db1						push hl 
1db1						ld hl, $8f9f 
1db1						push hl 
1db1						exx 
1db1					endif 
1db1				endif 
1db1			endm 
# End of macro STACKFRAME
1db1				; first time into the parser so pass over the current scratch pad 
1db1 21 e5 f4			ld hl,os_cli_cmd 
1db4				; tokenise the entered statement(s) in HL 
1db4 cd f6 24			call forthparse 
1db7			        ; exec forth statements in top of return stack 
1db7 cd 36 25			call forthexec 
1dba				;call forthexec_cleanup 
1dba			;	call parsenext 
1dba			 
1dba				STACKFRAMECHK ON $fbfe $8f9f 
1dba				if DEBUG_STACK_IMB 
1dba					if ON 
1dba						exx 
1dba						ld hl, $8f9f 
1dba						pop de   ; $8f9f 
1dba						call cmp16 
1dba						jr nz, .spnosame 
1dba						ld hl, $fbfe 
1dba						pop de   ; $fbfe 
1dba						call cmp16 
1dba						jr z, .spfrsame 
1dba						.spnosame: call showsperror 
1dba						.spfrsame: nop 
1dba						exx 
1dba					endif 
1dba				endif 
1dba			endm 
# End of macro STACKFRAMECHK
1dba				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1dba			 
1dba 3e 78			ld a, display_row_4 
1dbc 11 ed 1d			ld de, endprog 
1dbf			 
1dbf cd be 0d			call update_display		 
1dc2			 
1dc2 cd 73 20			call next_page_prompt 
1dc5			 
1dc5				; switch frame buffer to cli 
1dc5			 
1dc5 21 ae fd				ld hl, display_fb0 
1dc8 22 c9 fb				ld (display_fb_active), hl 
1dcb			 
1dcb			 
1dcb cd 9b 0d		        call clear_display 
1dce cd be 0d			call update_display		 
1dd1			 
1dd1 21 e5 f4			ld hl, os_cli_cmd 
1dd4			 
1dd4 3e 00			ld a, 0		 ; init cli input 
1dd6 77				ld (hl), a 
1dd7			 
1dd7				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1dd7			 
1dd7				; now on last line 
1dd7			 
1dd7				; TODO scroll screen up 
1dd7			 
1dd7				; TODO instead just clear screen and place at top of screen 
1dd7			 
1dd7			;	ld a, 0 
1dd7			;	ld (f_cursor_ptr),a 
1dd7			 
1dd7				;call clear_display 
1dd7				;call update_display 
1dd7			 
1dd7				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1dd7 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1dd9 c3 94 1d			jp cli 
1ddc			 
1ddc .. 00		freeram: db "Free bytes: ",0 
1de9 ..			asc: db "1A2F" 
1ded .. 00		endprog: db "End prog...",0 
1df9			 
1df9			testenter2:   
1df9 21 f0 f1			ld hl,scratch+50 
1dfc 22 e1 f4			ld (os_cur_ptr),hl 
1dff c3 94 1d			jp cli 
1e02			 
1e02			testenter:  
1e02			 
1e02 21 e9 1d			ld hl,asc 
1e05			;	ld a,(hl) 
1e05			;	call nibble2val 
1e05 cd 26 13			call get_byte 
1e08			 
1e08			 
1e08			;	ld a,(hl) 
1e08			;	call atohex 
1e08			 
1e08			;	call fourehexhl 
1e08 32 f0 f1			ld (scratch+50),a 
1e0b			 
1e0b			 
1e0b			 
1e0b 21 eb 1d			ld hl,asc+2 
1e0e			;	ld a, (hl) 
1e0e			;	call nibble2val 
1e0e cd 26 13			call get_byte 
1e11			 
1e11			;	call fourehexhl 
1e11 32 f2 f1			ld (scratch+52),a 
1e14				 
1e14 21 f0 f1			ld hl,scratch+50 
1e17 22 e1 f4			ld (os_cur_ptr),hl 
1e1a c3 94 1d			jp cli 
1e1d			 
1e1d			enter:	 
1e1d 3a c2 f1			ld a,(scratch+4) 
1e20 fe 00			cp 0 
1e22 28 0c			jr z, .entercont 
1e24				; no, not a null term line so has an address to work out.... 
1e24			 
1e24 21 c0 f1			ld hl,scratch+2 
1e27 cd 86 13			call get_word_hl 
1e2a			 
1e2a 22 e1 f4			ld (os_cur_ptr),hl	 
1e2d c3 94 1d			jp cli 
1e30			 
1e30			 
1e30			.entercont:  
1e30			 
1e30 21 c0 f1			ld hl, scratch+2 
1e33 cd 26 13			call get_byte 
1e36			 
1e36 2a e1 f4		   	ld hl,(os_cur_ptr) 
1e39 77					ld (hl),a 
1e3a 23					inc hl 
1e3b 22 e1 f4				ld (os_cur_ptr),hl 
1e3e				 
1e3e			; get byte  
1e3e			 
1e3e			 
1e3e c3 94 1d			jp cli 
1e41			 
1e41			 
1e41			; basic monitor support 
1e41			 
1e41			monitor: 
1e41				;  
1e41 cd 9b 0d			call clear_display 
1e44 3e 00			ld a, 0 
1e46 11 95 1e			ld de, .monprompt 
1e49 cd ae 0d			call str_at_display 
1e4c cd be 0d			call update_display 
1e4f			 
1e4f				; get a monitor command 
1e4f			 
1e4f 0e 00			ld c, 0     ; entry at top left 
1e51 16 64			ld d, 100   ; max buffer size 
1e53 1e 0f			ld e, 15    ; input scroll area 
1e55 3e 00			ld a, 0     ; init string 
1e57 21 bc f3			ld hl, os_input 
1e5a 77				ld (hl), a 
1e5b 23				inc hl 
1e5c 77				ld (hl), a 
1e5d 21 bc f3			ld hl, os_input 
1e60 3e 01			ld a, 1     ; init string 
1e62 cd fc 0f			call input_str 
1e65			 
1e65 cd 9b 0d		        call clear_display 
1e68 cd be 0d			call update_display		 
1e6b			 
1e6b 3a bc f3			ld a, (os_input) 
1e6e cd 24 14			call toUpper 
1e71 fe 48		        cp 'H' 
1e73 ca fa 1e		        jp z, .monhelp 
1e76 fe 44			cp 'D'		; dump 
1e78 ca 2d 1f			jp z, .mondump	 
1e7b fe 43			cp 'C'		; dump 
1e7d ca 47 1f			jp z, .moncdump	 
1e80 fe 4d			cp 'M'		; dump 
1e82 ca 97 1e			jp z, .moneditstart 
1e85 fe 55			cp 'U'		; dump 
1e87 ca a3 1e			jp z, .monedit	 
1e8a fe 47			cp 'G'		; dump 
1e8c ca 23 1f			jp z, .monjump 
1e8f fe 51			cp 'Q'		; dump 
1e91 c8				ret z	 
1e92			 
1e92			 
1e92				; TODO "S" to access symbol by name and not need the address 
1e92				; TODO "F" to find a string in memory 
1e92			 
1e92 c3 41 1e			jp monitor 
1e95			 
1e95 .. 00		.monprompt: db ">", 0 
1e97			 
1e97			.moneditstart: 
1e97				; get starting address 
1e97			 
1e97 21 be f3			ld hl,os_input+2 
1e9a cd 86 13			call get_word_hl 
1e9d			 
1e9d 22 e1 f4			ld (os_cur_ptr),hl	 
1ea0			 
1ea0 c3 41 1e			jp monitor 
1ea3			 
1ea3			.monedit: 
1ea3				; get byte to load 
1ea3			 
1ea3 21 be f3			ld hl,os_input+2 
1ea6 cd 26 13			call get_byte 
1ea9			 
1ea9				; get address to update 
1ea9 2a e1 f4			ld hl, (os_cur_ptr) 
1eac			 
1eac				; update byte 
1eac			 
1eac 77				ld (hl), a 
1ead			 
1ead				; move to next address and save it 
1ead			 
1ead 23				inc hl 
1eae 22 e1 f4			ld (os_cur_ptr),hl	 
1eb1			 
1eb1 c3 41 1e			jp monitor 
1eb4			 
1eb4			 
1eb4 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ec8 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1ee4 .. 00		.monhelptext3:  db "G-Call address",0 
1ef3 .. 00		.monhelptext4:  db "Q-Quit",0 
1efa			        
1efa			.monhelp: 
1efa 3e 00			ld a, display_row_1 
1efc 11 b4 1e		        ld de, .monhelptext1 
1eff			 
1eff cd ae 0d			call str_at_display 
1f02 3e 28			ld a, display_row_2 
1f04 11 c8 1e		        ld de, .monhelptext2 
1f07					 
1f07 cd ae 0d			call str_at_display 
1f0a 3e 50			ld a, display_row_3 
1f0c 11 e4 1e		        ld de, .monhelptext3 
1f0f					 
1f0f cd ae 0d			call str_at_display 
1f12 3e 78			ld a, display_row_4 
1f14 11 f3 1e		        ld de, .monhelptext4 
1f17 cd ae 0d			call str_at_display 
1f1a			 
1f1a cd be 0d			call update_display		 
1f1d			 
1f1d cd 73 20			call next_page_prompt 
1f20 c3 41 1e			jp monitor 
1f23			 
1f23			.monjump:    
1f23 21 be f3			ld hl,os_input+2 
1f26 cd 86 13			call get_word_hl 
1f29			 
1f29 e9				jp (hl) 
1f2a c3 41 1e			jp monitor 
1f2d			 
1f2d			.mondump:    
1f2d 21 be f3			ld hl,os_input+2 
1f30 cd 86 13			call get_word_hl 
1f33			 
1f33 22 e1 f4			ld (os_cur_ptr),hl	 
1f36 cd 7b 1f			call dumpcont 
1f39 3e 78			ld a, display_row_4 
1f3b 11 ed 1d			ld de, endprog 
1f3e			 
1f3e cd be 0d			call update_display		 
1f41			 
1f41 cd 73 20			call next_page_prompt 
1f44 c3 41 1e			jp monitor 
1f47			.moncdump: 
1f47 cd 7b 1f			call dumpcont 
1f4a 3e 78			ld a, display_row_4 
1f4c 11 ed 1d			ld de, endprog 
1f4f			 
1f4f cd be 0d			call update_display		 
1f52			 
1f52 cd 73 20			call next_page_prompt 
1f55 c3 41 1e			jp monitor 
1f58			 
1f58			 
1f58			; TODO symbol access  
1f58			 
1f58			.symbols:     ;; A list of symbols that can be called up  
1f58 ae fd			dw display_fb0 
1f5a .. 00			db "fb0",0  
1f5e 77 fa		     	dw store_page 
1f60 .. 00			db "store_page",0 
1f6b			 
1f6b			 
1f6b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1f6b			 
1f6b 3a bf f1			ld a,(scratch+1) 
1f6e fe 00			cp 0 
1f70 28 09			jr z, dumpcont 
1f72			 
1f72				; no, not a null term line so has an address to work out.... 
1f72			 
1f72 21 c0 f1			ld hl,scratch+2 
1f75 cd 86 13			call get_word_hl 
1f78			 
1f78 22 e1 f4			ld (os_cur_ptr),hl	 
1f7b			 
1f7b			 
1f7b			 
1f7b			dumpcont: 
1f7b			 
1f7b				; dump bytes at ptr 
1f7b			 
1f7b			 
1f7b 3e 00			ld a, display_row_1 
1f7d 2a c9 fb			ld hl, (display_fb_active) 
1f80 cd cf 0f			call addatohl 
1f83 cd ab 1f			call .dumpbyterow 
1f86			 
1f86 3e 28			ld a, display_row_2 
1f88 2a c9 fb			ld hl, (display_fb_active) 
1f8b cd cf 0f			call addatohl 
1f8e cd ab 1f			call .dumpbyterow 
1f91			 
1f91			 
1f91 3e 50			ld a, display_row_3 
1f93 2a c9 fb			ld hl, (display_fb_active) 
1f96 cd cf 0f			call addatohl 
1f99 cd ab 1f			call .dumpbyterow 
1f9c			 
1f9c 3e 78			ld a, display_row_4 
1f9e 2a c9 fb			ld hl, (display_fb_active) 
1fa1 cd cf 0f			call addatohl 
1fa4 cd ab 1f			call .dumpbyterow 
1fa7			 
1fa7 cd be 0d			call update_display 
1faa			;		jp cli 
1faa c9				ret 
1fab			 
1fab			.dumpbyterow: 
1fab			 
1fab				;push af 
1fab			 
1fab e5				push hl 
1fac			 
1fac				; calc where to poke the ascii 
1fac			if display_cols == 20 
1fac				ld a, 16 
1fac			else 
1fac 3e 1f			ld a, 31 
1fae			endif 
1fae			 
1fae cd cf 0f			call addatohl 
1fb1 22 c3 f4			ld (os_word_scratch),hl  		; save pos for later 
1fb4			 
1fb4			 
1fb4			; display decoding address 
1fb4 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fb7			 
1fb7 7c				ld a,h 
1fb8 e1				pop hl 
1fb9 e5				push hl 
1fba			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1fba cd d0 12			call hexout 
1fbd 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fc0			 
1fc0 7d				ld a,l 
1fc1 e1				pop hl 
1fc2 23				inc hl 
1fc3 23				inc hl 
1fc4 e5				push hl 
1fc5			;	ld hl, os_word_scratch+2 
1fc5 cd d0 12			call hexout 
1fc8 e1				pop hl 
1fc9 23				inc hl 
1fca 23				inc hl 
1fcb				;ld hl, os_word_scratch+4 
1fcb 3e 3a			ld a, ':' 
1fcd 77				ld (hl),a 
1fce 23				inc hl 
1fcf				;ld a, 0 
1fcf				;ld (hl),a 
1fcf				;ld de, os_word_scratch 
1fcf				;pop af 
1fcf				;push af 
1fcf			;		ld a, display_row_2 
1fcf			;		call str_at_display 
1fcf			;		call update_display 
1fcf			 
1fcf			 
1fcf			;pop af 
1fcf			;	add 5 
1fcf			 
1fcf			if display_cols == 20 
1fcf				ld b, 4 
1fcf			else 
1fcf 06 08			ld b, 8 
1fd1			endif	 
1fd1			 
1fd1			.dumpbyte: 
1fd1 c5				push bc 
1fd2 e5				push hl 
1fd3			 
1fd3			 
1fd3 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fd6 7e					ld a,(hl) 
1fd7			 
1fd7					; poke the ascii to display 
1fd7 2a c3 f4				ld hl,(os_word_scratch) 
1fda 77					ld (hl),a 
1fdb 23					inc hl 
1fdc 22 c3 f4				ld (os_word_scratch),hl 
1fdf			 
1fdf					 
1fdf			 
1fdf			 
1fdf e1					pop hl 
1fe0 e5					push hl 
1fe1			 
1fe1 cd d0 12				call hexout 
1fe4			 
1fe4					 
1fe4 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fe7 23				inc hl 
1fe8 22 e1 f4		   	ld (os_cur_ptr),hl 
1feb			 
1feb e1					pop hl 
1fec 23					inc hl 
1fed 23					inc hl 
1fee 23					inc hl 
1fef			 
1fef			 
1fef			 
1fef					;ld a,0 
1fef					;ld (os_word_scratch+2),a 
1fef					;pop af 
1fef					;push af 
1fef			 
1fef					;ld de, os_word_scratch 
1fef					;call str_at_display 
1fef			;		call update_display 
1fef			;		pop af 
1fef c1					pop bc 
1ff0 c6 03				add 3 
1ff2 10 dd			djnz .dumpbyte 
1ff4			 
1ff4				 
1ff4			 
1ff4 c9				ret 
1ff5			 
1ff5			jump:	 
1ff5			 
1ff5 21 c0 f1			ld hl,scratch+2 
1ff8 cd 86 13			call get_word_hl 
1ffb				;ld hl,(scratch+2) 
1ffb				;call fourehexhl 
1ffb			 
1ffb 22 e1 f4			ld (os_cur_ptr),hl	 
1ffe			 
1ffe e9				jp (hl) 
1fff			 
1fff			 
1fff			 
1fff			; TODO implement a basic monitor mode to start with 
1fff			 
1fff			 
1fff			 
1fff			 
1fff			 
1fff			 
1fff			 
1fff			 
1fff			 
1fff			; testing and demo code during development 
1fff			 
1fff			 
1fff .. 00		str1: db "Enter some text...",0 
2012 .. 00		clear: db "                    ",0 
2027			 
2027			demo: 
2027			 
2027			 
2027			 
2027			;	call update_display 
2027			 
2027				; init scratch input area for testing 
2027 21 be f1			ld hl, scratch	 
202a 3e 00			ld a,0 
202c 77				ld (hl),a 
202d			 
202d			 
202d 3e 28		            LD   A, display_row_2 
202f			;            CALL fLCD_Pos       ;Position cursor to location in A 
202f 11 ff 1f		            LD   DE, str1 
2032 cd ae 0d			call str_at_display 
2035			 
2035			;            CALL fLCD_Str       ;Display string pointed to by DE 
2035			cloop:	 
2035 3e 50		            LD   A, display_row_3 
2037			;            CALL fLCD_Pos       ;Position cursor to location in A 
2037 11 12 20		            LD   DE, clear 
203a			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
203a cd ae 0d				call str_at_display 
203d 3e 78			ld a, display_row_4 
203f 11 6f 20			ld de, prompt 
2042			 
2042 cd ae 0d				call str_at_display 
2045 cd be 0d			call update_display 
2048			 
2048 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
204a 16 0a			ld d, 10 
204c 21 be f1			ld hl, scratch	 
204f cd fc 0f			call input_str 
2052			 
2052			;	call clear_display 
2052			;'	call update_display 
2052			 
2052 3e 00		            LD   A, display_row_1 
2054			;            CALL fLCD_Pos       ;Position cursor to location in A 
2054 11 12 20		            LD   DE, clear 
2057 cd ae 0d				call str_at_display 
205a			;            CALL fLCD_Str       ;Display string pointed to by DE 
205a 3e 00		            LD   A, display_row_1 
205c			;            CALL fLCD_Pos       ;Position cursor to location in A 
205c 11 be f1		            LD   DE, scratch 
205f			;            CALL fLCD_Str       ;Display string pointed to by DE 
205f cd ae 0d				call str_at_display 
2062 cd be 0d			call update_display 
2065			 
2065 3e 00				ld a,0 
2067 21 be f1			ld hl, scratch 
206a 77				ld (hl),a 
206b			 
206b 00				nop 
206c c3 35 20			jp cloop 
206f			 
206f			 
206f			 
206f			; OS Prompt 
206f			 
206f .. 00		prompt: db ">",0 
2071 .. 00		endprg: db "?",0 
2073			 
2073			 
2073			; handy next page prompt 
2073			next_page_prompt: 
2073 e5				push hl 
2074 d5				push de 
2075 f5				push af 
2076 c5				push bc 
2077			 
2077 3e 9f			ld a,display_row_4 + display_cols - 1 
2079 11 71 20		        ld de, endprg 
207c cd ae 0d			call str_at_display 
207f cd be 0d			call update_display 
2082 cd 27 7a			call cin_wait 
2085 c1				pop bc 
2086 f1				pop af 
2087 d1				pop de 
2088 e1				pop hl 
2089			 
2089			 
2089 c9				ret 
208a			 
208a			 
208a			; forth parser 
208a			 
208a			; My forth kernel 
208a			include "forth_kernel.asm" 
208a			; 
208a			; kernel to the forth OS 
208a			 
208a			DS_TYPE_STR: equ 1     ; string type 
208a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
208a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
208a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
208a			 
208a			FORTH_PARSEV1: equ 0 
208a			FORTH_PARSEV2: equ 0 
208a			FORTH_PARSEV3: equ 0 
208a			FORTH_PARSEV4: equ 0 
208a			FORTH_PARSEV5: equ 1 
208a			 
208a			;if FORTH_PARSEV5 
208a			;	FORTH_END_BUFFER: equ 0 
208a			;else 
208a			FORTH_END_BUFFER: equ 127 
208a			;endif 
208a			 
208a			FORTH_TRUE: equ 1 
208a			FORTH_FALSE: equ 0 
208a			 
208a			if FORTH_PARSEV4 
208a			include "forth_stackops.asm" 
208a			endif 
208a			 
208a			if FORTH_PARSEV5 
208a			include "forth_stackopsv5.asm" 
208a			 
208a			; Stack operations for v5 parser on wards 
208a			; * DATA stack 
208a			; * LOOP stack 
208a			; * RETURN stack 
208a			 
208a			 
208a			 
208a			FORTH_CHK_DSP_UNDER: macro 
208a				push hl 
208a				push de 
208a				ld hl,(cli_data_sp) 
208a				ld de, cli_data_stack 
208a				call cmp16 
208a				jp c, fault_dsp_under 
208a				pop de 
208a				pop hl 
208a				endm 
208a			 
208a			 
208a			FORTH_CHK_RSP_UNDER: macro 
208a				push hl 
208a				push de 
208a				ld hl,(cli_ret_sp) 
208a				ld de, cli_ret_stack 
208a				call cmp16 
208a				jp c, fault_rsp_under 
208a				pop de 
208a				pop hl 
208a				endm 
208a			 
208a			FORTH_CHK_LOOP_UNDER: macro 
208a				push hl 
208a				push de 
208a				ld hl,(cli_loop_sp) 
208a				ld de, cli_loop_stack 
208a				call cmp16 
208a				jp c, fault_loop_under 
208a				pop de 
208a				pop hl 
208a				endm 
208a			 
208a			FORTH_ERR_TOS_NOTSTR: macro 
208a				; TOSO might need more for checks when used 
208a				push af 
208a				ld a,(hl) 
208a				cp DS_TYPE_STR 
208a				jp nz, type_faultn   
208a				pop af 
208a				endm 
208a			 
208a			FORTH_ERR_TOS_NOTNUM: macro 
208a				push af 
208a				ld a,(hl) 
208a				cp DS_TYPE_INUM 
208a				jp nz, type_faultn   
208a				pop af 
208a				endm 
208a			 
208a			 
208a			; increase data stack pointer and save hl to it 
208a				 
208a			FORTH_DSP_NEXT: macro 
208a				call macro_forth_dsp_next 
208a				endm 
208a			 
208a			 
208a			macro_forth_dsp_next: 
208a				if DEBUG_FORTH_STACK_GUARD 
208a cd d4 72				call check_stacks 
208d				endif 
208d e5				push hl 
208e d5				push de 
208f eb				ex de,hl 
2090 2a eb f9			ld hl,(cli_data_sp) 
2093 23				inc hl 
2094 23				inc hl 
2095			 
2095			; PARSEV5 
2095 23				inc hl 
2096 22 eb f9			ld (cli_data_sp),hl 
2099 73				ld (hl), e 
209a 23				inc hl 
209b 72				ld (hl), d 
209c d1				pop de 
209d e1				pop hl 
209e				if DEBUG_FORTH_STACK_GUARD 
209e cd d4 72				call check_stacks 
20a1				endif 
20a1 c9				ret 
20a2			 
20a2			 
20a2			; increase ret stack pointer and save hl to it 
20a2				 
20a2			FORTH_RSP_NEXT: macro 
20a2				call macro_forth_rsp_next 
20a2				endm 
20a2			 
20a2			macro_forth_rsp_next: 
20a2				if DEBUG_FORTH_STACK_GUARD 
20a2 cd d4 72				call check_stacks 
20a5				endif 
20a5 e5				push hl 
20a6 d5				push de 
20a7 eb				ex de,hl 
20a8 2a ef f9			ld hl,(cli_ret_sp) 
20ab 23				inc hl 
20ac 23				inc hl 
20ad 22 ef f9			ld (cli_ret_sp),hl 
20b0 73				ld (hl), e 
20b1 23				inc hl 
20b2 72				ld (hl), d 
20b3 d1				pop de 
20b4 e1				pop hl 
20b5				if DEBUG_FORTH_STACK_GUARD 
20b5 cd d4 72				call check_stacks 
20b8				endif 
20b8 c9				ret 
20b9			 
20b9			; get current ret stack pointer and save to hl  
20b9				 
20b9			FORTH_RSP_TOS: macro 
20b9				call macro_forth_rsp_tos 
20b9				endm 
20b9			 
20b9			macro_forth_rsp_tos: 
20b9				;push de 
20b9 2a ef f9			ld hl,(cli_ret_sp) 
20bc cd f4 20			call loadhlptrtohl 
20bf				;ld e, (hl) 
20bf				;inc hl 
20bf				;ld d, (hl) 
20bf				;ex de, hl 
20bf					if DEBUG_FORTH_WORDS 
20bf			;			DMARK "RST" 
20bf						CALLMONITOR 
20bf cd 6c fe			call debug_vector  
20c2				endm  
# End of macro CALLMONITOR
20c2					endif 
20c2				;pop de 
20c2 c9				ret 
20c3			 
20c3			; pop ret stack pointer 
20c3				 
20c3			FORTH_RSP_POP: macro 
20c3				call macro_forth_rsp_pop 
20c3				endm 
20c3			 
20c3			 
20c3			macro_forth_rsp_pop: 
20c3				if DEBUG_FORTH_STACK_GUARD 
20c3			;		DMARK "RPP" 
20c3 cd d4 72				call check_stacks 
20c6					FORTH_CHK_RSP_UNDER 
20c6 e5				push hl 
20c7 d5				push de 
20c8 2a ef f9			ld hl,(cli_ret_sp) 
20cb 11 a9 f9			ld de, cli_ret_stack 
20ce cd ed 0f			call cmp16 
20d1 da e8 73			jp c, fault_rsp_under 
20d4 d1				pop de 
20d5 e1				pop hl 
20d6				endm 
# End of macro FORTH_CHK_RSP_UNDER
20d6				endif 
20d6 e5				push hl 
20d7 2a ef f9			ld hl,(cli_ret_sp) 
20da			 
20da			 
20da				if FORTH_ENABLE_FREE 
20da			 
20da					; get pointer 
20da			 
20da					push de 
20da					push hl 
20da			 
20da					ld e, (hl) 
20da					inc hl 
20da					ld d, (hl) 
20da			 
20da					ex de, hl 
20da					call free 
20da			 
20da					pop hl 
20da					pop de 
20da			 
20da			 
20da				endif 
20da			 
20da			 
20da 2b				dec hl 
20db 2b				dec hl 
20dc 22 ef f9			ld (cli_ret_sp), hl 
20df				; do stack underflow checks 
20df e1				pop hl 
20e0				if DEBUG_FORTH_STACK_GUARD 
20e0 cd d4 72				call check_stacks 
20e3					FORTH_CHK_RSP_UNDER 
20e3 e5				push hl 
20e4 d5				push de 
20e5 2a ef f9			ld hl,(cli_ret_sp) 
20e8 11 a9 f9			ld de, cli_ret_stack 
20eb cd ed 0f			call cmp16 
20ee da e8 73			jp c, fault_rsp_under 
20f1 d1				pop de 
20f2 e1				pop hl 
20f3				endm 
# End of macro FORTH_CHK_RSP_UNDER
20f3				endif 
20f3 c9				ret 
20f4			 
20f4			 
20f4			 
20f4			; routine to load word pointed to by hl into hl 
20f4			 
20f4			loadhlptrtohl: 
20f4			 
20f4 d5				push de 
20f5 5e				ld e, (hl) 
20f6 23				inc hl 
20f7 56				ld d, (hl) 
20f8 eb				ex de, hl 
20f9 d1				pop de 
20fa			 
20fa c9				ret 
20fb			 
20fb			 
20fb			 
20fb			 
20fb			 
20fb			; push a number held in HL onto the data stack 
20fb			; entry point for pushing a value when already in hl used in function above 
20fb			 
20fb			forth_push_numhl: 
20fb			 
20fb e5				push hl    ; save value to push 
20fc			 
20fc			if DEBUG_FORTH_PUSH 
20fc				; see if disabled 
20fc			 
20fc			 
20fc f5				push af 
20fd 3a 6c fe			ld a,(debug_vector) 
2100 fe c9			cp $c9   ; ret 
2102			;	ld a, (os_view_disable) 
2102			;	cp '*' 
2102 28 34			jr z, .pskip2 
2104 e5				push hl 
2105 e5			push hl 
2106 cd 9b 0d			call clear_display 
2109 e1			pop hl 
210a 7c				ld a,h 
210b 21 c3 f4			ld hl, os_word_scratch 
210e cd d0 12			call hexout 
2111 e1				pop hl 
2112 7d				ld a,l 
2113 21 c5 f4			ld hl, os_word_scratch+2 
2116 cd d0 12			call hexout 
2119			 
2119 21 c7 f4			ld hl, os_word_scratch+4 
211c 3e 00			ld a,0 
211e 77				ld (hl),a 
211f 11 c3 f4			ld de,os_word_scratch 
2122 3e 28				ld a, display_row_2 
2124 cd ae 0d				call str_at_display 
2127 11 e6 5d			ld de, .push_num 
212a 3e 00			ld a, display_row_1 
212c			 
212c cd ae 0d				call str_at_display 
212f			 
212f			 
212f cd be 0d			call update_display 
2132 cd de 0c			call delay1s 
2135 cd de 0c			call delay1s 
2138			.pskip2:  
2138			 
2138 f1				pop af 
2139			endif	 
2139			 
2139			 
2139				FORTH_DSP_NEXT 
2139 cd 8a 20			call macro_forth_dsp_next 
213c				endm 
# End of macro FORTH_DSP_NEXT
213c			 
213c 2a eb f9			ld hl, (cli_data_sp) 
213f			 
213f				; save item type 
213f 3e 02			ld a,  DS_TYPE_INUM 
2141 77				ld (hl), a 
2142 23				inc hl 
2143			 
2143				; get word off stack 
2143 d1				pop de 
2144 7b				ld a,e 
2145 77				ld (hl), a 
2146 23				inc hl 
2147 7a				ld a,d 
2148 77				ld (hl), a 
2149			 
2149			if DEBUG_FORTH_PUSH 
2149 2b				dec hl 
214a 2b				dec hl 
214b 2b				dec hl 
214c						DMARK "PH5" 
214c f5				push af  
214d 3a 61 21			ld a, (.dmark)  
2150 32 68 fe			ld (debug_mark),a  
2153 3a 62 21			ld a, (.dmark+1)  
2156 32 69 fe			ld (debug_mark+1),a  
2159 3a 63 21			ld a, (.dmark+2)  
215c 32 6a fe			ld (debug_mark+2),a  
215f 18 03			jr .pastdmark  
2161 ..			.dmark: db "PH5"  
2164 f1			.pastdmark: pop af  
2165			endm  
# End of macro DMARK
2165				CALLMONITOR 
2165 cd 6c fe			call debug_vector  
2168				endm  
# End of macro CALLMONITOR
2168			endif	 
2168			 
2168 c9				ret 
2169			 
2169			 
2169			; Push a string to stack pointed to by hl 
2169			 
2169			forth_push_str: 
2169			 
2169			if DEBUG_FORTH_PUSH 
2169						DMARK "PSQ" 
2169 f5				push af  
216a 3a 7e 21			ld a, (.dmark)  
216d 32 68 fe			ld (debug_mark),a  
2170 3a 7f 21			ld a, (.dmark+1)  
2173 32 69 fe			ld (debug_mark+1),a  
2176 3a 80 21			ld a, (.dmark+2)  
2179 32 6a fe			ld (debug_mark+2),a  
217c 18 03			jr .pastdmark  
217e ..			.dmark: db "PSQ"  
2181 f1			.pastdmark: pop af  
2182			endm  
# End of macro DMARK
2182				CALLMONITOR 
2182 cd 6c fe			call debug_vector  
2185				endm  
# End of macro CALLMONITOR
2185			endif	 
2185			    
2185 e5				push hl 
2186 e5				push hl 
2187			 
2187			;	ld a, 0   ; find end of string 
2187 cd 2d 14			call strlenz 
218a			if DEBUG_FORTH_PUSH 
218a						DMARK "PQ2" 
218a f5				push af  
218b 3a 9f 21			ld a, (.dmark)  
218e 32 68 fe			ld (debug_mark),a  
2191 3a a0 21			ld a, (.dmark+1)  
2194 32 69 fe			ld (debug_mark+1),a  
2197 3a a1 21			ld a, (.dmark+2)  
219a 32 6a fe			ld (debug_mark+2),a  
219d 18 03			jr .pastdmark  
219f ..			.dmark: db "PQ2"  
21a2 f1			.pastdmark: pop af  
21a3			endm  
# End of macro DMARK
21a3				CALLMONITOR 
21a3 cd 6c fe			call debug_vector  
21a6				endm  
# End of macro CALLMONITOR
21a6			endif	 
21a6 eb				ex de, hl 
21a7 e1				pop hl   ; get ptr to start of string 
21a8			if DEBUG_FORTH_PUSH 
21a8						DMARK "PQ3" 
21a8 f5				push af  
21a9 3a bd 21			ld a, (.dmark)  
21ac 32 68 fe			ld (debug_mark),a  
21af 3a be 21			ld a, (.dmark+1)  
21b2 32 69 fe			ld (debug_mark+1),a  
21b5 3a bf 21			ld a, (.dmark+2)  
21b8 32 6a fe			ld (debug_mark+2),a  
21bb 18 03			jr .pastdmark  
21bd ..			.dmark: db "PQ3"  
21c0 f1			.pastdmark: pop af  
21c1			endm  
# End of macro DMARK
21c1				CALLMONITOR 
21c1 cd 6c fe			call debug_vector  
21c4				endm  
# End of macro CALLMONITOR
21c4			endif	 
21c4 19				add hl,de 
21c5			if DEBUG_FORTH_PUSH 
21c5						DMARK "PQE" 
21c5 f5				push af  
21c6 3a da 21			ld a, (.dmark)  
21c9 32 68 fe			ld (debug_mark),a  
21cc 3a db 21			ld a, (.dmark+1)  
21cf 32 69 fe			ld (debug_mark+1),a  
21d2 3a dc 21			ld a, (.dmark+2)  
21d5 32 6a fe			ld (debug_mark+2),a  
21d8 18 03			jr .pastdmark  
21da ..			.dmark: db "PQE"  
21dd f1			.pastdmark: pop af  
21de			endm  
# End of macro DMARK
21de				CALLMONITOR 
21de cd 6c fe			call debug_vector  
21e1				endm  
# End of macro CALLMONITOR
21e1			endif	 
21e1			 
21e1 2b				dec hl    ; see if there is an optional trailing double quote 
21e2 7e				ld a,(hl) 
21e3 fe 22			cp '"' 
21e5 20 03			jr nz, .strnoq 
21e7 3e 00			ld a, 0      ; get rid of double quote 
21e9 77				ld (hl), a 
21ea 23			.strnoq: inc hl 
21eb			 
21eb 3e 00			ld a, 0 
21ed 77				ld (hl), a     ; add null term and get rid of trailing double quote 
21ee			 
21ee 13				inc de ; add one for the type string 
21ef 13				inc de ; add one for null term??? 
21f0			 
21f0				; tos is get string pointer again 
21f0				; de contains space to allocate 
21f0				 
21f0 d5				push de 
21f1			 
21f1 eb				ex de, hl 
21f2			 
21f2				;push af 
21f2			 
21f2			if DEBUG_FORTH_PUSH 
21f2						DMARK "PHm" 
21f2 f5				push af  
21f3 3a 07 22			ld a, (.dmark)  
21f6 32 68 fe			ld (debug_mark),a  
21f9 3a 08 22			ld a, (.dmark+1)  
21fc 32 69 fe			ld (debug_mark+1),a  
21ff 3a 09 22			ld a, (.dmark+2)  
2202 32 6a fe			ld (debug_mark+2),a  
2205 18 03			jr .pastdmark  
2207 ..			.dmark: db "PHm"  
220a f1			.pastdmark: pop af  
220b			endm  
# End of macro DMARK
220b				CALLMONITOR 
220b cd 6c fe			call debug_vector  
220e				endm  
# End of macro CALLMONITOR
220e			endif	 
220e cd 96 14			call malloc	; on ret hl now contains allocated memory 
2211				if DEBUG_FORTH_MALLOC_GUARD 
2211 cc 3e 5e				call z,malloc_error 
2214				endif 
2214			 
2214				 
2214 c1				pop bc    ; get length 
2215 d1				pop de   ;  get string start    
2216			 
2216				; hl has destination from malloc 
2216			 
2216 eb				ex de, hl    ; prep for ldir 
2217			 
2217 d5				push de   ; save malloc area for DSP later 
2218				;push hl   ; save malloc area for DSP later 
2218			 
2218			if DEBUG_FORTH_PUSH 
2218						DMARK "PHc" 
2218 f5				push af  
2219 3a 2d 22			ld a, (.dmark)  
221c 32 68 fe			ld (debug_mark),a  
221f 3a 2e 22			ld a, (.dmark+1)  
2222 32 69 fe			ld (debug_mark+1),a  
2225 3a 2f 22			ld a, (.dmark+2)  
2228 32 6a fe			ld (debug_mark+2),a  
222b 18 03			jr .pastdmark  
222d ..			.dmark: db "PHc"  
2230 f1			.pastdmark: pop af  
2231			endm  
# End of macro DMARK
2231				CALLMONITOR 
2231 cd 6c fe			call debug_vector  
2234				endm  
# End of macro CALLMONITOR
2234			endif	 
2234			 
2234			 
2234 ed b0			ldir 
2236			 
2236			 
2236				; push malloc to data stack     macro?????  
2236			 
2236				FORTH_DSP_NEXT 
2236 cd 8a 20			call macro_forth_dsp_next 
2239				endm 
# End of macro FORTH_DSP_NEXT
2239			 
2239				; save value and type 
2239			 
2239 2a eb f9			ld hl, (cli_data_sp) 
223c			 
223c				; save item type 
223c 3e 01			ld a,  DS_TYPE_STR 
223e 77				ld (hl), a 
223f 23				inc hl 
2240			 
2240				; get malloc word off stack 
2240 d1				pop de 
2241 73				ld (hl), e 
2242 23				inc hl 
2243 72				ld (hl), d 
2244			 
2244			 
2244			 
2244			if DEBUG_FORTH_PUSH 
2244 2a eb f9			ld hl, (cli_data_sp) 
2247						DMARK "PHS" 
2247 f5				push af  
2248 3a 5c 22			ld a, (.dmark)  
224b 32 68 fe			ld (debug_mark),a  
224e 3a 5d 22			ld a, (.dmark+1)  
2251 32 69 fe			ld (debug_mark+1),a  
2254 3a 5e 22			ld a, (.dmark+2)  
2257 32 6a fe			ld (debug_mark+2),a  
225a 18 03			jr .pastdmark  
225c ..			.dmark: db "PHS"  
225f f1			.pastdmark: pop af  
2260			endm  
# End of macro DMARK
2260				CALLMONITOR 
2260 cd 6c fe			call debug_vector  
2263				endm  
# End of macro CALLMONITOR
2263			;	ex de,hl 
2263			endif	 
2263				; in case of spaces, skip the ptr past the copied string 
2263				;pop af 
2263				;ld (cli_origptr),hl 
2263			 
2263 c9				ret 
2264			 
2264			 
2264			 
2264			; TODO ascii push input onto stack given hl to start of input 
2264			 
2264			; identify type 
2264			; if starts with a " then a string 
2264			; otherwise it is a number 
2264			;  
2264			; if a string 
2264			;     scan for ending " to get length of string to malloc for + 1 
2264			;     malloc 
2264			;     put pointer to string on stack first byte flags as string 
2264			; 
2264			; else a number 
2264			;    look for number format identifier 
2264			;    $xx hex 
2264			;    %xxxxx bin 
2264			;    xxxxx decimal 
2264			;    convert number to 16bit word.  
2264			;    malloc word + 1 with flag to identiy as num 
2264			;    put pointer to number on stack 
2264			;   
2264			;  
2264			  
2264			forth_apush: 
2264				; kernel push 
2264			 
2264			if DEBUG_FORTH_PUSH 
2264						DMARK "PSH" 
2264 f5				push af  
2265 3a 79 22			ld a, (.dmark)  
2268 32 68 fe			ld (debug_mark),a  
226b 3a 7a 22			ld a, (.dmark+1)  
226e 32 69 fe			ld (debug_mark+1),a  
2271 3a 7b 22			ld a, (.dmark+2)  
2274 32 6a fe			ld (debug_mark+2),a  
2277 18 03			jr .pastdmark  
2279 ..			.dmark: db "PSH"  
227c f1			.pastdmark: pop af  
227d			endm  
# End of macro DMARK
227d				CALLMONITOR 
227d cd 6c fe			call debug_vector  
2280				endm  
# End of macro CALLMONITOR
2280			endif	 
2280				; identify input type 
2280			 
2280 7e				ld a,(hl) 
2281 fe 22			cp '"' 
2283 28 0a			jr z, .fapstr 
2285 fe 24			cp '$' 
2287 ca af 22			jp z, .faphex 
228a fe 25			cp '%' 
228c ca 97 22			jp z, .fapbin 
228f			;	cp 'b' 
228f			;	jp z, .fabin 
228f				; else decimal 
228f			 
228f				; TODO do decimal conversion 
228f				; decimal is stored as a 16bit word 
228f			 
228f				; by default everything is a string if type is not detected 
228f			.fapstr: ; 
228f fe 22			cp '"' 
2291 20 01			jr nz, .strnoqu 
2293 23				inc hl 
2294			.strnoqu: 
2294 c3 69 21			jp forth_push_str 
2297			 
2297			 
2297			 
2297			.fapbin:    ; push a binary string.  
2297 11 00 00			ld de, 0   ; hold a 16bit value 
229a			 
229a 23			.fapbinshift:	inc hl  
229b 7e				ld a,(hl) 
229c fe 00			cp 0     ; done scanning  
229e 28 0b			jr z, .fapbdone  	; got it in HL so push  
22a0			 
22a0				; left shift de 
22a0 eb				ex de, hl	 
22a1 29				add hl, hl 
22a2			 
22a2				; is 1 
22a2 fe 31			cp '1' 
22a4 20 02			jr nz, .binzero 
22a6 cb 4d			bit 1, l 
22a8			.binzero: 
22a8 eb				ex de, hl	 ; save current de 
22a9 18 ef			jr .fapbinshift 
22ab			 
22ab			.fapbdone: 
22ab eb				ex de, hl 
22ac c3 fb 20			jp forth_push_numhl 
22af			 
22af			 
22af			.faphex:   ; hex is always stored as a 16bit word 
22af				; skip number prefix 
22af 23				inc hl 
22b0				; turn ascii into number 
22b0 cd 86 13			call get_word_hl	; ret 16bit word in hl 
22b3			 
22b3 c3 fb 20			jp forth_push_numhl 
22b6			 
22b6 00				 nop 
22b7			 
22b7			.fabin:   ; TODO bin conversion 
22b7			 
22b7			 
22b7 c9				ret 
22b8			 
22b8			 
22b8			; get either a string ptr or a 16bit word from the data stack 
22b8			 
22b8			FORTH_DSP: macro 
22b8				call macro_forth_dsp 
22b8				endm 
22b8			 
22b8			macro_forth_dsp: 
22b8				; data stack pointer points to current word on tos 
22b8			 
22b8 2a eb f9			ld hl,(cli_data_sp) 
22bb			 
22bb				if DEBUG_FORTH_PUSH 
22bb						DMARK "DSP" 
22bb f5				push af  
22bc 3a d0 22			ld a, (.dmark)  
22bf 32 68 fe			ld (debug_mark),a  
22c2 3a d1 22			ld a, (.dmark+1)  
22c5 32 69 fe			ld (debug_mark+1),a  
22c8 3a d2 22			ld a, (.dmark+2)  
22cb 32 6a fe			ld (debug_mark+2),a  
22ce 18 03			jr .pastdmark  
22d0 ..			.dmark: db "DSP"  
22d3 f1			.pastdmark: pop af  
22d4			endm  
# End of macro DMARK
22d4			 
22d4 cd 71 5e				call display_data_sp 
22d7				;call break_point_state 
22d7				;rst 030h 
22d7				CALLMONITOR 
22d7 cd 6c fe			call debug_vector  
22da				endm  
# End of macro CALLMONITOR
22da				endif 
22da			 
22da c9				ret 
22db			 
22db			; return hl to start of value on stack 
22db			 
22db			FORTH_DSP_VALUE: macro 
22db				call macro_forth_dsp_value 
22db				endm 
22db			 
22db			macro_forth_dsp_value: 
22db			 
22db				FORTH_DSP 
22db cd b8 22			call macro_forth_dsp 
22de				endm 
# End of macro FORTH_DSP
22de			 
22de d5				push de 
22df			 
22df 23				inc hl ; skip type 
22e0			 
22e0 5e				ld e, (hl) 
22e1 23				inc hl 
22e2 56				ld d, (hl) 
22e3 eb				ex de,hl  
22e4			 
22e4 d1				pop de 
22e5			 
22e5 c9				ret 
22e6			 
22e6			; return hl to start of value to second item on stack 
22e6			 
22e6			FORTH_DSP_VALUEM1: macro 
22e6				call macro_forth_dsp_value_m1 
22e6				endm 
22e6			 
22e6			macro_forth_dsp_value_m1: 
22e6			 
22e6				FORTH_DSP 
22e6 cd b8 22			call macro_forth_dsp 
22e9				endm 
# End of macro FORTH_DSP
22e9			 
22e9 2b				dec hl 
22ea 2b				dec hl 
22eb			;	dec hl 
22eb			 
22eb d5				push de 
22ec			 
22ec 5e				ld e, (hl) 
22ed 23				inc hl 
22ee 56				ld d, (hl) 
22ef eb				ex de,hl  
22f0			 
22f0 d1				pop de 
22f1			 
22f1 c9				ret 
22f2			 
22f2				 
22f2			 
22f2			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
22f2			 
22f2			FORTH_DSP_POP: macro 
22f2				call macro_forth_dsp_pop 
22f2				endm 
22f2			 
22f2			 
22f2			; get the tos data type 
22f2			 
22f2			FORTH_DSP_TYPE:   macro 
22f2			 
22f2				;FORTH_DSP_VALUE 
22f2				FORTH_DSP 
22f2				 
22f2				; hl points to value 
22f2				; check type 
22f2			 
22f2				ld a,(hl) 
22f2			 
22f2				endm 
22f2			 
22f2			; load the tos value into hl 
22f2			 
22f2			 
22f2			FORTH_DSP_VALUEHL:  macro 
22f2				call macro_dsp_valuehl 
22f2				endm 
22f2			 
22f2			 
22f2			 
22f2			macro_dsp_valuehl: 
22f2				FORTH_DSP_VALUE 
22f2 cd db 22			call macro_forth_dsp_value 
22f5				endm 
# End of macro FORTH_DSP_VALUE
22f5			 
22f5				;FORTH_ERR_TOS_NOTNUM 
22f5			 
22f5				;inc hl   ; skip type id 
22f5			 
22f5			;	push de 
22f5			; 
22f5			;	ld e, (hl) 
22f5			;	inc hl 
22f5			;	ld d, (hl) 
22f5			;	ex de,hl  
22f5			 
22f5			;	pop de 
22f5			 
22f5				if DEBUG_FORTH_PUSH 
22f5						DMARK "DVL" 
22f5 f5				push af  
22f6 3a 0a 23			ld a, (.dmark)  
22f9 32 68 fe			ld (debug_mark),a  
22fc 3a 0b 23			ld a, (.dmark+1)  
22ff 32 69 fe			ld (debug_mark+1),a  
2302 3a 0c 23			ld a, (.dmark+2)  
2305 32 6a fe			ld (debug_mark+2),a  
2308 18 03			jr .pastdmark  
230a ..			.dmark: db "DVL"  
230d f1			.pastdmark: pop af  
230e			endm  
# End of macro DMARK
230e				CALLMONITOR 
230e cd 6c fe			call debug_vector  
2311				endm  
# End of macro CALLMONITOR
2311				endif 
2311 c9				ret 
2312			 
2312			forth_apushstrhl:      
2312				; push of string requires use of cli_origptr 
2312				; bodge use 
2312			 
2312				; get current cli_origptr, save, update with temp pointer  
2312 ed 5b 3b fa		ld de, (cli_origptr) 
2316 22 3b fa			ld (cli_origptr), hl 
2319 d5				push de 
231a cd 64 22			call forth_apush 
231d d1				pop de 
231e ed 53 3b fa		ld (cli_origptr), de 
2322 c9			        ret	 
2323			 
2323			 
2323			; increase loop stack pointer and save hl to it 
2323				 
2323			FORTH_LOOP_NEXT: macro 
2323				call macro_forth_loop_next 
2323				;nop 
2323				endm 
2323			 
2323			macro_forth_loop_next: 
2323				if DEBUG_FORTH_STACK_GUARD 
2323 cd d4 72				call check_stacks 
2326				endif 
2326 e5				push hl 
2327 d5				push de 
2328 eb				ex de,hl 
2329 2a ed f9			ld hl,(cli_loop_sp) 
232c 23				inc hl 
232d 23				inc hl 
232e					if DEBUG_FORTH_WORDS 
232e						DMARK "LNX" 
232e f5				push af  
232f 3a 43 23			ld a, (.dmark)  
2332 32 68 fe			ld (debug_mark),a  
2335 3a 44 23			ld a, (.dmark+1)  
2338 32 69 fe			ld (debug_mark+1),a  
233b 3a 45 23			ld a, (.dmark+2)  
233e 32 6a fe			ld (debug_mark+2),a  
2341 18 03			jr .pastdmark  
2343 ..			.dmark: db "LNX"  
2346 f1			.pastdmark: pop af  
2347			endm  
# End of macro DMARK
2347						CALLMONITOR 
2347 cd 6c fe			call debug_vector  
234a				endm  
# End of macro CALLMONITOR
234a					endif 
234a 22 ed f9			ld (cli_loop_sp),hl 
234d 73				ld (hl), e 
234e 23				inc hl 
234f 72				ld (hl), d 
2350 d1				pop de    ; been reversed so save a swap on restore 
2351 e1				pop hl 
2352				if DEBUG_FORTH_STACK_GUARD 
2352 cd d4 72				call check_stacks 
2355				endif 
2355 c9				ret 
2356			 
2356			; get current ret stack pointer and save to hl  
2356				 
2356			FORTH_LOOP_TOS: macro 
2356				call macro_forth_loop_tos 
2356				endm 
2356			 
2356			macro_forth_loop_tos: 
2356 d5				push de 
2357 2a ed f9			ld hl,(cli_loop_sp) 
235a 5e				ld e, (hl) 
235b 23				inc hl 
235c 56				ld d, (hl) 
235d eb				ex de, hl 
235e d1				pop de 
235f c9				ret 
2360			 
2360			; pop loop stack pointer 
2360				 
2360			FORTH_LOOP_POP: macro 
2360				call macro_forth_loop_pop 
2360				endm 
2360			 
2360			 
2360			macro_forth_loop_pop: 
2360				if DEBUG_FORTH_STACK_GUARD 
2360					DMARK "LPP" 
2360 f5				push af  
2361 3a 75 23			ld a, (.dmark)  
2364 32 68 fe			ld (debug_mark),a  
2367 3a 76 23			ld a, (.dmark+1)  
236a 32 69 fe			ld (debug_mark+1),a  
236d 3a 77 23			ld a, (.dmark+2)  
2370 32 6a fe			ld (debug_mark+2),a  
2373 18 03			jr .pastdmark  
2375 ..			.dmark: db "LPP"  
2378 f1			.pastdmark: pop af  
2379			endm  
# End of macro DMARK
2379 cd d4 72				call check_stacks 
237c					FORTH_CHK_LOOP_UNDER 
237c e5				push hl 
237d d5				push de 
237e 2a ed f9			ld hl,(cli_loop_sp) 
2381 11 27 f9			ld de, cli_loop_stack 
2384 cd ed 0f			call cmp16 
2387 da ee 73			jp c, fault_loop_under 
238a d1				pop de 
238b e1				pop hl 
238c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
238c				endif 
238c e5				push hl 
238d 2a ed f9			ld hl,(cli_loop_sp) 
2390 2b				dec hl 
2391 2b				dec hl 
2392 22 ed f9			ld (cli_loop_sp), hl 
2395				; TODO do stack underflow checks 
2395 e1				pop hl 
2396				if DEBUG_FORTH_STACK_GUARD 
2396 cd d4 72				call check_stacks 
2399					FORTH_CHK_LOOP_UNDER 
2399 e5				push hl 
239a d5				push de 
239b 2a ed f9			ld hl,(cli_loop_sp) 
239e 11 27 f9			ld de, cli_loop_stack 
23a1 cd ed 0f			call cmp16 
23a4 da ee 73			jp c, fault_loop_under 
23a7 d1				pop de 
23a8 e1				pop hl 
23a9				endm 
# End of macro FORTH_CHK_LOOP_UNDER
23a9				endif 
23a9 c9				ret 
23aa			 
23aa			macro_forth_dsp_pop: 
23aa			 
23aa e5				push hl 
23ab			 
23ab				; release malloc data 
23ab			 
23ab				if DEBUG_FORTH_STACK_GUARD 
23ab cd d4 72				call check_stacks 
23ae					FORTH_CHK_DSP_UNDER 
23ae e5				push hl 
23af d5				push de 
23b0 2a eb f9			ld hl,(cli_data_sp) 
23b3 11 25 f7			ld de, cli_data_stack 
23b6 cd ed 0f			call cmp16 
23b9 da e2 73			jp c, fault_dsp_under 
23bc d1				pop de 
23bd e1				pop hl 
23be				endm 
# End of macro FORTH_CHK_DSP_UNDER
23be				endif 
23be				;ld hl,(cli_data_sp) 
23be			if DEBUG_FORTH_DOT 
23be				DMARK "DPP" 
23be f5				push af  
23bf 3a d3 23			ld a, (.dmark)  
23c2 32 68 fe			ld (debug_mark),a  
23c5 3a d4 23			ld a, (.dmark+1)  
23c8 32 69 fe			ld (debug_mark+1),a  
23cb 3a d5 23			ld a, (.dmark+2)  
23ce 32 6a fe			ld (debug_mark+2),a  
23d1 18 03			jr .pastdmark  
23d3 ..			.dmark: db "DPP"  
23d6 f1			.pastdmark: pop af  
23d7			endm  
# End of macro DMARK
23d7				CALLMONITOR 
23d7 cd 6c fe			call debug_vector  
23da				endm  
# End of macro CALLMONITOR
23da			endif	 
23da			 
23da			 
23da			if FORTH_ENABLE_DSPPOPFREE 
23da			 
23da				FORTH_DSP 
23da cd b8 22			call macro_forth_dsp 
23dd				endm 
# End of macro FORTH_DSP
23dd			 
23dd 7e				ld a, (hl) 
23de fe 01			cp DS_TYPE_STR 
23e0 20 23			jr nz, .skippopfree 
23e2			 
23e2				FORTH_DSP_VALUEHL 
23e2 cd f2 22			call macro_dsp_valuehl 
23e5				endm 
# End of macro FORTH_DSP_VALUEHL
23e5 00				nop 
23e6			if DEBUG_FORTH_DOT 
23e6				DMARK "DPf" 
23e6 f5				push af  
23e7 3a fb 23			ld a, (.dmark)  
23ea 32 68 fe			ld (debug_mark),a  
23ed 3a fc 23			ld a, (.dmark+1)  
23f0 32 69 fe			ld (debug_mark+1),a  
23f3 3a fd 23			ld a, (.dmark+2)  
23f6 32 6a fe			ld (debug_mark+2),a  
23f9 18 03			jr .pastdmark  
23fb ..			.dmark: db "DPf"  
23fe f1			.pastdmark: pop af  
23ff			endm  
# End of macro DMARK
23ff				CALLMONITOR 
23ff cd 6c fe			call debug_vector  
2402				endm  
# End of macro CALLMONITOR
2402			endif	 
2402 cd 60 15			call free 
2405			.skippopfree: 
2405				 
2405			 
2405			endif 
2405			 
2405			if DEBUG_FORTH_DOT_KEY 
2405				DMARK "DP2" 
2405				CALLMONITOR 
2405			endif	 
2405			 
2405				; move pointer down 
2405			 
2405 2a eb f9			ld hl,(cli_data_sp) 
2408 2b				dec hl 
2409 2b				dec hl 
240a			; PARSEV5 
240a 2b				dec hl 
240b 22 eb f9			ld (cli_data_sp), hl 
240e			 
240e				if DEBUG_FORTH_STACK_GUARD 
240e cd d4 72				call check_stacks 
2411					FORTH_CHK_DSP_UNDER 
2411 e5				push hl 
2412 d5				push de 
2413 2a eb f9			ld hl,(cli_data_sp) 
2416 11 25 f7			ld de, cli_data_stack 
2419 cd ed 0f			call cmp16 
241c da e2 73			jp c, fault_dsp_under 
241f d1				pop de 
2420 e1				pop hl 
2421				endm 
# End of macro FORTH_CHK_DSP_UNDER
2421				endif 
2421			 
2421 e1				pop hl 
2422			 
2422 c9				ret 
2423			 
2423			getwordathl: 
2423				; hl points to an address 
2423				; load hl with the word at that address 
2423			 
2423 d5				push de 
2424			 
2424 5e				ld e, (hl) 
2425 23				inc hl 
2426 56				ld d, (hl) 
2427 eb				ex de, hl 
2428			 
2428 d1				pop de 
2429 c9				ret 
242a			 
242a			 
242a			 
242a			 
242a			 
242a			; eof 
242a			 
# End of file forth_stackopsv5.asm
242a			endif 
242a			 
242a			loadwordinhl:	 
242a			 
242a d5				push de 
242b			 
242b 5e				ld e, (hl) 
242c 23				inc hl 
242d 56				ld d, (hl) 
242e eb				ex de,hl  
242f			 
242f d1				pop de 
2430			 
2430 c9				ret 
2431			 
2431			user_word_eol:  
2431				; hl contains the pointer to where to create a linked list item from the end 
2431				; of the user dict to continue on at the system word dict 
2431				 
2431				; poke the stub of the word list linked list to repoint to rom words 
2431			 
2431				; stub format 
2431				; db   word id 
2431				; dw    link to next word 
2431			        ; db char length of token 
2431				; db string + 0 term 
2431				; db exec code....  
2431			 
2431 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2433 77				ld (hl), a		; word id 
2434 23				inc hl 
2435			 
2435 11 00 26			ld de, sysdict 
2438 73				ld (hl), e		; next word link ie system dict 
2439 23				inc hl 
243a 72				ld (hl), d		; next word link ie system dict 
243b 23				inc hl	 
243c			 
243c			;	ld (hl), sysdict		; next word link ie system dict 
243c			;	inc hl 
243c			;	inc hl 
243c			 
243c			;	inc hl 
243c			;	inc hl 
243c			 
243c 3e 02			ld a, 2			; word length is 0 
243e 77				ld (hl), a	 
243f 23				inc hl 
2440			 
2440 3e 7e			ld a, '~'			; word length is 0 
2442 77				ld (hl), a	 
2443 23				inc hl 
2444 3e 00			ld a, 0			; save empty word 
2446 77				ld (hl), a 
2447			 
2447 c9				ret 
2448			 
2448				 
2448			 
2448			forthexec_cleanup: 
2448				FORTH_RSP_POP 
2448 cd c3 20			call macro_forth_rsp_pop 
244b				endm 
# End of macro FORTH_RSP_POP
244b c9				ret 
244c			 
244c			forth_call_hl: 
244c				; taking hl 
244c e5				push hl 
244d c9				ret 
244e			 
244e			; this is called to reset Forth system but keep existing uwords etc 
244e			 
244e			forth_warmstart: 
244e				; setup stack over/under flow checks 
244e				if DEBUG_FORTH_STACK_GUARD 
244e cd ba 72				call chk_stk_init 
2451				endif 
2451			 
2451				; init stack pointers  - * these stacks go upwards *  
2451 21 a9 f9			ld hl, cli_ret_stack 
2454 22 ef f9			ld (cli_ret_sp), hl	 
2457				; set bottom of stack 
2457 3e 00			ld a,0 
2459 77				ld (hl),a 
245a 23				inc hl 
245b 77				ld (hl),a 
245c			 
245c 21 25 f7			ld hl, cli_data_stack 
245f 22 eb f9			ld (cli_data_sp), hl	 
2462				; set bottom of stack 
2462 3e 00			ld a,0 
2464 77				ld (hl),a 
2465 23				inc hl 
2466 77				ld (hl),a 
2467			 
2467 21 27 f9			ld hl, cli_loop_stack 
246a 22 ed f9			ld (cli_loop_sp), hl	 
246d				; set bottom of stack 
246d 3e 00			ld a,0 
246f 77				ld (hl),a 
2470 23				inc hl 
2471 77				ld (hl),a 
2472			 
2472				; init extent of current open file 
2472			 
2472 3e 00			ld a, 0 
2474 32 67 fa			ld (store_openext), a 
2477			 
2477 c9				ret 
2478			 
2478			 
2478			 
2478			; Cold Start - this is called to setup the whole Forth system 
2478			 
2478			forth_init: 
2478			 
2478				; setup stack over/under flow checks 
2478			 
2478			;	if DEBUG_FORTH_STACK_GUARD 
2478			;		call chk_stk_init 
2478			;	endif 
2478			 
2478				; enable auto display updates (slow.....) 
2478			 
2478 3e 01			ld a, 1 
247a 32 39 fa			ld (cli_autodisplay), a 
247d			 
247d				; if storage is in use disable long reads for now 
247d 3e 00			ld a, 0 
247f 32 72 fa			ld (store_longread), a 
2482			 
2482			 
2482				; show start up screen 
2482			 
2482 cd 9b 0d			call clear_display 
2485			 
2485 3e 00			ld a,0 
2487 32 5b fa			ld (f_cursor_ptr), a 
248a			 
248a				; set start of word list in start of ram - for use when creating user words 
248a			 
248a 21 00 80			ld hl, baseram 
248d 22 bb f4			ld (os_last_new_uword), hl 
2490 cd 31 24			call user_word_eol 
2493				 
2493			;		call display_data_sp 
2493			;		call next_page_prompt 
2493			 
2493			 
2493			 
2493			 
2493 c9				ret 
2494			 
2494 .. 00		.bootforth: db " Forth Kernel Init ",0 
24a8			 
24a8			; TODO push to stack 
24a8			 
24a8			;  
24a8			 
24a8			if FORTH_PARSEV2 
24a8			 
24a8			 
24a8				include "forth_parserv2.asm" 
24a8			 
24a8			endif 
24a8			 
24a8			 
24a8			; parse cli version 1 
24a8			 
24a8			if FORTH_PARSEV1 
24a8			 
24a8			 
24a8			 
24a8			      include "forth_parserv1.asm" 
24a8			endif 
24a8				 
24a8			if FORTH_PARSEV3 
24a8			 
24a8			 
24a8			 
24a8			      include "forth_parserv3.asm" 
24a8				include "forth_wordsv3.asm" 
24a8			endif 
24a8			 
24a8			if FORTH_PARSEV4 
24a8			 
24a8			 
24a8			 
24a8			      include "forth_parserv4.asm" 
24a8				include "forth_wordsv4.asm" 
24a8			endif 
24a8			 
24a8			if FORTH_PARSEV5 
24a8			 
24a8			 
24a8			 
24a8			      include "forth_parserv5.asm" 
24a8			 
24a8			 
24a8			; A better parser without using malloc and string copies all over the place.  
24a8			; Exec in situ should be faster 
24a8			 
24a8			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
24a8			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
24a8			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
24a8			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
24a8			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
24a8			WORD_SYS_END: equ 0   ; Opcode for all user words 
24a8			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
24a8			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
24a8			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
24a8			 
24a8			; Core word preamble macro 
24a8			 
24a8			CWHEAD:   macro nxtword opcode lit len opflags 
24a8				db WORD_SYS_CORE+opcode             
24a8				; internal op code number 
24a8				dw nxtword            
24a8				; link to next dict word block 
24a8				db len + 1 
24a8				; literal length of dict word inc zero term 
24a8				db lit,0              
24a8				; literal dict word 
24a8			        ; TODO db opflags        
24a8				endm 
24a8			 
24a8			 
24a8			NEXTW: macro  
24a8				jp macro_next 
24a8				endm 
24a8			 
24a8			macro_next: 
24a8			if DEBUG_FORTH_PARSE_KEY 
24a8				DMARK "NXT" 
24a8				CALLMONITOR 
24a8			endif	 
24a8			;	inc hl  ; skip token null term  
24a8 ed 4b 3d fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24ac ed 5b 3b fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24b0 2a bf f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24b3			if DEBUG_FORTH_PARSE_KEY 
24b3				DMARK "}AA" 
24b3				CALLMONITOR 
24b3			endif	 
24b3 c3 b6 25			jp execnext 
24b6				;jp exec1 
24b6			       
24b6			 
24b6			 
24b6			; Another go at the parser to compile  
24b6			 
24b6			 
24b6			; TODO rework parser to change all of the string words to byte tokens 
24b6			; TODO do a search for  
24b6			 
24b6			; TODO first run normal parser to zero term sections 
24b6			; TODO for each word do a token look up to get the op code 
24b6			; TODO need some means to flag to the exec that this is a byte code form    
24b6			 
24b6			 
24b6			forthcompile: 
24b6			 
24b6			; 
24b6			; line parse: 
24b6			;       parse raw input buffer 
24b6			;       tokenise the words 
24b6			;       malloc new copy (for looping etc) 
24b6			;       copy to malloc + current pc in line to start of string and add line term 
24b6			;       save on new rsp 
24b6			; 
24b6			 
24b6			; hl to point to the line to tokenise 
24b6			 
24b6			;	push hl 
24b6 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
24b9			 
24b9			;	ld a,0		; string term on input 
24b9			;	call strlent 
24b9			 
24b9			;	ld (os_tok_len), hl	 ; save string length 
24b9			 
24b9			;if DEBUG_FORTH_TOK 
24b9			;	ex de,hl		 
24b9			;endif 
24b9			 
24b9			;	pop hl 		; get back string pointer 
24b9			 
24b9			if DEBUG_FORTH_TOK 
24b9						DMARK "TOc" 
24b9				CALLMONITOR 
24b9			endif 
24b9 7e			.cptoken2:    ld a,(hl) 
24ba 23				inc hl 
24bb fe 7f			cp FORTH_END_BUFFER 
24bd 28 29			jr z, .cptokendone2 
24bf fe 00			cp 0 
24c1 28 25			jr z, .cptokendone2 
24c3 fe 22			cp '"' 
24c5 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
24c7 fe 20			cp ' ' 
24c9 20 ee			jr nz,  .cptoken2 
24cb			 
24cb			; TODO consume comments held between ( and ) 
24cb			 
24cb				; we have a space so change to zero term for dict match later 
24cb 2b				dec hl 
24cc 3e 00			ld a,0 
24ce 77				ld (hl), a 
24cf 23				inc hl 
24d0 18 e7			jr .cptoken2 
24d2				 
24d2			 
24d2			.cptokenstr2: 
24d2				; skip all white space until either eol (because forgot to term) or end double quote 
24d2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24d2				;inc hl ; skip current double quote 
24d2 7e				ld a,(hl) 
24d3 23				inc hl 
24d4 fe 22			cp '"' 
24d6 28 e1			jr z, .cptoken2 
24d8 fe 7f			cp FORTH_END_BUFFER 
24da 28 0c			jr z, .cptokendone2 
24dc fe 00			cp 0 
24de 28 08			jr z, .cptokendone2 
24e0 fe 20			cp ' ' 
24e2 28 02			jr z, .cptmp2 
24e4 18 ec			jr .cptokenstr2 
24e6			 
24e6			.cptmp2:	; we have a space so change to zero term for dict match later 
24e6				;dec hl 
24e6				;ld a,"-"	; TODO remove this when working 
24e6				;ld (hl), a 
24e6				;inc hl 
24e6 18 ea			jr .cptokenstr2 
24e8			 
24e8			.cptokendone2: 
24e8				;inc hl 
24e8 3e 7f			ld a, FORTH_END_BUFFER 
24ea 77				ld (hl),a 
24eb 23				inc hl 
24ec 3e 21			ld a, '!' 
24ee 77				ld (hl),a 
24ef			 
24ef 2a bf f4			ld hl,(os_tok_ptr) 
24f2			         
24f2			if DEBUG_FORTH_TOK 
24f2						DMARK "Tc1" 
24f2				CALLMONITOR 
24f2			endif 
24f2			 
24f2				; push exec string to top of return stack 
24f2				FORTH_RSP_NEXT 
24f2 cd a2 20			call macro_forth_rsp_next 
24f5				endm 
# End of macro FORTH_RSP_NEXT
24f5 c9				ret 
24f6			 
24f6			; Another go at the parser need to simplify the process 
24f6			 
24f6			forthparse: 
24f6			 
24f6			; 
24f6			; line parse: 
24f6			;       parse raw input buffer 
24f6			;       tokenise the words 
24f6			;       malloc new copy (for looping etc) 
24f6			;       copy to malloc + current pc in line to start of string and add line term 
24f6			;       save on new rsp 
24f6			; 
24f6			 
24f6			; hl to point to the line to tokenise 
24f6			 
24f6			;	push hl 
24f6 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
24f9			 
24f9			;	ld a,0		; string term on input 
24f9			;	call strlent 
24f9			 
24f9			;	ld (os_tok_len), hl	 ; save string length 
24f9			 
24f9			;if DEBUG_FORTH_TOK 
24f9			;	ex de,hl		 
24f9			;endif 
24f9			 
24f9			;	pop hl 		; get back string pointer 
24f9			 
24f9			if DEBUG_FORTH_TOK 
24f9						DMARK "TOK" 
24f9				CALLMONITOR 
24f9			endif 
24f9 7e			.ptoken2:    ld a,(hl) 
24fa 23				inc hl 
24fb fe 7f			cp FORTH_END_BUFFER 
24fd 28 29			jr z, .ptokendone2 
24ff fe 00			cp 0 
2501 28 25			jr z, .ptokendone2 
2503 fe 22			cp '"' 
2505 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2507 fe 20			cp ' ' 
2509 20 ee			jr nz,  .ptoken2 
250b			 
250b			; TODO consume comments held between ( and ) 
250b			 
250b				; we have a space so change to zero term for dict match later 
250b 2b				dec hl 
250c 3e 00			ld a,0 
250e 77				ld (hl), a 
250f 23				inc hl 
2510 18 e7			jr .ptoken2 
2512				 
2512			 
2512			.ptokenstr2: 
2512				; skip all white space until either eol (because forgot to term) or end double quote 
2512			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2512				;inc hl ; skip current double quote 
2512 7e				ld a,(hl) 
2513 23				inc hl 
2514 fe 22			cp '"' 
2516 28 e1			jr z, .ptoken2 
2518 fe 7f			cp FORTH_END_BUFFER 
251a 28 0c			jr z, .ptokendone2 
251c fe 00			cp 0 
251e 28 08			jr z, .ptokendone2 
2520 fe 20			cp ' ' 
2522 28 02			jr z, .ptmp2 
2524 18 ec			jr .ptokenstr2 
2526			 
2526			.ptmp2:	; we have a space so change to zero term for dict match later 
2526				;dec hl 
2526				;ld a,"-"	; TODO remove this when working 
2526				;ld (hl), a 
2526				;inc hl 
2526 18 ea			jr .ptokenstr2 
2528			 
2528			.ptokendone2: 
2528				;inc hl 
2528 3e 7f			ld a, FORTH_END_BUFFER 
252a 77				ld (hl),a 
252b 23				inc hl 
252c 3e 21			ld a, '!' 
252e 77				ld (hl),a 
252f			 
252f 2a bf f4			ld hl,(os_tok_ptr) 
2532			         
2532			if DEBUG_FORTH_TOK 
2532						DMARK "TK1" 
2532				CALLMONITOR 
2532			endif 
2532			 
2532				; push exec string to top of return stack 
2532				FORTH_RSP_NEXT 
2532 cd a2 20			call macro_forth_rsp_next 
2535				endm 
# End of macro FORTH_RSP_NEXT
2535 c9				ret 
2536			 
2536			; 
2536			;	; malloc size + buffer pointer + if is loop flag 
2536			;	ld hl,(os_tok_len) 		 ; get string length 
2536			; 
2536			;	ld a,l 
2536			; 
2536			;	cp 0			; we dont want to use a null string 
2536			;	ret z 
2536			; 
2536			;;	add 3    ; prefix malloc with buffer for current word ptr 
2536			; 
2536			;	add 5     ; TODO when certain not over writing memory remove 
2536			; 
2536			;		 
2536			; 
2536			;if DEBUG_FORTH_TOK 
2536			;			DMARK "TKE" 
2536			;	CALLMONITOR 
2536			;endif 
2536			; 
2536			;	ld l,a 
2536			;	ld h,0 
2536			;;	push hl   ; save required space for the copy later 
2536			;	call malloc 
2536			;if DEBUG_FORTH_TOK 
2536			;			DMARK "TKM" 
2536			;	CALLMONITOR 
2536			;endif 
2536			;	if DEBUG_FORTH_MALLOC_GUARD 
2536			;		push af 
2536			;		call ishlzero 
2536			;;		ld a, l 
2536			;;		add h 
2536			;;		cp 0 
2536			;		pop af 
2536			;		 
2536			;		call z,malloc_error 
2536			;	endif 
2536			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2536			; 
2536			; 
2536			;if DEBUG_FORTH_TOK 
2536			;			DMARK "TKR" 
2536			;	CALLMONITOR 
2536			;endif 
2536			; 
2536			;	FORTH_RSP_NEXT 
2536			; 
2536			;	;inc hl	 ; go past current buffer pointer 
2536			;	;inc hl 
2536			;	;inc hl   ; and past if loop flag 
2536			;		; TODO Need to set flag  
2536			; 
2536			;	 
2536			;	 
2536			;	ex de,hl	; malloc is dest 
2536			;	ld hl, (os_tok_len) 
2536			;;	pop bc 
2536			;	ld c, l                
2536			;	ld b,0 
2536			;	ld hl, (os_tok_ptr) 
2536			; 
2536			;if DEBUG_FORTH_TOK 
2536			;			DMARK "TKT" 
2536			;	CALLMONITOR 
2536			;endif 
2536			; 
2536			;	; do str cpy 
2536			; 
2536			;	ldir      ; copy byte in hl to de 
2536			; 
2536			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2536			; 
2536			;if DEBUG_FORTH_TOK 
2536			; 
2536			;			DMARK "TKY" 
2536			;	CALLMONITOR 
2536			;endif 
2536			;	;ld a,0 
2536			;	;ld a,FORTH_END_BUFFER 
2536			;	ex de, hl 
2536			;	;dec hl			 ; go back over the space delim at the end of word 
2536			;	;ld (hl),a 
2536			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2536			;	ld a,FORTH_END_BUFFER 
2536			;	ld (hl),a 
2536			;	inc hl 
2536			;	ld a,FORTH_END_BUFFER 
2536			;	ld (hl),a 
2536			; 
2536			;	; init the malloc area data 
2536			;	; set pc for in current area 
2536			;	;ld hl, (os_tok_malloc) 
2536			;	;inc hl 
2536			;	;inc hl 
2536			;	;inc hl 
2536			;	;ex de,hl 
2536			;	;ld hl, (os_tok_malloc) 
2536			;	;ld (hl),e 
2536			;	;inc hl 
2536			;	;ld (hl),d 
2536			; 
2536			; 
2536			;	ld hl,(os_tok_malloc) 
2536			;if DEBUG_FORTH_PARSE_KEY 
2536			;			DMARK "TKU" 
2536			;	CALLMONITOR 
2536			;endif 
2536			; 
2536			;	ret 
2536			 
2536			forthexec: 
2536			 
2536			; line exec: 
2536			; forth parser 
2536			 
2536			; 
2536			;       get current exec line on rsp 
2536			 
2536				FORTH_RSP_TOS 
2536 cd b9 20			call macro_forth_rsp_tos 
2539				endm 
# End of macro FORTH_RSP_TOS
2539			 
2539			;       restore current pc - hl points to malloc of data 
2539			 
2539				;ld e, (hl) 
2539				;inc hl 
2539				;ld d, (hl) 
2539				;ex de,hl 
2539			 
2539			 
2539			exec1: 
2539 22 bf f4			ld (os_tok_ptr), hl 
253c			 
253c				; copy our PC to working vars  
253c 22 3d fa			ld (cli_ptr), hl 
253f 22 3b fa			ld (cli_origptr), hl 
2542			 
2542 7e				ld a,(hl) 
2543 fe 7f			cp FORTH_END_BUFFER 
2545 c8				ret z 
2546			 
2546				; skip any nulls 
2546			 
2546 fe 00			cp 0 
2548 20 03			jr nz, .execword 
254a 23				inc hl 
254b 18 ec			jr exec1 
254d			 
254d			 
254d			.execword: 
254d			 
254d			 
254d			 
254d			if DEBUG_FORTH_PARSE_KEY 
254d						DMARK "KYQ" 
254d				CALLMONITOR 
254d			endif 
254d			;       while at start of word: 
254d			; get start of dict (in user area first) 
254d			 
254d 21 00 80		ld hl, baseram 
2550			;ld hl, sysdict 
2550 22 3f fa		ld (cli_nextword),hl 
2553			;           match word at pc 
2553			;           exec word 
2553			;           or push to dsp 
2553			;           forward to next token 
2553			;           if line term pop rsp and exit 
2553			;        
2553			 
2553			if DEBUG_FORTH_PARSE_KEY 
2553						DMARK "KYq" 
2553				CALLMONITOR 
2553			endif 
2553			 
2553			; 
2553			; word comp 
2553			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2553			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2553			;    move to start of word  
2553			;    compare word to cli_token 
2553			 
2553			.execpnword:	; HL at start of a word in the dictionary to check 
2553			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2553			;	ld (cli_ptr), hl 
2553			 
2553 2a 3f fa			ld hl,(cli_nextword) 
2556			 
2556 cd f9 25			call forth_tok_next 
2559			; tok next start here 
2559			;	; TODO skip compiled symbol for now 
2559			;	inc hl 
2559			; 
2559			;	; save pointer to next word 
2559			; 
2559			;	; hl now points to the address of the next word pointer  
2559			;	ld e, (hl) 
2559			;	inc hl 
2559			;	ld d, (hl) 
2559			;	inc l 
2559			; 
2559			;	ex de,hl 
2559			;if DEBUG_FORTH_PARSE_NEXTWORD 
2559			;	push bc 
2559			;	ld bc, (cli_nextword) 
2559			;			DMARK "NXW" 
2559			;	CALLMONITOR 
2559			;	pop bc 
2559			;endif 
2559			; tok next end here 
2559 22 3f fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
255c eb				ex de, hl 
255d			 
255d			 
255d				; save the pointer of the current token - 1 to check against 
255d				 
255d 22 43 fa			ld (cli_token), hl   
2560				; TODO maybe remove below save if no debug 
2560				; save token string ptr for any debug later 
2560 23				inc hl  
2561 22 45 fa			ld (cli_origtoken), hl 
2564 2b				dec hl 
2565				; save pointer to the start of the next dictionay word 
2565 7e				ld a,(hl)   ; get string length 
2566 47				ld b,a 
2567			.execpnwordinc:  
2567 23				inc hl 
2568 10 fd			djnz .execpnwordinc 
256a 22 41 fa			ld (cli_execword), hl      ; save start of this words code 
256d			 
256d				; now check the word token against the string being parsed 
256d			 
256d 2a 43 fa			ld hl,(cli_token) 
2570 23				inc hl     ; skip string length (use zero term instead to end) 
2571 22 43 fa			ld (cli_token), hl 
2574			 
2574			if DEBUG_FORTH_PARSE_KEY 
2574						DMARK "KY2" 
2574			endif 
2574			if DEBUG_FORTH_PARSE_EXEC 
2574				; see if disabled 
2574			 
2574			;	ld a, (os_view_disable) 
2574			;	cp '*' 
2574				ld a, (debug_vector) 
2574				cp $c9   ; RET  
2574				jr z, .skip 
2574			 
2574				push hl 
2574				push hl 
2574				call clear_display 
2574				ld de, .compword 
2574				ld a, display_row_1 
2574				call str_at_display 
2574				pop de 
2574				ld a, display_row_2 
2574				call str_at_display 
2574				ld hl,(cli_ptr) 
2574				ld a,(hl) 
2574			        ld hl, os_word_scratch 
2574				ld (hl),a 
2574				ld a,0 
2574				inc hl 
2574				ld (hl),a 	 
2574				ld de, os_word_scratch 
2574				ld a, display_row_2+10 
2574				call str_at_display 
2574				call update_display 
2574				ld a, 100 
2574				call aDelayInMS 
2574				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2574				call delay250ms 
2574				endif 
2574				pop hl 
2574			.skip:  
2574			endif	 
2574			.execpnchar:    ; compare char between token and string to parse 
2574			 
2574			if DEBUG_FORTH_PARSE_KEY 
2574						DMARK "Ky3" 
2574			endif 
2574			if DEBUG_FORTH_PARSE_EXEC 
2574				; see if disabled 
2574			 
2574			;	ld a, (os_view_disable) 
2574			;	cp '*' 
2574				ld a, (debug_vector) 
2574				cp $C9  ; RET 
2574				jr z, .skip2 
2574			 
2574			;	call clear_display 
2574			ld hl,(cli_token) 
2574			ld a,(hl) 
2574			ld (os_word_scratch),a 
2574				ld hl,(cli_ptr) 
2574			ld a,(hl) 
2574				ld (os_word_scratch+1),a 
2574				ld a,0 
2574				ld (os_word_scratch+2),a 
2574				ld de,os_word_scratch 
2574				ld a,display_row_4 
2574				call str_at_display 
2574				call update_display 
2574			.skip2:  
2574			endif 
2574 2a 43 fa			ld hl,(cli_token) 
2577 7e				ld a, (hl)	 ; char in word token 
2578 23				inc hl 		; move to next char 
2579 22 43 fa			ld (cli_token), hl ; and save it 
257c 47				ld b,a 
257d			 
257d 2a 3d fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
2580 7e				ld a,(hl) 
2581 23				inc hl 
2582 22 3d fa			ld (cli_ptr), hl		; move to next char 
2585 cd 24 14			call toUpper 		; make sure the input string matches case 
2588			 
2588			if DEBUG_FORTH_PARSE 
2588			endif 
2588			 
2588				; input stream end of token is a space so get rid of it 
2588			 
2588			;	cp ' ' 
2588			;	jr nz, .pnskipspace 
2588			; 
2588			;	ld a, 0		; make same term as word token term 
2588			; 
2588			;.pnskipspace: 
2588			 
2588			if DEBUG_FORTH_PARSE_KEY 
2588						DMARK "KY7" 
2588			endif 
2588 b8				cp b 
2589 c2 9f 25			jp nz, .execpnskipword	 ; no match so move to next word 
258c				 
258c			;    if same 
258c			;       scan for string terms 0 for token and 32 for input 
258c			 
258c				 
258c			if DEBUG_FORTH_PARSE_KEY 
258c						DMARK "KY8" 
258c			endif 
258c			 
258c 80				add b			 
258d fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
258f							; TODO need to make sure last word in zero term string is accounted for 
258f 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2591			 
2591			 
2591				; at end of both strings so both are exact match 
2591			 
2591			;       skip ptr for next word 
2591			 
2591 2a 3d fa			ld hl,(cli_ptr) 	; at input string term 
2594 23				inc hl			 ; at next char 
2595 22 3d fa			ld (cli_ptr), hl     ; save for next round of the parser 
2598 22 3b fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
259b				 
259b				 
259b			if DEBUG_FORTH_PARSE_KEY 
259b						DMARK "KY3" 
259b			endif 
259b			 
259b			 
259b			 
259b			;       exec code block 
259b			if DEBUG_FORTH_JP 
259b				call clear_display 
259b				call update_display 
259b				call delay1s 
259b				ld hl, (cli_execword)     ; save for next check if no match on this word 
259b				ld a,h 
259b				ld hl, os_word_scratch 
259b				call hexout 
259b				ld hl, (cli_execword)     ; save for next check if no match on this word 
259b				ld a,l 
259b				ld hl, os_word_scratch+2 
259b				call hexout 
259b				ld hl, os_word_scratch+4 
259b				ld a,0 
259b				ld (hl),a 
259b				ld de,os_word_scratch 
259b				call str_at_display 
259b					ld a, display_row_2 
259b					call str_at_display 
259b				ld de, (cli_origtoken) 
259b				ld a, display_row_1+10 
259b					call str_at_display 
259b			 
259b				ld a,display_row_1 
259b				ld de, .foundword 
259b				ld a, display_row_3 
259b				call str_at_display 
259b				call update_display 
259b				call delay1s 
259b				call delay1s 
259b				call delay1s 
259b			endif 
259b			 
259b			if DEBUG_FORTH_PARSE_KEY 
259b						DMARK "KYj" 
259b			endif 
259b				; TODO save the word pointer in this exec 
259b			 
259b 2a 41 fa			ld hl,(cli_execword) 
259e e9				jp (hl) 
259f			 
259f			 
259f			;    if not same 
259f			;	scan for zero term 
259f			;	get ptr for next word 
259f			;	goto word comp 
259f			 
259f			.execpnskipword:	; get pointer to next word 
259f 2a 3f fa			ld hl,(cli_nextword) 
25a2			 
25a2 7e				ld a,(hl) 
25a3 fe 00			cp WORD_SYS_END 
25a5			;	cp 0 
25a5 28 09			jr z, .execendofdict			 ; at end of words 
25a7			 
25a7			if DEBUG_FORTH_PARSE_KEY 
25a7						DMARK "KY4" 
25a7			endif 
25a7			if DEBUG_FORTH_PARSE_EXEC 
25a7			 
25a7				; see if disabled 
25a7			 
25a7			;	ld a, (os_view_disable) 
25a7			;	cp '*' 
25a7				ld a,(debug_vector) 
25a7				cp $c9   ; RET 
25a7				jr z, .noskip 
25a7			 
25a7			 
25a7				ld de, .nowordfound 
25a7				ld a, display_row_3 
25a7				call str_at_display 
25a7				call update_display 
25a7				ld a, 100 
25a7				call aDelayInMS 
25a7				 
25a7				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25a7					call delay250ms 
25a7				endif 
25a7			.noskip:  
25a7			 
25a7			endif	 
25a7			 
25a7 2a 3b fa			ld hl,(cli_origptr) 
25aa 22 3d fa			ld (cli_ptr),hl 
25ad			 
25ad			if DEBUG_FORTH_PARSE_KEY 
25ad						DMARK "KY5" 
25ad			endif 
25ad c3 53 25			jp .execpnword			; else go to next word 
25b0			 
25b0			.execendofdict:  
25b0			 
25b0			if DEBUG_FORTH_PARSE_KEY 
25b0						DMARK "KYe" 
25b0			endif 
25b0			if DEBUG_FORTH_PARSE_EXEC 
25b0				; see if disabled 
25b0			 
25b0			;	ld a, (os_view_disable) 
25b0			;	cp '*' 
25b0				ld a,(debug_vector) 
25b0				cp $c9   ; ret 
25b0				jr z, .ispskip 
25b0			 
25b0				call clear_display 
25b0				call update_display 
25b0				call delay1s 
25b0				ld de, (cli_origptr) 
25b0				ld a, display_row_1 
25b0				call str_at_display 
25b0				 
25b0				ld de, .enddict 
25b0				ld a, display_row_3 
25b0				call str_at_display 
25b0				call update_display 
25b0				ld a, 100 
25b0				call aDelayInMS 
25b0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25b0				call delay1s 
25b0				call delay1s 
25b0				call delay1s 
25b0				endif 
25b0			.ispskip:  
25b0				 
25b0			endif	 
25b0			 
25b0			 
25b0			 
25b0				; if the word is not a keyword then must be a literal so push it to stack 
25b0			 
25b0			; push token to stack to end of word 
25b0			 
25b0				STACKFRAME ON $1efe $2f9f 
25b0				if DEBUG_STACK_IMB 
25b0					if ON 
25b0						exx 
25b0						ld de, $1efe 
25b0						ld a, d 
25b0						ld hl, curframe 
25b0						call hexout 
25b0						ld a, e 
25b0						ld hl, curframe+2 
25b0						call hexout 
25b0						ld hl, $1efe 
25b0						push hl 
25b0						ld hl, $2f9f 
25b0						push hl 
25b0						exx 
25b0					endif 
25b0				endif 
25b0			endm 
# End of macro STACKFRAME
25b0			 
25b0 2a bf f4		ld hl,(os_tok_ptr) 
25b3 cd 64 22		call forth_apush 
25b6			 
25b6				STACKFRAMECHK ON $1efe $2f9f 
25b6				if DEBUG_STACK_IMB 
25b6					if ON 
25b6						exx 
25b6						ld hl, $2f9f 
25b6						pop de   ; $2f9f 
25b6						call cmp16 
25b6						jr nz, .spnosame 
25b6						ld hl, $1efe 
25b6						pop de   ; $1efe 
25b6						call cmp16 
25b6						jr z, .spfrsame 
25b6						.spnosame: call showsperror 
25b6						.spfrsame: nop 
25b6						exx 
25b6					endif 
25b6				endif 
25b6			endm 
# End of macro STACKFRAMECHK
25b6			 
25b6			execnext: 
25b6			 
25b6			if DEBUG_FORTH_PARSE_KEY 
25b6						DMARK "KY>" 
25b6			endif 
25b6			; move past token to next word 
25b6			 
25b6 2a bf f4		ld hl, (os_tok_ptr) 
25b9 3e 00		ld a, 0 
25bb 01 ff 00		ld bc, 255     ; input buffer size 
25be ed b1		cpir 
25c0			 
25c0			if DEBUG_FORTH_PARSE_KEY 
25c0						DMARK "KY!" 
25c0				CALLMONITOR 
25c0			endif	 
25c0			; TODO this might place hl on the null, so will need to forward on??? 
25c0			;inc hl   ; see if this gets onto the next item 
25c0			 
25c0			 
25c0			; TODO pass a pointer to the buffer to push 
25c0			; TODO call function to push 
25c0			 
25c0			; look for end of input 
25c0			 
25c0			;inc hl 
25c0			;ld a,(hl) 
25c0			;cp FORTH_END_BUFFER 
25c0			;ret z 
25c0			 
25c0			 
25c0 c3 39 25		jp exec1 
25c3			 
25c3			 
25c3			 
25c3			 
25c3			 
25c3			 
25c3			 
25c3			 
25c3			 
25c3			findnexttok: 
25c3			 
25c3				; hl is pointer to move 
25c3				; de is the token to locate 
25c3			 
25c3					if DEBUG_FORTH 
25c3						DMARK "NTK" 
25c3						CALLMONITOR 
25c3					endif 
25c3 d5				push de 
25c4			 
25c4			.fnt1:	 
25c4				; find first char of token to locate 
25c4			 
25c4 1a				ld a, (de) 
25c5 4f				ld c,a 
25c6 7e				ld a,(hl) 
25c7 cd 24 14			call toUpper 
25ca					if DEBUG_FORTH 
25ca						DMARK "NT1" 
25ca						CALLMONITOR 
25ca					endif 
25ca b9				cp c 
25cb			 
25cb 28 03			jr z, .fnt2cmpmorefirst	 
25cd			 
25cd				; first char not found move to next char 
25cd			 
25cd 23				inc hl 
25ce 18 f4			jr .fnt1 
25d0			 
25d0			.fnt2cmpmorefirst:	 
25d0				; first char of token found.  
25d0			 
25d0 e5				push hl     ; save start of token just in case it is the right one 
25d1 d9				exx 
25d2 e1				pop hl        ; save it to hl' 
25d3 d9				exx 
25d4			 
25d4			 
25d4			.fnt2cmpmore:	 
25d4				; compare the rest 
25d4				 
25d4 23				inc hl 
25d5 13				inc de 
25d6				 
25d6 1a				ld a, (de) 
25d7 4f				ld c,a 
25d8 7e				ld a,(hl) 
25d9 cd 24 14			call toUpper 
25dc			 
25dc					if DEBUG_FORTH 
25dc						DMARK "NT2" 
25dc						CALLMONITOR 
25dc					endif 
25dc				; c has the token to find char 
25dc				; a has the mem to scan char 
25dc			 
25dc b9				cp c 
25dd 28 04			jr z,.fntmatch1 
25df			 
25df				; they are not the same 
25df			 
25df					if DEBUG_FORTH 
25df						DMARK "NT3" 
25df						CALLMONITOR 
25df					endif 
25df d1				pop de	; reset de token to look for 
25e0 d5				push de 
25e1 18 e1			jr .fnt1 
25e3				 
25e3			.fntmatch1: 
25e3			 
25e3				; is the same char a null which means we might have a full hit? 
25e3					if DEBUG_FORTH 
25e3						DMARK "NT4" 
25e3						CALLMONITOR 
25e3					endif 
25e3			 
25e3 fe 00			cp 0 
25e5 28 0b			jr z, .fntmatchyes 
25e7			 
25e7				; are we at the end of the token to find? 
25e7			 
25e7					if DEBUG_FORTH 
25e7						DMARK "NT5" 
25e7						CALLMONITOR 
25e7					endif 
25e7 3e 00			ld a, 0 
25e9 b9				cp c 
25ea			 
25ea c2 d4 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
25ed			 
25ed					if DEBUG_FORTH 
25ed						DMARK "NT6" 
25ed						CALLMONITOR 
25ed					endif 
25ed				; token to find is exhusted but no match to stream 
25ed			 
25ed				; restore tok pointer and continue on 
25ed d1				pop de 
25ee d5				push de 
25ef c3 c4 25			jp .fnt1 
25f2			 
25f2			 
25f2			.fntmatchyes: 
25f2			 
25f2				; hl now contains the end of the found token 
25f2			 
25f2				; get rid of saved token pointer to find 
25f2			 
25f2 d1				pop de 
25f3			 
25f3					if DEBUG_FORTH 
25f3						DMARK "NT9" 
25f3						CALLMONITOR 
25f3					endif 
25f3			 
25f3				; hl will be on the null term so forward on 
25f3			 
25f3				; get back the saved start of the token 
25f3			 
25f3 d9				exx 
25f4 e5				push hl     ; save start of token just in case it is the right one 
25f5 d9				exx 
25f6 e1				pop hl        ; save it to hl 
25f7			 
25f7 c9				ret 
25f8			 
25f8			 
25f8			; LIST needs to find a specific token   
25f8			; FORGET needs to find a spefici token 
25f8			 
25f8			; SAVE needs to find all tokens by flag 
25f8			; WORDS just needs to scan through all  by flag 
25f8			; UWORDS needs to scan through all by flag 
25f8			 
25f8			 
25f8			; given hl as pointer to start of dict look up string 
25f8			; return hl as pointer to start of word block 
25f8			; or 0 if not found 
25f8			 
25f8			forth_find_tok: 
25f8 c9				ret 
25f9			 
25f9			; given hl as pointer to dict structure 
25f9			; move to the next dict block structure 
25f9			 
25f9			forth_tok_next: 
25f9				; hl now points to the address of the next word pointer  
25f9				; TODO skip compiled symbol for now 
25f9			;	push de 
25f9 23				inc hl 
25fa 5e				ld e, (hl) 
25fb 23				inc hl 
25fc 56				ld d, (hl) 
25fd 23				inc hl 
25fe			 
25fe eb				ex de,hl 
25ff			if DEBUG_FORTH_PARSE_NEXTWORD 
25ff				push bc 
25ff				ld bc, (cli_nextword) 
25ff						DMARK "NXW" 
25ff				CALLMONITOR 
25ff				pop bc 
25ff			endif 
25ff			;	pop de	 
25ff c9				ret 
2600			 
2600			 
2600			 
2600			; eof 
# End of file forth_parserv5.asm
2600				include "forth_wordsv4.asm" 
2600			 
2600			; the core word dictionary v4 
2600			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2600			 
2600			; this is a linked list for each of the system words used 
2600			; user defined words will follow the same format but will be in ram 
2600			 
2600			 
2600			; 
2600			; 
2600			; define linked list: 
2600			; 
2600			; 1. compiled byte op code 
2600			; 2. len of text word 
2600			; 3. text word 
2600			; 4. ptr to next dictionary word 
2600			; 5. asm, calls etc for the word 
2600			; 
2600			;  if 1 == 0 then last word in dict  
2600			;   
2600			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2600			;  
2600			;  
2600			; create basic standard set of words 
2600			; 
2600			;  
2600			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2600			; 2DUP 2DROP 2SWAP  
2600			; @ C@ - get byte  
2600			; ! C! - store byte 
2600			; 0< true if less than zero 
2600			; 0= true if zero 
2600			; < >  
2600			; = true if same 
2600			; variables 
2600			 
2600			 
2600			; Hardware specific words I may need 
2600			; 
2600			; IN OUT  
2600			; calls to key util functions 
2600			; calls to hardward abstraction stuff 
2600			; easy control of frame buffers and lcd i/o 
2600			; keyboard  
2600			 
2600			 
2600			;DICT: macro 
2600			; op_code, len, word, next 
2600			;    word: 
2600			;    db op_code 
2600			;    ds word zero term 
2600			;    dw next 
2600			;    endm 
2600			 
2600			 
2600			 
2600			 
2600			; op code 1 is a flag for user define words which are to be handled differently 
2600			 
2600			 
2600			; 
2600			; 
2600			;    TODO on entry to a word this should be the expected environment 
2600			;    hl - tos value if number then held, if string this is the ptr 
2600			;    de -  
2600			 
2600			 
2600			; opcode ranges 
2600			; 0 - end of word dict 
2600			; 255 - user define words 
2600			 
2600			sysdict: 
2600			include "forth_opcodes.asm" 
2600			; op codes for forth keywords 
2600			; free to use code 0  
2600				OPCODE_HEAP: equ  1 
2600				OPCODE_EXEC: equ 2 
2600				OPCODE_DUP: equ 3 
2600				OPCODE_SWAP: equ 4 
2600				OPCODE_COLN: equ 5 
2600				OPCODE_SCOLN: equ 6 
2600				OPCODE_DROP: equ 7 
2600				OPCODE_DUP2: equ 8 
2600				OPCODE_DROP2: equ 9 
2600				OPCODE_SWAP2: equ 10 
2600				OPCODE_AT: equ 11 
2600				OPCODE_CAT: equ 12 
2600				OPCODE_BANG: equ 13 
2600				OPCODE_CBANG: equ 14 
2600				OPCODE_SCALL: equ 15 
2600				OPCODE_DEPTH: equ 16 
2600				OPCODE_OVER: equ 17 
2600				OPCODE_PAUSE: equ 18 
2600				OPCODE_PAUSES: equ 19 
2600				OPCODE_ROT: equ 20 
2600			;free to reuse	OPCODE_WORDS: equ 21 
2600			        OPCODE_NOT: equ 21 
2600				OPCODE_UWORDS: equ 22 
2600				OPCODE_BP: equ 23 
2600				OPCODE_MONITOR: equ 24  
2600				OPCODE_MALLOC: equ 25 
2600				OPCODE_FREE: equ 26 
2600				OPCODE_LIST: equ 27 
2600				OPCODE_FORGET: equ 28 
2600				OPCODE_NOP: equ 29 
2600				OPCODE_COMO: equ 30 
2600				OPCODE_COMC: equ 31 
2600			;free to reuse	OPCODE_ENDCORE: equ 32 
2600				OPCODE_AFTERSOUND: equ 33 
2600				OPCODE_GP2: equ 34 
2600				OPCODE_GP3: equ 35 
2600				OPCODE_GP4: equ 36 
2600				OPCODE_SIN: equ 37 
2600				OPCODE_SOUT: equ 38 
2600				OPCODE_SPIO: equ 39 
2600				OPCODE_SPICEH: equ 40 
2600				OPCODE_SPIOb: equ 41 
2600				OPCODE_SPII: equ 42 
2600				OPCODE_SESEL: equ 43 
2600				OPCODE_CARTDEV: equ 44 
2600			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2600				OPCODE_FB: equ 46 
2600				OPCODE_EMIT: equ 47 
2600				OPCODE_DOTH: equ 48 
2600				OPCODE_DOTF: equ 49 
2600				OPCODE_DOT: equ 50 
2600				OPCODE_CLS: equ 51 
2600				OPCODE_DRAW: equ 52 
2600				OPCODE_DUMP: equ 53 
2600				OPCODE_CDUMP: equ 54 
2600				OPCODE_DAT: equ 55 
2600				OPCODE_HOME: equ 56 
2600				OPCODE_SPACE: equ 57 
2600				OPCODE_SPACES: equ 58 
2600				OPCODE_SCROLL: equ 59 
2600				OPCODE_ATQ: equ 60 
2600				OPCODE_AUTODSP: equ 61 
2600				OPCODE_MENU: equ 62 
2600			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2600				OPCODE_THEN: equ 64 
2600				OPCODE_ELSE: equ 65 
2600				OPCODE_DO: equ 66 
2600				OPCODE_LOOP: equ 67 
2600				OPCODE_I: equ 68 
2600				OPCODE_DLOOP: equ 69  
2600				OPCODE_REPEAT: equ 70  
2600				OPCODE_UNTIL: equ 71 
2600				OPCODE_ENDFLOW: equ 72 
2600				OPCODE_WAITK: equ 73 
2600				OPCODE_ACCEPT: equ 74 
2600				OPCODE_EDIT: equ 75 
2600			;free to reuse	OPCODE_ENDKEY: equ 76 
2600				OPCODE_LZERO: equ 77 
2600				OPCODE_TZERO: equ 78 
2600				OPCODE_LESS: equ 79 
2600				OPCODE_GT: equ 80 
2600				OPCODE_EQUAL: equ 81  
2600			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2600				OPCODE_NEG: equ 83 
2600				OPCODE_DIV: equ 84 
2600				OPCODE_MUL: equ 85 
2600				OPCODE_MIN: equ 86 
2600				OPCODE_MAX: equ 87 
2600				OPCODE_RND16: equ 88 
2600				OPCODE_RND8: equ 89 
2600				OPCODE_RND: equ 90 
2600			;free to reuse	OPCODE_ENDMATHS: equ 91  
2600				OPCODE_BYNAME: equ 92 
2600				OPCODE_DIR: equ 93 
2600				OPCODE_SAVE: equ 94 
2600				OPCODE_LOAD: equ 95 
2600				OPCODE_BSAVE: equ 96 
2600				OPCODE_BLOAD: equ 97 
2600				OPCODE_SEO: equ 98  
2600				OPCODE_SEI: equ 99 
2600				OPCODE_SFREE: equ 100 
2600				OPCODE_SIZE: equ 101 
2600				OPCODE_CREATE: equ 102 
2600				OPCODE_APPEND: equ 103 
2600				OPCODE_SDEL: equ 104 
2600				OPCODE_OPEN: equ 105 
2600				OPCODE_READ: equ 106 
2600				OPCODE_EOF: equ 106 
2600				OPCODE_FORMAT: equ 107 
2600				OPCODE_LABEL: equ 108 
2600				OPCODE_LABELS: equ 109 
2600			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2600				OPCODE_UPPER: equ 111 
2600				OPCODE_LOWER: equ 112 
2600				OPCODE_SUBSTR: equ 113 
2600				OPCODE_LEFT: equ 114 
2600				OPCODE_RIGHT: equ 115 
2600				OPCODE_STR2NUM: equ 116 
2600				OPCODE_NUM2STR: equ 117 
2600				OPCODE_CONCAT: equ 118 
2600				OPCODE_FIND: equ 119 
2600				OPCODE_LEN: equ 120 
2600				OPCODE_CHAR: equ 121 
2600			; free to reuse	OPCODE_STRLEN: equ 122 
2600			; free to reuse	OPCODE_ENDSTR: equ 123 
2600				OPCODE_V0S: equ 124 
2600				OPCODE_V0Q: equ 125 
2600				OPCODE_V1S: equ 126 
2600				OPCODE_V1Q: equ 127 
2600				OPCODE_V2S: equ 128 
2600				OPCODE_V2Q: equ 129 
2600				OPCODE_V3S: equ 130 
2600				OPCODE_V3Q: equ 131 
2600			;free to reuse	OPCODE_END: equ 132 
2600				OPCODE_ZDUP: equ 133 
2600			 
2600			; eof 
# End of file forth_opcodes.asm
2600			 
2600			include "forth_words_core.asm" 
2600			 
2600			; | ## Core Words 
2600			 
2600			;if MALLOC_4 
2600			 
2600			.HEAP: 
2600			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2600 15				db WORD_SYS_CORE+OPCODE_HEAP             
2601 3f 26			dw .EXEC            
2603 05				db 4 + 1 
2604 .. 00			db "HEAP",0              
2609				endm 
# End of macro CWHEAD
2609			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2609			; | | u1 - Current number of bytes in the heap 
2609			; | | u2 - Remaining bytes left on the heap 
2609			; | |  
2609			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2609			 
2609			 
2609				if DEBUG_FORTH_WORDS_KEY 
2609					DMARK "HEP" 
2609 f5				push af  
260a 3a 1e 26			ld a, (.dmark)  
260d 32 68 fe			ld (debug_mark),a  
2610 3a 1f 26			ld a, (.dmark+1)  
2613 32 69 fe			ld (debug_mark+1),a  
2616 3a 20 26			ld a, (.dmark+2)  
2619 32 6a fe			ld (debug_mark+2),a  
261c 18 03			jr .pastdmark  
261e ..			.dmark: db "HEP"  
2621 f1			.pastdmark: pop af  
2622			endm  
# End of macro DMARK
2622					CALLMONITOR 
2622 cd 6c fe			call debug_vector  
2625				endm  
# End of macro CALLMONITOR
2625				endif 
2625 2a 0a 80			ld hl, (free_list )      
2628 11 0e 80			ld de, heap_start 
262b			 
262b ed 52			sbc hl, de  
262d			 
262d cd fb 20			call forth_push_numhl 
2630			 
2630			 
2630 ed 5b 0a 80		ld de, (free_list )      
2634 21 99 f1			ld hl, heap_end 
2637			 
2637 ed 52			sbc hl, de 
2639			 
2639 cd fb 20			call forth_push_numhl 
263c				 
263c			 
263c				 
263c			 
263c			 
263c			 
263c				NEXTW 
263c c3 a8 24			jp macro_next 
263f				endm 
# End of macro NEXTW
263f			;endif 
263f			 
263f			.EXEC: 
263f			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
263f			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
263f			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
263f			;; > > 
263f			;; > >   
263f			;	STACKFRAME OFF $5efe $5f9f 
263f			; 
263f			;		if DEBUG_FORTH_WORDS_KEY 
263f			;			DMARK "EXE" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			; 
263f			;	FORTH_DSP_VALUEHL 
263f			; 
263f			;	FORTH_DSP_POP 
263f			; 
263f			;		if DEBUG_FORTH_WORDS 
263f			;			DMARK "EX1" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			;;	ld e,(hl) 
263f			;;	inc hl 
263f			;;	ld d,(hl) 
263f			;;	ex de,hl 
263f			; 
263f			;;		if DEBUG_FORTH_WORDS 
263f			;;			DMARK "EX2" 
263f			;;			CALLMONITOR 
263f			;;		endif 
263f			;	push hl 
263f			; 
263f			;	;ld a, 0 
263f			;	;ld a, FORTH_END_BUFFER 
263f			;	call strlenz 
263f			;	inc hl   ; include zero term to copy 
263f			;	inc hl   ; include term 
263f			;	inc hl   ; include term 
263f			;	ld b,0 
263f			;	ld c,l 
263f			;	pop hl 
263f			;	ld de, execscratch 
263f			;		if DEBUG_FORTH_WORDS 
263f			;			DMARK "EX3" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			;	ldir 
263f			; 
263f			; 
263f			;	ld hl, execscratch 
263f			; 
263f			;		if DEBUG_FORTH_WORDS 
263f			;			DMARK "EXe" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			; 
263f			;	call forthparse 
263f			;	call forthexec 
263f			;;	call forthexec_cleanup 
263f			;;	call forthparse 
263f			;;	call forthexec 
263f			; 
263f			;	STACKFRAMECHK OFF $5efe $5f9f 
263f			; 
263f			;	; an immediate word so no need to process any more words 
263f			;	ret 
263f			;	NEXTW 
263f			 
263f			; dead code - old version  
263f			;	FORTH_RSP_NEXT 
263f			 
263f			;  
263f			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
263f			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
263f			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
263f			;	push hl 
263f			;	push de 
263f			;	push bc 
263f			; 
263f			; 
263f			;		if DEBUG_FORTH_WORDS_KEY 
263f			;			DMARK "EXR" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			; 
263f			; 
263f			; 
263f			;	;v5 FORTH_DSP_VALUE 
263f			;	FORTH_DSP_VALUEHL 
263f			; 
263f			;	; TODO do string type checks 
263f			; 
263f			;;v5	inc hl   ; skip type 
263f			; 
263f			;	push hl  ; source code  
263f			;		if DEBUG_FORTH_WORDS 
263f			;			DMARK "EX1" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			;	ld a, 0 
263f			;	call strlent 
263f			; 
263f			;	inc hl 
263f			;	inc hl 
263f			;	inc hl 
263f			;	inc hl 
263f			; 
263f			;	push hl    ; size 
263f			; 
263f			;		if DEBUG_FORTH_WORDS 
263f			;			DMARK "EX2" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			;	call malloc 
263f			; 
263f			;	ex de, hl    ; de now contains malloc area 
263f			;	pop bc   	; get byte count 
263f			;	pop hl      ; get string to copy 
263f			; 
263f			;	push de     ; save malloc for free later 
263f			; 
263f			;		if DEBUG_FORTH_WORDS 
263f			;			DMARK "EX3" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			;	ldir       ; duplicate string 
263f			; 
263f			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
263f			;	 
263f			;	; TODO fix the parse would be better than this...  
263f			;	ex de, hl 
263f			;	dec hl 
263f			;	ld a, 0 
263f			;	ld (hl), a 
263f			;	dec hl 
263f			;	ld a, ' ' 
263f			;	ld (hl), a 
263f			;	dec hl 
263f			;	ld (hl), a 
263f			; 
263f			;	dec hl 
263f			;	ld (hl), a 
263f			; 
263f			; 
263f			;	FORTH_DSP_POP  
263f			; 
263f			;	pop hl     
263f			;	push hl    ; save malloc area 
263f			; 
263f			;		if DEBUG_FORTH_WORDS 
263f			;			DMARK "EX4" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			; 
263f			;	call forthparse 
263f			;	call forthexec 
263f			;	 
263f			;	pop hl 
263f			;	if DEBUG_FORTH_WORDS 
263f			;		DMARK "EX5" 
263f			;		CALLMONITOR 
263f			;	endif 
263f			; 
263f			;	if FORTH_ENABLE_FREE 
263f			;	call free 
263f			;	endif 
263f			; 
263f			;	if DEBUG_FORTH_WORDS 
263f			;		DMARK "EX6" 
263f			;		CALLMONITOR 
263f			;	endif 
263f			; 
263f			;	pop bc 
263f			;	pop de 
263f			;	pop hl 
263f			;;	FORTH_RSP_POP	  
263f			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
263f			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
263f			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
263f			; 
263f			;	if DEBUG_FORTH_WORDS 
263f			;		DMARK "EX7" 
263f			;		CALLMONITOR 
263f			;	endif 
263f			;	NEXTW 
263f			 
263f			;.STKEXEC: 
263f			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
263f			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
263f			; 
263f			; 
263f			;		if DEBUG_FORTH_WORDS_KEY 
263f			;			DMARK "STX" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			; 
263f			;	FORTH_DSP_VALUEHL 
263f			; 
263f			;	ld (store_tmp1), hl    ; count 
263f			; 
263f			;	FORTH_DSP_POP 
263f			;.stkexec1: 
263f			;	ld hl, (store_tmp1)   ; count 
263f			;	ld a, 0 
263f			;	cp l 
263f			;	ret z 
263f			; 
263f			;	dec hl 
263f			;	ld (store_tmp1), hl    ; count 
263f			;	 
263f			;	FORTH_DSP_VALUEHL 
263f			;	push hl 
263f			;	 
263f			;		if DEBUG_FORTH_WORDS 
263f			;			DMARK "EXp" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			;	FORTH_DSP_POP 
263f			; 
263f			;	call strlenz 
263f			;	inc hl   ; include zero term to copy 
263f			;	inc hl   ; include zero term to copy 
263f			;	inc hl   ; include zero term to copy 
263f			;	ld b,0 
263f			;	ld c,l 
263f			;	pop hl 
263f			;	ld de, execscratch 
263f			;		if DEBUG_FORTH_WORDS 
263f			;			DMARK "EX3" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			;	ldir 
263f			; 
263f			; 
263f			;	ld hl, execscratch 
263f			; 
263f			;		if DEBUG_FORTH_WORDS 
263f			;			DMARK "EXP" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			; 
263f			;	call forthparse 
263f			;	ld hl, execscratch 
263f			;		if DEBUG_FORTH_WORDS 
263f			;			DMARK "EXx" 
263f			;			CALLMONITOR 
263f			;		endif 
263f			;	call forthexec 
263f			; 
263f			;	jp .stkexec1 
263f			; 
263f			;	ret 
263f			 
263f			 
263f			.DUP: 
263f			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
263f 17				db WORD_SYS_CORE+OPCODE_DUP             
2640 b5 26			dw .ZDUP            
2642 04				db 3 + 1 
2643 .. 00			db "DUP",0              
2647				endm 
# End of macro CWHEAD
2647			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2647			 
2647				if DEBUG_FORTH_WORDS_KEY 
2647					DMARK "DUP" 
2647 f5				push af  
2648 3a 5c 26			ld a, (.dmark)  
264b 32 68 fe			ld (debug_mark),a  
264e 3a 5d 26			ld a, (.dmark+1)  
2651 32 69 fe			ld (debug_mark+1),a  
2654 3a 5e 26			ld a, (.dmark+2)  
2657 32 6a fe			ld (debug_mark+2),a  
265a 18 03			jr .pastdmark  
265c ..			.dmark: db "DUP"  
265f f1			.pastdmark: pop af  
2660			endm  
# End of macro DMARK
2660					CALLMONITOR 
2660 cd 6c fe			call debug_vector  
2663				endm  
# End of macro CALLMONITOR
2663				endif 
2663			 
2663				FORTH_DSP 
2663 cd b8 22			call macro_forth_dsp 
2666				endm 
# End of macro FORTH_DSP
2666			 
2666 7e				ld a, (HL) 
2667 fe 01			cp DS_TYPE_STR 
2669 20 25			jr nz, .dupinum 
266b			 
266b				; push another string 
266b			 
266b				FORTH_DSP_VALUEHL     		 
266b cd f2 22			call macro_dsp_valuehl 
266e				endm 
# End of macro FORTH_DSP_VALUEHL
266e			 
266e			if DEBUG_FORTH_WORDS 
266e				DMARK "DUs" 
266e f5				push af  
266f 3a 83 26			ld a, (.dmark)  
2672 32 68 fe			ld (debug_mark),a  
2675 3a 84 26			ld a, (.dmark+1)  
2678 32 69 fe			ld (debug_mark+1),a  
267b 3a 85 26			ld a, (.dmark+2)  
267e 32 6a fe			ld (debug_mark+2),a  
2681 18 03			jr .pastdmark  
2683 ..			.dmark: db "DUs"  
2686 f1			.pastdmark: pop af  
2687			endm  
# End of macro DMARK
2687				CALLMONITOR 
2687 cd 6c fe			call debug_vector  
268a				endm  
# End of macro CALLMONITOR
268a			endif 
268a cd 69 21			call forth_push_str 
268d			 
268d				NEXTW 
268d c3 a8 24			jp macro_next 
2690				endm 
# End of macro NEXTW
2690			 
2690			 
2690			.dupinum: 
2690				 
2690			 
2690			 
2690				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2690 cd f2 22			call macro_dsp_valuehl 
2693				endm 
# End of macro FORTH_DSP_VALUEHL
2693			 
2693			; TODO add floating point number detection 
2693			 
2693			if DEBUG_FORTH_WORDS 
2693				DMARK "DUi" 
2693 f5				push af  
2694 3a a8 26			ld a, (.dmark)  
2697 32 68 fe			ld (debug_mark),a  
269a 3a a9 26			ld a, (.dmark+1)  
269d 32 69 fe			ld (debug_mark+1),a  
26a0 3a aa 26			ld a, (.dmark+2)  
26a3 32 6a fe			ld (debug_mark+2),a  
26a6 18 03			jr .pastdmark  
26a8 ..			.dmark: db "DUi"  
26ab f1			.pastdmark: pop af  
26ac			endm  
# End of macro DMARK
26ac				CALLMONITOR 
26ac cd 6c fe			call debug_vector  
26af				endm  
# End of macro CALLMONITOR
26af			endif 
26af			 
26af cd fb 20			call forth_push_numhl 
26b2				NEXTW 
26b2 c3 a8 24			jp macro_next 
26b5				endm 
# End of macro NEXTW
26b5			.ZDUP: 
26b5			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
26b5 99				db WORD_SYS_CORE+OPCODE_ZDUP             
26b6 ed 26			dw .SWAP            
26b8 05				db 4 + 1 
26b9 .. 00			db "?DUP",0              
26be				endm 
# End of macro CWHEAD
26be			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
26be			 
26be				if DEBUG_FORTH_WORDS_KEY 
26be					DMARK "qDU" 
26be f5				push af  
26bf 3a d3 26			ld a, (.dmark)  
26c2 32 68 fe			ld (debug_mark),a  
26c5 3a d4 26			ld a, (.dmark+1)  
26c8 32 69 fe			ld (debug_mark+1),a  
26cb 3a d5 26			ld a, (.dmark+2)  
26ce 32 6a fe			ld (debug_mark+2),a  
26d1 18 03			jr .pastdmark  
26d3 ..			.dmark: db "qDU"  
26d6 f1			.pastdmark: pop af  
26d7			endm  
# End of macro DMARK
26d7					CALLMONITOR 
26d7 cd 6c fe			call debug_vector  
26da				endm  
# End of macro CALLMONITOR
26da				endif 
26da				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26da cd f2 22			call macro_dsp_valuehl 
26dd				endm 
# End of macro FORTH_DSP_VALUEHL
26dd			 
26dd e5				push hl 
26de			 
26de				; is it a zero? 
26de			 
26de 3e 00			ld a, 0 
26e0 84				add h 
26e1 85				add l 
26e2			 
26e2 e1				pop hl 
26e3			 
26e3 fe 00			cp 0 
26e5 28 03			jr z, .dup2orig 
26e7			 
26e7			 
26e7 cd fb 20			call forth_push_numhl 
26ea			 
26ea			 
26ea			; TODO add floating point number detection 
26ea			 
26ea			.dup2orig: 
26ea			 
26ea				NEXTW 
26ea c3 a8 24			jp macro_next 
26ed				endm 
# End of macro NEXTW
26ed			.SWAP: 
26ed			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26ed 18				db WORD_SYS_CORE+OPCODE_SWAP             
26ee 2c 27			dw .COLN            
26f0 05				db 4 + 1 
26f1 .. 00			db "SWAP",0              
26f6				endm 
# End of macro CWHEAD
26f6			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
26f6				if DEBUG_FORTH_WORDS_KEY 
26f6					DMARK "SWP" 
26f6 f5				push af  
26f7 3a 0b 27			ld a, (.dmark)  
26fa 32 68 fe			ld (debug_mark),a  
26fd 3a 0c 27			ld a, (.dmark+1)  
2700 32 69 fe			ld (debug_mark+1),a  
2703 3a 0d 27			ld a, (.dmark+2)  
2706 32 6a fe			ld (debug_mark+2),a  
2709 18 03			jr .pastdmark  
270b ..			.dmark: db "SWP"  
270e f1			.pastdmark: pop af  
270f			endm  
# End of macro DMARK
270f					CALLMONITOR 
270f cd 6c fe			call debug_vector  
2712				endm  
# End of macro CALLMONITOR
2712				endif 
2712			 
2712			; TODO Use os stack swap memory 
2712				FORTH_DSP_VALUEHL 
2712 cd f2 22			call macro_dsp_valuehl 
2715				endm 
# End of macro FORTH_DSP_VALUEHL
2715 e5				push hl     ; w2 
2716			 
2716				FORTH_DSP_POP 
2716 cd aa 23			call macro_forth_dsp_pop 
2719				endm 
# End of macro FORTH_DSP_POP
2719			 
2719				FORTH_DSP_VALUEHL 
2719 cd f2 22			call macro_dsp_valuehl 
271c				endm 
# End of macro FORTH_DSP_VALUEHL
271c			 
271c				FORTH_DSP_POP 
271c cd aa 23			call macro_forth_dsp_pop 
271f				endm 
# End of macro FORTH_DSP_POP
271f			 
271f d1				pop de     ; w2	, hl = w1 
2720			 
2720 eb				ex de, hl 
2721 d5				push de 
2722			 
2722 cd fb 20			call forth_push_numhl 
2725			 
2725 e1				pop hl 
2726			 
2726 cd fb 20			call forth_push_numhl 
2729				 
2729			 
2729				NEXTW 
2729 c3 a8 24			jp macro_next 
272c				endm 
# End of macro NEXTW
272c			.COLN: 
272c			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
272c 19				db WORD_SYS_CORE+OPCODE_COLN             
272d b8 28			dw .SCOLN            
272f 02				db 1 + 1 
2730 .. 00			db ":",0              
2732				endm 
# End of macro CWHEAD
2732			; | : ( -- )         Create new word | DONE 
2732			 
2732				if DEBUG_FORTH_WORDS_KEY 
2732					DMARK "CLN" 
2732 f5				push af  
2733 3a 47 27			ld a, (.dmark)  
2736 32 68 fe			ld (debug_mark),a  
2739 3a 48 27			ld a, (.dmark+1)  
273c 32 69 fe			ld (debug_mark+1),a  
273f 3a 49 27			ld a, (.dmark+2)  
2742 32 6a fe			ld (debug_mark+2),a  
2745 18 03			jr .pastdmark  
2747 ..			.dmark: db "CLN"  
274a f1			.pastdmark: pop af  
274b			endm  
# End of macro DMARK
274b					CALLMONITOR 
274b cd 6c fe			call debug_vector  
274e				endm  
# End of macro CALLMONITOR
274e				endif 
274e			STACKFRAME OFF $8efe $989f 
274e				if DEBUG_STACK_IMB 
274e					if OFF 
274e						exx 
274e						ld de, $8efe 
274e						ld a, d 
274e						ld hl, curframe 
274e						call hexout 
274e						ld a, e 
274e						ld hl, curframe+2 
274e						call hexout 
274e						ld hl, $8efe 
274e						push hl 
274e						ld hl, $989f 
274e						push hl 
274e						exx 
274e					endif 
274e				endif 
274e			endm 
# End of macro STACKFRAME
274e			; get parser buffer length  of new word 
274e			 
274e			 
274e			 
274e				; move tok past this to start of name defintition 
274e				; TODO get word to define 
274e				; TODO Move past word token 
274e				; TODO get length of string up to the ';' 
274e			 
274e 2a bf f4		ld hl, (os_tok_ptr) 
2751 23			inc hl 
2752 23			inc hl 
2753			 
2753 3e 3b		ld a, ';' 
2755 cd 38 14		call strlent 
2758			 
2758 7d			ld a,l 
2759 32 ae f1		ld (os_new_parse_len), a 
275c			 
275c			 
275c			if DEBUG_FORTH_UWORD 
275c ed 5b bf f4	ld de, (os_tok_ptr) 
2760					DMARK ":01" 
2760 f5				push af  
2761 3a 75 27			ld a, (.dmark)  
2764 32 68 fe			ld (debug_mark),a  
2767 3a 76 27			ld a, (.dmark+1)  
276a 32 69 fe			ld (debug_mark+1),a  
276d 3a 77 27			ld a, (.dmark+2)  
2770 32 6a fe			ld (debug_mark+2),a  
2773 18 03			jr .pastdmark  
2775 ..			.dmark: db ":01"  
2778 f1			.pastdmark: pop af  
2779			endm  
# End of macro DMARK
2779			CALLMONITOR 
2779 cd 6c fe			call debug_vector  
277c				endm  
# End of macro CALLMONITOR
277c			endif 
277c			 
277c			; 
277c			;  new word memory layout: 
277c			;  
277c			;    : adg 6666 ;  
277c			; 
277c			;    db   1     ; user defined word  
277c 23			inc hl    
277d			;    dw   sysdict 
277d 23			inc hl 
277e 23			inc hl 
277f			;    db <word len>+1 (for null) 
277f 23			inc hl 
2780			;    db .... <word> 
2780			; 
2780			 
2780 23			inc hl    ; some extras for the word preamble before the above 
2781 23			inc hl 
2782 23			inc hl 
2783 23			inc hl 
2784 23			inc hl 
2785 23			inc hl 
2786 23			inc hl  
2787 23			inc hl 
2788 23			inc hl 
2789 23			inc hl 
278a 23			inc hl 
278b 23			inc hl 
278c 23			inc hl 
278d 23			inc hl     ; TODO how many do we really need?     maybe only 6 
278e			;       exec word buffer 
278e			;	<ptr word>   
278e 23			inc hl 
278f 23			inc hl 
2790			;       <word list><null term> 7F final term 
2790			 
2790			 
2790			if DEBUG_FORTH_UWORD 
2790					DMARK ":02" 
2790 f5				push af  
2791 3a a5 27			ld a, (.dmark)  
2794 32 68 fe			ld (debug_mark),a  
2797 3a a6 27			ld a, (.dmark+1)  
279a 32 69 fe			ld (debug_mark+1),a  
279d 3a a7 27			ld a, (.dmark+2)  
27a0 32 6a fe			ld (debug_mark+2),a  
27a3 18 03			jr .pastdmark  
27a5 ..			.dmark: db ":02"  
27a8 f1			.pastdmark: pop af  
27a9			endm  
# End of macro DMARK
27a9			CALLMONITOR 
27a9 cd 6c fe			call debug_vector  
27ac				endm  
# End of macro CALLMONITOR
27ac			endif 
27ac			 
27ac			 
27ac				; malloc the size 
27ac			 
27ac cd 96 14			call malloc 
27af 22 b0 f1			ld (os_new_malloc), hl     ; save malloc start 
27b2			 
27b2			;    db   1     ; user defined word  
27b2 3e 01			ld a, WORD_SYS_UWORD  
27b4 77				ld (hl), a 
27b5			 
27b5 23			inc hl    
27b6			;    dw   sysdict 
27b6 11 00 26		ld de, sysdict       ; continue on with the scan to the system dict 
27b9 73			ld (hl), e 
27ba 23			inc hl 
27bb 72			ld (hl), d 
27bc 23			inc hl 
27bd			 
27bd			 
27bd			;    Setup dict word 
27bd			 
27bd 23			inc hl 
27be 22 aa f1		ld (os_new_work_ptr), hl     ; save start of dict word  
27c1			 
27c1			; 1. get length of dict word 
27c1			 
27c1			 
27c1 2a bf f4		ld hl, (os_tok_ptr) 
27c4 23			inc hl 
27c5 23			inc hl    ; position to start of dict word 
27c6 3e 00		ld a, 0 
27c8 cd 38 14		call strlent 
27cb			 
27cb			 
27cb 23			inc hl    ; to include null??? 
27cc			 
27cc			; write length of dict word 
27cc			 
27cc ed 5b aa f1	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27d0 1b			dec de 
27d1 eb			ex de, hl 
27d2 73			ld (hl), e 
27d3 eb			ex de, hl 
27d4			 
27d4			 
27d4			 
27d4			; copy  
27d4 4d			ld c, l 
27d5 06 00		ld b, 0 
27d7 ed 5b aa f1	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27db 2a bf f4		ld hl, (os_tok_ptr) 
27de 23			inc hl 
27df 23			inc hl    ; position to start of dict word 
27e0			 
27e0			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27e0			 
27e0			; TODO need to convert word to upper case 
27e0			 
27e0			ucasetok:	 
27e0 7e			ld a,(hl) 
27e1 cd 24 14		call toUpper 
27e4 77			ld (hl),a 
27e5 ed a0		ldi 
27e7 f2 e0 27		jp p, ucasetok 
27ea			 
27ea			 
27ea			 
27ea			; de now points to start of where the word body code should be placed 
27ea ed 53 aa f1	ld (os_new_work_ptr), de 
27ee			; hl now points to the words to throw at forthexec which needs to be copied 
27ee 22 a8 f1		ld (os_new_src_ptr), hl 
27f1			 
27f1			; TODO add 'call to forthexec' 
27f1			 
27f1			if DEBUG_FORTH_UWORD 
27f1 c5			push bc 
27f2 ed 4b b0 f1	ld bc, (os_new_malloc) 
27f6					DMARK ":0x" 
27f6 f5				push af  
27f7 3a 0b 28			ld a, (.dmark)  
27fa 32 68 fe			ld (debug_mark),a  
27fd 3a 0c 28			ld a, (.dmark+1)  
2800 32 69 fe			ld (debug_mark+1),a  
2803 3a 0d 28			ld a, (.dmark+2)  
2806 32 6a fe			ld (debug_mark+2),a  
2809 18 03			jr .pastdmark  
280b ..			.dmark: db ":0x"  
280e f1			.pastdmark: pop af  
280f			endm  
# End of macro DMARK
280f			CALLMONITOR 
280f cd 6c fe			call debug_vector  
2812				endm  
# End of macro CALLMONITOR
2812 c1			pop bc 
2813			endif 
2813			 
2813			 
2813			; create word preamble which should be: 
2813			 
2813			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2813			 
2813			;    ld hl, <word code> 
2813			;    jp user_exec 
2813			;    <word code bytes> 
2813			 
2813			 
2813			;	inc de     ; TODO ??? or are we already past the word's null 
2813 eb			ex de, hl 
2814			 
2814 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2816			 
2816 23			inc hl 
2817 22 a4 f1		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
281a 23			inc hl 
281b			 
281b 23			inc hl 
281c 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
281e			 
281e 01 6c 5d		ld bc, user_exec 
2821 23			inc hl 
2822 71			ld (hl), c     ; poke address of user_exec 
2823 23			inc hl 
2824 70			ld (hl), b     
2825			; 
2825			;	inc hl 
2825			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2825			; 
2825			; 
2825			;	ld bc, macro_forth_rsp_next 
2825			;	inc hl 
2825			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2825			;	inc hl 
2825			;	ld (hl), b     
2825			; 
2825			;	inc hl 
2825			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2825			; 
2825			; 
2825			;	inc hl 
2825			;	ld bc, forthexec 
2825			;	ld (hl), c     ; poke address of forthexec 
2825			;	inc hl 
2825			;	ld (hl), b      
2825			; 
2825			;	inc hl 
2825			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2825			; 
2825			;	ld bc, user_dict_next 
2825			;	inc hl 
2825			;	ld (hl), c     ; poke address of forthexec 
2825			;	inc hl 
2825			;	ld (hl), b      
2825			 
2825			; hl is now where we need to copy the word byte data to save this 
2825			 
2825 23			inc hl 
2826 22 a6 f1		ld (os_new_exec), hl 
2829			 
2829			; copy definition 
2829			 
2829 eb			ex de, hl 
282a			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
282a			;	inc de    ; skip the PC for this parse 
282a 3a ae f1		ld a, (os_new_parse_len) 
282d 4f			ld c, a 
282e 06 00		ld b, 0 
2830 ed b0		ldir		 ; copy defintion 
2832			 
2832			 
2832			; poke the address of where the new word bytes live for forthexec 
2832			 
2832 2a a4 f1		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2835			 
2835 ed 5b a6 f1	ld de, (os_new_exec)      
2839			 
2839 73			ld (hl), e 
283a 23			inc hl 
283b 72			ld (hl), d 
283c			 
283c				; TODO copy last user dict word next link to this word 
283c				; TODO update last user dict word to point to this word 
283c			; 
283c			; hl f923 de 812a ; bc 811a 
283c			 
283c			if DEBUG_FORTH_UWORD 
283c c5			push bc 
283d ed 4b b0 f1	ld bc, (os_new_malloc) 
2841					DMARK ":0A" 
2841 f5				push af  
2842 3a 56 28			ld a, (.dmark)  
2845 32 68 fe			ld (debug_mark),a  
2848 3a 57 28			ld a, (.dmark+1)  
284b 32 69 fe			ld (debug_mark+1),a  
284e 3a 58 28			ld a, (.dmark+2)  
2851 32 6a fe			ld (debug_mark+2),a  
2854 18 03			jr .pastdmark  
2856 ..			.dmark: db ":0A"  
2859 f1			.pastdmark: pop af  
285a			endm  
# End of macro DMARK
285a			CALLMONITOR 
285a cd 6c fe			call debug_vector  
285d				endm  
# End of macro CALLMONITOR
285d c1			pop bc 
285e			endif 
285e			if DEBUG_FORTH_UWORD 
285e c5			push bc 
285f ed 4b b0 f1	ld bc, (os_new_malloc) 
2863 03			inc bc 
2864 03			inc bc 
2865 03			inc bc 
2866 03			inc bc 
2867 03			inc bc 
2868 03			inc bc 
2869 03			inc bc 
286a 03			inc bc 
286b			 
286b					DMARK ":0B" 
286b f5				push af  
286c 3a 80 28			ld a, (.dmark)  
286f 32 68 fe			ld (debug_mark),a  
2872 3a 81 28			ld a, (.dmark+1)  
2875 32 69 fe			ld (debug_mark+1),a  
2878 3a 82 28			ld a, (.dmark+2)  
287b 32 6a fe			ld (debug_mark+2),a  
287e 18 03			jr .pastdmark  
2880 ..			.dmark: db ":0B"  
2883 f1			.pastdmark: pop af  
2884			endm  
# End of macro DMARK
2884			CALLMONITOR 
2884 cd 6c fe			call debug_vector  
2887				endm  
# End of macro CALLMONITOR
2887 c1			pop bc 
2888			endif 
2888			 
2888			; update word dict linked list for new word 
2888			 
2888			 
2888 2a bb f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
288b 23			inc hl     ; move to next work linked list ptr 
288c			 
288c ed 5b b0 f1	ld de, (os_new_malloc)		 ; new next word 
2890 73			ld (hl), e 
2891 23			inc hl 
2892 72			ld (hl), d 
2893			 
2893			if DEBUG_FORTH_UWORD 
2893 ed 4b bb f4	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2897			endif 
2897			 
2897 ed 53 bb f4	ld (os_last_new_uword), de      ; update last new uword ptr 
289b			 
289b			 
289b			if DEBUG_FORTH_UWORD 
289b					DMARK ":0+" 
289b f5				push af  
289c 3a b0 28			ld a, (.dmark)  
289f 32 68 fe			ld (debug_mark),a  
28a2 3a b1 28			ld a, (.dmark+1)  
28a5 32 69 fe			ld (debug_mark+1),a  
28a8 3a b2 28			ld a, (.dmark+2)  
28ab 32 6a fe			ld (debug_mark+2),a  
28ae 18 03			jr .pastdmark  
28b0 ..			.dmark: db ":0+"  
28b3 f1			.pastdmark: pop af  
28b4			endm  
# End of macro DMARK
28b4			CALLMONITOR 
28b4 cd 6c fe			call debug_vector  
28b7				endm  
# End of macro CALLMONITOR
28b7			endif 
28b7			 
28b7			STACKFRAMECHK OFF $8efe $989f 
28b7				if DEBUG_STACK_IMB 
28b7					if OFF 
28b7						exx 
28b7						ld hl, $989f 
28b7						pop de   ; $989f 
28b7						call cmp16 
28b7						jr nz, .spnosame 
28b7						ld hl, $8efe 
28b7						pop de   ; $8efe 
28b7						call cmp16 
28b7						jr z, .spfrsame 
28b7						.spnosame: call showsperror 
28b7						.spfrsame: nop 
28b7						exx 
28b7					endif 
28b7				endif 
28b7			endm 
# End of macro STACKFRAMECHK
28b7			 
28b7 c9			ret    ; dont process any remaining parser tokens as they form new word 
28b8			 
28b8			 
28b8			 
28b8			 
28b8			;		NEXT 
28b8			.SCOLN: 
28b8			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28b8 06			db OPCODE_SCOLN 
28b9 04 29		dw .DROP 
28bb 02			db 2 
28bc .. 00		db ";",0           
28be			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28be				if DEBUG_FORTH_WORDS_KEY 
28be					DMARK "SCN" 
28be f5				push af  
28bf 3a d3 28			ld a, (.dmark)  
28c2 32 68 fe			ld (debug_mark),a  
28c5 3a d4 28			ld a, (.dmark+1)  
28c8 32 69 fe			ld (debug_mark+1),a  
28cb 3a d5 28			ld a, (.dmark+2)  
28ce 32 6a fe			ld (debug_mark+2),a  
28d1 18 03			jr .pastdmark  
28d3 ..			.dmark: db "SCN"  
28d6 f1			.pastdmark: pop af  
28d7			endm  
# End of macro DMARK
28d7					CALLMONITOR 
28d7 cd 6c fe			call debug_vector  
28da				endm  
# End of macro CALLMONITOR
28da				endif 
28da				FORTH_RSP_TOS 
28da cd b9 20			call macro_forth_rsp_tos 
28dd				endm 
# End of macro FORTH_RSP_TOS
28dd e5				push hl 
28de				FORTH_RSP_POP 
28de cd c3 20			call macro_forth_rsp_pop 
28e1				endm 
# End of macro FORTH_RSP_POP
28e1 e1				pop hl 
28e2			;		ex de,hl 
28e2 22 bf f4			ld (os_tok_ptr),hl 
28e5			 
28e5			if DEBUG_FORTH_UWORD 
28e5					DMARK "SCL" 
28e5 f5				push af  
28e6 3a fa 28			ld a, (.dmark)  
28e9 32 68 fe			ld (debug_mark),a  
28ec 3a fb 28			ld a, (.dmark+1)  
28ef 32 69 fe			ld (debug_mark+1),a  
28f2 3a fc 28			ld a, (.dmark+2)  
28f5 32 6a fe			ld (debug_mark+2),a  
28f8 18 03			jr .pastdmark  
28fa ..			.dmark: db "SCL"  
28fd f1			.pastdmark: pop af  
28fe			endm  
# End of macro DMARK
28fe			CALLMONITOR 
28fe cd 6c fe			call debug_vector  
2901				endm  
# End of macro CALLMONITOR
2901			endif 
2901				NEXTW 
2901 c3 a8 24			jp macro_next 
2904				endm 
# End of macro NEXTW
2904			 
2904			.DROP: 
2904			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2904 1b				db WORD_SYS_CORE+OPCODE_DROP             
2905 2f 29			dw .DUP2            
2907 05				db 4 + 1 
2908 .. 00			db "DROP",0              
290d				endm 
# End of macro CWHEAD
290d			; | DROP ( w -- )   drop the TOS item   | DONE 
290d				if DEBUG_FORTH_WORDS_KEY 
290d					DMARK "DRP" 
290d f5				push af  
290e 3a 22 29			ld a, (.dmark)  
2911 32 68 fe			ld (debug_mark),a  
2914 3a 23 29			ld a, (.dmark+1)  
2917 32 69 fe			ld (debug_mark+1),a  
291a 3a 24 29			ld a, (.dmark+2)  
291d 32 6a fe			ld (debug_mark+2),a  
2920 18 03			jr .pastdmark  
2922 ..			.dmark: db "DRP"  
2925 f1			.pastdmark: pop af  
2926			endm  
# End of macro DMARK
2926					CALLMONITOR 
2926 cd 6c fe			call debug_vector  
2929				endm  
# End of macro CALLMONITOR
2929				endif 
2929				FORTH_DSP_POP 
2929 cd aa 23			call macro_forth_dsp_pop 
292c				endm 
# End of macro FORTH_DSP_POP
292c				NEXTW 
292c c3 a8 24			jp macro_next 
292f				endm 
# End of macro NEXTW
292f			.DUP2: 
292f			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
292f 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2930 74 29			dw .DROP2            
2932 05				db 4 + 1 
2933 .. 00			db "2DUP",0              
2938				endm 
# End of macro CWHEAD
2938			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2938				if DEBUG_FORTH_WORDS_KEY 
2938					DMARK "2DU" 
2938 f5				push af  
2939 3a 4d 29			ld a, (.dmark)  
293c 32 68 fe			ld (debug_mark),a  
293f 3a 4e 29			ld a, (.dmark+1)  
2942 32 69 fe			ld (debug_mark+1),a  
2945 3a 4f 29			ld a, (.dmark+2)  
2948 32 6a fe			ld (debug_mark+2),a  
294b 18 03			jr .pastdmark  
294d ..			.dmark: db "2DU"  
2950 f1			.pastdmark: pop af  
2951			endm  
# End of macro DMARK
2951					CALLMONITOR 
2951 cd 6c fe			call debug_vector  
2954				endm  
# End of macro CALLMONITOR
2954				endif 
2954				FORTH_DSP_VALUEHL 
2954 cd f2 22			call macro_dsp_valuehl 
2957				endm 
# End of macro FORTH_DSP_VALUEHL
2957 e5				push hl      ; 2 
2958			 
2958				FORTH_DSP_POP 
2958 cd aa 23			call macro_forth_dsp_pop 
295b				endm 
# End of macro FORTH_DSP_POP
295b				 
295b				FORTH_DSP_VALUEHL 
295b cd f2 22			call macro_dsp_valuehl 
295e				endm 
# End of macro FORTH_DSP_VALUEHL
295e			;		push hl      ; 1 
295e			 
295e				FORTH_DSP_POP 
295e cd aa 23			call macro_forth_dsp_pop 
2961				endm 
# End of macro FORTH_DSP_POP
2961			 
2961			;		pop hl       ; 1 
2961 d1				pop de       ; 2 
2962			 
2962 cd fb 20			call forth_push_numhl 
2965 eb				ex de, hl 
2966 cd fb 20			call forth_push_numhl 
2969			 
2969				 
2969 eb				ex de, hl 
296a			 
296a cd fb 20			call forth_push_numhl 
296d eb				ex de, hl 
296e cd fb 20			call forth_push_numhl 
2971			 
2971			 
2971				NEXTW 
2971 c3 a8 24			jp macro_next 
2974				endm 
# End of macro NEXTW
2974			.DROP2: 
2974			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2974 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2975 a3 29			dw .SWAP2            
2977 06				db 5 + 1 
2978 .. 00			db "2DROP",0              
297e				endm 
# End of macro CWHEAD
297e			; | 2DROP ( w w -- )    Double drop | DONE 
297e				if DEBUG_FORTH_WORDS_KEY 
297e					DMARK "2DR" 
297e f5				push af  
297f 3a 93 29			ld a, (.dmark)  
2982 32 68 fe			ld (debug_mark),a  
2985 3a 94 29			ld a, (.dmark+1)  
2988 32 69 fe			ld (debug_mark+1),a  
298b 3a 95 29			ld a, (.dmark+2)  
298e 32 6a fe			ld (debug_mark+2),a  
2991 18 03			jr .pastdmark  
2993 ..			.dmark: db "2DR"  
2996 f1			.pastdmark: pop af  
2997			endm  
# End of macro DMARK
2997					CALLMONITOR 
2997 cd 6c fe			call debug_vector  
299a				endm  
# End of macro CALLMONITOR
299a				endif 
299a				FORTH_DSP_POP 
299a cd aa 23			call macro_forth_dsp_pop 
299d				endm 
# End of macro FORTH_DSP_POP
299d				FORTH_DSP_POP 
299d cd aa 23			call macro_forth_dsp_pop 
29a0				endm 
# End of macro FORTH_DSP_POP
29a0				NEXTW 
29a0 c3 a8 24			jp macro_next 
29a3				endm 
# End of macro NEXTW
29a3			.SWAP2: 
29a3			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
29a3 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
29a4 cc 29			dw .AT            
29a6 06				db 5 + 1 
29a7 .. 00			db "2SWAP",0              
29ad				endm 
# End of macro CWHEAD
29ad			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
29ad				if DEBUG_FORTH_WORDS_KEY 
29ad					DMARK "2SW" 
29ad f5				push af  
29ae 3a c2 29			ld a, (.dmark)  
29b1 32 68 fe			ld (debug_mark),a  
29b4 3a c3 29			ld a, (.dmark+1)  
29b7 32 69 fe			ld (debug_mark+1),a  
29ba 3a c4 29			ld a, (.dmark+2)  
29bd 32 6a fe			ld (debug_mark+2),a  
29c0 18 03			jr .pastdmark  
29c2 ..			.dmark: db "2SW"  
29c5 f1			.pastdmark: pop af  
29c6			endm  
# End of macro DMARK
29c6					CALLMONITOR 
29c6 cd 6c fe			call debug_vector  
29c9				endm  
# End of macro CALLMONITOR
29c9				endif 
29c9			; TODO Use os stack swap memory 
29c9				NEXTW 
29c9 c3 a8 24			jp macro_next 
29cc				endm 
# End of macro NEXTW
29cc			.AT: 
29cc			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
29cc 1f				db WORD_SYS_CORE+OPCODE_AT             
29cd fe 29			dw .CAT            
29cf 02				db 1 + 1 
29d0 .. 00			db "@",0              
29d2				endm 
# End of macro CWHEAD
29d2			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
29d2			 
29d2				if DEBUG_FORTH_WORDS_KEY 
29d2					DMARK "AT." 
29d2 f5				push af  
29d3 3a e7 29			ld a, (.dmark)  
29d6 32 68 fe			ld (debug_mark),a  
29d9 3a e8 29			ld a, (.dmark+1)  
29dc 32 69 fe			ld (debug_mark+1),a  
29df 3a e9 29			ld a, (.dmark+2)  
29e2 32 6a fe			ld (debug_mark+2),a  
29e5 18 03			jr .pastdmark  
29e7 ..			.dmark: db "AT."  
29ea f1			.pastdmark: pop af  
29eb			endm  
# End of macro DMARK
29eb					CALLMONITOR 
29eb cd 6c fe			call debug_vector  
29ee				endm  
# End of macro CALLMONITOR
29ee				endif 
29ee			.getbyteat:	 
29ee				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29ee cd f2 22			call macro_dsp_valuehl 
29f1				endm 
# End of macro FORTH_DSP_VALUEHL
29f1				 
29f1			;		push hl 
29f1			 
29f1				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29f1 cd aa 23			call macro_forth_dsp_pop 
29f4				endm 
# End of macro FORTH_DSP_POP
29f4			 
29f4			;		pop hl 
29f4			 
29f4 7e				ld a, (hl) 
29f5			 
29f5 6f				ld l, a 
29f6 26 00			ld h, 0 
29f8 cd fb 20			call forth_push_numhl 
29fb			 
29fb				NEXTW 
29fb c3 a8 24			jp macro_next 
29fe				endm 
# End of macro NEXTW
29fe			.CAT: 
29fe			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
29fe 20				db WORD_SYS_CORE+OPCODE_CAT             
29ff 27 2a			dw .BANG            
2a01 03				db 2 + 1 
2a02 .. 00			db "C@",0              
2a05				endm 
# End of macro CWHEAD
2a05			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2a05				if DEBUG_FORTH_WORDS_KEY 
2a05					DMARK "CAA" 
2a05 f5				push af  
2a06 3a 1a 2a			ld a, (.dmark)  
2a09 32 68 fe			ld (debug_mark),a  
2a0c 3a 1b 2a			ld a, (.dmark+1)  
2a0f 32 69 fe			ld (debug_mark+1),a  
2a12 3a 1c 2a			ld a, (.dmark+2)  
2a15 32 6a fe			ld (debug_mark+2),a  
2a18 18 03			jr .pastdmark  
2a1a ..			.dmark: db "CAA"  
2a1d f1			.pastdmark: pop af  
2a1e			endm  
# End of macro DMARK
2a1e					CALLMONITOR 
2a1e cd 6c fe			call debug_vector  
2a21				endm  
# End of macro CALLMONITOR
2a21				endif 
2a21 c3 ee 29			jp .getbyteat 
2a24				NEXTW 
2a24 c3 a8 24			jp macro_next 
2a27				endm 
# End of macro NEXTW
2a27			.BANG: 
2a27			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2a27 21				db WORD_SYS_CORE+OPCODE_BANG             
2a28 5d 2a			dw .CBANG            
2a2a 02				db 1 + 1 
2a2b .. 00			db "!",0              
2a2d				endm 
# End of macro CWHEAD
2a2d			; | ! ( x w -- ) Store x at address w      | DONE 
2a2d				if DEBUG_FORTH_WORDS_KEY 
2a2d					DMARK "BNG" 
2a2d f5				push af  
2a2e 3a 42 2a			ld a, (.dmark)  
2a31 32 68 fe			ld (debug_mark),a  
2a34 3a 43 2a			ld a, (.dmark+1)  
2a37 32 69 fe			ld (debug_mark+1),a  
2a3a 3a 44 2a			ld a, (.dmark+2)  
2a3d 32 6a fe			ld (debug_mark+2),a  
2a40 18 03			jr .pastdmark  
2a42 ..			.dmark: db "BNG"  
2a45 f1			.pastdmark: pop af  
2a46			endm  
# End of macro DMARK
2a46					CALLMONITOR 
2a46 cd 6c fe			call debug_vector  
2a49				endm  
# End of macro CALLMONITOR
2a49				endif 
2a49			 
2a49			.storebyteat:		 
2a49				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a49 cd f2 22			call macro_dsp_valuehl 
2a4c				endm 
# End of macro FORTH_DSP_VALUEHL
2a4c				 
2a4c e5				push hl 
2a4d			 
2a4d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a4d cd aa 23			call macro_forth_dsp_pop 
2a50				endm 
# End of macro FORTH_DSP_POP
2a50			 
2a50				; get byte to poke 
2a50			 
2a50				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a50 cd f2 22			call macro_dsp_valuehl 
2a53				endm 
# End of macro FORTH_DSP_VALUEHL
2a53 e5				push hl 
2a54			 
2a54			 
2a54				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a54 cd aa 23			call macro_forth_dsp_pop 
2a57				endm 
# End of macro FORTH_DSP_POP
2a57			 
2a57			 
2a57 d1				pop de 
2a58 e1				pop hl 
2a59			 
2a59 73				ld (hl),e 
2a5a			 
2a5a			 
2a5a				NEXTW 
2a5a c3 a8 24			jp macro_next 
2a5d				endm 
# End of macro NEXTW
2a5d			.CBANG: 
2a5d			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a5d 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a5e 86 2a			dw .SCALL            
2a60 03				db 2 + 1 
2a61 .. 00			db "C!",0              
2a64				endm 
# End of macro CWHEAD
2a64			; | C!  ( x w -- ) Store x at address w  | DONE 
2a64				if DEBUG_FORTH_WORDS_KEY 
2a64					DMARK "CBA" 
2a64 f5				push af  
2a65 3a 79 2a			ld a, (.dmark)  
2a68 32 68 fe			ld (debug_mark),a  
2a6b 3a 7a 2a			ld a, (.dmark+1)  
2a6e 32 69 fe			ld (debug_mark+1),a  
2a71 3a 7b 2a			ld a, (.dmark+2)  
2a74 32 6a fe			ld (debug_mark+2),a  
2a77 18 03			jr .pastdmark  
2a79 ..			.dmark: db "CBA"  
2a7c f1			.pastdmark: pop af  
2a7d			endm  
# End of macro DMARK
2a7d					CALLMONITOR 
2a7d cd 6c fe			call debug_vector  
2a80				endm  
# End of macro CALLMONITOR
2a80				endif 
2a80 c3 49 2a			jp .storebyteat 
2a83				NEXTW 
2a83 c3 a8 24			jp macro_next 
2a86				endm 
# End of macro NEXTW
2a86			.SCALL: 
2a86			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a86 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a87 ba 2a			dw .DEPTH            
2a89 05				db 4 + 1 
2a8a .. 00			db "CALL",0              
2a8f				endm 
# End of macro CWHEAD
2a8f			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a8f				if DEBUG_FORTH_WORDS_KEY 
2a8f					DMARK "CLL" 
2a8f f5				push af  
2a90 3a a4 2a			ld a, (.dmark)  
2a93 32 68 fe			ld (debug_mark),a  
2a96 3a a5 2a			ld a, (.dmark+1)  
2a99 32 69 fe			ld (debug_mark+1),a  
2a9c 3a a6 2a			ld a, (.dmark+2)  
2a9f 32 6a fe			ld (debug_mark+2),a  
2aa2 18 03			jr .pastdmark  
2aa4 ..			.dmark: db "CLL"  
2aa7 f1			.pastdmark: pop af  
2aa8			endm  
# End of macro DMARK
2aa8					CALLMONITOR 
2aa8 cd 6c fe			call debug_vector  
2aab				endm  
# End of macro CALLMONITOR
2aab				endif 
2aab			 
2aab				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2aab cd f2 22			call macro_dsp_valuehl 
2aae				endm 
# End of macro FORTH_DSP_VALUEHL
2aae			 
2aae			;		push hl 
2aae			 
2aae				; destroy value TOS 
2aae			 
2aae				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2aae cd aa 23			call macro_forth_dsp_pop 
2ab1				endm 
# End of macro FORTH_DSP_POP
2ab1			 
2ab1					 
2ab1			;		pop hl 
2ab1			 
2ab1				; how to do a call with hl???? save SP? 
2ab1 cd 4c 24			call forth_call_hl 
2ab4			 
2ab4			 
2ab4				; TODO push value back onto stack for another op etc 
2ab4			 
2ab4 cd fb 20			call forth_push_numhl 
2ab7				NEXTW 
2ab7 c3 a8 24			jp macro_next 
2aba				endm 
# End of macro NEXTW
2aba			.DEPTH: 
2aba			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2aba 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2abb f7 2a			dw .OVER            
2abd 06				db 5 + 1 
2abe .. 00			db "DEPTH",0              
2ac4				endm 
# End of macro CWHEAD
2ac4			; | DEPTH ( -- u ) Push count of stack | DONE 
2ac4				; take current TOS and remove from base value div by two to get count 
2ac4				if DEBUG_FORTH_WORDS_KEY 
2ac4					DMARK "DEP" 
2ac4 f5				push af  
2ac5 3a d9 2a			ld a, (.dmark)  
2ac8 32 68 fe			ld (debug_mark),a  
2acb 3a da 2a			ld a, (.dmark+1)  
2ace 32 69 fe			ld (debug_mark+1),a  
2ad1 3a db 2a			ld a, (.dmark+2)  
2ad4 32 6a fe			ld (debug_mark+2),a  
2ad7 18 03			jr .pastdmark  
2ad9 ..			.dmark: db "DEP"  
2adc f1			.pastdmark: pop af  
2add			endm  
# End of macro DMARK
2add					CALLMONITOR 
2add cd 6c fe			call debug_vector  
2ae0				endm  
# End of macro CALLMONITOR
2ae0				endif 
2ae0			 
2ae0			 
2ae0 2a eb f9		ld hl, (cli_data_sp) 
2ae3 11 25 f7		ld de, cli_data_stack 
2ae6 ed 52		sbc hl,de 
2ae8			 
2ae8			; div by size of stack item 
2ae8			 
2ae8 5d			ld e,l 
2ae9 0e 03		ld c, 3 
2aeb cd 5f 0f		call Div8 
2aee			 
2aee 6f			ld l,a 
2aef 26 00		ld h,0 
2af1			 
2af1			;srl h 
2af1			;rr l 
2af1			 
2af1 cd fb 20			call forth_push_numhl 
2af4				NEXTW 
2af4 c3 a8 24			jp macro_next 
2af7				endm 
# End of macro NEXTW
2af7			.OVER: 
2af7			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2af7 42				db WORD_SYS_CORE+46             
2af8 3e 2b			dw .PAUSE            
2afa 05				db 4 + 1 
2afb .. 00			db "OVER",0              
2b00				endm 
# End of macro CWHEAD
2b00			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2b00				if DEBUG_FORTH_WORDS_KEY 
2b00					DMARK "OVR" 
2b00 f5				push af  
2b01 3a 15 2b			ld a, (.dmark)  
2b04 32 68 fe			ld (debug_mark),a  
2b07 3a 16 2b			ld a, (.dmark+1)  
2b0a 32 69 fe			ld (debug_mark+1),a  
2b0d 3a 17 2b			ld a, (.dmark+2)  
2b10 32 6a fe			ld (debug_mark+2),a  
2b13 18 03			jr .pastdmark  
2b15 ..			.dmark: db "OVR"  
2b18 f1			.pastdmark: pop af  
2b19			endm  
# End of macro DMARK
2b19					CALLMONITOR 
2b19 cd 6c fe			call debug_vector  
2b1c				endm  
# End of macro CALLMONITOR
2b1c				endif 
2b1c			 
2b1c			; TODO Use os stack swap memory 
2b1c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b1c cd f2 22			call macro_dsp_valuehl 
2b1f				endm 
# End of macro FORTH_DSP_VALUEHL
2b1f e5				push hl    ; n2 
2b20				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b20 cd aa 23			call macro_forth_dsp_pop 
2b23				endm 
# End of macro FORTH_DSP_POP
2b23			 
2b23				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b23 cd f2 22			call macro_dsp_valuehl 
2b26				endm 
# End of macro FORTH_DSP_VALUEHL
2b26 e5				push hl    ; n1 
2b27				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b27 cd aa 23			call macro_forth_dsp_pop 
2b2a				endm 
# End of macro FORTH_DSP_POP
2b2a			 
2b2a d1				pop de     ; n1 
2b2b e1				pop hl     ; n2 
2b2c			 
2b2c d5				push de 
2b2d e5				push hl 
2b2e d5				push de 
2b2f			 
2b2f				; push back  
2b2f			 
2b2f e1				pop hl 
2b30 cd fb 20			call forth_push_numhl 
2b33 e1				pop hl 
2b34 cd fb 20			call forth_push_numhl 
2b37 e1				pop hl 
2b38 cd fb 20			call forth_push_numhl 
2b3b				NEXTW 
2b3b c3 a8 24			jp macro_next 
2b3e				endm 
# End of macro NEXTW
2b3e			 
2b3e			.PAUSE: 
2b3e			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b3e 43				db WORD_SYS_CORE+47             
2b3f 73 2b			dw .PAUSES            
2b41 08				db 7 + 1 
2b42 .. 00			db "PAUSEMS",0              
2b4a				endm 
# End of macro CWHEAD
2b4a			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b4a				if DEBUG_FORTH_WORDS_KEY 
2b4a					DMARK "PMS" 
2b4a f5				push af  
2b4b 3a 5f 2b			ld a, (.dmark)  
2b4e 32 68 fe			ld (debug_mark),a  
2b51 3a 60 2b			ld a, (.dmark+1)  
2b54 32 69 fe			ld (debug_mark+1),a  
2b57 3a 61 2b			ld a, (.dmark+2)  
2b5a 32 6a fe			ld (debug_mark+2),a  
2b5d 18 03			jr .pastdmark  
2b5f ..			.dmark: db "PMS"  
2b62 f1			.pastdmark: pop af  
2b63			endm  
# End of macro DMARK
2b63					CALLMONITOR 
2b63 cd 6c fe			call debug_vector  
2b66				endm  
# End of macro CALLMONITOR
2b66				endif 
2b66				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b66 cd f2 22			call macro_dsp_valuehl 
2b69				endm 
# End of macro FORTH_DSP_VALUEHL
2b69			;		push hl    ; n2 
2b69				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b69 cd aa 23			call macro_forth_dsp_pop 
2b6c				endm 
# End of macro FORTH_DSP_POP
2b6c			;		pop hl 
2b6c			 
2b6c 7d				ld a, l 
2b6d cd c3 0c			call aDelayInMS 
2b70			       NEXTW 
2b70 c3 a8 24			jp macro_next 
2b73				endm 
# End of macro NEXTW
2b73			.PAUSES:  
2b73			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b73 44				db WORD_SYS_CORE+48             
2b74 e2 2b			dw .ROT            
2b76 06				db 5 + 1 
2b77 .. 00			db "PAUSE",0              
2b7d				endm 
# End of macro CWHEAD
2b7d			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b7d				if DEBUG_FORTH_WORDS_KEY 
2b7d					DMARK "PAU" 
2b7d f5				push af  
2b7e 3a 92 2b			ld a, (.dmark)  
2b81 32 68 fe			ld (debug_mark),a  
2b84 3a 93 2b			ld a, (.dmark+1)  
2b87 32 69 fe			ld (debug_mark+1),a  
2b8a 3a 94 2b			ld a, (.dmark+2)  
2b8d 32 6a fe			ld (debug_mark+2),a  
2b90 18 03			jr .pastdmark  
2b92 ..			.dmark: db "PAU"  
2b95 f1			.pastdmark: pop af  
2b96			endm  
# End of macro DMARK
2b96					CALLMONITOR 
2b96 cd 6c fe			call debug_vector  
2b99				endm  
# End of macro CALLMONITOR
2b99				endif 
2b99				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b99 cd f2 22			call macro_dsp_valuehl 
2b9c				endm 
# End of macro FORTH_DSP_VALUEHL
2b9c			;		push hl    ; n2 
2b9c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b9c cd aa 23			call macro_forth_dsp_pop 
2b9f				endm 
# End of macro FORTH_DSP_POP
2b9f			;		pop hl 
2b9f 45				ld b, l 
2ba0				if DEBUG_FORTH_WORDS 
2ba0					DMARK "PAU" 
2ba0 f5				push af  
2ba1 3a b5 2b			ld a, (.dmark)  
2ba4 32 68 fe			ld (debug_mark),a  
2ba7 3a b6 2b			ld a, (.dmark+1)  
2baa 32 69 fe			ld (debug_mark+1),a  
2bad 3a b7 2b			ld a, (.dmark+2)  
2bb0 32 6a fe			ld (debug_mark+2),a  
2bb3 18 03			jr .pastdmark  
2bb5 ..			.dmark: db "PAU"  
2bb8 f1			.pastdmark: pop af  
2bb9			endm  
# End of macro DMARK
2bb9					CALLMONITOR 
2bb9 cd 6c fe			call debug_vector  
2bbc				endm  
# End of macro CALLMONITOR
2bbc				endif 
2bbc c5			.pauses1:	push bc 
2bbd cd de 0c			call delay1s 
2bc0 c1				pop bc 
2bc1				if DEBUG_FORTH_WORDS 
2bc1					DMARK "PA1" 
2bc1 f5				push af  
2bc2 3a d6 2b			ld a, (.dmark)  
2bc5 32 68 fe			ld (debug_mark),a  
2bc8 3a d7 2b			ld a, (.dmark+1)  
2bcb 32 69 fe			ld (debug_mark+1),a  
2bce 3a d8 2b			ld a, (.dmark+2)  
2bd1 32 6a fe			ld (debug_mark+2),a  
2bd4 18 03			jr .pastdmark  
2bd6 ..			.dmark: db "PA1"  
2bd9 f1			.pastdmark: pop af  
2bda			endm  
# End of macro DMARK
2bda					CALLMONITOR 
2bda cd 6c fe			call debug_vector  
2bdd				endm  
# End of macro CALLMONITOR
2bdd				endif 
2bdd 10 dd			djnz .pauses1 
2bdf			 
2bdf			       NEXTW 
2bdf c3 a8 24			jp macro_next 
2be2				endm 
# End of macro NEXTW
2be2			.ROT: 
2be2			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2be2 45				db WORD_SYS_CORE+49             
2be3 30 2c			dw .UWORDS            
2be5 04				db 3 + 1 
2be6 .. 00			db "ROT",0              
2bea				endm 
# End of macro CWHEAD
2bea			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2bea				if DEBUG_FORTH_WORDS_KEY 
2bea					DMARK "ROT" 
2bea f5				push af  
2beb 3a ff 2b			ld a, (.dmark)  
2bee 32 68 fe			ld (debug_mark),a  
2bf1 3a 00 2c			ld a, (.dmark+1)  
2bf4 32 69 fe			ld (debug_mark+1),a  
2bf7 3a 01 2c			ld a, (.dmark+2)  
2bfa 32 6a fe			ld (debug_mark+2),a  
2bfd 18 03			jr .pastdmark  
2bff ..			.dmark: db "ROT"  
2c02 f1			.pastdmark: pop af  
2c03			endm  
# End of macro DMARK
2c03					CALLMONITOR 
2c03 cd 6c fe			call debug_vector  
2c06				endm  
# End of macro CALLMONITOR
2c06				endif 
2c06			 
2c06			; TODO Use os stack swap memory 
2c06				FORTH_DSP_VALUEHL 
2c06 cd f2 22			call macro_dsp_valuehl 
2c09				endm 
# End of macro FORTH_DSP_VALUEHL
2c09 e5				push hl    ; u3  
2c0a			 
2c0a				FORTH_DSP_POP 
2c0a cd aa 23			call macro_forth_dsp_pop 
2c0d				endm 
# End of macro FORTH_DSP_POP
2c0d			 
2c0d				FORTH_DSP_VALUEHL 
2c0d cd f2 22			call macro_dsp_valuehl 
2c10				endm 
# End of macro FORTH_DSP_VALUEHL
2c10 e5				push hl     ; u2 
2c11			 
2c11				FORTH_DSP_POP 
2c11 cd aa 23			call macro_forth_dsp_pop 
2c14				endm 
# End of macro FORTH_DSP_POP
2c14			 
2c14				FORTH_DSP_VALUEHL 
2c14 cd f2 22			call macro_dsp_valuehl 
2c17				endm 
# End of macro FORTH_DSP_VALUEHL
2c17 e5				push hl     ; u1 
2c18			 
2c18				FORTH_DSP_POP 
2c18 cd aa 23			call macro_forth_dsp_pop 
2c1b				endm 
# End of macro FORTH_DSP_POP
2c1b			 
2c1b c1				pop bc      ; u1 
2c1c e1				pop hl      ; u2 
2c1d d1				pop de      ; u3 
2c1e			 
2c1e			 
2c1e c5				push bc 
2c1f d5				push de 
2c20 e5				push hl 
2c21			 
2c21			 
2c21 e1				pop hl 
2c22 cd fb 20			call forth_push_numhl 
2c25			 
2c25 e1				pop hl 
2c26 cd fb 20			call forth_push_numhl 
2c29			 
2c29 e1				pop hl 
2c2a cd fb 20			call forth_push_numhl 
2c2d				 
2c2d			 
2c2d			 
2c2d			 
2c2d			 
2c2d			 
2c2d			       NEXTW 
2c2d c3 a8 24			jp macro_next 
2c30				endm 
# End of macro NEXTW
2c30			 
2c30			.UWORDS: 
2c30			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2c30 50				db WORD_SYS_CORE+60             
2c31 f2 2c			dw .BP            
2c33 07				db 6 + 1 
2c34 .. 00			db "UWORDS",0              
2c3b				endm 
# End of macro CWHEAD
2c3b			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c3b			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c3b			; | | Following the count are the individual words. 
2c3b			; | | 
2c3b			; | | e.g. UWORDS 
2c3b			; | | BOX DIRLIST 2 
2c3b			; | |  
2c3b			; | | Can be used to save the words to storage via: 
2c3b			; | | UWORDS $01 DO $01 APPEND LOOP 
2c3b			if DEBUG_FORTH_WORDS_KEY 
2c3b				DMARK "UWR" 
2c3b f5				push af  
2c3c 3a 50 2c			ld a, (.dmark)  
2c3f 32 68 fe			ld (debug_mark),a  
2c42 3a 51 2c			ld a, (.dmark+1)  
2c45 32 69 fe			ld (debug_mark+1),a  
2c48 3a 52 2c			ld a, (.dmark+2)  
2c4b 32 6a fe			ld (debug_mark+2),a  
2c4e 18 03			jr .pastdmark  
2c50 ..			.dmark: db "UWR"  
2c53 f1			.pastdmark: pop af  
2c54			endm  
# End of macro DMARK
2c54				CALLMONITOR 
2c54 cd 6c fe			call debug_vector  
2c57				endm  
# End of macro CALLMONITOR
2c57			endif 
2c57 21 00 80			ld hl, baseram 
2c5a				;ld hl, baseusermem 
2c5a 01 00 00			ld bc, 0    ; start a counter 
2c5d			 
2c5d			; skip dict stub 
2c5d			 
2c5d cd f9 25			call forth_tok_next 
2c60			 
2c60			 
2c60			; while we have words to look for 
2c60			 
2c60 7e			.douscan:	ld a, (hl)      
2c61			if DEBUG_FORTH_WORDS 
2c61				DMARK "UWs" 
2c61 f5				push af  
2c62 3a 76 2c			ld a, (.dmark)  
2c65 32 68 fe			ld (debug_mark),a  
2c68 3a 77 2c			ld a, (.dmark+1)  
2c6b 32 69 fe			ld (debug_mark+1),a  
2c6e 3a 78 2c			ld a, (.dmark+2)  
2c71 32 6a fe			ld (debug_mark+2),a  
2c74 18 03			jr .pastdmark  
2c76 ..			.dmark: db "UWs"  
2c79 f1			.pastdmark: pop af  
2c7a			endm  
# End of macro DMARK
2c7a				CALLMONITOR 
2c7a cd 6c fe			call debug_vector  
2c7d				endm  
# End of macro CALLMONITOR
2c7d			endif 
2c7d fe 00			cp WORD_SYS_END 
2c7f 28 4d			jr z, .udone 
2c81 fe 01			cp WORD_SYS_UWORD 
2c83 20 44			jr nz, .nuword 
2c85			 
2c85			if DEBUG_FORTH_WORDS 
2c85				DMARK "UWu" 
2c85 f5				push af  
2c86 3a 9a 2c			ld a, (.dmark)  
2c89 32 68 fe			ld (debug_mark),a  
2c8c 3a 9b 2c			ld a, (.dmark+1)  
2c8f 32 69 fe			ld (debug_mark+1),a  
2c92 3a 9c 2c			ld a, (.dmark+2)  
2c95 32 6a fe			ld (debug_mark+2),a  
2c98 18 03			jr .pastdmark  
2c9a ..			.dmark: db "UWu"  
2c9d f1			.pastdmark: pop af  
2c9e			endm  
# End of macro DMARK
2c9e				CALLMONITOR 
2c9e cd 6c fe			call debug_vector  
2ca1				endm  
# End of macro CALLMONITOR
2ca1			endif 
2ca1				; we have a uword so push its name to the stack 
2ca1			 
2ca1 e5				push hl  ; save so we can move to next dict block 
2ca2			 
2ca2				; skip opcode 
2ca2 23				inc hl  
2ca3				; skip next ptr 
2ca3 23				inc hl  
2ca4 23				inc hl 
2ca5				; skip len 
2ca5 23				inc hl 
2ca6			if DEBUG_FORTH_WORDS 
2ca6				DMARK "UWt" 
2ca6 f5				push af  
2ca7 3a bb 2c			ld a, (.dmark)  
2caa 32 68 fe			ld (debug_mark),a  
2cad 3a bc 2c			ld a, (.dmark+1)  
2cb0 32 69 fe			ld (debug_mark+1),a  
2cb3 3a bd 2c			ld a, (.dmark+2)  
2cb6 32 6a fe			ld (debug_mark+2),a  
2cb9 18 03			jr .pastdmark  
2cbb ..			.dmark: db "UWt"  
2cbe f1			.pastdmark: pop af  
2cbf			endm  
# End of macro DMARK
2cbf				CALLMONITOR 
2cbf cd 6c fe			call debug_vector  
2cc2				endm  
# End of macro CALLMONITOR
2cc2			endif 
2cc2 03				inc bc 
2cc3			 
2cc3 c5				push bc 
2cc4 cd 69 21			call forth_push_str 
2cc7 c1				pop bc 
2cc8			 
2cc8 e1				pop hl 	 
2cc9			 
2cc9 cd f9 25		.nuword:	call forth_tok_next 
2ccc 18 92			jr .douscan  
2cce			 
2cce			.udone:		 ; push count of uwords found 
2cce c5				push bc 
2ccf e1				pop hl 
2cd0			 
2cd0			if DEBUG_FORTH_WORDS 
2cd0				DMARK "UWc" 
2cd0 f5				push af  
2cd1 3a e5 2c			ld a, (.dmark)  
2cd4 32 68 fe			ld (debug_mark),a  
2cd7 3a e6 2c			ld a, (.dmark+1)  
2cda 32 69 fe			ld (debug_mark+1),a  
2cdd 3a e7 2c			ld a, (.dmark+2)  
2ce0 32 6a fe			ld (debug_mark+2),a  
2ce3 18 03			jr .pastdmark  
2ce5 ..			.dmark: db "UWc"  
2ce8 f1			.pastdmark: pop af  
2ce9			endm  
# End of macro DMARK
2ce9				CALLMONITOR 
2ce9 cd 6c fe			call debug_vector  
2cec				endm  
# End of macro CALLMONITOR
2cec			endif 
2cec cd fb 20			call forth_push_numhl 
2cef			 
2cef			 
2cef			       NEXTW 
2cef c3 a8 24			jp macro_next 
2cf2				endm 
# End of macro NEXTW
2cf2			 
2cf2			.BP: 
2cf2			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2cf2 54				db WORD_SYS_CORE+64             
2cf3 2c 2d			dw .MONITOR            
2cf5 03				db 2 + 1 
2cf6 .. 00			db "BP",0              
2cf9				endm 
# End of macro CWHEAD
2cf9			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2cf9			; | | $00 Will enable the break points within specific code paths 
2cf9			; | | $01 Will disable break points 
2cf9			; | |  
2cf9			; | | By default break points are off. Either the above can be used to enable them 
2cf9			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2cf9			; | | and on release of the pressed key a message will be disaplayed to notify 
2cf9			; | | that break points are enabled. Pressing any key will then continue boot process. 
2cf9				; get byte count 
2cf9				if DEBUG_FORTH_WORDS_KEY 
2cf9					DMARK "BP." 
2cf9 f5				push af  
2cfa 3a 0e 2d			ld a, (.dmark)  
2cfd 32 68 fe			ld (debug_mark),a  
2d00 3a 0f 2d			ld a, (.dmark+1)  
2d03 32 69 fe			ld (debug_mark+1),a  
2d06 3a 10 2d			ld a, (.dmark+2)  
2d09 32 6a fe			ld (debug_mark+2),a  
2d0c 18 03			jr .pastdmark  
2d0e ..			.dmark: db "BP."  
2d11 f1			.pastdmark: pop af  
2d12			endm  
# End of macro DMARK
2d12					CALLMONITOR 
2d12 cd 6c fe			call debug_vector  
2d15				endm  
# End of macro CALLMONITOR
2d15				endif 
2d15			 
2d15				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d15 cd f2 22			call macro_dsp_valuehl 
2d18				endm 
# End of macro FORTH_DSP_VALUEHL
2d18			 
2d18			;		push hl 
2d18			 
2d18				; destroy value TOS 
2d18			 
2d18				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d18 cd aa 23			call macro_forth_dsp_pop 
2d1b				endm 
# End of macro FORTH_DSP_POP
2d1b			 
2d1b			;		pop hl 
2d1b			 
2d1b 3e 00			ld a,0 
2d1d bd				cp l 
2d1e 28 06			jr z, .bpset 
2d20			;		ld a, '*' 
2d20 cd 39 1a			call bp_off 
2d23				NEXTW 
2d23 c3 a8 24			jp macro_next 
2d26				endm 
# End of macro NEXTW
2d26			 
2d26			.bpset:	 
2d26				;	ld (os_view_disable), a 
2d26 cd 2d 1a			call bp_on 
2d29			 
2d29			 
2d29				NEXTW 
2d29 c3 a8 24			jp macro_next 
2d2c				endm 
# End of macro NEXTW
2d2c			 
2d2c			 
2d2c			.MONITOR: 
2d2c			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2d2c 55				db WORD_SYS_CORE+65             
2d2d 5d 2d			dw .MALLOC            
2d2f 08				db 7 + 1 
2d30 .. 00			db "MONITOR",0              
2d38				endm 
# End of macro CWHEAD
2d38			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2d38			; | | At start the current various registers will be displayed with contents. 
2d38			; | | Top right corner will show the most recent debug marker seen. 
2d38			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2d38			; | | and the return stack pointer (RSP). 
2d38			; | | Pressing: 
2d38			; | |    1 - Initial screen 
2d38			; | |    2 - Display a data dump of HL 
2d38			; | |    3 - Display a data dump of DE 
2d38			; | |    4 - Display a data dump of BC 
2d38			; | |    5 - Display a data dump of HL 
2d38			; | |    6 - Display a data dump of DSP 
2d38			; | |    7 - Display a data dump of RSP 
2d38			; | |    8 - Display a data dump of what is at DSP 
2d38			; | |    9 - Display a data dump of what is at RSP 
2d38			; | |    0 - Exit monitor and continue running. This will also enable break points 
2d38			; | |    * - Disable break points 
2d38			; | |    # - Enter traditional monitor mode 
2d38			; | | 
2d38			; | | Monitor Mode 
2d38			; | | ------------ 
2d38			; | | A prompt of '>' will be shown for various commands: 
2d38			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2d38			; | |    C - Continue display a data dump from the last set address 
2d38			; | |    M xxxx - Set start of memory edit at address xx 
2d38			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2d38			; | |    Q - Return to previous 
2d38				if DEBUG_FORTH_WORDS_KEY 
2d38					DMARK "MON" 
2d38 f5				push af  
2d39 3a 4d 2d			ld a, (.dmark)  
2d3c 32 68 fe			ld (debug_mark),a  
2d3f 3a 4e 2d			ld a, (.dmark+1)  
2d42 32 69 fe			ld (debug_mark+1),a  
2d45 3a 4f 2d			ld a, (.dmark+2)  
2d48 32 6a fe			ld (debug_mark+2),a  
2d4b 18 03			jr .pastdmark  
2d4d ..			.dmark: db "MON"  
2d50 f1			.pastdmark: pop af  
2d51			endm  
# End of macro DMARK
2d51					CALLMONITOR 
2d51 cd 6c fe			call debug_vector  
2d54				endm  
# End of macro CALLMONITOR
2d54				endif 
2d54			;		ld a, 0 
2d54			;		ld (os_view_disable), a 
2d54 cd 2d 1a			call bp_on 
2d57			 
2d57				CALLMONITOR 
2d57 cd 6c fe			call debug_vector  
2d5a				endm  
# End of macro CALLMONITOR
2d5a			 
2d5a			;	call monitor 
2d5a			 
2d5a				NEXTW 
2d5a c3 a8 24			jp macro_next 
2d5d				endm 
# End of macro NEXTW
2d5d			 
2d5d			 
2d5d			.MALLOC: 
2d5d			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d5d 56				db WORD_SYS_CORE+66             
2d5e 86 2d			dw .MALLOC2            
2d60 06				db 5 + 1 
2d61 .. 00			db "ALLOT",0              
2d67				endm 
# End of macro CWHEAD
2d67			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d67				if DEBUG_FORTH_WORDS_KEY 
2d67					DMARK "ALL" 
2d67 f5				push af  
2d68 3a 7c 2d			ld a, (.dmark)  
2d6b 32 68 fe			ld (debug_mark),a  
2d6e 3a 7d 2d			ld a, (.dmark+1)  
2d71 32 69 fe			ld (debug_mark+1),a  
2d74 3a 7e 2d			ld a, (.dmark+2)  
2d77 32 6a fe			ld (debug_mark+2),a  
2d7a 18 03			jr .pastdmark  
2d7c ..			.dmark: db "ALL"  
2d7f f1			.pastdmark: pop af  
2d80			endm  
# End of macro DMARK
2d80					CALLMONITOR 
2d80 cd 6c fe			call debug_vector  
2d83				endm  
# End of macro CALLMONITOR
2d83				endif 
2d83 c3 ad 2d			jp .mallocc 
2d86			.MALLOC2: 
2d86			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d86 56				db WORD_SYS_CORE+66             
2d87 c4 2d			dw .FREE            
2d89 07				db 6 + 1 
2d8a .. 00			db "MALLOC",0              
2d91				endm 
# End of macro CWHEAD
2d91			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d91				; get byte count 
2d91				if DEBUG_FORTH_WORDS_KEY 
2d91					DMARK "MAL" 
2d91 f5				push af  
2d92 3a a6 2d			ld a, (.dmark)  
2d95 32 68 fe			ld (debug_mark),a  
2d98 3a a7 2d			ld a, (.dmark+1)  
2d9b 32 69 fe			ld (debug_mark+1),a  
2d9e 3a a8 2d			ld a, (.dmark+2)  
2da1 32 6a fe			ld (debug_mark+2),a  
2da4 18 03			jr .pastdmark  
2da6 ..			.dmark: db "MAL"  
2da9 f1			.pastdmark: pop af  
2daa			endm  
# End of macro DMARK
2daa					CALLMONITOR 
2daa cd 6c fe			call debug_vector  
2dad				endm  
# End of macro CALLMONITOR
2dad				endif 
2dad			.mallocc: 
2dad				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2dad cd f2 22			call macro_dsp_valuehl 
2db0				endm 
# End of macro FORTH_DSP_VALUEHL
2db0			 
2db0			;		push hl 
2db0			 
2db0				; destroy value TOS 
2db0			 
2db0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2db0 cd aa 23			call macro_forth_dsp_pop 
2db3				endm 
# End of macro FORTH_DSP_POP
2db3			 
2db3			;		pop hl 
2db3 cd 96 14			call malloc 
2db6			if DEBUG_FORTH_MALLOC_GUARD 
2db6 f5				push af 
2db7 cd f8 0f			call ishlzero 
2dba			;		ld a, l 
2dba			;		add h 
2dba			;		cp 0 
2dba f1				pop af 
2dbb				 
2dbb cc 3e 5e			call z,malloc_error 
2dbe			endif 
2dbe			 
2dbe cd fb 20			call forth_push_numhl 
2dc1				NEXTW 
2dc1 c3 a8 24			jp macro_next 
2dc4				endm 
# End of macro NEXTW
2dc4			 
2dc4			.FREE: 
2dc4			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2dc4 57				db WORD_SYS_CORE+67             
2dc5 f5 2d			dw .LIST            
2dc7 05				db 4 + 1 
2dc8 .. 00			db "FREE",0              
2dcd				endm 
# End of macro CWHEAD
2dcd			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2dcd				if DEBUG_FORTH_WORDS_KEY 
2dcd					DMARK "FRE" 
2dcd f5				push af  
2dce 3a e2 2d			ld a, (.dmark)  
2dd1 32 68 fe			ld (debug_mark),a  
2dd4 3a e3 2d			ld a, (.dmark+1)  
2dd7 32 69 fe			ld (debug_mark+1),a  
2dda 3a e4 2d			ld a, (.dmark+2)  
2ddd 32 6a fe			ld (debug_mark+2),a  
2de0 18 03			jr .pastdmark  
2de2 ..			.dmark: db "FRE"  
2de5 f1			.pastdmark: pop af  
2de6			endm  
# End of macro DMARK
2de6					CALLMONITOR 
2de6 cd 6c fe			call debug_vector  
2de9				endm  
# End of macro CALLMONITOR
2de9				endif 
2de9				; get address 
2de9			 
2de9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2de9 cd f2 22			call macro_dsp_valuehl 
2dec				endm 
# End of macro FORTH_DSP_VALUEHL
2dec			 
2dec			;		push hl 
2dec			 
2dec				; destroy value TOS 
2dec			 
2dec				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dec cd aa 23			call macro_forth_dsp_pop 
2def				endm 
# End of macro FORTH_DSP_POP
2def			 
2def			;		pop hl 
2def			if FORTH_ENABLE_MALLOCFREE 
2def cd 60 15			call free 
2df2			endif 
2df2				NEXTW 
2df2 c3 a8 24			jp macro_next 
2df5				endm 
# End of macro NEXTW
2df5			.LIST: 
2df5			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2df5 5c				db WORD_SYS_CORE+72             
2df6 e3 2f			dw .FORGET            
2df8 05				db 4 + 1 
2df9 .. 00			db "LIST",0              
2dfe				endm 
# End of macro CWHEAD
2dfe			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2dfe			; | | The quoted word must be in upper case. 
2dfe			if DEBUG_FORTH_WORDS_KEY 
2dfe				DMARK "LST" 
2dfe f5				push af  
2dff 3a 13 2e			ld a, (.dmark)  
2e02 32 68 fe			ld (debug_mark),a  
2e05 3a 14 2e			ld a, (.dmark+1)  
2e08 32 69 fe			ld (debug_mark+1),a  
2e0b 3a 15 2e			ld a, (.dmark+2)  
2e0e 32 6a fe			ld (debug_mark+2),a  
2e11 18 03			jr .pastdmark  
2e13 ..			.dmark: db "LST"  
2e16 f1			.pastdmark: pop af  
2e17			endm  
# End of macro DMARK
2e17				CALLMONITOR 
2e17 cd 6c fe			call debug_vector  
2e1a				endm  
# End of macro CALLMONITOR
2e1a			endif 
2e1a			 
2e1a				FORTH_DSP_VALUEHL 
2e1a cd f2 22			call macro_dsp_valuehl 
2e1d				endm 
# End of macro FORTH_DSP_VALUEHL
2e1d			 
2e1d e5				push hl 
2e1e				FORTH_DSP_POP 
2e1e cd aa 23			call macro_forth_dsp_pop 
2e21				endm 
# End of macro FORTH_DSP_POP
2e21 c1				pop bc 
2e22			 
2e22			; Start format of scratch string 
2e22			 
2e22 21 be f1			ld hl, scratch 
2e25			 
2e25 3e 3a			ld a, ':' 
2e27 77				ld (hl),a 
2e28 23				inc hl 
2e29 3e 20			ld a, ' ' 
2e2b 77				ld (hl), a 
2e2c			 
2e2c				; Get ptr to the word we need to look up 
2e2c			 
2e2c			;		FORTH_DSP_VALUEHL 
2e2c				;v5 FORTH_DSP_VALUE 
2e2c			; TODO type check 
2e2c			;		inc hl    ; Skip type check  
2e2c			;		push hl 
2e2c			;		ex de, hl    ; put into DE 
2e2c			 
2e2c			 
2e2c 21 00 80			ld hl, baseram 
2e2f				;ld hl, baseusermem 
2e2f			 
2e2f e5			push hl   ; sacreifical push 
2e30			 
2e30			.ldouscanm: 
2e30 e1			pop hl 
2e31			.ldouscan: 
2e31			if DEBUG_FORTH_WORDS 
2e31				DMARK "LSs" 
2e31 f5				push af  
2e32 3a 46 2e			ld a, (.dmark)  
2e35 32 68 fe			ld (debug_mark),a  
2e38 3a 47 2e			ld a, (.dmark+1)  
2e3b 32 69 fe			ld (debug_mark+1),a  
2e3e 3a 48 2e			ld a, (.dmark+2)  
2e41 32 6a fe			ld (debug_mark+2),a  
2e44 18 03			jr .pastdmark  
2e46 ..			.dmark: db "LSs"  
2e49 f1			.pastdmark: pop af  
2e4a			endm  
# End of macro DMARK
2e4a				CALLMONITOR 
2e4a cd 6c fe			call debug_vector  
2e4d				endm  
# End of macro CALLMONITOR
2e4d			endif 
2e4d			; skip dict stub 
2e4d cd f9 25			call forth_tok_next 
2e50			 
2e50			 
2e50			; while we have words to look for 
2e50			 
2e50 7e			ld a, (hl)      
2e51			if DEBUG_FORTH_WORDS 
2e51				DMARK "LSk" 
2e51 f5				push af  
2e52 3a 66 2e			ld a, (.dmark)  
2e55 32 68 fe			ld (debug_mark),a  
2e58 3a 67 2e			ld a, (.dmark+1)  
2e5b 32 69 fe			ld (debug_mark+1),a  
2e5e 3a 68 2e			ld a, (.dmark+2)  
2e61 32 6a fe			ld (debug_mark+2),a  
2e64 18 03			jr .pastdmark  
2e66 ..			.dmark: db "LSk"  
2e69 f1			.pastdmark: pop af  
2e6a			endm  
# End of macro DMARK
2e6a				CALLMONITOR 
2e6a cd 6c fe			call debug_vector  
2e6d				endm  
# End of macro CALLMONITOR
2e6d			endif 
2e6d				;cp WORD_SYS_END 
2e6d				;jp z, .lunotfound 
2e6d			 
2e6d					; if we hit non uwords then gone too far 
2e6d fe 01				cp WORD_SYS_UWORD 
2e6f c2 9f 2f				jp nz, .lunotfound 
2e72			 
2e72				if DEBUG_FORTH_WORDS 
2e72					DMARK "LSu" 
2e72 f5				push af  
2e73 3a 87 2e			ld a, (.dmark)  
2e76 32 68 fe			ld (debug_mark),a  
2e79 3a 88 2e			ld a, (.dmark+1)  
2e7c 32 69 fe			ld (debug_mark+1),a  
2e7f 3a 89 2e			ld a, (.dmark+2)  
2e82 32 6a fe			ld (debug_mark+2),a  
2e85 18 03			jr .pastdmark  
2e87 ..			.dmark: db "LSu"  
2e8a f1			.pastdmark: pop af  
2e8b			endm  
# End of macro DMARK
2e8b					CALLMONITOR 
2e8b cd 6c fe			call debug_vector  
2e8e				endm  
# End of macro CALLMONITOR
2e8e				endif 
2e8e			 
2e8e					; found a uword but is it the one we want... 
2e8e			 
2e8e c5					push bc     ; uword to find is on bc 
2e8f d1					pop de 
2e90			 
2e90 e5					push hl  ; to save the ptr 
2e91			 
2e91					; skip opcode 
2e91 23					inc hl  
2e92					; skip next ptr 
2e92 23					inc hl  
2e93 23					inc hl 
2e94					; skip len 
2e94 23					inc hl 
2e95			 
2e95				if DEBUG_FORTH_WORDS 
2e95					DMARK "LSc" 
2e95 f5				push af  
2e96 3a aa 2e			ld a, (.dmark)  
2e99 32 68 fe			ld (debug_mark),a  
2e9c 3a ab 2e			ld a, (.dmark+1)  
2e9f 32 69 fe			ld (debug_mark+1),a  
2ea2 3a ac 2e			ld a, (.dmark+2)  
2ea5 32 6a fe			ld (debug_mark+2),a  
2ea8 18 03			jr .pastdmark  
2eaa ..			.dmark: db "LSc"  
2ead f1			.pastdmark: pop af  
2eae			endm  
# End of macro DMARK
2eae					CALLMONITOR 
2eae cd 6c fe			call debug_vector  
2eb1				endm  
# End of macro CALLMONITOR
2eb1				endif 
2eb1 cd 65 14				call strcmp 
2eb4 c2 30 2e				jp nz, .ldouscanm 
2eb7				 
2eb7			 
2eb7			 
2eb7					; we have a uword so push its name to the stack 
2eb7			 
2eb7			;	   	push hl  ; save so we can move to next dict block 
2eb7 e1			pop hl 
2eb8			 
2eb8				if DEBUG_FORTH_WORDS 
2eb8					DMARK "LSm" 
2eb8 f5				push af  
2eb9 3a cd 2e			ld a, (.dmark)  
2ebc 32 68 fe			ld (debug_mark),a  
2ebf 3a ce 2e			ld a, (.dmark+1)  
2ec2 32 69 fe			ld (debug_mark+1),a  
2ec5 3a cf 2e			ld a, (.dmark+2)  
2ec8 32 6a fe			ld (debug_mark+2),a  
2ecb 18 03			jr .pastdmark  
2ecd ..			.dmark: db "LSm"  
2ed0 f1			.pastdmark: pop af  
2ed1			endm  
# End of macro DMARK
2ed1					CALLMONITOR 
2ed1 cd 6c fe			call debug_vector  
2ed4				endm  
# End of macro CALLMONITOR
2ed4				endif 
2ed4			 
2ed4					; skip opcode 
2ed4 23					inc hl  
2ed5					; skip next ptr 
2ed5 23					inc hl  
2ed6 23					inc hl 
2ed7					; skip len 
2ed7 7e					ld a, (hl)   ; save length to add 
2ed8				if DEBUG_FORTH_WORDS 
2ed8					DMARK "LS2" 
2ed8 f5				push af  
2ed9 3a ed 2e			ld a, (.dmark)  
2edc 32 68 fe			ld (debug_mark),a  
2edf 3a ee 2e			ld a, (.dmark+1)  
2ee2 32 69 fe			ld (debug_mark+1),a  
2ee5 3a ef 2e			ld a, (.dmark+2)  
2ee8 32 6a fe			ld (debug_mark+2),a  
2eeb 18 03			jr .pastdmark  
2eed ..			.dmark: db "LS2"  
2ef0 f1			.pastdmark: pop af  
2ef1			endm  
# End of macro DMARK
2ef1					CALLMONITOR 
2ef1 cd 6c fe			call debug_vector  
2ef4				endm  
# End of macro CALLMONITOR
2ef4				endif 
2ef4			 
2ef4					; save this location 
2ef4				 
2ef4 e5					push hl 
2ef5			 
2ef5 23					inc hl 
2ef6 11 c0 f1				ld de, scratch+2 
2ef9 4f					ld c, a 
2efa 06 00				ld b, 0 
2efc			 
2efc				if DEBUG_FORTH_WORDS 
2efc					DMARK "LSn" 
2efc f5				push af  
2efd 3a 11 2f			ld a, (.dmark)  
2f00 32 68 fe			ld (debug_mark),a  
2f03 3a 12 2f			ld a, (.dmark+1)  
2f06 32 69 fe			ld (debug_mark+1),a  
2f09 3a 13 2f			ld a, (.dmark+2)  
2f0c 32 6a fe			ld (debug_mark+2),a  
2f0f 18 03			jr .pastdmark  
2f11 ..			.dmark: db "LSn"  
2f14 f1			.pastdmark: pop af  
2f15			endm  
# End of macro DMARK
2f15					CALLMONITOR 
2f15 cd 6c fe			call debug_vector  
2f18				endm  
# End of macro CALLMONITOR
2f18				endif 
2f18			 
2f18					; copy uword name to scratch 
2f18			 
2f18 ed b0				ldir 
2f1a			 
2f1a 1b					dec de 
2f1b 3e 20				ld a, ' '    ; change null to space 
2f1d 12					ld (de), a 
2f1e			 
2f1e 13					inc de 
2f1f			 
2f1f d5					push de 
2f20 c1					pop bc     ; move scratch pointer to end of word name and save it 
2f21			 
2f21 e1					pop hl 
2f22 7e					ld a, (hl) 
2f23					;inc hl 
2f23					; skip word string 
2f23 cd cf 0f				call addatohl 
2f26			 
2f26 23					inc hl 
2f27			 
2f27				if DEBUG_FORTH_WORDS 
2f27					DMARK "LS3" 
2f27 f5				push af  
2f28 3a 3c 2f			ld a, (.dmark)  
2f2b 32 68 fe			ld (debug_mark),a  
2f2e 3a 3d 2f			ld a, (.dmark+1)  
2f31 32 69 fe			ld (debug_mark+1),a  
2f34 3a 3e 2f			ld a, (.dmark+2)  
2f37 32 6a fe			ld (debug_mark+2),a  
2f3a 18 03			jr .pastdmark  
2f3c ..			.dmark: db "LS3"  
2f3f f1			.pastdmark: pop af  
2f40			endm  
# End of macro DMARK
2f40					CALLMONITOR 
2f40 cd 6c fe			call debug_vector  
2f43				endm  
# End of macro CALLMONITOR
2f43				endif 
2f43					; should now be at the start of the machine code to setup the eval of the uword 
2f43					; now locate the ptr to the string defintion 
2f43			 
2f43					; skip ld hl, 
2f43					; then load the ptr 
2f43			; TODO use get from hl ptr 
2f43 23					inc hl 
2f44 5e					ld e, (hl) 
2f45 23					inc hl 
2f46 56					ld d, (hl) 
2f47 eb					ex de, hl 
2f48			 
2f48			 
2f48				if DEBUG_FORTH_WORDS 
2f48					DMARK "LSt" 
2f48 f5				push af  
2f49 3a 5d 2f			ld a, (.dmark)  
2f4c 32 68 fe			ld (debug_mark),a  
2f4f 3a 5e 2f			ld a, (.dmark+1)  
2f52 32 69 fe			ld (debug_mark+1),a  
2f55 3a 5f 2f			ld a, (.dmark+2)  
2f58 32 6a fe			ld (debug_mark+2),a  
2f5b 18 03			jr .pastdmark  
2f5d ..			.dmark: db "LSt"  
2f60 f1			.pastdmark: pop af  
2f61			endm  
# End of macro DMARK
2f61					CALLMONITOR 
2f61 cd 6c fe			call debug_vector  
2f64				endm  
# End of macro CALLMONITOR
2f64				endif 
2f64			 
2f64			; cant push right now due to tokenised strings  
2f64			 
2f64			; get the destination of where to copy this definition to. 
2f64			 
2f64 c5					push bc 
2f65 d1					pop de 
2f66			 
2f66 7e			.listl:         ld a,(hl) 
2f67 fe 00				cp 0 
2f69 28 09				jr z, .lreplsp     ; replace zero with space 
2f6b					;cp FORTH_END_BUFFER 
2f6b fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f6d 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f6f				 
2f6f					; just copy this char as is then 
2f6f			 
2f6f 12					ld (de), a 
2f70			 
2f70 23			.listnxt:	inc hl 
2f71 13					inc de 
2f72 18 f2				jr .listl 
2f74			 
2f74 3e 20		.lreplsp:	ld a,' ' 
2f76 12					ld (de), a 
2f77 18 f7				jr .listnxt 
2f79			 
2f79			; close up uword def 
2f79			 
2f79			.listdone: 
2f79 12					ld (de), a 
2f7a 13					inc de 
2f7b 3e 00				ld a, 0 
2f7d 12					ld (de), a 
2f7e			 
2f7e			; now have def so clean up and push to stack 
2f7e			 
2f7e 21 be f1				ld hl, scratch 
2f81				if DEBUG_FORTH_WORDS 
2f81					DMARK "Ltp" 
2f81 f5				push af  
2f82 3a 96 2f			ld a, (.dmark)  
2f85 32 68 fe			ld (debug_mark),a  
2f88 3a 97 2f			ld a, (.dmark+1)  
2f8b 32 69 fe			ld (debug_mark+1),a  
2f8e 3a 98 2f			ld a, (.dmark+2)  
2f91 32 6a fe			ld (debug_mark+2),a  
2f94 18 03			jr .pastdmark  
2f96 ..			.dmark: db "Ltp"  
2f99 f1			.pastdmark: pop af  
2f9a			endm  
# End of macro DMARK
2f9a					CALLMONITOR 
2f9a cd 6c fe			call debug_vector  
2f9d				endm  
# End of macro CALLMONITOR
2f9d				endif 
2f9d			 
2f9d 18 1f			jr .listpush 
2f9f			 
2f9f			;.lnuword:	pop hl 
2f9f			;		call forth_tok_next 
2f9f			;		jp .ldouscan  
2f9f			 
2f9f			.lunotfound:		  
2f9f			 
2f9f				if DEBUG_FORTH_WORDS 
2f9f					DMARK "LSn" 
2f9f f5				push af  
2fa0 3a b4 2f			ld a, (.dmark)  
2fa3 32 68 fe			ld (debug_mark),a  
2fa6 3a b5 2f			ld a, (.dmark+1)  
2fa9 32 69 fe			ld (debug_mark+1),a  
2fac 3a b6 2f			ld a, (.dmark+2)  
2faf 32 6a fe			ld (debug_mark+2),a  
2fb2 18 03			jr .pastdmark  
2fb4 ..			.dmark: db "LSn"  
2fb7 f1			.pastdmark: pop af  
2fb8			endm  
# End of macro DMARK
2fb8					CALLMONITOR 
2fb8 cd 6c fe			call debug_vector  
2fbb				endm  
# End of macro CALLMONITOR
2fbb				endif 
2fbb			 
2fbb					 
2fbb			;		FORTH_DSP_POP 
2fbb			;		ld hl, .luno 
2fbb			 
2fbb					NEXTW			 
2fbb c3 a8 24			jp macro_next 
2fbe				endm 
# End of macro NEXTW
2fbe			 
2fbe			.listpush: 
2fbe				if DEBUG_FORTH_WORDS 
2fbe					DMARK "LS>" 
2fbe f5				push af  
2fbf 3a d3 2f			ld a, (.dmark)  
2fc2 32 68 fe			ld (debug_mark),a  
2fc5 3a d4 2f			ld a, (.dmark+1)  
2fc8 32 69 fe			ld (debug_mark+1),a  
2fcb 3a d5 2f			ld a, (.dmark+2)  
2fce 32 6a fe			ld (debug_mark+2),a  
2fd1 18 03			jr .pastdmark  
2fd3 ..			.dmark: db "LS>"  
2fd6 f1			.pastdmark: pop af  
2fd7			endm  
# End of macro DMARK
2fd7					CALLMONITOR 
2fd7 cd 6c fe			call debug_vector  
2fda				endm  
# End of macro CALLMONITOR
2fda				endif 
2fda cd 69 21				call forth_push_str 
2fdd			 
2fdd			 
2fdd			 
2fdd					NEXTW 
2fdd c3 a8 24			jp macro_next 
2fe0				endm 
# End of macro NEXTW
2fe0			 
2fe0			;.luno:    db "Word not found",0 
2fe0			 
2fe0			 
2fe0			 
2fe0			 
2fe0			 
2fe0			;		push hl   ; save pointer to start of uword def string 
2fe0			; 
2fe0			;; look for FORTH_EOL_LINE 
2fe0			;		ld a, FORTH_END_BUFFER 
2fe0			;		call strlent 
2fe0			; 
2fe0			;		inc hl		 ; space for coln def 
2fe0			;		inc hl 
2fe0			;		inc hl          ; space for terms 
2fe0			;		inc hl 
2fe0			; 
2fe0			;		ld a, 20   ; TODO get actual length 
2fe0			;		call addatohl    ; include a random amount of room for the uword name 
2fe0			; 
2fe0			;		 
2fe0			;	if DEBUG_FORTH_WORDS 
2fe0			;		DMARK "Lt1" 
2fe0			;		CALLMONITOR 
2fe0			;	endif 
2fe0			;		 
2fe0			; 
2fe0			;; malloc space for the string because we cant change it 
2fe0			; 
2fe0			;		call malloc 
2fe0			;	if DEBUG_FORTH_MALLOC_GUARD 
2fe0			;		push af 
2fe0			;		call ishlzero 
2fe0			;		pop af 
2fe0			;		 
2fe0			;		call z,malloc_error 
2fe0			;	endif 
2fe0			; 
2fe0			;	if DEBUG_FORTH_WORDS 
2fe0			;		DMARK "Lt2" 
2fe0			;		CALLMONITOR 
2fe0			;	endif 
2fe0			;		pop de 
2fe0			;		push hl    ; push the malloc to release later 
2fe0			;		push hl   ;  push back a copy for the later stack push 
2fe0			;		 
2fe0			;; copy the string swapping out the zero terms for spaces 
2fe0			; 
2fe0			;		; de has our source 
2fe0			;		; hl has our dest 
2fe0			; 
2fe0			;; add the coln def 
2fe0			; 
2fe0			;		ld a, ':' 
2fe0			;		ld (hl), a 
2fe0			;		inc hl 
2fe0			;		ld a, ' ' 
2fe0			;		ld (hl), a 
2fe0			;		inc hl 
2fe0			; 
2fe0			;; add the uname word 
2fe0			;		push de   ; save our string for now 
2fe0			;		ex de, hl 
2fe0			; 
2fe0			;		FORTH_DSP_VALUE 
2fe0			;		;v5 FORTH_DSP_VALUE 
2fe0			; 
2fe0			;		inc hl   ; skip type but we know by now this is OK 
2fe0			; 
2fe0			;.luword:	ld a,(hl) 
2fe0			;		cp 0 
2fe0			;		jr z, .luword2 
2fe0			;		ld (de), a 
2fe0			;		inc de 
2fe0			;		inc hl 
2fe0			;		jr .luword 
2fe0			; 
2fe0			;.luword2:	ld a, ' ' 
2fe0			;		ld (de), a 
2fe0			;;		inc hl 
2fe0			;;		inc de 
2fe0			;;		ld (de), a 
2fe0			;;		inc hl 
2fe0			;		inc de 
2fe0			; 
2fe0			;		ex de, hl 
2fe0			;		pop de 
2fe0			;		 
2fe0			;		 
2fe0			; 
2fe0			;; detoken that string and copy it 
2fe0			; 
2fe0			;	if DEBUG_FORTH_WORDS 
2fe0			;		DMARK "Lt2" 
2fe0			;		CALLMONITOR 
2fe0			;	endif 
2fe0			;.ldetok:	ld a, (de) 
2fe0			;		cp FORTH_END_BUFFER 
2fe0			;		jr z, .ldetokend 
2fe0			;		; swap out any zero term for space 
2fe0			;		cp 0 
2fe0			;		jr nz, .ldetoknext 
2fe0			;		ld a, ' ' 
2fe0			; 
2fe0			;	if DEBUG_FORTH_WORDS 
2fe0			;		DMARK "LtS" 
2fe0			;		CALLMONITOR 
2fe0			;	endif 
2fe0			;.ldetoknext:	ld (hl), a 
2fe0			;		inc de 
2fe0			;		inc hl 
2fe0			;		jr .ldetok 
2fe0			; 
2fe0			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2fe0			;		ld (hl), a  
2fe0			; 
2fe0			;; free that temp malloc 
2fe0			; 
2fe0			;		pop hl    
2fe0			; 
2fe0			;	if DEBUG_FORTH_WORDS 
2fe0			;		DMARK "Lt4" 
2fe0			;		CALLMONITOR 
2fe0			;	endif 
2fe0			;		call forth_apushstrhl 
2fe0			; 
2fe0			;		; get rid of temp malloc area 
2fe0			; 
2fe0			;		pop hl 
2fe0			;		call free 
2fe0			; 
2fe0			;		jr .ludone 
2fe0			; 
2fe0			;.lnuword:	pop hl 
2fe0			;		call forth_tok_next 
2fe0			;		jp .ldouscan  
2fe0			; 
2fe0			;.ludone:		 pop hl 
2fe0			; 
2fe0					NEXTW 
2fe0 c3 a8 24			jp macro_next 
2fe3				endm 
# End of macro NEXTW
2fe3			 
2fe3			.FORGET: 
2fe3				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2fe3 5d				db WORD_SYS_CORE+73             
2fe4 5c 30			dw .NOP            
2fe6 07				db 6 + 1 
2fe7 .. 00			db "FORGET",0              
2fee				endm 
# End of macro CWHEAD
2fee			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2fee			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2fee			; | |  
2fee			; | | e.g. "MORE" forget 
2fee					if DEBUG_FORTH_WORDS_KEY 
2fee						DMARK "FRG" 
2fee f5				push af  
2fef 3a 03 30			ld a, (.dmark)  
2ff2 32 68 fe			ld (debug_mark),a  
2ff5 3a 04 30			ld a, (.dmark+1)  
2ff8 32 69 fe			ld (debug_mark+1),a  
2ffb 3a 05 30			ld a, (.dmark+2)  
2ffe 32 6a fe			ld (debug_mark+2),a  
3001 18 03			jr .pastdmark  
3003 ..			.dmark: db "FRG"  
3006 f1			.pastdmark: pop af  
3007			endm  
# End of macro DMARK
3007						CALLMONITOR 
3007 cd 6c fe			call debug_vector  
300a				endm  
# End of macro CALLMONITOR
300a					endif 
300a			 
300a				; find uword 
300a			        ; update start of word with "_" 
300a				; replace uword with deleted flag 
300a			 
300a			 
300a			;	if DEBUG_FORTH_WORDS 
300a			;		DMARK "FOG" 
300a			;		CALLMONITOR 
300a			;	endif 
300a			 
300a			 
300a					; Get ptr to the word we need to look up 
300a			 
300a					FORTH_DSP_VALUEHL 
300a cd f2 22			call macro_dsp_valuehl 
300d				endm 
# End of macro FORTH_DSP_VALUEHL
300d					;v5 FORTH_DSP_VALUE 
300d				; TODO type check 
300d			;		inc hl    ; Skip type check  
300d e5					push hl 
300e c1					pop bc 
300f			;		ex de, hl    ; put into DE 
300f			 
300f			 
300f 21 00 80				ld hl, baseram 
3012					;ld hl, baseusermem 
3012			 
3012				; skip dict stub 
3012			;	call forth_tok_next 
3012 e5			push hl   ; sacreifical push 
3013			 
3013			.fldouscanm: 
3013 e1				pop hl 
3014			.fldouscan: 
3014			;	if DEBUG_FORTH_WORDS 
3014			;		DMARK "LSs" 
3014			;		CALLMONITOR 
3014			;	endif 
3014				; skip dict stub 
3014 cd f9 25				call forth_tok_next 
3017			 
3017			 
3017			; while we have words to look for 
3017			 
3017 7e				ld a, (hl)      
3018			;	if DEBUG_FORTH_WORDS 
3018			;		DMARK "LSk" 
3018			;		CALLMONITOR 
3018			;	endif 
3018 fe 00				cp WORD_SYS_END 
301a ca 56 30				jp z, .flunotfound 
301d fe 01				cp WORD_SYS_UWORD 
301f c2 14 30				jp nz, .fldouscan 
3022			 
3022			;	if DEBUG_FORTH_WORDS 
3022			;		DMARK "LSu" 
3022			;		CALLMONITOR 
3022			;	endif 
3022			 
3022					; found a uword but is it the one we want... 
3022			 
3022 c5					push bc     ; uword to find is on bc 
3023 d1					pop de 
3024			 
3024 e5					push hl  ; to save the ptr 
3025			 
3025					; skip opcode 
3025 23					inc hl  
3026					; skip next ptr 
3026 23					inc hl  
3027 23					inc hl 
3028					; skip len 
3028 23					inc hl 
3029			 
3029			;	if DEBUG_FORTH_WORDS 
3029			;		DMARK "LSc" 
3029			;		CALLMONITOR 
3029			;	endif 
3029 cd 65 14				call strcmp 
302c c2 13 30				jp nz, .fldouscanm 
302f			; 
302f			; 
302f			;; while we have words to look for 
302f			; 
302f			;.fdouscan:	ld a, (hl)      
302f			;	if DEBUG_FORTH_WORDS 
302f			;		DMARK "LSs" 
302f			;		CALLMONITOR 
302f			;	endif 
302f			;		cp WORD_SYS_END 
302f			;		jp z, .fudone 
302f			;		cp WORD_SYS_UWORD 
302f			;		jp nz, .fnuword 
302f			; 
302f			;	if DEBUG_FORTH_WORDS 
302f			;		DMARK "FGu" 
302f			;		CALLMONITOR 
302f			;	endif 
302f			; 
302f			;		; found a uword but is it the one we want... 
302f			; 
302f			; 
302f			;	        pop de   ; get back the dsp name 
302f			;		push de 
302f			; 
302f			;		push hl  ; to save the ptr 
302f			; 
302f			;		; skip opcode 
302f			;		inc hl  
302f			;		; skip next ptr 
302f			;		inc hl  
302f			;		inc hl 
302f			;		; skip len 
302f			;		inc hl 
302f			; 
302f			;	if DEBUG_FORTH_WORDS 
302f			;		DMARK "FGc" 
302f			;		CALLMONITOR 
302f			;	endif 
302f			;		call strcmp 
302f			;		jp nz, .fnuword 
302f			 
302f			 
302f e1			pop hl 
3030			 
3030				 
3030				if DEBUG_FORTH_WORDS 
3030					DMARK "FGm" 
3030 f5				push af  
3031 3a 45 30			ld a, (.dmark)  
3034 32 68 fe			ld (debug_mark),a  
3037 3a 46 30			ld a, (.dmark+1)  
303a 32 69 fe			ld (debug_mark+1),a  
303d 3a 47 30			ld a, (.dmark+2)  
3040 32 6a fe			ld (debug_mark+2),a  
3043 18 03			jr .pastdmark  
3045 ..			.dmark: db "FGm"  
3048 f1			.pastdmark: pop af  
3049			endm  
# End of macro DMARK
3049					CALLMONITOR 
3049 cd 6c fe			call debug_vector  
304c				endm  
# End of macro CALLMONITOR
304c				endif 
304c			 
304c			 
304c			 
304c					; we have a uword so push its name to the stack 
304c			 
304c			;	   	push hl  ; save so we can move to next dict block 
304c			;pop hl 
304c			 
304c					; update opcode to deleted 
304c 3e 03				ld a, WORD_SYS_DELETED 
304e 77					ld (hl), a 
304f			 
304f 23					inc hl  
3050					; skip next ptr 
3050 23					inc hl  
3051 23					inc hl 
3052					; skip len 
3052 23					inc hl 
3053			 
3053					; TODO change parser to skip deleted words but for now mark it out 
3053 3e 5f				ld a, "_" 
3055 77					ld  (hl),a 
3056			 
3056			;		jr .fudone 
3056			; 
3056			;.fnuword:	pop hl 
3056			;		call forth_tok_next 
3056			;		jp .fdouscan  
3056			 
3056			.flunotfound:		  
3056			 
3056			 
3056					 
3056					FORTH_DSP_POP 
3056 cd aa 23			call macro_forth_dsp_pop 
3059				endm 
# End of macro FORTH_DSP_POP
3059			;		ld hl, .luno 
3059			;.fudone:		 pop hl 
3059					NEXTW 
3059 c3 a8 24			jp macro_next 
305c				endm 
# End of macro NEXTW
305c			.NOP: 
305c				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
305c 61				db WORD_SYS_CORE+77             
305d 83 30			dw .COMO            
305f 04				db 3 + 1 
3060 .. 00			db "NOP",0              
3064				endm 
# End of macro CWHEAD
3064			; | NOP (  --  ) Do nothing | DONE 
3064					if DEBUG_FORTH_WORDS_KEY 
3064						DMARK "NOP" 
3064 f5				push af  
3065 3a 79 30			ld a, (.dmark)  
3068 32 68 fe			ld (debug_mark),a  
306b 3a 7a 30			ld a, (.dmark+1)  
306e 32 69 fe			ld (debug_mark+1),a  
3071 3a 7b 30			ld a, (.dmark+2)  
3074 32 6a fe			ld (debug_mark+2),a  
3077 18 03			jr .pastdmark  
3079 ..			.dmark: db "NOP"  
307c f1			.pastdmark: pop af  
307d			endm  
# End of macro DMARK
307d						CALLMONITOR 
307d cd 6c fe			call debug_vector  
3080				endm  
# End of macro CALLMONITOR
3080					endif 
3080				       NEXTW 
3080 c3 a8 24			jp macro_next 
3083				endm 
# End of macro NEXTW
3083			.COMO: 
3083				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
3083 6e				db WORD_SYS_CORE+90             
3084 d5 30			dw .COMC            
3086 02				db 1 + 1 
3087 .. 00			db "(",0              
3089				endm 
# End of macro CWHEAD
3089			; | ( ( -- )  Start of comment | DONE 
3089			 
3089			 
3089 2a bf f4				ld hl, ( os_tok_ptr) 
308c 11 d0 30			ld de, .closepar 
308f					 
308f					if DEBUG_FORTH_WORDS 
308f						DMARK ").." 
308f f5				push af  
3090 3a a4 30			ld a, (.dmark)  
3093 32 68 fe			ld (debug_mark),a  
3096 3a a5 30			ld a, (.dmark+1)  
3099 32 69 fe			ld (debug_mark+1),a  
309c 3a a6 30			ld a, (.dmark+2)  
309f 32 6a fe			ld (debug_mark+2),a  
30a2 18 03			jr .pastdmark  
30a4 ..			.dmark: db ").."  
30a7 f1			.pastdmark: pop af  
30a8			endm  
# End of macro DMARK
30a8						CALLMONITOR 
30a8 cd 6c fe			call debug_vector  
30ab				endm  
# End of macro CALLMONITOR
30ab					endif 
30ab cd c3 25			call findnexttok  
30ae			 
30ae					if DEBUG_FORTH_WORDS 
30ae						DMARK "IF5" 
30ae f5				push af  
30af 3a c3 30			ld a, (.dmark)  
30b2 32 68 fe			ld (debug_mark),a  
30b5 3a c4 30			ld a, (.dmark+1)  
30b8 32 69 fe			ld (debug_mark+1),a  
30bb 3a c5 30			ld a, (.dmark+2)  
30be 32 6a fe			ld (debug_mark+2),a  
30c1 18 03			jr .pastdmark  
30c3 ..			.dmark: db "IF5"  
30c6 f1			.pastdmark: pop af  
30c7			endm  
# End of macro DMARK
30c7						CALLMONITOR 
30c7 cd 6c fe			call debug_vector  
30ca				endm  
# End of macro CALLMONITOR
30ca					endif 
30ca				; replace below with ) exec using tok_ptr 
30ca 22 bf f4			ld (os_tok_ptr), hl 
30cd c3 39 25			jp exec1 
30d0			 
30d0 .. 00			.closepar:   db ")",0 
30d2			 
30d2				       NEXTW 
30d2 c3 a8 24			jp macro_next 
30d5				endm 
# End of macro NEXTW
30d5			.COMC: 
30d5				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
30d5 6f				db WORD_SYS_CORE+91             
30d6 de 30			dw .SCRATCH            
30d8 02				db 1 + 1 
30d9 .. 00			db ")",0              
30db				endm 
# End of macro CWHEAD
30db			; | ) ( -- )  End of comment |  DONE  
30db				       NEXTW 
30db c3 a8 24			jp macro_next 
30de				endm 
# End of macro NEXTW
30de			 
30de			.SCRATCH: 
30de				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30de 6f				db WORD_SYS_CORE+91             
30df 19 31			dw .INC            
30e1 08				db 7 + 1 
30e2 .. 00			db "SCRATCH",0              
30ea				endm 
# End of macro CWHEAD
30ea			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
30ea			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
30ea			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
30ea			; | |  
30ea			; | | e.g.    : score $00 scratch ; 
30ea			; | |  
30ea			; | | $00 score ! 
30ea			; | | $01 score +! 
30ea			; | |  
30ea			; | | e.g.   : varword $0a scratch ;  
30ea			; | | 
30ea			; | | $8000 varword ! 
30ea					if DEBUG_FORTH_WORDS_KEY 
30ea						DMARK "SCR" 
30ea f5				push af  
30eb 3a ff 30			ld a, (.dmark)  
30ee 32 68 fe			ld (debug_mark),a  
30f1 3a 00 31			ld a, (.dmark+1)  
30f4 32 69 fe			ld (debug_mark+1),a  
30f7 3a 01 31			ld a, (.dmark+2)  
30fa 32 6a fe			ld (debug_mark+2),a  
30fd 18 03			jr .pastdmark  
30ff ..			.dmark: db "SCR"  
3102 f1			.pastdmark: pop af  
3103			endm  
# End of macro DMARK
3103						CALLMONITOR 
3103 cd 6c fe			call debug_vector  
3106				endm  
# End of macro CALLMONITOR
3106					endif 
3106			 
3106					FORTH_DSP_VALUEHL 
3106 cd f2 22			call macro_dsp_valuehl 
3109				endm 
# End of macro FORTH_DSP_VALUEHL
3109				 
3109					FORTH_DSP_POP 
3109 cd aa 23			call macro_forth_dsp_pop 
310c				endm 
# End of macro FORTH_DSP_POP
310c			 
310c 7d					ld a, l 
310d 21 e3 f6				ld hl, os_var_array 
3110 cd cf 0f				call addatohl 
3113			 
3113 cd fb 20				call forth_push_numhl 
3116			 
3116				       NEXTW 
3116 c3 a8 24			jp macro_next 
3119				endm 
# End of macro NEXTW
3119			 
3119			.INC: 
3119				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3119 6f				db WORD_SYS_CORE+91             
311a 6f 31			dw .DEC            
311c 03				db 2 + 1 
311d .. 00			db "+!",0              
3120				endm 
# End of macro CWHEAD
3120			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3120					if DEBUG_FORTH_WORDS_KEY 
3120						DMARK "+s_" 
3120 f5				push af  
3121 3a 35 31			ld a, (.dmark)  
3124 32 68 fe			ld (debug_mark),a  
3127 3a 36 31			ld a, (.dmark+1)  
312a 32 69 fe			ld (debug_mark+1),a  
312d 3a 37 31			ld a, (.dmark+2)  
3130 32 6a fe			ld (debug_mark+2),a  
3133 18 03			jr .pastdmark  
3135 ..			.dmark: db "+s_"  
3138 f1			.pastdmark: pop af  
3139			endm  
# End of macro DMARK
3139						CALLMONITOR 
3139 cd 6c fe			call debug_vector  
313c				endm  
# End of macro CALLMONITOR
313c					endif 
313c			 
313c					FORTH_DSP_VALUEHL 
313c cd f2 22			call macro_dsp_valuehl 
313f				endm 
# End of macro FORTH_DSP_VALUEHL
313f			 
313f e5					push hl   ; save address 
3140			 
3140					FORTH_DSP_POP 
3140 cd aa 23			call macro_forth_dsp_pop 
3143				endm 
# End of macro FORTH_DSP_POP
3143			 
3143					FORTH_DSP_VALUEHL 
3143 cd f2 22			call macro_dsp_valuehl 
3146				endm 
# End of macro FORTH_DSP_VALUEHL
3146			 
3146 e5					push hl 
3147					FORTH_DSP_POP 
3147 cd aa 23			call macro_forth_dsp_pop 
314a				endm 
# End of macro FORTH_DSP_POP
314a e1					pop hl 
314b			 
314b					; hl contains value to add to byte at a 
314b				 
314b eb					ex de, hl 
314c			 
314c e1					pop hl 
314d			 
314d					if DEBUG_FORTH_WORDS 
314d						DMARK "INC" 
314d f5				push af  
314e 3a 62 31			ld a, (.dmark)  
3151 32 68 fe			ld (debug_mark),a  
3154 3a 63 31			ld a, (.dmark+1)  
3157 32 69 fe			ld (debug_mark+1),a  
315a 3a 64 31			ld a, (.dmark+2)  
315d 32 6a fe			ld (debug_mark+2),a  
3160 18 03			jr .pastdmark  
3162 ..			.dmark: db "INC"  
3165 f1			.pastdmark: pop af  
3166			endm  
# End of macro DMARK
3166						CALLMONITOR 
3166 cd 6c fe			call debug_vector  
3169				endm  
# End of macro CALLMONITOR
3169					endif 
3169			 
3169 7e					ld a,(hl) 
316a 83					add e 
316b 77					ld (hl),a 
316c			 
316c			 
316c			 
316c				       NEXTW 
316c c3 a8 24			jp macro_next 
316f				endm 
# End of macro NEXTW
316f			 
316f			.DEC: 
316f				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
316f 6f				db WORD_SYS_CORE+91             
3170 c3 31			dw .INC2            
3172 03				db 2 + 1 
3173 .. 00			db "-!",0              
3176				endm 
# End of macro CWHEAD
3176			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
3176					if DEBUG_FORTH_WORDS_KEY 
3176						DMARK "-s_" 
3176 f5				push af  
3177 3a 8b 31			ld a, (.dmark)  
317a 32 68 fe			ld (debug_mark),a  
317d 3a 8c 31			ld a, (.dmark+1)  
3180 32 69 fe			ld (debug_mark+1),a  
3183 3a 8d 31			ld a, (.dmark+2)  
3186 32 6a fe			ld (debug_mark+2),a  
3189 18 03			jr .pastdmark  
318b ..			.dmark: db "-s_"  
318e f1			.pastdmark: pop af  
318f			endm  
# End of macro DMARK
318f						CALLMONITOR 
318f cd 6c fe			call debug_vector  
3192				endm  
# End of macro CALLMONITOR
3192					endif 
3192			 
3192					FORTH_DSP_VALUEHL 
3192 cd f2 22			call macro_dsp_valuehl 
3195				endm 
# End of macro FORTH_DSP_VALUEHL
3195			 
3195 e5					push hl   ; save address 
3196			 
3196					FORTH_DSP_POP 
3196 cd aa 23			call macro_forth_dsp_pop 
3199				endm 
# End of macro FORTH_DSP_POP
3199			 
3199					FORTH_DSP_VALUEHL 
3199 cd f2 22			call macro_dsp_valuehl 
319c				endm 
# End of macro FORTH_DSP_VALUEHL
319c			 
319c					; hl contains value to add to byte at a 
319c				 
319c eb					ex de, hl 
319d			 
319d e1					pop hl 
319e			 
319e					if DEBUG_FORTH_WORDS 
319e						DMARK "DEC" 
319e f5				push af  
319f 3a b3 31			ld a, (.dmark)  
31a2 32 68 fe			ld (debug_mark),a  
31a5 3a b4 31			ld a, (.dmark+1)  
31a8 32 69 fe			ld (debug_mark+1),a  
31ab 3a b5 31			ld a, (.dmark+2)  
31ae 32 6a fe			ld (debug_mark+2),a  
31b1 18 03			jr .pastdmark  
31b3 ..			.dmark: db "DEC"  
31b6 f1			.pastdmark: pop af  
31b7			endm  
# End of macro DMARK
31b7						CALLMONITOR 
31b7 cd 6c fe			call debug_vector  
31ba				endm  
# End of macro CALLMONITOR
31ba					endif 
31ba			 
31ba 7e					ld a,(hl) 
31bb 93					sub e 
31bc 77					ld (hl),a 
31bd			 
31bd			 
31bd					FORTH_DSP_POP 
31bd cd aa 23			call macro_forth_dsp_pop 
31c0				endm 
# End of macro FORTH_DSP_POP
31c0			 
31c0				       NEXTW 
31c0 c3 a8 24			jp macro_next 
31c3				endm 
# End of macro NEXTW
31c3			 
31c3			.INC2: 
31c3				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
31c3 6f				db WORD_SYS_CORE+91             
31c4 70 32			dw .DEC2            
31c6 04				db 3 + 1 
31c7 .. 00			db "+2!",0              
31cb				endm 
# End of macro CWHEAD
31cb			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
31cb			 
31cb					if DEBUG_FORTH_WORDS_KEY 
31cb						DMARK "+2s" 
31cb f5				push af  
31cc 3a e0 31			ld a, (.dmark)  
31cf 32 68 fe			ld (debug_mark),a  
31d2 3a e1 31			ld a, (.dmark+1)  
31d5 32 69 fe			ld (debug_mark+1),a  
31d8 3a e2 31			ld a, (.dmark+2)  
31db 32 6a fe			ld (debug_mark+2),a  
31de 18 03			jr .pastdmark  
31e0 ..			.dmark: db "+2s"  
31e3 f1			.pastdmark: pop af  
31e4			endm  
# End of macro DMARK
31e4						CALLMONITOR 
31e4 cd 6c fe			call debug_vector  
31e7				endm  
# End of macro CALLMONITOR
31e7					endif 
31e7			 
31e7					; Address 
31e7			 
31e7					FORTH_DSP_VALUEHL 
31e7 cd f2 22			call macro_dsp_valuehl 
31ea				endm 
# End of macro FORTH_DSP_VALUEHL
31ea			 
31ea e5					push hl    ; save address 
31eb			 
31eb					; load content into de 
31eb			 
31eb 5e					ld e,(hl) 
31ec 23					inc hl 
31ed 56					ld d, (hl) 
31ee			 
31ee					if DEBUG_FORTH_WORDS 
31ee						DMARK "+2a" 
31ee f5				push af  
31ef 3a 03 32			ld a, (.dmark)  
31f2 32 68 fe			ld (debug_mark),a  
31f5 3a 04 32			ld a, (.dmark+1)  
31f8 32 69 fe			ld (debug_mark+1),a  
31fb 3a 05 32			ld a, (.dmark+2)  
31fe 32 6a fe			ld (debug_mark+2),a  
3201 18 03			jr .pastdmark  
3203 ..			.dmark: db "+2a"  
3206 f1			.pastdmark: pop af  
3207			endm  
# End of macro DMARK
3207						CALLMONITOR 
3207 cd 6c fe			call debug_vector  
320a				endm  
# End of macro CALLMONITOR
320a					endif 
320a			 
320a					FORTH_DSP_POP 
320a cd aa 23			call macro_forth_dsp_pop 
320d				endm 
# End of macro FORTH_DSP_POP
320d			 
320d					; Get value to add 
320d			 
320d					FORTH_DSP_VALUE 
320d cd db 22			call macro_forth_dsp_value 
3210				endm 
# End of macro FORTH_DSP_VALUE
3210			 
3210					if DEBUG_FORTH_WORDS 
3210						DMARK "+2v" 
3210 f5				push af  
3211 3a 25 32			ld a, (.dmark)  
3214 32 68 fe			ld (debug_mark),a  
3217 3a 26 32			ld a, (.dmark+1)  
321a 32 69 fe			ld (debug_mark+1),a  
321d 3a 27 32			ld a, (.dmark+2)  
3220 32 6a fe			ld (debug_mark+2),a  
3223 18 03			jr .pastdmark  
3225 ..			.dmark: db "+2v"  
3228 f1			.pastdmark: pop af  
3229			endm  
# End of macro DMARK
3229						CALLMONITOR 
3229 cd 6c fe			call debug_vector  
322c				endm  
# End of macro CALLMONITOR
322c					endif 
322c			 
322c 19					add hl, de 
322d			 
322d					if DEBUG_FORTH_WORDS 
322d						DMARK "+2+" 
322d f5				push af  
322e 3a 42 32			ld a, (.dmark)  
3231 32 68 fe			ld (debug_mark),a  
3234 3a 43 32			ld a, (.dmark+1)  
3237 32 69 fe			ld (debug_mark+1),a  
323a 3a 44 32			ld a, (.dmark+2)  
323d 32 6a fe			ld (debug_mark+2),a  
3240 18 03			jr .pastdmark  
3242 ..			.dmark: db "+2+"  
3245 f1			.pastdmark: pop af  
3246			endm  
# End of macro DMARK
3246						CALLMONITOR 
3246 cd 6c fe			call debug_vector  
3249				endm  
# End of macro CALLMONITOR
3249					endif 
3249			 
3249					; move result to de 
3249			 
3249 eb					ex de, hl 
324a			 
324a					; Address 
324a			 
324a e1					pop hl 
324b			 
324b					; save it back 
324b			 
324b 73					ld (hl), e 
324c 23					inc hl 
324d 72					ld (hl), d 
324e			 
324e					if DEBUG_FORTH_WORDS 
324e						DMARK "+2e" 
324e f5				push af  
324f 3a 63 32			ld a, (.dmark)  
3252 32 68 fe			ld (debug_mark),a  
3255 3a 64 32			ld a, (.dmark+1)  
3258 32 69 fe			ld (debug_mark+1),a  
325b 3a 65 32			ld a, (.dmark+2)  
325e 32 6a fe			ld (debug_mark+2),a  
3261 18 03			jr .pastdmark  
3263 ..			.dmark: db "+2e"  
3266 f1			.pastdmark: pop af  
3267			endm  
# End of macro DMARK
3267						CALLMONITOR 
3267 cd 6c fe			call debug_vector  
326a				endm  
# End of macro CALLMONITOR
326a					endif 
326a			 
326a			 
326a			 
326a					FORTH_DSP_POP 
326a cd aa 23			call macro_forth_dsp_pop 
326d				endm 
# End of macro FORTH_DSP_POP
326d			 
326d			 
326d				       NEXTW 
326d c3 a8 24			jp macro_next 
3270				endm 
# End of macro NEXTW
3270			 
3270			.DEC2: 
3270				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3270 6f				db WORD_SYS_CORE+91             
3271 1f 33			dw .GET2            
3273 04				db 3 + 1 
3274 .. 00			db "-2!",0              
3278				endm 
# End of macro CWHEAD
3278			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3278			 
3278			 
3278					if DEBUG_FORTH_WORDS_KEY 
3278						DMARK "-2s" 
3278 f5				push af  
3279 3a 8d 32			ld a, (.dmark)  
327c 32 68 fe			ld (debug_mark),a  
327f 3a 8e 32			ld a, (.dmark+1)  
3282 32 69 fe			ld (debug_mark+1),a  
3285 3a 8f 32			ld a, (.dmark+2)  
3288 32 6a fe			ld (debug_mark+2),a  
328b 18 03			jr .pastdmark  
328d ..			.dmark: db "-2s"  
3290 f1			.pastdmark: pop af  
3291			endm  
# End of macro DMARK
3291						CALLMONITOR 
3291 cd 6c fe			call debug_vector  
3294				endm  
# End of macro CALLMONITOR
3294					endif 
3294			 
3294					; Address 
3294			 
3294					FORTH_DSP_VALUEHL 
3294 cd f2 22			call macro_dsp_valuehl 
3297				endm 
# End of macro FORTH_DSP_VALUEHL
3297			 
3297 e5					push hl    ; save address 
3298			 
3298					; load content into de 
3298			 
3298 5e					ld e,(hl) 
3299 23					inc hl 
329a 56					ld d, (hl) 
329b			 
329b					if DEBUG_FORTH_WORDS 
329b						DMARK "-2a" 
329b f5				push af  
329c 3a b0 32			ld a, (.dmark)  
329f 32 68 fe			ld (debug_mark),a  
32a2 3a b1 32			ld a, (.dmark+1)  
32a5 32 69 fe			ld (debug_mark+1),a  
32a8 3a b2 32			ld a, (.dmark+2)  
32ab 32 6a fe			ld (debug_mark+2),a  
32ae 18 03			jr .pastdmark  
32b0 ..			.dmark: db "-2a"  
32b3 f1			.pastdmark: pop af  
32b4			endm  
# End of macro DMARK
32b4						CALLMONITOR 
32b4 cd 6c fe			call debug_vector  
32b7				endm  
# End of macro CALLMONITOR
32b7					endif 
32b7			 
32b7					FORTH_DSP_POP 
32b7 cd aa 23			call macro_forth_dsp_pop 
32ba				endm 
# End of macro FORTH_DSP_POP
32ba			 
32ba					; Get value to remove 
32ba			 
32ba					FORTH_DSP_VALUE 
32ba cd db 22			call macro_forth_dsp_value 
32bd				endm 
# End of macro FORTH_DSP_VALUE
32bd			 
32bd					if DEBUG_FORTH_WORDS 
32bd						DMARK "-2v" 
32bd f5				push af  
32be 3a d2 32			ld a, (.dmark)  
32c1 32 68 fe			ld (debug_mark),a  
32c4 3a d3 32			ld a, (.dmark+1)  
32c7 32 69 fe			ld (debug_mark+1),a  
32ca 3a d4 32			ld a, (.dmark+2)  
32cd 32 6a fe			ld (debug_mark+2),a  
32d0 18 03			jr .pastdmark  
32d2 ..			.dmark: db "-2v"  
32d5 f1			.pastdmark: pop af  
32d6			endm  
# End of macro DMARK
32d6						CALLMONITOR 
32d6 cd 6c fe			call debug_vector  
32d9				endm  
# End of macro CALLMONITOR
32d9					endif 
32d9			 
32d9 eb					ex de, hl 
32da ed 52				sbc hl, de 
32dc			 
32dc					if DEBUG_FORTH_WORDS 
32dc						DMARK "-2d" 
32dc f5				push af  
32dd 3a f1 32			ld a, (.dmark)  
32e0 32 68 fe			ld (debug_mark),a  
32e3 3a f2 32			ld a, (.dmark+1)  
32e6 32 69 fe			ld (debug_mark+1),a  
32e9 3a f3 32			ld a, (.dmark+2)  
32ec 32 6a fe			ld (debug_mark+2),a  
32ef 18 03			jr .pastdmark  
32f1 ..			.dmark: db "-2d"  
32f4 f1			.pastdmark: pop af  
32f5			endm  
# End of macro DMARK
32f5						CALLMONITOR 
32f5 cd 6c fe			call debug_vector  
32f8				endm  
# End of macro CALLMONITOR
32f8					endif 
32f8			 
32f8					; move result to de 
32f8			 
32f8 eb					ex de, hl 
32f9			 
32f9					; Address 
32f9			 
32f9 e1					pop hl 
32fa			 
32fa					; save it back 
32fa			 
32fa 73					ld (hl), e 
32fb 23					inc hl 
32fc 72					ld (hl), d 
32fd			 
32fd					if DEBUG_FORTH_WORDS 
32fd						DMARK "-2e" 
32fd f5				push af  
32fe 3a 12 33			ld a, (.dmark)  
3301 32 68 fe			ld (debug_mark),a  
3304 3a 13 33			ld a, (.dmark+1)  
3307 32 69 fe			ld (debug_mark+1),a  
330a 3a 14 33			ld a, (.dmark+2)  
330d 32 6a fe			ld (debug_mark+2),a  
3310 18 03			jr .pastdmark  
3312 ..			.dmark: db "-2e"  
3315 f1			.pastdmark: pop af  
3316			endm  
# End of macro DMARK
3316						CALLMONITOR 
3316 cd 6c fe			call debug_vector  
3319				endm  
# End of macro CALLMONITOR
3319					endif 
3319			 
3319			 
3319					FORTH_DSP_POP 
3319 cd aa 23			call macro_forth_dsp_pop 
331c				endm 
# End of macro FORTH_DSP_POP
331c			 
331c			 
331c			 
331c				       NEXTW 
331c c3 a8 24			jp macro_next 
331f				endm 
# End of macro NEXTW
331f			.GET2: 
331f				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
331f 6f				db WORD_SYS_CORE+91             
3320 54 33			dw .BANG2            
3322 03				db 2 + 1 
3323 .. 00			db "2@",0              
3326				endm 
# End of macro CWHEAD
3326			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3326					if DEBUG_FORTH_WORDS_KEY 
3326						DMARK "2A_" 
3326 f5				push af  
3327 3a 3b 33			ld a, (.dmark)  
332a 32 68 fe			ld (debug_mark),a  
332d 3a 3c 33			ld a, (.dmark+1)  
3330 32 69 fe			ld (debug_mark+1),a  
3333 3a 3d 33			ld a, (.dmark+2)  
3336 32 6a fe			ld (debug_mark+2),a  
3339 18 03			jr .pastdmark  
333b ..			.dmark: db "2A_"  
333e f1			.pastdmark: pop af  
333f			endm  
# End of macro DMARK
333f						CALLMONITOR 
333f cd 6c fe			call debug_vector  
3342				endm  
# End of macro CALLMONITOR
3342					endif 
3342			 
3342					FORTH_DSP_VALUEHL 
3342 cd f2 22			call macro_dsp_valuehl 
3345				endm 
# End of macro FORTH_DSP_VALUEHL
3345			 
3345 e5					push hl   ; save address 
3346			 
3346					FORTH_DSP_POP 
3346 cd aa 23			call macro_forth_dsp_pop 
3349				endm 
# End of macro FORTH_DSP_POP
3349			 
3349 e1					pop hl 
334a			 
334a 5e					ld e, (hl) 
334b 23					inc hl 
334c 56					ld d, (hl) 
334d			 
334d eb					ex de, hl 
334e			 
334e cd fb 20				call forth_push_numhl 
3351			 
3351				       NEXTW 
3351 c3 a8 24			jp macro_next 
3354				endm 
# End of macro NEXTW
3354			.BANG2: 
3354				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
3354 6f				db WORD_SYS_CORE+91             
3355 8c 33			dw .CONFIG            
3357 03				db 2 + 1 
3358 .. 00			db "2!",0              
335b				endm 
# End of macro CWHEAD
335b			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
335b					if DEBUG_FORTH_WORDS_KEY 
335b						DMARK "2S_" 
335b f5				push af  
335c 3a 70 33			ld a, (.dmark)  
335f 32 68 fe			ld (debug_mark),a  
3362 3a 71 33			ld a, (.dmark+1)  
3365 32 69 fe			ld (debug_mark+1),a  
3368 3a 72 33			ld a, (.dmark+2)  
336b 32 6a fe			ld (debug_mark+2),a  
336e 18 03			jr .pastdmark  
3370 ..			.dmark: db "2S_"  
3373 f1			.pastdmark: pop af  
3374			endm  
# End of macro DMARK
3374						CALLMONITOR 
3374 cd 6c fe			call debug_vector  
3377				endm  
# End of macro CALLMONITOR
3377					endif 
3377			 
3377					FORTH_DSP_VALUEHL 
3377 cd f2 22			call macro_dsp_valuehl 
337a				endm 
# End of macro FORTH_DSP_VALUEHL
337a			 
337a e5					push hl   ; save address 
337b			 
337b			 
337b					FORTH_DSP_POP 
337b cd aa 23			call macro_forth_dsp_pop 
337e				endm 
# End of macro FORTH_DSP_POP
337e			 
337e					 
337e					FORTH_DSP_VALUEHL 
337e cd f2 22			call macro_dsp_valuehl 
3381				endm 
# End of macro FORTH_DSP_VALUEHL
3381			 
3381					FORTH_DSP_POP 
3381 cd aa 23			call macro_forth_dsp_pop 
3384				endm 
# End of macro FORTH_DSP_POP
3384			 
3384 eb					ex de, hl    ; value now in de 
3385			 
3385 e1					pop hl 
3386			 
3386 73					ld (hl), e 
3387			 
3387 23					inc hl 
3388			 
3388 72					ld (hl), d 
3389			 
3389			 
3389				       NEXTW 
3389 c3 a8 24			jp macro_next 
338c				endm 
# End of macro NEXTW
338c			.CONFIG: 
338c				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
338c 6f				db WORD_SYS_CORE+91             
338d 9d 33			dw .ADTOS            
338f 07				db 6 + 1 
3390 .. 00			db "CONFIG",0              
3397				endm 
# End of macro CWHEAD
3397			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3397			 
3397 cd 2f 16				call config 
339a					NEXTW 
339a c3 a8 24			jp macro_next 
339d				endm 
# End of macro NEXTW
339d			 
339d			.ADTOS: 
339d				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
339d 6f				db WORD_SYS_CORE+91             
339e b3 33			dw .SBTOS            
33a0 03				db 2 + 1 
33a1 .. 00			db "1+",0              
33a4				endm 
# End of macro CWHEAD
33a4			; | 1+ ( u -- u )  Increment value on TOS | DONE 
33a4			 
33a4					FORTH_DSP_VALUEHL 
33a4 cd f2 22			call macro_dsp_valuehl 
33a7				endm 
# End of macro FORTH_DSP_VALUEHL
33a7 e5					push hl 
33a8			 
33a8					FORTH_DSP_POP 
33a8 cd aa 23			call macro_forth_dsp_pop 
33ab				endm 
# End of macro FORTH_DSP_POP
33ab e1					pop hl 
33ac			 
33ac 23					inc hl 
33ad cd fb 20				call forth_push_numhl 
33b0					 
33b0					NEXTW 
33b0 c3 a8 24			jp macro_next 
33b3				endm 
# End of macro NEXTW
33b3			.SBTOS: 
33b3				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
33b3 6f				db WORD_SYS_CORE+91             
33b4 c9 33			dw .ADSTORE            
33b6 03				db 2 + 1 
33b7 .. 00			db "1-",0              
33ba				endm 
# End of macro CWHEAD
33ba			; | 1- ( u -- u )  Decrement value on TOS | DONE 
33ba			 
33ba					FORTH_DSP_VALUEHL 
33ba cd f2 22			call macro_dsp_valuehl 
33bd				endm 
# End of macro FORTH_DSP_VALUEHL
33bd e5					push hl 
33be			 
33be					FORTH_DSP_POP 
33be cd aa 23			call macro_forth_dsp_pop 
33c1				endm 
# End of macro FORTH_DSP_POP
33c1 e1					pop hl 
33c2			 
33c2 2b					dec hl 
33c3 cd fb 20				call forth_push_numhl 
33c6					 
33c6					NEXTW 
33c6 c3 a8 24			jp macro_next 
33c9				endm 
# End of macro NEXTW
33c9			.ADSTORE: 
33c9				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
33c9 6f				db WORD_SYS_CORE+91             
33ca df 33			dw .ADWSTORE            
33cc 04				db 3 + 1 
33cd .. 00			db "1+!",0              
33d1				endm 
# End of macro CWHEAD
33d1			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
33d1			 
33d1					FORTH_DSP_VALUEHL 
33d1 cd f2 22			call macro_dsp_valuehl 
33d4				endm 
# End of macro FORTH_DSP_VALUEHL
33d4 e5					push hl 
33d5			 
33d5					FORTH_DSP_POP 
33d5 cd aa 23			call macro_forth_dsp_pop 
33d8				endm 
# End of macro FORTH_DSP_POP
33d8 e1					pop hl 
33d9			 
33d9 7e					ld a, (hl) 
33da 3c					inc a 
33db 77					ld (hl), a 
33dc					 
33dc					NEXTW 
33dc c3 a8 24			jp macro_next 
33df				endm 
# End of macro NEXTW
33df			.ADWSTORE: 
33df				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
33df 6f				db WORD_SYS_CORE+91             
33e0 fd 33			dw .SBSTORE            
33e2 05				db 4 + 1 
33e3 .. 00			db "1+2!",0              
33e8				endm 
# End of macro CWHEAD
33e8			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
33e8			 
33e8					FORTH_DSP_VALUEHL 
33e8 cd f2 22			call macro_dsp_valuehl 
33eb				endm 
# End of macro FORTH_DSP_VALUEHL
33eb e5					push hl 
33ec			 
33ec					FORTH_DSP_POP 
33ec cd aa 23			call macro_forth_dsp_pop 
33ef				endm 
# End of macro FORTH_DSP_POP
33ef e1					pop hl 
33f0			 
33f0 e5					push hl 
33f1			 
33f1 cd 2a 24				call loadwordinhl 
33f4 23					inc hl 
33f5			 
33f5 d1					pop de 
33f6 eb					ex de, hl 
33f7 73					ld (hl), e 
33f8 23					inc hl 
33f9 72					ld (hl), d 
33fa					 
33fa					NEXTW 
33fa c3 a8 24			jp macro_next 
33fd				endm 
# End of macro NEXTW
33fd			.SBSTORE: 
33fd				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
33fd 6f				db WORD_SYS_CORE+91             
33fe 13 34			dw .SBWSTORE            
3400 04				db 3 + 1 
3401 .. 00			db "1-!",0              
3405				endm 
# End of macro CWHEAD
3405			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3405			 
3405					FORTH_DSP_VALUEHL 
3405 cd f2 22			call macro_dsp_valuehl 
3408				endm 
# End of macro FORTH_DSP_VALUEHL
3408 e5					push hl 
3409			 
3409					FORTH_DSP_POP 
3409 cd aa 23			call macro_forth_dsp_pop 
340c				endm 
# End of macro FORTH_DSP_POP
340c e1					pop hl 
340d			 
340d 7e					ld a, (hl) 
340e 3d					dec a 
340f 77					ld (hl), a 
3410					 
3410					NEXTW 
3410 c3 a8 24			jp macro_next 
3413				endm 
# End of macro NEXTW
3413			.SBWSTORE: 
3413				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
3413 6f				db WORD_SYS_CORE+91             
3414 31 34			dw .ENDCORE            
3416 05				db 4 + 1 
3417 .. 00			db "1-2!",0              
341c				endm 
# End of macro CWHEAD
341c			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
341c			 
341c					FORTH_DSP_VALUEHL 
341c cd f2 22			call macro_dsp_valuehl 
341f				endm 
# End of macro FORTH_DSP_VALUEHL
341f e5					push hl 
3420			 
3420					FORTH_DSP_POP 
3420 cd aa 23			call macro_forth_dsp_pop 
3423				endm 
# End of macro FORTH_DSP_POP
3423 e1					pop hl 
3424			 
3424 e5					push hl 
3425			 
3425 cd 2a 24				call loadwordinhl 
3428 2b					dec hl 
3429			 
3429 d1					pop de 
342a eb					ex de, hl 
342b 73					ld (hl), e 
342c 23					inc hl 
342d 72					ld (hl), d 
342e					 
342e					NEXTW 
342e c3 a8 24			jp macro_next 
3431				endm 
# End of macro NEXTW
3431			.ENDCORE: 
3431			 
3431			; eof 
3431			 
3431			 
# End of file forth_words_core.asm
3431			include "forth_words_flow.asm" 
3431			 
3431			; | ## Program Flow Words 
3431			 
3431			.IF: 
3431				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3431 1e				db WORD_SYS_CORE+10             
3432 26 35			dw .THEN            
3434 03				db 2 + 1 
3435 .. 00			db "IF",0              
3438				endm 
# End of macro CWHEAD
3438			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3438			; 
3438					if DEBUG_FORTH_WORDS_KEY 
3438						DMARK "IF." 
3438 f5				push af  
3439 3a 4d 34			ld a, (.dmark)  
343c 32 68 fe			ld (debug_mark),a  
343f 3a 4e 34			ld a, (.dmark+1)  
3442 32 69 fe			ld (debug_mark+1),a  
3445 3a 4f 34			ld a, (.dmark+2)  
3448 32 6a fe			ld (debug_mark+2),a  
344b 18 03			jr .pastdmark  
344d ..			.dmark: db "IF."  
3450 f1			.pastdmark: pop af  
3451			endm  
# End of macro DMARK
3451						CALLMONITOR 
3451 cd 6c fe			call debug_vector  
3454				endm  
# End of macro CALLMONITOR
3454					endif 
3454			; eval TOS 
3454			 
3454				FORTH_DSP_VALUEHL 
3454 cd f2 22			call macro_dsp_valuehl 
3457				endm 
# End of macro FORTH_DSP_VALUEHL
3457			 
3457			;	push hl 
3457				FORTH_DSP_POP 
3457 cd aa 23			call macro_forth_dsp_pop 
345a				endm 
# End of macro FORTH_DSP_POP
345a			;	pop hl 
345a			 
345a					if DEBUG_FORTH_WORDS 
345a						DMARK "IF1" 
345a f5				push af  
345b 3a 6f 34			ld a, (.dmark)  
345e 32 68 fe			ld (debug_mark),a  
3461 3a 70 34			ld a, (.dmark+1)  
3464 32 69 fe			ld (debug_mark+1),a  
3467 3a 71 34			ld a, (.dmark+2)  
346a 32 6a fe			ld (debug_mark+2),a  
346d 18 03			jr .pastdmark  
346f ..			.dmark: db "IF1"  
3472 f1			.pastdmark: pop af  
3473			endm  
# End of macro DMARK
3473						CALLMONITOR 
3473 cd 6c fe			call debug_vector  
3476				endm  
# End of macro CALLMONITOR
3476					endif 
3476 b7				or a        ; clear carry flag 
3477 11 00 00			ld de, 0 
347a eb				ex de,hl 
347b ed 52			sbc hl, de 
347d c2 07 35			jp nz, .iftrue 
3480			 
3480					if DEBUG_FORTH_WORDS 
3480						DMARK "IF2" 
3480 f5				push af  
3481 3a 95 34			ld a, (.dmark)  
3484 32 68 fe			ld (debug_mark),a  
3487 3a 96 34			ld a, (.dmark+1)  
348a 32 69 fe			ld (debug_mark+1),a  
348d 3a 97 34			ld a, (.dmark+2)  
3490 32 6a fe			ld (debug_mark+2),a  
3493 18 03			jr .pastdmark  
3495 ..			.dmark: db "IF2"  
3498 f1			.pastdmark: pop af  
3499			endm  
# End of macro DMARK
3499						CALLMONITOR 
3499 cd 6c fe			call debug_vector  
349c				endm  
# End of macro CALLMONITOR
349c					endif 
349c			 
349c			; if not true then skip to THEN 
349c			 
349c				; TODO get tok_ptr 
349c				; TODO consume toks until we get to THEN 
349c			 
349c 2a bf f4			ld hl, (os_tok_ptr) 
349f					if DEBUG_FORTH_WORDS 
349f						DMARK "IF3" 
349f f5				push af  
34a0 3a b4 34			ld a, (.dmark)  
34a3 32 68 fe			ld (debug_mark),a  
34a6 3a b5 34			ld a, (.dmark+1)  
34a9 32 69 fe			ld (debug_mark+1),a  
34ac 3a b6 34			ld a, (.dmark+2)  
34af 32 6a fe			ld (debug_mark+2),a  
34b2 18 03			jr .pastdmark  
34b4 ..			.dmark: db "IF3"  
34b7 f1			.pastdmark: pop af  
34b8			endm  
# End of macro DMARK
34b8						CALLMONITOR 
34b8 cd 6c fe			call debug_vector  
34bb				endm  
# End of macro CALLMONITOR
34bb						 
34bb					endif 
34bb 11 02 35			ld de, .ifthen 
34be					if DEBUG_FORTH_WORDS 
34be						DMARK "IF4" 
34be f5				push af  
34bf 3a d3 34			ld a, (.dmark)  
34c2 32 68 fe			ld (debug_mark),a  
34c5 3a d4 34			ld a, (.dmark+1)  
34c8 32 69 fe			ld (debug_mark+1),a  
34cb 3a d5 34			ld a, (.dmark+2)  
34ce 32 6a fe			ld (debug_mark+2),a  
34d1 18 03			jr .pastdmark  
34d3 ..			.dmark: db "IF4"  
34d6 f1			.pastdmark: pop af  
34d7			endm  
# End of macro DMARK
34d7						CALLMONITOR 
34d7 cd 6c fe			call debug_vector  
34da				endm  
# End of macro CALLMONITOR
34da					endif 
34da cd c3 25			call findnexttok  
34dd			 
34dd					if DEBUG_FORTH_WORDS 
34dd						DMARK "IF5" 
34dd f5				push af  
34de 3a f2 34			ld a, (.dmark)  
34e1 32 68 fe			ld (debug_mark),a  
34e4 3a f3 34			ld a, (.dmark+1)  
34e7 32 69 fe			ld (debug_mark+1),a  
34ea 3a f4 34			ld a, (.dmark+2)  
34ed 32 6a fe			ld (debug_mark+2),a  
34f0 18 03			jr .pastdmark  
34f2 ..			.dmark: db "IF5"  
34f5 f1			.pastdmark: pop af  
34f6			endm  
# End of macro DMARK
34f6						CALLMONITOR 
34f6 cd 6c fe			call debug_vector  
34f9				endm  
# End of macro CALLMONITOR
34f9					endif 
34f9				; TODO replace below with ; exec using tok_ptr 
34f9 22 bf f4			ld (os_tok_ptr), hl 
34fc c3 39 25			jp exec1 
34ff				NEXTW 
34ff c3 a8 24			jp macro_next 
3502				endm 
# End of macro NEXTW
3502			 
3502 .. 00		.ifthen:  db "THEN",0 
3507			 
3507			.iftrue:		 
3507				; Exec next words normally 
3507			 
3507				; if true then exec following IF as normal 
3507					if DEBUG_FORTH_WORDS 
3507						DMARK "IFT" 
3507 f5				push af  
3508 3a 1c 35			ld a, (.dmark)  
350b 32 68 fe			ld (debug_mark),a  
350e 3a 1d 35			ld a, (.dmark+1)  
3511 32 69 fe			ld (debug_mark+1),a  
3514 3a 1e 35			ld a, (.dmark+2)  
3517 32 6a fe			ld (debug_mark+2),a  
351a 18 03			jr .pastdmark  
351c ..			.dmark: db "IFT"  
351f f1			.pastdmark: pop af  
3520			endm  
# End of macro DMARK
3520						CALLMONITOR 
3520 cd 6c fe			call debug_vector  
3523				endm  
# End of macro CALLMONITOR
3523					endif 
3523			 
3523					NEXTW 
3523 c3 a8 24			jp macro_next 
3526				endm 
# End of macro NEXTW
3526			.THEN: 
3526				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3526 1f				db WORD_SYS_CORE+11             
3527 4e 35			dw .ELSE            
3529 05				db 4 + 1 
352a .. 00			db "THEN",0              
352f				endm 
# End of macro CWHEAD
352f			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
352f					if DEBUG_FORTH_WORDS_KEY 
352f						DMARK "THN" 
352f f5				push af  
3530 3a 44 35			ld a, (.dmark)  
3533 32 68 fe			ld (debug_mark),a  
3536 3a 45 35			ld a, (.dmark+1)  
3539 32 69 fe			ld (debug_mark+1),a  
353c 3a 46 35			ld a, (.dmark+2)  
353f 32 6a fe			ld (debug_mark+2),a  
3542 18 03			jr .pastdmark  
3544 ..			.dmark: db "THN"  
3547 f1			.pastdmark: pop af  
3548			endm  
# End of macro DMARK
3548						CALLMONITOR 
3548 cd 6c fe			call debug_vector  
354b				endm  
# End of macro CALLMONITOR
354b					endif 
354b					NEXTW 
354b c3 a8 24			jp macro_next 
354e				endm 
# End of macro NEXTW
354e			.ELSE: 
354e				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
354e 20				db WORD_SYS_CORE+12             
354f 76 35			dw .DO            
3551 03				db 2 + 1 
3552 .. 00			db "ELSE",0              
3557				endm 
# End of macro CWHEAD
3557			; | ELSE ( -- ) Not supported - does nothing | TODO 
3557			 
3557					if DEBUG_FORTH_WORDS_KEY 
3557						DMARK "ELS" 
3557 f5				push af  
3558 3a 6c 35			ld a, (.dmark)  
355b 32 68 fe			ld (debug_mark),a  
355e 3a 6d 35			ld a, (.dmark+1)  
3561 32 69 fe			ld (debug_mark+1),a  
3564 3a 6e 35			ld a, (.dmark+2)  
3567 32 6a fe			ld (debug_mark+2),a  
356a 18 03			jr .pastdmark  
356c ..			.dmark: db "ELS"  
356f f1			.pastdmark: pop af  
3570			endm  
# End of macro DMARK
3570						CALLMONITOR 
3570 cd 6c fe			call debug_vector  
3573				endm  
# End of macro CALLMONITOR
3573					endif 
3573			 
3573			 
3573					NEXTW 
3573 c3 a8 24			jp macro_next 
3576				endm 
# End of macro NEXTW
3576			.DO: 
3576				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3576 21				db WORD_SYS_CORE+13             
3577 9d 36			dw .LOOP            
3579 03				db 2 + 1 
357a .. 00			db "DO",0              
357d				endm 
# End of macro CWHEAD
357d			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
357d			 
357d					if DEBUG_FORTH_WORDS_KEY 
357d						DMARK "DO." 
357d f5				push af  
357e 3a 92 35			ld a, (.dmark)  
3581 32 68 fe			ld (debug_mark),a  
3584 3a 93 35			ld a, (.dmark+1)  
3587 32 69 fe			ld (debug_mark+1),a  
358a 3a 94 35			ld a, (.dmark+2)  
358d 32 6a fe			ld (debug_mark+2),a  
3590 18 03			jr .pastdmark  
3592 ..			.dmark: db "DO."  
3595 f1			.pastdmark: pop af  
3596			endm  
# End of macro DMARK
3596						CALLMONITOR 
3596 cd 6c fe			call debug_vector  
3599				endm  
# End of macro CALLMONITOR
3599					endif 
3599			;  push pc to rsp stack past the DO 
3599			 
3599 2a bf f4				ld hl, (os_tok_ptr) 
359c 23					inc hl   ; D 
359d 23					inc hl  ; O 
359e 23					inc hl   ; null 
359f					if DEBUG_FORTH_WORDS 
359f						DMARK "DO2" 
359f f5				push af  
35a0 3a b4 35			ld a, (.dmark)  
35a3 32 68 fe			ld (debug_mark),a  
35a6 3a b5 35			ld a, (.dmark+1)  
35a9 32 69 fe			ld (debug_mark+1),a  
35ac 3a b6 35			ld a, (.dmark+2)  
35af 32 6a fe			ld (debug_mark+2),a  
35b2 18 03			jr .pastdmark  
35b4 ..			.dmark: db "DO2"  
35b7 f1			.pastdmark: pop af  
35b8			endm  
# End of macro DMARK
35b8						CALLMONITOR 
35b8 cd 6c fe			call debug_vector  
35bb				endm  
# End of macro CALLMONITOR
35bb					endif 
35bb					FORTH_RSP_NEXT 
35bb cd a2 20			call macro_forth_rsp_next 
35be				endm 
# End of macro FORTH_RSP_NEXT
35be					if DEBUG_FORTH_WORDS 
35be						DMARK "DO3" 
35be f5				push af  
35bf 3a d3 35			ld a, (.dmark)  
35c2 32 68 fe			ld (debug_mark),a  
35c5 3a d4 35			ld a, (.dmark+1)  
35c8 32 69 fe			ld (debug_mark+1),a  
35cb 3a d5 35			ld a, (.dmark+2)  
35ce 32 6a fe			ld (debug_mark+2),a  
35d1 18 03			jr .pastdmark  
35d3 ..			.dmark: db "DO3"  
35d6 f1			.pastdmark: pop af  
35d7			endm  
# End of macro DMARK
35d7						CALLMONITOR 
35d7 cd 6c fe			call debug_vector  
35da				endm  
# End of macro CALLMONITOR
35da					endif 
35da			 
35da					;if DEBUG_FORTH_WORDS 
35da				;		push hl 
35da			;		endif  
35da			 
35da			; get counters from data stack 
35da			 
35da			 
35da					FORTH_DSP_VALUEHL 
35da cd f2 22			call macro_dsp_valuehl 
35dd				endm 
# End of macro FORTH_DSP_VALUEHL
35dd e5					push hl		 ; hl now has starting counter which needs to be tos 
35de			 
35de					if DEBUG_FORTH_WORDS 
35de						DMARK "DO4" 
35de f5				push af  
35df 3a f3 35			ld a, (.dmark)  
35e2 32 68 fe			ld (debug_mark),a  
35e5 3a f4 35			ld a, (.dmark+1)  
35e8 32 69 fe			ld (debug_mark+1),a  
35eb 3a f5 35			ld a, (.dmark+2)  
35ee 32 6a fe			ld (debug_mark+2),a  
35f1 18 03			jr .pastdmark  
35f3 ..			.dmark: db "DO4"  
35f6 f1			.pastdmark: pop af  
35f7			endm  
# End of macro DMARK
35f7						CALLMONITOR 
35f7 cd 6c fe			call debug_vector  
35fa				endm  
# End of macro CALLMONITOR
35fa					endif 
35fa					FORTH_DSP_POP 
35fa cd aa 23			call macro_forth_dsp_pop 
35fd				endm 
# End of macro FORTH_DSP_POP
35fd			 
35fd					if DEBUG_FORTH_WORDS 
35fd						DMARK "DO5" 
35fd f5				push af  
35fe 3a 12 36			ld a, (.dmark)  
3601 32 68 fe			ld (debug_mark),a  
3604 3a 13 36			ld a, (.dmark+1)  
3607 32 69 fe			ld (debug_mark+1),a  
360a 3a 14 36			ld a, (.dmark+2)  
360d 32 6a fe			ld (debug_mark+2),a  
3610 18 03			jr .pastdmark  
3612 ..			.dmark: db "DO5"  
3615 f1			.pastdmark: pop af  
3616			endm  
# End of macro DMARK
3616						CALLMONITOR 
3616 cd 6c fe			call debug_vector  
3619				endm  
# End of macro CALLMONITOR
3619					endif 
3619			 
3619					FORTH_DSP_VALUEHL 
3619 cd f2 22			call macro_dsp_valuehl 
361c				endm 
# End of macro FORTH_DSP_VALUEHL
361c			;		push hl		 ; hl now has starting limit counter 
361c			 
361c					if DEBUG_FORTH_WORDS 
361c						DMARK "DO6" 
361c f5				push af  
361d 3a 31 36			ld a, (.dmark)  
3620 32 68 fe			ld (debug_mark),a  
3623 3a 32 36			ld a, (.dmark+1)  
3626 32 69 fe			ld (debug_mark+1),a  
3629 3a 33 36			ld a, (.dmark+2)  
362c 32 6a fe			ld (debug_mark+2),a  
362f 18 03			jr .pastdmark  
3631 ..			.dmark: db "DO6"  
3634 f1			.pastdmark: pop af  
3635			endm  
# End of macro DMARK
3635						CALLMONITOR 
3635 cd 6c fe			call debug_vector  
3638				endm  
# End of macro CALLMONITOR
3638					endif 
3638					FORTH_DSP_POP 
3638 cd aa 23			call macro_forth_dsp_pop 
363b				endm 
# End of macro FORTH_DSP_POP
363b			 
363b			; put counters on the loop stack 
363b			 
363b			;		pop hl			 ; limit counter 
363b d1					pop de			; start counter 
363c			 
363c					; push limit counter 
363c			 
363c					if DEBUG_FORTH_WORDS 
363c						DMARK "DO7" 
363c f5				push af  
363d 3a 51 36			ld a, (.dmark)  
3640 32 68 fe			ld (debug_mark),a  
3643 3a 52 36			ld a, (.dmark+1)  
3646 32 69 fe			ld (debug_mark+1),a  
3649 3a 53 36			ld a, (.dmark+2)  
364c 32 6a fe			ld (debug_mark+2),a  
364f 18 03			jr .pastdmark  
3651 ..			.dmark: db "DO7"  
3654 f1			.pastdmark: pop af  
3655			endm  
# End of macro DMARK
3655						CALLMONITOR 
3655 cd 6c fe			call debug_vector  
3658				endm  
# End of macro CALLMONITOR
3658					endif 
3658					FORTH_LOOP_NEXT 
3658 cd 23 23			call macro_forth_loop_next 
365b				endm 
# End of macro FORTH_LOOP_NEXT
365b			 
365b					; push start counter 
365b			 
365b eb					ex de, hl 
365c					if DEBUG_FORTH_WORDS 
365c						DMARK "DO7" 
365c f5				push af  
365d 3a 71 36			ld a, (.dmark)  
3660 32 68 fe			ld (debug_mark),a  
3663 3a 72 36			ld a, (.dmark+1)  
3666 32 69 fe			ld (debug_mark+1),a  
3669 3a 73 36			ld a, (.dmark+2)  
366c 32 6a fe			ld (debug_mark+2),a  
366f 18 03			jr .pastdmark  
3671 ..			.dmark: db "DO7"  
3674 f1			.pastdmark: pop af  
3675			endm  
# End of macro DMARK
3675						CALLMONITOR 
3675 cd 6c fe			call debug_vector  
3678				endm  
# End of macro CALLMONITOR
3678					endif 
3678					FORTH_LOOP_NEXT 
3678 cd 23 23			call macro_forth_loop_next 
367b				endm 
# End of macro FORTH_LOOP_NEXT
367b			 
367b			 
367b					; init first round of I counter 
367b			 
367b 22 e3 f4				ld (os_current_i), hl 
367e			 
367e					if DEBUG_FORTH_WORDS 
367e						DMARK "DO8" 
367e f5				push af  
367f 3a 93 36			ld a, (.dmark)  
3682 32 68 fe			ld (debug_mark),a  
3685 3a 94 36			ld a, (.dmark+1)  
3688 32 69 fe			ld (debug_mark+1),a  
368b 3a 95 36			ld a, (.dmark+2)  
368e 32 6a fe			ld (debug_mark+2),a  
3691 18 03			jr .pastdmark  
3693 ..			.dmark: db "DO8"  
3696 f1			.pastdmark: pop af  
3697			endm  
# End of macro DMARK
3697						CALLMONITOR 
3697 cd 6c fe			call debug_vector  
369a				endm  
# End of macro CALLMONITOR
369a					endif 
369a			 
369a					NEXTW 
369a c3 a8 24			jp macro_next 
369d				endm 
# End of macro NEXTW
369d			.LOOP: 
369d				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
369d 22				db WORD_SYS_CORE+14             
369e b5 37			dw .I            
36a0 05				db 4 + 1 
36a1 .. 00			db "LOOP",0              
36a6				endm 
# End of macro CWHEAD
36a6			; | LOOP ( -- ) Increment and test loop counter  | DONE 
36a6			 
36a6				; pop tos as current loop count to hl 
36a6			 
36a6				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36a6			 
36a6				FORTH_LOOP_TOS 
36a6 cd 56 23			call macro_forth_loop_tos 
36a9				endm 
# End of macro FORTH_LOOP_TOS
36a9 e5				push hl 
36aa			 
36aa					if DEBUG_FORTH_WORDS_KEY 
36aa						DMARK "LOP" 
36aa f5				push af  
36ab 3a bf 36			ld a, (.dmark)  
36ae 32 68 fe			ld (debug_mark),a  
36b1 3a c0 36			ld a, (.dmark+1)  
36b4 32 69 fe			ld (debug_mark+1),a  
36b7 3a c1 36			ld a, (.dmark+2)  
36ba 32 6a fe			ld (debug_mark+2),a  
36bd 18 03			jr .pastdmark  
36bf ..			.dmark: db "LOP"  
36c2 f1			.pastdmark: pop af  
36c3			endm  
# End of macro DMARK
36c3						CALLMONITOR 
36c3 cd 6c fe			call debug_vector  
36c6				endm  
# End of macro CALLMONITOR
36c6					endif 
36c6				; next item on the stack is the limit. get it 
36c6			 
36c6			 
36c6				FORTH_LOOP_POP 
36c6 cd 60 23			call macro_forth_loop_pop 
36c9				endm 
# End of macro FORTH_LOOP_POP
36c9			 
36c9				FORTH_LOOP_TOS 
36c9 cd 56 23			call macro_forth_loop_tos 
36cc				endm 
# End of macro FORTH_LOOP_TOS
36cc			 
36cc d1				pop de		 ; de = i, hl = limit 
36cd			 
36cd					if DEBUG_FORTH_WORDS 
36cd						DMARK "LP1" 
36cd f5				push af  
36ce 3a e2 36			ld a, (.dmark)  
36d1 32 68 fe			ld (debug_mark),a  
36d4 3a e3 36			ld a, (.dmark+1)  
36d7 32 69 fe			ld (debug_mark+1),a  
36da 3a e4 36			ld a, (.dmark+2)  
36dd 32 6a fe			ld (debug_mark+2),a  
36e0 18 03			jr .pastdmark  
36e2 ..			.dmark: db "LP1"  
36e5 f1			.pastdmark: pop af  
36e6			endm  
# End of macro DMARK
36e6						CALLMONITOR 
36e6 cd 6c fe			call debug_vector  
36e9				endm  
# End of macro CALLMONITOR
36e9					endif 
36e9			 
36e9				; go back to previous word 
36e9			 
36e9 d5				push de    ; save I for inc later 
36ea			 
36ea			 
36ea				; get limit 
36ea				;  is I at limit? 
36ea			 
36ea			 
36ea					if DEBUG_FORTH_WORDS 
36ea						DMARK "LP1" 
36ea f5				push af  
36eb 3a ff 36			ld a, (.dmark)  
36ee 32 68 fe			ld (debug_mark),a  
36f1 3a 00 37			ld a, (.dmark+1)  
36f4 32 69 fe			ld (debug_mark+1),a  
36f7 3a 01 37			ld a, (.dmark+2)  
36fa 32 6a fe			ld (debug_mark+2),a  
36fd 18 03			jr .pastdmark  
36ff ..			.dmark: db "LP1"  
3702 f1			.pastdmark: pop af  
3703			endm  
# End of macro DMARK
3703						CALLMONITOR 
3703 cd 6c fe			call debug_vector  
3706				endm  
# End of macro CALLMONITOR
3706					endif 
3706			 
3706 ed 52			sbc hl, de 
3708			 
3708			 
3708				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3708			 
3708 20 26				jr nz, .loopnotdone 
370a			 
370a e1				pop hl   ; get rid of saved I 
370b				FORTH_LOOP_POP     ; get rid of limit 
370b cd 60 23			call macro_forth_loop_pop 
370e				endm 
# End of macro FORTH_LOOP_POP
370e			 
370e				FORTH_RSP_POP     ; get rid of DO ptr 
370e cd c3 20			call macro_forth_rsp_pop 
3711				endm 
# End of macro FORTH_RSP_POP
3711			 
3711			if DEBUG_FORTH_WORDS 
3711						DMARK "LP>" 
3711 f5				push af  
3712 3a 26 37			ld a, (.dmark)  
3715 32 68 fe			ld (debug_mark),a  
3718 3a 27 37			ld a, (.dmark+1)  
371b 32 69 fe			ld (debug_mark+1),a  
371e 3a 28 37			ld a, (.dmark+2)  
3721 32 6a fe			ld (debug_mark+2),a  
3724 18 03			jr .pastdmark  
3726 ..			.dmark: db "LP>"  
3729 f1			.pastdmark: pop af  
372a			endm  
# End of macro DMARK
372a				CALLMONITOR 
372a cd 6c fe			call debug_vector  
372d				endm  
# End of macro CALLMONITOR
372d			endif 
372d			 
372d					NEXTW 
372d c3 a8 24			jp macro_next 
3730				endm 
# End of macro NEXTW
3730				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3730			 
3730			.loopnotdone: 
3730			 
3730 e1				pop hl    ; get I 
3731 23				inc hl 
3732			 
3732			   	; save new I 
3732			 
3732			 
3732					; set I counter 
3732			 
3732 22 e3 f4				ld (os_current_i), hl 
3735			 
3735					if DEBUG_FORTH_WORDS 
3735						DMARK "LPN" 
3735 f5				push af  
3736 3a 4a 37			ld a, (.dmark)  
3739 32 68 fe			ld (debug_mark),a  
373c 3a 4b 37			ld a, (.dmark+1)  
373f 32 69 fe			ld (debug_mark+1),a  
3742 3a 4c 37			ld a, (.dmark+2)  
3745 32 6a fe			ld (debug_mark+2),a  
3748 18 03			jr .pastdmark  
374a ..			.dmark: db "LPN"  
374d f1			.pastdmark: pop af  
374e			endm  
# End of macro DMARK
374e					CALLMONITOR 
374e cd 6c fe			call debug_vector  
3751				endm  
# End of macro CALLMONITOR
3751					endif 
3751					 
3751				FORTH_LOOP_NEXT 
3751 cd 23 23			call macro_forth_loop_next 
3754				endm 
# End of macro FORTH_LOOP_NEXT
3754			 
3754			 
3754					if DEBUG_FORTH_WORDS 
3754 eb						ex de,hl 
3755					endif 
3755			 
3755			;	; get DO ptr 
3755			; 
3755					if DEBUG_FORTH_WORDS 
3755						DMARK "LP7" 
3755 f5				push af  
3756 3a 6a 37			ld a, (.dmark)  
3759 32 68 fe			ld (debug_mark),a  
375c 3a 6b 37			ld a, (.dmark+1)  
375f 32 69 fe			ld (debug_mark+1),a  
3762 3a 6c 37			ld a, (.dmark+2)  
3765 32 6a fe			ld (debug_mark+2),a  
3768 18 03			jr .pastdmark  
376a ..			.dmark: db "LP7"  
376d f1			.pastdmark: pop af  
376e			endm  
# End of macro DMARK
376e					CALLMONITOR 
376e cd 6c fe			call debug_vector  
3771				endm  
# End of macro CALLMONITOR
3771					endif 
3771				FORTH_RSP_TOS 
3771 cd b9 20			call macro_forth_rsp_tos 
3774				endm 
# End of macro FORTH_RSP_TOS
3774			 
3774					if DEBUG_FORTH_WORDS 
3774						DMARK "LP8" 
3774 f5				push af  
3775 3a 89 37			ld a, (.dmark)  
3778 32 68 fe			ld (debug_mark),a  
377b 3a 8a 37			ld a, (.dmark+1)  
377e 32 69 fe			ld (debug_mark+1),a  
3781 3a 8b 37			ld a, (.dmark+2)  
3784 32 6a fe			ld (debug_mark+2),a  
3787 18 03			jr .pastdmark  
3789 ..			.dmark: db "LP8"  
378c f1			.pastdmark: pop af  
378d			endm  
# End of macro DMARK
378d					CALLMONITOR 
378d cd 6c fe			call debug_vector  
3790				endm  
# End of macro CALLMONITOR
3790					endif 
3790				;push hl 
3790			 
3790				; not going to DO any more 
3790				; get rid of the RSP pointer as DO will add it back in 
3790				;FORTH_RSP_POP 
3790				;pop hl 
3790			 
3790				;ld hl,(cli_ret_sp) 
3790				;ld e, (hl) 
3790				;inc hl 
3790				;ld d, (hl) 
3790				;ex de,hl 
3790 22 bf f4			ld (os_tok_ptr), hl 
3793					if DEBUG_FORTH_WORDS 
3793						DMARK "LP<" 
3793 f5				push af  
3794 3a a8 37			ld a, (.dmark)  
3797 32 68 fe			ld (debug_mark),a  
379a 3a a9 37			ld a, (.dmark+1)  
379d 32 69 fe			ld (debug_mark+1),a  
37a0 3a aa 37			ld a, (.dmark+2)  
37a3 32 6a fe			ld (debug_mark+2),a  
37a6 18 03			jr .pastdmark  
37a8 ..			.dmark: db "LP<"  
37ab f1			.pastdmark: pop af  
37ac			endm  
# End of macro DMARK
37ac					CALLMONITOR 
37ac cd 6c fe			call debug_vector  
37af				endm  
# End of macro CALLMONITOR
37af				endif 
37af c3 39 25			jp exec1 
37b2			 
37b2					 
37b2			 
37b2			 
37b2					NEXTW 
37b2 c3 a8 24			jp macro_next 
37b5				endm 
# End of macro NEXTW
37b5			.I:  
37b5			 
37b5				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
37b5 5e				db WORD_SYS_CORE+74             
37b6 e0 37			dw .DLOOP            
37b8 02				db 1 + 1 
37b9 .. 00			db "I",0              
37bb				endm 
# End of macro CWHEAD
37bb			; | I ( -- ) Current loop counter | DONE 
37bb					if DEBUG_FORTH_WORDS_KEY 
37bb						DMARK "I.." 
37bb f5				push af  
37bc 3a d0 37			ld a, (.dmark)  
37bf 32 68 fe			ld (debug_mark),a  
37c2 3a d1 37			ld a, (.dmark+1)  
37c5 32 69 fe			ld (debug_mark+1),a  
37c8 3a d2 37			ld a, (.dmark+2)  
37cb 32 6a fe			ld (debug_mark+2),a  
37ce 18 03			jr .pastdmark  
37d0 ..			.dmark: db "I.."  
37d3 f1			.pastdmark: pop af  
37d4			endm  
# End of macro DMARK
37d4						CALLMONITOR 
37d4 cd 6c fe			call debug_vector  
37d7				endm  
# End of macro CALLMONITOR
37d7					endif 
37d7			 
37d7 2a e3 f4				ld hl,(os_current_i) 
37da cd fb 20				call forth_push_numhl 
37dd			 
37dd					NEXTW 
37dd c3 a8 24			jp macro_next 
37e0				endm 
# End of macro NEXTW
37e0			.DLOOP: 
37e0				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
37e0 5f				db WORD_SYS_CORE+75             
37e1 c1 38			dw .REPEAT            
37e3 06				db 5 + 1 
37e4 .. 00			db "-LOOP",0              
37ea				endm 
# End of macro CWHEAD
37ea			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
37ea				; pop tos as current loop count to hl 
37ea					if DEBUG_FORTH_WORDS_KEY 
37ea						DMARK "-LP" 
37ea f5				push af  
37eb 3a ff 37			ld a, (.dmark)  
37ee 32 68 fe			ld (debug_mark),a  
37f1 3a 00 38			ld a, (.dmark+1)  
37f4 32 69 fe			ld (debug_mark+1),a  
37f7 3a 01 38			ld a, (.dmark+2)  
37fa 32 6a fe			ld (debug_mark+2),a  
37fd 18 03			jr .pastdmark  
37ff ..			.dmark: db "-LP"  
3802 f1			.pastdmark: pop af  
3803			endm  
# End of macro DMARK
3803						CALLMONITOR 
3803 cd 6c fe			call debug_vector  
3806				endm  
# End of macro CALLMONITOR
3806					endif 
3806			 
3806				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3806			 
3806				FORTH_LOOP_TOS 
3806 cd 56 23			call macro_forth_loop_tos 
3809				endm 
# End of macro FORTH_LOOP_TOS
3809 e5				push hl 
380a			 
380a					if DEBUG_FORTH_WORDS 
380a						DMARK "-LP" 
380a f5				push af  
380b 3a 1f 38			ld a, (.dmark)  
380e 32 68 fe			ld (debug_mark),a  
3811 3a 20 38			ld a, (.dmark+1)  
3814 32 69 fe			ld (debug_mark+1),a  
3817 3a 21 38			ld a, (.dmark+2)  
381a 32 6a fe			ld (debug_mark+2),a  
381d 18 03			jr .pastdmark  
381f ..			.dmark: db "-LP"  
3822 f1			.pastdmark: pop af  
3823			endm  
# End of macro DMARK
3823						CALLMONITOR 
3823 cd 6c fe			call debug_vector  
3826				endm  
# End of macro CALLMONITOR
3826					endif 
3826				; next item on the stack is the limit. get it 
3826			 
3826			 
3826				FORTH_LOOP_POP 
3826 cd 60 23			call macro_forth_loop_pop 
3829				endm 
# End of macro FORTH_LOOP_POP
3829			 
3829				FORTH_LOOP_TOS 
3829 cd 56 23			call macro_forth_loop_tos 
382c				endm 
# End of macro FORTH_LOOP_TOS
382c			 
382c d1				pop de		 ; de = i, hl = limit 
382d			 
382d					if DEBUG_FORTH_WORDS 
382d						DMARK "-L1" 
382d f5				push af  
382e 3a 42 38			ld a, (.dmark)  
3831 32 68 fe			ld (debug_mark),a  
3834 3a 43 38			ld a, (.dmark+1)  
3837 32 69 fe			ld (debug_mark+1),a  
383a 3a 44 38			ld a, (.dmark+2)  
383d 32 6a fe			ld (debug_mark+2),a  
3840 18 03			jr .pastdmark  
3842 ..			.dmark: db "-L1"  
3845 f1			.pastdmark: pop af  
3846			endm  
# End of macro DMARK
3846						CALLMONITOR 
3846 cd 6c fe			call debug_vector  
3849				endm  
# End of macro CALLMONITOR
3849					endif 
3849			 
3849				; go back to previous word 
3849			 
3849 d5				push de    ; save I for inc later 
384a			 
384a			 
384a				; get limit 
384a				;  is I at limit? 
384a			 
384a			 
384a					if DEBUG_FORTH_WORDS 
384a						DMARK "-L1" 
384a f5				push af  
384b 3a 5f 38			ld a, (.dmark)  
384e 32 68 fe			ld (debug_mark),a  
3851 3a 60 38			ld a, (.dmark+1)  
3854 32 69 fe			ld (debug_mark+1),a  
3857 3a 61 38			ld a, (.dmark+2)  
385a 32 6a fe			ld (debug_mark+2),a  
385d 18 03			jr .pastdmark  
385f ..			.dmark: db "-L1"  
3862 f1			.pastdmark: pop af  
3863			endm  
# End of macro DMARK
3863						CALLMONITOR 
3863 cd 6c fe			call debug_vector  
3866				endm  
# End of macro CALLMONITOR
3866					endif 
3866			 
3866 ed 52			sbc hl, de 
3868			 
3868			 
3868				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3868			 
3868 20 26				jr nz, .mloopnotdone 
386a			 
386a e1				pop hl   ; get rid of saved I 
386b				FORTH_LOOP_POP     ; get rid of limit 
386b cd 60 23			call macro_forth_loop_pop 
386e				endm 
# End of macro FORTH_LOOP_POP
386e			 
386e				FORTH_RSP_POP     ; get rid of DO ptr 
386e cd c3 20			call macro_forth_rsp_pop 
3871				endm 
# End of macro FORTH_RSP_POP
3871			 
3871			if DEBUG_FORTH_WORDS 
3871						DMARK "-L>" 
3871 f5				push af  
3872 3a 86 38			ld a, (.dmark)  
3875 32 68 fe			ld (debug_mark),a  
3878 3a 87 38			ld a, (.dmark+1)  
387b 32 69 fe			ld (debug_mark+1),a  
387e 3a 88 38			ld a, (.dmark+2)  
3881 32 6a fe			ld (debug_mark+2),a  
3884 18 03			jr .pastdmark  
3886 ..			.dmark: db "-L>"  
3889 f1			.pastdmark: pop af  
388a			endm  
# End of macro DMARK
388a				CALLMONITOR 
388a cd 6c fe			call debug_vector  
388d				endm  
# End of macro CALLMONITOR
388d			endif 
388d			 
388d					NEXTW 
388d c3 a8 24			jp macro_next 
3890				endm 
# End of macro NEXTW
3890				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3890			 
3890			.mloopnotdone: 
3890			 
3890 e1				pop hl    ; get I 
3891 2b				dec hl 
3892			 
3892			   	; save new I 
3892			 
3892			 
3892					; set I counter 
3892			 
3892 22 e3 f4				ld (os_current_i), hl 
3895			 
3895					 
3895				FORTH_LOOP_NEXT 
3895 cd 23 23			call macro_forth_loop_next 
3898				endm 
# End of macro FORTH_LOOP_NEXT
3898			 
3898			 
3898					if DEBUG_FORTH_WORDS 
3898 eb						ex de,hl 
3899					endif 
3899			 
3899			;	; get DO ptr 
3899			; 
3899				FORTH_RSP_TOS 
3899 cd b9 20			call macro_forth_rsp_tos 
389c				endm 
# End of macro FORTH_RSP_TOS
389c			 
389c				;push hl 
389c			 
389c				; not going to DO any more 
389c				; get rid of the RSP pointer as DO will add it back in 
389c				;FORTH_RSP_POP 
389c				;pop hl 
389c			 
389c			 
389c 22 bf f4			ld (os_tok_ptr), hl 
389f					if DEBUG_FORTH_WORDS 
389f						DMARK "-L<" 
389f f5				push af  
38a0 3a b4 38			ld a, (.dmark)  
38a3 32 68 fe			ld (debug_mark),a  
38a6 3a b5 38			ld a, (.dmark+1)  
38a9 32 69 fe			ld (debug_mark+1),a  
38ac 3a b6 38			ld a, (.dmark+2)  
38af 32 6a fe			ld (debug_mark+2),a  
38b2 18 03			jr .pastdmark  
38b4 ..			.dmark: db "-L<"  
38b7 f1			.pastdmark: pop af  
38b8			endm  
# End of macro DMARK
38b8					CALLMONITOR 
38b8 cd 6c fe			call debug_vector  
38bb				endm  
# End of macro CALLMONITOR
38bb				endif 
38bb c3 39 25			jp exec1 
38be			 
38be					 
38be			 
38be			 
38be			 
38be				NEXTW 
38be c3 a8 24			jp macro_next 
38c1				endm 
# End of macro NEXTW
38c1			 
38c1			 
38c1			 
38c1			 
38c1			.REPEAT: 
38c1				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
38c1 71				db WORD_SYS_CORE+93             
38c2 14 39			dw .UNTIL            
38c4 06				db 5 + 1 
38c5 .. 00			db "REPEAT",0              
38cc				endm 
# End of macro CWHEAD
38cc			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
38cc			;  push pc to rsp stack past the REPEAT 
38cc					if DEBUG_FORTH_WORDS_KEY 
38cc						DMARK "REP" 
38cc f5				push af  
38cd 3a e1 38			ld a, (.dmark)  
38d0 32 68 fe			ld (debug_mark),a  
38d3 3a e2 38			ld a, (.dmark+1)  
38d6 32 69 fe			ld (debug_mark+1),a  
38d9 3a e3 38			ld a, (.dmark+2)  
38dc 32 6a fe			ld (debug_mark+2),a  
38df 18 03			jr .pastdmark  
38e1 ..			.dmark: db "REP"  
38e4 f1			.pastdmark: pop af  
38e5			endm  
# End of macro DMARK
38e5						CALLMONITOR 
38e5 cd 6c fe			call debug_vector  
38e8				endm  
# End of macro CALLMONITOR
38e8					endif 
38e8			 
38e8 2a bf f4				ld hl, (os_tok_ptr) 
38eb 23					inc hl   ; R 
38ec 23					inc hl  ; E 
38ed 23					inc hl   ; P 
38ee 23					inc hl   ; E 
38ef 23					inc hl   ; A 
38f0 23					inc hl   ; T 
38f1 23					inc hl   ; zero 
38f2					FORTH_RSP_NEXT 
38f2 cd a2 20			call macro_forth_rsp_next 
38f5				endm 
# End of macro FORTH_RSP_NEXT
38f5			 
38f5			 
38f5					if DEBUG_FORTH_WORDS 
38f5						DMARK "REP" 
38f5 f5				push af  
38f6 3a 0a 39			ld a, (.dmark)  
38f9 32 68 fe			ld (debug_mark),a  
38fc 3a 0b 39			ld a, (.dmark+1)  
38ff 32 69 fe			ld (debug_mark+1),a  
3902 3a 0c 39			ld a, (.dmark+2)  
3905 32 6a fe			ld (debug_mark+2),a  
3908 18 03			jr .pastdmark  
390a ..			.dmark: db "REP"  
390d f1			.pastdmark: pop af  
390e			endm  
# End of macro DMARK
390e						;pop bc    ; TODO BUG ?????? what is this for???? 
390e						CALLMONITOR 
390e cd 6c fe			call debug_vector  
3911				endm  
# End of macro CALLMONITOR
3911					endif 
3911			 
3911					NEXTW 
3911 c3 a8 24			jp macro_next 
3914				endm 
# End of macro NEXTW
3914			;	       NEXTW 
3914			 
3914			.UNTIL: 
3914				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3914 72				db WORD_SYS_CORE+94             
3915 ab 39			dw .ENDFLOW            
3917 06				db 5 + 1 
3918 .. 00			db "UNTIL",0              
391e				endm 
# End of macro CWHEAD
391e			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
391e			 
391e				; pop tos as check 
391e			 
391e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
391e			 
391e				FORTH_DSP_VALUEHL 
391e cd f2 22			call macro_dsp_valuehl 
3921				endm 
# End of macro FORTH_DSP_VALUEHL
3921			 
3921					if DEBUG_FORTH_WORDS_KEY 
3921						DMARK "UNT" 
3921 f5				push af  
3922 3a 36 39			ld a, (.dmark)  
3925 32 68 fe			ld (debug_mark),a  
3928 3a 37 39			ld a, (.dmark+1)  
392b 32 69 fe			ld (debug_mark+1),a  
392e 3a 38 39			ld a, (.dmark+2)  
3931 32 6a fe			ld (debug_mark+2),a  
3934 18 03			jr .pastdmark  
3936 ..			.dmark: db "UNT"  
3939 f1			.pastdmark: pop af  
393a			endm  
# End of macro DMARK
393a						CALLMONITOR 
393a cd 6c fe			call debug_vector  
393d				endm  
# End of macro CALLMONITOR
393d					endif 
393d			 
393d			;	push hl 
393d				FORTH_DSP_POP 
393d cd aa 23			call macro_forth_dsp_pop 
3940				endm 
# End of macro FORTH_DSP_POP
3940			 
3940			;	pop hl 
3940			 
3940				; test if true 
3940			 
3940 cd f8 0f			call ishlzero 
3943			;	ld a,l 
3943			;	add h 
3943			; 
3943			;	cp 0 
3943			 
3943 20 3e			jr nz, .untilnotdone 
3945			 
3945					if DEBUG_FORTH_WORDS 
3945						DMARK "UNf" 
3945 f5				push af  
3946 3a 5a 39			ld a, (.dmark)  
3949 32 68 fe			ld (debug_mark),a  
394c 3a 5b 39			ld a, (.dmark+1)  
394f 32 69 fe			ld (debug_mark+1),a  
3952 3a 5c 39			ld a, (.dmark+2)  
3955 32 6a fe			ld (debug_mark+2),a  
3958 18 03			jr .pastdmark  
395a ..			.dmark: db "UNf"  
395d f1			.pastdmark: pop af  
395e			endm  
# End of macro DMARK
395e						CALLMONITOR 
395e cd 6c fe			call debug_vector  
3961				endm  
# End of macro CALLMONITOR
3961					endif 
3961			 
3961			 
3961			 
3961				FORTH_RSP_POP     ; get rid of DO ptr 
3961 cd c3 20			call macro_forth_rsp_pop 
3964				endm 
# End of macro FORTH_RSP_POP
3964			 
3964			if DEBUG_FORTH_WORDS 
3964						DMARK "UN>" 
3964 f5				push af  
3965 3a 79 39			ld a, (.dmark)  
3968 32 68 fe			ld (debug_mark),a  
396b 3a 7a 39			ld a, (.dmark+1)  
396e 32 69 fe			ld (debug_mark+1),a  
3971 3a 7b 39			ld a, (.dmark+2)  
3974 32 6a fe			ld (debug_mark+2),a  
3977 18 03			jr .pastdmark  
3979 ..			.dmark: db "UN>"  
397c f1			.pastdmark: pop af  
397d			endm  
# End of macro DMARK
397d				CALLMONITOR 
397d cd 6c fe			call debug_vector  
3980				endm  
# End of macro CALLMONITOR
3980			endif 
3980			 
3980					NEXTW 
3980 c3 a8 24			jp macro_next 
3983				endm 
# End of macro NEXTW
3983				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3983			 
3983			.untilnotdone: 
3983			 
3983			 
3983			;	; get DO ptr 
3983			; 
3983				FORTH_RSP_TOS 
3983 cd b9 20			call macro_forth_rsp_tos 
3986				endm 
# End of macro FORTH_RSP_TOS
3986			 
3986				;push hl 
3986			 
3986				; not going to DO any more 
3986				; get rid of the RSP pointer as DO will add it back in 
3986				;FORTH_RSP_POP 
3986				;pop hl 
3986			 
3986			 
3986 22 bf f4			ld (os_tok_ptr), hl 
3989					if DEBUG_FORTH_WORDS 
3989						DMARK "UN<" 
3989 f5				push af  
398a 3a 9e 39			ld a, (.dmark)  
398d 32 68 fe			ld (debug_mark),a  
3990 3a 9f 39			ld a, (.dmark+1)  
3993 32 69 fe			ld (debug_mark+1),a  
3996 3a a0 39			ld a, (.dmark+2)  
3999 32 6a fe			ld (debug_mark+2),a  
399c 18 03			jr .pastdmark  
399e ..			.dmark: db "UN<"  
39a1 f1			.pastdmark: pop af  
39a2			endm  
# End of macro DMARK
39a2					CALLMONITOR 
39a2 cd 6c fe			call debug_vector  
39a5				endm  
# End of macro CALLMONITOR
39a5				endif 
39a5 c3 39 25			jp exec1 
39a8			 
39a8					 
39a8			 
39a8			 
39a8					NEXTW 
39a8 c3 a8 24			jp macro_next 
39ab				endm 
# End of macro NEXTW
39ab			 
39ab			 
39ab			.ENDFLOW: 
39ab			 
39ab			; eof 
39ab			 
# End of file forth_words_flow.asm
39ab			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
39ab			include "forth_words_logic.asm" 
39ab			 
39ab			; | ## Logic Words 
39ab			 
39ab			.NOT: 
39ab				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
39ab 2d				db WORD_SYS_CORE+25             
39ac f3 39			dw .IS            
39ae 04				db 3 + 1 
39af .. 00			db "NOT",0              
39b3				endm 
# End of macro CWHEAD
39b3			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
39b3					if DEBUG_FORTH_WORDS_KEY 
39b3						DMARK "NOT" 
39b3 f5				push af  
39b4 3a c8 39			ld a, (.dmark)  
39b7 32 68 fe			ld (debug_mark),a  
39ba 3a c9 39			ld a, (.dmark+1)  
39bd 32 69 fe			ld (debug_mark+1),a  
39c0 3a ca 39			ld a, (.dmark+2)  
39c3 32 6a fe			ld (debug_mark+2),a  
39c6 18 03			jr .pastdmark  
39c8 ..			.dmark: db "NOT"  
39cb f1			.pastdmark: pop af  
39cc			endm  
# End of macro DMARK
39cc						CALLMONITOR 
39cc cd 6c fe			call debug_vector  
39cf				endm  
# End of macro CALLMONITOR
39cf					endif 
39cf					FORTH_DSP 
39cf cd b8 22			call macro_forth_dsp 
39d2				endm 
# End of macro FORTH_DSP
39d2 7e					ld a,(hl)	; get type of value on TOS 
39d3 fe 02				cp DS_TYPE_INUM  
39d5 28 03				jr z, .noti 
39d7					NEXTW 
39d7 c3 a8 24			jp macro_next 
39da				endm 
# End of macro NEXTW
39da			.noti:          FORTH_DSP_VALUEHL 
39da cd f2 22			call macro_dsp_valuehl 
39dd				endm 
# End of macro FORTH_DSP_VALUEHL
39dd			;		push hl 
39dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39dd cd aa 23			call macro_forth_dsp_pop 
39e0				endm 
# End of macro FORTH_DSP_POP
39e0			;		pop hl 
39e0 3e 00				ld a,0 
39e2 bd					cp l 
39e3 28 04				jr z, .not2t 
39e5 2e 00				ld l, 0 
39e7 18 02				jr .notip 
39e9			 
39e9 2e ff		.not2t:		ld l, 255 
39eb			 
39eb 26 00		.notip:		ld h, 0	 
39ed			 
39ed cd fb 20				call forth_push_numhl 
39f0					NEXTW 
39f0 c3 a8 24			jp macro_next 
39f3				endm 
# End of macro NEXTW
39f3			 
39f3			.IS: 
39f3				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
39f3 2d				db WORD_SYS_CORE+25             
39f4 19 3a			dw .LZERO            
39f6 03				db 2 + 1 
39f7 .. 00			db "IS",0              
39fa				endm 
# End of macro CWHEAD
39fa			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
39fa					if DEBUG_FORTH_WORDS_KEY 
39fa						DMARK "IS." 
39fa f5				push af  
39fb 3a 0f 3a			ld a, (.dmark)  
39fe 32 68 fe			ld (debug_mark),a  
3a01 3a 10 3a			ld a, (.dmark+1)  
3a04 32 69 fe			ld (debug_mark+1),a  
3a07 3a 11 3a			ld a, (.dmark+2)  
3a0a 32 6a fe			ld (debug_mark+2),a  
3a0d 18 03			jr .pastdmark  
3a0f ..			.dmark: db "IS."  
3a12 f1			.pastdmark: pop af  
3a13			endm  
# End of macro DMARK
3a13						CALLMONITOR 
3a13 cd 6c fe			call debug_vector  
3a16				endm  
# End of macro CALLMONITOR
3a16					endif 
3a16					NEXTW 
3a16 c3 a8 24			jp macro_next 
3a19				endm 
# End of macro NEXTW
3a19			.LZERO: 
3a19				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3a19 2d				db WORD_SYS_CORE+25             
3a1a 23 3a			dw .TZERO            
3a1c 03				db 2 + 1 
3a1d .. 00			db "0<",0              
3a20				endm 
# End of macro CWHEAD
3a20			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3a20					NEXTW 
3a20 c3 a8 24			jp macro_next 
3a23				endm 
# End of macro NEXTW
3a23			.TZERO: 
3a23				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3a23 2e				db WORD_SYS_CORE+26             
3a24 6a 3a			dw .LESS            
3a26 03				db 2 + 1 
3a27 .. 00			db "0=",0              
3a2a				endm 
# End of macro CWHEAD
3a2a			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3a2a				; TODO add floating point number detection 
3a2a					;v5 FORTH_DSP_VALUE 
3a2a					if DEBUG_FORTH_WORDS_KEY 
3a2a						DMARK "0=." 
3a2a f5				push af  
3a2b 3a 3f 3a			ld a, (.dmark)  
3a2e 32 68 fe			ld (debug_mark),a  
3a31 3a 40 3a			ld a, (.dmark+1)  
3a34 32 69 fe			ld (debug_mark+1),a  
3a37 3a 41 3a			ld a, (.dmark+2)  
3a3a 32 6a fe			ld (debug_mark+2),a  
3a3d 18 03			jr .pastdmark  
3a3f ..			.dmark: db "0=."  
3a42 f1			.pastdmark: pop af  
3a43			endm  
# End of macro DMARK
3a43						CALLMONITOR 
3a43 cd 6c fe			call debug_vector  
3a46				endm  
# End of macro CALLMONITOR
3a46					endif 
3a46					FORTH_DSP 
3a46 cd b8 22			call macro_forth_dsp 
3a49				endm 
# End of macro FORTH_DSP
3a49 7e					ld a,(hl)	; get type of value on TOS 
3a4a fe 02				cp DS_TYPE_INUM  
3a4c 28 00				jr z, .tz_inum 
3a4e			 
3a4e				if FORTH_ENABLE_FLOATMATH 
3a4e					jr .tz_done 
3a4e			 
3a4e				endif 
3a4e					 
3a4e			 
3a4e			.tz_inum: 
3a4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a4e cd f2 22			call macro_dsp_valuehl 
3a51				endm 
# End of macro FORTH_DSP_VALUEHL
3a51			 
3a51			;		push hl 
3a51			 
3a51					; destroy value TOS 
3a51			 
3a51					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a51 cd aa 23			call macro_forth_dsp_pop 
3a54				endm 
# End of macro FORTH_DSP_POP
3a54			 
3a54			;		pop hl 
3a54			 
3a54 3e 00				ld a,0 
3a56			 
3a56 bd					cp l 
3a57 20 08				jr nz, .tz_notzero 
3a59			 
3a59 bc					cp h 
3a5a			 
3a5a 20 05				jr nz, .tz_notzero 
3a5c			 
3a5c			 
3a5c 21 01 00				ld hl, FORTH_TRUE 
3a5f 18 03				jr .tz_done 
3a61			 
3a61 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3a64			 
3a64					; push value back onto stack for another op etc 
3a64			 
3a64			.tz_done: 
3a64 cd fb 20				call forth_push_numhl 
3a67			 
3a67					NEXTW 
3a67 c3 a8 24			jp macro_next 
3a6a				endm 
# End of macro NEXTW
3a6a			.LESS: 
3a6a				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3a6a 2f				db WORD_SYS_CORE+27             
3a6b d3 3a			dw .GT            
3a6d 02				db 1 + 1 
3a6e .. 00			db "<",0              
3a70				endm 
# End of macro CWHEAD
3a70			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3a70				; TODO add floating point number detection 
3a70					if DEBUG_FORTH_WORDS_KEY 
3a70						DMARK "LES" 
3a70 f5				push af  
3a71 3a 85 3a			ld a, (.dmark)  
3a74 32 68 fe			ld (debug_mark),a  
3a77 3a 86 3a			ld a, (.dmark+1)  
3a7a 32 69 fe			ld (debug_mark+1),a  
3a7d 3a 87 3a			ld a, (.dmark+2)  
3a80 32 6a fe			ld (debug_mark+2),a  
3a83 18 03			jr .pastdmark  
3a85 ..			.dmark: db "LES"  
3a88 f1			.pastdmark: pop af  
3a89			endm  
# End of macro DMARK
3a89						CALLMONITOR 
3a89 cd 6c fe			call debug_vector  
3a8c				endm  
# End of macro CALLMONITOR
3a8c					endif 
3a8c					FORTH_DSP 
3a8c cd b8 22			call macro_forth_dsp 
3a8f				endm 
# End of macro FORTH_DSP
3a8f					;v5 FORTH_DSP_VALUE 
3a8f 7e					ld a,(hl)	; get type of value on TOS 
3a90 fe 02				cp DS_TYPE_INUM  
3a92 28 00				jr z, .less_inum 
3a94			 
3a94				if FORTH_ENABLE_FLOATMATH 
3a94					jr .less_done 
3a94			 
3a94				endif 
3a94					 
3a94			 
3a94			.less_inum: 
3a94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a94 cd f2 22			call macro_dsp_valuehl 
3a97				endm 
# End of macro FORTH_DSP_VALUEHL
3a97			 
3a97 e5					push hl  ; u2 
3a98			 
3a98					; destroy value TOS 
3a98			 
3a98					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a98 cd aa 23			call macro_forth_dsp_pop 
3a9b				endm 
# End of macro FORTH_DSP_POP
3a9b			 
3a9b			 
3a9b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a9b cd f2 22			call macro_dsp_valuehl 
3a9e				endm 
# End of macro FORTH_DSP_VALUEHL
3a9e			 
3a9e e5					push hl    ; u1 
3a9f			 
3a9f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9f cd aa 23			call macro_forth_dsp_pop 
3aa2				endm 
# End of macro FORTH_DSP_POP
3aa2			 
3aa2			 
3aa2 b7			 or a      ;clear carry flag 
3aa3 01 00 00		 ld bc, FORTH_FALSE 
3aa6 e1			  pop hl    ; u1 
3aa7 d1			  pop de    ; u2 
3aa8 ed 52		  sbc hl,de 
3aaa 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3aac			 
3aac 01 01 00		 ld bc, FORTH_TRUE 
3aaf			.lscont:  
3aaf c5					push bc 
3ab0 e1					pop hl 
3ab1			 
3ab1					if DEBUG_FORTH_WORDS 
3ab1						DMARK "LT1" 
3ab1 f5				push af  
3ab2 3a c6 3a			ld a, (.dmark)  
3ab5 32 68 fe			ld (debug_mark),a  
3ab8 3a c7 3a			ld a, (.dmark+1)  
3abb 32 69 fe			ld (debug_mark+1),a  
3abe 3a c8 3a			ld a, (.dmark+2)  
3ac1 32 6a fe			ld (debug_mark+2),a  
3ac4 18 03			jr .pastdmark  
3ac6 ..			.dmark: db "LT1"  
3ac9 f1			.pastdmark: pop af  
3aca			endm  
# End of macro DMARK
3aca						CALLMONITOR 
3aca cd 6c fe			call debug_vector  
3acd				endm  
# End of macro CALLMONITOR
3acd					endif 
3acd cd fb 20				call forth_push_numhl 
3ad0			 
3ad0					NEXTW 
3ad0 c3 a8 24			jp macro_next 
3ad3				endm 
# End of macro NEXTW
3ad3			.GT: 
3ad3				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3ad3 30				db WORD_SYS_CORE+28             
3ad4 3c 3b			dw .EQUAL            
3ad6 02				db 1 + 1 
3ad7 .. 00			db ">",0              
3ad9				endm 
# End of macro CWHEAD
3ad9			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3ad9				; TODO add floating point number detection 
3ad9					if DEBUG_FORTH_WORDS_KEY 
3ad9						DMARK "GRT" 
3ad9 f5				push af  
3ada 3a ee 3a			ld a, (.dmark)  
3add 32 68 fe			ld (debug_mark),a  
3ae0 3a ef 3a			ld a, (.dmark+1)  
3ae3 32 69 fe			ld (debug_mark+1),a  
3ae6 3a f0 3a			ld a, (.dmark+2)  
3ae9 32 6a fe			ld (debug_mark+2),a  
3aec 18 03			jr .pastdmark  
3aee ..			.dmark: db "GRT"  
3af1 f1			.pastdmark: pop af  
3af2			endm  
# End of macro DMARK
3af2						CALLMONITOR 
3af2 cd 6c fe			call debug_vector  
3af5				endm  
# End of macro CALLMONITOR
3af5					endif 
3af5					FORTH_DSP 
3af5 cd b8 22			call macro_forth_dsp 
3af8				endm 
# End of macro FORTH_DSP
3af8					;FORTH_DSP_VALUE 
3af8 7e					ld a,(hl)	; get type of value on TOS 
3af9 fe 02				cp DS_TYPE_INUM  
3afb 28 00				jr z, .gt_inum 
3afd			 
3afd				if FORTH_ENABLE_FLOATMATH 
3afd					jr .gt_done 
3afd			 
3afd				endif 
3afd					 
3afd			 
3afd			.gt_inum: 
3afd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3afd cd f2 22			call macro_dsp_valuehl 
3b00				endm 
# End of macro FORTH_DSP_VALUEHL
3b00			 
3b00 e5					push hl  ; u2 
3b01			 
3b01					; destroy value TOS 
3b01			 
3b01					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b01 cd aa 23			call macro_forth_dsp_pop 
3b04				endm 
# End of macro FORTH_DSP_POP
3b04			 
3b04			 
3b04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b04 cd f2 22			call macro_dsp_valuehl 
3b07				endm 
# End of macro FORTH_DSP_VALUEHL
3b07			 
3b07 e5					push hl    ; u1 
3b08			 
3b08					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b08 cd aa 23			call macro_forth_dsp_pop 
3b0b				endm 
# End of macro FORTH_DSP_POP
3b0b			 
3b0b			 
3b0b b7			 or a      ;clear carry flag 
3b0c 01 00 00		 ld bc, FORTH_FALSE 
3b0f e1			  pop hl    ; u1 
3b10 d1			  pop de    ; u2 
3b11 ed 52		  sbc hl,de 
3b13 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3b15			 
3b15 01 01 00		 ld bc, FORTH_TRUE 
3b18			.gtcont:  
3b18 c5					push bc 
3b19 e1					pop hl 
3b1a			 
3b1a					if DEBUG_FORTH_WORDS 
3b1a						DMARK "GT1" 
3b1a f5				push af  
3b1b 3a 2f 3b			ld a, (.dmark)  
3b1e 32 68 fe			ld (debug_mark),a  
3b21 3a 30 3b			ld a, (.dmark+1)  
3b24 32 69 fe			ld (debug_mark+1),a  
3b27 3a 31 3b			ld a, (.dmark+2)  
3b2a 32 6a fe			ld (debug_mark+2),a  
3b2d 18 03			jr .pastdmark  
3b2f ..			.dmark: db "GT1"  
3b32 f1			.pastdmark: pop af  
3b33			endm  
# End of macro DMARK
3b33						CALLMONITOR 
3b33 cd 6c fe			call debug_vector  
3b36				endm  
# End of macro CALLMONITOR
3b36					endif 
3b36 cd fb 20				call forth_push_numhl 
3b39			 
3b39					NEXTW 
3b39 c3 a8 24			jp macro_next 
3b3c				endm 
# End of macro NEXTW
3b3c			.EQUAL: 
3b3c				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3b3c 31				db WORD_SYS_CORE+29             
3b3d a7 3b			dw .ENDLOGIC            
3b3f 02				db 1 + 1 
3b40 .. 00			db "=",0              
3b42				endm 
# End of macro CWHEAD
3b42			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3b42				; TODO add floating point number detection 
3b42					if DEBUG_FORTH_WORDS_KEY 
3b42						DMARK "EQ." 
3b42 f5				push af  
3b43 3a 57 3b			ld a, (.dmark)  
3b46 32 68 fe			ld (debug_mark),a  
3b49 3a 58 3b			ld a, (.dmark+1)  
3b4c 32 69 fe			ld (debug_mark+1),a  
3b4f 3a 59 3b			ld a, (.dmark+2)  
3b52 32 6a fe			ld (debug_mark+2),a  
3b55 18 03			jr .pastdmark  
3b57 ..			.dmark: db "EQ."  
3b5a f1			.pastdmark: pop af  
3b5b			endm  
# End of macro DMARK
3b5b						CALLMONITOR 
3b5b cd 6c fe			call debug_vector  
3b5e				endm  
# End of macro CALLMONITOR
3b5e					endif 
3b5e					FORTH_DSP 
3b5e cd b8 22			call macro_forth_dsp 
3b61				endm 
# End of macro FORTH_DSP
3b61					;v5 FORTH_DSP_VALUE 
3b61 7e					ld a,(hl)	; get type of value on TOS 
3b62 fe 02				cp DS_TYPE_INUM  
3b64 28 00				jr z, .eq_inum 
3b66			 
3b66				if FORTH_ENABLE_FLOATMATH 
3b66					jr .eq_done 
3b66			 
3b66				endif 
3b66					 
3b66			 
3b66			.eq_inum: 
3b66					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b66 cd f2 22			call macro_dsp_valuehl 
3b69				endm 
# End of macro FORTH_DSP_VALUEHL
3b69			 
3b69 e5					push hl 
3b6a			 
3b6a					; destroy value TOS 
3b6a			 
3b6a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b6a cd aa 23			call macro_forth_dsp_pop 
3b6d				endm 
# End of macro FORTH_DSP_POP
3b6d			 
3b6d			 
3b6d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b6d cd f2 22			call macro_dsp_valuehl 
3b70				endm 
# End of macro FORTH_DSP_VALUEHL
3b70			 
3b70					; one value on hl get other one back 
3b70			 
3b70 e5					push hl 
3b71			 
3b71					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b71 cd aa 23			call macro_forth_dsp_pop 
3b74				endm 
# End of macro FORTH_DSP_POP
3b74			 
3b74 0e 00				ld c, FORTH_FALSE 
3b76			 
3b76 e1					pop hl 
3b77 d1					pop de 
3b78			 
3b78 7b					ld a, e 
3b79 bd					cp l 
3b7a			 
3b7a 20 06				jr nz, .eq_done 
3b7c			 
3b7c 7a					ld a, d 
3b7d bc					cp h 
3b7e			 
3b7e 20 02				jr nz, .eq_done 
3b80			 
3b80 0e 01				ld c, FORTH_TRUE 
3b82					 
3b82			 
3b82			 
3b82			.eq_done: 
3b82			 
3b82					; TODO push value back onto stack for another op etc 
3b82			 
3b82 26 00				ld h, 0 
3b84 69					ld l, c 
3b85					if DEBUG_FORTH_WORDS 
3b85						DMARK "EQ1" 
3b85 f5				push af  
3b86 3a 9a 3b			ld a, (.dmark)  
3b89 32 68 fe			ld (debug_mark),a  
3b8c 3a 9b 3b			ld a, (.dmark+1)  
3b8f 32 69 fe			ld (debug_mark+1),a  
3b92 3a 9c 3b			ld a, (.dmark+2)  
3b95 32 6a fe			ld (debug_mark+2),a  
3b98 18 03			jr .pastdmark  
3b9a ..			.dmark: db "EQ1"  
3b9d f1			.pastdmark: pop af  
3b9e			endm  
# End of macro DMARK
3b9e						CALLMONITOR 
3b9e cd 6c fe			call debug_vector  
3ba1				endm  
# End of macro CALLMONITOR
3ba1					endif 
3ba1 cd fb 20				call forth_push_numhl 
3ba4			 
3ba4					NEXTW 
3ba4 c3 a8 24			jp macro_next 
3ba7				endm 
# End of macro NEXTW
3ba7			 
3ba7			 
3ba7			.ENDLOGIC: 
3ba7			; eof 
3ba7			 
3ba7			 
# End of file forth_words_logic.asm
3ba7			include "forth_words_maths.asm" 
3ba7			 
3ba7			; | ## Maths Words 
3ba7			 
3ba7			.PLUS:	 
3ba7				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3ba7 15				db WORD_SYS_CORE+1             
3ba8 05 3c			dw .NEG            
3baa 02				db 1 + 1 
3bab .. 00			db "+",0              
3bad				endm 
# End of macro CWHEAD
3bad			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3bad					if DEBUG_FORTH_WORDS_KEY 
3bad						DMARK "PLU" 
3bad f5				push af  
3bae 3a c2 3b			ld a, (.dmark)  
3bb1 32 68 fe			ld (debug_mark),a  
3bb4 3a c3 3b			ld a, (.dmark+1)  
3bb7 32 69 fe			ld (debug_mark+1),a  
3bba 3a c4 3b			ld a, (.dmark+2)  
3bbd 32 6a fe			ld (debug_mark+2),a  
3bc0 18 03			jr .pastdmark  
3bc2 ..			.dmark: db "PLU"  
3bc5 f1			.pastdmark: pop af  
3bc6			endm  
# End of macro DMARK
3bc6						CALLMONITOR 
3bc6 cd 6c fe			call debug_vector  
3bc9				endm  
# End of macro CALLMONITOR
3bc9					endif 
3bc9					; add top two values and push back result 
3bc9			 
3bc9					;for v5 FORTH_DSP_VALUE 
3bc9					FORTH_DSP 
3bc9 cd b8 22			call macro_forth_dsp 
3bcc				endm 
# End of macro FORTH_DSP
3bcc 7e					ld a,(hl)	; get type of value on TOS 
3bcd fe 02				cp DS_TYPE_INUM  
3bcf 28 03				jr z, .dot_inum 
3bd1			 
3bd1					NEXTW 
3bd1 c3 a8 24			jp macro_next 
3bd4				endm 
# End of macro NEXTW
3bd4			 
3bd4			; float maths 
3bd4			 
3bd4				if FORTH_ENABLE_FLOATMATH 
3bd4						inc hl      ; now at start of numeric as string 
3bd4			 
3bd4					if DEBUG_FORTH_MATHS 
3bd4						DMARK "ADD" 
3bd4				CALLMONITOR 
3bd4					endif 
3bd4			 
3bd4					;ld ix, hl 
3bd4					call CON 
3bd4			 
3bd4			 
3bd4					push hl 
3bd4					 
3bd4					 
3bd4			 
3bd4						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3bd4			 
3bd4					; get next number 
3bd4			 
3bd4						FORTH_DSP_VALUE 
3bd4			 
3bd4						inc hl      ; now at start of numeric as string 
3bd4			 
3bd4					;ld ix, hl 
3bd4					call CON 
3bd4			 
3bd4					push hl 
3bd4			 
3bd4			 
3bd4						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bd4			 
3bd4						; TODO do add 
3bd4			 
3bd4						call IADD 
3bd4			 
3bd4						; TODO get result back as ascii 
3bd4			 
3bd4						; TODO push result  
3bd4			 
3bd4			 
3bd4			 
3bd4						jr .dot_done 
3bd4				endif 
3bd4			 
3bd4			.dot_inum: 
3bd4			 
3bd4			 
3bd4					if DEBUG_FORTH_DOT 
3bd4						DMARK "+IT" 
3bd4 f5				push af  
3bd5 3a e9 3b			ld a, (.dmark)  
3bd8 32 68 fe			ld (debug_mark),a  
3bdb 3a ea 3b			ld a, (.dmark+1)  
3bde 32 69 fe			ld (debug_mark+1),a  
3be1 3a eb 3b			ld a, (.dmark+2)  
3be4 32 6a fe			ld (debug_mark+2),a  
3be7 18 03			jr .pastdmark  
3be9 ..			.dmark: db "+IT"  
3bec f1			.pastdmark: pop af  
3bed			endm  
# End of macro DMARK
3bed				CALLMONITOR 
3bed cd 6c fe			call debug_vector  
3bf0				endm  
# End of macro CALLMONITOR
3bf0					endif 
3bf0			 
3bf0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bf0 cd f2 22			call macro_dsp_valuehl 
3bf3				endm 
# End of macro FORTH_DSP_VALUEHL
3bf3			 
3bf3				; TODO add floating point number detection 
3bf3			 
3bf3 e5					push hl 
3bf4			 
3bf4					; destroy value TOS 
3bf4			 
3bf4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bf4 cd aa 23			call macro_forth_dsp_pop 
3bf7				endm 
# End of macro FORTH_DSP_POP
3bf7			 
3bf7			 
3bf7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bf7 cd f2 22			call macro_dsp_valuehl 
3bfa				endm 
# End of macro FORTH_DSP_VALUEHL
3bfa			 
3bfa					; one value on hl get other one back 
3bfa			 
3bfa d1					pop de 
3bfb			 
3bfb					; do the add 
3bfb			 
3bfb 19					add hl,de 
3bfc			 
3bfc					; save it 
3bfc			 
3bfc			;		push hl	 
3bfc			 
3bfc					; 
3bfc			 
3bfc					; destroy value TOS 
3bfc			 
3bfc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bfc cd aa 23			call macro_forth_dsp_pop 
3bff				endm 
# End of macro FORTH_DSP_POP
3bff			 
3bff					; TODO push value back onto stack for another op etc 
3bff			 
3bff			;		pop hl 
3bff			 
3bff			.dot_done: 
3bff cd fb 20				call forth_push_numhl 
3c02			 
3c02					NEXTW 
3c02 c3 a8 24			jp macro_next 
3c05				endm 
# End of macro NEXTW
3c05			.NEG: 
3c05			 
3c05				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3c05 17				db WORD_SYS_CORE+3             
3c06 48 3c			dw .DIV            
3c08 02				db 1 + 1 
3c09 .. 00			db "-",0              
3c0b				endm 
# End of macro CWHEAD
3c0b			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3c0b					if DEBUG_FORTH_WORDS_KEY 
3c0b						DMARK "SUB" 
3c0b f5				push af  
3c0c 3a 20 3c			ld a, (.dmark)  
3c0f 32 68 fe			ld (debug_mark),a  
3c12 3a 21 3c			ld a, (.dmark+1)  
3c15 32 69 fe			ld (debug_mark+1),a  
3c18 3a 22 3c			ld a, (.dmark+2)  
3c1b 32 6a fe			ld (debug_mark+2),a  
3c1e 18 03			jr .pastdmark  
3c20 ..			.dmark: db "SUB"  
3c23 f1			.pastdmark: pop af  
3c24			endm  
# End of macro DMARK
3c24						CALLMONITOR 
3c24 cd 6c fe			call debug_vector  
3c27				endm  
# End of macro CALLMONITOR
3c27					endif 
3c27			 
3c27			 
3c27				; TODO add floating point number detection 
3c27					; v5 FORTH_DSP_VALUE 
3c27					FORTH_DSP 
3c27 cd b8 22			call macro_forth_dsp 
3c2a				endm 
# End of macro FORTH_DSP
3c2a 7e					ld a,(hl)	; get type of value on TOS 
3c2b fe 02				cp DS_TYPE_INUM  
3c2d 28 03				jr z, .neg_inum 
3c2f			 
3c2f					NEXTW 
3c2f c3 a8 24			jp macro_next 
3c32				endm 
# End of macro NEXTW
3c32			 
3c32			; float maths 
3c32			 
3c32				if FORTH_ENABLE_FLOATMATH 
3c32					jr .neg_done 
3c32			 
3c32				endif 
3c32					 
3c32			 
3c32			.neg_inum: 
3c32					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c32 cd f2 22			call macro_dsp_valuehl 
3c35				endm 
# End of macro FORTH_DSP_VALUEHL
3c35			 
3c35 e5					push hl 
3c36			 
3c36					; destroy value TOS 
3c36			 
3c36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c36 cd aa 23			call macro_forth_dsp_pop 
3c39				endm 
# End of macro FORTH_DSP_POP
3c39			 
3c39			 
3c39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c39 cd f2 22			call macro_dsp_valuehl 
3c3c				endm 
# End of macro FORTH_DSP_VALUEHL
3c3c			 
3c3c					; one value on hl get other one back 
3c3c			 
3c3c d1					pop de 
3c3d			 
3c3d					; do the sub 
3c3d			;		ex de, hl 
3c3d			 
3c3d ed 52				sbc hl,de 
3c3f			 
3c3f					; save it 
3c3f			 
3c3f			;		push hl	 
3c3f			 
3c3f					; 
3c3f			 
3c3f					; destroy value TOS 
3c3f			 
3c3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c3f cd aa 23			call macro_forth_dsp_pop 
3c42				endm 
# End of macro FORTH_DSP_POP
3c42			 
3c42					; TODO push value back onto stack for another op etc 
3c42			 
3c42			;		pop hl 
3c42			 
3c42 cd fb 20				call forth_push_numhl 
3c45			.neg_done: 
3c45			 
3c45					NEXTW 
3c45 c3 a8 24			jp macro_next 
3c48				endm 
# End of macro NEXTW
3c48			.DIV: 
3c48				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3c48 18				db WORD_SYS_CORE+4             
3c49 95 3c			dw .MUL            
3c4b 02				db 1 + 1 
3c4c .. 00			db "/",0              
3c4e				endm 
# End of macro CWHEAD
3c4e			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3c4e					if DEBUG_FORTH_WORDS_KEY 
3c4e						DMARK "DIV" 
3c4e f5				push af  
3c4f 3a 63 3c			ld a, (.dmark)  
3c52 32 68 fe			ld (debug_mark),a  
3c55 3a 64 3c			ld a, (.dmark+1)  
3c58 32 69 fe			ld (debug_mark+1),a  
3c5b 3a 65 3c			ld a, (.dmark+2)  
3c5e 32 6a fe			ld (debug_mark+2),a  
3c61 18 03			jr .pastdmark  
3c63 ..			.dmark: db "DIV"  
3c66 f1			.pastdmark: pop af  
3c67			endm  
# End of macro DMARK
3c67						CALLMONITOR 
3c67 cd 6c fe			call debug_vector  
3c6a				endm  
# End of macro CALLMONITOR
3c6a					endif 
3c6a				; TODO add floating point number detection 
3c6a					; v5 FORTH_DSP_VALUE 
3c6a					FORTH_DSP 
3c6a cd b8 22			call macro_forth_dsp 
3c6d				endm 
# End of macro FORTH_DSP
3c6d 7e					ld a,(hl)	; get type of value on TOS 
3c6e fe 02				cp DS_TYPE_INUM  
3c70 28 03				jr z, .div_inum 
3c72			 
3c72				if FORTH_ENABLE_FLOATMATH 
3c72					jr .div_done 
3c72			 
3c72				endif 
3c72					NEXTW 
3c72 c3 a8 24			jp macro_next 
3c75				endm 
# End of macro NEXTW
3c75			.div_inum: 
3c75			 
3c75					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c75 cd f2 22			call macro_dsp_valuehl 
3c78				endm 
# End of macro FORTH_DSP_VALUEHL
3c78			 
3c78 e5					push hl    ; to go to bc 
3c79			 
3c79					; destroy value TOS 
3c79			 
3c79					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c79 cd aa 23			call macro_forth_dsp_pop 
3c7c				endm 
# End of macro FORTH_DSP_POP
3c7c			 
3c7c			 
3c7c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c7c cd f2 22			call macro_dsp_valuehl 
3c7f				endm 
# End of macro FORTH_DSP_VALUEHL
3c7f			 
3c7f					; hl to go to de 
3c7f			 
3c7f e5					push hl 
3c80			 
3c80 c1					pop bc 
3c81 d1					pop de		 
3c82			 
3c82			 
3c82					if DEBUG_FORTH_MATHS 
3c82						DMARK "DIV" 
3c82				CALLMONITOR 
3c82					endif 
3c82					; one value on hl but move to a get other one back 
3c82			 
3c82			        
3c82 cd 2c 0f			call Div16 
3c85			 
3c85			;	push af	 
3c85 e5				push hl 
3c86 c5				push bc 
3c87			 
3c87					if DEBUG_FORTH_MATHS 
3c87						DMARK "DI1" 
3c87				CALLMONITOR 
3c87					endif 
3c87			 
3c87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c87 cd aa 23			call macro_forth_dsp_pop 
3c8a				endm 
# End of macro FORTH_DSP_POP
3c8a			 
3c8a			 
3c8a			 
3c8a e1					pop hl    ; result 
3c8b			 
3c8b cd fb 20				call forth_push_numhl 
3c8e			 
3c8e e1					pop hl    ; reminder 
3c8f			;		ld h,0 
3c8f			;		ld l,d 
3c8f			 
3c8f cd fb 20				call forth_push_numhl 
3c92			.div_done: 
3c92					NEXTW 
3c92 c3 a8 24			jp macro_next 
3c95				endm 
# End of macro NEXTW
3c95			.MUL: 
3c95				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3c95 19				db WORD_SYS_CORE+5             
3c96 da 3c			dw .MIN            
3c98 02				db 1 + 1 
3c99 .. 00			db "*",0              
3c9b				endm 
# End of macro CWHEAD
3c9b			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3c9b				; TODO add floating point number detection 
3c9b					if DEBUG_FORTH_WORDS_KEY 
3c9b						DMARK "MUL" 
3c9b f5				push af  
3c9c 3a b0 3c			ld a, (.dmark)  
3c9f 32 68 fe			ld (debug_mark),a  
3ca2 3a b1 3c			ld a, (.dmark+1)  
3ca5 32 69 fe			ld (debug_mark+1),a  
3ca8 3a b2 3c			ld a, (.dmark+2)  
3cab 32 6a fe			ld (debug_mark+2),a  
3cae 18 03			jr .pastdmark  
3cb0 ..			.dmark: db "MUL"  
3cb3 f1			.pastdmark: pop af  
3cb4			endm  
# End of macro DMARK
3cb4						CALLMONITOR 
3cb4 cd 6c fe			call debug_vector  
3cb7				endm  
# End of macro CALLMONITOR
3cb7					endif 
3cb7					FORTH_DSP 
3cb7 cd b8 22			call macro_forth_dsp 
3cba				endm 
# End of macro FORTH_DSP
3cba					; v5 FORTH_DSP_VALUE 
3cba 7e					ld a,(hl)	; get type of value on TOS 
3cbb fe 02				cp DS_TYPE_INUM  
3cbd 28 03				jr z, .mul_inum 
3cbf			 
3cbf				if FORTH_ENABLE_FLOATMATH 
3cbf					jr .mul_done 
3cbf			 
3cbf				endif 
3cbf			 
3cbf					NEXTW 
3cbf c3 a8 24			jp macro_next 
3cc2				endm 
# End of macro NEXTW
3cc2			.mul_inum:	 
3cc2			 
3cc2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cc2 cd f2 22			call macro_dsp_valuehl 
3cc5				endm 
# End of macro FORTH_DSP_VALUEHL
3cc5			 
3cc5 e5					push hl 
3cc6			 
3cc6					; destroy value TOS 
3cc6			 
3cc6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cc6 cd aa 23			call macro_forth_dsp_pop 
3cc9				endm 
# End of macro FORTH_DSP_POP
3cc9			 
3cc9			 
3cc9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cc9 cd f2 22			call macro_dsp_valuehl 
3ccc				endm 
# End of macro FORTH_DSP_VALUEHL
3ccc			 
3ccc					; one value on hl but move to a get other one back 
3ccc			 
3ccc 7d					ld a, l 
3ccd			 
3ccd d1					pop de 
3cce			 
3cce					; do the mull 
3cce			;		ex de, hl 
3cce			 
3cce cd 52 0f				call Mult16 
3cd1					; save it 
3cd1			 
3cd1			;		push hl	 
3cd1			 
3cd1					; 
3cd1			 
3cd1					; destroy value TOS 
3cd1			 
3cd1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd1 cd aa 23			call macro_forth_dsp_pop 
3cd4				endm 
# End of macro FORTH_DSP_POP
3cd4			 
3cd4					; TODO push value back onto stack for another op etc 
3cd4			 
3cd4			;		pop hl 
3cd4			 
3cd4 cd fb 20				call forth_push_numhl 
3cd7			 
3cd7			.mul_done: 
3cd7					NEXTW 
3cd7 c3 a8 24			jp macro_next 
3cda				endm 
# End of macro NEXTW
3cda			 
3cda			 
3cda			 
3cda			 
3cda			.MIN: 
3cda				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3cda 49				db WORD_SYS_CORE+53             
3cdb 5b 3d			dw .MAX            
3cdd 04				db 3 + 1 
3cde .. 00			db "MIN",0              
3ce2				endm 
# End of macro CWHEAD
3ce2			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3ce2					if DEBUG_FORTH_WORDS_KEY 
3ce2						DMARK "MIN" 
3ce2 f5				push af  
3ce3 3a f7 3c			ld a, (.dmark)  
3ce6 32 68 fe			ld (debug_mark),a  
3ce9 3a f8 3c			ld a, (.dmark+1)  
3cec 32 69 fe			ld (debug_mark+1),a  
3cef 3a f9 3c			ld a, (.dmark+2)  
3cf2 32 6a fe			ld (debug_mark+2),a  
3cf5 18 03			jr .pastdmark  
3cf7 ..			.dmark: db "MIN"  
3cfa f1			.pastdmark: pop af  
3cfb			endm  
# End of macro DMARK
3cfb						CALLMONITOR 
3cfb cd 6c fe			call debug_vector  
3cfe				endm  
# End of macro CALLMONITOR
3cfe					endif 
3cfe					; get u2 
3cfe			 
3cfe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cfe cd f2 22			call macro_dsp_valuehl 
3d01				endm 
# End of macro FORTH_DSP_VALUEHL
3d01			 
3d01 e5					push hl   ; u2 
3d02			 
3d02					; destroy value TOS 
3d02			 
3d02					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d02 cd aa 23			call macro_forth_dsp_pop 
3d05				endm 
# End of macro FORTH_DSP_POP
3d05			 
3d05					; get u1 
3d05			 
3d05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d05 cd f2 22			call macro_dsp_valuehl 
3d08				endm 
# End of macro FORTH_DSP_VALUEHL
3d08			 
3d08 e5					push hl  ; u1 
3d09			 
3d09					; destroy value TOS 
3d09			 
3d09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d09 cd aa 23			call macro_forth_dsp_pop 
3d0c				endm 
# End of macro FORTH_DSP_POP
3d0c			 
3d0c b7			 or a      ;clear carry flag 
3d0d e1			  pop hl    ; u1 
3d0e d1			  pop de    ; u2 
3d0f e5				push hl   ; saved in case hl is lowest 
3d10 ed 52		  sbc hl,de 
3d12 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3d14			 
3d14 e1				pop hl 
3d15					if DEBUG_FORTH_WORDS 
3d15						DMARK "MIN" 
3d15 f5				push af  
3d16 3a 2a 3d			ld a, (.dmark)  
3d19 32 68 fe			ld (debug_mark),a  
3d1c 3a 2b 3d			ld a, (.dmark+1)  
3d1f 32 69 fe			ld (debug_mark+1),a  
3d22 3a 2c 3d			ld a, (.dmark+2)  
3d25 32 6a fe			ld (debug_mark+2),a  
3d28 18 03			jr .pastdmark  
3d2a ..			.dmark: db "MIN"  
3d2d f1			.pastdmark: pop af  
3d2e			endm  
# End of macro DMARK
3d2e						CALLMONITOR 
3d2e cd 6c fe			call debug_vector  
3d31				endm  
# End of macro CALLMONITOR
3d31					endif 
3d31 cd fb 20				call forth_push_numhl 
3d34			 
3d34				       NEXTW 
3d34 c3 a8 24			jp macro_next 
3d37				endm 
# End of macro NEXTW
3d37			 
3d37			.mincont:  
3d37 c1				pop bc   ; tidy up 
3d38 eb				ex de , hl  
3d39					if DEBUG_FORTH_WORDS 
3d39						DMARK "MI1" 
3d39 f5				push af  
3d3a 3a 4e 3d			ld a, (.dmark)  
3d3d 32 68 fe			ld (debug_mark),a  
3d40 3a 4f 3d			ld a, (.dmark+1)  
3d43 32 69 fe			ld (debug_mark+1),a  
3d46 3a 50 3d			ld a, (.dmark+2)  
3d49 32 6a fe			ld (debug_mark+2),a  
3d4c 18 03			jr .pastdmark  
3d4e ..			.dmark: db "MI1"  
3d51 f1			.pastdmark: pop af  
3d52			endm  
# End of macro DMARK
3d52						CALLMONITOR 
3d52 cd 6c fe			call debug_vector  
3d55				endm  
# End of macro CALLMONITOR
3d55					endif 
3d55 cd fb 20				call forth_push_numhl 
3d58			 
3d58				       NEXTW 
3d58 c3 a8 24			jp macro_next 
3d5b				endm 
# End of macro NEXTW
3d5b			.MAX: 
3d5b				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3d5b 4a				db WORD_SYS_CORE+54             
3d5c dc 3d			dw .RND16            
3d5e 04				db 3 + 1 
3d5f .. 00			db "MAX",0              
3d63				endm 
# End of macro CWHEAD
3d63			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3d63					if DEBUG_FORTH_WORDS_KEY 
3d63						DMARK "MAX" 
3d63 f5				push af  
3d64 3a 78 3d			ld a, (.dmark)  
3d67 32 68 fe			ld (debug_mark),a  
3d6a 3a 79 3d			ld a, (.dmark+1)  
3d6d 32 69 fe			ld (debug_mark+1),a  
3d70 3a 7a 3d			ld a, (.dmark+2)  
3d73 32 6a fe			ld (debug_mark+2),a  
3d76 18 03			jr .pastdmark  
3d78 ..			.dmark: db "MAX"  
3d7b f1			.pastdmark: pop af  
3d7c			endm  
# End of macro DMARK
3d7c						CALLMONITOR 
3d7c cd 6c fe			call debug_vector  
3d7f				endm  
# End of macro CALLMONITOR
3d7f					endif 
3d7f					; get u2 
3d7f			 
3d7f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d7f cd f2 22			call macro_dsp_valuehl 
3d82				endm 
# End of macro FORTH_DSP_VALUEHL
3d82			 
3d82 e5					push hl   ; u2 
3d83			 
3d83					; destroy value TOS 
3d83			 
3d83					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d83 cd aa 23			call macro_forth_dsp_pop 
3d86				endm 
# End of macro FORTH_DSP_POP
3d86			 
3d86					; get u1 
3d86			 
3d86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d86 cd f2 22			call macro_dsp_valuehl 
3d89				endm 
# End of macro FORTH_DSP_VALUEHL
3d89			 
3d89 e5					push hl  ; u1 
3d8a			 
3d8a					; destroy value TOS 
3d8a			 
3d8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d8a cd aa 23			call macro_forth_dsp_pop 
3d8d				endm 
# End of macro FORTH_DSP_POP
3d8d			 
3d8d b7			 or a      ;clear carry flag 
3d8e e1			  pop hl    ; u1 
3d8f d1			  pop de    ; u2 
3d90 e5				push hl   ; saved in case hl is lowest 
3d91 ed 52		  sbc hl,de 
3d93 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3d95			 
3d95 e1				pop hl 
3d96					if DEBUG_FORTH_WORDS 
3d96						DMARK "MAX" 
3d96 f5				push af  
3d97 3a ab 3d			ld a, (.dmark)  
3d9a 32 68 fe			ld (debug_mark),a  
3d9d 3a ac 3d			ld a, (.dmark+1)  
3da0 32 69 fe			ld (debug_mark+1),a  
3da3 3a ad 3d			ld a, (.dmark+2)  
3da6 32 6a fe			ld (debug_mark+2),a  
3da9 18 03			jr .pastdmark  
3dab ..			.dmark: db "MAX"  
3dae f1			.pastdmark: pop af  
3daf			endm  
# End of macro DMARK
3daf						CALLMONITOR 
3daf cd 6c fe			call debug_vector  
3db2				endm  
# End of macro CALLMONITOR
3db2					endif 
3db2 cd fb 20				call forth_push_numhl 
3db5			 
3db5				       NEXTW 
3db5 c3 a8 24			jp macro_next 
3db8				endm 
# End of macro NEXTW
3db8			 
3db8			.maxcont:  
3db8 c1				pop bc   ; tidy up 
3db9 eb				ex de , hl  
3dba					if DEBUG_FORTH_WORDS 
3dba						DMARK "MA1" 
3dba f5				push af  
3dbb 3a cf 3d			ld a, (.dmark)  
3dbe 32 68 fe			ld (debug_mark),a  
3dc1 3a d0 3d			ld a, (.dmark+1)  
3dc4 32 69 fe			ld (debug_mark+1),a  
3dc7 3a d1 3d			ld a, (.dmark+2)  
3dca 32 6a fe			ld (debug_mark+2),a  
3dcd 18 03			jr .pastdmark  
3dcf ..			.dmark: db "MA1"  
3dd2 f1			.pastdmark: pop af  
3dd3			endm  
# End of macro DMARK
3dd3						CALLMONITOR 
3dd3 cd 6c fe			call debug_vector  
3dd6				endm  
# End of macro CALLMONITOR
3dd6					endif 
3dd6 cd fb 20				call forth_push_numhl 
3dd9				       NEXTW 
3dd9 c3 a8 24			jp macro_next 
3ddc				endm 
# End of macro NEXTW
3ddc			 
3ddc			.RND16: 
3ddc				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3ddc 4e				db WORD_SYS_CORE+58             
3ddd 0b 3e			dw .RND8            
3ddf 06				db 5 + 1 
3de0 .. 00			db "RND16",0              
3de6				endm 
# End of macro CWHEAD
3de6			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3de6					if DEBUG_FORTH_WORDS_KEY 
3de6						DMARK "R16" 
3de6 f5				push af  
3de7 3a fb 3d			ld a, (.dmark)  
3dea 32 68 fe			ld (debug_mark),a  
3ded 3a fc 3d			ld a, (.dmark+1)  
3df0 32 69 fe			ld (debug_mark+1),a  
3df3 3a fd 3d			ld a, (.dmark+2)  
3df6 32 6a fe			ld (debug_mark+2),a  
3df9 18 03			jr .pastdmark  
3dfb ..			.dmark: db "R16"  
3dfe f1			.pastdmark: pop af  
3dff			endm  
# End of macro DMARK
3dff						CALLMONITOR 
3dff cd 6c fe			call debug_vector  
3e02				endm  
# End of macro CALLMONITOR
3e02					endif 
3e02 cd f6 0e				call prng16  
3e05 cd fb 20				call forth_push_numhl 
3e08				       NEXTW 
3e08 c3 a8 24			jp macro_next 
3e0b				endm 
# End of macro NEXTW
3e0b			.RND8: 
3e0b				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3e0b 60				db WORD_SYS_CORE+76             
3e0c 40 3e			dw .RND            
3e0e 05				db 4 + 1 
3e0f .. 00			db "RND8",0              
3e14				endm 
# End of macro CWHEAD
3e14			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3e14					if DEBUG_FORTH_WORDS_KEY 
3e14						DMARK "RN8" 
3e14 f5				push af  
3e15 3a 29 3e			ld a, (.dmark)  
3e18 32 68 fe			ld (debug_mark),a  
3e1b 3a 2a 3e			ld a, (.dmark+1)  
3e1e 32 69 fe			ld (debug_mark+1),a  
3e21 3a 2b 3e			ld a, (.dmark+2)  
3e24 32 6a fe			ld (debug_mark+2),a  
3e27 18 03			jr .pastdmark  
3e29 ..			.dmark: db "RN8"  
3e2c f1			.pastdmark: pop af  
3e2d			endm  
# End of macro DMARK
3e2d						CALLMONITOR 
3e2d cd 6c fe			call debug_vector  
3e30				endm  
# End of macro CALLMONITOR
3e30					endif 
3e30 2a a6 fb				ld hl,(xrandc) 
3e33 23					inc hl 
3e34 cd 10 0f				call xrnd 
3e37 6f					ld l,a	 
3e38 26 00				ld h,0 
3e3a cd fb 20				call forth_push_numhl 
3e3d				       NEXTW 
3e3d c3 a8 24			jp macro_next 
3e40				endm 
# End of macro NEXTW
3e40			.RND: 
3e40				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3e40 60				db WORD_SYS_CORE+76             
3e41 46 3f			dw .ENDMATHS            
3e43 04				db 3 + 1 
3e44 .. 00			db "RND",0              
3e48				endm 
# End of macro CWHEAD
3e48			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3e48			 
3e48					if DEBUG_FORTH_WORDS_KEY 
3e48						DMARK "RND" 
3e48 f5				push af  
3e49 3a 5d 3e			ld a, (.dmark)  
3e4c 32 68 fe			ld (debug_mark),a  
3e4f 3a 5e 3e			ld a, (.dmark+1)  
3e52 32 69 fe			ld (debug_mark+1),a  
3e55 3a 5f 3e			ld a, (.dmark+2)  
3e58 32 6a fe			ld (debug_mark+2),a  
3e5b 18 03			jr .pastdmark  
3e5d ..			.dmark: db "RND"  
3e60 f1			.pastdmark: pop af  
3e61			endm  
# End of macro DMARK
3e61						CALLMONITOR 
3e61 cd 6c fe			call debug_vector  
3e64				endm  
# End of macro CALLMONITOR
3e64					endif 
3e64					 
3e64					FORTH_DSP_VALUEHL    ; upper range 
3e64 cd f2 22			call macro_dsp_valuehl 
3e67				endm 
# End of macro FORTH_DSP_VALUEHL
3e67			 
3e67 22 aa fb				ld (LFSRSeed), hl	 
3e6a			 
3e6a					if DEBUG_FORTH_WORDS 
3e6a						DMARK "RN1" 
3e6a f5				push af  
3e6b 3a 7f 3e			ld a, (.dmark)  
3e6e 32 68 fe			ld (debug_mark),a  
3e71 3a 80 3e			ld a, (.dmark+1)  
3e74 32 69 fe			ld (debug_mark+1),a  
3e77 3a 81 3e			ld a, (.dmark+2)  
3e7a 32 6a fe			ld (debug_mark+2),a  
3e7d 18 03			jr .pastdmark  
3e7f ..			.dmark: db "RN1"  
3e82 f1			.pastdmark: pop af  
3e83			endm  
# End of macro DMARK
3e83						CALLMONITOR 
3e83 cd 6c fe			call debug_vector  
3e86				endm  
# End of macro CALLMONITOR
3e86					endif 
3e86					FORTH_DSP_POP 
3e86 cd aa 23			call macro_forth_dsp_pop 
3e89				endm 
# End of macro FORTH_DSP_POP
3e89			 
3e89					FORTH_DSP_VALUEHL    ; low range 
3e89 cd f2 22			call macro_dsp_valuehl 
3e8c				endm 
# End of macro FORTH_DSP_VALUEHL
3e8c			 
3e8c					if DEBUG_FORTH_WORDS 
3e8c						DMARK "RN2" 
3e8c f5				push af  
3e8d 3a a1 3e			ld a, (.dmark)  
3e90 32 68 fe			ld (debug_mark),a  
3e93 3a a2 3e			ld a, (.dmark+1)  
3e96 32 69 fe			ld (debug_mark+1),a  
3e99 3a a3 3e			ld a, (.dmark+2)  
3e9c 32 6a fe			ld (debug_mark+2),a  
3e9f 18 03			jr .pastdmark  
3ea1 ..			.dmark: db "RN2"  
3ea4 f1			.pastdmark: pop af  
3ea5			endm  
# End of macro DMARK
3ea5						CALLMONITOR 
3ea5 cd 6c fe			call debug_vector  
3ea8				endm  
# End of macro CALLMONITOR
3ea8					endif 
3ea8 22 ac fb				ld (LFSRSeed+2), hl 
3eab			 
3eab					FORTH_DSP_POP 
3eab cd aa 23			call macro_forth_dsp_pop 
3eae				endm 
# End of macro FORTH_DSP_POP
3eae			 
3eae e5					push hl 
3eaf			 
3eaf e1			.inrange:	pop hl 
3eb0 cd f6 0e				call prng16  
3eb3					if DEBUG_FORTH_WORDS 
3eb3						DMARK "RN3" 
3eb3 f5				push af  
3eb4 3a c8 3e			ld a, (.dmark)  
3eb7 32 68 fe			ld (debug_mark),a  
3eba 3a c9 3e			ld a, (.dmark+1)  
3ebd 32 69 fe			ld (debug_mark+1),a  
3ec0 3a ca 3e			ld a, (.dmark+2)  
3ec3 32 6a fe			ld (debug_mark+2),a  
3ec6 18 03			jr .pastdmark  
3ec8 ..			.dmark: db "RN3"  
3ecb f1			.pastdmark: pop af  
3ecc			endm  
# End of macro DMARK
3ecc						CALLMONITOR 
3ecc cd 6c fe			call debug_vector  
3ecf				endm  
# End of macro CALLMONITOR
3ecf					endif 
3ecf					 
3ecf					; if the range is 8bit knock out the high byte 
3ecf			 
3ecf ed 5b aa fb			ld de, (LFSRSeed)     ; check high level 
3ed3			 
3ed3 3e 00				ld a, 0 
3ed5 ba					cp d  
3ed6 20 1e				jr nz, .hirange 
3ed8 26 00				ld h, 0   ; knock it down to 8bit 
3eda			 
3eda					if DEBUG_FORTH_WORDS 
3eda						DMARK "RNk" 
3eda f5				push af  
3edb 3a ef 3e			ld a, (.dmark)  
3ede 32 68 fe			ld (debug_mark),a  
3ee1 3a f0 3e			ld a, (.dmark+1)  
3ee4 32 69 fe			ld (debug_mark+1),a  
3ee7 3a f1 3e			ld a, (.dmark+2)  
3eea 32 6a fe			ld (debug_mark+2),a  
3eed 18 03			jr .pastdmark  
3eef ..			.dmark: db "RNk"  
3ef2 f1			.pastdmark: pop af  
3ef3			endm  
# End of macro DMARK
3ef3						CALLMONITOR 
3ef3 cd 6c fe			call debug_vector  
3ef6				endm  
# End of macro CALLMONITOR
3ef6					endif 
3ef6			.hirange:   
3ef6 e5					push hl  
3ef7 b7					or a  
3ef8 ed 52		                sbc hl, de 
3efa			 
3efa					;call cmp16 
3efa			 
3efa 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3efc e1					pop hl 
3efd e5					push hl 
3efe			 
3efe					if DEBUG_FORTH_WORDS 
3efe						DMARK "RN4" 
3efe f5				push af  
3eff 3a 13 3f			ld a, (.dmark)  
3f02 32 68 fe			ld (debug_mark),a  
3f05 3a 14 3f			ld a, (.dmark+1)  
3f08 32 69 fe			ld (debug_mark+1),a  
3f0b 3a 15 3f			ld a, (.dmark+2)  
3f0e 32 6a fe			ld (debug_mark+2),a  
3f11 18 03			jr .pastdmark  
3f13 ..			.dmark: db "RN4"  
3f16 f1			.pastdmark: pop af  
3f17			endm  
# End of macro DMARK
3f17						CALLMONITOR 
3f17 cd 6c fe			call debug_vector  
3f1a				endm  
# End of macro CALLMONITOR
3f1a					endif 
3f1a ed 5b ac fb			ld de, (LFSRSeed+2)   ; check low range 
3f1e					;call cmp16 
3f1e				 
3f1e b7					or a  
3f1f ed 52		                sbc hl, de 
3f21 38 8c				jr c, .inrange 
3f23			 
3f23 e1					pop hl 
3f24					 
3f24					if DEBUG_FORTH_WORDS 
3f24						DMARK "RNd" 
3f24 f5				push af  
3f25 3a 39 3f			ld a, (.dmark)  
3f28 32 68 fe			ld (debug_mark),a  
3f2b 3a 3a 3f			ld a, (.dmark+1)  
3f2e 32 69 fe			ld (debug_mark+1),a  
3f31 3a 3b 3f			ld a, (.dmark+2)  
3f34 32 6a fe			ld (debug_mark+2),a  
3f37 18 03			jr .pastdmark  
3f39 ..			.dmark: db "RNd"  
3f3c f1			.pastdmark: pop af  
3f3d			endm  
# End of macro DMARK
3f3d						CALLMONITOR 
3f3d cd 6c fe			call debug_vector  
3f40				endm  
# End of macro CALLMONITOR
3f40					endif 
3f40			 
3f40			 
3f40 cd fb 20				call forth_push_numhl 
3f43				       NEXTW 
3f43 c3 a8 24			jp macro_next 
3f46				endm 
# End of macro NEXTW
3f46			 
3f46			.ENDMATHS: 
3f46			 
3f46			; eof 
3f46			 
# End of file forth_words_maths.asm
3f46			include "forth_words_display.asm" 
3f46			 
3f46			; | ## Display Words 
3f46			 
3f46			.ACT: 
3f46			 
3f46				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3f46 62				db WORD_SYS_CORE+78             
3f47 92 3f			dw .INFO            
3f49 07				db 6 + 1 
3f4a .. 00			db "ACTIVE",0              
3f51				endm 
# End of macro CWHEAD
3f51			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3f51			;  
3f51			; | | e.g. $ff $00 do active . $01 pause loop 
3f51			 
3f51					if DEBUG_FORTH_WORDS_KEY 
3f51						DMARK "ACT" 
3f51 f5				push af  
3f52 3a 66 3f			ld a, (.dmark)  
3f55 32 68 fe			ld (debug_mark),a  
3f58 3a 67 3f			ld a, (.dmark+1)  
3f5b 32 69 fe			ld (debug_mark+1),a  
3f5e 3a 68 3f			ld a, (.dmark+2)  
3f61 32 6a fe			ld (debug_mark+2),a  
3f64 18 03			jr .pastdmark  
3f66 ..			.dmark: db "ACT"  
3f69 f1			.pastdmark: pop af  
3f6a			endm  
# End of macro DMARK
3f6a						CALLMONITOR 
3f6a cd 6c fe			call debug_vector  
3f6d				endm  
# End of macro CALLMONITOR
3f6d					endif 
3f6d cd f2 0c				call active 
3f70					if DEBUG_FORTH_WORDS 
3f70						DMARK "ACp" 
3f70 f5				push af  
3f71 3a 85 3f			ld a, (.dmark)  
3f74 32 68 fe			ld (debug_mark),a  
3f77 3a 86 3f			ld a, (.dmark+1)  
3f7a 32 69 fe			ld (debug_mark+1),a  
3f7d 3a 87 3f			ld a, (.dmark+2)  
3f80 32 6a fe			ld (debug_mark+2),a  
3f83 18 03			jr .pastdmark  
3f85 ..			.dmark: db "ACp"  
3f88 f1			.pastdmark: pop af  
3f89			endm  
# End of macro DMARK
3f89						CALLMONITOR 
3f89 cd 6c fe			call debug_vector  
3f8c				endm  
# End of macro CALLMONITOR
3f8c					endif 
3f8c cd 69 21				call forth_push_str 
3f8f			 
3f8f					NEXTW 
3f8f c3 a8 24			jp macro_next 
3f92				endm 
# End of macro NEXTW
3f92			.INFO: 
3f92			 
3f92				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3f92 62				db WORD_SYS_CORE+78             
3f93 af 3f			dw .ATP            
3f95 05				db 4 + 1 
3f96 .. 00			db "INFO",0              
3f9b				endm 
# End of macro CWHEAD
3f9b			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3f9b					FORTH_DSP_VALUEHL 
3f9b cd f2 22			call macro_dsp_valuehl 
3f9e				endm 
# End of macro FORTH_DSP_VALUEHL
3f9e			 
3f9e					FORTH_DSP_POP 
3f9e cd aa 23			call macro_forth_dsp_pop 
3fa1				endm 
# End of macro FORTH_DSP_POP
3fa1			 
3fa1 e5					push hl 
3fa2			 
3fa2					FORTH_DSP_VALUEHL 
3fa2 cd f2 22			call macro_dsp_valuehl 
3fa5				endm 
# End of macro FORTH_DSP_VALUEHL
3fa5			 
3fa5					FORTH_DSP_POP 
3fa5 cd aa 23			call macro_forth_dsp_pop 
3fa8				endm 
# End of macro FORTH_DSP_POP
3fa8			 
3fa8 d1					pop de 
3fa9			 
3fa9 cd 2c 0d				call info_panel 
3fac			 
3fac			 
3fac					NEXTW 
3fac c3 a8 24			jp macro_next 
3faf				endm 
# End of macro NEXTW
3faf			.ATP: 
3faf				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3faf 62				db WORD_SYS_CORE+78             
3fb0 26 40			dw .FB            
3fb2 04				db 3 + 1 
3fb3 .. 00			db "AT?",0              
3fb7				endm 
# End of macro CWHEAD
3fb7			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3fb7					if DEBUG_FORTH_WORDS_KEY 
3fb7						DMARK "AT?" 
3fb7 f5				push af  
3fb8 3a cc 3f			ld a, (.dmark)  
3fbb 32 68 fe			ld (debug_mark),a  
3fbe 3a cd 3f			ld a, (.dmark+1)  
3fc1 32 69 fe			ld (debug_mark+1),a  
3fc4 3a ce 3f			ld a, (.dmark+2)  
3fc7 32 6a fe			ld (debug_mark+2),a  
3fca 18 03			jr .pastdmark  
3fcc ..			.dmark: db "AT?"  
3fcf f1			.pastdmark: pop af  
3fd0			endm  
# End of macro DMARK
3fd0						CALLMONITOR 
3fd0 cd 6c fe			call debug_vector  
3fd3				endm  
# End of macro CALLMONITOR
3fd3					endif 
3fd3 3a 5b fa				ld a, (f_cursor_ptr) 
3fd6			 
3fd6			if DEBUG_FORTH_WORDS 
3fd6				DMARK "AT?" 
3fd6 f5				push af  
3fd7 3a eb 3f			ld a, (.dmark)  
3fda 32 68 fe			ld (debug_mark),a  
3fdd 3a ec 3f			ld a, (.dmark+1)  
3fe0 32 69 fe			ld (debug_mark+1),a  
3fe3 3a ed 3f			ld a, (.dmark+2)  
3fe6 32 6a fe			ld (debug_mark+2),a  
3fe9 18 03			jr .pastdmark  
3feb ..			.dmark: db "AT?"  
3fee f1			.pastdmark: pop af  
3fef			endm  
# End of macro DMARK
3fef				CALLMONITOR 
3fef cd 6c fe			call debug_vector  
3ff2				endm  
# End of macro CALLMONITOR
3ff2			endif	 
3ff2					; count the number of rows 
3ff2			 
3ff2 06 00				ld b, 0 
3ff4 4f			.atpr:		ld c, a    ; save in case we go below zero 
3ff5 d6 28				sub display_cols 
3ff7 f2 fd 3f				jp p, .atprunder 
3ffa 04					inc b 
3ffb 18 f7				jr .atpr 
3ffd			.atprunder:	 
3ffd			if DEBUG_FORTH_WORDS 
3ffd				DMARK "A?2" 
3ffd f5				push af  
3ffe 3a 12 40			ld a, (.dmark)  
4001 32 68 fe			ld (debug_mark),a  
4004 3a 13 40			ld a, (.dmark+1)  
4007 32 69 fe			ld (debug_mark+1),a  
400a 3a 14 40			ld a, (.dmark+2)  
400d 32 6a fe			ld (debug_mark+2),a  
4010 18 03			jr .pastdmark  
4012 ..			.dmark: db "A?2"  
4015 f1			.pastdmark: pop af  
4016			endm  
# End of macro DMARK
4016				CALLMONITOR 
4016 cd 6c fe			call debug_vector  
4019				endm  
# End of macro CALLMONITOR
4019			endif	 
4019 26 00				ld h, 0 
401b 69					ld l, c 
401c cd fb 20				call forth_push_numhl 
401f 68					ld l, b  
4020 cd fb 20				call forth_push_numhl 
4023			 
4023			 
4023				NEXTW 
4023 c3 a8 24			jp macro_next 
4026				endm 
# End of macro NEXTW
4026			 
4026			.FB: 
4026				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
4026 1b				db WORD_SYS_CORE+7             
4027 74 40			dw .EMIT            
4029 03				db 2 + 1 
402a .. 00			db "FB",0              
402d				endm 
# End of macro CWHEAD
402d			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
402d			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
402d			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
402d			; | | If automatic display is off then updates will not be shown until DRAW is used. 
402d					if DEBUG_FORTH_WORDS_KEY 
402d						DMARK "FB." 
402d f5				push af  
402e 3a 42 40			ld a, (.dmark)  
4031 32 68 fe			ld (debug_mark),a  
4034 3a 43 40			ld a, (.dmark+1)  
4037 32 69 fe			ld (debug_mark+1),a  
403a 3a 44 40			ld a, (.dmark+2)  
403d 32 6a fe			ld (debug_mark+2),a  
4040 18 03			jr .pastdmark  
4042 ..			.dmark: db "FB."  
4045 f1			.pastdmark: pop af  
4046			endm  
# End of macro DMARK
4046						CALLMONITOR 
4046 cd 6c fe			call debug_vector  
4049				endm  
# End of macro CALLMONITOR
4049					endif 
4049			 
4049					FORTH_DSP_VALUEHL 
4049 cd f2 22			call macro_dsp_valuehl 
404c				endm 
# End of macro FORTH_DSP_VALUEHL
404c			 
404c 7d					ld a, l 
404d fe 01				cp 1 
404f 20 05				jr nz, .fbn1 
4051 21 0d fd				ld hl, display_fb1 
4054 18 15				jr .fbset 
4056 fe 02		.fbn1:		cp 2 
4058 20 05				jr nz, .fbn2 
405a 21 cb fb				ld hl, display_fb2 
405d 18 0c				jr .fbset 
405f fe 03		.fbn2:		cp 3 
4061 20 05				jr nz, .fbn3 
4063 21 6c fc				ld hl, display_fb3 
4066 18 03				jr .fbset 
4068			.fbn3:		 ; if invalid number select first 
4068 21 0d fd				ld hl, display_fb1 
406b 22 c9 fb		.fbset:		ld (display_fb_active), hl 
406e			 
406e					FORTH_DSP_POP 
406e cd aa 23			call macro_forth_dsp_pop 
4071				endm 
# End of macro FORTH_DSP_POP
4071			 
4071					NEXTW 
4071 c3 a8 24			jp macro_next 
4074				endm 
# End of macro NEXTW
4074			 
4074			 
4074			.EMIT: 
4074				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
4074 1b				db WORD_SYS_CORE+7             
4075 c5 40			dw .DOTH            
4077 05				db 4 + 1 
4078 .. 00			db "EMIT",0              
407d				endm 
# End of macro CWHEAD
407d			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
407d					; get value off TOS and display it 
407d			 
407d					if DEBUG_FORTH_WORDS_KEY 
407d						DMARK "EMT" 
407d f5				push af  
407e 3a 92 40			ld a, (.dmark)  
4081 32 68 fe			ld (debug_mark),a  
4084 3a 93 40			ld a, (.dmark+1)  
4087 32 69 fe			ld (debug_mark+1),a  
408a 3a 94 40			ld a, (.dmark+2)  
408d 32 6a fe			ld (debug_mark+2),a  
4090 18 03			jr .pastdmark  
4092 ..			.dmark: db "EMT"  
4095 f1			.pastdmark: pop af  
4096			endm  
# End of macro DMARK
4096						CALLMONITOR 
4096 cd 6c fe			call debug_vector  
4099				endm  
# End of macro CALLMONITOR
4099					endif 
4099			 
4099					FORTH_DSP_VALUEHL 
4099 cd f2 22			call macro_dsp_valuehl 
409c				endm 
# End of macro FORTH_DSP_VALUEHL
409c			 
409c 7d					ld a,l 
409d			 
409d					; TODO write to display 
409d			 
409d 32 bc f3				ld (os_input), a 
40a0 3e 00				ld a, 0 
40a2 32 bd f3				ld (os_input+1), a 
40a5					 
40a5 3a 5b fa				ld a, (f_cursor_ptr) 
40a8 11 bc f3				ld de, os_input 
40ab cd ae 0d				call str_at_display 
40ae			 
40ae			 
40ae 3a 39 fa				ld a,(cli_autodisplay) 
40b1 fe 00				cp 0 
40b3 28 03				jr z, .enoupdate 
40b5 cd be 0d						call update_display 
40b8					.enoupdate: 
40b8			 
40b8 3a 5b fa				ld a, (f_cursor_ptr) 
40bb 3c					inc a 
40bc 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
40bf			 
40bf			 
40bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40bf cd aa 23			call macro_forth_dsp_pop 
40c2				endm 
# End of macro FORTH_DSP_POP
40c2			  
40c2			 
40c2					NEXTW 
40c2 c3 a8 24			jp macro_next 
40c5				endm 
# End of macro NEXTW
40c5			.DOTH: 
40c5				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
40c5 1c				db WORD_SYS_CORE+8             
40c6 f5 40			dw .DOTF            
40c8 03				db 2 + 1 
40c9 .. 00			db ".-",0              
40cc				endm 
# End of macro CWHEAD
40cc			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
40cc					; get value off TOS and display it 
40cc					if DEBUG_FORTH_WORDS_KEY 
40cc						DMARK "DTD" 
40cc f5				push af  
40cd 3a e1 40			ld a, (.dmark)  
40d0 32 68 fe			ld (debug_mark),a  
40d3 3a e2 40			ld a, (.dmark+1)  
40d6 32 69 fe			ld (debug_mark+1),a  
40d9 3a e3 40			ld a, (.dmark+2)  
40dc 32 6a fe			ld (debug_mark+2),a  
40df 18 03			jr .pastdmark  
40e1 ..			.dmark: db "DTD"  
40e4 f1			.pastdmark: pop af  
40e5			endm  
# End of macro DMARK
40e5						CALLMONITOR 
40e5 cd 6c fe			call debug_vector  
40e8				endm  
# End of macro CALLMONITOR
40e8					endif 
40e8 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
40ea 3e 00			ld a, 0 
40ec 32 3a fa			ld (cli_mvdot), a 
40ef c3 4c 41			jp .dotgo 
40f2				NEXTW 
40f2 c3 a8 24			jp macro_next 
40f5				endm 
# End of macro NEXTW
40f5			.DOTF: 
40f5				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
40f5 1c				db WORD_SYS_CORE+8             
40f6 23 41			dw .DOT            
40f8 03				db 2 + 1 
40f9 .. 00			db ".>",0              
40fc				endm 
# End of macro CWHEAD
40fc			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
40fc					; get value off TOS and display it 
40fc			        ; TODO BUG adds extra spaces 
40fc			        ; TODO BUG handle numerics? 
40fc					if DEBUG_FORTH_WORDS_KEY 
40fc						DMARK "DTC" 
40fc f5				push af  
40fd 3a 11 41			ld a, (.dmark)  
4100 32 68 fe			ld (debug_mark),a  
4103 3a 12 41			ld a, (.dmark+1)  
4106 32 69 fe			ld (debug_mark+1),a  
4109 3a 13 41			ld a, (.dmark+2)  
410c 32 6a fe			ld (debug_mark+2),a  
410f 18 03			jr .pastdmark  
4111 ..			.dmark: db "DTC"  
4114 f1			.pastdmark: pop af  
4115			endm  
# End of macro DMARK
4115						CALLMONITOR 
4115 cd 6c fe			call debug_vector  
4118				endm  
# End of macro CALLMONITOR
4118					endif 
4118 3e 01			ld a, 1 
411a 32 3a fa			ld (cli_mvdot), a 
411d c3 4c 41			jp .dotgo 
4120				NEXTW 
4120 c3 a8 24			jp macro_next 
4123				endm 
# End of macro NEXTW
4123			 
4123			.DOT: 
4123				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4123 1c				db WORD_SYS_CORE+8             
4124 ff 42			dw .CLS            
4126 02				db 1 + 1 
4127 .. 00			db ".",0              
4129				endm 
# End of macro CWHEAD
4129			        ; | . ( u -- ) Display TOS | DONE 
4129					; get value off TOS and display it 
4129			 
4129					if DEBUG_FORTH_WORDS_KEY 
4129						DMARK "DOT" 
4129 f5				push af  
412a 3a 3e 41			ld a, (.dmark)  
412d 32 68 fe			ld (debug_mark),a  
4130 3a 3f 41			ld a, (.dmark+1)  
4133 32 69 fe			ld (debug_mark+1),a  
4136 3a 40 41			ld a, (.dmark+2)  
4139 32 6a fe			ld (debug_mark+2),a  
413c 18 03			jr .pastdmark  
413e ..			.dmark: db "DOT"  
4141 f1			.pastdmark: pop af  
4142			endm  
# End of macro DMARK
4142						CALLMONITOR 
4142 cd 6c fe			call debug_vector  
4145				endm  
# End of macro CALLMONITOR
4145					endif 
4145 3e 00			ld a, 0 
4147 32 3a fa			ld (cli_mvdot), a 
414a 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
414c				 
414c			 
414c			.dotgo: 
414c			 
414c			; move up type to on stack for parserv5 
414c					FORTH_DSP 
414c cd b8 22			call macro_forth_dsp 
414f				endm 
# End of macro FORTH_DSP
414f				;FORTH_DSP_VALUE  
414f			 
414f			if DEBUG_FORTH_DOT 
414f				DMARK "DOT" 
414f f5				push af  
4150 3a 64 41			ld a, (.dmark)  
4153 32 68 fe			ld (debug_mark),a  
4156 3a 65 41			ld a, (.dmark+1)  
4159 32 69 fe			ld (debug_mark+1),a  
415c 3a 66 41			ld a, (.dmark+2)  
415f 32 6a fe			ld (debug_mark+2),a  
4162 18 03			jr .pastdmark  
4164 ..			.dmark: db "DOT"  
4167 f1			.pastdmark: pop af  
4168			endm  
# End of macro DMARK
4168				CALLMONITOR 
4168 cd 6c fe			call debug_vector  
416b				endm  
# End of macro CALLMONITOR
416b			endif	 
416b			;		.print: 
416b			 
416b 7e				ld a,(hl)  ; work out what type of value is on the TOS 
416c 23				inc hl   ; position to the actual value 
416d fe 01			cp DS_TYPE_STR 
416f 20 06			jr nz, .dotnum1  
4171			 
4171			; display string 
4171				FORTH_DSP_VALUE  
4171 cd db 22			call macro_forth_dsp_value 
4174				endm 
# End of macro FORTH_DSP_VALUE
4174 eb				ex de,hl 
4175 18 49			jr .dotwrite 
4177			 
4177			.dotnum1: 
4177 fe 02			cp DS_TYPE_INUM 
4179 20 44			jr nz, .dotflot 
417b			 
417b			 
417b			; display number 
417b			 
417b			;	push hl 
417b			;	call clear_display 
417b			;	pop hl 
417b			 
417b 5e				ld e, (hl) 
417c 23				inc hl 
417d 56				ld d, (hl) 
417e 21 be f1			ld hl, scratch 
4181			if DEBUG_FORTH_DOT 
4181				DMARK "DT1" 
4181 f5				push af  
4182 3a 96 41			ld a, (.dmark)  
4185 32 68 fe			ld (debug_mark),a  
4188 3a 97 41			ld a, (.dmark+1)  
418b 32 69 fe			ld (debug_mark+1),a  
418e 3a 98 41			ld a, (.dmark+2)  
4191 32 6a fe			ld (debug_mark+2),a  
4194 18 03			jr .pastdmark  
4196 ..			.dmark: db "DT1"  
4199 f1			.pastdmark: pop af  
419a			endm  
# End of macro DMARK
419a				CALLMONITOR 
419a cd 6c fe			call debug_vector  
419d				endm  
# End of macro CALLMONITOR
419d			endif	 
419d			 
419d cd dc 13			call uitoa_16 
41a0 eb				ex de,hl 
41a1			 
41a1			if DEBUG_FORTH_DOT 
41a1				DMARK "DT2" 
41a1 f5				push af  
41a2 3a b6 41			ld a, (.dmark)  
41a5 32 68 fe			ld (debug_mark),a  
41a8 3a b7 41			ld a, (.dmark+1)  
41ab 32 69 fe			ld (debug_mark+1),a  
41ae 3a b8 41			ld a, (.dmark+2)  
41b1 32 6a fe			ld (debug_mark+2),a  
41b4 18 03			jr .pastdmark  
41b6 ..			.dmark: db "DT2"  
41b9 f1			.pastdmark: pop af  
41ba			endm  
# End of macro DMARK
41ba				CALLMONITOR 
41ba cd 6c fe			call debug_vector  
41bd				endm  
# End of macro CALLMONITOR
41bd			endif	 
41bd			 
41bd			;	ld de, os_word_scratch 
41bd 18 01			jr .dotwrite 
41bf			 
41bf 00			.dotflot:   nop 
41c0			; TODO print floating point number 
41c0			 
41c0			.dotwrite:		 
41c0			 
41c0					; if c is set then set all '-' to spaces 
41c0					; need to also take into account .>  
41c0			 
41c0 3e 01				ld a, 1 
41c2 b9					cp c 
41c3 20 67				jr nz, .nodashswap 
41c5			 
41c5					; DE has the string to write, working with HL 
41c5			 
41c5 06 ff				ld b, 255 
41c7 d5					push de 
41c8 e1					pop hl 
41c9			 
41c9			if DEBUG_FORTH_DOT 
41c9				DMARK "DT-" 
41c9 f5				push af  
41ca 3a de 41			ld a, (.dmark)  
41cd 32 68 fe			ld (debug_mark),a  
41d0 3a df 41			ld a, (.dmark+1)  
41d3 32 69 fe			ld (debug_mark+1),a  
41d6 3a e0 41			ld a, (.dmark+2)  
41d9 32 6a fe			ld (debug_mark+2),a  
41dc 18 03			jr .pastdmark  
41de ..			.dmark: db "DT-"  
41e1 f1			.pastdmark: pop af  
41e2			endm  
# End of macro DMARK
41e2				CALLMONITOR 
41e2 cd 6c fe			call debug_vector  
41e5				endm  
# End of macro CALLMONITOR
41e5			endif	 
41e5 7e			.dashscan:	ld a, (hl) 
41e6 fe 00				cp 0 
41e8 28 42				jr z, .nodashswap 
41ea fe 2d				cp '-' 
41ec 20 03				jr nz, .dashskip 
41ee 3e 20				ld a, ' ' 
41f0 77					ld (hl), a 
41f1 23			.dashskip:	inc hl 
41f2			if DEBUG_FORTH_DOT 
41f2				DMARK "D-2" 
41f2 f5				push af  
41f3 3a 07 42			ld a, (.dmark)  
41f6 32 68 fe			ld (debug_mark),a  
41f9 3a 08 42			ld a, (.dmark+1)  
41fc 32 69 fe			ld (debug_mark+1),a  
41ff 3a 09 42			ld a, (.dmark+2)  
4202 32 6a fe			ld (debug_mark+2),a  
4205 18 03			jr .pastdmark  
4207 ..			.dmark: db "D-2"  
420a f1			.pastdmark: pop af  
420b			endm  
# End of macro DMARK
420b				CALLMONITOR 
420b cd 6c fe			call debug_vector  
420e				endm  
# End of macro CALLMONITOR
420e			endif	 
420e 10 d5				djnz .dashscan 
4210			 
4210			if DEBUG_FORTH_DOT 
4210				DMARK "D-1" 
4210 f5				push af  
4211 3a 25 42			ld a, (.dmark)  
4214 32 68 fe			ld (debug_mark),a  
4217 3a 26 42			ld a, (.dmark+1)  
421a 32 69 fe			ld (debug_mark+1),a  
421d 3a 27 42			ld a, (.dmark+2)  
4220 32 6a fe			ld (debug_mark+2),a  
4223 18 03			jr .pastdmark  
4225 ..			.dmark: db "D-1"  
4228 f1			.pastdmark: pop af  
4229			endm  
# End of macro DMARK
4229				CALLMONITOR 
4229 cd 6c fe			call debug_vector  
422c				endm  
# End of macro CALLMONITOR
422c			endif	 
422c			 
422c			.nodashswap: 
422c			 
422c			if DEBUG_FORTH_DOT 
422c				DMARK "D-o" 
422c f5				push af  
422d 3a 41 42			ld a, (.dmark)  
4230 32 68 fe			ld (debug_mark),a  
4233 3a 42 42			ld a, (.dmark+1)  
4236 32 69 fe			ld (debug_mark+1),a  
4239 3a 43 42			ld a, (.dmark+2)  
423c 32 6a fe			ld (debug_mark+2),a  
423f 18 03			jr .pastdmark  
4241 ..			.dmark: db "D-o"  
4244 f1			.pastdmark: pop af  
4245			endm  
# End of macro DMARK
4245				CALLMONITOR 
4245 cd 6c fe			call debug_vector  
4248				endm  
# End of macro CALLMONITOR
4248			endif	 
4248			 
4248 d5					push de   ; save string start in case we need to advance print 
4249			 
4249 3a 5b fa				ld a, (f_cursor_ptr) 
424c cd ae 0d				call str_at_display 
424f 3a 39 fa				ld a,(cli_autodisplay) 
4252 fe 00				cp 0 
4254 28 03				jr z, .noupdate 
4256 cd be 0d						call update_display 
4259					.noupdate: 
4259			 
4259			 
4259					; see if we need to advance the print position 
4259			 
4259 e1					pop hl   ; get back string 
425a			;		ex de,hl 
425a			 
425a 3a 3a fa				ld a, (cli_mvdot) 
425d			if DEBUG_FORTH_DOT 
425d			;		ld e,a 
425d				DMARK "D>1" 
425d f5				push af  
425e 3a 72 42			ld a, (.dmark)  
4261 32 68 fe			ld (debug_mark),a  
4264 3a 73 42			ld a, (.dmark+1)  
4267 32 69 fe			ld (debug_mark+1),a  
426a 3a 74 42			ld a, (.dmark+2)  
426d 32 6a fe			ld (debug_mark+2),a  
4270 18 03			jr .pastdmark  
4272 ..			.dmark: db "D>1"  
4275 f1			.pastdmark: pop af  
4276			endm  
# End of macro DMARK
4276				CALLMONITOR 
4276 cd 6c fe			call debug_vector  
4279				endm  
# End of macro CALLMONITOR
4279			endif	 
4279 fe 00				cp 0 
427b 28 44				jr z, .noadv 
427d					; yes, lets advance the print position 
427d 3e 00				ld a, 0 
427f cd 38 14				call strlent 
4282			if DEBUG_FORTH_DOT 
4282				DMARK "D-?" 
4282 f5				push af  
4283 3a 97 42			ld a, (.dmark)  
4286 32 68 fe			ld (debug_mark),a  
4289 3a 98 42			ld a, (.dmark+1)  
428c 32 69 fe			ld (debug_mark+1),a  
428f 3a 99 42			ld a, (.dmark+2)  
4292 32 6a fe			ld (debug_mark+2),a  
4295 18 03			jr .pastdmark  
4297 ..			.dmark: db "D-?"  
429a f1			.pastdmark: pop af  
429b			endm  
# End of macro DMARK
429b				CALLMONITOR 
429b cd 6c fe			call debug_vector  
429e				endm  
# End of macro CALLMONITOR
429e			endif	 
429e 3a 5b fa				ld a, (f_cursor_ptr) 
42a1 85					add a,l 
42a2					;call addatohl 
42a2					;ld a, l 
42a2 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
42a5			 
42a5			if DEBUG_FORTH_DOT 
42a5				DMARK "D->" 
42a5 f5				push af  
42a6 3a ba 42			ld a, (.dmark)  
42a9 32 68 fe			ld (debug_mark),a  
42ac 3a bb 42			ld a, (.dmark+1)  
42af 32 69 fe			ld (debug_mark+1),a  
42b2 3a bc 42			ld a, (.dmark+2)  
42b5 32 6a fe			ld (debug_mark+2),a  
42b8 18 03			jr .pastdmark  
42ba ..			.dmark: db "D->"  
42bd f1			.pastdmark: pop af  
42be			endm  
# End of macro DMARK
42be				CALLMONITOR 
42be cd 6c fe			call debug_vector  
42c1				endm  
# End of macro CALLMONITOR
42c1			endif	 
42c1			 
42c1			.noadv:	 
42c1			 
42c1					if DEBUG_FORTH_DOT_WAIT 
42c1							call next_page_prompt 
42c1					endif	 
42c1			; TODO this pop off the stack causes a crash. i dont know why 
42c1			 
42c1			 
42c1			if DEBUG_FORTH_DOT 
42c1				DMARK "DTh" 
42c1 f5				push af  
42c2 3a d6 42			ld a, (.dmark)  
42c5 32 68 fe			ld (debug_mark),a  
42c8 3a d7 42			ld a, (.dmark+1)  
42cb 32 69 fe			ld (debug_mark+1),a  
42ce 3a d8 42			ld a, (.dmark+2)  
42d1 32 6a fe			ld (debug_mark+2),a  
42d4 18 03			jr .pastdmark  
42d6 ..			.dmark: db "DTh"  
42d9 f1			.pastdmark: pop af  
42da			endm  
# End of macro DMARK
42da				CALLMONITOR 
42da cd 6c fe			call debug_vector  
42dd				endm  
# End of macro CALLMONITOR
42dd			endif	 
42dd			 
42dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42dd cd aa 23			call macro_forth_dsp_pop 
42e0				endm 
# End of macro FORTH_DSP_POP
42e0			 
42e0			if DEBUG_FORTH_DOT 
42e0				DMARK "DTi" 
42e0 f5				push af  
42e1 3a f5 42			ld a, (.dmark)  
42e4 32 68 fe			ld (debug_mark),a  
42e7 3a f6 42			ld a, (.dmark+1)  
42ea 32 69 fe			ld (debug_mark+1),a  
42ed 3a f7 42			ld a, (.dmark+2)  
42f0 32 6a fe			ld (debug_mark+2),a  
42f3 18 03			jr .pastdmark  
42f5 ..			.dmark: db "DTi"  
42f8 f1			.pastdmark: pop af  
42f9			endm  
# End of macro DMARK
42f9				CALLMONITOR 
42f9 cd 6c fe			call debug_vector  
42fc				endm  
# End of macro CALLMONITOR
42fc			endif	 
42fc			 
42fc			 
42fc					NEXTW 
42fc c3 a8 24			jp macro_next 
42ff				endm 
# End of macro NEXTW
42ff			 
42ff			.CLS: 
42ff				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
42ff 35				db WORD_SYS_CORE+33             
4300 2c 43			dw .DRAW            
4302 04				db 3 + 1 
4303 .. 00			db "CLS",0              
4307				endm 
# End of macro CWHEAD
4307			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4307					if DEBUG_FORTH_WORDS_KEY 
4307						DMARK "CLS" 
4307 f5				push af  
4308 3a 1c 43			ld a, (.dmark)  
430b 32 68 fe			ld (debug_mark),a  
430e 3a 1d 43			ld a, (.dmark+1)  
4311 32 69 fe			ld (debug_mark+1),a  
4314 3a 1e 43			ld a, (.dmark+2)  
4317 32 6a fe			ld (debug_mark+2),a  
431a 18 03			jr .pastdmark  
431c ..			.dmark: db "CLS"  
431f f1			.pastdmark: pop af  
4320			endm  
# End of macro DMARK
4320						CALLMONITOR 
4320 cd 6c fe			call debug_vector  
4323				endm  
# End of macro CALLMONITOR
4323					endif 
4323 cd 9b 0d				call clear_display 
4326 c3 3a 44				jp .home		; and home cursor 
4329					NEXTW 
4329 c3 a8 24			jp macro_next 
432c				endm 
# End of macro NEXTW
432c			 
432c			.DRAW: 
432c				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
432c 36				db WORD_SYS_CORE+34             
432d 57 43			dw .DUMP            
432f 05				db 4 + 1 
4330 .. 00			db "DRAW",0              
4335				endm 
# End of macro CWHEAD
4335			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4335					if DEBUG_FORTH_WORDS_KEY 
4335						DMARK "DRW" 
4335 f5				push af  
4336 3a 4a 43			ld a, (.dmark)  
4339 32 68 fe			ld (debug_mark),a  
433c 3a 4b 43			ld a, (.dmark+1)  
433f 32 69 fe			ld (debug_mark+1),a  
4342 3a 4c 43			ld a, (.dmark+2)  
4345 32 6a fe			ld (debug_mark+2),a  
4348 18 03			jr .pastdmark  
434a ..			.dmark: db "DRW"  
434d f1			.pastdmark: pop af  
434e			endm  
# End of macro DMARK
434e						CALLMONITOR 
434e cd 6c fe			call debug_vector  
4351				endm  
# End of macro CALLMONITOR
4351					endif 
4351 cd be 0d				call update_display 
4354					NEXTW 
4354 c3 a8 24			jp macro_next 
4357				endm 
# End of macro NEXTW
4357			 
4357			.DUMP: 
4357				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4357 37				db WORD_SYS_CORE+35             
4358 8f 43			dw .CDUMP            
435a 05				db 4 + 1 
435b .. 00			db "DUMP",0              
4360				endm 
# End of macro CWHEAD
4360			; | DUMP ( x -- ) With address x display dump   | DONE 
4360			; TODO pop address to use off of the stack 
4360					if DEBUG_FORTH_WORDS_KEY 
4360						DMARK "DUM" 
4360 f5				push af  
4361 3a 75 43			ld a, (.dmark)  
4364 32 68 fe			ld (debug_mark),a  
4367 3a 76 43			ld a, (.dmark+1)  
436a 32 69 fe			ld (debug_mark+1),a  
436d 3a 77 43			ld a, (.dmark+2)  
4370 32 6a fe			ld (debug_mark+2),a  
4373 18 03			jr .pastdmark  
4375 ..			.dmark: db "DUM"  
4378 f1			.pastdmark: pop af  
4379			endm  
# End of macro DMARK
4379						CALLMONITOR 
4379 cd 6c fe			call debug_vector  
437c				endm  
# End of macro CALLMONITOR
437c					endif 
437c cd 9b 0d				call clear_display 
437f			 
437f					; get address 
437f			 
437f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
437f cd f2 22			call macro_dsp_valuehl 
4382				endm 
# End of macro FORTH_DSP_VALUEHL
4382				 
4382					; save it for cdump 
4382			 
4382 22 e1 f4				ld (os_cur_ptr),hl 
4385			 
4385					; destroy value TOS 
4385			 
4385					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4385 cd aa 23			call macro_forth_dsp_pop 
4388				endm 
# End of macro FORTH_DSP_POP
4388			 
4388 cd 7b 1f				call dumpcont	; skip old style of param parsing	 
438b c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
438c					NEXTW 
438c c3 a8 24			jp macro_next 
438f				endm 
# End of macro NEXTW
438f			.CDUMP: 
438f				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
438f 38				db WORD_SYS_CORE+36             
4390 bf 43			dw .DAT            
4392 06				db 5 + 1 
4393 .. 00			db "CDUMP",0              
4399				endm 
# End of macro CWHEAD
4399			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
4399					if DEBUG_FORTH_WORDS_KEY 
4399						DMARK "CDP" 
4399 f5				push af  
439a 3a ae 43			ld a, (.dmark)  
439d 32 68 fe			ld (debug_mark),a  
43a0 3a af 43			ld a, (.dmark+1)  
43a3 32 69 fe			ld (debug_mark+1),a  
43a6 3a b0 43			ld a, (.dmark+2)  
43a9 32 6a fe			ld (debug_mark+2),a  
43ac 18 03			jr .pastdmark  
43ae ..			.dmark: db "CDP"  
43b1 f1			.pastdmark: pop af  
43b2			endm  
# End of macro DMARK
43b2						CALLMONITOR 
43b2 cd 6c fe			call debug_vector  
43b5				endm  
# End of macro CALLMONITOR
43b5					endif 
43b5 cd 9b 0d				call clear_display 
43b8 cd 7b 1f				call dumpcont	 
43bb c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
43bc					NEXTW 
43bc c3 a8 24			jp macro_next 
43bf				endm 
# End of macro NEXTW
43bf			 
43bf			 
43bf			 
43bf			 
43bf			.DAT: 
43bf				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
43bf 3d				db WORD_SYS_CORE+41             
43c0 15 44			dw .HOME            
43c2 03				db 2 + 1 
43c3 .. 00			db "AT",0              
43c6				endm 
# End of macro CWHEAD
43c6			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
43c6					if DEBUG_FORTH_WORDS_KEY 
43c6						DMARK "AT." 
43c6 f5				push af  
43c7 3a db 43			ld a, (.dmark)  
43ca 32 68 fe			ld (debug_mark),a  
43cd 3a dc 43			ld a, (.dmark+1)  
43d0 32 69 fe			ld (debug_mark+1),a  
43d3 3a dd 43			ld a, (.dmark+2)  
43d6 32 6a fe			ld (debug_mark+2),a  
43d9 18 03			jr .pastdmark  
43db ..			.dmark: db "AT."  
43de f1			.pastdmark: pop af  
43df			endm  
# End of macro DMARK
43df						CALLMONITOR 
43df cd 6c fe			call debug_vector  
43e2				endm  
# End of macro CALLMONITOR
43e2					endif 
43e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43e2 cd f2 22			call macro_dsp_valuehl 
43e5				endm 
# End of macro FORTH_DSP_VALUEHL
43e5			 
43e5			 
43e5					; TODO save cursor row 
43e5 7d					ld a,l 
43e6 fe 02				cp 2 
43e8 20 04				jr nz, .crow3 
43ea 3e 28				ld a, display_row_2 
43ec 18 12				jr .ccol1 
43ee fe 03		.crow3:		cp 3 
43f0 20 04				jr nz, .crow4 
43f2 3e 50				ld a, display_row_3 
43f4 18 0a				jr .ccol1 
43f6 fe 04		.crow4:		cp 4 
43f8 20 04				jr nz, .crow1 
43fa 3e 78				ld a, display_row_4 
43fc 18 02				jr .ccol1 
43fe 3e 00		.crow1:		ld a,display_row_1 
4400 f5			.ccol1:		push af			; got row offset 
4401 6f					ld l,a 
4402 26 00				ld h,0 
4404					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4404 cd aa 23			call macro_forth_dsp_pop 
4407				endm 
# End of macro FORTH_DSP_POP
4407					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4407 cd f2 22			call macro_dsp_valuehl 
440a				endm 
# End of macro FORTH_DSP_VALUEHL
440a					; TODO save cursor col 
440a f1					pop af 
440b 85					add l		; add col offset 
440c 32 5b fa				ld (f_cursor_ptr), a 
440f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
440f cd aa 23			call macro_forth_dsp_pop 
4412				endm 
# End of macro FORTH_DSP_POP
4412			 
4412					; calculate  
4412			 
4412					NEXTW 
4412 c3 a8 24			jp macro_next 
4415				endm 
# End of macro NEXTW
4415			 
4415			 
4415			.HOME: 
4415				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
4415 41				db WORD_SYS_CORE+45             
4416 42 44			dw .SPACE            
4418 05				db 4 + 1 
4419 .. 00			db "HOME",0              
441e				endm 
# End of macro CWHEAD
441e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
441e					if DEBUG_FORTH_WORDS_KEY 
441e						DMARK "HOM" 
441e f5				push af  
441f 3a 33 44			ld a, (.dmark)  
4422 32 68 fe			ld (debug_mark),a  
4425 3a 34 44			ld a, (.dmark+1)  
4428 32 69 fe			ld (debug_mark+1),a  
442b 3a 35 44			ld a, (.dmark+2)  
442e 32 6a fe			ld (debug_mark+2),a  
4431 18 03			jr .pastdmark  
4433 ..			.dmark: db "HOM"  
4436 f1			.pastdmark: pop af  
4437			endm  
# End of macro DMARK
4437						CALLMONITOR 
4437 cd 6c fe			call debug_vector  
443a				endm  
# End of macro CALLMONITOR
443a					endif 
443a 3e 00		.home:		ld a, 0		; and home cursor 
443c 32 5b fa				ld (f_cursor_ptr), a 
443f					NEXTW 
443f c3 a8 24			jp macro_next 
4442				endm 
# End of macro NEXTW
4442			 
4442			 
4442			.SPACE: 
4442				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4442 46				db WORD_SYS_CORE+50             
4443 78 44			dw .SPACES            
4445 03				db 2 + 1 
4446 .. 00			db "BL",0              
4449				endm 
# End of macro CWHEAD
4449			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
4449					if DEBUG_FORTH_WORDS_KEY 
4449						DMARK "BL." 
4449 f5				push af  
444a 3a 5e 44			ld a, (.dmark)  
444d 32 68 fe			ld (debug_mark),a  
4450 3a 5f 44			ld a, (.dmark+1)  
4453 32 69 fe			ld (debug_mark+1),a  
4456 3a 60 44			ld a, (.dmark+2)  
4459 32 6a fe			ld (debug_mark+2),a  
445c 18 03			jr .pastdmark  
445e ..			.dmark: db "BL."  
4461 f1			.pastdmark: pop af  
4462			endm  
# End of macro DMARK
4462						CALLMONITOR 
4462 cd 6c fe			call debug_vector  
4465				endm  
# End of macro CALLMONITOR
4465					endif 
4465 3e 20				ld a, " " 
4467 32 be f1				ld (scratch),a 
446a 3e 00				ld a, 0 
446c 32 bf f1				ld (scratch+1),a 
446f 21 be f1				ld hl, scratch 
4472 cd 69 21				call forth_push_str 
4475					 
4475				       NEXTW 
4475 c3 a8 24			jp macro_next 
4478				endm 
# End of macro NEXTW
4478			 
4478			;.blstr: db " ", 0 
4478			 
4478			.SPACES: 
4478				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
4478 47				db WORD_SYS_CORE+51             
4479 13 45			dw .SCROLL            
447b 07				db 6 + 1 
447c .. 00			db "SPACES",0              
4483				endm 
# End of macro CWHEAD
4483			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4483					if DEBUG_FORTH_WORDS_KEY 
4483						DMARK "SPS" 
4483 f5				push af  
4484 3a 98 44			ld a, (.dmark)  
4487 32 68 fe			ld (debug_mark),a  
448a 3a 99 44			ld a, (.dmark+1)  
448d 32 69 fe			ld (debug_mark+1),a  
4490 3a 9a 44			ld a, (.dmark+2)  
4493 32 6a fe			ld (debug_mark+2),a  
4496 18 03			jr .pastdmark  
4498 ..			.dmark: db "SPS"  
449b f1			.pastdmark: pop af  
449c			endm  
# End of macro DMARK
449c						CALLMONITOR 
449c cd 6c fe			call debug_vector  
449f				endm  
# End of macro CALLMONITOR
449f					endif 
449f			 
449f			 
449f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
449f cd f2 22			call macro_dsp_valuehl 
44a2				endm 
# End of macro FORTH_DSP_VALUEHL
44a2			 
44a2 e5					push hl    ; u 
44a3					if DEBUG_FORTH_WORDS 
44a3						DMARK "SPA" 
44a3 f5				push af  
44a4 3a b8 44			ld a, (.dmark)  
44a7 32 68 fe			ld (debug_mark),a  
44aa 3a b9 44			ld a, (.dmark+1)  
44ad 32 69 fe			ld (debug_mark+1),a  
44b0 3a ba 44			ld a, (.dmark+2)  
44b3 32 6a fe			ld (debug_mark+2),a  
44b6 18 03			jr .pastdmark  
44b8 ..			.dmark: db "SPA"  
44bb f1			.pastdmark: pop af  
44bc			endm  
# End of macro DMARK
44bc						CALLMONITOR 
44bc cd 6c fe			call debug_vector  
44bf				endm  
# End of macro CALLMONITOR
44bf					endif 
44bf			 
44bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44bf cd aa 23			call macro_forth_dsp_pop 
44c2				endm 
# End of macro FORTH_DSP_POP
44c2 e1					pop hl 
44c3 0e 00				ld c, 0 
44c5 45					ld b, l 
44c6 21 be f1				ld hl, scratch  
44c9			 
44c9					if DEBUG_FORTH_WORDS 
44c9						DMARK "SP2" 
44c9 f5				push af  
44ca 3a de 44			ld a, (.dmark)  
44cd 32 68 fe			ld (debug_mark),a  
44d0 3a df 44			ld a, (.dmark+1)  
44d3 32 69 fe			ld (debug_mark+1),a  
44d6 3a e0 44			ld a, (.dmark+2)  
44d9 32 6a fe			ld (debug_mark+2),a  
44dc 18 03			jr .pastdmark  
44de ..			.dmark: db "SP2"  
44e1 f1			.pastdmark: pop af  
44e2			endm  
# End of macro DMARK
44e2						CALLMONITOR 
44e2 cd 6c fe			call debug_vector  
44e5				endm  
# End of macro CALLMONITOR
44e5					endif 
44e5 3e 20				ld a, ' ' 
44e7			.spaces1:	 
44e7 77					ld (hl),a 
44e8 23					inc hl 
44e9					 
44e9 10 fc				djnz .spaces1 
44eb 3e 00				ld a,0 
44ed 77					ld (hl),a 
44ee 21 be f1				ld hl, scratch 
44f1					if DEBUG_FORTH_WORDS 
44f1						DMARK "SP3" 
44f1 f5				push af  
44f2 3a 06 45			ld a, (.dmark)  
44f5 32 68 fe			ld (debug_mark),a  
44f8 3a 07 45			ld a, (.dmark+1)  
44fb 32 69 fe			ld (debug_mark+1),a  
44fe 3a 08 45			ld a, (.dmark+2)  
4501 32 6a fe			ld (debug_mark+2),a  
4504 18 03			jr .pastdmark  
4506 ..			.dmark: db "SP3"  
4509 f1			.pastdmark: pop af  
450a			endm  
# End of macro DMARK
450a						CALLMONITOR 
450a cd 6c fe			call debug_vector  
450d				endm  
# End of macro CALLMONITOR
450d					endif 
450d cd 69 21				call forth_push_str 
4510			 
4510				       NEXTW 
4510 c3 a8 24			jp macro_next 
4513				endm 
# End of macro NEXTW
4513			 
4513			 
4513			 
4513			.SCROLL: 
4513				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4513 53				db WORD_SYS_CORE+63             
4514 40 45			dw .SCROLLD            
4516 07				db 6 + 1 
4517 .. 00			db "SCROLL",0              
451e				endm 
# End of macro CWHEAD
451e			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
451e					if DEBUG_FORTH_WORDS_KEY 
451e						DMARK "SCR" 
451e f5				push af  
451f 3a 33 45			ld a, (.dmark)  
4522 32 68 fe			ld (debug_mark),a  
4525 3a 34 45			ld a, (.dmark+1)  
4528 32 69 fe			ld (debug_mark+1),a  
452b 3a 35 45			ld a, (.dmark+2)  
452e 32 6a fe			ld (debug_mark+2),a  
4531 18 03			jr .pastdmark  
4533 ..			.dmark: db "SCR"  
4536 f1			.pastdmark: pop af  
4537			endm  
# End of macro DMARK
4537						CALLMONITOR 
4537 cd 6c fe			call debug_vector  
453a				endm  
# End of macro CALLMONITOR
453a					endif 
453a			 
453a cd 5d 0d			call scroll_up 
453d			;	call update_display 
453d			 
453d					NEXTW 
453d c3 a8 24			jp macro_next 
4540				endm 
# End of macro NEXTW
4540			 
4540			 
4540			 
4540			;		; get dir 
4540			; 
4540			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4540			; 
4540			;		push hl 
4540			; 
4540			;		; destroy value TOS 
4540			; 
4540			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4540			; 
4540			;		; get count 
4540			; 
4540			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4540			; 
4540			;		push hl 
4540			; 
4540			;		; destroy value TOS 
4540			; 
4540			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4540			; 
4540			;		; one value on hl get other one back 
4540			; 
4540			;		pop bc    ; count 
4540			; 
4540			;		pop de   ; dir 
4540			; 
4540			; 
4540			;		ld b, c 
4540			; 
4540			;.scrolldir:     push bc 
4540			;		push de 
4540			; 
4540			;		ld a, 0 
4540			;		cp e 
4540			;		jr z, .scrollup  
4540			;		call scroll_down 
4540			;		jr .scrollnext 
4540			;.scrollup:	call scroll_up 
4540			; 
4540			;		 
4540			;.scrollnext: 
4540			;		pop de 
4540			;		pop bc 
4540			;		djnz .scrolldir 
4540			; 
4540			; 
4540			; 
4540			; 
4540			; 
4540			;		NEXTW 
4540			 
4540			.SCROLLD: 
4540				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4540 53				db WORD_SYS_CORE+63             
4541 6e 45			dw .ATQ            
4543 08				db 7 + 1 
4544 .. 00			db "SCROLLD",0              
454c				endm 
# End of macro CWHEAD
454c			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
454c					if DEBUG_FORTH_WORDS_KEY 
454c						DMARK "SCD" 
454c f5				push af  
454d 3a 61 45			ld a, (.dmark)  
4550 32 68 fe			ld (debug_mark),a  
4553 3a 62 45			ld a, (.dmark+1)  
4556 32 69 fe			ld (debug_mark+1),a  
4559 3a 63 45			ld a, (.dmark+2)  
455c 32 6a fe			ld (debug_mark+2),a  
455f 18 03			jr .pastdmark  
4561 ..			.dmark: db "SCD"  
4564 f1			.pastdmark: pop af  
4565			endm  
# End of macro DMARK
4565						CALLMONITOR 
4565 cd 6c fe			call debug_vector  
4568				endm  
# End of macro CALLMONITOR
4568					endif 
4568			 
4568 cd 81 0d			call scroll_down 
456b			;	call update_display 
456b			 
456b					NEXTW 
456b c3 a8 24			jp macro_next 
456e				endm 
# End of macro NEXTW
456e			 
456e			 
456e			.ATQ: 
456e				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
456e 62				db WORD_SYS_CORE+78             
456f cc 45			dw .AUTODSP            
4571 04				db 3 + 1 
4572 .. 00			db "AT@",0              
4576				endm 
# End of macro CWHEAD
4576			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4576					if DEBUG_FORTH_WORDS_KEY 
4576						DMARK "ATA" 
4576 f5				push af  
4577 3a 8b 45			ld a, (.dmark)  
457a 32 68 fe			ld (debug_mark),a  
457d 3a 8c 45			ld a, (.dmark+1)  
4580 32 69 fe			ld (debug_mark+1),a  
4583 3a 8d 45			ld a, (.dmark+2)  
4586 32 6a fe			ld (debug_mark+2),a  
4589 18 03			jr .pastdmark  
458b ..			.dmark: db "ATA"  
458e f1			.pastdmark: pop af  
458f			endm  
# End of macro DMARK
458f						CALLMONITOR 
458f cd 6c fe			call debug_vector  
4592				endm  
# End of macro CALLMONITOR
4592					endif 
4592			 
4592			 
4592					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4592 cd f2 22			call macro_dsp_valuehl 
4595				endm 
# End of macro FORTH_DSP_VALUEHL
4595			 
4595					; TODO save cursor row 
4595 7d					ld a,l 
4596 fe 02				cp 2 
4598 20 04				jr nz, .crow3aq 
459a 3e 28				ld a, display_row_2 
459c 18 12				jr .ccol1aq 
459e fe 03		.crow3aq:		cp 3 
45a0 20 04				jr nz, .crow4aq 
45a2 3e 50				ld a, display_row_3 
45a4 18 0a				jr .ccol1aq 
45a6 fe 04		.crow4aq:		cp 4 
45a8 20 04				jr nz, .crow1aq 
45aa 3e 78				ld a, display_row_4 
45ac 18 02				jr .ccol1aq 
45ae 3e 00		.crow1aq:		ld a,display_row_1 
45b0 f5			.ccol1aq:		push af			; got row offset 
45b1 6f					ld l,a 
45b2 26 00				ld h,0 
45b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45b4 cd aa 23			call macro_forth_dsp_pop 
45b7				endm 
# End of macro FORTH_DSP_POP
45b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45b7 cd f2 22			call macro_dsp_valuehl 
45ba				endm 
# End of macro FORTH_DSP_VALUEHL
45ba					; TODO save cursor col 
45ba f1					pop af 
45bb 85					add l		; add col offset 
45bc			 
45bc					; add current frame buffer address 
45bc 2a c9 fb				ld hl, (display_fb_active) 
45bf cd cf 0f				call addatohl 
45c2			 
45c2			 
45c2			 
45c2			 
45c2					; get char frame buffer location offset in hl 
45c2			 
45c2 7e					ld a,(hl) 
45c3 26 00				ld h, 0 
45c5 6f					ld l, a 
45c6			 
45c6 cd fb 20				call forth_push_numhl 
45c9			 
45c9			 
45c9					NEXTW 
45c9 c3 a8 24			jp macro_next 
45cc				endm 
# End of macro NEXTW
45cc			 
45cc			.AUTODSP: 
45cc				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
45cc 63				db WORD_SYS_CORE+79             
45cd e2 45			dw .MENU            
45cf 05				db 4 + 1 
45d0 .. 00			db "ADSP",0              
45d5				endm 
# End of macro CWHEAD
45d5			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
45d5			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
45d5			 
45d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45d5 cd f2 22			call macro_dsp_valuehl 
45d8				endm 
# End of macro FORTH_DSP_VALUEHL
45d8			 
45d8			;		push hl 
45d8			 
45d8					; destroy value TOS 
45d8			 
45d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45d8 cd aa 23			call macro_forth_dsp_pop 
45db				endm 
# End of macro FORTH_DSP_POP
45db			 
45db			;		pop hl 
45db			 
45db 7d					ld a,l 
45dc 32 39 fa				ld (cli_autodisplay), a 
45df				       NEXTW 
45df c3 a8 24			jp macro_next 
45e2				endm 
# End of macro NEXTW
45e2			 
45e2			.MENU: 
45e2				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
45e2 70				db WORD_SYS_CORE+92             
45e3 8b 46			dw .ENDDISPLAY            
45e5 05				db 4 + 1 
45e6 .. 00			db "MENU",0              
45eb				endm 
# End of macro CWHEAD
45eb			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
45eb			 
45eb			;		; get number of items on the stack 
45eb			; 
45eb				 
45eb					FORTH_DSP_VALUEHL 
45eb cd f2 22			call macro_dsp_valuehl 
45ee				endm 
# End of macro FORTH_DSP_VALUEHL
45ee				 
45ee					if DEBUG_FORTH_WORDS_KEY 
45ee						DMARK "MNU" 
45ee f5				push af  
45ef 3a 03 46			ld a, (.dmark)  
45f2 32 68 fe			ld (debug_mark),a  
45f5 3a 04 46			ld a, (.dmark+1)  
45f8 32 69 fe			ld (debug_mark+1),a  
45fb 3a 05 46			ld a, (.dmark+2)  
45fe 32 6a fe			ld (debug_mark+2),a  
4601 18 03			jr .pastdmark  
4603 ..			.dmark: db "MNU"  
4606 f1			.pastdmark: pop af  
4607			endm  
# End of macro DMARK
4607						CALLMONITOR 
4607 cd 6c fe			call debug_vector  
460a				endm  
# End of macro CALLMONITOR
460a					endif 
460a			 
460a 45					ld b, l	 
460b 05					dec b 
460c			 
460c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
460c cd aa 23			call macro_forth_dsp_pop 
460f				endm 
# End of macro FORTH_DSP_POP
460f			 
460f			 
460f					; go directly through the stack to pluck out the string pointers and build an array 
460f			 
460f			;		FORTH_DSP 
460f			 
460f					; hl contains top most stack item 
460f				 
460f 11 be f1				ld de, scratch 
4612			 
4612			.mbuild: 
4612			 
4612					FORTH_DSP_VALUEHL 
4612 cd f2 22			call macro_dsp_valuehl 
4615				endm 
# End of macro FORTH_DSP_VALUEHL
4615			 
4615					if DEBUG_FORTH_WORDS 
4615						DMARK "MN3" 
4615 f5				push af  
4616 3a 2a 46			ld a, (.dmark)  
4619 32 68 fe			ld (debug_mark),a  
461c 3a 2b 46			ld a, (.dmark+1)  
461f 32 69 fe			ld (debug_mark+1),a  
4622 3a 2c 46			ld a, (.dmark+2)  
4625 32 6a fe			ld (debug_mark+2),a  
4628 18 03			jr .pastdmark  
462a ..			.dmark: db "MN3"  
462d f1			.pastdmark: pop af  
462e			endm  
# End of macro DMARK
462e						CALLMONITOR 
462e cd 6c fe			call debug_vector  
4631				endm  
# End of macro CALLMONITOR
4631					endif 
4631 eb					ex de, hl 
4632 73					ld (hl), e 
4633 23					inc hl 
4634 72					ld (hl), d 
4635 23					inc hl 
4636 eb					ex de, hl 
4637			 
4637					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4637 cd aa 23			call macro_forth_dsp_pop 
463a				endm 
# End of macro FORTH_DSP_POP
463a			 
463a 10 d6				djnz .mbuild 
463c			 
463c					; done add term 
463c			 
463c eb					ex de, hl 
463d 36 00				ld (hl), 0 
463f 23					inc hl 
4640 36 00				ld (hl), 0 
4642			 
4642				 
4642					 
4642 21 be f1				ld hl, scratch 
4645			 
4645					if DEBUG_FORTH_WORDS 
4645						DMARK "MNx" 
4645 f5				push af  
4646 3a 5a 46			ld a, (.dmark)  
4649 32 68 fe			ld (debug_mark),a  
464c 3a 5b 46			ld a, (.dmark+1)  
464f 32 69 fe			ld (debug_mark+1),a  
4652 3a 5c 46			ld a, (.dmark+2)  
4655 32 6a fe			ld (debug_mark+2),a  
4658 18 03			jr .pastdmark  
465a ..			.dmark: db "MNx"  
465d f1			.pastdmark: pop af  
465e			endm  
# End of macro DMARK
465e						CALLMONITOR 
465e cd 6c fe			call debug_vector  
4661				endm  
# End of macro CALLMONITOR
4661					endif 
4661			 
4661			 
4661			 
4661 3e 00				ld a, 0 
4663 cd cc 0d				call menu 
4666			 
4666			 
4666 6f					ld l, a 
4667 26 00				ld h, 0 
4669			 
4669					if DEBUG_FORTH_WORDS 
4669						DMARK "MNr" 
4669 f5				push af  
466a 3a 7e 46			ld a, (.dmark)  
466d 32 68 fe			ld (debug_mark),a  
4670 3a 7f 46			ld a, (.dmark+1)  
4673 32 69 fe			ld (debug_mark+1),a  
4676 3a 80 46			ld a, (.dmark+2)  
4679 32 6a fe			ld (debug_mark+2),a  
467c 18 03			jr .pastdmark  
467e ..			.dmark: db "MNr"  
4681 f1			.pastdmark: pop af  
4682			endm  
# End of macro DMARK
4682						CALLMONITOR 
4682 cd 6c fe			call debug_vector  
4685				endm  
# End of macro CALLMONITOR
4685					endif 
4685			 
4685 cd fb 20				call forth_push_numhl 
4688			 
4688			 
4688			 
4688			 
4688				       NEXTW 
4688 c3 a8 24			jp macro_next 
468b				endm 
# End of macro NEXTW
468b			 
468b			 
468b			.ENDDISPLAY: 
468b			 
468b			; eof 
# End of file forth_words_display.asm
468b			include "forth_words_str.asm" 
468b			 
468b			; | ## String Words 
468b			 
468b			.PTR:   
468b			 
468b				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
468b 48				db WORD_SYS_CORE+52             
468c b8 46			dw .STYPE            
468e 04				db 3 + 1 
468f .. 00			db "PTR",0              
4693				endm 
# End of macro CWHEAD
4693			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4693			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4693			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4693			 
4693					if DEBUG_FORTH_WORDS_KEY 
4693						DMARK "PTR" 
4693 f5				push af  
4694 3a a8 46			ld a, (.dmark)  
4697 32 68 fe			ld (debug_mark),a  
469a 3a a9 46			ld a, (.dmark+1)  
469d 32 69 fe			ld (debug_mark+1),a  
46a0 3a aa 46			ld a, (.dmark+2)  
46a3 32 6a fe			ld (debug_mark+2),a  
46a6 18 03			jr .pastdmark  
46a8 ..			.dmark: db "PTR"  
46ab f1			.pastdmark: pop af  
46ac			endm  
# End of macro DMARK
46ac						CALLMONITOR 
46ac cd 6c fe			call debug_vector  
46af				endm  
# End of macro CALLMONITOR
46af					endif 
46af					FORTH_DSP_VALUEHL 
46af cd f2 22			call macro_dsp_valuehl 
46b2				endm 
# End of macro FORTH_DSP_VALUEHL
46b2 cd fb 20				call forth_push_numhl 
46b5			 
46b5			 
46b5					NEXTW 
46b5 c3 a8 24			jp macro_next 
46b8				endm 
# End of macro NEXTW
46b8			.STYPE: 
46b8				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
46b8 48				db WORD_SYS_CORE+52             
46b9 07 47			dw .UPPER            
46bb 06				db 5 + 1 
46bc .. 00			db "STYPE",0              
46c2				endm 
# End of macro CWHEAD
46c2			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
46c2					if DEBUG_FORTH_WORDS_KEY 
46c2						DMARK "STY" 
46c2 f5				push af  
46c3 3a d7 46			ld a, (.dmark)  
46c6 32 68 fe			ld (debug_mark),a  
46c9 3a d8 46			ld a, (.dmark+1)  
46cc 32 69 fe			ld (debug_mark+1),a  
46cf 3a d9 46			ld a, (.dmark+2)  
46d2 32 6a fe			ld (debug_mark+2),a  
46d5 18 03			jr .pastdmark  
46d7 ..			.dmark: db "STY"  
46da f1			.pastdmark: pop af  
46db			endm  
# End of macro DMARK
46db						CALLMONITOR 
46db cd 6c fe			call debug_vector  
46de				endm  
# End of macro CALLMONITOR
46de					endif 
46de					FORTH_DSP 
46de cd b8 22			call macro_forth_dsp 
46e1				endm 
# End of macro FORTH_DSP
46e1					;v5 FORTH_DSP_VALUE 
46e1			 
46e1 7e					ld a, (hl) 
46e2			 
46e2 f5					push af 
46e3			 
46e3			; Dont destroy TOS		FORTH_DSP_POP 
46e3			 
46e3 f1					pop af 
46e4			 
46e4 fe 01				cp DS_TYPE_STR 
46e6 28 09				jr z, .typestr 
46e8			 
46e8 fe 02				cp DS_TYPE_INUM 
46ea 28 0a				jr z, .typeinum 
46ec			 
46ec 21 05 47				ld hl, .tna 
46ef 18 0a				jr .tpush 
46f1			 
46f1 21 01 47		.typestr:	ld hl, .tstr 
46f4 18 05				jr .tpush 
46f6 21 03 47		.typeinum:	ld hl, .tinum 
46f9 18 00				jr .tpush 
46fb			 
46fb			.tpush: 
46fb			 
46fb cd 69 21				call forth_push_str 
46fe			 
46fe					NEXTW 
46fe c3 a8 24			jp macro_next 
4701				endm 
# End of macro NEXTW
4701 .. 00		.tstr:	db "s",0 
4703 .. 00		.tinum:  db "i",0 
4705 .. 00		.tna:   db "?", 0 
4707			 
4707			 
4707			.UPPER: 
4707				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4707 48				db WORD_SYS_CORE+52             
4708 42 47			dw .LOWER            
470a 06				db 5 + 1 
470b .. 00			db "UPPER",0              
4711				endm 
# End of macro CWHEAD
4711			; | UPPER ( s -- s ) Upper case string s  | DONE 
4711					if DEBUG_FORTH_WORDS_KEY 
4711						DMARK "UPR" 
4711 f5				push af  
4712 3a 26 47			ld a, (.dmark)  
4715 32 68 fe			ld (debug_mark),a  
4718 3a 27 47			ld a, (.dmark+1)  
471b 32 69 fe			ld (debug_mark+1),a  
471e 3a 28 47			ld a, (.dmark+2)  
4721 32 6a fe			ld (debug_mark+2),a  
4724 18 03			jr .pastdmark  
4726 ..			.dmark: db "UPR"  
4729 f1			.pastdmark: pop af  
472a			endm  
# End of macro DMARK
472a						CALLMONITOR 
472a cd 6c fe			call debug_vector  
472d				endm  
# End of macro CALLMONITOR
472d					endif 
472d			 
472d					FORTH_DSP 
472d cd b8 22			call macro_forth_dsp 
4730				endm 
# End of macro FORTH_DSP
4730					 
4730			; TODO check is string type 
4730			 
4730					FORTH_DSP_VALUEHL 
4730 cd f2 22			call macro_dsp_valuehl 
4733				endm 
# End of macro FORTH_DSP_VALUEHL
4733			; get pointer to string in hl 
4733			 
4733 7e			.toup:		ld a, (hl) 
4734 fe 00				cp 0 
4736 28 07				jr z, .toupdone 
4738			 
4738 cd 3c 13				call to_upper 
473b			 
473b 77					ld (hl), a 
473c 23					inc hl 
473d 18 f4				jr .toup 
473f			 
473f					 
473f			 
473f			 
473f			; for each char convert to upper 
473f					 
473f			.toupdone: 
473f			 
473f			 
473f					NEXTW 
473f c3 a8 24			jp macro_next 
4742				endm 
# End of macro NEXTW
4742			.LOWER: 
4742				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4742 48				db WORD_SYS_CORE+52             
4743 7d 47			dw .TCASE            
4745 06				db 5 + 1 
4746 .. 00			db "LOWER",0              
474c				endm 
# End of macro CWHEAD
474c			; | LOWER ( s -- s ) Lower case string s  | DONE 
474c					if DEBUG_FORTH_WORDS_KEY 
474c						DMARK "LWR" 
474c f5				push af  
474d 3a 61 47			ld a, (.dmark)  
4750 32 68 fe			ld (debug_mark),a  
4753 3a 62 47			ld a, (.dmark+1)  
4756 32 69 fe			ld (debug_mark+1),a  
4759 3a 63 47			ld a, (.dmark+2)  
475c 32 6a fe			ld (debug_mark+2),a  
475f 18 03			jr .pastdmark  
4761 ..			.dmark: db "LWR"  
4764 f1			.pastdmark: pop af  
4765			endm  
# End of macro DMARK
4765						CALLMONITOR 
4765 cd 6c fe			call debug_vector  
4768				endm  
# End of macro CALLMONITOR
4768					endif 
4768			 
4768					FORTH_DSP 
4768 cd b8 22			call macro_forth_dsp 
476b				endm 
# End of macro FORTH_DSP
476b					 
476b			; TODO check is string type 
476b			 
476b					FORTH_DSP_VALUEHL 
476b cd f2 22			call macro_dsp_valuehl 
476e				endm 
# End of macro FORTH_DSP_VALUEHL
476e			; get pointer to string in hl 
476e			 
476e 7e			.tolow:		ld a, (hl) 
476f fe 00				cp 0 
4771 28 07				jr z, .tolowdone 
4773			 
4773 cd 45 13				call to_lower 
4776			 
4776 77					ld (hl), a 
4777 23					inc hl 
4778 18 f4				jr .tolow 
477a			 
477a					 
477a			 
477a			 
477a			; for each char convert to low 
477a					 
477a			.tolowdone: 
477a					NEXTW 
477a c3 a8 24			jp macro_next 
477d				endm 
# End of macro NEXTW
477d			.TCASE: 
477d				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
477d 48				db WORD_SYS_CORE+52             
477e b3 48			dw .SUBSTR            
4780 06				db 5 + 1 
4781 .. 00			db "TCASE",0              
4787				endm 
# End of macro CWHEAD
4787			; | TCASE ( s -- s ) Title case string s  | DONE 
4787					if DEBUG_FORTH_WORDS_KEY 
4787						DMARK "TCS" 
4787 f5				push af  
4788 3a 9c 47			ld a, (.dmark)  
478b 32 68 fe			ld (debug_mark),a  
478e 3a 9d 47			ld a, (.dmark+1)  
4791 32 69 fe			ld (debug_mark+1),a  
4794 3a 9e 47			ld a, (.dmark+2)  
4797 32 6a fe			ld (debug_mark+2),a  
479a 18 03			jr .pastdmark  
479c ..			.dmark: db "TCS"  
479f f1			.pastdmark: pop af  
47a0			endm  
# End of macro DMARK
47a0						CALLMONITOR 
47a0 cd 6c fe			call debug_vector  
47a3				endm  
# End of macro CALLMONITOR
47a3					endif 
47a3			 
47a3					FORTH_DSP 
47a3 cd b8 22			call macro_forth_dsp 
47a6				endm 
# End of macro FORTH_DSP
47a6					 
47a6			; TODO check is string type 
47a6			 
47a6					FORTH_DSP_VALUEHL 
47a6 cd f2 22			call macro_dsp_valuehl 
47a9				endm 
# End of macro FORTH_DSP_VALUEHL
47a9			; get pointer to string in hl 
47a9			 
47a9					if DEBUG_FORTH_WORDS 
47a9						DMARK "TC1" 
47a9 f5				push af  
47aa 3a be 47			ld a, (.dmark)  
47ad 32 68 fe			ld (debug_mark),a  
47b0 3a bf 47			ld a, (.dmark+1)  
47b3 32 69 fe			ld (debug_mark+1),a  
47b6 3a c0 47			ld a, (.dmark+2)  
47b9 32 6a fe			ld (debug_mark+2),a  
47bc 18 03			jr .pastdmark  
47be ..			.dmark: db "TC1"  
47c1 f1			.pastdmark: pop af  
47c2			endm  
# End of macro DMARK
47c2						CALLMONITOR 
47c2 cd 6c fe			call debug_vector  
47c5				endm  
# End of macro CALLMONITOR
47c5					endif 
47c5			 
47c5					; first time in turn to upper case first char 
47c5			 
47c5 7e					ld a, (hl) 
47c6 c3 50 48				jp .totsiptou 
47c9			 
47c9			 
47c9 7e			.tot:		ld a, (hl) 
47ca fe 00				cp 0 
47cc ca 94 48				jp z, .totdone 
47cf			 
47cf					if DEBUG_FORTH_WORDS 
47cf						DMARK "TC2" 
47cf f5				push af  
47d0 3a e4 47			ld a, (.dmark)  
47d3 32 68 fe			ld (debug_mark),a  
47d6 3a e5 47			ld a, (.dmark+1)  
47d9 32 69 fe			ld (debug_mark+1),a  
47dc 3a e6 47			ld a, (.dmark+2)  
47df 32 6a fe			ld (debug_mark+2),a  
47e2 18 03			jr .pastdmark  
47e4 ..			.dmark: db "TC2"  
47e7 f1			.pastdmark: pop af  
47e8			endm  
# End of macro DMARK
47e8						CALLMONITOR 
47e8 cd 6c fe			call debug_vector  
47eb				endm  
# End of macro CALLMONITOR
47eb					endif 
47eb					; check to see if current char is a space 
47eb			 
47eb fe 20				cp ' ' 
47ed 28 21				jr z, .totsp 
47ef cd 45 13				call to_lower 
47f2					if DEBUG_FORTH_WORDS 
47f2						DMARK "TC3" 
47f2 f5				push af  
47f3 3a 07 48			ld a, (.dmark)  
47f6 32 68 fe			ld (debug_mark),a  
47f9 3a 08 48			ld a, (.dmark+1)  
47fc 32 69 fe			ld (debug_mark+1),a  
47ff 3a 09 48			ld a, (.dmark+2)  
4802 32 6a fe			ld (debug_mark+2),a  
4805 18 03			jr .pastdmark  
4807 ..			.dmark: db "TC3"  
480a f1			.pastdmark: pop af  
480b			endm  
# End of macro DMARK
480b						CALLMONITOR 
480b cd 6c fe			call debug_vector  
480e				endm  
# End of macro CALLMONITOR
480e					endif 
480e 18 63				jr .totnxt 
4810			 
4810			.totsp:         ; on a space, find next char which should be upper 
4810			 
4810					if DEBUG_FORTH_WORDS 
4810						DMARK "TC4" 
4810 f5				push af  
4811 3a 25 48			ld a, (.dmark)  
4814 32 68 fe			ld (debug_mark),a  
4817 3a 26 48			ld a, (.dmark+1)  
481a 32 69 fe			ld (debug_mark+1),a  
481d 3a 27 48			ld a, (.dmark+2)  
4820 32 6a fe			ld (debug_mark+2),a  
4823 18 03			jr .pastdmark  
4825 ..			.dmark: db "TC4"  
4828 f1			.pastdmark: pop af  
4829			endm  
# End of macro DMARK
4829						CALLMONITOR 
4829 cd 6c fe			call debug_vector  
482c				endm  
# End of macro CALLMONITOR
482c					endif 
482c					;; 
482c			 
482c fe 20				cp ' ' 
482e 20 20				jr nz, .totsiptou 
4830 23					inc hl 
4831 7e					ld a, (hl) 
4832					if DEBUG_FORTH_WORDS 
4832						DMARK "TC5" 
4832 f5				push af  
4833 3a 47 48			ld a, (.dmark)  
4836 32 68 fe			ld (debug_mark),a  
4839 3a 48 48			ld a, (.dmark+1)  
483c 32 69 fe			ld (debug_mark+1),a  
483f 3a 49 48			ld a, (.dmark+2)  
4842 32 6a fe			ld (debug_mark+2),a  
4845 18 03			jr .pastdmark  
4847 ..			.dmark: db "TC5"  
484a f1			.pastdmark: pop af  
484b			endm  
# End of macro DMARK
484b						CALLMONITOR 
484b cd 6c fe			call debug_vector  
484e				endm  
# End of macro CALLMONITOR
484e					endif 
484e 18 c0				jr .totsp 
4850 fe 00		.totsiptou:    cp 0 
4852 28 40				jr z, .totdone 
4854					; not space and not zero term so upper case it 
4854 cd 3c 13				call to_upper 
4857			 
4857					if DEBUG_FORTH_WORDS 
4857						DMARK "TC6" 
4857 f5				push af  
4858 3a 6c 48			ld a, (.dmark)  
485b 32 68 fe			ld (debug_mark),a  
485e 3a 6d 48			ld a, (.dmark+1)  
4861 32 69 fe			ld (debug_mark+1),a  
4864 3a 6e 48			ld a, (.dmark+2)  
4867 32 6a fe			ld (debug_mark+2),a  
486a 18 03			jr .pastdmark  
486c ..			.dmark: db "TC6"  
486f f1			.pastdmark: pop af  
4870			endm  
# End of macro DMARK
4870						CALLMONITOR 
4870 cd 6c fe			call debug_vector  
4873				endm  
# End of macro CALLMONITOR
4873					endif 
4873			 
4873			 
4873			.totnxt: 
4873			 
4873 77					ld (hl), a 
4874 23					inc hl 
4875					if DEBUG_FORTH_WORDS 
4875						DMARK "TC7" 
4875 f5				push af  
4876 3a 8a 48			ld a, (.dmark)  
4879 32 68 fe			ld (debug_mark),a  
487c 3a 8b 48			ld a, (.dmark+1)  
487f 32 69 fe			ld (debug_mark+1),a  
4882 3a 8c 48			ld a, (.dmark+2)  
4885 32 6a fe			ld (debug_mark+2),a  
4888 18 03			jr .pastdmark  
488a ..			.dmark: db "TC7"  
488d f1			.pastdmark: pop af  
488e			endm  
# End of macro DMARK
488e						CALLMONITOR 
488e cd 6c fe			call debug_vector  
4891				endm  
# End of macro CALLMONITOR
4891					endif 
4891 c3 c9 47				jp .tot 
4894			 
4894					 
4894			 
4894			 
4894			; for each char convert to low 
4894					 
4894			.totdone: 
4894					if DEBUG_FORTH_WORDS 
4894						DMARK "TCd" 
4894 f5				push af  
4895 3a a9 48			ld a, (.dmark)  
4898 32 68 fe			ld (debug_mark),a  
489b 3a aa 48			ld a, (.dmark+1)  
489e 32 69 fe			ld (debug_mark+1),a  
48a1 3a ab 48			ld a, (.dmark+2)  
48a4 32 6a fe			ld (debug_mark+2),a  
48a7 18 03			jr .pastdmark  
48a9 ..			.dmark: db "TCd"  
48ac f1			.pastdmark: pop af  
48ad			endm  
# End of macro DMARK
48ad						CALLMONITOR 
48ad cd 6c fe			call debug_vector  
48b0				endm  
# End of macro CALLMONITOR
48b0					endif 
48b0					NEXTW 
48b0 c3 a8 24			jp macro_next 
48b3				endm 
# End of macro NEXTW
48b3			 
48b3			.SUBSTR: 
48b3				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
48b3 48				db WORD_SYS_CORE+52             
48b4 11 49			dw .LEFT            
48b6 07				db 6 + 1 
48b7 .. 00			db "SUBSTR",0              
48be				endm 
# End of macro CWHEAD
48be			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
48be			 
48be					if DEBUG_FORTH_WORDS_KEY 
48be						DMARK "SST" 
48be f5				push af  
48bf 3a d3 48			ld a, (.dmark)  
48c2 32 68 fe			ld (debug_mark),a  
48c5 3a d4 48			ld a, (.dmark+1)  
48c8 32 69 fe			ld (debug_mark+1),a  
48cb 3a d5 48			ld a, (.dmark+2)  
48ce 32 6a fe			ld (debug_mark+2),a  
48d1 18 03			jr .pastdmark  
48d3 ..			.dmark: db "SST"  
48d6 f1			.pastdmark: pop af  
48d7			endm  
# End of macro DMARK
48d7						CALLMONITOR 
48d7 cd 6c fe			call debug_vector  
48da				endm  
# End of macro CALLMONITOR
48da					endif 
48da			; TODO check string type 
48da					FORTH_DSP_VALUEHL 
48da cd f2 22			call macro_dsp_valuehl 
48dd				endm 
# End of macro FORTH_DSP_VALUEHL
48dd			 
48dd e5					push hl      ; string length 
48de			 
48de					FORTH_DSP_POP 
48de cd aa 23			call macro_forth_dsp_pop 
48e1				endm 
# End of macro FORTH_DSP_POP
48e1			 
48e1					FORTH_DSP_VALUEHL 
48e1 cd f2 22			call macro_dsp_valuehl 
48e4				endm 
# End of macro FORTH_DSP_VALUEHL
48e4			 
48e4 e5					push hl     ; start char 
48e5			 
48e5					FORTH_DSP_POP 
48e5 cd aa 23			call macro_forth_dsp_pop 
48e8				endm 
# End of macro FORTH_DSP_POP
48e8			 
48e8			 
48e8					FORTH_DSP_VALUE 
48e8 cd db 22			call macro_forth_dsp_value 
48eb				endm 
# End of macro FORTH_DSP_VALUE
48eb			 
48eb d1					pop de    ; get start post offset 
48ec			 
48ec 19					add hl, de    ; starting offset 
48ed			 
48ed c1					pop bc 
48ee c5					push bc      ; grab size of string 
48ef			 
48ef e5					push hl    ; save string start  
48f0			 
48f0 26 00				ld h, 0 
48f2 69					ld l, c 
48f3 23					inc hl 
48f4 23					inc hl 
48f5			 
48f5 cd 96 14				call malloc 
48f8				if DEBUG_FORTH_MALLOC_GUARD 
48f8 cc 3e 5e				call z,malloc_error 
48fb				endif 
48fb			 
48fb eb					ex de, hl      ; save malloc area for string copy 
48fc e1					pop hl    ; get back source 
48fd c1					pop bc    ; get length of string back 
48fe			 
48fe d5					push de    ; save malloc area for after we push 
48ff ed b0				ldir     ; copy substr 
4901			 
4901			 
4901 eb					ex de, hl 
4902 3e 00				ld a, 0 
4904 77					ld (hl), a   ; term substr 
4905			 
4905					 
4905 e1					pop hl    ; get malloc so we can push it 
4906 e5					push hl   ; save so we can free it afterwards 
4907			 
4907 cd 69 21				call forth_push_str 
490a			 
490a e1					pop hl 
490b cd 60 15				call free 
490e			 
490e					 
490e					 
490e			 
490e			 
490e					NEXTW 
490e c3 a8 24			jp macro_next 
4911				endm 
# End of macro NEXTW
4911			 
4911			.LEFT: 
4911				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4911 48				db WORD_SYS_CORE+52             
4912 39 49			dw .RIGHT            
4914 05				db 4 + 1 
4915 .. 00			db "LEFT",0              
491a				endm 
# End of macro CWHEAD
491a			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
491a					if DEBUG_FORTH_WORDS_KEY 
491a						DMARK "LEF" 
491a f5				push af  
491b 3a 2f 49			ld a, (.dmark)  
491e 32 68 fe			ld (debug_mark),a  
4921 3a 30 49			ld a, (.dmark+1)  
4924 32 69 fe			ld (debug_mark+1),a  
4927 3a 31 49			ld a, (.dmark+2)  
492a 32 6a fe			ld (debug_mark+2),a  
492d 18 03			jr .pastdmark  
492f ..			.dmark: db "LEF"  
4932 f1			.pastdmark: pop af  
4933			endm  
# End of macro DMARK
4933						CALLMONITOR 
4933 cd 6c fe			call debug_vector  
4936				endm  
# End of macro CALLMONITOR
4936					endif 
4936			 
4936					NEXTW 
4936 c3 a8 24			jp macro_next 
4939				endm 
# End of macro NEXTW
4939			.RIGHT: 
4939				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4939 48				db WORD_SYS_CORE+52             
493a 62 49			dw .STR2NUM            
493c 06				db 5 + 1 
493d .. 00			db "RIGHT",0              
4943				endm 
# End of macro CWHEAD
4943			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4943					if DEBUG_FORTH_WORDS_KEY 
4943						DMARK "RIG" 
4943 f5				push af  
4944 3a 58 49			ld a, (.dmark)  
4947 32 68 fe			ld (debug_mark),a  
494a 3a 59 49			ld a, (.dmark+1)  
494d 32 69 fe			ld (debug_mark+1),a  
4950 3a 5a 49			ld a, (.dmark+2)  
4953 32 6a fe			ld (debug_mark+2),a  
4956 18 03			jr .pastdmark  
4958 ..			.dmark: db "RIG"  
495b f1			.pastdmark: pop af  
495c			endm  
# End of macro DMARK
495c						CALLMONITOR 
495c cd 6c fe			call debug_vector  
495f				endm  
# End of macro CALLMONITOR
495f					endif 
495f			 
495f					NEXTW 
495f c3 a8 24			jp macro_next 
4962				endm 
# End of macro NEXTW
4962			 
4962			 
4962			.STR2NUM: 
4962				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4962 48				db WORD_SYS_CORE+52             
4963 ee 49			dw .NUM2STR            
4965 08				db 7 + 1 
4966 .. 00			db "STR2NUM",0              
496e				endm 
# End of macro CWHEAD
496e			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
496e			 
496e			 
496e			; TODO STR type check to do 
496e					if DEBUG_FORTH_WORDS_KEY 
496e						DMARK "S2N" 
496e f5				push af  
496f 3a 83 49			ld a, (.dmark)  
4972 32 68 fe			ld (debug_mark),a  
4975 3a 84 49			ld a, (.dmark+1)  
4978 32 69 fe			ld (debug_mark+1),a  
497b 3a 85 49			ld a, (.dmark+2)  
497e 32 6a fe			ld (debug_mark+2),a  
4981 18 03			jr .pastdmark  
4983 ..			.dmark: db "S2N"  
4986 f1			.pastdmark: pop af  
4987			endm  
# End of macro DMARK
4987						CALLMONITOR 
4987 cd 6c fe			call debug_vector  
498a				endm  
# End of macro CALLMONITOR
498a					endif 
498a			 
498a					;FORTH_DSP 
498a					FORTH_DSP_VALUE 
498a cd db 22			call macro_forth_dsp_value 
498d				endm 
# End of macro FORTH_DSP_VALUE
498d					;inc hl 
498d			 
498d eb					ex de, hl 
498e					if DEBUG_FORTH_WORDS 
498e						DMARK "S2a" 
498e f5				push af  
498f 3a a3 49			ld a, (.dmark)  
4992 32 68 fe			ld (debug_mark),a  
4995 3a a4 49			ld a, (.dmark+1)  
4998 32 69 fe			ld (debug_mark+1),a  
499b 3a a5 49			ld a, (.dmark+2)  
499e 32 6a fe			ld (debug_mark+2),a  
49a1 18 03			jr .pastdmark  
49a3 ..			.dmark: db "S2a"  
49a6 f1			.pastdmark: pop af  
49a7			endm  
# End of macro DMARK
49a7						CALLMONITOR 
49a7 cd 6c fe			call debug_vector  
49aa				endm  
# End of macro CALLMONITOR
49aa					endif 
49aa cd c4 13				call string_to_uint16 
49ad			 
49ad					if DEBUG_FORTH_WORDS 
49ad						DMARK "S2b" 
49ad f5				push af  
49ae 3a c2 49			ld a, (.dmark)  
49b1 32 68 fe			ld (debug_mark),a  
49b4 3a c3 49			ld a, (.dmark+1)  
49b7 32 69 fe			ld (debug_mark+1),a  
49ba 3a c4 49			ld a, (.dmark+2)  
49bd 32 6a fe			ld (debug_mark+2),a  
49c0 18 03			jr .pastdmark  
49c2 ..			.dmark: db "S2b"  
49c5 f1			.pastdmark: pop af  
49c6			endm  
# End of macro DMARK
49c6						CALLMONITOR 
49c6 cd 6c fe			call debug_vector  
49c9				endm  
# End of macro CALLMONITOR
49c9					endif 
49c9			;		push hl 
49c9					FORTH_DSP_POP 
49c9 cd aa 23			call macro_forth_dsp_pop 
49cc				endm 
# End of macro FORTH_DSP_POP
49cc			;		pop hl 
49cc					 
49cc					if DEBUG_FORTH_WORDS 
49cc						DMARK "S2b" 
49cc f5				push af  
49cd 3a e1 49			ld a, (.dmark)  
49d0 32 68 fe			ld (debug_mark),a  
49d3 3a e2 49			ld a, (.dmark+1)  
49d6 32 69 fe			ld (debug_mark+1),a  
49d9 3a e3 49			ld a, (.dmark+2)  
49dc 32 6a fe			ld (debug_mark+2),a  
49df 18 03			jr .pastdmark  
49e1 ..			.dmark: db "S2b"  
49e4 f1			.pastdmark: pop af  
49e5			endm  
# End of macro DMARK
49e5						CALLMONITOR 
49e5 cd 6c fe			call debug_vector  
49e8				endm  
# End of macro CALLMONITOR
49e8					endif 
49e8 cd fb 20				call forth_push_numhl	 
49eb			 
49eb				 
49eb				       NEXTW 
49eb c3 a8 24			jp macro_next 
49ee				endm 
# End of macro NEXTW
49ee			.NUM2STR: 
49ee				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
49ee 48				db WORD_SYS_CORE+52             
49ef fd 49			dw .CONCAT            
49f1 08				db 7 + 1 
49f2 .. 00			db "NUM2STR",0              
49fa				endm 
# End of macro CWHEAD
49fa			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
49fa			 
49fa			;		; malloc a string to target 
49fa			;		ld hl, 10     ; TODO max string size should be fine 
49fa			;		call malloc 
49fa			;		push hl    ; save malloc location 
49fa			; 
49fa			; 
49fa			;; TODO check int type 
49fa			;		FORTH_DSP_VALUEHL 
49fa			;		ld a, l 
49fa			;		call DispAToASCII   
49fa			;;TODO need to chage above call to dump into string 
49fa			; 
49fa			; 
49fa			 
49fa				       NEXTW 
49fa c3 a8 24			jp macro_next 
49fd				endm 
# End of macro NEXTW
49fd			 
49fd			.CONCAT: 
49fd				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
49fd 48				db WORD_SYS_CORE+52             
49fe b0 4a			dw .FIND            
4a00 07				db 6 + 1 
4a01 .. 00			db "CONCAT",0              
4a08				endm 
# End of macro CWHEAD
4a08			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4a08			 
4a08			; TODO check string type 
4a08			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4a08			 
4a08					if DEBUG_FORTH_WORDS_KEY 
4a08						DMARK "CON" 
4a08 f5				push af  
4a09 3a 1d 4a			ld a, (.dmark)  
4a0c 32 68 fe			ld (debug_mark),a  
4a0f 3a 1e 4a			ld a, (.dmark+1)  
4a12 32 69 fe			ld (debug_mark+1),a  
4a15 3a 1f 4a			ld a, (.dmark+2)  
4a18 32 6a fe			ld (debug_mark+2),a  
4a1b 18 03			jr .pastdmark  
4a1d ..			.dmark: db "CON"  
4a20 f1			.pastdmark: pop af  
4a21			endm  
# End of macro DMARK
4a21						CALLMONITOR 
4a21 cd 6c fe			call debug_vector  
4a24				endm  
# End of macro CALLMONITOR
4a24					endif 
4a24			 
4a24			 
4a24					FORTH_DSP_VALUE 
4a24 cd db 22			call macro_forth_dsp_value 
4a27				endm 
# End of macro FORTH_DSP_VALUE
4a27 e5					push hl   ; s2 
4a28			 
4a28					FORTH_DSP_POP 
4a28 cd aa 23			call macro_forth_dsp_pop 
4a2b				endm 
# End of macro FORTH_DSP_POP
4a2b			 
4a2b					FORTH_DSP_VALUE 
4a2b cd db 22			call macro_forth_dsp_value 
4a2e				endm 
# End of macro FORTH_DSP_VALUE
4a2e			 
4a2e e5					push hl   ; s1 
4a2f			 
4a2f					FORTH_DSP_POP 
4a2f cd aa 23			call macro_forth_dsp_pop 
4a32				endm 
# End of macro FORTH_DSP_POP
4a32					 
4a32			 
4a32					; copy s1 
4a32			 
4a32				 
4a32					; save ptr 
4a32 e1					pop hl  
4a33 e5					push hl 
4a34 3e 00				ld a, 0 
4a36 cd 38 14				call strlent 
4a39					;inc hl    ; zer0 
4a39 06 00				ld b, 0 
4a3b 4d					ld c, l 
4a3c e1					pop hl		 
4a3d 11 be f1				ld de, scratch	 
4a40					if DEBUG_FORTH_WORDS 
4a40						DMARK "CO1" 
4a40 f5				push af  
4a41 3a 55 4a			ld a, (.dmark)  
4a44 32 68 fe			ld (debug_mark),a  
4a47 3a 56 4a			ld a, (.dmark+1)  
4a4a 32 69 fe			ld (debug_mark+1),a  
4a4d 3a 57 4a			ld a, (.dmark+2)  
4a50 32 6a fe			ld (debug_mark+2),a  
4a53 18 03			jr .pastdmark  
4a55 ..			.dmark: db "CO1"  
4a58 f1			.pastdmark: pop af  
4a59			endm  
# End of macro DMARK
4a59						CALLMONITOR 
4a59 cd 6c fe			call debug_vector  
4a5c				endm  
# End of macro CALLMONITOR
4a5c					endif 
4a5c ed b0				ldir 
4a5e			 
4a5e e1					pop hl 
4a5f e5					push hl 
4a60 d5					push de 
4a61			 
4a61			 
4a61 3e 00				ld a, 0 
4a63 cd 38 14				call strlent 
4a66 23					inc hl    ; zer0 
4a67 23					inc hl 
4a68 06 00				ld b, 0 
4a6a 4d					ld c, l 
4a6b d1					pop de 
4a6c e1					pop hl		 
4a6d					if DEBUG_FORTH_WORDS 
4a6d						DMARK "CO2" 
4a6d f5				push af  
4a6e 3a 82 4a			ld a, (.dmark)  
4a71 32 68 fe			ld (debug_mark),a  
4a74 3a 83 4a			ld a, (.dmark+1)  
4a77 32 69 fe			ld (debug_mark+1),a  
4a7a 3a 84 4a			ld a, (.dmark+2)  
4a7d 32 6a fe			ld (debug_mark+2),a  
4a80 18 03			jr .pastdmark  
4a82 ..			.dmark: db "CO2"  
4a85 f1			.pastdmark: pop af  
4a86			endm  
# End of macro DMARK
4a86						CALLMONITOR 
4a86 cd 6c fe			call debug_vector  
4a89				endm  
# End of macro CALLMONITOR
4a89					endif 
4a89 ed b0				ldir 
4a8b			 
4a8b			 
4a8b			 
4a8b 21 be f1				ld hl, scratch 
4a8e					if DEBUG_FORTH_WORDS 
4a8e						DMARK "CO5" 
4a8e f5				push af  
4a8f 3a a3 4a			ld a, (.dmark)  
4a92 32 68 fe			ld (debug_mark),a  
4a95 3a a4 4a			ld a, (.dmark+1)  
4a98 32 69 fe			ld (debug_mark+1),a  
4a9b 3a a5 4a			ld a, (.dmark+2)  
4a9e 32 6a fe			ld (debug_mark+2),a  
4aa1 18 03			jr .pastdmark  
4aa3 ..			.dmark: db "CO5"  
4aa6 f1			.pastdmark: pop af  
4aa7			endm  
# End of macro DMARK
4aa7						CALLMONITOR 
4aa7 cd 6c fe			call debug_vector  
4aaa				endm  
# End of macro CALLMONITOR
4aaa					endif 
4aaa			 
4aaa cd 69 21				call forth_push_str 
4aad			 
4aad			 
4aad			 
4aad			 
4aad				       NEXTW 
4aad c3 a8 24			jp macro_next 
4ab0				endm 
# End of macro NEXTW
4ab0			 
4ab0			 
4ab0			.FIND: 
4ab0				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4ab0 4b				db WORD_SYS_CORE+55             
4ab1 6e 4b			dw .LEN            
4ab3 05				db 4 + 1 
4ab4 .. 00			db "FIND",0              
4ab9				endm 
# End of macro CWHEAD
4ab9			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4ab9			 
4ab9					if DEBUG_FORTH_WORDS_KEY 
4ab9						DMARK "FND" 
4ab9 f5				push af  
4aba 3a ce 4a			ld a, (.dmark)  
4abd 32 68 fe			ld (debug_mark),a  
4ac0 3a cf 4a			ld a, (.dmark+1)  
4ac3 32 69 fe			ld (debug_mark+1),a  
4ac6 3a d0 4a			ld a, (.dmark+2)  
4ac9 32 6a fe			ld (debug_mark+2),a  
4acc 18 03			jr .pastdmark  
4ace ..			.dmark: db "FND"  
4ad1 f1			.pastdmark: pop af  
4ad2			endm  
# End of macro DMARK
4ad2						CALLMONITOR 
4ad2 cd 6c fe			call debug_vector  
4ad5				endm  
# End of macro CALLMONITOR
4ad5					endif 
4ad5			 
4ad5			; TODO check string type 
4ad5					FORTH_DSP_VALUE 
4ad5 cd db 22			call macro_forth_dsp_value 
4ad8				endm 
# End of macro FORTH_DSP_VALUE
4ad8			 
4ad8 e5					push hl    
4ad9 7e					ld a,(hl)    ; char to find   
4ada			; TODO change char to substr 
4ada			 
4ada f5					push af 
4adb					 
4adb			 
4adb			 
4adb					if DEBUG_FORTH_WORDS 
4adb						DMARK "FN1" 
4adb f5				push af  
4adc 3a f0 4a			ld a, (.dmark)  
4adf 32 68 fe			ld (debug_mark),a  
4ae2 3a f1 4a			ld a, (.dmark+1)  
4ae5 32 69 fe			ld (debug_mark+1),a  
4ae8 3a f2 4a			ld a, (.dmark+2)  
4aeb 32 6a fe			ld (debug_mark+2),a  
4aee 18 03			jr .pastdmark  
4af0 ..			.dmark: db "FN1"  
4af3 f1			.pastdmark: pop af  
4af4			endm  
# End of macro DMARK
4af4						CALLMONITOR 
4af4 cd 6c fe			call debug_vector  
4af7				endm  
# End of macro CALLMONITOR
4af7					endif 
4af7			 
4af7					FORTH_DSP_POP 
4af7 cd aa 23			call macro_forth_dsp_pop 
4afa				endm 
# End of macro FORTH_DSP_POP
4afa			 
4afa					; string to search 
4afa			 
4afa					FORTH_DSP_VALUE 
4afa cd db 22			call macro_forth_dsp_value 
4afd				endm 
# End of macro FORTH_DSP_VALUE
4afd			 
4afd d1					pop de  ; d is char to find  
4afe			 
4afe					if DEBUG_FORTH_WORDS 
4afe						DMARK "FN2" 
4afe f5				push af  
4aff 3a 13 4b			ld a, (.dmark)  
4b02 32 68 fe			ld (debug_mark),a  
4b05 3a 14 4b			ld a, (.dmark+1)  
4b08 32 69 fe			ld (debug_mark+1),a  
4b0b 3a 15 4b			ld a, (.dmark+2)  
4b0e 32 6a fe			ld (debug_mark+2),a  
4b11 18 03			jr .pastdmark  
4b13 ..			.dmark: db "FN2"  
4b16 f1			.pastdmark: pop af  
4b17			endm  
# End of macro DMARK
4b17						CALLMONITOR 
4b17 cd 6c fe			call debug_vector  
4b1a				endm  
# End of macro CALLMONITOR
4b1a					endif 
4b1a					 
4b1a 01 00 00				ld bc, 0 
4b1d 7e			.findchar:      ld a,(hl) 
4b1e fe 00				cp 0   		 
4b20 28 27				jr z, .finddone     
4b22 ba					cp d 
4b23 28 20				jr z, .foundchar 
4b25 03					inc bc 
4b26 23					inc hl 
4b27					if DEBUG_FORTH_WORDS 
4b27						DMARK "FN3" 
4b27 f5				push af  
4b28 3a 3c 4b			ld a, (.dmark)  
4b2b 32 68 fe			ld (debug_mark),a  
4b2e 3a 3d 4b			ld a, (.dmark+1)  
4b31 32 69 fe			ld (debug_mark+1),a  
4b34 3a 3e 4b			ld a, (.dmark+2)  
4b37 32 6a fe			ld (debug_mark+2),a  
4b3a 18 03			jr .pastdmark  
4b3c ..			.dmark: db "FN3"  
4b3f f1			.pastdmark: pop af  
4b40			endm  
# End of macro DMARK
4b40						CALLMONITOR 
4b40 cd 6c fe			call debug_vector  
4b43				endm  
# End of macro CALLMONITOR
4b43					endif 
4b43 18 d8				jr .findchar 
4b45			 
4b45			 
4b45 c5			.foundchar:	push bc 
4b46 e1					pop hl 
4b47 18 03				jr .findexit 
4b49			 
4b49			 
4b49							 
4b49			 
4b49			.finddone:     ; got to end of string with no find 
4b49 21 00 00				ld hl, 0 
4b4c			.findexit: 
4b4c			 
4b4c					if DEBUG_FORTH_WORDS 
4b4c						DMARK "FNd" 
4b4c f5				push af  
4b4d 3a 61 4b			ld a, (.dmark)  
4b50 32 68 fe			ld (debug_mark),a  
4b53 3a 62 4b			ld a, (.dmark+1)  
4b56 32 69 fe			ld (debug_mark+1),a  
4b59 3a 63 4b			ld a, (.dmark+2)  
4b5c 32 6a fe			ld (debug_mark+2),a  
4b5f 18 03			jr .pastdmark  
4b61 ..			.dmark: db "FNd"  
4b64 f1			.pastdmark: pop af  
4b65			endm  
# End of macro DMARK
4b65						CALLMONITOR 
4b65 cd 6c fe			call debug_vector  
4b68				endm  
# End of macro CALLMONITOR
4b68					endif 
4b68 cd fb 20			call forth_push_numhl 
4b6b			 
4b6b				       NEXTW 
4b6b c3 a8 24			jp macro_next 
4b6e				endm 
# End of macro NEXTW
4b6e			 
4b6e			.LEN: 
4b6e				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4b6e 4c				db WORD_SYS_CORE+56             
4b6f d8 4b			dw .ASC            
4b71 06				db 5 + 1 
4b72 .. 00			db "COUNT",0              
4b78				endm 
# End of macro CWHEAD
4b78			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4b78			 
4b78					if DEBUG_FORTH_WORDS_KEY 
4b78						DMARK "CNT" 
4b78 f5				push af  
4b79 3a 8d 4b			ld a, (.dmark)  
4b7c 32 68 fe			ld (debug_mark),a  
4b7f 3a 8e 4b			ld a, (.dmark+1)  
4b82 32 69 fe			ld (debug_mark+1),a  
4b85 3a 8f 4b			ld a, (.dmark+2)  
4b88 32 6a fe			ld (debug_mark+2),a  
4b8b 18 03			jr .pastdmark  
4b8d ..			.dmark: db "CNT"  
4b90 f1			.pastdmark: pop af  
4b91			endm  
# End of macro DMARK
4b91						CALLMONITOR 
4b91 cd 6c fe			call debug_vector  
4b94				endm  
# End of macro CALLMONITOR
4b94					endif 
4b94			; TODO check string type 
4b94					FORTH_DSP_VALUE 
4b94 cd db 22			call macro_forth_dsp_value 
4b97				endm 
# End of macro FORTH_DSP_VALUE
4b97			 
4b97			 
4b97					if DEBUG_FORTH_WORDS 
4b97						DMARK "CN?" 
4b97 f5				push af  
4b98 3a ac 4b			ld a, (.dmark)  
4b9b 32 68 fe			ld (debug_mark),a  
4b9e 3a ad 4b			ld a, (.dmark+1)  
4ba1 32 69 fe			ld (debug_mark+1),a  
4ba4 3a ae 4b			ld a, (.dmark+2)  
4ba7 32 6a fe			ld (debug_mark+2),a  
4baa 18 03			jr .pastdmark  
4bac ..			.dmark: db "CN?"  
4baf f1			.pastdmark: pop af  
4bb0			endm  
# End of macro DMARK
4bb0						CALLMONITOR 
4bb0 cd 6c fe			call debug_vector  
4bb3				endm  
# End of macro CALLMONITOR
4bb3					endif 
4bb3 cd 2d 14				call strlenz 
4bb6					if DEBUG_FORTH_WORDS 
4bb6						DMARK "CNl" 
4bb6 f5				push af  
4bb7 3a cb 4b			ld a, (.dmark)  
4bba 32 68 fe			ld (debug_mark),a  
4bbd 3a cc 4b			ld a, (.dmark+1)  
4bc0 32 69 fe			ld (debug_mark+1),a  
4bc3 3a cd 4b			ld a, (.dmark+2)  
4bc6 32 6a fe			ld (debug_mark+2),a  
4bc9 18 03			jr .pastdmark  
4bcb ..			.dmark: db "CNl"  
4bce f1			.pastdmark: pop af  
4bcf			endm  
# End of macro DMARK
4bcf						CALLMONITOR 
4bcf cd 6c fe			call debug_vector  
4bd2				endm  
# End of macro CALLMONITOR
4bd2					endif 
4bd2			 
4bd2 cd fb 20				call forth_push_numhl 
4bd5			 
4bd5			 
4bd5			 
4bd5				       NEXTW 
4bd5 c3 a8 24			jp macro_next 
4bd8				endm 
# End of macro NEXTW
4bd8			.ASC: 
4bd8				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4bd8 4d				db WORD_SYS_CORE+57             
4bd9 46 4c			dw .CHR            
4bdb 04				db 3 + 1 
4bdc .. 00			db "ASC",0              
4be0				endm 
# End of macro CWHEAD
4be0			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4be0					if DEBUG_FORTH_WORDS_KEY 
4be0						DMARK "ASC" 
4be0 f5				push af  
4be1 3a f5 4b			ld a, (.dmark)  
4be4 32 68 fe			ld (debug_mark),a  
4be7 3a f6 4b			ld a, (.dmark+1)  
4bea 32 69 fe			ld (debug_mark+1),a  
4bed 3a f7 4b			ld a, (.dmark+2)  
4bf0 32 6a fe			ld (debug_mark+2),a  
4bf3 18 03			jr .pastdmark  
4bf5 ..			.dmark: db "ASC"  
4bf8 f1			.pastdmark: pop af  
4bf9			endm  
# End of macro DMARK
4bf9						CALLMONITOR 
4bf9 cd 6c fe			call debug_vector  
4bfc				endm  
# End of macro CALLMONITOR
4bfc					endif 
4bfc					FORTH_DSP_VALUE 
4bfc cd db 22			call macro_forth_dsp_value 
4bff				endm 
# End of macro FORTH_DSP_VALUE
4bff					;v5 FORTH_DSP_VALUE 
4bff			;		inc hl      ; now at start of numeric as string 
4bff			 
4bff e5					push hl 
4c00			 
4c00					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c00 cd aa 23			call macro_forth_dsp_pop 
4c03				endm 
# End of macro FORTH_DSP_POP
4c03			 
4c03 e1					pop hl 
4c04			 
4c04					if DEBUG_FORTH_WORDS 
4c04						DMARK "AS1" 
4c04 f5				push af  
4c05 3a 19 4c			ld a, (.dmark)  
4c08 32 68 fe			ld (debug_mark),a  
4c0b 3a 1a 4c			ld a, (.dmark+1)  
4c0e 32 69 fe			ld (debug_mark+1),a  
4c11 3a 1b 4c			ld a, (.dmark+2)  
4c14 32 6a fe			ld (debug_mark+2),a  
4c17 18 03			jr .pastdmark  
4c19 ..			.dmark: db "AS1"  
4c1c f1			.pastdmark: pop af  
4c1d			endm  
# End of macro DMARK
4c1d						CALLMONITOR 
4c1d cd 6c fe			call debug_vector  
4c20				endm  
# End of macro CALLMONITOR
4c20					endif 
4c20					; push the content of a onto the stack as a value 
4c20			 
4c20 7e					ld a,(hl)   ; get char 
4c21 26 00				ld h,0 
4c23 6f					ld l,a 
4c24					if DEBUG_FORTH_WORDS 
4c24						DMARK "AS2" 
4c24 f5				push af  
4c25 3a 39 4c			ld a, (.dmark)  
4c28 32 68 fe			ld (debug_mark),a  
4c2b 3a 3a 4c			ld a, (.dmark+1)  
4c2e 32 69 fe			ld (debug_mark+1),a  
4c31 3a 3b 4c			ld a, (.dmark+2)  
4c34 32 6a fe			ld (debug_mark+2),a  
4c37 18 03			jr .pastdmark  
4c39 ..			.dmark: db "AS2"  
4c3c f1			.pastdmark: pop af  
4c3d			endm  
# End of macro DMARK
4c3d						CALLMONITOR 
4c3d cd 6c fe			call debug_vector  
4c40				endm  
# End of macro CALLMONITOR
4c40					endif 
4c40 cd fb 20				call forth_push_numhl 
4c43			 
4c43				       NEXTW 
4c43 c3 a8 24			jp macro_next 
4c46				endm 
# End of macro NEXTW
4c46			 
4c46			.CHR: 
4c46				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4c46 4d				db WORD_SYS_CORE+57             
4c47 82 4c			dw .ENDSTR            
4c49 04				db 3 + 1 
4c4a .. 00			db "CHR",0              
4c4e				endm 
# End of macro CWHEAD
4c4e			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4c4e					if DEBUG_FORTH_WORDS_KEY 
4c4e						DMARK "CHR" 
4c4e f5				push af  
4c4f 3a 63 4c			ld a, (.dmark)  
4c52 32 68 fe			ld (debug_mark),a  
4c55 3a 64 4c			ld a, (.dmark+1)  
4c58 32 69 fe			ld (debug_mark+1),a  
4c5b 3a 65 4c			ld a, (.dmark+2)  
4c5e 32 6a fe			ld (debug_mark+2),a  
4c61 18 03			jr .pastdmark  
4c63 ..			.dmark: db "CHR"  
4c66 f1			.pastdmark: pop af  
4c67			endm  
# End of macro DMARK
4c67						CALLMONITOR 
4c67 cd 6c fe			call debug_vector  
4c6a				endm  
# End of macro CALLMONITOR
4c6a					endif 
4c6a					FORTH_DSP_VALUEHL 
4c6a cd f2 22			call macro_dsp_valuehl 
4c6d				endm 
# End of macro FORTH_DSP_VALUEHL
4c6d			 
4c6d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c6d cd aa 23			call macro_forth_dsp_pop 
4c70				endm 
# End of macro FORTH_DSP_POP
4c70			 
4c70					; save asci byte as a zero term string and push string 
4c70			 
4c70 7d					ld a,l 
4c71 32 be f1				ld (scratch), a 
4c74			 
4c74 3e 00				ld a, 0 
4c76 32 bf f1				ld (scratch+1), a 
4c79			 
4c79 21 be f1				ld hl, scratch 
4c7c cd 69 21				call forth_push_str 
4c7f			 
4c7f			 
4c7f				       NEXTW 
4c7f c3 a8 24			jp macro_next 
4c82				endm 
# End of macro NEXTW
4c82			 
4c82			 
4c82			 
4c82			 
4c82			.ENDSTR: 
4c82			; eof 
4c82			 
# End of file forth_words_str.asm
4c82			include "forth_words_key.asm" 
4c82			 
4c82			; | ## Keyboard Words 
4c82			 
4c82			.KEY: 
4c82				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4c82 3e				db WORD_SYS_CORE+42             
4c83 b2 4c			dw .WAITK            
4c85 04				db 3 + 1 
4c86 .. 00			db "KEY",0              
4c8a				endm 
# End of macro CWHEAD
4c8a			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4c8a			 
4c8a					if DEBUG_FORTH_WORDS_KEY 
4c8a						DMARK "KEY" 
4c8a f5				push af  
4c8b 3a 9f 4c			ld a, (.dmark)  
4c8e 32 68 fe			ld (debug_mark),a  
4c91 3a a0 4c			ld a, (.dmark+1)  
4c94 32 69 fe			ld (debug_mark+1),a  
4c97 3a a1 4c			ld a, (.dmark+2)  
4c9a 32 6a fe			ld (debug_mark+2),a  
4c9d 18 03			jr .pastdmark  
4c9f ..			.dmark: db "KEY"  
4ca2 f1			.pastdmark: pop af  
4ca3			endm  
# End of macro DMARK
4ca3						CALLMONITOR 
4ca3 cd 6c fe			call debug_vector  
4ca6				endm  
# End of macro CALLMONITOR
4ca6					endif 
4ca6			; TODO currently waits 
4ca6 cd 38 7a				call cin 
4ca9					;call cin_wait 
4ca9 6f					ld l, a 
4caa 26 00				ld h, 0 
4cac cd fb 20				call forth_push_numhl 
4caf					NEXTW 
4caf c3 a8 24			jp macro_next 
4cb2				endm 
# End of macro NEXTW
4cb2			.WAITK: 
4cb2				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4cb2 3f				db WORD_SYS_CORE+43             
4cb3 e4 4c			dw .ACCEPT            
4cb5 06				db 5 + 1 
4cb6 .. 00			db "WAITK",0              
4cbc				endm 
# End of macro CWHEAD
4cbc			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4cbc					if DEBUG_FORTH_WORDS_KEY 
4cbc						DMARK "WAI" 
4cbc f5				push af  
4cbd 3a d1 4c			ld a, (.dmark)  
4cc0 32 68 fe			ld (debug_mark),a  
4cc3 3a d2 4c			ld a, (.dmark+1)  
4cc6 32 69 fe			ld (debug_mark+1),a  
4cc9 3a d3 4c			ld a, (.dmark+2)  
4ccc 32 6a fe			ld (debug_mark+2),a  
4ccf 18 03			jr .pastdmark  
4cd1 ..			.dmark: db "WAI"  
4cd4 f1			.pastdmark: pop af  
4cd5			endm  
# End of macro DMARK
4cd5						CALLMONITOR 
4cd5 cd 6c fe			call debug_vector  
4cd8				endm  
# End of macro CALLMONITOR
4cd8					endif 
4cd8 cd 27 7a				call cin_wait 
4cdb 6f					ld l, a 
4cdc 26 00				ld h, 0 
4cde cd fb 20				call forth_push_numhl 
4ce1					NEXTW 
4ce1 c3 a8 24			jp macro_next 
4ce4				endm 
# End of macro NEXTW
4ce4			.ACCEPT: 
4ce4				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4ce4 40				db WORD_SYS_CORE+44             
4ce5 42 4d			dw .EDIT            
4ce7 07				db 6 + 1 
4ce8 .. 00			db "ACCEPT",0              
4cef				endm 
# End of macro CWHEAD
4cef			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4cef					; TODO crashes on push 
4cef					if DEBUG_FORTH_WORDS_KEY 
4cef						DMARK "ACC" 
4cef f5				push af  
4cf0 3a 04 4d			ld a, (.dmark)  
4cf3 32 68 fe			ld (debug_mark),a  
4cf6 3a 05 4d			ld a, (.dmark+1)  
4cf9 32 69 fe			ld (debug_mark+1),a  
4cfc 3a 06 4d			ld a, (.dmark+2)  
4cff 32 6a fe			ld (debug_mark+2),a  
4d02 18 03			jr .pastdmark  
4d04 ..			.dmark: db "ACC"  
4d07 f1			.pastdmark: pop af  
4d08			endm  
# End of macro DMARK
4d08						CALLMONITOR 
4d08 cd 6c fe			call debug_vector  
4d0b				endm  
# End of macro CALLMONITOR
4d0b					endif 
4d0b 21 bc f3				ld hl, os_input 
4d0e 3e 00				ld a, 0 
4d10 77					ld (hl),a 
4d11 3a 5b fa				ld a,(f_cursor_ptr) 
4d14 16 64				ld d, 100 
4d16 0e 00				ld c, 0 
4d18 1e 28				ld e, 40 
4d1a cd fc 0f				call input_str 
4d1d					; TODO perhaps do a type check and wrap in quotes if not a number 
4d1d 21 bc f3				ld hl, os_input 
4d20					if DEBUG_FORTH_WORDS 
4d20						DMARK "AC1" 
4d20 f5				push af  
4d21 3a 35 4d			ld a, (.dmark)  
4d24 32 68 fe			ld (debug_mark),a  
4d27 3a 36 4d			ld a, (.dmark+1)  
4d2a 32 69 fe			ld (debug_mark+1),a  
4d2d 3a 37 4d			ld a, (.dmark+2)  
4d30 32 6a fe			ld (debug_mark+2),a  
4d33 18 03			jr .pastdmark  
4d35 ..			.dmark: db "AC1"  
4d38 f1			.pastdmark: pop af  
4d39			endm  
# End of macro DMARK
4d39						CALLMONITOR 
4d39 cd 6c fe			call debug_vector  
4d3c				endm  
# End of macro CALLMONITOR
4d3c					endif 
4d3c cd 69 21				call forth_push_str 
4d3f					NEXTW 
4d3f c3 a8 24			jp macro_next 
4d42				endm 
# End of macro NEXTW
4d42			 
4d42			.EDIT: 
4d42				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4d42 40				db WORD_SYS_CORE+44             
4d43 e4 4d			dw .DEDIT            
4d45 05				db 4 + 1 
4d46 .. 00			db "EDIT",0              
4d4b				endm 
# End of macro CWHEAD
4d4b			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4d4b			 
4d4b					; TODO does not copy from stack 
4d4b					if DEBUG_FORTH_WORDS_KEY 
4d4b						DMARK "EDT" 
4d4b f5				push af  
4d4c 3a 60 4d			ld a, (.dmark)  
4d4f 32 68 fe			ld (debug_mark),a  
4d52 3a 61 4d			ld a, (.dmark+1)  
4d55 32 69 fe			ld (debug_mark+1),a  
4d58 3a 62 4d			ld a, (.dmark+2)  
4d5b 32 6a fe			ld (debug_mark+2),a  
4d5e 18 03			jr .pastdmark  
4d60 ..			.dmark: db "EDT"  
4d63 f1			.pastdmark: pop af  
4d64			endm  
# End of macro DMARK
4d64						CALLMONITOR 
4d64 cd 6c fe			call debug_vector  
4d67				endm  
# End of macro CALLMONITOR
4d67					endif 
4d67			 
4d67					;FORTH_DSP 
4d67					FORTH_DSP_VALUEHL 
4d67 cd f2 22			call macro_dsp_valuehl 
4d6a				endm 
# End of macro FORTH_DSP_VALUEHL
4d6a			;		inc hl    ; TODO do type check 
4d6a			 
4d6a			;		call get_word_hl 
4d6a e5					push hl 
4d6b					if DEBUG_FORTH_WORDS 
4d6b						DMARK "EDp" 
4d6b f5				push af  
4d6c 3a 80 4d			ld a, (.dmark)  
4d6f 32 68 fe			ld (debug_mark),a  
4d72 3a 81 4d			ld a, (.dmark+1)  
4d75 32 69 fe			ld (debug_mark+1),a  
4d78 3a 82 4d			ld a, (.dmark+2)  
4d7b 32 6a fe			ld (debug_mark+2),a  
4d7e 18 03			jr .pastdmark  
4d80 ..			.dmark: db "EDp"  
4d83 f1			.pastdmark: pop af  
4d84			endm  
# End of macro DMARK
4d84						CALLMONITOR 
4d84 cd 6c fe			call debug_vector  
4d87				endm  
# End of macro CALLMONITOR
4d87					endif 
4d87				;	ld a, 0 
4d87 cd 2d 14				call strlenz 
4d8a 23					inc hl 
4d8b			 
4d8b 06 00				ld b, 0 
4d8d 4d					ld c, l 
4d8e			 
4d8e e1					pop hl 
4d8f 11 bc f3				ld de, os_input 
4d92					if DEBUG_FORTH_WORDS_KEY 
4d92						DMARK "EDc" 
4d92 f5				push af  
4d93 3a a7 4d			ld a, (.dmark)  
4d96 32 68 fe			ld (debug_mark),a  
4d99 3a a8 4d			ld a, (.dmark+1)  
4d9c 32 69 fe			ld (debug_mark+1),a  
4d9f 3a a9 4d			ld a, (.dmark+2)  
4da2 32 6a fe			ld (debug_mark+2),a  
4da5 18 03			jr .pastdmark  
4da7 ..			.dmark: db "EDc"  
4daa f1			.pastdmark: pop af  
4dab			endm  
# End of macro DMARK
4dab						CALLMONITOR 
4dab cd 6c fe			call debug_vector  
4dae				endm  
# End of macro CALLMONITOR
4dae					endif 
4dae ed b0				ldir 
4db0			 
4db0			 
4db0 21 bc f3				ld hl, os_input 
4db3					;ld a, 0 
4db3					;ld (hl),a 
4db3 3a 5b fa				ld a,(f_cursor_ptr) 
4db6 16 64				ld d, 100 
4db8 0e 00				ld c, 0 
4dba 1e 28				ld e, 40 
4dbc cd fc 0f				call input_str 
4dbf					; TODO perhaps do a type check and wrap in quotes if not a number 
4dbf 21 bc f3				ld hl, os_input 
4dc2					if DEBUG_FORTH_WORDS 
4dc2						DMARK "ED1" 
4dc2 f5				push af  
4dc3 3a d7 4d			ld a, (.dmark)  
4dc6 32 68 fe			ld (debug_mark),a  
4dc9 3a d8 4d			ld a, (.dmark+1)  
4dcc 32 69 fe			ld (debug_mark+1),a  
4dcf 3a d9 4d			ld a, (.dmark+2)  
4dd2 32 6a fe			ld (debug_mark+2),a  
4dd5 18 03			jr .pastdmark  
4dd7 ..			.dmark: db "ED1"  
4dda f1			.pastdmark: pop af  
4ddb			endm  
# End of macro DMARK
4ddb						CALLMONITOR 
4ddb cd 6c fe			call debug_vector  
4dde				endm  
# End of macro CALLMONITOR
4dde					endif 
4dde cd 69 21				call forth_push_str 
4de1					NEXTW 
4de1 c3 a8 24			jp macro_next 
4de4				endm 
# End of macro NEXTW
4de4			 
4de4			.DEDIT: 
4de4				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4de4 40				db WORD_SYS_CORE+44             
4de5 46 4e			dw .ENDKEY            
4de7 06				db 5 + 1 
4de8 .. 00			db "DEDIT",0              
4dee				endm 
# End of macro CWHEAD
4dee			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4dee			 
4dee					; TODO does not copy from stack 
4dee					if DEBUG_FORTH_WORDS_KEY 
4dee						DMARK "DED" 
4dee f5				push af  
4def 3a 03 4e			ld a, (.dmark)  
4df2 32 68 fe			ld (debug_mark),a  
4df5 3a 04 4e			ld a, (.dmark+1)  
4df8 32 69 fe			ld (debug_mark+1),a  
4dfb 3a 05 4e			ld a, (.dmark+2)  
4dfe 32 6a fe			ld (debug_mark+2),a  
4e01 18 03			jr .pastdmark  
4e03 ..			.dmark: db "DED"  
4e06 f1			.pastdmark: pop af  
4e07			endm  
# End of macro DMARK
4e07						CALLMONITOR 
4e07 cd 6c fe			call debug_vector  
4e0a				endm  
# End of macro CALLMONITOR
4e0a					endif 
4e0a			 
4e0a					;FORTH_DSP 
4e0a					FORTH_DSP_VALUEHL 
4e0a cd f2 22			call macro_dsp_valuehl 
4e0d				endm 
# End of macro FORTH_DSP_VALUEHL
4e0d			;		inc hl    ; TODO do type check 
4e0d			 
4e0d			;		call get_word_hl 
4e0d e5					push hl 
4e0e e5					push hl 
4e0f					FORTH_DSP_POP 
4e0f cd aa 23			call macro_forth_dsp_pop 
4e12				endm 
# End of macro FORTH_DSP_POP
4e12 e1					pop hl 
4e13					if DEBUG_FORTH_WORDS 
4e13						DMARK "EDp" 
4e13 f5				push af  
4e14 3a 28 4e			ld a, (.dmark)  
4e17 32 68 fe			ld (debug_mark),a  
4e1a 3a 29 4e			ld a, (.dmark+1)  
4e1d 32 69 fe			ld (debug_mark+1),a  
4e20 3a 2a 4e			ld a, (.dmark+2)  
4e23 32 6a fe			ld (debug_mark+2),a  
4e26 18 03			jr .pastdmark  
4e28 ..			.dmark: db "EDp"  
4e2b f1			.pastdmark: pop af  
4e2c			endm  
# End of macro DMARK
4e2c						CALLMONITOR 
4e2c cd 6c fe			call debug_vector  
4e2f				endm  
# End of macro CALLMONITOR
4e2f					endif 
4e2f				;	ld a, 0 
4e2f cd 2d 14				call strlenz 
4e32 23					inc hl 
4e33			 
4e33 06 00				ld b, 0 
4e35 4d					ld c, l 
4e36			 
4e36 e1					pop hl 
4e37			 
4e37					;ld a, 0 
4e37					;ld (hl),a 
4e37 3a 5b fa				ld a,(f_cursor_ptr) 
4e3a 16 64				ld d, 100 
4e3c 0e 00				ld c, 0 
4e3e 1e 28				ld e, 40 
4e40 cd fc 0f				call input_str 
4e43					; TODO perhaps do a type check and wrap in quotes if not a number 
4e43					NEXTW 
4e43 c3 a8 24			jp macro_next 
4e46				endm 
# End of macro NEXTW
4e46			 
4e46			 
4e46			.ENDKEY: 
4e46			; eof 
4e46			 
# End of file forth_words_key.asm
4e46			include "forth_words_const.asm" 
4e46			 
4e46			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4e46			 
4e46			 
4e46			.SPITIME: 
4e46				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4e46 77				db WORD_SYS_CORE+99             
4e47 5b 4e			dw .VA            
4e49 08				db 7 + 1 
4e4a .. 00			db "SPITIME",0              
4e52				endm 
# End of macro CWHEAD
4e52			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4e52			; 
4e52			; | If using BANK devices then leave as is. 
4e52			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4e52			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4e52			 
4e52 21 61 fa				ld hl, spi_clktime  
4e55 cd fb 20				call forth_push_numhl 
4e58			 
4e58					NEXTW 
4e58 c3 a8 24			jp macro_next 
4e5b				endm 
# End of macro NEXTW
4e5b			 
4e5b			 
4e5b			.VA: 
4e5b				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4e5b 77				db WORD_SYS_CORE+99             
4e5c 6b 4e			dw .SYMBOL            
4e5e 03				db 2 + 1 
4e5f .. 00			db "VA",0              
4e62				endm 
# End of macro CWHEAD
4e62			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4e62 21 25 fa				ld hl, cli_var_array 
4e65 cd fb 20				call forth_push_numhl 
4e68			 
4e68					NEXTW 
4e68 c3 a8 24			jp macro_next 
4e6b				endm 
# End of macro NEXTW
4e6b			 
4e6b			.SYMBOL: 
4e6b				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4e6b 77				db WORD_SYS_CORE+99             
4e6c 75 4f			dw .ENDCONST            
4e6e 07				db 6 + 1 
4e6f .. 00			db "SYMBOL",0              
4e76				endm 
# End of macro CWHEAD
4e76			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4e76			; | 
4e76			; | The value is the number reference and the final address is pushed to stack 
4e76			 
4e76			; | dw sym_table 
4e76			; | dw nmi_vector 
4e76			; | dw cli_autodisplay 
4e76			; | dw cli_data_sp 
4e76			; | dw cli_data_stack 
4e76			; | dw cli_loop_sp 
4e76			; | dw cli_loop_stack 
4e76			; | dw cli_var_array 
4e76			; | dw cursor_col 
4e76			; | dw cursor_ptr 
4e76			; | ; 10 
4e76			; | dw cursor_row 
4e76			; | dw debug_mark 
4e76			; | dw display_fb0 
4e76			; | dw display_fb1 
4e76			; | dw display_fb2 
4e76			; | dw display_fb3 
4e76			; | dw display_fb_active 
4e76			; | dw execscratch 
4e76			; | dw f_cursor_ptr 
4e76			; | dw hardware_word 
4e76			; | ;20 
4e76			; | dw input_at_cursor 
4e76			; | dw input_at_pos 
4e76			; | dw input_cur_flash 
4e76			; | dw input_cur_onoff 
4e76			; | dw input_cursor 
4e76			; | dw input_display_size 
4e76			; | dw input_len 
4e76			; | dw input_ptr 
4e76			; | dw input_size 
4e76			; | dw input_start 
4e76			; | ; 30 
4e76			; | dw input_str 
4e76			; | dw input_under_cursor 
4e76			; | dw os_cli_cmd 
4e76			; | dw os_cur_ptr 
4e76			; | dw os_current_i 
4e76			; | dw os_input 
4e76			; | dw os_last_cmd 
4e76			; | dw os_last_new_uword 
4e76			; | dw debug_vector 
4e76			; | dw os_view_hl 
4e76			; | ;40 
4e76			; | dw os_word_scratch 
4e76			; | dw portbctl 
4e76			; | dw portbdata 
4e76			; | dw spi_cartdev 
4e76			; | dw spi_cartdev2 
4e76			; | dw spi_clktime 
4e76			; | dw spi_device 
4e76			; | dw spi_device_id 
4e76			; | dw spi_portbyte 
4e76			; | dw stackstore 
4e76			; | ; 50 
4e76			; | if STORAGE_SE 
4e76			; | dw storage_actl 
4e76			; | dw storage_adata 
4e76			; | else 
4e76			; | dw 0 
4e76			; | dw 0 
4e76			; | endif 
4e76			; | dw storage_append 
4e76			; | if STORAGE_SE 
4e76			; | dw storage_bctl 
4e76			; | else 
4e76			; | dw 0 
4e76			; | endif 
4e76			; | dw store_bank_active 
4e76			; | dw store_filecache 
4e76			; | dw store_longread 
4e76			; | dw store_openaddr 
4e76			; | dw store_openext 
4e76			; | dw store_openmaxext 
4e76			; | ; 60 
4e76			; | dw store_page 
4e76			; | dw store_readbuf 
4e76			; | dw store_readcont 
4e76			; | dw store_readptr 
4e76			; | dw store_tmpext 
4e76			; | dw store_tmpid 
4e76			; | dw store_tmppageid 
4e76			; | dw malloc 
4e76			; | dw free 
4e76			; | dw cin 
4e76			; | ; 70 
4e76			; | dw cin_wait 
4e76			; | dw forth_push_numhl 
4e76			; | dw forth_push_str 
4e76			 
4e76					if DEBUG_FORTH_WORDS_KEY 
4e76						DMARK "SYM" 
4e76 f5				push af  
4e77 3a 8b 4e			ld a, (.dmark)  
4e7a 32 68 fe			ld (debug_mark),a  
4e7d 3a 8c 4e			ld a, (.dmark+1)  
4e80 32 69 fe			ld (debug_mark+1),a  
4e83 3a 8d 4e			ld a, (.dmark+2)  
4e86 32 6a fe			ld (debug_mark+2),a  
4e89 18 03			jr .pastdmark  
4e8b ..			.dmark: db "SYM"  
4e8e f1			.pastdmark: pop af  
4e8f			endm  
# End of macro DMARK
4e8f						CALLMONITOR 
4e8f cd 6c fe			call debug_vector  
4e92				endm  
# End of macro CALLMONITOR
4e92					endif 
4e92			 
4e92					FORTH_DSP_VALUEHL 
4e92 cd f2 22			call macro_dsp_valuehl 
4e95				endm 
# End of macro FORTH_DSP_VALUEHL
4e95			 
4e95 7d					ld a, l     
4e96			 
4e96			 
4e96					if DEBUG_FORTH_WORDS 
4e96						DMARK "SY1" 
4e96 f5				push af  
4e97 3a ab 4e			ld a, (.dmark)  
4e9a 32 68 fe			ld (debug_mark),a  
4e9d 3a ac 4e			ld a, (.dmark+1)  
4ea0 32 69 fe			ld (debug_mark+1),a  
4ea3 3a ad 4e			ld a, (.dmark+2)  
4ea6 32 6a fe			ld (debug_mark+2),a  
4ea9 18 03			jr .pastdmark  
4eab ..			.dmark: db "SY1"  
4eae f1			.pastdmark: pop af  
4eaf			endm  
# End of macro DMARK
4eaf						CALLMONITOR 
4eaf cd 6c fe			call debug_vector  
4eb2				endm  
# End of macro CALLMONITOR
4eb2					endif 
4eb2					 
4eb2 f5					push af	 
4eb3					FORTH_DSP_POP 
4eb3 cd aa 23			call macro_forth_dsp_pop 
4eb6				endm 
# End of macro FORTH_DSP_POP
4eb6 f1					pop af 
4eb7			 
4eb7 cb 27				sla a  
4eb9				 
4eb9					 
4eb9					if DEBUG_FORTH_WORDS 
4eb9						DMARK "SY" 
4eb9 f5				push af  
4eba 3a ce 4e			ld a, (.dmark)  
4ebd 32 68 fe			ld (debug_mark),a  
4ec0 3a cf 4e			ld a, (.dmark+1)  
4ec3 32 69 fe			ld (debug_mark+1),a  
4ec6 3a d0 4e			ld a, (.dmark+2)  
4ec9 32 6a fe			ld (debug_mark+2),a  
4ecc 18 02			jr .pastdmark  
4ece ..			.dmark: db "SY"  
4ed0 f1			.pastdmark: pop af  
4ed1			endm  
# End of macro DMARK
4ed1						CALLMONITOR 
4ed1 cd 6c fe			call debug_vector  
4ed4				endm  
# End of macro CALLMONITOR
4ed4					endif 
4ed4			 
4ed4 21 e3 4e				ld hl, sym_table 
4ed7 cd cf 0f				call addatohl 
4eda cd 2a 24				call loadwordinhl 
4edd cd fb 20				call forth_push_numhl 
4ee0			 
4ee0			 
4ee0				       NEXTW 
4ee0 c3 a8 24			jp macro_next 
4ee3				endm 
# End of macro NEXTW
4ee3			 
4ee3			sym_table: 
4ee3			 
4ee3			; 0 
4ee3 e3 4e		dw sym_table 
4ee5 6f fe		dw nmi_vector 
4ee7 39 fa		dw cli_autodisplay 
4ee9 eb f9		dw cli_data_sp 
4eeb 25 f7		dw cli_data_stack 
4eed ed f9		dw cli_loop_sp 
4eef 27 f9		dw cli_loop_stack 
4ef1 25 fa		dw cli_var_array 
4ef3 c2 fb		dw cursor_col 
4ef5 c0 fb		dw cursor_ptr 
4ef7			; 10 
4ef7 c1 fb		dw cursor_row 
4ef9 68 fe		dw debug_mark 
4efb ae fd		dw display_fb0 
4efd 0d fd		dw display_fb1 
4eff cb fb		dw display_fb2 
4f01 6c fc		dw display_fb3 
4f03 c9 fb		dw display_fb_active 
4f05 bd f2		dw execscratch 
4f07 5b fa		dw f_cursor_ptr 
4f09 72 fe		dw hardware_word 
4f0b			;20 
4f0b 5f fe		dw input_at_cursor 
4f0d 61 fe		dw input_at_pos 
4f0f 5d fe		dw input_cur_flash 
4f11 5c fe		dw input_cur_onoff 
4f13 52 fe		dw input_cursor 
4f15 62 fe		dw input_display_size 
4f17 57 fe		dw input_len 
4f19 66 fe		dw input_ptr 
4f1b 63 fe		dw input_size 
4f1d 64 fe		dw input_start 
4f1f			; 30 
4f1f fc 0f		dw input_str 
4f21 60 fe		dw input_under_cursor 
4f23 e5 f4		dw os_cli_cmd 
4f25 e1 f4		dw os_cur_ptr 
4f27 e3 f4		dw os_current_i 
4f29 bc f3		dw os_input 
4f2b e4 f5		dw os_last_cmd 
4f2d bb f4		dw os_last_new_uword 
4f2f 6c fe		dw debug_vector 
4f31 a0 f1		dw os_view_hl 
4f33			;40 
4f33 c3 f4		dw os_word_scratch 
4f35 c3 00		dw portbctl 
4f37 c1 00		dw portbdata 
4f39 60 fa		dw spi_cartdev 
4f3b 5f fa		dw spi_cartdev2 
4f3d 61 fa		dw spi_clktime 
4f3f 5d fa		dw spi_device 
4f41 5c fa		dw spi_device_id 
4f43 5e fa		dw spi_portbyte 
4f45 a4 fb		dw stackstore 
4f47			; 50 
4f47			if STORAGE_SE 
4f47 82 00		dw storage_actl 
4f49 80 00		dw storage_adata 
4f4b			else 
4f4b			dw 0 
4f4b			dw 0 
4f4b			endif 
4f4b 55 0b		dw storage_append 
4f4d			if STORAGE_SE 
4f4d 83 00		dw storage_bctl 
4f4f			else 
4f4f			dw 0 
4f4f			endif 
4f4f 90 fb		dw store_bank_active 
4f51 64 fa		dw store_filecache 
4f53 72 fa		dw store_longread 
4f55 68 fa		dw store_openaddr 
4f57 67 fa		dw store_openext 
4f59 66 fa		dw store_openmaxext 
4f5b			; 60 
4f5b 77 fa		dw store_page 
4f5d 73 fa		dw store_readbuf 
4f5f 6a fa		dw store_readcont 
4f61 75 fa		dw store_readptr 
4f63 6a fa		dw store_tmpext 
4f65 6b fa		dw store_tmpid 
4f67 62 fa		dw store_tmppageid 
4f69 96 14		dw malloc 
4f6b 60 15		dw free 
4f6d 38 7a		dw cin 
4f6f			; 70 
4f6f 27 7a		dw cin_wait 
4f71 fb 20		dw forth_push_numhl 
4f73 69 21		dw forth_push_str 
4f75			 
4f75			 
4f75			.ENDCONST: 
4f75			 
4f75			; eof 
4f75			 
4f75			 
# End of file forth_words_const.asm
4f75			 
4f75			if STORAGE_SE 
4f75			   	include "forth_words_storage.asm" 
4f75			 
4f75			; | ## Fixed Storage Words 
4f75			 
4f75			.RENAME: 
4f75			  
4f75				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4f75 3a				db WORD_SYS_CORE+38             
4f76 6b 50			dw .RECORD            
4f78 07				db 6 + 1 
4f79 .. 00			db "RENAME",0              
4f80				endm 
# End of macro CWHEAD
4f80			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4f80			; | | Compatible with PicoSPINet  
4f80					if DEBUG_FORTH_WORDS_KEY 
4f80						DMARK "REN" 
4f80 f5				push af  
4f81 3a 95 4f			ld a, (.dmark)  
4f84 32 68 fe			ld (debug_mark),a  
4f87 3a 96 4f			ld a, (.dmark+1)  
4f8a 32 69 fe			ld (debug_mark+1),a  
4f8d 3a 97 4f			ld a, (.dmark+2)  
4f90 32 6a fe			ld (debug_mark+2),a  
4f93 18 03			jr .pastdmark  
4f95 ..			.dmark: db "REN"  
4f98 f1			.pastdmark: pop af  
4f99			endm  
# End of macro DMARK
4f99						CALLMONITOR 
4f99 cd 6c fe			call debug_vector  
4f9c				endm  
# End of macro CALLMONITOR
4f9c					endif 
4f9c			 
4f9c			 
4f9c					; preserve some internal vars used by other file handing routines 
4f9c			 
4f9c 2a 68 fa				ld hl, (store_openaddr) 
4f9f e5					push hl 
4fa0 3a 6a fa				ld a, (store_readcont) 
4fa3 f5					push af 
4fa4			 
4fa4					FORTH_DSP_VALUEHL 
4fa4 cd f2 22			call macro_dsp_valuehl 
4fa7				endm 
# End of macro FORTH_DSP_VALUEHL
4fa7			 
4fa7					; move ext and id around for the file header 
4fa7			 
4fa7 65					ld h, l 
4fa8 2e 00				ld l, 0 
4faa			 
4faa e5					push hl    ; id 
4fab			 
4fab					FORTH_DSP_POP 
4fab cd aa 23			call macro_forth_dsp_pop 
4fae				endm 
# End of macro FORTH_DSP_POP
4fae			 
4fae					; Locate the file header 
4fae			 
4fae e1					pop hl 
4faf e5					push hl 
4fb0 11 77 fa				ld de, store_page      ; get block zero of file 
4fb3					if DEBUG_FORTH_WORDS 
4fb3						DMARK "REr" 
4fb3 f5				push af  
4fb4 3a c8 4f			ld a, (.dmark)  
4fb7 32 68 fe			ld (debug_mark),a  
4fba 3a c9 4f			ld a, (.dmark+1)  
4fbd 32 69 fe			ld (debug_mark+1),a  
4fc0 3a ca 4f			ld a, (.dmark+2)  
4fc3 32 6a fe			ld (debug_mark+2),a  
4fc6 18 03			jr .pastdmark  
4fc8 ..			.dmark: db "REr"  
4fcb f1			.pastdmark: pop af  
4fcc			endm  
# End of macro DMARK
4fcc						CALLMONITOR 
4fcc cd 6c fe			call debug_vector  
4fcf				endm  
# End of macro CALLMONITOR
4fcf					endif 
4fcf cd be 09				call storage_read 
4fd2			 
4fd2 cd f8 0f			call ishlzero 
4fd5 20 05			jr nz, .rnfound 
4fd7			 
4fd7				; file does not exist so indicate with 255 extents in use 
4fd7			 
4fd7 3e ff			ld a, 255 
4fd9 e1				pop hl ; clear dup hl 
4fda 18 7b			jr .skiprneof 
4fdc			 
4fdc			 
4fdc			.rnfound: 
4fdc					; file found so rename 
4fdc			 
4fdc					FORTH_DSP_VALUEHL 
4fdc cd f2 22			call macro_dsp_valuehl 
4fdf				endm 
# End of macro FORTH_DSP_VALUEHL
4fdf			 
4fdf e5				push hl 
4fe0 3e 00			ld a, 0 
4fe2 cd 38 14			call strlent 
4fe5 23				inc hl   ; cover zero term 
4fe6 06 00			ld b,0 
4fe8 4d				ld c,l 
4fe9 e1				pop hl 
4fea 11 7a fa				ld de, store_page + 3 
4fed ed b0				ldir 
4fef			 
4fef 11 77 fa				ld de, store_page 
4ff2					if DEBUG_FORTH_WORDS 
4ff2						DMARK "RER" 
4ff2 f5				push af  
4ff3 3a 07 50			ld a, (.dmark)  
4ff6 32 68 fe			ld (debug_mark),a  
4ff9 3a 08 50			ld a, (.dmark+1)  
4ffc 32 69 fe			ld (debug_mark+1),a  
4fff 3a 09 50			ld a, (.dmark+2)  
5002 32 6a fe			ld (debug_mark+2),a  
5005 18 03			jr .pastdmark  
5007 ..			.dmark: db "RER"  
500a f1			.pastdmark: pop af  
500b			endm  
# End of macro DMARK
500b						CALLMONITOR 
500b cd 6c fe			call debug_vector  
500e				endm  
# End of macro CALLMONITOR
500e					endif 
500e			 
500e e1					pop hl    ; get orig file id and mangle it for find id 
500f 55					ld d, l 
5010 5c					ld e, h 
5011			 
5011 21 00 00				ld hl, 0 
5014					if DEBUG_FORTH_WORDS 
5014						DMARK "REf" 
5014 f5				push af  
5015 3a 29 50			ld a, (.dmark)  
5018 32 68 fe			ld (debug_mark),a  
501b 3a 2a 50			ld a, (.dmark+1)  
501e 32 69 fe			ld (debug_mark+1),a  
5021 3a 2b 50			ld a, (.dmark+2)  
5024 32 6a fe			ld (debug_mark+2),a  
5027 18 03			jr .pastdmark  
5029 ..			.dmark: db "REf"  
502c f1			.pastdmark: pop af  
502d			endm  
# End of macro DMARK
502d						CALLMONITOR 
502d cd 6c fe			call debug_vector  
5030				endm  
# End of macro CALLMONITOR
5030					endif 
5030 cd 98 07				call storage_findnextid 
5033 11 77 fa				ld de, store_page 
5036					if DEBUG_FORTH_WORDS 
5036						DMARK "REw" 
5036 f5				push af  
5037 3a 4b 50			ld a, (.dmark)  
503a 32 68 fe			ld (debug_mark),a  
503d 3a 4c 50			ld a, (.dmark+1)  
5040 32 69 fe			ld (debug_mark+1),a  
5043 3a 4d 50			ld a, (.dmark+2)  
5046 32 6a fe			ld (debug_mark+2),a  
5049 18 03			jr .pastdmark  
504b ..			.dmark: db "REw"  
504e f1			.pastdmark: pop af  
504f			endm  
# End of macro DMARK
504f						CALLMONITOR 
504f cd 6c fe			call debug_vector  
5052				endm  
# End of macro CALLMONITOR
5052					endif 
5052 cd ca 04				call storage_write_block 
5055			 
5055 3e 00				ld a, 0 
5057			.skiprneof: 
5057					; drop file name 
5057					FORTH_DSP_POP 
5057 cd aa 23			call macro_forth_dsp_pop 
505a				endm 
# End of macro FORTH_DSP_POP
505a			 
505a 6f					ld l, a 
505b 26 00				ld h, 0 
505d cd fb 20				call forth_push_numhl 
5060			 
5060			 
5060 f1					pop af 
5061 32 6a fa				ld (store_readcont),a 
5064 e1					pop hl 
5065 22 68 fa				ld (store_openaddr), hl 
5068						 
5068				NEXTW 
5068 c3 a8 24			jp macro_next 
506b				endm 
# End of macro NEXTW
506b			.RECORD: 
506b			  
506b				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
506b 3a				db WORD_SYS_CORE+38             
506c 0f 51			dw .BREAD            
506e 07				db 6 + 1 
506f .. 00			db "RECORD",0              
5076				endm 
# End of macro CWHEAD
5076			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
5076			; | | Compatible with PicoSPINet  
5076			 
5076					if DEBUG_FORTH_WORDS_KEY 
5076						DMARK "REC" 
5076 f5				push af  
5077 3a 8b 50			ld a, (.dmark)  
507a 32 68 fe			ld (debug_mark),a  
507d 3a 8c 50			ld a, (.dmark+1)  
5080 32 69 fe			ld (debug_mark+1),a  
5083 3a 8d 50			ld a, (.dmark+2)  
5086 32 6a fe			ld (debug_mark+2),a  
5089 18 03			jr .pastdmark  
508b ..			.dmark: db "REC"  
508e f1			.pastdmark: pop af  
508f			endm  
# End of macro DMARK
508f						CALLMONITOR 
508f cd 6c fe			call debug_vector  
5092				endm  
# End of macro CALLMONITOR
5092					endif 
5092			 
5092					FORTH_DSP_VALUEHL 
5092 cd f2 22			call macro_dsp_valuehl 
5095				endm 
# End of macro FORTH_DSP_VALUEHL
5095			 
5095 e5					push hl    ; id 
5096			 
5096					FORTH_DSP_POP 
5096 cd aa 23			call macro_forth_dsp_pop 
5099				endm 
# End of macro FORTH_DSP_POP
5099			 
5099					FORTH_DSP_VALUEHL 
5099 cd f2 22			call macro_dsp_valuehl 
509c				endm 
# End of macro FORTH_DSP_VALUEHL
509c			 
509c					FORTH_DSP_POP 
509c cd aa 23			call macro_forth_dsp_pop 
509f				endm 
# End of macro FORTH_DSP_POP
509f			 
509f d1					pop de     ; get file id 
50a0			 
50a0					; e = file id 
50a0					; l = file extent 
50a0			 
50a0			 
50a0					; construct request to access file extent 
50a0			 
50a0			;		ld a, e 
50a0 63					ld h, e 
50a1					 
50a1					 
50a1					 
50a1			 
50a1					; e has id 
50a1			 
50a1 11 77 fa			ld de, store_page 
50a4					if DEBUG_FORTH_WORDS 
50a4						DMARK "REr" 
50a4 f5				push af  
50a5 3a b9 50			ld a, (.dmark)  
50a8 32 68 fe			ld (debug_mark),a  
50ab 3a ba 50			ld a, (.dmark+1)  
50ae 32 69 fe			ld (debug_mark+1),a  
50b1 3a bb 50			ld a, (.dmark+2)  
50b4 32 6a fe			ld (debug_mark+2),a  
50b7 18 03			jr .pastdmark  
50b9 ..			.dmark: db "REr"  
50bc f1			.pastdmark: pop af  
50bd			endm  
# End of macro DMARK
50bd						CALLMONITOR 
50bd cd 6c fe			call debug_vector  
50c0				endm  
# End of macro CALLMONITOR
50c0					endif 
50c0 cd be 09				call storage_read 
50c3 cd f8 0f			call ishlzero 
50c6 28 22			jr z, .recnotfound 
50c8			 
50c8			 
50c8					if DEBUG_FORTH_WORDS 
50c8						DMARK "REe" 
50c8 f5				push af  
50c9 3a dd 50			ld a, (.dmark)  
50cc 32 68 fe			ld (debug_mark),a  
50cf 3a de 50			ld a, (.dmark+1)  
50d2 32 69 fe			ld (debug_mark+1),a  
50d5 3a df 50			ld a, (.dmark+2)  
50d8 32 6a fe			ld (debug_mark+2),a  
50db 18 03			jr .pastdmark  
50dd ..			.dmark: db "REe"  
50e0 f1			.pastdmark: pop af  
50e1			endm  
# End of macro DMARK
50e1						CALLMONITOR 
50e1 cd 6c fe			call debug_vector  
50e4				endm  
# End of macro CALLMONITOR
50e4					endif 
50e4 cd 69 21			call forth_push_str 
50e7			 
50e7					NEXTW 
50e7 c3 a8 24			jp macro_next 
50ea				endm 
# End of macro NEXTW
50ea			 
50ea			.recnotfound: 
50ea					if DEBUG_FORTH_WORDS 
50ea						DMARK "REf" 
50ea f5				push af  
50eb 3a ff 50			ld a, (.dmark)  
50ee 32 68 fe			ld (debug_mark),a  
50f1 3a 00 51			ld a, (.dmark+1)  
50f4 32 69 fe			ld (debug_mark+1),a  
50f7 3a 01 51			ld a, (.dmark+2)  
50fa 32 6a fe			ld (debug_mark+2),a  
50fd 18 03			jr .pastdmark  
50ff ..			.dmark: db "REf"  
5102 f1			.pastdmark: pop af  
5103			endm  
# End of macro DMARK
5103						CALLMONITOR 
5103 cd 6c fe			call debug_vector  
5106				endm  
# End of macro CALLMONITOR
5106					endif 
5106 21 ff 00			ld hl, 255 
5109 cd fb 20			call forth_push_numhl 
510c				NEXTW 
510c c3 a8 24			jp macro_next 
510f				endm 
# End of macro NEXTW
510f			 
510f			 
510f			.BREAD: 
510f			  
510f				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
510f 3a				db WORD_SYS_CORE+38             
5110 92 51			dw .BWRITE            
5112 06				db 5 + 1 
5113 .. 00			db "BREAD",0              
5119				endm 
# End of macro CWHEAD
5119			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
5119			; | | Compatible with PicoSPINet  
5119				 
5119					if DEBUG_FORTH_WORDS_KEY 
5119						DMARK "BRD" 
5119 f5				push af  
511a 3a 2e 51			ld a, (.dmark)  
511d 32 68 fe			ld (debug_mark),a  
5120 3a 2f 51			ld a, (.dmark+1)  
5123 32 69 fe			ld (debug_mark+1),a  
5126 3a 30 51			ld a, (.dmark+2)  
5129 32 6a fe			ld (debug_mark+2),a  
512c 18 03			jr .pastdmark  
512e ..			.dmark: db "BRD"  
5131 f1			.pastdmark: pop af  
5132			endm  
# End of macro DMARK
5132						CALLMONITOR 
5132 cd 6c fe			call debug_vector  
5135				endm  
# End of macro CALLMONITOR
5135					endif 
5135			 
5135				FORTH_DSP_VALUEHL 
5135 cd f2 22			call macro_dsp_valuehl 
5138				endm 
# End of macro FORTH_DSP_VALUEHL
5138			 
5138				FORTH_DSP_POP 
5138 cd aa 23			call macro_forth_dsp_pop 
513b				endm 
# End of macro FORTH_DSP_POP
513b			 
513b				; calc block address 
513b			 
513b eb				ex de, hl 
513c 3e 40			ld a, STORE_BLOCK_PHY 
513e cd 52 0f			call Mult16 
5141			 
5141			 
5141 11 77 fa			ld de, store_page 
5144			 
5144					if DEBUG_FORTH_WORDS 
5144						DMARK "BR1" 
5144 f5				push af  
5145 3a 59 51			ld a, (.dmark)  
5148 32 68 fe			ld (debug_mark),a  
514b 3a 5a 51			ld a, (.dmark+1)  
514e 32 69 fe			ld (debug_mark+1),a  
5151 3a 5b 51			ld a, (.dmark+2)  
5154 32 6a fe			ld (debug_mark+2),a  
5157 18 03			jr .pastdmark  
5159 ..			.dmark: db "BR1"  
515c f1			.pastdmark: pop af  
515d			endm  
# End of macro DMARK
515d						CALLMONITOR 
515d cd 6c fe			call debug_vector  
5160				endm  
# End of macro CALLMONITOR
5160					endif 
5160			 
5160 cd 65 04			call storage_read_block 
5163			 
5163 cd f8 0f			call ishlzero 
5166 20 05			jr nz, .brfound 
5168			 
5168 cd fb 20			call forth_push_numhl 
516b 18 22			jr .brdone 
516d			 
516d			 
516d			.brfound: 
516d 21 79 fa		        ld hl, store_page+2 
5170			 
5170					if DEBUG_FORTH_WORDS 
5170						DMARK "BR2" 
5170 f5				push af  
5171 3a 85 51			ld a, (.dmark)  
5174 32 68 fe			ld (debug_mark),a  
5177 3a 86 51			ld a, (.dmark+1)  
517a 32 69 fe			ld (debug_mark+1),a  
517d 3a 87 51			ld a, (.dmark+2)  
5180 32 6a fe			ld (debug_mark+2),a  
5183 18 03			jr .pastdmark  
5185 ..			.dmark: db "BR2"  
5188 f1			.pastdmark: pop af  
5189			endm  
# End of macro DMARK
5189						CALLMONITOR 
5189 cd 6c fe			call debug_vector  
518c				endm  
# End of macro CALLMONITOR
518c					endif 
518c			 
518c cd 69 21			call forth_push_str 
518f			 
518f			 
518f			.brdone: 
518f			 
518f					NEXTW 
518f c3 a8 24			jp macro_next 
5192				endm 
# End of macro NEXTW
5192			.BWRITE: 
5192				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5192 3a				db WORD_SYS_CORE+38             
5193 27 52			dw .BUPD            
5195 07				db 6 + 1 
5196 .. 00			db "BWRITE",0              
519d				endm 
# End of macro CWHEAD
519d			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
519d			; | | Compatible with PicoSPINet  
519d			 
519d					if DEBUG_FORTH_WORDS_KEY 
519d						DMARK "BWR" 
519d f5				push af  
519e 3a b2 51			ld a, (.dmark)  
51a1 32 68 fe			ld (debug_mark),a  
51a4 3a b3 51			ld a, (.dmark+1)  
51a7 32 69 fe			ld (debug_mark+1),a  
51aa 3a b4 51			ld a, (.dmark+2)  
51ad 32 6a fe			ld (debug_mark+2),a  
51b0 18 03			jr .pastdmark  
51b2 ..			.dmark: db "BWR"  
51b5 f1			.pastdmark: pop af  
51b6			endm  
# End of macro DMARK
51b6						CALLMONITOR 
51b6 cd 6c fe			call debug_vector  
51b9				endm  
# End of macro CALLMONITOR
51b9					endif 
51b9			 
51b9				FORTH_DSP_VALUEHL 
51b9 cd f2 22			call macro_dsp_valuehl 
51bc				endm 
# End of macro FORTH_DSP_VALUEHL
51bc			 
51bc				; calc block address 
51bc			 
51bc eb				ex de, hl 
51bd 3e 40			ld a, STORE_BLOCK_PHY 
51bf cd 52 0f			call Mult16 
51c2			 
51c2 e5				push hl         ; address 
51c3			 
51c3				FORTH_DSP_POP 
51c3 cd aa 23			call macro_forth_dsp_pop 
51c6				endm 
# End of macro FORTH_DSP_POP
51c6			 
51c6				FORTH_DSP_VALUEHL 
51c6 cd f2 22			call macro_dsp_valuehl 
51c9				endm 
# End of macro FORTH_DSP_VALUEHL
51c9			 
51c9				FORTH_DSP_POP 
51c9 cd aa 23			call macro_forth_dsp_pop 
51cc				endm 
# End of macro FORTH_DSP_POP
51cc			 
51cc cd a1 0c			call storage_clear_page 
51cf			 
51cf				; copy string to store page 
51cf			 
51cf e5				push hl     ; save string address 
51d0			 
51d0 3e 00			ld a, 0 
51d2 cd 38 14			call strlent 
51d5			 
51d5 23				inc hl 
51d6			 
51d6 4d				ld c, l 
51d7 06 00			ld b, 0 
51d9			 
51d9 e1				pop hl 
51da 11 79 fa			ld de, store_page + 2 
51dd					if DEBUG_FORTH_WORDS 
51dd						DMARK "BW1" 
51dd f5				push af  
51de 3a f2 51			ld a, (.dmark)  
51e1 32 68 fe			ld (debug_mark),a  
51e4 3a f3 51			ld a, (.dmark+1)  
51e7 32 69 fe			ld (debug_mark+1),a  
51ea 3a f4 51			ld a, (.dmark+2)  
51ed 32 6a fe			ld (debug_mark+2),a  
51f0 18 03			jr .pastdmark  
51f2 ..			.dmark: db "BW1"  
51f5 f1			.pastdmark: pop af  
51f6			endm  
# End of macro DMARK
51f6						CALLMONITOR 
51f6 cd 6c fe			call debug_vector  
51f9				endm  
# End of macro CALLMONITOR
51f9					endif 
51f9 ed b0			ldir 
51fb			 
51fb			 
51fb				; poke the start of the block with flags to prevent high level file ops hitting the block 
51fb			 
51fb 21 ff ff			ld hl, $ffff 
51fe			 
51fe 22 77 fa			ld (store_page), hl	 
5201				 
5201 e1				pop hl    ; get address 
5202 11 77 fa			ld de, store_page 
5205			 
5205					if DEBUG_FORTH_WORDS 
5205						DMARK "BW2" 
5205 f5				push af  
5206 3a 1a 52			ld a, (.dmark)  
5209 32 68 fe			ld (debug_mark),a  
520c 3a 1b 52			ld a, (.dmark+1)  
520f 32 69 fe			ld (debug_mark+1),a  
5212 3a 1c 52			ld a, (.dmark+2)  
5215 32 6a fe			ld (debug_mark+2),a  
5218 18 03			jr .pastdmark  
521a ..			.dmark: db "BW2"  
521d f1			.pastdmark: pop af  
521e			endm  
# End of macro DMARK
521e						CALLMONITOR 
521e cd 6c fe			call debug_vector  
5221				endm  
# End of macro CALLMONITOR
5221					endif 
5221			 
5221 cd ca 04			call storage_write_block 
5224			 
5224					NEXTW 
5224 c3 a8 24			jp macro_next 
5227				endm 
# End of macro NEXTW
5227			 
5227			.BUPD: 
5227				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
5227 3a				db WORD_SYS_CORE+38             
5228 7d 52			dw .BYID            
522a 05				db 4 + 1 
522b .. 00			db "BUPD",0              
5230				endm 
# End of macro CWHEAD
5230			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
5230			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
5230			; | | or completely different file system structure. 
5230			; | | Compatible with PicoSPINet  
5230			 
5230					if DEBUG_FORTH_WORDS_KEY 
5230						DMARK "BUD" 
5230 f5				push af  
5231 3a 45 52			ld a, (.dmark)  
5234 32 68 fe			ld (debug_mark),a  
5237 3a 46 52			ld a, (.dmark+1)  
523a 32 69 fe			ld (debug_mark+1),a  
523d 3a 47 52			ld a, (.dmark+2)  
5240 32 6a fe			ld (debug_mark+2),a  
5243 18 03			jr .pastdmark  
5245 ..			.dmark: db "BUD"  
5248 f1			.pastdmark: pop af  
5249			endm  
# End of macro DMARK
5249						CALLMONITOR 
5249 cd 6c fe			call debug_vector  
524c				endm  
# End of macro CALLMONITOR
524c					endif 
524c			 
524c				FORTH_DSP_VALUEHL 
524c cd f2 22			call macro_dsp_valuehl 
524f				endm 
# End of macro FORTH_DSP_VALUEHL
524f			 
524f				; calc block address 
524f			 
524f eb				ex de, hl 
5250 3e 40			ld a, STORE_BLOCK_PHY 
5252 cd 52 0f			call Mult16 
5255			 
5255				FORTH_DSP_POP 
5255 cd aa 23			call macro_forth_dsp_pop 
5258				endm 
# End of macro FORTH_DSP_POP
5258			 
5258			 
5258 11 77 fa			ld de, store_page 
525b			 
525b					if DEBUG_FORTH_WORDS 
525b						DMARK "BUe" 
525b f5				push af  
525c 3a 70 52			ld a, (.dmark)  
525f 32 68 fe			ld (debug_mark),a  
5262 3a 71 52			ld a, (.dmark+1)  
5265 32 69 fe			ld (debug_mark+1),a  
5268 3a 72 52			ld a, (.dmark+2)  
526b 32 6a fe			ld (debug_mark+2),a  
526e 18 03			jr .pastdmark  
5270 ..			.dmark: db "BUe"  
5273 f1			.pastdmark: pop af  
5274			endm  
# End of macro DMARK
5274						CALLMONITOR 
5274 cd 6c fe			call debug_vector  
5277				endm  
# End of macro CALLMONITOR
5277					endif 
5277			 
5277 cd ca 04			call storage_write_block 
527a			 
527a					NEXTW 
527a c3 a8 24			jp macro_next 
527d				endm 
# End of macro NEXTW
527d			 
527d			.BYID: 
527d			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
527d			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
527d			; 
527d			;		 
527d			;		if DEBUG_FORTH_WORDS_KEY 
527d			;			DMARK "BYID" 
527d			;			CALLMONITOR 
527d			;		endif 
527d			; 
527d			;		; get direct address 
527d			; 
527d			;		FORTH_DSP_VALUEHL 
527d			; 
527d			;		FORTH_DSP_POP 
527d			; 
527d			;	; calc block address 
527d			; 
527d			;	ex de, hl 
527d			;	ld a, STORE_BLOCK_PHY 
527d			;	call Mult16 
527d			;	;	do BREAD with number as param 
527d			;	; push the file name	 
527d			;	ld de, store_page 
527d			;	call storage_read_block 
527d			 ;       ld hl, store_page+2 
527d			; 
527d			; 
527d			;		NEXTW 
527d			;.BYNAME: 
527d				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
527d 3a				db WORD_SYS_CORE+38             
527e 96 52			dw .DIR            
5280 06				db 5 + 1 
5281 .. 00			db "GETID",0              
5287				endm 
# End of macro CWHEAD
5287			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
5287			; | | Compatible with PicoSPINet  
5287			 
5287					; get pointer to file name to seek 
5287			 
5287					FORTH_DSP_VALUEHL 
5287 cd f2 22			call macro_dsp_valuehl 
528a				endm 
# End of macro FORTH_DSP_VALUEHL
528a			 
528a			 
528a cd 8c 03				call storage_getid  
528d			 
528d					FORTH_DSP_POP 
528d cd aa 23			call macro_forth_dsp_pop 
5290				endm 
# End of macro FORTH_DSP_POP
5290			 
5290 cd fb 20				call forth_push_numhl 
5293			 
5293					NEXTW 
5293 c3 a8 24			jp macro_next 
5296				endm 
# End of macro NEXTW
5296			; 
5296			.DIR: 
5296				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
5296 3a				db WORD_SYS_CORE+38             
5297 9a 53			dw .SAVE            
5299 04				db 3 + 1 
529a .. 00			db "DIR",0              
529e				endm 
# End of macro CWHEAD
529e			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
529e			; | | Compatible with PicoSPINet  
529e			 
529e					if DEBUG_FORTH_WORDS_KEY 
529e						DMARK "DIR" 
529e f5				push af  
529f 3a b3 52			ld a, (.dmark)  
52a2 32 68 fe			ld (debug_mark),a  
52a5 3a b4 52			ld a, (.dmark+1)  
52a8 32 69 fe			ld (debug_mark+1),a  
52ab 3a b5 52			ld a, (.dmark+2)  
52ae 32 6a fe			ld (debug_mark+2),a  
52b1 18 03			jr .pastdmark  
52b3 ..			.dmark: db "DIR"  
52b6 f1			.pastdmark: pop af  
52b7			endm  
# End of macro DMARK
52b7						CALLMONITOR 
52b7 cd 6c fe			call debug_vector  
52ba				endm  
# End of macro CALLMONITOR
52ba					endif 
52ba cd 16 05			call storage_get_block_0 
52bd			 
52bd 21 77 fa			ld hl, store_page     ; get current id count 
52c0 46				ld b, (hl) 
52c1 0e 00			ld c, 0    ; count of files   
52c3					if DEBUG_FORTH_WORDS 
52c3						DMARK "DI1" 
52c3 f5				push af  
52c4 3a d8 52			ld a, (.dmark)  
52c7 32 68 fe			ld (debug_mark),a  
52ca 3a d9 52			ld a, (.dmark+1)  
52cd 32 69 fe			ld (debug_mark+1),a  
52d0 3a da 52			ld a, (.dmark+2)  
52d3 32 6a fe			ld (debug_mark+2),a  
52d6 18 03			jr .pastdmark  
52d8 ..			.dmark: db "DI1"  
52db f1			.pastdmark: pop af  
52dc			endm  
# End of macro DMARK
52dc						CALLMONITOR 
52dc cd 6c fe			call debug_vector  
52df				endm  
# End of macro CALLMONITOR
52df					endif 
52df			 
52df				; check for empty drive 
52df			 
52df 3e 00			ld a, 0 
52e1 b8				cp b 
52e2 ca 50 53			jp z, .dirdone 
52e5			 
52e5				; for each of the current ids do a search for them and if found push to stack 
52e5			 
52e5 c5			.diritem:	push bc 
52e6 21 40 00				ld hl, STORE_BLOCK_PHY 
52e9 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
52eb 58					ld e,b 
52ec			 
52ec			;		if DEBUG_FORTH_WORDS 
52ec			;			DMARK "DI2" 
52ec			;			CALLMONITOR 
52ec			;		endif 
52ec			 
52ec cd 98 07				call storage_findnextid 
52ef			 
52ef			;		if DEBUG_FORTH_WORDS 
52ef			;			DMARK "DI3" 
52ef			;			CALLMONITOR 
52ef			;		endif 
52ef			 
52ef					; if found hl will be non zero 
52ef			 
52ef cd f8 0f				call ishlzero 
52f2			;		ld a, l 
52f2			;		add h 
52f2			; 
52f2			;		cp 0 
52f2 28 59				jr z, .dirnotfound 
52f4			 
52f4					; increase count 
52f4			 
52f4 c1					pop bc	 
52f5 0c					inc c 
52f6 c5					push bc 
52f7					 
52f7			 
52f7					; get file header and push the file name 
52f7			 
52f7 11 77 fa				ld de, store_page 
52fa cd 65 04				call storage_read_block 
52fd			 
52fd					; push file id to stack 
52fd				 
52fd 3a 77 fa				ld a, (store_page) 
5300 26 00				ld h, 0 
5302 6f					ld l, a 
5303 cd fb 20				call forth_push_numhl 
5306			 
5306					; push extent count to stack  
5306				 
5306 3a 79 fa				ld a, (store_page+2) 
5309 26 00				ld h, 0 
530b 6f					ld l, a 
530c cd fb 20				call forth_push_numhl 
530f			 
530f					; push file name 
530f			 
530f 21 7a fa				ld hl, store_page+3 
5312					if DEBUG_FORTH_WORDS 
5312						DMARK "DI5" 
5312 f5				push af  
5313 3a 27 53			ld a, (.dmark)  
5316 32 68 fe			ld (debug_mark),a  
5319 3a 28 53			ld a, (.dmark+1)  
531c 32 69 fe			ld (debug_mark+1),a  
531f 3a 29 53			ld a, (.dmark+2)  
5322 32 6a fe			ld (debug_mark+2),a  
5325 18 03			jr .pastdmark  
5327 ..			.dmark: db "DI5"  
532a f1			.pastdmark: pop af  
532b			endm  
# End of macro DMARK
532b						CALLMONITOR 
532b cd 6c fe			call debug_vector  
532e				endm  
# End of macro CALLMONITOR
532e					endif 
532e cd 69 21				call forth_push_str 
5331					if DEBUG_FORTH_WORDS 
5331						DMARK "DI6" 
5331 f5				push af  
5332 3a 46 53			ld a, (.dmark)  
5335 32 68 fe			ld (debug_mark),a  
5338 3a 47 53			ld a, (.dmark+1)  
533b 32 69 fe			ld (debug_mark+1),a  
533e 3a 48 53			ld a, (.dmark+2)  
5341 32 6a fe			ld (debug_mark+2),a  
5344 18 03			jr .pastdmark  
5346 ..			.dmark: db "DI6"  
5349 f1			.pastdmark: pop af  
534a			endm  
# End of macro DMARK
534a						CALLMONITOR 
534a cd 6c fe			call debug_vector  
534d				endm  
# End of macro CALLMONITOR
534d					endif 
534d			.dirnotfound: 
534d c1					pop bc     
534e 10 95				djnz .diritem 
5350				 
5350			.dirdone:	 
5350					if DEBUG_FORTH_WORDS 
5350						DMARK "DI7" 
5350 f5				push af  
5351 3a 65 53			ld a, (.dmark)  
5354 32 68 fe			ld (debug_mark),a  
5357 3a 66 53			ld a, (.dmark+1)  
535a 32 69 fe			ld (debug_mark+1),a  
535d 3a 67 53			ld a, (.dmark+2)  
5360 32 6a fe			ld (debug_mark+2),a  
5363 18 03			jr .pastdmark  
5365 ..			.dmark: db "DI7"  
5368 f1			.pastdmark: pop af  
5369			endm  
# End of macro DMARK
5369						CALLMONITOR 
5369 cd 6c fe			call debug_vector  
536c				endm  
# End of macro CALLMONITOR
536c					endif 
536c			 
536c					; push a count of the dir items found 
536c			 
536c 26 00				ld h, 0 
536e 69					ld l, c 
536f cd fb 20				call forth_push_numhl 
5372			 
5372					; push the bank label 
5372			 
5372 cd 16 05				call storage_get_block_0 
5375			 
5375				 
5375 21 7a fa		 		ld hl, store_page+3 
5378			 
5378					if DEBUG_FORTH_WORDS 
5378						DMARK "DI8" 
5378 f5				push af  
5379 3a 8d 53			ld a, (.dmark)  
537c 32 68 fe			ld (debug_mark),a  
537f 3a 8e 53			ld a, (.dmark+1)  
5382 32 69 fe			ld (debug_mark+1),a  
5385 3a 8f 53			ld a, (.dmark+2)  
5388 32 6a fe			ld (debug_mark+2),a  
538b 18 03			jr .pastdmark  
538d ..			.dmark: db "DI8"  
5390 f1			.pastdmark: pop af  
5391			endm  
# End of macro DMARK
5391						CALLMONITOR 
5391 cd 6c fe			call debug_vector  
5394				endm  
# End of macro CALLMONITOR
5394					endif 
5394 cd 69 21				call forth_push_str 
5397			 
5397			 
5397				 
5397					NEXTW 
5397 c3 a8 24			jp macro_next 
539a				endm 
# End of macro NEXTW
539a			.SAVE: 
539a			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
539a			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
539a			;		NEXTW 
539a			;.LOAD: 
539a			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
539a			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
539a			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
539a			;; > > The LOAD command can not be used in any user words or compound lines. 
539a			; 
539a			;		; store_openext use it. If zero it is EOF 
539a			; 
539a			;		; read block from current stream id 
539a			;		; if the block does not contain zero term keep reading blocks until zero found 
539a			;		; push the block to stack 
539a			;		; save the block id to stream 
539a			; 
539a			; 
539a			;		FORTH_DSP_VALUEHL 
539a			; 
539a			;;		push hl 
539a			; 
539a			;	if DEBUG_STORESE 
539a			;		DMARK "LOA" 
539a			;		CALLMONITOR 
539a			;	endif 
539a			;		FORTH_DSP_POP 
539a			; 
539a			;;		pop hl 
539a			; 
539a			;		ld h, l 
539a			;		ld l, 0 
539a			; 
539a			;		push hl     ; stack holds current file id and extent to work with 
539a			; 
539a			; 
539a			;		ld de, store_page      ; get block zero of file 
539a			;	if DEBUG_STORESE 
539a			;		DMARK "LO0" 
539a			;		CALLMONITOR 
539a			;	endif 
539a			;		call storage_read 
539a			; 
539a			;		ld a, (store_page+2)    ; max extents for this file 
539a			;		ld  (store_openmaxext),a   ; get our limit 
539a			; 
539a			;	if DEBUG_STORESE 
539a			;		DMARK "LOE" 
539a			;		CALLMONITOR 
539a			;	endif 
539a			; 
539a			;; TODO dont know why max extents are not present 
539a			;;		cp 0 
539a			;;		jp z, .loadeof     ; dont read past eof 
539a			; 
539a			;;		ld a, 1   ; start from the head of the file 
539a			; 
539a			;.loadline:	pop hl 
539a			;		inc hl 
539a			;		ld  a, (store_openmaxext)   ; get our limit 
539a			;	if DEBUG_STORESE 
539a			;		DMARK "LOx" 
539a			;		CALLMONITOR 
539a			;	endif 
539a			;		inc a 
539a			;		cp l 
539a			;		jp z, .loadeof 
539a			;		push hl    ; save current extent 
539a			; 
539a			;		ld de, store_page 
539a			; 
539a			;	if DEBUG_STORESE 
539a			;		DMARK "LO1" 
539a			;		CALLMONITOR 
539a			;	endif 
539a			;		call storage_read 
539a			; 
539a			;	if DEBUG_STORESE 
539a			;		DMARK "LO2" 
539a			;		CALLMONITOR 
539a			;	endif 
539a			;	call ishlzero 
539a			;	ld a, l 
539a			;	add h 
539a			;	cp 0 
539a			;	jr z, .loadeof 
539a			; 
539a			;	; not eof so hl should point to data to exec 
539a			; 
539a			;	; will need to add the FORTH_END_BUFFER flag 
539a			 ; 
539a			;	ld hl, store_page+2 
539a			;	ld bc, 255 
539a			;	ld a, 0 
539a			;	cpir 
539a			;	if DEBUG_STORESE 
539a			;		DMARK "LOt" 
539a			;		CALLMONITOR 
539a			;	endif 
539a			;	dec hl 
539a			;	ld a, ' ' 
539a			;	ld (hl), a 
539a			;	inc hl 
539a			;	ld (hl), a 
539a			;	inc hl 
539a			;	ld (hl), a 
539a			;	inc hl 
539a			;	ld a, FORTH_END_BUFFER 
539a			;	ld (hl), a 
539a			; 
539a			;	; TODO handle more than a single block read 
539a			; 
539a			; 
539a			;	ld hl, store_page+2 
539a			; 
539a			;	ld (os_tok_ptr), hl 
539a			; 
539a			;	if DEBUG_STORESE 
539a			;		DMARK "LO3" 
539a			;		CALLMONITOR 
539a			;	endif 
539a			; 
539a			;	call forthparse 
539a			;	call forthexec 
539a			;	call forthexec_cleanup 
539a			; 
539a			;	; go to next extent 
539a			; 
539a			;	; get next block  or mark as eof 
539a			;	jp .loadline 
539a			; 
539a			; 
539a			; 
539a			;	       NEXTW 
539a			;.loadeof:	ld a, 0 
539a			;		ld (store_openext), a 
539a			; 
539a			;	if DEBUG_STORESE 
539a			;		DMARK "LOF" 
539a			;		CALLMONITOR 
539a			;	endif 
539a			;		ret 
539a			;		;NEXTW 
539a			;.BSAVE:   
539a			; 
539a			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
539a			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
539a			;		NEXTW 
539a			;.BLOAD: 
539a			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
539a			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
539a			;		NEXTW 
539a			;;;; counter gap 
539a			 
539a			 
539a			.SEO: 
539a				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
539a 64				db WORD_SYS_CORE+80             
539b b9 53			dw .SEI            
539d 04				db 3 + 1 
539e .. 00			db "SEO",0              
53a2				endm 
# End of macro CWHEAD
53a2			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
53a2			 
53a2					; get port 
53a2			 
53a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53a2 cd f2 22			call macro_dsp_valuehl 
53a5				endm 
# End of macro FORTH_DSP_VALUEHL
53a5			 
53a5 e5					push hl    ; u2 - byte 
53a6			 
53a6					; destroy value TOS 
53a6			 
53a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53a6 cd aa 23			call macro_forth_dsp_pop 
53a9				endm 
# End of macro FORTH_DSP_POP
53a9			 
53a9					; get byte to send 
53a9			 
53a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53a9 cd f2 22			call macro_dsp_valuehl 
53ac				endm 
# End of macro FORTH_DSP_VALUEHL
53ac			 
53ac e5					push hl    ; u1 - addr 
53ad			 
53ad					; destroy value TOS 
53ad			 
53ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53ad cd aa 23			call macro_forth_dsp_pop 
53b0				endm 
# End of macro FORTH_DSP_POP
53b0			 
53b0					; one value on hl get other one back 
53b0			 
53b0 d1					pop de   ; u1 - byte 
53b1			 
53b1 e1					pop hl   ; u2 - addr 
53b2			 
53b2					; TODO Send SPI byte 
53b2			 
53b2			 
53b2 7b					ld a, e 
53b3 cd 6a 02				call se_writebyte 
53b6			 
53b6					 
53b6			 
53b6					NEXTW 
53b6 c3 a8 24			jp macro_next 
53b9				endm 
# End of macro NEXTW
53b9			 
53b9			.SEI: 
53b9				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
53b9 65				db WORD_SYS_CORE+81             
53ba d3 53			dw .SFREE            
53bc 04				db 3 + 1 
53bd .. 00			db "SEI",0              
53c1				endm 
# End of macro CWHEAD
53c1			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
53c1			 
53c1					; get port 
53c1			 
53c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53c1 cd f2 22			call macro_dsp_valuehl 
53c4				endm 
# End of macro FORTH_DSP_VALUEHL
53c4			 
53c4			;		push hl 
53c4			 
53c4					; destroy value TOS 
53c4			 
53c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53c4 cd aa 23			call macro_forth_dsp_pop 
53c7				endm 
# End of macro FORTH_DSP_POP
53c7			 
53c7					; one value on hl get other one back 
53c7			 
53c7			;		pop hl 
53c7			 
53c7			 
53c7					; TODO Get SPI byte 
53c7			 
53c7 cd 0c 03				call se_readbyte 
53ca			 
53ca 26 00				ld h, 0 
53cc 6f					ld l, a 
53cd cd fb 20				call forth_push_numhl 
53d0			 
53d0					NEXTW 
53d0 c3 a8 24			jp macro_next 
53d3				endm 
# End of macro NEXTW
53d3			 
53d3			.SFREE: 
53d3				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
53d3 67				db WORD_SYS_CORE+83             
53d4 02 54			dw .SIZE            
53d6 06				db 5 + 1 
53d7 .. 00			db "FFREE",0              
53dd				endm 
# End of macro CWHEAD
53dd			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
53dd			; | | Compatible with PicoSPINet  
53dd					if DEBUG_FORTH_WORDS_KEY 
53dd						DMARK "FFR" 
53dd f5				push af  
53de 3a f2 53			ld a, (.dmark)  
53e1 32 68 fe			ld (debug_mark),a  
53e4 3a f3 53			ld a, (.dmark+1)  
53e7 32 69 fe			ld (debug_mark+1),a  
53ea 3a f4 53			ld a, (.dmark+2)  
53ed 32 6a fe			ld (debug_mark+2),a  
53f0 18 03			jr .pastdmark  
53f2 ..			.dmark: db "FFR"  
53f5 f1			.pastdmark: pop af  
53f6			endm  
# End of macro DMARK
53f6						CALLMONITOR 
53f6 cd 6c fe			call debug_vector  
53f9				endm  
# End of macro CALLMONITOR
53f9					endif 
53f9			 
53f9 cd 32 08				call storage_freeblocks 
53fc			 
53fc cd fb 20				call forth_push_numhl 
53ff			 
53ff				       NEXTW 
53ff c3 a8 24			jp macro_next 
5402				endm 
# End of macro NEXTW
5402			.SIZE: 
5402				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5402 67				db WORD_SYS_CORE+83             
5403 36 54			dw .CREATE            
5405 05				db 4 + 1 
5406 .. 00			db "SIZE",0              
540b				endm 
# End of macro CWHEAD
540b			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
540b			; | | Compatible with PicoSPINet  
540b					if DEBUG_FORTH_WORDS_KEY 
540b						DMARK "SIZ" 
540b f5				push af  
540c 3a 20 54			ld a, (.dmark)  
540f 32 68 fe			ld (debug_mark),a  
5412 3a 21 54			ld a, (.dmark+1)  
5415 32 69 fe			ld (debug_mark+1),a  
5418 3a 22 54			ld a, (.dmark+2)  
541b 32 6a fe			ld (debug_mark+2),a  
541e 18 03			jr .pastdmark  
5420 ..			.dmark: db "SIZ"  
5423 f1			.pastdmark: pop af  
5424			endm  
# End of macro DMARK
5424						CALLMONITOR 
5424 cd 6c fe			call debug_vector  
5427				endm  
# End of macro CALLMONITOR
5427					endif 
5427			 
5427					FORTH_DSP_VALUEHL 
5427 cd f2 22			call macro_dsp_valuehl 
542a				endm 
# End of macro FORTH_DSP_VALUEHL
542a			;		push hl 
542a					FORTH_DSP_POP 
542a cd aa 23			call macro_forth_dsp_pop 
542d				endm 
# End of macro FORTH_DSP_POP
542d			;		pop hl 
542d cd 94 04				call storage_file_size 
5430			 
5430 cd fb 20				call forth_push_numhl 
5433			  
5433			 
5433				       NEXTW 
5433 c3 a8 24			jp macro_next 
5436				endm 
# End of macro NEXTW
5436			 
5436			.CREATE: 
5436				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5436 68				db WORD_SYS_CORE+84             
5437 a4 54			dw .APPEND            
5439 07				db 6 + 1 
543a .. 00			db "CREATE",0              
5441				endm 
# End of macro CWHEAD
5441			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5441			; | | e.g.  
5441			; | | TestProgram CREATE 
5441			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5441			; | |  
5441			; | | Max file IDs are 255. 
5441			; | |  
5441			; | | Compatible with PicoSPINet  
5441					 
5441					if DEBUG_FORTH_WORDS_KEY 
5441						DMARK "CRT" 
5441 f5				push af  
5442 3a 56 54			ld a, (.dmark)  
5445 32 68 fe			ld (debug_mark),a  
5448 3a 57 54			ld a, (.dmark+1)  
544b 32 69 fe			ld (debug_mark+1),a  
544e 3a 58 54			ld a, (.dmark+2)  
5451 32 6a fe			ld (debug_mark+2),a  
5454 18 03			jr .pastdmark  
5456 ..			.dmark: db "CRT"  
5459 f1			.pastdmark: pop af  
545a			endm  
# End of macro DMARK
545a						CALLMONITOR 
545a cd 6c fe			call debug_vector  
545d				endm  
# End of macro CALLMONITOR
545d					endif 
545d			;		call storage_get_block_0 
545d			 
545d					; TODO pop hl 
545d			 
545d					;v5 FORTH_DSP_VALUE 
545d					FORTH_DSP_VALUE 
545d cd db 22			call macro_forth_dsp_value 
5460				endm 
# End of macro FORTH_DSP_VALUE
5460			 
5460				if DEBUG_STORESE 
5460					DMARK "CR1" 
5460 f5				push af  
5461 3a 75 54			ld a, (.dmark)  
5464 32 68 fe			ld (debug_mark),a  
5467 3a 76 54			ld a, (.dmark+1)  
546a 32 69 fe			ld (debug_mark+1),a  
546d 3a 77 54			ld a, (.dmark+2)  
5470 32 6a fe			ld (debug_mark+2),a  
5473 18 03			jr .pastdmark  
5475 ..			.dmark: db "CR1"  
5478 f1			.pastdmark: pop af  
5479			endm  
# End of macro DMARK
5479					CALLMONITOR 
5479 cd 6c fe			call debug_vector  
547c				endm  
# End of macro CALLMONITOR
547c				endif 
547c			;		push hl 
547c			;		FORTH_DSP_POP 
547c			;		pop hl 
547c			 
547c			;		inc hl   ; move past the type marker 
547c			 
547c cd 68 08				call storage_create 
547f			 
547f				if DEBUG_STORESE 
547f					DMARK "CT1" 
547f f5				push af  
5480 3a 94 54			ld a, (.dmark)  
5483 32 68 fe			ld (debug_mark),a  
5486 3a 95 54			ld a, (.dmark+1)  
5489 32 69 fe			ld (debug_mark+1),a  
548c 3a 96 54			ld a, (.dmark+2)  
548f 32 6a fe			ld (debug_mark+2),a  
5492 18 03			jr .pastdmark  
5494 ..			.dmark: db "CT1"  
5497 f1			.pastdmark: pop af  
5498			endm  
# End of macro DMARK
5498					CALLMONITOR 
5498 cd 6c fe			call debug_vector  
549b				endm  
# End of macro CALLMONITOR
549b				endif 
549b			;		push hl 
549b					FORTH_DSP_POP 
549b cd aa 23			call macro_forth_dsp_pop 
549e				endm 
# End of macro FORTH_DSP_POP
549e			;		pop hl 
549e					; push file id to stack 
549e cd fb 20				call forth_push_numhl 
54a1			 
54a1			 
54a1			 
54a1				       NEXTW 
54a1 c3 a8 24			jp macro_next 
54a4				endm 
# End of macro NEXTW
54a4			 
54a4			.APPEND: 
54a4				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
54a4 69				db WORD_SYS_CORE+85             
54a5 35 55			dw .SDEL            
54a7 07				db 6 + 1 
54a8 .. 00			db "APPEND",0              
54af				endm 
# End of macro CWHEAD
54af			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
54af			; | | e.g. 
54af			; | | Test CREATE      -> $01 
54af			; | | "A string to add to file" $01 APPEND 
54af			; | |  
54af			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
54af			; | | Compatible with PicoSPINet  
54af					if DEBUG_FORTH_WORDS_KEY 
54af						DMARK "APP" 
54af f5				push af  
54b0 3a c4 54			ld a, (.dmark)  
54b3 32 68 fe			ld (debug_mark),a  
54b6 3a c5 54			ld a, (.dmark+1)  
54b9 32 69 fe			ld (debug_mark+1),a  
54bc 3a c6 54			ld a, (.dmark+2)  
54bf 32 6a fe			ld (debug_mark+2),a  
54c2 18 03			jr .pastdmark  
54c4 ..			.dmark: db "APP"  
54c7 f1			.pastdmark: pop af  
54c8			endm  
# End of macro DMARK
54c8						CALLMONITOR 
54c8 cd 6c fe			call debug_vector  
54cb				endm  
# End of macro CALLMONITOR
54cb					endif 
54cb			 
54cb					FORTH_DSP_VALUEHL 
54cb cd f2 22			call macro_dsp_valuehl 
54ce				endm 
# End of macro FORTH_DSP_VALUEHL
54ce e5					push hl 	; save file id 
54cf			 
54cf				if DEBUG_STORESE 
54cf					DMARK "AP1" 
54cf f5				push af  
54d0 3a e4 54			ld a, (.dmark)  
54d3 32 68 fe			ld (debug_mark),a  
54d6 3a e5 54			ld a, (.dmark+1)  
54d9 32 69 fe			ld (debug_mark+1),a  
54dc 3a e6 54			ld a, (.dmark+2)  
54df 32 6a fe			ld (debug_mark+2),a  
54e2 18 03			jr .pastdmark  
54e4 ..			.dmark: db "AP1"  
54e7 f1			.pastdmark: pop af  
54e8			endm  
# End of macro DMARK
54e8					CALLMONITOR 
54e8 cd 6c fe			call debug_vector  
54eb				endm  
# End of macro CALLMONITOR
54eb				endif 
54eb					FORTH_DSP_POP 
54eb cd aa 23			call macro_forth_dsp_pop 
54ee				endm 
# End of macro FORTH_DSP_POP
54ee			 
54ee					FORTH_DSP_VALUEHL 
54ee cd f2 22			call macro_dsp_valuehl 
54f1				endm 
# End of macro FORTH_DSP_VALUEHL
54f1					;v5 FORTH_DSP_VALUE 
54f1 e5					push hl 	; save ptr to string to save 
54f2			 
54f2				if DEBUG_STORESE 
54f2					DMARK "AP1" 
54f2 f5				push af  
54f3 3a 07 55			ld a, (.dmark)  
54f6 32 68 fe			ld (debug_mark),a  
54f9 3a 08 55			ld a, (.dmark+1)  
54fc 32 69 fe			ld (debug_mark+1),a  
54ff 3a 09 55			ld a, (.dmark+2)  
5502 32 6a fe			ld (debug_mark+2),a  
5505 18 03			jr .pastdmark  
5507 ..			.dmark: db "AP1"  
550a f1			.pastdmark: pop af  
550b			endm  
# End of macro DMARK
550b					CALLMONITOR 
550b cd 6c fe			call debug_vector  
550e				endm  
# End of macro CALLMONITOR
550e				endif 
550e					FORTH_DSP_POP 
550e cd aa 23			call macro_forth_dsp_pop 
5511				endm 
# End of macro FORTH_DSP_POP
5511			 
5511 d1					pop de 
5512 e1					pop hl 
5513				if DEBUG_STORESE 
5513					DMARK "AP2" 
5513 f5				push af  
5514 3a 28 55			ld a, (.dmark)  
5517 32 68 fe			ld (debug_mark),a  
551a 3a 29 55			ld a, (.dmark+1)  
551d 32 69 fe			ld (debug_mark+1),a  
5520 3a 2a 55			ld a, (.dmark+2)  
5523 32 6a fe			ld (debug_mark+2),a  
5526 18 03			jr .pastdmark  
5528 ..			.dmark: db "AP2"  
552b f1			.pastdmark: pop af  
552c			endm  
# End of macro DMARK
552c					CALLMONITOR 
552c cd 6c fe			call debug_vector  
552f				endm  
# End of macro CALLMONITOR
552f				endif 
552f					;inc de ; skip var type indicator 
552f			 
552f					; TODO how to append numerics???? 
552f			 
552f cd 55 0b				call storage_append		 
5532			 
5532				       NEXTW 
5532 c3 a8 24			jp macro_next 
5535				endm 
# End of macro NEXTW
5535			.SDEL: 
5535				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5535 6a				db WORD_SYS_CORE+86             
5536 81 55			dw .OPEN            
5538 05				db 4 + 1 
5539 .. 00			db "ERA",0              
553d				endm 
# End of macro CWHEAD
553d			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
553d			; | | Compatible with PicoSPINet  
553d					FORTH_DSP_VALUEHL 
553d cd f2 22			call macro_dsp_valuehl 
5540				endm 
# End of macro FORTH_DSP_VALUEHL
5540			;		push hl 	; save file id 
5540			 
5540					if DEBUG_FORTH_WORDS_KEY 
5540						DMARK "ERA" 
5540 f5				push af  
5541 3a 55 55			ld a, (.dmark)  
5544 32 68 fe			ld (debug_mark),a  
5547 3a 56 55			ld a, (.dmark+1)  
554a 32 69 fe			ld (debug_mark+1),a  
554d 3a 57 55			ld a, (.dmark+2)  
5550 32 6a fe			ld (debug_mark+2),a  
5553 18 03			jr .pastdmark  
5555 ..			.dmark: db "ERA"  
5558 f1			.pastdmark: pop af  
5559			endm  
# End of macro DMARK
5559						CALLMONITOR 
5559 cd 6c fe			call debug_vector  
555c				endm  
# End of macro CALLMONITOR
555c					endif 
555c				if DEBUG_STORESE 
555c					DMARK "ER1" 
555c f5				push af  
555d 3a 71 55			ld a, (.dmark)  
5560 32 68 fe			ld (debug_mark),a  
5563 3a 72 55			ld a, (.dmark+1)  
5566 32 69 fe			ld (debug_mark+1),a  
5569 3a 73 55			ld a, (.dmark+2)  
556c 32 6a fe			ld (debug_mark+2),a  
556f 18 03			jr .pastdmark  
5571 ..			.dmark: db "ER1"  
5574 f1			.pastdmark: pop af  
5575			endm  
# End of macro DMARK
5575					CALLMONITOR 
5575 cd 6c fe			call debug_vector  
5578				endm  
# End of macro CALLMONITOR
5578				endif 
5578					FORTH_DSP_POP 
5578 cd aa 23			call macro_forth_dsp_pop 
557b				endm 
# End of macro FORTH_DSP_POP
557b			 
557b			;		pop hl 
557b			 
557b cd a7 06				call storage_erase 
557e				       NEXTW 
557e c3 a8 24			jp macro_next 
5581				endm 
# End of macro NEXTW
5581			 
5581			.OPEN: 
5581				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5581 6b				db WORD_SYS_CORE+87             
5582 15 56			dw .READ            
5584 05				db 4 + 1 
5585 .. 00			db "OPEN",0              
558a				endm 
# End of macro CWHEAD
558a			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
558a			; | | e.g. 
558a			; | | $01 OPEN $01 DO $01 READ . LOOP 
558a			; | | 
558a			; | | Will return with 255 blocks if the file does not exist 
558a			; | | Compatible with PicoSPINet  
558a			 
558a					if DEBUG_FORTH_WORDS_KEY 
558a						DMARK "OPN" 
558a f5				push af  
558b 3a 9f 55			ld a, (.dmark)  
558e 32 68 fe			ld (debug_mark),a  
5591 3a a0 55			ld a, (.dmark+1)  
5594 32 69 fe			ld (debug_mark+1),a  
5597 3a a1 55			ld a, (.dmark+2)  
559a 32 6a fe			ld (debug_mark+2),a  
559d 18 03			jr .pastdmark  
559f ..			.dmark: db "OPN"  
55a2 f1			.pastdmark: pop af  
55a3			endm  
# End of macro DMARK
55a3						CALLMONITOR 
55a3 cd 6c fe			call debug_vector  
55a6				endm  
# End of macro CALLMONITOR
55a6					endif 
55a6					; TODO handle multiple file opens 
55a6			 
55a6 3e 01			       	ld a, 1 
55a8 32 67 fa				ld (store_openext), a 
55ab			 
55ab					; get max extents for this file 
55ab				 
55ab								 
55ab					FORTH_DSP_VALUEHL 
55ab cd f2 22			call macro_dsp_valuehl 
55ae				endm 
# End of macro FORTH_DSP_VALUEHL
55ae			 
55ae 65					ld h, l 
55af 2e 00				ld l, 0 
55b1			 
55b1					; store file id 
55b1			 
55b1 7c					ld a, h 
55b2 32 64 fa				ld (store_filecache), a 
55b5			 
55b5				if DEBUG_STORESE 
55b5					DMARK "OPN" 
55b5 f5				push af  
55b6 3a ca 55			ld a, (.dmark)  
55b9 32 68 fe			ld (debug_mark),a  
55bc 3a cb 55			ld a, (.dmark+1)  
55bf 32 69 fe			ld (debug_mark+1),a  
55c2 3a cc 55			ld a, (.dmark+2)  
55c5 32 6a fe			ld (debug_mark+2),a  
55c8 18 03			jr .pastdmark  
55ca ..			.dmark: db "OPN"  
55cd f1			.pastdmark: pop af  
55ce			endm  
# End of macro DMARK
55ce					CALLMONITOR 
55ce cd 6c fe			call debug_vector  
55d1				endm  
# End of macro CALLMONITOR
55d1				endif 
55d1			;		push hl 
55d1					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
55d1 cd aa 23			call macro_forth_dsp_pop 
55d4				endm 
# End of macro FORTH_DSP_POP
55d4			;		pop hl 
55d4						 
55d4 11 77 fa				ld de, store_page      ; get block zero of file 
55d7 cd be 09				call storage_read 
55da cd f8 0f			call ishlzero 
55dd 20 04			jr nz, .opfound 
55df			 
55df				; file does not exist so indicate with 255 extents in use 
55df			 
55df 3e ff			ld a, 255 
55e1 18 29			jr .skipopeneof 
55e3			 
55e3			 
55e3			.opfound: 
55e3			 
55e3			 
55e3 3a 79 fa				ld a, (store_page+2)    ; max extents for this file 
55e6 32 66 fa				ld  (store_openmaxext), a   ; get our limit and push 
55e9					 
55e9				if DEBUG_STORESE 
55e9					DMARK "OPx" 
55e9 f5				push af  
55ea 3a fe 55			ld a, (.dmark)  
55ed 32 68 fe			ld (debug_mark),a  
55f0 3a ff 55			ld a, (.dmark+1)  
55f3 32 69 fe			ld (debug_mark+1),a  
55f6 3a 00 56			ld a, (.dmark+2)  
55f9 32 6a fe			ld (debug_mark+2),a  
55fc 18 03			jr .pastdmark  
55fe ..			.dmark: db "OPx"  
5601 f1			.pastdmark: pop af  
5602			endm  
# End of macro DMARK
5602					CALLMONITOR 
5602 cd 6c fe			call debug_vector  
5605				endm  
# End of macro CALLMONITOR
5605				endif 
5605 fe 00				cp 0 
5607 20 03				jr nz, .skipopeneof 
5609					; have opened an empty file 
5609					 
5609 32 67 fa				ld (store_openext), a 
560c			 
560c			.skipopeneof: 
560c			 
560c 6f					ld l, a 
560d 26 00				ld h, 0 
560f cd fb 20				call forth_push_numhl 
5612			 
5612			 
5612				       NEXTW 
5612 c3 a8 24			jp macro_next 
5615				endm 
# End of macro NEXTW
5615			.READ: 
5615				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5615 6c				db WORD_SYS_CORE+88             
5616 3f 57			dw .EOF            
5618 05				db 4 + 1 
5619 .. 00			db "READ",0              
561e				endm 
# End of macro CWHEAD
561e			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
561e			; | | e.g. 
561e			; | | $01 OPEN $01 DO READ . LOOP 
561e			; | | 
561e			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
561e			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
561e			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
561e			; | | two bytes contain the file id and extent. 
561e			; | |  
561e			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
561e			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
561e			; | | Compatible with PicoSPINet  
561e			 
561e					if DEBUG_FORTH_WORDS_KEY 
561e						DMARK "REA" 
561e f5				push af  
561f 3a 33 56			ld a, (.dmark)  
5622 32 68 fe			ld (debug_mark),a  
5625 3a 34 56			ld a, (.dmark+1)  
5628 32 69 fe			ld (debug_mark+1),a  
562b 3a 35 56			ld a, (.dmark+2)  
562e 32 6a fe			ld (debug_mark+2),a  
5631 18 03			jr .pastdmark  
5633 ..			.dmark: db "REA"  
5636 f1			.pastdmark: pop af  
5637			endm  
# End of macro DMARK
5637						CALLMONITOR 
5637 cd 6c fe			call debug_vector  
563a				endm  
# End of macro CALLMONITOR
563a					endif 
563a					; store_openext use it. If zero it is EOF 
563a			 
563a					; read block from current stream id 
563a					; if the block does not contain zero term keep reading blocks until zero found 
563a					; push the block to stack 
563a					; save the block id to stream 
563a			 
563a			 
563a cd 6c 57				call .testeof 
563d 3e 01				ld a, 1 
563f bd					cp l 
5640 ca 1b 57				jp z, .ateof 
5643			 
5643			 
5643			;		FORTH_DSP_VALUEHL 
5643			 
5643			;		push hl 
5643			 
5643			;	if DEBUG_STORESE 
5643			;		DMARK "REA" 
5643			;		CALLMONITOR 
5643			;	endif 
5643			;		FORTH_DSP_POP 
5643			 
5643			;		pop hl 
5643				 
5643 3a 64 fa				ld a, (store_filecache) 
5646 67					ld h,a 
5647			 
5647 3a 67 fa				ld a, (store_openext) 
564a 6f					ld l, a 
564b					 
564b fe 00				cp 0 
564d ca 1b 57				jp z, .ateof     ; dont read past eof 
5650			 
5650 cd a1 0c				call storage_clear_page 
5653			 
5653 11 77 fa				ld de, store_page 
5656				if DEBUG_STORESE 
5656					DMARK "RE1" 
5656 f5				push af  
5657 3a 6b 56			ld a, (.dmark)  
565a 32 68 fe			ld (debug_mark),a  
565d 3a 6c 56			ld a, (.dmark+1)  
5660 32 69 fe			ld (debug_mark+1),a  
5663 3a 6d 56			ld a, (.dmark+2)  
5666 32 6a fe			ld (debug_mark+2),a  
5669 18 03			jr .pastdmark  
566b ..			.dmark: db "RE1"  
566e f1			.pastdmark: pop af  
566f			endm  
# End of macro DMARK
566f					CALLMONITOR 
566f cd 6c fe			call debug_vector  
5672				endm  
# End of macro CALLMONITOR
5672				endif 
5672 cd be 09				call storage_read 
5675			 
5675				if DEBUG_STORESE 
5675					DMARK "RE2" 
5675 f5				push af  
5676 3a 8a 56			ld a, (.dmark)  
5679 32 68 fe			ld (debug_mark),a  
567c 3a 8b 56			ld a, (.dmark+1)  
567f 32 69 fe			ld (debug_mark+1),a  
5682 3a 8c 56			ld a, (.dmark+2)  
5685 32 6a fe			ld (debug_mark+2),a  
5688 18 03			jr .pastdmark  
568a ..			.dmark: db "RE2"  
568d f1			.pastdmark: pop af  
568e			endm  
# End of macro DMARK
568e					CALLMONITOR 
568e cd 6c fe			call debug_vector  
5691				endm  
# End of macro CALLMONITOR
5691				endif 
5691 cd f8 0f			call ishlzero 
5694			;	ld a, l 
5694			;	add h 
5694			;	cp 0 
5694 ca 1b 57			jp z, .readeof 
5697			 
5697				; not eof so hl should point to data to push to stack 
5697			 
5697				if DEBUG_STORESE 
5697					DMARK "RE3" 
5697 f5				push af  
5698 3a ac 56			ld a, (.dmark)  
569b 32 68 fe			ld (debug_mark),a  
569e 3a ad 56			ld a, (.dmark+1)  
56a1 32 69 fe			ld (debug_mark+1),a  
56a4 3a ae 56			ld a, (.dmark+2)  
56a7 32 6a fe			ld (debug_mark+2),a  
56aa 18 03			jr .pastdmark  
56ac ..			.dmark: db "RE3"  
56af f1			.pastdmark: pop af  
56b0			endm  
# End of macro DMARK
56b0					CALLMONITOR 
56b0 cd 6c fe			call debug_vector  
56b3				endm  
# End of macro CALLMONITOR
56b3				endif 
56b3 cd 69 21			call forth_push_str 
56b6			 
56b6				if DEBUG_STORESE 
56b6					DMARK "RE4" 
56b6 f5				push af  
56b7 3a cb 56			ld a, (.dmark)  
56ba 32 68 fe			ld (debug_mark),a  
56bd 3a cc 56			ld a, (.dmark+1)  
56c0 32 69 fe			ld (debug_mark+1),a  
56c3 3a cd 56			ld a, (.dmark+2)  
56c6 32 6a fe			ld (debug_mark+2),a  
56c9 18 03			jr .pastdmark  
56cb ..			.dmark: db "RE4"  
56ce f1			.pastdmark: pop af  
56cf			endm  
# End of macro DMARK
56cf					CALLMONITOR 
56cf cd 6c fe			call debug_vector  
56d2				endm  
# End of macro CALLMONITOR
56d2				endif 
56d2				; get next block  or mark as eof 
56d2			 
56d2 3a 66 fa			ld a, (store_openmaxext)   ; get our limit 
56d5 4f				ld c, a	 
56d6 3a 67 fa			ld a, (store_openext) 
56d9			 
56d9				if DEBUG_STORESE 
56d9					DMARK "RE5" 
56d9 f5				push af  
56da 3a ee 56			ld a, (.dmark)  
56dd 32 68 fe			ld (debug_mark),a  
56e0 3a ef 56			ld a, (.dmark+1)  
56e3 32 69 fe			ld (debug_mark+1),a  
56e6 3a f0 56			ld a, (.dmark+2)  
56e9 32 6a fe			ld (debug_mark+2),a  
56ec 18 03			jr .pastdmark  
56ee ..			.dmark: db "RE5"  
56f1 f1			.pastdmark: pop af  
56f2			endm  
# End of macro DMARK
56f2					CALLMONITOR 
56f2 cd 6c fe			call debug_vector  
56f5				endm  
# End of macro CALLMONITOR
56f5				endif 
56f5 b9				cp c 
56f6 28 23			jr z, .readeof     ; at last extent 
56f8			 
56f8 3c					inc a 
56f9 32 67 fa				ld (store_openext), a 
56fc			 
56fc				if DEBUG_STORESE 
56fc					DMARK "RE6" 
56fc f5				push af  
56fd 3a 11 57			ld a, (.dmark)  
5700 32 68 fe			ld (debug_mark),a  
5703 3a 12 57			ld a, (.dmark+1)  
5706 32 69 fe			ld (debug_mark+1),a  
5709 3a 13 57			ld a, (.dmark+2)  
570c 32 6a fe			ld (debug_mark+2),a  
570f 18 03			jr .pastdmark  
5711 ..			.dmark: db "RE6"  
5714 f1			.pastdmark: pop af  
5715			endm  
# End of macro DMARK
5715					CALLMONITOR 
5715 cd 6c fe			call debug_vector  
5718				endm  
# End of macro CALLMONITOR
5718				endif 
5718			 
5718			 
5718				       NEXTW 
5718 c3 a8 24			jp macro_next 
571b				endm 
# End of macro NEXTW
571b			.ateof: 
571b				;	ld hl, .showeof 
571b				;	call forth_push_str 
571b 3e 00		.readeof:	ld a, 0 
571d 32 67 fa				ld (store_openext), a 
5720			 
5720					 
5720				if DEBUG_STORESE 
5720					DMARK "REF" 
5720 f5				push af  
5721 3a 35 57			ld a, (.dmark)  
5724 32 68 fe			ld (debug_mark),a  
5727 3a 36 57			ld a, (.dmark+1)  
572a 32 69 fe			ld (debug_mark+1),a  
572d 3a 37 57			ld a, (.dmark+2)  
5730 32 6a fe			ld (debug_mark+2),a  
5733 18 03			jr .pastdmark  
5735 ..			.dmark: db "REF"  
5738 f1			.pastdmark: pop af  
5739			endm  
# End of macro DMARK
5739					CALLMONITOR 
5739 cd 6c fe			call debug_vector  
573c				endm  
# End of macro CALLMONITOR
573c				endif 
573c				       NEXTW 
573c c3 a8 24			jp macro_next 
573f				endm 
# End of macro NEXTW
573f			 
573f			;.showeof:   db "eof", 0 
573f			 
573f			 
573f			.EOF: 
573f				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
573f 6d				db WORD_SYS_CORE+89             
5740 81 57			dw .FORMAT            
5742 04				db 3 + 1 
5743 .. 00			db "EOF",0              
5747				endm 
# End of macro CWHEAD
5747			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5747			; | | e.g. 
5747			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5747			; | | Compatible with PicoSPINet  
5747					; TODO if current block id for stream is zero then push true else false 
5747			 
5747					if DEBUG_FORTH_WORDS_KEY 
5747						DMARK "EOF" 
5747 f5				push af  
5748 3a 5c 57			ld a, (.dmark)  
574b 32 68 fe			ld (debug_mark),a  
574e 3a 5d 57			ld a, (.dmark+1)  
5751 32 69 fe			ld (debug_mark+1),a  
5754 3a 5e 57			ld a, (.dmark+2)  
5757 32 6a fe			ld (debug_mark+2),a  
575a 18 03			jr .pastdmark  
575c ..			.dmark: db "EOF"  
575f f1			.pastdmark: pop af  
5760			endm  
# End of macro DMARK
5760						CALLMONITOR 
5760 cd 6c fe			call debug_vector  
5763				endm  
# End of macro CALLMONITOR
5763					endif 
5763			 
5763					; TODO handlue multiple file streams 
5763			 
5763			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5763 cd 6c 57				call .testeof 
5766 cd fb 20				call forth_push_numhl 
5769			 
5769			 
5769				       NEXTW 
5769 c3 a8 24			jp macro_next 
576c				endm 
# End of macro NEXTW
576c			 
576c			.testeof: 
576c 2e 01				ld l, 1 
576e 3a 66 fa				ld a, (store_openmaxext) 
5771 fe 00				cp 0 
5773 28 09				jr  z, .eofdone   ; empty file 
5775 3a 67 fa				ld a, (store_openext) 
5778 fe 00				cp 0 
577a 28 02				jr  z, .eofdone 
577c 2e 00				ld l, 0 
577e 26 00		.eofdone:	ld h, 0 
5780 c9					ret 
5781			 
5781			 
5781			 
5781			 
5781			.FORMAT: 
5781				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5781 6d				db WORD_SYS_CORE+89             
5782 d2 57			dw .LABEL            
5784 07				db 6 + 1 
5785 .. 00			db "FORMAT",0              
578c				endm 
# End of macro CWHEAD
578c			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
578c			; | | Compatible with PicoSPINet  
578c					; TODO if current block id for stream is zero then push true else false 
578c				 
578c				if DEBUG_STORESE 
578c					DMARK "FOR" 
578c f5				push af  
578d 3a a1 57			ld a, (.dmark)  
5790 32 68 fe			ld (debug_mark),a  
5793 3a a2 57			ld a, (.dmark+1)  
5796 32 69 fe			ld (debug_mark+1),a  
5799 3a a3 57			ld a, (.dmark+2)  
579c 32 6a fe			ld (debug_mark+2),a  
579f 18 03			jr .pastdmark  
57a1 ..			.dmark: db "FOR"  
57a4 f1			.pastdmark: pop af  
57a5			endm  
# End of macro DMARK
57a5					CALLMONITOR 
57a5 cd 6c fe			call debug_vector  
57a8				endm  
# End of macro CALLMONITOR
57a8				endif 
57a8					; Wipes the bank check flags to cause a reformat on next block 0 read 
57a8			 
57a8 21 01 00				ld hl, 1 
57ab 3e 00				ld a, 0 
57ad cd 6a 02				call se_writebyte 
57b0			 
57b0				if DEBUG_STORESE 
57b0					DMARK "FO0" 
57b0 f5				push af  
57b1 3a c5 57			ld a, (.dmark)  
57b4 32 68 fe			ld (debug_mark),a  
57b7 3a c6 57			ld a, (.dmark+1)  
57ba 32 69 fe			ld (debug_mark+1),a  
57bd 3a c7 57			ld a, (.dmark+2)  
57c0 32 6a fe			ld (debug_mark+2),a  
57c3 18 03			jr .pastdmark  
57c5 ..			.dmark: db "FO0"  
57c8 f1			.pastdmark: pop af  
57c9			endm  
# End of macro DMARK
57c9					CALLMONITOR 
57c9 cd 6c fe			call debug_vector  
57cc				endm  
# End of macro CALLMONITOR
57cc				endif 
57cc					; force bank init 
57cc			 
57cc cd 16 05				call storage_get_block_0 
57cf					 
57cf				       NEXTW 
57cf c3 a8 24			jp macro_next 
57d2				endm 
# End of macro NEXTW
57d2			.LABEL: 
57d2				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
57d2 6d				db WORD_SYS_CORE+89             
57d3 20 58			dw .STOREPAGE            
57d5 06				db 5 + 1 
57d6 .. 00			db "LABEL",0              
57dc				endm 
# End of macro CWHEAD
57dc			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
57dc			; | | Compatible with PicoSPINet  
57dc					; TODO test to see if bank is selected 
57dc				 
57dc					if DEBUG_FORTH_WORDS_KEY 
57dc						DMARK "LBL" 
57dc f5				push af  
57dd 3a f1 57			ld a, (.dmark)  
57e0 32 68 fe			ld (debug_mark),a  
57e3 3a f2 57			ld a, (.dmark+1)  
57e6 32 69 fe			ld (debug_mark+1),a  
57e9 3a f3 57			ld a, (.dmark+2)  
57ec 32 6a fe			ld (debug_mark+2),a  
57ef 18 03			jr .pastdmark  
57f1 ..			.dmark: db "LBL"  
57f4 f1			.pastdmark: pop af  
57f5			endm  
# End of macro DMARK
57f5						CALLMONITOR 
57f5 cd 6c fe			call debug_vector  
57f8				endm  
# End of macro CALLMONITOR
57f8					endif 
57f8			;	if DEBUG_STORESE 
57f8			;		DMARK "LBL" 
57f8			;		CALLMONITOR 
57f8			;	endif 
57f8					FORTH_DSP_VALUEHL 
57f8 cd f2 22			call macro_dsp_valuehl 
57fb				endm 
# End of macro FORTH_DSP_VALUEHL
57fb					;v5FORTH_DSP_VALUE 
57fb					 
57fb			;		push hl 
57fb					FORTH_DSP_POP 
57fb cd aa 23			call macro_forth_dsp_pop 
57fe				endm 
# End of macro FORTH_DSP_POP
57fe			;		pop hl 
57fe			 
57fe			;v5		inc hl   ; move past the type marker 
57fe			 
57fe				if DEBUG_STORESE 
57fe					DMARK "LBl" 
57fe f5				push af  
57ff 3a 13 58			ld a, (.dmark)  
5802 32 68 fe			ld (debug_mark),a  
5805 3a 14 58			ld a, (.dmark+1)  
5808 32 69 fe			ld (debug_mark+1),a  
580b 3a 15 58			ld a, (.dmark+2)  
580e 32 6a fe			ld (debug_mark+2),a  
5811 18 03			jr .pastdmark  
5813 ..			.dmark: db "LBl"  
5816 f1			.pastdmark: pop af  
5817			endm  
# End of macro DMARK
5817					CALLMONITOR 
5817 cd 6c fe			call debug_vector  
581a				endm  
# End of macro CALLMONITOR
581a				endif 
581a cd 3a 06				call storage_label 
581d			 
581d				       NEXTW 
581d c3 a8 24			jp macro_next 
5820				endm 
# End of macro NEXTW
5820			.STOREPAGE: 
5820				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5820 6d				db WORD_SYS_CORE+89             
5821 53 58			dw .LABELS            
5823 0a				db 9 + 1 
5824 .. 00			db "STOREPAGE",0              
582e				endm 
# End of macro CWHEAD
582e			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
582e			; | | Compatible with PicoSPINet  
582e					; TODO test to see if bank is selected 
582e				 
582e					if DEBUG_FORTH_WORDS_KEY 
582e						DMARK "STP" 
582e f5				push af  
582f 3a 43 58			ld a, (.dmark)  
5832 32 68 fe			ld (debug_mark),a  
5835 3a 44 58			ld a, (.dmark+1)  
5838 32 69 fe			ld (debug_mark+1),a  
583b 3a 45 58			ld a, (.dmark+2)  
583e 32 6a fe			ld (debug_mark+2),a  
5841 18 03			jr .pastdmark  
5843 ..			.dmark: db "STP"  
5846 f1			.pastdmark: pop af  
5847			endm  
# End of macro DMARK
5847						CALLMONITOR 
5847 cd 6c fe			call debug_vector  
584a				endm  
# End of macro CALLMONITOR
584a					endif 
584a			;	if DEBUG_STORESE 
584a			;		DMARK "STP" 
584a			;		CALLMONITOR 
584a			;	endif 
584a			 
584a 21 77 fa			ld hl, store_page 
584d cd fb 20			call forth_push_numhl 
5850			 
5850			 
5850				       NEXTW 
5850 c3 a8 24			jp macro_next 
5853				endm 
# End of macro NEXTW
5853			.LABELS: 
5853				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5853 6d				db WORD_SYS_CORE+89             
5854 dd 58			dw .SCONST1            
5856 07				db 6 + 1 
5857 .. 00			db "LABELS",0              
585e				endm 
# End of macro CWHEAD
585e			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
585e			; | | *NOT* Compatible with PicoSPINet  
585e					;  
585e			 
585e					; save the current device selected to restore afterwards 
585e				 
585e 3a 5d fa				ld a, (spi_device) 
5861 f5					push af 
5862			 
5862			 
5862					; run through each of the banks 
5862			 
5862 21 01 00				ld hl, 1 
5865 cd fb 20				call forth_push_numhl 
5868 3e ff				ld a, SPI_CE_HIGH 
586a cb 87				res SPI_CE0, a 
586c 32 5d fa				ld (spi_device), a 
586f cd 16 05				call storage_get_block_0 
5872 21 7a fa				ld hl, store_page+3 
5875 cd 69 21				call forth_push_str 
5878			 
5878					 
5878 21 02 00				ld hl, 2 
587b cd fb 20				call forth_push_numhl 
587e 3e ff				ld a, SPI_CE_HIGH 
5880 cb 8f				res SPI_CE1, a 
5882 32 5d fa				ld (spi_device), a 
5885 cd 16 05				call storage_get_block_0 
5888 21 7a fa				ld hl, store_page+3 
588b cd 69 21				call forth_push_str 
588e			 
588e					 
588e 21 03 00				ld hl, 3 
5891 cd fb 20				call forth_push_numhl 
5894 3e ff				ld a, SPI_CE_HIGH 
5896 cb 97				res SPI_CE2, a 
5898 32 5d fa				ld (spi_device), a 
589b cd 16 05				call storage_get_block_0 
589e 21 7a fa				ld hl, store_page+3 
58a1 cd 69 21				call forth_push_str 
58a4			 
58a4			 
58a4 21 04 00				ld hl, 4 
58a7 cd fb 20				call forth_push_numhl 
58aa 3e ff				ld a, SPI_CE_HIGH 
58ac cb 9f				res SPI_CE3, a 
58ae 32 5d fa				ld (spi_device), a 
58b1 cd 16 05				call storage_get_block_0 
58b4 21 7a fa				ld hl, store_page+3 
58b7 cd 69 21				call forth_push_str 
58ba			 
58ba					 
58ba			 
58ba 21 05 00				ld hl, 5 
58bd cd fb 20				call forth_push_numhl 
58c0 3e ff				ld a, SPI_CE_HIGH 
58c2 cb a7				res SPI_CE4, a 
58c4 32 5d fa				ld (spi_device), a 
58c7 cd 16 05				call storage_get_block_0 
58ca 21 7a fa				ld hl, store_page+3 
58cd cd 69 21				call forth_push_str 
58d0			 
58d0					 
58d0					; push fixed count of storage devices (on board) for now 
58d0			 
58d0 21 05 00				ld hl, 5 
58d3 cd fb 20				call forth_push_numhl 
58d6			 
58d6					; restore selected device  
58d6				 
58d6 f1					pop af 
58d7 32 5d fa				ld (spi_device), a 
58da			 
58da				       NEXTW 
58da c3 a8 24			jp macro_next 
58dd				endm 
# End of macro NEXTW
58dd			 
58dd			.SCONST1: 
58dd				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
58dd 6d				db WORD_SYS_CORE+89             
58de f4 58			dw .SCONST2            
58e0 07				db 6 + 1 
58e1 .. 00			db "FILEID",0              
58e8				endm 
# End of macro CWHEAD
58e8			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
58e8			; | | Compatible with PicoSPINet  
58e8 3a 64 fa				ld a, (store_filecache) 
58eb 26 00				ld h, 0 
58ed 6f					ld l, a 
58ee cd fb 20				call forth_push_numhl 
58f1					NEXTW 
58f1 c3 a8 24			jp macro_next 
58f4				endm 
# End of macro NEXTW
58f4			.SCONST2: 
58f4				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
58f4 6d				db WORD_SYS_CORE+89             
58f5 0c 59			dw .SCONST3            
58f7 08				db 7 + 1 
58f8 .. 00			db "FILEEXT",0              
5900				endm 
# End of macro CWHEAD
5900			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5900			; | | Compatible with PicoSPINet  
5900 3a 67 fa				ld a, (store_openext) 
5903 26 00				ld h, 0 
5905 6f					ld l, a 
5906 cd fb 20				call forth_push_numhl 
5909					NEXTW 
5909 c3 a8 24			jp macro_next 
590c				endm 
# End of macro NEXTW
590c			.SCONST3: 
590c				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
590c 6d				db WORD_SYS_CORE+89             
590d 24 59			dw .SCONST4            
590f 08				db 7 + 1 
5910 .. 00			db "FILEMAX",0              
5918				endm 
# End of macro CWHEAD
5918			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5918			; | | Compatible with PicoSPINet  
5918 3a 66 fa				ld a, (store_openmaxext) 
591b 26 00				ld h, 0 
591d 6f					ld l, a 
591e cd fb 20				call forth_push_numhl 
5921					NEXTW 
5921 c3 a8 24			jp macro_next 
5924				endm 
# End of macro NEXTW
5924			.SCONST4: 
5924				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5924 6d				db WORD_SYS_CORE+89             
5925 3a 59			dw .SCONST5            
5927 09				db 8 + 1 
5928 .. 00			db "FILEADDR",0              
5931				endm 
# End of macro CWHEAD
5931			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
5931			; | | Compatible with PicoSPINet  
5931 2a 68 fa				ld hl, (store_openaddr) 
5934 cd fb 20				call forth_push_numhl 
5937					NEXTW 
5937 c3 a8 24			jp macro_next 
593a				endm 
# End of macro NEXTW
593a			.SCONST5: 
593a				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
593a 6d				db WORD_SYS_CORE+89             
593b 5b 59			dw .SCONST6            
593d 09				db 8 + 1 
593e .. 00			db "FILEPAGE",0              
5947				endm 
# End of macro CWHEAD
5947			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
5947			; | | Compatible with PicoSPINet  
5947 2a 68 fa				ld hl, (store_openaddr) 
594a e5					push hl 
594b c1					pop bc 
594c 16 00				ld d, 0 
594e 1e 40				ld e, STORE_BLOCK_PHY 
5950 cd 2c 0f				call Div16 
5953 c5					push bc 
5954 e1					pop hl 
5955 cd fb 20				call forth_push_numhl 
5958					NEXTW 
5958 c3 a8 24			jp macro_next 
595b				endm 
# End of macro NEXTW
595b			.SCONST6: 
595b				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
595b 6d				db WORD_SYS_CORE+89             
595c 74 59			dw .ENDSTORAGE            
595e 09				db 8 + 1 
595f .. 00			db "READCONT",0              
5968				endm 
# End of macro CWHEAD
5968			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5968			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5968			; | | a further read should, if applicable, be CONCAT to the previous read. 
5968			; | | Compatible with PicoSPINet  
5968 3a 6a fa				ld a, (store_readcont) 
596b 26 00				ld h, 0 
596d 6f					ld l, a 
596e cd fb 20				call forth_push_numhl 
5971					NEXTW 
5971 c3 a8 24			jp macro_next 
5974				endm 
# End of macro NEXTW
5974			.ENDSTORAGE: 
5974			; eof 
# End of file forth_words_storage.asm
5974			endif 
5974				include "forth_words_device.asm" 
5974			; Device related words 
5974			 
5974			; | ## Device Words 
5974			 
5974			;if SOUND_ENABLE 
5974			;.NOTE: 
5974			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5974			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
5974			;		if DEBUG_FORTH_WORDS_KEY 
5974			;			DMARK "NTE" 
5974			;			CALLMONITOR 
5974			;		endif 
5974			; 
5974			;	 
5974			; 
5974			;		NEXTW 
5974			;.AFTERSOUND: 
5974			;endif 
5974			 
5974			 
5974			USE_GPIO: equ 0 
5974			 
5974			if USE_GPIO 
5974			.GP1: 
5974				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5974			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
5974					NEXTW 
5974			.GP2: 
5974				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5974			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
5974			 
5974					NEXTW 
5974			 
5974			.GP3: 
5974				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5974			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
5974			 
5974					NEXTW 
5974			 
5974			.GP4: 
5974				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5974			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
5974			 
5974					NEXTW 
5974			.SIN: 
5974			 
5974			 
5974			endif 
5974			 
5974			 
5974				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5974 33				db WORD_SYS_CORE+31             
5975 a9 59			dw .SOUT            
5977 03				db 2 + 1 
5978 .. 00			db "IN",0              
597b				endm 
# End of macro CWHEAD
597b			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
597b					if DEBUG_FORTH_WORDS_KEY 
597b						DMARK "IN." 
597b f5				push af  
597c 3a 90 59			ld a, (.dmark)  
597f 32 68 fe			ld (debug_mark),a  
5982 3a 91 59			ld a, (.dmark+1)  
5985 32 69 fe			ld (debug_mark+1),a  
5988 3a 92 59			ld a, (.dmark+2)  
598b 32 6a fe			ld (debug_mark+2),a  
598e 18 03			jr .pastdmark  
5990 ..			.dmark: db "IN."  
5993 f1			.pastdmark: pop af  
5994			endm  
# End of macro DMARK
5994						CALLMONITOR 
5994 cd 6c fe			call debug_vector  
5997				endm  
# End of macro CALLMONITOR
5997					endif 
5997					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5997 cd f2 22			call macro_dsp_valuehl 
599a				endm 
# End of macro FORTH_DSP_VALUEHL
599a			 
599a e5					push hl 
599b			 
599b					; destroy value TOS 
599b			 
599b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
599b cd aa 23			call macro_forth_dsp_pop 
599e				endm 
# End of macro FORTH_DSP_POP
599e			 
599e					; one value on hl get other one back 
599e			 
599e c1					pop bc 
599f			 
599f					; do the sub 
599f			;		ex de, hl 
599f			 
599f ed 68				in l,(c) 
59a1			 
59a1					; save it 
59a1			 
59a1 26 00				ld h,0 
59a3			 
59a3					; TODO push value back onto stack for another op etc 
59a3			 
59a3 cd fb 20				call forth_push_numhl 
59a6					NEXTW 
59a6 c3 a8 24			jp macro_next 
59a9				endm 
# End of macro NEXTW
59a9			.SOUT: 
59a9				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
59a9 34				db WORD_SYS_CORE+32             
59aa fc 59			dw .SPIO            
59ac 04				db 3 + 1 
59ad .. 00			db "OUT",0              
59b1				endm 
# End of macro CWHEAD
59b1			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
59b1					if DEBUG_FORTH_WORDS_KEY 
59b1						DMARK "OUT" 
59b1 f5				push af  
59b2 3a c6 59			ld a, (.dmark)  
59b5 32 68 fe			ld (debug_mark),a  
59b8 3a c7 59			ld a, (.dmark+1)  
59bb 32 69 fe			ld (debug_mark+1),a  
59be 3a c8 59			ld a, (.dmark+2)  
59c1 32 6a fe			ld (debug_mark+2),a  
59c4 18 03			jr .pastdmark  
59c6 ..			.dmark: db "OUT"  
59c9 f1			.pastdmark: pop af  
59ca			endm  
# End of macro DMARK
59ca						CALLMONITOR 
59ca cd 6c fe			call debug_vector  
59cd				endm  
# End of macro CALLMONITOR
59cd					endif 
59cd			 
59cd					; get port 
59cd			 
59cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59cd cd f2 22			call macro_dsp_valuehl 
59d0				endm 
# End of macro FORTH_DSP_VALUEHL
59d0			 
59d0 e5					push hl 
59d1			 
59d1					; destroy value TOS 
59d1			 
59d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59d1 cd aa 23			call macro_forth_dsp_pop 
59d4				endm 
# End of macro FORTH_DSP_POP
59d4			 
59d4					; get byte to send 
59d4			 
59d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59d4 cd f2 22			call macro_dsp_valuehl 
59d7				endm 
# End of macro FORTH_DSP_VALUEHL
59d7			 
59d7			;		push hl 
59d7			 
59d7					; destroy value TOS 
59d7			 
59d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59d7 cd aa 23			call macro_forth_dsp_pop 
59da				endm 
# End of macro FORTH_DSP_POP
59da			 
59da					; one value on hl get other one back 
59da			 
59da			;		pop hl 
59da			 
59da c1					pop bc 
59db			 
59db					if DEBUG_FORTH_WORDS 
59db						DMARK "OUT" 
59db f5				push af  
59dc 3a f0 59			ld a, (.dmark)  
59df 32 68 fe			ld (debug_mark),a  
59e2 3a f1 59			ld a, (.dmark+1)  
59e5 32 69 fe			ld (debug_mark+1),a  
59e8 3a f2 59			ld a, (.dmark+2)  
59eb 32 6a fe			ld (debug_mark+2),a  
59ee 18 03			jr .pastdmark  
59f0 ..			.dmark: db "OUT"  
59f3 f1			.pastdmark: pop af  
59f4			endm  
# End of macro DMARK
59f4						CALLMONITOR 
59f4 cd 6c fe			call debug_vector  
59f7				endm  
# End of macro CALLMONITOR
59f7					endif 
59f7			 
59f7 ed 69				out (c), l 
59f9			 
59f9					NEXTW 
59f9 c3 a8 24			jp macro_next 
59fc				endm 
# End of macro NEXTW
59fc			 
59fc			 
59fc			.SPIO: 
59fc			 
59fc			if STORAGE_SE 
59fc				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
59fc 51				db WORD_SYS_CORE+61             
59fd 0d 5a			dw .SPICEH            
59ff 07				db 6 + 1 
5a00 .. 00			db "SPICEL",0              
5a07				endm 
# End of macro CWHEAD
5a07			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5a07			 
5a07 cd 13 02				call spi_ce_low 
5a0a			    NEXTW 
5a0a c3 a8 24			jp macro_next 
5a0d				endm 
# End of macro NEXTW
5a0d			 
5a0d			.SPICEH: 
5a0d				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5a0d 51				db WORD_SYS_CORE+61             
5a0e 1e 5a			dw .SPIOb            
5a10 07				db 6 + 1 
5a11 .. 00			db "SPICEH",0              
5a18				endm 
# End of macro CWHEAD
5a18			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5a18			 
5a18 cd 02 02				call spi_ce_high 
5a1b			    NEXTW 
5a1b c3 a8 24			jp macro_next 
5a1e				endm 
# End of macro NEXTW
5a1e			 
5a1e			 
5a1e			.SPIOb: 
5a1e			 
5a1e				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5a1e 51				db WORD_SYS_CORE+61             
5a1f 50 5a			dw .SPII            
5a21 05				db 4 + 1 
5a22 .. 00			db "SPIO",0              
5a27				endm 
# End of macro CWHEAD
5a27			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5a27			 
5a27					if DEBUG_FORTH_WORDS_KEY 
5a27						DMARK "SPo" 
5a27 f5				push af  
5a28 3a 3c 5a			ld a, (.dmark)  
5a2b 32 68 fe			ld (debug_mark),a  
5a2e 3a 3d 5a			ld a, (.dmark+1)  
5a31 32 69 fe			ld (debug_mark+1),a  
5a34 3a 3e 5a			ld a, (.dmark+2)  
5a37 32 6a fe			ld (debug_mark+2),a  
5a3a 18 03			jr .pastdmark  
5a3c ..			.dmark: db "SPo"  
5a3f f1			.pastdmark: pop af  
5a40			endm  
# End of macro DMARK
5a40						CALLMONITOR 
5a40 cd 6c fe			call debug_vector  
5a43				endm  
# End of macro CALLMONITOR
5a43					endif 
5a43					; get port 
5a43			 
5a43			 
5a43					; get byte to send 
5a43			 
5a43					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a43 cd f2 22			call macro_dsp_valuehl 
5a46				endm 
# End of macro FORTH_DSP_VALUEHL
5a46			 
5a46			;		push hl    ; u1  
5a46			 
5a46					; destroy value TOS 
5a46			 
5a46					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a46 cd aa 23			call macro_forth_dsp_pop 
5a49				endm 
# End of macro FORTH_DSP_POP
5a49			 
5a49					; one value on hl get other one back 
5a49			 
5a49			;		pop hl   ; u2 - addr 
5a49			 
5a49					; TODO Send SPI byte 
5a49			 
5a49			;		push hl 
5a49			;		call spi_ce_low 
5a49			;		pop hl 
5a49 7d					ld a, l 
5a4a cd 01 01				call spi_send_byte 
5a4d			;		call spi_ce_high 
5a4d			 
5a4d					NEXTW 
5a4d c3 a8 24			jp macro_next 
5a50				endm 
# End of macro NEXTW
5a50			 
5a50			.SPII: 
5a50				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5a50 52				db WORD_SYS_CORE+62             
5a51 b9 5a			dw .SESEL            
5a53 06				db 5 + 1 
5a54 .. 00			db "SPII",0              
5a59				endm 
# End of macro CWHEAD
5a59			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5a59					if DEBUG_FORTH_WORDS_KEY 
5a59						DMARK "SPi" 
5a59 f5				push af  
5a5a 3a 6e 5a			ld a, (.dmark)  
5a5d 32 68 fe			ld (debug_mark),a  
5a60 3a 6f 5a			ld a, (.dmark+1)  
5a63 32 69 fe			ld (debug_mark+1),a  
5a66 3a 70 5a			ld a, (.dmark+2)  
5a69 32 6a fe			ld (debug_mark+2),a  
5a6c 18 03			jr .pastdmark  
5a6e ..			.dmark: db "SPi"  
5a71 f1			.pastdmark: pop af  
5a72			endm  
# End of macro DMARK
5a72						CALLMONITOR 
5a72 cd 6c fe			call debug_vector  
5a75				endm  
# End of macro CALLMONITOR
5a75					endif 
5a75			 
5a75					; TODO Get SPI byte 
5a75			 
5a75 cd 28 01				call spi_read_byte 
5a78			 
5a78					if DEBUG_FORTH_WORDS 
5a78						DMARK "Si2" 
5a78 f5				push af  
5a79 3a 8d 5a			ld a, (.dmark)  
5a7c 32 68 fe			ld (debug_mark),a  
5a7f 3a 8e 5a			ld a, (.dmark+1)  
5a82 32 69 fe			ld (debug_mark+1),a  
5a85 3a 8f 5a			ld a, (.dmark+2)  
5a88 32 6a fe			ld (debug_mark+2),a  
5a8b 18 03			jr .pastdmark  
5a8d ..			.dmark: db "Si2"  
5a90 f1			.pastdmark: pop af  
5a91			endm  
# End of macro DMARK
5a91						CALLMONITOR 
5a91 cd 6c fe			call debug_vector  
5a94				endm  
# End of macro CALLMONITOR
5a94					endif 
5a94 26 00				ld h, 0 
5a96 6f					ld l, a 
5a97					if DEBUG_FORTH_WORDS 
5a97						DMARK "Si3" 
5a97 f5				push af  
5a98 3a ac 5a			ld a, (.dmark)  
5a9b 32 68 fe			ld (debug_mark),a  
5a9e 3a ad 5a			ld a, (.dmark+1)  
5aa1 32 69 fe			ld (debug_mark+1),a  
5aa4 3a ae 5a			ld a, (.dmark+2)  
5aa7 32 6a fe			ld (debug_mark+2),a  
5aaa 18 03			jr .pastdmark  
5aac ..			.dmark: db "Si3"  
5aaf f1			.pastdmark: pop af  
5ab0			endm  
# End of macro DMARK
5ab0						CALLMONITOR 
5ab0 cd 6c fe			call debug_vector  
5ab3				endm  
# End of macro CALLMONITOR
5ab3					endif 
5ab3 cd fb 20				call forth_push_numhl 
5ab6			 
5ab6					NEXTW 
5ab6 c3 a8 24			jp macro_next 
5ab9				endm 
# End of macro NEXTW
5ab9			 
5ab9			 
5ab9			 
5ab9			.SESEL: 
5ab9				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5ab9 66				db WORD_SYS_CORE+82             
5aba 62 5b			dw .CARTDEV            
5abc 05				db 4 + 1 
5abd .. 00			db "BANK",0              
5ac2				endm 
# End of macro CWHEAD
5ac2			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5ac2					if DEBUG_FORTH_WORDS_KEY 
5ac2						DMARK "BNK" 
5ac2 f5				push af  
5ac3 3a d7 5a			ld a, (.dmark)  
5ac6 32 68 fe			ld (debug_mark),a  
5ac9 3a d8 5a			ld a, (.dmark+1)  
5acc 32 69 fe			ld (debug_mark+1),a  
5acf 3a d9 5a			ld a, (.dmark+2)  
5ad2 32 6a fe			ld (debug_mark+2),a  
5ad5 18 03			jr .pastdmark  
5ad7 ..			.dmark: db "BNK"  
5ada f1			.pastdmark: pop af  
5adb			endm  
# End of macro DMARK
5adb						CALLMONITOR 
5adb cd 6c fe			call debug_vector  
5ade				endm  
# End of macro CALLMONITOR
5ade					endif 
5ade			 
5ade 3e ff				ld a, 255 
5ae0 32 60 fa				ld (spi_cartdev), a 
5ae3			 
5ae3					; get bank 
5ae3			 
5ae3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ae3 cd f2 22			call macro_dsp_valuehl 
5ae6				endm 
# End of macro FORTH_DSP_VALUEHL
5ae6			 
5ae6			;		push hl 
5ae6			 
5ae6					; destroy value TOS 
5ae6			 
5ae6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ae6 cd aa 23			call macro_forth_dsp_pop 
5ae9				endm 
# End of macro FORTH_DSP_POP
5ae9			 
5ae9					; one value on hl get other one back 
5ae9			 
5ae9			;		pop hl 
5ae9			 
5ae9			 
5ae9 0e ff				ld c, SPI_CE_HIGH 
5aeb 06 30				ld b, '0'    ; human readable bank number 
5aed			 
5aed 7d					ld a, l 
5aee			 
5aee					if DEBUG_FORTH_WORDS 
5aee						DMARK "BNK" 
5aee f5				push af  
5aef 3a 03 5b			ld a, (.dmark)  
5af2 32 68 fe			ld (debug_mark),a  
5af5 3a 04 5b			ld a, (.dmark+1)  
5af8 32 69 fe			ld (debug_mark+1),a  
5afb 3a 05 5b			ld a, (.dmark+2)  
5afe 32 6a fe			ld (debug_mark+2),a  
5b01 18 03			jr .pastdmark  
5b03 ..			.dmark: db "BNK"  
5b06 f1			.pastdmark: pop af  
5b07			endm  
# End of macro DMARK
5b07						CALLMONITOR 
5b07 cd 6c fe			call debug_vector  
5b0a				endm  
# End of macro CALLMONITOR
5b0a					endif 
5b0a			 
5b0a					; active low 
5b0a			 
5b0a fe 00				cp 0 
5b0c 28 28				jr z, .bset 
5b0e fe 01				cp 1 
5b10 20 04				jr nz, .b2 
5b12 cb 81				res 0, c 
5b14 06 31				ld b, '1'    ; human readable bank number 
5b16 fe 02		.b2:		cp 2 
5b18 20 04				jr nz, .b3 
5b1a cb 89				res 1, c 
5b1c 06 32				ld b, '2'    ; human readable bank number 
5b1e fe 03		.b3:		cp 3 
5b20 20 04				jr nz, .b4 
5b22 cb 91				res 2, c 
5b24 06 33				ld b, '3'    ; human readable bank number 
5b26 fe 04		.b4:		cp 4 
5b28 20 04				jr nz, .b5 
5b2a cb 99				res 3, c 
5b2c 06 34				ld b, '4'    ; human readable bank number 
5b2e fe 05		.b5:		cp 5 
5b30 20 04				jr nz, .bset 
5b32 cb a1				res 4, c 
5b34 06 35				ld b, '5'    ; human readable bank number 
5b36			 
5b36			.bset: 
5b36 79					ld a, c 
5b37 32 5d fa				ld (spi_device),a 
5b3a 78					ld a, b 
5b3b 32 5c fa				ld (spi_device_id),a 
5b3e					if DEBUG_FORTH_WORDS 
5b3e						DMARK "BN2" 
5b3e f5				push af  
5b3f 3a 53 5b			ld a, (.dmark)  
5b42 32 68 fe			ld (debug_mark),a  
5b45 3a 54 5b			ld a, (.dmark+1)  
5b48 32 69 fe			ld (debug_mark+1),a  
5b4b 3a 55 5b			ld a, (.dmark+2)  
5b4e 32 6a fe			ld (debug_mark+2),a  
5b51 18 03			jr .pastdmark  
5b53 ..			.dmark: db "BN2"  
5b56 f1			.pastdmark: pop af  
5b57			endm  
# End of macro DMARK
5b57						CALLMONITOR 
5b57 cd 6c fe			call debug_vector  
5b5a				endm  
# End of macro CALLMONITOR
5b5a					endif 
5b5a			 
5b5a					; set default SPI clk pulse time as disabled for BANK use 
5b5a			 
5b5a 3e 00				ld a, 0 
5b5c 32 61 fa				ld (spi_clktime), a 
5b5f			 
5b5f					NEXTW 
5b5f c3 a8 24			jp macro_next 
5b62				endm 
# End of macro NEXTW
5b62			 
5b62			.CARTDEV: 
5b62				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5b62 66				db WORD_SYS_CORE+82             
5b63 10 5c			dw .ENDDEVICE            
5b65 08				db 7 + 1 
5b66 .. 00			db "CARTDEV",0              
5b6e				endm 
# End of macro CWHEAD
5b6e			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5b6e					if DEBUG_FORTH_WORDS_KEY 
5b6e						DMARK "CDV" 
5b6e f5				push af  
5b6f 3a 83 5b			ld a, (.dmark)  
5b72 32 68 fe			ld (debug_mark),a  
5b75 3a 84 5b			ld a, (.dmark+1)  
5b78 32 69 fe			ld (debug_mark+1),a  
5b7b 3a 85 5b			ld a, (.dmark+2)  
5b7e 32 6a fe			ld (debug_mark+2),a  
5b81 18 03			jr .pastdmark  
5b83 ..			.dmark: db "CDV"  
5b86 f1			.pastdmark: pop af  
5b87			endm  
# End of macro DMARK
5b87						CALLMONITOR 
5b87 cd 6c fe			call debug_vector  
5b8a				endm  
# End of macro CALLMONITOR
5b8a					endif 
5b8a			 
5b8a					; disable se storage bank selection 
5b8a			 
5b8a 3e ff				ld a, SPI_CE_HIGH		; ce high 
5b8c 32 5d fa				ld (spi_device), a 
5b8f			 
5b8f					; get bank 
5b8f			 
5b8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b8f cd f2 22			call macro_dsp_valuehl 
5b92				endm 
# End of macro FORTH_DSP_VALUEHL
5b92			 
5b92			;		push hl 
5b92			 
5b92					; destroy value TOS 
5b92			 
5b92					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b92 cd aa 23			call macro_forth_dsp_pop 
5b95				endm 
# End of macro FORTH_DSP_POP
5b95			 
5b95					; one value on hl get other one back 
5b95			 
5b95			;		pop hl 
5b95			 
5b95					; active low 
5b95			 
5b95 0e ff				ld c, 255 
5b97			 
5b97 7d					ld a, l 
5b98					if DEBUG_FORTH_WORDS 
5b98						DMARK "CDV" 
5b98 f5				push af  
5b99 3a ad 5b			ld a, (.dmark)  
5b9c 32 68 fe			ld (debug_mark),a  
5b9f 3a ae 5b			ld a, (.dmark+1)  
5ba2 32 69 fe			ld (debug_mark+1),a  
5ba5 3a af 5b			ld a, (.dmark+2)  
5ba8 32 6a fe			ld (debug_mark+2),a  
5bab 18 03			jr .pastdmark  
5bad ..			.dmark: db "CDV"  
5bb0 f1			.pastdmark: pop af  
5bb1			endm  
# End of macro DMARK
5bb1						CALLMONITOR 
5bb1 cd 6c fe			call debug_vector  
5bb4				endm  
# End of macro CALLMONITOR
5bb4					endif 
5bb4 fe 00				cp 0 
5bb6 28 30				jr z, .cset 
5bb8 fe 01				cp 1 
5bba 20 02				jr nz, .c2 
5bbc cb 81				res 0, c 
5bbe fe 02		.c2:		cp 2 
5bc0 20 02				jr nz, .c3 
5bc2 cb 89				res 1, c 
5bc4 fe 03		.c3:		cp 3 
5bc6 20 02				jr nz, .c4 
5bc8 cb 91				res 2, c 
5bca fe 04		.c4:		cp 4 
5bcc 20 02				jr nz, .c5 
5bce cb 99				res 3, c 
5bd0 fe 05		.c5:		cp 5 
5bd2 20 02				jr nz, .c6 
5bd4 cb a1				res 4, c 
5bd6 fe 06		.c6:		cp 6 
5bd8 20 02				jr nz, .c7 
5bda cb a9				res 5, c 
5bdc fe 07		.c7:		cp 7 
5bde 20 02				jr nz, .c8 
5be0 cb b1				res 6, c 
5be2 fe 08		.c8:		cp 8 
5be4 20 02				jr nz, .cset 
5be6 cb b9				res 7, c 
5be8 79			.cset:		ld a, c 
5be9 32 60 fa				ld (spi_cartdev),a 
5bec			 
5bec					if DEBUG_FORTH_WORDS 
5bec						DMARK "CD2" 
5bec f5				push af  
5bed 3a 01 5c			ld a, (.dmark)  
5bf0 32 68 fe			ld (debug_mark),a  
5bf3 3a 02 5c			ld a, (.dmark+1)  
5bf6 32 69 fe			ld (debug_mark+1),a  
5bf9 3a 03 5c			ld a, (.dmark+2)  
5bfc 32 6a fe			ld (debug_mark+2),a  
5bff 18 03			jr .pastdmark  
5c01 ..			.dmark: db "CD2"  
5c04 f1			.pastdmark: pop af  
5c05			endm  
# End of macro DMARK
5c05						CALLMONITOR 
5c05 cd 6c fe			call debug_vector  
5c08				endm  
# End of macro CALLMONITOR
5c08					endif 
5c08			 
5c08					; set default SPI clk pulse time as 10ms for CARTDEV use 
5c08			 
5c08 3e 0a				ld a, $0a 
5c0a 32 61 fa				ld (spi_clktime), a 
5c0d					NEXTW 
5c0d c3 a8 24			jp macro_next 
5c10				endm 
# End of macro NEXTW
5c10			endif 
5c10			 
5c10			.ENDDEVICE: 
5c10			; eof 
5c10			 
# End of file forth_words_device.asm
5c10			 
5c10			; var handler 
5c10			 
5c10			 
5c10			.VARS: 
5c10				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5c10 77				db WORD_SYS_CORE+99             
5c11 c1 5c			dw .V0            
5c13 04				db 3 + 1 
5c14 .. 00			db "VAR",0              
5c18				endm 
# End of macro CWHEAD
5c18			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5c18			;| 
5c18			;| The variable name should consist of a single letter. e.g. "a" 
5c18			;! If a full string is passed then only the first char is looked at 
5c18			;| Any other char could exceed bounds checks!  
5c18			 
5c18					if DEBUG_FORTH_WORDS_KEY 
5c18						DMARK "VAR" 
5c18 f5				push af  
5c19 3a 2d 5c			ld a, (.dmark)  
5c1c 32 68 fe			ld (debug_mark),a  
5c1f 3a 2e 5c			ld a, (.dmark+1)  
5c22 32 69 fe			ld (debug_mark+1),a  
5c25 3a 2f 5c			ld a, (.dmark+2)  
5c28 32 6a fe			ld (debug_mark+2),a  
5c2b 18 03			jr .pastdmark  
5c2d ..			.dmark: db "VAR"  
5c30 f1			.pastdmark: pop af  
5c31			endm  
# End of macro DMARK
5c31						CALLMONITOR 
5c31 cd 6c fe			call debug_vector  
5c34				endm  
# End of macro CALLMONITOR
5c34					endif 
5c34			 
5c34					FORTH_DSP_VALUEHL 
5c34 cd f2 22			call macro_dsp_valuehl 
5c37				endm 
# End of macro FORTH_DSP_VALUEHL
5c37			 
5c37 7e					ld a, (hl)    ; get first char on of the string 
5c38			 
5c38			 
5c38					if DEBUG_FORTH_WORDS 
5c38						DMARK "VR1" 
5c38 f5				push af  
5c39 3a 4d 5c			ld a, (.dmark)  
5c3c 32 68 fe			ld (debug_mark),a  
5c3f 3a 4e 5c			ld a, (.dmark+1)  
5c42 32 69 fe			ld (debug_mark+1),a  
5c45 3a 4f 5c			ld a, (.dmark+2)  
5c48 32 6a fe			ld (debug_mark+2),a  
5c4b 18 03			jr .pastdmark  
5c4d ..			.dmark: db "VR1"  
5c50 f1			.pastdmark: pop af  
5c51			endm  
# End of macro DMARK
5c51						CALLMONITOR 
5c51 cd 6c fe			call debug_vector  
5c54				endm  
# End of macro CALLMONITOR
5c54					endif 
5c54					 
5c54 f5					push af	 
5c55					FORTH_DSP_POP 
5c55 cd aa 23			call macro_forth_dsp_pop 
5c58				endm 
# End of macro FORTH_DSP_POP
5c58 f1					pop af 
5c59			 
5c59					; convert to upper 
5c59			 
5c59 cd 3c 13				call to_upper 
5c5c					if DEBUG_FORTH_WORDS 
5c5c						DMARK "Vaa" 
5c5c f5				push af  
5c5d 3a 71 5c			ld a, (.dmark)  
5c60 32 68 fe			ld (debug_mark),a  
5c63 3a 72 5c			ld a, (.dmark+1)  
5c66 32 69 fe			ld (debug_mark+1),a  
5c69 3a 73 5c			ld a, (.dmark+2)  
5c6c 32 6a fe			ld (debug_mark+2),a  
5c6f 18 03			jr .pastdmark  
5c71 ..			.dmark: db "Vaa"  
5c74 f1			.pastdmark: pop af  
5c75			endm  
# End of macro DMARK
5c75						CALLMONITOR 
5c75 cd 6c fe			call debug_vector  
5c78				endm  
# End of macro CALLMONITOR
5c78					endif 
5c78 06 41				ld b, 'A' 
5c7a 90					sub b			; set offset 
5c7b					if DEBUG_FORTH_WORDS 
5c7b						DMARK "Vbb" 
5c7b f5				push af  
5c7c 3a 90 5c			ld a, (.dmark)  
5c7f 32 68 fe			ld (debug_mark),a  
5c82 3a 91 5c			ld a, (.dmark+1)  
5c85 32 69 fe			ld (debug_mark+1),a  
5c88 3a 92 5c			ld a, (.dmark+2)  
5c8b 32 6a fe			ld (debug_mark+2),a  
5c8e 18 03			jr .pastdmark  
5c90 ..			.dmark: db "Vbb"  
5c93 f1			.pastdmark: pop af  
5c94			endm  
# End of macro DMARK
5c94						CALLMONITOR 
5c94 cd 6c fe			call debug_vector  
5c97				endm  
# End of macro CALLMONITOR
5c97					endif 
5c97 cb 27				sla a  
5c99				 
5c99					 
5c99					if DEBUG_FORTH_WORDS 
5c99						DMARK "VR2" 
5c99 f5				push af  
5c9a 3a ae 5c			ld a, (.dmark)  
5c9d 32 68 fe			ld (debug_mark),a  
5ca0 3a af 5c			ld a, (.dmark+1)  
5ca3 32 69 fe			ld (debug_mark+1),a  
5ca6 3a b0 5c			ld a, (.dmark+2)  
5ca9 32 6a fe			ld (debug_mark+2),a  
5cac 18 03			jr .pastdmark  
5cae ..			.dmark: db "VR2"  
5cb1 f1			.pastdmark: pop af  
5cb2			endm  
# End of macro DMARK
5cb2						CALLMONITOR 
5cb2 cd 6c fe			call debug_vector  
5cb5				endm  
# End of macro CALLMONITOR
5cb5					endif 
5cb5			 
5cb5 21 f1 f9				ld hl, cli_var_array2 
5cb8 cd cf 0f				call addatohl 
5cbb cd fb 20				call forth_push_numhl 
5cbe			 
5cbe			 
5cbe				       NEXTW 
5cbe c3 a8 24			jp macro_next 
5cc1				endm 
# End of macro NEXTW
5cc1			.V0: 
5cc1				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5cc1 78				db WORD_SYS_CORE+100             
5cc2 d9 5c			dw .V0Q            
5cc4 04				db 3 + 1 
5cc5 .. 00			db "V0!",0              
5cc9				endm 
# End of macro CWHEAD
5cc9			;| V0! ( u1 -- )  Store value to v0  | DONE 
5cc9			 
5cc9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cc9 cd f2 22			call macro_dsp_valuehl 
5ccc				endm 
# End of macro FORTH_DSP_VALUEHL
5ccc			 
5ccc 11 25 fa				ld de, cli_var_array 
5ccf			 
5ccf eb					ex de, hl 
5cd0 73					ld (hl), e 
5cd1 23					inc hl 
5cd2 72					ld (hl), d 
5cd3			 
5cd3					; destroy value TOS 
5cd3			 
5cd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cd3 cd aa 23			call macro_forth_dsp_pop 
5cd6				endm 
# End of macro FORTH_DSP_POP
5cd6			 
5cd6				       NEXTW 
5cd6 c3 a8 24			jp macro_next 
5cd9				endm 
# End of macro NEXTW
5cd9			.V0Q: 
5cd9				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5cd9 79				db WORD_SYS_CORE+101             
5cda ea 5c			dw .V1S            
5cdc 04				db 3 + 1 
5cdd .. 00			db "V0@",0              
5ce1				endm 
# End of macro CWHEAD
5ce1			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5ce1 2a 25 fa				ld hl, (cli_var_array) 
5ce4 cd fb 20				call forth_push_numhl 
5ce7			 
5ce7				       NEXTW 
5ce7 c3 a8 24			jp macro_next 
5cea				endm 
# End of macro NEXTW
5cea			.V1S: 
5cea				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5cea 7a				db WORD_SYS_CORE+102             
5ceb 02 5d			dw .V1Q            
5ced 04				db 3 + 1 
5cee .. 00			db "V1!",0              
5cf2				endm 
# End of macro CWHEAD
5cf2			;| V1! ( u1 -- )  Store value to v1 | DONE 
5cf2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cf2 cd f2 22			call macro_dsp_valuehl 
5cf5				endm 
# End of macro FORTH_DSP_VALUEHL
5cf5			 
5cf5 11 27 fa				ld de, cli_var_array+2 
5cf8				 
5cf8 eb					ex de, hl 
5cf9 73					ld (hl), e 
5cfa 23					inc hl 
5cfb 72					ld (hl), d 
5cfc			 
5cfc					; destroy value TOS 
5cfc			 
5cfc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cfc cd aa 23			call macro_forth_dsp_pop 
5cff				endm 
# End of macro FORTH_DSP_POP
5cff				       NEXTW 
5cff c3 a8 24			jp macro_next 
5d02				endm 
# End of macro NEXTW
5d02			.V1Q: 
5d02				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5d02 7b				db WORD_SYS_CORE+103             
5d03 13 5d			dw .V2S            
5d05 04				db 3 + 1 
5d06 .. 00			db "V1@",0              
5d0a				endm 
# End of macro CWHEAD
5d0a			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5d0a 2a 27 fa				ld hl, (cli_var_array+2) 
5d0d cd fb 20				call forth_push_numhl 
5d10				       NEXTW 
5d10 c3 a8 24			jp macro_next 
5d13				endm 
# End of macro NEXTW
5d13			.V2S: 
5d13				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5d13 7c				db WORD_SYS_CORE+104             
5d14 2b 5d			dw .V2Q            
5d16 04				db 3 + 1 
5d17 .. 00			db "V2!",0              
5d1b				endm 
# End of macro CWHEAD
5d1b			;| V2! ( u1 -- )  Store value to v2 | DONE 
5d1b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d1b cd f2 22			call macro_dsp_valuehl 
5d1e				endm 
# End of macro FORTH_DSP_VALUEHL
5d1e			 
5d1e 11 29 fa				ld de, cli_var_array+4 
5d21				 
5d21 eb					ex de, hl 
5d22 73					ld (hl), e 
5d23 23					inc hl 
5d24 72					ld (hl), d 
5d25			 
5d25					; destroy value TOS 
5d25			 
5d25					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d25 cd aa 23			call macro_forth_dsp_pop 
5d28				endm 
# End of macro FORTH_DSP_POP
5d28				       NEXTW 
5d28 c3 a8 24			jp macro_next 
5d2b				endm 
# End of macro NEXTW
5d2b			.V2Q: 
5d2b				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5d2b 7d				db WORD_SYS_CORE+105             
5d2c 3c 5d			dw .V3S            
5d2e 04				db 3 + 1 
5d2f .. 00			db "V2@",0              
5d33				endm 
# End of macro CWHEAD
5d33			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5d33 2a 29 fa				ld hl, (cli_var_array+4) 
5d36 cd fb 20				call forth_push_numhl 
5d39				       NEXTW 
5d39 c3 a8 24			jp macro_next 
5d3c				endm 
# End of macro NEXTW
5d3c			.V3S: 
5d3c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5d3c 7c				db WORD_SYS_CORE+104             
5d3d 54 5d			dw .V3Q            
5d3f 04				db 3 + 1 
5d40 .. 00			db "V3!",0              
5d44				endm 
# End of macro CWHEAD
5d44			;| V3! ( u1 -- )  Store value to v3 | DONE 
5d44					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d44 cd f2 22			call macro_dsp_valuehl 
5d47				endm 
# End of macro FORTH_DSP_VALUEHL
5d47			 
5d47 11 2b fa				ld de, cli_var_array+6 
5d4a				 
5d4a eb					ex de, hl 
5d4b 73					ld (hl), e 
5d4c 23					inc hl 
5d4d 72					ld (hl), d 
5d4e			 
5d4e					; destroy value TOS 
5d4e			 
5d4e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d4e cd aa 23			call macro_forth_dsp_pop 
5d51				endm 
# End of macro FORTH_DSP_POP
5d51				       NEXTW 
5d51 c3 a8 24			jp macro_next 
5d54				endm 
# End of macro NEXTW
5d54			.V3Q: 
5d54				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5d54 7d				db WORD_SYS_CORE+105             
5d55 65 5d			dw .END            
5d57 04				db 3 + 1 
5d58 .. 00			db "V3@",0              
5d5c				endm 
# End of macro CWHEAD
5d5c			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5d5c 2a 2b fa				ld hl, (cli_var_array+6) 
5d5f cd fb 20				call forth_push_numhl 
5d62				       NEXTW 
5d62 c3 a8 24			jp macro_next 
5d65				endm 
# End of macro NEXTW
5d65			 
5d65			 
5d65			 
5d65			 
5d65			 
5d65			; end of dict marker 
5d65			 
5d65 00			.END:    db WORD_SYS_END 
5d66 00 00			dw 0 
5d68 00				db 0 
5d69			 
5d69			; use to jp here for user dict words to save on macro expansion  
5d69			 
5d69			user_dict_next: 
5d69				NEXTW 
5d69 c3 a8 24			jp macro_next 
5d6c				endm 
# End of macro NEXTW
5d6c			 
5d6c			 
5d6c			user_exec: 
5d6c				;    ld hl, <word code> 
5d6c				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5d6c				;    call forthexec 
5d6c				;    jp user_dict_next   (NEXT) 
5d6c			        ;    <word code bytes> 
5d6c eb				ex de, hl 
5d6d 2a bf f4			ld hl,(os_tok_ptr) 
5d70				 
5d70				FORTH_RSP_NEXT 
5d70 cd a2 20			call macro_forth_rsp_next 
5d73				endm 
# End of macro FORTH_RSP_NEXT
5d73			 
5d73			if DEBUG_FORTH_UWORD 
5d73						DMARK "UEX" 
5d73 f5				push af  
5d74 3a 88 5d			ld a, (.dmark)  
5d77 32 68 fe			ld (debug_mark),a  
5d7a 3a 89 5d			ld a, (.dmark+1)  
5d7d 32 69 fe			ld (debug_mark+1),a  
5d80 3a 8a 5d			ld a, (.dmark+2)  
5d83 32 6a fe			ld (debug_mark+2),a  
5d86 18 03			jr .pastdmark  
5d88 ..			.dmark: db "UEX"  
5d8b f1			.pastdmark: pop af  
5d8c			endm  
# End of macro DMARK
5d8c				CALLMONITOR 
5d8c cd 6c fe			call debug_vector  
5d8f				endm  
# End of macro CALLMONITOR
5d8f			endif 
5d8f			 
5d8f			 
5d8f			 
5d8f eb				ex de, hl 
5d90 22 bf f4			ld (os_tok_ptr), hl 
5d93				 
5d93				; Don't use next - Skips the first word in uword. 
5d93			 
5d93 c3 39 25			jp exec1 
5d96			;	NEXT 
5d96			 
5d96			 
5d96			; eof 
# End of file forth_wordsv4.asm
5d96			endif 
5d96			;;;;;;;;;;;;;; Debug code 
5d96			 
5d96			 
5d96			;if DEBUG_FORTH_PARSE 
5d96 .. 00		.nowordfound: db "No match",0 
5d9f .. 00		.compword:	db "Comparing word ",0 
5daf .. 00		.nextwordat:	db "Next word at",0 
5dbc .. 00		.charmatch:	db "Char match",0 
5dc7			;endif 
5dc7			if DEBUG_FORTH_JP 
5dc7			.foundword:	db "Word match. Exec..",0 
5dc7			endif 
5dc7			;if DEBUG_FORTH_PUSH 
5dc7 .. 00		.enddict:	db "Dict end. Push.",0 
5dd7 .. 00		.push_str:	db "Pushing string",0 
5de6 .. 00		.push_num:	db "Pushing number",0 
5df5 .. 00		.data_sp:	db "SP:",0 
5df9 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5e0b .. 00		.wordinde:	db "Word in DE (3/0):",0 
5e1d .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5e2f			;endif 
5e2f			;if DEBUG_FORTH_MALLOC 
5e2f .. 00		.push_malloc:	db "Malloc address",0 
5e3e			;endif 
5e3e			 
5e3e			 
5e3e			 
5e3e			; display malloc address and current data stack pointer  
5e3e			 
5e3e			malloc_error: 
5e3e d5				push de 
5e3f f5				push af 
5e40 e5				push hl 
5e41 cd 9b 0d			call clear_display 
5e44 11 64 5e			ld de, .mallocerr 
5e47 3e 00			ld a,0 
5e49			;	ld de,os_word_scratch 
5e49 cd ae 0d			call str_at_display 
5e4c 3e 11			ld a, display_row_1+17 
5e4e 11 68 fe			ld de, debug_mark 
5e51 cd ae 0d			call str_at_display 
5e54 cd be 0d			call update_display 
5e57				;call break_point_state 
5e57 cd 27 7a			call cin_wait 
5e5a			 
5e5a			;	ld a, ' ' 
5e5a			;	ld (os_view_disable), a 
5e5a cd 2d 1a			call bp_on 
5e5d e1				pop hl 
5e5e f1				pop af 
5e5f d1				pop de	 
5e60				CALLMONITOR 
5e60 cd 6c fe			call debug_vector  
5e63				endm  
# End of macro CALLMONITOR
5e63 c9				ret 
5e64			 
5e64 .. 00		.mallocerr: 	db "Malloc Error",0 
5e71			;if DEBUG_FORTH_PUSH 
5e71			display_data_sp: 
5e71 f5				push af 
5e72			 
5e72				; see if disabled 
5e72			 
5e72			 
5e72 3a 6c fe			ld a, (debug_vector) 
5e75 fe c9			cp $C9  ; RET 
5e77				;ld a, (os_view_disable) 
5e77				;cp '*' 
5e77 28 67			jr z, .skipdsp 
5e79			 
5e79 e5				push hl 
5e7a e5				push hl 
5e7b e5			push hl 
5e7c cd 9b 0d			call clear_display 
5e7f e1			pop hl 
5e80 7c				ld a,h 
5e81 21 c3 f4			ld hl, os_word_scratch 
5e84 cd d0 12			call hexout 
5e87 e1				pop hl 
5e88 7d				ld a,l 
5e89 21 c5 f4			ld hl, os_word_scratch+2 
5e8c cd d0 12			call hexout 
5e8f 21 c7 f4			ld hl, os_word_scratch+4 
5e92 3e 00			ld a,0 
5e94 77				ld (hl),a 
5e95 11 c3 f4			ld de,os_word_scratch 
5e98 3e 28				ld a, display_row_2 
5e9a cd ae 0d				call str_at_display 
5e9d 11 f9 5d			ld de, .wordinhl 
5ea0 3e 00			ld a, display_row_1 
5ea2			 
5ea2 cd ae 0d				call str_at_display 
5ea5 11 68 fe			ld de, debug_mark 
5ea8 3e 11			ld a, display_row_1+17 
5eaa			 
5eaa cd ae 0d				call str_at_display 
5ead			 
5ead				; display current data stack pointer 
5ead 11 f5 5d			ld de,.data_sp 
5eb0 3e 30				ld a, display_row_2 + 8 
5eb2 cd ae 0d				call str_at_display 
5eb5			 
5eb5 2a eb f9			ld hl,(cli_data_sp) 
5eb8 e5				push hl 
5eb9 7c				ld a,h 
5eba 21 c3 f4			ld hl, os_word_scratch 
5ebd cd d0 12			call hexout 
5ec0 e1				pop hl 
5ec1 7d				ld a,l 
5ec2 21 c5 f4			ld hl, os_word_scratch+2 
5ec5 cd d0 12			call hexout 
5ec8 21 c7 f4			ld hl, os_word_scratch+4 
5ecb 3e 00			ld a,0 
5ecd 77				ld (hl),a 
5ece 11 c3 f4			ld de,os_word_scratch 
5ed1 3e 33				ld a, display_row_2 + 11 
5ed3 cd ae 0d				call str_at_display 
5ed6			 
5ed6			 
5ed6 cd be 0d			call update_display 
5ed9 cd de 0c			call delay1s 
5edc cd de 0c			call delay1s 
5edf e1				pop hl 
5ee0			.skipdsp: 
5ee0 f1				pop af 
5ee1 c9				ret 
5ee2			 
5ee2			display_data_malloc: 
5ee2			 
5ee2 f5				push af 
5ee3 e5				push hl 
5ee4 e5				push hl 
5ee5 e5			push hl 
5ee6 cd 9b 0d			call clear_display 
5ee9 e1			pop hl 
5eea 7c				ld a,h 
5eeb 21 c3 f4			ld hl, os_word_scratch 
5eee cd d0 12			call hexout 
5ef1 e1				pop hl 
5ef2 7d				ld a,l 
5ef3 21 c5 f4			ld hl, os_word_scratch+2 
5ef6 cd d0 12			call hexout 
5ef9 21 c7 f4			ld hl, os_word_scratch+4 
5efc 3e 00			ld a,0 
5efe 77				ld (hl),a 
5eff 11 c3 f4			ld de,os_word_scratch 
5f02 3e 28				ld a, display_row_2 
5f04 cd ae 0d				call str_at_display 
5f07 11 2f 5e			ld de, .push_malloc 
5f0a 3e 00			ld a, display_row_1 
5f0c			 
5f0c cd ae 0d				call str_at_display 
5f0f			 
5f0f				; display current data stack pointer 
5f0f 11 f5 5d			ld de,.data_sp 
5f12 3e 30				ld a, display_row_2 + 8 
5f14 cd ae 0d				call str_at_display 
5f17			 
5f17 2a eb f9			ld hl,(cli_data_sp) 
5f1a e5				push hl 
5f1b 7c				ld a,h 
5f1c 21 c3 f4			ld hl, os_word_scratch 
5f1f cd d0 12			call hexout 
5f22 e1				pop hl 
5f23 7d				ld a,l 
5f24 21 c5 f4			ld hl, os_word_scratch+2 
5f27 cd d0 12			call hexout 
5f2a 21 c7 f4			ld hl, os_word_scratch+4 
5f2d 3e 00			ld a,0 
5f2f 77				ld (hl),a 
5f30 11 c3 f4			ld de,os_word_scratch 
5f33 3e 33				ld a, display_row_2 + 11 
5f35 cd ae 0d				call str_at_display 
5f38			 
5f38 cd be 0d			call update_display 
5f3b cd de 0c			call delay1s 
5f3e cd de 0c			call delay1s 
5f41 e1				pop hl 
5f42 f1				pop af 
5f43 c9				ret 
5f44			;endif 
5f44			 
5f44			include "forth_autostart.asm" 
5f44			; list of commands to perform at system start up 
5f44			 
5f44			startcmds: 
5f44			;	dw test11 
5f44			;	dw test12 
5f44			;	dw test13 
5f44			;	dw test14 
5f44			;	dw test15 
5f44			;	dw test16 
5f44			;	dw test17 
5f44			;	dw ifthtest1 
5f44			;	dw ifthtest2 
5f44			;	dw ifthtest3 
5f44			;	dw mmtest1 
5f44			;	dw mmtest2 
5f44			;	dw mmtest3 
5f44			;	dw mmtest4 
5f44			;	dw mmtest5 
5f44			;	dw mmtest6 
5f44			;	dw iftest1 
5f44			;	dw iftest2 
5f44			;	dw iftest3 
5f44			;	dw looptest1 
5f44			;	dw looptest2 
5f44			;	dw test1 
5f44			;	dw test2 
5f44			;	dw test3 
5f44			;	dw test4 
5f44			;	dw game2r 
5f44			;	dw game2b1 
5f44			;	dw game2b2 
5f44			 
5f44				; start up words that are actually useful 
5f44			 
5f44			;    dw spi1 
5f44			;    dw spi2 
5f44			;    dw spi3 
5f44			;    dw spi4 
5f44			;    dw spi5 
5f44			;    dw spi6 
5f44			;    dw spi7 
5f44			; 
5f44			;    dw spi8 
5f44			;    dw spi9 
5f44			;    dw spi10 
5f44			 
5f44			; file editor 
5f44			;	dw edit1 
5f44			;	dw edit2 
5f44			;	dw edit3 
5f44			 
5f44			;	dw longread 
5f44 6e 63			dw clrstack 
5f46 a2 63			dw type 
5f48			;	dw stest 
5f48 c7 63			dw strncpy 
5f4a			;	dw list 
5f4a 28 64			dw start1 
5f4c 38 64			dw start2 
5f4e			;	dw start3 
5f4e			;	dw start3b 
5f4e			;	dw start3c 
5f4e			 
5f4e				; (unit) testing words 
5f4e			 
5f4e			;	dw mtesta 
5f4e			;	dw mtestb 
5f4e			;	dw mtestc 
5f4e			;	dw mtestd 
5f4e			;	dw mteste 
5f4e			 
5f4e				; demo/game words 
5f4e			 
5f4e			;        dw game3w 
5f4e			;        dw game3p 
5f4e			;        dw game3sc 
5f4e			;        dw game3vsi 
5f4e			;        dw game3vs 
5f4e				 
5f4e 91 6e			dw game2b 
5f50 ff 6e			dw game2bf 
5f52 49 6f			dw game2mba 
5f54 df 6f			dw game2mbas 
5f56 21 70			dw game2mb 
5f58			 
5f58 52 6b			dw game1 
5f5a 63 6b			dw game1a 
5f5c c5 6b			dw game1b 
5f5e fa 6b			dw game1c 
5f60 30 6c			dw game1d 
5f62 61 6c			dw game1s 
5f64 75 6c			dw game1t 
5f66 8a 6c			dw game1f 
5f68 be 6c			dw game1z 
5f6a 02 6d			dw game1zz 
5f6c			 
5f6c 6c 69			dw test5 
5f6e a4 69			dw test6 
5f70 dc 69			dw test7 
5f72 f0 69			dw test8 
5f74 1c 6a			dw test9 
5f76 32 6a			dw test10 
5f78				 
5f78 d9 6d		        dw ssv5 
5f7a bd 6d		        dw ssv4 
5f7c a1 6d		        dw ssv3 
5f7e 6b 6d		        dw ssv2 
5f80 f2 6d		        dw ssv1 
5f82 3a 6e		        dw ssv1cpm 
5f84			;	dw keyup 
5f84			;	dw keydown 
5f84			;	dw keyleft 
5f84			;	dw keyright 
5f84			;	dw 	keyf1 
5f84			;	dw keyf2 
5f84			;	dw keyf3 
5f84			;	dw keyf4 
5f84			;	dw keyf5 
5f84			;	dw keyf6 
5f84			;	dw keyf7 
5f84			;	dw keyf8 
5f84			;	dw keyf9 
5f84			;	dw keyf10 
5f84			;	dw keyf11 
5f84			;	dw keyf12 
5f84			;	dw keytab 
5f84			;	dw keycr 
5f84			;	dw keyhome 
5f84			;	dw keyend 
5f84			;	dw keybs 
5f84 00 00			db 0, 0	 
5f86			 
5f86			 
5f86			; File Editor 
5f86			 
5f86			; ( id - ) use 'e' to edit the displayed line 
5f86 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5fa7 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5fdc			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5fdc .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
6014			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
6014			 
6014			; SPI Net support words 
6014			 
6014			; v0! = node to send to 
6014			; ( str count - ) 
6014 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
606d			 
606d			; spiputc ( char node - ) 
606d .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
60a1			; spiputc ( u node - ) 
60a1 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
60cf			 
60cf			; spigetc ( - n ) 
60cf .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
60f8			 
60f8			; getnode ( - n ) 
60f8 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
6125			 
6125			; ( str node - )  
6125 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
618b			; store string ( str i - ) 
618b			 
618b			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
618b .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
61e0			 
61e0			; get string ( addr i -  )    TO FIX 
61e0			 
61e0 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6238			 
6238			 
6238			; NETCHAT (TODO) 
6238			; Program to allow two nodes to chat with eachother 
6238			; 
6238			; v0 - target node 
6238			;  
6238			; accept input at 0,0 
6238			; if input is string send spitype to target node 
6238			; starting at row 2,0 , while spigetchr is not zero ->  
6238			; 
6238			; 
6238			; TODO add paging of get request 
6238			 
6238			; ( node - ) 
6238 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
6257 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
62af .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6327			 
6327			 
6327			; Long read of currently open file 
6327 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
636e			 
636e			; clear stack  
636e			 
636e .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
63a2			 
63a2			; type ( addr count - ) 
63a2 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
63c7			 
63c7			; some direct memory words 
63c7			; strncpy ( len t f -- t ) 
63c7			 
63c7 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6428			 
6428 .. 00		start1:     	db ": bpon $00 bp ;",0 
6438 .. 00		start2:     	db ": bpoff $01 bp ;",0 
6449 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
64c4 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6524			 
6524			 
6524			; a handy word to list items on the stack 
6524			 
6524 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
658e			 
658e			 
658e			; test stack  
658e			; rnd8 stest 
658e			 
658e .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
6605			 
6605			; random malloc and free cycles 
6605			 
6605 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66ba			 
66ba			; fixed malloc and free cycles 
66ba			 
66ba .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
675d			 
675d			; fixed double string push and drop cycle  
675d			 
675d .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6812			 
6812			; consistent fixed string push and drop cycle  
6812			 
6812 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
68b6			 
68b6 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
696c			 
696c			;test1:		db ": aa 1 2 3 ;", 0 
696c			;test2:     	db "111 aa 888 999",0 
696c			;test3:     	db ": bb 77 ;",0 
696c			;test4:     	db "$02 $01 do i . loop bb",0 
696c			 
696c .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
69a4 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
69dc .. 00		test7:     	db ": box hline vline ;",0 
69f0 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6a1c .. 00		test9:     	db ": sw $01 adsp world ;",0 
6a32 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6a57 .. 00		test11:     	db "hello create .",0 
6a66 .. 00		test12:     	db "hello2 create .",0 
6a76			 
6a76			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6a76			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6a76			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6a76			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6a76			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6a76			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6a76			 
6a76			;iftest1:     	db "$0001 IF cls .",0 
6a76			;iftest2:     	db "$0000 IF cls .",0 
6a76			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6a76			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6a76			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6a76			 
6a76			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a76			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a76			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a76			 
6a76			 
6a76 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6a9a .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6aca .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6aef .. 00		sound4: db ": cha $00 ; ",0 
6afc .. 00		sound5: db ": chb $20 ; ",0 
6b09 .. 00		sound6: db ": chc $40 ; ",0 
6b16 .. 00		sound7: db ": chd $60 ; ",0 
6b23 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6b3b .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6b52			 
6b52			 
6b52			 
6b52			 
6b52			; a small guess the number game 
6b52			 
6b52 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6b63 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6bc5			 
6bc5 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6bfa .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6c30 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6c61 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6c75 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6c8a .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6cbe .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6d02			 
6d02			; Using 'ga' save a high score across multiple runs using external storage 
6d02			 
6d02 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6d6b			 
6d6b			 
6d6b			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6d6b			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d6b			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d6b			 
6d6b			; simple screen saver to test code memory reuse to destruction 
6d6b			 
6d6b .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6da1 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6dbd .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6dd9 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6df2 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6e3a .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6e91			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6e91			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6e91			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6e91			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6e91			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6e91			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6e91			 
6e91			 
6e91			 
6e91			; minesweeper/battleship finding game 
6e91			; draws a game board of random ship/mine positions 
6e91			; user enters coords to see if it hits on 
6e91			; game ends when all are hit 
6e91			; when hit or miss says how many may be in the area 
6e91			 
6e91			; setup the game board and then hide it 
6e91 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6eff .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6f49			; prompt for where to target 
6f49 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6fdf .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
7004			; TODO see if the entered coords hits or misses pushes char hit of miss 
7004 .. 00		game2mbht:      db ": mbckht nop ;",0 
7013 .. 00		game2mbms:      db ": mbcms nop ;",0 
7021			; TODO how many might be near by 
7021 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
709e			 
709e			; Game 3 
709e			 
709e			; Vert scroller ski game - avoid the trees! 
709e			 
709e			; v0 score (ie turns) 
709e			; v1 player pos 
709e			; v2 left wall 
709e			; v3 right wall 
709e			 
709e			; Draw side walls randomly 
709e			 
709e .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
70cc			 
70cc			; Draw player 
70cc .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
70ea			 
70ea			; TODO Get Key 
70ea			 
70ea			; TODO Move left right 
70ea			 
70ea			; scroll and move walls a bit 
70ea			 
70ea .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
711b			 
711b			; main game loop 
711b			 
711b .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
7147 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
7186			 
7186			; key board defs 
7186			 
7186 .. 00		keyup:       db ": keyup $05 ;",0 
7194 .. 00		keydown:       db ": keydown $0a ;",0 
71a4 .. 00		keyleft:       db ": keyleft $0b ;",0 
71b4 .. 00		keyright:       db ": keyright $0c ;",0 
71c5 .. 00		keyf1:       db ": keyf1 $10 ;",0 
71d3 .. 00		keyf2:       db ": keyf2 $11 ;",0 
71e1 .. 00		keyf3:       db ": keyf3 $12 ;",0 
71ef .. 00		keyf4:       db ": keyf4 $13 ;",0 
71fd .. 00		keyf5:       db ": keyf5 $14 ;",0 
720b .. 00		keyf6:       db ": keyf6 $15 ;",0 
7219 .. 00		keyf7:       db ": keyf7 $16 ;",0 
7227 .. 00		keyf8:       db ": keyf8 $17 ;",0 
7235 .. 00		keyf9:       db ": keyf9 $18 ;",0 
7243 .. 00		keyf10:       db ": keyf10 $19 ;",0 
7252 .. 00		keyf11:       db ": keyf11 $1a ;",0 
7261 .. 00		keyf12:       db ": keyf12 $1b ;",0 
7270			 
7270 .. 00		keytab:       db ": keytab $09 ;",0 
727f .. 00		keycr:       db ": keycr $0d ;",0 
728d .. 00		keyhome:       db ": keyhome $0e ;",0 
729d .. 00		keyend:       db ": keyend $0f ;",0 
72ac .. 00		keybs:       db ": keybs $08 ;",0 
72ba			 
72ba			   
72ba			 
72ba			 
72ba			 
72ba			; eof 
# End of file forth_autostart.asm
72ba			 
72ba			 
72ba			 
72ba			; stack over and underflow checks 
72ba			 
72ba			; init the words to detect the under/overflow 
72ba			 
72ba			chk_stk_init: 
72ba				; a vague random number to check so we dont get any "lucky" hits 
72ba 3e 2d			ld a, 45 
72bc 6f				ld l, a 
72bd 00				nop 
72be 3e 17			ld a, 23 
72c0 67				ld h, a 
72c1			 
72c1 22 9a f1			ld (chk_word), hl     ; the word we need to check against 
72c4			 
72c4			;	ld (chk_stund), hl	; stack points.... 
72c4 22 fd fe			ld (chk_stovr), hl 
72c7 22 e9 f9			ld (chk_ret_und), hl 
72ca 22 a7 f9			ld (chk_ret_ovr), hl 
72cd 22 25 f9			ld (chk_loop_ovr), hl 
72d0 22 23 f7			ld (chk_data_ovr), hl 
72d3 c9				ret 
72d4				 
72d4			check_stacks: 
72d4				; check all stack words 
72d4			 
72d4 e5				push hl 
72d5 d5				push de 
72d6			 
72d6			;	ld de,(chk_word) 
72d6			;	ld hl, (chk_stund)	; stack points.... 
72d6			;	if DEBUG_STK_FAULT 
72d6			;		DMARK "FAa" 
72d6			;		CALLMONITOR 
72d6			;	endif 
72d6			;	call cmp16 
72d6			;	jp z, .chk_faulta 
72d6			; 
72d6			;	ld de, sfaultsu 
72d6			;	jp .chk_fault 
72d6			 
72d6 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
72d9 ed 5b 9a f1		ld de,(chk_word) 
72dd				if DEBUG_STK_FAULT 
72dd					DMARK "FAb" 
72dd					CALLMONITOR 
72dd				endif 
72dd cd ed 0f			call cmp16 
72e0 28 06			jr z, .chk_fault1 
72e2 11 83 73			ld de, sfaultso 
72e5 c3 37 73			jp .chk_fault 
72e8			.chk_fault1:  
72e8 2a e9 f9			ld hl, (chk_ret_und) 
72eb ed 5b 9a f1		ld de,(chk_word) 
72ef				if DEBUG_STK_FAULT 
72ef					DMARK "FAU" 
72ef					CALLMONITOR 
72ef				endif 
72ef cd ed 0f			call cmp16 
72f2 ca fb 72			jp z, .chk_fault2 
72f5 11 93 73			ld de, sfaultru 
72f8 c3 37 73			jp .chk_fault 
72fb			.chk_fault2:  
72fb 2a a7 f9			ld hl, (chk_ret_ovr) 
72fe ed 5b 9a f1		ld de,(chk_word) 
7302				if DEBUG_STK_FAULT 
7302					DMARK "FA1" 
7302					CALLMONITOR 
7302				endif 
7302 cd ed 0f			call cmp16 
7305 ca 0e 73			jp z, .chk_fault3 
7308 11 a1 73			ld de, sfaultro 
730b c3 37 73			jp .chk_fault 
730e			.chk_fault3:  
730e 2a 25 f9			ld hl, (chk_loop_ovr) 
7311 ed 5b 9a f1		ld de,(chk_word) 
7315				if DEBUG_STK_FAULT 
7315					DMARK "FA2" 
7315					CALLMONITOR 
7315				endif 
7315 cd ed 0f			call cmp16 
7318 ca 21 73			jp z, .chk_fault4 
731b 11 bb 73			ld de, sfaultlo 
731e c3 37 73			jp .chk_fault 
7321			.chk_fault4:  
7321 2a 23 f7			ld hl, (chk_data_ovr) 
7324 ed 5b 9a f1		ld de,(chk_word) 
7328				if DEBUG_STK_FAULT 
7328					DMARK "FA3" 
7328					CALLMONITOR 
7328				endif 
7328 cd ed 0f			call cmp16 
732b ca 34 73			jp z, .chk_fault5 
732e 11 d5 73			ld de, sfaultdo 
7331 c3 37 73			jp .chk_fault 
7334			 
7334			 
7334			.chk_fault5:  
7334 d1				pop de 
7335 e1				pop hl 
7336			 
7336 c9				ret 
7337			 
7337 cd 9b 0d		.chk_fault: 	call clear_display 
733a 3e 28				ld a, display_row_2 
733c cd ae 0d				call str_at_display 
733f 11 65 73				   ld de, .stackfault 
7342 3e 00				ld a, display_row_1 
7344 cd ae 0d				call str_at_display 
7347 11 68 fe				    ld de, debug_mark 
734a 3e 11				ld a, display_row_1+17 
734c cd ae 0d				call str_at_display 
734f cd be 0d				call update_display 
7352			 
7352				; prompt before entering montior for investigating issue 
7352			 
7352 3e 78			ld a, display_row_4 
7354 11 ed 1d			ld de, endprog 
7357			 
7357 cd be 0d			call update_display		 
735a			 
735a cd 73 20			call next_page_prompt 
735d			 
735d d1				pop de 
735e e1				pop hl 
735f cd 41 1e				call monitor 
7362 c3 4a 1d				jp warmstart 
7365					;jp 0 
7365					;halt 
7365			 
7365			 
7365			 
7365 .. 00		.stackfault: 	db "Stack fault:",0 
7372			 
7372 .. 00		sfaultsu: 	db	"Stack under flow",0 
7383 .. 00		sfaultso: 	db	"Stack over flow",0 
7393 .. 00		sfaultru:	db "RTS underflow",0 
73a1 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
73bb .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
73d5 .. 00		sfaultdo:	db "DTS overflow", 0 
73e2			 
73e2			 
73e2			fault_dsp_under: 
73e2 11 f4 73			ld de, .dsp_under 
73e5 c3 a4 74			jp .show_fault 
73e8			 
73e8			fault_rsp_under: 
73e8 11 02 74			ld de, .rsp_under 
73eb c3 a4 74			jp .show_fault 
73ee			fault_loop_under: 
73ee 11 10 74			ld de, .loop_under 
73f1 c3 a4 74			jp .show_fault 
73f4			 
73f4 .. 00		.dsp_under: db "DSP Underflow",0 
7402 .. 00		.rsp_under: db "RSP Underflow",0 
7410 .. 00		.loop_under: db "LOOP Underflow",0 
741f			 
741f			 
741f d5			type_faultn: 	push de 
7420 e5					push hl 
7421 cd 9b 0d				call clear_display 
7424 11 4b 74				   ld de, .typefaultn 
7427 3e 00				ld a, display_row_1 
7429 cd ae 0d				call str_at_display 
742c 11 68 fe				    ld de, debug_mark 
742f 3e 11				ld a, display_row_1+17 
7431 cd ae 0d				call str_at_display 
7434 cd be 0d				call update_display 
7437			 
7437				; prompt before entering montior for investigating issue 
7437			 
7437 3e 78			ld a, display_row_4 
7439 11 ed 1d			ld de, endprog 
743c			 
743c cd be 0d			call update_display		 
743f			 
743f cd 73 20			call next_page_prompt 
7442			 
7442 e5					push hl 
7443 d5					push de 
7444 cd 41 1e				call monitor 
7447 c3 4a 1d				jp warmstart 
744a 76					halt 
744b			 
744b			 
744b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
7462			 
7462 d5			type_faults: 	push de 
7463 e5					push hl 
7464 cd 9b 0d				call clear_display 
7467 11 8d 74				   ld de, .typefaults 
746a 3e 00				ld a, display_row_1 
746c cd ae 0d				call str_at_display 
746f 11 68 fe				    ld de, debug_mark 
7472 3e 11				ld a, display_row_1+17 
7474 cd ae 0d				call str_at_display 
7477 cd be 0d				call update_display 
747a			 
747a				; prompt before entering montior for investigating issue 
747a			 
747a 3e 78			ld a, display_row_4 
747c 11 ed 1d			ld de, endprog 
747f			 
747f cd be 0d			call update_display		 
7482			 
7482 cd 73 20			call next_page_prompt 
7485			 
7485 e1					pop hl 
7486 d1					pop de 
7487 cd 41 1e				call monitor 
748a c3 4a 1d				jp warmstart 
748d			 
748d			 
748d .. 00		.typefaults: db "STR Type Expected TOS!",0 
74a4			 
74a4			.show_fault: 	 
74a4 d5					push de 
74a5 cd 9b 0d				call clear_display 
74a8 d1					pop de 
74a9 3e 00				ld a, display_row_1 
74ab cd ae 0d				call str_at_display 
74ae 11 68 fe				    ld de, debug_mark 
74b1 3e 11				ld a, display_row_1+17 
74b3 cd ae 0d				call str_at_display 
74b6 cd be 0d				call update_display 
74b9			 
74b9				; prompt before entering montior for investigating issue 
74b9			 
74b9 3e 78			ld a, display_row_4 
74bb 11 ed 1d			ld de, endprog 
74be			 
74be cd be 0d			call update_display		 
74c1			 
74c1 cd 73 20			call next_page_prompt 
74c4			 
74c4 e1					pop hl 
74c5 d1					pop de 
74c6 cd 41 1e				call monitor 
74c9			; do a dump to cli and not warmstart so we preserve all of the uwords.  
74c9			; TODO Make optional fault restart to cli or warm boot? 
74c9					;jp warmstart 
74c9 c3 94 1d				jp cli 
74cc 76					halt 
74cd			 
74cd			; handle the auto run of code from files in storage 
74cd			 
74cd			 
74cd			include "forth_startup.asm" 
74cd			; Which startup method to use? 
74cd			; 
74cd			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
74cd			; followed by loading of a list of scripts in eeprom 
74cd			 
74cd			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
74cd			; from eeprom 
74cd			 
74cd			; Select with define in main stubs 
74cd			 
74cd			if STARTUP_V1 
74cd				include "forth_startupv1.asm" 
74cd			endif 
74cd			if STARTUP_V2 
74cd				include "forth_startupv2.asm" 
74cd			; Version 2 of the startup  
74cd			;  
74cd			; Auto load any files in bank 1 that start with a '*' 
74cd			; If no se storage then revert to using eprom 
74cd			 
74cd			 
74cd			if STORAGE_SE = 0 
74cd			 
74cd			sprompt1: db "Startup load...",0 
74cd			sprompt2: db "Run? 1=No *=End #=All",0 
74cd			 
74cd			 
74cd			 
74cd			 
74cd			forth_startup: 
74cd				ld hl, startcmds 
74cd				ld a, 0 
74cd				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
74cd			 
74cd			.start1:	push hl 
74cd				call clear_display 
74cd				ld de, sprompt1 
74cd			        ld a, display_row_1 
74cd				call str_at_display 
74cd				ld de, sprompt2 
74cd			        ld a, display_row_2 
74cd				call str_at_display 
74cd				pop hl 
74cd				push hl 
74cd				ld e,(hl) 
74cd				inc hl 
74cd				ld d,(hl) 
74cd			        ld a, display_row_3 
74cd				call str_at_display 
74cd				call update_display 
74cd			 
74cd			 
74cd				ld a, (os_last_cmd) 
74cd				cp 0 
74cd				jr z, .startprompt 
74cd				call delay250ms 
74cd				jr .startdo 
74cd				 
74cd				 
74cd			 
74cd			.startprompt: 
74cd			 
74cd				ld a,display_row_4 + display_cols - 1 
74cd			        ld de, endprg 
74cd				call str_at_display 
74cd				call update_display 
74cd				call delay1s 
74cd				call cin_wait 
74cd						 
74cd				cp '*' 
74cd				jr z, .startupend1 
74cd				cp '#' 
74cd				jr nz, .startno 
74cd				ld a, 1 
74cd				ld (os_last_cmd),a 
74cd				jr .startdo 
74cd			.startno:	cp '1' 
74cd				jr z,.startnxt  
74cd			 
74cd				; exec startup line 
74cd			.startdo:	 
74cd				pop hl 
74cd				push hl 
74cd				 
74cd				ld e,(hl) 
74cd				inc hl 
74cd				ld d,(hl) 
74cd				ex de,hl 
74cd			 
74cd				push hl 
74cd			 
74cd				ld a, 0 
74cd				;ld a, FORTH_END_BUFFER 
74cd				call strlent 
74cd				inc hl   ; include zero term to copy 
74cd				ld b,0 
74cd				ld c,l 
74cd				pop hl 
74cd				ld de, scratch 
74cd				ldir 
74cd			 
74cd			 
74cd				ld hl, scratch 
74cd				call forthparse 
74cd				call forthexec 
74cd				call forthexec_cleanup 
74cd			 
74cd				ld a, display_row_4 
74cd				ld de, endprog 
74cd			 
74cd				call update_display		 
74cd			 
74cd				ld a, (os_last_cmd) 
74cd				cp 0 
74cd				jr nz, .startnxt 
74cd				call next_page_prompt 
74cd			        call clear_display 
74cd				call update_display		 
74cd			 
74cd				; move onto next startup line? 
74cd			.startnxt: 
74cd			 
74cd				call delay250ms 
74cd				pop hl 
74cd			 
74cd				inc hl 
74cd				inc hl 
74cd			 
74cd				push hl 
74cd				ld e, (hl) 
74cd				inc hl 
74cd				ld d, (hl) 
74cd				pop hl 
74cd				; TODO replace 0 test 
74cd			 
74cd				ex de, hl 
74cd				call ishlzero 
74cd			;	ld a,e 
74cd			;	add d 
74cd			;	cp 0    ; any left to do? 
74cd				ex de, hl 
74cd				jp nz, .start1 
74cd				jr .startupend 
74cd			 
74cd			.startupend1: pop hl 
74cd			.startupend: 
74cd			 
74cd				call clear_display 
74cd				call update_display 
74cd				ret 
74cd			endif 
74cd			 
74cd			 
74cd			if STORAGE_SE 
74cd			 
74cd			;sprompt3: db "Loading from start-up file:",0 
74cd .. 00		sprompt3: db "  Searching...",0 
74dc			;sprompt4: db "(Any key to stop)",0 
74dc			 
74dc			 
74dc			forth_autoload: 
74dc			 
74dc				; load block 0 of store 1 
74dc				 
74dc 3e fe			ld a, $fe      ; bit 0 clear 
74de 32 5d fa			ld (spi_device), a 
74e1			 
74e1 cd 16 05			call storage_get_block_0 
74e4			 
74e4 3a 98 fa			ld a, (store_page+STORE_0_AUTOFILE) 
74e7			 
74e7 fe 00			cp 0 
74e9 c8				ret z     ; auto start not enabled 
74ea			 
74ea cd 9b 0d			call clear_display 
74ed			 
74ed				; set bank 
74ed			 
74ed 3a 9a fa				ld a, (store_page+STORE_0_BANKRUN) 
74f0 32 5d fa				ld (spi_device), a 
74f3			 
74f3			 
74f3				; generate a directory of bank 1 and search for flagged files 
74f3			 
74f3					if DEBUG_FORTH_WORDS_KEY 
74f3						DMARK "DIR" 
74f3 f5				push af  
74f4 3a 08 75			ld a, (.dmark)  
74f7 32 68 fe			ld (debug_mark),a  
74fa 3a 09 75			ld a, (.dmark+1)  
74fd 32 69 fe			ld (debug_mark+1),a  
7500 3a 0a 75			ld a, (.dmark+2)  
7503 32 6a fe			ld (debug_mark+2),a  
7506 18 03			jr .pastdmark  
7508 ..			.dmark: db "DIR"  
750b f1			.pastdmark: pop af  
750c			endm  
# End of macro DMARK
750c						CALLMONITOR 
750c cd 6c fe			call debug_vector  
750f				endm  
# End of macro CALLMONITOR
750f					endif 
750f			 
750f cd 16 05			call storage_get_block_0 
7512			 
7512 21 77 fa			ld hl, store_page     ; get current id count 
7515 46				ld b, (hl) 
7516 0e 00			ld c, 0    ; count of files   
7518					if DEBUG_FORTH_WORDS 
7518						DMARK "DI1" 
7518 f5				push af  
7519 3a 2d 75			ld a, (.dmark)  
751c 32 68 fe			ld (debug_mark),a  
751f 3a 2e 75			ld a, (.dmark+1)  
7522 32 69 fe			ld (debug_mark+1),a  
7525 3a 2f 75			ld a, (.dmark+2)  
7528 32 6a fe			ld (debug_mark+2),a  
752b 18 03			jr .pastdmark  
752d ..			.dmark: db "DI1"  
7530 f1			.pastdmark: pop af  
7531			endm  
# End of macro DMARK
7531						CALLMONITOR 
7531 cd 6c fe			call debug_vector  
7534				endm  
# End of macro CALLMONITOR
7534					endif 
7534			 
7534				; check for empty drive 
7534			 
7534 3e 00			ld a, 0 
7536 b8				cp b 
7537 ca 84 75			jp z, .dirdone 
753a			 
753a				; for each of the current ids do a search for them and if found push to stack 
753a			 
753a c5			.diritem:	push bc 
753b 21 40 00				ld hl, STORE_BLOCK_PHY 
753e 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
7540 58					ld e,b 
7541			 
7541 d5					push de 
7542 e5					push hl 
7543 cd 9b 0d			call clear_display 
7546 3e 32			ld a, display_row_2 + 10 
7548 11 cd 74			ld de, sprompt3 
754b cd ae 0d			call str_at_display 
754e cd f2 0c			call active 
7551 eb				ex de, hl 
7552 3e 2f			ld a, display_row_2 + 7 
7554 cd ae 0d			call str_at_display 
7557 cd be 0d			call update_display 
755a e1				pop hl 
755b d1				pop de 
755c			 
755c			;		if DEBUG_FORTH_WORDS 
755c			;			DMARK "DI2" 
755c			;			CALLMONITOR 
755c			;		endif 
755c			 
755c cd 98 07				call storage_findnextid 
755f			 
755f			;		if DEBUG_FORTH_WORDS 
755f			;			DMARK "DI3" 
755f			;			CALLMONITOR 
755f			;		endif 
755f			 
755f					; if found hl will be non zero 
755f			 
755f cd f8 0f				call ishlzero 
7562			;		ld a, l 
7562			;		add h 
7562			; 
7562			;		cp 0 
7562 28 1d				jr z, .dirnotfound 
7564			 
7564					; increase count 
7564			 
7564 c1					pop bc	 
7565 0c					inc c 
7566 c5					push bc 
7567					 
7567			 
7567					; get file header and push the file name 
7567			 
7567 11 77 fa				ld de, store_page 
756a cd 65 04				call storage_read_block 
756d			 
756d					; push file id to stack 
756d				 
756d			 
756d					; is this a file we want to run? 
756d			 
756d 21 7a fa				ld hl, store_page+3 
7570 7e					ld a,(hl) 
7571 fe 2a				cp '*' 
7573 20 0c				jr nz,  .dirnotfound 
7575					 
7575			 
7575			 
7575 3a 77 fa				ld a, (store_page) 
7578 d5					push de 
7579 e5					push hl 
757a c5					push bc 
757b cd a7 75				call .autorunf 
757e c1					pop bc 
757f e1					pop hl 
7580 d1					pop de 
7581			 
7581			 
7581			 
7581				; save this extent 
7581			 
7581					; push file name 
7581			;display file name to run 
7581			 
7581			;		ld hl, store_page+3 
7581			;		if DEBUG_FORTH_WORDS 
7581			;			DMARK "DI5" 
7581			;			CALLMONITOR 
7581			;		endif 
7581			; 
7581			;		 
7581			; 
7581			;		call forth_push_str 
7581			;		if DEBUG_FORTH_WORDS 
7581			;			DMARK "DI6" 
7581			;			CALLMONITOR 
7581			;		endif 
7581			.dirnotfound: 
7581 c1					pop bc     
7582 10 b6				djnz .diritem 
7584				 
7584			.dirdone:	 
7584					if DEBUG_FORTH_WORDS 
7584						DMARK "DI7" 
7584 f5				push af  
7585 3a 99 75			ld a, (.dmark)  
7588 32 68 fe			ld (debug_mark),a  
758b 3a 9a 75			ld a, (.dmark+1)  
758e 32 69 fe			ld (debug_mark+1),a  
7591 3a 9b 75			ld a, (.dmark+2)  
7594 32 6a fe			ld (debug_mark+2),a  
7597 18 03			jr .pastdmark  
7599 ..			.dmark: db "DI7"  
759c f1			.pastdmark: pop af  
759d			endm  
# End of macro DMARK
759d						CALLMONITOR 
759d cd 6c fe			call debug_vector  
75a0				endm  
# End of macro CALLMONITOR
75a0					endif 
75a0			 
75a0 cd 9b 0d				call clear_display 
75a3 cd be 0d				call update_display 
75a6			 
75a6 c9					ret 
75a7			 
75a7			 
75a7			 
75a7			 
75a7			 
75a7			.autorunf: 
75a7			 
75a7			 
75a7				; get file id to load from and get the file name to display 
75a7			 
75a7			;		ld a, (store_page+STORE_0_FILERUN) 
75a7			 
75a7 2e 00				ld l, 0 
75a9 67					ld h, a 
75aa 11 77 fa				ld de, store_page 
75ad			 
75ad					if DEBUG_FORTH_WORDS 
75ad						DMARK "ASp" 
75ad f5				push af  
75ae 3a c2 75			ld a, (.dmark)  
75b1 32 68 fe			ld (debug_mark),a  
75b4 3a c3 75			ld a, (.dmark+1)  
75b7 32 69 fe			ld (debug_mark+1),a  
75ba 3a c4 75			ld a, (.dmark+2)  
75bd 32 6a fe			ld (debug_mark+2),a  
75c0 18 03			jr .pastdmark  
75c2 ..			.dmark: db "ASp"  
75c5 f1			.pastdmark: pop af  
75c6			endm  
# End of macro DMARK
75c6						CALLMONITOR 
75c6 cd 6c fe			call debug_vector  
75c9				endm  
# End of macro CALLMONITOR
75c9					endif 
75c9 cd be 09				call storage_read 
75cc			 
75cc					if DEBUG_FORTH_WORDS 
75cc						DMARK "ASr" 
75cc f5				push af  
75cd 3a e1 75			ld a, (.dmark)  
75d0 32 68 fe			ld (debug_mark),a  
75d3 3a e2 75			ld a, (.dmark+1)  
75d6 32 69 fe			ld (debug_mark+1),a  
75d9 3a e3 75			ld a, (.dmark+2)  
75dc 32 6a fe			ld (debug_mark+2),a  
75df 18 03			jr .pastdmark  
75e1 ..			.dmark: db "ASr"  
75e4 f1			.pastdmark: pop af  
75e5			endm  
# End of macro DMARK
75e5						CALLMONITOR 
75e5 cd 6c fe			call debug_vector  
75e8				endm  
# End of macro CALLMONITOR
75e8					endif 
75e8			 
75e8 cd f8 0f				call ishlzero 
75eb c8					ret z             ; file not found 
75ec			 
75ec					; display file name we are loading 
75ec			 
75ec cd 9b 0d				call clear_display 
75ef			 
75ef 3e 32				ld a, display_row_2 + 10 
75f1 11 7a fa				ld de, store_page+3 
75f4 cd ae 0d				call str_at_display 
75f7				 
75f7			; 
75f7			 
75f7			;	ld a, display_row_1+5 
75f7			;	ld de, sprompt3 
75f7			;	call str_at_display 
75f7			;	ld a, display_row_2+7 
75f7			;	call active 
75f7			;	ex de, hl 
75f7			;;	ld de, sprompt4 
75f7			;	call str_at_display 
75f7			; 
75f7 cd be 0d			call update_display 
75fa			 
75fa			;	call cin_wait 
75fa			;	cp 'n' 
75fa			;	ret z 
75fa			;	cp 'N' 
75fa			;	ret z 
75fa			 
75fa			;	call delay1s 
75fa			 
75fa 3a 79 fa			ld a, (store_page+2) 
75fd 32 66 fa			ld (store_openmaxext), a    ; save count of ext 
7600 3e 01			ld a, 1  
7602 32 67 fa			ld (store_openext), a    ; save count of ext 
7605			 
7605			.autof: 
7605				; begin to read a line from file 
7605			 
7605 21 e5 f4			ld hl, os_cli_cmd 
7608 22 e3 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
760b			  
760b			.readext: 
760b 3a 67 fa			ld a, (store_openext) 
760e 6f				ld l , a 
760f				 
760f 3a 77 fa			ld a, (store_page) 
7612 67				ld h, a	 
7613 11 77 fa			ld de, store_page 
7616					if DEBUG_FORTH_WORDS 
7616						DMARK "ASl" 
7616 f5				push af  
7617 3a 2b 76			ld a, (.dmark)  
761a 32 68 fe			ld (debug_mark),a  
761d 3a 2c 76			ld a, (.dmark+1)  
7620 32 69 fe			ld (debug_mark+1),a  
7623 3a 2d 76			ld a, (.dmark+2)  
7626 32 6a fe			ld (debug_mark+2),a  
7629 18 03			jr .pastdmark  
762b ..			.dmark: db "ASl"  
762e f1			.pastdmark: pop af  
762f			endm  
# End of macro DMARK
762f						CALLMONITOR 
762f cd 6c fe			call debug_vector  
7632				endm  
# End of macro CALLMONITOR
7632					endif 
7632 cd be 09				call storage_read 
7635 cd f8 0f			call ishlzero 
7638 c8				ret z 
7639			 
7639			; TODO copy to exec buffer 
7639			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7639			 
7639				; copy the record buffer to the cli buffer 
7639			 
7639 ed 5b e3 f6		ld de, (os_var_array) 
763d 21 79 fa			ld hl, store_page+2 
7640			;	ex de, hl 
7640 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
7643 ed b0			ldir 
7645 ed 53 e3 f6		ld (os_var_array), de 
7649				 
7649 3a 67 fa			ld a, (store_openext) 
764c 3c				inc a 
764d 32 67 fa			ld (store_openext), a    ; save count of ext 
7650			 
7650			 
7650			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7650				 
7650 3a 6a fa			ld a, (store_readcont) 
7653 fe 00			cp 0 
7655 20 b4			jr nz, .readext 
7657			 
7657			;	jr z, .autoend 
7657			 
7657					if DEBUG_FORTH_WORDS 
7657						DMARK "ASc" 
7657 f5				push af  
7658 3a 6c 76			ld a, (.dmark)  
765b 32 68 fe			ld (debug_mark),a  
765e 3a 6d 76			ld a, (.dmark+1)  
7661 32 69 fe			ld (debug_mark+1),a  
7664 3a 6e 76			ld a, (.dmark+2)  
7667 32 6a fe			ld (debug_mark+2),a  
766a 18 03			jr .pastdmark  
766c ..			.dmark: db "ASc"  
766f f1			.pastdmark: pop af  
7670			endm  
# End of macro DMARK
7670						CALLMONITOR 
7670 cd 6c fe			call debug_vector  
7673				endm  
# End of macro CALLMONITOR
7673					endif 
7673 e5				push hl	 
7674 d5				push de 
7675 cd f2 0c			call active 
7678 eb				ex de, hl 
7679 3e 2f			ld a, display_row_2 + 7 
767b cd ae 0d			call str_at_display 
767e			 
767e cd be 0d			call update_display 
7681 d1				pop de  
7682 e1				pop hl 
7683			;	call delay250ms 
7683			 
7683			 
7683			 
7683			 
7683			.autoexec: 
7683			 
7683			 
7683 21 e5 f4			ld hl, os_cli_cmd 
7686					if DEBUG_FORTH_WORDS 
7686						DMARK "ASx" 
7686 f5				push af  
7687 3a 9b 76			ld a, (.dmark)  
768a 32 68 fe			ld (debug_mark),a  
768d 3a 9c 76			ld a, (.dmark+1)  
7690 32 69 fe			ld (debug_mark+1),a  
7693 3a 9d 76			ld a, (.dmark+2)  
7696 32 6a fe			ld (debug_mark+2),a  
7699 18 03			jr .pastdmark  
769b ..			.dmark: db "ASx"  
769e f1			.pastdmark: pop af  
769f			endm  
# End of macro DMARK
769f						CALLMONITOR 
769f cd 6c fe			call debug_vector  
76a2				endm  
# End of macro CALLMONITOR
76a2					endif 
76a2 cd f6 24			call forthparse 
76a5 cd 36 25			call forthexec 
76a8 cd 48 24			call forthexec_cleanup 
76ab			 
76ab			 
76ab			 
76ab c3 05 76			jp .autof 
76ae			;.autofdone: 
76ae			; 
76ae			;		if DEBUG_FORTH_WORDS 
76ae			;			DMARK "ASx" 
76ae			;			CALLMONITOR 
76ae			;		endif 
76ae			;;	call clear_display 
76ae			;	ret 
76ae			 
76ae			 
76ae			 
76ae			endif 
# End of file forth_startupv2.asm
76ae			endif 
76ae			 
# End of file forth_startup.asm
76ae			 
76ae			; eof 
# End of file forth_kernel.asm
76ae			;include "nascombasic.asm" 
76ae			 
76ae			 
76ae			; find out where the code ends if loaded into RAM (for SC114) 
76ae			;endofcode:  
76ae			;	nop 
76ae			 
76ae			 
76ae			; jump to nmi vector 
76ae			 
76ae			init_nmi: 
76ae 3e c9			ld a, $c9   ; RET 
76b0 32 6f fe			ld (nmi_vector), a 
76b3 c9				ret 
76b4			nmi: 
76b4 e5				push hl 
76b5 d5				push de 
76b6 c5				push bc 
76b7 f5				push af 
76b8 cd 6f fe			call nmi_vector 
76bb f5				push af 
76bc c5				push bc 
76bd d5				push de 
76be e5				push hl 
76bf ed 4d			reti 
76c1			 
76c1			 
76c1			; eof 
76c1			 
# End of file main.asm
76c1			include "firmware_lcd_4x40.asm" 
76c1			; **********************************************************************  
76c1			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
76c1			; **********************************************************************  
76c1			;  
76c1			; **  Written as a Small Computer Monitor App  
76c1			; **  www.scc.me.uk  
76c1			;  
76c1			; History  
76c1			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
76c1			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
76c1			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
76c1			;  
76c1			; **********************************************************************  
76c1			;  
76c1			; This program is an example of one of the methods of interfacing an   
76c1			; alphanumeric LCD module.   
76c1			;  
76c1			; In this example the display is connected to either a Z80 PIO or a   
76c1			; simple 8-bit output port.   
76c1			;  
76c1			; This interfacing method uses 4-bit data mode and uses time delays  
76c1			; rather than polling the display's ready status. As a result the   
76c1			; interface only requires 6 simple output lines:  
76c1			;   Output bit 0 = not used  
76c1			;   Output bit 1 = not used  
76c1			;   Output bit 2 = RS         High = data, Low = instruction  
76c1			;   Output bit 3 = E          Active high  
76c1			;   Output bit 4 = DB4  
76c1			;   Output bit 5 = DB5  
76c1			;   Output bit 6 = DB6  
76c1			;   Output bit 7 = DB7  
76c1			; Display's R/W is connected to 0v so it is always in write mode  
76c1			;  
76c1			; This set up should work with any system supporting the RC2014 bus  
76c1			  
76c1			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
76c1			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
76c1			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
76c1			;  
76c1			; **********************************************************************  
76c1			  
76c1			; Additonal for 4x40. E1 and E2 instead of just E   
76c1			; TODO swipe vidout signal on port a to activate E2  
76c1			  
76c1			; **********************************************************************  
76c1			; **  Constants  
76c1			; **********************************************************************  
76c1			; LCD constants required by LCD support module  
76c1			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
76c1			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
76c1			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
76c1			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
76c1			; TODO Decide which E is being set  
76c1			kLCDWidth:  EQU display_cols             ;Width in characters  
76c1			  
76c1			; **********************************************************************  
76c1			; **  Code library usage  
76c1			; **********************************************************************  
76c1			  
76c1			; send character to current cursor position  
76c1			; wraps and/or scrolls screen automatically  
76c1			  
76c1			  
76c1			  
76c1			lcd_init:  
76c1			  
76c1			; SCMonAPI functions used  
76c1			  
76c1			; Alphanumeric LCD functions used  
76c1			; no need to specify specific functions for this module  
76c1			  
76c1 3e cf		            LD   A, 11001111b  
76c3 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
76c5 3e 00		            LD   A, 00000000b  
76c7 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
76c9			  
76c9			; Initialise alphanumeric LCD module  
76c9 3e 00				ld a, 0  
76cb 32 c8 fb				ld (display_lcde1e2), a  
76ce cd 4f 77		            CALL fLCD_Init      ;Initialise LCD module  
76d1 3e 01				ld a, 1  
76d3 32 c8 fb				ld (display_lcde1e2), a  
76d6 cd 4f 77		            CALL fLCD_Init      ;Initialise LCD module  
76d9			  
76d9 c9				ret  
76da			  
76da			;  
76da			;;  
76da			; lcd functions  
76da			;  
76da			;  
76da			  
76da			; what is at cursor position   
76da			  
76da			;get_cursor:	ld de, (cursor_row)   ;  row + col  
76da			;		call curptr  
76da			;		ret  
76da			  
76da			  
76da			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
76da			  
76da			curptr:  
76da c5				push bc  
76db 21 ae fd			ld hl, display_fb0  
76de			cpr:	  
76de				; loop for cursor whole row  
76de 0e 28			ld c, display_cols  
76e0 23			cpr1:	inc hl  
76e1 0d				dec c  
76e2 20 fc			jr nz, cpr1  
76e4 05				dec b  
76e5 20 f7			jr nz, cpr  
76e7			  
76e7				; add col	  
76e7			  
76e7 23			cpr2:	inc hl  
76e8 1d				dec e  
76e9 20 fc			jr nz, cpr2  
76eb			  
76eb c1				pop bc  
76ec c9				ret  
76ed				  
76ed			  
76ed			  
76ed			  
76ed			  
76ed			; write the frame buffer given in hl to hardware   
76ed 22 c6 fb		write_display: ld (display_write_tmp), hl 	   
76f0 3e 00			ld a, kLCD_Line1  
76f2 cd fc 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76f5 06 28			ld b, display_cols  
76f7 ed 5b c6 fb		ld de, (display_write_tmp)  
76fb cd 47 77			call write_len_string  
76fe				  
76fe				  
76fe 2a c6 fb			ld hl, (display_write_tmp)  
7701 11 28 00			ld de, display_cols  
7704 19				add hl,de  
7705 22 c6 fb			ld (display_write_tmp),hl  
7708			  
7708				  
7708 3e 28			ld a, kLCD_Line2  
770a cd fc 77		            CALL fLCD_Pos       ;Position cursor to location in A  
770d 06 28			ld b, display_cols  
770f ed 5b c6 fb		ld de, (display_write_tmp)  
7713 cd 47 77			call write_len_string  
7716				  
7716 2a c6 fb			ld hl, (display_write_tmp)  
7719 11 28 00			ld de, display_cols  
771c 19				add hl,de  
771d 22 c6 fb			ld (display_write_tmp),hl  
7720			  
7720				  
7720 3e 50			ld a, kLCD_Line3  
7722 cd fc 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7725 06 28			ld b, display_cols  
7727 ed 5b c6 fb		ld de, (display_write_tmp)  
772b cd 47 77			call write_len_string  
772e				  
772e 2a c6 fb			ld hl, (display_write_tmp)  
7731 11 28 00			ld de, display_cols  
7734 19				add hl,de  
7735 22 c6 fb			ld (display_write_tmp),hl  
7738			  
7738				  
7738 3e 78			ld a, kLCD_Line4  
773a cd fc 77		            CALL fLCD_Pos       ;Position cursor to location in A  
773d 06 28			ld b, display_cols  
773f ed 5b c6 fb		ld de, (display_write_tmp)  
7743 cd 47 77			call write_len_string  
7746 c9					ret  
7747				  
7747				; write out a fixed length string given in b from de  
7747			  
7747 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
7748 cd b4 77		            CALL fLCD_Data      ;Write character to display  
774b 13				inc de  
774c 10 f9			djnz write_len_string  
774e c9				ret  
774f			  
774f			; Some other things to do  
774f			;            LD   A, kLCD_Clear ;Display clear  
774f			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
774f			;            LD   A, kLCD_Under ;Display on with underscore cursor  
774f			;            LD   A, kLCD_On     ;Display on with no cursor  
774f			;            ;LD   A, kLCD_Off   ;Display off  
774f			;            CALL fLCD_Inst      ;Send instruction to display  
774f			;  
774f			;  
774f			;            halt  
774f			;  
774f			;  
774f			;MsgHello:   DB  "Hello World!",0  
774f			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
774f			  
774f			; Custom characters 5 pixels wide by 8 pixels high  
774f			; Up to 8 custom characters can be defined  
774f			;BitMaps:      
774f			;; Character 0x00 = Battery icon  
774f			;            DB  01110b  
774f			;            DB  11011b  
774f			;            DB  10001b  
774f			;            DB  10001b  
774f			;            DB  11111b  
774f			;            DB  11111b  
774f			;            DB  11111b  
774f			;            DB  11111b  
774f			;; Character 0x01 = Bluetooth icon  
774f			;            DB  01100b  
774f			;            DB  01010b  
774f			;            DB  11100b  
774f			;            DB  01000b  
774f			;            DB  11100b  
774f			;            DB  01010b  
774f			;            DB  01100b  
774f			;            DB  00000b  
774f			;  
774f			  
774f			  
774f			; **********************************************************************  
774f			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
774f			; **********************************************************************  
774f			;  
774f			; **  Written as a Small Computer Monitor App   
774f			; **  Version 0.1 SCC 2018-05-16  
774f			; **  www.scc.me.uk  
774f			;  
774f			; **********************************************************************  
774f			;  
774f			; This module provides support for alphanumeric LCD modules using with  
774f			; *  HD44780 (or compatible) controller  
774f			; *  5 x 7 pixel fonts  
774f			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
774f			; *  Interface via six digital outputs to the display (see below)  
774f			;  
774f			; LCD module pinout:  
774f			;   1  Vss   0v supply  
774f			;   2  Vdd   5v supply  
774f			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
774f			;   4  RS    High = data, Low = instruction  
774f			;   5  R/W   High = Read, Low = Write  
774f			;   6  E     Enable signal (active high)  
774f			;   7  DB0   Data bit 0  
774f			;   8  DB1   Data bit 1  
774f			;   9  DB2   Data bit 2  
774f			;  10  DB3   Data bit 3  
774f			;  11  DB4   Data bit 4  
774f			;  12  DB5   Data bit 5  
774f			;  13  DB6   Data bit 6  
774f			;  14  DB7   Data bit 7  
774f			;  15  A     Backlight anode (+)  
774f			;  16  K     Backlight cathode (-)  
774f			;  
774f			; This interfacing method uses 4-bit data mode and uses time delays  
774f			; rather than polling the display's ready status. As a result the   
774f			; interface only requires 6 simple output lines:  
774f			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
774f			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
774f			;   LCD DB4 = Microcomputer output port bit 4  
774f			;   LCD DB5 = Microcomputer output port bit 5  
774f			;   LCD DB6 = Microcomputer output port bit 6  
774f			;   LCD DB7 = Microcomputer output port bit 7  
774f			; Display's R/W is connected to 0v so it is always in write mode  
774f			; All 6 connections must be on the same port address <kLCDPrt>  
774f			; This method also allows a decent length of cable from micro to LCD  
774f			;  
774f			; **********************************************************************  
774f			;  
774f			; To include the code for any given function provided by this module,   
774f			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
774f			; the parent source file.  
774f			; For example:  #REQUIRES   uHexPrefix  
774f			;  
774f			; Also #INCLUDE this file at some point after the #REQUIRES statements  
774f			; in the parent source file.  
774f			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
774f			;  
774f			; These are the function names provided by this module:  
774f			; fLCD_Init                     ;Initialise LCD  
774f			; fLCD_Inst                     ;Send instruction to LCD  
774f			; fLCD_Data                     ;Send data byte to LCD  
774f			; fLCD_Pos                      ;Position cursor  
774f			; fLCD_Str                      ;Display string  
774f			; fLCD_Def                      ;Define custom character  
774f			;  
774f			; **********************************************************************  
774f			;  
774f			; Requires SCMonAPI.asm to also be included in the project  
774f			;  
774f			  
774f			  
774f			; **********************************************************************  
774f			; **  Constants  
774f			; **********************************************************************  
774f			  
774f			; Constants that must be defined externally  
774f			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
774f			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
774f			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
774f			;kLCDWidth: EQU 20             ;Width in characters  
774f			  
774f			; general line offsets in any frame buffer  
774f			  
774f			  
774f			display_row_1: equ 0  
774f			display_row_2: equ display_row_1+display_cols  
774f			display_row_3: equ display_row_2 + display_cols  
774f			display_row_4: equ display_row_3 + display_cols  
774f			;display_row_4_eol:   
774f			  
774f			  
774f			; Cursor position values for the start of each line  
774f			  
774f			; E  
774f			kLCD_Line1: EQU 0x00   
774f			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
774f			; E1  
774f			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
774f			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
774f			  
774f			; Instructions to send as A register to fLCD_Inst  
774f			kLCD_Clear: EQU 00000001b     ;LCD clear  
774f			kLCD_Off:   EQU 00001000b     ;LCD off  
774f			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
774f			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
774f			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
774f			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
774f			  
774f			; Constants used by this code module  
774f			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
774f			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
774f			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
774f			  
774f			  
774f			  
774f			; **********************************************************************  
774f			; **  LCD support functions  
774f			; **********************************************************************  
774f			  
774f			; Initialise alphanumeric LCD module  
774f			; LCD control register codes:  
774f			;   DL   0 = 4-bit mode        1 = 8-bit mode  
774f			;   N    0 = 1-line mode       1 = 2-line mode  
774f			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
774f			;   D    0 = Display off       1 = Display on  
774f			;   C    0 = Cursor off        1 = Cursor on  
774f			;   B    0 = Blinking off      1 = Blinking on  
774f			;   ID   0 = Decrement mode    1 = Increment mode  
774f			;   SH   0 = Entire shift off  1 = Entire shift on  
774f 3e 28		fLCD_Init:  LD   A, 40  
7751 cd 76 78		            CALL LCDDelay       ;Delay 40ms after power up  
7754			; For reliable reset set 8-bit mode - 3 times  
7754 cd 46 78		            CALL WrFn8bit       ;Function = 8-bit mode  
7757 cd 46 78		            CALL WrFn8bit       ;Function = 8-bit mode  
775a cd 46 78		            CALL WrFn8bit       ;Function = 8-bit mode  
775d			; Set 4-bit mode  
775d cd 42 78		            CALL WrFn4bit       ;Function = 4-bit mode  
7760 cd 74 78		            CALL LCDDelay1      ;Delay 37 us or more  
7763			; Function set  
7763 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7765 cd 78 77		            CALL fLCD_Inst      ;2 line, display on  
7768			; Display On/Off control  
7768 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
776a cd 78 77		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
776d			; Display Clear  
776d 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
776f cd 78 77		            CALL fLCD_Inst      ;Clear display  
7772			; Entry mode  
7772 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7774 cd 78 77		            CALL fLCD_Inst      ;Increment mode, shift off  
7777			; Display module now initialised  
7777 c9			            RET  
7778			; ok to here  
7778			  
7778			; Write instruction to LCD  
7778			;   On entry: A = Instruction byte to be written  
7778			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7778 f5			fLCD_Inst:  PUSH AF  
7779 f5			            PUSH AF  
777a cd 8c 77		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
777d f1			            POP  AF  
777e 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
777f 17			            RLA  
7780 17			            RLA  
7781 17			            RLA  
7782 cd 8c 77		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7785 3e 02		            LD   A, 2  
7787 cd 76 78		            CALL LCDDelay       ;Delay 2 ms to complete   
778a f1			            POP  AF  
778b c9			            RET  
778c			Wr4bits:   
778c f5					push af  
778d 3a c8 fb				ld a, (display_lcde1e2)  
7790 fe 00				cp 0     ; e  
7792 20 10				jr nz, .wea2	  
7794 f1					pop af  
7795 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7797 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7799 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
779b cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
779d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
779f cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
77a1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77a3 c9			            RET  
77a4 f1			.wea2:		pop af  
77a5 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
77a7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77a9 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
77ab cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
77ad d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77af cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
77b1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77b3 c9			            RET  
77b4			  
77b4			  
77b4			; Write data to LCD  
77b4			;   On entry: A = Data byte to be written  
77b4			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77b4 f5			fLCD_Data:  PUSH AF  
77b5 f5			            PUSH AF  
77b6 cd c8 77		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
77b9 f1			            POP  AF  
77ba 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
77bb 17			            RLA  
77bc 17			            RLA  
77bd 17			            RLA  
77be cd c8 77		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
77c1 3e 96		            LD   A, 150  
77c3 3d			Wait:      DEC  A              ;Wait a while to allow data   
77c4 20 fd		            JR   NZ, Wait      ;  write to complete  
77c6 f1			            POP  AF  
77c7 c9			            RET  
77c8			Wr4bitsa:     
77c8 f5					push af  
77c9 3a c8 fb				ld a, (display_lcde1e2)  
77cc fe 00				cp 0     ; e1  
77ce 20 16				jr nz, .we2	  
77d0 f1					pop af  
77d1 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
77d3 cb d7		            SET  kLCDBitRS, A  
77d5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
77d7 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
77d9 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
77db d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
77dd cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
77df d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
77e1 cb 97		            RES  kLCDBitRS, A  
77e3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77e5 c9			            RET  
77e6 f1			.we2:		pop af  
77e7 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
77e9 cb d7		            SET  kLCDBitRS, A  
77eb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
77ed cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
77ef cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
77f1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
77f3 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
77f5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
77f7 cb 97		            RES  kLCDBitRS, A  
77f9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77fb c9			            RET  
77fc			  
77fc			  
77fc			; Position cursor to specified location  
77fc			;   On entry: A = Cursor position  
77fc			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77fc f5			fLCD_Pos:   PUSH AF  
77fd					; at this point set the E1 or E2 flag depending on position  
77fd			  
77fd c5					push bc  
77fe			;		push af  
77fe 06 00				ld b, 0  
7800 4f					ld c, a  
7801 3e 4f				ld a, kLCD_Line3-1  
7803 b7			 		or a      ;clear carry flag  
7804 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
7805 38 04				jr c, .pe1  
7807			  
7807					; E selection  
7807 cb 80				res 0, b         ; bit 0 unset e  
7809			;		pop af    ; before line 3 so recover orig pos  
7809			;		ld c, a    ; save for poking back  
7809 18 06				jr .peset	          
780b			.pe1:          	; E2 selection  
780b cb c0				set 0, b         ; bit 0 set e1  
780d 79					ld a, c  
780e de 4f				sbc a, kLCD_Line3-1  
7810 4f					ld c, a	         ; save caculated offset  
7811			;		pop af     ; bin this original value now we have calculated form  
7811			  
7811			.peset:		; set bit  
7811 78					ld a, b  
7812 32 c8 fb				ld (display_lcde1e2), a 	  
7815 79					ld a, c  
7816 c1					pop bc  
7817			  
7817 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
7819 cd 78 77		            CALL fLCD_Inst      ;Write instruction to LCD  
781c f1			            POP  AF  
781d c9			            RET  
781e			  
781e			  
781e			; Output text string to LCD  
781e			;   On entry: DE = Pointer to null terminated text string  
781e			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
781e 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
781f b7			            OR   A              ;Null terminator?  
7820 c8			            RET  Z              ;Yes, so finished  
7821 cd b4 77		            CALL fLCD_Data      ;Write character to display  
7824 13			            INC  DE             ;Point to next character  
7825 18 f7		            JR   fLCD_Str       ;Repeat  
7827 c9					ret  
7828			  
7828			; Define custom character  
7828			;   On entry: A = Character number (0 to 7)  
7828			;             DE = Pointer to character bitmap data  
7828			;   On exit:  A = Next character number  
7828			;             DE = Next location following bitmap  
7828			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7828			; Character is   
7828 c5			fLCD_Def:   PUSH BC  
7829 f5			            PUSH AF  
782a 07			            RLCA                ;Calculate location  
782b 07			            RLCA                ;  for bitmap data  
782c 07			            RLCA                ;  = 8 x CharacterNumber  
782d f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
782f cd 78 77		            CALL fLCD_Inst      ;Write instruction to LCD  
7832 06 00		            LD   B, 0  
7834 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
7835 cd b4 77		            CALL fLCD_Data      ;Write byte to display  
7838 13			            INC  DE             ;Point to next byte  
7839 04			            INC  B              ;Count bytes  
783a cb 58		            BIT  3, B           ;Finish all 8 bytes?  
783c 28 f6		            JR   Z, Loop       ;No, so repeat  
783e f1			            POP  AF  
783f 3c			            INC  A              ;Increment character number  
7840 c1			            POP  BC  
7841 c9			            RET  
7842			  
7842			  
7842			; **********************************************************************  
7842			; **  Private functions  
7842			; **********************************************************************  
7842			  
7842			; Write function to LCD  
7842			;   On entry: A = Function byte to be written  
7842			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7842 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7844 18 02		            JR   WrFunc  
7846 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
7848 f5			WrFunc:     PUSH AF  
7849 f5					push af  
784a 3a c8 fb				ld a, (display_lcde1e2)  
784d fe 00				cp 0     ; e1  
784f 20 0f				jr nz, .wfea2	  
7851 f1					pop af  
7852 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7854 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
7856 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7858 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
785a cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
785c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
785e 18 0d			jr .wfskip  
7860 f1			.wfea2:		pop af  
7861 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7863 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7865 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7867 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7869 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
786b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
786d 3e 05		.wfskip:            LD  A, 5  
786f cd 76 78		            CALL LCDDelay       ;Delay 5 ms to complete  
7872 f1			            POP  AF  
7873 c9			            RET  
7874			  
7874			  
7874			; Delay in milliseconds  
7874			;   On entry: A = Number of milliseconds delay  
7874			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7874 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7876 d5			LCDDelay:   PUSH DE  
7877 5f			            LD   E, A           ;Delay by 'A' ms  
7878 16 00		            LD   D, 0  
787a cd c3 0c		            CALL aDelayInMS  
787d d1			            POP  DE  
787e c9			            RET  
787f			  
787f			  
787f			testlcd:  
787f 3e 00			ld a, kLCD_Line1  
7881 cd fc 77			call fLCD_Pos  
7884 06 28			ld b, 40  
7886 11 b4 78			ld de, .ttext1  
7889 cd 47 77			call write_len_string  
788c			  
788c 3e 28			ld a, kLCD_Line2  
788e cd fc 77			call fLCD_Pos  
7891 06 28			ld b, 40  
7893 11 dd 78			ld de, .ttext2  
7896 cd 47 77			call write_len_string  
7899 3e 50			ld a, kLCD_Line3  
789b cd fc 77			call fLCD_Pos  
789e 06 28			ld b, 40  
78a0 11 06 79			ld de, .ttext3  
78a3 cd 47 77			call write_len_string  
78a6 3e 78			ld a, kLCD_Line4  
78a8 cd fc 77			call fLCD_Pos  
78ab 06 28			ld b, 40  
78ad 11 2f 79			ld de, .ttext4  
78b0 cd 47 77			call write_len_string  
78b3			  
78b3 76				halt  
78b4			  
78b4			  
78b4 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
78dd .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
7906 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
792f .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
7958			   
7958			  
7958			  
7958			; eof  
7958			  
# End of file firmware_lcd_4x40.asm
7958			;include "firmware_lcd_4x20.asm" 
7958			include "firmware_key_5x10.asm" 
7958			; 5 x 10 decade counter scanner  
7958			  
7958			  
7958			; TODO do cursor shape change for shift keys  
7958			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
7958			  
7958			  
7958			; bit mask for each scan column and row for teing the matrix  
7958			  
7958			  
7958			key_init:  
7958			  
7958			; SCMonAPI functions used  
7958			  
7958			; Alphanumeric LCD functions used  
7958			; no need to specify specific functions for this module  
7958			  
7958			  
7958 3e cf		            LD   A, 11001111b  
795a d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
795c			;            LD   A, 00000000b  
795c 3e 1f		            LD   A, 00011111b  
795e d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7960			  
7960			  
7960				; TODO Configure cursor shapes  
7960			  
7960				; Load cursor shapes   
7960 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7962 11 72 79		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7965 06 02		            LD   B, 2           ;Number of characters to define  
7967 cd 28 78		.DefLoop:   CALL fLCD_Def       ;Define custom character  
796a 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
796c			  
796c 3e 01				ld a, 1  
796e 32 be fb			ld (cursor_shape),a  
7971 c9				ret  
7972			  
7972			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7972			; Up to 8 custom characters can be defined  
7972			.cursor_shapes:      
7972			;; Character 0x00 = Normal  
7972 1f			            DB  11111b  
7973 1f			            DB  11111b  
7974 1f			            DB  11111b  
7975 1f			            DB  11111b  
7976 1f			            DB  11111b  
7977 1f			            DB  11111b  
7978 1f			            DB  11111b  
7979 1f			            DB  11111b  
797a			;; Character 0x01 = Modifier  
797a 1f			            DB  11111b  
797b 1b			            DB  11011b  
797c 1b			            DB  11011b  
797d 1b			            DB  11011b  
797e 1b			            DB  11011b  
797f 1f			            DB  11111b  
7980 1b			            DB  11011b  
7981 1f			            DB  11111b  
7982			  
7982			  
7982			  
7982			  
7982			; Display custom character 0  
7982			;            LD   A, kLCD_Line1+14  
7982			;            CALL fLCD_Pos       ;Position cursor to location in A  
7982			;            LD   A, 0  
7982			;            CALL fLCD_Data      ;Write character in A at cursor  
7982			  
7982			; Display custom character 1  
7982			;            LD   A, kLCD_Line2+14  
7982			;            CALL fLCD_Pos      ;Position cursor to location in A  
7982			;            LD   A, 1  
7982			;            CALL fLCD_Data     ;Write character in A at cursor  
7982			  
7982			; keyboard scanning   
7982			  
7982			; character in from keyboard  
7982			  
7982			; mapping for the pcb layout  
7982			  
7982			.matrix_to_char:  
7982 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
798d .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7998 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
79a3 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
79ae .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
79b9			.matrix_to_shift:  
79b9			  
79b9 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
79c4 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
79cf 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
79da 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
79e5 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
79f0			  
79f0			.matrix_to_symbolshift:  
79f0			  
79f0 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
79fb .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7a06 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7a11			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7a11 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7a1c .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7a27			  
7a27			  
7a27			  
7a27			; mapping for a simple straight through breadboard layout  
7a27			  
7a27			;.matrix_to_char:  
7a27			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7a27			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7a27			;		db "asdfghjkl",KEY_CR,0  
7a27			;		db "qwertyuiop",0  
7a27			;		 db "1234567890",0  
7a27			;.matrix_to_shift:  
7a27			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7a27			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7a27			;		db "ASDFGHJKL",KEY_CR,0  
7a27			;		db "QWERTYUIOP",0  
7a27			;		 db "!",'"',"#$%^&*()",0  
7a27			;.matrix_to_symbolshift:  
7a27			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7a27			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7a27			;		db "_?*fghjk=",KEY_CR,0  
7a27			;		db "-/+*[]{}@#",0  
7a27			;		 db "1234567890",0  
7a27			  
7a27			;.matrix_to_char: db "D#0*C987B654A321"  
7a27			  
7a27			  
7a27				  
7a27			  
7a27			; add cin and cin_wait  
7a27			  
7a27 cd 38 7a		cin_wait: 	call cin  
7a2a						if DEBUG_KEYCINWAIT  
7a2a							push af  
7a2a							  
7a2a							ld hl,key_repeat_ct  
7a2a							ld (hl),a  
7a2a							inc hl  
7a2a							call hexout  
7a2a							ld hl,key_repeat_ct+3  
7a2a							ld a,0  
7a2a							ld (hl),a  
7a2a			  
7a2a							    LD   A, kLCD_Line1+11  
7a2a							    CALL fLCD_Pos       ;Position cursor to location in A  
7a2a							    LD   DE, key_repeat_ct  
7a2a							    ;LD   DE, MsgHello  
7a2a							    CALL fLCD_Str       ;Display string pointed to by DE  
7a2a			  
7a2a			  
7a2a			  
7a2a							pop af  
7a2a						endif  
7a2a fe 00			cp 0  
7a2c 28 f9			jr z, cin_wait   ; block until key press  
7a2e			  
7a2e							if DEBUG_KEYCINWAIT  
7a2e								push af  
7a2e			  
7a2e								ld a, 'A'	  
7a2e								ld hl,key_repeat_ct  
7a2e								ld (hl),a  
7a2e								inc hl  
7a2e								ld a,0  
7a2e								ld (hl),a  
7a2e			  
7a2e								    LD   A, kLCD_Line2+11  
7a2e								    CALL fLCD_Pos       ;Position cursor to location in A  
7a2e								    LD   DE, key_repeat_ct  
7a2e								    ;LD   DE, MsgHello  
7a2e								    CALL fLCD_Str       ;Display string pointed to by DE  
7a2e			  
7a2e							call delay500ms  
7a2e			  
7a2e								pop af  
7a2e							endif  
7a2e f5				push af   ; save key pressed  
7a2f			  
7a2f			.cin_wait1:	  
7a2f							if DEBUG_KEYCINWAIT  
7a2f								push af  
7a2f			  
7a2f								ld a, 'b'	  
7a2f								ld hl,key_repeat_ct  
7a2f								ld (hl),a  
7a2f								inc hl  
7a2f								ld a,0  
7a2f								ld (hl),a  
7a2f			  
7a2f								    LD   A, kLCD_Line2+11  
7a2f								    CALL fLCD_Pos       ;Position cursor to location in A  
7a2f								    LD   DE, key_repeat_ct  
7a2f								    ;LD   DE, MsgHello  
7a2f								    CALL fLCD_Str       ;Display string pointed to by DE  
7a2f			  
7a2f			  
7a2f							call delay500ms  
7a2f			  
7a2f								pop af  
7a2f							endif  
7a2f			  
7a2f cd 38 7a		call cin  
7a32 fe 00			cp 0  
7a34 20 f9			jr nz, .cin_wait1  	; wait for key release  
7a36			if DEBUG_KEYCINWAIT  
7a36				push af  
7a36			  
7a36				ld a, '3'	  
7a36				ld hl,key_repeat_ct  
7a36				ld (hl),a  
7a36				inc hl  
7a36				ld a,0  
7a36				ld (hl),a  
7a36			  
7a36			            LD   A, kLCD_Line2+11  
7a36			            CALL fLCD_Pos       ;Position cursor to location in A  
7a36			            LD   DE, key_repeat_ct  
7a36			            ;LD   DE, MsgHello  
7a36			            CALL fLCD_Str       ;Display string pointed to by DE  
7a36			  
7a36			  
7a36			call delay500ms  
7a36			  
7a36				pop af  
7a36			endif  
7a36			  
7a36 f1				pop af   ; get key  
7a37 c9				ret  
7a38			  
7a38			  
7a38 cd 4c 7a		cin: 	call .mtoc  
7a3b			  
7a3b			if DEBUG_KEYCIN  
7a3b				push af  
7a3b				  
7a3b				ld hl,key_repeat_ct  
7a3b				ld (hl),a  
7a3b				inc hl  
7a3b				call hexout  
7a3b				ld hl,key_repeat_ct+3  
7a3b				ld a,0  
7a3b				ld (hl),a  
7a3b			  
7a3b			            LD   A, kLCD_Line3+15  
7a3b			            CALL fLCD_Pos       ;Position cursor to location in A  
7a3b			            LD   DE, key_repeat_ct  
7a3b			            ;LD   DE, MsgHello  
7a3b			            CALL fLCD_Str       ;Display string pointed to by DE  
7a3b			  
7a3b			  
7a3b			call delay500ms  
7a3b			  
7a3b				pop af  
7a3b			endif  
7a3b			  
7a3b			  
7a3b				; no key held  
7a3b fe 00			cp 0  
7a3d c8				ret z  
7a3e			  
7a3e			if DEBUG_KEYCIN  
7a3e				push af  
7a3e			  
7a3e				ld a, '1'	  
7a3e				ld hl,key_repeat_ct  
7a3e				ld (hl),a  
7a3e				inc hl  
7a3e				ld a,0  
7a3e				ld (hl),a  
7a3e			  
7a3e			            LD   A, kLCD_Line4+15  
7a3e			            CALL fLCD_Pos       ;Position cursor to location in A  
7a3e			            LD   DE, key_repeat_ct  
7a3e			            ;LD   DE, MsgHello  
7a3e			            CALL fLCD_Str       ;Display string pointed to by DE  
7a3e			  
7a3e			  
7a3e			call delay500ms  
7a3e			  
7a3e				pop af  
7a3e			endif  
7a3e			  
7a3e				; stop key bounce  
7a3e			  
7a3e 32 88 fe			ld (key_held),a		 ; save it  
7a41 47				ld b, a  
7a42			  
7a42 c5			.cina1:	push bc  
7a43			if DEBUG_KEYCIN  
7a43				push af  
7a43			  
7a43				ld hl,key_repeat_ct  
7a43				inc hl  
7a43				call hexout  
7a43				ld hl,key_repeat_ct+3  
7a43				ld a,0  
7a43				ld (hl),a  
7a43				ld hl,key_repeat_ct  
7a43				ld a, '2'	  
7a43				ld (hl),a  
7a43			  
7a43			            LD   A, kLCD_Line4+15  
7a43			            CALL fLCD_Pos       ;Position cursor to location in A  
7a43			            LD   DE, key_repeat_ct  
7a43			            ;LD   DE, MsgHello  
7a43			            CALL fLCD_Str       ;Display string pointed to by DE  
7a43			  
7a43				pop af  
7a43			endif  
7a43 cd 4c 7a			call .mtoc  
7a46 c1				pop bc  
7a47 b8				cp b  
7a48 28 f8			jr z, .cina1  
7a4a 78				ld a,b		  
7a4b			if DEBUG_KEYCIN  
7a4b				push af  
7a4b			  
7a4b				ld hl,key_repeat_ct  
7a4b				inc hl  
7a4b				call hexout  
7a4b				ld hl,key_repeat_ct+3  
7a4b				ld a,0  
7a4b				ld (hl),a  
7a4b				ld hl,key_repeat_ct  
7a4b				ld a, '3'	  
7a4b				ld (hl),a  
7a4b			  
7a4b			            LD   A, kLCD_Line4+15  
7a4b			            CALL fLCD_Pos       ;Position cursor to location in A  
7a4b			            LD   DE, key_repeat_ct  
7a4b			            ;LD   DE, MsgHello  
7a4b			            CALL fLCD_Str       ;Display string pointed to by DE  
7a4b			  
7a4b				pop af  
7a4b			endif  
7a4b c9				ret  
7a4c			  
7a4c			; detect keyboard modifier key press and apply new overlay to the face key held  
7a4c			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7a4c			  
7a4c			;.cin_map_modifier:   
7a4c			;	ld a, (hl)  
7a4c			;	and 255  
7a4c			;	ret NZ		; modifier key not flagged  
7a4c			;  
7a4c			;	; get key face  
7a4c			;  
7a4c			;	ld b,(key_face_held)  
7a4c			;  
7a4c			;	ld b, key_cols * key_rows  
7a4c			;  
7a4c			;	push de  
7a4c			;	pop hl  
7a4c			;  
7a4c			;.mmod1: ld a,(hl)   ; get map test  
7a4c			;	cp b  
7a4c			;	jr z, .mmod2  
7a4c			;  
7a4c			;  
7a4c			;  
7a4c			;.mmod2: inc hl    ;   
7a4c			;  
7a4c			;	  
7a4c			;  
7a4c			;	  
7a4c			;  
7a4c			;	ld hl,key_actual_pressed  
7a4c			;	ld (hl),a,  
7a4c			;	ret  
7a4c			  
7a4c			; map matrix key held to char on face of key  
7a4c			  
7a4c			.mtoc:  
7a4c			  
7a4c			; test decade counter strobes  
7a4c			  
7a4c			;.decadetest1:  
7a4c			  
7a4c			; reset counter  
7a4c			;ld a, 128  
7a4c			;out (portbdata),a  
7a4c			  
7a4c			  
7a4c			;ld b, 5  
7a4c			;.dec1:  
7a4c			;ld a, 0  
7a4c			;out (portbdata),a  
7a4c			;call delay1s  
7a4c			  
7a4c			;ld a, 32  
7a4c			;out (portbdata),a  
7a4c			;call delay1s  
7a4c			;call delay1s  
7a4c			;call delay1s  
7a4c			;  
7a4c			;ld a, 64+32  
7a4c			;out (portbdata),a  
7a4c			;call delay1s  
7a4c			;;djnz .dec1  
7a4c			;  
7a4c			;jp .decadetest1  
7a4c			  
7a4c			  
7a4c			  
7a4c			  
7a4c			  
7a4c			  
7a4c			  
7a4c			  
7a4c			  
7a4c			  
7a4c				; scan keyboard matrix and generate raw scan map  
7a4c cd df 7a			call matrix  
7a4f			  
7a4f				; reuse c bit 0 left modifer button - ie shift  
7a4f			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7a4f				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7a4f			  
7a4f 0e 00			ld c, 0  
7a51			  
7a51				; TODO set flags for modifer key presses   
7a51				; TODO do a search for modifer key...  
7a51			  
7a51				;ld hl,keyscan_table_row4  
7a51 21 e7 fe			ld hl,keyscan_table_row2  
7a54			  
7a54 7e				ld a, (hl)  
7a55 fe 23			cp '#'  
7a57 20 07			jr nz, .nextmodcheck  
7a59 cb c1			set 0, c  
7a5b 21 b9 79			ld hl, .matrix_to_shift  
7a5e 18 21			jr .dokeymap  
7a60				; TODO for now igonre  
7a60			.nextmodcheck:  
7a60 21 dc fe			ld hl,keyscan_table_row3  
7a63			  
7a63 7e				ld a, (hl)  
7a64 fe 23			cp '#'  
7a66 20 07			jr nz, .nextmodcheck2  
7a68 cb c9			set 1, c   
7a6a 21 f0 79			ld hl, .matrix_to_symbolshift  
7a6d 18 12			jr .dokeymap  
7a6f			.nextmodcheck2:  
7a6f 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
7a72			  
7a72 7e				ld a, (hl)  
7a73 fe 23			cp '#'  
7a75 20 07			jr nz, .donemodcheck  
7a77 cb c9			set 1, c   
7a79 21 b9 79			ld hl, .matrix_to_shift  
7a7c 18 03			jr .dokeymap  
7a7e			  
7a7e				; no modifer found so just map to normal keys  
7a7e				; get mtoc map matrix to respective keys  
7a7e			;	ld hl, .matrix_to_char  
7a7e			;	ld hl, .matrix_to_char  
7a7e			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a7e			;	ld a, KEY_SHIFT  
7a7e			;	call findchar  
7a7e			;  
7a7e			;	; got offset to key modifer in b  
7a7e			;  
7a7e			;	ld hl,keyscan_table_row5  
7a7e			;  
7a7e			;	ld a,b  
7a7e			;	call addatohl  
7a7e			;	ld a,(hl)  
7a7e			;  
7a7e			;	cp '#'  
7a7e			;	jr nz, .nextmodcheck  
7a7e			;	set 0, c  
7a7e			;	ld hl, .matrix_to_char  
7a7e			;	jr .dokeymap  
7a7e			;	; TODO for now igonre  
7a7e			;.nextmodcheck:  
7a7e			;	ld hl, .matrix_to_symbolshift  
7a7e			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a7e			;	ld a, KEY_SYMBOLSHIFT  
7a7e			;	call findchar  
7a7e			;  
7a7e			;  
7a7e			;	; got offset to key modifer in b  
7a7e			;  
7a7e			;	ld hl,keyscan_table_row5  
7a7e			;  
7a7e			;	ld a,b  
7a7e			;	call addatohl  
7a7e			;	ld a,(hl)  
7a7e			;  
7a7e			;	cp '#'  
7a7e			;	jr nz, .donemodcheck  
7a7e			;	set 1, c   
7a7e			;	ld hl, .matrix_to_symbolshift  
7a7e			;	jr .dokeymap  
7a7e			  
7a7e			  
7a7e			  
7a7e			.donemodcheck:  
7a7e				; no modifer found so just map to normal keys  
7a7e				; get mtoc map matrix to respective keys  
7a7e 21 82 79			ld hl, .matrix_to_char  
7a81			  
7a81			.dokeymap:  
7a81				;ld (key_fa), c   
7a81 cd 9a 7a			call .mapkeys  
7a84			  
7a84			  
7a84			if DEBUG_KEY  
7a84			  
7a84			; Display text on first line  
7a84			            LD   A, kLCD_Line1  
7a84			            CALL fLCD_Pos       ;Position cursor to location in A  
7a84			            LD   DE, keyscan_table_row1  
7a84			            ;LD   DE, MsgHello  
7a84			            CALL fLCD_Str       ;Display string pointed to by DE  
7a84			  
7a84			; Display text on second line  
7a84			            LD   A, kLCD_Line2  
7a84			            CALL fLCD_Pos       ;Position cursor to location in A  
7a84			            LD   DE, keyscan_table_row2  
7a84			            CALL fLCD_Str       ;Display string pointed to by DE  
7a84			            LD   A, kLCD_Line3  
7a84			            CALL fLCD_Pos       ;Position cursor to location in A  
7a84			            LD   DE, keyscan_table_row3  
7a84			            CALL fLCD_Str       ;Display string pointed to by DE  
7a84			            LD   A, kLCD_Line4  
7a84			            CALL fLCD_Pos       ;Position cursor to location in A  
7a84			            LD   DE, keyscan_table_row4  
7a84			            CALL fLCD_Str       ;Display string pointed to by DE  
7a84			            LD   A, kLCD_Line1+10  
7a84			            CALL fLCD_Pos       ;Position cursor to location in A  
7a84			            LD   DE, keyscan_table_row5  
7a84			            CALL fLCD_Str       ;Display string pointed to by DE  
7a84			  
7a84				;call delay250ms  
7a84			endif  
7a84			;	jp testkey  
7a84			  
7a84			; get first char reported  
7a84			  
7a84 21 c6 fe			ld hl,keyscan_table_row5  
7a87			  
7a87				;ld b, 46   ; 30 keys to remap + 8 nulls   
7a87 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a89			.findkey:  
7a89 7e				ld a,(hl)  
7a8a fe 00			cp 0  
7a8c 28 04			jr z, .nextkey  
7a8e fe 7e			cp KEY_MATRIX_NO_PRESS  
7a90 20 06			jr nz, .foundkey  
7a92			.nextkey:  
7a92 23				inc hl  
7a93 10 f4			djnz .findkey  
7a95 3e 00			ld a,0  
7a97 c9				ret  
7a98			.foundkey:  
7a98 7e				ld a,(hl)  
7a99 c9				ret  
7a9a				  
7a9a			  
7a9a			; convert the raw key map given hl for destination key  
7a9a			.mapkeys:  
7a9a 11 c6 fe			ld de,keyscan_table_row5  
7a9d			  
7a9d 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a9f			.remap:  
7a9f 1a				ld a,(de)  
7aa0 fe 23			cp '#'  
7aa2 20 02			jr nz, .remapnext  
7aa4				;CALLMONITOR  
7aa4 7e				ld a,(hl)  
7aa5 12				ld (de),a  
7aa6			  
7aa6			  
7aa6			  
7aa6			.remapnext:  
7aa6 23				inc hl  
7aa7 13				inc de  
7aa8 10 f5			djnz .remap  
7aaa				  
7aaa c9				ret  
7aab			  
7aab			  
7aab			  
7aab			.mtocold2:  
7aab			  
7aab			;	; flag if key D is held down and remove from reporting  
7aab			;	ld bc, .key_map_fd    
7aab			;	ld hl, keyscan_table  
7aab			;	ld de, key_fd  
7aab			;	call .key_shift_hold  
7aab			;	cp 255  
7aab			;	jr z, .cinmap  
7aab			;	; flag if key C is held down and remove from reporting  
7aab			;	ld bc, .key_map_fc    
7aab			;	ld hl, keyscan_table+key_cols  
7aab			;	ld de, key_fc  
7aab			;	call .key_shift_hold  
7aab			;	cp 255  
7aab			;	jr z, .cinmap  
7aab			;	; flag if key B is held down and remove from reporting  
7aab			;	ld bc, .key_map_fb    
7aab			;	ld hl, keyscan_table+(key_cols*2)  
7aab			;	ld de, key_fb  
7aab			;	call .key_shift_hold  
7aab			;	cp 255  
7aab			;	jr z, .cinmap  
7aab			;	; flag if key A is held down and remove from reporting  
7aab			;	ld bc, .key_map_fa    
7aab			;	ld hl, keyscan_table+(key_cols*3)  
7aab			;	ld de, key_fa  
7aab			;	call .key_shift_hold  
7aab			;	cp 255  
7aab			;	jr z, .cinmap  
7aab			  
7aab 11 82 79			ld de, .matrix_to_char  
7aae			  
7aae			  
7aae			.cinmap1:   
7aae				if DEBUG_KEY  
7aae			            LD   A, kLCD_Line4  
7aae			            CALL fLCD_Pos       ;Position cursor to location in A  
7aae					push de  
7aae			            LD   DE, keyscan_table  
7aae			            CALL fLCD_Str       ;Display string pointed to by DE  
7aae					pop de  
7aae				endif  
7aae			  
7aae				; scan key matrix table for any held key  
7aae			  
7aae				; de holds either the default matrix or one selected above  
7aae			  
7aae 21 93 fe			ld hl, keyscan_table  
7ab1 06 32			ld b,key_cols*key_rows  
7ab3			  
7ab3 7e			.cin11:	ld a,(hl)  
7ab4 fe 23			cp '#'  
7ab6 28 08			jr z, .cinhit1  
7ab8 23				inc hl  
7ab9 13				inc de  
7aba 05				dec b  
7abb 20 f6			jr nz, .cin11  
7abd				; no key found held  
7abd 3e 00			ld a,0  
7abf c9				ret  
7ac0 d5			.cinhit1: push de  
7ac1 e1				pop hl  
7ac2 7e				ld a,(hl)  
7ac3 c9				ret  
7ac4			  
7ac4			; flag a control key is held   
7ac4			; hl is key pin, de is flag indicator  
7ac4			  
7ac4			.key_shift_hold1:  
7ac4 c5				push bc  
7ac5 3e 01			ld a, 1  
7ac7 32 be fb			ld (cursor_shape),a  
7aca 06 00			ld b, 0  
7acc 7e				ld a, (hl)  
7acd fe 2e			cp '.'  
7acf 28 0a			jr z, .key_shift11  
7ad1 06 ff			ld b, 255  
7ad3 3e 2b			ld a, '+'    ; hide key from later scans  
7ad5 77				ld (hl),a  
7ad6 3e 02			ld a, 2  
7ad8 32 be fb			ld (cursor_shape),a  
7adb			.key_shift11:  
7adb				; write flag indicator  
7adb 78				ld a,b  
7adc 12				ld (de),a  
7add			  
7add d1				pop de    ; de now holds the key map ptr  
7ade c9				ret  
7adf			  
7adf				  
7adf			  
7adf			; scans keyboard matrix and flags key press in memory array	  
7adf				  
7adf			matrix:  
7adf				;call matrix  
7adf				; TODO optimise the code....  
7adf			  
7adf			  
7adf			;ld hl, keyscan_table_row1  
7adf			;ld de, keyscan_table_row1+1  
7adf			;ld bc,46  
7adf			;ld a,KEY_MATRIX_NO_PRESS  
7adf			;ldir  
7adf			  
7adf			  
7adf			  
7adf			; reset counter  
7adf 3e 80		ld a, 128  
7ae1 d3 c1		out (portbdata),a  
7ae3			  
7ae3 06 0a		ld b, 10  
7ae5 0e 00		ld c, 0       ; current clock toggle  
7ae7			  
7ae7			.colscan:  
7ae7			  
7ae7			; set current column  
7ae7			; disable clock enable and set clock low  
7ae7			  
7ae7			;ld a, 0  
7ae7			;out (portbdata),a  
7ae7			  
7ae7			; For each column scan for switches  
7ae7			  
7ae7 c5			push bc  
7ae8 21 89 fe		ld hl, keyscan_scancol  
7aeb cd f4 7b		call .rowscan  
7aee c1			pop bc  
7aef			  
7aef			  
7aef			; get back current column  
7aef			  
7aef			; translate the row scan  
7aef			  
7aef			;   
7aef			; row 1  
7aef			  
7aef 78			ld a,b  
7af0			  
7af0 21 fc fe		LD   hl, keyscan_table_row1+10  
7af3			  
7af3 cd e1 0f		call subafromhl  
7af6			;call addatohl  
7af6			  
7af6 11 89 fe		ld de, keyscan_scancol  
7af9			  
7af9 1a			ld a,(de)  
7afa 77			ld (hl),a  
7afb			  
7afb			  
7afb			  
7afb			  
7afb			; row 2  
7afb			  
7afb 78			ld a,b  
7afc			  
7afc 21 f1 fe		LD   hl, keyscan_table_row2+10  
7aff			  
7aff			;call addatohl  
7aff cd e1 0f		call subafromhl  
7b02			  
7b02			  
7b02 11 8a fe		ld de, keyscan_scancol+1  
7b05			  
7b05 1a			ld a,(de)  
7b06 77			ld (hl),a  
7b07			  
7b07			  
7b07			; row 3  
7b07			  
7b07 78			ld a,b  
7b08			  
7b08 21 e6 fe		LD   hl, keyscan_table_row3+10  
7b0b			  
7b0b			;call addatohl  
7b0b cd e1 0f		call subafromhl  
7b0e			  
7b0e 11 8b fe		ld de, keyscan_scancol+2  
7b11			  
7b11 1a			ld a,(de)  
7b12 77			ld (hl),a  
7b13			  
7b13			  
7b13			  
7b13			; row 4  
7b13			  
7b13 78			ld a,b  
7b14			  
7b14 21 db fe		LD   hl, keyscan_table_row4+10  
7b17			  
7b17			;call addatohl  
7b17 cd e1 0f		call subafromhl  
7b1a			  
7b1a 11 8c fe		ld de, keyscan_scancol+3  
7b1d			  
7b1d 1a			ld a,(de)  
7b1e 77			ld (hl),a  
7b1f			  
7b1f			; row 5  
7b1f			  
7b1f 78			ld a,b  
7b20			  
7b20 21 d0 fe		LD   hl, keyscan_table_row5+10  
7b23			  
7b23			;call addatohl  
7b23 cd e1 0f		call subafromhl  
7b26			  
7b26 11 8d fe		ld de, keyscan_scancol+4  
7b29			  
7b29 1a			ld a,(de)  
7b2a 77			ld (hl),a  
7b2b			  
7b2b			; handshake next column  
7b2b			  
7b2b			  
7b2b 3e 40		ld a, 64  
7b2d d3 c1		out (portbdata),a  
7b2f			  
7b2f 3e 00		ld a, 0  
7b31 d3 c1		out (portbdata),a  
7b33			  
7b33			; toggle clk and move to next column  
7b33			;ld a, 64  
7b33			;cp c  
7b33			;  
7b33			;jr z, .coltoglow  
7b33			;ld c, a  
7b33			;jr .coltog  
7b33			;.coltoglow:  
7b33			;ld c, 0  
7b33			;.coltog:  
7b33			;ld a, c  
7b33			;out (portbdata),a  
7b33			  
7b33 10 b2		djnz .colscan  
7b35			  
7b35 3e 0a		ld a,10  
7b37 21 f2 fe		LD   hl, keyscan_table_row1  
7b3a cd cf 0f		call addatohl  
7b3d 3e 00		ld a, 0  
7b3f 77			ld (hl), a  
7b40			  
7b40			  
7b40 3e 0a		ld a,10  
7b42 21 e7 fe		LD   hl, keyscan_table_row2  
7b45 cd cf 0f		call addatohl  
7b48 3e 00		ld a, 0  
7b4a 77			ld (hl), a  
7b4b			  
7b4b 3e 0a		ld a,10  
7b4d 21 dc fe		LD   hl, keyscan_table_row3  
7b50 cd cf 0f		call addatohl  
7b53 3e 00		ld a, 0  
7b55 77			ld (hl), a  
7b56			  
7b56 3e 0a		ld a,10  
7b58 21 d1 fe		LD   hl, keyscan_table_row4  
7b5b cd cf 0f		call addatohl  
7b5e 3e 00		ld a, 0  
7b60 77			ld (hl), a  
7b61			  
7b61 3e 0a		ld a,10  
7b63 21 c6 fe		LD   hl, keyscan_table_row5  
7b66 cd cf 0f		call addatohl  
7b69 3e 00		ld a, 0  
7b6b 77			ld (hl), a  
7b6c			  
7b6c			if DEBUG_KEY_MATRIX  
7b6c			  
7b6c			; Display text on first line  
7b6c			            LD   A, kLCD_Line1  
7b6c			            CALL fLCD_Pos       ;Position cursor to location in A  
7b6c			            LD   DE, keyscan_table_row1  
7b6c			            ;LD   DE, MsgHello  
7b6c			            CALL fLCD_Str       ;Display string pointed to by DE  
7b6c			  
7b6c			; Display text on second line  
7b6c			            LD   A, kLCD_Line2  
7b6c			            CALL fLCD_Pos       ;Position cursor to location in A  
7b6c			            LD   DE, keyscan_table_row2  
7b6c			            CALL fLCD_Str       ;Display string pointed to by DE  
7b6c			            LD   A, kLCD_Line3  
7b6c			            CALL fLCD_Pos       ;Position cursor to location in A  
7b6c			            LD   DE, keyscan_table_row3  
7b6c			            CALL fLCD_Str       ;Display string pointed to by DE  
7b6c			            LD   A, kLCD_Line4  
7b6c			            CALL fLCD_Pos       ;Position cursor to location in A  
7b6c			            LD   DE, keyscan_table_row4  
7b6c			            CALL fLCD_Str       ;Display string pointed to by DE  
7b6c			            LD   A, kLCD_Line4+10  
7b6c			            CALL fLCD_Pos       ;Position cursor to location in A  
7b6c			            LD   DE, keyscan_table_row5  
7b6c			            CALL fLCD_Str       ;Display string pointed to by DE  
7b6c			  
7b6c			;call delay250ms  
7b6c				jp matrix  
7b6c			endif  
7b6c c9			ret  
7b6d			  
7b6d			; using decade counter....  
7b6d			  
7b6d			  
7b6d			; TODO reset decade counter to start of scan  
7b6d			  
7b6d			; reset 15  
7b6d			; clock 14  
7b6d			; ce 13  
7b6d			  
7b6d			; 1 - q5  
7b6d			; 2 - q1  
7b6d			; 3 - q0  
7b6d			; 4 - q2  
7b6d			; 5 - q6  
7b6d			; 6 - q7  
7b6d			; 7 - q3  
7b6d			; 8 - vss  
7b6d			; 9 - q8  
7b6d			; 10 - q4  
7b6d			; 11 - q9  
7b6d			; 12 - cout  
7b6d			; 16 - vdd  
7b6d			  
7b6d			; clock      ce       reset     output  
7b6d			; 0          x        0         n  
7b6d			; x          1        0         n  
7b6d			; x          x        1         q0  
7b6d			; rising     0        0         n+1  
7b6d			; falling    x        0         n  
7b6d			; x          rising   0         n  
7b6d			; 1          falling  0         x+1  
7b6d			;  
7b6d			; x = dont care, if n < 5 carry = 1 otherwise 0  
7b6d			  
7b6d			;   
7b6d			; reset   
7b6d			; 13=0, 14=0, 15=1 .. 15=0  
7b6d			;  
7b6d			; handshake line  
7b6d			; 14=1.... read line 14=0  
7b6d			  
7b6d			  
7b6d			  
7b6d			  
7b6d			  
7b6d			; TODO hand shake clock for next column scan  
7b6d			; TODO detect each row  
7b6d			  
7b6d			  
7b6d			  
7b6d			  
7b6d			; reset 128  
7b6d			; clock 64  
7b6d			; ce 32  
7b6d			  
7b6d			  
7b6d			.cyclestart:  
7b6d			  
7b6d			; reset counter  
7b6d 3e 80		ld a, 128  
7b6f d3 c1		out (portbdata),a  
7b71			  
7b71			; loop leds  
7b71 06 0a		ld b,10  
7b73			  
7b73			.cycle1:  
7b73 c5			push bc  
7b74 3e 00		ld a, 0  
7b76 d3 c1		out (portbdata),a  
7b78 cd d2 0c		call delay250ms  
7b7b			  
7b7b 3e 40		ld a, 64  
7b7d d3 c1		out (portbdata),a  
7b7f cd d2 0c		call delay250ms  
7b82			  
7b82 3e 00		ld a, 0  
7b84 d3 c1		out (portbdata),a  
7b86 cd d2 0c		call delay250ms  
7b89			  
7b89 c1			pop bc  
7b8a 10 e7		djnz .cycle1  
7b8c			  
7b8c			  
7b8c 18 df		jr .cyclestart  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			; map matrix key held to char on face of key  
7b8e			  
7b8e			;.mtocold:  
7b8e			;  
7b8e			;  
7b8e			;; reset counter  
7b8e			;ld a, 128  
7b8e			;out (portbdata),a  
7b8e			;  
7b8e			;  
7b8e			;; scan keyboard row 1  
7b8e			;ld a, 0  
7b8e			;out (portbdata),a  
7b8e			;;ld a, 64  
7b8e			;;out (portbdata),a  
7b8e			;  
7b8e			;  
7b8e			;	ld a, 128  
7b8e			;	ld hl, keyscan_table  
7b8e			;	call .rowscan  
7b8e			;  
7b8e			;;ld a, 0  
7b8e			;;out (portbdata),a  
7b8e			;ld a, 64  
7b8e			;out (portbdata),a  
7b8e			;  
7b8e			;	ld a, 64  
7b8e			;	ld hl, keyscan_table+key_cols  
7b8e			;	call .rowscan  
7b8e			;  
7b8e			;ld a, 0  
7b8e			;out (portbdata),a  
7b8e			;;ld a, 64  
7b8e			;;out (portbdata),a  
7b8e			;	ld a, 32  
7b8e			;	ld hl, keyscan_table+(key_cols*2)  
7b8e			;	call .rowscan  
7b8e			;  
7b8e			;  
7b8e			;;ld a, 0  
7b8e			;;out (portbdata),a  
7b8e			;ld a, 64  
7b8e			;out (portbdata),a  
7b8e			;  
7b8e			;	ld a, 16  
7b8e			;	ld hl, keyscan_table+(key_cols*3)  
7b8e			;	call .rowscan  
7b8e			;  
7b8e			;  
7b8e			;	; flag if key D is held down and remove from reporting  
7b8e			;	ld bc, .key_map_fd    
7b8e			;	ld hl, keyscan_table  
7b8e			;	ld de, key_fd  
7b8e			;	call .key_shift_hold  
7b8e			;	cp 255  
7b8e			;	jr z, .cinmap  
7b8e			;	; flag if key C is held down and remove from reporting  
7b8e			;	ld bc, .key_map_fc    
7b8e			;	ld hl, keyscan_table+key_cols  
7b8e			;	ld de, key_fc  
7b8e			;	call .key_shift_hold  
7b8e			;	cp 255  
7b8e			;	jr z, .cinmap  
7b8e			;	; flag if key B is held down and remove from reporting  
7b8e			;	ld bc, .key_map_fb    
7b8e			;	ld hl, keyscan_table+(key_cols*2)  
7b8e			;	ld de, key_fb  
7b8e			;	call .key_shift_hold  
7b8e			;	cp 255  
7b8e			;	jr z, .cinmap  
7b8e			;	; flag if key A is held down and remove from reporting  
7b8e			;	ld bc, .key_map_fa    
7b8e			;	ld hl, keyscan_table+(key_cols*3)  
7b8e			;	ld de, key_fa  
7b8e			;	call .key_shift_hold  
7b8e			;	cp 255  
7b8e			;	jr z, .cinmap  
7b8e			;  
7b8e			;	ld de, .matrix_to_char  
7b8e			;  
7b8e			;  
7b8e			;.cinmap:   
7b8e			;	if DEBUG_KEY  
7b8e			;            LD   A, kLCD_Line4  
7b8e			;            CALL fLCD_Pos       ;Position cursor to location in A  
7b8e			;		push de  
7b8e			;            LD   DE, keyscan_table  
7b8e			;            CALL fLCD_Str       ;Display string pointed to by DE  
7b8e			;		pop de  
7b8e			;	endif  
7b8e			  
7b8e				; scan key matrix table for any held key  
7b8e			  
7b8e				; de holds either the default matrix or one selected above  
7b8e			  
7b8e			;	ld hl, keyscan_table  
7b8e			;	ld b,key_cols*key_rows  
7b8e			;  
7b8e			;.cin1:	ld a,(hl)  
7b8e			;	cp '#'  
7b8e			;	jr z, .cinhit  
7b8e			;	inc hl  
7b8e			;	inc de  
7b8e			;	dec b  
7b8e			;	jr nz, .cin1  
7b8e			;	; no key found held  
7b8e			;	ld a,0  
7b8e			;	ret  
7b8e			;.cinhit: push de  
7b8e			;	pop hl  
7b8e			;	ld a,(hl)  
7b8e			;	ret  
7b8e			  
7b8e			; flag a control key is held   
7b8e			; hl is key pin, de is flag indicator  
7b8e			  
7b8e			;.key_shift_hold:  
7b8e			;	push bc  
7b8e			;	ld a, 1  
7b8e			;	ld (cursor_shape),a  
7b8e			;	ld b, 0  
7b8e			;	ld a, (hl)  
7b8e			;	cp '.'  
7b8e			;	jr z, .key_shift1  
7b8e			;	ld b, 255  
7b8e			;	ld a, '+'    ; hide key from later scans  
7b8e			;	ld (hl),a  
7b8e			;	ld a, 2  
7b8e			;	ld (cursor_shape),a  
7b8e			;.key_shift1:  
7b8e			;	; write flag indicator  
7b8e			;	ld a,b  
7b8e			;	ld (de),a  
7b8e			;  
7b8e			;	pop de    ; de now holds the key map ptr  
7b8e			;	ret  
7b8e			  
7b8e				  
7b8e				  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			;	push hl  
7b8e			;	push de  
7b8e			;	push bc  
7b8e			;	call keyscan  
7b8e			;	; map key matrix to ascii value of key face  
7b8e			;  
7b8e			;	ld hl, key_face_map  
7b8e			;	ld de, keyscan_table  
7b8e			;  
7b8e			;	; get how many keys to look at  
7b8e			;	ld b, keyscan_table_len  
7b8e			;	  
7b8e			;  
7b8e			;	; at this stage fall out on first key hit  
7b8e			;	; TODO handle multiple key press  
7b8e			;  
7b8e			;map1:	ld a,(hl)  
7b8e			;	cp '#'  
7b8e			;	jr z, keyhit  
7b8e			;	inc hl  
7b8e			;	inc de  
7b8e			;	dec b  
7b8e			;	jr nz, map1  
7b8e			;nohit:	ld a, 0  
7b8e			;	jr keydone  
7b8e			;keyhit: push de  
7b8e			;	pop hl  
7b8e			;	ld a,(hl)  
7b8e			;keydone:  
7b8e			;	push bc  
7b8e			;	push de  
7b8e			; 	push hl  
7b8e			;	ret   
7b8e			;  
7b8e			  
7b8e			  
7b8e			  
7b8e			  
7b8e			; scan physical key matrix  
7b8e			  
7b8e			  
7b8e			;keyscan:  
7b8e			;  
7b8e			;; for each key_row use keyscanr bit mask for out  
7b8e			;; then read in for keyscanc bitmask  
7b8e			;; save result of row scan to keyscantable  
7b8e			;  
7b8e			;; scan keyboard row 1  
7b8e			;  
7b8e			;	ld b, key_rows  
7b8e			;	ld hl, key_scanr  
7b8e			;	ld de, keyscan_table  
7b8e			;  
7b8e			;rowloop:  
7b8e			;  
7b8e			;	ld a,(hl)		; out bit mask to energise keyboard row  
7b8e			;	call rowscan  
7b8e			;	inc hl  
7b8e			;	dec b  
7b8e			;	jr nz, rowloop  
7b8e			;  
7b8e			;	ret  
7b8e			;  
7b8e			;  
7b8e			;; pass a out bitmask, b row number  
7b8e			;arowscan:   
7b8e			;	push bc  
7b8e			;  
7b8e			;	ld d, b  
7b8e			;  
7b8e			;	; calculate buffer location for this row  
7b8e			;  
7b8e			;	ld hl, keyscan_table	  
7b8e			;kbufr:  ld e, key_cols  
7b8e			;kbufc:	inc hl  
7b8e			;	dec e  
7b8e			;	jr nz, kbufc  
7b8e			;	dec d  
7b8e			;	jr nz, kbufr  
7b8e			;  
7b8e			;	; energise row and read columns  
7b8e			;  
7b8e			;	out (portbdata),a  
7b8e			;	in a,(portbdata)  
7b8e			;	ld c,a  
7b8e			;  
7b8e			;  
7b8e			;	; save buffer loc  
7b8e			;  
7b8e			;	ld (keybufptr), hl  
7b8e			;  
7b8e			;	ld hl, key_scanc  
7b8e			;	ld d, key_cols  
7b8e			;  
7b8e			;	; for each column check each bit mask  
7b8e			;  
7b8e			;colloop:  
7b8e			;	  
7b8e			;  
7b8e			;	; reset flags for the row   
7b8e			;  
7b8e			;	ld b,'.'  
7b8e			;	and (hl)  
7b8e			;	jr z, maskskip  
7b8e			;	ld b,'#'  
7b8e			;maskskip:  
7b8e			;	; save  key state  
7b8e			;	push hl  
7b8e			;	ld hl, (keybufptr)  
7b8e			;	ld (hl), b  
7b8e			;	inc hl  
7b8e			;	ld (keybufptr), hl  
7b8e			;  
7b8e			;	; move to next bit mask  
7b8e			;	pop hl  
7b8e			;	inc hl  
7b8e			;  
7b8e			;	dec d  
7b8e			;	jr nz, colloop  
7b8e			;  
7b8e			;	ret  
7b8e			;  
7b8e			;  
7b8e			;;  
7b8e			; lcd functions  
7b8e			;  
7b8e			;  
7b8e			  
7b8e			;if DEBUG_KEY_MATRIX  
7b8e			  
7b8e			; test function to display hardware view of matrix state  
7b8e			  
7b8e			matrixold:  
7b8e			  
7b8e			  
7b8e			  
7b8e			; reset counter  
7b8e 3e 80		ld a, 128  
7b90 d3 c1		out (portbdata),a  
7b92			; scan keyboard row 1  
7b92 3e 00		ld a, 0  
7b94 d3 c1		out (portbdata),a  
7b96			;ld a, 64  
7b96			;out (portbdata),a  
7b96 3e 80			ld a, 128  
7b98 21 f2 fe			ld hl, keyscan_table_row1  
7b9b cd f4 7b			call .rowscan  
7b9e			  
7b9e			;ld a, 0  
7b9e			;out (portbdata),a  
7b9e 3e 40		ld a, 64  
7ba0 d3 c1		out (portbdata),a  
7ba2 3e 40			ld a, 64  
7ba4 21 e7 fe			ld hl, keyscan_table_row2  
7ba7 cd f4 7b			call .rowscan  
7baa			  
7baa 3e 00		ld a, 0  
7bac d3 c1		out (portbdata),a  
7bae			;ld a, 64  
7bae			;out (portbdata),a  
7bae 3e 20			ld a, 32  
7bb0 21 dc fe			ld hl, keyscan_table_row3  
7bb3 cd f4 7b			call .rowscan  
7bb6			  
7bb6			;ld a, 0  
7bb6			;out (portbdata),a  
7bb6 3e 40		ld a, 64  
7bb8 d3 c1		out (portbdata),a  
7bba 3e 10			ld a, 16  
7bbc 21 d1 fe			ld hl, keyscan_table_row4  
7bbf cd f4 7b			call .rowscan  
7bc2			  
7bc2			; Display text on first line  
7bc2 3e 00		            LD   A, kLCD_Line1  
7bc4 cd fc 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7bc7 11 f2 fe		            LD   DE, keyscan_table_row1  
7bca			            ;LD   DE, MsgHello  
7bca cd 1e 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7bcd			  
7bcd			; Display text on second line  
7bcd 3e 28		            LD   A, kLCD_Line2  
7bcf cd fc 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7bd2 11 e7 fe		            LD   DE, keyscan_table_row2  
7bd5 cd 1e 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7bd8 3e 50		            LD   A, kLCD_Line3  
7bda cd fc 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7bdd 11 dc fe		            LD   DE, keyscan_table_row3  
7be0 cd 1e 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7be3 3e 78		            LD   A, kLCD_Line4  
7be5 cd fc 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7be8 11 d1 fe		            LD   DE, keyscan_table_row4  
7beb cd 1e 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7bee			  
7bee cd d2 0c			call delay250ms  
7bf1 c3 df 7a			jp matrix  
7bf4			  
7bf4			; pass de as row display flags  
7bf4			.rowscan:   
7bf4			;	out (portbdata),a  
7bf4 db c1			in a,(portbdata)  
7bf6 4f				ld c,a  
7bf7				; reset flags for the row   
7bf7 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bf9 e6 01			and 1  
7bfb 28 02			jr z, .p1on  
7bfd 06 23			ld b,'#'  
7bff			.p1on:  
7bff 70				ld (hl), b  
7c00 23				inc hl  
7c01			  
7c01 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c03 79				ld a,c  
7c04 e6 02			and 2  
7c06			;	bit 0,a  
7c06 28 02			jr z, .p2on  
7c08 06 23			ld b,'#'  
7c0a			.p2on:  
7c0a 70				ld (hl), b  
7c0b 23				inc hl  
7c0c			;  
7c0c 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c0e 79				ld a,c  
7c0f e6 04			and 4  
7c11			;;	bit 0,a  
7c11 28 02			jr z, .p3on  
7c13 06 23			ld b,'#'  
7c15			.p3on:  
7c15 70				ld (hl), b  
7c16 23				inc hl  
7c17			;;  
7c17 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c19			;;	bit 0,a  
7c19 79				ld a,c  
7c1a e6 08			and 8  
7c1c 28 02			jr z, .p4on  
7c1e 06 23			ld b,'#'  
7c20			.p4on:  
7c20 70				ld (hl), b  
7c21 23				inc hl  
7c22			  
7c22 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c24			;;	bit 0,a  
7c24 79				ld a,c  
7c25 e6 10			and 16  
7c27 28 02			jr z, .p5on  
7c29 06 23			ld b,'#'  
7c2b			.p5on:  
7c2b 70				ld (hl), b  
7c2c 23				inc hl  
7c2d			; zero term  
7c2d 06 00			ld b,0  
7c2f 70				ld (hl), b  
7c30			  
7c30 c9			.rscandone: ret  
7c31			  
7c31			;addatohl:  
7c31			;  
7c31			 ;add   a, l    ; A = A+L  
7c31			  ;  ld    l, a    ; L = A+L  
7c31			   ; adc   a, h    ; A = A+L+H+carry  
7c31			   ; sub   l       ; A = H+carry  
7c31			   ; ld    h, a    ; H = H+carry  
7c31			  
7c31			;ret  
7c31			; eof  
# End of file firmware_key_5x10.asm
7c31			;include "firmware_key_4x10.asm" 
7c31			 
7c31			heap_size:    equ heap_end - heap_start 
7c31			;eof 
# End of file os_mega.asm
7c31
