# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 7d 1a			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-09 10:11' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b			 
011b			 
011b			 
011b			;        nop  
011b			;        nop 
011b			;;	org 05h		; null out bdos call 
011b			; 
011b			;        nop  
011b			;        nop  
011b			;        nop 
011b			;;	org 08h 
011b			;;; 
011b			;;	jp cin		; rst 8 - char in 
011b			;;; 
011b			; 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;	org 010h 
011b			;; 
011b			;	jp cout		; rest 010h  - char out 
011b			;; 
011b			;	org 01bh   
011b			; 
011b			;	;jp  		; rst 01bh   - write string to display 
011b			;	jp str_at_display 
011b			; 
011b			; 
011b			;	org 020h 
011b			; 
011b			;	; jp		 ; rst 020h - read char at screen location 
011b			; 
011b			;	org 028h 
011b			 
011b				; jp		 ; rst 028h  - storage i/o 
011b			 
011b			; 	org 030h 
011b			;	jp break_point_state 
011b			  
011b			; $30  
011b			; org 038h 
011b			; $38 
011b			 
011b			; TODO any more important entry points to add to jump table for easier coding use? 
011b			 
011b			if BASE_KEV = 1  
011b			 
011b				; need to be at $66 for nmi support 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255 
011b				jp nmi 
011b			endif 
011b			 
011b			include "firmware.asm" 
011b			  
011b			; main constants (used here and in firmware)  
011b			  
011b			; TODO have page 0 of storage as bios  
011b			  
011b			Device_A: equ 0h  
011b			Device_B: equ 040h          ; Sound  
011b			  
011b			if BASE_KEV  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_SC114  
011b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			; TODO fixup for CPM  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			Device_D: equ 0c0h             ; Keyboard and LCD  
011b			  
011b			; Odd specific debug points for testing hardware dev  
011b			  
011b			DEBUG_SOUND: equ 0       
011b			DEBUG_STK_FAULT: equ 0  
011b			DEBUG_INPUT: equ 0     ; Debug input entry code  
011b			DEBUG_INPUTV2: equ 1     ; Debug input entry code  
011b			DEBUG_KEYCINWAIT: equ 0  
011b			DEBUG_KEYCIN: equ 0  
011b			DEBUG_KEY: equ 0  
011b			DEBUG_KEY_MATRIX: equ 0  
011b			DEBUG_STORECF: equ 0  
011b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011b			DEBUG_SPI: equ 0    ; low level spi tests  
011b			  
011b			; Enable many break points  
011b			  
011b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011b			DEBUG_FORTH_JP: equ 0    ; 4  
011b			DEBUG_FORTH_MALLOC: equ 0  
011b			DEBUG_FORTH_MALLOC_INT: equ 0  
011b			DEBUG_FORTH_DOT: equ 1  
011b			DEBUG_FORTH_DOT_WAIT: equ 0  
011b			DEBUG_FORTH_MATHS: equ 0  
011b			DEBUG_FORTH_TOK: equ 0    ; 4  
011b			DEBUG_FORTH_PARSE: equ 0    ; 3  
011b			DEBUG_FORTH: equ 0  ;2  
011b			DEBUG_FORTH_WORDS: equ 1   ; 1  
011b			DEBUG_FORTH_PUSH: equ 1   ; 1  
011b			DEBUG_FORTH_UWORD: equ 1   ; 1  
011b			  
011b			; Enable key point breakpoints  
011b			  
011b			DEBUG_FORTH_DOT_KEY: equ 0  
011b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011b			  
011b			; Debug stack imbalances  
011b			  
011b			ON: equ 1  
011b			OFF: equ 0  
011b			  
011b			DEBUG_STACK_IMB: equ 0  
011b			STACK_IMB_STORE: equ 20  
011b			  
011b			; House keeping and protections  
011b			  
011b			DEBUG_FORTH_STACK_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011b			FORTH_ENABLE_FREE: equ 0  
011b			FORTH_ENABLE_MALLOCFREE: equ 1  
011b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011b			FORTH_ENABLE_FLOATMATH: equ 0  
011b			  
011b			  
011b			CALLMONITOR: macro  
011b			;	call break_point_state  
011b			; now use the break point debug vector  
011b				call debug_vector  
011b				endm  
011b			  
011b			MALLOC_1: equ 1        ; from dk88   
011b			MALLOC_2: equ 0           ; broke  
011b			MALLOC_3: equ 0           ; really broke  
011b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011b			  
011b			if BASE_KEV   
011b			;stacksize: equ 256  
011b			; each stack entry is three bytes (type + word)  
011b			stacksize: equ 3*150  
011b			  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 512  
011b			endif  
011b			if BASE_SC114  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			;if STORAGE_SE == 0  
011b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011b			;endif  
011b			  
011b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011b			  
011b			STORE_0_AUTORUN: equ $20  
011b			  
011b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011b			  
011b			STORE_0_AUTOFILE: equ $21  
011b			STORE_0_BANKRUN: equ $23  
011b			STORE_0_FILERUN: equ $24  
011b			  
011b			; Block 0 offsets for settings  
011b			  
011b			; if set then skip prompt for start up and accept all  
011b			  
011b			STORE_0_QUICKSTART: equ $25  
011b			  
011b			; Blocks where directory table is held  
011b			  
011b			; Reducing the number of entries increases the max file size  
011b			  
011b			;STORE_DIR_START: equ 1  
011b			;STORE_DIR_END: equ 33  
011b			  
011b			; Blocks from where file data is stored  
011b			  
011b			;STORE_DATA_START: equ STORE_DIR_END + 1  
011b			  
011b			; Block indicators (<32 are data files)  
011b			  
011b			;STORE_BLOCK_CFG: equ $8f       ; config block  
011b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011b			;STORE_BLOCK_FREE: equ $85       ; data block free  
011b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011b			  
011b			  
011b			  
011b			; Directory entry flags  
011b			  
011b			;STORE_DIR_FREE: equ 0  
011b			;STORE_DIR_FILE:  equ 1  
011b			  
011b			; Structure offsets to directory entries  
011b			;STORE_DE_FLAG: equ 0  
011b			;STORE_DE_MAXEXT: equ 1  
011b			;STORE_DE_FILENAME: equ 2  
011b			  
011b			; Structure offsets to block 0  
011b			  
011b			;STORE_BK0_ISFOR: equ 1  
011b			;STORE_BK0_LABEL: equ 3  
011b			  
011b			; memory allocation   
011b			  
011b			chk_stund: equ tos+2           ; underflow check word  
011b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011b			  
011b			; keyscan table needs rows x cols buffer  
011b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011b			  
011b			keyscan_table_row1: equ chk_stovr -key_cols-1  
011b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011b			keyscan_scancol: equ keyscan_table-key_cols  
011b			;keyscan_table_len: equ key_rows*key_cols  
011b			;keybufptr: equ keyscan_table - 2  
011b			;keysymbol: equ keybufptr - 1  
011b			key_held: equ keyscan_scancol-1	; currently held  
011b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011b			key_fa: equ key_repeat_ct -1 ;  
011b			key_fb: equ key_fa -1 ;  
011b			key_fc: equ key_fb -1 ;  
011b			key_fd: equ key_fc -1 ;  
011b			key_face_held: equ key_fd - 1   
011b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011b			  
011b			hardware_config: equ key_face_held - 10  
011b			  
011b			; hardware config switches  
011b			; TODO add bitmasks on includes for hardware  
011b			; high byte for expansion ids  
011b			;     0000 0000  no card inserted  
011b			;     0000 0001  storage card inserted  
011b			;     0000 0010  spi sd card active  
011b			  
011b			;       
011b			; low byte:  
011b			;     0000 0001   4x4 keypad  
011b			;     0000 0010   full keyboard  
011b			;     0000 0011   spi/ext keyboard  
011b			;     0000 0100   20x4 lcd  
011b			;     0000 1000   40x4 lcd  
011b			;     0000 1100   spi/ext display  
011b			;     0001 0000   ide interface available  
011b			  
011b			hardware_word: equ hardware_config - 2  
011b			  
011b			; debug marker - optional display of debug point on the debug screens  
011b			  
011b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011b			  
011b			debug_mark: equ debug_vector - 4  
011b			  
011b			; input_str vars  
011b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011b			input_size: equ input_start -1  ; number of chars  
011b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011b			input_len: equ input_cur_onoff - 5 ; length of current input  
011b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011b			  
011b			; cursor blink rate  
011b			CUR_BLINK_RATE: equ $09  
011b			;CUR_BLINK_RATE: equ 15  
011b			  
011b			key_actual_pressed: equ input_cursor - 1   
011b			key_symbol: equ key_actual_pressed - 1   
011b			key_shift: equ key_symbol - 1   
011b			  
011b			; Display allocation  
011b			  
011b			;display_rows: equ 4     ; move out to mini and mega files  
011b			;display_cols: equ 20  
011b			  
011b			display_fb_len: equ display_rows*display_cols  
011b			  
011b			; primary frame buffer     
011b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011b			; working frame buffers  
011b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011b			display_fb3: equ  display_fb1-display_fb_len - 1  
011b			display_fb2: equ  display_fb3-display_fb_len - 1  
011b			;  
011b			; pointer to active frame buffer  
011b			display_fb_active: equ display_fb2 - 2  
011b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011b			display_write_tmp: equ display_lcde1e2 - 2  
011b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011b			  
011b			;  
011b			  
011b			;; can load into de directory  
011b			cursor_col: equ display_active-1  
011b			cursor_row: equ cursor_col-1  
011b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011b			  
011b			; maths vars  
011b			  
011b			LFSRSeed: equ cursor_shape -20   
011b			randData: equ LFSRSeed - 2  
011b			xrandc: equ randData - 2  
011b			stackstore: equ xrandc - 2  
011b			seed1: equ  stackstore -2   
011b			seed2: equ seed1 - 2  
011b			  
011b			; cf storage vars  
011b			  
011b			iErrorNum:  equ seed2-1         ;Error number  
011b			iErrorReg:  equ iErrorNum -1              ;Error register  
011b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011b			  
011b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011b			  
011b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011b			  
011b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011b			store_tmpid: equ store_tmp3 - 1		; page temp id  
011b			store_tmpext: equ store_tmpid - 1		; file extent temp  
011b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011b			;  
011b			; spi vars  
011b			  
011b			  
011b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011b			spi_device_id: equ spi_device - 1    ; human readable bank number  
011b			  
011b			;;;;; forth cli params  
011b			  
011b			; TODO use a different frame buffer for forth???  
011b			  
011b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011b			  
011b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011b			  
011b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011b			  
011b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011b			  
011b			; os/forth token vars  
011b			  
011b			os_last_cmd: equ os_var_array-255  
011b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011b			os_current_i: equ os_cli_cmd-2  
011b			os_cur_ptr: equ os_current_i-2  
011b			os_word_scratch: equ os_cur_ptr-30  
011b			os_tok_len: equ os_word_scratch - 2  
011b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011b			os_tok_malloc: equ os_tok_ptr - 2  
011b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011b			execscratch: equ os_input-255        ; exec cmd eval buffer  
011b			scratch: equ execscratch-255  
011b			  
011b			os_stack_1: equ scratch - 3       ; stack holding area 1  
011b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011b			  
011b			  
011b			; temp locations for new word processing to save on adding more   
011b			  
011b			os_new_malloc: equ os_stack_4-2  
011b			os_new_parse_len: equ os_new_malloc - 2  
011b			os_new_word_len: equ os_new_parse_len - 2  
011b			os_new_work_ptr: equ os_new_word_len - 2  
011b			os_new_src_ptr: equ os_new_work_ptr - 2  
011b			os_new_exec: equ os_new_src_ptr - 2  
011b			os_new_exec_ptr: equ os_new_exec - 2  
011b			  
011b			; resume memory alloocations....  
011b			  
011b			;os_view_disable: equ os_new_exec_ptr - 1  
011b			os_view_af: equ os_new_exec_ptr - 2  
011b			os_view_hl: equ os_view_af -2  
011b			os_view_de: equ os_view_hl - 2  
011b			os_view_bc: equ os_view_de - 2  
011b			  
011b			; stack checksum word  
011b			if DEBUG_STACK_IMB  
011b				curframe: equ  os_view_de - 5  
011b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			else  
011b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			endif  
011b			  
011b			; with data stack could see memory filled with junk. need some memory management   
011b			; malloc and free entry points added  
011b			  
011b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			;heap_end: equ free_list-1  ; Starting address of heap  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			heap_end: equ chk_word-1  ; Starting address of heap  
011b			  
011b			  
011b			;if BASE_KEV   
011b			;heap_start: equ 0800eh  ; Starting address of heap  
011b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;heap_start: equ baseram+15  ; Starting address of heap  
011b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;endif  
011b			  
011b			  
011b			;;;;  
011b			  
011b			  
011b			; change below to point to last memory alloc above  
011b			topusermem:  equ   heap_start  
011b			  
011b			;if BASE_KEV   
011b			;baseusermem: equ 08000h  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;;aseusermem:     equ    12  
011b			;baseusermem:     equ    prompt  
011b			;;baseusermem:     equ    endofcode  
011b			;endif  
011b			  
011b			  
011b			; **********************************************************************  
011b			; **  Constants  
011b			; **********************************************************************  
011b			  
011b			; Constants used by this code module  
011b			kDataReg:   EQU Device_D           ;PIO port A data register  
011b			kContReg:   EQU Device_D+2           ;PIO port A control register  
011b			  
011b			  
011b			portbdata:  equ Device_D+1    ; port b data  
011b			portbctl:   equ Device_D+3    ; port b control  
011b			  
011b			  
011b			;KEY_SHIFT:   equ 5  
011b			;KEY_SYMBOLSHIFT:  equ 6  
011b			  
011b			KEY_SHIFTLOCK: equ 4  
011b			  
011b			  
011b			KEY_UP: equ 5  
011b			KEY_NEXTWORD: equ 6  
011b			KEY_PREVWORD: equ 7  
011b			KEY_BS: equ 8  
011b			KEY_TAB:  equ 9  
011b			KEY_DOWN: equ 10  
011b			KEY_LEFT: equ 11  
011b			KEY_RIGHT: equ 12  
011b			KEY_CR:   equ 13  
011b			KEY_HOME: equ 14  
011b			KEY_END: equ 15  
011b			  
011b			KEY_F1: equ 16  
011b			KEY_F2: equ 17  
011b			KEY_F3: equ 18  
011b			KEY_F4: equ 19  
011b			  
011b			KEY_F5: equ 20  
011b			KEY_F6: equ 21  
011b			KEY_F7: equ 22  
011b			KEY_F8: equ 23  
011b			  
011b			KEY_F9: equ 24  
011b			KEY_F10: equ 25  
011b			KEY_F11: equ 26  
011b			KEY_F12: equ 27  
011b			  
011b			;if DEBUG_KEY  
011b			;	KEY_MATRIX_NO_PRESS: equ '.'  
011b			;	KEY_SHIFT:   equ '.'  
011b			;	KEY_SYMBOLSHIFT:  equ '.'  
011b			;else  
011b				KEY_SHIFT:   equ '~'  
011b				KEY_SYMBOLSHIFT:  equ '~'  
011b				KEY_MATRIX_NO_PRESS: equ '~'  
011b			;endi  
011b			  
011b			  
011b			  
011b			  
011b			; Macro to make adding debug marks easier  
011b			  
011b			DMARK: macro str  
011b				push af  
011b				ld a, (.dmark)  
011b				ld (debug_mark),a  
011b				ld a, (.dmark+1)  
011b				ld (debug_mark+1),a  
011b				ld a, (.dmark+2)  
011b				ld (debug_mark+2),a  
011b				jr .pastdmark  
011b			.dmark: db str  
011b			.pastdmark: pop af  
011b			  
011b			endm  
011b			  
011b			  
011b			; macro to detect for stack imbalances  
011b			  
011b			include "stackimbal.asm"  
011b			; Macro and code to detect stock imbalances 
011b			 
011b			SPPUSH: equ 0 
011b			 
011b			; Add a stack frame which can be checked before return 
011b			 
011b			STACKFRAME: macro onoff frame1 frame2 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b						exx 
011b			 
011b						ld de, frame1 
011b						ld a, d 
011b						ld hl, curframe 
011b						call hexout 
011b						ld a, e 
011b						ld hl, curframe+2 
011b						call hexout 
011b			  
011b						ld hl, frame1 
011b						push hl 
011b						ld hl, frame2 
011b						push hl 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			endm 
011b			 
011b			STACKFRAMECHK: macro onoff frame1 frame2 
011b			 
011b					 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						exx 
011b						; check stack frame SP 
011b			 
011b						ld hl, frame2 
011b						pop de   ; frame2 
011b			 
011b						call cmp16 
011b						jr nz, .spnosame 
011b						 
011b			 
011b						ld hl, frame1 
011b						pop de   ; frame1 
011b			 
011b						call cmp16 
011b						jr z, .spfrsame 
011b			 
011b						.spnosame: call showsperror 
011b			 
011b						.spfrsame: nop 
011b			 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			 
011b			 
011b			endm 
011b			 
011b			 
011b			; for a sub routine, wrap SP collection and comparisons 
011b			 
011b			; Usage: 
011b			; 
011b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011b			 
011b			SAVESP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b			 
011b						ld (store_sp+(storeword*4)), sp 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			CHECKSP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b			 
011b						; save SP after last save 
011b				 
011b						ld (store_sp+(storeword*4)+2), sp 
011b			 
011b						push hl 
011b						ld hl, store_sp+(storeword*4) 
011b						call check_stack_sp  
011b						pop hl 
011b			 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			if DEBUG_STACK_IMB 
011b			 
011b			check_stack_sp: 
011b					push de 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					push de 
011b			 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					pop hl 
011b			 
011b			 
011b					; check to see if the same 
011b			 
011b					call cmp16 
011b					jr z, .spsame 
011b			 
011b					; not same 
011b			 
011b					call showsperror 
011b			.spsame: 
011b			 
011b					pop de 
011b			 
011b					ret 
011b			 
011b			.sperr:  db "Stack imbalance",0 
011b			 
011b			 
011b			showsperror: 
011b			 
011b			 
011b				push hl 
011b				push af 
011b				push de 
011b				call clear_display 
011b				ld de, .sperr 
011b				ld a,0 
011b			;	ld de,os_word_scratch 
011b				call str_at_display 
011b				ld a, display_row_1+17 
011b				ld de, debug_mark 
011b				call str_at_display 
011b				ld a, 0 
011b				ld (curframe+4),a 
011b				ld hl, curframe 
011b				ld de, os_word_scratch 
011b				ld a, display_row_4 
011b				call str_at_display 
011b				call update_display 
011b				;call break_point_state 
011b				call cin_wait 
011b			 
011b			;	ld a, ' ' 
011b			;	ld (os_view_disable), a 
011b				call bp_on 
011b				pop de	 
011b				pop af 
011b				pop hl 
011b				CALLMONITOR 
011b				ret 
011b			 
011b			endif 
011b			 
011b			 
011b			 
011b			; eof 
# End of file stackimbal.asm
011b			  
011b			;TODO macro to calc col and row offset into screen  
011b			  
011b			  
011b			  
011b			hardware_init:  
011b			  
011b				  
011b			  
011b					;ld a, 0  
011b					;ld (hardware_diag), a  
011b			  
011b					; clear all the buffers  
011b			  
011b 21 10 ed				ld hl, display_fb1  
011e 22 cc eb				ld (display_fb_active), hl  
0121			  
0121 cd b9 0b				call clear_display  
0124			  
0124 21 ce eb				ld hl, display_fb2  
0127 22 cc eb				ld (display_fb_active), hl  
012a			  
012a cd b9 0b				call clear_display  
012d			  
012d					; init primary frame buffer area  
012d 21 b1 ed				ld hl, display_fb0  
0130 22 cc eb				ld (display_fb_active), hl  
0133			  
0133 cd b9 0b				call clear_display  
0136			  
0136			  
0136 cd 4f 67				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0139			  
0139 cd 3d 68			call key_init  
013c cd 9e 01			call storage_init  
013f			  
013f				; setup malloc functions  
013f			  
013f				if MALLOC_1  
013f cd ad 14				call  heap_init  
0142				endif  
0142				if MALLOC_4  
0142					call  heap_init  
0142				endif  
0142			  
0142				; init sound hardware if present  
0142			  
0142				if SOUND_ENABLE  
0142					call sound_init  
0142				endif  
0142			  
0142				; lcd test sequence  
0142					  
0142 cd dc 0b			call update_display  
0145 cd f1 0a			call delay1s  
0148 3e 2b			ld a,'+'  
014a cd be 0b			call fill_display  
014d cd dc 0b			call update_display  
0150 cd f1 0a			call delay1s  
0153 3e 2a			ld a,'*'  
0155 cd be 0b			call fill_display  
0158 cd dc 0b			call update_display  
015b cd f1 0a			call delay1s  
015e 3e 2d			ld a,'-'  
0160 cd be 0b			call fill_display  
0163 cd dc 0b			call update_display  
0166 cd f1 0a			call delay1s  
0169			  
0169			; boot splash screen  
0169			if display_cols == 20	  
0169			        ld a, display_row_1    
0169			else  
0169 3e 0a		        ld a, display_row_1 +10   
016b			endif  
016b 11 db 19			ld de, prom_bootmsg  
016e cd cc 0b			call str_at_display  
0171 cd dc 0b			call update_display  
0174			  
0174			  
0174 cd f1 0a			call delay1s  
0177 cd f1 0a			call delay1s  
017a			if display_cols == 20	  
017a			            LD   A, display_row_3+2  
017a			else  
017a 3e 5c		            LD   A, display_row_3+12  
017c			endif  
017c 11 f0 19			ld de, prom_bootmsg1  
017f cd cc 0b			call str_at_display  
0182 cd dc 0b			call update_display  
0185 cd f1 0a			call delay1s  
0188 cd f1 0a			call delay1s  
018b			  
018b			;	ld a, display_row_4+3  
018b			;	ld de, bootmsg2  
018b			;	call str_at_display  
018b			;	call update_display  
018b			;	call delay1s  
018b			;	call delay1s  
018b			  
018b			; debug mark setup  
018b			  
018b 3e 5f		ld a, '_'  
018d 32 6b ee		ld (debug_mark),a  
0190 32 6c ee		ld (debug_mark+1),a  
0193 32 6d ee		ld (debug_mark+2),a  
0196 3e 00		ld a,0  
0198 32 6e ee		ld (debug_mark+3),a  
019b			  
019b c9					ret  
019c			  
019c			  
019c			;bootmsg2:	db "Firmware v0.1",0  
019c			  
019c			; a 4x20 lcd  
019c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019c			  
019c			;if display_cols == 20  
019c			;	include "firmware_lcd_4x20.asm"  
019c			;endif  
019c			  
019c			;if display_cols == 40  
019c			;	include "firmware_lcd_4x40.asm"  
019c			;endif  
019c			  
019c			;  
019c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019c			; TODO abstract the bit bang video out interface for dual display  
019c			; TODO wire video out to tx pin on rc2014 bus  
019c			  
019c			; must supply cin, and cin_wait for low level hardware abstraction   
019c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019c			; test scancode  
019c			  
019c			;;;;;  
019c			;;;  
019c			; Moved out to mini and maxi versions  
019c			;  
019c			; include "firmware_key_4x4.asm"  
019c			; using existing 4 wire x 4 resistor array for input  
019c			;include "firmware_key_4x10.asm"  
019c			; need to mod the board for 5 rows due to resistor array  
019c			;include "firmware_key_5x10.asm"  
019c			  
019c			; storage hardware interface  
019c			  
019c			; use microchip serial eeprom for storage  
019c			  
019c			  
019c			if STORAGE_SE  
019c				include "firmware_spi.asm"  
019c				include "firmware_seeprom.asm"  
019c			else  
019c			   ; create some stubs for the labels  
019c c9			se_readbyte: ret  
019d c9			se_writebyte: ret  
019e c9			storage_init: ret  
019f			  
019f			endif  
019f			  
019f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
019f			;include "firmware_cf.asm"  
019f			  
019f			; load up high level storage hardward abstractions  
019f			include "firmware_storage.asm"  
019f			 
019f			; persisent storage hardware abstraction layer  
019f			 
019f			 
019f			 
019f			; Block 0 on storage is a config state 
019f			 
019f			 
019f			 
019f			; TODO add read phy block and write phy block functions 
019f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
019f			 
019f			; Abstraction layer  
019f			 
019f			; Logocial block size is same size as physical size - using tape concept 
019f			 
019f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
019f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
019f			 
019f			 
019f			 
019f			; Filesystem layout (Logical layout) 
019f			; 
019f			; Block 0 - Bank config  
019f			; 
019f			;      Byte - 0 file id counter 
019f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
019f			;      Byte - 3-20 zero terminated bank label 
019f			; 
019f			; Block 1 > File storage 
019f			; 
019f			;      Byte 0 file id    - block 0 file details 
019f			;      Byte 1 block id - block 0 is file  
019f			;            Byte 2-15 - File name 
019f			; 
019f			;       - to end of block data 
019f			; 
019f			 
019f			; Get ID for the file named in pointer held HL 
019f			; Returns ID in HL = 255 if no file found 
019f			 
019f			storage_getid: 
019f			 
019f 22 73 ea			ld (store_tmp1), hl 
01a2			 
01a2				if DEBUG_STORESE 
01a2					DMARK "SGI" 
01a2 f5				push af  
01a3 3a b7 01			ld a, (.dmark)  
01a6 32 6b ee			ld (debug_mark),a  
01a9 3a b8 01			ld a, (.dmark+1)  
01ac 32 6c ee			ld (debug_mark+1),a  
01af 3a b9 01			ld a, (.dmark+2)  
01b2 32 6d ee			ld (debug_mark+2),a  
01b5 18 03			jr .pastdmark  
01b7 ..			.dmark: db "SGI"  
01ba f1			.pastdmark: pop af  
01bb			endm  
# End of macro DMARK
01bb					CALLMONITOR 
01bb cd 6f ee			call debug_vector  
01be				endm  
# End of macro CALLMONITOR
01be				endif 
01be				; get block 0 and set counter for number of files to scan 
01be			 
01be cd 29 03			call storage_get_block_0 
01c1			 
01c1 3a 7a ea			ld a, (store_page) 
01c4 47				ld b, a 
01c5			 
01c5				; get extent 0 of each file id 
01c5			 
01c5				if DEBUG_STORESE 
01c5					DMARK "SGc" 
01c5 f5				push af  
01c6 3a da 01			ld a, (.dmark)  
01c9 32 6b ee			ld (debug_mark),a  
01cc 3a db 01			ld a, (.dmark+1)  
01cf 32 6c ee			ld (debug_mark+1),a  
01d2 3a dc 01			ld a, (.dmark+2)  
01d5 32 6d ee			ld (debug_mark+2),a  
01d8 18 03			jr .pastdmark  
01da ..			.dmark: db "SGc"  
01dd f1			.pastdmark: pop af  
01de			endm  
# End of macro DMARK
01de					CALLMONITOR 
01de cd 6f ee			call debug_vector  
01e1				endm  
# End of macro CALLMONITOR
01e1				endif 
01e1 60			.getloop:	ld h, b 
01e2 2e 00				ld l, 0 
01e4 c5					push bc 
01e5			 
01e5 11 7a ea				ld de, store_page 
01e8				if DEBUG_STORESE 
01e8					DMARK "SGr" 
01e8 f5				push af  
01e9 3a fd 01			ld a, (.dmark)  
01ec 32 6b ee			ld (debug_mark),a  
01ef 3a fe 01			ld a, (.dmark+1)  
01f2 32 6c ee			ld (debug_mark+1),a  
01f5 3a ff 01			ld a, (.dmark+2)  
01f8 32 6d ee			ld (debug_mark+2),a  
01fb 18 03			jr .pastdmark  
01fd ..			.dmark: db "SGr"  
0200 f1			.pastdmark: pop af  
0201			endm  
# End of macro DMARK
0201					CALLMONITOR 
0201 cd 6f ee			call debug_vector  
0204				endm  
# End of macro CALLMONITOR
0204				endif 
0204 cd d1 07				call storage_read 
0207 cd 0f 0e				call ishlzero 
020a 28 2d				jr z, .gap 
020c					 
020c					; have a file name read. Is it one we want. 
020c			 
020c 2a 73 ea				ld hl, (store_tmp1) 
020f 11 7d ea				ld de, store_page+3   ; file name 
0212			 
0212				if DEBUG_STORESE 
0212					DMARK "SGc" 
0212 f5				push af  
0213 3a 27 02			ld a, (.dmark)  
0216 32 6b ee			ld (debug_mark),a  
0219 3a 28 02			ld a, (.dmark+1)  
021c 32 6c ee			ld (debug_mark+1),a  
021f 3a 29 02			ld a, (.dmark+2)  
0222 32 6d ee			ld (debug_mark+2),a  
0225 18 03			jr .pastdmark  
0227 ..			.dmark: db "SGc"  
022a f1			.pastdmark: pop af  
022b			endm  
# End of macro DMARK
022b					CALLMONITOR 
022b cd 6f ee			call debug_vector  
022e				endm  
# End of macro CALLMONITOR
022e				endif 
022e cd 94 14				call strcmp 
0231 20 06				jr nz, .gap   ; not this one 
0233			 
0233 c1				        pop bc 
0234			 
0234 26 00				ld h, 0 
0236 68					ld l, b 
0237 18 22				jr .getdone 
0239						 
0239			 
0239			 
0239			 
0239			.gap: 
0239				if DEBUG_STORESE 
0239					DMARK "SGg" 
0239 f5				push af  
023a 3a 4e 02			ld a, (.dmark)  
023d 32 6b ee			ld (debug_mark),a  
0240 3a 4f 02			ld a, (.dmark+1)  
0243 32 6c ee			ld (debug_mark+1),a  
0246 3a 50 02			ld a, (.dmark+2)  
0249 32 6d ee			ld (debug_mark+2),a  
024c 18 03			jr .pastdmark  
024e ..			.dmark: db "SGg"  
0251 f1			.pastdmark: pop af  
0252			endm  
# End of macro DMARK
0252					CALLMONITOR 
0252 cd 6f ee			call debug_vector  
0255				endm  
# End of macro CALLMONITOR
0255				endif 
0255			 
0255 c1					pop bc 
0256 10 89				djnz .getloop 
0258 21 ff 00				ld hl, 255 
025b			.getdone: 
025b			 
025b				if DEBUG_STORESE 
025b					DMARK "SGe" 
025b f5				push af  
025c 3a 70 02			ld a, (.dmark)  
025f 32 6b ee			ld (debug_mark),a  
0262 3a 71 02			ld a, (.dmark+1)  
0265 32 6c ee			ld (debug_mark+1),a  
0268 3a 72 02			ld a, (.dmark+2)  
026b 32 6d ee			ld (debug_mark+2),a  
026e 18 03			jr .pastdmark  
0270 ..			.dmark: db "SGe"  
0273 f1			.pastdmark: pop af  
0274			endm  
# End of macro DMARK
0274					CALLMONITOR 
0274 cd 6f ee			call debug_vector  
0277				endm  
# End of macro CALLMONITOR
0277				endif 
0277			 
0277 c9				ret 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			; Read Block 
0278			; ---------- 
0278			; 
0278			; With current bank 
0278			;  
0278			; Get block number to read 
0278			; Load physical blocks starting at start block into buffer 
0278			 
0278			; de points to buffer to use 
0278			; hl holds logical block number  
0278			 
0278			storage_read_block: 
0278			 
0278				; TODO bank selection 
0278			 
0278				; for each of the physical blocks read it into the buffer 
0278 06 40			ld b, STORE_BLOCK_PHY 
027a			 
027a				if DEBUG_STORESE 
027a d5					push de 
027b				endif 
027b				 
027b			.rl1:    
027b			 
027b				; read physical block at hl into de 
027b			        ; increment hl and de to next read position on exit 
027b			 
027b e5				push hl 
027c d5				push de	 
027d c5				push bc 
027e			;	if DEBUG_STORESE 
027e			;		push af 
027e			;		ld a, 'R' 
027e			;		ld (debug_mark),a 
027e			;		pop af 
027e			;		CALLMONITOR 
027e			;	endif 
027e cd 9c 01			call se_readbyte 
0281			;	if DEBUG_STORESE 
0281			;		ld a,(spi_portbyte) 
0281			;		ld l, a 
0281			;		push af 
0281			;		ld a, '1' 
0281			;		ld (debug_mark),a 
0281			;		pop af 
0281			;		CALLMONITOR 
0281			;	endif 
0281 c1				pop bc 
0282 d1				pop de 
0283 e1				pop hl 
0284 12				ld (de),a 
0285 23				inc hl 
0286 13				inc de 
0287			 
0287			;	if DEBUG_STORESE 
0287			;		push af 
0287			;		ld a, 'r' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287			;		CALLMONITOR 
0287			;	endif 
0287			 
0287 10 f2			djnz .rl1 
0289			 
0289				if DEBUG_STORESE 
0289					DMARK "SRB" 
0289 f5				push af  
028a 3a 9e 02			ld a, (.dmark)  
028d 32 6b ee			ld (debug_mark),a  
0290 3a 9f 02			ld a, (.dmark+1)  
0293 32 6c ee			ld (debug_mark+1),a  
0296 3a a0 02			ld a, (.dmark+2)  
0299 32 6d ee			ld (debug_mark+2),a  
029c 18 03			jr .pastdmark  
029e ..			.dmark: db "SRB"  
02a1 f1			.pastdmark: pop af  
02a2			endm  
# End of macro DMARK
02a2 d1					pop de 
02a3			; 
02a3			;		push af 
02a3			;		ld a, 'R' 
02a3			;		ld (debug_mark),a 
02a3			;		pop af 
02a3					CALLMONITOR 
02a3 cd 6f ee			call debug_vector  
02a6				endm  
# End of macro CALLMONITOR
02a6				endif 
02a6 c9				ret	 
02a7				 
02a7			 
02a7			; File Size 
02a7			; --------- 
02a7			; 
02a7			;   hl file id 
02a7			; 
02a7			;  returns in hl the number of blocks 
02a7			 
02a7			storage_file_size: 
02a7 5d				ld e, l 
02a8 16 00			ld d, 0 
02aa 21 40 00			ld hl, STORE_BLOCK_PHY 
02ad					if DEBUG_FORTH_WORDS 
02ad						DMARK "SIZ" 
02ad f5				push af  
02ae 3a c2 02			ld a, (.dmark)  
02b1 32 6b ee			ld (debug_mark),a  
02b4 3a c3 02			ld a, (.dmark+1)  
02b7 32 6c ee			ld (debug_mark+1),a  
02ba 3a c4 02			ld a, (.dmark+2)  
02bd 32 6d ee			ld (debug_mark+2),a  
02c0 18 03			jr .pastdmark  
02c2 ..			.dmark: db "SIZ"  
02c5 f1			.pastdmark: pop af  
02c6			endm  
# End of macro DMARK
02c6						CALLMONITOR 
02c6 cd 6f ee			call debug_vector  
02c9				endm  
# End of macro CALLMONITOR
02c9					endif 
02c9 cd ab 05			call storage_findnextid 
02cc			 
02cc cd 0f 0e			call ishlzero 
02cf			;	ld a, l 
02cf			;	add h 
02cf			;	cp 0 
02cf c8				ret z			; block not found so EOF 
02d0			 
02d0 11 7a ea			ld de, store_page 
02d3 cd 78 02			call storage_read_block 
02d6			 
02d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02d9 6f				ld l, a 
02da 26 00			ld h, 0 
02dc c9			 	ret 
02dd			 
02dd			 
02dd			; Write Block 
02dd			; ----------- 
02dd			; 
02dd			; With current bank 
02dd			;  
02dd			; Get block number to write 
02dd			; Write physical blocks starting at start block from buffer 
02dd			  
02dd			storage_write_block: 
02dd				; TODO bank selection 
02dd			 
02dd				; for each of the physical blocks read it into the buffer 
02dd 06 40			ld b, STORE_BLOCK_PHY 
02df			 
02df				if DEBUG_STORESE 
02df					DMARK "SWB" 
02df f5				push af  
02e0 3a f4 02			ld a, (.dmark)  
02e3 32 6b ee			ld (debug_mark),a  
02e6 3a f5 02			ld a, (.dmark+1)  
02e9 32 6c ee			ld (debug_mark+1),a  
02ec 3a f6 02			ld a, (.dmark+2)  
02ef 32 6d ee			ld (debug_mark+2),a  
02f2 18 03			jr .pastdmark  
02f4 ..			.dmark: db "SWB"  
02f7 f1			.pastdmark: pop af  
02f8			endm  
# End of macro DMARK
02f8			 
02f8					;push af 
02f8					;ld a, 'W' 
02f8					;ld (debug_mark),a 
02f8					;pop af 
02f8					CALLMONITOR 
02f8 cd 6f ee			call debug_vector  
02fb				endm  
# End of macro CALLMONITOR
02fb				endif 
02fb			 
02fb			; might not be working 
02fb			;	call se_writepage 
02fb			 
02fb			;	ret 
02fb			; 
02fb			 
02fb			 
02fb			 
02fb			.wl1:    
02fb			 
02fb				; read physical block at hl into de 
02fb			        ; increment hl and de to next read position on exit 
02fb			 
02fb e5				push hl 
02fc d5				push de	 
02fd c5				push bc 
02fe 1a				ld a,(de) 
02ff				;if DEBUG_STORESE 
02ff			;		push af 
02ff			;		ld a, 'W' 
02ff			;		ld (debug_mark),a 
02ff			;		pop af 
02ff			;		CALLMONITOR 
02ff			;	endif 
02ff cd 9d 01			call se_writebyte 
0302			;	call delay250ms 
0302 00				nop 
0303 00				nop 
0304 00				nop 
0305			;	if DEBUG_STORESE 
0305			;		push af 
0305			;		ld a, 'w' 
0305			;		ld (debug_mark),a 
0305			;		pop af 
0305			;		CALLMONITOR 
0305			;	endif 
0305 c1				pop bc 
0306 d1				pop de 
0307 e1				pop hl 
0308 23				inc hl 
0309 13				inc de 
030a			 
030a			 
030a 10 ef			djnz .wl1 
030c			 
030c				if DEBUG_STORESE 
030c					DMARK "SW2" 
030c f5				push af  
030d 3a 21 03			ld a, (.dmark)  
0310 32 6b ee			ld (debug_mark),a  
0313 3a 22 03			ld a, (.dmark+1)  
0316 32 6c ee			ld (debug_mark+1),a  
0319 3a 23 03			ld a, (.dmark+2)  
031c 32 6d ee			ld (debug_mark+2),a  
031f 18 03			jr .pastdmark  
0321 ..			.dmark: db "SW2"  
0324 f1			.pastdmark: pop af  
0325			endm  
# End of macro DMARK
0325			 
0325					;push af 
0325					;ld a, 'W' 
0325					;ld (debug_mark),a 
0325					;pop af 
0325					CALLMONITOR 
0325 cd 6f ee			call debug_vector  
0328				endm  
# End of macro CALLMONITOR
0328				endif 
0328 c9				ret	 
0329			 
0329			; Init bank 
0329			; --------- 
0329			; 
0329			; With current bank 
0329			; 
0329			; Setup block 0 config 
0329			;     Set 0 file id counter 
0329			;     Set formatted byte pattern 
0329			;     Zero out bank label 
0329			;      
0329			; For every logical block write 0-1 byte as null 
0329			 
0329			storage_get_block_0: 
0329			 
0329				; TODO check presence 
0329			 
0329				; get block 0 config 
0329			 
0329 21 00 00			ld hl, 0 
032c 11 7a ea			ld de, store_page 
032f cd 78 02			call storage_read_block 
0332			 
0332				if DEBUG_STORESE 
0332					DMARK "SB0" 
0332 f5				push af  
0333 3a 47 03			ld a, (.dmark)  
0336 32 6b ee			ld (debug_mark),a  
0339 3a 48 03			ld a, (.dmark+1)  
033c 32 6c ee			ld (debug_mark+1),a  
033f 3a 49 03			ld a, (.dmark+2)  
0342 32 6d ee			ld (debug_mark+2),a  
0345 18 03			jr .pastdmark  
0347 ..			.dmark: db "SB0"  
034a f1			.pastdmark: pop af  
034b			endm  
# End of macro DMARK
034b 11 7a ea				ld de, store_page 
034e			;		push af 
034e			;		ld a, 'i' 
034e			;		ld (debug_mark),a 
034e			;		pop af 
034e					CALLMONITOR 
034e cd 6f ee			call debug_vector  
0351				endm  
# End of macro CALLMONITOR
0351				endif 
0351			 
0351				; is this area formatted? 
0351			 
0351			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0351 2a 7b ea			ld hl, (store_page+1) 
0354 3e 80			ld a,0x80 
0356 bd				cp l 
0357 20 22			jr nz, .ininotformatted 
0359				; do a double check 
0359 3e 27			ld a, 0x27 
035b bc				cp h 
035c 20 1d			jr nz, .ininotformatted 
035e			 
035e				; formatted then 
035e			 
035e				if DEBUG_STORESE 
035e					DMARK "SB1" 
035e f5				push af  
035f 3a 73 03			ld a, (.dmark)  
0362 32 6b ee			ld (debug_mark),a  
0365 3a 74 03			ld a, (.dmark+1)  
0368 32 6c ee			ld (debug_mark+1),a  
036b 3a 75 03			ld a, (.dmark+2)  
036e 32 6d ee			ld (debug_mark+2),a  
0371 18 03			jr .pastdmark  
0373 ..			.dmark: db "SB1"  
0376 f1			.pastdmark: pop af  
0377			endm  
# End of macro DMARK
0377					;push af 
0377					;ld a, 'I' 
0377					;ld (debug_mark),a 
0377					;pop af 
0377					CALLMONITOR 
0377 cd 6f ee			call debug_vector  
037a				endm  
# End of macro CALLMONITOR
037a				endif 
037a c9				ret 
037b			 
037b			.ininotformatted: 
037b				; bank not formatted so poke various bits to make sure 
037b			 
037b				if DEBUG_STORESE 
037b					DMARK "SB2" 
037b f5				push af  
037c 3a 90 03			ld a, (.dmark)  
037f 32 6b ee			ld (debug_mark),a  
0382 3a 91 03			ld a, (.dmark+1)  
0385 32 6c ee			ld (debug_mark+1),a  
0388 3a 92 03			ld a, (.dmark+2)  
038b 32 6d ee			ld (debug_mark+2),a  
038e 18 03			jr .pastdmark  
0390 ..			.dmark: db "SB2"  
0393 f1			.pastdmark: pop af  
0394			endm  
# End of macro DMARK
0394					;push af 
0394					;ld a, 'f' 
0394					;ld (debug_mark),a 
0394					;pop af 
0394					CALLMONITOR 
0394 cd 6f ee			call debug_vector  
0397				endm  
# End of macro CALLMONITOR
0397				endif 
0397			 
0397 cd b4 0a			call storage_clear_page 
039a			 
039a 21 7a ea			ld hl, store_page 
039d 3e 00			ld a, 0 
039f				 
039f 77				ld (hl),a   ; reset file counter 
03a0			 
03a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a3 22 7b ea		 	ld (store_page+1), hl	 
03a6			 
03a6				; set default label 
03a6			 
03a6 21 42 04			ld hl, .defaultbanklabl 
03a9 11 7d ea		 	ld de, store_page+3 
03ac 01 0f 00			ld bc, 15 
03af ed b0			ldir 
03b1			 
03b1				; Append the current bank id 
03b1 21 86 ea			ld hl, store_page+3+9 
03b4 3a 5f ea			ld a, (spi_device_id) 
03b7 77				ld (hl), a 
03b8			 
03b8				; save default page 0 
03b8			 
03b8 21 00 00			ld hl, 0 
03bb 11 7a ea			ld de, store_page 
03be				if DEBUG_STORESE 
03be					DMARK "SB3" 
03be f5				push af  
03bf 3a d3 03			ld a, (.dmark)  
03c2 32 6b ee			ld (debug_mark),a  
03c5 3a d4 03			ld a, (.dmark+1)  
03c8 32 6c ee			ld (debug_mark+1),a  
03cb 3a d5 03			ld a, (.dmark+2)  
03ce 32 6d ee			ld (debug_mark+2),a  
03d1 18 03			jr .pastdmark  
03d3 ..			.dmark: db "SB3"  
03d6 f1			.pastdmark: pop af  
03d7			endm  
# End of macro DMARK
03d7			;		push af 
03d7			;		ld a, 'F' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7					CALLMONITOR 
03d7 cd 6f ee			call debug_vector  
03da				endm  
# End of macro CALLMONITOR
03da				endif 
03da cd dd 02			call storage_write_block 
03dd				if DEBUG_STORESE 
03dd					DMARK "SB4" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6b ee			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6c ee			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 6d ee			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SB4"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6			;		push af 
03f6			;		ld a, '>' 
03f6			;		ld (debug_mark),a 
03f6			;		pop af 
03f6					CALLMONITOR 
03f6 cd 6f ee			call debug_vector  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 00				nop 
03fa 00				nop 
03fb 00				nop 
03fc			 
03fc				; now set 0 in every page to mark as a free block 
03fc			 
03fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03fe 21 40 00			ld hl, STORE_BLOCK_PHY 
0401			 
0401 3e 00		.setmark1:   	ld a,0 
0403 e5					push hl 
0404 c5					push bc 
0405 cd 9d 01				call se_writebyte 
0408 3e 0a			ld a, 10 
040a cd d6 0a			call aDelayInMS 
040d 23				inc hl 
040e cd 9d 01				call se_writebyte 
0411 3e 0a			ld a, 10 
0413 cd d6 0a			call aDelayInMS 
0416 2b				dec hl 
0417 c1					pop bc 
0418 e1					pop hl 
0419 3e 40				ld a, STORE_BLOCK_PHY 
041b cd e6 0d				call addatohl 
041e 10 e1				djnz .setmark1 
0420			 
0420 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0422 3e 00		.setmark2:   	ld a,0 
0424 e5					push hl 
0425 c5					push bc 
0426 cd 9d 01				call se_writebyte 
0429 3e 0a			ld a, 10 
042b cd d6 0a			call aDelayInMS 
042e 23				inc hl 
042f cd 9d 01				call se_writebyte 
0432 3e 0a			ld a, 10 
0434 cd d6 0a			call aDelayInMS 
0437 2b				dec hl 
0438 c1					pop bc 
0439 e1					pop hl 
043a 3e 40				ld a, STORE_BLOCK_PHY 
043c cd e6 0d				call addatohl 
043f 10 e1				djnz .setmark2 
0441			 
0441					 
0441			 
0441			 
0441 c9				ret 
0442			 
0442			 
0442			 
0442			 
0442 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044d			 
044d			 
044d			 
044d			; Label Bank 
044d			; ---------- 
044d			; 
044d			; With current bank 
044d			; Read block 0 
044d			; Set label 
044d			; Write block 0 
044d			 
044d			; label str pointer in hl 
044d			 
044d			storage_label:     
044d			 
044d				if DEBUG_STORESE 
044d					DMARK "LBL" 
044d f5				push af  
044e 3a 62 04			ld a, (.dmark)  
0451 32 6b ee			ld (debug_mark),a  
0454 3a 63 04			ld a, (.dmark+1)  
0457 32 6c ee			ld (debug_mark+1),a  
045a 3a 64 04			ld a, (.dmark+2)  
045d 32 6d ee			ld (debug_mark+2),a  
0460 18 03			jr .pastdmark  
0462 ..			.dmark: db "LBL"  
0465 f1			.pastdmark: pop af  
0466			endm  
# End of macro DMARK
0466					CALLMONITOR 
0466 cd 6f ee			call debug_vector  
0469				endm  
# End of macro CALLMONITOR
0469				endif 
0469			 
0469 e5				push hl 
046a			 
046a cd 29 03			call storage_get_block_0 
046d			 
046d				; set default label 
046d			 
046d e1				pop hl 
046e			 
046e 11 7d ea		 	ld de, store_page+3 
0471 01 0f 00			ld bc, 15 
0474				if DEBUG_STORESE 
0474					DMARK "LB3" 
0474 f5				push af  
0475 3a 89 04			ld a, (.dmark)  
0478 32 6b ee			ld (debug_mark),a  
047b 3a 8a 04			ld a, (.dmark+1)  
047e 32 6c ee			ld (debug_mark+1),a  
0481 3a 8b 04			ld a, (.dmark+2)  
0484 32 6d ee			ld (debug_mark+2),a  
0487 18 03			jr .pastdmark  
0489 ..			.dmark: db "LB3"  
048c f1			.pastdmark: pop af  
048d			endm  
# End of macro DMARK
048d					CALLMONITOR 
048d cd 6f ee			call debug_vector  
0490				endm  
# End of macro CALLMONITOR
0490				endif 
0490 ed b0			ldir 
0492				; save default page 0 
0492			 
0492 21 00 00			ld hl, 0 
0495 11 7a ea			ld de, store_page 
0498				if DEBUG_STORESE 
0498					DMARK "LBW" 
0498 f5				push af  
0499 3a ad 04			ld a, (.dmark)  
049c 32 6b ee			ld (debug_mark),a  
049f 3a ae 04			ld a, (.dmark+1)  
04a2 32 6c ee			ld (debug_mark+1),a  
04a5 3a af 04			ld a, (.dmark+2)  
04a8 32 6d ee			ld (debug_mark+2),a  
04ab 18 03			jr .pastdmark  
04ad ..			.dmark: db "LBW"  
04b0 f1			.pastdmark: pop af  
04b1			endm  
# End of macro DMARK
04b1					CALLMONITOR 
04b1 cd 6f ee			call debug_vector  
04b4				endm  
# End of macro CALLMONITOR
04b4				endif 
04b4 cd dd 02			call storage_write_block 
04b7			 
04b7 c9				ret 
04b8			 
04b8			 
04b8			 
04b8			; Read Block 0 - Config 
04b8			; --------------------- 
04b8			; 
04b8			; With current bank 
04b8			; Call presence test 
04b8			;    If not present format/init bank  
04b8			; Read block 0  
04b8			;  
04b8			 
04b8			 
04b8			; Dir 
04b8			; --- 
04b8			; 
04b8			; With current bank 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block read byte 2 
04b8			;      if first block of file 
04b8			;         Display file name 
04b8			;         Display type flags for file 
04b8			;        
04b8			 
04b8			; moving to words as this requires stack control 
04b8			 
04b8			 
04b8			; Delete File 
04b8			; ----------- 
04b8			; 
04b8			; With current bank 
04b8			; 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block file id 
04b8			;      If first block of file and dont have file id 
04b8			;         if file to delete 
04b8			;         Save file id 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			;      If file id is one saved 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			 
04b8			 
04b8			.se_done: 
04b8 e1				pop hl 
04b9 c9				ret 
04ba			 
04ba			storage_erase: 
04ba			 
04ba				; hl contains the file id 
04ba			 
04ba 5d				ld e, l 
04bb 16 00			ld d, 0 
04bd 21 40 00			ld hl, STORE_BLOCK_PHY 
04c0					if DEBUG_FORTH_WORDS 
04c0						DMARK "ERA" 
04c0 f5				push af  
04c1 3a d5 04			ld a, (.dmark)  
04c4 32 6b ee			ld (debug_mark),a  
04c7 3a d6 04			ld a, (.dmark+1)  
04ca 32 6c ee			ld (debug_mark+1),a  
04cd 3a d7 04			ld a, (.dmark+2)  
04d0 32 6d ee			ld (debug_mark+2),a  
04d3 18 03			jr .pastdmark  
04d5 ..			.dmark: db "ERA"  
04d8 f1			.pastdmark: pop af  
04d9			endm  
# End of macro DMARK
04d9						CALLMONITOR 
04d9 cd 6f ee			call debug_vector  
04dc				endm  
# End of macro CALLMONITOR
04dc					endif 
04dc cd ab 05			call storage_findnextid 
04df cd 0f 0e			call ishlzero 
04e2 c8				ret z 
04e3			 
04e3 e5				push hl 
04e4			 
04e4				; TODO check file not found 
04e4			 
04e4 11 7a ea			ld de, store_page 
04e7 cd 78 02			call storage_read_block 
04ea			 
04ea cd 0f 0e			call ishlzero 
04ed ca b8 04			jp z,.se_done 
04f0			 
04f0					if DEBUG_FORTH_WORDS 
04f0						DMARK "ER1" 
04f0 f5				push af  
04f1 3a 05 05			ld a, (.dmark)  
04f4 32 6b ee			ld (debug_mark),a  
04f7 3a 06 05			ld a, (.dmark+1)  
04fa 32 6c ee			ld (debug_mark+1),a  
04fd 3a 07 05			ld a, (.dmark+2)  
0500 32 6d ee			ld (debug_mark+2),a  
0503 18 03			jr .pastdmark  
0505 ..			.dmark: db "ER1"  
0508 f1			.pastdmark: pop af  
0509			endm  
# End of macro DMARK
0509						CALLMONITOR 
0509 cd 6f ee			call debug_vector  
050c				endm  
# End of macro CALLMONITOR
050c					endif 
050c 3a 7a ea			ld a, (store_page)	; get file id 
050f 32 6e ea			ld (store_tmpid), a 
0512			 
0512 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0515 32 6d ea			ld (store_tmpext), a 
0518			 
0518				; wipe file header 
0518			 
0518 e1				pop hl 
0519 3e 00			ld a, 0 
051b 32 7a ea			ld (store_page), a 
051e 32 7b ea			ld (store_page+1),a 
0521 11 7a ea			ld de, store_page 
0524					if DEBUG_FORTH_WORDS 
0524						DMARK "ER2" 
0524 f5				push af  
0525 3a 39 05			ld a, (.dmark)  
0528 32 6b ee			ld (debug_mark),a  
052b 3a 3a 05			ld a, (.dmark+1)  
052e 32 6c ee			ld (debug_mark+1),a  
0531 3a 3b 05			ld a, (.dmark+2)  
0534 32 6d ee			ld (debug_mark+2),a  
0537 18 03			jr .pastdmark  
0539 ..			.dmark: db "ER2"  
053c f1			.pastdmark: pop af  
053d			endm  
# End of macro DMARK
053d						CALLMONITOR 
053d cd 6f ee			call debug_vector  
0540				endm  
# End of macro CALLMONITOR
0540					endif 
0540 cd dd 02			call storage_write_block 
0543			 
0543			 
0543				; wipe file extents 
0543			 
0543 3a 6d ea			ld a, (store_tmpext) 
0546 47				ld b, a 
0547			 
0547			.eraext:	  
0547 c5				push bc 
0548			 
0548 21 40 00			ld hl, STORE_BLOCK_PHY 
054b 3a 6e ea			ld a,(store_tmpid) 
054e 5f				ld e, a 
054f 50				ld d, b	 
0550					if DEBUG_FORTH_WORDS 
0550						DMARK "ER3" 
0550 f5				push af  
0551 3a 65 05			ld a, (.dmark)  
0554 32 6b ee			ld (debug_mark),a  
0557 3a 66 05			ld a, (.dmark+1)  
055a 32 6c ee			ld (debug_mark+1),a  
055d 3a 67 05			ld a, (.dmark+2)  
0560 32 6d ee			ld (debug_mark+2),a  
0563 18 03			jr .pastdmark  
0565 ..			.dmark: db "ER3"  
0568 f1			.pastdmark: pop af  
0569			endm  
# End of macro DMARK
0569						CALLMONITOR 
0569 cd 6f ee			call debug_vector  
056c				endm  
# End of macro CALLMONITOR
056c					endif 
056c cd ab 05			call storage_findnextid 
056f cd 0f 0e			call ishlzero 
0572 ca b8 04			jp z,.se_done 
0575			 
0575 e5				push hl 
0576 11 7a ea			ld de, store_page 
0579 cd 78 02			call storage_read_block 
057c			 
057c				; free block	 
057c			 
057c 3e 00			ld a, 0 
057e 32 7a ea			ld (store_page), a 
0581 32 7b ea			ld (store_page+1),a 
0584 11 7a ea			ld de, store_page 
0587 e1				pop hl 
0588					if DEBUG_FORTH_WORDS 
0588						DMARK "ER4" 
0588 f5				push af  
0589 3a 9d 05			ld a, (.dmark)  
058c 32 6b ee			ld (debug_mark),a  
058f 3a 9e 05			ld a, (.dmark+1)  
0592 32 6c ee			ld (debug_mark+1),a  
0595 3a 9f 05			ld a, (.dmark+2)  
0598 32 6d ee			ld (debug_mark+2),a  
059b 18 03			jr .pastdmark  
059d ..			.dmark: db "ER4"  
05a0 f1			.pastdmark: pop af  
05a1			endm  
# End of macro DMARK
05a1						CALLMONITOR 
05a1 cd 6f ee			call debug_vector  
05a4				endm  
# End of macro CALLMONITOR
05a4					endif 
05a4 cd dd 02			call storage_write_block 
05a7			 
05a7 c1				pop bc 
05a8 10 9d			djnz .eraext 
05aa			 
05aa c9				ret 
05ab			 
05ab			 
05ab			; Find Free Block 
05ab			; --------------- 
05ab			; 
05ab			; With current bank 
05ab			;  
05ab			; From given starting logical block 
05ab			;    Read block  
05ab			;    If no file id 
05ab			;         Return block id 
05ab			 
05ab			 
05ab			; hl starting page number 
05ab			; hl contains free page number or zero if no pages free 
05ab			; e contains the file id to locate 
05ab			; d contains the block number 
05ab			 
05ab			; TODO change to find file id and use zero for free block 
05ab			 
05ab			storage_findnextid: 
05ab			 
05ab				; now locate first 0 page to mark as a free block 
05ab			 
05ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ad			;	ld hl, STORE_BLOCK_PHY 
05ad			 
05ad					if DEBUG_FORTH_WORDS 
05ad					DMARK "FNI" 
05ad f5				push af  
05ae 3a c2 05			ld a, (.dmark)  
05b1 32 6b ee			ld (debug_mark),a  
05b4 3a c3 05			ld a, (.dmark+1)  
05b7 32 6c ee			ld (debug_mark+1),a  
05ba 3a c4 05			ld a, (.dmark+2)  
05bd 32 6d ee			ld (debug_mark+2),a  
05c0 18 03			jr .pastdmark  
05c2 ..			.dmark: db "FNI"  
05c5 f1			.pastdmark: pop af  
05c6			endm  
# End of macro DMARK
05c6						CALLMONITOR 
05c6 cd 6f ee			call debug_vector  
05c9				endm  
# End of macro CALLMONITOR
05c9					endif 
05c9			.ff1:   	 
05c9 e5					push hl 
05ca c5					push bc 
05cb d5					push de 
05cc cd 9c 01				call se_readbyte 
05cf 5f					ld e,a 
05d0 23					inc hl 
05d1 cd 9c 01				call se_readbyte 
05d4 57					ld d, a 
05d5 e1					pop hl 
05d6 e5					push hl 
05d7 cd 04 0e				call cmp16 
05da 28 49				jr z, .fffound 
05dc			 
05dc d1					pop de 
05dd c1					pop bc 
05de e1					pop hl 
05df			 
05df					; is found? 
05df					;cp e 
05df					;ret z 
05df			 
05df 3e 40				ld a, STORE_BLOCK_PHY 
05e1 cd e6 0d				call addatohl 
05e4 10 e3				djnz .ff1 
05e6			 
05e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e8			.ff2:   	 
05e8			 
05e8 e5					push hl 
05e9 c5					push bc 
05ea d5					push de 
05eb cd 9c 01				call se_readbyte 
05ee 5f					ld e,a 
05ef 23					inc hl 
05f0 cd 9c 01				call se_readbyte 
05f3 57					ld d, a 
05f4			 
05f4 e1					pop hl 
05f5 e5					push hl 
05f6 cd 04 0e				call cmp16 
05f9 28 2a				jr z, .fffound 
05fb			 
05fb d1					pop de 
05fc c1					pop bc 
05fd e1					pop hl 
05fe					; is found? 
05fe					;cp e 
05fe					;ret z 
05fe			 
05fe 3e 40				ld a, STORE_BLOCK_PHY 
0600 cd e6 0d				call addatohl 
0603 10 e3				djnz .ff2 
0605			 
0605			 
0605					if DEBUG_FORTH_WORDS 
0605					DMARK "FN-" 
0605 f5				push af  
0606 3a 1a 06			ld a, (.dmark)  
0609 32 6b ee			ld (debug_mark),a  
060c 3a 1b 06			ld a, (.dmark+1)  
060f 32 6c ee			ld (debug_mark+1),a  
0612 3a 1c 06			ld a, (.dmark+2)  
0615 32 6d ee			ld (debug_mark+2),a  
0618 18 03			jr .pastdmark  
061a ..			.dmark: db "FN-"  
061d f1			.pastdmark: pop af  
061e			endm  
# End of macro DMARK
061e					;	push af 
061e					;	ld a, 'n' 
061e					;	ld (debug_mark),a 
061e					;	pop af 
061e						CALLMONITOR 
061e cd 6f ee			call debug_vector  
0621				endm  
# End of macro CALLMONITOR
0621					endif 
0621				; no free marks! 
0621 21 00 00				ld hl, 0 
0624 c9				ret 
0625			.fffound: 
0625				 
0625			 
0625 d1					pop de 
0626 c1					pop bc 
0627 e1					pop hl 
0628					if DEBUG_FORTH_WORDS 
0628					DMARK "FNF" 
0628 f5				push af  
0629 3a 3d 06			ld a, (.dmark)  
062c 32 6b ee			ld (debug_mark),a  
062f 3a 3e 06			ld a, (.dmark+1)  
0632 32 6c ee			ld (debug_mark+1),a  
0635 3a 3f 06			ld a, (.dmark+2)  
0638 32 6d ee			ld (debug_mark+2),a  
063b 18 03			jr .pastdmark  
063d ..			.dmark: db "FNF"  
0640 f1			.pastdmark: pop af  
0641			endm  
# End of macro DMARK
0641					;	push af 
0641					;	ld a, 'n' 
0641					;	ld (debug_mark),a 
0641					;	pop af 
0641						CALLMONITOR 
0641 cd 6f ee			call debug_vector  
0644				endm  
# End of macro CALLMONITOR
0644					endif 
0644 c9				ret 
0645			 
0645			 
0645			 
0645			; Free Space 
0645			; ---------- 
0645			; 
0645			; With current bank 
0645			; 
0645			; Set block count to zero 
0645			; Starting with first logical block 
0645			;      Find free block  
0645			;      If block id given, increment block count 
0645			; 
0645			;  
0645			 
0645			 
0645			; hl contains count of free blocks 
0645			 
0645			storage_freeblocks: 
0645			 
0645				; now locate first 0 page to mark as a free block 
0645			 
0645 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0647 21 40 00			ld hl, STORE_BLOCK_PHY 
064a 11 00 00			ld de, 0 
064d			 
064d			.fb1:   	 
064d e5					push hl 
064e c5					push bc 
064f d5					push de 
0650 cd 9c 01				call se_readbyte 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is free? 
0656 fe 00				cp 0 
0658 20 01				jr nz, .ff1cont 
065a 13					inc de 
065b			 
065b			.ff1cont: 
065b			 
065b			 
065b 3e 40				ld a, STORE_BLOCK_PHY 
065d cd e6 0d				call addatohl 
0660 10 eb				djnz .fb1 
0662			 
0662 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0664			.fb2:   	 
0664 e5					push hl 
0665 c5					push bc 
0666 d5					push de 
0667 cd 9c 01				call se_readbyte 
066a d1					pop de 
066b c1					pop bc 
066c e1					pop hl 
066d			 
066d					; is free? 
066d fe 00				cp 0 
066f 20 01				jr nz, .ff2cont 
0671 13					inc de 
0672			 
0672			.ff2cont: 
0672			 
0672 3e 40				ld a, STORE_BLOCK_PHY 
0674 cd e6 0d				call addatohl 
0677 10 eb				djnz .fb2 
0679			 
0679 eb				ex de, hl 
067a c9				ret 
067b			 
067b			; Get File ID 
067b			; ----------- 
067b			; 
067b			; With current bank 
067b			;  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; For each logical block 
067b			;    Read block file id 
067b			;      If first block of file and dont have file id 
067b			;         if file get id and exit 
067b			 
067b			 
067b			 
067b			 
067b			; Create File 
067b			; ----------- 
067b			; 
067b			; With current bank  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; Increment file id number 
067b			; Save Config 
067b			; Find free block 
067b			; Set buffer with file name and file id 
067b			; Write buffer to free block  
067b			 
067b			 
067b			; hl point to file name 
067b			; hl returns file id 
067b			 
067b			; file format: 
067b			; byte 0 - file id 
067b			; byte 1 - extent number 
067b			; byte 2-> data 
067b			 
067b			; format for extent number 0: 
067b			; 
067b			; byte 0 - file id 
067b			; byte 1 - extent 0 
067b			; byte 2 - extent count 
067b			; byte 3 -> file name and meta data 
067b			 
067b			 
067b			storage_create: 
067b				if DEBUG_STORESE 
067b					DMARK "SCR" 
067b f5				push af  
067c 3a 90 06			ld a, (.dmark)  
067f 32 6b ee			ld (debug_mark),a  
0682 3a 91 06			ld a, (.dmark+1)  
0685 32 6c ee			ld (debug_mark+1),a  
0688 3a 92 06			ld a, (.dmark+2)  
068b 32 6d ee			ld (debug_mark+2),a  
068e 18 03			jr .pastdmark  
0690 ..			.dmark: db "SCR"  
0693 f1			.pastdmark: pop af  
0694			endm  
# End of macro DMARK
0694					CALLMONITOR 
0694 cd 6f ee			call debug_vector  
0697				endm  
# End of macro CALLMONITOR
0697				endif 
0697			 
0697 e5				push hl		; save file name pointer 
0698			 
0698 cd 29 03			call storage_get_block_0 
069b			 
069b 3a 7a ea			ld a,(store_page)	; get current file id 
069e 3c				inc a 
069f 32 7a ea			ld (store_page),a 
06a2				 
06a2 32 6e ea			ld (store_tmpid),a			; save id 
06a5			 
06a5 21 00 00			ld hl, 0 
06a8 11 7a ea			ld de, store_page 
06ab				if DEBUG_STORESE 
06ab					DMARK "SCw" 
06ab f5				push af  
06ac 3a c0 06			ld a, (.dmark)  
06af 32 6b ee			ld (debug_mark),a  
06b2 3a c1 06			ld a, (.dmark+1)  
06b5 32 6c ee			ld (debug_mark+1),a  
06b8 3a c2 06			ld a, (.dmark+2)  
06bb 32 6d ee			ld (debug_mark+2),a  
06be 18 03			jr .pastdmark  
06c0 ..			.dmark: db "SCw"  
06c3 f1			.pastdmark: pop af  
06c4			endm  
# End of macro DMARK
06c4					CALLMONITOR 
06c4 cd 6f ee			call debug_vector  
06c7				endm  
# End of macro CALLMONITOR
06c7				endif 
06c7 cd dd 02			call storage_write_block	 ; save update 
06ca			 
06ca				if DEBUG_STORESE 
06ca 11 7a ea				ld de, store_page 
06cd					DMARK "SCC" 
06cd f5				push af  
06ce 3a e2 06			ld a, (.dmark)  
06d1 32 6b ee			ld (debug_mark),a  
06d4 3a e3 06			ld a, (.dmark+1)  
06d7 32 6c ee			ld (debug_mark+1),a  
06da 3a e4 06			ld a, (.dmark+2)  
06dd 32 6d ee			ld (debug_mark+2),a  
06e0 18 03			jr .pastdmark  
06e2 ..			.dmark: db "SCC"  
06e5 f1			.pastdmark: pop af  
06e6			endm  
# End of macro DMARK
06e6					CALLMONITOR 
06e6 cd 6f ee			call debug_vector  
06e9				endm  
# End of macro CALLMONITOR
06e9				endif 
06e9				;  
06e9				 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 11 00 00			ld de, 0 
06ef cd ab 05			call storage_findnextid 
06f2			 
06f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f5			 
06f5				; TODO detect 0 = no spare blocks 
06f5			 
06f5				; hl now contains the free page to use for the file header page 
06f5			 
06f5				if DEBUG_STORESE 
06f5				DMARK "SCF" 
06f5 f5				push af  
06f6 3a 0a 07			ld a, (.dmark)  
06f9 32 6b ee			ld (debug_mark),a  
06fc 3a 0b 07			ld a, (.dmark+1)  
06ff 32 6c ee			ld (debug_mark+1),a  
0702 3a 0c 07			ld a, (.dmark+2)  
0705 32 6d ee			ld (debug_mark+2),a  
0708 18 03			jr .pastdmark  
070a ..			.dmark: db "SCF"  
070d f1			.pastdmark: pop af  
070e			endm  
# End of macro DMARK
070e					CALLMONITOR 
070e cd 6f ee			call debug_vector  
0711				endm  
# End of macro CALLMONITOR
0711				endif 
0711			 
0711 22 65 ea			ld (store_tmppageid), hl 
0714				 
0714 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0717			;	ld a, (store_filecache)			; save to cache 
0717			 
0717 32 7a ea			ld (store_page),a    ; set page id 
071a 3e 00			ld a, 0			 ; extent 0 is file header 
071c 32 7b ea			ld (store_page+1), a   ; set file extent 
071f			 
071f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0722			 
0722			;	inc hl 		; init block 0 of file 
0722			;	inc hl   		; skip file and extent id 
0722			 ;       ld a, 0 
0722			;	ld (hl),a 
0722			;	ld a, (store_filecache+1)  	; save to cache 
0722			 
0722			;	inc hl    ; file name 
0722				 
0722				 
0722 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0725				if DEBUG_STORESE 
0725					DMARK "SCc" 
0725 f5				push af  
0726 3a 3a 07			ld a, (.dmark)  
0729 32 6b ee			ld (debug_mark),a  
072c 3a 3b 07			ld a, (.dmark+1)  
072f 32 6c ee			ld (debug_mark+1),a  
0732 3a 3c 07			ld a, (.dmark+2)  
0735 32 6d ee			ld (debug_mark+2),a  
0738 18 03			jr .pastdmark  
073a ..			.dmark: db "SCc"  
073d f1			.pastdmark: pop af  
073e			endm  
# End of macro DMARK
073e					CALLMONITOR 
073e cd 6f ee			call debug_vector  
0741				endm  
# End of macro CALLMONITOR
0741				endif 
0741 e1				pop hl    ; get zero term string 
0742 e5				push hl 
0743 3e 00			ld a, 0 
0745 cd 67 14			call strlent 
0748 23				inc hl   ; cover zero term 
0749 06 00			ld b,0 
074b 4d				ld c,l 
074c e1				pop hl 
074d				;ex de, hl 
074d				if DEBUG_STORESE 
074d					DMARK "SCa" 
074d f5				push af  
074e 3a 62 07			ld a, (.dmark)  
0751 32 6b ee			ld (debug_mark),a  
0754 3a 63 07			ld a, (.dmark+1)  
0757 32 6c ee			ld (debug_mark+1),a  
075a 3a 64 07			ld a, (.dmark+2)  
075d 32 6d ee			ld (debug_mark+2),a  
0760 18 03			jr .pastdmark  
0762 ..			.dmark: db "SCa"  
0765 f1			.pastdmark: pop af  
0766			endm  
# End of macro DMARK
0766					;push af 
0766					;ld a, 'a' 
0766					;ld (debug_mark),a 
0766					;pop af 
0766					CALLMONITOR 
0766 cd 6f ee			call debug_vector  
0769				endm  
# End of macro CALLMONITOR
0769				endif 
0769 ed b0			ldir    ; copy zero term string 
076b				if DEBUG_STORESE 
076b					DMARK "SCA" 
076b f5				push af  
076c 3a 80 07			ld a, (.dmark)  
076f 32 6b ee			ld (debug_mark),a  
0772 3a 81 07			ld a, (.dmark+1)  
0775 32 6c ee			ld (debug_mark+1),a  
0778 3a 82 07			ld a, (.dmark+2)  
077b 32 6d ee			ld (debug_mark+2),a  
077e 18 03			jr .pastdmark  
0780 ..			.dmark: db "SCA"  
0783 f1			.pastdmark: pop af  
0784			endm  
# End of macro DMARK
0784					CALLMONITOR 
0784 cd 6f ee			call debug_vector  
0787				endm  
# End of macro CALLMONITOR
0787				endif 
0787			 
0787				; write file header page 
0787			 
0787 2a 65 ea			ld hl,(store_tmppageid) 
078a 11 7a ea			ld de, store_page 
078d				if DEBUG_STORESE 
078d					DMARK "SCb" 
078d f5				push af  
078e 3a a2 07			ld a, (.dmark)  
0791 32 6b ee			ld (debug_mark),a  
0794 3a a3 07			ld a, (.dmark+1)  
0797 32 6c ee			ld (debug_mark+1),a  
079a 3a a4 07			ld a, (.dmark+2)  
079d 32 6d ee			ld (debug_mark+2),a  
07a0 18 03			jr .pastdmark  
07a2 ..			.dmark: db "SCb"  
07a5 f1			.pastdmark: pop af  
07a6			endm  
# End of macro DMARK
07a6					;push af 
07a6					;ld a, 'b' 
07a6					;ld (debug_mark),a 
07a6					;pop af 
07a6					CALLMONITOR 
07a6 cd 6f ee			call debug_vector  
07a9				endm  
# End of macro CALLMONITOR
07a9				endif 
07a9 cd dd 02			call storage_write_block 
07ac			 
07ac 3a 6e ea			ld a, (store_tmpid) 
07af 6f				ld l, a 
07b0 26 00			ld h,0 
07b2				if DEBUG_STORESE 
07b2					DMARK "SCz" 
07b2 f5				push af  
07b3 3a c7 07			ld a, (.dmark)  
07b6 32 6b ee			ld (debug_mark),a  
07b9 3a c8 07			ld a, (.dmark+1)  
07bc 32 6c ee			ld (debug_mark+1),a  
07bf 3a c9 07			ld a, (.dmark+2)  
07c2 32 6d ee			ld (debug_mark+2),a  
07c5 18 03			jr .pastdmark  
07c7 ..			.dmark: db "SCz"  
07ca f1			.pastdmark: pop af  
07cb			endm  
# End of macro DMARK
07cb					CALLMONITOR 
07cb cd 6f ee			call debug_vector  
07ce				endm  
# End of macro CALLMONITOR
07ce				endif 
07ce c9				ret 
07cf				 
07cf			 
07cf			 
07cf			; 
07cf			; Read File 
07cf			; 
07cf			; h - file id to locate 
07cf			; l - extent to locate 
07cf			; de - pointer to string to read into 
07cf			; 
07cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07cf			 
07cf			.sr_fail: 
07cf d1				pop de 
07d0 c9				ret 
07d1			 
07d1			storage_read: 
07d1			 
07d1			 
07d1 d5				push de 
07d2			 
07d2			; TODO BUG the above push is it popped before the RET Z? 
07d2			 
07d2			; TODO how to handle multiple part blocks 
07d2			 
07d2				; locate file extent to read 
07d2			 
07d2 5c				ld e, h 
07d3 55				ld d, l 
07d4			 
07d4			.srext: 
07d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07db			 
07db 21 40 00			ld hl, STORE_BLOCK_PHY 
07de				if DEBUG_STORESE 
07de					DMARK "sre" 
07de f5				push af  
07df 3a f3 07			ld a, (.dmark)  
07e2 32 6b ee			ld (debug_mark),a  
07e5 3a f4 07			ld a, (.dmark+1)  
07e8 32 6c ee			ld (debug_mark+1),a  
07eb 3a f5 07			ld a, (.dmark+2)  
07ee 32 6d ee			ld (debug_mark+2),a  
07f1 18 03			jr .pastdmark  
07f3 ..			.dmark: db "sre"  
07f6 f1			.pastdmark: pop af  
07f7			endm  
# End of macro DMARK
07f7					CALLMONITOR 
07f7 cd 6f ee			call debug_vector  
07fa				endm  
# End of macro CALLMONITOR
07fa				endif 
07fa cd ab 05			call storage_findnextid 
07fd			 
07fd				if DEBUG_STORESE 
07fd					DMARK "srf" 
07fd f5				push af  
07fe 3a 12 08			ld a, (.dmark)  
0801 32 6b ee			ld (debug_mark),a  
0804 3a 13 08			ld a, (.dmark+1)  
0807 32 6c ee			ld (debug_mark+1),a  
080a 3a 14 08			ld a, (.dmark+2)  
080d 32 6d ee			ld (debug_mark+2),a  
0810 18 03			jr .pastdmark  
0812 ..			.dmark: db "srf"  
0815 f1			.pastdmark: pop af  
0816			endm  
# End of macro DMARK
0816					CALLMONITOR 
0816 cd 6f ee			call debug_vector  
0819				endm  
# End of macro CALLMONITOR
0819				endif 
0819 cd 0f 0e			call ishlzero 
081c			;	ld a, l 
081c			;	add h 
081c			;	cp 0 
081c 28 b1			jr z,.sr_fail			; block not found so EOF 
081e			 
081e				; save current address for use by higher level words etc 
081e			 
081e 22 6b ea			ld (store_openaddr),hl 
0821			 
0821			 
0821				; hl contains page number to load 
0821 d1				pop de   ; get storage 
0822 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0826 d5				push de 
0827				if DEBUG_STORESE 
0827					DMARK "srg" 
0827 f5				push af  
0828 3a 3c 08			ld a, (.dmark)  
082b 32 6b ee			ld (debug_mark),a  
082e 3a 3d 08			ld a, (.dmark+1)  
0831 32 6c ee			ld (debug_mark+1),a  
0834 3a 3e 08			ld a, (.dmark+2)  
0837 32 6d ee			ld (debug_mark+2),a  
083a 18 03			jr .pastdmark  
083c ..			.dmark: db "srg"  
083f f1			.pastdmark: pop af  
0840			endm  
# End of macro DMARK
0840					CALLMONITOR 
0840 cd 6f ee			call debug_vector  
0843				endm  
# End of macro CALLMONITOR
0843				endif 
0843 cd 78 02			call storage_read_block 
0846			 
0846				; if this a continuation read??? 
0846			 
0846 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0849			 
0849 3e 3f			ld a, STORE_BLOCK_PHY-1 
084b cd e6 0d			call addatohl 
084e 7e				ld a,(hl) 
084f fe 00			cp 0 
0851 28 02			jr z, .markiscont 
0853 3e ff			ld a, 255 
0855			 
0855			.markiscont: 
0855 32 6d ea			ld (store_readcont), a 
0858			 
0858				if DEBUG_STORESE 
0858					DMARK "srC" 
0858 f5				push af  
0859 3a 6d 08			ld a, (.dmark)  
085c 32 6b ee			ld (debug_mark),a  
085f 3a 6e 08			ld a, (.dmark+1)  
0862 32 6c ee			ld (debug_mark+1),a  
0865 3a 6f 08			ld a, (.dmark+2)  
0868 32 6d ee			ld (debug_mark+2),a  
086b 18 03			jr .pastdmark  
086d ..			.dmark: db "srC"  
0870 f1			.pastdmark: pop af  
0871			endm  
# End of macro DMARK
0871					CALLMONITOR 
0871 cd 6f ee			call debug_vector  
0874				endm  
# End of macro CALLMONITOR
0874				endif 
0874				; only short reads enabled 
0874			 
0874 3a 75 ea			ld a, (store_longread) 
0877 fe 00			cp 0 
0879 ca 46 09			jp z, .readdone 
087c			 
087c			; TODO if block has no zeros then need to read next block  
087c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087c			; check last byte of physical block. 
087c			; if not zero then the next block needs to be loaded 
087c			 
087c			 
087c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
087f			 
087f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0881 cd e6 0d			call addatohl 
0884				;dec hl 
0884 7e				ld a,(hl) 
0885				if DEBUG_STORESE 
0885					DMARK "sr?" 
0885 f5				push af  
0886 3a 9a 08			ld a, (.dmark)  
0889 32 6b ee			ld (debug_mark),a  
088c 3a 9b 08			ld a, (.dmark+1)  
088f 32 6c ee			ld (debug_mark+1),a  
0892 3a 9c 08			ld a, (.dmark+2)  
0895 32 6d ee			ld (debug_mark+2),a  
0898 18 03			jr .pastdmark  
089a ..			.dmark: db "sr?"  
089d f1			.pastdmark: pop af  
089e			endm  
# End of macro DMARK
089e					CALLMONITOR 
089e cd 6f ee			call debug_vector  
08a1				endm  
# End of macro CALLMONITOR
08a1				endif 
08a1 fe 00			cp 0 
08a3 ca 46 09			jp z, .readdone 
08a6			 
08a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a6			 
08a6 23				inc hl 
08a7			 
08a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08aa			 
08aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08ae			 
08ae eb				ex de, hl 
08af			 
08af				; next ext 
08af			 
08af 23				inc hl 
08b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b3			 
08b3				if DEBUG_STORESE 
08b3					DMARK "sF2" 
08b3 f5				push af  
08b4 3a c8 08			ld a, (.dmark)  
08b7 32 6b ee			ld (debug_mark),a  
08ba 3a c9 08			ld a, (.dmark+1)  
08bd 32 6c ee			ld (debug_mark+1),a  
08c0 3a ca 08			ld a, (.dmark+2)  
08c3 32 6d ee			ld (debug_mark+2),a  
08c6 18 03			jr .pastdmark  
08c8 ..			.dmark: db "sF2"  
08cb f1			.pastdmark: pop af  
08cc			endm  
# End of macro DMARK
08cc					CALLMONITOR 
08cc cd 6f ee			call debug_vector  
08cf				endm  
# End of macro CALLMONITOR
08cf				endif 
08cf			 
08cf				; get and load block 
08cf			 
08cf cd ab 05			call storage_findnextid 
08d2			 
08d2				if DEBUG_STORESE 
08d2					DMARK "sf2" 
08d2 f5				push af  
08d3 3a e7 08			ld a, (.dmark)  
08d6 32 6b ee			ld (debug_mark),a  
08d9 3a e8 08			ld a, (.dmark+1)  
08dc 32 6c ee			ld (debug_mark+1),a  
08df 3a e9 08			ld a, (.dmark+2)  
08e2 32 6d ee			ld (debug_mark+2),a  
08e5 18 03			jr .pastdmark  
08e7 ..			.dmark: db "sf2"  
08ea f1			.pastdmark: pop af  
08eb			endm  
# End of macro DMARK
08eb					CALLMONITOR 
08eb cd 6f ee			call debug_vector  
08ee				endm  
# End of macro CALLMONITOR
08ee				endif 
08ee cd 0f 0e			call ishlzero 
08f1			;	ld a, l 
08f1			;	add h 
08f1			;	cp 0 
08f1 ca cf 07			jp z,.sr_fail			; block not found so EOF 
08f4				 
08f4				; save current address for use by higher level words etc 
08f4			 
08f4 22 6b ea			ld (store_openaddr),hl 
08f7			 
08f7 cd 78 02			call storage_read_block 
08fa			 
08fa				; on a continuation block, we now have the file id and ext in the middle of the block 
08fa				; we need to pull everything back  
08fa			 
08fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0901 23				inc hl 
0902 23				inc hl     ; skip id and ext 
0903 01 40 00			ld bc, STORE_BLOCK_PHY 
0906				if DEBUG_STORESE 
0906					DMARK "SR<" 
0906 f5				push af  
0907 3a 1b 09			ld a, (.dmark)  
090a 32 6b ee			ld (debug_mark),a  
090d 3a 1c 09			ld a, (.dmark+1)  
0910 32 6c ee			ld (debug_mark+1),a  
0913 3a 1d 09			ld a, (.dmark+2)  
0916 32 6d ee			ld (debug_mark+2),a  
0919 18 03			jr .pastdmark  
091b ..			.dmark: db "SR<"  
091e f1			.pastdmark: pop af  
091f			endm  
# End of macro DMARK
091f					CALLMONITOR 
091f cd 6f ee			call debug_vector  
0922				endm  
# End of macro CALLMONITOR
0922				endif 
0922 ed b0			ldir     ; copy data 
0924			 
0924				; move the pointer back and pretend we have a full buffer for next recheck 
0924			 
0924 1b				dec de 
0925 1b				dec de 
0926			 
0926			; TODO do pop below now short circuit loop????? 
0926 c1				pop bc     ; get rid of spare de on stack 
0927				if DEBUG_STORESE 
0927					DMARK "SR>" 
0927 f5				push af  
0928 3a 3c 09			ld a, (.dmark)  
092b 32 6b ee			ld (debug_mark),a  
092e 3a 3d 09			ld a, (.dmark+1)  
0931 32 6c ee			ld (debug_mark+1),a  
0934 3a 3e 09			ld a, (.dmark+2)  
0937 32 6d ee			ld (debug_mark+2),a  
093a 18 03			jr .pastdmark  
093c ..			.dmark: db "SR>"  
093f f1			.pastdmark: pop af  
0940			endm  
# End of macro DMARK
0940					CALLMONITOR 
0940 cd 6f ee			call debug_vector  
0943				endm  
# End of macro CALLMONITOR
0943				endif 
0943 c3 d4 07			jp .srext 
0946			 
0946			 
0946			 
0946			 
0946			 
0946			.readdone:		 
0946 e1				pop hl 		 ; return start of data to show as not EOF 
0947 23				inc hl   ; past file id 
0948 23				inc hl   ; past ext 
0949				if DEBUG_STORESE 
0949					DMARK "SRe" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 6b ee			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 6c ee			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 6d ee			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SRe"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					CALLMONITOR 
0962 cd 6f ee			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 c9					ret 
0966			 
0966			 
0966			 
0966			; 
0966			; Append File 
0966			; 
0966			; hl - file id to locate 
0966			; de - pointer to (multi block) string to write 
0966			 
0966			.sa_notfound: 
0966 d1				pop de 
0967 c9				ret 
0968			 
0968			 
0968			storage_append: 
0968				; hl -  file id to append to 
0968				; de - string to append 
0968			 
0968 d5				push de 
0969				 
0969				if DEBUG_STORESE 
0969					DMARK "AP1" 
0969 f5				push af  
096a 3a 7e 09			ld a, (.dmark)  
096d 32 6b ee			ld (debug_mark),a  
0970 3a 7f 09			ld a, (.dmark+1)  
0973 32 6c ee			ld (debug_mark+1),a  
0976 3a 80 09			ld a, (.dmark+2)  
0979 32 6d ee			ld (debug_mark+2),a  
097c 18 03			jr .pastdmark  
097e ..			.dmark: db "AP1"  
0981 f1			.pastdmark: pop af  
0982			endm  
# End of macro DMARK
0982					CALLMONITOR 
0982 cd 6f ee			call debug_vector  
0985				endm  
# End of macro CALLMONITOR
0985				endif 
0985			 
0985 7d				ld a, l 
0986 32 6e ea			ld (store_tmpid), a 
0989			 
0989				; get file header  
0989			 
0989 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098b 3a 6e ea			ld a, (store_tmpid) 
098e 5f				ld e, a 
098f			 
098f 21 40 00				ld hl, STORE_BLOCK_PHY 
0992 cd ab 05				call storage_findnextid 
0995			 
0995 cd 0f 0e			call ishlzero 
0998 28 cc			jr z, .sa_notfound 
099a			 
099a 22 65 ea			ld (store_tmppageid), hl 
099d			 
099d				; TODO handle file id not found 
099d			 
099d				if DEBUG_STORESE 
099d					DMARK "AP2" 
099d f5				push af  
099e 3a b2 09			ld a, (.dmark)  
09a1 32 6b ee			ld (debug_mark),a  
09a4 3a b3 09			ld a, (.dmark+1)  
09a7 32 6c ee			ld (debug_mark+1),a  
09aa 3a b4 09			ld a, (.dmark+2)  
09ad 32 6d ee			ld (debug_mark+2),a  
09b0 18 03			jr .pastdmark  
09b2 ..			.dmark: db "AP2"  
09b5 f1			.pastdmark: pop af  
09b6			endm  
# End of macro DMARK
09b6					CALLMONITOR 
09b6 cd 6f ee			call debug_vector  
09b9				endm  
# End of macro CALLMONITOR
09b9				endif 
09b9			 
09b9				; update file extent count 
09b9			 
09b9 11 7a ea			ld de, store_page 
09bc			 
09bc cd 78 02			call storage_read_block 
09bf			 
09bf				if DEBUG_STORESE 
09bf					DMARK "AP3" 
09bf f5				push af  
09c0 3a d4 09			ld a, (.dmark)  
09c3 32 6b ee			ld (debug_mark),a  
09c6 3a d5 09			ld a, (.dmark+1)  
09c9 32 6c ee			ld (debug_mark+1),a  
09cc 3a d6 09			ld a, (.dmark+2)  
09cf 32 6d ee			ld (debug_mark+2),a  
09d2 18 03			jr .pastdmark  
09d4 ..			.dmark: db "AP3"  
09d7 f1			.pastdmark: pop af  
09d8			endm  
# End of macro DMARK
09d8					CALLMONITOR 
09d8 cd 6f ee			call debug_vector  
09db				endm  
# End of macro CALLMONITOR
09db				endif 
09db			;	ld (store_tmppageid), hl 
09db			 
09db 3a 7c ea			ld a, (store_page+2) 
09de 3c				inc a 
09df 32 7c ea			ld (store_page+2), a 
09e2 32 6d ea			ld (store_tmpext), a 
09e5				 
09e5				if DEBUG_STORESE 
09e5					DMARK "AP3" 
09e5 f5				push af  
09e6 3a fa 09			ld a, (.dmark)  
09e9 32 6b ee			ld (debug_mark),a  
09ec 3a fb 09			ld a, (.dmark+1)  
09ef 32 6c ee			ld (debug_mark+1),a  
09f2 3a fc 09			ld a, (.dmark+2)  
09f5 32 6d ee			ld (debug_mark+2),a  
09f8 18 03			jr .pastdmark  
09fa ..			.dmark: db "AP3"  
09fd f1			.pastdmark: pop af  
09fe			endm  
# End of macro DMARK
09fe					CALLMONITOR 
09fe cd 6f ee			call debug_vector  
0a01				endm  
# End of macro CALLMONITOR
0a01				endif 
0a01 2a 65 ea			ld hl, (store_tmppageid) 
0a04 11 7a ea			ld de, store_page 
0a07 cd dd 02			call storage_write_block 
0a0a			 
0a0a				; find free block 
0a0a			 
0a0a 11 00 00			ld de, 0			 ; file extent to locate 
0a0d			 
0a0d 21 40 00				ld hl, STORE_BLOCK_PHY 
0a10 cd ab 05				call storage_findnextid 
0a13 cd 0f 0e			call ishlzero 
0a16 ca 66 09			jp z, .sa_notfound 
0a19			 
0a19					; TODO handle no space left 
0a19					 
0a19 22 65 ea				ld (store_tmppageid), hl 
0a1c			 
0a1c				if DEBUG_STORESE 
0a1c					DMARK "AP4" 
0a1c f5				push af  
0a1d 3a 31 0a			ld a, (.dmark)  
0a20 32 6b ee			ld (debug_mark),a  
0a23 3a 32 0a			ld a, (.dmark+1)  
0a26 32 6c ee			ld (debug_mark+1),a  
0a29 3a 33 0a			ld a, (.dmark+2)  
0a2c 32 6d ee			ld (debug_mark+2),a  
0a2f 18 03			jr .pastdmark  
0a31 ..			.dmark: db "AP4"  
0a34 f1			.pastdmark: pop af  
0a35			endm  
# End of macro DMARK
0a35					CALLMONITOR 
0a35 cd 6f ee			call debug_vector  
0a38				endm  
# End of macro CALLMONITOR
0a38				endif 
0a38					; init the buffer with zeros so we can id if the buffer is full or not 
0a38			 
0a38 e5					push hl 
0a39 c5					push bc 
0a3a			 
0a3a 21 7a ea				ld hl, store_page 
0a3d 06 40				ld b, STORE_BLOCK_PHY 
0a3f 3e 00				ld a, 0 
0a41 77			.zeroblock:	ld (hl), a 
0a42 23					inc hl 
0a43 10 fc				djnz .zeroblock 
0a45			 
0a45 c1					pop bc 
0a46 e1					pop hl 
0a47			 
0a47					; construct block 
0a47			 
0a47 3a 6e ea				ld a, (store_tmpid) 
0a4a 32 7a ea				ld (store_page), a   ; file id 
0a4d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a50 32 7b ea				ld (store_page+1), a 
0a53			 
0a53 e1					pop hl    ; get string to write 
0a54 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a56 11 7c ea				ld de, store_page+2 
0a59			 
0a59				if DEBUG_STORESE 
0a59					DMARK "AP5" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 6b ee			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 6c ee			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 6d ee			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "AP5"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd 6f ee			call debug_vector  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75			 
0a75			 
0a75			 
0a75					; fill buffer with data until end of string or full block 
0a75			 
0a75 7e			.appd:		ld a, (hl) 
0a76 12					ld (de), a 
0a77 fe 00				cp 0 
0a79 28 04				jr z, .appdone 
0a7b 23					inc hl 
0a7c 13					inc de 
0a7d 10 f6				djnz .appd 
0a7f			 
0a7f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a80 f5					push af   		; save last byte dumped 
0a81			 
0a81			 
0a81 2a 65 ea			ld hl, (store_tmppageid) 
0a84 11 7a ea			ld de, store_page 
0a87				if DEBUG_STORESE 
0a87					DMARK "AP6" 
0a87 f5				push af  
0a88 3a 9c 0a			ld a, (.dmark)  
0a8b 32 6b ee			ld (debug_mark),a  
0a8e 3a 9d 0a			ld a, (.dmark+1)  
0a91 32 6c ee			ld (debug_mark+1),a  
0a94 3a 9e 0a			ld a, (.dmark+2)  
0a97 32 6d ee			ld (debug_mark+2),a  
0a9a 18 03			jr .pastdmark  
0a9c ..			.dmark: db "AP6"  
0a9f f1			.pastdmark: pop af  
0aa0			endm  
# End of macro DMARK
0aa0					CALLMONITOR 
0aa0 cd 6f ee			call debug_vector  
0aa3				endm  
# End of macro CALLMONITOR
0aa3				endif 
0aa3 cd dd 02				call storage_write_block 
0aa6			 
0aa6			 
0aa6				; was that a full block of data written? 
0aa6				; any more to write out? 
0aa6			 
0aa6				; if yes then set vars and jump to start of function again 
0aa6			 
0aa6 f1					pop af 
0aa7 d1					pop de 
0aa8			 
0aa8 fe 00				cp 0		 ; no, string was fully written 
0aaa c8					ret z 
0aab			 
0aab					; setup vars for next cycle 
0aab			 
0aab 3a 6e ea				ld a, (store_tmpid) 
0aae 6f					ld l, a 
0aaf 26 00				ld h, 0 
0ab1			 
0ab1 c3 68 09			 	jp storage_append	 ; yes, need to write out some more 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			if DEBUG_STORECF 
0ab4			storageput:	 
0ab4					ret 
0ab4			storageread: 
0ab4					ld hl, store_page 
0ab4					ld b, 200 
0ab4					ld a,0 
0ab4			.src:		ld (hl),a 
0ab4					inc hl 
0ab4					djnz .src 
0ab4					 
0ab4			 
0ab4					ld de, 0 
0ab4					ld bc, 1 
0ab4					ld hl, store_page 
0ab4					call cfRead 
0ab4			 
0ab4				call cfGetError 
0ab4				ld hl,scratch 
0ab4				call hexout 
0ab4				ld hl, scratch+2 
0ab4				ld a, 0 
0ab4				ld (hl),a 
0ab4				ld de, scratch 
0ab4				ld a,display_row_1 
0ab4				call str_at_display 
0ab4				call update_display 
0ab4			 
0ab4					ld hl, store_page 
0ab4					ld (os_cur_ptr),hl 
0ab4			 
0ab4					ret 
0ab4			endif 
0ab4			 
0ab4			 
0ab4			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab4			 
0ab4			storage_clear_page: 
0ab4 e5				push hl 
0ab5 d5				push de 
0ab6 c5				push bc 
0ab7 21 7a ea			ld hl, store_page 
0aba 3e 00			ld a, 0 
0abc 77				ld (hl), a 
0abd			 
0abd 11 7b ea			ld de, store_page+1 
0ac0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac3			 
0ac3 ed b0			ldir 
0ac5				 
0ac5 c1				pop bc 
0ac6 d1				pop de 
0ac7 e1				pop hl 
0ac8 c9				ret 
0ac9			 
0ac9			; eof 
# End of file firmware_storage.asm
0ac9			  
0ac9			; support routines for above hardware abstraction layer  
0ac9			  
0ac9			include "firmware_general.asm"        ; general support functions  
0ac9			 
0ac9			; word look up 
0ac9			 
0ac9			; in 
0ac9			; a is the index 
0ac9			; hl is pointer start of array 
0ac9			; 
0ac9			; returns 
0ac9			; hl to the word 
0ac9			; 
0ac9			 
0ac9			table_lookup:  
0ac9 d5					push de 
0aca eb					ex de, hl 
0acb			 
0acb 6f					ld l, a 
0acc 26 00				ld h, 0 
0ace 29					add hl, hl 
0acf 19					add hl, de 
0ad0 7e					ld a, (hl) 
0ad1 23					inc hl 
0ad2 66					ld h,(hl) 
0ad3 6f					ld l, a 
0ad4			 
0ad4 d1					pop de 
0ad5 c9					ret 
0ad6			 
0ad6			; Delay loops 
0ad6			 
0ad6			 
0ad6			 
0ad6			aDelayInMS: 
0ad6 c5				push bc 
0ad7 47				ld b,a 
0ad8			msdelay: 
0ad8 c5				push bc 
0ad9				 
0ad9			 
0ad9 01 41 00			ld bc,041h 
0adc cd f4 0a			call delayloop 
0adf c1				pop bc 
0ae0 05				dec b 
0ae1 20 f5			jr nz,msdelay 
0ae3			 
0ae3			;if CPU_CLOCK_8MHZ 
0ae3			;msdelay8: 
0ae3			;	push bc 
0ae3			;	 
0ae3			; 
0ae3			;	ld bc,041h 
0ae3			;	call delayloop 
0ae3			;	pop bc 
0ae3			;	dec b 
0ae3			;	jr nz,msdelay8 
0ae3			;endif 
0ae3			 
0ae3			 
0ae3 c1				pop bc 
0ae4 c9				ret 
0ae5			 
0ae5			 
0ae5			delay250ms: 
0ae5				;push de 
0ae5 01 00 40			ld bc, 04000h 
0ae8 c3 f4 0a			jp delayloop 
0aeb			delay500ms: 
0aeb				;push de 
0aeb 01 00 80			ld bc, 08000h 
0aee c3 f4 0a			jp delayloop 
0af1			delay1s: 
0af1				;push bc 
0af1			   ; Clobbers A, d and e 
0af1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af4			delayloop: 
0af4 c5			    push bc 
0af5			 
0af5			if BASE_CPM 
0af5 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af8			.cpmloop: 
0af8 c5				push bc 
0af9			 
0af9			endif 
0af9			 
0af9			 
0af9			 
0af9			delayloopi: 
0af9			;	push bc 
0af9			;.dl: 
0af9 cb 47		    bit     0,a    	; 8 
0afb cb 47		    bit     0,a    	; 8 
0afd cb 47		    bit     0,a    	; 8 
0aff e6 ff		    and     255  	; 7 
0b01 0b			    dec     bc      	; 6 
0b02 79			    ld      a,c     	; 4 
0b03 b0			    or      b     	; 4 
0b04 c2 f9 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b07			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b07				;pop de 
0b07			;pop bc 
0b07			 
0b07			if BASE_CPM 
0b07 c1				pop bc 
0b08				 
0b08 0b			    dec     bc      	; 6 
0b09 79			    ld      a,c     	; 4 
0b0a b0			    or      b     	; 4 
0b0b c2 f8 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0e				 
0b0e			 
0b0e			endif 
0b0e			;if CPU_CLOCK_8MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e			 
0b0e			;if CPU_CLOCK_10MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e c1			    pop bc 
0b0f			 
0b0f c9				ret 
0b10			 
0b10			 
0b10			 
0b10			; eof 
# End of file firmware_general.asm
0b10			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b10			; display routines that use the physical hardware abstraction layer 
0b10			 
0b10			 
0b10			; Display an activity indicator 
0b10			; Each call returns the new char pointed to in hl 
0b10			 
0b10			active: 
0b10 3a c6 eb			ld a, (display_active) 
0b13 fe 06			cp 6 
0b15			 
0b15 20 02			jr nz, .sne 
0b17				; gone past the last one reset sequence 
0b17 3e ff			ld a, 255 
0b19			 
0b19			.sne:   
0b19				; get the next char in seq 
0b19 3c				inc a 
0b1a 32 c6 eb			ld (display_active), a 
0b1d			 
0b1d				; look up the string in the table 
0b1d 21 34 0b			ld hl, actseq 
0b20 cb 27			sla a 
0b22 cd e6 0d			call addatohl 
0b25 cd 99 21			call loadwordinhl 
0b28			 
0b28				; forth will write the to string when pushing so move from rom to ram 
0b28			 
0b28 11 c7 eb			ld de, display_active+1 
0b2b 01 02 00			ld bc, 2 
0b2e ed b0			ldir 
0b30			 
0b30 21 c7 eb			ld hl, display_active+1 
0b33 c9				ret 
0b34				 
0b34				 
0b34			 
0b34			 
0b34			;db "|/-\|-\" 
0b34			 
0b34			actseq: 
0b34			 
0b34 42 0b		dw spin0 
0b36 44 0b		dw spin1 
0b38 46 0b		dw spin2 
0b3a 48 0b		dw spin3 
0b3c 46 0b		dw spin2 
0b3e 44 0b		dw spin1 
0b40 42 0b		dw spin0 
0b42			 
0b42 .. 00		spin0: db " ", 0 
0b44 .. 00		spin1: db "-", 0 
0b46 .. 00		spin2: db "+", 0 
0b48 .. 00		spin3: db "#", 0 
0b4a			 
0b4a			 
0b4a			; information window 
0b4a			 
0b4a			; pass hl with 1st string to display 
0b4a			; pass de with 2nd string to display 
0b4a			 
0b4a			info_panel: 
0b4a e5				push hl 
0b4b			 
0b4b 2a cc eb			ld hl, (display_fb_active) 
0b4e e5				push hl    ; future de destination 
0b4f 21 b1 ed				ld hl, display_fb0 
0b52 22 cc eb				ld (display_fb_active), hl 
0b55			 
0b55			;	call clear_display 
0b55			 
0b55				if BASE_CPM 
0b55 3e 2e			ld a, '.' 
0b57				else 
0b57				ld a, 165 
0b57				endif 
0b57 cd be 0b			call fill_display 
0b5a			 
0b5a			 
0b5a 3e 55			ld a, display_row_3 + 5 
0b5c cd cc 0b			call str_at_display 
0b5f			 
0b5f e1				pop hl 
0b60 d1				pop de 
0b61			 
0b61 e5				push hl 
0b62			 
0b62			 
0b62 3e 2d			ld a, display_row_2 + 5 
0b64 cd cc 0b			call str_at_display 
0b67			 
0b67			 
0b67 cd dc 0b			call update_display 
0b6a cd e2 1d			call next_page_prompt 
0b6d cd b9 0b			call clear_display 
0b70			 
0b70				 
0b70 21 10 ed				ld hl, display_fb1 
0b73 22 cc eb				ld (display_fb_active), hl 
0b76 cd dc 0b			call update_display 
0b79			 
0b79 e1				pop hl 
0b7a			 
0b7a c9				ret 
0b7b			 
0b7b			 
0b7b			 
0b7b			 
0b7b			; TODO windowing? 
0b7b			 
0b7b			; TODO scroll line up 
0b7b			 
0b7b			scroll_up: 
0b7b			 
0b7b e5				push hl 
0b7c d5				push de 
0b7d c5				push bc 
0b7e			 
0b7e				; get frame buffer  
0b7e			 
0b7e 2a cc eb			ld hl, (display_fb_active) 
0b81 e5				push hl    ; future de destination 
0b82			 
0b82 11 28 00			ld  de, display_cols 
0b85 19				add hl, de 
0b86			 
0b86 d1				pop de 
0b87			 
0b87				;ex de, hl 
0b87 01 9f 00			ld bc, display_fb_len -1  
0b8a			;if DEBUG_FORTH_WORDS 
0b8a			;	DMARK "SCL" 
0b8a			;	CALLMONITOR 
0b8a			;endif	 
0b8a ed b0			ldir 
0b8c			 
0b8c				; wipe bottom row 
0b8c			 
0b8c			 
0b8c 2a cc eb			ld hl, (display_fb_active) 
0b8f 11 a0 00			ld de, display_cols*display_rows 
0b92 19				add hl, de 
0b93 06 28			ld b, display_cols 
0b95 3e 20			ld a, ' ' 
0b97			.scwipe: 
0b97 77				ld (hl), a 
0b98 2b				dec hl 
0b99 10 fc			djnz .scwipe 
0b9b			 
0b9b				;pop hl 
0b9b			 
0b9b c1				pop bc 
0b9c d1				pop de 
0b9d e1				pop hl 
0b9e			 
0b9e c9				ret 
0b9f			 
0b9f			 
0b9f			;scroll_upo: 
0b9f			;	ld de, display_row_1 
0b9f			 ;	ld hl, display_row_2 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_2 
0b9f			 ;	ld hl, display_row_3 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_3 
0b9f			 ;	ld hl, display_row_4 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			 
0b9f			; TODO clear row 4 
0b9f			 
0b9f			;	ret 
0b9f			 
0b9f				 
0b9f			scroll_down: 
0b9f			 
0b9f e5				push hl 
0ba0 d5				push de 
0ba1 c5				push bc 
0ba2			 
0ba2				; get frame buffer  
0ba2			 
0ba2 2a cc eb			ld hl, (display_fb_active) 
0ba5			 
0ba5 11 9f 00			ld de, display_fb_len - 1 
0ba8 19				add hl, de 
0ba9			 
0ba9 e5			push hl    ; future de destination 
0baa			 
0baa 11 28 00			ld  de, display_cols 
0bad ed 52			sbc hl, de 
0baf			 
0baf			 
0baf d1				pop de 
0bb0			 
0bb0			;	ex de, hl 
0bb0 01 9f 00			ld bc, display_fb_len -1  
0bb3			 
0bb3			 
0bb3				 
0bb3			 
0bb3 ed b0			ldir 
0bb5			 
0bb5				; wipe bottom row 
0bb5			 
0bb5			 
0bb5			;	ld hl, (display_fb_active) 
0bb5			;;	ld de, display_cols*display_rows 
0bb5			;;	add hl, de 
0bb5			;	ld b, display_cols 
0bb5			;	ld a, ' ' 
0bb5			;.scwiped: 
0bb5			;	ld (hl), a 
0bb5			;	dec hl 
0bb5			;	djnz .scwiped 
0bb5			 
0bb5				;pop hl 
0bb5			 
0bb5 c1				pop bc 
0bb6 d1				pop de 
0bb7 e1				pop hl 
0bb8			 
0bb8 c9				ret 
0bb9			;scroll_down: 
0bb9			;	ld de, display_row_4 
0bb9			;	ld hl, display_row_3 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_3 
0bb9			; 	ld hl, display_row_2 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_2 
0bb9			;	ld hl, display_row_1 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;;; TODO clear row 1 
0bb9			;	ret 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			; clear active frame buffer 
0bb9			 
0bb9			clear_display: 
0bb9 3e 20			ld a, ' ' 
0bbb c3 be 0b			jp fill_display 
0bbe			 
0bbe			; fill active frame buffer with a char in A 
0bbe			 
0bbe			fill_display: 
0bbe 06 a0			ld b,display_fb_len 
0bc0 2a cc eb			ld hl, (display_fb_active) 
0bc3 77			.fd1:	ld (hl),a 
0bc4 23				inc hl 
0bc5 10 fc			djnz .fd1 
0bc7 23				inc hl 
0bc8 3e 00			ld a,0 
0bca 77				ld (hl),a 
0bcb			 
0bcb			 
0bcb c9				ret 
0bcc			; Write string (DE) at pos (A) to active frame buffer 
0bcc			 
0bcc 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bcf 06 00					ld b,0 
0bd1 4f					ld c,a 
0bd2 09					add hl,bc 
0bd3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd4 b7			            OR   A              ;Null terminator? 
0bd5 c8			            RET  Z              ;Yes, so finished 
0bd6 77					ld (hl),a 
0bd7 23				inc hl 
0bd8 13			            INC  DE             ;Point to next character 
0bd9 18 f8		            JR   .sad1     ;Repeat 
0bdb c9					ret 
0bdc			 
0bdc			; using current frame buffer write to physical display 
0bdc			 
0bdc			update_display: 
0bdc e5				push hl 
0bdd 2a cc eb			ld hl, (display_fb_active) 
0be0 cd 8c 67			call write_display 
0be3 e1				pop hl 
0be4 c9				ret 
0be5			 
0be5			; TODO scrolling 
0be5			 
0be5			 
0be5			; move cursor right one char 
0be5			cursor_right: 
0be5			 
0be5				; TODO shift right 
0be5				; TODO if beyond max col 
0be5				; TODO       cursor_next_line 
0be5			 
0be5 c9				ret 
0be6			 
0be6			 
0be6			cursor_next_line: 
0be6				; TODO first char 
0be6				; TODO line down 
0be6				; TODO if past last row 
0be6				; TODO    scroll up 
0be6			 
0be6 c9				ret 
0be7			 
0be7			cursor_left: 
0be7				; TODO shift left 
0be7				; TODO if beyond left  
0be7				; TODO     cursor prev line 
0be7				 
0be7 c9				ret 
0be8			 
0be8			cursor_prev_line: 
0be8				; TODO last char 
0be8				; TODO line up 
0be8				; TODO if past first row 
0be8				; TODO   scroll down 
0be8			 
0be8 c9				ret 
0be9			 
0be9			 
0be9			cout: 
0be9				; A - char 
0be9 c9				ret 
0bea			 
0bea			 
0bea			; Display a menu and allow item selection (optional toggle items) 
0bea			; 
0bea			; format: 
0bea			; hl pointer to word array with zero term for items 
0bea			; e.g.    db item1 
0bea			;         db .... 
0bea			;         db 0 
0bea			; 
0bea			; a = starting menu item  
0bea			; 
0bea			; de = pointer item toggle array   (todo) 
0bea			; 
0bea			; returns item selected in a 1-... 
0bea			; returns 0 if back button pressed 
0bea			; 
0bea			; NOTE: Uses system frame buffer to display 
0bea			; 
0bea			; LEFT, Q = go back 
0bea			; RIGHT, SPACE, CR = select 
0bea			; UP, A - Up 
0bea			; DOWN, Z - Down 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			menu: 
0bea			 
0bea					; keep array pointer 
0bea			 
0bea 22 73 ea				ld (store_tmp1), hl 
0bed 32 71 ea				ld (store_tmp2), a 
0bf0			 
0bf0					; check for key bounce 
0bf0			 
0bf0			if BASE_KEV 
0bf0			 
0bf0			.mbounce:	call cin 
0bf0					cp 0 
0bf0					jr nz, .mbounce 
0bf0			endif 
0bf0					; for ease use ex 
0bf0			 
0bf0					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf0 21 b1 ed				ld hl, display_fb0 
0bf3 22 cc eb				ld (display_fb_active), hl 
0bf6			 
0bf6 cd b9 0b		.mloop:		call clear_display 
0bf9 cd dc 0b				call update_display 
0bfc			 
0bfc					; draw selection id '>' at 1 
0bfc			 
0bfc					; init start of list display 
0bfc			 
0bfc 3e 05				ld a, 5 
0bfe 32 6f ea				ld (store_tmp3), a   ; display row count 
0c01 3a 71 ea				ld a,( store_tmp2) 
0c04 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c07			 
0c07					 
0c07			.mitem:	 
0c07			 
0c07			 
0c07 3a 72 ea				ld a,(store_tmp2+1) 
0c0a 6f					ld l, a 
0c0b 26 00				ld h, 0 
0c0d 29					add hl, hl 
0c0e ed 5b 73 ea			ld de, (store_tmp1) 
0c12 19					add hl, de 
0c13 7e					ld a, (hl) 
0c14 23					inc hl 
0c15 66					ld h,(hl) 
0c16 6f					ld l, a 
0c17			 
0c17 cd 0f 0e				call ishlzero 
0c1a 28 1a				jr z, .mdone 
0c1c			 
0c1c eb					ex de, hl 
0c1d 3a 6f ea				ld a, (store_tmp3) 
0c20 cd cc 0b				call str_at_display 
0c23					 
0c23			 
0c23					; next item 
0c23 3a 72 ea				ld a, (store_tmp2+1) 
0c26 3c					inc a 
0c27 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2a			 
0c2a			 		; next row 
0c2a			 
0c2a 3a 6f ea				ld a, (store_tmp3) 
0c2d c6 28				add display_cols 
0c2f 32 6f ea				ld (store_tmp3), a 
0c32			 
0c32					; at end of screen? 
0c32			 
0c32 fe 10				cp display_rows*4 
0c34 20 d1				jr nz, .mitem 
0c36			 
0c36			 
0c36			.mdone: 
0c36 cd 0f 0e				call ishlzero 
0c39 28 08				jr z, .nodn 
0c3b			 
0c3b 3e 78				ld a, display_row_4 
0c3d 11 bc 0c				ld de, .mdown 
0c40 cd cc 0b				call str_at_display 
0c43			 
0c43					; draw options to fill the screens with active item on line 1 
0c43					; if current option is 2 or more then display ^ in top 
0c43			 
0c43 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c46 fe 00				cp 0 
0c48 28 08				jr z, .noup 
0c4a			 
0c4a 3e 00				ld a, 0 
0c4c 11 ba 0c				ld de, .mup 
0c4f cd cc 0b				call str_at_display 
0c52			 
0c52 3e 02		.noup:		ld a, 2 
0c54 11 b8 0c				ld de, .msel 
0c57 cd cc 0b				call str_at_display 
0c5a			 
0c5a					; if current option + 1 is not null then display V in bottom 
0c5a					; get key 
0c5a cd dc 0b				call update_display 
0c5d			 
0c5d			 
0c5d					; handle key 
0c5d			 
0c5d cd 3e 68				call cin_wait 
0c60			 
0c60 fe 05				cp KEY_UP 
0c62 28 2b				jr z, .mgoup 
0c64 fe 61				cp 'a' 
0c66 28 27				jr z, .mgoup 
0c68 fe 0a				cp KEY_DOWN 
0c6a 28 32				jr z, .mgod 
0c6c fe 7a				cp 'z' 
0c6e 28 2e				jr z, .mgod 
0c70 fe 20				cp ' ' 
0c72 28 34				jr z, .goend 
0c74 fe 0c				cp KEY_RIGHT 
0c76 28 30				jr z, .goend 
0c78 fe 0d				cp KEY_CR 
0c7a 28 2c				jr z, .goend 
0c7c fe 71				cp 'q' 
0c7e 28 0b				jr z, .goback 
0c80			 
0c80 fe 0b				cp KEY_LEFT 
0c82 28 07				jr z, .goback 
0c84 fe 08				cp KEY_BS 
0c86 28 03				jr z, .goback 
0c88 c3 f6 0b				jp .mloop 
0c8b			 
0c8b			.goback: 
0c8b 3e 00			ld a, 0 
0c8d 18 1d			jr .goend2 
0c8f			 
0c8f				; move up one 
0c8f			.mgoup: 
0c8f 3a 71 ea				ld a, (store_tmp2) 
0c92 fe 00				cp 0 
0c94 ca f6 0b				jp z, .mloop 
0c97 3d					dec a 
0c98 32 71 ea				ld (store_tmp2), a 
0c9b c3 f6 0b				jp .mloop 
0c9e			 
0c9e				; move down one 
0c9e			.mgod: 
0c9e 3a 71 ea				ld a, (store_tmp2) 
0ca1 3c					inc a 
0ca2 32 71 ea				ld (store_tmp2), a 
0ca5 c3 f6 0b				jp .mloop 
0ca8			 
0ca8			 
0ca8			.goend: 
0ca8					; get selected item number 
0ca8			 
0ca8 3a 71 ea				ld a, (store_tmp2) 
0cab 3c					inc a 
0cac			 
0cac			.goend2: 
0cac f5					push af 
0cad			 
0cad					; restore active fb 
0cad					; TODO BUG assumes fb1 
0cad			 
0cad 21 10 ed				ld hl, display_fb1 
0cb0 22 cc eb				ld (display_fb_active), hl 
0cb3			 
0cb3					; restore main regs 
0cb3			 
0cb3			 
0cb3 cd dc 0b				call update_display 
0cb6			 
0cb6 f1					pop af 
0cb7			 
0cb7 c9				ret 
0cb8			 
0cb8 .. 00		.msel:   db ">",0 
0cba .. 00		.mup:   db "^",0 
0cbc .. 00		.mdown:   db "v",0 
0cbe			 
0cbe			 
0cbe			; eof 
0cbe			 
# End of file firmware_display.asm
0cbe			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbe			; random number generators 
0cbe			 
0cbe			 
0cbe			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbe			 
0cbe			 
0cbe			;-----> Generate a random number 
0cbe			; output a=answer 0<=a<=255 
0cbe			; all registers are preserved except: af 
0cbe			random: 
0cbe e5			        push    hl 
0cbf d5			        push    de 
0cc0 2a ab eb		        ld      hl,(randData) 
0cc3 ed 5f		        ld      a,r 
0cc5 57			        ld      d,a 
0cc6 5e			        ld      e,(hl) 
0cc7 19			        add     hl,de 
0cc8 85			        add     a,l 
0cc9 ac			        xor     h 
0cca 22 ab eb		        ld      (randData),hl 
0ccd d1			        pop     de 
0cce e1			        pop     hl 
0ccf c9			        ret 
0cd0			 
0cd0			 
0cd0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd0			 
0cd0			 
0cd0			 
0cd0			;------LFSR------ 
0cd0			;James Montelongo 
0cd0			;optimized by Spencer Putt 
0cd0			;out: 
0cd0			; a = 8 bit random number 
0cd0			RandLFSR: 
0cd0 21 b1 eb		        ld hl,LFSRSeed+4 
0cd3 5e			        ld e,(hl) 
0cd4 23			        inc hl 
0cd5 56			        ld d,(hl) 
0cd6 23			        inc hl 
0cd7 4e			        ld c,(hl) 
0cd8 23			        inc hl 
0cd9 7e			        ld a,(hl) 
0cda 47			        ld b,a 
0cdb cb 13		        rl e  
0cdd cb 12			rl d 
0cdf cb 11		        rl c  
0ce1 17				rla 
0ce2 cb 13		        rl e  
0ce4 cb 12			rl d 
0ce6 cb 11		        rl c  
0ce8 17				rla 
0ce9 cb 13		        rl e  
0ceb cb 12			rl d 
0ced cb 11		        rl c  
0cef 17				rla 
0cf0 67			        ld h,a 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 a8			        xor b 
0cf9 cb 13		        rl e  
0cfb cb 12			rl d 
0cfd ac			        xor h 
0cfe a9			        xor c 
0cff aa			        xor d 
0d00 21 b3 eb		        ld hl,LFSRSeed+6 
0d03 11 b4 eb		        ld de,LFSRSeed+7 
0d06 01 07 00		        ld bc,7 
0d09 ed b8		        lddr 
0d0b 12			        ld (de),a 
0d0c c9			        ret 
0d0d			 
0d0d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0d			 
0d0d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0d			 
0d0d			 
0d0d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0d			 
0d0d			prng16: 
0d0d			;Inputs: 
0d0d			;   (seed1) contains a 16-bit seed value 
0d0d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0d			;Outputs: 
0d0d			;   HL is the result 
0d0d			;   BC is the result of the LCG, so not that great of quality 
0d0d			;   DE is preserved 
0d0d			;Destroys: 
0d0d			;   AF 
0d0d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0d			;160cc 
0d0d			;26 bytes 
0d0d 2a a5 eb		    ld hl,(seed1) 
0d10 44			    ld b,h 
0d11 4d			    ld c,l 
0d12 29			    add hl,hl 
0d13 29			    add hl,hl 
0d14 2c			    inc l 
0d15 09			    add hl,bc 
0d16 22 a5 eb		    ld (seed1),hl 
0d19 2a a3 eb		    ld hl,(seed2) 
0d1c 29			    add hl,hl 
0d1d 9f			    sbc a,a 
0d1e e6 2d		    and %00101101 
0d20 ad			    xor l 
0d21 6f			    ld l,a 
0d22 22 a3 eb		    ld (seed2),hl 
0d25 09			    add hl,bc 
0d26 c9			    ret 
0d27			 
0d27			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d27			 
0d27			rand32: 
0d27			;Inputs: 
0d27			;   (seed1_0) holds the lower 16 bits of the first seed 
0d27			;   (seed1_1) holds the upper 16 bits of the first seed 
0d27			;   (seed2_0) holds the lower 16 bits of the second seed 
0d27			;   (seed2_1) holds the upper 16 bits of the second seed 
0d27			;   **NOTE: seed2 must be non-zero 
0d27			;Outputs: 
0d27			;   HL is the result 
0d27			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d27			;Destroys: 
0d27			;   AF 
0d27			;Tested and passes all CAcert tests 
0d27			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d27			;it has a period of 18,446,744,069,414,584,320 
0d27			;roughly 18.4 quintillion. 
0d27			;LFSR taps: 0,2,6,7  = 11000101 
0d27			;291cc 
0d27			;seed1_0=$+1 
0d27			;    ld hl,12345 
0d27			;seed1_1=$+1 
0d27			;    ld de,6789 
0d27			;    ld b,h 
0d27			;    ld c,l 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    inc l 
0d27			;    add hl,bc 
0d27			;    ld (seed1_0),hl 
0d27			;    ld hl,(seed1_1) 
0d27			;    adc hl,de 
0d27			;    ld (seed1_1),hl 
0d27			;    ex de,hl 
0d27			;seed2_0=$+1 
0d27			;    ld hl,9876 
0d27			;seed2_1=$+1 
0d27			;    ld bc,54321 
0d27			;    add hl,hl \ rl c \ rl b 
0d27			;    ld (seed2_1),bc 
0d27			;    sbc a,a 
0d27			;    and %11000101 
0d27			;    xor l 
0d27			;    ld l,a 
0d27			;    ld (seed2_0),hl 
0d27			;    ex de,hl 
0d27			;    add hl,bc 
0d27			;    ret 
0d27			; 
0d27			 
0d27			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d27			; 20 bytes, 86 cycles (excluding ret) 
0d27			 
0d27			; returns   hl = pseudorandom number 
0d27			; corrupts   a 
0d27			 
0d27			; generates 16-bit pseudorandom numbers with a period of 65535 
0d27			; using the xorshift method: 
0d27			 
0d27			; hl ^= hl << 7 
0d27			; hl ^= hl >> 9 
0d27			; hl ^= hl << 8 
0d27			 
0d27			; some alternative shift triplets which also perform well are: 
0d27			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d27			 
0d27			;  org 32768 
0d27			 
0d27			xrnd: 
0d27 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2a 3e 00		  ld a,0 
0d2c bd			  cp l 
0d2d 20 02		  jr nz, .xrnd1 
0d2f 2e 01		  ld l, 1 
0d31			.xrnd1: 
0d31			 
0d31 7c			  ld a,h 
0d32 1f			  rra 
0d33 7d			  ld a,l 
0d34 1f			  rra 
0d35 ac			  xor h 
0d36 67			  ld h,a 
0d37 7d			  ld a,l 
0d38 1f			  rra 
0d39 7c			  ld a,h 
0d3a 1f			  rra 
0d3b ad			  xor l 
0d3c 6f			  ld l,a 
0d3d ac			  xor h 
0d3e 67			  ld h,a 
0d3f			 
0d3f 22 a9 eb		  ld (xrandc),hl 
0d42			 
0d42 c9			  ret 
0d43			;  
0d43			 
0d43			 
0d43			;;;; int maths 
0d43			 
0d43			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d43			; Divide 16-bit values (with 16-bit result) 
0d43			; In: Divide BC by divider DE 
0d43			; Out: BC = result, HL = rest 
0d43			; 
0d43			Div16: 
0d43 21 00 00		    ld hl,0 
0d46 78			    ld a,b 
0d47 06 08		    ld b,8 
0d49			Div16_Loop1: 
0d49 17			    rla 
0d4a ed 6a		    adc hl,hl 
0d4c ed 52		    sbc hl,de 
0d4e 30 01		    jr nc,Div16_NoAdd1 
0d50 19			    add hl,de 
0d51			Div16_NoAdd1: 
0d51 10 f6		    djnz Div16_Loop1 
0d53 17			    rla 
0d54 2f			    cpl 
0d55 47			    ld b,a 
0d56 79			    ld a,c 
0d57 48			    ld c,b 
0d58 06 08		    ld b,8 
0d5a			Div16_Loop2: 
0d5a 17			    rla 
0d5b ed 6a		    adc hl,hl 
0d5d ed 52		    sbc hl,de 
0d5f 30 01		    jr nc,Div16_NoAdd2 
0d61 19			    add hl,de 
0d62			Div16_NoAdd2: 
0d62 10 f6		    djnz Div16_Loop2 
0d64 17			    rla 
0d65 2f			    cpl 
0d66 41			    ld b,c 
0d67 4f			    ld c,a 
0d68 c9			ret 
0d69			 
0d69			 
0d69			;http://z80-heaven.wikidot.com/math 
0d69			; 
0d69			;Inputs: 
0d69			;     DE and A are factors 
0d69			;Outputs: 
0d69			;     A is not changed 
0d69			;     B is 0 
0d69			;     C is not changed 
0d69			;     DE is not changed 
0d69			;     HL is the product 
0d69			;Time: 
0d69			;     342+6x 
0d69			; 
0d69			Mult16: 
0d69			 
0d69 06 08		     ld b,8          ;7           7 
0d6b 21 00 00		     ld hl,0         ;10         10 
0d6e 29			       add hl,hl     ;11*8       88 
0d6f 07			       rlca          ;4*8        32 
0d70 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d72 19			         add hl,de   ;--         -- 
0d73 10 f9		       djnz $-5      ;13*7+8     99 
0d75 c9			ret 
0d76			 
0d76			; 
0d76			; Square root of 16-bit value 
0d76			; In:  HL = value 
0d76			; Out:  D = result (rounded down) 
0d76			; 
0d76			;Sqr16: 
0d76			;    ld de,#0040 
0d76			;    ld a,l 
0d76			;    ld l,h 
0d76			;    ld h,d 
0d76			;    or a 
0d76			;    ld b,8 
0d76			;Sqr16_Loop: 
0d76			;    sbc hl,de 
0d76			;    jr nc,Sqr16_Skip 
0d76			;    add hl,de 
0d76			;Sqr16_Skip: 
0d76			;    ccf 
0d76			;    rl d 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    djnz Sqr16_Loop 
0d76			;    ret 
0d76			; 
0d76			; 
0d76			; Divide 8-bit values 
0d76			; In: Divide E by divider C 
0d76			; Out: A = result, B = rest 
0d76			; 
0d76			Div8: 
0d76 af			    xor a 
0d77 06 08		    ld b,8 
0d79			Div8_Loop: 
0d79 cb 13		    rl e 
0d7b 17			    rla 
0d7c 91			    sub c 
0d7d 30 01		    jr nc,Div8_NoAdd 
0d7f 81			    add a,c 
0d80			Div8_NoAdd: 
0d80 10 f7		    djnz Div8_Loop 
0d82 47			    ld b,a 
0d83 7b			    ld a,e 
0d84 17			    rla 
0d85 2f			    cpl 
0d86 c9			    ret 
0d87			 
0d87			; 
0d87			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d87			; In: Multiply A with DE 
0d87			; Out: HL = result 
0d87			; 
0d87			Mult12U: 
0d87 2e 00		    ld l,0 
0d89 87			    add a,a 
0d8a 30 01		    jr nc,Mult12U_NoAdd0 
0d8c 19			    add hl,de 
0d8d			Mult12U_NoAdd0: 
0d8d 29			    add hl,hl 
0d8e 87			    add a,a 
0d8f 30 01		    jr nc,Mult12U_NoAdd1 
0d91 19			    add hl,de 
0d92			Mult12U_NoAdd1: 
0d92 29			    add hl,hl 
0d93 87			    add a,a 
0d94 30 01		    jr nc,Mult12U_NoAdd2 
0d96 19			    add hl,de 
0d97			Mult12U_NoAdd2: 
0d97 29			    add hl,hl 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd3 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd3: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd4 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd4: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd5 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd5: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd6 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd6: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad d0			    ret nc 
0dae 19			    add hl,de 
0daf c9			    ret 
0db0			 
0db0			; 
0db0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db0			; In: Multiply A with DE 
0db0			;      Put lowest value in A for most efficient calculation 
0db0			; Out: HL = result 
0db0			; 
0db0			Mult12R: 
0db0 21 00 00		    ld hl,0 
0db3			Mult12R_Loop: 
0db3 cb 3f		    srl a 
0db5 30 01		    jr nc,Mult12R_NoAdd 
0db7 19			    add hl,de 
0db8			Mult12R_NoAdd: 
0db8 cb 23		    sla e 
0dba cb 12		    rl d 
0dbc b7			    or a 
0dbd c2 b3 0d		    jp nz,Mult12R_Loop 
0dc0 c9			    ret 
0dc1			 
0dc1			; 
0dc1			; Multiply 16-bit values (with 32-bit result) 
0dc1			; In: Multiply BC with DE 
0dc1			; Out: BCHL = result 
0dc1			; 
0dc1			Mult32: 
0dc1 79			    ld a,c 
0dc2 48			    ld c,b 
0dc3 21 00 00		    ld hl,0 
0dc6 06 10		    ld b,16 
0dc8			Mult32_Loop: 
0dc8 29			    add hl,hl 
0dc9 17			    rla 
0dca cb 11		    rl c 
0dcc 30 07		    jr nc,Mult32_NoAdd 
0dce 19			    add hl,de 
0dcf ce 00		    adc a,0 
0dd1 d2 d5 0d		    jp nc,Mult32_NoAdd 
0dd4 0c			    inc c 
0dd5			Mult32_NoAdd: 
0dd5 10 f1		    djnz Mult32_Loop 
0dd7 41			    ld b,c 
0dd8 4f			    ld c,a 
0dd9 c9			    ret 
0dda			 
0dda			 
0dda			 
0dda			; 
0dda			; Multiply 8-bit values 
0dda			; In:  Multiply H with E 
0dda			; Out: HL = result 
0dda			; 
0dda			Mult8: 
0dda 16 00		    ld d,0 
0ddc 6a			    ld l,d 
0ddd 06 08		    ld b,8 
0ddf			Mult8_Loop: 
0ddf 29			    add hl,hl 
0de0 30 01		    jr nc,Mult8_NoAdd 
0de2 19			    add hl,de 
0de3			Mult8_NoAdd: 
0de3 10 fa		    djnz Mult8_Loop 
0de5 c9			    ret 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			;;http://z80-heaven.wikidot.com/math 
0de6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de6			; 
0de6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de6			;     ld a,16        ;7 
0de6			;     ld hl,0        ;10 
0de6			;     jp $+5         ;10 
0de6			;.DivLoop: 
0de6			;       add hl,bc    ;-- 
0de6			;       dec a        ;64 
0de6			;       jr z,.DivLoopEnd        ;86 
0de6			; 
0de6			;       sla e        ;128 
0de6			;       rl d         ;128 
0de6			;       adc hl,hl    ;240 
0de6			;       sbc hl,bc    ;240 
0de6			;       jr nc,.DivLoop ;23|21 
0de6			;       inc e        ;-- 
0de6			;       jp .DivLoop+1 
0de6			; 
0de6			;.DivLoopEnd: 
0de6			 
0de6			;HL_Div_C: 
0de6			;Inputs: 
0de6			;     HL is the numerator 
0de6			;     C is the denominator 
0de6			;Outputs: 
0de6			;     A is the remainder 
0de6			;     B is 0 
0de6			;     C is not changed 
0de6			;     DE is not changed 
0de6			;     HL is the quotient 
0de6			; 
0de6			;       ld b,16 
0de6			;       xor a 
0de6			;         add hl,hl 
0de6			;         rla 
0de6			;         cp c 
0de6			;         jr c,$+4 
0de6			;           inc l 
0de6			;           sub c 
0de6			;         djnz $-7 
0de6			 
0de6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de6			 
0de6			addatohl: 
0de6 85			    add   a, l    ; A = A+L 
0de7 6f			    ld    l, a    ; L = A+L 
0de8 8c			    adc   a, h    ; A = A+L+H+carry 
0de9 95			    sub   l       ; A = H+carry 
0dea 67			    ld    h, a    ; H = H+carry 
0deb c9			ret 
0dec			 
0dec			addatode: 
0dec 83			    add   a, e    ; A = A+L 
0ded 5f			    ld    e, a    ; L = A+L 
0dee 8a			    adc   a, d    ; A = A+L+H+carry 
0def 93			    sub   e       ; A = H+carry 
0df0 57			    ld    d, a    ; H = H+carry 
0df1 c9			ret 
0df2			 
0df2			 
0df2			addatobc: 
0df2 81			    add   a, c    ; A = A+L 
0df3 4f			    ld    c, a    ; L = A+L 
0df4 88			    adc   a, b    ; A = A+L+H+carry 
0df5 91			    sub   c       ; A = H+carry 
0df6 47			    ld    b, a    ; H = H+carry 
0df7 c9			ret 
0df8			 
0df8			subafromhl: 
0df8			   ; If A=0 do nothing 
0df8			    ; Otherwise flip A's sign. Since 
0df8			    ; the upper byte becomes -1, also 
0df8			    ; substract 1 from H. 
0df8 ed 44		    neg 
0dfa ca 03 0e		    jp    z, Skip 
0dfd 25			    dec   h 
0dfe			     
0dfe			    ; Now add the low byte as usual 
0dfe			    ; Two's complement takes care of 
0dfe			    ; ensuring the result is correct 
0dfe 85			    add   a, l 
0dff 6f			    ld    l, a 
0e00 8c			    adc   a, h 
0e01 95			    sub   l 
0e02 67			    ld    h, a 
0e03			Skip: 
0e03 c9				ret 
0e04			 
0e04			 
0e04			; compare hl and de 
0e04			; returns:  
0e04			; if hl = de, z=1, s=0, c0=0 
0e04			; if hl > de, z=0, s=0, c=0 
0e04			; if hl < de, z=0, s=1, c=1 
0e04			cmp16:	 
0e04 b7				or a 
0e05 ed 52			sbc hl,de 
0e07 e0				ret po 
0e08 7c				ld a,h 
0e09 1f				rra 
0e0a ee 40			xor 01000000B 
0e0c 37				scf 
0e0d 8f				adc a,a 
0e0e c9				ret 
0e0f			 
0e0f			 
0e0f			; test if hl contains zero   - A is destroyed 
0e0f			 
0e0f			ishlzero:    
0e0f b7				or a     ; reset flags 
0e10 7c				ld a, h 
0e11 b5				or l        	 
0e12			 
0e12 c9				ret 
0e13			 
0e13			 
0e13			 
0e13			 
0e13			if FORTH_ENABLE_FLOATMATH 
0e13			;include "float/bbcmath.z80" 
0e13			include "float/lpfpcalc.asm" 
0e13			endif 
0e13			 
0e13			 
0e13			; eof 
0e13			 
# End of file firmware_maths.asm
0e13			include "firmware_strings.asm"   ; string handling  
0e13			 
0e13			 
0e13			; TODO string len 
0e13			; input text string, end on cr with zero term 
0e13			; a offset into frame buffer to start prompt 
0e13			; d is max length 
0e13			; e is display size TODO 
0e13			; c is current cursor position 
0e13			; hl is ptr to where string will be stored and edited directly 
0e13			 
0e13			 
0e13			; TODO check limit of buffer for new inserts 
0e13			; TODO check insert does not push beyond buffer 
0e13			; TODO scroll in a limited display area 
0e13			; TODO scroll whole screen on page wrap 
0e13			 
0e13			 
0e13			; TODO use LCD cursor? 
0e13			 
0e13			EDIT_V1: equ 0 
0e13			EDIT_V2: equ 1 
0e13			 
0e13			 
0e13			 
0e13			if EDIT_V2 
0e13			input_str: 
0e13			else 
0e13			input_str_new: 
0e13			endif 
0e13			 
0e13 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
0e16			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e16 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e19			;		ld a, c 
0e19			;		call addatohl 
0e19			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e19 7a					ld a,d 
0e1a 32 66 ee			        ld (input_size), a       ; save length of input area 
0e1d 79					ld a, c 
0e1e 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e21 7b					ld a,e 
0e22 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e25			 
0e25			 
0e25					; add a trailing space to make screen refresh nicer 
0e25			 
0e25					;ld hl, (input_start) 
0e25					;push hl 
0e25					;ld a, 0 
0e25					;call strlent 
0e25					;ld a, l 
0e25					;pop hl 
0e25					;call addatohl 
0e25					;dec hl 
0e25					;ld a, ' ' 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld a, 0 
0e25					;ld (hl), a 
0e25			 
0e25			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e25					; init cursor shape if not set by the cin routines 
0e25 21 c1 eb				ld hl, cursor_shape 
0e28			if BASE_KEV 
0e28					ld a, 255 
0e28			else 
0e28 3e 23				ld a, '#' 
0e2a			endif 
0e2a 77					ld (hl), a 
0e2b 23					inc hl 
0e2c 3e 00				ld a, 0 
0e2e 77					ld (hl), a 
0e2f			 
0e2f 3e 09				ld a, CUR_BLINK_RATE 
0e31 32 60 ee				ld (input_cur_flash), a 
0e34 3e 01				ld a, 1 
0e36 32 5f ee				ld (input_cur_onoff),a 
0e39			.inmain:	 
0e39			 
0e39 cd a5 0f				call input_disp_ref 
0e3c			 
0e3c					; save current length of string 
0e3c			 
0e3c 2a 67 ee				ld hl, (input_start) 
0e3f 3e 00				ld a, 0 
0e41 cd 67 14				call strlent 
0e44 7d					ld a,l 
0e45 32 5a ee				ld (input_len), a 
0e48			 
0e48					;call input_disp_oncur 
0e48			 
0e48					; display current state of input buffer 
0e48			 
0e48					; clean any backspace chars 
0e48			 
0e48 3e 5f				ld a, "_" 
0e4a 32 c1 e2				ld (scratch),a 
0e4d 3e 00				ld a, 0 
0e4f 32 c2 e2				ld (scratch+1),a 
0e52 3a 64 ee				ld a,(input_at_pos) 
0e55 85					add l 
0e56 11 c1 e2				ld de, scratch 
0e59 cd cc 0b				call str_at_display 
0e5c			 
0e5c					; pause 1ms 
0e5c			 
0e5c 3e 01				ld a, 1 
0e5e cd d6 0a				call aDelayInMS 
0e61			 
0e61			; display cursor if visible on this cycle 
0e61			 
0e61					; dec flash counter 
0e61 3a 60 ee				ld a, (input_cur_flash) 
0e64 3d					dec a 
0e65 32 60 ee				ld (input_cur_flash), a 
0e68 fe 00				cp 0 
0e6a 20 0d				jr nz, .inochgstate 
0e6c			 
0e6c			 
0e6c					; reset on change of state 
0e6c 3e 09				ld a, CUR_BLINK_RATE 
0e6e 32 60 ee				ld (input_cur_flash), a 
0e71			 
0e71					; change state 
0e71 3a 5f ee				ld a,(input_cur_onoff) 
0e74 ed 44				neg 
0e76 32 5f ee				ld (input_cur_onoff),a 
0e79			 
0e79			 
0e79			 
0e79			 
0e79					; TODO is cursor visible? 
0e79					; TODO if so then over write the char at curspos pos with the cursor shape 
0e79			 
0e79								 
0e79			 
0e79			.inochgstate: 
0e79 3a 5f ee				ld a,(input_cur_onoff) 
0e7c fe ff				cp 255 
0e7e 28 0e				jr z, .skipcursor 
0e80 3a 64 ee				ld a, (input_at_pos) 
0e83 47					ld b, a 
0e84 3a 55 ee				ld a, (input_cursor) 
0e87 80					add b 
0e88 11 c1 eb				ld de, cursor_shape 
0e8b					 
0e8b cd cc 0b				call str_at_display 
0e8e			 
0e8e			.skipcursor: 
0e8e				if DEBUG_INPUTV2 
0e8e			 
0e8e 3a 64 ee				ld a,(input_at_pos) 
0e91 21 ad eb				ld hl, LFSRSeed 
0e94 cd ff 12				call hexout 
0e97 3a 55 ee				ld a, (input_cursor) 
0e9a 21 af eb				ld hl, LFSRSeed+2 
0e9d cd ff 12				call hexout 
0ea0 3a 66 ee				ld a,(input_size) 
0ea3 21 b1 eb				ld hl, LFSRSeed+4 
0ea6 cd ff 12				call hexout 
0ea9			 
0ea9 3a 5f ee				ld a,(input_cur_onoff) 
0eac 21 b3 eb				ld hl, LFSRSeed+6 
0eaf cd ff 12				call hexout 
0eb2			 
0eb2 3a 60 ee				ld a,(input_cur_flash) 
0eb5 21 b5 eb				ld hl, LFSRSeed+8 
0eb8 cd ff 12				call hexout 
0ebb			 
0ebb 3a 5a ee				ld a,(input_len) 
0ebe 21 b7 eb				ld hl, LFSRSeed+10 
0ec1 cd ff 12				call hexout 
0ec4 21 b9 eb				ld hl, LFSRSeed+12 
0ec7 3e 00				ld a, 0 
0ec9 77					ld (hl),a 
0eca 3e 78				ld a, display_row_4 
0ecc 11 ad eb				ld de, LFSRSeed 
0ecf cd cc 0b				call str_at_display 
0ed2				endif 
0ed2 cd dc 0b				call update_display 
0ed5			 
0ed5					; TODO keyboard processing 
0ed5			 
0ed5			if BASE_CPM 
0ed5 cd 3e 68				call cin_wait 
0ed8			else 
0ed8					call cin    ; _wait 
0ed8			endif 
0ed8 fe 00				cp 0 
0eda ca 39 0e				jp z, .inmain 
0edd			 
0edd fe 0b				cp KEY_LEFT    ; cursor left 
0edf ca 97 0f				jp z, input_left 
0ee2				 
0ee2 fe 0c				cp KEY_RIGHT      ; cursor right 
0ee4 ca 9e 0f				jp z, input_right 
0ee7			 
0ee7 fe 0d				cp KEY_CR 
0ee9 c8					ret z 
0eea			 
0eea fe 08				cp KEY_BS 
0eec ca 0c 10				jp z, input_delchar 
0eef			 
0eef fe 06				cp KEY_NEXTWORD 
0ef1 ca 2a 0f				jp z, input_nxtword 
0ef4			 
0ef4 fe 07				cp KEY_PREVWORD 
0ef6 ca 51 0f				jp z, input_prvword 
0ef9 fe 10				cp KEY_F1 
0efb ca 51 0f				jp z, input_prvword 
0efe			.inskl: 
0efe fe 0e				cp KEY_HOME    ; jump to start of line 
0f00 20 08				jr nz, .ikh 
0f02 3e 00				ld a, 0 
0f04 32 55 ee				ld (input_cursor), a 
0f07 ca 39 0e				jp z, .inmain 
0f0a			.ikh: 
0f0a			 
0f0a fe 0f				cp KEY_END     ; jump to end of line 
0f0c 20 09				jr nz, .ike 
0f0e 3a 5a ee				ld a, (input_len) 
0f11 32 55 ee				ld (input_cursor),a 
0f14 ca 39 0e				jp z, .inmain 
0f17			.ike: 
0f17 fe 05			        cp KEY_UP      ; recall last command 
0f19 20 0c				jr nz, .irec 
0f1b			; TODO next word 
0f1b			; TODO prev word 
0f1b			;  
0f1b			; 
0f1b 21 c1 e2			ld hl, scratch 
0f1e 11 e7 e6			ld de, os_last_cmd 
0f21 cd f5 12			call strcpy 
0f24 ca 39 0e				jp z, .inmain 
0f27			.irec: 
0f27			;		jr .instr1 
0f27			 
0f27			 
0f27					; if no special key then insert as a char 
0f27			 
0f27 c3 de 0f				jp input_inschr 
0f2a			 
0f2a				 
0f2a			input_nxtword: 
0f2a				; jump to start next word after the cursor 
0f2a			 
0f2a			.insknwn:	 
0f2a cd d4 0f				call input_curptr	 
0f2d 7e					ld a,(hl)	 
0f2e fe 00				cp 0 
0f30 ca 39 0e				jp z, .inmain    ; end of string 
0f33			 
0f33			; if we are on a word, then move off of it 
0f33			 
0f33 fe 20				cp ' ' 
0f35 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0f37 21 55 ee				ld hl, input_cursor 
0f3a 34					inc (hl) 
0f3b 18 ed				jr .insknwn 
0f3d			 
0f3d			.inspace: 
0f3d			 
0f3d cd d4 0f				call input_curptr	 
0f40 7e					ld a,(hl)	 
0f41 fe 00				cp 0 
0f43 ca 39 0e				jp z, .inmain    ; end of string 
0f46			 
0f46			; if we are on a word, then move off of it 
0f46			 
0f46 fe 20				cp ' ' 
0f48 c2 39 0e				jp nz, .inmain     ; we are on non space so at next word 
0f4b 21 55 ee				ld hl, input_cursor 
0f4e 34					inc (hl) 
0f4f 18 ec				jr .inspace 
0f51			 
0f51			 
0f51			 
0f51			 
0f51			input_prvword: 
0f51				; jump to the start of previous word before the cursor 
0f51			.inskpwn:	 
0f51 3a 55 ee				ld a,(input_cursor) 
0f54 fe 00				cp 0 
0f56 ca 39 0e				jp z, .inmain    ; start of string 
0f59			 
0f59			; if we are on a word, then move off of it 
0f59			 
0f59 cd d4 0f				call input_curptr	 
0f5c fe 20				cp ' ' 
0f5e 28 06				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0f60					;jp z, .inmain    ; start of string 
0f60 21 55 ee				ld hl, input_cursor 
0f63 35					dec (hl) 
0f64 18 eb				jr .inskpwn 
0f66			 
0f66			.inspacep: 
0f66			 
0f66 3a 55 ee				ld a,(input_cursor) 
0f69 fe 00				cp 0 
0f6b ca 39 0e				jp z, .inmain    ; start of string 
0f6e			 
0f6e			; if we are on a word, then move off of it 
0f6e			 
0f6e cd d4 0f				call input_curptr	 
0f71 fe 20				cp ' ' 
0f73 c2 7c 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f76 21 55 ee				ld hl, input_cursor 
0f79 35					dec (hl) 
0f7a 18 ea				jr .inspacep 
0f7c			 
0f7c			 
0f7c			.incharp:	 
0f7c					; eat the word to get to the start 
0f7c 3a 55 ee				ld a,(input_cursor) 
0f7f fe 00				cp 0 
0f81 ca 39 0e				jp z, .inmain    ; start of string 
0f84			 
0f84			; if we are on a word, then move off of it 
0f84			 
0f84 cd d4 0f				call input_curptr	 
0f87 fe 20				cp ' ' 
0f89 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f8b 21 55 ee				ld hl, input_cursor 
0f8e 35					dec (hl) 
0f8f 18 eb				jr .incharp 
0f91			.ipwordst: 
0f91					; at space before the prev word so reposition over it 
0f91 21 55 ee				ld hl, input_cursor 
0f94 34					inc (hl) 
0f95 18 ba				jr .inskpwn 
0f97					 
0f97			 
0f97			 
0f97			input_left: 
0f97				; move cursor left 
0f97 21 55 ee			ld hl, input_cursor 
0f9a 35				dec (hl) 
0f9b			;	cp 0 
0f9b			;	jp z, .inmain    ; ignore left as at the start of the string 
0f9b c3 39 0e			jp .inmain 
0f9e			 
0f9e			input_right: 
0f9e				; move cursor right 
0f9e				 
0f9e				;ld a, (input_size) 
0f9e				;ld b, a 
0f9e 21 55 ee			ld hl, input_cursor 
0fa1 34				inc (hl) 
0fa2				;dec b 
0fa2				;cp 0 
0fa2				;jp z, .inmain   ; ignore as at end of the string buffer 
0fa2				;ld a, b 
0fa2				;inc a 
0fa2				;ld (input_cursor), a 
0fa2 c3 39 0e			jp .inmain 
0fa5			 
0fa5			 
0fa5			 
0fa5			input_disp_ref: 
0fa5				; display the text from start of buffer (ie full refresh) 
0fa5 3a 64 ee			ld a, (input_at_pos) 
0fa8 2a 67 ee			ld hl,(input_start) 
0fab eb				ex de, hl 
0fac cd cc 0b			call str_at_display  
0faf c9				ret 
0fb0			input_disp_oncur: 
0fb0				; display the text from cursor position to end of buffer 
0fb0				; TODO position start of string at cursor position on screen 
0fb0				; TODO draw from that point on 
0fb0 3a 55 ee			ld a, (input_cursor) 
0fb3 47				ld b, a 
0fb4 3a 64 ee			ld a, (input_at_pos) 
0fb7 80				add b 
0fb8 48				ld c, b     ; save a 
0fb9 78				ld a, b     ; inc string start for cursor 
0fba 2a 67 ee			ld hl,(input_start) 
0fbd cd e6 0d			call addatohl 
0fc0 eb				ex de, hl 
0fc1 79				ld a, c 
0fc2 cd cc 0b			call str_at_display  
0fc5 c9				ret 
0fc6			 
0fc6			input_nxtw: 
0fc6				; Find next word 
0fc6 c9				ret 
0fc7			 
0fc7			input_prvw: 
0fc7				; Find previous word 
0fc7 c9				ret 
0fc8			 
0fc8			input_lenrem:   
0fc8				; Calculate the length of string remaining from current cursor 
0fc8				; position to end of buffer (exc null term) 
0fc8				 
0fc8 3a 55 ee			ld a, (input_cursor) 
0fcb 4f				ld c, a 
0fcc 3a 66 ee			ld a, (input_size) 
0fcf 91				sub c 
0fd0 06 00			ld b, 0 
0fd2 0d				dec c 
0fd3 c9				ret	 
0fd4			 
0fd4			input_curptr: 
0fd4				; calc address of the character under the cursor 
0fd4				 
0fd4 2a 67 ee			ld hl, (input_start) 
0fd7 3a 55 ee			ld a, (input_cursor) 
0fda cd e6 0d			call addatohl 
0fdd c9				ret 
0fde			 
0fde			input_inschr: 
0fde				; Insert char at cursor position 
0fde f5				push af   ; save char 
0fdf				;call input_lenrem    ; get bc length of remaining string 
0fdf			 
0fdf				 
0fdf cd d4 0f			call input_curptr 
0fe2			;	ld hl, (input_start) 
0fe2			;	ld a, (input_cursor) 
0fe2			;	call addatohl 
0fe2				;push hl   ; save to come back to 
0fe2			 
0fe2				; shift everything up one to end of buffer 
0fe2			 
0fe2				;push hl 
0fe2				;dec de 
0fe2				;inc de 
0fe2			;	ldir 
0fe2				 
0fe2				;pop hl 
0fe2			 
0fe2				; are we adding to the end of line? 
0fe2			 
0fe2 3a 55 ee			ld a, (input_cursor) 
0fe5 47				ld b, a 
0fe6 3a 5a ee			ld a, (input_len) 
0fe9 b8				cp b 
0fea 20 09			jr nz, .insmid   ; no, insert in middle of text 
0fec			 
0fec				; tack on the end of the line 
0fec f1				pop af 
0fed 77				ld (hl), a   ; save new char 
0fee 23				inc hl 
0fef 3e 00			ld a, 0 
0ff1 77				ld (hl), a 
0ff2 c3 9e 0f			jp input_right 
0ff5				 
0ff5			.insmid: 
0ff5				; hl has insertion point so move everything up one to allow for insertion 
0ff5				;call input_shiftright 
0ff5 f1				pop af 
0ff6			 
0ff6			.shufinsmid: 
0ff6 47				ld b, a     ; b contains new char, c prev char at this position  
0ff7 7e				ld a, (hl) 
0ff8			 
0ff8 fe 00			cp 0    ; at end of string need to then dump new char and add term 
0ffa 28 07			jr z, .endinsmid 
0ffc 4f				ld c, a 
0ffd 78				ld a, b 
0ffe 77				ld (hl), a 
0fff 23				inc hl 
1000 79				ld a, c 
1001 18 f3			jr .shufinsmid 
1003				 
1003			 
1003			 
1003			 
1003			.endinsmid: 
1003 78				ld a, b 
1004 77				ld (hl), a 
1005 23				inc hl 
1006 3e 00			ld a, 0 
1008 77				ld (hl), a 
1009			 
1009			 
1009			;	ld (hl), a   ; save new char 
1009			 
1009 c3 9e 0f			jp input_right 
100c			 
100c			;input_shiftright: 
100c			;	; shift text right at cursor, hl has shift start 
100c			;	push hl 
100c			;	push de 
100c			;	push bc 
100c			; 
100c			; 
100c			;	; move to end of string past zero term 
100c			;	ld hl,(input_start) 
100c			;	ld a, (input_len) 
100c			;	call addatohl 
100c			;	inc hl 
100c			;;	inc hl 
100c			;;	inc hl 
100c			;	ld a, 0 
100c			;	ld (hl), a 
100c			;;	dec hl 
100c			;	 
100c			;;	ld (hl), a 
100c			;;	dec hl 
100c			; 
100c			;	push hl 
100c			;	pop de 
100c			;	inc de 
100c			;	 
100c			; 
100c			;;	ld hl,(input_start) 
100c			;;	ld a, (input_cursor) 
100c			;;	call addatohl 
100c			; 
100c			; 
100c			;	; calc how many bytes from cursor pos to end of string we need to shift 
100c			;	call input_lenrem    ; get bc length of remaining string 
100c			;	;ld a, (input_cursor) 
100c			;	;ld c, a 
100c			;	ld a, (input_len) 
100c			;	cp 2 
100c			;	jr z, .iskipzero	 
100c			;	;sub c 
100c			;	;inc a 
100c			;	;ld c, a 
100c			;	;ld b, 0 
100c			;	inc c 
100c			;	inc c 
100c			;	; move data 
100c			;	lddr 
100c			;.iskipzero: 
100c			; 
100c			;	pop bc 
100c			;	pop de 
100c			;	pop hl 
100c			;	ret	 
100c			 
100c			input_delchar: 
100c				; Delete char at cursor position 
100c cd c8 0f			call input_lenrem    ; get bc length of remaining string 
100f 2a 67 ee			ld hl, (input_start) 
1012 3a 55 ee			ld a, (input_cursor) 
1015 cd e6 0d			call addatohl 
1018			 
1018 e5				push hl 
1019 d1				pop de 
101a 1b				dec de 
101b			 
101b			.dl:	 
101b ed a0			ldi  
101d 7e				ld a, (hl) 
101e fe 00			cp 0 
1020 28 02			jr z, .dldone 
1022 18 f7			jr .dl 
1024			.dldone: 
1024 ed a0			ldi 
1026			 
1026 c3 97 0f			jp input_left 
1029			 
1029			 
1029			 
1029			 
1029			 
1029			if EDIT_V1 
1029			input_str: 
1029			else 
1029			input_str_old: 
1029			endif 
1029			 
1029 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
102c 81					add c 
102d 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
1030 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
1033 79					ld a, c 
1034 cd e6 0d				call addatohl 
1037 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
103a 7a					ld a,d 
103b 32 66 ee			        ld (input_size), a       ; save length of input area 
103e 79					ld a, c 
103f 32 55 ee				ld (input_cursor),a      ; init cursor start position  
1042 7b					ld a,e 
1043 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
1046					 
1046					 
1046			 
1046			;		ld a,(input_ptr) 
1046			;		ld (input_under_cursor),a 	; save what is under the cursor 
1046			 
1046			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
1046					; init cursor shape if not set by the cin routines 
1046 21 c1 eb				ld hl, cursor_shape 
1049			if BASE_KEV 
1049					ld a, 255 
1049			else 
1049 3e 23				ld a, '#' 
104b			endif 
104b 77					ld (hl), a 
104c 23					inc hl 
104d 3e 00				ld a, 0 
104f 77					ld (hl), a 
1050			 
1050 3e 09				ld a, CUR_BLINK_RATE 
1052 32 60 ee				ld (input_cur_flash), a 
1055 3e 01				ld a, 1 
1057 32 5f ee				ld (input_cur_onoff),a 
105a			 
105a			;	if DEBUG_INPUT 
105a			;		push af 
105a			;		ld a, 'I' 
105a			;		ld (debug_mark),a 
105a			;		pop af 
105a			;		CALLMONITOR 
105a			;	endif 
105a			.is1:		; main entry loop 
105a			 
105a			 
105a			 
105a					; pause 1ms 
105a			 
105a 3e 01				ld a, 1 
105c cd d6 0a				call aDelayInMS 
105f			 
105f					; dec flash counter 
105f 3a 60 ee				ld a, (input_cur_flash) 
1062 3d					dec a 
1063 32 60 ee				ld (input_cur_flash), a 
1066 fe 00				cp 0 
1068 20 0d				jr nz, .nochgstate 
106a			 
106a			 
106a					; change state 
106a 3a 5f ee				ld a,(input_cur_onoff) 
106d ed 44				neg 
106f 32 5f ee				ld (input_cur_onoff),a 
1072			 
1072			 
1072					; reset on change of state 
1072 3e 09				ld a, CUR_BLINK_RATE 
1074 32 60 ee				ld (input_cur_flash), a 
1077			 
1077			.nochgstate: 
1077					 
1077					 
1077			 
1077					; display cursor  
1077			 
1077			;		ld hl, (input_start) 
1077			;		ld a, (input_cursor) 
1077			;		call addatohl 
1077			 
1077					; get char under cursor and replace with cursor 
1077 2a 69 ee		ld hl, (input_ptr) 
107a			;		ld a, (hl) 
107a			;		ld (input_under_cursor),a 
107a			;		ld a, '_' 
107a			;		ld (hl), a 
107a			 
107a					; display string 
107a			 
107a ed 5b 67 ee			ld de, (input_start) 
107e 3a 64 ee				ld a, (input_at_pos) 
1081 cd cc 0b				call str_at_display 
1084			;	        call update_display 
1084			 
1084					; find place to put the cursor 
1084			;		add h 
1084			;		ld l, display_row_1 
1084			;		sub l 
1084			; (input_at_pos) 
1084					;ld c, a 
1084			;		ld a, (input_cursor) 
1084			;		ld l, (input_at_pos) 
1084			;		;ld b, h 
1084			;		add l 
1084			;		ld (input_at_cursor),a 
1084					;ld l,h 
1084			 
1084			;		ld h, 0 
1084			;		ld l,(input_at_pos) 
1084			;		ld a, (input_cursor) 
1084			;		call addatohl 
1084			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
1084			;		call subafromhl 
1084			;		ld a,l 
1084			;		ld (input_at_cursor), a 
1084			 
1084				if DEBUG_INPUT 
1084					ld a, (hardware_diag) 
1084					cp 0 
1084					jr z, .skip_input_diag 
1084			 
1084					ld a,(input_at_pos) 
1084					ld hl, LFSRSeed 
1084					call hexout 
1084					ld a, (input_cursor) 
1084					ld hl, LFSRSeed+2 
1084					call hexout 
1084					ld a,(input_at_cursor) 
1084					ld hl, LFSRSeed+4 
1084					call hexout 
1084			 
1084					ld a,(input_cur_onoff) 
1084					ld hl, LFSRSeed+6 
1084					call hexout 
1084			 
1084					ld a,(input_cur_flash) 
1084					ld hl, LFSRSeed+8 
1084					call hexout 
1084			 
1084					ld a,(input_len) 
1084					ld hl, LFSRSeed+10 
1084					call hexout 
1084					ld hl, LFSRSeed+12 
1084					ld a, 0 
1084					ld (hl),a 
1084					ld a, display_row_4 
1084					ld de, LFSRSeed 
1084					call str_at_display 
1084					.skip_input_diag: 
1084				endif 
1084			 
1084					; decide on if we are showing the cursor this time round 
1084			 
1084 3a 5f ee				ld a, (input_cur_onoff) 
1087 fe ff				cp 255 
1089 28 15				jr z, .skipcur 
108b			 
108b			 
108b 3a 62 ee				ld a,(input_at_cursor) 
108e 11 c1 eb				ld de, cursor_shape 
1091 cd cc 0b				call str_at_display 
1094			 
1094					; save length of current input string 
1094 2a 67 ee				ld hl, (input_start) 
1097 3e 00				ld a, 0 
1099 cd 67 14				call strlent 
109c 7d					ld a,l 
109d 32 5a ee				ld (input_len),a 
10a0			 
10a0			.skipcur: 
10a0			 
10a0 cd dc 0b			        call update_display 
10a3					 
10a3			 
10a3			 
10a3					; wait 
10a3				 
10a3					; TODO loop without wait to flash the cursor and char under cursor	 
10a3 cd 46 68				call cin    ; _wait 
10a6			 
10a6 fe 00				cp 0 
10a8 ca 5a 10				jp z, .is1 
10ab			 
10ab					; get ptr to char to input into 
10ab			 
10ab 4f					ld c,a 
10ac 2a 67 ee				ld hl, (input_start) 
10af 3a 55 ee				ld a, (input_cursor) 
10b2 cd e6 0d				call addatohl 
10b5 22 69 ee				ld (input_ptr), hl 
10b8 79					ld a,c 
10b9			 
10b9					; replace char under cursor 
10b9			 
10b9			;		ld hl, (input_ptr) 
10b9			;		ld a, (input_under_cursor) 	; get what is under the cursor 
10b9			;		ld (hl), a 
10b9			 
10b9			;	if DEBUG_INPUT 
10b9			;		push af 
10b9			;		ld a, 'i' 
10b9			;		ld (debug_mark),a 
10b9			;		pop af 
10b9			;		CALLMONITOR 
10b9			;	endif 
10b9 fe 0e				cp KEY_HOME 
10bb 20 0e				jr nz, .iske 
10bd			 
10bd 3a 64 ee				ld a, (input_at_pos) 
10c0 32 62 ee				ld (input_at_cursor),a 
10c3 3e 00				ld a, 0 
10c5 32 55 ee				ld (input_cursor), a 
10c8 c3 5a 10				jp .is1 
10cb					 
10cb fe 0f		.iske:		cp KEY_END 
10cd 20 03				jr nz, .isknw 
10cf c3 5a 10				jp .is1 
10d2			 
10d2 fe 06		.isknw:		cp KEY_NEXTWORD 
10d4 20 1b				jr nz, .iskpw 
10d6			 
10d6 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
10d9 7e					ld a,(hl)	 
10da fe 00				cp 0 
10dc ca 5a 10				jp z, .is1    ; end of string 
10df fe 20				cp ' ' 
10e1 ca 5a 10				jp z, .is1    ; end of word 
10e4 23					inc hl 
10e5 22 69 ee				ld (input_ptr), hl 
10e8 3a 62 ee				ld a, (input_at_cursor) 
10eb 3c					inc a 
10ec 32 62 ee				ld (input_at_cursor), a 
10ef 18 e5				jr .isknwm 
10f1			 
10f1 fe 07		.iskpw:		cp KEY_PREVWORD 
10f3 20 1b				jr nz, .iskl 
10f5			.iskpwm:	 
10f5 2a 69 ee				ld hl, (input_ptr) 
10f8 7e					ld a,(hl)	 
10f9 fe 00				cp 0  
10fb ca 5a 10				jp z, .is1    ; end of string 
10fe fe 20				cp ' ' 
1100 ca 5a 10				jp z, .is1    ; end of word 
1103 2b					dec hl 
1104 22 69 ee				ld (input_ptr), hl 
1107 3a 62 ee				ld a, (input_at_cursor) 
110a 3d					dec a 
110b 32 62 ee				ld (input_at_cursor), a 
110e 18 e5				jr .iskpwm 
1110			 
1110			 
1110 fe 0b		.iskl:		cp KEY_LEFT 
1112 20 27				jr nz, .isk1 
1114			 
1114 3a 55 ee				ld a, (input_cursor) 
1117			 
1117 fe 00				cp 0 
1119 ca 5a 10				jp z, .is1 		; at start of line to ignore  
111c			 
111c 3d					dec  a 		; TODO check underflow 
111d 32 55 ee				ld (input_cursor), a 
1120			 
1120 2a 69 ee				ld hl, (input_ptr) 
1123 2b					dec hl 
1124 22 69 ee				ld (input_ptr), hl 
1127					 
1127 3a 62 ee				ld a, (input_at_cursor) 
112a 3d					dec a 
112b 32 62 ee				ld (input_at_cursor), a 
112e			 
112e 3e 01				ld a, 1		; show cursor moving 
1130 32 5f ee				ld (input_cur_onoff),a 
1133 3e 09				ld a, CUR_BLINK_RATE 
1135 32 60 ee				ld (input_cur_flash), a 
1138			 
1138 c3 5a 10				jp .is1 
113b			 
113b fe 0c		.isk1:		cp KEY_RIGHT 
113d 20 2a				jr nz, .isk2 
113f			 
113f 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1142 5f					ld e,a 
1143 3a 55 ee				ld a, (input_cursor) 
1146 bb					cp e 
1147 ca 5a 10				jp z, .is1		; at the end of string so dont go right 
114a			 
114a 3c					inc  a 		; TODO check overflow 
114b 32 55 ee				ld (input_cursor), a 
114e			 
114e 3a 62 ee				ld a, (input_at_cursor) 
1151 3c					inc a 
1152 32 62 ee				ld (input_at_cursor), a 
1155			 
1155 2a 69 ee				ld hl, (input_ptr) 
1158 23					inc hl 
1159 22 69 ee				ld (input_ptr), hl 
115c			 
115c 3e 01				ld a, 1		; show cursor moving 
115e 32 5f ee				ld (input_cur_onoff),a 
1161 3e 09				ld a, CUR_BLINK_RATE 
1163 32 60 ee				ld (input_cur_flash), a 
1166			 
1166 c3 5a 10				jp .is1 
1169			 
1169 fe 05		.isk2:		cp KEY_UP 
116b			 
116b 20 26				jr nz, .isk3 
116d			 
116d					; swap last command with the current on 
116d			 
116d					; move cursor to start of string 
116d 2a 67 ee				ld hl, (input_start) 
1170 22 69 ee				ld (input_ptr), hl 
1173			 
1173 3a 64 ee				ld a, (input_at_pos) 
1176 32 62 ee				ld (input_at_cursor), a 
1179			 
1179 3e 00				ld a, 0 
117b 32 55 ee				ld (input_cursor), a 
117e					 
117e					; swap input and last command buffers 
117e			 
117e 21 e8 e5				ld hl, os_cli_cmd 
1181 11 e7 e6				ld de, os_last_cmd 
1184 06 ff				ld b, 255 
1186 7e			.swap1:		ld a, (hl) 
1187 4f					ld c,a 
1188 1a					ld a, (de) 
1189 77					ld (hl), a 
118a 79					ld a,c 
118b 12					ld (de),a 
118c 23					inc hl 
118d 13					inc de 
118e 10 f6				djnz .swap1 
1190			 
1190			 
1190			 
1190			 
1190			 
1190 c3 5a 10				jp .is1 
1193			 
1193 fe 08		.isk3:		cp KEY_BS 
1195 20 3c				jr nz, .isk4 
1197			 
1197 3a 55 ee				ld a, (input_cursor) 
119a			 
119a fe 00				cp 0 
119c ca 5a 10				jp z, .is1 		; at start of line to ignore  
119f			 
119f 3d					dec  a 		; TODO check underflow 
11a0 32 55 ee				ld (input_cursor), a 
11a3			 
11a3					; hl is source 
11a3					; de needs to be source - 1 
11a3			 
11a3			;		ld a, 0 
11a3			;		dec hl 
11a3			;		ld (hl), a 
11a3			 
11a3 2a 69 ee				ld hl, (input_ptr) 
11a6 2b					dec hl 
11a7 22 69 ee				ld (input_ptr), hl 
11aa			 
11aa					; shift all data 
11aa			 
11aa e5					push hl 
11ab 23					inc hl 
11ac d1					pop de 
11ad 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11b0 4f					ld c,a 
11b1 06 00				ld b,0 
11b3 ed b0				ldir  
11b5			 
11b5			 
11b5			 
11b5			 
11b5 3a 62 ee				ld a, (input_at_cursor) 
11b8 3d					dec a 
11b9 32 62 ee				ld (input_at_cursor), a 
11bc			 
11bc			 
11bc 3e 01				ld a, 1		; show cursor moving 
11be 32 5f ee				ld (input_cur_onoff),a 
11c1 3e 09				ld a, CUR_BLINK_RATE 
11c3 32 60 ee				ld (input_cur_flash), a 
11c6			 
11c6					; remove char 
11c6 3a 62 ee				ld a, (input_at_cursor) 
11c9 3c					inc a 
11ca 11 54 12				ld de,.iblank 
11cd cd cc 0b				call str_at_display 
11d0			 
11d0 c3 5a 10				jp .is1 
11d3			 
11d3 fe 0d		.isk4:		cp KEY_CR 
11d5 28 6c				jr z, .endinput 
11d7			 
11d7					; else add the key press to the end 
11d7			 
11d7 4f					ld c, a			; save key pressed 
11d8			 
11d8 7e					ld a,(hl)		; get what is currently under char 
11d9			 
11d9 fe 00				cp 0			; we are at the end of the string 
11db 20 2f				jr nz, .onchar 
11dd					 
11dd					; add a char to the end of the string 
11dd				 
11dd 71					ld (hl),c 
11de 23					inc hl 
11df			;		ld a,' ' 
11df			;		ld (hl),a 
11df			;		inc hl 
11df 3e 00				ld a,0 
11e1 77					ld (hl),a 
11e2 2b					dec hl 
11e3			 
11e3 3a 55 ee				ld a, (input_cursor) 
11e6 3c					inc a				; TODO check max string length and scroll  
11e7 32 55 ee				ld (input_cursor), a		; inc cursor pos 
11ea							 
11ea 3a 62 ee				ld a, (input_at_cursor) 
11ed 3c					inc a 
11ee 32 62 ee				ld (input_at_cursor), a 
11f1			 
11f1 2a 69 ee				ld hl, (input_ptr) 
11f4 23					inc hl 
11f5 22 69 ee				ld (input_ptr), hl 
11f8			 
11f8 2a 69 ee				ld hl, (input_ptr) 
11fb 23					inc hl 
11fc 22 69 ee				ld (input_ptr), hl 
11ff			;	if DEBUG_INPUT 
11ff			;		push af 
11ff			;		ld a, '+' 
11ff			;		ld (debug_mark),a 
11ff			;		pop af 
11ff			;		CALLMONITOR 
11ff			;	endif 
11ff 3e 01				ld a, 1		; show cursor moving 
1201 32 5f ee				ld (input_cur_onoff),a 
1204 3e 09				ld a, CUR_BLINK_RATE 
1206 32 60 ee				ld (input_cur_flash), a 
1209 c3 5a 10				jp .is1 
120c					 
120c			 
120c			 
120c					; if on a char then insert 
120c			.onchar: 
120c			 
120c					; TODO over flow check: make sure insert does not blow out buffer 
120c			 
120c					; need to do some maths to use lddr 
120c			 
120c e5					push hl   ; save char pos 
120d c5					push bc 
120e			 
120e 2a 67 ee				ld hl, (input_start) 
1211 3a 5a ee				ld a, (input_len) 
1214 cd e6 0d				call addatohl  		; end of string 
1217 23					inc hl 
1218 23					inc hl		; past zero term 
1219 e5					push hl 
121a 23					inc hl 
121b e5					push hl  
121c			 
121c								; start and end of lddr set, now how much to move? 
121c			 
121c							 
121c 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
121f 47					ld b,a 
1220 3a 5a ee				ld a,(input_len) 
1223 5f					ld e,a 
1224 90					sub b 
1225 3c					inc a		;?? 
1226 3c					inc a		;?? 
1227 3c					inc a		;?? 
1228			 
1228 06 00				ld b,0 
122a 4f					ld c,a 
122b			 
122b				if DEBUG_INPUT 
122b					push af 
122b					ld a, 'i' 
122b					ld (debug_mark),a 
122b					pop af 
122b			;		CALLMONITOR 
122b				endif 
122b d1					pop de 
122c e1					pop hl 
122d				if DEBUG_INPUT 
122d					push af 
122d					ld a, 'I' 
122d					ld (debug_mark),a 
122d					pop af 
122d			;		CALLMONITOR 
122d				endif 
122d ed b8				lddr 
122f				 
122f			 
122f			 
122f					; TODO have a key for insert/overwrite mode???? 
122f c1					pop bc 
1230 e1					pop hl 
1231 71					ld (hl), c		; otherwise overwrite current char 
1232					 
1232			 
1232			 
1232			 
1232 3a 55 ee				ld a, (input_cursor) 
1235 3c					inc  a 		; TODO check overflow 
1236 32 55 ee				ld (input_cursor), a 
1239			 
1239 3a 62 ee				ld a, (input_at_cursor) 
123c 3c					inc a 
123d 32 62 ee				ld (input_at_cursor), a 
1240			 
1240 c3 5a 10				jp .is1 
1243			 
1243			.endinput:	; TODO look for end of string 
1243			 
1243					; add trailing space for end of token 
1243			 
1243 2a 67 ee				ld hl, (input_start) 
1246 3a 5a ee				ld a,(input_len) 
1249 cd e6 0d				call addatohl 
124c 3e 20				ld a, ' ' 
124e 77					ld (hl),a 
124f					; TODO eof of parse marker 
124f			 
124f 23					inc hl 
1250 3e 00				ld a, 0 
1252 77					ld (hl),a 
1253			 
1253			 
1253 c9					ret 
1254			 
1254 .. 00		.iblank: db " ",0 
1256			 
1256			 
1256 32 64 ee		input_str_prev:	ld (input_at_pos), a 
1259 22 67 ee				ld (input_start), hl 
125c 3e 01				ld a,1			; add cursor 
125e 77					ld (hl),a 
125f 23					inc hl 
1260 3e 00				ld a,0 
1262 77					ld (hl),a 
1263 22 69 ee				ld (input_ptr), hl 
1266 7a					ld a,d 
1267 32 66 ee				ld (input_size), a 
126a 3e 00				ld a,0 
126c 32 55 ee				ld (input_cursor),a 
126f			.instr1:	 
126f			 
126f					; TODO do block cursor 
126f					; TODO switch cursor depending on the modifer key 
126f			 
126f					; update cursor shape change on key hold 
126f			 
126f 2a 69 ee				ld hl, (input_ptr) 
1272 2b					dec hl 
1273 3a c1 eb				ld a,(cursor_shape) 
1276 77					ld (hl), a 
1277			 
1277					; display entered text 
1277 3a 64 ee				ld a,(input_at_pos) 
127a cd 5b 67		            	CALL fLCD_Pos       ;Position cursor to location in A 
127d ed 5b 67 ee	            	LD   de, (input_start) 
1281 cd 50 67		            	CALL fLCD_Str       ;Display string pointed to by DE 
1284			 
1284 cd 46 68				call cin 
1287 fe 00				cp 0 
1289 28 e4				jr z, .instr1 
128b			 
128b					; proecess keyboard controls first 
128b			 
128b 2a 69 ee				ld hl,(input_ptr) 
128e			 
128e fe 0d				cp KEY_CR	 ; pressing enter ends input 
1290 28 5a				jr z, .instrcr 
1292			 
1292 fe 08				cp KEY_BS 	; back space 
1294 20 0f				jr nz, .instr2 
1296					; process back space 
1296			 
1296					; TODO stop back space if at start of string 
1296 2b					dec hl 
1297 2b					dec hl ; to over write cursor 
1298 3a c1 eb				ld a,(cursor_shape) 
129b					;ld a,0 
129b 77					ld (hl),a 
129c 23					inc hl 
129d 3e 20				ld a," " 
129f 77					ld (hl),a 
12a0 22 69 ee				ld (input_ptr),hl 
12a3					 
12a3			 
12a3 18 ca				jr .instr1 
12a5			 
12a5 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
12a7 20 06				jr nz, .instr3 
12a9 2b					dec hl 
12aa 22 69 ee				ld (input_ptr),hl 
12ad 18 c0				jr .instr1 
12af				 
12af fe 0c		.instr3:	cp KEY_RIGHT      ; cursor right 
12b1 20 06				jr nz, .instr4 
12b3 23					inc hl 
12b4 22 69 ee				ld (input_ptr),hl 
12b7 18 b6				jr .instr1 
12b9			 
12b9 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
12bb 20 06				jr nz, .instr5 
12bd 2b					dec hl 
12be 22 69 ee				ld (input_ptr),hl 
12c1 18 ac				jr .instr1 
12c3			 
12c3 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
12c5 20 06				jr nz, .instr6 
12c7 2b					dec hl 
12c8 22 69 ee				ld (input_ptr),hl 
12cb 18 a2				jr .instr1 
12cd fe 05		.instr6:        cp KEY_UP      ; recall last command 
12cf 20 0b				jr nz, .instrnew 
12d1			 
12d1 21 c1 e2			ld hl, scratch 
12d4 11 e7 e6			ld de, os_last_cmd 
12d7 cd f5 12			call strcpy 
12da 18 93				jr .instr1 
12dc			 
12dc			 
12dc			.instrnew:	; no special key pressed to see if we have room to store it 
12dc			 
12dc					; TODO do string size test 
12dc			 
12dc 2b					dec hl ; to over write cursor 
12dd 77					ld (hl),a 
12de 23					inc hl 
12df 3a c1 eb				ld a,(cursor_shape) 
12e2 77					ld (hl),a 
12e3 23					inc hl 
12e4 3e 00				ld a,0 
12e6 77					ld (hl),a 
12e7			 
12e7 22 69 ee				ld (input_ptr),hl 
12ea					 
12ea 18 83				jr .instr1 
12ec 2b			.instrcr:	dec hl		; remove cursor 
12ed 3e 20				ld a,' '	; TODO add a trailing space for safety 
12ef 77					ld (hl),a 
12f0 23					inc hl 
12f1 3e 00				ld a,0 
12f3 77					ld (hl),a 
12f4			 
12f4			 
12f4					; if at end of line scroll up    
12f4					; TODO detecting only end of line 4 for scroll up  
12f4			 
12f4					;ld   
12f4			 
12f4 c9					ret 
12f5			 
12f5			 
12f5			; strcpy hl = dest, de source 
12f5			 
12f5 1a			strcpy:   LD   A, (DE)        ;Get character from string 
12f6 b7			            OR   A              ;Null terminator? 
12f7 c8			            RET  Z              ;Yes, so finished 
12f8 1a					ld a,(de) 
12f9 77					ld (hl),a 
12fa 13			            INC  DE             ;Point to next character 
12fb 23					inc hl 
12fc 18 f7		            JR   strcpy       ;Repeat 
12fe c9					ret 
12ff			 
12ff			 
12ff			; TODO string_at  
12ff			; pass string which starts with lcd offset address and then null term string 
12ff			 
12ff			; TODO string to dec 
12ff			; TODO string to hex 
12ff			; TODO byte to string hex 
12ff			; TODO byte to string dec 
12ff			 
12ff			 
12ff			 
12ff			; from z80uartmonitor 
12ff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ff			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
12ff			; pass hl for where to put the text 
12ff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ff c5			hexout:	PUSH BC 
1300 f5					PUSH AF 
1301 47					LD B, A 
1302					; Upper nybble 
1302 cb 3f				SRL A 
1304 cb 3f				SRL A 
1306 cb 3f				SRL A 
1308 cb 3f				SRL A 
130a cd 1a 13				CALL tohex 
130d 77					ld (hl),a 
130e 23					inc hl	 
130f					 
130f					; Lower nybble 
130f 78					LD A, B 
1310 e6 0f				AND 0FH 
1312 cd 1a 13				CALL tohex 
1315 77					ld (hl),a 
1316 23					inc hl	 
1317					 
1317 f1					POP AF 
1318 c1					POP BC 
1319 c9					RET 
131a					 
131a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
131a			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
131a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
131a			tohex: 
131a e5					PUSH HL 
131b d5					PUSH DE 
131c 16 00				LD D, 0 
131e 5f					LD E, A 
131f 21 27 13				LD HL, .DATA 
1322 19					ADD HL, DE 
1323 7e					LD A, (HL) 
1324 d1					POP DE 
1325 e1					POP HL 
1326 c9					RET 
1327			 
1327			.DATA: 
1327 30					DEFB	30h	; 0 
1328 31					DEFB	31h	; 1 
1329 32					DEFB	32h	; 2 
132a 33					DEFB	33h	; 3 
132b 34					DEFB	34h	; 4 
132c 35					DEFB	35h	; 5 
132d 36					DEFB	36h	; 6 
132e 37					DEFB	37h	; 7 
132f 38					DEFB	38h	; 8 
1330 39					DEFB	39h	; 9 
1331 41					DEFB	41h	; A 
1332 42					DEFB	42h	; B 
1333 43					DEFB	43h	; C 
1334 44					DEFB	44h	; D 
1335 45					DEFB	45h	; E 
1336 46					DEFB	46h	; F 
1337			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1337			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1337			;;    subtract $30, if result > 9 then subtract $7 more 
1337			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1337			atohex: 
1337 d6 30				SUB $30 
1339 fe 0a				CP 10 
133b f8					RET M		; If result negative it was 0-9 so we're done 
133c d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
133e c9					RET		 
133f			 
133f			 
133f			 
133f			 
133f			; Get 2 ASCII characters as hex byte from pointer in hl 
133f			 
133f			BYTERD: 
133f 16 00			LD	D,00h		;Set up 
1341 cd 49 13			CALL	HEXCON		;Get byte and convert to hex 
1344 87				ADD	A,A		;First nibble so 
1345 87				ADD	A,A		;multiply by 16 
1346 87				ADD	A,A		; 
1347 87				ADD	A,A		; 
1348 57				LD	D,A		;Save hi nibble in D 
1349			HEXCON: 
1349 7e				ld a, (hl)		;Get next chr 
134a 23				inc hl 
134b d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
134d fe 0a			CP	00Ah		;Is it 0-9 ? 
134f 38 02			JR	C,NALPHA	;If so miss next bit 
1351 d6 07			SUB	007h		;Else convert alpha 
1353			NALPHA: 
1353 b2				OR	D		;Add hi nibble back 
1354 c9				RET			; 
1355			 
1355			 
1355			; 
1355			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1355			; Since the routines get_byte and therefore get_nibble are called, only valid 
1355			; characters (0-9a-f) are accepted. 
1355			; 
1355			;get_word        push    af 
1355			;                call    get_byte        ; Get the upper byte 
1355			;                ld      h, a 
1355			;                call    get_byte        ; Get the lower byte 
1355			;                ld      l, a 
1355			;                pop     af 
1355			;                ret 
1355			; 
1355			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1355			; the routine get_nibble is used only valid characters are accepted - the  
1355			; input routine only accepts characters 0-9a-f. 
1355			; 
1355 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1356 7e					ld a,(hl) 
1357 23					inc hl 
1358 cd 7d 13		                call    nibble2val      ; Get upper nibble 
135b cb 07		                rlc     a 
135d cb 07		                rlc     a 
135f cb 07		                rlc     a 
1361 cb 07		                rlc     a 
1363 47			                ld      b, a            ; Save upper four bits 
1364 7e					ld a,(hl) 
1365 cd 7d 13		                call    nibble2val      ; Get lower nibble 
1368 b0			                or      b               ; Combine both nibbles 
1369 c1			                pop     bc              ; Restore B (and C) 
136a c9			                ret 
136b			; 
136b			; Get a hexadecimal digit from the serial line. This routine blocks until 
136b			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
136b			; to the serial line interface. The lower 4 bits of A contain the value of  
136b			; that particular digit. 
136b			; 
136b			;get_nibble      ld a,(hl)           ; Read a character 
136b			;                call    to_upper        ; Convert to upper case 
136b			;                call    is_hex          ; Was it a hex digit? 
136b			;                jr      nc, get_nibble  ; No, get another character 
136b			 ;               call    nibble2val      ; Convert nibble to value 
136b			 ;               call    print_nibble 
136b			 ;               ret 
136b			; 
136b			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
136b			; A valid hexadecimal digit is denoted by a set C flag. 
136b			; 
136b			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
136b			;                ret     nc              ; Yes 
136b			;                cp      '0'             ; Less than '0'? 
136b			;                jr      nc, is_hex_1    ; No, continue 
136b			;                ccf                     ; Complement carry (i.e. clear it) 
136b			;                ret 
136b			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
136b			;                ret     c               ; Yes 
136b			;                cp      'A'             ; Less than 'A'? 
136b			;                jr      nc, is_hex_2    ; No, continue 
136b			;                ccf                     ; Yes - clear carry and return 
136b			;                ret 
136b			;is_hex_2        scf                     ; Set carry 
136b			;                ret 
136b			; 
136b			; Convert a single character contained in A to upper case: 
136b			; 
136b fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
136d d8			                ret     c 
136e fe 7b		                cp      'z' + 1         ; > 'z'? 
1370 d0			                ret     nc              ; Nothing to do, either 
1371 e6 5f		                and     $5f             ; Convert to upper case 
1373 c9			                ret 
1374			 
1374			 
1374			to_lower: 
1374			 
1374			   ; if char is in [A-Z] make it lower case 
1374			 
1374			   ; enter : a = char 
1374			   ; exit  : a = lower case char 
1374			   ; uses  : af 
1374			 
1374 fe 41		   cp 'A' 
1376 d8			   ret c 
1377			    
1377 fe 5b		   cp 'Z'+1 
1379 d0			   ret nc 
137a			    
137a f6 20		   or $20 
137c c9			   ret 
137d			 
137d			; 
137d			; Expects a hexadecimal digit (upper case!) in A and returns the 
137d			; corresponding value in A. 
137d			; 
137d fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
137f 38 02		                jr      c, nibble2val_1 ; Yes 
1381 d6 07		                sub     7               ; Adjust for A-F 
1383 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1385 e6 0f		                and     $f              ; Only return lower 4 bits 
1387 c9			                ret 
1388			; 
1388			; Print_nibble prints a single hex nibble which is contained in the lower  
1388			; four bits of A: 
1388			; 
1388			;print_nibble    push    af              ; We won't destroy the contents of A 
1388			;                and     $f              ; Just in case... 
1388			;                add     a, '0'             ; If we have a digit we are done here. 
1388			;                cp      '9' + 1         ; Is the result > 9? 
1388			;                jr      c, print_nibble_1 
1388			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1388			;print_nibble_1  call    putc            ; Print the nibble and 
1388			;                pop     af              ; restore the original value of A 
1388			;                ret 
1388			;; 
1388			;; Send a CR/LF pair: 
1388			; 
1388			;crlf            push    af 
1388			;                ld      a, cr 
1388			;                call    putc 
1388			;                ld      a, lf 
1388			;                call    putc 
1388			;                pop     af 
1388			;                ret 
1388			; 
1388			; Print_word prints the four hex digits of a word to the serial line. The  
1388			; word is expected to be in HL. 
1388			; 
1388			;print_word      push    hl 
1388			;                push    af 
1388			;                ld      a, h 
1388			;                call    print_byte 
1388			;                ld      a, l 
1388			;                call    print_byte 
1388			;                pop     af 
1388			;                pop     hl 
1388			;                ret 
1388			; 
1388			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1388			; The byte to be printed is expected to be in A. 
1388			; 
1388			;print_byte      push    af              ; Save the contents of the registers 
1388			;                push    bc 
1388			;                ld      b, a 
1388			;                rrca 
1388			;                rrca 
1388			;                rrca 
1388			;                rrca 
1388			;                call    print_nibble    ; Print high nibble 
1388			;                ld      a, b 
1388			;                call    print_nibble    ; Print low nibble 
1388			;                pop     bc              ; Restore original register contents 
1388			;                pop     af 
1388			;                ret 
1388			 
1388			 
1388			 
1388			 
1388			 
1388			fourehexhl:  
1388 7e				ld a,(hl) 
1389 cd 37 13			call atohex 
138c cb 3f				SRL A 
138e cb 3f				SRL A 
1390 cb 3f				SRL A 
1392 cb 3f				SRL A 
1394 47				ld b, a 
1395 23				inc hl 
1396 7e				ld a,(hl) 
1397 23				inc hl 
1398 cd 37 13			call atohex 
139b 80				add b 
139c 57				ld d,a 
139d 7e				ld a,(hl) 
139e cd 37 13			call atohex 
13a1 cb 3f				SRL A 
13a3 cb 3f				SRL A 
13a5 cb 3f				SRL A 
13a7 cb 3f				SRL A 
13a9 47				ld b, a 
13aa 23				inc hl 
13ab 7e				ld a,(hl) 
13ac 23				inc hl 
13ad cd 37 13			call atohex 
13b0 80				add b 
13b1 5f				ld e, a 
13b2 d5				push de 
13b3 e1				pop hl 
13b4 c9				ret 
13b5			 
13b5			; pass hl. returns z set if the byte at hl is a digit 
13b5			;isdigithl:  
13b5			;	push bc 
13b5			;	ld a,(hl) 
13b5			;	cp ':' 
13b5			;	jr nc, .isdf 		; > 
13b5			;	cp '0' 
13b5			;	jr c, .isdf		; < 
13b5			; 
13b5			;	; TODO find a better way to set z 
13b5			; 
13b5			;	ld b,a 
13b5			;	cp b 
13b5			;	pop bc 
13b5			;	ret 
13b5			; 
13b5			;.isdf:	; not digit so clear z 
13b5			; 
13b5			;	; TODO find a better way to unset z 
13b5			; 
13b5			;	ld b,a 
13b5			;	inc b 
13b5			;	cp b 
13b5			; 
13b5			;	pop bc 
13b5			;	ret 
13b5				 
13b5				 
13b5			 
13b5			 
13b5			; pass hl as the four byte address to load 
13b5			 
13b5			get_word_hl:  
13b5 e5				push hl 
13b6 cd 55 13			call get_byte 
13b9				 
13b9 47				ld b, a 
13ba			 
13ba e1				pop hl 
13bb 23				inc hl 
13bc 23				inc hl 
13bd			 
13bd			; TODO not able to handle a-f  
13bd 7e				ld a,(hl) 
13be			;	;cp ':' 
13be			;	cp 'g' 
13be			;	jr nc, .single_byte_hl 		; > 
13be			;	cp 'G' 
13be			;	jr nc, .single_byte_hl 		; > 
13be			;	cp '0' 
13be			;	jr c, .single_byte_hl		; < 
13be			 
13be				;call isdigithl 
13be fe 00			cp 0 
13c0 28 06			jr z, .single_byte_hl 
13c2			 
13c2			.getwhln:   ; hex word so get next byte 
13c2			 
13c2 cd 55 13			call get_byte 
13c5 6f				ld l, a 
13c6 60				ld h,b 
13c7 c9				ret 
13c8 68			.single_byte_hl:   ld l,b 
13c9 26 00				ld h,0 
13cb c9					ret 
13cc			 
13cc			 
13cc			 
13cc			 
13cc 21 59 1b			ld hl,asc+1 
13cf			;	ld a, (hl) 
13cf			;	call nibble2val 
13cf cd 55 13			call get_byte 
13d2			 
13d2			;	call fourehexhl 
13d2 32 f5 e2			ld (scratch+52),a 
13d5				 
13d5 21 f3 e2			ld hl,scratch+50 
13d8 22 e4 e5			ld (os_cur_ptr),hl 
13db			 
13db c9				ret 
13dc			 
13dc			 
13dc			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
13dc			 
13dc			; Decimal Unsigned Version 
13dc			 
13dc			;Number in a to decimal ASCII 
13dc			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
13dc			;Example: display a=56 as "056" 
13dc			;input: a = number 
13dc			;Output: a=0,value of a in the screen 
13dc			;destroys af,bc (don't know about hl and de) 
13dc			DispAToASCII: 
13dc 0e 9c			ld	c,-100 
13de cd e8 13			call	.Na1 
13e1 0e f6			ld	c,-10 
13e3 cd e8 13			call	.Na1 
13e6 0e ff			ld	c,-1 
13e8 06 2f		.Na1:	ld	b,'0'-1 
13ea 04			.Na2:	inc	b 
13eb 81				add	a,c 
13ec 38 fc			jr	c,.Na2 
13ee 91				sub	c		;works as add 100/10/1 
13ef f5				push af		;safer than ld c,a 
13f0 78				ld	a,b		;char is in b 
13f1			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
13f1 f1				pop af		;safer than ld a,c 
13f2 c9				ret 
13f3			 
13f3			; Decimal Signed Version 
13f3			 
13f3			; DispA 
13f3			; -------------------------------------------------------------- 
13f3			; Converts a signed integer value to a zero-terminated ASCII 
13f3			; string representative of that value (using radix 10). 
13f3			; -------------------------------------------------------------- 
13f3			; INPUTS: 
13f3			;     HL     Value to convert (two's complement integer). 
13f3			;     DE     Base address of string destination. (pointer). 
13f3			; -------------------------------------------------------------- 
13f3			; OUTPUTS: 
13f3			;     None 
13f3			; -------------------------------------------------------------- 
13f3			; REGISTERS/MEMORY DESTROYED 
13f3			; AF HL 
13f3			; -------------------------------------------------------------- 
13f3			 
13f3			;DispHLToASCII: 
13f3			;   push    de 
13f3			;   push    bc 
13f3			; 
13f3			;; Detect sign of HL. 
13f3			;    bit    7, h 
13f3			;    jr     z, ._DoConvert 
13f3			; 
13f3			;; HL is negative. Output '-' to string and negate HL. 
13f3			;    ld     a, '-' 
13f3			;    ld     (de), a 
13f3			;    inc    de 
13f3			; 
13f3			;; Negate HL (using two's complement) 
13f3			;    xor    a 
13f3			;    sub    l 
13f3			;    ld     l, a 
13f3			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
13f3			;    sbc    a, h 
13f3			;    ld     h, a 
13f3			; 
13f3			;; Convert HL to digit characters 
13f3			;._DoConvert: 
13f3			;    ld     b, 0     ; B will count character length of number 
13f3			;-   ld     a, 10 
13f3			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
13f3			;    push   af 
13f3			;    inc    b 
13f3			;    ld     a, h 
13f3			;    or     l 
13f3			;    jr     nz, - 
13f3			; 
13f3			;; Retrieve digits from stack 
13f3			;-   pop    af 
13f3			;    or     $30 
13f3			;    ld     (de), a 
13f3			;    inc    de 
13f3			;    djnz   - 
13f3			; 
13f3			;; Terminate string with NULL 
13f3			;    xor    a 
13f3			;    ld     (de), a 
13f3			; 
13f3			;    pop    bc 
13f3			;    pop    de 
13f3			;    ret 
13f3			 
13f3			;Comments 
13f3			; 
13f3			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
13f3			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
13f3			;    Note that the output string will not be fixed-width. 
13f3			; 
13f3			;Example Usage 
13f3			; 
13f3			;    ld    hl, -1004 
13f3			;    ld    de, OP1 
13f3			;    call  DispA 
13f3			;    ld    hl, OP1 
13f3			;    syscall  PutS 
13f3			 
13f3			 
13f3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13f3			 
13f3			 
13f3			;Converts an ASCII string to an unsigned 16-bit integer 
13f3			;Quits when it reaches a non-decimal digit 
13f3			 
13f3			string_to_uint16: 
13f3			atoui_16: 
13f3			;Input: 
13f3			;     DE points to the string 
13f3			;Outputs: 
13f3			;     HL is the result 
13f3			;     A is the 8-bit value of the number 
13f3			;     DE points to the byte after the number 
13f3			;Destroys: 
13f3			;     BC 
13f3			;       if the string is non-empty, BC is HL/10 
13f3			;Size:  24 bytes 
13f3			;Speed: 42+d(104+{0,9}) 
13f3			;       d is the number of digits in the number 
13f3			;       max is 640 cycles for a 5 digit number 
13f3			;Assuming no leading zeros: 
13f3			;1 digit:  146cc 
13f3			;2 digit:  250cc 
13f3			;3 digit:  354cc or 363cc (avg: 354.126cc) 
13f3			;4 digit:  458cc or 467cc (avg: 458.27cc) 
13f3			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
13f3			;avg: 544.81158447265625cc (544+13297/16384) 
13f3			;=============================================================== 
13f3 21 00 00		  ld hl,0 
13f6			.u16a: 
13f6 1a			  ld a,(de) 
13f7 d6 30		  sub 30h 
13f9 fe 0a		  cp 10 
13fb d0			  ret nc 
13fc 13			  inc de 
13fd 44			  ld b,h 
13fe 4d			  ld c,l 
13ff 29			  add hl,hl 
1400 29			  add hl,hl 
1401 09			  add hl,bc 
1402 29			  add hl,hl 
1403 85			  add a,l 
1404 6f			  ld l,a 
1405 30 ef		  jr nc,.u16a 
1407 24			  inc h 
1408 c3 f6 13		  jp .u16a 
140b			 
140b			 
140b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
140b			 
140b			;written by Zeda 
140b			;Converts a 16-bit unsigned integer to an ASCII string. 
140b			 
140b			uitoa_16: 
140b			;Input: 
140b			;   DE is the number to convert 
140b			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
140b			;Output: 
140b			;   HL points to the null-terminated ASCII string 
140b			;      NOTE: This isn't necessarily the same as the input HL. 
140b d5			  push de 
140c c5			  push bc 
140d f5			  push af 
140e eb			  ex de,hl 
140f			 
140f 01 f0 d8		  ld bc,-10000 
1412 3e 2f		  ld a,'0'-1 
1414 3c			  inc a 
1415 09			  add hl,bc  
1416 38 fc		   jr c,$-2 
1418 12			  ld (de),a 
1419 13			  inc de 
141a			 
141a 01 e8 03		  ld bc,1000 
141d 3e 3a		  ld a,'9'+1 
141f 3d			  dec a  
1420 09			  add hl,bc  
1421 30 fc		   jr nc,$-2 
1423 12			  ld (de),a 
1424 13			  inc de 
1425			 
1425 01 9c ff		  ld bc,-100 
1428 3e 2f		  ld a,'0'-1 
142a 3c			  inc a  
142b 09			  add hl,bc  
142c 38 fc		   jr c,$-2 
142e 12			  ld (de),a 
142f 13			  inc de 
1430			 
1430 7d			  ld a,l 
1431 26 3a		  ld h,'9'+1 
1433 25			  dec h  
1434 c6 0a		  add a,10  
1436 30 fb		   jr nc,$-3 
1438 c6 30		  add a,'0' 
143a eb			  ex de,hl 
143b 72			  ld (hl),d 
143c 23			  inc hl 
143d 77			  ld (hl),a 
143e 23			  inc hl 
143f 36 00		  ld (hl),0 
1441			 
1441			;Now strip the leading zeros 
1441 0e fa		  ld c,-6 
1443 09			  add hl,bc 
1444 3e 30		  ld a,'0' 
1446 23			  inc hl  
1447 be			  cp (hl)  
1448 28 fc		  jr z,$-2 
144a			 
144a			;Make sure that the string is non-empty! 
144a 7e			  ld a,(hl) 
144b b7			  or a 
144c 20 01		  jr nz,.atoub 
144e 2b			  dec hl 
144f			.atoub: 
144f			 
144f f1			  pop af 
1450 c1			  pop bc 
1451 d1			  pop de 
1452 c9			  ret 
1453			 
1453			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1453			 
1453			toUpper: 
1453			;A is the char. 
1453			;If A is a lowercase letter, this sets it to the matching uppercase 
1453			;18cc or 30cc or 41cc 
1453			;avg: 26.75cc 
1453 fe 61		  cp 'a' 
1455 d8			  ret c 
1456 fe 7b		  cp 'z'+1 
1458 d0			  ret nc 
1459 d6 20		  sub 'a'-'A' 
145b c9			  ret 
145c			 
145c			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
145c			 
145c			; String Length 
145c			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
145c			 
145c			; Get the length of the null-terminated string starting at $8000 hl 
145c			;    LD     HL, $8000 
145c			 
145c			strlenz: 
145c			 
145c af			    XOR    A               ; Zero is the value we are looking for. 
145d 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
145e 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
145f			                           ; 65, 536 bytes (the entire addressable memory space). 
145f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1461			 
1461			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1461 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1462 6f			    LD     L, A             ; number of bytes 
1463 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1465 2b			    DEC    HL              ; Compensate for null. 
1466 c9				ret 
1467			 
1467			; Get the length of the A terminated string starting at $8000 hl 
1467			;    LD     HL, $8000 
1467			 
1467			strlent: 
1467			 
1467			                  ; A is the value we are looking for. 
1467 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1469 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
146b			                           ; 65, 536 bytes (the entire addressable memory space). 
146b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
146d			 
146d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
146d 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
146f 2e 00		    LD     L, 0             ; number of bytes 
1471 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1473 2b			    DEC    HL              ; Compensate for null. 
1474 c9				ret 
1475			 
1475			 
1475			;Comparing Strings 
1475			 
1475			;IN    HL     Address of string1. 
1475			;      DE     Address of string2. 
1475			 
1475			; doc given but wrong??? 
1475			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1475			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1475			; tested 
1475			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1475			 
1475			strcmp_old: 
1475 e5			    PUSH   HL 
1476 d5			    PUSH   DE 
1477			 
1477 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1478 be			    CP     (HL)            ; (want to minimize work). 
1479 38 01		    JR     C, Str1IsBigger 
147b 7e			    LD     A, (HL) 
147c			 
147c			Str1IsBigger: 
147c 4f			    LD     C, A             ; Put length in BC 
147d 06 00		    LD     B, 0 
147f 13			    INC    DE              ; Increment pointers to meat of string. 
1480 23			    INC    HL 
1481			 
1481			CmpLoop: 
1481 1a			    LD     A, (DE)          ; Compare bytes. 
1482 ed a1		    CPI 
1484 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1486 13			    INC    DE              ; Update pointer. 
1487 ea 81 14		    JP     PE, CmpLoop 
148a			 
148a d1			    POP    DE 
148b e1			    POP    HL 
148c 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
148d be			    CP     (HL) 
148e c9			    RET 
148f			 
148f			NoMatch: 
148f 2b			    DEC    HL 
1490 be			    CP     (HL)            ; Compare again to affect carry. 
1491 d1			    POP    DE 
1492 e1			    POP    HL 
1493 c9			    RET 
1494			 
1494			;; test strmp 
1494			; 
1494			;ld de, .str1 
1494			;ld hl, .str2 
1494			;call strcmp 
1494			;jr z, .z1 
1494			;;this 
1494			;	if DEBUG_FORTH_WORDS 
1494			;		DMARK "NZ1" 
1494			;		CALLMONITOR 
1494			;	endif 
1494			;.z1: 
1494			; 
1494			;	if DEBUG_FORTH_WORDS 
1494			;		DMARK "ZZ1" 
1494			;		CALLMONITOR 
1494			;	endif 
1494			; 
1494			;ld de, .str1 
1494			;ld hl, .str1 
1494			;call strcmp 
1494			;jr z, .z2 
1494			;;this 
1494			;	if DEBUG_FORTH_WORDS 
1494			;		DMARK "NZ2" 
1494			;		CALLMONITOR 
1494			;	endif 
1494			;.z2: 
1494			; 
1494			;	if DEBUG_FORTH_WORDS 
1494			;		DMARK "ZZ2" 
1494			;		CALLMONITOR 
1494			;	endif 
1494			; 
1494			;ld de, .str1 
1494			;ld hl, .str2 
1494			;call strcmp 
1494			;jr c, .c1 
1494			; 
1494			;	if DEBUG_FORTH_WORDS 
1494			;		DMARK "Nc1" 
1494			;		CALLMONITOR 
1494			;	endif 
1494			;.c1: 
1494			;;this 
1494			;	if DEBUG_FORTH_WORDS 
1494			;		DMARK "cc1" 
1494			;		CALLMONITOR 
1494			;	endif 
1494			; 
1494			;ld de, .str1 
1494			;ld hl, .str1 
1494			;call strcmp 
1494			;jr c, .c2 
1494			;;this 
1494			;	if DEBUG_FORTH_WORDS 
1494			;		DMARK "Nc2" 
1494			;		CALLMONITOR 
1494			;	endif 
1494			;.c2: 
1494			; 
1494			;	if DEBUG_FORTH_WORDS 
1494			;		DMARK "cc2" 
1494			;		CALLMONITOR 
1494			;	endif 
1494			;	NEXTW 
1494			;.str1:   db "string1",0 
1494			;.str2:   db "string2",0 
1494			 
1494			; only care about direct match or not 
1494			; hl and de strings 
1494			; zero set if the same 
1494			 
1494			strcmp: 
1494 1a				ld a, (de) 
1495 be				cp (hl) 
1496 28 02			jr z, .ssame 
1498 b7				or a 
1499 c9				ret 
149a			 
149a			.ssame:  
149a fe 00			cp 0 
149c c8				ret z 
149d			 
149d 23				inc hl 
149e 13				inc de 
149f 18 f3			jr strcmp 
14a1				 
14a1				 
14a1			 
14a1			;Copyright (c) 2014, Luke Maurits 
14a1			;All rights reserved. 
14a1			; 
14a1			;Redistribution and use in source and binary forms, with or without 
14a1			;modification, are permitted provided that the following conditions are met: 
14a1			; 
14a1			;* Redistributions of source code must retain the above copyright notice, this 
14a1			;  list of conditions and the following disclaimer. 
14a1			; 
14a1			;* Redistributions in binary form must reproduce the above copyright notice, 
14a1			;  this list of conditions and the following disclaimer in the documentation 
14a1			;  and/or other materials provided with the distribution. 
14a1			; 
14a1			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
14a1			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
14a1			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
14a1			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
14a1			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
14a1			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
14a1			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
14a1			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
14a1			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
14a1			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
14a1			 
14a1			; https://github.com/lmaurits/lm512/blob/master/string.z80 
14a1			 
14a1			StrictStrCmp: 
14a1				; Load next chars of each string 
14a1 1a				ld a, (de) 
14a2 47				ld b, a 
14a3 7e				ld a, (hl) 
14a4				; Compare 
14a4 b8				cp b 
14a5				; Return non-zero if chars don't match 
14a5 c0				ret nz 
14a6				; Check for end of both strings 
14a6 fe 00			cp "\0" 
14a8				; Return if strings have ended 
14a8 c8				ret z 
14a9				; Otherwise, advance to next chars 
14a9 23				inc hl 
14aa 13				inc de 
14ab 18 f4			jr StrictStrCmp 
14ad			 
14ad			;end 
14ad			; eof 
14ad			 
14ad			 
14ad			 
14ad			 
14ad			 
14ad			 
# End of file firmware_strings.asm
14ad			include "firmware_memory.asm"   ; malloc and free  
14ad			 
14ad			if DEBUG_FORTH_MALLOC_HIGH 
14ad			.mallocsize: db "Wants malloc >256",0 
14ad			.mallocasize: db "MALLOC gives >256",0 
14ad			.malloczero: db "MALLOC gives zero",0 
14ad			 
14ad			malloc_guard_zerolen: 
14ad				push hl 
14ad				push de 
14ad				push af 
14ad			 
14ad				ld de, 0 
14ad			        call cmp16 
14ad				jr nz, .lowalloz 
14ad			 
14ad				push hl 
14ad				push de 
14ad					ld hl, display_fb0 
14ad					ld (display_fb_active), hl 
14ad				call clear_display 
14ad				ld a, 0 
14ad				ld de, .malloczero 
14ad				call str_at_display 
14ad				call update_display 
14ad				call delay1s 
14ad				call delay1s 
14ad				call bp_on 
14ad			;	ld a, 0 
14ad			;	ld (os_view_disable), a 
14ad			 
14ad				pop de 
14ad				pop hl 
14ad			 
14ad				 
14ad			 
14ad				CALLMONITOR 
14ad			.lowalloz: 
14ad			 
14ad			 
14ad				pop af 
14ad				pop de 
14ad				pop hl 
14ad			ret 
14ad			 
14ad			malloc_guard_entry: 
14ad				push hl 
14ad				push de 
14ad				push af 
14ad			 
14ad			 	or a      ;clear carry flag 
14ad				push hl 
14ad				ld de, 255 
14ad				sbc hl, de 
14ad				jr c, .lowalloc 
14ad			 
14ad				push de 
14ad					ld hl, display_fb0 
14ad					ld (display_fb_active), hl 
14ad				call clear_display 
14ad				ld a, 0 
14ad				ld de, .mallocsize 
14ad				call str_at_display 
14ad				call update_display 
14ad				call delay1s 
14ad				call delay1s 
14ad			;	ld a, 0 
14ad			;	ld (os_view_disable), a 
14ad				call bp_on 
14ad			 
14ad				pop de 
14ad				pop hl 
14ad			 
14ad				 
14ad			 
14ad				CALLMONITOR 
14ad				jr .lowdone 
14ad			.lowalloc: 
14ad			 
14ad			 
14ad				pop hl 
14ad			.lowdone:	pop af 
14ad				pop de 
14ad				pop hl 
14ad			ret 
14ad			 
14ad			malloc_guard_exit: 
14ad				push hl 
14ad				push de 
14ad				push af 
14ad			 
14ad			 	or a      ;clear carry flag 
14ad				push hl 
14ad				ld de, 255 
14ad				sbc hl, de 
14ad				jr c, .lowallocx 
14ad			 
14ad				push de 
14ad					ld hl, display_fb0 
14ad					ld (display_fb_active), hl 
14ad				call clear_display 
14ad				ld a, 0 
14ad				ld de, .mallocasize 
14ad				call str_at_display 
14ad				call update_display 
14ad				call delay1s 
14ad				call delay1s 
14ad			;	ld a, 0 
14ad			;	ld (os_view_disable), a 
14ad				call bp_on 
14ad				pop de 
14ad				pop hl 
14ad			 
14ad				CALLMONITOR 
14ad				jr .lowdonex 
14ad			.lowallocx: 
14ad			 
14ad				pop hl 
14ad			.lowdonex:	pop af 
14ad				pop de 
14ad				pop hl 
14ad			ret 
14ad			endif 
14ad			 
14ad			if MALLOC_2 
14ad			; Z80 Malloc and Free Functions 
14ad			 
14ad			; Malloc Function: 
14ad			; Input: 
14ad			;   HL: Size of block to allocate 
14ad			; Output: 
14ad			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
14ad			 
14ad			malloc: 
14ad				 
14ad			if DEBUG_FORTH_MALLOC_HIGH 
14ad			call malloc_guard_entry 
14ad			endif 
14ad			 
14ad			 
14ad			 
14ad			 
14ad					if DEBUG_FORTH_MALLOC 
14ad						DMARK "mal" 
14ad						CALLMONITOR 
14ad					endif 
14ad			    push af            ; Save AF register 
14ad			    ld a, l            ; Load low byte of size into A 
14ad			    or h               ; Check if size is zero 
14ad			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
14ad			 
14ad			    ; Allocate memory 
14ad			    ld hl, (heap_start) ; Load start of heap into HL 
14ad					if DEBUG_FORTH_MALLOC 
14ad						DMARK "ma1" 
14ad						CALLMONITOR 
14ad					endif 
14ad			    call malloc_internal ; Call internal malloc function 
14ad			    pop af             ; Restore AF register 
14ad			if DEBUG_FORTH_MALLOC_HIGH 
14ad			call malloc_guard_exit 
14ad			call malloc_guard_zerolen 
14ad			endif 
14ad			    ret                ; Return 
14ad			 
14ad			; Free Function: 
14ad			; Input: 
14ad			;   HL: Pointer to memory block to free 
14ad			; Output: 
14ad			;   None 
14ad			 
14ad			free: 
14ad			    push af            ; Save AF register 
14ad			    ld a, l            ; Load low byte of pointer into A 
14ad			    or h               ; Check if pointer is NULL 
14ad			    jp z, free_exit    ; If pointer is NULL, exit 
14ad			 
14ad			    ; Free memory 
14ad			    ld hl, (heap_start) ; Load start of heap into HL 
14ad			    call free_internal  ; Call internal free function 
14ad			    pop af             ; Restore AF register 
14ad			    ret                ; Return 
14ad			 
14ad			; Internal Malloc Function: 
14ad			; Input: 
14ad			;   HL: Size of block to allocate 
14ad			; Output: 
14ad			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
14ad			 
14ad			malloc_internal: 
14ad			    ld bc, 2           ; Number of bytes to allocate for management overhead 
14ad			    add hl, bc         ; Add management overhead to requested size 
14ad			    ex de, hl          ; Save total size in DE, and keep it in HL 
14ad					if DEBUG_FORTH_MALLOC 
14ad						DMARK "ma2" 
14ad						CALLMONITOR 
14ad					endif 
14ad			 
14ad			    ; Search for free memory block 
14ad			    ld de, (heap_end)  ; Load end of heap into DE 
14ad			    ld bc, 0           ; Initialize counter 
14ad			 
14ad					if DEBUG_FORTH_MALLOC 
14ad						DMARK "ma2" 
14ad						CALLMONITOR 
14ad					endif 
14ad			malloc_search_loop: 
14ad			    ; Check if current block is free 
14ad			    ld a, (hl)         ; Load current block's status (free or used) 
14ad			    cp 0               ; Compare with zero (free) 
14ad			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
14ad			 
14ad			    ; Check if current block is large enough 
14ad			    ld a, (hl+1)       ; Load high byte of block size 
14ad			    cp l               ; Compare with low byte of requested size 
14ad			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
14ad			 
14ad			    ld a, (hl+2)       ; Load low byte of block size 
14ad			    cp h               ; Compare with high byte of requested size 
14ad			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
14ad			 
14ad			    ; Mark block as used 
14ad			    ld (hl), 0xFF      ; Set status byte to indicate used block 
14ad			 
14ad			    ; Calculate remaining space in block 
14ad			    ld bc, 0           ; Clear BC 
14ad			    add hl, bc         ; Increment HL to point to start of data block 
14ad			    add hl, de         ; HL = HL + DE (total size) 
14ad			    ld bc, 1           ; Number of bytes to allocate for management overhead 
14ad			    add hl, bc         ; Add management overhead to start of data block 
14ad			 
14ad			    ; Save pointer to allocated block in HL 
14ad			if DEBUG_FORTH_MALLOC_HIGH 
14ad						DMARK "ma5" 
14ad			call malloc_guard_exit 
14ad			call malloc_guard_zerolen 
14ad			endif 
14ad			    ret 
14ad			 
14ad			malloc_skip_block_check: 
14ad			    ; Move to the next block 
14ad			    ld bc, 3           ; Size of management overhead 
14ad			    add hl, bc         ; Move to the next block 
14ad			    inc de             ; Increment counter 
14ad			 
14ad			    ; Check if we have reached the end of heap 
14ad			    ld a, e            ; Load low byte of heap end address 
14ad			    cp (hl)            ; Compare with low byte of current address 
14ad			    jr nz, malloc_search_loop  ; If not equal, continue searching 
14ad			    ld a, d            ; Load high byte of heap end address 
14ad			    cp 0               ; Check if it's zero (end of memory) 
14ad			    jr nz, malloc_search_loop  ; If not zero, continue searching 
14ad			 
14ad			    ; If we reached here, allocation failed 
14ad			    xor a              ; Set result to NULL 
14ad			if DEBUG_FORTH_MALLOC_HIGH 
14ad						DMARK "ma6" 
14ad			call malloc_guard_exit 
14ad			call malloc_guard_zerolen 
14ad			endif 
14ad			    ret 
14ad			malloc_exit: 
14ad			if DEBUG_FORTH_MALLOC_HIGH 
14ad						DMARK "ma7" 
14ad			call malloc_guard_exit 
14ad			call malloc_guard_zerolen 
14ad			endif 
14ad			    ret 
14ad			 
14ad			; Internal Free Function: 
14ad			; Input: 
14ad			;   HL: Pointer to memory block to free 
14ad			; Output: 
14ad			;   None 
14ad			 
14ad			free_internal: 
14ad			    ld de, (heap_start) ; Load start of heap into DE 
14ad			    ld bc, 0            ; Initialize counter 
14ad			 
14ad			free_search_loop: 
14ad			    ; Check if current block contains the pointer 
14ad			    ld a, l             ; Load low byte of pointer 
14ad			    cp (hl+1)           ; Compare with high byte of current block's address 
14ad			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
14ad			    ld a, h             ; Load high byte of pointer 
14ad			    cp (hl+2)           ; Compare with low byte of current block's address 
14ad			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
14ad			 
14ad			    ; Mark block as free 
14ad			    ld (hl), 0          ; Set status byte to indicate free block 
14ad			    ret                 ; Return 
14ad			 
14ad			free_skip_block_check: 
14ad			    ; Move to the next block 
14ad			    ld bc, 3            ; Size of management overhead 
14ad			    add hl, bc          ; Move to the next block 
14ad			    inc de              ; Increment counter 
14ad			 
14ad			    ; Check if we have reached the end of heap 
14ad			    ld a, e             ; Load low byte of heap end address 
14ad			    cp (hl)             ; Compare with low byte of current address 
14ad			    jr nz, free_search_loop  ; If not equal, continue searching 
14ad			    ld a, d             ; Load high byte of heap end address 
14ad			    cp 0                ; Check if it's zero (end of memory) 
14ad			    jr nz, free_search_loop  ; If not zero, continue searching 
14ad			 
14ad			    ; If we reached here, pointer is not found in heap 
14ad			    ret 
14ad			 
14ad			free_exit: 
14ad			    ret                 ; Return 
14ad			 
14ad			; Define heap start and end addresses 
14ad			;heap_start:    .dw 0xC000   ; Start of heap 
14ad			;heap_end:      .dw 0xE000   ; End of heap 
14ad			 
14ad			endif 
14ad			 
14ad			 
14ad			if MALLOC_1 
14ad			 
14ad			 
14ad			 
14ad			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
14ad			 
14ad			;moved to firmware.asm 
14ad			;heap_start        .equ  0x9000      ; Starting address of heap 
14ad			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
14ad			 
14ad			;      .org 0 
14ad			;      jp    main 
14ad			 
14ad			 
14ad			;      .org  0x100 
14ad			;main: 
14ad			;      ld    HL, 0x8100 
14ad			;      ld    SP, HL 
14ad			; 
14ad			;      call  heap_init 
14ad			; 
14ad			;      ; Make some allocations 
14ad			;      ld    HL, 12 
14ad			;      call  malloc            ; Allocates 0x9004 
14ad			; 
14ad			;      ld    HL, 12 
14ad			;      call  malloc            ; Allocates 0x9014 
14ad			; 
14ad			;      ld    HL, 12 
14ad			;      call  malloc            ; Allocates 0x9024 
14ad			; 
14ad			;      ; Free some allocations 
14ad			;      ld    HL, 0x9014 
14ad			;      call  free 
14ad			; 
14ad			;      ld    HL, 0x9004 
14ad			;      call  free 
14ad			; 
14ad			;      ld    HL, 0x9024 
14ad			;      call  free 
14ad			; 
14ad			; 
14ad			;      halt 
14ad			 
14ad			 
14ad			;------------------------------------------------------------------------------ 
14ad			;     heap_init                                                               : 
14ad			;                                                                             : 
14ad			; Description                                                                 : 
14ad			;     Initialise the heap and make it ready for malloc and free operations.   : 
14ad			;                                                                             : 
14ad			;     The heap is maintained as a linked list, starting with an initial       : 
14ad			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
14ad			;     the first free block in the heap. Each block then points to the next    : 
14ad			;     free block within the heap, and the free list ends at the first block   : 
14ad			;     with a null pointer to the next free block.                             : 
14ad			;                                                                             : 
14ad			; Parameters                                                                  : 
14ad			;     Inputs are compile-time only. Two defines which specify the starting    : 
14ad			;     address of the heap and its size are required, along with a memory      : 
14ad			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
14ad			;     principally stores a pointer to the first free block in the heap.       : 
14ad			;                                                                             : 
14ad			; Returns                                                                     : 
14ad			;     Nothing                                                                 : 
14ad			;------------------------------------------------------------------------------ 
14ad			heap_init: 
14ad e5			      push  HL 
14ae			 
14ae			      ; Initialise free list struct 
14ae 21 6e 68		      ld    HL, heap_start 
14b1 22 69 68		      ld    (free_list), HL 
14b4 21 00 00		      ld    HL, 0 
14b7 22 6b 68		      ld    (free_list+2), HL 
14ba			 
14ba			      ; Insert first free block at bottom of heap, consumes entire heap 
14ba 21 98 e2		      ld    HL, heap_start+heap_size-4 
14bd 22 6e 68		      ld    (heap_start), HL        ; Next block (end of free list) 
14c0 21 2a 7a		      ld    HL, heap_size-4 
14c3 22 70 68		      ld    (heap_start+2), HL      ; Block size 
14c6			 
14c6			      ; Insert end of free list block at top of heap - two null words will 
14c6			      ; terminate the free list 
14c6 21 00 00		      ld    HL, 0 
14c9 22 9a e2		      ld    (heap_start+heap_size-2), HL 
14cc 22 98 e2		      ld    (heap_start+heap_size-4), HL 
14cf			 
14cf e1			      pop   HL 
14d0			 
14d0 c9			      ret 
14d1			 
14d1			 
14d1			;------------------------------------------------------------------------------ 
14d1			;     malloc                                                                  : 
14d1			;                                                                             : 
14d1			; Description                                                                 : 
14d1			;     Allocates the wanted space from the heap and returns the address of the : 
14d1			;     first useable byte of the allocation.                                   : 
14d1			;                                                                             : 
14d1			;     Allocations can happen in one of two ways:                              : 
14d1			;                                                                             : 
14d1			;     1. A free block may be found which is the exact size wanted. In this    : 
14d1			;        case the block is removed from the free list and retuedn to the      : 
14d1			;        caller.                                                              : 
14d1			;     2. A free block may be found which is larger than the size wanted. In   : 
14d1			;        this case, the larger block is split into two. The first portion of  : 
14d1			;        this block will become the requested space by the malloc call and    : 
14d1			;        is returned to the caller. The second portion becomes a new free     : 
14d1			;        block, and the free list is adjusted to maintain continuity via this : 
14d1			;        newly created block.                                                 : 
14d1			;                                                                             : 
14d1			;     malloc does not set any initial value in the allocated space, the       : 
14d1			;     caller is required to do this as required.                              : 
14d1			;                                                                             : 
14d1			;     This implementation of malloc uses the stack exclusively, and is        : 
14d1			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14d1			;     advisable to disable interrupts before calling malloc, and recommended  : 
14d1			;     to avoid the use of malloc inside ISRs in general.                      : 
14d1			;                                                                             : 
14d1			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14d1			;                                                                             : 
14d1			; Parameters                                                                  : 
14d1			;     HL  Number of bytes wanted                                              : 
14d1			;                                                                             : 
14d1			; Returns                                                                     : 
14d1			;     HL  Address of the first useable byte of the allocation                 : 
14d1			;                                                                             : 
14d1			; Flags                                                                       : 
14d1			;     Z   Set if the allocation did not succeed, clear otherwise              : 
14d1			;                                                                             : 
14d1			; Stack frame                                                                 : 
14d1			;       |             |                                                       : 
14d1			;       +-------------+                                                       : 
14d1			;       |     BC      |                                                       : 
14d1			;       +-------------+                                                       : 
14d1			;       |     DE      |                                                       : 
14d1			;       +-------------+                                                       : 
14d1			;       |     IX      |                                                       : 
14d1			;       +-------------+                                                       : 
14d1			;       |  prev_free  |                                                       : 
14d1			;   +4  +-------------+                                                       : 
14d1			;       |  this_free  |                                                       : 
14d1			;   +2  +-------------+                                                       : 
14d1			;       |  next_free  |                                                       : 
14d1			;   +0  +-------------+                                                       : 
14d1			;       |             |                                                       : 
14d1			;                                                                             : 
14d1			;------------------------------------------------------------------------------ 
14d1			 
14d1			 
14d1			;malloc: 
14d1			; 
14d1			;	SAVESP ON 1 
14d1			; 
14d1			;	call malloc_code 
14d1			; 
14d1			;	CHECKSP ON 1 
14d1			;	ret 
14d1			 
14d1			 
14d1			malloc: 
14d1 c5			      push  BC 
14d2 d5			      push  DE 
14d3 dd e5		      push  IX 
14d5			if DEBUG_FORTH_MALLOC_HIGH 
14d5			call malloc_guard_entry 
14d5			endif 
14d5			 
14d5					if DEBUG_FORTH_MALLOC 
14d5						DMARK "mal" 
14d5						CALLMONITOR 
14d5					endif 
14d5 7c			      ld    A, H                    ; Exit if no space requested 
14d6 b5			      or    L 
14d7 ca 96 15		      jp    Z, malloc_early_exit 
14da			 
14da			;inc hl 
14da			;inc hl 
14da			;inc hl 
14da			; 
14da			;inc hl 
14da			;inc hl 
14da			;inc hl 
14da			;inc hl 
14da			;inc hl 
14da			;inc hl 
14da			;inc hl 
14da			;inc hl 
14da			;inc hl 
14da			 
14da			 
14da			 
14da			 
14da					if DEBUG_FORTH_MALLOC 
14da						DMARK "maA" 
14da						CALLMONITOR 
14da					endif 
14da			      ; Set up stack frame 
14da eb			      ex    DE, HL 
14db 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
14de 39			      add   HL, SP 
14df f9			      ld    SP, HL 
14e0 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14e4 dd 39		      add   IX, SP 
14e6			 
14e6			      ; Setup initial state 
14e6 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
14e9 19			      add   HL, DE 
14ea			 
14ea 44			      ld    B, H                    ; Move want to BC 
14eb 4d			      ld    C, L 
14ec			 
14ec 21 69 68		      ld    HL, free_list           ; Store prev_free ptr to stack 
14ef dd 75 04		      ld    (IX+4), L 
14f2 dd 74 05		      ld    (IX+5), H 
14f5			 
14f5 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
14f6 23			      inc   HL 
14f7 56			      ld    D, (HL) 
14f8 dd 73 02		      ld    (IX+2), E 
14fb dd 72 03		      ld    (IX+3), D 
14fe eb			      ex    DE, HL                  ; this_free ptr into HL 
14ff			 
14ff					if DEBUG_FORTH_MALLOC 
14ff						DMARK "maB" 
14ff						CALLMONITOR 
14ff					endif 
14ff			      ; Loop through free block list to find some space 
14ff			malloc_find_space: 
14ff 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1500 23			      inc   HL 
1501 56			      ld    D, (HL) 
1502			 
1502 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1503 b3			      or    E 
1504 ca 90 15		      jp    Z, malloc_no_space 
1507			 
1507 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
150a dd 72 01		      ld    (IX+1), D 
150d			 
150d			      ; Does this block have enough space to make the allocation? 
150d 23			      inc   HL                      ; Load free block size into DE 
150e 5e			      ld    E, (HL) 
150f 23			      inc   HL 
1510 56			      ld    D, (HL) 
1511			 
1511 eb			      ex    DE, HL                  ; Check size of block against want 
1512 b7			      or    A                       ; Ensure carry flag clear 
1513 ed 42		      sbc   HL, BC 
1515 e5			      push  HL                      ; Store the result for later (new block size) 
1516			 
1516 ca 65 15		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1519 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
151b			 
151b			      ; this_free block is not big enough, setup ptrs to test next free block 
151b e1			      pop   HL                      ; Discard previous result 
151c			 
151c dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
151f dd 66 03		      ld    H, (IX+3) 
1522 dd 75 04		      ld    (IX+4), L 
1525 dd 74 05		      ld    (IX+5), H 
1528			 
1528 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
152b dd 66 01		      ld    H, (IX+1) 
152e dd 75 02		      ld    (IX+2), L 
1531 dd 74 03		      ld    (IX+3), H 
1534			 
1534					if DEBUG_FORTH_MALLOC 
1534						DMARK "MA>" 
1534						CALLMONITOR 
1534					endif 
1534 18 c9		      jr    malloc_find_space 
1536			 
1536			      ; split a bigger block into two - requested size and remaining size 
1536			malloc_alloc_split: 
1536					if DEBUG_FORTH_MALLOC 
1536						DMARK "MAs" 
1536						CALLMONITOR 
1536					endif 
1536 eb			      ex    DE, HL                  ; Calculate address of new free block 
1537 2b			      dec   HL 
1538 2b			      dec   HL 
1539 2b			      dec   HL 
153a 09			      add   HL, BC 
153b			 
153b			      ; Create a new block and point it at next_free 
153b dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
153e dd 56 01		      ld    D, (IX+1) 
1541			 
1541 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1542 23			      inc   HL 
1543 72			      ld    (HL), D 
1544			 
1544 d1			      pop   DE                      ; Store size of new block into new block 
1545 23			      inc   HL 
1546 73			      ld    (HL), E 
1547 23			      inc   HL 
1548 72			      ld    (HL), D 
1549			 
1549			      ; Update this_free ptr to point to new block 
1549 2b			      dec   HL 
154a 2b			      dec   HL 
154b 2b			      dec   HL 
154c			 
154c dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
154f dd 56 03		      ld    D, (IX+3) 
1552			 
1552 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1555 dd 74 03		      ld    (IX+3), H 
1558			 
1558			      ; Modify this_free block to be allocation 
1558 eb			      ex    DE, HL 
1559 af			      xor   A                       ; Null the next block ptr of allocated block 
155a 77			      ld    (HL), A 
155b 23			      inc   HL 
155c 77			      ld    (HL), A 
155d			 
155d 23			      inc   HL                      ; Store want size into allocated block 
155e 71			      ld    (HL), C 
155f 23			      inc   HL 
1560 70			      ld    (HL), B 
1561 23			      inc   HL 
1562 e5			      push  HL                      ; Address of allocation to return 
1563			 
1563 18 19		      jr    malloc_update_links 
1565			 
1565			malloc_alloc_fit: 
1565 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1566			 
1566					if DEBUG_FORTH_MALLOC 
1566						DMARK "MAf" 
1566						CALLMONITOR 
1566					endif 
1566			      ; Modify this_free block to be allocation 
1566 eb			      ex    DE, HL 
1567 2b			      dec   HL 
1568 2b			      dec   HL 
1569 2b			      dec   HL 
156a			 
156a af			      xor   A                       ; Null the next block ptr of allocated block 
156b 77			      ld    (HL), A 
156c 23			      inc   HL 
156d 77			      ld    (HL), A 
156e			 
156e 23			      inc   HL                      ; Store address of allocation to return 
156f 23			      inc   HL 
1570 23			      inc   HL 
1571 e5			      push  HL 
1572			 
1572			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1572 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1575 dd 66 01		      ld    H, (IX+1) 
1578			 
1578 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
157b dd 74 03		      ld    (IX+3), H 
157e			 
157e			 
157e			malloc_update_links: 
157e			      ; Update prev_free ptr to point to this_free 
157e dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1581 dd 66 05		      ld    H, (IX+5) 
1584			 
1584 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1587 dd 56 03		      ld    D, (IX+3) 
158a			 
158a 73			      ld    (HL), E                 ; this_free ptr into prev_free 
158b 23			      inc   HL 
158c 72			      ld    (HL), D 
158d			 
158d					if DEBUG_FORTH_MALLOC 
158d						DMARK "Mul" 
158d						CALLMONITOR 
158d					endif 
158d			      ; Clear the Z flag to indicate successful allocation 
158d 7a			      ld    A, D 
158e b3			      or    E 
158f			 
158f d1			      pop   DE                      ; Address of allocation 
1590					if DEBUG_FORTH_MALLOC 
1590						DMARK "MAu" 
1590						CALLMONITOR 
1590					endif 
1590			 
1590			malloc_no_space: 
1590 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1593 39			      add   HL, SP 
1594 f9			      ld    SP, HL 
1595			 
1595 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1596					if DEBUG_FORTH_MALLOC 
1596						DMARK "MAN" 
1596						CALLMONITOR 
1596					endif 
1596			 
1596			malloc_early_exit: 
1596					if DEBUG_FORTH_MALLOC 
1596						DMARK "MAx" 
1596						CALLMONITOR 
1596					endif 
1596 dd e1		      pop   IX 
1598 d1			      pop   DE 
1599 c1			      pop   BC 
159a			 
159a			if DEBUG_FORTH_MALLOC_HIGH 
159a			call malloc_guard_exit 
159a			call malloc_guard_zerolen 
159a			endif 
159a c9			      ret 
159b			 
159b			 
159b			;------------------------------------------------------------------------------ 
159b			;     free                                                                    : 
159b			;                                                                             : 
159b			; Description                                                                 : 
159b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
159b			;     returned by malloc, otherwise the behaviour is undefined.               : 
159b			;                                                                             : 
159b			;     Where possible, directly adjacent free blocks will be merged together   : 
159b			;     into larger blocks to help ensure that the heap does not become         : 
159b			;     excessively fragmented.                                                 : 
159b			;                                                                             : 
159b			;     free does not clear or set any other value into the freed space, and    : 
159b			;     therefore its contents may be visible through subsequent malloc's. The  : 
159b			;     caller should clear the freed space as required.                        : 
159b			;                                                                             : 
159b			;     This implementation of free uses the stack exclusively, and is          : 
159b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
159b			;     advisable to disable interrupts before calling free, and recommended    : 
159b			;     to avoid the use of free inside ISRs in general.                        : 
159b			;                                                                             : 
159b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
159b			;                                                                             : 
159b			; Parameters                                                                  : 
159b			;     HL  Pointer to address of first byte of allocation to be freed          : 
159b			;                                                                             : 
159b			; Returns                                                                     : 
159b			;     Nothing                                                                 : 
159b			;                                                                             : 
159b			; Stack frame                                                                 : 
159b			;       |             |                                                       : 
159b			;       +-------------+                                                       : 
159b			;       |     BC      |                                                       : 
159b			;       +-------------+                                                       : 
159b			;       |     DE      |                                                       : 
159b			;       +-------------+                                                       : 
159b			;       |     IX      |                                                       : 
159b			;       +-------------+                                                       : 
159b			;       |  prev_free  |                                                       : 
159b			;   +2  +-------------+                                                       : 
159b			;       |  next_free  |                                                       : 
159b			;   +0  +-------------+                                                       : 
159b			;       |             |                                                       : 
159b			;                                                                             : 
159b			;------------------------------------------------------------------------------ 
159b			free: 
159b c5			      push  BC 
159c d5			      push  DE 
159d dd e5		      push  IX 
159f			 
159f 7c			      ld    A, H                    ; Exit if ptr is null 
15a0 b5			      or    L 
15a1 ca 65 16		      jp    Z, free_early_exit 
15a4			 
15a4			      ; Set up stack frame 
15a4 eb			      ex    DE, HL 
15a5 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15a8 39			      add   HL, SP 
15a9 f9			      ld    SP, HL 
15aa dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
15ae dd 39		      add   IX, SP 
15b0			 
15b0			      ; The address in HL points to the start of the useable allocated space, 
15b0			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15b0			      ; address of the block itself. 
15b0 eb			      ex    DE, HL 
15b1 11 fc ff		      ld    DE, -4 
15b4 19			      add   HL, DE 
15b5			 
15b5			      ; An allocated block must have a null next block pointer in it 
15b5 7e			      ld    A, (HL) 
15b6 23			      inc   HL 
15b7 b6			      or    (HL) 
15b8 c2 60 16		      jp    NZ, free_done 
15bb			 
15bb 2b			      dec   HL 
15bc			 
15bc 44			      ld    B, H                    ; Copy HL to BC 
15bd 4d			      ld    C, L 
15be			 
15be			      ; Loop through the free list to find the first block with an address 
15be			      ; higher than the block being freed 
15be 21 69 68		      ld    HL, free_list 
15c1			 
15c1			free_find_higher_block: 
15c1 5e			      ld    E, (HL)                 ; Load next ptr from free block 
15c2 23			      inc   HL 
15c3 56			      ld    D, (HL) 
15c4 2b			      dec   HL 
15c5			 
15c5 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
15c8 dd 72 01		      ld    (IX+1), D 
15cb dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
15ce dd 74 03		      ld    (IX+3), H 
15d1			 
15d1 78			      ld    A, B                    ; Check if DE is greater than BC 
15d2 ba			      cp    D                       ; Compare MSB first 
15d3 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
15d5 30 04		      jr    NC, free_find_higher_block_skip 
15d7 79			      ld    A, C 
15d8 bb			      cp    E                       ; Then compare LSB 
15d9 38 08		      jr    C, free_found_higher_block 
15db			 
15db			free_find_higher_block_skip: 
15db 7a			      ld    A, D                    ; Reached the end of the free list? 
15dc b3			      or    E 
15dd ca 60 16		      jp    Z, free_done 
15e0			 
15e0 eb			      ex    DE, HL 
15e1			 
15e1 18 de		      jr    free_find_higher_block 
15e3			 
15e3			free_found_higher_block: 
15e3			      ; Insert freed block between prev and next free blocks 
15e3 71			      ld    (HL), C                 ; Point prev free block to freed block 
15e4 23			      inc   HL 
15e5 70			      ld    (HL), B 
15e6			 
15e6 60			      ld    H, B                    ; Point freed block at next free block 
15e7 69			      ld    L, C 
15e8 73			      ld    (HL), E 
15e9 23			      inc   HL 
15ea 72			      ld    (HL), D 
15eb			 
15eb			      ; Check if the freed block is adjacent to the next free block 
15eb 23			      inc   HL                      ; Load size of freed block into HL 
15ec 5e			      ld    E, (HL) 
15ed 23			      inc   HL 
15ee 56			      ld    D, (HL) 
15ef eb			      ex    DE, HL 
15f0			 
15f0 09			      add   HL, BC                  ; Add addr of freed block and its size 
15f1			 
15f1 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
15f4 dd 56 01		      ld    D, (IX+1) 
15f7			 
15f7 b7			      or    A                       ; Clear the carry flag 
15f8 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15fa 20 22		      jr    NZ, free_check_adjacent_to_prev 
15fc			 
15fc			      ; Freed block is adjacent to next, merge into one bigger block 
15fc eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
15fd 5e			      ld    E, (HL) 
15fe 23			      inc   HL 
15ff 56			      ld    D, (HL) 
1600 e5			      push  HL                      ; Save ptr to next block for later 
1601			 
1601 60			      ld    H, B                    ; Store ptr from next block into freed block 
1602 69			      ld    L, C 
1603 73			      ld    (HL), E 
1604 23			      inc   HL 
1605 72			      ld    (HL), D 
1606			 
1606 e1			      pop   HL                      ; Restore ptr to next block 
1607 23			      inc   HL                      ; Load size of next block into DE 
1608 5e			      ld    E, (HL) 
1609 23			      inc   HL 
160a 56			      ld    D, (HL) 
160b d5			      push  DE                      ; Save next block size for later 
160c			 
160c 60			      ld    H, B                    ; Load size of freed block into HL 
160d 69			      ld    L, C 
160e 23			      inc   HL 
160f 23			      inc   HL 
1610 5e			      ld    E, (HL) 
1611 23			      inc   HL 
1612 56			      ld    D, (HL) 
1613 eb			      ex    DE, HL 
1614			 
1614 d1			      pop   DE                      ; Restore size of next block 
1615 19			      add   HL, DE                  ; Add sizes of both blocks 
1616 eb			      ex    DE, HL 
1617			 
1617 60			      ld    H, B                    ; Store new bigger size into freed block 
1618 69			      ld    L, C 
1619 23			      inc   HL 
161a 23			      inc   HL 
161b 73			      ld    (HL), E 
161c 23			      inc   HL 
161d 72			      ld    (HL), D 
161e			 
161e			free_check_adjacent_to_prev: 
161e			      ; Check if the freed block is adjacent to the prev free block 
161e dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1621 dd 66 03		      ld    H, (IX+3) 
1624			 
1624 23			      inc   HL                      ; Size of prev free block into DE 
1625 23			      inc   HL 
1626 5e			      ld    E, (HL) 
1627 23			      inc   HL 
1628 56			      ld    D, (HL) 
1629 2b			      dec   HL 
162a 2b			      dec   HL 
162b 2b			      dec   HL 
162c			 
162c 19			      add   HL, DE                  ; Add prev block addr and size 
162d			 
162d b7			      or    A                       ; Clear the carry flag 
162e ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1630 20 2e		      jr    NZ, free_done 
1632			 
1632			      ; Freed block is adjacent to prev, merge into one bigger block 
1632 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1633 69			      ld    L, C 
1634 5e			      ld    E, (HL) 
1635 23			      inc   HL 
1636 56			      ld    D, (HL) 
1637 e5			      push  HL                      ; Save freed block ptr for later 
1638			 
1638 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
163b dd 66 03		      ld    H, (IX+3) 
163e 73			      ld    (HL), E 
163f 23			      inc   HL 
1640 72			      ld    (HL), D 
1641			 
1641 e1			      pop   HL                      ; Restore freed block ptr 
1642 23			      inc   HL                      ; Load size of freed block into DE 
1643 5e			      ld    E, (HL) 
1644 23			      inc   HL 
1645 56			      ld    D, (HL) 
1646 d5			      push  DE                      ; Save freed block size for later 
1647			 
1647 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
164a dd 66 03		      ld    H, (IX+3) 
164d 23			      inc   HL 
164e 23			      inc   HL 
164f 5e			      ld    E, (HL) 
1650 23			      inc   HL 
1651 56			      ld    D, (HL) 
1652			 
1652 e1			      pop   HL                      ; Add sizes of both blocks 
1653 19			      add   HL, DE 
1654 eb			      ex    DE, HL 
1655			 
1655 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1658 dd 66 03		      ld    H, (IX+3) 
165b 23			      inc   HL 
165c 23			      inc   HL 
165d 73			      ld    (HL), E 
165e 23			      inc   HL 
165f 72			      ld    (HL), D 
1660			 
1660			free_done: 
1660 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1663 39			      add   HL, SP 
1664 f9			      ld    SP, HL 
1665			 
1665			free_early_exit: 
1665 dd e1		      pop   IX 
1667 d1			      pop   DE 
1668 c1			      pop   BC 
1669			 
1669 c9			      ret 
166a			 
166a			; moved to firmware.asm 
166a			; 
166a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
166a			;                  .dw   0 
166a			 
166a			 
166a			endif 
166a			 
166a			 
166a			if MALLOC_3 
166a			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
166a			;heap_start        .equ  0x9000      ; Starting address of heap 
166a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
166a			; 
166a			 ;     .org 0 
166a			  ;    jp    main 
166a			; 
166a			; 
166a			 ;     .org  0x100 
166a			;main: 
166a			 ;     ld    HL, 0x8100 
166a			  ;    ld    SP, HL 
166a			; 
166a			;      call  heap_init 
166a			 
166a			      ; Make some allocations 
166a			;      ld    HL, 12 
166a			;      call  malloc            ; Allocates 0x9004 
166a			; 
166a			 ;     ld    HL, 12 
166a			;      call  malloc            ; Allocates 0x9014 
166a			 
166a			;      ld    HL, 12 
166a			;      call  malloc            ; Allocates 0x9024 
166a			 
166a			      ; Free some allocations 
166a			;      ld    HL, 0x9014 
166a			;      call  free 
166a			 
166a			;      ld    HL, 0x9004 
166a			;      call  free 
166a			; 
166a			;      ld    HL, 0x9024 
166a			;      call  free 
166a			 
166a			 
166a			 ;     halt 
166a			 
166a			 
166a			;------------------------------------------------------------------------------ 
166a			;     heap_init                                                               : 
166a			;                                                                             : 
166a			; Description                                                                 : 
166a			;     Initialise the heap and make it ready for malloc and free operations.   : 
166a			;                                                                             : 
166a			;     The heap is maintained as a linked list, starting with an initial       : 
166a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
166a			;     the first free block in the heap. Each block then points to the next    : 
166a			;     free block within the heap, and the free list ends at the first block   : 
166a			;     with a null pointer to the next free block.                             : 
166a			;                                                                             : 
166a			; Parameters                                                                  : 
166a			;     Inputs are compile-time only. Two defines which specify the starting    : 
166a			;     address of the heap and its size are required, along with a memory      : 
166a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
166a			;     principally stores a pointer to the first free block in the heap.       : 
166a			;                                                                             : 
166a			; Returns                                                                     : 
166a			;     Nothing                                                                 : 
166a			;------------------------------------------------------------------------------ 
166a			heap_init: 
166a			      push  HL 
166a			 
166a			      ; Initialise free list struct 
166a			      ld    HL, heap_start 
166a			      ld    (free_list), HL 
166a			      ld    HL, 0 
166a			      ld    (free_list+2), HL 
166a			 
166a			      ; Insert first free block at bottom of heap, consumes entire heap 
166a			      ld    HL, heap_start+heap_size-4 
166a			      ld    (heap_start), HL        ; Next block (end of free list) 
166a			      ld    HL, heap_size-4 
166a			      ld    (heap_start+2), HL      ; Block size 
166a			 
166a			      ; Insert end of free list block at top of heap - two null words will 
166a			      ; terminate the free list 
166a			      ld    HL, 0 
166a			      ld    (heap_start+heap_size-2), HL 
166a			      ld    (heap_start+heap_size-4), HL 
166a			 
166a			      pop   HL 
166a			 
166a			      ret 
166a			 
166a			 
166a			;------------------------------------------------------------------------------ 
166a			;     malloc                                                                  : 
166a			;                                                                             : 
166a			; Description                                                                 : 
166a			;     Allocates the wanted space from the heap and returns the address of the : 
166a			;     first useable byte of the allocation.                                   : 
166a			;                                                                             : 
166a			;     Allocations can happen in one of two ways:                              : 
166a			;                                                                             : 
166a			;     1. A free block may be found which is the exact size wanted. In this    : 
166a			;        case the block is removed from the free list and retuedn to the      : 
166a			;        caller.                                                              : 
166a			;     2. A free block may be found which is larger than the size wanted. In   : 
166a			;        this case, the larger block is split into two. The first portion of  : 
166a			;        this block will become the requested space by the malloc call and    : 
166a			;        is returned to the caller. The second portion becomes a new free     : 
166a			;        block, and the free list is adjusted to maintain continuity via this : 
166a			;        newly created block.                                                 : 
166a			;                                                                             : 
166a			;     malloc does not set any initial value in the allocated space, the       : 
166a			;     caller is required to do this as required.                              : 
166a			;                                                                             : 
166a			;     This implementation of malloc uses the stack exclusively, and is        : 
166a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
166a			;     advisable to disable interrupts before calling malloc, and recommended  : 
166a			;     to avoid the use of malloc inside ISRs in general.                      : 
166a			;                                                                             : 
166a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
166a			;                                                                             : 
166a			; Parameters                                                                  : 
166a			;     HL  Number of bytes wanted                                              : 
166a			;                                                                             : 
166a			; Returns                                                                     : 
166a			;     HL  Address of the first useable byte of the allocation                 : 
166a			;                                                                             : 
166a			; Flags                                                                       : 
166a			;     Z   Set if the allocation did not succeed, clear otherwise              : 
166a			;                                                                             : 
166a			; Stack frame                                                                 : 
166a			;       |             |                                                       : 
166a			;       +-------------+                                                       : 
166a			;       |     BC      |                                                       : 
166a			;       +-------------+                                                       : 
166a			;       |     DE      |                                                       : 
166a			;       +-------------+                                                       : 
166a			;       |     IX      |                                                       : 
166a			;       +-------------+                                                       : 
166a			;       |  prev_free  |                                                       : 
166a			;   +4  +-------------+                                                       : 
166a			;       |  this_free  |                                                       : 
166a			;   +2  +-------------+                                                       : 
166a			;       |  next_free  |                                                       : 
166a			;   +0  +-------------+                                                       : 
166a			;       |             |                                                       : 
166a			;                                                                             : 
166a			;------------------------------------------------------------------------------ 
166a			malloc: 
166a			      push  BC 
166a			      push  DE 
166a			      push  IX 
166a			 
166a			      ld    A, H                    ; Exit if no space requested 
166a			      or    L 
166a			      jp    Z, malloc_early_exit 
166a			 
166a			      ; Set up stack frame 
166a			      ex    DE, HL 
166a			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
166a			      add   HL, SP 
166a			      ld    SP, HL 
166a			      ld    IX, 0                   ; Use IX as a frame pointer 
166a			      add   IX, SP 
166a			 
166a			      ; Setup initial state 
166a			      ld    HL, 4                   ; want must also include space used by block struct 
166a			      add   HL, DE 
166a			 
166a			      ld    B, H                    ; Move want to BC 
166a			      ld    C, L 
166a			 
166a			      ld    HL, free_list           ; Store prev_free ptr to stack 
166a			      ld    (IX+4), L 
166a			      ld    (IX+5), H 
166a			 
166a			      ld    E, (HL)                 ; Store this_free ptr to stack 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			      ld    (IX+2), E 
166a			      ld    (IX+3), D 
166a			      ex    DE, HL                  ; this_free ptr into HL 
166a			 
166a			      ; Loop through free block list to find some space 
166a			malloc_find_space: 
166a			      ld    E, (HL)                 ; Load next_free ptr into DE 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			 
166a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
166a			      or    E 
166a			      jp    Z, malloc_no_space 
166a			 
166a			      ld    (IX+0), E               ; Store next_free ptr to stack 
166a			      ld    (IX+1), D 
166a			 
166a			      ; Does this block have enough space to make the allocation? 
166a			      inc   HL                      ; Load free block size into DE 
166a			      ld    E, (HL) 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			 
166a			      ex    DE, HL                  ; Check size of block against want 
166a			      or    A                       ; Ensure carry flag clear 
166a			      sbc   HL, BC 
166a			      push  HL                      ; Store the result for later (new block size) 
166a			 
166a			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
166a			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
166a			 
166a			      ; this_free block is not big enough, setup ptrs to test next free block 
166a			      pop   HL                      ; Discard previous result 
166a			 
166a			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
166a			      ld    H, (IX+3) 
166a			      ld    (IX+4), L 
166a			      ld    (IX+5), H 
166a			 
166a			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
166a			      ld    H, (IX+1) 
166a			      ld    (IX+2), L 
166a			      ld    (IX+3), H 
166a			 
166a			      jr    malloc_find_space 
166a			 
166a			      ; split a bigger block into two - requested size and remaining size 
166a			malloc_alloc_split: 
166a			      ex    DE, HL                  ; Calculate address of new free block 
166a			      dec   HL 
166a			      dec   HL 
166a			      dec   HL 
166a			      add   HL, BC 
166a			 
166a			      ; Create a new block and point it at next_free 
166a			      ld    E, (IX+0)               ; Load next_free ptr into DE 
166a			      ld    D, (IX+1) 
166a			 
166a			      ld    (HL), E                 ; Store next_free ptr into new block 
166a			      inc   HL 
166a			      ld    (HL), D 
166a			 
166a			      pop   DE                      ; Store size of new block into new block 
166a			      inc   HL 
166a			      ld    (HL), E 
166a			      inc   HL 
166a			      ld    (HL), D 
166a			 
166a			      ; Update this_free ptr to point to new block 
166a			      dec   HL 
166a			      dec   HL 
166a			      dec   HL 
166a			 
166a			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
166a			      ld    D, (IX+3) 
166a			 
166a			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
166a			      ld    (IX+3), H 
166a			 
166a			      ; Modify this_free block to be allocation 
166a			      ex    DE, HL 
166a			      xor   A                       ; Null the next block ptr of allocated block 
166a			      ld    (HL), A 
166a			      inc   HL 
166a			      ld    (HL), A 
166a			 
166a			      inc   HL                      ; Store want size into allocated block 
166a			      ld    (HL), C 
166a			      inc   HL 
166a			      ld    (HL), B 
166a			      inc   HL 
166a			      push  HL                      ; Address of allocation to return 
166a			 
166a			      jr    malloc_update_links 
166a			 
166a			malloc_alloc_fit: 
166a			      pop   HL                      ; Dont need new block size, want is exact fit 
166a			 
166a			      ; Modify this_free block to be allocation 
166a			      ex    DE, HL 
166a			      dec   HL 
166a			      dec   HL 
166a			      dec   HL 
166a			 
166a			      xor   A                       ; Null the next block ptr of allocated block 
166a			      ld    (HL), A 
166a			      inc   HL 
166a			      ld    (HL), A 
166a			 
166a			      inc   HL                      ; Store address of allocation to return 
166a			      inc   HL 
166a			      inc   HL 
166a			      push  HL 
166a			 
166a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
166a			      ld    L, (IX+0)               ; next_free to HL 
166a			      ld    H, (IX+1) 
166a			 
166a			      ld    (IX+2), L               ; HL to this_free 
166a			      ld    (IX+3), H 
166a			 
166a			 
166a			malloc_update_links: 
166a			      ; Update prev_free ptr to point to this_free 
166a			      ld    L, (IX+4)               ; prev_free ptr to HL 
166a			      ld    H, (IX+5) 
166a			 
166a			      ld    E, (IX+2)               ; this_free ptr to DE 
166a			      ld    D, (IX+3) 
166a			 
166a			      ld    (HL), E                 ; this_free ptr into prev_free 
166a			      inc   HL 
166a			      ld    (HL), D 
166a			 
166a			      ; Clear the Z flag to indicate successful allocation 
166a			      ld    A, D 
166a			      or    E 
166a			 
166a			      pop   DE                      ; Address of allocation 
166a			 
166a			malloc_no_space: 
166a			      ld    HL, 6                   ; Clean up stack frame 
166a			      add   HL, SP 
166a			      ld    SP, HL 
166a			 
166a			      ex    DE, HL                  ; Alloc addr into HL for return 
166a			 
166a			malloc_early_exit: 
166a			      pop   IX 
166a			      pop   DE 
166a			      pop   BC 
166a			 
166a			      ret 
166a			 
166a			 
166a			;------------------------------------------------------------------------------ 
166a			;     free                                                                    : 
166a			;                                                                             : 
166a			; Description                                                                 : 
166a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
166a			;     returned by malloc, otherwise the behaviour is undefined.               : 
166a			;                                                                             : 
166a			;     Where possible, directly adjacent free blocks will be merged together   : 
166a			;     into larger blocks to help ensure that the heap does not become         : 
166a			;     excessively fragmented.                                                 : 
166a			;                                                                             : 
166a			;     free does not clear or set any other value into the freed space, and    : 
166a			;     therefore its contents may be visible through subsequent malloc's. The  : 
166a			;     caller should clear the freed space as required.                        : 
166a			;                                                                             : 
166a			;     This implementation of free uses the stack exclusively, and is          : 
166a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
166a			;     advisable to disable interrupts before calling free, and recommended    : 
166a			;     to avoid the use of free inside ISRs in general.                        : 
166a			;                                                                             : 
166a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
166a			;                                                                             : 
166a			; Parameters                                                                  : 
166a			;     HL  Pointer to address of first byte of allocation to be freed          : 
166a			;                                                                             : 
166a			; Returns                                                                     : 
166a			;     Nothing                                                                 : 
166a			;                                                                             : 
166a			; Stack frame                                                                 : 
166a			;       |             |                                                       : 
166a			;       +-------------+                                                       : 
166a			;       |     BC      |                                                       : 
166a			;       +-------------+                                                       : 
166a			;       |     DE      |                                                       : 
166a			;       +-------------+                                                       : 
166a			;       |     IX      |                                                       : 
166a			;       +-------------+                                                       : 
166a			;       |  prev_free  |                                                       : 
166a			;   +2  +-------------+                                                       : 
166a			;       |  next_free  |                                                       : 
166a			;   +0  +-------------+                                                       : 
166a			;       |             |                                                       : 
166a			;                                                                             : 
166a			;------------------------------------------------------------------------------ 
166a			free: 
166a			      push  BC 
166a			      push  DE 
166a			      push  IX 
166a			 
166a			      ld    A, H                    ; Exit if ptr is null 
166a			      or    L 
166a			      jp    Z, free_early_exit 
166a			 
166a			      ; Set up stack frame 
166a			      ex    DE, HL 
166a			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
166a			      add   HL, SP 
166a			      ld    SP, HL 
166a			      ld    IX, 0                   ; Use IX as a frame pointer 
166a			      add   IX, SP 
166a			 
166a			      ; The address in HL points to the start of the useable allocated space, 
166a			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
166a			      ; address of the block itself. 
166a			      ex    DE, HL 
166a			      ld    DE, -4 
166a			      add   HL, DE 
166a			 
166a			      ; An allocated block must have a null next block pointer in it 
166a			      ld    A, (HL) 
166a			      inc   HL 
166a			      or    (HL) 
166a			      jp    NZ, free_done 
166a			 
166a			      dec   HL 
166a			 
166a			      ld    B, H                    ; Copy HL to BC 
166a			      ld    C, L 
166a			 
166a			      ; Loop through the free list to find the first block with an address 
166a			      ; higher than the block being freed 
166a			      ld    HL, free_list 
166a			 
166a			free_find_higher_block: 
166a			      ld    E, (HL)                 ; Load next ptr from free block 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			      dec   HL 
166a			 
166a			      ld    (IX+0), E               ; Save ptr to next free block 
166a			      ld    (IX+1), D 
166a			      ld    (IX+2), L               ; Save ptr to prev free block 
166a			      ld    (IX+3), H 
166a			 
166a			      ld    A, B                    ; Check if DE is greater than BC 
166a			      cp    D                       ; Compare MSB first 
166a			      jr    Z, $+4                  ; MSB the same, compare LSB 
166a			      jr    NC, free_find_higher_block_skip 
166a			      ld    A, C 
166a			      cp    E                       ; Then compare LSB 
166a			      jr    C, free_found_higher_block 
166a			 
166a			free_find_higher_block_skip: 
166a			      ld    A, D                    ; Reached the end of the free list? 
166a			      or    E 
166a			      jp    Z, free_done 
166a			 
166a			      ex    DE, HL 
166a			 
166a			      jr    free_find_higher_block 
166a			 
166a			free_found_higher_block: 
166a			      ; Insert freed block between prev and next free blocks 
166a			      ld    (HL), C                 ; Point prev free block to freed block 
166a			      inc   HL 
166a			      ld    (HL), B 
166a			 
166a			      ld    H, B                    ; Point freed block at next free block 
166a			      ld    L, C 
166a			      ld    (HL), E 
166a			      inc   HL 
166a			      ld    (HL), D 
166a			 
166a			      ; Check if the freed block is adjacent to the next free block 
166a			      inc   HL                      ; Load size of freed block into HL 
166a			      ld    E, (HL) 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			      ex    DE, HL 
166a			 
166a			      add   HL, BC                  ; Add addr of freed block and its size 
166a			 
166a			      ld    E, (IX+0)               ; Load addr of next free block into DE 
166a			      ld    D, (IX+1) 
166a			 
166a			      or    A                       ; Clear the carry flag 
166a			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
166a			      jr    NZ, free_check_adjacent_to_prev 
166a			 
166a			      ; Freed block is adjacent to next, merge into one bigger block 
166a			      ex    DE, HL                  ; Load next ptr from next block into DE 
166a			      ld    E, (HL) 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			      push  HL                      ; Save ptr to next block for later 
166a			 
166a			      ld    H, B                    ; Store ptr from next block into freed block 
166a			      ld    L, C 
166a			      ld    (HL), E 
166a			      inc   HL 
166a			      ld    (HL), D 
166a			 
166a			      pop   HL                      ; Restore ptr to next block 
166a			      inc   HL                      ; Load size of next block into DE 
166a			      ld    E, (HL) 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			      push  DE                      ; Save next block size for later 
166a			 
166a			      ld    H, B                    ; Load size of freed block into HL 
166a			      ld    L, C 
166a			      inc   HL 
166a			      inc   HL 
166a			      ld    E, (HL) 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			      ex    DE, HL 
166a			 
166a			      pop   DE                      ; Restore size of next block 
166a			      add   HL, DE                  ; Add sizes of both blocks 
166a			      ex    DE, HL 
166a			 
166a			      ld    H, B                    ; Store new bigger size into freed block 
166a			      ld    L, C 
166a			      inc   HL 
166a			      inc   HL 
166a			      ld    (HL), E 
166a			      inc   HL 
166a			      ld    (HL), D 
166a			 
166a			free_check_adjacent_to_prev: 
166a			      ; Check if the freed block is adjacent to the prev free block 
166a			      ld    L, (IX+2)               ; Prev free block ptr into HL 
166a			      ld    H, (IX+3) 
166a			 
166a			      inc   HL                      ; Size of prev free block into DE 
166a			      inc   HL 
166a			      ld    E, (HL) 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			      dec   HL 
166a			      dec   HL 
166a			      dec   HL 
166a			 
166a			      add   HL, DE                  ; Add prev block addr and size 
166a			 
166a			      or    A                       ; Clear the carry flag 
166a			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
166a			      jr    NZ, free_done 
166a			 
166a			      ; Freed block is adjacent to prev, merge into one bigger block 
166a			      ld    H, B                    ; Load next ptr from freed block into DE 
166a			      ld    L, C 
166a			      ld    E, (HL) 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			      push  HL                      ; Save freed block ptr for later 
166a			 
166a			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
166a			      ld    H, (IX+3) 
166a			      ld    (HL), E 
166a			      inc   HL 
166a			      ld    (HL), D 
166a			 
166a			      pop   HL                      ; Restore freed block ptr 
166a			      inc   HL                      ; Load size of freed block into DE 
166a			      ld    E, (HL) 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			      push  DE                      ; Save freed block size for later 
166a			 
166a			      ld    L, (IX+2)               ; Load size of prev block into DE 
166a			      ld    H, (IX+3) 
166a			      inc   HL 
166a			      inc   HL 
166a			      ld    E, (HL) 
166a			      inc   HL 
166a			      ld    D, (HL) 
166a			 
166a			      pop   HL                      ; Add sizes of both blocks 
166a			      add   HL, DE 
166a			      ex    DE, HL 
166a			 
166a			      ld    L, (IX+2)               ; Store new bigger size into prev block 
166a			      ld    H, (IX+3) 
166a			      inc   HL 
166a			      inc   HL 
166a			      ld    (HL), E 
166a			      inc   HL 
166a			      ld    (HL), D 
166a			 
166a			free_done: 
166a			      ld    HL, 4                   ; Clean up stack frame 
166a			      add   HL, SP 
166a			      ld    SP, HL 
166a			 
166a			free_early_exit: 
166a			      pop   IX 
166a			      pop   DE 
166a			      pop   BC 
166a			 
166a			      ret 
166a			 
166a			 
166a			;      .org 0x8000 
166a			; 
166a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
166a			 ;                 .dw   0 
166a			 
166a			endif 
166a			 
166a			 
166a			if MALLOC_4 
166a			 
166a			; My memory allocation code. Very very simple.... 
166a			; allocate space under 250 chars 
166a			 
166a			heap_init: 
166a				; init start of heap as zero 
166a				;  
166a			 
166a				ld hl, heap_start 
166a				ld a, 0 
166a				ld (hl), a      ; empty block 
166a				inc hl 
166a				ld a, 0 
166a				ld (hl), a      ; length of block 
166a				; write end of list 
166a				inc hl 
166a				ld a,(hl) 
166a				inc hl 
166a				ld a,(hl) 
166a				 
166a			 
166a				; init some malloc vars 
166a			 
166a				ld hl, 0 
166a				ld (free_list), hl       ; store last malloc location 
166a			 
166a				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
166a				ld a, 0 
166a				ld (hl), a 
166a			 
166a			 
166a				ld hl, heap_start 
166a				;  
166a				  
166a				ret 
166a			 
166a			 
166a			;    free block marker 
166a			;    requested size  
166a			;    pointer to next block 
166a			;    .... 
166a			;    next block marker 
166a			 
166a			 
166a			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
166a			; 
166a			 
166a			 
166a			malloc:  
166a				push de 
166a				push bc 
166a				push af 
166a			 
166a				; hl space required 
166a				 
166a				ld c, l    ; hold space   (TODO only a max of 255) 
166a			 
166a			;	inc c     ; TODO BUG need to fix memory leak on push str 
166a			;	inc c 
166a			;	inc c 
166a			;	inc c 
166a			;	inc c 
166a			;	inc c 
166a			;	inc c 
166a			 
166a			 
166a			 
166a				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
166a			 
166a				ld a, (free_list+3) 
166a				cp 0 
166a				jr z, .contheap 
166a			 
166a				ld hl, (free_list)     ; get last alloc 
166a					if DEBUG_FORTH_MALLOC_INT 
166a						DMARK "mrs" 
166a						CALLMONITOR 
166a					endif 
166a				jr .startalloc 
166a			 
166a			.contheap: 
166a				ld hl, heap_start 
166a			 
166a			.startalloc: 
166a			 
166a					if DEBUG_FORTH_MALLOC_INT 
166a						DMARK "mym" 
166a						CALLMONITOR 
166a					endif 
166a			.findblock: 
166a					if DEBUG_FORTH_MALLOC_INT 
166a						DMARK "mmf" 
166a						CALLMONITOR 
166a					endif 
166a			 
166a				ld a,(hl)  
166a				; if byte is zero then clear to use 
166a			 
166a				cp 0 
166a				jr z, .foundemptyblock 
166a			 
166a				; if byte is not clear 
166a				;     then byte is offset to next block 
166a			 
166a				inc hl 
166a				ld a, (hl) ; get size 
166a			.nextblock:	inc hl 
166a					ld e, (hl) 
166a					inc hl 
166a					ld d, (hl) 
166a					ex de, hl 
166a			;	inc hl  ; move past the store space 
166a			;	inc hl  ; move past zero index  
166a			 
166a				; TODO detect no more space 
166a			 
166a				push hl 
166a				ld de, heap_end 
166a				call cmp16 
166a				pop hl 
166a				jr nc, .nospace 
166a			 
166a				jr .findblock 
166a			 
166a			.nospace: ld hl, 0 
166a				jp .exit 
166a			 
166a			 
166a			.foundemptyblock:	 
166a					if DEBUG_FORTH_MALLOC_INT 
166a						DMARK "mme" 
166a						CALLMONITOR 
166a					endif 
166a			 
166a			; TODO has block enough space if reusing??? 
166a			 
166a				;  
166a			 
166a			; see if this block has been previously used 
166a				inc hl 
166a				ld a, (hl) 
166a				dec hl 
166a				cp 0 
166a				jr z, .newblock 
166a			 
166a					if DEBUG_FORTH_MALLOC_INT 
166a						DMARK "meR" 
166a						CALLMONITOR 
166a					endif 
166a			 
166a			; no reusing previously allocated block 
166a			 
166a			; is it smaller than previously used? 
166a				 
166a				inc hl    ; move to size 
166a				ld a, c 
166a				sub (hl)        ; we want c < (hl) 
166a				dec hl    ; move back to marker 
166a			        jr z, .findblock 
166a			 
166a				; update with the new size which should be lower 
166a			 
166a			        ;inc  hl   ; negate next move. move back to size  
166a			 
166a			.newblock: 
166a				; need to be at marker here 
166a			 
166a					if DEBUG_FORTH_MALLOC_INT 
166a						DMARK "meN" 
166a						CALLMONITOR 
166a					endif 
166a			 
166a			 
166a				ld a, c 
166a			 
166a				ld (free_list+3), a	 ; flag resume from last malloc  
166a				ld (free_list), hl    ; save out last location 
166a			 
166a			 
166a				;inc a     ; space for length byte 
166a				ld (hl), a     ; save block in use marker 
166a			 
166a				inc hl   ; move to space marker 
166a				ld (hl), a    ; save new space 
166a			 
166a				inc hl   ; move to start of allocated area 
166a				 
166a			;	push hl     ; save where we are - 1  
166a			 
166a			;	inc hl  ; move past zero index  
166a				; skip space to set down new marker 
166a			 
166a				; provide some extra space for now 
166a			 
166a				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
166a				inc a 
166a				inc a 
166a			 
166a				push hl   ; save where we are in the node block 
166a			 
166a				call addatohl 
166a			 
166a				; write linked list point 
166a			 
166a				pop de     ; get our node position 
166a				ex de, hl 
166a			 
166a				ld (hl), e 
166a				inc hl 
166a				ld (hl), d 
166a			 
166a				inc hl 
166a			 
166a				; now at start of allocated data so save pointer 
166a			 
166a				push hl 
166a			 
166a				; jump to position of next node and setup empty header in DE 
166a			 
166a				ex de, hl 
166a			 
166a			;	inc hl ; move past end of block 
166a			 
166a				ld a, 0 
166a				ld (hl), a   ; empty marker 
166a				inc hl 
166a				ld (hl), a   ; size 
166a				inc hl  
166a				ld (hl), a   ; ptr 
166a				inc hl 
166a				ld (hl), a   ; ptr 
166a			 
166a			 
166a				pop hl 
166a			 
166a					if DEBUG_FORTH_MALLOC_INT 
166a						DMARK "mmr" 
166a						CALLMONITOR 
166a					endif 
166a			 
166a			.exit: 
166a				pop af 
166a				pop bc 
166a				pop de  
166a				ret 
166a			 
166a			 
166a			 
166a			 
166a			free:  
166a				push hl 
166a				push af 
166a				; get address in hl 
166a			 
166a					if DEBUG_FORTH_MALLOC_INT 
166a						DMARK "fre" 
166a						CALLMONITOR 
166a					endif 
166a				; data is at hl - move to block count 
166a				dec hl 
166a				dec hl    ; get past pointer 
166a				dec hl 
166a			 
166a				ld a, (hl)    ; need this for a validation check 
166a			 
166a				dec hl    ; move to block marker 
166a			 
166a				; now check that the block count and block marker are the same  
166a			        ; this checks that we are on a malloc node and not random memory 
166a			        ; OK a faint chance this could be a problem but rare - famous last words! 
166a			 
166a				ld c, a 
166a				ld a, (hl)    
166a			 
166a				cp c 
166a				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
166a			 
166a				; yes good chance we are on a malloc node 
166a			 
166a				ld a, 0      
166a				ld (hl), a   ; mark as free 
166a			 
166a				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
166a			 
166a			.freeignore:  
166a			 
166a				pop af 
166a				pop hl 
166a			 
166a				ret 
166a			 
166a			 
166a			 
166a			endif 
166a			 
166a			; eof 
# End of file firmware_memory.asm
166a			  
166a			; device C  
166a			; Now handled by SPI  
166a			;if SOUND_ENABLE  
166a			;	include "firmware_sound.asm"  
166a			;endif  
166a			  
166a			include "firmware_diags.asm"  
166a			; Hardware diags menu 
166a			 
166a			 
166a			config: 
166a			 
166a 3e 00			ld a, 0 
166c 21 90 16			ld hl, .configmn 
166f cd ea 0b			call menu 
1672			 
1672 fe 00			cp 0 
1674 c8				ret z 
1675			 
1675			;	cp 1 
1675			;	call z, .savetostore 
1675			 
1675 fe 01			cp 1 
1677			if STARTUP_V1 
1677 cc a6 16			call z, .selautoload 
167a			endif 
167a			 
167a			if STARTUP_V2 
167a				call z, .enautoload 
167a			endif 
167a fe 02			cp 2 
167c cc 9c 16			call z, .disautoload 
167f			;	cp 3 
167f			;	call z, .selbank 
167f fe 03			cp 3 
1681 cc c4 16			call z, .debug_tog 
1684 fe 04			cp 4 
1686 cc 12 18			call z, .bpsgo 
1689 fe 05			cp 5 
168b cc ed 16			call z, hardware_diags 
168e			if STARTUP_V2 
168e				cp 6 
168e				call z, create_startup 
168e			endif 
168e 18 da			jr config 
1690			 
1690			.configmn: 
1690			;	dw prom_c3 
1690 00 1a			dw prom_c2 
1692 15 1a			dw prom_c2a 
1694			;	dw prom_c2b 
1694			;	dw prom_c4 
1694 34 1a			dw prom_m4 
1696 4f 1a			dw prom_m4b 
1698 57 1a			dw prom_c1 
169a			if STARTUP_V2 
169a				dw prom_c9 
169a			endif 
169a 00 00			dw 0 
169c				 
169c			 
169c			if STARTUP_V2 
169c			.enautoload: 
169c				if STORAGE_SE 
169c				ld a, $fe      ; bit 0 clear 
169c				ld (spi_device), a 
169c			 
169c				call storage_get_block_0 
169c			 
169c				ld a, 1 
169c				ld (store_page+STORE_0_AUTOFILE), a 
169c			 
169c					ld hl, 0 
169c					ld de, store_page 
169c				call storage_write_block	 ; save update 
169c				else 
169c			 
169c				ld hl, prom_notav 
169c				ld de, prom_empty 
169c				call info_panel 
169c				endif 
169c			 
169c			 
169c				ret 
169c			endif 
169c			 
169c			.disautoload: 
169c				if STORAGE_SE 
169c				ld a, $fe      ; bit 0 clear 
169c				ld (spi_device), a 
169c			 
169c				call storage_get_block_0 
169c			 
169c				ld a, 0 
169c				ld (store_page+STORE_0_AUTOFILE), a 
169c			 
169c					ld hl, 0 
169c					ld de, store_page 
169c				call storage_write_block	 ; save update 
169c				else 
169c			 
169c 21 66 1a			ld hl, prom_notav 
169f 11 7c 1a			ld de, prom_empty 
16a2 cd 4a 0b			call info_panel 
16a5				endif 
16a5			 
16a5			 
16a5 c9				ret 
16a6			 
16a6			if STARTUP_V1 
16a6			 
16a6			; Select auto start 
16a6			 
16a6			.selautoload: 
16a6			 
16a6				 
16a6				if STORAGE_SE 
16a6			 
16a6					call config_dir 
16a6				        ld hl, scratch 
16a6					ld a, 0 
16a6					call menu 
16a6			 
16a6					cp 0 
16a6					ret z 
16a6			 
16a6					dec a 
16a6			 
16a6			 
16a6					; locate menu option 
16a6			 
16a6					ld hl, scratch 
16a6					call table_lookup 
16a6			 
16a6					if DEBUG_FORTH_WORDS 
16a6						DMARK "ALl" 
16a6						CALLMONITOR 
16a6					endif 
16a6					; with the pointer to the menu it, the byte following the zero term is the file id 
16a6			 
16a6					ld a, 0 
16a6					ld bc, 50   ; max of bytes to look at 
16a6					cpir  
16a6			 
16a6					if DEBUG_FORTH_WORDS 
16a6						DMARK "ALb" 
16a6						CALLMONITOR 
16a6					endif 
16a6					;inc hl 
16a6			 
16a6					ld a, (hl)   ; file id 
16a6					 
16a6				        ; save bank and file ids 
16a6			 
16a6					push af 
16a6			 
16a6			; TODO need to save to block 0 on bank 1	 
16a6			 
16a6					call storage_get_block_0 
16a6			 
16a6					if DEBUG_FORTH_WORDS 
16a6						DMARK "AL0" 
16a6						CALLMONITOR 
16a6					endif 
16a6					pop af 
16a6			 
16a6					ld (store_page+STORE_0_FILERUN),a 
16a6					 
16a6					; save bank id 
16a6			 
16a6					ld a,(spi_device) 
16a6					ld (store_page+STORE_0_BANKRUN),a 
16a6			 
16a6					; enable auto run of store file 
16a6			 
16a6					ld a, 1 
16a6					ld (store_page+STORE_0_AUTOFILE),a 
16a6			 
16a6					; save buffer 
16a6			 
16a6					ld hl, 0 
16a6					ld de, store_page 
16a6					if DEBUG_FORTH_WORDS 
16a6						DMARK "ALw" 
16a6						CALLMONITOR 
16a6					endif 
16a6				call storage_write_block	 ; save update 
16a6			  
16a6			 
16a6			 
16a6			 
16a6					ld hl, scratch 
16a6					call config_fdir 
16a6			 
16a6				else 
16a6			 
16a6 21 66 1a			ld hl, prom_notav 
16a9 11 7c 1a			ld de, prom_empty 
16ac cd 4a 0b			call info_panel 
16af			 
16af				endif 
16af c9				ret 
16b0			endif 
16b0			 
16b0			 
16b0			; Select storage bank 
16b0			 
16b0			.selbank: 
16b0			 
16b0			;	if STORAGE_SE 
16b0			;	else 
16b0			 
16b0 21 66 1a			ld hl, prom_notav 
16b3 11 7c 1a			ld de, prom_empty 
16b6 cd 4a 0b			call info_panel 
16b9			;	endif 
16b9				 
16b9 c9				ret 
16ba			 
16ba			if STORAGE_SE 
16ba			 
16ba			.config_ldir:   
16ba				; Load storage bank labels into menu array 
16ba			 
16ba				 
16ba			 
16ba			 
16ba				ret 
16ba			 
16ba			 
16ba			endif 
16ba			 
16ba			 
16ba			; Save user words to storage 
16ba			 
16ba			.savetostore: 
16ba			 
16ba			;	if STORAGE_SE 
16ba			; 
16ba			;		call config_dir 
16ba			;	        ld hl, scratch 
16ba			;		ld a, 0 
16ba			;		call menu 
16ba			;		 
16ba			;		ld hl, scratch 
16ba			;		call config_fdir 
16ba			; 
16ba			;	else 
16ba			 
16ba 21 66 1a			ld hl, prom_notav 
16bd 11 7c 1a			ld de, prom_empty 
16c0 cd 4a 0b			call info_panel 
16c3			 
16c3			;	endif 
16c3			 
16c3 c9				ret 
16c4			 
16c4			if STARTUP_V2 
16c4			 
16c4			create_startup: 
16c4			 
16c4				ld a, 0 
16c4				ld hl, .crstart 
16c4				call menu 
16c4			 
16c4				cp 0 
16c4				ret z 
16c4			 
16c4				cp 1 
16c4				call z, .genlsword 
16c4				cp 2 
16c4				call z, .genedword 
16c4			 
16c4				cp 3 
16c4				call z, .gendemword 
16c4			 
16c4				cp 4 
16c4				call z, .genutlword 
16c4				cp 5 
16c4				call z, .genspiword 
16c4				cp 6 
16c4				call z, .genkeyword 
16c4				cp 7 
16c4				call z, .gensoundword 
16c4				jr create_startup 
16c4			 
16c4			.gensoundword: 
16c4				ld hl, crs_sound 
16c4				ld de, .soundworddef 
16c4				call .genfile 
16c4				ret 
16c4			.genlsword: 
16c4				ld hl, crs_s1 
16c4				ld de, .lsworddef 
16c4				call .genfile 
16c4				ret 
16c4			 
16c4			.genedword: 
16c4				ld de, .edworddef 
16c4				ld hl, crs_s2 
16c4				call .genfile 
16c4				ret 
16c4			 
16c4			.gendemword: 
16c4				ld de, .demoworddef 
16c4				ld hl, crs_s3 
16c4				call .genfile 
16c4				ret 
16c4			 
16c4			.genutlword: 
16c4				ld hl, crs_s4 
16c4				ld de, .utilwordef 
16c4				call .genfile 
16c4				ret 
16c4			.genspiword: 
16c4				ld hl, crs_s5 
16c4				ld de, .spiworddef 
16c4				call .genfile 
16c4				ret 
16c4			.genkeyword: 
16c4				ld hl, crs_s6 
16c4				ld de, .keyworddef 
16c4				call .genfile 
16c4				ret 
16c4			 
16c4			; hl - points to file name 
16c4			; de - points to strings to add to file 
16c4			 
16c4			.genfile: 
16c4				push hl 
16c4				push de 
16c4			 
16c4				call clear_display 
16c4				ld a, display_row_1 
16c4				ld de, .genfiletxt 
16c4				call str_at_display 
16c4				call update_display 
16c4			 
16c4				pop de 
16c4				pop hl 
16c4			 
16c4			 
16c4				push de 
16c4				call storage_create 
16c4				; id in hl 
16c4				pop de   ; table of strings to add 
16c4			 
16c4			.genloop: 
16c4			 
16c4				push hl ; save id for next time around 
16c4				push de ; save de for next time around 
16c4			 
16c4				ex de, hl 
16c4				call loadwordinhl 
16c4				ex de, hl 
16c4			 
16c4				; need hl to be the id 
16c4				; need de to be the string ptr 
16c4				 
16c4				call storage_append 
16c4			 
16c4				pop de 
16c4				pop hl 
16c4			 
16c4				inc de 
16c4				inc de 
16c4			 
16c4				ld a,(de) 
16c4				cp 0 
16c4				jr nz, .genloop 
16c4				inc de 
16c4				ld a, (de) 
16c4				dec de 
16c4				cp 0 
16c4				jr nz, .genloop	 
16c4			 
16c4				ret 
16c4			 
16c4			.genfiletxt:  db "Creating file...",0 
16c4			 
16c4			.soundworddef: 
16c4				dw sound1 
16c4				dw sound2 
16c4				dw sound3 
16c4				dw sound4 
16c4				dw sound5 
16c4				dw sound6 
16c4				dw sound7 
16c4				dw sound8 
16c4				dw sound9 
16c4				dw 0 
16c4			 
16c4			.utilwordef: 
16c4				dw strncpy 
16c4				dw type 
16c4				dw clrstack 
16c4				dw longread 
16c4				dw start1 
16c4				dw start2 
16c4			; duplicated 
16c4			;	dw start3b 
16c4			;	dw start3c 
16c4				dw list 
16c4				dw 0 
16c4			 
16c4			.lsworddef: 
16c4				dw start3b 
16c4				dw 0 
16c4			 
16c4			.edworddef: 
16c4				dw edit1 
16c4				dw edit2 
16c4				dw edit3 
16c4				dw 0 
16c4			 
16c4			.demoworddef: 
16c4				dw test5 
16c4				dw test6 
16c4				dw test7 
16c4				dw test8 
16c4				dw test9 
16c4				dw test10 
16c4				dw game1 
16c4				dw game1a 
16c4				dw game1b 
16c4				dw game1c 
16c4				dw game1d 
16c4				dw game1s 
16c4				dw game1t 
16c4				dw game1f 
16c4				dw game1z 
16c4				dw game1zz 
16c4				dw ssv2 
16c4				dw ssv3 
16c4				dw ssv4 
16c4				dw ssv5 
16c4				dw ssv1 
16c4				dw ssv1cpm	 
16c4				dw game2b 
16c4				dw game2bf 
16c4				dw game2mba 
16c4				dw game2mbas	 
16c4				dw game2mbht 
16c4				dw game2mbms 
16c4				dw game2mb 
16c4				dw game3w 
16c4				dw game3p 
16c4				dw game3sc 
16c4				dw game3vsi 
16c4				dw game3vs 
16c4				dw 0 
16c4			 
16c4			 
16c4			.spiworddef: 
16c4			 
16c4			    dw spi1 
16c4			    dw spi2 
16c4			    dw spi2b 
16c4			    dw spi3 
16c4			    dw spi4 
16c4			    dw spi5 
16c4			;    dw spi6 
16c4			;    dw spi7 
16c4			 
16c4			;    dw spi8 
16c4			;    dw spi9 
16c4			;    dw spi10 
16c4			    dw 0 
16c4			 
16c4			.keyworddef: 
16c4			 
16c4				dw keyup 
16c4				dw keydown 
16c4				dw keyleft 
16c4				dw keyright 
16c4				dw 	keyf1 
16c4				dw keyf2 
16c4				dw keyf3 
16c4				dw keyf4 
16c4				dw keyf5 
16c4				dw keyf6 
16c4				dw keyf7 
16c4				dw keyf8 
16c4				dw keyf9 
16c4				dw keyf10 
16c4				dw keyf11 
16c4				dw keyf12 
16c4				dw keytab 
16c4				dw keycr 
16c4				dw keyhome 
16c4				dw keyend 
16c4				dw keybs 
16c4				dw 0 
16c4			 
16c4			.crstart: 
16c4				dw crs_s1 
16c4				dw crs_s2 
16c4				dw crs_s3 
16c4				dw crs_s4 
16c4				dw crs_s5 
16c4				dw crs_s6 
16c4				dw crs_sound 
16c4				dw 0 
16c4			 
16c4			endif 
16c4			 
16c4			 
16c4			if STORAGE_SE 
16c4			 
16c4			config_fdir: 
16c4				; using the scratch dir go through and release the memory allocated for each string 
16c4				 
16c4				ld hl, scratch 
16c4			.cfdir:	ld e,(hl) 
16c4				inc hl 
16c4				ld d,(hl) 
16c4				inc hl 
16c4			 
16c4				ex de, hl 
16c4				call ishlzero 
16c4				ret z     ; return on null pointer 
16c4				call free 
16c4				ex de, hl 
16c4				jr .cfdir 
16c4			 
16c4			 
16c4				ret 
16c4			 
16c4			 
16c4			config_dir: 
16c4			 
16c4				; for the config menus that need to build a directory of storage call this routine 
16c4				; it will construct a menu in scratch to pass to menu 
16c4			 
16c4				; open storage device 
16c4			 
16c4				; execute DIR to build a list of files and their ids into scratch in menu format 
16c4				; once the menu has finished then will need to call config_fdir to release the strings 
16c4				 
16c4				; c = number items 
16c4			 
16c4				 
16c4				call storage_get_block_0 
16c4			 
16c4				ld hl, store_page     ; get current id count 
16c4				ld b, (hl) 
16c4				ld c, 0    ; count of files   
16c4			 
16c4			 
16c4				ld hl, scratch 
16c4				ld (store_tmp2), hl    ; location to poke strings 
16c4			 
16c4				; check for empty drive 
16c4			 
16c4				ld a, 0 
16c4				cp b 
16c4				jp z, .dirdone 
16c4			 
16c4				 
16c4					if DEBUG_FORTH_WORDS 
16c4						DMARK "Cdc" 
16c4						CALLMONITOR 
16c4					endif 
16c4			 
16c4			 
16c4			.diritem:	 
16c4				push bc 
16c4				; for each of the current ids do a search for them and if found push to stack 
16c4			 
16c4					ld hl, STORE_BLOCK_PHY 
16c4					ld d, 0		 ; look for extent 0 of block id as this contains file name 
16c4					ld e,b 
16c4			 
16c4					call storage_findnextid 
16c4			 
16c4			 
16c4					; if found hl will be non zero 
16c4			 
16c4					call ishlzero 
16c4					jr z, .dirnotfound 
16c4			 
16c4					; increase count 
16c4			 
16c4					pop bc	 
16c4					inc c 
16c4					push bc 
16c4					 
16c4			 
16c4					; get file header and push the file name 
16c4			 
16c4					ld de, store_page 
16c4					call storage_read_block 
16c4			 
16c4					; push file id to stack 
16c4				 
16c4					ld a, (store_page) 
16c4					ld h, 0 
16c4					ld l, a 
16c4			 
16c4					;call forth_push_numhl 
16c4					; TODO store id 
16c4			 
16c4					push hl 
16c4			 
16c4					; push extent count to stack  
16c4				 
16c4					ld hl, store_page+3 
16c4			 
16c4					; get file name length 
16c4			 
16c4					call strlenz   
16c4			 
16c4					inc hl   ; cover zero term 
16c4					inc hl  ; stick the id at the end of the area 
16c4			 
16c4					push hl 
16c4					pop bc    ; move length to bc 
16c4			 
16c4					call malloc 
16c4			 
16c4					; TODO save malloc area to scratch 
16c4			 
16c4					ex de, hl 
16c4					ld hl, (store_tmp2) 
16c4					ld (hl), e 
16c4					inc hl 
16c4					ld (hl), d 
16c4					inc hl 
16c4					ld (store_tmp2), hl 
16c4			 
16c4					 
16c4			 
16c4					;pop hl   ; get source 
16c4			;		ex de, hl    ; swap aronund	 
16c4			 
16c4					ld hl, store_page+3 
16c4					if DEBUG_FORTH_WORDS 
16c4						DMARK "CFd" 
16c4						CALLMONITOR 
16c4					endif 
16c4					ldir 
16c4			 
16c4					; de is past string, move back one and store id 
16c4					 
16c4					dec de 
16c4			 
16c4					; store file id 
16c4			 
16c4					pop hl 
16c4					ex de,hl 
16c4					ld (hl), e 
16c4			 
16c4					if DEBUG_FORTH_WORDS 
16c4						DMARK "Cdi" 
16c4						CALLMONITOR 
16c4					endif 
16c4					 
16c4			.dirnotfound: 
16c4					pop bc     
16c4					djnz .diritem 
16c4				 
16c4			.dirdone:	 
16c4			 
16c4					ld a, 0 
16c4					ld hl, (store_tmp2) 
16c4					ld (hl), a 
16c4					inc hl 
16c4					ld (hl), a 
16c4					inc hl 
16c4					; push a count of the dir items found 
16c4			 
16c4			;		ld h, 0 
16c4			;		ld l, c 
16c4			 
16c4				ret 
16c4			 
16c4			endif 
16c4			 
16c4			 
16c4			; Settings 
16c4			; Run  
16c4			 
16c4			 
16c4			 
16c4			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
16c4			;;hd_menu2:   db "        2: Editor",0   
16c4			;hd_menu2:   db "        2: Editor       6: Menu",0   
16c4			;hd_menu3:   db "        3: Storage",0 
16c4			;hd_menu4:   db "0=quit  4: Debug",0 
16c4			;hd_don:     db "ON",0 
16c4			;hd_doff:     db "OFF",0 
16c4			; 
16c4			; 
16c4			; 
16c4			;hardware_diags_old:       
16c4			; 
16c4			;.diagmenu: 
16c4			;	call clear_display 
16c4			;	ld a, display_row_1 
16c4			;	ld de, hd_menu1 
16c4			;	call str_at_display 
16c4			; 
16c4			;	ld a, display_row_2 
16c4			;	ld de, hd_menu2 
16c4			;	call str_at_display 
16c4			; 
16c4			;	ld a, display_row_3 
16c4			;	ld de, hd_menu3 
16c4			;	call str_at_display 
16c4			; 
16c4			;	ld a,  display_row_4 
16c4			;	ld de, hd_menu4 
16c4			;	call str_at_display 
16c4			; 
16c4			;	; display debug state 
16c4			; 
16c4			;	ld de, hd_don 
16c4			;	ld a, (os_view_disable) 
16c4			;	cp 0 
16c4			;	jr z, .distog 
16c4			;	ld de, hd_doff 
16c4			;.distog: ld a, display_row_4+17 
16c4			;	call str_at_display 
16c4			; 
16c4			;	call update_display 
16c4			; 
16c4			;	call cin_wait 
16c4			; 
16c4			; 
16c4			; 
16c4			;	cp '4' 
16c4			;	jr nz, .diagn1 
16c4			; 
16c4			;	; debug toggle 
16c4			; 
16c4			;	ld a, (os_view_disable) 
16c4			;	ld b, '*' 
16c4			;	cp 0 
16c4			;	jr z, .debtog 
16c4			;	ld b, 0 
16c4			;.debtog:	 
16c4			;	ld a,b 
16c4			;	ld (os_view_disable),a 
16c4			; 
16c4			;.diagn1: cp '0' 
16c4			;	 ret z 
16c4			; 
16c4			;;	cp '1' 
16c4			;;       jp z, matrix	 
16c4			;;   TODO keyboard matrix test 
16c4			; 
16c4			;	cp '2' 
16c4			;	jp z, .diagedit 
16c4			; 
16c4			;;	cp '6' 
16c4			;;	jp z, .menutest 
16c4			;;if ENABLE_BASIC 
16c4			;;	cp '6' 
16c4			;;	jp z, basic 
16c4			;;endif 
16c4			 ; 
16c4			;	jp .diagmenu 
16c4			; 
16c4			; 
16c4			;	ret 
16c4			 
16c4			 
16c4			.debug_tog: 
16c4 21 0e 17			ld hl, .menudebug 
16c7				 
16c7			;	ld a, (os_view_disable) 
16c7			;	cp '*' 
16c7 3a 6f ee			ld a,(debug_vector) 
16ca fe c9			cp $C9   ; RET 
16cc 20 04			jr nz,.tdon  
16ce 3e 01			ld a, 1 
16d0 18 02			jr .tog1 
16d2 3e 00		.tdon: ld a, 0 
16d4			 
16d4			.tog1: 
16d4 cd ea 0b			call menu 
16d7 fe 00			cp 0 
16d9 c8				ret z 
16da fe 01			cp 1    ; disable debug 
16dc 28 04			jr z, .dtog0 
16de 3e 2a			ld a, '*' 
16e0 18 05			jr .dtogset 
16e2			.dtog0:  
16e2				;ld a, 0 
16e2 cd 00 18			call bp_on 
16e5 18 dd			jr .debug_tog 
16e7			.dtogset:  
16e7				; ld (os_view_disable), a 
16e7 cd 0c 18			call bp_off 
16ea c3 c4 16			jp .debug_tog 
16ed			 
16ed			 
16ed			hardware_diags:       
16ed			 
16ed			.diagm: 
16ed 21 00 17			ld hl, .menuitems 
16f0 3e 00			ld a, 0 
16f2 cd ea 0b			call menu 
16f5			 
16f5 fe 00		         cp 0 
16f7 c8				 ret z 
16f8			 
16f8 fe 02			cp 2 
16fa ca 59 17			jp z, .diagedit 
16fd			 
16fd			;	cp '6' 
16fd			;	jp z, .menutest 
16fd			;if ENABLE_BASIC 
16fd			;	cp '6' 
16fd			;	jp z, basic 
16fd			;endif 
16fd			  
16fd c3 ed 16			jp .diagm 
1700			 
1700				 
1700 14 17		.menuitems:   	dw .m1 
1702 1f 17				dw .m2 
1704 26 17				dw .m3 
1706 2e 17				dw .m5 
1708 34 17				dw .m5a 
170a 3d 17				dw .m5b 
170c 00 00				dw 0 
170e			 
170e			.menudebug: 
170e 46 17				dw .m6 
1710 4f 17				dw .m7 
1712 00 00				dw 0 
1714			 
1714 .. 00		.m1:   db "Key Matrix",0 
171f .. 00		.m2:   db "Editor",0 
1726 .. 00		.m3:   db "Storage",0 
172e .. 00		.m5:   db "Sound",0 
1734 .. 00		.m5a:  db "RAM Test",0 
173d .. 00		.m5b:  db "LCD Test",0 
1746			 
1746 .. 00		.m6:   db "Debug ON",0 
174f .. 00		.m7:   db "Debug OFF",0 
1759			 
1759			; debug editor 
1759			 
1759			.diagedit: 
1759			 
1759 21 c1 e2			ld hl, scratch 
175c			;	ld bc, 250 
175c			;	ldir 
175c				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
175c 3e 00			ld a, 0 
175e 77				ld (hl), a 
175f 23				inc hl 
1760 77				ld (hl), a 
1761 23				inc hl 
1762 77				ld (hl), a 
1763			 
1763 cd b9 0b		        call clear_display 
1766 cd dc 0b			call update_display 
1769				;ld a, 1 
1769				;ld (hardware_diag), a 
1769			.diloop: 
1769 3e 00			ld a, display_row_1 
176b 0e 00			ld c, 0 
176d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
176f 1e 28			ld e, 40 
1771			 
1771 21 c1 e2			ld hl, scratch	 
1774 cd 13 0e			call input_str 
1777			 
1777 3e 28			ld a, display_row_2 
1779 11 c1 e2			ld de, scratch 
177c cd cc 0b			call str_at_display 
177f cd dc 0b			call update_display 
1782			 
1782 c3 69 17			jp .diloop 
1785			 
1785			 
1785			; pass word in hl 
1785			; a has display location 
1785			display_word_at: 
1785 f5				push af 
1786 e5				push hl 
1787 7c				ld a,h 
1788 21 c6 e5			ld hl, os_word_scratch 
178b cd ff 12			call hexout 
178e e1				pop hl 
178f 7d				ld a,l 
1790 21 c8 e5			ld hl, os_word_scratch+2 
1793 cd ff 12			call hexout 
1796 21 ca e5			ld hl, os_word_scratch+4 
1799 3e 00			ld a,0 
179b 77				ld (hl),a 
179c 11 c6 e5			ld de,os_word_scratch 
179f f1				pop af 
17a0 cd cc 0b				call str_at_display 
17a3 c9				ret 
17a4			 
17a4			display_ptr_state: 
17a4			 
17a4				; to restore afterwards 
17a4			 
17a4 d5				push de 
17a5 c5				push bc 
17a6 e5				push hl 
17a7 f5				push af 
17a8			 
17a8				; for use in here 
17a8			 
17a8			;	push bc 
17a8			;	push de 
17a8			;	push hl 
17a8			;	push af 
17a8			 
17a8 cd b9 0b			call clear_display 
17ab			 
17ab 11 83 19			ld de, .ptrstate 
17ae 3e 00			ld a, display_row_1 
17b0 cd cc 0b			call str_at_display 
17b3			 
17b3				; display debug step 
17b3			 
17b3			 
17b3 11 6b ee			ld de, debug_mark 
17b6 3e 26			ld a, display_row_1+display_cols-2 
17b8 cd cc 0b			call str_at_display 
17bb			 
17bb				; display a 
17bb 11 8d 19			ld de, .ptrcliptr 
17be 3e 28			ld a, display_row_2 
17c0 cd cc 0b			call str_at_display 
17c3			 
17c3 f1				pop af 
17c4 2a 40 ea			ld hl,(cli_ptr) 
17c7 3e 30			ld a, display_row_2+8 
17c9 cd 85 17			call display_word_at 
17cc			 
17cc			 
17cc				; display hl 
17cc			 
17cc			 
17cc 11 95 19			ld de, .ptrclioptr 
17cf 3e 32			ld a, display_row_2+10 
17d1 cd cc 0b			call str_at_display 
17d4			; 
17d4			;	pop hl 
17d4 3e 35			ld a, display_row_2+13 
17d6 2a 3e ea			ld hl,(cli_origptr) 
17d9 cd 85 17			call display_word_at 
17dc			; 
17dc			;	 
17dc			;	; display de 
17dc			 
17dc			;	ld de, .regstatede 
17dc			;	ld a, display_row_3 
17dc			;	call str_at_display 
17dc			 
17dc			;	pop de 
17dc			;	ld h,d 
17dc			;	ld l, e 
17dc			;	ld a, display_row_3+3 
17dc			;	call display_word_at 
17dc			 
17dc			 
17dc				; display bc 
17dc			 
17dc			;	ld de, .regstatebc 
17dc			;	ld a, display_row_3+10 
17dc			;	call str_at_display 
17dc			 
17dc			;	pop bc 
17dc			;	ld h,b 
17dc			;	ld l, c 
17dc			;	ld a, display_row_3+13 
17dc			;	call display_word_at 
17dc			 
17dc			 
17dc				; display dsp 
17dc			 
17dc			;	ld de, .regstatedsp 
17dc			;	ld a, display_row_4 
17dc			;	call str_at_display 
17dc			 
17dc				 
17dc			;	ld hl,(cli_data_sp) 
17dc			;	ld a, display_row_4+4 
17dc			;	call display_word_at 
17dc			 
17dc				; display rsp 
17dc			 
17dc 11 c4 19			ld de, .regstatersp 
17df 3e 82			ld a, display_row_4+10 
17e1 cd cc 0b			call str_at_display 
17e4			 
17e4				 
17e4 2a f2 e9			ld hl,(cli_ret_sp) 
17e7 3e 86			ld a, display_row_4+14 
17e9 cd 85 17			call display_word_at 
17ec			 
17ec cd dc 0b			call update_display 
17ef			 
17ef cd f1 0a			call delay1s 
17f2 cd f1 0a			call delay1s 
17f5 cd f1 0a			call delay1s 
17f8			 
17f8			 
17f8 cd e2 1d			call next_page_prompt 
17fb			 
17fb				; restore  
17fb			 
17fb f1				pop af 
17fc e1				pop hl 
17fd c1				pop bc 
17fe d1				pop de 
17ff c9				ret 
1800			 
1800			; Update the break point vector so that the user can hook a new routine 
1800			 
1800			bp_on: 
1800 3e c3			ld a, $c3    ; JP 
1802 32 6f ee			ld (debug_vector), a 
1805 21 12 18			ld hl, break_point_state 
1808 22 70 ee			ld (debug_vector+1), hl 
180b c9				ret 
180c			 
180c			bp_off: 
180c 3e c9			ld a, $c9    ; RET 
180e 32 6f ee			ld (debug_vector), a 
1811 c9				ret 
1812			 
1812			 
1812			break_point_state: 
1812			;	push af 
1812			; 
1812			;	; see if disabled 
1812			; 
1812			;	ld a, (os_view_disable) 
1812			;	cp '*' 
1812			;	jr nz, .bpsgo 
1812			;	pop af 
1812			;	ret 
1812			 
1812			.bpsgo: 
1812			;	pop af 
1812 f5				push af 
1813 22 a3 e2			ld (os_view_hl), hl 
1816 ed 53 a1 e2		ld (os_view_de), de 
181a ed 43 9f e2		ld (os_view_bc), bc 
181e e5				push hl 
181f 6f				ld l, a 
1820 26 00			ld h, 0 
1822 22 a5 e2			ld (os_view_af),hl 
1825			 
1825 21 b1 ed				ld hl, display_fb0 
1828 22 cc eb				ld (display_fb_active), hl 
182b e1				pop hl	 
182c			 
182c 3e 31			ld a, '1' 
182e fe 2a		.bps1:  cp '*' 
1830 cc 0c 18			call z, bp_off 
1833			;	jr nz, .bps1b 
1833			;	ld (os_view_disable),a 
1833 fe 31		.bps1b:  cp '1' 
1835 20 14			jr nz, .bps2 
1837			 
1837				; display reg 
1837			 
1837				 
1837			 
1837 3a a5 e2			ld a, (os_view_af) 
183a 2a a3 e2			ld hl, (os_view_hl) 
183d ed 5b a1 e2		ld de, (os_view_de) 
1841 ed 4b 9f e2		ld bc, (os_view_bc) 
1845 cd df 18			call display_reg_state 
1848 c3 cb 18			jp .bpschk 
184b			 
184b fe 32		.bps2:  cp '2' 
184d 20 08			jr nz, .bps3 
184f				 
184f				; display hl 
184f 2a a3 e2			ld hl, (os_view_hl) 
1852 cd c9 19			call display_dump_at_hl 
1855			 
1855 18 74			jr .bpschk 
1857			 
1857 fe 33		.bps3:  cp '3' 
1859 20 08			jr nz, .bps4 
185b			 
185b			        ; display de 
185b 2a a1 e2			ld hl, (os_view_de) 
185e cd c9 19			call display_dump_at_hl 
1861			 
1861 18 68			jr .bpschk 
1863 fe 34		.bps4:  cp '4' 
1865 20 08			jr nz, .bps5 
1867			 
1867			        ; display bc 
1867 2a 9f e2			ld hl, (os_view_bc) 
186a cd c9 19			call display_dump_at_hl 
186d			 
186d 18 5c			jr .bpschk 
186f fe 35		.bps5:  cp '5' 
1871 20 08		        jr nz, .bps7 
1873			 
1873				; display cur ptr 
1873 2a 40 ea			ld hl, (cli_ptr) 
1876 cd c9 19			call display_dump_at_hl 
1879			 
1879 18 50			jr .bpschk 
187b fe 36		.bps7:  cp '6' 
187d 20 08			jr nz, .bps8b 
187f				 
187f				; display cur orig ptr 
187f 2a 3e ea			ld hl, (cli_origptr) 
1882 cd c9 19			call display_dump_at_hl 
1885 18 44			jr .bpschk 
1887 fe 37		.bps8b:  cp '7' 
1889 20 08			jr nz, .bps9 
188b				 
188b				; display dsp 
188b 2a ee e9			ld hl, (cli_data_sp) 
188e cd c9 19			call display_dump_at_hl 
1891			 
1891 18 38			jr .bpschk 
1893 fe 39		.bps9:  cp '9' 
1895 20 05			jr nz, .bps8c 
1897				 
1897				; display SP 
1897			;	ld hl, sp 
1897 cd c9 19			call display_dump_at_hl 
189a			 
189a 18 2f			jr .bpschk 
189c fe 38		.bps8c:  cp '8' 
189e 20 08			jr nz, .bps8d 
18a0				 
18a0				; display rsp 
18a0 2a f2 e9			ld hl, (cli_ret_sp) 
18a3 cd c9 19			call display_dump_at_hl 
18a6			 
18a6 18 23			jr .bpschk 
18a8 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
18aa 20 05			jr nz, .bps8 
18ac cd b0 1b			call monitor 
18af			 
18af 18 1a			jr .bpschk 
18b1 fe 30		.bps8:  cp '0' 
18b3 20 16			jr nz, .bpschk 
18b5			 
18b5 21 10 ed				ld hl, display_fb1 
18b8 22 cc eb				ld (display_fb_active), hl 
18bb cd dc 0b				call update_display 
18be			 
18be				;ld a, (os_view_af) 
18be 2a a3 e2			ld hl, (os_view_hl) 
18c1 ed 5b a1 e2		ld de, (os_view_de) 
18c5 ed 4b 9f e2		ld bc, (os_view_bc) 
18c9 f1				pop af 
18ca c9				ret 
18cb			 
18cb			.bpschk:   
18cb cd f1 0a			call delay1s 
18ce 3e 9f		ld a,display_row_4 + display_cols - 1 
18d0 11 e0 1d		        ld de, endprg 
18d3 cd cc 0b			call str_at_display 
18d6 cd dc 0b			call update_display 
18d9 cd 3e 68			call cin_wait 
18dc			 
18dc c3 2e 18			jp .bps1 
18df			 
18df			 
18df			display_reg_state: 
18df			 
18df				; to restore afterwards 
18df			 
18df d5				push de 
18e0 c5				push bc 
18e1 e5				push hl 
18e2 f5				push af 
18e3			 
18e3				; for use in here 
18e3			 
18e3 c5				push bc 
18e4 d5				push de 
18e5 e5				push hl 
18e6 f5				push af 
18e7			 
18e7 cd b9 0b			call clear_display 
18ea			 
18ea 11 9f 19			ld de, .regstate 
18ed 3e 00			ld a, display_row_1 
18ef cd cc 0b			call str_at_display 
18f2			 
18f2				; display debug step 
18f2			 
18f2			 
18f2 11 6b ee			ld de, debug_mark 
18f5 3e 25			ld a, display_row_1+display_cols-3 
18f7 cd cc 0b			call str_at_display 
18fa			 
18fa				; display a 
18fa 11 bb 19			ld de, .regstatea 
18fd 3e 28			ld a, display_row_2 
18ff cd cc 0b			call str_at_display 
1902			 
1902 e1				pop hl 
1903			;	ld h,0 
1903			;	ld l, a 
1903 3e 2b			ld a, display_row_2+3 
1905 cd 85 17			call display_word_at 
1908			 
1908			 
1908				; display hl 
1908			 
1908			 
1908 11 af 19			ld de, .regstatehl 
190b 3e 32			ld a, display_row_2+10 
190d cd cc 0b			call str_at_display 
1910			 
1910 e1				pop hl 
1911 3e 35			ld a, display_row_2+13 
1913 cd 85 17			call display_word_at 
1916			 
1916				 
1916				; display de 
1916			 
1916 11 b3 19			ld de, .regstatede 
1919 3e 50			ld a, display_row_3 
191b cd cc 0b			call str_at_display 
191e			 
191e e1				pop hl 
191f			;	ld h,d 
191f			;	ld l, e 
191f 3e 53			ld a, display_row_3+3 
1921 cd 85 17			call display_word_at 
1924			 
1924			 
1924				; display bc 
1924			 
1924 11 b7 19			ld de, .regstatebc 
1927 3e 5a			ld a, display_row_3+10 
1929 cd cc 0b			call str_at_display 
192c			 
192c e1				pop hl 
192d			;	ld h,b 
192d			;	ld l, c 
192d 3e 5d			ld a, display_row_3+13 
192f cd 85 17			call display_word_at 
1932			 
1932			 
1932				; display dsp 
1932			 
1932 11 bf 19			ld de, .regstatedsp 
1935 3e 78			ld a, display_row_4 
1937 cd cc 0b			call str_at_display 
193a			 
193a				 
193a 2a ee e9			ld hl,(cli_data_sp) 
193d 3e 7c			ld a, display_row_4+4 
193f cd 85 17			call display_word_at 
1942			 
1942				; display rsp 
1942			 
1942 11 c4 19			ld de, .regstatersp 
1945 3e 82			ld a, display_row_4+10 
1947 cd cc 0b			call str_at_display 
194a			 
194a				 
194a 2a f2 e9			ld hl,(cli_ret_sp) 
194d 3e 86			ld a, display_row_4+14 
194f cd 85 17			call display_word_at 
1952			 
1952 cd dc 0b			call update_display 
1955			 
1955			;	call delay1s 
1955			;	call delay1s 
1955			;	call delay1s 
1955			 
1955			 
1955			;	call next_page_prompt 
1955			 
1955				; restore  
1955			 
1955 f1				pop af 
1956 e1				pop hl 
1957 c1				pop bc 
1958 d1				pop de 
1959 c9				ret 
195a			 
195a .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
196e .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1983 .. 00		.ptrstate:	db "Ptr State",0 
198d .. 00		.ptrcliptr:     db "cli_ptr",0 
1995 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
199f .. 00		.regstate:	db "Reg State (1/0)",0 
19af .. 00		.regstatehl:	db "HL:",0 
19b3 .. 00		.regstatede:	db "DE:",0 
19b7 .. 00		.regstatebc:	db "BC:",0 
19bb .. 00		.regstatea:	db "A :",0 
19bf .. 00		.regstatedsp:	db "DSP:",0 
19c4 .. 00		.regstatersp:	db "RSP:",0 
19c9			 
19c9			display_dump_at_hl: 
19c9 e5				push hl 
19ca d5				push de 
19cb c5				push bc 
19cc f5				push af 
19cd			 
19cd 22 e4 e5			ld (os_cur_ptr),hl	 
19d0 cd b9 0b			call clear_display 
19d3 cd ea 1c			call dumpcont 
19d6			;	call delay1s 
19d6			;	call next_page_prompt 
19d6			 
19d6			 
19d6 f1				pop af 
19d7 c1				pop bc 
19d8 d1				pop de 
19d9 e1				pop hl 
19da c9				ret 
19db			 
19db			;if ENABLE_BASIC 
19db			;	include "nascombasic.asm" 
19db			;	basic: 
19db			;	include "forth/FORTH.ASM" 
19db			;endif 
19db			 
19db			; eof 
19db			 
19db			 
# End of file firmware_diags.asm
19db			  
19db			include "firmware_prompts.asm"  
19db			; Prompts  
19db			 
19db			; boot messages 
19db			 
19db .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
19f0 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1a00			 
1a00			 
1a00			; config menus 
1a00			 
1a00			;prom_c3: db "Add Dictionary To File",0 
1a00			 
1a00			if STARTUP_V1 
1a00 .. 00		prom_c2: db "Select Autoload File",0 
1a15 .. 00		prom_c2a: db "Disable Autoload File", 0 
1a2b			endif 
1a2b			 
1a2b			if STARTUP_V2 
1a2b			prom_c2: db "Enable Autoload Files",0 
1a2b			prom_c2a: db "Disable Autoload Files", 0 
1a2b			 
1a2b			crs_s1: db "*ls-word", 0 
1a2b			crs_s2: db "*ed-word", 0 
1a2b			crs_s3: db "*Demo-Programs", 0 
1a2b			crs_s4: db "*Utils", 0 
1a2b			crs_s5: db "*SPI-Util", 0 
1a2b			crs_s6: db "*Key-constants", 0 
1a2b			crs_sound: db "*Sound-Util", 0 
1a2b			 
1a2b			 
1a2b			 
1a2b			endif 
1a2b			;prom_c2b: db "Select Storage Bank",0 
1a2b .. 00		prom_c4: db "Settings",0 
1a34 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1a4f .. 00		prom_m4b:   db "Monitor",0 
1a57 .. 00		prom_c1: db "Hardware Diags",0 
1a66			 
1a66			 
1a66			if STARTUP_V2 
1a66			prom_c9: db "Create Startup Files",0 
1a66			endif 
1a66			 
1a66 .. 00		prom_notav:    db "Feature not available",0 
1a7c .. 00		prom_empty:    db "",0 
1a7d			 
1a7d			; eof 
1a7d			 
# End of file firmware_prompts.asm
1a7d			  
1a7d			  
1a7d			; eof  
1a7d			  
# End of file firmware.asm
1a7d			 
1a7d			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1a7d			;if BASE_KEV  
1a7d			;baseram: equ 08000h 
1a7d			;endif 
1a7d			 
1a7d			;if BASE_SC114 
1a7d			;baseram:     equ    endofcode 
1a7d			;endif 
1a7d			 
1a7d			 
1a7d			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1a7d			 
1a7d			; start system 
1a7d			 
1a7d			coldstart: 
1a7d				; set sp 
1a7d				; di/ei 
1a7d			 
1a7d f3				di 
1a7e 31 00 f0			ld sp, tos 
1a81 cd 3c 67			call init_nmi 
1a84			;	ei 
1a84			 
1a84				; init spinner 
1a84 3e 00			ld a,0 
1a86 32 c6 eb			ld (display_active), a 
1a89			 
1a89				; disable breakpoint by default 
1a89			 
1a89				;ld a,'*' 
1a89			;	ld a,' ' 
1a89			;	ld (os_view_disable),a 
1a89			 
1a89				; set break point vector as new break point on or off 
1a89 cd 0c 18			call bp_off 
1a8c			 
1a8c				; init hardware 
1a8c			 
1a8c				; init keyboard and screen hardware 
1a8c			 
1a8c cd 1b 01			call hardware_init 
1a8f			 
1a8f			 
1a8f cd f1 0a			call delay1s 
1a92 3e 58			ld a, display_row_3+8 
1a94 11 03 01			ld de, buildtime 
1a97 cd cc 0b			call str_at_display 
1a9a cd dc 0b			call update_display 
1a9d			 
1a9d cd f1 0a			call delay1s 
1aa0 cd f1 0a			call delay1s 
1aa3 cd f1 0a			call delay1s 
1aa6			 
1aa6				; detect if any keys are held down to enable breakpoints at start up 
1aa6			 
1aa6 cd 46 68			call cin  
1aa9 fe 00			cp 0 
1aab 28 03			jr z, .nokeys 
1aad			 
1aad				;call hardware_diags 
1aad cd 6a 16			call config 
1ab0			 
1ab0			;	ld de, .bpen 
1ab0			;	ld a, display_row_4 
1ab0			;	call str_at_display 
1ab0			;	call update_display 
1ab0			; 
1ab0			;	ld a,0 
1ab0			;	ld (os_view_disable),a 
1ab0			; 
1ab0			;.bpwait: 
1ab0			;	call cin 
1ab0			;	cp 0 
1ab0			;	jr z, .bpwait 
1ab0			;	jr .nokeys 
1ab0			; 
1ab0			; 
1ab0			;.bpen:  db "Break points enabled!",0 
1ab0			 
1ab0			 
1ab0			 
1ab0			 
1ab0			 
1ab0			 
1ab0			.nokeys: 
1ab0			 
1ab0			 
1ab0				 
1ab0			 
1ab0			;jp  testkey 
1ab0			 
1ab0			;call storage_get_block_0 
1ab0			; 
1ab0			;ld hl, 0 
1ab0			;ld de, store_page 
1ab0			;call storage_read_block 
1ab0			 
1ab0				 
1ab0			;ld hl, 10 
1ab0			;ld de, store_page 
1ab0			;call storage_read_block 
1ab0			 
1ab0			 
1ab0			 
1ab0			 
1ab0			 
1ab0			;stop:	nop 
1ab0			;	jp stop 
1ab0			 
1ab0			 
1ab0			 
1ab0			main: 
1ab0 cd b9 0b			call clear_display 
1ab3 cd dc 0b			call update_display 
1ab6			 
1ab6			 
1ab6			 
1ab6			;	call testlcd 
1ab6			 
1ab6			 
1ab6			 
1ab6 cd e7 21			call forth_init 
1ab9			 
1ab9			 
1ab9			warmstart: 
1ab9 cd bd 21			call forth_warmstart 
1abc			 
1abc				; run startup word load 
1abc			        ; TODO prevent this running at warmstart after crash  
1abc			 
1abc				if STARTUP_ENABLE 
1abc			 
1abc					if STARTUP_V1 
1abc			 
1abc						if STORAGE_SE 
1abc							call forth_autoload 
1abc						endif 
1abc cd 8c 66					call forth_startup 
1abf					endif 
1abf			 
1abf					if STARTUP_V2 
1abf			 
1abf						if STORAGE_SE 
1abf							call forth_autoload 
1abf						else 
1abf							call forth_startup 
1abf						endif 
1abf			 
1abf			 
1abf					endif 
1abf			 
1abf				endif 
1abf			 
1abf				; show free memory after boot 
1abf 11 4b 1b			ld de, freeram 
1ac2 3e 00			ld a, display_row_1 
1ac4 cd cc 0b			call str_at_display 
1ac7			 
1ac7				; get current heap start after loading any uwords 
1ac7			 
1ac7				;ld de, (os_last_new_uword) 
1ac7				;ex de, hl 
1ac7			 
1ac7			; Or use heap_size word???? 
1ac7				;ld hl, heap_end 
1ac7				;ld hl, heap_size 
1ac7				;ld de, topusermem 
1ac7				;ld de, heap_start 
1ac7 ed 5b 69 68			ld de, (free_list )      
1acb 21 9c e2				ld hl, heap_end 
1ace ed 52			sbc hl, de 
1ad0				;push hl 
1ad0				;ld a,h	         	 
1ad0				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ad0				;call hexout 
1ad0			   	;pop hl 
1ad0			; 
1ad0			;	ld a,l 
1ad0			;	ld hl, os_word_scratch+2 
1ad0			;	call hexout 
1ad0			;	ld hl, os_word_scratch+4 
1ad0			;	ld a, 0 
1ad0			;	ld (hl),a 
1ad0 eb				ex de, hl 
1ad1 21 c6 e5			ld hl, os_word_scratch 
1ad4 cd 0b 14			call uitoa_16 
1ad7			 
1ad7			 
1ad7 11 c6 e5			ld de, os_word_scratch 
1ada 3e 0d			ld a, display_row_1 + 13 
1adc cd cc 0b			call str_at_display 
1adf cd dc 0b			call update_display 
1ae2			 
1ae2			 
1ae2				;call demo 
1ae2			 
1ae2			 
1ae2				; init scratch input area for cli commands 
1ae2			 
1ae2 21 e8 e5			ld hl, os_cli_cmd 
1ae5 3e 00			ld a,0 
1ae7 77				ld (hl),a 
1ae8 23				inc hl 
1ae9 77				ld (hl),a 
1aea			 
1aea 3e 00			ld a,0 
1aec 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1aef			 
1aef 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1af2 32 e5 e5			ld (os_cur_ptr+1),a	 
1af5			 
1af5 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1af8 32 c7 e5			ld (os_word_scratch+1),a	 
1afb				 
1afb			 
1afb				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1afb 21 e8 e5			ld hl, os_cli_cmd 
1afe			 
1afe 3e 00			ld a, 0		 ; init cli input 
1b00 77				ld (hl), a 
1b01 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1b03			cli: 
1b03				; show cli prompt 
1b03				;push af 
1b03				;ld a, 0 
1b03				;ld de, prompt 
1b03				;call str_at_display 
1b03			 
1b03				;call update_display 
1b03				;pop af 
1b03				;inc a 
1b03				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b03 0e 00			ld c, 0 
1b05 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1b07 1e 28			ld e, 40 
1b09			 
1b09 21 e8 e5			ld hl, os_cli_cmd 
1b0c			 
1b0c				STACKFRAME OFF $fefe $9f9f 
1b0c				if DEBUG_STACK_IMB 
1b0c					if OFF 
1b0c						exx 
1b0c						ld de, $fefe 
1b0c						ld a, d 
1b0c						ld hl, curframe 
1b0c						call hexout 
1b0c						ld a, e 
1b0c						ld hl, curframe+2 
1b0c						call hexout 
1b0c						ld hl, $fefe 
1b0c						push hl 
1b0c						ld hl, $9f9f 
1b0c						push hl 
1b0c						exx 
1b0c					endif 
1b0c				endif 
1b0c			endm 
# End of macro STACKFRAME
1b0c			 
1b0c cd 13 0e			call input_str 
1b0f			 
1b0f				STACKFRAMECHK OFF $fefe $9f9f 
1b0f				if DEBUG_STACK_IMB 
1b0f					if OFF 
1b0f						exx 
1b0f						ld hl, $9f9f 
1b0f						pop de   ; $9f9f 
1b0f						call cmp16 
1b0f						jr nz, .spnosame 
1b0f						ld hl, $fefe 
1b0f						pop de   ; $fefe 
1b0f						call cmp16 
1b0f						jr z, .spfrsame 
1b0f						.spnosame: call showsperror 
1b0f						.spfrsame: nop 
1b0f						exx 
1b0f					endif 
1b0f				endif 
1b0f			endm 
# End of macro STACKFRAMECHK
1b0f			 
1b0f				; copy input to last command 
1b0f			 
1b0f 21 e8 e5			ld hl, os_cli_cmd 
1b12 11 e7 e6			ld de, os_last_cmd 
1b15 01 ff 00			ld bc, 255 
1b18 ed b0			ldir 
1b1a			 
1b1a				; wipe current buffer 
1b1a			 
1b1a			;	ld a, 0 
1b1a			;	ld hl, os_cli_cmd 
1b1a			;	ld de, os_cli_cmd+1 
1b1a			;	ld bc, 254 
1b1a			;	ldir 
1b1a				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1b1a			;	call strcpy 
1b1a			;	ld a, 0 
1b1a			;	ld (hl), a 
1b1a			;	inc hl 
1b1a			;	ld (hl), a 
1b1a			;	inc hl 
1b1a			;	ld (hl), a 
1b1a			 
1b1a				; switch frame buffer to program  
1b1a			 
1b1a 21 10 ed				ld hl, display_fb1 
1b1d 22 cc eb				ld (display_fb_active), hl 
1b20			 
1b20			;	nop 
1b20				STACKFRAME ON $fbfe $8f9f 
1b20				if DEBUG_STACK_IMB 
1b20					if ON 
1b20						exx 
1b20						ld de, $fbfe 
1b20						ld a, d 
1b20						ld hl, curframe 
1b20						call hexout 
1b20						ld a, e 
1b20						ld hl, curframe+2 
1b20						call hexout 
1b20						ld hl, $fbfe 
1b20						push hl 
1b20						ld hl, $8f9f 
1b20						push hl 
1b20						exx 
1b20					endif 
1b20				endif 
1b20			endm 
# End of macro STACKFRAME
1b20				; first time into the parser so pass over the current scratch pad 
1b20 21 e8 e5			ld hl,os_cli_cmd 
1b23				; tokenise the entered statement(s) in HL 
1b23 cd 65 22			call forthparse 
1b26			        ; exec forth statements in top of return stack 
1b26 cd a5 22			call forthexec 
1b29				;call forthexec_cleanup 
1b29			;	call parsenext 
1b29			 
1b29				STACKFRAMECHK ON $fbfe $8f9f 
1b29				if DEBUG_STACK_IMB 
1b29					if ON 
1b29						exx 
1b29						ld hl, $8f9f 
1b29						pop de   ; $8f9f 
1b29						call cmp16 
1b29						jr nz, .spnosame 
1b29						ld hl, $fbfe 
1b29						pop de   ; $fbfe 
1b29						call cmp16 
1b29						jr z, .spfrsame 
1b29						.spnosame: call showsperror 
1b29						.spfrsame: nop 
1b29						exx 
1b29					endif 
1b29				endif 
1b29			endm 
# End of macro STACKFRAMECHK
1b29				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1b29			 
1b29 3e 78			ld a, display_row_4 
1b2b 11 5c 1b			ld de, endprog 
1b2e			 
1b2e cd dc 0b			call update_display		 
1b31			 
1b31 cd e2 1d			call next_page_prompt 
1b34			 
1b34				; switch frame buffer to cli 
1b34			 
1b34 21 b1 ed				ld hl, display_fb0 
1b37 22 cc eb				ld (display_fb_active), hl 
1b3a			 
1b3a			 
1b3a cd b9 0b		        call clear_display 
1b3d cd dc 0b			call update_display		 
1b40			 
1b40 21 e8 e5			ld hl, os_cli_cmd 
1b43			 
1b43 3e 00			ld a, 0		 ; init cli input 
1b45 77				ld (hl), a 
1b46			 
1b46				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1b46			 
1b46				; now on last line 
1b46			 
1b46				; TODO scroll screen up 
1b46			 
1b46				; TODO instead just clear screen and place at top of screen 
1b46			 
1b46			;	ld a, 0 
1b46			;	ld (f_cursor_ptr),a 
1b46			 
1b46				;call clear_display 
1b46				;call update_display 
1b46			 
1b46				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1b46 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1b48 c3 03 1b			jp cli 
1b4b			 
1b4b .. 00		freeram: db "Free bytes: ",0 
1b58 ..			asc: db "1A2F" 
1b5c .. 00		endprog: db "End prog...",0 
1b68			 
1b68			testenter2:   
1b68 21 f3 e2			ld hl,scratch+50 
1b6b 22 e4 e5			ld (os_cur_ptr),hl 
1b6e c3 03 1b			jp cli 
1b71			 
1b71			testenter:  
1b71			 
1b71 21 58 1b			ld hl,asc 
1b74			;	ld a,(hl) 
1b74			;	call nibble2val 
1b74 cd 55 13			call get_byte 
1b77			 
1b77			 
1b77			;	ld a,(hl) 
1b77			;	call atohex 
1b77			 
1b77			;	call fourehexhl 
1b77 32 f3 e2			ld (scratch+50),a 
1b7a			 
1b7a			 
1b7a			 
1b7a 21 5a 1b			ld hl,asc+2 
1b7d			;	ld a, (hl) 
1b7d			;	call nibble2val 
1b7d cd 55 13			call get_byte 
1b80			 
1b80			;	call fourehexhl 
1b80 32 f5 e2			ld (scratch+52),a 
1b83				 
1b83 21 f3 e2			ld hl,scratch+50 
1b86 22 e4 e5			ld (os_cur_ptr),hl 
1b89 c3 03 1b			jp cli 
1b8c			 
1b8c			enter:	 
1b8c 3a c5 e2			ld a,(scratch+4) 
1b8f fe 00			cp 0 
1b91 28 0c			jr z, .entercont 
1b93				; no, not a null term line so has an address to work out.... 
1b93			 
1b93 21 c3 e2			ld hl,scratch+2 
1b96 cd b5 13			call get_word_hl 
1b99			 
1b99 22 e4 e5			ld (os_cur_ptr),hl	 
1b9c c3 03 1b			jp cli 
1b9f			 
1b9f			 
1b9f			.entercont:  
1b9f			 
1b9f 21 c3 e2			ld hl, scratch+2 
1ba2 cd 55 13			call get_byte 
1ba5			 
1ba5 2a e4 e5		   	ld hl,(os_cur_ptr) 
1ba8 77					ld (hl),a 
1ba9 23					inc hl 
1baa 22 e4 e5				ld (os_cur_ptr),hl 
1bad				 
1bad			; get byte  
1bad			 
1bad			 
1bad c3 03 1b			jp cli 
1bb0			 
1bb0			 
1bb0			; basic monitor support 
1bb0			 
1bb0			monitor: 
1bb0				;  
1bb0 cd b9 0b			call clear_display 
1bb3 3e 00			ld a, 0 
1bb5 11 04 1c			ld de, .monprompt 
1bb8 cd cc 0b			call str_at_display 
1bbb cd dc 0b			call update_display 
1bbe			 
1bbe				; get a monitor command 
1bbe			 
1bbe 0e 00			ld c, 0     ; entry at top left 
1bc0 16 64			ld d, 100   ; max buffer size 
1bc2 1e 0f			ld e, 15    ; input scroll area 
1bc4 3e 00			ld a, 0     ; init string 
1bc6 21 bf e4			ld hl, os_input 
1bc9 77				ld (hl), a 
1bca 23				inc hl 
1bcb 77				ld (hl), a 
1bcc 21 bf e4			ld hl, os_input 
1bcf 3e 01			ld a, 1     ; init string 
1bd1 cd 13 0e			call input_str 
1bd4			 
1bd4 cd b9 0b		        call clear_display 
1bd7 cd dc 0b			call update_display		 
1bda			 
1bda 3a bf e4			ld a, (os_input) 
1bdd cd 53 14			call toUpper 
1be0 fe 48		        cp 'H' 
1be2 ca 69 1c		        jp z, .monhelp 
1be5 fe 44			cp 'D'		; dump 
1be7 ca 9c 1c			jp z, .mondump	 
1bea fe 43			cp 'C'		; dump 
1bec ca b6 1c			jp z, .moncdump	 
1bef fe 4d			cp 'M'		; dump 
1bf1 ca 06 1c			jp z, .moneditstart 
1bf4 fe 55			cp 'U'		; dump 
1bf6 ca 12 1c			jp z, .monedit	 
1bf9 fe 47			cp 'G'		; dump 
1bfb ca 92 1c			jp z, .monjump 
1bfe fe 51			cp 'Q'		; dump 
1c00 c8				ret z	 
1c01			 
1c01			 
1c01				; TODO "S" to access symbol by name and not need the address 
1c01				; TODO "F" to find a string in memory 
1c01			 
1c01 c3 b0 1b			jp monitor 
1c04			 
1c04 .. 00		.monprompt: db ">", 0 
1c06			 
1c06			.moneditstart: 
1c06				; get starting address 
1c06			 
1c06 21 c1 e4			ld hl,os_input+2 
1c09 cd b5 13			call get_word_hl 
1c0c			 
1c0c 22 e4 e5			ld (os_cur_ptr),hl	 
1c0f			 
1c0f c3 b0 1b			jp monitor 
1c12			 
1c12			.monedit: 
1c12				; get byte to load 
1c12			 
1c12 21 c1 e4			ld hl,os_input+2 
1c15 cd 55 13			call get_byte 
1c18			 
1c18				; get address to update 
1c18 2a e4 e5			ld hl, (os_cur_ptr) 
1c1b			 
1c1b				; update byte 
1c1b			 
1c1b 77				ld (hl), a 
1c1c			 
1c1c				; move to next address and save it 
1c1c			 
1c1c 23				inc hl 
1c1d 22 e4 e5			ld (os_cur_ptr),hl	 
1c20			 
1c20 c3 b0 1b			jp monitor 
1c23			 
1c23			 
1c23 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1c37 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1c53 .. 00		.monhelptext3:  db "G-Call address",0 
1c62 .. 00		.monhelptext4:  db "Q-Quit",0 
1c69			        
1c69			.monhelp: 
1c69 3e 00			ld a, display_row_1 
1c6b 11 23 1c		        ld de, .monhelptext1 
1c6e			 
1c6e cd cc 0b			call str_at_display 
1c71 3e 28			ld a, display_row_2 
1c73 11 37 1c		        ld de, .monhelptext2 
1c76					 
1c76 cd cc 0b			call str_at_display 
1c79 3e 50			ld a, display_row_3 
1c7b 11 53 1c		        ld de, .monhelptext3 
1c7e					 
1c7e cd cc 0b			call str_at_display 
1c81 3e 78			ld a, display_row_4 
1c83 11 62 1c		        ld de, .monhelptext4 
1c86 cd cc 0b			call str_at_display 
1c89			 
1c89 cd dc 0b			call update_display		 
1c8c			 
1c8c cd e2 1d			call next_page_prompt 
1c8f c3 b0 1b			jp monitor 
1c92			 
1c92			.monjump:    
1c92 21 c1 e4			ld hl,os_input+2 
1c95 cd b5 13			call get_word_hl 
1c98			 
1c98 e9				jp (hl) 
1c99 c3 b0 1b			jp monitor 
1c9c			 
1c9c			.mondump:    
1c9c 21 c1 e4			ld hl,os_input+2 
1c9f cd b5 13			call get_word_hl 
1ca2			 
1ca2 22 e4 e5			ld (os_cur_ptr),hl	 
1ca5 cd ea 1c			call dumpcont 
1ca8 3e 78			ld a, display_row_4 
1caa 11 5c 1b			ld de, endprog 
1cad			 
1cad cd dc 0b			call update_display		 
1cb0			 
1cb0 cd e2 1d			call next_page_prompt 
1cb3 c3 b0 1b			jp monitor 
1cb6			.moncdump: 
1cb6 cd ea 1c			call dumpcont 
1cb9 3e 78			ld a, display_row_4 
1cbb 11 5c 1b			ld de, endprog 
1cbe			 
1cbe cd dc 0b			call update_display		 
1cc1			 
1cc1 cd e2 1d			call next_page_prompt 
1cc4 c3 b0 1b			jp monitor 
1cc7			 
1cc7			 
1cc7			; TODO symbol access  
1cc7			 
1cc7			.symbols:     ;; A list of symbols that can be called up  
1cc7 b1 ed			dw display_fb0 
1cc9 .. 00			db "fb0",0  
1ccd 7a ea		     	dw store_page 
1ccf .. 00			db "store_page",0 
1cda			 
1cda			 
1cda			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1cda			 
1cda 3a c2 e2			ld a,(scratch+1) 
1cdd fe 00			cp 0 
1cdf 28 09			jr z, dumpcont 
1ce1			 
1ce1				; no, not a null term line so has an address to work out.... 
1ce1			 
1ce1 21 c3 e2			ld hl,scratch+2 
1ce4 cd b5 13			call get_word_hl 
1ce7			 
1ce7 22 e4 e5			ld (os_cur_ptr),hl	 
1cea			 
1cea			 
1cea			 
1cea			dumpcont: 
1cea			 
1cea				; dump bytes at ptr 
1cea			 
1cea			 
1cea 3e 00			ld a, display_row_1 
1cec 2a cc eb			ld hl, (display_fb_active) 
1cef cd e6 0d			call addatohl 
1cf2 cd 1a 1d			call .dumpbyterow 
1cf5			 
1cf5 3e 28			ld a, display_row_2 
1cf7 2a cc eb			ld hl, (display_fb_active) 
1cfa cd e6 0d			call addatohl 
1cfd cd 1a 1d			call .dumpbyterow 
1d00			 
1d00			 
1d00 3e 50			ld a, display_row_3 
1d02 2a cc eb			ld hl, (display_fb_active) 
1d05 cd e6 0d			call addatohl 
1d08 cd 1a 1d			call .dumpbyterow 
1d0b			 
1d0b 3e 78			ld a, display_row_4 
1d0d 2a cc eb			ld hl, (display_fb_active) 
1d10 cd e6 0d			call addatohl 
1d13 cd 1a 1d			call .dumpbyterow 
1d16			 
1d16 cd dc 0b			call update_display 
1d19			;		jp cli 
1d19 c9				ret 
1d1a			 
1d1a			.dumpbyterow: 
1d1a			 
1d1a				;push af 
1d1a			 
1d1a e5				push hl 
1d1b			 
1d1b				; calc where to poke the ascii 
1d1b			if display_cols == 20 
1d1b				ld a, 16 
1d1b			else 
1d1b 3e 1f			ld a, 31 
1d1d			endif 
1d1d			 
1d1d cd e6 0d			call addatohl 
1d20 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1d23			 
1d23			 
1d23			; display decoding address 
1d23 2a e4 e5		   	ld hl,(os_cur_ptr) 
1d26			 
1d26 7c				ld a,h 
1d27 e1				pop hl 
1d28 e5				push hl 
1d29			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d29 cd ff 12			call hexout 
1d2c 2a e4 e5		   	ld hl,(os_cur_ptr) 
1d2f			 
1d2f 7d				ld a,l 
1d30 e1				pop hl 
1d31 23				inc hl 
1d32 23				inc hl 
1d33 e5				push hl 
1d34			;	ld hl, os_word_scratch+2 
1d34 cd ff 12			call hexout 
1d37 e1				pop hl 
1d38 23				inc hl 
1d39 23				inc hl 
1d3a				;ld hl, os_word_scratch+4 
1d3a 3e 3a			ld a, ':' 
1d3c 77				ld (hl),a 
1d3d 23				inc hl 
1d3e				;ld a, 0 
1d3e				;ld (hl),a 
1d3e				;ld de, os_word_scratch 
1d3e				;pop af 
1d3e				;push af 
1d3e			;		ld a, display_row_2 
1d3e			;		call str_at_display 
1d3e			;		call update_display 
1d3e			 
1d3e			 
1d3e			;pop af 
1d3e			;	add 5 
1d3e			 
1d3e			if display_cols == 20 
1d3e				ld b, 4 
1d3e			else 
1d3e 06 08			ld b, 8 
1d40			endif	 
1d40			 
1d40			.dumpbyte: 
1d40 c5				push bc 
1d41 e5				push hl 
1d42			 
1d42			 
1d42 2a e4 e5		   	ld hl,(os_cur_ptr) 
1d45 7e					ld a,(hl) 
1d46			 
1d46					; poke the ascii to display 
1d46 2a c6 e5				ld hl,(os_word_scratch) 
1d49 77					ld (hl),a 
1d4a 23					inc hl 
1d4b 22 c6 e5				ld (os_word_scratch),hl 
1d4e			 
1d4e					 
1d4e			 
1d4e			 
1d4e e1					pop hl 
1d4f e5					push hl 
1d50			 
1d50 cd ff 12				call hexout 
1d53			 
1d53					 
1d53 2a e4 e5		   	ld hl,(os_cur_ptr) 
1d56 23				inc hl 
1d57 22 e4 e5		   	ld (os_cur_ptr),hl 
1d5a			 
1d5a e1					pop hl 
1d5b 23					inc hl 
1d5c 23					inc hl 
1d5d 23					inc hl 
1d5e			 
1d5e			 
1d5e			 
1d5e					;ld a,0 
1d5e					;ld (os_word_scratch+2),a 
1d5e					;pop af 
1d5e					;push af 
1d5e			 
1d5e					;ld de, os_word_scratch 
1d5e					;call str_at_display 
1d5e			;		call update_display 
1d5e			;		pop af 
1d5e c1					pop bc 
1d5f c6 03				add 3 
1d61 10 dd			djnz .dumpbyte 
1d63			 
1d63				 
1d63			 
1d63 c9				ret 
1d64			 
1d64			jump:	 
1d64			 
1d64 21 c3 e2			ld hl,scratch+2 
1d67 cd b5 13			call get_word_hl 
1d6a				;ld hl,(scratch+2) 
1d6a				;call fourehexhl 
1d6a			 
1d6a 22 e4 e5			ld (os_cur_ptr),hl	 
1d6d			 
1d6d e9				jp (hl) 
1d6e			 
1d6e			 
1d6e			 
1d6e			; TODO implement a basic monitor mode to start with 
1d6e			 
1d6e			 
1d6e			 
1d6e			 
1d6e			 
1d6e			 
1d6e			 
1d6e			 
1d6e			 
1d6e			; testing and demo code during development 
1d6e			 
1d6e			 
1d6e .. 00		str1: db "Enter some text...",0 
1d81 .. 00		clear: db "                    ",0 
1d96			 
1d96			demo: 
1d96			 
1d96			 
1d96			 
1d96			;	call update_display 
1d96			 
1d96				; init scratch input area for testing 
1d96 21 c1 e2			ld hl, scratch	 
1d99 3e 00			ld a,0 
1d9b 77				ld (hl),a 
1d9c			 
1d9c			 
1d9c 3e 28		            LD   A, display_row_2 
1d9e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d9e 11 6e 1d		            LD   DE, str1 
1da1 cd cc 0b			call str_at_display 
1da4			 
1da4			;            CALL fLCD_Str       ;Display string pointed to by DE 
1da4			cloop:	 
1da4 3e 50		            LD   A, display_row_3 
1da6			;            CALL fLCD_Pos       ;Position cursor to location in A 
1da6 11 81 1d		            LD   DE, clear 
1da9			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1da9 cd cc 0b				call str_at_display 
1dac 3e 78			ld a, display_row_4 
1dae 11 de 1d			ld de, prompt 
1db1			 
1db1 cd cc 0b				call str_at_display 
1db4 cd dc 0b			call update_display 
1db7			 
1db7 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1db9 16 0a			ld d, 10 
1dbb 21 c1 e2			ld hl, scratch	 
1dbe cd 13 0e			call input_str 
1dc1			 
1dc1			;	call clear_display 
1dc1			;'	call update_display 
1dc1			 
1dc1 3e 00		            LD   A, display_row_1 
1dc3			;            CALL fLCD_Pos       ;Position cursor to location in A 
1dc3 11 81 1d		            LD   DE, clear 
1dc6 cd cc 0b				call str_at_display 
1dc9			;            CALL fLCD_Str       ;Display string pointed to by DE 
1dc9 3e 00		            LD   A, display_row_1 
1dcb			;            CALL fLCD_Pos       ;Position cursor to location in A 
1dcb 11 c1 e2		            LD   DE, scratch 
1dce			;            CALL fLCD_Str       ;Display string pointed to by DE 
1dce cd cc 0b				call str_at_display 
1dd1 cd dc 0b			call update_display 
1dd4			 
1dd4 3e 00				ld a,0 
1dd6 21 c1 e2			ld hl, scratch 
1dd9 77				ld (hl),a 
1dda			 
1dda 00				nop 
1ddb c3 a4 1d			jp cloop 
1dde			 
1dde			 
1dde			 
1dde			; OS Prompt 
1dde			 
1dde .. 00		prompt: db ">",0 
1de0 .. 00		endprg: db "?",0 
1de2			 
1de2			 
1de2			; handy next page prompt 
1de2			next_page_prompt: 
1de2 e5				push hl 
1de3 d5				push de 
1de4 f5				push af 
1de5 c5				push bc 
1de6			 
1de6 3e 9f			ld a,display_row_4 + display_cols - 1 
1de8 11 e0 1d		        ld de, endprg 
1deb cd cc 0b			call str_at_display 
1dee cd dc 0b			call update_display 
1df1 cd 3e 68			call cin_wait 
1df4 c1				pop bc 
1df5 f1				pop af 
1df6 d1				pop de 
1df7 e1				pop hl 
1df8			 
1df8			 
1df8 c9				ret 
1df9			 
1df9			 
1df9			; forth parser 
1df9			 
1df9			; My forth kernel 
1df9			include "forth_kernel.asm" 
1df9			; 
1df9			; kernel to the forth OS 
1df9			 
1df9			DS_TYPE_STR: equ 1     ; string type 
1df9			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1df9			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1df9			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1df9			 
1df9			FORTH_PARSEV1: equ 0 
1df9			FORTH_PARSEV2: equ 0 
1df9			FORTH_PARSEV3: equ 0 
1df9			FORTH_PARSEV4: equ 0 
1df9			FORTH_PARSEV5: equ 1 
1df9			 
1df9			;if FORTH_PARSEV5 
1df9			;	FORTH_END_BUFFER: equ 0 
1df9			;else 
1df9			FORTH_END_BUFFER: equ 127 
1df9			;endif 
1df9			 
1df9			FORTH_TRUE: equ 1 
1df9			FORTH_FALSE: equ 0 
1df9			 
1df9			if FORTH_PARSEV4 
1df9			include "forth_stackops.asm" 
1df9			endif 
1df9			 
1df9			if FORTH_PARSEV5 
1df9			include "forth_stackopsv5.asm" 
1df9			 
1df9			; Stack operations for v5 parser on wards 
1df9			; * DATA stack 
1df9			; * LOOP stack 
1df9			; * RETURN stack 
1df9			 
1df9			 
1df9			 
1df9			FORTH_CHK_DSP_UNDER: macro 
1df9				push hl 
1df9				push de 
1df9				ld hl,(cli_data_sp) 
1df9				ld de, cli_data_stack 
1df9				call cmp16 
1df9				jp c, fault_dsp_under 
1df9				pop de 
1df9				pop hl 
1df9				endm 
1df9			 
1df9			 
1df9			FORTH_CHK_RSP_UNDER: macro 
1df9				push hl 
1df9				push de 
1df9				ld hl,(cli_ret_sp) 
1df9				ld de, cli_ret_stack 
1df9				call cmp16 
1df9				jp c, fault_rsp_under 
1df9				pop de 
1df9				pop hl 
1df9				endm 
1df9			 
1df9			FORTH_CHK_LOOP_UNDER: macro 
1df9				push hl 
1df9				push de 
1df9				ld hl,(cli_loop_sp) 
1df9				ld de, cli_loop_stack 
1df9				call cmp16 
1df9				jp c, fault_loop_under 
1df9				pop de 
1df9				pop hl 
1df9				endm 
1df9			 
1df9			FORTH_ERR_TOS_NOTSTR: macro 
1df9				; TOSO might need more for checks when used 
1df9				push af 
1df9				ld a,(hl) 
1df9				cp DS_TYPE_STR 
1df9				jp nz, type_faultn   
1df9				pop af 
1df9				endm 
1df9			 
1df9			FORTH_ERR_TOS_NOTNUM: macro 
1df9				push af 
1df9				ld a,(hl) 
1df9				cp DS_TYPE_INUM 
1df9				jp nz, type_faultn   
1df9				pop af 
1df9				endm 
1df9			 
1df9			 
1df9			; increase data stack pointer and save hl to it 
1df9				 
1df9			FORTH_DSP_NEXT: macro 
1df9				call macro_forth_dsp_next 
1df9				endm 
1df9			 
1df9			 
1df9			macro_forth_dsp_next: 
1df9				if DEBUG_FORTH_STACK_GUARD 
1df9 cd 6d 64				call check_stacks 
1dfc				endif 
1dfc e5				push hl 
1dfd d5				push de 
1dfe eb				ex de,hl 
1dff 2a ee e9			ld hl,(cli_data_sp) 
1e02 23				inc hl 
1e03 23				inc hl 
1e04			 
1e04			; PARSEV5 
1e04 23				inc hl 
1e05 22 ee e9			ld (cli_data_sp),hl 
1e08 73				ld (hl), e 
1e09 23				inc hl 
1e0a 72				ld (hl), d 
1e0b d1				pop de 
1e0c e1				pop hl 
1e0d				if DEBUG_FORTH_STACK_GUARD 
1e0d cd 6d 64				call check_stacks 
1e10				endif 
1e10 c9				ret 
1e11			 
1e11			 
1e11			; increase ret stack pointer and save hl to it 
1e11				 
1e11			FORTH_RSP_NEXT: macro 
1e11				call macro_forth_rsp_next 
1e11				endm 
1e11			 
1e11			macro_forth_rsp_next: 
1e11				if DEBUG_FORTH_STACK_GUARD 
1e11 cd 6d 64				call check_stacks 
1e14				endif 
1e14 e5				push hl 
1e15 d5				push de 
1e16 eb				ex de,hl 
1e17 2a f2 e9			ld hl,(cli_ret_sp) 
1e1a 23				inc hl 
1e1b 23				inc hl 
1e1c 22 f2 e9			ld (cli_ret_sp),hl 
1e1f 73				ld (hl), e 
1e20 23				inc hl 
1e21 72				ld (hl), d 
1e22 d1				pop de 
1e23 e1				pop hl 
1e24				if DEBUG_FORTH_STACK_GUARD 
1e24 cd 6d 64				call check_stacks 
1e27				endif 
1e27 c9				ret 
1e28			 
1e28			; get current ret stack pointer and save to hl  
1e28				 
1e28			FORTH_RSP_TOS: macro 
1e28				call macro_forth_rsp_tos 
1e28				endm 
1e28			 
1e28			macro_forth_rsp_tos: 
1e28				;push de 
1e28 2a f2 e9			ld hl,(cli_ret_sp) 
1e2b cd 63 1e			call loadhlptrtohl 
1e2e				;ld e, (hl) 
1e2e				;inc hl 
1e2e				;ld d, (hl) 
1e2e				;ex de, hl 
1e2e					if DEBUG_FORTH_WORDS 
1e2e			;			DMARK "RST" 
1e2e						CALLMONITOR 
1e2e cd 6f ee			call debug_vector  
1e31				endm  
# End of macro CALLMONITOR
1e31					endif 
1e31				;pop de 
1e31 c9				ret 
1e32			 
1e32			; pop ret stack pointer 
1e32				 
1e32			FORTH_RSP_POP: macro 
1e32				call macro_forth_rsp_pop 
1e32				endm 
1e32			 
1e32			 
1e32			macro_forth_rsp_pop: 
1e32				if DEBUG_FORTH_STACK_GUARD 
1e32			;		DMARK "RPP" 
1e32 cd 6d 64				call check_stacks 
1e35					FORTH_CHK_RSP_UNDER 
1e35 e5				push hl 
1e36 d5				push de 
1e37 2a f2 e9			ld hl,(cli_ret_sp) 
1e3a 11 ac e9			ld de, cli_ret_stack 
1e3d cd 04 0e			call cmp16 
1e40 da 81 65			jp c, fault_rsp_under 
1e43 d1				pop de 
1e44 e1				pop hl 
1e45				endm 
# End of macro FORTH_CHK_RSP_UNDER
1e45				endif 
1e45 e5				push hl 
1e46 2a f2 e9			ld hl,(cli_ret_sp) 
1e49			 
1e49			 
1e49				if FORTH_ENABLE_FREE 
1e49			 
1e49					; get pointer 
1e49			 
1e49					push de 
1e49					push hl 
1e49			 
1e49					ld e, (hl) 
1e49					inc hl 
1e49					ld d, (hl) 
1e49			 
1e49					ex de, hl 
1e49					call free 
1e49			 
1e49					pop hl 
1e49					pop de 
1e49			 
1e49			 
1e49				endif 
1e49			 
1e49			 
1e49 2b				dec hl 
1e4a 2b				dec hl 
1e4b 22 f2 e9			ld (cli_ret_sp), hl 
1e4e				; do stack underflow checks 
1e4e e1				pop hl 
1e4f				if DEBUG_FORTH_STACK_GUARD 
1e4f cd 6d 64				call check_stacks 
1e52					FORTH_CHK_RSP_UNDER 
1e52 e5				push hl 
1e53 d5				push de 
1e54 2a f2 e9			ld hl,(cli_ret_sp) 
1e57 11 ac e9			ld de, cli_ret_stack 
1e5a cd 04 0e			call cmp16 
1e5d da 81 65			jp c, fault_rsp_under 
1e60 d1				pop de 
1e61 e1				pop hl 
1e62				endm 
# End of macro FORTH_CHK_RSP_UNDER
1e62				endif 
1e62 c9				ret 
1e63			 
1e63			 
1e63			 
1e63			; routine to load word pointed to by hl into hl 
1e63			 
1e63			loadhlptrtohl: 
1e63			 
1e63 d5				push de 
1e64 5e				ld e, (hl) 
1e65 23				inc hl 
1e66 56				ld d, (hl) 
1e67 eb				ex de, hl 
1e68 d1				pop de 
1e69			 
1e69 c9				ret 
1e6a			 
1e6a			 
1e6a			 
1e6a			 
1e6a			 
1e6a			; push a number held in HL onto the data stack 
1e6a			; entry point for pushing a value when already in hl used in function above 
1e6a			 
1e6a			forth_push_numhl: 
1e6a			 
1e6a e5				push hl    ; save value to push 
1e6b			 
1e6b			if DEBUG_FORTH_PUSH 
1e6b				; see if disabled 
1e6b			 
1e6b			 
1e6b f5				push af 
1e6c 3a 6f ee			ld a,(debug_vector) 
1e6f fe c9			cp $c9   ; ret 
1e71			;	ld a, (os_view_disable) 
1e71			;	cp '*' 
1e71 28 34			jr z, .pskip2 
1e73 e5				push hl 
1e74 e5			push hl 
1e75 cd b9 0b			call clear_display 
1e78 e1			pop hl 
1e79 7c				ld a,h 
1e7a 21 c6 e5			ld hl, os_word_scratch 
1e7d cd ff 12			call hexout 
1e80 e1				pop hl 
1e81 7d				ld a,l 
1e82 21 c8 e5			ld hl, os_word_scratch+2 
1e85 cd ff 12			call hexout 
1e88			 
1e88 21 ca e5			ld hl, os_word_scratch+4 
1e8b 3e 00			ld a,0 
1e8d 77				ld (hl),a 
1e8e 11 c6 e5			ld de,os_word_scratch 
1e91 3e 28				ld a, display_row_2 
1e93 cd cc 0b				call str_at_display 
1e96 11 7f 4f			ld de, .push_num 
1e99 3e 00			ld a, display_row_1 
1e9b			 
1e9b cd cc 0b				call str_at_display 
1e9e			 
1e9e			 
1e9e cd dc 0b			call update_display 
1ea1 cd f1 0a			call delay1s 
1ea4 cd f1 0a			call delay1s 
1ea7			.pskip2:  
1ea7			 
1ea7 f1				pop af 
1ea8			endif	 
1ea8			 
1ea8			 
1ea8				FORTH_DSP_NEXT 
1ea8 cd f9 1d			call macro_forth_dsp_next 
1eab				endm 
# End of macro FORTH_DSP_NEXT
1eab			 
1eab 2a ee e9			ld hl, (cli_data_sp) 
1eae			 
1eae				; save item type 
1eae 3e 02			ld a,  DS_TYPE_INUM 
1eb0 77				ld (hl), a 
1eb1 23				inc hl 
1eb2			 
1eb2				; get word off stack 
1eb2 d1				pop de 
1eb3 7b				ld a,e 
1eb4 77				ld (hl), a 
1eb5 23				inc hl 
1eb6 7a				ld a,d 
1eb7 77				ld (hl), a 
1eb8			 
1eb8			if DEBUG_FORTH_PUSH 
1eb8 2b				dec hl 
1eb9 2b				dec hl 
1eba 2b				dec hl 
1ebb						DMARK "PH5" 
1ebb f5				push af  
1ebc 3a d0 1e			ld a, (.dmark)  
1ebf 32 6b ee			ld (debug_mark),a  
1ec2 3a d1 1e			ld a, (.dmark+1)  
1ec5 32 6c ee			ld (debug_mark+1),a  
1ec8 3a d2 1e			ld a, (.dmark+2)  
1ecb 32 6d ee			ld (debug_mark+2),a  
1ece 18 03			jr .pastdmark  
1ed0 ..			.dmark: db "PH5"  
1ed3 f1			.pastdmark: pop af  
1ed4			endm  
# End of macro DMARK
1ed4				CALLMONITOR 
1ed4 cd 6f ee			call debug_vector  
1ed7				endm  
# End of macro CALLMONITOR
1ed7			endif	 
1ed7			 
1ed7 c9				ret 
1ed8			 
1ed8			 
1ed8			; Push a string to stack pointed to by hl 
1ed8			 
1ed8			forth_push_str: 
1ed8			 
1ed8			if DEBUG_FORTH_PUSH 
1ed8						DMARK "PSQ" 
1ed8 f5				push af  
1ed9 3a ed 1e			ld a, (.dmark)  
1edc 32 6b ee			ld (debug_mark),a  
1edf 3a ee 1e			ld a, (.dmark+1)  
1ee2 32 6c ee			ld (debug_mark+1),a  
1ee5 3a ef 1e			ld a, (.dmark+2)  
1ee8 32 6d ee			ld (debug_mark+2),a  
1eeb 18 03			jr .pastdmark  
1eed ..			.dmark: db "PSQ"  
1ef0 f1			.pastdmark: pop af  
1ef1			endm  
# End of macro DMARK
1ef1				CALLMONITOR 
1ef1 cd 6f ee			call debug_vector  
1ef4				endm  
# End of macro CALLMONITOR
1ef4			endif	 
1ef4			    
1ef4 e5				push hl 
1ef5 e5				push hl 
1ef6			 
1ef6			;	ld a, 0   ; find end of string 
1ef6 cd 5c 14			call strlenz 
1ef9			if DEBUG_FORTH_PUSH 
1ef9						DMARK "PQ2" 
1ef9 f5				push af  
1efa 3a 0e 1f			ld a, (.dmark)  
1efd 32 6b ee			ld (debug_mark),a  
1f00 3a 0f 1f			ld a, (.dmark+1)  
1f03 32 6c ee			ld (debug_mark+1),a  
1f06 3a 10 1f			ld a, (.dmark+2)  
1f09 32 6d ee			ld (debug_mark+2),a  
1f0c 18 03			jr .pastdmark  
1f0e ..			.dmark: db "PQ2"  
1f11 f1			.pastdmark: pop af  
1f12			endm  
# End of macro DMARK
1f12				CALLMONITOR 
1f12 cd 6f ee			call debug_vector  
1f15				endm  
# End of macro CALLMONITOR
1f15			endif	 
1f15 eb				ex de, hl 
1f16 e1				pop hl   ; get ptr to start of string 
1f17			if DEBUG_FORTH_PUSH 
1f17						DMARK "PQ3" 
1f17 f5				push af  
1f18 3a 2c 1f			ld a, (.dmark)  
1f1b 32 6b ee			ld (debug_mark),a  
1f1e 3a 2d 1f			ld a, (.dmark+1)  
1f21 32 6c ee			ld (debug_mark+1),a  
1f24 3a 2e 1f			ld a, (.dmark+2)  
1f27 32 6d ee			ld (debug_mark+2),a  
1f2a 18 03			jr .pastdmark  
1f2c ..			.dmark: db "PQ3"  
1f2f f1			.pastdmark: pop af  
1f30			endm  
# End of macro DMARK
1f30				CALLMONITOR 
1f30 cd 6f ee			call debug_vector  
1f33				endm  
# End of macro CALLMONITOR
1f33			endif	 
1f33 19				add hl,de 
1f34			if DEBUG_FORTH_PUSH 
1f34						DMARK "PQE" 
1f34 f5				push af  
1f35 3a 49 1f			ld a, (.dmark)  
1f38 32 6b ee			ld (debug_mark),a  
1f3b 3a 4a 1f			ld a, (.dmark+1)  
1f3e 32 6c ee			ld (debug_mark+1),a  
1f41 3a 4b 1f			ld a, (.dmark+2)  
1f44 32 6d ee			ld (debug_mark+2),a  
1f47 18 03			jr .pastdmark  
1f49 ..			.dmark: db "PQE"  
1f4c f1			.pastdmark: pop af  
1f4d			endm  
# End of macro DMARK
1f4d				CALLMONITOR 
1f4d cd 6f ee			call debug_vector  
1f50				endm  
# End of macro CALLMONITOR
1f50			endif	 
1f50			 
1f50 2b				dec hl    ; see if there is an optional trailing double quote 
1f51 7e				ld a,(hl) 
1f52 fe 22			cp '"' 
1f54 20 03			jr nz, .strnoq 
1f56 3e 00			ld a, 0      ; get rid of double quote 
1f58 77				ld (hl), a 
1f59 23			.strnoq: inc hl 
1f5a			 
1f5a 3e 00			ld a, 0 
1f5c 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1f5d			 
1f5d 13				inc de ; add one for the type string 
1f5e 13				inc de ; add one for null term??? 
1f5f			 
1f5f				; tos is get string pointer again 
1f5f				; de contains space to allocate 
1f5f				 
1f5f d5				push de 
1f60			 
1f60 eb				ex de, hl 
1f61			 
1f61				;push af 
1f61			 
1f61			if DEBUG_FORTH_PUSH 
1f61						DMARK "PHm" 
1f61 f5				push af  
1f62 3a 76 1f			ld a, (.dmark)  
1f65 32 6b ee			ld (debug_mark),a  
1f68 3a 77 1f			ld a, (.dmark+1)  
1f6b 32 6c ee			ld (debug_mark+1),a  
1f6e 3a 78 1f			ld a, (.dmark+2)  
1f71 32 6d ee			ld (debug_mark+2),a  
1f74 18 03			jr .pastdmark  
1f76 ..			.dmark: db "PHm"  
1f79 f1			.pastdmark: pop af  
1f7a			endm  
# End of macro DMARK
1f7a				CALLMONITOR 
1f7a cd 6f ee			call debug_vector  
1f7d				endm  
# End of macro CALLMONITOR
1f7d			endif	 
1f7d cd d1 14			call malloc	; on ret hl now contains allocated memory 
1f80				if DEBUG_FORTH_MALLOC_GUARD 
1f80 cc d7 4f				call z,malloc_error 
1f83				endif 
1f83			 
1f83				 
1f83 c1				pop bc    ; get length 
1f84 d1				pop de   ;  get string start    
1f85			 
1f85				; hl has destination from malloc 
1f85			 
1f85 eb				ex de, hl    ; prep for ldir 
1f86			 
1f86 d5				push de   ; save malloc area for DSP later 
1f87				;push hl   ; save malloc area for DSP later 
1f87			 
1f87			if DEBUG_FORTH_PUSH 
1f87						DMARK "PHc" 
1f87 f5				push af  
1f88 3a 9c 1f			ld a, (.dmark)  
1f8b 32 6b ee			ld (debug_mark),a  
1f8e 3a 9d 1f			ld a, (.dmark+1)  
1f91 32 6c ee			ld (debug_mark+1),a  
1f94 3a 9e 1f			ld a, (.dmark+2)  
1f97 32 6d ee			ld (debug_mark+2),a  
1f9a 18 03			jr .pastdmark  
1f9c ..			.dmark: db "PHc"  
1f9f f1			.pastdmark: pop af  
1fa0			endm  
# End of macro DMARK
1fa0				CALLMONITOR 
1fa0 cd 6f ee			call debug_vector  
1fa3				endm  
# End of macro CALLMONITOR
1fa3			endif	 
1fa3			 
1fa3			 
1fa3 ed b0			ldir 
1fa5			 
1fa5			 
1fa5				; push malloc to data stack     macro?????  
1fa5			 
1fa5				FORTH_DSP_NEXT 
1fa5 cd f9 1d			call macro_forth_dsp_next 
1fa8				endm 
# End of macro FORTH_DSP_NEXT
1fa8			 
1fa8				; save value and type 
1fa8			 
1fa8 2a ee e9			ld hl, (cli_data_sp) 
1fab			 
1fab				; save item type 
1fab 3e 01			ld a,  DS_TYPE_STR 
1fad 77				ld (hl), a 
1fae 23				inc hl 
1faf			 
1faf				; get malloc word off stack 
1faf d1				pop de 
1fb0 73				ld (hl), e 
1fb1 23				inc hl 
1fb2 72				ld (hl), d 
1fb3			 
1fb3			 
1fb3			 
1fb3			if DEBUG_FORTH_PUSH 
1fb3 2a ee e9			ld hl, (cli_data_sp) 
1fb6						DMARK "PHS" 
1fb6 f5				push af  
1fb7 3a cb 1f			ld a, (.dmark)  
1fba 32 6b ee			ld (debug_mark),a  
1fbd 3a cc 1f			ld a, (.dmark+1)  
1fc0 32 6c ee			ld (debug_mark+1),a  
1fc3 3a cd 1f			ld a, (.dmark+2)  
1fc6 32 6d ee			ld (debug_mark+2),a  
1fc9 18 03			jr .pastdmark  
1fcb ..			.dmark: db "PHS"  
1fce f1			.pastdmark: pop af  
1fcf			endm  
# End of macro DMARK
1fcf				CALLMONITOR 
1fcf cd 6f ee			call debug_vector  
1fd2				endm  
# End of macro CALLMONITOR
1fd2			;	ex de,hl 
1fd2			endif	 
1fd2				; in case of spaces, skip the ptr past the copied string 
1fd2				;pop af 
1fd2				;ld (cli_origptr),hl 
1fd2			 
1fd2 c9				ret 
1fd3			 
1fd3			 
1fd3			 
1fd3			; TODO ascii push input onto stack given hl to start of input 
1fd3			 
1fd3			; identify type 
1fd3			; if starts with a " then a string 
1fd3			; otherwise it is a number 
1fd3			;  
1fd3			; if a string 
1fd3			;     scan for ending " to get length of string to malloc for + 1 
1fd3			;     malloc 
1fd3			;     put pointer to string on stack first byte flags as string 
1fd3			; 
1fd3			; else a number 
1fd3			;    look for number format identifier 
1fd3			;    $xx hex 
1fd3			;    %xxxxx bin 
1fd3			;    xxxxx decimal 
1fd3			;    convert number to 16bit word.  
1fd3			;    malloc word + 1 with flag to identiy as num 
1fd3			;    put pointer to number on stack 
1fd3			;   
1fd3			;  
1fd3			  
1fd3			forth_apush: 
1fd3				; kernel push 
1fd3			 
1fd3			if DEBUG_FORTH_PUSH 
1fd3						DMARK "PSH" 
1fd3 f5				push af  
1fd4 3a e8 1f			ld a, (.dmark)  
1fd7 32 6b ee			ld (debug_mark),a  
1fda 3a e9 1f			ld a, (.dmark+1)  
1fdd 32 6c ee			ld (debug_mark+1),a  
1fe0 3a ea 1f			ld a, (.dmark+2)  
1fe3 32 6d ee			ld (debug_mark+2),a  
1fe6 18 03			jr .pastdmark  
1fe8 ..			.dmark: db "PSH"  
1feb f1			.pastdmark: pop af  
1fec			endm  
# End of macro DMARK
1fec				CALLMONITOR 
1fec cd 6f ee			call debug_vector  
1fef				endm  
# End of macro CALLMONITOR
1fef			endif	 
1fef				; identify input type 
1fef			 
1fef 7e				ld a,(hl) 
1ff0 fe 22			cp '"' 
1ff2 28 0a			jr z, .fapstr 
1ff4 fe 24			cp '$' 
1ff6 ca 1e 20			jp z, .faphex 
1ff9 fe 25			cp '%' 
1ffb ca 06 20			jp z, .fapbin 
1ffe			;	cp 'b' 
1ffe			;	jp z, .fabin 
1ffe				; else decimal 
1ffe			 
1ffe				; TODO do decimal conversion 
1ffe				; decimal is stored as a 16bit word 
1ffe			 
1ffe				; by default everything is a string if type is not detected 
1ffe			.fapstr: ; 
1ffe fe 22			cp '"' 
2000 20 01			jr nz, .strnoqu 
2002 23				inc hl 
2003			.strnoqu: 
2003 c3 d8 1e			jp forth_push_str 
2006			 
2006			 
2006			 
2006			.fapbin:    ; push a binary string.  
2006 11 00 00			ld de, 0   ; hold a 16bit value 
2009			 
2009 23			.fapbinshift:	inc hl  
200a 7e				ld a,(hl) 
200b fe 00			cp 0     ; done scanning  
200d 28 0b			jr z, .fapbdone  	; got it in HL so push  
200f			 
200f				; left shift de 
200f eb				ex de, hl	 
2010 29				add hl, hl 
2011			 
2011				; is 1 
2011 fe 31			cp '1' 
2013 20 02			jr nz, .binzero 
2015 cb 4d			bit 1, l 
2017			.binzero: 
2017 eb				ex de, hl	 ; save current de 
2018 18 ef			jr .fapbinshift 
201a			 
201a			.fapbdone: 
201a eb				ex de, hl 
201b c3 6a 1e			jp forth_push_numhl 
201e			 
201e			 
201e			.faphex:   ; hex is always stored as a 16bit word 
201e				; skip number prefix 
201e 23				inc hl 
201f				; turn ascii into number 
201f cd b5 13			call get_word_hl	; ret 16bit word in hl 
2022			 
2022 c3 6a 1e			jp forth_push_numhl 
2025			 
2025 00				 nop 
2026			 
2026			.fabin:   ; TODO bin conversion 
2026			 
2026			 
2026 c9				ret 
2027			 
2027			 
2027			; get either a string ptr or a 16bit word from the data stack 
2027			 
2027			FORTH_DSP: macro 
2027				call macro_forth_dsp 
2027				endm 
2027			 
2027			macro_forth_dsp: 
2027				; data stack pointer points to current word on tos 
2027			 
2027 2a ee e9			ld hl,(cli_data_sp) 
202a			 
202a				if DEBUG_FORTH_PUSH 
202a						DMARK "DSP" 
202a f5				push af  
202b 3a 3f 20			ld a, (.dmark)  
202e 32 6b ee			ld (debug_mark),a  
2031 3a 40 20			ld a, (.dmark+1)  
2034 32 6c ee			ld (debug_mark+1),a  
2037 3a 41 20			ld a, (.dmark+2)  
203a 32 6d ee			ld (debug_mark+2),a  
203d 18 03			jr .pastdmark  
203f ..			.dmark: db "DSP"  
2042 f1			.pastdmark: pop af  
2043			endm  
# End of macro DMARK
2043			 
2043 cd 0a 50				call display_data_sp 
2046				;call break_point_state 
2046				;rst 030h 
2046				CALLMONITOR 
2046 cd 6f ee			call debug_vector  
2049				endm  
# End of macro CALLMONITOR
2049				endif 
2049			 
2049 c9				ret 
204a			 
204a			; return hl to start of value on stack 
204a			 
204a			FORTH_DSP_VALUE: macro 
204a				call macro_forth_dsp_value 
204a				endm 
204a			 
204a			macro_forth_dsp_value: 
204a			 
204a				FORTH_DSP 
204a cd 27 20			call macro_forth_dsp 
204d				endm 
# End of macro FORTH_DSP
204d			 
204d d5				push de 
204e			 
204e 23				inc hl ; skip type 
204f			 
204f 5e				ld e, (hl) 
2050 23				inc hl 
2051 56				ld d, (hl) 
2052 eb				ex de,hl  
2053			 
2053 d1				pop de 
2054			 
2054 c9				ret 
2055			 
2055			; return hl to start of value to second item on stack 
2055			 
2055			FORTH_DSP_VALUEM1: macro 
2055				call macro_forth_dsp_value_m1 
2055				endm 
2055			 
2055			macro_forth_dsp_value_m1: 
2055			 
2055				FORTH_DSP 
2055 cd 27 20			call macro_forth_dsp 
2058				endm 
# End of macro FORTH_DSP
2058			 
2058 2b				dec hl 
2059 2b				dec hl 
205a			;	dec hl 
205a			 
205a d5				push de 
205b			 
205b 5e				ld e, (hl) 
205c 23				inc hl 
205d 56				ld d, (hl) 
205e eb				ex de,hl  
205f			 
205f d1				pop de 
2060			 
2060 c9				ret 
2061			 
2061				 
2061			 
2061			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2061			 
2061			FORTH_DSP_POP: macro 
2061				call macro_forth_dsp_pop 
2061				endm 
2061			 
2061			 
2061			; get the tos data type 
2061			 
2061			FORTH_DSP_TYPE:   macro 
2061			 
2061				;FORTH_DSP_VALUE 
2061				FORTH_DSP 
2061				 
2061				; hl points to value 
2061				; check type 
2061			 
2061				ld a,(hl) 
2061			 
2061				endm 
2061			 
2061			; load the tos value into hl 
2061			 
2061			 
2061			FORTH_DSP_VALUEHL:  macro 
2061				call macro_dsp_valuehl 
2061				endm 
2061			 
2061			 
2061			 
2061			macro_dsp_valuehl: 
2061				FORTH_DSP_VALUE 
2061 cd 4a 20			call macro_forth_dsp_value 
2064				endm 
# End of macro FORTH_DSP_VALUE
2064			 
2064				;FORTH_ERR_TOS_NOTNUM 
2064			 
2064				;inc hl   ; skip type id 
2064			 
2064			;	push de 
2064			; 
2064			;	ld e, (hl) 
2064			;	inc hl 
2064			;	ld d, (hl) 
2064			;	ex de,hl  
2064			 
2064			;	pop de 
2064			 
2064				if DEBUG_FORTH_PUSH 
2064						DMARK "DVL" 
2064 f5				push af  
2065 3a 79 20			ld a, (.dmark)  
2068 32 6b ee			ld (debug_mark),a  
206b 3a 7a 20			ld a, (.dmark+1)  
206e 32 6c ee			ld (debug_mark+1),a  
2071 3a 7b 20			ld a, (.dmark+2)  
2074 32 6d ee			ld (debug_mark+2),a  
2077 18 03			jr .pastdmark  
2079 ..			.dmark: db "DVL"  
207c f1			.pastdmark: pop af  
207d			endm  
# End of macro DMARK
207d				CALLMONITOR 
207d cd 6f ee			call debug_vector  
2080				endm  
# End of macro CALLMONITOR
2080				endif 
2080 c9				ret 
2081			 
2081			forth_apushstrhl:      
2081				; push of string requires use of cli_origptr 
2081				; bodge use 
2081			 
2081				; get current cli_origptr, save, update with temp pointer  
2081 ed 5b 3e ea		ld de, (cli_origptr) 
2085 22 3e ea			ld (cli_origptr), hl 
2088 d5				push de 
2089 cd d3 1f			call forth_apush 
208c d1				pop de 
208d ed 53 3e ea		ld (cli_origptr), de 
2091 c9			        ret	 
2092			 
2092			 
2092			; increase loop stack pointer and save hl to it 
2092				 
2092			FORTH_LOOP_NEXT: macro 
2092				call macro_forth_loop_next 
2092				;nop 
2092				endm 
2092			 
2092			macro_forth_loop_next: 
2092				if DEBUG_FORTH_STACK_GUARD 
2092 cd 6d 64				call check_stacks 
2095				endif 
2095 e5				push hl 
2096 d5				push de 
2097 eb				ex de,hl 
2098 2a f0 e9			ld hl,(cli_loop_sp) 
209b 23				inc hl 
209c 23				inc hl 
209d					if DEBUG_FORTH_WORDS 
209d						DMARK "LNX" 
209d f5				push af  
209e 3a b2 20			ld a, (.dmark)  
20a1 32 6b ee			ld (debug_mark),a  
20a4 3a b3 20			ld a, (.dmark+1)  
20a7 32 6c ee			ld (debug_mark+1),a  
20aa 3a b4 20			ld a, (.dmark+2)  
20ad 32 6d ee			ld (debug_mark+2),a  
20b0 18 03			jr .pastdmark  
20b2 ..			.dmark: db "LNX"  
20b5 f1			.pastdmark: pop af  
20b6			endm  
# End of macro DMARK
20b6						CALLMONITOR 
20b6 cd 6f ee			call debug_vector  
20b9				endm  
# End of macro CALLMONITOR
20b9					endif 
20b9 22 f0 e9			ld (cli_loop_sp),hl 
20bc 73				ld (hl), e 
20bd 23				inc hl 
20be 72				ld (hl), d 
20bf d1				pop de    ; been reversed so save a swap on restore 
20c0 e1				pop hl 
20c1				if DEBUG_FORTH_STACK_GUARD 
20c1 cd 6d 64				call check_stacks 
20c4				endif 
20c4 c9				ret 
20c5			 
20c5			; get current ret stack pointer and save to hl  
20c5				 
20c5			FORTH_LOOP_TOS: macro 
20c5				call macro_forth_loop_tos 
20c5				endm 
20c5			 
20c5			macro_forth_loop_tos: 
20c5 d5				push de 
20c6 2a f0 e9			ld hl,(cli_loop_sp) 
20c9 5e				ld e, (hl) 
20ca 23				inc hl 
20cb 56				ld d, (hl) 
20cc eb				ex de, hl 
20cd d1				pop de 
20ce c9				ret 
20cf			 
20cf			; pop loop stack pointer 
20cf				 
20cf			FORTH_LOOP_POP: macro 
20cf				call macro_forth_loop_pop 
20cf				endm 
20cf			 
20cf			 
20cf			macro_forth_loop_pop: 
20cf				if DEBUG_FORTH_STACK_GUARD 
20cf					DMARK "LPP" 
20cf f5				push af  
20d0 3a e4 20			ld a, (.dmark)  
20d3 32 6b ee			ld (debug_mark),a  
20d6 3a e5 20			ld a, (.dmark+1)  
20d9 32 6c ee			ld (debug_mark+1),a  
20dc 3a e6 20			ld a, (.dmark+2)  
20df 32 6d ee			ld (debug_mark+2),a  
20e2 18 03			jr .pastdmark  
20e4 ..			.dmark: db "LPP"  
20e7 f1			.pastdmark: pop af  
20e8			endm  
# End of macro DMARK
20e8 cd 6d 64				call check_stacks 
20eb					FORTH_CHK_LOOP_UNDER 
20eb e5				push hl 
20ec d5				push de 
20ed 2a f0 e9			ld hl,(cli_loop_sp) 
20f0 11 2a e9			ld de, cli_loop_stack 
20f3 cd 04 0e			call cmp16 
20f6 da 87 65			jp c, fault_loop_under 
20f9 d1				pop de 
20fa e1				pop hl 
20fb				endm 
# End of macro FORTH_CHK_LOOP_UNDER
20fb				endif 
20fb e5				push hl 
20fc 2a f0 e9			ld hl,(cli_loop_sp) 
20ff 2b				dec hl 
2100 2b				dec hl 
2101 22 f0 e9			ld (cli_loop_sp), hl 
2104				; TODO do stack underflow checks 
2104 e1				pop hl 
2105				if DEBUG_FORTH_STACK_GUARD 
2105 cd 6d 64				call check_stacks 
2108					FORTH_CHK_LOOP_UNDER 
2108 e5				push hl 
2109 d5				push de 
210a 2a f0 e9			ld hl,(cli_loop_sp) 
210d 11 2a e9			ld de, cli_loop_stack 
2110 cd 04 0e			call cmp16 
2113 da 87 65			jp c, fault_loop_under 
2116 d1				pop de 
2117 e1				pop hl 
2118				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2118				endif 
2118 c9				ret 
2119			 
2119			macro_forth_dsp_pop: 
2119			 
2119 e5				push hl 
211a			 
211a				; release malloc data 
211a			 
211a				if DEBUG_FORTH_STACK_GUARD 
211a cd 6d 64				call check_stacks 
211d					FORTH_CHK_DSP_UNDER 
211d e5				push hl 
211e d5				push de 
211f 2a ee e9			ld hl,(cli_data_sp) 
2122 11 28 e8			ld de, cli_data_stack 
2125 cd 04 0e			call cmp16 
2128 da 7b 65			jp c, fault_dsp_under 
212b d1				pop de 
212c e1				pop hl 
212d				endm 
# End of macro FORTH_CHK_DSP_UNDER
212d				endif 
212d				;ld hl,(cli_data_sp) 
212d			if DEBUG_FORTH_DOT 
212d				DMARK "DPP" 
212d f5				push af  
212e 3a 42 21			ld a, (.dmark)  
2131 32 6b ee			ld (debug_mark),a  
2134 3a 43 21			ld a, (.dmark+1)  
2137 32 6c ee			ld (debug_mark+1),a  
213a 3a 44 21			ld a, (.dmark+2)  
213d 32 6d ee			ld (debug_mark+2),a  
2140 18 03			jr .pastdmark  
2142 ..			.dmark: db "DPP"  
2145 f1			.pastdmark: pop af  
2146			endm  
# End of macro DMARK
2146				CALLMONITOR 
2146 cd 6f ee			call debug_vector  
2149				endm  
# End of macro CALLMONITOR
2149			endif	 
2149			 
2149			 
2149			if FORTH_ENABLE_DSPPOPFREE 
2149			 
2149				FORTH_DSP 
2149 cd 27 20			call macro_forth_dsp 
214c				endm 
# End of macro FORTH_DSP
214c			 
214c 7e				ld a, (hl) 
214d fe 01			cp DS_TYPE_STR 
214f 20 23			jr nz, .skippopfree 
2151			 
2151				FORTH_DSP_VALUEHL 
2151 cd 61 20			call macro_dsp_valuehl 
2154				endm 
# End of macro FORTH_DSP_VALUEHL
2154 00				nop 
2155			if DEBUG_FORTH_DOT 
2155				DMARK "DPf" 
2155 f5				push af  
2156 3a 6a 21			ld a, (.dmark)  
2159 32 6b ee			ld (debug_mark),a  
215c 3a 6b 21			ld a, (.dmark+1)  
215f 32 6c ee			ld (debug_mark+1),a  
2162 3a 6c 21			ld a, (.dmark+2)  
2165 32 6d ee			ld (debug_mark+2),a  
2168 18 03			jr .pastdmark  
216a ..			.dmark: db "DPf"  
216d f1			.pastdmark: pop af  
216e			endm  
# End of macro DMARK
216e				CALLMONITOR 
216e cd 6f ee			call debug_vector  
2171				endm  
# End of macro CALLMONITOR
2171			endif	 
2171 cd 9b 15			call free 
2174			.skippopfree: 
2174				 
2174			 
2174			endif 
2174			 
2174			if DEBUG_FORTH_DOT_KEY 
2174				DMARK "DP2" 
2174				CALLMONITOR 
2174			endif	 
2174			 
2174				; move pointer down 
2174			 
2174 2a ee e9			ld hl,(cli_data_sp) 
2177 2b				dec hl 
2178 2b				dec hl 
2179			; PARSEV5 
2179 2b				dec hl 
217a 22 ee e9			ld (cli_data_sp), hl 
217d			 
217d				if DEBUG_FORTH_STACK_GUARD 
217d cd 6d 64				call check_stacks 
2180					FORTH_CHK_DSP_UNDER 
2180 e5				push hl 
2181 d5				push de 
2182 2a ee e9			ld hl,(cli_data_sp) 
2185 11 28 e8			ld de, cli_data_stack 
2188 cd 04 0e			call cmp16 
218b da 7b 65			jp c, fault_dsp_under 
218e d1				pop de 
218f e1				pop hl 
2190				endm 
# End of macro FORTH_CHK_DSP_UNDER
2190				endif 
2190			 
2190 e1				pop hl 
2191			 
2191 c9				ret 
2192			 
2192			getwordathl: 
2192				; hl points to an address 
2192				; load hl with the word at that address 
2192			 
2192 d5				push de 
2193			 
2193 5e				ld e, (hl) 
2194 23				inc hl 
2195 56				ld d, (hl) 
2196 eb				ex de, hl 
2197			 
2197 d1				pop de 
2198 c9				ret 
2199			 
2199			 
2199			 
2199			 
2199			 
2199			; eof 
2199			 
# End of file forth_stackopsv5.asm
2199			endif 
2199			 
2199			loadwordinhl:	 
2199			 
2199 d5				push de 
219a			 
219a 5e				ld e, (hl) 
219b 23				inc hl 
219c 56				ld d, (hl) 
219d eb				ex de,hl  
219e			 
219e d1				pop de 
219f			 
219f c9				ret 
21a0			 
21a0			user_word_eol:  
21a0				; hl contains the pointer to where to create a linked list item from the end 
21a0				; of the user dict to continue on at the system word dict 
21a0				 
21a0				; poke the stub of the word list linked list to repoint to rom words 
21a0			 
21a0				; stub format 
21a0				; db   word id 
21a0				; dw    link to next word 
21a0			        ; db char length of token 
21a0				; db string + 0 term 
21a0				; db exec code....  
21a0			 
21a0 3e 00			ld a, WORD_SYS_ROOT     ; root word 
21a2 77				ld (hl), a		; word id 
21a3 23				inc hl 
21a4			 
21a4 11 6f 23			ld de, sysdict 
21a7 73				ld (hl), e		; next word link ie system dict 
21a8 23				inc hl 
21a9 72				ld (hl), d		; next word link ie system dict 
21aa 23				inc hl	 
21ab			 
21ab			;	ld (hl), sysdict		; next word link ie system dict 
21ab			;	inc hl 
21ab			;	inc hl 
21ab			 
21ab			;	inc hl 
21ab			;	inc hl 
21ab			 
21ab 3e 02			ld a, 2			; word length is 0 
21ad 77				ld (hl), a	 
21ae 23				inc hl 
21af			 
21af 3e 7e			ld a, '~'			; word length is 0 
21b1 77				ld (hl), a	 
21b2 23				inc hl 
21b3 3e 00			ld a, 0			; save empty word 
21b5 77				ld (hl), a 
21b6			 
21b6 c9				ret 
21b7			 
21b7				 
21b7			 
21b7			forthexec_cleanup: 
21b7				FORTH_RSP_POP 
21b7 cd 32 1e			call macro_forth_rsp_pop 
21ba				endm 
# End of macro FORTH_RSP_POP
21ba c9				ret 
21bb			 
21bb			forth_call_hl: 
21bb				; taking hl 
21bb e5				push hl 
21bc c9				ret 
21bd			 
21bd			; this is called to reset Forth system but keep existing uwords etc 
21bd			 
21bd			forth_warmstart: 
21bd				; setup stack over/under flow checks 
21bd				if DEBUG_FORTH_STACK_GUARD 
21bd cd 53 64				call chk_stk_init 
21c0				endif 
21c0			 
21c0				; init stack pointers  - * these stacks go upwards *  
21c0 21 ac e9			ld hl, cli_ret_stack 
21c3 22 f2 e9			ld (cli_ret_sp), hl	 
21c6				; set bottom of stack 
21c6 3e 00			ld a,0 
21c8 77				ld (hl),a 
21c9 23				inc hl 
21ca 77				ld (hl),a 
21cb			 
21cb 21 28 e8			ld hl, cli_data_stack 
21ce 22 ee e9			ld (cli_data_sp), hl	 
21d1				; set bottom of stack 
21d1 3e 00			ld a,0 
21d3 77				ld (hl),a 
21d4 23				inc hl 
21d5 77				ld (hl),a 
21d6			 
21d6 21 2a e9			ld hl, cli_loop_stack 
21d9 22 f0 e9			ld (cli_loop_sp), hl	 
21dc				; set bottom of stack 
21dc 3e 00			ld a,0 
21de 77				ld (hl),a 
21df 23				inc hl 
21e0 77				ld (hl),a 
21e1			 
21e1				; init extent of current open file 
21e1			 
21e1 3e 00			ld a, 0 
21e3 32 6a ea			ld (store_openext), a 
21e6			 
21e6 c9				ret 
21e7			 
21e7			 
21e7			 
21e7			; Cold Start - this is called to setup the whole Forth system 
21e7			 
21e7			forth_init: 
21e7			 
21e7				; setup stack over/under flow checks 
21e7			 
21e7			;	if DEBUG_FORTH_STACK_GUARD 
21e7			;		call chk_stk_init 
21e7			;	endif 
21e7			 
21e7				; enable auto display updates (slow.....) 
21e7			 
21e7 3e 01			ld a, 1 
21e9 32 3c ea			ld (cli_autodisplay), a 
21ec			 
21ec				; if storage is in use disable long reads for now 
21ec 3e 00			ld a, 0 
21ee 32 75 ea			ld (store_longread), a 
21f1			 
21f1			 
21f1				; show start up screen 
21f1			 
21f1 cd b9 0b			call clear_display 
21f4			 
21f4 3e 00			ld a,0 
21f6 32 5e ea			ld (f_cursor_ptr), a 
21f9			 
21f9				; set start of word list in start of ram - for use when creating user words 
21f9			 
21f9 21 5f 68			ld hl, baseram 
21fc 22 be e5			ld (os_last_new_uword), hl 
21ff cd a0 21			call user_word_eol 
2202				 
2202			;		call display_data_sp 
2202			;		call next_page_prompt 
2202			 
2202			 
2202			 
2202			 
2202 c9				ret 
2203			 
2203 .. 00		.bootforth: db " Forth Kernel Init ",0 
2217			 
2217			; TODO push to stack 
2217			 
2217			;  
2217			 
2217			if FORTH_PARSEV2 
2217			 
2217			 
2217				include "forth_parserv2.asm" 
2217			 
2217			endif 
2217			 
2217			 
2217			; parse cli version 1 
2217			 
2217			if FORTH_PARSEV1 
2217			 
2217			 
2217			 
2217			      include "forth_parserv1.asm" 
2217			endif 
2217				 
2217			if FORTH_PARSEV3 
2217			 
2217			 
2217			 
2217			      include "forth_parserv3.asm" 
2217				include "forth_wordsv3.asm" 
2217			endif 
2217			 
2217			if FORTH_PARSEV4 
2217			 
2217			 
2217			 
2217			      include "forth_parserv4.asm" 
2217				include "forth_wordsv4.asm" 
2217			endif 
2217			 
2217			if FORTH_PARSEV5 
2217			 
2217			 
2217			 
2217			      include "forth_parserv5.asm" 
2217			 
2217			 
2217			; A better parser without using malloc and string copies all over the place.  
2217			; Exec in situ should be faster 
2217			 
2217			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2217			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2217			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2217			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2217			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2217			WORD_SYS_END: equ 0   ; Opcode for all user words 
2217			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2217			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2217			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2217			 
2217			; Core word preamble macro 
2217			 
2217			CWHEAD:   macro nxtword opcode lit len opflags 
2217				db WORD_SYS_CORE+opcode             
2217				; internal op code number 
2217				dw nxtword            
2217				; link to next dict word block 
2217				db len + 1 
2217				; literal length of dict word inc zero term 
2217				db lit,0              
2217				; literal dict word 
2217			        ; TODO db opflags        
2217				endm 
2217			 
2217			 
2217			NEXTW: macro  
2217				jp macro_next 
2217				endm 
2217			 
2217			macro_next: 
2217			if DEBUG_FORTH_PARSE_KEY 
2217				DMARK "NXT" 
2217				CALLMONITOR 
2217			endif	 
2217			;	inc hl  ; skip token null term  
2217 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
221b ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
221f 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2222			if DEBUG_FORTH_PARSE_KEY 
2222				DMARK "}AA" 
2222				CALLMONITOR 
2222			endif	 
2222 c3 25 23			jp execnext 
2225				;jp exec1 
2225			       
2225			 
2225			 
2225			; Another go at the parser to compile  
2225			 
2225			 
2225			; TODO rework parser to change all of the string words to byte tokens 
2225			; TODO do a search for  
2225			 
2225			; TODO first run normal parser to zero term sections 
2225			; TODO for each word do a token look up to get the op code 
2225			; TODO need some means to flag to the exec that this is a byte code form    
2225			 
2225			 
2225			forthcompile: 
2225			 
2225			; 
2225			; line parse: 
2225			;       parse raw input buffer 
2225			;       tokenise the words 
2225			;       malloc new copy (for looping etc) 
2225			;       copy to malloc + current pc in line to start of string and add line term 
2225			;       save on new rsp 
2225			; 
2225			 
2225			; hl to point to the line to tokenise 
2225			 
2225			;	push hl 
2225 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2228			 
2228			;	ld a,0		; string term on input 
2228			;	call strlent 
2228			 
2228			;	ld (os_tok_len), hl	 ; save string length 
2228			 
2228			;if DEBUG_FORTH_TOK 
2228			;	ex de,hl		 
2228			;endif 
2228			 
2228			;	pop hl 		; get back string pointer 
2228			 
2228			if DEBUG_FORTH_TOK 
2228						DMARK "TOc" 
2228				CALLMONITOR 
2228			endif 
2228 7e			.cptoken2:    ld a,(hl) 
2229 23				inc hl 
222a fe 7f			cp FORTH_END_BUFFER 
222c 28 29			jr z, .cptokendone2 
222e fe 00			cp 0 
2230 28 25			jr z, .cptokendone2 
2232 fe 22			cp '"' 
2234 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2236 fe 20			cp ' ' 
2238 20 ee			jr nz,  .cptoken2 
223a			 
223a			; TODO consume comments held between ( and ) 
223a			 
223a				; we have a space so change to zero term for dict match later 
223a 2b				dec hl 
223b 3e 00			ld a,0 
223d 77				ld (hl), a 
223e 23				inc hl 
223f 18 e7			jr .cptoken2 
2241				 
2241			 
2241			.cptokenstr2: 
2241				; skip all white space until either eol (because forgot to term) or end double quote 
2241			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2241				;inc hl ; skip current double quote 
2241 7e				ld a,(hl) 
2242 23				inc hl 
2243 fe 22			cp '"' 
2245 28 e1			jr z, .cptoken2 
2247 fe 7f			cp FORTH_END_BUFFER 
2249 28 0c			jr z, .cptokendone2 
224b fe 00			cp 0 
224d 28 08			jr z, .cptokendone2 
224f fe 20			cp ' ' 
2251 28 02			jr z, .cptmp2 
2253 18 ec			jr .cptokenstr2 
2255			 
2255			.cptmp2:	; we have a space so change to zero term for dict match later 
2255				;dec hl 
2255				;ld a,"-"	; TODO remove this when working 
2255				;ld (hl), a 
2255				;inc hl 
2255 18 ea			jr .cptokenstr2 
2257			 
2257			.cptokendone2: 
2257				;inc hl 
2257 3e 7f			ld a, FORTH_END_BUFFER 
2259 77				ld (hl),a 
225a 23				inc hl 
225b 3e 21			ld a, '!' 
225d 77				ld (hl),a 
225e			 
225e 2a c2 e5			ld hl,(os_tok_ptr) 
2261			         
2261			if DEBUG_FORTH_TOK 
2261						DMARK "Tc1" 
2261				CALLMONITOR 
2261			endif 
2261			 
2261				; push exec string to top of return stack 
2261				FORTH_RSP_NEXT 
2261 cd 11 1e			call macro_forth_rsp_next 
2264				endm 
# End of macro FORTH_RSP_NEXT
2264 c9				ret 
2265			 
2265			; Another go at the parser need to simplify the process 
2265			 
2265			forthparse: 
2265			 
2265			; 
2265			; line parse: 
2265			;       parse raw input buffer 
2265			;       tokenise the words 
2265			;       malloc new copy (for looping etc) 
2265			;       copy to malloc + current pc in line to start of string and add line term 
2265			;       save on new rsp 
2265			; 
2265			 
2265			; hl to point to the line to tokenise 
2265			 
2265			;	push hl 
2265 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2268			 
2268			;	ld a,0		; string term on input 
2268			;	call strlent 
2268			 
2268			;	ld (os_tok_len), hl	 ; save string length 
2268			 
2268			;if DEBUG_FORTH_TOK 
2268			;	ex de,hl		 
2268			;endif 
2268			 
2268			;	pop hl 		; get back string pointer 
2268			 
2268			if DEBUG_FORTH_TOK 
2268						DMARK "TOK" 
2268				CALLMONITOR 
2268			endif 
2268 7e			.ptoken2:    ld a,(hl) 
2269 23				inc hl 
226a fe 7f			cp FORTH_END_BUFFER 
226c 28 29			jr z, .ptokendone2 
226e fe 00			cp 0 
2270 28 25			jr z, .ptokendone2 
2272 fe 22			cp '"' 
2274 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2276 fe 20			cp ' ' 
2278 20 ee			jr nz,  .ptoken2 
227a			 
227a			; TODO consume comments held between ( and ) 
227a			 
227a				; we have a space so change to zero term for dict match later 
227a 2b				dec hl 
227b 3e 00			ld a,0 
227d 77				ld (hl), a 
227e 23				inc hl 
227f 18 e7			jr .ptoken2 
2281				 
2281			 
2281			.ptokenstr2: 
2281				; skip all white space until either eol (because forgot to term) or end double quote 
2281			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2281				;inc hl ; skip current double quote 
2281 7e				ld a,(hl) 
2282 23				inc hl 
2283 fe 22			cp '"' 
2285 28 e1			jr z, .ptoken2 
2287 fe 7f			cp FORTH_END_BUFFER 
2289 28 0c			jr z, .ptokendone2 
228b fe 00			cp 0 
228d 28 08			jr z, .ptokendone2 
228f fe 20			cp ' ' 
2291 28 02			jr z, .ptmp2 
2293 18 ec			jr .ptokenstr2 
2295			 
2295			.ptmp2:	; we have a space so change to zero term for dict match later 
2295				;dec hl 
2295				;ld a,"-"	; TODO remove this when working 
2295				;ld (hl), a 
2295				;inc hl 
2295 18 ea			jr .ptokenstr2 
2297			 
2297			.ptokendone2: 
2297				;inc hl 
2297 3e 7f			ld a, FORTH_END_BUFFER 
2299 77				ld (hl),a 
229a 23				inc hl 
229b 3e 21			ld a, '!' 
229d 77				ld (hl),a 
229e			 
229e 2a c2 e5			ld hl,(os_tok_ptr) 
22a1			         
22a1			if DEBUG_FORTH_TOK 
22a1						DMARK "TK1" 
22a1				CALLMONITOR 
22a1			endif 
22a1			 
22a1				; push exec string to top of return stack 
22a1				FORTH_RSP_NEXT 
22a1 cd 11 1e			call macro_forth_rsp_next 
22a4				endm 
# End of macro FORTH_RSP_NEXT
22a4 c9				ret 
22a5			 
22a5			; 
22a5			;	; malloc size + buffer pointer + if is loop flag 
22a5			;	ld hl,(os_tok_len) 		 ; get string length 
22a5			; 
22a5			;	ld a,l 
22a5			; 
22a5			;	cp 0			; we dont want to use a null string 
22a5			;	ret z 
22a5			; 
22a5			;;	add 3    ; prefix malloc with buffer for current word ptr 
22a5			; 
22a5			;	add 5     ; TODO when certain not over writing memory remove 
22a5			; 
22a5			;		 
22a5			; 
22a5			;if DEBUG_FORTH_TOK 
22a5			;			DMARK "TKE" 
22a5			;	CALLMONITOR 
22a5			;endif 
22a5			; 
22a5			;	ld l,a 
22a5			;	ld h,0 
22a5			;;	push hl   ; save required space for the copy later 
22a5			;	call malloc 
22a5			;if DEBUG_FORTH_TOK 
22a5			;			DMARK "TKM" 
22a5			;	CALLMONITOR 
22a5			;endif 
22a5			;	if DEBUG_FORTH_MALLOC_GUARD 
22a5			;		push af 
22a5			;		call ishlzero 
22a5			;;		ld a, l 
22a5			;;		add h 
22a5			;;		cp 0 
22a5			;		pop af 
22a5			;		 
22a5			;		call z,malloc_error 
22a5			;	endif 
22a5			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
22a5			; 
22a5			; 
22a5			;if DEBUG_FORTH_TOK 
22a5			;			DMARK "TKR" 
22a5			;	CALLMONITOR 
22a5			;endif 
22a5			; 
22a5			;	FORTH_RSP_NEXT 
22a5			; 
22a5			;	;inc hl	 ; go past current buffer pointer 
22a5			;	;inc hl 
22a5			;	;inc hl   ; and past if loop flag 
22a5			;		; TODO Need to set flag  
22a5			; 
22a5			;	 
22a5			;	 
22a5			;	ex de,hl	; malloc is dest 
22a5			;	ld hl, (os_tok_len) 
22a5			;;	pop bc 
22a5			;	ld c, l                
22a5			;	ld b,0 
22a5			;	ld hl, (os_tok_ptr) 
22a5			; 
22a5			;if DEBUG_FORTH_TOK 
22a5			;			DMARK "TKT" 
22a5			;	CALLMONITOR 
22a5			;endif 
22a5			; 
22a5			;	; do str cpy 
22a5			; 
22a5			;	ldir      ; copy byte in hl to de 
22a5			; 
22a5			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
22a5			; 
22a5			;if DEBUG_FORTH_TOK 
22a5			; 
22a5			;			DMARK "TKY" 
22a5			;	CALLMONITOR 
22a5			;endif 
22a5			;	;ld a,0 
22a5			;	;ld a,FORTH_END_BUFFER 
22a5			;	ex de, hl 
22a5			;	;dec hl			 ; go back over the space delim at the end of word 
22a5			;	;ld (hl),a 
22a5			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
22a5			;	ld a,FORTH_END_BUFFER 
22a5			;	ld (hl),a 
22a5			;	inc hl 
22a5			;	ld a,FORTH_END_BUFFER 
22a5			;	ld (hl),a 
22a5			; 
22a5			;	; init the malloc area data 
22a5			;	; set pc for in current area 
22a5			;	;ld hl, (os_tok_malloc) 
22a5			;	;inc hl 
22a5			;	;inc hl 
22a5			;	;inc hl 
22a5			;	;ex de,hl 
22a5			;	;ld hl, (os_tok_malloc) 
22a5			;	;ld (hl),e 
22a5			;	;inc hl 
22a5			;	;ld (hl),d 
22a5			; 
22a5			; 
22a5			;	ld hl,(os_tok_malloc) 
22a5			;if DEBUG_FORTH_PARSE_KEY 
22a5			;			DMARK "TKU" 
22a5			;	CALLMONITOR 
22a5			;endif 
22a5			; 
22a5			;	ret 
22a5			 
22a5			forthexec: 
22a5			 
22a5			; line exec: 
22a5			; forth parser 
22a5			 
22a5			; 
22a5			;       get current exec line on rsp 
22a5			 
22a5				FORTH_RSP_TOS 
22a5 cd 28 1e			call macro_forth_rsp_tos 
22a8				endm 
# End of macro FORTH_RSP_TOS
22a8			 
22a8			;       restore current pc - hl points to malloc of data 
22a8			 
22a8				;ld e, (hl) 
22a8				;inc hl 
22a8				;ld d, (hl) 
22a8				;ex de,hl 
22a8			 
22a8			 
22a8			exec1: 
22a8 22 c2 e5			ld (os_tok_ptr), hl 
22ab			 
22ab				; copy our PC to working vars  
22ab 22 40 ea			ld (cli_ptr), hl 
22ae 22 3e ea			ld (cli_origptr), hl 
22b1			 
22b1 7e				ld a,(hl) 
22b2 fe 7f			cp FORTH_END_BUFFER 
22b4 c8				ret z 
22b5			 
22b5				; skip any nulls 
22b5			 
22b5 fe 00			cp 0 
22b7 20 03			jr nz, .execword 
22b9 23				inc hl 
22ba 18 ec			jr exec1 
22bc			 
22bc			 
22bc			.execword: 
22bc			 
22bc			 
22bc			 
22bc			if DEBUG_FORTH_PARSE_KEY 
22bc						DMARK "KYQ" 
22bc				CALLMONITOR 
22bc			endif 
22bc			;       while at start of word: 
22bc			; get start of dict (in user area first) 
22bc			 
22bc 21 5f 68		ld hl, baseram 
22bf			;ld hl, sysdict 
22bf 22 42 ea		ld (cli_nextword),hl 
22c2			;           match word at pc 
22c2			;           exec word 
22c2			;           or push to dsp 
22c2			;           forward to next token 
22c2			;           if line term pop rsp and exit 
22c2			;        
22c2			 
22c2			if DEBUG_FORTH_PARSE_KEY 
22c2						DMARK "KYq" 
22c2				CALLMONITOR 
22c2			endif 
22c2			 
22c2			; 
22c2			; word comp 
22c2			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
22c2			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
22c2			;    move to start of word  
22c2			;    compare word to cli_token 
22c2			 
22c2			.execpnword:	; HL at start of a word in the dictionary to check 
22c2			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
22c2			;	ld (cli_ptr), hl 
22c2			 
22c2 2a 42 ea			ld hl,(cli_nextword) 
22c5			 
22c5 cd 68 23			call forth_tok_next 
22c8			; tok next start here 
22c8			;	; TODO skip compiled symbol for now 
22c8			;	inc hl 
22c8			; 
22c8			;	; save pointer to next word 
22c8			; 
22c8			;	; hl now points to the address of the next word pointer  
22c8			;	ld e, (hl) 
22c8			;	inc hl 
22c8			;	ld d, (hl) 
22c8			;	inc l 
22c8			; 
22c8			;	ex de,hl 
22c8			;if DEBUG_FORTH_PARSE_NEXTWORD 
22c8			;	push bc 
22c8			;	ld bc, (cli_nextword) 
22c8			;			DMARK "NXW" 
22c8			;	CALLMONITOR 
22c8			;	pop bc 
22c8			;endif 
22c8			; tok next end here 
22c8 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
22cb eb				ex de, hl 
22cc			 
22cc			 
22cc				; save the pointer of the current token - 1 to check against 
22cc				 
22cc 22 46 ea			ld (cli_token), hl   
22cf				; TODO maybe remove below save if no debug 
22cf				; save token string ptr for any debug later 
22cf 23				inc hl  
22d0 22 48 ea			ld (cli_origtoken), hl 
22d3 2b				dec hl 
22d4				; save pointer to the start of the next dictionay word 
22d4 7e				ld a,(hl)   ; get string length 
22d5 47				ld b,a 
22d6			.execpnwordinc:  
22d6 23				inc hl 
22d7 10 fd			djnz .execpnwordinc 
22d9 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
22dc			 
22dc				; now check the word token against the string being parsed 
22dc			 
22dc 2a 46 ea			ld hl,(cli_token) 
22df 23				inc hl     ; skip string length (use zero term instead to end) 
22e0 22 46 ea			ld (cli_token), hl 
22e3			 
22e3			if DEBUG_FORTH_PARSE_KEY 
22e3						DMARK "KY2" 
22e3			endif 
22e3			if DEBUG_FORTH_PARSE_EXEC 
22e3				; see if disabled 
22e3			 
22e3			;	ld a, (os_view_disable) 
22e3			;	cp '*' 
22e3				ld a, (debug_vector) 
22e3				cp $c9   ; RET  
22e3				jr z, .skip 
22e3			 
22e3				push hl 
22e3				push hl 
22e3				call clear_display 
22e3				ld de, .compword 
22e3				ld a, display_row_1 
22e3				call str_at_display 
22e3				pop de 
22e3				ld a, display_row_2 
22e3				call str_at_display 
22e3				ld hl,(cli_ptr) 
22e3				ld a,(hl) 
22e3			        ld hl, os_word_scratch 
22e3				ld (hl),a 
22e3				ld a,0 
22e3				inc hl 
22e3				ld (hl),a 	 
22e3				ld de, os_word_scratch 
22e3				ld a, display_row_2+10 
22e3				call str_at_display 
22e3				call update_display 
22e3				ld a, 100 
22e3				call aDelayInMS 
22e3				if DEBUG_FORTH_PARSE_EXEC_SLOW 
22e3				call delay250ms 
22e3				endif 
22e3				pop hl 
22e3			.skip:  
22e3			endif	 
22e3			.execpnchar:    ; compare char between token and string to parse 
22e3			 
22e3			if DEBUG_FORTH_PARSE_KEY 
22e3						DMARK "Ky3" 
22e3			endif 
22e3			if DEBUG_FORTH_PARSE_EXEC 
22e3				; see if disabled 
22e3			 
22e3			;	ld a, (os_view_disable) 
22e3			;	cp '*' 
22e3				ld a, (debug_vector) 
22e3				cp $C9  ; RET 
22e3				jr z, .skip2 
22e3			 
22e3			;	call clear_display 
22e3			ld hl,(cli_token) 
22e3			ld a,(hl) 
22e3			ld (os_word_scratch),a 
22e3				ld hl,(cli_ptr) 
22e3			ld a,(hl) 
22e3				ld (os_word_scratch+1),a 
22e3				ld a,0 
22e3				ld (os_word_scratch+2),a 
22e3				ld de,os_word_scratch 
22e3				ld a,display_row_4 
22e3				call str_at_display 
22e3				call update_display 
22e3			.skip2:  
22e3			endif 
22e3 2a 46 ea			ld hl,(cli_token) 
22e6 7e				ld a, (hl)	 ; char in word token 
22e7 23				inc hl 		; move to next char 
22e8 22 46 ea			ld (cli_token), hl ; and save it 
22eb 47				ld b,a 
22ec			 
22ec 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
22ef 7e				ld a,(hl) 
22f0 23				inc hl 
22f1 22 40 ea			ld (cli_ptr), hl		; move to next char 
22f4 cd 53 14			call toUpper 		; make sure the input string matches case 
22f7			 
22f7			if DEBUG_FORTH_PARSE 
22f7			endif 
22f7			 
22f7				; input stream end of token is a space so get rid of it 
22f7			 
22f7			;	cp ' ' 
22f7			;	jr nz, .pnskipspace 
22f7			; 
22f7			;	ld a, 0		; make same term as word token term 
22f7			; 
22f7			;.pnskipspace: 
22f7			 
22f7			if DEBUG_FORTH_PARSE_KEY 
22f7						DMARK "KY7" 
22f7			endif 
22f7 b8				cp b 
22f8 c2 0e 23			jp nz, .execpnskipword	 ; no match so move to next word 
22fb				 
22fb			;    if same 
22fb			;       scan for string terms 0 for token and 32 for input 
22fb			 
22fb				 
22fb			if DEBUG_FORTH_PARSE_KEY 
22fb						DMARK "KY8" 
22fb			endif 
22fb			 
22fb 80				add b			 
22fc fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
22fe							; TODO need to make sure last word in zero term string is accounted for 
22fe 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2300			 
2300			 
2300				; at end of both strings so both are exact match 
2300			 
2300			;       skip ptr for next word 
2300			 
2300 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
2303 23				inc hl			 ; at next char 
2304 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
2307 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
230a				 
230a				 
230a			if DEBUG_FORTH_PARSE_KEY 
230a						DMARK "KY3" 
230a			endif 
230a			 
230a			 
230a			 
230a			;       exec code block 
230a			if DEBUG_FORTH_JP 
230a				call clear_display 
230a				call update_display 
230a				call delay1s 
230a				ld hl, (cli_execword)     ; save for next check if no match on this word 
230a				ld a,h 
230a				ld hl, os_word_scratch 
230a				call hexout 
230a				ld hl, (cli_execword)     ; save for next check if no match on this word 
230a				ld a,l 
230a				ld hl, os_word_scratch+2 
230a				call hexout 
230a				ld hl, os_word_scratch+4 
230a				ld a,0 
230a				ld (hl),a 
230a				ld de,os_word_scratch 
230a				call str_at_display 
230a					ld a, display_row_2 
230a					call str_at_display 
230a				ld de, (cli_origtoken) 
230a				ld a, display_row_1+10 
230a					call str_at_display 
230a			 
230a				ld a,display_row_1 
230a				ld de, .foundword 
230a				ld a, display_row_3 
230a				call str_at_display 
230a				call update_display 
230a				call delay1s 
230a				call delay1s 
230a				call delay1s 
230a			endif 
230a			 
230a			if DEBUG_FORTH_PARSE_KEY 
230a						DMARK "KYj" 
230a			endif 
230a				; TODO save the word pointer in this exec 
230a			 
230a 2a 44 ea			ld hl,(cli_execword) 
230d e9				jp (hl) 
230e			 
230e			 
230e			;    if not same 
230e			;	scan for zero term 
230e			;	get ptr for next word 
230e			;	goto word comp 
230e			 
230e			.execpnskipword:	; get pointer to next word 
230e 2a 42 ea			ld hl,(cli_nextword) 
2311			 
2311 7e				ld a,(hl) 
2312 fe 00			cp WORD_SYS_END 
2314			;	cp 0 
2314 28 09			jr z, .execendofdict			 ; at end of words 
2316			 
2316			if DEBUG_FORTH_PARSE_KEY 
2316						DMARK "KY4" 
2316			endif 
2316			if DEBUG_FORTH_PARSE_EXEC 
2316			 
2316				; see if disabled 
2316			 
2316			;	ld a, (os_view_disable) 
2316			;	cp '*' 
2316				ld a,(debug_vector) 
2316				cp $c9   ; RET 
2316				jr z, .noskip 
2316			 
2316			 
2316				ld de, .nowordfound 
2316				ld a, display_row_3 
2316				call str_at_display 
2316				call update_display 
2316				ld a, 100 
2316				call aDelayInMS 
2316				 
2316				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2316					call delay250ms 
2316				endif 
2316			.noskip:  
2316			 
2316			endif	 
2316			 
2316 2a 3e ea			ld hl,(cli_origptr) 
2319 22 40 ea			ld (cli_ptr),hl 
231c			 
231c			if DEBUG_FORTH_PARSE_KEY 
231c						DMARK "KY5" 
231c			endif 
231c c3 c2 22			jp .execpnword			; else go to next word 
231f			 
231f			.execendofdict:  
231f			 
231f			if DEBUG_FORTH_PARSE_KEY 
231f						DMARK "KYe" 
231f			endif 
231f			if DEBUG_FORTH_PARSE_EXEC 
231f				; see if disabled 
231f			 
231f			;	ld a, (os_view_disable) 
231f			;	cp '*' 
231f				ld a,(debug_vector) 
231f				cp $c9   ; ret 
231f				jr z, .ispskip 
231f			 
231f				call clear_display 
231f				call update_display 
231f				call delay1s 
231f				ld de, (cli_origptr) 
231f				ld a, display_row_1 
231f				call str_at_display 
231f				 
231f				ld de, .enddict 
231f				ld a, display_row_3 
231f				call str_at_display 
231f				call update_display 
231f				ld a, 100 
231f				call aDelayInMS 
231f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
231f				call delay1s 
231f				call delay1s 
231f				call delay1s 
231f				endif 
231f			.ispskip:  
231f				 
231f			endif	 
231f			 
231f			 
231f			 
231f				; if the word is not a keyword then must be a literal so push it to stack 
231f			 
231f			; push token to stack to end of word 
231f			 
231f				STACKFRAME ON $1efe $2f9f 
231f				if DEBUG_STACK_IMB 
231f					if ON 
231f						exx 
231f						ld de, $1efe 
231f						ld a, d 
231f						ld hl, curframe 
231f						call hexout 
231f						ld a, e 
231f						ld hl, curframe+2 
231f						call hexout 
231f						ld hl, $1efe 
231f						push hl 
231f						ld hl, $2f9f 
231f						push hl 
231f						exx 
231f					endif 
231f				endif 
231f			endm 
# End of macro STACKFRAME
231f			 
231f 2a c2 e5		ld hl,(os_tok_ptr) 
2322 cd d3 1f		call forth_apush 
2325			 
2325				STACKFRAMECHK ON $1efe $2f9f 
2325				if DEBUG_STACK_IMB 
2325					if ON 
2325						exx 
2325						ld hl, $2f9f 
2325						pop de   ; $2f9f 
2325						call cmp16 
2325						jr nz, .spnosame 
2325						ld hl, $1efe 
2325						pop de   ; $1efe 
2325						call cmp16 
2325						jr z, .spfrsame 
2325						.spnosame: call showsperror 
2325						.spfrsame: nop 
2325						exx 
2325					endif 
2325				endif 
2325			endm 
# End of macro STACKFRAMECHK
2325			 
2325			execnext: 
2325			 
2325			if DEBUG_FORTH_PARSE_KEY 
2325						DMARK "KY>" 
2325			endif 
2325			; move past token to next word 
2325			 
2325 2a c2 e5		ld hl, (os_tok_ptr) 
2328 3e 00		ld a, 0 
232a 01 ff 00		ld bc, 255     ; input buffer size 
232d ed b1		cpir 
232f			 
232f			if DEBUG_FORTH_PARSE_KEY 
232f						DMARK "KY!" 
232f				CALLMONITOR 
232f			endif	 
232f			; TODO this might place hl on the null, so will need to forward on??? 
232f			;inc hl   ; see if this gets onto the next item 
232f			 
232f			 
232f			; TODO pass a pointer to the buffer to push 
232f			; TODO call function to push 
232f			 
232f			; look for end of input 
232f			 
232f			;inc hl 
232f			;ld a,(hl) 
232f			;cp FORTH_END_BUFFER 
232f			;ret z 
232f			 
232f			 
232f c3 a8 22		jp exec1 
2332			 
2332			 
2332			 
2332			 
2332			 
2332			 
2332			 
2332			 
2332			 
2332			findnexttok: 
2332			 
2332				; hl is pointer to move 
2332				; de is the token to locate 
2332			 
2332					if DEBUG_FORTH 
2332						DMARK "NTK" 
2332						CALLMONITOR 
2332					endif 
2332 d5				push de 
2333			 
2333			.fnt1:	 
2333				; find first char of token to locate 
2333			 
2333 1a				ld a, (de) 
2334 4f				ld c,a 
2335 7e				ld a,(hl) 
2336 cd 53 14			call toUpper 
2339					if DEBUG_FORTH 
2339						DMARK "NT1" 
2339						CALLMONITOR 
2339					endif 
2339 b9				cp c 
233a			 
233a 28 03			jr z, .fnt2cmpmorefirst	 
233c			 
233c				; first char not found move to next char 
233c			 
233c 23				inc hl 
233d 18 f4			jr .fnt1 
233f			 
233f			.fnt2cmpmorefirst:	 
233f				; first char of token found.  
233f			 
233f e5				push hl     ; save start of token just in case it is the right one 
2340 d9				exx 
2341 e1				pop hl        ; save it to hl' 
2342 d9				exx 
2343			 
2343			 
2343			.fnt2cmpmore:	 
2343				; compare the rest 
2343				 
2343 23				inc hl 
2344 13				inc de 
2345				 
2345 1a				ld a, (de) 
2346 4f				ld c,a 
2347 7e				ld a,(hl) 
2348 cd 53 14			call toUpper 
234b			 
234b					if DEBUG_FORTH 
234b						DMARK "NT2" 
234b						CALLMONITOR 
234b					endif 
234b				; c has the token to find char 
234b				; a has the mem to scan char 
234b			 
234b b9				cp c 
234c 28 04			jr z,.fntmatch1 
234e			 
234e				; they are not the same 
234e			 
234e					if DEBUG_FORTH 
234e						DMARK "NT3" 
234e						CALLMONITOR 
234e					endif 
234e d1				pop de	; reset de token to look for 
234f d5				push de 
2350 18 e1			jr .fnt1 
2352				 
2352			.fntmatch1: 
2352			 
2352				; is the same char a null which means we might have a full hit? 
2352					if DEBUG_FORTH 
2352						DMARK "NT4" 
2352						CALLMONITOR 
2352					endif 
2352			 
2352 fe 00			cp 0 
2354 28 0b			jr z, .fntmatchyes 
2356			 
2356				; are we at the end of the token to find? 
2356			 
2356					if DEBUG_FORTH 
2356						DMARK "NT5" 
2356						CALLMONITOR 
2356					endif 
2356 3e 00			ld a, 0 
2358 b9				cp c 
2359			 
2359 c2 43 23			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
235c			 
235c					if DEBUG_FORTH 
235c						DMARK "NT6" 
235c						CALLMONITOR 
235c					endif 
235c				; token to find is exhusted but no match to stream 
235c			 
235c				; restore tok pointer and continue on 
235c d1				pop de 
235d d5				push de 
235e c3 33 23			jp .fnt1 
2361			 
2361			 
2361			.fntmatchyes: 
2361			 
2361				; hl now contains the end of the found token 
2361			 
2361				; get rid of saved token pointer to find 
2361			 
2361 d1				pop de 
2362			 
2362					if DEBUG_FORTH 
2362						DMARK "NT9" 
2362						CALLMONITOR 
2362					endif 
2362			 
2362				; hl will be on the null term so forward on 
2362			 
2362				; get back the saved start of the token 
2362			 
2362 d9				exx 
2363 e5				push hl     ; save start of token just in case it is the right one 
2364 d9				exx 
2365 e1				pop hl        ; save it to hl 
2366			 
2366 c9				ret 
2367			 
2367			 
2367			; LIST needs to find a specific token   
2367			; FORGET needs to find a spefici token 
2367			 
2367			; SAVE needs to find all tokens by flag 
2367			; WORDS just needs to scan through all  by flag 
2367			; UWORDS needs to scan through all by flag 
2367			 
2367			 
2367			; given hl as pointer to start of dict look up string 
2367			; return hl as pointer to start of word block 
2367			; or 0 if not found 
2367			 
2367			forth_find_tok: 
2367 c9				ret 
2368			 
2368			; given hl as pointer to dict structure 
2368			; move to the next dict block structure 
2368			 
2368			forth_tok_next: 
2368				; hl now points to the address of the next word pointer  
2368				; TODO skip compiled symbol for now 
2368			;	push de 
2368 23				inc hl 
2369 5e				ld e, (hl) 
236a 23				inc hl 
236b 56				ld d, (hl) 
236c 23				inc hl 
236d			 
236d eb				ex de,hl 
236e			if DEBUG_FORTH_PARSE_NEXTWORD 
236e				push bc 
236e				ld bc, (cli_nextword) 
236e						DMARK "NXW" 
236e				CALLMONITOR 
236e				pop bc 
236e			endif 
236e			;	pop de	 
236e c9				ret 
236f			 
236f			 
236f			 
236f			; eof 
# End of file forth_parserv5.asm
236f				include "forth_wordsv4.asm" 
236f			 
236f			; the core word dictionary v4 
236f			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
236f			 
236f			; this is a linked list for each of the system words used 
236f			; user defined words will follow the same format but will be in ram 
236f			 
236f			 
236f			; 
236f			; 
236f			; define linked list: 
236f			; 
236f			; 1. compiled byte op code 
236f			; 2. len of text word 
236f			; 3. text word 
236f			; 4. ptr to next dictionary word 
236f			; 5. asm, calls etc for the word 
236f			; 
236f			;  if 1 == 0 then last word in dict  
236f			;   
236f			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
236f			;  
236f			;  
236f			; create basic standard set of words 
236f			; 
236f			;  
236f			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
236f			; 2DUP 2DROP 2SWAP  
236f			; @ C@ - get byte  
236f			; ! C! - store byte 
236f			; 0< true if less than zero 
236f			; 0= true if zero 
236f			; < >  
236f			; = true if same 
236f			; variables 
236f			 
236f			 
236f			; Hardware specific words I may need 
236f			; 
236f			; IN OUT  
236f			; calls to key util functions 
236f			; calls to hardward abstraction stuff 
236f			; easy control of frame buffers and lcd i/o 
236f			; keyboard  
236f			 
236f			 
236f			;DICT: macro 
236f			; op_code, len, word, next 
236f			;    word: 
236f			;    db op_code 
236f			;    ds word zero term 
236f			;    dw next 
236f			;    endm 
236f			 
236f			 
236f			 
236f			 
236f			; op code 1 is a flag for user define words which are to be handled differently 
236f			 
236f			 
236f			; 
236f			; 
236f			;    TODO on entry to a word this should be the expected environment 
236f			;    hl - tos value if number then held, if string this is the ptr 
236f			;    de -  
236f			 
236f			 
236f			; opcode ranges 
236f			; 0 - end of word dict 
236f			; 255 - user define words 
236f			 
236f			sysdict: 
236f			include "forth_opcodes.asm" 
236f			; op codes for forth keywords 
236f			; free to use code 0  
236f				OPCODE_HEAP: equ  1 
236f				OPCODE_EXEC: equ 2 
236f				OPCODE_DUP: equ 3 
236f				OPCODE_SWAP: equ 4 
236f				OPCODE_COLN: equ 5 
236f				OPCODE_SCOLN: equ 6 
236f				OPCODE_DROP: equ 7 
236f				OPCODE_DUP2: equ 8 
236f				OPCODE_DROP2: equ 9 
236f				OPCODE_SWAP2: equ 10 
236f				OPCODE_AT: equ 11 
236f				OPCODE_CAT: equ 12 
236f				OPCODE_BANG: equ 13 
236f				OPCODE_CBANG: equ 14 
236f				OPCODE_SCALL: equ 15 
236f				OPCODE_DEPTH: equ 16 
236f				OPCODE_OVER: equ 17 
236f				OPCODE_PAUSE: equ 18 
236f				OPCODE_PAUSES: equ 19 
236f				OPCODE_ROT: equ 20 
236f			;free to reuse	OPCODE_WORDS: equ 21 
236f			        OPCODE_NOT: equ 21 
236f				OPCODE_UWORDS: equ 22 
236f				OPCODE_BP: equ 23 
236f				OPCODE_MONITOR: equ 24  
236f				OPCODE_MALLOC: equ 25 
236f				OPCODE_FREE: equ 26 
236f				OPCODE_LIST: equ 27 
236f				OPCODE_FORGET: equ 28 
236f				OPCODE_NOP: equ 29 
236f				OPCODE_COMO: equ 30 
236f				OPCODE_COMC: equ 31 
236f			;free to reuse	OPCODE_ENDCORE: equ 32 
236f				OPCODE_AFTERSOUND: equ 33 
236f				OPCODE_GP2: equ 34 
236f				OPCODE_GP3: equ 35 
236f				OPCODE_GP4: equ 36 
236f				OPCODE_SIN: equ 37 
236f				OPCODE_SOUT: equ 38 
236f				OPCODE_SPIO: equ 39 
236f				OPCODE_SPICEH: equ 40 
236f				OPCODE_SPIOb: equ 41 
236f				OPCODE_SPII: equ 42 
236f				OPCODE_SESEL: equ 43 
236f				OPCODE_CARTDEV: equ 44 
236f			; free to reuse	OPCODE_ENDDEVICE: equ 45 
236f				OPCODE_FB: equ 46 
236f				OPCODE_EMIT: equ 47 
236f				OPCODE_DOTH: equ 48 
236f				OPCODE_DOTF: equ 49 
236f				OPCODE_DOT: equ 50 
236f				OPCODE_CLS: equ 51 
236f				OPCODE_DRAW: equ 52 
236f				OPCODE_DUMP: equ 53 
236f				OPCODE_CDUMP: equ 54 
236f				OPCODE_DAT: equ 55 
236f				OPCODE_HOME: equ 56 
236f				OPCODE_SPACE: equ 57 
236f				OPCODE_SPACES: equ 58 
236f				OPCODE_SCROLL: equ 59 
236f				OPCODE_ATQ: equ 60 
236f				OPCODE_AUTODSP: equ 61 
236f				OPCODE_MENU: equ 62 
236f			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
236f				OPCODE_THEN: equ 64 
236f				OPCODE_ELSE: equ 65 
236f				OPCODE_DO: equ 66 
236f				OPCODE_LOOP: equ 67 
236f				OPCODE_I: equ 68 
236f				OPCODE_DLOOP: equ 69  
236f				OPCODE_REPEAT: equ 70  
236f				OPCODE_UNTIL: equ 71 
236f				OPCODE_ENDFLOW: equ 72 
236f				OPCODE_WAITK: equ 73 
236f				OPCODE_ACCEPT: equ 74 
236f				OPCODE_EDIT: equ 75 
236f			;free to reuse	OPCODE_ENDKEY: equ 76 
236f				OPCODE_LZERO: equ 77 
236f				OPCODE_TZERO: equ 78 
236f				OPCODE_LESS: equ 79 
236f				OPCODE_GT: equ 80 
236f				OPCODE_EQUAL: equ 81  
236f			;free to reuse	OPCODE_ENDLOGIC: equ 82 
236f				OPCODE_NEG: equ 83 
236f				OPCODE_DIV: equ 84 
236f				OPCODE_MUL: equ 85 
236f				OPCODE_MIN: equ 86 
236f				OPCODE_MAX: equ 87 
236f				OPCODE_RND16: equ 88 
236f				OPCODE_RND8: equ 89 
236f				OPCODE_RND: equ 90 
236f			;free to reuse	OPCODE_ENDMATHS: equ 91  
236f				OPCODE_BYNAME: equ 92 
236f				OPCODE_DIR: equ 93 
236f				OPCODE_SAVE: equ 94 
236f				OPCODE_LOAD: equ 95 
236f				OPCODE_BSAVE: equ 96 
236f				OPCODE_BLOAD: equ 97 
236f				OPCODE_SEO: equ 98  
236f				OPCODE_SEI: equ 99 
236f				OPCODE_SFREE: equ 100 
236f				OPCODE_SIZE: equ 101 
236f				OPCODE_CREATE: equ 102 
236f				OPCODE_APPEND: equ 103 
236f				OPCODE_SDEL: equ 104 
236f				OPCODE_OPEN: equ 105 
236f				OPCODE_READ: equ 106 
236f				OPCODE_EOF: equ 106 
236f				OPCODE_FORMAT: equ 107 
236f				OPCODE_LABEL: equ 108 
236f				OPCODE_LABELS: equ 109 
236f			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
236f				OPCODE_UPPER: equ 111 
236f				OPCODE_LOWER: equ 112 
236f				OPCODE_SUBSTR: equ 113 
236f				OPCODE_LEFT: equ 114 
236f				OPCODE_RIGHT: equ 115 
236f				OPCODE_STR2NUM: equ 116 
236f				OPCODE_NUM2STR: equ 117 
236f				OPCODE_CONCAT: equ 118 
236f				OPCODE_FIND: equ 119 
236f				OPCODE_LEN: equ 120 
236f				OPCODE_CHAR: equ 121 
236f			; free to reuse	OPCODE_STRLEN: equ 122 
236f			; free to reuse	OPCODE_ENDSTR: equ 123 
236f				OPCODE_V0S: equ 124 
236f				OPCODE_V0Q: equ 125 
236f				OPCODE_V1S: equ 126 
236f				OPCODE_V1Q: equ 127 
236f				OPCODE_V2S: equ 128 
236f				OPCODE_V2Q: equ 129 
236f				OPCODE_V3S: equ 130 
236f				OPCODE_V3Q: equ 131 
236f			;free to reuse	OPCODE_END: equ 132 
236f				OPCODE_ZDUP: equ 133 
236f			 
236f			; eof 
# End of file forth_opcodes.asm
236f			 
236f			include "forth_words_core.asm" 
236f			 
236f			; | ## Core Words 
236f			 
236f			;if MALLOC_4 
236f			 
236f			.HEAP: 
236f			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
236f 15				db WORD_SYS_CORE+OPCODE_HEAP             
2370 ae 23			dw .EXEC            
2372 05				db 4 + 1 
2373 .. 00			db "HEAP",0              
2378				endm 
# End of macro CWHEAD
2378			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2378			; | | u1 - Current number of bytes in the heap 
2378			; | | u2 - Remaining bytes left on the heap 
2378			; | |  
2378			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2378			 
2378			 
2378				if DEBUG_FORTH_WORDS_KEY 
2378					DMARK "HEP" 
2378 f5				push af  
2379 3a 8d 23			ld a, (.dmark)  
237c 32 6b ee			ld (debug_mark),a  
237f 3a 8e 23			ld a, (.dmark+1)  
2382 32 6c ee			ld (debug_mark+1),a  
2385 3a 8f 23			ld a, (.dmark+2)  
2388 32 6d ee			ld (debug_mark+2),a  
238b 18 03			jr .pastdmark  
238d ..			.dmark: db "HEP"  
2390 f1			.pastdmark: pop af  
2391			endm  
# End of macro DMARK
2391					CALLMONITOR 
2391 cd 6f ee			call debug_vector  
2394				endm  
# End of macro CALLMONITOR
2394				endif 
2394 2a 69 68			ld hl, (free_list )      
2397 11 6e 68			ld de, heap_start 
239a			 
239a ed 52			sbc hl, de  
239c			 
239c cd 6a 1e			call forth_push_numhl 
239f			 
239f			 
239f ed 5b 69 68		ld de, (free_list )      
23a3 21 9c e2			ld hl, heap_end 
23a6			 
23a6 ed 52			sbc hl, de 
23a8			 
23a8 cd 6a 1e			call forth_push_numhl 
23ab				 
23ab			 
23ab				 
23ab			 
23ab			 
23ab			 
23ab				NEXTW 
23ab c3 17 22			jp macro_next 
23ae				endm 
# End of macro NEXTW
23ae			;endif 
23ae			 
23ae			.EXEC: 
23ae			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
23ae			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
23ae			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
23ae			;; > > 
23ae			;; > >   
23ae			;	STACKFRAME OFF $5efe $5f9f 
23ae			; 
23ae			;		if DEBUG_FORTH_WORDS_KEY 
23ae			;			DMARK "EXE" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			; 
23ae			;	FORTH_DSP_VALUEHL 
23ae			; 
23ae			;	FORTH_DSP_POP 
23ae			; 
23ae			;		if DEBUG_FORTH_WORDS 
23ae			;			DMARK "EX1" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			;;	ld e,(hl) 
23ae			;;	inc hl 
23ae			;;	ld d,(hl) 
23ae			;;	ex de,hl 
23ae			; 
23ae			;;		if DEBUG_FORTH_WORDS 
23ae			;;			DMARK "EX2" 
23ae			;;			CALLMONITOR 
23ae			;;		endif 
23ae			;	push hl 
23ae			; 
23ae			;	;ld a, 0 
23ae			;	;ld a, FORTH_END_BUFFER 
23ae			;	call strlenz 
23ae			;	inc hl   ; include zero term to copy 
23ae			;	inc hl   ; include term 
23ae			;	inc hl   ; include term 
23ae			;	ld b,0 
23ae			;	ld c,l 
23ae			;	pop hl 
23ae			;	ld de, execscratch 
23ae			;		if DEBUG_FORTH_WORDS 
23ae			;			DMARK "EX3" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			;	ldir 
23ae			; 
23ae			; 
23ae			;	ld hl, execscratch 
23ae			; 
23ae			;		if DEBUG_FORTH_WORDS 
23ae			;			DMARK "EXe" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			; 
23ae			;	call forthparse 
23ae			;	call forthexec 
23ae			;;	call forthexec_cleanup 
23ae			;;	call forthparse 
23ae			;;	call forthexec 
23ae			; 
23ae			;	STACKFRAMECHK OFF $5efe $5f9f 
23ae			; 
23ae			;	; an immediate word so no need to process any more words 
23ae			;	ret 
23ae			;	NEXTW 
23ae			 
23ae			; dead code - old version  
23ae			;	FORTH_RSP_NEXT 
23ae			 
23ae			;  
23ae			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23ae			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23ae			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
23ae			;	push hl 
23ae			;	push de 
23ae			;	push bc 
23ae			; 
23ae			; 
23ae			;		if DEBUG_FORTH_WORDS_KEY 
23ae			;			DMARK "EXR" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			; 
23ae			; 
23ae			; 
23ae			;	;v5 FORTH_DSP_VALUE 
23ae			;	FORTH_DSP_VALUEHL 
23ae			; 
23ae			;	; TODO do string type checks 
23ae			; 
23ae			;;v5	inc hl   ; skip type 
23ae			; 
23ae			;	push hl  ; source code  
23ae			;		if DEBUG_FORTH_WORDS 
23ae			;			DMARK "EX1" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			;	ld a, 0 
23ae			;	call strlent 
23ae			; 
23ae			;	inc hl 
23ae			;	inc hl 
23ae			;	inc hl 
23ae			;	inc hl 
23ae			; 
23ae			;	push hl    ; size 
23ae			; 
23ae			;		if DEBUG_FORTH_WORDS 
23ae			;			DMARK "EX2" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			;	call malloc 
23ae			; 
23ae			;	ex de, hl    ; de now contains malloc area 
23ae			;	pop bc   	; get byte count 
23ae			;	pop hl      ; get string to copy 
23ae			; 
23ae			;	push de     ; save malloc for free later 
23ae			; 
23ae			;		if DEBUG_FORTH_WORDS 
23ae			;			DMARK "EX3" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			;	ldir       ; duplicate string 
23ae			; 
23ae			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
23ae			;	 
23ae			;	; TODO fix the parse would be better than this...  
23ae			;	ex de, hl 
23ae			;	dec hl 
23ae			;	ld a, 0 
23ae			;	ld (hl), a 
23ae			;	dec hl 
23ae			;	ld a, ' ' 
23ae			;	ld (hl), a 
23ae			;	dec hl 
23ae			;	ld (hl), a 
23ae			; 
23ae			;	dec hl 
23ae			;	ld (hl), a 
23ae			; 
23ae			; 
23ae			;	FORTH_DSP_POP  
23ae			; 
23ae			;	pop hl     
23ae			;	push hl    ; save malloc area 
23ae			; 
23ae			;		if DEBUG_FORTH_WORDS 
23ae			;			DMARK "EX4" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			; 
23ae			;	call forthparse 
23ae			;	call forthexec 
23ae			;	 
23ae			;	pop hl 
23ae			;	if DEBUG_FORTH_WORDS 
23ae			;		DMARK "EX5" 
23ae			;		CALLMONITOR 
23ae			;	endif 
23ae			; 
23ae			;	if FORTH_ENABLE_FREE 
23ae			;	call free 
23ae			;	endif 
23ae			; 
23ae			;	if DEBUG_FORTH_WORDS 
23ae			;		DMARK "EX6" 
23ae			;		CALLMONITOR 
23ae			;	endif 
23ae			; 
23ae			;	pop bc 
23ae			;	pop de 
23ae			;	pop hl 
23ae			;;	FORTH_RSP_POP	  
23ae			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
23ae			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
23ae			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
23ae			; 
23ae			;	if DEBUG_FORTH_WORDS 
23ae			;		DMARK "EX7" 
23ae			;		CALLMONITOR 
23ae			;	endif 
23ae			;	NEXTW 
23ae			 
23ae			;.STKEXEC: 
23ae			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
23ae			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
23ae			; 
23ae			; 
23ae			;		if DEBUG_FORTH_WORDS_KEY 
23ae			;			DMARK "STX" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			; 
23ae			;	FORTH_DSP_VALUEHL 
23ae			; 
23ae			;	ld (store_tmp1), hl    ; count 
23ae			; 
23ae			;	FORTH_DSP_POP 
23ae			;.stkexec1: 
23ae			;	ld hl, (store_tmp1)   ; count 
23ae			;	ld a, 0 
23ae			;	cp l 
23ae			;	ret z 
23ae			; 
23ae			;	dec hl 
23ae			;	ld (store_tmp1), hl    ; count 
23ae			;	 
23ae			;	FORTH_DSP_VALUEHL 
23ae			;	push hl 
23ae			;	 
23ae			;		if DEBUG_FORTH_WORDS 
23ae			;			DMARK "EXp" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			;	FORTH_DSP_POP 
23ae			; 
23ae			;	call strlenz 
23ae			;	inc hl   ; include zero term to copy 
23ae			;	inc hl   ; include zero term to copy 
23ae			;	inc hl   ; include zero term to copy 
23ae			;	ld b,0 
23ae			;	ld c,l 
23ae			;	pop hl 
23ae			;	ld de, execscratch 
23ae			;		if DEBUG_FORTH_WORDS 
23ae			;			DMARK "EX3" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			;	ldir 
23ae			; 
23ae			; 
23ae			;	ld hl, execscratch 
23ae			; 
23ae			;		if DEBUG_FORTH_WORDS 
23ae			;			DMARK "EXP" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			; 
23ae			;	call forthparse 
23ae			;	ld hl, execscratch 
23ae			;		if DEBUG_FORTH_WORDS 
23ae			;			DMARK "EXx" 
23ae			;			CALLMONITOR 
23ae			;		endif 
23ae			;	call forthexec 
23ae			; 
23ae			;	jp .stkexec1 
23ae			; 
23ae			;	ret 
23ae			 
23ae			 
23ae			.DUP: 
23ae			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
23ae 17				db WORD_SYS_CORE+OPCODE_DUP             
23af 24 24			dw .ZDUP            
23b1 04				db 3 + 1 
23b2 .. 00			db "DUP",0              
23b6				endm 
# End of macro CWHEAD
23b6			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
23b6			 
23b6				if DEBUG_FORTH_WORDS_KEY 
23b6					DMARK "DUP" 
23b6 f5				push af  
23b7 3a cb 23			ld a, (.dmark)  
23ba 32 6b ee			ld (debug_mark),a  
23bd 3a cc 23			ld a, (.dmark+1)  
23c0 32 6c ee			ld (debug_mark+1),a  
23c3 3a cd 23			ld a, (.dmark+2)  
23c6 32 6d ee			ld (debug_mark+2),a  
23c9 18 03			jr .pastdmark  
23cb ..			.dmark: db "DUP"  
23ce f1			.pastdmark: pop af  
23cf			endm  
# End of macro DMARK
23cf					CALLMONITOR 
23cf cd 6f ee			call debug_vector  
23d2				endm  
# End of macro CALLMONITOR
23d2				endif 
23d2			 
23d2				FORTH_DSP 
23d2 cd 27 20			call macro_forth_dsp 
23d5				endm 
# End of macro FORTH_DSP
23d5			 
23d5 7e				ld a, (HL) 
23d6 fe 01			cp DS_TYPE_STR 
23d8 20 25			jr nz, .dupinum 
23da			 
23da				; push another string 
23da			 
23da				FORTH_DSP_VALUEHL     		 
23da cd 61 20			call macro_dsp_valuehl 
23dd				endm 
# End of macro FORTH_DSP_VALUEHL
23dd			 
23dd			if DEBUG_FORTH_WORDS 
23dd				DMARK "DUs" 
23dd f5				push af  
23de 3a f2 23			ld a, (.dmark)  
23e1 32 6b ee			ld (debug_mark),a  
23e4 3a f3 23			ld a, (.dmark+1)  
23e7 32 6c ee			ld (debug_mark+1),a  
23ea 3a f4 23			ld a, (.dmark+2)  
23ed 32 6d ee			ld (debug_mark+2),a  
23f0 18 03			jr .pastdmark  
23f2 ..			.dmark: db "DUs"  
23f5 f1			.pastdmark: pop af  
23f6			endm  
# End of macro DMARK
23f6				CALLMONITOR 
23f6 cd 6f ee			call debug_vector  
23f9				endm  
# End of macro CALLMONITOR
23f9			endif 
23f9 cd d8 1e			call forth_push_str 
23fc			 
23fc				NEXTW 
23fc c3 17 22			jp macro_next 
23ff				endm 
# End of macro NEXTW
23ff			 
23ff			 
23ff			.dupinum: 
23ff				 
23ff			 
23ff			 
23ff				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23ff cd 61 20			call macro_dsp_valuehl 
2402				endm 
# End of macro FORTH_DSP_VALUEHL
2402			 
2402			; TODO add floating point number detection 
2402			 
2402			if DEBUG_FORTH_WORDS 
2402				DMARK "DUi" 
2402 f5				push af  
2403 3a 17 24			ld a, (.dmark)  
2406 32 6b ee			ld (debug_mark),a  
2409 3a 18 24			ld a, (.dmark+1)  
240c 32 6c ee			ld (debug_mark+1),a  
240f 3a 19 24			ld a, (.dmark+2)  
2412 32 6d ee			ld (debug_mark+2),a  
2415 18 03			jr .pastdmark  
2417 ..			.dmark: db "DUi"  
241a f1			.pastdmark: pop af  
241b			endm  
# End of macro DMARK
241b				CALLMONITOR 
241b cd 6f ee			call debug_vector  
241e				endm  
# End of macro CALLMONITOR
241e			endif 
241e			 
241e cd 6a 1e			call forth_push_numhl 
2421				NEXTW 
2421 c3 17 22			jp macro_next 
2424				endm 
# End of macro NEXTW
2424			.ZDUP: 
2424			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2424 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2425 5c 24			dw .SWAP            
2427 05				db 4 + 1 
2428 .. 00			db "?DUP",0              
242d				endm 
# End of macro CWHEAD
242d			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
242d			 
242d				if DEBUG_FORTH_WORDS_KEY 
242d					DMARK "qDU" 
242d f5				push af  
242e 3a 42 24			ld a, (.dmark)  
2431 32 6b ee			ld (debug_mark),a  
2434 3a 43 24			ld a, (.dmark+1)  
2437 32 6c ee			ld (debug_mark+1),a  
243a 3a 44 24			ld a, (.dmark+2)  
243d 32 6d ee			ld (debug_mark+2),a  
2440 18 03			jr .pastdmark  
2442 ..			.dmark: db "qDU"  
2445 f1			.pastdmark: pop af  
2446			endm  
# End of macro DMARK
2446					CALLMONITOR 
2446 cd 6f ee			call debug_vector  
2449				endm  
# End of macro CALLMONITOR
2449				endif 
2449				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2449 cd 61 20			call macro_dsp_valuehl 
244c				endm 
# End of macro FORTH_DSP_VALUEHL
244c			 
244c e5				push hl 
244d			 
244d				; is it a zero? 
244d			 
244d 3e 00			ld a, 0 
244f 84				add h 
2450 85				add l 
2451			 
2451 e1				pop hl 
2452			 
2452 fe 00			cp 0 
2454 28 03			jr z, .dup2orig 
2456			 
2456			 
2456 cd 6a 1e			call forth_push_numhl 
2459			 
2459			 
2459			; TODO add floating point number detection 
2459			 
2459			.dup2orig: 
2459			 
2459				NEXTW 
2459 c3 17 22			jp macro_next 
245c				endm 
# End of macro NEXTW
245c			.SWAP: 
245c			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
245c 18				db WORD_SYS_CORE+OPCODE_SWAP             
245d 9b 24			dw .COLN            
245f 05				db 4 + 1 
2460 .. 00			db "SWAP",0              
2465				endm 
# End of macro CWHEAD
2465			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2465				if DEBUG_FORTH_WORDS_KEY 
2465					DMARK "SWP" 
2465 f5				push af  
2466 3a 7a 24			ld a, (.dmark)  
2469 32 6b ee			ld (debug_mark),a  
246c 3a 7b 24			ld a, (.dmark+1)  
246f 32 6c ee			ld (debug_mark+1),a  
2472 3a 7c 24			ld a, (.dmark+2)  
2475 32 6d ee			ld (debug_mark+2),a  
2478 18 03			jr .pastdmark  
247a ..			.dmark: db "SWP"  
247d f1			.pastdmark: pop af  
247e			endm  
# End of macro DMARK
247e					CALLMONITOR 
247e cd 6f ee			call debug_vector  
2481				endm  
# End of macro CALLMONITOR
2481				endif 
2481			 
2481			; TODO Use os stack swap memory 
2481				FORTH_DSP_VALUEHL 
2481 cd 61 20			call macro_dsp_valuehl 
2484				endm 
# End of macro FORTH_DSP_VALUEHL
2484 e5				push hl     ; w2 
2485			 
2485				FORTH_DSP_POP 
2485 cd 19 21			call macro_forth_dsp_pop 
2488				endm 
# End of macro FORTH_DSP_POP
2488			 
2488				FORTH_DSP_VALUEHL 
2488 cd 61 20			call macro_dsp_valuehl 
248b				endm 
# End of macro FORTH_DSP_VALUEHL
248b			 
248b				FORTH_DSP_POP 
248b cd 19 21			call macro_forth_dsp_pop 
248e				endm 
# End of macro FORTH_DSP_POP
248e			 
248e d1				pop de     ; w2	, hl = w1 
248f			 
248f eb				ex de, hl 
2490 d5				push de 
2491			 
2491 cd 6a 1e			call forth_push_numhl 
2494			 
2494 e1				pop hl 
2495			 
2495 cd 6a 1e			call forth_push_numhl 
2498				 
2498			 
2498				NEXTW 
2498 c3 17 22			jp macro_next 
249b				endm 
# End of macro NEXTW
249b			.COLN: 
249b			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
249b 19				db WORD_SYS_CORE+OPCODE_COLN             
249c 27 26			dw .SCOLN            
249e 02				db 1 + 1 
249f .. 00			db ":",0              
24a1				endm 
# End of macro CWHEAD
24a1			; | : ( -- )         Create new word | DONE 
24a1			 
24a1				if DEBUG_FORTH_WORDS_KEY 
24a1					DMARK "CLN" 
24a1 f5				push af  
24a2 3a b6 24			ld a, (.dmark)  
24a5 32 6b ee			ld (debug_mark),a  
24a8 3a b7 24			ld a, (.dmark+1)  
24ab 32 6c ee			ld (debug_mark+1),a  
24ae 3a b8 24			ld a, (.dmark+2)  
24b1 32 6d ee			ld (debug_mark+2),a  
24b4 18 03			jr .pastdmark  
24b6 ..			.dmark: db "CLN"  
24b9 f1			.pastdmark: pop af  
24ba			endm  
# End of macro DMARK
24ba					CALLMONITOR 
24ba cd 6f ee			call debug_vector  
24bd				endm  
# End of macro CALLMONITOR
24bd				endif 
24bd			STACKFRAME OFF $8efe $989f 
24bd				if DEBUG_STACK_IMB 
24bd					if OFF 
24bd						exx 
24bd						ld de, $8efe 
24bd						ld a, d 
24bd						ld hl, curframe 
24bd						call hexout 
24bd						ld a, e 
24bd						ld hl, curframe+2 
24bd						call hexout 
24bd						ld hl, $8efe 
24bd						push hl 
24bd						ld hl, $989f 
24bd						push hl 
24bd						exx 
24bd					endif 
24bd				endif 
24bd			endm 
# End of macro STACKFRAME
24bd			; get parser buffer length  of new word 
24bd			 
24bd			 
24bd			 
24bd				; move tok past this to start of name defintition 
24bd				; TODO get word to define 
24bd				; TODO Move past word token 
24bd				; TODO get length of string up to the ';' 
24bd			 
24bd 2a c2 e5		ld hl, (os_tok_ptr) 
24c0 23			inc hl 
24c1 23			inc hl 
24c2			 
24c2 3e 3b		ld a, ';' 
24c4 cd 67 14		call strlent 
24c7			 
24c7 7d			ld a,l 
24c8 32 b1 e2		ld (os_new_parse_len), a 
24cb			 
24cb			 
24cb			if DEBUG_FORTH_UWORD 
24cb ed 5b c2 e5	ld de, (os_tok_ptr) 
24cf					DMARK ":01" 
24cf f5				push af  
24d0 3a e4 24			ld a, (.dmark)  
24d3 32 6b ee			ld (debug_mark),a  
24d6 3a e5 24			ld a, (.dmark+1)  
24d9 32 6c ee			ld (debug_mark+1),a  
24dc 3a e6 24			ld a, (.dmark+2)  
24df 32 6d ee			ld (debug_mark+2),a  
24e2 18 03			jr .pastdmark  
24e4 ..			.dmark: db ":01"  
24e7 f1			.pastdmark: pop af  
24e8			endm  
# End of macro DMARK
24e8			CALLMONITOR 
24e8 cd 6f ee			call debug_vector  
24eb				endm  
# End of macro CALLMONITOR
24eb			endif 
24eb			 
24eb			; 
24eb			;  new word memory layout: 
24eb			;  
24eb			;    : adg 6666 ;  
24eb			; 
24eb			;    db   1     ; user defined word  
24eb 23			inc hl    
24ec			;    dw   sysdict 
24ec 23			inc hl 
24ed 23			inc hl 
24ee			;    db <word len>+1 (for null) 
24ee 23			inc hl 
24ef			;    db .... <word> 
24ef			; 
24ef			 
24ef 23			inc hl    ; some extras for the word preamble before the above 
24f0 23			inc hl 
24f1 23			inc hl 
24f2 23			inc hl 
24f3 23			inc hl 
24f4 23			inc hl 
24f5 23			inc hl  
24f6 23			inc hl 
24f7 23			inc hl 
24f8 23			inc hl 
24f9 23			inc hl 
24fa 23			inc hl 
24fb 23			inc hl 
24fc 23			inc hl     ; TODO how many do we really need?     maybe only 6 
24fd			;       exec word buffer 
24fd			;	<ptr word>   
24fd 23			inc hl 
24fe 23			inc hl 
24ff			;       <word list><null term> 7F final term 
24ff			 
24ff			 
24ff			if DEBUG_FORTH_UWORD 
24ff					DMARK ":02" 
24ff f5				push af  
2500 3a 14 25			ld a, (.dmark)  
2503 32 6b ee			ld (debug_mark),a  
2506 3a 15 25			ld a, (.dmark+1)  
2509 32 6c ee			ld (debug_mark+1),a  
250c 3a 16 25			ld a, (.dmark+2)  
250f 32 6d ee			ld (debug_mark+2),a  
2512 18 03			jr .pastdmark  
2514 ..			.dmark: db ":02"  
2517 f1			.pastdmark: pop af  
2518			endm  
# End of macro DMARK
2518			CALLMONITOR 
2518 cd 6f ee			call debug_vector  
251b				endm  
# End of macro CALLMONITOR
251b			endif 
251b			 
251b			 
251b				; malloc the size 
251b			 
251b cd d1 14			call malloc 
251e 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
2521			 
2521			;    db   1     ; user defined word  
2521 3e 01			ld a, WORD_SYS_UWORD  
2523 77				ld (hl), a 
2524			 
2524 23			inc hl    
2525			;    dw   sysdict 
2525 11 6f 23		ld de, sysdict       ; continue on with the scan to the system dict 
2528 73			ld (hl), e 
2529 23			inc hl 
252a 72			ld (hl), d 
252b 23			inc hl 
252c			 
252c			 
252c			;    Setup dict word 
252c			 
252c 23			inc hl 
252d 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
2530			 
2530			; 1. get length of dict word 
2530			 
2530			 
2530 2a c2 e5		ld hl, (os_tok_ptr) 
2533 23			inc hl 
2534 23			inc hl    ; position to start of dict word 
2535 3e 00		ld a, 0 
2537 cd 67 14		call strlent 
253a			 
253a			 
253a 23			inc hl    ; to include null??? 
253b			 
253b			; write length of dict word 
253b			 
253b ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
253f 1b			dec de 
2540 eb			ex de, hl 
2541 73			ld (hl), e 
2542 eb			ex de, hl 
2543			 
2543			 
2543			 
2543			; copy  
2543 4d			ld c, l 
2544 06 00		ld b, 0 
2546 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
254a 2a c2 e5		ld hl, (os_tok_ptr) 
254d 23			inc hl 
254e 23			inc hl    ; position to start of dict word 
254f			 
254f			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
254f			 
254f			; TODO need to convert word to upper case 
254f			 
254f			ucasetok:	 
254f 7e			ld a,(hl) 
2550 cd 53 14		call toUpper 
2553 77			ld (hl),a 
2554 ed a0		ldi 
2556 f2 4f 25		jp p, ucasetok 
2559			 
2559			 
2559			 
2559			; de now points to start of where the word body code should be placed 
2559 ed 53 ad e2	ld (os_new_work_ptr), de 
255d			; hl now points to the words to throw at forthexec which needs to be copied 
255d 22 ab e2		ld (os_new_src_ptr), hl 
2560			 
2560			; TODO add 'call to forthexec' 
2560			 
2560			if DEBUG_FORTH_UWORD 
2560 c5			push bc 
2561 ed 4b b3 e2	ld bc, (os_new_malloc) 
2565					DMARK ":0x" 
2565 f5				push af  
2566 3a 7a 25			ld a, (.dmark)  
2569 32 6b ee			ld (debug_mark),a  
256c 3a 7b 25			ld a, (.dmark+1)  
256f 32 6c ee			ld (debug_mark+1),a  
2572 3a 7c 25			ld a, (.dmark+2)  
2575 32 6d ee			ld (debug_mark+2),a  
2578 18 03			jr .pastdmark  
257a ..			.dmark: db ":0x"  
257d f1			.pastdmark: pop af  
257e			endm  
# End of macro DMARK
257e			CALLMONITOR 
257e cd 6f ee			call debug_vector  
2581				endm  
# End of macro CALLMONITOR
2581 c1			pop bc 
2582			endif 
2582			 
2582			 
2582			; create word preamble which should be: 
2582			 
2582			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2582			 
2582			;    ld hl, <word code> 
2582			;    jp user_exec 
2582			;    <word code bytes> 
2582			 
2582			 
2582			;	inc de     ; TODO ??? or are we already past the word's null 
2582 eb			ex de, hl 
2583			 
2583 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2585			 
2585 23			inc hl 
2586 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2589 23			inc hl 
258a			 
258a 23			inc hl 
258b 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
258d			 
258d 01 05 4f		ld bc, user_exec 
2590 23			inc hl 
2591 71			ld (hl), c     ; poke address of user_exec 
2592 23			inc hl 
2593 70			ld (hl), b     
2594			; 
2594			;	inc hl 
2594			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2594			; 
2594			; 
2594			;	ld bc, macro_forth_rsp_next 
2594			;	inc hl 
2594			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2594			;	inc hl 
2594			;	ld (hl), b     
2594			; 
2594			;	inc hl 
2594			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2594			; 
2594			; 
2594			;	inc hl 
2594			;	ld bc, forthexec 
2594			;	ld (hl), c     ; poke address of forthexec 
2594			;	inc hl 
2594			;	ld (hl), b      
2594			; 
2594			;	inc hl 
2594			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2594			; 
2594			;	ld bc, user_dict_next 
2594			;	inc hl 
2594			;	ld (hl), c     ; poke address of forthexec 
2594			;	inc hl 
2594			;	ld (hl), b      
2594			 
2594			; hl is now where we need to copy the word byte data to save this 
2594			 
2594 23			inc hl 
2595 22 a9 e2		ld (os_new_exec), hl 
2598			 
2598			; copy definition 
2598			 
2598 eb			ex de, hl 
2599			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2599			;	inc de    ; skip the PC for this parse 
2599 3a b1 e2		ld a, (os_new_parse_len) 
259c 4f			ld c, a 
259d 06 00		ld b, 0 
259f ed b0		ldir		 ; copy defintion 
25a1			 
25a1			 
25a1			; poke the address of where the new word bytes live for forthexec 
25a1			 
25a1 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
25a4			 
25a4 ed 5b a9 e2	ld de, (os_new_exec)      
25a8			 
25a8 73			ld (hl), e 
25a9 23			inc hl 
25aa 72			ld (hl), d 
25ab			 
25ab				; TODO copy last user dict word next link to this word 
25ab				; TODO update last user dict word to point to this word 
25ab			; 
25ab			; hl f923 de 812a ; bc 811a 
25ab			 
25ab			if DEBUG_FORTH_UWORD 
25ab c5			push bc 
25ac ed 4b b3 e2	ld bc, (os_new_malloc) 
25b0					DMARK ":0A" 
25b0 f5				push af  
25b1 3a c5 25			ld a, (.dmark)  
25b4 32 6b ee			ld (debug_mark),a  
25b7 3a c6 25			ld a, (.dmark+1)  
25ba 32 6c ee			ld (debug_mark+1),a  
25bd 3a c7 25			ld a, (.dmark+2)  
25c0 32 6d ee			ld (debug_mark+2),a  
25c3 18 03			jr .pastdmark  
25c5 ..			.dmark: db ":0A"  
25c8 f1			.pastdmark: pop af  
25c9			endm  
# End of macro DMARK
25c9			CALLMONITOR 
25c9 cd 6f ee			call debug_vector  
25cc				endm  
# End of macro CALLMONITOR
25cc c1			pop bc 
25cd			endif 
25cd			if DEBUG_FORTH_UWORD 
25cd c5			push bc 
25ce ed 4b b3 e2	ld bc, (os_new_malloc) 
25d2 03			inc bc 
25d3 03			inc bc 
25d4 03			inc bc 
25d5 03			inc bc 
25d6 03			inc bc 
25d7 03			inc bc 
25d8 03			inc bc 
25d9 03			inc bc 
25da			 
25da					DMARK ":0B" 
25da f5				push af  
25db 3a ef 25			ld a, (.dmark)  
25de 32 6b ee			ld (debug_mark),a  
25e1 3a f0 25			ld a, (.dmark+1)  
25e4 32 6c ee			ld (debug_mark+1),a  
25e7 3a f1 25			ld a, (.dmark+2)  
25ea 32 6d ee			ld (debug_mark+2),a  
25ed 18 03			jr .pastdmark  
25ef ..			.dmark: db ":0B"  
25f2 f1			.pastdmark: pop af  
25f3			endm  
# End of macro DMARK
25f3			CALLMONITOR 
25f3 cd 6f ee			call debug_vector  
25f6				endm  
# End of macro CALLMONITOR
25f6 c1			pop bc 
25f7			endif 
25f7			 
25f7			; update word dict linked list for new word 
25f7			 
25f7			 
25f7 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
25fa 23			inc hl     ; move to next work linked list ptr 
25fb			 
25fb ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
25ff 73			ld (hl), e 
2600 23			inc hl 
2601 72			ld (hl), d 
2602			 
2602			if DEBUG_FORTH_UWORD 
2602 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2606			endif 
2606			 
2606 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
260a			 
260a			 
260a			if DEBUG_FORTH_UWORD 
260a					DMARK ":0+" 
260a f5				push af  
260b 3a 1f 26			ld a, (.dmark)  
260e 32 6b ee			ld (debug_mark),a  
2611 3a 20 26			ld a, (.dmark+1)  
2614 32 6c ee			ld (debug_mark+1),a  
2617 3a 21 26			ld a, (.dmark+2)  
261a 32 6d ee			ld (debug_mark+2),a  
261d 18 03			jr .pastdmark  
261f ..			.dmark: db ":0+"  
2622 f1			.pastdmark: pop af  
2623			endm  
# End of macro DMARK
2623			CALLMONITOR 
2623 cd 6f ee			call debug_vector  
2626				endm  
# End of macro CALLMONITOR
2626			endif 
2626			 
2626			STACKFRAMECHK OFF $8efe $989f 
2626				if DEBUG_STACK_IMB 
2626					if OFF 
2626						exx 
2626						ld hl, $989f 
2626						pop de   ; $989f 
2626						call cmp16 
2626						jr nz, .spnosame 
2626						ld hl, $8efe 
2626						pop de   ; $8efe 
2626						call cmp16 
2626						jr z, .spfrsame 
2626						.spnosame: call showsperror 
2626						.spfrsame: nop 
2626						exx 
2626					endif 
2626				endif 
2626			endm 
# End of macro STACKFRAMECHK
2626			 
2626 c9			ret    ; dont process any remaining parser tokens as they form new word 
2627			 
2627			 
2627			 
2627			 
2627			;		NEXT 
2627			.SCOLN: 
2627			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2627 06			db OPCODE_SCOLN 
2628 73 26		dw .DROP 
262a 02			db 2 
262b .. 00		db ";",0           
262d			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
262d				if DEBUG_FORTH_WORDS_KEY 
262d					DMARK "SCN" 
262d f5				push af  
262e 3a 42 26			ld a, (.dmark)  
2631 32 6b ee			ld (debug_mark),a  
2634 3a 43 26			ld a, (.dmark+1)  
2637 32 6c ee			ld (debug_mark+1),a  
263a 3a 44 26			ld a, (.dmark+2)  
263d 32 6d ee			ld (debug_mark+2),a  
2640 18 03			jr .pastdmark  
2642 ..			.dmark: db "SCN"  
2645 f1			.pastdmark: pop af  
2646			endm  
# End of macro DMARK
2646					CALLMONITOR 
2646 cd 6f ee			call debug_vector  
2649				endm  
# End of macro CALLMONITOR
2649				endif 
2649				FORTH_RSP_TOS 
2649 cd 28 1e			call macro_forth_rsp_tos 
264c				endm 
# End of macro FORTH_RSP_TOS
264c e5				push hl 
264d				FORTH_RSP_POP 
264d cd 32 1e			call macro_forth_rsp_pop 
2650				endm 
# End of macro FORTH_RSP_POP
2650 e1				pop hl 
2651			;		ex de,hl 
2651 22 c2 e5			ld (os_tok_ptr),hl 
2654			 
2654			if DEBUG_FORTH_UWORD 
2654					DMARK "SCL" 
2654 f5				push af  
2655 3a 69 26			ld a, (.dmark)  
2658 32 6b ee			ld (debug_mark),a  
265b 3a 6a 26			ld a, (.dmark+1)  
265e 32 6c ee			ld (debug_mark+1),a  
2661 3a 6b 26			ld a, (.dmark+2)  
2664 32 6d ee			ld (debug_mark+2),a  
2667 18 03			jr .pastdmark  
2669 ..			.dmark: db "SCL"  
266c f1			.pastdmark: pop af  
266d			endm  
# End of macro DMARK
266d			CALLMONITOR 
266d cd 6f ee			call debug_vector  
2670				endm  
# End of macro CALLMONITOR
2670			endif 
2670				NEXTW 
2670 c3 17 22			jp macro_next 
2673				endm 
# End of macro NEXTW
2673			 
2673			.DROP: 
2673			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2673 1b				db WORD_SYS_CORE+OPCODE_DROP             
2674 9e 26			dw .DUP2            
2676 05				db 4 + 1 
2677 .. 00			db "DROP",0              
267c				endm 
# End of macro CWHEAD
267c			; | DROP ( w -- )   drop the TOS item   | DONE 
267c				if DEBUG_FORTH_WORDS_KEY 
267c					DMARK "DRP" 
267c f5				push af  
267d 3a 91 26			ld a, (.dmark)  
2680 32 6b ee			ld (debug_mark),a  
2683 3a 92 26			ld a, (.dmark+1)  
2686 32 6c ee			ld (debug_mark+1),a  
2689 3a 93 26			ld a, (.dmark+2)  
268c 32 6d ee			ld (debug_mark+2),a  
268f 18 03			jr .pastdmark  
2691 ..			.dmark: db "DRP"  
2694 f1			.pastdmark: pop af  
2695			endm  
# End of macro DMARK
2695					CALLMONITOR 
2695 cd 6f ee			call debug_vector  
2698				endm  
# End of macro CALLMONITOR
2698				endif 
2698				FORTH_DSP_POP 
2698 cd 19 21			call macro_forth_dsp_pop 
269b				endm 
# End of macro FORTH_DSP_POP
269b				NEXTW 
269b c3 17 22			jp macro_next 
269e				endm 
# End of macro NEXTW
269e			.DUP2: 
269e			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
269e 1c				db WORD_SYS_CORE+OPCODE_DUP2             
269f e3 26			dw .DROP2            
26a1 05				db 4 + 1 
26a2 .. 00			db "2DUP",0              
26a7				endm 
# End of macro CWHEAD
26a7			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
26a7				if DEBUG_FORTH_WORDS_KEY 
26a7					DMARK "2DU" 
26a7 f5				push af  
26a8 3a bc 26			ld a, (.dmark)  
26ab 32 6b ee			ld (debug_mark),a  
26ae 3a bd 26			ld a, (.dmark+1)  
26b1 32 6c ee			ld (debug_mark+1),a  
26b4 3a be 26			ld a, (.dmark+2)  
26b7 32 6d ee			ld (debug_mark+2),a  
26ba 18 03			jr .pastdmark  
26bc ..			.dmark: db "2DU"  
26bf f1			.pastdmark: pop af  
26c0			endm  
# End of macro DMARK
26c0					CALLMONITOR 
26c0 cd 6f ee			call debug_vector  
26c3				endm  
# End of macro CALLMONITOR
26c3				endif 
26c3				FORTH_DSP_VALUEHL 
26c3 cd 61 20			call macro_dsp_valuehl 
26c6				endm 
# End of macro FORTH_DSP_VALUEHL
26c6 e5				push hl      ; 2 
26c7			 
26c7				FORTH_DSP_POP 
26c7 cd 19 21			call macro_forth_dsp_pop 
26ca				endm 
# End of macro FORTH_DSP_POP
26ca				 
26ca				FORTH_DSP_VALUEHL 
26ca cd 61 20			call macro_dsp_valuehl 
26cd				endm 
# End of macro FORTH_DSP_VALUEHL
26cd			;		push hl      ; 1 
26cd			 
26cd				FORTH_DSP_POP 
26cd cd 19 21			call macro_forth_dsp_pop 
26d0				endm 
# End of macro FORTH_DSP_POP
26d0			 
26d0			;		pop hl       ; 1 
26d0 d1				pop de       ; 2 
26d1			 
26d1 cd 6a 1e			call forth_push_numhl 
26d4 eb				ex de, hl 
26d5 cd 6a 1e			call forth_push_numhl 
26d8			 
26d8				 
26d8 eb				ex de, hl 
26d9			 
26d9 cd 6a 1e			call forth_push_numhl 
26dc eb				ex de, hl 
26dd cd 6a 1e			call forth_push_numhl 
26e0			 
26e0			 
26e0				NEXTW 
26e0 c3 17 22			jp macro_next 
26e3				endm 
# End of macro NEXTW
26e3			.DROP2: 
26e3			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
26e3 1d				db WORD_SYS_CORE+OPCODE_DROP2             
26e4 12 27			dw .SWAP2            
26e6 06				db 5 + 1 
26e7 .. 00			db "2DROP",0              
26ed				endm 
# End of macro CWHEAD
26ed			; | 2DROP ( w w -- )    Double drop | DONE 
26ed				if DEBUG_FORTH_WORDS_KEY 
26ed					DMARK "2DR" 
26ed f5				push af  
26ee 3a 02 27			ld a, (.dmark)  
26f1 32 6b ee			ld (debug_mark),a  
26f4 3a 03 27			ld a, (.dmark+1)  
26f7 32 6c ee			ld (debug_mark+1),a  
26fa 3a 04 27			ld a, (.dmark+2)  
26fd 32 6d ee			ld (debug_mark+2),a  
2700 18 03			jr .pastdmark  
2702 ..			.dmark: db "2DR"  
2705 f1			.pastdmark: pop af  
2706			endm  
# End of macro DMARK
2706					CALLMONITOR 
2706 cd 6f ee			call debug_vector  
2709				endm  
# End of macro CALLMONITOR
2709				endif 
2709				FORTH_DSP_POP 
2709 cd 19 21			call macro_forth_dsp_pop 
270c				endm 
# End of macro FORTH_DSP_POP
270c				FORTH_DSP_POP 
270c cd 19 21			call macro_forth_dsp_pop 
270f				endm 
# End of macro FORTH_DSP_POP
270f				NEXTW 
270f c3 17 22			jp macro_next 
2712				endm 
# End of macro NEXTW
2712			.SWAP2: 
2712			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2712 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2713 3b 27			dw .AT            
2715 06				db 5 + 1 
2716 .. 00			db "2SWAP",0              
271c				endm 
# End of macro CWHEAD
271c			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
271c				if DEBUG_FORTH_WORDS_KEY 
271c					DMARK "2SW" 
271c f5				push af  
271d 3a 31 27			ld a, (.dmark)  
2720 32 6b ee			ld (debug_mark),a  
2723 3a 32 27			ld a, (.dmark+1)  
2726 32 6c ee			ld (debug_mark+1),a  
2729 3a 33 27			ld a, (.dmark+2)  
272c 32 6d ee			ld (debug_mark+2),a  
272f 18 03			jr .pastdmark  
2731 ..			.dmark: db "2SW"  
2734 f1			.pastdmark: pop af  
2735			endm  
# End of macro DMARK
2735					CALLMONITOR 
2735 cd 6f ee			call debug_vector  
2738				endm  
# End of macro CALLMONITOR
2738				endif 
2738			; TODO Use os stack swap memory 
2738				NEXTW 
2738 c3 17 22			jp macro_next 
273b				endm 
# End of macro NEXTW
273b			.AT: 
273b			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
273b 1f				db WORD_SYS_CORE+OPCODE_AT             
273c 6d 27			dw .CAT            
273e 02				db 1 + 1 
273f .. 00			db "@",0              
2741				endm 
# End of macro CWHEAD
2741			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2741			 
2741				if DEBUG_FORTH_WORDS_KEY 
2741					DMARK "AT." 
2741 f5				push af  
2742 3a 56 27			ld a, (.dmark)  
2745 32 6b ee			ld (debug_mark),a  
2748 3a 57 27			ld a, (.dmark+1)  
274b 32 6c ee			ld (debug_mark+1),a  
274e 3a 58 27			ld a, (.dmark+2)  
2751 32 6d ee			ld (debug_mark+2),a  
2754 18 03			jr .pastdmark  
2756 ..			.dmark: db "AT."  
2759 f1			.pastdmark: pop af  
275a			endm  
# End of macro DMARK
275a					CALLMONITOR 
275a cd 6f ee			call debug_vector  
275d				endm  
# End of macro CALLMONITOR
275d				endif 
275d			.getbyteat:	 
275d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
275d cd 61 20			call macro_dsp_valuehl 
2760				endm 
# End of macro FORTH_DSP_VALUEHL
2760				 
2760			;		push hl 
2760			 
2760				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2760 cd 19 21			call macro_forth_dsp_pop 
2763				endm 
# End of macro FORTH_DSP_POP
2763			 
2763			;		pop hl 
2763			 
2763 7e				ld a, (hl) 
2764			 
2764 6f				ld l, a 
2765 26 00			ld h, 0 
2767 cd 6a 1e			call forth_push_numhl 
276a			 
276a				NEXTW 
276a c3 17 22			jp macro_next 
276d				endm 
# End of macro NEXTW
276d			.CAT: 
276d			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
276d 20				db WORD_SYS_CORE+OPCODE_CAT             
276e 96 27			dw .BANG            
2770 03				db 2 + 1 
2771 .. 00			db "C@",0              
2774				endm 
# End of macro CWHEAD
2774			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2774				if DEBUG_FORTH_WORDS_KEY 
2774					DMARK "CAA" 
2774 f5				push af  
2775 3a 89 27			ld a, (.dmark)  
2778 32 6b ee			ld (debug_mark),a  
277b 3a 8a 27			ld a, (.dmark+1)  
277e 32 6c ee			ld (debug_mark+1),a  
2781 3a 8b 27			ld a, (.dmark+2)  
2784 32 6d ee			ld (debug_mark+2),a  
2787 18 03			jr .pastdmark  
2789 ..			.dmark: db "CAA"  
278c f1			.pastdmark: pop af  
278d			endm  
# End of macro DMARK
278d					CALLMONITOR 
278d cd 6f ee			call debug_vector  
2790				endm  
# End of macro CALLMONITOR
2790				endif 
2790 c3 5d 27			jp .getbyteat 
2793				NEXTW 
2793 c3 17 22			jp macro_next 
2796				endm 
# End of macro NEXTW
2796			.BANG: 
2796			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2796 21				db WORD_SYS_CORE+OPCODE_BANG             
2797 cc 27			dw .CBANG            
2799 02				db 1 + 1 
279a .. 00			db "!",0              
279c				endm 
# End of macro CWHEAD
279c			; | ! ( x w -- ) Store x at address w      | DONE 
279c				if DEBUG_FORTH_WORDS_KEY 
279c					DMARK "BNG" 
279c f5				push af  
279d 3a b1 27			ld a, (.dmark)  
27a0 32 6b ee			ld (debug_mark),a  
27a3 3a b2 27			ld a, (.dmark+1)  
27a6 32 6c ee			ld (debug_mark+1),a  
27a9 3a b3 27			ld a, (.dmark+2)  
27ac 32 6d ee			ld (debug_mark+2),a  
27af 18 03			jr .pastdmark  
27b1 ..			.dmark: db "BNG"  
27b4 f1			.pastdmark: pop af  
27b5			endm  
# End of macro DMARK
27b5					CALLMONITOR 
27b5 cd 6f ee			call debug_vector  
27b8				endm  
# End of macro CALLMONITOR
27b8				endif 
27b8			 
27b8			.storebyteat:		 
27b8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27b8 cd 61 20			call macro_dsp_valuehl 
27bb				endm 
# End of macro FORTH_DSP_VALUEHL
27bb				 
27bb e5				push hl 
27bc			 
27bc				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27bc cd 19 21			call macro_forth_dsp_pop 
27bf				endm 
# End of macro FORTH_DSP_POP
27bf			 
27bf				; get byte to poke 
27bf			 
27bf				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27bf cd 61 20			call macro_dsp_valuehl 
27c2				endm 
# End of macro FORTH_DSP_VALUEHL
27c2 e5				push hl 
27c3			 
27c3			 
27c3				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27c3 cd 19 21			call macro_forth_dsp_pop 
27c6				endm 
# End of macro FORTH_DSP_POP
27c6			 
27c6			 
27c6 d1				pop de 
27c7 e1				pop hl 
27c8			 
27c8 73				ld (hl),e 
27c9			 
27c9			 
27c9				NEXTW 
27c9 c3 17 22			jp macro_next 
27cc				endm 
# End of macro NEXTW
27cc			.CBANG: 
27cc			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
27cc 22				db WORD_SYS_CORE+OPCODE_CBANG             
27cd f5 27			dw .SCALL            
27cf 03				db 2 + 1 
27d0 .. 00			db "C!",0              
27d3				endm 
# End of macro CWHEAD
27d3			; | C!  ( x w -- ) Store x at address w  | DONE 
27d3				if DEBUG_FORTH_WORDS_KEY 
27d3					DMARK "CBA" 
27d3 f5				push af  
27d4 3a e8 27			ld a, (.dmark)  
27d7 32 6b ee			ld (debug_mark),a  
27da 3a e9 27			ld a, (.dmark+1)  
27dd 32 6c ee			ld (debug_mark+1),a  
27e0 3a ea 27			ld a, (.dmark+2)  
27e3 32 6d ee			ld (debug_mark+2),a  
27e6 18 03			jr .pastdmark  
27e8 ..			.dmark: db "CBA"  
27eb f1			.pastdmark: pop af  
27ec			endm  
# End of macro DMARK
27ec					CALLMONITOR 
27ec cd 6f ee			call debug_vector  
27ef				endm  
# End of macro CALLMONITOR
27ef				endif 
27ef c3 b8 27			jp .storebyteat 
27f2				NEXTW 
27f2 c3 17 22			jp macro_next 
27f5				endm 
# End of macro NEXTW
27f5			.SCALL: 
27f5			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
27f5 23				db WORD_SYS_CORE+OPCODE_SCALL             
27f6 29 28			dw .DEPTH            
27f8 05				db 4 + 1 
27f9 .. 00			db "CALL",0              
27fe				endm 
# End of macro CWHEAD
27fe			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
27fe				if DEBUG_FORTH_WORDS_KEY 
27fe					DMARK "CLL" 
27fe f5				push af  
27ff 3a 13 28			ld a, (.dmark)  
2802 32 6b ee			ld (debug_mark),a  
2805 3a 14 28			ld a, (.dmark+1)  
2808 32 6c ee			ld (debug_mark+1),a  
280b 3a 15 28			ld a, (.dmark+2)  
280e 32 6d ee			ld (debug_mark+2),a  
2811 18 03			jr .pastdmark  
2813 ..			.dmark: db "CLL"  
2816 f1			.pastdmark: pop af  
2817			endm  
# End of macro DMARK
2817					CALLMONITOR 
2817 cd 6f ee			call debug_vector  
281a				endm  
# End of macro CALLMONITOR
281a				endif 
281a			 
281a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
281a cd 61 20			call macro_dsp_valuehl 
281d				endm 
# End of macro FORTH_DSP_VALUEHL
281d			 
281d			;		push hl 
281d			 
281d				; destroy value TOS 
281d			 
281d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
281d cd 19 21			call macro_forth_dsp_pop 
2820				endm 
# End of macro FORTH_DSP_POP
2820			 
2820					 
2820			;		pop hl 
2820			 
2820				; how to do a call with hl???? save SP? 
2820 cd bb 21			call forth_call_hl 
2823			 
2823			 
2823				; TODO push value back onto stack for another op etc 
2823			 
2823 cd 6a 1e			call forth_push_numhl 
2826				NEXTW 
2826 c3 17 22			jp macro_next 
2829				endm 
# End of macro NEXTW
2829			.DEPTH: 
2829			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2829 24				db WORD_SYS_CORE+OPCODE_DEPTH             
282a 66 28			dw .OVER            
282c 06				db 5 + 1 
282d .. 00			db "DEPTH",0              
2833				endm 
# End of macro CWHEAD
2833			; | DEPTH ( -- u ) Push count of stack | DONE 
2833				; take current TOS and remove from base value div by two to get count 
2833				if DEBUG_FORTH_WORDS_KEY 
2833					DMARK "DEP" 
2833 f5				push af  
2834 3a 48 28			ld a, (.dmark)  
2837 32 6b ee			ld (debug_mark),a  
283a 3a 49 28			ld a, (.dmark+1)  
283d 32 6c ee			ld (debug_mark+1),a  
2840 3a 4a 28			ld a, (.dmark+2)  
2843 32 6d ee			ld (debug_mark+2),a  
2846 18 03			jr .pastdmark  
2848 ..			.dmark: db "DEP"  
284b f1			.pastdmark: pop af  
284c			endm  
# End of macro DMARK
284c					CALLMONITOR 
284c cd 6f ee			call debug_vector  
284f				endm  
# End of macro CALLMONITOR
284f				endif 
284f			 
284f			 
284f 2a ee e9		ld hl, (cli_data_sp) 
2852 11 28 e8		ld de, cli_data_stack 
2855 ed 52		sbc hl,de 
2857			 
2857			; div by size of stack item 
2857			 
2857 5d			ld e,l 
2858 0e 03		ld c, 3 
285a cd 76 0d		call Div8 
285d			 
285d 6f			ld l,a 
285e 26 00		ld h,0 
2860			 
2860			;srl h 
2860			;rr l 
2860			 
2860 cd 6a 1e			call forth_push_numhl 
2863				NEXTW 
2863 c3 17 22			jp macro_next 
2866				endm 
# End of macro NEXTW
2866			.OVER: 
2866			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2866 42				db WORD_SYS_CORE+46             
2867 ad 28			dw .PAUSE            
2869 05				db 4 + 1 
286a .. 00			db "OVER",0              
286f				endm 
# End of macro CWHEAD
286f			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
286f				if DEBUG_FORTH_WORDS_KEY 
286f					DMARK "OVR" 
286f f5				push af  
2870 3a 84 28			ld a, (.dmark)  
2873 32 6b ee			ld (debug_mark),a  
2876 3a 85 28			ld a, (.dmark+1)  
2879 32 6c ee			ld (debug_mark+1),a  
287c 3a 86 28			ld a, (.dmark+2)  
287f 32 6d ee			ld (debug_mark+2),a  
2882 18 03			jr .pastdmark  
2884 ..			.dmark: db "OVR"  
2887 f1			.pastdmark: pop af  
2888			endm  
# End of macro DMARK
2888					CALLMONITOR 
2888 cd 6f ee			call debug_vector  
288b				endm  
# End of macro CALLMONITOR
288b				endif 
288b			 
288b			; TODO Use os stack swap memory 
288b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
288b cd 61 20			call macro_dsp_valuehl 
288e				endm 
# End of macro FORTH_DSP_VALUEHL
288e e5				push hl    ; n2 
288f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
288f cd 19 21			call macro_forth_dsp_pop 
2892				endm 
# End of macro FORTH_DSP_POP
2892			 
2892				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2892 cd 61 20			call macro_dsp_valuehl 
2895				endm 
# End of macro FORTH_DSP_VALUEHL
2895 e5				push hl    ; n1 
2896				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2896 cd 19 21			call macro_forth_dsp_pop 
2899				endm 
# End of macro FORTH_DSP_POP
2899			 
2899 d1				pop de     ; n1 
289a e1				pop hl     ; n2 
289b			 
289b d5				push de 
289c e5				push hl 
289d d5				push de 
289e			 
289e				; push back  
289e			 
289e e1				pop hl 
289f cd 6a 1e			call forth_push_numhl 
28a2 e1				pop hl 
28a3 cd 6a 1e			call forth_push_numhl 
28a6 e1				pop hl 
28a7 cd 6a 1e			call forth_push_numhl 
28aa				NEXTW 
28aa c3 17 22			jp macro_next 
28ad				endm 
# End of macro NEXTW
28ad			 
28ad			.PAUSE: 
28ad			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
28ad 43				db WORD_SYS_CORE+47             
28ae e2 28			dw .PAUSES            
28b0 08				db 7 + 1 
28b1 .. 00			db "PAUSEMS",0              
28b9				endm 
# End of macro CWHEAD
28b9			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
28b9				if DEBUG_FORTH_WORDS_KEY 
28b9					DMARK "PMS" 
28b9 f5				push af  
28ba 3a ce 28			ld a, (.dmark)  
28bd 32 6b ee			ld (debug_mark),a  
28c0 3a cf 28			ld a, (.dmark+1)  
28c3 32 6c ee			ld (debug_mark+1),a  
28c6 3a d0 28			ld a, (.dmark+2)  
28c9 32 6d ee			ld (debug_mark+2),a  
28cc 18 03			jr .pastdmark  
28ce ..			.dmark: db "PMS"  
28d1 f1			.pastdmark: pop af  
28d2			endm  
# End of macro DMARK
28d2					CALLMONITOR 
28d2 cd 6f ee			call debug_vector  
28d5				endm  
# End of macro CALLMONITOR
28d5				endif 
28d5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28d5 cd 61 20			call macro_dsp_valuehl 
28d8				endm 
# End of macro FORTH_DSP_VALUEHL
28d8			;		push hl    ; n2 
28d8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28d8 cd 19 21			call macro_forth_dsp_pop 
28db				endm 
# End of macro FORTH_DSP_POP
28db			;		pop hl 
28db			 
28db 7d				ld a, l 
28dc cd d6 0a			call aDelayInMS 
28df			       NEXTW 
28df c3 17 22			jp macro_next 
28e2				endm 
# End of macro NEXTW
28e2			.PAUSES:  
28e2			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
28e2 44				db WORD_SYS_CORE+48             
28e3 51 29			dw .ROT            
28e5 06				db 5 + 1 
28e6 .. 00			db "PAUSE",0              
28ec				endm 
# End of macro CWHEAD
28ec			; | PAUSE ( n -- )  Pause for n seconds | DONE 
28ec				if DEBUG_FORTH_WORDS_KEY 
28ec					DMARK "PAU" 
28ec f5				push af  
28ed 3a 01 29			ld a, (.dmark)  
28f0 32 6b ee			ld (debug_mark),a  
28f3 3a 02 29			ld a, (.dmark+1)  
28f6 32 6c ee			ld (debug_mark+1),a  
28f9 3a 03 29			ld a, (.dmark+2)  
28fc 32 6d ee			ld (debug_mark+2),a  
28ff 18 03			jr .pastdmark  
2901 ..			.dmark: db "PAU"  
2904 f1			.pastdmark: pop af  
2905			endm  
# End of macro DMARK
2905					CALLMONITOR 
2905 cd 6f ee			call debug_vector  
2908				endm  
# End of macro CALLMONITOR
2908				endif 
2908				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2908 cd 61 20			call macro_dsp_valuehl 
290b				endm 
# End of macro FORTH_DSP_VALUEHL
290b			;		push hl    ; n2 
290b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
290b cd 19 21			call macro_forth_dsp_pop 
290e				endm 
# End of macro FORTH_DSP_POP
290e			;		pop hl 
290e 45				ld b, l 
290f				if DEBUG_FORTH_WORDS 
290f					DMARK "PAU" 
290f f5				push af  
2910 3a 24 29			ld a, (.dmark)  
2913 32 6b ee			ld (debug_mark),a  
2916 3a 25 29			ld a, (.dmark+1)  
2919 32 6c ee			ld (debug_mark+1),a  
291c 3a 26 29			ld a, (.dmark+2)  
291f 32 6d ee			ld (debug_mark+2),a  
2922 18 03			jr .pastdmark  
2924 ..			.dmark: db "PAU"  
2927 f1			.pastdmark: pop af  
2928			endm  
# End of macro DMARK
2928					CALLMONITOR 
2928 cd 6f ee			call debug_vector  
292b				endm  
# End of macro CALLMONITOR
292b				endif 
292b c5			.pauses1:	push bc 
292c cd f1 0a			call delay1s 
292f c1				pop bc 
2930				if DEBUG_FORTH_WORDS 
2930					DMARK "PA1" 
2930 f5				push af  
2931 3a 45 29			ld a, (.dmark)  
2934 32 6b ee			ld (debug_mark),a  
2937 3a 46 29			ld a, (.dmark+1)  
293a 32 6c ee			ld (debug_mark+1),a  
293d 3a 47 29			ld a, (.dmark+2)  
2940 32 6d ee			ld (debug_mark+2),a  
2943 18 03			jr .pastdmark  
2945 ..			.dmark: db "PA1"  
2948 f1			.pastdmark: pop af  
2949			endm  
# End of macro DMARK
2949					CALLMONITOR 
2949 cd 6f ee			call debug_vector  
294c				endm  
# End of macro CALLMONITOR
294c				endif 
294c 10 dd			djnz .pauses1 
294e			 
294e			       NEXTW 
294e c3 17 22			jp macro_next 
2951				endm 
# End of macro NEXTW
2951			.ROT: 
2951			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2951 45				db WORD_SYS_CORE+49             
2952 9f 29			dw .UWORDS            
2954 04				db 3 + 1 
2955 .. 00			db "ROT",0              
2959				endm 
# End of macro CWHEAD
2959			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2959				if DEBUG_FORTH_WORDS_KEY 
2959					DMARK "ROT" 
2959 f5				push af  
295a 3a 6e 29			ld a, (.dmark)  
295d 32 6b ee			ld (debug_mark),a  
2960 3a 6f 29			ld a, (.dmark+1)  
2963 32 6c ee			ld (debug_mark+1),a  
2966 3a 70 29			ld a, (.dmark+2)  
2969 32 6d ee			ld (debug_mark+2),a  
296c 18 03			jr .pastdmark  
296e ..			.dmark: db "ROT"  
2971 f1			.pastdmark: pop af  
2972			endm  
# End of macro DMARK
2972					CALLMONITOR 
2972 cd 6f ee			call debug_vector  
2975				endm  
# End of macro CALLMONITOR
2975				endif 
2975			 
2975			; TODO Use os stack swap memory 
2975				FORTH_DSP_VALUEHL 
2975 cd 61 20			call macro_dsp_valuehl 
2978				endm 
# End of macro FORTH_DSP_VALUEHL
2978 e5				push hl    ; u3  
2979			 
2979				FORTH_DSP_POP 
2979 cd 19 21			call macro_forth_dsp_pop 
297c				endm 
# End of macro FORTH_DSP_POP
297c			 
297c				FORTH_DSP_VALUEHL 
297c cd 61 20			call macro_dsp_valuehl 
297f				endm 
# End of macro FORTH_DSP_VALUEHL
297f e5				push hl     ; u2 
2980			 
2980				FORTH_DSP_POP 
2980 cd 19 21			call macro_forth_dsp_pop 
2983				endm 
# End of macro FORTH_DSP_POP
2983			 
2983				FORTH_DSP_VALUEHL 
2983 cd 61 20			call macro_dsp_valuehl 
2986				endm 
# End of macro FORTH_DSP_VALUEHL
2986 e5				push hl     ; u1 
2987			 
2987				FORTH_DSP_POP 
2987 cd 19 21			call macro_forth_dsp_pop 
298a				endm 
# End of macro FORTH_DSP_POP
298a			 
298a c1				pop bc      ; u1 
298b e1				pop hl      ; u2 
298c d1				pop de      ; u3 
298d			 
298d			 
298d c5				push bc 
298e d5				push de 
298f e5				push hl 
2990			 
2990			 
2990 e1				pop hl 
2991 cd 6a 1e			call forth_push_numhl 
2994			 
2994 e1				pop hl 
2995 cd 6a 1e			call forth_push_numhl 
2998			 
2998 e1				pop hl 
2999 cd 6a 1e			call forth_push_numhl 
299c				 
299c			 
299c			 
299c			 
299c			 
299c			 
299c			       NEXTW 
299c c3 17 22			jp macro_next 
299f				endm 
# End of macro NEXTW
299f			 
299f			.UWORDS: 
299f			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
299f 50				db WORD_SYS_CORE+60             
29a0 61 2a			dw .BP            
29a2 07				db 6 + 1 
29a3 .. 00			db "UWORDS",0              
29aa				endm 
# End of macro CWHEAD
29aa			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
29aa			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
29aa			; | | Following the count are the individual words. 
29aa			; | | 
29aa			; | | e.g. UWORDS 
29aa			; | | BOX DIRLIST 2 
29aa			; | |  
29aa			; | | Can be used to save the words to storage via: 
29aa			; | | UWORDS $01 DO $01 APPEND LOOP 
29aa			if DEBUG_FORTH_WORDS_KEY 
29aa				DMARK "UWR" 
29aa f5				push af  
29ab 3a bf 29			ld a, (.dmark)  
29ae 32 6b ee			ld (debug_mark),a  
29b1 3a c0 29			ld a, (.dmark+1)  
29b4 32 6c ee			ld (debug_mark+1),a  
29b7 3a c1 29			ld a, (.dmark+2)  
29ba 32 6d ee			ld (debug_mark+2),a  
29bd 18 03			jr .pastdmark  
29bf ..			.dmark: db "UWR"  
29c2 f1			.pastdmark: pop af  
29c3			endm  
# End of macro DMARK
29c3				CALLMONITOR 
29c3 cd 6f ee			call debug_vector  
29c6				endm  
# End of macro CALLMONITOR
29c6			endif 
29c6 21 5f 68			ld hl, baseram 
29c9				;ld hl, baseusermem 
29c9 01 00 00			ld bc, 0    ; start a counter 
29cc			 
29cc			; skip dict stub 
29cc			 
29cc cd 68 23			call forth_tok_next 
29cf			 
29cf			 
29cf			; while we have words to look for 
29cf			 
29cf 7e			.douscan:	ld a, (hl)      
29d0			if DEBUG_FORTH_WORDS 
29d0				DMARK "UWs" 
29d0 f5				push af  
29d1 3a e5 29			ld a, (.dmark)  
29d4 32 6b ee			ld (debug_mark),a  
29d7 3a e6 29			ld a, (.dmark+1)  
29da 32 6c ee			ld (debug_mark+1),a  
29dd 3a e7 29			ld a, (.dmark+2)  
29e0 32 6d ee			ld (debug_mark+2),a  
29e3 18 03			jr .pastdmark  
29e5 ..			.dmark: db "UWs"  
29e8 f1			.pastdmark: pop af  
29e9			endm  
# End of macro DMARK
29e9				CALLMONITOR 
29e9 cd 6f ee			call debug_vector  
29ec				endm  
# End of macro CALLMONITOR
29ec			endif 
29ec fe 00			cp WORD_SYS_END 
29ee 28 4d			jr z, .udone 
29f0 fe 01			cp WORD_SYS_UWORD 
29f2 20 44			jr nz, .nuword 
29f4			 
29f4			if DEBUG_FORTH_WORDS 
29f4				DMARK "UWu" 
29f4 f5				push af  
29f5 3a 09 2a			ld a, (.dmark)  
29f8 32 6b ee			ld (debug_mark),a  
29fb 3a 0a 2a			ld a, (.dmark+1)  
29fe 32 6c ee			ld (debug_mark+1),a  
2a01 3a 0b 2a			ld a, (.dmark+2)  
2a04 32 6d ee			ld (debug_mark+2),a  
2a07 18 03			jr .pastdmark  
2a09 ..			.dmark: db "UWu"  
2a0c f1			.pastdmark: pop af  
2a0d			endm  
# End of macro DMARK
2a0d				CALLMONITOR 
2a0d cd 6f ee			call debug_vector  
2a10				endm  
# End of macro CALLMONITOR
2a10			endif 
2a10				; we have a uword so push its name to the stack 
2a10			 
2a10 e5				push hl  ; save so we can move to next dict block 
2a11			 
2a11				; skip opcode 
2a11 23				inc hl  
2a12				; skip next ptr 
2a12 23				inc hl  
2a13 23				inc hl 
2a14				; skip len 
2a14 23				inc hl 
2a15			if DEBUG_FORTH_WORDS 
2a15				DMARK "UWt" 
2a15 f5				push af  
2a16 3a 2a 2a			ld a, (.dmark)  
2a19 32 6b ee			ld (debug_mark),a  
2a1c 3a 2b 2a			ld a, (.dmark+1)  
2a1f 32 6c ee			ld (debug_mark+1),a  
2a22 3a 2c 2a			ld a, (.dmark+2)  
2a25 32 6d ee			ld (debug_mark+2),a  
2a28 18 03			jr .pastdmark  
2a2a ..			.dmark: db "UWt"  
2a2d f1			.pastdmark: pop af  
2a2e			endm  
# End of macro DMARK
2a2e				CALLMONITOR 
2a2e cd 6f ee			call debug_vector  
2a31				endm  
# End of macro CALLMONITOR
2a31			endif 
2a31 03				inc bc 
2a32			 
2a32 c5				push bc 
2a33 cd d8 1e			call forth_push_str 
2a36 c1				pop bc 
2a37			 
2a37 e1				pop hl 	 
2a38			 
2a38 cd 68 23		.nuword:	call forth_tok_next 
2a3b 18 92			jr .douscan  
2a3d			 
2a3d			.udone:		 ; push count of uwords found 
2a3d c5				push bc 
2a3e e1				pop hl 
2a3f			 
2a3f			if DEBUG_FORTH_WORDS 
2a3f				DMARK "UWc" 
2a3f f5				push af  
2a40 3a 54 2a			ld a, (.dmark)  
2a43 32 6b ee			ld (debug_mark),a  
2a46 3a 55 2a			ld a, (.dmark+1)  
2a49 32 6c ee			ld (debug_mark+1),a  
2a4c 3a 56 2a			ld a, (.dmark+2)  
2a4f 32 6d ee			ld (debug_mark+2),a  
2a52 18 03			jr .pastdmark  
2a54 ..			.dmark: db "UWc"  
2a57 f1			.pastdmark: pop af  
2a58			endm  
# End of macro DMARK
2a58				CALLMONITOR 
2a58 cd 6f ee			call debug_vector  
2a5b				endm  
# End of macro CALLMONITOR
2a5b			endif 
2a5b cd 6a 1e			call forth_push_numhl 
2a5e			 
2a5e			 
2a5e			       NEXTW 
2a5e c3 17 22			jp macro_next 
2a61				endm 
# End of macro NEXTW
2a61			 
2a61			.BP: 
2a61			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2a61 54				db WORD_SYS_CORE+64             
2a62 9b 2a			dw .MONITOR            
2a64 03				db 2 + 1 
2a65 .. 00			db "BP",0              
2a68				endm 
# End of macro CWHEAD
2a68			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2a68			; | | $00 Will enable the break points within specific code paths 
2a68			; | | $01 Will disable break points 
2a68			; | |  
2a68			; | | By default break points are off. Either the above can be used to enable them 
2a68			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2a68			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2a68			; | | can disable break points. Exiting will then continue boot process. 
2a68				; get byte count 
2a68				if DEBUG_FORTH_WORDS_KEY 
2a68					DMARK "BP." 
2a68 f5				push af  
2a69 3a 7d 2a			ld a, (.dmark)  
2a6c 32 6b ee			ld (debug_mark),a  
2a6f 3a 7e 2a			ld a, (.dmark+1)  
2a72 32 6c ee			ld (debug_mark+1),a  
2a75 3a 7f 2a			ld a, (.dmark+2)  
2a78 32 6d ee			ld (debug_mark+2),a  
2a7b 18 03			jr .pastdmark  
2a7d ..			.dmark: db "BP."  
2a80 f1			.pastdmark: pop af  
2a81			endm  
# End of macro DMARK
2a81					CALLMONITOR 
2a81 cd 6f ee			call debug_vector  
2a84				endm  
# End of macro CALLMONITOR
2a84				endif 
2a84			 
2a84				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a84 cd 61 20			call macro_dsp_valuehl 
2a87				endm 
# End of macro FORTH_DSP_VALUEHL
2a87			 
2a87			;		push hl 
2a87			 
2a87				; destroy value TOS 
2a87			 
2a87				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a87 cd 19 21			call macro_forth_dsp_pop 
2a8a				endm 
# End of macro FORTH_DSP_POP
2a8a			 
2a8a			;		pop hl 
2a8a			 
2a8a 3e 00			ld a,0 
2a8c bd				cp l 
2a8d 28 06			jr z, .bpset 
2a8f			;		ld a, '*' 
2a8f cd 0c 18			call bp_off 
2a92				NEXTW 
2a92 c3 17 22			jp macro_next 
2a95				endm 
# End of macro NEXTW
2a95			 
2a95			.bpset:	 
2a95				;	ld (os_view_disable), a 
2a95 cd 00 18			call bp_on 
2a98			 
2a98			 
2a98				NEXTW 
2a98 c3 17 22			jp macro_next 
2a9b				endm 
# End of macro NEXTW
2a9b			 
2a9b			 
2a9b			.MONITOR: 
2a9b			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2a9b 55				db WORD_SYS_CORE+65             
2a9c cc 2a			dw .MALLOC            
2a9e 08				db 7 + 1 
2a9f .. 00			db "MONITOR",0              
2aa7				endm 
# End of macro CWHEAD
2aa7			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2aa7			; | | At start the current various registers will be displayed with contents. 
2aa7			; | | Top right corner will show the most recent debug marker seen. 
2aa7			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2aa7			; | | and the return stack pointer (RSP). 
2aa7			; | | Pressing: 
2aa7			; | |    1 - Initial screen 
2aa7			; | |    2 - Display a data dump of HL 
2aa7			; | |    3 - Display a data dump of DE 
2aa7			; | |    4 - Display a data dump of BC 
2aa7			; | |    5 - Display a data dump of HL 
2aa7			; | |    6 - Display a data dump of DSP 
2aa7			; | |    7 - Display a data dump of RSP 
2aa7			; | |    8 - Display a data dump of what is at DSP 
2aa7			; | |    9 - Display a data dump of what is at RSP 
2aa7			; | |    0 - Exit monitor and continue running. This will also enable break points 
2aa7			; | |    * - Disable break points 
2aa7			; | |    # - Enter traditional monitor mode 
2aa7			; | | 
2aa7			; | | Monitor Mode 
2aa7			; | | ------------ 
2aa7			; | | A prompt of '>' will be shown for various commands: 
2aa7			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2aa7			; | |    C - Continue display a data dump from the last set address 
2aa7			; | |    M xxxx - Set start of memory edit at address xx 
2aa7			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2aa7			; | |    G xxxx - Exec code at specific address 
2aa7			; | |    Q - Return to previous 
2aa7				if DEBUG_FORTH_WORDS_KEY 
2aa7					DMARK "MON" 
2aa7 f5				push af  
2aa8 3a bc 2a			ld a, (.dmark)  
2aab 32 6b ee			ld (debug_mark),a  
2aae 3a bd 2a			ld a, (.dmark+1)  
2ab1 32 6c ee			ld (debug_mark+1),a  
2ab4 3a be 2a			ld a, (.dmark+2)  
2ab7 32 6d ee			ld (debug_mark+2),a  
2aba 18 03			jr .pastdmark  
2abc ..			.dmark: db "MON"  
2abf f1			.pastdmark: pop af  
2ac0			endm  
# End of macro DMARK
2ac0					CALLMONITOR 
2ac0 cd 6f ee			call debug_vector  
2ac3				endm  
# End of macro CALLMONITOR
2ac3				endif 
2ac3			;		ld a, 0 
2ac3			;		ld (os_view_disable), a 
2ac3 cd 00 18			call bp_on 
2ac6			 
2ac6				CALLMONITOR 
2ac6 cd 6f ee			call debug_vector  
2ac9				endm  
# End of macro CALLMONITOR
2ac9			 
2ac9			;	call monitor 
2ac9			 
2ac9				NEXTW 
2ac9 c3 17 22			jp macro_next 
2acc				endm 
# End of macro NEXTW
2acc			 
2acc			 
2acc			.MALLOC: 
2acc			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2acc 56				db WORD_SYS_CORE+66             
2acd f5 2a			dw .MALLOC2            
2acf 06				db 5 + 1 
2ad0 .. 00			db "ALLOT",0              
2ad6				endm 
# End of macro CWHEAD
2ad6			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ad6				if DEBUG_FORTH_WORDS_KEY 
2ad6					DMARK "ALL" 
2ad6 f5				push af  
2ad7 3a eb 2a			ld a, (.dmark)  
2ada 32 6b ee			ld (debug_mark),a  
2add 3a ec 2a			ld a, (.dmark+1)  
2ae0 32 6c ee			ld (debug_mark+1),a  
2ae3 3a ed 2a			ld a, (.dmark+2)  
2ae6 32 6d ee			ld (debug_mark+2),a  
2ae9 18 03			jr .pastdmark  
2aeb ..			.dmark: db "ALL"  
2aee f1			.pastdmark: pop af  
2aef			endm  
# End of macro DMARK
2aef					CALLMONITOR 
2aef cd 6f ee			call debug_vector  
2af2				endm  
# End of macro CALLMONITOR
2af2				endif 
2af2 c3 1c 2b			jp .mallocc 
2af5			.MALLOC2: 
2af5			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2af5 56				db WORD_SYS_CORE+66             
2af6 33 2b			dw .FREE            
2af8 07				db 6 + 1 
2af9 .. 00			db "MALLOC",0              
2b00				endm 
# End of macro CWHEAD
2b00			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b00				; get byte count 
2b00				if DEBUG_FORTH_WORDS_KEY 
2b00					DMARK "MAL" 
2b00 f5				push af  
2b01 3a 15 2b			ld a, (.dmark)  
2b04 32 6b ee			ld (debug_mark),a  
2b07 3a 16 2b			ld a, (.dmark+1)  
2b0a 32 6c ee			ld (debug_mark+1),a  
2b0d 3a 17 2b			ld a, (.dmark+2)  
2b10 32 6d ee			ld (debug_mark+2),a  
2b13 18 03			jr .pastdmark  
2b15 ..			.dmark: db "MAL"  
2b18 f1			.pastdmark: pop af  
2b19			endm  
# End of macro DMARK
2b19					CALLMONITOR 
2b19 cd 6f ee			call debug_vector  
2b1c				endm  
# End of macro CALLMONITOR
2b1c				endif 
2b1c			.mallocc: 
2b1c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b1c cd 61 20			call macro_dsp_valuehl 
2b1f				endm 
# End of macro FORTH_DSP_VALUEHL
2b1f			 
2b1f			;		push hl 
2b1f			 
2b1f				; destroy value TOS 
2b1f			 
2b1f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b1f cd 19 21			call macro_forth_dsp_pop 
2b22				endm 
# End of macro FORTH_DSP_POP
2b22			 
2b22			;		pop hl 
2b22 cd d1 14			call malloc 
2b25			if DEBUG_FORTH_MALLOC_GUARD 
2b25 f5				push af 
2b26 cd 0f 0e			call ishlzero 
2b29			;		ld a, l 
2b29			;		add h 
2b29			;		cp 0 
2b29 f1				pop af 
2b2a				 
2b2a cc d7 4f			call z,malloc_error 
2b2d			endif 
2b2d			 
2b2d cd 6a 1e			call forth_push_numhl 
2b30				NEXTW 
2b30 c3 17 22			jp macro_next 
2b33				endm 
# End of macro NEXTW
2b33			 
2b33			.FREE: 
2b33			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2b33 57				db WORD_SYS_CORE+67             
2b34 64 2b			dw .LIST            
2b36 05				db 4 + 1 
2b37 .. 00			db "FREE",0              
2b3c				endm 
# End of macro CWHEAD
2b3c			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2b3c				if DEBUG_FORTH_WORDS_KEY 
2b3c					DMARK "FRE" 
2b3c f5				push af  
2b3d 3a 51 2b			ld a, (.dmark)  
2b40 32 6b ee			ld (debug_mark),a  
2b43 3a 52 2b			ld a, (.dmark+1)  
2b46 32 6c ee			ld (debug_mark+1),a  
2b49 3a 53 2b			ld a, (.dmark+2)  
2b4c 32 6d ee			ld (debug_mark+2),a  
2b4f 18 03			jr .pastdmark  
2b51 ..			.dmark: db "FRE"  
2b54 f1			.pastdmark: pop af  
2b55			endm  
# End of macro DMARK
2b55					CALLMONITOR 
2b55 cd 6f ee			call debug_vector  
2b58				endm  
# End of macro CALLMONITOR
2b58				endif 
2b58				; get address 
2b58			 
2b58				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b58 cd 61 20			call macro_dsp_valuehl 
2b5b				endm 
# End of macro FORTH_DSP_VALUEHL
2b5b			 
2b5b			;		push hl 
2b5b			 
2b5b				; destroy value TOS 
2b5b			 
2b5b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b5b cd 19 21			call macro_forth_dsp_pop 
2b5e				endm 
# End of macro FORTH_DSP_POP
2b5e			 
2b5e			;		pop hl 
2b5e			if FORTH_ENABLE_MALLOCFREE 
2b5e cd 9b 15			call free 
2b61			endif 
2b61				NEXTW 
2b61 c3 17 22			jp macro_next 
2b64				endm 
# End of macro NEXTW
2b64			.LIST: 
2b64			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2b64 5c				db WORD_SYS_CORE+72             
2b65 54 2d			dw .FORGET            
2b67 05				db 4 + 1 
2b68 .. 00			db "LIST",0              
2b6d				endm 
# End of macro CWHEAD
2b6d			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2b6d			; | | The quoted word must be in upper case. 
2b6d			if DEBUG_FORTH_WORDS_KEY 
2b6d				DMARK "LST" 
2b6d f5				push af  
2b6e 3a 82 2b			ld a, (.dmark)  
2b71 32 6b ee			ld (debug_mark),a  
2b74 3a 83 2b			ld a, (.dmark+1)  
2b77 32 6c ee			ld (debug_mark+1),a  
2b7a 3a 84 2b			ld a, (.dmark+2)  
2b7d 32 6d ee			ld (debug_mark+2),a  
2b80 18 03			jr .pastdmark  
2b82 ..			.dmark: db "LST"  
2b85 f1			.pastdmark: pop af  
2b86			endm  
# End of macro DMARK
2b86				CALLMONITOR 
2b86 cd 6f ee			call debug_vector  
2b89				endm  
# End of macro CALLMONITOR
2b89			endif 
2b89			 
2b89				FORTH_DSP_VALUEHL 
2b89 cd 61 20			call macro_dsp_valuehl 
2b8c				endm 
# End of macro FORTH_DSP_VALUEHL
2b8c			 
2b8c e5				push hl 
2b8d				FORTH_DSP_POP 
2b8d cd 19 21			call macro_forth_dsp_pop 
2b90				endm 
# End of macro FORTH_DSP_POP
2b90 c1				pop bc 
2b91			 
2b91			; Start format of scratch string 
2b91			 
2b91 21 c1 e2			ld hl, scratch 
2b94			 
2b94 3e 3a			ld a, ':' 
2b96 77				ld (hl),a 
2b97 23				inc hl 
2b98 3e 20			ld a, ' ' 
2b9a 77				ld (hl), a 
2b9b			 
2b9b				; Get ptr to the word we need to look up 
2b9b			 
2b9b			;		FORTH_DSP_VALUEHL 
2b9b				;v5 FORTH_DSP_VALUE 
2b9b			; TODO type check 
2b9b			;		inc hl    ; Skip type check  
2b9b			;		push hl 
2b9b			;		ex de, hl    ; put into DE 
2b9b			 
2b9b			 
2b9b 21 5f 68			ld hl, baseram 
2b9e				;ld hl, baseusermem 
2b9e			 
2b9e e5			push hl   ; sacreifical push 
2b9f			 
2b9f			.ldouscanm: 
2b9f e1			pop hl 
2ba0			.ldouscan: 
2ba0			if DEBUG_FORTH_WORDS 
2ba0				DMARK "LSs" 
2ba0 f5				push af  
2ba1 3a b5 2b			ld a, (.dmark)  
2ba4 32 6b ee			ld (debug_mark),a  
2ba7 3a b6 2b			ld a, (.dmark+1)  
2baa 32 6c ee			ld (debug_mark+1),a  
2bad 3a b7 2b			ld a, (.dmark+2)  
2bb0 32 6d ee			ld (debug_mark+2),a  
2bb3 18 03			jr .pastdmark  
2bb5 ..			.dmark: db "LSs"  
2bb8 f1			.pastdmark: pop af  
2bb9			endm  
# End of macro DMARK
2bb9				CALLMONITOR 
2bb9 cd 6f ee			call debug_vector  
2bbc				endm  
# End of macro CALLMONITOR
2bbc			endif 
2bbc			; skip dict stub 
2bbc cd 68 23			call forth_tok_next 
2bbf			 
2bbf			 
2bbf			; while we have words to look for 
2bbf			 
2bbf 7e			ld a, (hl)      
2bc0			if DEBUG_FORTH_WORDS 
2bc0				DMARK "LSk" 
2bc0 f5				push af  
2bc1 3a d5 2b			ld a, (.dmark)  
2bc4 32 6b ee			ld (debug_mark),a  
2bc7 3a d6 2b			ld a, (.dmark+1)  
2bca 32 6c ee			ld (debug_mark+1),a  
2bcd 3a d7 2b			ld a, (.dmark+2)  
2bd0 32 6d ee			ld (debug_mark+2),a  
2bd3 18 03			jr .pastdmark  
2bd5 ..			.dmark: db "LSk"  
2bd8 f1			.pastdmark: pop af  
2bd9			endm  
# End of macro DMARK
2bd9				CALLMONITOR 
2bd9 cd 6f ee			call debug_vector  
2bdc				endm  
# End of macro CALLMONITOR
2bdc			endif 
2bdc				;cp WORD_SYS_END 
2bdc				;jp z, .lunotfound 
2bdc			 
2bdc					; if we hit non uwords then gone too far 
2bdc fe 01				cp WORD_SYS_UWORD 
2bde c2 10 2d				jp nz, .lunotfound 
2be1			 
2be1				if DEBUG_FORTH_WORDS 
2be1					DMARK "LSu" 
2be1 f5				push af  
2be2 3a f6 2b			ld a, (.dmark)  
2be5 32 6b ee			ld (debug_mark),a  
2be8 3a f7 2b			ld a, (.dmark+1)  
2beb 32 6c ee			ld (debug_mark+1),a  
2bee 3a f8 2b			ld a, (.dmark+2)  
2bf1 32 6d ee			ld (debug_mark+2),a  
2bf4 18 03			jr .pastdmark  
2bf6 ..			.dmark: db "LSu"  
2bf9 f1			.pastdmark: pop af  
2bfa			endm  
# End of macro DMARK
2bfa					CALLMONITOR 
2bfa cd 6f ee			call debug_vector  
2bfd				endm  
# End of macro CALLMONITOR
2bfd				endif 
2bfd			 
2bfd					; found a uword but is it the one we want... 
2bfd			 
2bfd c5					push bc     ; uword to find is on bc 
2bfe d1					pop de 
2bff			 
2bff e5					push hl  ; to save the ptr 
2c00			 
2c00					; skip opcode 
2c00 23					inc hl  
2c01					; skip next ptr 
2c01 23					inc hl  
2c02 23					inc hl 
2c03					; skip len 
2c03 23					inc hl 
2c04			 
2c04				if DEBUG_FORTH_WORDS 
2c04					DMARK "LSc" 
2c04 f5				push af  
2c05 3a 19 2c			ld a, (.dmark)  
2c08 32 6b ee			ld (debug_mark),a  
2c0b 3a 1a 2c			ld a, (.dmark+1)  
2c0e 32 6c ee			ld (debug_mark+1),a  
2c11 3a 1b 2c			ld a, (.dmark+2)  
2c14 32 6d ee			ld (debug_mark+2),a  
2c17 18 03			jr .pastdmark  
2c19 ..			.dmark: db "LSc"  
2c1c f1			.pastdmark: pop af  
2c1d			endm  
# End of macro DMARK
2c1d					CALLMONITOR 
2c1d cd 6f ee			call debug_vector  
2c20				endm  
# End of macro CALLMONITOR
2c20				endif 
2c20			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2c20			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2c20			; Nope that has gone the other way. It needs to be exact not on first zero 
2c20			;		call strcmp 
2c20 c5					push bc 
2c21 cd a1 14				call StrictStrCmp 
2c24 c1					pop bc 
2c25 c2 9f 2b				jp nz, .ldouscanm 
2c28				 
2c28			 
2c28			 
2c28					; we have a uword so push its name to the stack 
2c28			 
2c28			;	   	push hl  ; save so we can move to next dict block 
2c28 e1			pop hl 
2c29			 
2c29				if DEBUG_FORTH_WORDS 
2c29					DMARK "LSm" 
2c29 f5				push af  
2c2a 3a 3e 2c			ld a, (.dmark)  
2c2d 32 6b ee			ld (debug_mark),a  
2c30 3a 3f 2c			ld a, (.dmark+1)  
2c33 32 6c ee			ld (debug_mark+1),a  
2c36 3a 40 2c			ld a, (.dmark+2)  
2c39 32 6d ee			ld (debug_mark+2),a  
2c3c 18 03			jr .pastdmark  
2c3e ..			.dmark: db "LSm"  
2c41 f1			.pastdmark: pop af  
2c42			endm  
# End of macro DMARK
2c42					CALLMONITOR 
2c42 cd 6f ee			call debug_vector  
2c45				endm  
# End of macro CALLMONITOR
2c45				endif 
2c45			 
2c45					; skip opcode 
2c45 23					inc hl  
2c46					; skip next ptr 
2c46 23					inc hl  
2c47 23					inc hl 
2c48					; skip len 
2c48 7e					ld a, (hl)   ; save length to add 
2c49				if DEBUG_FORTH_WORDS 
2c49					DMARK "LS2" 
2c49 f5				push af  
2c4a 3a 5e 2c			ld a, (.dmark)  
2c4d 32 6b ee			ld (debug_mark),a  
2c50 3a 5f 2c			ld a, (.dmark+1)  
2c53 32 6c ee			ld (debug_mark+1),a  
2c56 3a 60 2c			ld a, (.dmark+2)  
2c59 32 6d ee			ld (debug_mark+2),a  
2c5c 18 03			jr .pastdmark  
2c5e ..			.dmark: db "LS2"  
2c61 f1			.pastdmark: pop af  
2c62			endm  
# End of macro DMARK
2c62					CALLMONITOR 
2c62 cd 6f ee			call debug_vector  
2c65				endm  
# End of macro CALLMONITOR
2c65				endif 
2c65			 
2c65					; save this location 
2c65				 
2c65 e5					push hl 
2c66			 
2c66 23					inc hl 
2c67 11 c3 e2				ld de, scratch+2 
2c6a 4f					ld c, a 
2c6b 06 00				ld b, 0 
2c6d			 
2c6d				if DEBUG_FORTH_WORDS 
2c6d					DMARK "LSn" 
2c6d f5				push af  
2c6e 3a 82 2c			ld a, (.dmark)  
2c71 32 6b ee			ld (debug_mark),a  
2c74 3a 83 2c			ld a, (.dmark+1)  
2c77 32 6c ee			ld (debug_mark+1),a  
2c7a 3a 84 2c			ld a, (.dmark+2)  
2c7d 32 6d ee			ld (debug_mark+2),a  
2c80 18 03			jr .pastdmark  
2c82 ..			.dmark: db "LSn"  
2c85 f1			.pastdmark: pop af  
2c86			endm  
# End of macro DMARK
2c86					CALLMONITOR 
2c86 cd 6f ee			call debug_vector  
2c89				endm  
# End of macro CALLMONITOR
2c89				endif 
2c89			 
2c89					; copy uword name to scratch 
2c89			 
2c89 ed b0				ldir 
2c8b			 
2c8b 1b					dec de 
2c8c 3e 20				ld a, ' '    ; change null to space 
2c8e 12					ld (de), a 
2c8f			 
2c8f 13					inc de 
2c90			 
2c90 d5					push de 
2c91 c1					pop bc     ; move scratch pointer to end of word name and save it 
2c92			 
2c92 e1					pop hl 
2c93 7e					ld a, (hl) 
2c94					;inc hl 
2c94					; skip word string 
2c94 cd e6 0d				call addatohl 
2c97			 
2c97 23					inc hl 
2c98			 
2c98				if DEBUG_FORTH_WORDS 
2c98					DMARK "LS3" 
2c98 f5				push af  
2c99 3a ad 2c			ld a, (.dmark)  
2c9c 32 6b ee			ld (debug_mark),a  
2c9f 3a ae 2c			ld a, (.dmark+1)  
2ca2 32 6c ee			ld (debug_mark+1),a  
2ca5 3a af 2c			ld a, (.dmark+2)  
2ca8 32 6d ee			ld (debug_mark+2),a  
2cab 18 03			jr .pastdmark  
2cad ..			.dmark: db "LS3"  
2cb0 f1			.pastdmark: pop af  
2cb1			endm  
# End of macro DMARK
2cb1					CALLMONITOR 
2cb1 cd 6f ee			call debug_vector  
2cb4				endm  
# End of macro CALLMONITOR
2cb4				endif 
2cb4					; should now be at the start of the machine code to setup the eval of the uword 
2cb4					; now locate the ptr to the string defintion 
2cb4			 
2cb4					; skip ld hl, 
2cb4					; then load the ptr 
2cb4			; TODO use get from hl ptr 
2cb4 23					inc hl 
2cb5 5e					ld e, (hl) 
2cb6 23					inc hl 
2cb7 56					ld d, (hl) 
2cb8 eb					ex de, hl 
2cb9			 
2cb9			 
2cb9				if DEBUG_FORTH_WORDS 
2cb9					DMARK "LSt" 
2cb9 f5				push af  
2cba 3a ce 2c			ld a, (.dmark)  
2cbd 32 6b ee			ld (debug_mark),a  
2cc0 3a cf 2c			ld a, (.dmark+1)  
2cc3 32 6c ee			ld (debug_mark+1),a  
2cc6 3a d0 2c			ld a, (.dmark+2)  
2cc9 32 6d ee			ld (debug_mark+2),a  
2ccc 18 03			jr .pastdmark  
2cce ..			.dmark: db "LSt"  
2cd1 f1			.pastdmark: pop af  
2cd2			endm  
# End of macro DMARK
2cd2					CALLMONITOR 
2cd2 cd 6f ee			call debug_vector  
2cd5				endm  
# End of macro CALLMONITOR
2cd5				endif 
2cd5			 
2cd5			; cant push right now due to tokenised strings  
2cd5			 
2cd5			; get the destination of where to copy this definition to. 
2cd5			 
2cd5 c5					push bc 
2cd6 d1					pop de 
2cd7			 
2cd7 7e			.listl:         ld a,(hl) 
2cd8 fe 00				cp 0 
2cda 28 09				jr z, .lreplsp     ; replace zero with space 
2cdc					;cp FORTH_END_BUFFER 
2cdc fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2cde 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ce0				 
2ce0					; just copy this char as is then 
2ce0			 
2ce0 12					ld (de), a 
2ce1			 
2ce1 23			.listnxt:	inc hl 
2ce2 13					inc de 
2ce3 18 f2				jr .listl 
2ce5			 
2ce5 3e 20		.lreplsp:	ld a,' ' 
2ce7 12					ld (de), a 
2ce8 18 f7				jr .listnxt 
2cea			 
2cea			; close up uword def 
2cea			 
2cea			.listdone: 
2cea 12					ld (de), a 
2ceb 13					inc de 
2cec 3e 00				ld a, 0 
2cee 12					ld (de), a 
2cef			 
2cef			; now have def so clean up and push to stack 
2cef			 
2cef 21 c1 e2				ld hl, scratch 
2cf2				if DEBUG_FORTH_WORDS 
2cf2					DMARK "Ltp" 
2cf2 f5				push af  
2cf3 3a 07 2d			ld a, (.dmark)  
2cf6 32 6b ee			ld (debug_mark),a  
2cf9 3a 08 2d			ld a, (.dmark+1)  
2cfc 32 6c ee			ld (debug_mark+1),a  
2cff 3a 09 2d			ld a, (.dmark+2)  
2d02 32 6d ee			ld (debug_mark+2),a  
2d05 18 03			jr .pastdmark  
2d07 ..			.dmark: db "Ltp"  
2d0a f1			.pastdmark: pop af  
2d0b			endm  
# End of macro DMARK
2d0b					CALLMONITOR 
2d0b cd 6f ee			call debug_vector  
2d0e				endm  
# End of macro CALLMONITOR
2d0e				endif 
2d0e			 
2d0e 18 1f			jr .listpush 
2d10			 
2d10			;.lnuword:	pop hl 
2d10			;		call forth_tok_next 
2d10			;		jp .ldouscan  
2d10			 
2d10			.lunotfound:		  
2d10			 
2d10				if DEBUG_FORTH_WORDS 
2d10					DMARK "LSn" 
2d10 f5				push af  
2d11 3a 25 2d			ld a, (.dmark)  
2d14 32 6b ee			ld (debug_mark),a  
2d17 3a 26 2d			ld a, (.dmark+1)  
2d1a 32 6c ee			ld (debug_mark+1),a  
2d1d 3a 27 2d			ld a, (.dmark+2)  
2d20 32 6d ee			ld (debug_mark+2),a  
2d23 18 03			jr .pastdmark  
2d25 ..			.dmark: db "LSn"  
2d28 f1			.pastdmark: pop af  
2d29			endm  
# End of macro DMARK
2d29					CALLMONITOR 
2d29 cd 6f ee			call debug_vector  
2d2c				endm  
# End of macro CALLMONITOR
2d2c				endif 
2d2c			 
2d2c					 
2d2c			;		FORTH_DSP_POP 
2d2c			;		ld hl, .luno 
2d2c			 
2d2c					NEXTW			 
2d2c c3 17 22			jp macro_next 
2d2f				endm 
# End of macro NEXTW
2d2f			 
2d2f			.listpush: 
2d2f				if DEBUG_FORTH_WORDS 
2d2f					DMARK "LS>" 
2d2f f5				push af  
2d30 3a 44 2d			ld a, (.dmark)  
2d33 32 6b ee			ld (debug_mark),a  
2d36 3a 45 2d			ld a, (.dmark+1)  
2d39 32 6c ee			ld (debug_mark+1),a  
2d3c 3a 46 2d			ld a, (.dmark+2)  
2d3f 32 6d ee			ld (debug_mark+2),a  
2d42 18 03			jr .pastdmark  
2d44 ..			.dmark: db "LS>"  
2d47 f1			.pastdmark: pop af  
2d48			endm  
# End of macro DMARK
2d48					CALLMONITOR 
2d48 cd 6f ee			call debug_vector  
2d4b				endm  
# End of macro CALLMONITOR
2d4b				endif 
2d4b cd d8 1e				call forth_push_str 
2d4e			 
2d4e			 
2d4e			 
2d4e					NEXTW 
2d4e c3 17 22			jp macro_next 
2d51				endm 
# End of macro NEXTW
2d51			 
2d51			;.luno:    db "Word not found",0 
2d51			 
2d51			 
2d51			 
2d51			 
2d51			 
2d51			;		push hl   ; save pointer to start of uword def string 
2d51			; 
2d51			;; look for FORTH_EOL_LINE 
2d51			;		ld a, FORTH_END_BUFFER 
2d51			;		call strlent 
2d51			; 
2d51			;		inc hl		 ; space for coln def 
2d51			;		inc hl 
2d51			;		inc hl          ; space for terms 
2d51			;		inc hl 
2d51			; 
2d51			;		ld a, 20   ; TODO get actual length 
2d51			;		call addatohl    ; include a random amount of room for the uword name 
2d51			; 
2d51			;		 
2d51			;	if DEBUG_FORTH_WORDS 
2d51			;		DMARK "Lt1" 
2d51			;		CALLMONITOR 
2d51			;	endif 
2d51			;		 
2d51			; 
2d51			;; malloc space for the string because we cant change it 
2d51			; 
2d51			;		call malloc 
2d51			;	if DEBUG_FORTH_MALLOC_GUARD 
2d51			;		push af 
2d51			;		call ishlzero 
2d51			;		pop af 
2d51			;		 
2d51			;		call z,malloc_error 
2d51			;	endif 
2d51			; 
2d51			;	if DEBUG_FORTH_WORDS 
2d51			;		DMARK "Lt2" 
2d51			;		CALLMONITOR 
2d51			;	endif 
2d51			;		pop de 
2d51			;		push hl    ; push the malloc to release later 
2d51			;		push hl   ;  push back a copy for the later stack push 
2d51			;		 
2d51			;; copy the string swapping out the zero terms for spaces 
2d51			; 
2d51			;		; de has our source 
2d51			;		; hl has our dest 
2d51			; 
2d51			;; add the coln def 
2d51			; 
2d51			;		ld a, ':' 
2d51			;		ld (hl), a 
2d51			;		inc hl 
2d51			;		ld a, ' ' 
2d51			;		ld (hl), a 
2d51			;		inc hl 
2d51			; 
2d51			;; add the uname word 
2d51			;		push de   ; save our string for now 
2d51			;		ex de, hl 
2d51			; 
2d51			;		FORTH_DSP_VALUE 
2d51			;		;v5 FORTH_DSP_VALUE 
2d51			; 
2d51			;		inc hl   ; skip type but we know by now this is OK 
2d51			; 
2d51			;.luword:	ld a,(hl) 
2d51			;		cp 0 
2d51			;		jr z, .luword2 
2d51			;		ld (de), a 
2d51			;		inc de 
2d51			;		inc hl 
2d51			;		jr .luword 
2d51			; 
2d51			;.luword2:	ld a, ' ' 
2d51			;		ld (de), a 
2d51			;;		inc hl 
2d51			;;		inc de 
2d51			;;		ld (de), a 
2d51			;;		inc hl 
2d51			;		inc de 
2d51			; 
2d51			;		ex de, hl 
2d51			;		pop de 
2d51			;		 
2d51			;		 
2d51			; 
2d51			;; detoken that string and copy it 
2d51			; 
2d51			;	if DEBUG_FORTH_WORDS 
2d51			;		DMARK "Lt2" 
2d51			;		CALLMONITOR 
2d51			;	endif 
2d51			;.ldetok:	ld a, (de) 
2d51			;		cp FORTH_END_BUFFER 
2d51			;		jr z, .ldetokend 
2d51			;		; swap out any zero term for space 
2d51			;		cp 0 
2d51			;		jr nz, .ldetoknext 
2d51			;		ld a, ' ' 
2d51			; 
2d51			;	if DEBUG_FORTH_WORDS 
2d51			;		DMARK "LtS" 
2d51			;		CALLMONITOR 
2d51			;	endif 
2d51			;.ldetoknext:	ld (hl), a 
2d51			;		inc de 
2d51			;		inc hl 
2d51			;		jr .ldetok 
2d51			; 
2d51			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2d51			;		ld (hl), a  
2d51			; 
2d51			;; free that temp malloc 
2d51			; 
2d51			;		pop hl    
2d51			; 
2d51			;	if DEBUG_FORTH_WORDS 
2d51			;		DMARK "Lt4" 
2d51			;		CALLMONITOR 
2d51			;	endif 
2d51			;		call forth_apushstrhl 
2d51			; 
2d51			;		; get rid of temp malloc area 
2d51			; 
2d51			;		pop hl 
2d51			;		call free 
2d51			; 
2d51			;		jr .ludone 
2d51			; 
2d51			;.lnuword:	pop hl 
2d51			;		call forth_tok_next 
2d51			;		jp .ldouscan  
2d51			; 
2d51			;.ludone:		 pop hl 
2d51			; 
2d51					NEXTW 
2d51 c3 17 22			jp macro_next 
2d54				endm 
# End of macro NEXTW
2d54			 
2d54			.FORGET: 
2d54				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2d54 5d				db WORD_SYS_CORE+73             
2d55 cd 2d			dw .NOP            
2d57 07				db 6 + 1 
2d58 .. 00			db "FORGET",0              
2d5f				endm 
# End of macro CWHEAD
2d5f			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2d5f			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2d5f			; | |  
2d5f			; | | e.g. "MORE" forget 
2d5f					if DEBUG_FORTH_WORDS_KEY 
2d5f						DMARK "FRG" 
2d5f f5				push af  
2d60 3a 74 2d			ld a, (.dmark)  
2d63 32 6b ee			ld (debug_mark),a  
2d66 3a 75 2d			ld a, (.dmark+1)  
2d69 32 6c ee			ld (debug_mark+1),a  
2d6c 3a 76 2d			ld a, (.dmark+2)  
2d6f 32 6d ee			ld (debug_mark+2),a  
2d72 18 03			jr .pastdmark  
2d74 ..			.dmark: db "FRG"  
2d77 f1			.pastdmark: pop af  
2d78			endm  
# End of macro DMARK
2d78						CALLMONITOR 
2d78 cd 6f ee			call debug_vector  
2d7b				endm  
# End of macro CALLMONITOR
2d7b					endif 
2d7b			 
2d7b				; find uword 
2d7b			        ; update start of word with "_" 
2d7b				; replace uword with deleted flag 
2d7b			 
2d7b			 
2d7b			;	if DEBUG_FORTH_WORDS 
2d7b			;		DMARK "FOG" 
2d7b			;		CALLMONITOR 
2d7b			;	endif 
2d7b			 
2d7b			 
2d7b					; Get ptr to the word we need to look up 
2d7b			 
2d7b					FORTH_DSP_VALUEHL 
2d7b cd 61 20			call macro_dsp_valuehl 
2d7e				endm 
# End of macro FORTH_DSP_VALUEHL
2d7e					;v5 FORTH_DSP_VALUE 
2d7e				; TODO type check 
2d7e			;		inc hl    ; Skip type check  
2d7e e5					push hl 
2d7f c1					pop bc 
2d80			;		ex de, hl    ; put into DE 
2d80			 
2d80			 
2d80 21 5f 68				ld hl, baseram 
2d83					;ld hl, baseusermem 
2d83			 
2d83				; skip dict stub 
2d83			;	call forth_tok_next 
2d83 e5			push hl   ; sacreifical push 
2d84			 
2d84			.fldouscanm: 
2d84 e1				pop hl 
2d85			.fldouscan: 
2d85			;	if DEBUG_FORTH_WORDS 
2d85			;		DMARK "LSs" 
2d85			;		CALLMONITOR 
2d85			;	endif 
2d85				; skip dict stub 
2d85 cd 68 23				call forth_tok_next 
2d88			 
2d88			 
2d88			; while we have words to look for 
2d88			 
2d88 7e				ld a, (hl)      
2d89			;	if DEBUG_FORTH_WORDS 
2d89			;		DMARK "LSk" 
2d89			;		CALLMONITOR 
2d89			;	endif 
2d89 fe 00				cp WORD_SYS_END 
2d8b ca c7 2d				jp z, .flunotfound 
2d8e fe 01				cp WORD_SYS_UWORD 
2d90 c2 85 2d				jp nz, .fldouscan 
2d93			 
2d93			;	if DEBUG_FORTH_WORDS 
2d93			;		DMARK "LSu" 
2d93			;		CALLMONITOR 
2d93			;	endif 
2d93			 
2d93					; found a uword but is it the one we want... 
2d93			 
2d93 c5					push bc     ; uword to find is on bc 
2d94 d1					pop de 
2d95			 
2d95 e5					push hl  ; to save the ptr 
2d96			 
2d96					; skip opcode 
2d96 23					inc hl  
2d97					; skip next ptr 
2d97 23					inc hl  
2d98 23					inc hl 
2d99					; skip len 
2d99 23					inc hl 
2d9a			 
2d9a			;	if DEBUG_FORTH_WORDS 
2d9a			;		DMARK "LSc" 
2d9a			;		CALLMONITOR 
2d9a			;	endif 
2d9a cd 94 14				call strcmp 
2d9d c2 84 2d				jp nz, .fldouscanm 
2da0			; 
2da0			; 
2da0			;; while we have words to look for 
2da0			; 
2da0			;.fdouscan:	ld a, (hl)      
2da0			;	if DEBUG_FORTH_WORDS 
2da0			;		DMARK "LSs" 
2da0			;		CALLMONITOR 
2da0			;	endif 
2da0			;		cp WORD_SYS_END 
2da0			;		jp z, .fudone 
2da0			;		cp WORD_SYS_UWORD 
2da0			;		jp nz, .fnuword 
2da0			; 
2da0			;	if DEBUG_FORTH_WORDS 
2da0			;		DMARK "FGu" 
2da0			;		CALLMONITOR 
2da0			;	endif 
2da0			; 
2da0			;		; found a uword but is it the one we want... 
2da0			; 
2da0			; 
2da0			;	        pop de   ; get back the dsp name 
2da0			;		push de 
2da0			; 
2da0			;		push hl  ; to save the ptr 
2da0			; 
2da0			;		; skip opcode 
2da0			;		inc hl  
2da0			;		; skip next ptr 
2da0			;		inc hl  
2da0			;		inc hl 
2da0			;		; skip len 
2da0			;		inc hl 
2da0			; 
2da0			;	if DEBUG_FORTH_WORDS 
2da0			;		DMARK "FGc" 
2da0			;		CALLMONITOR 
2da0			;	endif 
2da0			;		call strcmp 
2da0			;		jp nz, .fnuword 
2da0			 
2da0			 
2da0 e1			pop hl 
2da1			 
2da1				 
2da1				if DEBUG_FORTH_WORDS 
2da1					DMARK "FGm" 
2da1 f5				push af  
2da2 3a b6 2d			ld a, (.dmark)  
2da5 32 6b ee			ld (debug_mark),a  
2da8 3a b7 2d			ld a, (.dmark+1)  
2dab 32 6c ee			ld (debug_mark+1),a  
2dae 3a b8 2d			ld a, (.dmark+2)  
2db1 32 6d ee			ld (debug_mark+2),a  
2db4 18 03			jr .pastdmark  
2db6 ..			.dmark: db "FGm"  
2db9 f1			.pastdmark: pop af  
2dba			endm  
# End of macro DMARK
2dba					CALLMONITOR 
2dba cd 6f ee			call debug_vector  
2dbd				endm  
# End of macro CALLMONITOR
2dbd				endif 
2dbd			 
2dbd			 
2dbd			 
2dbd					; we have a uword so push its name to the stack 
2dbd			 
2dbd			;	   	push hl  ; save so we can move to next dict block 
2dbd			;pop hl 
2dbd			 
2dbd					; update opcode to deleted 
2dbd 3e 03				ld a, WORD_SYS_DELETED 
2dbf 77					ld (hl), a 
2dc0			 
2dc0 23					inc hl  
2dc1					; skip next ptr 
2dc1 23					inc hl  
2dc2 23					inc hl 
2dc3					; skip len 
2dc3 23					inc hl 
2dc4			 
2dc4					; TODO change parser to skip deleted words but for now mark it out 
2dc4 3e 5f				ld a, "_" 
2dc6 77					ld  (hl),a 
2dc7			 
2dc7			;		jr .fudone 
2dc7			; 
2dc7			;.fnuword:	pop hl 
2dc7			;		call forth_tok_next 
2dc7			;		jp .fdouscan  
2dc7			 
2dc7			.flunotfound:		  
2dc7			 
2dc7			 
2dc7					 
2dc7					FORTH_DSP_POP 
2dc7 cd 19 21			call macro_forth_dsp_pop 
2dca				endm 
# End of macro FORTH_DSP_POP
2dca			;		ld hl, .luno 
2dca			;.fudone:		 pop hl 
2dca					NEXTW 
2dca c3 17 22			jp macro_next 
2dcd				endm 
# End of macro NEXTW
2dcd			.NOP: 
2dcd				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2dcd 61				db WORD_SYS_CORE+77             
2dce f4 2d			dw .COMO            
2dd0 04				db 3 + 1 
2dd1 .. 00			db "NOP",0              
2dd5				endm 
# End of macro CWHEAD
2dd5			; | NOP (  --  ) Do nothing | DONE 
2dd5					if DEBUG_FORTH_WORDS_KEY 
2dd5						DMARK "NOP" 
2dd5 f5				push af  
2dd6 3a ea 2d			ld a, (.dmark)  
2dd9 32 6b ee			ld (debug_mark),a  
2ddc 3a eb 2d			ld a, (.dmark+1)  
2ddf 32 6c ee			ld (debug_mark+1),a  
2de2 3a ec 2d			ld a, (.dmark+2)  
2de5 32 6d ee			ld (debug_mark+2),a  
2de8 18 03			jr .pastdmark  
2dea ..			.dmark: db "NOP"  
2ded f1			.pastdmark: pop af  
2dee			endm  
# End of macro DMARK
2dee						CALLMONITOR 
2dee cd 6f ee			call debug_vector  
2df1				endm  
# End of macro CALLMONITOR
2df1					endif 
2df1				       NEXTW 
2df1 c3 17 22			jp macro_next 
2df4				endm 
# End of macro NEXTW
2df4			.COMO: 
2df4				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2df4 6e				db WORD_SYS_CORE+90             
2df5 46 2e			dw .COMC            
2df7 02				db 1 + 1 
2df8 .. 00			db "(",0              
2dfa				endm 
# End of macro CWHEAD
2dfa			; | ( ( -- )  Start of comment | DONE 
2dfa			 
2dfa			 
2dfa 2a c2 e5				ld hl, ( os_tok_ptr) 
2dfd 11 41 2e			ld de, .closepar 
2e00					 
2e00					if DEBUG_FORTH_WORDS 
2e00						DMARK ").." 
2e00 f5				push af  
2e01 3a 15 2e			ld a, (.dmark)  
2e04 32 6b ee			ld (debug_mark),a  
2e07 3a 16 2e			ld a, (.dmark+1)  
2e0a 32 6c ee			ld (debug_mark+1),a  
2e0d 3a 17 2e			ld a, (.dmark+2)  
2e10 32 6d ee			ld (debug_mark+2),a  
2e13 18 03			jr .pastdmark  
2e15 ..			.dmark: db ").."  
2e18 f1			.pastdmark: pop af  
2e19			endm  
# End of macro DMARK
2e19						CALLMONITOR 
2e19 cd 6f ee			call debug_vector  
2e1c				endm  
# End of macro CALLMONITOR
2e1c					endif 
2e1c cd 32 23			call findnexttok  
2e1f			 
2e1f					if DEBUG_FORTH_WORDS 
2e1f						DMARK "IF5" 
2e1f f5				push af  
2e20 3a 34 2e			ld a, (.dmark)  
2e23 32 6b ee			ld (debug_mark),a  
2e26 3a 35 2e			ld a, (.dmark+1)  
2e29 32 6c ee			ld (debug_mark+1),a  
2e2c 3a 36 2e			ld a, (.dmark+2)  
2e2f 32 6d ee			ld (debug_mark+2),a  
2e32 18 03			jr .pastdmark  
2e34 ..			.dmark: db "IF5"  
2e37 f1			.pastdmark: pop af  
2e38			endm  
# End of macro DMARK
2e38						CALLMONITOR 
2e38 cd 6f ee			call debug_vector  
2e3b				endm  
# End of macro CALLMONITOR
2e3b					endif 
2e3b				; replace below with ) exec using tok_ptr 
2e3b 22 c2 e5			ld (os_tok_ptr), hl 
2e3e c3 a8 22			jp exec1 
2e41			 
2e41 .. 00			.closepar:   db ")",0 
2e43			 
2e43				       NEXTW 
2e43 c3 17 22			jp macro_next 
2e46				endm 
# End of macro NEXTW
2e46			.COMC: 
2e46				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2e46 6f				db WORD_SYS_CORE+91             
2e47 4f 2e			dw .SCRATCH            
2e49 02				db 1 + 1 
2e4a .. 00			db ")",0              
2e4c				endm 
# End of macro CWHEAD
2e4c			; | ) ( -- )  End of comment |  DONE  
2e4c				       NEXTW 
2e4c c3 17 22			jp macro_next 
2e4f				endm 
# End of macro NEXTW
2e4f			 
2e4f			.SCRATCH: 
2e4f				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2e4f 6f				db WORD_SYS_CORE+91             
2e50 8a 2e			dw .INC            
2e52 08				db 7 + 1 
2e53 .. 00			db "SCRATCH",0              
2e5b				endm 
# End of macro CWHEAD
2e5b			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2e5b			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2e5b			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2e5b			; | |  
2e5b			; | | e.g.    : score $00 scratch ; 
2e5b			; | |  
2e5b			; | | $00 score ! 
2e5b			; | | $01 score +! 
2e5b			; | |  
2e5b			; | | e.g.   : varword $0a scratch ;  
2e5b			; | | 
2e5b			; | | $8000 varword ! 
2e5b					if DEBUG_FORTH_WORDS_KEY 
2e5b						DMARK "SCR" 
2e5b f5				push af  
2e5c 3a 70 2e			ld a, (.dmark)  
2e5f 32 6b ee			ld (debug_mark),a  
2e62 3a 71 2e			ld a, (.dmark+1)  
2e65 32 6c ee			ld (debug_mark+1),a  
2e68 3a 72 2e			ld a, (.dmark+2)  
2e6b 32 6d ee			ld (debug_mark+2),a  
2e6e 18 03			jr .pastdmark  
2e70 ..			.dmark: db "SCR"  
2e73 f1			.pastdmark: pop af  
2e74			endm  
# End of macro DMARK
2e74						CALLMONITOR 
2e74 cd 6f ee			call debug_vector  
2e77				endm  
# End of macro CALLMONITOR
2e77					endif 
2e77			 
2e77					FORTH_DSP_VALUEHL 
2e77 cd 61 20			call macro_dsp_valuehl 
2e7a				endm 
# End of macro FORTH_DSP_VALUEHL
2e7a				 
2e7a					FORTH_DSP_POP 
2e7a cd 19 21			call macro_forth_dsp_pop 
2e7d				endm 
# End of macro FORTH_DSP_POP
2e7d			 
2e7d 7d					ld a, l 
2e7e 21 e6 e7				ld hl, os_var_array 
2e81 cd e6 0d				call addatohl 
2e84			 
2e84 cd 6a 1e				call forth_push_numhl 
2e87			 
2e87				       NEXTW 
2e87 c3 17 22			jp macro_next 
2e8a				endm 
# End of macro NEXTW
2e8a			 
2e8a			.INC: 
2e8a				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2e8a 6f				db WORD_SYS_CORE+91             
2e8b e0 2e			dw .DEC            
2e8d 03				db 2 + 1 
2e8e .. 00			db "+!",0              
2e91				endm 
# End of macro CWHEAD
2e91			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2e91					if DEBUG_FORTH_WORDS_KEY 
2e91						DMARK "+s_" 
2e91 f5				push af  
2e92 3a a6 2e			ld a, (.dmark)  
2e95 32 6b ee			ld (debug_mark),a  
2e98 3a a7 2e			ld a, (.dmark+1)  
2e9b 32 6c ee			ld (debug_mark+1),a  
2e9e 3a a8 2e			ld a, (.dmark+2)  
2ea1 32 6d ee			ld (debug_mark+2),a  
2ea4 18 03			jr .pastdmark  
2ea6 ..			.dmark: db "+s_"  
2ea9 f1			.pastdmark: pop af  
2eaa			endm  
# End of macro DMARK
2eaa						CALLMONITOR 
2eaa cd 6f ee			call debug_vector  
2ead				endm  
# End of macro CALLMONITOR
2ead					endif 
2ead			 
2ead					FORTH_DSP_VALUEHL 
2ead cd 61 20			call macro_dsp_valuehl 
2eb0				endm 
# End of macro FORTH_DSP_VALUEHL
2eb0			 
2eb0 e5					push hl   ; save address 
2eb1			 
2eb1					FORTH_DSP_POP 
2eb1 cd 19 21			call macro_forth_dsp_pop 
2eb4				endm 
# End of macro FORTH_DSP_POP
2eb4			 
2eb4					FORTH_DSP_VALUEHL 
2eb4 cd 61 20			call macro_dsp_valuehl 
2eb7				endm 
# End of macro FORTH_DSP_VALUEHL
2eb7			 
2eb7 e5					push hl 
2eb8					FORTH_DSP_POP 
2eb8 cd 19 21			call macro_forth_dsp_pop 
2ebb				endm 
# End of macro FORTH_DSP_POP
2ebb e1					pop hl 
2ebc			 
2ebc					; hl contains value to add to byte at a 
2ebc				 
2ebc eb					ex de, hl 
2ebd			 
2ebd e1					pop hl 
2ebe			 
2ebe					if DEBUG_FORTH_WORDS 
2ebe						DMARK "INC" 
2ebe f5				push af  
2ebf 3a d3 2e			ld a, (.dmark)  
2ec2 32 6b ee			ld (debug_mark),a  
2ec5 3a d4 2e			ld a, (.dmark+1)  
2ec8 32 6c ee			ld (debug_mark+1),a  
2ecb 3a d5 2e			ld a, (.dmark+2)  
2ece 32 6d ee			ld (debug_mark+2),a  
2ed1 18 03			jr .pastdmark  
2ed3 ..			.dmark: db "INC"  
2ed6 f1			.pastdmark: pop af  
2ed7			endm  
# End of macro DMARK
2ed7						CALLMONITOR 
2ed7 cd 6f ee			call debug_vector  
2eda				endm  
# End of macro CALLMONITOR
2eda					endif 
2eda			 
2eda 7e					ld a,(hl) 
2edb 83					add e 
2edc 77					ld (hl),a 
2edd			 
2edd			 
2edd			 
2edd				       NEXTW 
2edd c3 17 22			jp macro_next 
2ee0				endm 
# End of macro NEXTW
2ee0			 
2ee0			.DEC: 
2ee0				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2ee0 6f				db WORD_SYS_CORE+91             
2ee1 34 2f			dw .INC2            
2ee3 03				db 2 + 1 
2ee4 .. 00			db "-!",0              
2ee7				endm 
# End of macro CWHEAD
2ee7			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ee7					if DEBUG_FORTH_WORDS_KEY 
2ee7						DMARK "-s_" 
2ee7 f5				push af  
2ee8 3a fc 2e			ld a, (.dmark)  
2eeb 32 6b ee			ld (debug_mark),a  
2eee 3a fd 2e			ld a, (.dmark+1)  
2ef1 32 6c ee			ld (debug_mark+1),a  
2ef4 3a fe 2e			ld a, (.dmark+2)  
2ef7 32 6d ee			ld (debug_mark+2),a  
2efa 18 03			jr .pastdmark  
2efc ..			.dmark: db "-s_"  
2eff f1			.pastdmark: pop af  
2f00			endm  
# End of macro DMARK
2f00						CALLMONITOR 
2f00 cd 6f ee			call debug_vector  
2f03				endm  
# End of macro CALLMONITOR
2f03					endif 
2f03			 
2f03					FORTH_DSP_VALUEHL 
2f03 cd 61 20			call macro_dsp_valuehl 
2f06				endm 
# End of macro FORTH_DSP_VALUEHL
2f06			 
2f06 e5					push hl   ; save address 
2f07			 
2f07					FORTH_DSP_POP 
2f07 cd 19 21			call macro_forth_dsp_pop 
2f0a				endm 
# End of macro FORTH_DSP_POP
2f0a			 
2f0a					FORTH_DSP_VALUEHL 
2f0a cd 61 20			call macro_dsp_valuehl 
2f0d				endm 
# End of macro FORTH_DSP_VALUEHL
2f0d			 
2f0d					; hl contains value to add to byte at a 
2f0d				 
2f0d eb					ex de, hl 
2f0e			 
2f0e e1					pop hl 
2f0f			 
2f0f					if DEBUG_FORTH_WORDS 
2f0f						DMARK "DEC" 
2f0f f5				push af  
2f10 3a 24 2f			ld a, (.dmark)  
2f13 32 6b ee			ld (debug_mark),a  
2f16 3a 25 2f			ld a, (.dmark+1)  
2f19 32 6c ee			ld (debug_mark+1),a  
2f1c 3a 26 2f			ld a, (.dmark+2)  
2f1f 32 6d ee			ld (debug_mark+2),a  
2f22 18 03			jr .pastdmark  
2f24 ..			.dmark: db "DEC"  
2f27 f1			.pastdmark: pop af  
2f28			endm  
# End of macro DMARK
2f28						CALLMONITOR 
2f28 cd 6f ee			call debug_vector  
2f2b				endm  
# End of macro CALLMONITOR
2f2b					endif 
2f2b			 
2f2b 7e					ld a,(hl) 
2f2c 93					sub e 
2f2d 77					ld (hl),a 
2f2e			 
2f2e			 
2f2e					FORTH_DSP_POP 
2f2e cd 19 21			call macro_forth_dsp_pop 
2f31				endm 
# End of macro FORTH_DSP_POP
2f31			 
2f31				       NEXTW 
2f31 c3 17 22			jp macro_next 
2f34				endm 
# End of macro NEXTW
2f34			 
2f34			.INC2: 
2f34				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2f34 6f				db WORD_SYS_CORE+91             
2f35 e1 2f			dw .DEC2            
2f37 04				db 3 + 1 
2f38 .. 00			db "+2!",0              
2f3c				endm 
# End of macro CWHEAD
2f3c			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2f3c			 
2f3c					if DEBUG_FORTH_WORDS_KEY 
2f3c						DMARK "+2s" 
2f3c f5				push af  
2f3d 3a 51 2f			ld a, (.dmark)  
2f40 32 6b ee			ld (debug_mark),a  
2f43 3a 52 2f			ld a, (.dmark+1)  
2f46 32 6c ee			ld (debug_mark+1),a  
2f49 3a 53 2f			ld a, (.dmark+2)  
2f4c 32 6d ee			ld (debug_mark+2),a  
2f4f 18 03			jr .pastdmark  
2f51 ..			.dmark: db "+2s"  
2f54 f1			.pastdmark: pop af  
2f55			endm  
# End of macro DMARK
2f55						CALLMONITOR 
2f55 cd 6f ee			call debug_vector  
2f58				endm  
# End of macro CALLMONITOR
2f58					endif 
2f58			 
2f58					; Address 
2f58			 
2f58					FORTH_DSP_VALUEHL 
2f58 cd 61 20			call macro_dsp_valuehl 
2f5b				endm 
# End of macro FORTH_DSP_VALUEHL
2f5b			 
2f5b e5					push hl    ; save address 
2f5c			 
2f5c					; load content into de 
2f5c			 
2f5c 5e					ld e,(hl) 
2f5d 23					inc hl 
2f5e 56					ld d, (hl) 
2f5f			 
2f5f					if DEBUG_FORTH_WORDS 
2f5f						DMARK "+2a" 
2f5f f5				push af  
2f60 3a 74 2f			ld a, (.dmark)  
2f63 32 6b ee			ld (debug_mark),a  
2f66 3a 75 2f			ld a, (.dmark+1)  
2f69 32 6c ee			ld (debug_mark+1),a  
2f6c 3a 76 2f			ld a, (.dmark+2)  
2f6f 32 6d ee			ld (debug_mark+2),a  
2f72 18 03			jr .pastdmark  
2f74 ..			.dmark: db "+2a"  
2f77 f1			.pastdmark: pop af  
2f78			endm  
# End of macro DMARK
2f78						CALLMONITOR 
2f78 cd 6f ee			call debug_vector  
2f7b				endm  
# End of macro CALLMONITOR
2f7b					endif 
2f7b			 
2f7b					FORTH_DSP_POP 
2f7b cd 19 21			call macro_forth_dsp_pop 
2f7e				endm 
# End of macro FORTH_DSP_POP
2f7e			 
2f7e					; Get value to add 
2f7e			 
2f7e					FORTH_DSP_VALUE 
2f7e cd 4a 20			call macro_forth_dsp_value 
2f81				endm 
# End of macro FORTH_DSP_VALUE
2f81			 
2f81					if DEBUG_FORTH_WORDS 
2f81						DMARK "+2v" 
2f81 f5				push af  
2f82 3a 96 2f			ld a, (.dmark)  
2f85 32 6b ee			ld (debug_mark),a  
2f88 3a 97 2f			ld a, (.dmark+1)  
2f8b 32 6c ee			ld (debug_mark+1),a  
2f8e 3a 98 2f			ld a, (.dmark+2)  
2f91 32 6d ee			ld (debug_mark+2),a  
2f94 18 03			jr .pastdmark  
2f96 ..			.dmark: db "+2v"  
2f99 f1			.pastdmark: pop af  
2f9a			endm  
# End of macro DMARK
2f9a						CALLMONITOR 
2f9a cd 6f ee			call debug_vector  
2f9d				endm  
# End of macro CALLMONITOR
2f9d					endif 
2f9d			 
2f9d 19					add hl, de 
2f9e			 
2f9e					if DEBUG_FORTH_WORDS 
2f9e						DMARK "+2+" 
2f9e f5				push af  
2f9f 3a b3 2f			ld a, (.dmark)  
2fa2 32 6b ee			ld (debug_mark),a  
2fa5 3a b4 2f			ld a, (.dmark+1)  
2fa8 32 6c ee			ld (debug_mark+1),a  
2fab 3a b5 2f			ld a, (.dmark+2)  
2fae 32 6d ee			ld (debug_mark+2),a  
2fb1 18 03			jr .pastdmark  
2fb3 ..			.dmark: db "+2+"  
2fb6 f1			.pastdmark: pop af  
2fb7			endm  
# End of macro DMARK
2fb7						CALLMONITOR 
2fb7 cd 6f ee			call debug_vector  
2fba				endm  
# End of macro CALLMONITOR
2fba					endif 
2fba			 
2fba					; move result to de 
2fba			 
2fba eb					ex de, hl 
2fbb			 
2fbb					; Address 
2fbb			 
2fbb e1					pop hl 
2fbc			 
2fbc					; save it back 
2fbc			 
2fbc 73					ld (hl), e 
2fbd 23					inc hl 
2fbe 72					ld (hl), d 
2fbf			 
2fbf					if DEBUG_FORTH_WORDS 
2fbf						DMARK "+2e" 
2fbf f5				push af  
2fc0 3a d4 2f			ld a, (.dmark)  
2fc3 32 6b ee			ld (debug_mark),a  
2fc6 3a d5 2f			ld a, (.dmark+1)  
2fc9 32 6c ee			ld (debug_mark+1),a  
2fcc 3a d6 2f			ld a, (.dmark+2)  
2fcf 32 6d ee			ld (debug_mark+2),a  
2fd2 18 03			jr .pastdmark  
2fd4 ..			.dmark: db "+2e"  
2fd7 f1			.pastdmark: pop af  
2fd8			endm  
# End of macro DMARK
2fd8						CALLMONITOR 
2fd8 cd 6f ee			call debug_vector  
2fdb				endm  
# End of macro CALLMONITOR
2fdb					endif 
2fdb			 
2fdb			 
2fdb			 
2fdb					FORTH_DSP_POP 
2fdb cd 19 21			call macro_forth_dsp_pop 
2fde				endm 
# End of macro FORTH_DSP_POP
2fde			 
2fde			 
2fde				       NEXTW 
2fde c3 17 22			jp macro_next 
2fe1				endm 
# End of macro NEXTW
2fe1			 
2fe1			.DEC2: 
2fe1				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2fe1 6f				db WORD_SYS_CORE+91             
2fe2 90 30			dw .GET2            
2fe4 04				db 3 + 1 
2fe5 .. 00			db "-2!",0              
2fe9				endm 
# End of macro CWHEAD
2fe9			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2fe9			 
2fe9			 
2fe9					if DEBUG_FORTH_WORDS_KEY 
2fe9						DMARK "-2s" 
2fe9 f5				push af  
2fea 3a fe 2f			ld a, (.dmark)  
2fed 32 6b ee			ld (debug_mark),a  
2ff0 3a ff 2f			ld a, (.dmark+1)  
2ff3 32 6c ee			ld (debug_mark+1),a  
2ff6 3a 00 30			ld a, (.dmark+2)  
2ff9 32 6d ee			ld (debug_mark+2),a  
2ffc 18 03			jr .pastdmark  
2ffe ..			.dmark: db "-2s"  
3001 f1			.pastdmark: pop af  
3002			endm  
# End of macro DMARK
3002						CALLMONITOR 
3002 cd 6f ee			call debug_vector  
3005				endm  
# End of macro CALLMONITOR
3005					endif 
3005			 
3005					; Address 
3005			 
3005					FORTH_DSP_VALUEHL 
3005 cd 61 20			call macro_dsp_valuehl 
3008				endm 
# End of macro FORTH_DSP_VALUEHL
3008			 
3008 e5					push hl    ; save address 
3009			 
3009					; load content into de 
3009			 
3009 5e					ld e,(hl) 
300a 23					inc hl 
300b 56					ld d, (hl) 
300c			 
300c					if DEBUG_FORTH_WORDS 
300c						DMARK "-2a" 
300c f5				push af  
300d 3a 21 30			ld a, (.dmark)  
3010 32 6b ee			ld (debug_mark),a  
3013 3a 22 30			ld a, (.dmark+1)  
3016 32 6c ee			ld (debug_mark+1),a  
3019 3a 23 30			ld a, (.dmark+2)  
301c 32 6d ee			ld (debug_mark+2),a  
301f 18 03			jr .pastdmark  
3021 ..			.dmark: db "-2a"  
3024 f1			.pastdmark: pop af  
3025			endm  
# End of macro DMARK
3025						CALLMONITOR 
3025 cd 6f ee			call debug_vector  
3028				endm  
# End of macro CALLMONITOR
3028					endif 
3028			 
3028					FORTH_DSP_POP 
3028 cd 19 21			call macro_forth_dsp_pop 
302b				endm 
# End of macro FORTH_DSP_POP
302b			 
302b					; Get value to remove 
302b			 
302b					FORTH_DSP_VALUE 
302b cd 4a 20			call macro_forth_dsp_value 
302e				endm 
# End of macro FORTH_DSP_VALUE
302e			 
302e					if DEBUG_FORTH_WORDS 
302e						DMARK "-2v" 
302e f5				push af  
302f 3a 43 30			ld a, (.dmark)  
3032 32 6b ee			ld (debug_mark),a  
3035 3a 44 30			ld a, (.dmark+1)  
3038 32 6c ee			ld (debug_mark+1),a  
303b 3a 45 30			ld a, (.dmark+2)  
303e 32 6d ee			ld (debug_mark+2),a  
3041 18 03			jr .pastdmark  
3043 ..			.dmark: db "-2v"  
3046 f1			.pastdmark: pop af  
3047			endm  
# End of macro DMARK
3047						CALLMONITOR 
3047 cd 6f ee			call debug_vector  
304a				endm  
# End of macro CALLMONITOR
304a					endif 
304a			 
304a eb					ex de, hl 
304b ed 52				sbc hl, de 
304d			 
304d					if DEBUG_FORTH_WORDS 
304d						DMARK "-2d" 
304d f5				push af  
304e 3a 62 30			ld a, (.dmark)  
3051 32 6b ee			ld (debug_mark),a  
3054 3a 63 30			ld a, (.dmark+1)  
3057 32 6c ee			ld (debug_mark+1),a  
305a 3a 64 30			ld a, (.dmark+2)  
305d 32 6d ee			ld (debug_mark+2),a  
3060 18 03			jr .pastdmark  
3062 ..			.dmark: db "-2d"  
3065 f1			.pastdmark: pop af  
3066			endm  
# End of macro DMARK
3066						CALLMONITOR 
3066 cd 6f ee			call debug_vector  
3069				endm  
# End of macro CALLMONITOR
3069					endif 
3069			 
3069					; move result to de 
3069			 
3069 eb					ex de, hl 
306a			 
306a					; Address 
306a			 
306a e1					pop hl 
306b			 
306b					; save it back 
306b			 
306b 73					ld (hl), e 
306c 23					inc hl 
306d 72					ld (hl), d 
306e			 
306e					if DEBUG_FORTH_WORDS 
306e						DMARK "-2e" 
306e f5				push af  
306f 3a 83 30			ld a, (.dmark)  
3072 32 6b ee			ld (debug_mark),a  
3075 3a 84 30			ld a, (.dmark+1)  
3078 32 6c ee			ld (debug_mark+1),a  
307b 3a 85 30			ld a, (.dmark+2)  
307e 32 6d ee			ld (debug_mark+2),a  
3081 18 03			jr .pastdmark  
3083 ..			.dmark: db "-2e"  
3086 f1			.pastdmark: pop af  
3087			endm  
# End of macro DMARK
3087						CALLMONITOR 
3087 cd 6f ee			call debug_vector  
308a				endm  
# End of macro CALLMONITOR
308a					endif 
308a			 
308a			 
308a					FORTH_DSP_POP 
308a cd 19 21			call macro_forth_dsp_pop 
308d				endm 
# End of macro FORTH_DSP_POP
308d			 
308d			 
308d			 
308d				       NEXTW 
308d c3 17 22			jp macro_next 
3090				endm 
# End of macro NEXTW
3090			.GET2: 
3090				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3090 6f				db WORD_SYS_CORE+91             
3091 c5 30			dw .BANG2            
3093 03				db 2 + 1 
3094 .. 00			db "2@",0              
3097				endm 
# End of macro CWHEAD
3097			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3097					if DEBUG_FORTH_WORDS_KEY 
3097						DMARK "2A_" 
3097 f5				push af  
3098 3a ac 30			ld a, (.dmark)  
309b 32 6b ee			ld (debug_mark),a  
309e 3a ad 30			ld a, (.dmark+1)  
30a1 32 6c ee			ld (debug_mark+1),a  
30a4 3a ae 30			ld a, (.dmark+2)  
30a7 32 6d ee			ld (debug_mark+2),a  
30aa 18 03			jr .pastdmark  
30ac ..			.dmark: db "2A_"  
30af f1			.pastdmark: pop af  
30b0			endm  
# End of macro DMARK
30b0						CALLMONITOR 
30b0 cd 6f ee			call debug_vector  
30b3				endm  
# End of macro CALLMONITOR
30b3					endif 
30b3			 
30b3					FORTH_DSP_VALUEHL 
30b3 cd 61 20			call macro_dsp_valuehl 
30b6				endm 
# End of macro FORTH_DSP_VALUEHL
30b6			 
30b6 e5					push hl   ; save address 
30b7			 
30b7					FORTH_DSP_POP 
30b7 cd 19 21			call macro_forth_dsp_pop 
30ba				endm 
# End of macro FORTH_DSP_POP
30ba			 
30ba e1					pop hl 
30bb			 
30bb 5e					ld e, (hl) 
30bc 23					inc hl 
30bd 56					ld d, (hl) 
30be			 
30be eb					ex de, hl 
30bf			 
30bf cd 6a 1e				call forth_push_numhl 
30c2			 
30c2				       NEXTW 
30c2 c3 17 22			jp macro_next 
30c5				endm 
# End of macro NEXTW
30c5			.BANG2: 
30c5				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
30c5 6f				db WORD_SYS_CORE+91             
30c6 fd 30			dw .CONFIG            
30c8 03				db 2 + 1 
30c9 .. 00			db "2!",0              
30cc				endm 
# End of macro CWHEAD
30cc			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
30cc					if DEBUG_FORTH_WORDS_KEY 
30cc						DMARK "2S_" 
30cc f5				push af  
30cd 3a e1 30			ld a, (.dmark)  
30d0 32 6b ee			ld (debug_mark),a  
30d3 3a e2 30			ld a, (.dmark+1)  
30d6 32 6c ee			ld (debug_mark+1),a  
30d9 3a e3 30			ld a, (.dmark+2)  
30dc 32 6d ee			ld (debug_mark+2),a  
30df 18 03			jr .pastdmark  
30e1 ..			.dmark: db "2S_"  
30e4 f1			.pastdmark: pop af  
30e5			endm  
# End of macro DMARK
30e5						CALLMONITOR 
30e5 cd 6f ee			call debug_vector  
30e8				endm  
# End of macro CALLMONITOR
30e8					endif 
30e8			 
30e8					FORTH_DSP_VALUEHL 
30e8 cd 61 20			call macro_dsp_valuehl 
30eb				endm 
# End of macro FORTH_DSP_VALUEHL
30eb			 
30eb e5					push hl   ; save address 
30ec			 
30ec			 
30ec					FORTH_DSP_POP 
30ec cd 19 21			call macro_forth_dsp_pop 
30ef				endm 
# End of macro FORTH_DSP_POP
30ef			 
30ef					 
30ef					FORTH_DSP_VALUEHL 
30ef cd 61 20			call macro_dsp_valuehl 
30f2				endm 
# End of macro FORTH_DSP_VALUEHL
30f2			 
30f2					FORTH_DSP_POP 
30f2 cd 19 21			call macro_forth_dsp_pop 
30f5				endm 
# End of macro FORTH_DSP_POP
30f5			 
30f5 eb					ex de, hl    ; value now in de 
30f6			 
30f6 e1					pop hl 
30f7			 
30f7 73					ld (hl), e 
30f8			 
30f8 23					inc hl 
30f9			 
30f9 72					ld (hl), d 
30fa			 
30fa			 
30fa				       NEXTW 
30fa c3 17 22			jp macro_next 
30fd				endm 
# End of macro NEXTW
30fd			.CONFIG: 
30fd				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
30fd 6f				db WORD_SYS_CORE+91             
30fe 0e 31			dw .ADTOS            
3100 07				db 6 + 1 
3101 .. 00			db "CONFIG",0              
3108				endm 
# End of macro CWHEAD
3108			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3108			 
3108 cd 6a 16				call config 
310b					NEXTW 
310b c3 17 22			jp macro_next 
310e				endm 
# End of macro NEXTW
310e			 
310e			.ADTOS: 
310e				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
310e 6f				db WORD_SYS_CORE+91             
310f 24 31			dw .SBTOS            
3111 03				db 2 + 1 
3112 .. 00			db "1+",0              
3115				endm 
# End of macro CWHEAD
3115			; | 1+ ( u -- u )  Increment value on TOS | DONE 
3115			 
3115					FORTH_DSP_VALUEHL 
3115 cd 61 20			call macro_dsp_valuehl 
3118				endm 
# End of macro FORTH_DSP_VALUEHL
3118 e5					push hl 
3119			 
3119					FORTH_DSP_POP 
3119 cd 19 21			call macro_forth_dsp_pop 
311c				endm 
# End of macro FORTH_DSP_POP
311c e1					pop hl 
311d			 
311d 23					inc hl 
311e cd 6a 1e				call forth_push_numhl 
3121					 
3121					NEXTW 
3121 c3 17 22			jp macro_next 
3124				endm 
# End of macro NEXTW
3124			.SBTOS: 
3124				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
3124 6f				db WORD_SYS_CORE+91             
3125 3a 31			dw .ADSTORE            
3127 03				db 2 + 1 
3128 .. 00			db "1-",0              
312b				endm 
# End of macro CWHEAD
312b			; | 1- ( u -- u )  Decrement value on TOS | DONE 
312b			 
312b					FORTH_DSP_VALUEHL 
312b cd 61 20			call macro_dsp_valuehl 
312e				endm 
# End of macro FORTH_DSP_VALUEHL
312e e5					push hl 
312f			 
312f					FORTH_DSP_POP 
312f cd 19 21			call macro_forth_dsp_pop 
3132				endm 
# End of macro FORTH_DSP_POP
3132 e1					pop hl 
3133			 
3133 2b					dec hl 
3134 cd 6a 1e				call forth_push_numhl 
3137					 
3137					NEXTW 
3137 c3 17 22			jp macro_next 
313a				endm 
# End of macro NEXTW
313a			.ADSTORE: 
313a				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
313a 6f				db WORD_SYS_CORE+91             
313b 50 31			dw .ADWSTORE            
313d 04				db 3 + 1 
313e .. 00			db "1+!",0              
3142				endm 
# End of macro CWHEAD
3142			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
3142			 
3142					FORTH_DSP_VALUEHL 
3142 cd 61 20			call macro_dsp_valuehl 
3145				endm 
# End of macro FORTH_DSP_VALUEHL
3145 e5					push hl 
3146			 
3146					FORTH_DSP_POP 
3146 cd 19 21			call macro_forth_dsp_pop 
3149				endm 
# End of macro FORTH_DSP_POP
3149 e1					pop hl 
314a			 
314a 7e					ld a, (hl) 
314b 3c					inc a 
314c 77					ld (hl), a 
314d					 
314d					NEXTW 
314d c3 17 22			jp macro_next 
3150				endm 
# End of macro NEXTW
3150			.ADWSTORE: 
3150				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
3150 6f				db WORD_SYS_CORE+91             
3151 6e 31			dw .SBSTORE            
3153 05				db 4 + 1 
3154 .. 00			db "1+2!",0              
3159				endm 
# End of macro CWHEAD
3159			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3159			 
3159					FORTH_DSP_VALUEHL 
3159 cd 61 20			call macro_dsp_valuehl 
315c				endm 
# End of macro FORTH_DSP_VALUEHL
315c e5					push hl 
315d			 
315d					FORTH_DSP_POP 
315d cd 19 21			call macro_forth_dsp_pop 
3160				endm 
# End of macro FORTH_DSP_POP
3160 e1					pop hl 
3161			 
3161 e5					push hl 
3162			 
3162 cd 99 21				call loadwordinhl 
3165 23					inc hl 
3166			 
3166 d1					pop de 
3167 eb					ex de, hl 
3168 73					ld (hl), e 
3169 23					inc hl 
316a 72					ld (hl), d 
316b					 
316b					NEXTW 
316b c3 17 22			jp macro_next 
316e				endm 
# End of macro NEXTW
316e			.SBSTORE: 
316e				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
316e 6f				db WORD_SYS_CORE+91             
316f 84 31			dw .SBWSTORE            
3171 04				db 3 + 1 
3172 .. 00			db "1-!",0              
3176				endm 
# End of macro CWHEAD
3176			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3176			 
3176					FORTH_DSP_VALUEHL 
3176 cd 61 20			call macro_dsp_valuehl 
3179				endm 
# End of macro FORTH_DSP_VALUEHL
3179 e5					push hl 
317a			 
317a					FORTH_DSP_POP 
317a cd 19 21			call macro_forth_dsp_pop 
317d				endm 
# End of macro FORTH_DSP_POP
317d e1					pop hl 
317e			 
317e 7e					ld a, (hl) 
317f 3d					dec a 
3180 77					ld (hl), a 
3181					 
3181					NEXTW 
3181 c3 17 22			jp macro_next 
3184				endm 
# End of macro NEXTW
3184			.SBWSTORE: 
3184				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
3184 6f				db WORD_SYS_CORE+91             
3185 a2 31			dw .ENDCORE            
3187 05				db 4 + 1 
3188 .. 00			db "1-2!",0              
318d				endm 
# End of macro CWHEAD
318d			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
318d			 
318d					FORTH_DSP_VALUEHL 
318d cd 61 20			call macro_dsp_valuehl 
3190				endm 
# End of macro FORTH_DSP_VALUEHL
3190 e5					push hl 
3191			 
3191					FORTH_DSP_POP 
3191 cd 19 21			call macro_forth_dsp_pop 
3194				endm 
# End of macro FORTH_DSP_POP
3194 e1					pop hl 
3195			 
3195 e5					push hl 
3196			 
3196 cd 99 21				call loadwordinhl 
3199 2b					dec hl 
319a			 
319a d1					pop de 
319b eb					ex de, hl 
319c 73					ld (hl), e 
319d 23					inc hl 
319e 72					ld (hl), d 
319f					 
319f					NEXTW 
319f c3 17 22			jp macro_next 
31a2				endm 
# End of macro NEXTW
31a2			.ENDCORE: 
31a2			 
31a2			; eof 
31a2			 
31a2			 
# End of file forth_words_core.asm
31a2			include "forth_words_flow.asm" 
31a2			 
31a2			; | ## Program Flow Words 
31a2			 
31a2			.IF: 
31a2				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
31a2 1e				db WORD_SYS_CORE+10             
31a3 97 32			dw .THEN            
31a5 03				db 2 + 1 
31a6 .. 00			db "IF",0              
31a9				endm 
# End of macro CWHEAD
31a9			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
31a9			; 
31a9					if DEBUG_FORTH_WORDS_KEY 
31a9						DMARK "IF." 
31a9 f5				push af  
31aa 3a be 31			ld a, (.dmark)  
31ad 32 6b ee			ld (debug_mark),a  
31b0 3a bf 31			ld a, (.dmark+1)  
31b3 32 6c ee			ld (debug_mark+1),a  
31b6 3a c0 31			ld a, (.dmark+2)  
31b9 32 6d ee			ld (debug_mark+2),a  
31bc 18 03			jr .pastdmark  
31be ..			.dmark: db "IF."  
31c1 f1			.pastdmark: pop af  
31c2			endm  
# End of macro DMARK
31c2						CALLMONITOR 
31c2 cd 6f ee			call debug_vector  
31c5				endm  
# End of macro CALLMONITOR
31c5					endif 
31c5			; eval TOS 
31c5			 
31c5				FORTH_DSP_VALUEHL 
31c5 cd 61 20			call macro_dsp_valuehl 
31c8				endm 
# End of macro FORTH_DSP_VALUEHL
31c8			 
31c8			;	push hl 
31c8				FORTH_DSP_POP 
31c8 cd 19 21			call macro_forth_dsp_pop 
31cb				endm 
# End of macro FORTH_DSP_POP
31cb			;	pop hl 
31cb			 
31cb					if DEBUG_FORTH_WORDS 
31cb						DMARK "IF1" 
31cb f5				push af  
31cc 3a e0 31			ld a, (.dmark)  
31cf 32 6b ee			ld (debug_mark),a  
31d2 3a e1 31			ld a, (.dmark+1)  
31d5 32 6c ee			ld (debug_mark+1),a  
31d8 3a e2 31			ld a, (.dmark+2)  
31db 32 6d ee			ld (debug_mark+2),a  
31de 18 03			jr .pastdmark  
31e0 ..			.dmark: db "IF1"  
31e3 f1			.pastdmark: pop af  
31e4			endm  
# End of macro DMARK
31e4						CALLMONITOR 
31e4 cd 6f ee			call debug_vector  
31e7				endm  
# End of macro CALLMONITOR
31e7					endif 
31e7 b7				or a        ; clear carry flag 
31e8 11 00 00			ld de, 0 
31eb eb				ex de,hl 
31ec ed 52			sbc hl, de 
31ee c2 78 32			jp nz, .iftrue 
31f1			 
31f1					if DEBUG_FORTH_WORDS 
31f1						DMARK "IF2" 
31f1 f5				push af  
31f2 3a 06 32			ld a, (.dmark)  
31f5 32 6b ee			ld (debug_mark),a  
31f8 3a 07 32			ld a, (.dmark+1)  
31fb 32 6c ee			ld (debug_mark+1),a  
31fe 3a 08 32			ld a, (.dmark+2)  
3201 32 6d ee			ld (debug_mark+2),a  
3204 18 03			jr .pastdmark  
3206 ..			.dmark: db "IF2"  
3209 f1			.pastdmark: pop af  
320a			endm  
# End of macro DMARK
320a						CALLMONITOR 
320a cd 6f ee			call debug_vector  
320d				endm  
# End of macro CALLMONITOR
320d					endif 
320d			 
320d			; if not true then skip to THEN 
320d			 
320d				; TODO get tok_ptr 
320d				; TODO consume toks until we get to THEN 
320d			 
320d 2a c2 e5			ld hl, (os_tok_ptr) 
3210					if DEBUG_FORTH_WORDS 
3210						DMARK "IF3" 
3210 f5				push af  
3211 3a 25 32			ld a, (.dmark)  
3214 32 6b ee			ld (debug_mark),a  
3217 3a 26 32			ld a, (.dmark+1)  
321a 32 6c ee			ld (debug_mark+1),a  
321d 3a 27 32			ld a, (.dmark+2)  
3220 32 6d ee			ld (debug_mark+2),a  
3223 18 03			jr .pastdmark  
3225 ..			.dmark: db "IF3"  
3228 f1			.pastdmark: pop af  
3229			endm  
# End of macro DMARK
3229						CALLMONITOR 
3229 cd 6f ee			call debug_vector  
322c				endm  
# End of macro CALLMONITOR
322c						 
322c					endif 
322c 11 73 32			ld de, .ifthen 
322f					if DEBUG_FORTH_WORDS 
322f						DMARK "IF4" 
322f f5				push af  
3230 3a 44 32			ld a, (.dmark)  
3233 32 6b ee			ld (debug_mark),a  
3236 3a 45 32			ld a, (.dmark+1)  
3239 32 6c ee			ld (debug_mark+1),a  
323c 3a 46 32			ld a, (.dmark+2)  
323f 32 6d ee			ld (debug_mark+2),a  
3242 18 03			jr .pastdmark  
3244 ..			.dmark: db "IF4"  
3247 f1			.pastdmark: pop af  
3248			endm  
# End of macro DMARK
3248						CALLMONITOR 
3248 cd 6f ee			call debug_vector  
324b				endm  
# End of macro CALLMONITOR
324b					endif 
324b cd 32 23			call findnexttok  
324e			 
324e					if DEBUG_FORTH_WORDS 
324e						DMARK "IF5" 
324e f5				push af  
324f 3a 63 32			ld a, (.dmark)  
3252 32 6b ee			ld (debug_mark),a  
3255 3a 64 32			ld a, (.dmark+1)  
3258 32 6c ee			ld (debug_mark+1),a  
325b 3a 65 32			ld a, (.dmark+2)  
325e 32 6d ee			ld (debug_mark+2),a  
3261 18 03			jr .pastdmark  
3263 ..			.dmark: db "IF5"  
3266 f1			.pastdmark: pop af  
3267			endm  
# End of macro DMARK
3267						CALLMONITOR 
3267 cd 6f ee			call debug_vector  
326a				endm  
# End of macro CALLMONITOR
326a					endif 
326a				; TODO replace below with ; exec using tok_ptr 
326a 22 c2 e5			ld (os_tok_ptr), hl 
326d c3 a8 22			jp exec1 
3270				NEXTW 
3270 c3 17 22			jp macro_next 
3273				endm 
# End of macro NEXTW
3273			 
3273 .. 00		.ifthen:  db "THEN",0 
3278			 
3278			.iftrue:		 
3278				; Exec next words normally 
3278			 
3278				; if true then exec following IF as normal 
3278					if DEBUG_FORTH_WORDS 
3278						DMARK "IFT" 
3278 f5				push af  
3279 3a 8d 32			ld a, (.dmark)  
327c 32 6b ee			ld (debug_mark),a  
327f 3a 8e 32			ld a, (.dmark+1)  
3282 32 6c ee			ld (debug_mark+1),a  
3285 3a 8f 32			ld a, (.dmark+2)  
3288 32 6d ee			ld (debug_mark+2),a  
328b 18 03			jr .pastdmark  
328d ..			.dmark: db "IFT"  
3290 f1			.pastdmark: pop af  
3291			endm  
# End of macro DMARK
3291						CALLMONITOR 
3291 cd 6f ee			call debug_vector  
3294				endm  
# End of macro CALLMONITOR
3294					endif 
3294			 
3294					NEXTW 
3294 c3 17 22			jp macro_next 
3297				endm 
# End of macro NEXTW
3297			.THEN: 
3297				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3297 1f				db WORD_SYS_CORE+11             
3298 bf 32			dw .ELSE            
329a 05				db 4 + 1 
329b .. 00			db "THEN",0              
32a0				endm 
# End of macro CWHEAD
32a0			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
32a0					if DEBUG_FORTH_WORDS_KEY 
32a0						DMARK "THN" 
32a0 f5				push af  
32a1 3a b5 32			ld a, (.dmark)  
32a4 32 6b ee			ld (debug_mark),a  
32a7 3a b6 32			ld a, (.dmark+1)  
32aa 32 6c ee			ld (debug_mark+1),a  
32ad 3a b7 32			ld a, (.dmark+2)  
32b0 32 6d ee			ld (debug_mark+2),a  
32b3 18 03			jr .pastdmark  
32b5 ..			.dmark: db "THN"  
32b8 f1			.pastdmark: pop af  
32b9			endm  
# End of macro DMARK
32b9						CALLMONITOR 
32b9 cd 6f ee			call debug_vector  
32bc				endm  
# End of macro CALLMONITOR
32bc					endif 
32bc					NEXTW 
32bc c3 17 22			jp macro_next 
32bf				endm 
# End of macro NEXTW
32bf			.ELSE: 
32bf				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
32bf 20				db WORD_SYS_CORE+12             
32c0 e7 32			dw .DO            
32c2 03				db 2 + 1 
32c3 .. 00			db "ELSE",0              
32c8				endm 
# End of macro CWHEAD
32c8			; | ELSE ( -- ) Not supported - does nothing | TODO 
32c8			 
32c8					if DEBUG_FORTH_WORDS_KEY 
32c8						DMARK "ELS" 
32c8 f5				push af  
32c9 3a dd 32			ld a, (.dmark)  
32cc 32 6b ee			ld (debug_mark),a  
32cf 3a de 32			ld a, (.dmark+1)  
32d2 32 6c ee			ld (debug_mark+1),a  
32d5 3a df 32			ld a, (.dmark+2)  
32d8 32 6d ee			ld (debug_mark+2),a  
32db 18 03			jr .pastdmark  
32dd ..			.dmark: db "ELS"  
32e0 f1			.pastdmark: pop af  
32e1			endm  
# End of macro DMARK
32e1						CALLMONITOR 
32e1 cd 6f ee			call debug_vector  
32e4				endm  
# End of macro CALLMONITOR
32e4					endif 
32e4			 
32e4			 
32e4					NEXTW 
32e4 c3 17 22			jp macro_next 
32e7				endm 
# End of macro NEXTW
32e7			.DO: 
32e7				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
32e7 21				db WORD_SYS_CORE+13             
32e8 0e 34			dw .LOOP            
32ea 03				db 2 + 1 
32eb .. 00			db "DO",0              
32ee				endm 
# End of macro CWHEAD
32ee			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
32ee			 
32ee					if DEBUG_FORTH_WORDS_KEY 
32ee						DMARK "DO." 
32ee f5				push af  
32ef 3a 03 33			ld a, (.dmark)  
32f2 32 6b ee			ld (debug_mark),a  
32f5 3a 04 33			ld a, (.dmark+1)  
32f8 32 6c ee			ld (debug_mark+1),a  
32fb 3a 05 33			ld a, (.dmark+2)  
32fe 32 6d ee			ld (debug_mark+2),a  
3301 18 03			jr .pastdmark  
3303 ..			.dmark: db "DO."  
3306 f1			.pastdmark: pop af  
3307			endm  
# End of macro DMARK
3307						CALLMONITOR 
3307 cd 6f ee			call debug_vector  
330a				endm  
# End of macro CALLMONITOR
330a					endif 
330a			;  push pc to rsp stack past the DO 
330a			 
330a 2a c2 e5				ld hl, (os_tok_ptr) 
330d 23					inc hl   ; D 
330e 23					inc hl  ; O 
330f 23					inc hl   ; null 
3310					if DEBUG_FORTH_WORDS 
3310						DMARK "DO2" 
3310 f5				push af  
3311 3a 25 33			ld a, (.dmark)  
3314 32 6b ee			ld (debug_mark),a  
3317 3a 26 33			ld a, (.dmark+1)  
331a 32 6c ee			ld (debug_mark+1),a  
331d 3a 27 33			ld a, (.dmark+2)  
3320 32 6d ee			ld (debug_mark+2),a  
3323 18 03			jr .pastdmark  
3325 ..			.dmark: db "DO2"  
3328 f1			.pastdmark: pop af  
3329			endm  
# End of macro DMARK
3329						CALLMONITOR 
3329 cd 6f ee			call debug_vector  
332c				endm  
# End of macro CALLMONITOR
332c					endif 
332c					FORTH_RSP_NEXT 
332c cd 11 1e			call macro_forth_rsp_next 
332f				endm 
# End of macro FORTH_RSP_NEXT
332f					if DEBUG_FORTH_WORDS 
332f						DMARK "DO3" 
332f f5				push af  
3330 3a 44 33			ld a, (.dmark)  
3333 32 6b ee			ld (debug_mark),a  
3336 3a 45 33			ld a, (.dmark+1)  
3339 32 6c ee			ld (debug_mark+1),a  
333c 3a 46 33			ld a, (.dmark+2)  
333f 32 6d ee			ld (debug_mark+2),a  
3342 18 03			jr .pastdmark  
3344 ..			.dmark: db "DO3"  
3347 f1			.pastdmark: pop af  
3348			endm  
# End of macro DMARK
3348						CALLMONITOR 
3348 cd 6f ee			call debug_vector  
334b				endm  
# End of macro CALLMONITOR
334b					endif 
334b			 
334b					;if DEBUG_FORTH_WORDS 
334b				;		push hl 
334b			;		endif  
334b			 
334b			; get counters from data stack 
334b			 
334b			 
334b					FORTH_DSP_VALUEHL 
334b cd 61 20			call macro_dsp_valuehl 
334e				endm 
# End of macro FORTH_DSP_VALUEHL
334e e5					push hl		 ; hl now has starting counter which needs to be tos 
334f			 
334f					if DEBUG_FORTH_WORDS 
334f						DMARK "DO4" 
334f f5				push af  
3350 3a 64 33			ld a, (.dmark)  
3353 32 6b ee			ld (debug_mark),a  
3356 3a 65 33			ld a, (.dmark+1)  
3359 32 6c ee			ld (debug_mark+1),a  
335c 3a 66 33			ld a, (.dmark+2)  
335f 32 6d ee			ld (debug_mark+2),a  
3362 18 03			jr .pastdmark  
3364 ..			.dmark: db "DO4"  
3367 f1			.pastdmark: pop af  
3368			endm  
# End of macro DMARK
3368						CALLMONITOR 
3368 cd 6f ee			call debug_vector  
336b				endm  
# End of macro CALLMONITOR
336b					endif 
336b					FORTH_DSP_POP 
336b cd 19 21			call macro_forth_dsp_pop 
336e				endm 
# End of macro FORTH_DSP_POP
336e			 
336e					if DEBUG_FORTH_WORDS 
336e						DMARK "DO5" 
336e f5				push af  
336f 3a 83 33			ld a, (.dmark)  
3372 32 6b ee			ld (debug_mark),a  
3375 3a 84 33			ld a, (.dmark+1)  
3378 32 6c ee			ld (debug_mark+1),a  
337b 3a 85 33			ld a, (.dmark+2)  
337e 32 6d ee			ld (debug_mark+2),a  
3381 18 03			jr .pastdmark  
3383 ..			.dmark: db "DO5"  
3386 f1			.pastdmark: pop af  
3387			endm  
# End of macro DMARK
3387						CALLMONITOR 
3387 cd 6f ee			call debug_vector  
338a				endm  
# End of macro CALLMONITOR
338a					endif 
338a			 
338a					FORTH_DSP_VALUEHL 
338a cd 61 20			call macro_dsp_valuehl 
338d				endm 
# End of macro FORTH_DSP_VALUEHL
338d			;		push hl		 ; hl now has starting limit counter 
338d			 
338d					if DEBUG_FORTH_WORDS 
338d						DMARK "DO6" 
338d f5				push af  
338e 3a a2 33			ld a, (.dmark)  
3391 32 6b ee			ld (debug_mark),a  
3394 3a a3 33			ld a, (.dmark+1)  
3397 32 6c ee			ld (debug_mark+1),a  
339a 3a a4 33			ld a, (.dmark+2)  
339d 32 6d ee			ld (debug_mark+2),a  
33a0 18 03			jr .pastdmark  
33a2 ..			.dmark: db "DO6"  
33a5 f1			.pastdmark: pop af  
33a6			endm  
# End of macro DMARK
33a6						CALLMONITOR 
33a6 cd 6f ee			call debug_vector  
33a9				endm  
# End of macro CALLMONITOR
33a9					endif 
33a9					FORTH_DSP_POP 
33a9 cd 19 21			call macro_forth_dsp_pop 
33ac				endm 
# End of macro FORTH_DSP_POP
33ac			 
33ac			; put counters on the loop stack 
33ac			 
33ac			;		pop hl			 ; limit counter 
33ac d1					pop de			; start counter 
33ad			 
33ad					; push limit counter 
33ad			 
33ad					if DEBUG_FORTH_WORDS 
33ad						DMARK "DO7" 
33ad f5				push af  
33ae 3a c2 33			ld a, (.dmark)  
33b1 32 6b ee			ld (debug_mark),a  
33b4 3a c3 33			ld a, (.dmark+1)  
33b7 32 6c ee			ld (debug_mark+1),a  
33ba 3a c4 33			ld a, (.dmark+2)  
33bd 32 6d ee			ld (debug_mark+2),a  
33c0 18 03			jr .pastdmark  
33c2 ..			.dmark: db "DO7"  
33c5 f1			.pastdmark: pop af  
33c6			endm  
# End of macro DMARK
33c6						CALLMONITOR 
33c6 cd 6f ee			call debug_vector  
33c9				endm  
# End of macro CALLMONITOR
33c9					endif 
33c9					FORTH_LOOP_NEXT 
33c9 cd 92 20			call macro_forth_loop_next 
33cc				endm 
# End of macro FORTH_LOOP_NEXT
33cc			 
33cc					; push start counter 
33cc			 
33cc eb					ex de, hl 
33cd					if DEBUG_FORTH_WORDS 
33cd						DMARK "DO7" 
33cd f5				push af  
33ce 3a e2 33			ld a, (.dmark)  
33d1 32 6b ee			ld (debug_mark),a  
33d4 3a e3 33			ld a, (.dmark+1)  
33d7 32 6c ee			ld (debug_mark+1),a  
33da 3a e4 33			ld a, (.dmark+2)  
33dd 32 6d ee			ld (debug_mark+2),a  
33e0 18 03			jr .pastdmark  
33e2 ..			.dmark: db "DO7"  
33e5 f1			.pastdmark: pop af  
33e6			endm  
# End of macro DMARK
33e6						CALLMONITOR 
33e6 cd 6f ee			call debug_vector  
33e9				endm  
# End of macro CALLMONITOR
33e9					endif 
33e9					FORTH_LOOP_NEXT 
33e9 cd 92 20			call macro_forth_loop_next 
33ec				endm 
# End of macro FORTH_LOOP_NEXT
33ec			 
33ec			 
33ec					; init first round of I counter 
33ec			 
33ec 22 e6 e5				ld (os_current_i), hl 
33ef			 
33ef					if DEBUG_FORTH_WORDS 
33ef						DMARK "DO8" 
33ef f5				push af  
33f0 3a 04 34			ld a, (.dmark)  
33f3 32 6b ee			ld (debug_mark),a  
33f6 3a 05 34			ld a, (.dmark+1)  
33f9 32 6c ee			ld (debug_mark+1),a  
33fc 3a 06 34			ld a, (.dmark+2)  
33ff 32 6d ee			ld (debug_mark+2),a  
3402 18 03			jr .pastdmark  
3404 ..			.dmark: db "DO8"  
3407 f1			.pastdmark: pop af  
3408			endm  
# End of macro DMARK
3408						CALLMONITOR 
3408 cd 6f ee			call debug_vector  
340b				endm  
# End of macro CALLMONITOR
340b					endif 
340b			 
340b					NEXTW 
340b c3 17 22			jp macro_next 
340e				endm 
# End of macro NEXTW
340e			.LOOP: 
340e				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
340e 22				db WORD_SYS_CORE+14             
340f 26 35			dw .I            
3411 05				db 4 + 1 
3412 .. 00			db "LOOP",0              
3417				endm 
# End of macro CWHEAD
3417			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3417			 
3417				; pop tos as current loop count to hl 
3417			 
3417				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3417			 
3417				FORTH_LOOP_TOS 
3417 cd c5 20			call macro_forth_loop_tos 
341a				endm 
# End of macro FORTH_LOOP_TOS
341a e5				push hl 
341b			 
341b					if DEBUG_FORTH_WORDS_KEY 
341b						DMARK "LOP" 
341b f5				push af  
341c 3a 30 34			ld a, (.dmark)  
341f 32 6b ee			ld (debug_mark),a  
3422 3a 31 34			ld a, (.dmark+1)  
3425 32 6c ee			ld (debug_mark+1),a  
3428 3a 32 34			ld a, (.dmark+2)  
342b 32 6d ee			ld (debug_mark+2),a  
342e 18 03			jr .pastdmark  
3430 ..			.dmark: db "LOP"  
3433 f1			.pastdmark: pop af  
3434			endm  
# End of macro DMARK
3434						CALLMONITOR 
3434 cd 6f ee			call debug_vector  
3437				endm  
# End of macro CALLMONITOR
3437					endif 
3437				; next item on the stack is the limit. get it 
3437			 
3437			 
3437				FORTH_LOOP_POP 
3437 cd cf 20			call macro_forth_loop_pop 
343a				endm 
# End of macro FORTH_LOOP_POP
343a			 
343a				FORTH_LOOP_TOS 
343a cd c5 20			call macro_forth_loop_tos 
343d				endm 
# End of macro FORTH_LOOP_TOS
343d			 
343d d1				pop de		 ; de = i, hl = limit 
343e			 
343e					if DEBUG_FORTH_WORDS 
343e						DMARK "LP1" 
343e f5				push af  
343f 3a 53 34			ld a, (.dmark)  
3442 32 6b ee			ld (debug_mark),a  
3445 3a 54 34			ld a, (.dmark+1)  
3448 32 6c ee			ld (debug_mark+1),a  
344b 3a 55 34			ld a, (.dmark+2)  
344e 32 6d ee			ld (debug_mark+2),a  
3451 18 03			jr .pastdmark  
3453 ..			.dmark: db "LP1"  
3456 f1			.pastdmark: pop af  
3457			endm  
# End of macro DMARK
3457						CALLMONITOR 
3457 cd 6f ee			call debug_vector  
345a				endm  
# End of macro CALLMONITOR
345a					endif 
345a			 
345a				; go back to previous word 
345a			 
345a d5				push de    ; save I for inc later 
345b			 
345b			 
345b				; get limit 
345b				;  is I at limit? 
345b			 
345b			 
345b					if DEBUG_FORTH_WORDS 
345b						DMARK "LP1" 
345b f5				push af  
345c 3a 70 34			ld a, (.dmark)  
345f 32 6b ee			ld (debug_mark),a  
3462 3a 71 34			ld a, (.dmark+1)  
3465 32 6c ee			ld (debug_mark+1),a  
3468 3a 72 34			ld a, (.dmark+2)  
346b 32 6d ee			ld (debug_mark+2),a  
346e 18 03			jr .pastdmark  
3470 ..			.dmark: db "LP1"  
3473 f1			.pastdmark: pop af  
3474			endm  
# End of macro DMARK
3474						CALLMONITOR 
3474 cd 6f ee			call debug_vector  
3477				endm  
# End of macro CALLMONITOR
3477					endif 
3477			 
3477 ed 52			sbc hl, de 
3479			 
3479			 
3479				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3479			 
3479 20 26				jr nz, .loopnotdone 
347b			 
347b e1				pop hl   ; get rid of saved I 
347c				FORTH_LOOP_POP     ; get rid of limit 
347c cd cf 20			call macro_forth_loop_pop 
347f				endm 
# End of macro FORTH_LOOP_POP
347f			 
347f				FORTH_RSP_POP     ; get rid of DO ptr 
347f cd 32 1e			call macro_forth_rsp_pop 
3482				endm 
# End of macro FORTH_RSP_POP
3482			 
3482			if DEBUG_FORTH_WORDS 
3482						DMARK "LP>" 
3482 f5				push af  
3483 3a 97 34			ld a, (.dmark)  
3486 32 6b ee			ld (debug_mark),a  
3489 3a 98 34			ld a, (.dmark+1)  
348c 32 6c ee			ld (debug_mark+1),a  
348f 3a 99 34			ld a, (.dmark+2)  
3492 32 6d ee			ld (debug_mark+2),a  
3495 18 03			jr .pastdmark  
3497 ..			.dmark: db "LP>"  
349a f1			.pastdmark: pop af  
349b			endm  
# End of macro DMARK
349b				CALLMONITOR 
349b cd 6f ee			call debug_vector  
349e				endm  
# End of macro CALLMONITOR
349e			endif 
349e			 
349e					NEXTW 
349e c3 17 22			jp macro_next 
34a1				endm 
# End of macro NEXTW
34a1				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34a1			 
34a1			.loopnotdone: 
34a1			 
34a1 e1				pop hl    ; get I 
34a2 23				inc hl 
34a3			 
34a3			   	; save new I 
34a3			 
34a3			 
34a3					; set I counter 
34a3			 
34a3 22 e6 e5				ld (os_current_i), hl 
34a6			 
34a6					if DEBUG_FORTH_WORDS 
34a6						DMARK "LPN" 
34a6 f5				push af  
34a7 3a bb 34			ld a, (.dmark)  
34aa 32 6b ee			ld (debug_mark),a  
34ad 3a bc 34			ld a, (.dmark+1)  
34b0 32 6c ee			ld (debug_mark+1),a  
34b3 3a bd 34			ld a, (.dmark+2)  
34b6 32 6d ee			ld (debug_mark+2),a  
34b9 18 03			jr .pastdmark  
34bb ..			.dmark: db "LPN"  
34be f1			.pastdmark: pop af  
34bf			endm  
# End of macro DMARK
34bf					CALLMONITOR 
34bf cd 6f ee			call debug_vector  
34c2				endm  
# End of macro CALLMONITOR
34c2					endif 
34c2					 
34c2				FORTH_LOOP_NEXT 
34c2 cd 92 20			call macro_forth_loop_next 
34c5				endm 
# End of macro FORTH_LOOP_NEXT
34c5			 
34c5			 
34c5					if DEBUG_FORTH_WORDS 
34c5 eb						ex de,hl 
34c6					endif 
34c6			 
34c6			;	; get DO ptr 
34c6			; 
34c6					if DEBUG_FORTH_WORDS 
34c6						DMARK "LP7" 
34c6 f5				push af  
34c7 3a db 34			ld a, (.dmark)  
34ca 32 6b ee			ld (debug_mark),a  
34cd 3a dc 34			ld a, (.dmark+1)  
34d0 32 6c ee			ld (debug_mark+1),a  
34d3 3a dd 34			ld a, (.dmark+2)  
34d6 32 6d ee			ld (debug_mark+2),a  
34d9 18 03			jr .pastdmark  
34db ..			.dmark: db "LP7"  
34de f1			.pastdmark: pop af  
34df			endm  
# End of macro DMARK
34df					CALLMONITOR 
34df cd 6f ee			call debug_vector  
34e2				endm  
# End of macro CALLMONITOR
34e2					endif 
34e2				FORTH_RSP_TOS 
34e2 cd 28 1e			call macro_forth_rsp_tos 
34e5				endm 
# End of macro FORTH_RSP_TOS
34e5			 
34e5					if DEBUG_FORTH_WORDS 
34e5						DMARK "LP8" 
34e5 f5				push af  
34e6 3a fa 34			ld a, (.dmark)  
34e9 32 6b ee			ld (debug_mark),a  
34ec 3a fb 34			ld a, (.dmark+1)  
34ef 32 6c ee			ld (debug_mark+1),a  
34f2 3a fc 34			ld a, (.dmark+2)  
34f5 32 6d ee			ld (debug_mark+2),a  
34f8 18 03			jr .pastdmark  
34fa ..			.dmark: db "LP8"  
34fd f1			.pastdmark: pop af  
34fe			endm  
# End of macro DMARK
34fe					CALLMONITOR 
34fe cd 6f ee			call debug_vector  
3501				endm  
# End of macro CALLMONITOR
3501					endif 
3501				;push hl 
3501			 
3501				; not going to DO any more 
3501				; get rid of the RSP pointer as DO will add it back in 
3501				;FORTH_RSP_POP 
3501				;pop hl 
3501			 
3501				;ld hl,(cli_ret_sp) 
3501				;ld e, (hl) 
3501				;inc hl 
3501				;ld d, (hl) 
3501				;ex de,hl 
3501 22 c2 e5			ld (os_tok_ptr), hl 
3504					if DEBUG_FORTH_WORDS 
3504						DMARK "LP<" 
3504 f5				push af  
3505 3a 19 35			ld a, (.dmark)  
3508 32 6b ee			ld (debug_mark),a  
350b 3a 1a 35			ld a, (.dmark+1)  
350e 32 6c ee			ld (debug_mark+1),a  
3511 3a 1b 35			ld a, (.dmark+2)  
3514 32 6d ee			ld (debug_mark+2),a  
3517 18 03			jr .pastdmark  
3519 ..			.dmark: db "LP<"  
351c f1			.pastdmark: pop af  
351d			endm  
# End of macro DMARK
351d					CALLMONITOR 
351d cd 6f ee			call debug_vector  
3520				endm  
# End of macro CALLMONITOR
3520				endif 
3520 c3 a8 22			jp exec1 
3523			 
3523					 
3523			 
3523			 
3523					NEXTW 
3523 c3 17 22			jp macro_next 
3526				endm 
# End of macro NEXTW
3526			.I:  
3526			 
3526				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3526 5e				db WORD_SYS_CORE+74             
3527 51 35			dw .DLOOP            
3529 02				db 1 + 1 
352a .. 00			db "I",0              
352c				endm 
# End of macro CWHEAD
352c			; | I ( -- ) Current loop counter | DONE 
352c					if DEBUG_FORTH_WORDS_KEY 
352c						DMARK "I.." 
352c f5				push af  
352d 3a 41 35			ld a, (.dmark)  
3530 32 6b ee			ld (debug_mark),a  
3533 3a 42 35			ld a, (.dmark+1)  
3536 32 6c ee			ld (debug_mark+1),a  
3539 3a 43 35			ld a, (.dmark+2)  
353c 32 6d ee			ld (debug_mark+2),a  
353f 18 03			jr .pastdmark  
3541 ..			.dmark: db "I.."  
3544 f1			.pastdmark: pop af  
3545			endm  
# End of macro DMARK
3545						CALLMONITOR 
3545 cd 6f ee			call debug_vector  
3548				endm  
# End of macro CALLMONITOR
3548					endif 
3548			 
3548 2a e6 e5				ld hl,(os_current_i) 
354b cd 6a 1e				call forth_push_numhl 
354e			 
354e					NEXTW 
354e c3 17 22			jp macro_next 
3551				endm 
# End of macro NEXTW
3551			.DLOOP: 
3551				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3551 5f				db WORD_SYS_CORE+75             
3552 32 36			dw .REPEAT            
3554 06				db 5 + 1 
3555 .. 00			db "-LOOP",0              
355b				endm 
# End of macro CWHEAD
355b			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
355b				; pop tos as current loop count to hl 
355b					if DEBUG_FORTH_WORDS_KEY 
355b						DMARK "-LP" 
355b f5				push af  
355c 3a 70 35			ld a, (.dmark)  
355f 32 6b ee			ld (debug_mark),a  
3562 3a 71 35			ld a, (.dmark+1)  
3565 32 6c ee			ld (debug_mark+1),a  
3568 3a 72 35			ld a, (.dmark+2)  
356b 32 6d ee			ld (debug_mark+2),a  
356e 18 03			jr .pastdmark  
3570 ..			.dmark: db "-LP"  
3573 f1			.pastdmark: pop af  
3574			endm  
# End of macro DMARK
3574						CALLMONITOR 
3574 cd 6f ee			call debug_vector  
3577				endm  
# End of macro CALLMONITOR
3577					endif 
3577			 
3577				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3577			 
3577				FORTH_LOOP_TOS 
3577 cd c5 20			call macro_forth_loop_tos 
357a				endm 
# End of macro FORTH_LOOP_TOS
357a e5				push hl 
357b			 
357b					if DEBUG_FORTH_WORDS 
357b						DMARK "-LP" 
357b f5				push af  
357c 3a 90 35			ld a, (.dmark)  
357f 32 6b ee			ld (debug_mark),a  
3582 3a 91 35			ld a, (.dmark+1)  
3585 32 6c ee			ld (debug_mark+1),a  
3588 3a 92 35			ld a, (.dmark+2)  
358b 32 6d ee			ld (debug_mark+2),a  
358e 18 03			jr .pastdmark  
3590 ..			.dmark: db "-LP"  
3593 f1			.pastdmark: pop af  
3594			endm  
# End of macro DMARK
3594						CALLMONITOR 
3594 cd 6f ee			call debug_vector  
3597				endm  
# End of macro CALLMONITOR
3597					endif 
3597				; next item on the stack is the limit. get it 
3597			 
3597			 
3597				FORTH_LOOP_POP 
3597 cd cf 20			call macro_forth_loop_pop 
359a				endm 
# End of macro FORTH_LOOP_POP
359a			 
359a				FORTH_LOOP_TOS 
359a cd c5 20			call macro_forth_loop_tos 
359d				endm 
# End of macro FORTH_LOOP_TOS
359d			 
359d d1				pop de		 ; de = i, hl = limit 
359e			 
359e					if DEBUG_FORTH_WORDS 
359e						DMARK "-L1" 
359e f5				push af  
359f 3a b3 35			ld a, (.dmark)  
35a2 32 6b ee			ld (debug_mark),a  
35a5 3a b4 35			ld a, (.dmark+1)  
35a8 32 6c ee			ld (debug_mark+1),a  
35ab 3a b5 35			ld a, (.dmark+2)  
35ae 32 6d ee			ld (debug_mark+2),a  
35b1 18 03			jr .pastdmark  
35b3 ..			.dmark: db "-L1"  
35b6 f1			.pastdmark: pop af  
35b7			endm  
# End of macro DMARK
35b7						CALLMONITOR 
35b7 cd 6f ee			call debug_vector  
35ba				endm  
# End of macro CALLMONITOR
35ba					endif 
35ba			 
35ba				; go back to previous word 
35ba			 
35ba d5				push de    ; save I for inc later 
35bb			 
35bb			 
35bb				; get limit 
35bb				;  is I at limit? 
35bb			 
35bb			 
35bb					if DEBUG_FORTH_WORDS 
35bb						DMARK "-L1" 
35bb f5				push af  
35bc 3a d0 35			ld a, (.dmark)  
35bf 32 6b ee			ld (debug_mark),a  
35c2 3a d1 35			ld a, (.dmark+1)  
35c5 32 6c ee			ld (debug_mark+1),a  
35c8 3a d2 35			ld a, (.dmark+2)  
35cb 32 6d ee			ld (debug_mark+2),a  
35ce 18 03			jr .pastdmark  
35d0 ..			.dmark: db "-L1"  
35d3 f1			.pastdmark: pop af  
35d4			endm  
# End of macro DMARK
35d4						CALLMONITOR 
35d4 cd 6f ee			call debug_vector  
35d7				endm  
# End of macro CALLMONITOR
35d7					endif 
35d7			 
35d7 ed 52			sbc hl, de 
35d9			 
35d9			 
35d9				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
35d9			 
35d9 20 26				jr nz, .mloopnotdone 
35db			 
35db e1				pop hl   ; get rid of saved I 
35dc				FORTH_LOOP_POP     ; get rid of limit 
35dc cd cf 20			call macro_forth_loop_pop 
35df				endm 
# End of macro FORTH_LOOP_POP
35df			 
35df				FORTH_RSP_POP     ; get rid of DO ptr 
35df cd 32 1e			call macro_forth_rsp_pop 
35e2				endm 
# End of macro FORTH_RSP_POP
35e2			 
35e2			if DEBUG_FORTH_WORDS 
35e2						DMARK "-L>" 
35e2 f5				push af  
35e3 3a f7 35			ld a, (.dmark)  
35e6 32 6b ee			ld (debug_mark),a  
35e9 3a f8 35			ld a, (.dmark+1)  
35ec 32 6c ee			ld (debug_mark+1),a  
35ef 3a f9 35			ld a, (.dmark+2)  
35f2 32 6d ee			ld (debug_mark+2),a  
35f5 18 03			jr .pastdmark  
35f7 ..			.dmark: db "-L>"  
35fa f1			.pastdmark: pop af  
35fb			endm  
# End of macro DMARK
35fb				CALLMONITOR 
35fb cd 6f ee			call debug_vector  
35fe				endm  
# End of macro CALLMONITOR
35fe			endif 
35fe			 
35fe					NEXTW 
35fe c3 17 22			jp macro_next 
3601				endm 
# End of macro NEXTW
3601				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3601			 
3601			.mloopnotdone: 
3601			 
3601 e1				pop hl    ; get I 
3602 2b				dec hl 
3603			 
3603			   	; save new I 
3603			 
3603			 
3603					; set I counter 
3603			 
3603 22 e6 e5				ld (os_current_i), hl 
3606			 
3606					 
3606				FORTH_LOOP_NEXT 
3606 cd 92 20			call macro_forth_loop_next 
3609				endm 
# End of macro FORTH_LOOP_NEXT
3609			 
3609			 
3609					if DEBUG_FORTH_WORDS 
3609 eb						ex de,hl 
360a					endif 
360a			 
360a			;	; get DO ptr 
360a			; 
360a				FORTH_RSP_TOS 
360a cd 28 1e			call macro_forth_rsp_tos 
360d				endm 
# End of macro FORTH_RSP_TOS
360d			 
360d				;push hl 
360d			 
360d				; not going to DO any more 
360d				; get rid of the RSP pointer as DO will add it back in 
360d				;FORTH_RSP_POP 
360d				;pop hl 
360d			 
360d			 
360d 22 c2 e5			ld (os_tok_ptr), hl 
3610					if DEBUG_FORTH_WORDS 
3610						DMARK "-L<" 
3610 f5				push af  
3611 3a 25 36			ld a, (.dmark)  
3614 32 6b ee			ld (debug_mark),a  
3617 3a 26 36			ld a, (.dmark+1)  
361a 32 6c ee			ld (debug_mark+1),a  
361d 3a 27 36			ld a, (.dmark+2)  
3620 32 6d ee			ld (debug_mark+2),a  
3623 18 03			jr .pastdmark  
3625 ..			.dmark: db "-L<"  
3628 f1			.pastdmark: pop af  
3629			endm  
# End of macro DMARK
3629					CALLMONITOR 
3629 cd 6f ee			call debug_vector  
362c				endm  
# End of macro CALLMONITOR
362c				endif 
362c c3 a8 22			jp exec1 
362f			 
362f					 
362f			 
362f			 
362f			 
362f				NEXTW 
362f c3 17 22			jp macro_next 
3632				endm 
# End of macro NEXTW
3632			 
3632			 
3632			 
3632			 
3632			.REPEAT: 
3632				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3632 71				db WORD_SYS_CORE+93             
3633 85 36			dw .UNTIL            
3635 06				db 5 + 1 
3636 .. 00			db "REPEAT",0              
363d				endm 
# End of macro CWHEAD
363d			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
363d			;  push pc to rsp stack past the REPEAT 
363d					if DEBUG_FORTH_WORDS_KEY 
363d						DMARK "REP" 
363d f5				push af  
363e 3a 52 36			ld a, (.dmark)  
3641 32 6b ee			ld (debug_mark),a  
3644 3a 53 36			ld a, (.dmark+1)  
3647 32 6c ee			ld (debug_mark+1),a  
364a 3a 54 36			ld a, (.dmark+2)  
364d 32 6d ee			ld (debug_mark+2),a  
3650 18 03			jr .pastdmark  
3652 ..			.dmark: db "REP"  
3655 f1			.pastdmark: pop af  
3656			endm  
# End of macro DMARK
3656						CALLMONITOR 
3656 cd 6f ee			call debug_vector  
3659				endm  
# End of macro CALLMONITOR
3659					endif 
3659			 
3659 2a c2 e5				ld hl, (os_tok_ptr) 
365c 23					inc hl   ; R 
365d 23					inc hl  ; E 
365e 23					inc hl   ; P 
365f 23					inc hl   ; E 
3660 23					inc hl   ; A 
3661 23					inc hl   ; T 
3662 23					inc hl   ; zero 
3663					FORTH_RSP_NEXT 
3663 cd 11 1e			call macro_forth_rsp_next 
3666				endm 
# End of macro FORTH_RSP_NEXT
3666			 
3666			 
3666					if DEBUG_FORTH_WORDS 
3666						DMARK "REP" 
3666 f5				push af  
3667 3a 7b 36			ld a, (.dmark)  
366a 32 6b ee			ld (debug_mark),a  
366d 3a 7c 36			ld a, (.dmark+1)  
3670 32 6c ee			ld (debug_mark+1),a  
3673 3a 7d 36			ld a, (.dmark+2)  
3676 32 6d ee			ld (debug_mark+2),a  
3679 18 03			jr .pastdmark  
367b ..			.dmark: db "REP"  
367e f1			.pastdmark: pop af  
367f			endm  
# End of macro DMARK
367f						;pop bc    ; TODO BUG ?????? what is this for???? 
367f						CALLMONITOR 
367f cd 6f ee			call debug_vector  
3682				endm  
# End of macro CALLMONITOR
3682					endif 
3682			 
3682					NEXTW 
3682 c3 17 22			jp macro_next 
3685				endm 
# End of macro NEXTW
3685			;	       NEXTW 
3685			 
3685			.UNTIL: 
3685				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3685 72				db WORD_SYS_CORE+94             
3686 1c 37			dw .ENDFLOW            
3688 06				db 5 + 1 
3689 .. 00			db "UNTIL",0              
368f				endm 
# End of macro CWHEAD
368f			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
368f			 
368f				; pop tos as check 
368f			 
368f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
368f			 
368f				FORTH_DSP_VALUEHL 
368f cd 61 20			call macro_dsp_valuehl 
3692				endm 
# End of macro FORTH_DSP_VALUEHL
3692			 
3692					if DEBUG_FORTH_WORDS_KEY 
3692						DMARK "UNT" 
3692 f5				push af  
3693 3a a7 36			ld a, (.dmark)  
3696 32 6b ee			ld (debug_mark),a  
3699 3a a8 36			ld a, (.dmark+1)  
369c 32 6c ee			ld (debug_mark+1),a  
369f 3a a9 36			ld a, (.dmark+2)  
36a2 32 6d ee			ld (debug_mark+2),a  
36a5 18 03			jr .pastdmark  
36a7 ..			.dmark: db "UNT"  
36aa f1			.pastdmark: pop af  
36ab			endm  
# End of macro DMARK
36ab						CALLMONITOR 
36ab cd 6f ee			call debug_vector  
36ae				endm  
# End of macro CALLMONITOR
36ae					endif 
36ae			 
36ae			;	push hl 
36ae				FORTH_DSP_POP 
36ae cd 19 21			call macro_forth_dsp_pop 
36b1				endm 
# End of macro FORTH_DSP_POP
36b1			 
36b1			;	pop hl 
36b1			 
36b1				; test if true 
36b1			 
36b1 cd 0f 0e			call ishlzero 
36b4			;	ld a,l 
36b4			;	add h 
36b4			; 
36b4			;	cp 0 
36b4			 
36b4 20 3e			jr nz, .untilnotdone 
36b6			 
36b6					if DEBUG_FORTH_WORDS 
36b6						DMARK "UNf" 
36b6 f5				push af  
36b7 3a cb 36			ld a, (.dmark)  
36ba 32 6b ee			ld (debug_mark),a  
36bd 3a cc 36			ld a, (.dmark+1)  
36c0 32 6c ee			ld (debug_mark+1),a  
36c3 3a cd 36			ld a, (.dmark+2)  
36c6 32 6d ee			ld (debug_mark+2),a  
36c9 18 03			jr .pastdmark  
36cb ..			.dmark: db "UNf"  
36ce f1			.pastdmark: pop af  
36cf			endm  
# End of macro DMARK
36cf						CALLMONITOR 
36cf cd 6f ee			call debug_vector  
36d2				endm  
# End of macro CALLMONITOR
36d2					endif 
36d2			 
36d2			 
36d2			 
36d2				FORTH_RSP_POP     ; get rid of DO ptr 
36d2 cd 32 1e			call macro_forth_rsp_pop 
36d5				endm 
# End of macro FORTH_RSP_POP
36d5			 
36d5			if DEBUG_FORTH_WORDS 
36d5						DMARK "UN>" 
36d5 f5				push af  
36d6 3a ea 36			ld a, (.dmark)  
36d9 32 6b ee			ld (debug_mark),a  
36dc 3a eb 36			ld a, (.dmark+1)  
36df 32 6c ee			ld (debug_mark+1),a  
36e2 3a ec 36			ld a, (.dmark+2)  
36e5 32 6d ee			ld (debug_mark+2),a  
36e8 18 03			jr .pastdmark  
36ea ..			.dmark: db "UN>"  
36ed f1			.pastdmark: pop af  
36ee			endm  
# End of macro DMARK
36ee				CALLMONITOR 
36ee cd 6f ee			call debug_vector  
36f1				endm  
# End of macro CALLMONITOR
36f1			endif 
36f1			 
36f1					NEXTW 
36f1 c3 17 22			jp macro_next 
36f4				endm 
# End of macro NEXTW
36f4				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
36f4			 
36f4			.untilnotdone: 
36f4			 
36f4			 
36f4			;	; get DO ptr 
36f4			; 
36f4				FORTH_RSP_TOS 
36f4 cd 28 1e			call macro_forth_rsp_tos 
36f7				endm 
# End of macro FORTH_RSP_TOS
36f7			 
36f7				;push hl 
36f7			 
36f7				; not going to DO any more 
36f7				; get rid of the RSP pointer as DO will add it back in 
36f7				;FORTH_RSP_POP 
36f7				;pop hl 
36f7			 
36f7			 
36f7 22 c2 e5			ld (os_tok_ptr), hl 
36fa					if DEBUG_FORTH_WORDS 
36fa						DMARK "UN<" 
36fa f5				push af  
36fb 3a 0f 37			ld a, (.dmark)  
36fe 32 6b ee			ld (debug_mark),a  
3701 3a 10 37			ld a, (.dmark+1)  
3704 32 6c ee			ld (debug_mark+1),a  
3707 3a 11 37			ld a, (.dmark+2)  
370a 32 6d ee			ld (debug_mark+2),a  
370d 18 03			jr .pastdmark  
370f ..			.dmark: db "UN<"  
3712 f1			.pastdmark: pop af  
3713			endm  
# End of macro DMARK
3713					CALLMONITOR 
3713 cd 6f ee			call debug_vector  
3716				endm  
# End of macro CALLMONITOR
3716				endif 
3716 c3 a8 22			jp exec1 
3719			 
3719					 
3719			 
3719			 
3719					NEXTW 
3719 c3 17 22			jp macro_next 
371c				endm 
# End of macro NEXTW
371c			 
371c			 
371c			.ENDFLOW: 
371c			 
371c			; eof 
371c			 
# End of file forth_words_flow.asm
371c			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
371c			include "forth_words_logic.asm" 
371c			 
371c			; | ## Logic Words 
371c			 
371c			.NOT: 
371c				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
371c 2d				db WORD_SYS_CORE+25             
371d 64 37			dw .IS            
371f 04				db 3 + 1 
3720 .. 00			db "NOT",0              
3724				endm 
# End of macro CWHEAD
3724			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3724					if DEBUG_FORTH_WORDS_KEY 
3724						DMARK "NOT" 
3724 f5				push af  
3725 3a 39 37			ld a, (.dmark)  
3728 32 6b ee			ld (debug_mark),a  
372b 3a 3a 37			ld a, (.dmark+1)  
372e 32 6c ee			ld (debug_mark+1),a  
3731 3a 3b 37			ld a, (.dmark+2)  
3734 32 6d ee			ld (debug_mark+2),a  
3737 18 03			jr .pastdmark  
3739 ..			.dmark: db "NOT"  
373c f1			.pastdmark: pop af  
373d			endm  
# End of macro DMARK
373d						CALLMONITOR 
373d cd 6f ee			call debug_vector  
3740				endm  
# End of macro CALLMONITOR
3740					endif 
3740					FORTH_DSP 
3740 cd 27 20			call macro_forth_dsp 
3743				endm 
# End of macro FORTH_DSP
3743 7e					ld a,(hl)	; get type of value on TOS 
3744 fe 02				cp DS_TYPE_INUM  
3746 28 03				jr z, .noti 
3748					NEXTW 
3748 c3 17 22			jp macro_next 
374b				endm 
# End of macro NEXTW
374b			.noti:          FORTH_DSP_VALUEHL 
374b cd 61 20			call macro_dsp_valuehl 
374e				endm 
# End of macro FORTH_DSP_VALUEHL
374e			;		push hl 
374e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
374e cd 19 21			call macro_forth_dsp_pop 
3751				endm 
# End of macro FORTH_DSP_POP
3751			;		pop hl 
3751 3e 00				ld a,0 
3753 bd					cp l 
3754 28 04				jr z, .not2t 
3756 2e 00				ld l, 0 
3758 18 02				jr .notip 
375a			 
375a 2e ff		.not2t:		ld l, 255 
375c			 
375c 26 00		.notip:		ld h, 0	 
375e			 
375e cd 6a 1e				call forth_push_numhl 
3761					NEXTW 
3761 c3 17 22			jp macro_next 
3764				endm 
# End of macro NEXTW
3764			 
3764			.IS: 
3764				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3764 2d				db WORD_SYS_CORE+25             
3765 8a 37			dw .LZERO            
3767 03				db 2 + 1 
3768 .. 00			db "IS",0              
376b				endm 
# End of macro CWHEAD
376b			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
376b					if DEBUG_FORTH_WORDS_KEY 
376b						DMARK "IS." 
376b f5				push af  
376c 3a 80 37			ld a, (.dmark)  
376f 32 6b ee			ld (debug_mark),a  
3772 3a 81 37			ld a, (.dmark+1)  
3775 32 6c ee			ld (debug_mark+1),a  
3778 3a 82 37			ld a, (.dmark+2)  
377b 32 6d ee			ld (debug_mark+2),a  
377e 18 03			jr .pastdmark  
3780 ..			.dmark: db "IS."  
3783 f1			.pastdmark: pop af  
3784			endm  
# End of macro DMARK
3784						CALLMONITOR 
3784 cd 6f ee			call debug_vector  
3787				endm  
# End of macro CALLMONITOR
3787					endif 
3787					NEXTW 
3787 c3 17 22			jp macro_next 
378a				endm 
# End of macro NEXTW
378a			.LZERO: 
378a				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
378a 2d				db WORD_SYS_CORE+25             
378b 94 37			dw .TZERO            
378d 03				db 2 + 1 
378e .. 00			db "0<",0              
3791				endm 
# End of macro CWHEAD
3791			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3791					NEXTW 
3791 c3 17 22			jp macro_next 
3794				endm 
# End of macro NEXTW
3794			.TZERO: 
3794				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3794 2e				db WORD_SYS_CORE+26             
3795 db 37			dw .LESS            
3797 03				db 2 + 1 
3798 .. 00			db "0=",0              
379b				endm 
# End of macro CWHEAD
379b			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
379b				; TODO add floating point number detection 
379b					;v5 FORTH_DSP_VALUE 
379b					if DEBUG_FORTH_WORDS_KEY 
379b						DMARK "0=." 
379b f5				push af  
379c 3a b0 37			ld a, (.dmark)  
379f 32 6b ee			ld (debug_mark),a  
37a2 3a b1 37			ld a, (.dmark+1)  
37a5 32 6c ee			ld (debug_mark+1),a  
37a8 3a b2 37			ld a, (.dmark+2)  
37ab 32 6d ee			ld (debug_mark+2),a  
37ae 18 03			jr .pastdmark  
37b0 ..			.dmark: db "0=."  
37b3 f1			.pastdmark: pop af  
37b4			endm  
# End of macro DMARK
37b4						CALLMONITOR 
37b4 cd 6f ee			call debug_vector  
37b7				endm  
# End of macro CALLMONITOR
37b7					endif 
37b7					FORTH_DSP 
37b7 cd 27 20			call macro_forth_dsp 
37ba				endm 
# End of macro FORTH_DSP
37ba 7e					ld a,(hl)	; get type of value on TOS 
37bb fe 02				cp DS_TYPE_INUM  
37bd 28 00				jr z, .tz_inum 
37bf			 
37bf				if FORTH_ENABLE_FLOATMATH 
37bf					jr .tz_done 
37bf			 
37bf				endif 
37bf					 
37bf			 
37bf			.tz_inum: 
37bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37bf cd 61 20			call macro_dsp_valuehl 
37c2				endm 
# End of macro FORTH_DSP_VALUEHL
37c2			 
37c2			;		push hl 
37c2			 
37c2					; destroy value TOS 
37c2			 
37c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37c2 cd 19 21			call macro_forth_dsp_pop 
37c5				endm 
# End of macro FORTH_DSP_POP
37c5			 
37c5			;		pop hl 
37c5			 
37c5 3e 00				ld a,0 
37c7			 
37c7 bd					cp l 
37c8 20 08				jr nz, .tz_notzero 
37ca			 
37ca bc					cp h 
37cb			 
37cb 20 05				jr nz, .tz_notzero 
37cd			 
37cd			 
37cd 21 01 00				ld hl, FORTH_TRUE 
37d0 18 03				jr .tz_done 
37d2			 
37d2 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
37d5			 
37d5					; push value back onto stack for another op etc 
37d5			 
37d5			.tz_done: 
37d5 cd 6a 1e				call forth_push_numhl 
37d8			 
37d8					NEXTW 
37d8 c3 17 22			jp macro_next 
37db				endm 
# End of macro NEXTW
37db			.LESS: 
37db				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
37db 2f				db WORD_SYS_CORE+27             
37dc 44 38			dw .GT            
37de 02				db 1 + 1 
37df .. 00			db "<",0              
37e1				endm 
# End of macro CWHEAD
37e1			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
37e1				; TODO add floating point number detection 
37e1					if DEBUG_FORTH_WORDS_KEY 
37e1						DMARK "LES" 
37e1 f5				push af  
37e2 3a f6 37			ld a, (.dmark)  
37e5 32 6b ee			ld (debug_mark),a  
37e8 3a f7 37			ld a, (.dmark+1)  
37eb 32 6c ee			ld (debug_mark+1),a  
37ee 3a f8 37			ld a, (.dmark+2)  
37f1 32 6d ee			ld (debug_mark+2),a  
37f4 18 03			jr .pastdmark  
37f6 ..			.dmark: db "LES"  
37f9 f1			.pastdmark: pop af  
37fa			endm  
# End of macro DMARK
37fa						CALLMONITOR 
37fa cd 6f ee			call debug_vector  
37fd				endm  
# End of macro CALLMONITOR
37fd					endif 
37fd					FORTH_DSP 
37fd cd 27 20			call macro_forth_dsp 
3800				endm 
# End of macro FORTH_DSP
3800					;v5 FORTH_DSP_VALUE 
3800 7e					ld a,(hl)	; get type of value on TOS 
3801 fe 02				cp DS_TYPE_INUM  
3803 28 00				jr z, .less_inum 
3805			 
3805				if FORTH_ENABLE_FLOATMATH 
3805					jr .less_done 
3805			 
3805				endif 
3805					 
3805			 
3805			.less_inum: 
3805					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3805 cd 61 20			call macro_dsp_valuehl 
3808				endm 
# End of macro FORTH_DSP_VALUEHL
3808			 
3808 e5					push hl  ; u2 
3809			 
3809					; destroy value TOS 
3809			 
3809					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3809 cd 19 21			call macro_forth_dsp_pop 
380c				endm 
# End of macro FORTH_DSP_POP
380c			 
380c			 
380c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380c cd 61 20			call macro_dsp_valuehl 
380f				endm 
# End of macro FORTH_DSP_VALUEHL
380f			 
380f e5					push hl    ; u1 
3810			 
3810					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3810 cd 19 21			call macro_forth_dsp_pop 
3813				endm 
# End of macro FORTH_DSP_POP
3813			 
3813			 
3813 b7			 or a      ;clear carry flag 
3814 01 00 00		 ld bc, FORTH_FALSE 
3817 e1			  pop hl    ; u1 
3818 d1			  pop de    ; u2 
3819 ed 52		  sbc hl,de 
381b 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
381d			 
381d 01 01 00		 ld bc, FORTH_TRUE 
3820			.lscont:  
3820 c5					push bc 
3821 e1					pop hl 
3822			 
3822					if DEBUG_FORTH_WORDS 
3822						DMARK "LT1" 
3822 f5				push af  
3823 3a 37 38			ld a, (.dmark)  
3826 32 6b ee			ld (debug_mark),a  
3829 3a 38 38			ld a, (.dmark+1)  
382c 32 6c ee			ld (debug_mark+1),a  
382f 3a 39 38			ld a, (.dmark+2)  
3832 32 6d ee			ld (debug_mark+2),a  
3835 18 03			jr .pastdmark  
3837 ..			.dmark: db "LT1"  
383a f1			.pastdmark: pop af  
383b			endm  
# End of macro DMARK
383b						CALLMONITOR 
383b cd 6f ee			call debug_vector  
383e				endm  
# End of macro CALLMONITOR
383e					endif 
383e cd 6a 1e				call forth_push_numhl 
3841			 
3841					NEXTW 
3841 c3 17 22			jp macro_next 
3844				endm 
# End of macro NEXTW
3844			.GT: 
3844				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3844 30				db WORD_SYS_CORE+28             
3845 ad 38			dw .EQUAL            
3847 02				db 1 + 1 
3848 .. 00			db ">",0              
384a				endm 
# End of macro CWHEAD
384a			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
384a				; TODO add floating point number detection 
384a					if DEBUG_FORTH_WORDS_KEY 
384a						DMARK "GRT" 
384a f5				push af  
384b 3a 5f 38			ld a, (.dmark)  
384e 32 6b ee			ld (debug_mark),a  
3851 3a 60 38			ld a, (.dmark+1)  
3854 32 6c ee			ld (debug_mark+1),a  
3857 3a 61 38			ld a, (.dmark+2)  
385a 32 6d ee			ld (debug_mark+2),a  
385d 18 03			jr .pastdmark  
385f ..			.dmark: db "GRT"  
3862 f1			.pastdmark: pop af  
3863			endm  
# End of macro DMARK
3863						CALLMONITOR 
3863 cd 6f ee			call debug_vector  
3866				endm  
# End of macro CALLMONITOR
3866					endif 
3866					FORTH_DSP 
3866 cd 27 20			call macro_forth_dsp 
3869				endm 
# End of macro FORTH_DSP
3869					;FORTH_DSP_VALUE 
3869 7e					ld a,(hl)	; get type of value on TOS 
386a fe 02				cp DS_TYPE_INUM  
386c 28 00				jr z, .gt_inum 
386e			 
386e				if FORTH_ENABLE_FLOATMATH 
386e					jr .gt_done 
386e			 
386e				endif 
386e					 
386e			 
386e			.gt_inum: 
386e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
386e cd 61 20			call macro_dsp_valuehl 
3871				endm 
# End of macro FORTH_DSP_VALUEHL
3871			 
3871 e5					push hl  ; u2 
3872			 
3872					; destroy value TOS 
3872			 
3872					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3872 cd 19 21			call macro_forth_dsp_pop 
3875				endm 
# End of macro FORTH_DSP_POP
3875			 
3875			 
3875					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3875 cd 61 20			call macro_dsp_valuehl 
3878				endm 
# End of macro FORTH_DSP_VALUEHL
3878			 
3878 e5					push hl    ; u1 
3879			 
3879					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3879 cd 19 21			call macro_forth_dsp_pop 
387c				endm 
# End of macro FORTH_DSP_POP
387c			 
387c			 
387c b7			 or a      ;clear carry flag 
387d 01 00 00		 ld bc, FORTH_FALSE 
3880 e1			  pop hl    ; u1 
3881 d1			  pop de    ; u2 
3882 ed 52		  sbc hl,de 
3884 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3886			 
3886 01 01 00		 ld bc, FORTH_TRUE 
3889			.gtcont:  
3889 c5					push bc 
388a e1					pop hl 
388b			 
388b					if DEBUG_FORTH_WORDS 
388b						DMARK "GT1" 
388b f5				push af  
388c 3a a0 38			ld a, (.dmark)  
388f 32 6b ee			ld (debug_mark),a  
3892 3a a1 38			ld a, (.dmark+1)  
3895 32 6c ee			ld (debug_mark+1),a  
3898 3a a2 38			ld a, (.dmark+2)  
389b 32 6d ee			ld (debug_mark+2),a  
389e 18 03			jr .pastdmark  
38a0 ..			.dmark: db "GT1"  
38a3 f1			.pastdmark: pop af  
38a4			endm  
# End of macro DMARK
38a4						CALLMONITOR 
38a4 cd 6f ee			call debug_vector  
38a7				endm  
# End of macro CALLMONITOR
38a7					endif 
38a7 cd 6a 1e				call forth_push_numhl 
38aa			 
38aa					NEXTW 
38aa c3 17 22			jp macro_next 
38ad				endm 
# End of macro NEXTW
38ad			.EQUAL: 
38ad				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
38ad 31				db WORD_SYS_CORE+29             
38ae 18 39			dw .ENDLOGIC            
38b0 02				db 1 + 1 
38b1 .. 00			db "=",0              
38b3				endm 
# End of macro CWHEAD
38b3			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
38b3				; TODO add floating point number detection 
38b3					if DEBUG_FORTH_WORDS_KEY 
38b3						DMARK "EQ." 
38b3 f5				push af  
38b4 3a c8 38			ld a, (.dmark)  
38b7 32 6b ee			ld (debug_mark),a  
38ba 3a c9 38			ld a, (.dmark+1)  
38bd 32 6c ee			ld (debug_mark+1),a  
38c0 3a ca 38			ld a, (.dmark+2)  
38c3 32 6d ee			ld (debug_mark+2),a  
38c6 18 03			jr .pastdmark  
38c8 ..			.dmark: db "EQ."  
38cb f1			.pastdmark: pop af  
38cc			endm  
# End of macro DMARK
38cc						CALLMONITOR 
38cc cd 6f ee			call debug_vector  
38cf				endm  
# End of macro CALLMONITOR
38cf					endif 
38cf					FORTH_DSP 
38cf cd 27 20			call macro_forth_dsp 
38d2				endm 
# End of macro FORTH_DSP
38d2					;v5 FORTH_DSP_VALUE 
38d2 7e					ld a,(hl)	; get type of value on TOS 
38d3 fe 02				cp DS_TYPE_INUM  
38d5 28 00				jr z, .eq_inum 
38d7			 
38d7				if FORTH_ENABLE_FLOATMATH 
38d7					jr .eq_done 
38d7			 
38d7				endif 
38d7					 
38d7			 
38d7			.eq_inum: 
38d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38d7 cd 61 20			call macro_dsp_valuehl 
38da				endm 
# End of macro FORTH_DSP_VALUEHL
38da			 
38da e5					push hl 
38db			 
38db					; destroy value TOS 
38db			 
38db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38db cd 19 21			call macro_forth_dsp_pop 
38de				endm 
# End of macro FORTH_DSP_POP
38de			 
38de			 
38de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38de cd 61 20			call macro_dsp_valuehl 
38e1				endm 
# End of macro FORTH_DSP_VALUEHL
38e1			 
38e1					; one value on hl get other one back 
38e1			 
38e1 e5					push hl 
38e2			 
38e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e2 cd 19 21			call macro_forth_dsp_pop 
38e5				endm 
# End of macro FORTH_DSP_POP
38e5			 
38e5 0e 00				ld c, FORTH_FALSE 
38e7			 
38e7 e1					pop hl 
38e8 d1					pop de 
38e9			 
38e9 7b					ld a, e 
38ea bd					cp l 
38eb			 
38eb 20 06				jr nz, .eq_done 
38ed			 
38ed 7a					ld a, d 
38ee bc					cp h 
38ef			 
38ef 20 02				jr nz, .eq_done 
38f1			 
38f1 0e 01				ld c, FORTH_TRUE 
38f3					 
38f3			 
38f3			 
38f3			.eq_done: 
38f3			 
38f3					; TODO push value back onto stack for another op etc 
38f3			 
38f3 26 00				ld h, 0 
38f5 69					ld l, c 
38f6					if DEBUG_FORTH_WORDS 
38f6						DMARK "EQ1" 
38f6 f5				push af  
38f7 3a 0b 39			ld a, (.dmark)  
38fa 32 6b ee			ld (debug_mark),a  
38fd 3a 0c 39			ld a, (.dmark+1)  
3900 32 6c ee			ld (debug_mark+1),a  
3903 3a 0d 39			ld a, (.dmark+2)  
3906 32 6d ee			ld (debug_mark+2),a  
3909 18 03			jr .pastdmark  
390b ..			.dmark: db "EQ1"  
390e f1			.pastdmark: pop af  
390f			endm  
# End of macro DMARK
390f						CALLMONITOR 
390f cd 6f ee			call debug_vector  
3912				endm  
# End of macro CALLMONITOR
3912					endif 
3912 cd 6a 1e				call forth_push_numhl 
3915			 
3915					NEXTW 
3915 c3 17 22			jp macro_next 
3918				endm 
# End of macro NEXTW
3918			 
3918			 
3918			.ENDLOGIC: 
3918			; eof 
3918			 
3918			 
# End of file forth_words_logic.asm
3918			include "forth_words_maths.asm" 
3918			 
3918			; | ## Maths Words 
3918			 
3918			.PLUS:	 
3918				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3918 15				db WORD_SYS_CORE+1             
3919 76 39			dw .NEG            
391b 02				db 1 + 1 
391c .. 00			db "+",0              
391e				endm 
# End of macro CWHEAD
391e			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
391e					if DEBUG_FORTH_WORDS_KEY 
391e						DMARK "PLU" 
391e f5				push af  
391f 3a 33 39			ld a, (.dmark)  
3922 32 6b ee			ld (debug_mark),a  
3925 3a 34 39			ld a, (.dmark+1)  
3928 32 6c ee			ld (debug_mark+1),a  
392b 3a 35 39			ld a, (.dmark+2)  
392e 32 6d ee			ld (debug_mark+2),a  
3931 18 03			jr .pastdmark  
3933 ..			.dmark: db "PLU"  
3936 f1			.pastdmark: pop af  
3937			endm  
# End of macro DMARK
3937						CALLMONITOR 
3937 cd 6f ee			call debug_vector  
393a				endm  
# End of macro CALLMONITOR
393a					endif 
393a					; add top two values and push back result 
393a			 
393a					;for v5 FORTH_DSP_VALUE 
393a					FORTH_DSP 
393a cd 27 20			call macro_forth_dsp 
393d				endm 
# End of macro FORTH_DSP
393d 7e					ld a,(hl)	; get type of value on TOS 
393e fe 02				cp DS_TYPE_INUM  
3940 28 03				jr z, .dot_inum 
3942			 
3942					NEXTW 
3942 c3 17 22			jp macro_next 
3945				endm 
# End of macro NEXTW
3945			 
3945			; float maths 
3945			 
3945				if FORTH_ENABLE_FLOATMATH 
3945						inc hl      ; now at start of numeric as string 
3945			 
3945					if DEBUG_FORTH_MATHS 
3945						DMARK "ADD" 
3945				CALLMONITOR 
3945					endif 
3945			 
3945					;ld ix, hl 
3945					call CON 
3945			 
3945			 
3945					push hl 
3945					 
3945					 
3945			 
3945						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3945			 
3945					; get next number 
3945			 
3945						FORTH_DSP_VALUE 
3945			 
3945						inc hl      ; now at start of numeric as string 
3945			 
3945					;ld ix, hl 
3945					call CON 
3945			 
3945					push hl 
3945			 
3945			 
3945						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3945			 
3945						; TODO do add 
3945			 
3945						call IADD 
3945			 
3945						; TODO get result back as ascii 
3945			 
3945						; TODO push result  
3945			 
3945			 
3945			 
3945						jr .dot_done 
3945				endif 
3945			 
3945			.dot_inum: 
3945			 
3945			 
3945					if DEBUG_FORTH_DOT 
3945						DMARK "+IT" 
3945 f5				push af  
3946 3a 5a 39			ld a, (.dmark)  
3949 32 6b ee			ld (debug_mark),a  
394c 3a 5b 39			ld a, (.dmark+1)  
394f 32 6c ee			ld (debug_mark+1),a  
3952 3a 5c 39			ld a, (.dmark+2)  
3955 32 6d ee			ld (debug_mark+2),a  
3958 18 03			jr .pastdmark  
395a ..			.dmark: db "+IT"  
395d f1			.pastdmark: pop af  
395e			endm  
# End of macro DMARK
395e				CALLMONITOR 
395e cd 6f ee			call debug_vector  
3961				endm  
# End of macro CALLMONITOR
3961					endif 
3961			 
3961					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3961 cd 61 20			call macro_dsp_valuehl 
3964				endm 
# End of macro FORTH_DSP_VALUEHL
3964			 
3964				; TODO add floating point number detection 
3964			 
3964 e5					push hl 
3965			 
3965					; destroy value TOS 
3965			 
3965					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3965 cd 19 21			call macro_forth_dsp_pop 
3968				endm 
# End of macro FORTH_DSP_POP
3968			 
3968			 
3968					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3968 cd 61 20			call macro_dsp_valuehl 
396b				endm 
# End of macro FORTH_DSP_VALUEHL
396b			 
396b					; one value on hl get other one back 
396b			 
396b d1					pop de 
396c			 
396c					; do the add 
396c			 
396c 19					add hl,de 
396d			 
396d					; save it 
396d			 
396d			;		push hl	 
396d			 
396d					; 
396d			 
396d					; destroy value TOS 
396d			 
396d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
396d cd 19 21			call macro_forth_dsp_pop 
3970				endm 
# End of macro FORTH_DSP_POP
3970			 
3970					; TODO push value back onto stack for another op etc 
3970			 
3970			;		pop hl 
3970			 
3970			.dot_done: 
3970 cd 6a 1e				call forth_push_numhl 
3973			 
3973					NEXTW 
3973 c3 17 22			jp macro_next 
3976				endm 
# End of macro NEXTW
3976			.NEG: 
3976			 
3976				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3976 17				db WORD_SYS_CORE+3             
3977 b9 39			dw .DIV            
3979 02				db 1 + 1 
397a .. 00			db "-",0              
397c				endm 
# End of macro CWHEAD
397c			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
397c					if DEBUG_FORTH_WORDS_KEY 
397c						DMARK "SUB" 
397c f5				push af  
397d 3a 91 39			ld a, (.dmark)  
3980 32 6b ee			ld (debug_mark),a  
3983 3a 92 39			ld a, (.dmark+1)  
3986 32 6c ee			ld (debug_mark+1),a  
3989 3a 93 39			ld a, (.dmark+2)  
398c 32 6d ee			ld (debug_mark+2),a  
398f 18 03			jr .pastdmark  
3991 ..			.dmark: db "SUB"  
3994 f1			.pastdmark: pop af  
3995			endm  
# End of macro DMARK
3995						CALLMONITOR 
3995 cd 6f ee			call debug_vector  
3998				endm  
# End of macro CALLMONITOR
3998					endif 
3998			 
3998			 
3998				; TODO add floating point number detection 
3998					; v5 FORTH_DSP_VALUE 
3998					FORTH_DSP 
3998 cd 27 20			call macro_forth_dsp 
399b				endm 
# End of macro FORTH_DSP
399b 7e					ld a,(hl)	; get type of value on TOS 
399c fe 02				cp DS_TYPE_INUM  
399e 28 03				jr z, .neg_inum 
39a0			 
39a0					NEXTW 
39a0 c3 17 22			jp macro_next 
39a3				endm 
# End of macro NEXTW
39a3			 
39a3			; float maths 
39a3			 
39a3				if FORTH_ENABLE_FLOATMATH 
39a3					jr .neg_done 
39a3			 
39a3				endif 
39a3					 
39a3			 
39a3			.neg_inum: 
39a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39a3 cd 61 20			call macro_dsp_valuehl 
39a6				endm 
# End of macro FORTH_DSP_VALUEHL
39a6			 
39a6 e5					push hl 
39a7			 
39a7					; destroy value TOS 
39a7			 
39a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39a7 cd 19 21			call macro_forth_dsp_pop 
39aa				endm 
# End of macro FORTH_DSP_POP
39aa			 
39aa			 
39aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39aa cd 61 20			call macro_dsp_valuehl 
39ad				endm 
# End of macro FORTH_DSP_VALUEHL
39ad			 
39ad					; one value on hl get other one back 
39ad			 
39ad d1					pop de 
39ae			 
39ae					; do the sub 
39ae			;		ex de, hl 
39ae			 
39ae ed 52				sbc hl,de 
39b0			 
39b0					; save it 
39b0			 
39b0			;		push hl	 
39b0			 
39b0					; 
39b0			 
39b0					; destroy value TOS 
39b0			 
39b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39b0 cd 19 21			call macro_forth_dsp_pop 
39b3				endm 
# End of macro FORTH_DSP_POP
39b3			 
39b3					; TODO push value back onto stack for another op etc 
39b3			 
39b3			;		pop hl 
39b3			 
39b3 cd 6a 1e				call forth_push_numhl 
39b6			.neg_done: 
39b6			 
39b6					NEXTW 
39b6 c3 17 22			jp macro_next 
39b9				endm 
# End of macro NEXTW
39b9			.DIV: 
39b9				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
39b9 18				db WORD_SYS_CORE+4             
39ba 06 3a			dw .MUL            
39bc 02				db 1 + 1 
39bd .. 00			db "/",0              
39bf				endm 
# End of macro CWHEAD
39bf			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
39bf					if DEBUG_FORTH_WORDS_KEY 
39bf						DMARK "DIV" 
39bf f5				push af  
39c0 3a d4 39			ld a, (.dmark)  
39c3 32 6b ee			ld (debug_mark),a  
39c6 3a d5 39			ld a, (.dmark+1)  
39c9 32 6c ee			ld (debug_mark+1),a  
39cc 3a d6 39			ld a, (.dmark+2)  
39cf 32 6d ee			ld (debug_mark+2),a  
39d2 18 03			jr .pastdmark  
39d4 ..			.dmark: db "DIV"  
39d7 f1			.pastdmark: pop af  
39d8			endm  
# End of macro DMARK
39d8						CALLMONITOR 
39d8 cd 6f ee			call debug_vector  
39db				endm  
# End of macro CALLMONITOR
39db					endif 
39db				; TODO add floating point number detection 
39db					; v5 FORTH_DSP_VALUE 
39db					FORTH_DSP 
39db cd 27 20			call macro_forth_dsp 
39de				endm 
# End of macro FORTH_DSP
39de 7e					ld a,(hl)	; get type of value on TOS 
39df fe 02				cp DS_TYPE_INUM  
39e1 28 03				jr z, .div_inum 
39e3			 
39e3				if FORTH_ENABLE_FLOATMATH 
39e3					jr .div_done 
39e3			 
39e3				endif 
39e3					NEXTW 
39e3 c3 17 22			jp macro_next 
39e6				endm 
# End of macro NEXTW
39e6			.div_inum: 
39e6			 
39e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39e6 cd 61 20			call macro_dsp_valuehl 
39e9				endm 
# End of macro FORTH_DSP_VALUEHL
39e9			 
39e9 e5					push hl    ; to go to bc 
39ea			 
39ea					; destroy value TOS 
39ea			 
39ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ea cd 19 21			call macro_forth_dsp_pop 
39ed				endm 
# End of macro FORTH_DSP_POP
39ed			 
39ed			 
39ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ed cd 61 20			call macro_dsp_valuehl 
39f0				endm 
# End of macro FORTH_DSP_VALUEHL
39f0			 
39f0					; hl to go to de 
39f0			 
39f0 e5					push hl 
39f1			 
39f1 c1					pop bc 
39f2 d1					pop de		 
39f3			 
39f3			 
39f3					if DEBUG_FORTH_MATHS 
39f3						DMARK "DIV" 
39f3				CALLMONITOR 
39f3					endif 
39f3					; one value on hl but move to a get other one back 
39f3			 
39f3			        
39f3 cd 43 0d			call Div16 
39f6			 
39f6			;	push af	 
39f6 e5				push hl 
39f7 c5				push bc 
39f8			 
39f8					if DEBUG_FORTH_MATHS 
39f8						DMARK "DI1" 
39f8				CALLMONITOR 
39f8					endif 
39f8			 
39f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f8 cd 19 21			call macro_forth_dsp_pop 
39fb				endm 
# End of macro FORTH_DSP_POP
39fb			 
39fb			 
39fb			 
39fb e1					pop hl    ; result 
39fc			 
39fc cd 6a 1e				call forth_push_numhl 
39ff			 
39ff e1					pop hl    ; reminder 
3a00			;		ld h,0 
3a00			;		ld l,d 
3a00			 
3a00 cd 6a 1e				call forth_push_numhl 
3a03			.div_done: 
3a03					NEXTW 
3a03 c3 17 22			jp macro_next 
3a06				endm 
# End of macro NEXTW
3a06			.MUL: 
3a06				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a06 19				db WORD_SYS_CORE+5             
3a07 4b 3a			dw .MIN            
3a09 02				db 1 + 1 
3a0a .. 00			db "*",0              
3a0c				endm 
# End of macro CWHEAD
3a0c			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a0c				; TODO add floating point number detection 
3a0c					if DEBUG_FORTH_WORDS_KEY 
3a0c						DMARK "MUL" 
3a0c f5				push af  
3a0d 3a 21 3a			ld a, (.dmark)  
3a10 32 6b ee			ld (debug_mark),a  
3a13 3a 22 3a			ld a, (.dmark+1)  
3a16 32 6c ee			ld (debug_mark+1),a  
3a19 3a 23 3a			ld a, (.dmark+2)  
3a1c 32 6d ee			ld (debug_mark+2),a  
3a1f 18 03			jr .pastdmark  
3a21 ..			.dmark: db "MUL"  
3a24 f1			.pastdmark: pop af  
3a25			endm  
# End of macro DMARK
3a25						CALLMONITOR 
3a25 cd 6f ee			call debug_vector  
3a28				endm  
# End of macro CALLMONITOR
3a28					endif 
3a28					FORTH_DSP 
3a28 cd 27 20			call macro_forth_dsp 
3a2b				endm 
# End of macro FORTH_DSP
3a2b					; v5 FORTH_DSP_VALUE 
3a2b 7e					ld a,(hl)	; get type of value on TOS 
3a2c fe 02				cp DS_TYPE_INUM  
3a2e 28 03				jr z, .mul_inum 
3a30			 
3a30				if FORTH_ENABLE_FLOATMATH 
3a30					jr .mul_done 
3a30			 
3a30				endif 
3a30			 
3a30					NEXTW 
3a30 c3 17 22			jp macro_next 
3a33				endm 
# End of macro NEXTW
3a33			.mul_inum:	 
3a33			 
3a33					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a33 cd 61 20			call macro_dsp_valuehl 
3a36				endm 
# End of macro FORTH_DSP_VALUEHL
3a36			 
3a36 e5					push hl 
3a37			 
3a37					; destroy value TOS 
3a37			 
3a37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a37 cd 19 21			call macro_forth_dsp_pop 
3a3a				endm 
# End of macro FORTH_DSP_POP
3a3a			 
3a3a			 
3a3a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a3a cd 61 20			call macro_dsp_valuehl 
3a3d				endm 
# End of macro FORTH_DSP_VALUEHL
3a3d			 
3a3d					; one value on hl but move to a get other one back 
3a3d			 
3a3d 7d					ld a, l 
3a3e			 
3a3e d1					pop de 
3a3f			 
3a3f					; do the mull 
3a3f			;		ex de, hl 
3a3f			 
3a3f cd 69 0d				call Mult16 
3a42					; save it 
3a42			 
3a42			;		push hl	 
3a42			 
3a42					; 
3a42			 
3a42					; destroy value TOS 
3a42			 
3a42					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a42 cd 19 21			call macro_forth_dsp_pop 
3a45				endm 
# End of macro FORTH_DSP_POP
3a45			 
3a45					; TODO push value back onto stack for another op etc 
3a45			 
3a45			;		pop hl 
3a45			 
3a45 cd 6a 1e				call forth_push_numhl 
3a48			 
3a48			.mul_done: 
3a48					NEXTW 
3a48 c3 17 22			jp macro_next 
3a4b				endm 
# End of macro NEXTW
3a4b			 
3a4b			 
3a4b			 
3a4b			 
3a4b			.MIN: 
3a4b				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3a4b 49				db WORD_SYS_CORE+53             
3a4c cc 3a			dw .MAX            
3a4e 04				db 3 + 1 
3a4f .. 00			db "MIN",0              
3a53				endm 
# End of macro CWHEAD
3a53			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3a53					if DEBUG_FORTH_WORDS_KEY 
3a53						DMARK "MIN" 
3a53 f5				push af  
3a54 3a 68 3a			ld a, (.dmark)  
3a57 32 6b ee			ld (debug_mark),a  
3a5a 3a 69 3a			ld a, (.dmark+1)  
3a5d 32 6c ee			ld (debug_mark+1),a  
3a60 3a 6a 3a			ld a, (.dmark+2)  
3a63 32 6d ee			ld (debug_mark+2),a  
3a66 18 03			jr .pastdmark  
3a68 ..			.dmark: db "MIN"  
3a6b f1			.pastdmark: pop af  
3a6c			endm  
# End of macro DMARK
3a6c						CALLMONITOR 
3a6c cd 6f ee			call debug_vector  
3a6f				endm  
# End of macro CALLMONITOR
3a6f					endif 
3a6f					; get u2 
3a6f			 
3a6f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a6f cd 61 20			call macro_dsp_valuehl 
3a72				endm 
# End of macro FORTH_DSP_VALUEHL
3a72			 
3a72 e5					push hl   ; u2 
3a73			 
3a73					; destroy value TOS 
3a73			 
3a73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a73 cd 19 21			call macro_forth_dsp_pop 
3a76				endm 
# End of macro FORTH_DSP_POP
3a76			 
3a76					; get u1 
3a76			 
3a76					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a76 cd 61 20			call macro_dsp_valuehl 
3a79				endm 
# End of macro FORTH_DSP_VALUEHL
3a79			 
3a79 e5					push hl  ; u1 
3a7a			 
3a7a					; destroy value TOS 
3a7a			 
3a7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a7a cd 19 21			call macro_forth_dsp_pop 
3a7d				endm 
# End of macro FORTH_DSP_POP
3a7d			 
3a7d b7			 or a      ;clear carry flag 
3a7e e1			  pop hl    ; u1 
3a7f d1			  pop de    ; u2 
3a80 e5				push hl   ; saved in case hl is lowest 
3a81 ed 52		  sbc hl,de 
3a83 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3a85			 
3a85 e1				pop hl 
3a86					if DEBUG_FORTH_WORDS 
3a86						DMARK "MIN" 
3a86 f5				push af  
3a87 3a 9b 3a			ld a, (.dmark)  
3a8a 32 6b ee			ld (debug_mark),a  
3a8d 3a 9c 3a			ld a, (.dmark+1)  
3a90 32 6c ee			ld (debug_mark+1),a  
3a93 3a 9d 3a			ld a, (.dmark+2)  
3a96 32 6d ee			ld (debug_mark+2),a  
3a99 18 03			jr .pastdmark  
3a9b ..			.dmark: db "MIN"  
3a9e f1			.pastdmark: pop af  
3a9f			endm  
# End of macro DMARK
3a9f						CALLMONITOR 
3a9f cd 6f ee			call debug_vector  
3aa2				endm  
# End of macro CALLMONITOR
3aa2					endif 
3aa2 cd 6a 1e				call forth_push_numhl 
3aa5			 
3aa5				       NEXTW 
3aa5 c3 17 22			jp macro_next 
3aa8				endm 
# End of macro NEXTW
3aa8			 
3aa8			.mincont:  
3aa8 c1				pop bc   ; tidy up 
3aa9 eb				ex de , hl  
3aaa					if DEBUG_FORTH_WORDS 
3aaa						DMARK "MI1" 
3aaa f5				push af  
3aab 3a bf 3a			ld a, (.dmark)  
3aae 32 6b ee			ld (debug_mark),a  
3ab1 3a c0 3a			ld a, (.dmark+1)  
3ab4 32 6c ee			ld (debug_mark+1),a  
3ab7 3a c1 3a			ld a, (.dmark+2)  
3aba 32 6d ee			ld (debug_mark+2),a  
3abd 18 03			jr .pastdmark  
3abf ..			.dmark: db "MI1"  
3ac2 f1			.pastdmark: pop af  
3ac3			endm  
# End of macro DMARK
3ac3						CALLMONITOR 
3ac3 cd 6f ee			call debug_vector  
3ac6				endm  
# End of macro CALLMONITOR
3ac6					endif 
3ac6 cd 6a 1e				call forth_push_numhl 
3ac9			 
3ac9				       NEXTW 
3ac9 c3 17 22			jp macro_next 
3acc				endm 
# End of macro NEXTW
3acc			.MAX: 
3acc				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3acc 4a				db WORD_SYS_CORE+54             
3acd 4d 3b			dw .RND16            
3acf 04				db 3 + 1 
3ad0 .. 00			db "MAX",0              
3ad4				endm 
# End of macro CWHEAD
3ad4			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3ad4					if DEBUG_FORTH_WORDS_KEY 
3ad4						DMARK "MAX" 
3ad4 f5				push af  
3ad5 3a e9 3a			ld a, (.dmark)  
3ad8 32 6b ee			ld (debug_mark),a  
3adb 3a ea 3a			ld a, (.dmark+1)  
3ade 32 6c ee			ld (debug_mark+1),a  
3ae1 3a eb 3a			ld a, (.dmark+2)  
3ae4 32 6d ee			ld (debug_mark+2),a  
3ae7 18 03			jr .pastdmark  
3ae9 ..			.dmark: db "MAX"  
3aec f1			.pastdmark: pop af  
3aed			endm  
# End of macro DMARK
3aed						CALLMONITOR 
3aed cd 6f ee			call debug_vector  
3af0				endm  
# End of macro CALLMONITOR
3af0					endif 
3af0					; get u2 
3af0			 
3af0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3af0 cd 61 20			call macro_dsp_valuehl 
3af3				endm 
# End of macro FORTH_DSP_VALUEHL
3af3			 
3af3 e5					push hl   ; u2 
3af4			 
3af4					; destroy value TOS 
3af4			 
3af4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3af4 cd 19 21			call macro_forth_dsp_pop 
3af7				endm 
# End of macro FORTH_DSP_POP
3af7			 
3af7					; get u1 
3af7			 
3af7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3af7 cd 61 20			call macro_dsp_valuehl 
3afa				endm 
# End of macro FORTH_DSP_VALUEHL
3afa			 
3afa e5					push hl  ; u1 
3afb			 
3afb					; destroy value TOS 
3afb			 
3afb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3afb cd 19 21			call macro_forth_dsp_pop 
3afe				endm 
# End of macro FORTH_DSP_POP
3afe			 
3afe b7			 or a      ;clear carry flag 
3aff e1			  pop hl    ; u1 
3b00 d1			  pop de    ; u2 
3b01 e5				push hl   ; saved in case hl is lowest 
3b02 ed 52		  sbc hl,de 
3b04 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b06			 
3b06 e1				pop hl 
3b07					if DEBUG_FORTH_WORDS 
3b07						DMARK "MAX" 
3b07 f5				push af  
3b08 3a 1c 3b			ld a, (.dmark)  
3b0b 32 6b ee			ld (debug_mark),a  
3b0e 3a 1d 3b			ld a, (.dmark+1)  
3b11 32 6c ee			ld (debug_mark+1),a  
3b14 3a 1e 3b			ld a, (.dmark+2)  
3b17 32 6d ee			ld (debug_mark+2),a  
3b1a 18 03			jr .pastdmark  
3b1c ..			.dmark: db "MAX"  
3b1f f1			.pastdmark: pop af  
3b20			endm  
# End of macro DMARK
3b20						CALLMONITOR 
3b20 cd 6f ee			call debug_vector  
3b23				endm  
# End of macro CALLMONITOR
3b23					endif 
3b23 cd 6a 1e				call forth_push_numhl 
3b26			 
3b26				       NEXTW 
3b26 c3 17 22			jp macro_next 
3b29				endm 
# End of macro NEXTW
3b29			 
3b29			.maxcont:  
3b29 c1				pop bc   ; tidy up 
3b2a eb				ex de , hl  
3b2b					if DEBUG_FORTH_WORDS 
3b2b						DMARK "MA1" 
3b2b f5				push af  
3b2c 3a 40 3b			ld a, (.dmark)  
3b2f 32 6b ee			ld (debug_mark),a  
3b32 3a 41 3b			ld a, (.dmark+1)  
3b35 32 6c ee			ld (debug_mark+1),a  
3b38 3a 42 3b			ld a, (.dmark+2)  
3b3b 32 6d ee			ld (debug_mark+2),a  
3b3e 18 03			jr .pastdmark  
3b40 ..			.dmark: db "MA1"  
3b43 f1			.pastdmark: pop af  
3b44			endm  
# End of macro DMARK
3b44						CALLMONITOR 
3b44 cd 6f ee			call debug_vector  
3b47				endm  
# End of macro CALLMONITOR
3b47					endif 
3b47 cd 6a 1e				call forth_push_numhl 
3b4a				       NEXTW 
3b4a c3 17 22			jp macro_next 
3b4d				endm 
# End of macro NEXTW
3b4d			 
3b4d			.RND16: 
3b4d				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3b4d 4e				db WORD_SYS_CORE+58             
3b4e 7c 3b			dw .RND8            
3b50 06				db 5 + 1 
3b51 .. 00			db "RND16",0              
3b57				endm 
# End of macro CWHEAD
3b57			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3b57					if DEBUG_FORTH_WORDS_KEY 
3b57						DMARK "R16" 
3b57 f5				push af  
3b58 3a 6c 3b			ld a, (.dmark)  
3b5b 32 6b ee			ld (debug_mark),a  
3b5e 3a 6d 3b			ld a, (.dmark+1)  
3b61 32 6c ee			ld (debug_mark+1),a  
3b64 3a 6e 3b			ld a, (.dmark+2)  
3b67 32 6d ee			ld (debug_mark+2),a  
3b6a 18 03			jr .pastdmark  
3b6c ..			.dmark: db "R16"  
3b6f f1			.pastdmark: pop af  
3b70			endm  
# End of macro DMARK
3b70						CALLMONITOR 
3b70 cd 6f ee			call debug_vector  
3b73				endm  
# End of macro CALLMONITOR
3b73					endif 
3b73 cd 0d 0d				call prng16  
3b76 cd 6a 1e				call forth_push_numhl 
3b79				       NEXTW 
3b79 c3 17 22			jp macro_next 
3b7c				endm 
# End of macro NEXTW
3b7c			.RND8: 
3b7c				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3b7c 60				db WORD_SYS_CORE+76             
3b7d b1 3b			dw .RND            
3b7f 05				db 4 + 1 
3b80 .. 00			db "RND8",0              
3b85				endm 
# End of macro CWHEAD
3b85			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3b85					if DEBUG_FORTH_WORDS_KEY 
3b85						DMARK "RN8" 
3b85 f5				push af  
3b86 3a 9a 3b			ld a, (.dmark)  
3b89 32 6b ee			ld (debug_mark),a  
3b8c 3a 9b 3b			ld a, (.dmark+1)  
3b8f 32 6c ee			ld (debug_mark+1),a  
3b92 3a 9c 3b			ld a, (.dmark+2)  
3b95 32 6d ee			ld (debug_mark+2),a  
3b98 18 03			jr .pastdmark  
3b9a ..			.dmark: db "RN8"  
3b9d f1			.pastdmark: pop af  
3b9e			endm  
# End of macro DMARK
3b9e						CALLMONITOR 
3b9e cd 6f ee			call debug_vector  
3ba1				endm  
# End of macro CALLMONITOR
3ba1					endif 
3ba1 2a a9 eb				ld hl,(xrandc) 
3ba4 23					inc hl 
3ba5 cd 27 0d				call xrnd 
3ba8 6f					ld l,a	 
3ba9 26 00				ld h,0 
3bab cd 6a 1e				call forth_push_numhl 
3bae				       NEXTW 
3bae c3 17 22			jp macro_next 
3bb1				endm 
# End of macro NEXTW
3bb1			.RND: 
3bb1				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3bb1 60				db WORD_SYS_CORE+76             
3bb2 b7 3c			dw .ENDMATHS            
3bb4 04				db 3 + 1 
3bb5 .. 00			db "RND",0              
3bb9				endm 
# End of macro CWHEAD
3bb9			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3bb9			 
3bb9					if DEBUG_FORTH_WORDS_KEY 
3bb9						DMARK "RND" 
3bb9 f5				push af  
3bba 3a ce 3b			ld a, (.dmark)  
3bbd 32 6b ee			ld (debug_mark),a  
3bc0 3a cf 3b			ld a, (.dmark+1)  
3bc3 32 6c ee			ld (debug_mark+1),a  
3bc6 3a d0 3b			ld a, (.dmark+2)  
3bc9 32 6d ee			ld (debug_mark+2),a  
3bcc 18 03			jr .pastdmark  
3bce ..			.dmark: db "RND"  
3bd1 f1			.pastdmark: pop af  
3bd2			endm  
# End of macro DMARK
3bd2						CALLMONITOR 
3bd2 cd 6f ee			call debug_vector  
3bd5				endm  
# End of macro CALLMONITOR
3bd5					endif 
3bd5					 
3bd5					FORTH_DSP_VALUEHL    ; upper range 
3bd5 cd 61 20			call macro_dsp_valuehl 
3bd8				endm 
# End of macro FORTH_DSP_VALUEHL
3bd8			 
3bd8 22 ad eb				ld (LFSRSeed), hl	 
3bdb			 
3bdb					if DEBUG_FORTH_WORDS 
3bdb						DMARK "RN1" 
3bdb f5				push af  
3bdc 3a f0 3b			ld a, (.dmark)  
3bdf 32 6b ee			ld (debug_mark),a  
3be2 3a f1 3b			ld a, (.dmark+1)  
3be5 32 6c ee			ld (debug_mark+1),a  
3be8 3a f2 3b			ld a, (.dmark+2)  
3beb 32 6d ee			ld (debug_mark+2),a  
3bee 18 03			jr .pastdmark  
3bf0 ..			.dmark: db "RN1"  
3bf3 f1			.pastdmark: pop af  
3bf4			endm  
# End of macro DMARK
3bf4						CALLMONITOR 
3bf4 cd 6f ee			call debug_vector  
3bf7				endm  
# End of macro CALLMONITOR
3bf7					endif 
3bf7					FORTH_DSP_POP 
3bf7 cd 19 21			call macro_forth_dsp_pop 
3bfa				endm 
# End of macro FORTH_DSP_POP
3bfa			 
3bfa					FORTH_DSP_VALUEHL    ; low range 
3bfa cd 61 20			call macro_dsp_valuehl 
3bfd				endm 
# End of macro FORTH_DSP_VALUEHL
3bfd			 
3bfd					if DEBUG_FORTH_WORDS 
3bfd						DMARK "RN2" 
3bfd f5				push af  
3bfe 3a 12 3c			ld a, (.dmark)  
3c01 32 6b ee			ld (debug_mark),a  
3c04 3a 13 3c			ld a, (.dmark+1)  
3c07 32 6c ee			ld (debug_mark+1),a  
3c0a 3a 14 3c			ld a, (.dmark+2)  
3c0d 32 6d ee			ld (debug_mark+2),a  
3c10 18 03			jr .pastdmark  
3c12 ..			.dmark: db "RN2"  
3c15 f1			.pastdmark: pop af  
3c16			endm  
# End of macro DMARK
3c16						CALLMONITOR 
3c16 cd 6f ee			call debug_vector  
3c19				endm  
# End of macro CALLMONITOR
3c19					endif 
3c19 22 af eb				ld (LFSRSeed+2), hl 
3c1c			 
3c1c					FORTH_DSP_POP 
3c1c cd 19 21			call macro_forth_dsp_pop 
3c1f				endm 
# End of macro FORTH_DSP_POP
3c1f			 
3c1f e5					push hl 
3c20			 
3c20 e1			.inrange:	pop hl 
3c21 cd 0d 0d				call prng16  
3c24					if DEBUG_FORTH_WORDS 
3c24						DMARK "RN3" 
3c24 f5				push af  
3c25 3a 39 3c			ld a, (.dmark)  
3c28 32 6b ee			ld (debug_mark),a  
3c2b 3a 3a 3c			ld a, (.dmark+1)  
3c2e 32 6c ee			ld (debug_mark+1),a  
3c31 3a 3b 3c			ld a, (.dmark+2)  
3c34 32 6d ee			ld (debug_mark+2),a  
3c37 18 03			jr .pastdmark  
3c39 ..			.dmark: db "RN3"  
3c3c f1			.pastdmark: pop af  
3c3d			endm  
# End of macro DMARK
3c3d						CALLMONITOR 
3c3d cd 6f ee			call debug_vector  
3c40				endm  
# End of macro CALLMONITOR
3c40					endif 
3c40					 
3c40					; if the range is 8bit knock out the high byte 
3c40			 
3c40 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
3c44			 
3c44 3e 00				ld a, 0 
3c46 ba					cp d  
3c47 20 1e				jr nz, .hirange 
3c49 26 00				ld h, 0   ; knock it down to 8bit 
3c4b			 
3c4b					if DEBUG_FORTH_WORDS 
3c4b						DMARK "RNk" 
3c4b f5				push af  
3c4c 3a 60 3c			ld a, (.dmark)  
3c4f 32 6b ee			ld (debug_mark),a  
3c52 3a 61 3c			ld a, (.dmark+1)  
3c55 32 6c ee			ld (debug_mark+1),a  
3c58 3a 62 3c			ld a, (.dmark+2)  
3c5b 32 6d ee			ld (debug_mark+2),a  
3c5e 18 03			jr .pastdmark  
3c60 ..			.dmark: db "RNk"  
3c63 f1			.pastdmark: pop af  
3c64			endm  
# End of macro DMARK
3c64						CALLMONITOR 
3c64 cd 6f ee			call debug_vector  
3c67				endm  
# End of macro CALLMONITOR
3c67					endif 
3c67			.hirange:   
3c67 e5					push hl  
3c68 b7					or a  
3c69 ed 52		                sbc hl, de 
3c6b			 
3c6b					;call cmp16 
3c6b			 
3c6b 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3c6d e1					pop hl 
3c6e e5					push hl 
3c6f			 
3c6f					if DEBUG_FORTH_WORDS 
3c6f						DMARK "RN4" 
3c6f f5				push af  
3c70 3a 84 3c			ld a, (.dmark)  
3c73 32 6b ee			ld (debug_mark),a  
3c76 3a 85 3c			ld a, (.dmark+1)  
3c79 32 6c ee			ld (debug_mark+1),a  
3c7c 3a 86 3c			ld a, (.dmark+2)  
3c7f 32 6d ee			ld (debug_mark+2),a  
3c82 18 03			jr .pastdmark  
3c84 ..			.dmark: db "RN4"  
3c87 f1			.pastdmark: pop af  
3c88			endm  
# End of macro DMARK
3c88						CALLMONITOR 
3c88 cd 6f ee			call debug_vector  
3c8b				endm  
# End of macro CALLMONITOR
3c8b					endif 
3c8b ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
3c8f					;call cmp16 
3c8f				 
3c8f b7					or a  
3c90 ed 52		                sbc hl, de 
3c92 38 8c				jr c, .inrange 
3c94			 
3c94 e1					pop hl 
3c95					 
3c95					if DEBUG_FORTH_WORDS 
3c95						DMARK "RNd" 
3c95 f5				push af  
3c96 3a aa 3c			ld a, (.dmark)  
3c99 32 6b ee			ld (debug_mark),a  
3c9c 3a ab 3c			ld a, (.dmark+1)  
3c9f 32 6c ee			ld (debug_mark+1),a  
3ca2 3a ac 3c			ld a, (.dmark+2)  
3ca5 32 6d ee			ld (debug_mark+2),a  
3ca8 18 03			jr .pastdmark  
3caa ..			.dmark: db "RNd"  
3cad f1			.pastdmark: pop af  
3cae			endm  
# End of macro DMARK
3cae						CALLMONITOR 
3cae cd 6f ee			call debug_vector  
3cb1				endm  
# End of macro CALLMONITOR
3cb1					endif 
3cb1			 
3cb1			 
3cb1 cd 6a 1e				call forth_push_numhl 
3cb4				       NEXTW 
3cb4 c3 17 22			jp macro_next 
3cb7				endm 
# End of macro NEXTW
3cb7			 
3cb7			.ENDMATHS: 
3cb7			 
3cb7			; eof 
3cb7			 
# End of file forth_words_maths.asm
3cb7			include "forth_words_display.asm" 
3cb7			 
3cb7			; | ## Display Words 
3cb7			 
3cb7			.ACT: 
3cb7			 
3cb7				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3cb7 62				db WORD_SYS_CORE+78             
3cb8 03 3d			dw .INFO            
3cba 07				db 6 + 1 
3cbb .. 00			db "ACTIVE",0              
3cc2				endm 
# End of macro CWHEAD
3cc2			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3cc2			;  
3cc2			; | | To display a pulsing activity indicator in a processing loop do this... 
3cc2			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3cc2			 
3cc2					if DEBUG_FORTH_WORDS_KEY 
3cc2						DMARK "ACT" 
3cc2 f5				push af  
3cc3 3a d7 3c			ld a, (.dmark)  
3cc6 32 6b ee			ld (debug_mark),a  
3cc9 3a d8 3c			ld a, (.dmark+1)  
3ccc 32 6c ee			ld (debug_mark+1),a  
3ccf 3a d9 3c			ld a, (.dmark+2)  
3cd2 32 6d ee			ld (debug_mark+2),a  
3cd5 18 03			jr .pastdmark  
3cd7 ..			.dmark: db "ACT"  
3cda f1			.pastdmark: pop af  
3cdb			endm  
# End of macro DMARK
3cdb						CALLMONITOR 
3cdb cd 6f ee			call debug_vector  
3cde				endm  
# End of macro CALLMONITOR
3cde					endif 
3cde cd 10 0b				call active 
3ce1					if DEBUG_FORTH_WORDS 
3ce1						DMARK "ACp" 
3ce1 f5				push af  
3ce2 3a f6 3c			ld a, (.dmark)  
3ce5 32 6b ee			ld (debug_mark),a  
3ce8 3a f7 3c			ld a, (.dmark+1)  
3ceb 32 6c ee			ld (debug_mark+1),a  
3cee 3a f8 3c			ld a, (.dmark+2)  
3cf1 32 6d ee			ld (debug_mark+2),a  
3cf4 18 03			jr .pastdmark  
3cf6 ..			.dmark: db "ACp"  
3cf9 f1			.pastdmark: pop af  
3cfa			endm  
# End of macro DMARK
3cfa						CALLMONITOR 
3cfa cd 6f ee			call debug_vector  
3cfd				endm  
# End of macro CALLMONITOR
3cfd					endif 
3cfd cd d8 1e				call forth_push_str 
3d00			 
3d00					NEXTW 
3d00 c3 17 22			jp macro_next 
3d03				endm 
# End of macro NEXTW
3d03			.INFO: 
3d03			 
3d03				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3d03 62				db WORD_SYS_CORE+78             
3d04 20 3d			dw .ATP            
3d06 05				db 4 + 1 
3d07 .. 00			db "INFO",0              
3d0c				endm 
# End of macro CWHEAD
3d0c			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3d0c					FORTH_DSP_VALUEHL 
3d0c cd 61 20			call macro_dsp_valuehl 
3d0f				endm 
# End of macro FORTH_DSP_VALUEHL
3d0f			 
3d0f					FORTH_DSP_POP 
3d0f cd 19 21			call macro_forth_dsp_pop 
3d12				endm 
# End of macro FORTH_DSP_POP
3d12			 
3d12 e5					push hl 
3d13			 
3d13					FORTH_DSP_VALUEHL 
3d13 cd 61 20			call macro_dsp_valuehl 
3d16				endm 
# End of macro FORTH_DSP_VALUEHL
3d16			 
3d16					FORTH_DSP_POP 
3d16 cd 19 21			call macro_forth_dsp_pop 
3d19				endm 
# End of macro FORTH_DSP_POP
3d19			 
3d19 d1					pop de 
3d1a			 
3d1a cd 4a 0b				call info_panel 
3d1d			 
3d1d			 
3d1d					NEXTW 
3d1d c3 17 22			jp macro_next 
3d20				endm 
# End of macro NEXTW
3d20			.ATP: 
3d20				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3d20 62				db WORD_SYS_CORE+78             
3d21 97 3d			dw .FB            
3d23 04				db 3 + 1 
3d24 .. 00			db "AT?",0              
3d28				endm 
# End of macro CWHEAD
3d28			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3d28					if DEBUG_FORTH_WORDS_KEY 
3d28						DMARK "AT?" 
3d28 f5				push af  
3d29 3a 3d 3d			ld a, (.dmark)  
3d2c 32 6b ee			ld (debug_mark),a  
3d2f 3a 3e 3d			ld a, (.dmark+1)  
3d32 32 6c ee			ld (debug_mark+1),a  
3d35 3a 3f 3d			ld a, (.dmark+2)  
3d38 32 6d ee			ld (debug_mark+2),a  
3d3b 18 03			jr .pastdmark  
3d3d ..			.dmark: db "AT?"  
3d40 f1			.pastdmark: pop af  
3d41			endm  
# End of macro DMARK
3d41						CALLMONITOR 
3d41 cd 6f ee			call debug_vector  
3d44				endm  
# End of macro CALLMONITOR
3d44					endif 
3d44 3a 5e ea				ld a, (f_cursor_ptr) 
3d47			 
3d47			if DEBUG_FORTH_WORDS 
3d47				DMARK "AT?" 
3d47 f5				push af  
3d48 3a 5c 3d			ld a, (.dmark)  
3d4b 32 6b ee			ld (debug_mark),a  
3d4e 3a 5d 3d			ld a, (.dmark+1)  
3d51 32 6c ee			ld (debug_mark+1),a  
3d54 3a 5e 3d			ld a, (.dmark+2)  
3d57 32 6d ee			ld (debug_mark+2),a  
3d5a 18 03			jr .pastdmark  
3d5c ..			.dmark: db "AT?"  
3d5f f1			.pastdmark: pop af  
3d60			endm  
# End of macro DMARK
3d60				CALLMONITOR 
3d60 cd 6f ee			call debug_vector  
3d63				endm  
# End of macro CALLMONITOR
3d63			endif	 
3d63					; count the number of rows 
3d63			 
3d63 06 00				ld b, 0 
3d65 4f			.atpr:		ld c, a    ; save in case we go below zero 
3d66 d6 28				sub display_cols 
3d68 f2 6e 3d				jp p, .atprunder 
3d6b 04					inc b 
3d6c 18 f7				jr .atpr 
3d6e			.atprunder:	 
3d6e			if DEBUG_FORTH_WORDS 
3d6e				DMARK "A?2" 
3d6e f5				push af  
3d6f 3a 83 3d			ld a, (.dmark)  
3d72 32 6b ee			ld (debug_mark),a  
3d75 3a 84 3d			ld a, (.dmark+1)  
3d78 32 6c ee			ld (debug_mark+1),a  
3d7b 3a 85 3d			ld a, (.dmark+2)  
3d7e 32 6d ee			ld (debug_mark+2),a  
3d81 18 03			jr .pastdmark  
3d83 ..			.dmark: db "A?2"  
3d86 f1			.pastdmark: pop af  
3d87			endm  
# End of macro DMARK
3d87				CALLMONITOR 
3d87 cd 6f ee			call debug_vector  
3d8a				endm  
# End of macro CALLMONITOR
3d8a			endif	 
3d8a 26 00				ld h, 0 
3d8c 69					ld l, c 
3d8d cd 6a 1e				call forth_push_numhl 
3d90 68					ld l, b  
3d91 cd 6a 1e				call forth_push_numhl 
3d94			 
3d94			 
3d94				NEXTW 
3d94 c3 17 22			jp macro_next 
3d97				endm 
# End of macro NEXTW
3d97			 
3d97			.FB: 
3d97				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3d97 1b				db WORD_SYS_CORE+7             
3d98 e5 3d			dw .EMIT            
3d9a 03				db 2 + 1 
3d9b .. 00			db "FB",0              
3d9e				endm 
# End of macro CWHEAD
3d9e			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3d9e			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3d9e			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3d9e			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3d9e					if DEBUG_FORTH_WORDS_KEY 
3d9e						DMARK "FB." 
3d9e f5				push af  
3d9f 3a b3 3d			ld a, (.dmark)  
3da2 32 6b ee			ld (debug_mark),a  
3da5 3a b4 3d			ld a, (.dmark+1)  
3da8 32 6c ee			ld (debug_mark+1),a  
3dab 3a b5 3d			ld a, (.dmark+2)  
3dae 32 6d ee			ld (debug_mark+2),a  
3db1 18 03			jr .pastdmark  
3db3 ..			.dmark: db "FB."  
3db6 f1			.pastdmark: pop af  
3db7			endm  
# End of macro DMARK
3db7						CALLMONITOR 
3db7 cd 6f ee			call debug_vector  
3dba				endm  
# End of macro CALLMONITOR
3dba					endif 
3dba			 
3dba					FORTH_DSP_VALUEHL 
3dba cd 61 20			call macro_dsp_valuehl 
3dbd				endm 
# End of macro FORTH_DSP_VALUEHL
3dbd			 
3dbd 7d					ld a, l 
3dbe fe 01				cp 1 
3dc0 20 05				jr nz, .fbn1 
3dc2 21 10 ed				ld hl, display_fb1 
3dc5 18 15				jr .fbset 
3dc7 fe 02		.fbn1:		cp 2 
3dc9 20 05				jr nz, .fbn2 
3dcb 21 ce eb				ld hl, display_fb2 
3dce 18 0c				jr .fbset 
3dd0 fe 03		.fbn2:		cp 3 
3dd2 20 05				jr nz, .fbn3 
3dd4 21 6f ec				ld hl, display_fb3 
3dd7 18 03				jr .fbset 
3dd9			.fbn3:		 ; if invalid number select first 
3dd9 21 10 ed				ld hl, display_fb1 
3ddc 22 cc eb		.fbset:		ld (display_fb_active), hl 
3ddf			 
3ddf					FORTH_DSP_POP 
3ddf cd 19 21			call macro_forth_dsp_pop 
3de2				endm 
# End of macro FORTH_DSP_POP
3de2			 
3de2					NEXTW 
3de2 c3 17 22			jp macro_next 
3de5				endm 
# End of macro NEXTW
3de5			 
3de5			 
3de5			.EMIT: 
3de5				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3de5 1b				db WORD_SYS_CORE+7             
3de6 36 3e			dw .DOTH            
3de8 05				db 4 + 1 
3de9 .. 00			db "EMIT",0              
3dee				endm 
# End of macro CWHEAD
3dee			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3dee					; get value off TOS and display it 
3dee			 
3dee					if DEBUG_FORTH_WORDS_KEY 
3dee						DMARK "EMT" 
3dee f5				push af  
3def 3a 03 3e			ld a, (.dmark)  
3df2 32 6b ee			ld (debug_mark),a  
3df5 3a 04 3e			ld a, (.dmark+1)  
3df8 32 6c ee			ld (debug_mark+1),a  
3dfb 3a 05 3e			ld a, (.dmark+2)  
3dfe 32 6d ee			ld (debug_mark+2),a  
3e01 18 03			jr .pastdmark  
3e03 ..			.dmark: db "EMT"  
3e06 f1			.pastdmark: pop af  
3e07			endm  
# End of macro DMARK
3e07						CALLMONITOR 
3e07 cd 6f ee			call debug_vector  
3e0a				endm  
# End of macro CALLMONITOR
3e0a					endif 
3e0a			 
3e0a					FORTH_DSP_VALUEHL 
3e0a cd 61 20			call macro_dsp_valuehl 
3e0d				endm 
# End of macro FORTH_DSP_VALUEHL
3e0d			 
3e0d 7d					ld a,l 
3e0e			 
3e0e					; TODO write to display 
3e0e			 
3e0e 32 bf e4				ld (os_input), a 
3e11 3e 00				ld a, 0 
3e13 32 c0 e4				ld (os_input+1), a 
3e16					 
3e16 3a 5e ea				ld a, (f_cursor_ptr) 
3e19 11 bf e4				ld de, os_input 
3e1c cd cc 0b				call str_at_display 
3e1f			 
3e1f			 
3e1f 3a 3c ea				ld a,(cli_autodisplay) 
3e22 fe 00				cp 0 
3e24 28 03				jr z, .enoupdate 
3e26 cd dc 0b						call update_display 
3e29					.enoupdate: 
3e29			 
3e29 3a 5e ea				ld a, (f_cursor_ptr) 
3e2c 3c					inc a 
3e2d 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3e30			 
3e30			 
3e30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e30 cd 19 21			call macro_forth_dsp_pop 
3e33				endm 
# End of macro FORTH_DSP_POP
3e33			  
3e33			 
3e33					NEXTW 
3e33 c3 17 22			jp macro_next 
3e36				endm 
# End of macro NEXTW
3e36			.DOTH: 
3e36				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3e36 1c				db WORD_SYS_CORE+8             
3e37 66 3e			dw .DOTF            
3e39 03				db 2 + 1 
3e3a .. 00			db ".-",0              
3e3d				endm 
# End of macro CWHEAD
3e3d			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3e3d					; get value off TOS and display it 
3e3d					if DEBUG_FORTH_WORDS_KEY 
3e3d						DMARK "DTD" 
3e3d f5				push af  
3e3e 3a 52 3e			ld a, (.dmark)  
3e41 32 6b ee			ld (debug_mark),a  
3e44 3a 53 3e			ld a, (.dmark+1)  
3e47 32 6c ee			ld (debug_mark+1),a  
3e4a 3a 54 3e			ld a, (.dmark+2)  
3e4d 32 6d ee			ld (debug_mark+2),a  
3e50 18 03			jr .pastdmark  
3e52 ..			.dmark: db "DTD"  
3e55 f1			.pastdmark: pop af  
3e56			endm  
# End of macro DMARK
3e56						CALLMONITOR 
3e56 cd 6f ee			call debug_vector  
3e59				endm  
# End of macro CALLMONITOR
3e59					endif 
3e59 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3e5b 3e 00			ld a, 0 
3e5d 32 3d ea			ld (cli_mvdot), a 
3e60 c3 bd 3e			jp .dotgo 
3e63				NEXTW 
3e63 c3 17 22			jp macro_next 
3e66				endm 
# End of macro NEXTW
3e66			.DOTF: 
3e66				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3e66 1c				db WORD_SYS_CORE+8             
3e67 94 3e			dw .DOT            
3e69 03				db 2 + 1 
3e6a .. 00			db ".>",0              
3e6d				endm 
# End of macro CWHEAD
3e6d			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3e6d					; get value off TOS and display it 
3e6d			        ; TODO BUG adds extra spaces 
3e6d			        ; TODO BUG handle numerics? 
3e6d					if DEBUG_FORTH_WORDS_KEY 
3e6d						DMARK "DTC" 
3e6d f5				push af  
3e6e 3a 82 3e			ld a, (.dmark)  
3e71 32 6b ee			ld (debug_mark),a  
3e74 3a 83 3e			ld a, (.dmark+1)  
3e77 32 6c ee			ld (debug_mark+1),a  
3e7a 3a 84 3e			ld a, (.dmark+2)  
3e7d 32 6d ee			ld (debug_mark+2),a  
3e80 18 03			jr .pastdmark  
3e82 ..			.dmark: db "DTC"  
3e85 f1			.pastdmark: pop af  
3e86			endm  
# End of macro DMARK
3e86						CALLMONITOR 
3e86 cd 6f ee			call debug_vector  
3e89				endm  
# End of macro CALLMONITOR
3e89					endif 
3e89 3e 01			ld a, 1 
3e8b 32 3d ea			ld (cli_mvdot), a 
3e8e c3 bd 3e			jp .dotgo 
3e91				NEXTW 
3e91 c3 17 22			jp macro_next 
3e94				endm 
# End of macro NEXTW
3e94			 
3e94			.DOT: 
3e94				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3e94 1c				db WORD_SYS_CORE+8             
3e95 70 40			dw .CLS            
3e97 02				db 1 + 1 
3e98 .. 00			db ".",0              
3e9a				endm 
# End of macro CWHEAD
3e9a			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3e9a					; get value off TOS and display it 
3e9a			 
3e9a					if DEBUG_FORTH_WORDS_KEY 
3e9a						DMARK "DOT" 
3e9a f5				push af  
3e9b 3a af 3e			ld a, (.dmark)  
3e9e 32 6b ee			ld (debug_mark),a  
3ea1 3a b0 3e			ld a, (.dmark+1)  
3ea4 32 6c ee			ld (debug_mark+1),a  
3ea7 3a b1 3e			ld a, (.dmark+2)  
3eaa 32 6d ee			ld (debug_mark+2),a  
3ead 18 03			jr .pastdmark  
3eaf ..			.dmark: db "DOT"  
3eb2 f1			.pastdmark: pop af  
3eb3			endm  
# End of macro DMARK
3eb3						CALLMONITOR 
3eb3 cd 6f ee			call debug_vector  
3eb6				endm  
# End of macro CALLMONITOR
3eb6					endif 
3eb6 3e 00			ld a, 0 
3eb8 32 3d ea			ld (cli_mvdot), a 
3ebb 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3ebd				 
3ebd			 
3ebd			.dotgo: 
3ebd			 
3ebd			; move up type to on stack for parserv5 
3ebd					FORTH_DSP 
3ebd cd 27 20			call macro_forth_dsp 
3ec0				endm 
# End of macro FORTH_DSP
3ec0				;FORTH_DSP_VALUE  
3ec0			 
3ec0			if DEBUG_FORTH_DOT 
3ec0				DMARK "DOT" 
3ec0 f5				push af  
3ec1 3a d5 3e			ld a, (.dmark)  
3ec4 32 6b ee			ld (debug_mark),a  
3ec7 3a d6 3e			ld a, (.dmark+1)  
3eca 32 6c ee			ld (debug_mark+1),a  
3ecd 3a d7 3e			ld a, (.dmark+2)  
3ed0 32 6d ee			ld (debug_mark+2),a  
3ed3 18 03			jr .pastdmark  
3ed5 ..			.dmark: db "DOT"  
3ed8 f1			.pastdmark: pop af  
3ed9			endm  
# End of macro DMARK
3ed9				CALLMONITOR 
3ed9 cd 6f ee			call debug_vector  
3edc				endm  
# End of macro CALLMONITOR
3edc			endif	 
3edc			;		.print: 
3edc			 
3edc 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3edd 23				inc hl   ; position to the actual value 
3ede fe 01			cp DS_TYPE_STR 
3ee0 20 06			jr nz, .dotnum1  
3ee2			 
3ee2			; display string 
3ee2				FORTH_DSP_VALUE  
3ee2 cd 4a 20			call macro_forth_dsp_value 
3ee5				endm 
# End of macro FORTH_DSP_VALUE
3ee5 eb				ex de,hl 
3ee6 18 49			jr .dotwrite 
3ee8			 
3ee8			.dotnum1: 
3ee8 fe 02			cp DS_TYPE_INUM 
3eea 20 44			jr nz, .dotflot 
3eec			 
3eec			 
3eec			; display number 
3eec			 
3eec			;	push hl 
3eec			;	call clear_display 
3eec			;	pop hl 
3eec			 
3eec 5e				ld e, (hl) 
3eed 23				inc hl 
3eee 56				ld d, (hl) 
3eef 21 c1 e2			ld hl, scratch 
3ef2			if DEBUG_FORTH_DOT 
3ef2				DMARK "DT1" 
3ef2 f5				push af  
3ef3 3a 07 3f			ld a, (.dmark)  
3ef6 32 6b ee			ld (debug_mark),a  
3ef9 3a 08 3f			ld a, (.dmark+1)  
3efc 32 6c ee			ld (debug_mark+1),a  
3eff 3a 09 3f			ld a, (.dmark+2)  
3f02 32 6d ee			ld (debug_mark+2),a  
3f05 18 03			jr .pastdmark  
3f07 ..			.dmark: db "DT1"  
3f0a f1			.pastdmark: pop af  
3f0b			endm  
# End of macro DMARK
3f0b				CALLMONITOR 
3f0b cd 6f ee			call debug_vector  
3f0e				endm  
# End of macro CALLMONITOR
3f0e			endif	 
3f0e			 
3f0e cd 0b 14			call uitoa_16 
3f11 eb				ex de,hl 
3f12			 
3f12			if DEBUG_FORTH_DOT 
3f12				DMARK "DT2" 
3f12 f5				push af  
3f13 3a 27 3f			ld a, (.dmark)  
3f16 32 6b ee			ld (debug_mark),a  
3f19 3a 28 3f			ld a, (.dmark+1)  
3f1c 32 6c ee			ld (debug_mark+1),a  
3f1f 3a 29 3f			ld a, (.dmark+2)  
3f22 32 6d ee			ld (debug_mark+2),a  
3f25 18 03			jr .pastdmark  
3f27 ..			.dmark: db "DT2"  
3f2a f1			.pastdmark: pop af  
3f2b			endm  
# End of macro DMARK
3f2b				CALLMONITOR 
3f2b cd 6f ee			call debug_vector  
3f2e				endm  
# End of macro CALLMONITOR
3f2e			endif	 
3f2e			 
3f2e			;	ld de, os_word_scratch 
3f2e 18 01			jr .dotwrite 
3f30			 
3f30 00			.dotflot:   nop 
3f31			; TODO print floating point number 
3f31			 
3f31			.dotwrite:		 
3f31			 
3f31					; if c is set then set all '-' to spaces 
3f31					; need to also take into account .>  
3f31			 
3f31 3e 01				ld a, 1 
3f33 b9					cp c 
3f34 20 67				jr nz, .nodashswap 
3f36			 
3f36					; DE has the string to write, working with HL 
3f36			 
3f36 06 ff				ld b, 255 
3f38 d5					push de 
3f39 e1					pop hl 
3f3a			 
3f3a			if DEBUG_FORTH_DOT 
3f3a				DMARK "DT-" 
3f3a f5				push af  
3f3b 3a 4f 3f			ld a, (.dmark)  
3f3e 32 6b ee			ld (debug_mark),a  
3f41 3a 50 3f			ld a, (.dmark+1)  
3f44 32 6c ee			ld (debug_mark+1),a  
3f47 3a 51 3f			ld a, (.dmark+2)  
3f4a 32 6d ee			ld (debug_mark+2),a  
3f4d 18 03			jr .pastdmark  
3f4f ..			.dmark: db "DT-"  
3f52 f1			.pastdmark: pop af  
3f53			endm  
# End of macro DMARK
3f53				CALLMONITOR 
3f53 cd 6f ee			call debug_vector  
3f56				endm  
# End of macro CALLMONITOR
3f56			endif	 
3f56 7e			.dashscan:	ld a, (hl) 
3f57 fe 00				cp 0 
3f59 28 42				jr z, .nodashswap 
3f5b fe 2d				cp '-' 
3f5d 20 03				jr nz, .dashskip 
3f5f 3e 20				ld a, ' ' 
3f61 77					ld (hl), a 
3f62 23			.dashskip:	inc hl 
3f63			if DEBUG_FORTH_DOT 
3f63				DMARK "D-2" 
3f63 f5				push af  
3f64 3a 78 3f			ld a, (.dmark)  
3f67 32 6b ee			ld (debug_mark),a  
3f6a 3a 79 3f			ld a, (.dmark+1)  
3f6d 32 6c ee			ld (debug_mark+1),a  
3f70 3a 7a 3f			ld a, (.dmark+2)  
3f73 32 6d ee			ld (debug_mark+2),a  
3f76 18 03			jr .pastdmark  
3f78 ..			.dmark: db "D-2"  
3f7b f1			.pastdmark: pop af  
3f7c			endm  
# End of macro DMARK
3f7c				CALLMONITOR 
3f7c cd 6f ee			call debug_vector  
3f7f				endm  
# End of macro CALLMONITOR
3f7f			endif	 
3f7f 10 d5				djnz .dashscan 
3f81			 
3f81			if DEBUG_FORTH_DOT 
3f81				DMARK "D-1" 
3f81 f5				push af  
3f82 3a 96 3f			ld a, (.dmark)  
3f85 32 6b ee			ld (debug_mark),a  
3f88 3a 97 3f			ld a, (.dmark+1)  
3f8b 32 6c ee			ld (debug_mark+1),a  
3f8e 3a 98 3f			ld a, (.dmark+2)  
3f91 32 6d ee			ld (debug_mark+2),a  
3f94 18 03			jr .pastdmark  
3f96 ..			.dmark: db "D-1"  
3f99 f1			.pastdmark: pop af  
3f9a			endm  
# End of macro DMARK
3f9a				CALLMONITOR 
3f9a cd 6f ee			call debug_vector  
3f9d				endm  
# End of macro CALLMONITOR
3f9d			endif	 
3f9d			 
3f9d			.nodashswap: 
3f9d			 
3f9d			if DEBUG_FORTH_DOT 
3f9d				DMARK "D-o" 
3f9d f5				push af  
3f9e 3a b2 3f			ld a, (.dmark)  
3fa1 32 6b ee			ld (debug_mark),a  
3fa4 3a b3 3f			ld a, (.dmark+1)  
3fa7 32 6c ee			ld (debug_mark+1),a  
3faa 3a b4 3f			ld a, (.dmark+2)  
3fad 32 6d ee			ld (debug_mark+2),a  
3fb0 18 03			jr .pastdmark  
3fb2 ..			.dmark: db "D-o"  
3fb5 f1			.pastdmark: pop af  
3fb6			endm  
# End of macro DMARK
3fb6				CALLMONITOR 
3fb6 cd 6f ee			call debug_vector  
3fb9				endm  
# End of macro CALLMONITOR
3fb9			endif	 
3fb9			 
3fb9 d5					push de   ; save string start in case we need to advance print 
3fba			 
3fba 3a 5e ea				ld a, (f_cursor_ptr) 
3fbd cd cc 0b				call str_at_display 
3fc0 3a 3c ea				ld a,(cli_autodisplay) 
3fc3 fe 00				cp 0 
3fc5 28 03				jr z, .noupdate 
3fc7 cd dc 0b						call update_display 
3fca					.noupdate: 
3fca			 
3fca			 
3fca					; see if we need to advance the print position 
3fca			 
3fca e1					pop hl   ; get back string 
3fcb			;		ex de,hl 
3fcb			 
3fcb 3a 3d ea				ld a, (cli_mvdot) 
3fce			if DEBUG_FORTH_DOT 
3fce			;		ld e,a 
3fce				DMARK "D>1" 
3fce f5				push af  
3fcf 3a e3 3f			ld a, (.dmark)  
3fd2 32 6b ee			ld (debug_mark),a  
3fd5 3a e4 3f			ld a, (.dmark+1)  
3fd8 32 6c ee			ld (debug_mark+1),a  
3fdb 3a e5 3f			ld a, (.dmark+2)  
3fde 32 6d ee			ld (debug_mark+2),a  
3fe1 18 03			jr .pastdmark  
3fe3 ..			.dmark: db "D>1"  
3fe6 f1			.pastdmark: pop af  
3fe7			endm  
# End of macro DMARK
3fe7				CALLMONITOR 
3fe7 cd 6f ee			call debug_vector  
3fea				endm  
# End of macro CALLMONITOR
3fea			endif	 
3fea fe 00				cp 0 
3fec 28 44				jr z, .noadv 
3fee					; yes, lets advance the print position 
3fee 3e 00				ld a, 0 
3ff0 cd 67 14				call strlent 
3ff3			if DEBUG_FORTH_DOT 
3ff3				DMARK "D-?" 
3ff3 f5				push af  
3ff4 3a 08 40			ld a, (.dmark)  
3ff7 32 6b ee			ld (debug_mark),a  
3ffa 3a 09 40			ld a, (.dmark+1)  
3ffd 32 6c ee			ld (debug_mark+1),a  
4000 3a 0a 40			ld a, (.dmark+2)  
4003 32 6d ee			ld (debug_mark+2),a  
4006 18 03			jr .pastdmark  
4008 ..			.dmark: db "D-?"  
400b f1			.pastdmark: pop af  
400c			endm  
# End of macro DMARK
400c				CALLMONITOR 
400c cd 6f ee			call debug_vector  
400f				endm  
# End of macro CALLMONITOR
400f			endif	 
400f 3a 5e ea				ld a, (f_cursor_ptr) 
4012 85					add a,l 
4013					;call addatohl 
4013					;ld a, l 
4013 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
4016			 
4016			if DEBUG_FORTH_DOT 
4016				DMARK "D->" 
4016 f5				push af  
4017 3a 2b 40			ld a, (.dmark)  
401a 32 6b ee			ld (debug_mark),a  
401d 3a 2c 40			ld a, (.dmark+1)  
4020 32 6c ee			ld (debug_mark+1),a  
4023 3a 2d 40			ld a, (.dmark+2)  
4026 32 6d ee			ld (debug_mark+2),a  
4029 18 03			jr .pastdmark  
402b ..			.dmark: db "D->"  
402e f1			.pastdmark: pop af  
402f			endm  
# End of macro DMARK
402f				CALLMONITOR 
402f cd 6f ee			call debug_vector  
4032				endm  
# End of macro CALLMONITOR
4032			endif	 
4032			 
4032			.noadv:	 
4032			 
4032					if DEBUG_FORTH_DOT_WAIT 
4032							call next_page_prompt 
4032					endif	 
4032			; TODO this pop off the stack causes a crash. i dont know why 
4032			 
4032			 
4032			if DEBUG_FORTH_DOT 
4032				DMARK "DTh" 
4032 f5				push af  
4033 3a 47 40			ld a, (.dmark)  
4036 32 6b ee			ld (debug_mark),a  
4039 3a 48 40			ld a, (.dmark+1)  
403c 32 6c ee			ld (debug_mark+1),a  
403f 3a 49 40			ld a, (.dmark+2)  
4042 32 6d ee			ld (debug_mark+2),a  
4045 18 03			jr .pastdmark  
4047 ..			.dmark: db "DTh"  
404a f1			.pastdmark: pop af  
404b			endm  
# End of macro DMARK
404b				CALLMONITOR 
404b cd 6f ee			call debug_vector  
404e				endm  
# End of macro CALLMONITOR
404e			endif	 
404e			 
404e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
404e cd 19 21			call macro_forth_dsp_pop 
4051				endm 
# End of macro FORTH_DSP_POP
4051			 
4051			if DEBUG_FORTH_DOT 
4051				DMARK "DTi" 
4051 f5				push af  
4052 3a 66 40			ld a, (.dmark)  
4055 32 6b ee			ld (debug_mark),a  
4058 3a 67 40			ld a, (.dmark+1)  
405b 32 6c ee			ld (debug_mark+1),a  
405e 3a 68 40			ld a, (.dmark+2)  
4061 32 6d ee			ld (debug_mark+2),a  
4064 18 03			jr .pastdmark  
4066 ..			.dmark: db "DTi"  
4069 f1			.pastdmark: pop af  
406a			endm  
# End of macro DMARK
406a				CALLMONITOR 
406a cd 6f ee			call debug_vector  
406d				endm  
# End of macro CALLMONITOR
406d			endif	 
406d			 
406d			 
406d					NEXTW 
406d c3 17 22			jp macro_next 
4070				endm 
# End of macro NEXTW
4070			 
4070			.CLS: 
4070				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4070 35				db WORD_SYS_CORE+33             
4071 9d 40			dw .DRAW            
4073 04				db 3 + 1 
4074 .. 00			db "CLS",0              
4078				endm 
# End of macro CWHEAD
4078			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4078					if DEBUG_FORTH_WORDS_KEY 
4078						DMARK "CLS" 
4078 f5				push af  
4079 3a 8d 40			ld a, (.dmark)  
407c 32 6b ee			ld (debug_mark),a  
407f 3a 8e 40			ld a, (.dmark+1)  
4082 32 6c ee			ld (debug_mark+1),a  
4085 3a 8f 40			ld a, (.dmark+2)  
4088 32 6d ee			ld (debug_mark+2),a  
408b 18 03			jr .pastdmark  
408d ..			.dmark: db "CLS"  
4090 f1			.pastdmark: pop af  
4091			endm  
# End of macro DMARK
4091						CALLMONITOR 
4091 cd 6f ee			call debug_vector  
4094				endm  
# End of macro CALLMONITOR
4094					endif 
4094 cd b9 0b				call clear_display 
4097 c3 ab 41				jp .home		; and home cursor 
409a					NEXTW 
409a c3 17 22			jp macro_next 
409d				endm 
# End of macro NEXTW
409d			 
409d			.DRAW: 
409d				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
409d 36				db WORD_SYS_CORE+34             
409e c8 40			dw .DUMP            
40a0 05				db 4 + 1 
40a1 .. 00			db "DRAW",0              
40a6				endm 
# End of macro CWHEAD
40a6			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
40a6					if DEBUG_FORTH_WORDS_KEY 
40a6						DMARK "DRW" 
40a6 f5				push af  
40a7 3a bb 40			ld a, (.dmark)  
40aa 32 6b ee			ld (debug_mark),a  
40ad 3a bc 40			ld a, (.dmark+1)  
40b0 32 6c ee			ld (debug_mark+1),a  
40b3 3a bd 40			ld a, (.dmark+2)  
40b6 32 6d ee			ld (debug_mark+2),a  
40b9 18 03			jr .pastdmark  
40bb ..			.dmark: db "DRW"  
40be f1			.pastdmark: pop af  
40bf			endm  
# End of macro DMARK
40bf						CALLMONITOR 
40bf cd 6f ee			call debug_vector  
40c2				endm  
# End of macro CALLMONITOR
40c2					endif 
40c2 cd dc 0b				call update_display 
40c5					NEXTW 
40c5 c3 17 22			jp macro_next 
40c8				endm 
# End of macro NEXTW
40c8			 
40c8			.DUMP: 
40c8				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
40c8 37				db WORD_SYS_CORE+35             
40c9 00 41			dw .CDUMP            
40cb 05				db 4 + 1 
40cc .. 00			db "DUMP",0              
40d1				endm 
# End of macro CWHEAD
40d1			; | DUMP ( x -- ) With address x display dump   | DONE 
40d1			; TODO pop address to use off of the stack 
40d1					if DEBUG_FORTH_WORDS_KEY 
40d1						DMARK "DUM" 
40d1 f5				push af  
40d2 3a e6 40			ld a, (.dmark)  
40d5 32 6b ee			ld (debug_mark),a  
40d8 3a e7 40			ld a, (.dmark+1)  
40db 32 6c ee			ld (debug_mark+1),a  
40de 3a e8 40			ld a, (.dmark+2)  
40e1 32 6d ee			ld (debug_mark+2),a  
40e4 18 03			jr .pastdmark  
40e6 ..			.dmark: db "DUM"  
40e9 f1			.pastdmark: pop af  
40ea			endm  
# End of macro DMARK
40ea						CALLMONITOR 
40ea cd 6f ee			call debug_vector  
40ed				endm  
# End of macro CALLMONITOR
40ed					endif 
40ed cd b9 0b				call clear_display 
40f0			 
40f0					; get address 
40f0			 
40f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40f0 cd 61 20			call macro_dsp_valuehl 
40f3				endm 
# End of macro FORTH_DSP_VALUEHL
40f3				 
40f3					; save it for cdump 
40f3			 
40f3 22 e4 e5				ld (os_cur_ptr),hl 
40f6			 
40f6					; destroy value TOS 
40f6			 
40f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40f6 cd 19 21			call macro_forth_dsp_pop 
40f9				endm 
# End of macro FORTH_DSP_POP
40f9			 
40f9 cd ea 1c				call dumpcont	; skip old style of param parsing	 
40fc c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
40fd					NEXTW 
40fd c3 17 22			jp macro_next 
4100				endm 
# End of macro NEXTW
4100			.CDUMP: 
4100				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4100 38				db WORD_SYS_CORE+36             
4101 30 41			dw .DAT            
4103 06				db 5 + 1 
4104 .. 00			db "CDUMP",0              
410a				endm 
# End of macro CWHEAD
410a			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
410a					if DEBUG_FORTH_WORDS_KEY 
410a						DMARK "CDP" 
410a f5				push af  
410b 3a 1f 41			ld a, (.dmark)  
410e 32 6b ee			ld (debug_mark),a  
4111 3a 20 41			ld a, (.dmark+1)  
4114 32 6c ee			ld (debug_mark+1),a  
4117 3a 21 41			ld a, (.dmark+2)  
411a 32 6d ee			ld (debug_mark+2),a  
411d 18 03			jr .pastdmark  
411f ..			.dmark: db "CDP"  
4122 f1			.pastdmark: pop af  
4123			endm  
# End of macro DMARK
4123						CALLMONITOR 
4123 cd 6f ee			call debug_vector  
4126				endm  
# End of macro CALLMONITOR
4126					endif 
4126 cd b9 0b				call clear_display 
4129 cd ea 1c				call dumpcont	 
412c c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
412d					NEXTW 
412d c3 17 22			jp macro_next 
4130				endm 
# End of macro NEXTW
4130			 
4130			 
4130			 
4130			 
4130			.DAT: 
4130				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4130 3d				db WORD_SYS_CORE+41             
4131 86 41			dw .HOME            
4133 03				db 2 + 1 
4134 .. 00			db "AT",0              
4137				endm 
# End of macro CWHEAD
4137			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4137					if DEBUG_FORTH_WORDS_KEY 
4137						DMARK "AT." 
4137 f5				push af  
4138 3a 4c 41			ld a, (.dmark)  
413b 32 6b ee			ld (debug_mark),a  
413e 3a 4d 41			ld a, (.dmark+1)  
4141 32 6c ee			ld (debug_mark+1),a  
4144 3a 4e 41			ld a, (.dmark+2)  
4147 32 6d ee			ld (debug_mark+2),a  
414a 18 03			jr .pastdmark  
414c ..			.dmark: db "AT."  
414f f1			.pastdmark: pop af  
4150			endm  
# End of macro DMARK
4150						CALLMONITOR 
4150 cd 6f ee			call debug_vector  
4153				endm  
# End of macro CALLMONITOR
4153					endif 
4153					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4153 cd 61 20			call macro_dsp_valuehl 
4156				endm 
# End of macro FORTH_DSP_VALUEHL
4156			 
4156			 
4156					; TODO save cursor row 
4156 7d					ld a,l 
4157 fe 02				cp 2 
4159 20 04				jr nz, .crow3 
415b 3e 28				ld a, display_row_2 
415d 18 12				jr .ccol1 
415f fe 03		.crow3:		cp 3 
4161 20 04				jr nz, .crow4 
4163 3e 50				ld a, display_row_3 
4165 18 0a				jr .ccol1 
4167 fe 04		.crow4:		cp 4 
4169 20 04				jr nz, .crow1 
416b 3e 78				ld a, display_row_4 
416d 18 02				jr .ccol1 
416f 3e 00		.crow1:		ld a,display_row_1 
4171 f5			.ccol1:		push af			; got row offset 
4172 6f					ld l,a 
4173 26 00				ld h,0 
4175					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4175 cd 19 21			call macro_forth_dsp_pop 
4178				endm 
# End of macro FORTH_DSP_POP
4178					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4178 cd 61 20			call macro_dsp_valuehl 
417b				endm 
# End of macro FORTH_DSP_VALUEHL
417b					; TODO save cursor col 
417b f1					pop af 
417c 85					add l		; add col offset 
417d 32 5e ea				ld (f_cursor_ptr), a 
4180					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4180 cd 19 21			call macro_forth_dsp_pop 
4183				endm 
# End of macro FORTH_DSP_POP
4183			 
4183					; calculate  
4183			 
4183					NEXTW 
4183 c3 17 22			jp macro_next 
4186				endm 
# End of macro NEXTW
4186			 
4186			 
4186			.HOME: 
4186				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4186 41				db WORD_SYS_CORE+45             
4187 b3 41			dw .CR            
4189 05				db 4 + 1 
418a .. 00			db "HOME",0              
418f				endm 
# End of macro CWHEAD
418f			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
418f					if DEBUG_FORTH_WORDS_KEY 
418f						DMARK "HOM" 
418f f5				push af  
4190 3a a4 41			ld a, (.dmark)  
4193 32 6b ee			ld (debug_mark),a  
4196 3a a5 41			ld a, (.dmark+1)  
4199 32 6c ee			ld (debug_mark+1),a  
419c 3a a6 41			ld a, (.dmark+2)  
419f 32 6d ee			ld (debug_mark+2),a  
41a2 18 03			jr .pastdmark  
41a4 ..			.dmark: db "HOM"  
41a7 f1			.pastdmark: pop af  
41a8			endm  
# End of macro DMARK
41a8						CALLMONITOR 
41a8 cd 6f ee			call debug_vector  
41ab				endm  
# End of macro CALLMONITOR
41ab					endif 
41ab 3e 00		.home:		ld a, 0		; and home cursor 
41ad 32 5e ea				ld (f_cursor_ptr), a 
41b0					NEXTW 
41b0 c3 17 22			jp macro_next 
41b3				endm 
# End of macro NEXTW
41b3			 
41b3			 
41b3			.CR: 
41b3				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
41b3 46				db WORD_SYS_CORE+50             
41b4 ee 41			dw .SPACE            
41b6 03				db 2 + 1 
41b7 .. 00			db "CR",0              
41ba				endm 
# End of macro CWHEAD
41ba			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
41ba					if DEBUG_FORTH_WORDS_KEY 
41ba						DMARK "CR." 
41ba f5				push af  
41bb 3a cf 41			ld a, (.dmark)  
41be 32 6b ee			ld (debug_mark),a  
41c1 3a d0 41			ld a, (.dmark+1)  
41c4 32 6c ee			ld (debug_mark+1),a  
41c7 3a d1 41			ld a, (.dmark+2)  
41ca 32 6d ee			ld (debug_mark+2),a  
41cd 18 03			jr .pastdmark  
41cf ..			.dmark: db "CR."  
41d2 f1			.pastdmark: pop af  
41d3			endm  
# End of macro DMARK
41d3						CALLMONITOR 
41d3 cd 6f ee			call debug_vector  
41d6				endm  
# End of macro CALLMONITOR
41d6					endif 
41d6 3e 0d				ld a, 13 
41d8 32 c1 e2				ld (scratch),a 
41db 3e 0a				ld a, 10 
41dd 32 c2 e2				ld (scratch+1),a 
41e0 3e 00				ld a, 0 
41e2 32 c3 e2				ld (scratch+2),a 
41e5 21 c1 e2				ld hl, scratch 
41e8 cd d8 1e				call forth_push_str 
41eb					 
41eb				       NEXTW 
41eb c3 17 22			jp macro_next 
41ee				endm 
# End of macro NEXTW
41ee			.SPACE: 
41ee				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
41ee 46				db WORD_SYS_CORE+50             
41ef 24 42			dw .SPACES            
41f1 03				db 2 + 1 
41f2 .. 00			db "BL",0              
41f5				endm 
# End of macro CWHEAD
41f5			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
41f5					if DEBUG_FORTH_WORDS_KEY 
41f5						DMARK "BL." 
41f5 f5				push af  
41f6 3a 0a 42			ld a, (.dmark)  
41f9 32 6b ee			ld (debug_mark),a  
41fc 3a 0b 42			ld a, (.dmark+1)  
41ff 32 6c ee			ld (debug_mark+1),a  
4202 3a 0c 42			ld a, (.dmark+2)  
4205 32 6d ee			ld (debug_mark+2),a  
4208 18 03			jr .pastdmark  
420a ..			.dmark: db "BL."  
420d f1			.pastdmark: pop af  
420e			endm  
# End of macro DMARK
420e						CALLMONITOR 
420e cd 6f ee			call debug_vector  
4211				endm  
# End of macro CALLMONITOR
4211					endif 
4211 3e 20				ld a, " " 
4213 32 c1 e2				ld (scratch),a 
4216 3e 00				ld a, 0 
4218 32 c2 e2				ld (scratch+1),a 
421b 21 c1 e2				ld hl, scratch 
421e cd d8 1e				call forth_push_str 
4221					 
4221				       NEXTW 
4221 c3 17 22			jp macro_next 
4224				endm 
# End of macro NEXTW
4224			 
4224			;.blstr: db " ", 0 
4224			 
4224			.SPACES: 
4224				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
4224 47				db WORD_SYS_CORE+51             
4225 bf 42			dw .SCROLL            
4227 07				db 6 + 1 
4228 .. 00			db "SPACES",0              
422f				endm 
# End of macro CWHEAD
422f			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
422f					if DEBUG_FORTH_WORDS_KEY 
422f						DMARK "SPS" 
422f f5				push af  
4230 3a 44 42			ld a, (.dmark)  
4233 32 6b ee			ld (debug_mark),a  
4236 3a 45 42			ld a, (.dmark+1)  
4239 32 6c ee			ld (debug_mark+1),a  
423c 3a 46 42			ld a, (.dmark+2)  
423f 32 6d ee			ld (debug_mark+2),a  
4242 18 03			jr .pastdmark  
4244 ..			.dmark: db "SPS"  
4247 f1			.pastdmark: pop af  
4248			endm  
# End of macro DMARK
4248						CALLMONITOR 
4248 cd 6f ee			call debug_vector  
424b				endm  
# End of macro CALLMONITOR
424b					endif 
424b			 
424b			 
424b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
424b cd 61 20			call macro_dsp_valuehl 
424e				endm 
# End of macro FORTH_DSP_VALUEHL
424e			 
424e e5					push hl    ; u 
424f					if DEBUG_FORTH_WORDS 
424f						DMARK "SPA" 
424f f5				push af  
4250 3a 64 42			ld a, (.dmark)  
4253 32 6b ee			ld (debug_mark),a  
4256 3a 65 42			ld a, (.dmark+1)  
4259 32 6c ee			ld (debug_mark+1),a  
425c 3a 66 42			ld a, (.dmark+2)  
425f 32 6d ee			ld (debug_mark+2),a  
4262 18 03			jr .pastdmark  
4264 ..			.dmark: db "SPA"  
4267 f1			.pastdmark: pop af  
4268			endm  
# End of macro DMARK
4268						CALLMONITOR 
4268 cd 6f ee			call debug_vector  
426b				endm  
# End of macro CALLMONITOR
426b					endif 
426b			 
426b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
426b cd 19 21			call macro_forth_dsp_pop 
426e				endm 
# End of macro FORTH_DSP_POP
426e e1					pop hl 
426f 0e 00				ld c, 0 
4271 45					ld b, l 
4272 21 c1 e2				ld hl, scratch  
4275			 
4275					if DEBUG_FORTH_WORDS 
4275						DMARK "SP2" 
4275 f5				push af  
4276 3a 8a 42			ld a, (.dmark)  
4279 32 6b ee			ld (debug_mark),a  
427c 3a 8b 42			ld a, (.dmark+1)  
427f 32 6c ee			ld (debug_mark+1),a  
4282 3a 8c 42			ld a, (.dmark+2)  
4285 32 6d ee			ld (debug_mark+2),a  
4288 18 03			jr .pastdmark  
428a ..			.dmark: db "SP2"  
428d f1			.pastdmark: pop af  
428e			endm  
# End of macro DMARK
428e						CALLMONITOR 
428e cd 6f ee			call debug_vector  
4291				endm  
# End of macro CALLMONITOR
4291					endif 
4291 3e 20				ld a, ' ' 
4293			.spaces1:	 
4293 77					ld (hl),a 
4294 23					inc hl 
4295					 
4295 10 fc				djnz .spaces1 
4297 3e 00				ld a,0 
4299 77					ld (hl),a 
429a 21 c1 e2				ld hl, scratch 
429d					if DEBUG_FORTH_WORDS 
429d						DMARK "SP3" 
429d f5				push af  
429e 3a b2 42			ld a, (.dmark)  
42a1 32 6b ee			ld (debug_mark),a  
42a4 3a b3 42			ld a, (.dmark+1)  
42a7 32 6c ee			ld (debug_mark+1),a  
42aa 3a b4 42			ld a, (.dmark+2)  
42ad 32 6d ee			ld (debug_mark+2),a  
42b0 18 03			jr .pastdmark  
42b2 ..			.dmark: db "SP3"  
42b5 f1			.pastdmark: pop af  
42b6			endm  
# End of macro DMARK
42b6						CALLMONITOR 
42b6 cd 6f ee			call debug_vector  
42b9				endm  
# End of macro CALLMONITOR
42b9					endif 
42b9 cd d8 1e				call forth_push_str 
42bc			 
42bc				       NEXTW 
42bc c3 17 22			jp macro_next 
42bf				endm 
# End of macro NEXTW
42bf			 
42bf			 
42bf			 
42bf			.SCROLL: 
42bf				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
42bf 53				db WORD_SYS_CORE+63             
42c0 ec 42			dw .SCROLLD            
42c2 07				db 6 + 1 
42c3 .. 00			db "SCROLL",0              
42ca				endm 
# End of macro CWHEAD
42ca			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
42ca					if DEBUG_FORTH_WORDS_KEY 
42ca						DMARK "SCR" 
42ca f5				push af  
42cb 3a df 42			ld a, (.dmark)  
42ce 32 6b ee			ld (debug_mark),a  
42d1 3a e0 42			ld a, (.dmark+1)  
42d4 32 6c ee			ld (debug_mark+1),a  
42d7 3a e1 42			ld a, (.dmark+2)  
42da 32 6d ee			ld (debug_mark+2),a  
42dd 18 03			jr .pastdmark  
42df ..			.dmark: db "SCR"  
42e2 f1			.pastdmark: pop af  
42e3			endm  
# End of macro DMARK
42e3						CALLMONITOR 
42e3 cd 6f ee			call debug_vector  
42e6				endm  
# End of macro CALLMONITOR
42e6					endif 
42e6			 
42e6 cd 7b 0b			call scroll_up 
42e9			;	call update_display 
42e9			 
42e9					NEXTW 
42e9 c3 17 22			jp macro_next 
42ec				endm 
# End of macro NEXTW
42ec			 
42ec			 
42ec			 
42ec			;		; get dir 
42ec			; 
42ec			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42ec			; 
42ec			;		push hl 
42ec			; 
42ec			;		; destroy value TOS 
42ec			; 
42ec			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42ec			; 
42ec			;		; get count 
42ec			; 
42ec			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42ec			; 
42ec			;		push hl 
42ec			; 
42ec			;		; destroy value TOS 
42ec			; 
42ec			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42ec			; 
42ec			;		; one value on hl get other one back 
42ec			; 
42ec			;		pop bc    ; count 
42ec			; 
42ec			;		pop de   ; dir 
42ec			; 
42ec			; 
42ec			;		ld b, c 
42ec			; 
42ec			;.scrolldir:     push bc 
42ec			;		push de 
42ec			; 
42ec			;		ld a, 0 
42ec			;		cp e 
42ec			;		jr z, .scrollup  
42ec			;		call scroll_down 
42ec			;		jr .scrollnext 
42ec			;.scrollup:	call scroll_up 
42ec			; 
42ec			;		 
42ec			;.scrollnext: 
42ec			;		pop de 
42ec			;		pop bc 
42ec			;		djnz .scrolldir 
42ec			; 
42ec			; 
42ec			; 
42ec			; 
42ec			; 
42ec			;		NEXTW 
42ec			 
42ec			.SCROLLD: 
42ec				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
42ec 53				db WORD_SYS_CORE+63             
42ed 1a 43			dw .ATQ            
42ef 08				db 7 + 1 
42f0 .. 00			db "SCROLLD",0              
42f8				endm 
# End of macro CWHEAD
42f8			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
42f8					if DEBUG_FORTH_WORDS_KEY 
42f8						DMARK "SCD" 
42f8 f5				push af  
42f9 3a 0d 43			ld a, (.dmark)  
42fc 32 6b ee			ld (debug_mark),a  
42ff 3a 0e 43			ld a, (.dmark+1)  
4302 32 6c ee			ld (debug_mark+1),a  
4305 3a 0f 43			ld a, (.dmark+2)  
4308 32 6d ee			ld (debug_mark+2),a  
430b 18 03			jr .pastdmark  
430d ..			.dmark: db "SCD"  
4310 f1			.pastdmark: pop af  
4311			endm  
# End of macro DMARK
4311						CALLMONITOR 
4311 cd 6f ee			call debug_vector  
4314				endm  
# End of macro CALLMONITOR
4314					endif 
4314			 
4314 cd 9f 0b			call scroll_down 
4317			;	call update_display 
4317			 
4317					NEXTW 
4317 c3 17 22			jp macro_next 
431a				endm 
# End of macro NEXTW
431a			 
431a			 
431a			.ATQ: 
431a				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
431a 62				db WORD_SYS_CORE+78             
431b 78 43			dw .AUTODSP            
431d 04				db 3 + 1 
431e .. 00			db "AT@",0              
4322				endm 
# End of macro CWHEAD
4322			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4322					if DEBUG_FORTH_WORDS_KEY 
4322						DMARK "ATA" 
4322 f5				push af  
4323 3a 37 43			ld a, (.dmark)  
4326 32 6b ee			ld (debug_mark),a  
4329 3a 38 43			ld a, (.dmark+1)  
432c 32 6c ee			ld (debug_mark+1),a  
432f 3a 39 43			ld a, (.dmark+2)  
4332 32 6d ee			ld (debug_mark+2),a  
4335 18 03			jr .pastdmark  
4337 ..			.dmark: db "ATA"  
433a f1			.pastdmark: pop af  
433b			endm  
# End of macro DMARK
433b						CALLMONITOR 
433b cd 6f ee			call debug_vector  
433e				endm  
# End of macro CALLMONITOR
433e					endif 
433e			 
433e			 
433e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
433e cd 61 20			call macro_dsp_valuehl 
4341				endm 
# End of macro FORTH_DSP_VALUEHL
4341			 
4341					; TODO save cursor row 
4341 7d					ld a,l 
4342 fe 02				cp 2 
4344 20 04				jr nz, .crow3aq 
4346 3e 28				ld a, display_row_2 
4348 18 12				jr .ccol1aq 
434a fe 03		.crow3aq:		cp 3 
434c 20 04				jr nz, .crow4aq 
434e 3e 50				ld a, display_row_3 
4350 18 0a				jr .ccol1aq 
4352 fe 04		.crow4aq:		cp 4 
4354 20 04				jr nz, .crow1aq 
4356 3e 78				ld a, display_row_4 
4358 18 02				jr .ccol1aq 
435a 3e 00		.crow1aq:		ld a,display_row_1 
435c f5			.ccol1aq:		push af			; got row offset 
435d 6f					ld l,a 
435e 26 00				ld h,0 
4360					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4360 cd 19 21			call macro_forth_dsp_pop 
4363				endm 
# End of macro FORTH_DSP_POP
4363					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4363 cd 61 20			call macro_dsp_valuehl 
4366				endm 
# End of macro FORTH_DSP_VALUEHL
4366					; TODO save cursor col 
4366 f1					pop af 
4367 85					add l		; add col offset 
4368			 
4368					; add current frame buffer address 
4368 2a cc eb				ld hl, (display_fb_active) 
436b cd e6 0d				call addatohl 
436e			 
436e			 
436e			 
436e			 
436e					; get char frame buffer location offset in hl 
436e			 
436e 7e					ld a,(hl) 
436f 26 00				ld h, 0 
4371 6f					ld l, a 
4372			 
4372 cd 6a 1e				call forth_push_numhl 
4375			 
4375			 
4375					NEXTW 
4375 c3 17 22			jp macro_next 
4378				endm 
# End of macro NEXTW
4378			 
4378			.AUTODSP: 
4378				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4378 63				db WORD_SYS_CORE+79             
4379 8e 43			dw .MENU            
437b 05				db 4 + 1 
437c .. 00			db "ADSP",0              
4381				endm 
# End of macro CWHEAD
4381			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4381			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4381			 
4381					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4381 cd 61 20			call macro_dsp_valuehl 
4384				endm 
# End of macro FORTH_DSP_VALUEHL
4384			 
4384			;		push hl 
4384			 
4384					; destroy value TOS 
4384			 
4384					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4384 cd 19 21			call macro_forth_dsp_pop 
4387				endm 
# End of macro FORTH_DSP_POP
4387			 
4387			;		pop hl 
4387			 
4387 7d					ld a,l 
4388 32 3c ea				ld (cli_autodisplay), a 
438b				       NEXTW 
438b c3 17 22			jp macro_next 
438e				endm 
# End of macro NEXTW
438e			 
438e			.MENU: 
438e				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
438e 70				db WORD_SYS_CORE+92             
438f 37 44			dw .ENDDISPLAY            
4391 05				db 4 + 1 
4392 .. 00			db "MENU",0              
4397				endm 
# End of macro CWHEAD
4397			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4397			 
4397			;		; get number of items on the stack 
4397			; 
4397				 
4397					FORTH_DSP_VALUEHL 
4397 cd 61 20			call macro_dsp_valuehl 
439a				endm 
# End of macro FORTH_DSP_VALUEHL
439a				 
439a					if DEBUG_FORTH_WORDS_KEY 
439a						DMARK "MNU" 
439a f5				push af  
439b 3a af 43			ld a, (.dmark)  
439e 32 6b ee			ld (debug_mark),a  
43a1 3a b0 43			ld a, (.dmark+1)  
43a4 32 6c ee			ld (debug_mark+1),a  
43a7 3a b1 43			ld a, (.dmark+2)  
43aa 32 6d ee			ld (debug_mark+2),a  
43ad 18 03			jr .pastdmark  
43af ..			.dmark: db "MNU"  
43b2 f1			.pastdmark: pop af  
43b3			endm  
# End of macro DMARK
43b3						CALLMONITOR 
43b3 cd 6f ee			call debug_vector  
43b6				endm  
# End of macro CALLMONITOR
43b6					endif 
43b6			 
43b6 45					ld b, l	 
43b7 05					dec b 
43b8			 
43b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43b8 cd 19 21			call macro_forth_dsp_pop 
43bb				endm 
# End of macro FORTH_DSP_POP
43bb			 
43bb			 
43bb					; go directly through the stack to pluck out the string pointers and build an array 
43bb			 
43bb			;		FORTH_DSP 
43bb			 
43bb					; hl contains top most stack item 
43bb				 
43bb 11 c1 e2				ld de, scratch 
43be			 
43be			.mbuild: 
43be			 
43be					FORTH_DSP_VALUEHL 
43be cd 61 20			call macro_dsp_valuehl 
43c1				endm 
# End of macro FORTH_DSP_VALUEHL
43c1			 
43c1					if DEBUG_FORTH_WORDS 
43c1						DMARK "MN3" 
43c1 f5				push af  
43c2 3a d6 43			ld a, (.dmark)  
43c5 32 6b ee			ld (debug_mark),a  
43c8 3a d7 43			ld a, (.dmark+1)  
43cb 32 6c ee			ld (debug_mark+1),a  
43ce 3a d8 43			ld a, (.dmark+2)  
43d1 32 6d ee			ld (debug_mark+2),a  
43d4 18 03			jr .pastdmark  
43d6 ..			.dmark: db "MN3"  
43d9 f1			.pastdmark: pop af  
43da			endm  
# End of macro DMARK
43da						CALLMONITOR 
43da cd 6f ee			call debug_vector  
43dd				endm  
# End of macro CALLMONITOR
43dd					endif 
43dd eb					ex de, hl 
43de 73					ld (hl), e 
43df 23					inc hl 
43e0 72					ld (hl), d 
43e1 23					inc hl 
43e2 eb					ex de, hl 
43e3			 
43e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43e3 cd 19 21			call macro_forth_dsp_pop 
43e6				endm 
# End of macro FORTH_DSP_POP
43e6			 
43e6 10 d6				djnz .mbuild 
43e8			 
43e8					; done add term 
43e8			 
43e8 eb					ex de, hl 
43e9 36 00				ld (hl), 0 
43eb 23					inc hl 
43ec 36 00				ld (hl), 0 
43ee			 
43ee				 
43ee					 
43ee 21 c1 e2				ld hl, scratch 
43f1			 
43f1					if DEBUG_FORTH_WORDS 
43f1						DMARK "MNx" 
43f1 f5				push af  
43f2 3a 06 44			ld a, (.dmark)  
43f5 32 6b ee			ld (debug_mark),a  
43f8 3a 07 44			ld a, (.dmark+1)  
43fb 32 6c ee			ld (debug_mark+1),a  
43fe 3a 08 44			ld a, (.dmark+2)  
4401 32 6d ee			ld (debug_mark+2),a  
4404 18 03			jr .pastdmark  
4406 ..			.dmark: db "MNx"  
4409 f1			.pastdmark: pop af  
440a			endm  
# End of macro DMARK
440a						CALLMONITOR 
440a cd 6f ee			call debug_vector  
440d				endm  
# End of macro CALLMONITOR
440d					endif 
440d			 
440d			 
440d			 
440d 3e 00				ld a, 0 
440f cd ea 0b				call menu 
4412			 
4412			 
4412 6f					ld l, a 
4413 26 00				ld h, 0 
4415			 
4415					if DEBUG_FORTH_WORDS 
4415						DMARK "MNr" 
4415 f5				push af  
4416 3a 2a 44			ld a, (.dmark)  
4419 32 6b ee			ld (debug_mark),a  
441c 3a 2b 44			ld a, (.dmark+1)  
441f 32 6c ee			ld (debug_mark+1),a  
4422 3a 2c 44			ld a, (.dmark+2)  
4425 32 6d ee			ld (debug_mark+2),a  
4428 18 03			jr .pastdmark  
442a ..			.dmark: db "MNr"  
442d f1			.pastdmark: pop af  
442e			endm  
# End of macro DMARK
442e						CALLMONITOR 
442e cd 6f ee			call debug_vector  
4431				endm  
# End of macro CALLMONITOR
4431					endif 
4431			 
4431 cd 6a 1e				call forth_push_numhl 
4434			 
4434			 
4434			 
4434			 
4434				       NEXTW 
4434 c3 17 22			jp macro_next 
4437				endm 
# End of macro NEXTW
4437			 
4437			 
4437			.ENDDISPLAY: 
4437			 
4437			; eof 
# End of file forth_words_display.asm
4437			include "forth_words_str.asm" 
4437			 
4437			; | ## String Words 
4437			 
4437			.PTR:   
4437			 
4437				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4437 48				db WORD_SYS_CORE+52             
4438 64 44			dw .STYPE            
443a 04				db 3 + 1 
443b .. 00			db "PTR",0              
443f				endm 
# End of macro CWHEAD
443f			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
443f			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
443f			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
443f			 
443f					if DEBUG_FORTH_WORDS_KEY 
443f						DMARK "PTR" 
443f f5				push af  
4440 3a 54 44			ld a, (.dmark)  
4443 32 6b ee			ld (debug_mark),a  
4446 3a 55 44			ld a, (.dmark+1)  
4449 32 6c ee			ld (debug_mark+1),a  
444c 3a 56 44			ld a, (.dmark+2)  
444f 32 6d ee			ld (debug_mark+2),a  
4452 18 03			jr .pastdmark  
4454 ..			.dmark: db "PTR"  
4457 f1			.pastdmark: pop af  
4458			endm  
# End of macro DMARK
4458						CALLMONITOR 
4458 cd 6f ee			call debug_vector  
445b				endm  
# End of macro CALLMONITOR
445b					endif 
445b					FORTH_DSP_VALUEHL 
445b cd 61 20			call macro_dsp_valuehl 
445e				endm 
# End of macro FORTH_DSP_VALUEHL
445e cd 6a 1e				call forth_push_numhl 
4461			 
4461			 
4461					NEXTW 
4461 c3 17 22			jp macro_next 
4464				endm 
# End of macro NEXTW
4464			.STYPE: 
4464				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4464 48				db WORD_SYS_CORE+52             
4465 b3 44			dw .UPPER            
4467 06				db 5 + 1 
4468 .. 00			db "STYPE",0              
446e				endm 
# End of macro CWHEAD
446e			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
446e					if DEBUG_FORTH_WORDS_KEY 
446e						DMARK "STY" 
446e f5				push af  
446f 3a 83 44			ld a, (.dmark)  
4472 32 6b ee			ld (debug_mark),a  
4475 3a 84 44			ld a, (.dmark+1)  
4478 32 6c ee			ld (debug_mark+1),a  
447b 3a 85 44			ld a, (.dmark+2)  
447e 32 6d ee			ld (debug_mark+2),a  
4481 18 03			jr .pastdmark  
4483 ..			.dmark: db "STY"  
4486 f1			.pastdmark: pop af  
4487			endm  
# End of macro DMARK
4487						CALLMONITOR 
4487 cd 6f ee			call debug_vector  
448a				endm  
# End of macro CALLMONITOR
448a					endif 
448a					FORTH_DSP 
448a cd 27 20			call macro_forth_dsp 
448d				endm 
# End of macro FORTH_DSP
448d					;v5 FORTH_DSP_VALUE 
448d			 
448d 7e					ld a, (hl) 
448e			 
448e f5					push af 
448f			 
448f			; Dont destroy TOS		FORTH_DSP_POP 
448f			 
448f f1					pop af 
4490			 
4490 fe 01				cp DS_TYPE_STR 
4492 28 09				jr z, .typestr 
4494			 
4494 fe 02				cp DS_TYPE_INUM 
4496 28 0a				jr z, .typeinum 
4498			 
4498 21 b1 44				ld hl, .tna 
449b 18 0a				jr .tpush 
449d			 
449d 21 ad 44		.typestr:	ld hl, .tstr 
44a0 18 05				jr .tpush 
44a2 21 af 44		.typeinum:	ld hl, .tinum 
44a5 18 00				jr .tpush 
44a7			 
44a7			.tpush: 
44a7			 
44a7 cd d8 1e				call forth_push_str 
44aa			 
44aa					NEXTW 
44aa c3 17 22			jp macro_next 
44ad				endm 
# End of macro NEXTW
44ad .. 00		.tstr:	db "s",0 
44af .. 00		.tinum:  db "i",0 
44b1 .. 00		.tna:   db "?", 0 
44b3			 
44b3			 
44b3			.UPPER: 
44b3				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
44b3 48				db WORD_SYS_CORE+52             
44b4 ee 44			dw .LOWER            
44b6 06				db 5 + 1 
44b7 .. 00			db "UPPER",0              
44bd				endm 
# End of macro CWHEAD
44bd			; | UPPER ( s -- s ) Upper case string s  | DONE 
44bd					if DEBUG_FORTH_WORDS_KEY 
44bd						DMARK "UPR" 
44bd f5				push af  
44be 3a d2 44			ld a, (.dmark)  
44c1 32 6b ee			ld (debug_mark),a  
44c4 3a d3 44			ld a, (.dmark+1)  
44c7 32 6c ee			ld (debug_mark+1),a  
44ca 3a d4 44			ld a, (.dmark+2)  
44cd 32 6d ee			ld (debug_mark+2),a  
44d0 18 03			jr .pastdmark  
44d2 ..			.dmark: db "UPR"  
44d5 f1			.pastdmark: pop af  
44d6			endm  
# End of macro DMARK
44d6						CALLMONITOR 
44d6 cd 6f ee			call debug_vector  
44d9				endm  
# End of macro CALLMONITOR
44d9					endif 
44d9			 
44d9					FORTH_DSP 
44d9 cd 27 20			call macro_forth_dsp 
44dc				endm 
# End of macro FORTH_DSP
44dc					 
44dc			; TODO check is string type 
44dc			 
44dc					FORTH_DSP_VALUEHL 
44dc cd 61 20			call macro_dsp_valuehl 
44df				endm 
# End of macro FORTH_DSP_VALUEHL
44df			; get pointer to string in hl 
44df			 
44df 7e			.toup:		ld a, (hl) 
44e0 fe 00				cp 0 
44e2 28 07				jr z, .toupdone 
44e4			 
44e4 cd 6b 13				call to_upper 
44e7			 
44e7 77					ld (hl), a 
44e8 23					inc hl 
44e9 18 f4				jr .toup 
44eb			 
44eb					 
44eb			 
44eb			 
44eb			; for each char convert to upper 
44eb					 
44eb			.toupdone: 
44eb			 
44eb			 
44eb					NEXTW 
44eb c3 17 22			jp macro_next 
44ee				endm 
# End of macro NEXTW
44ee			.LOWER: 
44ee				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
44ee 48				db WORD_SYS_CORE+52             
44ef 29 45			dw .TCASE            
44f1 06				db 5 + 1 
44f2 .. 00			db "LOWER",0              
44f8				endm 
# End of macro CWHEAD
44f8			; | LOWER ( s -- s ) Lower case string s  | DONE 
44f8					if DEBUG_FORTH_WORDS_KEY 
44f8						DMARK "LWR" 
44f8 f5				push af  
44f9 3a 0d 45			ld a, (.dmark)  
44fc 32 6b ee			ld (debug_mark),a  
44ff 3a 0e 45			ld a, (.dmark+1)  
4502 32 6c ee			ld (debug_mark+1),a  
4505 3a 0f 45			ld a, (.dmark+2)  
4508 32 6d ee			ld (debug_mark+2),a  
450b 18 03			jr .pastdmark  
450d ..			.dmark: db "LWR"  
4510 f1			.pastdmark: pop af  
4511			endm  
# End of macro DMARK
4511						CALLMONITOR 
4511 cd 6f ee			call debug_vector  
4514				endm  
# End of macro CALLMONITOR
4514					endif 
4514			 
4514					FORTH_DSP 
4514 cd 27 20			call macro_forth_dsp 
4517				endm 
# End of macro FORTH_DSP
4517					 
4517			; TODO check is string type 
4517			 
4517					FORTH_DSP_VALUEHL 
4517 cd 61 20			call macro_dsp_valuehl 
451a				endm 
# End of macro FORTH_DSP_VALUEHL
451a			; get pointer to string in hl 
451a			 
451a 7e			.tolow:		ld a, (hl) 
451b fe 00				cp 0 
451d 28 07				jr z, .tolowdone 
451f			 
451f cd 74 13				call to_lower 
4522			 
4522 77					ld (hl), a 
4523 23					inc hl 
4524 18 f4				jr .tolow 
4526			 
4526					 
4526			 
4526			 
4526			; for each char convert to low 
4526					 
4526			.tolowdone: 
4526					NEXTW 
4526 c3 17 22			jp macro_next 
4529				endm 
# End of macro NEXTW
4529			.TCASE: 
4529				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4529 48				db WORD_SYS_CORE+52             
452a 5f 46			dw .SUBSTR            
452c 06				db 5 + 1 
452d .. 00			db "TCASE",0              
4533				endm 
# End of macro CWHEAD
4533			; | TCASE ( s -- s ) Title case string s  | DONE 
4533					if DEBUG_FORTH_WORDS_KEY 
4533						DMARK "TCS" 
4533 f5				push af  
4534 3a 48 45			ld a, (.dmark)  
4537 32 6b ee			ld (debug_mark),a  
453a 3a 49 45			ld a, (.dmark+1)  
453d 32 6c ee			ld (debug_mark+1),a  
4540 3a 4a 45			ld a, (.dmark+2)  
4543 32 6d ee			ld (debug_mark+2),a  
4546 18 03			jr .pastdmark  
4548 ..			.dmark: db "TCS"  
454b f1			.pastdmark: pop af  
454c			endm  
# End of macro DMARK
454c						CALLMONITOR 
454c cd 6f ee			call debug_vector  
454f				endm  
# End of macro CALLMONITOR
454f					endif 
454f			 
454f					FORTH_DSP 
454f cd 27 20			call macro_forth_dsp 
4552				endm 
# End of macro FORTH_DSP
4552					 
4552			; TODO check is string type 
4552			 
4552					FORTH_DSP_VALUEHL 
4552 cd 61 20			call macro_dsp_valuehl 
4555				endm 
# End of macro FORTH_DSP_VALUEHL
4555			; get pointer to string in hl 
4555			 
4555					if DEBUG_FORTH_WORDS 
4555						DMARK "TC1" 
4555 f5				push af  
4556 3a 6a 45			ld a, (.dmark)  
4559 32 6b ee			ld (debug_mark),a  
455c 3a 6b 45			ld a, (.dmark+1)  
455f 32 6c ee			ld (debug_mark+1),a  
4562 3a 6c 45			ld a, (.dmark+2)  
4565 32 6d ee			ld (debug_mark+2),a  
4568 18 03			jr .pastdmark  
456a ..			.dmark: db "TC1"  
456d f1			.pastdmark: pop af  
456e			endm  
# End of macro DMARK
456e						CALLMONITOR 
456e cd 6f ee			call debug_vector  
4571				endm  
# End of macro CALLMONITOR
4571					endif 
4571			 
4571					; first time in turn to upper case first char 
4571			 
4571 7e					ld a, (hl) 
4572 c3 fc 45				jp .totsiptou 
4575			 
4575			 
4575 7e			.tot:		ld a, (hl) 
4576 fe 00				cp 0 
4578 ca 40 46				jp z, .totdone 
457b			 
457b					if DEBUG_FORTH_WORDS 
457b						DMARK "TC2" 
457b f5				push af  
457c 3a 90 45			ld a, (.dmark)  
457f 32 6b ee			ld (debug_mark),a  
4582 3a 91 45			ld a, (.dmark+1)  
4585 32 6c ee			ld (debug_mark+1),a  
4588 3a 92 45			ld a, (.dmark+2)  
458b 32 6d ee			ld (debug_mark+2),a  
458e 18 03			jr .pastdmark  
4590 ..			.dmark: db "TC2"  
4593 f1			.pastdmark: pop af  
4594			endm  
# End of macro DMARK
4594						CALLMONITOR 
4594 cd 6f ee			call debug_vector  
4597				endm  
# End of macro CALLMONITOR
4597					endif 
4597					; check to see if current char is a space 
4597			 
4597 fe 20				cp ' ' 
4599 28 21				jr z, .totsp 
459b cd 74 13				call to_lower 
459e					if DEBUG_FORTH_WORDS 
459e						DMARK "TC3" 
459e f5				push af  
459f 3a b3 45			ld a, (.dmark)  
45a2 32 6b ee			ld (debug_mark),a  
45a5 3a b4 45			ld a, (.dmark+1)  
45a8 32 6c ee			ld (debug_mark+1),a  
45ab 3a b5 45			ld a, (.dmark+2)  
45ae 32 6d ee			ld (debug_mark+2),a  
45b1 18 03			jr .pastdmark  
45b3 ..			.dmark: db "TC3"  
45b6 f1			.pastdmark: pop af  
45b7			endm  
# End of macro DMARK
45b7						CALLMONITOR 
45b7 cd 6f ee			call debug_vector  
45ba				endm  
# End of macro CALLMONITOR
45ba					endif 
45ba 18 63				jr .totnxt 
45bc			 
45bc			.totsp:         ; on a space, find next char which should be upper 
45bc			 
45bc					if DEBUG_FORTH_WORDS 
45bc						DMARK "TC4" 
45bc f5				push af  
45bd 3a d1 45			ld a, (.dmark)  
45c0 32 6b ee			ld (debug_mark),a  
45c3 3a d2 45			ld a, (.dmark+1)  
45c6 32 6c ee			ld (debug_mark+1),a  
45c9 3a d3 45			ld a, (.dmark+2)  
45cc 32 6d ee			ld (debug_mark+2),a  
45cf 18 03			jr .pastdmark  
45d1 ..			.dmark: db "TC4"  
45d4 f1			.pastdmark: pop af  
45d5			endm  
# End of macro DMARK
45d5						CALLMONITOR 
45d5 cd 6f ee			call debug_vector  
45d8				endm  
# End of macro CALLMONITOR
45d8					endif 
45d8					;; 
45d8			 
45d8 fe 20				cp ' ' 
45da 20 20				jr nz, .totsiptou 
45dc 23					inc hl 
45dd 7e					ld a, (hl) 
45de					if DEBUG_FORTH_WORDS 
45de						DMARK "TC5" 
45de f5				push af  
45df 3a f3 45			ld a, (.dmark)  
45e2 32 6b ee			ld (debug_mark),a  
45e5 3a f4 45			ld a, (.dmark+1)  
45e8 32 6c ee			ld (debug_mark+1),a  
45eb 3a f5 45			ld a, (.dmark+2)  
45ee 32 6d ee			ld (debug_mark+2),a  
45f1 18 03			jr .pastdmark  
45f3 ..			.dmark: db "TC5"  
45f6 f1			.pastdmark: pop af  
45f7			endm  
# End of macro DMARK
45f7						CALLMONITOR 
45f7 cd 6f ee			call debug_vector  
45fa				endm  
# End of macro CALLMONITOR
45fa					endif 
45fa 18 c0				jr .totsp 
45fc fe 00		.totsiptou:    cp 0 
45fe 28 40				jr z, .totdone 
4600					; not space and not zero term so upper case it 
4600 cd 6b 13				call to_upper 
4603			 
4603					if DEBUG_FORTH_WORDS 
4603						DMARK "TC6" 
4603 f5				push af  
4604 3a 18 46			ld a, (.dmark)  
4607 32 6b ee			ld (debug_mark),a  
460a 3a 19 46			ld a, (.dmark+1)  
460d 32 6c ee			ld (debug_mark+1),a  
4610 3a 1a 46			ld a, (.dmark+2)  
4613 32 6d ee			ld (debug_mark+2),a  
4616 18 03			jr .pastdmark  
4618 ..			.dmark: db "TC6"  
461b f1			.pastdmark: pop af  
461c			endm  
# End of macro DMARK
461c						CALLMONITOR 
461c cd 6f ee			call debug_vector  
461f				endm  
# End of macro CALLMONITOR
461f					endif 
461f			 
461f			 
461f			.totnxt: 
461f			 
461f 77					ld (hl), a 
4620 23					inc hl 
4621					if DEBUG_FORTH_WORDS 
4621						DMARK "TC7" 
4621 f5				push af  
4622 3a 36 46			ld a, (.dmark)  
4625 32 6b ee			ld (debug_mark),a  
4628 3a 37 46			ld a, (.dmark+1)  
462b 32 6c ee			ld (debug_mark+1),a  
462e 3a 38 46			ld a, (.dmark+2)  
4631 32 6d ee			ld (debug_mark+2),a  
4634 18 03			jr .pastdmark  
4636 ..			.dmark: db "TC7"  
4639 f1			.pastdmark: pop af  
463a			endm  
# End of macro DMARK
463a						CALLMONITOR 
463a cd 6f ee			call debug_vector  
463d				endm  
# End of macro CALLMONITOR
463d					endif 
463d c3 75 45				jp .tot 
4640			 
4640					 
4640			 
4640			 
4640			; for each char convert to low 
4640					 
4640			.totdone: 
4640					if DEBUG_FORTH_WORDS 
4640						DMARK "TCd" 
4640 f5				push af  
4641 3a 55 46			ld a, (.dmark)  
4644 32 6b ee			ld (debug_mark),a  
4647 3a 56 46			ld a, (.dmark+1)  
464a 32 6c ee			ld (debug_mark+1),a  
464d 3a 57 46			ld a, (.dmark+2)  
4650 32 6d ee			ld (debug_mark+2),a  
4653 18 03			jr .pastdmark  
4655 ..			.dmark: db "TCd"  
4658 f1			.pastdmark: pop af  
4659			endm  
# End of macro DMARK
4659						CALLMONITOR 
4659 cd 6f ee			call debug_vector  
465c				endm  
# End of macro CALLMONITOR
465c					endif 
465c					NEXTW 
465c c3 17 22			jp macro_next 
465f				endm 
# End of macro NEXTW
465f			 
465f			.SUBSTR: 
465f				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
465f 48				db WORD_SYS_CORE+52             
4660 bd 46			dw .LEFT            
4662 07				db 6 + 1 
4663 .. 00			db "SUBSTR",0              
466a				endm 
# End of macro CWHEAD
466a			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
466a			 
466a					if DEBUG_FORTH_WORDS_KEY 
466a						DMARK "SST" 
466a f5				push af  
466b 3a 7f 46			ld a, (.dmark)  
466e 32 6b ee			ld (debug_mark),a  
4671 3a 80 46			ld a, (.dmark+1)  
4674 32 6c ee			ld (debug_mark+1),a  
4677 3a 81 46			ld a, (.dmark+2)  
467a 32 6d ee			ld (debug_mark+2),a  
467d 18 03			jr .pastdmark  
467f ..			.dmark: db "SST"  
4682 f1			.pastdmark: pop af  
4683			endm  
# End of macro DMARK
4683						CALLMONITOR 
4683 cd 6f ee			call debug_vector  
4686				endm  
# End of macro CALLMONITOR
4686					endif 
4686			; TODO check string type 
4686					FORTH_DSP_VALUEHL 
4686 cd 61 20			call macro_dsp_valuehl 
4689				endm 
# End of macro FORTH_DSP_VALUEHL
4689			 
4689 e5					push hl      ; string length 
468a			 
468a					FORTH_DSP_POP 
468a cd 19 21			call macro_forth_dsp_pop 
468d				endm 
# End of macro FORTH_DSP_POP
468d			 
468d					FORTH_DSP_VALUEHL 
468d cd 61 20			call macro_dsp_valuehl 
4690				endm 
# End of macro FORTH_DSP_VALUEHL
4690			 
4690 e5					push hl     ; start char 
4691			 
4691					FORTH_DSP_POP 
4691 cd 19 21			call macro_forth_dsp_pop 
4694				endm 
# End of macro FORTH_DSP_POP
4694			 
4694			 
4694					FORTH_DSP_VALUE 
4694 cd 4a 20			call macro_forth_dsp_value 
4697				endm 
# End of macro FORTH_DSP_VALUE
4697			 
4697 d1					pop de    ; get start post offset 
4698			 
4698 19					add hl, de    ; starting offset 
4699			 
4699 c1					pop bc 
469a c5					push bc      ; grab size of string 
469b			 
469b e5					push hl    ; save string start  
469c			 
469c 26 00				ld h, 0 
469e 69					ld l, c 
469f 23					inc hl 
46a0 23					inc hl 
46a1			 
46a1 cd d1 14				call malloc 
46a4				if DEBUG_FORTH_MALLOC_GUARD 
46a4 cc d7 4f				call z,malloc_error 
46a7				endif 
46a7			 
46a7 eb					ex de, hl      ; save malloc area for string copy 
46a8 e1					pop hl    ; get back source 
46a9 c1					pop bc    ; get length of string back 
46aa			 
46aa d5					push de    ; save malloc area for after we push 
46ab ed b0				ldir     ; copy substr 
46ad			 
46ad			 
46ad eb					ex de, hl 
46ae 3e 00				ld a, 0 
46b0 77					ld (hl), a   ; term substr 
46b1			 
46b1					 
46b1 e1					pop hl    ; get malloc so we can push it 
46b2 e5					push hl   ; save so we can free it afterwards 
46b3			 
46b3 cd d8 1e				call forth_push_str 
46b6			 
46b6 e1					pop hl 
46b7 cd 9b 15				call free 
46ba			 
46ba					 
46ba					 
46ba			 
46ba			 
46ba					NEXTW 
46ba c3 17 22			jp macro_next 
46bd				endm 
# End of macro NEXTW
46bd			 
46bd			.LEFT: 
46bd				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
46bd 48				db WORD_SYS_CORE+52             
46be e5 46			dw .RIGHT            
46c0 05				db 4 + 1 
46c1 .. 00			db "LEFT",0              
46c6				endm 
# End of macro CWHEAD
46c6			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
46c6					if DEBUG_FORTH_WORDS_KEY 
46c6						DMARK "LEF" 
46c6 f5				push af  
46c7 3a db 46			ld a, (.dmark)  
46ca 32 6b ee			ld (debug_mark),a  
46cd 3a dc 46			ld a, (.dmark+1)  
46d0 32 6c ee			ld (debug_mark+1),a  
46d3 3a dd 46			ld a, (.dmark+2)  
46d6 32 6d ee			ld (debug_mark+2),a  
46d9 18 03			jr .pastdmark  
46db ..			.dmark: db "LEF"  
46de f1			.pastdmark: pop af  
46df			endm  
# End of macro DMARK
46df						CALLMONITOR 
46df cd 6f ee			call debug_vector  
46e2				endm  
# End of macro CALLMONITOR
46e2					endif 
46e2			 
46e2					NEXTW 
46e2 c3 17 22			jp macro_next 
46e5				endm 
# End of macro NEXTW
46e5			.RIGHT: 
46e5				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
46e5 48				db WORD_SYS_CORE+52             
46e6 0e 47			dw .STR2NUM            
46e8 06				db 5 + 1 
46e9 .. 00			db "RIGHT",0              
46ef				endm 
# End of macro CWHEAD
46ef			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
46ef					if DEBUG_FORTH_WORDS_KEY 
46ef						DMARK "RIG" 
46ef f5				push af  
46f0 3a 04 47			ld a, (.dmark)  
46f3 32 6b ee			ld (debug_mark),a  
46f6 3a 05 47			ld a, (.dmark+1)  
46f9 32 6c ee			ld (debug_mark+1),a  
46fc 3a 06 47			ld a, (.dmark+2)  
46ff 32 6d ee			ld (debug_mark+2),a  
4702 18 03			jr .pastdmark  
4704 ..			.dmark: db "RIG"  
4707 f1			.pastdmark: pop af  
4708			endm  
# End of macro DMARK
4708						CALLMONITOR 
4708 cd 6f ee			call debug_vector  
470b				endm  
# End of macro CALLMONITOR
470b					endif 
470b			 
470b					NEXTW 
470b c3 17 22			jp macro_next 
470e				endm 
# End of macro NEXTW
470e			 
470e			 
470e			.STR2NUM: 
470e				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
470e 48				db WORD_SYS_CORE+52             
470f 9a 47			dw .NUM2STR            
4711 08				db 7 + 1 
4712 .. 00			db "STR2NUM",0              
471a				endm 
# End of macro CWHEAD
471a			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
471a			 
471a			 
471a			; TODO STR type check to do 
471a					if DEBUG_FORTH_WORDS_KEY 
471a						DMARK "S2N" 
471a f5				push af  
471b 3a 2f 47			ld a, (.dmark)  
471e 32 6b ee			ld (debug_mark),a  
4721 3a 30 47			ld a, (.dmark+1)  
4724 32 6c ee			ld (debug_mark+1),a  
4727 3a 31 47			ld a, (.dmark+2)  
472a 32 6d ee			ld (debug_mark+2),a  
472d 18 03			jr .pastdmark  
472f ..			.dmark: db "S2N"  
4732 f1			.pastdmark: pop af  
4733			endm  
# End of macro DMARK
4733						CALLMONITOR 
4733 cd 6f ee			call debug_vector  
4736				endm  
# End of macro CALLMONITOR
4736					endif 
4736			 
4736					;FORTH_DSP 
4736					FORTH_DSP_VALUE 
4736 cd 4a 20			call macro_forth_dsp_value 
4739				endm 
# End of macro FORTH_DSP_VALUE
4739					;inc hl 
4739			 
4739 eb					ex de, hl 
473a					if DEBUG_FORTH_WORDS 
473a						DMARK "S2a" 
473a f5				push af  
473b 3a 4f 47			ld a, (.dmark)  
473e 32 6b ee			ld (debug_mark),a  
4741 3a 50 47			ld a, (.dmark+1)  
4744 32 6c ee			ld (debug_mark+1),a  
4747 3a 51 47			ld a, (.dmark+2)  
474a 32 6d ee			ld (debug_mark+2),a  
474d 18 03			jr .pastdmark  
474f ..			.dmark: db "S2a"  
4752 f1			.pastdmark: pop af  
4753			endm  
# End of macro DMARK
4753						CALLMONITOR 
4753 cd 6f ee			call debug_vector  
4756				endm  
# End of macro CALLMONITOR
4756					endif 
4756 cd f3 13				call string_to_uint16 
4759			 
4759					if DEBUG_FORTH_WORDS 
4759						DMARK "S2b" 
4759 f5				push af  
475a 3a 6e 47			ld a, (.dmark)  
475d 32 6b ee			ld (debug_mark),a  
4760 3a 6f 47			ld a, (.dmark+1)  
4763 32 6c ee			ld (debug_mark+1),a  
4766 3a 70 47			ld a, (.dmark+2)  
4769 32 6d ee			ld (debug_mark+2),a  
476c 18 03			jr .pastdmark  
476e ..			.dmark: db "S2b"  
4771 f1			.pastdmark: pop af  
4772			endm  
# End of macro DMARK
4772						CALLMONITOR 
4772 cd 6f ee			call debug_vector  
4775				endm  
# End of macro CALLMONITOR
4775					endif 
4775			;		push hl 
4775					FORTH_DSP_POP 
4775 cd 19 21			call macro_forth_dsp_pop 
4778				endm 
# End of macro FORTH_DSP_POP
4778			;		pop hl 
4778					 
4778					if DEBUG_FORTH_WORDS 
4778						DMARK "S2b" 
4778 f5				push af  
4779 3a 8d 47			ld a, (.dmark)  
477c 32 6b ee			ld (debug_mark),a  
477f 3a 8e 47			ld a, (.dmark+1)  
4782 32 6c ee			ld (debug_mark+1),a  
4785 3a 8f 47			ld a, (.dmark+2)  
4788 32 6d ee			ld (debug_mark+2),a  
478b 18 03			jr .pastdmark  
478d ..			.dmark: db "S2b"  
4790 f1			.pastdmark: pop af  
4791			endm  
# End of macro DMARK
4791						CALLMONITOR 
4791 cd 6f ee			call debug_vector  
4794				endm  
# End of macro CALLMONITOR
4794					endif 
4794 cd 6a 1e				call forth_push_numhl	 
4797			 
4797				 
4797				       NEXTW 
4797 c3 17 22			jp macro_next 
479a				endm 
# End of macro NEXTW
479a			.NUM2STR: 
479a				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
479a 48				db WORD_SYS_CORE+52             
479b a9 47			dw .CONCAT            
479d 08				db 7 + 1 
479e .. 00			db "NUM2STR",0              
47a6				endm 
# End of macro CWHEAD
47a6			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
47a6			 
47a6			;		; malloc a string to target 
47a6			;		ld hl, 10     ; TODO max string size should be fine 
47a6			;		call malloc 
47a6			;		push hl    ; save malloc location 
47a6			; 
47a6			; 
47a6			;; TODO check int type 
47a6			;		FORTH_DSP_VALUEHL 
47a6			;		ld a, l 
47a6			;		call DispAToASCII   
47a6			;;TODO need to chage above call to dump into string 
47a6			; 
47a6			; 
47a6			 
47a6				       NEXTW 
47a6 c3 17 22			jp macro_next 
47a9				endm 
# End of macro NEXTW
47a9			 
47a9			.CONCAT: 
47a9				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
47a9 48				db WORD_SYS_CORE+52             
47aa 5c 48			dw .FIND            
47ac 07				db 6 + 1 
47ad .. 00			db "CONCAT",0              
47b4				endm 
# End of macro CWHEAD
47b4			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
47b4			 
47b4			; TODO check string type 
47b4			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
47b4			 
47b4					if DEBUG_FORTH_WORDS_KEY 
47b4						DMARK "CON" 
47b4 f5				push af  
47b5 3a c9 47			ld a, (.dmark)  
47b8 32 6b ee			ld (debug_mark),a  
47bb 3a ca 47			ld a, (.dmark+1)  
47be 32 6c ee			ld (debug_mark+1),a  
47c1 3a cb 47			ld a, (.dmark+2)  
47c4 32 6d ee			ld (debug_mark+2),a  
47c7 18 03			jr .pastdmark  
47c9 ..			.dmark: db "CON"  
47cc f1			.pastdmark: pop af  
47cd			endm  
# End of macro DMARK
47cd						CALLMONITOR 
47cd cd 6f ee			call debug_vector  
47d0				endm  
# End of macro CALLMONITOR
47d0					endif 
47d0			 
47d0			 
47d0					FORTH_DSP_VALUE 
47d0 cd 4a 20			call macro_forth_dsp_value 
47d3				endm 
# End of macro FORTH_DSP_VALUE
47d3 e5					push hl   ; s2 
47d4			 
47d4					FORTH_DSP_POP 
47d4 cd 19 21			call macro_forth_dsp_pop 
47d7				endm 
# End of macro FORTH_DSP_POP
47d7			 
47d7					FORTH_DSP_VALUE 
47d7 cd 4a 20			call macro_forth_dsp_value 
47da				endm 
# End of macro FORTH_DSP_VALUE
47da			 
47da e5					push hl   ; s1 
47db			 
47db					FORTH_DSP_POP 
47db cd 19 21			call macro_forth_dsp_pop 
47de				endm 
# End of macro FORTH_DSP_POP
47de					 
47de			 
47de					; copy s1 
47de			 
47de				 
47de					; save ptr 
47de e1					pop hl  
47df e5					push hl 
47e0 3e 00				ld a, 0 
47e2 cd 67 14				call strlent 
47e5					;inc hl    ; zer0 
47e5 06 00				ld b, 0 
47e7 4d					ld c, l 
47e8 e1					pop hl		 
47e9 11 c1 e2				ld de, scratch	 
47ec					if DEBUG_FORTH_WORDS 
47ec						DMARK "CO1" 
47ec f5				push af  
47ed 3a 01 48			ld a, (.dmark)  
47f0 32 6b ee			ld (debug_mark),a  
47f3 3a 02 48			ld a, (.dmark+1)  
47f6 32 6c ee			ld (debug_mark+1),a  
47f9 3a 03 48			ld a, (.dmark+2)  
47fc 32 6d ee			ld (debug_mark+2),a  
47ff 18 03			jr .pastdmark  
4801 ..			.dmark: db "CO1"  
4804 f1			.pastdmark: pop af  
4805			endm  
# End of macro DMARK
4805						CALLMONITOR 
4805 cd 6f ee			call debug_vector  
4808				endm  
# End of macro CALLMONITOR
4808					endif 
4808 ed b0				ldir 
480a			 
480a e1					pop hl 
480b e5					push hl 
480c d5					push de 
480d			 
480d			 
480d 3e 00				ld a, 0 
480f cd 67 14				call strlent 
4812 23					inc hl    ; zer0 
4813 23					inc hl 
4814 06 00				ld b, 0 
4816 4d					ld c, l 
4817 d1					pop de 
4818 e1					pop hl		 
4819					if DEBUG_FORTH_WORDS 
4819						DMARK "CO2" 
4819 f5				push af  
481a 3a 2e 48			ld a, (.dmark)  
481d 32 6b ee			ld (debug_mark),a  
4820 3a 2f 48			ld a, (.dmark+1)  
4823 32 6c ee			ld (debug_mark+1),a  
4826 3a 30 48			ld a, (.dmark+2)  
4829 32 6d ee			ld (debug_mark+2),a  
482c 18 03			jr .pastdmark  
482e ..			.dmark: db "CO2"  
4831 f1			.pastdmark: pop af  
4832			endm  
# End of macro DMARK
4832						CALLMONITOR 
4832 cd 6f ee			call debug_vector  
4835				endm  
# End of macro CALLMONITOR
4835					endif 
4835 ed b0				ldir 
4837			 
4837			 
4837			 
4837 21 c1 e2				ld hl, scratch 
483a					if DEBUG_FORTH_WORDS 
483a						DMARK "CO5" 
483a f5				push af  
483b 3a 4f 48			ld a, (.dmark)  
483e 32 6b ee			ld (debug_mark),a  
4841 3a 50 48			ld a, (.dmark+1)  
4844 32 6c ee			ld (debug_mark+1),a  
4847 3a 51 48			ld a, (.dmark+2)  
484a 32 6d ee			ld (debug_mark+2),a  
484d 18 03			jr .pastdmark  
484f ..			.dmark: db "CO5"  
4852 f1			.pastdmark: pop af  
4853			endm  
# End of macro DMARK
4853						CALLMONITOR 
4853 cd 6f ee			call debug_vector  
4856				endm  
# End of macro CALLMONITOR
4856					endif 
4856			 
4856 cd d8 1e				call forth_push_str 
4859			 
4859			 
4859			 
4859			 
4859				       NEXTW 
4859 c3 17 22			jp macro_next 
485c				endm 
# End of macro NEXTW
485c			 
485c			 
485c			.FIND: 
485c				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
485c 4b				db WORD_SYS_CORE+55             
485d 1a 49			dw .LEN            
485f 05				db 4 + 1 
4860 .. 00			db "FIND",0              
4865				endm 
# End of macro CWHEAD
4865			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4865			 
4865					if DEBUG_FORTH_WORDS_KEY 
4865						DMARK "FND" 
4865 f5				push af  
4866 3a 7a 48			ld a, (.dmark)  
4869 32 6b ee			ld (debug_mark),a  
486c 3a 7b 48			ld a, (.dmark+1)  
486f 32 6c ee			ld (debug_mark+1),a  
4872 3a 7c 48			ld a, (.dmark+2)  
4875 32 6d ee			ld (debug_mark+2),a  
4878 18 03			jr .pastdmark  
487a ..			.dmark: db "FND"  
487d f1			.pastdmark: pop af  
487e			endm  
# End of macro DMARK
487e						CALLMONITOR 
487e cd 6f ee			call debug_vector  
4881				endm  
# End of macro CALLMONITOR
4881					endif 
4881			 
4881			; TODO check string type 
4881					FORTH_DSP_VALUE 
4881 cd 4a 20			call macro_forth_dsp_value 
4884				endm 
# End of macro FORTH_DSP_VALUE
4884			 
4884 e5					push hl    
4885 7e					ld a,(hl)    ; char to find   
4886			; TODO change char to substr 
4886			 
4886 f5					push af 
4887					 
4887			 
4887			 
4887					if DEBUG_FORTH_WORDS 
4887						DMARK "FN1" 
4887 f5				push af  
4888 3a 9c 48			ld a, (.dmark)  
488b 32 6b ee			ld (debug_mark),a  
488e 3a 9d 48			ld a, (.dmark+1)  
4891 32 6c ee			ld (debug_mark+1),a  
4894 3a 9e 48			ld a, (.dmark+2)  
4897 32 6d ee			ld (debug_mark+2),a  
489a 18 03			jr .pastdmark  
489c ..			.dmark: db "FN1"  
489f f1			.pastdmark: pop af  
48a0			endm  
# End of macro DMARK
48a0						CALLMONITOR 
48a0 cd 6f ee			call debug_vector  
48a3				endm  
# End of macro CALLMONITOR
48a3					endif 
48a3			 
48a3					FORTH_DSP_POP 
48a3 cd 19 21			call macro_forth_dsp_pop 
48a6				endm 
# End of macro FORTH_DSP_POP
48a6			 
48a6					; string to search 
48a6			 
48a6					FORTH_DSP_VALUE 
48a6 cd 4a 20			call macro_forth_dsp_value 
48a9				endm 
# End of macro FORTH_DSP_VALUE
48a9			 
48a9 d1					pop de  ; d is char to find  
48aa			 
48aa					if DEBUG_FORTH_WORDS 
48aa						DMARK "FN2" 
48aa f5				push af  
48ab 3a bf 48			ld a, (.dmark)  
48ae 32 6b ee			ld (debug_mark),a  
48b1 3a c0 48			ld a, (.dmark+1)  
48b4 32 6c ee			ld (debug_mark+1),a  
48b7 3a c1 48			ld a, (.dmark+2)  
48ba 32 6d ee			ld (debug_mark+2),a  
48bd 18 03			jr .pastdmark  
48bf ..			.dmark: db "FN2"  
48c2 f1			.pastdmark: pop af  
48c3			endm  
# End of macro DMARK
48c3						CALLMONITOR 
48c3 cd 6f ee			call debug_vector  
48c6				endm  
# End of macro CALLMONITOR
48c6					endif 
48c6					 
48c6 01 00 00				ld bc, 0 
48c9 7e			.findchar:      ld a,(hl) 
48ca fe 00				cp 0   		 
48cc 28 27				jr z, .finddone     
48ce ba					cp d 
48cf 28 20				jr z, .foundchar 
48d1 03					inc bc 
48d2 23					inc hl 
48d3					if DEBUG_FORTH_WORDS 
48d3						DMARK "FN3" 
48d3 f5				push af  
48d4 3a e8 48			ld a, (.dmark)  
48d7 32 6b ee			ld (debug_mark),a  
48da 3a e9 48			ld a, (.dmark+1)  
48dd 32 6c ee			ld (debug_mark+1),a  
48e0 3a ea 48			ld a, (.dmark+2)  
48e3 32 6d ee			ld (debug_mark+2),a  
48e6 18 03			jr .pastdmark  
48e8 ..			.dmark: db "FN3"  
48eb f1			.pastdmark: pop af  
48ec			endm  
# End of macro DMARK
48ec						CALLMONITOR 
48ec cd 6f ee			call debug_vector  
48ef				endm  
# End of macro CALLMONITOR
48ef					endif 
48ef 18 d8				jr .findchar 
48f1			 
48f1			 
48f1 c5			.foundchar:	push bc 
48f2 e1					pop hl 
48f3 18 03				jr .findexit 
48f5			 
48f5			 
48f5							 
48f5			 
48f5			.finddone:     ; got to end of string with no find 
48f5 21 00 00				ld hl, 0 
48f8			.findexit: 
48f8			 
48f8					if DEBUG_FORTH_WORDS 
48f8						DMARK "FNd" 
48f8 f5				push af  
48f9 3a 0d 49			ld a, (.dmark)  
48fc 32 6b ee			ld (debug_mark),a  
48ff 3a 0e 49			ld a, (.dmark+1)  
4902 32 6c ee			ld (debug_mark+1),a  
4905 3a 0f 49			ld a, (.dmark+2)  
4908 32 6d ee			ld (debug_mark+2),a  
490b 18 03			jr .pastdmark  
490d ..			.dmark: db "FNd"  
4910 f1			.pastdmark: pop af  
4911			endm  
# End of macro DMARK
4911						CALLMONITOR 
4911 cd 6f ee			call debug_vector  
4914				endm  
# End of macro CALLMONITOR
4914					endif 
4914 cd 6a 1e			call forth_push_numhl 
4917			 
4917				       NEXTW 
4917 c3 17 22			jp macro_next 
491a				endm 
# End of macro NEXTW
491a			 
491a			.LEN: 
491a				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
491a 4c				db WORD_SYS_CORE+56             
491b 84 49			dw .ASC            
491d 06				db 5 + 1 
491e .. 00			db "COUNT",0              
4924				endm 
# End of macro CWHEAD
4924			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4924			 
4924					if DEBUG_FORTH_WORDS_KEY 
4924						DMARK "CNT" 
4924 f5				push af  
4925 3a 39 49			ld a, (.dmark)  
4928 32 6b ee			ld (debug_mark),a  
492b 3a 3a 49			ld a, (.dmark+1)  
492e 32 6c ee			ld (debug_mark+1),a  
4931 3a 3b 49			ld a, (.dmark+2)  
4934 32 6d ee			ld (debug_mark+2),a  
4937 18 03			jr .pastdmark  
4939 ..			.dmark: db "CNT"  
493c f1			.pastdmark: pop af  
493d			endm  
# End of macro DMARK
493d						CALLMONITOR 
493d cd 6f ee			call debug_vector  
4940				endm  
# End of macro CALLMONITOR
4940					endif 
4940			; TODO check string type 
4940					FORTH_DSP_VALUE 
4940 cd 4a 20			call macro_forth_dsp_value 
4943				endm 
# End of macro FORTH_DSP_VALUE
4943			 
4943			 
4943					if DEBUG_FORTH_WORDS 
4943						DMARK "CN?" 
4943 f5				push af  
4944 3a 58 49			ld a, (.dmark)  
4947 32 6b ee			ld (debug_mark),a  
494a 3a 59 49			ld a, (.dmark+1)  
494d 32 6c ee			ld (debug_mark+1),a  
4950 3a 5a 49			ld a, (.dmark+2)  
4953 32 6d ee			ld (debug_mark+2),a  
4956 18 03			jr .pastdmark  
4958 ..			.dmark: db "CN?"  
495b f1			.pastdmark: pop af  
495c			endm  
# End of macro DMARK
495c						CALLMONITOR 
495c cd 6f ee			call debug_vector  
495f				endm  
# End of macro CALLMONITOR
495f					endif 
495f cd 5c 14				call strlenz 
4962					if DEBUG_FORTH_WORDS 
4962						DMARK "CNl" 
4962 f5				push af  
4963 3a 77 49			ld a, (.dmark)  
4966 32 6b ee			ld (debug_mark),a  
4969 3a 78 49			ld a, (.dmark+1)  
496c 32 6c ee			ld (debug_mark+1),a  
496f 3a 79 49			ld a, (.dmark+2)  
4972 32 6d ee			ld (debug_mark+2),a  
4975 18 03			jr .pastdmark  
4977 ..			.dmark: db "CNl"  
497a f1			.pastdmark: pop af  
497b			endm  
# End of macro DMARK
497b						CALLMONITOR 
497b cd 6f ee			call debug_vector  
497e				endm  
# End of macro CALLMONITOR
497e					endif 
497e			 
497e cd 6a 1e				call forth_push_numhl 
4981			 
4981			 
4981			 
4981				       NEXTW 
4981 c3 17 22			jp macro_next 
4984				endm 
# End of macro NEXTW
4984			.ASC: 
4984				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4984 4d				db WORD_SYS_CORE+57             
4985 f2 49			dw .CHR            
4987 04				db 3 + 1 
4988 .. 00			db "ASC",0              
498c				endm 
# End of macro CWHEAD
498c			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
498c					if DEBUG_FORTH_WORDS_KEY 
498c						DMARK "ASC" 
498c f5				push af  
498d 3a a1 49			ld a, (.dmark)  
4990 32 6b ee			ld (debug_mark),a  
4993 3a a2 49			ld a, (.dmark+1)  
4996 32 6c ee			ld (debug_mark+1),a  
4999 3a a3 49			ld a, (.dmark+2)  
499c 32 6d ee			ld (debug_mark+2),a  
499f 18 03			jr .pastdmark  
49a1 ..			.dmark: db "ASC"  
49a4 f1			.pastdmark: pop af  
49a5			endm  
# End of macro DMARK
49a5						CALLMONITOR 
49a5 cd 6f ee			call debug_vector  
49a8				endm  
# End of macro CALLMONITOR
49a8					endif 
49a8					FORTH_DSP_VALUE 
49a8 cd 4a 20			call macro_forth_dsp_value 
49ab				endm 
# End of macro FORTH_DSP_VALUE
49ab					;v5 FORTH_DSP_VALUE 
49ab			;		inc hl      ; now at start of numeric as string 
49ab			 
49ab e5					push hl 
49ac			 
49ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49ac cd 19 21			call macro_forth_dsp_pop 
49af				endm 
# End of macro FORTH_DSP_POP
49af			 
49af e1					pop hl 
49b0			 
49b0					if DEBUG_FORTH_WORDS 
49b0						DMARK "AS1" 
49b0 f5				push af  
49b1 3a c5 49			ld a, (.dmark)  
49b4 32 6b ee			ld (debug_mark),a  
49b7 3a c6 49			ld a, (.dmark+1)  
49ba 32 6c ee			ld (debug_mark+1),a  
49bd 3a c7 49			ld a, (.dmark+2)  
49c0 32 6d ee			ld (debug_mark+2),a  
49c3 18 03			jr .pastdmark  
49c5 ..			.dmark: db "AS1"  
49c8 f1			.pastdmark: pop af  
49c9			endm  
# End of macro DMARK
49c9						CALLMONITOR 
49c9 cd 6f ee			call debug_vector  
49cc				endm  
# End of macro CALLMONITOR
49cc					endif 
49cc					; push the content of a onto the stack as a value 
49cc			 
49cc 7e					ld a,(hl)   ; get char 
49cd 26 00				ld h,0 
49cf 6f					ld l,a 
49d0					if DEBUG_FORTH_WORDS 
49d0						DMARK "AS2" 
49d0 f5				push af  
49d1 3a e5 49			ld a, (.dmark)  
49d4 32 6b ee			ld (debug_mark),a  
49d7 3a e6 49			ld a, (.dmark+1)  
49da 32 6c ee			ld (debug_mark+1),a  
49dd 3a e7 49			ld a, (.dmark+2)  
49e0 32 6d ee			ld (debug_mark+2),a  
49e3 18 03			jr .pastdmark  
49e5 ..			.dmark: db "AS2"  
49e8 f1			.pastdmark: pop af  
49e9			endm  
# End of macro DMARK
49e9						CALLMONITOR 
49e9 cd 6f ee			call debug_vector  
49ec				endm  
# End of macro CALLMONITOR
49ec					endif 
49ec cd 6a 1e				call forth_push_numhl 
49ef			 
49ef				       NEXTW 
49ef c3 17 22			jp macro_next 
49f2				endm 
# End of macro NEXTW
49f2			 
49f2			.CHR: 
49f2				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
49f2 4d				db WORD_SYS_CORE+57             
49f3 2e 4a			dw .ENDSTR            
49f5 04				db 3 + 1 
49f6 .. 00			db "CHR",0              
49fa				endm 
# End of macro CWHEAD
49fa			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
49fa					if DEBUG_FORTH_WORDS_KEY 
49fa						DMARK "CHR" 
49fa f5				push af  
49fb 3a 0f 4a			ld a, (.dmark)  
49fe 32 6b ee			ld (debug_mark),a  
4a01 3a 10 4a			ld a, (.dmark+1)  
4a04 32 6c ee			ld (debug_mark+1),a  
4a07 3a 11 4a			ld a, (.dmark+2)  
4a0a 32 6d ee			ld (debug_mark+2),a  
4a0d 18 03			jr .pastdmark  
4a0f ..			.dmark: db "CHR"  
4a12 f1			.pastdmark: pop af  
4a13			endm  
# End of macro DMARK
4a13						CALLMONITOR 
4a13 cd 6f ee			call debug_vector  
4a16				endm  
# End of macro CALLMONITOR
4a16					endif 
4a16					FORTH_DSP_VALUEHL 
4a16 cd 61 20			call macro_dsp_valuehl 
4a19				endm 
# End of macro FORTH_DSP_VALUEHL
4a19			 
4a19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a19 cd 19 21			call macro_forth_dsp_pop 
4a1c				endm 
# End of macro FORTH_DSP_POP
4a1c			 
4a1c					; save asci byte as a zero term string and push string 
4a1c			 
4a1c 7d					ld a,l 
4a1d 32 c1 e2				ld (scratch), a 
4a20			 
4a20 3e 00				ld a, 0 
4a22 32 c2 e2				ld (scratch+1), a 
4a25			 
4a25 21 c1 e2				ld hl, scratch 
4a28 cd d8 1e				call forth_push_str 
4a2b			 
4a2b			 
4a2b				       NEXTW 
4a2b c3 17 22			jp macro_next 
4a2e				endm 
# End of macro NEXTW
4a2e			 
4a2e			 
4a2e			 
4a2e			 
4a2e			.ENDSTR: 
4a2e			; eof 
4a2e			 
# End of file forth_words_str.asm
4a2e			include "forth_words_key.asm" 
4a2e			 
4a2e			; | ## Keyboard Words 
4a2e			 
4a2e			.KEY: 
4a2e				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4a2e 3e				db WORD_SYS_CORE+42             
4a2f 5e 4a			dw .WAITK            
4a31 04				db 3 + 1 
4a32 .. 00			db "KEY",0              
4a36				endm 
# End of macro CWHEAD
4a36			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4a36			 
4a36					if DEBUG_FORTH_WORDS_KEY 
4a36						DMARK "KEY" 
4a36 f5				push af  
4a37 3a 4b 4a			ld a, (.dmark)  
4a3a 32 6b ee			ld (debug_mark),a  
4a3d 3a 4c 4a			ld a, (.dmark+1)  
4a40 32 6c ee			ld (debug_mark+1),a  
4a43 3a 4d 4a			ld a, (.dmark+2)  
4a46 32 6d ee			ld (debug_mark+2),a  
4a49 18 03			jr .pastdmark  
4a4b ..			.dmark: db "KEY"  
4a4e f1			.pastdmark: pop af  
4a4f			endm  
# End of macro DMARK
4a4f						CALLMONITOR 
4a4f cd 6f ee			call debug_vector  
4a52				endm  
# End of macro CALLMONITOR
4a52					endif 
4a52			; TODO currently waits 
4a52 cd 46 68				call cin 
4a55					;call cin_wait 
4a55 6f					ld l, a 
4a56 26 00				ld h, 0 
4a58 cd 6a 1e				call forth_push_numhl 
4a5b					NEXTW 
4a5b c3 17 22			jp macro_next 
4a5e				endm 
# End of macro NEXTW
4a5e			.WAITK: 
4a5e				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4a5e 3f				db WORD_SYS_CORE+43             
4a5f 90 4a			dw .ACCEPT            
4a61 06				db 5 + 1 
4a62 .. 00			db "WAITK",0              
4a68				endm 
# End of macro CWHEAD
4a68			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4a68					if DEBUG_FORTH_WORDS_KEY 
4a68						DMARK "WAI" 
4a68 f5				push af  
4a69 3a 7d 4a			ld a, (.dmark)  
4a6c 32 6b ee			ld (debug_mark),a  
4a6f 3a 7e 4a			ld a, (.dmark+1)  
4a72 32 6c ee			ld (debug_mark+1),a  
4a75 3a 7f 4a			ld a, (.dmark+2)  
4a78 32 6d ee			ld (debug_mark+2),a  
4a7b 18 03			jr .pastdmark  
4a7d ..			.dmark: db "WAI"  
4a80 f1			.pastdmark: pop af  
4a81			endm  
# End of macro DMARK
4a81						CALLMONITOR 
4a81 cd 6f ee			call debug_vector  
4a84				endm  
# End of macro CALLMONITOR
4a84					endif 
4a84 cd 3e 68				call cin_wait 
4a87 6f					ld l, a 
4a88 26 00				ld h, 0 
4a8a cd 6a 1e				call forth_push_numhl 
4a8d					NEXTW 
4a8d c3 17 22			jp macro_next 
4a90				endm 
# End of macro NEXTW
4a90			.ACCEPT: 
4a90				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4a90 40				db WORD_SYS_CORE+44             
4a91 ee 4a			dw .EDIT            
4a93 07				db 6 + 1 
4a94 .. 00			db "ACCEPT",0              
4a9b				endm 
# End of macro CWHEAD
4a9b			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4a9b					; TODO crashes on push 
4a9b					if DEBUG_FORTH_WORDS_KEY 
4a9b						DMARK "ACC" 
4a9b f5				push af  
4a9c 3a b0 4a			ld a, (.dmark)  
4a9f 32 6b ee			ld (debug_mark),a  
4aa2 3a b1 4a			ld a, (.dmark+1)  
4aa5 32 6c ee			ld (debug_mark+1),a  
4aa8 3a b2 4a			ld a, (.dmark+2)  
4aab 32 6d ee			ld (debug_mark+2),a  
4aae 18 03			jr .pastdmark  
4ab0 ..			.dmark: db "ACC"  
4ab3 f1			.pastdmark: pop af  
4ab4			endm  
# End of macro DMARK
4ab4						CALLMONITOR 
4ab4 cd 6f ee			call debug_vector  
4ab7				endm  
# End of macro CALLMONITOR
4ab7					endif 
4ab7 21 bf e4				ld hl, os_input 
4aba 3e 00				ld a, 0 
4abc 77					ld (hl),a 
4abd 3a 5e ea				ld a,(f_cursor_ptr) 
4ac0 16 64				ld d, 100 
4ac2 0e 00				ld c, 0 
4ac4 1e 28				ld e, 40 
4ac6 cd 13 0e				call input_str 
4ac9					; TODO perhaps do a type check and wrap in quotes if not a number 
4ac9 21 bf e4				ld hl, os_input 
4acc					if DEBUG_FORTH_WORDS 
4acc						DMARK "AC1" 
4acc f5				push af  
4acd 3a e1 4a			ld a, (.dmark)  
4ad0 32 6b ee			ld (debug_mark),a  
4ad3 3a e2 4a			ld a, (.dmark+1)  
4ad6 32 6c ee			ld (debug_mark+1),a  
4ad9 3a e3 4a			ld a, (.dmark+2)  
4adc 32 6d ee			ld (debug_mark+2),a  
4adf 18 03			jr .pastdmark  
4ae1 ..			.dmark: db "AC1"  
4ae4 f1			.pastdmark: pop af  
4ae5			endm  
# End of macro DMARK
4ae5						CALLMONITOR 
4ae5 cd 6f ee			call debug_vector  
4ae8				endm  
# End of macro CALLMONITOR
4ae8					endif 
4ae8 cd d8 1e				call forth_push_str 
4aeb					NEXTW 
4aeb c3 17 22			jp macro_next 
4aee				endm 
# End of macro NEXTW
4aee			 
4aee			.EDIT: 
4aee				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4aee 40				db WORD_SYS_CORE+44             
4aef 90 4b			dw .DEDIT            
4af1 05				db 4 + 1 
4af2 .. 00			db "EDIT",0              
4af7				endm 
# End of macro CWHEAD
4af7			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4af7			 
4af7					; TODO does not copy from stack 
4af7					if DEBUG_FORTH_WORDS_KEY 
4af7						DMARK "EDT" 
4af7 f5				push af  
4af8 3a 0c 4b			ld a, (.dmark)  
4afb 32 6b ee			ld (debug_mark),a  
4afe 3a 0d 4b			ld a, (.dmark+1)  
4b01 32 6c ee			ld (debug_mark+1),a  
4b04 3a 0e 4b			ld a, (.dmark+2)  
4b07 32 6d ee			ld (debug_mark+2),a  
4b0a 18 03			jr .pastdmark  
4b0c ..			.dmark: db "EDT"  
4b0f f1			.pastdmark: pop af  
4b10			endm  
# End of macro DMARK
4b10						CALLMONITOR 
4b10 cd 6f ee			call debug_vector  
4b13				endm  
# End of macro CALLMONITOR
4b13					endif 
4b13			 
4b13					;FORTH_DSP 
4b13					FORTH_DSP_VALUEHL 
4b13 cd 61 20			call macro_dsp_valuehl 
4b16				endm 
# End of macro FORTH_DSP_VALUEHL
4b16			;		inc hl    ; TODO do type check 
4b16			 
4b16			;		call get_word_hl 
4b16 e5					push hl 
4b17					if DEBUG_FORTH_WORDS 
4b17						DMARK "EDp" 
4b17 f5				push af  
4b18 3a 2c 4b			ld a, (.dmark)  
4b1b 32 6b ee			ld (debug_mark),a  
4b1e 3a 2d 4b			ld a, (.dmark+1)  
4b21 32 6c ee			ld (debug_mark+1),a  
4b24 3a 2e 4b			ld a, (.dmark+2)  
4b27 32 6d ee			ld (debug_mark+2),a  
4b2a 18 03			jr .pastdmark  
4b2c ..			.dmark: db "EDp"  
4b2f f1			.pastdmark: pop af  
4b30			endm  
# End of macro DMARK
4b30						CALLMONITOR 
4b30 cd 6f ee			call debug_vector  
4b33				endm  
# End of macro CALLMONITOR
4b33					endif 
4b33				;	ld a, 0 
4b33 cd 5c 14				call strlenz 
4b36 23					inc hl 
4b37			 
4b37 06 00				ld b, 0 
4b39 4d					ld c, l 
4b3a			 
4b3a e1					pop hl 
4b3b 11 bf e4				ld de, os_input 
4b3e					if DEBUG_FORTH_WORDS_KEY 
4b3e						DMARK "EDc" 
4b3e f5				push af  
4b3f 3a 53 4b			ld a, (.dmark)  
4b42 32 6b ee			ld (debug_mark),a  
4b45 3a 54 4b			ld a, (.dmark+1)  
4b48 32 6c ee			ld (debug_mark+1),a  
4b4b 3a 55 4b			ld a, (.dmark+2)  
4b4e 32 6d ee			ld (debug_mark+2),a  
4b51 18 03			jr .pastdmark  
4b53 ..			.dmark: db "EDc"  
4b56 f1			.pastdmark: pop af  
4b57			endm  
# End of macro DMARK
4b57						CALLMONITOR 
4b57 cd 6f ee			call debug_vector  
4b5a				endm  
# End of macro CALLMONITOR
4b5a					endif 
4b5a ed b0				ldir 
4b5c			 
4b5c			 
4b5c 21 bf e4				ld hl, os_input 
4b5f					;ld a, 0 
4b5f					;ld (hl),a 
4b5f 3a 5e ea				ld a,(f_cursor_ptr) 
4b62 16 64				ld d, 100 
4b64 0e 00				ld c, 0 
4b66 1e 28				ld e, 40 
4b68 cd 13 0e				call input_str 
4b6b					; TODO perhaps do a type check and wrap in quotes if not a number 
4b6b 21 bf e4				ld hl, os_input 
4b6e					if DEBUG_FORTH_WORDS 
4b6e						DMARK "ED1" 
4b6e f5				push af  
4b6f 3a 83 4b			ld a, (.dmark)  
4b72 32 6b ee			ld (debug_mark),a  
4b75 3a 84 4b			ld a, (.dmark+1)  
4b78 32 6c ee			ld (debug_mark+1),a  
4b7b 3a 85 4b			ld a, (.dmark+2)  
4b7e 32 6d ee			ld (debug_mark+2),a  
4b81 18 03			jr .pastdmark  
4b83 ..			.dmark: db "ED1"  
4b86 f1			.pastdmark: pop af  
4b87			endm  
# End of macro DMARK
4b87						CALLMONITOR 
4b87 cd 6f ee			call debug_vector  
4b8a				endm  
# End of macro CALLMONITOR
4b8a					endif 
4b8a cd d8 1e				call forth_push_str 
4b8d					NEXTW 
4b8d c3 17 22			jp macro_next 
4b90				endm 
# End of macro NEXTW
4b90			 
4b90			.DEDIT: 
4b90				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4b90 40				db WORD_SYS_CORE+44             
4b91 f2 4b			dw .ENDKEY            
4b93 06				db 5 + 1 
4b94 .. 00			db "DEDIT",0              
4b9a				endm 
# End of macro CWHEAD
4b9a			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4b9a			 
4b9a					; TODO does not copy from stack 
4b9a					if DEBUG_FORTH_WORDS_KEY 
4b9a						DMARK "DED" 
4b9a f5				push af  
4b9b 3a af 4b			ld a, (.dmark)  
4b9e 32 6b ee			ld (debug_mark),a  
4ba1 3a b0 4b			ld a, (.dmark+1)  
4ba4 32 6c ee			ld (debug_mark+1),a  
4ba7 3a b1 4b			ld a, (.dmark+2)  
4baa 32 6d ee			ld (debug_mark+2),a  
4bad 18 03			jr .pastdmark  
4baf ..			.dmark: db "DED"  
4bb2 f1			.pastdmark: pop af  
4bb3			endm  
# End of macro DMARK
4bb3						CALLMONITOR 
4bb3 cd 6f ee			call debug_vector  
4bb6				endm  
# End of macro CALLMONITOR
4bb6					endif 
4bb6			 
4bb6					;FORTH_DSP 
4bb6					FORTH_DSP_VALUEHL 
4bb6 cd 61 20			call macro_dsp_valuehl 
4bb9				endm 
# End of macro FORTH_DSP_VALUEHL
4bb9			;		inc hl    ; TODO do type check 
4bb9			 
4bb9			;		call get_word_hl 
4bb9 e5					push hl 
4bba e5					push hl 
4bbb					FORTH_DSP_POP 
4bbb cd 19 21			call macro_forth_dsp_pop 
4bbe				endm 
# End of macro FORTH_DSP_POP
4bbe e1					pop hl 
4bbf					if DEBUG_FORTH_WORDS 
4bbf						DMARK "EDp" 
4bbf f5				push af  
4bc0 3a d4 4b			ld a, (.dmark)  
4bc3 32 6b ee			ld (debug_mark),a  
4bc6 3a d5 4b			ld a, (.dmark+1)  
4bc9 32 6c ee			ld (debug_mark+1),a  
4bcc 3a d6 4b			ld a, (.dmark+2)  
4bcf 32 6d ee			ld (debug_mark+2),a  
4bd2 18 03			jr .pastdmark  
4bd4 ..			.dmark: db "EDp"  
4bd7 f1			.pastdmark: pop af  
4bd8			endm  
# End of macro DMARK
4bd8						CALLMONITOR 
4bd8 cd 6f ee			call debug_vector  
4bdb				endm  
# End of macro CALLMONITOR
4bdb					endif 
4bdb				;	ld a, 0 
4bdb cd 5c 14				call strlenz 
4bde 23					inc hl 
4bdf			 
4bdf 06 00				ld b, 0 
4be1 4d					ld c, l 
4be2			 
4be2 e1					pop hl 
4be3			 
4be3					;ld a, 0 
4be3					;ld (hl),a 
4be3 3a 5e ea				ld a,(f_cursor_ptr) 
4be6 16 64				ld d, 100 
4be8 0e 00				ld c, 0 
4bea 1e 28				ld e, 40 
4bec cd 13 0e				call input_str 
4bef					; TODO perhaps do a type check and wrap in quotes if not a number 
4bef					NEXTW 
4bef c3 17 22			jp macro_next 
4bf2				endm 
# End of macro NEXTW
4bf2			 
4bf2			 
4bf2			.ENDKEY: 
4bf2			; eof 
4bf2			 
# End of file forth_words_key.asm
4bf2			include "forth_words_const.asm" 
4bf2			 
4bf2			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4bf2			 
4bf2			 
4bf2			.SPITIME: 
4bf2				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4bf2 77				db WORD_SYS_CORE+99             
4bf3 07 4c			dw .VA            
4bf5 08				db 7 + 1 
4bf6 .. 00			db "SPITIME",0              
4bfe				endm 
# End of macro CWHEAD
4bfe			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4bfe			; 
4bfe			; | | If using BANK devices then leave as is. 
4bfe			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4bfe			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4bfe			 
4bfe 21 64 ea				ld hl, spi_clktime  
4c01 cd 6a 1e				call forth_push_numhl 
4c04			 
4c04					NEXTW 
4c04 c3 17 22			jp macro_next 
4c07				endm 
# End of macro NEXTW
4c07			 
4c07			 
4c07			.VA: 
4c07				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4c07 77				db WORD_SYS_CORE+99             
4c08 17 4c			dw .SYMBOL            
4c0a 03				db 2 + 1 
4c0b .. 00			db "VA",0              
4c0e				endm 
# End of macro CWHEAD
4c0e			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4c0e 21 28 ea				ld hl, cli_var_array 
4c11 cd 6a 1e				call forth_push_numhl 
4c14			 
4c14					NEXTW 
4c14 c3 17 22			jp macro_next 
4c17				endm 
# End of macro NEXTW
4c17			 
4c17			.SYMBOL: 
4c17				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4c17 77				db WORD_SYS_CORE+99             
4c18 21 4d			dw .ENDCONST            
4c1a 07				db 6 + 1 
4c1b .. 00			db "SYMBOL",0              
4c22				endm 
# End of macro CWHEAD
4c22			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4c22			; | 
4c22			; | | The value is the number reference and the final address is pushed to stack 
4c22			 
4c22			; | | ``` 
4c22			; | | dw sym_table 
4c22			; | | dw nmi_vector 
4c22			; | | dw cli_autodisplay 
4c22			; | | dw cli_data_sp 
4c22			; | | dw cli_data_stack 
4c22			; | | dw cli_loop_sp 
4c22			; | | dw cli_loop_stack 
4c22			; | | dw cli_var_array 
4c22			; | | dw cursor_col 
4c22			; | | dw cursor_ptr 
4c22			; | | ; 10 
4c22			; | | dw cursor_row 
4c22			; | | dw debug_mark 
4c22			; | | dw display_fb0 
4c22			; | | dw display_fb1 
4c22			; | | dw display_fb2 
4c22			; | | dw display_fb3 
4c22			; | | dw display_fb_active 
4c22			; | | dw execscratch 
4c22			; | | dw f_cursor_ptr 
4c22			; | | dw hardware_word 
4c22			; | | ;20 
4c22			; | | dw input_at_cursor 
4c22			; | | dw input_at_pos 
4c22			; | | dw input_cur_flash 
4c22			; | | dw input_cur_onoff 
4c22			; | | dw input_cursor 
4c22			; | | dw input_display_size 
4c22			; | | dw input_len 
4c22			; | | dw input_ptr 
4c22			; | | dw input_size 
4c22			; | | dw input_start 
4c22			; | | ; 30 
4c22			; | | dw input_str 
4c22			; | | dw input_under_cursor 
4c22			; | | dw os_cli_cmd 
4c22			; | | dw os_cur_ptr 
4c22			; | | dw os_current_i 
4c22			; | | dw os_input 
4c22			; | | dw os_last_cmd 
4c22			; | | dw os_last_new_uword 
4c22			; | | dw debug_vector 
4c22			; | | dw os_view_hl 
4c22			; | | ;40 
4c22			; | | dw os_word_scratch 
4c22			; | | dw portbctl 
4c22			; | | dw portbdata 
4c22			; | | dw spi_cartdev 
4c22			; | | dw spi_cartdev2 
4c22			; | | dw spi_clktime 
4c22			; | | dw spi_device 
4c22			; | | dw spi_device_id 
4c22			; | | dw spi_portbyte 
4c22			; | | dw stackstore 
4c22			; | | ; 50 
4c22			; | | if STORAGE_SE 
4c22			; | | dw storage_actl 
4c22			; | | dw storage_adata 
4c22			; | | else 
4c22			; | | dw 0 
4c22			; | | dw 0 
4c22			; | | endif 
4c22			; | | dw storage_append 
4c22			; | | if STORAGE_SE 
4c22			; | | dw storage_bctl 
4c22			; | | else 
4c22			; | | dw 0 
4c22			; | | endif 
4c22			; | | dw store_bank_active 
4c22			; | | dw store_filecache 
4c22			; | | dw store_longread 
4c22			; | | dw store_openaddr 
4c22			; | | dw store_openext 
4c22			; | | dw store_openmaxext 
4c22			; | | ; 60 
4c22			; | | dw store_page 
4c22			; | | dw store_readbuf 
4c22			; | | dw store_readcont 
4c22			; | | dw store_readptr 
4c22			; | | dw store_tmpext 
4c22			; | | dw store_tmpid 
4c22			; | | dw store_tmppageid 
4c22			; | | dw malloc 
4c22			; | | dw free 
4c22			; | | dw cin 
4c22			; | | ; 70 
4c22			; | | dw cin_wait 
4c22			; | | dw forth_push_numhl 
4c22			; | | dw forth_push_str 
4c22			; | | ``` 
4c22			 
4c22					if DEBUG_FORTH_WORDS_KEY 
4c22						DMARK "SYM" 
4c22 f5				push af  
4c23 3a 37 4c			ld a, (.dmark)  
4c26 32 6b ee			ld (debug_mark),a  
4c29 3a 38 4c			ld a, (.dmark+1)  
4c2c 32 6c ee			ld (debug_mark+1),a  
4c2f 3a 39 4c			ld a, (.dmark+2)  
4c32 32 6d ee			ld (debug_mark+2),a  
4c35 18 03			jr .pastdmark  
4c37 ..			.dmark: db "SYM"  
4c3a f1			.pastdmark: pop af  
4c3b			endm  
# End of macro DMARK
4c3b						CALLMONITOR 
4c3b cd 6f ee			call debug_vector  
4c3e				endm  
# End of macro CALLMONITOR
4c3e					endif 
4c3e			 
4c3e					FORTH_DSP_VALUEHL 
4c3e cd 61 20			call macro_dsp_valuehl 
4c41				endm 
# End of macro FORTH_DSP_VALUEHL
4c41			 
4c41 7d					ld a, l     
4c42			 
4c42			 
4c42					if DEBUG_FORTH_WORDS 
4c42						DMARK "SY1" 
4c42 f5				push af  
4c43 3a 57 4c			ld a, (.dmark)  
4c46 32 6b ee			ld (debug_mark),a  
4c49 3a 58 4c			ld a, (.dmark+1)  
4c4c 32 6c ee			ld (debug_mark+1),a  
4c4f 3a 59 4c			ld a, (.dmark+2)  
4c52 32 6d ee			ld (debug_mark+2),a  
4c55 18 03			jr .pastdmark  
4c57 ..			.dmark: db "SY1"  
4c5a f1			.pastdmark: pop af  
4c5b			endm  
# End of macro DMARK
4c5b						CALLMONITOR 
4c5b cd 6f ee			call debug_vector  
4c5e				endm  
# End of macro CALLMONITOR
4c5e					endif 
4c5e					 
4c5e f5					push af	 
4c5f					FORTH_DSP_POP 
4c5f cd 19 21			call macro_forth_dsp_pop 
4c62				endm 
# End of macro FORTH_DSP_POP
4c62 f1					pop af 
4c63			 
4c63 cb 27				sla a  
4c65				 
4c65					 
4c65					if DEBUG_FORTH_WORDS 
4c65						DMARK "SY" 
4c65 f5				push af  
4c66 3a 7a 4c			ld a, (.dmark)  
4c69 32 6b ee			ld (debug_mark),a  
4c6c 3a 7b 4c			ld a, (.dmark+1)  
4c6f 32 6c ee			ld (debug_mark+1),a  
4c72 3a 7c 4c			ld a, (.dmark+2)  
4c75 32 6d ee			ld (debug_mark+2),a  
4c78 18 02			jr .pastdmark  
4c7a ..			.dmark: db "SY"  
4c7c f1			.pastdmark: pop af  
4c7d			endm  
# End of macro DMARK
4c7d						CALLMONITOR 
4c7d cd 6f ee			call debug_vector  
4c80				endm  
# End of macro CALLMONITOR
4c80					endif 
4c80			 
4c80 21 8f 4c				ld hl, sym_table 
4c83 cd e6 0d				call addatohl 
4c86 cd 99 21				call loadwordinhl 
4c89 cd 6a 1e				call forth_push_numhl 
4c8c			 
4c8c			 
4c8c				       NEXTW 
4c8c c3 17 22			jp macro_next 
4c8f				endm 
# End of macro NEXTW
4c8f			 
4c8f			sym_table: 
4c8f			 
4c8f			; 0 
4c8f 8f 4c		dw sym_table 
4c91 72 ee		dw nmi_vector 
4c93 3c ea		dw cli_autodisplay 
4c95 ee e9		dw cli_data_sp 
4c97 28 e8		dw cli_data_stack 
4c99 f0 e9		dw cli_loop_sp 
4c9b 2a e9		dw cli_loop_stack 
4c9d 28 ea		dw cli_var_array 
4c9f c5 eb		dw cursor_col 
4ca1 c3 eb		dw cursor_ptr 
4ca3			; 10 
4ca3 c4 eb		dw cursor_row 
4ca5 6b ee		dw debug_mark 
4ca7 b1 ed		dw display_fb0 
4ca9 10 ed		dw display_fb1 
4cab ce eb		dw display_fb2 
4cad 6f ec		dw display_fb3 
4caf cc eb		dw display_fb_active 
4cb1 c0 e3		dw execscratch 
4cb3 5e ea		dw f_cursor_ptr 
4cb5 75 ee		dw hardware_word 
4cb7			;20 
4cb7 62 ee		dw input_at_cursor 
4cb9 64 ee		dw input_at_pos 
4cbb 60 ee		dw input_cur_flash 
4cbd 5f ee		dw input_cur_onoff 
4cbf 55 ee		dw input_cursor 
4cc1 65 ee		dw input_display_size 
4cc3 5a ee		dw input_len 
4cc5 69 ee		dw input_ptr 
4cc7 66 ee		dw input_size 
4cc9 67 ee		dw input_start 
4ccb			; 30 
4ccb 13 0e		dw input_str 
4ccd 63 ee		dw input_under_cursor 
4ccf e8 e5		dw os_cli_cmd 
4cd1 e4 e5		dw os_cur_ptr 
4cd3 e6 e5		dw os_current_i 
4cd5 bf e4		dw os_input 
4cd7 e7 e6		dw os_last_cmd 
4cd9 be e5		dw os_last_new_uword 
4cdb 6f ee		dw debug_vector 
4cdd a3 e2		dw os_view_hl 
4cdf			;40 
4cdf c6 e5		dw os_word_scratch 
4ce1 c3 00		dw portbctl 
4ce3 c1 00		dw portbdata 
4ce5 63 ea		dw spi_cartdev 
4ce7 62 ea		dw spi_cartdev2 
4ce9 64 ea		dw spi_clktime 
4ceb 60 ea		dw spi_device 
4ced 5f ea		dw spi_device_id 
4cef 61 ea		dw spi_portbyte 
4cf1 a7 eb		dw stackstore 
4cf3			; 50 
4cf3			if STORAGE_SE 
4cf3			dw storage_actl 
4cf3			dw storage_adata 
4cf3			else 
4cf3 00 00		dw 0 
4cf5 00 00		dw 0 
4cf7			endif 
4cf7 68 09		dw storage_append 
4cf9			if STORAGE_SE 
4cf9			dw storage_bctl 
4cf9			else 
4cf9 00 00		dw 0 
4cfb			endif 
4cfb 93 eb		dw store_bank_active 
4cfd 67 ea		dw store_filecache 
4cff 75 ea		dw store_longread 
4d01 6b ea		dw store_openaddr 
4d03 6a ea		dw store_openext 
4d05 69 ea		dw store_openmaxext 
4d07			; 60 
4d07 7a ea		dw store_page 
4d09 76 ea		dw store_readbuf 
4d0b 6d ea		dw store_readcont 
4d0d 78 ea		dw store_readptr 
4d0f 6d ea		dw store_tmpext 
4d11 6e ea		dw store_tmpid 
4d13 65 ea		dw store_tmppageid 
4d15 d1 14		dw malloc 
4d17 9b 15		dw free 
4d19 46 68		dw cin 
4d1b			; 70 
4d1b 3e 68		dw cin_wait 
4d1d 6a 1e		dw forth_push_numhl 
4d1f d8 1e		dw forth_push_str 
4d21			 
4d21			 
4d21			.ENDCONST: 
4d21			 
4d21			; eof 
4d21			 
4d21			 
# End of file forth_words_const.asm
4d21			 
4d21			if STORAGE_SE 
4d21			   	include "forth_words_storage.asm" 
4d21			endif 
4d21				include "forth_words_device.asm" 
4d21			; Device related words 
4d21			 
4d21			; | ## Device Words 
4d21			 
4d21			;if SOUND_ENABLE 
4d21			;.NOTE: 
4d21			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4d21			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4d21			;		if DEBUG_FORTH_WORDS_KEY 
4d21			;			DMARK "NTE" 
4d21			;			CALLMONITOR 
4d21			;		endif 
4d21			; 
4d21			;	 
4d21			; 
4d21			;		NEXTW 
4d21			;.AFTERSOUND: 
4d21			;endif 
4d21			 
4d21			 
4d21			USE_GPIO: equ 0 
4d21			 
4d21			if USE_GPIO 
4d21			.GP1: 
4d21				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4d21			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4d21					NEXTW 
4d21			.GP2: 
4d21				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4d21			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4d21			 
4d21					NEXTW 
4d21			 
4d21			.GP3: 
4d21				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4d21			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4d21			 
4d21					NEXTW 
4d21			 
4d21			.GP4: 
4d21				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4d21			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4d21			 
4d21					NEXTW 
4d21			.SIN: 
4d21			 
4d21			 
4d21			endif 
4d21			 
4d21			 
4d21				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4d21 33				db WORD_SYS_CORE+31             
4d22 56 4d			dw .SOUT            
4d24 03				db 2 + 1 
4d25 .. 00			db "IN",0              
4d28				endm 
# End of macro CWHEAD
4d28			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4d28					if DEBUG_FORTH_WORDS_KEY 
4d28						DMARK "IN." 
4d28 f5				push af  
4d29 3a 3d 4d			ld a, (.dmark)  
4d2c 32 6b ee			ld (debug_mark),a  
4d2f 3a 3e 4d			ld a, (.dmark+1)  
4d32 32 6c ee			ld (debug_mark+1),a  
4d35 3a 3f 4d			ld a, (.dmark+2)  
4d38 32 6d ee			ld (debug_mark+2),a  
4d3b 18 03			jr .pastdmark  
4d3d ..			.dmark: db "IN."  
4d40 f1			.pastdmark: pop af  
4d41			endm  
# End of macro DMARK
4d41						CALLMONITOR 
4d41 cd 6f ee			call debug_vector  
4d44				endm  
# End of macro CALLMONITOR
4d44					endif 
4d44					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d44 cd 61 20			call macro_dsp_valuehl 
4d47				endm 
# End of macro FORTH_DSP_VALUEHL
4d47			 
4d47 e5					push hl 
4d48			 
4d48					; destroy value TOS 
4d48			 
4d48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d48 cd 19 21			call macro_forth_dsp_pop 
4d4b				endm 
# End of macro FORTH_DSP_POP
4d4b			 
4d4b					; one value on hl get other one back 
4d4b			 
4d4b c1					pop bc 
4d4c			 
4d4c					; do the sub 
4d4c			;		ex de, hl 
4d4c			 
4d4c ed 68				in l,(c) 
4d4e			 
4d4e					; save it 
4d4e			 
4d4e 26 00				ld h,0 
4d50			 
4d50					; TODO push value back onto stack for another op etc 
4d50			 
4d50 cd 6a 1e				call forth_push_numhl 
4d53					NEXTW 
4d53 c3 17 22			jp macro_next 
4d56				endm 
# End of macro NEXTW
4d56			.SOUT: 
4d56				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4d56 34				db WORD_SYS_CORE+32             
4d57 a9 4d			dw .SPIO            
4d59 04				db 3 + 1 
4d5a .. 00			db "OUT",0              
4d5e				endm 
# End of macro CWHEAD
4d5e			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4d5e					if DEBUG_FORTH_WORDS_KEY 
4d5e						DMARK "OUT" 
4d5e f5				push af  
4d5f 3a 73 4d			ld a, (.dmark)  
4d62 32 6b ee			ld (debug_mark),a  
4d65 3a 74 4d			ld a, (.dmark+1)  
4d68 32 6c ee			ld (debug_mark+1),a  
4d6b 3a 75 4d			ld a, (.dmark+2)  
4d6e 32 6d ee			ld (debug_mark+2),a  
4d71 18 03			jr .pastdmark  
4d73 ..			.dmark: db "OUT"  
4d76 f1			.pastdmark: pop af  
4d77			endm  
# End of macro DMARK
4d77						CALLMONITOR 
4d77 cd 6f ee			call debug_vector  
4d7a				endm  
# End of macro CALLMONITOR
4d7a					endif 
4d7a			 
4d7a					; get port 
4d7a			 
4d7a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d7a cd 61 20			call macro_dsp_valuehl 
4d7d				endm 
# End of macro FORTH_DSP_VALUEHL
4d7d			 
4d7d e5					push hl 
4d7e			 
4d7e					; destroy value TOS 
4d7e			 
4d7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d7e cd 19 21			call macro_forth_dsp_pop 
4d81				endm 
# End of macro FORTH_DSP_POP
4d81			 
4d81					; get byte to send 
4d81			 
4d81					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d81 cd 61 20			call macro_dsp_valuehl 
4d84				endm 
# End of macro FORTH_DSP_VALUEHL
4d84			 
4d84			;		push hl 
4d84			 
4d84					; destroy value TOS 
4d84			 
4d84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d84 cd 19 21			call macro_forth_dsp_pop 
4d87				endm 
# End of macro FORTH_DSP_POP
4d87			 
4d87					; one value on hl get other one back 
4d87			 
4d87			;		pop hl 
4d87			 
4d87 c1					pop bc 
4d88			 
4d88					if DEBUG_FORTH_WORDS 
4d88						DMARK "OUT" 
4d88 f5				push af  
4d89 3a 9d 4d			ld a, (.dmark)  
4d8c 32 6b ee			ld (debug_mark),a  
4d8f 3a 9e 4d			ld a, (.dmark+1)  
4d92 32 6c ee			ld (debug_mark+1),a  
4d95 3a 9f 4d			ld a, (.dmark+2)  
4d98 32 6d ee			ld (debug_mark+2),a  
4d9b 18 03			jr .pastdmark  
4d9d ..			.dmark: db "OUT"  
4da0 f1			.pastdmark: pop af  
4da1			endm  
# End of macro DMARK
4da1						CALLMONITOR 
4da1 cd 6f ee			call debug_vector  
4da4				endm  
# End of macro CALLMONITOR
4da4					endif 
4da4			 
4da4 ed 69				out (c), l 
4da6			 
4da6					NEXTW 
4da6 c3 17 22			jp macro_next 
4da9				endm 
# End of macro NEXTW
4da9			 
4da9			 
4da9			.SPIO: 
4da9			 
4da9			if STORAGE_SE 
4da9				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4da9			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4da9			 
4da9					call spi_ce_low 
4da9			    NEXTW 
4da9			 
4da9			.SPICEH: 
4da9				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4da9			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4da9			 
4da9					call spi_ce_high 
4da9			    NEXTW 
4da9			 
4da9			 
4da9			.SPIOb: 
4da9			 
4da9				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4da9			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4da9			 
4da9					if DEBUG_FORTH_WORDS_KEY 
4da9						DMARK "SPo" 
4da9						CALLMONITOR 
4da9					endif 
4da9					; get port 
4da9			 
4da9			 
4da9					; get byte to send 
4da9			 
4da9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4da9			 
4da9			;		push hl    ; u1  
4da9			 
4da9					; destroy value TOS 
4da9			 
4da9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4da9			 
4da9					; one value on hl get other one back 
4da9			 
4da9			;		pop hl   ; u2 - addr 
4da9			 
4da9					; TODO Send SPI byte 
4da9			 
4da9			;		push hl 
4da9			;		call spi_ce_low 
4da9			;		pop hl 
4da9					ld a, l 
4da9					call spi_send_byte 
4da9			;		call spi_ce_high 
4da9			 
4da9					NEXTW 
4da9			 
4da9			.SPII: 
4da9				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4da9			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4da9					if DEBUG_FORTH_WORDS_KEY 
4da9						DMARK "SPi" 
4da9						CALLMONITOR 
4da9					endif 
4da9			 
4da9					; TODO Get SPI byte 
4da9			 
4da9					call spi_read_byte 
4da9			 
4da9					if DEBUG_FORTH_WORDS 
4da9						DMARK "Si2" 
4da9						CALLMONITOR 
4da9					endif 
4da9					ld h, 0 
4da9					ld l, a 
4da9					if DEBUG_FORTH_WORDS 
4da9						DMARK "Si3" 
4da9						CALLMONITOR 
4da9					endif 
4da9					call forth_push_numhl 
4da9			 
4da9					NEXTW 
4da9			 
4da9			 
4da9			 
4da9			.SESEL: 
4da9				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4da9			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4da9					if DEBUG_FORTH_WORDS_KEY 
4da9						DMARK "BNK" 
4da9						CALLMONITOR 
4da9					endif 
4da9			 
4da9					ld a, 255 
4da9					ld (spi_cartdev), a 
4da9			 
4da9					; get bank 
4da9			 
4da9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4da9			 
4da9			;		push hl 
4da9			 
4da9					; destroy value TOS 
4da9			 
4da9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4da9			 
4da9					; one value on hl get other one back 
4da9			 
4da9			;		pop hl 
4da9			 
4da9			 
4da9					ld c, SPI_CE_HIGH 
4da9					ld b, '0'    ; human readable bank number 
4da9			 
4da9					ld a, l 
4da9			 
4da9					if DEBUG_FORTH_WORDS 
4da9						DMARK "BNK" 
4da9						CALLMONITOR 
4da9					endif 
4da9			 
4da9					; active low 
4da9			 
4da9					cp 0 
4da9					jr z, .bset 
4da9					cp 1 
4da9					jr nz, .b2 
4da9					res 0, c 
4da9					ld b, '1'    ; human readable bank number 
4da9			.b2:		cp 2 
4da9					jr nz, .b3 
4da9					res 1, c 
4da9					ld b, '2'    ; human readable bank number 
4da9			.b3:		cp 3 
4da9					jr nz, .b4 
4da9					res 2, c 
4da9					ld b, '3'    ; human readable bank number 
4da9			.b4:		cp 4 
4da9					jr nz, .b5 
4da9					res 3, c 
4da9					ld b, '4'    ; human readable bank number 
4da9			.b5:		cp 5 
4da9					jr nz, .bset 
4da9					res 4, c 
4da9					ld b, '5'    ; human readable bank number 
4da9			 
4da9			.bset: 
4da9					ld a, c 
4da9					ld (spi_device),a 
4da9					ld a, b 
4da9					ld (spi_device_id),a 
4da9					if DEBUG_FORTH_WORDS 
4da9						DMARK "BN2" 
4da9						CALLMONITOR 
4da9					endif 
4da9			 
4da9					; set default SPI clk pulse time as disabled for BANK use 
4da9			 
4da9					ld a, 0 
4da9					ld (spi_clktime), a 
4da9			 
4da9					NEXTW 
4da9			 
4da9			.CARTDEV: 
4da9				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4da9			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4da9					if DEBUG_FORTH_WORDS_KEY 
4da9						DMARK "CDV" 
4da9						CALLMONITOR 
4da9					endif 
4da9			 
4da9					; disable se storage bank selection 
4da9			 
4da9					ld a, SPI_CE_HIGH		; ce high 
4da9					ld (spi_device), a 
4da9			 
4da9					; get bank 
4da9			 
4da9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4da9			 
4da9			;		push hl 
4da9			 
4da9					; destroy value TOS 
4da9			 
4da9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4da9			 
4da9					; one value on hl get other one back 
4da9			 
4da9			;		pop hl 
4da9			 
4da9					; active low 
4da9			 
4da9					ld c, 255 
4da9			 
4da9					ld a, l 
4da9					if DEBUG_FORTH_WORDS 
4da9						DMARK "CDV" 
4da9						CALLMONITOR 
4da9					endif 
4da9					cp 0 
4da9					jr z, .cset 
4da9					cp 1 
4da9					jr nz, .c2 
4da9					res 0, c 
4da9			.c2:		cp 2 
4da9					jr nz, .c3 
4da9					res 1, c 
4da9			.c3:		cp 3 
4da9					jr nz, .c4 
4da9					res 2, c 
4da9			.c4:		cp 4 
4da9					jr nz, .c5 
4da9					res 3, c 
4da9			.c5:		cp 5 
4da9					jr nz, .c6 
4da9					res 4, c 
4da9			.c6:		cp 6 
4da9					jr nz, .c7 
4da9					res 5, c 
4da9			.c7:		cp 7 
4da9					jr nz, .c8 
4da9					res 6, c 
4da9			.c8:		cp 8 
4da9					jr nz, .cset 
4da9					res 7, c 
4da9			.cset:		ld a, c 
4da9					ld (spi_cartdev),a 
4da9			 
4da9					if DEBUG_FORTH_WORDS 
4da9						DMARK "CD2" 
4da9						CALLMONITOR 
4da9					endif 
4da9			 
4da9					; set default SPI clk pulse time as 10ms for CARTDEV use 
4da9			 
4da9					ld a, $0a 
4da9					ld (spi_clktime), a 
4da9					NEXTW 
4da9			endif 
4da9			 
4da9			.ENDDEVICE: 
4da9			; eof 
4da9			 
# End of file forth_words_device.asm
4da9			 
4da9			; var handler 
4da9			 
4da9			 
4da9			.VARS: 
4da9				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4da9 77				db WORD_SYS_CORE+99             
4daa 5a 4e			dw .V0            
4dac 04				db 3 + 1 
4dad .. 00			db "VAR",0              
4db1				endm 
# End of macro CWHEAD
4db1			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4db1			;| 
4db1			;| The variable name should consist of a single letter. e.g. "a" 
4db1			;! If a full string is passed then only the first char is looked at 
4db1			;| Any other char could exceed bounds checks!  
4db1			 
4db1					if DEBUG_FORTH_WORDS_KEY 
4db1						DMARK "VAR" 
4db1 f5				push af  
4db2 3a c6 4d			ld a, (.dmark)  
4db5 32 6b ee			ld (debug_mark),a  
4db8 3a c7 4d			ld a, (.dmark+1)  
4dbb 32 6c ee			ld (debug_mark+1),a  
4dbe 3a c8 4d			ld a, (.dmark+2)  
4dc1 32 6d ee			ld (debug_mark+2),a  
4dc4 18 03			jr .pastdmark  
4dc6 ..			.dmark: db "VAR"  
4dc9 f1			.pastdmark: pop af  
4dca			endm  
# End of macro DMARK
4dca						CALLMONITOR 
4dca cd 6f ee			call debug_vector  
4dcd				endm  
# End of macro CALLMONITOR
4dcd					endif 
4dcd			 
4dcd					FORTH_DSP_VALUEHL 
4dcd cd 61 20			call macro_dsp_valuehl 
4dd0				endm 
# End of macro FORTH_DSP_VALUEHL
4dd0			 
4dd0 7e					ld a, (hl)    ; get first char on of the string 
4dd1			 
4dd1			 
4dd1					if DEBUG_FORTH_WORDS 
4dd1						DMARK "VR1" 
4dd1 f5				push af  
4dd2 3a e6 4d			ld a, (.dmark)  
4dd5 32 6b ee			ld (debug_mark),a  
4dd8 3a e7 4d			ld a, (.dmark+1)  
4ddb 32 6c ee			ld (debug_mark+1),a  
4dde 3a e8 4d			ld a, (.dmark+2)  
4de1 32 6d ee			ld (debug_mark+2),a  
4de4 18 03			jr .pastdmark  
4de6 ..			.dmark: db "VR1"  
4de9 f1			.pastdmark: pop af  
4dea			endm  
# End of macro DMARK
4dea						CALLMONITOR 
4dea cd 6f ee			call debug_vector  
4ded				endm  
# End of macro CALLMONITOR
4ded					endif 
4ded					 
4ded f5					push af	 
4dee					FORTH_DSP_POP 
4dee cd 19 21			call macro_forth_dsp_pop 
4df1				endm 
# End of macro FORTH_DSP_POP
4df1 f1					pop af 
4df2			 
4df2					; convert to upper 
4df2			 
4df2 cd 6b 13				call to_upper 
4df5					if DEBUG_FORTH_WORDS 
4df5						DMARK "Vaa" 
4df5 f5				push af  
4df6 3a 0a 4e			ld a, (.dmark)  
4df9 32 6b ee			ld (debug_mark),a  
4dfc 3a 0b 4e			ld a, (.dmark+1)  
4dff 32 6c ee			ld (debug_mark+1),a  
4e02 3a 0c 4e			ld a, (.dmark+2)  
4e05 32 6d ee			ld (debug_mark+2),a  
4e08 18 03			jr .pastdmark  
4e0a ..			.dmark: db "Vaa"  
4e0d f1			.pastdmark: pop af  
4e0e			endm  
# End of macro DMARK
4e0e						CALLMONITOR 
4e0e cd 6f ee			call debug_vector  
4e11				endm  
# End of macro CALLMONITOR
4e11					endif 
4e11 06 41				ld b, 'A' 
4e13 90					sub b			; set offset 
4e14					if DEBUG_FORTH_WORDS 
4e14						DMARK "Vbb" 
4e14 f5				push af  
4e15 3a 29 4e			ld a, (.dmark)  
4e18 32 6b ee			ld (debug_mark),a  
4e1b 3a 2a 4e			ld a, (.dmark+1)  
4e1e 32 6c ee			ld (debug_mark+1),a  
4e21 3a 2b 4e			ld a, (.dmark+2)  
4e24 32 6d ee			ld (debug_mark+2),a  
4e27 18 03			jr .pastdmark  
4e29 ..			.dmark: db "Vbb"  
4e2c f1			.pastdmark: pop af  
4e2d			endm  
# End of macro DMARK
4e2d						CALLMONITOR 
4e2d cd 6f ee			call debug_vector  
4e30				endm  
# End of macro CALLMONITOR
4e30					endif 
4e30 cb 27				sla a  
4e32				 
4e32					 
4e32					if DEBUG_FORTH_WORDS 
4e32						DMARK "VR2" 
4e32 f5				push af  
4e33 3a 47 4e			ld a, (.dmark)  
4e36 32 6b ee			ld (debug_mark),a  
4e39 3a 48 4e			ld a, (.dmark+1)  
4e3c 32 6c ee			ld (debug_mark+1),a  
4e3f 3a 49 4e			ld a, (.dmark+2)  
4e42 32 6d ee			ld (debug_mark+2),a  
4e45 18 03			jr .pastdmark  
4e47 ..			.dmark: db "VR2"  
4e4a f1			.pastdmark: pop af  
4e4b			endm  
# End of macro DMARK
4e4b						CALLMONITOR 
4e4b cd 6f ee			call debug_vector  
4e4e				endm  
# End of macro CALLMONITOR
4e4e					endif 
4e4e			 
4e4e 21 f4 e9				ld hl, cli_var_array2 
4e51 cd e6 0d				call addatohl 
4e54 cd 6a 1e				call forth_push_numhl 
4e57			 
4e57			 
4e57				       NEXTW 
4e57 c3 17 22			jp macro_next 
4e5a				endm 
# End of macro NEXTW
4e5a			.V0: 
4e5a				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4e5a 78				db WORD_SYS_CORE+100             
4e5b 72 4e			dw .V0Q            
4e5d 04				db 3 + 1 
4e5e .. 00			db "V0!",0              
4e62				endm 
# End of macro CWHEAD
4e62			;| V0! ( u1 -- )  Store value to v0  | DONE 
4e62			 
4e62					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e62 cd 61 20			call macro_dsp_valuehl 
4e65				endm 
# End of macro FORTH_DSP_VALUEHL
4e65			 
4e65 11 28 ea				ld de, cli_var_array 
4e68			 
4e68 eb					ex de, hl 
4e69 73					ld (hl), e 
4e6a 23					inc hl 
4e6b 72					ld (hl), d 
4e6c			 
4e6c					; destroy value TOS 
4e6c			 
4e6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e6c cd 19 21			call macro_forth_dsp_pop 
4e6f				endm 
# End of macro FORTH_DSP_POP
4e6f			 
4e6f				       NEXTW 
4e6f c3 17 22			jp macro_next 
4e72				endm 
# End of macro NEXTW
4e72			.V0Q: 
4e72				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4e72 79				db WORD_SYS_CORE+101             
4e73 83 4e			dw .V1S            
4e75 04				db 3 + 1 
4e76 .. 00			db "V0@",0              
4e7a				endm 
# End of macro CWHEAD
4e7a			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4e7a 2a 28 ea				ld hl, (cli_var_array) 
4e7d cd 6a 1e				call forth_push_numhl 
4e80			 
4e80				       NEXTW 
4e80 c3 17 22			jp macro_next 
4e83				endm 
# End of macro NEXTW
4e83			.V1S: 
4e83				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4e83 7a				db WORD_SYS_CORE+102             
4e84 9b 4e			dw .V1Q            
4e86 04				db 3 + 1 
4e87 .. 00			db "V1!",0              
4e8b				endm 
# End of macro CWHEAD
4e8b			;| V1! ( u1 -- )  Store value to v1 | DONE 
4e8b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e8b cd 61 20			call macro_dsp_valuehl 
4e8e				endm 
# End of macro FORTH_DSP_VALUEHL
4e8e			 
4e8e 11 2a ea				ld de, cli_var_array+2 
4e91				 
4e91 eb					ex de, hl 
4e92 73					ld (hl), e 
4e93 23					inc hl 
4e94 72					ld (hl), d 
4e95			 
4e95					; destroy value TOS 
4e95			 
4e95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e95 cd 19 21			call macro_forth_dsp_pop 
4e98				endm 
# End of macro FORTH_DSP_POP
4e98				       NEXTW 
4e98 c3 17 22			jp macro_next 
4e9b				endm 
# End of macro NEXTW
4e9b			.V1Q: 
4e9b				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4e9b 7b				db WORD_SYS_CORE+103             
4e9c ac 4e			dw .V2S            
4e9e 04				db 3 + 1 
4e9f .. 00			db "V1@",0              
4ea3				endm 
# End of macro CWHEAD
4ea3			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4ea3 2a 2a ea				ld hl, (cli_var_array+2) 
4ea6 cd 6a 1e				call forth_push_numhl 
4ea9				       NEXTW 
4ea9 c3 17 22			jp macro_next 
4eac				endm 
# End of macro NEXTW
4eac			.V2S: 
4eac				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4eac 7c				db WORD_SYS_CORE+104             
4ead c4 4e			dw .V2Q            
4eaf 04				db 3 + 1 
4eb0 .. 00			db "V2!",0              
4eb4				endm 
# End of macro CWHEAD
4eb4			;| V2! ( u1 -- )  Store value to v2 | DONE 
4eb4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eb4 cd 61 20			call macro_dsp_valuehl 
4eb7				endm 
# End of macro FORTH_DSP_VALUEHL
4eb7			 
4eb7 11 2c ea				ld de, cli_var_array+4 
4eba				 
4eba eb					ex de, hl 
4ebb 73					ld (hl), e 
4ebc 23					inc hl 
4ebd 72					ld (hl), d 
4ebe			 
4ebe					; destroy value TOS 
4ebe			 
4ebe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ebe cd 19 21			call macro_forth_dsp_pop 
4ec1				endm 
# End of macro FORTH_DSP_POP
4ec1				       NEXTW 
4ec1 c3 17 22			jp macro_next 
4ec4				endm 
# End of macro NEXTW
4ec4			.V2Q: 
4ec4				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4ec4 7d				db WORD_SYS_CORE+105             
4ec5 d5 4e			dw .V3S            
4ec7 04				db 3 + 1 
4ec8 .. 00			db "V2@",0              
4ecc				endm 
# End of macro CWHEAD
4ecc			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4ecc 2a 2c ea				ld hl, (cli_var_array+4) 
4ecf cd 6a 1e				call forth_push_numhl 
4ed2				       NEXTW 
4ed2 c3 17 22			jp macro_next 
4ed5				endm 
# End of macro NEXTW
4ed5			.V3S: 
4ed5				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4ed5 7c				db WORD_SYS_CORE+104             
4ed6 ed 4e			dw .V3Q            
4ed8 04				db 3 + 1 
4ed9 .. 00			db "V3!",0              
4edd				endm 
# End of macro CWHEAD
4edd			;| V3! ( u1 -- )  Store value to v3 | DONE 
4edd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4edd cd 61 20			call macro_dsp_valuehl 
4ee0				endm 
# End of macro FORTH_DSP_VALUEHL
4ee0			 
4ee0 11 2e ea				ld de, cli_var_array+6 
4ee3				 
4ee3 eb					ex de, hl 
4ee4 73					ld (hl), e 
4ee5 23					inc hl 
4ee6 72					ld (hl), d 
4ee7			 
4ee7					; destroy value TOS 
4ee7			 
4ee7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ee7 cd 19 21			call macro_forth_dsp_pop 
4eea				endm 
# End of macro FORTH_DSP_POP
4eea				       NEXTW 
4eea c3 17 22			jp macro_next 
4eed				endm 
# End of macro NEXTW
4eed			.V3Q: 
4eed				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4eed 7d				db WORD_SYS_CORE+105             
4eee fe 4e			dw .END            
4ef0 04				db 3 + 1 
4ef1 .. 00			db "V3@",0              
4ef5				endm 
# End of macro CWHEAD
4ef5			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4ef5 2a 2e ea				ld hl, (cli_var_array+6) 
4ef8 cd 6a 1e				call forth_push_numhl 
4efb				       NEXTW 
4efb c3 17 22			jp macro_next 
4efe				endm 
# End of macro NEXTW
4efe			 
4efe			 
4efe			 
4efe			 
4efe			 
4efe			; end of dict marker 
4efe			 
4efe 00			.END:    db WORD_SYS_END 
4eff 00 00			dw 0 
4f01 00				db 0 
4f02			 
4f02			; use to jp here for user dict words to save on macro expansion  
4f02			 
4f02			user_dict_next: 
4f02				NEXTW 
4f02 c3 17 22			jp macro_next 
4f05				endm 
# End of macro NEXTW
4f05			 
4f05			 
4f05			user_exec: 
4f05				;    ld hl, <word code> 
4f05				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4f05				;    call forthexec 
4f05				;    jp user_dict_next   (NEXT) 
4f05			        ;    <word code bytes> 
4f05 eb				ex de, hl 
4f06 2a c2 e5			ld hl,(os_tok_ptr) 
4f09				 
4f09				FORTH_RSP_NEXT 
4f09 cd 11 1e			call macro_forth_rsp_next 
4f0c				endm 
# End of macro FORTH_RSP_NEXT
4f0c			 
4f0c			if DEBUG_FORTH_UWORD 
4f0c						DMARK "UEX" 
4f0c f5				push af  
4f0d 3a 21 4f			ld a, (.dmark)  
4f10 32 6b ee			ld (debug_mark),a  
4f13 3a 22 4f			ld a, (.dmark+1)  
4f16 32 6c ee			ld (debug_mark+1),a  
4f19 3a 23 4f			ld a, (.dmark+2)  
4f1c 32 6d ee			ld (debug_mark+2),a  
4f1f 18 03			jr .pastdmark  
4f21 ..			.dmark: db "UEX"  
4f24 f1			.pastdmark: pop af  
4f25			endm  
# End of macro DMARK
4f25				CALLMONITOR 
4f25 cd 6f ee			call debug_vector  
4f28				endm  
# End of macro CALLMONITOR
4f28			endif 
4f28			 
4f28			 
4f28			 
4f28 eb				ex de, hl 
4f29 22 c2 e5			ld (os_tok_ptr), hl 
4f2c				 
4f2c				; Don't use next - Skips the first word in uword. 
4f2c			 
4f2c c3 a8 22			jp exec1 
4f2f			;	NEXT 
4f2f			 
4f2f			 
4f2f			; eof 
# End of file forth_wordsv4.asm
4f2f			endif 
4f2f			;;;;;;;;;;;;;; Debug code 
4f2f			 
4f2f			 
4f2f			;if DEBUG_FORTH_PARSE 
4f2f .. 00		.nowordfound: db "No match",0 
4f38 .. 00		.compword:	db "Comparing word ",0 
4f48 .. 00		.nextwordat:	db "Next word at",0 
4f55 .. 00		.charmatch:	db "Char match",0 
4f60			;endif 
4f60			if DEBUG_FORTH_JP 
4f60			.foundword:	db "Word match. Exec..",0 
4f60			endif 
4f60			;if DEBUG_FORTH_PUSH 
4f60 .. 00		.enddict:	db "Dict end. Push.",0 
4f70 .. 00		.push_str:	db "Pushing string",0 
4f7f .. 00		.push_num:	db "Pushing number",0 
4f8e .. 00		.data_sp:	db "SP:",0 
4f92 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4fa4 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4fb6 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4fc8			;endif 
4fc8			;if DEBUG_FORTH_MALLOC 
4fc8 .. 00		.push_malloc:	db "Malloc address",0 
4fd7			;endif 
4fd7			 
4fd7			 
4fd7			 
4fd7			; display malloc address and current data stack pointer  
4fd7			 
4fd7			malloc_error: 
4fd7 d5				push de 
4fd8 f5				push af 
4fd9 e5				push hl 
4fda cd b9 0b			call clear_display 
4fdd 11 fd 4f			ld de, .mallocerr 
4fe0 3e 00			ld a,0 
4fe2			;	ld de,os_word_scratch 
4fe2 cd cc 0b			call str_at_display 
4fe5 3e 11			ld a, display_row_1+17 
4fe7 11 6b ee			ld de, debug_mark 
4fea cd cc 0b			call str_at_display 
4fed cd dc 0b			call update_display 
4ff0				;call break_point_state 
4ff0 cd 3e 68			call cin_wait 
4ff3			 
4ff3			;	ld a, ' ' 
4ff3			;	ld (os_view_disable), a 
4ff3 cd 00 18			call bp_on 
4ff6 e1				pop hl 
4ff7 f1				pop af 
4ff8 d1				pop de	 
4ff9				CALLMONITOR 
4ff9 cd 6f ee			call debug_vector  
4ffc				endm  
# End of macro CALLMONITOR
4ffc c9				ret 
4ffd			 
4ffd .. 00		.mallocerr: 	db "Malloc Error",0 
500a			;if DEBUG_FORTH_PUSH 
500a			display_data_sp: 
500a f5				push af 
500b			 
500b				; see if disabled 
500b			 
500b			 
500b 3a 6f ee			ld a, (debug_vector) 
500e fe c9			cp $C9  ; RET 
5010				;ld a, (os_view_disable) 
5010				;cp '*' 
5010 28 67			jr z, .skipdsp 
5012			 
5012 e5				push hl 
5013 e5				push hl 
5014 e5			push hl 
5015 cd b9 0b			call clear_display 
5018 e1			pop hl 
5019 7c				ld a,h 
501a 21 c6 e5			ld hl, os_word_scratch 
501d cd ff 12			call hexout 
5020 e1				pop hl 
5021 7d				ld a,l 
5022 21 c8 e5			ld hl, os_word_scratch+2 
5025 cd ff 12			call hexout 
5028 21 ca e5			ld hl, os_word_scratch+4 
502b 3e 00			ld a,0 
502d 77				ld (hl),a 
502e 11 c6 e5			ld de,os_word_scratch 
5031 3e 28				ld a, display_row_2 
5033 cd cc 0b				call str_at_display 
5036 11 92 4f			ld de, .wordinhl 
5039 3e 00			ld a, display_row_1 
503b			 
503b cd cc 0b				call str_at_display 
503e 11 6b ee			ld de, debug_mark 
5041 3e 11			ld a, display_row_1+17 
5043			 
5043 cd cc 0b				call str_at_display 
5046			 
5046				; display current data stack pointer 
5046 11 8e 4f			ld de,.data_sp 
5049 3e 30				ld a, display_row_2 + 8 
504b cd cc 0b				call str_at_display 
504e			 
504e 2a ee e9			ld hl,(cli_data_sp) 
5051 e5				push hl 
5052 7c				ld a,h 
5053 21 c6 e5			ld hl, os_word_scratch 
5056 cd ff 12			call hexout 
5059 e1				pop hl 
505a 7d				ld a,l 
505b 21 c8 e5			ld hl, os_word_scratch+2 
505e cd ff 12			call hexout 
5061 21 ca e5			ld hl, os_word_scratch+4 
5064 3e 00			ld a,0 
5066 77				ld (hl),a 
5067 11 c6 e5			ld de,os_word_scratch 
506a 3e 33				ld a, display_row_2 + 11 
506c cd cc 0b				call str_at_display 
506f			 
506f			 
506f cd dc 0b			call update_display 
5072 cd f1 0a			call delay1s 
5075 cd f1 0a			call delay1s 
5078 e1				pop hl 
5079			.skipdsp: 
5079 f1				pop af 
507a c9				ret 
507b			 
507b			display_data_malloc: 
507b			 
507b f5				push af 
507c e5				push hl 
507d e5				push hl 
507e e5			push hl 
507f cd b9 0b			call clear_display 
5082 e1			pop hl 
5083 7c				ld a,h 
5084 21 c6 e5			ld hl, os_word_scratch 
5087 cd ff 12			call hexout 
508a e1				pop hl 
508b 7d				ld a,l 
508c 21 c8 e5			ld hl, os_word_scratch+2 
508f cd ff 12			call hexout 
5092 21 ca e5			ld hl, os_word_scratch+4 
5095 3e 00			ld a,0 
5097 77				ld (hl),a 
5098 11 c6 e5			ld de,os_word_scratch 
509b 3e 28				ld a, display_row_2 
509d cd cc 0b				call str_at_display 
50a0 11 c8 4f			ld de, .push_malloc 
50a3 3e 00			ld a, display_row_1 
50a5			 
50a5 cd cc 0b				call str_at_display 
50a8			 
50a8				; display current data stack pointer 
50a8 11 8e 4f			ld de,.data_sp 
50ab 3e 30				ld a, display_row_2 + 8 
50ad cd cc 0b				call str_at_display 
50b0			 
50b0 2a ee e9			ld hl,(cli_data_sp) 
50b3 e5				push hl 
50b4 7c				ld a,h 
50b5 21 c6 e5			ld hl, os_word_scratch 
50b8 cd ff 12			call hexout 
50bb e1				pop hl 
50bc 7d				ld a,l 
50bd 21 c8 e5			ld hl, os_word_scratch+2 
50c0 cd ff 12			call hexout 
50c3 21 ca e5			ld hl, os_word_scratch+4 
50c6 3e 00			ld a,0 
50c8 77				ld (hl),a 
50c9 11 c6 e5			ld de,os_word_scratch 
50cc 3e 33				ld a, display_row_2 + 11 
50ce cd cc 0b				call str_at_display 
50d1			 
50d1 cd dc 0b			call update_display 
50d4 cd f1 0a			call delay1s 
50d7 cd f1 0a			call delay1s 
50da e1				pop hl 
50db f1				pop af 
50dc c9				ret 
50dd			;endif 
50dd			 
50dd			include "forth_autostart.asm" 
50dd			; list of commands to perform at system start up 
50dd			 
50dd			startcmds: 
50dd			;	dw test11 
50dd			;	dw test12 
50dd			;	dw test13 
50dd			;	dw test14 
50dd			;	dw test15 
50dd			;	dw test16 
50dd			;	dw test17 
50dd			;	dw ifthtest1 
50dd			;	dw ifthtest2 
50dd			;	dw ifthtest3 
50dd			;	dw mmtest1 
50dd			;	dw mmtest2 
50dd			;	dw mmtest3 
50dd			;	dw mmtest4 
50dd			;	dw mmtest5 
50dd			;	dw mmtest6 
50dd			;	dw iftest1 
50dd			;	dw iftest2 
50dd			;	dw iftest3 
50dd			;	dw looptest1 
50dd			;	dw looptest2 
50dd			;	dw test1 
50dd			;	dw test2 
50dd			;	dw test3 
50dd			;	dw test4 
50dd			;	dw game2r 
50dd			;	dw game2b1 
50dd			;	dw game2b2 
50dd			 
50dd				; start up words that are actually useful 
50dd			 
50dd			;    dw spi1 
50dd			;    dw spi2 
50dd			;    dw spi3 
50dd			;    dw spi4 
50dd			;    dw spi5 
50dd			;    dw spi6 
50dd			;    dw spi7 
50dd			; 
50dd			;    dw spi8 
50dd			;    dw spi9 
50dd			;    dw spi10 
50dd			 
50dd			; file editor 
50dd			;	dw edit1 
50dd			;	dw edit2 
50dd			;	dw edit3 
50dd			 
50dd			;	dw longread 
50dd 07 55			dw clrstack 
50df 3b 55			dw type 
50e1			;	dw stest 
50e1 60 55			dw strncpy 
50e3			;	dw list 
50e3 c1 55			dw start1 
50e5 d1 55			dw start2 
50e7			;	dw start3 
50e7			;	dw start3b 
50e7			;	dw start3c 
50e7			 
50e7				; (unit) testing words 
50e7			 
50e7			;	dw mtesta 
50e7			;	dw mtestb 
50e7			;	dw mtestc 
50e7			;	dw mtestd 
50e7			;	dw mteste 
50e7			 
50e7				; demo/game words 
50e7			 
50e7			;        dw game3w 
50e7			;        dw game3p 
50e7			;        dw game3sc 
50e7			;        dw game3vsi 
50e7			;        dw game3vs 
50e7				 
50e7 2a 60			dw game2b 
50e9 98 60			dw game2bf 
50eb e2 60			dw game2mba 
50ed 78 61			dw game2mbas 
50ef ba 61			dw game2mb 
50f1			 
50f1 eb 5c			dw game1 
50f3 fc 5c			dw game1a 
50f5 5e 5d			dw game1b 
50f7 93 5d			dw game1c 
50f9 c9 5d			dw game1d 
50fb fa 5d			dw game1s 
50fd 0e 5e			dw game1t 
50ff 23 5e			dw game1f 
5101 57 5e			dw game1z 
5103 9b 5e			dw game1zz 
5105			 
5105 05 5b			dw test5 
5107 3d 5b			dw test6 
5109 75 5b			dw test7 
510b 89 5b			dw test8 
510d b5 5b			dw test9 
510f cb 5b			dw test10 
5111				 
5111 72 5f		        dw ssv5 
5113 56 5f		        dw ssv4 
5115 3a 5f		        dw ssv3 
5117 04 5f		        dw ssv2 
5119 8b 5f		        dw ssv1 
511b d3 5f		        dw ssv1cpm 
511d			;	dw keyup 
511d			;	dw keydown 
511d			;	dw keyleft 
511d			;	dw keyright 
511d			;	dw 	keyf1 
511d			;	dw keyf2 
511d			;	dw keyf3 
511d			;	dw keyf4 
511d			;	dw keyf5 
511d			;	dw keyf6 
511d			;	dw keyf7 
511d			;	dw keyf8 
511d			;	dw keyf9 
511d			;	dw keyf10 
511d			;	dw keyf11 
511d			;	dw keyf12 
511d			;	dw keytab 
511d			;	dw keycr 
511d			;	dw keyhome 
511d			;	dw keyend 
511d			;	dw keybs 
511d 00 00			db 0, 0	 
511f			 
511f			 
511f			; File Editor 
511f			 
511f			; ( id - ) use 'e' to edit the displayed line 
511f .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5140 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5175			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5175 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
51ad			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
51ad			 
51ad			; SPI Net support words 
51ad			 
51ad			; v0! = node to send to 
51ad			; ( str count - ) 
51ad .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5206			 
5206			; spiputc ( char node - ) 
5206 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
523a			; spiputc ( u node - ) 
523a .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
5268			 
5268			; spigetc ( - n ) 
5268 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
5291			 
5291			; getnode ( - n ) 
5291 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
52be			 
52be			; ( str node - )  
52be .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5324			; store string ( str i - ) 
5324			 
5324			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5324 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5379			 
5379			; get string ( addr i -  )    TO FIX 
5379			 
5379 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
53d1			 
53d1			 
53d1			; NETCHAT (TODO) 
53d1			; Program to allow two nodes to chat with eachother 
53d1			; 
53d1			; v0 - target node 
53d1			;  
53d1			; accept input at 0,0 
53d1			; if input is string send spitype to target node 
53d1			; starting at row 2,0 , while spigetchr is not zero ->  
53d1			; 
53d1			; 
53d1			; TODO add paging of get request 
53d1			 
53d1			; ( node - ) 
53d1 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
53f0 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5448 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
54c0			 
54c0			 
54c0			; Long read of currently open file 
54c0 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5507			 
5507			; clear stack  
5507			 
5507 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
553b			 
553b			; type ( addr count - ) 
553b .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
5560			 
5560			; some direct memory words 
5560			; strncpy ( len t f -- t ) 
5560			 
5560 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
55c1			 
55c1 .. 00		start1:     	db ": bpon $00 bp ;",0 
55d1 .. 00		start2:     	db ": bpoff $01 bp ;",0 
55e2 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
565d .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
56bd			 
56bd			 
56bd			; a handy word to list items on the stack 
56bd			 
56bd .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5727			 
5727			 
5727			; test stack  
5727			; rnd8 stest 
5727			 
5727 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
579e			 
579e			; random malloc and free cycles 
579e			 
579e .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5853			 
5853			; fixed malloc and free cycles 
5853			 
5853 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
58f6			 
58f6			; fixed double string push and drop cycle  
58f6			 
58f6 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
59ab			 
59ab			; consistent fixed string push and drop cycle  
59ab			 
59ab .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5a4f			 
5a4f .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5b05			 
5b05			;test1:		db ": aa 1 2 3 ;", 0 
5b05			;test2:     	db "111 aa 888 999",0 
5b05			;test3:     	db ": bb 77 ;",0 
5b05			;test4:     	db "$02 $01 do i . loop bb",0 
5b05			 
5b05 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5b3d .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5b75 .. 00		test7:     	db ": box hline vline ;",0 
5b89 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5bb5 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5bcb .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5bf0 .. 00		test11:     	db "hello create .",0 
5bff .. 00		test12:     	db "hello2 create .",0 
5c0f			 
5c0f			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5c0f			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5c0f			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5c0f			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5c0f			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5c0f			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5c0f			 
5c0f			;iftest1:     	db "$0001 IF cls .",0 
5c0f			;iftest2:     	db "$0000 IF cls .",0 
5c0f			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5c0f			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5c0f			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5c0f			 
5c0f			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c0f			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c0f			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c0f			 
5c0f			 
5c0f .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5c33 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5c63 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5c88 .. 00		sound4: db ": cha $00 ; ",0 
5c95 .. 00		sound5: db ": chb $20 ; ",0 
5ca2 .. 00		sound6: db ": chc $40 ; ",0 
5caf .. 00		sound7: db ": chd $60 ; ",0 
5cbc .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5cd4 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5ceb			 
5ceb			 
5ceb			 
5ceb			 
5ceb			; a small guess the number game 
5ceb			 
5ceb .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5cfc .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5d5e			 
5d5e .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5d93 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5dc9 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5dfa .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5e0e .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5e23 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5e57 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5e9b			 
5e9b			; Using 'ga' save a high score across multiple runs using external storage 
5e9b			 
5e9b .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5f04			 
5f04			 
5f04			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5f04			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5f04			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5f04			 
5f04			; simple screen saver to test code memory reuse to destruction 
5f04			 
5f04 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5f3a .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5f56 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5f72 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5f8b .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5fd3 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
602a			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
602a			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
602a			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
602a			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
602a			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
602a			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
602a			 
602a			 
602a			 
602a			; minesweeper/battleship finding game 
602a			; draws a game board of random ship/mine positions 
602a			; user enters coords to see if it hits on 
602a			; game ends when all are hit 
602a			; when hit or miss says how many may be in the area 
602a			 
602a			; setup the game board and then hide it 
602a .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6098 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
60e2			; prompt for where to target 
60e2 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6178 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
619d			; TODO see if the entered coords hits or misses pushes char hit of miss 
619d .. 00		game2mbht:      db ": mbckht nop ;",0 
61ac .. 00		game2mbms:      db ": mbcms nop ;",0 
61ba			; TODO how many might be near by 
61ba .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6237			 
6237			; Game 3 
6237			 
6237			; Vert scroller ski game - avoid the trees! 
6237			 
6237			; v0 score (ie turns) 
6237			; v1 player pos 
6237			; v2 left wall 
6237			; v3 right wall 
6237			 
6237			; Draw side walls randomly 
6237			 
6237 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6265			 
6265			; Draw player 
6265 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6283			 
6283			; TODO Get Key 
6283			 
6283			; TODO Move left right 
6283			 
6283			; scroll and move walls a bit 
6283			 
6283 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
62b4			 
62b4			; main game loop 
62b4			 
62b4 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
62e0 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
631f			 
631f			; key board defs 
631f			 
631f .. 00		keyup:       db ": keyup $05 ;",0 
632d .. 00		keydown:       db ": keydown $0a ;",0 
633d .. 00		keyleft:       db ": keyleft $0b ;",0 
634d .. 00		keyright:       db ": keyright $0c ;",0 
635e .. 00		keyf1:       db ": keyf1 $10 ;",0 
636c .. 00		keyf2:       db ": keyf2 $11 ;",0 
637a .. 00		keyf3:       db ": keyf3 $12 ;",0 
6388 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6396 .. 00		keyf5:       db ": keyf5 $14 ;",0 
63a4 .. 00		keyf6:       db ": keyf6 $15 ;",0 
63b2 .. 00		keyf7:       db ": keyf7 $16 ;",0 
63c0 .. 00		keyf8:       db ": keyf8 $17 ;",0 
63ce .. 00		keyf9:       db ": keyf9 $18 ;",0 
63dc .. 00		keyf10:       db ": keyf10 $19 ;",0 
63eb .. 00		keyf11:       db ": keyf11 $1a ;",0 
63fa .. 00		keyf12:       db ": keyf12 $1b ;",0 
6409			 
6409 .. 00		keytab:       db ": keytab $09 ;",0 
6418 .. 00		keycr:       db ": keycr $0d ;",0 
6426 .. 00		keyhome:       db ": keyhome $0e ;",0 
6436 .. 00		keyend:       db ": keyend $0f ;",0 
6445 .. 00		keybs:       db ": keybs $08 ;",0 
6453			 
6453			   
6453			 
6453			 
6453			 
6453			; eof 
# End of file forth_autostart.asm
6453			 
6453			 
6453			 
6453			; stack over and underflow checks 
6453			 
6453			; init the words to detect the under/overflow 
6453			 
6453			chk_stk_init: 
6453				; a vague random number to check so we dont get any "lucky" hits 
6453 3e 2d			ld a, 45 
6455 6f				ld l, a 
6456 00				nop 
6457 3e 17			ld a, 23 
6459 67				ld h, a 
645a			 
645a 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
645d			 
645d			;	ld (chk_stund), hl	; stack points.... 
645d 22 00 ef			ld (chk_stovr), hl 
6460 22 ec e9			ld (chk_ret_und), hl 
6463 22 aa e9			ld (chk_ret_ovr), hl 
6466 22 28 e9			ld (chk_loop_ovr), hl 
6469 22 26 e8			ld (chk_data_ovr), hl 
646c c9				ret 
646d				 
646d			check_stacks: 
646d				; check all stack words 
646d			 
646d e5				push hl 
646e d5				push de 
646f			 
646f			;	ld de,(chk_word) 
646f			;	ld hl, (chk_stund)	; stack points.... 
646f			;	if DEBUG_STK_FAULT 
646f			;		DMARK "FAa" 
646f			;		CALLMONITOR 
646f			;	endif 
646f			;	call cmp16 
646f			;	jp z, .chk_faulta 
646f			; 
646f			;	ld de, sfaultsu 
646f			;	jp .chk_fault 
646f			 
646f 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
6472 ed 5b 9d e2		ld de,(chk_word) 
6476				if DEBUG_STK_FAULT 
6476					DMARK "FAb" 
6476					CALLMONITOR 
6476				endif 
6476 cd 04 0e			call cmp16 
6479 28 06			jr z, .chk_fault1 
647b 11 1c 65			ld de, sfaultso 
647e c3 d0 64			jp .chk_fault 
6481			.chk_fault1:  
6481 2a ec e9			ld hl, (chk_ret_und) 
6484 ed 5b 9d e2		ld de,(chk_word) 
6488				if DEBUG_STK_FAULT 
6488					DMARK "FAU" 
6488					CALLMONITOR 
6488				endif 
6488 cd 04 0e			call cmp16 
648b ca 94 64			jp z, .chk_fault2 
648e 11 2c 65			ld de, sfaultru 
6491 c3 d0 64			jp .chk_fault 
6494			.chk_fault2:  
6494 2a aa e9			ld hl, (chk_ret_ovr) 
6497 ed 5b 9d e2		ld de,(chk_word) 
649b				if DEBUG_STK_FAULT 
649b					DMARK "FA1" 
649b					CALLMONITOR 
649b				endif 
649b cd 04 0e			call cmp16 
649e ca a7 64			jp z, .chk_fault3 
64a1 11 3a 65			ld de, sfaultro 
64a4 c3 d0 64			jp .chk_fault 
64a7			.chk_fault3:  
64a7 2a 28 e9			ld hl, (chk_loop_ovr) 
64aa ed 5b 9d e2		ld de,(chk_word) 
64ae				if DEBUG_STK_FAULT 
64ae					DMARK "FA2" 
64ae					CALLMONITOR 
64ae				endif 
64ae cd 04 0e			call cmp16 
64b1 ca ba 64			jp z, .chk_fault4 
64b4 11 54 65			ld de, sfaultlo 
64b7 c3 d0 64			jp .chk_fault 
64ba			.chk_fault4:  
64ba 2a 26 e8			ld hl, (chk_data_ovr) 
64bd ed 5b 9d e2		ld de,(chk_word) 
64c1				if DEBUG_STK_FAULT 
64c1					DMARK "FA3" 
64c1					CALLMONITOR 
64c1				endif 
64c1 cd 04 0e			call cmp16 
64c4 ca cd 64			jp z, .chk_fault5 
64c7 11 6e 65			ld de, sfaultdo 
64ca c3 d0 64			jp .chk_fault 
64cd			 
64cd			 
64cd			.chk_fault5:  
64cd d1				pop de 
64ce e1				pop hl 
64cf			 
64cf c9				ret 
64d0			 
64d0 cd b9 0b		.chk_fault: 	call clear_display 
64d3 3e 28				ld a, display_row_2 
64d5 cd cc 0b				call str_at_display 
64d8 11 fe 64				   ld de, .stackfault 
64db 3e 00				ld a, display_row_1 
64dd cd cc 0b				call str_at_display 
64e0 11 6b ee				    ld de, debug_mark 
64e3 3e 11				ld a, display_row_1+17 
64e5 cd cc 0b				call str_at_display 
64e8 cd dc 0b				call update_display 
64eb			 
64eb				; prompt before entering montior for investigating issue 
64eb			 
64eb 3e 78			ld a, display_row_4 
64ed 11 5c 1b			ld de, endprog 
64f0			 
64f0 cd dc 0b			call update_display		 
64f3			 
64f3 cd e2 1d			call next_page_prompt 
64f6			 
64f6 d1				pop de 
64f7 e1				pop hl 
64f8 cd b0 1b				call monitor 
64fb c3 b9 1a				jp warmstart 
64fe					;jp 0 
64fe					;halt 
64fe			 
64fe			 
64fe			 
64fe .. 00		.stackfault: 	db "Stack fault:",0 
650b			 
650b .. 00		sfaultsu: 	db	"Stack under flow",0 
651c .. 00		sfaultso: 	db	"Stack over flow",0 
652c .. 00		sfaultru:	db "RTS underflow",0 
653a .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6554 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
656e .. 00		sfaultdo:	db "DTS overflow", 0 
657b			 
657b			 
657b			fault_dsp_under: 
657b 11 8d 65			ld de, .dsp_under 
657e c3 3d 66			jp .show_fault 
6581			 
6581			fault_rsp_under: 
6581 11 9b 65			ld de, .rsp_under 
6584 c3 3d 66			jp .show_fault 
6587			fault_loop_under: 
6587 11 a9 65			ld de, .loop_under 
658a c3 3d 66			jp .show_fault 
658d			 
658d .. 00		.dsp_under: db "DSP Underflow",0 
659b .. 00		.rsp_under: db "RSP Underflow",0 
65a9 .. 00		.loop_under: db "LOOP Underflow",0 
65b8			 
65b8			 
65b8 d5			type_faultn: 	push de 
65b9 e5					push hl 
65ba cd b9 0b				call clear_display 
65bd 11 e4 65				   ld de, .typefaultn 
65c0 3e 00				ld a, display_row_1 
65c2 cd cc 0b				call str_at_display 
65c5 11 6b ee				    ld de, debug_mark 
65c8 3e 11				ld a, display_row_1+17 
65ca cd cc 0b				call str_at_display 
65cd cd dc 0b				call update_display 
65d0			 
65d0				; prompt before entering montior for investigating issue 
65d0			 
65d0 3e 78			ld a, display_row_4 
65d2 11 5c 1b			ld de, endprog 
65d5			 
65d5 cd dc 0b			call update_display		 
65d8			 
65d8 cd e2 1d			call next_page_prompt 
65db			 
65db e5					push hl 
65dc d5					push de 
65dd cd b0 1b				call monitor 
65e0 c3 b9 1a				jp warmstart 
65e3 76					halt 
65e4			 
65e4			 
65e4 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
65fb			 
65fb d5			type_faults: 	push de 
65fc e5					push hl 
65fd cd b9 0b				call clear_display 
6600 11 26 66				   ld de, .typefaults 
6603 3e 00				ld a, display_row_1 
6605 cd cc 0b				call str_at_display 
6608 11 6b ee				    ld de, debug_mark 
660b 3e 11				ld a, display_row_1+17 
660d cd cc 0b				call str_at_display 
6610 cd dc 0b				call update_display 
6613			 
6613				; prompt before entering montior for investigating issue 
6613			 
6613 3e 78			ld a, display_row_4 
6615 11 5c 1b			ld de, endprog 
6618			 
6618 cd dc 0b			call update_display		 
661b			 
661b cd e2 1d			call next_page_prompt 
661e			 
661e e1					pop hl 
661f d1					pop de 
6620 cd b0 1b				call monitor 
6623 c3 b9 1a				jp warmstart 
6626			 
6626			 
6626 .. 00		.typefaults: db "STR Type Expected TOS!",0 
663d			 
663d			.show_fault: 	 
663d d5					push de 
663e cd b9 0b				call clear_display 
6641 d1					pop de 
6642 3e 00				ld a, display_row_1 
6644 cd cc 0b				call str_at_display 
6647 11 6b ee				    ld de, debug_mark 
664a 3e 11				ld a, display_row_1+17 
664c cd cc 0b				call str_at_display 
664f cd dc 0b				call update_display 
6652			 
6652				; prompt before entering montior for investigating issue 
6652			 
6652 3e 78			ld a, display_row_4 
6654 11 5c 1b			ld de, endprog 
6657			 
6657 cd dc 0b			call update_display		 
665a			 
665a cd e2 1d			call next_page_prompt 
665d			 
665d e1					pop hl 
665e d1					pop de 
665f cd b0 1b				call monitor 
6662			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6662			; TODO Make optional fault restart to cli or warm boot? 
6662					;jp warmstart 
6662 c3 03 1b				jp cli 
6665 76					halt 
6666			 
6666			; handle the auto run of code from files in storage 
6666			 
6666			 
6666			include "forth_startup.asm" 
6666			; Which startup method to use? 
6666			; 
6666			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6666			; followed by loading of a list of scripts in eeprom 
6666			 
6666			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6666			; from eeprom 
6666			 
6666			; Select with define in main stubs 
6666			 
6666			if STARTUP_V1 
6666				include "forth_startupv1.asm" 
6666			; Startup script loading version 1 
6666			 
6666			; If SE storage is available first stage is to use the selected file 
6666			; then go through the eeprom list 
6666			 
6666 .. 00		sprompt1: db "Startup load...",0 
6676 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
668c			 
668c			 
668c			 
668c			 
668c			forth_startup: 
668c 21 dd 50			ld hl, startcmds 
668f 3e 00			ld a, 0 
6691 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6694			 
6694 e5			.start1:	push hl 
6695 cd b9 0b			call clear_display 
6698 11 66 66			ld de, sprompt1 
669b 3e 00		        ld a, display_row_1 
669d cd cc 0b			call str_at_display 
66a0 11 76 66			ld de, sprompt2 
66a3 3e 28		        ld a, display_row_2 
66a5 cd cc 0b			call str_at_display 
66a8 e1				pop hl 
66a9 e5				push hl 
66aa 5e				ld e,(hl) 
66ab 23				inc hl 
66ac 56				ld d,(hl) 
66ad 3e 50		        ld a, display_row_3 
66af cd cc 0b			call str_at_display 
66b2 cd dc 0b			call update_display 
66b5			 
66b5			 
66b5 3a e7 e6			ld a, (os_last_cmd) 
66b8 fe 00			cp 0 
66ba 28 05			jr z, .startprompt 
66bc cd e5 0a			call delay250ms 
66bf 18 24			jr .startdo 
66c1				 
66c1				 
66c1			 
66c1			.startprompt: 
66c1			 
66c1 3e 9f			ld a,display_row_4 + display_cols - 1 
66c3 11 e0 1d		        ld de, endprg 
66c6 cd cc 0b			call str_at_display 
66c9 cd dc 0b			call update_display 
66cc cd f1 0a			call delay1s 
66cf cd 3e 68			call cin_wait 
66d2						 
66d2 fe 2a			cp '*' 
66d4 28 5e			jr z, .startupend1 
66d6 fe 23			cp '#' 
66d8 20 07			jr nz, .startno 
66da 3e 01			ld a, 1 
66dc 32 e7 e6			ld (os_last_cmd),a 
66df 18 04			jr .startdo 
66e1 fe 31		.startno:	cp '1' 
66e3 28 3a			jr z,.startnxt  
66e5			 
66e5				; exec startup line 
66e5			.startdo:	 
66e5 e1				pop hl 
66e6 e5				push hl 
66e7				 
66e7 5e				ld e,(hl) 
66e8 23				inc hl 
66e9 56				ld d,(hl) 
66ea eb				ex de,hl 
66eb			 
66eb e5				push hl 
66ec			 
66ec 3e 00			ld a, 0 
66ee				;ld a, FORTH_END_BUFFER 
66ee cd 67 14			call strlent 
66f1 23				inc hl   ; include zero term to copy 
66f2 06 00			ld b,0 
66f4 4d				ld c,l 
66f5 e1				pop hl 
66f6 11 c1 e2			ld de, scratch 
66f9 ed b0			ldir 
66fb			 
66fb			 
66fb 21 c1 e2			ld hl, scratch 
66fe cd 65 22			call forthparse 
6701 cd a5 22			call forthexec 
6704 cd b7 21			call forthexec_cleanup 
6707			 
6707 3e 78			ld a, display_row_4 
6709 11 5c 1b			ld de, endprog 
670c			 
670c cd dc 0b			call update_display		 
670f			 
670f 3a e7 e6			ld a, (os_last_cmd) 
6712 fe 00			cp 0 
6714 20 09			jr nz, .startnxt 
6716 cd e2 1d			call next_page_prompt 
6719 cd b9 0b		        call clear_display 
671c cd dc 0b			call update_display		 
671f			 
671f				; move onto next startup line? 
671f			.startnxt: 
671f			 
671f cd e5 0a			call delay250ms 
6722 e1				pop hl 
6723			 
6723 23				inc hl 
6724 23				inc hl 
6725			 
6725 e5				push hl 
6726 5e				ld e, (hl) 
6727 23				inc hl 
6728 56				ld d, (hl) 
6729 e1				pop hl 
672a				; TODO replace 0 test 
672a			 
672a eb				ex de, hl 
672b cd 0f 0e			call ishlzero 
672e			;	ld a,e 
672e			;	add d 
672e			;	cp 0    ; any left to do? 
672e eb				ex de, hl 
672f c2 94 66			jp nz, .start1 
6732 18 01			jr .startupend 
6734			 
6734 e1			.startupend1: pop hl 
6735			.startupend: 
6735			 
6735 cd b9 0b			call clear_display 
6738 cd dc 0b			call update_display 
673b c9				ret 
673c			if STORAGE_SE 
673c			 
673c			sprompt3: db "Loading from start-up file?:",0 
673c			sprompt4: db "(Y=Any key/N=No)",0 
673c			 
673c			 
673c			forth_autoload: 
673c			 
673c				; load block 0 of store 1 
673c				 
673c				ld a, $fe      ; bit 0 clear 
673c				ld (spi_device), a 
673c			 
673c				call storage_get_block_0 
673c			 
673c				ld a, (store_page+STORE_0_AUTOFILE) 
673c			 
673c				cp 0 
673c				ret z     ; auto start not enabled 
673c			 
673c				call clear_display 
673c			 
673c				; set bank 
673c			 
673c					ld a, (store_page+STORE_0_BANKRUN) 
673c					ld (spi_device), a 
673c			 
673c				; get file id to load from and get the file name to display 
673c			 
673c					ld a, (store_page+STORE_0_FILERUN) 
673c			 
673c					ld l, 0 
673c					ld h, a 
673c					ld de, store_page 
673c			 
673c					if DEBUG_FORTH_WORDS 
673c						DMARK "ASp" 
673c						CALLMONITOR 
673c					endif 
673c					call storage_read 
673c			 
673c					if DEBUG_FORTH_WORDS 
673c						DMARK "ASr" 
673c						CALLMONITOR 
673c					endif 
673c			 
673c					call ishlzero 
673c					ret z             ; file not found 
673c			 
673c					ld a, display_row_2 + 10 
673c					ld de, store_page+3 
673c					call str_at_display 
673c				 
673c			; 
673c			 
673c				ld a, display_row_1+5 
673c				ld de, sprompt3 
673c				call str_at_display 
673c				ld a, display_row_3+15 
673c				ld de, sprompt4 
673c				call str_at_display 
673c			 
673c				call update_display 
673c			 
673c				call cin_wait 
673c				cp 'n' 
673c				ret z 
673c				cp 'N' 
673c				ret z 
673c			 
673c				call delay1s 
673c			 
673c				ld a, (store_page+2) 
673c				ld (store_openmaxext), a    ; save count of ext 
673c				ld a, 1  
673c				ld (store_openext), a    ; save count of ext 
673c			 
673c			.autof:  
673c				ld l , a 
673c				 
673c				ld a, (store_page) 
673c				ld h, a	 
673c				ld de, store_page 
673c					if DEBUG_FORTH_WORDS 
673c						DMARK "ASl" 
673c						CALLMONITOR 
673c					endif 
673c					call storage_read 
673c				call ishlzero 
673c				ret z 
673c			;	jr z, .autoend 
673c			 
673c					if DEBUG_FORTH_WORDS 
673c						DMARK "ASc" 
673c						CALLMONITOR 
673c					endif 
673c				ld de, store_page+2 
673c				ld a, display_row_4 
673c				call str_at_display 
673c			 
673c				call update_display 
673c				call delay250ms 
673c			 
673c			 
673c			 
673c				ld hl, store_page+2 
673c				call forthparse 
673c				call forthexec 
673c				call forthexec_cleanup 
673c			 
673c				 
673c				ld a, (store_openext) 
673c				inc a 
673c				ld (store_openext), a    ; save count of ext 
673c			 
673c				jr .autof 
673c			;.autofdone: 
673c			; 
673c			;		if DEBUG_FORTH_WORDS 
673c			;			DMARK "ASx" 
673c			;			CALLMONITOR 
673c			;		endif 
673c			;;	call clear_display 
673c			;	ret 
673c			 
673c			 
673c			 
673c			endif 
# End of file forth_startupv1.asm
673c			endif 
673c			if STARTUP_V2 
673c				include "forth_startupv2.asm" 
673c			endif 
673c			 
# End of file forth_startup.asm
673c			 
673c			; eof 
# End of file forth_kernel.asm
673c			;include "nascombasic.asm" 
673c			 
673c			 
673c			; find out where the code ends if loaded into RAM (for SC114) 
673c			;endofcode:  
673c			;	nop 
673c			 
673c			 
673c			; jump to nmi vector 
673c			 
673c			init_nmi: 
673c 3e c9			ld a, $c9   ; RET 
673e 32 72 ee			ld (nmi_vector), a 
6741 c9				ret 
6742			nmi: 
6742 e5				push hl 
6743 d5				push de 
6744 c5				push bc 
6745 f5				push af 
6746 cd 72 ee			call nmi_vector 
6749 f5				push af 
674a c5				push bc 
674b d5				push de 
674c e5				push hl 
674d ed 4d			reti 
674f			 
674f			 
674f			; eof 
674f			 
# End of file main.asm
674f			;include "firmware_lcd_4x40.asm" 
674f			;;include "firmware_lcd_4x20.asm" 
674f			include "firmware_cpm_display.asm" 
674f			 
674f			; Serial display interface for SC114 
674f			 
674f			 
674f			display_row_1: equ 0 
674f			display_row_2: equ display_row_1+display_cols 
674f			display_row_3: equ display_row_2 + display_cols 
674f			display_row_4: equ display_row_3 + display_cols 
674f			 
674f			kLCDWidth:  EQU display_cols             ;Width in characters 
674f			kLCD_Line1: EQU 0x00  
674f			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
674f			; E1 
674f			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
674f			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
674f			 
674f			lcd_init: 
674f				; no init as handled by the SCM bios 
674f c9				ret 
6750			 
6750			 
6750			; low level functions for direct screen writes 
6750			 
6750			; output char at pos? 
6750			fLCD_Str: 
6750			        ;out (SC114_SIO_1_OUT),a 
6750 c5				push bc 
6751 d5				push de 
6752 5f				ld e, a 
6753			; TODO Replace with CP/M BIOS call 
6753 0e 02			ld c, $02 
6755 cd 05 00			call 5 
6758 d1				pop de 
6759 c1				pop bc 
675a c9				ret 
675b			 
675b			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
675b			fLCD_Pos: 
675b				; use ASCII escape to position 
675b			        ;out (SC114_SIO_1_OUT),a 
675b c5				push bc 
675c d5				push de 
675d 5f				ld e, a 
675e 0e 02			ld c, $02 
6760			; TODO Replace with CP/M BIOS call 
6760 cd 05 00			call 5 
6763 d1				pop de 
6764 c1				pop bc 
6765			 
6765 c9				ret 
6766			 
6766			; output char at pos 
6766			fLCD_Data: 
6766			      ;  out (SC114_SIO_1_OUT),a 
6766 c5				push bc 
6767 d5				push de 
6768 0e 02			ld c, $02 
676a 5f				ld e, a 
676b			; TODO Replace with CP/M BIOS call 
676b cd 05 00			call 5 
676e d1				pop de 
676f c1				pop bc 
6770			 
6770 c9				ret 
6771			 
6771			; ascii cls  
6771			 
6771 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
6775			 
6775 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
678c			;.clscpm: db 3, $3c,"$" 
678c			 
678c			; write the frame buffer given in hl to hardware  
678c			write_display: 
678c			 
678c			API: equ 0 
678c			 
678c			if API 
678c				push bc 
678c				ld b, 4 
678c			 
678c			        ld (display_write_tmp), hl 	  
678c			 
678c				; clear and home cursor 
678c			 
678c				ld c, 9 
678c				ld de, .cls 
678c			; TODO Replace with CP/M BIOS call 
678c				call 5 
678c			 
678c			 
678c			.writeln: 
678c			 
678c				ld de, (display_write_tmp) 
678c				ld c, 6 
678c			; TODO Replace with CP/M BIOS call 
678c				rst $30 
678c				ld c, 7 
678c				rst $30 
678c			 
678c				ld hl, (display_write_tmp) 
678c				ld de, display_cols 
678c				add hl,de 
678c				ld (display_write_tmp),hl 
678c			 
678c				djnz  .writeln 
678c			 
678c				pop bc 
678c			 
678c			 
678c				ret 
678c			endif 
678c e5				push hl 
678d c5				push bc 
678e d5				push de 
678f			 
678f			;	ld c, 2 
678f			;	;ld de, .cls 
678f			;	ld a, 27 
678f			;	rst $30 
678f			;	ld c, 2 
678f			;	;ld de, .cls 
678f			;	ld a, '[' 
678f			;	rst $30 
678f			; 
678f			;	ld c, 2 
678f			;	;ld de, .cls 
678f			;	ld a, 'H' 
678f			;	rst $30 
678f			; 
678f			 
678f			 
678f			; lots of CR/LF 
678f			;	ld c, 9 
678f			;	ld de, .clscpm 
678f			;	call 5 
678f			 
678f			; xterm cls 
678f 0e 02			ld c, 2 
6791 1e 1b			ld e, 27 
6793 cd 05 00			call 5 
6796			; cls causes too much flicker 
6796			;	ld c, 2 
6796			;	ld e, 'c' 
6796			;	call 5 
6796			 
6796			; use xterm home instead 
6796 0e 02			ld c, 2 
6798 1e 5b			ld e, '[' 
679a cd 05 00			call 5 
679d 0e 02			ld c, 2 
679f 1e 48			ld e, 'H' 
67a1 cd 05 00			call 5 
67a4			LLL: equ 0 
67a4			 
67a4			if LLL 
67a4			 
67a4				ld c, 2 
67a4				;ld de, .cls 
67a4				ld e, 27 
67a4			; TODO Replace with CP/M BIOS call 
67a4				call 5 
67a4			 
67a4			 
67a4				ld c, 2 
67a4				;ld de, .cls 
67a4				ld e, '[' 
67a4			; TODO Replace with CP/M BIOS call 
67a4				call 5 
67a4				ld c, 2 
67a4				;ld de, .cls 
67a4				ld e, '2' 
67a4			; TODO Replace with CP/M BIOS call 
67a4				call 5 
67a4				ld c, 2 
67a4				;ld de, .cls 
67a4				ld e, 'J' 
67a4			; TODO Replace with CP/M BIOS call 
67a4				call 5 
67a4			 
67a4			endif 
67a4			 
67a4 d1				pop de 
67a5 c1				pop bc 
67a6 e1				pop hl 
67a7			 
67a7			 
67a7 22 c9 eb		        ld (display_write_tmp), hl 	  
67aa 3e 00			ld a, kLCD_Line1 
67ac			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
67ac 06 28			ld b, display_cols 
67ae ed 5b c9 eb		ld de, (display_write_tmp) 
67b2 cd 35 68			call write_len_string 
67b5				 
67b5			 
67b5 e5			push hl 
67b6 d5			push de 
67b7 c5			push bc 
67b8 0e 02			ld c, 2 
67ba 1e 0a			ld e, 10 
67bc cd 05 00			call 5 
67bf 0e 02			ld c, 2 
67c1 1e 0d			ld e, 13 
67c3 cd 05 00			call 5 
67c6			; TODO Replace with CP/M BIOS call 
67c6				;rst $30 
67c6 c1			pop bc 
67c7 d1			pop de 
67c8 e1			pop hl 
67c9			 
67c9				 
67c9 2a c9 eb			ld hl, (display_write_tmp) 
67cc 11 28 00			ld de, display_cols 
67cf 19				add hl,de 
67d0 22 c9 eb			ld (display_write_tmp),hl 
67d3			 
67d3				 
67d3 3e 28			ld a, kLCD_Line2 
67d5			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
67d5 06 28			ld b, display_cols 
67d7 ed 5b c9 eb		ld de, (display_write_tmp) 
67db cd 35 68			call write_len_string 
67de				 
67de 2a c9 eb			ld hl, (display_write_tmp) 
67e1 11 28 00			ld de, display_cols 
67e4 19				add hl,de 
67e5 22 c9 eb			ld (display_write_tmp),hl 
67e8			 
67e8 e5			push hl 
67e9 d5			push de 
67ea c5			push bc 
67eb 0e 07			ld c, 7 
67ed			; TODO Replace with CP/M BIOS call 
67ed				;rst $30 
67ed 0e 02			ld c, 2 
67ef 1e 0a			ld e, 10 
67f1 cd 05 00			call 5 
67f4 0e 02			ld c, 2 
67f6 1e 0d			ld e, 13 
67f8 cd 05 00			call 5 
67fb c1			pop bc 
67fc d1			pop de 
67fd e1			pop hl 
67fe			 
67fe				 
67fe 3e 50			ld a, kLCD_Line3 
6800			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
6800 06 28			ld b, display_cols 
6802 ed 5b c9 eb		ld de, (display_write_tmp) 
6806 cd 35 68			call write_len_string 
6809				 
6809 2a c9 eb			ld hl, (display_write_tmp) 
680c 11 28 00			ld de, display_cols 
680f 19				add hl,de 
6810 22 c9 eb			ld (display_write_tmp),hl 
6813			 
6813 e5			push hl 
6814 d5			push de 
6815 c5			push bc 
6816 0e 07			ld c, 7 
6818			; TODO Replace with CP/M BIOS call 
6818				;rst $30 
6818 0e 02			ld c, 2 
681a 1e 0a			ld e, 10 
681c cd 05 00			call 5 
681f 0e 02			ld c, 2 
6821 1e 0d			ld e, 13 
6823 cd 05 00			call 5 
6826 c1			pop bc 
6827 d1			pop de 
6828 e1			pop hl 
6829			 
6829				 
6829 3e 78			ld a, kLCD_Line4 
682b			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
682b 06 28			ld b, display_cols 
682d ed 5b c9 eb		ld de, (display_write_tmp) 
6831 cd 35 68			call write_len_string 
6834 c9					ret 
6835			 
6835			 
6835				; write out a fixed length string given in b from de 
6835			 
6835 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
6836 cd 66 67		            CALL fLCD_Data      ;Write character to display 
6839 13				inc de 
683a 10 f9			djnz write_len_string 
683c c9				ret 
683d			 
683d			 
683d			; eof 
# End of file firmware_cpm_display.asm
683d			;include "firmware_key_5x10.asm" 
683d			;;include "firmware_key_4x10.asm" 
683d			include "firmware_key_cpm.asm" 
683d			; Serial keyboard interface for SC114 
683d			 
683d			 
683d			key_init: 
683d				; no init as handled by the SCM bios 
683d c9				ret 
683e			 
683e			 
683e			cin_wait: 
683e			;	ld a, 0 
683e			;	ret 
683e			 
683e				;in a,(SC114_SIO_1_IN) 
683e			        ; Use SCM API to get from whatever console device we are using 
683e			 
683e			; TODO Replace with CP/M BIOS call 
683e c5				push bc 
683f 0e 01			ld c, $01 
6841 cd 05 00			call 5 
6844 c1				pop bc 
6845 c9				ret 
6846			 
6846			cin: 
6846			 
6846			 
6846 c5				push bc 
6847			 
6847				; any key waiting to process? 
6847			; TODO Replace with CP/M BIOS call 
6847 0e 06			ld c, $06 
6849 cd 05 00			call 5 
684c 28 0d			jr z, .cin_skip 
684e			 
684e				; yep, get it 
684e			 
684e 0e 01			ld c, $01 
6850			; TODO Replace with CP/M BIOS call 
6850 cd 05 00			call 5 
6853			 
6853 fe 7f			cp $7f     ; back space 
6855 20 02			jr nz, .skipbs 
6857 3e 08			ld a, KEY_BS 
6859			.skipbs: 
6859			 
6859 c1				pop bc 
685a c9				ret 
685b			.cin_skip: 
685b 3e 00			ld a, 0 
685d c1				pop bc 
685e c9				ret 
685f			 
685f			 
685f			 
685f			 
# End of file firmware_key_cpm.asm
685f			endofcode:  
685f			baseram:  
685f 00				nop 
6860			 
6860			heap_start: equ baseram+15  ; Starting address of heap 
6860			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
6860			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
6860			;VDU:  EQU     endofcode           ; BASIC Work space 
6860			; eof 
6860			 
# End of file os_mega_cpm.asm
6860
