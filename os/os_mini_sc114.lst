# File os_mini_sc114.asm
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			 
0000			 
0000			tos:	equ 0f000h 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			SC103_PIO: equ 068h 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 46 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 1  
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 0  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c				call break_point_state  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			debug_mark: equ hardware_word - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_write_tmp-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_view_disable - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c				ld a, ' ' 
801c				ld (os_view_disable), a 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 fc ed				ld hl, display_fb1  
801f 22 58 ed				ld (display_fb_active), hl  
8022			  
8022 cd 75 8a				call clear_display  
8025			  
8025 21 5a ed				ld hl, display_fb2  
8028 22 58 ed				ld (display_fb_active), hl  
802b			  
802b cd 75 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 4d ee				ld hl, display_fb0  
8031 22 58 ed				ld (display_fb_active), hl  
8034			  
8034 cd 75 8a				call clear_display  
8037			  
8037			  
8037 cd 96 da				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd 38 db			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 45 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd 98 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd 7a 8a			call fill_display  
804e cd 98 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd 7a 8a			call fill_display  
8059 cd 98 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd 7a 8a			call fill_display  
8064 cd 98 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a 3e 00		        ld a, display_row_1    
806c			else  
806c			        ld a, display_row_1 +10   
806c			endif  
806c 11 79 96			ld de, prom_bootmsg  
806f cd 88 8a			call str_at_display  
8072 cd 98 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b 3e 2a		            LD   A, display_row_3+2  
807d			else  
807d			            LD   A, display_row_3+12  
807d			endif  
807d 11 8e 96			ld de, prom_bootmsg1  
8080 cd 88 8a			call str_at_display  
8083 cd 98 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 b7 ee		ld (debug_mark),a  
8091 32 b8 ee		ld (debug_mark+1),a  
8094 32 b9 ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 ba ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 03 ec			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 b7 ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 b8 ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 b9 ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd a3 94			call break_point_state  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 0a ec			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 b7 ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 b8 ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 b9 ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd a3 94			call break_point_state  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 0a ec				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 b7 ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 b8 ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 b9 ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd a3 94			call break_point_state  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd cb 8c				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 03 ec				ld hl, (store_tmp1) 
8110 11 0d ec				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 b7 ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 b8 ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 b9 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd a3 94			call break_point_state  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 38 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 b7 ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 b8 ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 b9 ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd a3 94			call break_point_state  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 b7 ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 b8 ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 b9 ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd a3 94			call break_point_state  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 b7 ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 b8 ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 b9 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd a3 94			call break_point_state  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 b7 ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 b8 ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 b9 ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd a3 94			call break_point_state  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd cb 8c			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 0a ec			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 0c ec			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 b7 ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 b8 ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 b9 ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd a3 94			call break_point_state  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 b7 ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 b8 ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 b9 ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd a3 94			call break_point_state  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 0a ec			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 b7 ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 b8 ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 b9 ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 0a ec				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd a3 94			call break_point_state  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 0b ec			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 b7 ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 b8 ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 b9 ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd a3 94			call break_point_state  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 b7 ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 b8 ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 b9 ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd a3 94			call break_point_state  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 0a ec			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 0b ec		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 0d ec		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 16 ec			ld hl, store_page+3+9 
82b5 3a ef eb			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 0a ec			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 b7 ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 b8 ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 b9 ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd a3 94			call break_point_state  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 b7 ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 b8 ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 b9 ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd a3 94			call break_point_state  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd a2 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd a2 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 b7 ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 b8 ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 b9 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd a3 94			call break_point_state  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 0d ec		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 b7 ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 b8 ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 b9 ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd a3 94			call break_point_state  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 0a ec			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 b7 ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 b8 ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 b9 ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd a3 94			call break_point_state  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 b7 ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 b8 ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 b9 ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd a3 94			call break_point_state  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd cb 8c			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 0a ec			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd cb 8c			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 b7 ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 b8 ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 b9 ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd a3 94			call break_point_state  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 0a ec			ld a, (store_page)	; get file id 
8410 32 fe eb			ld (store_tmpid), a 
8413			 
8413 3a 0c ec			ld a, (store_page+2)    ; get count of extends 
8416 32 fd eb			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 0a ec			ld (store_page), a 
841f 32 0b ec			ld (store_page+1),a 
8422 11 0a ec			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 b7 ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 b8 ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 b9 ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd a3 94			call break_point_state  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a fd eb			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a fe eb			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 b7 ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 b8 ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 b9 ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd a3 94			call break_point_state  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd cb 8c			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 0a ec			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 0a ec			ld (store_page), a 
8482 32 0b ec			ld (store_page+1),a 
8485 11 0a ec			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 b7 ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 b8 ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 b9 ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd a3 94			call break_point_state  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 b7 ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 b8 ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 b9 ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd a3 94			call break_point_state  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd c0 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd a2 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd c0 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd a2 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 b7 ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 b8 ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 b9 ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd a3 94			call break_point_state  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 b7 ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 b8 ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 b9 ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd a3 94			call break_point_state  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd a2 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd a2 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 b7 ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 b8 ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 b9 ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd a3 94			call break_point_state  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 0a ec			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 0a ec			ld (store_page),a 
85a3				 
85a3 32 fe eb			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 0a ec			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 b7 ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 b8 ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 b9 ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd a3 94			call break_point_state  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 0a ec				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 b7 ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 b8 ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 b9 ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd a3 94			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 f5 eb			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 b7 ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 b8 ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 b9 ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd a3 94			call break_point_state  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 f5 eb			ld (store_tmppageid), hl 
8615				 
8615 3a fe eb			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 0a ec			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 0b ec			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 0c ec			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 0d ec			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 b7 ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 b8 ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 b9 ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd a3 94			call break_point_state  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 0b 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 b7 ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 b8 ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 b9 ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd a3 94			call break_point_state  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 b7 ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 b8 ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 b9 ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd a3 94			call break_point_state  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a f5 eb			ld hl,(store_tmppageid) 
868b 11 0a ec			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 b7 ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 b8 ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 b9 ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd a3 94			call break_point_state  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a fe eb			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 b7 ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 b8 ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 b9 ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd a3 94			call break_point_state  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 08 ec			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 06 ec		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 b7 ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 b8 ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 b9 ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd a3 94			call break_point_state  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 b7 ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 b8 ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 b9 ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd a3 94			call break_point_state  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd cb 8c			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 fb eb			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 06 ec		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 b7 ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 b8 ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 b9 ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd a3 94			call break_point_state  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 06 ec			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd a2 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 fd eb			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 b7 ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 b8 ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 b9 ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd a3 94			call break_point_state  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 05 ec			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 06 ec			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd a2 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 b7 ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 b8 ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 b9 ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd a3 94			call break_point_state  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 06 ec			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 08 ec		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 08 ec			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 b7 ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 b8 ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 b9 ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd a3 94			call break_point_state  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 b7 ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 b8 ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 b9 ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd a3 94			call break_point_state  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd cb 8c			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 fb eb			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 06 ec		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 06 ec			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 b7 ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 b8 ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 b9 ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd a3 94			call break_point_state  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 b7 ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 b8 ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 b9 ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd a3 94			call break_point_state  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 b7 ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 b8 ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 b9 ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd a3 94			call break_point_state  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 b7 ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 b8 ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 b9 ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd a3 94			call break_point_state  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 fe eb			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a fe eb			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd cb 8c			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 f5 eb			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 b7 ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 b8 ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 b9 ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd a3 94			call break_point_state  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 0a ec			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 b7 ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 b8 ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 b9 ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd a3 94			call break_point_state  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 0c ec			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 0c ec			ld (store_page+2), a 
88e3 32 fd eb			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 b7 ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 b8 ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 b9 ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd a3 94			call break_point_state  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a f5 eb			ld hl, (store_tmppageid) 
8905 11 0a ec			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd cb 8c			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 f5 eb				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 b7 ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 b8 ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 b9 ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd a3 94			call break_point_state  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 0a ec				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a fe eb				ld a, (store_tmpid) 
894b 32 0a ec				ld (store_page), a   ; file id 
894e 3a fd eb				ld a, (store_tmpext)   ; extent for this block 
8951 32 0b ec				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 0c ec				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 b7 ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 b8 ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 b9 ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd a3 94			call break_point_state  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a f5 eb			ld hl, (store_tmppageid) 
8985 11 0a ec			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 b7 ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 b8 ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 b9 ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd a3 94			call break_point_state  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a fe eb				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 0a ec			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 0b ec			ld de, store_page+1 
89c1 01 18 01			ld bc, STORE_BLOCK_LOG 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; information window 
8a06			 
8a06			; pass hl with 1st string to display 
8a06			; pass de with 2nd string to display 
8a06			 
8a06			info_panel: 
8a06 e5				push hl 
8a07			 
8a07 2a 58 ed			ld hl, (display_fb_active) 
8a0a e5				push hl    ; future de destination 
8a0b 21 4d ee				ld hl, display_fb0 
8a0e 22 58 ed				ld (display_fb_active), hl 
8a11			 
8a11			;	call clear_display 
8a11			 
8a11				if BASE_CPM 
8a11				ld a, '.' 
8a11				else 
8a11 3e a5			ld a, 165 
8a13				endif 
8a13 cd 7a 8a			call fill_display 
8a16			 
8a16			 
8a16 3e 2d			ld a, display_row_3 + 5 
8a18 cd 88 8a			call str_at_display 
8a1b			 
8a1b e1				pop hl 
8a1c d1				pop de 
8a1d			 
8a1d e5				push hl 
8a1e			 
8a1e			 
8a1e 3e 19			ld a, display_row_2 + 5 
8a20 cd 88 8a			call str_at_display 
8a23			 
8a23			 
8a23 cd 98 8a			call update_display 
8a26 cd 8c 9a			call next_page_prompt 
8a29 cd 75 8a			call clear_display 
8a2c			 
8a2c				 
8a2c 21 fc ed				ld hl, display_fb1 
8a2f 22 58 ed				ld (display_fb_active), hl 
8a32 cd 98 8a			call update_display 
8a35			 
8a35 e1				pop hl 
8a36			 
8a36 c9				ret 
8a37			 
8a37			 
8a37			 
8a37			 
8a37			; TODO windowing? 
8a37			 
8a37			; TODO scroll line up 
8a37			 
8a37			scroll_up: 
8a37			 
8a37 e5				push hl 
8a38 d5				push de 
8a39 c5				push bc 
8a3a			 
8a3a				; get frame buffer  
8a3a			 
8a3a 2a 58 ed			ld hl, (display_fb_active) 
8a3d e5				push hl    ; future de destination 
8a3e			 
8a3e 11 14 00			ld  de, display_cols 
8a41 19				add hl, de 
8a42			 
8a42 d1				pop de 
8a43			 
8a43				;ex de, hl 
8a43 01 4f 00			ld bc, display_fb_len -1  
8a46			;if DEBUG_FORTH_WORDS 
8a46			;	DMARK "SCL" 
8a46			;	CALLMONITOR 
8a46			;endif	 
8a46 ed b0			ldir 
8a48			 
8a48				; wipe bottom row 
8a48			 
8a48			 
8a48 2a 58 ed			ld hl, (display_fb_active) 
8a4b 11 50 00			ld de, display_cols*display_rows 
8a4e 19				add hl, de 
8a4f 06 14			ld b, display_cols 
8a51 3e 20			ld a, ' ' 
8a53			.scwipe: 
8a53 77				ld (hl), a 
8a54 2b				dec hl 
8a55 10 fc			djnz .scwipe 
8a57			 
8a57				;pop hl 
8a57			 
8a57 c1				pop bc 
8a58 d1				pop de 
8a59 e1				pop hl 
8a5a			 
8a5a c9				ret 
8a5b			 
8a5b			 
8a5b			;scroll_upo: 
8a5b			;	ld de, display_row_1 
8a5b			 ;	ld hl, display_row_2 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			;	ld de, display_row_2 
8a5b			 ;	ld hl, display_row_3 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			;	ld de, display_row_3 
8a5b			 ;	ld hl, display_row_4 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			 
8a5b			; TODO clear row 4 
8a5b			 
8a5b			;	ret 
8a5b			 
8a5b				 
8a5b			scroll_down: 
8a5b			 
8a5b e5				push hl 
8a5c d5				push de 
8a5d c5				push bc 
8a5e			 
8a5e				; get frame buffer  
8a5e			 
8a5e 2a 58 ed			ld hl, (display_fb_active) 
8a61			 
8a61 11 4f 00			ld de, display_fb_len - 1 
8a64 19				add hl, de 
8a65			 
8a65 e5			push hl    ; future de destination 
8a66			 
8a66 11 14 00			ld  de, display_cols 
8a69 ed 52			sbc hl, de 
8a6b			 
8a6b			 
8a6b d1				pop de 
8a6c			 
8a6c			;	ex de, hl 
8a6c 01 4f 00			ld bc, display_fb_len -1  
8a6f			 
8a6f			 
8a6f				 
8a6f			 
8a6f ed b0			ldir 
8a71			 
8a71				; wipe bottom row 
8a71			 
8a71			 
8a71			;	ld hl, (display_fb_active) 
8a71			;;	ld de, display_cols*display_rows 
8a71			;;	add hl, de 
8a71			;	ld b, display_cols 
8a71			;	ld a, ' ' 
8a71			;.scwiped: 
8a71			;	ld (hl), a 
8a71			;	dec hl 
8a71			;	djnz .scwiped 
8a71			 
8a71				;pop hl 
8a71			 
8a71 c1				pop bc 
8a72 d1				pop de 
8a73 e1				pop hl 
8a74			 
8a74 c9				ret 
8a75			;scroll_down: 
8a75			;	ld de, display_row_4 
8a75			;	ld hl, display_row_3 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;	ld de, display_row_3 
8a75			; 	ld hl, display_row_2 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;	ld de, display_row_2 
8a75			;	ld hl, display_row_1 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;;; TODO clear row 1 
8a75			;	ret 
8a75			 
8a75			 
8a75			 
8a75			 
8a75			 
8a75			; clear active frame buffer 
8a75			 
8a75			clear_display: 
8a75 3e 20			ld a, ' ' 
8a77 c3 7a 8a			jp fill_display 
8a7a			 
8a7a			; fill active frame buffer with a char in A 
8a7a			 
8a7a			fill_display: 
8a7a 06 50			ld b,display_fb_len 
8a7c 2a 58 ed			ld hl, (display_fb_active) 
8a7f 77			.fd1:	ld (hl),a 
8a80 23				inc hl 
8a81 10 fc			djnz .fd1 
8a83 23				inc hl 
8a84 3e 00			ld a,0 
8a86 77				ld (hl),a 
8a87			 
8a87			 
8a87 c9				ret 
8a88			; Write string (DE) at pos (A) to active frame buffer 
8a88			 
8a88 2a 58 ed		str_at_display:    ld hl,(display_fb_active) 
8a8b 06 00					ld b,0 
8a8d 4f					ld c,a 
8a8e 09					add hl,bc 
8a8f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8a90 b7			            OR   A              ;Null terminator? 
8a91 c8			            RET  Z              ;Yes, so finished 
8a92 77					ld (hl),a 
8a93 23				inc hl 
8a94 13			            INC  DE             ;Point to next character 
8a95 18 f8		            JR   .sad1     ;Repeat 
8a97 c9					ret 
8a98			 
8a98			; using current frame buffer write to physical display 
8a98			 
8a98			update_display: 
8a98 e5				push hl 
8a99 2a 58 ed			ld hl, (display_fb_active) 
8a9c cd ad da			call write_display 
8a9f e1				pop hl 
8aa0 c9				ret 
8aa1			 
8aa1			; TODO scrolling 
8aa1			 
8aa1			 
8aa1			; move cursor right one char 
8aa1			cursor_right: 
8aa1			 
8aa1				; TODO shift right 
8aa1				; TODO if beyond max col 
8aa1				; TODO       cursor_next_line 
8aa1			 
8aa1 c9				ret 
8aa2			 
8aa2			 
8aa2			cursor_next_line: 
8aa2				; TODO first char 
8aa2				; TODO line down 
8aa2				; TODO if past last row 
8aa2				; TODO    scroll up 
8aa2			 
8aa2 c9				ret 
8aa3			 
8aa3			cursor_left: 
8aa3				; TODO shift left 
8aa3				; TODO if beyond left  
8aa3				; TODO     cursor prev line 
8aa3				 
8aa3 c9				ret 
8aa4			 
8aa4			cursor_prev_line: 
8aa4				; TODO last char 
8aa4				; TODO line up 
8aa4				; TODO if past first row 
8aa4				; TODO   scroll down 
8aa4			 
8aa4 c9				ret 
8aa5			 
8aa5			 
8aa5			cout: 
8aa5				; A - char 
8aa5 c9				ret 
8aa6			 
8aa6			 
8aa6			; Display a menu and allow item selection (optional toggle items) 
8aa6			; 
8aa6			; format: 
8aa6			; hl pointer to word array with zero term for items 
8aa6			; e.g.    db item1 
8aa6			;         db .... 
8aa6			;         db 0 
8aa6			; 
8aa6			; a = starting menu item  
8aa6			; 
8aa6			; de = pointer item toggle array   (todo) 
8aa6			; 
8aa6			; returns item selected in a 1-... 
8aa6			; returns 0 if back button pressed 
8aa6			; 
8aa6			; NOTE: Uses system frame buffer to display 
8aa6			; 
8aa6			; LEFT, Q = go back 
8aa6			; RIGHT, SPACE, CR = select 
8aa6			; UP, A - Up 
8aa6			; DOWN, Z - Down 
8aa6			 
8aa6			 
8aa6			 
8aa6			 
8aa6			 
8aa6			menu: 
8aa6			 
8aa6					; keep array pointer 
8aa6			 
8aa6 22 03 ec				ld (store_tmp1), hl 
8aa9 32 01 ec				ld (store_tmp2), a 
8aac			 
8aac					; check for key bounce 
8aac			 
8aac			if BASE_KEV 
8aac			 
8aac			.mbounce:	call cin 
8aac					cp 0 
8aac					jr nz, .mbounce 
8aac			endif 
8aac					; for ease use ex 
8aac			 
8aac					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8aac 21 4d ee				ld hl, display_fb0 
8aaf 22 58 ed				ld (display_fb_active), hl 
8ab2			 
8ab2 cd 75 8a		.mloop:		call clear_display 
8ab5 cd 98 8a				call update_display 
8ab8			 
8ab8					; draw selection id '>' at 1 
8ab8			 
8ab8					; init start of list display 
8ab8			 
8ab8 3e 05				ld a, 5 
8aba 32 ff eb				ld (store_tmp3), a   ; display row count 
8abd 3a 01 ec				ld a,( store_tmp2) 
8ac0 32 02 ec				ld (store_tmp2+1), a   ; display item count 
8ac3			 
8ac3					 
8ac3			.mitem:	 
8ac3			 
8ac3			 
8ac3 3a 02 ec				ld a,(store_tmp2+1) 
8ac6 6f					ld l, a 
8ac7 26 00				ld h, 0 
8ac9 29					add hl, hl 
8aca ed 5b 03 ec			ld de, (store_tmp1) 
8ace 19					add hl, de 
8acf 7e					ld a, (hl) 
8ad0 23					inc hl 
8ad1 66					ld h,(hl) 
8ad2 6f					ld l, a 
8ad3			 
8ad3 cd cb 8c				call ishlzero 
8ad6 28 1a				jr z, .mdone 
8ad8			 
8ad8 eb					ex de, hl 
8ad9 3a ff eb				ld a, (store_tmp3) 
8adc cd 88 8a				call str_at_display 
8adf					 
8adf			 
8adf					; next item 
8adf 3a 02 ec				ld a, (store_tmp2+1) 
8ae2 3c					inc a 
8ae3 32 02 ec				ld (store_tmp2+1), a   ; display item count 
8ae6			 
8ae6			 		; next row 
8ae6			 
8ae6 3a ff eb				ld a, (store_tmp3) 
8ae9 c6 14				add display_cols 
8aeb 32 ff eb				ld (store_tmp3), a 
8aee			 
8aee					; at end of screen? 
8aee			 
8aee fe 10				cp display_rows*4 
8af0 20 d1				jr nz, .mitem 
8af2			 
8af2			 
8af2			.mdone: 
8af2 cd cb 8c				call ishlzero 
8af5 28 08				jr z, .nodn 
8af7			 
8af7 3e 3c				ld a, display_row_4 
8af9 11 78 8b				ld de, .mdown 
8afc cd 88 8a				call str_at_display 
8aff			 
8aff					; draw options to fill the screens with active item on line 1 
8aff					; if current option is 2 or more then display ^ in top 
8aff			 
8aff 3a 01 ec		.nodn:		ld a, (store_tmp2) 
8b02 fe 00				cp 0 
8b04 28 08				jr z, .noup 
8b06			 
8b06 3e 00				ld a, 0 
8b08 11 76 8b				ld de, .mup 
8b0b cd 88 8a				call str_at_display 
8b0e			 
8b0e 3e 02		.noup:		ld a, 2 
8b10 11 74 8b				ld de, .msel 
8b13 cd 88 8a				call str_at_display 
8b16			 
8b16					; if current option + 1 is not null then display V in bottom 
8b16					; get key 
8b16 cd 98 8a				call update_display 
8b19			 
8b19			 
8b19					; handle key 
8b19			 
8b19 cd 39 db				call cin_wait 
8b1c			 
8b1c fe 05				cp KEY_UP 
8b1e 28 2b				jr z, .mgoup 
8b20 fe 61				cp 'a' 
8b22 28 27				jr z, .mgoup 
8b24 fe 0a				cp KEY_DOWN 
8b26 28 32				jr z, .mgod 
8b28 fe 7a				cp 'z' 
8b2a 28 2e				jr z, .mgod 
8b2c fe 20				cp ' ' 
8b2e 28 34				jr z, .goend 
8b30 fe 0c				cp KEY_RIGHT 
8b32 28 30				jr z, .goend 
8b34 fe 0d				cp KEY_CR 
8b36 28 2c				jr z, .goend 
8b38 fe 71				cp 'q' 
8b3a 28 0b				jr z, .goback 
8b3c			 
8b3c fe 0b				cp KEY_LEFT 
8b3e 28 07				jr z, .goback 
8b40 fe 08				cp KEY_BS 
8b42 28 03				jr z, .goback 
8b44 c3 b2 8a				jp .mloop 
8b47			 
8b47			.goback: 
8b47 3e 00			ld a, 0 
8b49 18 1d			jr .goend2 
8b4b			 
8b4b				; move up one 
8b4b			.mgoup: 
8b4b 3a 01 ec				ld a, (store_tmp2) 
8b4e fe 00				cp 0 
8b50 ca b2 8a				jp z, .mloop 
8b53 3d					dec a 
8b54 32 01 ec				ld (store_tmp2), a 
8b57 c3 b2 8a				jp .mloop 
8b5a			 
8b5a				; move down one 
8b5a			.mgod: 
8b5a 3a 01 ec				ld a, (store_tmp2) 
8b5d 3c					inc a 
8b5e 32 01 ec				ld (store_tmp2), a 
8b61 c3 b2 8a				jp .mloop 
8b64			 
8b64			 
8b64			.goend: 
8b64					; get selected item number 
8b64			 
8b64 3a 01 ec				ld a, (store_tmp2) 
8b67 3c					inc a 
8b68			 
8b68			.goend2: 
8b68 f5					push af 
8b69			 
8b69					; restore active fb 
8b69					; TODO BUG assumes fb1 
8b69			 
8b69 21 fc ed				ld hl, display_fb1 
8b6c 22 58 ed				ld (display_fb_active), hl 
8b6f			 
8b6f					; restore main regs 
8b6f			 
8b6f			 
8b6f cd 98 8a				call update_display 
8b72			 
8b72 f1					pop af 
8b73			 
8b73 c9				ret 
8b74			 
8b74 .. 00		.msel:   db ">",0 
8b76 .. 00		.mup:   db "^",0 
8b78 .. 00		.mdown:   db "v",0 
8b7a			 
8b7a			 
8b7a			; eof 
8b7a			 
# End of file firmware_display.asm
8b7a			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8b7a			; random number generators 
8b7a			 
8b7a			 
8b7a			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8b7a			 
8b7a			 
8b7a			;-----> Generate a random number 
8b7a			; output a=answer 0<=a<=255 
8b7a			; all registers are preserved except: af 
8b7a			random: 
8b7a e5			        push    hl 
8b7b d5			        push    de 
8b7c 2a 3a ed		        ld      hl,(randData) 
8b7f ed 5f		        ld      a,r 
8b81 57			        ld      d,a 
8b82 5e			        ld      e,(hl) 
8b83 19			        add     hl,de 
8b84 85			        add     a,l 
8b85 ac			        xor     h 
8b86 22 3a ed		        ld      (randData),hl 
8b89 d1			        pop     de 
8b8a e1			        pop     hl 
8b8b c9			        ret 
8b8c			 
8b8c			 
8b8c			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8b8c			 
8b8c			 
8b8c			 
8b8c			;------LFSR------ 
8b8c			;James Montelongo 
8b8c			;optimized by Spencer Putt 
8b8c			;out: 
8b8c			; a = 8 bit random number 
8b8c			RandLFSR: 
8b8c 21 40 ed		        ld hl,LFSRSeed+4 
8b8f 5e			        ld e,(hl) 
8b90 23			        inc hl 
8b91 56			        ld d,(hl) 
8b92 23			        inc hl 
8b93 4e			        ld c,(hl) 
8b94 23			        inc hl 
8b95 7e			        ld a,(hl) 
8b96 47			        ld b,a 
8b97 cb 13		        rl e  
8b99 cb 12			rl d 
8b9b cb 11		        rl c  
8b9d 17				rla 
8b9e cb 13		        rl e  
8ba0 cb 12			rl d 
8ba2 cb 11		        rl c  
8ba4 17				rla 
8ba5 cb 13		        rl e  
8ba7 cb 12			rl d 
8ba9 cb 11		        rl c  
8bab 17				rla 
8bac 67			        ld h,a 
8bad cb 13		        rl e  
8baf cb 12			rl d 
8bb1 cb 11		        rl c  
8bb3 17				rla 
8bb4 a8			        xor b 
8bb5 cb 13		        rl e  
8bb7 cb 12			rl d 
8bb9 ac			        xor h 
8bba a9			        xor c 
8bbb aa			        xor d 
8bbc 21 42 ed		        ld hl,LFSRSeed+6 
8bbf 11 43 ed		        ld de,LFSRSeed+7 
8bc2 01 07 00		        ld bc,7 
8bc5 ed b8		        lddr 
8bc7 12			        ld (de),a 
8bc8 c9			        ret 
8bc9			 
8bc9			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8bc9			 
8bc9			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8bc9			 
8bc9			 
8bc9			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8bc9			 
8bc9			prng16: 
8bc9			;Inputs: 
8bc9			;   (seed1) contains a 16-bit seed value 
8bc9			;   (seed2) contains a NON-ZERO 16-bit seed value 
8bc9			;Outputs: 
8bc9			;   HL is the result 
8bc9			;   BC is the result of the LCG, so not that great of quality 
8bc9			;   DE is preserved 
8bc9			;Destroys: 
8bc9			;   AF 
8bc9			;cycle: 4,294,901,760 (almost 4.3 billion) 
8bc9			;160cc 
8bc9			;26 bytes 
8bc9 2a 34 ed		    ld hl,(seed1) 
8bcc 44			    ld b,h 
8bcd 4d			    ld c,l 
8bce 29			    add hl,hl 
8bcf 29			    add hl,hl 
8bd0 2c			    inc l 
8bd1 09			    add hl,bc 
8bd2 22 34 ed		    ld (seed1),hl 
8bd5 2a 32 ed		    ld hl,(seed2) 
8bd8 29			    add hl,hl 
8bd9 9f			    sbc a,a 
8bda e6 2d		    and %00101101 
8bdc ad			    xor l 
8bdd 6f			    ld l,a 
8bde 22 32 ed		    ld (seed2),hl 
8be1 09			    add hl,bc 
8be2 c9			    ret 
8be3			 
8be3			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8be3			 
8be3			rand32: 
8be3			;Inputs: 
8be3			;   (seed1_0) holds the lower 16 bits of the first seed 
8be3			;   (seed1_1) holds the upper 16 bits of the first seed 
8be3			;   (seed2_0) holds the lower 16 bits of the second seed 
8be3			;   (seed2_1) holds the upper 16 bits of the second seed 
8be3			;   **NOTE: seed2 must be non-zero 
8be3			;Outputs: 
8be3			;   HL is the result 
8be3			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8be3			;Destroys: 
8be3			;   AF 
8be3			;Tested and passes all CAcert tests 
8be3			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8be3			;it has a period of 18,446,744,069,414,584,320 
8be3			;roughly 18.4 quintillion. 
8be3			;LFSR taps: 0,2,6,7  = 11000101 
8be3			;291cc 
8be3			;seed1_0=$+1 
8be3			;    ld hl,12345 
8be3			;seed1_1=$+1 
8be3			;    ld de,6789 
8be3			;    ld b,h 
8be3			;    ld c,l 
8be3			;    add hl,hl \ rl e \ rl d 
8be3			;    add hl,hl \ rl e \ rl d 
8be3			;    inc l 
8be3			;    add hl,bc 
8be3			;    ld (seed1_0),hl 
8be3			;    ld hl,(seed1_1) 
8be3			;    adc hl,de 
8be3			;    ld (seed1_1),hl 
8be3			;    ex de,hl 
8be3			;seed2_0=$+1 
8be3			;    ld hl,9876 
8be3			;seed2_1=$+1 
8be3			;    ld bc,54321 
8be3			;    add hl,hl \ rl c \ rl b 
8be3			;    ld (seed2_1),bc 
8be3			;    sbc a,a 
8be3			;    and %11000101 
8be3			;    xor l 
8be3			;    ld l,a 
8be3			;    ld (seed2_0),hl 
8be3			;    ex de,hl 
8be3			;    add hl,bc 
8be3			;    ret 
8be3			; 
8be3			 
8be3			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8be3			; 20 bytes, 86 cycles (excluding ret) 
8be3			 
8be3			; returns   hl = pseudorandom number 
8be3			; corrupts   a 
8be3			 
8be3			; generates 16-bit pseudorandom numbers with a period of 65535 
8be3			; using the xorshift method: 
8be3			 
8be3			; hl ^= hl << 7 
8be3			; hl ^= hl >> 9 
8be3			; hl ^= hl << 8 
8be3			 
8be3			; some alternative shift triplets which also perform well are: 
8be3			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8be3			 
8be3			;  org 32768 
8be3			 
8be3			xrnd: 
8be3 2a 38 ed		  ld hl,(xrandc)       ; seed must not be 0 
8be6 3e 00		  ld a,0 
8be8 bd			  cp l 
8be9 20 02		  jr nz, .xrnd1 
8beb 2e 01		  ld l, 1 
8bed			.xrnd1: 
8bed			 
8bed 7c			  ld a,h 
8bee 1f			  rra 
8bef 7d			  ld a,l 
8bf0 1f			  rra 
8bf1 ac			  xor h 
8bf2 67			  ld h,a 
8bf3 7d			  ld a,l 
8bf4 1f			  rra 
8bf5 7c			  ld a,h 
8bf6 1f			  rra 
8bf7 ad			  xor l 
8bf8 6f			  ld l,a 
8bf9 ac			  xor h 
8bfa 67			  ld h,a 
8bfb			 
8bfb 22 38 ed		  ld (xrandc),hl 
8bfe			 
8bfe c9			  ret 
8bff			;  
8bff			 
8bff			 
8bff			;;;; int maths 
8bff			 
8bff			; https://map.grauw.nl/articles/mult_div_shifts.php 
8bff			; Divide 16-bit values (with 16-bit result) 
8bff			; In: Divide BC by divider DE 
8bff			; Out: BC = result, HL = rest 
8bff			; 
8bff			Div16: 
8bff 21 00 00		    ld hl,0 
8c02 78			    ld a,b 
8c03 06 08		    ld b,8 
8c05			Div16_Loop1: 
8c05 17			    rla 
8c06 ed 6a		    adc hl,hl 
8c08 ed 52		    sbc hl,de 
8c0a 30 01		    jr nc,Div16_NoAdd1 
8c0c 19			    add hl,de 
8c0d			Div16_NoAdd1: 
8c0d 10 f6		    djnz Div16_Loop1 
8c0f 17			    rla 
8c10 2f			    cpl 
8c11 47			    ld b,a 
8c12 79			    ld a,c 
8c13 48			    ld c,b 
8c14 06 08		    ld b,8 
8c16			Div16_Loop2: 
8c16 17			    rla 
8c17 ed 6a		    adc hl,hl 
8c19 ed 52		    sbc hl,de 
8c1b 30 01		    jr nc,Div16_NoAdd2 
8c1d 19			    add hl,de 
8c1e			Div16_NoAdd2: 
8c1e 10 f6		    djnz Div16_Loop2 
8c20 17			    rla 
8c21 2f			    cpl 
8c22 41			    ld b,c 
8c23 4f			    ld c,a 
8c24 c9			ret 
8c25			 
8c25			 
8c25			;http://z80-heaven.wikidot.com/math 
8c25			; 
8c25			;Inputs: 
8c25			;     DE and A are factors 
8c25			;Outputs: 
8c25			;     A is not changed 
8c25			;     B is 0 
8c25			;     C is not changed 
8c25			;     DE is not changed 
8c25			;     HL is the product 
8c25			;Time: 
8c25			;     342+6x 
8c25			; 
8c25			Mult16: 
8c25			 
8c25 06 08		     ld b,8          ;7           7 
8c27 21 00 00		     ld hl,0         ;10         10 
8c2a 29			       add hl,hl     ;11*8       88 
8c2b 07			       rlca          ;4*8        32 
8c2c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c2e 19			         add hl,de   ;--         -- 
8c2f 10 f9		       djnz $-5      ;13*7+8     99 
8c31 c9			ret 
8c32			 
8c32			; 
8c32			; Square root of 16-bit value 
8c32			; In:  HL = value 
8c32			; Out:  D = result (rounded down) 
8c32			; 
8c32			;Sqr16: 
8c32			;    ld de,#0040 
8c32			;    ld a,l 
8c32			;    ld l,h 
8c32			;    ld h,d 
8c32			;    or a 
8c32			;    ld b,8 
8c32			;Sqr16_Loop: 
8c32			;    sbc hl,de 
8c32			;    jr nc,Sqr16_Skip 
8c32			;    add hl,de 
8c32			;Sqr16_Skip: 
8c32			;    ccf 
8c32			;    rl d 
8c32			;    add a,a 
8c32			;    adc hl,hl 
8c32			;    add a,a 
8c32			;    adc hl,hl 
8c32			;    djnz Sqr16_Loop 
8c32			;    ret 
8c32			; 
8c32			; 
8c32			; Divide 8-bit values 
8c32			; In: Divide E by divider C 
8c32			; Out: A = result, B = rest 
8c32			; 
8c32			Div8: 
8c32 af			    xor a 
8c33 06 08		    ld b,8 
8c35			Div8_Loop: 
8c35 cb 13		    rl e 
8c37 17			    rla 
8c38 91			    sub c 
8c39 30 01		    jr nc,Div8_NoAdd 
8c3b 81			    add a,c 
8c3c			Div8_NoAdd: 
8c3c 10 f7		    djnz Div8_Loop 
8c3e 47			    ld b,a 
8c3f 7b			    ld a,e 
8c40 17			    rla 
8c41 2f			    cpl 
8c42 c9			    ret 
8c43			 
8c43			; 
8c43			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c43			; In: Multiply A with DE 
8c43			; Out: HL = result 
8c43			; 
8c43			Mult12U: 
8c43 2e 00		    ld l,0 
8c45 87			    add a,a 
8c46 30 01		    jr nc,Mult12U_NoAdd0 
8c48 19			    add hl,de 
8c49			Mult12U_NoAdd0: 
8c49 29			    add hl,hl 
8c4a 87			    add a,a 
8c4b 30 01		    jr nc,Mult12U_NoAdd1 
8c4d 19			    add hl,de 
8c4e			Mult12U_NoAdd1: 
8c4e 29			    add hl,hl 
8c4f 87			    add a,a 
8c50 30 01		    jr nc,Mult12U_NoAdd2 
8c52 19			    add hl,de 
8c53			Mult12U_NoAdd2: 
8c53 29			    add hl,hl 
8c54 87			    add a,a 
8c55 30 01		    jr nc,Mult12U_NoAdd3 
8c57 19			    add hl,de 
8c58			Mult12U_NoAdd3: 
8c58 29			    add hl,hl 
8c59 87			    add a,a 
8c5a 30 01		    jr nc,Mult12U_NoAdd4 
8c5c 19			    add hl,de 
8c5d			Mult12U_NoAdd4: 
8c5d 29			    add hl,hl 
8c5e 87			    add a,a 
8c5f 30 01		    jr nc,Mult12U_NoAdd5 
8c61 19			    add hl,de 
8c62			Mult12U_NoAdd5: 
8c62 29			    add hl,hl 
8c63 87			    add a,a 
8c64 30 01		    jr nc,Mult12U_NoAdd6 
8c66 19			    add hl,de 
8c67			Mult12U_NoAdd6: 
8c67 29			    add hl,hl 
8c68 87			    add a,a 
8c69 d0			    ret nc 
8c6a 19			    add hl,de 
8c6b c9			    ret 
8c6c			 
8c6c			; 
8c6c			; Multiply 8-bit value with a 16-bit value (right rotating) 
8c6c			; In: Multiply A with DE 
8c6c			;      Put lowest value in A for most efficient calculation 
8c6c			; Out: HL = result 
8c6c			; 
8c6c			Mult12R: 
8c6c 21 00 00		    ld hl,0 
8c6f			Mult12R_Loop: 
8c6f cb 3f		    srl a 
8c71 30 01		    jr nc,Mult12R_NoAdd 
8c73 19			    add hl,de 
8c74			Mult12R_NoAdd: 
8c74 cb 23		    sla e 
8c76 cb 12		    rl d 
8c78 b7			    or a 
8c79 c2 6f 8c		    jp nz,Mult12R_Loop 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 16-bit values (with 32-bit result) 
8c7d			; In: Multiply BC with DE 
8c7d			; Out: BCHL = result 
8c7d			; 
8c7d			Mult32: 
8c7d 79			    ld a,c 
8c7e 48			    ld c,b 
8c7f 21 00 00		    ld hl,0 
8c82 06 10		    ld b,16 
8c84			Mult32_Loop: 
8c84 29			    add hl,hl 
8c85 17			    rla 
8c86 cb 11		    rl c 
8c88 30 07		    jr nc,Mult32_NoAdd 
8c8a 19			    add hl,de 
8c8b ce 00		    adc a,0 
8c8d d2 91 8c		    jp nc,Mult32_NoAdd 
8c90 0c			    inc c 
8c91			Mult32_NoAdd: 
8c91 10 f1		    djnz Mult32_Loop 
8c93 41			    ld b,c 
8c94 4f			    ld c,a 
8c95 c9			    ret 
8c96			 
8c96			 
8c96			 
8c96			; 
8c96			; Multiply 8-bit values 
8c96			; In:  Multiply H with E 
8c96			; Out: HL = result 
8c96			; 
8c96			Mult8: 
8c96 16 00		    ld d,0 
8c98 6a			    ld l,d 
8c99 06 08		    ld b,8 
8c9b			Mult8_Loop: 
8c9b 29			    add hl,hl 
8c9c 30 01		    jr nc,Mult8_NoAdd 
8c9e 19			    add hl,de 
8c9f			Mult8_NoAdd: 
8c9f 10 fa		    djnz Mult8_Loop 
8ca1 c9			    ret 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			;;http://z80-heaven.wikidot.com/math 
8ca2			;;This divides DE by BC, storing the result in DE, remainder in HL 
8ca2			; 
8ca2			;DE_Div_BC:          ;1281-2x, x is at most 16 
8ca2			;     ld a,16        ;7 
8ca2			;     ld hl,0        ;10 
8ca2			;     jp $+5         ;10 
8ca2			;.DivLoop: 
8ca2			;       add hl,bc    ;-- 
8ca2			;       dec a        ;64 
8ca2			;       jr z,.DivLoopEnd        ;86 
8ca2			; 
8ca2			;       sla e        ;128 
8ca2			;       rl d         ;128 
8ca2			;       adc hl,hl    ;240 
8ca2			;       sbc hl,bc    ;240 
8ca2			;       jr nc,.DivLoop ;23|21 
8ca2			;       inc e        ;-- 
8ca2			;       jp .DivLoop+1 
8ca2			; 
8ca2			;.DivLoopEnd: 
8ca2			 
8ca2			;HL_Div_C: 
8ca2			;Inputs: 
8ca2			;     HL is the numerator 
8ca2			;     C is the denominator 
8ca2			;Outputs: 
8ca2			;     A is the remainder 
8ca2			;     B is 0 
8ca2			;     C is not changed 
8ca2			;     DE is not changed 
8ca2			;     HL is the quotient 
8ca2			; 
8ca2			;       ld b,16 
8ca2			;       xor a 
8ca2			;         add hl,hl 
8ca2			;         rla 
8ca2			;         cp c 
8ca2			;         jr c,$+4 
8ca2			;           inc l 
8ca2			;           sub c 
8ca2			;         djnz $-7 
8ca2			 
8ca2			; https://plutiedev.com/z80-add-8bit-to-16bit 
8ca2			 
8ca2			addatohl: 
8ca2 85			    add   a, l    ; A = A+L 
8ca3 6f			    ld    l, a    ; L = A+L 
8ca4 8c			    adc   a, h    ; A = A+L+H+carry 
8ca5 95			    sub   l       ; A = H+carry 
8ca6 67			    ld    h, a    ; H = H+carry 
8ca7 c9			ret 
8ca8			 
8ca8			addatode: 
8ca8 83			    add   a, e    ; A = A+L 
8ca9 5f			    ld    e, a    ; L = A+L 
8caa 8a			    adc   a, d    ; A = A+L+H+carry 
8cab 93			    sub   e       ; A = H+carry 
8cac 57			    ld    d, a    ; H = H+carry 
8cad c9			ret 
8cae			 
8cae			 
8cae			addatobc: 
8cae 81			    add   a, c    ; A = A+L 
8caf 4f			    ld    c, a    ; L = A+L 
8cb0 88			    adc   a, b    ; A = A+L+H+carry 
8cb1 91			    sub   c       ; A = H+carry 
8cb2 47			    ld    b, a    ; H = H+carry 
8cb3 c9			ret 
8cb4			 
8cb4			subafromhl: 
8cb4			   ; If A=0 do nothing 
8cb4			    ; Otherwise flip A's sign. Since 
8cb4			    ; the upper byte becomes -1, also 
8cb4			    ; substract 1 from H. 
8cb4 ed 44		    neg 
8cb6 ca bf 8c		    jp    z, Skip 
8cb9 25			    dec   h 
8cba			     
8cba			    ; Now add the low byte as usual 
8cba			    ; Two's complement takes care of 
8cba			    ; ensuring the result is correct 
8cba 85			    add   a, l 
8cbb 6f			    ld    l, a 
8cbc 8c			    adc   a, h 
8cbd 95			    sub   l 
8cbe 67			    ld    h, a 
8cbf			Skip: 
8cbf c9				ret 
8cc0			 
8cc0			 
8cc0			; compare hl and de 
8cc0			; returns:  
8cc0			; if hl = de, z=1, s=0, c0=0 
8cc0			; if hl > de, z=0, s=0, c=0 
8cc0			; if hl < de, z=0, s=1, c=1 
8cc0			cmp16:	 
8cc0 b7				or a 
8cc1 ed 52			sbc hl,de 
8cc3 e0				ret po 
8cc4 7c				ld a,h 
8cc5 1f				rra 
8cc6 ee 40			xor 01000000B 
8cc8 37				scf 
8cc9 8f				adc a,a 
8cca c9				ret 
8ccb			 
8ccb			 
8ccb			; test if hl contains zero   - A is destroyed 
8ccb			 
8ccb			ishlzero:    
8ccb b7				or a     ; reset flags 
8ccc 7c				ld a, h 
8ccd b5				or l        	 
8cce			 
8cce c9				ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			 
8ccf			if FORTH_ENABLE_FLOATMATH 
8ccf			;include "float/bbcmath.z80" 
8ccf			include "float/lpfpcalc.asm" 
8ccf			endif 
8ccf			 
8ccf			 
8ccf			; eof 
8ccf			 
# End of file firmware_maths.asm
8ccf			include "firmware_strings.asm"   ; string handling  
8ccf			 
8ccf			 
8ccf			; TODO string len 
8ccf			; input text string, end on cr with zero term 
8ccf			; a offset into frame buffer to start prompt 
8ccf			; d is max length 
8ccf			; e is display size TODO 
8ccf			; c is current cursor position 
8ccf			; hl is ptr to where string will be stored 
8ccf			 
8ccf			 
8ccf			; TODO check limit of buffer for new inserts 
8ccf			; TODO check insert does not push beyond buffer 
8ccf			; TODO scroll in a limited display area 
8ccf			; TODO scroll whole screen on page wrap 
8ccf			 
8ccf			 
8ccf			; TODO handle KEY_PREVWORD 
8ccf			; TODO handle KEY_NEXTWORD 
8ccf			; TODO handle KEY_HOME 
8ccf			; TODO handle KEY_END 
8ccf			; TODO use LCD cursor? 
8ccf			 
8ccf 32 b0 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8cd2 81					add c 
8cd3 32 ae ee				ld (input_at_cursor),a	; save draw pos of cursor 
8cd6 22 b3 ee				ld (input_start), hl     ; save ptr to buffer 
8cd9 79					ld a, c 
8cda cd a2 8c				call addatohl 
8cdd 22 b5 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8ce0 7a					ld a,d 
8ce1 32 b2 ee			        ld (input_size), a       ; save length of input area 
8ce4 79					ld a, c 
8ce5 32 a1 ee				ld (input_cursor),a      ; init cursor start position  
8ce8 7b					ld a,e 
8ce9 32 b1 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8cec					 
8cec					 
8cec			 
8cec			;		ld a,(input_ptr) 
8cec			;		ld (input_under_cursor),a 	; save what is under the cursor 
8cec			 
8cec			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8cec					; init cursor shape if not set by the cin routines 
8cec 21 50 ed				ld hl, cursor_shape 
8cef 3e ff				ld a, 255 
8cf1 77					ld (hl), a 
8cf2 23					inc hl 
8cf3 3e 00				ld a, 0 
8cf5 77					ld (hl), a 
8cf6			 
8cf6 3e 0f				ld a, CUR_BLINK_RATE 
8cf8 32 ac ee				ld (input_cur_flash), a 
8cfb 3e 01				ld a, 1 
8cfd 32 ab ee				ld (input_cur_onoff),a 
8d00			 
8d00			;	if DEBUG_INPUT 
8d00			;		push af 
8d00			;		ld a, 'I' 
8d00			;		ld (debug_mark),a 
8d00			;		pop af 
8d00			;		CALLMONITOR 
8d00			;	endif 
8d00			.is1:		; main entry loop 
8d00			 
8d00			 
8d00			 
8d00					; pause 1ms 
8d00			 
8d00 3e 01				ld a, 1 
8d02 cd d7 89				call aDelayInMS 
8d05			 
8d05					; dec flash counter 
8d05 3a ac ee				ld a, (input_cur_flash) 
8d08 3d					dec a 
8d09 32 ac ee				ld (input_cur_flash), a 
8d0c fe 00				cp 0 
8d0e 20 0d				jr nz, .nochgstate 
8d10			 
8d10			 
8d10					; change state 
8d10 3a ab ee				ld a,(input_cur_onoff) 
8d13 ed 44				neg 
8d15 32 ab ee				ld (input_cur_onoff),a 
8d18			 
8d18			 
8d18					; reset on change of state 
8d18 3e 0f				ld a, CUR_BLINK_RATE 
8d1a 32 ac ee				ld (input_cur_flash), a 
8d1d			 
8d1d			.nochgstate: 
8d1d					 
8d1d					 
8d1d			 
8d1d					; display cursor  
8d1d			 
8d1d			;		ld hl, (input_start) 
8d1d			;		ld a, (input_cursor) 
8d1d			;		call addatohl 
8d1d			 
8d1d					; get char under cursor and replace with cursor 
8d1d 2a b5 ee		ld hl, (input_ptr) 
8d20			;		ld a, (hl) 
8d20			;		ld (input_under_cursor),a 
8d20			;		ld a, '_' 
8d20			;		ld (hl), a 
8d20			 
8d20					; display string 
8d20			 
8d20 ed 5b b3 ee			ld de, (input_start) 
8d24 3a b0 ee				ld a, (input_at_pos) 
8d27 cd 88 8a				call str_at_display 
8d2a			;	        call update_display 
8d2a			 
8d2a					; find place to put the cursor 
8d2a			;		add h 
8d2a			;		ld l, display_row_1 
8d2a			;		sub l 
8d2a			; (input_at_pos) 
8d2a					;ld c, a 
8d2a			;		ld a, (input_cursor) 
8d2a			;		ld l, (input_at_pos) 
8d2a			;		;ld b, h 
8d2a			;		add l 
8d2a			;		ld (input_at_cursor),a 
8d2a					;ld l,h 
8d2a			 
8d2a			;		ld h, 0 
8d2a			;		ld l,(input_at_pos) 
8d2a			;		ld a, (input_cursor) 
8d2a			;		call addatohl 
8d2a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d2a			;		call subafromhl 
8d2a			;		ld a,l 
8d2a			;		ld (input_at_cursor), a 
8d2a			 
8d2a				if DEBUG_INPUT 
8d2a					ld a, (hardware_diag) 
8d2a					cp 0 
8d2a					jr z, .skip_input_diag 
8d2a			 
8d2a					ld a,(input_at_pos) 
8d2a					ld hl, LFSRSeed 
8d2a					call hexout 
8d2a					ld a, (input_cursor) 
8d2a					ld hl, LFSRSeed+2 
8d2a					call hexout 
8d2a					ld a,(input_at_cursor) 
8d2a					ld hl, LFSRSeed+4 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_cur_onoff) 
8d2a					ld hl, LFSRSeed+6 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_cur_flash) 
8d2a					ld hl, LFSRSeed+8 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_len) 
8d2a					ld hl, LFSRSeed+10 
8d2a					call hexout 
8d2a					ld hl, LFSRSeed+12 
8d2a					ld a, 0 
8d2a					ld (hl),a 
8d2a					ld a, display_row_4 
8d2a					ld de, LFSRSeed 
8d2a					call str_at_display 
8d2a					.skip_input_diag: 
8d2a				endif 
8d2a			 
8d2a					; decide on if we are showing the cursor this time round 
8d2a			 
8d2a 3a ab ee				ld a, (input_cur_onoff) 
8d2d fe ff				cp 255 
8d2f 28 13				jr z, .skipcur 
8d31			 
8d31			 
8d31 3a ae ee				ld a,(input_at_cursor) 
8d34 11 50 ed				ld de, cursor_shape 
8d37 cd 88 8a				call str_at_display 
8d3a			 
8d3a					; save length of current input string 
8d3a 2a b3 ee				ld hl, (input_start) 
8d3d cd 00 91				call strlenz 
8d40 7d					ld a,l 
8d41 32 a6 ee				ld (input_len),a 
8d44			 
8d44			.skipcur: 
8d44			 
8d44 cd 98 8a			        call update_display 
8d47					 
8d47			 
8d47			 
8d47					; wait 
8d47				 
8d47					; TODO loop without wait to flash the cursor and char under cursor	 
8d47 cd 3f db				call cin    ; _wait 
8d4a			 
8d4a fe 00				cp 0 
8d4c ca 00 8d				jp z, .is1 
8d4f			 
8d4f					; get ptr to char to input into 
8d4f			 
8d4f 4f					ld c,a 
8d50 2a b3 ee				ld hl, (input_start) 
8d53 3a a1 ee				ld a, (input_cursor) 
8d56 cd a2 8c				call addatohl 
8d59 22 b5 ee				ld (input_ptr), hl 
8d5c 79					ld a,c 
8d5d			 
8d5d					; replace char under cursor 
8d5d			 
8d5d			;		ld hl, (input_ptr) 
8d5d			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d5d			;		ld (hl), a 
8d5d			 
8d5d			;	if DEBUG_INPUT 
8d5d			;		push af 
8d5d			;		ld a, 'i' 
8d5d			;		ld (debug_mark),a 
8d5d			;		pop af 
8d5d			;		CALLMONITOR 
8d5d			;	endif 
8d5d fe 0e				cp KEY_HOME 
8d5f 20 0e				jr nz, .iske 
8d61			 
8d61 3a b0 ee				ld a, (input_at_pos) 
8d64 32 ae ee				ld (input_at_cursor),a 
8d67 3e 00				ld a, 0 
8d69 32 a1 ee				ld (input_cursor), a 
8d6c c3 00 8d				jp .is1 
8d6f					 
8d6f fe 0f		.iske:		cp KEY_END 
8d71 20 03				jr nz, .isknw 
8d73 c3 00 8d				jp .is1 
8d76			 
8d76 fe 06		.isknw:		cp KEY_NEXTWORD 
8d78 20 1b				jr nz, .iskpw 
8d7a			 
8d7a 2a b5 ee		.isknwm:	ld hl, (input_ptr) 
8d7d 7e					ld a,(hl)	 
8d7e fe 00				cp 0 
8d80 ca 00 8d				jp z, .is1    ; end of string 
8d83 fe 20				cp ' ' 
8d85 ca 00 8d				jp z, .is1    ; end of word 
8d88 23					inc hl 
8d89 22 b5 ee				ld (input_ptr), hl 
8d8c 3a ae ee				ld a, (input_at_cursor) 
8d8f 3c					inc a 
8d90 32 ae ee				ld (input_at_cursor), a 
8d93 18 e5				jr .isknwm 
8d95			 
8d95 fe 07		.iskpw:		cp KEY_PREVWORD 
8d97 20 1b				jr nz, .iskl 
8d99			.iskpwm:	 
8d99 2a b5 ee				ld hl, (input_ptr) 
8d9c 7e					ld a,(hl)	 
8d9d fe 00				cp 0  
8d9f ca 00 8d				jp z, .is1    ; end of string 
8da2 fe 20				cp ' ' 
8da4 ca 00 8d				jp z, .is1    ; end of word 
8da7 2b					dec hl 
8da8 22 b5 ee				ld (input_ptr), hl 
8dab 3a ae ee				ld a, (input_at_cursor) 
8dae 3d					dec a 
8daf 32 ae ee				ld (input_at_cursor), a 
8db2 18 e5				jr .iskpwm 
8db4			 
8db4			 
8db4 fe 0b		.iskl:		cp KEY_LEFT 
8db6 20 27				jr nz, .isk1 
8db8			 
8db8 3a a1 ee				ld a, (input_cursor) 
8dbb			 
8dbb fe 00				cp 0 
8dbd ca 00 8d				jp z, .is1 		; at start of line to ignore  
8dc0			 
8dc0 3d					dec  a 		; TODO check underflow 
8dc1 32 a1 ee				ld (input_cursor), a 
8dc4			 
8dc4 2a b5 ee				ld hl, (input_ptr) 
8dc7 2b					dec hl 
8dc8 22 b5 ee				ld (input_ptr), hl 
8dcb					 
8dcb 3a ae ee				ld a, (input_at_cursor) 
8dce 3d					dec a 
8dcf 32 ae ee				ld (input_at_cursor), a 
8dd2			 
8dd2 3e 01				ld a, 1		; show cursor moving 
8dd4 32 ab ee				ld (input_cur_onoff),a 
8dd7 3e 0f				ld a, CUR_BLINK_RATE 
8dd9 32 ac ee				ld (input_cur_flash), a 
8ddc			 
8ddc c3 00 8d				jp .is1 
8ddf			 
8ddf fe 0c		.isk1:		cp KEY_RIGHT 
8de1 20 2a				jr nz, .isk2 
8de3			 
8de3 3a a6 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8de6 5f					ld e,a 
8de7 3a a1 ee				ld a, (input_cursor) 
8dea bb					cp e 
8deb ca 00 8d				jp z, .is1		; at the end of string so dont go right 
8dee			 
8dee 3c					inc  a 		; TODO check overflow 
8def 32 a1 ee				ld (input_cursor), a 
8df2			 
8df2 3a ae ee				ld a, (input_at_cursor) 
8df5 3c					inc a 
8df6 32 ae ee				ld (input_at_cursor), a 
8df9			 
8df9 2a b5 ee				ld hl, (input_ptr) 
8dfc 23					inc hl 
8dfd 22 b5 ee				ld (input_ptr), hl 
8e00			 
8e00 3e 01				ld a, 1		; show cursor moving 
8e02 32 ab ee				ld (input_cur_onoff),a 
8e05 3e 0f				ld a, CUR_BLINK_RATE 
8e07 32 ac ee				ld (input_cur_flash), a 
8e0a			 
8e0a c3 00 8d				jp .is1 
8e0d			 
8e0d fe 05		.isk2:		cp KEY_UP 
8e0f			 
8e0f 20 26				jr nz, .isk3 
8e11			 
8e11					; swap last command with the current on 
8e11			 
8e11					; move cursor to start of string 
8e11 2a b3 ee				ld hl, (input_start) 
8e14 22 b5 ee				ld (input_ptr), hl 
8e17			 
8e17 3a b0 ee				ld a, (input_at_pos) 
8e1a 32 ae ee				ld (input_at_cursor), a 
8e1d			 
8e1d 3e 00				ld a, 0 
8e1f 32 a1 ee				ld (input_cursor), a 
8e22					 
8e22					; swap input and last command buffers 
8e22			 
8e22 21 ac e7				ld hl, os_cli_cmd 
8e25 11 ab e8				ld de, os_last_cmd 
8e28 06 ff				ld b, 255 
8e2a 7e			.swap1:		ld a, (hl) 
8e2b 4f					ld c,a 
8e2c 1a					ld a, (de) 
8e2d 77					ld (hl), a 
8e2e 79					ld a,c 
8e2f 12					ld (de),a 
8e30 23					inc hl 
8e31 13					inc de 
8e32 10 f6				djnz .swap1 
8e34			 
8e34			 
8e34			 
8e34			 
8e34			 
8e34 c3 00 8d				jp .is1 
8e37			 
8e37 fe 08		.isk3:		cp KEY_BS 
8e39 20 3c				jr nz, .isk4 
8e3b			 
8e3b 3a a1 ee				ld a, (input_cursor) 
8e3e			 
8e3e fe 00				cp 0 
8e40 ca 00 8d				jp z, .is1 		; at start of line to ignore  
8e43			 
8e43 3d					dec  a 		; TODO check underflow 
8e44 32 a1 ee				ld (input_cursor), a 
8e47			 
8e47					; hl is source 
8e47					; de needs to be source - 1 
8e47			 
8e47			;		ld a, 0 
8e47			;		dec hl 
8e47			;		ld (hl), a 
8e47			 
8e47 2a b5 ee				ld hl, (input_ptr) 
8e4a 2b					dec hl 
8e4b 22 b5 ee				ld (input_ptr), hl 
8e4e			 
8e4e					; shift all data 
8e4e			 
8e4e e5					push hl 
8e4f 23					inc hl 
8e50 d1					pop de 
8e51 3a a6 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e54 4f					ld c,a 
8e55 06 00				ld b,0 
8e57 ed b0				ldir  
8e59			 
8e59			 
8e59			 
8e59			 
8e59 3a ae ee				ld a, (input_at_cursor) 
8e5c 3d					dec a 
8e5d 32 ae ee				ld (input_at_cursor), a 
8e60			 
8e60			 
8e60 3e 01				ld a, 1		; show cursor moving 
8e62 32 ab ee				ld (input_cur_onoff),a 
8e65 3e 0f				ld a, CUR_BLINK_RATE 
8e67 32 ac ee				ld (input_cur_flash), a 
8e6a			 
8e6a					; remove char 
8e6a 3a ae ee				ld a, (input_at_cursor) 
8e6d 3c					inc a 
8e6e 11 f8 8e				ld de,.iblank 
8e71 cd 88 8a				call str_at_display 
8e74			 
8e74 c3 00 8d				jp .is1 
8e77			 
8e77 fe 0d		.isk4:		cp KEY_CR 
8e79 28 6c				jr z, .endinput 
8e7b			 
8e7b					; else add the key press to the end 
8e7b			 
8e7b 4f					ld c, a			; save key pressed 
8e7c			 
8e7c 7e					ld a,(hl)		; get what is currently under char 
8e7d			 
8e7d fe 00				cp 0			; we are at the end of the string 
8e7f 20 2f				jr nz, .onchar 
8e81					 
8e81					; add a char to the end of the string 
8e81				 
8e81 71					ld (hl),c 
8e82 23					inc hl 
8e83			;		ld a,' ' 
8e83			;		ld (hl),a 
8e83			;		inc hl 
8e83 3e 00				ld a,0 
8e85 77					ld (hl),a 
8e86 2b					dec hl 
8e87			 
8e87 3a a1 ee				ld a, (input_cursor) 
8e8a 3c					inc a				; TODO check max string length and scroll  
8e8b 32 a1 ee				ld (input_cursor), a		; inc cursor pos 
8e8e							 
8e8e 3a ae ee				ld a, (input_at_cursor) 
8e91 3c					inc a 
8e92 32 ae ee				ld (input_at_cursor), a 
8e95			 
8e95 2a b5 ee				ld hl, (input_ptr) 
8e98 23					inc hl 
8e99 22 b5 ee				ld (input_ptr), hl 
8e9c			 
8e9c 2a b5 ee				ld hl, (input_ptr) 
8e9f 23					inc hl 
8ea0 22 b5 ee				ld (input_ptr), hl 
8ea3			;	if DEBUG_INPUT 
8ea3			;		push af 
8ea3			;		ld a, '+' 
8ea3			;		ld (debug_mark),a 
8ea3			;		pop af 
8ea3			;		CALLMONITOR 
8ea3			;	endif 
8ea3 3e 01				ld a, 1		; show cursor moving 
8ea5 32 ab ee				ld (input_cur_onoff),a 
8ea8 3e 0f				ld a, CUR_BLINK_RATE 
8eaa 32 ac ee				ld (input_cur_flash), a 
8ead c3 00 8d				jp .is1 
8eb0					 
8eb0			 
8eb0			 
8eb0					; if on a char then insert 
8eb0			.onchar: 
8eb0			 
8eb0					; TODO over flow check: make sure insert does not blow out buffer 
8eb0			 
8eb0					; need to do some maths to use lddr 
8eb0			 
8eb0 e5					push hl   ; save char pos 
8eb1 c5					push bc 
8eb2			 
8eb2 2a b3 ee				ld hl, (input_start) 
8eb5 3a a6 ee				ld a, (input_len) 
8eb8 cd a2 8c				call addatohl  		; end of string 
8ebb 23					inc hl 
8ebc 23					inc hl		; past zero term 
8ebd e5					push hl 
8ebe 23					inc hl 
8ebf e5					push hl  
8ec0			 
8ec0								; start and end of lddr set, now how much to move? 
8ec0			 
8ec0							 
8ec0 3a a1 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ec3 47					ld b,a 
8ec4 3a a6 ee				ld a,(input_len) 
8ec7 5f					ld e,a 
8ec8 90					sub b 
8ec9 3c					inc a		;?? 
8eca 3c					inc a		;?? 
8ecb 3c					inc a		;?? 
8ecc			 
8ecc 06 00				ld b,0 
8ece 4f					ld c,a 
8ecf			 
8ecf				if DEBUG_INPUT 
8ecf					push af 
8ecf					ld a, 'i' 
8ecf					ld (debug_mark),a 
8ecf					pop af 
8ecf			;		CALLMONITOR 
8ecf				endif 
8ecf d1					pop de 
8ed0 e1					pop hl 
8ed1				if DEBUG_INPUT 
8ed1					push af 
8ed1					ld a, 'I' 
8ed1					ld (debug_mark),a 
8ed1					pop af 
8ed1			;		CALLMONITOR 
8ed1				endif 
8ed1 ed b8				lddr 
8ed3				 
8ed3			 
8ed3			 
8ed3					; TODO have a key for insert/overwrite mode???? 
8ed3 c1					pop bc 
8ed4 e1					pop hl 
8ed5 71					ld (hl), c		; otherwise overwrite current char 
8ed6					 
8ed6			 
8ed6			 
8ed6			 
8ed6 3a a1 ee				ld a, (input_cursor) 
8ed9 3c					inc  a 		; TODO check overflow 
8eda 32 a1 ee				ld (input_cursor), a 
8edd			 
8edd 3a ae ee				ld a, (input_at_cursor) 
8ee0 3c					inc a 
8ee1 32 ae ee				ld (input_at_cursor), a 
8ee4			 
8ee4 c3 00 8d				jp .is1 
8ee7			 
8ee7			.endinput:	; TODO look for end of string 
8ee7			 
8ee7					; add trailing space for end of token 
8ee7			 
8ee7 2a b3 ee				ld hl, (input_start) 
8eea 3a a6 ee				ld a,(input_len) 
8eed cd a2 8c				call addatohl 
8ef0 3e 20				ld a, ' ' 
8ef2 77					ld (hl),a 
8ef3					; TODO eof of parse marker 
8ef3			 
8ef3 23					inc hl 
8ef4 3e 00				ld a, 0 
8ef6 77					ld (hl),a 
8ef7			 
8ef7			 
8ef7 c9					ret 
8ef8			 
8ef8 .. 00		.iblank: db " ",0 
8efa			 
8efa			 
8efa 32 b0 ee		input_str_prev:	ld (input_at_pos), a 
8efd 22 b3 ee				ld (input_start), hl 
8f00 3e 01				ld a,1			; add cursor 
8f02 77					ld (hl),a 
8f03 23					inc hl 
8f04 3e 00				ld a,0 
8f06 77					ld (hl),a 
8f07 22 b5 ee				ld (input_ptr), hl 
8f0a 7a					ld a,d 
8f0b 32 b2 ee				ld (input_size), a 
8f0e 3e 00				ld a,0 
8f10 32 a1 ee				ld (input_cursor),a 
8f13			.instr1:	 
8f13			 
8f13					; TODO do block cursor 
8f13					; TODO switch cursor depending on the modifer key 
8f13			 
8f13					; update cursor shape change on key hold 
8f13			 
8f13 2a b5 ee				ld hl, (input_ptr) 
8f16 2b					dec hl 
8f17 3a 50 ed				ld a,(cursor_shape) 
8f1a 77					ld (hl), a 
8f1b			 
8f1b					; display entered text 
8f1b 3a b0 ee				ld a,(input_at_pos) 
8f1e cd 9d da		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f21 ed 5b b3 ee	            	LD   de, (input_start) 
8f25 cd 97 da		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f28			 
8f28 cd 3f db				call cin 
8f2b fe 00				cp 0 
8f2d 28 e4				jr z, .instr1 
8f2f			 
8f2f					; proecess keyboard controls first 
8f2f			 
8f2f 2a b5 ee				ld hl,(input_ptr) 
8f32			 
8f32 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f34 28 5a				jr z, .instrcr 
8f36			 
8f36 fe 08				cp KEY_BS 	; back space 
8f38 20 0f				jr nz, .instr2 
8f3a					; process back space 
8f3a			 
8f3a					; TODO stop back space if at start of string 
8f3a 2b					dec hl 
8f3b 2b					dec hl ; to over write cursor 
8f3c 3a 50 ed				ld a,(cursor_shape) 
8f3f					;ld a,0 
8f3f 77					ld (hl),a 
8f40 23					inc hl 
8f41 3e 20				ld a," " 
8f43 77					ld (hl),a 
8f44 22 b5 ee				ld (input_ptr),hl 
8f47					 
8f47			 
8f47 18 ca				jr .instr1 
8f49			 
8f49 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f4b 20 06				jr nz, .instr3 
8f4d 2b					dec hl 
8f4e 22 b5 ee				ld (input_ptr),hl 
8f51 18 c0				jr .instr1 
8f53				 
8f53 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f55 20 06				jr nz, .instr4 
8f57 23					inc hl 
8f58 22 b5 ee				ld (input_ptr),hl 
8f5b 18 b6				jr .instr1 
8f5d			 
8f5d fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f5f 20 06				jr nz, .instr5 
8f61 2b					dec hl 
8f62 22 b5 ee				ld (input_ptr),hl 
8f65 18 ac				jr .instr1 
8f67			 
8f67 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8f69 20 06				jr nz, .instr6 
8f6b 2b					dec hl 
8f6c 22 b5 ee				ld (input_ptr),hl 
8f6f 18 a2				jr .instr1 
8f71 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8f73 20 0b				jr nz, .instrnew 
8f75			 
8f75 21 85 e4			ld hl, scratch 
8f78 11 ab e8			ld de, os_last_cmd 
8f7b cd 99 8f			call strcpy 
8f7e 18 93				jr .instr1 
8f80			 
8f80			 
8f80			.instrnew:	; no special key pressed to see if we have room to store it 
8f80			 
8f80					; TODO do string size test 
8f80			 
8f80 2b					dec hl ; to over write cursor 
8f81 77					ld (hl),a 
8f82 23					inc hl 
8f83 3a 50 ed				ld a,(cursor_shape) 
8f86 77					ld (hl),a 
8f87 23					inc hl 
8f88 3e 00				ld a,0 
8f8a 77					ld (hl),a 
8f8b			 
8f8b 22 b5 ee				ld (input_ptr),hl 
8f8e					 
8f8e 18 83				jr .instr1 
8f90 2b			.instrcr:	dec hl		; remove cursor 
8f91 3e 20				ld a,' '	; TODO add a trailing space for safety 
8f93 77					ld (hl),a 
8f94 23					inc hl 
8f95 3e 00				ld a,0 
8f97 77					ld (hl),a 
8f98			 
8f98			 
8f98					; if at end of line scroll up    
8f98					; TODO detecting only end of line 4 for scroll up  
8f98			 
8f98					;ld   
8f98			 
8f98 c9					ret 
8f99			 
8f99			 
8f99			; strcpy hl = dest, de source 
8f99			 
8f99 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8f9a b7			            OR   A              ;Null terminator? 
8f9b c8			            RET  Z              ;Yes, so finished 
8f9c 1a					ld a,(de) 
8f9d 77					ld (hl),a 
8f9e 13			            INC  DE             ;Point to next character 
8f9f 23					inc hl 
8fa0 18 f7		            JR   strcpy       ;Repeat 
8fa2 c9					ret 
8fa3			 
8fa3			 
8fa3			; TODO string_at  
8fa3			; pass string which starts with lcd offset address and then null term string 
8fa3			 
8fa3			; TODO string to dec 
8fa3			; TODO string to hex 
8fa3			; TODO byte to string hex 
8fa3			; TODO byte to string dec 
8fa3			 
8fa3			 
8fa3			 
8fa3			; from z80uartmonitor 
8fa3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fa3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fa3			; pass hl for where to put the text 
8fa3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fa3 c5			hexout:	PUSH BC 
8fa4 f5					PUSH AF 
8fa5 47					LD B, A 
8fa6					; Upper nybble 
8fa6 cb 3f				SRL A 
8fa8 cb 3f				SRL A 
8faa cb 3f				SRL A 
8fac cb 3f				SRL A 
8fae cd be 8f				CALL tohex 
8fb1 77					ld (hl),a 
8fb2 23					inc hl	 
8fb3					 
8fb3					; Lower nybble 
8fb3 78					LD A, B 
8fb4 e6 0f				AND 0FH 
8fb6 cd be 8f				CALL tohex 
8fb9 77					ld (hl),a 
8fba 23					inc hl	 
8fbb					 
8fbb f1					POP AF 
8fbc c1					POP BC 
8fbd c9					RET 
8fbe					 
8fbe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fbe			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8fbe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fbe			tohex: 
8fbe e5					PUSH HL 
8fbf d5					PUSH DE 
8fc0 16 00				LD D, 0 
8fc2 5f					LD E, A 
8fc3 21 cb 8f				LD HL, .DATA 
8fc6 19					ADD HL, DE 
8fc7 7e					LD A, (HL) 
8fc8 d1					POP DE 
8fc9 e1					POP HL 
8fca c9					RET 
8fcb			 
8fcb			.DATA: 
8fcb 30					DEFB	30h	; 0 
8fcc 31					DEFB	31h	; 1 
8fcd 32					DEFB	32h	; 2 
8fce 33					DEFB	33h	; 3 
8fcf 34					DEFB	34h	; 4 
8fd0 35					DEFB	35h	; 5 
8fd1 36					DEFB	36h	; 6 
8fd2 37					DEFB	37h	; 7 
8fd3 38					DEFB	38h	; 8 
8fd4 39					DEFB	39h	; 9 
8fd5 41					DEFB	41h	; A 
8fd6 42					DEFB	42h	; B 
8fd7 43					DEFB	43h	; C 
8fd8 44					DEFB	44h	; D 
8fd9 45					DEFB	45h	; E 
8fda 46					DEFB	46h	; F 
8fdb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fdb			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8fdb			;;    subtract $30, if result > 9 then subtract $7 more 
8fdb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fdb			atohex: 
8fdb d6 30				SUB $30 
8fdd fe 0a				CP 10 
8fdf f8					RET M		; If result negative it was 0-9 so we're done 
8fe0 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8fe2 c9					RET		 
8fe3			 
8fe3			 
8fe3			 
8fe3			 
8fe3			; Get 2 ASCII characters as hex byte from pointer in hl 
8fe3			 
8fe3			BYTERD: 
8fe3 16 00			LD	D,00h		;Set up 
8fe5 cd ed 8f			CALL	HEXCON		;Get byte and convert to hex 
8fe8 87				ADD	A,A		;First nibble so 
8fe9 87				ADD	A,A		;multiply by 16 
8fea 87				ADD	A,A		; 
8feb 87				ADD	A,A		; 
8fec 57				LD	D,A		;Save hi nibble in D 
8fed			HEXCON: 
8fed 7e				ld a, (hl)		;Get next chr 
8fee 23				inc hl 
8fef d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8ff1 fe 0a			CP	00Ah		;Is it 0-9 ? 
8ff3 38 02			JR	C,NALPHA	;If so miss next bit 
8ff5 d6 07			SUB	007h		;Else convert alpha 
8ff7			NALPHA: 
8ff7 b2				OR	D		;Add hi nibble back 
8ff8 c9				RET			; 
8ff9			 
8ff9			 
8ff9			; 
8ff9			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8ff9			; Since the routines get_byte and therefore get_nibble are called, only valid 
8ff9			; characters (0-9a-f) are accepted. 
8ff9			; 
8ff9			;get_word        push    af 
8ff9			;                call    get_byte        ; Get the upper byte 
8ff9			;                ld      h, a 
8ff9			;                call    get_byte        ; Get the lower byte 
8ff9			;                ld      l, a 
8ff9			;                pop     af 
8ff9			;                ret 
8ff9			; 
8ff9			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8ff9			; the routine get_nibble is used only valid characters are accepted - the  
8ff9			; input routine only accepts characters 0-9a-f. 
8ff9			; 
8ff9 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8ffa 7e					ld a,(hl) 
8ffb 23					inc hl 
8ffc cd 21 90		                call    nibble2val      ; Get upper nibble 
8fff cb 07		                rlc     a 
9001 cb 07		                rlc     a 
9003 cb 07		                rlc     a 
9005 cb 07		                rlc     a 
9007 47			                ld      b, a            ; Save upper four bits 
9008 7e					ld a,(hl) 
9009 cd 21 90		                call    nibble2val      ; Get lower nibble 
900c b0			                or      b               ; Combine both nibbles 
900d c1			                pop     bc              ; Restore B (and C) 
900e c9			                ret 
900f			; 
900f			; Get a hexadecimal digit from the serial line. This routine blocks until 
900f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
900f			; to the serial line interface. The lower 4 bits of A contain the value of  
900f			; that particular digit. 
900f			; 
900f			;get_nibble      ld a,(hl)           ; Read a character 
900f			;                call    to_upper        ; Convert to upper case 
900f			;                call    is_hex          ; Was it a hex digit? 
900f			;                jr      nc, get_nibble  ; No, get another character 
900f			 ;               call    nibble2val      ; Convert nibble to value 
900f			 ;               call    print_nibble 
900f			 ;               ret 
900f			; 
900f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
900f			; A valid hexadecimal digit is denoted by a set C flag. 
900f			; 
900f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
900f			;                ret     nc              ; Yes 
900f			;                cp      '0'             ; Less than '0'? 
900f			;                jr      nc, is_hex_1    ; No, continue 
900f			;                ccf                     ; Complement carry (i.e. clear it) 
900f			;                ret 
900f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
900f			;                ret     c               ; Yes 
900f			;                cp      'A'             ; Less than 'A'? 
900f			;                jr      nc, is_hex_2    ; No, continue 
900f			;                ccf                     ; Yes - clear carry and return 
900f			;                ret 
900f			;is_hex_2        scf                     ; Set carry 
900f			;                ret 
900f			; 
900f			; Convert a single character contained in A to upper case: 
900f			; 
900f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
9011 d8			                ret     c 
9012 fe 7b		                cp      'z' + 1         ; > 'z'? 
9014 d0			                ret     nc              ; Nothing to do, either 
9015 e6 5f		                and     $5f             ; Convert to upper case 
9017 c9			                ret 
9018			 
9018			 
9018			to_lower: 
9018			 
9018			   ; if char is in [A-Z] make it lower case 
9018			 
9018			   ; enter : a = char 
9018			   ; exit  : a = lower case char 
9018			   ; uses  : af 
9018			 
9018 fe 41		   cp 'A' 
901a d8			   ret c 
901b			    
901b fe 5b		   cp 'Z'+1 
901d d0			   ret nc 
901e			    
901e f6 20		   or $20 
9020 c9			   ret 
9021			 
9021			; 
9021			; Expects a hexadecimal digit (upper case!) in A and returns the 
9021			; corresponding value in A. 
9021			; 
9021 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
9023 38 02		                jr      c, nibble2val_1 ; Yes 
9025 d6 07		                sub     7               ; Adjust for A-F 
9027 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9029 e6 0f		                and     $f              ; Only return lower 4 bits 
902b c9			                ret 
902c			; 
902c			; Print_nibble prints a single hex nibble which is contained in the lower  
902c			; four bits of A: 
902c			; 
902c			;print_nibble    push    af              ; We won't destroy the contents of A 
902c			;                and     $f              ; Just in case... 
902c			;                add     a, '0'             ; If we have a digit we are done here. 
902c			;                cp      '9' + 1         ; Is the result > 9? 
902c			;                jr      c, print_nibble_1 
902c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
902c			;print_nibble_1  call    putc            ; Print the nibble and 
902c			;                pop     af              ; restore the original value of A 
902c			;                ret 
902c			;; 
902c			;; Send a CR/LF pair: 
902c			; 
902c			;crlf            push    af 
902c			;                ld      a, cr 
902c			;                call    putc 
902c			;                ld      a, lf 
902c			;                call    putc 
902c			;                pop     af 
902c			;                ret 
902c			; 
902c			; Print_word prints the four hex digits of a word to the serial line. The  
902c			; word is expected to be in HL. 
902c			; 
902c			;print_word      push    hl 
902c			;                push    af 
902c			;                ld      a, h 
902c			;                call    print_byte 
902c			;                ld      a, l 
902c			;                call    print_byte 
902c			;                pop     af 
902c			;                pop     hl 
902c			;                ret 
902c			; 
902c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
902c			; The byte to be printed is expected to be in A. 
902c			; 
902c			;print_byte      push    af              ; Save the contents of the registers 
902c			;                push    bc 
902c			;                ld      b, a 
902c			;                rrca 
902c			;                rrca 
902c			;                rrca 
902c			;                rrca 
902c			;                call    print_nibble    ; Print high nibble 
902c			;                ld      a, b 
902c			;                call    print_nibble    ; Print low nibble 
902c			;                pop     bc              ; Restore original register contents 
902c			;                pop     af 
902c			;                ret 
902c			 
902c			 
902c			 
902c			 
902c			 
902c			fourehexhl:  
902c 7e				ld a,(hl) 
902d cd db 8f			call atohex 
9030 cb 3f				SRL A 
9032 cb 3f				SRL A 
9034 cb 3f				SRL A 
9036 cb 3f				SRL A 
9038 47				ld b, a 
9039 23				inc hl 
903a 7e				ld a,(hl) 
903b 23				inc hl 
903c cd db 8f			call atohex 
903f 80				add b 
9040 57				ld d,a 
9041 7e				ld a,(hl) 
9042 cd db 8f			call atohex 
9045 cb 3f				SRL A 
9047 cb 3f				SRL A 
9049 cb 3f				SRL A 
904b cb 3f				SRL A 
904d 47				ld b, a 
904e 23				inc hl 
904f 7e				ld a,(hl) 
9050 23				inc hl 
9051 cd db 8f			call atohex 
9054 80				add b 
9055 5f				ld e, a 
9056 d5				push de 
9057 e1				pop hl 
9058 c9				ret 
9059			 
9059			; pass hl. returns z set if the byte at hl is a digit 
9059			;isdigithl:  
9059			;	push bc 
9059			;	ld a,(hl) 
9059			;	cp ':' 
9059			;	jr nc, .isdf 		; > 
9059			;	cp '0' 
9059			;	jr c, .isdf		; < 
9059			; 
9059			;	; TODO find a better way to set z 
9059			; 
9059			;	ld b,a 
9059			;	cp b 
9059			;	pop bc 
9059			;	ret 
9059			; 
9059			;.isdf:	; not digit so clear z 
9059			; 
9059			;	; TODO find a better way to unset z 
9059			; 
9059			;	ld b,a 
9059			;	inc b 
9059			;	cp b 
9059			; 
9059			;	pop bc 
9059			;	ret 
9059				 
9059				 
9059			 
9059			 
9059			; pass hl as the four byte address to load 
9059			 
9059			get_word_hl:  
9059 e5				push hl 
905a cd f9 8f			call get_byte 
905d				 
905d 47				ld b, a 
905e			 
905e e1				pop hl 
905f 23				inc hl 
9060 23				inc hl 
9061			 
9061			; TODO not able to handle a-f  
9061 7e				ld a,(hl) 
9062			;	;cp ':' 
9062			;	cp 'g' 
9062			;	jr nc, .single_byte_hl 		; > 
9062			;	cp 'G' 
9062			;	jr nc, .single_byte_hl 		; > 
9062			;	cp '0' 
9062			;	jr c, .single_byte_hl		; < 
9062			 
9062				;call isdigithl 
9062 fe 00			cp 0 
9064 28 06			jr z, .single_byte_hl 
9066			 
9066			.getwhln:   ; hex word so get next byte 
9066			 
9066 cd f9 8f			call get_byte 
9069 6f				ld l, a 
906a 60				ld h,b 
906b c9				ret 
906c 68			.single_byte_hl:   ld l,b 
906d 26 00				ld h,0 
906f c9					ret 
9070			 
9070			 
9070			 
9070			 
9070 21 2b 98			ld hl,asc+1 
9073			;	ld a, (hl) 
9073			;	call nibble2val 
9073 cd f9 8f			call get_byte 
9076			 
9076			;	call fourehexhl 
9076 32 b9 e4			ld (scratch+52),a 
9079				 
9079 21 b7 e4			ld hl,scratch+50 
907c 22 a8 e7			ld (os_cur_ptr),hl 
907f			 
907f c9				ret 
9080			 
9080			 
9080			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
9080			 
9080			; Decimal Unsigned Version 
9080			 
9080			;Number in a to decimal ASCII 
9080			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
9080			;Example: display a=56 as "056" 
9080			;input: a = number 
9080			;Output: a=0,value of a in the screen 
9080			;destroys af,bc (don't know about hl and de) 
9080			DispAToASCII: 
9080 0e 9c			ld	c,-100 
9082 cd 8c 90			call	.Na1 
9085 0e f6			ld	c,-10 
9087 cd 8c 90			call	.Na1 
908a 0e ff			ld	c,-1 
908c 06 2f		.Na1:	ld	b,'0'-1 
908e 04			.Na2:	inc	b 
908f 81				add	a,c 
9090 38 fc			jr	c,.Na2 
9092 91				sub	c		;works as add 100/10/1 
9093 f5				push af		;safer than ld c,a 
9094 78				ld	a,b		;char is in b 
9095			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
9095 f1				pop af		;safer than ld a,c 
9096 c9				ret 
9097			 
9097			; Decimal Signed Version 
9097			 
9097			; DispA 
9097			; -------------------------------------------------------------- 
9097			; Converts a signed integer value to a zero-terminated ASCII 
9097			; string representative of that value (using radix 10). 
9097			; -------------------------------------------------------------- 
9097			; INPUTS: 
9097			;     HL     Value to convert (two's complement integer). 
9097			;     DE     Base address of string destination. (pointer). 
9097			; -------------------------------------------------------------- 
9097			; OUTPUTS: 
9097			;     None 
9097			; -------------------------------------------------------------- 
9097			; REGISTERS/MEMORY DESTROYED 
9097			; AF HL 
9097			; -------------------------------------------------------------- 
9097			 
9097			;DispHLToASCII: 
9097			;   push    de 
9097			;   push    bc 
9097			; 
9097			;; Detect sign of HL. 
9097			;    bit    7, h 
9097			;    jr     z, ._DoConvert 
9097			; 
9097			;; HL is negative. Output '-' to string and negate HL. 
9097			;    ld     a, '-' 
9097			;    ld     (de), a 
9097			;    inc    de 
9097			; 
9097			;; Negate HL (using two's complement) 
9097			;    xor    a 
9097			;    sub    l 
9097			;    ld     l, a 
9097			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
9097			;    sbc    a, h 
9097			;    ld     h, a 
9097			; 
9097			;; Convert HL to digit characters 
9097			;._DoConvert: 
9097			;    ld     b, 0     ; B will count character length of number 
9097			;-   ld     a, 10 
9097			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
9097			;    push   af 
9097			;    inc    b 
9097			;    ld     a, h 
9097			;    or     l 
9097			;    jr     nz, - 
9097			; 
9097			;; Retrieve digits from stack 
9097			;-   pop    af 
9097			;    or     $30 
9097			;    ld     (de), a 
9097			;    inc    de 
9097			;    djnz   - 
9097			; 
9097			;; Terminate string with NULL 
9097			;    xor    a 
9097			;    ld     (de), a 
9097			; 
9097			;    pop    bc 
9097			;    pop    de 
9097			;    ret 
9097			 
9097			;Comments 
9097			; 
9097			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
9097			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
9097			;    Note that the output string will not be fixed-width. 
9097			; 
9097			;Example Usage 
9097			; 
9097			;    ld    hl, -1004 
9097			;    ld    de, OP1 
9097			;    call  DispA 
9097			;    ld    hl, OP1 
9097			;    syscall  PutS 
9097			 
9097			 
9097			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
9097			 
9097			 
9097			;Converts an ASCII string to an unsigned 16-bit integer 
9097			;Quits when it reaches a non-decimal digit 
9097			 
9097			string_to_uint16: 
9097			atoui_16: 
9097			;Input: 
9097			;     DE points to the string 
9097			;Outputs: 
9097			;     HL is the result 
9097			;     A is the 8-bit value of the number 
9097			;     DE points to the byte after the number 
9097			;Destroys: 
9097			;     BC 
9097			;       if the string is non-empty, BC is HL/10 
9097			;Size:  24 bytes 
9097			;Speed: 42+d(104+{0,9}) 
9097			;       d is the number of digits in the number 
9097			;       max is 640 cycles for a 5 digit number 
9097			;Assuming no leading zeros: 
9097			;1 digit:  146cc 
9097			;2 digit:  250cc 
9097			;3 digit:  354cc or 363cc (avg: 354.126cc) 
9097			;4 digit:  458cc or 467cc (avg: 458.27cc) 
9097			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
9097			;avg: 544.81158447265625cc (544+13297/16384) 
9097			;=============================================================== 
9097 21 00 00		  ld hl,0 
909a			.u16a: 
909a 1a			  ld a,(de) 
909b d6 30		  sub 30h 
909d fe 0a		  cp 10 
909f d0			  ret nc 
90a0 13			  inc de 
90a1 44			  ld b,h 
90a2 4d			  ld c,l 
90a3 29			  add hl,hl 
90a4 29			  add hl,hl 
90a5 09			  add hl,bc 
90a6 29			  add hl,hl 
90a7 85			  add a,l 
90a8 6f			  ld l,a 
90a9 30 ef		  jr nc,.u16a 
90ab 24			  inc h 
90ac c3 9a 90		  jp .u16a 
90af			 
90af			 
90af			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90af			 
90af			;written by Zeda 
90af			;Converts a 16-bit unsigned integer to an ASCII string. 
90af			 
90af			uitoa_16: 
90af			;Input: 
90af			;   DE is the number to convert 
90af			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90af			;Output: 
90af			;   HL points to the null-terminated ASCII string 
90af			;      NOTE: This isn't necessarily the same as the input HL. 
90af d5			  push de 
90b0 c5			  push bc 
90b1 f5			  push af 
90b2 eb			  ex de,hl 
90b3			 
90b3 01 f0 d8		  ld bc,-10000 
90b6 3e 2f		  ld a,'0'-1 
90b8 3c			  inc a 
90b9 09			  add hl,bc  
90ba 38 fc		   jr c,$-2 
90bc 12			  ld (de),a 
90bd 13			  inc de 
90be			 
90be 01 e8 03		  ld bc,1000 
90c1 3e 3a		  ld a,'9'+1 
90c3 3d			  dec a  
90c4 09			  add hl,bc  
90c5 30 fc		   jr nc,$-2 
90c7 12			  ld (de),a 
90c8 13			  inc de 
90c9			 
90c9 01 9c ff		  ld bc,-100 
90cc 3e 2f		  ld a,'0'-1 
90ce 3c			  inc a  
90cf 09			  add hl,bc  
90d0 38 fc		   jr c,$-2 
90d2 12			  ld (de),a 
90d3 13			  inc de 
90d4			 
90d4 7d			  ld a,l 
90d5 26 3a		  ld h,'9'+1 
90d7 25			  dec h  
90d8 c6 0a		  add a,10  
90da 30 fb		   jr nc,$-3 
90dc c6 30		  add a,'0' 
90de eb			  ex de,hl 
90df 72			  ld (hl),d 
90e0 23			  inc hl 
90e1 77			  ld (hl),a 
90e2 23			  inc hl 
90e3 36 00		  ld (hl),0 
90e5			 
90e5			;Now strip the leading zeros 
90e5 0e fa		  ld c,-6 
90e7 09			  add hl,bc 
90e8 3e 30		  ld a,'0' 
90ea 23			  inc hl  
90eb be			  cp (hl)  
90ec 28 fc		  jr z,$-2 
90ee			 
90ee			;Make sure that the string is non-empty! 
90ee 7e			  ld a,(hl) 
90ef b7			  or a 
90f0 20 01		  jr nz,.atoub 
90f2 2b			  dec hl 
90f3			.atoub: 
90f3			 
90f3 f1			  pop af 
90f4 c1			  pop bc 
90f5 d1			  pop de 
90f6 c9			  ret 
90f7			 
90f7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
90f7			 
90f7			toUpper: 
90f7			;A is the char. 
90f7			;If A is a lowercase letter, this sets it to the matching uppercase 
90f7			;18cc or 30cc or 41cc 
90f7			;avg: 26.75cc 
90f7 fe 61		  cp 'a' 
90f9 d8			  ret c 
90fa fe 7b		  cp 'z'+1 
90fc d0			  ret nc 
90fd d6 20		  sub 'a'-'A' 
90ff c9			  ret 
9100			 
9100			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9100			 
9100			; String Length 
9100			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9100			 
9100			; Get the length of the null-terminated string starting at $8000 hl 
9100			;    LD     HL, $8000 
9100			 
9100			strlenz: 
9100			 
9100 af			    XOR    A               ; Zero is the value we are looking for. 
9101 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9102 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9103			                           ; 65, 536 bytes (the entire addressable memory space). 
9103 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9105			 
9105			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9105 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9106 6f			    LD     L, A             ; number of bytes 
9107 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9109 2b			    DEC    HL              ; Compensate for null. 
910a c9				ret 
910b			 
910b			; Get the length of the A terminated string starting at $8000 hl 
910b			;    LD     HL, $8000 
910b			 
910b			strlent: 
910b			 
910b			                  ; A is the value we are looking for. 
910b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
910d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
910f			                           ; 65, 536 bytes (the entire addressable memory space). 
910f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9111			 
9111			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9111 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9113 2e 00		    LD     L, 0             ; number of bytes 
9115 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9117 2b			    DEC    HL              ; Compensate for null. 
9118 c9				ret 
9119			 
9119			 
9119			;Comparing Strings 
9119			 
9119			;IN    HL     Address of string1. 
9119			;      DE     Address of string2. 
9119			 
9119			; doc given but wrong??? 
9119			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9119			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9119			; tested 
9119			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9119			 
9119			strcmp_old: 
9119 e5			    PUSH   HL 
911a d5			    PUSH   DE 
911b			 
911b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
911c be			    CP     (HL)            ; (want to minimize work). 
911d 38 01		    JR     C, Str1IsBigger 
911f 7e			    LD     A, (HL) 
9120			 
9120			Str1IsBigger: 
9120 4f			    LD     C, A             ; Put length in BC 
9121 06 00		    LD     B, 0 
9123 13			    INC    DE              ; Increment pointers to meat of string. 
9124 23			    INC    HL 
9125			 
9125			CmpLoop: 
9125 1a			    LD     A, (DE)          ; Compare bytes. 
9126 ed a1		    CPI 
9128 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
912a 13			    INC    DE              ; Update pointer. 
912b ea 25 91		    JP     PE, CmpLoop 
912e			 
912e d1			    POP    DE 
912f e1			    POP    HL 
9130 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
9131 be			    CP     (HL) 
9132 c9			    RET 
9133			 
9133			NoMatch: 
9133 2b			    DEC    HL 
9134 be			    CP     (HL)            ; Compare again to affect carry. 
9135 d1			    POP    DE 
9136 e1			    POP    HL 
9137 c9			    RET 
9138			 
9138			;; test strmp 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str2 
9138			;call strcmp 
9138			;jr z, .z1 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "NZ1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.z1: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "ZZ1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str1 
9138			;call strcmp 
9138			;jr z, .z2 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "NZ2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.z2: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "ZZ2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str2 
9138			;call strcmp 
9138			;jr c, .c1 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "Nc1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.c1: 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "cc1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str1 
9138			;call strcmp 
9138			;jr c, .c2 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "Nc2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.c2: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "cc2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;	NEXTW 
9138			;.str1:   db "string1",0 
9138			;.str2:   db "string2",0 
9138			 
9138			; only care about direct match or not 
9138			; hl and de strings 
9138			; zero set if the same 
9138			 
9138			strcmp: 
9138 1a				ld a, (de) 
9139 be				cp (hl) 
913a 28 02			jr z, .ssame 
913c b7				or a 
913d c9				ret 
913e			 
913e			.ssame:  
913e fe 00			cp 0 
9140 c8				ret z 
9141			 
9141 23				inc hl 
9142 13				inc de 
9143 18 f3			jr strcmp 
9145				 
9145				 
9145			 
9145			 
9145			 
9145			 
9145			; eof 
9145			 
9145			 
9145			 
9145			 
9145			 
9145			 
# End of file firmware_strings.asm
9145			include "firmware_memory.asm"   ; malloc and free  
9145			 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			.mallocsize: db "Wants malloc >256",0 
9145			.mallocasize: db "MALLOC gives >256",0 
9145			.malloczero: db "MALLOC gives zero",0 
9145			 
9145			malloc_guard_zerolen: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145				ld de, 0 
9145			        call cmp16 
9145				jr nz, .lowalloz 
9145			 
9145				push hl 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .malloczero 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145			 
9145				pop de 
9145				pop hl 
9145			 
9145				 
9145			 
9145				CALLMONITOR 
9145			.lowalloz: 
9145			 
9145			 
9145				pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			 
9145			malloc_guard_entry: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145			 	or a      ;clear carry flag 
9145				push hl 
9145				ld de, 255 
9145				sbc hl, de 
9145				jr c, .lowalloc 
9145			 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .mallocsize 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145			 
9145				pop de 
9145				pop hl 
9145			 
9145				 
9145			 
9145				CALLMONITOR 
9145				jr .lowdone 
9145			.lowalloc: 
9145			 
9145			 
9145				pop hl 
9145			.lowdone:	pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			 
9145			malloc_guard_exit: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145			 	or a      ;clear carry flag 
9145				push hl 
9145				ld de, 255 
9145				sbc hl, de 
9145				jr c, .lowallocx 
9145			 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .mallocasize 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145				pop de 
9145				pop hl 
9145			 
9145				CALLMONITOR 
9145				jr .lowdonex 
9145			.lowallocx: 
9145			 
9145				pop hl 
9145			.lowdonex:	pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			endif 
9145			 
9145			if MALLOC_2 
9145			; Z80 Malloc and Free Functions 
9145			 
9145			; Malloc Function: 
9145			; Input: 
9145			;   HL: Size of block to allocate 
9145			; Output: 
9145			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9145			 
9145			malloc: 
9145				 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			call malloc_guard_entry 
9145			endif 
9145			 
9145			 
9145			 
9145			 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "mal" 
9145						CALLMONITOR 
9145					endif 
9145			    push af            ; Save AF register 
9145			    ld a, l            ; Load low byte of size into A 
9145			    or h               ; Check if size is zero 
9145			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
9145			 
9145			    ; Allocate memory 
9145			    ld hl, (heap_start) ; Load start of heap into HL 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma1" 
9145						CALLMONITOR 
9145					endif 
9145			    call malloc_internal ; Call internal malloc function 
9145			    pop af             ; Restore AF register 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret                ; Return 
9145			 
9145			; Free Function: 
9145			; Input: 
9145			;   HL: Pointer to memory block to free 
9145			; Output: 
9145			;   None 
9145			 
9145			free: 
9145			    push af            ; Save AF register 
9145			    ld a, l            ; Load low byte of pointer into A 
9145			    or h               ; Check if pointer is NULL 
9145			    jp z, free_exit    ; If pointer is NULL, exit 
9145			 
9145			    ; Free memory 
9145			    ld hl, (heap_start) ; Load start of heap into HL 
9145			    call free_internal  ; Call internal free function 
9145			    pop af             ; Restore AF register 
9145			    ret                ; Return 
9145			 
9145			; Internal Malloc Function: 
9145			; Input: 
9145			;   HL: Size of block to allocate 
9145			; Output: 
9145			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9145			 
9145			malloc_internal: 
9145			    ld bc, 2           ; Number of bytes to allocate for management overhead 
9145			    add hl, bc         ; Add management overhead to requested size 
9145			    ex de, hl          ; Save total size in DE, and keep it in HL 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma2" 
9145						CALLMONITOR 
9145					endif 
9145			 
9145			    ; Search for free memory block 
9145			    ld de, (heap_end)  ; Load end of heap into DE 
9145			    ld bc, 0           ; Initialize counter 
9145			 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma2" 
9145						CALLMONITOR 
9145					endif 
9145			malloc_search_loop: 
9145			    ; Check if current block is free 
9145			    ld a, (hl)         ; Load current block's status (free or used) 
9145			    cp 0               ; Compare with zero (free) 
9145			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
9145			 
9145			    ; Check if current block is large enough 
9145			    ld a, (hl+1)       ; Load high byte of block size 
9145			    cp l               ; Compare with low byte of requested size 
9145			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
9145			 
9145			    ld a, (hl+2)       ; Load low byte of block size 
9145			    cp h               ; Compare with high byte of requested size 
9145			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
9145			 
9145			    ; Mark block as used 
9145			    ld (hl), 0xFF      ; Set status byte to indicate used block 
9145			 
9145			    ; Calculate remaining space in block 
9145			    ld bc, 0           ; Clear BC 
9145			    add hl, bc         ; Increment HL to point to start of data block 
9145			    add hl, de         ; HL = HL + DE (total size) 
9145			    ld bc, 1           ; Number of bytes to allocate for management overhead 
9145			    add hl, bc         ; Add management overhead to start of data block 
9145			 
9145			    ; Save pointer to allocated block in HL 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma5" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			 
9145			malloc_skip_block_check: 
9145			    ; Move to the next block 
9145			    ld bc, 3           ; Size of management overhead 
9145			    add hl, bc         ; Move to the next block 
9145			    inc de             ; Increment counter 
9145			 
9145			    ; Check if we have reached the end of heap 
9145			    ld a, e            ; Load low byte of heap end address 
9145			    cp (hl)            ; Compare with low byte of current address 
9145			    jr nz, malloc_search_loop  ; If not equal, continue searching 
9145			    ld a, d            ; Load high byte of heap end address 
9145			    cp 0               ; Check if it's zero (end of memory) 
9145			    jr nz, malloc_search_loop  ; If not zero, continue searching 
9145			 
9145			    ; If we reached here, allocation failed 
9145			    xor a              ; Set result to NULL 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma6" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			malloc_exit: 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma7" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			 
9145			; Internal Free Function: 
9145			; Input: 
9145			;   HL: Pointer to memory block to free 
9145			; Output: 
9145			;   None 
9145			 
9145			free_internal: 
9145			    ld de, (heap_start) ; Load start of heap into DE 
9145			    ld bc, 0            ; Initialize counter 
9145			 
9145			free_search_loop: 
9145			    ; Check if current block contains the pointer 
9145			    ld a, l             ; Load low byte of pointer 
9145			    cp (hl+1)           ; Compare with high byte of current block's address 
9145			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9145			    ld a, h             ; Load high byte of pointer 
9145			    cp (hl+2)           ; Compare with low byte of current block's address 
9145			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9145			 
9145			    ; Mark block as free 
9145			    ld (hl), 0          ; Set status byte to indicate free block 
9145			    ret                 ; Return 
9145			 
9145			free_skip_block_check: 
9145			    ; Move to the next block 
9145			    ld bc, 3            ; Size of management overhead 
9145			    add hl, bc          ; Move to the next block 
9145			    inc de              ; Increment counter 
9145			 
9145			    ; Check if we have reached the end of heap 
9145			    ld a, e             ; Load low byte of heap end address 
9145			    cp (hl)             ; Compare with low byte of current address 
9145			    jr nz, free_search_loop  ; If not equal, continue searching 
9145			    ld a, d             ; Load high byte of heap end address 
9145			    cp 0                ; Check if it's zero (end of memory) 
9145			    jr nz, free_search_loop  ; If not zero, continue searching 
9145			 
9145			    ; If we reached here, pointer is not found in heap 
9145			    ret 
9145			 
9145			free_exit: 
9145			    ret                 ; Return 
9145			 
9145			; Define heap start and end addresses 
9145			;heap_start:    .dw 0xC000   ; Start of heap 
9145			;heap_end:      .dw 0xE000   ; End of heap 
9145			 
9145			endif 
9145			 
9145			 
9145			if MALLOC_1 
9145			 
9145			 
9145			 
9145			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
9145			 
9145			;moved to firmware.asm 
9145			;heap_start        .equ  0x9000      ; Starting address of heap 
9145			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9145			 
9145			;      .org 0 
9145			;      jp    main 
9145			 
9145			 
9145			;      .org  0x100 
9145			;main: 
9145			;      ld    HL, 0x8100 
9145			;      ld    SP, HL 
9145			; 
9145			;      call  heap_init 
9145			; 
9145			;      ; Make some allocations 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9004 
9145			; 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9014 
9145			; 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9024 
9145			; 
9145			;      ; Free some allocations 
9145			;      ld    HL, 0x9014 
9145			;      call  free 
9145			; 
9145			;      ld    HL, 0x9004 
9145			;      call  free 
9145			; 
9145			;      ld    HL, 0x9024 
9145			;      call  free 
9145			; 
9145			; 
9145			;      halt 
9145			 
9145			 
9145			;------------------------------------------------------------------------------ 
9145			;     heap_init                                                               : 
9145			;                                                                             : 
9145			; Description                                                                 : 
9145			;     Initialise the heap and make it ready for malloc and free operations.   : 
9145			;                                                                             : 
9145			;     The heap is maintained as a linked list, starting with an initial       : 
9145			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9145			;     the first free block in the heap. Each block then points to the next    : 
9145			;     free block within the heap, and the free list ends at the first block   : 
9145			;     with a null pointer to the next free block.                             : 
9145			;                                                                             : 
9145			; Parameters                                                                  : 
9145			;     Inputs are compile-time only. Two defines which specify the starting    : 
9145			;     address of the heap and its size are required, along with a memory      : 
9145			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9145			;     principally stores a pointer to the first free block in the heap.       : 
9145			;                                                                             : 
9145			; Returns                                                                     : 
9145			;     Nothing                                                                 : 
9145			;------------------------------------------------------------------------------ 
9145			heap_init: 
9145 e5			      push  HL 
9146			 
9146			      ; Initialise free list struct 
9146 21 5d db		      ld    HL, heap_start 
9149 22 58 db		      ld    (free_list), HL 
914c 21 00 00		      ld    HL, 0 
914f 22 5a db		      ld    (free_list+2), HL 
9152			 
9152			      ; Insert first free block at bottom of heap, consumes entire heap 
9152 21 67 e4		      ld    HL, heap_start+heap_size-4 
9155 22 5d db		      ld    (heap_start), HL        ; Next block (end of free list) 
9158 21 0a 09		      ld    HL, heap_size-4 
915b 22 5f db		      ld    (heap_start+2), HL      ; Block size 
915e			 
915e			      ; Insert end of free list block at top of heap - two null words will 
915e			      ; terminate the free list 
915e 21 00 00		      ld    HL, 0 
9161 22 69 e4		      ld    (heap_start+heap_size-2), HL 
9164 22 67 e4		      ld    (heap_start+heap_size-4), HL 
9167			 
9167 e1			      pop   HL 
9168			 
9168 c9			      ret 
9169			 
9169			 
9169			;------------------------------------------------------------------------------ 
9169			;     malloc                                                                  : 
9169			;                                                                             : 
9169			; Description                                                                 : 
9169			;     Allocates the wanted space from the heap and returns the address of the : 
9169			;     first useable byte of the allocation.                                   : 
9169			;                                                                             : 
9169			;     Allocations can happen in one of two ways:                              : 
9169			;                                                                             : 
9169			;     1. A free block may be found which is the exact size wanted. In this    : 
9169			;        case the block is removed from the free list and retuedn to the      : 
9169			;        caller.                                                              : 
9169			;     2. A free block may be found which is larger than the size wanted. In   : 
9169			;        this case, the larger block is split into two. The first portion of  : 
9169			;        this block will become the requested space by the malloc call and    : 
9169			;        is returned to the caller. The second portion becomes a new free     : 
9169			;        block, and the free list is adjusted to maintain continuity via this : 
9169			;        newly created block.                                                 : 
9169			;                                                                             : 
9169			;     malloc does not set any initial value in the allocated space, the       : 
9169			;     caller is required to do this as required.                              : 
9169			;                                                                             : 
9169			;     This implementation of malloc uses the stack exclusively, and is        : 
9169			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9169			;     advisable to disable interrupts before calling malloc, and recommended  : 
9169			;     to avoid the use of malloc inside ISRs in general.                      : 
9169			;                                                                             : 
9169			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9169			;                                                                             : 
9169			; Parameters                                                                  : 
9169			;     HL  Number of bytes wanted                                              : 
9169			;                                                                             : 
9169			; Returns                                                                     : 
9169			;     HL  Address of the first useable byte of the allocation                 : 
9169			;                                                                             : 
9169			; Flags                                                                       : 
9169			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9169			;                                                                             : 
9169			; Stack frame                                                                 : 
9169			;       |             |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     BC      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     DE      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     IX      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |  prev_free  |                                                       : 
9169			;   +4  +-------------+                                                       : 
9169			;       |  this_free  |                                                       : 
9169			;   +2  +-------------+                                                       : 
9169			;       |  next_free  |                                                       : 
9169			;   +0  +-------------+                                                       : 
9169			;       |             |                                                       : 
9169			;                                                                             : 
9169			;------------------------------------------------------------------------------ 
9169			 
9169			 
9169			;malloc: 
9169			; 
9169			;	SAVESP ON 1 
9169			; 
9169			;	call malloc_code 
9169			; 
9169			;	CHECKSP ON 1 
9169			;	ret 
9169			 
9169			 
9169			malloc: 
9169 c5			      push  BC 
916a d5			      push  DE 
916b dd e5		      push  IX 
916d			if DEBUG_FORTH_MALLOC_HIGH 
916d			call malloc_guard_entry 
916d			endif 
916d			 
916d					if DEBUG_FORTH_MALLOC 
916d						DMARK "mal" 
916d						CALLMONITOR 
916d					endif 
916d 7c			      ld    A, H                    ; Exit if no space requested 
916e b5			      or    L 
916f ca 2e 92		      jp    Z, malloc_early_exit 
9172			 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			; 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			 
9172			 
9172			 
9172			 
9172					if DEBUG_FORTH_MALLOC 
9172						DMARK "maA" 
9172						CALLMONITOR 
9172					endif 
9172			      ; Set up stack frame 
9172 eb			      ex    DE, HL 
9173 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9176 39			      add   HL, SP 
9177 f9			      ld    SP, HL 
9178 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
917c dd 39		      add   IX, SP 
917e			 
917e			      ; Setup initial state 
917e 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
9181 19			      add   HL, DE 
9182			 
9182 44			      ld    B, H                    ; Move want to BC 
9183 4d			      ld    C, L 
9184			 
9184 21 58 db		      ld    HL, free_list           ; Store prev_free ptr to stack 
9187 dd 75 04		      ld    (IX+4), L 
918a dd 74 05		      ld    (IX+5), H 
918d			 
918d 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
918e 23			      inc   HL 
918f 56			      ld    D, (HL) 
9190 dd 73 02		      ld    (IX+2), E 
9193 dd 72 03		      ld    (IX+3), D 
9196 eb			      ex    DE, HL                  ; this_free ptr into HL 
9197			 
9197					if DEBUG_FORTH_MALLOC 
9197						DMARK "maB" 
9197						CALLMONITOR 
9197					endif 
9197			      ; Loop through free block list to find some space 
9197			malloc_find_space: 
9197 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
9198 23			      inc   HL 
9199 56			      ld    D, (HL) 
919a			 
919a 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
919b b3			      or    E 
919c ca 28 92		      jp    Z, malloc_no_space 
919f			 
919f dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91a2 dd 72 01		      ld    (IX+1), D 
91a5			 
91a5			      ; Does this block have enough space to make the allocation? 
91a5 23			      inc   HL                      ; Load free block size into DE 
91a6 5e			      ld    E, (HL) 
91a7 23			      inc   HL 
91a8 56			      ld    D, (HL) 
91a9			 
91a9 eb			      ex    DE, HL                  ; Check size of block against want 
91aa b7			      or    A                       ; Ensure carry flag clear 
91ab ed 42		      sbc   HL, BC 
91ad e5			      push  HL                      ; Store the result for later (new block size) 
91ae			 
91ae ca fd 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91b1 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91b3			 
91b3			      ; this_free block is not big enough, setup ptrs to test next free block 
91b3 e1			      pop   HL                      ; Discard previous result 
91b4			 
91b4 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91b7 dd 66 03		      ld    H, (IX+3) 
91ba dd 75 04		      ld    (IX+4), L 
91bd dd 74 05		      ld    (IX+5), H 
91c0			 
91c0 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91c3 dd 66 01		      ld    H, (IX+1) 
91c6 dd 75 02		      ld    (IX+2), L 
91c9 dd 74 03		      ld    (IX+3), H 
91cc			 
91cc					if DEBUG_FORTH_MALLOC 
91cc						DMARK "MA>" 
91cc						CALLMONITOR 
91cc					endif 
91cc 18 c9		      jr    malloc_find_space 
91ce			 
91ce			      ; split a bigger block into two - requested size and remaining size 
91ce			malloc_alloc_split: 
91ce					if DEBUG_FORTH_MALLOC 
91ce						DMARK "MAs" 
91ce						CALLMONITOR 
91ce					endif 
91ce eb			      ex    DE, HL                  ; Calculate address of new free block 
91cf 2b			      dec   HL 
91d0 2b			      dec   HL 
91d1 2b			      dec   HL 
91d2 09			      add   HL, BC 
91d3			 
91d3			      ; Create a new block and point it at next_free 
91d3 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
91d6 dd 56 01		      ld    D, (IX+1) 
91d9			 
91d9 73			      ld    (HL), E                 ; Store next_free ptr into new block 
91da 23			      inc   HL 
91db 72			      ld    (HL), D 
91dc			 
91dc d1			      pop   DE                      ; Store size of new block into new block 
91dd 23			      inc   HL 
91de 73			      ld    (HL), E 
91df 23			      inc   HL 
91e0 72			      ld    (HL), D 
91e1			 
91e1			      ; Update this_free ptr to point to new block 
91e1 2b			      dec   HL 
91e2 2b			      dec   HL 
91e3 2b			      dec   HL 
91e4			 
91e4 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
91e7 dd 56 03		      ld    D, (IX+3) 
91ea			 
91ea dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
91ed dd 74 03		      ld    (IX+3), H 
91f0			 
91f0			      ; Modify this_free block to be allocation 
91f0 eb			      ex    DE, HL 
91f1 af			      xor   A                       ; Null the next block ptr of allocated block 
91f2 77			      ld    (HL), A 
91f3 23			      inc   HL 
91f4 77			      ld    (HL), A 
91f5			 
91f5 23			      inc   HL                      ; Store want size into allocated block 
91f6 71			      ld    (HL), C 
91f7 23			      inc   HL 
91f8 70			      ld    (HL), B 
91f9 23			      inc   HL 
91fa e5			      push  HL                      ; Address of allocation to return 
91fb			 
91fb 18 19		      jr    malloc_update_links 
91fd			 
91fd			malloc_alloc_fit: 
91fd e1			      pop   HL                      ; Dont need new block size, want is exact fit 
91fe			 
91fe					if DEBUG_FORTH_MALLOC 
91fe						DMARK "MAf" 
91fe						CALLMONITOR 
91fe					endif 
91fe			      ; Modify this_free block to be allocation 
91fe eb			      ex    DE, HL 
91ff 2b			      dec   HL 
9200 2b			      dec   HL 
9201 2b			      dec   HL 
9202			 
9202 af			      xor   A                       ; Null the next block ptr of allocated block 
9203 77			      ld    (HL), A 
9204 23			      inc   HL 
9205 77			      ld    (HL), A 
9206			 
9206 23			      inc   HL                      ; Store address of allocation to return 
9207 23			      inc   HL 
9208 23			      inc   HL 
9209 e5			      push  HL 
920a			 
920a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
920a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
920d dd 66 01		      ld    H, (IX+1) 
9210			 
9210 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9213 dd 74 03		      ld    (IX+3), H 
9216			 
9216			 
9216			malloc_update_links: 
9216			      ; Update prev_free ptr to point to this_free 
9216 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9219 dd 66 05		      ld    H, (IX+5) 
921c			 
921c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
921f dd 56 03		      ld    D, (IX+3) 
9222			 
9222 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9223 23			      inc   HL 
9224 72			      ld    (HL), D 
9225			 
9225					if DEBUG_FORTH_MALLOC 
9225						DMARK "Mul" 
9225						CALLMONITOR 
9225					endif 
9225			      ; Clear the Z flag to indicate successful allocation 
9225 7a			      ld    A, D 
9226 b3			      or    E 
9227			 
9227 d1			      pop   DE                      ; Address of allocation 
9228					if DEBUG_FORTH_MALLOC 
9228						DMARK "MAu" 
9228						CALLMONITOR 
9228					endif 
9228			 
9228			malloc_no_space: 
9228 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
922b 39			      add   HL, SP 
922c f9			      ld    SP, HL 
922d			 
922d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
922e					if DEBUG_FORTH_MALLOC 
922e						DMARK "MAN" 
922e						CALLMONITOR 
922e					endif 
922e			 
922e			malloc_early_exit: 
922e					if DEBUG_FORTH_MALLOC 
922e						DMARK "MAx" 
922e						CALLMONITOR 
922e					endif 
922e dd e1		      pop   IX 
9230 d1			      pop   DE 
9231 c1			      pop   BC 
9232			 
9232			if DEBUG_FORTH_MALLOC_HIGH 
9232			call malloc_guard_exit 
9232			call malloc_guard_zerolen 
9232			endif 
9232 c9			      ret 
9233			 
9233			 
9233			;------------------------------------------------------------------------------ 
9233			;     free                                                                    : 
9233			;                                                                             : 
9233			; Description                                                                 : 
9233			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9233			;     returned by malloc, otherwise the behaviour is undefined.               : 
9233			;                                                                             : 
9233			;     Where possible, directly adjacent free blocks will be merged together   : 
9233			;     into larger blocks to help ensure that the heap does not become         : 
9233			;     excessively fragmented.                                                 : 
9233			;                                                                             : 
9233			;     free does not clear or set any other value into the freed space, and    : 
9233			;     therefore its contents may be visible through subsequent malloc's. The  : 
9233			;     caller should clear the freed space as required.                        : 
9233			;                                                                             : 
9233			;     This implementation of free uses the stack exclusively, and is          : 
9233			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9233			;     advisable to disable interrupts before calling free, and recommended    : 
9233			;     to avoid the use of free inside ISRs in general.                        : 
9233			;                                                                             : 
9233			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9233			;                                                                             : 
9233			; Parameters                                                                  : 
9233			;     HL  Pointer to address of first byte of allocation to be freed          : 
9233			;                                                                             : 
9233			; Returns                                                                     : 
9233			;     Nothing                                                                 : 
9233			;                                                                             : 
9233			; Stack frame                                                                 : 
9233			;       |             |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     BC      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     DE      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     IX      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |  prev_free  |                                                       : 
9233			;   +2  +-------------+                                                       : 
9233			;       |  next_free  |                                                       : 
9233			;   +0  +-------------+                                                       : 
9233			;       |             |                                                       : 
9233			;                                                                             : 
9233			;------------------------------------------------------------------------------ 
9233			free: 
9233 c5			      push  BC 
9234 d5			      push  DE 
9235 dd e5		      push  IX 
9237			 
9237 7c			      ld    A, H                    ; Exit if ptr is null 
9238 b5			      or    L 
9239 ca fd 92		      jp    Z, free_early_exit 
923c			 
923c			      ; Set up stack frame 
923c eb			      ex    DE, HL 
923d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9240 39			      add   HL, SP 
9241 f9			      ld    SP, HL 
9242 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9246 dd 39		      add   IX, SP 
9248			 
9248			      ; The address in HL points to the start of the useable allocated space, 
9248			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9248			      ; address of the block itself. 
9248 eb			      ex    DE, HL 
9249 11 fc ff		      ld    DE, -4 
924c 19			      add   HL, DE 
924d			 
924d			      ; An allocated block must have a null next block pointer in it 
924d 7e			      ld    A, (HL) 
924e 23			      inc   HL 
924f b6			      or    (HL) 
9250 c2 f8 92		      jp    NZ, free_done 
9253			 
9253 2b			      dec   HL 
9254			 
9254 44			      ld    B, H                    ; Copy HL to BC 
9255 4d			      ld    C, L 
9256			 
9256			      ; Loop through the free list to find the first block with an address 
9256			      ; higher than the block being freed 
9256 21 58 db		      ld    HL, free_list 
9259			 
9259			free_find_higher_block: 
9259 5e			      ld    E, (HL)                 ; Load next ptr from free block 
925a 23			      inc   HL 
925b 56			      ld    D, (HL) 
925c 2b			      dec   HL 
925d			 
925d dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9260 dd 72 01		      ld    (IX+1), D 
9263 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
9266 dd 74 03		      ld    (IX+3), H 
9269			 
9269 78			      ld    A, B                    ; Check if DE is greater than BC 
926a ba			      cp    D                       ; Compare MSB first 
926b 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
926d 30 04		      jr    NC, free_find_higher_block_skip 
926f 79			      ld    A, C 
9270 bb			      cp    E                       ; Then compare LSB 
9271 38 08		      jr    C, free_found_higher_block 
9273			 
9273			free_find_higher_block_skip: 
9273 7a			      ld    A, D                    ; Reached the end of the free list? 
9274 b3			      or    E 
9275 ca f8 92		      jp    Z, free_done 
9278			 
9278 eb			      ex    DE, HL 
9279			 
9279 18 de		      jr    free_find_higher_block 
927b			 
927b			free_found_higher_block: 
927b			      ; Insert freed block between prev and next free blocks 
927b 71			      ld    (HL), C                 ; Point prev free block to freed block 
927c 23			      inc   HL 
927d 70			      ld    (HL), B 
927e			 
927e 60			      ld    H, B                    ; Point freed block at next free block 
927f 69			      ld    L, C 
9280 73			      ld    (HL), E 
9281 23			      inc   HL 
9282 72			      ld    (HL), D 
9283			 
9283			      ; Check if the freed block is adjacent to the next free block 
9283 23			      inc   HL                      ; Load size of freed block into HL 
9284 5e			      ld    E, (HL) 
9285 23			      inc   HL 
9286 56			      ld    D, (HL) 
9287 eb			      ex    DE, HL 
9288			 
9288 09			      add   HL, BC                  ; Add addr of freed block and its size 
9289			 
9289 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
928c dd 56 01		      ld    D, (IX+1) 
928f			 
928f b7			      or    A                       ; Clear the carry flag 
9290 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9292 20 22		      jr    NZ, free_check_adjacent_to_prev 
9294			 
9294			      ; Freed block is adjacent to next, merge into one bigger block 
9294 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
9295 5e			      ld    E, (HL) 
9296 23			      inc   HL 
9297 56			      ld    D, (HL) 
9298 e5			      push  HL                      ; Save ptr to next block for later 
9299			 
9299 60			      ld    H, B                    ; Store ptr from next block into freed block 
929a 69			      ld    L, C 
929b 73			      ld    (HL), E 
929c 23			      inc   HL 
929d 72			      ld    (HL), D 
929e			 
929e e1			      pop   HL                      ; Restore ptr to next block 
929f 23			      inc   HL                      ; Load size of next block into DE 
92a0 5e			      ld    E, (HL) 
92a1 23			      inc   HL 
92a2 56			      ld    D, (HL) 
92a3 d5			      push  DE                      ; Save next block size for later 
92a4			 
92a4 60			      ld    H, B                    ; Load size of freed block into HL 
92a5 69			      ld    L, C 
92a6 23			      inc   HL 
92a7 23			      inc   HL 
92a8 5e			      ld    E, (HL) 
92a9 23			      inc   HL 
92aa 56			      ld    D, (HL) 
92ab eb			      ex    DE, HL 
92ac			 
92ac d1			      pop   DE                      ; Restore size of next block 
92ad 19			      add   HL, DE                  ; Add sizes of both blocks 
92ae eb			      ex    DE, HL 
92af			 
92af 60			      ld    H, B                    ; Store new bigger size into freed block 
92b0 69			      ld    L, C 
92b1 23			      inc   HL 
92b2 23			      inc   HL 
92b3 73			      ld    (HL), E 
92b4 23			      inc   HL 
92b5 72			      ld    (HL), D 
92b6			 
92b6			free_check_adjacent_to_prev: 
92b6			      ; Check if the freed block is adjacent to the prev free block 
92b6 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92b9 dd 66 03		      ld    H, (IX+3) 
92bc			 
92bc 23			      inc   HL                      ; Size of prev free block into DE 
92bd 23			      inc   HL 
92be 5e			      ld    E, (HL) 
92bf 23			      inc   HL 
92c0 56			      ld    D, (HL) 
92c1 2b			      dec   HL 
92c2 2b			      dec   HL 
92c3 2b			      dec   HL 
92c4			 
92c4 19			      add   HL, DE                  ; Add prev block addr and size 
92c5			 
92c5 b7			      or    A                       ; Clear the carry flag 
92c6 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
92c8 20 2e		      jr    NZ, free_done 
92ca			 
92ca			      ; Freed block is adjacent to prev, merge into one bigger block 
92ca 60			      ld    H, B                    ; Load next ptr from freed block into DE 
92cb 69			      ld    L, C 
92cc 5e			      ld    E, (HL) 
92cd 23			      inc   HL 
92ce 56			      ld    D, (HL) 
92cf e5			      push  HL                      ; Save freed block ptr for later 
92d0			 
92d0 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
92d3 dd 66 03		      ld    H, (IX+3) 
92d6 73			      ld    (HL), E 
92d7 23			      inc   HL 
92d8 72			      ld    (HL), D 
92d9			 
92d9 e1			      pop   HL                      ; Restore freed block ptr 
92da 23			      inc   HL                      ; Load size of freed block into DE 
92db 5e			      ld    E, (HL) 
92dc 23			      inc   HL 
92dd 56			      ld    D, (HL) 
92de d5			      push  DE                      ; Save freed block size for later 
92df			 
92df dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
92e2 dd 66 03		      ld    H, (IX+3) 
92e5 23			      inc   HL 
92e6 23			      inc   HL 
92e7 5e			      ld    E, (HL) 
92e8 23			      inc   HL 
92e9 56			      ld    D, (HL) 
92ea			 
92ea e1			      pop   HL                      ; Add sizes of both blocks 
92eb 19			      add   HL, DE 
92ec eb			      ex    DE, HL 
92ed			 
92ed dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
92f0 dd 66 03		      ld    H, (IX+3) 
92f3 23			      inc   HL 
92f4 23			      inc   HL 
92f5 73			      ld    (HL), E 
92f6 23			      inc   HL 
92f7 72			      ld    (HL), D 
92f8			 
92f8			free_done: 
92f8 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
92fb 39			      add   HL, SP 
92fc f9			      ld    SP, HL 
92fd			 
92fd			free_early_exit: 
92fd dd e1		      pop   IX 
92ff d1			      pop   DE 
9300 c1			      pop   BC 
9301			 
9301 c9			      ret 
9302			 
9302			; moved to firmware.asm 
9302			; 
9302			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9302			;                  .dw   0 
9302			 
9302			 
9302			endif 
9302			 
9302			 
9302			if MALLOC_3 
9302			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9302			;heap_start        .equ  0x9000      ; Starting address of heap 
9302			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9302			; 
9302			 ;     .org 0 
9302			  ;    jp    main 
9302			; 
9302			; 
9302			 ;     .org  0x100 
9302			;main: 
9302			 ;     ld    HL, 0x8100 
9302			  ;    ld    SP, HL 
9302			; 
9302			;      call  heap_init 
9302			 
9302			      ; Make some allocations 
9302			;      ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9004 
9302			; 
9302			 ;     ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9014 
9302			 
9302			;      ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9024 
9302			 
9302			      ; Free some allocations 
9302			;      ld    HL, 0x9014 
9302			;      call  free 
9302			 
9302			;      ld    HL, 0x9004 
9302			;      call  free 
9302			; 
9302			;      ld    HL, 0x9024 
9302			;      call  free 
9302			 
9302			 
9302			 ;     halt 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     heap_init                                                               : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Initialise the heap and make it ready for malloc and free operations.   : 
9302			;                                                                             : 
9302			;     The heap is maintained as a linked list, starting with an initial       : 
9302			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9302			;     the first free block in the heap. Each block then points to the next    : 
9302			;     free block within the heap, and the free list ends at the first block   : 
9302			;     with a null pointer to the next free block.                             : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     Inputs are compile-time only. Two defines which specify the starting    : 
9302			;     address of the heap and its size are required, along with a memory      : 
9302			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9302			;     principally stores a pointer to the first free block in the heap.       : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     Nothing                                                                 : 
9302			;------------------------------------------------------------------------------ 
9302			heap_init: 
9302			      push  HL 
9302			 
9302			      ; Initialise free list struct 
9302			      ld    HL, heap_start 
9302			      ld    (free_list), HL 
9302			      ld    HL, 0 
9302			      ld    (free_list+2), HL 
9302			 
9302			      ; Insert first free block at bottom of heap, consumes entire heap 
9302			      ld    HL, heap_start+heap_size-4 
9302			      ld    (heap_start), HL        ; Next block (end of free list) 
9302			      ld    HL, heap_size-4 
9302			      ld    (heap_start+2), HL      ; Block size 
9302			 
9302			      ; Insert end of free list block at top of heap - two null words will 
9302			      ; terminate the free list 
9302			      ld    HL, 0 
9302			      ld    (heap_start+heap_size-2), HL 
9302			      ld    (heap_start+heap_size-4), HL 
9302			 
9302			      pop   HL 
9302			 
9302			      ret 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     malloc                                                                  : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Allocates the wanted space from the heap and returns the address of the : 
9302			;     first useable byte of the allocation.                                   : 
9302			;                                                                             : 
9302			;     Allocations can happen in one of two ways:                              : 
9302			;                                                                             : 
9302			;     1. A free block may be found which is the exact size wanted. In this    : 
9302			;        case the block is removed from the free list and retuedn to the      : 
9302			;        caller.                                                              : 
9302			;     2. A free block may be found which is larger than the size wanted. In   : 
9302			;        this case, the larger block is split into two. The first portion of  : 
9302			;        this block will become the requested space by the malloc call and    : 
9302			;        is returned to the caller. The second portion becomes a new free     : 
9302			;        block, and the free list is adjusted to maintain continuity via this : 
9302			;        newly created block.                                                 : 
9302			;                                                                             : 
9302			;     malloc does not set any initial value in the allocated space, the       : 
9302			;     caller is required to do this as required.                              : 
9302			;                                                                             : 
9302			;     This implementation of malloc uses the stack exclusively, and is        : 
9302			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9302			;     advisable to disable interrupts before calling malloc, and recommended  : 
9302			;     to avoid the use of malloc inside ISRs in general.                      : 
9302			;                                                                             : 
9302			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     HL  Number of bytes wanted                                              : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     HL  Address of the first useable byte of the allocation                 : 
9302			;                                                                             : 
9302			; Flags                                                                       : 
9302			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9302			;                                                                             : 
9302			; Stack frame                                                                 : 
9302			;       |             |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     BC      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     DE      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     IX      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |  prev_free  |                                                       : 
9302			;   +4  +-------------+                                                       : 
9302			;       |  this_free  |                                                       : 
9302			;   +2  +-------------+                                                       : 
9302			;       |  next_free  |                                                       : 
9302			;   +0  +-------------+                                                       : 
9302			;       |             |                                                       : 
9302			;                                                                             : 
9302			;------------------------------------------------------------------------------ 
9302			malloc: 
9302			      push  BC 
9302			      push  DE 
9302			      push  IX 
9302			 
9302			      ld    A, H                    ; Exit if no space requested 
9302			      or    L 
9302			      jp    Z, malloc_early_exit 
9302			 
9302			      ; Set up stack frame 
9302			      ex    DE, HL 
9302			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			      ld    IX, 0                   ; Use IX as a frame pointer 
9302			      add   IX, SP 
9302			 
9302			      ; Setup initial state 
9302			      ld    HL, 4                   ; want must also include space used by block struct 
9302			      add   HL, DE 
9302			 
9302			      ld    B, H                    ; Move want to BC 
9302			      ld    C, L 
9302			 
9302			      ld    HL, free_list           ; Store prev_free ptr to stack 
9302			      ld    (IX+4), L 
9302			      ld    (IX+5), H 
9302			 
9302			      ld    E, (HL)                 ; Store this_free ptr to stack 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ld    (IX+2), E 
9302			      ld    (IX+3), D 
9302			      ex    DE, HL                  ; this_free ptr into HL 
9302			 
9302			      ; Loop through free block list to find some space 
9302			malloc_find_space: 
9302			      ld    E, (HL)                 ; Load next_free ptr into DE 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9302			      or    E 
9302			      jp    Z, malloc_no_space 
9302			 
9302			      ld    (IX+0), E               ; Store next_free ptr to stack 
9302			      ld    (IX+1), D 
9302			 
9302			      ; Does this block have enough space to make the allocation? 
9302			      inc   HL                      ; Load free block size into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      ex    DE, HL                  ; Check size of block against want 
9302			      or    A                       ; Ensure carry flag clear 
9302			      sbc   HL, BC 
9302			      push  HL                      ; Store the result for later (new block size) 
9302			 
9302			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9302			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9302			 
9302			      ; this_free block is not big enough, setup ptrs to test next free block 
9302			      pop   HL                      ; Discard previous result 
9302			 
9302			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9302			      ld    H, (IX+3) 
9302			      ld    (IX+4), L 
9302			      ld    (IX+5), H 
9302			 
9302			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9302			      ld    H, (IX+1) 
9302			      ld    (IX+2), L 
9302			      ld    (IX+3), H 
9302			 
9302			      jr    malloc_find_space 
9302			 
9302			      ; split a bigger block into two - requested size and remaining size 
9302			malloc_alloc_split: 
9302			      ex    DE, HL                  ; Calculate address of new free block 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			      add   HL, BC 
9302			 
9302			      ; Create a new block and point it at next_free 
9302			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9302			      ld    D, (IX+1) 
9302			 
9302			      ld    (HL), E                 ; Store next_free ptr into new block 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   DE                      ; Store size of new block into new block 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Update this_free ptr to point to new block 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9302			      ld    D, (IX+3) 
9302			 
9302			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9302			      ld    (IX+3), H 
9302			 
9302			      ; Modify this_free block to be allocation 
9302			      ex    DE, HL 
9302			      xor   A                       ; Null the next block ptr of allocated block 
9302			      ld    (HL), A 
9302			      inc   HL 
9302			      ld    (HL), A 
9302			 
9302			      inc   HL                      ; Store want size into allocated block 
9302			      ld    (HL), C 
9302			      inc   HL 
9302			      ld    (HL), B 
9302			      inc   HL 
9302			      push  HL                      ; Address of allocation to return 
9302			 
9302			      jr    malloc_update_links 
9302			 
9302			malloc_alloc_fit: 
9302			      pop   HL                      ; Dont need new block size, want is exact fit 
9302			 
9302			      ; Modify this_free block to be allocation 
9302			      ex    DE, HL 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      xor   A                       ; Null the next block ptr of allocated block 
9302			      ld    (HL), A 
9302			      inc   HL 
9302			      ld    (HL), A 
9302			 
9302			      inc   HL                      ; Store address of allocation to return 
9302			      inc   HL 
9302			      inc   HL 
9302			      push  HL 
9302			 
9302			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9302			      ld    L, (IX+0)               ; next_free to HL 
9302			      ld    H, (IX+1) 
9302			 
9302			      ld    (IX+2), L               ; HL to this_free 
9302			      ld    (IX+3), H 
9302			 
9302			 
9302			malloc_update_links: 
9302			      ; Update prev_free ptr to point to this_free 
9302			      ld    L, (IX+4)               ; prev_free ptr to HL 
9302			      ld    H, (IX+5) 
9302			 
9302			      ld    E, (IX+2)               ; this_free ptr to DE 
9302			      ld    D, (IX+3) 
9302			 
9302			      ld    (HL), E                 ; this_free ptr into prev_free 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Clear the Z flag to indicate successful allocation 
9302			      ld    A, D 
9302			      or    E 
9302			 
9302			      pop   DE                      ; Address of allocation 
9302			 
9302			malloc_no_space: 
9302			      ld    HL, 6                   ; Clean up stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			 
9302			      ex    DE, HL                  ; Alloc addr into HL for return 
9302			 
9302			malloc_early_exit: 
9302			      pop   IX 
9302			      pop   DE 
9302			      pop   BC 
9302			 
9302			      ret 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     free                                                                    : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9302			;     returned by malloc, otherwise the behaviour is undefined.               : 
9302			;                                                                             : 
9302			;     Where possible, directly adjacent free blocks will be merged together   : 
9302			;     into larger blocks to help ensure that the heap does not become         : 
9302			;     excessively fragmented.                                                 : 
9302			;                                                                             : 
9302			;     free does not clear or set any other value into the freed space, and    : 
9302			;     therefore its contents may be visible through subsequent malloc's. The  : 
9302			;     caller should clear the freed space as required.                        : 
9302			;                                                                             : 
9302			;     This implementation of free uses the stack exclusively, and is          : 
9302			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9302			;     advisable to disable interrupts before calling free, and recommended    : 
9302			;     to avoid the use of free inside ISRs in general.                        : 
9302			;                                                                             : 
9302			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     HL  Pointer to address of first byte of allocation to be freed          : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     Nothing                                                                 : 
9302			;                                                                             : 
9302			; Stack frame                                                                 : 
9302			;       |             |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     BC      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     DE      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     IX      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |  prev_free  |                                                       : 
9302			;   +2  +-------------+                                                       : 
9302			;       |  next_free  |                                                       : 
9302			;   +0  +-------------+                                                       : 
9302			;       |             |                                                       : 
9302			;                                                                             : 
9302			;------------------------------------------------------------------------------ 
9302			free: 
9302			      push  BC 
9302			      push  DE 
9302			      push  IX 
9302			 
9302			      ld    A, H                    ; Exit if ptr is null 
9302			      or    L 
9302			      jp    Z, free_early_exit 
9302			 
9302			      ; Set up stack frame 
9302			      ex    DE, HL 
9302			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			      ld    IX, 0                   ; Use IX as a frame pointer 
9302			      add   IX, SP 
9302			 
9302			      ; The address in HL points to the start of the useable allocated space, 
9302			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9302			      ; address of the block itself. 
9302			      ex    DE, HL 
9302			      ld    DE, -4 
9302			      add   HL, DE 
9302			 
9302			      ; An allocated block must have a null next block pointer in it 
9302			      ld    A, (HL) 
9302			      inc   HL 
9302			      or    (HL) 
9302			      jp    NZ, free_done 
9302			 
9302			      dec   HL 
9302			 
9302			      ld    B, H                    ; Copy HL to BC 
9302			      ld    C, L 
9302			 
9302			      ; Loop through the free list to find the first block with an address 
9302			      ; higher than the block being freed 
9302			      ld    HL, free_list 
9302			 
9302			free_find_higher_block: 
9302			      ld    E, (HL)                 ; Load next ptr from free block 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      dec   HL 
9302			 
9302			      ld    (IX+0), E               ; Save ptr to next free block 
9302			      ld    (IX+1), D 
9302			      ld    (IX+2), L               ; Save ptr to prev free block 
9302			      ld    (IX+3), H 
9302			 
9302			      ld    A, B                    ; Check if DE is greater than BC 
9302			      cp    D                       ; Compare MSB first 
9302			      jr    Z, $+4                  ; MSB the same, compare LSB 
9302			      jr    NC, free_find_higher_block_skip 
9302			      ld    A, C 
9302			      cp    E                       ; Then compare LSB 
9302			      jr    C, free_found_higher_block 
9302			 
9302			free_find_higher_block_skip: 
9302			      ld    A, D                    ; Reached the end of the free list? 
9302			      or    E 
9302			      jp    Z, free_done 
9302			 
9302			      ex    DE, HL 
9302			 
9302			      jr    free_find_higher_block 
9302			 
9302			free_found_higher_block: 
9302			      ; Insert freed block between prev and next free blocks 
9302			      ld    (HL), C                 ; Point prev free block to freed block 
9302			      inc   HL 
9302			      ld    (HL), B 
9302			 
9302			      ld    H, B                    ; Point freed block at next free block 
9302			      ld    L, C 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Check if the freed block is adjacent to the next free block 
9302			      inc   HL                      ; Load size of freed block into HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ex    DE, HL 
9302			 
9302			      add   HL, BC                  ; Add addr of freed block and its size 
9302			 
9302			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9302			      ld    D, (IX+1) 
9302			 
9302			      or    A                       ; Clear the carry flag 
9302			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9302			      jr    NZ, free_check_adjacent_to_prev 
9302			 
9302			      ; Freed block is adjacent to next, merge into one bigger block 
9302			      ex    DE, HL                  ; Load next ptr from next block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  HL                      ; Save ptr to next block for later 
9302			 
9302			      ld    H, B                    ; Store ptr from next block into freed block 
9302			      ld    L, C 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   HL                      ; Restore ptr to next block 
9302			      inc   HL                      ; Load size of next block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  DE                      ; Save next block size for later 
9302			 
9302			      ld    H, B                    ; Load size of freed block into HL 
9302			      ld    L, C 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ex    DE, HL 
9302			 
9302			      pop   DE                      ; Restore size of next block 
9302			      add   HL, DE                  ; Add sizes of both blocks 
9302			      ex    DE, HL 
9302			 
9302			      ld    H, B                    ; Store new bigger size into freed block 
9302			      ld    L, C 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			free_check_adjacent_to_prev: 
9302			      ; Check if the freed block is adjacent to the prev free block 
9302			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9302			      ld    H, (IX+3) 
9302			 
9302			      inc   HL                      ; Size of prev free block into DE 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      add   HL, DE                  ; Add prev block addr and size 
9302			 
9302			      or    A                       ; Clear the carry flag 
9302			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9302			      jr    NZ, free_done 
9302			 
9302			      ; Freed block is adjacent to prev, merge into one bigger block 
9302			      ld    H, B                    ; Load next ptr from freed block into DE 
9302			      ld    L, C 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  HL                      ; Save freed block ptr for later 
9302			 
9302			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9302			      ld    H, (IX+3) 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   HL                      ; Restore freed block ptr 
9302			      inc   HL                      ; Load size of freed block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  DE                      ; Save freed block size for later 
9302			 
9302			      ld    L, (IX+2)               ; Load size of prev block into DE 
9302			      ld    H, (IX+3) 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      pop   HL                      ; Add sizes of both blocks 
9302			      add   HL, DE 
9302			      ex    DE, HL 
9302			 
9302			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9302			      ld    H, (IX+3) 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			free_done: 
9302			      ld    HL, 4                   ; Clean up stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			 
9302			free_early_exit: 
9302			      pop   IX 
9302			      pop   DE 
9302			      pop   BC 
9302			 
9302			      ret 
9302			 
9302			 
9302			;      .org 0x8000 
9302			; 
9302			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9302			 ;                 .dw   0 
9302			 
9302			endif 
9302			 
9302			 
9302			if MALLOC_4 
9302			 
9302			; My memory allocation code. Very very simple.... 
9302			; allocate space under 250 chars 
9302			 
9302			heap_init: 
9302				; init start of heap as zero 
9302				;  
9302			 
9302				ld hl, heap_start 
9302				ld a, 0 
9302				ld (hl), a      ; empty block 
9302				inc hl 
9302				ld a, 0 
9302				ld (hl), a      ; length of block 
9302				; write end of list 
9302				inc hl 
9302				ld a,(hl) 
9302				inc hl 
9302				ld a,(hl) 
9302				 
9302			 
9302				; init some malloc vars 
9302			 
9302				ld hl, 0 
9302				ld (free_list), hl       ; store last malloc location 
9302			 
9302				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9302				ld a, 0 
9302				ld (hl), a 
9302			 
9302			 
9302				ld hl, heap_start 
9302				;  
9302				  
9302				ret 
9302			 
9302			 
9302			;    free block marker 
9302			;    requested size  
9302			;    pointer to next block 
9302			;    .... 
9302			;    next block marker 
9302			 
9302			 
9302			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9302			; 
9302			 
9302			 
9302			malloc:  
9302				push de 
9302				push bc 
9302				push af 
9302			 
9302				; hl space required 
9302				 
9302				ld c, l    ; hold space   (TODO only a max of 255) 
9302			 
9302			;	inc c     ; TODO BUG need to fix memory leak on push str 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			 
9302			 
9302			 
9302				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9302			 
9302				ld a, (free_list+3) 
9302				cp 0 
9302				jr z, .contheap 
9302			 
9302				ld hl, (free_list)     ; get last alloc 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mrs" 
9302						CALLMONITOR 
9302					endif 
9302				jr .startalloc 
9302			 
9302			.contheap: 
9302				ld hl, heap_start 
9302			 
9302			.startalloc: 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mym" 
9302						CALLMONITOR 
9302					endif 
9302			.findblock: 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mmf" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302				ld a,(hl)  
9302				; if byte is zero then clear to use 
9302			 
9302				cp 0 
9302				jr z, .foundemptyblock 
9302			 
9302				; if byte is not clear 
9302				;     then byte is offset to next block 
9302			 
9302				inc hl 
9302				ld a, (hl) ; get size 
9302			.nextblock:	inc hl 
9302					ld e, (hl) 
9302					inc hl 
9302					ld d, (hl) 
9302					ex de, hl 
9302			;	inc hl  ; move past the store space 
9302			;	inc hl  ; move past zero index  
9302			 
9302				; TODO detect no more space 
9302			 
9302				push hl 
9302				ld de, heap_end 
9302				call cmp16 
9302				pop hl 
9302				jr nc, .nospace 
9302			 
9302				jr .findblock 
9302			 
9302			.nospace: ld hl, 0 
9302				jp .exit 
9302			 
9302			 
9302			.foundemptyblock:	 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mme" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			; TODO has block enough space if reusing??? 
9302			 
9302				;  
9302			 
9302			; see if this block has been previously used 
9302				inc hl 
9302				ld a, (hl) 
9302				dec hl 
9302				cp 0 
9302				jr z, .newblock 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "meR" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			; no reusing previously allocated block 
9302			 
9302			; is it smaller than previously used? 
9302				 
9302				inc hl    ; move to size 
9302				ld a, c 
9302				sub (hl)        ; we want c < (hl) 
9302				dec hl    ; move back to marker 
9302			        jr z, .findblock 
9302			 
9302				; update with the new size which should be lower 
9302			 
9302			        ;inc  hl   ; negate next move. move back to size  
9302			 
9302			.newblock: 
9302				; need to be at marker here 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "meN" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			 
9302				ld a, c 
9302			 
9302				ld (free_list+3), a	 ; flag resume from last malloc  
9302				ld (free_list), hl    ; save out last location 
9302			 
9302			 
9302				;inc a     ; space for length byte 
9302				ld (hl), a     ; save block in use marker 
9302			 
9302				inc hl   ; move to space marker 
9302				ld (hl), a    ; save new space 
9302			 
9302				inc hl   ; move to start of allocated area 
9302				 
9302			;	push hl     ; save where we are - 1  
9302			 
9302			;	inc hl  ; move past zero index  
9302				; skip space to set down new marker 
9302			 
9302				; provide some extra space for now 
9302			 
9302				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9302				inc a 
9302				inc a 
9302			 
9302				push hl   ; save where we are in the node block 
9302			 
9302				call addatohl 
9302			 
9302				; write linked list point 
9302			 
9302				pop de     ; get our node position 
9302				ex de, hl 
9302			 
9302				ld (hl), e 
9302				inc hl 
9302				ld (hl), d 
9302			 
9302				inc hl 
9302			 
9302				; now at start of allocated data so save pointer 
9302			 
9302				push hl 
9302			 
9302				; jump to position of next node and setup empty header in DE 
9302			 
9302				ex de, hl 
9302			 
9302			;	inc hl ; move past end of block 
9302			 
9302				ld a, 0 
9302				ld (hl), a   ; empty marker 
9302				inc hl 
9302				ld (hl), a   ; size 
9302				inc hl  
9302				ld (hl), a   ; ptr 
9302				inc hl 
9302				ld (hl), a   ; ptr 
9302			 
9302			 
9302				pop hl 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mmr" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			.exit: 
9302				pop af 
9302				pop bc 
9302				pop de  
9302				ret 
9302			 
9302			 
9302			 
9302			 
9302			free:  
9302				push hl 
9302				push af 
9302				; get address in hl 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "fre" 
9302						CALLMONITOR 
9302					endif 
9302				; data is at hl - move to block count 
9302				dec hl 
9302				dec hl    ; get past pointer 
9302				dec hl 
9302			 
9302				ld a, (hl)    ; need this for a validation check 
9302			 
9302				dec hl    ; move to block marker 
9302			 
9302				; now check that the block count and block marker are the same  
9302			        ; this checks that we are on a malloc node and not random memory 
9302			        ; OK a faint chance this could be a problem but rare - famous last words! 
9302			 
9302				ld c, a 
9302				ld a, (hl)    
9302			 
9302				cp c 
9302				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9302			 
9302				; yes good chance we are on a malloc node 
9302			 
9302				ld a, 0      
9302				ld (hl), a   ; mark as free 
9302			 
9302				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9302			 
9302			.freeignore:  
9302			 
9302				pop af 
9302				pop hl 
9302			 
9302				ret 
9302			 
9302			 
9302			 
9302			endif 
9302			 
9302			; eof 
# End of file firmware_memory.asm
9302			  
9302			; device C  
9302			if SOUND_ENABLE  
9302				include "firmware_sound.asm"  
9302			endif  
9302			  
9302			include "firmware_diags.asm"  
9302			; Hardware diags menu 
9302			 
9302			 
9302			config: 
9302			 
9302 3e 00			ld a, 0 
9304 21 32 93			ld hl, .configmn 
9307 cd a6 8a			call menu 
930a			 
930a fe 00			cp 0 
930c c8				ret z 
930d			 
930d fe 01			cp 1 
930f cc 60 93			call z, .savetostore 
9312			 
9312 fe 02			cp 2 
9314 cc 4c 93			call z, .selautoload 
9317 fe 03			cp 3 
9319 cc 42 93			call z, .disautoload 
931c fe 04			cp 4 
931e cc 56 93			call z, .selbank 
9321 fe 05			cp 5 
9323 cc 6a 93			call z, .debug_tog 
9326 fe 06			cp 6 
9328 cc ad 94			call z, .bpsgo 
932b fe 07			cp 7 
932d cc 90 93			call z, hardware_diags 
9330			 
9330 18 d0			jr config 
9332			 
9332			.configmn: 
9332 9e 96			dw prom_c3 
9334 b5 96			dw prom_c2 
9336 ca 96			dw prom_c2a 
9338 e0 96			dw prom_c2b 
933a			;	dw prom_c4 
933a fd 96			dw prom_m4 
933c 18 97			dw prom_m4b 
933e 20 97			dw prom_c1 
9340 00 00			dw 0 
9342				 
9342			 
9342			 
9342			 
9342			.disautoload: 
9342				if STORAGE_SE 
9342				ld a, $fe      ; bit 0 clear 
9342				ld (spi_device), a 
9342			 
9342				call storage_get_block_0 
9342			 
9342				ld a, 0 
9342				ld (store_page+STORE_0_AUTOFILE), a 
9342			 
9342					ld hl, 0 
9342					ld de, store_page 
9342				call storage_write_block	 ; save update 
9342				else 
9342			 
9342 21 2f 97			ld hl, prom_notav 
9345 11 45 97			ld de, prom_empty 
9348 cd 06 8a			call info_panel 
934b				endif 
934b			 
934b			 
934b c9				ret 
934c			 
934c			 
934c			 
934c			; Select auto start 
934c			 
934c			.selautoload: 
934c			 
934c				 
934c				if STORAGE_SE 
934c			 
934c					call config_dir 
934c				        ld hl, scratch 
934c					ld a, 0 
934c					call menu 
934c			 
934c					cp 0 
934c					ret z 
934c			 
934c					dec a 
934c			 
934c			 
934c					; locate menu option 
934c			 
934c					ld hl, scratch 
934c					call table_lookup 
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALl" 
934c						CALLMONITOR 
934c					endif 
934c					; with the pointer to the menu it, the byte following the zero term is the file id 
934c			 
934c					ld a, 0 
934c					ld bc, 50   ; max of bytes to look at 
934c					cpir  
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALb" 
934c						CALLMONITOR 
934c					endif 
934c					;inc hl 
934c			 
934c					ld a, (hl)   ; file id 
934c					 
934c				        ; save bank and file ids 
934c			 
934c					push af 
934c			 
934c			; TODO need to save to block 0 on bank 1	 
934c			 
934c					call storage_get_block_0 
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "AL0" 
934c						CALLMONITOR 
934c					endif 
934c					pop af 
934c			 
934c					ld (store_page+STORE_0_FILERUN),a 
934c					 
934c					; save bank id 
934c			 
934c					ld a,(spi_device) 
934c					ld (store_page+STORE_0_BANKRUN),a 
934c			 
934c					; enable auto run of store file 
934c			 
934c					ld a, 1 
934c					ld (store_page+STORE_0_AUTOFILE),a 
934c			 
934c					; save buffer 
934c			 
934c					ld hl, 0 
934c					ld de, store_page 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALw" 
934c						CALLMONITOR 
934c					endif 
934c				call storage_write_block	 ; save update 
934c			  
934c			 
934c			 
934c			 
934c					ld hl, scratch 
934c					call config_fdir 
934c			 
934c				else 
934c			 
934c 21 2f 97			ld hl, prom_notav 
934f 11 45 97			ld de, prom_empty 
9352 cd 06 8a			call info_panel 
9355			 
9355				endif 
9355 c9				ret 
9356			 
9356			 
9356			 
9356			; Select storage bank 
9356			 
9356			.selbank: 
9356			 
9356				if STORAGE_SE 
9356				else 
9356			 
9356 21 2f 97			ld hl, prom_notav 
9359 11 45 97			ld de, prom_empty 
935c cd 06 8a			call info_panel 
935f				endif 
935f				 
935f c9				ret 
9360			 
9360			if STORAGE_SE 
9360			 
9360			.config_ldir:   
9360				; Load storage bank labels into menu array 
9360			 
9360				 
9360			 
9360			 
9360				ret 
9360			 
9360			 
9360			endif 
9360			 
9360			 
9360			; Save user words to storage 
9360			 
9360			.savetostore: 
9360			 
9360				if STORAGE_SE 
9360			 
9360					call config_dir 
9360				        ld hl, scratch 
9360					ld a, 0 
9360					call menu 
9360					 
9360					ld hl, scratch 
9360					call config_fdir 
9360			 
9360				else 
9360			 
9360 21 2f 97			ld hl, prom_notav 
9363 11 45 97			ld de, prom_empty 
9366 cd 06 8a			call info_panel 
9369			 
9369				endif 
9369			 
9369 c9				ret 
936a			 
936a			 
936a			 
936a			if STORAGE_SE 
936a			 
936a			config_fdir: 
936a				; using the scratch dir go through and release the memory allocated for each string 
936a				 
936a				ld hl, scratch 
936a			.cfdir:	ld e,(hl) 
936a				inc hl 
936a				ld d,(hl) 
936a				inc hl 
936a			 
936a				ex de, hl 
936a				call ishlzero 
936a				ret z     ; return on null pointer 
936a				call free 
936a				ex de, hl 
936a				jr .cfdir 
936a			 
936a			 
936a				ret 
936a			 
936a			 
936a			config_dir: 
936a			 
936a				; for the config menus that need to build a directory of storage call this routine 
936a				; it will construct a menu in scratch to pass to menu 
936a			 
936a				; open storage device 
936a			 
936a				; execute DIR to build a list of files and their ids into scratch in menu format 
936a				; once the menu has finished then will need to call config_fdir to release the strings 
936a				 
936a				; c = number items 
936a			 
936a				 
936a				call storage_get_block_0 
936a			 
936a				ld hl, store_page     ; get current id count 
936a				ld b, (hl) 
936a				ld c, 0    ; count of files   
936a			 
936a			 
936a				ld hl, scratch 
936a				ld (store_tmp2), hl    ; location to poke strings 
936a			 
936a				; check for empty drive 
936a			 
936a				ld a, 0 
936a				cp b 
936a				jp z, .dirdone 
936a			 
936a				 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "Cdc" 
936a						CALLMONITOR 
936a					endif 
936a			 
936a			 
936a			.diritem:	 
936a				push bc 
936a				; for each of the current ids do a search for them and if found push to stack 
936a			 
936a					ld hl, STORE_BLOCK_PHY 
936a					ld d, 0		 ; look for extent 0 of block id as this contains file name 
936a					ld e,b 
936a			 
936a					call storage_findnextid 
936a			 
936a			 
936a					; if found hl will be non zero 
936a			 
936a					call ishlzero 
936a					jr z, .dirnotfound 
936a			 
936a					; increase count 
936a			 
936a					pop bc	 
936a					inc c 
936a					push bc 
936a					 
936a			 
936a					; get file header and push the file name 
936a			 
936a					ld de, store_page 
936a					call storage_read_block 
936a			 
936a					; push file id to stack 
936a				 
936a					ld a, (store_page) 
936a					ld h, 0 
936a					ld l, a 
936a			 
936a					;call forth_push_numhl 
936a					; TODO store id 
936a			 
936a					push hl 
936a			 
936a					; push extent count to stack  
936a				 
936a					ld hl, store_page+3 
936a			 
936a					; get file name length 
936a			 
936a					call strlenz   
936a			 
936a					inc hl   ; cover zero term 
936a					inc hl  ; stick the id at the end of the area 
936a			 
936a					push hl 
936a					pop bc    ; move length to bc 
936a			 
936a					call malloc 
936a			 
936a					; TODO save malloc area to scratch 
936a			 
936a					ex de, hl 
936a					ld hl, (store_tmp2) 
936a					ld (hl), e 
936a					inc hl 
936a					ld (hl), d 
936a					inc hl 
936a					ld (store_tmp2), hl 
936a			 
936a					 
936a			 
936a					;pop hl   ; get source 
936a			;		ex de, hl    ; swap aronund	 
936a			 
936a					ld hl, store_page+3 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "CFd" 
936a						CALLMONITOR 
936a					endif 
936a					ldir 
936a			 
936a					; de is past string, move back one and store id 
936a					 
936a					dec de 
936a			 
936a					; store file id 
936a			 
936a					pop hl 
936a					ex de,hl 
936a					ld (hl), e 
936a			 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "Cdi" 
936a						CALLMONITOR 
936a					endif 
936a					 
936a			.dirnotfound: 
936a					pop bc     
936a					djnz .diritem 
936a				 
936a			.dirdone:	 
936a			 
936a					ld a, 0 
936a					ld hl, (store_tmp2) 
936a					ld (hl), a 
936a					inc hl 
936a					ld (hl), a 
936a					inc hl 
936a					; push a count of the dir items found 
936a			 
936a			;		ld h, 0 
936a			;		ld l, c 
936a			 
936a				ret 
936a			 
936a			endif 
936a			 
936a			 
936a			; Settings 
936a			; Run  
936a			 
936a			 
936a			 
936a			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
936a			;;hd_menu2:   db "        2: Editor",0   
936a			;hd_menu2:   db "        2: Editor       6: Menu",0   
936a			;hd_menu3:   db "        3: Storage",0 
936a			;hd_menu4:   db "0=quit  4: Debug",0 
936a			;hd_don:     db "ON",0 
936a			;hd_doff:     db "OFF",0 
936a			; 
936a			; 
936a			; 
936a			;hardware_diags_old:       
936a			; 
936a			;.diagmenu: 
936a			;	call clear_display 
936a			;	ld a, display_row_1 
936a			;	ld de, hd_menu1 
936a			;	call str_at_display 
936a			; 
936a			;	ld a, display_row_2 
936a			;	ld de, hd_menu2 
936a			;	call str_at_display 
936a			; 
936a			;	ld a, display_row_3 
936a			;	ld de, hd_menu3 
936a			;	call str_at_display 
936a			; 
936a			;	ld a,  display_row_4 
936a			;	ld de, hd_menu4 
936a			;	call str_at_display 
936a			; 
936a			;	; display debug state 
936a			; 
936a			;	ld de, hd_don 
936a			;	ld a, (os_view_disable) 
936a			;	cp 0 
936a			;	jr z, .distog 
936a			;	ld de, hd_doff 
936a			;.distog: ld a, display_row_4+17 
936a			;	call str_at_display 
936a			; 
936a			;	call update_display 
936a			; 
936a			;	call cin_wait 
936a			; 
936a			; 
936a			; 
936a			;	cp '4' 
936a			;	jr nz, .diagn1 
936a			; 
936a			;	; debug toggle 
936a			; 
936a			;	ld a, (os_view_disable) 
936a			;	ld b, '*' 
936a			;	cp 0 
936a			;	jr z, .debtog 
936a			;	ld b, 0 
936a			;.debtog:	 
936a			;	ld a,b 
936a			;	ld (os_view_disable),a 
936a			; 
936a			;.diagn1: cp '0' 
936a			;	 ret z 
936a			; 
936a			;;	cp '1' 
936a			;;       jp z, matrix	 
936a			;;   TODO keyboard matrix test 
936a			; 
936a			;	cp '2' 
936a			;	jp z, .diagedit 
936a			; 
936a			;;	cp '6' 
936a			;;	jp z, .menutest 
936a			;;if ENABLE_BASIC 
936a			;;	cp '6' 
936a			;;	jp z, basic 
936a			;;endif 
936a			 ; 
936a			;	jp .diagmenu 
936a			; 
936a			; 
936a			;	ret 
936a			 
936a			 
936a			.debug_tog: 
936a 21 b1 93			ld hl, .menudebug 
936d				 
936d 3a 76 e4			ld a, (os_view_disable) 
9370 fe 2a			cp '*' 
9372 20 04			jr nz,.tdon  
9374 3e 01			ld a, 1 
9376 18 02			jr .tog1 
9378 3e 00		.tdon: ld a, 0 
937a			 
937a			.tog1: 
937a cd a6 8a			call menu 
937d fe 00			cp 0 
937f c8				ret z 
9380 fe 01			cp 1    ; disable debug 
9382 28 04			jr z, .dtog0 
9384 3e 2a			ld a, '*' 
9386 18 02			jr .dtogset 
9388 3e 00		.dtog0: ld a, 0 
938a 32 76 e4		.dtogset:  ld (os_view_disable), a 
938d c3 6a 93			jp .debug_tog 
9390			 
9390			 
9390			hardware_diags:       
9390			 
9390			.diagm: 
9390 21 a3 93			ld hl, .menuitems 
9393 3e 00			ld a, 0 
9395 cd a6 8a			call menu 
9398			 
9398 fe 00		         cp 0 
939a c8				 ret z 
939b			 
939b fe 02			cp 2 
939d ca fc 93			jp z, .diagedit 
93a0			 
93a0			;	cp '6' 
93a0			;	jp z, .menutest 
93a0			;if ENABLE_BASIC 
93a0			;	cp '6' 
93a0			;	jp z, basic 
93a0			;endif 
93a0			  
93a0 c3 90 93			jp .diagm 
93a3			 
93a3				 
93a3 b7 93		.menuitems:   	dw .m1 
93a5 c2 93				dw .m2 
93a7 c9 93				dw .m3 
93a9 d1 93				dw .m5 
93ab d7 93				dw .m5a 
93ad e0 93				dw .m5b 
93af 00 00				dw 0 
93b1			 
93b1			.menudebug: 
93b1 e9 93				dw .m6 
93b3 f2 93				dw .m7 
93b5 00 00				dw 0 
93b7			 
93b7 .. 00		.m1:   db "Key Matrix",0 
93c2 .. 00		.m2:   db "Editor",0 
93c9 .. 00		.m3:   db "Storage",0 
93d1 .. 00		.m5:   db "Sound",0 
93d7 .. 00		.m5a:  db "RAM Test",0 
93e0 .. 00		.m5b:  db "LCD Test",0 
93e9			 
93e9 .. 00		.m6:   db "Debug ON",0 
93f2 .. 00		.m7:   db "Debug OFF",0 
93fc			 
93fc			; debug editor 
93fc			 
93fc			.diagedit: 
93fc			 
93fc 21 85 e4			ld hl, scratch 
93ff			;	ld bc, 250 
93ff			;	ldir 
93ff				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
93ff 3e 00			ld a, 0 
9401 77				ld (hl), a 
9402 23				inc hl 
9403 77				ld (hl), a 
9404 23				inc hl 
9405 77				ld (hl), a 
9406			 
9406 cd 75 8a		        call clear_display 
9409 cd 98 8a			call update_display 
940c				;ld a, 1 
940c				;ld (hardware_diag), a 
940c			.diloop: 
940c 3e 00			ld a, display_row_1 
940e 0e 00			ld c, 0 
9410 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9412 1e 28			ld e, 40 
9414			 
9414 21 85 e4			ld hl, scratch	 
9417 cd cf 8c			call input_str 
941a			 
941a 3e 14			ld a, display_row_2 
941c 11 85 e4			ld de, scratch 
941f cd 88 8a			call str_at_display 
9422 cd 98 8a			call update_display 
9425			 
9425 c3 0c 94			jp .diloop 
9428			 
9428			 
9428			; pass word in hl 
9428			; a has display location 
9428			display_word_at: 
9428 f5				push af 
9429 e5				push hl 
942a 7c				ld a,h 
942b 21 8a e7			ld hl, os_word_scratch 
942e cd a3 8f			call hexout 
9431 e1				pop hl 
9432 7d				ld a,l 
9433 21 8c e7			ld hl, os_word_scratch+2 
9436 cd a3 8f			call hexout 
9439 21 8e e7			ld hl, os_word_scratch+4 
943c 3e 00			ld a,0 
943e 77				ld (hl),a 
943f 11 8a e7			ld de,os_word_scratch 
9442 f1				pop af 
9443 cd 88 8a				call str_at_display 
9446 c9				ret 
9447			 
9447			display_ptr_state: 
9447			 
9447				; to restore afterwards 
9447			 
9447 d5				push de 
9448 c5				push bc 
9449 e5				push hl 
944a f5				push af 
944b			 
944b				; for use in here 
944b			 
944b			;	push bc 
944b			;	push de 
944b			;	push hl 
944b			;	push af 
944b			 
944b cd 75 8a			call clear_display 
944e			 
944e 11 21 96			ld de, .ptrstate 
9451 3e 00			ld a, display_row_1 
9453 cd 88 8a			call str_at_display 
9456			 
9456				; display debug step 
9456			 
9456			 
9456 11 b7 ee			ld de, debug_mark 
9459 3e 12			ld a, display_row_1+display_cols-2 
945b cd 88 8a			call str_at_display 
945e			 
945e				; display a 
945e 11 2b 96			ld de, .ptrcliptr 
9461 3e 14			ld a, display_row_2 
9463 cd 88 8a			call str_at_display 
9466			 
9466 f1				pop af 
9467 2a d0 eb			ld hl,(cli_ptr) 
946a 3e 1c			ld a, display_row_2+8 
946c cd 28 94			call display_word_at 
946f			 
946f			 
946f				; display hl 
946f			 
946f			 
946f 11 33 96			ld de, .ptrclioptr 
9472 3e 1e			ld a, display_row_2+10 
9474 cd 88 8a			call str_at_display 
9477			; 
9477			;	pop hl 
9477 3e 21			ld a, display_row_2+13 
9479 2a ce eb			ld hl,(cli_origptr) 
947c cd 28 94			call display_word_at 
947f			; 
947f			;	 
947f			;	; display de 
947f			 
947f			;	ld de, .regstatede 
947f			;	ld a, display_row_3 
947f			;	call str_at_display 
947f			 
947f			;	pop de 
947f			;	ld h,d 
947f			;	ld l, e 
947f			;	ld a, display_row_3+3 
947f			;	call display_word_at 
947f			 
947f			 
947f				; display bc 
947f			 
947f			;	ld de, .regstatebc 
947f			;	ld a, display_row_3+10 
947f			;	call str_at_display 
947f			 
947f			;	pop bc 
947f			;	ld h,b 
947f			;	ld l, c 
947f			;	ld a, display_row_3+13 
947f			;	call display_word_at 
947f			 
947f			 
947f				; display dsp 
947f			 
947f			;	ld de, .regstatedsp 
947f			;	ld a, display_row_4 
947f			;	call str_at_display 
947f			 
947f				 
947f			;	ld hl,(cli_data_sp) 
947f			;	ld a, display_row_4+4 
947f			;	call display_word_at 
947f			 
947f				; display rsp 
947f			 
947f 11 62 96			ld de, .regstatersp 
9482 3e 46			ld a, display_row_4+10 
9484 cd 88 8a			call str_at_display 
9487			 
9487				 
9487 2a b6 eb			ld hl,(cli_ret_sp) 
948a 3e 4a			ld a, display_row_4+14 
948c cd 28 94			call display_word_at 
948f			 
948f cd 98 8a			call update_display 
9492			 
9492 cd f2 89			call delay1s 
9495 cd f2 89			call delay1s 
9498 cd f2 89			call delay1s 
949b			 
949b			 
949b cd 8c 9a			call next_page_prompt 
949e			 
949e				; restore  
949e			 
949e f1				pop af 
949f e1				pop hl 
94a0 c1				pop bc 
94a1 d1				pop de 
94a2 c9				ret 
94a3			 
94a3			break_point_state: 
94a3 f5				push af 
94a4			 
94a4				; see if disabled 
94a4			 
94a4 3a 76 e4			ld a, (os_view_disable) 
94a7 fe 2a			cp '*' 
94a9 20 02			jr nz, .bpsgo 
94ab f1				pop af 
94ac c9				ret 
94ad			 
94ad			.bpsgo: 
94ad f1				pop af 
94ae f5				push af 
94af 22 72 e4			ld (os_view_hl), hl 
94b2 ed 53 70 e4		ld (os_view_de), de 
94b6 ed 43 6e e4		ld (os_view_bc), bc 
94ba e5				push hl 
94bb 6f				ld l, a 
94bc 26 00			ld h, 0 
94be 22 74 e4			ld (os_view_af),hl 
94c1			 
94c1 21 4d ee				ld hl, display_fb0 
94c4 22 58 ed				ld (display_fb_active), hl 
94c7 e1				pop hl	 
94c8			 
94c8 3e 31			ld a, '1' 
94ca fe 2a		.bps1:  cp '*' 
94cc 20 03			jr nz, .bps1b 
94ce 32 76 e4			ld (os_view_disable),a 
94d1 fe 31		.bps1b:  cp '1' 
94d3 20 14			jr nz, .bps2 
94d5			 
94d5				; display reg 
94d5			 
94d5				 
94d5			 
94d5 3a 74 e4			ld a, (os_view_af) 
94d8 2a 72 e4			ld hl, (os_view_hl) 
94db ed 5b 70 e4		ld de, (os_view_de) 
94df ed 4b 6e e4		ld bc, (os_view_bc) 
94e3 cd 7d 95			call display_reg_state 
94e6 c3 69 95			jp .bpschk 
94e9			 
94e9 fe 32		.bps2:  cp '2' 
94eb 20 08			jr nz, .bps3 
94ed				 
94ed				; display hl 
94ed 2a 72 e4			ld hl, (os_view_hl) 
94f0 cd 67 96			call display_dump_at_hl 
94f3			 
94f3 18 74			jr .bpschk 
94f5			 
94f5 fe 33		.bps3:  cp '3' 
94f7 20 08			jr nz, .bps4 
94f9			 
94f9			        ; display de 
94f9 2a 70 e4			ld hl, (os_view_de) 
94fc cd 67 96			call display_dump_at_hl 
94ff			 
94ff 18 68			jr .bpschk 
9501 fe 34		.bps4:  cp '4' 
9503 20 08			jr nz, .bps5 
9505			 
9505			        ; display bc 
9505 2a 6e e4			ld hl, (os_view_bc) 
9508 cd 67 96			call display_dump_at_hl 
950b			 
950b 18 5c			jr .bpschk 
950d fe 35		.bps5:  cp '5' 
950f 20 08		        jr nz, .bps7 
9511			 
9511				; display cur ptr 
9511 2a d0 eb			ld hl, (cli_ptr) 
9514 cd 67 96			call display_dump_at_hl 
9517			 
9517 18 50			jr .bpschk 
9519 fe 36		.bps7:  cp '6' 
951b 20 08			jr nz, .bps8b 
951d				 
951d				; display cur orig ptr 
951d 2a ce eb			ld hl, (cli_origptr) 
9520 cd 67 96			call display_dump_at_hl 
9523 18 44			jr .bpschk 
9525 fe 37		.bps8b:  cp '7' 
9527 20 08			jr nz, .bps9 
9529				 
9529				; display dsp 
9529 2a b2 eb			ld hl, (cli_data_sp) 
952c cd 67 96			call display_dump_at_hl 
952f			 
952f 18 38			jr .bpschk 
9531 fe 39		.bps9:  cp '9' 
9533 20 05			jr nz, .bps8c 
9535				 
9535				; display SP 
9535			;	ld hl, sp 
9535 cd 67 96			call display_dump_at_hl 
9538			 
9538 18 2f			jr .bpschk 
953a fe 38		.bps8c:  cp '8' 
953c 20 08			jr nz, .bps8d 
953e				 
953e				; display rsp 
953e 2a b6 eb			ld hl, (cli_ret_sp) 
9541 cd 67 96			call display_dump_at_hl 
9544			 
9544 18 23			jr .bpschk 
9546 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9548 20 05			jr nz, .bps8 
954a cd 82 98			call monitor 
954d			 
954d 18 1a			jr .bpschk 
954f fe 30		.bps8:  cp '0' 
9551 20 16			jr nz, .bpschk 
9553			 
9553 21 fc ed				ld hl, display_fb1 
9556 22 58 ed				ld (display_fb_active), hl 
9559 cd 98 8a				call update_display 
955c			 
955c				;ld a, (os_view_af) 
955c 2a 72 e4			ld hl, (os_view_hl) 
955f ed 5b 70 e4		ld de, (os_view_de) 
9563 ed 4b 6e e4		ld bc, (os_view_bc) 
9567 f1				pop af 
9568 c9				ret 
9569			 
9569			.bpschk:   
9569 cd f2 89			call delay1s 
956c 3e 4f		ld a,display_row_4 + display_cols - 1 
956e 11 8a 9a		        ld de, endprg 
9571 cd 88 8a			call str_at_display 
9574 cd 98 8a			call update_display 
9577 cd 39 db			call cin_wait 
957a			 
957a c3 ca 94			jp .bps1 
957d			 
957d			 
957d			display_reg_state: 
957d			 
957d				; to restore afterwards 
957d			 
957d d5				push de 
957e c5				push bc 
957f e5				push hl 
9580 f5				push af 
9581			 
9581				; for use in here 
9581			 
9581 c5				push bc 
9582 d5				push de 
9583 e5				push hl 
9584 f5				push af 
9585			 
9585 cd 75 8a			call clear_display 
9588			 
9588 11 3d 96			ld de, .regstate 
958b 3e 00			ld a, display_row_1 
958d cd 88 8a			call str_at_display 
9590			 
9590				; display debug step 
9590			 
9590			 
9590 11 b7 ee			ld de, debug_mark 
9593 3e 11			ld a, display_row_1+display_cols-3 
9595 cd 88 8a			call str_at_display 
9598			 
9598				; display a 
9598 11 59 96			ld de, .regstatea 
959b 3e 14			ld a, display_row_2 
959d cd 88 8a			call str_at_display 
95a0			 
95a0 e1				pop hl 
95a1			;	ld h,0 
95a1			;	ld l, a 
95a1 3e 17			ld a, display_row_2+3 
95a3 cd 28 94			call display_word_at 
95a6			 
95a6			 
95a6				; display hl 
95a6			 
95a6			 
95a6 11 4d 96			ld de, .regstatehl 
95a9 3e 1e			ld a, display_row_2+10 
95ab cd 88 8a			call str_at_display 
95ae			 
95ae e1				pop hl 
95af 3e 21			ld a, display_row_2+13 
95b1 cd 28 94			call display_word_at 
95b4			 
95b4				 
95b4				; display de 
95b4			 
95b4 11 51 96			ld de, .regstatede 
95b7 3e 28			ld a, display_row_3 
95b9 cd 88 8a			call str_at_display 
95bc			 
95bc e1				pop hl 
95bd			;	ld h,d 
95bd			;	ld l, e 
95bd 3e 2b			ld a, display_row_3+3 
95bf cd 28 94			call display_word_at 
95c2			 
95c2			 
95c2				; display bc 
95c2			 
95c2 11 55 96			ld de, .regstatebc 
95c5 3e 32			ld a, display_row_3+10 
95c7 cd 88 8a			call str_at_display 
95ca			 
95ca e1				pop hl 
95cb			;	ld h,b 
95cb			;	ld l, c 
95cb 3e 35			ld a, display_row_3+13 
95cd cd 28 94			call display_word_at 
95d0			 
95d0			 
95d0				; display dsp 
95d0			 
95d0 11 5d 96			ld de, .regstatedsp 
95d3 3e 3c			ld a, display_row_4 
95d5 cd 88 8a			call str_at_display 
95d8			 
95d8				 
95d8 2a b2 eb			ld hl,(cli_data_sp) 
95db 3e 40			ld a, display_row_4+4 
95dd cd 28 94			call display_word_at 
95e0			 
95e0				; display rsp 
95e0			 
95e0 11 62 96			ld de, .regstatersp 
95e3 3e 46			ld a, display_row_4+10 
95e5 cd 88 8a			call str_at_display 
95e8			 
95e8				 
95e8 2a b6 eb			ld hl,(cli_ret_sp) 
95eb 3e 4a			ld a, display_row_4+14 
95ed cd 28 94			call display_word_at 
95f0			 
95f0 cd 98 8a			call update_display 
95f3			 
95f3			;	call delay1s 
95f3			;	call delay1s 
95f3			;	call delay1s 
95f3			 
95f3			 
95f3			;	call next_page_prompt 
95f3			 
95f3				; restore  
95f3			 
95f3 f1				pop af 
95f4 e1				pop hl 
95f5 c1				pop bc 
95f6 d1				pop de 
95f7 c9				ret 
95f8			 
95f8 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
960c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9621 .. 00		.ptrstate:	db "Ptr State",0 
962b .. 00		.ptrcliptr:     db "cli_ptr",0 
9633 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
963d .. 00		.regstate:	db "Reg State (1/0)",0 
964d .. 00		.regstatehl:	db "HL:",0 
9651 .. 00		.regstatede:	db "DE:",0 
9655 .. 00		.regstatebc:	db "BC:",0 
9659 .. 00		.regstatea:	db "A :",0 
965d .. 00		.regstatedsp:	db "DSP:",0 
9662 .. 00		.regstatersp:	db "RSP:",0 
9667			 
9667			display_dump_at_hl: 
9667 e5				push hl 
9668 d5				push de 
9669 c5				push bc 
966a f5				push af 
966b			 
966b 22 a8 e7			ld (os_cur_ptr),hl	 
966e cd 75 8a			call clear_display 
9671 cd 94 99			call dumpcont 
9674			;	call delay1s 
9674			;	call next_page_prompt 
9674			 
9674			 
9674 f1				pop af 
9675 c1				pop bc 
9676 d1				pop de 
9677 e1				pop hl 
9678 c9				ret 
9679			 
9679			;if ENABLE_BASIC 
9679			;	include "nascombasic.asm" 
9679			;	basic: 
9679			;	include "forth/FORTH.ASM" 
9679			;endif 
9679			 
9679			; eof 
9679			 
9679			 
# End of file firmware_diags.asm
9679			  
9679			include "firmware_prompts.asm"  
9679			; Prompts  
9679			 
9679			; boot messages 
9679			 
9679 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
968e .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
969e			 
969e			 
969e			; config menus 
969e			 
969e .. 00		prom_c3: db "Add Dictionary To File",0 
96b5 .. 00		prom_c2: db "Select Autoload File",0 
96ca .. 00		prom_c2a: db "Disable Autoload File", 0 
96e0 .. 00		prom_c2b: db "Select Storage Bank",0 
96f4 .. 00		prom_c4: db "Settings",0 
96fd .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9718 .. 00		prom_m4b:   db "Monitor",0 
9720 .. 00		prom_c1: db "Hardware Diags",0 
972f			 
972f			 
972f .. 00		prom_notav:    db "Feature not available",0 
9745 .. 00		prom_empty:    db "",0 
9746			 
9746			; eof 
9746			 
# End of file firmware_prompts.asm
9746			  
9746			  
9746			; eof  
9746			  
# End of file firmware.asm
9746			 
9746			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9746			;if BASE_KEV  
9746			;baseram: equ 08000h 
9746			;endif 
9746			 
9746			;if BASE_SC114 
9746			;baseram:     equ    endofcode 
9746			;endif 
9746			 
9746			 
9746			; start system 
9746			 
9746			coldstart: 
9746				; set sp 
9746				; di/ei 
9746			 
9746 f3				di 
9747 31 00 f0			ld sp, tos 
974a			;	ei 
974a			 
974a			 
974a				; disable breakpoint by default 
974a			 
974a 3e 2a			ld a,'*' 
974c 32 76 e4			ld (os_view_disable),a 
974f			 
974f				; init hardware 
974f			 
974f				; init keyboard and screen hardware 
974f			 
974f cd 1c 80			call hardware_init 
9752			 
9752			 
9752 cd f2 89			call delay1s 
9755 3e 30			ld a, display_row_3+8 
9757 11 03 80			ld de, buildtime 
975a cd 88 8a			call str_at_display 
975d cd 98 8a			call update_display 
9760			 
9760 cd f2 89			call delay1s 
9763 cd f2 89			call delay1s 
9766 cd f2 89			call delay1s 
9769			 
9769				; detect if any keys are held down to enable breakpoints at start up 
9769			 
9769 cd 3f db			call cin  
976c fe 00			cp 0 
976e 28 03			jr z, .nokeys 
9770			 
9770				;call hardware_diags 
9770 cd 02 93			call config 
9773			 
9773			;	ld de, .bpen 
9773			;	ld a, display_row_4 
9773			;	call str_at_display 
9773			;	call update_display 
9773			; 
9773			;	ld a,0 
9773			;	ld (os_view_disable),a 
9773			; 
9773			;.bpwait: 
9773			;	call cin 
9773			;	cp 0 
9773			;	jr z, .bpwait 
9773			;	jr .nokeys 
9773			; 
9773			; 
9773			;.bpen:  db "Break points enabled!",0 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			.nokeys: 
9773			 
9773			 
9773				 
9773			 
9773			;jp  testkey 
9773			 
9773			;call storage_get_block_0 
9773			; 
9773			;ld hl, 0 
9773			;ld de, store_page 
9773			;call storage_read_block 
9773			 
9773				 
9773			;ld hl, 10 
9773			;ld de, store_page 
9773			;call storage_read_block 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			;stop:	nop 
9773			;	jp stop 
9773			 
9773			 
9773			 
9773			main: 
9773 cd 75 8a			call clear_display 
9776 cd 98 8a			call update_display 
9779			 
9779			 
9779			 
9779			;	call testlcd 
9779			 
9779			 
9779			 
9779 cd 52 9e			call forth_init 
977c			 
977c			 
977c			warmstart: 
977c cd 28 9e			call forth_warmstart 
977f			 
977f				; run startup word load 
977f			        ; TODO prevent this running at warmstart after crash  
977f			 
977f				if STARTUP_ENABLE 
977f					if STORAGE_SE 
977f						call forth_autoload 
977f					endif 
977f cd d3 d7				call forth_startup 
9782			 
9782			 
9782				endif 
9782			 
9782				; show free memory after boot 
9782 11 1c 98			ld de, freeram 
9785 3e 00			ld a, display_row_1 
9787 cd 88 8a			call str_at_display 
978a			 
978a			; Or use heap_size word???? 
978a 21 6b e4			ld hl, heap_end 
978d 11 5d db			ld de, heap_start 
9790 ed 52			sbc hl, de 
9792 e5				push hl 
9793 7c				ld a,h	         	 
9794 21 8a e7			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9797 cd a3 8f			call hexout 
979a e1			   	pop hl 
979b			 
979b 7d				ld a,l 
979c 21 8c e7			ld hl, os_word_scratch+2 
979f cd a3 8f			call hexout 
97a2 21 8e e7			ld hl, os_word_scratch+4 
97a5 3e 00			ld a, 0 
97a7 77				ld (hl),a 
97a8 11 8a e7			ld de, os_word_scratch 
97ab 3e 0d			ld a, display_row_1 + 13 
97ad cd 88 8a			call str_at_display 
97b0 cd 98 8a			call update_display 
97b3			 
97b3			 
97b3				;call demo 
97b3			 
97b3			 
97b3				; init scratch input area for cli commands 
97b3			 
97b3 21 ac e7			ld hl, os_cli_cmd 
97b6 3e 00			ld a,0 
97b8 77				ld (hl),a 
97b9 23				inc hl 
97ba 77				ld (hl),a 
97bb			 
97bb 3e 00			ld a,0 
97bd 32 ab e8			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97c0			 
97c0 32 a8 e7			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97c3 32 a9 e7			ld (os_cur_ptr+1),a	 
97c6			 
97c6 32 8a e7			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97c9 32 8b e7			ld (os_word_scratch+1),a	 
97cc				 
97cc			 
97cc				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97cc 21 ac e7			ld hl, os_cli_cmd 
97cf			 
97cf 3e 00			ld a, 0		 ; init cli input 
97d1 77				ld (hl), a 
97d2 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97d4			cli: 
97d4				; show cli prompt 
97d4				;push af 
97d4				;ld a, 0 
97d4				;ld de, prompt 
97d4				;call str_at_display 
97d4			 
97d4				;call update_display 
97d4				;pop af 
97d4				;inc a 
97d4				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97d4 0e 00			ld c, 0 
97d6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97d8 1e 28			ld e, 40 
97da			 
97da 21 ac e7			ld hl, os_cli_cmd 
97dd			 
97dd				STACKFRAME OFF $fefe $9f9f 
97dd				if DEBUG_STACK_IMB 
97dd					if OFF 
97dd						exx 
97dd						ld de, $fefe 
97dd						ld a, d 
97dd						ld hl, curframe 
97dd						call hexout 
97dd						ld a, e 
97dd						ld hl, curframe+2 
97dd						call hexout 
97dd						ld hl, $fefe 
97dd						push hl 
97dd						ld hl, $9f9f 
97dd						push hl 
97dd						exx 
97dd					endif 
97dd				endif 
97dd			endm 
# End of macro STACKFRAME
97dd			 
97dd cd cf 8c			call input_str 
97e0			 
97e0				STACKFRAMECHK OFF $fefe $9f9f 
97e0				if DEBUG_STACK_IMB 
97e0					if OFF 
97e0						exx 
97e0						ld hl, $9f9f 
97e0						pop de   ; $9f9f 
97e0						call cmp16 
97e0						jr nz, .spnosame 
97e0						ld hl, $fefe 
97e0						pop de   ; $fefe 
97e0						call cmp16 
97e0						jr z, .spfrsame 
97e0						.spnosame: call showsperror 
97e0						.spfrsame: nop 
97e0						exx 
97e0					endif 
97e0				endif 
97e0			endm 
# End of macro STACKFRAMECHK
97e0			 
97e0				; copy input to last command 
97e0			 
97e0 21 ac e7			ld hl, os_cli_cmd 
97e3 11 ab e8			ld de, os_last_cmd 
97e6 01 ff 00			ld bc, 255 
97e9 ed b0			ldir 
97eb			 
97eb				; wipe current buffer 
97eb			 
97eb			;	ld a, 0 
97eb			;	ld hl, os_cli_cmd 
97eb			;	ld de, os_cli_cmd+1 
97eb			;	ld bc, 254 
97eb			;	ldir 
97eb				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97eb			;	call strcpy 
97eb			;	ld a, 0 
97eb			;	ld (hl), a 
97eb			;	inc hl 
97eb			;	ld (hl), a 
97eb			;	inc hl 
97eb			;	ld (hl), a 
97eb			 
97eb				; switch frame buffer to program  
97eb			 
97eb 21 fc ed				ld hl, display_fb1 
97ee 22 58 ed				ld (display_fb_active), hl 
97f1			 
97f1			;	nop 
97f1				STACKFRAME ON $fbfe $8f9f 
97f1				if DEBUG_STACK_IMB 
97f1					if ON 
97f1						exx 
97f1						ld de, $fbfe 
97f1						ld a, d 
97f1						ld hl, curframe 
97f1						call hexout 
97f1						ld a, e 
97f1						ld hl, curframe+2 
97f1						call hexout 
97f1						ld hl, $fbfe 
97f1						push hl 
97f1						ld hl, $8f9f 
97f1						push hl 
97f1						exx 
97f1					endif 
97f1				endif 
97f1			endm 
# End of macro STACKFRAME
97f1				; first time into the parser so pass over the current scratch pad 
97f1 21 ac e7			ld hl,os_cli_cmd 
97f4				; tokenise the entered statement(s) in HL 
97f4 cd d0 9e			call forthparse 
97f7			        ; exec forth statements in top of return stack 
97f7 cd 10 9f			call forthexec 
97fa				;call forthexec_cleanup 
97fa			;	call parsenext 
97fa			 
97fa				STACKFRAMECHK ON $fbfe $8f9f 
97fa				if DEBUG_STACK_IMB 
97fa					if ON 
97fa						exx 
97fa						ld hl, $8f9f 
97fa						pop de   ; $8f9f 
97fa						call cmp16 
97fa						jr nz, .spnosame 
97fa						ld hl, $fbfe 
97fa						pop de   ; $fbfe 
97fa						call cmp16 
97fa						jr z, .spfrsame 
97fa						.spnosame: call showsperror 
97fa						.spfrsame: nop 
97fa						exx 
97fa					endif 
97fa				endif 
97fa			endm 
# End of macro STACKFRAMECHK
97fa				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
97fa			 
97fa 3e 3c			ld a, display_row_4 
97fc 11 2e 98			ld de, endprog 
97ff			 
97ff cd 98 8a			call update_display		 
9802			 
9802 cd 8c 9a			call next_page_prompt 
9805			 
9805				; switch frame buffer to cli 
9805			 
9805 21 4d ee				ld hl, display_fb0 
9808 22 58 ed				ld (display_fb_active), hl 
980b			 
980b			 
980b cd 75 8a		        call clear_display 
980e cd 98 8a			call update_display		 
9811			 
9811 21 ac e7			ld hl, os_cli_cmd 
9814			 
9814 3e 00			ld a, 0		 ; init cli input 
9816 77				ld (hl), a 
9817			 
9817				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9817			 
9817				; now on last line 
9817			 
9817				; TODO scroll screen up 
9817			 
9817				; TODO instead just clear screen and place at top of screen 
9817			 
9817			;	ld a, 0 
9817			;	ld (f_cursor_ptr),a 
9817			 
9817				;call clear_display 
9817				;call update_display 
9817			 
9817				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9817 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9819 c3 d4 97			jp cli 
981c			 
981c .. 00		freeram: db "Free bytes: $",0 
982a ..			asc: db "1A2F" 
982e .. 00		endprog: db "End prog...",0 
983a			 
983a			testenter2:   
983a 21 b7 e4			ld hl,scratch+50 
983d 22 a8 e7			ld (os_cur_ptr),hl 
9840 c3 d4 97			jp cli 
9843			 
9843			testenter:  
9843			 
9843 21 2a 98			ld hl,asc 
9846			;	ld a,(hl) 
9846			;	call nibble2val 
9846 cd f9 8f			call get_byte 
9849			 
9849			 
9849			;	ld a,(hl) 
9849			;	call atohex 
9849			 
9849			;	call fourehexhl 
9849 32 b7 e4			ld (scratch+50),a 
984c			 
984c			 
984c			 
984c 21 2c 98			ld hl,asc+2 
984f			;	ld a, (hl) 
984f			;	call nibble2val 
984f cd f9 8f			call get_byte 
9852			 
9852			;	call fourehexhl 
9852 32 b9 e4			ld (scratch+52),a 
9855				 
9855 21 b7 e4			ld hl,scratch+50 
9858 22 a8 e7			ld (os_cur_ptr),hl 
985b c3 d4 97			jp cli 
985e			 
985e			enter:	 
985e 3a 89 e4			ld a,(scratch+4) 
9861 fe 00			cp 0 
9863 28 0c			jr z, .entercont 
9865				; no, not a null term line so has an address to work out.... 
9865			 
9865 21 87 e4			ld hl,scratch+2 
9868 cd 59 90			call get_word_hl 
986b			 
986b 22 a8 e7			ld (os_cur_ptr),hl	 
986e c3 d4 97			jp cli 
9871			 
9871			 
9871			.entercont:  
9871			 
9871 21 87 e4			ld hl, scratch+2 
9874 cd f9 8f			call get_byte 
9877			 
9877 2a a8 e7		   	ld hl,(os_cur_ptr) 
987a 77					ld (hl),a 
987b 23					inc hl 
987c 22 a8 e7				ld (os_cur_ptr),hl 
987f				 
987f			; get byte  
987f			 
987f			 
987f c3 d4 97			jp cli 
9882			 
9882			 
9882			; basic monitor support 
9882			 
9882			monitor: 
9882				;  
9882 cd 75 8a			call clear_display 
9885 3e 00			ld a, 0 
9887 11 cf 98			ld de, .monprompt 
988a cd 88 8a			call str_at_display 
988d cd 98 8a			call update_display 
9890			 
9890				; get a monitor command 
9890			 
9890 0e 00			ld c, 0     ; entry at top left 
9892 16 64			ld d, 100   ; max buffer size 
9894 1e 0f			ld e, 15    ; input scroll area 
9896 3e 00			ld a, 0     ; init string 
9898 21 83 e6			ld hl, os_input 
989b 77				ld (hl), a 
989c 23				inc hl 
989d 77				ld (hl), a 
989e 21 83 e6			ld hl, os_input 
98a1 3e 01			ld a, 1     ; init string 
98a3 cd cf 8c			call input_str 
98a6			 
98a6 cd 75 8a		        call clear_display 
98a9 cd 98 8a			call update_display		 
98ac			 
98ac 3a 83 e6			ld a, (os_input) 
98af cd f7 90			call toUpper 
98b2 fe 48		        cp 'H' 
98b4 28 6f		        jr z, .monhelp 
98b6 fe 44			cp 'D'		; dump 
98b8 ca 46 99			jp z, .mondump	 
98bb fe 43			cp 'C'		; dump 
98bd ca 60 99			jp z, .moncdump	 
98c0 fe 4d			cp 'M'		; dump 
98c2 ca d1 98			jp z, .moneditstart 
98c5 fe 55			cp 'U'		; dump 
98c7 28 14			jr z, .monedit	 
98c9 fe 51			cp 'Q'		; dump 
98cb c8				ret z	 
98cc			 
98cc			 
98cc				; TODO "S" to access symbol by name and not need the address 
98cc				; TODO "F" to find a string in memory 
98cc			 
98cc c3 82 98			jp monitor 
98cf			 
98cf .. 00		.monprompt: db ">", 0 
98d1			 
98d1			.moneditstart: 
98d1				; get starting address 
98d1			 
98d1 21 85 e6			ld hl,os_input+2 
98d4 cd 59 90			call get_word_hl 
98d7			 
98d7 22 a8 e7			ld (os_cur_ptr),hl	 
98da			 
98da c3 82 98			jp monitor 
98dd			 
98dd			.monedit: 
98dd				; get byte to load 
98dd			 
98dd 21 85 e6			ld hl,os_input+2 
98e0 cd f9 8f			call get_byte 
98e3			 
98e3				; get address to update 
98e3 2a a8 e7			ld hl, (os_cur_ptr) 
98e6			 
98e6				; update byte 
98e6			 
98e6 77				ld (hl), a 
98e7			 
98e7				; move to next address and save it 
98e7			 
98e7 23				inc hl 
98e8 22 a8 e7			ld (os_cur_ptr),hl	 
98eb			 
98eb c3 82 98			jp monitor 
98ee			 
98ee			 
98ee .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9902 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
991e .. 00		.monhelptext3:  db "Q-Quit",0 
9925			        
9925			.monhelp: 
9925 3e 00			ld a, display_row_1 
9927 11 ee 98		        ld de, .monhelptext1 
992a			 
992a cd 88 8a			call str_at_display 
992d 3e 14			ld a, display_row_2 
992f 11 02 99		        ld de, .monhelptext2 
9932					 
9932 cd 88 8a			call str_at_display 
9935 3e 28			ld a, display_row_3 
9937 11 1e 99		        ld de, .monhelptext3 
993a					 
993a cd 88 8a			call str_at_display 
993d cd 98 8a			call update_display		 
9940			 
9940 cd 8c 9a			call next_page_prompt 
9943 c3 82 98			jp monitor 
9946			 
9946			.mondump:    
9946 21 85 e6			ld hl,os_input+2 
9949 cd 59 90			call get_word_hl 
994c			 
994c 22 a8 e7			ld (os_cur_ptr),hl	 
994f cd 94 99			call dumpcont 
9952 3e 3c			ld a, display_row_4 
9954 11 2e 98			ld de, endprog 
9957			 
9957 cd 98 8a			call update_display		 
995a			 
995a cd 8c 9a			call next_page_prompt 
995d c3 82 98			jp monitor 
9960			.moncdump: 
9960 cd 94 99			call dumpcont 
9963 3e 3c			ld a, display_row_4 
9965 11 2e 98			ld de, endprog 
9968			 
9968 cd 98 8a			call update_display		 
996b			 
996b cd 8c 9a			call next_page_prompt 
996e c3 82 98			jp monitor 
9971			 
9971			 
9971			; TODO symbol access  
9971			 
9971			.symbols:     ;; A list of symbols that can be called up  
9971 4d ee			dw display_fb0 
9973 .. 00			db "fb0",0  
9977 0a ec		     	dw store_page 
9979 .. 00			db "store_page",0 
9984			 
9984			 
9984			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9984			 
9984 3a 86 e4			ld a,(scratch+1) 
9987 fe 00			cp 0 
9989 28 09			jr z, dumpcont 
998b			 
998b				; no, not a null term line so has an address to work out.... 
998b			 
998b 21 87 e4			ld hl,scratch+2 
998e cd 59 90			call get_word_hl 
9991			 
9991 22 a8 e7			ld (os_cur_ptr),hl	 
9994			 
9994			 
9994			 
9994			dumpcont: 
9994			 
9994				; dump bytes at ptr 
9994			 
9994			 
9994 3e 00			ld a, display_row_1 
9996 2a 58 ed			ld hl, (display_fb_active) 
9999 cd a2 8c			call addatohl 
999c cd c4 99			call .dumpbyterow 
999f			 
999f 3e 14			ld a, display_row_2 
99a1 2a 58 ed			ld hl, (display_fb_active) 
99a4 cd a2 8c			call addatohl 
99a7 cd c4 99			call .dumpbyterow 
99aa			 
99aa			 
99aa 3e 28			ld a, display_row_3 
99ac 2a 58 ed			ld hl, (display_fb_active) 
99af cd a2 8c			call addatohl 
99b2 cd c4 99			call .dumpbyterow 
99b5			 
99b5 3e 3c			ld a, display_row_4 
99b7 2a 58 ed			ld hl, (display_fb_active) 
99ba cd a2 8c			call addatohl 
99bd cd c4 99			call .dumpbyterow 
99c0			 
99c0 cd 98 8a			call update_display 
99c3			;		jp cli 
99c3 c9				ret 
99c4			 
99c4			.dumpbyterow: 
99c4			 
99c4				;push af 
99c4			 
99c4 e5				push hl 
99c5			 
99c5				; calc where to poke the ascii 
99c5			if display_cols == 20 
99c5 3e 10			ld a, 16 
99c7			else 
99c7				ld a, 31 
99c7			endif 
99c7			 
99c7 cd a2 8c			call addatohl 
99ca 22 8a e7			ld (os_word_scratch),hl  		; save pos for later 
99cd			 
99cd			 
99cd			; display decoding address 
99cd 2a a8 e7		   	ld hl,(os_cur_ptr) 
99d0			 
99d0 7c				ld a,h 
99d1 e1				pop hl 
99d2 e5				push hl 
99d3			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
99d3 cd a3 8f			call hexout 
99d6 2a a8 e7		   	ld hl,(os_cur_ptr) 
99d9			 
99d9 7d				ld a,l 
99da e1				pop hl 
99db 23				inc hl 
99dc 23				inc hl 
99dd e5				push hl 
99de			;	ld hl, os_word_scratch+2 
99de cd a3 8f			call hexout 
99e1 e1				pop hl 
99e2 23				inc hl 
99e3 23				inc hl 
99e4				;ld hl, os_word_scratch+4 
99e4 3e 3a			ld a, ':' 
99e6 77				ld (hl),a 
99e7 23				inc hl 
99e8				;ld a, 0 
99e8				;ld (hl),a 
99e8				;ld de, os_word_scratch 
99e8				;pop af 
99e8				;push af 
99e8			;		ld a, display_row_2 
99e8			;		call str_at_display 
99e8			;		call update_display 
99e8			 
99e8			 
99e8			;pop af 
99e8			;	add 5 
99e8			 
99e8			if display_cols == 20 
99e8 06 04			ld b, 4 
99ea			else 
99ea				ld b, 8 
99ea			endif	 
99ea			 
99ea			.dumpbyte: 
99ea c5				push bc 
99eb e5				push hl 
99ec			 
99ec			 
99ec 2a a8 e7		   	ld hl,(os_cur_ptr) 
99ef 7e					ld a,(hl) 
99f0			 
99f0					; poke the ascii to display 
99f0 2a 8a e7				ld hl,(os_word_scratch) 
99f3 77					ld (hl),a 
99f4 23					inc hl 
99f5 22 8a e7				ld (os_word_scratch),hl 
99f8			 
99f8					 
99f8			 
99f8			 
99f8 e1					pop hl 
99f9 e5					push hl 
99fa			 
99fa cd a3 8f				call hexout 
99fd			 
99fd					 
99fd 2a a8 e7		   	ld hl,(os_cur_ptr) 
9a00 23				inc hl 
9a01 22 a8 e7		   	ld (os_cur_ptr),hl 
9a04			 
9a04 e1					pop hl 
9a05 23					inc hl 
9a06 23					inc hl 
9a07 23					inc hl 
9a08			 
9a08			 
9a08			 
9a08					;ld a,0 
9a08					;ld (os_word_scratch+2),a 
9a08					;pop af 
9a08					;push af 
9a08			 
9a08					;ld de, os_word_scratch 
9a08					;call str_at_display 
9a08			;		call update_display 
9a08			;		pop af 
9a08 c1					pop bc 
9a09 c6 03				add 3 
9a0b 10 dd			djnz .dumpbyte 
9a0d			 
9a0d				 
9a0d			 
9a0d c9				ret 
9a0e			 
9a0e			jump:	 
9a0e			 
9a0e 21 87 e4			ld hl,scratch+2 
9a11 cd 59 90			call get_word_hl 
9a14				;ld hl,(scratch+2) 
9a14				;call fourehexhl 
9a14			 
9a14 22 a8 e7			ld (os_cur_ptr),hl	 
9a17			 
9a17 e9				jp (hl) 
9a18			 
9a18			 
9a18			 
9a18			; TODO implement a basic monitor mode to start with 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			; testing and demo code during development 
9a18			 
9a18			 
9a18 .. 00		str1: db "Enter some text...",0 
9a2b .. 00		clear: db "                    ",0 
9a40			 
9a40			demo: 
9a40			 
9a40			 
9a40			 
9a40			;	call update_display 
9a40			 
9a40				; init scratch input area for testing 
9a40 21 85 e4			ld hl, scratch	 
9a43 3e 00			ld a,0 
9a45 77				ld (hl),a 
9a46			 
9a46			 
9a46 3e 14		            LD   A, display_row_2 
9a48			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a48 11 18 9a		            LD   DE, str1 
9a4b cd 88 8a			call str_at_display 
9a4e			 
9a4e			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a4e			cloop:	 
9a4e 3e 28		            LD   A, display_row_3 
9a50			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a50 11 2b 9a		            LD   DE, clear 
9a53			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a53 cd 88 8a				call str_at_display 
9a56 3e 3c			ld a, display_row_4 
9a58 11 88 9a			ld de, prompt 
9a5b			 
9a5b cd 88 8a				call str_at_display 
9a5e cd 98 8a			call update_display 
9a61			 
9a61 3e 3d			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a63 16 0a			ld d, 10 
9a65 21 85 e4			ld hl, scratch	 
9a68 cd cf 8c			call input_str 
9a6b			 
9a6b			;	call clear_display 
9a6b			;'	call update_display 
9a6b			 
9a6b 3e 00		            LD   A, display_row_1 
9a6d			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a6d 11 2b 9a		            LD   DE, clear 
9a70 cd 88 8a				call str_at_display 
9a73			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a73 3e 00		            LD   A, display_row_1 
9a75			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a75 11 85 e4		            LD   DE, scratch 
9a78			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a78 cd 88 8a				call str_at_display 
9a7b cd 98 8a			call update_display 
9a7e			 
9a7e 3e 00				ld a,0 
9a80 21 85 e4			ld hl, scratch 
9a83 77				ld (hl),a 
9a84			 
9a84 00				nop 
9a85 c3 4e 9a			jp cloop 
9a88			 
9a88			 
9a88			 
9a88			; OS Prompt 
9a88			 
9a88 .. 00		prompt: db ">",0 
9a8a .. 00		endprg: db "?",0 
9a8c			 
9a8c			 
9a8c			; handy next page prompt 
9a8c			next_page_prompt: 
9a8c e5				push hl 
9a8d d5				push de 
9a8e f5				push af 
9a8f c5				push bc 
9a90			 
9a90 3e 4f			ld a,display_row_4 + display_cols - 1 
9a92 11 8a 9a		        ld de, endprg 
9a95 cd 88 8a			call str_at_display 
9a98 cd 98 8a			call update_display 
9a9b cd 39 db			call cin_wait 
9a9e c1				pop bc 
9a9f f1				pop af 
9aa0 d1				pop de 
9aa1 e1				pop hl 
9aa2			 
9aa2			 
9aa2 c9				ret 
9aa3			 
9aa3			 
9aa3			; forth parser 
9aa3			 
9aa3			; My forth kernel 
9aa3			include "forth_kernel.asm" 
9aa3			; 
9aa3			; kernel to the forth OS 
9aa3			 
9aa3			DS_TYPE_STR: equ 1     ; string type 
9aa3			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9aa3			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9aa3			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9aa3			 
9aa3			FORTH_PARSEV1: equ 0 
9aa3			FORTH_PARSEV2: equ 0 
9aa3			FORTH_PARSEV3: equ 0 
9aa3			FORTH_PARSEV4: equ 0 
9aa3			FORTH_PARSEV5: equ 1 
9aa3			 
9aa3			;if FORTH_PARSEV5 
9aa3			;	FORTH_END_BUFFER: equ 0 
9aa3			;else 
9aa3			FORTH_END_BUFFER: equ 127 
9aa3			;endif 
9aa3			 
9aa3			FORTH_TRUE: equ 1 
9aa3			FORTH_FALSE: equ 0 
9aa3			 
9aa3			if FORTH_PARSEV4 
9aa3			include "forth_stackops.asm" 
9aa3			endif 
9aa3			 
9aa3			if FORTH_PARSEV5 
9aa3			include "forth_stackopsv5.asm" 
9aa3			 
9aa3			; Stack operations for v5 parser on wards 
9aa3			; * DATA stack 
9aa3			; * LOOP stack 
9aa3			; * RETURN stack 
9aa3			 
9aa3			 
9aa3			 
9aa3			FORTH_CHK_DSP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_data_sp) 
9aa3				ld de, cli_data_stack 
9aa3				call cmp16 
9aa3				jp c, fault_dsp_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			FORTH_CHK_RSP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_ret_sp) 
9aa3				ld de, cli_ret_stack 
9aa3				call cmp16 
9aa3				jp c, fault_rsp_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			FORTH_CHK_LOOP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_loop_sp) 
9aa3				ld de, cli_loop_stack 
9aa3				call cmp16 
9aa3				jp c, fault_loop_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			FORTH_ERR_TOS_NOTSTR: macro 
9aa3				; TOSO might need more for checks when used 
9aa3				push af 
9aa3				ld a,(hl) 
9aa3				cp DS_TYPE_STR 
9aa3				jp nz, type_faultn   
9aa3				pop af 
9aa3				endm 
9aa3			 
9aa3			FORTH_ERR_TOS_NOTNUM: macro 
9aa3				push af 
9aa3				ld a,(hl) 
9aa3				cp DS_TYPE_INUM 
9aa3				jp nz, type_faultn   
9aa3				pop af 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			; increase data stack pointer and save hl to it 
9aa3				 
9aa3			FORTH_DSP_NEXT: macro 
9aa3				call macro_forth_dsp_next 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			macro_forth_dsp_next: 
9aa3				if DEBUG_FORTH_STACK_GUARD 
9aa3 cd 9d d8				call check_stacks 
9aa6				endif 
9aa6 e5				push hl 
9aa7 d5				push de 
9aa8 eb				ex de,hl 
9aa9 2a b2 eb			ld hl,(cli_data_sp) 
9aac 23				inc hl 
9aad 23				inc hl 
9aae			 
9aae			; PARSEV5 
9aae 23				inc hl 
9aaf 22 b2 eb			ld (cli_data_sp),hl 
9ab2 73				ld (hl), e 
9ab3 23				inc hl 
9ab4 72				ld (hl), d 
9ab5 d1				pop de 
9ab6 e1				pop hl 
9ab7				if DEBUG_FORTH_STACK_GUARD 
9ab7 cd 9d d8				call check_stacks 
9aba				endif 
9aba c9				ret 
9abb			 
9abb			 
9abb			; increase ret stack pointer and save hl to it 
9abb				 
9abb			FORTH_RSP_NEXT: macro 
9abb				call macro_forth_rsp_next 
9abb				endm 
9abb			 
9abb			macro_forth_rsp_next: 
9abb				if DEBUG_FORTH_STACK_GUARD 
9abb cd 9d d8				call check_stacks 
9abe				endif 
9abe e5				push hl 
9abf d5				push de 
9ac0 eb				ex de,hl 
9ac1 2a b6 eb			ld hl,(cli_ret_sp) 
9ac4 23				inc hl 
9ac5 23				inc hl 
9ac6 22 b6 eb			ld (cli_ret_sp),hl 
9ac9 73				ld (hl), e 
9aca 23				inc hl 
9acb 72				ld (hl), d 
9acc d1				pop de 
9acd e1				pop hl 
9ace				if DEBUG_FORTH_STACK_GUARD 
9ace cd 9d d8				call check_stacks 
9ad1				endif 
9ad1 c9				ret 
9ad2			 
9ad2			; get current ret stack pointer and save to hl  
9ad2				 
9ad2			FORTH_RSP_TOS: macro 
9ad2				call macro_forth_rsp_tos 
9ad2				endm 
9ad2			 
9ad2			macro_forth_rsp_tos: 
9ad2				;push de 
9ad2 2a b6 eb			ld hl,(cli_ret_sp) 
9ad5 cd 0d 9b			call loadhlptrtohl 
9ad8				;ld e, (hl) 
9ad8				;inc hl 
9ad8				;ld d, (hl) 
9ad8				;ex de, hl 
9ad8					if DEBUG_FORTH_WORDS 
9ad8			;			DMARK "RST" 
9ad8						CALLMONITOR 
9ad8 cd a3 94			call break_point_state  
9adb				endm  
# End of macro CALLMONITOR
9adb					endif 
9adb				;pop de 
9adb c9				ret 
9adc			 
9adc			; pop ret stack pointer 
9adc				 
9adc			FORTH_RSP_POP: macro 
9adc				call macro_forth_rsp_pop 
9adc				endm 
9adc			 
9adc			 
9adc			macro_forth_rsp_pop: 
9adc				if DEBUG_FORTH_STACK_GUARD 
9adc			;		DMARK "RPP" 
9adc cd 9d d8				call check_stacks 
9adf					FORTH_CHK_RSP_UNDER 
9adf e5				push hl 
9ae0 d5				push de 
9ae1 2a b6 eb			ld hl,(cli_ret_sp) 
9ae4 11 70 eb			ld de, cli_ret_stack 
9ae7 cd c0 8c			call cmp16 
9aea da b1 d9			jp c, fault_rsp_under 
9aed d1				pop de 
9aee e1				pop hl 
9aef				endm 
# End of macro FORTH_CHK_RSP_UNDER
9aef				endif 
9aef e5				push hl 
9af0 2a b6 eb			ld hl,(cli_ret_sp) 
9af3			 
9af3			 
9af3				if FORTH_ENABLE_FREE 
9af3			 
9af3					; get pointer 
9af3			 
9af3					push de 
9af3					push hl 
9af3			 
9af3					ld e, (hl) 
9af3					inc hl 
9af3					ld d, (hl) 
9af3			 
9af3					ex de, hl 
9af3					call free 
9af3			 
9af3					pop hl 
9af3					pop de 
9af3			 
9af3			 
9af3				endif 
9af3			 
9af3			 
9af3 2b				dec hl 
9af4 2b				dec hl 
9af5 22 b6 eb			ld (cli_ret_sp), hl 
9af8				; do stack underflow checks 
9af8 e1				pop hl 
9af9				if DEBUG_FORTH_STACK_GUARD 
9af9 cd 9d d8				call check_stacks 
9afc					FORTH_CHK_RSP_UNDER 
9afc e5				push hl 
9afd d5				push de 
9afe 2a b6 eb			ld hl,(cli_ret_sp) 
9b01 11 70 eb			ld de, cli_ret_stack 
9b04 cd c0 8c			call cmp16 
9b07 da b1 d9			jp c, fault_rsp_under 
9b0a d1				pop de 
9b0b e1				pop hl 
9b0c				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b0c				endif 
9b0c c9				ret 
9b0d			 
9b0d			 
9b0d			 
9b0d			; routine to load word pointed to by hl into hl 
9b0d			 
9b0d			loadhlptrtohl: 
9b0d			 
9b0d d5				push de 
9b0e 5e				ld e, (hl) 
9b0f 23				inc hl 
9b10 56				ld d, (hl) 
9b11 eb				ex de, hl 
9b12 d1				pop de 
9b13			 
9b13 c9				ret 
9b14			 
9b14			 
9b14			 
9b14			 
9b14			 
9b14			; push a number held in HL onto the data stack 
9b14			; entry point for pushing a value when already in hl used in function above 
9b14			 
9b14			forth_push_numhl: 
9b14			 
9b14 e5				push hl    ; save value to push 
9b15			 
9b15			if DEBUG_FORTH_PUSH 
9b15				; see if disabled 
9b15			 
9b15			 
9b15 f5				push af 
9b16 3a 76 e4			ld a, (os_view_disable) 
9b19 fe 2a			cp '*' 
9b1b 28 34			jr z, .pskip2 
9b1d e5				push hl 
9b1e e5			push hl 
9b1f cd 75 8a			call clear_display 
9b22 e1			pop hl 
9b23 7c				ld a,h 
9b24 21 8a e7			ld hl, os_word_scratch 
9b27 cd a3 8f			call hexout 
9b2a e1				pop hl 
9b2b 7d				ld a,l 
9b2c 21 8c e7			ld hl, os_word_scratch+2 
9b2f cd a3 8f			call hexout 
9b32			 
9b32 21 8e e7			ld hl, os_word_scratch+4 
9b35 3e 00			ld a,0 
9b37 77				ld (hl),a 
9b38 11 8a e7			ld de,os_word_scratch 
9b3b 3e 14				ld a, display_row_2 
9b3d cd 88 8a				call str_at_display 
9b40 11 91 c6			ld de, .push_num 
9b43 3e 00			ld a, display_row_1 
9b45			 
9b45 cd 88 8a				call str_at_display 
9b48			 
9b48			 
9b48 cd 98 8a			call update_display 
9b4b cd f2 89			call delay1s 
9b4e cd f2 89			call delay1s 
9b51			.pskip2:  
9b51			 
9b51 f1				pop af 
9b52			endif	 
9b52			 
9b52			 
9b52				FORTH_DSP_NEXT 
9b52 cd a3 9a			call macro_forth_dsp_next 
9b55				endm 
# End of macro FORTH_DSP_NEXT
9b55			 
9b55 2a b2 eb			ld hl, (cli_data_sp) 
9b58			 
9b58				; save item type 
9b58 3e 02			ld a,  DS_TYPE_INUM 
9b5a 77				ld (hl), a 
9b5b 23				inc hl 
9b5c			 
9b5c				; get word off stack 
9b5c d1				pop de 
9b5d 7b				ld a,e 
9b5e 77				ld (hl), a 
9b5f 23				inc hl 
9b60 7a				ld a,d 
9b61 77				ld (hl), a 
9b62			 
9b62			if DEBUG_FORTH_PUSH 
9b62 2b				dec hl 
9b63 2b				dec hl 
9b64 2b				dec hl 
9b65						DMARK "PH5" 
9b65 f5				push af  
9b66 3a 7a 9b			ld a, (.dmark)  
9b69 32 b7 ee			ld (debug_mark),a  
9b6c 3a 7b 9b			ld a, (.dmark+1)  
9b6f 32 b8 ee			ld (debug_mark+1),a  
9b72 3a 7c 9b			ld a, (.dmark+2)  
9b75 32 b9 ee			ld (debug_mark+2),a  
9b78 18 03			jr .pastdmark  
9b7a ..			.dmark: db "PH5"  
9b7d f1			.pastdmark: pop af  
9b7e			endm  
# End of macro DMARK
9b7e				CALLMONITOR 
9b7e cd a3 94			call break_point_state  
9b81				endm  
# End of macro CALLMONITOR
9b81			endif	 
9b81			 
9b81 c9				ret 
9b82			 
9b82			 
9b82			; Push a string to stack pointed to by hl 
9b82			 
9b82			forth_push_str: 
9b82			 
9b82			if DEBUG_FORTH_PUSH 
9b82						DMARK "PSQ" 
9b82 f5				push af  
9b83 3a 97 9b			ld a, (.dmark)  
9b86 32 b7 ee			ld (debug_mark),a  
9b89 3a 98 9b			ld a, (.dmark+1)  
9b8c 32 b8 ee			ld (debug_mark+1),a  
9b8f 3a 99 9b			ld a, (.dmark+2)  
9b92 32 b9 ee			ld (debug_mark+2),a  
9b95 18 03			jr .pastdmark  
9b97 ..			.dmark: db "PSQ"  
9b9a f1			.pastdmark: pop af  
9b9b			endm  
# End of macro DMARK
9b9b				CALLMONITOR 
9b9b cd a3 94			call break_point_state  
9b9e				endm  
# End of macro CALLMONITOR
9b9e			endif	 
9b9e			    
9b9e e5				push hl 
9b9f e5				push hl 
9ba0			 
9ba0			;	ld a, 0   ; find end of string 
9ba0 cd 00 91			call strlenz 
9ba3			if DEBUG_FORTH_PUSH 
9ba3						DMARK "PQ2" 
9ba3 f5				push af  
9ba4 3a b8 9b			ld a, (.dmark)  
9ba7 32 b7 ee			ld (debug_mark),a  
9baa 3a b9 9b			ld a, (.dmark+1)  
9bad 32 b8 ee			ld (debug_mark+1),a  
9bb0 3a ba 9b			ld a, (.dmark+2)  
9bb3 32 b9 ee			ld (debug_mark+2),a  
9bb6 18 03			jr .pastdmark  
9bb8 ..			.dmark: db "PQ2"  
9bbb f1			.pastdmark: pop af  
9bbc			endm  
# End of macro DMARK
9bbc				CALLMONITOR 
9bbc cd a3 94			call break_point_state  
9bbf				endm  
# End of macro CALLMONITOR
9bbf			endif	 
9bbf eb				ex de, hl 
9bc0 e1				pop hl   ; get ptr to start of string 
9bc1			if DEBUG_FORTH_PUSH 
9bc1						DMARK "PQ3" 
9bc1 f5				push af  
9bc2 3a d6 9b			ld a, (.dmark)  
9bc5 32 b7 ee			ld (debug_mark),a  
9bc8 3a d7 9b			ld a, (.dmark+1)  
9bcb 32 b8 ee			ld (debug_mark+1),a  
9bce 3a d8 9b			ld a, (.dmark+2)  
9bd1 32 b9 ee			ld (debug_mark+2),a  
9bd4 18 03			jr .pastdmark  
9bd6 ..			.dmark: db "PQ3"  
9bd9 f1			.pastdmark: pop af  
9bda			endm  
# End of macro DMARK
9bda				CALLMONITOR 
9bda cd a3 94			call break_point_state  
9bdd				endm  
# End of macro CALLMONITOR
9bdd			endif	 
9bdd 19				add hl,de 
9bde			if DEBUG_FORTH_PUSH 
9bde						DMARK "PQE" 
9bde f5				push af  
9bdf 3a f3 9b			ld a, (.dmark)  
9be2 32 b7 ee			ld (debug_mark),a  
9be5 3a f4 9b			ld a, (.dmark+1)  
9be8 32 b8 ee			ld (debug_mark+1),a  
9beb 3a f5 9b			ld a, (.dmark+2)  
9bee 32 b9 ee			ld (debug_mark+2),a  
9bf1 18 03			jr .pastdmark  
9bf3 ..			.dmark: db "PQE"  
9bf6 f1			.pastdmark: pop af  
9bf7			endm  
# End of macro DMARK
9bf7				CALLMONITOR 
9bf7 cd a3 94			call break_point_state  
9bfa				endm  
# End of macro CALLMONITOR
9bfa			endif	 
9bfa			 
9bfa 2b				dec hl    ; see if there is an optional trailing double quote 
9bfb 7e				ld a,(hl) 
9bfc fe 22			cp '"' 
9bfe 20 03			jr nz, .strnoq 
9c00 3e 00			ld a, 0      ; get rid of double quote 
9c02 77				ld (hl), a 
9c03 23			.strnoq: inc hl 
9c04			 
9c04 3e 00			ld a, 0 
9c06 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c07			 
9c07 13				inc de ; add one for the type string 
9c08 13				inc de ; add one for null term??? 
9c09			 
9c09				; tos is get string pointer again 
9c09				; de contains space to allocate 
9c09				 
9c09 d5				push de 
9c0a			 
9c0a eb				ex de, hl 
9c0b			 
9c0b				;push af 
9c0b			 
9c0b			if DEBUG_FORTH_PUSH 
9c0b						DMARK "PHm" 
9c0b f5				push af  
9c0c 3a 20 9c			ld a, (.dmark)  
9c0f 32 b7 ee			ld (debug_mark),a  
9c12 3a 21 9c			ld a, (.dmark+1)  
9c15 32 b8 ee			ld (debug_mark+1),a  
9c18 3a 22 9c			ld a, (.dmark+2)  
9c1b 32 b9 ee			ld (debug_mark+2),a  
9c1e 18 03			jr .pastdmark  
9c20 ..			.dmark: db "PHm"  
9c23 f1			.pastdmark: pop af  
9c24			endm  
# End of macro DMARK
9c24				CALLMONITOR 
9c24 cd a3 94			call break_point_state  
9c27				endm  
# End of macro CALLMONITOR
9c27			endif	 
9c27 cd 69 91			call malloc	; on ret hl now contains allocated memory 
9c2a				if DEBUG_FORTH_MALLOC_GUARD 
9c2a cc e9 c6				call z,malloc_error 
9c2d				endif 
9c2d			 
9c2d				 
9c2d c1				pop bc    ; get length 
9c2e d1				pop de   ;  get string start    
9c2f			 
9c2f				; hl has destination from malloc 
9c2f			 
9c2f eb				ex de, hl    ; prep for ldir 
9c30			 
9c30 d5				push de   ; save malloc area for DSP later 
9c31				;push hl   ; save malloc area for DSP later 
9c31			 
9c31			if DEBUG_FORTH_PUSH 
9c31						DMARK "PHc" 
9c31 f5				push af  
9c32 3a 46 9c			ld a, (.dmark)  
9c35 32 b7 ee			ld (debug_mark),a  
9c38 3a 47 9c			ld a, (.dmark+1)  
9c3b 32 b8 ee			ld (debug_mark+1),a  
9c3e 3a 48 9c			ld a, (.dmark+2)  
9c41 32 b9 ee			ld (debug_mark+2),a  
9c44 18 03			jr .pastdmark  
9c46 ..			.dmark: db "PHc"  
9c49 f1			.pastdmark: pop af  
9c4a			endm  
# End of macro DMARK
9c4a				CALLMONITOR 
9c4a cd a3 94			call break_point_state  
9c4d				endm  
# End of macro CALLMONITOR
9c4d			endif	 
9c4d			 
9c4d			 
9c4d ed b0			ldir 
9c4f			 
9c4f			 
9c4f				; push malloc to data stack     macro?????  
9c4f			 
9c4f				FORTH_DSP_NEXT 
9c4f cd a3 9a			call macro_forth_dsp_next 
9c52				endm 
# End of macro FORTH_DSP_NEXT
9c52			 
9c52				; save value and type 
9c52			 
9c52 2a b2 eb			ld hl, (cli_data_sp) 
9c55			 
9c55				; save item type 
9c55 3e 01			ld a,  DS_TYPE_STR 
9c57 77				ld (hl), a 
9c58 23				inc hl 
9c59			 
9c59				; get malloc word off stack 
9c59 d1				pop de 
9c5a 73				ld (hl), e 
9c5b 23				inc hl 
9c5c 72				ld (hl), d 
9c5d			 
9c5d			 
9c5d			 
9c5d			if DEBUG_FORTH_PUSH 
9c5d 2a b2 eb			ld hl, (cli_data_sp) 
9c60						DMARK "PHS" 
9c60 f5				push af  
9c61 3a 75 9c			ld a, (.dmark)  
9c64 32 b7 ee			ld (debug_mark),a  
9c67 3a 76 9c			ld a, (.dmark+1)  
9c6a 32 b8 ee			ld (debug_mark+1),a  
9c6d 3a 77 9c			ld a, (.dmark+2)  
9c70 32 b9 ee			ld (debug_mark+2),a  
9c73 18 03			jr .pastdmark  
9c75 ..			.dmark: db "PHS"  
9c78 f1			.pastdmark: pop af  
9c79			endm  
# End of macro DMARK
9c79				CALLMONITOR 
9c79 cd a3 94			call break_point_state  
9c7c				endm  
# End of macro CALLMONITOR
9c7c			;	ex de,hl 
9c7c			endif	 
9c7c				; in case of spaces, skip the ptr past the copied string 
9c7c				;pop af 
9c7c				;ld (cli_origptr),hl 
9c7c			 
9c7c c9				ret 
9c7d			 
9c7d			 
9c7d			 
9c7d			; TODO ascii push input onto stack given hl to start of input 
9c7d			 
9c7d			; identify type 
9c7d			; if starts with a " then a string 
9c7d			; otherwise it is a number 
9c7d			;  
9c7d			; if a string 
9c7d			;     scan for ending " to get length of string to malloc for + 1 
9c7d			;     malloc 
9c7d			;     put pointer to string on stack first byte flags as string 
9c7d			; 
9c7d			; else a number 
9c7d			;    look for number format identifier 
9c7d			;    $xx hex 
9c7d			;    %xxxxx bin 
9c7d			;    xxxxx decimal 
9c7d			;    convert number to 16bit word.  
9c7d			;    malloc word + 1 with flag to identiy as num 
9c7d			;    put pointer to number on stack 
9c7d			;   
9c7d			;  
9c7d			  
9c7d			forth_apush: 
9c7d				; kernel push 
9c7d			 
9c7d			if DEBUG_FORTH_PUSH 
9c7d						DMARK "PSH" 
9c7d f5				push af  
9c7e 3a 92 9c			ld a, (.dmark)  
9c81 32 b7 ee			ld (debug_mark),a  
9c84 3a 93 9c			ld a, (.dmark+1)  
9c87 32 b8 ee			ld (debug_mark+1),a  
9c8a 3a 94 9c			ld a, (.dmark+2)  
9c8d 32 b9 ee			ld (debug_mark+2),a  
9c90 18 03			jr .pastdmark  
9c92 ..			.dmark: db "PSH"  
9c95 f1			.pastdmark: pop af  
9c96			endm  
# End of macro DMARK
9c96				CALLMONITOR 
9c96 cd a3 94			call break_point_state  
9c99				endm  
# End of macro CALLMONITOR
9c99			endif	 
9c99				; identify input type 
9c99			 
9c99 7e				ld a,(hl) 
9c9a fe 22			cp '"' 
9c9c 28 0a			jr z, .fapstr 
9c9e fe 24			cp '$' 
9ca0 ca c8 9c			jp z, .faphex 
9ca3 fe 25			cp '%' 
9ca5 ca b0 9c			jp z, .fapbin 
9ca8			;	cp 'b' 
9ca8			;	jp z, .fabin 
9ca8				; else decimal 
9ca8			 
9ca8				; TODO do decimal conversion 
9ca8				; decimal is stored as a 16bit word 
9ca8			 
9ca8				; by default everything is a string if type is not detected 
9ca8			.fapstr: ; 
9ca8 fe 22			cp '"' 
9caa 20 01			jr nz, .strnoqu 
9cac 23				inc hl 
9cad			.strnoqu: 
9cad c3 82 9b			jp forth_push_str 
9cb0			 
9cb0			 
9cb0			 
9cb0			.fapbin:    ; push a binary string.  
9cb0 11 00 00			ld de, 0   ; hold a 16bit value 
9cb3			 
9cb3 23			.fapbinshift:	inc hl  
9cb4 7e				ld a,(hl) 
9cb5 fe 00			cp 0     ; done scanning  
9cb7 28 0b			jr z, .fapbdone  	; got it in HL so push  
9cb9			 
9cb9				; left shift de 
9cb9 eb				ex de, hl	 
9cba 29				add hl, hl 
9cbb			 
9cbb				; is 1 
9cbb fe 31			cp '1' 
9cbd 20 02			jr nz, .binzero 
9cbf cb 4d			bit 1, l 
9cc1			.binzero: 
9cc1 eb				ex de, hl	 ; save current de 
9cc2 18 ef			jr .fapbinshift 
9cc4			 
9cc4			.fapbdone: 
9cc4 eb				ex de, hl 
9cc5 c3 14 9b			jp forth_push_numhl 
9cc8			 
9cc8			 
9cc8			.faphex:   ; hex is always stored as a 16bit word 
9cc8				; skip number prefix 
9cc8 23				inc hl 
9cc9				; turn ascii into number 
9cc9 cd 59 90			call get_word_hl	; ret 16bit word in hl 
9ccc			 
9ccc c3 14 9b			jp forth_push_numhl 
9ccf			 
9ccf 00				 nop 
9cd0			 
9cd0			.fabin:   ; TODO bin conversion 
9cd0			 
9cd0			 
9cd0 c9				ret 
9cd1			 
9cd1			 
9cd1			; get either a string ptr or a 16bit word from the data stack 
9cd1			 
9cd1			FORTH_DSP: macro 
9cd1				call macro_forth_dsp 
9cd1				endm 
9cd1			 
9cd1			macro_forth_dsp: 
9cd1				; data stack pointer points to current word on tos 
9cd1			 
9cd1 2a b2 eb			ld hl,(cli_data_sp) 
9cd4			 
9cd4				if DEBUG_FORTH_PUSH 
9cd4						DMARK "DSP" 
9cd4 f5				push af  
9cd5 3a e9 9c			ld a, (.dmark)  
9cd8 32 b7 ee			ld (debug_mark),a  
9cdb 3a ea 9c			ld a, (.dmark+1)  
9cde 32 b8 ee			ld (debug_mark+1),a  
9ce1 3a eb 9c			ld a, (.dmark+2)  
9ce4 32 b9 ee			ld (debug_mark+2),a  
9ce7 18 03			jr .pastdmark  
9ce9 ..			.dmark: db "DSP"  
9cec f1			.pastdmark: pop af  
9ced			endm  
# End of macro DMARK
9ced			 
9ced cd 1e c7				call display_data_sp 
9cf0				;call break_point_state 
9cf0				;rst 030h 
9cf0				CALLMONITOR 
9cf0 cd a3 94			call break_point_state  
9cf3				endm  
# End of macro CALLMONITOR
9cf3				endif 
9cf3			 
9cf3 c9				ret 
9cf4			 
9cf4			; return hl to start of value on stack 
9cf4			 
9cf4			FORTH_DSP_VALUE: macro 
9cf4				call macro_forth_dsp_value 
9cf4				endm 
9cf4			 
9cf4			macro_forth_dsp_value: 
9cf4			 
9cf4				FORTH_DSP 
9cf4 cd d1 9c			call macro_forth_dsp 
9cf7				endm 
# End of macro FORTH_DSP
9cf7			 
9cf7 d5				push de 
9cf8			 
9cf8 23				inc hl ; skip type 
9cf9			 
9cf9 5e				ld e, (hl) 
9cfa 23				inc hl 
9cfb 56				ld d, (hl) 
9cfc eb				ex de,hl  
9cfd			 
9cfd d1				pop de 
9cfe			 
9cfe c9				ret 
9cff			 
9cff			; return hl to start of value to second item on stack 
9cff			 
9cff			FORTH_DSP_VALUEM1: macro 
9cff				call macro_forth_dsp_value_m1 
9cff				endm 
9cff			 
9cff			macro_forth_dsp_value_m1: 
9cff			 
9cff				FORTH_DSP 
9cff cd d1 9c			call macro_forth_dsp 
9d02				endm 
# End of macro FORTH_DSP
9d02			 
9d02 2b				dec hl 
9d03 2b				dec hl 
9d04			;	dec hl 
9d04			 
9d04 d5				push de 
9d05			 
9d05 5e				ld e, (hl) 
9d06 23				inc hl 
9d07 56				ld d, (hl) 
9d08 eb				ex de,hl  
9d09			 
9d09 d1				pop de 
9d0a			 
9d0a c9				ret 
9d0b			 
9d0b				 
9d0b			 
9d0b			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d0b			 
9d0b			FORTH_DSP_POP: macro 
9d0b				call macro_forth_dsp_pop 
9d0b				endm 
9d0b			 
9d0b			 
9d0b			; get the tos data type 
9d0b			 
9d0b			FORTH_DSP_TYPE:   macro 
9d0b			 
9d0b				;FORTH_DSP_VALUE 
9d0b				FORTH_DSP 
9d0b				 
9d0b				; hl points to value 
9d0b				; check type 
9d0b			 
9d0b				ld a,(hl) 
9d0b			 
9d0b				endm 
9d0b			 
9d0b			; load the tos value into hl 
9d0b			 
9d0b			 
9d0b			FORTH_DSP_VALUEHL:  macro 
9d0b				call macro_dsp_valuehl 
9d0b				endm 
9d0b			 
9d0b			 
9d0b			 
9d0b			macro_dsp_valuehl: 
9d0b				FORTH_DSP_VALUE 
9d0b cd f4 9c			call macro_forth_dsp_value 
9d0e				endm 
# End of macro FORTH_DSP_VALUE
9d0e			 
9d0e				;FORTH_ERR_TOS_NOTNUM 
9d0e			 
9d0e				;inc hl   ; skip type id 
9d0e			 
9d0e			;	push de 
9d0e			; 
9d0e			;	ld e, (hl) 
9d0e			;	inc hl 
9d0e			;	ld d, (hl) 
9d0e			;	ex de,hl  
9d0e			 
9d0e			;	pop de 
9d0e			 
9d0e				if DEBUG_FORTH_PUSH 
9d0e						DMARK "DVL" 
9d0e f5				push af  
9d0f 3a 23 9d			ld a, (.dmark)  
9d12 32 b7 ee			ld (debug_mark),a  
9d15 3a 24 9d			ld a, (.dmark+1)  
9d18 32 b8 ee			ld (debug_mark+1),a  
9d1b 3a 25 9d			ld a, (.dmark+2)  
9d1e 32 b9 ee			ld (debug_mark+2),a  
9d21 18 03			jr .pastdmark  
9d23 ..			.dmark: db "DVL"  
9d26 f1			.pastdmark: pop af  
9d27			endm  
# End of macro DMARK
9d27				CALLMONITOR 
9d27 cd a3 94			call break_point_state  
9d2a				endm  
# End of macro CALLMONITOR
9d2a				endif 
9d2a c9				ret 
9d2b			 
9d2b			forth_apushstrhl:      
9d2b				; push of string requires use of cli_origptr 
9d2b				; bodge use 
9d2b			 
9d2b				; get current cli_origptr, save, update with temp pointer  
9d2b ed 5b ce eb		ld de, (cli_origptr) 
9d2f 22 ce eb			ld (cli_origptr), hl 
9d32 d5				push de 
9d33 cd 7d 9c			call forth_apush 
9d36 d1				pop de 
9d37 ed 53 ce eb		ld (cli_origptr), de 
9d3b c9			        ret	 
9d3c			 
9d3c			 
9d3c			; increase loop stack pointer and save hl to it 
9d3c				 
9d3c			FORTH_LOOP_NEXT: macro 
9d3c				call macro_forth_loop_next 
9d3c				;nop 
9d3c				endm 
9d3c			 
9d3c			macro_forth_loop_next: 
9d3c				if DEBUG_FORTH_STACK_GUARD 
9d3c cd 9d d8				call check_stacks 
9d3f				endif 
9d3f e5				push hl 
9d40 d5				push de 
9d41 eb				ex de,hl 
9d42 2a b4 eb			ld hl,(cli_loop_sp) 
9d45 23				inc hl 
9d46 23				inc hl 
9d47					if DEBUG_FORTH_WORDS 
9d47						DMARK "LNX" 
9d47 f5				push af  
9d48 3a 5c 9d			ld a, (.dmark)  
9d4b 32 b7 ee			ld (debug_mark),a  
9d4e 3a 5d 9d			ld a, (.dmark+1)  
9d51 32 b8 ee			ld (debug_mark+1),a  
9d54 3a 5e 9d			ld a, (.dmark+2)  
9d57 32 b9 ee			ld (debug_mark+2),a  
9d5a 18 03			jr .pastdmark  
9d5c ..			.dmark: db "LNX"  
9d5f f1			.pastdmark: pop af  
9d60			endm  
# End of macro DMARK
9d60						CALLMONITOR 
9d60 cd a3 94			call break_point_state  
9d63				endm  
# End of macro CALLMONITOR
9d63					endif 
9d63 22 b4 eb			ld (cli_loop_sp),hl 
9d66 73				ld (hl), e 
9d67 23				inc hl 
9d68 72				ld (hl), d 
9d69 d1				pop de    ; been reversed so save a swap on restore 
9d6a e1				pop hl 
9d6b				if DEBUG_FORTH_STACK_GUARD 
9d6b cd 9d d8				call check_stacks 
9d6e				endif 
9d6e c9				ret 
9d6f			 
9d6f			; get current ret stack pointer and save to hl  
9d6f				 
9d6f			FORTH_LOOP_TOS: macro 
9d6f				call macro_forth_loop_tos 
9d6f				endm 
9d6f			 
9d6f			macro_forth_loop_tos: 
9d6f d5				push de 
9d70 2a b4 eb			ld hl,(cli_loop_sp) 
9d73 5e				ld e, (hl) 
9d74 23				inc hl 
9d75 56				ld d, (hl) 
9d76 eb				ex de, hl 
9d77 d1				pop de 
9d78 c9				ret 
9d79			 
9d79			; pop loop stack pointer 
9d79				 
9d79			FORTH_LOOP_POP: macro 
9d79				call macro_forth_loop_pop 
9d79				endm 
9d79			 
9d79			 
9d79			macro_forth_loop_pop: 
9d79				if DEBUG_FORTH_STACK_GUARD 
9d79					DMARK "LPP" 
9d79 f5				push af  
9d7a 3a 8e 9d			ld a, (.dmark)  
9d7d 32 b7 ee			ld (debug_mark),a  
9d80 3a 8f 9d			ld a, (.dmark+1)  
9d83 32 b8 ee			ld (debug_mark+1),a  
9d86 3a 90 9d			ld a, (.dmark+2)  
9d89 32 b9 ee			ld (debug_mark+2),a  
9d8c 18 03			jr .pastdmark  
9d8e ..			.dmark: db "LPP"  
9d91 f1			.pastdmark: pop af  
9d92			endm  
# End of macro DMARK
9d92 cd 9d d8				call check_stacks 
9d95					FORTH_CHK_LOOP_UNDER 
9d95 e5				push hl 
9d96 d5				push de 
9d97 2a b4 eb			ld hl,(cli_loop_sp) 
9d9a 11 ee ea			ld de, cli_loop_stack 
9d9d cd c0 8c			call cmp16 
9da0 da b7 d9			jp c, fault_loop_under 
9da3 d1				pop de 
9da4 e1				pop hl 
9da5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9da5				endif 
9da5 e5				push hl 
9da6 2a b4 eb			ld hl,(cli_loop_sp) 
9da9 2b				dec hl 
9daa 2b				dec hl 
9dab 22 b4 eb			ld (cli_loop_sp), hl 
9dae				; TODO do stack underflow checks 
9dae e1				pop hl 
9daf				if DEBUG_FORTH_STACK_GUARD 
9daf cd 9d d8				call check_stacks 
9db2					FORTH_CHK_LOOP_UNDER 
9db2 e5				push hl 
9db3 d5				push de 
9db4 2a b4 eb			ld hl,(cli_loop_sp) 
9db7 11 ee ea			ld de, cli_loop_stack 
9dba cd c0 8c			call cmp16 
9dbd da b7 d9			jp c, fault_loop_under 
9dc0 d1				pop de 
9dc1 e1				pop hl 
9dc2				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9dc2				endif 
9dc2 c9				ret 
9dc3			 
9dc3			macro_forth_dsp_pop: 
9dc3			 
9dc3 e5				push hl 
9dc4			 
9dc4				; release malloc data 
9dc4			 
9dc4				if DEBUG_FORTH_STACK_GUARD 
9dc4 cd 9d d8				call check_stacks 
9dc7					FORTH_CHK_DSP_UNDER 
9dc7 e5				push hl 
9dc8 d5				push de 
9dc9 2a b2 eb			ld hl,(cli_data_sp) 
9dcc 11 ec e9			ld de, cli_data_stack 
9dcf cd c0 8c			call cmp16 
9dd2 da ab d9			jp c, fault_dsp_under 
9dd5 d1				pop de 
9dd6 e1				pop hl 
9dd7				endm 
# End of macro FORTH_CHK_DSP_UNDER
9dd7				endif 
9dd7				;ld hl,(cli_data_sp) 
9dd7			if DEBUG_FORTH_DOT 
9dd7				DMARK "DPP" 
9dd7				CALLMONITOR 
9dd7			endif	 
9dd7			 
9dd7			 
9dd7			if FORTH_ENABLE_DSPPOPFREE 
9dd7			 
9dd7				FORTH_DSP 
9dd7 cd d1 9c			call macro_forth_dsp 
9dda				endm 
# End of macro FORTH_DSP
9dda			 
9dda 7e				ld a, (hl) 
9ddb fe 01			cp DS_TYPE_STR 
9ddd 20 07			jr nz, .skippopfree 
9ddf			 
9ddf				FORTH_DSP_VALUEHL 
9ddf cd 0b 9d			call macro_dsp_valuehl 
9de2				endm 
# End of macro FORTH_DSP_VALUEHL
9de2 00				nop 
9de3			if DEBUG_FORTH_DOT 
9de3				DMARK "DPf" 
9de3				CALLMONITOR 
9de3			endif	 
9de3 cd 33 92			call free 
9de6			.skippopfree: 
9de6				 
9de6			 
9de6			endif 
9de6			 
9de6			if DEBUG_FORTH_DOT_KEY 
9de6				DMARK "DP2" 
9de6				CALLMONITOR 
9de6			endif	 
9de6			 
9de6				; move pointer down 
9de6			 
9de6 2a b2 eb			ld hl,(cli_data_sp) 
9de9 2b				dec hl 
9dea 2b				dec hl 
9deb			; PARSEV5 
9deb 2b				dec hl 
9dec 22 b2 eb			ld (cli_data_sp), hl 
9def			 
9def				if DEBUG_FORTH_STACK_GUARD 
9def cd 9d d8				call check_stacks 
9df2					FORTH_CHK_DSP_UNDER 
9df2 e5				push hl 
9df3 d5				push de 
9df4 2a b2 eb			ld hl,(cli_data_sp) 
9df7 11 ec e9			ld de, cli_data_stack 
9dfa cd c0 8c			call cmp16 
9dfd da ab d9			jp c, fault_dsp_under 
9e00 d1				pop de 
9e01 e1				pop hl 
9e02				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e02				endif 
9e02			 
9e02 e1				pop hl 
9e03			 
9e03 c9				ret 
9e04			 
9e04			getwordathl: 
9e04				; hl points to an address 
9e04				; load hl with the word at that address 
9e04			 
9e04 d5				push de 
9e05			 
9e05 5e				ld e, (hl) 
9e06 23				inc hl 
9e07 56				ld d, (hl) 
9e08 eb				ex de, hl 
9e09			 
9e09 d1				pop de 
9e0a c9				ret 
9e0b			 
9e0b			 
9e0b			 
9e0b			 
9e0b			 
9e0b			; eof 
9e0b			 
# End of file forth_stackopsv5.asm
9e0b			endif 
9e0b			 
9e0b			user_word_eol:  
9e0b				; hl contains the pointer to where to create a linked list item from the end 
9e0b				; of the user dict to continue on at the system word dict 
9e0b				 
9e0b				; poke the stub of the word list linked list to repoint to rom words 
9e0b			 
9e0b				; stub format 
9e0b				; db   word id 
9e0b				; dw    link to next word 
9e0b			        ; db char length of token 
9e0b				; db string + 0 term 
9e0b				; db exec code....  
9e0b			 
9e0b 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e0d 77				ld (hl), a		; word id 
9e0e 23				inc hl 
9e0f			 
9e0f 11 da 9f			ld de, sysdict 
9e12 73				ld (hl), e		; next word link ie system dict 
9e13 23				inc hl 
9e14 72				ld (hl), d		; next word link ie system dict 
9e15 23				inc hl	 
9e16			 
9e16			;	ld (hl), sysdict		; next word link ie system dict 
9e16			;	inc hl 
9e16			;	inc hl 
9e16			 
9e16			;	inc hl 
9e16			;	inc hl 
9e16			 
9e16 3e 02			ld a, 2			; word length is 0 
9e18 77				ld (hl), a	 
9e19 23				inc hl 
9e1a			 
9e1a 3e 7e			ld a, '~'			; word length is 0 
9e1c 77				ld (hl), a	 
9e1d 23				inc hl 
9e1e 3e 00			ld a, 0			; save empty word 
9e20 77				ld (hl), a 
9e21			 
9e21 c9				ret 
9e22			 
9e22				 
9e22			 
9e22			forthexec_cleanup: 
9e22				FORTH_RSP_POP 
9e22 cd dc 9a			call macro_forth_rsp_pop 
9e25				endm 
# End of macro FORTH_RSP_POP
9e25 c9				ret 
9e26			 
9e26			forth_call_hl: 
9e26				; taking hl 
9e26 e5				push hl 
9e27 c9				ret 
9e28			 
9e28			; this is called to reset Forth system but keep existing uwords etc 
9e28			 
9e28			forth_warmstart: 
9e28				; setup stack over/under flow checks 
9e28				if DEBUG_FORTH_STACK_GUARD 
9e28 cd 83 d8				call chk_stk_init 
9e2b				endif 
9e2b			 
9e2b				; init stack pointers  - * these stacks go upwards *  
9e2b 21 70 eb			ld hl, cli_ret_stack 
9e2e 22 b6 eb			ld (cli_ret_sp), hl	 
9e31				; set bottom of stack 
9e31 3e 00			ld a,0 
9e33 77				ld (hl),a 
9e34 23				inc hl 
9e35 77				ld (hl),a 
9e36			 
9e36 21 ec e9			ld hl, cli_data_stack 
9e39 22 b2 eb			ld (cli_data_sp), hl	 
9e3c				; set bottom of stack 
9e3c 3e 00			ld a,0 
9e3e 77				ld (hl),a 
9e3f 23				inc hl 
9e40 77				ld (hl),a 
9e41			 
9e41 21 ee ea			ld hl, cli_loop_stack 
9e44 22 b4 eb			ld (cli_loop_sp), hl	 
9e47				; set bottom of stack 
9e47 3e 00			ld a,0 
9e49 77				ld (hl),a 
9e4a 23				inc hl 
9e4b 77				ld (hl),a 
9e4c			 
9e4c				; init extent of current open file 
9e4c			 
9e4c 3e 00			ld a, 0 
9e4e 32 fa eb			ld (store_openext), a 
9e51			 
9e51 c9				ret 
9e52			 
9e52			 
9e52			; Cold Start - this is called to setup the whole Forth system 
9e52			 
9e52			forth_init: 
9e52			 
9e52				; setup stack over/under flow checks 
9e52			 
9e52			;	if DEBUG_FORTH_STACK_GUARD 
9e52			;		call chk_stk_init 
9e52			;	endif 
9e52			 
9e52				; enable auto display updates (slow.....) 
9e52			 
9e52 3e 01			ld a, 1 
9e54 32 cc eb			ld (cli_autodisplay), a 
9e57			 
9e57				; if storage is in use disable long reads for now 
9e57 3e 00			ld a, 0 
9e59 32 05 ec			ld (store_longread), a 
9e5c			 
9e5c			 
9e5c				; show start up screen 
9e5c			 
9e5c cd 75 8a			call clear_display 
9e5f			 
9e5f 3e 00			ld a,0 
9e61 32 ee eb			ld (f_cursor_ptr), a 
9e64			 
9e64				; set start of word list in start of ram - for use when creating user words 
9e64			 
9e64 21 4e db			ld hl, baseram 
9e67 22 82 e7			ld (os_last_new_uword), hl 
9e6a cd 0b 9e			call user_word_eol 
9e6d				 
9e6d			;		call display_data_sp 
9e6d			;		call next_page_prompt 
9e6d			 
9e6d			 
9e6d			 
9e6d			 
9e6d c9				ret 
9e6e			 
9e6e .. 00		.bootforth: db " Forth Kernel Init ",0 
9e82			 
9e82			; TODO push to stack 
9e82			 
9e82			;  
9e82			 
9e82			if FORTH_PARSEV2 
9e82			 
9e82			 
9e82				include "forth_parserv2.asm" 
9e82			 
9e82			endif 
9e82			 
9e82			 
9e82			; parse cli version 1 
9e82			 
9e82			if FORTH_PARSEV1 
9e82			 
9e82			 
9e82			 
9e82			      include "forth_parserv1.asm" 
9e82			endif 
9e82				 
9e82			if FORTH_PARSEV3 
9e82			 
9e82			 
9e82			 
9e82			      include "forth_parserv3.asm" 
9e82				include "forth_wordsv3.asm" 
9e82			endif 
9e82			 
9e82			if FORTH_PARSEV4 
9e82			 
9e82			 
9e82			 
9e82			      include "forth_parserv4.asm" 
9e82				include "forth_wordsv4.asm" 
9e82			endif 
9e82			 
9e82			if FORTH_PARSEV5 
9e82			 
9e82			 
9e82			 
9e82			      include "forth_parserv5.asm" 
9e82			 
9e82			 
9e82			; A better parser without using malloc and string copies all over the place.  
9e82			; Exec in situ should be faster 
9e82			 
9e82			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9e82			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9e82			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9e82			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9e82			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9e82			WORD_SYS_END: equ 0   ; Opcode for all user words 
9e82			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9e82			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9e82			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9e82			 
9e82			; Core word preamble macro 
9e82			 
9e82			CWHEAD:   macro nxtword opcode lit len opflags 
9e82				db WORD_SYS_CORE+opcode             
9e82				; internal op code number 
9e82				dw nxtword            
9e82				; link to next dict word block 
9e82				db len + 1 
9e82				; literal length of dict word inc zero term 
9e82				db lit,0              
9e82				; literal dict word 
9e82			        ; TODO db opflags        
9e82				endm 
9e82			 
9e82			 
9e82			NEXTW: macro  
9e82				jp macro_next 
9e82				endm 
9e82			 
9e82			macro_next: 
9e82			if DEBUG_FORTH_PARSE_KEY 
9e82				DMARK "NXT" 
9e82				CALLMONITOR 
9e82			endif	 
9e82			;	inc hl  ; skip token null term  
9e82 ed 4b d0 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e86 ed 5b ce eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e8a 2a 86 e7			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e8d			if DEBUG_FORTH_PARSE_KEY 
9e8d				DMARK "}AA" 
9e8d				CALLMONITOR 
9e8d			endif	 
9e8d c3 90 9f			jp execnext 
9e90				;jp exec1 
9e90			       
9e90			 
9e90			 
9e90			; Another go at the parser to compile  
9e90			 
9e90			 
9e90			; TODO rework parser to change all of the string words to byte tokens 
9e90			; TODO do a search for  
9e90			 
9e90			; TODO first run normal parser to zero term sections 
9e90			; TODO for each word do a token look up to get the op code 
9e90			; TODO need some means to flag to the exec that this is a byte code form    
9e90			 
9e90			 
9e90			forthcompile: 
9e90			 
9e90			; 
9e90			; line parse: 
9e90			;       parse raw input buffer 
9e90			;       tokenise the words 
9e90			;       malloc new copy (for looping etc) 
9e90			;       copy to malloc + current pc in line to start of string and add line term 
9e90			;       save on new rsp 
9e90			; 
9e90			 
9e90			; hl to point to the line to tokenise 
9e90			 
9e90			;	push hl 
9e90 22 86 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9e93			 
9e93			;	ld a,0		; string term on input 
9e93			;	call strlent 
9e93			 
9e93			;	ld (os_tok_len), hl	 ; save string length 
9e93			 
9e93			;if DEBUG_FORTH_TOK 
9e93			;	ex de,hl		 
9e93			;endif 
9e93			 
9e93			;	pop hl 		; get back string pointer 
9e93			 
9e93			if DEBUG_FORTH_TOK 
9e93						DMARK "TOc" 
9e93				CALLMONITOR 
9e93			endif 
9e93 7e			.cptoken2:    ld a,(hl) 
9e94 23				inc hl 
9e95 fe 7f			cp FORTH_END_BUFFER 
9e97 28 29			jr z, .cptokendone2 
9e99 fe 00			cp 0 
9e9b 28 25			jr z, .cptokendone2 
9e9d fe 22			cp '"' 
9e9f 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9ea1 fe 20			cp ' ' 
9ea3 20 ee			jr nz,  .cptoken2 
9ea5			 
9ea5			; TODO consume comments held between ( and ) 
9ea5			 
9ea5				; we have a space so change to zero term for dict match later 
9ea5 2b				dec hl 
9ea6 3e 00			ld a,0 
9ea8 77				ld (hl), a 
9ea9 23				inc hl 
9eaa 18 e7			jr .cptoken2 
9eac				 
9eac			 
9eac			.cptokenstr2: 
9eac				; skip all white space until either eol (because forgot to term) or end double quote 
9eac			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9eac				;inc hl ; skip current double quote 
9eac 7e				ld a,(hl) 
9ead 23				inc hl 
9eae fe 22			cp '"' 
9eb0 28 e1			jr z, .cptoken2 
9eb2 fe 7f			cp FORTH_END_BUFFER 
9eb4 28 0c			jr z, .cptokendone2 
9eb6 fe 00			cp 0 
9eb8 28 08			jr z, .cptokendone2 
9eba fe 20			cp ' ' 
9ebc 28 02			jr z, .cptmp2 
9ebe 18 ec			jr .cptokenstr2 
9ec0			 
9ec0			.cptmp2:	; we have a space so change to zero term for dict match later 
9ec0				;dec hl 
9ec0				;ld a,"-"	; TODO remove this when working 
9ec0				;ld (hl), a 
9ec0				;inc hl 
9ec0 18 ea			jr .cptokenstr2 
9ec2			 
9ec2			.cptokendone2: 
9ec2				;inc hl 
9ec2 3e 7f			ld a, FORTH_END_BUFFER 
9ec4 77				ld (hl),a 
9ec5 23				inc hl 
9ec6 3e 21			ld a, '!' 
9ec8 77				ld (hl),a 
9ec9			 
9ec9 2a 86 e7			ld hl,(os_tok_ptr) 
9ecc			         
9ecc			if DEBUG_FORTH_TOK 
9ecc						DMARK "Tc1" 
9ecc				CALLMONITOR 
9ecc			endif 
9ecc			 
9ecc				; push exec string to top of return stack 
9ecc				FORTH_RSP_NEXT 
9ecc cd bb 9a			call macro_forth_rsp_next 
9ecf				endm 
# End of macro FORTH_RSP_NEXT
9ecf c9				ret 
9ed0			 
9ed0			; Another go at the parser need to simplify the process 
9ed0			 
9ed0			forthparse: 
9ed0			 
9ed0			; 
9ed0			; line parse: 
9ed0			;       parse raw input buffer 
9ed0			;       tokenise the words 
9ed0			;       malloc new copy (for looping etc) 
9ed0			;       copy to malloc + current pc in line to start of string and add line term 
9ed0			;       save on new rsp 
9ed0			; 
9ed0			 
9ed0			; hl to point to the line to tokenise 
9ed0			 
9ed0			;	push hl 
9ed0 22 86 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9ed3			 
9ed3			;	ld a,0		; string term on input 
9ed3			;	call strlent 
9ed3			 
9ed3			;	ld (os_tok_len), hl	 ; save string length 
9ed3			 
9ed3			;if DEBUG_FORTH_TOK 
9ed3			;	ex de,hl		 
9ed3			;endif 
9ed3			 
9ed3			;	pop hl 		; get back string pointer 
9ed3			 
9ed3			if DEBUG_FORTH_TOK 
9ed3						DMARK "TOK" 
9ed3				CALLMONITOR 
9ed3			endif 
9ed3 7e			.ptoken2:    ld a,(hl) 
9ed4 23				inc hl 
9ed5 fe 7f			cp FORTH_END_BUFFER 
9ed7 28 29			jr z, .ptokendone2 
9ed9 fe 00			cp 0 
9edb 28 25			jr z, .ptokendone2 
9edd fe 22			cp '"' 
9edf 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9ee1 fe 20			cp ' ' 
9ee3 20 ee			jr nz,  .ptoken2 
9ee5			 
9ee5			; TODO consume comments held between ( and ) 
9ee5			 
9ee5				; we have a space so change to zero term for dict match later 
9ee5 2b				dec hl 
9ee6 3e 00			ld a,0 
9ee8 77				ld (hl), a 
9ee9 23				inc hl 
9eea 18 e7			jr .ptoken2 
9eec				 
9eec			 
9eec			.ptokenstr2: 
9eec				; skip all white space until either eol (because forgot to term) or end double quote 
9eec			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9eec				;inc hl ; skip current double quote 
9eec 7e				ld a,(hl) 
9eed 23				inc hl 
9eee fe 22			cp '"' 
9ef0 28 e1			jr z, .ptoken2 
9ef2 fe 7f			cp FORTH_END_BUFFER 
9ef4 28 0c			jr z, .ptokendone2 
9ef6 fe 00			cp 0 
9ef8 28 08			jr z, .ptokendone2 
9efa fe 20			cp ' ' 
9efc 28 02			jr z, .ptmp2 
9efe 18 ec			jr .ptokenstr2 
9f00			 
9f00			.ptmp2:	; we have a space so change to zero term for dict match later 
9f00				;dec hl 
9f00				;ld a,"-"	; TODO remove this when working 
9f00				;ld (hl), a 
9f00				;inc hl 
9f00 18 ea			jr .ptokenstr2 
9f02			 
9f02			.ptokendone2: 
9f02				;inc hl 
9f02 3e 7f			ld a, FORTH_END_BUFFER 
9f04 77				ld (hl),a 
9f05 23				inc hl 
9f06 3e 21			ld a, '!' 
9f08 77				ld (hl),a 
9f09			 
9f09 2a 86 e7			ld hl,(os_tok_ptr) 
9f0c			         
9f0c			if DEBUG_FORTH_TOK 
9f0c						DMARK "TK1" 
9f0c				CALLMONITOR 
9f0c			endif 
9f0c			 
9f0c				; push exec string to top of return stack 
9f0c				FORTH_RSP_NEXT 
9f0c cd bb 9a			call macro_forth_rsp_next 
9f0f				endm 
# End of macro FORTH_RSP_NEXT
9f0f c9				ret 
9f10			 
9f10			; 
9f10			;	; malloc size + buffer pointer + if is loop flag 
9f10			;	ld hl,(os_tok_len) 		 ; get string length 
9f10			; 
9f10			;	ld a,l 
9f10			; 
9f10			;	cp 0			; we dont want to use a null string 
9f10			;	ret z 
9f10			; 
9f10			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f10			; 
9f10			;	add 5     ; TODO when certain not over writing memory remove 
9f10			; 
9f10			;		 
9f10			; 
9f10			;if DEBUG_FORTH_TOK 
9f10			;			DMARK "TKE" 
9f10			;	CALLMONITOR 
9f10			;endif 
9f10			; 
9f10			;	ld l,a 
9f10			;	ld h,0 
9f10			;;	push hl   ; save required space for the copy later 
9f10			;	call malloc 
9f10			;if DEBUG_FORTH_TOK 
9f10			;			DMARK "TKM" 
9f10			;	CALLMONITOR 
9f10			;endif 
9f10			;	if DEBUG_FORTH_MALLOC_GUARD 
9f10			;		push af 
9f10			;		call ishlzero 
9f10			;;		ld a, l 
9f10			;;		add h 
9f10			;;		cp 0 
9f10			;		pop af 
9f10			;		 
9f10			;		call z,malloc_error 
9f10			;	endif 
9f10			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f10			; 
9f10			; 
9f10			;if DEBUG_FORTH_TOK 
9f10			;			DMARK "TKR" 
9f10			;	CALLMONITOR 
9f10			;endif 
9f10			; 
9f10			;	FORTH_RSP_NEXT 
9f10			; 
9f10			;	;inc hl	 ; go past current buffer pointer 
9f10			;	;inc hl 
9f10			;	;inc hl   ; and past if loop flag 
9f10			;		; TODO Need to set flag  
9f10			; 
9f10			;	 
9f10			;	 
9f10			;	ex de,hl	; malloc is dest 
9f10			;	ld hl, (os_tok_len) 
9f10			;;	pop bc 
9f10			;	ld c, l                
9f10			;	ld b,0 
9f10			;	ld hl, (os_tok_ptr) 
9f10			; 
9f10			;if DEBUG_FORTH_TOK 
9f10			;			DMARK "TKT" 
9f10			;	CALLMONITOR 
9f10			;endif 
9f10			; 
9f10			;	; do str cpy 
9f10			; 
9f10			;	ldir      ; copy byte in hl to de 
9f10			; 
9f10			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f10			; 
9f10			;if DEBUG_FORTH_TOK 
9f10			; 
9f10			;			DMARK "TKY" 
9f10			;	CALLMONITOR 
9f10			;endif 
9f10			;	;ld a,0 
9f10			;	;ld a,FORTH_END_BUFFER 
9f10			;	ex de, hl 
9f10			;	;dec hl			 ; go back over the space delim at the end of word 
9f10			;	;ld (hl),a 
9f10			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f10			;	ld a,FORTH_END_BUFFER 
9f10			;	ld (hl),a 
9f10			;	inc hl 
9f10			;	ld a,FORTH_END_BUFFER 
9f10			;	ld (hl),a 
9f10			; 
9f10			;	; init the malloc area data 
9f10			;	; set pc for in current area 
9f10			;	;ld hl, (os_tok_malloc) 
9f10			;	;inc hl 
9f10			;	;inc hl 
9f10			;	;inc hl 
9f10			;	;ex de,hl 
9f10			;	;ld hl, (os_tok_malloc) 
9f10			;	;ld (hl),e 
9f10			;	;inc hl 
9f10			;	;ld (hl),d 
9f10			; 
9f10			; 
9f10			;	ld hl,(os_tok_malloc) 
9f10			;if DEBUG_FORTH_PARSE_KEY 
9f10			;			DMARK "TKU" 
9f10			;	CALLMONITOR 
9f10			;endif 
9f10			; 
9f10			;	ret 
9f10			 
9f10			forthexec: 
9f10			 
9f10			; line exec: 
9f10			; forth parser 
9f10			 
9f10			; 
9f10			;       get current exec line on rsp 
9f10			 
9f10				FORTH_RSP_TOS 
9f10 cd d2 9a			call macro_forth_rsp_tos 
9f13				endm 
# End of macro FORTH_RSP_TOS
9f13			 
9f13			;       restore current pc - hl points to malloc of data 
9f13			 
9f13				;ld e, (hl) 
9f13				;inc hl 
9f13				;ld d, (hl) 
9f13				;ex de,hl 
9f13			 
9f13			 
9f13			exec1: 
9f13 22 86 e7			ld (os_tok_ptr), hl 
9f16			 
9f16				; copy our PC to working vars  
9f16 22 d0 eb			ld (cli_ptr), hl 
9f19 22 ce eb			ld (cli_origptr), hl 
9f1c			 
9f1c 7e				ld a,(hl) 
9f1d fe 7f			cp FORTH_END_BUFFER 
9f1f c8				ret z 
9f20			 
9f20				; skip any nulls 
9f20			 
9f20 fe 00			cp 0 
9f22 20 03			jr nz, .execword 
9f24 23				inc hl 
9f25 18 ec			jr exec1 
9f27			 
9f27			 
9f27			.execword: 
9f27			 
9f27			 
9f27			 
9f27			if DEBUG_FORTH_PARSE_KEY 
9f27						DMARK "KYQ" 
9f27				CALLMONITOR 
9f27			endif 
9f27			;       while at start of word: 
9f27			; get start of dict (in user area first) 
9f27			 
9f27 21 4e db		ld hl, baseram 
9f2a			;ld hl, sysdict 
9f2a 22 d2 eb		ld (cli_nextword),hl 
9f2d			;           match word at pc 
9f2d			;           exec word 
9f2d			;           or push to dsp 
9f2d			;           forward to next token 
9f2d			;           if line term pop rsp and exit 
9f2d			;        
9f2d			 
9f2d			if DEBUG_FORTH_PARSE_KEY 
9f2d						DMARK "KYq" 
9f2d				CALLMONITOR 
9f2d			endif 
9f2d			 
9f2d			; 
9f2d			; word comp 
9f2d			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9f2d			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9f2d			;    move to start of word  
9f2d			;    compare word to cli_token 
9f2d			 
9f2d			.execpnword:	; HL at start of a word in the dictionary to check 
9f2d			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9f2d			;	ld (cli_ptr), hl 
9f2d			 
9f2d 2a d2 eb			ld hl,(cli_nextword) 
9f30			 
9f30 cd d3 9f			call forth_tok_next 
9f33			; tok next start here 
9f33			;	; TODO skip compiled symbol for now 
9f33			;	inc hl 
9f33			; 
9f33			;	; save pointer to next word 
9f33			; 
9f33			;	; hl now points to the address of the next word pointer  
9f33			;	ld e, (hl) 
9f33			;	inc hl 
9f33			;	ld d, (hl) 
9f33			;	inc l 
9f33			; 
9f33			;	ex de,hl 
9f33			;if DEBUG_FORTH_PARSE_NEXTWORD 
9f33			;	push bc 
9f33			;	ld bc, (cli_nextword) 
9f33			;			DMARK "NXW" 
9f33			;	CALLMONITOR 
9f33			;	pop bc 
9f33			;endif 
9f33			; tok next end here 
9f33 22 d2 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
9f36 eb				ex de, hl 
9f37			 
9f37			 
9f37				; save the pointer of the current token - 1 to check against 
9f37				 
9f37 22 d6 eb			ld (cli_token), hl   
9f3a				; TODO maybe remove below save if no debug 
9f3a				; save token string ptr for any debug later 
9f3a 23				inc hl  
9f3b 22 d8 eb			ld (cli_origtoken), hl 
9f3e 2b				dec hl 
9f3f				; save pointer to the start of the next dictionay word 
9f3f 7e				ld a,(hl)   ; get string length 
9f40 47				ld b,a 
9f41			.execpnwordinc:  
9f41 23				inc hl 
9f42 10 fd			djnz .execpnwordinc 
9f44 22 d4 eb			ld (cli_execword), hl      ; save start of this words code 
9f47			 
9f47				; now check the word token against the string being parsed 
9f47			 
9f47 2a d6 eb			ld hl,(cli_token) 
9f4a 23				inc hl     ; skip string length (use zero term instead to end) 
9f4b 22 d6 eb			ld (cli_token), hl 
9f4e			 
9f4e			if DEBUG_FORTH_PARSE_KEY 
9f4e						DMARK "KY2" 
9f4e			endif 
9f4e			if DEBUG_FORTH_PARSE_EXEC 
9f4e				; see if disabled 
9f4e			 
9f4e				ld a, (os_view_disable) 
9f4e				cp '*' 
9f4e				jr z, .skip 
9f4e			 
9f4e				push hl 
9f4e				push hl 
9f4e				call clear_display 
9f4e				ld de, .compword 
9f4e				ld a, display_row_1 
9f4e				call str_at_display 
9f4e				pop de 
9f4e				ld a, display_row_2 
9f4e				call str_at_display 
9f4e				ld hl,(cli_ptr) 
9f4e				ld a,(hl) 
9f4e			        ld hl, os_word_scratch 
9f4e				ld (hl),a 
9f4e				ld a,0 
9f4e				inc hl 
9f4e				ld (hl),a 	 
9f4e				ld de, os_word_scratch 
9f4e				ld a, display_row_2+10 
9f4e				call str_at_display 
9f4e				call update_display 
9f4e				ld a, 100 
9f4e				call aDelayInMS 
9f4e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f4e				call delay250ms 
9f4e				endif 
9f4e				pop hl 
9f4e			.skip:  
9f4e			endif	 
9f4e			.execpnchar:    ; compare char between token and string to parse 
9f4e			 
9f4e			if DEBUG_FORTH_PARSE_KEY 
9f4e						DMARK "Ky3" 
9f4e			endif 
9f4e			if DEBUG_FORTH_PARSE_EXEC 
9f4e				; see if disabled 
9f4e			 
9f4e				ld a, (os_view_disable) 
9f4e				cp '*' 
9f4e				jr z, .skip2 
9f4e			 
9f4e			;	call clear_display 
9f4e			ld hl,(cli_token) 
9f4e			ld a,(hl) 
9f4e			ld (os_word_scratch),a 
9f4e				ld hl,(cli_ptr) 
9f4e			ld a,(hl) 
9f4e				ld (os_word_scratch+1),a 
9f4e				ld a,0 
9f4e				ld (os_word_scratch+2),a 
9f4e				ld de,os_word_scratch 
9f4e				ld a,display_row_4 
9f4e				call str_at_display 
9f4e				call update_display 
9f4e			.skip2:  
9f4e			endif 
9f4e 2a d6 eb			ld hl,(cli_token) 
9f51 7e				ld a, (hl)	 ; char in word token 
9f52 23				inc hl 		; move to next char 
9f53 22 d6 eb			ld (cli_token), hl ; and save it 
9f56 47				ld b,a 
9f57			 
9f57 2a d0 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
9f5a 7e				ld a,(hl) 
9f5b 23				inc hl 
9f5c 22 d0 eb			ld (cli_ptr), hl		; move to next char 
9f5f cd f7 90			call toUpper 		; make sure the input string matches case 
9f62			 
9f62			if DEBUG_FORTH_PARSE 
9f62			endif 
9f62			 
9f62				; input stream end of token is a space so get rid of it 
9f62			 
9f62			;	cp ' ' 
9f62			;	jr nz, .pnskipspace 
9f62			; 
9f62			;	ld a, 0		; make same term as word token term 
9f62			; 
9f62			;.pnskipspace: 
9f62			 
9f62			if DEBUG_FORTH_PARSE_KEY 
9f62						DMARK "KY7" 
9f62			endif 
9f62 b8				cp b 
9f63 c2 79 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9f66				 
9f66			;    if same 
9f66			;       scan for string terms 0 for token and 32 for input 
9f66			 
9f66				 
9f66			if DEBUG_FORTH_PARSE_KEY 
9f66						DMARK "KY8" 
9f66			endif 
9f66			 
9f66 80				add b			 
9f67 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9f69							; TODO need to make sure last word in zero term string is accounted for 
9f69 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9f6b			 
9f6b			 
9f6b				; at end of both strings so both are exact match 
9f6b			 
9f6b			;       skip ptr for next word 
9f6b			 
9f6b 2a d0 eb			ld hl,(cli_ptr) 	; at input string term 
9f6e 23				inc hl			 ; at next char 
9f6f 22 d0 eb			ld (cli_ptr), hl     ; save for next round of the parser 
9f72 22 ce eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9f75				 
9f75				 
9f75			if DEBUG_FORTH_PARSE_KEY 
9f75						DMARK "KY3" 
9f75			endif 
9f75			 
9f75			 
9f75			 
9f75			;       exec code block 
9f75			if DEBUG_FORTH_JP 
9f75				call clear_display 
9f75				call update_display 
9f75				call delay1s 
9f75				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f75				ld a,h 
9f75				ld hl, os_word_scratch 
9f75				call hexout 
9f75				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f75				ld a,l 
9f75				ld hl, os_word_scratch+2 
9f75				call hexout 
9f75				ld hl, os_word_scratch+4 
9f75				ld a,0 
9f75				ld (hl),a 
9f75				ld de,os_word_scratch 
9f75				call str_at_display 
9f75					ld a, display_row_2 
9f75					call str_at_display 
9f75				ld de, (cli_origtoken) 
9f75				ld a, display_row_1+10 
9f75					call str_at_display 
9f75			 
9f75				ld a,display_row_1 
9f75				ld de, .foundword 
9f75				ld a, display_row_3 
9f75				call str_at_display 
9f75				call update_display 
9f75				call delay1s 
9f75				call delay1s 
9f75				call delay1s 
9f75			endif 
9f75			 
9f75			if DEBUG_FORTH_PARSE_KEY 
9f75						DMARK "KYj" 
9f75			endif 
9f75				; TODO save the word pointer in this exec 
9f75			 
9f75 2a d4 eb			ld hl,(cli_execword) 
9f78 e9				jp (hl) 
9f79			 
9f79			 
9f79			;    if not same 
9f79			;	scan for zero term 
9f79			;	get ptr for next word 
9f79			;	goto word comp 
9f79			 
9f79			.execpnskipword:	; get pointer to next word 
9f79 2a d2 eb			ld hl,(cli_nextword) 
9f7c			 
9f7c 7e				ld a,(hl) 
9f7d fe 00			cp WORD_SYS_END 
9f7f			;	cp 0 
9f7f 28 09			jr z, .execendofdict			 ; at end of words 
9f81			 
9f81			if DEBUG_FORTH_PARSE_KEY 
9f81						DMARK "KY4" 
9f81			endif 
9f81			if DEBUG_FORTH_PARSE_EXEC 
9f81			 
9f81				; see if disabled 
9f81			 
9f81				ld a, (os_view_disable) 
9f81				cp '*' 
9f81				jr z, .noskip 
9f81			 
9f81			 
9f81				ld de, .nowordfound 
9f81				ld a, display_row_3 
9f81				call str_at_display 
9f81				call update_display 
9f81				ld a, 100 
9f81				call aDelayInMS 
9f81				 
9f81				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f81					call delay250ms 
9f81				endif 
9f81			.noskip:  
9f81			 
9f81			endif	 
9f81			 
9f81 2a ce eb			ld hl,(cli_origptr) 
9f84 22 d0 eb			ld (cli_ptr),hl 
9f87			 
9f87			if DEBUG_FORTH_PARSE_KEY 
9f87						DMARK "KY5" 
9f87			endif 
9f87 c3 2d 9f			jp .execpnword			; else go to next word 
9f8a			 
9f8a			.execendofdict:  
9f8a			 
9f8a			if DEBUG_FORTH_PARSE_KEY 
9f8a						DMARK "KYe" 
9f8a			endif 
9f8a			if DEBUG_FORTH_PARSE_EXEC 
9f8a				; see if disabled 
9f8a			 
9f8a				ld a, (os_view_disable) 
9f8a				cp '*' 
9f8a				jr z, .ispskip 
9f8a			 
9f8a				call clear_display 
9f8a				call update_display 
9f8a				call delay1s 
9f8a				ld de, (cli_origptr) 
9f8a				ld a, display_row_1 
9f8a				call str_at_display 
9f8a				 
9f8a				ld de, .enddict 
9f8a				ld a, display_row_3 
9f8a				call str_at_display 
9f8a				call update_display 
9f8a				ld a, 100 
9f8a				call aDelayInMS 
9f8a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f8a				call delay1s 
9f8a				call delay1s 
9f8a				call delay1s 
9f8a				endif 
9f8a			.ispskip:  
9f8a				 
9f8a			endif	 
9f8a			 
9f8a			 
9f8a			 
9f8a				; if the word is not a keyword then must be a literal so push it to stack 
9f8a			 
9f8a			; push token to stack to end of word 
9f8a			 
9f8a				STACKFRAME ON $1efe $2f9f 
9f8a				if DEBUG_STACK_IMB 
9f8a					if ON 
9f8a						exx 
9f8a						ld de, $1efe 
9f8a						ld a, d 
9f8a						ld hl, curframe 
9f8a						call hexout 
9f8a						ld a, e 
9f8a						ld hl, curframe+2 
9f8a						call hexout 
9f8a						ld hl, $1efe 
9f8a						push hl 
9f8a						ld hl, $2f9f 
9f8a						push hl 
9f8a						exx 
9f8a					endif 
9f8a				endif 
9f8a			endm 
# End of macro STACKFRAME
9f8a			 
9f8a 2a 86 e7		ld hl,(os_tok_ptr) 
9f8d cd 7d 9c		call forth_apush 
9f90			 
9f90				STACKFRAMECHK ON $1efe $2f9f 
9f90				if DEBUG_STACK_IMB 
9f90					if ON 
9f90						exx 
9f90						ld hl, $2f9f 
9f90						pop de   ; $2f9f 
9f90						call cmp16 
9f90						jr nz, .spnosame 
9f90						ld hl, $1efe 
9f90						pop de   ; $1efe 
9f90						call cmp16 
9f90						jr z, .spfrsame 
9f90						.spnosame: call showsperror 
9f90						.spfrsame: nop 
9f90						exx 
9f90					endif 
9f90				endif 
9f90			endm 
# End of macro STACKFRAMECHK
9f90			 
9f90			execnext: 
9f90			 
9f90			if DEBUG_FORTH_PARSE_KEY 
9f90						DMARK "KY>" 
9f90			endif 
9f90			; move past token to next word 
9f90			 
9f90 2a 86 e7		ld hl, (os_tok_ptr) 
9f93 3e 00		ld a, 0 
9f95 01 ff 00		ld bc, 255     ; input buffer size 
9f98 ed b1		cpir 
9f9a			 
9f9a			if DEBUG_FORTH_PARSE_KEY 
9f9a						DMARK "KY!" 
9f9a				CALLMONITOR 
9f9a			endif	 
9f9a			; TODO this might place hl on the null, so will need to forward on??? 
9f9a			;inc hl   ; see if this gets onto the next item 
9f9a			 
9f9a			 
9f9a			; TODO pass a pointer to the buffer to push 
9f9a			; TODO call function to push 
9f9a			 
9f9a			; look for end of input 
9f9a			 
9f9a			;inc hl 
9f9a			;ld a,(hl) 
9f9a			;cp FORTH_END_BUFFER 
9f9a			;ret z 
9f9a			 
9f9a			 
9f9a c3 13 9f		jp exec1 
9f9d			 
9f9d			 
9f9d			 
9f9d			 
9f9d			 
9f9d			 
9f9d			 
9f9d			 
9f9d			 
9f9d			findnexttok: 
9f9d			 
9f9d				; hl is pointer to move 
9f9d				; de is the token to locate 
9f9d			 
9f9d					if DEBUG_FORTH 
9f9d						DMARK "NTK" 
9f9d						CALLMONITOR 
9f9d					endif 
9f9d d5				push de 
9f9e			 
9f9e			.fnt1:	 
9f9e				; find first char of token to locate 
9f9e			 
9f9e 1a				ld a, (de) 
9f9f 4f				ld c,a 
9fa0 7e				ld a,(hl) 
9fa1 cd f7 90			call toUpper 
9fa4					if DEBUG_FORTH 
9fa4						DMARK "NT1" 
9fa4						CALLMONITOR 
9fa4					endif 
9fa4 b9				cp c 
9fa5			 
9fa5 28 03			jr z, .fnt2cmpmorefirst	 
9fa7			 
9fa7				; first char not found move to next char 
9fa7			 
9fa7 23				inc hl 
9fa8 18 f4			jr .fnt1 
9faa			 
9faa			.fnt2cmpmorefirst:	 
9faa				; first char of token found.  
9faa			 
9faa e5				push hl     ; save start of token just in case it is the right one 
9fab d9				exx 
9fac e1				pop hl        ; save it to hl' 
9fad d9				exx 
9fae			 
9fae			 
9fae			.fnt2cmpmore:	 
9fae				; compare the rest 
9fae				 
9fae 23				inc hl 
9faf 13				inc de 
9fb0				 
9fb0 1a				ld a, (de) 
9fb1 4f				ld c,a 
9fb2 7e				ld a,(hl) 
9fb3 cd f7 90			call toUpper 
9fb6			 
9fb6					if DEBUG_FORTH 
9fb6						DMARK "NT2" 
9fb6						CALLMONITOR 
9fb6					endif 
9fb6				; c has the token to find char 
9fb6				; a has the mem to scan char 
9fb6			 
9fb6 b9				cp c 
9fb7 28 04			jr z,.fntmatch1 
9fb9			 
9fb9				; they are not the same 
9fb9			 
9fb9					if DEBUG_FORTH 
9fb9						DMARK "NT3" 
9fb9						CALLMONITOR 
9fb9					endif 
9fb9 d1				pop de	; reset de token to look for 
9fba d5				push de 
9fbb 18 e1			jr .fnt1 
9fbd				 
9fbd			.fntmatch1: 
9fbd			 
9fbd				; is the same char a null which means we might have a full hit? 
9fbd					if DEBUG_FORTH 
9fbd						DMARK "NT4" 
9fbd						CALLMONITOR 
9fbd					endif 
9fbd			 
9fbd fe 00			cp 0 
9fbf 28 0b			jr z, .fntmatchyes 
9fc1			 
9fc1				; are we at the end of the token to find? 
9fc1			 
9fc1					if DEBUG_FORTH 
9fc1						DMARK "NT5" 
9fc1						CALLMONITOR 
9fc1					endif 
9fc1 3e 00			ld a, 0 
9fc3 b9				cp c 
9fc4			 
9fc4 c2 ae 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9fc7			 
9fc7					if DEBUG_FORTH 
9fc7						DMARK "NT6" 
9fc7						CALLMONITOR 
9fc7					endif 
9fc7				; token to find is exhusted but no match to stream 
9fc7			 
9fc7				; restore tok pointer and continue on 
9fc7 d1				pop de 
9fc8 d5				push de 
9fc9 c3 9e 9f			jp .fnt1 
9fcc			 
9fcc			 
9fcc			.fntmatchyes: 
9fcc			 
9fcc				; hl now contains the end of the found token 
9fcc			 
9fcc				; get rid of saved token pointer to find 
9fcc			 
9fcc d1				pop de 
9fcd			 
9fcd					if DEBUG_FORTH 
9fcd						DMARK "NT9" 
9fcd						CALLMONITOR 
9fcd					endif 
9fcd			 
9fcd				; hl will be on the null term so forward on 
9fcd			 
9fcd				; get back the saved start of the token 
9fcd			 
9fcd d9				exx 
9fce e5				push hl     ; save start of token just in case it is the right one 
9fcf d9				exx 
9fd0 e1				pop hl        ; save it to hl 
9fd1			 
9fd1 c9				ret 
9fd2			 
9fd2			 
9fd2			; LIST needs to find a specific token   
9fd2			; FORGET needs to find a spefici token 
9fd2			 
9fd2			; SAVE needs to find all tokens by flag 
9fd2			; WORDS just needs to scan through all  by flag 
9fd2			; UWORDS needs to scan through all by flag 
9fd2			 
9fd2			 
9fd2			; given hl as pointer to start of dict look up string 
9fd2			; return hl as pointer to start of word block 
9fd2			; or 0 if not found 
9fd2			 
9fd2			forth_find_tok: 
9fd2 c9				ret 
9fd3			 
9fd3			; given hl as pointer to dict structure 
9fd3			; move to the next dict block structure 
9fd3			 
9fd3			forth_tok_next: 
9fd3				; hl now points to the address of the next word pointer  
9fd3				; TODO skip compiled symbol for now 
9fd3			;	push de 
9fd3 23				inc hl 
9fd4 5e				ld e, (hl) 
9fd5 23				inc hl 
9fd6 56				ld d, (hl) 
9fd7 23				inc hl 
9fd8			 
9fd8 eb				ex de,hl 
9fd9			if DEBUG_FORTH_PARSE_NEXTWORD 
9fd9				push bc 
9fd9				ld bc, (cli_nextword) 
9fd9						DMARK "NXW" 
9fd9				CALLMONITOR 
9fd9				pop bc 
9fd9			endif 
9fd9			;	pop de	 
9fd9 c9				ret 
9fda			 
9fda			 
9fda			 
9fda			; eof 
# End of file forth_parserv5.asm
9fda				include "forth_wordsv4.asm" 
9fda			 
9fda			; the core word dictionary v4 
9fda			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9fda			 
9fda			; this is a linked list for each of the system words used 
9fda			; user defined words will follow the same format but will be in ram 
9fda			 
9fda			 
9fda			; 
9fda			; 
9fda			; define linked list: 
9fda			; 
9fda			; 1. compiled byte op code 
9fda			; 2. len of text word 
9fda			; 3. text word 
9fda			; 4. ptr to next dictionary word 
9fda			; 5. asm, calls etc for the word 
9fda			; 
9fda			;  if 1 == 0 then last word in dict  
9fda			;   
9fda			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9fda			;  
9fda			;  
9fda			; create basic standard set of words 
9fda			; 
9fda			;  
9fda			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9fda			; 2DUP 2DROP 2SWAP  
9fda			; @ C@ - get byte  
9fda			; ! C! - store byte 
9fda			; 0< true if less than zero 
9fda			; 0= true if zero 
9fda			; < >  
9fda			; = true if same 
9fda			; variables 
9fda			 
9fda			 
9fda			; Hardware specific words I may need 
9fda			; 
9fda			; IN OUT  
9fda			; calls to key util functions 
9fda			; calls to hardward abstraction stuff 
9fda			; easy control of frame buffers and lcd i/o 
9fda			; keyboard  
9fda			 
9fda			 
9fda			;DICT: macro 
9fda			; op_code, len, word, next 
9fda			;    word: 
9fda			;    db op_code 
9fda			;    ds word zero term 
9fda			;    dw next 
9fda			;    endm 
9fda			 
9fda			 
9fda			 
9fda			 
9fda			; op code 1 is a flag for user define words which are to be handled differently 
9fda			 
9fda			 
9fda			; 
9fda			; 
9fda			;    TODO on entry to a word this should be the expected environment 
9fda			;    hl - tos value if number then held, if string this is the ptr 
9fda			;    de -  
9fda			 
9fda			 
9fda			; opcode ranges 
9fda			; 0 - end of word dict 
9fda			; 255 - user define words 
9fda			 
9fda			sysdict: 
9fda			include "forth_opcodes.asm" 
9fda			; op codes for forth keywords 
9fda			; free to use code 0  
9fda				OPCODE_HEAP: equ  1 
9fda				OPCODE_EXEC: equ 2 
9fda				OPCODE_DUP: equ 3 
9fda				OPCODE_SWAP: equ 4 
9fda				OPCODE_COLN: equ 5 
9fda				OPCODE_SCOLN: equ 6 
9fda				OPCODE_DROP: equ 7 
9fda				OPCODE_DUP2: equ 8 
9fda				OPCODE_DROP2: equ 9 
9fda				OPCODE_SWAP2: equ 10 
9fda				OPCODE_AT: equ 11 
9fda				OPCODE_CAT: equ 12 
9fda				OPCODE_BANG: equ 13 
9fda				OPCODE_CBANG: equ 14 
9fda				OPCODE_SCALL: equ 15 
9fda				OPCODE_DEPTH: equ 16 
9fda				OPCODE_OVER: equ 17 
9fda				OPCODE_PAUSE: equ 18 
9fda				OPCODE_PAUSES: equ 19 
9fda				OPCODE_ROT: equ 20 
9fda			;free to reuse	OPCODE_WORDS: equ 21 
9fda			        OPCODE_NOT: equ 21 
9fda				OPCODE_UWORDS: equ 22 
9fda				OPCODE_BP: equ 23 
9fda				OPCODE_MONITOR: equ 24  
9fda				OPCODE_MALLOC: equ 25 
9fda				OPCODE_FREE: equ 26 
9fda				OPCODE_LIST: equ 27 
9fda				OPCODE_FORGET: equ 28 
9fda				OPCODE_NOP: equ 29 
9fda				OPCODE_COMO: equ 30 
9fda				OPCODE_COMC: equ 31 
9fda			;free to reuse	OPCODE_ENDCORE: equ 32 
9fda				OPCODE_AFTERSOUND: equ 33 
9fda				OPCODE_GP2: equ 34 
9fda				OPCODE_GP3: equ 35 
9fda				OPCODE_GP4: equ 36 
9fda				OPCODE_SIN: equ 37 
9fda				OPCODE_SOUT: equ 38 
9fda				OPCODE_SPIO: equ 39 
9fda				OPCODE_SPICEH: equ 40 
9fda				OPCODE_SPIOb: equ 41 
9fda				OPCODE_SPII: equ 42 
9fda				OPCODE_SESEL: equ 43 
9fda				OPCODE_CARTDEV: equ 44 
9fda			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9fda				OPCODE_FB: equ 46 
9fda				OPCODE_EMIT: equ 47 
9fda				OPCODE_DOTH: equ 48 
9fda				OPCODE_DOTF: equ 49 
9fda				OPCODE_DOT: equ 50 
9fda				OPCODE_CLS: equ 51 
9fda				OPCODE_DRAW: equ 52 
9fda				OPCODE_DUMP: equ 53 
9fda				OPCODE_CDUMP: equ 54 
9fda				OPCODE_DAT: equ 55 
9fda				OPCODE_HOME: equ 56 
9fda				OPCODE_SPACE: equ 57 
9fda				OPCODE_SPACES: equ 58 
9fda				OPCODE_SCROLL: equ 59 
9fda				OPCODE_ATQ: equ 60 
9fda				OPCODE_AUTODSP: equ 61 
9fda				OPCODE_MENU: equ 62 
9fda			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9fda				OPCODE_THEN: equ 64 
9fda				OPCODE_ELSE: equ 65 
9fda				OPCODE_DO: equ 66 
9fda				OPCODE_LOOP: equ 67 
9fda				OPCODE_I: equ 68 
9fda				OPCODE_DLOOP: equ 69  
9fda				OPCODE_REPEAT: equ 70  
9fda				OPCODE_UNTIL: equ 71 
9fda				OPCODE_ENDFLOW: equ 72 
9fda				OPCODE_WAITK: equ 73 
9fda				OPCODE_ACCEPT: equ 74 
9fda				OPCODE_EDIT: equ 75 
9fda			;free to reuse	OPCODE_ENDKEY: equ 76 
9fda				OPCODE_LZERO: equ 77 
9fda				OPCODE_TZERO: equ 78 
9fda				OPCODE_LESS: equ 79 
9fda				OPCODE_GT: equ 80 
9fda				OPCODE_EQUAL: equ 81  
9fda			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9fda				OPCODE_NEG: equ 83 
9fda				OPCODE_DIV: equ 84 
9fda				OPCODE_MUL: equ 85 
9fda				OPCODE_MIN: equ 86 
9fda				OPCODE_MAX: equ 87 
9fda				OPCODE_RND16: equ 88 
9fda				OPCODE_RND8: equ 89 
9fda				OPCODE_RND: equ 90 
9fda			;free to reuse	OPCODE_ENDMATHS: equ 91  
9fda				OPCODE_BYNAME: equ 92 
9fda				OPCODE_DIR: equ 93 
9fda				OPCODE_SAVE: equ 94 
9fda				OPCODE_LOAD: equ 95 
9fda				OPCODE_BSAVE: equ 96 
9fda				OPCODE_BLOAD: equ 97 
9fda				OPCODE_SEO: equ 98  
9fda				OPCODE_SEI: equ 99 
9fda				OPCODE_SFREE: equ 100 
9fda				OPCODE_SIZE: equ 101 
9fda				OPCODE_CREATE: equ 102 
9fda				OPCODE_APPEND: equ 103 
9fda				OPCODE_SDEL: equ 104 
9fda				OPCODE_OPEN: equ 105 
9fda				OPCODE_READ: equ 106 
9fda				OPCODE_EOF: equ 106 
9fda				OPCODE_FORMAT: equ 107 
9fda				OPCODE_LABEL: equ 108 
9fda				OPCODE_LABELS: equ 109 
9fda			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9fda				OPCODE_UPPER: equ 111 
9fda				OPCODE_LOWER: equ 112 
9fda				OPCODE_SUBSTR: equ 113 
9fda				OPCODE_LEFT: equ 114 
9fda				OPCODE_RIGHT: equ 115 
9fda				OPCODE_STR2NUM: equ 116 
9fda				OPCODE_NUM2STR: equ 117 
9fda				OPCODE_CONCAT: equ 118 
9fda				OPCODE_FIND: equ 119 
9fda				OPCODE_LEN: equ 120 
9fda				OPCODE_CHAR: equ 121 
9fda			; free to reuse	OPCODE_STRLEN: equ 122 
9fda			; free to reuse	OPCODE_ENDSTR: equ 123 
9fda				OPCODE_V0S: equ 124 
9fda				OPCODE_V0Q: equ 125 
9fda				OPCODE_V1S: equ 126 
9fda				OPCODE_V1Q: equ 127 
9fda				OPCODE_V2S: equ 128 
9fda				OPCODE_V2Q: equ 129 
9fda				OPCODE_V3S: equ 130 
9fda				OPCODE_V3Q: equ 131 
9fda			;free to reuse	OPCODE_END: equ 132 
9fda				OPCODE_ZDUP: equ 133 
9fda			 
9fda			; eof 
# End of file forth_opcodes.asm
9fda			 
9fda			include "forth_words_core.asm" 
9fda			 
9fda			; | ## Core Words 
9fda			 
9fda			;if MALLOC_4 
9fda			 
9fda			.HEAP: 
9fda				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9fda 15				db WORD_SYS_CORE+OPCODE_HEAP             
9fdb 19 a0			dw .EXEC            
9fdd 05				db 4 + 1 
9fde .. 00			db "HEAP",0              
9fe3				endm 
# End of macro CWHEAD
9fe3			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9fe3			; | | u1 - Current number of bytes in the heap 
9fe3			; | | u2 - Remaining bytes left on the heap 
9fe3			; | |  
9fe3			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9fe3			 
9fe3			 
9fe3					if DEBUG_FORTH_WORDS_KEY 
9fe3						DMARK "HEP" 
9fe3 f5				push af  
9fe4 3a f8 9f			ld a, (.dmark)  
9fe7 32 b7 ee			ld (debug_mark),a  
9fea 3a f9 9f			ld a, (.dmark+1)  
9fed 32 b8 ee			ld (debug_mark+1),a  
9ff0 3a fa 9f			ld a, (.dmark+2)  
9ff3 32 b9 ee			ld (debug_mark+2),a  
9ff6 18 03			jr .pastdmark  
9ff8 ..			.dmark: db "HEP"  
9ffb f1			.pastdmark: pop af  
9ffc			endm  
# End of macro DMARK
9ffc						CALLMONITOR 
9ffc cd a3 94			call break_point_state  
9fff				endm  
# End of macro CALLMONITOR
9fff					endif 
9fff 2a 58 db				ld hl, (free_list )      
a002 11 5d db				ld de, heap_start 
a005			 
a005 ed 52				sbc hl, de  
a007			 
a007 cd 14 9b				call forth_push_numhl 
a00a			 
a00a			 
a00a ed 5b 58 db			ld de, (free_list )      
a00e 21 6b e4				ld hl, heap_end 
a011			 
a011 ed 52				sbc hl, de 
a013			 
a013 cd 14 9b				call forth_push_numhl 
a016					 
a016			 
a016					 
a016			 
a016			 
a016			 
a016					NEXTW 
a016 c3 82 9e			jp macro_next 
a019				endm 
# End of macro NEXTW
a019			;endif 
a019			 
a019			.EXEC: 
a019			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a019			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a019			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a019			;; > > 
a019			;; > >   
a019			;	STACKFRAME OFF $5efe $5f9f 
a019			; 
a019			;		if DEBUG_FORTH_WORDS_KEY 
a019			;			DMARK "EXE" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			; 
a019			;	FORTH_DSP_VALUEHL 
a019			; 
a019			;	FORTH_DSP_POP 
a019			; 
a019			;		if DEBUG_FORTH_WORDS 
a019			;			DMARK "EX1" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			;;	ld e,(hl) 
a019			;;	inc hl 
a019			;;	ld d,(hl) 
a019			;;	ex de,hl 
a019			; 
a019			;;		if DEBUG_FORTH_WORDS 
a019			;;			DMARK "EX2" 
a019			;;			CALLMONITOR 
a019			;;		endif 
a019			;	push hl 
a019			; 
a019			;	;ld a, 0 
a019			;	;ld a, FORTH_END_BUFFER 
a019			;	call strlenz 
a019			;	inc hl   ; include zero term to copy 
a019			;	inc hl   ; include term 
a019			;	inc hl   ; include term 
a019			;	ld b,0 
a019			;	ld c,l 
a019			;	pop hl 
a019			;	ld de, execscratch 
a019			;		if DEBUG_FORTH_WORDS 
a019			;			DMARK "EX3" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			;	ldir 
a019			; 
a019			; 
a019			;	ld hl, execscratch 
a019			; 
a019			;		if DEBUG_FORTH_WORDS 
a019			;			DMARK "EXe" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			; 
a019			;	call forthparse 
a019			;	call forthexec 
a019			;;	call forthexec_cleanup 
a019			;;	call forthparse 
a019			;;	call forthexec 
a019			; 
a019			;	STACKFRAMECHK OFF $5efe $5f9f 
a019			; 
a019			;	; an immediate word so no need to process any more words 
a019			;	ret 
a019			;	NEXTW 
a019			 
a019			; dead code - old version  
a019			;	FORTH_RSP_NEXT 
a019			 
a019			;  
a019			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a019			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a019			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a019			;	push hl 
a019			;	push de 
a019			;	push bc 
a019			; 
a019			; 
a019			;		if DEBUG_FORTH_WORDS_KEY 
a019			;			DMARK "EXR" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			; 
a019			; 
a019			; 
a019			;	;v5 FORTH_DSP_VALUE 
a019			;	FORTH_DSP_VALUEHL 
a019			; 
a019			;	; TODO do string type checks 
a019			; 
a019			;;v5	inc hl   ; skip type 
a019			; 
a019			;	push hl  ; source code  
a019			;		if DEBUG_FORTH_WORDS 
a019			;			DMARK "EX1" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			;	ld a, 0 
a019			;	call strlent 
a019			; 
a019			;	inc hl 
a019			;	inc hl 
a019			;	inc hl 
a019			;	inc hl 
a019			; 
a019			;	push hl    ; size 
a019			; 
a019			;		if DEBUG_FORTH_WORDS 
a019			;			DMARK "EX2" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			;	call malloc 
a019			; 
a019			;	ex de, hl    ; de now contains malloc area 
a019			;	pop bc   	; get byte count 
a019			;	pop hl      ; get string to copy 
a019			; 
a019			;	push de     ; save malloc for free later 
a019			; 
a019			;		if DEBUG_FORTH_WORDS 
a019			;			DMARK "EX3" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			;	ldir       ; duplicate string 
a019			; 
a019			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a019			;	 
a019			;	; TODO fix the parse would be better than this...  
a019			;	ex de, hl 
a019			;	dec hl 
a019			;	ld a, 0 
a019			;	ld (hl), a 
a019			;	dec hl 
a019			;	ld a, ' ' 
a019			;	ld (hl), a 
a019			;	dec hl 
a019			;	ld (hl), a 
a019			; 
a019			;	dec hl 
a019			;	ld (hl), a 
a019			; 
a019			; 
a019			;	FORTH_DSP_POP  
a019			; 
a019			;	pop hl     
a019			;	push hl    ; save malloc area 
a019			; 
a019			;		if DEBUG_FORTH_WORDS 
a019			;			DMARK "EX4" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			; 
a019			;	call forthparse 
a019			;	call forthexec 
a019			;	 
a019			;	pop hl 
a019			;	if DEBUG_FORTH_WORDS 
a019			;		DMARK "EX5" 
a019			;		CALLMONITOR 
a019			;	endif 
a019			; 
a019			;	if FORTH_ENABLE_FREE 
a019			;	call free 
a019			;	endif 
a019			; 
a019			;	if DEBUG_FORTH_WORDS 
a019			;		DMARK "EX6" 
a019			;		CALLMONITOR 
a019			;	endif 
a019			; 
a019			;	pop bc 
a019			;	pop de 
a019			;	pop hl 
a019			;;	FORTH_RSP_POP	  
a019			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a019			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a019			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a019			; 
a019			;	if DEBUG_FORTH_WORDS 
a019			;		DMARK "EX7" 
a019			;		CALLMONITOR 
a019			;	endif 
a019			;	NEXTW 
a019			 
a019			;.STKEXEC: 
a019			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a019			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a019			; 
a019			; 
a019			;		if DEBUG_FORTH_WORDS_KEY 
a019			;			DMARK "STX" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			; 
a019			;	FORTH_DSP_VALUEHL 
a019			; 
a019			;	ld (store_tmp1), hl    ; count 
a019			; 
a019			;	FORTH_DSP_POP 
a019			;.stkexec1: 
a019			;	ld hl, (store_tmp1)   ; count 
a019			;	ld a, 0 
a019			;	cp l 
a019			;	ret z 
a019			; 
a019			;	dec hl 
a019			;	ld (store_tmp1), hl    ; count 
a019			;	 
a019			;	FORTH_DSP_VALUEHL 
a019			;	push hl 
a019			;	 
a019			;		if DEBUG_FORTH_WORDS 
a019			;			DMARK "EXp" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			;	FORTH_DSP_POP 
a019			; 
a019			;	call strlenz 
a019			;	inc hl   ; include zero term to copy 
a019			;	inc hl   ; include zero term to copy 
a019			;	inc hl   ; include zero term to copy 
a019			;	ld b,0 
a019			;	ld c,l 
a019			;	pop hl 
a019			;	ld de, execscratch 
a019			;		if DEBUG_FORTH_WORDS 
a019			;			DMARK "EX3" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			;	ldir 
a019			; 
a019			; 
a019			;	ld hl, execscratch 
a019			; 
a019			;		if DEBUG_FORTH_WORDS 
a019			;			DMARK "EXP" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			; 
a019			;	call forthparse 
a019			;	ld hl, execscratch 
a019			;		if DEBUG_FORTH_WORDS 
a019			;			DMARK "EXx" 
a019			;			CALLMONITOR 
a019			;		endif 
a019			;	call forthexec 
a019			; 
a019			;	jp .stkexec1 
a019			; 
a019			;	ret 
a019			 
a019			 
a019			.DUP: 
a019				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a019 17				db WORD_SYS_CORE+OPCODE_DUP             
a01a 8f a0			dw .ZDUP            
a01c 04				db 3 + 1 
a01d .. 00			db "DUP",0              
a021				endm 
# End of macro CWHEAD
a021			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a021			 
a021					if DEBUG_FORTH_WORDS_KEY 
a021						DMARK "DUP" 
a021 f5				push af  
a022 3a 36 a0			ld a, (.dmark)  
a025 32 b7 ee			ld (debug_mark),a  
a028 3a 37 a0			ld a, (.dmark+1)  
a02b 32 b8 ee			ld (debug_mark+1),a  
a02e 3a 38 a0			ld a, (.dmark+2)  
a031 32 b9 ee			ld (debug_mark+2),a  
a034 18 03			jr .pastdmark  
a036 ..			.dmark: db "DUP"  
a039 f1			.pastdmark: pop af  
a03a			endm  
# End of macro DMARK
a03a						CALLMONITOR 
a03a cd a3 94			call break_point_state  
a03d				endm  
# End of macro CALLMONITOR
a03d					endif 
a03d			 
a03d					FORTH_DSP 
a03d cd d1 9c			call macro_forth_dsp 
a040				endm 
# End of macro FORTH_DSP
a040			 
a040 7e					ld a, (HL) 
a041 fe 01				cp DS_TYPE_STR 
a043 20 25				jr nz, .dupinum 
a045			 
a045					; push another string 
a045			 
a045					FORTH_DSP_VALUEHL     		 
a045 cd 0b 9d			call macro_dsp_valuehl 
a048				endm 
# End of macro FORTH_DSP_VALUEHL
a048			 
a048				if DEBUG_FORTH_WORDS 
a048					DMARK "DUs" 
a048 f5				push af  
a049 3a 5d a0			ld a, (.dmark)  
a04c 32 b7 ee			ld (debug_mark),a  
a04f 3a 5e a0			ld a, (.dmark+1)  
a052 32 b8 ee			ld (debug_mark+1),a  
a055 3a 5f a0			ld a, (.dmark+2)  
a058 32 b9 ee			ld (debug_mark+2),a  
a05b 18 03			jr .pastdmark  
a05d ..			.dmark: db "DUs"  
a060 f1			.pastdmark: pop af  
a061			endm  
# End of macro DMARK
a061					CALLMONITOR 
a061 cd a3 94			call break_point_state  
a064				endm  
# End of macro CALLMONITOR
a064				endif 
a064 cd 82 9b				call forth_push_str 
a067			 
a067					NEXTW 
a067 c3 82 9e			jp macro_next 
a06a				endm 
# End of macro NEXTW
a06a			 
a06a			 
a06a			.dupinum: 
a06a					 
a06a			 
a06a			 
a06a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a06a cd 0b 9d			call macro_dsp_valuehl 
a06d				endm 
# End of macro FORTH_DSP_VALUEHL
a06d			 
a06d				; TODO add floating point number detection 
a06d			 
a06d				if DEBUG_FORTH_WORDS 
a06d					DMARK "DUi" 
a06d f5				push af  
a06e 3a 82 a0			ld a, (.dmark)  
a071 32 b7 ee			ld (debug_mark),a  
a074 3a 83 a0			ld a, (.dmark+1)  
a077 32 b8 ee			ld (debug_mark+1),a  
a07a 3a 84 a0			ld a, (.dmark+2)  
a07d 32 b9 ee			ld (debug_mark+2),a  
a080 18 03			jr .pastdmark  
a082 ..			.dmark: db "DUi"  
a085 f1			.pastdmark: pop af  
a086			endm  
# End of macro DMARK
a086					CALLMONITOR 
a086 cd a3 94			call break_point_state  
a089				endm  
# End of macro CALLMONITOR
a089				endif 
a089			 
a089 cd 14 9b				call forth_push_numhl 
a08c					NEXTW 
a08c c3 82 9e			jp macro_next 
a08f				endm 
# End of macro NEXTW
a08f			.ZDUP: 
a08f				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a08f 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a090 c7 a0			dw .SWAP            
a092 05				db 4 + 1 
a093 .. 00			db "?DUP",0              
a098				endm 
# End of macro CWHEAD
a098			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a098			 
a098					if DEBUG_FORTH_WORDS_KEY 
a098						DMARK "qDU" 
a098 f5				push af  
a099 3a ad a0			ld a, (.dmark)  
a09c 32 b7 ee			ld (debug_mark),a  
a09f 3a ae a0			ld a, (.dmark+1)  
a0a2 32 b8 ee			ld (debug_mark+1),a  
a0a5 3a af a0			ld a, (.dmark+2)  
a0a8 32 b9 ee			ld (debug_mark+2),a  
a0ab 18 03			jr .pastdmark  
a0ad ..			.dmark: db "qDU"  
a0b0 f1			.pastdmark: pop af  
a0b1			endm  
# End of macro DMARK
a0b1						CALLMONITOR 
a0b1 cd a3 94			call break_point_state  
a0b4				endm  
# End of macro CALLMONITOR
a0b4					endif 
a0b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0b4 cd 0b 9d			call macro_dsp_valuehl 
a0b7				endm 
# End of macro FORTH_DSP_VALUEHL
a0b7			 
a0b7 e5					push hl 
a0b8			 
a0b8					; is it a zero? 
a0b8			 
a0b8 3e 00				ld a, 0 
a0ba 84					add h 
a0bb 85					add l 
a0bc			 
a0bc e1					pop hl 
a0bd			 
a0bd fe 00				cp 0 
a0bf 28 03				jr z, .dup2orig 
a0c1			 
a0c1			 
a0c1 cd 14 9b				call forth_push_numhl 
a0c4			 
a0c4			 
a0c4				; TODO add floating point number detection 
a0c4			 
a0c4			.dup2orig: 
a0c4			 
a0c4					NEXTW 
a0c4 c3 82 9e			jp macro_next 
a0c7				endm 
# End of macro NEXTW
a0c7			.SWAP: 
a0c7				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a0c7 18				db WORD_SYS_CORE+OPCODE_SWAP             
a0c8 06 a1			dw .COLN            
a0ca 05				db 4 + 1 
a0cb .. 00			db "SWAP",0              
a0d0				endm 
# End of macro CWHEAD
a0d0			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a0d0					if DEBUG_FORTH_WORDS_KEY 
a0d0						DMARK "SWP" 
a0d0 f5				push af  
a0d1 3a e5 a0			ld a, (.dmark)  
a0d4 32 b7 ee			ld (debug_mark),a  
a0d7 3a e6 a0			ld a, (.dmark+1)  
a0da 32 b8 ee			ld (debug_mark+1),a  
a0dd 3a e7 a0			ld a, (.dmark+2)  
a0e0 32 b9 ee			ld (debug_mark+2),a  
a0e3 18 03			jr .pastdmark  
a0e5 ..			.dmark: db "SWP"  
a0e8 f1			.pastdmark: pop af  
a0e9			endm  
# End of macro DMARK
a0e9						CALLMONITOR 
a0e9 cd a3 94			call break_point_state  
a0ec				endm  
# End of macro CALLMONITOR
a0ec					endif 
a0ec			 
a0ec					FORTH_DSP_VALUEHL 
a0ec cd 0b 9d			call macro_dsp_valuehl 
a0ef				endm 
# End of macro FORTH_DSP_VALUEHL
a0ef e5					push hl     ; w2 
a0f0			 
a0f0					FORTH_DSP_POP 
a0f0 cd c3 9d			call macro_forth_dsp_pop 
a0f3				endm 
# End of macro FORTH_DSP_POP
a0f3			 
a0f3					FORTH_DSP_VALUEHL 
a0f3 cd 0b 9d			call macro_dsp_valuehl 
a0f6				endm 
# End of macro FORTH_DSP_VALUEHL
a0f6			 
a0f6					FORTH_DSP_POP 
a0f6 cd c3 9d			call macro_forth_dsp_pop 
a0f9				endm 
# End of macro FORTH_DSP_POP
a0f9			 
a0f9 d1					pop de     ; w2	, hl = w1 
a0fa			 
a0fa eb					ex de, hl 
a0fb d5					push de 
a0fc			 
a0fc cd 14 9b				call forth_push_numhl 
a0ff			 
a0ff e1					pop hl 
a100			 
a100 cd 14 9b				call forth_push_numhl 
a103					 
a103			 
a103					NEXTW 
a103 c3 82 9e			jp macro_next 
a106				endm 
# End of macro NEXTW
a106			.COLN: 
a106				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a106 19				db WORD_SYS_CORE+OPCODE_COLN             
a107 92 a2			dw .SCOLN            
a109 02				db 1 + 1 
a10a .. 00			db ":",0              
a10c				endm 
# End of macro CWHEAD
a10c			; | : ( -- )         Create new word | DONE 
a10c			 
a10c					if DEBUG_FORTH_WORDS_KEY 
a10c						DMARK "CLN" 
a10c f5				push af  
a10d 3a 21 a1			ld a, (.dmark)  
a110 32 b7 ee			ld (debug_mark),a  
a113 3a 22 a1			ld a, (.dmark+1)  
a116 32 b8 ee			ld (debug_mark+1),a  
a119 3a 23 a1			ld a, (.dmark+2)  
a11c 32 b9 ee			ld (debug_mark+2),a  
a11f 18 03			jr .pastdmark  
a121 ..			.dmark: db "CLN"  
a124 f1			.pastdmark: pop af  
a125			endm  
# End of macro DMARK
a125						CALLMONITOR 
a125 cd a3 94			call break_point_state  
a128				endm  
# End of macro CALLMONITOR
a128					endif 
a128				STACKFRAME OFF $8efe $989f 
a128				if DEBUG_STACK_IMB 
a128					if OFF 
a128						exx 
a128						ld de, $8efe 
a128						ld a, d 
a128						ld hl, curframe 
a128						call hexout 
a128						ld a, e 
a128						ld hl, curframe+2 
a128						call hexout 
a128						ld hl, $8efe 
a128						push hl 
a128						ld hl, $989f 
a128						push hl 
a128						exx 
a128					endif 
a128				endif 
a128			endm 
# End of macro STACKFRAME
a128				; get parser buffer length  of new word 
a128			 
a128				 
a128			 
a128					; move tok past this to start of name defintition 
a128					; TODO get word to define 
a128					; TODO Move past word token 
a128					; TODO get length of string up to the ';' 
a128			 
a128 2a 86 e7			ld hl, (os_tok_ptr) 
a12b 23				inc hl 
a12c 23				inc hl 
a12d			 
a12d 3e 3b			ld a, ';' 
a12f cd 0b 91			call strlent 
a132			 
a132 7d				ld a,l 
a133 32 81 e4			ld (os_new_parse_len), a 
a136			 
a136			 
a136			if DEBUG_FORTH_UWORD 
a136 ed 5b 86 e7		ld de, (os_tok_ptr) 
a13a						DMARK ":01" 
a13a f5				push af  
a13b 3a 4f a1			ld a, (.dmark)  
a13e 32 b7 ee			ld (debug_mark),a  
a141 3a 50 a1			ld a, (.dmark+1)  
a144 32 b8 ee			ld (debug_mark+1),a  
a147 3a 51 a1			ld a, (.dmark+2)  
a14a 32 b9 ee			ld (debug_mark+2),a  
a14d 18 03			jr .pastdmark  
a14f ..			.dmark: db ":01"  
a152 f1			.pastdmark: pop af  
a153			endm  
# End of macro DMARK
a153				CALLMONITOR 
a153 cd a3 94			call break_point_state  
a156				endm  
# End of macro CALLMONITOR
a156			endif 
a156			 
a156			; 
a156			;  new word memory layout: 
a156			;  
a156			;    : adg 6666 ;  
a156			; 
a156			;    db   1     ; user defined word  
a156 23				inc hl    
a157			;    dw   sysdict 
a157 23				inc hl 
a158 23				inc hl 
a159			;    db <word len>+1 (for null) 
a159 23				inc hl 
a15a			;    db .... <word> 
a15a			; 
a15a			 
a15a 23				inc hl    ; some extras for the word preamble before the above 
a15b 23				inc hl 
a15c 23				inc hl 
a15d 23				inc hl 
a15e 23				inc hl 
a15f 23				inc hl 
a160 23				inc hl  
a161 23				inc hl 
a162 23				inc hl 
a163 23				inc hl 
a164 23				inc hl 
a165 23				inc hl 
a166 23				inc hl 
a167 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a168			;       exec word buffer 
a168			;	<ptr word>   
a168 23				inc hl 
a169 23				inc hl 
a16a			;       <word list><null term> 7F final term 
a16a			 
a16a			 
a16a			if DEBUG_FORTH_UWORD 
a16a						DMARK ":02" 
a16a f5				push af  
a16b 3a 7f a1			ld a, (.dmark)  
a16e 32 b7 ee			ld (debug_mark),a  
a171 3a 80 a1			ld a, (.dmark+1)  
a174 32 b8 ee			ld (debug_mark+1),a  
a177 3a 81 a1			ld a, (.dmark+2)  
a17a 32 b9 ee			ld (debug_mark+2),a  
a17d 18 03			jr .pastdmark  
a17f ..			.dmark: db ":02"  
a182 f1			.pastdmark: pop af  
a183			endm  
# End of macro DMARK
a183				CALLMONITOR 
a183 cd a3 94			call break_point_state  
a186				endm  
# End of macro CALLMONITOR
a186			endif 
a186			 
a186				 
a186					; malloc the size 
a186			 
a186 cd 69 91				call malloc 
a189 22 83 e4				ld (os_new_malloc), hl     ; save malloc start 
a18c			 
a18c			;    db   1     ; user defined word  
a18c 3e 01				ld a, WORD_SYS_UWORD  
a18e 77					ld (hl), a 
a18f				 
a18f 23				inc hl    
a190			;    dw   sysdict 
a190 11 da 9f			ld de, sysdict       ; continue on with the scan to the system dict 
a193 73				ld (hl), e 
a194 23				inc hl 
a195 72				ld (hl), d 
a196 23				inc hl 
a197			 
a197			 
a197			;    Setup dict word 
a197			 
a197 23				inc hl 
a198 22 7d e4			ld (os_new_work_ptr), hl     ; save start of dict word  
a19b			 
a19b				; 1. get length of dict word 
a19b			 
a19b			 
a19b 2a 86 e7			ld hl, (os_tok_ptr) 
a19e 23				inc hl 
a19f 23				inc hl    ; position to start of dict word 
a1a0 3e 00			ld a, 0 
a1a2 cd 0b 91			call strlent 
a1a5			 
a1a5			 
a1a5 23				inc hl    ; to include null??? 
a1a6			 
a1a6				; write length of dict word 
a1a6			 
a1a6 ed 5b 7d e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1aa 1b				dec de 
a1ab eb				ex de, hl 
a1ac 73				ld (hl), e 
a1ad eb				ex de, hl 
a1ae			 
a1ae				 
a1ae			 
a1ae				; copy  
a1ae 4d				ld c, l 
a1af 06 00			ld b, 0 
a1b1 ed 5b 7d e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1b5 2a 86 e7			ld hl, (os_tok_ptr) 
a1b8 23				inc hl 
a1b9 23				inc hl    ; position to start of dict word 
a1ba				 
a1ba			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a1ba				 
a1ba				; TODO need to convert word to upper case 
a1ba			 
a1ba			ucasetok:	 
a1ba 7e				ld a,(hl) 
a1bb cd f7 90			call toUpper 
a1be 77				ld (hl),a 
a1bf ed a0			ldi 
a1c1 f2 ba a1		 	jp p, ucasetok 
a1c4			 
a1c4			 
a1c4			 
a1c4				; de now points to start of where the word body code should be placed 
a1c4 ed 53 7d e4		ld (os_new_work_ptr), de 
a1c8				; hl now points to the words to throw at forthexec which needs to be copied 
a1c8 22 7b e4			ld (os_new_src_ptr), hl 
a1cb			 
a1cb				; TODO add 'call to forthexec' 
a1cb			 
a1cb			if DEBUG_FORTH_UWORD 
a1cb c5				push bc 
a1cc ed 4b 83 e4		ld bc, (os_new_malloc) 
a1d0						DMARK ":0x" 
a1d0 f5				push af  
a1d1 3a e5 a1			ld a, (.dmark)  
a1d4 32 b7 ee			ld (debug_mark),a  
a1d7 3a e6 a1			ld a, (.dmark+1)  
a1da 32 b8 ee			ld (debug_mark+1),a  
a1dd 3a e7 a1			ld a, (.dmark+2)  
a1e0 32 b9 ee			ld (debug_mark+2),a  
a1e3 18 03			jr .pastdmark  
a1e5 ..			.dmark: db ":0x"  
a1e8 f1			.pastdmark: pop af  
a1e9			endm  
# End of macro DMARK
a1e9				CALLMONITOR 
a1e9 cd a3 94			call break_point_state  
a1ec				endm  
# End of macro CALLMONITOR
a1ec c1				pop bc 
a1ed			endif 
a1ed			 
a1ed			 
a1ed				; create word preamble which should be: 
a1ed			 
a1ed			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a1ed			 
a1ed				;    ld hl, <word code> 
a1ed				;    jp user_exec 
a1ed			        ;    <word code bytes> 
a1ed			 
a1ed			 
a1ed			;	inc de     ; TODO ??? or are we already past the word's null 
a1ed eb				ex de, hl 
a1ee			 
a1ee 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a1f0			 
a1f0 23				inc hl 
a1f1 22 77 e4			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a1f4 23				inc hl 
a1f5			 
a1f5 23				inc hl 
a1f6 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a1f8			 
a1f8 01 17 c6			ld bc, user_exec 
a1fb 23				inc hl 
a1fc 71				ld (hl), c     ; poke address of user_exec 
a1fd 23				inc hl 
a1fe 70				ld (hl), b     
a1ff			 ; 
a1ff			;	inc hl 
a1ff			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1ff			; 
a1ff			; 
a1ff			;	ld bc, macro_forth_rsp_next 
a1ff			;	inc hl 
a1ff			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a1ff			;	inc hl 
a1ff			;	ld (hl), b     
a1ff			 ; 
a1ff			;	inc hl 
a1ff			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1ff			; 
a1ff			; 
a1ff			;	inc hl 
a1ff			;	ld bc, forthexec 
a1ff			;	ld (hl), c     ; poke address of forthexec 
a1ff			;	inc hl 
a1ff			;	ld (hl), b      
a1ff			; 
a1ff			;	inc hl 
a1ff			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a1ff			; 
a1ff			;	ld bc, user_dict_next 
a1ff			;	inc hl 
a1ff			;	ld (hl), c     ; poke address of forthexec 
a1ff			;	inc hl 
a1ff			;	ld (hl), b      
a1ff			 
a1ff				; hl is now where we need to copy the word byte data to save this 
a1ff			 
a1ff 23				inc hl 
a200 22 79 e4			ld (os_new_exec), hl 
a203				 
a203				; copy definition 
a203			 
a203 eb				ex de, hl 
a204			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a204			;	inc de    ; skip the PC for this parse 
a204 3a 81 e4			ld a, (os_new_parse_len) 
a207 4f				ld c, a 
a208 06 00			ld b, 0 
a20a ed b0			ldir		 ; copy defintion 
a20c			 
a20c			 
a20c				; poke the address of where the new word bytes live for forthexec 
a20c			 
a20c 2a 77 e4			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a20f			 
a20f ed 5b 79 e4		ld de, (os_new_exec)      
a213				 
a213 73				ld (hl), e 
a214 23				inc hl 
a215 72				ld (hl), d 
a216			 
a216					; TODO copy last user dict word next link to this word 
a216					; TODO update last user dict word to point to this word 
a216			; 
a216			; hl f923 de 812a ; bc 811a 
a216			 
a216			if DEBUG_FORTH_UWORD 
a216 c5				push bc 
a217 ed 4b 83 e4		ld bc, (os_new_malloc) 
a21b						DMARK ":0A" 
a21b f5				push af  
a21c 3a 30 a2			ld a, (.dmark)  
a21f 32 b7 ee			ld (debug_mark),a  
a222 3a 31 a2			ld a, (.dmark+1)  
a225 32 b8 ee			ld (debug_mark+1),a  
a228 3a 32 a2			ld a, (.dmark+2)  
a22b 32 b9 ee			ld (debug_mark+2),a  
a22e 18 03			jr .pastdmark  
a230 ..			.dmark: db ":0A"  
a233 f1			.pastdmark: pop af  
a234			endm  
# End of macro DMARK
a234				CALLMONITOR 
a234 cd a3 94			call break_point_state  
a237				endm  
# End of macro CALLMONITOR
a237 c1				pop bc 
a238			endif 
a238			if DEBUG_FORTH_UWORD 
a238 c5				push bc 
a239 ed 4b 83 e4		ld bc, (os_new_malloc) 
a23d 03				inc bc 
a23e 03				inc bc 
a23f 03				inc bc 
a240 03				inc bc 
a241 03				inc bc 
a242 03				inc bc 
a243 03				inc bc 
a244 03				inc bc 
a245			 
a245						DMARK ":0B" 
a245 f5				push af  
a246 3a 5a a2			ld a, (.dmark)  
a249 32 b7 ee			ld (debug_mark),a  
a24c 3a 5b a2			ld a, (.dmark+1)  
a24f 32 b8 ee			ld (debug_mark+1),a  
a252 3a 5c a2			ld a, (.dmark+2)  
a255 32 b9 ee			ld (debug_mark+2),a  
a258 18 03			jr .pastdmark  
a25a ..			.dmark: db ":0B"  
a25d f1			.pastdmark: pop af  
a25e			endm  
# End of macro DMARK
a25e				CALLMONITOR 
a25e cd a3 94			call break_point_state  
a261				endm  
# End of macro CALLMONITOR
a261 c1				pop bc 
a262			endif 
a262			 
a262			; update word dict linked list for new word 
a262			 
a262			 
a262 2a 82 e7		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a265 23			inc hl     ; move to next work linked list ptr 
a266			 
a266 ed 5b 83 e4	ld de, (os_new_malloc)		 ; new next word 
a26a 73			ld (hl), e 
a26b 23			inc hl 
a26c 72			ld (hl), d 
a26d			 
a26d			if DEBUG_FORTH_UWORD 
a26d ed 4b 82 e7		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a271			endif 
a271			 
a271 ed 53 82 e7	ld (os_last_new_uword), de      ; update last new uword ptr 
a275			 
a275			 
a275			if DEBUG_FORTH_UWORD 
a275						DMARK ":0+" 
a275 f5				push af  
a276 3a 8a a2			ld a, (.dmark)  
a279 32 b7 ee			ld (debug_mark),a  
a27c 3a 8b a2			ld a, (.dmark+1)  
a27f 32 b8 ee			ld (debug_mark+1),a  
a282 3a 8c a2			ld a, (.dmark+2)  
a285 32 b9 ee			ld (debug_mark+2),a  
a288 18 03			jr .pastdmark  
a28a ..			.dmark: db ":0+"  
a28d f1			.pastdmark: pop af  
a28e			endm  
# End of macro DMARK
a28e				CALLMONITOR 
a28e cd a3 94			call break_point_state  
a291				endm  
# End of macro CALLMONITOR
a291			endif 
a291			 
a291				STACKFRAMECHK OFF $8efe $989f 
a291				if DEBUG_STACK_IMB 
a291					if OFF 
a291						exx 
a291						ld hl, $989f 
a291						pop de   ; $989f 
a291						call cmp16 
a291						jr nz, .spnosame 
a291						ld hl, $8efe 
a291						pop de   ; $8efe 
a291						call cmp16 
a291						jr z, .spfrsame 
a291						.spnosame: call showsperror 
a291						.spfrsame: nop 
a291						exx 
a291					endif 
a291				endif 
a291			endm 
# End of macro STACKFRAMECHK
a291			 
a291 c9			ret    ; dont process any remaining parser tokens as they form new word 
a292			 
a292			 
a292			 
a292			 
a292			;		NEXT 
a292			.SCOLN: 
a292			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a292 06				db OPCODE_SCOLN 
a293 de a2			dw .DROP 
a295 02				db 2 
a296 .. 00			db ";",0           
a298			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a298					if DEBUG_FORTH_WORDS_KEY 
a298						DMARK "SCN" 
a298 f5				push af  
a299 3a ad a2			ld a, (.dmark)  
a29c 32 b7 ee			ld (debug_mark),a  
a29f 3a ae a2			ld a, (.dmark+1)  
a2a2 32 b8 ee			ld (debug_mark+1),a  
a2a5 3a af a2			ld a, (.dmark+2)  
a2a8 32 b9 ee			ld (debug_mark+2),a  
a2ab 18 03			jr .pastdmark  
a2ad ..			.dmark: db "SCN"  
a2b0 f1			.pastdmark: pop af  
a2b1			endm  
# End of macro DMARK
a2b1						CALLMONITOR 
a2b1 cd a3 94			call break_point_state  
a2b4				endm  
# End of macro CALLMONITOR
a2b4					endif 
a2b4					FORTH_RSP_TOS 
a2b4 cd d2 9a			call macro_forth_rsp_tos 
a2b7				endm 
# End of macro FORTH_RSP_TOS
a2b7 e5					push hl 
a2b8					FORTH_RSP_POP 
a2b8 cd dc 9a			call macro_forth_rsp_pop 
a2bb				endm 
# End of macro FORTH_RSP_POP
a2bb e1					pop hl 
a2bc			;		ex de,hl 
a2bc 22 86 e7				ld (os_tok_ptr),hl 
a2bf			 
a2bf			if DEBUG_FORTH_UWORD 
a2bf						DMARK "SCL" 
a2bf f5				push af  
a2c0 3a d4 a2			ld a, (.dmark)  
a2c3 32 b7 ee			ld (debug_mark),a  
a2c6 3a d5 a2			ld a, (.dmark+1)  
a2c9 32 b8 ee			ld (debug_mark+1),a  
a2cc 3a d6 a2			ld a, (.dmark+2)  
a2cf 32 b9 ee			ld (debug_mark+2),a  
a2d2 18 03			jr .pastdmark  
a2d4 ..			.dmark: db "SCL"  
a2d7 f1			.pastdmark: pop af  
a2d8			endm  
# End of macro DMARK
a2d8				CALLMONITOR 
a2d8 cd a3 94			call break_point_state  
a2db				endm  
# End of macro CALLMONITOR
a2db			endif 
a2db					NEXTW 
a2db c3 82 9e			jp macro_next 
a2de				endm 
# End of macro NEXTW
a2de			 
a2de			.DROP: 
a2de				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a2de 1b				db WORD_SYS_CORE+OPCODE_DROP             
a2df 09 a3			dw .DUP2            
a2e1 05				db 4 + 1 
a2e2 .. 00			db "DROP",0              
a2e7				endm 
# End of macro CWHEAD
a2e7			; | DROP ( w -- )   drop the TOS item   | DONE 
a2e7					if DEBUG_FORTH_WORDS_KEY 
a2e7						DMARK "DRP" 
a2e7 f5				push af  
a2e8 3a fc a2			ld a, (.dmark)  
a2eb 32 b7 ee			ld (debug_mark),a  
a2ee 3a fd a2			ld a, (.dmark+1)  
a2f1 32 b8 ee			ld (debug_mark+1),a  
a2f4 3a fe a2			ld a, (.dmark+2)  
a2f7 32 b9 ee			ld (debug_mark+2),a  
a2fa 18 03			jr .pastdmark  
a2fc ..			.dmark: db "DRP"  
a2ff f1			.pastdmark: pop af  
a300			endm  
# End of macro DMARK
a300						CALLMONITOR 
a300 cd a3 94			call break_point_state  
a303				endm  
# End of macro CALLMONITOR
a303					endif 
a303					FORTH_DSP_POP 
a303 cd c3 9d			call macro_forth_dsp_pop 
a306				endm 
# End of macro FORTH_DSP_POP
a306					NEXTW 
a306 c3 82 9e			jp macro_next 
a309				endm 
# End of macro NEXTW
a309			.DUP2: 
a309				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a309 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a30a 4e a3			dw .DROP2            
a30c 05				db 4 + 1 
a30d .. 00			db "2DUP",0              
a312				endm 
# End of macro CWHEAD
a312			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a312					if DEBUG_FORTH_WORDS_KEY 
a312						DMARK "2DU" 
a312 f5				push af  
a313 3a 27 a3			ld a, (.dmark)  
a316 32 b7 ee			ld (debug_mark),a  
a319 3a 28 a3			ld a, (.dmark+1)  
a31c 32 b8 ee			ld (debug_mark+1),a  
a31f 3a 29 a3			ld a, (.dmark+2)  
a322 32 b9 ee			ld (debug_mark+2),a  
a325 18 03			jr .pastdmark  
a327 ..			.dmark: db "2DU"  
a32a f1			.pastdmark: pop af  
a32b			endm  
# End of macro DMARK
a32b						CALLMONITOR 
a32b cd a3 94			call break_point_state  
a32e				endm  
# End of macro CALLMONITOR
a32e					endif 
a32e					FORTH_DSP_VALUEHL 
a32e cd 0b 9d			call macro_dsp_valuehl 
a331				endm 
# End of macro FORTH_DSP_VALUEHL
a331 e5					push hl      ; 2 
a332			 
a332					FORTH_DSP_POP 
a332 cd c3 9d			call macro_forth_dsp_pop 
a335				endm 
# End of macro FORTH_DSP_POP
a335					 
a335					FORTH_DSP_VALUEHL 
a335 cd 0b 9d			call macro_dsp_valuehl 
a338				endm 
# End of macro FORTH_DSP_VALUEHL
a338			;		push hl      ; 1 
a338			 
a338					FORTH_DSP_POP 
a338 cd c3 9d			call macro_forth_dsp_pop 
a33b				endm 
# End of macro FORTH_DSP_POP
a33b			 
a33b			;		pop hl       ; 1 
a33b d1					pop de       ; 2 
a33c			 
a33c cd 14 9b				call forth_push_numhl 
a33f eb					ex de, hl 
a340 cd 14 9b				call forth_push_numhl 
a343			 
a343					 
a343 eb					ex de, hl 
a344			 
a344 cd 14 9b				call forth_push_numhl 
a347 eb					ex de, hl 
a348 cd 14 9b				call forth_push_numhl 
a34b			 
a34b			 
a34b					NEXTW 
a34b c3 82 9e			jp macro_next 
a34e				endm 
# End of macro NEXTW
a34e			.DROP2: 
a34e				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a34e 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a34f 7d a3			dw .SWAP2            
a351 06				db 5 + 1 
a352 .. 00			db "2DROP",0              
a358				endm 
# End of macro CWHEAD
a358			; | 2DROP ( w w -- )    Double drop | DONE 
a358					if DEBUG_FORTH_WORDS_KEY 
a358						DMARK "2DR" 
a358 f5				push af  
a359 3a 6d a3			ld a, (.dmark)  
a35c 32 b7 ee			ld (debug_mark),a  
a35f 3a 6e a3			ld a, (.dmark+1)  
a362 32 b8 ee			ld (debug_mark+1),a  
a365 3a 6f a3			ld a, (.dmark+2)  
a368 32 b9 ee			ld (debug_mark+2),a  
a36b 18 03			jr .pastdmark  
a36d ..			.dmark: db "2DR"  
a370 f1			.pastdmark: pop af  
a371			endm  
# End of macro DMARK
a371						CALLMONITOR 
a371 cd a3 94			call break_point_state  
a374				endm  
# End of macro CALLMONITOR
a374					endif 
a374					FORTH_DSP_POP 
a374 cd c3 9d			call macro_forth_dsp_pop 
a377				endm 
# End of macro FORTH_DSP_POP
a377					FORTH_DSP_POP 
a377 cd c3 9d			call macro_forth_dsp_pop 
a37a				endm 
# End of macro FORTH_DSP_POP
a37a					NEXTW 
a37a c3 82 9e			jp macro_next 
a37d				endm 
# End of macro NEXTW
a37d			.SWAP2: 
a37d				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a37d 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a37e a6 a3			dw .AT            
a380 06				db 5 + 1 
a381 .. 00			db "2SWAP",0              
a387				endm 
# End of macro CWHEAD
a387			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a387					if DEBUG_FORTH_WORDS_KEY 
a387						DMARK "2SW" 
a387 f5				push af  
a388 3a 9c a3			ld a, (.dmark)  
a38b 32 b7 ee			ld (debug_mark),a  
a38e 3a 9d a3			ld a, (.dmark+1)  
a391 32 b8 ee			ld (debug_mark+1),a  
a394 3a 9e a3			ld a, (.dmark+2)  
a397 32 b9 ee			ld (debug_mark+2),a  
a39a 18 03			jr .pastdmark  
a39c ..			.dmark: db "2SW"  
a39f f1			.pastdmark: pop af  
a3a0			endm  
# End of macro DMARK
a3a0						CALLMONITOR 
a3a0 cd a3 94			call break_point_state  
a3a3				endm  
# End of macro CALLMONITOR
a3a3					endif 
a3a3					NEXTW 
a3a3 c3 82 9e			jp macro_next 
a3a6				endm 
# End of macro NEXTW
a3a6			.AT: 
a3a6				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a3a6 1f				db WORD_SYS_CORE+OPCODE_AT             
a3a7 d8 a3			dw .CAT            
a3a9 02				db 1 + 1 
a3aa .. 00			db "@",0              
a3ac				endm 
# End of macro CWHEAD
a3ac			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a3ac			 
a3ac					if DEBUG_FORTH_WORDS_KEY 
a3ac						DMARK "AT." 
a3ac f5				push af  
a3ad 3a c1 a3			ld a, (.dmark)  
a3b0 32 b7 ee			ld (debug_mark),a  
a3b3 3a c2 a3			ld a, (.dmark+1)  
a3b6 32 b8 ee			ld (debug_mark+1),a  
a3b9 3a c3 a3			ld a, (.dmark+2)  
a3bc 32 b9 ee			ld (debug_mark+2),a  
a3bf 18 03			jr .pastdmark  
a3c1 ..			.dmark: db "AT."  
a3c4 f1			.pastdmark: pop af  
a3c5			endm  
# End of macro DMARK
a3c5						CALLMONITOR 
a3c5 cd a3 94			call break_point_state  
a3c8				endm  
# End of macro CALLMONITOR
a3c8					endif 
a3c8			.getbyteat:	 
a3c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3c8 cd 0b 9d			call macro_dsp_valuehl 
a3cb				endm 
# End of macro FORTH_DSP_VALUEHL
a3cb					 
a3cb			;		push hl 
a3cb				 
a3cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3cb cd c3 9d			call macro_forth_dsp_pop 
a3ce				endm 
# End of macro FORTH_DSP_POP
a3ce			 
a3ce			;		pop hl 
a3ce			 
a3ce 7e					ld a, (hl) 
a3cf			 
a3cf 6f					ld l, a 
a3d0 26 00				ld h, 0 
a3d2 cd 14 9b				call forth_push_numhl 
a3d5			 
a3d5					NEXTW 
a3d5 c3 82 9e			jp macro_next 
a3d8				endm 
# End of macro NEXTW
a3d8			.CAT: 
a3d8				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a3d8 20				db WORD_SYS_CORE+OPCODE_CAT             
a3d9 01 a4			dw .BANG            
a3db 03				db 2 + 1 
a3dc .. 00			db "C@",0              
a3df				endm 
# End of macro CWHEAD
a3df			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a3df					if DEBUG_FORTH_WORDS_KEY 
a3df						DMARK "CAA" 
a3df f5				push af  
a3e0 3a f4 a3			ld a, (.dmark)  
a3e3 32 b7 ee			ld (debug_mark),a  
a3e6 3a f5 a3			ld a, (.dmark+1)  
a3e9 32 b8 ee			ld (debug_mark+1),a  
a3ec 3a f6 a3			ld a, (.dmark+2)  
a3ef 32 b9 ee			ld (debug_mark+2),a  
a3f2 18 03			jr .pastdmark  
a3f4 ..			.dmark: db "CAA"  
a3f7 f1			.pastdmark: pop af  
a3f8			endm  
# End of macro DMARK
a3f8						CALLMONITOR 
a3f8 cd a3 94			call break_point_state  
a3fb				endm  
# End of macro CALLMONITOR
a3fb					endif 
a3fb c3 c8 a3				jp .getbyteat 
a3fe					NEXTW 
a3fe c3 82 9e			jp macro_next 
a401				endm 
# End of macro NEXTW
a401			.BANG: 
a401				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a401 21				db WORD_SYS_CORE+OPCODE_BANG             
a402 37 a4			dw .CBANG            
a404 02				db 1 + 1 
a405 .. 00			db "!",0              
a407				endm 
# End of macro CWHEAD
a407			; | ! ( x w -- ) Store x at address w      | DONE 
a407					if DEBUG_FORTH_WORDS_KEY 
a407						DMARK "BNG" 
a407 f5				push af  
a408 3a 1c a4			ld a, (.dmark)  
a40b 32 b7 ee			ld (debug_mark),a  
a40e 3a 1d a4			ld a, (.dmark+1)  
a411 32 b8 ee			ld (debug_mark+1),a  
a414 3a 1e a4			ld a, (.dmark+2)  
a417 32 b9 ee			ld (debug_mark+2),a  
a41a 18 03			jr .pastdmark  
a41c ..			.dmark: db "BNG"  
a41f f1			.pastdmark: pop af  
a420			endm  
# End of macro DMARK
a420						CALLMONITOR 
a420 cd a3 94			call break_point_state  
a423				endm  
# End of macro CALLMONITOR
a423					endif 
a423			 
a423			.storebyteat:		 
a423					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a423 cd 0b 9d			call macro_dsp_valuehl 
a426				endm 
# End of macro FORTH_DSP_VALUEHL
a426					 
a426 e5					push hl 
a427				 
a427					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a427 cd c3 9d			call macro_forth_dsp_pop 
a42a				endm 
# End of macro FORTH_DSP_POP
a42a			 
a42a					; get byte to poke 
a42a			 
a42a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a42a cd 0b 9d			call macro_dsp_valuehl 
a42d				endm 
# End of macro FORTH_DSP_VALUEHL
a42d e5					push hl 
a42e			 
a42e			 
a42e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a42e cd c3 9d			call macro_forth_dsp_pop 
a431				endm 
# End of macro FORTH_DSP_POP
a431			 
a431			 
a431 d1					pop de 
a432 e1					pop hl 
a433			 
a433 73					ld (hl),e 
a434			 
a434			 
a434					NEXTW 
a434 c3 82 9e			jp macro_next 
a437				endm 
# End of macro NEXTW
a437			.CBANG: 
a437				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a437 22				db WORD_SYS_CORE+OPCODE_CBANG             
a438 60 a4			dw .SCALL            
a43a 03				db 2 + 1 
a43b .. 00			db "C!",0              
a43e				endm 
# End of macro CWHEAD
a43e			; | C!  ( x w -- ) Store x at address w  | DONE 
a43e					if DEBUG_FORTH_WORDS_KEY 
a43e						DMARK "CBA" 
a43e f5				push af  
a43f 3a 53 a4			ld a, (.dmark)  
a442 32 b7 ee			ld (debug_mark),a  
a445 3a 54 a4			ld a, (.dmark+1)  
a448 32 b8 ee			ld (debug_mark+1),a  
a44b 3a 55 a4			ld a, (.dmark+2)  
a44e 32 b9 ee			ld (debug_mark+2),a  
a451 18 03			jr .pastdmark  
a453 ..			.dmark: db "CBA"  
a456 f1			.pastdmark: pop af  
a457			endm  
# End of macro DMARK
a457						CALLMONITOR 
a457 cd a3 94			call break_point_state  
a45a				endm  
# End of macro CALLMONITOR
a45a					endif 
a45a c3 23 a4				jp .storebyteat 
a45d					NEXTW 
a45d c3 82 9e			jp macro_next 
a460				endm 
# End of macro NEXTW
a460			.SCALL: 
a460				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a460 23				db WORD_SYS_CORE+OPCODE_SCALL             
a461 94 a4			dw .DEPTH            
a463 05				db 4 + 1 
a464 .. 00			db "CALL",0              
a469				endm 
# End of macro CWHEAD
a469			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a469					if DEBUG_FORTH_WORDS_KEY 
a469						DMARK "CLL" 
a469 f5				push af  
a46a 3a 7e a4			ld a, (.dmark)  
a46d 32 b7 ee			ld (debug_mark),a  
a470 3a 7f a4			ld a, (.dmark+1)  
a473 32 b8 ee			ld (debug_mark+1),a  
a476 3a 80 a4			ld a, (.dmark+2)  
a479 32 b9 ee			ld (debug_mark+2),a  
a47c 18 03			jr .pastdmark  
a47e ..			.dmark: db "CLL"  
a481 f1			.pastdmark: pop af  
a482			endm  
# End of macro DMARK
a482						CALLMONITOR 
a482 cd a3 94			call break_point_state  
a485				endm  
# End of macro CALLMONITOR
a485					endif 
a485			 
a485					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a485 cd 0b 9d			call macro_dsp_valuehl 
a488				endm 
# End of macro FORTH_DSP_VALUEHL
a488			 
a488			;		push hl 
a488			 
a488					; destroy value TOS 
a488			 
a488					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a488 cd c3 9d			call macro_forth_dsp_pop 
a48b				endm 
# End of macro FORTH_DSP_POP
a48b			 
a48b						 
a48b			;		pop hl 
a48b			 
a48b					; how to do a call with hl???? save SP? 
a48b cd 26 9e				call forth_call_hl 
a48e			 
a48e			 
a48e					; TODO push value back onto stack for another op etc 
a48e			 
a48e cd 14 9b				call forth_push_numhl 
a491					NEXTW 
a491 c3 82 9e			jp macro_next 
a494				endm 
# End of macro NEXTW
a494			.DEPTH: 
a494				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a494 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a495 d1 a4			dw .OVER            
a497 06				db 5 + 1 
a498 .. 00			db "DEPTH",0              
a49e				endm 
# End of macro CWHEAD
a49e			; | DEPTH ( -- u ) Push count of stack | DONE 
a49e					; take current TOS and remove from base value div by two to get count 
a49e					if DEBUG_FORTH_WORDS_KEY 
a49e						DMARK "DEP" 
a49e f5				push af  
a49f 3a b3 a4			ld a, (.dmark)  
a4a2 32 b7 ee			ld (debug_mark),a  
a4a5 3a b4 a4			ld a, (.dmark+1)  
a4a8 32 b8 ee			ld (debug_mark+1),a  
a4ab 3a b5 a4			ld a, (.dmark+2)  
a4ae 32 b9 ee			ld (debug_mark+2),a  
a4b1 18 03			jr .pastdmark  
a4b3 ..			.dmark: db "DEP"  
a4b6 f1			.pastdmark: pop af  
a4b7			endm  
# End of macro DMARK
a4b7						CALLMONITOR 
a4b7 cd a3 94			call break_point_state  
a4ba				endm  
# End of macro CALLMONITOR
a4ba					endif 
a4ba			 
a4ba			 
a4ba 2a b2 eb			ld hl, (cli_data_sp) 
a4bd 11 ec e9			ld de, cli_data_stack 
a4c0 ed 52			sbc hl,de 
a4c2				 
a4c2				; div by size of stack item 
a4c2			 
a4c2 5d				ld e,l 
a4c3 0e 03			ld c, 3 
a4c5 cd 32 8c			call Div8 
a4c8			 
a4c8 6f				ld l,a 
a4c9 26 00			ld h,0 
a4cb			 
a4cb				;srl h 
a4cb				;rr l 
a4cb			 
a4cb cd 14 9b				call forth_push_numhl 
a4ce					NEXTW 
a4ce c3 82 9e			jp macro_next 
a4d1				endm 
# End of macro NEXTW
a4d1			.OVER: 
a4d1				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a4d1 42				db WORD_SYS_CORE+46             
a4d2 18 a5			dw .PAUSE            
a4d4 05				db 4 + 1 
a4d5 .. 00			db "OVER",0              
a4da				endm 
# End of macro CWHEAD
a4da			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a4da					if DEBUG_FORTH_WORDS_KEY 
a4da						DMARK "OVR" 
a4da f5				push af  
a4db 3a ef a4			ld a, (.dmark)  
a4de 32 b7 ee			ld (debug_mark),a  
a4e1 3a f0 a4			ld a, (.dmark+1)  
a4e4 32 b8 ee			ld (debug_mark+1),a  
a4e7 3a f1 a4			ld a, (.dmark+2)  
a4ea 32 b9 ee			ld (debug_mark+2),a  
a4ed 18 03			jr .pastdmark  
a4ef ..			.dmark: db "OVR"  
a4f2 f1			.pastdmark: pop af  
a4f3			endm  
# End of macro DMARK
a4f3						CALLMONITOR 
a4f3 cd a3 94			call break_point_state  
a4f6				endm  
# End of macro CALLMONITOR
a4f6					endif 
a4f6			 
a4f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4f6 cd 0b 9d			call macro_dsp_valuehl 
a4f9				endm 
# End of macro FORTH_DSP_VALUEHL
a4f9 e5					push hl    ; n2 
a4fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4fa cd c3 9d			call macro_forth_dsp_pop 
a4fd				endm 
# End of macro FORTH_DSP_POP
a4fd			 
a4fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4fd cd 0b 9d			call macro_dsp_valuehl 
a500				endm 
# End of macro FORTH_DSP_VALUEHL
a500 e5					push hl    ; n1 
a501					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a501 cd c3 9d			call macro_forth_dsp_pop 
a504				endm 
# End of macro FORTH_DSP_POP
a504			 
a504 d1					pop de     ; n1 
a505 e1					pop hl     ; n2 
a506			 
a506 d5					push de 
a507 e5					push hl 
a508 d5					push de 
a509			 
a509					; push back  
a509			 
a509 e1					pop hl 
a50a cd 14 9b				call forth_push_numhl 
a50d e1					pop hl 
a50e cd 14 9b				call forth_push_numhl 
a511 e1					pop hl 
a512 cd 14 9b				call forth_push_numhl 
a515					NEXTW 
a515 c3 82 9e			jp macro_next 
a518				endm 
# End of macro NEXTW
a518			 
a518			.PAUSE: 
a518				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a518 43				db WORD_SYS_CORE+47             
a519 4d a5			dw .PAUSES            
a51b 08				db 7 + 1 
a51c .. 00			db "PAUSEMS",0              
a524				endm 
# End of macro CWHEAD
a524			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a524					if DEBUG_FORTH_WORDS_KEY 
a524						DMARK "PMS" 
a524 f5				push af  
a525 3a 39 a5			ld a, (.dmark)  
a528 32 b7 ee			ld (debug_mark),a  
a52b 3a 3a a5			ld a, (.dmark+1)  
a52e 32 b8 ee			ld (debug_mark+1),a  
a531 3a 3b a5			ld a, (.dmark+2)  
a534 32 b9 ee			ld (debug_mark+2),a  
a537 18 03			jr .pastdmark  
a539 ..			.dmark: db "PMS"  
a53c f1			.pastdmark: pop af  
a53d			endm  
# End of macro DMARK
a53d						CALLMONITOR 
a53d cd a3 94			call break_point_state  
a540				endm  
# End of macro CALLMONITOR
a540					endif 
a540					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a540 cd 0b 9d			call macro_dsp_valuehl 
a543				endm 
# End of macro FORTH_DSP_VALUEHL
a543			;		push hl    ; n2 
a543					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a543 cd c3 9d			call macro_forth_dsp_pop 
a546				endm 
# End of macro FORTH_DSP_POP
a546			;		pop hl 
a546			 
a546 7d					ld a, l 
a547 cd d7 89				call aDelayInMS 
a54a				       NEXTW 
a54a c3 82 9e			jp macro_next 
a54d				endm 
# End of macro NEXTW
a54d			.PAUSES:  
a54d				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a54d 44				db WORD_SYS_CORE+48             
a54e bc a5			dw .ROT            
a550 06				db 5 + 1 
a551 .. 00			db "PAUSE",0              
a557				endm 
# End of macro CWHEAD
a557			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a557					if DEBUG_FORTH_WORDS_KEY 
a557						DMARK "PAU" 
a557 f5				push af  
a558 3a 6c a5			ld a, (.dmark)  
a55b 32 b7 ee			ld (debug_mark),a  
a55e 3a 6d a5			ld a, (.dmark+1)  
a561 32 b8 ee			ld (debug_mark+1),a  
a564 3a 6e a5			ld a, (.dmark+2)  
a567 32 b9 ee			ld (debug_mark+2),a  
a56a 18 03			jr .pastdmark  
a56c ..			.dmark: db "PAU"  
a56f f1			.pastdmark: pop af  
a570			endm  
# End of macro DMARK
a570						CALLMONITOR 
a570 cd a3 94			call break_point_state  
a573				endm  
# End of macro CALLMONITOR
a573					endif 
a573					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a573 cd 0b 9d			call macro_dsp_valuehl 
a576				endm 
# End of macro FORTH_DSP_VALUEHL
a576			;		push hl    ; n2 
a576					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a576 cd c3 9d			call macro_forth_dsp_pop 
a579				endm 
# End of macro FORTH_DSP_POP
a579			;		pop hl 
a579 45					ld b, l 
a57a					if DEBUG_FORTH_WORDS 
a57a						DMARK "PAU" 
a57a f5				push af  
a57b 3a 8f a5			ld a, (.dmark)  
a57e 32 b7 ee			ld (debug_mark),a  
a581 3a 90 a5			ld a, (.dmark+1)  
a584 32 b8 ee			ld (debug_mark+1),a  
a587 3a 91 a5			ld a, (.dmark+2)  
a58a 32 b9 ee			ld (debug_mark+2),a  
a58d 18 03			jr .pastdmark  
a58f ..			.dmark: db "PAU"  
a592 f1			.pastdmark: pop af  
a593			endm  
# End of macro DMARK
a593						CALLMONITOR 
a593 cd a3 94			call break_point_state  
a596				endm  
# End of macro CALLMONITOR
a596					endif 
a596 c5			.pauses1:	push bc 
a597 cd f2 89				call delay1s 
a59a c1					pop bc 
a59b					if DEBUG_FORTH_WORDS 
a59b						DMARK "PA1" 
a59b f5				push af  
a59c 3a b0 a5			ld a, (.dmark)  
a59f 32 b7 ee			ld (debug_mark),a  
a5a2 3a b1 a5			ld a, (.dmark+1)  
a5a5 32 b8 ee			ld (debug_mark+1),a  
a5a8 3a b2 a5			ld a, (.dmark+2)  
a5ab 32 b9 ee			ld (debug_mark+2),a  
a5ae 18 03			jr .pastdmark  
a5b0 ..			.dmark: db "PA1"  
a5b3 f1			.pastdmark: pop af  
a5b4			endm  
# End of macro DMARK
a5b4						CALLMONITOR 
a5b4 cd a3 94			call break_point_state  
a5b7				endm  
# End of macro CALLMONITOR
a5b7					endif 
a5b7 10 dd				djnz .pauses1 
a5b9			 
a5b9				       NEXTW 
a5b9 c3 82 9e			jp macro_next 
a5bc				endm 
# End of macro NEXTW
a5bc			.ROT: 
a5bc				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a5bc 45				db WORD_SYS_CORE+49             
a5bd 0a a6			dw .UWORDS            
a5bf 04				db 3 + 1 
a5c0 .. 00			db "ROT",0              
a5c4				endm 
# End of macro CWHEAD
a5c4			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a5c4					if DEBUG_FORTH_WORDS_KEY 
a5c4						DMARK "ROT" 
a5c4 f5				push af  
a5c5 3a d9 a5			ld a, (.dmark)  
a5c8 32 b7 ee			ld (debug_mark),a  
a5cb 3a da a5			ld a, (.dmark+1)  
a5ce 32 b8 ee			ld (debug_mark+1),a  
a5d1 3a db a5			ld a, (.dmark+2)  
a5d4 32 b9 ee			ld (debug_mark+2),a  
a5d7 18 03			jr .pastdmark  
a5d9 ..			.dmark: db "ROT"  
a5dc f1			.pastdmark: pop af  
a5dd			endm  
# End of macro DMARK
a5dd						CALLMONITOR 
a5dd cd a3 94			call break_point_state  
a5e0				endm  
# End of macro CALLMONITOR
a5e0					endif 
a5e0			 
a5e0					FORTH_DSP_VALUEHL 
a5e0 cd 0b 9d			call macro_dsp_valuehl 
a5e3				endm 
# End of macro FORTH_DSP_VALUEHL
a5e3 e5					push hl    ; u3  
a5e4			 
a5e4					FORTH_DSP_POP 
a5e4 cd c3 9d			call macro_forth_dsp_pop 
a5e7				endm 
# End of macro FORTH_DSP_POP
a5e7			   
a5e7					FORTH_DSP_VALUEHL 
a5e7 cd 0b 9d			call macro_dsp_valuehl 
a5ea				endm 
# End of macro FORTH_DSP_VALUEHL
a5ea e5					push hl     ; u2 
a5eb			 
a5eb					FORTH_DSP_POP 
a5eb cd c3 9d			call macro_forth_dsp_pop 
a5ee				endm 
# End of macro FORTH_DSP_POP
a5ee			 
a5ee					FORTH_DSP_VALUEHL 
a5ee cd 0b 9d			call macro_dsp_valuehl 
a5f1				endm 
# End of macro FORTH_DSP_VALUEHL
a5f1 e5					push hl     ; u1 
a5f2			 
a5f2					FORTH_DSP_POP 
a5f2 cd c3 9d			call macro_forth_dsp_pop 
a5f5				endm 
# End of macro FORTH_DSP_POP
a5f5			 
a5f5 c1					pop bc      ; u1 
a5f6 e1					pop hl      ; u2 
a5f7 d1					pop de      ; u3 
a5f8			 
a5f8			 
a5f8 c5					push bc 
a5f9 d5					push de 
a5fa e5					push hl 
a5fb			 
a5fb			 
a5fb e1					pop hl 
a5fc cd 14 9b				call forth_push_numhl 
a5ff			 
a5ff e1					pop hl 
a600 cd 14 9b				call forth_push_numhl 
a603			 
a603 e1					pop hl 
a604 cd 14 9b				call forth_push_numhl 
a607					 
a607			 
a607			 
a607			 
a607			 
a607			 
a607				       NEXTW 
a607 c3 82 9e			jp macro_next 
a60a				endm 
# End of macro NEXTW
a60a			 
a60a			.UWORDS: 
a60a				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a60a 50				db WORD_SYS_CORE+60             
a60b cc a6			dw .BP            
a60d 07				db 6 + 1 
a60e .. 00			db "UWORDS",0              
a615				endm 
# End of macro CWHEAD
a615			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a615			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a615			; | | Following the count are the individual words. 
a615			; | | 
a615			; | | e.g. UWORDS 
a615			; | | BOX DIRLIST 2 
a615			; | |  
a615			; | | Can be used to save the words to storage via: 
a615			; | | UWORDS $01 DO $01 APPEND LOOP 
a615				if DEBUG_FORTH_WORDS_KEY 
a615					DMARK "UWR" 
a615 f5				push af  
a616 3a 2a a6			ld a, (.dmark)  
a619 32 b7 ee			ld (debug_mark),a  
a61c 3a 2b a6			ld a, (.dmark+1)  
a61f 32 b8 ee			ld (debug_mark+1),a  
a622 3a 2c a6			ld a, (.dmark+2)  
a625 32 b9 ee			ld (debug_mark+2),a  
a628 18 03			jr .pastdmark  
a62a ..			.dmark: db "UWR"  
a62d f1			.pastdmark: pop af  
a62e			endm  
# End of macro DMARK
a62e					CALLMONITOR 
a62e cd a3 94			call break_point_state  
a631				endm  
# End of macro CALLMONITOR
a631				endif 
a631 21 4e db				ld hl, baseram 
a634					;ld hl, baseusermem 
a634 01 00 00				ld bc, 0    ; start a counter 
a637			 
a637				; skip dict stub 
a637			 
a637 cd d3 9f				call forth_tok_next 
a63a			 
a63a			 
a63a			; while we have words to look for 
a63a			 
a63a 7e			.douscan:	ld a, (hl)      
a63b				if DEBUG_FORTH_WORDS 
a63b					DMARK "UWs" 
a63b f5				push af  
a63c 3a 50 a6			ld a, (.dmark)  
a63f 32 b7 ee			ld (debug_mark),a  
a642 3a 51 a6			ld a, (.dmark+1)  
a645 32 b8 ee			ld (debug_mark+1),a  
a648 3a 52 a6			ld a, (.dmark+2)  
a64b 32 b9 ee			ld (debug_mark+2),a  
a64e 18 03			jr .pastdmark  
a650 ..			.dmark: db "UWs"  
a653 f1			.pastdmark: pop af  
a654			endm  
# End of macro DMARK
a654					CALLMONITOR 
a654 cd a3 94			call break_point_state  
a657				endm  
# End of macro CALLMONITOR
a657				endif 
a657 fe 00				cp WORD_SYS_END 
a659 28 4d				jr z, .udone 
a65b fe 01				cp WORD_SYS_UWORD 
a65d 20 44				jr nz, .nuword 
a65f			 
a65f				if DEBUG_FORTH_WORDS 
a65f					DMARK "UWu" 
a65f f5				push af  
a660 3a 74 a6			ld a, (.dmark)  
a663 32 b7 ee			ld (debug_mark),a  
a666 3a 75 a6			ld a, (.dmark+1)  
a669 32 b8 ee			ld (debug_mark+1),a  
a66c 3a 76 a6			ld a, (.dmark+2)  
a66f 32 b9 ee			ld (debug_mark+2),a  
a672 18 03			jr .pastdmark  
a674 ..			.dmark: db "UWu"  
a677 f1			.pastdmark: pop af  
a678			endm  
# End of macro DMARK
a678					CALLMONITOR 
a678 cd a3 94			call break_point_state  
a67b				endm  
# End of macro CALLMONITOR
a67b				endif 
a67b					; we have a uword so push its name to the stack 
a67b			 
a67b e5				   	push hl  ; save so we can move to next dict block 
a67c			 
a67c					; skip opcode 
a67c 23					inc hl  
a67d					; skip next ptr 
a67d 23					inc hl  
a67e 23					inc hl 
a67f					; skip len 
a67f 23					inc hl 
a680				if DEBUG_FORTH_WORDS 
a680					DMARK "UWt" 
a680 f5				push af  
a681 3a 95 a6			ld a, (.dmark)  
a684 32 b7 ee			ld (debug_mark),a  
a687 3a 96 a6			ld a, (.dmark+1)  
a68a 32 b8 ee			ld (debug_mark+1),a  
a68d 3a 97 a6			ld a, (.dmark+2)  
a690 32 b9 ee			ld (debug_mark+2),a  
a693 18 03			jr .pastdmark  
a695 ..			.dmark: db "UWt"  
a698 f1			.pastdmark: pop af  
a699			endm  
# End of macro DMARK
a699					CALLMONITOR 
a699 cd a3 94			call break_point_state  
a69c				endm  
# End of macro CALLMONITOR
a69c				endif 
a69c 03					inc bc 
a69d			 
a69d c5					push bc 
a69e cd 82 9b				call forth_push_str 
a6a1 c1					pop bc 
a6a2			 
a6a2 e1					pop hl 	 
a6a3			 
a6a3 cd d3 9f		.nuword:	call forth_tok_next 
a6a6 18 92				jr .douscan  
a6a8			 
a6a8			.udone:		 ; push count of uwords found 
a6a8 c5					push bc 
a6a9 e1					pop hl 
a6aa			 
a6aa				if DEBUG_FORTH_WORDS 
a6aa					DMARK "UWc" 
a6aa f5				push af  
a6ab 3a bf a6			ld a, (.dmark)  
a6ae 32 b7 ee			ld (debug_mark),a  
a6b1 3a c0 a6			ld a, (.dmark+1)  
a6b4 32 b8 ee			ld (debug_mark+1),a  
a6b7 3a c1 a6			ld a, (.dmark+2)  
a6ba 32 b9 ee			ld (debug_mark+2),a  
a6bd 18 03			jr .pastdmark  
a6bf ..			.dmark: db "UWc"  
a6c2 f1			.pastdmark: pop af  
a6c3			endm  
# End of macro DMARK
a6c3					CALLMONITOR 
a6c3 cd a3 94			call break_point_state  
a6c6				endm  
# End of macro CALLMONITOR
a6c6				endif 
a6c6 cd 14 9b				call forth_push_numhl 
a6c9			 
a6c9			 
a6c9				       NEXTW 
a6c9 c3 82 9e			jp macro_next 
a6cc				endm 
# End of macro NEXTW
a6cc			 
a6cc			.BP: 
a6cc				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a6cc 54				db WORD_SYS_CORE+64             
a6cd 02 a7			dw .MONITOR            
a6cf 03				db 2 + 1 
a6d0 .. 00			db "BP",0              
a6d3				endm 
# End of macro CWHEAD
a6d3			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a6d3			; | | $00 Will enable the break points within specific code paths 
a6d3			; | | $01 Will disable break points 
a6d3			; | |  
a6d3			; | | By default break points are off. Either the above can be used to enable them 
a6d3			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a6d3			; | | and on release of the pressed key a message will be disaplayed to notify 
a6d3			; | | that break points are enabled. Pressing any key will then continue boot process. 
a6d3					; get byte count 
a6d3					if DEBUG_FORTH_WORDS_KEY 
a6d3						DMARK "BP." 
a6d3 f5				push af  
a6d4 3a e8 a6			ld a, (.dmark)  
a6d7 32 b7 ee			ld (debug_mark),a  
a6da 3a e9 a6			ld a, (.dmark+1)  
a6dd 32 b8 ee			ld (debug_mark+1),a  
a6e0 3a ea a6			ld a, (.dmark+2)  
a6e3 32 b9 ee			ld (debug_mark+2),a  
a6e6 18 03			jr .pastdmark  
a6e8 ..			.dmark: db "BP."  
a6eb f1			.pastdmark: pop af  
a6ec			endm  
# End of macro DMARK
a6ec						CALLMONITOR 
a6ec cd a3 94			call break_point_state  
a6ef				endm  
# End of macro CALLMONITOR
a6ef					endif 
a6ef			 
a6ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6ef cd 0b 9d			call macro_dsp_valuehl 
a6f2				endm 
# End of macro FORTH_DSP_VALUEHL
a6f2			 
a6f2			;		push hl 
a6f2			 
a6f2					; destroy value TOS 
a6f2			 
a6f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6f2 cd c3 9d			call macro_forth_dsp_pop 
a6f5				endm 
# End of macro FORTH_DSP_POP
a6f5			 
a6f5			;		pop hl 
a6f5			 
a6f5 3e 00				ld a,0 
a6f7 bd					cp l 
a6f8 28 02				jr z, .bpset 
a6fa 3e 2a				ld a, '*' 
a6fc			 
a6fc 32 76 e4		.bpset:		ld (os_view_disable), a 
a6ff			 
a6ff			 
a6ff					NEXTW 
a6ff c3 82 9e			jp macro_next 
a702				endm 
# End of macro NEXTW
a702			 
a702			 
a702			.MONITOR: 
a702				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a702 55				db WORD_SYS_CORE+65             
a703 35 a7			dw .MALLOC            
a705 08				db 7 + 1 
a706 .. 00			db "MONITOR",0              
a70e				endm 
# End of macro CWHEAD
a70e			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a70e			; | | At start the current various registers will be displayed with contents. 
a70e			; | | Top right corner will show the most recent debug marker seen. 
a70e			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a70e			; | | and the return stack pointer (RSP). 
a70e			; | | Pressing: 
a70e			; | |    1 - Initial screen 
a70e			; | |    2 - Display a data dump of HL 
a70e			; | |    3 - Display a data dump of DE 
a70e			; | |    4 - Display a data dump of BC 
a70e			; | |    5 - Display a data dump of HL 
a70e			; | |    6 - Display a data dump of DSP 
a70e			; | |    7 - Display a data dump of RSP 
a70e			; | |    8 - Display a data dump of what is at DSP 
a70e			; | |    9 - Display a data dump of what is at RSP 
a70e			; | |    0 - Exit monitor and continue running. This will also enable break points 
a70e			; | |    * - Disable break points 
a70e			; | |    # - Enter traditional monitor mode 
a70e			; | | 
a70e			; | | Monitor Mode 
a70e			; | | ------------ 
a70e			; | | A prompt of '>' will be shown for various commands: 
a70e			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a70e			; | |    C - Continue display a data dump from the last set address 
a70e			; | |    M xxxx - Set start of memory edit at address xx 
a70e			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a70e			; | |    Q - Return to previous 
a70e					if DEBUG_FORTH_WORDS_KEY 
a70e						DMARK "MON" 
a70e f5				push af  
a70f 3a 23 a7			ld a, (.dmark)  
a712 32 b7 ee			ld (debug_mark),a  
a715 3a 24 a7			ld a, (.dmark+1)  
a718 32 b8 ee			ld (debug_mark+1),a  
a71b 3a 25 a7			ld a, (.dmark+2)  
a71e 32 b9 ee			ld (debug_mark+2),a  
a721 18 03			jr .pastdmark  
a723 ..			.dmark: db "MON"  
a726 f1			.pastdmark: pop af  
a727			endm  
# End of macro DMARK
a727						CALLMONITOR 
a727 cd a3 94			call break_point_state  
a72a				endm  
# End of macro CALLMONITOR
a72a					endif 
a72a 3e 00				ld a, 0 
a72c 32 76 e4				ld (os_view_disable), a 
a72f			 
a72f					CALLMONITOR 
a72f cd a3 94			call break_point_state  
a732				endm  
# End of macro CALLMONITOR
a732			 
a732			;	call monitor 
a732			 
a732					NEXTW 
a732 c3 82 9e			jp macro_next 
a735				endm 
# End of macro NEXTW
a735			 
a735			 
a735			.MALLOC: 
a735				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a735 56				db WORD_SYS_CORE+66             
a736 5e a7			dw .MALLOC2            
a738 06				db 5 + 1 
a739 .. 00			db "ALLOT",0              
a73f				endm 
# End of macro CWHEAD
a73f			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a73f					if DEBUG_FORTH_WORDS_KEY 
a73f						DMARK "ALL" 
a73f f5				push af  
a740 3a 54 a7			ld a, (.dmark)  
a743 32 b7 ee			ld (debug_mark),a  
a746 3a 55 a7			ld a, (.dmark+1)  
a749 32 b8 ee			ld (debug_mark+1),a  
a74c 3a 56 a7			ld a, (.dmark+2)  
a74f 32 b9 ee			ld (debug_mark+2),a  
a752 18 03			jr .pastdmark  
a754 ..			.dmark: db "ALL"  
a757 f1			.pastdmark: pop af  
a758			endm  
# End of macro DMARK
a758						CALLMONITOR 
a758 cd a3 94			call break_point_state  
a75b				endm  
# End of macro CALLMONITOR
a75b					endif 
a75b c3 85 a7				jp .mallocc 
a75e			.MALLOC2: 
a75e				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a75e 56				db WORD_SYS_CORE+66             
a75f 9c a7			dw .FREE            
a761 07				db 6 + 1 
a762 .. 00			db "MALLOC",0              
a769				endm 
# End of macro CWHEAD
a769			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a769					; get byte count 
a769					if DEBUG_FORTH_WORDS_KEY 
a769						DMARK "MAL" 
a769 f5				push af  
a76a 3a 7e a7			ld a, (.dmark)  
a76d 32 b7 ee			ld (debug_mark),a  
a770 3a 7f a7			ld a, (.dmark+1)  
a773 32 b8 ee			ld (debug_mark+1),a  
a776 3a 80 a7			ld a, (.dmark+2)  
a779 32 b9 ee			ld (debug_mark+2),a  
a77c 18 03			jr .pastdmark  
a77e ..			.dmark: db "MAL"  
a781 f1			.pastdmark: pop af  
a782			endm  
# End of macro DMARK
a782						CALLMONITOR 
a782 cd a3 94			call break_point_state  
a785				endm  
# End of macro CALLMONITOR
a785					endif 
a785			.mallocc: 
a785					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a785 cd 0b 9d			call macro_dsp_valuehl 
a788				endm 
# End of macro FORTH_DSP_VALUEHL
a788			 
a788			;		push hl 
a788			 
a788					; destroy value TOS 
a788			 
a788					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a788 cd c3 9d			call macro_forth_dsp_pop 
a78b				endm 
# End of macro FORTH_DSP_POP
a78b			 
a78b			;		pop hl 
a78b cd 69 91				call malloc 
a78e				if DEBUG_FORTH_MALLOC_GUARD 
a78e f5					push af 
a78f cd cb 8c				call ishlzero 
a792			;		ld a, l 
a792			;		add h 
a792			;		cp 0 
a792 f1					pop af 
a793					 
a793 cc e9 c6				call z,malloc_error 
a796				endif 
a796			 
a796 cd 14 9b				call forth_push_numhl 
a799					NEXTW 
a799 c3 82 9e			jp macro_next 
a79c				endm 
# End of macro NEXTW
a79c			 
a79c			.FREE: 
a79c				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a79c 57				db WORD_SYS_CORE+67             
a79d cd a7			dw .LIST            
a79f 05				db 4 + 1 
a7a0 .. 00			db "FREE",0              
a7a5				endm 
# End of macro CWHEAD
a7a5			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a7a5					if DEBUG_FORTH_WORDS_KEY 
a7a5						DMARK "FRE" 
a7a5 f5				push af  
a7a6 3a ba a7			ld a, (.dmark)  
a7a9 32 b7 ee			ld (debug_mark),a  
a7ac 3a bb a7			ld a, (.dmark+1)  
a7af 32 b8 ee			ld (debug_mark+1),a  
a7b2 3a bc a7			ld a, (.dmark+2)  
a7b5 32 b9 ee			ld (debug_mark+2),a  
a7b8 18 03			jr .pastdmark  
a7ba ..			.dmark: db "FRE"  
a7bd f1			.pastdmark: pop af  
a7be			endm  
# End of macro DMARK
a7be						CALLMONITOR 
a7be cd a3 94			call break_point_state  
a7c1				endm  
# End of macro CALLMONITOR
a7c1					endif 
a7c1					; get address 
a7c1			 
a7c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7c1 cd 0b 9d			call macro_dsp_valuehl 
a7c4				endm 
# End of macro FORTH_DSP_VALUEHL
a7c4			 
a7c4			;		push hl 
a7c4			 
a7c4					; destroy value TOS 
a7c4			 
a7c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7c4 cd c3 9d			call macro_forth_dsp_pop 
a7c7				endm 
# End of macro FORTH_DSP_POP
a7c7			 
a7c7			;		pop hl 
a7c7			if FORTH_ENABLE_MALLOCFREE 
a7c7 cd 33 92				call free 
a7ca			endif 
a7ca					NEXTW 
a7ca c3 82 9e			jp macro_next 
a7cd				endm 
# End of macro NEXTW
a7cd			.LIST: 
a7cd				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a7cd 5c				db WORD_SYS_CORE+72             
a7ce bb a9			dw .FORGET            
a7d0 05				db 4 + 1 
a7d1 .. 00			db "LIST",0              
a7d6				endm 
# End of macro CWHEAD
a7d6			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a7d6			; | | The quoted word must be in upper case. 
a7d6				if DEBUG_FORTH_WORDS_KEY 
a7d6					DMARK "LST" 
a7d6 f5				push af  
a7d7 3a eb a7			ld a, (.dmark)  
a7da 32 b7 ee			ld (debug_mark),a  
a7dd 3a ec a7			ld a, (.dmark+1)  
a7e0 32 b8 ee			ld (debug_mark+1),a  
a7e3 3a ed a7			ld a, (.dmark+2)  
a7e6 32 b9 ee			ld (debug_mark+2),a  
a7e9 18 03			jr .pastdmark  
a7eb ..			.dmark: db "LST"  
a7ee f1			.pastdmark: pop af  
a7ef			endm  
# End of macro DMARK
a7ef					CALLMONITOR 
a7ef cd a3 94			call break_point_state  
a7f2				endm  
# End of macro CALLMONITOR
a7f2				endif 
a7f2			 
a7f2					FORTH_DSP_VALUEHL 
a7f2 cd 0b 9d			call macro_dsp_valuehl 
a7f5				endm 
# End of macro FORTH_DSP_VALUEHL
a7f5			 
a7f5 e5					push hl 
a7f6					FORTH_DSP_POP 
a7f6 cd c3 9d			call macro_forth_dsp_pop 
a7f9				endm 
# End of macro FORTH_DSP_POP
a7f9 c1					pop bc 
a7fa			 
a7fa			; Start format of scratch string 
a7fa			 
a7fa 21 85 e4				ld hl, scratch 
a7fd			 
a7fd 3e 3a				ld a, ':' 
a7ff 77					ld (hl),a 
a800 23					inc hl 
a801 3e 20				ld a, ' ' 
a803 77					ld (hl), a 
a804			 
a804					; Get ptr to the word we need to look up 
a804			 
a804			;		FORTH_DSP_VALUEHL 
a804					;v5 FORTH_DSP_VALUE 
a804				; TODO type check 
a804			;		inc hl    ; Skip type check  
a804			;		push hl 
a804			;		ex de, hl    ; put into DE 
a804			 
a804			 
a804 21 4e db				ld hl, baseram 
a807					;ld hl, baseusermem 
a807			 
a807 e5			push hl   ; sacreifical push 
a808			 
a808			.ldouscanm: 
a808 e1				pop hl 
a809			.ldouscan: 
a809				if DEBUG_FORTH_WORDS 
a809					DMARK "LSs" 
a809 f5				push af  
a80a 3a 1e a8			ld a, (.dmark)  
a80d 32 b7 ee			ld (debug_mark),a  
a810 3a 1f a8			ld a, (.dmark+1)  
a813 32 b8 ee			ld (debug_mark+1),a  
a816 3a 20 a8			ld a, (.dmark+2)  
a819 32 b9 ee			ld (debug_mark+2),a  
a81c 18 03			jr .pastdmark  
a81e ..			.dmark: db "LSs"  
a821 f1			.pastdmark: pop af  
a822			endm  
# End of macro DMARK
a822					CALLMONITOR 
a822 cd a3 94			call break_point_state  
a825				endm  
# End of macro CALLMONITOR
a825				endif 
a825				; skip dict stub 
a825 cd d3 9f				call forth_tok_next 
a828			 
a828			 
a828			; while we have words to look for 
a828			 
a828 7e				ld a, (hl)      
a829				if DEBUG_FORTH_WORDS 
a829					DMARK "LSk" 
a829 f5				push af  
a82a 3a 3e a8			ld a, (.dmark)  
a82d 32 b7 ee			ld (debug_mark),a  
a830 3a 3f a8			ld a, (.dmark+1)  
a833 32 b8 ee			ld (debug_mark+1),a  
a836 3a 40 a8			ld a, (.dmark+2)  
a839 32 b9 ee			ld (debug_mark+2),a  
a83c 18 03			jr .pastdmark  
a83e ..			.dmark: db "LSk"  
a841 f1			.pastdmark: pop af  
a842			endm  
# End of macro DMARK
a842					CALLMONITOR 
a842 cd a3 94			call break_point_state  
a845				endm  
# End of macro CALLMONITOR
a845				endif 
a845					;cp WORD_SYS_END 
a845					;jp z, .lunotfound 
a845			 
a845					; if we hit non uwords then gone too far 
a845 fe 01				cp WORD_SYS_UWORD 
a847 c2 77 a9				jp nz, .lunotfound 
a84a			 
a84a				if DEBUG_FORTH_WORDS 
a84a					DMARK "LSu" 
a84a f5				push af  
a84b 3a 5f a8			ld a, (.dmark)  
a84e 32 b7 ee			ld (debug_mark),a  
a851 3a 60 a8			ld a, (.dmark+1)  
a854 32 b8 ee			ld (debug_mark+1),a  
a857 3a 61 a8			ld a, (.dmark+2)  
a85a 32 b9 ee			ld (debug_mark+2),a  
a85d 18 03			jr .pastdmark  
a85f ..			.dmark: db "LSu"  
a862 f1			.pastdmark: pop af  
a863			endm  
# End of macro DMARK
a863					CALLMONITOR 
a863 cd a3 94			call break_point_state  
a866				endm  
# End of macro CALLMONITOR
a866				endif 
a866			 
a866					; found a uword but is it the one we want... 
a866			 
a866 c5					push bc     ; uword to find is on bc 
a867 d1					pop de 
a868			 
a868 e5					push hl  ; to save the ptr 
a869			 
a869					; skip opcode 
a869 23					inc hl  
a86a					; skip next ptr 
a86a 23					inc hl  
a86b 23					inc hl 
a86c					; skip len 
a86c 23					inc hl 
a86d			 
a86d				if DEBUG_FORTH_WORDS 
a86d					DMARK "LSc" 
a86d f5				push af  
a86e 3a 82 a8			ld a, (.dmark)  
a871 32 b7 ee			ld (debug_mark),a  
a874 3a 83 a8			ld a, (.dmark+1)  
a877 32 b8 ee			ld (debug_mark+1),a  
a87a 3a 84 a8			ld a, (.dmark+2)  
a87d 32 b9 ee			ld (debug_mark+2),a  
a880 18 03			jr .pastdmark  
a882 ..			.dmark: db "LSc"  
a885 f1			.pastdmark: pop af  
a886			endm  
# End of macro DMARK
a886					CALLMONITOR 
a886 cd a3 94			call break_point_state  
a889				endm  
# End of macro CALLMONITOR
a889				endif 
a889 cd 38 91				call strcmp 
a88c c2 08 a8				jp nz, .ldouscanm 
a88f				 
a88f			 
a88f			 
a88f					; we have a uword so push its name to the stack 
a88f			 
a88f			;	   	push hl  ; save so we can move to next dict block 
a88f e1			pop hl 
a890			 
a890				if DEBUG_FORTH_WORDS 
a890					DMARK "LSm" 
a890 f5				push af  
a891 3a a5 a8			ld a, (.dmark)  
a894 32 b7 ee			ld (debug_mark),a  
a897 3a a6 a8			ld a, (.dmark+1)  
a89a 32 b8 ee			ld (debug_mark+1),a  
a89d 3a a7 a8			ld a, (.dmark+2)  
a8a0 32 b9 ee			ld (debug_mark+2),a  
a8a3 18 03			jr .pastdmark  
a8a5 ..			.dmark: db "LSm"  
a8a8 f1			.pastdmark: pop af  
a8a9			endm  
# End of macro DMARK
a8a9					CALLMONITOR 
a8a9 cd a3 94			call break_point_state  
a8ac				endm  
# End of macro CALLMONITOR
a8ac				endif 
a8ac			 
a8ac					; skip opcode 
a8ac 23					inc hl  
a8ad					; skip next ptr 
a8ad 23					inc hl  
a8ae 23					inc hl 
a8af					; skip len 
a8af 7e					ld a, (hl)   ; save length to add 
a8b0				if DEBUG_FORTH_WORDS 
a8b0					DMARK "LS2" 
a8b0 f5				push af  
a8b1 3a c5 a8			ld a, (.dmark)  
a8b4 32 b7 ee			ld (debug_mark),a  
a8b7 3a c6 a8			ld a, (.dmark+1)  
a8ba 32 b8 ee			ld (debug_mark+1),a  
a8bd 3a c7 a8			ld a, (.dmark+2)  
a8c0 32 b9 ee			ld (debug_mark+2),a  
a8c3 18 03			jr .pastdmark  
a8c5 ..			.dmark: db "LS2"  
a8c8 f1			.pastdmark: pop af  
a8c9			endm  
# End of macro DMARK
a8c9					CALLMONITOR 
a8c9 cd a3 94			call break_point_state  
a8cc				endm  
# End of macro CALLMONITOR
a8cc				endif 
a8cc			 
a8cc					; save this location 
a8cc				 
a8cc e5					push hl 
a8cd			 
a8cd 23					inc hl 
a8ce 11 87 e4				ld de, scratch+2 
a8d1 4f					ld c, a 
a8d2 06 00				ld b, 0 
a8d4			 
a8d4				if DEBUG_FORTH_WORDS 
a8d4					DMARK "LSn" 
a8d4 f5				push af  
a8d5 3a e9 a8			ld a, (.dmark)  
a8d8 32 b7 ee			ld (debug_mark),a  
a8db 3a ea a8			ld a, (.dmark+1)  
a8de 32 b8 ee			ld (debug_mark+1),a  
a8e1 3a eb a8			ld a, (.dmark+2)  
a8e4 32 b9 ee			ld (debug_mark+2),a  
a8e7 18 03			jr .pastdmark  
a8e9 ..			.dmark: db "LSn"  
a8ec f1			.pastdmark: pop af  
a8ed			endm  
# End of macro DMARK
a8ed					CALLMONITOR 
a8ed cd a3 94			call break_point_state  
a8f0				endm  
# End of macro CALLMONITOR
a8f0				endif 
a8f0			 
a8f0					; copy uword name to scratch 
a8f0			 
a8f0 ed b0				ldir 
a8f2			 
a8f2 1b					dec de 
a8f3 3e 20				ld a, ' '    ; change null to space 
a8f5 12					ld (de), a 
a8f6			 
a8f6 13					inc de 
a8f7			 
a8f7 d5					push de 
a8f8 c1					pop bc     ; move scratch pointer to end of word name and save it 
a8f9			 
a8f9 e1					pop hl 
a8fa 7e					ld a, (hl) 
a8fb					;inc hl 
a8fb					; skip word string 
a8fb cd a2 8c				call addatohl 
a8fe			 
a8fe 23					inc hl 
a8ff			 
a8ff				if DEBUG_FORTH_WORDS 
a8ff					DMARK "LS3" 
a8ff f5				push af  
a900 3a 14 a9			ld a, (.dmark)  
a903 32 b7 ee			ld (debug_mark),a  
a906 3a 15 a9			ld a, (.dmark+1)  
a909 32 b8 ee			ld (debug_mark+1),a  
a90c 3a 16 a9			ld a, (.dmark+2)  
a90f 32 b9 ee			ld (debug_mark+2),a  
a912 18 03			jr .pastdmark  
a914 ..			.dmark: db "LS3"  
a917 f1			.pastdmark: pop af  
a918			endm  
# End of macro DMARK
a918					CALLMONITOR 
a918 cd a3 94			call break_point_state  
a91b				endm  
# End of macro CALLMONITOR
a91b				endif 
a91b					; should now be at the start of the machine code to setup the eval of the uword 
a91b					; now locate the ptr to the string defintion 
a91b			 
a91b					; skip ld hl, 
a91b					; then load the ptr 
a91b			; TODO use get from hl ptr 
a91b 23					inc hl 
a91c 5e					ld e, (hl) 
a91d 23					inc hl 
a91e 56					ld d, (hl) 
a91f eb					ex de, hl 
a920			 
a920			 
a920				if DEBUG_FORTH_WORDS 
a920					DMARK "LSt" 
a920 f5				push af  
a921 3a 35 a9			ld a, (.dmark)  
a924 32 b7 ee			ld (debug_mark),a  
a927 3a 36 a9			ld a, (.dmark+1)  
a92a 32 b8 ee			ld (debug_mark+1),a  
a92d 3a 37 a9			ld a, (.dmark+2)  
a930 32 b9 ee			ld (debug_mark+2),a  
a933 18 03			jr .pastdmark  
a935 ..			.dmark: db "LSt"  
a938 f1			.pastdmark: pop af  
a939			endm  
# End of macro DMARK
a939					CALLMONITOR 
a939 cd a3 94			call break_point_state  
a93c				endm  
# End of macro CALLMONITOR
a93c				endif 
a93c			 
a93c			; cant push right now due to tokenised strings  
a93c			 
a93c			; get the destination of where to copy this definition to. 
a93c			 
a93c c5					push bc 
a93d d1					pop de 
a93e			 
a93e 7e			.listl:         ld a,(hl) 
a93f fe 00				cp 0 
a941 28 09				jr z, .lreplsp     ; replace zero with space 
a943					;cp FORTH_END_BUFFER 
a943 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a945 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a947				 
a947					; just copy this char as is then 
a947			 
a947 12					ld (de), a 
a948			 
a948 23			.listnxt:	inc hl 
a949 13					inc de 
a94a 18 f2				jr .listl 
a94c			 
a94c 3e 20		.lreplsp:	ld a,' ' 
a94e 12					ld (de), a 
a94f 18 f7				jr .listnxt 
a951			 
a951			; close up uword def 
a951			 
a951			.listdone: 
a951 12					ld (de), a 
a952 13					inc de 
a953 3e 00				ld a, 0 
a955 12					ld (de), a 
a956			 
a956			; now have def so clean up and push to stack 
a956			 
a956 21 85 e4				ld hl, scratch 
a959				if DEBUG_FORTH_WORDS 
a959					DMARK "Ltp" 
a959 f5				push af  
a95a 3a 6e a9			ld a, (.dmark)  
a95d 32 b7 ee			ld (debug_mark),a  
a960 3a 6f a9			ld a, (.dmark+1)  
a963 32 b8 ee			ld (debug_mark+1),a  
a966 3a 70 a9			ld a, (.dmark+2)  
a969 32 b9 ee			ld (debug_mark+2),a  
a96c 18 03			jr .pastdmark  
a96e ..			.dmark: db "Ltp"  
a971 f1			.pastdmark: pop af  
a972			endm  
# End of macro DMARK
a972					CALLMONITOR 
a972 cd a3 94			call break_point_state  
a975				endm  
# End of macro CALLMONITOR
a975				endif 
a975			 
a975 18 1f			jr .listpush 
a977			 
a977			;.lnuword:	pop hl 
a977			;		call forth_tok_next 
a977			;		jp .ldouscan  
a977			 
a977			.lunotfound:		  
a977			 
a977				if DEBUG_FORTH_WORDS 
a977					DMARK "LSn" 
a977 f5				push af  
a978 3a 8c a9			ld a, (.dmark)  
a97b 32 b7 ee			ld (debug_mark),a  
a97e 3a 8d a9			ld a, (.dmark+1)  
a981 32 b8 ee			ld (debug_mark+1),a  
a984 3a 8e a9			ld a, (.dmark+2)  
a987 32 b9 ee			ld (debug_mark+2),a  
a98a 18 03			jr .pastdmark  
a98c ..			.dmark: db "LSn"  
a98f f1			.pastdmark: pop af  
a990			endm  
# End of macro DMARK
a990					CALLMONITOR 
a990 cd a3 94			call break_point_state  
a993				endm  
# End of macro CALLMONITOR
a993				endif 
a993			 
a993					 
a993			;		FORTH_DSP_POP 
a993			;		ld hl, .luno 
a993			 
a993					NEXTW			 
a993 c3 82 9e			jp macro_next 
a996				endm 
# End of macro NEXTW
a996			 
a996			.listpush: 
a996				if DEBUG_FORTH_WORDS 
a996					DMARK "LS>" 
a996 f5				push af  
a997 3a ab a9			ld a, (.dmark)  
a99a 32 b7 ee			ld (debug_mark),a  
a99d 3a ac a9			ld a, (.dmark+1)  
a9a0 32 b8 ee			ld (debug_mark+1),a  
a9a3 3a ad a9			ld a, (.dmark+2)  
a9a6 32 b9 ee			ld (debug_mark+2),a  
a9a9 18 03			jr .pastdmark  
a9ab ..			.dmark: db "LS>"  
a9ae f1			.pastdmark: pop af  
a9af			endm  
# End of macro DMARK
a9af					CALLMONITOR 
a9af cd a3 94			call break_point_state  
a9b2				endm  
# End of macro CALLMONITOR
a9b2				endif 
a9b2 cd 82 9b				call forth_push_str 
a9b5			 
a9b5			 
a9b5			 
a9b5					NEXTW 
a9b5 c3 82 9e			jp macro_next 
a9b8				endm 
# End of macro NEXTW
a9b8			 
a9b8			;.luno:    db "Word not found",0 
a9b8			 
a9b8			 
a9b8			 
a9b8			 
a9b8			 
a9b8			;		push hl   ; save pointer to start of uword def string 
a9b8			; 
a9b8			;; look for FORTH_EOL_LINE 
a9b8			;		ld a, FORTH_END_BUFFER 
a9b8			;		call strlent 
a9b8			; 
a9b8			;		inc hl		 ; space for coln def 
a9b8			;		inc hl 
a9b8			;		inc hl          ; space for terms 
a9b8			;		inc hl 
a9b8			; 
a9b8			;		ld a, 20   ; TODO get actual length 
a9b8			;		call addatohl    ; include a random amount of room for the uword name 
a9b8			; 
a9b8			;		 
a9b8			;	if DEBUG_FORTH_WORDS 
a9b8			;		DMARK "Lt1" 
a9b8			;		CALLMONITOR 
a9b8			;	endif 
a9b8			;		 
a9b8			; 
a9b8			;; malloc space for the string because we cant change it 
a9b8			; 
a9b8			;		call malloc 
a9b8			;	if DEBUG_FORTH_MALLOC_GUARD 
a9b8			;		push af 
a9b8			;		call ishlzero 
a9b8			;		pop af 
a9b8			;		 
a9b8			;		call z,malloc_error 
a9b8			;	endif 
a9b8			; 
a9b8			;	if DEBUG_FORTH_WORDS 
a9b8			;		DMARK "Lt2" 
a9b8			;		CALLMONITOR 
a9b8			;	endif 
a9b8			;		pop de 
a9b8			;		push hl    ; push the malloc to release later 
a9b8			;		push hl   ;  push back a copy for the later stack push 
a9b8			;		 
a9b8			;; copy the string swapping out the zero terms for spaces 
a9b8			; 
a9b8			;		; de has our source 
a9b8			;		; hl has our dest 
a9b8			; 
a9b8			;; add the coln def 
a9b8			; 
a9b8			;		ld a, ':' 
a9b8			;		ld (hl), a 
a9b8			;		inc hl 
a9b8			;		ld a, ' ' 
a9b8			;		ld (hl), a 
a9b8			;		inc hl 
a9b8			; 
a9b8			;; add the uname word 
a9b8			;		push de   ; save our string for now 
a9b8			;		ex de, hl 
a9b8			; 
a9b8			;		FORTH_DSP_VALUE 
a9b8			;		;v5 FORTH_DSP_VALUE 
a9b8			; 
a9b8			;		inc hl   ; skip type but we know by now this is OK 
a9b8			; 
a9b8			;.luword:	ld a,(hl) 
a9b8			;		cp 0 
a9b8			;		jr z, .luword2 
a9b8			;		ld (de), a 
a9b8			;		inc de 
a9b8			;		inc hl 
a9b8			;		jr .luword 
a9b8			; 
a9b8			;.luword2:	ld a, ' ' 
a9b8			;		ld (de), a 
a9b8			;;		inc hl 
a9b8			;;		inc de 
a9b8			;;		ld (de), a 
a9b8			;;		inc hl 
a9b8			;		inc de 
a9b8			; 
a9b8			;		ex de, hl 
a9b8			;		pop de 
a9b8			;		 
a9b8			;		 
a9b8			; 
a9b8			;; detoken that string and copy it 
a9b8			; 
a9b8			;	if DEBUG_FORTH_WORDS 
a9b8			;		DMARK "Lt2" 
a9b8			;		CALLMONITOR 
a9b8			;	endif 
a9b8			;.ldetok:	ld a, (de) 
a9b8			;		cp FORTH_END_BUFFER 
a9b8			;		jr z, .ldetokend 
a9b8			;		; swap out any zero term for space 
a9b8			;		cp 0 
a9b8			;		jr nz, .ldetoknext 
a9b8			;		ld a, ' ' 
a9b8			; 
a9b8			;	if DEBUG_FORTH_WORDS 
a9b8			;		DMARK "LtS" 
a9b8			;		CALLMONITOR 
a9b8			;	endif 
a9b8			;.ldetoknext:	ld (hl), a 
a9b8			;		inc de 
a9b8			;		inc hl 
a9b8			;		jr .ldetok 
a9b8			; 
a9b8			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a9b8			;		ld (hl), a  
a9b8			; 
a9b8			;; free that temp malloc 
a9b8			; 
a9b8			;		pop hl    
a9b8			; 
a9b8			;	if DEBUG_FORTH_WORDS 
a9b8			;		DMARK "Lt4" 
a9b8			;		CALLMONITOR 
a9b8			;	endif 
a9b8			;		call forth_apushstrhl 
a9b8			; 
a9b8			;		; get rid of temp malloc area 
a9b8			; 
a9b8			;		pop hl 
a9b8			;		call free 
a9b8			; 
a9b8			;		jr .ludone 
a9b8			; 
a9b8			;.lnuword:	pop hl 
a9b8			;		call forth_tok_next 
a9b8			;		jp .ldouscan  
a9b8			; 
a9b8			;.ludone:		 pop hl 
a9b8			; 
a9b8					NEXTW 
a9b8 c3 82 9e			jp macro_next 
a9bb				endm 
# End of macro NEXTW
a9bb			 
a9bb			.FORGET: 
a9bb				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a9bb 5d				db WORD_SYS_CORE+73             
a9bc 34 aa			dw .NOP            
a9be 07				db 6 + 1 
a9bf .. 00			db "FORGET",0              
a9c6				endm 
# End of macro CWHEAD
a9c6			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a9c6			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a9c6			; | |  
a9c6			; | | e.g. "MORE" forget 
a9c6					if DEBUG_FORTH_WORDS_KEY 
a9c6						DMARK "FRG" 
a9c6 f5				push af  
a9c7 3a db a9			ld a, (.dmark)  
a9ca 32 b7 ee			ld (debug_mark),a  
a9cd 3a dc a9			ld a, (.dmark+1)  
a9d0 32 b8 ee			ld (debug_mark+1),a  
a9d3 3a dd a9			ld a, (.dmark+2)  
a9d6 32 b9 ee			ld (debug_mark+2),a  
a9d9 18 03			jr .pastdmark  
a9db ..			.dmark: db "FRG"  
a9de f1			.pastdmark: pop af  
a9df			endm  
# End of macro DMARK
a9df						CALLMONITOR 
a9df cd a3 94			call break_point_state  
a9e2				endm  
# End of macro CALLMONITOR
a9e2					endif 
a9e2			 
a9e2				; find uword 
a9e2			        ; update start of word with "_" 
a9e2				; replace uword with deleted flag 
a9e2			 
a9e2			 
a9e2			;	if DEBUG_FORTH_WORDS 
a9e2			;		DMARK "FOG" 
a9e2			;		CALLMONITOR 
a9e2			;	endif 
a9e2			 
a9e2			 
a9e2					; Get ptr to the word we need to look up 
a9e2			 
a9e2					FORTH_DSP_VALUEHL 
a9e2 cd 0b 9d			call macro_dsp_valuehl 
a9e5				endm 
# End of macro FORTH_DSP_VALUEHL
a9e5					;v5 FORTH_DSP_VALUE 
a9e5				; TODO type check 
a9e5			;		inc hl    ; Skip type check  
a9e5 e5					push hl 
a9e6 c1					pop bc 
a9e7			;		ex de, hl    ; put into DE 
a9e7			 
a9e7			 
a9e7 21 4e db				ld hl, baseram 
a9ea					;ld hl, baseusermem 
a9ea			 
a9ea				; skip dict stub 
a9ea			;	call forth_tok_next 
a9ea e5			push hl   ; sacreifical push 
a9eb			 
a9eb			.fldouscanm: 
a9eb e1				pop hl 
a9ec			.fldouscan: 
a9ec			;	if DEBUG_FORTH_WORDS 
a9ec			;		DMARK "LSs" 
a9ec			;		CALLMONITOR 
a9ec			;	endif 
a9ec				; skip dict stub 
a9ec cd d3 9f				call forth_tok_next 
a9ef			 
a9ef			 
a9ef			; while we have words to look for 
a9ef			 
a9ef 7e				ld a, (hl)      
a9f0			;	if DEBUG_FORTH_WORDS 
a9f0			;		DMARK "LSk" 
a9f0			;		CALLMONITOR 
a9f0			;	endif 
a9f0 fe 00				cp WORD_SYS_END 
a9f2 ca 2e aa				jp z, .flunotfound 
a9f5 fe 01				cp WORD_SYS_UWORD 
a9f7 c2 ec a9				jp nz, .fldouscan 
a9fa			 
a9fa			;	if DEBUG_FORTH_WORDS 
a9fa			;		DMARK "LSu" 
a9fa			;		CALLMONITOR 
a9fa			;	endif 
a9fa			 
a9fa					; found a uword but is it the one we want... 
a9fa			 
a9fa c5					push bc     ; uword to find is on bc 
a9fb d1					pop de 
a9fc			 
a9fc e5					push hl  ; to save the ptr 
a9fd			 
a9fd					; skip opcode 
a9fd 23					inc hl  
a9fe					; skip next ptr 
a9fe 23					inc hl  
a9ff 23					inc hl 
aa00					; skip len 
aa00 23					inc hl 
aa01			 
aa01			;	if DEBUG_FORTH_WORDS 
aa01			;		DMARK "LSc" 
aa01			;		CALLMONITOR 
aa01			;	endif 
aa01 cd 38 91				call strcmp 
aa04 c2 eb a9				jp nz, .fldouscanm 
aa07			; 
aa07			; 
aa07			;; while we have words to look for 
aa07			; 
aa07			;.fdouscan:	ld a, (hl)      
aa07			;	if DEBUG_FORTH_WORDS 
aa07			;		DMARK "LSs" 
aa07			;		CALLMONITOR 
aa07			;	endif 
aa07			;		cp WORD_SYS_END 
aa07			;		jp z, .fudone 
aa07			;		cp WORD_SYS_UWORD 
aa07			;		jp nz, .fnuword 
aa07			; 
aa07			;	if DEBUG_FORTH_WORDS 
aa07			;		DMARK "FGu" 
aa07			;		CALLMONITOR 
aa07			;	endif 
aa07			; 
aa07			;		; found a uword but is it the one we want... 
aa07			; 
aa07			; 
aa07			;	        pop de   ; get back the dsp name 
aa07			;		push de 
aa07			; 
aa07			;		push hl  ; to save the ptr 
aa07			; 
aa07			;		; skip opcode 
aa07			;		inc hl  
aa07			;		; skip next ptr 
aa07			;		inc hl  
aa07			;		inc hl 
aa07			;		; skip len 
aa07			;		inc hl 
aa07			; 
aa07			;	if DEBUG_FORTH_WORDS 
aa07			;		DMARK "FGc" 
aa07			;		CALLMONITOR 
aa07			;	endif 
aa07			;		call strcmp 
aa07			;		jp nz, .fnuword 
aa07			 
aa07			 
aa07 e1			pop hl 
aa08			 
aa08				 
aa08				if DEBUG_FORTH_WORDS 
aa08					DMARK "FGm" 
aa08 f5				push af  
aa09 3a 1d aa			ld a, (.dmark)  
aa0c 32 b7 ee			ld (debug_mark),a  
aa0f 3a 1e aa			ld a, (.dmark+1)  
aa12 32 b8 ee			ld (debug_mark+1),a  
aa15 3a 1f aa			ld a, (.dmark+2)  
aa18 32 b9 ee			ld (debug_mark+2),a  
aa1b 18 03			jr .pastdmark  
aa1d ..			.dmark: db "FGm"  
aa20 f1			.pastdmark: pop af  
aa21			endm  
# End of macro DMARK
aa21					CALLMONITOR 
aa21 cd a3 94			call break_point_state  
aa24				endm  
# End of macro CALLMONITOR
aa24				endif 
aa24			 
aa24			 
aa24			 
aa24					; we have a uword so push its name to the stack 
aa24			 
aa24			;	   	push hl  ; save so we can move to next dict block 
aa24			;pop hl 
aa24			 
aa24					; update opcode to deleted 
aa24 3e 03				ld a, WORD_SYS_DELETED 
aa26 77					ld (hl), a 
aa27			 
aa27 23					inc hl  
aa28					; skip next ptr 
aa28 23					inc hl  
aa29 23					inc hl 
aa2a					; skip len 
aa2a 23					inc hl 
aa2b			 
aa2b					; TODO change parser to skip deleted words but for now mark it out 
aa2b 3e 5f				ld a, "_" 
aa2d 77					ld  (hl),a 
aa2e			 
aa2e			;		jr .fudone 
aa2e			; 
aa2e			;.fnuword:	pop hl 
aa2e			;		call forth_tok_next 
aa2e			;		jp .fdouscan  
aa2e			 
aa2e			.flunotfound:		  
aa2e			 
aa2e			 
aa2e					 
aa2e					FORTH_DSP_POP 
aa2e cd c3 9d			call macro_forth_dsp_pop 
aa31				endm 
# End of macro FORTH_DSP_POP
aa31			;		ld hl, .luno 
aa31			;.fudone:		 pop hl 
aa31					NEXTW 
aa31 c3 82 9e			jp macro_next 
aa34				endm 
# End of macro NEXTW
aa34			.NOP: 
aa34				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aa34 61				db WORD_SYS_CORE+77             
aa35 5b aa			dw .COMO            
aa37 04				db 3 + 1 
aa38 .. 00			db "NOP",0              
aa3c				endm 
# End of macro CWHEAD
aa3c			; | NOP (  --  ) Do nothing | DONE 
aa3c					if DEBUG_FORTH_WORDS_KEY 
aa3c						DMARK "NOP" 
aa3c f5				push af  
aa3d 3a 51 aa			ld a, (.dmark)  
aa40 32 b7 ee			ld (debug_mark),a  
aa43 3a 52 aa			ld a, (.dmark+1)  
aa46 32 b8 ee			ld (debug_mark+1),a  
aa49 3a 53 aa			ld a, (.dmark+2)  
aa4c 32 b9 ee			ld (debug_mark+2),a  
aa4f 18 03			jr .pastdmark  
aa51 ..			.dmark: db "NOP"  
aa54 f1			.pastdmark: pop af  
aa55			endm  
# End of macro DMARK
aa55						CALLMONITOR 
aa55 cd a3 94			call break_point_state  
aa58				endm  
# End of macro CALLMONITOR
aa58					endif 
aa58				       NEXTW 
aa58 c3 82 9e			jp macro_next 
aa5b				endm 
# End of macro NEXTW
aa5b			.COMO: 
aa5b				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aa5b 6e				db WORD_SYS_CORE+90             
aa5c ad aa			dw .COMC            
aa5e 02				db 1 + 1 
aa5f .. 00			db "(",0              
aa61				endm 
# End of macro CWHEAD
aa61			; | ( ( -- )  Start of comment | DONE 
aa61			 
aa61			 
aa61 2a 86 e7				ld hl, ( os_tok_ptr) 
aa64 11 a8 aa			ld de, .closepar 
aa67					 
aa67					if DEBUG_FORTH_WORDS 
aa67						DMARK ").." 
aa67 f5				push af  
aa68 3a 7c aa			ld a, (.dmark)  
aa6b 32 b7 ee			ld (debug_mark),a  
aa6e 3a 7d aa			ld a, (.dmark+1)  
aa71 32 b8 ee			ld (debug_mark+1),a  
aa74 3a 7e aa			ld a, (.dmark+2)  
aa77 32 b9 ee			ld (debug_mark+2),a  
aa7a 18 03			jr .pastdmark  
aa7c ..			.dmark: db ").."  
aa7f f1			.pastdmark: pop af  
aa80			endm  
# End of macro DMARK
aa80						CALLMONITOR 
aa80 cd a3 94			call break_point_state  
aa83				endm  
# End of macro CALLMONITOR
aa83					endif 
aa83 cd 9d 9f			call findnexttok  
aa86			 
aa86					if DEBUG_FORTH_WORDS 
aa86						DMARK "IF5" 
aa86 f5				push af  
aa87 3a 9b aa			ld a, (.dmark)  
aa8a 32 b7 ee			ld (debug_mark),a  
aa8d 3a 9c aa			ld a, (.dmark+1)  
aa90 32 b8 ee			ld (debug_mark+1),a  
aa93 3a 9d aa			ld a, (.dmark+2)  
aa96 32 b9 ee			ld (debug_mark+2),a  
aa99 18 03			jr .pastdmark  
aa9b ..			.dmark: db "IF5"  
aa9e f1			.pastdmark: pop af  
aa9f			endm  
# End of macro DMARK
aa9f						CALLMONITOR 
aa9f cd a3 94			call break_point_state  
aaa2				endm  
# End of macro CALLMONITOR
aaa2					endif 
aaa2				; replace below with ) exec using tok_ptr 
aaa2 22 86 e7			ld (os_tok_ptr), hl 
aaa5 c3 13 9f			jp exec1 
aaa8			 
aaa8 .. 00			.closepar:   db ")",0 
aaaa			 
aaaa				       NEXTW 
aaaa c3 82 9e			jp macro_next 
aaad				endm 
# End of macro NEXTW
aaad			.COMC: 
aaad				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
aaad 6f				db WORD_SYS_CORE+91             
aaae b6 aa			dw .SCRATCH            
aab0 02				db 1 + 1 
aab1 .. 00			db ")",0              
aab3				endm 
# End of macro CWHEAD
aab3			; | ) ( -- )  End of comment |  DONE  
aab3				       NEXTW 
aab3 c3 82 9e			jp macro_next 
aab6				endm 
# End of macro NEXTW
aab6			 
aab6			.SCRATCH: 
aab6				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
aab6 6f				db WORD_SYS_CORE+91             
aab7 f1 aa			dw .INC            
aab9 08				db 7 + 1 
aaba .. 00			db "SCRATCH",0              
aac2				endm 
# End of macro CWHEAD
aac2			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
aac2			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
aac2			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
aac2			; | |  
aac2			; | | e.g.    : score $00 scratch ; 
aac2			; | |  
aac2			; | | $00 score ! 
aac2			; | | $01 score +! 
aac2			; | |  
aac2			; | | e.g.   : varword $0a scratch ;  
aac2			; | | 
aac2			; | | $8000 varword ! 
aac2					if DEBUG_FORTH_WORDS_KEY 
aac2						DMARK "SCR" 
aac2 f5				push af  
aac3 3a d7 aa			ld a, (.dmark)  
aac6 32 b7 ee			ld (debug_mark),a  
aac9 3a d8 aa			ld a, (.dmark+1)  
aacc 32 b8 ee			ld (debug_mark+1),a  
aacf 3a d9 aa			ld a, (.dmark+2)  
aad2 32 b9 ee			ld (debug_mark+2),a  
aad5 18 03			jr .pastdmark  
aad7 ..			.dmark: db "SCR"  
aada f1			.pastdmark: pop af  
aadb			endm  
# End of macro DMARK
aadb						CALLMONITOR 
aadb cd a3 94			call break_point_state  
aade				endm  
# End of macro CALLMONITOR
aade					endif 
aade			 
aade					FORTH_DSP_VALUEHL 
aade cd 0b 9d			call macro_dsp_valuehl 
aae1				endm 
# End of macro FORTH_DSP_VALUEHL
aae1				 
aae1					FORTH_DSP_POP 
aae1 cd c3 9d			call macro_forth_dsp_pop 
aae4				endm 
# End of macro FORTH_DSP_POP
aae4			 
aae4 7d					ld a, l 
aae5 21 aa e9				ld hl, os_var_array 
aae8 cd a2 8c				call addatohl 
aaeb			 
aaeb cd 14 9b				call forth_push_numhl 
aaee			 
aaee				       NEXTW 
aaee c3 82 9e			jp macro_next 
aaf1				endm 
# End of macro NEXTW
aaf1			 
aaf1			.INC: 
aaf1				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
aaf1 6f				db WORD_SYS_CORE+91             
aaf2 45 ab			dw .DEC            
aaf4 03				db 2 + 1 
aaf5 .. 00			db "+!",0              
aaf8				endm 
# End of macro CWHEAD
aaf8			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
aaf8					if DEBUG_FORTH_WORDS_KEY 
aaf8						DMARK "+s_" 
aaf8 f5				push af  
aaf9 3a 0d ab			ld a, (.dmark)  
aafc 32 b7 ee			ld (debug_mark),a  
aaff 3a 0e ab			ld a, (.dmark+1)  
ab02 32 b8 ee			ld (debug_mark+1),a  
ab05 3a 0f ab			ld a, (.dmark+2)  
ab08 32 b9 ee			ld (debug_mark+2),a  
ab0b 18 03			jr .pastdmark  
ab0d ..			.dmark: db "+s_"  
ab10 f1			.pastdmark: pop af  
ab11			endm  
# End of macro DMARK
ab11						CALLMONITOR 
ab11 cd a3 94			call break_point_state  
ab14				endm  
# End of macro CALLMONITOR
ab14					endif 
ab14			 
ab14					FORTH_DSP_VALUEHL 
ab14 cd 0b 9d			call macro_dsp_valuehl 
ab17				endm 
# End of macro FORTH_DSP_VALUEHL
ab17			 
ab17 e5					push hl   ; save address 
ab18			 
ab18					FORTH_DSP_POP 
ab18 cd c3 9d			call macro_forth_dsp_pop 
ab1b				endm 
# End of macro FORTH_DSP_POP
ab1b			 
ab1b					FORTH_DSP_VALUEHL 
ab1b cd 0b 9d			call macro_dsp_valuehl 
ab1e				endm 
# End of macro FORTH_DSP_VALUEHL
ab1e			 
ab1e					FORTH_DSP_POP 
ab1e cd c3 9d			call macro_forth_dsp_pop 
ab21				endm 
# End of macro FORTH_DSP_POP
ab21			 
ab21					; hl contains value to add to byte at a 
ab21				 
ab21 eb					ex de, hl 
ab22			 
ab22 e1					pop hl 
ab23			 
ab23					if DEBUG_FORTH_WORDS 
ab23						DMARK "INC" 
ab23 f5				push af  
ab24 3a 38 ab			ld a, (.dmark)  
ab27 32 b7 ee			ld (debug_mark),a  
ab2a 3a 39 ab			ld a, (.dmark+1)  
ab2d 32 b8 ee			ld (debug_mark+1),a  
ab30 3a 3a ab			ld a, (.dmark+2)  
ab33 32 b9 ee			ld (debug_mark+2),a  
ab36 18 03			jr .pastdmark  
ab38 ..			.dmark: db "INC"  
ab3b f1			.pastdmark: pop af  
ab3c			endm  
# End of macro DMARK
ab3c						CALLMONITOR 
ab3c cd a3 94			call break_point_state  
ab3f				endm  
# End of macro CALLMONITOR
ab3f					endif 
ab3f			 
ab3f 7e					ld a,(hl) 
ab40 83					add e 
ab41 77					ld (hl),a 
ab42			 
ab42			 
ab42			 
ab42				       NEXTW 
ab42 c3 82 9e			jp macro_next 
ab45				endm 
# End of macro NEXTW
ab45			 
ab45			.DEC: 
ab45				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
ab45 6f				db WORD_SYS_CORE+91             
ab46 96 ab			dw .INC2            
ab48 03				db 2 + 1 
ab49 .. 00			db "-!",0              
ab4c				endm 
# End of macro CWHEAD
ab4c			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
ab4c					if DEBUG_FORTH_WORDS_KEY 
ab4c						DMARK "-s_" 
ab4c f5				push af  
ab4d 3a 61 ab			ld a, (.dmark)  
ab50 32 b7 ee			ld (debug_mark),a  
ab53 3a 62 ab			ld a, (.dmark+1)  
ab56 32 b8 ee			ld (debug_mark+1),a  
ab59 3a 63 ab			ld a, (.dmark+2)  
ab5c 32 b9 ee			ld (debug_mark+2),a  
ab5f 18 03			jr .pastdmark  
ab61 ..			.dmark: db "-s_"  
ab64 f1			.pastdmark: pop af  
ab65			endm  
# End of macro DMARK
ab65						CALLMONITOR 
ab65 cd a3 94			call break_point_state  
ab68				endm  
# End of macro CALLMONITOR
ab68					endif 
ab68			 
ab68					FORTH_DSP_VALUEHL 
ab68 cd 0b 9d			call macro_dsp_valuehl 
ab6b				endm 
# End of macro FORTH_DSP_VALUEHL
ab6b			 
ab6b e5					push hl   ; save address 
ab6c			 
ab6c					FORTH_DSP_POP 
ab6c cd c3 9d			call macro_forth_dsp_pop 
ab6f				endm 
# End of macro FORTH_DSP_POP
ab6f			 
ab6f					FORTH_DSP_VALUEHL 
ab6f cd 0b 9d			call macro_dsp_valuehl 
ab72				endm 
# End of macro FORTH_DSP_VALUEHL
ab72			 
ab72					; hl contains value to add to byte at a 
ab72				 
ab72 eb					ex de, hl 
ab73			 
ab73 e1					pop hl 
ab74			 
ab74					if DEBUG_FORTH_WORDS 
ab74						DMARK "DEC" 
ab74 f5				push af  
ab75 3a 89 ab			ld a, (.dmark)  
ab78 32 b7 ee			ld (debug_mark),a  
ab7b 3a 8a ab			ld a, (.dmark+1)  
ab7e 32 b8 ee			ld (debug_mark+1),a  
ab81 3a 8b ab			ld a, (.dmark+2)  
ab84 32 b9 ee			ld (debug_mark+2),a  
ab87 18 03			jr .pastdmark  
ab89 ..			.dmark: db "DEC"  
ab8c f1			.pastdmark: pop af  
ab8d			endm  
# End of macro DMARK
ab8d						CALLMONITOR 
ab8d cd a3 94			call break_point_state  
ab90				endm  
# End of macro CALLMONITOR
ab90					endif 
ab90			 
ab90 7e					ld a,(hl) 
ab91 93					sub e 
ab92 77					ld (hl),a 
ab93			 
ab93			 
ab93			 
ab93				       NEXTW 
ab93 c3 82 9e			jp macro_next 
ab96				endm 
# End of macro NEXTW
ab96			 
ab96			.INC2: 
ab96				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ab96 6f				db WORD_SYS_CORE+91             
ab97 40 ac			dw .DEC2            
ab99 04				db 3 + 1 
ab9a .. 00			db "+2!",0              
ab9e				endm 
# End of macro CWHEAD
ab9e			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ab9e			 
ab9e					if DEBUG_FORTH_WORDS_KEY 
ab9e						DMARK "+2s" 
ab9e f5				push af  
ab9f 3a b3 ab			ld a, (.dmark)  
aba2 32 b7 ee			ld (debug_mark),a  
aba5 3a b4 ab			ld a, (.dmark+1)  
aba8 32 b8 ee			ld (debug_mark+1),a  
abab 3a b5 ab			ld a, (.dmark+2)  
abae 32 b9 ee			ld (debug_mark+2),a  
abb1 18 03			jr .pastdmark  
abb3 ..			.dmark: db "+2s"  
abb6 f1			.pastdmark: pop af  
abb7			endm  
# End of macro DMARK
abb7						CALLMONITOR 
abb7 cd a3 94			call break_point_state  
abba				endm  
# End of macro CALLMONITOR
abba					endif 
abba			 
abba					; Address 
abba			 
abba					FORTH_DSP_VALUEHL 
abba cd 0b 9d			call macro_dsp_valuehl 
abbd				endm 
# End of macro FORTH_DSP_VALUEHL
abbd			 
abbd e5					push hl    ; save address 
abbe			 
abbe					; load content into de 
abbe			 
abbe 5e					ld e,(hl) 
abbf 23					inc hl 
abc0 56					ld d, (hl) 
abc1			 
abc1					if DEBUG_FORTH_WORDS 
abc1						DMARK "+2a" 
abc1 f5				push af  
abc2 3a d6 ab			ld a, (.dmark)  
abc5 32 b7 ee			ld (debug_mark),a  
abc8 3a d7 ab			ld a, (.dmark+1)  
abcb 32 b8 ee			ld (debug_mark+1),a  
abce 3a d8 ab			ld a, (.dmark+2)  
abd1 32 b9 ee			ld (debug_mark+2),a  
abd4 18 03			jr .pastdmark  
abd6 ..			.dmark: db "+2a"  
abd9 f1			.pastdmark: pop af  
abda			endm  
# End of macro DMARK
abda						CALLMONITOR 
abda cd a3 94			call break_point_state  
abdd				endm  
# End of macro CALLMONITOR
abdd					endif 
abdd			 
abdd					FORTH_DSP_POP 
abdd cd c3 9d			call macro_forth_dsp_pop 
abe0				endm 
# End of macro FORTH_DSP_POP
abe0			 
abe0					; Get value to add 
abe0			 
abe0					FORTH_DSP_VALUE 
abe0 cd f4 9c			call macro_forth_dsp_value 
abe3				endm 
# End of macro FORTH_DSP_VALUE
abe3			 
abe3					if DEBUG_FORTH_WORDS 
abe3						DMARK "+2v" 
abe3 f5				push af  
abe4 3a f8 ab			ld a, (.dmark)  
abe7 32 b7 ee			ld (debug_mark),a  
abea 3a f9 ab			ld a, (.dmark+1)  
abed 32 b8 ee			ld (debug_mark+1),a  
abf0 3a fa ab			ld a, (.dmark+2)  
abf3 32 b9 ee			ld (debug_mark+2),a  
abf6 18 03			jr .pastdmark  
abf8 ..			.dmark: db "+2v"  
abfb f1			.pastdmark: pop af  
abfc			endm  
# End of macro DMARK
abfc						CALLMONITOR 
abfc cd a3 94			call break_point_state  
abff				endm  
# End of macro CALLMONITOR
abff					endif 
abff			 
abff 19					add hl, de 
ac00			 
ac00					if DEBUG_FORTH_WORDS 
ac00						DMARK "+2+" 
ac00 f5				push af  
ac01 3a 15 ac			ld a, (.dmark)  
ac04 32 b7 ee			ld (debug_mark),a  
ac07 3a 16 ac			ld a, (.dmark+1)  
ac0a 32 b8 ee			ld (debug_mark+1),a  
ac0d 3a 17 ac			ld a, (.dmark+2)  
ac10 32 b9 ee			ld (debug_mark+2),a  
ac13 18 03			jr .pastdmark  
ac15 ..			.dmark: db "+2+"  
ac18 f1			.pastdmark: pop af  
ac19			endm  
# End of macro DMARK
ac19						CALLMONITOR 
ac19 cd a3 94			call break_point_state  
ac1c				endm  
# End of macro CALLMONITOR
ac1c					endif 
ac1c			 
ac1c					; move result to de 
ac1c			 
ac1c eb					ex de, hl 
ac1d			 
ac1d					; Address 
ac1d			 
ac1d e1					pop hl 
ac1e			 
ac1e					; save it back 
ac1e			 
ac1e 73					ld (hl), e 
ac1f 23					inc hl 
ac20 72					ld (hl), d 
ac21			 
ac21					if DEBUG_FORTH_WORDS 
ac21						DMARK "+2e" 
ac21 f5				push af  
ac22 3a 36 ac			ld a, (.dmark)  
ac25 32 b7 ee			ld (debug_mark),a  
ac28 3a 37 ac			ld a, (.dmark+1)  
ac2b 32 b8 ee			ld (debug_mark+1),a  
ac2e 3a 38 ac			ld a, (.dmark+2)  
ac31 32 b9 ee			ld (debug_mark+2),a  
ac34 18 03			jr .pastdmark  
ac36 ..			.dmark: db "+2e"  
ac39 f1			.pastdmark: pop af  
ac3a			endm  
# End of macro DMARK
ac3a						CALLMONITOR 
ac3a cd a3 94			call break_point_state  
ac3d				endm  
# End of macro CALLMONITOR
ac3d					endif 
ac3d			 
ac3d			 
ac3d			 
ac3d			 
ac3d			 
ac3d				       NEXTW 
ac3d c3 82 9e			jp macro_next 
ac40				endm 
# End of macro NEXTW
ac40			 
ac40			.DEC2: 
ac40				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
ac40 6f				db WORD_SYS_CORE+91             
ac41 ec ac			dw .GET2            
ac43 04				db 3 + 1 
ac44 .. 00			db "-2!",0              
ac48				endm 
# End of macro CWHEAD
ac48			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ac48			 
ac48			 
ac48					if DEBUG_FORTH_WORDS_KEY 
ac48						DMARK "-2s" 
ac48 f5				push af  
ac49 3a 5d ac			ld a, (.dmark)  
ac4c 32 b7 ee			ld (debug_mark),a  
ac4f 3a 5e ac			ld a, (.dmark+1)  
ac52 32 b8 ee			ld (debug_mark+1),a  
ac55 3a 5f ac			ld a, (.dmark+2)  
ac58 32 b9 ee			ld (debug_mark+2),a  
ac5b 18 03			jr .pastdmark  
ac5d ..			.dmark: db "-2s"  
ac60 f1			.pastdmark: pop af  
ac61			endm  
# End of macro DMARK
ac61						CALLMONITOR 
ac61 cd a3 94			call break_point_state  
ac64				endm  
# End of macro CALLMONITOR
ac64					endif 
ac64			 
ac64					; Address 
ac64			 
ac64					FORTH_DSP_VALUEHL 
ac64 cd 0b 9d			call macro_dsp_valuehl 
ac67				endm 
# End of macro FORTH_DSP_VALUEHL
ac67			 
ac67 e5					push hl    ; save address 
ac68			 
ac68					; load content into de 
ac68			 
ac68 5e					ld e,(hl) 
ac69 23					inc hl 
ac6a 56					ld d, (hl) 
ac6b			 
ac6b					if DEBUG_FORTH_WORDS 
ac6b						DMARK "-2a" 
ac6b f5				push af  
ac6c 3a 80 ac			ld a, (.dmark)  
ac6f 32 b7 ee			ld (debug_mark),a  
ac72 3a 81 ac			ld a, (.dmark+1)  
ac75 32 b8 ee			ld (debug_mark+1),a  
ac78 3a 82 ac			ld a, (.dmark+2)  
ac7b 32 b9 ee			ld (debug_mark+2),a  
ac7e 18 03			jr .pastdmark  
ac80 ..			.dmark: db "-2a"  
ac83 f1			.pastdmark: pop af  
ac84			endm  
# End of macro DMARK
ac84						CALLMONITOR 
ac84 cd a3 94			call break_point_state  
ac87				endm  
# End of macro CALLMONITOR
ac87					endif 
ac87			 
ac87					FORTH_DSP_POP 
ac87 cd c3 9d			call macro_forth_dsp_pop 
ac8a				endm 
# End of macro FORTH_DSP_POP
ac8a			 
ac8a					; Get value to remove 
ac8a			 
ac8a					FORTH_DSP_VALUE 
ac8a cd f4 9c			call macro_forth_dsp_value 
ac8d				endm 
# End of macro FORTH_DSP_VALUE
ac8d			 
ac8d					if DEBUG_FORTH_WORDS 
ac8d						DMARK "-2v" 
ac8d f5				push af  
ac8e 3a a2 ac			ld a, (.dmark)  
ac91 32 b7 ee			ld (debug_mark),a  
ac94 3a a3 ac			ld a, (.dmark+1)  
ac97 32 b8 ee			ld (debug_mark+1),a  
ac9a 3a a4 ac			ld a, (.dmark+2)  
ac9d 32 b9 ee			ld (debug_mark+2),a  
aca0 18 03			jr .pastdmark  
aca2 ..			.dmark: db "-2v"  
aca5 f1			.pastdmark: pop af  
aca6			endm  
# End of macro DMARK
aca6						CALLMONITOR 
aca6 cd a3 94			call break_point_state  
aca9				endm  
# End of macro CALLMONITOR
aca9					endif 
aca9			 
aca9 eb					ex de, hl 
acaa ed 52				sbc hl, de 
acac			 
acac					if DEBUG_FORTH_WORDS 
acac						DMARK "-2d" 
acac f5				push af  
acad 3a c1 ac			ld a, (.dmark)  
acb0 32 b7 ee			ld (debug_mark),a  
acb3 3a c2 ac			ld a, (.dmark+1)  
acb6 32 b8 ee			ld (debug_mark+1),a  
acb9 3a c3 ac			ld a, (.dmark+2)  
acbc 32 b9 ee			ld (debug_mark+2),a  
acbf 18 03			jr .pastdmark  
acc1 ..			.dmark: db "-2d"  
acc4 f1			.pastdmark: pop af  
acc5			endm  
# End of macro DMARK
acc5						CALLMONITOR 
acc5 cd a3 94			call break_point_state  
acc8				endm  
# End of macro CALLMONITOR
acc8					endif 
acc8			 
acc8					; move result to de 
acc8			 
acc8 eb					ex de, hl 
acc9			 
acc9					; Address 
acc9			 
acc9 e1					pop hl 
acca			 
acca					; save it back 
acca			 
acca 73					ld (hl), e 
accb 23					inc hl 
accc 72					ld (hl), d 
accd			 
accd					if DEBUG_FORTH_WORDS 
accd						DMARK "-2e" 
accd f5				push af  
acce 3a e2 ac			ld a, (.dmark)  
acd1 32 b7 ee			ld (debug_mark),a  
acd4 3a e3 ac			ld a, (.dmark+1)  
acd7 32 b8 ee			ld (debug_mark+1),a  
acda 3a e4 ac			ld a, (.dmark+2)  
acdd 32 b9 ee			ld (debug_mark+2),a  
ace0 18 03			jr .pastdmark  
ace2 ..			.dmark: db "-2e"  
ace5 f1			.pastdmark: pop af  
ace6			endm  
# End of macro DMARK
ace6						CALLMONITOR 
ace6 cd a3 94			call break_point_state  
ace9				endm  
# End of macro CALLMONITOR
ace9					endif 
ace9			 
ace9			 
ace9			 
ace9			 
ace9			 
ace9				       NEXTW 
ace9 c3 82 9e			jp macro_next 
acec				endm 
# End of macro NEXTW
acec			.GET2: 
acec				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
acec 6f				db WORD_SYS_CORE+91             
aced 1c ad			dw .BANG2            
acef 03				db 2 + 1 
acf0 .. 00			db "2@",0              
acf3				endm 
# End of macro CWHEAD
acf3			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
acf3					if DEBUG_FORTH_WORDS_KEY 
acf3						DMARK "2A_" 
acf3 f5				push af  
acf4 3a 08 ad			ld a, (.dmark)  
acf7 32 b7 ee			ld (debug_mark),a  
acfa 3a 09 ad			ld a, (.dmark+1)  
acfd 32 b8 ee			ld (debug_mark+1),a  
ad00 3a 0a ad			ld a, (.dmark+2)  
ad03 32 b9 ee			ld (debug_mark+2),a  
ad06 18 03			jr .pastdmark  
ad08 ..			.dmark: db "2A_"  
ad0b f1			.pastdmark: pop af  
ad0c			endm  
# End of macro DMARK
ad0c						CALLMONITOR 
ad0c cd a3 94			call break_point_state  
ad0f				endm  
# End of macro CALLMONITOR
ad0f					endif 
ad0f			 
ad0f					FORTH_DSP_VALUEHL 
ad0f cd 0b 9d			call macro_dsp_valuehl 
ad12				endm 
# End of macro FORTH_DSP_VALUEHL
ad12			 
ad12 5e					ld e, (hl) 
ad13 23					inc hl 
ad14 56					ld d, (hl) 
ad15			 
ad15 eb					ex de, hl 
ad16			 
ad16 cd 14 9b				call forth_push_numhl 
ad19			 
ad19				       NEXTW 
ad19 c3 82 9e			jp macro_next 
ad1c				endm 
# End of macro NEXTW
ad1c			.BANG2: 
ad1c				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad1c 6f				db WORD_SYS_CORE+91             
ad1d 54 ad			dw .CONFIG            
ad1f 03				db 2 + 1 
ad20 .. 00			db "2!",0              
ad23				endm 
# End of macro CWHEAD
ad23			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad23					if DEBUG_FORTH_WORDS_KEY 
ad23						DMARK "2S_" 
ad23 f5				push af  
ad24 3a 38 ad			ld a, (.dmark)  
ad27 32 b7 ee			ld (debug_mark),a  
ad2a 3a 39 ad			ld a, (.dmark+1)  
ad2d 32 b8 ee			ld (debug_mark+1),a  
ad30 3a 3a ad			ld a, (.dmark+2)  
ad33 32 b9 ee			ld (debug_mark+2),a  
ad36 18 03			jr .pastdmark  
ad38 ..			.dmark: db "2S_"  
ad3b f1			.pastdmark: pop af  
ad3c			endm  
# End of macro DMARK
ad3c						CALLMONITOR 
ad3c cd a3 94			call break_point_state  
ad3f				endm  
# End of macro CALLMONITOR
ad3f					endif 
ad3f			 
ad3f					FORTH_DSP_VALUEHL 
ad3f cd 0b 9d			call macro_dsp_valuehl 
ad42				endm 
# End of macro FORTH_DSP_VALUEHL
ad42			 
ad42 e5					push hl   ; save address 
ad43			 
ad43			 
ad43					FORTH_DSP_POP 
ad43 cd c3 9d			call macro_forth_dsp_pop 
ad46				endm 
# End of macro FORTH_DSP_POP
ad46			 
ad46					 
ad46					FORTH_DSP_VALUEHL 
ad46 cd 0b 9d			call macro_dsp_valuehl 
ad49				endm 
# End of macro FORTH_DSP_VALUEHL
ad49			 
ad49					FORTH_DSP_POP 
ad49 cd c3 9d			call macro_forth_dsp_pop 
ad4c				endm 
# End of macro FORTH_DSP_POP
ad4c			 
ad4c eb					ex de, hl    ; value now in de 
ad4d			 
ad4d e1					pop hl 
ad4e			 
ad4e 73					ld (hl), e 
ad4f			 
ad4f 23					inc hl 
ad50			 
ad50 72					ld (hl), d 
ad51			 
ad51			 
ad51				       NEXTW 
ad51 c3 82 9e			jp macro_next 
ad54				endm 
# End of macro NEXTW
ad54			.CONFIG: 
ad54				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ad54 6f				db WORD_SYS_CORE+91             
ad55 65 ad			dw .ENDCORE            
ad57 07				db 6 + 1 
ad58 .. 00			db "CONFIG",0              
ad5f				endm 
# End of macro CWHEAD
ad5f			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ad5f			 
ad5f cd 02 93				call config 
ad62					NEXTW 
ad62 c3 82 9e			jp macro_next 
ad65				endm 
# End of macro NEXTW
ad65			.ENDCORE: 
ad65			 
ad65			; eof 
ad65			 
ad65			 
# End of file forth_words_core.asm
ad65			include "forth_words_flow.asm" 
ad65			 
ad65			; | ## Program Flow Words 
ad65			 
ad65			.IF: 
ad65				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ad65 1e				db WORD_SYS_CORE+10             
ad66 5a ae			dw .THEN            
ad68 03				db 2 + 1 
ad69 .. 00			db "IF",0              
ad6c				endm 
# End of macro CWHEAD
ad6c			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ad6c			; 
ad6c					if DEBUG_FORTH_WORDS_KEY 
ad6c						DMARK "IF." 
ad6c f5				push af  
ad6d 3a 81 ad			ld a, (.dmark)  
ad70 32 b7 ee			ld (debug_mark),a  
ad73 3a 82 ad			ld a, (.dmark+1)  
ad76 32 b8 ee			ld (debug_mark+1),a  
ad79 3a 83 ad			ld a, (.dmark+2)  
ad7c 32 b9 ee			ld (debug_mark+2),a  
ad7f 18 03			jr .pastdmark  
ad81 ..			.dmark: db "IF."  
ad84 f1			.pastdmark: pop af  
ad85			endm  
# End of macro DMARK
ad85						CALLMONITOR 
ad85 cd a3 94			call break_point_state  
ad88				endm  
# End of macro CALLMONITOR
ad88					endif 
ad88			; eval TOS 
ad88			 
ad88				FORTH_DSP_VALUEHL 
ad88 cd 0b 9d			call macro_dsp_valuehl 
ad8b				endm 
# End of macro FORTH_DSP_VALUEHL
ad8b			 
ad8b			;	push hl 
ad8b				FORTH_DSP_POP 
ad8b cd c3 9d			call macro_forth_dsp_pop 
ad8e				endm 
# End of macro FORTH_DSP_POP
ad8e			;	pop hl 
ad8e			 
ad8e					if DEBUG_FORTH_WORDS 
ad8e						DMARK "IF1" 
ad8e f5				push af  
ad8f 3a a3 ad			ld a, (.dmark)  
ad92 32 b7 ee			ld (debug_mark),a  
ad95 3a a4 ad			ld a, (.dmark+1)  
ad98 32 b8 ee			ld (debug_mark+1),a  
ad9b 3a a5 ad			ld a, (.dmark+2)  
ad9e 32 b9 ee			ld (debug_mark+2),a  
ada1 18 03			jr .pastdmark  
ada3 ..			.dmark: db "IF1"  
ada6 f1			.pastdmark: pop af  
ada7			endm  
# End of macro DMARK
ada7						CALLMONITOR 
ada7 cd a3 94			call break_point_state  
adaa				endm  
# End of macro CALLMONITOR
adaa					endif 
adaa b7				or a        ; clear carry flag 
adab 11 00 00			ld de, 0 
adae eb				ex de,hl 
adaf ed 52			sbc hl, de 
adb1 c2 3b ae			jp nz, .iftrue 
adb4			 
adb4					if DEBUG_FORTH_WORDS 
adb4						DMARK "IF2" 
adb4 f5				push af  
adb5 3a c9 ad			ld a, (.dmark)  
adb8 32 b7 ee			ld (debug_mark),a  
adbb 3a ca ad			ld a, (.dmark+1)  
adbe 32 b8 ee			ld (debug_mark+1),a  
adc1 3a cb ad			ld a, (.dmark+2)  
adc4 32 b9 ee			ld (debug_mark+2),a  
adc7 18 03			jr .pastdmark  
adc9 ..			.dmark: db "IF2"  
adcc f1			.pastdmark: pop af  
adcd			endm  
# End of macro DMARK
adcd						CALLMONITOR 
adcd cd a3 94			call break_point_state  
add0				endm  
# End of macro CALLMONITOR
add0					endif 
add0			 
add0			; if not true then skip to THEN 
add0			 
add0				; TODO get tok_ptr 
add0				; TODO consume toks until we get to THEN 
add0			 
add0 2a 86 e7			ld hl, (os_tok_ptr) 
add3					if DEBUG_FORTH_WORDS 
add3						DMARK "IF3" 
add3 f5				push af  
add4 3a e8 ad			ld a, (.dmark)  
add7 32 b7 ee			ld (debug_mark),a  
adda 3a e9 ad			ld a, (.dmark+1)  
addd 32 b8 ee			ld (debug_mark+1),a  
ade0 3a ea ad			ld a, (.dmark+2)  
ade3 32 b9 ee			ld (debug_mark+2),a  
ade6 18 03			jr .pastdmark  
ade8 ..			.dmark: db "IF3"  
adeb f1			.pastdmark: pop af  
adec			endm  
# End of macro DMARK
adec						CALLMONITOR 
adec cd a3 94			call break_point_state  
adef				endm  
# End of macro CALLMONITOR
adef						 
adef					endif 
adef 11 36 ae			ld de, .ifthen 
adf2					if DEBUG_FORTH_WORDS 
adf2						DMARK "IF4" 
adf2 f5				push af  
adf3 3a 07 ae			ld a, (.dmark)  
adf6 32 b7 ee			ld (debug_mark),a  
adf9 3a 08 ae			ld a, (.dmark+1)  
adfc 32 b8 ee			ld (debug_mark+1),a  
adff 3a 09 ae			ld a, (.dmark+2)  
ae02 32 b9 ee			ld (debug_mark+2),a  
ae05 18 03			jr .pastdmark  
ae07 ..			.dmark: db "IF4"  
ae0a f1			.pastdmark: pop af  
ae0b			endm  
# End of macro DMARK
ae0b						CALLMONITOR 
ae0b cd a3 94			call break_point_state  
ae0e				endm  
# End of macro CALLMONITOR
ae0e					endif 
ae0e cd 9d 9f			call findnexttok  
ae11			 
ae11					if DEBUG_FORTH_WORDS 
ae11						DMARK "IF5" 
ae11 f5				push af  
ae12 3a 26 ae			ld a, (.dmark)  
ae15 32 b7 ee			ld (debug_mark),a  
ae18 3a 27 ae			ld a, (.dmark+1)  
ae1b 32 b8 ee			ld (debug_mark+1),a  
ae1e 3a 28 ae			ld a, (.dmark+2)  
ae21 32 b9 ee			ld (debug_mark+2),a  
ae24 18 03			jr .pastdmark  
ae26 ..			.dmark: db "IF5"  
ae29 f1			.pastdmark: pop af  
ae2a			endm  
# End of macro DMARK
ae2a						CALLMONITOR 
ae2a cd a3 94			call break_point_state  
ae2d				endm  
# End of macro CALLMONITOR
ae2d					endif 
ae2d				; TODO replace below with ; exec using tok_ptr 
ae2d 22 86 e7			ld (os_tok_ptr), hl 
ae30 c3 13 9f			jp exec1 
ae33				NEXTW 
ae33 c3 82 9e			jp macro_next 
ae36				endm 
# End of macro NEXTW
ae36			 
ae36 .. 00		.ifthen:  db "THEN",0 
ae3b			 
ae3b			.iftrue:		 
ae3b				; Exec next words normally 
ae3b			 
ae3b				; if true then exec following IF as normal 
ae3b					if DEBUG_FORTH_WORDS 
ae3b						DMARK "IFT" 
ae3b f5				push af  
ae3c 3a 50 ae			ld a, (.dmark)  
ae3f 32 b7 ee			ld (debug_mark),a  
ae42 3a 51 ae			ld a, (.dmark+1)  
ae45 32 b8 ee			ld (debug_mark+1),a  
ae48 3a 52 ae			ld a, (.dmark+2)  
ae4b 32 b9 ee			ld (debug_mark+2),a  
ae4e 18 03			jr .pastdmark  
ae50 ..			.dmark: db "IFT"  
ae53 f1			.pastdmark: pop af  
ae54			endm  
# End of macro DMARK
ae54						CALLMONITOR 
ae54 cd a3 94			call break_point_state  
ae57				endm  
# End of macro CALLMONITOR
ae57					endif 
ae57			 
ae57					NEXTW 
ae57 c3 82 9e			jp macro_next 
ae5a				endm 
# End of macro NEXTW
ae5a			.THEN: 
ae5a				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ae5a 1f				db WORD_SYS_CORE+11             
ae5b 82 ae			dw .ELSE            
ae5d 05				db 4 + 1 
ae5e .. 00			db "THEN",0              
ae63				endm 
# End of macro CWHEAD
ae63			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ae63					if DEBUG_FORTH_WORDS_KEY 
ae63						DMARK "THN" 
ae63 f5				push af  
ae64 3a 78 ae			ld a, (.dmark)  
ae67 32 b7 ee			ld (debug_mark),a  
ae6a 3a 79 ae			ld a, (.dmark+1)  
ae6d 32 b8 ee			ld (debug_mark+1),a  
ae70 3a 7a ae			ld a, (.dmark+2)  
ae73 32 b9 ee			ld (debug_mark+2),a  
ae76 18 03			jr .pastdmark  
ae78 ..			.dmark: db "THN"  
ae7b f1			.pastdmark: pop af  
ae7c			endm  
# End of macro DMARK
ae7c						CALLMONITOR 
ae7c cd a3 94			call break_point_state  
ae7f				endm  
# End of macro CALLMONITOR
ae7f					endif 
ae7f					NEXTW 
ae7f c3 82 9e			jp macro_next 
ae82				endm 
# End of macro NEXTW
ae82			.ELSE: 
ae82				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ae82 20				db WORD_SYS_CORE+12             
ae83 aa ae			dw .DO            
ae85 03				db 2 + 1 
ae86 .. 00			db "ELSE",0              
ae8b				endm 
# End of macro CWHEAD
ae8b			; | ELSE ( -- ) Not supported - does nothing | TODO 
ae8b			 
ae8b					if DEBUG_FORTH_WORDS_KEY 
ae8b						DMARK "ELS" 
ae8b f5				push af  
ae8c 3a a0 ae			ld a, (.dmark)  
ae8f 32 b7 ee			ld (debug_mark),a  
ae92 3a a1 ae			ld a, (.dmark+1)  
ae95 32 b8 ee			ld (debug_mark+1),a  
ae98 3a a2 ae			ld a, (.dmark+2)  
ae9b 32 b9 ee			ld (debug_mark+2),a  
ae9e 18 03			jr .pastdmark  
aea0 ..			.dmark: db "ELS"  
aea3 f1			.pastdmark: pop af  
aea4			endm  
# End of macro DMARK
aea4						CALLMONITOR 
aea4 cd a3 94			call break_point_state  
aea7				endm  
# End of macro CALLMONITOR
aea7					endif 
aea7			 
aea7			 
aea7					NEXTW 
aea7 c3 82 9e			jp macro_next 
aeaa				endm 
# End of macro NEXTW
aeaa			.DO: 
aeaa				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
aeaa 21				db WORD_SYS_CORE+13             
aeab d1 af			dw .LOOP            
aead 03				db 2 + 1 
aeae .. 00			db "DO",0              
aeb1				endm 
# End of macro CWHEAD
aeb1			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
aeb1			 
aeb1					if DEBUG_FORTH_WORDS_KEY 
aeb1						DMARK "DO." 
aeb1 f5				push af  
aeb2 3a c6 ae			ld a, (.dmark)  
aeb5 32 b7 ee			ld (debug_mark),a  
aeb8 3a c7 ae			ld a, (.dmark+1)  
aebb 32 b8 ee			ld (debug_mark+1),a  
aebe 3a c8 ae			ld a, (.dmark+2)  
aec1 32 b9 ee			ld (debug_mark+2),a  
aec4 18 03			jr .pastdmark  
aec6 ..			.dmark: db "DO."  
aec9 f1			.pastdmark: pop af  
aeca			endm  
# End of macro DMARK
aeca						CALLMONITOR 
aeca cd a3 94			call break_point_state  
aecd				endm  
# End of macro CALLMONITOR
aecd					endif 
aecd			;  push pc to rsp stack past the DO 
aecd			 
aecd 2a 86 e7				ld hl, (os_tok_ptr) 
aed0 23					inc hl   ; D 
aed1 23					inc hl  ; O 
aed2 23					inc hl   ; null 
aed3					if DEBUG_FORTH_WORDS 
aed3						DMARK "DO2" 
aed3 f5				push af  
aed4 3a e8 ae			ld a, (.dmark)  
aed7 32 b7 ee			ld (debug_mark),a  
aeda 3a e9 ae			ld a, (.dmark+1)  
aedd 32 b8 ee			ld (debug_mark+1),a  
aee0 3a ea ae			ld a, (.dmark+2)  
aee3 32 b9 ee			ld (debug_mark+2),a  
aee6 18 03			jr .pastdmark  
aee8 ..			.dmark: db "DO2"  
aeeb f1			.pastdmark: pop af  
aeec			endm  
# End of macro DMARK
aeec						CALLMONITOR 
aeec cd a3 94			call break_point_state  
aeef				endm  
# End of macro CALLMONITOR
aeef					endif 
aeef					FORTH_RSP_NEXT 
aeef cd bb 9a			call macro_forth_rsp_next 
aef2				endm 
# End of macro FORTH_RSP_NEXT
aef2					if DEBUG_FORTH_WORDS 
aef2						DMARK "DO3" 
aef2 f5				push af  
aef3 3a 07 af			ld a, (.dmark)  
aef6 32 b7 ee			ld (debug_mark),a  
aef9 3a 08 af			ld a, (.dmark+1)  
aefc 32 b8 ee			ld (debug_mark+1),a  
aeff 3a 09 af			ld a, (.dmark+2)  
af02 32 b9 ee			ld (debug_mark+2),a  
af05 18 03			jr .pastdmark  
af07 ..			.dmark: db "DO3"  
af0a f1			.pastdmark: pop af  
af0b			endm  
# End of macro DMARK
af0b						CALLMONITOR 
af0b cd a3 94			call break_point_state  
af0e				endm  
# End of macro CALLMONITOR
af0e					endif 
af0e			 
af0e					;if DEBUG_FORTH_WORDS 
af0e				;		push hl 
af0e			;		endif  
af0e			 
af0e			; get counters from data stack 
af0e			 
af0e			 
af0e					FORTH_DSP_VALUEHL 
af0e cd 0b 9d			call macro_dsp_valuehl 
af11				endm 
# End of macro FORTH_DSP_VALUEHL
af11 e5					push hl		 ; hl now has starting counter which needs to be tos 
af12			 
af12					if DEBUG_FORTH_WORDS 
af12						DMARK "DO4" 
af12 f5				push af  
af13 3a 27 af			ld a, (.dmark)  
af16 32 b7 ee			ld (debug_mark),a  
af19 3a 28 af			ld a, (.dmark+1)  
af1c 32 b8 ee			ld (debug_mark+1),a  
af1f 3a 29 af			ld a, (.dmark+2)  
af22 32 b9 ee			ld (debug_mark+2),a  
af25 18 03			jr .pastdmark  
af27 ..			.dmark: db "DO4"  
af2a f1			.pastdmark: pop af  
af2b			endm  
# End of macro DMARK
af2b						CALLMONITOR 
af2b cd a3 94			call break_point_state  
af2e				endm  
# End of macro CALLMONITOR
af2e					endif 
af2e					FORTH_DSP_POP 
af2e cd c3 9d			call macro_forth_dsp_pop 
af31				endm 
# End of macro FORTH_DSP_POP
af31			 
af31					if DEBUG_FORTH_WORDS 
af31						DMARK "DO5" 
af31 f5				push af  
af32 3a 46 af			ld a, (.dmark)  
af35 32 b7 ee			ld (debug_mark),a  
af38 3a 47 af			ld a, (.dmark+1)  
af3b 32 b8 ee			ld (debug_mark+1),a  
af3e 3a 48 af			ld a, (.dmark+2)  
af41 32 b9 ee			ld (debug_mark+2),a  
af44 18 03			jr .pastdmark  
af46 ..			.dmark: db "DO5"  
af49 f1			.pastdmark: pop af  
af4a			endm  
# End of macro DMARK
af4a						CALLMONITOR 
af4a cd a3 94			call break_point_state  
af4d				endm  
# End of macro CALLMONITOR
af4d					endif 
af4d			 
af4d					FORTH_DSP_VALUEHL 
af4d cd 0b 9d			call macro_dsp_valuehl 
af50				endm 
# End of macro FORTH_DSP_VALUEHL
af50			;		push hl		 ; hl now has starting limit counter 
af50			 
af50					if DEBUG_FORTH_WORDS 
af50						DMARK "DO6" 
af50 f5				push af  
af51 3a 65 af			ld a, (.dmark)  
af54 32 b7 ee			ld (debug_mark),a  
af57 3a 66 af			ld a, (.dmark+1)  
af5a 32 b8 ee			ld (debug_mark+1),a  
af5d 3a 67 af			ld a, (.dmark+2)  
af60 32 b9 ee			ld (debug_mark+2),a  
af63 18 03			jr .pastdmark  
af65 ..			.dmark: db "DO6"  
af68 f1			.pastdmark: pop af  
af69			endm  
# End of macro DMARK
af69						CALLMONITOR 
af69 cd a3 94			call break_point_state  
af6c				endm  
# End of macro CALLMONITOR
af6c					endif 
af6c					FORTH_DSP_POP 
af6c cd c3 9d			call macro_forth_dsp_pop 
af6f				endm 
# End of macro FORTH_DSP_POP
af6f			 
af6f			; put counters on the loop stack 
af6f			 
af6f			;		pop hl			 ; limit counter 
af6f d1					pop de			; start counter 
af70			 
af70					; push limit counter 
af70			 
af70					if DEBUG_FORTH_WORDS 
af70						DMARK "DO7" 
af70 f5				push af  
af71 3a 85 af			ld a, (.dmark)  
af74 32 b7 ee			ld (debug_mark),a  
af77 3a 86 af			ld a, (.dmark+1)  
af7a 32 b8 ee			ld (debug_mark+1),a  
af7d 3a 87 af			ld a, (.dmark+2)  
af80 32 b9 ee			ld (debug_mark+2),a  
af83 18 03			jr .pastdmark  
af85 ..			.dmark: db "DO7"  
af88 f1			.pastdmark: pop af  
af89			endm  
# End of macro DMARK
af89						CALLMONITOR 
af89 cd a3 94			call break_point_state  
af8c				endm  
# End of macro CALLMONITOR
af8c					endif 
af8c					FORTH_LOOP_NEXT 
af8c cd 3c 9d			call macro_forth_loop_next 
af8f				endm 
# End of macro FORTH_LOOP_NEXT
af8f			 
af8f					; push start counter 
af8f			 
af8f eb					ex de, hl 
af90					if DEBUG_FORTH_WORDS 
af90						DMARK "DO7" 
af90 f5				push af  
af91 3a a5 af			ld a, (.dmark)  
af94 32 b7 ee			ld (debug_mark),a  
af97 3a a6 af			ld a, (.dmark+1)  
af9a 32 b8 ee			ld (debug_mark+1),a  
af9d 3a a7 af			ld a, (.dmark+2)  
afa0 32 b9 ee			ld (debug_mark+2),a  
afa3 18 03			jr .pastdmark  
afa5 ..			.dmark: db "DO7"  
afa8 f1			.pastdmark: pop af  
afa9			endm  
# End of macro DMARK
afa9						CALLMONITOR 
afa9 cd a3 94			call break_point_state  
afac				endm  
# End of macro CALLMONITOR
afac					endif 
afac					FORTH_LOOP_NEXT 
afac cd 3c 9d			call macro_forth_loop_next 
afaf				endm 
# End of macro FORTH_LOOP_NEXT
afaf			 
afaf			 
afaf					; init first round of I counter 
afaf			 
afaf 22 aa e7				ld (os_current_i), hl 
afb2			 
afb2					if DEBUG_FORTH_WORDS 
afb2						DMARK "DO8" 
afb2 f5				push af  
afb3 3a c7 af			ld a, (.dmark)  
afb6 32 b7 ee			ld (debug_mark),a  
afb9 3a c8 af			ld a, (.dmark+1)  
afbc 32 b8 ee			ld (debug_mark+1),a  
afbf 3a c9 af			ld a, (.dmark+2)  
afc2 32 b9 ee			ld (debug_mark+2),a  
afc5 18 03			jr .pastdmark  
afc7 ..			.dmark: db "DO8"  
afca f1			.pastdmark: pop af  
afcb			endm  
# End of macro DMARK
afcb						CALLMONITOR 
afcb cd a3 94			call break_point_state  
afce				endm  
# End of macro CALLMONITOR
afce					endif 
afce			 
afce					NEXTW 
afce c3 82 9e			jp macro_next 
afd1				endm 
# End of macro NEXTW
afd1			.LOOP: 
afd1				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
afd1 22				db WORD_SYS_CORE+14             
afd2 e9 b0			dw .I            
afd4 05				db 4 + 1 
afd5 .. 00			db "LOOP",0              
afda				endm 
# End of macro CWHEAD
afda			; | LOOP ( -- ) Increment and test loop counter  | DONE 
afda			 
afda				; pop tos as current loop count to hl 
afda			 
afda				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
afda			 
afda				FORTH_LOOP_TOS 
afda cd 6f 9d			call macro_forth_loop_tos 
afdd				endm 
# End of macro FORTH_LOOP_TOS
afdd e5				push hl 
afde			 
afde					if DEBUG_FORTH_WORDS_KEY 
afde						DMARK "LOP" 
afde f5				push af  
afdf 3a f3 af			ld a, (.dmark)  
afe2 32 b7 ee			ld (debug_mark),a  
afe5 3a f4 af			ld a, (.dmark+1)  
afe8 32 b8 ee			ld (debug_mark+1),a  
afeb 3a f5 af			ld a, (.dmark+2)  
afee 32 b9 ee			ld (debug_mark+2),a  
aff1 18 03			jr .pastdmark  
aff3 ..			.dmark: db "LOP"  
aff6 f1			.pastdmark: pop af  
aff7			endm  
# End of macro DMARK
aff7						CALLMONITOR 
aff7 cd a3 94			call break_point_state  
affa				endm  
# End of macro CALLMONITOR
affa					endif 
affa				; next item on the stack is the limit. get it 
affa			 
affa			 
affa				FORTH_LOOP_POP 
affa cd 79 9d			call macro_forth_loop_pop 
affd				endm 
# End of macro FORTH_LOOP_POP
affd			 
affd				FORTH_LOOP_TOS 
affd cd 6f 9d			call macro_forth_loop_tos 
b000				endm 
# End of macro FORTH_LOOP_TOS
b000			 
b000 d1				pop de		 ; de = i, hl = limit 
b001			 
b001					if DEBUG_FORTH_WORDS 
b001						DMARK "LP1" 
b001 f5				push af  
b002 3a 16 b0			ld a, (.dmark)  
b005 32 b7 ee			ld (debug_mark),a  
b008 3a 17 b0			ld a, (.dmark+1)  
b00b 32 b8 ee			ld (debug_mark+1),a  
b00e 3a 18 b0			ld a, (.dmark+2)  
b011 32 b9 ee			ld (debug_mark+2),a  
b014 18 03			jr .pastdmark  
b016 ..			.dmark: db "LP1"  
b019 f1			.pastdmark: pop af  
b01a			endm  
# End of macro DMARK
b01a						CALLMONITOR 
b01a cd a3 94			call break_point_state  
b01d				endm  
# End of macro CALLMONITOR
b01d					endif 
b01d			 
b01d				; go back to previous word 
b01d			 
b01d d5				push de    ; save I for inc later 
b01e			 
b01e			 
b01e				; get limit 
b01e				;  is I at limit? 
b01e			 
b01e			 
b01e					if DEBUG_FORTH_WORDS 
b01e						DMARK "LP1" 
b01e f5				push af  
b01f 3a 33 b0			ld a, (.dmark)  
b022 32 b7 ee			ld (debug_mark),a  
b025 3a 34 b0			ld a, (.dmark+1)  
b028 32 b8 ee			ld (debug_mark+1),a  
b02b 3a 35 b0			ld a, (.dmark+2)  
b02e 32 b9 ee			ld (debug_mark+2),a  
b031 18 03			jr .pastdmark  
b033 ..			.dmark: db "LP1"  
b036 f1			.pastdmark: pop af  
b037			endm  
# End of macro DMARK
b037						CALLMONITOR 
b037 cd a3 94			call break_point_state  
b03a				endm  
# End of macro CALLMONITOR
b03a					endif 
b03a			 
b03a ed 52			sbc hl, de 
b03c			 
b03c			 
b03c				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b03c			 
b03c 20 26				jr nz, .loopnotdone 
b03e			 
b03e e1				pop hl   ; get rid of saved I 
b03f				FORTH_LOOP_POP     ; get rid of limit 
b03f cd 79 9d			call macro_forth_loop_pop 
b042				endm 
# End of macro FORTH_LOOP_POP
b042			 
b042				FORTH_RSP_POP     ; get rid of DO ptr 
b042 cd dc 9a			call macro_forth_rsp_pop 
b045				endm 
# End of macro FORTH_RSP_POP
b045			 
b045			if DEBUG_FORTH_WORDS 
b045						DMARK "LP>" 
b045 f5				push af  
b046 3a 5a b0			ld a, (.dmark)  
b049 32 b7 ee			ld (debug_mark),a  
b04c 3a 5b b0			ld a, (.dmark+1)  
b04f 32 b8 ee			ld (debug_mark+1),a  
b052 3a 5c b0			ld a, (.dmark+2)  
b055 32 b9 ee			ld (debug_mark+2),a  
b058 18 03			jr .pastdmark  
b05a ..			.dmark: db "LP>"  
b05d f1			.pastdmark: pop af  
b05e			endm  
# End of macro DMARK
b05e				CALLMONITOR 
b05e cd a3 94			call break_point_state  
b061				endm  
# End of macro CALLMONITOR
b061			endif 
b061			 
b061					NEXTW 
b061 c3 82 9e			jp macro_next 
b064				endm 
# End of macro NEXTW
b064				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b064			 
b064			.loopnotdone: 
b064			 
b064 e1				pop hl    ; get I 
b065 23				inc hl 
b066			 
b066			   	; save new I 
b066			 
b066			 
b066					; set I counter 
b066			 
b066 22 aa e7				ld (os_current_i), hl 
b069			 
b069					if DEBUG_FORTH_WORDS 
b069						DMARK "LPN" 
b069 f5				push af  
b06a 3a 7e b0			ld a, (.dmark)  
b06d 32 b7 ee			ld (debug_mark),a  
b070 3a 7f b0			ld a, (.dmark+1)  
b073 32 b8 ee			ld (debug_mark+1),a  
b076 3a 80 b0			ld a, (.dmark+2)  
b079 32 b9 ee			ld (debug_mark+2),a  
b07c 18 03			jr .pastdmark  
b07e ..			.dmark: db "LPN"  
b081 f1			.pastdmark: pop af  
b082			endm  
# End of macro DMARK
b082					CALLMONITOR 
b082 cd a3 94			call break_point_state  
b085				endm  
# End of macro CALLMONITOR
b085					endif 
b085					 
b085				FORTH_LOOP_NEXT 
b085 cd 3c 9d			call macro_forth_loop_next 
b088				endm 
# End of macro FORTH_LOOP_NEXT
b088			 
b088			 
b088					if DEBUG_FORTH_WORDS 
b088 eb						ex de,hl 
b089					endif 
b089			 
b089			;	; get DO ptr 
b089			; 
b089					if DEBUG_FORTH_WORDS 
b089						DMARK "LP7" 
b089 f5				push af  
b08a 3a 9e b0			ld a, (.dmark)  
b08d 32 b7 ee			ld (debug_mark),a  
b090 3a 9f b0			ld a, (.dmark+1)  
b093 32 b8 ee			ld (debug_mark+1),a  
b096 3a a0 b0			ld a, (.dmark+2)  
b099 32 b9 ee			ld (debug_mark+2),a  
b09c 18 03			jr .pastdmark  
b09e ..			.dmark: db "LP7"  
b0a1 f1			.pastdmark: pop af  
b0a2			endm  
# End of macro DMARK
b0a2					CALLMONITOR 
b0a2 cd a3 94			call break_point_state  
b0a5				endm  
# End of macro CALLMONITOR
b0a5					endif 
b0a5				FORTH_RSP_TOS 
b0a5 cd d2 9a			call macro_forth_rsp_tos 
b0a8				endm 
# End of macro FORTH_RSP_TOS
b0a8			 
b0a8					if DEBUG_FORTH_WORDS 
b0a8						DMARK "LP8" 
b0a8 f5				push af  
b0a9 3a bd b0			ld a, (.dmark)  
b0ac 32 b7 ee			ld (debug_mark),a  
b0af 3a be b0			ld a, (.dmark+1)  
b0b2 32 b8 ee			ld (debug_mark+1),a  
b0b5 3a bf b0			ld a, (.dmark+2)  
b0b8 32 b9 ee			ld (debug_mark+2),a  
b0bb 18 03			jr .pastdmark  
b0bd ..			.dmark: db "LP8"  
b0c0 f1			.pastdmark: pop af  
b0c1			endm  
# End of macro DMARK
b0c1					CALLMONITOR 
b0c1 cd a3 94			call break_point_state  
b0c4				endm  
# End of macro CALLMONITOR
b0c4					endif 
b0c4				;push hl 
b0c4			 
b0c4				; not going to DO any more 
b0c4				; get rid of the RSP pointer as DO will add it back in 
b0c4				;FORTH_RSP_POP 
b0c4				;pop hl 
b0c4			 
b0c4				;ld hl,(cli_ret_sp) 
b0c4				;ld e, (hl) 
b0c4				;inc hl 
b0c4				;ld d, (hl) 
b0c4				;ex de,hl 
b0c4 22 86 e7			ld (os_tok_ptr), hl 
b0c7					if DEBUG_FORTH_WORDS 
b0c7						DMARK "LP<" 
b0c7 f5				push af  
b0c8 3a dc b0			ld a, (.dmark)  
b0cb 32 b7 ee			ld (debug_mark),a  
b0ce 3a dd b0			ld a, (.dmark+1)  
b0d1 32 b8 ee			ld (debug_mark+1),a  
b0d4 3a de b0			ld a, (.dmark+2)  
b0d7 32 b9 ee			ld (debug_mark+2),a  
b0da 18 03			jr .pastdmark  
b0dc ..			.dmark: db "LP<"  
b0df f1			.pastdmark: pop af  
b0e0			endm  
# End of macro DMARK
b0e0					CALLMONITOR 
b0e0 cd a3 94			call break_point_state  
b0e3				endm  
# End of macro CALLMONITOR
b0e3				endif 
b0e3 c3 13 9f			jp exec1 
b0e6			 
b0e6					 
b0e6			 
b0e6			 
b0e6					NEXTW 
b0e6 c3 82 9e			jp macro_next 
b0e9				endm 
# End of macro NEXTW
b0e9			.I:  
b0e9			 
b0e9				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b0e9 5e				db WORD_SYS_CORE+74             
b0ea 14 b1			dw .DLOOP            
b0ec 02				db 1 + 1 
b0ed .. 00			db "I",0              
b0ef				endm 
# End of macro CWHEAD
b0ef			; | I ( -- ) Current loop counter | DONE 
b0ef					if DEBUG_FORTH_WORDS_KEY 
b0ef						DMARK "I.." 
b0ef f5				push af  
b0f0 3a 04 b1			ld a, (.dmark)  
b0f3 32 b7 ee			ld (debug_mark),a  
b0f6 3a 05 b1			ld a, (.dmark+1)  
b0f9 32 b8 ee			ld (debug_mark+1),a  
b0fc 3a 06 b1			ld a, (.dmark+2)  
b0ff 32 b9 ee			ld (debug_mark+2),a  
b102 18 03			jr .pastdmark  
b104 ..			.dmark: db "I.."  
b107 f1			.pastdmark: pop af  
b108			endm  
# End of macro DMARK
b108						CALLMONITOR 
b108 cd a3 94			call break_point_state  
b10b				endm  
# End of macro CALLMONITOR
b10b					endif 
b10b			 
b10b 2a aa e7				ld hl,(os_current_i) 
b10e cd 14 9b				call forth_push_numhl 
b111			 
b111					NEXTW 
b111 c3 82 9e			jp macro_next 
b114				endm 
# End of macro NEXTW
b114			.DLOOP: 
b114				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b114 5f				db WORD_SYS_CORE+75             
b115 f5 b1			dw .REPEAT            
b117 06				db 5 + 1 
b118 .. 00			db "-LOOP",0              
b11e				endm 
# End of macro CWHEAD
b11e			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b11e				; pop tos as current loop count to hl 
b11e					if DEBUG_FORTH_WORDS_KEY 
b11e						DMARK "-LP" 
b11e f5				push af  
b11f 3a 33 b1			ld a, (.dmark)  
b122 32 b7 ee			ld (debug_mark),a  
b125 3a 34 b1			ld a, (.dmark+1)  
b128 32 b8 ee			ld (debug_mark+1),a  
b12b 3a 35 b1			ld a, (.dmark+2)  
b12e 32 b9 ee			ld (debug_mark+2),a  
b131 18 03			jr .pastdmark  
b133 ..			.dmark: db "-LP"  
b136 f1			.pastdmark: pop af  
b137			endm  
# End of macro DMARK
b137						CALLMONITOR 
b137 cd a3 94			call break_point_state  
b13a				endm  
# End of macro CALLMONITOR
b13a					endif 
b13a			 
b13a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b13a			 
b13a				FORTH_LOOP_TOS 
b13a cd 6f 9d			call macro_forth_loop_tos 
b13d				endm 
# End of macro FORTH_LOOP_TOS
b13d e5				push hl 
b13e			 
b13e					if DEBUG_FORTH_WORDS 
b13e						DMARK "-LP" 
b13e f5				push af  
b13f 3a 53 b1			ld a, (.dmark)  
b142 32 b7 ee			ld (debug_mark),a  
b145 3a 54 b1			ld a, (.dmark+1)  
b148 32 b8 ee			ld (debug_mark+1),a  
b14b 3a 55 b1			ld a, (.dmark+2)  
b14e 32 b9 ee			ld (debug_mark+2),a  
b151 18 03			jr .pastdmark  
b153 ..			.dmark: db "-LP"  
b156 f1			.pastdmark: pop af  
b157			endm  
# End of macro DMARK
b157						CALLMONITOR 
b157 cd a3 94			call break_point_state  
b15a				endm  
# End of macro CALLMONITOR
b15a					endif 
b15a				; next item on the stack is the limit. get it 
b15a			 
b15a			 
b15a				FORTH_LOOP_POP 
b15a cd 79 9d			call macro_forth_loop_pop 
b15d				endm 
# End of macro FORTH_LOOP_POP
b15d			 
b15d				FORTH_LOOP_TOS 
b15d cd 6f 9d			call macro_forth_loop_tos 
b160				endm 
# End of macro FORTH_LOOP_TOS
b160			 
b160 d1				pop de		 ; de = i, hl = limit 
b161			 
b161					if DEBUG_FORTH_WORDS 
b161						DMARK "-L1" 
b161 f5				push af  
b162 3a 76 b1			ld a, (.dmark)  
b165 32 b7 ee			ld (debug_mark),a  
b168 3a 77 b1			ld a, (.dmark+1)  
b16b 32 b8 ee			ld (debug_mark+1),a  
b16e 3a 78 b1			ld a, (.dmark+2)  
b171 32 b9 ee			ld (debug_mark+2),a  
b174 18 03			jr .pastdmark  
b176 ..			.dmark: db "-L1"  
b179 f1			.pastdmark: pop af  
b17a			endm  
# End of macro DMARK
b17a						CALLMONITOR 
b17a cd a3 94			call break_point_state  
b17d				endm  
# End of macro CALLMONITOR
b17d					endif 
b17d			 
b17d				; go back to previous word 
b17d			 
b17d d5				push de    ; save I for inc later 
b17e			 
b17e			 
b17e				; get limit 
b17e				;  is I at limit? 
b17e			 
b17e			 
b17e					if DEBUG_FORTH_WORDS 
b17e						DMARK "-L1" 
b17e f5				push af  
b17f 3a 93 b1			ld a, (.dmark)  
b182 32 b7 ee			ld (debug_mark),a  
b185 3a 94 b1			ld a, (.dmark+1)  
b188 32 b8 ee			ld (debug_mark+1),a  
b18b 3a 95 b1			ld a, (.dmark+2)  
b18e 32 b9 ee			ld (debug_mark+2),a  
b191 18 03			jr .pastdmark  
b193 ..			.dmark: db "-L1"  
b196 f1			.pastdmark: pop af  
b197			endm  
# End of macro DMARK
b197						CALLMONITOR 
b197 cd a3 94			call break_point_state  
b19a				endm  
# End of macro CALLMONITOR
b19a					endif 
b19a			 
b19a ed 52			sbc hl, de 
b19c			 
b19c			 
b19c				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b19c			 
b19c 20 26				jr nz, .mloopnotdone 
b19e			 
b19e e1				pop hl   ; get rid of saved I 
b19f				FORTH_LOOP_POP     ; get rid of limit 
b19f cd 79 9d			call macro_forth_loop_pop 
b1a2				endm 
# End of macro FORTH_LOOP_POP
b1a2			 
b1a2				FORTH_RSP_POP     ; get rid of DO ptr 
b1a2 cd dc 9a			call macro_forth_rsp_pop 
b1a5				endm 
# End of macro FORTH_RSP_POP
b1a5			 
b1a5			if DEBUG_FORTH_WORDS 
b1a5						DMARK "-L>" 
b1a5 f5				push af  
b1a6 3a ba b1			ld a, (.dmark)  
b1a9 32 b7 ee			ld (debug_mark),a  
b1ac 3a bb b1			ld a, (.dmark+1)  
b1af 32 b8 ee			ld (debug_mark+1),a  
b1b2 3a bc b1			ld a, (.dmark+2)  
b1b5 32 b9 ee			ld (debug_mark+2),a  
b1b8 18 03			jr .pastdmark  
b1ba ..			.dmark: db "-L>"  
b1bd f1			.pastdmark: pop af  
b1be			endm  
# End of macro DMARK
b1be				CALLMONITOR 
b1be cd a3 94			call break_point_state  
b1c1				endm  
# End of macro CALLMONITOR
b1c1			endif 
b1c1			 
b1c1					NEXTW 
b1c1 c3 82 9e			jp macro_next 
b1c4				endm 
# End of macro NEXTW
b1c4				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b1c4			 
b1c4			.mloopnotdone: 
b1c4			 
b1c4 e1				pop hl    ; get I 
b1c5 2b				dec hl 
b1c6			 
b1c6			   	; save new I 
b1c6			 
b1c6			 
b1c6					; set I counter 
b1c6			 
b1c6 22 aa e7				ld (os_current_i), hl 
b1c9			 
b1c9					 
b1c9				FORTH_LOOP_NEXT 
b1c9 cd 3c 9d			call macro_forth_loop_next 
b1cc				endm 
# End of macro FORTH_LOOP_NEXT
b1cc			 
b1cc			 
b1cc					if DEBUG_FORTH_WORDS 
b1cc eb						ex de,hl 
b1cd					endif 
b1cd			 
b1cd			;	; get DO ptr 
b1cd			; 
b1cd				FORTH_RSP_TOS 
b1cd cd d2 9a			call macro_forth_rsp_tos 
b1d0				endm 
# End of macro FORTH_RSP_TOS
b1d0			 
b1d0				;push hl 
b1d0			 
b1d0				; not going to DO any more 
b1d0				; get rid of the RSP pointer as DO will add it back in 
b1d0				;FORTH_RSP_POP 
b1d0				;pop hl 
b1d0			 
b1d0			 
b1d0 22 86 e7			ld (os_tok_ptr), hl 
b1d3					if DEBUG_FORTH_WORDS 
b1d3						DMARK "-L<" 
b1d3 f5				push af  
b1d4 3a e8 b1			ld a, (.dmark)  
b1d7 32 b7 ee			ld (debug_mark),a  
b1da 3a e9 b1			ld a, (.dmark+1)  
b1dd 32 b8 ee			ld (debug_mark+1),a  
b1e0 3a ea b1			ld a, (.dmark+2)  
b1e3 32 b9 ee			ld (debug_mark+2),a  
b1e6 18 03			jr .pastdmark  
b1e8 ..			.dmark: db "-L<"  
b1eb f1			.pastdmark: pop af  
b1ec			endm  
# End of macro DMARK
b1ec					CALLMONITOR 
b1ec cd a3 94			call break_point_state  
b1ef				endm  
# End of macro CALLMONITOR
b1ef				endif 
b1ef c3 13 9f			jp exec1 
b1f2			 
b1f2					 
b1f2			 
b1f2			 
b1f2			 
b1f2				NEXTW 
b1f2 c3 82 9e			jp macro_next 
b1f5				endm 
# End of macro NEXTW
b1f5			 
b1f5			 
b1f5			 
b1f5			 
b1f5			.REPEAT: 
b1f5				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b1f5 71				db WORD_SYS_CORE+93             
b1f6 48 b2			dw .UNTIL            
b1f8 06				db 5 + 1 
b1f9 .. 00			db "REPEAT",0              
b200				endm 
# End of macro CWHEAD
b200			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b200			;  push pc to rsp stack past the REPEAT 
b200					if DEBUG_FORTH_WORDS_KEY 
b200						DMARK "REP" 
b200 f5				push af  
b201 3a 15 b2			ld a, (.dmark)  
b204 32 b7 ee			ld (debug_mark),a  
b207 3a 16 b2			ld a, (.dmark+1)  
b20a 32 b8 ee			ld (debug_mark+1),a  
b20d 3a 17 b2			ld a, (.dmark+2)  
b210 32 b9 ee			ld (debug_mark+2),a  
b213 18 03			jr .pastdmark  
b215 ..			.dmark: db "REP"  
b218 f1			.pastdmark: pop af  
b219			endm  
# End of macro DMARK
b219						CALLMONITOR 
b219 cd a3 94			call break_point_state  
b21c				endm  
# End of macro CALLMONITOR
b21c					endif 
b21c			 
b21c 2a 86 e7				ld hl, (os_tok_ptr) 
b21f 23					inc hl   ; R 
b220 23					inc hl  ; E 
b221 23					inc hl   ; P 
b222 23					inc hl   ; E 
b223 23					inc hl   ; A 
b224 23					inc hl   ; T 
b225 23					inc hl   ; zero 
b226					FORTH_RSP_NEXT 
b226 cd bb 9a			call macro_forth_rsp_next 
b229				endm 
# End of macro FORTH_RSP_NEXT
b229			 
b229			 
b229					if DEBUG_FORTH_WORDS 
b229						DMARK "REP" 
b229 f5				push af  
b22a 3a 3e b2			ld a, (.dmark)  
b22d 32 b7 ee			ld (debug_mark),a  
b230 3a 3f b2			ld a, (.dmark+1)  
b233 32 b8 ee			ld (debug_mark+1),a  
b236 3a 40 b2			ld a, (.dmark+2)  
b239 32 b9 ee			ld (debug_mark+2),a  
b23c 18 03			jr .pastdmark  
b23e ..			.dmark: db "REP"  
b241 f1			.pastdmark: pop af  
b242			endm  
# End of macro DMARK
b242						;pop bc    ; TODO BUG ?????? what is this for???? 
b242						CALLMONITOR 
b242 cd a3 94			call break_point_state  
b245				endm  
# End of macro CALLMONITOR
b245					endif 
b245			 
b245					NEXTW 
b245 c3 82 9e			jp macro_next 
b248				endm 
# End of macro NEXTW
b248			;	       NEXTW 
b248			 
b248			.UNTIL: 
b248				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b248 72				db WORD_SYS_CORE+94             
b249 df b2			dw .ENDFLOW            
b24b 06				db 5 + 1 
b24c .. 00			db "UNTIL",0              
b252				endm 
# End of macro CWHEAD
b252			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b252			 
b252				; pop tos as check 
b252			 
b252				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b252			 
b252				FORTH_DSP_VALUEHL 
b252 cd 0b 9d			call macro_dsp_valuehl 
b255				endm 
# End of macro FORTH_DSP_VALUEHL
b255			 
b255					if DEBUG_FORTH_WORDS_KEY 
b255						DMARK "UNT" 
b255 f5				push af  
b256 3a 6a b2			ld a, (.dmark)  
b259 32 b7 ee			ld (debug_mark),a  
b25c 3a 6b b2			ld a, (.dmark+1)  
b25f 32 b8 ee			ld (debug_mark+1),a  
b262 3a 6c b2			ld a, (.dmark+2)  
b265 32 b9 ee			ld (debug_mark+2),a  
b268 18 03			jr .pastdmark  
b26a ..			.dmark: db "UNT"  
b26d f1			.pastdmark: pop af  
b26e			endm  
# End of macro DMARK
b26e						CALLMONITOR 
b26e cd a3 94			call break_point_state  
b271				endm  
# End of macro CALLMONITOR
b271					endif 
b271			 
b271			;	push hl 
b271				FORTH_DSP_POP 
b271 cd c3 9d			call macro_forth_dsp_pop 
b274				endm 
# End of macro FORTH_DSP_POP
b274			 
b274			;	pop hl 
b274			 
b274				; test if true 
b274			 
b274 cd cb 8c			call ishlzero 
b277			;	ld a,l 
b277			;	add h 
b277			; 
b277			;	cp 0 
b277			 
b277 20 3e			jr nz, .untilnotdone 
b279			 
b279					if DEBUG_FORTH_WORDS 
b279						DMARK "UNf" 
b279 f5				push af  
b27a 3a 8e b2			ld a, (.dmark)  
b27d 32 b7 ee			ld (debug_mark),a  
b280 3a 8f b2			ld a, (.dmark+1)  
b283 32 b8 ee			ld (debug_mark+1),a  
b286 3a 90 b2			ld a, (.dmark+2)  
b289 32 b9 ee			ld (debug_mark+2),a  
b28c 18 03			jr .pastdmark  
b28e ..			.dmark: db "UNf"  
b291 f1			.pastdmark: pop af  
b292			endm  
# End of macro DMARK
b292						CALLMONITOR 
b292 cd a3 94			call break_point_state  
b295				endm  
# End of macro CALLMONITOR
b295					endif 
b295			 
b295			 
b295			 
b295				FORTH_RSP_POP     ; get rid of DO ptr 
b295 cd dc 9a			call macro_forth_rsp_pop 
b298				endm 
# End of macro FORTH_RSP_POP
b298			 
b298			if DEBUG_FORTH_WORDS 
b298						DMARK "UN>" 
b298 f5				push af  
b299 3a ad b2			ld a, (.dmark)  
b29c 32 b7 ee			ld (debug_mark),a  
b29f 3a ae b2			ld a, (.dmark+1)  
b2a2 32 b8 ee			ld (debug_mark+1),a  
b2a5 3a af b2			ld a, (.dmark+2)  
b2a8 32 b9 ee			ld (debug_mark+2),a  
b2ab 18 03			jr .pastdmark  
b2ad ..			.dmark: db "UN>"  
b2b0 f1			.pastdmark: pop af  
b2b1			endm  
# End of macro DMARK
b2b1				CALLMONITOR 
b2b1 cd a3 94			call break_point_state  
b2b4				endm  
# End of macro CALLMONITOR
b2b4			endif 
b2b4			 
b2b4					NEXTW 
b2b4 c3 82 9e			jp macro_next 
b2b7				endm 
# End of macro NEXTW
b2b7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b2b7			 
b2b7			.untilnotdone: 
b2b7			 
b2b7			 
b2b7			;	; get DO ptr 
b2b7			; 
b2b7				FORTH_RSP_TOS 
b2b7 cd d2 9a			call macro_forth_rsp_tos 
b2ba				endm 
# End of macro FORTH_RSP_TOS
b2ba			 
b2ba				;push hl 
b2ba			 
b2ba				; not going to DO any more 
b2ba				; get rid of the RSP pointer as DO will add it back in 
b2ba				;FORTH_RSP_POP 
b2ba				;pop hl 
b2ba			 
b2ba			 
b2ba 22 86 e7			ld (os_tok_ptr), hl 
b2bd					if DEBUG_FORTH_WORDS 
b2bd						DMARK "UN<" 
b2bd f5				push af  
b2be 3a d2 b2			ld a, (.dmark)  
b2c1 32 b7 ee			ld (debug_mark),a  
b2c4 3a d3 b2			ld a, (.dmark+1)  
b2c7 32 b8 ee			ld (debug_mark+1),a  
b2ca 3a d4 b2			ld a, (.dmark+2)  
b2cd 32 b9 ee			ld (debug_mark+2),a  
b2d0 18 03			jr .pastdmark  
b2d2 ..			.dmark: db "UN<"  
b2d5 f1			.pastdmark: pop af  
b2d6			endm  
# End of macro DMARK
b2d6					CALLMONITOR 
b2d6 cd a3 94			call break_point_state  
b2d9				endm  
# End of macro CALLMONITOR
b2d9				endif 
b2d9 c3 13 9f			jp exec1 
b2dc			 
b2dc					 
b2dc			 
b2dc			 
b2dc					NEXTW 
b2dc c3 82 9e			jp macro_next 
b2df				endm 
# End of macro NEXTW
b2df			 
b2df			 
b2df			.ENDFLOW: 
b2df			 
b2df			; eof 
b2df			 
# End of file forth_words_flow.asm
b2df			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b2df			include "forth_words_logic.asm" 
b2df			 
b2df			; | ## Logic Words 
b2df			 
b2df			.NOT: 
b2df				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b2df 2d				db WORD_SYS_CORE+25             
b2e0 27 b3			dw .IS            
b2e2 04				db 3 + 1 
b2e3 .. 00			db "NOT",0              
b2e7				endm 
# End of macro CWHEAD
b2e7			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b2e7					if DEBUG_FORTH_WORDS_KEY 
b2e7						DMARK "NOT" 
b2e7 f5				push af  
b2e8 3a fc b2			ld a, (.dmark)  
b2eb 32 b7 ee			ld (debug_mark),a  
b2ee 3a fd b2			ld a, (.dmark+1)  
b2f1 32 b8 ee			ld (debug_mark+1),a  
b2f4 3a fe b2			ld a, (.dmark+2)  
b2f7 32 b9 ee			ld (debug_mark+2),a  
b2fa 18 03			jr .pastdmark  
b2fc ..			.dmark: db "NOT"  
b2ff f1			.pastdmark: pop af  
b300			endm  
# End of macro DMARK
b300						CALLMONITOR 
b300 cd a3 94			call break_point_state  
b303				endm  
# End of macro CALLMONITOR
b303					endif 
b303					FORTH_DSP 
b303 cd d1 9c			call macro_forth_dsp 
b306				endm 
# End of macro FORTH_DSP
b306 7e					ld a,(hl)	; get type of value on TOS 
b307 fe 02				cp DS_TYPE_INUM  
b309 28 03				jr z, .noti 
b30b					NEXTW 
b30b c3 82 9e			jp macro_next 
b30e				endm 
# End of macro NEXTW
b30e			.noti:          FORTH_DSP_VALUEHL 
b30e cd 0b 9d			call macro_dsp_valuehl 
b311				endm 
# End of macro FORTH_DSP_VALUEHL
b311			;		push hl 
b311					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b311 cd c3 9d			call macro_forth_dsp_pop 
b314				endm 
# End of macro FORTH_DSP_POP
b314			;		pop hl 
b314 3e 00				ld a,0 
b316 bd					cp l 
b317 28 04				jr z, .not2t 
b319 2e 00				ld l, 0 
b31b 18 02				jr .notip 
b31d			 
b31d 2e ff		.not2t:		ld l, 255 
b31f			 
b31f 26 00		.notip:		ld h, 0	 
b321			 
b321 cd 14 9b				call forth_push_numhl 
b324					NEXTW 
b324 c3 82 9e			jp macro_next 
b327				endm 
# End of macro NEXTW
b327			 
b327			.IS: 
b327				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b327 2d				db WORD_SYS_CORE+25             
b328 4d b3			dw .LZERO            
b32a 03				db 2 + 1 
b32b .. 00			db "IS",0              
b32e				endm 
# End of macro CWHEAD
b32e			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b32e					if DEBUG_FORTH_WORDS_KEY 
b32e						DMARK "IS." 
b32e f5				push af  
b32f 3a 43 b3			ld a, (.dmark)  
b332 32 b7 ee			ld (debug_mark),a  
b335 3a 44 b3			ld a, (.dmark+1)  
b338 32 b8 ee			ld (debug_mark+1),a  
b33b 3a 45 b3			ld a, (.dmark+2)  
b33e 32 b9 ee			ld (debug_mark+2),a  
b341 18 03			jr .pastdmark  
b343 ..			.dmark: db "IS."  
b346 f1			.pastdmark: pop af  
b347			endm  
# End of macro DMARK
b347						CALLMONITOR 
b347 cd a3 94			call break_point_state  
b34a				endm  
# End of macro CALLMONITOR
b34a					endif 
b34a					NEXTW 
b34a c3 82 9e			jp macro_next 
b34d				endm 
# End of macro NEXTW
b34d			.LZERO: 
b34d				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b34d 2d				db WORD_SYS_CORE+25             
b34e 57 b3			dw .TZERO            
b350 03				db 2 + 1 
b351 .. 00			db "0<",0              
b354				endm 
# End of macro CWHEAD
b354			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b354					NEXTW 
b354 c3 82 9e			jp macro_next 
b357				endm 
# End of macro NEXTW
b357			.TZERO: 
b357				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b357 2e				db WORD_SYS_CORE+26             
b358 9e b3			dw .LESS            
b35a 03				db 2 + 1 
b35b .. 00			db "0=",0              
b35e				endm 
# End of macro CWHEAD
b35e			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b35e				; TODO add floating point number detection 
b35e					;v5 FORTH_DSP_VALUE 
b35e					if DEBUG_FORTH_WORDS_KEY 
b35e						DMARK "0=." 
b35e f5				push af  
b35f 3a 73 b3			ld a, (.dmark)  
b362 32 b7 ee			ld (debug_mark),a  
b365 3a 74 b3			ld a, (.dmark+1)  
b368 32 b8 ee			ld (debug_mark+1),a  
b36b 3a 75 b3			ld a, (.dmark+2)  
b36e 32 b9 ee			ld (debug_mark+2),a  
b371 18 03			jr .pastdmark  
b373 ..			.dmark: db "0=."  
b376 f1			.pastdmark: pop af  
b377			endm  
# End of macro DMARK
b377						CALLMONITOR 
b377 cd a3 94			call break_point_state  
b37a				endm  
# End of macro CALLMONITOR
b37a					endif 
b37a					FORTH_DSP 
b37a cd d1 9c			call macro_forth_dsp 
b37d				endm 
# End of macro FORTH_DSP
b37d 7e					ld a,(hl)	; get type of value on TOS 
b37e fe 02				cp DS_TYPE_INUM  
b380 28 00				jr z, .tz_inum 
b382			 
b382				if FORTH_ENABLE_FLOATMATH 
b382					jr .tz_done 
b382			 
b382				endif 
b382					 
b382			 
b382			.tz_inum: 
b382					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b382 cd 0b 9d			call macro_dsp_valuehl 
b385				endm 
# End of macro FORTH_DSP_VALUEHL
b385			 
b385			;		push hl 
b385			 
b385					; destroy value TOS 
b385			 
b385					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b385 cd c3 9d			call macro_forth_dsp_pop 
b388				endm 
# End of macro FORTH_DSP_POP
b388			 
b388			;		pop hl 
b388			 
b388 3e 00				ld a,0 
b38a			 
b38a bd					cp l 
b38b 20 08				jr nz, .tz_notzero 
b38d			 
b38d bc					cp h 
b38e			 
b38e 20 05				jr nz, .tz_notzero 
b390			 
b390			 
b390 21 01 00				ld hl, FORTH_TRUE 
b393 18 03				jr .tz_done 
b395			 
b395 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b398			 
b398					; push value back onto stack for another op etc 
b398			 
b398			.tz_done: 
b398 cd 14 9b				call forth_push_numhl 
b39b			 
b39b					NEXTW 
b39b c3 82 9e			jp macro_next 
b39e				endm 
# End of macro NEXTW
b39e			.LESS: 
b39e				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b39e 2f				db WORD_SYS_CORE+27             
b39f 07 b4			dw .GT            
b3a1 02				db 1 + 1 
b3a2 .. 00			db "<",0              
b3a4				endm 
# End of macro CWHEAD
b3a4			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b3a4				; TODO add floating point number detection 
b3a4					if DEBUG_FORTH_WORDS_KEY 
b3a4						DMARK "LES" 
b3a4 f5				push af  
b3a5 3a b9 b3			ld a, (.dmark)  
b3a8 32 b7 ee			ld (debug_mark),a  
b3ab 3a ba b3			ld a, (.dmark+1)  
b3ae 32 b8 ee			ld (debug_mark+1),a  
b3b1 3a bb b3			ld a, (.dmark+2)  
b3b4 32 b9 ee			ld (debug_mark+2),a  
b3b7 18 03			jr .pastdmark  
b3b9 ..			.dmark: db "LES"  
b3bc f1			.pastdmark: pop af  
b3bd			endm  
# End of macro DMARK
b3bd						CALLMONITOR 
b3bd cd a3 94			call break_point_state  
b3c0				endm  
# End of macro CALLMONITOR
b3c0					endif 
b3c0					FORTH_DSP 
b3c0 cd d1 9c			call macro_forth_dsp 
b3c3				endm 
# End of macro FORTH_DSP
b3c3					;v5 FORTH_DSP_VALUE 
b3c3 7e					ld a,(hl)	; get type of value on TOS 
b3c4 fe 02				cp DS_TYPE_INUM  
b3c6 28 00				jr z, .less_inum 
b3c8			 
b3c8				if FORTH_ENABLE_FLOATMATH 
b3c8					jr .less_done 
b3c8			 
b3c8				endif 
b3c8					 
b3c8			 
b3c8			.less_inum: 
b3c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3c8 cd 0b 9d			call macro_dsp_valuehl 
b3cb				endm 
# End of macro FORTH_DSP_VALUEHL
b3cb			 
b3cb e5					push hl  ; u2 
b3cc			 
b3cc					; destroy value TOS 
b3cc			 
b3cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3cc cd c3 9d			call macro_forth_dsp_pop 
b3cf				endm 
# End of macro FORTH_DSP_POP
b3cf			 
b3cf			 
b3cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3cf cd 0b 9d			call macro_dsp_valuehl 
b3d2				endm 
# End of macro FORTH_DSP_VALUEHL
b3d2			 
b3d2 e5					push hl    ; u1 
b3d3			 
b3d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3d3 cd c3 9d			call macro_forth_dsp_pop 
b3d6				endm 
# End of macro FORTH_DSP_POP
b3d6			 
b3d6			 
b3d6 b7			 or a      ;clear carry flag 
b3d7 01 00 00		 ld bc, FORTH_FALSE 
b3da e1			  pop hl    ; u1 
b3db d1			  pop de    ; u2 
b3dc ed 52		  sbc hl,de 
b3de 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b3e0			 
b3e0 01 01 00		 ld bc, FORTH_TRUE 
b3e3			.lscont:  
b3e3 c5					push bc 
b3e4 e1					pop hl 
b3e5			 
b3e5					if DEBUG_FORTH_WORDS 
b3e5						DMARK "LT1" 
b3e5 f5				push af  
b3e6 3a fa b3			ld a, (.dmark)  
b3e9 32 b7 ee			ld (debug_mark),a  
b3ec 3a fb b3			ld a, (.dmark+1)  
b3ef 32 b8 ee			ld (debug_mark+1),a  
b3f2 3a fc b3			ld a, (.dmark+2)  
b3f5 32 b9 ee			ld (debug_mark+2),a  
b3f8 18 03			jr .pastdmark  
b3fa ..			.dmark: db "LT1"  
b3fd f1			.pastdmark: pop af  
b3fe			endm  
# End of macro DMARK
b3fe						CALLMONITOR 
b3fe cd a3 94			call break_point_state  
b401				endm  
# End of macro CALLMONITOR
b401					endif 
b401 cd 14 9b				call forth_push_numhl 
b404			 
b404					NEXTW 
b404 c3 82 9e			jp macro_next 
b407				endm 
# End of macro NEXTW
b407			.GT: 
b407				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b407 30				db WORD_SYS_CORE+28             
b408 70 b4			dw .EQUAL            
b40a 02				db 1 + 1 
b40b .. 00			db ">",0              
b40d				endm 
# End of macro CWHEAD
b40d			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b40d				; TODO add floating point number detection 
b40d					if DEBUG_FORTH_WORDS_KEY 
b40d						DMARK "GRT" 
b40d f5				push af  
b40e 3a 22 b4			ld a, (.dmark)  
b411 32 b7 ee			ld (debug_mark),a  
b414 3a 23 b4			ld a, (.dmark+1)  
b417 32 b8 ee			ld (debug_mark+1),a  
b41a 3a 24 b4			ld a, (.dmark+2)  
b41d 32 b9 ee			ld (debug_mark+2),a  
b420 18 03			jr .pastdmark  
b422 ..			.dmark: db "GRT"  
b425 f1			.pastdmark: pop af  
b426			endm  
# End of macro DMARK
b426						CALLMONITOR 
b426 cd a3 94			call break_point_state  
b429				endm  
# End of macro CALLMONITOR
b429					endif 
b429					FORTH_DSP 
b429 cd d1 9c			call macro_forth_dsp 
b42c				endm 
# End of macro FORTH_DSP
b42c					;FORTH_DSP_VALUE 
b42c 7e					ld a,(hl)	; get type of value on TOS 
b42d fe 02				cp DS_TYPE_INUM  
b42f 28 00				jr z, .gt_inum 
b431			 
b431				if FORTH_ENABLE_FLOATMATH 
b431					jr .gt_done 
b431			 
b431				endif 
b431					 
b431			 
b431			.gt_inum: 
b431					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b431 cd 0b 9d			call macro_dsp_valuehl 
b434				endm 
# End of macro FORTH_DSP_VALUEHL
b434			 
b434 e5					push hl  ; u2 
b435			 
b435					; destroy value TOS 
b435			 
b435					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b435 cd c3 9d			call macro_forth_dsp_pop 
b438				endm 
# End of macro FORTH_DSP_POP
b438			 
b438			 
b438					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b438 cd 0b 9d			call macro_dsp_valuehl 
b43b				endm 
# End of macro FORTH_DSP_VALUEHL
b43b			 
b43b e5					push hl    ; u1 
b43c			 
b43c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b43c cd c3 9d			call macro_forth_dsp_pop 
b43f				endm 
# End of macro FORTH_DSP_POP
b43f			 
b43f			 
b43f b7			 or a      ;clear carry flag 
b440 01 00 00		 ld bc, FORTH_FALSE 
b443 e1			  pop hl    ; u1 
b444 d1			  pop de    ; u2 
b445 ed 52		  sbc hl,de 
b447 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b449			 
b449 01 01 00		 ld bc, FORTH_TRUE 
b44c			.gtcont:  
b44c c5					push bc 
b44d e1					pop hl 
b44e			 
b44e					if DEBUG_FORTH_WORDS 
b44e						DMARK "GT1" 
b44e f5				push af  
b44f 3a 63 b4			ld a, (.dmark)  
b452 32 b7 ee			ld (debug_mark),a  
b455 3a 64 b4			ld a, (.dmark+1)  
b458 32 b8 ee			ld (debug_mark+1),a  
b45b 3a 65 b4			ld a, (.dmark+2)  
b45e 32 b9 ee			ld (debug_mark+2),a  
b461 18 03			jr .pastdmark  
b463 ..			.dmark: db "GT1"  
b466 f1			.pastdmark: pop af  
b467			endm  
# End of macro DMARK
b467						CALLMONITOR 
b467 cd a3 94			call break_point_state  
b46a				endm  
# End of macro CALLMONITOR
b46a					endif 
b46a cd 14 9b				call forth_push_numhl 
b46d			 
b46d					NEXTW 
b46d c3 82 9e			jp macro_next 
b470				endm 
# End of macro NEXTW
b470			.EQUAL: 
b470				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b470 31				db WORD_SYS_CORE+29             
b471 db b4			dw .ENDLOGIC            
b473 02				db 1 + 1 
b474 .. 00			db "=",0              
b476				endm 
# End of macro CWHEAD
b476			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b476				; TODO add floating point number detection 
b476					if DEBUG_FORTH_WORDS_KEY 
b476						DMARK "EQ." 
b476 f5				push af  
b477 3a 8b b4			ld a, (.dmark)  
b47a 32 b7 ee			ld (debug_mark),a  
b47d 3a 8c b4			ld a, (.dmark+1)  
b480 32 b8 ee			ld (debug_mark+1),a  
b483 3a 8d b4			ld a, (.dmark+2)  
b486 32 b9 ee			ld (debug_mark+2),a  
b489 18 03			jr .pastdmark  
b48b ..			.dmark: db "EQ."  
b48e f1			.pastdmark: pop af  
b48f			endm  
# End of macro DMARK
b48f						CALLMONITOR 
b48f cd a3 94			call break_point_state  
b492				endm  
# End of macro CALLMONITOR
b492					endif 
b492					FORTH_DSP 
b492 cd d1 9c			call macro_forth_dsp 
b495				endm 
# End of macro FORTH_DSP
b495					;v5 FORTH_DSP_VALUE 
b495 7e					ld a,(hl)	; get type of value on TOS 
b496 fe 02				cp DS_TYPE_INUM  
b498 28 00				jr z, .eq_inum 
b49a			 
b49a				if FORTH_ENABLE_FLOATMATH 
b49a					jr .eq_done 
b49a			 
b49a				endif 
b49a					 
b49a			 
b49a			.eq_inum: 
b49a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b49a cd 0b 9d			call macro_dsp_valuehl 
b49d				endm 
# End of macro FORTH_DSP_VALUEHL
b49d			 
b49d e5					push hl 
b49e			 
b49e					; destroy value TOS 
b49e			 
b49e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b49e cd c3 9d			call macro_forth_dsp_pop 
b4a1				endm 
# End of macro FORTH_DSP_POP
b4a1			 
b4a1			 
b4a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4a1 cd 0b 9d			call macro_dsp_valuehl 
b4a4				endm 
# End of macro FORTH_DSP_VALUEHL
b4a4			 
b4a4					; one value on hl get other one back 
b4a4			 
b4a4 e5					push hl 
b4a5			 
b4a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4a5 cd c3 9d			call macro_forth_dsp_pop 
b4a8				endm 
# End of macro FORTH_DSP_POP
b4a8			 
b4a8 0e 00				ld c, FORTH_FALSE 
b4aa			 
b4aa e1					pop hl 
b4ab d1					pop de 
b4ac			 
b4ac 7b					ld a, e 
b4ad bd					cp l 
b4ae			 
b4ae 20 06				jr nz, .eq_done 
b4b0			 
b4b0 7a					ld a, d 
b4b1 bc					cp h 
b4b2			 
b4b2 20 02				jr nz, .eq_done 
b4b4			 
b4b4 0e 01				ld c, FORTH_TRUE 
b4b6					 
b4b6			 
b4b6			 
b4b6			.eq_done: 
b4b6			 
b4b6					; TODO push value back onto stack for another op etc 
b4b6			 
b4b6 26 00				ld h, 0 
b4b8 69					ld l, c 
b4b9					if DEBUG_FORTH_WORDS 
b4b9						DMARK "EQ1" 
b4b9 f5				push af  
b4ba 3a ce b4			ld a, (.dmark)  
b4bd 32 b7 ee			ld (debug_mark),a  
b4c0 3a cf b4			ld a, (.dmark+1)  
b4c3 32 b8 ee			ld (debug_mark+1),a  
b4c6 3a d0 b4			ld a, (.dmark+2)  
b4c9 32 b9 ee			ld (debug_mark+2),a  
b4cc 18 03			jr .pastdmark  
b4ce ..			.dmark: db "EQ1"  
b4d1 f1			.pastdmark: pop af  
b4d2			endm  
# End of macro DMARK
b4d2						CALLMONITOR 
b4d2 cd a3 94			call break_point_state  
b4d5				endm  
# End of macro CALLMONITOR
b4d5					endif 
b4d5 cd 14 9b				call forth_push_numhl 
b4d8			 
b4d8					NEXTW 
b4d8 c3 82 9e			jp macro_next 
b4db				endm 
# End of macro NEXTW
b4db			 
b4db			 
b4db			.ENDLOGIC: 
b4db			; eof 
b4db			 
b4db			 
# End of file forth_words_logic.asm
b4db			include "forth_words_maths.asm" 
b4db			 
b4db			; | ## Maths Words 
b4db			 
b4db			.PLUS:	 
b4db				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b4db 15				db WORD_SYS_CORE+1             
b4dc 1d b5			dw .NEG            
b4de 02				db 1 + 1 
b4df .. 00			db "+",0              
b4e1				endm 
# End of macro CWHEAD
b4e1			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b4e1					if DEBUG_FORTH_WORDS_KEY 
b4e1						DMARK "PLU" 
b4e1 f5				push af  
b4e2 3a f6 b4			ld a, (.dmark)  
b4e5 32 b7 ee			ld (debug_mark),a  
b4e8 3a f7 b4			ld a, (.dmark+1)  
b4eb 32 b8 ee			ld (debug_mark+1),a  
b4ee 3a f8 b4			ld a, (.dmark+2)  
b4f1 32 b9 ee			ld (debug_mark+2),a  
b4f4 18 03			jr .pastdmark  
b4f6 ..			.dmark: db "PLU"  
b4f9 f1			.pastdmark: pop af  
b4fa			endm  
# End of macro DMARK
b4fa						CALLMONITOR 
b4fa cd a3 94			call break_point_state  
b4fd				endm  
# End of macro CALLMONITOR
b4fd					endif 
b4fd					; add top two values and push back result 
b4fd			 
b4fd					;for v5 FORTH_DSP_VALUE 
b4fd					FORTH_DSP 
b4fd cd d1 9c			call macro_forth_dsp 
b500				endm 
# End of macro FORTH_DSP
b500 7e					ld a,(hl)	; get type of value on TOS 
b501 fe 02				cp DS_TYPE_INUM  
b503 28 03				jr z, .dot_inum 
b505			 
b505					NEXTW 
b505 c3 82 9e			jp macro_next 
b508				endm 
# End of macro NEXTW
b508			 
b508			; float maths 
b508			 
b508				if FORTH_ENABLE_FLOATMATH 
b508						inc hl      ; now at start of numeric as string 
b508			 
b508					if DEBUG_FORTH_MATHS 
b508						DMARK "ADD" 
b508				CALLMONITOR 
b508					endif 
b508			 
b508					;ld ix, hl 
b508					call CON 
b508			 
b508			 
b508					push hl 
b508					 
b508					 
b508			 
b508						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b508			 
b508					; get next number 
b508			 
b508						FORTH_DSP_VALUE 
b508			 
b508						inc hl      ; now at start of numeric as string 
b508			 
b508					;ld ix, hl 
b508					call CON 
b508			 
b508					push hl 
b508			 
b508			 
b508						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b508			 
b508						; TODO do add 
b508			 
b508						call IADD 
b508			 
b508						; TODO get result back as ascii 
b508			 
b508						; TODO push result  
b508			 
b508			 
b508			 
b508						jr .dot_done 
b508				endif 
b508			 
b508			.dot_inum: 
b508			 
b508			 
b508					if DEBUG_FORTH_DOT 
b508						DMARK "+IT" 
b508				CALLMONITOR 
b508					endif 
b508			 
b508					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b508 cd 0b 9d			call macro_dsp_valuehl 
b50b				endm 
# End of macro FORTH_DSP_VALUEHL
b50b			 
b50b				; TODO add floating point number detection 
b50b			 
b50b e5					push hl 
b50c			 
b50c					; destroy value TOS 
b50c			 
b50c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b50c cd c3 9d			call macro_forth_dsp_pop 
b50f				endm 
# End of macro FORTH_DSP_POP
b50f			 
b50f			 
b50f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b50f cd 0b 9d			call macro_dsp_valuehl 
b512				endm 
# End of macro FORTH_DSP_VALUEHL
b512			 
b512					; one value on hl get other one back 
b512			 
b512 d1					pop de 
b513			 
b513					; do the add 
b513			 
b513 19					add hl,de 
b514			 
b514					; save it 
b514			 
b514			;		push hl	 
b514			 
b514					; 
b514			 
b514					; destroy value TOS 
b514			 
b514					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b514 cd c3 9d			call macro_forth_dsp_pop 
b517				endm 
# End of macro FORTH_DSP_POP
b517			 
b517					; TODO push value back onto stack for another op etc 
b517			 
b517			;		pop hl 
b517			 
b517			.dot_done: 
b517 cd 14 9b				call forth_push_numhl 
b51a			 
b51a					NEXTW 
b51a c3 82 9e			jp macro_next 
b51d				endm 
# End of macro NEXTW
b51d			.NEG: 
b51d			 
b51d				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b51d 17				db WORD_SYS_CORE+3             
b51e 60 b5			dw .DIV            
b520 02				db 1 + 1 
b521 .. 00			db "-",0              
b523				endm 
# End of macro CWHEAD
b523			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b523					if DEBUG_FORTH_WORDS_KEY 
b523						DMARK "SUB" 
b523 f5				push af  
b524 3a 38 b5			ld a, (.dmark)  
b527 32 b7 ee			ld (debug_mark),a  
b52a 3a 39 b5			ld a, (.dmark+1)  
b52d 32 b8 ee			ld (debug_mark+1),a  
b530 3a 3a b5			ld a, (.dmark+2)  
b533 32 b9 ee			ld (debug_mark+2),a  
b536 18 03			jr .pastdmark  
b538 ..			.dmark: db "SUB"  
b53b f1			.pastdmark: pop af  
b53c			endm  
# End of macro DMARK
b53c						CALLMONITOR 
b53c cd a3 94			call break_point_state  
b53f				endm  
# End of macro CALLMONITOR
b53f					endif 
b53f			 
b53f			 
b53f				; TODO add floating point number detection 
b53f					; v5 FORTH_DSP_VALUE 
b53f					FORTH_DSP 
b53f cd d1 9c			call macro_forth_dsp 
b542				endm 
# End of macro FORTH_DSP
b542 7e					ld a,(hl)	; get type of value on TOS 
b543 fe 02				cp DS_TYPE_INUM  
b545 28 03				jr z, .neg_inum 
b547			 
b547					NEXTW 
b547 c3 82 9e			jp macro_next 
b54a				endm 
# End of macro NEXTW
b54a			 
b54a			; float maths 
b54a			 
b54a				if FORTH_ENABLE_FLOATMATH 
b54a					jr .neg_done 
b54a			 
b54a				endif 
b54a					 
b54a			 
b54a			.neg_inum: 
b54a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b54a cd 0b 9d			call macro_dsp_valuehl 
b54d				endm 
# End of macro FORTH_DSP_VALUEHL
b54d			 
b54d e5					push hl 
b54e			 
b54e					; destroy value TOS 
b54e			 
b54e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b54e cd c3 9d			call macro_forth_dsp_pop 
b551				endm 
# End of macro FORTH_DSP_POP
b551			 
b551			 
b551					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b551 cd 0b 9d			call macro_dsp_valuehl 
b554				endm 
# End of macro FORTH_DSP_VALUEHL
b554			 
b554					; one value on hl get other one back 
b554			 
b554 d1					pop de 
b555			 
b555					; do the sub 
b555			;		ex de, hl 
b555			 
b555 ed 52				sbc hl,de 
b557			 
b557					; save it 
b557			 
b557			;		push hl	 
b557			 
b557					; 
b557			 
b557					; destroy value TOS 
b557			 
b557					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b557 cd c3 9d			call macro_forth_dsp_pop 
b55a				endm 
# End of macro FORTH_DSP_POP
b55a			 
b55a					; TODO push value back onto stack for another op etc 
b55a			 
b55a			;		pop hl 
b55a			 
b55a cd 14 9b				call forth_push_numhl 
b55d			.neg_done: 
b55d			 
b55d					NEXTW 
b55d c3 82 9e			jp macro_next 
b560				endm 
# End of macro NEXTW
b560			.DIV: 
b560				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b560 18				db WORD_SYS_CORE+4             
b561 ad b5			dw .MUL            
b563 02				db 1 + 1 
b564 .. 00			db "/",0              
b566				endm 
# End of macro CWHEAD
b566			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b566					if DEBUG_FORTH_WORDS_KEY 
b566						DMARK "DIV" 
b566 f5				push af  
b567 3a 7b b5			ld a, (.dmark)  
b56a 32 b7 ee			ld (debug_mark),a  
b56d 3a 7c b5			ld a, (.dmark+1)  
b570 32 b8 ee			ld (debug_mark+1),a  
b573 3a 7d b5			ld a, (.dmark+2)  
b576 32 b9 ee			ld (debug_mark+2),a  
b579 18 03			jr .pastdmark  
b57b ..			.dmark: db "DIV"  
b57e f1			.pastdmark: pop af  
b57f			endm  
# End of macro DMARK
b57f						CALLMONITOR 
b57f cd a3 94			call break_point_state  
b582				endm  
# End of macro CALLMONITOR
b582					endif 
b582				; TODO add floating point number detection 
b582					; v5 FORTH_DSP_VALUE 
b582					FORTH_DSP 
b582 cd d1 9c			call macro_forth_dsp 
b585				endm 
# End of macro FORTH_DSP
b585 7e					ld a,(hl)	; get type of value on TOS 
b586 fe 02				cp DS_TYPE_INUM  
b588 28 03				jr z, .div_inum 
b58a			 
b58a				if FORTH_ENABLE_FLOATMATH 
b58a					jr .div_done 
b58a			 
b58a				endif 
b58a					NEXTW 
b58a c3 82 9e			jp macro_next 
b58d				endm 
# End of macro NEXTW
b58d			.div_inum: 
b58d			 
b58d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b58d cd 0b 9d			call macro_dsp_valuehl 
b590				endm 
# End of macro FORTH_DSP_VALUEHL
b590			 
b590 e5					push hl    ; to go to bc 
b591			 
b591					; destroy value TOS 
b591			 
b591					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b591 cd c3 9d			call macro_forth_dsp_pop 
b594				endm 
# End of macro FORTH_DSP_POP
b594			 
b594			 
b594					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b594 cd 0b 9d			call macro_dsp_valuehl 
b597				endm 
# End of macro FORTH_DSP_VALUEHL
b597			 
b597					; hl to go to de 
b597			 
b597 e5					push hl 
b598			 
b598 c1					pop bc 
b599 d1					pop de		 
b59a			 
b59a			 
b59a					if DEBUG_FORTH_MATHS 
b59a						DMARK "DIV" 
b59a				CALLMONITOR 
b59a					endif 
b59a					; one value on hl but move to a get other one back 
b59a			 
b59a			        
b59a cd ff 8b			call Div16 
b59d			 
b59d			;	push af	 
b59d e5				push hl 
b59e c5				push bc 
b59f			 
b59f					if DEBUG_FORTH_MATHS 
b59f						DMARK "DI1" 
b59f				CALLMONITOR 
b59f					endif 
b59f			 
b59f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b59f cd c3 9d			call macro_forth_dsp_pop 
b5a2				endm 
# End of macro FORTH_DSP_POP
b5a2			 
b5a2			 
b5a2			 
b5a2 e1					pop hl    ; result 
b5a3			 
b5a3 cd 14 9b				call forth_push_numhl 
b5a6			 
b5a6 e1					pop hl    ; reminder 
b5a7			;		ld h,0 
b5a7			;		ld l,d 
b5a7			 
b5a7 cd 14 9b				call forth_push_numhl 
b5aa			.div_done: 
b5aa					NEXTW 
b5aa c3 82 9e			jp macro_next 
b5ad				endm 
# End of macro NEXTW
b5ad			.MUL: 
b5ad				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b5ad 19				db WORD_SYS_CORE+5             
b5ae f2 b5			dw .MIN            
b5b0 02				db 1 + 1 
b5b1 .. 00			db "*",0              
b5b3				endm 
# End of macro CWHEAD
b5b3			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b5b3				; TODO add floating point number detection 
b5b3					if DEBUG_FORTH_WORDS_KEY 
b5b3						DMARK "MUL" 
b5b3 f5				push af  
b5b4 3a c8 b5			ld a, (.dmark)  
b5b7 32 b7 ee			ld (debug_mark),a  
b5ba 3a c9 b5			ld a, (.dmark+1)  
b5bd 32 b8 ee			ld (debug_mark+1),a  
b5c0 3a ca b5			ld a, (.dmark+2)  
b5c3 32 b9 ee			ld (debug_mark+2),a  
b5c6 18 03			jr .pastdmark  
b5c8 ..			.dmark: db "MUL"  
b5cb f1			.pastdmark: pop af  
b5cc			endm  
# End of macro DMARK
b5cc						CALLMONITOR 
b5cc cd a3 94			call break_point_state  
b5cf				endm  
# End of macro CALLMONITOR
b5cf					endif 
b5cf					FORTH_DSP 
b5cf cd d1 9c			call macro_forth_dsp 
b5d2				endm 
# End of macro FORTH_DSP
b5d2					; v5 FORTH_DSP_VALUE 
b5d2 7e					ld a,(hl)	; get type of value on TOS 
b5d3 fe 02				cp DS_TYPE_INUM  
b5d5 28 03				jr z, .mul_inum 
b5d7			 
b5d7				if FORTH_ENABLE_FLOATMATH 
b5d7					jr .mul_done 
b5d7			 
b5d7				endif 
b5d7			 
b5d7					NEXTW 
b5d7 c3 82 9e			jp macro_next 
b5da				endm 
# End of macro NEXTW
b5da			.mul_inum:	 
b5da			 
b5da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5da cd 0b 9d			call macro_dsp_valuehl 
b5dd				endm 
# End of macro FORTH_DSP_VALUEHL
b5dd			 
b5dd e5					push hl 
b5de			 
b5de					; destroy value TOS 
b5de			 
b5de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5de cd c3 9d			call macro_forth_dsp_pop 
b5e1				endm 
# End of macro FORTH_DSP_POP
b5e1			 
b5e1			 
b5e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5e1 cd 0b 9d			call macro_dsp_valuehl 
b5e4				endm 
# End of macro FORTH_DSP_VALUEHL
b5e4			 
b5e4					; one value on hl but move to a get other one back 
b5e4			 
b5e4 7d					ld a, l 
b5e5			 
b5e5 d1					pop de 
b5e6			 
b5e6					; do the mull 
b5e6			;		ex de, hl 
b5e6			 
b5e6 cd 25 8c				call Mult16 
b5e9					; save it 
b5e9			 
b5e9			;		push hl	 
b5e9			 
b5e9					; 
b5e9			 
b5e9					; destroy value TOS 
b5e9			 
b5e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5e9 cd c3 9d			call macro_forth_dsp_pop 
b5ec				endm 
# End of macro FORTH_DSP_POP
b5ec			 
b5ec					; TODO push value back onto stack for another op etc 
b5ec			 
b5ec			;		pop hl 
b5ec			 
b5ec cd 14 9b				call forth_push_numhl 
b5ef			 
b5ef			.mul_done: 
b5ef					NEXTW 
b5ef c3 82 9e			jp macro_next 
b5f2				endm 
# End of macro NEXTW
b5f2			 
b5f2			 
b5f2			 
b5f2			 
b5f2			.MIN: 
b5f2				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b5f2 49				db WORD_SYS_CORE+53             
b5f3 73 b6			dw .MAX            
b5f5 04				db 3 + 1 
b5f6 .. 00			db "MIN",0              
b5fa				endm 
# End of macro CWHEAD
b5fa			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b5fa					if DEBUG_FORTH_WORDS_KEY 
b5fa						DMARK "MIN" 
b5fa f5				push af  
b5fb 3a 0f b6			ld a, (.dmark)  
b5fe 32 b7 ee			ld (debug_mark),a  
b601 3a 10 b6			ld a, (.dmark+1)  
b604 32 b8 ee			ld (debug_mark+1),a  
b607 3a 11 b6			ld a, (.dmark+2)  
b60a 32 b9 ee			ld (debug_mark+2),a  
b60d 18 03			jr .pastdmark  
b60f ..			.dmark: db "MIN"  
b612 f1			.pastdmark: pop af  
b613			endm  
# End of macro DMARK
b613						CALLMONITOR 
b613 cd a3 94			call break_point_state  
b616				endm  
# End of macro CALLMONITOR
b616					endif 
b616					; get u2 
b616			 
b616					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b616 cd 0b 9d			call macro_dsp_valuehl 
b619				endm 
# End of macro FORTH_DSP_VALUEHL
b619			 
b619 e5					push hl   ; u2 
b61a			 
b61a					; destroy value TOS 
b61a			 
b61a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b61a cd c3 9d			call macro_forth_dsp_pop 
b61d				endm 
# End of macro FORTH_DSP_POP
b61d			 
b61d					; get u1 
b61d			 
b61d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b61d cd 0b 9d			call macro_dsp_valuehl 
b620				endm 
# End of macro FORTH_DSP_VALUEHL
b620			 
b620 e5					push hl  ; u1 
b621			 
b621					; destroy value TOS 
b621			 
b621					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b621 cd c3 9d			call macro_forth_dsp_pop 
b624				endm 
# End of macro FORTH_DSP_POP
b624			 
b624 b7			 or a      ;clear carry flag 
b625 e1			  pop hl    ; u1 
b626 d1			  pop de    ; u2 
b627 e5				push hl   ; saved in case hl is lowest 
b628 ed 52		  sbc hl,de 
b62a 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b62c			 
b62c e1				pop hl 
b62d					if DEBUG_FORTH_WORDS 
b62d						DMARK "MIN" 
b62d f5				push af  
b62e 3a 42 b6			ld a, (.dmark)  
b631 32 b7 ee			ld (debug_mark),a  
b634 3a 43 b6			ld a, (.dmark+1)  
b637 32 b8 ee			ld (debug_mark+1),a  
b63a 3a 44 b6			ld a, (.dmark+2)  
b63d 32 b9 ee			ld (debug_mark+2),a  
b640 18 03			jr .pastdmark  
b642 ..			.dmark: db "MIN"  
b645 f1			.pastdmark: pop af  
b646			endm  
# End of macro DMARK
b646						CALLMONITOR 
b646 cd a3 94			call break_point_state  
b649				endm  
# End of macro CALLMONITOR
b649					endif 
b649 cd 14 9b				call forth_push_numhl 
b64c			 
b64c				       NEXTW 
b64c c3 82 9e			jp macro_next 
b64f				endm 
# End of macro NEXTW
b64f			 
b64f			.mincont:  
b64f c1				pop bc   ; tidy up 
b650 eb				ex de , hl  
b651					if DEBUG_FORTH_WORDS 
b651						DMARK "MI1" 
b651 f5				push af  
b652 3a 66 b6			ld a, (.dmark)  
b655 32 b7 ee			ld (debug_mark),a  
b658 3a 67 b6			ld a, (.dmark+1)  
b65b 32 b8 ee			ld (debug_mark+1),a  
b65e 3a 68 b6			ld a, (.dmark+2)  
b661 32 b9 ee			ld (debug_mark+2),a  
b664 18 03			jr .pastdmark  
b666 ..			.dmark: db "MI1"  
b669 f1			.pastdmark: pop af  
b66a			endm  
# End of macro DMARK
b66a						CALLMONITOR 
b66a cd a3 94			call break_point_state  
b66d				endm  
# End of macro CALLMONITOR
b66d					endif 
b66d cd 14 9b				call forth_push_numhl 
b670			 
b670				       NEXTW 
b670 c3 82 9e			jp macro_next 
b673				endm 
# End of macro NEXTW
b673			.MAX: 
b673				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b673 4a				db WORD_SYS_CORE+54             
b674 f4 b6			dw .RND16            
b676 04				db 3 + 1 
b677 .. 00			db "MAX",0              
b67b				endm 
# End of macro CWHEAD
b67b			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b67b					if DEBUG_FORTH_WORDS_KEY 
b67b						DMARK "MAX" 
b67b f5				push af  
b67c 3a 90 b6			ld a, (.dmark)  
b67f 32 b7 ee			ld (debug_mark),a  
b682 3a 91 b6			ld a, (.dmark+1)  
b685 32 b8 ee			ld (debug_mark+1),a  
b688 3a 92 b6			ld a, (.dmark+2)  
b68b 32 b9 ee			ld (debug_mark+2),a  
b68e 18 03			jr .pastdmark  
b690 ..			.dmark: db "MAX"  
b693 f1			.pastdmark: pop af  
b694			endm  
# End of macro DMARK
b694						CALLMONITOR 
b694 cd a3 94			call break_point_state  
b697				endm  
# End of macro CALLMONITOR
b697					endif 
b697					; get u2 
b697			 
b697					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b697 cd 0b 9d			call macro_dsp_valuehl 
b69a				endm 
# End of macro FORTH_DSP_VALUEHL
b69a			 
b69a e5					push hl   ; u2 
b69b			 
b69b					; destroy value TOS 
b69b			 
b69b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b69b cd c3 9d			call macro_forth_dsp_pop 
b69e				endm 
# End of macro FORTH_DSP_POP
b69e			 
b69e					; get u1 
b69e			 
b69e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b69e cd 0b 9d			call macro_dsp_valuehl 
b6a1				endm 
# End of macro FORTH_DSP_VALUEHL
b6a1			 
b6a1 e5					push hl  ; u1 
b6a2			 
b6a2					; destroy value TOS 
b6a2			 
b6a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6a2 cd c3 9d			call macro_forth_dsp_pop 
b6a5				endm 
# End of macro FORTH_DSP_POP
b6a5			 
b6a5 b7			 or a      ;clear carry flag 
b6a6 e1			  pop hl    ; u1 
b6a7 d1			  pop de    ; u2 
b6a8 e5				push hl   ; saved in case hl is lowest 
b6a9 ed 52		  sbc hl,de 
b6ab 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b6ad			 
b6ad e1				pop hl 
b6ae					if DEBUG_FORTH_WORDS 
b6ae						DMARK "MAX" 
b6ae f5				push af  
b6af 3a c3 b6			ld a, (.dmark)  
b6b2 32 b7 ee			ld (debug_mark),a  
b6b5 3a c4 b6			ld a, (.dmark+1)  
b6b8 32 b8 ee			ld (debug_mark+1),a  
b6bb 3a c5 b6			ld a, (.dmark+2)  
b6be 32 b9 ee			ld (debug_mark+2),a  
b6c1 18 03			jr .pastdmark  
b6c3 ..			.dmark: db "MAX"  
b6c6 f1			.pastdmark: pop af  
b6c7			endm  
# End of macro DMARK
b6c7						CALLMONITOR 
b6c7 cd a3 94			call break_point_state  
b6ca				endm  
# End of macro CALLMONITOR
b6ca					endif 
b6ca cd 14 9b				call forth_push_numhl 
b6cd			 
b6cd				       NEXTW 
b6cd c3 82 9e			jp macro_next 
b6d0				endm 
# End of macro NEXTW
b6d0			 
b6d0			.maxcont:  
b6d0 c1				pop bc   ; tidy up 
b6d1 eb				ex de , hl  
b6d2					if DEBUG_FORTH_WORDS 
b6d2						DMARK "MA1" 
b6d2 f5				push af  
b6d3 3a e7 b6			ld a, (.dmark)  
b6d6 32 b7 ee			ld (debug_mark),a  
b6d9 3a e8 b6			ld a, (.dmark+1)  
b6dc 32 b8 ee			ld (debug_mark+1),a  
b6df 3a e9 b6			ld a, (.dmark+2)  
b6e2 32 b9 ee			ld (debug_mark+2),a  
b6e5 18 03			jr .pastdmark  
b6e7 ..			.dmark: db "MA1"  
b6ea f1			.pastdmark: pop af  
b6eb			endm  
# End of macro DMARK
b6eb						CALLMONITOR 
b6eb cd a3 94			call break_point_state  
b6ee				endm  
# End of macro CALLMONITOR
b6ee					endif 
b6ee cd 14 9b				call forth_push_numhl 
b6f1				       NEXTW 
b6f1 c3 82 9e			jp macro_next 
b6f4				endm 
# End of macro NEXTW
b6f4			 
b6f4			.RND16: 
b6f4				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b6f4 4e				db WORD_SYS_CORE+58             
b6f5 23 b7			dw .RND8            
b6f7 06				db 5 + 1 
b6f8 .. 00			db "RND16",0              
b6fe				endm 
# End of macro CWHEAD
b6fe			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b6fe					if DEBUG_FORTH_WORDS_KEY 
b6fe						DMARK "R16" 
b6fe f5				push af  
b6ff 3a 13 b7			ld a, (.dmark)  
b702 32 b7 ee			ld (debug_mark),a  
b705 3a 14 b7			ld a, (.dmark+1)  
b708 32 b8 ee			ld (debug_mark+1),a  
b70b 3a 15 b7			ld a, (.dmark+2)  
b70e 32 b9 ee			ld (debug_mark+2),a  
b711 18 03			jr .pastdmark  
b713 ..			.dmark: db "R16"  
b716 f1			.pastdmark: pop af  
b717			endm  
# End of macro DMARK
b717						CALLMONITOR 
b717 cd a3 94			call break_point_state  
b71a				endm  
# End of macro CALLMONITOR
b71a					endif 
b71a cd c9 8b				call prng16  
b71d cd 14 9b				call forth_push_numhl 
b720				       NEXTW 
b720 c3 82 9e			jp macro_next 
b723				endm 
# End of macro NEXTW
b723			.RND8: 
b723				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b723 60				db WORD_SYS_CORE+76             
b724 58 b7			dw .RND            
b726 05				db 4 + 1 
b727 .. 00			db "RND8",0              
b72c				endm 
# End of macro CWHEAD
b72c			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b72c					if DEBUG_FORTH_WORDS_KEY 
b72c						DMARK "RN8" 
b72c f5				push af  
b72d 3a 41 b7			ld a, (.dmark)  
b730 32 b7 ee			ld (debug_mark),a  
b733 3a 42 b7			ld a, (.dmark+1)  
b736 32 b8 ee			ld (debug_mark+1),a  
b739 3a 43 b7			ld a, (.dmark+2)  
b73c 32 b9 ee			ld (debug_mark+2),a  
b73f 18 03			jr .pastdmark  
b741 ..			.dmark: db "RN8"  
b744 f1			.pastdmark: pop af  
b745			endm  
# End of macro DMARK
b745						CALLMONITOR 
b745 cd a3 94			call break_point_state  
b748				endm  
# End of macro CALLMONITOR
b748					endif 
b748 2a 38 ed				ld hl,(xrandc) 
b74b 23					inc hl 
b74c cd e3 8b				call xrnd 
b74f 6f					ld l,a	 
b750 26 00				ld h,0 
b752 cd 14 9b				call forth_push_numhl 
b755				       NEXTW 
b755 c3 82 9e			jp macro_next 
b758				endm 
# End of macro NEXTW
b758			.RND: 
b758				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b758 60				db WORD_SYS_CORE+76             
b759 5e b8			dw .ENDMATHS            
b75b 04				db 3 + 1 
b75c .. 00			db "RND",0              
b760				endm 
# End of macro CWHEAD
b760			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b760			 
b760					if DEBUG_FORTH_WORDS_KEY 
b760						DMARK "RND" 
b760 f5				push af  
b761 3a 75 b7			ld a, (.dmark)  
b764 32 b7 ee			ld (debug_mark),a  
b767 3a 76 b7			ld a, (.dmark+1)  
b76a 32 b8 ee			ld (debug_mark+1),a  
b76d 3a 77 b7			ld a, (.dmark+2)  
b770 32 b9 ee			ld (debug_mark+2),a  
b773 18 03			jr .pastdmark  
b775 ..			.dmark: db "RND"  
b778 f1			.pastdmark: pop af  
b779			endm  
# End of macro DMARK
b779						CALLMONITOR 
b779 cd a3 94			call break_point_state  
b77c				endm  
# End of macro CALLMONITOR
b77c					endif 
b77c					 
b77c					FORTH_DSP_VALUEHL    ; upper range 
b77c cd 0b 9d			call macro_dsp_valuehl 
b77f				endm 
# End of macro FORTH_DSP_VALUEHL
b77f			 
b77f 22 3c ed				ld (LFSRSeed), hl	 
b782			 
b782					if DEBUG_FORTH_WORDS 
b782						DMARK "RN1" 
b782 f5				push af  
b783 3a 97 b7			ld a, (.dmark)  
b786 32 b7 ee			ld (debug_mark),a  
b789 3a 98 b7			ld a, (.dmark+1)  
b78c 32 b8 ee			ld (debug_mark+1),a  
b78f 3a 99 b7			ld a, (.dmark+2)  
b792 32 b9 ee			ld (debug_mark+2),a  
b795 18 03			jr .pastdmark  
b797 ..			.dmark: db "RN1"  
b79a f1			.pastdmark: pop af  
b79b			endm  
# End of macro DMARK
b79b						CALLMONITOR 
b79b cd a3 94			call break_point_state  
b79e				endm  
# End of macro CALLMONITOR
b79e					endif 
b79e					FORTH_DSP_POP 
b79e cd c3 9d			call macro_forth_dsp_pop 
b7a1				endm 
# End of macro FORTH_DSP_POP
b7a1			 
b7a1					FORTH_DSP_VALUEHL    ; low range 
b7a1 cd 0b 9d			call macro_dsp_valuehl 
b7a4				endm 
# End of macro FORTH_DSP_VALUEHL
b7a4			 
b7a4					if DEBUG_FORTH_WORDS 
b7a4						DMARK "RN2" 
b7a4 f5				push af  
b7a5 3a b9 b7			ld a, (.dmark)  
b7a8 32 b7 ee			ld (debug_mark),a  
b7ab 3a ba b7			ld a, (.dmark+1)  
b7ae 32 b8 ee			ld (debug_mark+1),a  
b7b1 3a bb b7			ld a, (.dmark+2)  
b7b4 32 b9 ee			ld (debug_mark+2),a  
b7b7 18 03			jr .pastdmark  
b7b9 ..			.dmark: db "RN2"  
b7bc f1			.pastdmark: pop af  
b7bd			endm  
# End of macro DMARK
b7bd						CALLMONITOR 
b7bd cd a3 94			call break_point_state  
b7c0				endm  
# End of macro CALLMONITOR
b7c0					endif 
b7c0 22 3e ed				ld (LFSRSeed+2), hl 
b7c3			 
b7c3					FORTH_DSP_POP 
b7c3 cd c3 9d			call macro_forth_dsp_pop 
b7c6				endm 
# End of macro FORTH_DSP_POP
b7c6			 
b7c6 e5					push hl 
b7c7			 
b7c7 e1			.inrange:	pop hl 
b7c8 cd c9 8b				call prng16  
b7cb					if DEBUG_FORTH_WORDS 
b7cb						DMARK "RN3" 
b7cb f5				push af  
b7cc 3a e0 b7			ld a, (.dmark)  
b7cf 32 b7 ee			ld (debug_mark),a  
b7d2 3a e1 b7			ld a, (.dmark+1)  
b7d5 32 b8 ee			ld (debug_mark+1),a  
b7d8 3a e2 b7			ld a, (.dmark+2)  
b7db 32 b9 ee			ld (debug_mark+2),a  
b7de 18 03			jr .pastdmark  
b7e0 ..			.dmark: db "RN3"  
b7e3 f1			.pastdmark: pop af  
b7e4			endm  
# End of macro DMARK
b7e4						CALLMONITOR 
b7e4 cd a3 94			call break_point_state  
b7e7				endm  
# End of macro CALLMONITOR
b7e7					endif 
b7e7					 
b7e7					; if the range is 8bit knock out the high byte 
b7e7			 
b7e7 ed 5b 3c ed			ld de, (LFSRSeed)     ; check high level 
b7eb			 
b7eb 3e 00				ld a, 0 
b7ed ba					cp d  
b7ee 20 1e				jr nz, .hirange 
b7f0 26 00				ld h, 0   ; knock it down to 8bit 
b7f2			 
b7f2					if DEBUG_FORTH_WORDS 
b7f2						DMARK "RNk" 
b7f2 f5				push af  
b7f3 3a 07 b8			ld a, (.dmark)  
b7f6 32 b7 ee			ld (debug_mark),a  
b7f9 3a 08 b8			ld a, (.dmark+1)  
b7fc 32 b8 ee			ld (debug_mark+1),a  
b7ff 3a 09 b8			ld a, (.dmark+2)  
b802 32 b9 ee			ld (debug_mark+2),a  
b805 18 03			jr .pastdmark  
b807 ..			.dmark: db "RNk"  
b80a f1			.pastdmark: pop af  
b80b			endm  
# End of macro DMARK
b80b						CALLMONITOR 
b80b cd a3 94			call break_point_state  
b80e				endm  
# End of macro CALLMONITOR
b80e					endif 
b80e			.hirange:   
b80e e5					push hl  
b80f b7					or a  
b810 ed 52		                sbc hl, de 
b812			 
b812					;call cmp16 
b812			 
b812 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b814 e1					pop hl 
b815 e5					push hl 
b816			 
b816					if DEBUG_FORTH_WORDS 
b816						DMARK "RN4" 
b816 f5				push af  
b817 3a 2b b8			ld a, (.dmark)  
b81a 32 b7 ee			ld (debug_mark),a  
b81d 3a 2c b8			ld a, (.dmark+1)  
b820 32 b8 ee			ld (debug_mark+1),a  
b823 3a 2d b8			ld a, (.dmark+2)  
b826 32 b9 ee			ld (debug_mark+2),a  
b829 18 03			jr .pastdmark  
b82b ..			.dmark: db "RN4"  
b82e f1			.pastdmark: pop af  
b82f			endm  
# End of macro DMARK
b82f						CALLMONITOR 
b82f cd a3 94			call break_point_state  
b832				endm  
# End of macro CALLMONITOR
b832					endif 
b832 ed 5b 3e ed			ld de, (LFSRSeed+2)   ; check low range 
b836					;call cmp16 
b836				 
b836 b7					or a  
b837 ed 52		                sbc hl, de 
b839 38 8c				jr c, .inrange 
b83b			 
b83b e1					pop hl 
b83c					 
b83c					if DEBUG_FORTH_WORDS 
b83c						DMARK "RNd" 
b83c f5				push af  
b83d 3a 51 b8			ld a, (.dmark)  
b840 32 b7 ee			ld (debug_mark),a  
b843 3a 52 b8			ld a, (.dmark+1)  
b846 32 b8 ee			ld (debug_mark+1),a  
b849 3a 53 b8			ld a, (.dmark+2)  
b84c 32 b9 ee			ld (debug_mark+2),a  
b84f 18 03			jr .pastdmark  
b851 ..			.dmark: db "RNd"  
b854 f1			.pastdmark: pop af  
b855			endm  
# End of macro DMARK
b855						CALLMONITOR 
b855 cd a3 94			call break_point_state  
b858				endm  
# End of macro CALLMONITOR
b858					endif 
b858			 
b858			 
b858 cd 14 9b				call forth_push_numhl 
b85b				       NEXTW 
b85b c3 82 9e			jp macro_next 
b85e				endm 
# End of macro NEXTW
b85e			 
b85e			.ENDMATHS: 
b85e			 
b85e			; eof 
b85e			 
# End of file forth_words_maths.asm
b85e			include "forth_words_display.asm" 
b85e			 
b85e			; | ## Display Words 
b85e			 
b85e			.INFO: 
b85e			 
b85e				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b85e 62				db WORD_SYS_CORE+78             
b85f 7b b8			dw .ATP            
b861 05				db 4 + 1 
b862 .. 00			db "INFO",0              
b867				endm 
# End of macro CWHEAD
b867			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b867					FORTH_DSP_VALUEHL 
b867 cd 0b 9d			call macro_dsp_valuehl 
b86a				endm 
# End of macro FORTH_DSP_VALUEHL
b86a			 
b86a					FORTH_DSP_POP 
b86a cd c3 9d			call macro_forth_dsp_pop 
b86d				endm 
# End of macro FORTH_DSP_POP
b86d			 
b86d e5					push hl 
b86e			 
b86e					FORTH_DSP_VALUEHL 
b86e cd 0b 9d			call macro_dsp_valuehl 
b871				endm 
# End of macro FORTH_DSP_VALUEHL
b871			 
b871					FORTH_DSP_POP 
b871 cd c3 9d			call macro_forth_dsp_pop 
b874				endm 
# End of macro FORTH_DSP_POP
b874			 
b874 d1					pop de 
b875			 
b875 cd 06 8a				call info_panel 
b878			 
b878			 
b878					NEXTW 
b878 c3 82 9e			jp macro_next 
b87b				endm 
# End of macro NEXTW
b87b			.ATP: 
b87b				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b87b 62				db WORD_SYS_CORE+78             
b87c f2 b8			dw .FB            
b87e 04				db 3 + 1 
b87f .. 00			db "AT?",0              
b883				endm 
# End of macro CWHEAD
b883			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b883					if DEBUG_FORTH_WORDS_KEY 
b883						DMARK "AT?" 
b883 f5				push af  
b884 3a 98 b8			ld a, (.dmark)  
b887 32 b7 ee			ld (debug_mark),a  
b88a 3a 99 b8			ld a, (.dmark+1)  
b88d 32 b8 ee			ld (debug_mark+1),a  
b890 3a 9a b8			ld a, (.dmark+2)  
b893 32 b9 ee			ld (debug_mark+2),a  
b896 18 03			jr .pastdmark  
b898 ..			.dmark: db "AT?"  
b89b f1			.pastdmark: pop af  
b89c			endm  
# End of macro DMARK
b89c						CALLMONITOR 
b89c cd a3 94			call break_point_state  
b89f				endm  
# End of macro CALLMONITOR
b89f					endif 
b89f 3a ee eb				ld a, (f_cursor_ptr) 
b8a2			 
b8a2			if DEBUG_FORTH_WORDS 
b8a2				DMARK "AT?" 
b8a2 f5				push af  
b8a3 3a b7 b8			ld a, (.dmark)  
b8a6 32 b7 ee			ld (debug_mark),a  
b8a9 3a b8 b8			ld a, (.dmark+1)  
b8ac 32 b8 ee			ld (debug_mark+1),a  
b8af 3a b9 b8			ld a, (.dmark+2)  
b8b2 32 b9 ee			ld (debug_mark+2),a  
b8b5 18 03			jr .pastdmark  
b8b7 ..			.dmark: db "AT?"  
b8ba f1			.pastdmark: pop af  
b8bb			endm  
# End of macro DMARK
b8bb				CALLMONITOR 
b8bb cd a3 94			call break_point_state  
b8be				endm  
# End of macro CALLMONITOR
b8be			endif	 
b8be					; count the number of rows 
b8be			 
b8be 06 00				ld b, 0 
b8c0 4f			.atpr:		ld c, a    ; save in case we go below zero 
b8c1 d6 14				sub display_cols 
b8c3 f2 c9 b8				jp p, .atprunder 
b8c6 04					inc b 
b8c7 18 f7				jr .atpr 
b8c9			.atprunder:	 
b8c9			if DEBUG_FORTH_WORDS 
b8c9				DMARK "A?2" 
b8c9 f5				push af  
b8ca 3a de b8			ld a, (.dmark)  
b8cd 32 b7 ee			ld (debug_mark),a  
b8d0 3a df b8			ld a, (.dmark+1)  
b8d3 32 b8 ee			ld (debug_mark+1),a  
b8d6 3a e0 b8			ld a, (.dmark+2)  
b8d9 32 b9 ee			ld (debug_mark+2),a  
b8dc 18 03			jr .pastdmark  
b8de ..			.dmark: db "A?2"  
b8e1 f1			.pastdmark: pop af  
b8e2			endm  
# End of macro DMARK
b8e2				CALLMONITOR 
b8e2 cd a3 94			call break_point_state  
b8e5				endm  
# End of macro CALLMONITOR
b8e5			endif	 
b8e5 26 00				ld h, 0 
b8e7 69					ld l, c 
b8e8 cd 14 9b				call forth_push_numhl 
b8eb 68					ld l, b  
b8ec cd 14 9b				call forth_push_numhl 
b8ef			 
b8ef			 
b8ef				NEXTW 
b8ef c3 82 9e			jp macro_next 
b8f2				endm 
# End of macro NEXTW
b8f2			 
b8f2			.FB: 
b8f2				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b8f2 1b				db WORD_SYS_CORE+7             
b8f3 40 b9			dw .EMIT            
b8f5 03				db 2 + 1 
b8f6 .. 00			db "FB",0              
b8f9				endm 
# End of macro CWHEAD
b8f9			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b8f9			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b8f9			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b8f9			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b8f9					if DEBUG_FORTH_WORDS_KEY 
b8f9						DMARK "FB." 
b8f9 f5				push af  
b8fa 3a 0e b9			ld a, (.dmark)  
b8fd 32 b7 ee			ld (debug_mark),a  
b900 3a 0f b9			ld a, (.dmark+1)  
b903 32 b8 ee			ld (debug_mark+1),a  
b906 3a 10 b9			ld a, (.dmark+2)  
b909 32 b9 ee			ld (debug_mark+2),a  
b90c 18 03			jr .pastdmark  
b90e ..			.dmark: db "FB."  
b911 f1			.pastdmark: pop af  
b912			endm  
# End of macro DMARK
b912						CALLMONITOR 
b912 cd a3 94			call break_point_state  
b915				endm  
# End of macro CALLMONITOR
b915					endif 
b915			 
b915					FORTH_DSP_VALUEHL 
b915 cd 0b 9d			call macro_dsp_valuehl 
b918				endm 
# End of macro FORTH_DSP_VALUEHL
b918			 
b918 7d					ld a, l 
b919 fe 01				cp 1 
b91b 20 05				jr nz, .fbn1 
b91d 21 fc ed				ld hl, display_fb1 
b920 18 15				jr .fbset 
b922 fe 02		.fbn1:		cp 2 
b924 20 05				jr nz, .fbn2 
b926 21 5a ed				ld hl, display_fb2 
b929 18 0c				jr .fbset 
b92b fe 03		.fbn2:		cp 3 
b92d 20 05				jr nz, .fbn3 
b92f 21 ab ed				ld hl, display_fb3 
b932 18 03				jr .fbset 
b934			.fbn3:		 ; if invalid number select first 
b934 21 fc ed				ld hl, display_fb1 
b937 22 58 ed		.fbset:		ld (display_fb_active), hl 
b93a			 
b93a					FORTH_DSP_POP 
b93a cd c3 9d			call macro_forth_dsp_pop 
b93d				endm 
# End of macro FORTH_DSP_POP
b93d			 
b93d					NEXTW 
b93d c3 82 9e			jp macro_next 
b940				endm 
# End of macro NEXTW
b940			 
b940			 
b940			.EMIT: 
b940				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b940 1b				db WORD_SYS_CORE+7             
b941 91 b9			dw .DOTH            
b943 05				db 4 + 1 
b944 .. 00			db "EMIT",0              
b949				endm 
# End of macro CWHEAD
b949			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b949					; get value off TOS and display it 
b949			 
b949					if DEBUG_FORTH_WORDS_KEY 
b949						DMARK "EMT" 
b949 f5				push af  
b94a 3a 5e b9			ld a, (.dmark)  
b94d 32 b7 ee			ld (debug_mark),a  
b950 3a 5f b9			ld a, (.dmark+1)  
b953 32 b8 ee			ld (debug_mark+1),a  
b956 3a 60 b9			ld a, (.dmark+2)  
b959 32 b9 ee			ld (debug_mark+2),a  
b95c 18 03			jr .pastdmark  
b95e ..			.dmark: db "EMT"  
b961 f1			.pastdmark: pop af  
b962			endm  
# End of macro DMARK
b962						CALLMONITOR 
b962 cd a3 94			call break_point_state  
b965				endm  
# End of macro CALLMONITOR
b965					endif 
b965			 
b965					FORTH_DSP_VALUEHL 
b965 cd 0b 9d			call macro_dsp_valuehl 
b968				endm 
# End of macro FORTH_DSP_VALUEHL
b968			 
b968 7d					ld a,l 
b969			 
b969					; TODO write to display 
b969			 
b969 32 83 e6				ld (os_input), a 
b96c 3e 00				ld a, 0 
b96e 32 84 e6				ld (os_input+1), a 
b971					 
b971 3a ee eb				ld a, (f_cursor_ptr) 
b974 11 83 e6				ld de, os_input 
b977 cd 88 8a				call str_at_display 
b97a			 
b97a			 
b97a 3a cc eb				ld a,(cli_autodisplay) 
b97d fe 00				cp 0 
b97f 28 03				jr z, .enoupdate 
b981 cd 98 8a						call update_display 
b984					.enoupdate: 
b984			 
b984 3a ee eb				ld a, (f_cursor_ptr) 
b987 3c					inc a 
b988 32 ee eb				ld (f_cursor_ptr), a   ; save new pos 
b98b			 
b98b			 
b98b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b98b cd c3 9d			call macro_forth_dsp_pop 
b98e				endm 
# End of macro FORTH_DSP_POP
b98e			  
b98e			 
b98e					NEXTW 
b98e c3 82 9e			jp macro_next 
b991				endm 
# End of macro NEXTW
b991			.DOTH: 
b991				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b991 1c				db WORD_SYS_CORE+8             
b992 c1 b9			dw .DOTF            
b994 03				db 2 + 1 
b995 .. 00			db ".-",0              
b998				endm 
# End of macro CWHEAD
b998			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b998					; get value off TOS and display it 
b998					if DEBUG_FORTH_WORDS_KEY 
b998						DMARK "DTD" 
b998 f5				push af  
b999 3a ad b9			ld a, (.dmark)  
b99c 32 b7 ee			ld (debug_mark),a  
b99f 3a ae b9			ld a, (.dmark+1)  
b9a2 32 b8 ee			ld (debug_mark+1),a  
b9a5 3a af b9			ld a, (.dmark+2)  
b9a8 32 b9 ee			ld (debug_mark+2),a  
b9ab 18 03			jr .pastdmark  
b9ad ..			.dmark: db "DTD"  
b9b0 f1			.pastdmark: pop af  
b9b1			endm  
# End of macro DMARK
b9b1						CALLMONITOR 
b9b1 cd a3 94			call break_point_state  
b9b4				endm  
# End of macro CALLMONITOR
b9b4					endif 
b9b4 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b9b6 3e 00			ld a, 0 
b9b8 32 cd eb			ld (cli_mvdot), a 
b9bb c3 18 ba			jp .dotgo 
b9be				NEXTW 
b9be c3 82 9e			jp macro_next 
b9c1				endm 
# End of macro NEXTW
b9c1			.DOTF: 
b9c1				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b9c1 1c				db WORD_SYS_CORE+8             
b9c2 ef b9			dw .DOT            
b9c4 03				db 2 + 1 
b9c5 .. 00			db ".>",0              
b9c8				endm 
# End of macro CWHEAD
b9c8			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b9c8					; get value off TOS and display it 
b9c8			        ; TODO BUG adds extra spaces 
b9c8			        ; TODO BUG handle numerics? 
b9c8					if DEBUG_FORTH_WORDS_KEY 
b9c8						DMARK "DTC" 
b9c8 f5				push af  
b9c9 3a dd b9			ld a, (.dmark)  
b9cc 32 b7 ee			ld (debug_mark),a  
b9cf 3a de b9			ld a, (.dmark+1)  
b9d2 32 b8 ee			ld (debug_mark+1),a  
b9d5 3a df b9			ld a, (.dmark+2)  
b9d8 32 b9 ee			ld (debug_mark+2),a  
b9db 18 03			jr .pastdmark  
b9dd ..			.dmark: db "DTC"  
b9e0 f1			.pastdmark: pop af  
b9e1			endm  
# End of macro DMARK
b9e1						CALLMONITOR 
b9e1 cd a3 94			call break_point_state  
b9e4				endm  
# End of macro CALLMONITOR
b9e4					endif 
b9e4 3e 01			ld a, 1 
b9e6 32 cd eb			ld (cli_mvdot), a 
b9e9 c3 18 ba			jp .dotgo 
b9ec				NEXTW 
b9ec c3 82 9e			jp macro_next 
b9ef				endm 
# End of macro NEXTW
b9ef			 
b9ef			.DOT: 
b9ef				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b9ef 1c				db WORD_SYS_CORE+8             
b9f0 7b ba			dw .CLS            
b9f2 02				db 1 + 1 
b9f3 .. 00			db ".",0              
b9f5				endm 
# End of macro CWHEAD
b9f5			        ; | . ( u -- ) Display TOS | DONE 
b9f5					; get value off TOS and display it 
b9f5			 
b9f5					if DEBUG_FORTH_WORDS_KEY 
b9f5						DMARK "DOT" 
b9f5 f5				push af  
b9f6 3a 0a ba			ld a, (.dmark)  
b9f9 32 b7 ee			ld (debug_mark),a  
b9fc 3a 0b ba			ld a, (.dmark+1)  
b9ff 32 b8 ee			ld (debug_mark+1),a  
ba02 3a 0c ba			ld a, (.dmark+2)  
ba05 32 b9 ee			ld (debug_mark+2),a  
ba08 18 03			jr .pastdmark  
ba0a ..			.dmark: db "DOT"  
ba0d f1			.pastdmark: pop af  
ba0e			endm  
# End of macro DMARK
ba0e						CALLMONITOR 
ba0e cd a3 94			call break_point_state  
ba11				endm  
# End of macro CALLMONITOR
ba11					endif 
ba11 3e 00			ld a, 0 
ba13 32 cd eb			ld (cli_mvdot), a 
ba16 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
ba18				 
ba18			 
ba18			.dotgo: 
ba18			 
ba18			; move up type to on stack for parserv5 
ba18					FORTH_DSP 
ba18 cd d1 9c			call macro_forth_dsp 
ba1b				endm 
# End of macro FORTH_DSP
ba1b				;FORTH_DSP_VALUE  
ba1b			 
ba1b			if DEBUG_FORTH_DOT 
ba1b				DMARK "DOT" 
ba1b				CALLMONITOR 
ba1b			endif	 
ba1b			;		.print: 
ba1b			 
ba1b 7e				ld a,(hl)  ; work out what type of value is on the TOS 
ba1c 23				inc hl   ; position to the actual value 
ba1d fe 01			cp DS_TYPE_STR 
ba1f 20 06			jr nz, .dotnum1  
ba21			 
ba21			; display string 
ba21				FORTH_DSP_VALUE  
ba21 cd f4 9c			call macro_forth_dsp_value 
ba24				endm 
# End of macro FORTH_DSP_VALUE
ba24 eb				ex de,hl 
ba25 18 11			jr .dotwrite 
ba27			 
ba27			.dotnum1: 
ba27 fe 02			cp DS_TYPE_INUM 
ba29 20 0c			jr nz, .dotflot 
ba2b			 
ba2b			 
ba2b			; display number 
ba2b			 
ba2b			;	push hl 
ba2b			;	call clear_display 
ba2b			;	pop hl 
ba2b			 
ba2b 5e				ld e, (hl) 
ba2c 23				inc hl 
ba2d 56				ld d, (hl) 
ba2e 21 85 e4			ld hl, scratch 
ba31			if DEBUG_FORTH_DOT 
ba31				DMARK "DT1" 
ba31				CALLMONITOR 
ba31			endif	 
ba31			 
ba31 cd af 90			call uitoa_16 
ba34 eb				ex de,hl 
ba35			 
ba35			if DEBUG_FORTH_DOT 
ba35				DMARK "DT2" 
ba35				CALLMONITOR 
ba35			endif	 
ba35			 
ba35			;	ld de, os_word_scratch 
ba35 18 01			jr .dotwrite 
ba37			 
ba37 00			.dotflot:   nop 
ba38			; TODO print floating point number 
ba38			 
ba38			.dotwrite:		 
ba38			 
ba38					; if c is set then set all '-' to spaces 
ba38					; need to also take into account .>  
ba38			 
ba38 3e 01				ld a, 1 
ba3a b9					cp c 
ba3b 20 13				jr nz, .nodashswap 
ba3d			 
ba3d					; DE has the string to write, working with HL 
ba3d			 
ba3d 06 ff				ld b, 255 
ba3f d5					push de 
ba40 e1					pop hl 
ba41			 
ba41			if DEBUG_FORTH_DOT 
ba41				DMARK "DT-" 
ba41				CALLMONITOR 
ba41			endif	 
ba41 7e			.dashscan:	ld a, (hl) 
ba42 fe 00				cp 0 
ba44 28 0a				jr z, .nodashswap 
ba46 fe 2d				cp '-' 
ba48 20 03				jr nz, .dashskip 
ba4a 3e 20				ld a, ' ' 
ba4c 77					ld (hl), a 
ba4d 23			.dashskip:	inc hl 
ba4e			if DEBUG_FORTH_DOT 
ba4e				DMARK "D-2" 
ba4e				CALLMONITOR 
ba4e			endif	 
ba4e 10 f1				djnz .dashscan 
ba50			 
ba50			if DEBUG_FORTH_DOT 
ba50				DMARK "D-1" 
ba50				CALLMONITOR 
ba50			endif	 
ba50			 
ba50			.nodashswap: 
ba50			 
ba50 e5					push hl   ; save string start in case we need to advance print 
ba51			 
ba51 3a ee eb				ld a, (f_cursor_ptr) 
ba54 cd 88 8a				call str_at_display 
ba57 3a cc eb				ld a,(cli_autodisplay) 
ba5a fe 00				cp 0 
ba5c 28 03				jr z, .noupdate 
ba5e cd 98 8a						call update_display 
ba61					.noupdate: 
ba61			 
ba61			 
ba61					; see if we need to advance the print position 
ba61			 
ba61 e1					pop hl   ; get back string 
ba62			 
ba62 3a cd eb				ld a, (cli_mvdot) 
ba65			if DEBUG_FORTH_DOT 
ba65					ld e,a 
ba65				DMARK "D>1" 
ba65				CALLMONITOR 
ba65			endif	 
ba65 fe 00				cp 0 
ba67 28 0c				jr z, .noadv 
ba69					; yes, lets advance the print position 
ba69 3e 00				ld a, 0 
ba6b cd 0b 91				call strlent 
ba6e 3a ee eb				ld a, (f_cursor_ptr) 
ba71 85					add a,l 
ba72					;call addatohl 
ba72					;ld a, l 
ba72 32 ee eb				ld (f_cursor_ptr), a   ; save new pos 
ba75			 
ba75			if DEBUG_FORTH_DOT 
ba75				DMARK "D->" 
ba75				CALLMONITOR 
ba75			endif	 
ba75			 
ba75			.noadv:	 
ba75			 
ba75					if DEBUG_FORTH_DOT_WAIT 
ba75							call next_page_prompt 
ba75					endif	 
ba75			; TODO this pop off the stack causes a crash. i dont know why 
ba75			 
ba75			 
ba75			if DEBUG_FORTH_DOT 
ba75				DMARK "DTh" 
ba75				CALLMONITOR 
ba75			endif	 
ba75			 
ba75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba75 cd c3 9d			call macro_forth_dsp_pop 
ba78				endm 
# End of macro FORTH_DSP_POP
ba78			 
ba78			if DEBUG_FORTH_DOT 
ba78				DMARK "DTi" 
ba78				CALLMONITOR 
ba78			endif	 
ba78			 
ba78			 
ba78					NEXTW 
ba78 c3 82 9e			jp macro_next 
ba7b				endm 
# End of macro NEXTW
ba7b			 
ba7b			.CLS: 
ba7b				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
ba7b 35				db WORD_SYS_CORE+33             
ba7c a8 ba			dw .DRAW            
ba7e 04				db 3 + 1 
ba7f .. 00			db "CLS",0              
ba83				endm 
# End of macro CWHEAD
ba83			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
ba83					if DEBUG_FORTH_WORDS_KEY 
ba83						DMARK "CLS" 
ba83 f5				push af  
ba84 3a 98 ba			ld a, (.dmark)  
ba87 32 b7 ee			ld (debug_mark),a  
ba8a 3a 99 ba			ld a, (.dmark+1)  
ba8d 32 b8 ee			ld (debug_mark+1),a  
ba90 3a 9a ba			ld a, (.dmark+2)  
ba93 32 b9 ee			ld (debug_mark+2),a  
ba96 18 03			jr .pastdmark  
ba98 ..			.dmark: db "CLS"  
ba9b f1			.pastdmark: pop af  
ba9c			endm  
# End of macro DMARK
ba9c						CALLMONITOR 
ba9c cd a3 94			call break_point_state  
ba9f				endm  
# End of macro CALLMONITOR
ba9f					endif 
ba9f cd 75 8a				call clear_display 
baa2 c3 b6 bb				jp .home		; and home cursor 
baa5					NEXTW 
baa5 c3 82 9e			jp macro_next 
baa8				endm 
# End of macro NEXTW
baa8			 
baa8			.DRAW: 
baa8				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
baa8 36				db WORD_SYS_CORE+34             
baa9 d3 ba			dw .DUMP            
baab 05				db 4 + 1 
baac .. 00			db "DRAW",0              
bab1				endm 
# End of macro CWHEAD
bab1			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bab1					if DEBUG_FORTH_WORDS_KEY 
bab1						DMARK "DRW" 
bab1 f5				push af  
bab2 3a c6 ba			ld a, (.dmark)  
bab5 32 b7 ee			ld (debug_mark),a  
bab8 3a c7 ba			ld a, (.dmark+1)  
babb 32 b8 ee			ld (debug_mark+1),a  
babe 3a c8 ba			ld a, (.dmark+2)  
bac1 32 b9 ee			ld (debug_mark+2),a  
bac4 18 03			jr .pastdmark  
bac6 ..			.dmark: db "DRW"  
bac9 f1			.pastdmark: pop af  
baca			endm  
# End of macro DMARK
baca						CALLMONITOR 
baca cd a3 94			call break_point_state  
bacd				endm  
# End of macro CALLMONITOR
bacd					endif 
bacd cd 98 8a				call update_display 
bad0					NEXTW 
bad0 c3 82 9e			jp macro_next 
bad3				endm 
# End of macro NEXTW
bad3			 
bad3			.DUMP: 
bad3				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bad3 37				db WORD_SYS_CORE+35             
bad4 0b bb			dw .CDUMP            
bad6 05				db 4 + 1 
bad7 .. 00			db "DUMP",0              
badc				endm 
# End of macro CWHEAD
badc			; | DUMP ( x -- ) With address x display dump   | DONE 
badc			; TODO pop address to use off of the stack 
badc					if DEBUG_FORTH_WORDS_KEY 
badc						DMARK "DUM" 
badc f5				push af  
badd 3a f1 ba			ld a, (.dmark)  
bae0 32 b7 ee			ld (debug_mark),a  
bae3 3a f2 ba			ld a, (.dmark+1)  
bae6 32 b8 ee			ld (debug_mark+1),a  
bae9 3a f3 ba			ld a, (.dmark+2)  
baec 32 b9 ee			ld (debug_mark+2),a  
baef 18 03			jr .pastdmark  
baf1 ..			.dmark: db "DUM"  
baf4 f1			.pastdmark: pop af  
baf5			endm  
# End of macro DMARK
baf5						CALLMONITOR 
baf5 cd a3 94			call break_point_state  
baf8				endm  
# End of macro CALLMONITOR
baf8					endif 
baf8 cd 75 8a				call clear_display 
bafb			 
bafb					; get address 
bafb			 
bafb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bafb cd 0b 9d			call macro_dsp_valuehl 
bafe				endm 
# End of macro FORTH_DSP_VALUEHL
bafe				 
bafe					; save it for cdump 
bafe			 
bafe 22 a8 e7				ld (os_cur_ptr),hl 
bb01			 
bb01					; destroy value TOS 
bb01			 
bb01					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb01 cd c3 9d			call macro_forth_dsp_pop 
bb04				endm 
# End of macro FORTH_DSP_POP
bb04			 
bb04 cd 94 99				call dumpcont	; skip old style of param parsing	 
bb07 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bb08					NEXTW 
bb08 c3 82 9e			jp macro_next 
bb0b				endm 
# End of macro NEXTW
bb0b			.CDUMP: 
bb0b				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bb0b 38				db WORD_SYS_CORE+36             
bb0c 3b bb			dw .DAT            
bb0e 06				db 5 + 1 
bb0f .. 00			db "CDUMP",0              
bb15				endm 
# End of macro CWHEAD
bb15			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bb15					if DEBUG_FORTH_WORDS_KEY 
bb15						DMARK "CDP" 
bb15 f5				push af  
bb16 3a 2a bb			ld a, (.dmark)  
bb19 32 b7 ee			ld (debug_mark),a  
bb1c 3a 2b bb			ld a, (.dmark+1)  
bb1f 32 b8 ee			ld (debug_mark+1),a  
bb22 3a 2c bb			ld a, (.dmark+2)  
bb25 32 b9 ee			ld (debug_mark+2),a  
bb28 18 03			jr .pastdmark  
bb2a ..			.dmark: db "CDP"  
bb2d f1			.pastdmark: pop af  
bb2e			endm  
# End of macro DMARK
bb2e						CALLMONITOR 
bb2e cd a3 94			call break_point_state  
bb31				endm  
# End of macro CALLMONITOR
bb31					endif 
bb31 cd 75 8a				call clear_display 
bb34 cd 94 99				call dumpcont	 
bb37 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bb38					NEXTW 
bb38 c3 82 9e			jp macro_next 
bb3b				endm 
# End of macro NEXTW
bb3b			 
bb3b			 
bb3b			 
bb3b			 
bb3b			.DAT: 
bb3b				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bb3b 3d				db WORD_SYS_CORE+41             
bb3c 91 bb			dw .HOME            
bb3e 03				db 2 + 1 
bb3f .. 00			db "AT",0              
bb42				endm 
# End of macro CWHEAD
bb42			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bb42					if DEBUG_FORTH_WORDS_KEY 
bb42						DMARK "AT." 
bb42 f5				push af  
bb43 3a 57 bb			ld a, (.dmark)  
bb46 32 b7 ee			ld (debug_mark),a  
bb49 3a 58 bb			ld a, (.dmark+1)  
bb4c 32 b8 ee			ld (debug_mark+1),a  
bb4f 3a 59 bb			ld a, (.dmark+2)  
bb52 32 b9 ee			ld (debug_mark+2),a  
bb55 18 03			jr .pastdmark  
bb57 ..			.dmark: db "AT."  
bb5a f1			.pastdmark: pop af  
bb5b			endm  
# End of macro DMARK
bb5b						CALLMONITOR 
bb5b cd a3 94			call break_point_state  
bb5e				endm  
# End of macro CALLMONITOR
bb5e					endif 
bb5e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb5e cd 0b 9d			call macro_dsp_valuehl 
bb61				endm 
# End of macro FORTH_DSP_VALUEHL
bb61			 
bb61			 
bb61					; TODO save cursor row 
bb61 7d					ld a,l 
bb62 fe 02				cp 2 
bb64 20 04				jr nz, .crow3 
bb66 3e 14				ld a, display_row_2 
bb68 18 12				jr .ccol1 
bb6a fe 03		.crow3:		cp 3 
bb6c 20 04				jr nz, .crow4 
bb6e 3e 28				ld a, display_row_3 
bb70 18 0a				jr .ccol1 
bb72 fe 04		.crow4:		cp 4 
bb74 20 04				jr nz, .crow1 
bb76 3e 3c				ld a, display_row_4 
bb78 18 02				jr .ccol1 
bb7a 3e 00		.crow1:		ld a,display_row_1 
bb7c f5			.ccol1:		push af			; got row offset 
bb7d 6f					ld l,a 
bb7e 26 00				ld h,0 
bb80					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb80 cd c3 9d			call macro_forth_dsp_pop 
bb83				endm 
# End of macro FORTH_DSP_POP
bb83					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb83 cd 0b 9d			call macro_dsp_valuehl 
bb86				endm 
# End of macro FORTH_DSP_VALUEHL
bb86					; TODO save cursor col 
bb86 f1					pop af 
bb87 85					add l		; add col offset 
bb88 32 ee eb				ld (f_cursor_ptr), a 
bb8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb8b cd c3 9d			call macro_forth_dsp_pop 
bb8e				endm 
# End of macro FORTH_DSP_POP
bb8e			 
bb8e					; calculate  
bb8e			 
bb8e					NEXTW 
bb8e c3 82 9e			jp macro_next 
bb91				endm 
# End of macro NEXTW
bb91			 
bb91			 
bb91			.HOME: 
bb91				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
bb91 41				db WORD_SYS_CORE+45             
bb92 be bb			dw .SPACE            
bb94 05				db 4 + 1 
bb95 .. 00			db "HOME",0              
bb9a				endm 
# End of macro CWHEAD
bb9a			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bb9a					if DEBUG_FORTH_WORDS_KEY 
bb9a						DMARK "HOM" 
bb9a f5				push af  
bb9b 3a af bb			ld a, (.dmark)  
bb9e 32 b7 ee			ld (debug_mark),a  
bba1 3a b0 bb			ld a, (.dmark+1)  
bba4 32 b8 ee			ld (debug_mark+1),a  
bba7 3a b1 bb			ld a, (.dmark+2)  
bbaa 32 b9 ee			ld (debug_mark+2),a  
bbad 18 03			jr .pastdmark  
bbaf ..			.dmark: db "HOM"  
bbb2 f1			.pastdmark: pop af  
bbb3			endm  
# End of macro DMARK
bbb3						CALLMONITOR 
bbb3 cd a3 94			call break_point_state  
bbb6				endm  
# End of macro CALLMONITOR
bbb6					endif 
bbb6 3e 00		.home:		ld a, 0		; and home cursor 
bbb8 32 ee eb				ld (f_cursor_ptr), a 
bbbb					NEXTW 
bbbb c3 82 9e			jp macro_next 
bbbe				endm 
# End of macro NEXTW
bbbe			 
bbbe			 
bbbe			.SPACE: 
bbbe				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
bbbe 46				db WORD_SYS_CORE+50             
bbbf ec bb			dw .SPACES            
bbc1 03				db 2 + 1 
bbc2 .. 00			db "BL",0              
bbc5				endm 
# End of macro CWHEAD
bbc5			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bbc5					if DEBUG_FORTH_WORDS_KEY 
bbc5						DMARK "BL." 
bbc5 f5				push af  
bbc6 3a da bb			ld a, (.dmark)  
bbc9 32 b7 ee			ld (debug_mark),a  
bbcc 3a db bb			ld a, (.dmark+1)  
bbcf 32 b8 ee			ld (debug_mark+1),a  
bbd2 3a dc bb			ld a, (.dmark+2)  
bbd5 32 b9 ee			ld (debug_mark+2),a  
bbd8 18 03			jr .pastdmark  
bbda ..			.dmark: db "BL."  
bbdd f1			.pastdmark: pop af  
bbde			endm  
# End of macro DMARK
bbde						CALLMONITOR 
bbde cd a3 94			call break_point_state  
bbe1				endm  
# End of macro CALLMONITOR
bbe1					endif 
bbe1 21 ea bb				ld hl, .blstr 
bbe4 cd 82 9b				call forth_push_str 
bbe7					 
bbe7				       NEXTW 
bbe7 c3 82 9e			jp macro_next 
bbea				endm 
# End of macro NEXTW
bbea			 
bbea .. 00		.blstr: db " ", 0 
bbec			 
bbec			.SPACES: 
bbec				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
bbec 47				db WORD_SYS_CORE+51             
bbed 87 bc			dw .SCROLL            
bbef 07				db 6 + 1 
bbf0 .. 00			db "SPACES",0              
bbf7				endm 
# End of macro CWHEAD
bbf7			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
bbf7					if DEBUG_FORTH_WORDS_KEY 
bbf7						DMARK "SPS" 
bbf7 f5				push af  
bbf8 3a 0c bc			ld a, (.dmark)  
bbfb 32 b7 ee			ld (debug_mark),a  
bbfe 3a 0d bc			ld a, (.dmark+1)  
bc01 32 b8 ee			ld (debug_mark+1),a  
bc04 3a 0e bc			ld a, (.dmark+2)  
bc07 32 b9 ee			ld (debug_mark+2),a  
bc0a 18 03			jr .pastdmark  
bc0c ..			.dmark: db "SPS"  
bc0f f1			.pastdmark: pop af  
bc10			endm  
# End of macro DMARK
bc10						CALLMONITOR 
bc10 cd a3 94			call break_point_state  
bc13				endm  
# End of macro CALLMONITOR
bc13					endif 
bc13			 
bc13			 
bc13					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bc13 cd 0b 9d			call macro_dsp_valuehl 
bc16				endm 
# End of macro FORTH_DSP_VALUEHL
bc16			 
bc16			;		push hl    ; u 
bc16					if DEBUG_FORTH_WORDS 
bc16						DMARK "SPA" 
bc16 f5				push af  
bc17 3a 2b bc			ld a, (.dmark)  
bc1a 32 b7 ee			ld (debug_mark),a  
bc1d 3a 2c bc			ld a, (.dmark+1)  
bc20 32 b8 ee			ld (debug_mark+1),a  
bc23 3a 2d bc			ld a, (.dmark+2)  
bc26 32 b9 ee			ld (debug_mark+2),a  
bc29 18 03			jr .pastdmark  
bc2b ..			.dmark: db "SPA"  
bc2e f1			.pastdmark: pop af  
bc2f			endm  
# End of macro DMARK
bc2f						CALLMONITOR 
bc2f cd a3 94			call break_point_state  
bc32				endm  
# End of macro CALLMONITOR
bc32					endif 
bc32			 
bc32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc32 cd c3 9d			call macro_forth_dsp_pop 
bc35				endm 
# End of macro FORTH_DSP_POP
bc35			;		pop hl 
bc35 4d					ld c, l 
bc36 06 00				ld b, 0 
bc38 21 85 e4				ld hl, scratch  
bc3b			 
bc3b					if DEBUG_FORTH_WORDS 
bc3b						DMARK "SP2" 
bc3b f5				push af  
bc3c 3a 50 bc			ld a, (.dmark)  
bc3f 32 b7 ee			ld (debug_mark),a  
bc42 3a 51 bc			ld a, (.dmark+1)  
bc45 32 b8 ee			ld (debug_mark+1),a  
bc48 3a 52 bc			ld a, (.dmark+2)  
bc4b 32 b9 ee			ld (debug_mark+2),a  
bc4e 18 03			jr .pastdmark  
bc50 ..			.dmark: db "SP2"  
bc53 f1			.pastdmark: pop af  
bc54			endm  
# End of macro DMARK
bc54						CALLMONITOR 
bc54 cd a3 94			call break_point_state  
bc57				endm  
# End of macro CALLMONITOR
bc57					endif 
bc57 3e 20				ld a, ' ' 
bc59 c5			.spaces1:	push bc 
bc5a 77					ld (hl),a 
bc5b 23					inc hl 
bc5c c1					pop bc 
bc5d 10 fa				djnz .spaces1 
bc5f 3e 00				ld a,0 
bc61 77					ld (hl),a 
bc62 21 85 e4				ld hl, scratch 
bc65					if DEBUG_FORTH_WORDS 
bc65						DMARK "SP3" 
bc65 f5				push af  
bc66 3a 7a bc			ld a, (.dmark)  
bc69 32 b7 ee			ld (debug_mark),a  
bc6c 3a 7b bc			ld a, (.dmark+1)  
bc6f 32 b8 ee			ld (debug_mark+1),a  
bc72 3a 7c bc			ld a, (.dmark+2)  
bc75 32 b9 ee			ld (debug_mark+2),a  
bc78 18 03			jr .pastdmark  
bc7a ..			.dmark: db "SP3"  
bc7d f1			.pastdmark: pop af  
bc7e			endm  
# End of macro DMARK
bc7e						CALLMONITOR 
bc7e cd a3 94			call break_point_state  
bc81				endm  
# End of macro CALLMONITOR
bc81					endif 
bc81 cd 7d 9c				call forth_apush 
bc84			 
bc84				       NEXTW 
bc84 c3 82 9e			jp macro_next 
bc87				endm 
# End of macro NEXTW
bc87			 
bc87			 
bc87			 
bc87			.SCROLL: 
bc87				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bc87 53				db WORD_SYS_CORE+63             
bc88 b4 bc			dw .SCROLLD            
bc8a 07				db 6 + 1 
bc8b .. 00			db "SCROLL",0              
bc92				endm 
# End of macro CWHEAD
bc92			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bc92					if DEBUG_FORTH_WORDS_KEY 
bc92						DMARK "SCR" 
bc92 f5				push af  
bc93 3a a7 bc			ld a, (.dmark)  
bc96 32 b7 ee			ld (debug_mark),a  
bc99 3a a8 bc			ld a, (.dmark+1)  
bc9c 32 b8 ee			ld (debug_mark+1),a  
bc9f 3a a9 bc			ld a, (.dmark+2)  
bca2 32 b9 ee			ld (debug_mark+2),a  
bca5 18 03			jr .pastdmark  
bca7 ..			.dmark: db "SCR"  
bcaa f1			.pastdmark: pop af  
bcab			endm  
# End of macro DMARK
bcab						CALLMONITOR 
bcab cd a3 94			call break_point_state  
bcae				endm  
# End of macro CALLMONITOR
bcae					endif 
bcae			 
bcae cd 37 8a			call scroll_up 
bcb1			;	call update_display 
bcb1			 
bcb1					NEXTW 
bcb1 c3 82 9e			jp macro_next 
bcb4				endm 
# End of macro NEXTW
bcb4			 
bcb4			 
bcb4			 
bcb4			;		; get dir 
bcb4			; 
bcb4			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bcb4			; 
bcb4			;		push hl 
bcb4			; 
bcb4			;		; destroy value TOS 
bcb4			; 
bcb4			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bcb4			; 
bcb4			;		; get count 
bcb4			; 
bcb4			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bcb4			; 
bcb4			;		push hl 
bcb4			; 
bcb4			;		; destroy value TOS 
bcb4			; 
bcb4			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bcb4			; 
bcb4			;		; one value on hl get other one back 
bcb4			; 
bcb4			;		pop bc    ; count 
bcb4			; 
bcb4			;		pop de   ; dir 
bcb4			; 
bcb4			; 
bcb4			;		ld b, c 
bcb4			; 
bcb4			;.scrolldir:     push bc 
bcb4			;		push de 
bcb4			; 
bcb4			;		ld a, 0 
bcb4			;		cp e 
bcb4			;		jr z, .scrollup  
bcb4			;		call scroll_down 
bcb4			;		jr .scrollnext 
bcb4			;.scrollup:	call scroll_up 
bcb4			; 
bcb4			;		 
bcb4			;.scrollnext: 
bcb4			;		pop de 
bcb4			;		pop bc 
bcb4			;		djnz .scrolldir 
bcb4			; 
bcb4			; 
bcb4			; 
bcb4			; 
bcb4			; 
bcb4			;		NEXTW 
bcb4			 
bcb4			.SCROLLD: 
bcb4				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bcb4 53				db WORD_SYS_CORE+63             
bcb5 e2 bc			dw .ATQ            
bcb7 08				db 7 + 1 
bcb8 .. 00			db "SCROLLD",0              
bcc0				endm 
# End of macro CWHEAD
bcc0			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bcc0					if DEBUG_FORTH_WORDS_KEY 
bcc0						DMARK "SCD" 
bcc0 f5				push af  
bcc1 3a d5 bc			ld a, (.dmark)  
bcc4 32 b7 ee			ld (debug_mark),a  
bcc7 3a d6 bc			ld a, (.dmark+1)  
bcca 32 b8 ee			ld (debug_mark+1),a  
bccd 3a d7 bc			ld a, (.dmark+2)  
bcd0 32 b9 ee			ld (debug_mark+2),a  
bcd3 18 03			jr .pastdmark  
bcd5 ..			.dmark: db "SCD"  
bcd8 f1			.pastdmark: pop af  
bcd9			endm  
# End of macro DMARK
bcd9						CALLMONITOR 
bcd9 cd a3 94			call break_point_state  
bcdc				endm  
# End of macro CALLMONITOR
bcdc					endif 
bcdc			 
bcdc cd 5b 8a			call scroll_down 
bcdf			;	call update_display 
bcdf			 
bcdf					NEXTW 
bcdf c3 82 9e			jp macro_next 
bce2				endm 
# End of macro NEXTW
bce2			 
bce2			 
bce2			.ATQ: 
bce2				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bce2 62				db WORD_SYS_CORE+78             
bce3 40 bd			dw .AUTODSP            
bce5 04				db 3 + 1 
bce6 .. 00			db "AT@",0              
bcea				endm 
# End of macro CWHEAD
bcea			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bcea					if DEBUG_FORTH_WORDS_KEY 
bcea						DMARK "ATA" 
bcea f5				push af  
bceb 3a ff bc			ld a, (.dmark)  
bcee 32 b7 ee			ld (debug_mark),a  
bcf1 3a 00 bd			ld a, (.dmark+1)  
bcf4 32 b8 ee			ld (debug_mark+1),a  
bcf7 3a 01 bd			ld a, (.dmark+2)  
bcfa 32 b9 ee			ld (debug_mark+2),a  
bcfd 18 03			jr .pastdmark  
bcff ..			.dmark: db "ATA"  
bd02 f1			.pastdmark: pop af  
bd03			endm  
# End of macro DMARK
bd03						CALLMONITOR 
bd03 cd a3 94			call break_point_state  
bd06				endm  
# End of macro CALLMONITOR
bd06					endif 
bd06			 
bd06			 
bd06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd06 cd 0b 9d			call macro_dsp_valuehl 
bd09				endm 
# End of macro FORTH_DSP_VALUEHL
bd09			 
bd09					; TODO save cursor row 
bd09 7d					ld a,l 
bd0a fe 02				cp 2 
bd0c 20 04				jr nz, .crow3aq 
bd0e 3e 14				ld a, display_row_2 
bd10 18 12				jr .ccol1aq 
bd12 fe 03		.crow3aq:		cp 3 
bd14 20 04				jr nz, .crow4aq 
bd16 3e 28				ld a, display_row_3 
bd18 18 0a				jr .ccol1aq 
bd1a fe 04		.crow4aq:		cp 4 
bd1c 20 04				jr nz, .crow1aq 
bd1e 3e 3c				ld a, display_row_4 
bd20 18 02				jr .ccol1aq 
bd22 3e 00		.crow1aq:		ld a,display_row_1 
bd24 f5			.ccol1aq:		push af			; got row offset 
bd25 6f					ld l,a 
bd26 26 00				ld h,0 
bd28					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd28 cd c3 9d			call macro_forth_dsp_pop 
bd2b				endm 
# End of macro FORTH_DSP_POP
bd2b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd2b cd 0b 9d			call macro_dsp_valuehl 
bd2e				endm 
# End of macro FORTH_DSP_VALUEHL
bd2e					; TODO save cursor col 
bd2e f1					pop af 
bd2f 85					add l		; add col offset 
bd30			 
bd30					; add current frame buffer address 
bd30 2a 58 ed				ld hl, (display_fb_active) 
bd33 cd a2 8c				call addatohl 
bd36			 
bd36			 
bd36			 
bd36			 
bd36					; get char frame buffer location offset in hl 
bd36			 
bd36 7e					ld a,(hl) 
bd37 26 00				ld h, 0 
bd39 6f					ld l, a 
bd3a			 
bd3a cd 14 9b				call forth_push_numhl 
bd3d			 
bd3d			 
bd3d					NEXTW 
bd3d c3 82 9e			jp macro_next 
bd40				endm 
# End of macro NEXTW
bd40			 
bd40			.AUTODSP: 
bd40				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bd40 63				db WORD_SYS_CORE+79             
bd41 56 bd			dw .MENU            
bd43 05				db 4 + 1 
bd44 .. 00			db "ADSP",0              
bd49				endm 
# End of macro CWHEAD
bd49			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bd49			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bd49			 
bd49					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd49 cd 0b 9d			call macro_dsp_valuehl 
bd4c				endm 
# End of macro FORTH_DSP_VALUEHL
bd4c			 
bd4c			;		push hl 
bd4c			 
bd4c					; destroy value TOS 
bd4c			 
bd4c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd4c cd c3 9d			call macro_forth_dsp_pop 
bd4f				endm 
# End of macro FORTH_DSP_POP
bd4f			 
bd4f			;		pop hl 
bd4f			 
bd4f 7d					ld a,l 
bd50 32 cc eb				ld (cli_autodisplay), a 
bd53				       NEXTW 
bd53 c3 82 9e			jp macro_next 
bd56				endm 
# End of macro NEXTW
bd56			 
bd56			.MENU: 
bd56				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bd56 70				db WORD_SYS_CORE+92             
bd57 ff bd			dw .ENDDISPLAY            
bd59 05				db 4 + 1 
bd5a .. 00			db "MENU",0              
bd5f				endm 
# End of macro CWHEAD
bd5f			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bd5f			 
bd5f			;		; get number of items on the stack 
bd5f			; 
bd5f				 
bd5f					FORTH_DSP_VALUEHL 
bd5f cd 0b 9d			call macro_dsp_valuehl 
bd62				endm 
# End of macro FORTH_DSP_VALUEHL
bd62				 
bd62					if DEBUG_FORTH_WORDS_KEY 
bd62						DMARK "MNU" 
bd62 f5				push af  
bd63 3a 77 bd			ld a, (.dmark)  
bd66 32 b7 ee			ld (debug_mark),a  
bd69 3a 78 bd			ld a, (.dmark+1)  
bd6c 32 b8 ee			ld (debug_mark+1),a  
bd6f 3a 79 bd			ld a, (.dmark+2)  
bd72 32 b9 ee			ld (debug_mark+2),a  
bd75 18 03			jr .pastdmark  
bd77 ..			.dmark: db "MNU"  
bd7a f1			.pastdmark: pop af  
bd7b			endm  
# End of macro DMARK
bd7b						CALLMONITOR 
bd7b cd a3 94			call break_point_state  
bd7e				endm  
# End of macro CALLMONITOR
bd7e					endif 
bd7e			 
bd7e 45					ld b, l	 
bd7f 05					dec b 
bd80			 
bd80					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd80 cd c3 9d			call macro_forth_dsp_pop 
bd83				endm 
# End of macro FORTH_DSP_POP
bd83			 
bd83			 
bd83					; go directly through the stack to pluck out the string pointers and build an array 
bd83			 
bd83			;		FORTH_DSP 
bd83			 
bd83					; hl contains top most stack item 
bd83				 
bd83 11 85 e4				ld de, scratch 
bd86			 
bd86			.mbuild: 
bd86			 
bd86					FORTH_DSP_VALUEHL 
bd86 cd 0b 9d			call macro_dsp_valuehl 
bd89				endm 
# End of macro FORTH_DSP_VALUEHL
bd89			 
bd89					if DEBUG_FORTH_WORDS 
bd89						DMARK "MN3" 
bd89 f5				push af  
bd8a 3a 9e bd			ld a, (.dmark)  
bd8d 32 b7 ee			ld (debug_mark),a  
bd90 3a 9f bd			ld a, (.dmark+1)  
bd93 32 b8 ee			ld (debug_mark+1),a  
bd96 3a a0 bd			ld a, (.dmark+2)  
bd99 32 b9 ee			ld (debug_mark+2),a  
bd9c 18 03			jr .pastdmark  
bd9e ..			.dmark: db "MN3"  
bda1 f1			.pastdmark: pop af  
bda2			endm  
# End of macro DMARK
bda2						CALLMONITOR 
bda2 cd a3 94			call break_point_state  
bda5				endm  
# End of macro CALLMONITOR
bda5					endif 
bda5 eb					ex de, hl 
bda6 73					ld (hl), e 
bda7 23					inc hl 
bda8 72					ld (hl), d 
bda9 23					inc hl 
bdaa eb					ex de, hl 
bdab			 
bdab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdab cd c3 9d			call macro_forth_dsp_pop 
bdae				endm 
# End of macro FORTH_DSP_POP
bdae			 
bdae 10 d6				djnz .mbuild 
bdb0			 
bdb0					; done add term 
bdb0			 
bdb0 eb					ex de, hl 
bdb1 36 00				ld (hl), 0 
bdb3 23					inc hl 
bdb4 36 00				ld (hl), 0 
bdb6			 
bdb6				 
bdb6					 
bdb6 21 85 e4				ld hl, scratch 
bdb9			 
bdb9					if DEBUG_FORTH_WORDS 
bdb9						DMARK "MNx" 
bdb9 f5				push af  
bdba 3a ce bd			ld a, (.dmark)  
bdbd 32 b7 ee			ld (debug_mark),a  
bdc0 3a cf bd			ld a, (.dmark+1)  
bdc3 32 b8 ee			ld (debug_mark+1),a  
bdc6 3a d0 bd			ld a, (.dmark+2)  
bdc9 32 b9 ee			ld (debug_mark+2),a  
bdcc 18 03			jr .pastdmark  
bdce ..			.dmark: db "MNx"  
bdd1 f1			.pastdmark: pop af  
bdd2			endm  
# End of macro DMARK
bdd2						CALLMONITOR 
bdd2 cd a3 94			call break_point_state  
bdd5				endm  
# End of macro CALLMONITOR
bdd5					endif 
bdd5			 
bdd5			 
bdd5			 
bdd5 3e 00				ld a, 0 
bdd7 cd a6 8a				call menu 
bdda			 
bdda			 
bdda 6f					ld l, a 
bddb 26 00				ld h, 0 
bddd			 
bddd					if DEBUG_FORTH_WORDS 
bddd						DMARK "MNr" 
bddd f5				push af  
bdde 3a f2 bd			ld a, (.dmark)  
bde1 32 b7 ee			ld (debug_mark),a  
bde4 3a f3 bd			ld a, (.dmark+1)  
bde7 32 b8 ee			ld (debug_mark+1),a  
bdea 3a f4 bd			ld a, (.dmark+2)  
bded 32 b9 ee			ld (debug_mark+2),a  
bdf0 18 03			jr .pastdmark  
bdf2 ..			.dmark: db "MNr"  
bdf5 f1			.pastdmark: pop af  
bdf6			endm  
# End of macro DMARK
bdf6						CALLMONITOR 
bdf6 cd a3 94			call break_point_state  
bdf9				endm  
# End of macro CALLMONITOR
bdf9					endif 
bdf9			 
bdf9 cd 14 9b				call forth_push_numhl 
bdfc			 
bdfc			 
bdfc			 
bdfc			 
bdfc				       NEXTW 
bdfc c3 82 9e			jp macro_next 
bdff				endm 
# End of macro NEXTW
bdff			 
bdff			 
bdff			.ENDDISPLAY: 
bdff			 
bdff			; eof 
# End of file forth_words_display.asm
bdff			include "forth_words_str.asm" 
bdff			 
bdff			; | ## String Words 
bdff			 
bdff			.PTR:   
bdff			 
bdff				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bdff 48				db WORD_SYS_CORE+52             
be00 2c be			dw .STYPE            
be02 04				db 3 + 1 
be03 .. 00			db "PTR",0              
be07				endm 
# End of macro CWHEAD
be07			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
be07			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
be07			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
be07			 
be07					if DEBUG_FORTH_WORDS_KEY 
be07						DMARK "PTR" 
be07 f5				push af  
be08 3a 1c be			ld a, (.dmark)  
be0b 32 b7 ee			ld (debug_mark),a  
be0e 3a 1d be			ld a, (.dmark+1)  
be11 32 b8 ee			ld (debug_mark+1),a  
be14 3a 1e be			ld a, (.dmark+2)  
be17 32 b9 ee			ld (debug_mark+2),a  
be1a 18 03			jr .pastdmark  
be1c ..			.dmark: db "PTR"  
be1f f1			.pastdmark: pop af  
be20			endm  
# End of macro DMARK
be20						CALLMONITOR 
be20 cd a3 94			call break_point_state  
be23				endm  
# End of macro CALLMONITOR
be23					endif 
be23					FORTH_DSP_VALUEHL 
be23 cd 0b 9d			call macro_dsp_valuehl 
be26				endm 
# End of macro FORTH_DSP_VALUEHL
be26 cd 14 9b				call forth_push_numhl 
be29			 
be29			 
be29					NEXTW 
be29 c3 82 9e			jp macro_next 
be2c				endm 
# End of macro NEXTW
be2c			.STYPE: 
be2c				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
be2c 48				db WORD_SYS_CORE+52             
be2d 7b be			dw .UPPER            
be2f 06				db 5 + 1 
be30 .. 00			db "STYPE",0              
be36				endm 
# End of macro CWHEAD
be36			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
be36					if DEBUG_FORTH_WORDS_KEY 
be36						DMARK "STY" 
be36 f5				push af  
be37 3a 4b be			ld a, (.dmark)  
be3a 32 b7 ee			ld (debug_mark),a  
be3d 3a 4c be			ld a, (.dmark+1)  
be40 32 b8 ee			ld (debug_mark+1),a  
be43 3a 4d be			ld a, (.dmark+2)  
be46 32 b9 ee			ld (debug_mark+2),a  
be49 18 03			jr .pastdmark  
be4b ..			.dmark: db "STY"  
be4e f1			.pastdmark: pop af  
be4f			endm  
# End of macro DMARK
be4f						CALLMONITOR 
be4f cd a3 94			call break_point_state  
be52				endm  
# End of macro CALLMONITOR
be52					endif 
be52					FORTH_DSP 
be52 cd d1 9c			call macro_forth_dsp 
be55				endm 
# End of macro FORTH_DSP
be55					;v5 FORTH_DSP_VALUE 
be55			 
be55 7e					ld a, (hl) 
be56			 
be56 f5					push af 
be57			 
be57			; Dont destroy TOS		FORTH_DSP_POP 
be57			 
be57 f1					pop af 
be58			 
be58 fe 01				cp DS_TYPE_STR 
be5a 28 09				jr z, .typestr 
be5c			 
be5c fe 02				cp DS_TYPE_INUM 
be5e 28 0a				jr z, .typeinum 
be60			 
be60 21 79 be				ld hl, .tna 
be63 18 0a				jr .tpush 
be65			 
be65 21 75 be		.typestr:	ld hl, .tstr 
be68 18 05				jr .tpush 
be6a 21 77 be		.typeinum:	ld hl, .tinum 
be6d 18 00				jr .tpush 
be6f			 
be6f			.tpush: 
be6f			 
be6f cd 82 9b				call forth_push_str 
be72			 
be72					NEXTW 
be72 c3 82 9e			jp macro_next 
be75				endm 
# End of macro NEXTW
be75 .. 00		.tstr:	db "s",0 
be77 .. 00		.tinum:  db "i",0 
be79 .. 00		.tna:   db "?", 0 
be7b			 
be7b			 
be7b			.UPPER: 
be7b				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
be7b 48				db WORD_SYS_CORE+52             
be7c b6 be			dw .LOWER            
be7e 06				db 5 + 1 
be7f .. 00			db "UPPER",0              
be85				endm 
# End of macro CWHEAD
be85			; | UPPER ( s -- s ) Upper case string s  | DONE 
be85					if DEBUG_FORTH_WORDS_KEY 
be85						DMARK "UPR" 
be85 f5				push af  
be86 3a 9a be			ld a, (.dmark)  
be89 32 b7 ee			ld (debug_mark),a  
be8c 3a 9b be			ld a, (.dmark+1)  
be8f 32 b8 ee			ld (debug_mark+1),a  
be92 3a 9c be			ld a, (.dmark+2)  
be95 32 b9 ee			ld (debug_mark+2),a  
be98 18 03			jr .pastdmark  
be9a ..			.dmark: db "UPR"  
be9d f1			.pastdmark: pop af  
be9e			endm  
# End of macro DMARK
be9e						CALLMONITOR 
be9e cd a3 94			call break_point_state  
bea1				endm  
# End of macro CALLMONITOR
bea1					endif 
bea1			 
bea1					FORTH_DSP 
bea1 cd d1 9c			call macro_forth_dsp 
bea4				endm 
# End of macro FORTH_DSP
bea4					 
bea4			; TODO check is string type 
bea4			 
bea4					FORTH_DSP_VALUEHL 
bea4 cd 0b 9d			call macro_dsp_valuehl 
bea7				endm 
# End of macro FORTH_DSP_VALUEHL
bea7			; get pointer to string in hl 
bea7			 
bea7 7e			.toup:		ld a, (hl) 
bea8 fe 00				cp 0 
beaa 28 07				jr z, .toupdone 
beac			 
beac cd 0f 90				call to_upper 
beaf			 
beaf 77					ld (hl), a 
beb0 23					inc hl 
beb1 18 f4				jr .toup 
beb3			 
beb3					 
beb3			 
beb3			 
beb3			; for each char convert to upper 
beb3					 
beb3			.toupdone: 
beb3			 
beb3			 
beb3					NEXTW 
beb3 c3 82 9e			jp macro_next 
beb6				endm 
# End of macro NEXTW
beb6			.LOWER: 
beb6				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
beb6 48				db WORD_SYS_CORE+52             
beb7 f1 be			dw .TCASE            
beb9 06				db 5 + 1 
beba .. 00			db "LOWER",0              
bec0				endm 
# End of macro CWHEAD
bec0			; | LOWER ( s -- s ) Lower case string s  | DONE 
bec0					if DEBUG_FORTH_WORDS_KEY 
bec0						DMARK "LWR" 
bec0 f5				push af  
bec1 3a d5 be			ld a, (.dmark)  
bec4 32 b7 ee			ld (debug_mark),a  
bec7 3a d6 be			ld a, (.dmark+1)  
beca 32 b8 ee			ld (debug_mark+1),a  
becd 3a d7 be			ld a, (.dmark+2)  
bed0 32 b9 ee			ld (debug_mark+2),a  
bed3 18 03			jr .pastdmark  
bed5 ..			.dmark: db "LWR"  
bed8 f1			.pastdmark: pop af  
bed9			endm  
# End of macro DMARK
bed9						CALLMONITOR 
bed9 cd a3 94			call break_point_state  
bedc				endm  
# End of macro CALLMONITOR
bedc					endif 
bedc			 
bedc					FORTH_DSP 
bedc cd d1 9c			call macro_forth_dsp 
bedf				endm 
# End of macro FORTH_DSP
bedf					 
bedf			; TODO check is string type 
bedf			 
bedf					FORTH_DSP_VALUEHL 
bedf cd 0b 9d			call macro_dsp_valuehl 
bee2				endm 
# End of macro FORTH_DSP_VALUEHL
bee2			; get pointer to string in hl 
bee2			 
bee2 7e			.tolow:		ld a, (hl) 
bee3 fe 00				cp 0 
bee5 28 07				jr z, .tolowdone 
bee7			 
bee7 cd 18 90				call to_lower 
beea			 
beea 77					ld (hl), a 
beeb 23					inc hl 
beec 18 f4				jr .tolow 
beee			 
beee					 
beee			 
beee			 
beee			; for each char convert to low 
beee					 
beee			.tolowdone: 
beee					NEXTW 
beee c3 82 9e			jp macro_next 
bef1				endm 
# End of macro NEXTW
bef1			.TCASE: 
bef1				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bef1 48				db WORD_SYS_CORE+52             
bef2 27 c0			dw .SUBSTR            
bef4 06				db 5 + 1 
bef5 .. 00			db "TCASE",0              
befb				endm 
# End of macro CWHEAD
befb			; | TCASE ( s -- s ) Title case string s  | DONE 
befb					if DEBUG_FORTH_WORDS_KEY 
befb						DMARK "TCS" 
befb f5				push af  
befc 3a 10 bf			ld a, (.dmark)  
beff 32 b7 ee			ld (debug_mark),a  
bf02 3a 11 bf			ld a, (.dmark+1)  
bf05 32 b8 ee			ld (debug_mark+1),a  
bf08 3a 12 bf			ld a, (.dmark+2)  
bf0b 32 b9 ee			ld (debug_mark+2),a  
bf0e 18 03			jr .pastdmark  
bf10 ..			.dmark: db "TCS"  
bf13 f1			.pastdmark: pop af  
bf14			endm  
# End of macro DMARK
bf14						CALLMONITOR 
bf14 cd a3 94			call break_point_state  
bf17				endm  
# End of macro CALLMONITOR
bf17					endif 
bf17			 
bf17					FORTH_DSP 
bf17 cd d1 9c			call macro_forth_dsp 
bf1a				endm 
# End of macro FORTH_DSP
bf1a					 
bf1a			; TODO check is string type 
bf1a			 
bf1a					FORTH_DSP_VALUEHL 
bf1a cd 0b 9d			call macro_dsp_valuehl 
bf1d				endm 
# End of macro FORTH_DSP_VALUEHL
bf1d			; get pointer to string in hl 
bf1d			 
bf1d					if DEBUG_FORTH_WORDS 
bf1d						DMARK "TC1" 
bf1d f5				push af  
bf1e 3a 32 bf			ld a, (.dmark)  
bf21 32 b7 ee			ld (debug_mark),a  
bf24 3a 33 bf			ld a, (.dmark+1)  
bf27 32 b8 ee			ld (debug_mark+1),a  
bf2a 3a 34 bf			ld a, (.dmark+2)  
bf2d 32 b9 ee			ld (debug_mark+2),a  
bf30 18 03			jr .pastdmark  
bf32 ..			.dmark: db "TC1"  
bf35 f1			.pastdmark: pop af  
bf36			endm  
# End of macro DMARK
bf36						CALLMONITOR 
bf36 cd a3 94			call break_point_state  
bf39				endm  
# End of macro CALLMONITOR
bf39					endif 
bf39			 
bf39					; first time in turn to upper case first char 
bf39			 
bf39 7e					ld a, (hl) 
bf3a c3 c4 bf				jp .totsiptou 
bf3d			 
bf3d			 
bf3d 7e			.tot:		ld a, (hl) 
bf3e fe 00				cp 0 
bf40 ca 08 c0				jp z, .totdone 
bf43			 
bf43					if DEBUG_FORTH_WORDS 
bf43						DMARK "TC2" 
bf43 f5				push af  
bf44 3a 58 bf			ld a, (.dmark)  
bf47 32 b7 ee			ld (debug_mark),a  
bf4a 3a 59 bf			ld a, (.dmark+1)  
bf4d 32 b8 ee			ld (debug_mark+1),a  
bf50 3a 5a bf			ld a, (.dmark+2)  
bf53 32 b9 ee			ld (debug_mark+2),a  
bf56 18 03			jr .pastdmark  
bf58 ..			.dmark: db "TC2"  
bf5b f1			.pastdmark: pop af  
bf5c			endm  
# End of macro DMARK
bf5c						CALLMONITOR 
bf5c cd a3 94			call break_point_state  
bf5f				endm  
# End of macro CALLMONITOR
bf5f					endif 
bf5f					; check to see if current char is a space 
bf5f			 
bf5f fe 20				cp ' ' 
bf61 28 21				jr z, .totsp 
bf63 cd 18 90				call to_lower 
bf66					if DEBUG_FORTH_WORDS 
bf66						DMARK "TC3" 
bf66 f5				push af  
bf67 3a 7b bf			ld a, (.dmark)  
bf6a 32 b7 ee			ld (debug_mark),a  
bf6d 3a 7c bf			ld a, (.dmark+1)  
bf70 32 b8 ee			ld (debug_mark+1),a  
bf73 3a 7d bf			ld a, (.dmark+2)  
bf76 32 b9 ee			ld (debug_mark+2),a  
bf79 18 03			jr .pastdmark  
bf7b ..			.dmark: db "TC3"  
bf7e f1			.pastdmark: pop af  
bf7f			endm  
# End of macro DMARK
bf7f						CALLMONITOR 
bf7f cd a3 94			call break_point_state  
bf82				endm  
# End of macro CALLMONITOR
bf82					endif 
bf82 18 63				jr .totnxt 
bf84			 
bf84			.totsp:         ; on a space, find next char which should be upper 
bf84			 
bf84					if DEBUG_FORTH_WORDS 
bf84						DMARK "TC4" 
bf84 f5				push af  
bf85 3a 99 bf			ld a, (.dmark)  
bf88 32 b7 ee			ld (debug_mark),a  
bf8b 3a 9a bf			ld a, (.dmark+1)  
bf8e 32 b8 ee			ld (debug_mark+1),a  
bf91 3a 9b bf			ld a, (.dmark+2)  
bf94 32 b9 ee			ld (debug_mark+2),a  
bf97 18 03			jr .pastdmark  
bf99 ..			.dmark: db "TC4"  
bf9c f1			.pastdmark: pop af  
bf9d			endm  
# End of macro DMARK
bf9d						CALLMONITOR 
bf9d cd a3 94			call break_point_state  
bfa0				endm  
# End of macro CALLMONITOR
bfa0					endif 
bfa0					;; 
bfa0			 
bfa0 fe 20				cp ' ' 
bfa2 20 20				jr nz, .totsiptou 
bfa4 23					inc hl 
bfa5 7e					ld a, (hl) 
bfa6					if DEBUG_FORTH_WORDS 
bfa6						DMARK "TC5" 
bfa6 f5				push af  
bfa7 3a bb bf			ld a, (.dmark)  
bfaa 32 b7 ee			ld (debug_mark),a  
bfad 3a bc bf			ld a, (.dmark+1)  
bfb0 32 b8 ee			ld (debug_mark+1),a  
bfb3 3a bd bf			ld a, (.dmark+2)  
bfb6 32 b9 ee			ld (debug_mark+2),a  
bfb9 18 03			jr .pastdmark  
bfbb ..			.dmark: db "TC5"  
bfbe f1			.pastdmark: pop af  
bfbf			endm  
# End of macro DMARK
bfbf						CALLMONITOR 
bfbf cd a3 94			call break_point_state  
bfc2				endm  
# End of macro CALLMONITOR
bfc2					endif 
bfc2 18 c0				jr .totsp 
bfc4 fe 00		.totsiptou:    cp 0 
bfc6 28 40				jr z, .totdone 
bfc8					; not space and not zero term so upper case it 
bfc8 cd 0f 90				call to_upper 
bfcb			 
bfcb					if DEBUG_FORTH_WORDS 
bfcb						DMARK "TC6" 
bfcb f5				push af  
bfcc 3a e0 bf			ld a, (.dmark)  
bfcf 32 b7 ee			ld (debug_mark),a  
bfd2 3a e1 bf			ld a, (.dmark+1)  
bfd5 32 b8 ee			ld (debug_mark+1),a  
bfd8 3a e2 bf			ld a, (.dmark+2)  
bfdb 32 b9 ee			ld (debug_mark+2),a  
bfde 18 03			jr .pastdmark  
bfe0 ..			.dmark: db "TC6"  
bfe3 f1			.pastdmark: pop af  
bfe4			endm  
# End of macro DMARK
bfe4						CALLMONITOR 
bfe4 cd a3 94			call break_point_state  
bfe7				endm  
# End of macro CALLMONITOR
bfe7					endif 
bfe7			 
bfe7			 
bfe7			.totnxt: 
bfe7			 
bfe7 77					ld (hl), a 
bfe8 23					inc hl 
bfe9					if DEBUG_FORTH_WORDS 
bfe9						DMARK "TC7" 
bfe9 f5				push af  
bfea 3a fe bf			ld a, (.dmark)  
bfed 32 b7 ee			ld (debug_mark),a  
bff0 3a ff bf			ld a, (.dmark+1)  
bff3 32 b8 ee			ld (debug_mark+1),a  
bff6 3a 00 c0			ld a, (.dmark+2)  
bff9 32 b9 ee			ld (debug_mark+2),a  
bffc 18 03			jr .pastdmark  
bffe ..			.dmark: db "TC7"  
c001 f1			.pastdmark: pop af  
c002			endm  
# End of macro DMARK
c002						CALLMONITOR 
c002 cd a3 94			call break_point_state  
c005				endm  
# End of macro CALLMONITOR
c005					endif 
c005 c3 3d bf				jp .tot 
c008			 
c008					 
c008			 
c008			 
c008			; for each char convert to low 
c008					 
c008			.totdone: 
c008					if DEBUG_FORTH_WORDS 
c008						DMARK "TCd" 
c008 f5				push af  
c009 3a 1d c0			ld a, (.dmark)  
c00c 32 b7 ee			ld (debug_mark),a  
c00f 3a 1e c0			ld a, (.dmark+1)  
c012 32 b8 ee			ld (debug_mark+1),a  
c015 3a 1f c0			ld a, (.dmark+2)  
c018 32 b9 ee			ld (debug_mark+2),a  
c01b 18 03			jr .pastdmark  
c01d ..			.dmark: db "TCd"  
c020 f1			.pastdmark: pop af  
c021			endm  
# End of macro DMARK
c021						CALLMONITOR 
c021 cd a3 94			call break_point_state  
c024				endm  
# End of macro CALLMONITOR
c024					endif 
c024					NEXTW 
c024 c3 82 9e			jp macro_next 
c027				endm 
# End of macro NEXTW
c027			 
c027			.SUBSTR: 
c027				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c027 48				db WORD_SYS_CORE+52             
c028 85 c0			dw .LEFT            
c02a 07				db 6 + 1 
c02b .. 00			db "SUBSTR",0              
c032				endm 
# End of macro CWHEAD
c032			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c032			 
c032					if DEBUG_FORTH_WORDS_KEY 
c032						DMARK "SST" 
c032 f5				push af  
c033 3a 47 c0			ld a, (.dmark)  
c036 32 b7 ee			ld (debug_mark),a  
c039 3a 48 c0			ld a, (.dmark+1)  
c03c 32 b8 ee			ld (debug_mark+1),a  
c03f 3a 49 c0			ld a, (.dmark+2)  
c042 32 b9 ee			ld (debug_mark+2),a  
c045 18 03			jr .pastdmark  
c047 ..			.dmark: db "SST"  
c04a f1			.pastdmark: pop af  
c04b			endm  
# End of macro DMARK
c04b						CALLMONITOR 
c04b cd a3 94			call break_point_state  
c04e				endm  
# End of macro CALLMONITOR
c04e					endif 
c04e			; TODO check string type 
c04e					FORTH_DSP_VALUEHL 
c04e cd 0b 9d			call macro_dsp_valuehl 
c051				endm 
# End of macro FORTH_DSP_VALUEHL
c051			 
c051 e5					push hl      ; string length 
c052			 
c052					FORTH_DSP_POP 
c052 cd c3 9d			call macro_forth_dsp_pop 
c055				endm 
# End of macro FORTH_DSP_POP
c055			 
c055					FORTH_DSP_VALUEHL 
c055 cd 0b 9d			call macro_dsp_valuehl 
c058				endm 
# End of macro FORTH_DSP_VALUEHL
c058			 
c058 e5					push hl     ; start char 
c059			 
c059					FORTH_DSP_POP 
c059 cd c3 9d			call macro_forth_dsp_pop 
c05c				endm 
# End of macro FORTH_DSP_POP
c05c			 
c05c			 
c05c					FORTH_DSP_VALUE 
c05c cd f4 9c			call macro_forth_dsp_value 
c05f				endm 
# End of macro FORTH_DSP_VALUE
c05f			 
c05f d1					pop de    ; get start post offset 
c060			 
c060 19					add hl, de    ; starting offset 
c061			 
c061 c1					pop bc 
c062 c5					push bc      ; grab size of string 
c063			 
c063 e5					push hl    ; save string start  
c064			 
c064 26 00				ld h, 0 
c066 69					ld l, c 
c067 23					inc hl 
c068 23					inc hl 
c069			 
c069 cd 69 91				call malloc 
c06c				if DEBUG_FORTH_MALLOC_GUARD 
c06c cc e9 c6				call z,malloc_error 
c06f				endif 
c06f			 
c06f eb					ex de, hl      ; save malloc area for string copy 
c070 e1					pop hl    ; get back source 
c071 c1					pop bc    ; get length of string back 
c072			 
c072 d5					push de    ; save malloc area for after we push 
c073 ed b0				ldir     ; copy substr 
c075			 
c075			 
c075 eb					ex de, hl 
c076 3e 00				ld a, 0 
c078 77					ld (hl), a   ; term substr 
c079			 
c079					 
c079 e1					pop hl    ; get malloc so we can push it 
c07a e5					push hl   ; save so we can free it afterwards 
c07b			 
c07b cd 82 9b				call forth_push_str 
c07e			 
c07e e1					pop hl 
c07f cd 33 92				call free 
c082			 
c082					 
c082					 
c082			 
c082			 
c082					NEXTW 
c082 c3 82 9e			jp macro_next 
c085				endm 
# End of macro NEXTW
c085			 
c085			.LEFT: 
c085				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c085 48				db WORD_SYS_CORE+52             
c086 ad c0			dw .RIGHT            
c088 05				db 4 + 1 
c089 .. 00			db "LEFT",0              
c08e				endm 
# End of macro CWHEAD
c08e			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c08e					if DEBUG_FORTH_WORDS_KEY 
c08e						DMARK "LEF" 
c08e f5				push af  
c08f 3a a3 c0			ld a, (.dmark)  
c092 32 b7 ee			ld (debug_mark),a  
c095 3a a4 c0			ld a, (.dmark+1)  
c098 32 b8 ee			ld (debug_mark+1),a  
c09b 3a a5 c0			ld a, (.dmark+2)  
c09e 32 b9 ee			ld (debug_mark+2),a  
c0a1 18 03			jr .pastdmark  
c0a3 ..			.dmark: db "LEF"  
c0a6 f1			.pastdmark: pop af  
c0a7			endm  
# End of macro DMARK
c0a7						CALLMONITOR 
c0a7 cd a3 94			call break_point_state  
c0aa				endm  
# End of macro CALLMONITOR
c0aa					endif 
c0aa			 
c0aa					NEXTW 
c0aa c3 82 9e			jp macro_next 
c0ad				endm 
# End of macro NEXTW
c0ad			.RIGHT: 
c0ad				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c0ad 48				db WORD_SYS_CORE+52             
c0ae d6 c0			dw .STR2NUM            
c0b0 06				db 5 + 1 
c0b1 .. 00			db "RIGHT",0              
c0b7				endm 
# End of macro CWHEAD
c0b7			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c0b7					if DEBUG_FORTH_WORDS_KEY 
c0b7						DMARK "RIG" 
c0b7 f5				push af  
c0b8 3a cc c0			ld a, (.dmark)  
c0bb 32 b7 ee			ld (debug_mark),a  
c0be 3a cd c0			ld a, (.dmark+1)  
c0c1 32 b8 ee			ld (debug_mark+1),a  
c0c4 3a ce c0			ld a, (.dmark+2)  
c0c7 32 b9 ee			ld (debug_mark+2),a  
c0ca 18 03			jr .pastdmark  
c0cc ..			.dmark: db "RIG"  
c0cf f1			.pastdmark: pop af  
c0d0			endm  
# End of macro DMARK
c0d0						CALLMONITOR 
c0d0 cd a3 94			call break_point_state  
c0d3				endm  
# End of macro CALLMONITOR
c0d3					endif 
c0d3			 
c0d3					NEXTW 
c0d3 c3 82 9e			jp macro_next 
c0d6				endm 
# End of macro NEXTW
c0d6			 
c0d6			 
c0d6			.STR2NUM: 
c0d6				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c0d6 48				db WORD_SYS_CORE+52             
c0d7 62 c1			dw .NUM2STR            
c0d9 08				db 7 + 1 
c0da .. 00			db "STR2NUM",0              
c0e2				endm 
# End of macro CWHEAD
c0e2			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c0e2			 
c0e2			 
c0e2			; TODO STR type check to do 
c0e2					if DEBUG_FORTH_WORDS_KEY 
c0e2						DMARK "S2N" 
c0e2 f5				push af  
c0e3 3a f7 c0			ld a, (.dmark)  
c0e6 32 b7 ee			ld (debug_mark),a  
c0e9 3a f8 c0			ld a, (.dmark+1)  
c0ec 32 b8 ee			ld (debug_mark+1),a  
c0ef 3a f9 c0			ld a, (.dmark+2)  
c0f2 32 b9 ee			ld (debug_mark+2),a  
c0f5 18 03			jr .pastdmark  
c0f7 ..			.dmark: db "S2N"  
c0fa f1			.pastdmark: pop af  
c0fb			endm  
# End of macro DMARK
c0fb						CALLMONITOR 
c0fb cd a3 94			call break_point_state  
c0fe				endm  
# End of macro CALLMONITOR
c0fe					endif 
c0fe			 
c0fe					;FORTH_DSP 
c0fe					FORTH_DSP_VALUE 
c0fe cd f4 9c			call macro_forth_dsp_value 
c101				endm 
# End of macro FORTH_DSP_VALUE
c101					;inc hl 
c101			 
c101 eb					ex de, hl 
c102					if DEBUG_FORTH_WORDS 
c102						DMARK "S2a" 
c102 f5				push af  
c103 3a 17 c1			ld a, (.dmark)  
c106 32 b7 ee			ld (debug_mark),a  
c109 3a 18 c1			ld a, (.dmark+1)  
c10c 32 b8 ee			ld (debug_mark+1),a  
c10f 3a 19 c1			ld a, (.dmark+2)  
c112 32 b9 ee			ld (debug_mark+2),a  
c115 18 03			jr .pastdmark  
c117 ..			.dmark: db "S2a"  
c11a f1			.pastdmark: pop af  
c11b			endm  
# End of macro DMARK
c11b						CALLMONITOR 
c11b cd a3 94			call break_point_state  
c11e				endm  
# End of macro CALLMONITOR
c11e					endif 
c11e cd 97 90				call string_to_uint16 
c121			 
c121					if DEBUG_FORTH_WORDS 
c121						DMARK "S2b" 
c121 f5				push af  
c122 3a 36 c1			ld a, (.dmark)  
c125 32 b7 ee			ld (debug_mark),a  
c128 3a 37 c1			ld a, (.dmark+1)  
c12b 32 b8 ee			ld (debug_mark+1),a  
c12e 3a 38 c1			ld a, (.dmark+2)  
c131 32 b9 ee			ld (debug_mark+2),a  
c134 18 03			jr .pastdmark  
c136 ..			.dmark: db "S2b"  
c139 f1			.pastdmark: pop af  
c13a			endm  
# End of macro DMARK
c13a						CALLMONITOR 
c13a cd a3 94			call break_point_state  
c13d				endm  
# End of macro CALLMONITOR
c13d					endif 
c13d			;		push hl 
c13d					FORTH_DSP_POP 
c13d cd c3 9d			call macro_forth_dsp_pop 
c140				endm 
# End of macro FORTH_DSP_POP
c140			;		pop hl 
c140					 
c140					if DEBUG_FORTH_WORDS 
c140						DMARK "S2b" 
c140 f5				push af  
c141 3a 55 c1			ld a, (.dmark)  
c144 32 b7 ee			ld (debug_mark),a  
c147 3a 56 c1			ld a, (.dmark+1)  
c14a 32 b8 ee			ld (debug_mark+1),a  
c14d 3a 57 c1			ld a, (.dmark+2)  
c150 32 b9 ee			ld (debug_mark+2),a  
c153 18 03			jr .pastdmark  
c155 ..			.dmark: db "S2b"  
c158 f1			.pastdmark: pop af  
c159			endm  
# End of macro DMARK
c159						CALLMONITOR 
c159 cd a3 94			call break_point_state  
c15c				endm  
# End of macro CALLMONITOR
c15c					endif 
c15c cd 14 9b				call forth_push_numhl	 
c15f			 
c15f				 
c15f				       NEXTW 
c15f c3 82 9e			jp macro_next 
c162				endm 
# End of macro NEXTW
c162			.NUM2STR: 
c162				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c162 48				db WORD_SYS_CORE+52             
c163 71 c1			dw .CONCAT            
c165 08				db 7 + 1 
c166 .. 00			db "NUM2STR",0              
c16e				endm 
# End of macro CWHEAD
c16e			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c16e			 
c16e			;		; malloc a string to target 
c16e			;		ld hl, 10     ; TODO max string size should be fine 
c16e			;		call malloc 
c16e			;		push hl    ; save malloc location 
c16e			; 
c16e			; 
c16e			;; TODO check int type 
c16e			;		FORTH_DSP_VALUEHL 
c16e			;		ld a, l 
c16e			;		call DispAToASCII   
c16e			;;TODO need to chage above call to dump into string 
c16e			; 
c16e			; 
c16e			 
c16e				       NEXTW 
c16e c3 82 9e			jp macro_next 
c171				endm 
# End of macro NEXTW
c171			 
c171			.CONCAT: 
c171				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c171 48				db WORD_SYS_CORE+52             
c172 24 c2			dw .FIND            
c174 07				db 6 + 1 
c175 .. 00			db "CONCAT",0              
c17c				endm 
# End of macro CWHEAD
c17c			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c17c			 
c17c			; TODO check string type 
c17c			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c17c			 
c17c					if DEBUG_FORTH_WORDS_KEY 
c17c						DMARK "CON" 
c17c f5				push af  
c17d 3a 91 c1			ld a, (.dmark)  
c180 32 b7 ee			ld (debug_mark),a  
c183 3a 92 c1			ld a, (.dmark+1)  
c186 32 b8 ee			ld (debug_mark+1),a  
c189 3a 93 c1			ld a, (.dmark+2)  
c18c 32 b9 ee			ld (debug_mark+2),a  
c18f 18 03			jr .pastdmark  
c191 ..			.dmark: db "CON"  
c194 f1			.pastdmark: pop af  
c195			endm  
# End of macro DMARK
c195						CALLMONITOR 
c195 cd a3 94			call break_point_state  
c198				endm  
# End of macro CALLMONITOR
c198					endif 
c198			 
c198			 
c198					FORTH_DSP_VALUE 
c198 cd f4 9c			call macro_forth_dsp_value 
c19b				endm 
# End of macro FORTH_DSP_VALUE
c19b e5					push hl   ; s2 
c19c			 
c19c					FORTH_DSP_POP 
c19c cd c3 9d			call macro_forth_dsp_pop 
c19f				endm 
# End of macro FORTH_DSP_POP
c19f			 
c19f					FORTH_DSP_VALUE 
c19f cd f4 9c			call macro_forth_dsp_value 
c1a2				endm 
# End of macro FORTH_DSP_VALUE
c1a2			 
c1a2 e5					push hl   ; s1 
c1a3			 
c1a3					FORTH_DSP_POP 
c1a3 cd c3 9d			call macro_forth_dsp_pop 
c1a6				endm 
# End of macro FORTH_DSP_POP
c1a6					 
c1a6			 
c1a6					; copy s1 
c1a6			 
c1a6				 
c1a6					; save ptr 
c1a6 e1					pop hl  
c1a7 e5					push hl 
c1a8 3e 00				ld a, 0 
c1aa cd 0b 91				call strlent 
c1ad					;inc hl    ; zer0 
c1ad 06 00				ld b, 0 
c1af 4d					ld c, l 
c1b0 e1					pop hl		 
c1b1 11 85 e4				ld de, scratch	 
c1b4					if DEBUG_FORTH_WORDS 
c1b4						DMARK "CO1" 
c1b4 f5				push af  
c1b5 3a c9 c1			ld a, (.dmark)  
c1b8 32 b7 ee			ld (debug_mark),a  
c1bb 3a ca c1			ld a, (.dmark+1)  
c1be 32 b8 ee			ld (debug_mark+1),a  
c1c1 3a cb c1			ld a, (.dmark+2)  
c1c4 32 b9 ee			ld (debug_mark+2),a  
c1c7 18 03			jr .pastdmark  
c1c9 ..			.dmark: db "CO1"  
c1cc f1			.pastdmark: pop af  
c1cd			endm  
# End of macro DMARK
c1cd						CALLMONITOR 
c1cd cd a3 94			call break_point_state  
c1d0				endm  
# End of macro CALLMONITOR
c1d0					endif 
c1d0 ed b0				ldir 
c1d2			 
c1d2 e1					pop hl 
c1d3 e5					push hl 
c1d4 d5					push de 
c1d5			 
c1d5			 
c1d5 3e 00				ld a, 0 
c1d7 cd 0b 91				call strlent 
c1da 23					inc hl    ; zer0 
c1db 23					inc hl 
c1dc 06 00				ld b, 0 
c1de 4d					ld c, l 
c1df d1					pop de 
c1e0 e1					pop hl		 
c1e1					if DEBUG_FORTH_WORDS 
c1e1						DMARK "CO2" 
c1e1 f5				push af  
c1e2 3a f6 c1			ld a, (.dmark)  
c1e5 32 b7 ee			ld (debug_mark),a  
c1e8 3a f7 c1			ld a, (.dmark+1)  
c1eb 32 b8 ee			ld (debug_mark+1),a  
c1ee 3a f8 c1			ld a, (.dmark+2)  
c1f1 32 b9 ee			ld (debug_mark+2),a  
c1f4 18 03			jr .pastdmark  
c1f6 ..			.dmark: db "CO2"  
c1f9 f1			.pastdmark: pop af  
c1fa			endm  
# End of macro DMARK
c1fa						CALLMONITOR 
c1fa cd a3 94			call break_point_state  
c1fd				endm  
# End of macro CALLMONITOR
c1fd					endif 
c1fd ed b0				ldir 
c1ff			 
c1ff			 
c1ff			 
c1ff 21 85 e4				ld hl, scratch 
c202					if DEBUG_FORTH_WORDS 
c202						DMARK "CO5" 
c202 f5				push af  
c203 3a 17 c2			ld a, (.dmark)  
c206 32 b7 ee			ld (debug_mark),a  
c209 3a 18 c2			ld a, (.dmark+1)  
c20c 32 b8 ee			ld (debug_mark+1),a  
c20f 3a 19 c2			ld a, (.dmark+2)  
c212 32 b9 ee			ld (debug_mark+2),a  
c215 18 03			jr .pastdmark  
c217 ..			.dmark: db "CO5"  
c21a f1			.pastdmark: pop af  
c21b			endm  
# End of macro DMARK
c21b						CALLMONITOR 
c21b cd a3 94			call break_point_state  
c21e				endm  
# End of macro CALLMONITOR
c21e					endif 
c21e			 
c21e cd 82 9b				call forth_push_str 
c221			 
c221			 
c221			 
c221			 
c221				       NEXTW 
c221 c3 82 9e			jp macro_next 
c224				endm 
# End of macro NEXTW
c224			 
c224			 
c224			.FIND: 
c224				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c224 4b				db WORD_SYS_CORE+55             
c225 e2 c2			dw .LEN            
c227 05				db 4 + 1 
c228 .. 00			db "FIND",0              
c22d				endm 
# End of macro CWHEAD
c22d			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c22d			 
c22d					if DEBUG_FORTH_WORDS_KEY 
c22d						DMARK "FND" 
c22d f5				push af  
c22e 3a 42 c2			ld a, (.dmark)  
c231 32 b7 ee			ld (debug_mark),a  
c234 3a 43 c2			ld a, (.dmark+1)  
c237 32 b8 ee			ld (debug_mark+1),a  
c23a 3a 44 c2			ld a, (.dmark+2)  
c23d 32 b9 ee			ld (debug_mark+2),a  
c240 18 03			jr .pastdmark  
c242 ..			.dmark: db "FND"  
c245 f1			.pastdmark: pop af  
c246			endm  
# End of macro DMARK
c246						CALLMONITOR 
c246 cd a3 94			call break_point_state  
c249				endm  
# End of macro CALLMONITOR
c249					endif 
c249			 
c249			; TODO check string type 
c249					FORTH_DSP_VALUE 
c249 cd f4 9c			call macro_forth_dsp_value 
c24c				endm 
# End of macro FORTH_DSP_VALUE
c24c			 
c24c e5					push hl    
c24d 7e					ld a,(hl)    ; char to find   
c24e			; TODO change char to substr 
c24e			 
c24e f5					push af 
c24f					 
c24f			 
c24f			 
c24f					if DEBUG_FORTH_WORDS 
c24f						DMARK "FN1" 
c24f f5				push af  
c250 3a 64 c2			ld a, (.dmark)  
c253 32 b7 ee			ld (debug_mark),a  
c256 3a 65 c2			ld a, (.dmark+1)  
c259 32 b8 ee			ld (debug_mark+1),a  
c25c 3a 66 c2			ld a, (.dmark+2)  
c25f 32 b9 ee			ld (debug_mark+2),a  
c262 18 03			jr .pastdmark  
c264 ..			.dmark: db "FN1"  
c267 f1			.pastdmark: pop af  
c268			endm  
# End of macro DMARK
c268						CALLMONITOR 
c268 cd a3 94			call break_point_state  
c26b				endm  
# End of macro CALLMONITOR
c26b					endif 
c26b			 
c26b					FORTH_DSP_POP 
c26b cd c3 9d			call macro_forth_dsp_pop 
c26e				endm 
# End of macro FORTH_DSP_POP
c26e			 
c26e					; string to search 
c26e			 
c26e					FORTH_DSP_VALUE 
c26e cd f4 9c			call macro_forth_dsp_value 
c271				endm 
# End of macro FORTH_DSP_VALUE
c271			 
c271 d1					pop de  ; d is char to find  
c272			 
c272					if DEBUG_FORTH_WORDS 
c272						DMARK "FN2" 
c272 f5				push af  
c273 3a 87 c2			ld a, (.dmark)  
c276 32 b7 ee			ld (debug_mark),a  
c279 3a 88 c2			ld a, (.dmark+1)  
c27c 32 b8 ee			ld (debug_mark+1),a  
c27f 3a 89 c2			ld a, (.dmark+2)  
c282 32 b9 ee			ld (debug_mark+2),a  
c285 18 03			jr .pastdmark  
c287 ..			.dmark: db "FN2"  
c28a f1			.pastdmark: pop af  
c28b			endm  
# End of macro DMARK
c28b						CALLMONITOR 
c28b cd a3 94			call break_point_state  
c28e				endm  
# End of macro CALLMONITOR
c28e					endif 
c28e					 
c28e 01 00 00				ld bc, 0 
c291 7e			.findchar:      ld a,(hl) 
c292 fe 00				cp 0   		 
c294 28 27				jr z, .finddone     
c296 ba					cp d 
c297 28 20				jr z, .foundchar 
c299 03					inc bc 
c29a 23					inc hl 
c29b					if DEBUG_FORTH_WORDS 
c29b						DMARK "FN3" 
c29b f5				push af  
c29c 3a b0 c2			ld a, (.dmark)  
c29f 32 b7 ee			ld (debug_mark),a  
c2a2 3a b1 c2			ld a, (.dmark+1)  
c2a5 32 b8 ee			ld (debug_mark+1),a  
c2a8 3a b2 c2			ld a, (.dmark+2)  
c2ab 32 b9 ee			ld (debug_mark+2),a  
c2ae 18 03			jr .pastdmark  
c2b0 ..			.dmark: db "FN3"  
c2b3 f1			.pastdmark: pop af  
c2b4			endm  
# End of macro DMARK
c2b4						CALLMONITOR 
c2b4 cd a3 94			call break_point_state  
c2b7				endm  
# End of macro CALLMONITOR
c2b7					endif 
c2b7 18 d8				jr .findchar 
c2b9			 
c2b9			 
c2b9 c5			.foundchar:	push bc 
c2ba e1					pop hl 
c2bb 18 03				jr .findexit 
c2bd			 
c2bd			 
c2bd							 
c2bd			 
c2bd			.finddone:     ; got to end of string with no find 
c2bd 21 00 00				ld hl, 0 
c2c0			.findexit: 
c2c0			 
c2c0					if DEBUG_FORTH_WORDS 
c2c0						DMARK "FNd" 
c2c0 f5				push af  
c2c1 3a d5 c2			ld a, (.dmark)  
c2c4 32 b7 ee			ld (debug_mark),a  
c2c7 3a d6 c2			ld a, (.dmark+1)  
c2ca 32 b8 ee			ld (debug_mark+1),a  
c2cd 3a d7 c2			ld a, (.dmark+2)  
c2d0 32 b9 ee			ld (debug_mark+2),a  
c2d3 18 03			jr .pastdmark  
c2d5 ..			.dmark: db "FNd"  
c2d8 f1			.pastdmark: pop af  
c2d9			endm  
# End of macro DMARK
c2d9						CALLMONITOR 
c2d9 cd a3 94			call break_point_state  
c2dc				endm  
# End of macro CALLMONITOR
c2dc					endif 
c2dc cd 14 9b			call forth_push_numhl 
c2df			 
c2df				       NEXTW 
c2df c3 82 9e			jp macro_next 
c2e2				endm 
# End of macro NEXTW
c2e2			 
c2e2			.LEN: 
c2e2				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c2e2 4c				db WORD_SYS_CORE+56             
c2e3 4c c3			dw .CHAR            
c2e5 06				db 5 + 1 
c2e6 .. 00			db "COUNT",0              
c2ec				endm 
# End of macro CWHEAD
c2ec			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c2ec			 
c2ec					if DEBUG_FORTH_WORDS_KEY 
c2ec						DMARK "CNT" 
c2ec f5				push af  
c2ed 3a 01 c3			ld a, (.dmark)  
c2f0 32 b7 ee			ld (debug_mark),a  
c2f3 3a 02 c3			ld a, (.dmark+1)  
c2f6 32 b8 ee			ld (debug_mark+1),a  
c2f9 3a 03 c3			ld a, (.dmark+2)  
c2fc 32 b9 ee			ld (debug_mark+2),a  
c2ff 18 03			jr .pastdmark  
c301 ..			.dmark: db "CNT"  
c304 f1			.pastdmark: pop af  
c305			endm  
# End of macro DMARK
c305						CALLMONITOR 
c305 cd a3 94			call break_point_state  
c308				endm  
# End of macro CALLMONITOR
c308					endif 
c308			; TODO check string type 
c308					FORTH_DSP_VALUE 
c308 cd f4 9c			call macro_forth_dsp_value 
c30b				endm 
# End of macro FORTH_DSP_VALUE
c30b			 
c30b			 
c30b					if DEBUG_FORTH_WORDS 
c30b						DMARK "CN?" 
c30b f5				push af  
c30c 3a 20 c3			ld a, (.dmark)  
c30f 32 b7 ee			ld (debug_mark),a  
c312 3a 21 c3			ld a, (.dmark+1)  
c315 32 b8 ee			ld (debug_mark+1),a  
c318 3a 22 c3			ld a, (.dmark+2)  
c31b 32 b9 ee			ld (debug_mark+2),a  
c31e 18 03			jr .pastdmark  
c320 ..			.dmark: db "CN?"  
c323 f1			.pastdmark: pop af  
c324			endm  
# End of macro DMARK
c324						CALLMONITOR 
c324 cd a3 94			call break_point_state  
c327				endm  
# End of macro CALLMONITOR
c327					endif 
c327 cd 00 91				call strlenz 
c32a					if DEBUG_FORTH_WORDS 
c32a						DMARK "CNl" 
c32a f5				push af  
c32b 3a 3f c3			ld a, (.dmark)  
c32e 32 b7 ee			ld (debug_mark),a  
c331 3a 40 c3			ld a, (.dmark+1)  
c334 32 b8 ee			ld (debug_mark+1),a  
c337 3a 41 c3			ld a, (.dmark+2)  
c33a 32 b9 ee			ld (debug_mark+2),a  
c33d 18 03			jr .pastdmark  
c33f ..			.dmark: db "CNl"  
c342 f1			.pastdmark: pop af  
c343			endm  
# End of macro DMARK
c343						CALLMONITOR 
c343 cd a3 94			call break_point_state  
c346				endm  
# End of macro CALLMONITOR
c346					endif 
c346			 
c346 cd 14 9b				call forth_push_numhl 
c349			 
c349			 
c349			 
c349				       NEXTW 
c349 c3 82 9e			jp macro_next 
c34c				endm 
# End of macro NEXTW
c34c			.CHAR: 
c34c				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c34c 4d				db WORD_SYS_CORE+57             
c34d 82 c3			dw .ENDSTR            
c34f 05				db 4 + 1 
c350 .. 00			db "CHAR",0              
c355				endm 
# End of macro CWHEAD
c355			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c355					if DEBUG_FORTH_WORDS_KEY 
c355						DMARK "CHR" 
c355 f5				push af  
c356 3a 6a c3			ld a, (.dmark)  
c359 32 b7 ee			ld (debug_mark),a  
c35c 3a 6b c3			ld a, (.dmark+1)  
c35f 32 b8 ee			ld (debug_mark+1),a  
c362 3a 6c c3			ld a, (.dmark+2)  
c365 32 b9 ee			ld (debug_mark+2),a  
c368 18 03			jr .pastdmark  
c36a ..			.dmark: db "CHR"  
c36d f1			.pastdmark: pop af  
c36e			endm  
# End of macro DMARK
c36e						CALLMONITOR 
c36e cd a3 94			call break_point_state  
c371				endm  
# End of macro CALLMONITOR
c371					endif 
c371					FORTH_DSP 
c371 cd d1 9c			call macro_forth_dsp 
c374				endm 
# End of macro FORTH_DSP
c374					;v5 FORTH_DSP_VALUE 
c374 23					inc hl      ; now at start of numeric as string 
c375			 
c375			;		push hl 
c375			 
c375					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c375 cd c3 9d			call macro_forth_dsp_pop 
c378				endm 
# End of macro FORTH_DSP_POP
c378			 
c378			;		pop hl 
c378			 
c378					; push the content of a onto the stack as a value 
c378			 
c378 7e					ld a,(hl)   ; get char 
c379 26 00				ld h,0 
c37b 6f					ld l,a 
c37c cd 14 9b				call forth_push_numhl 
c37f			 
c37f				       NEXTW 
c37f c3 82 9e			jp macro_next 
c382				endm 
# End of macro NEXTW
c382			 
c382			 
c382			 
c382			 
c382			.ENDSTR: 
c382			; eof 
c382			 
# End of file forth_words_str.asm
c382			include "forth_words_key.asm" 
c382			 
c382			; | ## Keyboard Words 
c382			 
c382			.KEY: 
c382				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c382 3e				db WORD_SYS_CORE+42             
c383 b2 c3			dw .WAITK            
c385 04				db 3 + 1 
c386 .. 00			db "KEY",0              
c38a				endm 
# End of macro CWHEAD
c38a			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c38a			 
c38a					if DEBUG_FORTH_WORDS_KEY 
c38a						DMARK "KEY" 
c38a f5				push af  
c38b 3a 9f c3			ld a, (.dmark)  
c38e 32 b7 ee			ld (debug_mark),a  
c391 3a a0 c3			ld a, (.dmark+1)  
c394 32 b8 ee			ld (debug_mark+1),a  
c397 3a a1 c3			ld a, (.dmark+2)  
c39a 32 b9 ee			ld (debug_mark+2),a  
c39d 18 03			jr .pastdmark  
c39f ..			.dmark: db "KEY"  
c3a2 f1			.pastdmark: pop af  
c3a3			endm  
# End of macro DMARK
c3a3						CALLMONITOR 
c3a3 cd a3 94			call break_point_state  
c3a6				endm  
# End of macro CALLMONITOR
c3a6					endif 
c3a6			; TODO currently waits 
c3a6 cd 3f db				call cin 
c3a9					;call cin_wait 
c3a9 6f					ld l, a 
c3aa 26 00				ld h, 0 
c3ac cd 14 9b				call forth_push_numhl 
c3af					NEXTW 
c3af c3 82 9e			jp macro_next 
c3b2				endm 
# End of macro NEXTW
c3b2			.WAITK: 
c3b2				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c3b2 3f				db WORD_SYS_CORE+43             
c3b3 e4 c3			dw .ACCEPT            
c3b5 06				db 5 + 1 
c3b6 .. 00			db "WAITK",0              
c3bc				endm 
# End of macro CWHEAD
c3bc			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c3bc					if DEBUG_FORTH_WORDS_KEY 
c3bc						DMARK "WAI" 
c3bc f5				push af  
c3bd 3a d1 c3			ld a, (.dmark)  
c3c0 32 b7 ee			ld (debug_mark),a  
c3c3 3a d2 c3			ld a, (.dmark+1)  
c3c6 32 b8 ee			ld (debug_mark+1),a  
c3c9 3a d3 c3			ld a, (.dmark+2)  
c3cc 32 b9 ee			ld (debug_mark+2),a  
c3cf 18 03			jr .pastdmark  
c3d1 ..			.dmark: db "WAI"  
c3d4 f1			.pastdmark: pop af  
c3d5			endm  
# End of macro DMARK
c3d5						CALLMONITOR 
c3d5 cd a3 94			call break_point_state  
c3d8				endm  
# End of macro CALLMONITOR
c3d8					endif 
c3d8 cd 39 db				call cin_wait 
c3db 6f					ld l, a 
c3dc 26 00				ld h, 0 
c3de cd 14 9b				call forth_push_numhl 
c3e1					NEXTW 
c3e1 c3 82 9e			jp macro_next 
c3e4				endm 
# End of macro NEXTW
c3e4			.ACCEPT: 
c3e4				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c3e4 40				db WORD_SYS_CORE+44             
c3e5 42 c4			dw .EDIT            
c3e7 07				db 6 + 1 
c3e8 .. 00			db "ACCEPT",0              
c3ef				endm 
# End of macro CWHEAD
c3ef			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c3ef					; TODO crashes on push 
c3ef					if DEBUG_FORTH_WORDS_KEY 
c3ef						DMARK "ACC" 
c3ef f5				push af  
c3f0 3a 04 c4			ld a, (.dmark)  
c3f3 32 b7 ee			ld (debug_mark),a  
c3f6 3a 05 c4			ld a, (.dmark+1)  
c3f9 32 b8 ee			ld (debug_mark+1),a  
c3fc 3a 06 c4			ld a, (.dmark+2)  
c3ff 32 b9 ee			ld (debug_mark+2),a  
c402 18 03			jr .pastdmark  
c404 ..			.dmark: db "ACC"  
c407 f1			.pastdmark: pop af  
c408			endm  
# End of macro DMARK
c408						CALLMONITOR 
c408 cd a3 94			call break_point_state  
c40b				endm  
# End of macro CALLMONITOR
c40b					endif 
c40b 21 83 e6				ld hl, os_input 
c40e 3e 00				ld a, 0 
c410 77					ld (hl),a 
c411 3a ee eb				ld a,(f_cursor_ptr) 
c414 16 64				ld d, 100 
c416 0e 00				ld c, 0 
c418 1e 28				ld e, 40 
c41a cd cf 8c				call input_str 
c41d					; TODO perhaps do a type check and wrap in quotes if not a number 
c41d 21 83 e6				ld hl, os_input 
c420					if DEBUG_FORTH_WORDS 
c420						DMARK "AC1" 
c420 f5				push af  
c421 3a 35 c4			ld a, (.dmark)  
c424 32 b7 ee			ld (debug_mark),a  
c427 3a 36 c4			ld a, (.dmark+1)  
c42a 32 b8 ee			ld (debug_mark+1),a  
c42d 3a 37 c4			ld a, (.dmark+2)  
c430 32 b9 ee			ld (debug_mark+2),a  
c433 18 03			jr .pastdmark  
c435 ..			.dmark: db "AC1"  
c438 f1			.pastdmark: pop af  
c439			endm  
# End of macro DMARK
c439						CALLMONITOR 
c439 cd a3 94			call break_point_state  
c43c				endm  
# End of macro CALLMONITOR
c43c					endif 
c43c cd 82 9b				call forth_push_str 
c43f					NEXTW 
c43f c3 82 9e			jp macro_next 
c442				endm 
# End of macro NEXTW
c442			 
c442			.EDIT: 
c442				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c442 40				db WORD_SYS_CORE+44             
c443 e4 c4			dw .ENDKEY            
c445 05				db 4 + 1 
c446 .. 00			db "EDIT",0              
c44b				endm 
# End of macro CWHEAD
c44b			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c44b			 
c44b					; TODO does not copy from stack 
c44b					if DEBUG_FORTH_WORDS_KEY 
c44b						DMARK "EDT" 
c44b f5				push af  
c44c 3a 60 c4			ld a, (.dmark)  
c44f 32 b7 ee			ld (debug_mark),a  
c452 3a 61 c4			ld a, (.dmark+1)  
c455 32 b8 ee			ld (debug_mark+1),a  
c458 3a 62 c4			ld a, (.dmark+2)  
c45b 32 b9 ee			ld (debug_mark+2),a  
c45e 18 03			jr .pastdmark  
c460 ..			.dmark: db "EDT"  
c463 f1			.pastdmark: pop af  
c464			endm  
# End of macro DMARK
c464						CALLMONITOR 
c464 cd a3 94			call break_point_state  
c467				endm  
# End of macro CALLMONITOR
c467					endif 
c467			 
c467					;FORTH_DSP 
c467					FORTH_DSP_VALUEHL 
c467 cd 0b 9d			call macro_dsp_valuehl 
c46a				endm 
# End of macro FORTH_DSP_VALUEHL
c46a			;		inc hl    ; TODO do type check 
c46a			 
c46a			;		call get_word_hl 
c46a e5					push hl 
c46b					if DEBUG_FORTH_WORDS 
c46b						DMARK "EDp" 
c46b f5				push af  
c46c 3a 80 c4			ld a, (.dmark)  
c46f 32 b7 ee			ld (debug_mark),a  
c472 3a 81 c4			ld a, (.dmark+1)  
c475 32 b8 ee			ld (debug_mark+1),a  
c478 3a 82 c4			ld a, (.dmark+2)  
c47b 32 b9 ee			ld (debug_mark+2),a  
c47e 18 03			jr .pastdmark  
c480 ..			.dmark: db "EDp"  
c483 f1			.pastdmark: pop af  
c484			endm  
# End of macro DMARK
c484						CALLMONITOR 
c484 cd a3 94			call break_point_state  
c487				endm  
# End of macro CALLMONITOR
c487					endif 
c487				;	ld a, 0 
c487 cd 00 91				call strlenz 
c48a 23					inc hl 
c48b			 
c48b 06 00				ld b, 0 
c48d 4d					ld c, l 
c48e			 
c48e e1					pop hl 
c48f 11 83 e6				ld de, os_input 
c492					if DEBUG_FORTH_WORDS_KEY 
c492						DMARK "EDc" 
c492 f5				push af  
c493 3a a7 c4			ld a, (.dmark)  
c496 32 b7 ee			ld (debug_mark),a  
c499 3a a8 c4			ld a, (.dmark+1)  
c49c 32 b8 ee			ld (debug_mark+1),a  
c49f 3a a9 c4			ld a, (.dmark+2)  
c4a2 32 b9 ee			ld (debug_mark+2),a  
c4a5 18 03			jr .pastdmark  
c4a7 ..			.dmark: db "EDc"  
c4aa f1			.pastdmark: pop af  
c4ab			endm  
# End of macro DMARK
c4ab						CALLMONITOR 
c4ab cd a3 94			call break_point_state  
c4ae				endm  
# End of macro CALLMONITOR
c4ae					endif 
c4ae ed b0				ldir 
c4b0			 
c4b0			 
c4b0 21 83 e6				ld hl, os_input 
c4b3					;ld a, 0 
c4b3					;ld (hl),a 
c4b3 3a ee eb				ld a,(f_cursor_ptr) 
c4b6 16 64				ld d, 100 
c4b8 0e 00				ld c, 0 
c4ba 1e 28				ld e, 40 
c4bc cd cf 8c				call input_str 
c4bf					; TODO perhaps do a type check and wrap in quotes if not a number 
c4bf 21 83 e6				ld hl, os_input 
c4c2					if DEBUG_FORTH_WORDS 
c4c2						DMARK "ED1" 
c4c2 f5				push af  
c4c3 3a d7 c4			ld a, (.dmark)  
c4c6 32 b7 ee			ld (debug_mark),a  
c4c9 3a d8 c4			ld a, (.dmark+1)  
c4cc 32 b8 ee			ld (debug_mark+1),a  
c4cf 3a d9 c4			ld a, (.dmark+2)  
c4d2 32 b9 ee			ld (debug_mark+2),a  
c4d5 18 03			jr .pastdmark  
c4d7 ..			.dmark: db "ED1"  
c4da f1			.pastdmark: pop af  
c4db			endm  
# End of macro DMARK
c4db						CALLMONITOR 
c4db cd a3 94			call break_point_state  
c4de				endm  
# End of macro CALLMONITOR
c4de					endif 
c4de cd 82 9b				call forth_push_str 
c4e1					NEXTW 
c4e1 c3 82 9e			jp macro_next 
c4e4				endm 
# End of macro NEXTW
c4e4			 
c4e4			 
c4e4			 
c4e4			.ENDKEY: 
c4e4			; eof 
c4e4			 
# End of file forth_words_key.asm
c4e4			 
c4e4			if STORAGE_SE 
c4e4			   	include "forth_words_storage.asm" 
c4e4			endif 
c4e4				include "forth_words_device.asm" 
c4e4			; Device related words 
c4e4			 
c4e4			; | ## Device Words 
c4e4			 
c4e4			if SOUND_ENABLE 
c4e4			.NOTE: 
c4e4				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c4e4			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c4e4					if DEBUG_FORTH_WORDS_KEY 
c4e4						DMARK "NTE" 
c4e4						CALLMONITOR 
c4e4					endif 
c4e4			 
c4e4				 
c4e4			 
c4e4					NEXTW 
c4e4			.AFTERSOUND: 
c4e4			endif 
c4e4			 
c4e4			 
c4e4			USE_GPIO: equ 0 
c4e4			 
c4e4			if USE_GPIO 
c4e4			.GP1: 
c4e4				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c4e4			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c4e4					NEXTW 
c4e4			.GP2: 
c4e4				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c4e4			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c4e4			 
c4e4					NEXTW 
c4e4			 
c4e4			.GP3: 
c4e4				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c4e4			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c4e4			 
c4e4					NEXTW 
c4e4			 
c4e4			.GP4: 
c4e4				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c4e4			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c4e4			 
c4e4					NEXTW 
c4e4			.SIN: 
c4e4			 
c4e4			 
c4e4			endif 
c4e4			 
c4e4			 
c4e4				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c4e4 33				db WORD_SYS_CORE+31             
c4e5 19 c5			dw .SOUT            
c4e7 03				db 2 + 1 
c4e8 .. 00			db "IN",0              
c4eb				endm 
# End of macro CWHEAD
c4eb			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c4eb					if DEBUG_FORTH_WORDS_KEY 
c4eb						DMARK "IN." 
c4eb f5				push af  
c4ec 3a 00 c5			ld a, (.dmark)  
c4ef 32 b7 ee			ld (debug_mark),a  
c4f2 3a 01 c5			ld a, (.dmark+1)  
c4f5 32 b8 ee			ld (debug_mark+1),a  
c4f8 3a 02 c5			ld a, (.dmark+2)  
c4fb 32 b9 ee			ld (debug_mark+2),a  
c4fe 18 03			jr .pastdmark  
c500 ..			.dmark: db "IN."  
c503 f1			.pastdmark: pop af  
c504			endm  
# End of macro DMARK
c504						CALLMONITOR 
c504 cd a3 94			call break_point_state  
c507				endm  
# End of macro CALLMONITOR
c507					endif 
c507					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c507 cd 0b 9d			call macro_dsp_valuehl 
c50a				endm 
# End of macro FORTH_DSP_VALUEHL
c50a			 
c50a e5					push hl 
c50b			 
c50b					; destroy value TOS 
c50b			 
c50b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c50b cd c3 9d			call macro_forth_dsp_pop 
c50e				endm 
# End of macro FORTH_DSP_POP
c50e			 
c50e					; one value on hl get other one back 
c50e			 
c50e c1					pop bc 
c50f			 
c50f					; do the sub 
c50f			;		ex de, hl 
c50f			 
c50f ed 68				in l,(c) 
c511			 
c511					; save it 
c511			 
c511 26 00				ld h,0 
c513			 
c513					; TODO push value back onto stack for another op etc 
c513			 
c513 cd 14 9b				call forth_push_numhl 
c516					NEXTW 
c516 c3 82 9e			jp macro_next 
c519				endm 
# End of macro NEXTW
c519			.SOUT: 
c519				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c519 34				db WORD_SYS_CORE+32             
c51a 6c c5			dw .SPIO            
c51c 04				db 3 + 1 
c51d .. 00			db "OUT",0              
c521				endm 
# End of macro CWHEAD
c521			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c521					if DEBUG_FORTH_WORDS_KEY 
c521						DMARK "OUT" 
c521 f5				push af  
c522 3a 36 c5			ld a, (.dmark)  
c525 32 b7 ee			ld (debug_mark),a  
c528 3a 37 c5			ld a, (.dmark+1)  
c52b 32 b8 ee			ld (debug_mark+1),a  
c52e 3a 38 c5			ld a, (.dmark+2)  
c531 32 b9 ee			ld (debug_mark+2),a  
c534 18 03			jr .pastdmark  
c536 ..			.dmark: db "OUT"  
c539 f1			.pastdmark: pop af  
c53a			endm  
# End of macro DMARK
c53a						CALLMONITOR 
c53a cd a3 94			call break_point_state  
c53d				endm  
# End of macro CALLMONITOR
c53d					endif 
c53d			 
c53d					; get port 
c53d			 
c53d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c53d cd 0b 9d			call macro_dsp_valuehl 
c540				endm 
# End of macro FORTH_DSP_VALUEHL
c540			 
c540 e5					push hl 
c541			 
c541					; destroy value TOS 
c541			 
c541					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c541 cd c3 9d			call macro_forth_dsp_pop 
c544				endm 
# End of macro FORTH_DSP_POP
c544			 
c544					; get byte to send 
c544			 
c544					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c544 cd 0b 9d			call macro_dsp_valuehl 
c547				endm 
# End of macro FORTH_DSP_VALUEHL
c547			 
c547			;		push hl 
c547			 
c547					; destroy value TOS 
c547			 
c547					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c547 cd c3 9d			call macro_forth_dsp_pop 
c54a				endm 
# End of macro FORTH_DSP_POP
c54a			 
c54a					; one value on hl get other one back 
c54a			 
c54a			;		pop hl 
c54a			 
c54a c1					pop bc 
c54b			 
c54b					if DEBUG_FORTH_WORDS 
c54b						DMARK "OUT" 
c54b f5				push af  
c54c 3a 60 c5			ld a, (.dmark)  
c54f 32 b7 ee			ld (debug_mark),a  
c552 3a 61 c5			ld a, (.dmark+1)  
c555 32 b8 ee			ld (debug_mark+1),a  
c558 3a 62 c5			ld a, (.dmark+2)  
c55b 32 b9 ee			ld (debug_mark+2),a  
c55e 18 03			jr .pastdmark  
c560 ..			.dmark: db "OUT"  
c563 f1			.pastdmark: pop af  
c564			endm  
# End of macro DMARK
c564						CALLMONITOR 
c564 cd a3 94			call break_point_state  
c567				endm  
# End of macro CALLMONITOR
c567					endif 
c567			 
c567 ed 69				out (c), l 
c569			 
c569					NEXTW 
c569 c3 82 9e			jp macro_next 
c56c				endm 
# End of macro NEXTW
c56c			 
c56c			 
c56c			.SPIO: 
c56c			 
c56c			if STORAGE_SE 
c56c				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c56c			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c56c			 
c56c					call spi_ce_low 
c56c			    NEXTW 
c56c			 
c56c			.SPICEH: 
c56c				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c56c			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c56c			 
c56c					call spi_ce_high 
c56c			    NEXTW 
c56c			 
c56c			 
c56c			.SPIOb: 
c56c			 
c56c				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c56c			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c56c			 
c56c					if DEBUG_FORTH_WORDS_KEY 
c56c						DMARK "SPo" 
c56c						CALLMONITOR 
c56c					endif 
c56c					; get port 
c56c			 
c56c			 
c56c					; get byte to send 
c56c			 
c56c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c56c			 
c56c			;		push hl    ; u1  
c56c			 
c56c					; destroy value TOS 
c56c			 
c56c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c56c			 
c56c					; one value on hl get other one back 
c56c			 
c56c			;		pop hl   ; u2 - addr 
c56c			 
c56c					; TODO Send SPI byte 
c56c			 
c56c			;		push hl 
c56c			;		call spi_ce_low 
c56c			;		pop hl 
c56c					ld a, l 
c56c					call spi_send_byte 
c56c			;		call spi_ce_high 
c56c			 
c56c					NEXTW 
c56c			 
c56c			.SPII: 
c56c				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c56c			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c56c					if DEBUG_FORTH_WORDS_KEY 
c56c						DMARK "SPi" 
c56c						CALLMONITOR 
c56c					endif 
c56c			 
c56c					; TODO Get SPI byte 
c56c			 
c56c					call spi_read_byte 
c56c			 
c56c					if DEBUG_FORTH_WORDS 
c56c						DMARK "Si2" 
c56c						CALLMONITOR 
c56c					endif 
c56c					ld h, 0 
c56c					ld l, a 
c56c					if DEBUG_FORTH_WORDS 
c56c						DMARK "Si3" 
c56c						CALLMONITOR 
c56c					endif 
c56c					call forth_push_numhl 
c56c			 
c56c					NEXTW 
c56c			 
c56c			 
c56c			 
c56c			.SESEL: 
c56c				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c56c			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c56c					if DEBUG_FORTH_WORDS_KEY 
c56c						DMARK "BNK" 
c56c						CALLMONITOR 
c56c					endif 
c56c			 
c56c					ld a, 255 
c56c					ld (spi_cartdev), a 
c56c			 
c56c					; get bank 
c56c			 
c56c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c56c			 
c56c			;		push hl 
c56c			 
c56c					; destroy value TOS 
c56c			 
c56c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c56c			 
c56c					; one value on hl get other one back 
c56c			 
c56c			;		pop hl 
c56c			 
c56c			 
c56c					ld c, SPI_CE_HIGH 
c56c					ld b, '0'    ; human readable bank number 
c56c			 
c56c					ld a, l 
c56c			 
c56c					if DEBUG_FORTH_WORDS 
c56c						DMARK "BNK" 
c56c						CALLMONITOR 
c56c					endif 
c56c			 
c56c					; active low 
c56c			 
c56c					cp 0 
c56c					jr z, .bset 
c56c					cp 1 
c56c					jr nz, .b2 
c56c					res 0, c 
c56c					ld b, '1'    ; human readable bank number 
c56c			.b2:		cp 2 
c56c					jr nz, .b3 
c56c					res 1, c 
c56c					ld b, '2'    ; human readable bank number 
c56c			.b3:		cp 3 
c56c					jr nz, .b4 
c56c					res 2, c 
c56c					ld b, '3'    ; human readable bank number 
c56c			.b4:		cp 4 
c56c					jr nz, .b5 
c56c					res 3, c 
c56c					ld b, '4'    ; human readable bank number 
c56c			.b5:		cp 5 
c56c					jr nz, .bset 
c56c					res 4, c 
c56c					ld b, '5'    ; human readable bank number 
c56c			 
c56c			.bset: 
c56c					ld a, c 
c56c					ld (spi_device),a 
c56c					ld a, b 
c56c					ld (spi_device_id),a 
c56c					if DEBUG_FORTH_WORDS 
c56c						DMARK "BN2" 
c56c						CALLMONITOR 
c56c					endif 
c56c			 
c56c					; set default SPI clk pulse time as disabled for BANK use 
c56c			 
c56c					ld a, 0 
c56c					ld (spi_clktime), a 
c56c			 
c56c					NEXTW 
c56c			 
c56c			.CARTDEV: 
c56c				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c56c			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c56c					if DEBUG_FORTH_WORDS_KEY 
c56c						DMARK "CDV" 
c56c						CALLMONITOR 
c56c					endif 
c56c			 
c56c					; disable se storage bank selection 
c56c			 
c56c					ld a, SPI_CE_HIGH		; ce high 
c56c					ld (spi_device), a 
c56c			 
c56c					; get bank 
c56c			 
c56c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c56c			 
c56c			;		push hl 
c56c			 
c56c					; destroy value TOS 
c56c			 
c56c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c56c			 
c56c					; one value on hl get other one back 
c56c			 
c56c			;		pop hl 
c56c			 
c56c					; active low 
c56c			 
c56c					ld c, 255 
c56c			 
c56c					ld a, l 
c56c					if DEBUG_FORTH_WORDS 
c56c						DMARK "CDV" 
c56c						CALLMONITOR 
c56c					endif 
c56c					cp 0 
c56c					jr z, .cset 
c56c					cp 1 
c56c					jr nz, .c2 
c56c					res 0, c 
c56c			.c2:		cp 2 
c56c					jr nz, .c3 
c56c					res 1, c 
c56c			.c3:		cp 3 
c56c					jr nz, .c4 
c56c					res 2, c 
c56c			.c4:		cp 4 
c56c					jr nz, .c5 
c56c					res 3, c 
c56c			.c5:		cp 5 
c56c					jr nz, .c6 
c56c					res 4, c 
c56c			.c6:		cp 6 
c56c					jr nz, .c7 
c56c					res 5, c 
c56c			.c7:		cp 7 
c56c					jr nz, .c8 
c56c					res 6, c 
c56c			.c8:		cp 8 
c56c					jr nz, .cset 
c56c					res 7, c 
c56c			.cset:		ld a, c 
c56c					ld (spi_cartdev),a 
c56c			 
c56c					if DEBUG_FORTH_WORDS 
c56c						DMARK "CD2" 
c56c						CALLMONITOR 
c56c					endif 
c56c			 
c56c					; set default SPI clk pulse time as 10ms for CARTDEV use 
c56c			 
c56c					ld a, $0a 
c56c					ld (spi_clktime), a 
c56c					NEXTW 
c56c			endif 
c56c			 
c56c			.ENDDEVICE: 
c56c			; eof 
c56c			 
# End of file forth_words_device.asm
c56c			 
c56c			; var handler 
c56c			 
c56c			 
c56c			.VARS: 
c56c				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c56c 78				db WORD_SYS_CORE+100             
c56d 84 c5			dw .V0Q            
c56f 04				db 3 + 1 
c570 .. 00			db "V0!",0              
c574				endm 
# End of macro CWHEAD
c574			;| V0! ( u1 -- )  Store value to v0  | DONE 
c574			 
c574					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c574 cd 0b 9d			call macro_dsp_valuehl 
c577				endm 
# End of macro FORTH_DSP_VALUEHL
c577			 
c577 11 b8 eb				ld de, cli_var_array 
c57a			 
c57a eb					ex de, hl 
c57b 73					ld (hl), e 
c57c 23					inc hl 
c57d 72					ld (hl), d 
c57e			 
c57e					; destroy value TOS 
c57e			 
c57e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c57e cd c3 9d			call macro_forth_dsp_pop 
c581				endm 
# End of macro FORTH_DSP_POP
c581			 
c581				       NEXTW 
c581 c3 82 9e			jp macro_next 
c584				endm 
# End of macro NEXTW
c584			.V0Q: 
c584				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c584 79				db WORD_SYS_CORE+101             
c585 95 c5			dw .V1S            
c587 04				db 3 + 1 
c588 .. 00			db "V0@",0              
c58c				endm 
# End of macro CWHEAD
c58c			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c58c 2a b8 eb				ld hl, (cli_var_array) 
c58f cd 14 9b				call forth_push_numhl 
c592			 
c592				       NEXTW 
c592 c3 82 9e			jp macro_next 
c595				endm 
# End of macro NEXTW
c595			.V1S: 
c595				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c595 7a				db WORD_SYS_CORE+102             
c596 ad c5			dw .V1Q            
c598 04				db 3 + 1 
c599 .. 00			db "V1!",0              
c59d				endm 
# End of macro CWHEAD
c59d			;| V1! ( u1 -- )  Store value to v1 | DONE 
c59d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c59d cd 0b 9d			call macro_dsp_valuehl 
c5a0				endm 
# End of macro FORTH_DSP_VALUEHL
c5a0			 
c5a0 11 ba eb				ld de, cli_var_array+2 
c5a3				 
c5a3 eb					ex de, hl 
c5a4 73					ld (hl), e 
c5a5 23					inc hl 
c5a6 72					ld (hl), d 
c5a7			 
c5a7					; destroy value TOS 
c5a7			 
c5a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5a7 cd c3 9d			call macro_forth_dsp_pop 
c5aa				endm 
# End of macro FORTH_DSP_POP
c5aa				       NEXTW 
c5aa c3 82 9e			jp macro_next 
c5ad				endm 
# End of macro NEXTW
c5ad			.V1Q: 
c5ad				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c5ad 7b				db WORD_SYS_CORE+103             
c5ae be c5			dw .V2S            
c5b0 04				db 3 + 1 
c5b1 .. 00			db "V1@",0              
c5b5				endm 
# End of macro CWHEAD
c5b5			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c5b5 2a ba eb				ld hl, (cli_var_array+2) 
c5b8 cd 14 9b				call forth_push_numhl 
c5bb				       NEXTW 
c5bb c3 82 9e			jp macro_next 
c5be				endm 
# End of macro NEXTW
c5be			.V2S: 
c5be				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c5be 7c				db WORD_SYS_CORE+104             
c5bf d6 c5			dw .V2Q            
c5c1 04				db 3 + 1 
c5c2 .. 00			db "V2!",0              
c5c6				endm 
# End of macro CWHEAD
c5c6			;| V2! ( u1 -- )  Store value to v2 | DONE 
c5c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c5c6 cd 0b 9d			call macro_dsp_valuehl 
c5c9				endm 
# End of macro FORTH_DSP_VALUEHL
c5c9			 
c5c9 11 bc eb				ld de, cli_var_array+4 
c5cc				 
c5cc eb					ex de, hl 
c5cd 73					ld (hl), e 
c5ce 23					inc hl 
c5cf 72					ld (hl), d 
c5d0			 
c5d0					; destroy value TOS 
c5d0			 
c5d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5d0 cd c3 9d			call macro_forth_dsp_pop 
c5d3				endm 
# End of macro FORTH_DSP_POP
c5d3				       NEXTW 
c5d3 c3 82 9e			jp macro_next 
c5d6				endm 
# End of macro NEXTW
c5d6			.V2Q: 
c5d6				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c5d6 7d				db WORD_SYS_CORE+105             
c5d7 e7 c5			dw .V3S            
c5d9 04				db 3 + 1 
c5da .. 00			db "V2@",0              
c5de				endm 
# End of macro CWHEAD
c5de			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c5de 2a bc eb				ld hl, (cli_var_array+4) 
c5e1 cd 14 9b				call forth_push_numhl 
c5e4				       NEXTW 
c5e4 c3 82 9e			jp macro_next 
c5e7				endm 
# End of macro NEXTW
c5e7			.V3S: 
c5e7				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c5e7 7c				db WORD_SYS_CORE+104             
c5e8 ff c5			dw .V3Q            
c5ea 04				db 3 + 1 
c5eb .. 00			db "V3!",0              
c5ef				endm 
# End of macro CWHEAD
c5ef			;| V3! ( u1 -- )  Store value to v3 | DONE 
c5ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c5ef cd 0b 9d			call macro_dsp_valuehl 
c5f2				endm 
# End of macro FORTH_DSP_VALUEHL
c5f2			 
c5f2 11 be eb				ld de, cli_var_array+6 
c5f5				 
c5f5 eb					ex de, hl 
c5f6 73					ld (hl), e 
c5f7 23					inc hl 
c5f8 72					ld (hl), d 
c5f9			 
c5f9					; destroy value TOS 
c5f9			 
c5f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5f9 cd c3 9d			call macro_forth_dsp_pop 
c5fc				endm 
# End of macro FORTH_DSP_POP
c5fc				       NEXTW 
c5fc c3 82 9e			jp macro_next 
c5ff				endm 
# End of macro NEXTW
c5ff			.V3Q: 
c5ff				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c5ff 7d				db WORD_SYS_CORE+105             
c600 10 c6			dw .END            
c602 04				db 3 + 1 
c603 .. 00			db "V3@",0              
c607				endm 
# End of macro CWHEAD
c607			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c607 2a be eb				ld hl, (cli_var_array+6) 
c60a cd 14 9b				call forth_push_numhl 
c60d				       NEXTW 
c60d c3 82 9e			jp macro_next 
c610				endm 
# End of macro NEXTW
c610			 
c610			 
c610			 
c610			 
c610			 
c610			; end of dict marker 
c610			 
c610 00			.END:    db WORD_SYS_END 
c611 00 00			dw 0 
c613 00				db 0 
c614			 
c614			; use to jp here for user dict words to save on macro expansion  
c614			 
c614			user_dict_next: 
c614				NEXTW 
c614 c3 82 9e			jp macro_next 
c617				endm 
# End of macro NEXTW
c617			 
c617			 
c617			user_exec: 
c617				;    ld hl, <word code> 
c617				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c617				;    call forthexec 
c617				;    jp user_dict_next   (NEXT) 
c617			        ;    <word code bytes> 
c617 eb				ex de, hl 
c618 2a 86 e7			ld hl,(os_tok_ptr) 
c61b				 
c61b				FORTH_RSP_NEXT 
c61b cd bb 9a			call macro_forth_rsp_next 
c61e				endm 
# End of macro FORTH_RSP_NEXT
c61e			 
c61e			if DEBUG_FORTH_UWORD 
c61e						DMARK "UEX" 
c61e f5				push af  
c61f 3a 33 c6			ld a, (.dmark)  
c622 32 b7 ee			ld (debug_mark),a  
c625 3a 34 c6			ld a, (.dmark+1)  
c628 32 b8 ee			ld (debug_mark+1),a  
c62b 3a 35 c6			ld a, (.dmark+2)  
c62e 32 b9 ee			ld (debug_mark+2),a  
c631 18 03			jr .pastdmark  
c633 ..			.dmark: db "UEX"  
c636 f1			.pastdmark: pop af  
c637			endm  
# End of macro DMARK
c637				CALLMONITOR 
c637 cd a3 94			call break_point_state  
c63a				endm  
# End of macro CALLMONITOR
c63a			endif 
c63a			 
c63a			 
c63a			 
c63a eb				ex de, hl 
c63b 22 86 e7			ld (os_tok_ptr), hl 
c63e				 
c63e				; Don't use next - Skips the first word in uword. 
c63e			 
c63e c3 13 9f			jp exec1 
c641			;	NEXT 
c641			 
c641			 
c641			; eof 
# End of file forth_wordsv4.asm
c641			endif 
c641			;;;;;;;;;;;;;; Debug code 
c641			 
c641			 
c641			;if DEBUG_FORTH_PARSE 
c641 .. 00		.nowordfound: db "No match",0 
c64a .. 00		.compword:	db "Comparing word ",0 
c65a .. 00		.nextwordat:	db "Next word at",0 
c667 .. 00		.charmatch:	db "Char match",0 
c672			;endif 
c672			if DEBUG_FORTH_JP 
c672			.foundword:	db "Word match. Exec..",0 
c672			endif 
c672			;if DEBUG_FORTH_PUSH 
c672 .. 00		.enddict:	db "Dict end. Push.",0 
c682 .. 00		.push_str:	db "Pushing string",0 
c691 .. 00		.push_num:	db "Pushing number",0 
c6a0 .. 00		.data_sp:	db "SP:",0 
c6a4 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c6b6 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c6c8 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c6da			;endif 
c6da			;if DEBUG_FORTH_MALLOC 
c6da .. 00		.push_malloc:	db "Malloc address",0 
c6e9			;endif 
c6e9			 
c6e9			 
c6e9			 
c6e9			; display malloc address and current data stack pointer  
c6e9			 
c6e9			malloc_error: 
c6e9 d5				push de 
c6ea f5				push af 
c6eb e5				push hl 
c6ec cd 75 8a			call clear_display 
c6ef 11 11 c7			ld de, .mallocerr 
c6f2 3e 00			ld a,0 
c6f4			;	ld de,os_word_scratch 
c6f4 cd 88 8a			call str_at_display 
c6f7 3e 11			ld a, display_row_1+17 
c6f9 11 b7 ee			ld de, debug_mark 
c6fc cd 88 8a			call str_at_display 
c6ff cd 98 8a			call update_display 
c702				;call break_point_state 
c702 cd 39 db			call cin_wait 
c705			 
c705 3e 20			ld a, ' ' 
c707 32 76 e4			ld (os_view_disable), a 
c70a e1				pop hl 
c70b f1				pop af 
c70c d1				pop de	 
c70d				CALLMONITOR 
c70d cd a3 94			call break_point_state  
c710				endm  
# End of macro CALLMONITOR
c710 c9				ret 
c711			 
c711 .. 00		.mallocerr: 	db "Malloc Error",0 
c71e			;if DEBUG_FORTH_PUSH 
c71e			display_data_sp: 
c71e f5				push af 
c71f			 
c71f				; see if disabled 
c71f			 
c71f 3a 76 e4			ld a, (os_view_disable) 
c722 fe 2a			cp '*' 
c724 28 67			jr z, .skipdsp 
c726			 
c726 e5				push hl 
c727 e5				push hl 
c728 e5			push hl 
c729 cd 75 8a			call clear_display 
c72c e1			pop hl 
c72d 7c				ld a,h 
c72e 21 8a e7			ld hl, os_word_scratch 
c731 cd a3 8f			call hexout 
c734 e1				pop hl 
c735 7d				ld a,l 
c736 21 8c e7			ld hl, os_word_scratch+2 
c739 cd a3 8f			call hexout 
c73c 21 8e e7			ld hl, os_word_scratch+4 
c73f 3e 00			ld a,0 
c741 77				ld (hl),a 
c742 11 8a e7			ld de,os_word_scratch 
c745 3e 14				ld a, display_row_2 
c747 cd 88 8a				call str_at_display 
c74a 11 a4 c6			ld de, .wordinhl 
c74d 3e 00			ld a, display_row_1 
c74f			 
c74f cd 88 8a				call str_at_display 
c752 11 b7 ee			ld de, debug_mark 
c755 3e 11			ld a, display_row_1+17 
c757			 
c757 cd 88 8a				call str_at_display 
c75a			 
c75a				; display current data stack pointer 
c75a 11 a0 c6			ld de,.data_sp 
c75d 3e 1c				ld a, display_row_2 + 8 
c75f cd 88 8a				call str_at_display 
c762			 
c762 2a b2 eb			ld hl,(cli_data_sp) 
c765 e5				push hl 
c766 7c				ld a,h 
c767 21 8a e7			ld hl, os_word_scratch 
c76a cd a3 8f			call hexout 
c76d e1				pop hl 
c76e 7d				ld a,l 
c76f 21 8c e7			ld hl, os_word_scratch+2 
c772 cd a3 8f			call hexout 
c775 21 8e e7			ld hl, os_word_scratch+4 
c778 3e 00			ld a,0 
c77a 77				ld (hl),a 
c77b 11 8a e7			ld de,os_word_scratch 
c77e 3e 1f				ld a, display_row_2 + 11 
c780 cd 88 8a				call str_at_display 
c783			 
c783			 
c783 cd 98 8a			call update_display 
c786 cd f2 89			call delay1s 
c789 cd f2 89			call delay1s 
c78c e1				pop hl 
c78d			.skipdsp: 
c78d f1				pop af 
c78e c9				ret 
c78f			 
c78f			display_data_malloc: 
c78f			 
c78f f5				push af 
c790 e5				push hl 
c791 e5				push hl 
c792 e5			push hl 
c793 cd 75 8a			call clear_display 
c796 e1			pop hl 
c797 7c				ld a,h 
c798 21 8a e7			ld hl, os_word_scratch 
c79b cd a3 8f			call hexout 
c79e e1				pop hl 
c79f 7d				ld a,l 
c7a0 21 8c e7			ld hl, os_word_scratch+2 
c7a3 cd a3 8f			call hexout 
c7a6 21 8e e7			ld hl, os_word_scratch+4 
c7a9 3e 00			ld a,0 
c7ab 77				ld (hl),a 
c7ac 11 8a e7			ld de,os_word_scratch 
c7af 3e 14				ld a, display_row_2 
c7b1 cd 88 8a				call str_at_display 
c7b4 11 da c6			ld de, .push_malloc 
c7b7 3e 00			ld a, display_row_1 
c7b9			 
c7b9 cd 88 8a				call str_at_display 
c7bc			 
c7bc				; display current data stack pointer 
c7bc 11 a0 c6			ld de,.data_sp 
c7bf 3e 1c				ld a, display_row_2 + 8 
c7c1 cd 88 8a				call str_at_display 
c7c4			 
c7c4 2a b2 eb			ld hl,(cli_data_sp) 
c7c7 e5				push hl 
c7c8 7c				ld a,h 
c7c9 21 8a e7			ld hl, os_word_scratch 
c7cc cd a3 8f			call hexout 
c7cf e1				pop hl 
c7d0 7d				ld a,l 
c7d1 21 8c e7			ld hl, os_word_scratch+2 
c7d4 cd a3 8f			call hexout 
c7d7 21 8e e7			ld hl, os_word_scratch+4 
c7da 3e 00			ld a,0 
c7dc 77				ld (hl),a 
c7dd 11 8a e7			ld de,os_word_scratch 
c7e0 3e 1f				ld a, display_row_2 + 11 
c7e2 cd 88 8a				call str_at_display 
c7e5			 
c7e5 cd 98 8a			call update_display 
c7e8 cd f2 89			call delay1s 
c7eb cd f2 89			call delay1s 
c7ee e1				pop hl 
c7ef f1				pop af 
c7f0 c9				ret 
c7f1			;endif 
c7f1			 
c7f1			include "forth_autostart.asm" 
c7f1			; list of commands to perform at system start up 
c7f1			 
c7f1			startcmds: 
c7f1			;	dw test11 
c7f1			;	dw test12 
c7f1			;	dw test13 
c7f1			;	dw test14 
c7f1			;	dw test15 
c7f1			;	dw test16 
c7f1			;	dw test17 
c7f1			;	dw ifthtest1 
c7f1			;	dw ifthtest2 
c7f1			;	dw ifthtest3 
c7f1			;	dw mmtest1 
c7f1			;	dw mmtest2 
c7f1			;	dw mmtest3 
c7f1			;	dw mmtest4 
c7f1			;	dw mmtest5 
c7f1			;	dw mmtest6 
c7f1			;	dw iftest1 
c7f1			;	dw iftest2 
c7f1			;	dw iftest3 
c7f1			;	dw looptest1 
c7f1			;	dw looptest2 
c7f1			;	dw test1 
c7f1			;	dw test2 
c7f1			;	dw test3 
c7f1			;	dw test4 
c7f1			;	dw game2r 
c7f1			;	dw game2b1 
c7f1			;	dw game2b2 
c7f1			 
c7f1				; start up words that are actually useful 
c7f1			 
c7f1 57 c8		    dw spi1 
c7f3 7f c8		    dw spi2 
c7f5 b7 c8		    dw spi3 
c7f7			 
c7f7			 
c7f7 f3 c8			dw longread 
c7f9 3a c9			dw clrstack 
c7fb 6d c9			dw type 
c7fd 5d cb			dw stest 
c7ff 91 c9			dw strncpy 
c801 f3 ca			dw list 
c803 f2 c9			dw start1 
c805 04 ca			dw start2 
c807			;	dw start3 
c807 17 ca			dw start3b 
c809 93 ca			dw start3c 
c80b			 
c80b				; (unit) testing words 
c80b			 
c80b d4 cb			dw mtesta 
c80d 89 cc			dw mtestb 
c80f 2c cd			dw mtestc 
c811 e1 cd			dw mtestd 
c813 85 ce			dw mteste 
c815			 
c815				; demo/game words 
c815			 
c815 91 d5		        dw game3w 
c817 bf d5		        dw game3p 
c819 dd d5		        dw game3sc 
c81b 0e d6		        dw game3vsi 
c81d 3a d6		        dw game3vs 
c81f				 
c81f 84 d3			dw game2b 
c821 f2 d3			dw game2bf 
c823 3c d4			dw game2mba 
c825 d2 d4			dw game2mbas 
c827 14 d5			dw game2mb 
c829			 
c829 45 d0			dw game1 
c82b 56 d0			dw game1a 
c82d b8 d0			dw game1b 
c82f ed d0			dw game1c 
c831 23 d1			dw game1d 
c833 54 d1			dw game1s 
c835 68 d1			dw game1t 
c837 7d d1			dw game1f 
c839 b1 d1			dw game1z 
c83b f5 d1			dw game1zz 
c83d			 
c83d 3b cf			dw test5 
c83f 73 cf			dw test6 
c841 ab cf			dw test7 
c843 bf cf			dw test8 
c845 eb cf			dw test9 
c847 01 d0			dw test10 
c849				 
c849 cc d2		        dw ssv5 
c84b b0 d2		        dw ssv4 
c84d 94 d2		        dw ssv3 
c84f 5e d2		        dw ssv2 
c851 e5 d2		        dw ssv1 
c853 2d d3		        dw ssv1cpm 
c855			;	dw keyup 
c855			;	dw keydown 
c855			;	dw keyleft 
c855			;	dw keyright 
c855			;	dw 	keyf1 
c855			;	dw keyf2 
c855			;	dw keyf3 
c855			;	dw keyf4 
c855			;	dw keyf5 
c855			;	dw keyf6 
c855			;	dw keyf7 
c855			;	dw keyf8 
c855			;	dw keyf9 
c855			;	dw keyf10 
c855			;	dw keyf11 
c855			;	dw keyf12 
c855			;	dw keytab 
c855			;	dw keycr 
c855			;	dw keyhome 
c855			;	dw keyend 
c855			;	dw keybs 
c855 00 00			db 0, 0	 
c857			 
c857			; SPI Net support words 
c857			 
c857			 
c857 .. 00		spi1:       db ": clkstro $00 do dup i + @ spio loop ; ",0 
c87f .. 00		spi2:       db ": send spicel $01 spio spio ptr count clkstro spiceh ; ",0 
c8b7 .. 00		spi3:       db ": storestr spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
c8f3			 
c8f3			; Long read of currently open file 
c8f3 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
c93a			 
c93a			; clear stack  
c93a			 
c93a .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c96d			 
c96d			; type ( addr count - ) 
c96d .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c991			 
c991			; some direct memory words 
c991			; strncpy ( len t f -- t ) 
c991			 
c991 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c9f2			 
c9f2 .. 00		start1:     	db ": bpon $0000 bp ;",0 
ca04 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
ca17 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
ca93 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
caf3			 
caf3			 
caf3			; a handy word to list items on the stack 
caf3			 
caf3 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
cb5d			 
cb5d			 
cb5d			; test stack  
cb5d			; rnd8 stest 
cb5d			 
cb5d .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
cbd4			 
cbd4			; random malloc and free cycles 
cbd4			 
cbd4 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
cc89			 
cc89			; fixed malloc and free cycles 
cc89			 
cc89 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
cd2c			 
cd2c			; fixed double string push and drop cycle  
cd2c			 
cd2c .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
cde1			 
cde1			; consistent fixed string push and drop cycle  
cde1			 
cde1 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
ce85			 
ce85 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cf3b			 
cf3b			;test1:		db ": aa 1 2 3 ;", 0 
cf3b			;test2:     	db "111 aa 888 999",0 
cf3b			;test3:     	db ": bb 77 ;",0 
cf3b			;test4:     	db "$02 $01 do i . loop bb",0 
cf3b			 
cf3b .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cf73 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cfab .. 00		test7:     	db ": box hline vline ;",0 
cfbf .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cfeb .. 00		test9:     	db ": sw $01 adsp world ;",0 
d001 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d026 .. 00		test11:     	db "hello create .",0 
d035 .. 00		test12:     	db "hello2 create .",0 
d045			 
d045			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d045			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d045			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d045			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d045			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d045			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d045			 
d045			;iftest1:     	db "$0001 IF cls .",0 
d045			;iftest2:     	db "$0000 IF cls .",0 
d045			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d045			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d045			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d045			 
d045			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d045			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d045			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d045			 
d045			 
d045			 
d045			; a small guess the number game 
d045			 
d045 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d056 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d0b8			 
d0b8 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d0ed .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d123 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d154 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d168 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d17d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d1b1 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d1f5			 
d1f5			; Using 'ga' save a high score across multiple runs using external storage 
d1f5			 
d1f5 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
d25e			 
d25e			 
d25e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
d25e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
d25e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
d25e			 
d25e			; simple screen saver to test code memory reuse to destruction 
d25e			 
d25e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
d294 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
d2b0 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d2cc .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d2e5 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d32d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d384			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d384			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d384			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d384			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d384			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d384			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d384			 
d384			 
d384			 
d384			; minesweeper/battleship finding game 
d384			; draws a game board of random ship/mine positions 
d384			; user enters coords to see if it hits on 
d384			; game ends when all are hit 
d384			; when hit or miss says how many may be in the area 
d384			 
d384			; setup the game board and then hide it 
d384 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d3f2 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d43c			; prompt for where to target 
d43c .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d4d2 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d4f7			; TODO see if the entered coords hits or misses pushes char hit of miss 
d4f7 .. 00		game2mbht:      db ": mbckht nop ;",0 
d506 .. 00		game2mbms:      db ": mbcms nop ;",0 
d514			; TODO how many might be near by 
d514 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d591			 
d591			; Game 3 
d591			 
d591			; Vert scroller ski game - avoid the trees! 
d591			 
d591			; v0 score (ie turns) 
d591			; v1 player pos 
d591			; v2 left wall 
d591			; v3 right wall 
d591			 
d591			; Draw side walls randomly 
d591			 
d591 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d5bf			 
d5bf			; Draw player 
d5bf .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d5dd			 
d5dd			; TODO Get Key 
d5dd			 
d5dd			; TODO Move left right 
d5dd			 
d5dd			; scroll and move walls a bit 
d5dd			 
d5dd .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d60e			 
d60e			; main game loop 
d60e			 
d60e .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d63a .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d679			 
d679			; key board defs 
d679			 
d679 .. 00		keyup:       db ": keyup $05 ;",0 
d687 .. 00		keydown:       db ": keydown $0a ;",0 
d697 .. 00		keyleft:       db ": keyleft $0b ;",0 
d6a7 .. 00		keyright:       db ": keyright $0c ;",0 
d6b8 .. 00		keyf1:       db ": keyf1 $10 ;",0 
d6c6 .. 00		keyf2:       db ": keyf2 $11 ;",0 
d6d4 .. 00		keyf3:       db ": keyf3 $12 ;",0 
d6e2 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d6f0 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d6fe .. 00		keyf6:       db ": keyf6 $15 ;",0 
d70c .. 00		keyf7:       db ": keyf7 $16 ;",0 
d71a .. 00		keyf8:       db ": keyf8 $17 ;",0 
d728 .. 00		keyf9:       db ": keyf9 $18 ;",0 
d736 .. 00		keyf10:       db ": keyf10 $19 ;",0 
d745 .. 00		keyf11:       db ": keyf11 $1a ;",0 
d754 .. 00		keyf12:       db ": keyf12 $1b ;",0 
d763			 
d763 .. 00		keytab:       db ": keytab $09 ;",0 
d772 .. 00		keycr:       db ": keycr $0d ;",0 
d780 .. 00		keyhome:       db ": keyhome $0e ;",0 
d790 .. 00		keyend:       db ": keyend $0f ;",0 
d79f .. 00		keybs:       db ": keybs $08 ;",0 
d7ad			 
d7ad			   
d7ad			 
d7ad			 
d7ad			 
d7ad			; eof 
# End of file forth_autostart.asm
d7ad			 
d7ad .. 00		sprompt1: db "Startup load...",0 
d7bd .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d7d3			 
d7d3			 
d7d3			 
d7d3			 
d7d3			forth_startup: 
d7d3 21 f1 c7			ld hl, startcmds 
d7d6 3e 00			ld a, 0 
d7d8 32 ab e8			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d7db			 
d7db e5			.start1:	push hl 
d7dc cd 75 8a			call clear_display 
d7df 11 ad d7			ld de, sprompt1 
d7e2 3e 00		        ld a, display_row_1 
d7e4 cd 88 8a			call str_at_display 
d7e7 11 bd d7			ld de, sprompt2 
d7ea 3e 14		        ld a, display_row_2 
d7ec cd 88 8a			call str_at_display 
d7ef e1				pop hl 
d7f0 e5				push hl 
d7f1 5e				ld e,(hl) 
d7f2 23				inc hl 
d7f3 56				ld d,(hl) 
d7f4 3e 28		        ld a, display_row_3 
d7f6 cd 88 8a			call str_at_display 
d7f9 cd 98 8a			call update_display 
d7fc			 
d7fc			 
d7fc 3a ab e8			ld a, (os_last_cmd) 
d7ff fe 00			cp 0 
d801 28 05			jr z, .startprompt 
d803 cd e6 89			call delay250ms 
d806 18 24			jr .startdo 
d808				 
d808				 
d808			 
d808			.startprompt: 
d808			 
d808 3e 4f			ld a,display_row_4 + display_cols - 1 
d80a 11 8a 9a		        ld de, endprg 
d80d cd 88 8a			call str_at_display 
d810 cd 98 8a			call update_display 
d813 cd f2 89			call delay1s 
d816 cd 39 db			call cin_wait 
d819						 
d819 fe 2a			cp '*' 
d81b 28 5e			jr z, .startupend1 
d81d fe 23			cp '#' 
d81f 20 07			jr nz, .startno 
d821 3e 01			ld a, 1 
d823 32 ab e8			ld (os_last_cmd),a 
d826 18 04			jr .startdo 
d828 fe 31		.startno:	cp '1' 
d82a 28 3a			jr z,.startnxt  
d82c			 
d82c				; exec startup line 
d82c			.startdo:	 
d82c e1				pop hl 
d82d e5				push hl 
d82e				 
d82e 5e				ld e,(hl) 
d82f 23				inc hl 
d830 56				ld d,(hl) 
d831 eb				ex de,hl 
d832			 
d832 e5				push hl 
d833			 
d833 3e 00			ld a, 0 
d835				;ld a, FORTH_END_BUFFER 
d835 cd 0b 91			call strlent 
d838 23				inc hl   ; include zero term to copy 
d839 06 00			ld b,0 
d83b 4d				ld c,l 
d83c e1				pop hl 
d83d 11 85 e4			ld de, scratch 
d840 ed b0			ldir 
d842			 
d842			 
d842 21 85 e4			ld hl, scratch 
d845 cd d0 9e			call forthparse 
d848 cd 10 9f			call forthexec 
d84b cd 22 9e			call forthexec_cleanup 
d84e			 
d84e 3e 3c			ld a, display_row_4 
d850 11 2e 98			ld de, endprog 
d853			 
d853 cd 98 8a			call update_display		 
d856			 
d856 3a ab e8			ld a, (os_last_cmd) 
d859 fe 00			cp 0 
d85b 20 09			jr nz, .startnxt 
d85d cd 8c 9a			call next_page_prompt 
d860 cd 75 8a		        call clear_display 
d863 cd 98 8a			call update_display		 
d866			 
d866				; move onto next startup line? 
d866			.startnxt: 
d866			 
d866 cd e6 89			call delay250ms 
d869 e1				pop hl 
d86a			 
d86a 23				inc hl 
d86b 23				inc hl 
d86c			 
d86c e5				push hl 
d86d 5e				ld e, (hl) 
d86e 23				inc hl 
d86f 56				ld d, (hl) 
d870 e1				pop hl 
d871				; TODO replace 0 test 
d871			 
d871 eb				ex de, hl 
d872 cd cb 8c			call ishlzero 
d875			;	ld a,e 
d875			;	add d 
d875			;	cp 0    ; any left to do? 
d875 eb				ex de, hl 
d876 c2 db d7			jp nz, .start1 
d879 18 01			jr .startupend 
d87b			 
d87b e1			.startupend1: pop hl 
d87c			.startupend: 
d87c			 
d87c cd 75 8a			call clear_display 
d87f cd 98 8a			call update_display 
d882 c9				ret 
d883			 
d883			 
d883			; stack over and underflow checks 
d883			 
d883			; init the words to detect the under/overflow 
d883			 
d883			chk_stk_init: 
d883				; a vague random number to check so we dont get any "lucky" hits 
d883 3e 2d			ld a, 45 
d885 6f				ld l, a 
d886 00				nop 
d887 3e 17			ld a, 23 
d889 67				ld h, a 
d88a			 
d88a 22 6c e4			ld (chk_word), hl     ; the word we need to check against 
d88d			 
d88d			;	ld (chk_stund), hl	; stack points.... 
d88d 22 00 ef			ld (chk_stovr), hl 
d890 22 b0 eb			ld (chk_ret_und), hl 
d893 22 6e eb			ld (chk_ret_ovr), hl 
d896 22 ec ea			ld (chk_loop_ovr), hl 
d899 22 ea e9			ld (chk_data_ovr), hl 
d89c c9				ret 
d89d				 
d89d			check_stacks: 
d89d				; check all stack words 
d89d			 
d89d e5				push hl 
d89e d5				push de 
d89f			 
d89f			;	ld de,(chk_word) 
d89f			;	ld hl, (chk_stund)	; stack points.... 
d89f			;	if DEBUG_STK_FAULT 
d89f			;		DMARK "FAa" 
d89f			;		CALLMONITOR 
d89f			;	endif 
d89f			;	call cmp16 
d89f			;	jp z, .chk_faulta 
d89f			; 
d89f			;	ld de, sfaultsu 
d89f			;	jp .chk_fault 
d89f			 
d89f 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d8a2 ed 5b 6c e4		ld de,(chk_word) 
d8a6				if DEBUG_STK_FAULT 
d8a6					DMARK "FAb" 
d8a6					CALLMONITOR 
d8a6				endif 
d8a6 cd c0 8c			call cmp16 
d8a9 28 06			jr z, .chk_fault1 
d8ab 11 4c d9			ld de, sfaultso 
d8ae c3 00 d9			jp .chk_fault 
d8b1			.chk_fault1:  
d8b1 2a b0 eb			ld hl, (chk_ret_und) 
d8b4 ed 5b 6c e4		ld de,(chk_word) 
d8b8				if DEBUG_STK_FAULT 
d8b8					DMARK "FAU" 
d8b8					CALLMONITOR 
d8b8				endif 
d8b8 cd c0 8c			call cmp16 
d8bb ca c4 d8			jp z, .chk_fault2 
d8be 11 5c d9			ld de, sfaultru 
d8c1 c3 00 d9			jp .chk_fault 
d8c4			.chk_fault2:  
d8c4 2a 6e eb			ld hl, (chk_ret_ovr) 
d8c7 ed 5b 6c e4		ld de,(chk_word) 
d8cb				if DEBUG_STK_FAULT 
d8cb					DMARK "FA1" 
d8cb					CALLMONITOR 
d8cb				endif 
d8cb cd c0 8c			call cmp16 
d8ce ca d7 d8			jp z, .chk_fault3 
d8d1 11 6a d9			ld de, sfaultro 
d8d4 c3 00 d9			jp .chk_fault 
d8d7			.chk_fault3:  
d8d7 2a ec ea			ld hl, (chk_loop_ovr) 
d8da ed 5b 6c e4		ld de,(chk_word) 
d8de				if DEBUG_STK_FAULT 
d8de					DMARK "FA2" 
d8de					CALLMONITOR 
d8de				endif 
d8de cd c0 8c			call cmp16 
d8e1 ca ea d8			jp z, .chk_fault4 
d8e4 11 84 d9			ld de, sfaultlo 
d8e7 c3 00 d9			jp .chk_fault 
d8ea			.chk_fault4:  
d8ea 2a ea e9			ld hl, (chk_data_ovr) 
d8ed ed 5b 6c e4		ld de,(chk_word) 
d8f1				if DEBUG_STK_FAULT 
d8f1					DMARK "FA3" 
d8f1					CALLMONITOR 
d8f1				endif 
d8f1 cd c0 8c			call cmp16 
d8f4 ca fd d8			jp z, .chk_fault5 
d8f7 11 9e d9			ld de, sfaultdo 
d8fa c3 00 d9			jp .chk_fault 
d8fd			 
d8fd			 
d8fd			.chk_fault5:  
d8fd d1				pop de 
d8fe e1				pop hl 
d8ff			 
d8ff c9				ret 
d900			 
d900 cd 75 8a		.chk_fault: 	call clear_display 
d903 3e 14				ld a, display_row_2 
d905 cd 88 8a				call str_at_display 
d908 11 2e d9				   ld de, .stackfault 
d90b 3e 00				ld a, display_row_1 
d90d cd 88 8a				call str_at_display 
d910 11 b7 ee				    ld de, debug_mark 
d913 3e 11				ld a, display_row_1+17 
d915 cd 88 8a				call str_at_display 
d918 cd 98 8a				call update_display 
d91b			 
d91b				; prompt before entering montior for investigating issue 
d91b			 
d91b 3e 3c			ld a, display_row_4 
d91d 11 2e 98			ld de, endprog 
d920			 
d920 cd 98 8a			call update_display		 
d923			 
d923 cd 8c 9a			call next_page_prompt 
d926			 
d926 d1				pop de 
d927 e1				pop hl 
d928 cd 82 98				call monitor 
d92b c3 7c 97				jp warmstart 
d92e					;jp 0 
d92e					;halt 
d92e			 
d92e			 
d92e			 
d92e .. 00		.stackfault: 	db "Stack fault:",0 
d93b			 
d93b .. 00		sfaultsu: 	db	"Stack under flow",0 
d94c .. 00		sfaultso: 	db	"Stack over flow",0 
d95c .. 00		sfaultru:	db "RTS underflow",0 
d96a .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d984 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d99e .. 00		sfaultdo:	db "DTS overflow", 0 
d9ab			 
d9ab			 
d9ab			fault_dsp_under: 
d9ab 11 bd d9			ld de, .dsp_under 
d9ae c3 6d da			jp .show_fault 
d9b1			 
d9b1			fault_rsp_under: 
d9b1 11 cb d9			ld de, .rsp_under 
d9b4 c3 6d da			jp .show_fault 
d9b7			fault_loop_under: 
d9b7 11 d9 d9			ld de, .loop_under 
d9ba c3 6d da			jp .show_fault 
d9bd			 
d9bd .. 00		.dsp_under: db "DSP Underflow",0 
d9cb .. 00		.rsp_under: db "RSP Underflow",0 
d9d9 .. 00		.loop_under: db "LOOP Underflow",0 
d9e8			 
d9e8			 
d9e8 d5			type_faultn: 	push de 
d9e9 e5					push hl 
d9ea cd 75 8a				call clear_display 
d9ed 11 14 da				   ld de, .typefaultn 
d9f0 3e 00				ld a, display_row_1 
d9f2 cd 88 8a				call str_at_display 
d9f5 11 b7 ee				    ld de, debug_mark 
d9f8 3e 11				ld a, display_row_1+17 
d9fa cd 88 8a				call str_at_display 
d9fd cd 98 8a				call update_display 
da00			 
da00				; prompt before entering montior for investigating issue 
da00			 
da00 3e 3c			ld a, display_row_4 
da02 11 2e 98			ld de, endprog 
da05			 
da05 cd 98 8a			call update_display		 
da08			 
da08 cd 8c 9a			call next_page_prompt 
da0b			 
da0b e5					push hl 
da0c d5					push de 
da0d cd 82 98				call monitor 
da10 c3 7c 97				jp warmstart 
da13 76					halt 
da14			 
da14			 
da14 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
da2b			 
da2b d5			type_faults: 	push de 
da2c e5					push hl 
da2d cd 75 8a				call clear_display 
da30 11 56 da				   ld de, .typefaults 
da33 3e 00				ld a, display_row_1 
da35 cd 88 8a				call str_at_display 
da38 11 b7 ee				    ld de, debug_mark 
da3b 3e 11				ld a, display_row_1+17 
da3d cd 88 8a				call str_at_display 
da40 cd 98 8a				call update_display 
da43			 
da43				; prompt before entering montior for investigating issue 
da43			 
da43 3e 3c			ld a, display_row_4 
da45 11 2e 98			ld de, endprog 
da48			 
da48 cd 98 8a			call update_display		 
da4b			 
da4b cd 8c 9a			call next_page_prompt 
da4e			 
da4e e1					pop hl 
da4f d1					pop de 
da50 cd 82 98				call monitor 
da53 c3 7c 97				jp warmstart 
da56			 
da56			 
da56 .. 00		.typefaults: db "STR Type Expected TOS!",0 
da6d			 
da6d			.show_fault: 	 
da6d d5					push de 
da6e cd 75 8a				call clear_display 
da71 d1					pop de 
da72 3e 00				ld a, display_row_1 
da74 cd 88 8a				call str_at_display 
da77 11 b7 ee				    ld de, debug_mark 
da7a 3e 11				ld a, display_row_1+17 
da7c cd 88 8a				call str_at_display 
da7f cd 98 8a				call update_display 
da82			 
da82				; prompt before entering montior for investigating issue 
da82			 
da82 3e 3c			ld a, display_row_4 
da84 11 2e 98			ld de, endprog 
da87			 
da87 cd 98 8a			call update_display		 
da8a			 
da8a cd 8c 9a			call next_page_prompt 
da8d			 
da8d e1					pop hl 
da8e d1					pop de 
da8f cd 82 98				call monitor 
da92			; do a dump to cli and not warmstart so we preserve all of the uwords.  
da92			; TODO Make optional fault restart to cli or warm boot? 
da92					;jp warmstart 
da92 c3 d4 97				jp cli 
da95 76					halt 
da96			 
da96			; handle the auto run of code from files in storage 
da96			 
da96			 
da96			if STORAGE_SE 
da96			 
da96			sprompt3: db "Loading from start-up file?:",0 
da96			sprompt4: db "(Y=Any key/N=No)",0 
da96			 
da96			 
da96			forth_autoload: 
da96			 
da96				; load block 0 of store 1 
da96				 
da96				ld a, $fe      ; bit 0 clear 
da96				ld (spi_device), a 
da96			 
da96				call storage_get_block_0 
da96			 
da96				ld a, (store_page+STORE_0_AUTOFILE) 
da96			 
da96				cp 0 
da96				ret z     ; auto start not enabled 
da96			 
da96				call clear_display 
da96			 
da96				; set bank 
da96			 
da96					ld a, (store_page+STORE_0_BANKRUN) 
da96					ld (spi_device), a 
da96			 
da96				; get file id to load from and get the file name to display 
da96			 
da96					ld a, (store_page+STORE_0_FILERUN) 
da96			 
da96					ld l, 0 
da96					ld h, a 
da96					ld de, store_page 
da96			 
da96					if DEBUG_FORTH_WORDS 
da96						DMARK "ASp" 
da96						CALLMONITOR 
da96					endif 
da96					call storage_read 
da96			 
da96					if DEBUG_FORTH_WORDS 
da96						DMARK "ASr" 
da96						CALLMONITOR 
da96					endif 
da96			 
da96					call ishlzero 
da96					ret z             ; file not found 
da96			 
da96					ld a, display_row_2 + 10 
da96					ld de, store_page+3 
da96					call str_at_display 
da96				 
da96			; 
da96			 
da96				ld a, display_row_1+5 
da96				ld de, sprompt3 
da96				call str_at_display 
da96				ld a, display_row_3+15 
da96				ld de, sprompt4 
da96				call str_at_display 
da96			 
da96				call update_display 
da96			 
da96				call cin_wait 
da96				cp 'n' 
da96				ret z 
da96				cp 'N' 
da96				ret z 
da96			 
da96				call delay1s 
da96			 
da96				ld a, (store_page+2) 
da96				ld (store_openmaxext), a    ; save count of ext 
da96				ld a, 1  
da96				ld (store_openext), a    ; save count of ext 
da96			 
da96			.autof:  
da96				ld l , a 
da96				 
da96				ld a, (store_page) 
da96				ld h, a	 
da96				ld de, store_page 
da96					if DEBUG_FORTH_WORDS 
da96						DMARK "ASl" 
da96						CALLMONITOR 
da96					endif 
da96					call storage_read 
da96				call ishlzero 
da96				ret z 
da96			;	jr z, .autoend 
da96			 
da96					if DEBUG_FORTH_WORDS 
da96						DMARK "ASc" 
da96						CALLMONITOR 
da96					endif 
da96				ld de, store_page+2 
da96				ld a, display_row_4 
da96				call str_at_display 
da96			 
da96				call update_display 
da96				call delay250ms 
da96			 
da96			 
da96			 
da96				ld hl, store_page+2 
da96				call forthparse 
da96				call forthexec 
da96				call forthexec_cleanup 
da96			 
da96				 
da96				ld a, (store_openext) 
da96				inc a 
da96				ld (store_openext), a    ; save count of ext 
da96			 
da96				jr .autof 
da96			;.autofdone: 
da96			; 
da96			;		if DEBUG_FORTH_WORDS 
da96			;			DMARK "ASx" 
da96			;			CALLMONITOR 
da96			;		endif 
da96			;;	call clear_display 
da96			;	ret 
da96			 
da96			 
da96			 
da96			endif 
da96			 
da96			 
da96			; eof 
# End of file forth_kernel.asm
da96			;include "nascombasic.asm" 
da96			 
da96			 
da96			; find out where the code ends if loaded into RAM (for SC114) 
da96			;endofcode:  
da96			;	nop 
da96			 
da96			 
da96			; eof 
da96			 
# End of file main.asm
da96			;include "firmware_lcd_4x20.asm" 
da96			;include "firmware_key_4x4.asm" 
da96			include "firmware_serial_display.asm" 
da96			 
da96			; Serial display interface for SC114 
da96			 
da96			 
da96			display_row_1: equ 0 
da96			display_row_2: equ display_row_1+display_cols 
da96			display_row_3: equ display_row_2 + display_cols 
da96			display_row_4: equ display_row_3 + display_cols 
da96			 
da96			kLCDWidth:  EQU display_cols             ;Width in characters 
da96			kLCD_Line1: EQU 0x00  
da96			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
da96			; E1 
da96			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
da96			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
da96			 
da96			lcd_init: 
da96				; no init as handled by the SCM bios 
da96 c9				ret 
da97			 
da97			 
da97			; low level functions for direct screen writes 
da97			 
da97			; output char at pos? 
da97			fLCD_Str: 
da97			        ;out (SC114_SIO_1_OUT),a 
da97 c5				push bc 
da98 0e 02			ld c, $02 
da9a f7				rst $30 
da9b c1				pop bc 
da9c c9				ret 
da9d			 
da9d			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
da9d			fLCD_Pos: 
da9d				; use ASCII escape to position 
da9d			        ;out (SC114_SIO_1_OUT),a 
da9d c5				push bc 
da9e 0e 02			ld c, $02 
daa0 f7				rst $30 
daa1 c1				pop bc 
daa2			 
daa2 c9				ret 
daa3			 
daa3			; output char at pos 
daa3			fLCD_Data: 
daa3			      ;  out (SC114_SIO_1_OUT),a 
daa3 c5				push bc 
daa4 0e 02			ld c, $02 
daa6 f7				rst $30 
daa7 c1				pop bc 
daa8			 
daa8 c9				ret 
daa9			 
daa9			; ascii cls  
daa9			 
daa9 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
daad			 
daad			; write the frame buffer given in hl to hardware  
daad			write_display: 
daad			 
daad			API: equ 0 
daad			 
daad			if API 
daad				push bc 
daad				ld b, 4 
daad			 
daad			        ld (display_write_tmp), hl 	  
daad			 
daad				; clear and home cursor 
daad			 
daad				ld c, 6 
daad				ld de, .cls 
daad				rst $30 
daad			 
daad			 
daad			.writeln: 
daad			 
daad				ld de, (display_write_tmp) 
daad				ld c, 6 
daad				rst $30 
daad				ld c, 7 
daad				rst $30 
daad			 
daad				ld hl, (display_write_tmp) 
daad				ld de, display_cols 
daad				add hl,de 
daad				ld (display_write_tmp),hl 
daad			 
daad				djnz  .writeln 
daad			 
daad				pop bc 
daad			 
daad			 
daad				ret 
daad			endif 
daad e5				push hl 
daae c5				push bc 
daaf d5				push de 
dab0			 
dab0			;	ld c, 2 
dab0			;	;ld de, .cls 
dab0			;	ld a, 27 
dab0			;	rst $30 
dab0			;	ld c, 2 
dab0			;	;ld de, .cls 
dab0			;	ld a, '[' 
dab0			;	rst $30 
dab0			; 
dab0			;	ld c, 2 
dab0			;	;ld de, .cls 
dab0			;	ld a, 'H' 
dab0			;	rst $30 
dab0			; 
dab0			 
dab0 0e 02			ld c, 2 
dab2				;ld de, .cls 
dab2 3e 1b			ld a, 27 
dab4 f7				rst $30 
dab5			 
dab5			 
dab5 0e 02			ld c, 2 
dab7				;ld de, .cls 
dab7 3e 5b			ld a, '[' 
dab9 f7				rst $30 
daba 0e 02			ld c, 2 
dabc				;ld de, .cls 
dabc 3e 32			ld a, '2' 
dabe f7				rst $30 
dabf 0e 02			ld c, 2 
dac1				;ld de, .cls 
dac1 3e 4a			ld a, 'J' 
dac3 f7				rst $30 
dac4 d1				pop de 
dac5 c1				pop bc 
dac6 e1				pop hl 
dac7			 
dac7			 
dac7 22 55 ed		        ld (display_write_tmp), hl 	  
daca 3e 00			ld a, kLCD_Line1 
dacc			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
dacc 06 14			ld b, display_cols 
dace ed 5b 55 ed		ld de, (display_write_tmp) 
dad2 cd 30 db			call write_len_string 
dad5				 
dad5			 
dad5 e5			push hl 
dad6 d5			push de 
dad7 c5			push bc 
dad8 0e 07			ld c, 7 
dada f7				rst $30 
dadb c1			pop bc 
dadc d1			pop de 
dadd e1			pop hl 
dade			 
dade				 
dade 2a 55 ed			ld hl, (display_write_tmp) 
dae1 11 14 00			ld de, display_cols 
dae4 19				add hl,de 
dae5 22 55 ed			ld (display_write_tmp),hl 
dae8			 
dae8				 
dae8 3e 14			ld a, kLCD_Line2 
daea			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
daea 06 14			ld b, display_cols 
daec ed 5b 55 ed		ld de, (display_write_tmp) 
daf0 cd 30 db			call write_len_string 
daf3				 
daf3 2a 55 ed			ld hl, (display_write_tmp) 
daf6 11 14 00			ld de, display_cols 
daf9 19				add hl,de 
dafa 22 55 ed			ld (display_write_tmp),hl 
dafd			 
dafd e5			push hl 
dafe d5			push de 
daff c5			push bc 
db00 0e 07			ld c, 7 
db02 f7				rst $30 
db03 c1			pop bc 
db04 d1			pop de 
db05 e1			pop hl 
db06			 
db06				 
db06 3e 28			ld a, kLCD_Line3 
db08			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
db08 06 14			ld b, display_cols 
db0a ed 5b 55 ed		ld de, (display_write_tmp) 
db0e cd 30 db			call write_len_string 
db11				 
db11 2a 55 ed			ld hl, (display_write_tmp) 
db14 11 14 00			ld de, display_cols 
db17 19				add hl,de 
db18 22 55 ed			ld (display_write_tmp),hl 
db1b			 
db1b e5			push hl 
db1c d5			push de 
db1d c5			push bc 
db1e 0e 07			ld c, 7 
db20 f7				rst $30 
db21 c1			pop bc 
db22 d1			pop de 
db23 e1			pop hl 
db24			 
db24				 
db24 3e 3c			ld a, kLCD_Line4 
db26			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
db26 06 14			ld b, display_cols 
db28 ed 5b 55 ed		ld de, (display_write_tmp) 
db2c cd 30 db			call write_len_string 
db2f c9					ret 
db30			 
db30			 
db30				; write out a fixed length string given in b from de 
db30			 
db30 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
db31 cd a3 da		            CALL fLCD_Data      ;Write character to display 
db34 13				inc de 
db35 10 f9			djnz write_len_string 
db37 c9				ret 
db38			 
db38			 
db38			; eof 
# End of file firmware_serial_display.asm
db38			include "firmware_key_serial.asm" 
db38			; Serial keyboard interface for SC114 
db38			 
db38			key_init: 
db38				; no init as handled by the SCM bios 
db38 c9				ret 
db39			 
db39			 
db39			cin_wait: 
db39			;	ld a, 0 
db39			;	ret 
db39			 
db39				;in a,(SC114_SIO_1_IN) 
db39			        ; Use SCM API to get from whatever console device we are using 
db39 c5				push bc 
db3a 0e 01			ld c, $01 
db3c f7				rst $30 
db3d c1				pop bc 
db3e c9				ret 
db3f			 
db3f			cin: 
db3f			 
db3f			 
db3f c5				push bc 
db40			 
db40				; any key waiting to process? 
db40 0e 03			ld c, $03 
db42 f7				rst $30 
db43 28 05			jr z, .cin_skip 
db45			 
db45				; yep, get it 
db45			 
db45 0e 01			ld c, $01 
db47 f7				rst $30 
db48 c1				pop bc 
db49 c9				ret 
db4a			.cin_skip: 
db4a 3e 00			ld a, 0 
db4c c1				pop bc 
db4d c9				ret 
db4e			 
db4e			 
db4e			 
db4e			 
# End of file firmware_key_serial.asm
db4e			 
db4e			baseram:  
db4e			endofcode: 
db4e 00				nop 
db4f			 
db4f			heap_start: equ baseram+15  ; Starting address of heap 
db4f			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
db4f			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
db4f			; 
db4f			 
# End of file os_mini_sc114.asm
db4f
