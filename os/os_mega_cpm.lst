# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 60 13			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 0   ; 1  
0103			DEBUG_FORTH_PUSH: equ 0   ; 1  
0103			DEBUG_FORTH_UWORD: equ 0   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ os_input  
0103			os_new_parse_len: equ os_new_malloc + 2  
0103			os_new_word_len: equ os_new_parse_len + 2  
0103			os_new_work_ptr: equ os_new_word_len + 2  
0103			os_new_src_ptr: equ os_new_work_ptr + 2  
0103			os_new_exec: equ os_new_src_ptr + 2  
0103			os_new_exec_ptr: equ os_new_exec + 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ scratch - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 6d 08				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 6d 08				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 6d 08				call clear_display  
0123			  
0123			  
0123 cd b5 46				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd a3 47			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 69 0e				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd 90 08			call update_display  
0132 cd e6 07			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd 72 08			call fill_display  
013a cd 90 08			call update_display  
013d cd e6 07			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd 72 08			call fill_display  
0145 cd 90 08			call update_display  
0148 cd e6 07			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd 72 08			call fill_display  
0150 cd 90 08			call update_display  
0153 cd e6 07			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd 80 08			call str_at_display  
015e cd 90 08			call update_display  
0161			  
0161			  
0161 cd e6 07			call delay1s  
0164 cd e6 07			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd 80 08			call str_at_display  
016f cd 90 08			call update_display  
0172 cd e6 07			call delay1s  
0175 cd e6 07			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd 8a 11			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6						CALLMONITOR 
01e6					endif 
01e6 cd 1f 04			call storage_findnextid 
01e9			 
01e9 cd ef 09			call ishlzero 
01ec			;	ld a, l 
01ec			;	add h 
01ec			;	cp 0 
01ec c8				ret z			; block not found so EOF 
01ed			 
01ed 11 65 eb			ld de, store_page 
01f0 cd b1 01			call storage_read_block 
01f3			 
01f3 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
01f6 6f				ld l, a 
01f7 26 00			ld h, 0 
01f9 c9			 	ret 
01fa			 
01fa			 
01fa			; Write Block 
01fa			; ----------- 
01fa			; 
01fa			; With current bank 
01fa			;  
01fa			; Get block number to write 
01fa			; Write physical blocks starting at start block from buffer 
01fa			  
01fa			storage_write_block: 
01fa				; TODO bank selection 
01fa			 
01fa				; for each of the physical blocks read it into the buffer 
01fa 06 40			ld b, STORE_BLOCK_PHY 
01fc			 
01fc				if DEBUG_STORESE 
01fc					DMARK "SWB" 
01fc f5				push af  
01fd 3a 11 02			ld a, (.dmark)  
0200 32 7a ee			ld (debug_mark),a  
0203 3a 12 02			ld a, (.dmark+1)  
0206 32 7b ee			ld (debug_mark+1),a  
0209 3a 13 02			ld a, (.dmark+2)  
020c 32 7c ee			ld (debug_mark+2),a  
020f 18 03			jr .pastdmark  
0211 ..			.dmark: db "SWB"  
0214 f1			.pastdmark: pop af  
0215			endm  
# End of macro DMARK
0215			 
0215					;push af 
0215					;ld a, 'W' 
0215					;ld (debug_mark),a 
0215					;pop af 
0215					CALLMONITOR 
0215 cd 8a 11			call break_point_state  
0218				endm  
# End of macro CALLMONITOR
0218				endif 
0218			 
0218			; might not be working 
0218			;	call se_writepage 
0218			 
0218			;	ret 
0218			; 
0218			 
0218			 
0218			 
0218			.wl1:    
0218			 
0218				; read physical block at hl into de 
0218			        ; increment hl and de to next read position on exit 
0218			 
0218 e5				push hl 
0219 d5				push de	 
021a c5				push bc 
021b 1a				ld a,(de) 
021c				;if DEBUG_STORESE 
021c			;		push af 
021c			;		ld a, 'W' 
021c			;		ld (debug_mark),a 
021c			;		pop af 
021c			;		CALLMONITOR 
021c			;	endif 
021c cd af 01			call se_writebyte 
021f			;	call delay250ms 
021f 00				nop 
0220 00				nop 
0221 00				nop 
0222			;	if DEBUG_STORESE 
0222			;		push af 
0222			;		ld a, 'w' 
0222			;		ld (debug_mark),a 
0222			;		pop af 
0222			;		CALLMONITOR 
0222			;	endif 
0222 c1				pop bc 
0223 d1				pop de 
0224 e1				pop hl 
0225 23				inc hl 
0226 13				inc de 
0227			 
0227			 
0227 10 ef			djnz .wl1 
0229			 
0229				if DEBUG_STORESE 
0229					DMARK "SW2" 
0229 f5				push af  
022a 3a 3e 02			ld a, (.dmark)  
022d 32 7a ee			ld (debug_mark),a  
0230 3a 3f 02			ld a, (.dmark+1)  
0233 32 7b ee			ld (debug_mark+1),a  
0236 3a 40 02			ld a, (.dmark+2)  
0239 32 7c ee			ld (debug_mark+2),a  
023c 18 03			jr .pastdmark  
023e ..			.dmark: db "SW2"  
0241 f1			.pastdmark: pop af  
0242			endm  
# End of macro DMARK
0242			 
0242					;push af 
0242					;ld a, 'W' 
0242					;ld (debug_mark),a 
0242					;pop af 
0242					CALLMONITOR 
0242 cd 8a 11			call break_point_state  
0245				endm  
# End of macro CALLMONITOR
0245				endif 
0245 c9				ret	 
0246			 
0246			; Init bank 
0246			; --------- 
0246			; 
0246			; With current bank 
0246			; 
0246			; Setup block 0 config 
0246			;     Set 0 file id counter 
0246			;     Set formatted byte pattern 
0246			;     Zero out bank label 
0246			;      
0246			; For every logical block write 0-1 byte as null 
0246			 
0246			storage_get_block_0: 
0246			 
0246				; TODO check presence 
0246			 
0246				; get block 0 config 
0246			 
0246 21 00 00			ld hl, 0 
0249 11 65 eb			ld de, store_page 
024c cd b1 01			call storage_read_block 
024f			 
024f				if DEBUG_STORESE 
024f					DMARK "SB0" 
024f f5				push af  
0250 3a 64 02			ld a, (.dmark)  
0253 32 7a ee			ld (debug_mark),a  
0256 3a 65 02			ld a, (.dmark+1)  
0259 32 7b ee			ld (debug_mark+1),a  
025c 3a 66 02			ld a, (.dmark+2)  
025f 32 7c ee			ld (debug_mark+2),a  
0262 18 03			jr .pastdmark  
0264 ..			.dmark: db "SB0"  
0267 f1			.pastdmark: pop af  
0268			endm  
# End of macro DMARK
0268 11 65 eb				ld de, store_page 
026b			;		push af 
026b			;		ld a, 'i' 
026b			;		ld (debug_mark),a 
026b			;		pop af 
026b					CALLMONITOR 
026b cd 8a 11			call break_point_state  
026e				endm  
# End of macro CALLMONITOR
026e				endif 
026e			 
026e				; is this area formatted? 
026e			 
026e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
026e 2a 66 eb			ld hl, (store_page+1) 
0271 3e 80			ld a,0x80 
0273 bd				cp l 
0274 20 22			jr nz, .ininotformatted 
0276				; do a double check 
0276 3e 27			ld a, 0x27 
0278 bc				cp h 
0279 20 1d			jr nz, .ininotformatted 
027b			 
027b				; formatted then 
027b			 
027b				if DEBUG_STORESE 
027b					DMARK "SB1" 
027b f5				push af  
027c 3a 90 02			ld a, (.dmark)  
027f 32 7a ee			ld (debug_mark),a  
0282 3a 91 02			ld a, (.dmark+1)  
0285 32 7b ee			ld (debug_mark+1),a  
0288 3a 92 02			ld a, (.dmark+2)  
028b 32 7c ee			ld (debug_mark+2),a  
028e 18 03			jr .pastdmark  
0290 ..			.dmark: db "SB1"  
0293 f1			.pastdmark: pop af  
0294			endm  
# End of macro DMARK
0294					;push af 
0294					;ld a, 'I' 
0294					;ld (debug_mark),a 
0294					;pop af 
0294					CALLMONITOR 
0294 cd 8a 11			call break_point_state  
0297				endm  
# End of macro CALLMONITOR
0297				endif 
0297 c9				ret 
0298			 
0298			.ininotformatted: 
0298				; bank not formatted so poke various bits to make sure 
0298			 
0298				if DEBUG_STORESE 
0298					DMARK "SB2" 
0298 f5				push af  
0299 3a ad 02			ld a, (.dmark)  
029c 32 7a ee			ld (debug_mark),a  
029f 3a ae 02			ld a, (.dmark+1)  
02a2 32 7b ee			ld (debug_mark+1),a  
02a5 3a af 02			ld a, (.dmark+2)  
02a8 32 7c ee			ld (debug_mark+2),a  
02ab 18 03			jr .pastdmark  
02ad ..			.dmark: db "SB2"  
02b0 f1			.pastdmark: pop af  
02b1			endm  
# End of macro DMARK
02b1					;push af 
02b1					;ld a, 'f' 
02b1					;ld (debug_mark),a 
02b1					;pop af 
02b1					CALLMONITOR 
02b1 cd 8a 11			call break_point_state  
02b4				endm  
# End of macro CALLMONITOR
02b4				endif 
02b4			 
02b4 21 65 eb			ld hl, store_page 
02b7 3e 00			ld a, 0 
02b9				 
02b9 77				ld (hl),a   ; reset file counter 
02ba			 
02ba 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02bd 22 66 eb		 	ld (store_page+1), hl	 
02c0			 
02c0				; set default label 
02c0			 
02c0 21 55 03			ld hl, .defaultbanklabl 
02c3 11 68 eb		 	ld de, store_page+3 
02c6 01 0f 00			ld bc, 15 
02c9 ed b0			ldir 
02cb			 
02cb				; save default page 0 
02cb			 
02cb 21 00 00			ld hl, 0 
02ce 11 65 eb			ld de, store_page 
02d1				if DEBUG_STORESE 
02d1					DMARK "SB3" 
02d1 f5				push af  
02d2 3a e6 02			ld a, (.dmark)  
02d5 32 7a ee			ld (debug_mark),a  
02d8 3a e7 02			ld a, (.dmark+1)  
02db 32 7b ee			ld (debug_mark+1),a  
02de 3a e8 02			ld a, (.dmark+2)  
02e1 32 7c ee			ld (debug_mark+2),a  
02e4 18 03			jr .pastdmark  
02e6 ..			.dmark: db "SB3"  
02e9 f1			.pastdmark: pop af  
02ea			endm  
# End of macro DMARK
02ea			;		push af 
02ea			;		ld a, 'F' 
02ea			;		ld (debug_mark),a 
02ea			;		pop af 
02ea					CALLMONITOR 
02ea cd 8a 11			call break_point_state  
02ed				endm  
# End of macro CALLMONITOR
02ed				endif 
02ed cd fa 01			call storage_write_block 
02f0				if DEBUG_STORESE 
02f0					DMARK "SB4" 
02f0 f5				push af  
02f1 3a 05 03			ld a, (.dmark)  
02f4 32 7a ee			ld (debug_mark),a  
02f7 3a 06 03			ld a, (.dmark+1)  
02fa 32 7b ee			ld (debug_mark+1),a  
02fd 3a 07 03			ld a, (.dmark+2)  
0300 32 7c ee			ld (debug_mark+2),a  
0303 18 03			jr .pastdmark  
0305 ..			.dmark: db "SB4"  
0308 f1			.pastdmark: pop af  
0309			endm  
# End of macro DMARK
0309			;		push af 
0309			;		ld a, '>' 
0309			;		ld (debug_mark),a 
0309			;		pop af 
0309					CALLMONITOR 
0309 cd 8a 11			call break_point_state  
030c				endm  
# End of macro CALLMONITOR
030c				endif 
030c			 
030c 00				nop 
030d 00				nop 
030e 00				nop 
030f			 
030f				; now set 0 in every page to mark as a free block 
030f			 
030f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0311 21 40 00			ld hl, STORE_BLOCK_PHY 
0314			 
0314 3e 00		.setmark1:   	ld a,0 
0316 e5					push hl 
0317 c5					push bc 
0318 cd af 01				call se_writebyte 
031b 3e 0a			ld a, 10 
031d cd cb 07			call aDelayInMS 
0320 23				inc hl 
0321 cd af 01				call se_writebyte 
0324 3e 0a			ld a, 10 
0326 cd cb 07			call aDelayInMS 
0329 2b				dec hl 
032a c1					pop bc 
032b e1					pop hl 
032c 3e 40				ld a, STORE_BLOCK_PHY 
032e cd c6 09				call addatohl 
0331 10 e1				djnz .setmark1 
0333			 
0333 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0335 3e 00		.setmark2:   	ld a,0 
0337 e5					push hl 
0338 c5					push bc 
0339 cd af 01				call se_writebyte 
033c 3e 0a			ld a, 10 
033e cd cb 07			call aDelayInMS 
0341 23				inc hl 
0342 cd af 01				call se_writebyte 
0345 3e 0a			ld a, 10 
0347 cd cb 07			call aDelayInMS 
034a 2b				dec hl 
034b c1					pop bc 
034c e1					pop hl 
034d 3e 40				ld a, STORE_BLOCK_PHY 
034f cd c6 09				call addatohl 
0352 10 e1				djnz .setmark2 
0354			 
0354					 
0354			 
0354			 
0354 c9				ret 
0355			 
0355			 
0355			 
0355			 
0355 .. 00		.defaultbanklabl:   db "BankLabel",0 
035f			 
035f			 
035f			 
035f			; Label Bank 
035f			; ---------- 
035f			; 
035f			; With current bank 
035f			; Read block 0 
035f			; Set label 
035f			; Write block 0 
035f			 
035f			; label str pointer in hl 
035f			 
035f			storage_label:     
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "LBL" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 7a ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 7b ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 7c ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "LBL"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					CALLMONITOR 
0378 cd 8a 11			call break_point_state  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b			 
037b e5				push hl 
037c			 
037c cd 46 02			call storage_get_block_0 
037f			 
037f				; set default label 
037f			 
037f e1				pop hl 
0380			 
0380 11 68 eb		 	ld de, store_page+3 
0383 01 0f 00			ld bc, 15 
0386				if DEBUG_STORESE 
0386					DMARK "LB3" 
0386 f5				push af  
0387 3a 9b 03			ld a, (.dmark)  
038a 32 7a ee			ld (debug_mark),a  
038d 3a 9c 03			ld a, (.dmark+1)  
0390 32 7b ee			ld (debug_mark+1),a  
0393 3a 9d 03			ld a, (.dmark+2)  
0396 32 7c ee			ld (debug_mark+2),a  
0399 18 03			jr .pastdmark  
039b ..			.dmark: db "LB3"  
039e f1			.pastdmark: pop af  
039f			endm  
# End of macro DMARK
039f					CALLMONITOR 
039f cd 8a 11			call break_point_state  
03a2				endm  
# End of macro CALLMONITOR
03a2				endif 
03a2 ed b0			ldir 
03a4				; save default page 0 
03a4			 
03a4 21 00 00			ld hl, 0 
03a7 11 65 eb			ld de, store_page 
03aa				if DEBUG_STORESE 
03aa					DMARK "LBW" 
03aa f5				push af  
03ab 3a bf 03			ld a, (.dmark)  
03ae 32 7a ee			ld (debug_mark),a  
03b1 3a c0 03			ld a, (.dmark+1)  
03b4 32 7b ee			ld (debug_mark+1),a  
03b7 3a c1 03			ld a, (.dmark+2)  
03ba 32 7c ee			ld (debug_mark+2),a  
03bd 18 03			jr .pastdmark  
03bf ..			.dmark: db "LBW"  
03c2 f1			.pastdmark: pop af  
03c3			endm  
# End of macro DMARK
03c3					CALLMONITOR 
03c3 cd 8a 11			call break_point_state  
03c6				endm  
# End of macro CALLMONITOR
03c6				endif 
03c6 cd fa 01			call storage_write_block 
03c9			 
03c9 c9				ret 
03ca			 
03ca			 
03ca			 
03ca			; Read Block 0 - Config 
03ca			; --------------------- 
03ca			; 
03ca			; With current bank 
03ca			; Call presence test 
03ca			;    If not present format/init bank  
03ca			; Read block 0  
03ca			;  
03ca			 
03ca			 
03ca			; Dir 
03ca			; --- 
03ca			; 
03ca			; With current bank 
03ca			; Load Block 0 Config 
03ca			; Get max file id number 
03ca			; For each logical block 
03ca			;    Read block read byte 2 
03ca			;      if first block of file 
03ca			;         Display file name 
03ca			;         Display type flags for file 
03ca			;        
03ca			 
03ca			; moving to words as this requires stack control 
03ca			 
03ca			 
03ca			; Delete File 
03ca			; ----------- 
03ca			; 
03ca			; With current bank 
03ca			; 
03ca			; Load Block 0 Config 
03ca			; Get max file id number 
03ca			; For each logical block 
03ca			;    Read block file id 
03ca			;      If first block of file and dont have file id 
03ca			;         if file to delete 
03ca			;         Save file id 
03ca			;         Null file id 
03ca			;         Write this block back 
03ca			;      If file id is one saved 
03ca			;         Null file id 
03ca			;         Write this block back 
03ca			 
03ca			storage_erase: 
03ca			 
03ca				; hl contains the file id 
03ca			 
03ca 5d				ld e, l 
03cb 16 00			ld d, 0 
03cd 21 40 00			ld hl, STORE_BLOCK_PHY 
03d0					if DEBUG_FORTH_WORDS 
03d0						DMARK "ERA" 
03d0						CALLMONITOR 
03d0					endif 
03d0 cd 1f 04			call storage_findnextid 
03d3			 
03d3 e5				push hl 
03d4			 
03d4				; TODO check file not found 
03d4			 
03d4 11 65 eb			ld de, store_page 
03d7 cd b1 01			call storage_read_block 
03da			 
03da					if DEBUG_FORTH_WORDS 
03da						DMARK "ER1" 
03da						CALLMONITOR 
03da					endif 
03da 3a 65 eb			ld a, (store_page)	; get file id 
03dd 32 5e eb			ld (store_tmpid), a 
03e0			 
03e0 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
03e3 32 5d eb			ld (store_tmpext), a 
03e6			 
03e6				; wipe file header 
03e6			 
03e6 e1				pop hl 
03e7 3e 00			ld a, 0 
03e9 32 65 eb			ld (store_page), a 
03ec 32 66 eb			ld (store_page+1),a 
03ef 11 65 eb			ld de, store_page 
03f2					if DEBUG_FORTH_WORDS 
03f2						DMARK "ER2" 
03f2						CALLMONITOR 
03f2					endif 
03f2 cd fa 01			call storage_write_block 
03f5			 
03f5			 
03f5				; wipe file extents 
03f5			 
03f5 3a 5d eb			ld a, (store_tmpext) 
03f8 47				ld b, a 
03f9			 
03f9			.eraext:	  
03f9 c5				push bc 
03fa			 
03fa 21 40 00			ld hl, STORE_BLOCK_PHY 
03fd 3a 5e eb			ld a,(store_tmpid) 
0400 5f				ld e, a 
0401 50				ld d, b	 
0402					if DEBUG_FORTH_WORDS 
0402						DMARK "ER3" 
0402						CALLMONITOR 
0402					endif 
0402 cd 1f 04			call storage_findnextid 
0405			 
0405 e5				push hl 
0406 11 65 eb			ld de, store_page 
0409 cd b1 01			call storage_read_block 
040c			 
040c				; free block	 
040c			 
040c 3e 00			ld a, 0 
040e 32 65 eb			ld (store_page), a 
0411 32 66 eb			ld (store_page+1),a 
0414 11 65 eb			ld de, store_page 
0417 e1				pop hl 
0418					if DEBUG_FORTH_WORDS 
0418						DMARK "ER4" 
0418						CALLMONITOR 
0418					endif 
0418 cd fa 01			call storage_write_block 
041b			 
041b c1				pop bc 
041c 10 db			djnz .eraext 
041e			 
041e c9				ret 
041f			 
041f			 
041f			; Find Free Block 
041f			; --------------- 
041f			; 
041f			; With current bank 
041f			;  
041f			; From given starting logical block 
041f			;    Read block  
041f			;    If no file id 
041f			;         Return block id 
041f			 
041f			 
041f			; hl starting page number 
041f			; hl contains free page number or zero if no pages free 
041f			; e contains the file id to locate 
041f			; d contains the block number 
041f			 
041f			; TODO change to find file id and use zero for free block 
041f			 
041f			storage_findnextid: 
041f			 
041f				; now locate first 0 page to mark as a free block 
041f			 
041f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0421			;	ld hl, STORE_BLOCK_PHY 
0421			 
0421					if DEBUG_FORTH_WORDS 
0421					DMARK "FNI" 
0421						CALLMONITOR 
0421					endif 
0421			.ff1:   	 
0421 e5					push hl 
0422 c5					push bc 
0423 d5					push de 
0424 cd ae 01				call se_readbyte 
0427 5f					ld e,a 
0428 23					inc hl 
0429 cd ae 01				call se_readbyte 
042c 57					ld d, a 
042d e1					pop hl 
042e e5					push hl 
042f cd e4 09				call cmp16 
0432 28 2d				jr z, .fffound 
0434			 
0434 d1					pop de 
0435 c1					pop bc 
0436 e1					pop hl 
0437			 
0437					; is found? 
0437					;cp e 
0437					;ret z 
0437			 
0437 3e 40				ld a, STORE_BLOCK_PHY 
0439 cd c6 09				call addatohl 
043c 10 e3				djnz .ff1 
043e			 
043e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0440			.ff2:   	 
0440			 
0440 e5					push hl 
0441 c5					push bc 
0442 d5					push de 
0443 cd ae 01				call se_readbyte 
0446 5f					ld e,a 
0447 23					inc hl 
0448 cd ae 01				call se_readbyte 
044b 57					ld d, a 
044c			 
044c e1					pop hl 
044d e5					push hl 
044e cd e4 09				call cmp16 
0451 28 0e				jr z, .fffound 
0453			 
0453 d1					pop de 
0454 c1					pop bc 
0455 e1					pop hl 
0456					; is found? 
0456					;cp e 
0456					;ret z 
0456			 
0456 3e 40				ld a, STORE_BLOCK_PHY 
0458 cd c6 09				call addatohl 
045b 10 e3				djnz .ff2 
045d			 
045d			 
045d					if DEBUG_FORTH_WORDS 
045d					DMARK "FN-" 
045d					;	push af 
045d					;	ld a, 'n' 
045d					;	ld (debug_mark),a 
045d					;	pop af 
045d						CALLMONITOR 
045d					endif 
045d				; no free marks! 
045d 21 00 00				ld hl, 0 
0460 c9				ret 
0461			.fffound: 
0461				 
0461			 
0461 d1					pop de 
0462 c1					pop bc 
0463 e1					pop hl 
0464					if DEBUG_FORTH_WORDS 
0464					DMARK "FNF" 
0464					;	push af 
0464					;	ld a, 'n' 
0464					;	ld (debug_mark),a 
0464					;	pop af 
0464						CALLMONITOR 
0464					endif 
0464 c9				ret 
0465			 
0465			 
0465			 
0465			; Free Space 
0465			; ---------- 
0465			; 
0465			; With current bank 
0465			; 
0465			; Set block count to zero 
0465			; Starting with first logical block 
0465			;      Find free block  
0465			;      If block id given, increment block count 
0465			; 
0465			;  
0465			 
0465			 
0465			; hl contains count of free blocks 
0465			 
0465			storage_freeblocks: 
0465			 
0465				; now locate first 0 page to mark as a free block 
0465			 
0465 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0467 21 40 00			ld hl, STORE_BLOCK_PHY 
046a 11 00 00			ld de, 0 
046d			 
046d			.fb1:   	 
046d e5					push hl 
046e c5					push bc 
046f d5					push de 
0470 cd ae 01				call se_readbyte 
0473 d1					pop de 
0474 c1					pop bc 
0475 e1					pop hl 
0476			 
0476					; is free? 
0476 fe 00				cp 0 
0478 20 01				jr nz, .ff1cont 
047a 13					inc de 
047b			 
047b			.ff1cont: 
047b			 
047b			 
047b 3e 40				ld a, STORE_BLOCK_PHY 
047d cd c6 09				call addatohl 
0480 10 eb				djnz .fb1 
0482			 
0482 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0484			.fb2:   	 
0484 e5					push hl 
0485 c5					push bc 
0486 d5					push de 
0487 cd ae 01				call se_readbyte 
048a d1					pop de 
048b c1					pop bc 
048c e1					pop hl 
048d			 
048d					; is free? 
048d fe 00				cp 0 
048f 20 01				jr nz, .ff2cont 
0491 13					inc de 
0492			 
0492			.ff2cont: 
0492			 
0492 3e 40				ld a, STORE_BLOCK_PHY 
0494 cd c6 09				call addatohl 
0497 10 eb				djnz .fb2 
0499			 
0499 eb				ex de, hl 
049a c9				ret 
049b			 
049b			; Get File ID 
049b			; ----------- 
049b			; 
049b			; With current bank 
049b			;  
049b			; Load Block 0 Config 
049b			; Get max file id number 
049b			; For each logical block 
049b			;    Read block file id 
049b			;      If first block of file and dont have file id 
049b			;         if file get id and exit 
049b			 
049b			 
049b			 
049b			 
049b			; Create File 
049b			; ----------- 
049b			; 
049b			; With current bank  
049b			; Load Block 0 Config 
049b			; Get max file id number 
049b			; Increment file id number 
049b			; Save Config 
049b			; Find free block 
049b			; Set buffer with file name and file id 
049b			; Write buffer to free block  
049b			 
049b			 
049b			; hl point to file name 
049b			; hl returns file id 
049b			 
049b			; file format: 
049b			; byte 0 - file id 
049b			; byte 1 - extent number 
049b			; byte 2-> data 
049b			 
049b			; format for extent number 0: 
049b			; 
049b			; byte 0 - file id 
049b			; byte 1 - extent 0 
049b			; byte 2 - extent count 
049b			; byte 3 -> file name and meta data 
049b			 
049b			 
049b			storage_create: 
049b				if DEBUG_STORESE 
049b					DMARK "SCR" 
049b f5				push af  
049c 3a b0 04			ld a, (.dmark)  
049f 32 7a ee			ld (debug_mark),a  
04a2 3a b1 04			ld a, (.dmark+1)  
04a5 32 7b ee			ld (debug_mark+1),a  
04a8 3a b2 04			ld a, (.dmark+2)  
04ab 32 7c ee			ld (debug_mark+2),a  
04ae 18 03			jr .pastdmark  
04b0 ..			.dmark: db "SCR"  
04b3 f1			.pastdmark: pop af  
04b4			endm  
# End of macro DMARK
04b4					CALLMONITOR 
04b4 cd 8a 11			call break_point_state  
04b7				endm  
# End of macro CALLMONITOR
04b7				endif 
04b7			 
04b7 e5				push hl		; save file name pointer 
04b8			 
04b8 cd 46 02			call storage_get_block_0 
04bb			 
04bb 3a 65 eb			ld a,(store_page)	; get current file id 
04be 3c				inc a 
04bf 32 65 eb			ld (store_page),a 
04c2				 
04c2 32 5e eb			ld (store_tmpid),a			; save id 
04c5			 
04c5 21 00 00			ld hl, 0 
04c8 11 65 eb			ld de, store_page 
04cb				if DEBUG_STORESE 
04cb					DMARK "SCw" 
04cb f5				push af  
04cc 3a e0 04			ld a, (.dmark)  
04cf 32 7a ee			ld (debug_mark),a  
04d2 3a e1 04			ld a, (.dmark+1)  
04d5 32 7b ee			ld (debug_mark+1),a  
04d8 3a e2 04			ld a, (.dmark+2)  
04db 32 7c ee			ld (debug_mark+2),a  
04de 18 03			jr .pastdmark  
04e0 ..			.dmark: db "SCw"  
04e3 f1			.pastdmark: pop af  
04e4			endm  
# End of macro DMARK
04e4					CALLMONITOR 
04e4 cd 8a 11			call break_point_state  
04e7				endm  
# End of macro CALLMONITOR
04e7				endif 
04e7 cd fa 01			call storage_write_block	 ; save update 
04ea			 
04ea				if DEBUG_STORESE 
04ea 11 65 eb				ld de, store_page 
04ed					DMARK "SCC" 
04ed f5				push af  
04ee 3a 02 05			ld a, (.dmark)  
04f1 32 7a ee			ld (debug_mark),a  
04f4 3a 03 05			ld a, (.dmark+1)  
04f7 32 7b ee			ld (debug_mark+1),a  
04fa 3a 04 05			ld a, (.dmark+2)  
04fd 32 7c ee			ld (debug_mark+2),a  
0500 18 03			jr .pastdmark  
0502 ..			.dmark: db "SCC"  
0505 f1			.pastdmark: pop af  
0506			endm  
# End of macro DMARK
0506					CALLMONITOR 
0506 cd 8a 11			call break_point_state  
0509				endm  
# End of macro CALLMONITOR
0509				endif 
0509				;  
0509				 
0509 21 40 00			ld hl, STORE_BLOCK_PHY 
050c 11 00 00			ld de, 0 
050f cd 1f 04			call storage_findnextid 
0512			 
0512 22 63 eb			ld (store_tmppageid), hl    ; save page to use  
0515			 
0515				; TODO detect 0 = no spare blocks 
0515			 
0515				; hl now contains the free page to use for the file header page 
0515			 
0515				if DEBUG_STORESE 
0515				DMARK "SCF" 
0515 f5				push af  
0516 3a 2a 05			ld a, (.dmark)  
0519 32 7a ee			ld (debug_mark),a  
051c 3a 2b 05			ld a, (.dmark+1)  
051f 32 7b ee			ld (debug_mark+1),a  
0522 3a 2c 05			ld a, (.dmark+2)  
0525 32 7c ee			ld (debug_mark+2),a  
0528 18 03			jr .pastdmark  
052a ..			.dmark: db "SCF"  
052d f1			.pastdmark: pop af  
052e			endm  
# End of macro DMARK
052e					CALLMONITOR 
052e cd 8a 11			call break_point_state  
0531				endm  
# End of macro CALLMONITOR
0531				endif 
0531			 
0531 22 63 eb			ld (store_tmppageid), hl 
0534				 
0534 3a 5e eb			ld a,(store_tmpid)    ; get file id 
0537			;	ld a, (store_filecache)			; save to cache 
0537			 
0537 32 65 eb			ld (store_page),a    ; set page id 
053a 3e 00			ld a, 0			 ; extent 0 is file header 
053c 32 66 eb			ld (store_page+1), a   ; set file extent 
053f			 
053f 32 67 eb			ld (store_page+2), a   ; extent count for the file 
0542			 
0542			;	inc hl 		; init block 0 of file 
0542			;	inc hl   		; skip file and extent id 
0542			 ;       ld a, 0 
0542			;	ld (hl),a 
0542			;	ld a, (store_filecache+1)  	; save to cache 
0542			 
0542			;	inc hl    ; file name 
0542				 
0542				 
0542 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
0545				if DEBUG_STORESE 
0545					DMARK "SCc" 
0545 f5				push af  
0546 3a 5a 05			ld a, (.dmark)  
0549 32 7a ee			ld (debug_mark),a  
054c 3a 5b 05			ld a, (.dmark+1)  
054f 32 7b ee			ld (debug_mark+1),a  
0552 3a 5c 05			ld a, (.dmark+2)  
0555 32 7c ee			ld (debug_mark+2),a  
0558 18 03			jr .pastdmark  
055a ..			.dmark: db "SCc"  
055d f1			.pastdmark: pop af  
055e			endm  
# End of macro DMARK
055e					CALLMONITOR 
055e cd 8a 11			call break_point_state  
0561				endm  
# End of macro CALLMONITOR
0561				endif 
0561 e1				pop hl    ; get zero term string 
0562 e5				push hl 
0563 3e 00			ld a, 0 
0565 cd 2f 0e			call strlent 
0568 23				inc hl   ; cover zero term 
0569 06 00			ld b,0 
056b 4d				ld c,l 
056c e1				pop hl 
056d				;ex de, hl 
056d				if DEBUG_STORESE 
056d					DMARK "SCa" 
056d f5				push af  
056e 3a 82 05			ld a, (.dmark)  
0571 32 7a ee			ld (debug_mark),a  
0574 3a 83 05			ld a, (.dmark+1)  
0577 32 7b ee			ld (debug_mark+1),a  
057a 3a 84 05			ld a, (.dmark+2)  
057d 32 7c ee			ld (debug_mark+2),a  
0580 18 03			jr .pastdmark  
0582 ..			.dmark: db "SCa"  
0585 f1			.pastdmark: pop af  
0586			endm  
# End of macro DMARK
0586					;push af 
0586					;ld a, 'a' 
0586					;ld (debug_mark),a 
0586					;pop af 
0586					CALLMONITOR 
0586 cd 8a 11			call break_point_state  
0589				endm  
# End of macro CALLMONITOR
0589				endif 
0589 ed b0			ldir    ; copy zero term string 
058b				if DEBUG_STORESE 
058b					DMARK "SCA" 
058b f5				push af  
058c 3a a0 05			ld a, (.dmark)  
058f 32 7a ee			ld (debug_mark),a  
0592 3a a1 05			ld a, (.dmark+1)  
0595 32 7b ee			ld (debug_mark+1),a  
0598 3a a2 05			ld a, (.dmark+2)  
059b 32 7c ee			ld (debug_mark+2),a  
059e 18 03			jr .pastdmark  
05a0 ..			.dmark: db "SCA"  
05a3 f1			.pastdmark: pop af  
05a4			endm  
# End of macro DMARK
05a4					CALLMONITOR 
05a4 cd 8a 11			call break_point_state  
05a7				endm  
# End of macro CALLMONITOR
05a7				endif 
05a7			 
05a7				; write file header page 
05a7			 
05a7 2a 63 eb			ld hl,(store_tmppageid) 
05aa 11 65 eb			ld de, store_page 
05ad				if DEBUG_STORESE 
05ad					DMARK "SCb" 
05ad f5				push af  
05ae 3a c2 05			ld a, (.dmark)  
05b1 32 7a ee			ld (debug_mark),a  
05b4 3a c3 05			ld a, (.dmark+1)  
05b7 32 7b ee			ld (debug_mark+1),a  
05ba 3a c4 05			ld a, (.dmark+2)  
05bd 32 7c ee			ld (debug_mark+2),a  
05c0 18 03			jr .pastdmark  
05c2 ..			.dmark: db "SCb"  
05c5 f1			.pastdmark: pop af  
05c6			endm  
# End of macro DMARK
05c6					;push af 
05c6					;ld a, 'b' 
05c6					;ld (debug_mark),a 
05c6					;pop af 
05c6					CALLMONITOR 
05c6 cd 8a 11			call break_point_state  
05c9				endm  
# End of macro CALLMONITOR
05c9				endif 
05c9 cd fa 01			call storage_write_block 
05cc			 
05cc 3a 5e eb			ld a, (store_tmpid) 
05cf 6f				ld l, a 
05d0 26 00			ld h,0 
05d2				if DEBUG_STORESE 
05d2					DMARK "SCz" 
05d2 f5				push af  
05d3 3a e7 05			ld a, (.dmark)  
05d6 32 7a ee			ld (debug_mark),a  
05d9 3a e8 05			ld a, (.dmark+1)  
05dc 32 7b ee			ld (debug_mark+1),a  
05df 3a e9 05			ld a, (.dmark+2)  
05e2 32 7c ee			ld (debug_mark+2),a  
05e5 18 03			jr .pastdmark  
05e7 ..			.dmark: db "SCz"  
05ea f1			.pastdmark: pop af  
05eb			endm  
# End of macro DMARK
05eb					CALLMONITOR 
05eb cd 8a 11			call break_point_state  
05ee				endm  
# End of macro CALLMONITOR
05ee				endif 
05ee c9				ret 
05ef				 
05ef			 
05ef			 
05ef			; 
05ef			; Read File 
05ef			; 
05ef			; h - file id to locate 
05ef			; l - extent to locate 
05ef			; de - pointer to string to read into 
05ef			; 
05ef			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
05ef			storage_read: 
05ef d5				push de 
05f0			 
05f0			; TODO BUG the above push is it popped before the RET Z? 
05f0			 
05f0			; TODO how to handle multiple part blocks 
05f0			 
05f0				; locate file extent to read 
05f0			 
05f0 5c				ld e, h 
05f1 55				ld d, l 
05f2 21 40 00			ld hl, STORE_BLOCK_PHY 
05f5				if DEBUG_STORESE 
05f5					DMARK "SRE" 
05f5 f5				push af  
05f6 3a 0a 06			ld a, (.dmark)  
05f9 32 7a ee			ld (debug_mark),a  
05fc 3a 0b 06			ld a, (.dmark+1)  
05ff 32 7b ee			ld (debug_mark+1),a  
0602 3a 0c 06			ld a, (.dmark+2)  
0605 32 7c ee			ld (debug_mark+2),a  
0608 18 03			jr .pastdmark  
060a ..			.dmark: db "SRE"  
060d f1			.pastdmark: pop af  
060e			endm  
# End of macro DMARK
060e					CALLMONITOR 
060e cd 8a 11			call break_point_state  
0611				endm  
# End of macro CALLMONITOR
0611				endif 
0611 cd 1f 04			call storage_findnextid 
0614			 
0614				if DEBUG_STORESE 
0614					DMARK "SRf" 
0614 f5				push af  
0615 3a 29 06			ld a, (.dmark)  
0618 32 7a ee			ld (debug_mark),a  
061b 3a 2a 06			ld a, (.dmark+1)  
061e 32 7b ee			ld (debug_mark+1),a  
0621 3a 2b 06			ld a, (.dmark+2)  
0624 32 7c ee			ld (debug_mark+2),a  
0627 18 03			jr .pastdmark  
0629 ..			.dmark: db "SRf"  
062c f1			.pastdmark: pop af  
062d			endm  
# End of macro DMARK
062d					CALLMONITOR 
062d cd 8a 11			call break_point_state  
0630				endm  
# End of macro CALLMONITOR
0630				endif 
0630 cd ef 09			call ishlzero 
0633			;	ld a, l 
0633			;	add h 
0633			;	cp 0 
0633 c8				ret z			; block not found so EOF 
0634			 
0634				; hl contains page number to load 
0634 d1				pop de   ; get storage 
0635 d5				push de 
0636				if DEBUG_STORESE 
0636					DMARK "SRg" 
0636 f5				push af  
0637 3a 4b 06			ld a, (.dmark)  
063a 32 7a ee			ld (debug_mark),a  
063d 3a 4c 06			ld a, (.dmark+1)  
0640 32 7b ee			ld (debug_mark+1),a  
0643 3a 4d 06			ld a, (.dmark+2)  
0646 32 7c ee			ld (debug_mark+2),a  
0649 18 03			jr .pastdmark  
064b ..			.dmark: db "SRg"  
064e f1			.pastdmark: pop af  
064f			endm  
# End of macro DMARK
064f					CALLMONITOR 
064f cd 8a 11			call break_point_state  
0652				endm  
# End of macro CALLMONITOR
0652				endif 
0652 cd b1 01			call storage_read_block 
0655			 
0655			 
0655			; TODO if block has no zeros then need to read next block  
0655			 
0655			 
0655					 
0655 e1				pop hl 		 ; return start of data to show as not EOF 
0656 23				inc hl   ; past file id 
0657 23				inc hl   ; past ext 
0658				if DEBUG_STORESE 
0658					DMARK "SRe" 
0658 f5				push af  
0659 3a 6d 06			ld a, (.dmark)  
065c 32 7a ee			ld (debug_mark),a  
065f 3a 6e 06			ld a, (.dmark+1)  
0662 32 7b ee			ld (debug_mark+1),a  
0665 3a 6f 06			ld a, (.dmark+2)  
0668 32 7c ee			ld (debug_mark+2),a  
066b 18 03			jr .pastdmark  
066d ..			.dmark: db "SRe"  
0670 f1			.pastdmark: pop af  
0671			endm  
# End of macro DMARK
0671					CALLMONITOR 
0671 cd 8a 11			call break_point_state  
0674				endm  
# End of macro CALLMONITOR
0674				endif 
0674 c9					ret 
0675			 
0675			 
0675			 
0675			; 
0675			; Append File 
0675			; 
0675			; hl - file id to locate 
0675			; de - pointer to (multi block) string to write 
0675			 
0675			 
0675			storage_append: 
0675				; hl -  file id to append to 
0675				; de - string to append 
0675			 
0675 d5				push de 
0676				 
0676				if DEBUG_STORESE 
0676					DMARK "AP1" 
0676 f5				push af  
0677 3a 8b 06			ld a, (.dmark)  
067a 32 7a ee			ld (debug_mark),a  
067d 3a 8c 06			ld a, (.dmark+1)  
0680 32 7b ee			ld (debug_mark+1),a  
0683 3a 8d 06			ld a, (.dmark+2)  
0686 32 7c ee			ld (debug_mark+2),a  
0689 18 03			jr .pastdmark  
068b ..			.dmark: db "AP1"  
068e f1			.pastdmark: pop af  
068f			endm  
# End of macro DMARK
068f					CALLMONITOR 
068f cd 8a 11			call break_point_state  
0692				endm  
# End of macro CALLMONITOR
0692				endif 
0692			 
0692 7d				ld a, l 
0693 32 5e eb			ld (store_tmpid), a 
0696			 
0696				; get file header  
0696			 
0696 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0698 3a 5e eb			ld a, (store_tmpid) 
069b 5f				ld e, a 
069c			 
069c 21 40 00				ld hl, STORE_BLOCK_PHY 
069f cd 1f 04				call storage_findnextid 
06a2			 
06a2 22 63 eb			ld (store_tmppageid), hl 
06a5			 
06a5				; TODO handle file id not found 
06a5			 
06a5				if DEBUG_STORESE 
06a5					DMARK "AP2" 
06a5 f5				push af  
06a6 3a ba 06			ld a, (.dmark)  
06a9 32 7a ee			ld (debug_mark),a  
06ac 3a bb 06			ld a, (.dmark+1)  
06af 32 7b ee			ld (debug_mark+1),a  
06b2 3a bc 06			ld a, (.dmark+2)  
06b5 32 7c ee			ld (debug_mark+2),a  
06b8 18 03			jr .pastdmark  
06ba ..			.dmark: db "AP2"  
06bd f1			.pastdmark: pop af  
06be			endm  
# End of macro DMARK
06be					CALLMONITOR 
06be cd 8a 11			call break_point_state  
06c1				endm  
# End of macro CALLMONITOR
06c1				endif 
06c1			 
06c1				; update file extent count 
06c1			 
06c1 11 65 eb			ld de, store_page 
06c4			 
06c4 cd b1 01			call storage_read_block 
06c7			 
06c7				if DEBUG_STORESE 
06c7					DMARK "AP3" 
06c7 f5				push af  
06c8 3a dc 06			ld a, (.dmark)  
06cb 32 7a ee			ld (debug_mark),a  
06ce 3a dd 06			ld a, (.dmark+1)  
06d1 32 7b ee			ld (debug_mark+1),a  
06d4 3a de 06			ld a, (.dmark+2)  
06d7 32 7c ee			ld (debug_mark+2),a  
06da 18 03			jr .pastdmark  
06dc ..			.dmark: db "AP3"  
06df f1			.pastdmark: pop af  
06e0			endm  
# End of macro DMARK
06e0					CALLMONITOR 
06e0 cd 8a 11			call break_point_state  
06e3				endm  
# End of macro CALLMONITOR
06e3				endif 
06e3			;	ld (store_tmppageid), hl 
06e3			 
06e3 3a 67 eb			ld a, (store_page+2) 
06e6 3c				inc a 
06e7 32 67 eb			ld (store_page+2), a 
06ea 32 5d eb			ld (store_tmpext), a 
06ed				 
06ed				if DEBUG_STORESE 
06ed					DMARK "AP3" 
06ed f5				push af  
06ee 3a 02 07			ld a, (.dmark)  
06f1 32 7a ee			ld (debug_mark),a  
06f4 3a 03 07			ld a, (.dmark+1)  
06f7 32 7b ee			ld (debug_mark+1),a  
06fa 3a 04 07			ld a, (.dmark+2)  
06fd 32 7c ee			ld (debug_mark+2),a  
0700 18 03			jr .pastdmark  
0702 ..			.dmark: db "AP3"  
0705 f1			.pastdmark: pop af  
0706			endm  
# End of macro DMARK
0706					CALLMONITOR 
0706 cd 8a 11			call break_point_state  
0709				endm  
# End of macro CALLMONITOR
0709				endif 
0709 2a 63 eb			ld hl, (store_tmppageid) 
070c 11 65 eb			ld de, store_page 
070f cd fa 01			call storage_write_block 
0712			 
0712				; find free block 
0712			 
0712 11 00 00			ld de, 0			 ; file extent to locate 
0715			 
0715 21 40 00				ld hl, STORE_BLOCK_PHY 
0718 cd 1f 04				call storage_findnextid 
071b			 
071b					; TODO handle no space left 
071b					 
071b 22 63 eb				ld (store_tmppageid), hl 
071e			 
071e				if DEBUG_STORESE 
071e					DMARK "AP4" 
071e f5				push af  
071f 3a 33 07			ld a, (.dmark)  
0722 32 7a ee			ld (debug_mark),a  
0725 3a 34 07			ld a, (.dmark+1)  
0728 32 7b ee			ld (debug_mark+1),a  
072b 3a 35 07			ld a, (.dmark+2)  
072e 32 7c ee			ld (debug_mark+2),a  
0731 18 03			jr .pastdmark  
0733 ..			.dmark: db "AP4"  
0736 f1			.pastdmark: pop af  
0737			endm  
# End of macro DMARK
0737					CALLMONITOR 
0737 cd 8a 11			call break_point_state  
073a				endm  
# End of macro CALLMONITOR
073a				endif 
073a					; init the buffer with zeros so we can id if the buffer is full or not 
073a			 
073a e5					push hl 
073b c5					push bc 
073c			 
073c 21 65 eb				ld hl, store_page 
073f 06 40				ld b, STORE_BLOCK_PHY 
0741 3e 00				ld a, 0 
0743 77			.zeroblock:	ld (hl), a 
0744 23					inc hl 
0745 10 fc				djnz .zeroblock 
0747			 
0747 c1					pop bc 
0748 e1					pop hl 
0749			 
0749					; construct block 
0749			 
0749 3a 5e eb				ld a, (store_tmpid) 
074c 32 65 eb				ld (store_page), a   ; file id 
074f 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
0752 32 66 eb				ld (store_page+1), a 
0755			 
0755 e1					pop hl    ; get string to write 
0756 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0758 11 67 eb				ld de, store_page+2 
075b			 
075b				if DEBUG_STORESE 
075b					DMARK "AP5" 
075b f5				push af  
075c 3a 70 07			ld a, (.dmark)  
075f 32 7a ee			ld (debug_mark),a  
0762 3a 71 07			ld a, (.dmark+1)  
0765 32 7b ee			ld (debug_mark+1),a  
0768 3a 72 07			ld a, (.dmark+2)  
076b 32 7c ee			ld (debug_mark+2),a  
076e 18 03			jr .pastdmark  
0770 ..			.dmark: db "AP5"  
0773 f1			.pastdmark: pop af  
0774			endm  
# End of macro DMARK
0774					CALLMONITOR 
0774 cd 8a 11			call break_point_state  
0777				endm  
# End of macro CALLMONITOR
0777				endif 
0777			 
0777			 
0777			 
0777					; fill buffer with data until end of string or full block 
0777			 
0777 7e			.appd:		ld a, (hl) 
0778 12					ld (de), a 
0779 fe 00				cp 0 
077b 28 04				jr z, .appdone 
077d 23					inc hl 
077e 13					inc de 
077f 10 f6				djnz .appd 
0781			 
0781 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0782 f5					push af   		; save last byte dumped 
0783			 
0783			 
0783 2a 63 eb			ld hl, (store_tmppageid) 
0786 11 65 eb			ld de, store_page 
0789				if DEBUG_STORESE 
0789					DMARK "AP6" 
0789 f5				push af  
078a 3a 9e 07			ld a, (.dmark)  
078d 32 7a ee			ld (debug_mark),a  
0790 3a 9f 07			ld a, (.dmark+1)  
0793 32 7b ee			ld (debug_mark+1),a  
0796 3a a0 07			ld a, (.dmark+2)  
0799 32 7c ee			ld (debug_mark+2),a  
079c 18 03			jr .pastdmark  
079e ..			.dmark: db "AP6"  
07a1 f1			.pastdmark: pop af  
07a2			endm  
# End of macro DMARK
07a2					CALLMONITOR 
07a2 cd 8a 11			call break_point_state  
07a5				endm  
# End of macro CALLMONITOR
07a5				endif 
07a5 cd fa 01				call storage_write_block 
07a8			 
07a8			 
07a8				; was that a full block of data written? 
07a8				; any more to write out? 
07a8			 
07a8				; if yes then set vars and jump to start of function again 
07a8			 
07a8 f1					pop af 
07a9 d1					pop de 
07aa			 
07aa fe 00				cp 0		 ; no, string was fully written 
07ac c8					ret z 
07ad			 
07ad					; setup vars for next cycle 
07ad			 
07ad 3a 5e eb				ld a, (store_tmpid) 
07b0 6f					ld l, a 
07b1 26 00				ld h, 0 
07b3			 
07b3 c3 75 06			 	jp storage_append	 ; yes, need to write out some more 
07b6			 
07b6			 
07b6			 
07b6			 
07b6			 
07b6			 
07b6			 
07b6			if DEBUG_STORECF 
07b6			storageput:	 
07b6					ret 
07b6			storageread: 
07b6					ld hl, store_page 
07b6					ld b, 200 
07b6					ld a,0 
07b6			.src:		ld (hl),a 
07b6					inc hl 
07b6					djnz .src 
07b6					 
07b6			 
07b6					ld de, 0 
07b6					ld bc, 1 
07b6					ld hl, store_page 
07b6					call cfRead 
07b6			 
07b6				call cfGetError 
07b6				ld hl,scratch 
07b6				call hexout 
07b6				ld hl, scratch+2 
07b6				ld a, 0 
07b6				ld (hl),a 
07b6				ld de, scratch 
07b6				ld a,display_row_1 
07b6				call str_at_display 
07b6				call update_display 
07b6			 
07b6					ld hl, store_page 
07b6					ld (os_cur_ptr),hl 
07b6			 
07b6					ret 
07b6			endif 
07b6			 
07b6			 
07b6			; Clear out the main buffer store (used to remove junk before writing a new block) 
07b6			 
07b6			storage_clear_page: 
07b6 e5				push hl 
07b7 d5				push de 
07b8 c5				push bc 
07b9 21 65 eb			ld hl, store_page 
07bc 3e 00			ld a, 0 
07be 77				ld (hl), a 
07bf			 
07bf 11 66 eb			ld de, store_page+1 
07c2 01 40 00			ld bc, STORE_BLOCK_PHY 
07c5			 
07c5 ed b0			ldir 
07c7				 
07c7 c1				pop bc 
07c8 d1				pop de 
07c9 e1				pop hl 
07ca c9				ret 
07cb			 
07cb			; eof 
# End of file firmware_storage.asm
07cb			  
07cb			; support routines for above hardware abstraction layer  
07cb			  
07cb			include "firmware_general.asm"        ; general support functions  
07cb			 
07cb			 
07cb			 
07cb			; Delay loops 
07cb			 
07cb			 
07cb			 
07cb			aDelayInMS: 
07cb c5				push bc 
07cc 47				ld b,a 
07cd			msdelay: 
07cd c5				push bc 
07ce				 
07ce			 
07ce 01 41 00			ld bc,041h 
07d1 cd e9 07			call delayloop 
07d4 c1				pop bc 
07d5 05				dec b 
07d6 20 f5			jr nz,msdelay 
07d8			 
07d8			;if CPU_CLOCK_8MHZ 
07d8			;msdelay8: 
07d8			;	push bc 
07d8			;	 
07d8			; 
07d8			;	ld bc,041h 
07d8			;	call delayloop 
07d8			;	pop bc 
07d8			;	dec b 
07d8			;	jr nz,msdelay8 
07d8			;endif 
07d8			 
07d8			 
07d8 c1				pop bc 
07d9 c9				ret 
07da			 
07da			 
07da			delay250ms: 
07da				;push de 
07da 01 00 40			ld bc, 04000h 
07dd c3 e9 07			jp delayloop 
07e0			delay500ms: 
07e0				;push de 
07e0 01 00 80			ld bc, 08000h 
07e3 c3 e9 07			jp delayloop 
07e6			delay1s: 
07e6				;push bc 
07e6			   ; Clobbers A, d and e 
07e6 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
07e9			delayloop: 
07e9 c5			    push bc 
07ea			 
07ea			if BASE_CPM 
07ea 01 a0 0f			ld bc, CPM_DELAY_TUNE 
07ed			.cpmloop: 
07ed c5				push bc 
07ee			 
07ee			endif 
07ee			 
07ee			 
07ee			 
07ee			delayloopi: 
07ee			;	push bc 
07ee			;.dl: 
07ee cb 47		    bit     0,a    	; 8 
07f0 cb 47		    bit     0,a    	; 8 
07f2 cb 47		    bit     0,a    	; 8 
07f4 e6 ff		    and     255  	; 7 
07f6 0b			    dec     bc      	; 6 
07f7 79			    ld      a,c     	; 4 
07f8 b0			    or      b     	; 4 
07f9 c2 ee 07		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
07fc			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
07fc				;pop de 
07fc			;pop bc 
07fc			 
07fc			if BASE_CPM 
07fc c1				pop bc 
07fd				 
07fd 0b			    dec     bc      	; 6 
07fe 79			    ld      a,c     	; 4 
07ff b0			    or      b     	; 4 
0800 c2 ed 07		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0803				 
0803			 
0803			endif 
0803			;if CPU_CLOCK_8MHZ 
0803			;    pop bc 
0803			;    push bc 
0803			;.dl8: 
0803			;    bit     0,a    	; 8 
0803			;    bit     0,a    	; 8 
0803			;    bit     0,a    	; 8 
0803			;    and     255  	; 7 
0803			;    dec     bc      	; 6 
0803			;    ld      a,c     	; 4 
0803			;    or      b     	; 4 
0803			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0803			;endif 
0803			 
0803			;if CPU_CLOCK_10MHZ 
0803			;    pop bc 
0803			;    push bc 
0803			;.dl8: 
0803			;    bit     0,a    	; 8 
0803			;    bit     0,a    	; 8 
0803			;    bit     0,a    	; 8 
0803			;    and     255  	; 7 
0803			;    dec     bc      	; 6 
0803			;    ld      a,c     	; 4 
0803			;    or      b     	; 4 
0803			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0803			;endif 
0803 c1			    pop bc 
0804			 
0804 c9				ret 
0805			 
0805			 
0805			 
0805			; eof 
# End of file firmware_general.asm
0805			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0805			; display routines that use the physical hardware abstraction layer 
0805			 
0805			 
0805			; TODO windowing? 
0805			 
0805			; TODO scroll line up 
0805			 
0805			scroll_up: 
0805			 
0805 e5				push hl 
0806 d5				push de 
0807 c5				push bc 
0808			 
0808				; get frame buffer  
0808			 
0808 2a db eb			ld hl, (display_fb_active) 
080b e5				push hl    ; future de destination 
080c			 
080c 11 28 00			ld  de, display_cols 
080f 19				add hl, de 
0810			 
0810 d1				pop de 
0811			 
0811				;ex de, hl 
0811 01 9f 00			ld bc, display_fb_len -1  
0814			;if DEBUG_FORTH_WORDS 
0814			;	DMARK "SCL" 
0814			;	CALLMONITOR 
0814			;endif	 
0814 ed b0			ldir 
0816			 
0816				; wipe bottom row 
0816			 
0816			 
0816 2a db eb			ld hl, (display_fb_active) 
0819 11 a0 00			ld de, display_cols*display_rows 
081c 19				add hl, de 
081d 06 28			ld b, display_cols 
081f 3e 20			ld a, ' ' 
0821			.scwipe: 
0821 77				ld (hl), a 
0822 2b				dec hl 
0823 10 fc			djnz .scwipe 
0825			 
0825				;pop hl 
0825			 
0825 c1				pop bc 
0826 d1				pop de 
0827 e1				pop hl 
0828			 
0828 c9				ret 
0829			 
0829			 
0829			scroll_upo: 
0829 11 00 00			ld de, display_row_1 
082c 21 28 00		 	ld hl, display_row_2 
082f 01 28 00			ld bc, display_cols 
0832 ed b0			ldir 
0834 11 28 00			ld de, display_row_2 
0837 21 50 00		 	ld hl, display_row_3 
083a 01 28 00			ld bc, display_cols 
083d ed b0			ldir 
083f 11 50 00			ld de, display_row_3 
0842 21 78 00		 	ld hl, display_row_4 
0845 01 28 00			ld bc, display_cols 
0848 ed b0			ldir 
084a			 
084a			; TODO clear row 4 
084a			 
084a c9				ret 
084b				 
084b			scroll_down: 
084b 11 78 00			ld de, display_row_4 
084e 21 50 00		 	ld hl, display_row_3 
0851 01 28 00			ld bc, display_cols 
0854 ed b0			ldir 
0856 11 50 00			ld de, display_row_3 
0859 21 28 00		 	ld hl, display_row_2 
085c 01 28 00			ld bc, display_cols 
085f ed b0			ldir 
0861 11 28 00			ld de, display_row_2 
0864 21 00 00		 	ld hl, display_row_1 
0867 01 28 00			ld bc, display_cols 
086a ed b0			ldir 
086c			; TODO clear row 1 
086c c9				ret 
086d			 
086d			 
086d			 
086d			 
086d			 
086d			; clear active frame buffer 
086d			 
086d			clear_display: 
086d 3e 20			ld a, ' ' 
086f c3 72 08			jp fill_display 
0872			 
0872			; fill active frame buffer with a char in A 
0872			 
0872			fill_display: 
0872 06 a0			ld b,display_fb_len 
0874 2a db eb			ld hl, (display_fb_active) 
0877 77			.fd1:	ld (hl),a 
0878 23				inc hl 
0879 10 fc			djnz .fd1 
087b 23				inc hl 
087c 3e 00			ld a,0 
087e 77				ld (hl),a 
087f			 
087f			 
087f c9				ret 
0880			; Write string (DE) at pos (A) to active frame buffer 
0880			 
0880 2a db eb		str_at_display:    ld hl,(display_fb_active) 
0883 06 00					ld b,0 
0885 4f					ld c,a 
0886 09					add hl,bc 
0887 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0888 b7			            OR   A              ;Null terminator? 
0889 c8			            RET  Z              ;Yes, so finished 
088a 77					ld (hl),a 
088b 23				inc hl 
088c 13			            INC  DE             ;Point to next character 
088d 18 f8		            JR   .sad1     ;Repeat 
088f c9					ret 
0890			 
0890			; using current frame buffer write to physical display 
0890			 
0890			update_display: 
0890 e5				push hl 
0891 2a db eb			ld hl, (display_fb_active) 
0894 cd f2 46			call write_display 
0897 e1				pop hl 
0898 c9				ret 
0899			 
0899			; TODO scrolling 
0899			 
0899			 
0899			; move cursor right one char 
0899			cursor_right: 
0899			 
0899				; TODO shift right 
0899				; TODO if beyond max col 
0899				; TODO       cursor_next_line 
0899			 
0899 c9				ret 
089a			 
089a			 
089a			cursor_next_line: 
089a				; TODO first char 
089a				; TODO line down 
089a				; TODO if past last row 
089a				; TODO    scroll up 
089a			 
089a c9				ret 
089b			 
089b			cursor_left: 
089b				; TODO shift left 
089b				; TODO if beyond left  
089b				; TODO     cursor prev line 
089b				 
089b c9				ret 
089c			 
089c			cursor_prev_line: 
089c				; TODO last char 
089c				; TODO line up 
089c				; TODO if past first row 
089c				; TODO   scroll down 
089c			 
089c c9				ret 
089d			 
089d			 
089d			cout: 
089d				; A - char 
089d c9				ret 
089e			 
089e			; eof 
089e			 
# End of file firmware_display.asm
089e			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
089e			; random number generators 
089e			 
089e			 
089e			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
089e			 
089e			 
089e			;-----> Generate a random number 
089e			; output a=answer 0<=a<=255 
089e			; all registers are preserved except: af 
089e			random: 
089e e5			        push    hl 
089f d5			        push    de 
08a0 2a bd eb		        ld      hl,(randData) 
08a3 ed 5f		        ld      a,r 
08a5 57			        ld      d,a 
08a6 5e			        ld      e,(hl) 
08a7 19			        add     hl,de 
08a8 85			        add     a,l 
08a9 ac			        xor     h 
08aa 22 bd eb		        ld      (randData),hl 
08ad d1			        pop     de 
08ae e1			        pop     hl 
08af c9			        ret 
08b0			 
08b0			 
08b0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
08b0			 
08b0			 
08b0			 
08b0			;------LFSR------ 
08b0			;James Montelongo 
08b0			;optimized by Spencer Putt 
08b0			;out: 
08b0			; a = 8 bit random number 
08b0			RandLFSR: 
08b0 21 c3 eb		        ld hl,LFSRSeed+4 
08b3 5e			        ld e,(hl) 
08b4 23			        inc hl 
08b5 56			        ld d,(hl) 
08b6 23			        inc hl 
08b7 4e			        ld c,(hl) 
08b8 23			        inc hl 
08b9 7e			        ld a,(hl) 
08ba 47			        ld b,a 
08bb cb 13		        rl e  
08bd cb 12			rl d 
08bf cb 11		        rl c  
08c1 17				rla 
08c2 cb 13		        rl e  
08c4 cb 12			rl d 
08c6 cb 11		        rl c  
08c8 17				rla 
08c9 cb 13		        rl e  
08cb cb 12			rl d 
08cd cb 11		        rl c  
08cf 17				rla 
08d0 67			        ld h,a 
08d1 cb 13		        rl e  
08d3 cb 12			rl d 
08d5 cb 11		        rl c  
08d7 17				rla 
08d8 a8			        xor b 
08d9 cb 13		        rl e  
08db cb 12			rl d 
08dd ac			        xor h 
08de a9			        xor c 
08df aa			        xor d 
08e0 21 c5 eb		        ld hl,LFSRSeed+6 
08e3 11 c6 eb		        ld de,LFSRSeed+7 
08e6 01 07 00		        ld bc,7 
08e9 ed b8		        lddr 
08eb 12			        ld (de),a 
08ec c9			        ret 
08ed			 
08ed			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
08ed			 
08ed			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
08ed			 
08ed			 
08ed			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
08ed			 
08ed			prng16: 
08ed			;Inputs: 
08ed			;   (seed1) contains a 16-bit seed value 
08ed			;   (seed2) contains a NON-ZERO 16-bit seed value 
08ed			;Outputs: 
08ed			;   HL is the result 
08ed			;   BC is the result of the LCG, so not that great of quality 
08ed			;   DE is preserved 
08ed			;Destroys: 
08ed			;   AF 
08ed			;cycle: 4,294,901,760 (almost 4.3 billion) 
08ed			;160cc 
08ed			;26 bytes 
08ed 2a b7 eb		    ld hl,(seed1) 
08f0 44			    ld b,h 
08f1 4d			    ld c,l 
08f2 29			    add hl,hl 
08f3 29			    add hl,hl 
08f4 2c			    inc l 
08f5 09			    add hl,bc 
08f6 22 b7 eb		    ld (seed1),hl 
08f9 2a b5 eb		    ld hl,(seed2) 
08fc 29			    add hl,hl 
08fd 9f			    sbc a,a 
08fe e6 2d		    and %00101101 
0900 ad			    xor l 
0901 6f			    ld l,a 
0902 22 b5 eb		    ld (seed2),hl 
0905 09			    add hl,bc 
0906 c9			    ret 
0907			 
0907			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0907			 
0907			rand32: 
0907			;Inputs: 
0907			;   (seed1_0) holds the lower 16 bits of the first seed 
0907			;   (seed1_1) holds the upper 16 bits of the first seed 
0907			;   (seed2_0) holds the lower 16 bits of the second seed 
0907			;   (seed2_1) holds the upper 16 bits of the second seed 
0907			;   **NOTE: seed2 must be non-zero 
0907			;Outputs: 
0907			;   HL is the result 
0907			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0907			;Destroys: 
0907			;   AF 
0907			;Tested and passes all CAcert tests 
0907			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0907			;it has a period of 18,446,744,069,414,584,320 
0907			;roughly 18.4 quintillion. 
0907			;LFSR taps: 0,2,6,7  = 11000101 
0907			;291cc 
0907			;seed1_0=$+1 
0907			;    ld hl,12345 
0907			;seed1_1=$+1 
0907			;    ld de,6789 
0907			;    ld b,h 
0907			;    ld c,l 
0907			;    add hl,hl \ rl e \ rl d 
0907			;    add hl,hl \ rl e \ rl d 
0907			;    inc l 
0907			;    add hl,bc 
0907			;    ld (seed1_0),hl 
0907			;    ld hl,(seed1_1) 
0907			;    adc hl,de 
0907			;    ld (seed1_1),hl 
0907			;    ex de,hl 
0907			;seed2_0=$+1 
0907			;    ld hl,9876 
0907			;seed2_1=$+1 
0907			;    ld bc,54321 
0907			;    add hl,hl \ rl c \ rl b 
0907			;    ld (seed2_1),bc 
0907			;    sbc a,a 
0907			;    and %11000101 
0907			;    xor l 
0907			;    ld l,a 
0907			;    ld (seed2_0),hl 
0907			;    ex de,hl 
0907			;    add hl,bc 
0907			;    ret 
0907			; 
0907			 
0907			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0907			; 20 bytes, 86 cycles (excluding ret) 
0907			 
0907			; returns   hl = pseudorandom number 
0907			; corrupts   a 
0907			 
0907			; generates 16-bit pseudorandom numbers with a period of 65535 
0907			; using the xorshift method: 
0907			 
0907			; hl ^= hl << 7 
0907			; hl ^= hl >> 9 
0907			; hl ^= hl << 8 
0907			 
0907			; some alternative shift triplets which also perform well are: 
0907			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0907			 
0907			;  org 32768 
0907			 
0907			xrnd: 
0907 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
090a 3e 00		  ld a,0 
090c bd			  cp l 
090d 20 02		  jr nz, .xrnd1 
090f 2e 01		  ld l, 1 
0911			.xrnd1: 
0911			 
0911 7c			  ld a,h 
0912 1f			  rra 
0913 7d			  ld a,l 
0914 1f			  rra 
0915 ac			  xor h 
0916 67			  ld h,a 
0917 7d			  ld a,l 
0918 1f			  rra 
0919 7c			  ld a,h 
091a 1f			  rra 
091b ad			  xor l 
091c 6f			  ld l,a 
091d ac			  xor h 
091e 67			  ld h,a 
091f			 
091f 22 bb eb		  ld (xrandc),hl 
0922			 
0922 c9			  ret 
0923			;  
0923			 
0923			 
0923			;;;; int maths 
0923			 
0923			; https://map.grauw.nl/articles/mult_div_shifts.php 
0923			; Divide 16-bit values (with 16-bit result) 
0923			; In: Divide BC by divider DE 
0923			; Out: BC = result, HL = rest 
0923			; 
0923			Div16: 
0923 21 00 00		    ld hl,0 
0926 78			    ld a,b 
0927 06 08		    ld b,8 
0929			Div16_Loop1: 
0929 17			    rla 
092a ed 6a		    adc hl,hl 
092c ed 52		    sbc hl,de 
092e 30 01		    jr nc,Div16_NoAdd1 
0930 19			    add hl,de 
0931			Div16_NoAdd1: 
0931 10 f6		    djnz Div16_Loop1 
0933 17			    rla 
0934 2f			    cpl 
0935 47			    ld b,a 
0936 79			    ld a,c 
0937 48			    ld c,b 
0938 06 08		    ld b,8 
093a			Div16_Loop2: 
093a 17			    rla 
093b ed 6a		    adc hl,hl 
093d ed 52		    sbc hl,de 
093f 30 01		    jr nc,Div16_NoAdd2 
0941 19			    add hl,de 
0942			Div16_NoAdd2: 
0942 10 f6		    djnz Div16_Loop2 
0944 17			    rla 
0945 2f			    cpl 
0946 41			    ld b,c 
0947 4f			    ld c,a 
0948 c9			ret 
0949			 
0949			 
0949			;http://z80-heaven.wikidot.com/math 
0949			; 
0949			;Inputs: 
0949			;     DE and A are factors 
0949			;Outputs: 
0949			;     A is not changed 
0949			;     B is 0 
0949			;     C is not changed 
0949			;     DE is not changed 
0949			;     HL is the product 
0949			;Time: 
0949			;     342+6x 
0949			; 
0949			Mult16: 
0949			 
0949 06 08		     ld b,8          ;7           7 
094b 21 00 00		     ld hl,0         ;10         10 
094e 29			       add hl,hl     ;11*8       88 
094f 07			       rlca          ;4*8        32 
0950 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0952 19			         add hl,de   ;--         -- 
0953 10 f9		       djnz $-5      ;13*7+8     99 
0955 c9			ret 
0956			 
0956			; 
0956			; Square root of 16-bit value 
0956			; In:  HL = value 
0956			; Out:  D = result (rounded down) 
0956			; 
0956			;Sqr16: 
0956			;    ld de,#0040 
0956			;    ld a,l 
0956			;    ld l,h 
0956			;    ld h,d 
0956			;    or a 
0956			;    ld b,8 
0956			;Sqr16_Loop: 
0956			;    sbc hl,de 
0956			;    jr nc,Sqr16_Skip 
0956			;    add hl,de 
0956			;Sqr16_Skip: 
0956			;    ccf 
0956			;    rl d 
0956			;    add a,a 
0956			;    adc hl,hl 
0956			;    add a,a 
0956			;    adc hl,hl 
0956			;    djnz Sqr16_Loop 
0956			;    ret 
0956			; 
0956			; 
0956			; Divide 8-bit values 
0956			; In: Divide E by divider C 
0956			; Out: A = result, B = rest 
0956			; 
0956			Div8: 
0956 af			    xor a 
0957 06 08		    ld b,8 
0959			Div8_Loop: 
0959 cb 13		    rl e 
095b 17			    rla 
095c 91			    sub c 
095d 30 01		    jr nc,Div8_NoAdd 
095f 81			    add a,c 
0960			Div8_NoAdd: 
0960 10 f7		    djnz Div8_Loop 
0962 47			    ld b,a 
0963 7b			    ld a,e 
0964 17			    rla 
0965 2f			    cpl 
0966 c9			    ret 
0967			 
0967			; 
0967			; Multiply 8-bit value with a 16-bit value (unrolled) 
0967			; In: Multiply A with DE 
0967			; Out: HL = result 
0967			; 
0967			Mult12U: 
0967 2e 00		    ld l,0 
0969 87			    add a,a 
096a 30 01		    jr nc,Mult12U_NoAdd0 
096c 19			    add hl,de 
096d			Mult12U_NoAdd0: 
096d 29			    add hl,hl 
096e 87			    add a,a 
096f 30 01		    jr nc,Mult12U_NoAdd1 
0971 19			    add hl,de 
0972			Mult12U_NoAdd1: 
0972 29			    add hl,hl 
0973 87			    add a,a 
0974 30 01		    jr nc,Mult12U_NoAdd2 
0976 19			    add hl,de 
0977			Mult12U_NoAdd2: 
0977 29			    add hl,hl 
0978 87			    add a,a 
0979 30 01		    jr nc,Mult12U_NoAdd3 
097b 19			    add hl,de 
097c			Mult12U_NoAdd3: 
097c 29			    add hl,hl 
097d 87			    add a,a 
097e 30 01		    jr nc,Mult12U_NoAdd4 
0980 19			    add hl,de 
0981			Mult12U_NoAdd4: 
0981 29			    add hl,hl 
0982 87			    add a,a 
0983 30 01		    jr nc,Mult12U_NoAdd5 
0985 19			    add hl,de 
0986			Mult12U_NoAdd5: 
0986 29			    add hl,hl 
0987 87			    add a,a 
0988 30 01		    jr nc,Mult12U_NoAdd6 
098a 19			    add hl,de 
098b			Mult12U_NoAdd6: 
098b 29			    add hl,hl 
098c 87			    add a,a 
098d d0			    ret nc 
098e 19			    add hl,de 
098f c9			    ret 
0990			 
0990			; 
0990			; Multiply 8-bit value with a 16-bit value (right rotating) 
0990			; In: Multiply A with DE 
0990			;      Put lowest value in A for most efficient calculation 
0990			; Out: HL = result 
0990			; 
0990			Mult12R: 
0990 21 00 00		    ld hl,0 
0993			Mult12R_Loop: 
0993 cb 3f		    srl a 
0995 30 01		    jr nc,Mult12R_NoAdd 
0997 19			    add hl,de 
0998			Mult12R_NoAdd: 
0998 cb 23		    sla e 
099a cb 12		    rl d 
099c b7			    or a 
099d c2 93 09		    jp nz,Mult12R_Loop 
09a0 c9			    ret 
09a1			 
09a1			; 
09a1			; Multiply 16-bit values (with 32-bit result) 
09a1			; In: Multiply BC with DE 
09a1			; Out: BCHL = result 
09a1			; 
09a1			Mult32: 
09a1 79			    ld a,c 
09a2 48			    ld c,b 
09a3 21 00 00		    ld hl,0 
09a6 06 10		    ld b,16 
09a8			Mult32_Loop: 
09a8 29			    add hl,hl 
09a9 17			    rla 
09aa cb 11		    rl c 
09ac 30 07		    jr nc,Mult32_NoAdd 
09ae 19			    add hl,de 
09af ce 00		    adc a,0 
09b1 d2 b5 09		    jp nc,Mult32_NoAdd 
09b4 0c			    inc c 
09b5			Mult32_NoAdd: 
09b5 10 f1		    djnz Mult32_Loop 
09b7 41			    ld b,c 
09b8 4f			    ld c,a 
09b9 c9			    ret 
09ba			 
09ba			 
09ba			 
09ba			; 
09ba			; Multiply 8-bit values 
09ba			; In:  Multiply H with E 
09ba			; Out: HL = result 
09ba			; 
09ba			Mult8: 
09ba 16 00		    ld d,0 
09bc 6a			    ld l,d 
09bd 06 08		    ld b,8 
09bf			Mult8_Loop: 
09bf 29			    add hl,hl 
09c0 30 01		    jr nc,Mult8_NoAdd 
09c2 19			    add hl,de 
09c3			Mult8_NoAdd: 
09c3 10 fa		    djnz Mult8_Loop 
09c5 c9			    ret 
09c6			 
09c6			 
09c6			 
09c6			 
09c6			 
09c6			 
09c6			 
09c6			 
09c6			;;http://z80-heaven.wikidot.com/math 
09c6			;;This divides DE by BC, storing the result in DE, remainder in HL 
09c6			; 
09c6			;DE_Div_BC:          ;1281-2x, x is at most 16 
09c6			;     ld a,16        ;7 
09c6			;     ld hl,0        ;10 
09c6			;     jp $+5         ;10 
09c6			;.DivLoop: 
09c6			;       add hl,bc    ;-- 
09c6			;       dec a        ;64 
09c6			;       jr z,.DivLoopEnd        ;86 
09c6			; 
09c6			;       sla e        ;128 
09c6			;       rl d         ;128 
09c6			;       adc hl,hl    ;240 
09c6			;       sbc hl,bc    ;240 
09c6			;       jr nc,.DivLoop ;23|21 
09c6			;       inc e        ;-- 
09c6			;       jp .DivLoop+1 
09c6			; 
09c6			;.DivLoopEnd: 
09c6			 
09c6			;HL_Div_C: 
09c6			;Inputs: 
09c6			;     HL is the numerator 
09c6			;     C is the denominator 
09c6			;Outputs: 
09c6			;     A is the remainder 
09c6			;     B is 0 
09c6			;     C is not changed 
09c6			;     DE is not changed 
09c6			;     HL is the quotient 
09c6			; 
09c6			;       ld b,16 
09c6			;       xor a 
09c6			;         add hl,hl 
09c6			;         rla 
09c6			;         cp c 
09c6			;         jr c,$+4 
09c6			;           inc l 
09c6			;           sub c 
09c6			;         djnz $-7 
09c6			 
09c6			; https://plutiedev.com/z80-add-8bit-to-16bit 
09c6			 
09c6			addatohl: 
09c6 85			    add   a, l    ; A = A+L 
09c7 6f			    ld    l, a    ; L = A+L 
09c8 8c			    adc   a, h    ; A = A+L+H+carry 
09c9 95			    sub   l       ; A = H+carry 
09ca 67			    ld    h, a    ; H = H+carry 
09cb c9			ret 
09cc			 
09cc			addatode: 
09cc 83			    add   a, e    ; A = A+L 
09cd 5f			    ld    e, a    ; L = A+L 
09ce 8a			    adc   a, d    ; A = A+L+H+carry 
09cf 93			    sub   e       ; A = H+carry 
09d0 57			    ld    d, a    ; H = H+carry 
09d1 c9			ret 
09d2			 
09d2			 
09d2			addatobc: 
09d2 81			    add   a, c    ; A = A+L 
09d3 4f			    ld    c, a    ; L = A+L 
09d4 88			    adc   a, b    ; A = A+L+H+carry 
09d5 91			    sub   c       ; A = H+carry 
09d6 47			    ld    b, a    ; H = H+carry 
09d7 c9			ret 
09d8			 
09d8			subafromhl: 
09d8			   ; If A=0 do nothing 
09d8			    ; Otherwise flip A's sign. Since 
09d8			    ; the upper byte becomes -1, also 
09d8			    ; substract 1 from H. 
09d8 ed 44		    neg 
09da ca e3 09		    jp    z, Skip 
09dd 25			    dec   h 
09de			     
09de			    ; Now add the low byte as usual 
09de			    ; Two's complement takes care of 
09de			    ; ensuring the result is correct 
09de 85			    add   a, l 
09df 6f			    ld    l, a 
09e0 8c			    adc   a, h 
09e1 95			    sub   l 
09e2 67			    ld    h, a 
09e3			Skip: 
09e3 c9				ret 
09e4			 
09e4			 
09e4			; compare hl and de 
09e4			; returns:  
09e4			; if hl = de, z=1, s=0, c0=0 
09e4			; if hl > de, z=0, s=0, c=0 
09e4			; if hl < de, z=0, s=1, c=1 
09e4			cmp16:	 
09e4 b7				or a 
09e5 ed 52			sbc hl,de 
09e7 e0				ret po 
09e8 7c				ld a,h 
09e9 1f				rra 
09ea ee 40			xor 01000000B 
09ec 37				scf 
09ed 8f				adc a,a 
09ee c9				ret 
09ef			 
09ef			 
09ef			; test if hl contains zero   - A is destroyed 
09ef			 
09ef			ishlzero:    
09ef b7				or a     ; reset flags 
09f0 7c				ld a, h 
09f1 b5				or l        	 
09f2			 
09f2 c9				ret 
09f3			 
09f3			 
09f3			 
09f3			 
09f3			if FORTH_ENABLE_FLOATMATH 
09f3			include "float/bbcmath.z80" 
09f3			endif 
09f3			 
09f3			 
09f3			; eof 
09f3			 
# End of file firmware_maths.asm
09f3			include "firmware_strings.asm"   ; string handling  
09f3			 
09f3			 
09f3			; TODO string len 
09f3			; input text string, end on cr with zero term 
09f3			; a offset into frame buffer to start prompt 
09f3			; d is max length 
09f3			; e is display size TODO 
09f3			; c is current cursor position 
09f3			; hl is ptr to where string will be stored 
09f3			 
09f3			 
09f3			; TODO check limit of buffer for new inserts 
09f3			; TODO check insert does not push beyond buffer 
09f3			; TODO scroll in a limited display area 
09f3			; TODO scroll whole screen on page wrap 
09f3			 
09f3			 
09f3			; TODO handle KEY_PREVWORD 
09f3			; TODO handle KEY_NEXTWORD 
09f3			; TODO handle KEY_HOME 
09f3			; TODO handle KEY_END 
09f3			; TODO use LCD cursor? 
09f3			 
09f3 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
09f6 81					add c 
09f7 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
09fa 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
09fd 79					ld a, c 
09fe cd c6 09				call addatohl 
0a01 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0a04 7a					ld a,d 
0a05 32 75 ee			        ld (input_size), a       ; save length of input area 
0a08 79					ld a, c 
0a09 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0a0c 7b					ld a,e 
0a0d 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0a10					 
0a10					 
0a10			 
0a10			;		ld a,(input_ptr) 
0a10			;		ld (input_under_cursor),a 	; save what is under the cursor 
0a10			 
0a10			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0a10					; init cursor shape if not set by the cin routines 
0a10 21 d3 eb				ld hl, cursor_shape 
0a13 3e ff				ld a, 255 
0a15 77					ld (hl), a 
0a16 23					inc hl 
0a17 3e 00				ld a, 0 
0a19 77					ld (hl), a 
0a1a			 
0a1a 3e 0f				ld a, CUR_BLINK_RATE 
0a1c 32 6f ee				ld (input_cur_flash), a 
0a1f 3e 01				ld a, 1 
0a21 32 6e ee				ld (input_cur_onoff),a 
0a24			 
0a24			;	if DEBUG_INPUT 
0a24			;		push af 
0a24			;		ld a, 'I' 
0a24			;		ld (debug_mark),a 
0a24			;		pop af 
0a24			;		CALLMONITOR 
0a24			;	endif 
0a24			.is1:		; main entry loop 
0a24			 
0a24			 
0a24			 
0a24					; pause 1ms 
0a24			 
0a24 3e 01				ld a, 1 
0a26 cd cb 07				call aDelayInMS 
0a29			 
0a29					; dec flash counter 
0a29 3a 6f ee				ld a, (input_cur_flash) 
0a2c 3d					dec a 
0a2d 32 6f ee				ld (input_cur_flash), a 
0a30 fe 00				cp 0 
0a32 20 0d				jr nz, .nochgstate 
0a34			 
0a34			 
0a34					; change state 
0a34 3a 6e ee				ld a,(input_cur_onoff) 
0a37 ed 44				neg 
0a39 32 6e ee				ld (input_cur_onoff),a 
0a3c			 
0a3c			 
0a3c					; reset on change of state 
0a3c 3e 0f				ld a, CUR_BLINK_RATE 
0a3e 32 6f ee				ld (input_cur_flash), a 
0a41			 
0a41			.nochgstate: 
0a41					 
0a41					 
0a41			 
0a41					; display cursor  
0a41			 
0a41			;		ld hl, (input_start) 
0a41			;		ld a, (input_cursor) 
0a41			;		call addatohl 
0a41			 
0a41					; get char under cursor and replace with cursor 
0a41 2a 78 ee		ld hl, (input_ptr) 
0a44			;		ld a, (hl) 
0a44			;		ld (input_under_cursor),a 
0a44			;		ld a, '_' 
0a44			;		ld (hl), a 
0a44			 
0a44					; display string 
0a44			 
0a44 ed 5b 76 ee			ld de, (input_start) 
0a48 3a 73 ee				ld a, (input_at_pos) 
0a4b cd 80 08				call str_at_display 
0a4e			;	        call update_display 
0a4e			 
0a4e					; find place to put the cursor 
0a4e			;		add h 
0a4e			;		ld l, display_row_1 
0a4e			;		sub l 
0a4e			; (input_at_pos) 
0a4e					;ld c, a 
0a4e			;		ld a, (input_cursor) 
0a4e			;		ld l, (input_at_pos) 
0a4e			;		;ld b, h 
0a4e			;		add l 
0a4e			;		ld (input_at_cursor),a 
0a4e					;ld l,h 
0a4e			 
0a4e			;		ld h, 0 
0a4e			;		ld l,(input_at_pos) 
0a4e			;		ld a, (input_cursor) 
0a4e			;		call addatohl 
0a4e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0a4e			;		call subafromhl 
0a4e			;		ld a,l 
0a4e			;		ld (input_at_cursor), a 
0a4e			 
0a4e				if DEBUG_INPUT 
0a4e					ld a, (hardware_diag) 
0a4e					cp 0 
0a4e					jr z, .skip_input_diag 
0a4e			 
0a4e					ld a,(input_at_pos) 
0a4e					ld hl, LFSRSeed 
0a4e					call hexout 
0a4e					ld a, (input_cursor) 
0a4e					ld hl, LFSRSeed+2 
0a4e					call hexout 
0a4e					ld a,(input_at_cursor) 
0a4e					ld hl, LFSRSeed+4 
0a4e					call hexout 
0a4e			 
0a4e					ld a,(input_cur_onoff) 
0a4e					ld hl, LFSRSeed+6 
0a4e					call hexout 
0a4e			 
0a4e					ld a,(input_cur_flash) 
0a4e					ld hl, LFSRSeed+8 
0a4e					call hexout 
0a4e			 
0a4e					ld a,(input_len) 
0a4e					ld hl, LFSRSeed+10 
0a4e					call hexout 
0a4e					ld hl, LFSRSeed+12 
0a4e					ld a, 0 
0a4e					ld (hl),a 
0a4e					ld a, display_row_4 
0a4e					ld de, LFSRSeed 
0a4e					call str_at_display 
0a4e					.skip_input_diag: 
0a4e				endif 
0a4e			 
0a4e					; decide on if we are showing the cursor this time round 
0a4e			 
0a4e 3a 6e ee				ld a, (input_cur_onoff) 
0a51 fe ff				cp 255 
0a53 28 13				jr z, .skipcur 
0a55			 
0a55			 
0a55 3a 71 ee				ld a,(input_at_cursor) 
0a58 11 d3 eb				ld de, cursor_shape 
0a5b cd 80 08				call str_at_display 
0a5e			 
0a5e					; save length of current input string 
0a5e 2a 76 ee				ld hl, (input_start) 
0a61 cd 24 0e				call strlenz 
0a64 7d					ld a,l 
0a65 32 69 ee				ld (input_len),a 
0a68			 
0a68			.skipcur: 
0a68			 
0a68 cd 90 08			        call update_display 
0a6b					 
0a6b			 
0a6b			 
0a6b					; wait 
0a6b				 
0a6b					; TODO loop without wait to flash the cursor and char under cursor	 
0a6b cd ac 47				call cin    ; _wait 
0a6e			 
0a6e fe 00				cp 0 
0a70 ca 24 0a				jp z, .is1 
0a73			 
0a73					; get ptr to char to input into 
0a73			 
0a73 4f					ld c,a 
0a74 2a 76 ee				ld hl, (input_start) 
0a77 3a 64 ee				ld a, (input_cursor) 
0a7a cd c6 09				call addatohl 
0a7d 22 78 ee				ld (input_ptr), hl 
0a80 79					ld a,c 
0a81			 
0a81					; replace char under cursor 
0a81			 
0a81			;		ld hl, (input_ptr) 
0a81			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0a81			;		ld (hl), a 
0a81			 
0a81			;	if DEBUG_INPUT 
0a81			;		push af 
0a81			;		ld a, 'i' 
0a81			;		ld (debug_mark),a 
0a81			;		pop af 
0a81			;		CALLMONITOR 
0a81			;	endif 
0a81 fe 0e				cp KEY_HOME 
0a83 20 0e				jr nz, .iske 
0a85			 
0a85 3a 73 ee				ld a, (input_at_pos) 
0a88 32 71 ee				ld (input_at_cursor),a 
0a8b 3e 00				ld a, 0 
0a8d 32 64 ee				ld (input_cursor), a 
0a90 c3 24 0a				jp .is1 
0a93					 
0a93 fe 0f		.iske:		cp KEY_END 
0a95 20 03				jr nz, .isknw 
0a97 c3 24 0a				jp .is1 
0a9a			 
0a9a fe 06		.isknw:		cp KEY_NEXTWORD 
0a9c 20 1b				jr nz, .iskpw 
0a9e			 
0a9e 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0aa1 7e					ld a,(hl)	 
0aa2 fe 00				cp 0 
0aa4 ca 24 0a				jp z, .is1    ; end of string 
0aa7 fe 20				cp ' ' 
0aa9 ca 24 0a				jp z, .is1    ; end of word 
0aac 23					inc hl 
0aad 22 78 ee				ld (input_ptr), hl 
0ab0 3a 71 ee				ld a, (input_at_cursor) 
0ab3 3c					inc a 
0ab4 32 71 ee				ld (input_at_cursor), a 
0ab7 18 e5				jr .isknwm 
0ab9			 
0ab9 fe 07		.iskpw:		cp KEY_PREVWORD 
0abb 20 1b				jr nz, .iskl 
0abd			.iskpwm:	 
0abd 2a 78 ee				ld hl, (input_ptr) 
0ac0 7e					ld a,(hl)	 
0ac1 fe 00				cp 0  
0ac3 ca 24 0a				jp z, .is1    ; end of string 
0ac6 fe 20				cp ' ' 
0ac8 ca 24 0a				jp z, .is1    ; end of word 
0acb 2b					dec hl 
0acc 22 78 ee				ld (input_ptr), hl 
0acf 3a 71 ee				ld a, (input_at_cursor) 
0ad2 3d					dec a 
0ad3 32 71 ee				ld (input_at_cursor), a 
0ad6 18 e5				jr .iskpwm 
0ad8			 
0ad8			 
0ad8 fe 0b		.iskl:		cp KEY_LEFT 
0ada 20 27				jr nz, .isk1 
0adc			 
0adc 3a 64 ee				ld a, (input_cursor) 
0adf			 
0adf fe 00				cp 0 
0ae1 ca 24 0a				jp z, .is1 		; at start of line to ignore  
0ae4			 
0ae4 3d					dec  a 		; TODO check underflow 
0ae5 32 64 ee				ld (input_cursor), a 
0ae8			 
0ae8 2a 78 ee				ld hl, (input_ptr) 
0aeb 2b					dec hl 
0aec 22 78 ee				ld (input_ptr), hl 
0aef					 
0aef 3a 71 ee				ld a, (input_at_cursor) 
0af2 3d					dec a 
0af3 32 71 ee				ld (input_at_cursor), a 
0af6			 
0af6 3e 01				ld a, 1		; show cursor moving 
0af8 32 6e ee				ld (input_cur_onoff),a 
0afb 3e 0f				ld a, CUR_BLINK_RATE 
0afd 32 6f ee				ld (input_cur_flash), a 
0b00			 
0b00 c3 24 0a				jp .is1 
0b03			 
0b03 fe 0c		.isk1:		cp KEY_RIGHT 
0b05 20 2a				jr nz, .isk2 
0b07			 
0b07 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0b0a 5f					ld e,a 
0b0b 3a 64 ee				ld a, (input_cursor) 
0b0e bb					cp e 
0b0f ca 24 0a				jp z, .is1		; at the end of string so dont go right 
0b12			 
0b12 3c					inc  a 		; TODO check overflow 
0b13 32 64 ee				ld (input_cursor), a 
0b16			 
0b16 3a 71 ee				ld a, (input_at_cursor) 
0b19 3c					inc a 
0b1a 32 71 ee				ld (input_at_cursor), a 
0b1d			 
0b1d 2a 78 ee				ld hl, (input_ptr) 
0b20 23					inc hl 
0b21 22 78 ee				ld (input_ptr), hl 
0b24			 
0b24 3e 01				ld a, 1		; show cursor moving 
0b26 32 6e ee				ld (input_cur_onoff),a 
0b29 3e 0f				ld a, CUR_BLINK_RATE 
0b2b 32 6f ee				ld (input_cur_flash), a 
0b2e			 
0b2e c3 24 0a				jp .is1 
0b31			 
0b31 fe 05		.isk2:		cp KEY_UP 
0b33			 
0b33 20 26				jr nz, .isk3 
0b35			 
0b35					; swap last command with the current on 
0b35			 
0b35					; move cursor to start of string 
0b35 2a 76 ee				ld hl, (input_start) 
0b38 22 78 ee				ld (input_ptr), hl 
0b3b			 
0b3b 3a 73 ee				ld a, (input_at_pos) 
0b3e 32 71 ee				ld (input_at_cursor), a 
0b41			 
0b41 3e 00				ld a, 0 
0b43 32 64 ee				ld (input_cursor), a 
0b46					 
0b46					; swap input and last command buffers 
0b46			 
0b46 21 9c e6				ld hl, os_cli_cmd 
0b49 11 9b e7				ld de, os_last_cmd 
0b4c 06 ff				ld b, 255 
0b4e 7e			.swap1:		ld a, (hl) 
0b4f 4f					ld c,a 
0b50 1a					ld a, (de) 
0b51 77					ld (hl), a 
0b52 79					ld a,c 
0b53 12					ld (de),a 
0b54 23					inc hl 
0b55 13					inc de 
0b56 10 f6				djnz .swap1 
0b58			 
0b58			 
0b58			 
0b58			 
0b58			 
0b58 c3 24 0a				jp .is1 
0b5b			 
0b5b fe 08		.isk3:		cp KEY_BS 
0b5d 20 3c				jr nz, .isk4 
0b5f			 
0b5f 3a 64 ee				ld a, (input_cursor) 
0b62			 
0b62 fe 00				cp 0 
0b64 ca 24 0a				jp z, .is1 		; at start of line to ignore  
0b67			 
0b67 3d					dec  a 		; TODO check underflow 
0b68 32 64 ee				ld (input_cursor), a 
0b6b			 
0b6b					; hl is source 
0b6b					; de needs to be source - 1 
0b6b			 
0b6b			;		ld a, 0 
0b6b			;		dec hl 
0b6b			;		ld (hl), a 
0b6b			 
0b6b 2a 78 ee				ld hl, (input_ptr) 
0b6e 2b					dec hl 
0b6f 22 78 ee				ld (input_ptr), hl 
0b72			 
0b72					; shift all data 
0b72			 
0b72 e5					push hl 
0b73 23					inc hl 
0b74 d1					pop de 
0b75 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0b78 4f					ld c,a 
0b79 06 00				ld b,0 
0b7b ed b0				ldir  
0b7d			 
0b7d			 
0b7d			 
0b7d			 
0b7d 3a 71 ee				ld a, (input_at_cursor) 
0b80 3d					dec a 
0b81 32 71 ee				ld (input_at_cursor), a 
0b84			 
0b84			 
0b84 3e 01				ld a, 1		; show cursor moving 
0b86 32 6e ee				ld (input_cur_onoff),a 
0b89 3e 0f				ld a, CUR_BLINK_RATE 
0b8b 32 6f ee				ld (input_cur_flash), a 
0b8e			 
0b8e					; remove char 
0b8e 3a 71 ee				ld a, (input_at_cursor) 
0b91 3c					inc a 
0b92 11 1c 0c				ld de,.iblank 
0b95 cd 80 08				call str_at_display 
0b98			 
0b98 c3 24 0a				jp .is1 
0b9b			 
0b9b fe 0d		.isk4:		cp KEY_CR 
0b9d 28 6c				jr z, .endinput 
0b9f			 
0b9f					; else add the key press to the end 
0b9f			 
0b9f 4f					ld c, a			; save key pressed 
0ba0			 
0ba0 7e					ld a,(hl)		; get what is currently under char 
0ba1			 
0ba1 fe 00				cp 0			; we are at the end of the string 
0ba3 20 2f				jr nz, .onchar 
0ba5					 
0ba5					; add a char to the end of the string 
0ba5				 
0ba5 71					ld (hl),c 
0ba6 23					inc hl 
0ba7			;		ld a,' ' 
0ba7			;		ld (hl),a 
0ba7			;		inc hl 
0ba7 3e 00				ld a,0 
0ba9 77					ld (hl),a 
0baa 2b					dec hl 
0bab			 
0bab 3a 64 ee				ld a, (input_cursor) 
0bae 3c					inc a				; TODO check max string length and scroll  
0baf 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0bb2							 
0bb2 3a 71 ee				ld a, (input_at_cursor) 
0bb5 3c					inc a 
0bb6 32 71 ee				ld (input_at_cursor), a 
0bb9			 
0bb9 2a 78 ee				ld hl, (input_ptr) 
0bbc 23					inc hl 
0bbd 22 78 ee				ld (input_ptr), hl 
0bc0			 
0bc0 2a 78 ee				ld hl, (input_ptr) 
0bc3 23					inc hl 
0bc4 22 78 ee				ld (input_ptr), hl 
0bc7			;	if DEBUG_INPUT 
0bc7			;		push af 
0bc7			;		ld a, '+' 
0bc7			;		ld (debug_mark),a 
0bc7			;		pop af 
0bc7			;		CALLMONITOR 
0bc7			;	endif 
0bc7 3e 01				ld a, 1		; show cursor moving 
0bc9 32 6e ee				ld (input_cur_onoff),a 
0bcc 3e 0f				ld a, CUR_BLINK_RATE 
0bce 32 6f ee				ld (input_cur_flash), a 
0bd1 c3 24 0a				jp .is1 
0bd4					 
0bd4			 
0bd4			 
0bd4					; if on a char then insert 
0bd4			.onchar: 
0bd4			 
0bd4					; TODO over flow check: make sure insert does not blow out buffer 
0bd4			 
0bd4					; need to do some maths to use lddr 
0bd4			 
0bd4 e5					push hl   ; save char pos 
0bd5 c5					push bc 
0bd6			 
0bd6 2a 76 ee				ld hl, (input_start) 
0bd9 3a 69 ee				ld a, (input_len) 
0bdc cd c6 09				call addatohl  		; end of string 
0bdf 23					inc hl 
0be0 23					inc hl		; past zero term 
0be1 e5					push hl 
0be2 23					inc hl 
0be3 e5					push hl  
0be4			 
0be4								; start and end of lddr set, now how much to move? 
0be4			 
0be4							 
0be4 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0be7 47					ld b,a 
0be8 3a 69 ee				ld a,(input_len) 
0beb 5f					ld e,a 
0bec 90					sub b 
0bed 3c					inc a		;?? 
0bee 3c					inc a		;?? 
0bef 3c					inc a		;?? 
0bf0			 
0bf0 06 00				ld b,0 
0bf2 4f					ld c,a 
0bf3			 
0bf3				if DEBUG_INPUT 
0bf3					push af 
0bf3					ld a, 'i' 
0bf3					ld (debug_mark),a 
0bf3					pop af 
0bf3			;		CALLMONITOR 
0bf3				endif 
0bf3 d1					pop de 
0bf4 e1					pop hl 
0bf5				if DEBUG_INPUT 
0bf5					push af 
0bf5					ld a, 'I' 
0bf5					ld (debug_mark),a 
0bf5					pop af 
0bf5			;		CALLMONITOR 
0bf5				endif 
0bf5 ed b8				lddr 
0bf7				 
0bf7			 
0bf7			 
0bf7					; TODO have a key for insert/overwrite mode???? 
0bf7 c1					pop bc 
0bf8 e1					pop hl 
0bf9 71					ld (hl), c		; otherwise overwrite current char 
0bfa					 
0bfa			 
0bfa			 
0bfa			 
0bfa 3a 64 ee				ld a, (input_cursor) 
0bfd 3c					inc  a 		; TODO check overflow 
0bfe 32 64 ee				ld (input_cursor), a 
0c01			 
0c01 3a 71 ee				ld a, (input_at_cursor) 
0c04 3c					inc a 
0c05 32 71 ee				ld (input_at_cursor), a 
0c08			 
0c08 c3 24 0a				jp .is1 
0c0b			 
0c0b			.endinput:	; TODO look for end of string 
0c0b			 
0c0b					; add trailing space for end of token 
0c0b			 
0c0b 2a 76 ee				ld hl, (input_start) 
0c0e 3a 69 ee				ld a,(input_len) 
0c11 cd c6 09				call addatohl 
0c14 3e 20				ld a, ' ' 
0c16 77					ld (hl),a 
0c17					; TODO eof of parse marker 
0c17			 
0c17 23					inc hl 
0c18 3e 00				ld a, 0 
0c1a 77					ld (hl),a 
0c1b			 
0c1b			 
0c1b c9					ret 
0c1c			 
0c1c .. 00		.iblank: db " ",0 
0c1e			 
0c1e			 
0c1e 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0c21 22 76 ee				ld (input_start), hl 
0c24 3e 01				ld a,1			; add cursor 
0c26 77					ld (hl),a 
0c27 23					inc hl 
0c28 3e 00				ld a,0 
0c2a 77					ld (hl),a 
0c2b 22 78 ee				ld (input_ptr), hl 
0c2e 7a					ld a,d 
0c2f 32 75 ee				ld (input_size), a 
0c32 3e 00				ld a,0 
0c34 32 64 ee				ld (input_cursor),a 
0c37			.instr1:	 
0c37			 
0c37					; TODO do block cursor 
0c37					; TODO switch cursor depending on the modifer key 
0c37			 
0c37					; update cursor shape change on key hold 
0c37			 
0c37 2a 78 ee				ld hl, (input_ptr) 
0c3a 2b					dec hl 
0c3b 3a d3 eb				ld a,(cursor_shape) 
0c3e 77					ld (hl), a 
0c3f			 
0c3f					; display entered text 
0c3f 3a 73 ee				ld a,(input_at_pos) 
0c42 cd c1 46		            	CALL fLCD_Pos       ;Position cursor to location in A 
0c45 ed 5b 76 ee	            	LD   de, (input_start) 
0c49 cd b6 46		            	CALL fLCD_Str       ;Display string pointed to by DE 
0c4c			 
0c4c cd ac 47				call cin 
0c4f fe 00				cp 0 
0c51 28 e4				jr z, .instr1 
0c53			 
0c53					; proecess keyboard controls first 
0c53			 
0c53 2a 78 ee				ld hl,(input_ptr) 
0c56			 
0c56 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0c58 28 5a				jr z, .instrcr 
0c5a			 
0c5a fe 08				cp KEY_BS 	; back space 
0c5c 20 0f				jr nz, .instr2 
0c5e					; process back space 
0c5e			 
0c5e					; TODO stop back space if at start of string 
0c5e 2b					dec hl 
0c5f 2b					dec hl ; to over write cursor 
0c60 3a d3 eb				ld a,(cursor_shape) 
0c63					;ld a,0 
0c63 77					ld (hl),a 
0c64 23					inc hl 
0c65 3e 20				ld a," " 
0c67 77					ld (hl),a 
0c68 22 78 ee				ld (input_ptr),hl 
0c6b					 
0c6b			 
0c6b 18 ca				jr .instr1 
0c6d			 
0c6d fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0c6f 20 06				jr nz, .instr3 
0c71 2b					dec hl 
0c72 22 78 ee				ld (input_ptr),hl 
0c75 18 c0				jr .instr1 
0c77				 
0c77 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0c79 20 06				jr nz, .instr4 
0c7b 23					inc hl 
0c7c 22 78 ee				ld (input_ptr),hl 
0c7f 18 b6				jr .instr1 
0c81			 
0c81 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0c83 20 06				jr nz, .instr5 
0c85 2b					dec hl 
0c86 22 78 ee				ld (input_ptr),hl 
0c89 18 ac				jr .instr1 
0c8b			 
0c8b fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0c8d 20 06				jr nz, .instr6 
0c8f 2b					dec hl 
0c90 22 78 ee				ld (input_ptr),hl 
0c93 18 a2				jr .instr1 
0c95 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0c97 20 0b				jr nz, .instrnew 
0c99			 
0c99 21 75 e3			ld hl, scratch 
0c9c 11 9b e7			ld de, os_last_cmd 
0c9f cd bd 0c			call strcpy 
0ca2 18 93				jr .instr1 
0ca4			 
0ca4			 
0ca4			.instrnew:	; no special key pressed to see if we have room to store it 
0ca4			 
0ca4					; TODO do string size test 
0ca4			 
0ca4 2b					dec hl ; to over write cursor 
0ca5 77					ld (hl),a 
0ca6 23					inc hl 
0ca7 3a d3 eb				ld a,(cursor_shape) 
0caa 77					ld (hl),a 
0cab 23					inc hl 
0cac 3e 00				ld a,0 
0cae 77					ld (hl),a 
0caf			 
0caf 22 78 ee				ld (input_ptr),hl 
0cb2					 
0cb2 18 83				jr .instr1 
0cb4 2b			.instrcr:	dec hl		; remove cursor 
0cb5 3e 20				ld a,' '	; TODO add a trailing space for safety 
0cb7 77					ld (hl),a 
0cb8 23					inc hl 
0cb9 3e 00				ld a,0 
0cbb 77					ld (hl),a 
0cbc			 
0cbc			 
0cbc					; if at end of line scroll up    
0cbc					; TODO detecting only end of line 4 for scroll up  
0cbc			 
0cbc					;ld   
0cbc			 
0cbc c9					ret 
0cbd			 
0cbd			 
0cbd			; strcpy hl = dest, de source 
0cbd			 
0cbd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0cbe b7			            OR   A              ;Null terminator? 
0cbf c8			            RET  Z              ;Yes, so finished 
0cc0 1a					ld a,(de) 
0cc1 77					ld (hl),a 
0cc2 13			            INC  DE             ;Point to next character 
0cc3 23					inc hl 
0cc4 18 f7		            JR   strcpy       ;Repeat 
0cc6 c9					ret 
0cc7			 
0cc7			 
0cc7			; TODO string_at  
0cc7			; pass string which starts with lcd offset address and then null term string 
0cc7			 
0cc7			; TODO string to dec 
0cc7			; TODO string to hex 
0cc7			; TODO byte to string hex 
0cc7			; TODO byte to string dec 
0cc7			 
0cc7			 
0cc7			 
0cc7			; from z80uartmonitor 
0cc7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0cc7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0cc7			; pass hl for where to put the text 
0cc7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0cc7 c5			hexout:	PUSH BC 
0cc8 f5					PUSH AF 
0cc9 47					LD B, A 
0cca					; Upper nybble 
0cca cb 3f				SRL A 
0ccc cb 3f				SRL A 
0cce cb 3f				SRL A 
0cd0 cb 3f				SRL A 
0cd2 cd e2 0c				CALL tohex 
0cd5 77					ld (hl),a 
0cd6 23					inc hl	 
0cd7					 
0cd7					; Lower nybble 
0cd7 78					LD A, B 
0cd8 e6 0f				AND 0FH 
0cda cd e2 0c				CALL tohex 
0cdd 77					ld (hl),a 
0cde 23					inc hl	 
0cdf					 
0cdf f1					POP AF 
0ce0 c1					POP BC 
0ce1 c9					RET 
0ce2					 
0ce2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ce2			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ce2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ce2			tohex: 
0ce2 e5					PUSH HL 
0ce3 d5					PUSH DE 
0ce4 16 00				LD D, 0 
0ce6 5f					LD E, A 
0ce7 21 ef 0c				LD HL, .DATA 
0cea 19					ADD HL, DE 
0ceb 7e					LD A, (HL) 
0cec d1					POP DE 
0ced e1					POP HL 
0cee c9					RET 
0cef			 
0cef			.DATA: 
0cef 30					DEFB	30h	; 0 
0cf0 31					DEFB	31h	; 1 
0cf1 32					DEFB	32h	; 2 
0cf2 33					DEFB	33h	; 3 
0cf3 34					DEFB	34h	; 4 
0cf4 35					DEFB	35h	; 5 
0cf5 36					DEFB	36h	; 6 
0cf6 37					DEFB	37h	; 7 
0cf7 38					DEFB	38h	; 8 
0cf8 39					DEFB	39h	; 9 
0cf9 41					DEFB	41h	; A 
0cfa 42					DEFB	42h	; B 
0cfb 43					DEFB	43h	; C 
0cfc 44					DEFB	44h	; D 
0cfd 45					DEFB	45h	; E 
0cfe 46					DEFB	46h	; F 
0cff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0cff			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0cff			;;    subtract $30, if result > 9 then subtract $7 more 
0cff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0cff			atohex: 
0cff d6 30				SUB $30 
0d01 fe 0a				CP 10 
0d03 f8					RET M		; If result negative it was 0-9 so we're done 
0d04 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0d06 c9					RET		 
0d07			 
0d07			 
0d07			 
0d07			 
0d07			; Get 2 ASCII characters as hex byte from pointer in hl 
0d07			 
0d07			BYTERD: 
0d07 16 00			LD	D,00h		;Set up 
0d09 cd 11 0d			CALL	HEXCON		;Get byte and convert to hex 
0d0c 87				ADD	A,A		;First nibble so 
0d0d 87				ADD	A,A		;multiply by 16 
0d0e 87				ADD	A,A		; 
0d0f 87				ADD	A,A		; 
0d10 57				LD	D,A		;Save hi nibble in D 
0d11			HEXCON: 
0d11 7e				ld a, (hl)		;Get next chr 
0d12 23				inc hl 
0d13 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0d15 fe 0a			CP	00Ah		;Is it 0-9 ? 
0d17 38 02			JR	C,NALPHA	;If so miss next bit 
0d19 d6 07			SUB	007h		;Else convert alpha 
0d1b			NALPHA: 
0d1b b2				OR	D		;Add hi nibble back 
0d1c c9				RET			; 
0d1d			 
0d1d			 
0d1d			; 
0d1d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0d1d			; Since the routines get_byte and therefore get_nibble are called, only valid 
0d1d			; characters (0-9a-f) are accepted. 
0d1d			; 
0d1d			;get_word        push    af 
0d1d			;                call    get_byte        ; Get the upper byte 
0d1d			;                ld      h, a 
0d1d			;                call    get_byte        ; Get the lower byte 
0d1d			;                ld      l, a 
0d1d			;                pop     af 
0d1d			;                ret 
0d1d			; 
0d1d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0d1d			; the routine get_nibble is used only valid characters are accepted - the  
0d1d			; input routine only accepts characters 0-9a-f. 
0d1d			; 
0d1d c5			get_byte:        push    bc              ; Save contents of B (and C) 
0d1e 7e					ld a,(hl) 
0d1f 23					inc hl 
0d20 cd 45 0d		                call    nibble2val      ; Get upper nibble 
0d23 cb 07		                rlc     a 
0d25 cb 07		                rlc     a 
0d27 cb 07		                rlc     a 
0d29 cb 07		                rlc     a 
0d2b 47			                ld      b, a            ; Save upper four bits 
0d2c 7e					ld a,(hl) 
0d2d cd 45 0d		                call    nibble2val      ; Get lower nibble 
0d30 b0			                or      b               ; Combine both nibbles 
0d31 c1			                pop     bc              ; Restore B (and C) 
0d32 c9			                ret 
0d33			; 
0d33			; Get a hexadecimal digit from the serial line. This routine blocks until 
0d33			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0d33			; to the serial line interface. The lower 4 bits of A contain the value of  
0d33			; that particular digit. 
0d33			; 
0d33			;get_nibble      ld a,(hl)           ; Read a character 
0d33			;                call    to_upper        ; Convert to upper case 
0d33			;                call    is_hex          ; Was it a hex digit? 
0d33			;                jr      nc, get_nibble  ; No, get another character 
0d33			 ;               call    nibble2val      ; Convert nibble to value 
0d33			 ;               call    print_nibble 
0d33			 ;               ret 
0d33			; 
0d33			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0d33			; A valid hexadecimal digit is denoted by a set C flag. 
0d33			; 
0d33			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0d33			;                ret     nc              ; Yes 
0d33			;                cp      '0'             ; Less than '0'? 
0d33			;                jr      nc, is_hex_1    ; No, continue 
0d33			;                ccf                     ; Complement carry (i.e. clear it) 
0d33			;                ret 
0d33			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0d33			;                ret     c               ; Yes 
0d33			;                cp      'A'             ; Less than 'A'? 
0d33			;                jr      nc, is_hex_2    ; No, continue 
0d33			;                ccf                     ; Yes - clear carry and return 
0d33			;                ret 
0d33			;is_hex_2        scf                     ; Set carry 
0d33			;                ret 
0d33			; 
0d33			; Convert a single character contained in A to upper case: 
0d33			; 
0d33 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0d35 d8			                ret     c 
0d36 fe 7b		                cp      'z' + 1         ; > 'z'? 
0d38 d0			                ret     nc              ; Nothing to do, either 
0d39 e6 5f		                and     $5f             ; Convert to upper case 
0d3b c9			                ret 
0d3c			 
0d3c			 
0d3c			to_lower: 
0d3c			 
0d3c			   ; if char is in [A-Z] make it lower case 
0d3c			 
0d3c			   ; enter : a = char 
0d3c			   ; exit  : a = lower case char 
0d3c			   ; uses  : af 
0d3c			 
0d3c fe 41		   cp 'A' 
0d3e d8			   ret c 
0d3f			    
0d3f fe 5b		   cp 'Z'+1 
0d41 d0			   ret nc 
0d42			    
0d42 f6 20		   or $20 
0d44 c9			   ret 
0d45			 
0d45			; 
0d45			; Expects a hexadecimal digit (upper case!) in A and returns the 
0d45			; corresponding value in A. 
0d45			; 
0d45 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0d47 38 02		                jr      c, nibble2val_1 ; Yes 
0d49 d6 07		                sub     7               ; Adjust for A-F 
0d4b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0d4d e6 0f		                and     $f              ; Only return lower 4 bits 
0d4f c9			                ret 
0d50			; 
0d50			; Print_nibble prints a single hex nibble which is contained in the lower  
0d50			; four bits of A: 
0d50			; 
0d50			;print_nibble    push    af              ; We won't destroy the contents of A 
0d50			;                and     $f              ; Just in case... 
0d50			;                add     a, '0'             ; If we have a digit we are done here. 
0d50			;                cp      '9' + 1         ; Is the result > 9? 
0d50			;                jr      c, print_nibble_1 
0d50			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0d50			;print_nibble_1  call    putc            ; Print the nibble and 
0d50			;                pop     af              ; restore the original value of A 
0d50			;                ret 
0d50			;; 
0d50			;; Send a CR/LF pair: 
0d50			; 
0d50			;crlf            push    af 
0d50			;                ld      a, cr 
0d50			;                call    putc 
0d50			;                ld      a, lf 
0d50			;                call    putc 
0d50			;                pop     af 
0d50			;                ret 
0d50			; 
0d50			; Print_word prints the four hex digits of a word to the serial line. The  
0d50			; word is expected to be in HL. 
0d50			; 
0d50			;print_word      push    hl 
0d50			;                push    af 
0d50			;                ld      a, h 
0d50			;                call    print_byte 
0d50			;                ld      a, l 
0d50			;                call    print_byte 
0d50			;                pop     af 
0d50			;                pop     hl 
0d50			;                ret 
0d50			; 
0d50			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0d50			; The byte to be printed is expected to be in A. 
0d50			; 
0d50			;print_byte      push    af              ; Save the contents of the registers 
0d50			;                push    bc 
0d50			;                ld      b, a 
0d50			;                rrca 
0d50			;                rrca 
0d50			;                rrca 
0d50			;                rrca 
0d50			;                call    print_nibble    ; Print high nibble 
0d50			;                ld      a, b 
0d50			;                call    print_nibble    ; Print low nibble 
0d50			;                pop     bc              ; Restore original register contents 
0d50			;                pop     af 
0d50			;                ret 
0d50			 
0d50			 
0d50			 
0d50			 
0d50			 
0d50			fourehexhl:  
0d50 7e				ld a,(hl) 
0d51 cd ff 0c			call atohex 
0d54 cb 3f				SRL A 
0d56 cb 3f				SRL A 
0d58 cb 3f				SRL A 
0d5a cb 3f				SRL A 
0d5c 47				ld b, a 
0d5d 23				inc hl 
0d5e 7e				ld a,(hl) 
0d5f 23				inc hl 
0d60 cd ff 0c			call atohex 
0d63 80				add b 
0d64 57				ld d,a 
0d65 7e				ld a,(hl) 
0d66 cd ff 0c			call atohex 
0d69 cb 3f				SRL A 
0d6b cb 3f				SRL A 
0d6d cb 3f				SRL A 
0d6f cb 3f				SRL A 
0d71 47				ld b, a 
0d72 23				inc hl 
0d73 7e				ld a,(hl) 
0d74 23				inc hl 
0d75 cd ff 0c			call atohex 
0d78 80				add b 
0d79 5f				ld e, a 
0d7a d5				push de 
0d7b e1				pop hl 
0d7c c9				ret 
0d7d			 
0d7d			; pass hl. returns z set if the byte at hl is a digit 
0d7d			;isdigithl:  
0d7d			;	push bc 
0d7d			;	ld a,(hl) 
0d7d			;	cp ':' 
0d7d			;	jr nc, .isdf 		; > 
0d7d			;	cp '0' 
0d7d			;	jr c, .isdf		; < 
0d7d			; 
0d7d			;	; TODO find a better way to set z 
0d7d			; 
0d7d			;	ld b,a 
0d7d			;	cp b 
0d7d			;	pop bc 
0d7d			;	ret 
0d7d			; 
0d7d			;.isdf:	; not digit so clear z 
0d7d			; 
0d7d			;	; TODO find a better way to unset z 
0d7d			; 
0d7d			;	ld b,a 
0d7d			;	inc b 
0d7d			;	cp b 
0d7d			; 
0d7d			;	pop bc 
0d7d			;	ret 
0d7d				 
0d7d				 
0d7d			 
0d7d			 
0d7d			; pass hl as the four byte address to load 
0d7d			 
0d7d			get_word_hl:  
0d7d e5				push hl 
0d7e cd 1d 0d			call get_byte 
0d81				 
0d81 47				ld b, a 
0d82			 
0d82 e1				pop hl 
0d83 23				inc hl 
0d84 23				inc hl 
0d85			 
0d85			; TODO not able to handle a-f  
0d85 7e				ld a,(hl) 
0d86			;	;cp ':' 
0d86			;	cp 'g' 
0d86			;	jr nc, .single_byte_hl 		; > 
0d86			;	cp 'G' 
0d86			;	jr nc, .single_byte_hl 		; > 
0d86			;	cp '0' 
0d86			;	jr c, .single_byte_hl		; < 
0d86			 
0d86				;call isdigithl 
0d86 fe 00			cp 0 
0d88 28 06			jr z, .single_byte_hl 
0d8a			 
0d8a			.getwhln:   ; hex word so get next byte 
0d8a			 
0d8a cd 1d 0d			call get_byte 
0d8d 6f				ld l, a 
0d8e 60				ld h,b 
0d8f c9				ret 
0d90 68			.single_byte_hl:   ld l,b 
0d91 26 00				ld h,0 
0d93 c9					ret 
0d94			 
0d94			 
0d94			 
0d94			 
0d94 21 2e 14			ld hl,asc+1 
0d97			;	ld a, (hl) 
0d97			;	call nibble2val 
0d97 cd 1d 0d			call get_byte 
0d9a			 
0d9a			;	call fourehexhl 
0d9a 32 a9 e3			ld (scratch+52),a 
0d9d				 
0d9d 21 a7 e3			ld hl,scratch+50 
0da0 22 98 e6			ld (os_cur_ptr),hl 
0da3			 
0da3 c9				ret 
0da4			 
0da4			 
0da4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0da4			 
0da4			; Decimal Unsigned Version 
0da4			 
0da4			;Number in a to decimal ASCII 
0da4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0da4			;Example: display a=56 as "056" 
0da4			;input: a = number 
0da4			;Output: a=0,value of a in the screen 
0da4			;destroys af,bc (don't know about hl and de) 
0da4			DispAToASCII: 
0da4 0e 9c			ld	c,-100 
0da6 cd b0 0d			call	.Na1 
0da9 0e f6			ld	c,-10 
0dab cd b0 0d			call	.Na1 
0dae 0e ff			ld	c,-1 
0db0 06 2f		.Na1:	ld	b,'0'-1 
0db2 04			.Na2:	inc	b 
0db3 81				add	a,c 
0db4 38 fc			jr	c,.Na2 
0db6 91				sub	c		;works as add 100/10/1 
0db7 f5				push af		;safer than ld c,a 
0db8 78				ld	a,b		;char is in b 
0db9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0db9 f1				pop af		;safer than ld a,c 
0dba c9				ret 
0dbb			 
0dbb			; Decimal Signed Version 
0dbb			 
0dbb			; DispA 
0dbb			; -------------------------------------------------------------- 
0dbb			; Converts a signed integer value to a zero-terminated ASCII 
0dbb			; string representative of that value (using radix 10). 
0dbb			; -------------------------------------------------------------- 
0dbb			; INPUTS: 
0dbb			;     HL     Value to convert (two's complement integer). 
0dbb			;     DE     Base address of string destination. (pointer). 
0dbb			; -------------------------------------------------------------- 
0dbb			; OUTPUTS: 
0dbb			;     None 
0dbb			; -------------------------------------------------------------- 
0dbb			; REGISTERS/MEMORY DESTROYED 
0dbb			; AF HL 
0dbb			; -------------------------------------------------------------- 
0dbb			 
0dbb			;DispHLToASCII: 
0dbb			;   push    de 
0dbb			;   push    bc 
0dbb			; 
0dbb			;; Detect sign of HL. 
0dbb			;    bit    7, h 
0dbb			;    jr     z, ._DoConvert 
0dbb			; 
0dbb			;; HL is negative. Output '-' to string and negate HL. 
0dbb			;    ld     a, '-' 
0dbb			;    ld     (de), a 
0dbb			;    inc    de 
0dbb			; 
0dbb			;; Negate HL (using two's complement) 
0dbb			;    xor    a 
0dbb			;    sub    l 
0dbb			;    ld     l, a 
0dbb			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0dbb			;    sbc    a, h 
0dbb			;    ld     h, a 
0dbb			; 
0dbb			;; Convert HL to digit characters 
0dbb			;._DoConvert: 
0dbb			;    ld     b, 0     ; B will count character length of number 
0dbb			;-   ld     a, 10 
0dbb			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0dbb			;    push   af 
0dbb			;    inc    b 
0dbb			;    ld     a, h 
0dbb			;    or     l 
0dbb			;    jr     nz, - 
0dbb			; 
0dbb			;; Retrieve digits from stack 
0dbb			;-   pop    af 
0dbb			;    or     $30 
0dbb			;    ld     (de), a 
0dbb			;    inc    de 
0dbb			;    djnz   - 
0dbb			; 
0dbb			;; Terminate string with NULL 
0dbb			;    xor    a 
0dbb			;    ld     (de), a 
0dbb			; 
0dbb			;    pop    bc 
0dbb			;    pop    de 
0dbb			;    ret 
0dbb			 
0dbb			;Comments 
0dbb			; 
0dbb			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0dbb			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0dbb			;    Note that the output string will not be fixed-width. 
0dbb			; 
0dbb			;Example Usage 
0dbb			; 
0dbb			;    ld    hl, -1004 
0dbb			;    ld    de, OP1 
0dbb			;    call  DispA 
0dbb			;    ld    hl, OP1 
0dbb			;    syscall  PutS 
0dbb			 
0dbb			 
0dbb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0dbb			 
0dbb			 
0dbb			;Converts an ASCII string to an unsigned 16-bit integer 
0dbb			;Quits when it reaches a non-decimal digit 
0dbb			 
0dbb			string_to_uint16: 
0dbb			atoui_16: 
0dbb			;Input: 
0dbb			;     DE points to the string 
0dbb			;Outputs: 
0dbb			;     HL is the result 
0dbb			;     A is the 8-bit value of the number 
0dbb			;     DE points to the byte after the number 
0dbb			;Destroys: 
0dbb			;     BC 
0dbb			;       if the string is non-empty, BC is HL/10 
0dbb			;Size:  24 bytes 
0dbb			;Speed: 42+d(104+{0,9}) 
0dbb			;       d is the number of digits in the number 
0dbb			;       max is 640 cycles for a 5 digit number 
0dbb			;Assuming no leading zeros: 
0dbb			;1 digit:  146cc 
0dbb			;2 digit:  250cc 
0dbb			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0dbb			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0dbb			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0dbb			;avg: 544.81158447265625cc (544+13297/16384) 
0dbb			;=============================================================== 
0dbb 21 00 00		  ld hl,0 
0dbe			.u16a: 
0dbe 1a			  ld a,(de) 
0dbf d6 30		  sub 30h 
0dc1 fe 0a		  cp 10 
0dc3 d0			  ret nc 
0dc4 13			  inc de 
0dc5 44			  ld b,h 
0dc6 4d			  ld c,l 
0dc7 29			  add hl,hl 
0dc8 29			  add hl,hl 
0dc9 09			  add hl,bc 
0dca 29			  add hl,hl 
0dcb 85			  add a,l 
0dcc 6f			  ld l,a 
0dcd 30 ef		  jr nc,.u16a 
0dcf 24			  inc h 
0dd0 c3 be 0d		  jp .u16a 
0dd3			 
0dd3			 
0dd3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0dd3			 
0dd3			;written by Zeda 
0dd3			;Converts a 16-bit unsigned integer to an ASCII string. 
0dd3			 
0dd3			uitoa_16: 
0dd3			;Input: 
0dd3			;   DE is the number to convert 
0dd3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0dd3			;Output: 
0dd3			;   HL points to the null-terminated ASCII string 
0dd3			;      NOTE: This isn't necessarily the same as the input HL. 
0dd3 d5			  push de 
0dd4 c5			  push bc 
0dd5 f5			  push af 
0dd6 eb			  ex de,hl 
0dd7			 
0dd7 01 f0 d8		  ld bc,-10000 
0dda 3e 2f		  ld a,'0'-1 
0ddc 3c			  inc a 
0ddd 09			  add hl,bc  
0dde 38 fc		   jr c,$-2 
0de0 12			  ld (de),a 
0de1 13			  inc de 
0de2			 
0de2 01 e8 03		  ld bc,1000 
0de5 3e 3a		  ld a,'9'+1 
0de7 3d			  dec a  
0de8 09			  add hl,bc  
0de9 30 fc		   jr nc,$-2 
0deb 12			  ld (de),a 
0dec 13			  inc de 
0ded			 
0ded 01 9c ff		  ld bc,-100 
0df0 3e 2f		  ld a,'0'-1 
0df2 3c			  inc a  
0df3 09			  add hl,bc  
0df4 38 fc		   jr c,$-2 
0df6 12			  ld (de),a 
0df7 13			  inc de 
0df8			 
0df8 7d			  ld a,l 
0df9 26 3a		  ld h,'9'+1 
0dfb 25			  dec h  
0dfc c6 0a		  add a,10  
0dfe 30 fb		   jr nc,$-3 
0e00 c6 30		  add a,'0' 
0e02 eb			  ex de,hl 
0e03 72			  ld (hl),d 
0e04 23			  inc hl 
0e05 77			  ld (hl),a 
0e06 23			  inc hl 
0e07 36 00		  ld (hl),0 
0e09			 
0e09			;Now strip the leading zeros 
0e09 0e fa		  ld c,-6 
0e0b 09			  add hl,bc 
0e0c 3e 30		  ld a,'0' 
0e0e 23			  inc hl  
0e0f be			  cp (hl)  
0e10 28 fc		  jr z,$-2 
0e12			 
0e12			;Make sure that the string is non-empty! 
0e12 7e			  ld a,(hl) 
0e13 b7			  or a 
0e14 20 01		  jr nz,.atoub 
0e16 2b			  dec hl 
0e17			.atoub: 
0e17			 
0e17 f1			  pop af 
0e18 c1			  pop bc 
0e19 d1			  pop de 
0e1a c9			  ret 
0e1b			 
0e1b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
0e1b			 
0e1b			toUpper: 
0e1b			;A is the char. 
0e1b			;If A is a lowercase letter, this sets it to the matching uppercase 
0e1b			;18cc or 30cc or 41cc 
0e1b			;avg: 26.75cc 
0e1b fe 61		  cp 'a' 
0e1d d8			  ret c 
0e1e fe 7b		  cp 'z'+1 
0e20 d0			  ret nc 
0e21 d6 20		  sub 'a'-'A' 
0e23 c9			  ret 
0e24			 
0e24			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
0e24			 
0e24			; String Length 
0e24			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
0e24			 
0e24			; Get the length of the null-terminated string starting at $8000 hl 
0e24			;    LD     HL, $8000 
0e24			 
0e24			strlenz: 
0e24			 
0e24 af			    XOR    A               ; Zero is the value we are looking for. 
0e25 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
0e26 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
0e27			                           ; 65, 536 bytes (the entire addressable memory space). 
0e27 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0e29			 
0e29			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0e29 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
0e2a 6f			    LD     L, A             ; number of bytes 
0e2b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0e2d 2b			    DEC    HL              ; Compensate for null. 
0e2e c9				ret 
0e2f			 
0e2f			; Get the length of the A terminated string starting at $8000 hl 
0e2f			;    LD     HL, $8000 
0e2f			 
0e2f			strlent: 
0e2f			 
0e2f			                  ; A is the value we are looking for. 
0e2f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
0e31 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
0e33			                           ; 65, 536 bytes (the entire addressable memory space). 
0e33 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0e35			 
0e35			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0e35 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
0e37 2e 00		    LD     L, 0             ; number of bytes 
0e39 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0e3b 2b			    DEC    HL              ; Compensate for null. 
0e3c c9				ret 
0e3d			 
0e3d			 
0e3d			;Comparing Strings 
0e3d			 
0e3d			;IN    HL     Address of string1. 
0e3d			;      DE     Address of string2. 
0e3d			 
0e3d			; doc given but wrong??? 
0e3d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
0e3d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
0e3d			; tested 
0e3d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
0e3d			 
0e3d			strcmp_old: 
0e3d e5			    PUSH   HL 
0e3e d5			    PUSH   DE 
0e3f			 
0e3f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
0e40 be			    CP     (HL)            ; (want to minimize work). 
0e41 38 01		    JR     C, Str1IsBigger 
0e43 7e			    LD     A, (HL) 
0e44			 
0e44			Str1IsBigger: 
0e44 4f			    LD     C, A             ; Put length in BC 
0e45 06 00		    LD     B, 0 
0e47 13			    INC    DE              ; Increment pointers to meat of string. 
0e48 23			    INC    HL 
0e49			 
0e49			CmpLoop: 
0e49 1a			    LD     A, (DE)          ; Compare bytes. 
0e4a ed a1		    CPI 
0e4c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
0e4e 13			    INC    DE              ; Update pointer. 
0e4f ea 49 0e		    JP     PE, CmpLoop 
0e52			 
0e52 d1			    POP    DE 
0e53 e1			    POP    HL 
0e54 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
0e55 be			    CP     (HL) 
0e56 c9			    RET 
0e57			 
0e57			NoMatch: 
0e57 2b			    DEC    HL 
0e58 be			    CP     (HL)            ; Compare again to affect carry. 
0e59 d1			    POP    DE 
0e5a e1			    POP    HL 
0e5b c9			    RET 
0e5c			 
0e5c			;; test strmp 
0e5c			; 
0e5c			;ld de, .str1 
0e5c			;ld hl, .str2 
0e5c			;call strcmp 
0e5c			;jr z, .z1 
0e5c			;;this 
0e5c			;	if DEBUG_FORTH_WORDS 
0e5c			;		DMARK "NZ1" 
0e5c			;		CALLMONITOR 
0e5c			;	endif 
0e5c			;.z1: 
0e5c			; 
0e5c			;	if DEBUG_FORTH_WORDS 
0e5c			;		DMARK "ZZ1" 
0e5c			;		CALLMONITOR 
0e5c			;	endif 
0e5c			; 
0e5c			;ld de, .str1 
0e5c			;ld hl, .str1 
0e5c			;call strcmp 
0e5c			;jr z, .z2 
0e5c			;;this 
0e5c			;	if DEBUG_FORTH_WORDS 
0e5c			;		DMARK "NZ2" 
0e5c			;		CALLMONITOR 
0e5c			;	endif 
0e5c			;.z2: 
0e5c			; 
0e5c			;	if DEBUG_FORTH_WORDS 
0e5c			;		DMARK "ZZ2" 
0e5c			;		CALLMONITOR 
0e5c			;	endif 
0e5c			; 
0e5c			;ld de, .str1 
0e5c			;ld hl, .str2 
0e5c			;call strcmp 
0e5c			;jr c, .c1 
0e5c			; 
0e5c			;	if DEBUG_FORTH_WORDS 
0e5c			;		DMARK "Nc1" 
0e5c			;		CALLMONITOR 
0e5c			;	endif 
0e5c			;.c1: 
0e5c			;;this 
0e5c			;	if DEBUG_FORTH_WORDS 
0e5c			;		DMARK "cc1" 
0e5c			;		CALLMONITOR 
0e5c			;	endif 
0e5c			; 
0e5c			;ld de, .str1 
0e5c			;ld hl, .str1 
0e5c			;call strcmp 
0e5c			;jr c, .c2 
0e5c			;;this 
0e5c			;	if DEBUG_FORTH_WORDS 
0e5c			;		DMARK "Nc2" 
0e5c			;		CALLMONITOR 
0e5c			;	endif 
0e5c			;.c2: 
0e5c			; 
0e5c			;	if DEBUG_FORTH_WORDS 
0e5c			;		DMARK "cc2" 
0e5c			;		CALLMONITOR 
0e5c			;	endif 
0e5c			;	NEXTW 
0e5c			;.str1:   db "string1",0 
0e5c			;.str2:   db "string2",0 
0e5c			 
0e5c			; only care about direct match or not 
0e5c			; hl and de strings 
0e5c			; zero set if the same 
0e5c			 
0e5c			strcmp: 
0e5c 1a				ld a, (de) 
0e5d be				cp (hl) 
0e5e 28 02			jr z, .ssame 
0e60 b7				or a 
0e61 c9				ret 
0e62			 
0e62			.ssame:  
0e62 fe 00			cp 0 
0e64 c8				ret z 
0e65			 
0e65 23				inc hl 
0e66 13				inc de 
0e67 18 f3			jr strcmp 
0e69				 
0e69				 
0e69			 
0e69			 
0e69			 
0e69			 
0e69			; eof 
0e69			 
0e69			 
0e69			 
0e69			 
0e69			 
0e69			 
# End of file firmware_strings.asm
0e69			include "firmware_memory.asm"   ; malloc and free  
0e69			 
0e69			if DEBUG_FORTH_MALLOC_HIGH 
0e69			.mallocsize: db "Wants malloc >256",0 
0e69			.mallocasize: db "MALLOC gives >256",0 
0e69			.malloczero: db "MALLOC gives zero",0 
0e69			 
0e69			malloc_guard_zerolen: 
0e69				push hl 
0e69				push de 
0e69				push af 
0e69			 
0e69				ld de, 0 
0e69			        call cmp16 
0e69				jr nz, .lowalloz 
0e69			 
0e69				push hl 
0e69				push de 
0e69					ld hl, display_fb0 
0e69					ld (display_fb_active), hl 
0e69				call clear_display 
0e69				ld a, 0 
0e69				ld de, .malloczero 
0e69				call str_at_display 
0e69				call update_display 
0e69				call delay1s 
0e69				call delay1s 
0e69				ld a, 0 
0e69				ld (os_view_disable), a 
0e69			 
0e69				pop de 
0e69				pop hl 
0e69			 
0e69				 
0e69			 
0e69				CALLMONITOR 
0e69			.lowalloz: 
0e69			 
0e69			 
0e69				pop af 
0e69				pop de 
0e69				pop hl 
0e69			ret 
0e69			 
0e69			malloc_guard_entry: 
0e69				push hl 
0e69				push de 
0e69				push af 
0e69			 
0e69			 	or a      ;clear carry flag 
0e69				push hl 
0e69				ld de, 255 
0e69				sbc hl, de 
0e69				jr c, .lowalloc 
0e69			 
0e69				push de 
0e69					ld hl, display_fb0 
0e69					ld (display_fb_active), hl 
0e69				call clear_display 
0e69				ld a, 0 
0e69				ld de, .mallocsize 
0e69				call str_at_display 
0e69				call update_display 
0e69				call delay1s 
0e69				call delay1s 
0e69				ld a, 0 
0e69				ld (os_view_disable), a 
0e69			 
0e69				pop de 
0e69				pop hl 
0e69			 
0e69				 
0e69			 
0e69				CALLMONITOR 
0e69				jr .lowdone 
0e69			.lowalloc: 
0e69			 
0e69			 
0e69				pop hl 
0e69			.lowdone:	pop af 
0e69				pop de 
0e69				pop hl 
0e69			ret 
0e69			 
0e69			malloc_guard_exit: 
0e69				push hl 
0e69				push de 
0e69				push af 
0e69			 
0e69			 	or a      ;clear carry flag 
0e69				push hl 
0e69				ld de, 255 
0e69				sbc hl, de 
0e69				jr c, .lowallocx 
0e69			 
0e69				push de 
0e69					ld hl, display_fb0 
0e69					ld (display_fb_active), hl 
0e69				call clear_display 
0e69				ld a, 0 
0e69				ld de, .mallocasize 
0e69				call str_at_display 
0e69				call update_display 
0e69				call delay1s 
0e69				call delay1s 
0e69				ld a, 0 
0e69				ld (os_view_disable), a 
0e69				pop de 
0e69				pop hl 
0e69			 
0e69				CALLMONITOR 
0e69				jr .lowdonex 
0e69			.lowallocx: 
0e69			 
0e69				pop hl 
0e69			.lowdonex:	pop af 
0e69				pop de 
0e69				pop hl 
0e69			ret 
0e69			endif 
0e69			 
0e69			if MALLOC_2 
0e69			; Z80 Malloc and Free Functions 
0e69			 
0e69			; Malloc Function: 
0e69			; Input: 
0e69			;   HL: Size of block to allocate 
0e69			; Output: 
0e69			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
0e69			 
0e69			malloc: 
0e69				 
0e69			if DEBUG_FORTH_MALLOC_HIGH 
0e69			call malloc_guard_entry 
0e69			endif 
0e69			 
0e69			 
0e69			 
0e69			 
0e69					if DEBUG_FORTH_MALLOC 
0e69						DMARK "mal" 
0e69						CALLMONITOR 
0e69					endif 
0e69			    push af            ; Save AF register 
0e69			    ld a, l            ; Load low byte of size into A 
0e69			    or h               ; Check if size is zero 
0e69			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
0e69			 
0e69			    ; Allocate memory 
0e69			    ld hl, (heap_start) ; Load start of heap into HL 
0e69					if DEBUG_FORTH_MALLOC 
0e69						DMARK "ma1" 
0e69						CALLMONITOR 
0e69					endif 
0e69			    call malloc_internal ; Call internal malloc function 
0e69			    pop af             ; Restore AF register 
0e69			if DEBUG_FORTH_MALLOC_HIGH 
0e69			call malloc_guard_exit 
0e69			call malloc_guard_zerolen 
0e69			endif 
0e69			    ret                ; Return 
0e69			 
0e69			; Free Function: 
0e69			; Input: 
0e69			;   HL: Pointer to memory block to free 
0e69			; Output: 
0e69			;   None 
0e69			 
0e69			free: 
0e69			    push af            ; Save AF register 
0e69			    ld a, l            ; Load low byte of pointer into A 
0e69			    or h               ; Check if pointer is NULL 
0e69			    jp z, free_exit    ; If pointer is NULL, exit 
0e69			 
0e69			    ; Free memory 
0e69			    ld hl, (heap_start) ; Load start of heap into HL 
0e69			    call free_internal  ; Call internal free function 
0e69			    pop af             ; Restore AF register 
0e69			    ret                ; Return 
0e69			 
0e69			; Internal Malloc Function: 
0e69			; Input: 
0e69			;   HL: Size of block to allocate 
0e69			; Output: 
0e69			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
0e69			 
0e69			malloc_internal: 
0e69			    ld bc, 2           ; Number of bytes to allocate for management overhead 
0e69			    add hl, bc         ; Add management overhead to requested size 
0e69			    ex de, hl          ; Save total size in DE, and keep it in HL 
0e69					if DEBUG_FORTH_MALLOC 
0e69						DMARK "ma2" 
0e69						CALLMONITOR 
0e69					endif 
0e69			 
0e69			    ; Search for free memory block 
0e69			    ld de, (heap_end)  ; Load end of heap into DE 
0e69			    ld bc, 0           ; Initialize counter 
0e69			 
0e69					if DEBUG_FORTH_MALLOC 
0e69						DMARK "ma2" 
0e69						CALLMONITOR 
0e69					endif 
0e69			malloc_search_loop: 
0e69			    ; Check if current block is free 
0e69			    ld a, (hl)         ; Load current block's status (free or used) 
0e69			    cp 0               ; Compare with zero (free) 
0e69			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
0e69			 
0e69			    ; Check if current block is large enough 
0e69			    ld a, (hl+1)       ; Load high byte of block size 
0e69			    cp l               ; Compare with low byte of requested size 
0e69			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
0e69			 
0e69			    ld a, (hl+2)       ; Load low byte of block size 
0e69			    cp h               ; Compare with high byte of requested size 
0e69			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
0e69			 
0e69			    ; Mark block as used 
0e69			    ld (hl), 0xFF      ; Set status byte to indicate used block 
0e69			 
0e69			    ; Calculate remaining space in block 
0e69			    ld bc, 0           ; Clear BC 
0e69			    add hl, bc         ; Increment HL to point to start of data block 
0e69			    add hl, de         ; HL = HL + DE (total size) 
0e69			    ld bc, 1           ; Number of bytes to allocate for management overhead 
0e69			    add hl, bc         ; Add management overhead to start of data block 
0e69			 
0e69			    ; Save pointer to allocated block in HL 
0e69			if DEBUG_FORTH_MALLOC_HIGH 
0e69						DMARK "ma5" 
0e69			call malloc_guard_exit 
0e69			call malloc_guard_zerolen 
0e69			endif 
0e69			    ret 
0e69			 
0e69			malloc_skip_block_check: 
0e69			    ; Move to the next block 
0e69			    ld bc, 3           ; Size of management overhead 
0e69			    add hl, bc         ; Move to the next block 
0e69			    inc de             ; Increment counter 
0e69			 
0e69			    ; Check if we have reached the end of heap 
0e69			    ld a, e            ; Load low byte of heap end address 
0e69			    cp (hl)            ; Compare with low byte of current address 
0e69			    jr nz, malloc_search_loop  ; If not equal, continue searching 
0e69			    ld a, d            ; Load high byte of heap end address 
0e69			    cp 0               ; Check if it's zero (end of memory) 
0e69			    jr nz, malloc_search_loop  ; If not zero, continue searching 
0e69			 
0e69			    ; If we reached here, allocation failed 
0e69			    xor a              ; Set result to NULL 
0e69			if DEBUG_FORTH_MALLOC_HIGH 
0e69						DMARK "ma6" 
0e69			call malloc_guard_exit 
0e69			call malloc_guard_zerolen 
0e69			endif 
0e69			    ret 
0e69			malloc_exit: 
0e69			if DEBUG_FORTH_MALLOC_HIGH 
0e69						DMARK "ma7" 
0e69			call malloc_guard_exit 
0e69			call malloc_guard_zerolen 
0e69			endif 
0e69			    ret 
0e69			 
0e69			; Internal Free Function: 
0e69			; Input: 
0e69			;   HL: Pointer to memory block to free 
0e69			; Output: 
0e69			;   None 
0e69			 
0e69			free_internal: 
0e69			    ld de, (heap_start) ; Load start of heap into DE 
0e69			    ld bc, 0            ; Initialize counter 
0e69			 
0e69			free_search_loop: 
0e69			    ; Check if current block contains the pointer 
0e69			    ld a, l             ; Load low byte of pointer 
0e69			    cp (hl+1)           ; Compare with high byte of current block's address 
0e69			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
0e69			    ld a, h             ; Load high byte of pointer 
0e69			    cp (hl+2)           ; Compare with low byte of current block's address 
0e69			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
0e69			 
0e69			    ; Mark block as free 
0e69			    ld (hl), 0          ; Set status byte to indicate free block 
0e69			    ret                 ; Return 
0e69			 
0e69			free_skip_block_check: 
0e69			    ; Move to the next block 
0e69			    ld bc, 3            ; Size of management overhead 
0e69			    add hl, bc          ; Move to the next block 
0e69			    inc de              ; Increment counter 
0e69			 
0e69			    ; Check if we have reached the end of heap 
0e69			    ld a, e             ; Load low byte of heap end address 
0e69			    cp (hl)             ; Compare with low byte of current address 
0e69			    jr nz, free_search_loop  ; If not equal, continue searching 
0e69			    ld a, d             ; Load high byte of heap end address 
0e69			    cp 0                ; Check if it's zero (end of memory) 
0e69			    jr nz, free_search_loop  ; If not zero, continue searching 
0e69			 
0e69			    ; If we reached here, pointer is not found in heap 
0e69			    ret 
0e69			 
0e69			free_exit: 
0e69			    ret                 ; Return 
0e69			 
0e69			; Define heap start and end addresses 
0e69			;heap_start:    .dw 0xC000   ; Start of heap 
0e69			;heap_end:      .dw 0xE000   ; End of heap 
0e69			 
0e69			endif 
0e69			 
0e69			 
0e69			if MALLOC_1 
0e69			 
0e69			 
0e69			 
0e69			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
0e69			 
0e69			;moved to firmware.asm 
0e69			;heap_start        .equ  0x9000      ; Starting address of heap 
0e69			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
0e69			 
0e69			;      .org 0 
0e69			;      jp    main 
0e69			 
0e69			 
0e69			;      .org  0x100 
0e69			;main: 
0e69			;      ld    HL, 0x8100 
0e69			;      ld    SP, HL 
0e69			; 
0e69			;      call  heap_init 
0e69			; 
0e69			;      ; Make some allocations 
0e69			;      ld    HL, 12 
0e69			;      call  malloc            ; Allocates 0x9004 
0e69			; 
0e69			;      ld    HL, 12 
0e69			;      call  malloc            ; Allocates 0x9014 
0e69			; 
0e69			;      ld    HL, 12 
0e69			;      call  malloc            ; Allocates 0x9024 
0e69			; 
0e69			;      ; Free some allocations 
0e69			;      ld    HL, 0x9014 
0e69			;      call  free 
0e69			; 
0e69			;      ld    HL, 0x9004 
0e69			;      call  free 
0e69			; 
0e69			;      ld    HL, 0x9024 
0e69			;      call  free 
0e69			; 
0e69			; 
0e69			;      halt 
0e69			 
0e69			 
0e69			;------------------------------------------------------------------------------ 
0e69			;     heap_init                                                               : 
0e69			;                                                                             : 
0e69			; Description                                                                 : 
0e69			;     Initialise the heap and make it ready for malloc and free operations.   : 
0e69			;                                                                             : 
0e69			;     The heap is maintained as a linked list, starting with an initial       : 
0e69			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
0e69			;     the first free block in the heap. Each block then points to the next    : 
0e69			;     free block within the heap, and the free list ends at the first block   : 
0e69			;     with a null pointer to the next free block.                             : 
0e69			;                                                                             : 
0e69			; Parameters                                                                  : 
0e69			;     Inputs are compile-time only. Two defines which specify the starting    : 
0e69			;     address of the heap and its size are required, along with a memory      : 
0e69			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
0e69			;     principally stores a pointer to the first free block in the heap.       : 
0e69			;                                                                             : 
0e69			; Returns                                                                     : 
0e69			;     Nothing                                                                 : 
0e69			;------------------------------------------------------------------------------ 
0e69			heap_init: 
0e69 e5			      push  HL 
0e6a			 
0e6a			      ; Initialise free list struct 
0e6a 21 d4 47		      ld    HL, heap_start 
0e6d 22 cf 47		      ld    (free_list), HL 
0e70 21 00 00		      ld    HL, 0 
0e73 22 d1 47		      ld    (free_list+2), HL 
0e76			 
0e76			      ; Insert first free block at bottom of heap, consumes entire heap 
0e76 21 65 e3		      ld    HL, heap_start+heap_size-4 
0e79 22 d4 47		      ld    (heap_start), HL        ; Next block (end of free list) 
0e7c 21 91 9b		      ld    HL, heap_size-4 
0e7f 22 d6 47		      ld    (heap_start+2), HL      ; Block size 
0e82			 
0e82			      ; Insert end of free list block at top of heap - two null words will 
0e82			      ; terminate the free list 
0e82 21 00 00		      ld    HL, 0 
0e85 22 67 e3		      ld    (heap_start+heap_size-2), HL 
0e88 22 65 e3		      ld    (heap_start+heap_size-4), HL 
0e8b			 
0e8b e1			      pop   HL 
0e8c			 
0e8c c9			      ret 
0e8d			 
0e8d			 
0e8d			;------------------------------------------------------------------------------ 
0e8d			;     malloc                                                                  : 
0e8d			;                                                                             : 
0e8d			; Description                                                                 : 
0e8d			;     Allocates the wanted space from the heap and returns the address of the : 
0e8d			;     first useable byte of the allocation.                                   : 
0e8d			;                                                                             : 
0e8d			;     Allocations can happen in one of two ways:                              : 
0e8d			;                                                                             : 
0e8d			;     1. A free block may be found which is the exact size wanted. In this    : 
0e8d			;        case the block is removed from the free list and retuedn to the      : 
0e8d			;        caller.                                                              : 
0e8d			;     2. A free block may be found which is larger than the size wanted. In   : 
0e8d			;        this case, the larger block is split into two. The first portion of  : 
0e8d			;        this block will become the requested space by the malloc call and    : 
0e8d			;        is returned to the caller. The second portion becomes a new free     : 
0e8d			;        block, and the free list is adjusted to maintain continuity via this : 
0e8d			;        newly created block.                                                 : 
0e8d			;                                                                             : 
0e8d			;     malloc does not set any initial value in the allocated space, the       : 
0e8d			;     caller is required to do this as required.                              : 
0e8d			;                                                                             : 
0e8d			;     This implementation of malloc uses the stack exclusively, and is        : 
0e8d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
0e8d			;     advisable to disable interrupts before calling malloc, and recommended  : 
0e8d			;     to avoid the use of malloc inside ISRs in general.                      : 
0e8d			;                                                                             : 
0e8d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
0e8d			;                                                                             : 
0e8d			; Parameters                                                                  : 
0e8d			;     HL  Number of bytes wanted                                              : 
0e8d			;                                                                             : 
0e8d			; Returns                                                                     : 
0e8d			;     HL  Address of the first useable byte of the allocation                 : 
0e8d			;                                                                             : 
0e8d			; Flags                                                                       : 
0e8d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
0e8d			;                                                                             : 
0e8d			; Stack frame                                                                 : 
0e8d			;       |             |                                                       : 
0e8d			;       +-------------+                                                       : 
0e8d			;       |     BC      |                                                       : 
0e8d			;       +-------------+                                                       : 
0e8d			;       |     DE      |                                                       : 
0e8d			;       +-------------+                                                       : 
0e8d			;       |     IX      |                                                       : 
0e8d			;       +-------------+                                                       : 
0e8d			;       |  prev_free  |                                                       : 
0e8d			;   +4  +-------------+                                                       : 
0e8d			;       |  this_free  |                                                       : 
0e8d			;   +2  +-------------+                                                       : 
0e8d			;       |  next_free  |                                                       : 
0e8d			;   +0  +-------------+                                                       : 
0e8d			;       |             |                                                       : 
0e8d			;                                                                             : 
0e8d			;------------------------------------------------------------------------------ 
0e8d			 
0e8d			 
0e8d			;malloc: 
0e8d			; 
0e8d			;	SAVESP ON 1 
0e8d			; 
0e8d			;	call malloc_code 
0e8d			; 
0e8d			;	CHECKSP ON 1 
0e8d			;	ret 
0e8d			 
0e8d			 
0e8d			malloc: 
0e8d c5			      push  BC 
0e8e d5			      push  DE 
0e8f dd e5		      push  IX 
0e91			if DEBUG_FORTH_MALLOC_HIGH 
0e91			call malloc_guard_entry 
0e91			endif 
0e91			 
0e91					if DEBUG_FORTH_MALLOC 
0e91						DMARK "mal" 
0e91						CALLMONITOR 
0e91					endif 
0e91 7c			      ld    A, H                    ; Exit if no space requested 
0e92 b5			      or    L 
0e93 ca 52 0f		      jp    Z, malloc_early_exit 
0e96			 
0e96			;inc hl 
0e96			;inc hl 
0e96			;inc hl 
0e96			; 
0e96			;inc hl 
0e96			;inc hl 
0e96			;inc hl 
0e96			;inc hl 
0e96			;inc hl 
0e96			;inc hl 
0e96			;inc hl 
0e96			;inc hl 
0e96			;inc hl 
0e96			 
0e96			 
0e96			 
0e96			 
0e96					if DEBUG_FORTH_MALLOC 
0e96						DMARK "maA" 
0e96						CALLMONITOR 
0e96					endif 
0e96			      ; Set up stack frame 
0e96 eb			      ex    DE, HL 
0e97 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
0e9a 39			      add   HL, SP 
0e9b f9			      ld    SP, HL 
0e9c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
0ea0 dd 39		      add   IX, SP 
0ea2			 
0ea2			      ; Setup initial state 
0ea2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
0ea5 19			      add   HL, DE 
0ea6			 
0ea6 44			      ld    B, H                    ; Move want to BC 
0ea7 4d			      ld    C, L 
0ea8			 
0ea8 21 cf 47		      ld    HL, free_list           ; Store prev_free ptr to stack 
0eab dd 75 04		      ld    (IX+4), L 
0eae dd 74 05		      ld    (IX+5), H 
0eb1			 
0eb1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
0eb2 23			      inc   HL 
0eb3 56			      ld    D, (HL) 
0eb4 dd 73 02		      ld    (IX+2), E 
0eb7 dd 72 03		      ld    (IX+3), D 
0eba eb			      ex    DE, HL                  ; this_free ptr into HL 
0ebb			 
0ebb					if DEBUG_FORTH_MALLOC 
0ebb						DMARK "maB" 
0ebb						CALLMONITOR 
0ebb					endif 
0ebb			      ; Loop through free block list to find some space 
0ebb			malloc_find_space: 
0ebb 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
0ebc 23			      inc   HL 
0ebd 56			      ld    D, (HL) 
0ebe			 
0ebe 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
0ebf b3			      or    E 
0ec0 ca 4c 0f		      jp    Z, malloc_no_space 
0ec3			 
0ec3 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
0ec6 dd 72 01		      ld    (IX+1), D 
0ec9			 
0ec9			      ; Does this block have enough space to make the allocation? 
0ec9 23			      inc   HL                      ; Load free block size into DE 
0eca 5e			      ld    E, (HL) 
0ecb 23			      inc   HL 
0ecc 56			      ld    D, (HL) 
0ecd			 
0ecd eb			      ex    DE, HL                  ; Check size of block against want 
0ece b7			      or    A                       ; Ensure carry flag clear 
0ecf ed 42		      sbc   HL, BC 
0ed1 e5			      push  HL                      ; Store the result for later (new block size) 
0ed2			 
0ed2 ca 21 0f		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
0ed5 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
0ed7			 
0ed7			      ; this_free block is not big enough, setup ptrs to test next free block 
0ed7 e1			      pop   HL                      ; Discard previous result 
0ed8			 
0ed8 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
0edb dd 66 03		      ld    H, (IX+3) 
0ede dd 75 04		      ld    (IX+4), L 
0ee1 dd 74 05		      ld    (IX+5), H 
0ee4			 
0ee4 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
0ee7 dd 66 01		      ld    H, (IX+1) 
0eea dd 75 02		      ld    (IX+2), L 
0eed dd 74 03		      ld    (IX+3), H 
0ef0			 
0ef0					if DEBUG_FORTH_MALLOC 
0ef0						DMARK "MA>" 
0ef0						CALLMONITOR 
0ef0					endif 
0ef0 18 c9		      jr    malloc_find_space 
0ef2			 
0ef2			      ; split a bigger block into two - requested size and remaining size 
0ef2			malloc_alloc_split: 
0ef2					if DEBUG_FORTH_MALLOC 
0ef2						DMARK "MAs" 
0ef2						CALLMONITOR 
0ef2					endif 
0ef2 eb			      ex    DE, HL                  ; Calculate address of new free block 
0ef3 2b			      dec   HL 
0ef4 2b			      dec   HL 
0ef5 2b			      dec   HL 
0ef6 09			      add   HL, BC 
0ef7			 
0ef7			      ; Create a new block and point it at next_free 
0ef7 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
0efa dd 56 01		      ld    D, (IX+1) 
0efd			 
0efd 73			      ld    (HL), E                 ; Store next_free ptr into new block 
0efe 23			      inc   HL 
0eff 72			      ld    (HL), D 
0f00			 
0f00 d1			      pop   DE                      ; Store size of new block into new block 
0f01 23			      inc   HL 
0f02 73			      ld    (HL), E 
0f03 23			      inc   HL 
0f04 72			      ld    (HL), D 
0f05			 
0f05			      ; Update this_free ptr to point to new block 
0f05 2b			      dec   HL 
0f06 2b			      dec   HL 
0f07 2b			      dec   HL 
0f08			 
0f08 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
0f0b dd 56 03		      ld    D, (IX+3) 
0f0e			 
0f0e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
0f11 dd 74 03		      ld    (IX+3), H 
0f14			 
0f14			      ; Modify this_free block to be allocation 
0f14 eb			      ex    DE, HL 
0f15 af			      xor   A                       ; Null the next block ptr of allocated block 
0f16 77			      ld    (HL), A 
0f17 23			      inc   HL 
0f18 77			      ld    (HL), A 
0f19			 
0f19 23			      inc   HL                      ; Store want size into allocated block 
0f1a 71			      ld    (HL), C 
0f1b 23			      inc   HL 
0f1c 70			      ld    (HL), B 
0f1d 23			      inc   HL 
0f1e e5			      push  HL                      ; Address of allocation to return 
0f1f			 
0f1f 18 19		      jr    malloc_update_links 
0f21			 
0f21			malloc_alloc_fit: 
0f21 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
0f22			 
0f22					if DEBUG_FORTH_MALLOC 
0f22						DMARK "MAf" 
0f22						CALLMONITOR 
0f22					endif 
0f22			      ; Modify this_free block to be allocation 
0f22 eb			      ex    DE, HL 
0f23 2b			      dec   HL 
0f24 2b			      dec   HL 
0f25 2b			      dec   HL 
0f26			 
0f26 af			      xor   A                       ; Null the next block ptr of allocated block 
0f27 77			      ld    (HL), A 
0f28 23			      inc   HL 
0f29 77			      ld    (HL), A 
0f2a			 
0f2a 23			      inc   HL                      ; Store address of allocation to return 
0f2b 23			      inc   HL 
0f2c 23			      inc   HL 
0f2d e5			      push  HL 
0f2e			 
0f2e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
0f2e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
0f31 dd 66 01		      ld    H, (IX+1) 
0f34			 
0f34 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
0f37 dd 74 03		      ld    (IX+3), H 
0f3a			 
0f3a			 
0f3a			malloc_update_links: 
0f3a			      ; Update prev_free ptr to point to this_free 
0f3a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
0f3d dd 66 05		      ld    H, (IX+5) 
0f40			 
0f40 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
0f43 dd 56 03		      ld    D, (IX+3) 
0f46			 
0f46 73			      ld    (HL), E                 ; this_free ptr into prev_free 
0f47 23			      inc   HL 
0f48 72			      ld    (HL), D 
0f49			 
0f49					if DEBUG_FORTH_MALLOC 
0f49						DMARK "Mul" 
0f49						CALLMONITOR 
0f49					endif 
0f49			      ; Clear the Z flag to indicate successful allocation 
0f49 7a			      ld    A, D 
0f4a b3			      or    E 
0f4b			 
0f4b d1			      pop   DE                      ; Address of allocation 
0f4c					if DEBUG_FORTH_MALLOC 
0f4c						DMARK "MAu" 
0f4c						CALLMONITOR 
0f4c					endif 
0f4c			 
0f4c			malloc_no_space: 
0f4c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
0f4f 39			      add   HL, SP 
0f50 f9			      ld    SP, HL 
0f51			 
0f51 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
0f52					if DEBUG_FORTH_MALLOC 
0f52						DMARK "MAN" 
0f52						CALLMONITOR 
0f52					endif 
0f52			 
0f52			malloc_early_exit: 
0f52					if DEBUG_FORTH_MALLOC 
0f52						DMARK "MAx" 
0f52						CALLMONITOR 
0f52					endif 
0f52 dd e1		      pop   IX 
0f54 d1			      pop   DE 
0f55 c1			      pop   BC 
0f56			 
0f56			if DEBUG_FORTH_MALLOC_HIGH 
0f56			call malloc_guard_exit 
0f56			call malloc_guard_zerolen 
0f56			endif 
0f56 c9			      ret 
0f57			 
0f57			 
0f57			;------------------------------------------------------------------------------ 
0f57			;     free                                                                    : 
0f57			;                                                                             : 
0f57			; Description                                                                 : 
0f57			;     Return the space pointed to by HL to the heap. HL must be an address as : 
0f57			;     returned by malloc, otherwise the behaviour is undefined.               : 
0f57			;                                                                             : 
0f57			;     Where possible, directly adjacent free blocks will be merged together   : 
0f57			;     into larger blocks to help ensure that the heap does not become         : 
0f57			;     excessively fragmented.                                                 : 
0f57			;                                                                             : 
0f57			;     free does not clear or set any other value into the freed space, and    : 
0f57			;     therefore its contents may be visible through subsequent malloc's. The  : 
0f57			;     caller should clear the freed space as required.                        : 
0f57			;                                                                             : 
0f57			;     This implementation of free uses the stack exclusively, and is          : 
0f57			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
0f57			;     advisable to disable interrupts before calling free, and recommended    : 
0f57			;     to avoid the use of free inside ISRs in general.                        : 
0f57			;                                                                             : 
0f57			;     NOTE: heap_init must be called before malloc and free can be used.      : 
0f57			;                                                                             : 
0f57			; Parameters                                                                  : 
0f57			;     HL  Pointer to address of first byte of allocation to be freed          : 
0f57			;                                                                             : 
0f57			; Returns                                                                     : 
0f57			;     Nothing                                                                 : 
0f57			;                                                                             : 
0f57			; Stack frame                                                                 : 
0f57			;       |             |                                                       : 
0f57			;       +-------------+                                                       : 
0f57			;       |     BC      |                                                       : 
0f57			;       +-------------+                                                       : 
0f57			;       |     DE      |                                                       : 
0f57			;       +-------------+                                                       : 
0f57			;       |     IX      |                                                       : 
0f57			;       +-------------+                                                       : 
0f57			;       |  prev_free  |                                                       : 
0f57			;   +2  +-------------+                                                       : 
0f57			;       |  next_free  |                                                       : 
0f57			;   +0  +-------------+                                                       : 
0f57			;       |             |                                                       : 
0f57			;                                                                             : 
0f57			;------------------------------------------------------------------------------ 
0f57			free: 
0f57 c5			      push  BC 
0f58 d5			      push  DE 
0f59 dd e5		      push  IX 
0f5b			 
0f5b 7c			      ld    A, H                    ; Exit if ptr is null 
0f5c b5			      or    L 
0f5d ca 21 10		      jp    Z, free_early_exit 
0f60			 
0f60			      ; Set up stack frame 
0f60 eb			      ex    DE, HL 
0f61 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
0f64 39			      add   HL, SP 
0f65 f9			      ld    SP, HL 
0f66 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
0f6a dd 39		      add   IX, SP 
0f6c			 
0f6c			      ; The address in HL points to the start of the useable allocated space, 
0f6c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
0f6c			      ; address of the block itself. 
0f6c eb			      ex    DE, HL 
0f6d 11 fc ff		      ld    DE, -4 
0f70 19			      add   HL, DE 
0f71			 
0f71			      ; An allocated block must have a null next block pointer in it 
0f71 7e			      ld    A, (HL) 
0f72 23			      inc   HL 
0f73 b6			      or    (HL) 
0f74 c2 1c 10		      jp    NZ, free_done 
0f77			 
0f77 2b			      dec   HL 
0f78			 
0f78 44			      ld    B, H                    ; Copy HL to BC 
0f79 4d			      ld    C, L 
0f7a			 
0f7a			      ; Loop through the free list to find the first block with an address 
0f7a			      ; higher than the block being freed 
0f7a 21 cf 47		      ld    HL, free_list 
0f7d			 
0f7d			free_find_higher_block: 
0f7d 5e			      ld    E, (HL)                 ; Load next ptr from free block 
0f7e 23			      inc   HL 
0f7f 56			      ld    D, (HL) 
0f80 2b			      dec   HL 
0f81			 
0f81 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
0f84 dd 72 01		      ld    (IX+1), D 
0f87 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
0f8a dd 74 03		      ld    (IX+3), H 
0f8d			 
0f8d 78			      ld    A, B                    ; Check if DE is greater than BC 
0f8e ba			      cp    D                       ; Compare MSB first 
0f8f 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
0f91 30 04		      jr    NC, free_find_higher_block_skip 
0f93 79			      ld    A, C 
0f94 bb			      cp    E                       ; Then compare LSB 
0f95 38 08		      jr    C, free_found_higher_block 
0f97			 
0f97			free_find_higher_block_skip: 
0f97 7a			      ld    A, D                    ; Reached the end of the free list? 
0f98 b3			      or    E 
0f99 ca 1c 10		      jp    Z, free_done 
0f9c			 
0f9c eb			      ex    DE, HL 
0f9d			 
0f9d 18 de		      jr    free_find_higher_block 
0f9f			 
0f9f			free_found_higher_block: 
0f9f			      ; Insert freed block between prev and next free blocks 
0f9f 71			      ld    (HL), C                 ; Point prev free block to freed block 
0fa0 23			      inc   HL 
0fa1 70			      ld    (HL), B 
0fa2			 
0fa2 60			      ld    H, B                    ; Point freed block at next free block 
0fa3 69			      ld    L, C 
0fa4 73			      ld    (HL), E 
0fa5 23			      inc   HL 
0fa6 72			      ld    (HL), D 
0fa7			 
0fa7			      ; Check if the freed block is adjacent to the next free block 
0fa7 23			      inc   HL                      ; Load size of freed block into HL 
0fa8 5e			      ld    E, (HL) 
0fa9 23			      inc   HL 
0faa 56			      ld    D, (HL) 
0fab eb			      ex    DE, HL 
0fac			 
0fac 09			      add   HL, BC                  ; Add addr of freed block and its size 
0fad			 
0fad dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
0fb0 dd 56 01		      ld    D, (IX+1) 
0fb3			 
0fb3 b7			      or    A                       ; Clear the carry flag 
0fb4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
0fb6 20 22		      jr    NZ, free_check_adjacent_to_prev 
0fb8			 
0fb8			      ; Freed block is adjacent to next, merge into one bigger block 
0fb8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
0fb9 5e			      ld    E, (HL) 
0fba 23			      inc   HL 
0fbb 56			      ld    D, (HL) 
0fbc e5			      push  HL                      ; Save ptr to next block for later 
0fbd			 
0fbd 60			      ld    H, B                    ; Store ptr from next block into freed block 
0fbe 69			      ld    L, C 
0fbf 73			      ld    (HL), E 
0fc0 23			      inc   HL 
0fc1 72			      ld    (HL), D 
0fc2			 
0fc2 e1			      pop   HL                      ; Restore ptr to next block 
0fc3 23			      inc   HL                      ; Load size of next block into DE 
0fc4 5e			      ld    E, (HL) 
0fc5 23			      inc   HL 
0fc6 56			      ld    D, (HL) 
0fc7 d5			      push  DE                      ; Save next block size for later 
0fc8			 
0fc8 60			      ld    H, B                    ; Load size of freed block into HL 
0fc9 69			      ld    L, C 
0fca 23			      inc   HL 
0fcb 23			      inc   HL 
0fcc 5e			      ld    E, (HL) 
0fcd 23			      inc   HL 
0fce 56			      ld    D, (HL) 
0fcf eb			      ex    DE, HL 
0fd0			 
0fd0 d1			      pop   DE                      ; Restore size of next block 
0fd1 19			      add   HL, DE                  ; Add sizes of both blocks 
0fd2 eb			      ex    DE, HL 
0fd3			 
0fd3 60			      ld    H, B                    ; Store new bigger size into freed block 
0fd4 69			      ld    L, C 
0fd5 23			      inc   HL 
0fd6 23			      inc   HL 
0fd7 73			      ld    (HL), E 
0fd8 23			      inc   HL 
0fd9 72			      ld    (HL), D 
0fda			 
0fda			free_check_adjacent_to_prev: 
0fda			      ; Check if the freed block is adjacent to the prev free block 
0fda dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
0fdd dd 66 03		      ld    H, (IX+3) 
0fe0			 
0fe0 23			      inc   HL                      ; Size of prev free block into DE 
0fe1 23			      inc   HL 
0fe2 5e			      ld    E, (HL) 
0fe3 23			      inc   HL 
0fe4 56			      ld    D, (HL) 
0fe5 2b			      dec   HL 
0fe6 2b			      dec   HL 
0fe7 2b			      dec   HL 
0fe8			 
0fe8 19			      add   HL, DE                  ; Add prev block addr and size 
0fe9			 
0fe9 b7			      or    A                       ; Clear the carry flag 
0fea ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
0fec 20 2e		      jr    NZ, free_done 
0fee			 
0fee			      ; Freed block is adjacent to prev, merge into one bigger block 
0fee 60			      ld    H, B                    ; Load next ptr from freed block into DE 
0fef 69			      ld    L, C 
0ff0 5e			      ld    E, (HL) 
0ff1 23			      inc   HL 
0ff2 56			      ld    D, (HL) 
0ff3 e5			      push  HL                      ; Save freed block ptr for later 
0ff4			 
0ff4 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
0ff7 dd 66 03		      ld    H, (IX+3) 
0ffa 73			      ld    (HL), E 
0ffb 23			      inc   HL 
0ffc 72			      ld    (HL), D 
0ffd			 
0ffd e1			      pop   HL                      ; Restore freed block ptr 
0ffe 23			      inc   HL                      ; Load size of freed block into DE 
0fff 5e			      ld    E, (HL) 
1000 23			      inc   HL 
1001 56			      ld    D, (HL) 
1002 d5			      push  DE                      ; Save freed block size for later 
1003			 
1003 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1006 dd 66 03		      ld    H, (IX+3) 
1009 23			      inc   HL 
100a 23			      inc   HL 
100b 5e			      ld    E, (HL) 
100c 23			      inc   HL 
100d 56			      ld    D, (HL) 
100e			 
100e e1			      pop   HL                      ; Add sizes of both blocks 
100f 19			      add   HL, DE 
1010 eb			      ex    DE, HL 
1011			 
1011 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1014 dd 66 03		      ld    H, (IX+3) 
1017 23			      inc   HL 
1018 23			      inc   HL 
1019 73			      ld    (HL), E 
101a 23			      inc   HL 
101b 72			      ld    (HL), D 
101c			 
101c			free_done: 
101c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
101f 39			      add   HL, SP 
1020 f9			      ld    SP, HL 
1021			 
1021			free_early_exit: 
1021 dd e1		      pop   IX 
1023 d1			      pop   DE 
1024 c1			      pop   BC 
1025			 
1025 c9			      ret 
1026			 
1026			; moved to firmware.asm 
1026			; 
1026			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1026			;                  .dw   0 
1026			 
1026			 
1026			endif 
1026			 
1026			 
1026			if MALLOC_3 
1026			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1026			;heap_start        .equ  0x9000      ; Starting address of heap 
1026			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1026			; 
1026			 ;     .org 0 
1026			  ;    jp    main 
1026			; 
1026			; 
1026			 ;     .org  0x100 
1026			;main: 
1026			 ;     ld    HL, 0x8100 
1026			  ;    ld    SP, HL 
1026			; 
1026			;      call  heap_init 
1026			 
1026			      ; Make some allocations 
1026			;      ld    HL, 12 
1026			;      call  malloc            ; Allocates 0x9004 
1026			; 
1026			 ;     ld    HL, 12 
1026			;      call  malloc            ; Allocates 0x9014 
1026			 
1026			;      ld    HL, 12 
1026			;      call  malloc            ; Allocates 0x9024 
1026			 
1026			      ; Free some allocations 
1026			;      ld    HL, 0x9014 
1026			;      call  free 
1026			 
1026			;      ld    HL, 0x9004 
1026			;      call  free 
1026			; 
1026			;      ld    HL, 0x9024 
1026			;      call  free 
1026			 
1026			 
1026			 ;     halt 
1026			 
1026			 
1026			;------------------------------------------------------------------------------ 
1026			;     heap_init                                                               : 
1026			;                                                                             : 
1026			; Description                                                                 : 
1026			;     Initialise the heap and make it ready for malloc and free operations.   : 
1026			;                                                                             : 
1026			;     The heap is maintained as a linked list, starting with an initial       : 
1026			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1026			;     the first free block in the heap. Each block then points to the next    : 
1026			;     free block within the heap, and the free list ends at the first block   : 
1026			;     with a null pointer to the next free block.                             : 
1026			;                                                                             : 
1026			; Parameters                                                                  : 
1026			;     Inputs are compile-time only. Two defines which specify the starting    : 
1026			;     address of the heap and its size are required, along with a memory      : 
1026			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1026			;     principally stores a pointer to the first free block in the heap.       : 
1026			;                                                                             : 
1026			; Returns                                                                     : 
1026			;     Nothing                                                                 : 
1026			;------------------------------------------------------------------------------ 
1026			heap_init: 
1026			      push  HL 
1026			 
1026			      ; Initialise free list struct 
1026			      ld    HL, heap_start 
1026			      ld    (free_list), HL 
1026			      ld    HL, 0 
1026			      ld    (free_list+2), HL 
1026			 
1026			      ; Insert first free block at bottom of heap, consumes entire heap 
1026			      ld    HL, heap_start+heap_size-4 
1026			      ld    (heap_start), HL        ; Next block (end of free list) 
1026			      ld    HL, heap_size-4 
1026			      ld    (heap_start+2), HL      ; Block size 
1026			 
1026			      ; Insert end of free list block at top of heap - two null words will 
1026			      ; terminate the free list 
1026			      ld    HL, 0 
1026			      ld    (heap_start+heap_size-2), HL 
1026			      ld    (heap_start+heap_size-4), HL 
1026			 
1026			      pop   HL 
1026			 
1026			      ret 
1026			 
1026			 
1026			;------------------------------------------------------------------------------ 
1026			;     malloc                                                                  : 
1026			;                                                                             : 
1026			; Description                                                                 : 
1026			;     Allocates the wanted space from the heap and returns the address of the : 
1026			;     first useable byte of the allocation.                                   : 
1026			;                                                                             : 
1026			;     Allocations can happen in one of two ways:                              : 
1026			;                                                                             : 
1026			;     1. A free block may be found which is the exact size wanted. In this    : 
1026			;        case the block is removed from the free list and retuedn to the      : 
1026			;        caller.                                                              : 
1026			;     2. A free block may be found which is larger than the size wanted. In   : 
1026			;        this case, the larger block is split into two. The first portion of  : 
1026			;        this block will become the requested space by the malloc call and    : 
1026			;        is returned to the caller. The second portion becomes a new free     : 
1026			;        block, and the free list is adjusted to maintain continuity via this : 
1026			;        newly created block.                                                 : 
1026			;                                                                             : 
1026			;     malloc does not set any initial value in the allocated space, the       : 
1026			;     caller is required to do this as required.                              : 
1026			;                                                                             : 
1026			;     This implementation of malloc uses the stack exclusively, and is        : 
1026			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1026			;     advisable to disable interrupts before calling malloc, and recommended  : 
1026			;     to avoid the use of malloc inside ISRs in general.                      : 
1026			;                                                                             : 
1026			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1026			;                                                                             : 
1026			; Parameters                                                                  : 
1026			;     HL  Number of bytes wanted                                              : 
1026			;                                                                             : 
1026			; Returns                                                                     : 
1026			;     HL  Address of the first useable byte of the allocation                 : 
1026			;                                                                             : 
1026			; Flags                                                                       : 
1026			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1026			;                                                                             : 
1026			; Stack frame                                                                 : 
1026			;       |             |                                                       : 
1026			;       +-------------+                                                       : 
1026			;       |     BC      |                                                       : 
1026			;       +-------------+                                                       : 
1026			;       |     DE      |                                                       : 
1026			;       +-------------+                                                       : 
1026			;       |     IX      |                                                       : 
1026			;       +-------------+                                                       : 
1026			;       |  prev_free  |                                                       : 
1026			;   +4  +-------------+                                                       : 
1026			;       |  this_free  |                                                       : 
1026			;   +2  +-------------+                                                       : 
1026			;       |  next_free  |                                                       : 
1026			;   +0  +-------------+                                                       : 
1026			;       |             |                                                       : 
1026			;                                                                             : 
1026			;------------------------------------------------------------------------------ 
1026			malloc: 
1026			      push  BC 
1026			      push  DE 
1026			      push  IX 
1026			 
1026			      ld    A, H                    ; Exit if no space requested 
1026			      or    L 
1026			      jp    Z, malloc_early_exit 
1026			 
1026			      ; Set up stack frame 
1026			      ex    DE, HL 
1026			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1026			      add   HL, SP 
1026			      ld    SP, HL 
1026			      ld    IX, 0                   ; Use IX as a frame pointer 
1026			      add   IX, SP 
1026			 
1026			      ; Setup initial state 
1026			      ld    HL, 4                   ; want must also include space used by block struct 
1026			      add   HL, DE 
1026			 
1026			      ld    B, H                    ; Move want to BC 
1026			      ld    C, L 
1026			 
1026			      ld    HL, free_list           ; Store prev_free ptr to stack 
1026			      ld    (IX+4), L 
1026			      ld    (IX+5), H 
1026			 
1026			      ld    E, (HL)                 ; Store this_free ptr to stack 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			      ld    (IX+2), E 
1026			      ld    (IX+3), D 
1026			      ex    DE, HL                  ; this_free ptr into HL 
1026			 
1026			      ; Loop through free block list to find some space 
1026			malloc_find_space: 
1026			      ld    E, (HL)                 ; Load next_free ptr into DE 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			 
1026			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1026			      or    E 
1026			      jp    Z, malloc_no_space 
1026			 
1026			      ld    (IX+0), E               ; Store next_free ptr to stack 
1026			      ld    (IX+1), D 
1026			 
1026			      ; Does this block have enough space to make the allocation? 
1026			      inc   HL                      ; Load free block size into DE 
1026			      ld    E, (HL) 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			 
1026			      ex    DE, HL                  ; Check size of block against want 
1026			      or    A                       ; Ensure carry flag clear 
1026			      sbc   HL, BC 
1026			      push  HL                      ; Store the result for later (new block size) 
1026			 
1026			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1026			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1026			 
1026			      ; this_free block is not big enough, setup ptrs to test next free block 
1026			      pop   HL                      ; Discard previous result 
1026			 
1026			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1026			      ld    H, (IX+3) 
1026			      ld    (IX+4), L 
1026			      ld    (IX+5), H 
1026			 
1026			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1026			      ld    H, (IX+1) 
1026			      ld    (IX+2), L 
1026			      ld    (IX+3), H 
1026			 
1026			      jr    malloc_find_space 
1026			 
1026			      ; split a bigger block into two - requested size and remaining size 
1026			malloc_alloc_split: 
1026			      ex    DE, HL                  ; Calculate address of new free block 
1026			      dec   HL 
1026			      dec   HL 
1026			      dec   HL 
1026			      add   HL, BC 
1026			 
1026			      ; Create a new block and point it at next_free 
1026			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1026			      ld    D, (IX+1) 
1026			 
1026			      ld    (HL), E                 ; Store next_free ptr into new block 
1026			      inc   HL 
1026			      ld    (HL), D 
1026			 
1026			      pop   DE                      ; Store size of new block into new block 
1026			      inc   HL 
1026			      ld    (HL), E 
1026			      inc   HL 
1026			      ld    (HL), D 
1026			 
1026			      ; Update this_free ptr to point to new block 
1026			      dec   HL 
1026			      dec   HL 
1026			      dec   HL 
1026			 
1026			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1026			      ld    D, (IX+3) 
1026			 
1026			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1026			      ld    (IX+3), H 
1026			 
1026			      ; Modify this_free block to be allocation 
1026			      ex    DE, HL 
1026			      xor   A                       ; Null the next block ptr of allocated block 
1026			      ld    (HL), A 
1026			      inc   HL 
1026			      ld    (HL), A 
1026			 
1026			      inc   HL                      ; Store want size into allocated block 
1026			      ld    (HL), C 
1026			      inc   HL 
1026			      ld    (HL), B 
1026			      inc   HL 
1026			      push  HL                      ; Address of allocation to return 
1026			 
1026			      jr    malloc_update_links 
1026			 
1026			malloc_alloc_fit: 
1026			      pop   HL                      ; Dont need new block size, want is exact fit 
1026			 
1026			      ; Modify this_free block to be allocation 
1026			      ex    DE, HL 
1026			      dec   HL 
1026			      dec   HL 
1026			      dec   HL 
1026			 
1026			      xor   A                       ; Null the next block ptr of allocated block 
1026			      ld    (HL), A 
1026			      inc   HL 
1026			      ld    (HL), A 
1026			 
1026			      inc   HL                      ; Store address of allocation to return 
1026			      inc   HL 
1026			      inc   HL 
1026			      push  HL 
1026			 
1026			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1026			      ld    L, (IX+0)               ; next_free to HL 
1026			      ld    H, (IX+1) 
1026			 
1026			      ld    (IX+2), L               ; HL to this_free 
1026			      ld    (IX+3), H 
1026			 
1026			 
1026			malloc_update_links: 
1026			      ; Update prev_free ptr to point to this_free 
1026			      ld    L, (IX+4)               ; prev_free ptr to HL 
1026			      ld    H, (IX+5) 
1026			 
1026			      ld    E, (IX+2)               ; this_free ptr to DE 
1026			      ld    D, (IX+3) 
1026			 
1026			      ld    (HL), E                 ; this_free ptr into prev_free 
1026			      inc   HL 
1026			      ld    (HL), D 
1026			 
1026			      ; Clear the Z flag to indicate successful allocation 
1026			      ld    A, D 
1026			      or    E 
1026			 
1026			      pop   DE                      ; Address of allocation 
1026			 
1026			malloc_no_space: 
1026			      ld    HL, 6                   ; Clean up stack frame 
1026			      add   HL, SP 
1026			      ld    SP, HL 
1026			 
1026			      ex    DE, HL                  ; Alloc addr into HL for return 
1026			 
1026			malloc_early_exit: 
1026			      pop   IX 
1026			      pop   DE 
1026			      pop   BC 
1026			 
1026			      ret 
1026			 
1026			 
1026			;------------------------------------------------------------------------------ 
1026			;     free                                                                    : 
1026			;                                                                             : 
1026			; Description                                                                 : 
1026			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1026			;     returned by malloc, otherwise the behaviour is undefined.               : 
1026			;                                                                             : 
1026			;     Where possible, directly adjacent free blocks will be merged together   : 
1026			;     into larger blocks to help ensure that the heap does not become         : 
1026			;     excessively fragmented.                                                 : 
1026			;                                                                             : 
1026			;     free does not clear or set any other value into the freed space, and    : 
1026			;     therefore its contents may be visible through subsequent malloc's. The  : 
1026			;     caller should clear the freed space as required.                        : 
1026			;                                                                             : 
1026			;     This implementation of free uses the stack exclusively, and is          : 
1026			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1026			;     advisable to disable interrupts before calling free, and recommended    : 
1026			;     to avoid the use of free inside ISRs in general.                        : 
1026			;                                                                             : 
1026			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1026			;                                                                             : 
1026			; Parameters                                                                  : 
1026			;     HL  Pointer to address of first byte of allocation to be freed          : 
1026			;                                                                             : 
1026			; Returns                                                                     : 
1026			;     Nothing                                                                 : 
1026			;                                                                             : 
1026			; Stack frame                                                                 : 
1026			;       |             |                                                       : 
1026			;       +-------------+                                                       : 
1026			;       |     BC      |                                                       : 
1026			;       +-------------+                                                       : 
1026			;       |     DE      |                                                       : 
1026			;       +-------------+                                                       : 
1026			;       |     IX      |                                                       : 
1026			;       +-------------+                                                       : 
1026			;       |  prev_free  |                                                       : 
1026			;   +2  +-------------+                                                       : 
1026			;       |  next_free  |                                                       : 
1026			;   +0  +-------------+                                                       : 
1026			;       |             |                                                       : 
1026			;                                                                             : 
1026			;------------------------------------------------------------------------------ 
1026			free: 
1026			      push  BC 
1026			      push  DE 
1026			      push  IX 
1026			 
1026			      ld    A, H                    ; Exit if ptr is null 
1026			      or    L 
1026			      jp    Z, free_early_exit 
1026			 
1026			      ; Set up stack frame 
1026			      ex    DE, HL 
1026			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1026			      add   HL, SP 
1026			      ld    SP, HL 
1026			      ld    IX, 0                   ; Use IX as a frame pointer 
1026			      add   IX, SP 
1026			 
1026			      ; The address in HL points to the start of the useable allocated space, 
1026			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1026			      ; address of the block itself. 
1026			      ex    DE, HL 
1026			      ld    DE, -4 
1026			      add   HL, DE 
1026			 
1026			      ; An allocated block must have a null next block pointer in it 
1026			      ld    A, (HL) 
1026			      inc   HL 
1026			      or    (HL) 
1026			      jp    NZ, free_done 
1026			 
1026			      dec   HL 
1026			 
1026			      ld    B, H                    ; Copy HL to BC 
1026			      ld    C, L 
1026			 
1026			      ; Loop through the free list to find the first block with an address 
1026			      ; higher than the block being freed 
1026			      ld    HL, free_list 
1026			 
1026			free_find_higher_block: 
1026			      ld    E, (HL)                 ; Load next ptr from free block 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			      dec   HL 
1026			 
1026			      ld    (IX+0), E               ; Save ptr to next free block 
1026			      ld    (IX+1), D 
1026			      ld    (IX+2), L               ; Save ptr to prev free block 
1026			      ld    (IX+3), H 
1026			 
1026			      ld    A, B                    ; Check if DE is greater than BC 
1026			      cp    D                       ; Compare MSB first 
1026			      jr    Z, $+4                  ; MSB the same, compare LSB 
1026			      jr    NC, free_find_higher_block_skip 
1026			      ld    A, C 
1026			      cp    E                       ; Then compare LSB 
1026			      jr    C, free_found_higher_block 
1026			 
1026			free_find_higher_block_skip: 
1026			      ld    A, D                    ; Reached the end of the free list? 
1026			      or    E 
1026			      jp    Z, free_done 
1026			 
1026			      ex    DE, HL 
1026			 
1026			      jr    free_find_higher_block 
1026			 
1026			free_found_higher_block: 
1026			      ; Insert freed block between prev and next free blocks 
1026			      ld    (HL), C                 ; Point prev free block to freed block 
1026			      inc   HL 
1026			      ld    (HL), B 
1026			 
1026			      ld    H, B                    ; Point freed block at next free block 
1026			      ld    L, C 
1026			      ld    (HL), E 
1026			      inc   HL 
1026			      ld    (HL), D 
1026			 
1026			      ; Check if the freed block is adjacent to the next free block 
1026			      inc   HL                      ; Load size of freed block into HL 
1026			      ld    E, (HL) 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			      ex    DE, HL 
1026			 
1026			      add   HL, BC                  ; Add addr of freed block and its size 
1026			 
1026			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1026			      ld    D, (IX+1) 
1026			 
1026			      or    A                       ; Clear the carry flag 
1026			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1026			      jr    NZ, free_check_adjacent_to_prev 
1026			 
1026			      ; Freed block is adjacent to next, merge into one bigger block 
1026			      ex    DE, HL                  ; Load next ptr from next block into DE 
1026			      ld    E, (HL) 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			      push  HL                      ; Save ptr to next block for later 
1026			 
1026			      ld    H, B                    ; Store ptr from next block into freed block 
1026			      ld    L, C 
1026			      ld    (HL), E 
1026			      inc   HL 
1026			      ld    (HL), D 
1026			 
1026			      pop   HL                      ; Restore ptr to next block 
1026			      inc   HL                      ; Load size of next block into DE 
1026			      ld    E, (HL) 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			      push  DE                      ; Save next block size for later 
1026			 
1026			      ld    H, B                    ; Load size of freed block into HL 
1026			      ld    L, C 
1026			      inc   HL 
1026			      inc   HL 
1026			      ld    E, (HL) 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			      ex    DE, HL 
1026			 
1026			      pop   DE                      ; Restore size of next block 
1026			      add   HL, DE                  ; Add sizes of both blocks 
1026			      ex    DE, HL 
1026			 
1026			      ld    H, B                    ; Store new bigger size into freed block 
1026			      ld    L, C 
1026			      inc   HL 
1026			      inc   HL 
1026			      ld    (HL), E 
1026			      inc   HL 
1026			      ld    (HL), D 
1026			 
1026			free_check_adjacent_to_prev: 
1026			      ; Check if the freed block is adjacent to the prev free block 
1026			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1026			      ld    H, (IX+3) 
1026			 
1026			      inc   HL                      ; Size of prev free block into DE 
1026			      inc   HL 
1026			      ld    E, (HL) 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			      dec   HL 
1026			      dec   HL 
1026			      dec   HL 
1026			 
1026			      add   HL, DE                  ; Add prev block addr and size 
1026			 
1026			      or    A                       ; Clear the carry flag 
1026			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1026			      jr    NZ, free_done 
1026			 
1026			      ; Freed block is adjacent to prev, merge into one bigger block 
1026			      ld    H, B                    ; Load next ptr from freed block into DE 
1026			      ld    L, C 
1026			      ld    E, (HL) 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			      push  HL                      ; Save freed block ptr for later 
1026			 
1026			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1026			      ld    H, (IX+3) 
1026			      ld    (HL), E 
1026			      inc   HL 
1026			      ld    (HL), D 
1026			 
1026			      pop   HL                      ; Restore freed block ptr 
1026			      inc   HL                      ; Load size of freed block into DE 
1026			      ld    E, (HL) 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			      push  DE                      ; Save freed block size for later 
1026			 
1026			      ld    L, (IX+2)               ; Load size of prev block into DE 
1026			      ld    H, (IX+3) 
1026			      inc   HL 
1026			      inc   HL 
1026			      ld    E, (HL) 
1026			      inc   HL 
1026			      ld    D, (HL) 
1026			 
1026			      pop   HL                      ; Add sizes of both blocks 
1026			      add   HL, DE 
1026			      ex    DE, HL 
1026			 
1026			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1026			      ld    H, (IX+3) 
1026			      inc   HL 
1026			      inc   HL 
1026			      ld    (HL), E 
1026			      inc   HL 
1026			      ld    (HL), D 
1026			 
1026			free_done: 
1026			      ld    HL, 4                   ; Clean up stack frame 
1026			      add   HL, SP 
1026			      ld    SP, HL 
1026			 
1026			free_early_exit: 
1026			      pop   IX 
1026			      pop   DE 
1026			      pop   BC 
1026			 
1026			      ret 
1026			 
1026			 
1026			;      .org 0x8000 
1026			; 
1026			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1026			 ;                 .dw   0 
1026			 
1026			endif 
1026			 
1026			 
1026			if MALLOC_4 
1026			 
1026			; My memory allocation code. Very very simple.... 
1026			; allocate space under 250 chars 
1026			 
1026			heap_init: 
1026				; init start of heap as zero 
1026				;  
1026			 
1026				ld hl, heap_start 
1026				ld a, 0 
1026				ld (hl), a      ; empty block 
1026				inc hl 
1026				ld a, 0 
1026				ld (hl), a      ; length of block 
1026				; write end of list 
1026				inc hl 
1026				ld a,(hl) 
1026				inc hl 
1026				ld a,(hl) 
1026				 
1026			 
1026				; init some malloc vars 
1026			 
1026				ld hl, 0 
1026				ld (free_list), hl       ; store last malloc location 
1026			 
1026				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1026				ld a, 0 
1026				ld (hl), a 
1026			 
1026			 
1026				ld hl, heap_start 
1026				;  
1026				  
1026				ret 
1026			 
1026			 
1026			;    free block marker 
1026			;    requested size  
1026			;    pointer to next block 
1026			;    .... 
1026			;    next block marker 
1026			 
1026			 
1026			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1026			; 
1026			 
1026			 
1026			malloc:  
1026				push de 
1026				push bc 
1026				push af 
1026			 
1026				; hl space required 
1026				 
1026				ld c, l    ; hold space   (TODO only a max of 255) 
1026			 
1026			;	inc c     ; TODO BUG need to fix memory leak on push str 
1026			;	inc c 
1026			;	inc c 
1026			;	inc c 
1026			;	inc c 
1026			;	inc c 
1026			;	inc c 
1026			 
1026			 
1026			 
1026				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1026			 
1026				ld a, (free_list+3) 
1026				cp 0 
1026				jr z, .contheap 
1026			 
1026				ld hl, (free_list)     ; get last alloc 
1026					if DEBUG_FORTH_MALLOC_INT 
1026						DMARK "mrs" 
1026						CALLMONITOR 
1026					endif 
1026				jr .startalloc 
1026			 
1026			.contheap: 
1026				ld hl, heap_start 
1026			 
1026			.startalloc: 
1026			 
1026					if DEBUG_FORTH_MALLOC_INT 
1026						DMARK "mym" 
1026						CALLMONITOR 
1026					endif 
1026			.findblock: 
1026					if DEBUG_FORTH_MALLOC_INT 
1026						DMARK "mmf" 
1026						CALLMONITOR 
1026					endif 
1026			 
1026				ld a,(hl)  
1026				; if byte is zero then clear to use 
1026			 
1026				cp 0 
1026				jr z, .foundemptyblock 
1026			 
1026				; if byte is not clear 
1026				;     then byte is offset to next block 
1026			 
1026				inc hl 
1026				ld a, (hl) ; get size 
1026			.nextblock:	inc hl 
1026					ld e, (hl) 
1026					inc hl 
1026					ld d, (hl) 
1026					ex de, hl 
1026			;	inc hl  ; move past the store space 
1026			;	inc hl  ; move past zero index  
1026			 
1026				; TODO detect no more space 
1026			 
1026				push hl 
1026				ld de, heap_end 
1026				call cmp16 
1026				pop hl 
1026				jr nc, .nospace 
1026			 
1026				jr .findblock 
1026			 
1026			.nospace: ld hl, 0 
1026				jp .exit 
1026			 
1026			 
1026			.foundemptyblock:	 
1026					if DEBUG_FORTH_MALLOC_INT 
1026						DMARK "mme" 
1026						CALLMONITOR 
1026					endif 
1026			 
1026			; TODO has block enough space if reusing??? 
1026			 
1026				;  
1026			 
1026			; see if this block has been previously used 
1026				inc hl 
1026				ld a, (hl) 
1026				dec hl 
1026				cp 0 
1026				jr z, .newblock 
1026			 
1026					if DEBUG_FORTH_MALLOC_INT 
1026						DMARK "meR" 
1026						CALLMONITOR 
1026					endif 
1026			 
1026			; no reusing previously allocated block 
1026			 
1026			; is it smaller than previously used? 
1026				 
1026				inc hl    ; move to size 
1026				ld a, c 
1026				sub (hl)        ; we want c < (hl) 
1026				dec hl    ; move back to marker 
1026			        jr z, .findblock 
1026			 
1026				; update with the new size which should be lower 
1026			 
1026			        ;inc  hl   ; negate next move. move back to size  
1026			 
1026			.newblock: 
1026				; need to be at marker here 
1026			 
1026					if DEBUG_FORTH_MALLOC_INT 
1026						DMARK "meN" 
1026						CALLMONITOR 
1026					endif 
1026			 
1026			 
1026				ld a, c 
1026			 
1026				ld (free_list+3), a	 ; flag resume from last malloc  
1026				ld (free_list), hl    ; save out last location 
1026			 
1026			 
1026				;inc a     ; space for length byte 
1026				ld (hl), a     ; save block in use marker 
1026			 
1026				inc hl   ; move to space marker 
1026				ld (hl), a    ; save new space 
1026			 
1026				inc hl   ; move to start of allocated area 
1026				 
1026			;	push hl     ; save where we are - 1  
1026			 
1026			;	inc hl  ; move past zero index  
1026				; skip space to set down new marker 
1026			 
1026				; provide some extra space for now 
1026			 
1026				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1026				inc a 
1026				inc a 
1026			 
1026				push hl   ; save where we are in the node block 
1026			 
1026				call addatohl 
1026			 
1026				; write linked list point 
1026			 
1026				pop de     ; get our node position 
1026				ex de, hl 
1026			 
1026				ld (hl), e 
1026				inc hl 
1026				ld (hl), d 
1026			 
1026				inc hl 
1026			 
1026				; now at start of allocated data so save pointer 
1026			 
1026				push hl 
1026			 
1026				; jump to position of next node and setup empty header in DE 
1026			 
1026				ex de, hl 
1026			 
1026			;	inc hl ; move past end of block 
1026			 
1026				ld a, 0 
1026				ld (hl), a   ; empty marker 
1026				inc hl 
1026				ld (hl), a   ; size 
1026				inc hl  
1026				ld (hl), a   ; ptr 
1026				inc hl 
1026				ld (hl), a   ; ptr 
1026			 
1026			 
1026				pop hl 
1026			 
1026					if DEBUG_FORTH_MALLOC_INT 
1026						DMARK "mmr" 
1026						CALLMONITOR 
1026					endif 
1026			 
1026			.exit: 
1026				pop af 
1026				pop bc 
1026				pop de  
1026				ret 
1026			 
1026			 
1026			 
1026			 
1026			free:  
1026				push hl 
1026				push af 
1026				; get address in hl 
1026			 
1026					if DEBUG_FORTH_MALLOC_INT 
1026						DMARK "fre" 
1026						CALLMONITOR 
1026					endif 
1026				; data is at hl - move to block count 
1026				dec hl 
1026				dec hl    ; get past pointer 
1026				dec hl 
1026			 
1026				ld a, (hl)    ; need this for a validation check 
1026			 
1026				dec hl    ; move to block marker 
1026			 
1026				; now check that the block count and block marker are the same  
1026			        ; this checks that we are on a malloc node and not random memory 
1026			        ; OK a faint chance this could be a problem but rare - famous last words! 
1026			 
1026				ld c, a 
1026				ld a, (hl)    
1026			 
1026				cp c 
1026				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1026			 
1026				; yes good chance we are on a malloc node 
1026			 
1026				ld a, 0      
1026				ld (hl), a   ; mark as free 
1026			 
1026				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1026			 
1026			.freeignore:  
1026			 
1026				pop af 
1026				pop hl 
1026			 
1026				ret 
1026			 
1026			 
1026			 
1026			endif 
1026			 
1026			; eof 
# End of file firmware_memory.asm
1026			  
1026			; device C  
1026			if SOUND_ENABLE  
1026				include "firmware_sound.asm"  
1026			endif  
1026			  
1026			include "firmware_diags.asm"  
1026			; Hardware diags menu 
1026			 
1026			 
1026 .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1047 .. 00		hd_menu2:   db "        2: Editor",0   
1059			;hd_menu2:   db "        2: Editor       6: BASIC",0   
1059 .. 00		hd_menu3:   db "        3: Storage",0 
106c .. 00		hd_menu4:   db "0=quit  4: Debug",0 
107d .. 00		hd_don:     db "ON",0 
1080 .. 00		hd_doff:     db "OFF",0 
1084			 
1084			 
1084			 
1084			hardware_diags:       
1084			 
1084			.diagmenu: 
1084 cd 6d 08			call clear_display 
1087 3e 00			ld a, display_row_1 
1089 11 26 10			ld de, hd_menu1 
108c cd 80 08			call str_at_display 
108f			 
108f 3e 28			ld a, display_row_2 
1091 11 47 10			ld de, hd_menu2 
1094 cd 80 08			call str_at_display 
1097			 
1097 3e 50			ld a, display_row_3 
1099 11 59 10			ld de, hd_menu3 
109c cd 80 08			call str_at_display 
109f			 
109f 3e 78			ld a,  display_row_4 
10a1 11 6c 10			ld de, hd_menu4 
10a4 cd 80 08			call str_at_display 
10a7			 
10a7				; display debug state 
10a7			 
10a7 11 7d 10			ld de, hd_don 
10aa 3a 74 e3			ld a, (os_view_disable) 
10ad fe 00			cp 0 
10af 28 03			jr z, .distog 
10b1 11 80 10			ld de, hd_doff 
10b4 3e 89		.distog: ld a, display_row_4+17 
10b6 cd 80 08			call str_at_display 
10b9			 
10b9 cd 90 08			call update_display 
10bc			 
10bc cd a4 47			call cin_wait 
10bf			 
10bf			 
10bf			 
10bf fe 34			cp '4' 
10c1 20 0f			jr nz, .diagn1 
10c3			 
10c3				; debug toggle 
10c3			 
10c3 3a 74 e3			ld a, (os_view_disable) 
10c6 06 2a			ld b, '*' 
10c8 fe 00			cp 0 
10ca 28 02			jr z, .debtog 
10cc 06 00			ld b, 0 
10ce			.debtog:	 
10ce 78				ld a,b 
10cf 32 74 e3			ld (os_view_disable),a 
10d2			 
10d2 fe 30		.diagn1: cp '0' 
10d4 c8				 ret z 
10d5			 
10d5			;	cp '1' 
10d5			;       jp z, matrix	 
10d5			;   TODO keyboard matrix test 
10d5			 
10d5 fe 32			cp '2' 
10d7 ca de 10			jp z, .diagedit 
10da			 
10da			;if ENABLE_BASIC 
10da			;	cp '6' 
10da			;	jp z, basic 
10da			;endif 
10da			  
10da c3 84 10			jp .diagmenu 
10dd			 
10dd			 
10dd c9				ret 
10de			 
10de			; debug editor 
10de			 
10de			.diagedit: 
10de			 
10de 21 75 e3			ld hl, scratch 
10e1			;	ld bc, 250 
10e1			;	ldir 
10e1				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
10e1 3e 00			ld a, 0 
10e3 77				ld (hl), a 
10e4 23				inc hl 
10e5 77				ld (hl), a 
10e6 23				inc hl 
10e7 77				ld (hl), a 
10e8			 
10e8 cd 6d 08		        call clear_display 
10eb cd 90 08			call update_display 
10ee 3e 01			ld a, 1 
10f0 32 80 ee			ld (hardware_diag), a 
10f3			.diloop: 
10f3 3e 00			ld a, display_row_1 
10f5 0e 00			ld c, 0 
10f7 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
10f9 1e 28			ld e, 40 
10fb			 
10fb 21 75 e3			ld hl, scratch	 
10fe cd f3 09			call input_str 
1101			 
1101 3e 28			ld a, display_row_2 
1103 11 75 e3			ld de, scratch 
1106 cd 80 08			call str_at_display 
1109 cd 90 08			call update_display 
110c			 
110c c3 f3 10			jp .diloop 
110f			 
110f			 
110f			; pass word in hl 
110f			; a has display location 
110f			display_word_at: 
110f f5				push af 
1110 e5				push hl 
1111 7c				ld a,h 
1112 21 7a e6			ld hl, os_word_scratch 
1115 cd c7 0c			call hexout 
1118 e1				pop hl 
1119 7d				ld a,l 
111a 21 7c e6			ld hl, os_word_scratch+2 
111d cd c7 0c			call hexout 
1120 21 7e e6			ld hl, os_word_scratch+4 
1123 3e 00			ld a,0 
1125 77				ld (hl),a 
1126 11 7a e6			ld de,os_word_scratch 
1129 f1				pop af 
112a cd 80 08				call str_at_display 
112d c9				ret 
112e			 
112e			display_ptr_state: 
112e			 
112e				; to restore afterwards 
112e			 
112e d5				push de 
112f c5				push bc 
1130 e5				push hl 
1131 f5				push af 
1132			 
1132				; for use in here 
1132			 
1132			;	push bc 
1132			;	push de 
1132			;	push hl 
1132			;	push af 
1132			 
1132 cd 6d 08			call clear_display 
1135			 
1135 11 08 13			ld de, .ptrstate 
1138 3e 00			ld a, display_row_1 
113a cd 80 08			call str_at_display 
113d			 
113d				; display debug step 
113d			 
113d			 
113d 11 7a ee			ld de, debug_mark 
1140 3e 26			ld a, display_row_1+display_cols-2 
1142 cd 80 08			call str_at_display 
1145			 
1145				; display a 
1145 11 12 13			ld de, .ptrcliptr 
1148 3e 28			ld a, display_row_2 
114a cd 80 08			call str_at_display 
114d			 
114d f1				pop af 
114e 2a 40 eb			ld hl,(cli_ptr) 
1151 3e 30			ld a, display_row_2+8 
1153 cd 0f 11			call display_word_at 
1156			 
1156			 
1156				; display hl 
1156			 
1156			 
1156 11 1a 13			ld de, .ptrclioptr 
1159 3e 32			ld a, display_row_2+10 
115b cd 80 08			call str_at_display 
115e			; 
115e			;	pop hl 
115e 3e 35			ld a, display_row_2+13 
1160 2a 3e eb			ld hl,(cli_origptr) 
1163 cd 0f 11			call display_word_at 
1166			; 
1166			;	 
1166			;	; display de 
1166			 
1166			;	ld de, .regstatede 
1166			;	ld a, display_row_3 
1166			;	call str_at_display 
1166			 
1166			;	pop de 
1166			;	ld h,d 
1166			;	ld l, e 
1166			;	ld a, display_row_3+3 
1166			;	call display_word_at 
1166			 
1166			 
1166				; display bc 
1166			 
1166			;	ld de, .regstatebc 
1166			;	ld a, display_row_3+10 
1166			;	call str_at_display 
1166			 
1166			;	pop bc 
1166			;	ld h,b 
1166			;	ld l, c 
1166			;	ld a, display_row_3+13 
1166			;	call display_word_at 
1166			 
1166			 
1166				; display dsp 
1166			 
1166			;	ld de, .regstatedsp 
1166			;	ld a, display_row_4 
1166			;	call str_at_display 
1166			 
1166				 
1166			;	ld hl,(cli_data_sp) 
1166			;	ld a, display_row_4+4 
1166			;	call display_word_at 
1166			 
1166				; display rsp 
1166			 
1166 11 49 13			ld de, .regstatersp 
1169 3e 82			ld a, display_row_4+10 
116b cd 80 08			call str_at_display 
116e			 
116e				 
116e 2a 26 eb			ld hl,(cli_ret_sp) 
1171 3e 86			ld a, display_row_4+14 
1173 cd 0f 11			call display_word_at 
1176			 
1176 cd 90 08			call update_display 
1179			 
1179 cd e6 07			call delay1s 
117c cd e6 07			call delay1s 
117f cd e6 07			call delay1s 
1182			 
1182			 
1182 cd 8f 16			call next_page_prompt 
1185			 
1185				; restore  
1185			 
1185 f1				pop af 
1186 e1				pop hl 
1187 c1				pop bc 
1188 d1				pop de 
1189 c9				ret 
118a			 
118a			break_point_state: 
118a f5				push af 
118b			 
118b				; see if disabled 
118b			 
118b 3a 74 e3			ld a, (os_view_disable) 
118e fe 2a			cp '*' 
1190 20 02			jr nz, .bpsgo 
1192 f1				pop af 
1193 c9				ret 
1194			 
1194			.bpsgo: 
1194 f1				pop af 
1195 f5				push af 
1196 22 70 e3			ld (os_view_hl), hl 
1199 ed 53 6e e3		ld (os_view_de), de 
119d ed 43 6c e3		ld (os_view_bc), bc 
11a1 e5				push hl 
11a2 6f				ld l, a 
11a3 26 00			ld h, 0 
11a5 22 72 e3			ld (os_view_af),hl 
11a8			 
11a8 21 c0 ed				ld hl, display_fb0 
11ab 22 db eb				ld (display_fb_active), hl 
11ae e1				pop hl	 
11af			 
11af 3e 31			ld a, '1' 
11b1 fe 2a		.bps1:  cp '*' 
11b3 20 03			jr nz, .bps1b 
11b5 32 74 e3			ld (os_view_disable),a 
11b8 fe 31		.bps1b:  cp '1' 
11ba 20 14			jr nz, .bps2 
11bc			 
11bc				; display reg 
11bc			 
11bc				 
11bc			 
11bc 3a 72 e3			ld a, (os_view_af) 
11bf 2a 70 e3			ld hl, (os_view_hl) 
11c2 ed 5b 6e e3		ld de, (os_view_de) 
11c6 ed 4b 6c e3		ld bc, (os_view_bc) 
11ca cd 64 12			call display_reg_state 
11cd c3 50 12			jp .bpschk 
11d0			 
11d0 fe 32		.bps2:  cp '2' 
11d2 20 08			jr nz, .bps3 
11d4				 
11d4				; display hl 
11d4 2a 70 e3			ld hl, (os_view_hl) 
11d7 cd 4e 13			call display_dump_at_hl 
11da			 
11da 18 74			jr .bpschk 
11dc			 
11dc fe 33		.bps3:  cp '3' 
11de 20 08			jr nz, .bps4 
11e0			 
11e0			        ; display de 
11e0 2a 6e e3			ld hl, (os_view_de) 
11e3 cd 4e 13			call display_dump_at_hl 
11e6			 
11e6 18 68			jr .bpschk 
11e8 fe 34		.bps4:  cp '4' 
11ea 20 08			jr nz, .bps5 
11ec			 
11ec			        ; display bc 
11ec 2a 6c e3			ld hl, (os_view_bc) 
11ef cd 4e 13			call display_dump_at_hl 
11f2			 
11f2 18 5c			jr .bpschk 
11f4 fe 35		.bps5:  cp '5' 
11f6 20 08		        jr nz, .bps7 
11f8			 
11f8				; display cur ptr 
11f8 2a 40 eb			ld hl, (cli_ptr) 
11fb cd 4e 13			call display_dump_at_hl 
11fe			 
11fe 18 50			jr .bpschk 
1200 fe 36		.bps7:  cp '6' 
1202 20 08			jr nz, .bps8b 
1204				 
1204				; display cur orig ptr 
1204 2a 3e eb			ld hl, (cli_origptr) 
1207 cd 4e 13			call display_dump_at_hl 
120a 18 44			jr .bpschk 
120c fe 37		.bps8b:  cp '7' 
120e 20 08			jr nz, .bps9 
1210				 
1210				; display dsp 
1210 2a 22 eb			ld hl, (cli_data_sp) 
1213 cd 4e 13			call display_dump_at_hl 
1216			 
1216 18 38			jr .bpschk 
1218 fe 39		.bps9:  cp '9' 
121a 20 05			jr nz, .bps8c 
121c				 
121c				; display SP 
121c			;	ld hl, sp 
121c cd 4e 13			call display_dump_at_hl 
121f			 
121f 18 2f			jr .bpschk 
1221 fe 38		.bps8c:  cp '8' 
1223 20 08			jr nz, .bps8d 
1225				 
1225				; display rsp 
1225 2a 26 eb			ld hl, (cli_ret_sp) 
1228 cd 4e 13			call display_dump_at_hl 
122b			 
122b 18 23			jr .bpschk 
122d fe 23		.bps8d:  cp '#'     ; access monitor sub system 
122f 20 05			jr nz, .bps8 
1231 cd 85 14			call monitor 
1234			 
1234 18 1a			jr .bpschk 
1236 fe 30		.bps8:  cp '0' 
1238 20 16			jr nz, .bpschk 
123a			 
123a 21 1f ed				ld hl, display_fb1 
123d 22 db eb				ld (display_fb_active), hl 
1240 cd 90 08				call update_display 
1243			 
1243				;ld a, (os_view_af) 
1243 2a 70 e3			ld hl, (os_view_hl) 
1246 ed 5b 6e e3		ld de, (os_view_de) 
124a ed 4b 6c e3		ld bc, (os_view_bc) 
124e f1				pop af 
124f c9				ret 
1250			 
1250			.bpschk:   
1250 cd e6 07			call delay1s 
1253 3e 9f		ld a,display_row_4 + display_cols - 1 
1255 11 8d 16		        ld de, endprg 
1258 cd 80 08			call str_at_display 
125b cd 90 08			call update_display 
125e cd a4 47			call cin_wait 
1261			 
1261 c3 b1 11			jp .bps1 
1264			 
1264			 
1264			display_reg_state: 
1264			 
1264				; to restore afterwards 
1264			 
1264 d5				push de 
1265 c5				push bc 
1266 e5				push hl 
1267 f5				push af 
1268			 
1268				; for use in here 
1268			 
1268 c5				push bc 
1269 d5				push de 
126a e5				push hl 
126b f5				push af 
126c			 
126c cd 6d 08			call clear_display 
126f			 
126f 11 24 13			ld de, .regstate 
1272 3e 00			ld a, display_row_1 
1274 cd 80 08			call str_at_display 
1277			 
1277				; display debug step 
1277			 
1277			 
1277 11 7a ee			ld de, debug_mark 
127a 3e 25			ld a, display_row_1+display_cols-3 
127c cd 80 08			call str_at_display 
127f			 
127f				; display a 
127f 11 40 13			ld de, .regstatea 
1282 3e 28			ld a, display_row_2 
1284 cd 80 08			call str_at_display 
1287			 
1287 e1				pop hl 
1288			;	ld h,0 
1288			;	ld l, a 
1288 3e 2b			ld a, display_row_2+3 
128a cd 0f 11			call display_word_at 
128d			 
128d			 
128d				; display hl 
128d			 
128d			 
128d 11 34 13			ld de, .regstatehl 
1290 3e 32			ld a, display_row_2+10 
1292 cd 80 08			call str_at_display 
1295			 
1295 e1				pop hl 
1296 3e 35			ld a, display_row_2+13 
1298 cd 0f 11			call display_word_at 
129b			 
129b				 
129b				; display de 
129b			 
129b 11 38 13			ld de, .regstatede 
129e 3e 50			ld a, display_row_3 
12a0 cd 80 08			call str_at_display 
12a3			 
12a3 e1				pop hl 
12a4			;	ld h,d 
12a4			;	ld l, e 
12a4 3e 53			ld a, display_row_3+3 
12a6 cd 0f 11			call display_word_at 
12a9			 
12a9			 
12a9				; display bc 
12a9			 
12a9 11 3c 13			ld de, .regstatebc 
12ac 3e 5a			ld a, display_row_3+10 
12ae cd 80 08			call str_at_display 
12b1			 
12b1 e1				pop hl 
12b2			;	ld h,b 
12b2			;	ld l, c 
12b2 3e 5d			ld a, display_row_3+13 
12b4 cd 0f 11			call display_word_at 
12b7			 
12b7			 
12b7				; display dsp 
12b7			 
12b7 11 44 13			ld de, .regstatedsp 
12ba 3e 78			ld a, display_row_4 
12bc cd 80 08			call str_at_display 
12bf			 
12bf				 
12bf 2a 22 eb			ld hl,(cli_data_sp) 
12c2 3e 7c			ld a, display_row_4+4 
12c4 cd 0f 11			call display_word_at 
12c7			 
12c7				; display rsp 
12c7			 
12c7 11 49 13			ld de, .regstatersp 
12ca 3e 82			ld a, display_row_4+10 
12cc cd 80 08			call str_at_display 
12cf			 
12cf				 
12cf 2a 26 eb			ld hl,(cli_ret_sp) 
12d2 3e 86			ld a, display_row_4+14 
12d4 cd 0f 11			call display_word_at 
12d7			 
12d7 cd 90 08			call update_display 
12da			 
12da			;	call delay1s 
12da			;	call delay1s 
12da			;	call delay1s 
12da			 
12da			 
12da			;	call next_page_prompt 
12da			 
12da				; restore  
12da			 
12da f1				pop af 
12db e1				pop hl 
12dc c1				pop bc 
12dd d1				pop de 
12de c9				ret 
12df			 
12df .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
12f3 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1308 .. 00		.ptrstate:	db "Ptr State",0 
1312 .. 00		.ptrcliptr:     db "cli_ptr",0 
131a .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1324 .. 00		.regstate:	db "Reg State (1/0)",0 
1334 .. 00		.regstatehl:	db "HL:",0 
1338 .. 00		.regstatede:	db "DE:",0 
133c .. 00		.regstatebc:	db "BC:",0 
1340 .. 00		.regstatea:	db "A :",0 
1344 .. 00		.regstatedsp:	db "DSP:",0 
1349 .. 00		.regstatersp:	db "RSP:",0 
134e			 
134e			display_dump_at_hl: 
134e e5				push hl 
134f d5				push de 
1350 c5				push bc 
1351 f5				push af 
1352			 
1352 22 98 e6			ld (os_cur_ptr),hl	 
1355 cd 6d 08			call clear_display 
1358 cd 97 15			call dumpcont 
135b			;	call delay1s 
135b			;	call next_page_prompt 
135b			 
135b			 
135b f1				pop af 
135c c1				pop bc 
135d d1				pop de 
135e e1				pop hl 
135f c9				ret 
1360			 
1360			;if ENABLE_BASIC 
1360			;	include "nascombasic.asm" 
1360			;	basic: 
1360			;	include "forth/FORTH.ASM" 
1360			;endif 
1360			 
1360			; eof 
1360			 
1360			 
# End of file firmware_diags.asm
1360			  
1360			  
1360			  
1360			  
1360			; eof  
1360			  
# End of file firmware.asm
1360			 
1360			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1360			;if BASE_KEV  
1360			;baseram: equ 08000h 
1360			;endif 
1360			 
1360			;if BASE_SC114 
1360			;baseram:     equ    endofcode 
1360			;endif 
1360			 
1360			 
1360			; start system 
1360			 
1360			coldstart: 
1360				; set sp 
1360				; di/ei 
1360			 
1360 f3				di 
1361 31 00 f0			ld sp, tos 
1364			;	ei 
1364			 
1364			 
1364				; disable breakpoint by default 
1364			 
1364 3e 2a			ld a,'*' 
1366 32 74 e3			ld (os_view_disable),a 
1369			 
1369				; init hardware 
1369			 
1369				; init keyboard and screen hardware 
1369			 
1369 cd 03 01			call hardware_init 
136c			 
136c			 
136c				; detect if any keys are held down to enable breakpoints at start up 
136c			 
136c cd ac 47			call cin  
136f fe 00			cp 0 
1371 28 03			jr z, .nokeys 
1373			 
1373 cd 84 10			call hardware_diags 
1376			 
1376			;	ld de, .bpen 
1376			;	ld a, display_row_4 
1376			;	call str_at_display 
1376			;	call update_display 
1376			; 
1376			;	ld a,0 
1376			;	ld (os_view_disable),a 
1376			; 
1376			;.bpwait: 
1376			;	call cin 
1376			;	cp 0 
1376			;	jr z, .bpwait 
1376			;	jr .nokeys 
1376			; 
1376			; 
1376			;.bpen:  db "Break points enabled!",0 
1376			 
1376			 
1376			 
1376			 
1376			 
1376			 
1376			.nokeys: 
1376			 
1376			 
1376				 
1376			 
1376			;jp  testkey 
1376			 
1376			;call storage_get_block_0 
1376			; 
1376			;ld hl, 0 
1376			;ld de, store_page 
1376			;call storage_read_block 
1376			 
1376				 
1376			;ld hl, 10 
1376			;ld de, store_page 
1376			;call storage_read_block 
1376			 
1376			 
1376			 
1376			 
1376			 
1376			;stop:	nop 
1376			;	jp stop 
1376			 
1376			 
1376			 
1376			main: 
1376 cd 6d 08			call clear_display 
1379 cd 90 08			call update_display 
137c			 
137c			 
137c			 
137c			;	call testlcd 
137c			 
137c			 
137c			 
137c cd be 18			call forth_init 
137f			 
137f			 
137f			warmstart: 
137f cd 94 18			call forth_warmstart 
1382			 
1382				; run startup word load 
1382			        ; TODO prevent this running at warmstart after crash  
1382			 
1382				if STARTUP_ENABLE 
1382 cd f2 43				call forth_startup 
1385				endif 
1385			 
1385				; show free memory after boot 
1385 11 1f 14			ld de, freeram 
1388 3e 00			ld a, display_row_1 
138a cd 80 08			call str_at_display 
138d			 
138d			; Or use heap_size word???? 
138d 21 69 e3			ld hl, heap_end 
1390 11 d4 47			ld de, heap_start 
1393 ed 52			sbc hl, de 
1395 e5				push hl 
1396 7c				ld a,h	         	 
1397 21 7a e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
139a cd c7 0c			call hexout 
139d e1			   	pop hl 
139e			 
139e 7d				ld a,l 
139f 21 7c e6			ld hl, os_word_scratch+2 
13a2 cd c7 0c			call hexout 
13a5 21 7e e6			ld hl, os_word_scratch+4 
13a8 3e 00			ld a, 0 
13aa 77				ld (hl),a 
13ab 11 7a e6			ld de, os_word_scratch 
13ae 3e 0d			ld a, display_row_1 + 13 
13b0 cd 80 08			call str_at_display 
13b3 cd 90 08			call update_display 
13b6			 
13b6			 
13b6				;call demo 
13b6			 
13b6			 
13b6				; init scratch input area for cli commands 
13b6			 
13b6 21 9c e6			ld hl, os_cli_cmd 
13b9 3e 00			ld a,0 
13bb 77				ld (hl),a 
13bc 23				inc hl 
13bd 77				ld (hl),a 
13be			 
13be 3e 00			ld a,0 
13c0 32 9b e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
13c3			 
13c3 32 98 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
13c6 32 99 e6			ld (os_cur_ptr+1),a	 
13c9			 
13c9 32 7a e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
13cc 32 7b e6			ld (os_word_scratch+1),a	 
13cf				 
13cf			 
13cf				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
13cf 21 9c e6			ld hl, os_cli_cmd 
13d2			 
13d2 3e 00			ld a, 0		 ; init cli input 
13d4 77				ld (hl), a 
13d5 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
13d7			cli: 
13d7				; show cli prompt 
13d7				;push af 
13d7				;ld a, 0 
13d7				;ld de, prompt 
13d7				;call str_at_display 
13d7			 
13d7				;call update_display 
13d7				;pop af 
13d7				;inc a 
13d7				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
13d7 0e 00			ld c, 0 
13d9 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
13db 1e 28			ld e, 40 
13dd			 
13dd 21 9c e6			ld hl, os_cli_cmd 
13e0			 
13e0				STACKFRAME OFF $fefe $9f9f 
13e0				if DEBUG_STACK_IMB 
13e0					if OFF 
13e0						exx 
13e0						ld de, $fefe 
13e0						ld a, d 
13e0						ld hl, curframe 
13e0						call hexout 
13e0						ld a, e 
13e0						ld hl, curframe+2 
13e0						call hexout 
13e0						ld hl, $fefe 
13e0						push hl 
13e0						ld hl, $9f9f 
13e0						push hl 
13e0						exx 
13e0					endif 
13e0				endif 
13e0			endm 
# End of macro STACKFRAME
13e0			 
13e0 cd f3 09			call input_str 
13e3			 
13e3				STACKFRAMECHK OFF $fefe $9f9f 
13e3				if DEBUG_STACK_IMB 
13e3					if OFF 
13e3						exx 
13e3						ld hl, $9f9f 
13e3						pop de   ; $9f9f 
13e3						call cmp16 
13e3						jr nz, .spnosame 
13e3						ld hl, $fefe 
13e3						pop de   ; $fefe 
13e3						call cmp16 
13e3						jr z, .spfrsame 
13e3						.spnosame: call showsperror 
13e3						.spfrsame: nop 
13e3						exx 
13e3					endif 
13e3				endif 
13e3			endm 
# End of macro STACKFRAMECHK
13e3			 
13e3				; copy input to last command 
13e3			 
13e3 21 9c e6			ld hl, os_cli_cmd 
13e6 11 9b e7			ld de, os_last_cmd 
13e9 01 ff 00			ld bc, 255 
13ec ed b0			ldir 
13ee				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
13ee			;	call strcpy 
13ee			;	ld a, 0 
13ee			;	ld (hl), a 
13ee			;	inc hl 
13ee			;	ld (hl), a 
13ee			;	inc hl 
13ee			;	ld (hl), a 
13ee			 
13ee				; switch frame buffer to program  
13ee			 
13ee 21 1f ed				ld hl, display_fb1 
13f1 22 db eb				ld (display_fb_active), hl 
13f4			 
13f4			;	nop 
13f4				STACKFRAME ON $fbfe $8f9f 
13f4				if DEBUG_STACK_IMB 
13f4					if ON 
13f4						exx 
13f4						ld de, $fbfe 
13f4						ld a, d 
13f4						ld hl, curframe 
13f4						call hexout 
13f4						ld a, e 
13f4						ld hl, curframe+2 
13f4						call hexout 
13f4						ld hl, $fbfe 
13f4						push hl 
13f4						ld hl, $8f9f 
13f4						push hl 
13f4						exx 
13f4					endif 
13f4				endif 
13f4			endm 
# End of macro STACKFRAME
13f4				; first time into the parser so pass over the current scratch pad 
13f4 21 9c e6			ld hl,os_cli_cmd 
13f7				; tokenise the entered statement(s) in HL 
13f7 cd 37 19			call forthparse 
13fa			        ; exec forth statements in top of return stack 
13fa cd 77 19			call forthexec 
13fd				;call forthexec_cleanup 
13fd			;	call parsenext 
13fd			 
13fd				STACKFRAMECHK ON $fbfe $8f9f 
13fd				if DEBUG_STACK_IMB 
13fd					if ON 
13fd						exx 
13fd						ld hl, $8f9f 
13fd						pop de   ; $8f9f 
13fd						call cmp16 
13fd						jr nz, .spnosame 
13fd						ld hl, $fbfe 
13fd						pop de   ; $fbfe 
13fd						call cmp16 
13fd						jr z, .spfrsame 
13fd						.spnosame: call showsperror 
13fd						.spfrsame: nop 
13fd						exx 
13fd					endif 
13fd				endif 
13fd			endm 
# End of macro STACKFRAMECHK
13fd				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
13fd			 
13fd 3e 78			ld a, display_row_4 
13ff 11 31 14			ld de, endprog 
1402			 
1402 cd 90 08			call update_display		 
1405			 
1405 cd 8f 16			call next_page_prompt 
1408			 
1408				; switch frame buffer to cli 
1408			 
1408 21 c0 ed				ld hl, display_fb0 
140b 22 db eb				ld (display_fb_active), hl 
140e			 
140e			 
140e cd 6d 08		        call clear_display 
1411 cd 90 08			call update_display		 
1414			 
1414 21 9c e6			ld hl, os_cli_cmd 
1417			 
1417 3e 00			ld a, 0		 ; init cli input 
1419 77				ld (hl), a 
141a			 
141a				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
141a			 
141a				; now on last line 
141a			 
141a				; TODO scroll screen up 
141a			 
141a				; TODO instead just clear screen and place at top of screen 
141a			 
141a			;	ld a, 0 
141a			;	ld (f_cursor_ptr),a 
141a			 
141a				;call clear_display 
141a				;call update_display 
141a			 
141a				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
141a 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
141c c3 d7 13			jp cli 
141f			 
141f .. 00		freeram: db "Free bytes: $",0 
142d ..			asc: db "1A2F" 
1431 .. 00		endprog: db "End prog...",0 
143d			 
143d			testenter2:   
143d 21 a7 e3			ld hl,scratch+50 
1440 22 98 e6			ld (os_cur_ptr),hl 
1443 c3 d7 13			jp cli 
1446			 
1446			testenter:  
1446			 
1446 21 2d 14			ld hl,asc 
1449			;	ld a,(hl) 
1449			;	call nibble2val 
1449 cd 1d 0d			call get_byte 
144c			 
144c			 
144c			;	ld a,(hl) 
144c			;	call atohex 
144c			 
144c			;	call fourehexhl 
144c 32 a7 e3			ld (scratch+50),a 
144f			 
144f			 
144f			 
144f 21 2f 14			ld hl,asc+2 
1452			;	ld a, (hl) 
1452			;	call nibble2val 
1452 cd 1d 0d			call get_byte 
1455			 
1455			;	call fourehexhl 
1455 32 a9 e3			ld (scratch+52),a 
1458				 
1458 21 a7 e3			ld hl,scratch+50 
145b 22 98 e6			ld (os_cur_ptr),hl 
145e c3 d7 13			jp cli 
1461			 
1461			enter:	 
1461 3a 79 e3			ld a,(scratch+4) 
1464 fe 00			cp 0 
1466 28 0c			jr z, .entercont 
1468				; no, not a null term line so has an address to work out.... 
1468			 
1468 21 77 e3			ld hl,scratch+2 
146b cd 7d 0d			call get_word_hl 
146e			 
146e 22 98 e6			ld (os_cur_ptr),hl	 
1471 c3 d7 13			jp cli 
1474			 
1474			 
1474			.entercont:  
1474			 
1474 21 77 e3			ld hl, scratch+2 
1477 cd 1d 0d			call get_byte 
147a			 
147a 2a 98 e6		   	ld hl,(os_cur_ptr) 
147d 77					ld (hl),a 
147e 23					inc hl 
147f 22 98 e6				ld (os_cur_ptr),hl 
1482				 
1482			; get byte  
1482			 
1482			 
1482 c3 d7 13			jp cli 
1485			 
1485			 
1485			; basic monitor support 
1485			 
1485			monitor: 
1485				;  
1485 cd 6d 08			call clear_display 
1488 3e 00			ld a, 0 
148a 11 d2 14			ld de, .monprompt 
148d cd 80 08			call str_at_display 
1490 cd 90 08			call update_display 
1493			 
1493				; get a monitor command 
1493			 
1493 0e 00			ld c, 0     ; entry at top left 
1495 16 64			ld d, 100   ; max buffer size 
1497 1e 0f			ld e, 15    ; input scroll area 
1499 3e 00			ld a, 0     ; init string 
149b 21 73 e5			ld hl, os_input 
149e 77				ld (hl), a 
149f 23				inc hl 
14a0 77				ld (hl), a 
14a1 21 73 e5			ld hl, os_input 
14a4 3e 01			ld a, 1     ; init string 
14a6 cd f3 09			call input_str 
14a9			 
14a9 cd 6d 08		        call clear_display 
14ac cd 90 08			call update_display		 
14af			 
14af 3a 73 e5			ld a, (os_input) 
14b2 cd 1b 0e			call toUpper 
14b5 fe 48		        cp 'H' 
14b7 28 6f		        jr z, .monhelp 
14b9 fe 44			cp 'D'		; dump 
14bb ca 49 15			jp z, .mondump	 
14be fe 43			cp 'C'		; dump 
14c0 ca 63 15			jp z, .moncdump	 
14c3 fe 4d			cp 'M'		; dump 
14c5 ca d4 14			jp z, .moneditstart 
14c8 fe 55			cp 'U'		; dump 
14ca 28 14			jr z, .monedit	 
14cc fe 51			cp 'Q'		; dump 
14ce c8				ret z	 
14cf			 
14cf			 
14cf				; TODO "S" to access symbol by name and not need the address 
14cf				; TODO "F" to find a string in memory 
14cf			 
14cf c3 85 14			jp monitor 
14d2			 
14d2 .. 00		.monprompt: db ">", 0 
14d4			 
14d4			.moneditstart: 
14d4				; get starting address 
14d4			 
14d4 21 75 e5			ld hl,os_input+2 
14d7 cd 7d 0d			call get_word_hl 
14da			 
14da 22 98 e6			ld (os_cur_ptr),hl	 
14dd			 
14dd c3 85 14			jp monitor 
14e0			 
14e0			.monedit: 
14e0				; get byte to load 
14e0			 
14e0 21 75 e5			ld hl,os_input+2 
14e3 cd 1d 0d			call get_byte 
14e6			 
14e6				; get address to update 
14e6 2a 98 e6			ld hl, (os_cur_ptr) 
14e9			 
14e9				; update byte 
14e9			 
14e9 77				ld (hl), a 
14ea			 
14ea				; move to next address and save it 
14ea			 
14ea 23				inc hl 
14eb 22 98 e6			ld (os_cur_ptr),hl	 
14ee			 
14ee c3 85 14			jp monitor 
14f1			 
14f1			 
14f1 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1505 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1521 .. 00		.monhelptext3:  db "Q-Quit",0 
1528			        
1528			.monhelp: 
1528 3e 00			ld a, display_row_1 
152a 11 f1 14		        ld de, .monhelptext1 
152d			 
152d cd 80 08			call str_at_display 
1530 3e 28			ld a, display_row_2 
1532 11 05 15		        ld de, .monhelptext2 
1535					 
1535 cd 80 08			call str_at_display 
1538 3e 50			ld a, display_row_3 
153a 11 21 15		        ld de, .monhelptext3 
153d					 
153d cd 80 08			call str_at_display 
1540 cd 90 08			call update_display		 
1543			 
1543 cd 8f 16			call next_page_prompt 
1546 c3 85 14			jp monitor 
1549			 
1549			.mondump:    
1549 21 75 e5			ld hl,os_input+2 
154c cd 7d 0d			call get_word_hl 
154f			 
154f 22 98 e6			ld (os_cur_ptr),hl	 
1552 cd 97 15			call dumpcont 
1555 3e 78			ld a, display_row_4 
1557 11 31 14			ld de, endprog 
155a			 
155a cd 90 08			call update_display		 
155d			 
155d cd 8f 16			call next_page_prompt 
1560 c3 85 14			jp monitor 
1563			.moncdump: 
1563 cd 97 15			call dumpcont 
1566 3e 78			ld a, display_row_4 
1568 11 31 14			ld de, endprog 
156b			 
156b cd 90 08			call update_display		 
156e			 
156e cd 8f 16			call next_page_prompt 
1571 c3 85 14			jp monitor 
1574			 
1574			 
1574			; TODO symbol access  
1574			 
1574			.symbols:     ;; A list of symbols that can be called up  
1574 c0 ed			dw display_fb0 
1576 .. 00			db "fb0",0  
157a 65 eb		     	dw store_page 
157c .. 00			db "store_page",0 
1587			 
1587			 
1587			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1587			 
1587 3a 76 e3			ld a,(scratch+1) 
158a fe 00			cp 0 
158c 28 09			jr z, dumpcont 
158e			 
158e				; no, not a null term line so has an address to work out.... 
158e			 
158e 21 77 e3			ld hl,scratch+2 
1591 cd 7d 0d			call get_word_hl 
1594			 
1594 22 98 e6			ld (os_cur_ptr),hl	 
1597			 
1597			 
1597			 
1597			dumpcont: 
1597			 
1597				; dump bytes at ptr 
1597			 
1597			 
1597 3e 00			ld a, display_row_1 
1599 2a db eb			ld hl, (display_fb_active) 
159c cd c6 09			call addatohl 
159f cd c7 15			call .dumpbyterow 
15a2			 
15a2 3e 28			ld a, display_row_2 
15a4 2a db eb			ld hl, (display_fb_active) 
15a7 cd c6 09			call addatohl 
15aa cd c7 15			call .dumpbyterow 
15ad			 
15ad			 
15ad 3e 50			ld a, display_row_3 
15af 2a db eb			ld hl, (display_fb_active) 
15b2 cd c6 09			call addatohl 
15b5 cd c7 15			call .dumpbyterow 
15b8			 
15b8 3e 78			ld a, display_row_4 
15ba 2a db eb			ld hl, (display_fb_active) 
15bd cd c6 09			call addatohl 
15c0 cd c7 15			call .dumpbyterow 
15c3			 
15c3 cd 90 08			call update_display 
15c6			;		jp cli 
15c6 c9				ret 
15c7			 
15c7			.dumpbyterow: 
15c7			 
15c7				;push af 
15c7			 
15c7 e5				push hl 
15c8			 
15c8				; calc where to poke the ascii 
15c8			if display_cols == 20 
15c8				ld a, 16 
15c8			else 
15c8 3e 1f			ld a, 31 
15ca			endif 
15ca			 
15ca cd c6 09			call addatohl 
15cd 22 7a e6			ld (os_word_scratch),hl  		; save pos for later 
15d0			 
15d0			 
15d0			; display decoding address 
15d0 2a 98 e6		   	ld hl,(os_cur_ptr) 
15d3			 
15d3 7c				ld a,h 
15d4 e1				pop hl 
15d5 e5				push hl 
15d6			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
15d6 cd c7 0c			call hexout 
15d9 2a 98 e6		   	ld hl,(os_cur_ptr) 
15dc			 
15dc 7d				ld a,l 
15dd e1				pop hl 
15de 23				inc hl 
15df 23				inc hl 
15e0 e5				push hl 
15e1			;	ld hl, os_word_scratch+2 
15e1 cd c7 0c			call hexout 
15e4 e1				pop hl 
15e5 23				inc hl 
15e6 23				inc hl 
15e7				;ld hl, os_word_scratch+4 
15e7 3e 3a			ld a, ':' 
15e9 77				ld (hl),a 
15ea 23				inc hl 
15eb				;ld a, 0 
15eb				;ld (hl),a 
15eb				;ld de, os_word_scratch 
15eb				;pop af 
15eb				;push af 
15eb			;		ld a, display_row_2 
15eb			;		call str_at_display 
15eb			;		call update_display 
15eb			 
15eb			 
15eb			;pop af 
15eb			;	add 5 
15eb			 
15eb			if display_cols == 20 
15eb				ld b, 4 
15eb			else 
15eb 06 08			ld b, 8 
15ed			endif	 
15ed			 
15ed			.dumpbyte: 
15ed c5				push bc 
15ee e5				push hl 
15ef			 
15ef			 
15ef 2a 98 e6		   	ld hl,(os_cur_ptr) 
15f2 7e					ld a,(hl) 
15f3			 
15f3					; poke the ascii to display 
15f3 2a 7a e6				ld hl,(os_word_scratch) 
15f6 77					ld (hl),a 
15f7 23					inc hl 
15f8 22 7a e6				ld (os_word_scratch),hl 
15fb			 
15fb					 
15fb			 
15fb			 
15fb e1					pop hl 
15fc e5					push hl 
15fd			 
15fd cd c7 0c				call hexout 
1600			 
1600					 
1600 2a 98 e6		   	ld hl,(os_cur_ptr) 
1603 23				inc hl 
1604 22 98 e6		   	ld (os_cur_ptr),hl 
1607			 
1607 e1					pop hl 
1608 23					inc hl 
1609 23					inc hl 
160a 23					inc hl 
160b			 
160b			 
160b			 
160b					;ld a,0 
160b					;ld (os_word_scratch+2),a 
160b					;pop af 
160b					;push af 
160b			 
160b					;ld de, os_word_scratch 
160b					;call str_at_display 
160b			;		call update_display 
160b			;		pop af 
160b c1					pop bc 
160c c6 03				add 3 
160e 10 dd			djnz .dumpbyte 
1610			 
1610				 
1610			 
1610 c9				ret 
1611			 
1611			jump:	 
1611			 
1611 21 77 e3			ld hl,scratch+2 
1614 cd 7d 0d			call get_word_hl 
1617				;ld hl,(scratch+2) 
1617				;call fourehexhl 
1617			 
1617 22 98 e6			ld (os_cur_ptr),hl	 
161a			 
161a e9				jp (hl) 
161b			 
161b			 
161b			 
161b			; TODO implement a basic monitor mode to start with 
161b			 
161b			 
161b			 
161b			 
161b			 
161b			 
161b			 
161b			 
161b			 
161b			; testing and demo code during development 
161b			 
161b			 
161b .. 00		str1: db "Enter some text...",0 
162e .. 00		clear: db "                    ",0 
1643			 
1643			demo: 
1643			 
1643			 
1643			 
1643			;	call update_display 
1643			 
1643				; init scratch input area for testing 
1643 21 75 e3			ld hl, scratch	 
1646 3e 00			ld a,0 
1648 77				ld (hl),a 
1649			 
1649			 
1649 3e 28		            LD   A, display_row_2 
164b			;            CALL fLCD_Pos       ;Position cursor to location in A 
164b 11 1b 16		            LD   DE, str1 
164e cd 80 08			call str_at_display 
1651			 
1651			;            CALL fLCD_Str       ;Display string pointed to by DE 
1651			cloop:	 
1651 3e 50		            LD   A, display_row_3 
1653			;            CALL fLCD_Pos       ;Position cursor to location in A 
1653 11 2e 16		            LD   DE, clear 
1656			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1656 cd 80 08				call str_at_display 
1659 3e 78			ld a, display_row_4 
165b 11 8b 16			ld de, prompt 
165e			 
165e cd 80 08				call str_at_display 
1661 cd 90 08			call update_display 
1664			 
1664 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1666 16 0a			ld d, 10 
1668 21 75 e3			ld hl, scratch	 
166b cd f3 09			call input_str 
166e			 
166e			;	call clear_display 
166e			;'	call update_display 
166e			 
166e 3e 00		            LD   A, display_row_1 
1670			;            CALL fLCD_Pos       ;Position cursor to location in A 
1670 11 2e 16		            LD   DE, clear 
1673 cd 80 08				call str_at_display 
1676			;            CALL fLCD_Str       ;Display string pointed to by DE 
1676 3e 00		            LD   A, display_row_1 
1678			;            CALL fLCD_Pos       ;Position cursor to location in A 
1678 11 75 e3		            LD   DE, scratch 
167b			;            CALL fLCD_Str       ;Display string pointed to by DE 
167b cd 80 08				call str_at_display 
167e cd 90 08			call update_display 
1681			 
1681 3e 00				ld a,0 
1683 21 75 e3			ld hl, scratch 
1686 77				ld (hl),a 
1687			 
1687 00				nop 
1688 c3 51 16			jp cloop 
168b			 
168b			 
168b			 
168b			; OS Prompt 
168b			 
168b .. 00		prompt: db ">",0 
168d .. 00		endprg: db "?",0 
168f			 
168f			 
168f			; handy next page prompt 
168f			next_page_prompt: 
168f e5				push hl 
1690 d5				push de 
1691 f5				push af 
1692 c5				push bc 
1693			 
1693 3e 9f			ld a,display_row_4 + display_cols - 1 
1695 11 8d 16		        ld de, endprg 
1698 cd 80 08			call str_at_display 
169b cd 90 08			call update_display 
169e cd a4 47			call cin_wait 
16a1 c1				pop bc 
16a2 f1				pop af 
16a3 d1				pop de 
16a4 e1				pop hl 
16a5			 
16a5			 
16a5 c9				ret 
16a6			 
16a6			 
16a6			; forth parser 
16a6			 
16a6			; My forth kernel 
16a6			include "forth_kernel.asm" 
16a6			; 
16a6			; kernel to the forth OS 
16a6			 
16a6			DS_TYPE_STR: equ 1     ; string type 
16a6			DS_TYPE_INUM: equ 2     ; $ 16 bit int usually a hex address 
16a6			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
16a6			 
16a6			FORTH_PARSEV1: equ 0 
16a6			FORTH_PARSEV2: equ 0 
16a6			FORTH_PARSEV3: equ 0 
16a6			FORTH_PARSEV4: equ 0 
16a6			FORTH_PARSEV5: equ 1 
16a6			 
16a6			;if FORTH_PARSEV5 
16a6			;	FORTH_END_BUFFER: equ 0 
16a6			;else 
16a6			FORTH_END_BUFFER: equ 127 
16a6			;endif 
16a6			 
16a6			FORTH_TRUE: equ 1 
16a6			FORTH_FALSE: equ 0 
16a6			 
16a6			if FORTH_PARSEV4 
16a6			include "forth_stackops.asm" 
16a6			endif 
16a6			 
16a6			if FORTH_PARSEV5 
16a6			include "forth_stackopsv5.asm" 
16a6			 
16a6			; Stack operations for v5 parser on wards 
16a6			; * DATA stack 
16a6			; * LOOP stack 
16a6			; * RETURN stack 
16a6			 
16a6			 
16a6			 
16a6			FORTH_CHK_DSP_UNDER: macro 
16a6				push hl 
16a6				push de 
16a6				ld hl,(cli_data_sp) 
16a6				ld de, cli_data_stack 
16a6				call cmp16 
16a6				jp c, fault_dsp_under 
16a6				pop de 
16a6				pop hl 
16a6				endm 
16a6			 
16a6			 
16a6			FORTH_CHK_RSP_UNDER: macro 
16a6				push hl 
16a6				push de 
16a6				ld hl,(cli_ret_sp) 
16a6				ld de, cli_ret_stack 
16a6				call cmp16 
16a6				jp c, fault_rsp_under 
16a6				pop de 
16a6				pop hl 
16a6				endm 
16a6			 
16a6			FORTH_CHK_LOOP_UNDER: macro 
16a6				push hl 
16a6				push de 
16a6				ld hl,(cli_loop_sp) 
16a6				ld de, cli_loop_stack 
16a6				call cmp16 
16a6				jp c, fault_loop_under 
16a6				pop de 
16a6				pop hl 
16a6				endm 
16a6			 
16a6			FORTH_ERR_TOS_NOTSTR: macro 
16a6				; TOSO might need more for checks when used 
16a6				push af 
16a6				ld a,(hl) 
16a6				cp DS_TYPE_STR 
16a6				jp nz, type_faultn   
16a6				pop af 
16a6				endm 
16a6			 
16a6			FORTH_ERR_TOS_NOTNUM: macro 
16a6				push af 
16a6				ld a,(hl) 
16a6				cp DS_TYPE_INUM 
16a6				jp nz, type_faultn   
16a6				pop af 
16a6				endm 
16a6			 
16a6			 
16a6			; increase data stack pointer and save hl to it 
16a6				 
16a6			FORTH_DSP_NEXT: macro 
16a6				call macro_forth_dsp_next 
16a6				endm 
16a6			 
16a6			 
16a6			macro_forth_dsp_next: 
16a6				if DEBUG_FORTH_STACK_GUARD 
16a6 cd bc 44				call check_stacks 
16a9				endif 
16a9 e5				push hl 
16aa d5				push de 
16ab eb				ex de,hl 
16ac 2a 22 eb			ld hl,(cli_data_sp) 
16af 23				inc hl 
16b0 23				inc hl 
16b1			 
16b1			; PARSEV5 
16b1 23				inc hl 
16b2 22 22 eb			ld (cli_data_sp),hl 
16b5 73				ld (hl), e 
16b6 23				inc hl 
16b7 72				ld (hl), d 
16b8 d1				pop de 
16b9 e1				pop hl 
16ba				if DEBUG_FORTH_STACK_GUARD 
16ba cd bc 44				call check_stacks 
16bd				endif 
16bd c9				ret 
16be			 
16be			 
16be			; increase ret stack pointer and save hl to it 
16be				 
16be			FORTH_RSP_NEXT: macro 
16be				call macro_forth_rsp_next 
16be				endm 
16be			 
16be			macro_forth_rsp_next: 
16be				if DEBUG_FORTH_STACK_GUARD 
16be cd bc 44				call check_stacks 
16c1				endif 
16c1 e5				push hl 
16c2 d5				push de 
16c3 eb				ex de,hl 
16c4 2a 26 eb			ld hl,(cli_ret_sp) 
16c7 23				inc hl 
16c8 23				inc hl 
16c9 22 26 eb			ld (cli_ret_sp),hl 
16cc 73				ld (hl), e 
16cd 23				inc hl 
16ce 72				ld (hl), d 
16cf d1				pop de 
16d0 e1				pop hl 
16d1				if DEBUG_FORTH_STACK_GUARD 
16d1 cd bc 44				call check_stacks 
16d4				endif 
16d4 c9				ret 
16d5			 
16d5			; get current ret stack pointer and save to hl  
16d5				 
16d5			FORTH_RSP_TOS: macro 
16d5				call macro_forth_rsp_tos 
16d5				endm 
16d5			 
16d5			macro_forth_rsp_tos: 
16d5				;push de 
16d5 2a 26 eb			ld hl,(cli_ret_sp) 
16d8 cd 0d 17			call loadhlptrtohl 
16db				;ld e, (hl) 
16db				;inc hl 
16db				;ld d, (hl) 
16db				;ex de, hl 
16db					if DEBUG_FORTH_WORDS 
16db			;			DMARK "RST" 
16db						CALLMONITOR 
16db					endif 
16db				;pop de 
16db c9				ret 
16dc			 
16dc			; pop ret stack pointer 
16dc				 
16dc			FORTH_RSP_POP: macro 
16dc				call macro_forth_rsp_pop 
16dc				endm 
16dc			 
16dc			 
16dc			macro_forth_rsp_pop: 
16dc				if DEBUG_FORTH_STACK_GUARD 
16dc			;		DMARK "RPP" 
16dc cd bc 44				call check_stacks 
16df					FORTH_CHK_RSP_UNDER 
16df e5				push hl 
16e0 d5				push de 
16e1 2a 26 eb			ld hl,(cli_ret_sp) 
16e4 11 e0 ea			ld de, cli_ret_stack 
16e7 cd e4 09			call cmp16 
16ea da d0 45			jp c, fault_rsp_under 
16ed d1				pop de 
16ee e1				pop hl 
16ef				endm 
# End of macro FORTH_CHK_RSP_UNDER
16ef				endif 
16ef e5				push hl 
16f0 2a 26 eb			ld hl,(cli_ret_sp) 
16f3			 
16f3			 
16f3				if FORTH_ENABLE_FREE 
16f3			 
16f3					; get pointer 
16f3			 
16f3					push de 
16f3					push hl 
16f3			 
16f3					ld e, (hl) 
16f3					inc hl 
16f3					ld d, (hl) 
16f3			 
16f3					ex de, hl 
16f3					call free 
16f3			 
16f3					pop hl 
16f3					pop de 
16f3			 
16f3			 
16f3				endif 
16f3			 
16f3			 
16f3 2b				dec hl 
16f4 2b				dec hl 
16f5 22 26 eb			ld (cli_ret_sp), hl 
16f8				; do stack underflow checks 
16f8 e1				pop hl 
16f9				if DEBUG_FORTH_STACK_GUARD 
16f9 cd bc 44				call check_stacks 
16fc					FORTH_CHK_RSP_UNDER 
16fc e5				push hl 
16fd d5				push de 
16fe 2a 26 eb			ld hl,(cli_ret_sp) 
1701 11 e0 ea			ld de, cli_ret_stack 
1704 cd e4 09			call cmp16 
1707 da d0 45			jp c, fault_rsp_under 
170a d1				pop de 
170b e1				pop hl 
170c				endm 
# End of macro FORTH_CHK_RSP_UNDER
170c				endif 
170c c9				ret 
170d			 
170d			 
170d			 
170d			; routine to load word pointed to by hl into hl 
170d			 
170d			loadhlptrtohl: 
170d			 
170d d5				push de 
170e 5e				ld e, (hl) 
170f 23				inc hl 
1710 56				ld d, (hl) 
1711 eb				ex de, hl 
1712 d1				pop de 
1713			 
1713 c9				ret 
1714			 
1714			 
1714			 
1714			 
1714			 
1714			; push a number held in HL onto the data stack 
1714			; entry point for pushing a value when already in hl used in function above 
1714			 
1714			forth_push_numhl: 
1714			 
1714 e5				push hl    ; save value to push 
1715			 
1715			if DEBUG_FORTH_PUSH 
1715				; see if disabled 
1715			 
1715			 
1715				push af 
1715				ld a, (os_view_disable) 
1715				cp '*' 
1715				jr z, .pskip2 
1715				push hl 
1715			push hl 
1715				call clear_display 
1715			pop hl 
1715				ld a,h 
1715				ld hl, os_word_scratch 
1715				call hexout 
1715				pop hl 
1715				ld a,l 
1715				ld hl, os_word_scratch+2 
1715				call hexout 
1715			 
1715				ld hl, os_word_scratch+4 
1715				ld a,0 
1715				ld (hl),a 
1715				ld de,os_word_scratch 
1715					ld a, display_row_2 
1715					call str_at_display 
1715				ld de, .push_num 
1715				ld a, display_row_1 
1715			 
1715					call str_at_display 
1715			 
1715			 
1715				call update_display 
1715				call delay1s 
1715				call delay1s 
1715			.pskip2:  
1715			 
1715				pop af 
1715			endif	 
1715			 
1715			 
1715				FORTH_DSP_NEXT 
1715 cd a6 16			call macro_forth_dsp_next 
1718				endm 
# End of macro FORTH_DSP_NEXT
1718			 
1718 2a 22 eb			ld hl, (cli_data_sp) 
171b			 
171b				; save item type 
171b 3e 02			ld a,  DS_TYPE_INUM 
171d 77				ld (hl), a 
171e 23				inc hl 
171f			 
171f				; get word off stack 
171f d1				pop de 
1720 7b				ld a,e 
1721 77				ld (hl), a 
1722 23				inc hl 
1723 7a				ld a,d 
1724 77				ld (hl), a 
1725			 
1725			if DEBUG_FORTH_PUSH 
1725				dec hl 
1725				dec hl 
1725				dec hl 
1725						DMARK "PH5" 
1725				CALLMONITOR 
1725			endif	 
1725			 
1725 c9				ret 
1726			 
1726			 
1726			; Push a string to stack pointed to by hl 
1726			 
1726			forth_push_str: 
1726			 
1726			if DEBUG_FORTH_PUSH 
1726						DMARK "PSQ" 
1726				CALLMONITOR 
1726			endif	 
1726			    
1726 e5				push hl 
1727 e5				push hl 
1728			 
1728 3e 00			ld a, 0   ; find end of string 
172a cd 2f 0e			call strlent       
172d			if DEBUG_FORTH_PUSH 
172d						DMARK "PQ2" 
172d				CALLMONITOR 
172d			endif	 
172d eb				ex de, hl 
172e e1				pop hl   ; get ptr to start of string 
172f			if DEBUG_FORTH_PUSH 
172f						DMARK "PQ3" 
172f				CALLMONITOR 
172f			endif	 
172f 19				add hl,de 
1730			if DEBUG_FORTH_PUSH 
1730						DMARK "PQE" 
1730				CALLMONITOR 
1730			endif	 
1730			 
1730 2b				dec hl    ; see if there is an optional trailing double quote 
1731 7e				ld a,(hl) 
1732 fe 22			cp '"' 
1734 20 03			jr nz, .strnoq 
1736 3e 00			ld a, 0      ; get rid of double quote 
1738 77				ld (hl), a 
1739 23			.strnoq: inc hl 
173a			 
173a 3e 00			ld a, 0 
173c 77				ld (hl), a     ; add null term and get rid of trailing double quote 
173d			 
173d 13				inc de ; add one for the type string 
173e 13				inc de ; add one for null term??? 
173f			 
173f				; tos is get string pointer again 
173f				; de contains space to allocate 
173f				 
173f d5				push de 
1740			 
1740 eb				ex de, hl 
1741			 
1741				;push af 
1741			 
1741			if DEBUG_FORTH_PUSH 
1741						DMARK "PHm" 
1741				CALLMONITOR 
1741			endif	 
1741 cd 8d 0e			call malloc	; on ret hl now contains allocated memory 
1744				if DEBUG_FORTH_MALLOC_GUARD 
1744 cc 8d 34				call z,malloc_error 
1747				endif 
1747			 
1747				 
1747 c1				pop bc    ; get length 
1748 d1				pop de   ;  get string start    
1749			 
1749				; hl has destination from malloc 
1749			 
1749 eb				ex de, hl    ; prep for ldir 
174a			 
174a e5				push hl   ; save malloc area for DSP later 
174b			 
174b			if DEBUG_FORTH_PUSH 
174b						DMARK "PHc" 
174b				CALLMONITOR 
174b			endif	 
174b			 
174b			 
174b ed b0			ldir 
174d			 
174d			 
174d				; push malloc to data stack     macro?????  
174d			 
174d				FORTH_DSP_NEXT 
174d cd a6 16			call macro_forth_dsp_next 
1750				endm 
# End of macro FORTH_DSP_NEXT
1750			 
1750				; save value and type 
1750			 
1750 2a 22 eb			ld hl, (cli_data_sp) 
1753			 
1753				; save item type 
1753 3e 01			ld a,  DS_TYPE_STR 
1755 77				ld (hl), a 
1756 23				inc hl 
1757			 
1757				; get malloc word off stack 
1757 d1				pop de 
1758 73				ld (hl), e 
1759 23				inc hl 
175a 72				ld (hl), d 
175b			 
175b			 
175b			 
175b			if DEBUG_FORTH_PUSH 
175b				ld hl, (cli_data_sp) 
175b						DMARK "PHS" 
175b				CALLMONITOR 
175b			;	ex de,hl 
175b			endif	 
175b				; in case of spaces, skip the ptr past the copied string 
175b				;pop af 
175b				;ld (cli_origptr),hl 
175b			 
175b c9				ret 
175c			 
175c			 
175c			 
175c			; TODO ascii push input onto stack given hl to start of input 
175c			 
175c			; identify type 
175c			; if starts with a " then a string 
175c			; otherwise it is a number 
175c			;  
175c			; if a string 
175c			;     scan for ending " to get length of string to malloc for + 1 
175c			;     malloc 
175c			;     put pointer to string on stack first byte flags as string 
175c			; 
175c			; else a number 
175c			;    look for number format identifier 
175c			;    $xx hex 
175c			;    %xxxxx bin 
175c			;    xxxxx decimal 
175c			;    convert number to 16bit word.  
175c			;    malloc word + 1 with flag to identiy as num 
175c			;    put pointer to number on stack 
175c			;   
175c			;  
175c			  
175c			forth_apush: 
175c				; kernel push 
175c			 
175c			if DEBUG_FORTH_PUSH 
175c						DMARK "PSH" 
175c				CALLMONITOR 
175c			endif	 
175c				; identify input type 
175c			 
175c 7e				ld a,(hl) 
175d fe 22			cp '"' 
175f 28 0a			jr z, .fapstr 
1761 fe 24			cp '$' 
1763 ca 8b 17			jp z, .faphex 
1766 fe 25			cp '%' 
1768 ca 73 17			jp z, .fapbin 
176b			;	cp 'b' 
176b			;	jp z, .fabin 
176b				; else decimal 
176b			 
176b				; TODO do decimal conversion 
176b				; decimal is stored as a 16bit word 
176b			 
176b				; by default everything is a string if type is not detected 
176b			.fapstr: ; 
176b fe 22			cp '"' 
176d 20 01			jr nz, .strnoqu 
176f 23				inc hl 
1770			.strnoqu: 
1770 c3 26 17			jp forth_push_str 
1773			 
1773			 
1773			 
1773			.fapbin:    ; push a binary string.  
1773 11 00 00			ld de, 0   ; hold a 16bit value 
1776			 
1776 23			.fapbinshift:	inc hl  
1777 7e				ld a,(hl) 
1778 fe 00			cp 0     ; done scanning  
177a 28 0b			jr z, .fapbdone  	; got it in HL so push  
177c			 
177c				; left shift de 
177c eb				ex de, hl	 
177d 29				add hl, hl 
177e			 
177e				; is 1 
177e fe 31			cp '1' 
1780 20 02			jr nz, .binzero 
1782 cb 4d			bit 1, l 
1784			.binzero: 
1784 eb				ex de, hl	 ; save current de 
1785 18 ef			jr .fapbinshift 
1787			 
1787			.fapbdone: 
1787 eb				ex de, hl 
1788 c3 14 17			jp forth_push_numhl 
178b			 
178b			 
178b			.faphex:   ; hex is always stored as a 16bit word 
178b				; skip number prefix 
178b 23				inc hl 
178c				; turn ascii into number 
178c cd 7d 0d			call get_word_hl	; ret 16bit word in hl 
178f			 
178f c3 14 17			jp forth_push_numhl 
1792			 
1792 00				 nop 
1793			 
1793			.fabin:   ; TODO bin conversion 
1793			 
1793			 
1793 c9				ret 
1794			 
1794			 
1794			; get either a string ptr or a 16bit word from the data stack 
1794			 
1794			FORTH_DSP: macro 
1794				call macro_forth_dsp 
1794				endm 
1794			 
1794			macro_forth_dsp: 
1794				; data stack pointer points to current word on tos 
1794			 
1794 2a 22 eb			ld hl,(cli_data_sp) 
1797			 
1797				if DEBUG_FORTH_PUSH 
1797						DMARK "DSP" 
1797			 
1797					call display_data_sp 
1797				;call break_point_state 
1797				;rst 030h 
1797				CALLMONITOR 
1797				endif 
1797			 
1797 c9				ret 
1798			 
1798			; return hl to start of value on stack 
1798			 
1798			FORTH_DSP_VALUE: macro 
1798				call macro_forth_dsp_value 
1798				endm 
1798			 
1798			macro_forth_dsp_value: 
1798			 
1798				FORTH_DSP 
1798 cd 94 17			call macro_forth_dsp 
179b				endm 
# End of macro FORTH_DSP
179b			 
179b d5				push de 
179c			 
179c 23				inc hl ; skip type 
179d			 
179d 5e				ld e, (hl) 
179e 23				inc hl 
179f 56				ld d, (hl) 
17a0 eb				ex de,hl  
17a1			 
17a1 d1				pop de 
17a2			 
17a2 c9				ret 
17a3			 
17a3			; return hl to start of value to second item on stack 
17a3			 
17a3			FORTH_DSP_VALUEM1: macro 
17a3				call macro_forth_dsp_value_m1 
17a3				endm 
17a3			 
17a3			macro_forth_dsp_value_m1: 
17a3			 
17a3				FORTH_DSP 
17a3 cd 94 17			call macro_forth_dsp 
17a6				endm 
# End of macro FORTH_DSP
17a6			 
17a6 2b				dec hl 
17a7 2b				dec hl 
17a8			;	dec hl 
17a8			 
17a8 d5				push de 
17a9			 
17a9 5e				ld e, (hl) 
17aa 23				inc hl 
17ab 56				ld d, (hl) 
17ac eb				ex de,hl  
17ad			 
17ad d1				pop de 
17ae			 
17ae c9				ret 
17af			 
17af				 
17af			 
17af			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
17af			 
17af			FORTH_DSP_POP: macro 
17af				call macro_forth_dsp_pop 
17af				endm 
17af			 
17af			 
17af			; get the tos data type 
17af			 
17af			FORTH_DSP_TYPE:   macro 
17af			 
17af				;FORTH_DSP_VALUE 
17af				FORTH_DSP 
17af				 
17af				; hl points to value 
17af				; check type 
17af			 
17af				ld a,(hl) 
17af			 
17af				endm 
17af			 
17af			; load the tos value into hl 
17af			 
17af			 
17af			FORTH_DSP_VALUEHL:  macro 
17af				call macro_dsp_valuehl 
17af				endm 
17af			 
17af			 
17af			 
17af			macro_dsp_valuehl: 
17af				FORTH_DSP_VALUE 
17af cd 98 17			call macro_forth_dsp_value 
17b2				endm 
# End of macro FORTH_DSP_VALUE
17b2			 
17b2				;FORTH_ERR_TOS_NOTNUM 
17b2			 
17b2				;inc hl   ; skip type id 
17b2			 
17b2			;	push de 
17b2			; 
17b2			;	ld e, (hl) 
17b2			;	inc hl 
17b2			;	ld d, (hl) 
17b2			;	ex de,hl  
17b2			 
17b2			;	pop de 
17b2			 
17b2				if DEBUG_FORTH_PUSH 
17b2						DMARK "DVL" 
17b2				CALLMONITOR 
17b2				endif 
17b2 c9				ret 
17b3			 
17b3			forth_apushstrhl:      
17b3				; push of string requires use of cli_origptr 
17b3				; bodge use 
17b3			 
17b3				; get current cli_origptr, save, update with temp pointer  
17b3 ed 5b 3e eb		ld de, (cli_origptr) 
17b7 22 3e eb			ld (cli_origptr), hl 
17ba d5				push de 
17bb cd 5c 17			call forth_apush 
17be d1				pop de 
17bf ed 53 3e eb		ld (cli_origptr), de 
17c3 c9			        ret	 
17c4			 
17c4			 
17c4			; increase loop stack pointer and save hl to it 
17c4				 
17c4			FORTH_LOOP_NEXT: macro 
17c4				call macro_forth_loop_next 
17c4				;nop 
17c4				endm 
17c4			 
17c4			macro_forth_loop_next: 
17c4				if DEBUG_FORTH_STACK_GUARD 
17c4 cd bc 44				call check_stacks 
17c7				endif 
17c7 e5				push hl 
17c8 d5				push de 
17c9 eb				ex de,hl 
17ca 2a 24 eb			ld hl,(cli_loop_sp) 
17cd 23				inc hl 
17ce 23				inc hl 
17cf					if DEBUG_FORTH_WORDS 
17cf						DMARK "LNX" 
17cf						CALLMONITOR 
17cf					endif 
17cf 22 24 eb			ld (cli_loop_sp),hl 
17d2 73				ld (hl), e 
17d3 23				inc hl 
17d4 72				ld (hl), d 
17d5 d1				pop de    ; been reversed so save a swap on restore 
17d6 e1				pop hl 
17d7				if DEBUG_FORTH_STACK_GUARD 
17d7 cd bc 44				call check_stacks 
17da				endif 
17da c9				ret 
17db			 
17db			; get current ret stack pointer and save to hl  
17db				 
17db			FORTH_LOOP_TOS: macro 
17db				call macro_forth_loop_tos 
17db				endm 
17db			 
17db			macro_forth_loop_tos: 
17db d5				push de 
17dc 2a 24 eb			ld hl,(cli_loop_sp) 
17df 5e				ld e, (hl) 
17e0 23				inc hl 
17e1 56				ld d, (hl) 
17e2 eb				ex de, hl 
17e3 d1				pop de 
17e4 c9				ret 
17e5			 
17e5			; pop loop stack pointer 
17e5				 
17e5			FORTH_LOOP_POP: macro 
17e5				call macro_forth_loop_pop 
17e5				endm 
17e5			 
17e5			 
17e5			macro_forth_loop_pop: 
17e5				if DEBUG_FORTH_STACK_GUARD 
17e5					DMARK "LPP" 
17e5 f5				push af  
17e6 3a fa 17			ld a, (.dmark)  
17e9 32 7a ee			ld (debug_mark),a  
17ec 3a fb 17			ld a, (.dmark+1)  
17ef 32 7b ee			ld (debug_mark+1),a  
17f2 3a fc 17			ld a, (.dmark+2)  
17f5 32 7c ee			ld (debug_mark+2),a  
17f8 18 03			jr .pastdmark  
17fa ..			.dmark: db "LPP"  
17fd f1			.pastdmark: pop af  
17fe			endm  
# End of macro DMARK
17fe cd bc 44				call check_stacks 
1801					FORTH_CHK_LOOP_UNDER 
1801 e5				push hl 
1802 d5				push de 
1803 2a 24 eb			ld hl,(cli_loop_sp) 
1806 11 de e9			ld de, cli_loop_stack 
1809 cd e4 09			call cmp16 
180c da d6 45			jp c, fault_loop_under 
180f d1				pop de 
1810 e1				pop hl 
1811				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1811				endif 
1811 e5				push hl 
1812 2a 24 eb			ld hl,(cli_loop_sp) 
1815 2b				dec hl 
1816 2b				dec hl 
1817 22 24 eb			ld (cli_loop_sp), hl 
181a				; TODO do stack underflow checks 
181a e1				pop hl 
181b				if DEBUG_FORTH_STACK_GUARD 
181b cd bc 44				call check_stacks 
181e					FORTH_CHK_LOOP_UNDER 
181e e5				push hl 
181f d5				push de 
1820 2a 24 eb			ld hl,(cli_loop_sp) 
1823 11 de e9			ld de, cli_loop_stack 
1826 cd e4 09			call cmp16 
1829 da d6 45			jp c, fault_loop_under 
182c d1				pop de 
182d e1				pop hl 
182e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
182e				endif 
182e c9				ret 
182f			 
182f			macro_forth_dsp_pop: 
182f			 
182f e5				push hl 
1830			 
1830				; release malloc data 
1830			 
1830				if DEBUG_FORTH_STACK_GUARD 
1830 cd bc 44				call check_stacks 
1833					FORTH_CHK_DSP_UNDER 
1833 e5				push hl 
1834 d5				push de 
1835 2a 22 eb			ld hl,(cli_data_sp) 
1838 11 dc e8			ld de, cli_data_stack 
183b cd e4 09			call cmp16 
183e da ca 45			jp c, fault_dsp_under 
1841 d1				pop de 
1842 e1				pop hl 
1843				endm 
# End of macro FORTH_CHK_DSP_UNDER
1843				endif 
1843				;ld hl,(cli_data_sp) 
1843			if DEBUG_FORTH_DOT 
1843				DMARK "DPP" 
1843				CALLMONITOR 
1843			endif	 
1843			 
1843			 
1843			if FORTH_ENABLE_DSPPOPFREE 
1843			 
1843				FORTH_DSP 
1843 cd 94 17			call macro_forth_dsp 
1846				endm 
# End of macro FORTH_DSP
1846			 
1846 7e				ld a, (hl) 
1847 fe 01			cp DS_TYPE_STR 
1849 20 07			jr nz, .skippopfree 
184b			 
184b				FORTH_DSP_VALUEHL 
184b cd af 17			call macro_dsp_valuehl 
184e				endm 
# End of macro FORTH_DSP_VALUEHL
184e 00				nop 
184f			if DEBUG_FORTH_DOT 
184f				DMARK "DPf" 
184f				CALLMONITOR 
184f			endif	 
184f cd 57 0f			call free 
1852			.skippopfree: 
1852				 
1852			 
1852			endif 
1852			 
1852			if DEBUG_FORTH_DOT_KEY 
1852				DMARK "DP2" 
1852				CALLMONITOR 
1852			endif	 
1852			 
1852				; move pointer down 
1852			 
1852 2a 22 eb			ld hl,(cli_data_sp) 
1855 2b				dec hl 
1856 2b				dec hl 
1857			; PARSEV5 
1857 2b				dec hl 
1858 22 22 eb			ld (cli_data_sp), hl 
185b			 
185b				if DEBUG_FORTH_STACK_GUARD 
185b cd bc 44				call check_stacks 
185e					FORTH_CHK_DSP_UNDER 
185e e5				push hl 
185f d5				push de 
1860 2a 22 eb			ld hl,(cli_data_sp) 
1863 11 dc e8			ld de, cli_data_stack 
1866 cd e4 09			call cmp16 
1869 da ca 45			jp c, fault_dsp_under 
186c d1				pop de 
186d e1				pop hl 
186e				endm 
# End of macro FORTH_CHK_DSP_UNDER
186e				endif 
186e			 
186e e1				pop hl 
186f			 
186f c9				ret 
1870			 
1870			getwordathl: 
1870				; hl points to an address 
1870				; load hl with the word at that address 
1870			 
1870 d5				push de 
1871			 
1871 5e				ld e, (hl) 
1872 23				inc hl 
1873 56				ld d, (hl) 
1874 eb				ex de, hl 
1875			 
1875 d1				pop de 
1876 c9				ret 
1877			 
1877			 
1877			 
1877			 
1877			 
1877			; eof 
1877			 
# End of file forth_stackopsv5.asm
1877			endif 
1877			 
1877			user_word_eol:  
1877				; hl contains the pointer to where to create a linked list item from the end 
1877				; of the user dict to continue on at the system word dict 
1877				 
1877				; poke the stub of the word list linked list to repoint to rom words 
1877			 
1877				; stub format 
1877				; db   word id 
1877				; dw    link to next word 
1877			        ; db char length of token 
1877				; db string + 0 term 
1877				; db exec code....  
1877			 
1877 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1879 77				ld (hl), a		; word id 
187a 23				inc hl 
187b			 
187b 11 41 1a			ld de, sysdict 
187e 73				ld (hl), e		; next word link ie system dict 
187f 23				inc hl 
1880 72				ld (hl), d		; next word link ie system dict 
1881 23				inc hl	 
1882			 
1882			;	ld (hl), sysdict		; next word link ie system dict 
1882			;	inc hl 
1882			;	inc hl 
1882			 
1882			;	inc hl 
1882			;	inc hl 
1882			 
1882 3e 02			ld a, 2			; word length is 0 
1884 77				ld (hl), a	 
1885 23				inc hl 
1886			 
1886 3e 7e			ld a, '~'			; word length is 0 
1888 77				ld (hl), a	 
1889 23				inc hl 
188a 3e 00			ld a, 0			; save empty word 
188c 77				ld (hl), a 
188d			 
188d c9				ret 
188e			 
188e				 
188e			 
188e			forthexec_cleanup: 
188e				FORTH_RSP_POP 
188e cd dc 16			call macro_forth_rsp_pop 
1891				endm 
# End of macro FORTH_RSP_POP
1891 c9				ret 
1892			 
1892			forth_call_hl: 
1892				; taking hl 
1892 e5				push hl 
1893 c9				ret 
1894			 
1894			; this is called to reset Forth system but keep existing uwords etc 
1894			 
1894			forth_warmstart: 
1894				; setup stack over/under flow checks 
1894				if DEBUG_FORTH_STACK_GUARD 
1894 cd a2 44				call chk_stk_init 
1897				endif 
1897			 
1897				; init stack pointers  - * these stacks go upwards *  
1897 21 e0 ea			ld hl, cli_ret_stack 
189a 22 26 eb			ld (cli_ret_sp), hl	 
189d				; set bottom of stack 
189d 3e 00			ld a,0 
189f 77				ld (hl),a 
18a0 23				inc hl 
18a1 77				ld (hl),a 
18a2			 
18a2 21 dc e8			ld hl, cli_data_stack 
18a5 22 22 eb			ld (cli_data_sp), hl	 
18a8				; set bottom of stack 
18a8 3e 00			ld a,0 
18aa 77				ld (hl),a 
18ab 23				inc hl 
18ac 77				ld (hl),a 
18ad			 
18ad 21 de e9			ld hl, cli_loop_stack 
18b0 22 24 eb			ld (cli_loop_sp), hl	 
18b3				; set bottom of stack 
18b3 3e 00			ld a,0 
18b5 77				ld (hl),a 
18b6 23				inc hl 
18b7 77				ld (hl),a 
18b8			 
18b8				; init extent of current open file 
18b8			 
18b8 3e 00			ld a, 0 
18ba 32 5c eb			ld (store_openext), a 
18bd			 
18bd c9				ret 
18be			 
18be			 
18be			; Cold Start - this is called to setup the whole Forth system 
18be			 
18be			forth_init: 
18be			 
18be				; setup stack over/under flow checks 
18be			 
18be			;	if DEBUG_FORTH_STACK_GUARD 
18be			;		call chk_stk_init 
18be			;	endif 
18be			 
18be				; enable auto display updates (slow.....) 
18be			 
18be 3e 01			ld a, 1 
18c0 32 3c eb			ld (cli_autodisplay), a 
18c3			 
18c3			 
18c3			 
18c3				; show start up screen 
18c3			 
18c3 cd 6d 08			call clear_display 
18c6			 
18c6 3e 00			ld a,0 
18c8 32 5e eb			ld (f_cursor_ptr), a 
18cb			 
18cb				; set start of word list in start of ram - for use when creating user words 
18cb			 
18cb 21 c5 47			ld hl, baseram 
18ce 22 72 e6			ld (os_last_new_uword), hl 
18d1 cd 77 18			call user_word_eol 
18d4				 
18d4			;		call display_data_sp 
18d4			;		call next_page_prompt 
18d4			 
18d4			 
18d4			 
18d4			 
18d4 c9				ret 
18d5			 
18d5 .. 00		.bootforth: db " Forth Kernel Init ",0 
18e9			 
18e9			; TODO push to stack 
18e9			 
18e9			;  
18e9			 
18e9			if FORTH_PARSEV2 
18e9			 
18e9			 
18e9				include "forth_parserv2.asm" 
18e9			 
18e9			endif 
18e9			 
18e9			 
18e9			; parse cli version 1 
18e9			 
18e9			if FORTH_PARSEV1 
18e9			 
18e9			 
18e9			 
18e9			      include "forth_parserv1.asm" 
18e9			endif 
18e9				 
18e9			if FORTH_PARSEV3 
18e9			 
18e9			 
18e9			 
18e9			      include "forth_parserv3.asm" 
18e9				include "forth_wordsv3.asm" 
18e9			endif 
18e9			 
18e9			if FORTH_PARSEV4 
18e9			 
18e9			 
18e9			 
18e9			      include "forth_parserv4.asm" 
18e9				include "forth_wordsv4.asm" 
18e9			endif 
18e9			 
18e9			if FORTH_PARSEV5 
18e9			 
18e9			 
18e9			 
18e9			      include "forth_parserv5.asm" 
18e9			 
18e9			 
18e9			; A better parser without using malloc and string copies all over the place.  
18e9			; Exec in situ should be faster 
18e9			 
18e9			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
18e9			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
18e9			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
18e9			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
18e9			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
18e9			WORD_SYS_END: equ 0   ; Opcode for all user words 
18e9			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
18e9			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
18e9			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
18e9			 
18e9			; Core word preamble macro 
18e9			 
18e9			CWHEAD:   macro nxtword opcode lit len opflags 
18e9				db WORD_SYS_CORE+opcode             
18e9				; internal op code number 
18e9				dw nxtword            
18e9				; link to next dict word block 
18e9				db len + 1 
18e9				; literal length of dict word inc zero term 
18e9				db lit,0              
18e9				; literal dict word 
18e9			        ; TODO db opflags        
18e9				endm 
18e9			 
18e9			 
18e9			NEXTW: macro  
18e9				jp macro_next 
18e9				endm 
18e9			 
18e9			macro_next: 
18e9			if DEBUG_FORTH_PARSE_KEY 
18e9				DMARK "NXT" 
18e9				CALLMONITOR 
18e9			endif	 
18e9			;	inc hl  ; skip token null term  
18e9 ed 4b 40 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
18ed ed 5b 3e eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
18f1 2a 76 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
18f4			if DEBUG_FORTH_PARSE_KEY 
18f4				DMARK "}AA" 
18f4				CALLMONITOR 
18f4			endif	 
18f4 c3 f7 19			jp execnext 
18f7				;jp exec1 
18f7			       
18f7			 
18f7			 
18f7			; Another go at the parser to compile  
18f7			 
18f7			 
18f7			; TODO rework parser to change all of the string words to byte tokens 
18f7			; TODO do a search for  
18f7			 
18f7			; TODO first run normal parser to zero term sections 
18f7			; TODO for each word do a token look up to get the op code 
18f7			; TODO need some means to flag to the exec that this is a byte code form    
18f7			 
18f7			 
18f7			forthcompile: 
18f7			 
18f7			; 
18f7			; line parse: 
18f7			;       parse raw input buffer 
18f7			;       tokenise the words 
18f7			;       malloc new copy (for looping etc) 
18f7			;       copy to malloc + current pc in line to start of string and add line term 
18f7			;       save on new rsp 
18f7			; 
18f7			 
18f7			; hl to point to the line to tokenise 
18f7			 
18f7			;	push hl 
18f7 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
18fa			 
18fa			;	ld a,0		; string term on input 
18fa			;	call strlent 
18fa			 
18fa			;	ld (os_tok_len), hl	 ; save string length 
18fa			 
18fa			;if DEBUG_FORTH_TOK 
18fa			;	ex de,hl		 
18fa			;endif 
18fa			 
18fa			;	pop hl 		; get back string pointer 
18fa			 
18fa			if DEBUG_FORTH_TOK 
18fa						DMARK "TOc" 
18fa				CALLMONITOR 
18fa			endif 
18fa 7e			.cptoken2:    ld a,(hl) 
18fb 23				inc hl 
18fc fe 7f			cp FORTH_END_BUFFER 
18fe 28 29			jr z, .cptokendone2 
1900 fe 00			cp 0 
1902 28 25			jr z, .cptokendone2 
1904 fe 22			cp '"' 
1906 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1908 fe 20			cp ' ' 
190a 20 ee			jr nz,  .cptoken2 
190c			 
190c			; TODO consume comments held between ( and ) 
190c			 
190c				; we have a space so change to zero term for dict match later 
190c 2b				dec hl 
190d 3e 00			ld a,0 
190f 77				ld (hl), a 
1910 23				inc hl 
1911 18 e7			jr .cptoken2 
1913				 
1913			 
1913			.cptokenstr2: 
1913				; skip all white space until either eol (because forgot to term) or end double quote 
1913			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1913				;inc hl ; skip current double quote 
1913 7e				ld a,(hl) 
1914 23				inc hl 
1915 fe 22			cp '"' 
1917 28 e1			jr z, .cptoken2 
1919 fe 7f			cp FORTH_END_BUFFER 
191b 28 0c			jr z, .cptokendone2 
191d fe 00			cp 0 
191f 28 08			jr z, .cptokendone2 
1921 fe 20			cp ' ' 
1923 28 02			jr z, .cptmp2 
1925 18 ec			jr .cptokenstr2 
1927			 
1927			.cptmp2:	; we have a space so change to zero term for dict match later 
1927				;dec hl 
1927				;ld a,"-"	; TODO remove this when working 
1927				;ld (hl), a 
1927				;inc hl 
1927 18 ea			jr .cptokenstr2 
1929			 
1929			.cptokendone2: 
1929				;inc hl 
1929 3e 7f			ld a, FORTH_END_BUFFER 
192b 77				ld (hl),a 
192c 23				inc hl 
192d 3e 21			ld a, '!' 
192f 77				ld (hl),a 
1930			 
1930 2a 76 e6			ld hl,(os_tok_ptr) 
1933			         
1933			if DEBUG_FORTH_TOK 
1933						DMARK "Tc1" 
1933				CALLMONITOR 
1933			endif 
1933			 
1933				; push exec string to top of return stack 
1933				FORTH_RSP_NEXT 
1933 cd be 16			call macro_forth_rsp_next 
1936				endm 
# End of macro FORTH_RSP_NEXT
1936 c9				ret 
1937			 
1937			; Another go at the parser need to simplify the process 
1937			 
1937			forthparse: 
1937			 
1937			; 
1937			; line parse: 
1937			;       parse raw input buffer 
1937			;       tokenise the words 
1937			;       malloc new copy (for looping etc) 
1937			;       copy to malloc + current pc in line to start of string and add line term 
1937			;       save on new rsp 
1937			; 
1937			 
1937			; hl to point to the line to tokenise 
1937			 
1937			;	push hl 
1937 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
193a			 
193a			;	ld a,0		; string term on input 
193a			;	call strlent 
193a			 
193a			;	ld (os_tok_len), hl	 ; save string length 
193a			 
193a			;if DEBUG_FORTH_TOK 
193a			;	ex de,hl		 
193a			;endif 
193a			 
193a			;	pop hl 		; get back string pointer 
193a			 
193a			if DEBUG_FORTH_TOK 
193a						DMARK "TOK" 
193a				CALLMONITOR 
193a			endif 
193a 7e			.ptoken2:    ld a,(hl) 
193b 23				inc hl 
193c fe 7f			cp FORTH_END_BUFFER 
193e 28 29			jr z, .ptokendone2 
1940 fe 00			cp 0 
1942 28 25			jr z, .ptokendone2 
1944 fe 22			cp '"' 
1946 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1948 fe 20			cp ' ' 
194a 20 ee			jr nz,  .ptoken2 
194c			 
194c			; TODO consume comments held between ( and ) 
194c			 
194c				; we have a space so change to zero term for dict match later 
194c 2b				dec hl 
194d 3e 00			ld a,0 
194f 77				ld (hl), a 
1950 23				inc hl 
1951 18 e7			jr .ptoken2 
1953				 
1953			 
1953			.ptokenstr2: 
1953				; skip all white space until either eol (because forgot to term) or end double quote 
1953			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1953				;inc hl ; skip current double quote 
1953 7e				ld a,(hl) 
1954 23				inc hl 
1955 fe 22			cp '"' 
1957 28 e1			jr z, .ptoken2 
1959 fe 7f			cp FORTH_END_BUFFER 
195b 28 0c			jr z, .ptokendone2 
195d fe 00			cp 0 
195f 28 08			jr z, .ptokendone2 
1961 fe 20			cp ' ' 
1963 28 02			jr z, .ptmp2 
1965 18 ec			jr .ptokenstr2 
1967			 
1967			.ptmp2:	; we have a space so change to zero term for dict match later 
1967				;dec hl 
1967				;ld a,"-"	; TODO remove this when working 
1967				;ld (hl), a 
1967				;inc hl 
1967 18 ea			jr .ptokenstr2 
1969			 
1969			.ptokendone2: 
1969				;inc hl 
1969 3e 7f			ld a, FORTH_END_BUFFER 
196b 77				ld (hl),a 
196c 23				inc hl 
196d 3e 21			ld a, '!' 
196f 77				ld (hl),a 
1970			 
1970 2a 76 e6			ld hl,(os_tok_ptr) 
1973			         
1973			if DEBUG_FORTH_TOK 
1973						DMARK "TK1" 
1973				CALLMONITOR 
1973			endif 
1973			 
1973				; push exec string to top of return stack 
1973				FORTH_RSP_NEXT 
1973 cd be 16			call macro_forth_rsp_next 
1976				endm 
# End of macro FORTH_RSP_NEXT
1976 c9				ret 
1977			 
1977			; 
1977			;	; malloc size + buffer pointer + if is loop flag 
1977			;	ld hl,(os_tok_len) 		 ; get string length 
1977			; 
1977			;	ld a,l 
1977			; 
1977			;	cp 0			; we dont want to use a null string 
1977			;	ret z 
1977			; 
1977			;;	add 3    ; prefix malloc with buffer for current word ptr 
1977			; 
1977			;	add 5     ; TODO when certain not over writing memory remove 
1977			; 
1977			;		 
1977			; 
1977			;if DEBUG_FORTH_TOK 
1977			;			DMARK "TKE" 
1977			;	CALLMONITOR 
1977			;endif 
1977			; 
1977			;	ld l,a 
1977			;	ld h,0 
1977			;;	push hl   ; save required space for the copy later 
1977			;	call malloc 
1977			;if DEBUG_FORTH_TOK 
1977			;			DMARK "TKM" 
1977			;	CALLMONITOR 
1977			;endif 
1977			;	if DEBUG_FORTH_MALLOC_GUARD 
1977			;		push af 
1977			;		call ishlzero 
1977			;;		ld a, l 
1977			;;		add h 
1977			;;		cp 0 
1977			;		pop af 
1977			;		 
1977			;		call z,malloc_error 
1977			;	endif 
1977			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1977			; 
1977			; 
1977			;if DEBUG_FORTH_TOK 
1977			;			DMARK "TKR" 
1977			;	CALLMONITOR 
1977			;endif 
1977			; 
1977			;	FORTH_RSP_NEXT 
1977			; 
1977			;	;inc hl	 ; go past current buffer pointer 
1977			;	;inc hl 
1977			;	;inc hl   ; and past if loop flag 
1977			;		; TODO Need to set flag  
1977			; 
1977			;	 
1977			;	 
1977			;	ex de,hl	; malloc is dest 
1977			;	ld hl, (os_tok_len) 
1977			;;	pop bc 
1977			;	ld c, l                
1977			;	ld b,0 
1977			;	ld hl, (os_tok_ptr) 
1977			; 
1977			;if DEBUG_FORTH_TOK 
1977			;			DMARK "TKT" 
1977			;	CALLMONITOR 
1977			;endif 
1977			; 
1977			;	; do str cpy 
1977			; 
1977			;	ldir      ; copy byte in hl to de 
1977			; 
1977			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1977			; 
1977			;if DEBUG_FORTH_TOK 
1977			; 
1977			;			DMARK "TKY" 
1977			;	CALLMONITOR 
1977			;endif 
1977			;	;ld a,0 
1977			;	;ld a,FORTH_END_BUFFER 
1977			;	ex de, hl 
1977			;	;dec hl			 ; go back over the space delim at the end of word 
1977			;	;ld (hl),a 
1977			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1977			;	ld a,FORTH_END_BUFFER 
1977			;	ld (hl),a 
1977			;	inc hl 
1977			;	ld a,FORTH_END_BUFFER 
1977			;	ld (hl),a 
1977			; 
1977			;	; init the malloc area data 
1977			;	; set pc for in current area 
1977			;	;ld hl, (os_tok_malloc) 
1977			;	;inc hl 
1977			;	;inc hl 
1977			;	;inc hl 
1977			;	;ex de,hl 
1977			;	;ld hl, (os_tok_malloc) 
1977			;	;ld (hl),e 
1977			;	;inc hl 
1977			;	;ld (hl),d 
1977			; 
1977			; 
1977			;	ld hl,(os_tok_malloc) 
1977			;if DEBUG_FORTH_PARSE_KEY 
1977			;			DMARK "TKU" 
1977			;	CALLMONITOR 
1977			;endif 
1977			; 
1977			;	ret 
1977			 
1977			forthexec: 
1977			 
1977			; line exec: 
1977			; forth parser 
1977			 
1977			; 
1977			;       get current exec line on rsp 
1977			 
1977				FORTH_RSP_TOS 
1977 cd d5 16			call macro_forth_rsp_tos 
197a				endm 
# End of macro FORTH_RSP_TOS
197a			 
197a			;       restore current pc - hl points to malloc of data 
197a			 
197a				;ld e, (hl) 
197a				;inc hl 
197a				;ld d, (hl) 
197a				;ex de,hl 
197a			 
197a			 
197a			exec1: 
197a 22 76 e6			ld (os_tok_ptr), hl 
197d			 
197d				; copy our PC to working vars  
197d 22 40 eb			ld (cli_ptr), hl 
1980 22 3e eb			ld (cli_origptr), hl 
1983			 
1983 7e				ld a,(hl) 
1984 fe 7f			cp FORTH_END_BUFFER 
1986 c8				ret z 
1987			 
1987				; skip any nulls 
1987			 
1987 fe 00			cp 0 
1989 20 03			jr nz, .execword 
198b 23				inc hl 
198c 18 ec			jr exec1 
198e			 
198e			 
198e			.execword: 
198e			 
198e			 
198e			 
198e			if DEBUG_FORTH_PARSE_KEY 
198e						DMARK "KYQ" 
198e				CALLMONITOR 
198e			endif 
198e			;       while at start of word: 
198e			; get start of dict (in user area first) 
198e			 
198e 21 c5 47		ld hl, baseram 
1991			;ld hl, sysdict 
1991 22 42 eb		ld (cli_nextword),hl 
1994			;           match word at pc 
1994			;           exec word 
1994			;           or push to dsp 
1994			;           forward to next token 
1994			;           if line term pop rsp and exit 
1994			;        
1994			 
1994			if DEBUG_FORTH_PARSE_KEY 
1994						DMARK "KYq" 
1994				CALLMONITOR 
1994			endif 
1994			 
1994			; 
1994			; word comp 
1994			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1994			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1994			;    move to start of word  
1994			;    compare word to cli_token 
1994			 
1994			.execpnword:	; HL at start of a word in the dictionary to check 
1994			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1994			;	ld (cli_ptr), hl 
1994			 
1994 2a 42 eb			ld hl,(cli_nextword) 
1997			 
1997 cd 3a 1a			call forth_tok_next 
199a			; tok next start here 
199a			;	; TODO skip compiled symbol for now 
199a			;	inc hl 
199a			; 
199a			;	; save pointer to next word 
199a			; 
199a			;	; hl now points to the address of the next word pointer  
199a			;	ld e, (hl) 
199a			;	inc hl 
199a			;	ld d, (hl) 
199a			;	inc l 
199a			; 
199a			;	ex de,hl 
199a			;if DEBUG_FORTH_PARSE_NEXTWORD 
199a			;	push bc 
199a			;	ld bc, (cli_nextword) 
199a			;			DMARK "NXW" 
199a			;	CALLMONITOR 
199a			;	pop bc 
199a			;endif 
199a			; tok next end here 
199a 22 42 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
199d eb				ex de, hl 
199e			 
199e			 
199e				; save the pointer of the current token - 1 to check against 
199e				 
199e 22 46 eb			ld (cli_token), hl   
19a1				; TODO maybe remove below save if no debug 
19a1				; save token string ptr for any debug later 
19a1 23				inc hl  
19a2 22 48 eb			ld (cli_origtoken), hl 
19a5 2b				dec hl 
19a6				; save pointer to the start of the next dictionay word 
19a6 7e				ld a,(hl)   ; get string length 
19a7 47				ld b,a 
19a8			.execpnwordinc:  
19a8 23				inc hl 
19a9 10 fd			djnz .execpnwordinc 
19ab 22 44 eb			ld (cli_execword), hl      ; save start of this words code 
19ae			 
19ae				; now check the word token against the string being parsed 
19ae			 
19ae 2a 46 eb			ld hl,(cli_token) 
19b1 23				inc hl     ; skip string length (use zero term instead to end) 
19b2 22 46 eb			ld (cli_token), hl 
19b5			 
19b5			if DEBUG_FORTH_PARSE_KEY 
19b5						DMARK "KY2" 
19b5			endif 
19b5			if DEBUG_FORTH_PARSE_EXEC 
19b5				; see if disabled 
19b5			 
19b5				ld a, (os_view_disable) 
19b5				cp '*' 
19b5				jr z, .skip 
19b5			 
19b5				push hl 
19b5				push hl 
19b5				call clear_display 
19b5				ld de, .compword 
19b5				ld a, display_row_1 
19b5				call str_at_display 
19b5				pop de 
19b5				ld a, display_row_2 
19b5				call str_at_display 
19b5				ld hl,(cli_ptr) 
19b5				ld a,(hl) 
19b5			        ld hl, os_word_scratch 
19b5				ld (hl),a 
19b5				ld a,0 
19b5				inc hl 
19b5				ld (hl),a 	 
19b5				ld de, os_word_scratch 
19b5				ld a, display_row_2+10 
19b5				call str_at_display 
19b5				call update_display 
19b5				ld a, 100 
19b5				call aDelayInMS 
19b5				if DEBUG_FORTH_PARSE_EXEC_SLOW 
19b5				call delay250ms 
19b5				endif 
19b5				pop hl 
19b5			.skip:  
19b5			endif	 
19b5			.execpnchar:    ; compare char between token and string to parse 
19b5			 
19b5			if DEBUG_FORTH_PARSE_KEY 
19b5						DMARK "Ky3" 
19b5			endif 
19b5			if DEBUG_FORTH_PARSE_EXEC 
19b5				; see if disabled 
19b5			 
19b5				ld a, (os_view_disable) 
19b5				cp '*' 
19b5				jr z, .skip2 
19b5			 
19b5			;	call clear_display 
19b5			ld hl,(cli_token) 
19b5			ld a,(hl) 
19b5			ld (os_word_scratch),a 
19b5				ld hl,(cli_ptr) 
19b5			ld a,(hl) 
19b5				ld (os_word_scratch+1),a 
19b5				ld a,0 
19b5				ld (os_word_scratch+2),a 
19b5				ld de,os_word_scratch 
19b5				ld a,display_row_4 
19b5				call str_at_display 
19b5				call update_display 
19b5			.skip2:  
19b5			endif 
19b5 2a 46 eb			ld hl,(cli_token) 
19b8 7e				ld a, (hl)	 ; char in word token 
19b9 23				inc hl 		; move to next char 
19ba 22 46 eb			ld (cli_token), hl ; and save it 
19bd 47				ld b,a 
19be			 
19be 2a 40 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
19c1 7e				ld a,(hl) 
19c2 23				inc hl 
19c3 22 40 eb			ld (cli_ptr), hl		; move to next char 
19c6 cd 1b 0e			call toUpper 		; make sure the input string matches case 
19c9			 
19c9			if DEBUG_FORTH_PARSE 
19c9			endif 
19c9			 
19c9				; input stream end of token is a space so get rid of it 
19c9			 
19c9			;	cp ' ' 
19c9			;	jr nz, .pnskipspace 
19c9			; 
19c9			;	ld a, 0		; make same term as word token term 
19c9			; 
19c9			;.pnskipspace: 
19c9			 
19c9			if DEBUG_FORTH_PARSE_KEY 
19c9						DMARK "KY7" 
19c9			endif 
19c9 b8				cp b 
19ca c2 e0 19			jp nz, .execpnskipword	 ; no match so move to next word 
19cd				 
19cd			;    if same 
19cd			;       scan for string terms 0 for token and 32 for input 
19cd			 
19cd				 
19cd			if DEBUG_FORTH_PARSE_KEY 
19cd						DMARK "KY8" 
19cd			endif 
19cd			 
19cd 80				add b			 
19ce fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
19d0							; TODO need to make sure last word in zero term string is accounted for 
19d0 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
19d2			 
19d2			 
19d2				; at end of both strings so both are exact match 
19d2			 
19d2			;       skip ptr for next word 
19d2			 
19d2 2a 40 eb			ld hl,(cli_ptr) 	; at input string term 
19d5 23				inc hl			 ; at next char 
19d6 22 40 eb			ld (cli_ptr), hl     ; save for next round of the parser 
19d9 22 3e eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
19dc				 
19dc				 
19dc			if DEBUG_FORTH_PARSE_KEY 
19dc						DMARK "KY3" 
19dc			endif 
19dc			 
19dc			 
19dc			 
19dc			;       exec code block 
19dc			if DEBUG_FORTH_JP 
19dc				call clear_display 
19dc				call update_display 
19dc				call delay1s 
19dc				ld hl, (cli_execword)     ; save for next check if no match on this word 
19dc				ld a,h 
19dc				ld hl, os_word_scratch 
19dc				call hexout 
19dc				ld hl, (cli_execword)     ; save for next check if no match on this word 
19dc				ld a,l 
19dc				ld hl, os_word_scratch+2 
19dc				call hexout 
19dc				ld hl, os_word_scratch+4 
19dc				ld a,0 
19dc				ld (hl),a 
19dc				ld de,os_word_scratch 
19dc				call str_at_display 
19dc					ld a, display_row_2 
19dc					call str_at_display 
19dc				ld de, (cli_origtoken) 
19dc				ld a, display_row_1+10 
19dc					call str_at_display 
19dc			 
19dc				ld a,display_row_1 
19dc				ld de, .foundword 
19dc				ld a, display_row_3 
19dc				call str_at_display 
19dc				call update_display 
19dc				call delay1s 
19dc				call delay1s 
19dc				call delay1s 
19dc			endif 
19dc			 
19dc			if DEBUG_FORTH_PARSE_KEY 
19dc						DMARK "KYj" 
19dc			endif 
19dc				; TODO save the word pointer in this exec 
19dc			 
19dc 2a 44 eb			ld hl,(cli_execword) 
19df e9				jp (hl) 
19e0			 
19e0			 
19e0			;    if not same 
19e0			;	scan for zero term 
19e0			;	get ptr for next word 
19e0			;	goto word comp 
19e0			 
19e0			.execpnskipword:	; get pointer to next word 
19e0 2a 42 eb			ld hl,(cli_nextword) 
19e3			 
19e3 7e				ld a,(hl) 
19e4 fe 00			cp WORD_SYS_END 
19e6			;	cp 0 
19e6 28 09			jr z, .execendofdict			 ; at end of words 
19e8			 
19e8			if DEBUG_FORTH_PARSE_KEY 
19e8						DMARK "KY4" 
19e8			endif 
19e8			if DEBUG_FORTH_PARSE_EXEC 
19e8			 
19e8				; see if disabled 
19e8			 
19e8				ld a, (os_view_disable) 
19e8				cp '*' 
19e8				jr z, .noskip 
19e8			 
19e8			 
19e8				ld de, .nowordfound 
19e8				ld a, display_row_3 
19e8				call str_at_display 
19e8				call update_display 
19e8				ld a, 100 
19e8				call aDelayInMS 
19e8				 
19e8				if DEBUG_FORTH_PARSE_EXEC_SLOW 
19e8					call delay250ms 
19e8				endif 
19e8			.noskip:  
19e8			 
19e8			endif	 
19e8			 
19e8 2a 3e eb			ld hl,(cli_origptr) 
19eb 22 40 eb			ld (cli_ptr),hl 
19ee			 
19ee			if DEBUG_FORTH_PARSE_KEY 
19ee						DMARK "KY5" 
19ee			endif 
19ee c3 94 19			jp .execpnword			; else go to next word 
19f1			 
19f1			.execendofdict:  
19f1			 
19f1			if DEBUG_FORTH_PARSE_KEY 
19f1						DMARK "KYe" 
19f1			endif 
19f1			if DEBUG_FORTH_PARSE_EXEC 
19f1				; see if disabled 
19f1			 
19f1				ld a, (os_view_disable) 
19f1				cp '*' 
19f1				jr z, .ispskip 
19f1			 
19f1				call clear_display 
19f1				call update_display 
19f1				call delay1s 
19f1				ld de, (cli_origptr) 
19f1				ld a, display_row_1 
19f1				call str_at_display 
19f1				 
19f1				ld de, .enddict 
19f1				ld a, display_row_3 
19f1				call str_at_display 
19f1				call update_display 
19f1				ld a, 100 
19f1				call aDelayInMS 
19f1				if DEBUG_FORTH_PARSE_EXEC_SLOW 
19f1				call delay1s 
19f1				call delay1s 
19f1				call delay1s 
19f1				endif 
19f1			.ispskip:  
19f1				 
19f1			endif	 
19f1			 
19f1			 
19f1			 
19f1				; if the word is not a keyword then must be a literal so push it to stack 
19f1			 
19f1			; push token to stack to end of word 
19f1			 
19f1				STACKFRAME ON $1efe $2f9f 
19f1				if DEBUG_STACK_IMB 
19f1					if ON 
19f1						exx 
19f1						ld de, $1efe 
19f1						ld a, d 
19f1						ld hl, curframe 
19f1						call hexout 
19f1						ld a, e 
19f1						ld hl, curframe+2 
19f1						call hexout 
19f1						ld hl, $1efe 
19f1						push hl 
19f1						ld hl, $2f9f 
19f1						push hl 
19f1						exx 
19f1					endif 
19f1				endif 
19f1			endm 
# End of macro STACKFRAME
19f1			 
19f1 2a 76 e6		ld hl,(os_tok_ptr) 
19f4 cd 5c 17		call forth_apush 
19f7			 
19f7				STACKFRAMECHK ON $1efe $2f9f 
19f7				if DEBUG_STACK_IMB 
19f7					if ON 
19f7						exx 
19f7						ld hl, $2f9f 
19f7						pop de   ; $2f9f 
19f7						call cmp16 
19f7						jr nz, .spnosame 
19f7						ld hl, $1efe 
19f7						pop de   ; $1efe 
19f7						call cmp16 
19f7						jr z, .spfrsame 
19f7						.spnosame: call showsperror 
19f7						.spfrsame: nop 
19f7						exx 
19f7					endif 
19f7				endif 
19f7			endm 
# End of macro STACKFRAMECHK
19f7			 
19f7			execnext: 
19f7			 
19f7			if DEBUG_FORTH_PARSE_KEY 
19f7						DMARK "KY>" 
19f7			endif 
19f7			; move past token to next word 
19f7			 
19f7 2a 76 e6		ld hl, (os_tok_ptr) 
19fa 3e 00		ld a, 0 
19fc 01 ff 00		ld bc, 255     ; input buffer size 
19ff ed b1		cpir 
1a01			 
1a01			if DEBUG_FORTH_PARSE_KEY 
1a01						DMARK "KY!" 
1a01				CALLMONITOR 
1a01			endif	 
1a01			; TODO this might place hl on the null, so will need to forward on??? 
1a01			;inc hl   ; see if this gets onto the next item 
1a01			 
1a01			 
1a01			; TODO pass a pointer to the buffer to push 
1a01			; TODO call function to push 
1a01			 
1a01			; look for end of input 
1a01			 
1a01			;inc hl 
1a01			;ld a,(hl) 
1a01			;cp FORTH_END_BUFFER 
1a01			;ret z 
1a01			 
1a01			 
1a01 c3 7a 19		jp exec1 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			findnexttok: 
1a04			 
1a04				; hl is pointer to move 
1a04				; de is the token to locate 
1a04			 
1a04					if DEBUG_FORTH 
1a04						DMARK "NTK" 
1a04						CALLMONITOR 
1a04					endif 
1a04 d5				push de 
1a05			 
1a05			.fnt1:	 
1a05				; find first char of token to locate 
1a05			 
1a05 1a				ld a, (de) 
1a06 4f				ld c,a 
1a07 7e				ld a,(hl) 
1a08 cd 1b 0e			call toUpper 
1a0b					if DEBUG_FORTH 
1a0b						DMARK "NT1" 
1a0b						CALLMONITOR 
1a0b					endif 
1a0b b9				cp c 
1a0c			 
1a0c 28 03			jr z, .fnt2cmpmorefirst	 
1a0e			 
1a0e				; first char not found move to next char 
1a0e			 
1a0e 23				inc hl 
1a0f 18 f4			jr .fnt1 
1a11			 
1a11			.fnt2cmpmorefirst:	 
1a11				; first char of token found.  
1a11			 
1a11 e5				push hl     ; save start of token just in case it is the right one 
1a12 d9				exx 
1a13 e1				pop hl        ; save it to hl' 
1a14 d9				exx 
1a15			 
1a15			 
1a15			.fnt2cmpmore:	 
1a15				; compare the rest 
1a15				 
1a15 23				inc hl 
1a16 13				inc de 
1a17				 
1a17 1a				ld a, (de) 
1a18 4f				ld c,a 
1a19 7e				ld a,(hl) 
1a1a cd 1b 0e			call toUpper 
1a1d			 
1a1d					if DEBUG_FORTH 
1a1d						DMARK "NT2" 
1a1d						CALLMONITOR 
1a1d					endif 
1a1d				; c has the token to find char 
1a1d				; a has the mem to scan char 
1a1d			 
1a1d b9				cp c 
1a1e 28 04			jr z,.fntmatch1 
1a20			 
1a20				; they are not the same 
1a20			 
1a20					if DEBUG_FORTH 
1a20						DMARK "NT3" 
1a20						CALLMONITOR 
1a20					endif 
1a20 d1				pop de	; reset de token to look for 
1a21 d5				push de 
1a22 18 e1			jr .fnt1 
1a24				 
1a24			.fntmatch1: 
1a24			 
1a24				; is the same char a null which means we might have a full hit? 
1a24					if DEBUG_FORTH 
1a24						DMARK "NT4" 
1a24						CALLMONITOR 
1a24					endif 
1a24			 
1a24 fe 00			cp 0 
1a26 28 0b			jr z, .fntmatchyes 
1a28			 
1a28				; are we at the end of the token to find? 
1a28			 
1a28					if DEBUG_FORTH 
1a28						DMARK "NT5" 
1a28						CALLMONITOR 
1a28					endif 
1a28 3e 00			ld a, 0 
1a2a b9				cp c 
1a2b			 
1a2b c2 15 1a			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1a2e			 
1a2e					if DEBUG_FORTH 
1a2e						DMARK "NT6" 
1a2e						CALLMONITOR 
1a2e					endif 
1a2e				; token to find is exhusted but no match to stream 
1a2e			 
1a2e				; restore tok pointer and continue on 
1a2e d1				pop de 
1a2f d5				push de 
1a30 c3 05 1a			jp .fnt1 
1a33			 
1a33			 
1a33			.fntmatchyes: 
1a33			 
1a33				; hl now contains the end of the found token 
1a33			 
1a33				; get rid of saved token pointer to find 
1a33			 
1a33 d1				pop de 
1a34			 
1a34					if DEBUG_FORTH 
1a34						DMARK "NT9" 
1a34						CALLMONITOR 
1a34					endif 
1a34			 
1a34				; hl will be on the null term so forward on 
1a34			 
1a34				; get back the saved start of the token 
1a34			 
1a34 d9				exx 
1a35 e5				push hl     ; save start of token just in case it is the right one 
1a36 d9				exx 
1a37 e1				pop hl        ; save it to hl 
1a38			 
1a38 c9				ret 
1a39			 
1a39			 
1a39			; LIST needs to find a specific token   
1a39			; FORGET needs to find a spefici token 
1a39			 
1a39			; SAVE needs to find all tokens by flag 
1a39			; WORDS just needs to scan through all  by flag 
1a39			; UWORDS needs to scan through all by flag 
1a39			 
1a39			 
1a39			; given hl as pointer to start of dict look up string 
1a39			; return hl as pointer to start of word block 
1a39			; or 0 if not found 
1a39			 
1a39			forth_find_tok: 
1a39 c9				ret 
1a3a			 
1a3a			; given hl as pointer to dict structure 
1a3a			; move to the next dict block structure 
1a3a			 
1a3a			forth_tok_next: 
1a3a				; hl now points to the address of the next word pointer  
1a3a				; TODO skip compiled symbol for now 
1a3a			;	push de 
1a3a 23				inc hl 
1a3b 5e				ld e, (hl) 
1a3c 23				inc hl 
1a3d 56				ld d, (hl) 
1a3e 23				inc hl 
1a3f			 
1a3f eb				ex de,hl 
1a40			if DEBUG_FORTH_PARSE_NEXTWORD 
1a40				push bc 
1a40				ld bc, (cli_nextword) 
1a40						DMARK "NXW" 
1a40				CALLMONITOR 
1a40				pop bc 
1a40			endif 
1a40			;	pop de	 
1a40 c9				ret 
1a41			 
1a41			 
1a41			 
1a41			; eof 
# End of file forth_parserv5.asm
1a41				include "forth_wordsv4.asm" 
1a41			 
1a41			; the core word dictionary v4 
1a41			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1a41			 
1a41			; this is a linked list for each of the system words used 
1a41			; user defined words will follow the same format but will be in ram 
1a41			 
1a41			 
1a41			; 
1a41			; 
1a41			; define linked list: 
1a41			; 
1a41			; 1. compiled byte op code 
1a41			; 2. len of text word 
1a41			; 3. text word 
1a41			; 4. ptr to next dictionary word 
1a41			; 5. asm, calls etc for the word 
1a41			; 
1a41			;  if 1 == 0 then last word in dict  
1a41			;   
1a41			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1a41			;  
1a41			;  
1a41			; create basic standard set of words 
1a41			; 
1a41			;  
1a41			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1a41			; 2DUP 2DROP 2SWAP  
1a41			; @ C@ - get byte  
1a41			; ! C! - store byte 
1a41			; 0< true if less than zero 
1a41			; 0= true if zero 
1a41			; < >  
1a41			; = true if same 
1a41			; variables 
1a41			 
1a41			 
1a41			; Hardware specific words I may need 
1a41			; 
1a41			; IN OUT  
1a41			; calls to key util functions 
1a41			; calls to hardward abstraction stuff 
1a41			; easy control of frame buffers and lcd i/o 
1a41			; keyboard  
1a41			 
1a41			 
1a41			;DICT: macro 
1a41			; op_code, len, word, next 
1a41			;    word: 
1a41			;    db op_code 
1a41			;    ds word zero term 
1a41			;    dw next 
1a41			;    endm 
1a41			 
1a41			 
1a41			 
1a41			 
1a41			; op code 1 is a flag for user define words which are to be handled differently 
1a41			 
1a41			 
1a41			; 
1a41			; 
1a41			;    TODO on entry to a word this should be the expected environment 
1a41			;    hl - tos value if number then held, if string this is the ptr 
1a41			;    de -  
1a41			 
1a41			 
1a41			; opcode ranges 
1a41			; 0 - end of word dict 
1a41			; 255 - user define words 
1a41			 
1a41			sysdict: 
1a41			include "forth_opcodes.asm" 
1a41			; op codes for forth keywords 
1a41			; free to use code 0  
1a41				OPCODE_HEAP: equ  1 
1a41				OPCODE_EXEC: equ 2 
1a41				OPCODE_DUP: equ 3 
1a41				OPCODE_SWAP: equ 4 
1a41				OPCODE_COLN: equ 5 
1a41				OPCODE_SCOLN: equ 6 
1a41				OPCODE_DROP: equ 7 
1a41				OPCODE_DUP2: equ 8 
1a41				OPCODE_DROP2: equ 9 
1a41				OPCODE_SWAP2: equ 10 
1a41				OPCODE_AT: equ 11 
1a41				OPCODE_CAT: equ 12 
1a41				OPCODE_BANG: equ 13 
1a41				OPCODE_CBANG: equ 14 
1a41				OPCODE_SCALL: equ 15 
1a41				OPCODE_DEPTH: equ 16 
1a41				OPCODE_OVER: equ 17 
1a41				OPCODE_PAUSE: equ 18 
1a41				OPCODE_PAUSES: equ 19 
1a41				OPCODE_ROT: equ 20 
1a41			;free to reuse	OPCODE_WORDS: equ 21 
1a41			        OPCODE_NOT: equ 21 
1a41				OPCODE_UWORDS: equ 22 
1a41				OPCODE_BP: equ 23 
1a41				OPCODE_MONITOR: equ 24  
1a41				OPCODE_MALLOC: equ 25 
1a41				OPCODE_FREE: equ 26 
1a41				OPCODE_LIST: equ 27 
1a41				OPCODE_FORGET: equ 28 
1a41				OPCODE_NOP: equ 29 
1a41				OPCODE_COMO: equ 30 
1a41				OPCODE_COMC: equ 31 
1a41			;free to reuse	OPCODE_ENDCORE: equ 32 
1a41				OPCODE_AFTERSOUND: equ 33 
1a41				OPCODE_GP2: equ 34 
1a41				OPCODE_GP3: equ 35 
1a41				OPCODE_GP4: equ 36 
1a41				OPCODE_SIN: equ 37 
1a41				OPCODE_SOUT: equ 38 
1a41				OPCODE_SPIO: equ 39 
1a41				OPCODE_SPICEH: equ 40 
1a41				OPCODE_SPIOb: equ 41 
1a41				OPCODE_SPII: equ 42 
1a41				OPCODE_SESEL: equ 43 
1a41				OPCODE_CARTDEV: equ 44 
1a41			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1a41				OPCODE_FB: equ 46 
1a41				OPCODE_EMIT: equ 47 
1a41				OPCODE_DOTH: equ 48 
1a41				OPCODE_DOTF: equ 49 
1a41				OPCODE_DOT: equ 50 
1a41				OPCODE_CLS: equ 51 
1a41				OPCODE_DRAW: equ 52 
1a41				OPCODE_DUMP: equ 53 
1a41				OPCODE_CDUMP: equ 54 
1a41				OPCODE_DAT: equ 55 
1a41				OPCODE_HOME: equ 56 
1a41				OPCODE_SPACE: equ 57 
1a41				OPCODE_SPACES: equ 58 
1a41				OPCODE_SCROLL: equ 59 
1a41				OPCODE_ATQ: equ 60 
1a41				OPCODE_AUTODSP: equ 61 
1a41				OPCODE_MENU: equ 62 
1a41			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1a41				OPCODE_THEN: equ 64 
1a41				OPCODE_ELSE: equ 65 
1a41				OPCODE_DO: equ 66 
1a41				OPCODE_LOOP: equ 67 
1a41				OPCODE_I: equ 68 
1a41				OPCODE_DLOOP: equ 69  
1a41				OPCODE_REPEAT: equ 70  
1a41				OPCODE_UNTIL: equ 71 
1a41				OPCODE_ENDFLOW: equ 72 
1a41				OPCODE_WAITK: equ 73 
1a41				OPCODE_ACCEPT: equ 74 
1a41				OPCODE_EDIT: equ 75 
1a41			;free to reuse	OPCODE_ENDKEY: equ 76 
1a41				OPCODE_LZERO: equ 77 
1a41				OPCODE_TZERO: equ 78 
1a41				OPCODE_LESS: equ 79 
1a41				OPCODE_GT: equ 80 
1a41				OPCODE_EQUAL: equ 81  
1a41			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1a41				OPCODE_NEG: equ 83 
1a41				OPCODE_DIV: equ 84 
1a41				OPCODE_MUL: equ 85 
1a41				OPCODE_MIN: equ 86 
1a41				OPCODE_MAX: equ 87 
1a41				OPCODE_RND16: equ 88 
1a41				OPCODE_RND8: equ 89 
1a41				OPCODE_RND: equ 90 
1a41			;free to reuse	OPCODE_ENDMATHS: equ 91  
1a41				OPCODE_BYNAME: equ 92 
1a41				OPCODE_DIR: equ 93 
1a41				OPCODE_SAVE: equ 94 
1a41				OPCODE_LOAD: equ 95 
1a41				OPCODE_BSAVE: equ 96 
1a41				OPCODE_BLOAD: equ 97 
1a41				OPCODE_SEO: equ 98  
1a41				OPCODE_SEI: equ 99 
1a41				OPCODE_SFREE: equ 100 
1a41				OPCODE_SIZE: equ 101 
1a41				OPCODE_CREATE: equ 102 
1a41				OPCODE_APPEND: equ 103 
1a41				OPCODE_SDEL: equ 104 
1a41				OPCODE_OPEN: equ 105 
1a41				OPCODE_READ: equ 106 
1a41				OPCODE_EOF: equ 106 
1a41				OPCODE_FORMAT: equ 107 
1a41				OPCODE_LABEL: equ 108 
1a41				OPCODE_LABELS: equ 109 
1a41			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1a41				OPCODE_UPPER: equ 111 
1a41				OPCODE_LOWER: equ 112 
1a41				OPCODE_SUBSTR: equ 113 
1a41				OPCODE_LEFT: equ 114 
1a41				OPCODE_RIGHT: equ 115 
1a41				OPCODE_STR2NUM: equ 116 
1a41				OPCODE_NUM2STR: equ 117 
1a41				OPCODE_CONCAT: equ 118 
1a41				OPCODE_FIND: equ 119 
1a41				OPCODE_LEN: equ 120 
1a41				OPCODE_CHAR: equ 121 
1a41			; free to reuse	OPCODE_STRLEN: equ 122 
1a41			; free to reuse	OPCODE_ENDSTR: equ 123 
1a41				OPCODE_V0S: equ 124 
1a41				OPCODE_V0Q: equ 125 
1a41				OPCODE_V1S: equ 126 
1a41				OPCODE_V1Q: equ 127 
1a41				OPCODE_V2S: equ 128 
1a41				OPCODE_V2Q: equ 129 
1a41				OPCODE_V3S: equ 130 
1a41				OPCODE_V3Q: equ 131 
1a41			;free to reuse	OPCODE_END: equ 132 
1a41				OPCODE_ZDUP: equ 133 
1a41			 
1a41			; eof 
# End of file forth_opcodes.asm
1a41			 
1a41			include "forth_words_core.asm" 
1a41			 
1a41			; | ## Core Words 
1a41			 
1a41			;if MALLOC_4 
1a41			 
1a41			.HEAP: 
1a41				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1a41 15				db WORD_SYS_CORE+OPCODE_HEAP             
1a42 80 1a			dw .EXEC            
1a44 05				db 4 + 1 
1a45 .. 00			db "HEAP",0              
1a4a				endm 
# End of macro CWHEAD
1a4a			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1a4a			; | | u1 - Current number of bytes in the heap 
1a4a			; | | u2 - Remaining bytes left on the heap 
1a4a			; | |  
1a4a			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1a4a			 
1a4a			 
1a4a					if DEBUG_FORTH_WORDS_KEY 
1a4a						DMARK "HEP" 
1a4a f5				push af  
1a4b 3a 5f 1a			ld a, (.dmark)  
1a4e 32 7a ee			ld (debug_mark),a  
1a51 3a 60 1a			ld a, (.dmark+1)  
1a54 32 7b ee			ld (debug_mark+1),a  
1a57 3a 61 1a			ld a, (.dmark+2)  
1a5a 32 7c ee			ld (debug_mark+2),a  
1a5d 18 03			jr .pastdmark  
1a5f ..			.dmark: db "HEP"  
1a62 f1			.pastdmark: pop af  
1a63			endm  
# End of macro DMARK
1a63						CALLMONITOR 
1a63 cd 8a 11			call break_point_state  
1a66				endm  
# End of macro CALLMONITOR
1a66					endif 
1a66 2a cf 47				ld hl, (free_list )      
1a69 11 d4 47				ld de, heap_start 
1a6c			 
1a6c ed 52				sbc hl, de  
1a6e			 
1a6e cd 14 17				call forth_push_numhl 
1a71			 
1a71			 
1a71 ed 5b cf 47			ld de, (free_list )      
1a75 21 69 e3				ld hl, heap_end 
1a78			 
1a78 ed 52				sbc hl, de 
1a7a			 
1a7a cd 14 17				call forth_push_numhl 
1a7d					 
1a7d			 
1a7d					 
1a7d			 
1a7d			 
1a7d			 
1a7d					NEXTW 
1a7d c3 e9 18			jp macro_next 
1a80				endm 
# End of macro NEXTW
1a80			;endif 
1a80			 
1a80			.EXEC: 
1a80				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1a80 16				db WORD_SYS_CORE+OPCODE_EXEC             
1a81 c6 1a			dw .STKEXEC            
1a83 05				db 4 + 1 
1a84 .. 00			db "EXEC",0              
1a89				endm 
# End of macro CWHEAD
1a89			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1a89			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1a89			; | | 
1a89			; | |   
1a89				STACKFRAME OFF $5efe $5f9f 
1a89				if DEBUG_STACK_IMB 
1a89					if OFF 
1a89						exx 
1a89						ld de, $5efe 
1a89						ld a, d 
1a89						ld hl, curframe 
1a89						call hexout 
1a89						ld a, e 
1a89						ld hl, curframe+2 
1a89						call hexout 
1a89						ld hl, $5efe 
1a89						push hl 
1a89						ld hl, $5f9f 
1a89						push hl 
1a89						exx 
1a89					endif 
1a89				endif 
1a89			endm 
# End of macro STACKFRAME
1a89			 
1a89					if DEBUG_FORTH_WORDS_KEY 
1a89						DMARK "EXE" 
1a89 f5				push af  
1a8a 3a 9e 1a			ld a, (.dmark)  
1a8d 32 7a ee			ld (debug_mark),a  
1a90 3a 9f 1a			ld a, (.dmark+1)  
1a93 32 7b ee			ld (debug_mark+1),a  
1a96 3a a0 1a			ld a, (.dmark+2)  
1a99 32 7c ee			ld (debug_mark+2),a  
1a9c 18 03			jr .pastdmark  
1a9e ..			.dmark: db "EXE"  
1aa1 f1			.pastdmark: pop af  
1aa2			endm  
# End of macro DMARK
1aa2						CALLMONITOR 
1aa2 cd 8a 11			call break_point_state  
1aa5				endm  
# End of macro CALLMONITOR
1aa5					endif 
1aa5			 
1aa5				FORTH_DSP_VALUEHL 
1aa5 cd af 17			call macro_dsp_valuehl 
1aa8				endm 
# End of macro FORTH_DSP_VALUEHL
1aa8			 
1aa8				FORTH_DSP_POP 
1aa8 cd 2f 18			call macro_forth_dsp_pop 
1aab				endm 
# End of macro FORTH_DSP_POP
1aab			 
1aab					if DEBUG_FORTH_WORDS 
1aab						DMARK "EX1" 
1aab						CALLMONITOR 
1aab					endif 
1aab			;	ld e,(hl) 
1aab			;	inc hl 
1aab			;	ld d,(hl) 
1aab			;	ex de,hl 
1aab			 
1aab					if DEBUG_FORTH_WORDS 
1aab						DMARK "EX2" 
1aab						CALLMONITOR 
1aab					endif 
1aab e5				push hl 
1aac			 
1aac				;ld a, 0 
1aac				;ld a, FORTH_END_BUFFER 
1aac cd 24 0e			call strlenz 
1aaf 23				inc hl   ; include zero term to copy 
1ab0 06 00			ld b,0 
1ab2 4d				ld c,l 
1ab3 e1				pop hl 
1ab4 11 74 e4			ld de, execscratch 
1ab7					if DEBUG_FORTH_WORDS 
1ab7						DMARK "EX3" 
1ab7						CALLMONITOR 
1ab7					endif 
1ab7 ed b0			ldir 
1ab9			 
1ab9			 
1ab9 21 74 e4			ld hl, execscratch 
1abc			 
1abc					if DEBUG_FORTH_WORDS 
1abc						DMARK "EXe" 
1abc						CALLMONITOR 
1abc					endif 
1abc			 
1abc cd 37 19			call forthparse 
1abf cd 77 19			call forthexec 
1ac2			;	call forthexec_cleanup 
1ac2			;	call forthparse 
1ac2			;	call forthexec 
1ac2			 
1ac2				STACKFRAMECHK OFF $5efe $5f9f 
1ac2				if DEBUG_STACK_IMB 
1ac2					if OFF 
1ac2						exx 
1ac2						ld hl, $5f9f 
1ac2						pop de   ; $5f9f 
1ac2						call cmp16 
1ac2						jr nz, .spnosame 
1ac2						ld hl, $5efe 
1ac2						pop de   ; $5efe 
1ac2						call cmp16 
1ac2						jr z, .spfrsame 
1ac2						.spnosame: call showsperror 
1ac2						.spfrsame: nop 
1ac2						exx 
1ac2					endif 
1ac2				endif 
1ac2			endm 
# End of macro STACKFRAMECHK
1ac2			 
1ac2				; an immediate word so no need to process any more words 
1ac2 c9				ret 
1ac3				NEXTW 
1ac3 c3 e9 18			jp macro_next 
1ac6				endm 
# End of macro NEXTW
1ac6			 
1ac6			; dead code - old version  
1ac6			;	FORTH_RSP_NEXT 
1ac6			 
1ac6			;  
1ac6			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ac6			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ac6			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ac6			;	push hl 
1ac6			;	push de 
1ac6			;	push bc 
1ac6			; 
1ac6			; 
1ac6			;		if DEBUG_FORTH_WORDS_KEY 
1ac6			;			DMARK "EXR" 
1ac6			;			CALLMONITOR 
1ac6			;		endif 
1ac6			; 
1ac6			; 
1ac6			; 
1ac6			;	;v5 FORTH_DSP_VALUE 
1ac6			;	FORTH_DSP_VALUEHL 
1ac6			; 
1ac6			;	; TODO do string type checks 
1ac6			; 
1ac6			;;v5	inc hl   ; skip type 
1ac6			; 
1ac6			;	push hl  ; source code  
1ac6			;		if DEBUG_FORTH_WORDS 
1ac6			;			DMARK "EX1" 
1ac6			;			CALLMONITOR 
1ac6			;		endif 
1ac6			;	ld a, 0 
1ac6			;	call strlent 
1ac6			; 
1ac6			;	inc hl 
1ac6			;	inc hl 
1ac6			;	inc hl 
1ac6			;	inc hl 
1ac6			; 
1ac6			;	push hl    ; size 
1ac6			; 
1ac6			;		if DEBUG_FORTH_WORDS 
1ac6			;			DMARK "EX2" 
1ac6			;			CALLMONITOR 
1ac6			;		endif 
1ac6			;	call malloc 
1ac6			; 
1ac6			;	ex de, hl    ; de now contains malloc area 
1ac6			;	pop bc   	; get byte count 
1ac6			;	pop hl      ; get string to copy 
1ac6			; 
1ac6			;	push de     ; save malloc for free later 
1ac6			; 
1ac6			;		if DEBUG_FORTH_WORDS 
1ac6			;			DMARK "EX3" 
1ac6			;			CALLMONITOR 
1ac6			;		endif 
1ac6			;	ldir       ; duplicate string 
1ac6			; 
1ac6			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1ac6			;	 
1ac6			;	; TODO fix the parse would be better than this...  
1ac6			;	ex de, hl 
1ac6			;	dec hl 
1ac6			;	ld a, 0 
1ac6			;	ld (hl), a 
1ac6			;	dec hl 
1ac6			;	ld a, ' ' 
1ac6			;	ld (hl), a 
1ac6			;	dec hl 
1ac6			;	ld (hl), a 
1ac6			; 
1ac6			;	dec hl 
1ac6			;	ld (hl), a 
1ac6			; 
1ac6			; 
1ac6			;	FORTH_DSP_POP  
1ac6			; 
1ac6			;	pop hl     
1ac6			;	push hl    ; save malloc area 
1ac6			; 
1ac6			;		if DEBUG_FORTH_WORDS 
1ac6			;			DMARK "EX4" 
1ac6			;			CALLMONITOR 
1ac6			;		endif 
1ac6			; 
1ac6			;	call forthparse 
1ac6			;	call forthexec 
1ac6			;	 
1ac6			;	pop hl 
1ac6			;	if DEBUG_FORTH_WORDS 
1ac6			;		DMARK "EX5" 
1ac6			;		CALLMONITOR 
1ac6			;	endif 
1ac6			; 
1ac6			;	if FORTH_ENABLE_FREE 
1ac6			;	call free 
1ac6			;	endif 
1ac6			; 
1ac6			;	if DEBUG_FORTH_WORDS 
1ac6			;		DMARK "EX6" 
1ac6			;		CALLMONITOR 
1ac6			;	endif 
1ac6			; 
1ac6			;	pop bc 
1ac6			;	pop de 
1ac6			;	pop hl 
1ac6			;;	FORTH_RSP_POP	  
1ac6			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1ac6			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1ac6			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1ac6			; 
1ac6			;	if DEBUG_FORTH_WORDS 
1ac6			;		DMARK "EX7" 
1ac6			;		CALLMONITOR 
1ac6			;	endif 
1ac6			;	NEXTW 
1ac6			 
1ac6			.STKEXEC: 
1ac6				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1ac6 3f				db WORD_SYS_CORE+43             
1ac7 61 1b			dw .ZDUP            
1ac9 08				db 7 + 1 
1aca .. 00			db "STKEXEC",0              
1ad2				endm 
# End of macro CWHEAD
1ad2			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1ad2			 
1ad2			 
1ad2					if DEBUG_FORTH_WORDS_KEY 
1ad2						DMARK "STX" 
1ad2 f5				push af  
1ad3 3a e7 1a			ld a, (.dmark)  
1ad6 32 7a ee			ld (debug_mark),a  
1ad9 3a e8 1a			ld a, (.dmark+1)  
1adc 32 7b ee			ld (debug_mark+1),a  
1adf 3a e9 1a			ld a, (.dmark+2)  
1ae2 32 7c ee			ld (debug_mark+2),a  
1ae5 18 03			jr .pastdmark  
1ae7 ..			.dmark: db "STX"  
1aea f1			.pastdmark: pop af  
1aeb			endm  
# End of macro DMARK
1aeb						CALLMONITOR 
1aeb cd 8a 11			call break_point_state  
1aee				endm  
# End of macro CALLMONITOR
1aee					endif 
1aee			 
1aee				FORTH_DSP_VALUEHL 
1aee cd af 17			call macro_dsp_valuehl 
1af1				endm 
# End of macro FORTH_DSP_VALUEHL
1af1			 
1af1 22 63 eb			ld (store_tmp1), hl    ; count 
1af4			 
1af4				FORTH_DSP_POP 
1af4 cd 2f 18			call macro_forth_dsp_pop 
1af7				endm 
# End of macro FORTH_DSP_POP
1af7			.stkexec1: 
1af7 2a 63 eb			ld hl, (store_tmp1)   ; count 
1afa 3e 00			ld a, 0 
1afc bd				cp l 
1afd c8				ret z 
1afe			 
1afe 2b				dec hl 
1aff 22 63 eb			ld (store_tmp1), hl    ; count 
1b02				 
1b02				FORTH_DSP_VALUEHL 
1b02 cd af 17			call macro_dsp_valuehl 
1b05				endm 
# End of macro FORTH_DSP_VALUEHL
1b05 e5				push hl 
1b06				 
1b06				FORTH_DSP_POP 
1b06 cd 2f 18			call macro_forth_dsp_pop 
1b09				endm 
# End of macro FORTH_DSP_POP
1b09			 
1b09 cd 24 0e			call strlenz 
1b0c 23				inc hl   ; include zero term to copy 
1b0d 06 00			ld b,0 
1b0f 4d				ld c,l 
1b10 e1				pop hl 
1b11 11 74 e4			ld de, execscratch 
1b14					if DEBUG_FORTH_WORDS 
1b14						DMARK "EX3" 
1b14						CALLMONITOR 
1b14					endif 
1b14 ed b0			ldir 
1b16			 
1b16			 
1b16 21 74 e4			ld hl, execscratch 
1b19			 
1b19					if DEBUG_FORTH_WORDS 
1b19						DMARK "EXe" 
1b19						CALLMONITOR 
1b19					endif 
1b19			 
1b19 cd 37 19			call forthparse 
1b1c cd 77 19			call forthexec 
1b1f			 
1b1f c3 f7 1a			jp .stkexec1 
1b22			 
1b22 c9				ret 
1b23			 
1b23			 
1b23			.DUP: 
1b23				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1b23 17				db WORD_SYS_CORE+OPCODE_DUP             
1b24 61 1b			dw .ZDUP            
1b26 04				db 3 + 1 
1b27 .. 00			db "DUP",0              
1b2b				endm 
# End of macro CWHEAD
1b2b			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1b2b			 
1b2b					if DEBUG_FORTH_WORDS_KEY 
1b2b						DMARK "DUP" 
1b2b f5				push af  
1b2c 3a 40 1b			ld a, (.dmark)  
1b2f 32 7a ee			ld (debug_mark),a  
1b32 3a 41 1b			ld a, (.dmark+1)  
1b35 32 7b ee			ld (debug_mark+1),a  
1b38 3a 42 1b			ld a, (.dmark+2)  
1b3b 32 7c ee			ld (debug_mark+2),a  
1b3e 18 03			jr .pastdmark  
1b40 ..			.dmark: db "DUP"  
1b43 f1			.pastdmark: pop af  
1b44			endm  
# End of macro DMARK
1b44						CALLMONITOR 
1b44 cd 8a 11			call break_point_state  
1b47				endm  
# End of macro CALLMONITOR
1b47					endif 
1b47			 
1b47					FORTH_DSP 
1b47 cd 94 17			call macro_forth_dsp 
1b4a				endm 
# End of macro FORTH_DSP
1b4a			 
1b4a 7e					ld a, (HL) 
1b4b fe 01				cp DS_TYPE_STR 
1b4d 20 09				jr nz, .dupinum 
1b4f			 
1b4f					; push another string 
1b4f			 
1b4f					FORTH_DSP_VALUEHL     		 
1b4f cd af 17			call macro_dsp_valuehl 
1b52				endm 
# End of macro FORTH_DSP_VALUEHL
1b52			 
1b52				if DEBUG_FORTH_WORDS 
1b52					DMARK "DUs" 
1b52					CALLMONITOR 
1b52				endif 
1b52 cd 26 17				call forth_push_str 
1b55			 
1b55					NEXTW 
1b55 c3 e9 18			jp macro_next 
1b58				endm 
# End of macro NEXTW
1b58			 
1b58			 
1b58			.dupinum: 
1b58					 
1b58			 
1b58			 
1b58					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1b58 cd af 17			call macro_dsp_valuehl 
1b5b				endm 
# End of macro FORTH_DSP_VALUEHL
1b5b			 
1b5b				; TODO add floating point number detection 
1b5b			 
1b5b				if DEBUG_FORTH_WORDS 
1b5b					DMARK "DUi" 
1b5b					CALLMONITOR 
1b5b				endif 
1b5b			 
1b5b cd 14 17				call forth_push_numhl 
1b5e					NEXTW 
1b5e c3 e9 18			jp macro_next 
1b61				endm 
# End of macro NEXTW
1b61			.ZDUP: 
1b61				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1b61 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1b62 99 1b			dw .SWAP            
1b64 05				db 4 + 1 
1b65 .. 00			db "?DUP",0              
1b6a				endm 
# End of macro CWHEAD
1b6a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1b6a			 
1b6a					if DEBUG_FORTH_WORDS_KEY 
1b6a						DMARK "qDU" 
1b6a f5				push af  
1b6b 3a 7f 1b			ld a, (.dmark)  
1b6e 32 7a ee			ld (debug_mark),a  
1b71 3a 80 1b			ld a, (.dmark+1)  
1b74 32 7b ee			ld (debug_mark+1),a  
1b77 3a 81 1b			ld a, (.dmark+2)  
1b7a 32 7c ee			ld (debug_mark+2),a  
1b7d 18 03			jr .pastdmark  
1b7f ..			.dmark: db "qDU"  
1b82 f1			.pastdmark: pop af  
1b83			endm  
# End of macro DMARK
1b83						CALLMONITOR 
1b83 cd 8a 11			call break_point_state  
1b86				endm  
# End of macro CALLMONITOR
1b86					endif 
1b86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1b86 cd af 17			call macro_dsp_valuehl 
1b89				endm 
# End of macro FORTH_DSP_VALUEHL
1b89			 
1b89 e5					push hl 
1b8a			 
1b8a					; is it a zero? 
1b8a			 
1b8a 3e 00				ld a, 0 
1b8c 84					add h 
1b8d 85					add l 
1b8e			 
1b8e e1					pop hl 
1b8f			 
1b8f fe 00				cp 0 
1b91 28 03				jr z, .dup2orig 
1b93			 
1b93			 
1b93 cd 14 17				call forth_push_numhl 
1b96			 
1b96			 
1b96				; TODO add floating point number detection 
1b96			 
1b96			.dup2orig: 
1b96			 
1b96					NEXTW 
1b96 c3 e9 18			jp macro_next 
1b99				endm 
# End of macro NEXTW
1b99			.SWAP: 
1b99				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1b99 18				db WORD_SYS_CORE+OPCODE_SWAP             
1b9a d8 1b			dw .COLN            
1b9c 05				db 4 + 1 
1b9d .. 00			db "SWAP",0              
1ba2				endm 
# End of macro CWHEAD
1ba2			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1ba2					if DEBUG_FORTH_WORDS_KEY 
1ba2						DMARK "SWP" 
1ba2 f5				push af  
1ba3 3a b7 1b			ld a, (.dmark)  
1ba6 32 7a ee			ld (debug_mark),a  
1ba9 3a b8 1b			ld a, (.dmark+1)  
1bac 32 7b ee			ld (debug_mark+1),a  
1baf 3a b9 1b			ld a, (.dmark+2)  
1bb2 32 7c ee			ld (debug_mark+2),a  
1bb5 18 03			jr .pastdmark  
1bb7 ..			.dmark: db "SWP"  
1bba f1			.pastdmark: pop af  
1bbb			endm  
# End of macro DMARK
1bbb						CALLMONITOR 
1bbb cd 8a 11			call break_point_state  
1bbe				endm  
# End of macro CALLMONITOR
1bbe					endif 
1bbe			 
1bbe					FORTH_DSP_VALUEHL 
1bbe cd af 17			call macro_dsp_valuehl 
1bc1				endm 
# End of macro FORTH_DSP_VALUEHL
1bc1 e5					push hl     ; w2 
1bc2			 
1bc2					FORTH_DSP_POP 
1bc2 cd 2f 18			call macro_forth_dsp_pop 
1bc5				endm 
# End of macro FORTH_DSP_POP
1bc5			 
1bc5					FORTH_DSP_VALUEHL 
1bc5 cd af 17			call macro_dsp_valuehl 
1bc8				endm 
# End of macro FORTH_DSP_VALUEHL
1bc8			 
1bc8					FORTH_DSP_POP 
1bc8 cd 2f 18			call macro_forth_dsp_pop 
1bcb				endm 
# End of macro FORTH_DSP_POP
1bcb			 
1bcb d1					pop de     ; w2	, hl = w1 
1bcc			 
1bcc eb					ex de, hl 
1bcd d5					push de 
1bce			 
1bce cd 14 17				call forth_push_numhl 
1bd1			 
1bd1 e1					pop hl 
1bd2			 
1bd2 cd 14 17				call forth_push_numhl 
1bd5					 
1bd5			 
1bd5					NEXTW 
1bd5 c3 e9 18			jp macro_next 
1bd8				endm 
# End of macro NEXTW
1bd8			.COLN: 
1bd8				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1bd8 19				db WORD_SYS_CORE+OPCODE_COLN             
1bd9 9a 1c			dw .SCOLN            
1bdb 02				db 1 + 1 
1bdc .. 00			db ":",0              
1bde				endm 
# End of macro CWHEAD
1bde			; | : ( -- )         Create new word | DONE 
1bde			 
1bde					if DEBUG_FORTH_WORDS_KEY 
1bde						DMARK "CLN" 
1bde f5				push af  
1bdf 3a f3 1b			ld a, (.dmark)  
1be2 32 7a ee			ld (debug_mark),a  
1be5 3a f4 1b			ld a, (.dmark+1)  
1be8 32 7b ee			ld (debug_mark+1),a  
1beb 3a f5 1b			ld a, (.dmark+2)  
1bee 32 7c ee			ld (debug_mark+2),a  
1bf1 18 03			jr .pastdmark  
1bf3 ..			.dmark: db "CLN"  
1bf6 f1			.pastdmark: pop af  
1bf7			endm  
# End of macro DMARK
1bf7						CALLMONITOR 
1bf7 cd 8a 11			call break_point_state  
1bfa				endm  
# End of macro CALLMONITOR
1bfa					endif 
1bfa				STACKFRAME OFF $8efe $989f 
1bfa				if DEBUG_STACK_IMB 
1bfa					if OFF 
1bfa						exx 
1bfa						ld de, $8efe 
1bfa						ld a, d 
1bfa						ld hl, curframe 
1bfa						call hexout 
1bfa						ld a, e 
1bfa						ld hl, curframe+2 
1bfa						call hexout 
1bfa						ld hl, $8efe 
1bfa						push hl 
1bfa						ld hl, $989f 
1bfa						push hl 
1bfa						exx 
1bfa					endif 
1bfa				endif 
1bfa			endm 
# End of macro STACKFRAME
1bfa				; get parser buffer length  of new word 
1bfa			 
1bfa				 
1bfa			 
1bfa					; move tok past this to start of name defintition 
1bfa					; TODO get word to define 
1bfa					; TODO Move past word token 
1bfa					; TODO get length of string up to the ';' 
1bfa			 
1bfa 2a 76 e6			ld hl, (os_tok_ptr) 
1bfd 23				inc hl 
1bfe 23				inc hl 
1bff			 
1bff 3e 3b			ld a, ';' 
1c01 cd 2f 0e			call strlent 
1c04			 
1c04 7d				ld a,l 
1c05 32 75 e5			ld (os_new_parse_len), a 
1c08			 
1c08			 
1c08			if DEBUG_FORTH_UWORD 
1c08				ld de, (os_tok_ptr) 
1c08						DMARK ":01" 
1c08				CALLMONITOR 
1c08			endif 
1c08			 
1c08			; 
1c08			;  new word memory layout: 
1c08			;  
1c08			;    : adg 6666 ;  
1c08			; 
1c08			;    db   1     ; user defined word  
1c08 23				inc hl    
1c09			;    dw   sysdict 
1c09 23				inc hl 
1c0a 23				inc hl 
1c0b			;    db <word len>+1 (for null) 
1c0b 23				inc hl 
1c0c			;    db .... <word> 
1c0c			; 
1c0c			 
1c0c 23				inc hl    ; some extras for the word preamble before the above 
1c0d 23				inc hl 
1c0e 23				inc hl 
1c0f 23				inc hl 
1c10 23				inc hl 
1c11 23				inc hl 
1c12 23				inc hl  
1c13 23				inc hl 
1c14 23				inc hl 
1c15 23				inc hl 
1c16 23				inc hl 
1c17 23				inc hl 
1c18 23				inc hl 
1c19 23				inc hl     ; TODO how many do we really need?     maybe only 6 
1c1a			;       exec word buffer 
1c1a			;	<ptr word>   
1c1a 23				inc hl 
1c1b 23				inc hl 
1c1c			;       <word list><null term> 7F final term 
1c1c			 
1c1c			 
1c1c			if DEBUG_FORTH_UWORD 
1c1c						DMARK ":02" 
1c1c				CALLMONITOR 
1c1c			endif 
1c1c			 
1c1c				 
1c1c					; malloc the size 
1c1c			 
1c1c cd 8d 0e				call malloc 
1c1f 22 73 e5				ld (os_new_malloc), hl     ; save malloc start 
1c22			 
1c22			;    db   1     ; user defined word  
1c22 3e 01				ld a, WORD_SYS_UWORD  
1c24 77					ld (hl), a 
1c25				 
1c25 23				inc hl    
1c26			;    dw   sysdict 
1c26 11 41 1a			ld de, sysdict       ; continue on with the scan to the system dict 
1c29 73				ld (hl), e 
1c2a 23				inc hl 
1c2b 72				ld (hl), d 
1c2c 23				inc hl 
1c2d			 
1c2d			 
1c2d			;    Setup dict word 
1c2d			 
1c2d 23				inc hl 
1c2e 22 79 e5			ld (os_new_work_ptr), hl     ; save start of dict word  
1c31			 
1c31				; 1. get length of dict word 
1c31			 
1c31			 
1c31 2a 76 e6			ld hl, (os_tok_ptr) 
1c34 23				inc hl 
1c35 23				inc hl    ; position to start of dict word 
1c36 3e 00			ld a, 0 
1c38 cd 2f 0e			call strlent 
1c3b			 
1c3b			 
1c3b 23				inc hl    ; to include null??? 
1c3c			 
1c3c				; write length of dict word 
1c3c			 
1c3c ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1c40 1b				dec de 
1c41 eb				ex de, hl 
1c42 73				ld (hl), e 
1c43 eb				ex de, hl 
1c44			 
1c44				 
1c44			 
1c44				; copy  
1c44 4d				ld c, l 
1c45 06 00			ld b, 0 
1c47 ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1c4b 2a 76 e6			ld hl, (os_tok_ptr) 
1c4e 23				inc hl 
1c4f 23				inc hl    ; position to start of dict word 
1c50				 
1c50			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
1c50				 
1c50				; TODO need to convert word to upper case 
1c50			 
1c50			ucasetok:	 
1c50 7e				ld a,(hl) 
1c51 cd 1b 0e			call toUpper 
1c54 77				ld (hl),a 
1c55 ed a0			ldi 
1c57 f2 50 1c		 	jp p, ucasetok 
1c5a			 
1c5a			 
1c5a			 
1c5a				; de now points to start of where the word body code should be placed 
1c5a ed 53 79 e5		ld (os_new_work_ptr), de 
1c5e				; hl now points to the words to throw at forthexec which needs to be copied 
1c5e 22 7b e5			ld (os_new_src_ptr), hl 
1c61			 
1c61				; TODO add 'call to forthexec' 
1c61			 
1c61			if DEBUG_FORTH_UWORD 
1c61				push bc 
1c61				ld bc, (os_new_malloc) 
1c61						DMARK ":0x" 
1c61				CALLMONITOR 
1c61				pop bc 
1c61			endif 
1c61			 
1c61			 
1c61				; create word preamble which should be: 
1c61			 
1c61			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
1c61			 
1c61				;    ld hl, <word code> 
1c61				;    jp user_exec 
1c61			        ;    <word code bytes> 
1c61			 
1c61			 
1c61			;	inc de     ; TODO ??? or are we already past the word's null 
1c61 eb				ex de, hl 
1c62			 
1c62 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
1c64			 
1c64 23				inc hl 
1c65 22 7f e5			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
1c68 23				inc hl 
1c69			 
1c69 23				inc hl 
1c6a 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
1c6c			 
1c6c 01 d7 33			ld bc, user_exec 
1c6f 23				inc hl 
1c70 71				ld (hl), c     ; poke address of user_exec 
1c71 23				inc hl 
1c72 70				ld (hl), b     
1c73			 ; 
1c73			;	inc hl 
1c73			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1c73			; 
1c73			; 
1c73			;	ld bc, macro_forth_rsp_next 
1c73			;	inc hl 
1c73			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
1c73			;	inc hl 
1c73			;	ld (hl), b     
1c73			 ; 
1c73			;	inc hl 
1c73			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1c73			; 
1c73			; 
1c73			;	inc hl 
1c73			;	ld bc, forthexec 
1c73			;	ld (hl), c     ; poke address of forthexec 
1c73			;	inc hl 
1c73			;	ld (hl), b      
1c73			; 
1c73			;	inc hl 
1c73			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
1c73			; 
1c73			;	ld bc, user_dict_next 
1c73			;	inc hl 
1c73			;	ld (hl), c     ; poke address of forthexec 
1c73			;	inc hl 
1c73			;	ld (hl), b      
1c73			 
1c73				; hl is now where we need to copy the word byte data to save this 
1c73			 
1c73 23				inc hl 
1c74 22 7d e5			ld (os_new_exec), hl 
1c77				 
1c77				; copy definition 
1c77			 
1c77 eb				ex de, hl 
1c78			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
1c78			;	inc de    ; skip the PC for this parse 
1c78 3a 75 e5			ld a, (os_new_parse_len) 
1c7b 4f				ld c, a 
1c7c 06 00			ld b, 0 
1c7e ed b0			ldir		 ; copy defintion 
1c80			 
1c80			 
1c80				; poke the address of where the new word bytes live for forthexec 
1c80			 
1c80 2a 7f e5			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
1c83			 
1c83 ed 5b 7d e5		ld de, (os_new_exec)      
1c87				 
1c87 73				ld (hl), e 
1c88 23				inc hl 
1c89 72				ld (hl), d 
1c8a			 
1c8a					; TODO copy last user dict word next link to this word 
1c8a					; TODO update last user dict word to point to this word 
1c8a			; 
1c8a			; hl f923 de 812a ; bc 811a 
1c8a			 
1c8a			if DEBUG_FORTH_UWORD 
1c8a				push bc 
1c8a				ld bc, (os_new_malloc) 
1c8a						DMARK ":0A" 
1c8a				CALLMONITOR 
1c8a				pop bc 
1c8a			endif 
1c8a			if DEBUG_FORTH_UWORD 
1c8a				push bc 
1c8a				ld bc, (os_new_malloc) 
1c8a				inc bc 
1c8a				inc bc 
1c8a				inc bc 
1c8a				inc bc 
1c8a				inc bc 
1c8a				inc bc 
1c8a				inc bc 
1c8a				inc bc 
1c8a			 
1c8a						DMARK ":0B" 
1c8a				CALLMONITOR 
1c8a				pop bc 
1c8a			endif 
1c8a			 
1c8a			; update word dict linked list for new word 
1c8a			 
1c8a			 
1c8a 2a 72 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
1c8d 23			inc hl     ; move to next work linked list ptr 
1c8e			 
1c8e ed 5b 73 e5	ld de, (os_new_malloc)		 ; new next word 
1c92 73			ld (hl), e 
1c93 23			inc hl 
1c94 72			ld (hl), d 
1c95			 
1c95			if DEBUG_FORTH_UWORD 
1c95				ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
1c95			endif 
1c95			 
1c95 ed 53 72 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
1c99			 
1c99			 
1c99			if DEBUG_FORTH_UWORD 
1c99						DMARK ":0+" 
1c99				CALLMONITOR 
1c99			endif 
1c99			 
1c99				STACKFRAMECHK OFF $8efe $989f 
1c99				if DEBUG_STACK_IMB 
1c99					if OFF 
1c99						exx 
1c99						ld hl, $989f 
1c99						pop de   ; $989f 
1c99						call cmp16 
1c99						jr nz, .spnosame 
1c99						ld hl, $8efe 
1c99						pop de   ; $8efe 
1c99						call cmp16 
1c99						jr z, .spfrsame 
1c99						.spnosame: call showsperror 
1c99						.spfrsame: nop 
1c99						exx 
1c99					endif 
1c99				endif 
1c99			endm 
# End of macro STACKFRAMECHK
1c99			 
1c99 c9			ret    ; dont process any remaining parser tokens as they form new word 
1c9a			 
1c9a			 
1c9a			 
1c9a			 
1c9a			;		NEXT 
1c9a			.SCOLN: 
1c9a			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
1c9a 06				db OPCODE_SCOLN 
1c9b ca 1c			dw .DROP 
1c9d 02				db 2 
1c9e .. 00			db ";",0           
1ca0			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
1ca0					if DEBUG_FORTH_WORDS_KEY 
1ca0						DMARK "SCN" 
1ca0 f5				push af  
1ca1 3a b5 1c			ld a, (.dmark)  
1ca4 32 7a ee			ld (debug_mark),a  
1ca7 3a b6 1c			ld a, (.dmark+1)  
1caa 32 7b ee			ld (debug_mark+1),a  
1cad 3a b7 1c			ld a, (.dmark+2)  
1cb0 32 7c ee			ld (debug_mark+2),a  
1cb3 18 03			jr .pastdmark  
1cb5 ..			.dmark: db "SCN"  
1cb8 f1			.pastdmark: pop af  
1cb9			endm  
# End of macro DMARK
1cb9						CALLMONITOR 
1cb9 cd 8a 11			call break_point_state  
1cbc				endm  
# End of macro CALLMONITOR
1cbc					endif 
1cbc					FORTH_RSP_TOS 
1cbc cd d5 16			call macro_forth_rsp_tos 
1cbf				endm 
# End of macro FORTH_RSP_TOS
1cbf e5					push hl 
1cc0					FORTH_RSP_POP 
1cc0 cd dc 16			call macro_forth_rsp_pop 
1cc3				endm 
# End of macro FORTH_RSP_POP
1cc3 e1					pop hl 
1cc4			;		ex de,hl 
1cc4 22 76 e6				ld (os_tok_ptr),hl 
1cc7			 
1cc7			if DEBUG_FORTH_UWORD 
1cc7						DMARK "SCL" 
1cc7				CALLMONITOR 
1cc7			endif 
1cc7					NEXTW 
1cc7 c3 e9 18			jp macro_next 
1cca				endm 
# End of macro NEXTW
1cca			 
1cca			.DROP: 
1cca				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
1cca 1b				db WORD_SYS_CORE+OPCODE_DROP             
1ccb f5 1c			dw .DUP2            
1ccd 05				db 4 + 1 
1cce .. 00			db "DROP",0              
1cd3				endm 
# End of macro CWHEAD
1cd3			; | DROP ( w -- )   drop the TOS item   | DONE 
1cd3					if DEBUG_FORTH_WORDS_KEY 
1cd3						DMARK "DRP" 
1cd3 f5				push af  
1cd4 3a e8 1c			ld a, (.dmark)  
1cd7 32 7a ee			ld (debug_mark),a  
1cda 3a e9 1c			ld a, (.dmark+1)  
1cdd 32 7b ee			ld (debug_mark+1),a  
1ce0 3a ea 1c			ld a, (.dmark+2)  
1ce3 32 7c ee			ld (debug_mark+2),a  
1ce6 18 03			jr .pastdmark  
1ce8 ..			.dmark: db "DRP"  
1ceb f1			.pastdmark: pop af  
1cec			endm  
# End of macro DMARK
1cec						CALLMONITOR 
1cec cd 8a 11			call break_point_state  
1cef				endm  
# End of macro CALLMONITOR
1cef					endif 
1cef					FORTH_DSP_POP 
1cef cd 2f 18			call macro_forth_dsp_pop 
1cf2				endm 
# End of macro FORTH_DSP_POP
1cf2					NEXTW 
1cf2 c3 e9 18			jp macro_next 
1cf5				endm 
# End of macro NEXTW
1cf5			.DUP2: 
1cf5				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
1cf5 1c				db WORD_SYS_CORE+OPCODE_DUP2             
1cf6 3a 1d			dw .DROP2            
1cf8 05				db 4 + 1 
1cf9 .. 00			db "2DUP",0              
1cfe				endm 
# End of macro CWHEAD
1cfe			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
1cfe					if DEBUG_FORTH_WORDS_KEY 
1cfe						DMARK "2DU" 
1cfe f5				push af  
1cff 3a 13 1d			ld a, (.dmark)  
1d02 32 7a ee			ld (debug_mark),a  
1d05 3a 14 1d			ld a, (.dmark+1)  
1d08 32 7b ee			ld (debug_mark+1),a  
1d0b 3a 15 1d			ld a, (.dmark+2)  
1d0e 32 7c ee			ld (debug_mark+2),a  
1d11 18 03			jr .pastdmark  
1d13 ..			.dmark: db "2DU"  
1d16 f1			.pastdmark: pop af  
1d17			endm  
# End of macro DMARK
1d17						CALLMONITOR 
1d17 cd 8a 11			call break_point_state  
1d1a				endm  
# End of macro CALLMONITOR
1d1a					endif 
1d1a					FORTH_DSP_VALUEHL 
1d1a cd af 17			call macro_dsp_valuehl 
1d1d				endm 
# End of macro FORTH_DSP_VALUEHL
1d1d e5					push hl      ; 2 
1d1e			 
1d1e					FORTH_DSP_POP 
1d1e cd 2f 18			call macro_forth_dsp_pop 
1d21				endm 
# End of macro FORTH_DSP_POP
1d21					 
1d21					FORTH_DSP_VALUEHL 
1d21 cd af 17			call macro_dsp_valuehl 
1d24				endm 
# End of macro FORTH_DSP_VALUEHL
1d24			;		push hl      ; 1 
1d24			 
1d24					FORTH_DSP_POP 
1d24 cd 2f 18			call macro_forth_dsp_pop 
1d27				endm 
# End of macro FORTH_DSP_POP
1d27			 
1d27			;		pop hl       ; 1 
1d27 d1					pop de       ; 2 
1d28			 
1d28 cd 14 17				call forth_push_numhl 
1d2b eb					ex de, hl 
1d2c cd 14 17				call forth_push_numhl 
1d2f			 
1d2f					 
1d2f eb					ex de, hl 
1d30			 
1d30 cd 14 17				call forth_push_numhl 
1d33 eb					ex de, hl 
1d34 cd 14 17				call forth_push_numhl 
1d37			 
1d37			 
1d37					NEXTW 
1d37 c3 e9 18			jp macro_next 
1d3a				endm 
# End of macro NEXTW
1d3a			.DROP2: 
1d3a				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
1d3a 1d				db WORD_SYS_CORE+OPCODE_DROP2             
1d3b 69 1d			dw .SWAP2            
1d3d 06				db 5 + 1 
1d3e .. 00			db "2DROP",0              
1d44				endm 
# End of macro CWHEAD
1d44			; | 2DROP ( w w -- )    Double drop | DONE 
1d44					if DEBUG_FORTH_WORDS_KEY 
1d44						DMARK "2DR" 
1d44 f5				push af  
1d45 3a 59 1d			ld a, (.dmark)  
1d48 32 7a ee			ld (debug_mark),a  
1d4b 3a 5a 1d			ld a, (.dmark+1)  
1d4e 32 7b ee			ld (debug_mark+1),a  
1d51 3a 5b 1d			ld a, (.dmark+2)  
1d54 32 7c ee			ld (debug_mark+2),a  
1d57 18 03			jr .pastdmark  
1d59 ..			.dmark: db "2DR"  
1d5c f1			.pastdmark: pop af  
1d5d			endm  
# End of macro DMARK
1d5d						CALLMONITOR 
1d5d cd 8a 11			call break_point_state  
1d60				endm  
# End of macro CALLMONITOR
1d60					endif 
1d60					FORTH_DSP_POP 
1d60 cd 2f 18			call macro_forth_dsp_pop 
1d63				endm 
# End of macro FORTH_DSP_POP
1d63					FORTH_DSP_POP 
1d63 cd 2f 18			call macro_forth_dsp_pop 
1d66				endm 
# End of macro FORTH_DSP_POP
1d66					NEXTW 
1d66 c3 e9 18			jp macro_next 
1d69				endm 
# End of macro NEXTW
1d69			.SWAP2: 
1d69				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
1d69 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
1d6a 92 1d			dw .AT            
1d6c 06				db 5 + 1 
1d6d .. 00			db "2SWAP",0              
1d73				endm 
# End of macro CWHEAD
1d73			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
1d73					if DEBUG_FORTH_WORDS_KEY 
1d73						DMARK "2SW" 
1d73 f5				push af  
1d74 3a 88 1d			ld a, (.dmark)  
1d77 32 7a ee			ld (debug_mark),a  
1d7a 3a 89 1d			ld a, (.dmark+1)  
1d7d 32 7b ee			ld (debug_mark+1),a  
1d80 3a 8a 1d			ld a, (.dmark+2)  
1d83 32 7c ee			ld (debug_mark+2),a  
1d86 18 03			jr .pastdmark  
1d88 ..			.dmark: db "2SW"  
1d8b f1			.pastdmark: pop af  
1d8c			endm  
# End of macro DMARK
1d8c						CALLMONITOR 
1d8c cd 8a 11			call break_point_state  
1d8f				endm  
# End of macro CALLMONITOR
1d8f					endif 
1d8f					NEXTW 
1d8f c3 e9 18			jp macro_next 
1d92				endm 
# End of macro NEXTW
1d92			.AT: 
1d92				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
1d92 1f				db WORD_SYS_CORE+OPCODE_AT             
1d93 c4 1d			dw .CAT            
1d95 02				db 1 + 1 
1d96 .. 00			db "@",0              
1d98				endm 
# End of macro CWHEAD
1d98			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
1d98			 
1d98					if DEBUG_FORTH_WORDS_KEY 
1d98						DMARK "AT." 
1d98 f5				push af  
1d99 3a ad 1d			ld a, (.dmark)  
1d9c 32 7a ee			ld (debug_mark),a  
1d9f 3a ae 1d			ld a, (.dmark+1)  
1da2 32 7b ee			ld (debug_mark+1),a  
1da5 3a af 1d			ld a, (.dmark+2)  
1da8 32 7c ee			ld (debug_mark+2),a  
1dab 18 03			jr .pastdmark  
1dad ..			.dmark: db "AT."  
1db0 f1			.pastdmark: pop af  
1db1			endm  
# End of macro DMARK
1db1						CALLMONITOR 
1db1 cd 8a 11			call break_point_state  
1db4				endm  
# End of macro CALLMONITOR
1db4					endif 
1db4			.getbyteat:	 
1db4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1db4 cd af 17			call macro_dsp_valuehl 
1db7				endm 
# End of macro FORTH_DSP_VALUEHL
1db7					 
1db7			;		push hl 
1db7				 
1db7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1db7 cd 2f 18			call macro_forth_dsp_pop 
1dba				endm 
# End of macro FORTH_DSP_POP
1dba			 
1dba			;		pop hl 
1dba			 
1dba 7e					ld a, (hl) 
1dbb			 
1dbb 6f					ld l, a 
1dbc 26 00				ld h, 0 
1dbe cd 14 17				call forth_push_numhl 
1dc1			 
1dc1					NEXTW 
1dc1 c3 e9 18			jp macro_next 
1dc4				endm 
# End of macro NEXTW
1dc4			.CAT: 
1dc4				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
1dc4 20				db WORD_SYS_CORE+OPCODE_CAT             
1dc5 ed 1d			dw .BANG            
1dc7 03				db 2 + 1 
1dc8 .. 00			db "C@",0              
1dcb				endm 
# End of macro CWHEAD
1dcb			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
1dcb					if DEBUG_FORTH_WORDS_KEY 
1dcb						DMARK "CAA" 
1dcb f5				push af  
1dcc 3a e0 1d			ld a, (.dmark)  
1dcf 32 7a ee			ld (debug_mark),a  
1dd2 3a e1 1d			ld a, (.dmark+1)  
1dd5 32 7b ee			ld (debug_mark+1),a  
1dd8 3a e2 1d			ld a, (.dmark+2)  
1ddb 32 7c ee			ld (debug_mark+2),a  
1dde 18 03			jr .pastdmark  
1de0 ..			.dmark: db "CAA"  
1de3 f1			.pastdmark: pop af  
1de4			endm  
# End of macro DMARK
1de4						CALLMONITOR 
1de4 cd 8a 11			call break_point_state  
1de7				endm  
# End of macro CALLMONITOR
1de7					endif 
1de7 c3 b4 1d				jp .getbyteat 
1dea					NEXTW 
1dea c3 e9 18			jp macro_next 
1ded				endm 
# End of macro NEXTW
1ded			.BANG: 
1ded				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
1ded 21				db WORD_SYS_CORE+OPCODE_BANG             
1dee 23 1e			dw .CBANG            
1df0 02				db 1 + 1 
1df1 .. 00			db "!",0              
1df3				endm 
# End of macro CWHEAD
1df3			; | ! ( x w -- ) Store x at address w      | DONE 
1df3					if DEBUG_FORTH_WORDS_KEY 
1df3						DMARK "BNG" 
1df3 f5				push af  
1df4 3a 08 1e			ld a, (.dmark)  
1df7 32 7a ee			ld (debug_mark),a  
1dfa 3a 09 1e			ld a, (.dmark+1)  
1dfd 32 7b ee			ld (debug_mark+1),a  
1e00 3a 0a 1e			ld a, (.dmark+2)  
1e03 32 7c ee			ld (debug_mark+2),a  
1e06 18 03			jr .pastdmark  
1e08 ..			.dmark: db "BNG"  
1e0b f1			.pastdmark: pop af  
1e0c			endm  
# End of macro DMARK
1e0c						CALLMONITOR 
1e0c cd 8a 11			call break_point_state  
1e0f				endm  
# End of macro CALLMONITOR
1e0f					endif 
1e0f			 
1e0f			.storebyteat:		 
1e0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1e0f cd af 17			call macro_dsp_valuehl 
1e12				endm 
# End of macro FORTH_DSP_VALUEHL
1e12					 
1e12 e5					push hl 
1e13				 
1e13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1e13 cd 2f 18			call macro_forth_dsp_pop 
1e16				endm 
# End of macro FORTH_DSP_POP
1e16			 
1e16					; get byte to poke 
1e16			 
1e16					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1e16 cd af 17			call macro_dsp_valuehl 
1e19				endm 
# End of macro FORTH_DSP_VALUEHL
1e19 e5					push hl 
1e1a			 
1e1a			 
1e1a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1e1a cd 2f 18			call macro_forth_dsp_pop 
1e1d				endm 
# End of macro FORTH_DSP_POP
1e1d			 
1e1d			 
1e1d d1					pop de 
1e1e e1					pop hl 
1e1f			 
1e1f 73					ld (hl),e 
1e20			 
1e20			 
1e20					NEXTW 
1e20 c3 e9 18			jp macro_next 
1e23				endm 
# End of macro NEXTW
1e23			.CBANG: 
1e23				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
1e23 22				db WORD_SYS_CORE+OPCODE_CBANG             
1e24 4c 1e			dw .SCALL            
1e26 03				db 2 + 1 
1e27 .. 00			db "C!",0              
1e2a				endm 
# End of macro CWHEAD
1e2a			; | C!  ( x w -- ) Store x at address w  | DONE 
1e2a					if DEBUG_FORTH_WORDS_KEY 
1e2a						DMARK "CBA" 
1e2a f5				push af  
1e2b 3a 3f 1e			ld a, (.dmark)  
1e2e 32 7a ee			ld (debug_mark),a  
1e31 3a 40 1e			ld a, (.dmark+1)  
1e34 32 7b ee			ld (debug_mark+1),a  
1e37 3a 41 1e			ld a, (.dmark+2)  
1e3a 32 7c ee			ld (debug_mark+2),a  
1e3d 18 03			jr .pastdmark  
1e3f ..			.dmark: db "CBA"  
1e42 f1			.pastdmark: pop af  
1e43			endm  
# End of macro DMARK
1e43						CALLMONITOR 
1e43 cd 8a 11			call break_point_state  
1e46				endm  
# End of macro CALLMONITOR
1e46					endif 
1e46 c3 0f 1e				jp .storebyteat 
1e49					NEXTW 
1e49 c3 e9 18			jp macro_next 
1e4c				endm 
# End of macro NEXTW
1e4c			.SCALL: 
1e4c				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
1e4c 23				db WORD_SYS_CORE+OPCODE_SCALL             
1e4d 80 1e			dw .DEPTH            
1e4f 05				db 4 + 1 
1e50 .. 00			db "CALL",0              
1e55				endm 
# End of macro CWHEAD
1e55			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
1e55					if DEBUG_FORTH_WORDS_KEY 
1e55						DMARK "CLL" 
1e55 f5				push af  
1e56 3a 6a 1e			ld a, (.dmark)  
1e59 32 7a ee			ld (debug_mark),a  
1e5c 3a 6b 1e			ld a, (.dmark+1)  
1e5f 32 7b ee			ld (debug_mark+1),a  
1e62 3a 6c 1e			ld a, (.dmark+2)  
1e65 32 7c ee			ld (debug_mark+2),a  
1e68 18 03			jr .pastdmark  
1e6a ..			.dmark: db "CLL"  
1e6d f1			.pastdmark: pop af  
1e6e			endm  
# End of macro DMARK
1e6e						CALLMONITOR 
1e6e cd 8a 11			call break_point_state  
1e71				endm  
# End of macro CALLMONITOR
1e71					endif 
1e71			 
1e71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1e71 cd af 17			call macro_dsp_valuehl 
1e74				endm 
# End of macro FORTH_DSP_VALUEHL
1e74			 
1e74			;		push hl 
1e74			 
1e74					; destroy value TOS 
1e74			 
1e74					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1e74 cd 2f 18			call macro_forth_dsp_pop 
1e77				endm 
# End of macro FORTH_DSP_POP
1e77			 
1e77						 
1e77			;		pop hl 
1e77			 
1e77					; how to do a call with hl???? save SP? 
1e77 cd 92 18				call forth_call_hl 
1e7a			 
1e7a			 
1e7a					; TODO push value back onto stack for another op etc 
1e7a			 
1e7a cd 14 17				call forth_push_numhl 
1e7d					NEXTW 
1e7d c3 e9 18			jp macro_next 
1e80				endm 
# End of macro NEXTW
1e80			.DEPTH: 
1e80				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
1e80 24				db WORD_SYS_CORE+OPCODE_DEPTH             
1e81 bd 1e			dw .OVER            
1e83 06				db 5 + 1 
1e84 .. 00			db "DEPTH",0              
1e8a				endm 
# End of macro CWHEAD
1e8a			; | DEPTH ( -- u ) Push count of stack | DONE 
1e8a					; take current TOS and remove from base value div by two to get count 
1e8a					if DEBUG_FORTH_WORDS_KEY 
1e8a						DMARK "DEP" 
1e8a f5				push af  
1e8b 3a 9f 1e			ld a, (.dmark)  
1e8e 32 7a ee			ld (debug_mark),a  
1e91 3a a0 1e			ld a, (.dmark+1)  
1e94 32 7b ee			ld (debug_mark+1),a  
1e97 3a a1 1e			ld a, (.dmark+2)  
1e9a 32 7c ee			ld (debug_mark+2),a  
1e9d 18 03			jr .pastdmark  
1e9f ..			.dmark: db "DEP"  
1ea2 f1			.pastdmark: pop af  
1ea3			endm  
# End of macro DMARK
1ea3						CALLMONITOR 
1ea3 cd 8a 11			call break_point_state  
1ea6				endm  
# End of macro CALLMONITOR
1ea6					endif 
1ea6			 
1ea6			 
1ea6 2a 22 eb			ld hl, (cli_data_sp) 
1ea9 11 dc e8			ld de, cli_data_stack 
1eac ed 52			sbc hl,de 
1eae				 
1eae				; div by size of stack item 
1eae			 
1eae 5d				ld e,l 
1eaf 0e 03			ld c, 3 
1eb1 cd 56 09			call Div8 
1eb4			 
1eb4 6f				ld l,a 
1eb5 26 00			ld h,0 
1eb7			 
1eb7				;srl h 
1eb7				;rr l 
1eb7			 
1eb7 cd 14 17				call forth_push_numhl 
1eba					NEXTW 
1eba c3 e9 18			jp macro_next 
1ebd				endm 
# End of macro NEXTW
1ebd			.OVER: 
1ebd				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
1ebd 42				db WORD_SYS_CORE+46             
1ebe 04 1f			dw .PAUSE            
1ec0 05				db 4 + 1 
1ec1 .. 00			db "OVER",0              
1ec6				endm 
# End of macro CWHEAD
1ec6			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
1ec6					if DEBUG_FORTH_WORDS_KEY 
1ec6						DMARK "OVR" 
1ec6 f5				push af  
1ec7 3a db 1e			ld a, (.dmark)  
1eca 32 7a ee			ld (debug_mark),a  
1ecd 3a dc 1e			ld a, (.dmark+1)  
1ed0 32 7b ee			ld (debug_mark+1),a  
1ed3 3a dd 1e			ld a, (.dmark+2)  
1ed6 32 7c ee			ld (debug_mark+2),a  
1ed9 18 03			jr .pastdmark  
1edb ..			.dmark: db "OVR"  
1ede f1			.pastdmark: pop af  
1edf			endm  
# End of macro DMARK
1edf						CALLMONITOR 
1edf cd 8a 11			call break_point_state  
1ee2				endm  
# End of macro CALLMONITOR
1ee2					endif 
1ee2			 
1ee2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1ee2 cd af 17			call macro_dsp_valuehl 
1ee5				endm 
# End of macro FORTH_DSP_VALUEHL
1ee5 e5					push hl    ; n2 
1ee6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1ee6 cd 2f 18			call macro_forth_dsp_pop 
1ee9				endm 
# End of macro FORTH_DSP_POP
1ee9			 
1ee9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1ee9 cd af 17			call macro_dsp_valuehl 
1eec				endm 
# End of macro FORTH_DSP_VALUEHL
1eec e5					push hl    ; n1 
1eed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1eed cd 2f 18			call macro_forth_dsp_pop 
1ef0				endm 
# End of macro FORTH_DSP_POP
1ef0			 
1ef0 d1					pop de     ; n1 
1ef1 e1					pop hl     ; n2 
1ef2			 
1ef2 d5					push de 
1ef3 e5					push hl 
1ef4 d5					push de 
1ef5			 
1ef5					; push back  
1ef5			 
1ef5 e1					pop hl 
1ef6 cd 14 17				call forth_push_numhl 
1ef9 e1					pop hl 
1efa cd 14 17				call forth_push_numhl 
1efd e1					pop hl 
1efe cd 14 17				call forth_push_numhl 
1f01					NEXTW 
1f01 c3 e9 18			jp macro_next 
1f04				endm 
# End of macro NEXTW
1f04			 
1f04			.PAUSE: 
1f04				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
1f04 43				db WORD_SYS_CORE+47             
1f05 39 1f			dw .PAUSES            
1f07 08				db 7 + 1 
1f08 .. 00			db "PAUSEMS",0              
1f10				endm 
# End of macro CWHEAD
1f10			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
1f10					if DEBUG_FORTH_WORDS_KEY 
1f10						DMARK "PMS" 
1f10 f5				push af  
1f11 3a 25 1f			ld a, (.dmark)  
1f14 32 7a ee			ld (debug_mark),a  
1f17 3a 26 1f			ld a, (.dmark+1)  
1f1a 32 7b ee			ld (debug_mark+1),a  
1f1d 3a 27 1f			ld a, (.dmark+2)  
1f20 32 7c ee			ld (debug_mark+2),a  
1f23 18 03			jr .pastdmark  
1f25 ..			.dmark: db "PMS"  
1f28 f1			.pastdmark: pop af  
1f29			endm  
# End of macro DMARK
1f29						CALLMONITOR 
1f29 cd 8a 11			call break_point_state  
1f2c				endm  
# End of macro CALLMONITOR
1f2c					endif 
1f2c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f2c cd af 17			call macro_dsp_valuehl 
1f2f				endm 
# End of macro FORTH_DSP_VALUEHL
1f2f			;		push hl    ; n2 
1f2f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1f2f cd 2f 18			call macro_forth_dsp_pop 
1f32				endm 
# End of macro FORTH_DSP_POP
1f32			;		pop hl 
1f32			 
1f32 7d					ld a, l 
1f33 cd cb 07				call aDelayInMS 
1f36				       NEXTW 
1f36 c3 e9 18			jp macro_next 
1f39				endm 
# End of macro NEXTW
1f39			.PAUSES:  
1f39				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
1f39 44				db WORD_SYS_CORE+48             
1f3a 70 1f			dw .ROT            
1f3c 06				db 5 + 1 
1f3d .. 00			db "PAUSE",0              
1f43				endm 
# End of macro CWHEAD
1f43			; | PAUSE ( n -- )  Pause for n seconds | DONE 
1f43					if DEBUG_FORTH_WORDS_KEY 
1f43						DMARK "PAU" 
1f43 f5				push af  
1f44 3a 58 1f			ld a, (.dmark)  
1f47 32 7a ee			ld (debug_mark),a  
1f4a 3a 59 1f			ld a, (.dmark+1)  
1f4d 32 7b ee			ld (debug_mark+1),a  
1f50 3a 5a 1f			ld a, (.dmark+2)  
1f53 32 7c ee			ld (debug_mark+2),a  
1f56 18 03			jr .pastdmark  
1f58 ..			.dmark: db "PAU"  
1f5b f1			.pastdmark: pop af  
1f5c			endm  
# End of macro DMARK
1f5c						CALLMONITOR 
1f5c cd 8a 11			call break_point_state  
1f5f				endm  
# End of macro CALLMONITOR
1f5f					endif 
1f5f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f5f cd af 17			call macro_dsp_valuehl 
1f62				endm 
# End of macro FORTH_DSP_VALUEHL
1f62			;		push hl    ; n2 
1f62					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1f62 cd 2f 18			call macro_forth_dsp_pop 
1f65				endm 
# End of macro FORTH_DSP_POP
1f65			;		pop hl 
1f65 45					ld b, l 
1f66					if DEBUG_FORTH_WORDS 
1f66						DMARK "PAU" 
1f66						CALLMONITOR 
1f66					endif 
1f66 c5			.pauses1:	push bc 
1f67 cd e6 07				call delay1s 
1f6a c1					pop bc 
1f6b					if DEBUG_FORTH_WORDS 
1f6b						DMARK "PA1" 
1f6b						CALLMONITOR 
1f6b					endif 
1f6b 10 f9				djnz .pauses1 
1f6d			 
1f6d				       NEXTW 
1f6d c3 e9 18			jp macro_next 
1f70				endm 
# End of macro NEXTW
1f70			.ROT: 
1f70				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
1f70 45				db WORD_SYS_CORE+49             
1f71 be 1f			dw .UWORDS            
1f73 04				db 3 + 1 
1f74 .. 00			db "ROT",0              
1f78				endm 
# End of macro CWHEAD
1f78			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
1f78					if DEBUG_FORTH_WORDS_KEY 
1f78						DMARK "ROT" 
1f78 f5				push af  
1f79 3a 8d 1f			ld a, (.dmark)  
1f7c 32 7a ee			ld (debug_mark),a  
1f7f 3a 8e 1f			ld a, (.dmark+1)  
1f82 32 7b ee			ld (debug_mark+1),a  
1f85 3a 8f 1f			ld a, (.dmark+2)  
1f88 32 7c ee			ld (debug_mark+2),a  
1f8b 18 03			jr .pastdmark  
1f8d ..			.dmark: db "ROT"  
1f90 f1			.pastdmark: pop af  
1f91			endm  
# End of macro DMARK
1f91						CALLMONITOR 
1f91 cd 8a 11			call break_point_state  
1f94				endm  
# End of macro CALLMONITOR
1f94					endif 
1f94			 
1f94					FORTH_DSP_VALUEHL 
1f94 cd af 17			call macro_dsp_valuehl 
1f97				endm 
# End of macro FORTH_DSP_VALUEHL
1f97 e5					push hl    ; u3  
1f98			 
1f98					FORTH_DSP_POP 
1f98 cd 2f 18			call macro_forth_dsp_pop 
1f9b				endm 
# End of macro FORTH_DSP_POP
1f9b			   
1f9b					FORTH_DSP_VALUEHL 
1f9b cd af 17			call macro_dsp_valuehl 
1f9e				endm 
# End of macro FORTH_DSP_VALUEHL
1f9e e5					push hl     ; u2 
1f9f			 
1f9f					FORTH_DSP_POP 
1f9f cd 2f 18			call macro_forth_dsp_pop 
1fa2				endm 
# End of macro FORTH_DSP_POP
1fa2			 
1fa2					FORTH_DSP_VALUEHL 
1fa2 cd af 17			call macro_dsp_valuehl 
1fa5				endm 
# End of macro FORTH_DSP_VALUEHL
1fa5 e5					push hl     ; u1 
1fa6			 
1fa6					FORTH_DSP_POP 
1fa6 cd 2f 18			call macro_forth_dsp_pop 
1fa9				endm 
# End of macro FORTH_DSP_POP
1fa9			 
1fa9 c1					pop bc      ; u1 
1faa e1					pop hl      ; u2 
1fab d1					pop de      ; u3 
1fac			 
1fac			 
1fac c5					push bc 
1fad d5					push de 
1fae e5					push hl 
1faf			 
1faf			 
1faf e1					pop hl 
1fb0 cd 14 17				call forth_push_numhl 
1fb3			 
1fb3 e1					pop hl 
1fb4 cd 14 17				call forth_push_numhl 
1fb7			 
1fb7 e1					pop hl 
1fb8 cd 14 17				call forth_push_numhl 
1fbb					 
1fbb			 
1fbb			 
1fbb			 
1fbb			 
1fbb			 
1fbb				       NEXTW 
1fbb c3 e9 18			jp macro_next 
1fbe				endm 
# End of macro NEXTW
1fbe			 
1fbe			.UWORDS: 
1fbe				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
1fbe 50				db WORD_SYS_CORE+60             
1fbf 10 20			dw .BP            
1fc1 07				db 6 + 1 
1fc2 .. 00			db "UWORDS",0              
1fc9				endm 
# End of macro CWHEAD
1fc9			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
1fc9			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
1fc9			; | | Following the count are the individual words. 
1fc9			; | | 
1fc9			; | | e.g. UWORDS 
1fc9			; | | BOX DIRLIST 2 
1fc9			; | |  
1fc9			; | | Can be used to save the words to storage via: 
1fc9			; | | UWORDS $01 DO $01 APPEND LOOP 
1fc9				if DEBUG_FORTH_WORDS_KEY 
1fc9					DMARK "UWR" 
1fc9 f5				push af  
1fca 3a de 1f			ld a, (.dmark)  
1fcd 32 7a ee			ld (debug_mark),a  
1fd0 3a df 1f			ld a, (.dmark+1)  
1fd3 32 7b ee			ld (debug_mark+1),a  
1fd6 3a e0 1f			ld a, (.dmark+2)  
1fd9 32 7c ee			ld (debug_mark+2),a  
1fdc 18 03			jr .pastdmark  
1fde ..			.dmark: db "UWR"  
1fe1 f1			.pastdmark: pop af  
1fe2			endm  
# End of macro DMARK
1fe2					CALLMONITOR 
1fe2 cd 8a 11			call break_point_state  
1fe5				endm  
# End of macro CALLMONITOR
1fe5				endif 
1fe5 21 c5 47				ld hl, baseram 
1fe8					;ld hl, baseusermem 
1fe8 01 00 00				ld bc, 0    ; start a counter 
1feb			 
1feb				; skip dict stub 
1feb			 
1feb cd 3a 1a				call forth_tok_next 
1fee			 
1fee			 
1fee			; while we have words to look for 
1fee			 
1fee 7e			.douscan:	ld a, (hl)      
1fef				if DEBUG_FORTH_WORDS 
1fef					DMARK "UWs" 
1fef					CALLMONITOR 
1fef				endif 
1fef fe 00				cp WORD_SYS_END 
1ff1 28 15				jr z, .udone 
1ff3 fe 01				cp WORD_SYS_UWORD 
1ff5 20 0c				jr nz, .nuword 
1ff7			 
1ff7				if DEBUG_FORTH_WORDS 
1ff7					DMARK "UWu" 
1ff7					CALLMONITOR 
1ff7				endif 
1ff7					; we have a uword so push its name to the stack 
1ff7			 
1ff7 e5				   	push hl  ; save so we can move to next dict block 
1ff8			 
1ff8					; skip opcode 
1ff8 23					inc hl  
1ff9					; skip next ptr 
1ff9 23					inc hl  
1ffa 23					inc hl 
1ffb					; skip len 
1ffb 23					inc hl 
1ffc				if DEBUG_FORTH_WORDS 
1ffc					DMARK "UWt" 
1ffc					CALLMONITOR 
1ffc				endif 
1ffc 03					inc bc 
1ffd			 
1ffd c5					push bc 
1ffe cd 26 17				call forth_push_str 
2001 c1					pop bc 
2002			 
2002 e1					pop hl 	 
2003			 
2003 cd 3a 1a		.nuword:	call forth_tok_next 
2006 18 e6				jr .douscan  
2008			 
2008			.udone:		 ; push count of uwords found 
2008 c5					push bc 
2009 e1					pop hl 
200a			 
200a				if DEBUG_FORTH_WORDS 
200a					DMARK "UWc" 
200a					CALLMONITOR 
200a				endif 
200a cd 14 17				call forth_push_numhl 
200d			 
200d			 
200d				       NEXTW 
200d c3 e9 18			jp macro_next 
2010				endm 
# End of macro NEXTW
2010			 
2010			.BP: 
2010				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2010 54				db WORD_SYS_CORE+64             
2011 46 20			dw .MONITOR            
2013 03				db 2 + 1 
2014 .. 00			db "BP",0              
2017				endm 
# End of macro CWHEAD
2017			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2017			; | | $00 Will enable the break points within specific code paths 
2017			; | | $01 Will disable break points 
2017			; | |  
2017			; | | By default break points are off. Either the above can be used to enable them 
2017			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2017			; | | and on release of the pressed key a message will be disaplayed to notify 
2017			; | | that break points are enabled. Pressing any key will then continue boot process. 
2017					; get byte count 
2017					if DEBUG_FORTH_WORDS_KEY 
2017						DMARK "BP." 
2017 f5				push af  
2018 3a 2c 20			ld a, (.dmark)  
201b 32 7a ee			ld (debug_mark),a  
201e 3a 2d 20			ld a, (.dmark+1)  
2021 32 7b ee			ld (debug_mark+1),a  
2024 3a 2e 20			ld a, (.dmark+2)  
2027 32 7c ee			ld (debug_mark+2),a  
202a 18 03			jr .pastdmark  
202c ..			.dmark: db "BP."  
202f f1			.pastdmark: pop af  
2030			endm  
# End of macro DMARK
2030						CALLMONITOR 
2030 cd 8a 11			call break_point_state  
2033				endm  
# End of macro CALLMONITOR
2033					endif 
2033			 
2033					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2033 cd af 17			call macro_dsp_valuehl 
2036				endm 
# End of macro FORTH_DSP_VALUEHL
2036			 
2036			;		push hl 
2036			 
2036					; destroy value TOS 
2036			 
2036					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2036 cd 2f 18			call macro_forth_dsp_pop 
2039				endm 
# End of macro FORTH_DSP_POP
2039			 
2039			;		pop hl 
2039			 
2039 3e 00				ld a,0 
203b bd					cp l 
203c 28 02				jr z, .bpset 
203e 3e 2a				ld a, '*' 
2040			 
2040 32 74 e3		.bpset:		ld (os_view_disable), a 
2043			 
2043			 
2043					NEXTW 
2043 c3 e9 18			jp macro_next 
2046				endm 
# End of macro NEXTW
2046			 
2046			 
2046			.MONITOR: 
2046				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2046 55				db WORD_SYS_CORE+65             
2047 79 20			dw .MALLOC            
2049 08				db 7 + 1 
204a .. 00			db "MONITOR",0              
2052				endm 
# End of macro CWHEAD
2052			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2052			; | | At start the current various registers will be displayed with contents. 
2052			; | | Top right corner will show the most recent debug marker seen. 
2052			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2052			; | | and the return stack pointer (RSP). 
2052			; | | Pressing: 
2052			; | |    1 - Initial screen 
2052			; | |    2 - Display a data dump of HL 
2052			; | |    3 - Display a data dump of DE 
2052			; | |    4 - Display a data dump of BC 
2052			; | |    5 - Display a data dump of HL 
2052			; | |    6 - Display a data dump of DSP 
2052			; | |    7 - Display a data dump of RSP 
2052			; | |    8 - Display a data dump of what is at DSP 
2052			; | |    9 - Display a data dump of what is at RSP 
2052			; | |    0 - Exit monitor and continue running. This will also enable break points 
2052			; | |    * - Disable break points 
2052			; | |    # - Enter traditional monitor mode 
2052			; | | 
2052			; | | Monitor Mode 
2052			; | | ------------ 
2052			; | | A prompt of '>' will be shown for various commands: 
2052			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2052			; | |    C - Continue display a data dump from the last set address 
2052			; | |    M xxxx - Set start of memory edit at address xx 
2052			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2052			; | |    Q - Return to previous 
2052					if DEBUG_FORTH_WORDS_KEY 
2052						DMARK "MON" 
2052 f5				push af  
2053 3a 67 20			ld a, (.dmark)  
2056 32 7a ee			ld (debug_mark),a  
2059 3a 68 20			ld a, (.dmark+1)  
205c 32 7b ee			ld (debug_mark+1),a  
205f 3a 69 20			ld a, (.dmark+2)  
2062 32 7c ee			ld (debug_mark+2),a  
2065 18 03			jr .pastdmark  
2067 ..			.dmark: db "MON"  
206a f1			.pastdmark: pop af  
206b			endm  
# End of macro DMARK
206b						CALLMONITOR 
206b cd 8a 11			call break_point_state  
206e				endm  
# End of macro CALLMONITOR
206e					endif 
206e 3e 00				ld a, 0 
2070 32 74 e3				ld (os_view_disable), a 
2073			 
2073					CALLMONITOR 
2073 cd 8a 11			call break_point_state  
2076				endm  
# End of macro CALLMONITOR
2076			 
2076			;	call monitor 
2076			 
2076					NEXTW 
2076 c3 e9 18			jp macro_next 
2079				endm 
# End of macro NEXTW
2079			 
2079			 
2079			.MALLOC: 
2079				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2079 56				db WORD_SYS_CORE+66             
207a a2 20			dw .MALLOC2            
207c 06				db 5 + 1 
207d .. 00			db "ALLOT",0              
2083				endm 
# End of macro CWHEAD
2083			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2083					if DEBUG_FORTH_WORDS_KEY 
2083						DMARK "ALL" 
2083 f5				push af  
2084 3a 98 20			ld a, (.dmark)  
2087 32 7a ee			ld (debug_mark),a  
208a 3a 99 20			ld a, (.dmark+1)  
208d 32 7b ee			ld (debug_mark+1),a  
2090 3a 9a 20			ld a, (.dmark+2)  
2093 32 7c ee			ld (debug_mark+2),a  
2096 18 03			jr .pastdmark  
2098 ..			.dmark: db "ALL"  
209b f1			.pastdmark: pop af  
209c			endm  
# End of macro DMARK
209c						CALLMONITOR 
209c cd 8a 11			call break_point_state  
209f				endm  
# End of macro CALLMONITOR
209f					endif 
209f c3 c9 20				jp .mallocc 
20a2			.MALLOC2: 
20a2				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
20a2 56				db WORD_SYS_CORE+66             
20a3 e0 20			dw .FREE            
20a5 07				db 6 + 1 
20a6 .. 00			db "MALLOC",0              
20ad				endm 
# End of macro CWHEAD
20ad			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
20ad					; get byte count 
20ad					if DEBUG_FORTH_WORDS_KEY 
20ad						DMARK "MAL" 
20ad f5				push af  
20ae 3a c2 20			ld a, (.dmark)  
20b1 32 7a ee			ld (debug_mark),a  
20b4 3a c3 20			ld a, (.dmark+1)  
20b7 32 7b ee			ld (debug_mark+1),a  
20ba 3a c4 20			ld a, (.dmark+2)  
20bd 32 7c ee			ld (debug_mark+2),a  
20c0 18 03			jr .pastdmark  
20c2 ..			.dmark: db "MAL"  
20c5 f1			.pastdmark: pop af  
20c6			endm  
# End of macro DMARK
20c6						CALLMONITOR 
20c6 cd 8a 11			call break_point_state  
20c9				endm  
# End of macro CALLMONITOR
20c9					endif 
20c9			.mallocc: 
20c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20c9 cd af 17			call macro_dsp_valuehl 
20cc				endm 
# End of macro FORTH_DSP_VALUEHL
20cc			 
20cc			;		push hl 
20cc			 
20cc					; destroy value TOS 
20cc			 
20cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
20cc cd 2f 18			call macro_forth_dsp_pop 
20cf				endm 
# End of macro FORTH_DSP_POP
20cf			 
20cf			;		pop hl 
20cf cd 8d 0e				call malloc 
20d2				if DEBUG_FORTH_MALLOC_GUARD 
20d2 f5					push af 
20d3 cd ef 09				call ishlzero 
20d6			;		ld a, l 
20d6			;		add h 
20d6			;		cp 0 
20d6 f1					pop af 
20d7					 
20d7 cc 8d 34				call z,malloc_error 
20da				endif 
20da			 
20da cd 14 17				call forth_push_numhl 
20dd					NEXTW 
20dd c3 e9 18			jp macro_next 
20e0				endm 
# End of macro NEXTW
20e0			 
20e0			.FREE: 
20e0				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
20e0 57				db WORD_SYS_CORE+67             
20e1 11 21			dw .LIST            
20e3 05				db 4 + 1 
20e4 .. 00			db "FREE",0              
20e9				endm 
# End of macro CWHEAD
20e9			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
20e9					if DEBUG_FORTH_WORDS_KEY 
20e9						DMARK "FRE" 
20e9 f5				push af  
20ea 3a fe 20			ld a, (.dmark)  
20ed 32 7a ee			ld (debug_mark),a  
20f0 3a ff 20			ld a, (.dmark+1)  
20f3 32 7b ee			ld (debug_mark+1),a  
20f6 3a 00 21			ld a, (.dmark+2)  
20f9 32 7c ee			ld (debug_mark+2),a  
20fc 18 03			jr .pastdmark  
20fe ..			.dmark: db "FRE"  
2101 f1			.pastdmark: pop af  
2102			endm  
# End of macro DMARK
2102						CALLMONITOR 
2102 cd 8a 11			call break_point_state  
2105				endm  
# End of macro CALLMONITOR
2105					endif 
2105					; get address 
2105			 
2105					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2105 cd af 17			call macro_dsp_valuehl 
2108				endm 
# End of macro FORTH_DSP_VALUEHL
2108			 
2108			;		push hl 
2108			 
2108					; destroy value TOS 
2108			 
2108					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2108 cd 2f 18			call macro_forth_dsp_pop 
210b				endm 
# End of macro FORTH_DSP_POP
210b			 
210b			;		pop hl 
210b			if FORTH_ENABLE_MALLOCFREE 
210b cd 57 0f				call free 
210e			endif 
210e					NEXTW 
210e c3 e9 18			jp macro_next 
2111				endm 
# End of macro NEXTW
2111			.LIST: 
2111				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2111 5c				db WORD_SYS_CORE+72             
2112 bc 21			dw .FORGET            
2114 05				db 4 + 1 
2115 .. 00			db "LIST",0              
211a				endm 
# End of macro CWHEAD
211a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
211a			; | | The quoted word must be in upper case. 
211a				if DEBUG_FORTH_WORDS_KEY 
211a					DMARK "LST" 
211a f5				push af  
211b 3a 2f 21			ld a, (.dmark)  
211e 32 7a ee			ld (debug_mark),a  
2121 3a 30 21			ld a, (.dmark+1)  
2124 32 7b ee			ld (debug_mark+1),a  
2127 3a 31 21			ld a, (.dmark+2)  
212a 32 7c ee			ld (debug_mark+2),a  
212d 18 03			jr .pastdmark  
212f ..			.dmark: db "LST"  
2132 f1			.pastdmark: pop af  
2133			endm  
# End of macro DMARK
2133					CALLMONITOR 
2133 cd 8a 11			call break_point_state  
2136				endm  
# End of macro CALLMONITOR
2136				endif 
2136			 
2136					FORTH_DSP_VALUEHL 
2136 cd af 17			call macro_dsp_valuehl 
2139				endm 
# End of macro FORTH_DSP_VALUEHL
2139			 
2139 e5					push hl 
213a c1					pop bc 
213b			 
213b			; Start format of scratch string 
213b			 
213b 21 75 e3				ld hl, scratch 
213e			 
213e 3e 3a				ld a, ':' 
2140 77					ld (hl),a 
2141 23					inc hl 
2142 3e 20				ld a, ' ' 
2144 77					ld (hl), a 
2145			 
2145					; Get ptr to the word we need to look up 
2145			 
2145			;		FORTH_DSP_VALUEHL 
2145					;v5 FORTH_DSP_VALUE 
2145				; TODO type check 
2145			;		inc hl    ; Skip type check  
2145			;		push hl 
2145			;		ex de, hl    ; put into DE 
2145			 
2145			 
2145 21 c5 47				ld hl, baseram 
2148					;ld hl, baseusermem 
2148			 
2148 e5			push hl   ; sacreifical push 
2149			 
2149			.ldouscanm: 
2149 e1				pop hl 
214a			.ldouscan: 
214a				if DEBUG_FORTH_WORDS 
214a					DMARK "LSs" 
214a					CALLMONITOR 
214a				endif 
214a				; skip dict stub 
214a cd 3a 1a				call forth_tok_next 
214d			 
214d			 
214d			; while we have words to look for 
214d			 
214d 7e				ld a, (hl)      
214e				if DEBUG_FORTH_WORDS 
214e					DMARK "LSk" 
214e					CALLMONITOR 
214e				endif 
214e fe 00				cp WORD_SYS_END 
2150 ca a3 21				jp z, .lunotfound 
2153 fe 01				cp WORD_SYS_UWORD 
2155 c2 4a 21				jp nz, .ldouscan 
2158			 
2158				if DEBUG_FORTH_WORDS 
2158					DMARK "LSu" 
2158					CALLMONITOR 
2158				endif 
2158			 
2158					; found a uword but is it the one we want... 
2158			 
2158 c5					push bc     ; uword to find is on bc 
2159 d1					pop de 
215a			 
215a e5					push hl  ; to save the ptr 
215b			 
215b					; skip opcode 
215b 23					inc hl  
215c					; skip next ptr 
215c 23					inc hl  
215d 23					inc hl 
215e					; skip len 
215e 23					inc hl 
215f			 
215f				if DEBUG_FORTH_WORDS 
215f					DMARK "LSc" 
215f					CALLMONITOR 
215f				endif 
215f cd 5c 0e				call strcmp 
2162 c2 49 21				jp nz, .ldouscanm 
2165				 
2165			 
2165			 
2165					; we have a uword so push its name to the stack 
2165			 
2165			;	   	push hl  ; save so we can move to next dict block 
2165 e1			pop hl 
2166			 
2166				if DEBUG_FORTH_WORDS 
2166					DMARK "LSm" 
2166					CALLMONITOR 
2166				endif 
2166			 
2166					; skip opcode 
2166 23					inc hl  
2167					; skip next ptr 
2167 23					inc hl  
2168 23					inc hl 
2169					; skip len 
2169 7e					ld a, (hl)   ; save length to add 
216a				if DEBUG_FORTH_WORDS 
216a					DMARK "LS2" 
216a					CALLMONITOR 
216a				endif 
216a			 
216a					; save this location 
216a				 
216a e5					push hl 
216b			 
216b 23					inc hl 
216c 11 77 e3				ld de, scratch+2 
216f 4f					ld c, a 
2170 06 00				ld b, 0 
2172			 
2172				if DEBUG_FORTH_WORDS 
2172					DMARK "LSn" 
2172					CALLMONITOR 
2172				endif 
2172			 
2172					; copy uword name to scratch 
2172			 
2172 ed b0				ldir 
2174			 
2174 1b					dec de 
2175 3e 20				ld a, ' '    ; change null to space 
2177 12					ld (de), a 
2178			 
2178 13					inc de 
2179			 
2179 d5					push de 
217a c1					pop bc     ; move scratch pointer to end of word name and save it 
217b			 
217b e1					pop hl 
217c 7e					ld a, (hl) 
217d					;inc hl 
217d					; skip word string 
217d cd c6 09				call addatohl 
2180			 
2180 23					inc hl 
2181			 
2181				if DEBUG_FORTH_WORDS 
2181					DMARK "LS3" 
2181					CALLMONITOR 
2181				endif 
2181					; should now be at the start of the machine code to setup the eval of the uword 
2181					; now locate the ptr to the string defintion 
2181			 
2181					; skip ld hl, 
2181					; then load the ptr 
2181			 
2181 23					inc hl 
2182 5e					ld e, (hl) 
2183 23					inc hl 
2184 56					ld d, (hl) 
2185 eb					ex de, hl 
2186			 
2186			 
2186				if DEBUG_FORTH_WORDS 
2186					DMARK "LSt" 
2186					CALLMONITOR 
2186				endif 
2186			 
2186			; cant push right now due to tokenised strings  
2186			 
2186			; get the destination of where to copy this definition to. 
2186			 
2186 c5					push bc 
2187 d1					pop de 
2188			 
2188 7e			.listl:         ld a,(hl) 
2189 fe 00				cp 0 
218b 28 09				jr z, .lreplsp     ; replace zero with space 
218d fe 7f				cp FORTH_END_BUFFER 
218f 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2191				 
2191					; just copy this char as is then 
2191			 
2191 12					ld (de), a 
2192			 
2192 23			.listnxt:	inc hl 
2193 13					inc de 
2194 18 f2				jr .listl 
2196			 
2196 3e 20		.lreplsp:	ld a,' ' 
2198 12					ld (de), a 
2199 18 f7				jr .listnxt 
219b			 
219b			; close up uword def 
219b			 
219b			.listdone: 
219b 3e 00				ld a, 0 
219d 12					ld (de), a 
219e			 
219e			; now have def so clean up and push to stack 
219e			 
219e 21 75 e3				ld hl, scratch 
21a1				if DEBUG_FORTH_WORDS 
21a1					DMARK "Ltp" 
21a1					CALLMONITOR 
21a1				endif 
21a1			 
21a1 18 06			jr .listpush 
21a3			 
21a3			;.lnuword:	pop hl 
21a3			;		call forth_tok_next 
21a3			;		jp .ldouscan  
21a3			 
21a3			.lunotfound:		  
21a3			 
21a3			 
21a3					 
21a3					FORTH_DSP_POP 
21a3 cd 2f 18			call macro_forth_dsp_pop 
21a6				endm 
# End of macro FORTH_DSP_POP
21a6 21 af 21				ld hl, .luno 
21a9						 
21a9			 
21a9			.listpush: 
21a9 cd 26 17				call forth_push_str 
21ac			 
21ac			 
21ac			 
21ac					NEXTW 
21ac c3 e9 18			jp macro_next 
21af				endm 
# End of macro NEXTW
21af			 
21af .. 00		.luno:    db "Not found",0 
21b9			 
21b9			 
21b9			 
21b9			 
21b9			 
21b9			;		push hl   ; save pointer to start of uword def string 
21b9			; 
21b9			;; look for FORTH_EOL_LINE 
21b9			;		ld a, FORTH_END_BUFFER 
21b9			;		call strlent 
21b9			; 
21b9			;		inc hl		 ; space for coln def 
21b9			;		inc hl 
21b9			;		inc hl          ; space for terms 
21b9			;		inc hl 
21b9			; 
21b9			;		ld a, 20   ; TODO get actual length 
21b9			;		call addatohl    ; include a random amount of room for the uword name 
21b9			; 
21b9			;		 
21b9			;	if DEBUG_FORTH_WORDS 
21b9			;		DMARK "Lt1" 
21b9			;		CALLMONITOR 
21b9			;	endif 
21b9			;		 
21b9			; 
21b9			;; malloc space for the string because we cant change it 
21b9			; 
21b9			;		call malloc 
21b9			;	if DEBUG_FORTH_MALLOC_GUARD 
21b9			;		push af 
21b9			;		call ishlzero 
21b9			;		pop af 
21b9			;		 
21b9			;		call z,malloc_error 
21b9			;	endif 
21b9			; 
21b9			;	if DEBUG_FORTH_WORDS 
21b9			;		DMARK "Lt2" 
21b9			;		CALLMONITOR 
21b9			;	endif 
21b9			;		pop de 
21b9			;		push hl    ; push the malloc to release later 
21b9			;		push hl   ;  push back a copy for the later stack push 
21b9			;		 
21b9			;; copy the string swapping out the zero terms for spaces 
21b9			; 
21b9			;		; de has our source 
21b9			;		; hl has our dest 
21b9			; 
21b9			;; add the coln def 
21b9			; 
21b9			;		ld a, ':' 
21b9			;		ld (hl), a 
21b9			;		inc hl 
21b9			;		ld a, ' ' 
21b9			;		ld (hl), a 
21b9			;		inc hl 
21b9			; 
21b9			;; add the uname word 
21b9			;		push de   ; save our string for now 
21b9			;		ex de, hl 
21b9			; 
21b9			;		FORTH_DSP_VALUE 
21b9			;		;v5 FORTH_DSP_VALUE 
21b9			; 
21b9			;		inc hl   ; skip type but we know by now this is OK 
21b9			; 
21b9			;.luword:	ld a,(hl) 
21b9			;		cp 0 
21b9			;		jr z, .luword2 
21b9			;		ld (de), a 
21b9			;		inc de 
21b9			;		inc hl 
21b9			;		jr .luword 
21b9			; 
21b9			;.luword2:	ld a, ' ' 
21b9			;		ld (de), a 
21b9			;;		inc hl 
21b9			;;		inc de 
21b9			;;		ld (de), a 
21b9			;;		inc hl 
21b9			;		inc de 
21b9			; 
21b9			;		ex de, hl 
21b9			;		pop de 
21b9			;		 
21b9			;		 
21b9			; 
21b9			;; detoken that string and copy it 
21b9			; 
21b9			;	if DEBUG_FORTH_WORDS 
21b9			;		DMARK "Lt2" 
21b9			;		CALLMONITOR 
21b9			;	endif 
21b9			;.ldetok:	ld a, (de) 
21b9			;		cp FORTH_END_BUFFER 
21b9			;		jr z, .ldetokend 
21b9			;		; swap out any zero term for space 
21b9			;		cp 0 
21b9			;		jr nz, .ldetoknext 
21b9			;		ld a, ' ' 
21b9			; 
21b9			;	if DEBUG_FORTH_WORDS 
21b9			;		DMARK "LtS" 
21b9			;		CALLMONITOR 
21b9			;	endif 
21b9			;.ldetoknext:	ld (hl), a 
21b9			;		inc de 
21b9			;		inc hl 
21b9			;		jr .ldetok 
21b9			; 
21b9			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
21b9			;		ld (hl), a  
21b9			; 
21b9			;; free that temp malloc 
21b9			; 
21b9			;		pop hl    
21b9			; 
21b9			;	if DEBUG_FORTH_WORDS 
21b9			;		DMARK "Lt4" 
21b9			;		CALLMONITOR 
21b9			;	endif 
21b9			;		call forth_apushstrhl 
21b9			; 
21b9			;		; get rid of temp malloc area 
21b9			; 
21b9			;		pop hl 
21b9			;		call free 
21b9			; 
21b9			;		jr .ludone 
21b9			; 
21b9			;.lnuword:	pop hl 
21b9			;		call forth_tok_next 
21b9			;		jp .ldouscan  
21b9			; 
21b9			;.ludone:		 pop hl 
21b9			; 
21b9					NEXTW 
21b9 c3 e9 18			jp macro_next 
21bc				endm 
# End of macro NEXTW
21bc			 
21bc			.FORGET: 
21bc				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
21bc 5d				db WORD_SYS_CORE+73             
21bd 19 22			dw .NOP            
21bf 07				db 6 + 1 
21c0 .. 00			db "FORGET",0              
21c7				endm 
# End of macro CWHEAD
21c7			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
21c7			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
21c7			; | |  
21c7			; | | e.g. "MORE" forget 
21c7					if DEBUG_FORTH_WORDS_KEY 
21c7						DMARK "FRG" 
21c7 f5				push af  
21c8 3a dc 21			ld a, (.dmark)  
21cb 32 7a ee			ld (debug_mark),a  
21ce 3a dd 21			ld a, (.dmark+1)  
21d1 32 7b ee			ld (debug_mark+1),a  
21d4 3a de 21			ld a, (.dmark+2)  
21d7 32 7c ee			ld (debug_mark+2),a  
21da 18 03			jr .pastdmark  
21dc ..			.dmark: db "FRG"  
21df f1			.pastdmark: pop af  
21e0			endm  
# End of macro DMARK
21e0						CALLMONITOR 
21e0 cd 8a 11			call break_point_state  
21e3				endm  
# End of macro CALLMONITOR
21e3					endif 
21e3			 
21e3				; find uword 
21e3			        ; update start of word with "_" 
21e3				; replace uword with deleted flag 
21e3			 
21e3			 
21e3			;	if DEBUG_FORTH_WORDS 
21e3			;		DMARK "FOG" 
21e3			;		CALLMONITOR 
21e3			;	endif 
21e3			 
21e3			 
21e3					; Get ptr to the word we need to look up 
21e3			 
21e3					FORTH_DSP_VALUEHL 
21e3 cd af 17			call macro_dsp_valuehl 
21e6				endm 
# End of macro FORTH_DSP_VALUEHL
21e6					;v5 FORTH_DSP_VALUE 
21e6				; TODO type check 
21e6			;		inc hl    ; Skip type check  
21e6 e5					push hl 
21e7 c1					pop bc 
21e8			;		ex de, hl    ; put into DE 
21e8			 
21e8			 
21e8 21 c5 47				ld hl, baseram 
21eb					;ld hl, baseusermem 
21eb			 
21eb				; skip dict stub 
21eb			;	call forth_tok_next 
21eb e5			push hl   ; sacreifical push 
21ec			 
21ec			.fldouscanm: 
21ec e1				pop hl 
21ed			.fldouscan: 
21ed			;	if DEBUG_FORTH_WORDS 
21ed			;		DMARK "LSs" 
21ed			;		CALLMONITOR 
21ed			;	endif 
21ed				; skip dict stub 
21ed cd 3a 1a				call forth_tok_next 
21f0			 
21f0			 
21f0			; while we have words to look for 
21f0			 
21f0 7e				ld a, (hl)      
21f1			;	if DEBUG_FORTH_WORDS 
21f1			;		DMARK "LSk" 
21f1			;		CALLMONITOR 
21f1			;	endif 
21f1 fe 00				cp WORD_SYS_END 
21f3 ca 13 22				jp z, .flunotfound 
21f6 fe 01				cp WORD_SYS_UWORD 
21f8 c2 ed 21				jp nz, .fldouscan 
21fb			 
21fb			;	if DEBUG_FORTH_WORDS 
21fb			;		DMARK "LSu" 
21fb			;		CALLMONITOR 
21fb			;	endif 
21fb			 
21fb					; found a uword but is it the one we want... 
21fb			 
21fb c5					push bc     ; uword to find is on bc 
21fc d1					pop de 
21fd			 
21fd e5					push hl  ; to save the ptr 
21fe			 
21fe					; skip opcode 
21fe 23					inc hl  
21ff					; skip next ptr 
21ff 23					inc hl  
2200 23					inc hl 
2201					; skip len 
2201 23					inc hl 
2202			 
2202			;	if DEBUG_FORTH_WORDS 
2202			;		DMARK "LSc" 
2202			;		CALLMONITOR 
2202			;	endif 
2202 cd 5c 0e				call strcmp 
2205 c2 ec 21				jp nz, .fldouscanm 
2208			; 
2208			; 
2208			;; while we have words to look for 
2208			; 
2208			;.fdouscan:	ld a, (hl)      
2208			;	if DEBUG_FORTH_WORDS 
2208			;		DMARK "LSs" 
2208			;		CALLMONITOR 
2208			;	endif 
2208			;		cp WORD_SYS_END 
2208			;		jp z, .fudone 
2208			;		cp WORD_SYS_UWORD 
2208			;		jp nz, .fnuword 
2208			; 
2208			;	if DEBUG_FORTH_WORDS 
2208			;		DMARK "FGu" 
2208			;		CALLMONITOR 
2208			;	endif 
2208			; 
2208			;		; found a uword but is it the one we want... 
2208			; 
2208			; 
2208			;	        pop de   ; get back the dsp name 
2208			;		push de 
2208			; 
2208			;		push hl  ; to save the ptr 
2208			; 
2208			;		; skip opcode 
2208			;		inc hl  
2208			;		; skip next ptr 
2208			;		inc hl  
2208			;		inc hl 
2208			;		; skip len 
2208			;		inc hl 
2208			; 
2208			;	if DEBUG_FORTH_WORDS 
2208			;		DMARK "FGc" 
2208			;		CALLMONITOR 
2208			;	endif 
2208			;		call strcmp 
2208			;		jp nz, .fnuword 
2208			 
2208			 
2208 e1			pop hl 
2209			 
2209				 
2209				if DEBUG_FORTH_WORDS 
2209					DMARK "FGm" 
2209					CALLMONITOR 
2209				endif 
2209			 
2209			 
2209			 
2209					; we have a uword so push its name to the stack 
2209			 
2209			;	   	push hl  ; save so we can move to next dict block 
2209			;pop hl 
2209			 
2209					; update opcode to deleted 
2209 3e 03				ld a, WORD_SYS_DELETED 
220b 77					ld (hl), a 
220c			 
220c 23					inc hl  
220d					; skip next ptr 
220d 23					inc hl  
220e 23					inc hl 
220f					; skip len 
220f 23					inc hl 
2210			 
2210					; TODO change parser to skip deleted words but for now mark it out 
2210 3e 5f				ld a, "_" 
2212 77					ld  (hl),a 
2213			 
2213			;		jr .fudone 
2213			; 
2213			;.fnuword:	pop hl 
2213			;		call forth_tok_next 
2213			;		jp .fdouscan  
2213			 
2213			.flunotfound:		  
2213			 
2213			 
2213					 
2213					FORTH_DSP_POP 
2213 cd 2f 18			call macro_forth_dsp_pop 
2216				endm 
# End of macro FORTH_DSP_POP
2216			;		ld hl, .luno 
2216			;.fudone:		 pop hl 
2216					NEXTW 
2216 c3 e9 18			jp macro_next 
2219				endm 
# End of macro NEXTW
2219			.NOP: 
2219				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2219 61				db WORD_SYS_CORE+77             
221a 40 22			dw .COMO            
221c 04				db 3 + 1 
221d .. 00			db "NOP",0              
2221				endm 
# End of macro CWHEAD
2221			; | NOP (  --  ) Do nothing | DONE 
2221					if DEBUG_FORTH_WORDS_KEY 
2221						DMARK "NOP" 
2221 f5				push af  
2222 3a 36 22			ld a, (.dmark)  
2225 32 7a ee			ld (debug_mark),a  
2228 3a 37 22			ld a, (.dmark+1)  
222b 32 7b ee			ld (debug_mark+1),a  
222e 3a 38 22			ld a, (.dmark+2)  
2231 32 7c ee			ld (debug_mark+2),a  
2234 18 03			jr .pastdmark  
2236 ..			.dmark: db "NOP"  
2239 f1			.pastdmark: pop af  
223a			endm  
# End of macro DMARK
223a						CALLMONITOR 
223a cd 8a 11			call break_point_state  
223d				endm  
# End of macro CALLMONITOR
223d					endif 
223d				       NEXTW 
223d c3 e9 18			jp macro_next 
2240				endm 
# End of macro NEXTW
2240			.COMO: 
2240				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2240 6e				db WORD_SYS_CORE+90             
2241 5a 22			dw .COMC            
2243 02				db 1 + 1 
2244 .. 00			db "(",0              
2246				endm 
# End of macro CWHEAD
2246			; | ( ( -- )  Start of comment | DONE 
2246			 
2246			 
2246 2a 76 e6				ld hl, ( os_tok_ptr) 
2249 11 55 22			ld de, .closepar 
224c					 
224c					if DEBUG_FORTH_WORDS 
224c						DMARK ").." 
224c						CALLMONITOR 
224c					endif 
224c cd 04 1a			call findnexttok  
224f			 
224f					if DEBUG_FORTH_WORDS 
224f						DMARK "IF5" 
224f						CALLMONITOR 
224f					endif 
224f				; replace below with ) exec using tok_ptr 
224f 22 76 e6			ld (os_tok_ptr), hl 
2252 c3 7a 19			jp exec1 
2255			 
2255 .. 00			.closepar:   db ")",0 
2257			 
2257				       NEXTW 
2257 c3 e9 18			jp macro_next 
225a				endm 
# End of macro NEXTW
225a			.COMC: 
225a				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
225a 6f				db WORD_SYS_CORE+91             
225b 63 22			dw .SCRATCH            
225d 02				db 1 + 1 
225e .. 00			db ")",0              
2260				endm 
# End of macro CWHEAD
2260			; | ) ( -- )  End of comment |  DONE  
2260				       NEXTW 
2260 c3 e9 18			jp macro_next 
2263				endm 
# End of macro NEXTW
2263			 
2263			.SCRATCH: 
2263				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2263 6f				db WORD_SYS_CORE+91             
2264 9e 22			dw .INC            
2266 08				db 7 + 1 
2267 .. 00			db "SCRATCH",0              
226f				endm 
# End of macro CWHEAD
226f			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
226f			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
226f			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
226f			; | |  
226f			; | | e.g.    : score $00 scratch ; 
226f			; | |  
226f			; | | $00 score ! 
226f			; | | $01 score +! 
226f			; | |  
226f			; | | e.g.   : varword $0a scratch ;  
226f			; | | 
226f			; | | $8000 varword ! 
226f					if DEBUG_FORTH_WORDS_KEY 
226f						DMARK "SCR" 
226f f5				push af  
2270 3a 84 22			ld a, (.dmark)  
2273 32 7a ee			ld (debug_mark),a  
2276 3a 85 22			ld a, (.dmark+1)  
2279 32 7b ee			ld (debug_mark+1),a  
227c 3a 86 22			ld a, (.dmark+2)  
227f 32 7c ee			ld (debug_mark+2),a  
2282 18 03			jr .pastdmark  
2284 ..			.dmark: db "SCR"  
2287 f1			.pastdmark: pop af  
2288			endm  
# End of macro DMARK
2288						CALLMONITOR 
2288 cd 8a 11			call break_point_state  
228b				endm  
# End of macro CALLMONITOR
228b					endif 
228b			 
228b					FORTH_DSP_VALUEHL 
228b cd af 17			call macro_dsp_valuehl 
228e				endm 
# End of macro FORTH_DSP_VALUEHL
228e				 
228e					FORTH_DSP_POP 
228e cd 2f 18			call macro_forth_dsp_pop 
2291				endm 
# End of macro FORTH_DSP_POP
2291			 
2291 7d					ld a, l 
2292 21 9a e8				ld hl, os_var_array 
2295 cd c6 09				call addatohl 
2298			 
2298 cd 14 17				call forth_push_numhl 
229b			 
229b				       NEXTW 
229b c3 e9 18			jp macro_next 
229e				endm 
# End of macro NEXTW
229e			 
229e			.INC: 
229e				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
229e 6f				db WORD_SYS_CORE+91             
229f d6 22			dw .DEC            
22a1 03				db 2 + 1 
22a2 .. 00			db "+!",0              
22a5				endm 
# End of macro CWHEAD
22a5			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
22a5					if DEBUG_FORTH_WORDS_KEY 
22a5						DMARK "+s_" 
22a5 f5				push af  
22a6 3a ba 22			ld a, (.dmark)  
22a9 32 7a ee			ld (debug_mark),a  
22ac 3a bb 22			ld a, (.dmark+1)  
22af 32 7b ee			ld (debug_mark+1),a  
22b2 3a bc 22			ld a, (.dmark+2)  
22b5 32 7c ee			ld (debug_mark+2),a  
22b8 18 03			jr .pastdmark  
22ba ..			.dmark: db "+s_"  
22bd f1			.pastdmark: pop af  
22be			endm  
# End of macro DMARK
22be						CALLMONITOR 
22be cd 8a 11			call break_point_state  
22c1				endm  
# End of macro CALLMONITOR
22c1					endif 
22c1			 
22c1					FORTH_DSP_VALUEHL 
22c1 cd af 17			call macro_dsp_valuehl 
22c4				endm 
# End of macro FORTH_DSP_VALUEHL
22c4			 
22c4 e5					push hl   ; save address 
22c5			 
22c5					FORTH_DSP_POP 
22c5 cd 2f 18			call macro_forth_dsp_pop 
22c8				endm 
# End of macro FORTH_DSP_POP
22c8			 
22c8					FORTH_DSP_VALUEHL 
22c8 cd af 17			call macro_dsp_valuehl 
22cb				endm 
# End of macro FORTH_DSP_VALUEHL
22cb			 
22cb					FORTH_DSP_POP 
22cb cd 2f 18			call macro_forth_dsp_pop 
22ce				endm 
# End of macro FORTH_DSP_POP
22ce			 
22ce					; hl contains value to add to byte at a 
22ce				 
22ce eb					ex de, hl 
22cf			 
22cf e1					pop hl 
22d0			 
22d0					if DEBUG_FORTH_WORDS 
22d0						DMARK "INC" 
22d0						CALLMONITOR 
22d0					endif 
22d0			 
22d0 7e					ld a,(hl) 
22d1 83					add e 
22d2 77					ld (hl),a 
22d3			 
22d3			 
22d3			 
22d3				       NEXTW 
22d3 c3 e9 18			jp macro_next 
22d6				endm 
# End of macro NEXTW
22d6			 
22d6			.DEC: 
22d6				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
22d6 6f				db WORD_SYS_CORE+91             
22d7 0b 23			dw .INC2            
22d9 03				db 2 + 1 
22da .. 00			db "-!",0              
22dd				endm 
# End of macro CWHEAD
22dd			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
22dd					if DEBUG_FORTH_WORDS_KEY 
22dd						DMARK "-s_" 
22dd f5				push af  
22de 3a f2 22			ld a, (.dmark)  
22e1 32 7a ee			ld (debug_mark),a  
22e4 3a f3 22			ld a, (.dmark+1)  
22e7 32 7b ee			ld (debug_mark+1),a  
22ea 3a f4 22			ld a, (.dmark+2)  
22ed 32 7c ee			ld (debug_mark+2),a  
22f0 18 03			jr .pastdmark  
22f2 ..			.dmark: db "-s_"  
22f5 f1			.pastdmark: pop af  
22f6			endm  
# End of macro DMARK
22f6						CALLMONITOR 
22f6 cd 8a 11			call break_point_state  
22f9				endm  
# End of macro CALLMONITOR
22f9					endif 
22f9			 
22f9					FORTH_DSP_VALUEHL 
22f9 cd af 17			call macro_dsp_valuehl 
22fc				endm 
# End of macro FORTH_DSP_VALUEHL
22fc			 
22fc e5					push hl   ; save address 
22fd			 
22fd					FORTH_DSP_POP 
22fd cd 2f 18			call macro_forth_dsp_pop 
2300				endm 
# End of macro FORTH_DSP_POP
2300			 
2300					FORTH_DSP_VALUEHL 
2300 cd af 17			call macro_dsp_valuehl 
2303				endm 
# End of macro FORTH_DSP_VALUEHL
2303			 
2303					; hl contains value to add to byte at a 
2303				 
2303 eb					ex de, hl 
2304			 
2304 e1					pop hl 
2305			 
2305					if DEBUG_FORTH_WORDS 
2305						DMARK "DEC" 
2305						CALLMONITOR 
2305					endif 
2305			 
2305 7e					ld a,(hl) 
2306 93					sub e 
2307 77					ld (hl),a 
2308			 
2308			 
2308			 
2308				       NEXTW 
2308 c3 e9 18			jp macro_next 
230b				endm 
# End of macro NEXTW
230b			 
230b			.INC2: 
230b				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
230b 6f				db WORD_SYS_CORE+91             
230c 45 23			dw .DEC2            
230e 04				db 3 + 1 
230f .. 00			db "+2!",0              
2313				endm 
# End of macro CWHEAD
2313			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2313			 
2313					if DEBUG_FORTH_WORDS_KEY 
2313						DMARK "+2s" 
2313 f5				push af  
2314 3a 28 23			ld a, (.dmark)  
2317 32 7a ee			ld (debug_mark),a  
231a 3a 29 23			ld a, (.dmark+1)  
231d 32 7b ee			ld (debug_mark+1),a  
2320 3a 2a 23			ld a, (.dmark+2)  
2323 32 7c ee			ld (debug_mark+2),a  
2326 18 03			jr .pastdmark  
2328 ..			.dmark: db "+2s"  
232b f1			.pastdmark: pop af  
232c			endm  
# End of macro DMARK
232c						CALLMONITOR 
232c cd 8a 11			call break_point_state  
232f				endm  
# End of macro CALLMONITOR
232f					endif 
232f			 
232f					; Address 
232f			 
232f					FORTH_DSP_VALUEHL 
232f cd af 17			call macro_dsp_valuehl 
2332				endm 
# End of macro FORTH_DSP_VALUEHL
2332			 
2332 e5					push hl    ; save address 
2333			 
2333					; load content into de 
2333			 
2333 5e					ld e,(hl) 
2334 23					inc hl 
2335 56					ld d, (hl) 
2336			 
2336					if DEBUG_FORTH_WORDS 
2336						DMARK "+2a" 
2336						CALLMONITOR 
2336					endif 
2336			 
2336					FORTH_DSP_POP 
2336 cd 2f 18			call macro_forth_dsp_pop 
2339				endm 
# End of macro FORTH_DSP_POP
2339			 
2339					; Get value to add 
2339			 
2339					FORTH_DSP_VALUE 
2339 cd 98 17			call macro_forth_dsp_value 
233c				endm 
# End of macro FORTH_DSP_VALUE
233c			 
233c					if DEBUG_FORTH_WORDS 
233c						DMARK "+2v" 
233c						CALLMONITOR 
233c					endif 
233c			 
233c 19					add hl, de 
233d			 
233d					if DEBUG_FORTH_WORDS 
233d						DMARK "+2+" 
233d						CALLMONITOR 
233d					endif 
233d			 
233d					; move result to de 
233d			 
233d eb					ex de, hl 
233e			 
233e					; Address 
233e			 
233e e1					pop hl 
233f			 
233f					; save it back 
233f			 
233f 73					ld (hl), e 
2340 23					inc hl 
2341 72					ld (hl), d 
2342			 
2342					if DEBUG_FORTH_WORDS 
2342						DMARK "+2e" 
2342						CALLMONITOR 
2342					endif 
2342			 
2342			 
2342			 
2342			 
2342			 
2342				       NEXTW 
2342 c3 e9 18			jp macro_next 
2345				endm 
# End of macro NEXTW
2345			 
2345			.DEC2: 
2345				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2345 6f				db WORD_SYS_CORE+91             
2346 81 23			dw .GET2            
2348 04				db 3 + 1 
2349 .. 00			db "-2!",0              
234d				endm 
# End of macro CWHEAD
234d			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
234d			 
234d			 
234d					if DEBUG_FORTH_WORDS_KEY 
234d						DMARK "-2s" 
234d f5				push af  
234e 3a 62 23			ld a, (.dmark)  
2351 32 7a ee			ld (debug_mark),a  
2354 3a 63 23			ld a, (.dmark+1)  
2357 32 7b ee			ld (debug_mark+1),a  
235a 3a 64 23			ld a, (.dmark+2)  
235d 32 7c ee			ld (debug_mark+2),a  
2360 18 03			jr .pastdmark  
2362 ..			.dmark: db "-2s"  
2365 f1			.pastdmark: pop af  
2366			endm  
# End of macro DMARK
2366						CALLMONITOR 
2366 cd 8a 11			call break_point_state  
2369				endm  
# End of macro CALLMONITOR
2369					endif 
2369			 
2369					; Address 
2369			 
2369					FORTH_DSP_VALUEHL 
2369 cd af 17			call macro_dsp_valuehl 
236c				endm 
# End of macro FORTH_DSP_VALUEHL
236c			 
236c e5					push hl    ; save address 
236d			 
236d					; load content into de 
236d			 
236d 5e					ld e,(hl) 
236e 23					inc hl 
236f 56					ld d, (hl) 
2370			 
2370					if DEBUG_FORTH_WORDS 
2370						DMARK "-2a" 
2370						CALLMONITOR 
2370					endif 
2370			 
2370					FORTH_DSP_POP 
2370 cd 2f 18			call macro_forth_dsp_pop 
2373				endm 
# End of macro FORTH_DSP_POP
2373			 
2373					; Get value to remove 
2373			 
2373					FORTH_DSP_VALUE 
2373 cd 98 17			call macro_forth_dsp_value 
2376				endm 
# End of macro FORTH_DSP_VALUE
2376			 
2376					if DEBUG_FORTH_WORDS 
2376						DMARK "-2v" 
2376						CALLMONITOR 
2376					endif 
2376			 
2376 eb					ex de, hl 
2377 ed 52				sbc hl, de 
2379			 
2379					if DEBUG_FORTH_WORDS 
2379						DMARK "-2d" 
2379						CALLMONITOR 
2379					endif 
2379			 
2379					; move result to de 
2379			 
2379 eb					ex de, hl 
237a			 
237a					; Address 
237a			 
237a e1					pop hl 
237b			 
237b					; save it back 
237b			 
237b 73					ld (hl), e 
237c 23					inc hl 
237d 72					ld (hl), d 
237e			 
237e					if DEBUG_FORTH_WORDS 
237e						DMARK "-2e" 
237e						CALLMONITOR 
237e					endif 
237e			 
237e			 
237e			 
237e			 
237e			 
237e				       NEXTW 
237e c3 e9 18			jp macro_next 
2381				endm 
# End of macro NEXTW
2381			.GET2: 
2381				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2381 6f				db WORD_SYS_CORE+91             
2382 b1 23			dw .BANG2            
2384 03				db 2 + 1 
2385 .. 00			db "2@",0              
2388				endm 
# End of macro CWHEAD
2388			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2388					if DEBUG_FORTH_WORDS_KEY 
2388						DMARK "2A_" 
2388 f5				push af  
2389 3a 9d 23			ld a, (.dmark)  
238c 32 7a ee			ld (debug_mark),a  
238f 3a 9e 23			ld a, (.dmark+1)  
2392 32 7b ee			ld (debug_mark+1),a  
2395 3a 9f 23			ld a, (.dmark+2)  
2398 32 7c ee			ld (debug_mark+2),a  
239b 18 03			jr .pastdmark  
239d ..			.dmark: db "2A_"  
23a0 f1			.pastdmark: pop af  
23a1			endm  
# End of macro DMARK
23a1						CALLMONITOR 
23a1 cd 8a 11			call break_point_state  
23a4				endm  
# End of macro CALLMONITOR
23a4					endif 
23a4			 
23a4					FORTH_DSP_VALUEHL 
23a4 cd af 17			call macro_dsp_valuehl 
23a7				endm 
# End of macro FORTH_DSP_VALUEHL
23a7			 
23a7 5e					ld e, (hl) 
23a8 23					inc hl 
23a9 56					ld d, (hl) 
23aa			 
23aa eb					ex de, hl 
23ab			 
23ab cd 14 17				call forth_push_numhl 
23ae			 
23ae				       NEXTW 
23ae c3 e9 18			jp macro_next 
23b1				endm 
# End of macro NEXTW
23b1			.BANG2: 
23b1				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
23b1 6f				db WORD_SYS_CORE+91             
23b2 e9 23			dw .ENDCORE            
23b4 03				db 2 + 1 
23b5 .. 00			db "2!",0              
23b8				endm 
# End of macro CWHEAD
23b8			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
23b8					if DEBUG_FORTH_WORDS_KEY 
23b8						DMARK "2S_" 
23b8 f5				push af  
23b9 3a cd 23			ld a, (.dmark)  
23bc 32 7a ee			ld (debug_mark),a  
23bf 3a ce 23			ld a, (.dmark+1)  
23c2 32 7b ee			ld (debug_mark+1),a  
23c5 3a cf 23			ld a, (.dmark+2)  
23c8 32 7c ee			ld (debug_mark+2),a  
23cb 18 03			jr .pastdmark  
23cd ..			.dmark: db "2S_"  
23d0 f1			.pastdmark: pop af  
23d1			endm  
# End of macro DMARK
23d1						CALLMONITOR 
23d1 cd 8a 11			call break_point_state  
23d4				endm  
# End of macro CALLMONITOR
23d4					endif 
23d4			 
23d4					FORTH_DSP_VALUEHL 
23d4 cd af 17			call macro_dsp_valuehl 
23d7				endm 
# End of macro FORTH_DSP_VALUEHL
23d7			 
23d7 e5					push hl   ; save address 
23d8			 
23d8			 
23d8					FORTH_DSP_POP 
23d8 cd 2f 18			call macro_forth_dsp_pop 
23db				endm 
# End of macro FORTH_DSP_POP
23db			 
23db					 
23db					FORTH_DSP_VALUEHL 
23db cd af 17			call macro_dsp_valuehl 
23de				endm 
# End of macro FORTH_DSP_VALUEHL
23de			 
23de					FORTH_DSP_POP 
23de cd 2f 18			call macro_forth_dsp_pop 
23e1				endm 
# End of macro FORTH_DSP_POP
23e1			 
23e1 eb					ex de, hl    ; value now in de 
23e2			 
23e2 e1					pop hl 
23e3			 
23e3 73					ld (hl), e 
23e4			 
23e4 23					inc hl 
23e5			 
23e5 72					ld (hl), d 
23e6			 
23e6			 
23e6				       NEXTW 
23e6 c3 e9 18			jp macro_next 
23e9				endm 
# End of macro NEXTW
23e9			.ENDCORE: 
23e9			 
23e9			; eof 
23e9			 
23e9			 
# End of file forth_words_core.asm
23e9			include "forth_words_flow.asm" 
23e9			 
23e9			; | ## Program Flow Words 
23e9			 
23e9			.IF: 
23e9				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
23e9 1e				db WORD_SYS_CORE+10             
23ea 36 24			dw .THEN            
23ec 03				db 2 + 1 
23ed .. 00			db "IF",0              
23f0				endm 
# End of macro CWHEAD
23f0			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
23f0			; 
23f0					if DEBUG_FORTH_WORDS_KEY 
23f0						DMARK "IF." 
23f0 f5				push af  
23f1 3a 05 24			ld a, (.dmark)  
23f4 32 7a ee			ld (debug_mark),a  
23f7 3a 06 24			ld a, (.dmark+1)  
23fa 32 7b ee			ld (debug_mark+1),a  
23fd 3a 07 24			ld a, (.dmark+2)  
2400 32 7c ee			ld (debug_mark+2),a  
2403 18 03			jr .pastdmark  
2405 ..			.dmark: db "IF."  
2408 f1			.pastdmark: pop af  
2409			endm  
# End of macro DMARK
2409						CALLMONITOR 
2409 cd 8a 11			call break_point_state  
240c				endm  
# End of macro CALLMONITOR
240c					endif 
240c			; eval TOS 
240c			 
240c				FORTH_DSP_VALUEHL 
240c cd af 17			call macro_dsp_valuehl 
240f				endm 
# End of macro FORTH_DSP_VALUEHL
240f			 
240f			;	push hl 
240f				FORTH_DSP_POP 
240f cd 2f 18			call macro_forth_dsp_pop 
2412				endm 
# End of macro FORTH_DSP_POP
2412			;	pop hl 
2412			 
2412					if DEBUG_FORTH_WORDS 
2412						DMARK "IF1" 
2412						CALLMONITOR 
2412					endif 
2412 b7				or a        ; clear carry flag 
2413 11 00 00			ld de, 0 
2416 eb				ex de,hl 
2417 ed 52			sbc hl, de 
2419 c2 33 24			jp nz, .iftrue 
241c			 
241c					if DEBUG_FORTH_WORDS 
241c						DMARK "IF2" 
241c						CALLMONITOR 
241c					endif 
241c			 
241c			; if not true then skip to THEN 
241c			 
241c				; TODO get tok_ptr 
241c				; TODO consume toks until we get to THEN 
241c			 
241c 2a 76 e6			ld hl, (os_tok_ptr) 
241f					if DEBUG_FORTH_WORDS 
241f						DMARK "IF3" 
241f						CALLMONITOR 
241f						 
241f					endif 
241f 11 2e 24			ld de, .ifthen 
2422					if DEBUG_FORTH_WORDS 
2422						DMARK "IF4" 
2422						CALLMONITOR 
2422					endif 
2422 cd 04 1a			call findnexttok  
2425			 
2425					if DEBUG_FORTH_WORDS 
2425						DMARK "IF5" 
2425						CALLMONITOR 
2425					endif 
2425				; TODO replace below with ; exec using tok_ptr 
2425 22 76 e6			ld (os_tok_ptr), hl 
2428 c3 7a 19			jp exec1 
242b				NEXTW 
242b c3 e9 18			jp macro_next 
242e				endm 
# End of macro NEXTW
242e			 
242e .. 00		.ifthen:  db "THEN",0 
2433			 
2433			.iftrue:		 
2433				; Exec next words normally 
2433			 
2433				; if true then exec following IF as normal 
2433					if DEBUG_FORTH_WORDS 
2433						DMARK "IFT" 
2433						CALLMONITOR 
2433					endif 
2433			 
2433					NEXTW 
2433 c3 e9 18			jp macro_next 
2436				endm 
# End of macro NEXTW
2436			.THEN: 
2436				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2436 1f				db WORD_SYS_CORE+11             
2437 5e 24			dw .ELSE            
2439 05				db 4 + 1 
243a .. 00			db "THEN",0              
243f				endm 
# End of macro CWHEAD
243f			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
243f					if DEBUG_FORTH_WORDS_KEY 
243f						DMARK "THN" 
243f f5				push af  
2440 3a 54 24			ld a, (.dmark)  
2443 32 7a ee			ld (debug_mark),a  
2446 3a 55 24			ld a, (.dmark+1)  
2449 32 7b ee			ld (debug_mark+1),a  
244c 3a 56 24			ld a, (.dmark+2)  
244f 32 7c ee			ld (debug_mark+2),a  
2452 18 03			jr .pastdmark  
2454 ..			.dmark: db "THN"  
2457 f1			.pastdmark: pop af  
2458			endm  
# End of macro DMARK
2458						CALLMONITOR 
2458 cd 8a 11			call break_point_state  
245b				endm  
# End of macro CALLMONITOR
245b					endif 
245b					NEXTW 
245b c3 e9 18			jp macro_next 
245e				endm 
# End of macro NEXTW
245e			.ELSE: 
245e				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
245e 20				db WORD_SYS_CORE+12             
245f 86 24			dw .DO            
2461 03				db 2 + 1 
2462 .. 00			db "ELSE",0              
2467				endm 
# End of macro CWHEAD
2467			; | ELSE ( -- ) Not supported - does nothing | TODO 
2467			 
2467					if DEBUG_FORTH_WORDS_KEY 
2467						DMARK "ELS" 
2467 f5				push af  
2468 3a 7c 24			ld a, (.dmark)  
246b 32 7a ee			ld (debug_mark),a  
246e 3a 7d 24			ld a, (.dmark+1)  
2471 32 7b ee			ld (debug_mark+1),a  
2474 3a 7e 24			ld a, (.dmark+2)  
2477 32 7c ee			ld (debug_mark+2),a  
247a 18 03			jr .pastdmark  
247c ..			.dmark: db "ELS"  
247f f1			.pastdmark: pop af  
2480			endm  
# End of macro DMARK
2480						CALLMONITOR 
2480 cd 8a 11			call break_point_state  
2483				endm  
# End of macro CALLMONITOR
2483					endif 
2483			 
2483			 
2483					NEXTW 
2483 c3 e9 18			jp macro_next 
2486				endm 
# End of macro NEXTW
2486			.DO: 
2486				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2486 21				db WORD_SYS_CORE+13             
2487 cd 24			dw .LOOP            
2489 03				db 2 + 1 
248a .. 00			db "DO",0              
248d				endm 
# End of macro CWHEAD
248d			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
248d			 
248d					if DEBUG_FORTH_WORDS_KEY 
248d						DMARK "DO." 
248d f5				push af  
248e 3a a2 24			ld a, (.dmark)  
2491 32 7a ee			ld (debug_mark),a  
2494 3a a3 24			ld a, (.dmark+1)  
2497 32 7b ee			ld (debug_mark+1),a  
249a 3a a4 24			ld a, (.dmark+2)  
249d 32 7c ee			ld (debug_mark+2),a  
24a0 18 03			jr .pastdmark  
24a2 ..			.dmark: db "DO."  
24a5 f1			.pastdmark: pop af  
24a6			endm  
# End of macro DMARK
24a6						CALLMONITOR 
24a6 cd 8a 11			call break_point_state  
24a9				endm  
# End of macro CALLMONITOR
24a9					endif 
24a9			;  push pc to rsp stack past the DO 
24a9			 
24a9 2a 76 e6				ld hl, (os_tok_ptr) 
24ac 23					inc hl   ; D 
24ad 23					inc hl  ; O 
24ae 23					inc hl   ; null 
24af					if DEBUG_FORTH_WORDS 
24af						DMARK "DO2" 
24af						CALLMONITOR 
24af					endif 
24af					FORTH_RSP_NEXT 
24af cd be 16			call macro_forth_rsp_next 
24b2				endm 
# End of macro FORTH_RSP_NEXT
24b2					if DEBUG_FORTH_WORDS 
24b2						DMARK "DO3" 
24b2						CALLMONITOR 
24b2					endif 
24b2			 
24b2					;if DEBUG_FORTH_WORDS 
24b2				;		push hl 
24b2			;		endif  
24b2			 
24b2			; get counters from data stack 
24b2			 
24b2			 
24b2					FORTH_DSP_VALUEHL 
24b2 cd af 17			call macro_dsp_valuehl 
24b5				endm 
# End of macro FORTH_DSP_VALUEHL
24b5 e5					push hl		 ; hl now has starting counter which needs to be tos 
24b6			 
24b6					if DEBUG_FORTH_WORDS 
24b6						DMARK "DO4" 
24b6						CALLMONITOR 
24b6					endif 
24b6					FORTH_DSP_POP 
24b6 cd 2f 18			call macro_forth_dsp_pop 
24b9				endm 
# End of macro FORTH_DSP_POP
24b9			 
24b9					if DEBUG_FORTH_WORDS 
24b9						DMARK "DO5" 
24b9						CALLMONITOR 
24b9					endif 
24b9			 
24b9					FORTH_DSP_VALUEHL 
24b9 cd af 17			call macro_dsp_valuehl 
24bc				endm 
# End of macro FORTH_DSP_VALUEHL
24bc			;		push hl		 ; hl now has starting limit counter 
24bc			 
24bc					if DEBUG_FORTH_WORDS 
24bc						DMARK "DO6" 
24bc						CALLMONITOR 
24bc					endif 
24bc					FORTH_DSP_POP 
24bc cd 2f 18			call macro_forth_dsp_pop 
24bf				endm 
# End of macro FORTH_DSP_POP
24bf			 
24bf			; put counters on the loop stack 
24bf			 
24bf			;		pop hl			 ; limit counter 
24bf d1					pop de			; start counter 
24c0			 
24c0					; push limit counter 
24c0			 
24c0					if DEBUG_FORTH_WORDS 
24c0						DMARK "DO7" 
24c0						CALLMONITOR 
24c0					endif 
24c0					FORTH_LOOP_NEXT 
24c0 cd c4 17			call macro_forth_loop_next 
24c3				endm 
# End of macro FORTH_LOOP_NEXT
24c3			 
24c3					; push start counter 
24c3			 
24c3 eb					ex de, hl 
24c4					if DEBUG_FORTH_WORDS 
24c4						DMARK "DO7" 
24c4						CALLMONITOR 
24c4					endif 
24c4					FORTH_LOOP_NEXT 
24c4 cd c4 17			call macro_forth_loop_next 
24c7				endm 
# End of macro FORTH_LOOP_NEXT
24c7			 
24c7			 
24c7					; init first round of I counter 
24c7			 
24c7 22 9a e6				ld (os_current_i), hl 
24ca			 
24ca					if DEBUG_FORTH_WORDS 
24ca						DMARK "DO8" 
24ca						CALLMONITOR 
24ca					endif 
24ca			 
24ca					NEXTW 
24ca c3 e9 18			jp macro_next 
24cd				endm 
# End of macro NEXTW
24cd			.LOOP: 
24cd				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
24cd 22				db WORD_SYS_CORE+14             
24ce 20 25			dw .I            
24d0 05				db 4 + 1 
24d1 .. 00			db "LOOP",0              
24d6				endm 
# End of macro CWHEAD
24d6			; | LOOP ( -- ) Increment and test loop counter  | DONE 
24d6			 
24d6				; pop tos as current loop count to hl 
24d6			 
24d6				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
24d6			 
24d6				FORTH_LOOP_TOS 
24d6 cd db 17			call macro_forth_loop_tos 
24d9				endm 
# End of macro FORTH_LOOP_TOS
24d9 e5				push hl 
24da			 
24da					if DEBUG_FORTH_WORDS_KEY 
24da						DMARK "LOP" 
24da f5				push af  
24db 3a ef 24			ld a, (.dmark)  
24de 32 7a ee			ld (debug_mark),a  
24e1 3a f0 24			ld a, (.dmark+1)  
24e4 32 7b ee			ld (debug_mark+1),a  
24e7 3a f1 24			ld a, (.dmark+2)  
24ea 32 7c ee			ld (debug_mark+2),a  
24ed 18 03			jr .pastdmark  
24ef ..			.dmark: db "LOP"  
24f2 f1			.pastdmark: pop af  
24f3			endm  
# End of macro DMARK
24f3						CALLMONITOR 
24f3 cd 8a 11			call break_point_state  
24f6				endm  
# End of macro CALLMONITOR
24f6					endif 
24f6				; next item on the stack is the limit. get it 
24f6			 
24f6			 
24f6				FORTH_LOOP_POP 
24f6 cd e5 17			call macro_forth_loop_pop 
24f9				endm 
# End of macro FORTH_LOOP_POP
24f9			 
24f9				FORTH_LOOP_TOS 
24f9 cd db 17			call macro_forth_loop_tos 
24fc				endm 
# End of macro FORTH_LOOP_TOS
24fc			 
24fc d1				pop de		 ; de = i, hl = limit 
24fd			 
24fd					if DEBUG_FORTH_WORDS 
24fd						DMARK "LP1" 
24fd						CALLMONITOR 
24fd					endif 
24fd			 
24fd				; go back to previous word 
24fd			 
24fd d5				push de    ; save I for inc later 
24fe			 
24fe			 
24fe				; get limit 
24fe				;  is I at limit? 
24fe			 
24fe			 
24fe					if DEBUG_FORTH_WORDS 
24fe						DMARK "LP1" 
24fe						CALLMONITOR 
24fe					endif 
24fe			 
24fe ed 52			sbc hl, de 
2500			 
2500			 
2500				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2500			 
2500 20 0a				jr nz, .loopnotdone 
2502			 
2502 e1				pop hl   ; get rid of saved I 
2503				FORTH_LOOP_POP     ; get rid of limit 
2503 cd e5 17			call macro_forth_loop_pop 
2506				endm 
# End of macro FORTH_LOOP_POP
2506			 
2506				FORTH_RSP_POP     ; get rid of DO ptr 
2506 cd dc 16			call macro_forth_rsp_pop 
2509				endm 
# End of macro FORTH_RSP_POP
2509			 
2509			if DEBUG_FORTH_WORDS 
2509						DMARK "LP>" 
2509				CALLMONITOR 
2509			endif 
2509			 
2509					NEXTW 
2509 c3 e9 18			jp macro_next 
250c				endm 
# End of macro NEXTW
250c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
250c			 
250c			.loopnotdone: 
250c			 
250c e1				pop hl    ; get I 
250d 23				inc hl 
250e			 
250e			   	; save new I 
250e			 
250e			 
250e					; set I counter 
250e			 
250e 22 9a e6				ld (os_current_i), hl 
2511			 
2511					if DEBUG_FORTH_WORDS 
2511						DMARK "LPN" 
2511					CALLMONITOR 
2511					endif 
2511					 
2511				FORTH_LOOP_NEXT 
2511 cd c4 17			call macro_forth_loop_next 
2514				endm 
# End of macro FORTH_LOOP_NEXT
2514			 
2514			 
2514					if DEBUG_FORTH_WORDS 
2514						ex de,hl 
2514					endif 
2514			 
2514			;	; get DO ptr 
2514			; 
2514					if DEBUG_FORTH_WORDS 
2514						DMARK "LP7" 
2514					CALLMONITOR 
2514					endif 
2514				FORTH_RSP_TOS 
2514 cd d5 16			call macro_forth_rsp_tos 
2517				endm 
# End of macro FORTH_RSP_TOS
2517			 
2517					if DEBUG_FORTH_WORDS 
2517						DMARK "LP8" 
2517					CALLMONITOR 
2517					endif 
2517				;push hl 
2517			 
2517				; not going to DO any more 
2517				; get rid of the RSP pointer as DO will add it back in 
2517				;FORTH_RSP_POP 
2517				;pop hl 
2517			 
2517				;ld hl,(cli_ret_sp) 
2517				;ld e, (hl) 
2517				;inc hl 
2517				;ld d, (hl) 
2517				;ex de,hl 
2517 22 76 e6			ld (os_tok_ptr), hl 
251a					if DEBUG_FORTH_WORDS 
251a						DMARK "LP<" 
251a					CALLMONITOR 
251a				endif 
251a c3 7a 19			jp exec1 
251d			 
251d					 
251d			 
251d			 
251d					NEXTW 
251d c3 e9 18			jp macro_next 
2520				endm 
# End of macro NEXTW
2520			.I:  
2520			 
2520				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2520 5e				db WORD_SYS_CORE+74             
2521 4b 25			dw .DLOOP            
2523 02				db 1 + 1 
2524 .. 00			db "I",0              
2526				endm 
# End of macro CWHEAD
2526			; | I ( -- ) Current loop counter | DONE 
2526					if DEBUG_FORTH_WORDS_KEY 
2526						DMARK "I.." 
2526 f5				push af  
2527 3a 3b 25			ld a, (.dmark)  
252a 32 7a ee			ld (debug_mark),a  
252d 3a 3c 25			ld a, (.dmark+1)  
2530 32 7b ee			ld (debug_mark+1),a  
2533 3a 3d 25			ld a, (.dmark+2)  
2536 32 7c ee			ld (debug_mark+2),a  
2539 18 03			jr .pastdmark  
253b ..			.dmark: db "I.."  
253e f1			.pastdmark: pop af  
253f			endm  
# End of macro DMARK
253f						CALLMONITOR 
253f cd 8a 11			call break_point_state  
2542				endm  
# End of macro CALLMONITOR
2542					endif 
2542			 
2542 2a 9a e6				ld hl,(os_current_i) 
2545 cd 14 17				call forth_push_numhl 
2548			 
2548					NEXTW 
2548 c3 e9 18			jp macro_next 
254b				endm 
# End of macro NEXTW
254b			.DLOOP: 
254b				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
254b 5f				db WORD_SYS_CORE+75             
254c 9f 25			dw .REPEAT            
254e 06				db 5 + 1 
254f .. 00			db "-LOOP",0              
2555				endm 
# End of macro CWHEAD
2555			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2555				; pop tos as current loop count to hl 
2555					if DEBUG_FORTH_WORDS_KEY 
2555						DMARK "-LP" 
2555 f5				push af  
2556 3a 6a 25			ld a, (.dmark)  
2559 32 7a ee			ld (debug_mark),a  
255c 3a 6b 25			ld a, (.dmark+1)  
255f 32 7b ee			ld (debug_mark+1),a  
2562 3a 6c 25			ld a, (.dmark+2)  
2565 32 7c ee			ld (debug_mark+2),a  
2568 18 03			jr .pastdmark  
256a ..			.dmark: db "-LP"  
256d f1			.pastdmark: pop af  
256e			endm  
# End of macro DMARK
256e						CALLMONITOR 
256e cd 8a 11			call break_point_state  
2571				endm  
# End of macro CALLMONITOR
2571					endif 
2571			 
2571				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2571			 
2571				FORTH_LOOP_TOS 
2571 cd db 17			call macro_forth_loop_tos 
2574				endm 
# End of macro FORTH_LOOP_TOS
2574 e5				push hl 
2575			 
2575					if DEBUG_FORTH_WORDS 
2575						DMARK "-LP" 
2575						CALLMONITOR 
2575					endif 
2575				; next item on the stack is the limit. get it 
2575			 
2575			 
2575				FORTH_LOOP_POP 
2575 cd e5 17			call macro_forth_loop_pop 
2578				endm 
# End of macro FORTH_LOOP_POP
2578			 
2578				FORTH_LOOP_TOS 
2578 cd db 17			call macro_forth_loop_tos 
257b				endm 
# End of macro FORTH_LOOP_TOS
257b			 
257b d1				pop de		 ; de = i, hl = limit 
257c			 
257c					if DEBUG_FORTH_WORDS 
257c						DMARK "-L1" 
257c						CALLMONITOR 
257c					endif 
257c			 
257c				; go back to previous word 
257c			 
257c d5				push de    ; save I for inc later 
257d			 
257d			 
257d				; get limit 
257d				;  is I at limit? 
257d			 
257d			 
257d					if DEBUG_FORTH_WORDS 
257d						DMARK "-L1" 
257d						CALLMONITOR 
257d					endif 
257d			 
257d ed 52			sbc hl, de 
257f			 
257f			 
257f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
257f			 
257f 20 0a				jr nz, .mloopnotdone 
2581			 
2581 e1				pop hl   ; get rid of saved I 
2582				FORTH_LOOP_POP     ; get rid of limit 
2582 cd e5 17			call macro_forth_loop_pop 
2585				endm 
# End of macro FORTH_LOOP_POP
2585			 
2585				FORTH_RSP_POP     ; get rid of DO ptr 
2585 cd dc 16			call macro_forth_rsp_pop 
2588				endm 
# End of macro FORTH_RSP_POP
2588			 
2588			if DEBUG_FORTH_WORDS 
2588						DMARK "-L>" 
2588				CALLMONITOR 
2588			endif 
2588			 
2588					NEXTW 
2588 c3 e9 18			jp macro_next 
258b				endm 
# End of macro NEXTW
258b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
258b			 
258b			.mloopnotdone: 
258b			 
258b e1				pop hl    ; get I 
258c 2b				dec hl 
258d			 
258d			   	; save new I 
258d			 
258d			 
258d					; set I counter 
258d			 
258d 22 9a e6				ld (os_current_i), hl 
2590			 
2590					 
2590				FORTH_LOOP_NEXT 
2590 cd c4 17			call macro_forth_loop_next 
2593				endm 
# End of macro FORTH_LOOP_NEXT
2593			 
2593			 
2593					if DEBUG_FORTH_WORDS 
2593						ex de,hl 
2593					endif 
2593			 
2593			;	; get DO ptr 
2593			; 
2593				FORTH_RSP_TOS 
2593 cd d5 16			call macro_forth_rsp_tos 
2596				endm 
# End of macro FORTH_RSP_TOS
2596			 
2596				;push hl 
2596			 
2596				; not going to DO any more 
2596				; get rid of the RSP pointer as DO will add it back in 
2596				;FORTH_RSP_POP 
2596				;pop hl 
2596			 
2596			 
2596 22 76 e6			ld (os_tok_ptr), hl 
2599					if DEBUG_FORTH_WORDS 
2599						DMARK "-L<" 
2599					CALLMONITOR 
2599				endif 
2599 c3 7a 19			jp exec1 
259c			 
259c					 
259c			 
259c			 
259c			 
259c				NEXTW 
259c c3 e9 18			jp macro_next 
259f				endm 
# End of macro NEXTW
259f			 
259f			 
259f			 
259f			 
259f			.REPEAT: 
259f				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
259f 71				db WORD_SYS_CORE+93             
25a0 d6 25			dw .UNTIL            
25a2 06				db 5 + 1 
25a3 .. 00			db "REPEAT",0              
25aa				endm 
# End of macro CWHEAD
25aa			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
25aa			;  push pc to rsp stack past the REPEAT 
25aa					if DEBUG_FORTH_WORDS_KEY 
25aa						DMARK "REP" 
25aa f5				push af  
25ab 3a bf 25			ld a, (.dmark)  
25ae 32 7a ee			ld (debug_mark),a  
25b1 3a c0 25			ld a, (.dmark+1)  
25b4 32 7b ee			ld (debug_mark+1),a  
25b7 3a c1 25			ld a, (.dmark+2)  
25ba 32 7c ee			ld (debug_mark+2),a  
25bd 18 03			jr .pastdmark  
25bf ..			.dmark: db "REP"  
25c2 f1			.pastdmark: pop af  
25c3			endm  
# End of macro DMARK
25c3						CALLMONITOR 
25c3 cd 8a 11			call break_point_state  
25c6				endm  
# End of macro CALLMONITOR
25c6					endif 
25c6			 
25c6 2a 76 e6				ld hl, (os_tok_ptr) 
25c9 23					inc hl   ; R 
25ca 23					inc hl  ; E 
25cb 23					inc hl   ; P 
25cc 23					inc hl   ; E 
25cd 23					inc hl   ; A 
25ce 23					inc hl   ; T 
25cf 23					inc hl   ; zero 
25d0					FORTH_RSP_NEXT 
25d0 cd be 16			call macro_forth_rsp_next 
25d3				endm 
# End of macro FORTH_RSP_NEXT
25d3			 
25d3			 
25d3					if DEBUG_FORTH_WORDS 
25d3						DMARK "REP" 
25d3						;pop bc    ; TODO BUG ?????? what is this for???? 
25d3						CALLMONITOR 
25d3					endif 
25d3			 
25d3					NEXTW 
25d3 c3 e9 18			jp macro_next 
25d6				endm 
# End of macro NEXTW
25d6			;	       NEXTW 
25d6			 
25d6			.UNTIL: 
25d6				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
25d6 72				db WORD_SYS_CORE+94             
25d7 19 26			dw .ENDFLOW            
25d9 06				db 5 + 1 
25da .. 00			db "UNTIL",0              
25e0				endm 
# End of macro CWHEAD
25e0			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
25e0			 
25e0				; pop tos as check 
25e0			 
25e0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
25e0			 
25e0				FORTH_DSP_VALUEHL 
25e0 cd af 17			call macro_dsp_valuehl 
25e3				endm 
# End of macro FORTH_DSP_VALUEHL
25e3			 
25e3					if DEBUG_FORTH_WORDS_KEY 
25e3						DMARK "UNT" 
25e3 f5				push af  
25e4 3a f8 25			ld a, (.dmark)  
25e7 32 7a ee			ld (debug_mark),a  
25ea 3a f9 25			ld a, (.dmark+1)  
25ed 32 7b ee			ld (debug_mark+1),a  
25f0 3a fa 25			ld a, (.dmark+2)  
25f3 32 7c ee			ld (debug_mark+2),a  
25f6 18 03			jr .pastdmark  
25f8 ..			.dmark: db "UNT"  
25fb f1			.pastdmark: pop af  
25fc			endm  
# End of macro DMARK
25fc						CALLMONITOR 
25fc cd 8a 11			call break_point_state  
25ff				endm  
# End of macro CALLMONITOR
25ff					endif 
25ff			 
25ff			;	push hl 
25ff				FORTH_DSP_POP 
25ff cd 2f 18			call macro_forth_dsp_pop 
2602				endm 
# End of macro FORTH_DSP_POP
2602			 
2602			;	pop hl 
2602			 
2602				; test if true 
2602			 
2602 cd ef 09			call ishlzero 
2605			;	ld a,l 
2605			;	add h 
2605			; 
2605			;	cp 0 
2605			 
2605 20 06			jr nz, .untilnotdone 
2607			 
2607					if DEBUG_FORTH_WORDS 
2607						DMARK "UNf" 
2607						CALLMONITOR 
2607					endif 
2607			 
2607			 
2607			 
2607				FORTH_RSP_POP     ; get rid of DO ptr 
2607 cd dc 16			call macro_forth_rsp_pop 
260a				endm 
# End of macro FORTH_RSP_POP
260a			 
260a			if DEBUG_FORTH_WORDS 
260a						DMARK "UN>" 
260a				CALLMONITOR 
260a			endif 
260a			 
260a					NEXTW 
260a c3 e9 18			jp macro_next 
260d				endm 
# End of macro NEXTW
260d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
260d			 
260d			.untilnotdone: 
260d			 
260d			 
260d			;	; get DO ptr 
260d			; 
260d				FORTH_RSP_TOS 
260d cd d5 16			call macro_forth_rsp_tos 
2610				endm 
# End of macro FORTH_RSP_TOS
2610			 
2610				;push hl 
2610			 
2610				; not going to DO any more 
2610				; get rid of the RSP pointer as DO will add it back in 
2610				;FORTH_RSP_POP 
2610				;pop hl 
2610			 
2610			 
2610 22 76 e6			ld (os_tok_ptr), hl 
2613					if DEBUG_FORTH_WORDS 
2613						DMARK "UN<" 
2613					CALLMONITOR 
2613				endif 
2613 c3 7a 19			jp exec1 
2616			 
2616					 
2616			 
2616			 
2616					NEXTW 
2616 c3 e9 18			jp macro_next 
2619				endm 
# End of macro NEXTW
2619			 
2619			 
2619			.ENDFLOW: 
2619			 
2619			; eof 
2619			 
# End of file forth_words_flow.asm
2619			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
2619			include "forth_words_logic.asm" 
2619			 
2619			; | ## Logic Words 
2619			 
2619			.NOT: 
2619				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
2619 2d				db WORD_SYS_CORE+25             
261a 61 26			dw .IS            
261c 04				db 3 + 1 
261d .. 00			db "NOT",0              
2621				endm 
# End of macro CWHEAD
2621			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
2621					if DEBUG_FORTH_WORDS_KEY 
2621						DMARK "NOT" 
2621 f5				push af  
2622 3a 36 26			ld a, (.dmark)  
2625 32 7a ee			ld (debug_mark),a  
2628 3a 37 26			ld a, (.dmark+1)  
262b 32 7b ee			ld (debug_mark+1),a  
262e 3a 38 26			ld a, (.dmark+2)  
2631 32 7c ee			ld (debug_mark+2),a  
2634 18 03			jr .pastdmark  
2636 ..			.dmark: db "NOT"  
2639 f1			.pastdmark: pop af  
263a			endm  
# End of macro DMARK
263a						CALLMONITOR 
263a cd 8a 11			call break_point_state  
263d				endm  
# End of macro CALLMONITOR
263d					endif 
263d					FORTH_DSP 
263d cd 94 17			call macro_forth_dsp 
2640				endm 
# End of macro FORTH_DSP
2640 7e					ld a,(hl)	; get type of value on TOS 
2641 fe 02				cp DS_TYPE_INUM  
2643 28 03				jr z, .noti 
2645					NEXTW 
2645 c3 e9 18			jp macro_next 
2648				endm 
# End of macro NEXTW
2648			.noti:          FORTH_DSP_VALUEHL 
2648 cd af 17			call macro_dsp_valuehl 
264b				endm 
# End of macro FORTH_DSP_VALUEHL
264b			;		push hl 
264b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
264b cd 2f 18			call macro_forth_dsp_pop 
264e				endm 
# End of macro FORTH_DSP_POP
264e			;		pop hl 
264e 3e 00				ld a,0 
2650 bd					cp l 
2651 28 04				jr z, .not2t 
2653 2e 00				ld l, 0 
2655 18 02				jr .notip 
2657			 
2657 2e ff		.not2t:		ld l, 255 
2659			 
2659 26 00		.notip:		ld h, 0	 
265b			 
265b cd 14 17				call forth_push_numhl 
265e					NEXTW 
265e c3 e9 18			jp macro_next 
2661				endm 
# End of macro NEXTW
2661			 
2661			.IS: 
2661				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
2661 2d				db WORD_SYS_CORE+25             
2662 87 26			dw .LZERO            
2664 03				db 2 + 1 
2665 .. 00			db "IS",0              
2668				endm 
# End of macro CWHEAD
2668			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
2668					if DEBUG_FORTH_WORDS_KEY 
2668						DMARK "IS." 
2668 f5				push af  
2669 3a 7d 26			ld a, (.dmark)  
266c 32 7a ee			ld (debug_mark),a  
266f 3a 7e 26			ld a, (.dmark+1)  
2672 32 7b ee			ld (debug_mark+1),a  
2675 3a 7f 26			ld a, (.dmark+2)  
2678 32 7c ee			ld (debug_mark+2),a  
267b 18 03			jr .pastdmark  
267d ..			.dmark: db "IS."  
2680 f1			.pastdmark: pop af  
2681			endm  
# End of macro DMARK
2681						CALLMONITOR 
2681 cd 8a 11			call break_point_state  
2684				endm  
# End of macro CALLMONITOR
2684					endif 
2684					NEXTW 
2684 c3 e9 18			jp macro_next 
2687				endm 
# End of macro NEXTW
2687			.LZERO: 
2687				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
2687 2d				db WORD_SYS_CORE+25             
2688 91 26			dw .TZERO            
268a 03				db 2 + 1 
268b .. 00			db "0<",0              
268e				endm 
# End of macro CWHEAD
268e			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
268e					NEXTW 
268e c3 e9 18			jp macro_next 
2691				endm 
# End of macro NEXTW
2691			.TZERO: 
2691				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
2691 2e				db WORD_SYS_CORE+26             
2692 d8 26			dw .LESS            
2694 03				db 2 + 1 
2695 .. 00			db "0=",0              
2698				endm 
# End of macro CWHEAD
2698			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
2698				; TODO add floating point number detection 
2698					;v5 FORTH_DSP_VALUE 
2698					if DEBUG_FORTH_WORDS_KEY 
2698						DMARK "0=." 
2698 f5				push af  
2699 3a ad 26			ld a, (.dmark)  
269c 32 7a ee			ld (debug_mark),a  
269f 3a ae 26			ld a, (.dmark+1)  
26a2 32 7b ee			ld (debug_mark+1),a  
26a5 3a af 26			ld a, (.dmark+2)  
26a8 32 7c ee			ld (debug_mark+2),a  
26ab 18 03			jr .pastdmark  
26ad ..			.dmark: db "0=."  
26b0 f1			.pastdmark: pop af  
26b1			endm  
# End of macro DMARK
26b1						CALLMONITOR 
26b1 cd 8a 11			call break_point_state  
26b4				endm  
# End of macro CALLMONITOR
26b4					endif 
26b4					FORTH_DSP 
26b4 cd 94 17			call macro_forth_dsp 
26b7				endm 
# End of macro FORTH_DSP
26b7 7e					ld a,(hl)	; get type of value on TOS 
26b8 fe 02				cp DS_TYPE_INUM  
26ba 28 00				jr z, .tz_inum 
26bc			 
26bc				if FORTH_ENABLE_FLOATMATH 
26bc					jr .tz_done 
26bc			 
26bc				endif 
26bc					 
26bc			 
26bc			.tz_inum: 
26bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26bc cd af 17			call macro_dsp_valuehl 
26bf				endm 
# End of macro FORTH_DSP_VALUEHL
26bf			 
26bf			;		push hl 
26bf			 
26bf					; destroy value TOS 
26bf			 
26bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26bf cd 2f 18			call macro_forth_dsp_pop 
26c2				endm 
# End of macro FORTH_DSP_POP
26c2			 
26c2			;		pop hl 
26c2			 
26c2 3e 00				ld a,0 
26c4			 
26c4 bd					cp l 
26c5 20 08				jr nz, .tz_notzero 
26c7			 
26c7 bc					cp h 
26c8			 
26c8 20 05				jr nz, .tz_notzero 
26ca			 
26ca			 
26ca 21 01 00				ld hl, FORTH_TRUE 
26cd 18 03				jr .tz_done 
26cf			 
26cf 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
26d2			 
26d2					; push value back onto stack for another op etc 
26d2			 
26d2			.tz_done: 
26d2 cd 14 17				call forth_push_numhl 
26d5			 
26d5					NEXTW 
26d5 c3 e9 18			jp macro_next 
26d8				endm 
# End of macro NEXTW
26d8			.LESS: 
26d8				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
26d8 2f				db WORD_SYS_CORE+27             
26d9 25 27			dw .GT            
26db 02				db 1 + 1 
26dc .. 00			db "<",0              
26de				endm 
# End of macro CWHEAD
26de			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
26de				; TODO add floating point number detection 
26de					if DEBUG_FORTH_WORDS_KEY 
26de						DMARK "LES" 
26de f5				push af  
26df 3a f3 26			ld a, (.dmark)  
26e2 32 7a ee			ld (debug_mark),a  
26e5 3a f4 26			ld a, (.dmark+1)  
26e8 32 7b ee			ld (debug_mark+1),a  
26eb 3a f5 26			ld a, (.dmark+2)  
26ee 32 7c ee			ld (debug_mark+2),a  
26f1 18 03			jr .pastdmark  
26f3 ..			.dmark: db "LES"  
26f6 f1			.pastdmark: pop af  
26f7			endm  
# End of macro DMARK
26f7						CALLMONITOR 
26f7 cd 8a 11			call break_point_state  
26fa				endm  
# End of macro CALLMONITOR
26fa					endif 
26fa					FORTH_DSP 
26fa cd 94 17			call macro_forth_dsp 
26fd				endm 
# End of macro FORTH_DSP
26fd					;v5 FORTH_DSP_VALUE 
26fd 7e					ld a,(hl)	; get type of value on TOS 
26fe fe 02				cp DS_TYPE_INUM  
2700 28 00				jr z, .less_inum 
2702			 
2702				if FORTH_ENABLE_FLOATMATH 
2702					jr .less_done 
2702			 
2702				endif 
2702					 
2702			 
2702			.less_inum: 
2702					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2702 cd af 17			call macro_dsp_valuehl 
2705				endm 
# End of macro FORTH_DSP_VALUEHL
2705			 
2705 e5					push hl  ; u2 
2706			 
2706					; destroy value TOS 
2706			 
2706					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2706 cd 2f 18			call macro_forth_dsp_pop 
2709				endm 
# End of macro FORTH_DSP_POP
2709			 
2709			 
2709					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2709 cd af 17			call macro_dsp_valuehl 
270c				endm 
# End of macro FORTH_DSP_VALUEHL
270c			 
270c e5					push hl    ; u1 
270d			 
270d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
270d cd 2f 18			call macro_forth_dsp_pop 
2710				endm 
# End of macro FORTH_DSP_POP
2710			 
2710			 
2710 b7			 or a      ;clear carry flag 
2711 01 00 00		 ld bc, FORTH_FALSE 
2714 e1			  pop hl    ; u1 
2715 d1			  pop de    ; u2 
2716 ed 52		  sbc hl,de 
2718 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
271a			 
271a 01 01 00		 ld bc, FORTH_TRUE 
271d			.lscont:  
271d c5					push bc 
271e e1					pop hl 
271f			 
271f					if DEBUG_FORTH_WORDS 
271f						DMARK "LT1" 
271f						CALLMONITOR 
271f					endif 
271f cd 14 17				call forth_push_numhl 
2722			 
2722					NEXTW 
2722 c3 e9 18			jp macro_next 
2725				endm 
# End of macro NEXTW
2725			.GT: 
2725				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
2725 30				db WORD_SYS_CORE+28             
2726 72 27			dw .EQUAL            
2728 02				db 1 + 1 
2729 .. 00			db ">",0              
272b				endm 
# End of macro CWHEAD
272b			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
272b				; TODO add floating point number detection 
272b					if DEBUG_FORTH_WORDS_KEY 
272b						DMARK "GRT" 
272b f5				push af  
272c 3a 40 27			ld a, (.dmark)  
272f 32 7a ee			ld (debug_mark),a  
2732 3a 41 27			ld a, (.dmark+1)  
2735 32 7b ee			ld (debug_mark+1),a  
2738 3a 42 27			ld a, (.dmark+2)  
273b 32 7c ee			ld (debug_mark+2),a  
273e 18 03			jr .pastdmark  
2740 ..			.dmark: db "GRT"  
2743 f1			.pastdmark: pop af  
2744			endm  
# End of macro DMARK
2744						CALLMONITOR 
2744 cd 8a 11			call break_point_state  
2747				endm  
# End of macro CALLMONITOR
2747					endif 
2747					FORTH_DSP 
2747 cd 94 17			call macro_forth_dsp 
274a				endm 
# End of macro FORTH_DSP
274a					;FORTH_DSP_VALUE 
274a 7e					ld a,(hl)	; get type of value on TOS 
274b fe 02				cp DS_TYPE_INUM  
274d 28 00				jr z, .gt_inum 
274f			 
274f				if FORTH_ENABLE_FLOATMATH 
274f					jr .gt_done 
274f			 
274f				endif 
274f					 
274f			 
274f			.gt_inum: 
274f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
274f cd af 17			call macro_dsp_valuehl 
2752				endm 
# End of macro FORTH_DSP_VALUEHL
2752			 
2752 e5					push hl  ; u2 
2753			 
2753					; destroy value TOS 
2753			 
2753					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2753 cd 2f 18			call macro_forth_dsp_pop 
2756				endm 
# End of macro FORTH_DSP_POP
2756			 
2756			 
2756					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2756 cd af 17			call macro_dsp_valuehl 
2759				endm 
# End of macro FORTH_DSP_VALUEHL
2759			 
2759 e5					push hl    ; u1 
275a			 
275a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
275a cd 2f 18			call macro_forth_dsp_pop 
275d				endm 
# End of macro FORTH_DSP_POP
275d			 
275d			 
275d b7			 or a      ;clear carry flag 
275e 01 00 00		 ld bc, FORTH_FALSE 
2761 e1			  pop hl    ; u1 
2762 d1			  pop de    ; u2 
2763 ed 52		  sbc hl,de 
2765 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
2767			 
2767 01 01 00		 ld bc, FORTH_TRUE 
276a			.gtcont:  
276a c5					push bc 
276b e1					pop hl 
276c			 
276c					if DEBUG_FORTH_WORDS 
276c						DMARK "GT1" 
276c						CALLMONITOR 
276c					endif 
276c cd 14 17				call forth_push_numhl 
276f			 
276f					NEXTW 
276f c3 e9 18			jp macro_next 
2772				endm 
# End of macro NEXTW
2772			.EQUAL: 
2772				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
2772 31				db WORD_SYS_CORE+29             
2773 c1 27			dw .ENDLOGIC            
2775 02				db 1 + 1 
2776 .. 00			db "=",0              
2778				endm 
# End of macro CWHEAD
2778			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
2778				; TODO add floating point number detection 
2778					if DEBUG_FORTH_WORDS_KEY 
2778						DMARK "EQ." 
2778 f5				push af  
2779 3a 8d 27			ld a, (.dmark)  
277c 32 7a ee			ld (debug_mark),a  
277f 3a 8e 27			ld a, (.dmark+1)  
2782 32 7b ee			ld (debug_mark+1),a  
2785 3a 8f 27			ld a, (.dmark+2)  
2788 32 7c ee			ld (debug_mark+2),a  
278b 18 03			jr .pastdmark  
278d ..			.dmark: db "EQ."  
2790 f1			.pastdmark: pop af  
2791			endm  
# End of macro DMARK
2791						CALLMONITOR 
2791 cd 8a 11			call break_point_state  
2794				endm  
# End of macro CALLMONITOR
2794					endif 
2794					FORTH_DSP 
2794 cd 94 17			call macro_forth_dsp 
2797				endm 
# End of macro FORTH_DSP
2797					;v5 FORTH_DSP_VALUE 
2797 7e					ld a,(hl)	; get type of value on TOS 
2798 fe 02				cp DS_TYPE_INUM  
279a 28 00				jr z, .eq_inum 
279c			 
279c				if FORTH_ENABLE_FLOATMATH 
279c					jr .eq_done 
279c			 
279c				endif 
279c					 
279c			 
279c			.eq_inum: 
279c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
279c cd af 17			call macro_dsp_valuehl 
279f				endm 
# End of macro FORTH_DSP_VALUEHL
279f			 
279f e5					push hl 
27a0			 
27a0					; destroy value TOS 
27a0			 
27a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27a0 cd 2f 18			call macro_forth_dsp_pop 
27a3				endm 
# End of macro FORTH_DSP_POP
27a3			 
27a3			 
27a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27a3 cd af 17			call macro_dsp_valuehl 
27a6				endm 
# End of macro FORTH_DSP_VALUEHL
27a6			 
27a6					; one value on hl get other one back 
27a6			 
27a6 e5					push hl 
27a7			 
27a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27a7 cd 2f 18			call macro_forth_dsp_pop 
27aa				endm 
# End of macro FORTH_DSP_POP
27aa			 
27aa 0e 00				ld c, FORTH_FALSE 
27ac			 
27ac e1					pop hl 
27ad d1					pop de 
27ae			 
27ae 7b					ld a, e 
27af bd					cp l 
27b0			 
27b0 20 06				jr nz, .eq_done 
27b2			 
27b2 7a					ld a, d 
27b3 bc					cp h 
27b4			 
27b4 20 02				jr nz, .eq_done 
27b6			 
27b6 0e 01				ld c, FORTH_TRUE 
27b8					 
27b8			 
27b8			 
27b8			.eq_done: 
27b8			 
27b8					; TODO push value back onto stack for another op etc 
27b8			 
27b8 26 00				ld h, 0 
27ba 69					ld l, c 
27bb					if DEBUG_FORTH_WORDS 
27bb						DMARK "EQ1" 
27bb						CALLMONITOR 
27bb					endif 
27bb cd 14 17				call forth_push_numhl 
27be			 
27be					NEXTW 
27be c3 e9 18			jp macro_next 
27c1				endm 
# End of macro NEXTW
27c1			 
27c1			 
27c1			.ENDLOGIC: 
27c1			; eof 
27c1			 
27c1			 
# End of file forth_words_logic.asm
27c1			include "forth_words_maths.asm" 
27c1			 
27c1			; | ## Maths Words 
27c1			 
27c1			.PLUS:	 
27c1				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
27c1 15				db WORD_SYS_CORE+1             
27c2 03 28			dw .NEG            
27c4 02				db 1 + 1 
27c5 .. 00			db "+",0              
27c7				endm 
# End of macro CWHEAD
27c7			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
27c7					if DEBUG_FORTH_WORDS_KEY 
27c7						DMARK "PLU" 
27c7 f5				push af  
27c8 3a dc 27			ld a, (.dmark)  
27cb 32 7a ee			ld (debug_mark),a  
27ce 3a dd 27			ld a, (.dmark+1)  
27d1 32 7b ee			ld (debug_mark+1),a  
27d4 3a de 27			ld a, (.dmark+2)  
27d7 32 7c ee			ld (debug_mark+2),a  
27da 18 03			jr .pastdmark  
27dc ..			.dmark: db "PLU"  
27df f1			.pastdmark: pop af  
27e0			endm  
# End of macro DMARK
27e0						CALLMONITOR 
27e0 cd 8a 11			call break_point_state  
27e3				endm  
# End of macro CALLMONITOR
27e3					endif 
27e3					; add top two values and push back result 
27e3			 
27e3					;for v5 FORTH_DSP_VALUE 
27e3					FORTH_DSP 
27e3 cd 94 17			call macro_forth_dsp 
27e6				endm 
# End of macro FORTH_DSP
27e6 7e					ld a,(hl)	; get type of value on TOS 
27e7 fe 02				cp DS_TYPE_INUM  
27e9 28 03				jr z, .dot_inum 
27eb			 
27eb					NEXTW 
27eb c3 e9 18			jp macro_next 
27ee				endm 
# End of macro NEXTW
27ee			 
27ee			; float maths 
27ee			 
27ee				if FORTH_ENABLE_FLOATMATH 
27ee						inc hl      ; now at start of numeric as string 
27ee			 
27ee					if DEBUG_FORTH_MATHS 
27ee						DMARK "ADD" 
27ee				CALLMONITOR 
27ee					endif 
27ee			 
27ee					;ld ix, hl 
27ee					call CON 
27ee			 
27ee			 
27ee					push hl 
27ee					 
27ee					 
27ee			 
27ee						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
27ee			 
27ee					; get next number 
27ee			 
27ee						FORTH_DSP_VALUE 
27ee			 
27ee						inc hl      ; now at start of numeric as string 
27ee			 
27ee					;ld ix, hl 
27ee					call CON 
27ee			 
27ee					push hl 
27ee			 
27ee			 
27ee						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27ee			 
27ee						; TODO do add 
27ee			 
27ee						call IADD 
27ee			 
27ee						; TODO get result back as ascii 
27ee			 
27ee						; TODO push result  
27ee			 
27ee			 
27ee			 
27ee						jr .dot_done 
27ee				endif 
27ee			 
27ee			.dot_inum: 
27ee			 
27ee			 
27ee					if DEBUG_FORTH_DOT 
27ee						DMARK "+IT" 
27ee				CALLMONITOR 
27ee					endif 
27ee			 
27ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27ee cd af 17			call macro_dsp_valuehl 
27f1				endm 
# End of macro FORTH_DSP_VALUEHL
27f1			 
27f1				; TODO add floating point number detection 
27f1			 
27f1 e5					push hl 
27f2			 
27f2					; destroy value TOS 
27f2			 
27f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27f2 cd 2f 18			call macro_forth_dsp_pop 
27f5				endm 
# End of macro FORTH_DSP_POP
27f5			 
27f5			 
27f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27f5 cd af 17			call macro_dsp_valuehl 
27f8				endm 
# End of macro FORTH_DSP_VALUEHL
27f8			 
27f8					; one value on hl get other one back 
27f8			 
27f8 d1					pop de 
27f9			 
27f9					; do the add 
27f9			 
27f9 19					add hl,de 
27fa			 
27fa					; save it 
27fa			 
27fa			;		push hl	 
27fa			 
27fa					; 
27fa			 
27fa					; destroy value TOS 
27fa			 
27fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27fa cd 2f 18			call macro_forth_dsp_pop 
27fd				endm 
# End of macro FORTH_DSP_POP
27fd			 
27fd					; TODO push value back onto stack for another op etc 
27fd			 
27fd			;		pop hl 
27fd			 
27fd			.dot_done: 
27fd cd 14 17				call forth_push_numhl 
2800			 
2800					NEXTW 
2800 c3 e9 18			jp macro_next 
2803				endm 
# End of macro NEXTW
2803			.NEG: 
2803			 
2803				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
2803 17				db WORD_SYS_CORE+3             
2804 46 28			dw .DIV            
2806 02				db 1 + 1 
2807 .. 00			db "-",0              
2809				endm 
# End of macro CWHEAD
2809			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
2809					if DEBUG_FORTH_WORDS_KEY 
2809						DMARK "SUB" 
2809 f5				push af  
280a 3a 1e 28			ld a, (.dmark)  
280d 32 7a ee			ld (debug_mark),a  
2810 3a 1f 28			ld a, (.dmark+1)  
2813 32 7b ee			ld (debug_mark+1),a  
2816 3a 20 28			ld a, (.dmark+2)  
2819 32 7c ee			ld (debug_mark+2),a  
281c 18 03			jr .pastdmark  
281e ..			.dmark: db "SUB"  
2821 f1			.pastdmark: pop af  
2822			endm  
# End of macro DMARK
2822						CALLMONITOR 
2822 cd 8a 11			call break_point_state  
2825				endm  
# End of macro CALLMONITOR
2825					endif 
2825			 
2825			 
2825				; TODO add floating point number detection 
2825					; v5 FORTH_DSP_VALUE 
2825					FORTH_DSP 
2825 cd 94 17			call macro_forth_dsp 
2828				endm 
# End of macro FORTH_DSP
2828 7e					ld a,(hl)	; get type of value on TOS 
2829 fe 02				cp DS_TYPE_INUM  
282b 28 03				jr z, .neg_inum 
282d			 
282d					NEXTW 
282d c3 e9 18			jp macro_next 
2830				endm 
# End of macro NEXTW
2830			 
2830			; float maths 
2830			 
2830				if FORTH_ENABLE_FLOATMATH 
2830					jr .neg_done 
2830			 
2830				endif 
2830					 
2830			 
2830			.neg_inum: 
2830					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2830 cd af 17			call macro_dsp_valuehl 
2833				endm 
# End of macro FORTH_DSP_VALUEHL
2833			 
2833 e5					push hl 
2834			 
2834					; destroy value TOS 
2834			 
2834					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2834 cd 2f 18			call macro_forth_dsp_pop 
2837				endm 
# End of macro FORTH_DSP_POP
2837			 
2837			 
2837					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2837 cd af 17			call macro_dsp_valuehl 
283a				endm 
# End of macro FORTH_DSP_VALUEHL
283a			 
283a					; one value on hl get other one back 
283a			 
283a d1					pop de 
283b			 
283b					; do the sub 
283b			;		ex de, hl 
283b			 
283b ed 52				sbc hl,de 
283d			 
283d					; save it 
283d			 
283d			;		push hl	 
283d			 
283d					; 
283d			 
283d					; destroy value TOS 
283d			 
283d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
283d cd 2f 18			call macro_forth_dsp_pop 
2840				endm 
# End of macro FORTH_DSP_POP
2840			 
2840					; TODO push value back onto stack for another op etc 
2840			 
2840			;		pop hl 
2840			 
2840 cd 14 17				call forth_push_numhl 
2843			.neg_done: 
2843			 
2843					NEXTW 
2843 c3 e9 18			jp macro_next 
2846				endm 
# End of macro NEXTW
2846			.DIV: 
2846				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
2846 18				db WORD_SYS_CORE+4             
2847 93 28			dw .MUL            
2849 02				db 1 + 1 
284a .. 00			db "/",0              
284c				endm 
# End of macro CWHEAD
284c			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
284c					if DEBUG_FORTH_WORDS_KEY 
284c						DMARK "DIV" 
284c f5				push af  
284d 3a 61 28			ld a, (.dmark)  
2850 32 7a ee			ld (debug_mark),a  
2853 3a 62 28			ld a, (.dmark+1)  
2856 32 7b ee			ld (debug_mark+1),a  
2859 3a 63 28			ld a, (.dmark+2)  
285c 32 7c ee			ld (debug_mark+2),a  
285f 18 03			jr .pastdmark  
2861 ..			.dmark: db "DIV"  
2864 f1			.pastdmark: pop af  
2865			endm  
# End of macro DMARK
2865						CALLMONITOR 
2865 cd 8a 11			call break_point_state  
2868				endm  
# End of macro CALLMONITOR
2868					endif 
2868				; TODO add floating point number detection 
2868					; v5 FORTH_DSP_VALUE 
2868					FORTH_DSP 
2868 cd 94 17			call macro_forth_dsp 
286b				endm 
# End of macro FORTH_DSP
286b 7e					ld a,(hl)	; get type of value on TOS 
286c fe 02				cp DS_TYPE_INUM  
286e 28 03				jr z, .div_inum 
2870			 
2870				if FORTH_ENABLE_FLOATMATH 
2870					jr .div_done 
2870			 
2870				endif 
2870					NEXTW 
2870 c3 e9 18			jp macro_next 
2873				endm 
# End of macro NEXTW
2873			.div_inum: 
2873			 
2873					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2873 cd af 17			call macro_dsp_valuehl 
2876				endm 
# End of macro FORTH_DSP_VALUEHL
2876			 
2876 e5					push hl    ; to go to bc 
2877			 
2877					; destroy value TOS 
2877			 
2877					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2877 cd 2f 18			call macro_forth_dsp_pop 
287a				endm 
# End of macro FORTH_DSP_POP
287a			 
287a			 
287a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
287a cd af 17			call macro_dsp_valuehl 
287d				endm 
# End of macro FORTH_DSP_VALUEHL
287d			 
287d					; hl to go to de 
287d			 
287d e5					push hl 
287e			 
287e c1					pop bc 
287f d1					pop de		 
2880			 
2880			 
2880					if DEBUG_FORTH_MATHS 
2880						DMARK "DIV" 
2880				CALLMONITOR 
2880					endif 
2880					; one value on hl but move to a get other one back 
2880			 
2880			        
2880 cd 23 09			call Div16 
2883			 
2883			;	push af	 
2883 e5				push hl 
2884 c5				push bc 
2885			 
2885					if DEBUG_FORTH_MATHS 
2885						DMARK "DI1" 
2885				CALLMONITOR 
2885					endif 
2885			 
2885					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2885 cd 2f 18			call macro_forth_dsp_pop 
2888				endm 
# End of macro FORTH_DSP_POP
2888			 
2888			 
2888			 
2888 e1					pop hl    ; result 
2889			 
2889 cd 14 17				call forth_push_numhl 
288c			 
288c e1					pop hl    ; reminder 
288d			;		ld h,0 
288d			;		ld l,d 
288d			 
288d cd 14 17				call forth_push_numhl 
2890			.div_done: 
2890					NEXTW 
2890 c3 e9 18			jp macro_next 
2893				endm 
# End of macro NEXTW
2893			.MUL: 
2893				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
2893 19				db WORD_SYS_CORE+5             
2894 d8 28			dw .MIN            
2896 02				db 1 + 1 
2897 .. 00			db "*",0              
2899				endm 
# End of macro CWHEAD
2899			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
2899				; TODO add floating point number detection 
2899					if DEBUG_FORTH_WORDS_KEY 
2899						DMARK "MUL" 
2899 f5				push af  
289a 3a ae 28			ld a, (.dmark)  
289d 32 7a ee			ld (debug_mark),a  
28a0 3a af 28			ld a, (.dmark+1)  
28a3 32 7b ee			ld (debug_mark+1),a  
28a6 3a b0 28			ld a, (.dmark+2)  
28a9 32 7c ee			ld (debug_mark+2),a  
28ac 18 03			jr .pastdmark  
28ae ..			.dmark: db "MUL"  
28b1 f1			.pastdmark: pop af  
28b2			endm  
# End of macro DMARK
28b2						CALLMONITOR 
28b2 cd 8a 11			call break_point_state  
28b5				endm  
# End of macro CALLMONITOR
28b5					endif 
28b5					FORTH_DSP 
28b5 cd 94 17			call macro_forth_dsp 
28b8				endm 
# End of macro FORTH_DSP
28b8					; v5 FORTH_DSP_VALUE 
28b8 7e					ld a,(hl)	; get type of value on TOS 
28b9 fe 02				cp DS_TYPE_INUM  
28bb 28 03				jr z, .mul_inum 
28bd			 
28bd				if FORTH_ENABLE_FLOATMATH 
28bd					jr .mul_done 
28bd			 
28bd				endif 
28bd			 
28bd					NEXTW 
28bd c3 e9 18			jp macro_next 
28c0				endm 
# End of macro NEXTW
28c0			.mul_inum:	 
28c0			 
28c0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28c0 cd af 17			call macro_dsp_valuehl 
28c3				endm 
# End of macro FORTH_DSP_VALUEHL
28c3			 
28c3 e5					push hl 
28c4			 
28c4					; destroy value TOS 
28c4			 
28c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28c4 cd 2f 18			call macro_forth_dsp_pop 
28c7				endm 
# End of macro FORTH_DSP_POP
28c7			 
28c7			 
28c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28c7 cd af 17			call macro_dsp_valuehl 
28ca				endm 
# End of macro FORTH_DSP_VALUEHL
28ca			 
28ca					; one value on hl but move to a get other one back 
28ca			 
28ca 7d					ld a, l 
28cb			 
28cb d1					pop de 
28cc			 
28cc					; do the mull 
28cc			;		ex de, hl 
28cc			 
28cc cd 49 09				call Mult16 
28cf					; save it 
28cf			 
28cf			;		push hl	 
28cf			 
28cf					; 
28cf			 
28cf					; destroy value TOS 
28cf			 
28cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28cf cd 2f 18			call macro_forth_dsp_pop 
28d2				endm 
# End of macro FORTH_DSP_POP
28d2			 
28d2					; TODO push value back onto stack for another op etc 
28d2			 
28d2			;		pop hl 
28d2			 
28d2 cd 14 17				call forth_push_numhl 
28d5			 
28d5			.mul_done: 
28d5					NEXTW 
28d5 c3 e9 18			jp macro_next 
28d8				endm 
# End of macro NEXTW
28d8			 
28d8			 
28d8			 
28d8			 
28d8			.MIN: 
28d8				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
28d8 49				db WORD_SYS_CORE+53             
28d9 21 29			dw .MAX            
28db 04				db 3 + 1 
28dc .. 00			db "MIN",0              
28e0				endm 
# End of macro CWHEAD
28e0			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
28e0					if DEBUG_FORTH_WORDS_KEY 
28e0						DMARK "MIN" 
28e0 f5				push af  
28e1 3a f5 28			ld a, (.dmark)  
28e4 32 7a ee			ld (debug_mark),a  
28e7 3a f6 28			ld a, (.dmark+1)  
28ea 32 7b ee			ld (debug_mark+1),a  
28ed 3a f7 28			ld a, (.dmark+2)  
28f0 32 7c ee			ld (debug_mark+2),a  
28f3 18 03			jr .pastdmark  
28f5 ..			.dmark: db "MIN"  
28f8 f1			.pastdmark: pop af  
28f9			endm  
# End of macro DMARK
28f9						CALLMONITOR 
28f9 cd 8a 11			call break_point_state  
28fc				endm  
# End of macro CALLMONITOR
28fc					endif 
28fc					; get u2 
28fc			 
28fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28fc cd af 17			call macro_dsp_valuehl 
28ff				endm 
# End of macro FORTH_DSP_VALUEHL
28ff			 
28ff e5					push hl   ; u2 
2900			 
2900					; destroy value TOS 
2900			 
2900					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2900 cd 2f 18			call macro_forth_dsp_pop 
2903				endm 
# End of macro FORTH_DSP_POP
2903			 
2903					; get u1 
2903			 
2903					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2903 cd af 17			call macro_dsp_valuehl 
2906				endm 
# End of macro FORTH_DSP_VALUEHL
2906			 
2906 e5					push hl  ; u1 
2907			 
2907					; destroy value TOS 
2907			 
2907					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2907 cd 2f 18			call macro_forth_dsp_pop 
290a				endm 
# End of macro FORTH_DSP_POP
290a			 
290a b7			 or a      ;clear carry flag 
290b e1			  pop hl    ; u1 
290c d1			  pop de    ; u2 
290d e5				push hl   ; saved in case hl is lowest 
290e ed 52		  sbc hl,de 
2910 30 07		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
2912			 
2912 e1				pop hl 
2913					if DEBUG_FORTH_WORDS 
2913						DMARK "MIN" 
2913						CALLMONITOR 
2913					endif 
2913 cd 14 17				call forth_push_numhl 
2916			 
2916				       NEXTW 
2916 c3 e9 18			jp macro_next 
2919				endm 
# End of macro NEXTW
2919			 
2919			.mincont:  
2919 c1				pop bc   ; tidy up 
291a eb				ex de , hl  
291b					if DEBUG_FORTH_WORDS 
291b						DMARK "MI1" 
291b						CALLMONITOR 
291b					endif 
291b cd 14 17				call forth_push_numhl 
291e			 
291e				       NEXTW 
291e c3 e9 18			jp macro_next 
2921				endm 
# End of macro NEXTW
2921			.MAX: 
2921				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
2921 4a				db WORD_SYS_CORE+54             
2922 6a 29			dw .RND16            
2924 04				db 3 + 1 
2925 .. 00			db "MAX",0              
2929				endm 
# End of macro CWHEAD
2929			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
2929					if DEBUG_FORTH_WORDS_KEY 
2929						DMARK "MAX" 
2929 f5				push af  
292a 3a 3e 29			ld a, (.dmark)  
292d 32 7a ee			ld (debug_mark),a  
2930 3a 3f 29			ld a, (.dmark+1)  
2933 32 7b ee			ld (debug_mark+1),a  
2936 3a 40 29			ld a, (.dmark+2)  
2939 32 7c ee			ld (debug_mark+2),a  
293c 18 03			jr .pastdmark  
293e ..			.dmark: db "MAX"  
2941 f1			.pastdmark: pop af  
2942			endm  
# End of macro DMARK
2942						CALLMONITOR 
2942 cd 8a 11			call break_point_state  
2945				endm  
# End of macro CALLMONITOR
2945					endif 
2945					; get u2 
2945			 
2945					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2945 cd af 17			call macro_dsp_valuehl 
2948				endm 
# End of macro FORTH_DSP_VALUEHL
2948			 
2948 e5					push hl   ; u2 
2949			 
2949					; destroy value TOS 
2949			 
2949					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2949 cd 2f 18			call macro_forth_dsp_pop 
294c				endm 
# End of macro FORTH_DSP_POP
294c			 
294c					; get u1 
294c			 
294c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
294c cd af 17			call macro_dsp_valuehl 
294f				endm 
# End of macro FORTH_DSP_VALUEHL
294f			 
294f e5					push hl  ; u1 
2950			 
2950					; destroy value TOS 
2950			 
2950					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2950 cd 2f 18			call macro_forth_dsp_pop 
2953				endm 
# End of macro FORTH_DSP_POP
2953			 
2953 b7			 or a      ;clear carry flag 
2954 e1			  pop hl    ; u1 
2955 d1			  pop de    ; u2 
2956 e5				push hl   ; saved in case hl is lowest 
2957 ed 52		  sbc hl,de 
2959 38 07		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
295b			 
295b e1				pop hl 
295c					if DEBUG_FORTH_WORDS 
295c						DMARK "MAX" 
295c						CALLMONITOR 
295c					endif 
295c cd 14 17				call forth_push_numhl 
295f			 
295f				       NEXTW 
295f c3 e9 18			jp macro_next 
2962				endm 
# End of macro NEXTW
2962			 
2962			.maxcont:  
2962 c1				pop bc   ; tidy up 
2963 eb				ex de , hl  
2964					if DEBUG_FORTH_WORDS 
2964						DMARK "MA1" 
2964						CALLMONITOR 
2964					endif 
2964 cd 14 17				call forth_push_numhl 
2967				       NEXTW 
2967 c3 e9 18			jp macro_next 
296a				endm 
# End of macro NEXTW
296a			 
296a			.RND16: 
296a				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
296a 4e				db WORD_SYS_CORE+58             
296b 99 29			dw .RND8            
296d 06				db 5 + 1 
296e .. 00			db "RND16",0              
2974				endm 
# End of macro CWHEAD
2974			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
2974					if DEBUG_FORTH_WORDS_KEY 
2974						DMARK "R16" 
2974 f5				push af  
2975 3a 89 29			ld a, (.dmark)  
2978 32 7a ee			ld (debug_mark),a  
297b 3a 8a 29			ld a, (.dmark+1)  
297e 32 7b ee			ld (debug_mark+1),a  
2981 3a 8b 29			ld a, (.dmark+2)  
2984 32 7c ee			ld (debug_mark+2),a  
2987 18 03			jr .pastdmark  
2989 ..			.dmark: db "R16"  
298c f1			.pastdmark: pop af  
298d			endm  
# End of macro DMARK
298d						CALLMONITOR 
298d cd 8a 11			call break_point_state  
2990				endm  
# End of macro CALLMONITOR
2990					endif 
2990 cd ed 08				call prng16  
2993 cd 14 17				call forth_push_numhl 
2996				       NEXTW 
2996 c3 e9 18			jp macro_next 
2999				endm 
# End of macro NEXTW
2999			.RND8: 
2999				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
2999 60				db WORD_SYS_CORE+76             
299a ce 29			dw .RND            
299c 05				db 4 + 1 
299d .. 00			db "RND8",0              
29a2				endm 
# End of macro CWHEAD
29a2			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
29a2					if DEBUG_FORTH_WORDS_KEY 
29a2						DMARK "RN8" 
29a2 f5				push af  
29a3 3a b7 29			ld a, (.dmark)  
29a6 32 7a ee			ld (debug_mark),a  
29a9 3a b8 29			ld a, (.dmark+1)  
29ac 32 7b ee			ld (debug_mark+1),a  
29af 3a b9 29			ld a, (.dmark+2)  
29b2 32 7c ee			ld (debug_mark+2),a  
29b5 18 03			jr .pastdmark  
29b7 ..			.dmark: db "RN8"  
29ba f1			.pastdmark: pop af  
29bb			endm  
# End of macro DMARK
29bb						CALLMONITOR 
29bb cd 8a 11			call break_point_state  
29be				endm  
# End of macro CALLMONITOR
29be					endif 
29be 2a bb eb				ld hl,(xrandc) 
29c1 23					inc hl 
29c2 cd 07 09				call xrnd 
29c5 6f					ld l,a	 
29c6 26 00				ld h,0 
29c8 cd 14 17				call forth_push_numhl 
29cb				       NEXTW 
29cb c3 e9 18			jp macro_next 
29ce				endm 
# End of macro NEXTW
29ce			.RND: 
29ce				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
29ce 60				db WORD_SYS_CORE+76             
29cf 2c 2a			dw .ENDMATHS            
29d1 04				db 3 + 1 
29d2 .. 00			db "RND",0              
29d6				endm 
# End of macro CWHEAD
29d6			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
29d6			 
29d6					if DEBUG_FORTH_WORDS_KEY 
29d6						DMARK "RND" 
29d6 f5				push af  
29d7 3a eb 29			ld a, (.dmark)  
29da 32 7a ee			ld (debug_mark),a  
29dd 3a ec 29			ld a, (.dmark+1)  
29e0 32 7b ee			ld (debug_mark+1),a  
29e3 3a ed 29			ld a, (.dmark+2)  
29e6 32 7c ee			ld (debug_mark+2),a  
29e9 18 03			jr .pastdmark  
29eb ..			.dmark: db "RND"  
29ee f1			.pastdmark: pop af  
29ef			endm  
# End of macro DMARK
29ef						CALLMONITOR 
29ef cd 8a 11			call break_point_state  
29f2				endm  
# End of macro CALLMONITOR
29f2					endif 
29f2					 
29f2					FORTH_DSP_VALUEHL    ; upper range 
29f2 cd af 17			call macro_dsp_valuehl 
29f5				endm 
# End of macro FORTH_DSP_VALUEHL
29f5			 
29f5 22 bf eb				ld (LFSRSeed), hl	 
29f8			 
29f8					if DEBUG_FORTH_WORDS 
29f8						DMARK "RN1" 
29f8						CALLMONITOR 
29f8					endif 
29f8					FORTH_DSP_POP 
29f8 cd 2f 18			call macro_forth_dsp_pop 
29fb				endm 
# End of macro FORTH_DSP_POP
29fb			 
29fb					FORTH_DSP_VALUEHL    ; low range 
29fb cd af 17			call macro_dsp_valuehl 
29fe				endm 
# End of macro FORTH_DSP_VALUEHL
29fe			 
29fe					if DEBUG_FORTH_WORDS 
29fe						DMARK "RN2" 
29fe						CALLMONITOR 
29fe					endif 
29fe 22 c1 eb				ld (LFSRSeed+2), hl 
2a01			 
2a01					FORTH_DSP_POP 
2a01 cd 2f 18			call macro_forth_dsp_pop 
2a04				endm 
# End of macro FORTH_DSP_POP
2a04			 
2a04 e5					push hl 
2a05			 
2a05 e1			.inrange:	pop hl 
2a06 cd ed 08				call prng16  
2a09					if DEBUG_FORTH_WORDS 
2a09						DMARK "RN3" 
2a09						CALLMONITOR 
2a09					endif 
2a09					 
2a09					; if the range is 8bit knock out the high byte 
2a09			 
2a09 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
2a0d			 
2a0d 3e 00				ld a, 0 
2a0f ba					cp d  
2a10 20 02				jr nz, .hirange 
2a12 26 00				ld h, 0   ; knock it down to 8bit 
2a14			 
2a14					if DEBUG_FORTH_WORDS 
2a14						DMARK "RNk" 
2a14						CALLMONITOR 
2a14					endif 
2a14			.hirange:   
2a14 e5					push hl  
2a15 b7					or a  
2a16 ed 52		                sbc hl, de 
2a18			 
2a18					;call cmp16 
2a18			 
2a18 30 eb				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
2a1a e1					pop hl 
2a1b e5					push hl 
2a1c			 
2a1c					if DEBUG_FORTH_WORDS 
2a1c						DMARK "RN4" 
2a1c						CALLMONITOR 
2a1c					endif 
2a1c ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
2a20					;call cmp16 
2a20				 
2a20 b7					or a  
2a21 ed 52		                sbc hl, de 
2a23 38 e0				jr c, .inrange 
2a25			 
2a25 e1					pop hl 
2a26					 
2a26					if DEBUG_FORTH_WORDS 
2a26						DMARK "RNd" 
2a26						CALLMONITOR 
2a26					endif 
2a26			 
2a26			 
2a26 cd 14 17				call forth_push_numhl 
2a29				       NEXTW 
2a29 c3 e9 18			jp macro_next 
2a2c				endm 
# End of macro NEXTW
2a2c			 
2a2c			.ENDMATHS: 
2a2c			 
2a2c			; eof 
2a2c			 
# End of file forth_words_maths.asm
2a2c			include "forth_words_display.asm" 
2a2c			 
2a2c			; | ## Display Words 
2a2c			 
2a2c			.ATP: 
2a2c				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
2a2c 62				db WORD_SYS_CORE+78             
2a2d 6b 2a			dw .FB            
2a2f 04				db 3 + 1 
2a30 .. 00			db "AT?",0              
2a34				endm 
# End of macro CWHEAD
2a34			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
2a34					if DEBUG_FORTH_WORDS_KEY 
2a34						DMARK "AT?" 
2a34 f5				push af  
2a35 3a 49 2a			ld a, (.dmark)  
2a38 32 7a ee			ld (debug_mark),a  
2a3b 3a 4a 2a			ld a, (.dmark+1)  
2a3e 32 7b ee			ld (debug_mark+1),a  
2a41 3a 4b 2a			ld a, (.dmark+2)  
2a44 32 7c ee			ld (debug_mark+2),a  
2a47 18 03			jr .pastdmark  
2a49 ..			.dmark: db "AT?"  
2a4c f1			.pastdmark: pop af  
2a4d			endm  
# End of macro DMARK
2a4d						CALLMONITOR 
2a4d cd 8a 11			call break_point_state  
2a50				endm  
# End of macro CALLMONITOR
2a50					endif 
2a50 3a 5e eb				ld a, (f_cursor_ptr) 
2a53			 
2a53			if DEBUG_FORTH_WORDS 
2a53				DMARK "AT?" 
2a53				CALLMONITOR 
2a53			endif	 
2a53					; count the number of rows 
2a53			 
2a53 06 00				ld b, 0 
2a55 4f			.atpr:		ld c, a    ; save in case we go below zero 
2a56 d6 28				sub display_cols 
2a58 f2 5e 2a				jp p, .atprunder 
2a5b 04					inc b 
2a5c 18 f7				jr .atpr 
2a5e			.atprunder:	 
2a5e			if DEBUG_FORTH_WORDS 
2a5e				DMARK "A?2" 
2a5e				CALLMONITOR 
2a5e			endif	 
2a5e 26 00				ld h, 0 
2a60 69					ld l, c 
2a61 cd 14 17				call forth_push_numhl 
2a64 68					ld l, b  
2a65 cd 14 17				call forth_push_numhl 
2a68			 
2a68			 
2a68				NEXTW 
2a68 c3 e9 18			jp macro_next 
2a6b				endm 
# End of macro NEXTW
2a6b			 
2a6b			.FB: 
2a6b				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
2a6b 1b				db WORD_SYS_CORE+7             
2a6c b9 2a			dw .EMIT            
2a6e 03				db 2 + 1 
2a6f .. 00			db "FB",0              
2a72				endm 
# End of macro CWHEAD
2a72			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
2a72			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
2a72			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
2a72			; | | If automatic display is off then updates will not be shown until DRAW is used. 
2a72					if DEBUG_FORTH_WORDS_KEY 
2a72						DMARK "FB." 
2a72 f5				push af  
2a73 3a 87 2a			ld a, (.dmark)  
2a76 32 7a ee			ld (debug_mark),a  
2a79 3a 88 2a			ld a, (.dmark+1)  
2a7c 32 7b ee			ld (debug_mark+1),a  
2a7f 3a 89 2a			ld a, (.dmark+2)  
2a82 32 7c ee			ld (debug_mark+2),a  
2a85 18 03			jr .pastdmark  
2a87 ..			.dmark: db "FB."  
2a8a f1			.pastdmark: pop af  
2a8b			endm  
# End of macro DMARK
2a8b						CALLMONITOR 
2a8b cd 8a 11			call break_point_state  
2a8e				endm  
# End of macro CALLMONITOR
2a8e					endif 
2a8e			 
2a8e					FORTH_DSP_VALUEHL 
2a8e cd af 17			call macro_dsp_valuehl 
2a91				endm 
# End of macro FORTH_DSP_VALUEHL
2a91			 
2a91 7d					ld a, l 
2a92 fe 01				cp 1 
2a94 20 05				jr nz, .fbn1 
2a96 21 1f ed				ld hl, display_fb1 
2a99 18 15				jr .fbset 
2a9b fe 02		.fbn1:		cp 2 
2a9d 20 05				jr nz, .fbn2 
2a9f 21 dd eb				ld hl, display_fb2 
2aa2 18 0c				jr .fbset 
2aa4 fe 03		.fbn2:		cp 3 
2aa6 20 05				jr nz, .fbn3 
2aa8 21 7e ec				ld hl, display_fb3 
2aab 18 03				jr .fbset 
2aad			.fbn3:		 ; if invalid number select first 
2aad 21 1f ed				ld hl, display_fb1 
2ab0 22 db eb		.fbset:		ld (display_fb_active), hl 
2ab3			 
2ab3					FORTH_DSP_POP 
2ab3 cd 2f 18			call macro_forth_dsp_pop 
2ab6				endm 
# End of macro FORTH_DSP_POP
2ab6			 
2ab6					NEXTW 
2ab6 c3 e9 18			jp macro_next 
2ab9				endm 
# End of macro NEXTW
2ab9			 
2ab9			 
2ab9			.EMIT: 
2ab9				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
2ab9 1b				db WORD_SYS_CORE+7             
2aba 0a 2b			dw .DOTH            
2abc 05				db 4 + 1 
2abd .. 00			db "EMIT",0              
2ac2				endm 
# End of macro CWHEAD
2ac2			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
2ac2					; get value off TOS and display it 
2ac2			 
2ac2					if DEBUG_FORTH_WORDS_KEY 
2ac2						DMARK "EMT" 
2ac2 f5				push af  
2ac3 3a d7 2a			ld a, (.dmark)  
2ac6 32 7a ee			ld (debug_mark),a  
2ac9 3a d8 2a			ld a, (.dmark+1)  
2acc 32 7b ee			ld (debug_mark+1),a  
2acf 3a d9 2a			ld a, (.dmark+2)  
2ad2 32 7c ee			ld (debug_mark+2),a  
2ad5 18 03			jr .pastdmark  
2ad7 ..			.dmark: db "EMT"  
2ada f1			.pastdmark: pop af  
2adb			endm  
# End of macro DMARK
2adb						CALLMONITOR 
2adb cd 8a 11			call break_point_state  
2ade				endm  
# End of macro CALLMONITOR
2ade					endif 
2ade			 
2ade					FORTH_DSP_VALUEHL 
2ade cd af 17			call macro_dsp_valuehl 
2ae1				endm 
# End of macro FORTH_DSP_VALUEHL
2ae1			 
2ae1 7d					ld a,l 
2ae2			 
2ae2					; TODO write to display 
2ae2			 
2ae2 32 73 e5				ld (os_input), a 
2ae5 3e 00				ld a, 0 
2ae7 32 74 e5				ld (os_input+1), a 
2aea					 
2aea 3a 5e eb				ld a, (f_cursor_ptr) 
2aed 11 73 e5				ld de, os_input 
2af0 cd 80 08				call str_at_display 
2af3			 
2af3			 
2af3 3a 3c eb				ld a,(cli_autodisplay) 
2af6 fe 00				cp 0 
2af8 28 03				jr z, .enoupdate 
2afa cd 90 08						call update_display 
2afd					.enoupdate: 
2afd			 
2afd 3a 5e eb				ld a, (f_cursor_ptr) 
2b00 3c					inc a 
2b01 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
2b04			 
2b04			 
2b04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b04 cd 2f 18			call macro_forth_dsp_pop 
2b07				endm 
# End of macro FORTH_DSP_POP
2b07			  
2b07			 
2b07					NEXTW 
2b07 c3 e9 18			jp macro_next 
2b0a				endm 
# End of macro NEXTW
2b0a			.DOTH: 
2b0a				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
2b0a 1c				db WORD_SYS_CORE+8             
2b0b 3a 2b			dw .DOTF            
2b0d 03				db 2 + 1 
2b0e .. 00			db ".-",0              
2b11				endm 
# End of macro CWHEAD
2b11			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
2b11					; get value off TOS and display it 
2b11					if DEBUG_FORTH_WORDS_KEY 
2b11						DMARK "DTD" 
2b11 f5				push af  
2b12 3a 26 2b			ld a, (.dmark)  
2b15 32 7a ee			ld (debug_mark),a  
2b18 3a 27 2b			ld a, (.dmark+1)  
2b1b 32 7b ee			ld (debug_mark+1),a  
2b1e 3a 28 2b			ld a, (.dmark+2)  
2b21 32 7c ee			ld (debug_mark+2),a  
2b24 18 03			jr .pastdmark  
2b26 ..			.dmark: db "DTD"  
2b29 f1			.pastdmark: pop af  
2b2a			endm  
# End of macro DMARK
2b2a						CALLMONITOR 
2b2a cd 8a 11			call break_point_state  
2b2d				endm  
# End of macro CALLMONITOR
2b2d					endif 
2b2d 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
2b2f 3e 00			ld a, 0 
2b31 32 3d eb			ld (cli_mvdot), a 
2b34 c3 91 2b			jp .dotgo 
2b37				NEXTW 
2b37 c3 e9 18			jp macro_next 
2b3a				endm 
# End of macro NEXTW
2b3a			.DOTF: 
2b3a				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
2b3a 1c				db WORD_SYS_CORE+8             
2b3b 68 2b			dw .DOT            
2b3d 03				db 2 + 1 
2b3e .. 00			db ".>",0              
2b41				endm 
# End of macro CWHEAD
2b41			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
2b41					; get value off TOS and display it 
2b41			        ; TODO BUG adds extra spaces 
2b41			        ; TODO BUG handle numerics? 
2b41					if DEBUG_FORTH_WORDS_KEY 
2b41						DMARK "DTC" 
2b41 f5				push af  
2b42 3a 56 2b			ld a, (.dmark)  
2b45 32 7a ee			ld (debug_mark),a  
2b48 3a 57 2b			ld a, (.dmark+1)  
2b4b 32 7b ee			ld (debug_mark+1),a  
2b4e 3a 58 2b			ld a, (.dmark+2)  
2b51 32 7c ee			ld (debug_mark+2),a  
2b54 18 03			jr .pastdmark  
2b56 ..			.dmark: db "DTC"  
2b59 f1			.pastdmark: pop af  
2b5a			endm  
# End of macro DMARK
2b5a						CALLMONITOR 
2b5a cd 8a 11			call break_point_state  
2b5d				endm  
# End of macro CALLMONITOR
2b5d					endif 
2b5d 3e 01			ld a, 1 
2b5f 32 3d eb			ld (cli_mvdot), a 
2b62 c3 91 2b			jp .dotgo 
2b65				NEXTW 
2b65 c3 e9 18			jp macro_next 
2b68				endm 
# End of macro NEXTW
2b68			 
2b68			.DOT: 
2b68				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
2b68 1c				db WORD_SYS_CORE+8             
2b69 f4 2b			dw .CLS            
2b6b 02				db 1 + 1 
2b6c .. 00			db ".",0              
2b6e				endm 
# End of macro CWHEAD
2b6e			        ; | . ( u -- ) Display TOS | DONE 
2b6e					; get value off TOS and display it 
2b6e			 
2b6e					if DEBUG_FORTH_WORDS_KEY 
2b6e						DMARK "DOT" 
2b6e f5				push af  
2b6f 3a 83 2b			ld a, (.dmark)  
2b72 32 7a ee			ld (debug_mark),a  
2b75 3a 84 2b			ld a, (.dmark+1)  
2b78 32 7b ee			ld (debug_mark+1),a  
2b7b 3a 85 2b			ld a, (.dmark+2)  
2b7e 32 7c ee			ld (debug_mark+2),a  
2b81 18 03			jr .pastdmark  
2b83 ..			.dmark: db "DOT"  
2b86 f1			.pastdmark: pop af  
2b87			endm  
# End of macro DMARK
2b87						CALLMONITOR 
2b87 cd 8a 11			call break_point_state  
2b8a				endm  
# End of macro CALLMONITOR
2b8a					endif 
2b8a 3e 00			ld a, 0 
2b8c 32 3d eb			ld (cli_mvdot), a 
2b8f 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
2b91				 
2b91			 
2b91			.dotgo: 
2b91			 
2b91			; move up type to on stack for parserv5 
2b91					FORTH_DSP 
2b91 cd 94 17			call macro_forth_dsp 
2b94				endm 
# End of macro FORTH_DSP
2b94				;FORTH_DSP_VALUE  
2b94			 
2b94			if DEBUG_FORTH_DOT 
2b94				DMARK "DOT" 
2b94				CALLMONITOR 
2b94			endif	 
2b94			;		.print: 
2b94			 
2b94 7e				ld a,(hl)  ; work out what type of value is on the TOS 
2b95 23				inc hl   ; position to the actual value 
2b96 fe 01			cp DS_TYPE_STR 
2b98 20 06			jr nz, .dotnum1  
2b9a			 
2b9a			; display string 
2b9a				FORTH_DSP_VALUE  
2b9a cd 98 17			call macro_forth_dsp_value 
2b9d				endm 
# End of macro FORTH_DSP_VALUE
2b9d eb				ex de,hl 
2b9e 18 11			jr .dotwrite 
2ba0			 
2ba0			.dotnum1: 
2ba0 fe 02			cp DS_TYPE_INUM 
2ba2 20 0c			jr nz, .dotflot 
2ba4			 
2ba4			 
2ba4			; display number 
2ba4			 
2ba4			;	push hl 
2ba4			;	call clear_display 
2ba4			;	pop hl 
2ba4			 
2ba4 5e				ld e, (hl) 
2ba5 23				inc hl 
2ba6 56				ld d, (hl) 
2ba7 21 75 e3			ld hl, scratch 
2baa			if DEBUG_FORTH_DOT 
2baa				DMARK "DT1" 
2baa				CALLMONITOR 
2baa			endif	 
2baa			 
2baa cd d3 0d			call uitoa_16 
2bad eb				ex de,hl 
2bae			 
2bae			if DEBUG_FORTH_DOT 
2bae				DMARK "DT2" 
2bae				CALLMONITOR 
2bae			endif	 
2bae			 
2bae			;	ld de, os_word_scratch 
2bae 18 01			jr .dotwrite 
2bb0			 
2bb0 00			.dotflot:   nop 
2bb1			; TODO print floating point number 
2bb1			 
2bb1			.dotwrite:		 
2bb1			 
2bb1					; if c is set then set all '-' to spaces 
2bb1					; need to also take into account .>  
2bb1			 
2bb1 3e 01				ld a, 1 
2bb3 b9					cp c 
2bb4 20 13				jr nz, .nodashswap 
2bb6			 
2bb6					; DE has the string to write, working with HL 
2bb6			 
2bb6 06 ff				ld b, 255 
2bb8 d5					push de 
2bb9 e1					pop hl 
2bba			 
2bba			if DEBUG_FORTH_DOT 
2bba				DMARK "DT-" 
2bba				CALLMONITOR 
2bba			endif	 
2bba 7e			.dashscan:	ld a, (hl) 
2bbb fe 00				cp 0 
2bbd 28 0a				jr z, .nodashswap 
2bbf fe 2d				cp '-' 
2bc1 20 03				jr nz, .dashskip 
2bc3 3e 20				ld a, ' ' 
2bc5 77					ld (hl), a 
2bc6 23			.dashskip:	inc hl 
2bc7			if DEBUG_FORTH_DOT 
2bc7				DMARK "D-2" 
2bc7				CALLMONITOR 
2bc7			endif	 
2bc7 10 f1				djnz .dashscan 
2bc9			 
2bc9			if DEBUG_FORTH_DOT 
2bc9				DMARK "D-1" 
2bc9				CALLMONITOR 
2bc9			endif	 
2bc9			 
2bc9			.nodashswap: 
2bc9			 
2bc9 e5					push hl   ; save string start in case we need to advance print 
2bca			 
2bca 3a 5e eb				ld a, (f_cursor_ptr) 
2bcd cd 80 08				call str_at_display 
2bd0 3a 3c eb				ld a,(cli_autodisplay) 
2bd3 fe 00				cp 0 
2bd5 28 03				jr z, .noupdate 
2bd7 cd 90 08						call update_display 
2bda					.noupdate: 
2bda			 
2bda			 
2bda					; see if we need to advance the print position 
2bda			 
2bda e1					pop hl   ; get back string 
2bdb			 
2bdb 3a 3d eb				ld a, (cli_mvdot) 
2bde			if DEBUG_FORTH_DOT 
2bde					ld e,a 
2bde				DMARK "D>1" 
2bde				CALLMONITOR 
2bde			endif	 
2bde fe 00				cp 0 
2be0 28 0c				jr z, .noadv 
2be2					; yes, lets advance the print position 
2be2 3e 00				ld a, 0 
2be4 cd 2f 0e				call strlent 
2be7 3a 5e eb				ld a, (f_cursor_ptr) 
2bea 85					add a,l 
2beb					;call addatohl 
2beb					;ld a, l 
2beb 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
2bee			 
2bee			if DEBUG_FORTH_DOT 
2bee				DMARK "D->" 
2bee				CALLMONITOR 
2bee			endif	 
2bee			 
2bee			.noadv:	 
2bee			 
2bee					if DEBUG_FORTH_DOT_WAIT 
2bee							call next_page_prompt 
2bee					endif	 
2bee			; TODO this pop off the stack causes a crash. i dont know why 
2bee			 
2bee			 
2bee			if DEBUG_FORTH_DOT 
2bee				DMARK "DTh" 
2bee				CALLMONITOR 
2bee			endif	 
2bee			 
2bee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bee cd 2f 18			call macro_forth_dsp_pop 
2bf1				endm 
# End of macro FORTH_DSP_POP
2bf1			 
2bf1			if DEBUG_FORTH_DOT 
2bf1				DMARK "DTi" 
2bf1				CALLMONITOR 
2bf1			endif	 
2bf1			 
2bf1			 
2bf1					NEXTW 
2bf1 c3 e9 18			jp macro_next 
2bf4				endm 
# End of macro NEXTW
2bf4			 
2bf4			.CLS: 
2bf4				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
2bf4 35				db WORD_SYS_CORE+33             
2bf5 21 2c			dw .DRAW            
2bf7 04				db 3 + 1 
2bf8 .. 00			db "CLS",0              
2bfc				endm 
# End of macro CWHEAD
2bfc			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
2bfc					if DEBUG_FORTH_WORDS_KEY 
2bfc						DMARK "CLS" 
2bfc f5				push af  
2bfd 3a 11 2c			ld a, (.dmark)  
2c00 32 7a ee			ld (debug_mark),a  
2c03 3a 12 2c			ld a, (.dmark+1)  
2c06 32 7b ee			ld (debug_mark+1),a  
2c09 3a 13 2c			ld a, (.dmark+2)  
2c0c 32 7c ee			ld (debug_mark+2),a  
2c0f 18 03			jr .pastdmark  
2c11 ..			.dmark: db "CLS"  
2c14 f1			.pastdmark: pop af  
2c15			endm  
# End of macro DMARK
2c15						CALLMONITOR 
2c15 cd 8a 11			call break_point_state  
2c18				endm  
# End of macro CALLMONITOR
2c18					endif 
2c18 cd 6d 08				call clear_display 
2c1b c3 2f 2d				jp .home		; and home cursor 
2c1e					NEXTW 
2c1e c3 e9 18			jp macro_next 
2c21				endm 
# End of macro NEXTW
2c21			 
2c21			.DRAW: 
2c21				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
2c21 36				db WORD_SYS_CORE+34             
2c22 4c 2c			dw .DUMP            
2c24 05				db 4 + 1 
2c25 .. 00			db "DRAW",0              
2c2a				endm 
# End of macro CWHEAD
2c2a			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
2c2a					if DEBUG_FORTH_WORDS_KEY 
2c2a						DMARK "DRW" 
2c2a f5				push af  
2c2b 3a 3f 2c			ld a, (.dmark)  
2c2e 32 7a ee			ld (debug_mark),a  
2c31 3a 40 2c			ld a, (.dmark+1)  
2c34 32 7b ee			ld (debug_mark+1),a  
2c37 3a 41 2c			ld a, (.dmark+2)  
2c3a 32 7c ee			ld (debug_mark+2),a  
2c3d 18 03			jr .pastdmark  
2c3f ..			.dmark: db "DRW"  
2c42 f1			.pastdmark: pop af  
2c43			endm  
# End of macro DMARK
2c43						CALLMONITOR 
2c43 cd 8a 11			call break_point_state  
2c46				endm  
# End of macro CALLMONITOR
2c46					endif 
2c46 cd 90 08				call update_display 
2c49					NEXTW 
2c49 c3 e9 18			jp macro_next 
2c4c				endm 
# End of macro NEXTW
2c4c			 
2c4c			.DUMP: 
2c4c				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
2c4c 37				db WORD_SYS_CORE+35             
2c4d 84 2c			dw .CDUMP            
2c4f 05				db 4 + 1 
2c50 .. 00			db "DUMP",0              
2c55				endm 
# End of macro CWHEAD
2c55			; | DUMP ( x -- ) With address x display dump   | DONE 
2c55			; TODO pop address to use off of the stack 
2c55					if DEBUG_FORTH_WORDS_KEY 
2c55						DMARK "DUM" 
2c55 f5				push af  
2c56 3a 6a 2c			ld a, (.dmark)  
2c59 32 7a ee			ld (debug_mark),a  
2c5c 3a 6b 2c			ld a, (.dmark+1)  
2c5f 32 7b ee			ld (debug_mark+1),a  
2c62 3a 6c 2c			ld a, (.dmark+2)  
2c65 32 7c ee			ld (debug_mark+2),a  
2c68 18 03			jr .pastdmark  
2c6a ..			.dmark: db "DUM"  
2c6d f1			.pastdmark: pop af  
2c6e			endm  
# End of macro DMARK
2c6e						CALLMONITOR 
2c6e cd 8a 11			call break_point_state  
2c71				endm  
# End of macro CALLMONITOR
2c71					endif 
2c71 cd 6d 08				call clear_display 
2c74			 
2c74					; get address 
2c74			 
2c74					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c74 cd af 17			call macro_dsp_valuehl 
2c77				endm 
# End of macro FORTH_DSP_VALUEHL
2c77				 
2c77					; save it for cdump 
2c77			 
2c77 22 98 e6				ld (os_cur_ptr),hl 
2c7a			 
2c7a					; destroy value TOS 
2c7a			 
2c7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c7a cd 2f 18			call macro_forth_dsp_pop 
2c7d				endm 
# End of macro FORTH_DSP_POP
2c7d			 
2c7d cd 97 15				call dumpcont	; skip old style of param parsing	 
2c80 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
2c81					NEXTW 
2c81 c3 e9 18			jp macro_next 
2c84				endm 
# End of macro NEXTW
2c84			.CDUMP: 
2c84				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
2c84 38				db WORD_SYS_CORE+36             
2c85 b4 2c			dw .DAT            
2c87 06				db 5 + 1 
2c88 .. 00			db "CDUMP",0              
2c8e				endm 
# End of macro CWHEAD
2c8e			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
2c8e					if DEBUG_FORTH_WORDS_KEY 
2c8e						DMARK "CDP" 
2c8e f5				push af  
2c8f 3a a3 2c			ld a, (.dmark)  
2c92 32 7a ee			ld (debug_mark),a  
2c95 3a a4 2c			ld a, (.dmark+1)  
2c98 32 7b ee			ld (debug_mark+1),a  
2c9b 3a a5 2c			ld a, (.dmark+2)  
2c9e 32 7c ee			ld (debug_mark+2),a  
2ca1 18 03			jr .pastdmark  
2ca3 ..			.dmark: db "CDP"  
2ca6 f1			.pastdmark: pop af  
2ca7			endm  
# End of macro DMARK
2ca7						CALLMONITOR 
2ca7 cd 8a 11			call break_point_state  
2caa				endm  
# End of macro CALLMONITOR
2caa					endif 
2caa cd 6d 08				call clear_display 
2cad cd 97 15				call dumpcont	 
2cb0 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
2cb1					NEXTW 
2cb1 c3 e9 18			jp macro_next 
2cb4				endm 
# End of macro NEXTW
2cb4			 
2cb4			 
2cb4			 
2cb4			 
2cb4			.DAT: 
2cb4				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
2cb4 3d				db WORD_SYS_CORE+41             
2cb5 0a 2d			dw .HOME            
2cb7 03				db 2 + 1 
2cb8 .. 00			db "AT",0              
2cbb				endm 
# End of macro CWHEAD
2cbb			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
2cbb					if DEBUG_FORTH_WORDS_KEY 
2cbb						DMARK "AT." 
2cbb f5				push af  
2cbc 3a d0 2c			ld a, (.dmark)  
2cbf 32 7a ee			ld (debug_mark),a  
2cc2 3a d1 2c			ld a, (.dmark+1)  
2cc5 32 7b ee			ld (debug_mark+1),a  
2cc8 3a d2 2c			ld a, (.dmark+2)  
2ccb 32 7c ee			ld (debug_mark+2),a  
2cce 18 03			jr .pastdmark  
2cd0 ..			.dmark: db "AT."  
2cd3 f1			.pastdmark: pop af  
2cd4			endm  
# End of macro DMARK
2cd4						CALLMONITOR 
2cd4 cd 8a 11			call break_point_state  
2cd7				endm  
# End of macro CALLMONITOR
2cd7					endif 
2cd7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2cd7 cd af 17			call macro_dsp_valuehl 
2cda				endm 
# End of macro FORTH_DSP_VALUEHL
2cda			 
2cda			 
2cda					; TODO save cursor row 
2cda 7d					ld a,l 
2cdb fe 02				cp 2 
2cdd 20 04				jr nz, .crow3 
2cdf 3e 28				ld a, display_row_2 
2ce1 18 12				jr .ccol1 
2ce3 fe 03		.crow3:		cp 3 
2ce5 20 04				jr nz, .crow4 
2ce7 3e 50				ld a, display_row_3 
2ce9 18 0a				jr .ccol1 
2ceb fe 04		.crow4:		cp 4 
2ced 20 04				jr nz, .crow1 
2cef 3e 78				ld a, display_row_4 
2cf1 18 02				jr .ccol1 
2cf3 3e 00		.crow1:		ld a,display_row_1 
2cf5 f5			.ccol1:		push af			; got row offset 
2cf6 6f					ld l,a 
2cf7 26 00				ld h,0 
2cf9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2cf9 cd 2f 18			call macro_forth_dsp_pop 
2cfc				endm 
# End of macro FORTH_DSP_POP
2cfc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2cfc cd af 17			call macro_dsp_valuehl 
2cff				endm 
# End of macro FORTH_DSP_VALUEHL
2cff					; TODO save cursor col 
2cff f1					pop af 
2d00 85					add l		; add col offset 
2d01 32 5e eb				ld (f_cursor_ptr), a 
2d04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d04 cd 2f 18			call macro_forth_dsp_pop 
2d07				endm 
# End of macro FORTH_DSP_POP
2d07			 
2d07					; calculate  
2d07			 
2d07					NEXTW 
2d07 c3 e9 18			jp macro_next 
2d0a				endm 
# End of macro NEXTW
2d0a			 
2d0a			 
2d0a			.HOME: 
2d0a				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
2d0a 41				db WORD_SYS_CORE+45             
2d0b 37 2d			dw .SPACE            
2d0d 05				db 4 + 1 
2d0e .. 00			db "HOME",0              
2d13				endm 
# End of macro CWHEAD
2d13			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
2d13					if DEBUG_FORTH_WORDS_KEY 
2d13						DMARK "HOM" 
2d13 f5				push af  
2d14 3a 28 2d			ld a, (.dmark)  
2d17 32 7a ee			ld (debug_mark),a  
2d1a 3a 29 2d			ld a, (.dmark+1)  
2d1d 32 7b ee			ld (debug_mark+1),a  
2d20 3a 2a 2d			ld a, (.dmark+2)  
2d23 32 7c ee			ld (debug_mark+2),a  
2d26 18 03			jr .pastdmark  
2d28 ..			.dmark: db "HOM"  
2d2b f1			.pastdmark: pop af  
2d2c			endm  
# End of macro DMARK
2d2c						CALLMONITOR 
2d2c cd 8a 11			call break_point_state  
2d2f				endm  
# End of macro CALLMONITOR
2d2f					endif 
2d2f 3e 00		.home:		ld a, 0		; and home cursor 
2d31 32 5e eb				ld (f_cursor_ptr), a 
2d34					NEXTW 
2d34 c3 e9 18			jp macro_next 
2d37				endm 
# End of macro NEXTW
2d37			 
2d37			 
2d37			.SPACE: 
2d37				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
2d37 46				db WORD_SYS_CORE+50             
2d38 65 2d			dw .SPACES            
2d3a 03				db 2 + 1 
2d3b .. 00			db "BL",0              
2d3e				endm 
# End of macro CWHEAD
2d3e			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
2d3e					if DEBUG_FORTH_WORDS_KEY 
2d3e						DMARK "BL." 
2d3e f5				push af  
2d3f 3a 53 2d			ld a, (.dmark)  
2d42 32 7a ee			ld (debug_mark),a  
2d45 3a 54 2d			ld a, (.dmark+1)  
2d48 32 7b ee			ld (debug_mark+1),a  
2d4b 3a 55 2d			ld a, (.dmark+2)  
2d4e 32 7c ee			ld (debug_mark+2),a  
2d51 18 03			jr .pastdmark  
2d53 ..			.dmark: db "BL."  
2d56 f1			.pastdmark: pop af  
2d57			endm  
# End of macro DMARK
2d57						CALLMONITOR 
2d57 cd 8a 11			call break_point_state  
2d5a				endm  
# End of macro CALLMONITOR
2d5a					endif 
2d5a 21 63 2d				ld hl, .blstr 
2d5d cd 26 17				call forth_push_str 
2d60					 
2d60				       NEXTW 
2d60 c3 e9 18			jp macro_next 
2d63				endm 
# End of macro NEXTW
2d63			 
2d63 .. 00		.blstr: db " ", 0 
2d65			 
2d65			.SPACES: 
2d65				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
2d65 47				db WORD_SYS_CORE+51             
2d66 ac 2d			dw .SCROLL            
2d68 07				db 6 + 1 
2d69 .. 00			db "SPACES",0              
2d70				endm 
# End of macro CWHEAD
2d70			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
2d70					if DEBUG_FORTH_WORDS_KEY 
2d70						DMARK "SPS" 
2d70 f5				push af  
2d71 3a 85 2d			ld a, (.dmark)  
2d74 32 7a ee			ld (debug_mark),a  
2d77 3a 86 2d			ld a, (.dmark+1)  
2d7a 32 7b ee			ld (debug_mark+1),a  
2d7d 3a 87 2d			ld a, (.dmark+2)  
2d80 32 7c ee			ld (debug_mark+2),a  
2d83 18 03			jr .pastdmark  
2d85 ..			.dmark: db "SPS"  
2d88 f1			.pastdmark: pop af  
2d89			endm  
# End of macro DMARK
2d89						CALLMONITOR 
2d89 cd 8a 11			call break_point_state  
2d8c				endm  
# End of macro CALLMONITOR
2d8c					endif 
2d8c			 
2d8c			 
2d8c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d8c cd af 17			call macro_dsp_valuehl 
2d8f				endm 
# End of macro FORTH_DSP_VALUEHL
2d8f			 
2d8f			;		push hl    ; u 
2d8f					if DEBUG_FORTH_WORDS 
2d8f						DMARK "SPA" 
2d8f						CALLMONITOR 
2d8f					endif 
2d8f			 
2d8f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d8f cd 2f 18			call macro_forth_dsp_pop 
2d92				endm 
# End of macro FORTH_DSP_POP
2d92			;		pop hl 
2d92 4d					ld c, l 
2d93 06 00				ld b, 0 
2d95 21 75 e3				ld hl, scratch  
2d98			 
2d98					if DEBUG_FORTH_WORDS 
2d98						DMARK "SP2" 
2d98						CALLMONITOR 
2d98					endif 
2d98 3e 20				ld a, ' ' 
2d9a c5			.spaces1:	push bc 
2d9b 77					ld (hl),a 
2d9c 23					inc hl 
2d9d c1					pop bc 
2d9e 10 fa				djnz .spaces1 
2da0 3e 00				ld a,0 
2da2 77					ld (hl),a 
2da3 21 75 e3				ld hl, scratch 
2da6					if DEBUG_FORTH_WORDS 
2da6						DMARK "SP3" 
2da6						CALLMONITOR 
2da6					endif 
2da6 cd 5c 17				call forth_apush 
2da9			 
2da9				       NEXTW 
2da9 c3 e9 18			jp macro_next 
2dac				endm 
# End of macro NEXTW
2dac			 
2dac			 
2dac			 
2dac			.SCROLL: 
2dac				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
2dac 53				db WORD_SYS_CORE+63             
2dad d9 2d			dw .ATQ            
2daf 07				db 6 + 1 
2db0 .. 00			db "SCROLL",0              
2db7				endm 
# End of macro CWHEAD
2db7			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
2db7					if DEBUG_FORTH_WORDS_KEY 
2db7						DMARK "SCR" 
2db7 f5				push af  
2db8 3a cc 2d			ld a, (.dmark)  
2dbb 32 7a ee			ld (debug_mark),a  
2dbe 3a cd 2d			ld a, (.dmark+1)  
2dc1 32 7b ee			ld (debug_mark+1),a  
2dc4 3a ce 2d			ld a, (.dmark+2)  
2dc7 32 7c ee			ld (debug_mark+2),a  
2dca 18 03			jr .pastdmark  
2dcc ..			.dmark: db "SCR"  
2dcf f1			.pastdmark: pop af  
2dd0			endm  
# End of macro DMARK
2dd0						CALLMONITOR 
2dd0 cd 8a 11			call break_point_state  
2dd3				endm  
# End of macro CALLMONITOR
2dd3					endif 
2dd3			 
2dd3 cd 05 08			call scroll_up 
2dd6			;	call update_display 
2dd6			 
2dd6					NEXTW 
2dd6 c3 e9 18			jp macro_next 
2dd9				endm 
# End of macro NEXTW
2dd9			 
2dd9			 
2dd9			 
2dd9			;		; get dir 
2dd9			; 
2dd9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2dd9			; 
2dd9			;		push hl 
2dd9			; 
2dd9			;		; destroy value TOS 
2dd9			; 
2dd9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dd9			; 
2dd9			;		; get count 
2dd9			; 
2dd9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2dd9			; 
2dd9			;		push hl 
2dd9			; 
2dd9			;		; destroy value TOS 
2dd9			; 
2dd9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dd9			; 
2dd9			;		; one value on hl get other one back 
2dd9			; 
2dd9			;		pop bc    ; count 
2dd9			; 
2dd9			;		pop de   ; dir 
2dd9			; 
2dd9			; 
2dd9			;		ld b, c 
2dd9			; 
2dd9			;.scrolldir:     push bc 
2dd9			;		push de 
2dd9			; 
2dd9			;		ld a, 0 
2dd9			;		cp e 
2dd9			;		jr z, .scrollup  
2dd9			;		call scroll_down 
2dd9			;		jr .scrollnext 
2dd9			;.scrollup:	call scroll_up 
2dd9			; 
2dd9			;		 
2dd9			;.scrollnext: 
2dd9			;		pop de 
2dd9			;		pop bc 
2dd9			;		djnz .scrolldir 
2dd9			; 
2dd9			; 
2dd9			; 
2dd9			; 
2dd9			; 
2dd9			;		NEXTW 
2dd9			 
2dd9			 
2dd9			 
2dd9			 
2dd9			.ATQ: 
2dd9				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
2dd9 62				db WORD_SYS_CORE+78             
2dda 37 2e			dw .AUTODSP            
2ddc 04				db 3 + 1 
2ddd .. 00			db "AT@",0              
2de1				endm 
# End of macro CWHEAD
2de1			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
2de1					if DEBUG_FORTH_WORDS_KEY 
2de1						DMARK "ATA" 
2de1 f5				push af  
2de2 3a f6 2d			ld a, (.dmark)  
2de5 32 7a ee			ld (debug_mark),a  
2de8 3a f7 2d			ld a, (.dmark+1)  
2deb 32 7b ee			ld (debug_mark+1),a  
2dee 3a f8 2d			ld a, (.dmark+2)  
2df1 32 7c ee			ld (debug_mark+2),a  
2df4 18 03			jr .pastdmark  
2df6 ..			.dmark: db "ATA"  
2df9 f1			.pastdmark: pop af  
2dfa			endm  
# End of macro DMARK
2dfa						CALLMONITOR 
2dfa cd 8a 11			call break_point_state  
2dfd				endm  
# End of macro CALLMONITOR
2dfd					endif 
2dfd			 
2dfd			 
2dfd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2dfd cd af 17			call macro_dsp_valuehl 
2e00				endm 
# End of macro FORTH_DSP_VALUEHL
2e00			 
2e00					; TODO save cursor row 
2e00 7d					ld a,l 
2e01 fe 02				cp 2 
2e03 20 04				jr nz, .crow3aq 
2e05 3e 28				ld a, display_row_2 
2e07 18 12				jr .ccol1aq 
2e09 fe 03		.crow3aq:		cp 3 
2e0b 20 04				jr nz, .crow4aq 
2e0d 3e 50				ld a, display_row_3 
2e0f 18 0a				jr .ccol1aq 
2e11 fe 04		.crow4aq:		cp 4 
2e13 20 04				jr nz, .crow1aq 
2e15 3e 78				ld a, display_row_4 
2e17 18 02				jr .ccol1aq 
2e19 3e 00		.crow1aq:		ld a,display_row_1 
2e1b f5			.ccol1aq:		push af			; got row offset 
2e1c 6f					ld l,a 
2e1d 26 00				ld h,0 
2e1f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e1f cd 2f 18			call macro_forth_dsp_pop 
2e22				endm 
# End of macro FORTH_DSP_POP
2e22					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e22 cd af 17			call macro_dsp_valuehl 
2e25				endm 
# End of macro FORTH_DSP_VALUEHL
2e25					; TODO save cursor col 
2e25 f1					pop af 
2e26 85					add l		; add col offset 
2e27			 
2e27					; add current frame buffer address 
2e27 2a db eb				ld hl, (display_fb_active) 
2e2a cd c6 09				call addatohl 
2e2d			 
2e2d			 
2e2d			 
2e2d			 
2e2d					; get char frame buffer location offset in hl 
2e2d			 
2e2d 7e					ld a,(hl) 
2e2e 26 00				ld h, 0 
2e30 6f					ld l, a 
2e31			 
2e31 cd 14 17				call forth_push_numhl 
2e34			 
2e34			 
2e34					NEXTW 
2e34 c3 e9 18			jp macro_next 
2e37				endm 
# End of macro NEXTW
2e37			 
2e37			.AUTODSP: 
2e37				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
2e37 63				db WORD_SYS_CORE+79             
2e38 4d 2e			dw .MENU            
2e3a 05				db 4 + 1 
2e3b .. 00			db "ADSP",0              
2e40				endm 
# End of macro CWHEAD
2e40			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
2e40			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
2e40			 
2e40					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e40 cd af 17			call macro_dsp_valuehl 
2e43				endm 
# End of macro FORTH_DSP_VALUEHL
2e43			 
2e43			;		push hl 
2e43			 
2e43					; destroy value TOS 
2e43			 
2e43					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e43 cd 2f 18			call macro_forth_dsp_pop 
2e46				endm 
# End of macro FORTH_DSP_POP
2e46			 
2e46			;		pop hl 
2e46			 
2e46 7d					ld a,l 
2e47 32 3c eb				ld (cli_autodisplay), a 
2e4a				       NEXTW 
2e4a c3 e9 18			jp macro_next 
2e4d				endm 
# End of macro NEXTW
2e4d			 
2e4d			.MENU: 
2e4d				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
2e4d 70				db WORD_SYS_CORE+92             
2e4e 59 2e			dw .ENDDISPLAY            
2e50 05				db 4 + 1 
2e51 .. 00			db "MENU",0              
2e56				endm 
# End of macro CWHEAD
2e56			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
2e56			 
2e56					; get the title address and save it 
2e56			 
2e56			;		FORTH_DSP_VALUEHL 
2e56			;		push hl 
2e56			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e56			; 
2e56			;		; get number of items on the stack 
2e56			; 
2e56			;	 
2e56			;		FORTH_DSP_VALUEHL 
2e56			;		push hl 
2e56			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e56			 
2e56			 
2e56			 
2e56			 
2e56				       NEXTW 
2e56 c3 e9 18			jp macro_next 
2e59				endm 
# End of macro NEXTW
2e59			 
2e59			 
2e59			.ENDDISPLAY: 
2e59			 
2e59			; eof 
# End of file forth_words_display.asm
2e59			include "forth_words_str.asm" 
2e59			 
2e59			; | ## String Words 
2e59			 
2e59			.PTR:   
2e59			 
2e59				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
2e59 48				db WORD_SYS_CORE+52             
2e5a 86 2e			dw .STYPE            
2e5c 04				db 3 + 1 
2e5d .. 00			db "PTR",0              
2e61				endm 
# End of macro CWHEAD
2e61			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
2e61			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
2e61			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
2e61			 
2e61					if DEBUG_FORTH_WORDS_KEY 
2e61						DMARK "PTR" 
2e61 f5				push af  
2e62 3a 76 2e			ld a, (.dmark)  
2e65 32 7a ee			ld (debug_mark),a  
2e68 3a 77 2e			ld a, (.dmark+1)  
2e6b 32 7b ee			ld (debug_mark+1),a  
2e6e 3a 78 2e			ld a, (.dmark+2)  
2e71 32 7c ee			ld (debug_mark+2),a  
2e74 18 03			jr .pastdmark  
2e76 ..			.dmark: db "PTR"  
2e79 f1			.pastdmark: pop af  
2e7a			endm  
# End of macro DMARK
2e7a						CALLMONITOR 
2e7a cd 8a 11			call break_point_state  
2e7d				endm  
# End of macro CALLMONITOR
2e7d					endif 
2e7d					FORTH_DSP_VALUEHL 
2e7d cd af 17			call macro_dsp_valuehl 
2e80				endm 
# End of macro FORTH_DSP_VALUEHL
2e80 cd 14 17				call forth_push_numhl 
2e83			 
2e83			 
2e83					NEXTW 
2e83 c3 e9 18			jp macro_next 
2e86				endm 
# End of macro NEXTW
2e86			.STYPE: 
2e86				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
2e86 48				db WORD_SYS_CORE+52             
2e87 d5 2e			dw .UPPER            
2e89 06				db 5 + 1 
2e8a .. 00			db "STYPE",0              
2e90				endm 
# End of macro CWHEAD
2e90			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
2e90					if DEBUG_FORTH_WORDS_KEY 
2e90						DMARK "STY" 
2e90 f5				push af  
2e91 3a a5 2e			ld a, (.dmark)  
2e94 32 7a ee			ld (debug_mark),a  
2e97 3a a6 2e			ld a, (.dmark+1)  
2e9a 32 7b ee			ld (debug_mark+1),a  
2e9d 3a a7 2e			ld a, (.dmark+2)  
2ea0 32 7c ee			ld (debug_mark+2),a  
2ea3 18 03			jr .pastdmark  
2ea5 ..			.dmark: db "STY"  
2ea8 f1			.pastdmark: pop af  
2ea9			endm  
# End of macro DMARK
2ea9						CALLMONITOR 
2ea9 cd 8a 11			call break_point_state  
2eac				endm  
# End of macro CALLMONITOR
2eac					endif 
2eac					FORTH_DSP 
2eac cd 94 17			call macro_forth_dsp 
2eaf				endm 
# End of macro FORTH_DSP
2eaf					;v5 FORTH_DSP_VALUE 
2eaf			 
2eaf 7e					ld a, (hl) 
2eb0			 
2eb0 f5					push af 
2eb1			 
2eb1			; Dont destroy TOS		FORTH_DSP_POP 
2eb1			 
2eb1 f1					pop af 
2eb2			 
2eb2 fe 01				cp DS_TYPE_STR 
2eb4 28 09				jr z, .typestr 
2eb6			 
2eb6 fe 02				cp DS_TYPE_INUM 
2eb8 28 0a				jr z, .typeinum 
2eba			 
2eba 21 d3 2e				ld hl, .tna 
2ebd 18 0a				jr .tpush 
2ebf			 
2ebf 21 cf 2e		.typestr:	ld hl, .tstr 
2ec2 18 05				jr .tpush 
2ec4 21 d1 2e		.typeinum:	ld hl, .tinum 
2ec7 18 00				jr .tpush 
2ec9			 
2ec9			.tpush: 
2ec9			 
2ec9 cd 26 17				call forth_push_str 
2ecc			 
2ecc					NEXTW 
2ecc c3 e9 18			jp macro_next 
2ecf				endm 
# End of macro NEXTW
2ecf .. 00		.tstr:	db "s",0 
2ed1 .. 00		.tinum:  db "i",0 
2ed3 .. 00		.tna:   db "?", 0 
2ed5			 
2ed5			 
2ed5			.UPPER: 
2ed5				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
2ed5 48				db WORD_SYS_CORE+52             
2ed6 10 2f			dw .LOWER            
2ed8 06				db 5 + 1 
2ed9 .. 00			db "UPPER",0              
2edf				endm 
# End of macro CWHEAD
2edf			; | UPPER ( s -- s ) Upper case string s  | DONE 
2edf					if DEBUG_FORTH_WORDS_KEY 
2edf						DMARK "UPR" 
2edf f5				push af  
2ee0 3a f4 2e			ld a, (.dmark)  
2ee3 32 7a ee			ld (debug_mark),a  
2ee6 3a f5 2e			ld a, (.dmark+1)  
2ee9 32 7b ee			ld (debug_mark+1),a  
2eec 3a f6 2e			ld a, (.dmark+2)  
2eef 32 7c ee			ld (debug_mark+2),a  
2ef2 18 03			jr .pastdmark  
2ef4 ..			.dmark: db "UPR"  
2ef7 f1			.pastdmark: pop af  
2ef8			endm  
# End of macro DMARK
2ef8						CALLMONITOR 
2ef8 cd 8a 11			call break_point_state  
2efb				endm  
# End of macro CALLMONITOR
2efb					endif 
2efb			 
2efb					FORTH_DSP 
2efb cd 94 17			call macro_forth_dsp 
2efe				endm 
# End of macro FORTH_DSP
2efe					 
2efe			; TODO check is string type 
2efe			 
2efe					FORTH_DSP_VALUEHL 
2efe cd af 17			call macro_dsp_valuehl 
2f01				endm 
# End of macro FORTH_DSP_VALUEHL
2f01			; get pointer to string in hl 
2f01			 
2f01 7e			.toup:		ld a, (hl) 
2f02 fe 00				cp 0 
2f04 28 07				jr z, .toupdone 
2f06			 
2f06 cd 33 0d				call to_upper 
2f09			 
2f09 77					ld (hl), a 
2f0a 23					inc hl 
2f0b 18 f4				jr .toup 
2f0d			 
2f0d					 
2f0d			 
2f0d			 
2f0d			; for each char convert to upper 
2f0d					 
2f0d			.toupdone: 
2f0d			 
2f0d			 
2f0d					NEXTW 
2f0d c3 e9 18			jp macro_next 
2f10				endm 
# End of macro NEXTW
2f10			.LOWER: 
2f10				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
2f10 48				db WORD_SYS_CORE+52             
2f11 4b 2f			dw .TCASE            
2f13 06				db 5 + 1 
2f14 .. 00			db "LOWER",0              
2f1a				endm 
# End of macro CWHEAD
2f1a			; | LOWER ( s -- s ) Lower case string s  | DONE 
2f1a					if DEBUG_FORTH_WORDS_KEY 
2f1a						DMARK "LWR" 
2f1a f5				push af  
2f1b 3a 2f 2f			ld a, (.dmark)  
2f1e 32 7a ee			ld (debug_mark),a  
2f21 3a 30 2f			ld a, (.dmark+1)  
2f24 32 7b ee			ld (debug_mark+1),a  
2f27 3a 31 2f			ld a, (.dmark+2)  
2f2a 32 7c ee			ld (debug_mark+2),a  
2f2d 18 03			jr .pastdmark  
2f2f ..			.dmark: db "LWR"  
2f32 f1			.pastdmark: pop af  
2f33			endm  
# End of macro DMARK
2f33						CALLMONITOR 
2f33 cd 8a 11			call break_point_state  
2f36				endm  
# End of macro CALLMONITOR
2f36					endif 
2f36			 
2f36					FORTH_DSP 
2f36 cd 94 17			call macro_forth_dsp 
2f39				endm 
# End of macro FORTH_DSP
2f39					 
2f39			; TODO check is string type 
2f39			 
2f39					FORTH_DSP_VALUEHL 
2f39 cd af 17			call macro_dsp_valuehl 
2f3c				endm 
# End of macro FORTH_DSP_VALUEHL
2f3c			; get pointer to string in hl 
2f3c			 
2f3c 7e			.tolow:		ld a, (hl) 
2f3d fe 00				cp 0 
2f3f 28 07				jr z, .tolowdone 
2f41			 
2f41 cd 3c 0d				call to_lower 
2f44			 
2f44 77					ld (hl), a 
2f45 23					inc hl 
2f46 18 f4				jr .tolow 
2f48			 
2f48					 
2f48			 
2f48			 
2f48			; for each char convert to low 
2f48					 
2f48			.tolowdone: 
2f48					NEXTW 
2f48 c3 e9 18			jp macro_next 
2f4b				endm 
# End of macro NEXTW
2f4b			.TCASE: 
2f4b				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
2f4b 48				db WORD_SYS_CORE+52             
2f4c a1 2f			dw .SUBSTR            
2f4e 06				db 5 + 1 
2f4f .. 00			db "TCASE",0              
2f55				endm 
# End of macro CWHEAD
2f55			; | TCASE ( s -- s ) Title case string s  | DONE 
2f55					if DEBUG_FORTH_WORDS_KEY 
2f55						DMARK "TCS" 
2f55 f5				push af  
2f56 3a 6a 2f			ld a, (.dmark)  
2f59 32 7a ee			ld (debug_mark),a  
2f5c 3a 6b 2f			ld a, (.dmark+1)  
2f5f 32 7b ee			ld (debug_mark+1),a  
2f62 3a 6c 2f			ld a, (.dmark+2)  
2f65 32 7c ee			ld (debug_mark+2),a  
2f68 18 03			jr .pastdmark  
2f6a ..			.dmark: db "TCS"  
2f6d f1			.pastdmark: pop af  
2f6e			endm  
# End of macro DMARK
2f6e						CALLMONITOR 
2f6e cd 8a 11			call break_point_state  
2f71				endm  
# End of macro CALLMONITOR
2f71					endif 
2f71			 
2f71					FORTH_DSP 
2f71 cd 94 17			call macro_forth_dsp 
2f74				endm 
# End of macro FORTH_DSP
2f74					 
2f74			; TODO check is string type 
2f74			 
2f74					FORTH_DSP_VALUEHL 
2f74 cd af 17			call macro_dsp_valuehl 
2f77				endm 
# End of macro FORTH_DSP_VALUEHL
2f77			; get pointer to string in hl 
2f77			 
2f77					if DEBUG_FORTH_WORDS 
2f77						DMARK "TC1" 
2f77						CALLMONITOR 
2f77					endif 
2f77			 
2f77					; first time in turn to upper case first char 
2f77			 
2f77 7e					ld a, (hl) 
2f78 c3 92 2f				jp .totsiptou 
2f7b			 
2f7b			 
2f7b 7e			.tot:		ld a, (hl) 
2f7c fe 00				cp 0 
2f7e ca 9e 2f				jp z, .totdone 
2f81			 
2f81					if DEBUG_FORTH_WORDS 
2f81						DMARK "TC2" 
2f81						CALLMONITOR 
2f81					endif 
2f81					; check to see if current char is a space 
2f81			 
2f81 fe 20				cp ' ' 
2f83 28 05				jr z, .totsp 
2f85 cd 3c 0d				call to_lower 
2f88					if DEBUG_FORTH_WORDS 
2f88						DMARK "TC3" 
2f88						CALLMONITOR 
2f88					endif 
2f88 18 0f				jr .totnxt 
2f8a			 
2f8a			.totsp:         ; on a space, find next char which should be upper 
2f8a			 
2f8a					if DEBUG_FORTH_WORDS 
2f8a						DMARK "TC4" 
2f8a						CALLMONITOR 
2f8a					endif 
2f8a					;; 
2f8a			 
2f8a fe 20				cp ' ' 
2f8c 20 04				jr nz, .totsiptou 
2f8e 23					inc hl 
2f8f 7e					ld a, (hl) 
2f90					if DEBUG_FORTH_WORDS 
2f90						DMARK "TC5" 
2f90						CALLMONITOR 
2f90					endif 
2f90 18 f8				jr .totsp 
2f92 fe 00		.totsiptou:    cp 0 
2f94 28 08				jr z, .totdone 
2f96					; not space and not zero term so upper case it 
2f96 cd 33 0d				call to_upper 
2f99			 
2f99					if DEBUG_FORTH_WORDS 
2f99						DMARK "TC6" 
2f99						CALLMONITOR 
2f99					endif 
2f99			 
2f99			 
2f99			.totnxt: 
2f99			 
2f99 77					ld (hl), a 
2f9a 23					inc hl 
2f9b					if DEBUG_FORTH_WORDS 
2f9b						DMARK "TC7" 
2f9b						CALLMONITOR 
2f9b					endif 
2f9b c3 7b 2f				jp .tot 
2f9e			 
2f9e					 
2f9e			 
2f9e			 
2f9e			; for each char convert to low 
2f9e					 
2f9e			.totdone: 
2f9e					if DEBUG_FORTH_WORDS 
2f9e						DMARK "TCd" 
2f9e						CALLMONITOR 
2f9e					endif 
2f9e					NEXTW 
2f9e c3 e9 18			jp macro_next 
2fa1				endm 
# End of macro NEXTW
2fa1			 
2fa1			.SUBSTR: 
2fa1				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
2fa1 48				db WORD_SYS_CORE+52             
2fa2 ff 2f			dw .LEFT            
2fa4 07				db 6 + 1 
2fa5 .. 00			db "SUBSTR",0              
2fac				endm 
# End of macro CWHEAD
2fac			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
2fac			 
2fac					if DEBUG_FORTH_WORDS_KEY 
2fac						DMARK "SST" 
2fac f5				push af  
2fad 3a c1 2f			ld a, (.dmark)  
2fb0 32 7a ee			ld (debug_mark),a  
2fb3 3a c2 2f			ld a, (.dmark+1)  
2fb6 32 7b ee			ld (debug_mark+1),a  
2fb9 3a c3 2f			ld a, (.dmark+2)  
2fbc 32 7c ee			ld (debug_mark+2),a  
2fbf 18 03			jr .pastdmark  
2fc1 ..			.dmark: db "SST"  
2fc4 f1			.pastdmark: pop af  
2fc5			endm  
# End of macro DMARK
2fc5						CALLMONITOR 
2fc5 cd 8a 11			call break_point_state  
2fc8				endm  
# End of macro CALLMONITOR
2fc8					endif 
2fc8			; TODO check string type 
2fc8					FORTH_DSP_VALUEHL 
2fc8 cd af 17			call macro_dsp_valuehl 
2fcb				endm 
# End of macro FORTH_DSP_VALUEHL
2fcb			 
2fcb e5					push hl      ; string length 
2fcc			 
2fcc					FORTH_DSP_POP 
2fcc cd 2f 18			call macro_forth_dsp_pop 
2fcf				endm 
# End of macro FORTH_DSP_POP
2fcf			 
2fcf					FORTH_DSP_VALUEHL 
2fcf cd af 17			call macro_dsp_valuehl 
2fd2				endm 
# End of macro FORTH_DSP_VALUEHL
2fd2			 
2fd2 e5					push hl     ; start char 
2fd3			 
2fd3					FORTH_DSP_POP 
2fd3 cd 2f 18			call macro_forth_dsp_pop 
2fd6				endm 
# End of macro FORTH_DSP_POP
2fd6			 
2fd6			 
2fd6					FORTH_DSP_VALUE 
2fd6 cd 98 17			call macro_forth_dsp_value 
2fd9				endm 
# End of macro FORTH_DSP_VALUE
2fd9			 
2fd9 d1					pop de    ; get start post offset 
2fda			 
2fda 19					add hl, de    ; starting offset 
2fdb			 
2fdb c1					pop bc 
2fdc c5					push bc      ; grab size of string 
2fdd			 
2fdd e5					push hl    ; save string start  
2fde			 
2fde 26 00				ld h, 0 
2fe0 69					ld l, c 
2fe1 23					inc hl 
2fe2 23					inc hl 
2fe3			 
2fe3 cd 8d 0e				call malloc 
2fe6				if DEBUG_FORTH_MALLOC_GUARD 
2fe6 cc 8d 34				call z,malloc_error 
2fe9				endif 
2fe9			 
2fe9 eb					ex de, hl      ; save malloc area for string copy 
2fea e1					pop hl    ; get back source 
2feb c1					pop bc    ; get length of string back 
2fec			 
2fec d5					push de    ; save malloc area for after we push 
2fed ed b0				ldir     ; copy substr 
2fef			 
2fef			 
2fef eb					ex de, hl 
2ff0 3e 00				ld a, 0 
2ff2 77					ld (hl), a   ; term substr 
2ff3			 
2ff3					 
2ff3 e1					pop hl    ; get malloc so we can push it 
2ff4 e5					push hl   ; save so we can free it afterwards 
2ff5			 
2ff5 cd 26 17				call forth_push_str 
2ff8			 
2ff8 e1					pop hl 
2ff9 cd 57 0f				call free 
2ffc			 
2ffc					 
2ffc					 
2ffc			 
2ffc			 
2ffc					NEXTW 
2ffc c3 e9 18			jp macro_next 
2fff				endm 
# End of macro NEXTW
2fff			 
2fff			.LEFT: 
2fff				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
2fff 48				db WORD_SYS_CORE+52             
3000 27 30			dw .RIGHT            
3002 05				db 4 + 1 
3003 .. 00			db "LEFT",0              
3008				endm 
# End of macro CWHEAD
3008			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3008					if DEBUG_FORTH_WORDS_KEY 
3008						DMARK "LEF" 
3008 f5				push af  
3009 3a 1d 30			ld a, (.dmark)  
300c 32 7a ee			ld (debug_mark),a  
300f 3a 1e 30			ld a, (.dmark+1)  
3012 32 7b ee			ld (debug_mark+1),a  
3015 3a 1f 30			ld a, (.dmark+2)  
3018 32 7c ee			ld (debug_mark+2),a  
301b 18 03			jr .pastdmark  
301d ..			.dmark: db "LEF"  
3020 f1			.pastdmark: pop af  
3021			endm  
# End of macro DMARK
3021						CALLMONITOR 
3021 cd 8a 11			call break_point_state  
3024				endm  
# End of macro CALLMONITOR
3024					endif 
3024			 
3024					NEXTW 
3024 c3 e9 18			jp macro_next 
3027				endm 
# End of macro NEXTW
3027			.RIGHT: 
3027				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3027 48				db WORD_SYS_CORE+52             
3028 50 30			dw .STR2NUM            
302a 06				db 5 + 1 
302b .. 00			db "RIGHT",0              
3031				endm 
# End of macro CWHEAD
3031			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3031					if DEBUG_FORTH_WORDS_KEY 
3031						DMARK "RIG" 
3031 f5				push af  
3032 3a 46 30			ld a, (.dmark)  
3035 32 7a ee			ld (debug_mark),a  
3038 3a 47 30			ld a, (.dmark+1)  
303b 32 7b ee			ld (debug_mark+1),a  
303e 3a 48 30			ld a, (.dmark+2)  
3041 32 7c ee			ld (debug_mark+2),a  
3044 18 03			jr .pastdmark  
3046 ..			.dmark: db "RIG"  
3049 f1			.pastdmark: pop af  
304a			endm  
# End of macro DMARK
304a						CALLMONITOR 
304a cd 8a 11			call break_point_state  
304d				endm  
# End of macro CALLMONITOR
304d					endif 
304d			 
304d					NEXTW 
304d c3 e9 18			jp macro_next 
3050				endm 
# End of macro NEXTW
3050			 
3050			 
3050			.STR2NUM: 
3050				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3050 48				db WORD_SYS_CORE+52             
3051 88 30			dw .NUM2STR            
3053 08				db 7 + 1 
3054 .. 00			db "STR2NUM",0              
305c				endm 
# End of macro CWHEAD
305c			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
305c			 
305c			 
305c			; TODO STR type check to do 
305c					if DEBUG_FORTH_WORDS_KEY 
305c						DMARK "S2N" 
305c f5				push af  
305d 3a 71 30			ld a, (.dmark)  
3060 32 7a ee			ld (debug_mark),a  
3063 3a 72 30			ld a, (.dmark+1)  
3066 32 7b ee			ld (debug_mark+1),a  
3069 3a 73 30			ld a, (.dmark+2)  
306c 32 7c ee			ld (debug_mark+2),a  
306f 18 03			jr .pastdmark  
3071 ..			.dmark: db "S2N"  
3074 f1			.pastdmark: pop af  
3075			endm  
# End of macro DMARK
3075						CALLMONITOR 
3075 cd 8a 11			call break_point_state  
3078				endm  
# End of macro CALLMONITOR
3078					endif 
3078			 
3078					;FORTH_DSP 
3078					FORTH_DSP_VALUE 
3078 cd 98 17			call macro_forth_dsp_value 
307b				endm 
# End of macro FORTH_DSP_VALUE
307b					;inc hl 
307b			 
307b eb					ex de, hl 
307c					if DEBUG_FORTH_WORDS 
307c						DMARK "S2a" 
307c						CALLMONITOR 
307c					endif 
307c cd bb 0d				call string_to_uint16 
307f			 
307f					if DEBUG_FORTH_WORDS 
307f						DMARK "S2b" 
307f						CALLMONITOR 
307f					endif 
307f			;		push hl 
307f					FORTH_DSP_POP 
307f cd 2f 18			call macro_forth_dsp_pop 
3082				endm 
# End of macro FORTH_DSP_POP
3082			;		pop hl 
3082					 
3082					if DEBUG_FORTH_WORDS 
3082						DMARK "S2b" 
3082						CALLMONITOR 
3082					endif 
3082 cd 14 17				call forth_push_numhl	 
3085			 
3085				 
3085				       NEXTW 
3085 c3 e9 18			jp macro_next 
3088				endm 
# End of macro NEXTW
3088			.NUM2STR: 
3088				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3088 48				db WORD_SYS_CORE+52             
3089 97 30			dw .CONCAT            
308b 08				db 7 + 1 
308c .. 00			db "NUM2STR",0              
3094				endm 
# End of macro CWHEAD
3094			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3094			 
3094			;		; malloc a string to target 
3094			;		ld hl, 10     ; TODO max string size should be fine 
3094			;		call malloc 
3094			;		push hl    ; save malloc location 
3094			; 
3094			; 
3094			;; TODO check int type 
3094			;		FORTH_DSP_VALUEHL 
3094			;		ld a, l 
3094			;		call DispAToASCII   
3094			;;TODO need to chage above call to dump into string 
3094			; 
3094			; 
3094			 
3094				       NEXTW 
3094 c3 e9 18			jp macro_next 
3097				endm 
# End of macro NEXTW
3097			 
3097			.CONCAT: 
3097				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3097 48				db WORD_SYS_CORE+52             
3098 f6 30			dw .FIND            
309a 07				db 6 + 1 
309b .. 00			db "CONCAT",0              
30a2				endm 
# End of macro CWHEAD
30a2			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
30a2			 
30a2			; TODO check string type 
30a2			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
30a2			 
30a2					if DEBUG_FORTH_WORDS_KEY 
30a2						DMARK "CON" 
30a2 f5				push af  
30a3 3a b7 30			ld a, (.dmark)  
30a6 32 7a ee			ld (debug_mark),a  
30a9 3a b8 30			ld a, (.dmark+1)  
30ac 32 7b ee			ld (debug_mark+1),a  
30af 3a b9 30			ld a, (.dmark+2)  
30b2 32 7c ee			ld (debug_mark+2),a  
30b5 18 03			jr .pastdmark  
30b7 ..			.dmark: db "CON"  
30ba f1			.pastdmark: pop af  
30bb			endm  
# End of macro DMARK
30bb						CALLMONITOR 
30bb cd 8a 11			call break_point_state  
30be				endm  
# End of macro CALLMONITOR
30be					endif 
30be			 
30be			 
30be					FORTH_DSP_VALUE 
30be cd 98 17			call macro_forth_dsp_value 
30c1				endm 
# End of macro FORTH_DSP_VALUE
30c1 e5					push hl   ; s2 
30c2			 
30c2					FORTH_DSP_POP 
30c2 cd 2f 18			call macro_forth_dsp_pop 
30c5				endm 
# End of macro FORTH_DSP_POP
30c5			 
30c5					FORTH_DSP_VALUE 
30c5 cd 98 17			call macro_forth_dsp_value 
30c8				endm 
# End of macro FORTH_DSP_VALUE
30c8			 
30c8 e5					push hl   ; s1 
30c9			 
30c9					FORTH_DSP_POP 
30c9 cd 2f 18			call macro_forth_dsp_pop 
30cc				endm 
# End of macro FORTH_DSP_POP
30cc					 
30cc			 
30cc					; copy s1 
30cc			 
30cc				 
30cc					; save ptr 
30cc e1					pop hl  
30cd e5					push hl 
30ce 3e 00				ld a, 0 
30d0 cd 2f 0e				call strlent 
30d3					;inc hl    ; zer0 
30d3 06 00				ld b, 0 
30d5 4d					ld c, l 
30d6 e1					pop hl		 
30d7 11 75 e3				ld de, scratch	 
30da					if DEBUG_FORTH_WORDS 
30da						DMARK "CO1" 
30da						CALLMONITOR 
30da					endif 
30da ed b0				ldir 
30dc			 
30dc e1					pop hl 
30dd e5					push hl 
30de d5					push de 
30df			 
30df			 
30df 3e 00				ld a, 0 
30e1 cd 2f 0e				call strlent 
30e4 23					inc hl    ; zer0 
30e5 23					inc hl 
30e6 06 00				ld b, 0 
30e8 4d					ld c, l 
30e9 d1					pop de 
30ea e1					pop hl		 
30eb					if DEBUG_FORTH_WORDS 
30eb						DMARK "CO2" 
30eb						CALLMONITOR 
30eb					endif 
30eb ed b0				ldir 
30ed			 
30ed			 
30ed			 
30ed 21 75 e3				ld hl, scratch 
30f0					if DEBUG_FORTH_WORDS 
30f0						DMARK "CO5" 
30f0						CALLMONITOR 
30f0					endif 
30f0			 
30f0 cd 26 17				call forth_push_str 
30f3			 
30f3			 
30f3			 
30f3			 
30f3				       NEXTW 
30f3 c3 e9 18			jp macro_next 
30f6				endm 
# End of macro NEXTW
30f6			 
30f6			 
30f6			.FIND: 
30f6				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
30f6 4b				db WORD_SYS_CORE+55             
30f7 44 31			dw .LEN            
30f9 05				db 4 + 1 
30fa .. 00			db "FIND",0              
30ff				endm 
# End of macro CWHEAD
30ff			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
30ff			 
30ff					if DEBUG_FORTH_WORDS_KEY 
30ff						DMARK "FND" 
30ff f5				push af  
3100 3a 14 31			ld a, (.dmark)  
3103 32 7a ee			ld (debug_mark),a  
3106 3a 15 31			ld a, (.dmark+1)  
3109 32 7b ee			ld (debug_mark+1),a  
310c 3a 16 31			ld a, (.dmark+2)  
310f 32 7c ee			ld (debug_mark+2),a  
3112 18 03			jr .pastdmark  
3114 ..			.dmark: db "FND"  
3117 f1			.pastdmark: pop af  
3118			endm  
# End of macro DMARK
3118						CALLMONITOR 
3118 cd 8a 11			call break_point_state  
311b				endm  
# End of macro CALLMONITOR
311b					endif 
311b			 
311b			; TODO check string type 
311b					FORTH_DSP_VALUE 
311b cd 98 17			call macro_forth_dsp_value 
311e				endm 
# End of macro FORTH_DSP_VALUE
311e			 
311e e5					push hl    
311f 7e					ld a,(hl)    ; char to find   
3120			; TODO change char to substr 
3120			 
3120 f5					push af 
3121					 
3121			 
3121			 
3121					if DEBUG_FORTH_WORDS 
3121						DMARK "FN1" 
3121						CALLMONITOR 
3121					endif 
3121			 
3121					FORTH_DSP_POP 
3121 cd 2f 18			call macro_forth_dsp_pop 
3124				endm 
# End of macro FORTH_DSP_POP
3124			 
3124					; string to search 
3124			 
3124					FORTH_DSP_VALUE 
3124 cd 98 17			call macro_forth_dsp_value 
3127				endm 
# End of macro FORTH_DSP_VALUE
3127			 
3127 d1					pop de  ; d is char to find  
3128			 
3128					if DEBUG_FORTH_WORDS 
3128						DMARK "FN2" 
3128						CALLMONITOR 
3128					endif 
3128					 
3128 01 00 00				ld bc, 0 
312b 7e			.findchar:      ld a,(hl) 
312c fe 00				cp 0   		 
312e 28 0b				jr z, .finddone     
3130 ba					cp d 
3131 28 04				jr z, .foundchar 
3133 03					inc bc 
3134 23					inc hl 
3135					if DEBUG_FORTH_WORDS 
3135						DMARK "FN3" 
3135						CALLMONITOR 
3135					endif 
3135 18 f4				jr .findchar 
3137			 
3137			 
3137 c5			.foundchar:	push bc 
3138 e1					pop hl 
3139 18 03				jr .findexit 
313b			 
313b			 
313b							 
313b			 
313b			.finddone:     ; got to end of string with no find 
313b 21 00 00				ld hl, 0 
313e			.findexit: 
313e			 
313e					if DEBUG_FORTH_WORDS 
313e						DMARK "FNd" 
313e						CALLMONITOR 
313e					endif 
313e cd 14 17			call forth_push_numhl 
3141			 
3141				       NEXTW 
3141 c3 e9 18			jp macro_next 
3144				endm 
# End of macro NEXTW
3144			 
3144			.LEN: 
3144				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
3144 4c				db WORD_SYS_CORE+56             
3145 79 31			dw .CHAR            
3147 06				db 5 + 1 
3148 .. 00			db "COUNT",0              
314e				endm 
# End of macro CWHEAD
314e			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
314e			 
314e					if DEBUG_FORTH_WORDS_KEY 
314e						DMARK "CNT" 
314e f5				push af  
314f 3a 63 31			ld a, (.dmark)  
3152 32 7a ee			ld (debug_mark),a  
3155 3a 64 31			ld a, (.dmark+1)  
3158 32 7b ee			ld (debug_mark+1),a  
315b 3a 65 31			ld a, (.dmark+2)  
315e 32 7c ee			ld (debug_mark+2),a  
3161 18 03			jr .pastdmark  
3163 ..			.dmark: db "CNT"  
3166 f1			.pastdmark: pop af  
3167			endm  
# End of macro DMARK
3167						CALLMONITOR 
3167 cd 8a 11			call break_point_state  
316a				endm  
# End of macro CALLMONITOR
316a					endif 
316a			; TODO check string type 
316a					FORTH_DSP 
316a cd 94 17			call macro_forth_dsp 
316d				endm 
# End of macro FORTH_DSP
316d					;v5FORTH_DSP_VALUE 
316d			 
316d 23					inc hl 
316e			 
316e 3e 00				ld a, 0 
3170 cd 2f 0e				call strlent 
3173			 
3173 cd 14 17				call forth_push_numhl 
3176			 
3176			 
3176			 
3176				       NEXTW 
3176 c3 e9 18			jp macro_next 
3179				endm 
# End of macro NEXTW
3179			.CHAR: 
3179				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
3179 4d				db WORD_SYS_CORE+57             
317a af 31			dw .ENDSTR            
317c 05				db 4 + 1 
317d .. 00			db "CHAR",0              
3182				endm 
# End of macro CWHEAD
3182			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
3182					if DEBUG_FORTH_WORDS_KEY 
3182						DMARK "CHR" 
3182 f5				push af  
3183 3a 97 31			ld a, (.dmark)  
3186 32 7a ee			ld (debug_mark),a  
3189 3a 98 31			ld a, (.dmark+1)  
318c 32 7b ee			ld (debug_mark+1),a  
318f 3a 99 31			ld a, (.dmark+2)  
3192 32 7c ee			ld (debug_mark+2),a  
3195 18 03			jr .pastdmark  
3197 ..			.dmark: db "CHR"  
319a f1			.pastdmark: pop af  
319b			endm  
# End of macro DMARK
319b						CALLMONITOR 
319b cd 8a 11			call break_point_state  
319e				endm  
# End of macro CALLMONITOR
319e					endif 
319e					FORTH_DSP 
319e cd 94 17			call macro_forth_dsp 
31a1				endm 
# End of macro FORTH_DSP
31a1					;v5 FORTH_DSP_VALUE 
31a1 23					inc hl      ; now at start of numeric as string 
31a2			 
31a2			;		push hl 
31a2			 
31a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31a2 cd 2f 18			call macro_forth_dsp_pop 
31a5				endm 
# End of macro FORTH_DSP_POP
31a5			 
31a5			;		pop hl 
31a5			 
31a5					; push the content of a onto the stack as a value 
31a5			 
31a5 7e					ld a,(hl)   ; get char 
31a6 26 00				ld h,0 
31a8 6f					ld l,a 
31a9 cd 14 17				call forth_push_numhl 
31ac			 
31ac				       NEXTW 
31ac c3 e9 18			jp macro_next 
31af				endm 
# End of macro NEXTW
31af			 
31af			 
31af			 
31af			 
31af			.ENDSTR: 
31af			; eof 
31af			 
# End of file forth_words_str.asm
31af			include "forth_words_key.asm" 
31af			 
31af			; | ## Keyboard Words 
31af			 
31af			.KEY: 
31af				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
31af 3e				db WORD_SYS_CORE+42             
31b0 df 31			dw .WAITK            
31b2 04				db 3 + 1 
31b3 .. 00			db "KEY",0              
31b7				endm 
# End of macro CWHEAD
31b7			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
31b7			 
31b7					if DEBUG_FORTH_WORDS_KEY 
31b7						DMARK "KEY" 
31b7 f5				push af  
31b8 3a cc 31			ld a, (.dmark)  
31bb 32 7a ee			ld (debug_mark),a  
31be 3a cd 31			ld a, (.dmark+1)  
31c1 32 7b ee			ld (debug_mark+1),a  
31c4 3a ce 31			ld a, (.dmark+2)  
31c7 32 7c ee			ld (debug_mark+2),a  
31ca 18 03			jr .pastdmark  
31cc ..			.dmark: db "KEY"  
31cf f1			.pastdmark: pop af  
31d0			endm  
# End of macro DMARK
31d0						CALLMONITOR 
31d0 cd 8a 11			call break_point_state  
31d3				endm  
# End of macro CALLMONITOR
31d3					endif 
31d3			; TODO currently waits 
31d3 cd a4 47				call cin_wait 
31d6 6f					ld l, a 
31d7 26 00				ld h, 0 
31d9 cd 14 17				call forth_push_numhl 
31dc					NEXTW 
31dc c3 e9 18			jp macro_next 
31df				endm 
# End of macro NEXTW
31df			.WAITK: 
31df				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
31df 3f				db WORD_SYS_CORE+43             
31e0 11 32			dw .ACCEPT            
31e2 06				db 5 + 1 
31e3 .. 00			db "WAITK",0              
31e9				endm 
# End of macro CWHEAD
31e9			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
31e9					if DEBUG_FORTH_WORDS_KEY 
31e9						DMARK "WAI" 
31e9 f5				push af  
31ea 3a fe 31			ld a, (.dmark)  
31ed 32 7a ee			ld (debug_mark),a  
31f0 3a ff 31			ld a, (.dmark+1)  
31f3 32 7b ee			ld (debug_mark+1),a  
31f6 3a 00 32			ld a, (.dmark+2)  
31f9 32 7c ee			ld (debug_mark+2),a  
31fc 18 03			jr .pastdmark  
31fe ..			.dmark: db "WAI"  
3201 f1			.pastdmark: pop af  
3202			endm  
# End of macro DMARK
3202						CALLMONITOR 
3202 cd 8a 11			call break_point_state  
3205				endm  
# End of macro CALLMONITOR
3205					endif 
3205 cd a4 47				call cin_wait 
3208 6f					ld l, a 
3209 26 00				ld h, 0 
320b cd 14 17				call forth_push_numhl 
320e					NEXTW 
320e c3 e9 18			jp macro_next 
3211				endm 
# End of macro NEXTW
3211			.ACCEPT: 
3211				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
3211 40				db WORD_SYS_CORE+44             
3212 53 32			dw .EDIT            
3214 07				db 6 + 1 
3215 .. 00			db "ACCEPT",0              
321c				endm 
# End of macro CWHEAD
321c			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
321c					; TODO crashes on push 
321c					if DEBUG_FORTH_WORDS_KEY 
321c						DMARK "ACC" 
321c f5				push af  
321d 3a 31 32			ld a, (.dmark)  
3220 32 7a ee			ld (debug_mark),a  
3223 3a 32 32			ld a, (.dmark+1)  
3226 32 7b ee			ld (debug_mark+1),a  
3229 3a 33 32			ld a, (.dmark+2)  
322c 32 7c ee			ld (debug_mark+2),a  
322f 18 03			jr .pastdmark  
3231 ..			.dmark: db "ACC"  
3234 f1			.pastdmark: pop af  
3235			endm  
# End of macro DMARK
3235						CALLMONITOR 
3235 cd 8a 11			call break_point_state  
3238				endm  
# End of macro CALLMONITOR
3238					endif 
3238 21 73 e5				ld hl, os_input 
323b 3e 00				ld a, 0 
323d 77					ld (hl),a 
323e 3a 5e eb				ld a,(f_cursor_ptr) 
3241 16 64				ld d, 100 
3243 0e 00				ld c, 0 
3245 1e 28				ld e, 40 
3247 cd f3 09				call input_str 
324a					; TODO perhaps do a type check and wrap in quotes if not a number 
324a 21 73 e5				ld hl, os_input 
324d					if DEBUG_FORTH_WORDS 
324d						DMARK "AC1" 
324d						CALLMONITOR 
324d					endif 
324d cd 26 17				call forth_push_str 
3250					NEXTW 
3250 c3 e9 18			jp macro_next 
3253				endm 
# End of macro NEXTW
3253			 
3253			.EDIT: 
3253				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
3253 40				db WORD_SYS_CORE+44             
3254 c0 32			dw .ENDKEY            
3256 05				db 4 + 1 
3257 .. 00			db "EDIT",0              
325c				endm 
# End of macro CWHEAD
325c			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
325c			 
325c					; TODO does not copy from stack 
325c					if DEBUG_FORTH_WORDS_KEY 
325c						DMARK "EDT" 
325c f5				push af  
325d 3a 71 32			ld a, (.dmark)  
3260 32 7a ee			ld (debug_mark),a  
3263 3a 72 32			ld a, (.dmark+1)  
3266 32 7b ee			ld (debug_mark+1),a  
3269 3a 73 32			ld a, (.dmark+2)  
326c 32 7c ee			ld (debug_mark+2),a  
326f 18 03			jr .pastdmark  
3271 ..			.dmark: db "EDT"  
3274 f1			.pastdmark: pop af  
3275			endm  
# End of macro DMARK
3275						CALLMONITOR 
3275 cd 8a 11			call break_point_state  
3278				endm  
# End of macro CALLMONITOR
3278					endif 
3278			 
3278					FORTH_DSP 
3278 cd 94 17			call macro_forth_dsp 
327b				endm 
# End of macro FORTH_DSP
327b					;v5 FORTH_DSP_VALUE 
327b 23					inc hl    ; TODO do type check 
327c			 
327c e5					push hl 
327d 3e 00				ld a, 0 
327f cd 2f 0e				call strlent 
3282 23					inc hl 
3283			 
3283 06 00				ld b, 0 
3285 4d					ld c, l 
3286			 
3286 e1					pop hl 
3287 11 73 e5				ld de, os_input 
328a					if DEBUG_FORTH_WORDS_KEY 
328a						DMARK "EDc" 
328a f5				push af  
328b 3a 9f 32			ld a, (.dmark)  
328e 32 7a ee			ld (debug_mark),a  
3291 3a a0 32			ld a, (.dmark+1)  
3294 32 7b ee			ld (debug_mark+1),a  
3297 3a a1 32			ld a, (.dmark+2)  
329a 32 7c ee			ld (debug_mark+2),a  
329d 18 03			jr .pastdmark  
329f ..			.dmark: db "EDc"  
32a2 f1			.pastdmark: pop af  
32a3			endm  
# End of macro DMARK
32a3						CALLMONITOR 
32a3 cd 8a 11			call break_point_state  
32a6				endm  
# End of macro CALLMONITOR
32a6					endif 
32a6 ed b0				ldir 
32a8			 
32a8			 
32a8 21 73 e5				ld hl, os_input 
32ab					;ld a, 0 
32ab					;ld (hl),a 
32ab 3a 5e eb				ld a,(f_cursor_ptr) 
32ae 16 64				ld d, 100 
32b0 0e 00				ld c, 0 
32b2 1e 28				ld e, 40 
32b4 cd f3 09				call input_str 
32b7					; TODO perhaps do a type check and wrap in quotes if not a number 
32b7 21 73 e5				ld hl, os_input 
32ba					if DEBUG_FORTH_WORDS 
32ba						DMARK "ED1" 
32ba						CALLMONITOR 
32ba					endif 
32ba cd 26 17				call forth_push_str 
32bd					NEXTW 
32bd c3 e9 18			jp macro_next 
32c0				endm 
# End of macro NEXTW
32c0			 
32c0			 
32c0			 
32c0			.ENDKEY: 
32c0			; eof 
32c0			 
# End of file forth_words_key.asm
32c0			 
32c0			if STORAGE_SE 
32c0			   	include "forth_words_storage.asm" 
32c0			endif 
32c0				include "forth_words_device.asm" 
32c0			; Device related words 
32c0			 
32c0			; | ## Device Words 
32c0			 
32c0			if SOUND_ENABLE 
32c0			.NOTE: 
32c0				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
32c0			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
32c0					if DEBUG_FORTH_WORDS_KEY 
32c0						DMARK "NTE" 
32c0						CALLMONITOR 
32c0					endif 
32c0			 
32c0				 
32c0			 
32c0					NEXTW 
32c0			.AFTERSOUND: 
32c0			endif 
32c0			 
32c0			 
32c0			USE_GPIO: equ 0 
32c0			 
32c0			if USE_GPIO 
32c0			.GP1: 
32c0				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
32c0			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
32c0					NEXTW 
32c0			.GP2: 
32c0				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
32c0			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
32c0			 
32c0					NEXTW 
32c0			 
32c0			.GP3: 
32c0				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
32c0			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
32c0			 
32c0					NEXTW 
32c0			 
32c0			.GP4: 
32c0				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
32c0			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
32c0			 
32c0					NEXTW 
32c0			.SIN: 
32c0			 
32c0			 
32c0			endif 
32c0			 
32c0			 
32c0				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
32c0 33				db WORD_SYS_CORE+31             
32c1 f5 32			dw .SOUT            
32c3 03				db 2 + 1 
32c4 .. 00			db "IN",0              
32c7				endm 
# End of macro CWHEAD
32c7			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
32c7					if DEBUG_FORTH_WORDS_KEY 
32c7						DMARK "IN." 
32c7 f5				push af  
32c8 3a dc 32			ld a, (.dmark)  
32cb 32 7a ee			ld (debug_mark),a  
32ce 3a dd 32			ld a, (.dmark+1)  
32d1 32 7b ee			ld (debug_mark+1),a  
32d4 3a de 32			ld a, (.dmark+2)  
32d7 32 7c ee			ld (debug_mark+2),a  
32da 18 03			jr .pastdmark  
32dc ..			.dmark: db "IN."  
32df f1			.pastdmark: pop af  
32e0			endm  
# End of macro DMARK
32e0						CALLMONITOR 
32e0 cd 8a 11			call break_point_state  
32e3				endm  
# End of macro CALLMONITOR
32e3					endif 
32e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32e3 cd af 17			call macro_dsp_valuehl 
32e6				endm 
# End of macro FORTH_DSP_VALUEHL
32e6			 
32e6 e5					push hl 
32e7			 
32e7					; destroy value TOS 
32e7			 
32e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32e7 cd 2f 18			call macro_forth_dsp_pop 
32ea				endm 
# End of macro FORTH_DSP_POP
32ea			 
32ea					; one value on hl get other one back 
32ea			 
32ea c1					pop bc 
32eb			 
32eb					; do the sub 
32eb			;		ex de, hl 
32eb			 
32eb ed 68				in l,(c) 
32ed			 
32ed					; save it 
32ed			 
32ed 26 00				ld h,0 
32ef			 
32ef					; TODO push value back onto stack for another op etc 
32ef			 
32ef cd 14 17				call forth_push_numhl 
32f2					NEXTW 
32f2 c3 e9 18			jp macro_next 
32f5				endm 
# End of macro NEXTW
32f5			.SOUT: 
32f5				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
32f5 34				db WORD_SYS_CORE+32             
32f6 2c 33			dw .SPIO            
32f8 04				db 3 + 1 
32f9 .. 00			db "OUT",0              
32fd				endm 
# End of macro CWHEAD
32fd			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
32fd					if DEBUG_FORTH_WORDS_KEY 
32fd						DMARK "OUT" 
32fd f5				push af  
32fe 3a 12 33			ld a, (.dmark)  
3301 32 7a ee			ld (debug_mark),a  
3304 3a 13 33			ld a, (.dmark+1)  
3307 32 7b ee			ld (debug_mark+1),a  
330a 3a 14 33			ld a, (.dmark+2)  
330d 32 7c ee			ld (debug_mark+2),a  
3310 18 03			jr .pastdmark  
3312 ..			.dmark: db "OUT"  
3315 f1			.pastdmark: pop af  
3316			endm  
# End of macro DMARK
3316						CALLMONITOR 
3316 cd 8a 11			call break_point_state  
3319				endm  
# End of macro CALLMONITOR
3319					endif 
3319			 
3319					; get port 
3319			 
3319					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3319 cd af 17			call macro_dsp_valuehl 
331c				endm 
# End of macro FORTH_DSP_VALUEHL
331c			 
331c e5					push hl 
331d			 
331d					; destroy value TOS 
331d			 
331d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
331d cd 2f 18			call macro_forth_dsp_pop 
3320				endm 
# End of macro FORTH_DSP_POP
3320			 
3320					; get byte to send 
3320			 
3320					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3320 cd af 17			call macro_dsp_valuehl 
3323				endm 
# End of macro FORTH_DSP_VALUEHL
3323			 
3323			;		push hl 
3323			 
3323					; destroy value TOS 
3323			 
3323					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3323 cd 2f 18			call macro_forth_dsp_pop 
3326				endm 
# End of macro FORTH_DSP_POP
3326			 
3326					; one value on hl get other one back 
3326			 
3326			;		pop hl 
3326			 
3326 c1					pop bc 
3327			 
3327					if DEBUG_FORTH_WORDS 
3327						DMARK "OUT" 
3327						CALLMONITOR 
3327					endif 
3327			 
3327 ed 69				out (c), l 
3329			 
3329					NEXTW 
3329 c3 e9 18			jp macro_next 
332c				endm 
# End of macro NEXTW
332c			 
332c			 
332c			.SPIO: 
332c			 
332c			if STORAGE_SE 
332c				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
332c			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
332c			 
332c					call spi_ce_low 
332c			    NEXTW 
332c			 
332c			.SPICEH: 
332c				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
332c			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
332c			 
332c					call spi_ce_high 
332c			    NEXTW 
332c			 
332c			 
332c			.SPIOb: 
332c			 
332c				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
332c			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
332c			 
332c					; get port 
332c			 
332c			 
332c					; get byte to send 
332c			 
332c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
332c			 
332c			;		push hl    ; u1  
332c			 
332c					; destroy value TOS 
332c			 
332c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
332c			 
332c					; one value on hl get other one back 
332c			 
332c			;		pop hl   ; u2 - addr 
332c			 
332c					; TODO Send SPI byte 
332c			 
332c					ld a, l 
332c					call spi_send_byte 
332c			 
332c					NEXTW 
332c			 
332c			.SPII: 
332c				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
332c			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
332c			 
332c					; TODO Get SPI byte 
332c			 
332c					call spi_read_byte 
332c			 
332c					ld h, 0 
332c					ld l, a 
332c					call forth_push_numhl 
332c			 
332c					NEXTW 
332c			 
332c			 
332c			 
332c			.SESEL: 
332c				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
332c			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
332c					if DEBUG_FORTH_WORDS_KEY 
332c						DMARK "BNK" 
332c						CALLMONITOR 
332c					endif 
332c			 
332c					ld a, 255 
332c					ld (spi_cartdev), a 
332c			 
332c					; get bank 
332c			 
332c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
332c			 
332c			;		push hl 
332c			 
332c					; destroy value TOS 
332c			 
332c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
332c			 
332c					; one value on hl get other one back 
332c			 
332c			;		pop hl 
332c			 
332c			 
332c					ld c, SPI_CE_HIGH 
332c			 
332c					ld a, l 
332c			 
332c					if DEBUG_FORTH_WORDS 
332c						DMARK "BNK" 
332c						CALLMONITOR 
332c					endif 
332c			 
332c					; active low 
332c			 
332c					cp 0 
332c					jr z, .bset 
332c					cp 1 
332c					jr nz, .b2 
332c					res 0, c 
332c			.b2:		cp 2 
332c					jr nz, .b3 
332c					res 1, c 
332c			.b3:		cp 3 
332c					jr nz, .b4 
332c					res 2, c 
332c			.b4:		cp 4 
332c					jr nz, .b5 
332c					res 3, c 
332c			.b5:		cp 5 
332c					jr nz, .bset 
332c					res 4, c 
332c			 
332c			.bset: 
332c					ld a, c 
332c					ld (spi_device),a 
332c					if DEBUG_FORTH_WORDS 
332c						DMARK "BN2" 
332c						CALLMONITOR 
332c					endif 
332c			 
332c					NEXTW 
332c			 
332c			.CARTDEV: 
332c				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
332c			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
332c					if DEBUG_FORTH_WORDS_KEY 
332c						DMARK "CDV" 
332c						CALLMONITOR 
332c					endif 
332c			 
332c					; disable se storage bank selection 
332c			 
332c					ld a, SPI_CE_HIGH		; ce high 
332c					ld (spi_device), a 
332c			 
332c					; get bank 
332c			 
332c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
332c			 
332c			;		push hl 
332c			 
332c					; destroy value TOS 
332c			 
332c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
332c			 
332c					; one value on hl get other one back 
332c			 
332c			;		pop hl 
332c			 
332c					; active low 
332c			 
332c					ld c, 255 
332c			 
332c					ld a, l 
332c					if DEBUG_FORTH_WORDS 
332c						DMARK "CDV" 
332c						CALLMONITOR 
332c					endif 
332c					cp 0 
332c					jr z, .cset 
332c					cp 1 
332c					jr nz, .c2 
332c					res 0, c 
332c			.c2:		cp 2 
332c					jr nz, .c3 
332c					res 1, c 
332c			.c3:		cp 3 
332c					jr nz, .c4 
332c					res 2, c 
332c			.c4:		cp 4 
332c					jr nz, .c5 
332c					res 3, c 
332c			.c5:		cp 5 
332c					jr nz, .c6 
332c					res 4, c 
332c			.c6:		cp 6 
332c					jr nz, .c7 
332c					res 5, c 
332c			.c7:		cp 7 
332c					jr nz, .c8 
332c					res 6, c 
332c			.c8:		cp 8 
332c					jr nz, .cset 
332c					res 7, c 
332c			.cset:		ld a, c 
332c					ld (spi_cartdev),a 
332c			 
332c					if DEBUG_FORTH_WORDS 
332c						DMARK "CD2" 
332c						CALLMONITOR 
332c					endif 
332c					NEXTW 
332c			endif 
332c			 
332c			.ENDDEVICE: 
332c			; eof 
332c			 
# End of file forth_words_device.asm
332c			 
332c			; var handler 
332c			 
332c			 
332c			.VARS: 
332c				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
332c 78				db WORD_SYS_CORE+100             
332d 44 33			dw .V0Q            
332f 04				db 3 + 1 
3330 .. 00			db "V0!",0              
3334				endm 
# End of macro CWHEAD
3334			;| V0! ( u1 -- )  Store value to v0  | DONE 
3334			 
3334					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3334 cd af 17			call macro_dsp_valuehl 
3337				endm 
# End of macro FORTH_DSP_VALUEHL
3337			 
3337 11 28 eb				ld de, cli_var_array 
333a			 
333a eb					ex de, hl 
333b 73					ld (hl), e 
333c 23					inc hl 
333d 72					ld (hl), d 
333e			 
333e					; destroy value TOS 
333e			 
333e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
333e cd 2f 18			call macro_forth_dsp_pop 
3341				endm 
# End of macro FORTH_DSP_POP
3341			 
3341				       NEXTW 
3341 c3 e9 18			jp macro_next 
3344				endm 
# End of macro NEXTW
3344			.V0Q: 
3344				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
3344 79				db WORD_SYS_CORE+101             
3345 55 33			dw .V1S            
3347 04				db 3 + 1 
3348 .. 00			db "V0@",0              
334c				endm 
# End of macro CWHEAD
334c			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
334c 2a 28 eb				ld hl, (cli_var_array) 
334f cd 14 17				call forth_push_numhl 
3352			 
3352				       NEXTW 
3352 c3 e9 18			jp macro_next 
3355				endm 
# End of macro NEXTW
3355			.V1S: 
3355				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
3355 7a				db WORD_SYS_CORE+102             
3356 6d 33			dw .V1Q            
3358 04				db 3 + 1 
3359 .. 00			db "V1!",0              
335d				endm 
# End of macro CWHEAD
335d			;| V1! ( u1 -- )  Store value to v1 | DONE 
335d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
335d cd af 17			call macro_dsp_valuehl 
3360				endm 
# End of macro FORTH_DSP_VALUEHL
3360			 
3360 11 2a eb				ld de, cli_var_array+2 
3363				 
3363 eb					ex de, hl 
3364 73					ld (hl), e 
3365 23					inc hl 
3366 72					ld (hl), d 
3367			 
3367					; destroy value TOS 
3367			 
3367					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3367 cd 2f 18			call macro_forth_dsp_pop 
336a				endm 
# End of macro FORTH_DSP_POP
336a				       NEXTW 
336a c3 e9 18			jp macro_next 
336d				endm 
# End of macro NEXTW
336d			.V1Q: 
336d				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
336d 7b				db WORD_SYS_CORE+103             
336e 7e 33			dw .V2S            
3370 04				db 3 + 1 
3371 .. 00			db "V1@",0              
3375				endm 
# End of macro CWHEAD
3375			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
3375 2a 2a eb				ld hl, (cli_var_array+2) 
3378 cd 14 17				call forth_push_numhl 
337b				       NEXTW 
337b c3 e9 18			jp macro_next 
337e				endm 
# End of macro NEXTW
337e			.V2S: 
337e				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
337e 7c				db WORD_SYS_CORE+104             
337f 96 33			dw .V2Q            
3381 04				db 3 + 1 
3382 .. 00			db "V2!",0              
3386				endm 
# End of macro CWHEAD
3386			;| V2! ( u1 -- )  Store value to v2 | DONE 
3386					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3386 cd af 17			call macro_dsp_valuehl 
3389				endm 
# End of macro FORTH_DSP_VALUEHL
3389			 
3389 11 2c eb				ld de, cli_var_array+4 
338c				 
338c eb					ex de, hl 
338d 73					ld (hl), e 
338e 23					inc hl 
338f 72					ld (hl), d 
3390			 
3390					; destroy value TOS 
3390			 
3390					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3390 cd 2f 18			call macro_forth_dsp_pop 
3393				endm 
# End of macro FORTH_DSP_POP
3393				       NEXTW 
3393 c3 e9 18			jp macro_next 
3396				endm 
# End of macro NEXTW
3396			.V2Q: 
3396				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
3396 7d				db WORD_SYS_CORE+105             
3397 a7 33			dw .V3S            
3399 04				db 3 + 1 
339a .. 00			db "V2@",0              
339e				endm 
# End of macro CWHEAD
339e			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
339e 2a 2c eb				ld hl, (cli_var_array+4) 
33a1 cd 14 17				call forth_push_numhl 
33a4				       NEXTW 
33a4 c3 e9 18			jp macro_next 
33a7				endm 
# End of macro NEXTW
33a7			.V3S: 
33a7				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
33a7 7c				db WORD_SYS_CORE+104             
33a8 bf 33			dw .V3Q            
33aa 04				db 3 + 1 
33ab .. 00			db "V3!",0              
33af				endm 
# End of macro CWHEAD
33af			;| V3! ( u1 -- )  Store value to v3 | DONE 
33af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33af cd af 17			call macro_dsp_valuehl 
33b2				endm 
# End of macro FORTH_DSP_VALUEHL
33b2			 
33b2 11 2e eb				ld de, cli_var_array+6 
33b5				 
33b5 eb					ex de, hl 
33b6 73					ld (hl), e 
33b7 23					inc hl 
33b8 72					ld (hl), d 
33b9			 
33b9					; destroy value TOS 
33b9			 
33b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33b9 cd 2f 18			call macro_forth_dsp_pop 
33bc				endm 
# End of macro FORTH_DSP_POP
33bc				       NEXTW 
33bc c3 e9 18			jp macro_next 
33bf				endm 
# End of macro NEXTW
33bf			.V3Q: 
33bf				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
33bf 7d				db WORD_SYS_CORE+105             
33c0 d0 33			dw .END            
33c2 04				db 3 + 1 
33c3 .. 00			db "V3@",0              
33c7				endm 
# End of macro CWHEAD
33c7			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
33c7 2a 2e eb				ld hl, (cli_var_array+6) 
33ca cd 14 17				call forth_push_numhl 
33cd				       NEXTW 
33cd c3 e9 18			jp macro_next 
33d0				endm 
# End of macro NEXTW
33d0			 
33d0			 
33d0			 
33d0			 
33d0			 
33d0			; end of dict marker 
33d0			 
33d0 00			.END:    db WORD_SYS_END 
33d1 00 00			dw 0 
33d3 00				db 0 
33d4			 
33d4			; use to jp here for user dict words to save on macro expansion  
33d4			 
33d4			user_dict_next: 
33d4				NEXTW 
33d4 c3 e9 18			jp macro_next 
33d7				endm 
# End of macro NEXTW
33d7			 
33d7			 
33d7			user_exec: 
33d7				;    ld hl, <word code> 
33d7				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
33d7				;    call forthexec 
33d7				;    jp user_dict_next   (NEXT) 
33d7			        ;    <word code bytes> 
33d7 eb				ex de, hl 
33d8 2a 76 e6			ld hl,(os_tok_ptr) 
33db				 
33db				FORTH_RSP_NEXT 
33db cd be 16			call macro_forth_rsp_next 
33de				endm 
# End of macro FORTH_RSP_NEXT
33de			 
33de			if DEBUG_FORTH_UWORD 
33de						DMARK "UEX" 
33de				CALLMONITOR 
33de			endif 
33de			 
33de			 
33de			 
33de eb				ex de, hl 
33df 22 76 e6			ld (os_tok_ptr), hl 
33e2				 
33e2				; Don't use next - Skips the first word in uword. 
33e2			 
33e2 c3 7a 19			jp exec1 
33e5			;	NEXT 
33e5			 
33e5			 
33e5			; eof 
# End of file forth_wordsv4.asm
33e5			endif 
33e5			;;;;;;;;;;;;;; Debug code 
33e5			 
33e5			 
33e5			;if DEBUG_FORTH_PARSE 
33e5 .. 00		.nowordfound: db "No match",0 
33ee .. 00		.compword:	db "Comparing word ",0 
33fe .. 00		.nextwordat:	db "Next word at",0 
340b .. 00		.charmatch:	db "Char match",0 
3416			;endif 
3416			if DEBUG_FORTH_JP 
3416			.foundword:	db "Word match. Exec..",0 
3416			endif 
3416			;if DEBUG_FORTH_PUSH 
3416 .. 00		.enddict:	db "Dict end. Push.",0 
3426 .. 00		.push_str:	db "Pushing string",0 
3435 .. 00		.push_num:	db "Pushing number",0 
3444 .. 00		.data_sp:	db "SP:",0 
3448 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
345a .. 00		.wordinde:	db "Word in DE (3/0):",0 
346c .. 00		.wordinbc:	db "Word in BC (4/0):",0 
347e			;endif 
347e			;if DEBUG_FORTH_MALLOC 
347e .. 00		.push_malloc:	db "Malloc address",0 
348d			;endif 
348d			 
348d			 
348d			 
348d			; display malloc address and current data stack pointer  
348d			 
348d			malloc_error: 
348d d5				push de 
348e f5				push af 
348f e5				push hl 
3490 cd 6d 08			call clear_display 
3493 11 b5 34			ld de, .mallocerr 
3496 3e 00			ld a,0 
3498			;	ld de,os_word_scratch 
3498 cd 80 08			call str_at_display 
349b 3e 11			ld a, display_row_1+17 
349d 11 7a ee			ld de, debug_mark 
34a0 cd 80 08			call str_at_display 
34a3 cd 90 08			call update_display 
34a6				;call break_point_state 
34a6 cd a4 47			call cin_wait 
34a9			 
34a9 3e 20			ld a, ' ' 
34ab 32 74 e3			ld (os_view_disable), a 
34ae e1				pop hl 
34af f1				pop af 
34b0 d1				pop de	 
34b1				CALLMONITOR 
34b1 cd 8a 11			call break_point_state  
34b4				endm  
# End of macro CALLMONITOR
34b4 c9				ret 
34b5			 
34b5 .. 00		.mallocerr: 	db "Malloc Error",0 
34c2			;if DEBUG_FORTH_PUSH 
34c2			display_data_sp: 
34c2 f5				push af 
34c3			 
34c3				; see if disabled 
34c3			 
34c3 3a 74 e3			ld a, (os_view_disable) 
34c6 fe 2a			cp '*' 
34c8 28 67			jr z, .skipdsp 
34ca			 
34ca e5				push hl 
34cb e5				push hl 
34cc e5			push hl 
34cd cd 6d 08			call clear_display 
34d0 e1			pop hl 
34d1 7c				ld a,h 
34d2 21 7a e6			ld hl, os_word_scratch 
34d5 cd c7 0c			call hexout 
34d8 e1				pop hl 
34d9 7d				ld a,l 
34da 21 7c e6			ld hl, os_word_scratch+2 
34dd cd c7 0c			call hexout 
34e0 21 7e e6			ld hl, os_word_scratch+4 
34e3 3e 00			ld a,0 
34e5 77				ld (hl),a 
34e6 11 7a e6			ld de,os_word_scratch 
34e9 3e 28				ld a, display_row_2 
34eb cd 80 08				call str_at_display 
34ee 11 48 34			ld de, .wordinhl 
34f1 3e 00			ld a, display_row_1 
34f3			 
34f3 cd 80 08				call str_at_display 
34f6 11 7a ee			ld de, debug_mark 
34f9 3e 11			ld a, display_row_1+17 
34fb			 
34fb cd 80 08				call str_at_display 
34fe			 
34fe				; display current data stack pointer 
34fe 11 44 34			ld de,.data_sp 
3501 3e 30				ld a, display_row_2 + 8 
3503 cd 80 08				call str_at_display 
3506			 
3506 2a 22 eb			ld hl,(cli_data_sp) 
3509 e5				push hl 
350a 7c				ld a,h 
350b 21 7a e6			ld hl, os_word_scratch 
350e cd c7 0c			call hexout 
3511 e1				pop hl 
3512 7d				ld a,l 
3513 21 7c e6			ld hl, os_word_scratch+2 
3516 cd c7 0c			call hexout 
3519 21 7e e6			ld hl, os_word_scratch+4 
351c 3e 00			ld a,0 
351e 77				ld (hl),a 
351f 11 7a e6			ld de,os_word_scratch 
3522 3e 33				ld a, display_row_2 + 11 
3524 cd 80 08				call str_at_display 
3527			 
3527			 
3527 cd 90 08			call update_display 
352a cd e6 07			call delay1s 
352d cd e6 07			call delay1s 
3530 e1				pop hl 
3531			.skipdsp: 
3531 f1				pop af 
3532 c9				ret 
3533			 
3533			display_data_malloc: 
3533			 
3533 f5				push af 
3534 e5				push hl 
3535 e5				push hl 
3536 e5			push hl 
3537 cd 6d 08			call clear_display 
353a e1			pop hl 
353b 7c				ld a,h 
353c 21 7a e6			ld hl, os_word_scratch 
353f cd c7 0c			call hexout 
3542 e1				pop hl 
3543 7d				ld a,l 
3544 21 7c e6			ld hl, os_word_scratch+2 
3547 cd c7 0c			call hexout 
354a 21 7e e6			ld hl, os_word_scratch+4 
354d 3e 00			ld a,0 
354f 77				ld (hl),a 
3550 11 7a e6			ld de,os_word_scratch 
3553 3e 28				ld a, display_row_2 
3555 cd 80 08				call str_at_display 
3558 11 7e 34			ld de, .push_malloc 
355b 3e 00			ld a, display_row_1 
355d			 
355d cd 80 08				call str_at_display 
3560			 
3560				; display current data stack pointer 
3560 11 44 34			ld de,.data_sp 
3563 3e 30				ld a, display_row_2 + 8 
3565 cd 80 08				call str_at_display 
3568			 
3568 2a 22 eb			ld hl,(cli_data_sp) 
356b e5				push hl 
356c 7c				ld a,h 
356d 21 7a e6			ld hl, os_word_scratch 
3570 cd c7 0c			call hexout 
3573 e1				pop hl 
3574 7d				ld a,l 
3575 21 7c e6			ld hl, os_word_scratch+2 
3578 cd c7 0c			call hexout 
357b 21 7e e6			ld hl, os_word_scratch+4 
357e 3e 00			ld a,0 
3580 77				ld (hl),a 
3581 11 7a e6			ld de,os_word_scratch 
3584 3e 33				ld a, display_row_2 + 11 
3586 cd 80 08				call str_at_display 
3589			 
3589 cd 90 08			call update_display 
358c cd e6 07			call delay1s 
358f cd e6 07			call delay1s 
3592 e1				pop hl 
3593 f1				pop af 
3594 c9				ret 
3595			;endif 
3595			 
3595			include "forth_autostart.asm" 
3595			; list of commands to perform at system start up 
3595			 
3595			startcmds: 
3595			;	dw test11 
3595			;	dw test12 
3595			;	dw test13 
3595			;	dw test14 
3595			;	dw test15 
3595			;	dw test16 
3595			;	dw test17 
3595			;	dw ifthtest1 
3595			;	dw ifthtest2 
3595			;	dw ifthtest3 
3595			;	dw mmtest1 
3595			;	dw mmtest2 
3595			;	dw mmtest3 
3595			;	dw mmtest4 
3595			;	dw mmtest5 
3595			;	dw mmtest6 
3595			;	dw iftest1 
3595			;	dw iftest2 
3595			;	dw iftest3 
3595			;	dw looptest1 
3595			;	dw looptest2 
3595			;	dw test1 
3595			;	dw test2 
3595			;	dw test3 
3595			;	dw test4 
3595			;	dw game2r 
3595			;	dw game2b1 
3595			;	dw game2b2 
3595			 
3595				; start up words that are actually useful 
3595			 
3595 f1 35			dw clrstack 
3597 24 36			dw type 
3599 e5 37			dw stest 
359b 48 36			dw strncpy 
359d 86 37			dw list 
359f a9 36			dw start1 
35a1 bb 36			dw start2 
35a3			;	dw start3 
35a3 ce 36			dw start3b 
35a5 26 37			dw start3c 
35a7			 
35a7				; (unit) testing words 
35a7			 
35a7 5c 38			dw mtesta 
35a9 11 39			dw mtestb 
35ab b4 39			dw mtestc 
35ad 69 3a			dw mtestd 
35af 0d 3b			dw mteste 
35b1			 
35b1				; demo/game words 
35b1			 
35b1 b0 41		        dw game3w 
35b3 de 41		        dw game3p 
35b5 fc 41		        dw game3sc 
35b7 2d 42		        dw game3vsi 
35b9 59 42		        dw game3vs 
35bb				 
35bb a3 3f			dw game2b 
35bd 11 40			dw game2bf 
35bf 5b 40			dw game2mba 
35c1 f1 40			dw game2mbas 
35c3 33 41			dw game2mb 
35c5			 
35c5 cd 3c			dw game1 
35c7 de 3c			dw game1a 
35c9 40 3d			dw game1b 
35cb 75 3d			dw game1c 
35cd ab 3d			dw game1d 
35cf dc 3d			dw game1s 
35d1 f0 3d			dw game1t 
35d3 05 3e			dw game1f 
35d5 39 3e			dw game1z 
35d7			 
35d7 c3 3b			dw test5 
35d9 fb 3b			dw test6 
35db 33 3c			dw test7 
35dd 47 3c			dw test8 
35df 73 3c			dw test9 
35e1 89 3c			dw test10 
35e3				 
35e3 eb 3e		        dw ssv5 
35e5 cf 3e		        dw ssv4 
35e7 b3 3e		        dw ssv3 
35e9 7d 3e		        dw ssv2 
35eb 04 3f		        dw ssv1 
35ed 4c 3f		        dw ssv1cpm 
35ef			;	dw keyup 
35ef			;	dw keydown 
35ef			;	dw keyleft 
35ef			;	dw keyright 
35ef			;	dw 	keyf1 
35ef			;	dw keyf2 
35ef			;	dw keyf3 
35ef			;	dw keyf4 
35ef			;	dw keyf5 
35ef			;	dw keyf6 
35ef			;	dw keyf7 
35ef			;	dw keyf8 
35ef			;	dw keyf9 
35ef			;	dw keyf10 
35ef			;	dw keyf11 
35ef			;	dw keyf12 
35ef			;	dw keytab 
35ef			;	dw keycr 
35ef			;	dw keyhome 
35ef			;	dw keyend 
35ef			;	dw keybs 
35ef 00 00			db 0, 0	 
35f1			 
35f1			 
35f1			; clear stack  
35f1			 
35f1 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
3624			 
3624			; type ( addr count - ) 
3624 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
3648			 
3648			; some direct memory words 
3648			; strncpy ( len t f -- t ) 
3648			 
3648 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
36a9			 
36a9 .. 00		start1:     	db ": bpon $0000 bp ;",0 
36bb .. 00		start2:     	db ": bpoff $0001 bp ;",0 
36ce			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
36ce .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
3726 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
3786			 
3786			 
3786			; a handy word to list items on the stack 
3786			 
3786 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
37e5			 
37e5			 
37e5			; test stack  
37e5			; rnd8 stest 
37e5			 
37e5 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
385c			 
385c			; random malloc and free cycles 
385c			 
385c .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
3911			 
3911			; fixed malloc and free cycles 
3911			 
3911 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
39b4			 
39b4			; fixed double string push and drop cycle  
39b4			 
39b4 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
3a69			 
3a69			; consistent fixed string push and drop cycle  
3a69			 
3a69 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
3b0d			 
3b0d .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
3bc3			 
3bc3			;test1:		db ": aa 1 2 3 ;", 0 
3bc3			;test2:     	db "111 aa 888 999",0 
3bc3			;test3:     	db ": bb 77 ;",0 
3bc3			;test4:     	db "$02 $01 do i . loop bb",0 
3bc3			 
3bc3 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
3bfb .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
3c33 .. 00		test7:     	db ": box hline vline ;",0 
3c47 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
3c73 .. 00		test9:     	db ": sw $01 adsp world ;",0 
3c89 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
3cae .. 00		test11:     	db "hello create .",0 
3cbd .. 00		test12:     	db "hello2 create .",0 
3ccd			 
3ccd			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
3ccd			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
3ccd			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
3ccd			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
3ccd			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
3ccd			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
3ccd			 
3ccd			;iftest1:     	db "$0001 IF cls .",0 
3ccd			;iftest2:     	db "$0000 IF cls .",0 
3ccd			;iftest3:     	db "$0002 $0003 - IF cls .",0 
3ccd			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
3ccd			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
3ccd			 
3ccd			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
3ccd			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
3ccd			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
3ccd			 
3ccd			 
3ccd			 
3ccd			; a small guess the number game 
3ccd			 
3ccd .. 00		game1:          db ": gsn rnd8 v1! ;",0 
3cde .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
3d40			 
3d40 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
3d75 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
3dab .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
3ddc .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
3df0 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
3e05 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
3e39 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
3e7d			 
3e7d			 
3e7d			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
3e7d			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
3e7d			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
3e7d			 
3e7d			; simple screen saver to test code memory reuse to destruction 
3e7d			 
3e7d .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
3eb3 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
3ecf .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
3eeb .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
3f04 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
3f4c .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
3fa3			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
3fa3			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
3fa3			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
3fa3			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
3fa3			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
3fa3			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
3fa3			 
3fa3			 
3fa3			 
3fa3			; minesweeper/battleship finding game 
3fa3			; draws a game board of random ship/mine positions 
3fa3			; user enters coords to see if it hits on 
3fa3			; game ends when all are hit 
3fa3			; when hit or miss says how many may be in the area 
3fa3			 
3fa3			; setup the game board and then hide it 
3fa3 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
4011 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
405b			; prompt for where to target 
405b .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
40f1 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
4116			; TODO see if the entered coords hits or misses pushes char hit of miss 
4116 .. 00		game2mbht:      db ": mbckht nop ;",0 
4125 .. 00		game2mbms:      db ": mbcms nop ;",0 
4133			; TODO how many might be near by 
4133 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
41b0			 
41b0			; Game 3 
41b0			 
41b0			; Vert scroller ski game - avoid the trees! 
41b0			 
41b0			; v0 score (ie turns) 
41b0			; v1 player pos 
41b0			; v2 left wall 
41b0			; v3 right wall 
41b0			 
41b0			; Draw side walls randomly 
41b0			 
41b0 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
41de			 
41de			; Draw player 
41de .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
41fc			 
41fc			; TODO Get Key 
41fc			 
41fc			; TODO Move left right 
41fc			 
41fc			; scroll and move walls a bit 
41fc			 
41fc .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
422d			 
422d			; main game loop 
422d			 
422d .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
4259 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
4298			 
4298			; key board defs 
4298			 
4298 .. 00		keyup:       db ": keyup $05 ;",0 
42a6 .. 00		keydown:       db ": keydown $0a ;",0 
42b6 .. 00		keyleft:       db ": keyleft $0b ;",0 
42c6 .. 00		keyright:       db ": keyright $0c ;",0 
42d7 .. 00		keyf1:       db ": keyf1 $10 ;",0 
42e5 .. 00		keyf2:       db ": keyf2 $11 ;",0 
42f3 .. 00		keyf3:       db ": keyf3 $12 ;",0 
4301 .. 00		keyf4:       db ": keyf4 $13 ;",0 
430f .. 00		keyf5:       db ": keyf5 $14 ;",0 
431d .. 00		keyf6:       db ": keyf6 $15 ;",0 
432b .. 00		keyf7:       db ": keyf7 $16 ;",0 
4339 .. 00		keyf8:       db ": keyf8 $17 ;",0 
4347 .. 00		keyf9:       db ": keyf9 $18 ;",0 
4355 .. 00		keyf10:       db ": keyf10 $19 ;",0 
4364 .. 00		keyf11:       db ": keyf11 $1a ;",0 
4373 .. 00		keyf12:       db ": keyf12 $1b ;",0 
4382			 
4382 .. 00		keytab:       db ": keytab $09 ;",0 
4391 .. 00		keycr:       db ": keycr $0d ;",0 
439f .. 00		keyhome:       db ": keyhome $0e ;",0 
43af .. 00		keyend:       db ": keyend $0f ;",0 
43be .. 00		keybs:       db ": keybs $08 ;",0 
43cc			 
43cc			   
43cc			 
43cc			 
43cc			 
43cc			; eof 
# End of file forth_autostart.asm
43cc			 
43cc .. 00		sprompt1: db "Startup load...",0 
43dc .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
43f2			 
43f2			forth_startup: 
43f2 21 95 35			ld hl, startcmds 
43f5 3e 00			ld a, 0 
43f7 32 9b e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
43fa			 
43fa e5			.start1:	push hl 
43fb cd 6d 08			call clear_display 
43fe 11 cc 43			ld de, sprompt1 
4401 3e 00		        ld a, display_row_1 
4403 cd 80 08			call str_at_display 
4406 11 dc 43			ld de, sprompt2 
4409 3e 28		        ld a, display_row_2 
440b cd 80 08			call str_at_display 
440e e1				pop hl 
440f e5				push hl 
4410 5e				ld e,(hl) 
4411 23				inc hl 
4412 56				ld d,(hl) 
4413 3e 50		        ld a, display_row_3 
4415 cd 80 08			call str_at_display 
4418 cd 90 08			call update_display 
441b			 
441b			 
441b 3a 9b e7			ld a, (os_last_cmd) 
441e fe 00			cp 0 
4420 28 05			jr z, .startprompt 
4422 cd da 07			call delay250ms 
4425 18 24			jr .startdo 
4427				 
4427				 
4427			 
4427			.startprompt: 
4427			 
4427 3e 9f			ld a,display_row_4 + display_cols - 1 
4429 11 8d 16		        ld de, endprg 
442c cd 80 08			call str_at_display 
442f cd 90 08			call update_display 
4432 cd e6 07			call delay1s 
4435 cd a4 47			call cin_wait 
4438						 
4438 fe 2a			cp '*' 
443a 28 5e			jr z, .startupend1 
443c fe 23			cp '#' 
443e 20 07			jr nz, .startno 
4440 3e 01			ld a, 1 
4442 32 9b e7			ld (os_last_cmd),a 
4445 18 04			jr .startdo 
4447 fe 31		.startno:	cp '1' 
4449 28 3a			jr z,.startnxt  
444b			 
444b				; exec startup line 
444b			.startdo:	 
444b e1				pop hl 
444c e5				push hl 
444d				 
444d 5e				ld e,(hl) 
444e 23				inc hl 
444f 56				ld d,(hl) 
4450 eb				ex de,hl 
4451			 
4451 e5				push hl 
4452			 
4452 3e 00			ld a, 0 
4454				;ld a, FORTH_END_BUFFER 
4454 cd 2f 0e			call strlent 
4457 23				inc hl   ; include zero term to copy 
4458 06 00			ld b,0 
445a 4d				ld c,l 
445b e1				pop hl 
445c 11 75 e3			ld de, scratch 
445f ed b0			ldir 
4461			 
4461			 
4461 21 75 e3			ld hl, scratch 
4464 cd 37 19			call forthparse 
4467 cd 77 19			call forthexec 
446a cd 8e 18			call forthexec_cleanup 
446d			 
446d 3e 78			ld a, display_row_4 
446f 11 31 14			ld de, endprog 
4472			 
4472 cd 90 08			call update_display		 
4475			 
4475 3a 9b e7			ld a, (os_last_cmd) 
4478 fe 00			cp 0 
447a 20 09			jr nz, .startnxt 
447c cd 8f 16			call next_page_prompt 
447f cd 6d 08		        call clear_display 
4482 cd 90 08			call update_display		 
4485			 
4485				; move onto next startup line? 
4485			.startnxt: 
4485			 
4485 cd da 07			call delay250ms 
4488 e1				pop hl 
4489			 
4489 23				inc hl 
448a 23				inc hl 
448b			 
448b e5				push hl 
448c 5e				ld e, (hl) 
448d 23				inc hl 
448e 56				ld d, (hl) 
448f e1				pop hl 
4490				; TODO replace 0 test 
4490			 
4490 eb				ex de, hl 
4491 cd ef 09			call ishlzero 
4494			;	ld a,e 
4494			;	add d 
4494			;	cp 0    ; any left to do? 
4494 eb				ex de, hl 
4495 c2 fa 43			jp nz, .start1 
4498 18 01			jr .startupend 
449a			 
449a e1			.startupend1: pop hl 
449b			.startupend: 
449b			 
449b cd 6d 08			call clear_display 
449e cd 90 08			call update_display 
44a1 c9				ret 
44a2			 
44a2			 
44a2			; stack over and underflow checks 
44a2			 
44a2			; init the words to detect the under/overflow 
44a2			 
44a2			chk_stk_init: 
44a2				; a vague random number to check so we dont get any "lucky" hits 
44a2 3e 2d			ld a, 45 
44a4 6f				ld l, a 
44a5 00				nop 
44a6 3e 17			ld a, 23 
44a8 67				ld h, a 
44a9			 
44a9 22 6a e3			ld (chk_word), hl     ; the word we need to check against 
44ac			 
44ac			;	ld (chk_stund), hl	; stack points.... 
44ac 22 00 ef			ld (chk_stovr), hl 
44af 22 20 eb			ld (chk_ret_und), hl 
44b2 22 de ea			ld (chk_ret_ovr), hl 
44b5 22 dc e9			ld (chk_loop_ovr), hl 
44b8 22 da e8			ld (chk_data_ovr), hl 
44bb c9				ret 
44bc				 
44bc			check_stacks: 
44bc				; check all stack words 
44bc			 
44bc e5				push hl 
44bd d5				push de 
44be			 
44be			;	ld de,(chk_word) 
44be			;	ld hl, (chk_stund)	; stack points.... 
44be			;	if DEBUG_STK_FAULT 
44be			;		DMARK "FAa" 
44be			;		CALLMONITOR 
44be			;	endif 
44be			;	call cmp16 
44be			;	jp z, .chk_faulta 
44be			; 
44be			;	ld de, sfaultsu 
44be			;	jp .chk_fault 
44be			 
44be 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
44c1 ed 5b 6a e3		ld de,(chk_word) 
44c5				if DEBUG_STK_FAULT 
44c5					DMARK "FAb" 
44c5					CALLMONITOR 
44c5				endif 
44c5 cd e4 09			call cmp16 
44c8 28 06			jr z, .chk_fault1 
44ca 11 6b 45			ld de, sfaultso 
44cd c3 1f 45			jp .chk_fault 
44d0			.chk_fault1:  
44d0 2a 20 eb			ld hl, (chk_ret_und) 
44d3 ed 5b 6a e3		ld de,(chk_word) 
44d7				if DEBUG_STK_FAULT 
44d7					DMARK "FAU" 
44d7					CALLMONITOR 
44d7				endif 
44d7 cd e4 09			call cmp16 
44da ca e3 44			jp z, .chk_fault2 
44dd 11 7b 45			ld de, sfaultru 
44e0 c3 1f 45			jp .chk_fault 
44e3			.chk_fault2:  
44e3 2a de ea			ld hl, (chk_ret_ovr) 
44e6 ed 5b 6a e3		ld de,(chk_word) 
44ea				if DEBUG_STK_FAULT 
44ea					DMARK "FA1" 
44ea					CALLMONITOR 
44ea				endif 
44ea cd e4 09			call cmp16 
44ed ca f6 44			jp z, .chk_fault3 
44f0 11 89 45			ld de, sfaultro 
44f3 c3 1f 45			jp .chk_fault 
44f6			.chk_fault3:  
44f6 2a dc e9			ld hl, (chk_loop_ovr) 
44f9 ed 5b 6a e3		ld de,(chk_word) 
44fd				if DEBUG_STK_FAULT 
44fd					DMARK "FA2" 
44fd					CALLMONITOR 
44fd				endif 
44fd cd e4 09			call cmp16 
4500 ca 09 45			jp z, .chk_fault4 
4503 11 a3 45			ld de, sfaultlo 
4506 c3 1f 45			jp .chk_fault 
4509			.chk_fault4:  
4509 2a da e8			ld hl, (chk_data_ovr) 
450c ed 5b 6a e3		ld de,(chk_word) 
4510				if DEBUG_STK_FAULT 
4510					DMARK "FA3" 
4510					CALLMONITOR 
4510				endif 
4510 cd e4 09			call cmp16 
4513 ca 1c 45			jp z, .chk_fault5 
4516 11 bd 45			ld de, sfaultdo 
4519 c3 1f 45			jp .chk_fault 
451c			 
451c			 
451c			.chk_fault5:  
451c d1				pop de 
451d e1				pop hl 
451e			 
451e c9				ret 
451f			 
451f cd 6d 08		.chk_fault: 	call clear_display 
4522 3e 28				ld a, display_row_2 
4524 cd 80 08				call str_at_display 
4527 11 4d 45				   ld de, .stackfault 
452a 3e 00				ld a, display_row_1 
452c cd 80 08				call str_at_display 
452f 11 7a ee				    ld de, debug_mark 
4532 3e 11				ld a, display_row_1+17 
4534 cd 80 08				call str_at_display 
4537 cd 90 08				call update_display 
453a			 
453a				; prompt before entering montior for investigating issue 
453a			 
453a 3e 78			ld a, display_row_4 
453c 11 31 14			ld de, endprog 
453f			 
453f cd 90 08			call update_display		 
4542			 
4542 cd 8f 16			call next_page_prompt 
4545			 
4545 d1				pop de 
4546 e1				pop hl 
4547 cd 85 14				call monitor 
454a c3 7f 13				jp warmstart 
454d					;jp 0 
454d					;halt 
454d			 
454d			 
454d			 
454d .. 00		.stackfault: 	db "Stack fault:",0 
455a			 
455a .. 00		sfaultsu: 	db	"Stack under flow",0 
456b .. 00		sfaultso: 	db	"Stack over flow",0 
457b .. 00		sfaultru:	db "RTS underflow",0 
4589 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
45a3 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
45bd .. 00		sfaultdo:	db "DTS overflow", 0 
45ca			 
45ca			 
45ca			fault_dsp_under: 
45ca 11 dc 45			ld de, .dsp_under 
45cd c3 8c 46			jp .show_fault 
45d0			 
45d0			fault_rsp_under: 
45d0 11 ea 45			ld de, .rsp_under 
45d3 c3 8c 46			jp .show_fault 
45d6			fault_loop_under: 
45d6 11 f8 45			ld de, .loop_under 
45d9 c3 8c 46			jp .show_fault 
45dc			 
45dc .. 00		.dsp_under: db "DSP Underflow",0 
45ea .. 00		.rsp_under: db "RSP Underflow",0 
45f8 .. 00		.loop_under: db "LOOP Underflow",0 
4607			 
4607			 
4607 d5			type_faultn: 	push de 
4608 e5					push hl 
4609 cd 6d 08				call clear_display 
460c 11 33 46				   ld de, .typefaultn 
460f 3e 00				ld a, display_row_1 
4611 cd 80 08				call str_at_display 
4614 11 7a ee				    ld de, debug_mark 
4617 3e 11				ld a, display_row_1+17 
4619 cd 80 08				call str_at_display 
461c cd 90 08				call update_display 
461f			 
461f				; prompt before entering montior for investigating issue 
461f			 
461f 3e 78			ld a, display_row_4 
4621 11 31 14			ld de, endprog 
4624			 
4624 cd 90 08			call update_display		 
4627			 
4627 cd 8f 16			call next_page_prompt 
462a			 
462a e5					push hl 
462b d5					push de 
462c cd 85 14				call monitor 
462f c3 7f 13				jp warmstart 
4632 76					halt 
4633			 
4633			 
4633 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
464a			 
464a d5			type_faults: 	push de 
464b e5					push hl 
464c cd 6d 08				call clear_display 
464f 11 75 46				   ld de, .typefaults 
4652 3e 00				ld a, display_row_1 
4654 cd 80 08				call str_at_display 
4657 11 7a ee				    ld de, debug_mark 
465a 3e 11				ld a, display_row_1+17 
465c cd 80 08				call str_at_display 
465f cd 90 08				call update_display 
4662			 
4662				; prompt before entering montior for investigating issue 
4662			 
4662 3e 78			ld a, display_row_4 
4664 11 31 14			ld de, endprog 
4667			 
4667 cd 90 08			call update_display		 
466a			 
466a cd 8f 16			call next_page_prompt 
466d			 
466d e1					pop hl 
466e d1					pop de 
466f cd 85 14				call monitor 
4672 c3 7f 13				jp warmstart 
4675			 
4675			 
4675 .. 00		.typefaults: db "STR Type Expected TOS!",0 
468c			 
468c			.show_fault: 	 
468c d5					push de 
468d cd 6d 08				call clear_display 
4690 d1					pop de 
4691 3e 00				ld a, display_row_1 
4693 cd 80 08				call str_at_display 
4696 11 7a ee				    ld de, debug_mark 
4699 3e 11				ld a, display_row_1+17 
469b cd 80 08				call str_at_display 
469e cd 90 08				call update_display 
46a1			 
46a1				; prompt before entering montior for investigating issue 
46a1			 
46a1 3e 78			ld a, display_row_4 
46a3 11 31 14			ld de, endprog 
46a6			 
46a6 cd 90 08			call update_display		 
46a9			 
46a9 cd 8f 16			call next_page_prompt 
46ac			 
46ac e1					pop hl 
46ad d1					pop de 
46ae cd 85 14				call monitor 
46b1			; do a dump to cli and not warmstart so we preserve all of the uwords.  
46b1			; TODO Make optional fault restart to cli or warm boot? 
46b1					;jp warmstart 
46b1 c3 d7 13				jp cli 
46b4 76					halt 
46b5			; eof 
# End of file forth_kernel.asm
46b5			;include "nascombasic.asm" 
46b5			 
46b5			 
46b5			; find out where the code ends if loaded into RAM (for SC114) 
46b5			;endofcode:  
46b5			;	nop 
46b5			 
46b5			 
46b5			; eof 
46b5			 
# End of file main.asm
46b5			;include "firmware_lcd_4x40.asm" 
46b5			;;include "firmware_lcd_4x20.asm" 
46b5			include "firmware_cpm_display.asm" 
46b5			 
46b5			; Serial display interface for SC114 
46b5			 
46b5			 
46b5			display_row_1: equ 0 
46b5			display_row_2: equ display_row_1+display_cols 
46b5			display_row_3: equ display_row_2 + display_cols 
46b5			display_row_4: equ display_row_3 + display_cols 
46b5			 
46b5			kLCDWidth:  EQU display_cols             ;Width in characters 
46b5			kLCD_Line1: EQU 0x00  
46b5			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
46b5			; E1 
46b5			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
46b5			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
46b5			 
46b5			lcd_init: 
46b5				; no init as handled by the SCM bios 
46b5 c9				ret 
46b6			 
46b6			 
46b6			; low level functions for direct screen writes 
46b6			 
46b6			; output char at pos? 
46b6			fLCD_Str: 
46b6			        ;out (SC114_SIO_1_OUT),a 
46b6 c5				push bc 
46b7 d5				push de 
46b8 5f				ld e, a 
46b9			; TODO Replace with CP/M BIOS call 
46b9 0e 02			ld c, $02 
46bb cd 05 00			call 5 
46be d1				pop de 
46bf c1				pop bc 
46c0 c9				ret 
46c1			 
46c1			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
46c1			fLCD_Pos: 
46c1				; use ASCII escape to position 
46c1			        ;out (SC114_SIO_1_OUT),a 
46c1 c5				push bc 
46c2 d5				push de 
46c3 5f				ld e, a 
46c4 0e 02			ld c, $02 
46c6			; TODO Replace with CP/M BIOS call 
46c6 cd 05 00			call 5 
46c9 d1				pop de 
46ca c1				pop bc 
46cb			 
46cb c9				ret 
46cc			 
46cc			; output char at pos 
46cc			fLCD_Data: 
46cc			      ;  out (SC114_SIO_1_OUT),a 
46cc c5				push bc 
46cd d5				push de 
46ce 0e 02			ld c, $02 
46d0 5f				ld e, a 
46d1			; TODO Replace with CP/M BIOS call 
46d1 cd 05 00			call 5 
46d4 d1				pop de 
46d5 c1				pop bc 
46d6			 
46d6 c9				ret 
46d7			 
46d7			; ascii cls  
46d7			 
46d7 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
46db			 
46db 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
46f2			;.clscpm: db 3, $3c,"$" 
46f2			 
46f2			; write the frame buffer given in hl to hardware  
46f2			write_display: 
46f2			 
46f2			API: equ 0 
46f2			 
46f2			if API 
46f2				push bc 
46f2				ld b, 4 
46f2			 
46f2			        ld (display_write_tmp), hl 	  
46f2			 
46f2				; clear and home cursor 
46f2			 
46f2				ld c, 9 
46f2				ld de, .cls 
46f2			; TODO Replace with CP/M BIOS call 
46f2				call 5 
46f2			 
46f2			 
46f2			.writeln: 
46f2			 
46f2				ld de, (display_write_tmp) 
46f2				ld c, 6 
46f2			; TODO Replace with CP/M BIOS call 
46f2				rst $30 
46f2				ld c, 7 
46f2				rst $30 
46f2			 
46f2				ld hl, (display_write_tmp) 
46f2				ld de, display_cols 
46f2				add hl,de 
46f2				ld (display_write_tmp),hl 
46f2			 
46f2				djnz  .writeln 
46f2			 
46f2				pop bc 
46f2			 
46f2			 
46f2				ret 
46f2			endif 
46f2 e5				push hl 
46f3 c5				push bc 
46f4 d5				push de 
46f5			 
46f5			;	ld c, 2 
46f5			;	;ld de, .cls 
46f5			;	ld a, 27 
46f5			;	rst $30 
46f5			;	ld c, 2 
46f5			;	;ld de, .cls 
46f5			;	ld a, '[' 
46f5			;	rst $30 
46f5			; 
46f5			;	ld c, 2 
46f5			;	;ld de, .cls 
46f5			;	ld a, 'H' 
46f5			;	rst $30 
46f5			; 
46f5			 
46f5			 
46f5			; lots of CR/LF 
46f5			;	ld c, 9 
46f5			;	ld de, .clscpm 
46f5			;	call 5 
46f5			 
46f5			; xterm cls 
46f5 0e 02			ld c, 2 
46f7 1e 1b			ld e, 27 
46f9 cd 05 00			call 5 
46fc			; cls causes too much flicker 
46fc			;	ld c, 2 
46fc			;	ld e, 'c' 
46fc			;	call 5 
46fc			 
46fc			; use xterm home instead 
46fc 0e 02			ld c, 2 
46fe 1e 5b			ld e, '[' 
4700 cd 05 00			call 5 
4703 0e 02			ld c, 2 
4705 1e 48			ld e, 'H' 
4707 cd 05 00			call 5 
470a			LLL: equ 0 
470a			 
470a			if LLL 
470a			 
470a				ld c, 2 
470a				;ld de, .cls 
470a				ld e, 27 
470a			; TODO Replace with CP/M BIOS call 
470a				call 5 
470a			 
470a			 
470a				ld c, 2 
470a				;ld de, .cls 
470a				ld e, '[' 
470a			; TODO Replace with CP/M BIOS call 
470a				call 5 
470a				ld c, 2 
470a				;ld de, .cls 
470a				ld e, '2' 
470a			; TODO Replace with CP/M BIOS call 
470a				call 5 
470a				ld c, 2 
470a				;ld de, .cls 
470a				ld e, 'J' 
470a			; TODO Replace with CP/M BIOS call 
470a				call 5 
470a			 
470a			endif 
470a			 
470a d1				pop de 
470b c1				pop bc 
470c e1				pop hl 
470d			 
470d			 
470d 22 d8 eb		        ld (display_write_tmp), hl 	  
4710 3e 00			ld a, kLCD_Line1 
4712			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
4712 06 28			ld b, display_cols 
4714 ed 5b d8 eb		ld de, (display_write_tmp) 
4718 cd 9b 47			call write_len_string 
471b				 
471b			 
471b e5			push hl 
471c d5			push de 
471d c5			push bc 
471e 0e 02			ld c, 2 
4720 1e 0a			ld e, 10 
4722 cd 05 00			call 5 
4725 0e 02			ld c, 2 
4727 1e 0d			ld e, 13 
4729 cd 05 00			call 5 
472c			; TODO Replace with CP/M BIOS call 
472c				;rst $30 
472c c1			pop bc 
472d d1			pop de 
472e e1			pop hl 
472f			 
472f				 
472f 2a d8 eb			ld hl, (display_write_tmp) 
4732 11 28 00			ld de, display_cols 
4735 19				add hl,de 
4736 22 d8 eb			ld (display_write_tmp),hl 
4739			 
4739				 
4739 3e 28			ld a, kLCD_Line2 
473b			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
473b 06 28			ld b, display_cols 
473d ed 5b d8 eb		ld de, (display_write_tmp) 
4741 cd 9b 47			call write_len_string 
4744				 
4744 2a d8 eb			ld hl, (display_write_tmp) 
4747 11 28 00			ld de, display_cols 
474a 19				add hl,de 
474b 22 d8 eb			ld (display_write_tmp),hl 
474e			 
474e e5			push hl 
474f d5			push de 
4750 c5			push bc 
4751 0e 07			ld c, 7 
4753			; TODO Replace with CP/M BIOS call 
4753				;rst $30 
4753 0e 02			ld c, 2 
4755 1e 0a			ld e, 10 
4757 cd 05 00			call 5 
475a 0e 02			ld c, 2 
475c 1e 0d			ld e, 13 
475e cd 05 00			call 5 
4761 c1			pop bc 
4762 d1			pop de 
4763 e1			pop hl 
4764			 
4764				 
4764 3e 50			ld a, kLCD_Line3 
4766			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
4766 06 28			ld b, display_cols 
4768 ed 5b d8 eb		ld de, (display_write_tmp) 
476c cd 9b 47			call write_len_string 
476f				 
476f 2a d8 eb			ld hl, (display_write_tmp) 
4772 11 28 00			ld de, display_cols 
4775 19				add hl,de 
4776 22 d8 eb			ld (display_write_tmp),hl 
4779			 
4779 e5			push hl 
477a d5			push de 
477b c5			push bc 
477c 0e 07			ld c, 7 
477e			; TODO Replace with CP/M BIOS call 
477e				;rst $30 
477e 0e 02			ld c, 2 
4780 1e 0a			ld e, 10 
4782 cd 05 00			call 5 
4785 0e 02			ld c, 2 
4787 1e 0d			ld e, 13 
4789 cd 05 00			call 5 
478c c1			pop bc 
478d d1			pop de 
478e e1			pop hl 
478f			 
478f				 
478f 3e 78			ld a, kLCD_Line4 
4791			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
4791 06 28			ld b, display_cols 
4793 ed 5b d8 eb		ld de, (display_write_tmp) 
4797 cd 9b 47			call write_len_string 
479a c9					ret 
479b			 
479b			 
479b				; write out a fixed length string given in b from de 
479b			 
479b 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
479c cd cc 46		            CALL fLCD_Data      ;Write character to display 
479f 13				inc de 
47a0 10 f9			djnz write_len_string 
47a2 c9				ret 
47a3			 
47a3			 
47a3			; eof 
# End of file firmware_cpm_display.asm
47a3			;include "firmware_key_5x10.asm" 
47a3			;;include "firmware_key_4x10.asm" 
47a3			include "firmware_key_cpm.asm" 
47a3			; Serial keyboard interface for SC114 
47a3			 
47a3			 
47a3			key_init: 
47a3				; no init as handled by the SCM bios 
47a3 c9				ret 
47a4			 
47a4			 
47a4			cin_wait: 
47a4			;	ld a, 0 
47a4			;	ret 
47a4			 
47a4				;in a,(SC114_SIO_1_IN) 
47a4			        ; Use SCM API to get from whatever console device we are using 
47a4			 
47a4			; TODO Replace with CP/M BIOS call 
47a4 c5				push bc 
47a5 0e 01			ld c, $01 
47a7 cd 05 00			call 5 
47aa c1				pop bc 
47ab c9				ret 
47ac			 
47ac			cin: 
47ac			 
47ac			 
47ac c5				push bc 
47ad			 
47ad				; any key waiting to process? 
47ad			; TODO Replace with CP/M BIOS call 
47ad 0e 06			ld c, $06 
47af cd 05 00			call 5 
47b2 28 0d			jr z, .cin_skip 
47b4			 
47b4				; yep, get it 
47b4			 
47b4 0e 01			ld c, $01 
47b6			; TODO Replace with CP/M BIOS call 
47b6 cd 05 00			call 5 
47b9			 
47b9 fe 7f			cp $7f     ; back space 
47bb 20 02			jr nz, .skipbs 
47bd 3e 08			ld a, KEY_BS 
47bf			.skipbs: 
47bf			 
47bf c1				pop bc 
47c0 c9				ret 
47c1			.cin_skip: 
47c1 3e 00			ld a, 0 
47c3 c1				pop bc 
47c4 c9				ret 
47c5			 
47c5			 
47c5			 
47c5			 
# End of file firmware_key_cpm.asm
47c5			endofcode:  
47c5			baseram:  
47c5 00				nop 
47c6			 
47c6			heap_start: equ baseram+15  ; Starting address of heap 
47c6			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
47c6			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
47c6			;VDU:  EQU     endofcode           ; BASIC Work space 
47c6			; eof 
47c6			 
# End of file os_mega_cpm.asm
47c6
