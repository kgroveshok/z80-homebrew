# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 32 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-11 13:11' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
001f			 
001f			 
001f			 
001f			;        nop  
001f			;        nop 
001f			;;	org 05h		; null out bdos call 
001f			; 
001f			;        nop  
001f			;        nop  
001f			;        nop 
001f			;;	org 08h 
001f			;;; 
001f			;;	jp cin		; rst 8 - char in 
001f			;;; 
001f			; 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;	org 010h 
001f			;; 
001f			;	jp cout		; rest 010h  - char out 
001f			;; 
001f			;	org 01bh   
001f			; 
001f			;	;jp  		; rst 01bh   - write string to display 
001f			;	jp str_at_display 
001f			; 
001f			; 
001f			;	org 020h 
001f			; 
001f			;	; jp		 ; rst 020h - read char at screen location 
001f			; 
001f			;	org 028h 
001f			 
001f				; jp		 ; rst 028h  - storage i/o 
001f			 
001f			; 	org 030h 
001f			;	jp break_point_state 
001f			  
001f			; $30  
001f			; org 038h 
001f			; $38 
001f			 
001f			; TODO any more important entry points to add to jump table for easier coding use? 
001f			 
001f			if BASE_KEV = 1  
001f			 
001f				; need to be at $66 for nmi support 
001f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0025 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0031 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0037 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0043 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0049 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0055 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0061 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0067 00 ff			db 0,255 
0069 c3 99 6f			jp nmi 
006c			endif 
006c			 
006c			include "firmware.asm" 
006c			  
006c			; main constants (used here and in firmware)  
006c			  
006c			; TODO have page 0 of storage as bios  
006c			  
006c			Device_A: equ 0h  
006c			Device_B: equ 040h          ; Sound  
006c			  
006c			if BASE_KEV  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_SC114  
006c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			; TODO fixup for CPM  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			Device_D: equ 0c0h             ; Keyboard and LCD  
006c			  
006c			; Odd specific debug points for testing hardware dev  
006c			  
006c			;if DEBUG_LEVEL0  
006c			;	include "debug_level0.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL1  
006c			;	include "debug_level1.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL2  
006c			;	include "debug_level2.asm"  
006c			;endif  
006c			  
006c			  
006c			CALLMONITOR: macro  
006c			;	call break_point_state  
006c			; now use the break point debug vector  
006c				call debug_vector  
006c				endm  
006c			  
006c			MALLOC_1: equ 1        ; from dk88   
006c			MALLOC_2: equ 0           ; broke  
006c			MALLOC_3: equ 0           ; really broke  
006c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
006c			  
006c			if BASE_KEV   
006c			;stacksize: equ 256  
006c			; each stack entry is three bytes (type + word)  
006c			stacksize: equ 3*150  
006c			  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 512  
006c			endif  
006c			if BASE_SC114  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			;if STORAGE_SE == 0  
006c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
006c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
006c			;endif  
006c			  
006c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
006c			  
006c			STORE_0_AUTORUN: equ $20  
006c			  
006c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
006c			  
006c			STORE_0_AUTOFILE: equ $21  
006c			STORE_0_BANKRUN: equ $23  
006c			STORE_0_FILERUN: equ $24  
006c			  
006c			; Block 0 offsets for settings  
006c			  
006c			; if set then skip prompt for start up and accept all  
006c			  
006c			STORE_0_QUICKSTART: equ $25  
006c			  
006c			; Blocks where directory table is held  
006c			  
006c			; Reducing the number of entries increases the max file size  
006c			  
006c			;STORE_DIR_START: equ 1  
006c			;STORE_DIR_END: equ 33  
006c			  
006c			; Blocks from where file data is stored  
006c			  
006c			;STORE_DATA_START: equ STORE_DIR_END + 1  
006c			  
006c			; Block indicators (<32 are data files)  
006c			  
006c			;STORE_BLOCK_CFG: equ $8f       ; config block  
006c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
006c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
006c			;STORE_BLOCK_FREE: equ $85       ; data block free  
006c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
006c			  
006c			  
006c			  
006c			; Directory entry flags  
006c			  
006c			;STORE_DIR_FREE: equ 0  
006c			;STORE_DIR_FILE:  equ 1  
006c			  
006c			; Structure offsets to directory entries  
006c			;STORE_DE_FLAG: equ 0  
006c			;STORE_DE_MAXEXT: equ 1  
006c			;STORE_DE_FILENAME: equ 2  
006c			  
006c			; Structure offsets to block 0  
006c			  
006c			;STORE_BK0_ISFOR: equ 1  
006c			;STORE_BK0_LABEL: equ 3  
006c			  
006c			; memory allocation   
006c			  
006c			chk_stund: equ tos+2           ; underflow check word  
006c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
006c			  
006c			; keyscan table needs rows x cols buffer  
006c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
006c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
006c			  
006c			keyscan_table_row1: equ chk_stovr -key_cols-1  
006c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
006c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
006c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
006c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
006c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
006c			keyscan_scancol: equ keyscan_table-key_cols  
006c			;keyscan_table_len: equ key_rows*key_cols  
006c			;keybufptr: equ keyscan_table - 2  
006c			;keysymbol: equ keybufptr - 1  
006c			key_held: equ keyscan_scancol-1	; currently held  
006c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
006c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
006c			key_fa: equ key_repeat_ct -1 ;  
006c			key_fb: equ key_fa -1 ;  
006c			key_fc: equ key_fb -1 ;  
006c			key_fd: equ key_fc -1 ;  
006c			key_face_held: equ key_fd - 1   
006c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
006c			  
006c			hardware_config: equ key_face_held - 10  
006c			  
006c			; hardware config switches  
006c			; TODO add bitmasks on includes for hardware  
006c			; high byte for expansion ids  
006c			;     0000 0000  no card inserted  
006c			;     0000 0001  storage card inserted  
006c			;     0000 0010  spi sd card active  
006c			  
006c			;       
006c			; low byte:  
006c			;     0000 0001   4x4 keypad  
006c			;     0000 0010   full keyboard  
006c			;     0000 0011   spi/ext keyboard  
006c			;     0000 0100   20x4 lcd  
006c			;     0000 1000   40x4 lcd  
006c			;     0000 1100   spi/ext display  
006c			;     0001 0000   ide interface available  
006c			  
006c			hardware_word: equ hardware_config - 2  
006c			  
006c			; debug marker - optional display of debug point on the debug screens  
006c			  
006c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
006c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
006c			  
006c			debug_umark: equ debug_vector - 6  ; current user mark  
006c			debug_mark: equ debug_umark - 4    ; internal word debug points  
006c			  
006c			; input_str vars  
006c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
006c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
006c			input_size: equ input_start -1  ; number of chars  
006c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
006c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
006c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
006c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
006c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
006c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
006c			input_len: equ input_cur_onoff - 5 ; length of current input  
006c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
006c			  
006c			; cursor blink rate  
006c			CUR_BLINK_RATE: equ $09  
006c			;CUR_BLINK_RATE: equ 15  
006c			  
006c			key_actual_pressed: equ input_cursor - 1   
006c			key_symbol: equ key_actual_pressed - 1   
006c			key_shift: equ key_symbol - 1   
006c			  
006c			; Display allocation  
006c			  
006c			;display_rows: equ 4     ; move out to mini and mega files  
006c			;display_cols: equ 20  
006c			  
006c			display_fb_len: equ display_rows*display_cols  
006c			  
006c			; primary frame buffer     
006c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
006c			; working frame buffers  
006c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
006c			display_fb3: equ  display_fb1-display_fb_len - 1  
006c			display_fb2: equ  display_fb3-display_fb_len - 1  
006c			;  
006c			; pointer to active frame buffer  
006c			display_fb_active: equ display_fb2 - 2  
006c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
006c			display_write_tmp: equ display_lcde1e2 - 2  
006c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
006c			  
006c			;  
006c			  
006c			;; can load into de directory  
006c			cursor_col: equ display_active-1  
006c			cursor_row: equ cursor_col-1  
006c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
006c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
006c			  
006c			; maths vars  
006c			  
006c			LFSRSeed: equ cursor_shape -20   
006c			randData: equ LFSRSeed - 2  
006c			xrandc: equ randData - 2  
006c			stackstore: equ xrandc - 2  
006c			seed1: equ  stackstore -2   
006c			seed2: equ seed1 - 2  
006c			  
006c			; cf storage vars  
006c			  
006c			iErrorNum:  equ seed2-1         ;Error number  
006c			iErrorReg:  equ iErrorNum -1              ;Error register  
006c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
006c			  
006c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
006c			  
006c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
006c			  
006c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
006c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
006c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
006c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
006c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
006c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
006c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
006c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
006c			store_tmpid: equ store_tmp3 - 1		; page temp id  
006c			store_tmpext: equ store_tmpid - 1		; file extent temp  
006c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
006c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
006c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
006c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
006c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
006c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
006c			;  
006c			; spi vars  
006c			  
006c			  
006c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
006c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
006c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
006c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
006c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
006c			spi_device_id: equ spi_device - 1    ; human readable bank number  
006c			  
006c			;;;;; forth cli params  
006c			  
006c			; TODO use a different frame buffer for forth???  
006c			  
006c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
006c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
006c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
006c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
006c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
006c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
006c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
006c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
006c			  
006c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
006c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
006c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
006c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
006c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
006c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
006c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
006c			  
006c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
006c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
006c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
006c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
006c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
006c			  
006c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
006c			  
006c			; os/forth token vars  
006c			  
006c			os_last_cmd: equ os_var_array-255  
006c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
006c			os_current_i: equ os_cli_cmd-2  
006c			os_cur_ptr: equ os_current_i-2  
006c			os_word_scratch: equ os_cur_ptr-30  
006c			os_tok_len: equ os_word_scratch - 2  
006c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
006c			os_tok_malloc: equ os_tok_ptr - 2  
006c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
006c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
006c			execscratch: equ os_input-255        ; exec cmd eval buffer  
006c			scratch: equ execscratch-255  
006c			  
006c			os_stack_1: equ scratch - 3       ; stack holding area 1  
006c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
006c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
006c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
006c			  
006c			  
006c			; temp locations for new word processing to save on adding more   
006c			  
006c			os_new_malloc: equ os_stack_4-2  
006c			os_new_parse_len: equ os_new_malloc - 2  
006c			os_new_word_len: equ os_new_parse_len - 2  
006c			os_new_work_ptr: equ os_new_word_len - 2  
006c			os_new_src_ptr: equ os_new_work_ptr - 2  
006c			os_new_exec: equ os_new_src_ptr - 2  
006c			os_new_exec_ptr: equ os_new_exec - 2  
006c			  
006c			; resume memory alloocations....  
006c			  
006c			;os_view_disable: equ os_new_exec_ptr - 1  
006c			os_view_af: equ os_new_exec_ptr - 2  
006c			os_view_hl: equ os_view_af -2  
006c			os_view_de: equ os_view_hl - 2  
006c			os_view_bc: equ os_view_de - 2  
006c			  
006c			; stack checksum word  
006c			if DEBUG_STACK_IMB  
006c				curframe: equ  os_view_de - 5  
006c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
006c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			else  
006c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			endif  
006c			  
006c			; with data stack could see memory filled with junk. need some memory management   
006c			; malloc and free entry points added  
006c			  
006c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
006c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			;heap_end: equ free_list-1  ; Starting address of heap  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			heap_end: equ chk_word-1  ; Starting address of heap  
006c			  
006c			  
006c			;if BASE_KEV   
006c			;heap_start: equ 0800eh  ; Starting address of heap  
006c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;heap_start: equ baseram+15  ; Starting address of heap  
006c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;endif  
006c			  
006c			  
006c			;;;;  
006c			  
006c			  
006c			; change below to point to last memory alloc above  
006c			topusermem:  equ   heap_start  
006c			  
006c			;if BASE_KEV   
006c			;baseusermem: equ 08000h  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;;aseusermem:     equ    12  
006c			;baseusermem:     equ    prompt  
006c			;;baseusermem:     equ    endofcode  
006c			;endif  
006c			  
006c			  
006c			; **********************************************************************  
006c			; **  Constants  
006c			; **********************************************************************  
006c			  
006c			; Constants used by this code module  
006c			kDataReg:   EQU Device_D           ;PIO port A data register  
006c			kContReg:   EQU Device_D+2           ;PIO port A control register  
006c			  
006c			  
006c			portbdata:  equ Device_D+1    ; port b data  
006c			portbctl:   equ Device_D+3    ; port b control  
006c			  
006c			  
006c			;KEY_SHIFT:   equ 5  
006c			;KEY_SYMBOLSHIFT:  equ 6  
006c			  
006c			KEY_SHIFTLOCK: equ 4  
006c			  
006c			  
006c			KEY_UP: equ 5  
006c			KEY_NEXTWORD: equ 6  
006c			KEY_PREVWORD: equ 7  
006c			KEY_BS: equ 8  
006c			KEY_TAB:  equ 9  
006c			KEY_DOWN: equ 10  
006c			KEY_LEFT: equ 11  
006c			KEY_RIGHT: equ 12  
006c			KEY_CR:   equ 13  
006c			KEY_HOME: equ 14  
006c			KEY_END: equ 15  
006c			  
006c			KEY_F1: equ 16  
006c			KEY_F2: equ 17  
006c			KEY_F3: equ 18  
006c			KEY_F4: equ 19  
006c			  
006c			KEY_F5: equ 20  
006c			KEY_F6: equ 21  
006c			KEY_F7: equ 22  
006c			KEY_F8: equ 23  
006c			  
006c			KEY_F9: equ 24  
006c			KEY_F10: equ 25  
006c			KEY_F11: equ 26  
006c			KEY_F12: equ 27  
006c			  
006c			;if DEBUG_KEY  
006c			;	KEY_MATRIX_NO_PRESS: equ '.'  
006c			;	KEY_SHIFT:   equ '.'  
006c			;	KEY_SYMBOLSHIFT:  equ '.'  
006c			;else  
006c				KEY_SHIFT:   equ '~'  
006c				KEY_SYMBOLSHIFT:  equ '~'  
006c				KEY_MATRIX_NO_PRESS: equ '~'  
006c			;endi  
006c			  
006c			  
006c			  
006c			  
006c			; Macro to make adding debug marks easier  
006c			  
006c			DMARK: macro str  
006c				push af  
006c				ld a, (.dmark)  
006c				ld (debug_mark),a  
006c				ld a, (.dmark+1)  
006c				ld (debug_mark+1),a  
006c				ld a, (.dmark+2)  
006c				ld (debug_mark+2),a  
006c				jr .pastdmark  
006c			.dmark: db str  
006c			.pastdmark: pop af  
006c			  
006c			endm  
006c			  
006c			  
006c			; macro to detect for stack imbalances  
006c			  
006c			include "stackimbal.asm"  
006c			; Macro and code to detect stock imbalances 
006c			 
006c			SPPUSH: equ 0 
006c			 
006c			; Add a stack frame which can be checked before return 
006c			 
006c			STACKFRAME: macro onoff frame1 frame2 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c						exx 
006c			 
006c						ld de, frame1 
006c						ld a, d 
006c						ld hl, curframe 
006c						call hexout 
006c						ld a, e 
006c						ld hl, curframe+2 
006c						call hexout 
006c			  
006c						ld hl, frame1 
006c						push hl 
006c						ld hl, frame2 
006c						push hl 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			endm 
006c			 
006c			STACKFRAMECHK: macro onoff frame1 frame2 
006c			 
006c					 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						exx 
006c						; check stack frame SP 
006c			 
006c						ld hl, frame2 
006c						pop de   ; frame2 
006c			 
006c						call cmp16 
006c						jr nz, .spnosame 
006c						 
006c			 
006c						ld hl, frame1 
006c						pop de   ; frame1 
006c			 
006c						call cmp16 
006c						jr z, .spfrsame 
006c			 
006c						.spnosame: call showsperror 
006c			 
006c						.spfrsame: nop 
006c			 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			 
006c			 
006c			endm 
006c			 
006c			 
006c			; for a sub routine, wrap SP collection and comparisons 
006c			 
006c			; Usage: 
006c			; 
006c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
006c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
006c			 
006c			SAVESP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c			 
006c						ld (store_sp+(storeword*4)), sp 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			CHECKSP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c			 
006c						; save SP after last save 
006c				 
006c						ld (store_sp+(storeword*4)+2), sp 
006c			 
006c						push hl 
006c						ld hl, store_sp+(storeword*4) 
006c						call check_stack_sp  
006c						pop hl 
006c			 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			if DEBUG_STACK_IMB 
006c			 
006c			check_stack_sp: 
006c					push de 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					push de 
006c			 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					pop hl 
006c			 
006c			 
006c					; check to see if the same 
006c			 
006c					call cmp16 
006c					jr z, .spsame 
006c			 
006c					; not same 
006c			 
006c					call showsperror 
006c			.spsame: 
006c			 
006c					pop de 
006c			 
006c					ret 
006c			 
006c			.sperr:  db "Stack imbalance",0 
006c			 
006c			 
006c			showsperror: 
006c			 
006c			 
006c				push hl 
006c				push af 
006c				push de 
006c				call clear_display 
006c				ld de, .sperr 
006c				ld a,0 
006c			;	ld de,os_word_scratch 
006c				call str_at_display 
006c				ld a, display_row_1+17 
006c				ld de, debug_mark 
006c				call str_at_display 
006c				ld a, 0 
006c				ld (curframe+4),a 
006c				ld hl, curframe 
006c				ld de, os_word_scratch 
006c				ld a, display_row_4 
006c				call str_at_display 
006c				call update_display 
006c				;call break_point_state 
006c				call cin_wait 
006c			 
006c			;	ld a, ' ' 
006c			;	ld (os_view_disable), a 
006c				call bp_on 
006c				pop de	 
006c				pop af 
006c				pop hl 
006c				CALLMONITOR 
006c				ret 
006c			 
006c			endif 
006c			 
006c			 
006c			 
006c			; eof 
# End of file stackimbal.asm
006c			  
006c			;TODO macro to calc col and row offset into screen  
006c			  
006c			  
006c			  
006c			hardware_init:  
006c			  
006c				  
006c			  
006c					;ld a, 0  
006c					;ld (hardware_diag), a  
006c			  
006c					; clear all the buffers  
006c			  
006c 21 45 fc				ld hl, display_fb1  
006f 22 01 fb				ld (display_fb_active), hl  
0072			  
0072 cd aa 0d				call clear_display  
0075			  
0075 21 03 fb				ld hl, display_fb2  
0078 22 01 fb				ld (display_fb_active), hl  
007b			  
007b cd aa 0d				call clear_display  
007e			  
007e					; init primary frame buffer area  
007e 21 e6 fc				ld hl, display_fb0  
0081 22 01 fb				ld (display_fb_active), hl  
0084			  
0084 cd aa 0d				call clear_display  
0087			  
0087			  
0087 cd a6 6f				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
008a			  
008a cd 3d 72			call key_init  
008d cd 56 02			call storage_init  
0090			  
0090				; setup malloc functions  
0090			  
0090				if MALLOC_1  
0090 cd 95 13				call  heap_init  
0093				endif  
0093				if MALLOC_4  
0093					call  heap_init  
0093				endif  
0093			  
0093				; init sound hardware if present  
0093			  
0093				if SOUND_ENABLE  
0093					call sound_init  
0093				endif  
0093			  
0093				; lcd test sequence  
0093					  
0093 cd cd 0d			call update_display  
0096 cd ed 0c			call delay1s  
0099 3e 2b			ld a,'+'  
009b cd af 0d			call fill_display  
009e cd cd 0d			call update_display  
00a1 cd ed 0c			call delay1s  
00a4 3e 2a			ld a,'*'  
00a6 cd af 0d			call fill_display  
00a9 cd cd 0d			call update_display  
00ac cd ed 0c			call delay1s  
00af 3e 2d			ld a,'-'  
00b1 cd af 0d			call fill_display  
00b4 cd cd 0d			call update_display  
00b7 cd ed 0c			call delay1s  
00ba			  
00ba			; boot splash screen  
00ba			if display_cols == 20	  
00ba			        ld a, display_row_1    
00ba			else  
00ba 3e 0a		        ld a, display_row_1 +10   
00bc			endif  
00bc 11 22 1b			ld de, prom_bootmsg  
00bf cd bd 0d			call str_at_display  
00c2 cd cd 0d			call update_display  
00c5			  
00c5			  
00c5 cd ed 0c			call delay1s  
00c8 cd ed 0c			call delay1s  
00cb			if display_cols == 20	  
00cb			            LD   A, display_row_3+2  
00cb			else  
00cb 3e 5c		            LD   A, display_row_3+12  
00cd			endif  
00cd 11 37 1b			ld de, prom_bootmsg1  
00d0 cd bd 0d			call str_at_display  
00d3			; display debug level  
00d3 3e 78		            LD   A, display_row_4  
00d5 11 1b 00			ld de, debuglevel  
00d8 cd bd 0d			call str_at_display  
00db			  
00db cd cd 0d			call update_display  
00de cd ed 0c			call delay1s  
00e1 cd ed 0c			call delay1s  
00e4			  
00e4			;	ld a, display_row_4+3  
00e4			;	ld de, bootmsg2  
00e4			;	call str_at_display  
00e4			;	call update_display  
00e4			;	call delay1s  
00e4			;	call delay1s  
00e4			  
00e4			; debug mark setup  
00e4			  
00e4 3e 5f		ld a, '_'  
00e6 32 a0 fd		ld (debug_mark),a  
00e9 32 a1 fd		ld (debug_mark+1),a  
00ec 32 a2 fd		ld (debug_mark+2),a  
00ef 3e 00		ld a,0  
00f1 32 a3 fd		ld (debug_mark+3),a  
00f4 32 a4 fd		ld (debug_umark),a  
00f7			  
00f7 c9					ret  
00f8			  
00f8			  
00f8			;bootmsg2:	db "Firmware v0.1",0  
00f8			  
00f8			; a 4x20 lcd  
00f8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00f8			  
00f8			;if display_cols == 20  
00f8			;	include "firmware_lcd_4x20.asm"  
00f8			;endif  
00f8			  
00f8			;if display_cols == 40  
00f8			;	include "firmware_lcd_4x40.asm"  
00f8			;endif  
00f8			  
00f8			;  
00f8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00f8			; TODO abstract the bit bang video out interface for dual display  
00f8			; TODO wire video out to tx pin on rc2014 bus  
00f8			  
00f8			; must supply cin, and cin_wait for low level hardware abstraction   
00f8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00f8			; test scancode  
00f8			  
00f8			;;;;;  
00f8			;;;  
00f8			; Moved out to mini and maxi versions  
00f8			;  
00f8			; include "firmware_key_4x4.asm"  
00f8			; using existing 4 wire x 4 resistor array for input  
00f8			;include "firmware_key_4x10.asm"  
00f8			; need to mod the board for 5 rows due to resistor array  
00f8			;include "firmware_key_5x10.asm"  
00f8			  
00f8			; storage hardware interface  
00f8			  
00f8			; use microchip serial eeprom for storage  
00f8			  
00f8			  
00f8			if STORAGE_SE  
00f8				include "firmware_spi.asm"  
00f8			; my spi protocol (used by storage) 
00f8			 
00f8			; SPI pins 
00f8			 
00f8			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00f8			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00f8			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00f8			 
00f8			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00f8			; chip pin 4 gnd 
00f8			 
00f8			 
00f8			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00f8			SPI_CE1: equ 1      ;    port a1 pin 14  
00f8			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00f8			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00f8			SPI_CE4: equ 4      ; port a4     pin 10 
00f8			 
00f8			; active low AND masks 
00f8			 
00f8			;SPI_CE0_MASK: equ    255-1 
00f8			;SPI_CE1_MASK: equ   255-2 
00f8			;SPI_CE2_MASK: equ   255-4 
00f8			;SPI_CE3_MASK: equ   255-8 
00f8			;SPI_CE4_MASK: equ   255-16 
00f8			SPI_CE_HIGH:  equ 255 
00f8			 
00f8			 
00f8			 
00f8			;  Perform SCLK wait pulse 
00f8			 
00f8			spi_clk: 
00f8 f5				push af 
00f9 3a 99 f9			ld a, (spi_clktime) 
00fc fe 00			cp 0 
00fe 28 03			jr z, .scskip 
0100 cd d2 0c			call aDelayInMS 
0103			.scskip: 
0103 f1				pop af 
0104 c9				ret 
0105			 
0105			 
0105			 
0105			; TODO store port id for spi device ie dev c 
0105			; TODO store pin for SO 
0105			; TODO store pin for SI 
0105			; TODO store pin for SCLK 
0105			 
0105			; 
0105			 
0105			; ensure that spi bus is in a stable state with default pins  
0105			 
0105			se_stable_spi:   
0105			 
0105				 ; set DI high, CE high , SCLK low 
0105				;ld a, SPI_DI | SPI_CE0 
0105 3e 07			ld a, SPI_DI  
0107 cd 11 02			call spi_ce_high 
010a d3 80			 out (storage_adata),a 
010c 32 96 f9			ld (spi_portbyte),a 
010f			 
010f				if DEBUG_SPI 
010f					push hl 
010f					ld l, a 
010f					DMARK "SPI" 
010f					CALLMONITOR 
010f					pop hl 
010f				endif 
010f c9				ret 
0110			 
0110			; byte to send in a 
0110			 
0110			spi_send_byte: 
0110				; save byte to send for bit mask shift out 
0110 4f			        ld c,a 
0111 3a 96 f9			ld a,(spi_portbyte) 
0114				  
0114				; clock out	each bit of the byte msb first 
0114			 
0114 06 08			ld b, 8 
0116			.ssb1: 
0116				; clear so bit  
0116 cb bf			res SPI_DI, a 
0118 cb 11			rl c 
011a				; if bit 7 is set then carry is set 
011a 30 02			jr nc, .ssb2 
011c cb ff			set SPI_DI,a 
011e			.ssb2:  ; output bit to ensure it is stable 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121				; clock bit high 
0121 cb ef			set SPI_SCLK,a 
0123 d3 80			out (storage_adata),a 
0125 00				nop 
0126 cd f8 00			call spi_clk 
0129				; then low 
0129 cb af			res SPI_SCLK,a 
012b d3 80			out (storage_adata),a 
012d 00				nop 
012e cd f8 00			call spi_clk 
0131 10 e3			djnz .ssb1 
0133			 
0133 32 96 f9			ld (spi_portbyte),a 
0136 c9				ret 
0137			 
0137			; TODO low level get byte into A on spi 
0137			 
0137			spi_read_byte:  
0137			 
0137				; save byte to send for bit mask shift out 
0137 0e 00		    ld c,0 
0139 3a 96 f9			ld a,(spi_portbyte) 
013c				  
013c				; clock out	each bit of the byte msb first 
013c			 
013c			 
013c				; clock bit high 
013c cb ef			set SPI_SCLK,a 
013e d3 80			out (storage_adata),a 
0140 00				nop 
0141 cd f8 00			call spi_clk 
0144			 
0144			    ; read DO  
0144			 
0144 cb f9		    set 7,c 
0146 db 80			in a,(storage_adata) 
0148 cb 77		    bit SPI_DO,a 
014a 20 02		    jr nz, .b7 
014c cb b9		    res 7,c 
014e			.b7: 
014e				; then low 
014e cb af			res SPI_SCLK,a 
0150 d3 80			out (storage_adata),a 
0152 00				nop 
0153 cd f8 00			call spi_clk 
0156			     
0156			 
0156				; clock bit high 
0156 cb ef			set SPI_SCLK,a 
0158 d3 80			out (storage_adata),a 
015a 00				nop 
015b cd f8 00			call spi_clk 
015e			 
015e			    ; read DO  
015e			 
015e cb f1		    set 6,c 
0160 db 80			in a,(storage_adata) 
0162 cb 77		    bit SPI_DO,a 
0164 20 02		    jr nz, .b6 
0166 cb b1		    res 6,c 
0168			.b6: 
0168				; then low 
0168 cb af			res SPI_SCLK,a 
016a d3 80			out (storage_adata),a 
016c 00				nop 
016d cd f8 00			call spi_clk 
0170			 
0170				; clock bit high 
0170 cb ef			set SPI_SCLK,a 
0172 d3 80			out (storage_adata),a 
0174 00				nop 
0175 cd f8 00			call spi_clk 
0178			 
0178			 
0178			    ; read DO  
0178			 
0178 cb e9		    set 5,c 
017a db 80			in a,(storage_adata) 
017c cb 77		    bit SPI_DO,a 
017e 20 02		    jr nz, .b5 
0180 cb a9		    res 5,c 
0182			.b5: 
0182				; then low 
0182 cb af			res SPI_SCLK,a 
0184 d3 80			out (storage_adata),a 
0186 00				nop 
0187 cd f8 00			call spi_clk 
018a				; clock bit high 
018a cb ef			set SPI_SCLK,a 
018c d3 80			out (storage_adata),a 
018e 00				nop 
018f cd f8 00			call spi_clk 
0192			 
0192			    ; read DO  
0192			 
0192 cb e1		    set 4,c 
0194 db 80			in a,(storage_adata) 
0196 cb 77		    bit SPI_DO,a 
0198 20 02		    jr nz, .b4 
019a cb a1		    res 4,c 
019c			.b4: 
019c				; then low 
019c cb af			res SPI_SCLK,a 
019e d3 80			out (storage_adata),a 
01a0 00				nop 
01a1 cd f8 00			call spi_clk 
01a4				; clock bit high 
01a4 cb ef			set SPI_SCLK,a 
01a6 d3 80			out (storage_adata),a 
01a8 00				nop 
01a9 cd f8 00			call spi_clk 
01ac			 
01ac			    ; read DO  
01ac			 
01ac cb d9		    set 3,c 
01ae db 80			in a,(storage_adata) 
01b0 cb 77		    bit SPI_DO,a 
01b2 20 02		    jr nz, .b3 
01b4 cb 99		    res 3,c 
01b6			.b3: 
01b6				; then low 
01b6 cb af			res SPI_SCLK,a 
01b8 d3 80			out (storage_adata),a 
01ba 00				nop 
01bb cd f8 00			call spi_clk 
01be				; clock bit high 
01be cb ef			set SPI_SCLK,a 
01c0 d3 80			out (storage_adata),a 
01c2 00				nop 
01c3 cd f8 00			call spi_clk 
01c6			 
01c6			    ; read DO  
01c6			 
01c6 cb d1		    set 2,c 
01c8 db 80			in a,(storage_adata) 
01ca cb 77		    bit SPI_DO,a 
01cc 20 02		    jr nz, .b2 
01ce cb 91		    res 2,c 
01d0			.b2: 
01d0				; then low 
01d0 cb af			res SPI_SCLK,a 
01d2 d3 80			out (storage_adata),a 
01d4 00				nop 
01d5 cd f8 00			call spi_clk 
01d8				; clock bit high 
01d8 cb ef			set SPI_SCLK,a 
01da d3 80			out (storage_adata),a 
01dc 00				nop 
01dd cd f8 00			call spi_clk 
01e0			 
01e0			    ; read DO  
01e0			 
01e0 cb c9		    set 1,c 
01e2 db 80			in a,(storage_adata) 
01e4 cb 77		    bit SPI_DO,a 
01e6 20 02		    jr nz, .b1 
01e8 cb 89		    res 1,c 
01ea			.b1: 
01ea				; then low 
01ea cb af			res SPI_SCLK,a 
01ec d3 80			out (storage_adata),a 
01ee 00				nop 
01ef cd f8 00			call spi_clk 
01f2				; clock bit high 
01f2 cb ef			set SPI_SCLK,a 
01f4 d3 80			out (storage_adata),a 
01f6 00				nop 
01f7 cd f8 00			call spi_clk 
01fa			 
01fa			    ; read DO  
01fa			 
01fa cb c1		    set 0,c 
01fc db 80			in a,(storage_adata) 
01fe cb 77		    bit SPI_DO,a 
0200 20 02		    jr nz, .b0 
0202 cb 81		    res 0,c 
0204			.b0: 
0204				; then low 
0204 cb af			res SPI_SCLK,a 
0206 d3 80			out (storage_adata),a 
0208 00				nop 
0209 cd f8 00			call spi_clk 
020c			 
020c			 
020c 32 96 f9			ld (spi_portbyte),a 
020f			 
020f			    ; return byte 
020f 79			    ld a,c 
0210			 
0210			 
0210 c9				ret 
0211			 
0211			 
0211			 
0211			spi_ce_high: 
0211			 
0211				if DEBUG_SPI_HARD_CE0 
0211			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0211					ret 
0211			 
0211				endif 
0211			 
0211			 
0211 f5				push af 
0212			 
0212				; send direct ce to port b 
0212 3e ff			ld a, 255 
0214 d3 81			out (storage_bdata), a 
0216			 
0216 f1				pop af 
0217			 
0217				; for port a that shares with spi lines AND the mask 
0217			  
0217				if DEBUG_SPI 
0217					push hl 
0217					ld h, a 
0217				endif 
0217			;	ld c, SPI_CE_HIGH 
0217			;	and c 
0217 cb c7			set SPI_CE0, a 
0219 cb cf			set SPI_CE1, a 
021b cb d7			set SPI_CE2, a 
021d cb df			set SPI_CE3, a 
021f cb e7			set SPI_CE4, a 
0221			 
0221				if DEBUG_SPI 
0221					ld l, a 
0221					DMARK "CEh" 
0221					CALLMONITOR 
0221					pop hl 
0221				endif 
0221 c9				ret 
0222			 
0222			 
0222			spi_ce_low: 
0222			 
0222				if DEBUG_SPI_HARD_CE0 
0222			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0222					ret 
0222			 
0222				endif 
0222			 
0222 c5				push bc 
0223 f5				push af 
0224			 
0224				; send direct ce to port b 
0224 3a 98 f9			ld a, (spi_cartdev) 
0227 d3 81			out (storage_bdata), a 
0229			 
0229			 
0229			 
0229				; for port a that shares with spi lines AND the mask 
0229			 
0229 3a 95 f9			ld a, (spi_device)  
022c 4f				ld c, a 
022d			 
022d f1				pop af 
022e			 
022e				; detect CEx 
022e			 
022e				if DEBUG_SPI 
022e					push hl 
022e					ld h, a 
022e				endif 
022e			 
022e cb 41			bit SPI_CE0, c 
0230 20 04			jr nz, .cel1 
0232 cb 87			res SPI_CE0, a 
0234 18 1e			jr .celn 
0236			.cel1: 
0236 cb 49			bit SPI_CE1, c 
0238 20 04			jr nz, .cel2 
023a cb 8f			res SPI_CE1, a 
023c 18 16			jr .celn 
023e			.cel2: 
023e cb 51			bit SPI_CE2, c 
0240 20 04			jr nz, .cel3 
0242 cb 97			res SPI_CE2, a 
0244 18 0e			jr .celn 
0246			.cel3: 
0246 cb 59			bit SPI_CE3, c 
0248 20 04			jr nz, .cel4 
024a cb 9f			res SPI_CE3, a 
024c 18 06			jr .celn 
024e			.cel4: 
024e cb 61			bit SPI_CE4, c 
0250 20 02			jr nz, .celn 
0252 cb a7			res SPI_CE4, a 
0254			.celn: 
0254			 
0254			 
0254			 
0254			;	add c 
0254			 
0254				if DEBUG_SPI 
0254					ld l, a 
0254					DMARK "CEl" 
0254					CALLMONITOR 
0254					pop hl 
0254				endif 
0254 c1				pop bc 
0255 c9				ret 
0256			 
0256			 
0256			 
0256			; eof 
0256			 
0256			 
0256			 
0256			 
0256			 
# End of file firmware_spi.asm
0256				include "firmware_seeprom.asm"  
0256			; 
0256			; persisent storage interface via microchip serial eeprom 
0256			 
0256			; port a pio 2 
0256			; pa 7 - si 
0256			; pa 6 - sclk  
0256			; pa 5 - so 
0256			; pa 4 - cs 
0256			; pa 3 - cs 
0256			; pa 2 - cs 
0256			; pa 1 - cs 
0256			; pa 0 - cs 
0256			; 
0256			; TODO get block 
0256			; TODO save block 
0256			; TODO load file 
0256			; TODO save file 
0256			; TODO get dir  
0256			 
0256			;  
0256			storage_adata: equ Device_C    ; device c port a - onboard storage 
0256			storage_actl: equ Device_C+2     ; device c port a 
0256			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0256			storage_bctl: equ Device_C+3     ; device c port b 
0256			 
0256			 
0256			; TODO move these to hardware driver file 
0256			 
0256			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0256			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0256			; storage bank file system format 
0256			; 
0256			; first page of bank: 
0256			; 	addr 0 - status check 
0256			;       addr 1 - write protect flag 
0256			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0256			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0256			;         TODO see if scanning whole of for available next file id is fast enough 
0256			;	addr 4 > zero term string of bank label 
0256			; 
0256			;        
0256			;  
0256			; first page of any file: 
0256			;      byte 0 - file id  
0256			;      byte 1-17 - fixed file name  
0256			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0256			; 
0256			; other pages of any file: 
0256			;      byte 0 - file id 
0256			;      byte 1> - file data 
0256			; 
0256			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0256			;  
0256			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0256			 
0256			 
0256			;storage_so_bit: 5 
0256			;storage_si_bit: 7 
0256			;storage_sclk_bit: 6 
0256			  
0256			 
0256			; init storage pio 
0256			 
0256			storage_init: 
0256			 
0256			 
0256					; set default SPI clk pulse time as disabled 
0256			 
0256 3e 00				ld a, 0 
0258 32 99 f9				ld (spi_clktime), a 
025b			 
025b					; init hardware 
025b			 
025b 3e cf		            LD   A, 11001111b 
025d d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
025f 3e 00		            LD   A, 00000000b 
0261 cb f7			set SPI_DO,a 
0263			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0263 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0265			 
0265 3e cf		            LD   A, 11001111b 
0267 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0269 3e 00		            LD   A, 00000000b 
026b d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
026d			 
026d				; set all external spi devices off  
026d 3e ff			ld a, 255 
026f 32 95 f9			ld (spi_device), a 
0272 32 98 f9			ld (spi_cartdev), a 
0275			 
0275					; ensure the spi bus is in a default stable state 
0275 cd 05 01				call se_stable_spi 
0278			 
0278			; TODO scan spi bus and gather which storage banks are present 
0278			 
0278			; populate store_bank_active  
0278			; for each ce line activate and attempt to write first byte of bank and read back 
0278			; if zero is returned then bank is empty 
0278			;   
0278			; 
0278			 
0278					; init file extent cache to save on slow reads 
0278			 
0278			;	ld hl, store_filecache 
0278			;	ld de, 0 
0278			;	ld hl,(de)	 
0278			 
0278			 
0278 c9			    ret 
0279			 
0279			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0279			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0279			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0279			 
0279			; INSTRUCTION SET 
0279			; READ 0000 0011 Read data from memory array beginning at selected address 
0279			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0279			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0279			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0279			; RDSR 0000 0101 Read STATUS register 
0279			; WRSR 0000 0001 Write STATUS register 
0279			; PE 0100 0010 Page Erase – erase one page in memory array 
0279			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0279			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0279			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0279			 
0279			; TODO send byte steam for page without setting the address for every single byte 
0279			; TODO read byte  
0279			 
0279			; byte in a 
0279			; address in hl  
0279			se_writebyte: 
0279			        
0279			    ;   ld c, a 
0279 f5			        push af 
027a e5			        push hl 
027b			 
027b			    ; initi write mode 
027b			    ; 
027b			    ;CS low 
027b			 
027b 3a 96 f9		       ld a,(spi_portbyte) 
027e cd 22 02			call spi_ce_low 
0281			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0281 d3 80		       out (storage_adata),a 
0283 32 96 f9		       ld (spi_portbyte), a 
0286			 
0286			    ;clock out wren instruction 
0286			 
0286 3e 06		    ld a, store_wren_ins 
0288 cd 10 01		    call spi_send_byte  
028b			 
028b			    ;cs high to enable write latch 
028b			 
028b 3a 96 f9		       ld a,(spi_portbyte) 
028e cd 11 02			call spi_ce_high 
0291			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0291 d3 80		       out (storage_adata),a 
0293 32 96 f9		       ld (spi_portbyte), a 
0296			 
0296 00				nop 
0297			    ; 
0297			    ; intial write data 
0297			    ; 
0297			    ; cs low 
0297			     
0297 3a 96 f9		       ld a,(spi_portbyte) 
029a cd 22 02			call spi_ce_low 
029d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
029d d3 80		       out (storage_adata),a 
029f 32 96 f9		       ld (spi_portbyte), a 
02a2			 
02a2			    ; clock out write instruction 
02a2			     
02a2 3e 02		    ld a, store_write_ins  
02a4 cd 10 01		    call spi_send_byte  
02a7			 
02a7			    ; clock out address (depending on address size) 
02a7			     
02a7 e1			    pop hl 
02a8 7c			    ld a,h    ; address out msb first 
02a9 cd 10 01		    call spi_send_byte  
02ac 7d			    ld a,l 
02ad cd 10 01		    call spi_send_byte  
02b0			 
02b0			    ; clock out byte(s) for page 
02b0			 
02b0 f1			    pop af 
02b1 cd 10 01		    call spi_send_byte  
02b4			 
02b4			    ; end write with ce high 
02b4 3a 96 f9		       ld a,(spi_portbyte) 
02b7			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b7 cd 11 02			call spi_ce_high 
02ba d3 80		       out (storage_adata),a 
02bc 32 96 f9		       ld (spi_portbyte), a 
02bf			 
02bf				; pause for internal write cycle 
02bf 3e 0a			ld a, 10 
02c1 cd d2 0c			call aDelayInMS 
02c4 c9			    ret 
02c5			 
02c5			; buffer to write in de 
02c5			; address in hl  
02c5			se_writepage: 
02c5			        
02c5			    ;   ld c, a 
02c5 d5				push de 
02c6 e5			        push hl 
02c7			 
02c7			    ; initi write mode 
02c7			    ; 
02c7			    ;CS low 
02c7			 
02c7 3a 96 f9		       ld a,(spi_portbyte) 
02ca cd 22 02			call spi_ce_low 
02cd			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cd d3 80		       out (storage_adata),a 
02cf 32 96 f9		       ld (spi_portbyte), a 
02d2			 
02d2			    ;clock out wren instruction 
02d2			 
02d2 3e 06		    ld a, store_wren_ins 
02d4 cd 10 01		    call spi_send_byte  
02d7			 
02d7			    ;cs high to enable write latch 
02d7			 
02d7 3a 96 f9		       ld a,(spi_portbyte) 
02da cd 11 02			call spi_ce_high 
02dd			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02dd d3 80		       out (storage_adata),a 
02df 32 96 f9		       ld (spi_portbyte), a 
02e2			 
02e2 00				nop 
02e3			    ; 
02e3			    ; intial write data 
02e3			    ; 
02e3			    ; cs low 
02e3			     
02e3 3a 96 f9		       ld a,(spi_portbyte) 
02e6			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02e6 cd 22 02			call spi_ce_low 
02e9 d3 80		       out (storage_adata),a 
02eb 32 96 f9		       ld (spi_portbyte), a 
02ee			 
02ee			    ; clock out write instruction 
02ee			     
02ee 3e 02		    ld a, store_write_ins  
02f0 cd 10 01		    call spi_send_byte  
02f3			 
02f3			    ; clock out address (depending on address size) 
02f3			     
02f3 e1			    pop hl 
02f4 7c			    ld a,h    ; address out msb first 
02f5 cd 10 01		    call spi_send_byte  
02f8 7d			    ld a,l 
02f9 cd 10 01		    call spi_send_byte  
02fc			 
02fc			    ; clock out byte(s) for page 
02fc			 
02fc e1				pop hl 
02fd 06 40			ld b, STORE_BLOCK_PHY 
02ff			.bytewrite: 
02ff			 
02ff 7e				ld a,(hl) 
0300 e5			    push hl 
0301 c5				push bc 
0302 cd 10 01		    call spi_send_byte  
0305 c1				pop bc 
0306 e1				pop hl 
0307			 
0307			    ; end write with ce high 
0307 3a 96 f9		       ld a,(spi_portbyte) 
030a cd 11 02			call spi_ce_high 
030d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
030d d3 80		       out (storage_adata),a 
030f 32 96 f9		       ld (spi_portbyte), a 
0312			 
0312 23				inc hl 
0313 10 ea			djnz .bytewrite 
0315			 
0315				; pause for internal write cycle 
0315 3e 64			ld a, 100 
0317 cd d2 0c			call aDelayInMS 
031a c9			    ret 
031b			; returns byte in a 
031b			; address in hl  
031b			se_readbyte: 
031b d5				push de 
031c c5				push bc 
031d			 
031d			    ;   ld c, a 
031d e5			        push hl 
031e			 
031e			    ; initi write mode 
031e			    ; 
031e			    ;CS low 
031e			 
031e 3a 96 f9		       ld a,(spi_portbyte) 
0321 cd 22 02			call spi_ce_low 
0324			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0324 d3 80		       out (storage_adata),a 
0326 32 96 f9		       ld (spi_portbyte), a 
0329			 
0329			    ;clock out wren instruction 
0329			 
0329 3e 03		    ld a, store_read_ins 
032b cd 10 01		    call spi_send_byte  
032e			 
032e			 
032e			    ; clock out address (depending on address size) 
032e			     
032e e1			    pop hl 
032f 7c			    ld a,h    ; address out msb first 
0330 cd 10 01		    call spi_send_byte  
0333 7d			    ld a,l 
0334 cd 10 01		    call spi_send_byte  
0337			 
0337			    ; clock in byte(s) for page 
0337			 
0337 cd 37 01		    call spi_read_byte  
033a f5				push af 
033b			 
033b			    ; end write with ce high 
033b 3a 96 f9		       ld a,(spi_portbyte) 
033e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
033e cd 11 02			call spi_ce_high 
0341 d3 80		       out (storage_adata),a 
0343 32 96 f9		       ld (spi_portbyte), a 
0346			 
0346 f1				pop af 
0347			 
0347 c1				pop bc 
0348 d1				pop de 
0349			 
0349 c9			    ret 
034a			 
034a			if DEBUG_STORESE 
034a			 
034a			storageput:  
034a			 
034a			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
034a			 
034a 21 f8 f0			ld hl,scratch+2 
034d cd 9d 12			call get_word_hl 
0350			 
0350				; stuff it here for the moment as it will be overwritten later anyway 
0350			 
0350 22 19 f4			ld (os_cur_ptr),hl	 
0353			 
0353			 
0353			; get pointer to start of string 
0353			 
0353 21 fd f0			ld hl, scratch+7 
0356			 
0356			; loop writing char of string to eeprom 
0356			 
0356 7e			.writestr:	ld a,(hl) 
0357 fe 00				cp 0 
0359 28 12				jr z, .wsdone		; done writing 
035b e5					push hl 
035c 2a 19 f4				ld hl,(os_cur_ptr) 
035f cd 79 02				call se_writebyte 
0362			 
0362 2a 19 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0365 23					inc hl 
0366 22 19 f4				ld (os_cur_ptr),hl 
0369			 
0369					; restore string pointer and get next char 
0369			 
0369 e1					pop hl 
036a 23					inc hl 
036b 18 e9				jr .writestr 
036d			 
036d			 
036d			 
036d			.wsdone: 
036d			 
036d			 
036d			; when done load first page into a buffer  
036d			 
036d 21 00 80				ld hl,08000h		; start in ram 
0370 22 19 f4				ld (os_cur_ptr),hl 
0373 21 00 00				ld hl, 0		 ; start of page 
0376 22 1e f1				ld (scratch+40),hl	; hang on to it 
0379			 
0379 06 80				ld b, 128		; actually get more then one page 
037b c5			.wsload:	push bc 
037c 2a 1e f1				ld hl,(scratch+40) 
037f e5					push hl 
0380 cd 1b 03				call se_readbyte 
0383			 
0383					; a now as the byte 
0383			 
0383 2a 19 f4				ld hl,(os_cur_ptr) 
0386 77					ld (hl),a 
0387					; inc next buffer area 
0387 23					inc hl 
0388 22 19 f4				ld (os_cur_ptr),hl 
038b			 
038b					; get eeprom position, inc and save for next round 
038b e1					pop hl		 
038c 23					inc hl 
038d 22 1e f1				ld (scratch+40),hl 
0390 c1					pop bc 
0391 10 e8				djnz .wsload 
0393			 
0393			; set 'd' pointer to start of buffer 
0393			 
0393 21 00 80				ld hl,08000h 
0396 22 19 f4				ld (os_cur_ptr),hl 
0399			 
0399			 
0399 c9			ret 
039a			 
039a			 
039a c9			storageread: ret 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			endif 
039b			 
039b			 
039b			 
# End of file firmware_seeprom.asm
039b			else  
039b			   ; create some stubs for the labels  
039b			se_readbyte: ret  
039b			se_writebyte: ret  
039b			storage_init: ret  
039b			  
039b			endif  
039b			  
039b			; use cf card for storage - throwing timeout errors. Hardware or software?????  
039b			;include "firmware_cf.asm"  
039b			  
039b			; load up high level storage hardward abstractions  
039b			include "firmware_storage.asm"  
039b			 
039b			; persisent storage hardware abstraction layer  
039b			 
039b			 
039b			 
039b			; Block 0 on storage is a config state 
039b			 
039b			 
039b			 
039b			; TODO add read phy block and write phy block functions 
039b			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
039b			 
039b			; Abstraction layer  
039b			 
039b			; Logocial block size is same size as physical size - using tape concept 
039b			 
039b			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
039b			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
039b			 
039b			 
039b			 
039b			; Filesystem layout (Logical layout) 
039b			; 
039b			; Block 0 - Bank config  
039b			; 
039b			;      Byte - 0 file id counter 
039b			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
039b			;      Byte - 3-20 zero terminated bank label 
039b			; 
039b			; Block 1 > File storage 
039b			; 
039b			;      Byte 0 file id    - block 0 file details 
039b			;      Byte 1 block id - block 0 is file  
039b			;            Byte 2-15 - File name 
039b			; 
039b			;       - to end of block data 
039b			; 
039b			 
039b			; Get ID for the file named in pointer held HL 
039b			; Returns ID in HL = 255 if no file found 
039b			 
039b			storage_getid: 
039b			 
039b 22 a8 f9			ld (store_tmp1), hl 
039e			 
039e				if DEBUG_STORESE 
039e					DMARK "SGI" 
039e f5				push af  
039f 3a b3 03			ld a, (.dmark)  
03a2 32 a0 fd			ld (debug_mark),a  
03a5 3a b4 03			ld a, (.dmark+1)  
03a8 32 a1 fd			ld (debug_mark+1),a  
03ab 3a b5 03			ld a, (.dmark+2)  
03ae 32 a2 fd			ld (debug_mark+2),a  
03b1 18 03			jr .pastdmark  
03b3 ..			.dmark: db "SGI"  
03b6 f1			.pastdmark: pop af  
03b7			endm  
# End of macro DMARK
03b7					CALLMONITOR 
03b7 cd aa fd			call debug_vector  
03ba				endm  
# End of macro CALLMONITOR
03ba				endif 
03ba				; get block 0 and set counter for number of files to scan 
03ba			 
03ba cd 25 05			call storage_get_block_0 
03bd			 
03bd 3a af f9			ld a, (store_page) 
03c0 47				ld b, a 
03c1			 
03c1				; get extent 0 of each file id 
03c1			 
03c1				if DEBUG_STORESE 
03c1					DMARK "SGc" 
03c1 f5				push af  
03c2 3a d6 03			ld a, (.dmark)  
03c5 32 a0 fd			ld (debug_mark),a  
03c8 3a d7 03			ld a, (.dmark+1)  
03cb 32 a1 fd			ld (debug_mark+1),a  
03ce 3a d8 03			ld a, (.dmark+2)  
03d1 32 a2 fd			ld (debug_mark+2),a  
03d4 18 03			jr .pastdmark  
03d6 ..			.dmark: db "SGc"  
03d9 f1			.pastdmark: pop af  
03da			endm  
# End of macro DMARK
03da					CALLMONITOR 
03da cd aa fd			call debug_vector  
03dd				endm  
# End of macro CALLMONITOR
03dd				endif 
03dd 60			.getloop:	ld h, b 
03de 2e 00				ld l, 0 
03e0 c5					push bc 
03e1			 
03e1 11 af f9				ld de, store_page 
03e4				if DEBUG_STORESE 
03e4					DMARK "SGr" 
03e4 f5				push af  
03e5 3a f9 03			ld a, (.dmark)  
03e8 32 a0 fd			ld (debug_mark),a  
03eb 3a fa 03			ld a, (.dmark+1)  
03ee 32 a1 fd			ld (debug_mark+1),a  
03f1 3a fb 03			ld a, (.dmark+2)  
03f4 32 a2 fd			ld (debug_mark+2),a  
03f7 18 03			jr .pastdmark  
03f9 ..			.dmark: db "SGr"  
03fc f1			.pastdmark: pop af  
03fd			endm  
# End of macro DMARK
03fd					CALLMONITOR 
03fd cd aa fd			call debug_vector  
0400				endm  
# End of macro CALLMONITOR
0400				endif 
0400 cd cd 09				call storage_read 
0403 cd 07 10				call ishlzero 
0406 28 2d				jr z, .gap 
0408					 
0408					; have a file name read. Is it one we want. 
0408			 
0408 2a a8 f9				ld hl, (store_tmp1) 
040b 11 b2 f9				ld de, store_page+3   ; file name 
040e			 
040e				if DEBUG_STORESE 
040e					DMARK "SGc" 
040e f5				push af  
040f 3a 23 04			ld a, (.dmark)  
0412 32 a0 fd			ld (debug_mark),a  
0415 3a 24 04			ld a, (.dmark+1)  
0418 32 a1 fd			ld (debug_mark+1),a  
041b 3a 25 04			ld a, (.dmark+2)  
041e 32 a2 fd			ld (debug_mark+2),a  
0421 18 03			jr .pastdmark  
0423 ..			.dmark: db "SGc"  
0426 f1			.pastdmark: pop af  
0427			endm  
# End of macro DMARK
0427					CALLMONITOR 
0427 cd aa fd			call debug_vector  
042a				endm  
# End of macro CALLMONITOR
042a				endif 
042a cd 7c 13				call strcmp 
042d 20 06				jr nz, .gap   ; not this one 
042f			 
042f c1				        pop bc 
0430			 
0430 26 00				ld h, 0 
0432 68					ld l, b 
0433 18 22				jr .getdone 
0435						 
0435			 
0435			 
0435			 
0435			.gap: 
0435				if DEBUG_STORESE 
0435					DMARK "SGg" 
0435 f5				push af  
0436 3a 4a 04			ld a, (.dmark)  
0439 32 a0 fd			ld (debug_mark),a  
043c 3a 4b 04			ld a, (.dmark+1)  
043f 32 a1 fd			ld (debug_mark+1),a  
0442 3a 4c 04			ld a, (.dmark+2)  
0445 32 a2 fd			ld (debug_mark+2),a  
0448 18 03			jr .pastdmark  
044a ..			.dmark: db "SGg"  
044d f1			.pastdmark: pop af  
044e			endm  
# End of macro DMARK
044e					CALLMONITOR 
044e cd aa fd			call debug_vector  
0451				endm  
# End of macro CALLMONITOR
0451				endif 
0451			 
0451 c1					pop bc 
0452 10 89				djnz .getloop 
0454 21 ff 00				ld hl, 255 
0457			.getdone: 
0457			 
0457				if DEBUG_STORESE 
0457					DMARK "SGe" 
0457 f5				push af  
0458 3a 6c 04			ld a, (.dmark)  
045b 32 a0 fd			ld (debug_mark),a  
045e 3a 6d 04			ld a, (.dmark+1)  
0461 32 a1 fd			ld (debug_mark+1),a  
0464 3a 6e 04			ld a, (.dmark+2)  
0467 32 a2 fd			ld (debug_mark+2),a  
046a 18 03			jr .pastdmark  
046c ..			.dmark: db "SGe"  
046f f1			.pastdmark: pop af  
0470			endm  
# End of macro DMARK
0470					CALLMONITOR 
0470 cd aa fd			call debug_vector  
0473				endm  
# End of macro CALLMONITOR
0473				endif 
0473			 
0473 c9				ret 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			; Read Block 
0474			; ---------- 
0474			; 
0474			; With current bank 
0474			;  
0474			; Get block number to read 
0474			; Load physical blocks starting at start block into buffer 
0474			 
0474			; de points to buffer to use 
0474			; hl holds logical block number  
0474			 
0474			storage_read_block: 
0474			 
0474				; TODO bank selection 
0474			 
0474				; for each of the physical blocks read it into the buffer 
0474 06 40			ld b, STORE_BLOCK_PHY 
0476			 
0476				if DEBUG_STORESE 
0476 d5					push de 
0477				endif 
0477				 
0477			.rl1:    
0477			 
0477				; read physical block at hl into de 
0477			        ; increment hl and de to next read position on exit 
0477			 
0477 e5				push hl 
0478 d5				push de	 
0479 c5				push bc 
047a			;	if DEBUG_STORESE 
047a			;		push af 
047a			;		ld a, 'R' 
047a			;		ld (debug_mark),a 
047a			;		pop af 
047a			;		CALLMONITOR 
047a			;	endif 
047a cd 1b 03			call se_readbyte 
047d			;	if DEBUG_STORESE 
047d			;		ld a,(spi_portbyte) 
047d			;		ld l, a 
047d			;		push af 
047d			;		ld a, '1' 
047d			;		ld (debug_mark),a 
047d			;		pop af 
047d			;		CALLMONITOR 
047d			;	endif 
047d c1				pop bc 
047e d1				pop de 
047f e1				pop hl 
0480 12				ld (de),a 
0481 23				inc hl 
0482 13				inc de 
0483			 
0483			;	if DEBUG_STORESE 
0483			;		push af 
0483			;		ld a, 'r' 
0483			;		ld (debug_mark),a 
0483			;		pop af 
0483			;		CALLMONITOR 
0483			;	endif 
0483			 
0483 10 f2			djnz .rl1 
0485			 
0485				if DEBUG_STORESE 
0485					DMARK "SRB" 
0485 f5				push af  
0486 3a 9a 04			ld a, (.dmark)  
0489 32 a0 fd			ld (debug_mark),a  
048c 3a 9b 04			ld a, (.dmark+1)  
048f 32 a1 fd			ld (debug_mark+1),a  
0492 3a 9c 04			ld a, (.dmark+2)  
0495 32 a2 fd			ld (debug_mark+2),a  
0498 18 03			jr .pastdmark  
049a ..			.dmark: db "SRB"  
049d f1			.pastdmark: pop af  
049e			endm  
# End of macro DMARK
049e d1					pop de 
049f			; 
049f			;		push af 
049f			;		ld a, 'R' 
049f			;		ld (debug_mark),a 
049f			;		pop af 
049f					CALLMONITOR 
049f cd aa fd			call debug_vector  
04a2				endm  
# End of macro CALLMONITOR
04a2				endif 
04a2 c9				ret	 
04a3				 
04a3			 
04a3			; File Size 
04a3			; --------- 
04a3			; 
04a3			;   hl file id 
04a3			; 
04a3			;  returns in hl the number of blocks 
04a3			 
04a3			storage_file_size: 
04a3 5d				ld e, l 
04a4 16 00			ld d, 0 
04a6 21 40 00			ld hl, STORE_BLOCK_PHY 
04a9					if DEBUG_FORTH_WORDS 
04a9						DMARK "SIZ" 
04a9 f5				push af  
04aa 3a be 04			ld a, (.dmark)  
04ad 32 a0 fd			ld (debug_mark),a  
04b0 3a bf 04			ld a, (.dmark+1)  
04b3 32 a1 fd			ld (debug_mark+1),a  
04b6 3a c0 04			ld a, (.dmark+2)  
04b9 32 a2 fd			ld (debug_mark+2),a  
04bc 18 03			jr .pastdmark  
04be ..			.dmark: db "SIZ"  
04c1 f1			.pastdmark: pop af  
04c2			endm  
# End of macro DMARK
04c2						CALLMONITOR 
04c2 cd aa fd			call debug_vector  
04c5				endm  
# End of macro CALLMONITOR
04c5					endif 
04c5 cd a7 07			call storage_findnextid 
04c8			 
04c8 cd 07 10			call ishlzero 
04cb			;	ld a, l 
04cb			;	add h 
04cb			;	cp 0 
04cb c8				ret z			; block not found so EOF 
04cc			 
04cc 11 af f9			ld de, store_page 
04cf cd 74 04			call storage_read_block 
04d2			 
04d2 3a b1 f9			ld a, (store_page+2)	 ; get extent count 
04d5 6f				ld l, a 
04d6 26 00			ld h, 0 
04d8 c9			 	ret 
04d9			 
04d9			 
04d9			; Write Block 
04d9			; ----------- 
04d9			; 
04d9			; With current bank 
04d9			;  
04d9			; Get block number to write 
04d9			; Write physical blocks starting at start block from buffer 
04d9			  
04d9			storage_write_block: 
04d9				; TODO bank selection 
04d9			 
04d9				; for each of the physical blocks read it into the buffer 
04d9 06 40			ld b, STORE_BLOCK_PHY 
04db			 
04db				if DEBUG_STORESE 
04db					DMARK "SWB" 
04db f5				push af  
04dc 3a f0 04			ld a, (.dmark)  
04df 32 a0 fd			ld (debug_mark),a  
04e2 3a f1 04			ld a, (.dmark+1)  
04e5 32 a1 fd			ld (debug_mark+1),a  
04e8 3a f2 04			ld a, (.dmark+2)  
04eb 32 a2 fd			ld (debug_mark+2),a  
04ee 18 03			jr .pastdmark  
04f0 ..			.dmark: db "SWB"  
04f3 f1			.pastdmark: pop af  
04f4			endm  
# End of macro DMARK
04f4			 
04f4					;push af 
04f4					;ld a, 'W' 
04f4					;ld (debug_mark),a 
04f4					;pop af 
04f4					CALLMONITOR 
04f4 cd aa fd			call debug_vector  
04f7				endm  
# End of macro CALLMONITOR
04f7				endif 
04f7			 
04f7			; might not be working 
04f7			;	call se_writepage 
04f7			 
04f7			;	ret 
04f7			; 
04f7			 
04f7			 
04f7			 
04f7			.wl1:    
04f7			 
04f7				; read physical block at hl into de 
04f7			        ; increment hl and de to next read position on exit 
04f7			 
04f7 e5				push hl 
04f8 d5				push de	 
04f9 c5				push bc 
04fa 1a				ld a,(de) 
04fb				;if DEBUG_STORESE 
04fb			;		push af 
04fb			;		ld a, 'W' 
04fb			;		ld (debug_mark),a 
04fb			;		pop af 
04fb			;		CALLMONITOR 
04fb			;	endif 
04fb cd 79 02			call se_writebyte 
04fe			;	call delay250ms 
04fe 00				nop 
04ff 00				nop 
0500 00				nop 
0501			;	if DEBUG_STORESE 
0501			;		push af 
0501			;		ld a, 'w' 
0501			;		ld (debug_mark),a 
0501			;		pop af 
0501			;		CALLMONITOR 
0501			;	endif 
0501 c1				pop bc 
0502 d1				pop de 
0503 e1				pop hl 
0504 23				inc hl 
0505 13				inc de 
0506			 
0506			 
0506 10 ef			djnz .wl1 
0508			 
0508				if DEBUG_STORESE 
0508					DMARK "SW2" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 a0 fd			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 a1 fd			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 a2 fd			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "SW2"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521			 
0521					;push af 
0521					;ld a, 'W' 
0521					;ld (debug_mark),a 
0521					;pop af 
0521					CALLMONITOR 
0521 cd aa fd			call debug_vector  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 c9				ret	 
0525			 
0525			; Init bank 
0525			; --------- 
0525			; 
0525			; With current bank 
0525			; 
0525			; Setup block 0 config 
0525			;     Set 0 file id counter 
0525			;     Set formatted byte pattern 
0525			;     Zero out bank label 
0525			;      
0525			; For every logical block write 0-1 byte as null 
0525			 
0525			storage_get_block_0: 
0525			 
0525				; TODO check presence 
0525			 
0525				; get block 0 config 
0525			 
0525 21 00 00			ld hl, 0 
0528 11 af f9			ld de, store_page 
052b cd 74 04			call storage_read_block 
052e			 
052e				if DEBUG_STORESE 
052e					DMARK "SB0" 
052e f5				push af  
052f 3a 43 05			ld a, (.dmark)  
0532 32 a0 fd			ld (debug_mark),a  
0535 3a 44 05			ld a, (.dmark+1)  
0538 32 a1 fd			ld (debug_mark+1),a  
053b 3a 45 05			ld a, (.dmark+2)  
053e 32 a2 fd			ld (debug_mark+2),a  
0541 18 03			jr .pastdmark  
0543 ..			.dmark: db "SB0"  
0546 f1			.pastdmark: pop af  
0547			endm  
# End of macro DMARK
0547 11 af f9				ld de, store_page 
054a			;		push af 
054a			;		ld a, 'i' 
054a			;		ld (debug_mark),a 
054a			;		pop af 
054a					CALLMONITOR 
054a cd aa fd			call debug_vector  
054d				endm  
# End of macro CALLMONITOR
054d				endif 
054d			 
054d				; is this area formatted? 
054d			 
054d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
054d 2a b0 f9			ld hl, (store_page+1) 
0550 3e 80			ld a,0x80 
0552 bd				cp l 
0553 20 22			jr nz, .ininotformatted 
0555				; do a double check 
0555 3e 27			ld a, 0x27 
0557 bc				cp h 
0558 20 1d			jr nz, .ininotformatted 
055a			 
055a				; formatted then 
055a			 
055a				if DEBUG_STORESE 
055a					DMARK "SB1" 
055a f5				push af  
055b 3a 6f 05			ld a, (.dmark)  
055e 32 a0 fd			ld (debug_mark),a  
0561 3a 70 05			ld a, (.dmark+1)  
0564 32 a1 fd			ld (debug_mark+1),a  
0567 3a 71 05			ld a, (.dmark+2)  
056a 32 a2 fd			ld (debug_mark+2),a  
056d 18 03			jr .pastdmark  
056f ..			.dmark: db "SB1"  
0572 f1			.pastdmark: pop af  
0573			endm  
# End of macro DMARK
0573					;push af 
0573					;ld a, 'I' 
0573					;ld (debug_mark),a 
0573					;pop af 
0573					CALLMONITOR 
0573 cd aa fd			call debug_vector  
0576				endm  
# End of macro CALLMONITOR
0576				endif 
0576 c9				ret 
0577			 
0577			.ininotformatted: 
0577				; bank not formatted so poke various bits to make sure 
0577			 
0577				if DEBUG_STORESE 
0577					DMARK "SB2" 
0577 f5				push af  
0578 3a 8c 05			ld a, (.dmark)  
057b 32 a0 fd			ld (debug_mark),a  
057e 3a 8d 05			ld a, (.dmark+1)  
0581 32 a1 fd			ld (debug_mark+1),a  
0584 3a 8e 05			ld a, (.dmark+2)  
0587 32 a2 fd			ld (debug_mark+2),a  
058a 18 03			jr .pastdmark  
058c ..			.dmark: db "SB2"  
058f f1			.pastdmark: pop af  
0590			endm  
# End of macro DMARK
0590					;push af 
0590					;ld a, 'f' 
0590					;ld (debug_mark),a 
0590					;pop af 
0590					CALLMONITOR 
0590 cd aa fd			call debug_vector  
0593				endm  
# End of macro CALLMONITOR
0593				endif 
0593			 
0593 cd b0 0c			call storage_clear_page 
0596			 
0596 21 af f9			ld hl, store_page 
0599 3e 00			ld a, 0 
059b				 
059b 77				ld (hl),a   ; reset file counter 
059c			 
059c 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
059f 22 b0 f9		 	ld (store_page+1), hl	 
05a2			 
05a2				; set default label 
05a2			 
05a2 21 3e 06			ld hl, .defaultbanklabl 
05a5 11 b2 f9		 	ld de, store_page+3 
05a8 01 0f 00			ld bc, 15 
05ab ed b0			ldir 
05ad			 
05ad				; Append the current bank id 
05ad 21 bb f9			ld hl, store_page+3+9 
05b0 3a 94 f9			ld a, (spi_device_id) 
05b3 77				ld (hl), a 
05b4			 
05b4				; save default page 0 
05b4			 
05b4 21 00 00			ld hl, 0 
05b7 11 af f9			ld de, store_page 
05ba				if DEBUG_STORESE 
05ba					DMARK "SB3" 
05ba f5				push af  
05bb 3a cf 05			ld a, (.dmark)  
05be 32 a0 fd			ld (debug_mark),a  
05c1 3a d0 05			ld a, (.dmark+1)  
05c4 32 a1 fd			ld (debug_mark+1),a  
05c7 3a d1 05			ld a, (.dmark+2)  
05ca 32 a2 fd			ld (debug_mark+2),a  
05cd 18 03			jr .pastdmark  
05cf ..			.dmark: db "SB3"  
05d2 f1			.pastdmark: pop af  
05d3			endm  
# End of macro DMARK
05d3			;		push af 
05d3			;		ld a, 'F' 
05d3			;		ld (debug_mark),a 
05d3			;		pop af 
05d3					CALLMONITOR 
05d3 cd aa fd			call debug_vector  
05d6				endm  
# End of macro CALLMONITOR
05d6				endif 
05d6 cd d9 04			call storage_write_block 
05d9				if DEBUG_STORESE 
05d9					DMARK "SB4" 
05d9 f5				push af  
05da 3a ee 05			ld a, (.dmark)  
05dd 32 a0 fd			ld (debug_mark),a  
05e0 3a ef 05			ld a, (.dmark+1)  
05e3 32 a1 fd			ld (debug_mark+1),a  
05e6 3a f0 05			ld a, (.dmark+2)  
05e9 32 a2 fd			ld (debug_mark+2),a  
05ec 18 03			jr .pastdmark  
05ee ..			.dmark: db "SB4"  
05f1 f1			.pastdmark: pop af  
05f2			endm  
# End of macro DMARK
05f2			;		push af 
05f2			;		ld a, '>' 
05f2			;		ld (debug_mark),a 
05f2			;		pop af 
05f2					CALLMONITOR 
05f2 cd aa fd			call debug_vector  
05f5				endm  
# End of macro CALLMONITOR
05f5				endif 
05f5			 
05f5 00				nop 
05f6 00				nop 
05f7 00				nop 
05f8			 
05f8				; now set 0 in every page to mark as a free block 
05f8			 
05f8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05fa 21 40 00			ld hl, STORE_BLOCK_PHY 
05fd			 
05fd 3e 00		.setmark1:   	ld a,0 
05ff e5					push hl 
0600 c5					push bc 
0601 cd 79 02				call se_writebyte 
0604 3e 0a			ld a, 10 
0606 cd d2 0c			call aDelayInMS 
0609 23				inc hl 
060a cd 79 02				call se_writebyte 
060d 3e 0a			ld a, 10 
060f cd d2 0c			call aDelayInMS 
0612 2b				dec hl 
0613 c1					pop bc 
0614 e1					pop hl 
0615 3e 40				ld a, STORE_BLOCK_PHY 
0617 cd de 0f				call addatohl 
061a 10 e1				djnz .setmark1 
061c			 
061c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
061e 3e 00		.setmark2:   	ld a,0 
0620 e5					push hl 
0621 c5					push bc 
0622 cd 79 02				call se_writebyte 
0625 3e 0a			ld a, 10 
0627 cd d2 0c			call aDelayInMS 
062a 23				inc hl 
062b cd 79 02				call se_writebyte 
062e 3e 0a			ld a, 10 
0630 cd d2 0c			call aDelayInMS 
0633 2b				dec hl 
0634 c1					pop bc 
0635 e1					pop hl 
0636 3e 40				ld a, STORE_BLOCK_PHY 
0638 cd de 0f				call addatohl 
063b 10 e1				djnz .setmark2 
063d			 
063d					 
063d			 
063d			 
063d c9				ret 
063e			 
063e			 
063e			 
063e			 
063e .. 00		.defaultbanklabl:   db "BankLabel_",0 
0649			 
0649			 
0649			 
0649			; Label Bank 
0649			; ---------- 
0649			; 
0649			; With current bank 
0649			; Read block 0 
0649			; Set label 
0649			; Write block 0 
0649			 
0649			; label str pointer in hl 
0649			 
0649			storage_label:     
0649			 
0649				if DEBUG_STORESE 
0649					DMARK "LBL" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 a0 fd			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 a1 fd			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 a2 fd			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "LBL"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662					CALLMONITOR 
0662 cd aa fd			call debug_vector  
0665				endm  
# End of macro CALLMONITOR
0665				endif 
0665			 
0665 e5				push hl 
0666			 
0666 cd 25 05			call storage_get_block_0 
0669			 
0669				; set default label 
0669			 
0669 e1				pop hl 
066a			 
066a 11 b2 f9		 	ld de, store_page+3 
066d 01 0f 00			ld bc, 15 
0670				if DEBUG_STORESE 
0670					DMARK "LB3" 
0670 f5				push af  
0671 3a 85 06			ld a, (.dmark)  
0674 32 a0 fd			ld (debug_mark),a  
0677 3a 86 06			ld a, (.dmark+1)  
067a 32 a1 fd			ld (debug_mark+1),a  
067d 3a 87 06			ld a, (.dmark+2)  
0680 32 a2 fd			ld (debug_mark+2),a  
0683 18 03			jr .pastdmark  
0685 ..			.dmark: db "LB3"  
0688 f1			.pastdmark: pop af  
0689			endm  
# End of macro DMARK
0689					CALLMONITOR 
0689 cd aa fd			call debug_vector  
068c				endm  
# End of macro CALLMONITOR
068c				endif 
068c ed b0			ldir 
068e				; save default page 0 
068e			 
068e 21 00 00			ld hl, 0 
0691 11 af f9			ld de, store_page 
0694				if DEBUG_STORESE 
0694					DMARK "LBW" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 a0 fd			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 a1 fd			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 a2 fd			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "LBW"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad					CALLMONITOR 
06ad cd aa fd			call debug_vector  
06b0				endm  
# End of macro CALLMONITOR
06b0				endif 
06b0 cd d9 04			call storage_write_block 
06b3			 
06b3 c9				ret 
06b4			 
06b4			 
06b4			 
06b4			; Read Block 0 - Config 
06b4			; --------------------- 
06b4			; 
06b4			; With current bank 
06b4			; Call presence test 
06b4			;    If not present format/init bank  
06b4			; Read block 0  
06b4			;  
06b4			 
06b4			 
06b4			; Dir 
06b4			; --- 
06b4			; 
06b4			; With current bank 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block read byte 2 
06b4			;      if first block of file 
06b4			;         Display file name 
06b4			;         Display type flags for file 
06b4			;        
06b4			 
06b4			; moving to words as this requires stack control 
06b4			 
06b4			 
06b4			; Delete File 
06b4			; ----------- 
06b4			; 
06b4			; With current bank 
06b4			; 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block file id 
06b4			;      If first block of file and dont have file id 
06b4			;         if file to delete 
06b4			;         Save file id 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			;      If file id is one saved 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			 
06b4			 
06b4			.se_done: 
06b4 e1				pop hl 
06b5 c9				ret 
06b6			 
06b6			storage_erase: 
06b6			 
06b6				; hl contains the file id 
06b6			 
06b6 5d				ld e, l 
06b7 16 00			ld d, 0 
06b9 21 40 00			ld hl, STORE_BLOCK_PHY 
06bc					if DEBUG_FORTH_WORDS 
06bc						DMARK "ERA" 
06bc f5				push af  
06bd 3a d1 06			ld a, (.dmark)  
06c0 32 a0 fd			ld (debug_mark),a  
06c3 3a d2 06			ld a, (.dmark+1)  
06c6 32 a1 fd			ld (debug_mark+1),a  
06c9 3a d3 06			ld a, (.dmark+2)  
06cc 32 a2 fd			ld (debug_mark+2),a  
06cf 18 03			jr .pastdmark  
06d1 ..			.dmark: db "ERA"  
06d4 f1			.pastdmark: pop af  
06d5			endm  
# End of macro DMARK
06d5						CALLMONITOR 
06d5 cd aa fd			call debug_vector  
06d8				endm  
# End of macro CALLMONITOR
06d8					endif 
06d8 cd a7 07			call storage_findnextid 
06db cd 07 10			call ishlzero 
06de c8				ret z 
06df			 
06df e5				push hl 
06e0			 
06e0				; TODO check file not found 
06e0			 
06e0 11 af f9			ld de, store_page 
06e3 cd 74 04			call storage_read_block 
06e6			 
06e6 cd 07 10			call ishlzero 
06e9 ca b4 06			jp z,.se_done 
06ec			 
06ec					if DEBUG_FORTH_WORDS 
06ec						DMARK "ER1" 
06ec f5				push af  
06ed 3a 01 07			ld a, (.dmark)  
06f0 32 a0 fd			ld (debug_mark),a  
06f3 3a 02 07			ld a, (.dmark+1)  
06f6 32 a1 fd			ld (debug_mark+1),a  
06f9 3a 03 07			ld a, (.dmark+2)  
06fc 32 a2 fd			ld (debug_mark+2),a  
06ff 18 03			jr .pastdmark  
0701 ..			.dmark: db "ER1"  
0704 f1			.pastdmark: pop af  
0705			endm  
# End of macro DMARK
0705						CALLMONITOR 
0705 cd aa fd			call debug_vector  
0708				endm  
# End of macro CALLMONITOR
0708					endif 
0708 3a af f9			ld a, (store_page)	; get file id 
070b 32 a3 f9			ld (store_tmpid), a 
070e			 
070e 3a b1 f9			ld a, (store_page+2)    ; get count of extends 
0711 32 a2 f9			ld (store_tmpext), a 
0714			 
0714				; wipe file header 
0714			 
0714 e1				pop hl 
0715 3e 00			ld a, 0 
0717 32 af f9			ld (store_page), a 
071a 32 b0 f9			ld (store_page+1),a 
071d 11 af f9			ld de, store_page 
0720					if DEBUG_FORTH_WORDS 
0720						DMARK "ER2" 
0720 f5				push af  
0721 3a 35 07			ld a, (.dmark)  
0724 32 a0 fd			ld (debug_mark),a  
0727 3a 36 07			ld a, (.dmark+1)  
072a 32 a1 fd			ld (debug_mark+1),a  
072d 3a 37 07			ld a, (.dmark+2)  
0730 32 a2 fd			ld (debug_mark+2),a  
0733 18 03			jr .pastdmark  
0735 ..			.dmark: db "ER2"  
0738 f1			.pastdmark: pop af  
0739			endm  
# End of macro DMARK
0739						CALLMONITOR 
0739 cd aa fd			call debug_vector  
073c				endm  
# End of macro CALLMONITOR
073c					endif 
073c cd d9 04			call storage_write_block 
073f			 
073f			 
073f				; wipe file extents 
073f			 
073f 3a a2 f9			ld a, (store_tmpext) 
0742 47				ld b, a 
0743			 
0743			.eraext:	  
0743 c5				push bc 
0744			 
0744 21 40 00			ld hl, STORE_BLOCK_PHY 
0747 3a a3 f9			ld a,(store_tmpid) 
074a 5f				ld e, a 
074b 50				ld d, b	 
074c					if DEBUG_FORTH_WORDS 
074c						DMARK "ER3" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 a0 fd			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 a1 fd			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 a2 fd			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "ER3"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765						CALLMONITOR 
0765 cd aa fd			call debug_vector  
0768				endm  
# End of macro CALLMONITOR
0768					endif 
0768 cd a7 07			call storage_findnextid 
076b cd 07 10			call ishlzero 
076e ca b4 06			jp z,.se_done 
0771			 
0771 e5				push hl 
0772 11 af f9			ld de, store_page 
0775 cd 74 04			call storage_read_block 
0778			 
0778				; free block	 
0778			 
0778 3e 00			ld a, 0 
077a 32 af f9			ld (store_page), a 
077d 32 b0 f9			ld (store_page+1),a 
0780 11 af f9			ld de, store_page 
0783 e1				pop hl 
0784					if DEBUG_FORTH_WORDS 
0784						DMARK "ER4" 
0784 f5				push af  
0785 3a 99 07			ld a, (.dmark)  
0788 32 a0 fd			ld (debug_mark),a  
078b 3a 9a 07			ld a, (.dmark+1)  
078e 32 a1 fd			ld (debug_mark+1),a  
0791 3a 9b 07			ld a, (.dmark+2)  
0794 32 a2 fd			ld (debug_mark+2),a  
0797 18 03			jr .pastdmark  
0799 ..			.dmark: db "ER4"  
079c f1			.pastdmark: pop af  
079d			endm  
# End of macro DMARK
079d						CALLMONITOR 
079d cd aa fd			call debug_vector  
07a0				endm  
# End of macro CALLMONITOR
07a0					endif 
07a0 cd d9 04			call storage_write_block 
07a3			 
07a3 c1				pop bc 
07a4 10 9d			djnz .eraext 
07a6			 
07a6 c9				ret 
07a7			 
07a7			 
07a7			; Find Free Block 
07a7			; --------------- 
07a7			; 
07a7			; With current bank 
07a7			;  
07a7			; From given starting logical block 
07a7			;    Read block  
07a7			;    If no file id 
07a7			;         Return block id 
07a7			 
07a7			 
07a7			; hl starting page number 
07a7			; hl contains free page number or zero if no pages free 
07a7			; e contains the file id to locate 
07a7			; d contains the block number 
07a7			 
07a7			; TODO change to find file id and use zero for free block 
07a7			 
07a7			storage_findnextid: 
07a7			 
07a7				; now locate first 0 page to mark as a free block 
07a7			 
07a7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a9			;	ld hl, STORE_BLOCK_PHY 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FNI" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 a0 fd			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 a1 fd			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 a2 fd			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FNI"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2						CALLMONITOR 
07c2 cd aa fd			call debug_vector  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5			.ff1:   	 
07c5 e5					push hl 
07c6 c5					push bc 
07c7 d5					push de 
07c8 cd 1b 03				call se_readbyte 
07cb 5f					ld e,a 
07cc 23					inc hl 
07cd cd 1b 03				call se_readbyte 
07d0 57					ld d, a 
07d1 e1					pop hl 
07d2 e5					push hl 
07d3 cd fc 0f				call cmp16 
07d6 28 49				jr z, .fffound 
07d8			 
07d8 d1					pop de 
07d9 c1					pop bc 
07da e1					pop hl 
07db			 
07db					; is found? 
07db					;cp e 
07db					;ret z 
07db			 
07db 3e 40				ld a, STORE_BLOCK_PHY 
07dd cd de 0f				call addatohl 
07e0 10 e3				djnz .ff1 
07e2			 
07e2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e4			.ff2:   	 
07e4			 
07e4 e5					push hl 
07e5 c5					push bc 
07e6 d5					push de 
07e7 cd 1b 03				call se_readbyte 
07ea 5f					ld e,a 
07eb 23					inc hl 
07ec cd 1b 03				call se_readbyte 
07ef 57					ld d, a 
07f0			 
07f0 e1					pop hl 
07f1 e5					push hl 
07f2 cd fc 0f				call cmp16 
07f5 28 2a				jr z, .fffound 
07f7			 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa					; is found? 
07fa					;cp e 
07fa					;ret z 
07fa			 
07fa 3e 40				ld a, STORE_BLOCK_PHY 
07fc cd de 0f				call addatohl 
07ff 10 e3				djnz .ff2 
0801			 
0801			 
0801					if DEBUG_FORTH_WORDS 
0801					DMARK "FN-" 
0801 f5				push af  
0802 3a 16 08			ld a, (.dmark)  
0805 32 a0 fd			ld (debug_mark),a  
0808 3a 17 08			ld a, (.dmark+1)  
080b 32 a1 fd			ld (debug_mark+1),a  
080e 3a 18 08			ld a, (.dmark+2)  
0811 32 a2 fd			ld (debug_mark+2),a  
0814 18 03			jr .pastdmark  
0816 ..			.dmark: db "FN-"  
0819 f1			.pastdmark: pop af  
081a			endm  
# End of macro DMARK
081a					;	push af 
081a					;	ld a, 'n' 
081a					;	ld (debug_mark),a 
081a					;	pop af 
081a						CALLMONITOR 
081a cd aa fd			call debug_vector  
081d				endm  
# End of macro CALLMONITOR
081d					endif 
081d				; no free marks! 
081d 21 00 00				ld hl, 0 
0820 c9				ret 
0821			.fffound: 
0821				 
0821			 
0821 d1					pop de 
0822 c1					pop bc 
0823 e1					pop hl 
0824					if DEBUG_FORTH_WORDS 
0824					DMARK "FNF" 
0824 f5				push af  
0825 3a 39 08			ld a, (.dmark)  
0828 32 a0 fd			ld (debug_mark),a  
082b 3a 3a 08			ld a, (.dmark+1)  
082e 32 a1 fd			ld (debug_mark+1),a  
0831 3a 3b 08			ld a, (.dmark+2)  
0834 32 a2 fd			ld (debug_mark+2),a  
0837 18 03			jr .pastdmark  
0839 ..			.dmark: db "FNF"  
083c f1			.pastdmark: pop af  
083d			endm  
# End of macro DMARK
083d					;	push af 
083d					;	ld a, 'n' 
083d					;	ld (debug_mark),a 
083d					;	pop af 
083d						CALLMONITOR 
083d cd aa fd			call debug_vector  
0840				endm  
# End of macro CALLMONITOR
0840					endif 
0840 c9				ret 
0841			 
0841			 
0841			 
0841			; Free Space 
0841			; ---------- 
0841			; 
0841			; With current bank 
0841			; 
0841			; Set block count to zero 
0841			; Starting with first logical block 
0841			;      Find free block  
0841			;      If block id given, increment block count 
0841			; 
0841			;  
0841			 
0841			 
0841			; hl contains count of free blocks 
0841			 
0841			storage_freeblocks: 
0841			 
0841				; now locate first 0 page to mark as a free block 
0841			 
0841 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0843 21 40 00			ld hl, STORE_BLOCK_PHY 
0846 11 00 00			ld de, 0 
0849			 
0849			.fb1:   	 
0849 e5					push hl 
084a c5					push bc 
084b d5					push de 
084c cd 1b 03				call se_readbyte 
084f d1					pop de 
0850 c1					pop bc 
0851 e1					pop hl 
0852			 
0852					; is free? 
0852 fe 00				cp 0 
0854 20 01				jr nz, .ff1cont 
0856 13					inc de 
0857			 
0857			.ff1cont: 
0857			 
0857			 
0857 3e 40				ld a, STORE_BLOCK_PHY 
0859 cd de 0f				call addatohl 
085c 10 eb				djnz .fb1 
085e			 
085e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0860			.fb2:   	 
0860 e5					push hl 
0861 c5					push bc 
0862 d5					push de 
0863 cd 1b 03				call se_readbyte 
0866 d1					pop de 
0867 c1					pop bc 
0868 e1					pop hl 
0869			 
0869					; is free? 
0869 fe 00				cp 0 
086b 20 01				jr nz, .ff2cont 
086d 13					inc de 
086e			 
086e			.ff2cont: 
086e			 
086e 3e 40				ld a, STORE_BLOCK_PHY 
0870 cd de 0f				call addatohl 
0873 10 eb				djnz .fb2 
0875			 
0875 eb				ex de, hl 
0876 c9				ret 
0877			 
0877			; Get File ID 
0877			; ----------- 
0877			; 
0877			; With current bank 
0877			;  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; For each logical block 
0877			;    Read block file id 
0877			;      If first block of file and dont have file id 
0877			;         if file get id and exit 
0877			 
0877			 
0877			 
0877			 
0877			; Create File 
0877			; ----------- 
0877			; 
0877			; With current bank  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; Increment file id number 
0877			; Save Config 
0877			; Find free block 
0877			; Set buffer with file name and file id 
0877			; Write buffer to free block  
0877			 
0877			 
0877			; hl point to file name 
0877			; hl returns file id 
0877			 
0877			; file format: 
0877			; byte 0 - file id 
0877			; byte 1 - extent number 
0877			; byte 2-> data 
0877			 
0877			; format for extent number 0: 
0877			; 
0877			; byte 0 - file id 
0877			; byte 1 - extent 0 
0877			; byte 2 - extent count 
0877			; byte 3 -> file name and meta data 
0877			 
0877			 
0877			storage_create: 
0877				if DEBUG_STORESE 
0877					DMARK "SCR" 
0877 f5				push af  
0878 3a 8c 08			ld a, (.dmark)  
087b 32 a0 fd			ld (debug_mark),a  
087e 3a 8d 08			ld a, (.dmark+1)  
0881 32 a1 fd			ld (debug_mark+1),a  
0884 3a 8e 08			ld a, (.dmark+2)  
0887 32 a2 fd			ld (debug_mark+2),a  
088a 18 03			jr .pastdmark  
088c ..			.dmark: db "SCR"  
088f f1			.pastdmark: pop af  
0890			endm  
# End of macro DMARK
0890					CALLMONITOR 
0890 cd aa fd			call debug_vector  
0893				endm  
# End of macro CALLMONITOR
0893				endif 
0893			 
0893 e5				push hl		; save file name pointer 
0894			 
0894 cd 25 05			call storage_get_block_0 
0897			 
0897 3a af f9			ld a,(store_page)	; get current file id 
089a 3c				inc a 
089b 32 af f9			ld (store_page),a 
089e				 
089e 32 a3 f9			ld (store_tmpid),a			; save id 
08a1			 
08a1 21 00 00			ld hl, 0 
08a4 11 af f9			ld de, store_page 
08a7				if DEBUG_STORESE 
08a7					DMARK "SCw" 
08a7 f5				push af  
08a8 3a bc 08			ld a, (.dmark)  
08ab 32 a0 fd			ld (debug_mark),a  
08ae 3a bd 08			ld a, (.dmark+1)  
08b1 32 a1 fd			ld (debug_mark+1),a  
08b4 3a be 08			ld a, (.dmark+2)  
08b7 32 a2 fd			ld (debug_mark+2),a  
08ba 18 03			jr .pastdmark  
08bc ..			.dmark: db "SCw"  
08bf f1			.pastdmark: pop af  
08c0			endm  
# End of macro DMARK
08c0					CALLMONITOR 
08c0 cd aa fd			call debug_vector  
08c3				endm  
# End of macro CALLMONITOR
08c3				endif 
08c3 cd d9 04			call storage_write_block	 ; save update 
08c6			 
08c6				if DEBUG_STORESE 
08c6 11 af f9				ld de, store_page 
08c9					DMARK "SCC" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 a0 fd			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 a1 fd			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 a2 fd			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCC"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd aa fd			call debug_vector  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5				;  
08e5				 
08e5 21 40 00			ld hl, STORE_BLOCK_PHY 
08e8 11 00 00			ld de, 0 
08eb cd a7 07			call storage_findnextid 
08ee			 
08ee 22 9a f9			ld (store_tmppageid), hl    ; save page to use  
08f1			 
08f1				; TODO detect 0 = no spare blocks 
08f1			 
08f1				; hl now contains the free page to use for the file header page 
08f1			 
08f1				if DEBUG_STORESE 
08f1				DMARK "SCF" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 a0 fd			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 a1 fd			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 a2 fd			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCF"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					CALLMONITOR 
090a cd aa fd			call debug_vector  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d			 
090d 22 9a f9			ld (store_tmppageid), hl 
0910				 
0910 3a a3 f9			ld a,(store_tmpid)    ; get file id 
0913			;	ld a, (store_filecache)			; save to cache 
0913			 
0913 32 af f9			ld (store_page),a    ; set page id 
0916 3e 00			ld a, 0			 ; extent 0 is file header 
0918 32 b0 f9			ld (store_page+1), a   ; set file extent 
091b			 
091b 32 b1 f9			ld (store_page+2), a   ; extent count for the file 
091e			 
091e			;	inc hl 		; init block 0 of file 
091e			;	inc hl   		; skip file and extent id 
091e			 ;       ld a, 0 
091e			;	ld (hl),a 
091e			;	ld a, (store_filecache+1)  	; save to cache 
091e			 
091e			;	inc hl    ; file name 
091e				 
091e				 
091e 11 b2 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0921				if DEBUG_STORESE 
0921					DMARK "SCc" 
0921 f5				push af  
0922 3a 36 09			ld a, (.dmark)  
0925 32 a0 fd			ld (debug_mark),a  
0928 3a 37 09			ld a, (.dmark+1)  
092b 32 a1 fd			ld (debug_mark+1),a  
092e 3a 38 09			ld a, (.dmark+2)  
0931 32 a2 fd			ld (debug_mark+2),a  
0934 18 03			jr .pastdmark  
0936 ..			.dmark: db "SCc"  
0939 f1			.pastdmark: pop af  
093a			endm  
# End of macro DMARK
093a					CALLMONITOR 
093a cd aa fd			call debug_vector  
093d				endm  
# End of macro CALLMONITOR
093d				endif 
093d e1				pop hl    ; get zero term string 
093e e5				push hl 
093f 3e 00			ld a, 0 
0941 cd 4f 13			call strlent 
0944 23				inc hl   ; cover zero term 
0945 06 00			ld b,0 
0947 4d				ld c,l 
0948 e1				pop hl 
0949				;ex de, hl 
0949				if DEBUG_STORESE 
0949					DMARK "SCa" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 a0 fd			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 a1 fd			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 a2 fd			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SCa"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					;push af 
0962					;ld a, 'a' 
0962					;ld (debug_mark),a 
0962					;pop af 
0962					CALLMONITOR 
0962 cd aa fd			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 ed b0			ldir    ; copy zero term string 
0967				if DEBUG_STORESE 
0967					DMARK "SCA" 
0967 f5				push af  
0968 3a 7c 09			ld a, (.dmark)  
096b 32 a0 fd			ld (debug_mark),a  
096e 3a 7d 09			ld a, (.dmark+1)  
0971 32 a1 fd			ld (debug_mark+1),a  
0974 3a 7e 09			ld a, (.dmark+2)  
0977 32 a2 fd			ld (debug_mark+2),a  
097a 18 03			jr .pastdmark  
097c ..			.dmark: db "SCA"  
097f f1			.pastdmark: pop af  
0980			endm  
# End of macro DMARK
0980					CALLMONITOR 
0980 cd aa fd			call debug_vector  
0983				endm  
# End of macro CALLMONITOR
0983				endif 
0983			 
0983				; write file header page 
0983			 
0983 2a 9a f9			ld hl,(store_tmppageid) 
0986 11 af f9			ld de, store_page 
0989				if DEBUG_STORESE 
0989					DMARK "SCb" 
0989 f5				push af  
098a 3a 9e 09			ld a, (.dmark)  
098d 32 a0 fd			ld (debug_mark),a  
0990 3a 9f 09			ld a, (.dmark+1)  
0993 32 a1 fd			ld (debug_mark+1),a  
0996 3a a0 09			ld a, (.dmark+2)  
0999 32 a2 fd			ld (debug_mark+2),a  
099c 18 03			jr .pastdmark  
099e ..			.dmark: db "SCb"  
09a1 f1			.pastdmark: pop af  
09a2			endm  
# End of macro DMARK
09a2					;push af 
09a2					;ld a, 'b' 
09a2					;ld (debug_mark),a 
09a2					;pop af 
09a2					CALLMONITOR 
09a2 cd aa fd			call debug_vector  
09a5				endm  
# End of macro CALLMONITOR
09a5				endif 
09a5 cd d9 04			call storage_write_block 
09a8			 
09a8 3a a3 f9			ld a, (store_tmpid) 
09ab 6f				ld l, a 
09ac 26 00			ld h,0 
09ae				if DEBUG_STORESE 
09ae					DMARK "SCz" 
09ae f5				push af  
09af 3a c3 09			ld a, (.dmark)  
09b2 32 a0 fd			ld (debug_mark),a  
09b5 3a c4 09			ld a, (.dmark+1)  
09b8 32 a1 fd			ld (debug_mark+1),a  
09bb 3a c5 09			ld a, (.dmark+2)  
09be 32 a2 fd			ld (debug_mark+2),a  
09c1 18 03			jr .pastdmark  
09c3 ..			.dmark: db "SCz"  
09c6 f1			.pastdmark: pop af  
09c7			endm  
# End of macro DMARK
09c7					CALLMONITOR 
09c7 cd aa fd			call debug_vector  
09ca				endm  
# End of macro CALLMONITOR
09ca				endif 
09ca c9				ret 
09cb				 
09cb			 
09cb			 
09cb			; 
09cb			; Read File 
09cb			; 
09cb			; h - file id to locate 
09cb			; l - extent to locate 
09cb			; de - pointer to string to read into 
09cb			; 
09cb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09cb			 
09cb			.sr_fail: 
09cb d1				pop de 
09cc c9				ret 
09cd			 
09cd			storage_read: 
09cd			 
09cd			 
09cd d5				push de 
09ce			 
09ce			; TODO BUG the above push is it popped before the RET Z? 
09ce			 
09ce			; TODO how to handle multiple part blocks 
09ce			 
09ce				; locate file extent to read 
09ce			 
09ce 5c				ld e, h 
09cf 55				ld d, l 
09d0			 
09d0			.srext: 
09d0 22 ad f9			ld (store_readptr), hl     ; save the current extent to load 
09d3 ed 53 ab f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09d7			 
09d7 21 40 00			ld hl, STORE_BLOCK_PHY 
09da				if DEBUG_STORESE 
09da					DMARK "sre" 
09da f5				push af  
09db 3a ef 09			ld a, (.dmark)  
09de 32 a0 fd			ld (debug_mark),a  
09e1 3a f0 09			ld a, (.dmark+1)  
09e4 32 a1 fd			ld (debug_mark+1),a  
09e7 3a f1 09			ld a, (.dmark+2)  
09ea 32 a2 fd			ld (debug_mark+2),a  
09ed 18 03			jr .pastdmark  
09ef ..			.dmark: db "sre"  
09f2 f1			.pastdmark: pop af  
09f3			endm  
# End of macro DMARK
09f3					CALLMONITOR 
09f3 cd aa fd			call debug_vector  
09f6				endm  
# End of macro CALLMONITOR
09f6				endif 
09f6 cd a7 07			call storage_findnextid 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "srf" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 a0 fd			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 a1 fd			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 a2 fd			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "srf"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd aa fd			call debug_vector  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15 cd 07 10			call ishlzero 
0a18			;	ld a, l 
0a18			;	add h 
0a18			;	cp 0 
0a18 28 b1			jr z,.sr_fail			; block not found so EOF 
0a1a			 
0a1a				; save current address for use by higher level words etc 
0a1a			 
0a1a 22 a0 f9			ld (store_openaddr),hl 
0a1d			 
0a1d			 
0a1d				; hl contains page number to load 
0a1d d1				pop de   ; get storage 
0a1e ed 53 ab f9		ld (store_readbuf), de     ; current buffer to load in to 
0a22 d5				push de 
0a23				if DEBUG_STORESE 
0a23					DMARK "srg" 
0a23 f5				push af  
0a24 3a 38 0a			ld a, (.dmark)  
0a27 32 a0 fd			ld (debug_mark),a  
0a2a 3a 39 0a			ld a, (.dmark+1)  
0a2d 32 a1 fd			ld (debug_mark+1),a  
0a30 3a 3a 0a			ld a, (.dmark+2)  
0a33 32 a2 fd			ld (debug_mark+2),a  
0a36 18 03			jr .pastdmark  
0a38 ..			.dmark: db "srg"  
0a3b f1			.pastdmark: pop af  
0a3c			endm  
# End of macro DMARK
0a3c					CALLMONITOR 
0a3c cd aa fd			call debug_vector  
0a3f				endm  
# End of macro CALLMONITOR
0a3f				endif 
0a3f cd 74 04			call storage_read_block 
0a42			 
0a42				; if this a continuation read??? 
0a42			 
0a42 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a45			 
0a45 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a47 cd de 0f			call addatohl 
0a4a 7e				ld a,(hl) 
0a4b fe 00			cp 0 
0a4d 28 02			jr z, .markiscont 
0a4f 3e ff			ld a, 255 
0a51			 
0a51			.markiscont: 
0a51 32 a2 f9			ld (store_readcont), a 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "srC" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 a0 fd			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 a1 fd			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 a2 fd			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "srC"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd aa fd			call debug_vector  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70				; only short reads enabled 
0a70			 
0a70 3a aa f9			ld a, (store_longread) 
0a73 fe 00			cp 0 
0a75 ca 42 0b			jp z, .readdone 
0a78			 
0a78			; TODO if block has no zeros then need to read next block  
0a78			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a78			; check last byte of physical block. 
0a78			; if not zero then the next block needs to be loaded 
0a78			 
0a78			 
0a78 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a7b			 
0a7b 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a7d cd de 0f			call addatohl 
0a80				;dec hl 
0a80 7e				ld a,(hl) 
0a81				if DEBUG_STORESE 
0a81					DMARK "sr?" 
0a81 f5				push af  
0a82 3a 96 0a			ld a, (.dmark)  
0a85 32 a0 fd			ld (debug_mark),a  
0a88 3a 97 0a			ld a, (.dmark+1)  
0a8b 32 a1 fd			ld (debug_mark+1),a  
0a8e 3a 98 0a			ld a, (.dmark+2)  
0a91 32 a2 fd			ld (debug_mark+2),a  
0a94 18 03			jr .pastdmark  
0a96 ..			.dmark: db "sr?"  
0a99 f1			.pastdmark: pop af  
0a9a			endm  
# End of macro DMARK
0a9a					CALLMONITOR 
0a9a cd aa fd			call debug_vector  
0a9d				endm  
# End of macro CALLMONITOR
0a9d				endif 
0a9d fe 00			cp 0 
0a9f ca 42 0b			jp z, .readdone 
0aa2			 
0aa2				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0aa2			 
0aa2 23				inc hl 
0aa3			 
0aa3 22 ab f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0aa6			 
0aa6 ed 5b ad f9		ld de, (store_readptr)     ; save the current extent to load 
0aaa			 
0aaa eb				ex de, hl 
0aab			 
0aab				; next ext 
0aab			 
0aab 23				inc hl 
0aac 22 ad f9			ld  (store_readptr), hl     ; save the current extent to load 
0aaf			 
0aaf				if DEBUG_STORESE 
0aaf					DMARK "sF2" 
0aaf f5				push af  
0ab0 3a c4 0a			ld a, (.dmark)  
0ab3 32 a0 fd			ld (debug_mark),a  
0ab6 3a c5 0a			ld a, (.dmark+1)  
0ab9 32 a1 fd			ld (debug_mark+1),a  
0abc 3a c6 0a			ld a, (.dmark+2)  
0abf 32 a2 fd			ld (debug_mark+2),a  
0ac2 18 03			jr .pastdmark  
0ac4 ..			.dmark: db "sF2"  
0ac7 f1			.pastdmark: pop af  
0ac8			endm  
# End of macro DMARK
0ac8					CALLMONITOR 
0ac8 cd aa fd			call debug_vector  
0acb				endm  
# End of macro CALLMONITOR
0acb				endif 
0acb			 
0acb				; get and load block 
0acb			 
0acb cd a7 07			call storage_findnextid 
0ace			 
0ace				if DEBUG_STORESE 
0ace					DMARK "sf2" 
0ace f5				push af  
0acf 3a e3 0a			ld a, (.dmark)  
0ad2 32 a0 fd			ld (debug_mark),a  
0ad5 3a e4 0a			ld a, (.dmark+1)  
0ad8 32 a1 fd			ld (debug_mark+1),a  
0adb 3a e5 0a			ld a, (.dmark+2)  
0ade 32 a2 fd			ld (debug_mark+2),a  
0ae1 18 03			jr .pastdmark  
0ae3 ..			.dmark: db "sf2"  
0ae6 f1			.pastdmark: pop af  
0ae7			endm  
# End of macro DMARK
0ae7					CALLMONITOR 
0ae7 cd aa fd			call debug_vector  
0aea				endm  
# End of macro CALLMONITOR
0aea				endif 
0aea cd 07 10			call ishlzero 
0aed			;	ld a, l 
0aed			;	add h 
0aed			;	cp 0 
0aed ca cb 09			jp z,.sr_fail			; block not found so EOF 
0af0				 
0af0				; save current address for use by higher level words etc 
0af0			 
0af0 22 a0 f9			ld (store_openaddr),hl 
0af3			 
0af3 cd 74 04			call storage_read_block 
0af6			 
0af6				; on a continuation block, we now have the file id and ext in the middle of the block 
0af6				; we need to pull everything back  
0af6			 
0af6 ed 5b ab f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0afa 2a ab f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0afd 23				inc hl 
0afe 23				inc hl     ; skip id and ext 
0aff 01 40 00			ld bc, STORE_BLOCK_PHY 
0b02				if DEBUG_STORESE 
0b02					DMARK "SR<" 
0b02 f5				push af  
0b03 3a 17 0b			ld a, (.dmark)  
0b06 32 a0 fd			ld (debug_mark),a  
0b09 3a 18 0b			ld a, (.dmark+1)  
0b0c 32 a1 fd			ld (debug_mark+1),a  
0b0f 3a 19 0b			ld a, (.dmark+2)  
0b12 32 a2 fd			ld (debug_mark+2),a  
0b15 18 03			jr .pastdmark  
0b17 ..			.dmark: db "SR<"  
0b1a f1			.pastdmark: pop af  
0b1b			endm  
# End of macro DMARK
0b1b					CALLMONITOR 
0b1b cd aa fd			call debug_vector  
0b1e				endm  
# End of macro CALLMONITOR
0b1e				endif 
0b1e ed b0			ldir     ; copy data 
0b20			 
0b20				; move the pointer back and pretend we have a full buffer for next recheck 
0b20			 
0b20 1b				dec de 
0b21 1b				dec de 
0b22			 
0b22			; TODO do pop below now short circuit loop????? 
0b22 c1				pop bc     ; get rid of spare de on stack 
0b23				if DEBUG_STORESE 
0b23					DMARK "SR>" 
0b23 f5				push af  
0b24 3a 38 0b			ld a, (.dmark)  
0b27 32 a0 fd			ld (debug_mark),a  
0b2a 3a 39 0b			ld a, (.dmark+1)  
0b2d 32 a1 fd			ld (debug_mark+1),a  
0b30 3a 3a 0b			ld a, (.dmark+2)  
0b33 32 a2 fd			ld (debug_mark+2),a  
0b36 18 03			jr .pastdmark  
0b38 ..			.dmark: db "SR>"  
0b3b f1			.pastdmark: pop af  
0b3c			endm  
# End of macro DMARK
0b3c					CALLMONITOR 
0b3c cd aa fd			call debug_vector  
0b3f				endm  
# End of macro CALLMONITOR
0b3f				endif 
0b3f c3 d0 09			jp .srext 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			.readdone:		 
0b42 e1				pop hl 		 ; return start of data to show as not EOF 
0b43 23				inc hl   ; past file id 
0b44 23				inc hl   ; past ext 
0b45				if DEBUG_STORESE 
0b45					DMARK "SRe" 
0b45 f5				push af  
0b46 3a 5a 0b			ld a, (.dmark)  
0b49 32 a0 fd			ld (debug_mark),a  
0b4c 3a 5b 0b			ld a, (.dmark+1)  
0b4f 32 a1 fd			ld (debug_mark+1),a  
0b52 3a 5c 0b			ld a, (.dmark+2)  
0b55 32 a2 fd			ld (debug_mark+2),a  
0b58 18 03			jr .pastdmark  
0b5a ..			.dmark: db "SRe"  
0b5d f1			.pastdmark: pop af  
0b5e			endm  
# End of macro DMARK
0b5e					CALLMONITOR 
0b5e cd aa fd			call debug_vector  
0b61				endm  
# End of macro CALLMONITOR
0b61				endif 
0b61 c9					ret 
0b62			 
0b62			 
0b62			 
0b62			; 
0b62			; Append File 
0b62			; 
0b62			; hl - file id to locate 
0b62			; de - pointer to (multi block) string to write 
0b62			 
0b62			.sa_notfound: 
0b62 d1				pop de 
0b63 c9				ret 
0b64			 
0b64			 
0b64			storage_append: 
0b64				; hl -  file id to append to 
0b64				; de - string to append 
0b64			 
0b64 d5				push de 
0b65				 
0b65				if DEBUG_STORESE 
0b65					DMARK "AP1" 
0b65 f5				push af  
0b66 3a 7a 0b			ld a, (.dmark)  
0b69 32 a0 fd			ld (debug_mark),a  
0b6c 3a 7b 0b			ld a, (.dmark+1)  
0b6f 32 a1 fd			ld (debug_mark+1),a  
0b72 3a 7c 0b			ld a, (.dmark+2)  
0b75 32 a2 fd			ld (debug_mark+2),a  
0b78 18 03			jr .pastdmark  
0b7a ..			.dmark: db "AP1"  
0b7d f1			.pastdmark: pop af  
0b7e			endm  
# End of macro DMARK
0b7e					CALLMONITOR 
0b7e cd aa fd			call debug_vector  
0b81				endm  
# End of macro CALLMONITOR
0b81				endif 
0b81			 
0b81 7d				ld a, l 
0b82 32 a3 f9			ld (store_tmpid), a 
0b85			 
0b85				; get file header  
0b85			 
0b85 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b87 3a a3 f9			ld a, (store_tmpid) 
0b8a 5f				ld e, a 
0b8b			 
0b8b 21 40 00				ld hl, STORE_BLOCK_PHY 
0b8e cd a7 07				call storage_findnextid 
0b91			 
0b91 cd 07 10			call ishlzero 
0b94 28 cc			jr z, .sa_notfound 
0b96			 
0b96 22 9a f9			ld (store_tmppageid), hl 
0b99			 
0b99				; TODO handle file id not found 
0b99			 
0b99				if DEBUG_STORESE 
0b99					DMARK "AP2" 
0b99 f5				push af  
0b9a 3a ae 0b			ld a, (.dmark)  
0b9d 32 a0 fd			ld (debug_mark),a  
0ba0 3a af 0b			ld a, (.dmark+1)  
0ba3 32 a1 fd			ld (debug_mark+1),a  
0ba6 3a b0 0b			ld a, (.dmark+2)  
0ba9 32 a2 fd			ld (debug_mark+2),a  
0bac 18 03			jr .pastdmark  
0bae ..			.dmark: db "AP2"  
0bb1 f1			.pastdmark: pop af  
0bb2			endm  
# End of macro DMARK
0bb2					CALLMONITOR 
0bb2 cd aa fd			call debug_vector  
0bb5				endm  
# End of macro CALLMONITOR
0bb5				endif 
0bb5			 
0bb5				; update file extent count 
0bb5			 
0bb5 11 af f9			ld de, store_page 
0bb8			 
0bb8 cd 74 04			call storage_read_block 
0bbb			 
0bbb				if DEBUG_STORESE 
0bbb					DMARK "AP3" 
0bbb f5				push af  
0bbc 3a d0 0b			ld a, (.dmark)  
0bbf 32 a0 fd			ld (debug_mark),a  
0bc2 3a d1 0b			ld a, (.dmark+1)  
0bc5 32 a1 fd			ld (debug_mark+1),a  
0bc8 3a d2 0b			ld a, (.dmark+2)  
0bcb 32 a2 fd			ld (debug_mark+2),a  
0bce 18 03			jr .pastdmark  
0bd0 ..			.dmark: db "AP3"  
0bd3 f1			.pastdmark: pop af  
0bd4			endm  
# End of macro DMARK
0bd4					CALLMONITOR 
0bd4 cd aa fd			call debug_vector  
0bd7				endm  
# End of macro CALLMONITOR
0bd7				endif 
0bd7			;	ld (store_tmppageid), hl 
0bd7			 
0bd7 3a b1 f9			ld a, (store_page+2) 
0bda 3c				inc a 
0bdb 32 b1 f9			ld (store_page+2), a 
0bde 32 a2 f9			ld (store_tmpext), a 
0be1				 
0be1				if DEBUG_STORESE 
0be1					DMARK "AP3" 
0be1 f5				push af  
0be2 3a f6 0b			ld a, (.dmark)  
0be5 32 a0 fd			ld (debug_mark),a  
0be8 3a f7 0b			ld a, (.dmark+1)  
0beb 32 a1 fd			ld (debug_mark+1),a  
0bee 3a f8 0b			ld a, (.dmark+2)  
0bf1 32 a2 fd			ld (debug_mark+2),a  
0bf4 18 03			jr .pastdmark  
0bf6 ..			.dmark: db "AP3"  
0bf9 f1			.pastdmark: pop af  
0bfa			endm  
# End of macro DMARK
0bfa					CALLMONITOR 
0bfa cd aa fd			call debug_vector  
0bfd				endm  
# End of macro CALLMONITOR
0bfd				endif 
0bfd 2a 9a f9			ld hl, (store_tmppageid) 
0c00 11 af f9			ld de, store_page 
0c03 cd d9 04			call storage_write_block 
0c06			 
0c06				; find free block 
0c06			 
0c06 11 00 00			ld de, 0			 ; file extent to locate 
0c09			 
0c09 21 40 00				ld hl, STORE_BLOCK_PHY 
0c0c cd a7 07				call storage_findnextid 
0c0f cd 07 10			call ishlzero 
0c12 ca 62 0b			jp z, .sa_notfound 
0c15			 
0c15					; TODO handle no space left 
0c15					 
0c15 22 9a f9				ld (store_tmppageid), hl 
0c18			 
0c18				if DEBUG_STORESE 
0c18					DMARK "AP4" 
0c18 f5				push af  
0c19 3a 2d 0c			ld a, (.dmark)  
0c1c 32 a0 fd			ld (debug_mark),a  
0c1f 3a 2e 0c			ld a, (.dmark+1)  
0c22 32 a1 fd			ld (debug_mark+1),a  
0c25 3a 2f 0c			ld a, (.dmark+2)  
0c28 32 a2 fd			ld (debug_mark+2),a  
0c2b 18 03			jr .pastdmark  
0c2d ..			.dmark: db "AP4"  
0c30 f1			.pastdmark: pop af  
0c31			endm  
# End of macro DMARK
0c31					CALLMONITOR 
0c31 cd aa fd			call debug_vector  
0c34				endm  
# End of macro CALLMONITOR
0c34				endif 
0c34					; init the buffer with zeros so we can id if the buffer is full or not 
0c34			 
0c34 e5					push hl 
0c35 c5					push bc 
0c36			 
0c36 21 af f9				ld hl, store_page 
0c39 06 40				ld b, STORE_BLOCK_PHY 
0c3b 3e 00				ld a, 0 
0c3d 77			.zeroblock:	ld (hl), a 
0c3e 23					inc hl 
0c3f 10 fc				djnz .zeroblock 
0c41			 
0c41 c1					pop bc 
0c42 e1					pop hl 
0c43			 
0c43					; construct block 
0c43			 
0c43 3a a3 f9				ld a, (store_tmpid) 
0c46 32 af f9				ld (store_page), a   ; file id 
0c49 3a a2 f9				ld a, (store_tmpext)   ; extent for this block 
0c4c 32 b0 f9				ld (store_page+1), a 
0c4f			 
0c4f e1					pop hl    ; get string to write 
0c50 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c52 11 b1 f9				ld de, store_page+2 
0c55			 
0c55				if DEBUG_STORESE 
0c55					DMARK "AP5" 
0c55 f5				push af  
0c56 3a 6a 0c			ld a, (.dmark)  
0c59 32 a0 fd			ld (debug_mark),a  
0c5c 3a 6b 0c			ld a, (.dmark+1)  
0c5f 32 a1 fd			ld (debug_mark+1),a  
0c62 3a 6c 0c			ld a, (.dmark+2)  
0c65 32 a2 fd			ld (debug_mark+2),a  
0c68 18 03			jr .pastdmark  
0c6a ..			.dmark: db "AP5"  
0c6d f1			.pastdmark: pop af  
0c6e			endm  
# End of macro DMARK
0c6e					CALLMONITOR 
0c6e cd aa fd			call debug_vector  
0c71				endm  
# End of macro CALLMONITOR
0c71				endif 
0c71			 
0c71			 
0c71			 
0c71					; fill buffer with data until end of string or full block 
0c71			 
0c71 7e			.appd:		ld a, (hl) 
0c72 12					ld (de), a 
0c73 fe 00				cp 0 
0c75 28 04				jr z, .appdone 
0c77 23					inc hl 
0c78 13					inc de 
0c79 10 f6				djnz .appd 
0c7b			 
0c7b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c7c f5					push af   		; save last byte dumped 
0c7d			 
0c7d			 
0c7d 2a 9a f9			ld hl, (store_tmppageid) 
0c80 11 af f9			ld de, store_page 
0c83				if DEBUG_STORESE 
0c83					DMARK "AP6" 
0c83 f5				push af  
0c84 3a 98 0c			ld a, (.dmark)  
0c87 32 a0 fd			ld (debug_mark),a  
0c8a 3a 99 0c			ld a, (.dmark+1)  
0c8d 32 a1 fd			ld (debug_mark+1),a  
0c90 3a 9a 0c			ld a, (.dmark+2)  
0c93 32 a2 fd			ld (debug_mark+2),a  
0c96 18 03			jr .pastdmark  
0c98 ..			.dmark: db "AP6"  
0c9b f1			.pastdmark: pop af  
0c9c			endm  
# End of macro DMARK
0c9c					CALLMONITOR 
0c9c cd aa fd			call debug_vector  
0c9f				endm  
# End of macro CALLMONITOR
0c9f				endif 
0c9f cd d9 04				call storage_write_block 
0ca2			 
0ca2			 
0ca2				; was that a full block of data written? 
0ca2				; any more to write out? 
0ca2			 
0ca2				; if yes then set vars and jump to start of function again 
0ca2			 
0ca2 f1					pop af 
0ca3 d1					pop de 
0ca4			 
0ca4 fe 00				cp 0		 ; no, string was fully written 
0ca6 c8					ret z 
0ca7			 
0ca7					; setup vars for next cycle 
0ca7			 
0ca7 3a a3 f9				ld a, (store_tmpid) 
0caa 6f					ld l, a 
0cab 26 00				ld h, 0 
0cad			 
0cad c3 64 0b			 	jp storage_append	 ; yes, need to write out some more 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			if DEBUG_STORECF 
0cb0			storageput:	 
0cb0					ret 
0cb0			storageread: 
0cb0					ld hl, store_page 
0cb0					ld b, 200 
0cb0					ld a,0 
0cb0			.src:		ld (hl),a 
0cb0					inc hl 
0cb0					djnz .src 
0cb0					 
0cb0			 
0cb0					ld de, 0 
0cb0					ld bc, 1 
0cb0					ld hl, store_page 
0cb0					call cfRead 
0cb0			 
0cb0				call cfGetError 
0cb0				ld hl,scratch 
0cb0				call hexout 
0cb0				ld hl, scratch+2 
0cb0				ld a, 0 
0cb0				ld (hl),a 
0cb0				ld de, scratch 
0cb0				ld a,display_row_1 
0cb0				call str_at_display 
0cb0				call update_display 
0cb0			 
0cb0					ld hl, store_page 
0cb0					ld (os_cur_ptr),hl 
0cb0			 
0cb0					ret 
0cb0			endif 
0cb0			 
0cb0			 
0cb0			; Clear out the main buffer store (used to remove junk before writing a new block) 
0cb0			 
0cb0			storage_clear_page: 
0cb0 e5				push hl 
0cb1 d5				push de 
0cb2 c5				push bc 
0cb3 21 af f9			ld hl, store_page 
0cb6 3e 00			ld a, 0 
0cb8 77				ld (hl), a 
0cb9			 
0cb9 11 b0 f9			ld de, store_page+1 
0cbc 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cbf			 
0cbf ed b0			ldir 
0cc1				 
0cc1 c1				pop bc 
0cc2 d1				pop de 
0cc3 e1				pop hl 
0cc4 c9				ret 
0cc5			 
0cc5			; eof 
# End of file firmware_storage.asm
0cc5			  
0cc5			; support routines for above hardware abstraction layer  
0cc5			  
0cc5			include "firmware_general.asm"        ; general support functions  
0cc5			 
0cc5			; word look up 
0cc5			 
0cc5			; in 
0cc5			; a is the index 
0cc5			; hl is pointer start of array 
0cc5			; 
0cc5			; returns 
0cc5			; hl to the word 
0cc5			; 
0cc5			 
0cc5			table_lookup:  
0cc5 d5					push de 
0cc6 eb					ex de, hl 
0cc7			 
0cc7 6f					ld l, a 
0cc8 26 00				ld h, 0 
0cca 29					add hl, hl 
0ccb 19					add hl, de 
0ccc 7e					ld a, (hl) 
0ccd 23					inc hl 
0cce 66					ld h,(hl) 
0ccf 6f					ld l, a 
0cd0			 
0cd0 d1					pop de 
0cd1 c9					ret 
0cd2			 
0cd2			; Delay loops 
0cd2			 
0cd2			 
0cd2			 
0cd2			aDelayInMS: 
0cd2 c5				push bc 
0cd3 47				ld b,a 
0cd4			msdelay: 
0cd4 c5				push bc 
0cd5				 
0cd5			 
0cd5 01 41 00			ld bc,041h 
0cd8 cd f0 0c			call delayloop 
0cdb c1				pop bc 
0cdc 05				dec b 
0cdd 20 f5			jr nz,msdelay 
0cdf			 
0cdf			;if CPU_CLOCK_8MHZ 
0cdf			;msdelay8: 
0cdf			;	push bc 
0cdf			;	 
0cdf			; 
0cdf			;	ld bc,041h 
0cdf			;	call delayloop 
0cdf			;	pop bc 
0cdf			;	dec b 
0cdf			;	jr nz,msdelay8 
0cdf			;endif 
0cdf			 
0cdf			 
0cdf c1				pop bc 
0ce0 c9				ret 
0ce1			 
0ce1			 
0ce1			delay250ms: 
0ce1				;push de 
0ce1 01 00 40			ld bc, 04000h 
0ce4 c3 f0 0c			jp delayloop 
0ce7			delay500ms: 
0ce7				;push de 
0ce7 01 00 80			ld bc, 08000h 
0cea c3 f0 0c			jp delayloop 
0ced			delay1s: 
0ced				;push bc 
0ced			   ; Clobbers A, d and e 
0ced 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0cf0			delayloop: 
0cf0 c5			    push bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				ld bc, CPM_DELAY_TUNE 
0cf1			.cpmloop: 
0cf1				push bc 
0cf1			 
0cf1			endif 
0cf1			 
0cf1			 
0cf1			 
0cf1			delayloopi: 
0cf1			;	push bc 
0cf1			;.dl: 
0cf1 cb 47		    bit     0,a    	; 8 
0cf3 cb 47		    bit     0,a    	; 8 
0cf5 cb 47		    bit     0,a    	; 8 
0cf7 e6 ff		    and     255  	; 7 
0cf9 0b			    dec     bc      	; 6 
0cfa 79			    ld      a,c     	; 4 
0cfb b0			    or      b     	; 4 
0cfc c2 f1 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cff			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cff				;pop de 
0cff			;pop bc 
0cff			 
0cff			if BASE_CPM 
0cff				pop bc 
0cff				 
0cff			    dec     bc      	; 6 
0cff			    ld      a,c     	; 4 
0cff			    or      b     	; 4 
0cff			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cff				 
0cff			 
0cff			endif 
0cff			;if CPU_CLOCK_8MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff			 
0cff			;if CPU_CLOCK_10MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff c1			    pop bc 
0d00			 
0d00 c9				ret 
0d01			 
0d01			 
0d01			 
0d01			; eof 
# End of file firmware_general.asm
0d01			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0d01			; display routines that use the physical hardware abstraction layer 
0d01			 
0d01			 
0d01			; Display an activity indicator 
0d01			; Each call returns the new char pointed to in hl 
0d01			 
0d01			active: 
0d01 3a fb fa			ld a, (display_active) 
0d04 fe 06			cp 6 
0d06			 
0d06 20 02			jr nz, .sne 
0d08				; gone past the last one reset sequence 
0d08 3e ff			ld a, 255 
0d0a			 
0d0a			.sne:   
0d0a				; get the next char in seq 
0d0a 3c				inc a 
0d0b 32 fb fa			ld (display_active), a 
0d0e			 
0d0e				; look up the string in the table 
0d0e 21 25 0d			ld hl, actseq 
0d11 cb 27			sla a 
0d13 cd de 0f			call addatohl 
0d16 cd b9 23			call loadwordinhl 
0d19			 
0d19				; forth will write the to string when pushing so move from rom to ram 
0d19			 
0d19 11 fc fa			ld de, display_active+1 
0d1c 01 02 00			ld bc, 2 
0d1f ed b0			ldir 
0d21			 
0d21 21 fc fa			ld hl, display_active+1 
0d24 c9				ret 
0d25				 
0d25				 
0d25			 
0d25			 
0d25			;db "|/-\|-\" 
0d25			 
0d25			actseq: 
0d25			 
0d25 33 0d		dw spin0 
0d27 35 0d		dw spin1 
0d29 37 0d		dw spin2 
0d2b 39 0d		dw spin3 
0d2d 37 0d		dw spin2 
0d2f 35 0d		dw spin1 
0d31 33 0d		dw spin0 
0d33			 
0d33 .. 00		spin0: db " ", 0 
0d35 .. 00		spin1: db "-", 0 
0d37 .. 00		spin2: db "+", 0 
0d39 .. 00		spin3: db "#", 0 
0d3b			 
0d3b			 
0d3b			; information window 
0d3b			 
0d3b			; pass hl with 1st string to display 
0d3b			; pass de with 2nd string to display 
0d3b			 
0d3b			info_panel: 
0d3b e5				push hl 
0d3c			 
0d3c 2a 01 fb			ld hl, (display_fb_active) 
0d3f e5				push hl    ; future de destination 
0d40 21 e6 fc				ld hl, display_fb0 
0d43 22 01 fb				ld (display_fb_active), hl 
0d46			 
0d46			;	call clear_display 
0d46			 
0d46				if BASE_CPM 
0d46				ld a, '.' 
0d46				else 
0d46 3e a5			ld a, 165 
0d48				endif 
0d48 cd af 0d			call fill_display 
0d4b			 
0d4b			 
0d4b 3e 55			ld a, display_row_3 + 5 
0d4d cd bd 0d			call str_at_display 
0d50			 
0d50 e1				pop hl 
0d51 d1				pop de 
0d52			 
0d52 e5				push hl 
0d53			 
0d53			 
0d53 3e 2d			ld a, display_row_2 + 5 
0d55 cd bd 0d			call str_at_display 
0d58			 
0d58			 
0d58 cd cd 0d			call update_display 
0d5b cd be 1f			call next_page_prompt 
0d5e cd aa 0d			call clear_display 
0d61			 
0d61				 
0d61 21 45 fc				ld hl, display_fb1 
0d64 22 01 fb				ld (display_fb_active), hl 
0d67 cd cd 0d			call update_display 
0d6a			 
0d6a e1				pop hl 
0d6b			 
0d6b c9				ret 
0d6c			 
0d6c			 
0d6c			 
0d6c			 
0d6c			; TODO windowing? 
0d6c			 
0d6c			; TODO scroll line up 
0d6c			 
0d6c			scroll_up: 
0d6c			 
0d6c e5				push hl 
0d6d d5				push de 
0d6e c5				push bc 
0d6f			 
0d6f				; get frame buffer  
0d6f			 
0d6f 2a 01 fb			ld hl, (display_fb_active) 
0d72 e5				push hl    ; future de destination 
0d73			 
0d73 11 28 00			ld  de, display_cols 
0d76 19				add hl, de 
0d77			 
0d77 d1				pop de 
0d78			 
0d78				;ex de, hl 
0d78 01 9f 00			ld bc, display_fb_len -1  
0d7b			;if DEBUG_FORTH_WORDS 
0d7b			;	DMARK "SCL" 
0d7b			;	CALLMONITOR 
0d7b			;endif	 
0d7b ed b0			ldir 
0d7d			 
0d7d				; wipe bottom row 
0d7d			 
0d7d			 
0d7d 2a 01 fb			ld hl, (display_fb_active) 
0d80 11 a0 00			ld de, display_cols*display_rows 
0d83 19				add hl, de 
0d84 06 28			ld b, display_cols 
0d86 3e 20			ld a, ' ' 
0d88			.scwipe: 
0d88 77				ld (hl), a 
0d89 2b				dec hl 
0d8a 10 fc			djnz .scwipe 
0d8c			 
0d8c				;pop hl 
0d8c			 
0d8c c1				pop bc 
0d8d d1				pop de 
0d8e e1				pop hl 
0d8f			 
0d8f c9				ret 
0d90			 
0d90			 
0d90			;scroll_upo: 
0d90			;	ld de, display_row_1 
0d90			 ;	ld hl, display_row_2 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_2 
0d90			 ;	ld hl, display_row_3 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_3 
0d90			 ;	ld hl, display_row_4 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			 
0d90			; TODO clear row 4 
0d90			 
0d90			;	ret 
0d90			 
0d90				 
0d90			scroll_down: 
0d90			 
0d90 e5				push hl 
0d91 d5				push de 
0d92 c5				push bc 
0d93			 
0d93				; get frame buffer  
0d93			 
0d93 2a 01 fb			ld hl, (display_fb_active) 
0d96			 
0d96 11 9f 00			ld de, display_fb_len - 1 
0d99 19				add hl, de 
0d9a			 
0d9a e5			push hl    ; future de destination 
0d9b			 
0d9b 11 28 00			ld  de, display_cols 
0d9e ed 52			sbc hl, de 
0da0			 
0da0			 
0da0 d1				pop de 
0da1			 
0da1			;	ex de, hl 
0da1 01 9f 00			ld bc, display_fb_len -1  
0da4			 
0da4			 
0da4				 
0da4			 
0da4 ed b0			ldir 
0da6			 
0da6				; wipe bottom row 
0da6			 
0da6			 
0da6			;	ld hl, (display_fb_active) 
0da6			;;	ld de, display_cols*display_rows 
0da6			;;	add hl, de 
0da6			;	ld b, display_cols 
0da6			;	ld a, ' ' 
0da6			;.scwiped: 
0da6			;	ld (hl), a 
0da6			;	dec hl 
0da6			;	djnz .scwiped 
0da6			 
0da6				;pop hl 
0da6			 
0da6 c1				pop bc 
0da7 d1				pop de 
0da8 e1				pop hl 
0da9			 
0da9 c9				ret 
0daa			;scroll_down: 
0daa			;	ld de, display_row_4 
0daa			;	ld hl, display_row_3 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_3 
0daa			; 	ld hl, display_row_2 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_2 
0daa			;	ld hl, display_row_1 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;;; TODO clear row 1 
0daa			;	ret 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			; clear active frame buffer 
0daa			 
0daa			clear_display: 
0daa 3e 20			ld a, ' ' 
0dac c3 af 0d			jp fill_display 
0daf			 
0daf			; fill active frame buffer with a char in A 
0daf			 
0daf			fill_display: 
0daf 06 a0			ld b,display_fb_len 
0db1 2a 01 fb			ld hl, (display_fb_active) 
0db4 77			.fd1:	ld (hl),a 
0db5 23				inc hl 
0db6 10 fc			djnz .fd1 
0db8 23				inc hl 
0db9 3e 00			ld a,0 
0dbb 77				ld (hl),a 
0dbc			 
0dbc			 
0dbc c9				ret 
0dbd			; Write string (DE) at pos (A) to active frame buffer 
0dbd			 
0dbd 2a 01 fb		str_at_display:    ld hl,(display_fb_active) 
0dc0 06 00					ld b,0 
0dc2 4f					ld c,a 
0dc3 09					add hl,bc 
0dc4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0dc5 b7			            OR   A              ;Null terminator? 
0dc6 c8			            RET  Z              ;Yes, so finished 
0dc7 77					ld (hl),a 
0dc8 23				inc hl 
0dc9 13			            INC  DE             ;Point to next character 
0dca 18 f8		            JR   .sad1     ;Repeat 
0dcc c9					ret 
0dcd			 
0dcd			; using current frame buffer write to physical display 
0dcd			 
0dcd			update_display: 
0dcd e5				push hl 
0dce 2a 01 fb			ld hl, (display_fb_active) 
0dd1 cd d2 6f			call write_display 
0dd4 e1				pop hl 
0dd5 c9				ret 
0dd6			 
0dd6			; TODO scrolling 
0dd6			 
0dd6			 
0dd6			; move cursor right one char 
0dd6			cursor_right: 
0dd6			 
0dd6				; TODO shift right 
0dd6				; TODO if beyond max col 
0dd6				; TODO       cursor_next_line 
0dd6			 
0dd6 c9				ret 
0dd7			 
0dd7			 
0dd7			cursor_next_line: 
0dd7				; TODO first char 
0dd7				; TODO line down 
0dd7				; TODO if past last row 
0dd7				; TODO    scroll up 
0dd7			 
0dd7 c9				ret 
0dd8			 
0dd8			cursor_left: 
0dd8				; TODO shift left 
0dd8				; TODO if beyond left  
0dd8				; TODO     cursor prev line 
0dd8				 
0dd8 c9				ret 
0dd9			 
0dd9			cursor_prev_line: 
0dd9				; TODO last char 
0dd9				; TODO line up 
0dd9				; TODO if past first row 
0dd9				; TODO   scroll down 
0dd9			 
0dd9 c9				ret 
0dda			 
0dda			 
0dda			cout: 
0dda				; A - char 
0dda c9				ret 
0ddb			 
0ddb			 
0ddb			; Display a menu and allow item selection (optional toggle items) 
0ddb			; 
0ddb			; format: 
0ddb			; hl pointer to word array with zero term for items 
0ddb			; e.g.    db item1 
0ddb			;         db .... 
0ddb			;         db 0 
0ddb			; 
0ddb			; a = starting menu item  
0ddb			; 
0ddb			; de = pointer item toggle array   (todo) 
0ddb			; 
0ddb			; returns item selected in a 1-... 
0ddb			; returns 0 if back button pressed 
0ddb			; 
0ddb			; NOTE: Uses system frame buffer to display 
0ddb			; 
0ddb			; LEFT, Q = go back 
0ddb			; RIGHT, SPACE, CR = select 
0ddb			; UP, A - Up 
0ddb			; DOWN, Z - Down 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			menu: 
0ddb			 
0ddb					; keep array pointer 
0ddb			 
0ddb 22 a8 f9				ld (store_tmp1), hl 
0dde 32 a6 f9				ld (store_tmp2), a 
0de1			 
0de1					; check for key bounce 
0de1			 
0de1			if BASE_KEV 
0de1			 
0de1 cd 1d 73		.mbounce:	call cin 
0de4 fe 00				cp 0 
0de6 20 f9				jr nz, .mbounce 
0de8			endif 
0de8					; for ease use ex 
0de8			 
0de8					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0de8 21 e6 fc				ld hl, display_fb0 
0deb 22 01 fb				ld (display_fb_active), hl 
0dee			 
0dee cd aa 0d		.mloop:		call clear_display 
0df1 cd cd 0d				call update_display 
0df4			 
0df4					; draw selection id '>' at 1 
0df4			 
0df4					; init start of list display 
0df4			 
0df4 3e 05				ld a, 5 
0df6 32 a4 f9				ld (store_tmp3), a   ; display row count 
0df9 3a a6 f9				ld a,( store_tmp2) 
0dfc 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0dff			 
0dff					 
0dff			.mitem:	 
0dff			 
0dff			 
0dff 3a a7 f9				ld a,(store_tmp2+1) 
0e02 6f					ld l, a 
0e03 26 00				ld h, 0 
0e05 29					add hl, hl 
0e06 ed 5b a8 f9			ld de, (store_tmp1) 
0e0a 19					add hl, de 
0e0b 7e					ld a, (hl) 
0e0c 23					inc hl 
0e0d 66					ld h,(hl) 
0e0e 6f					ld l, a 
0e0f			 
0e0f cd 07 10				call ishlzero 
0e12 28 1a				jr z, .mdone 
0e14			 
0e14 eb					ex de, hl 
0e15 3a a4 f9				ld a, (store_tmp3) 
0e18 cd bd 0d				call str_at_display 
0e1b					 
0e1b			 
0e1b					; next item 
0e1b 3a a7 f9				ld a, (store_tmp2+1) 
0e1e 3c					inc a 
0e1f 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0e22			 
0e22			 		; next row 
0e22			 
0e22 3a a4 f9				ld a, (store_tmp3) 
0e25 c6 28				add display_cols 
0e27 32 a4 f9				ld (store_tmp3), a 
0e2a			 
0e2a					; at end of screen? 
0e2a			 
0e2a fe 10				cp display_rows*4 
0e2c 20 d1				jr nz, .mitem 
0e2e			 
0e2e			 
0e2e			.mdone: 
0e2e cd 07 10				call ishlzero 
0e31 28 08				jr z, .nodn 
0e33			 
0e33 3e 78				ld a, display_row_4 
0e35 11 b4 0e				ld de, .mdown 
0e38 cd bd 0d				call str_at_display 
0e3b			 
0e3b					; draw options to fill the screens with active item on line 1 
0e3b					; if current option is 2 or more then display ^ in top 
0e3b			 
0e3b 3a a6 f9		.nodn:		ld a, (store_tmp2) 
0e3e fe 00				cp 0 
0e40 28 08				jr z, .noup 
0e42			 
0e42 3e 00				ld a, 0 
0e44 11 b2 0e				ld de, .mup 
0e47 cd bd 0d				call str_at_display 
0e4a			 
0e4a 3e 02		.noup:		ld a, 2 
0e4c 11 b0 0e				ld de, .msel 
0e4f cd bd 0d				call str_at_display 
0e52			 
0e52					; if current option + 1 is not null then display V in bottom 
0e52					; get key 
0e52 cd cd 0d				call update_display 
0e55			 
0e55			 
0e55					; handle key 
0e55			 
0e55 cd 0c 73				call cin_wait 
0e58			 
0e58 fe 05				cp KEY_UP 
0e5a 28 2b				jr z, .mgoup 
0e5c fe 61				cp 'a' 
0e5e 28 27				jr z, .mgoup 
0e60 fe 0a				cp KEY_DOWN 
0e62 28 32				jr z, .mgod 
0e64 fe 7a				cp 'z' 
0e66 28 2e				jr z, .mgod 
0e68 fe 20				cp ' ' 
0e6a 28 34				jr z, .goend 
0e6c fe 0c				cp KEY_RIGHT 
0e6e 28 30				jr z, .goend 
0e70 fe 0d				cp KEY_CR 
0e72 28 2c				jr z, .goend 
0e74 fe 71				cp 'q' 
0e76 28 0b				jr z, .goback 
0e78			 
0e78 fe 0b				cp KEY_LEFT 
0e7a 28 07				jr z, .goback 
0e7c fe 08				cp KEY_BS 
0e7e 28 03				jr z, .goback 
0e80 c3 ee 0d				jp .mloop 
0e83			 
0e83			.goback: 
0e83 3e 00			ld a, 0 
0e85 18 1d			jr .goend2 
0e87			 
0e87				; move up one 
0e87			.mgoup: 
0e87 3a a6 f9				ld a, (store_tmp2) 
0e8a fe 00				cp 0 
0e8c ca ee 0d				jp z, .mloop 
0e8f 3d					dec a 
0e90 32 a6 f9				ld (store_tmp2), a 
0e93 c3 ee 0d				jp .mloop 
0e96			 
0e96				; move down one 
0e96			.mgod: 
0e96 3a a6 f9				ld a, (store_tmp2) 
0e99 3c					inc a 
0e9a 32 a6 f9				ld (store_tmp2), a 
0e9d c3 ee 0d				jp .mloop 
0ea0			 
0ea0			 
0ea0			.goend: 
0ea0					; get selected item number 
0ea0			 
0ea0 3a a6 f9				ld a, (store_tmp2) 
0ea3 3c					inc a 
0ea4			 
0ea4			.goend2: 
0ea4 f5					push af 
0ea5			 
0ea5					; restore active fb 
0ea5					; TODO BUG assumes fb1 
0ea5			 
0ea5 21 45 fc				ld hl, display_fb1 
0ea8 22 01 fb				ld (display_fb_active), hl 
0eab			 
0eab					; restore main regs 
0eab			 
0eab			 
0eab cd cd 0d				call update_display 
0eae			 
0eae f1					pop af 
0eaf			 
0eaf c9				ret 
0eb0			 
0eb0 .. 00		.msel:   db ">",0 
0eb2 .. 00		.mup:   db "^",0 
0eb4 .. 00		.mdown:   db "v",0 
0eb6			 
0eb6			 
0eb6			; eof 
0eb6			 
# End of file firmware_display.asm
0eb6			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0eb6			; random number generators 
0eb6			 
0eb6			 
0eb6			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0eb6			 
0eb6			 
0eb6			;-----> Generate a random number 
0eb6			; output a=answer 0<=a<=255 
0eb6			; all registers are preserved except: af 
0eb6			random: 
0eb6 e5			        push    hl 
0eb7 d5			        push    de 
0eb8 2a e0 fa		        ld      hl,(randData) 
0ebb ed 5f		        ld      a,r 
0ebd 57			        ld      d,a 
0ebe 5e			        ld      e,(hl) 
0ebf 19			        add     hl,de 
0ec0 85			        add     a,l 
0ec1 ac			        xor     h 
0ec2 22 e0 fa		        ld      (randData),hl 
0ec5 d1			        pop     de 
0ec6 e1			        pop     hl 
0ec7 c9			        ret 
0ec8			 
0ec8			 
0ec8			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ec8			 
0ec8			 
0ec8			 
0ec8			;------LFSR------ 
0ec8			;James Montelongo 
0ec8			;optimized by Spencer Putt 
0ec8			;out: 
0ec8			; a = 8 bit random number 
0ec8			RandLFSR: 
0ec8 21 e6 fa		        ld hl,LFSRSeed+4 
0ecb 5e			        ld e,(hl) 
0ecc 23			        inc hl 
0ecd 56			        ld d,(hl) 
0ece 23			        inc hl 
0ecf 4e			        ld c,(hl) 
0ed0 23			        inc hl 
0ed1 7e			        ld a,(hl) 
0ed2 47			        ld b,a 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 cb 13		        rl e  
0ee3 cb 12			rl d 
0ee5 cb 11		        rl c  
0ee7 17				rla 
0ee8 67			        ld h,a 
0ee9 cb 13		        rl e  
0eeb cb 12			rl d 
0eed cb 11		        rl c  
0eef 17				rla 
0ef0 a8			        xor b 
0ef1 cb 13		        rl e  
0ef3 cb 12			rl d 
0ef5 ac			        xor h 
0ef6 a9			        xor c 
0ef7 aa			        xor d 
0ef8 21 e8 fa		        ld hl,LFSRSeed+6 
0efb 11 e9 fa		        ld de,LFSRSeed+7 
0efe 01 07 00		        ld bc,7 
0f01 ed b8		        lddr 
0f03 12			        ld (de),a 
0f04 c9			        ret 
0f05			 
0f05			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0f05			 
0f05			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0f05			 
0f05			 
0f05			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0f05			 
0f05			prng16: 
0f05			;Inputs: 
0f05			;   (seed1) contains a 16-bit seed value 
0f05			;   (seed2) contains a NON-ZERO 16-bit seed value 
0f05			;Outputs: 
0f05			;   HL is the result 
0f05			;   BC is the result of the LCG, so not that great of quality 
0f05			;   DE is preserved 
0f05			;Destroys: 
0f05			;   AF 
0f05			;cycle: 4,294,901,760 (almost 4.3 billion) 
0f05			;160cc 
0f05			;26 bytes 
0f05 2a da fa		    ld hl,(seed1) 
0f08 44			    ld b,h 
0f09 4d			    ld c,l 
0f0a 29			    add hl,hl 
0f0b 29			    add hl,hl 
0f0c 2c			    inc l 
0f0d 09			    add hl,bc 
0f0e 22 da fa		    ld (seed1),hl 
0f11 2a d8 fa		    ld hl,(seed2) 
0f14 29			    add hl,hl 
0f15 9f			    sbc a,a 
0f16 e6 2d		    and %00101101 
0f18 ad			    xor l 
0f19 6f			    ld l,a 
0f1a 22 d8 fa		    ld (seed2),hl 
0f1d 09			    add hl,bc 
0f1e c9			    ret 
0f1f			 
0f1f			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f1f			 
0f1f			rand32: 
0f1f			;Inputs: 
0f1f			;   (seed1_0) holds the lower 16 bits of the first seed 
0f1f			;   (seed1_1) holds the upper 16 bits of the first seed 
0f1f			;   (seed2_0) holds the lower 16 bits of the second seed 
0f1f			;   (seed2_1) holds the upper 16 bits of the second seed 
0f1f			;   **NOTE: seed2 must be non-zero 
0f1f			;Outputs: 
0f1f			;   HL is the result 
0f1f			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f1f			;Destroys: 
0f1f			;   AF 
0f1f			;Tested and passes all CAcert tests 
0f1f			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f1f			;it has a period of 18,446,744,069,414,584,320 
0f1f			;roughly 18.4 quintillion. 
0f1f			;LFSR taps: 0,2,6,7  = 11000101 
0f1f			;291cc 
0f1f			;seed1_0=$+1 
0f1f			;    ld hl,12345 
0f1f			;seed1_1=$+1 
0f1f			;    ld de,6789 
0f1f			;    ld b,h 
0f1f			;    ld c,l 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    inc l 
0f1f			;    add hl,bc 
0f1f			;    ld (seed1_0),hl 
0f1f			;    ld hl,(seed1_1) 
0f1f			;    adc hl,de 
0f1f			;    ld (seed1_1),hl 
0f1f			;    ex de,hl 
0f1f			;seed2_0=$+1 
0f1f			;    ld hl,9876 
0f1f			;seed2_1=$+1 
0f1f			;    ld bc,54321 
0f1f			;    add hl,hl \ rl c \ rl b 
0f1f			;    ld (seed2_1),bc 
0f1f			;    sbc a,a 
0f1f			;    and %11000101 
0f1f			;    xor l 
0f1f			;    ld l,a 
0f1f			;    ld (seed2_0),hl 
0f1f			;    ex de,hl 
0f1f			;    add hl,bc 
0f1f			;    ret 
0f1f			; 
0f1f			 
0f1f			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f1f			; 20 bytes, 86 cycles (excluding ret) 
0f1f			 
0f1f			; returns   hl = pseudorandom number 
0f1f			; corrupts   a 
0f1f			 
0f1f			; generates 16-bit pseudorandom numbers with a period of 65535 
0f1f			; using the xorshift method: 
0f1f			 
0f1f			; hl ^= hl << 7 
0f1f			; hl ^= hl >> 9 
0f1f			; hl ^= hl << 8 
0f1f			 
0f1f			; some alternative shift triplets which also perform well are: 
0f1f			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f1f			 
0f1f			;  org 32768 
0f1f			 
0f1f			xrnd: 
0f1f 2a de fa		  ld hl,(xrandc)       ; seed must not be 0 
0f22 3e 00		  ld a,0 
0f24 bd			  cp l 
0f25 20 02		  jr nz, .xrnd1 
0f27 2e 01		  ld l, 1 
0f29			.xrnd1: 
0f29			 
0f29 7c			  ld a,h 
0f2a 1f			  rra 
0f2b 7d			  ld a,l 
0f2c 1f			  rra 
0f2d ac			  xor h 
0f2e 67			  ld h,a 
0f2f 7d			  ld a,l 
0f30 1f			  rra 
0f31 7c			  ld a,h 
0f32 1f			  rra 
0f33 ad			  xor l 
0f34 6f			  ld l,a 
0f35 ac			  xor h 
0f36 67			  ld h,a 
0f37			 
0f37 22 de fa		  ld (xrandc),hl 
0f3a			 
0f3a c9			  ret 
0f3b			;  
0f3b			 
0f3b			 
0f3b			;;;; int maths 
0f3b			 
0f3b			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f3b			; Divide 16-bit values (with 16-bit result) 
0f3b			; In: Divide BC by divider DE 
0f3b			; Out: BC = result, HL = rest 
0f3b			; 
0f3b			Div16: 
0f3b 21 00 00		    ld hl,0 
0f3e 78			    ld a,b 
0f3f 06 08		    ld b,8 
0f41			Div16_Loop1: 
0f41 17			    rla 
0f42 ed 6a		    adc hl,hl 
0f44 ed 52		    sbc hl,de 
0f46 30 01		    jr nc,Div16_NoAdd1 
0f48 19			    add hl,de 
0f49			Div16_NoAdd1: 
0f49 10 f6		    djnz Div16_Loop1 
0f4b 17			    rla 
0f4c 2f			    cpl 
0f4d 47			    ld b,a 
0f4e 79			    ld a,c 
0f4f 48			    ld c,b 
0f50 06 08		    ld b,8 
0f52			Div16_Loop2: 
0f52 17			    rla 
0f53 ed 6a		    adc hl,hl 
0f55 ed 52		    sbc hl,de 
0f57 30 01		    jr nc,Div16_NoAdd2 
0f59 19			    add hl,de 
0f5a			Div16_NoAdd2: 
0f5a 10 f6		    djnz Div16_Loop2 
0f5c 17			    rla 
0f5d 2f			    cpl 
0f5e 41			    ld b,c 
0f5f 4f			    ld c,a 
0f60 c9			ret 
0f61			 
0f61			 
0f61			;http://z80-heaven.wikidot.com/math 
0f61			; 
0f61			;Inputs: 
0f61			;     DE and A are factors 
0f61			;Outputs: 
0f61			;     A is not changed 
0f61			;     B is 0 
0f61			;     C is not changed 
0f61			;     DE is not changed 
0f61			;     HL is the product 
0f61			;Time: 
0f61			;     342+6x 
0f61			; 
0f61			Mult16: 
0f61			 
0f61 06 08		     ld b,8          ;7           7 
0f63 21 00 00		     ld hl,0         ;10         10 
0f66 29			       add hl,hl     ;11*8       88 
0f67 07			       rlca          ;4*8        32 
0f68 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f6a 19			         add hl,de   ;--         -- 
0f6b 10 f9		       djnz $-5      ;13*7+8     99 
0f6d c9			ret 
0f6e			 
0f6e			; 
0f6e			; Square root of 16-bit value 
0f6e			; In:  HL = value 
0f6e			; Out:  D = result (rounded down) 
0f6e			; 
0f6e			;Sqr16: 
0f6e			;    ld de,#0040 
0f6e			;    ld a,l 
0f6e			;    ld l,h 
0f6e			;    ld h,d 
0f6e			;    or a 
0f6e			;    ld b,8 
0f6e			;Sqr16_Loop: 
0f6e			;    sbc hl,de 
0f6e			;    jr nc,Sqr16_Skip 
0f6e			;    add hl,de 
0f6e			;Sqr16_Skip: 
0f6e			;    ccf 
0f6e			;    rl d 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    djnz Sqr16_Loop 
0f6e			;    ret 
0f6e			; 
0f6e			; 
0f6e			; Divide 8-bit values 
0f6e			; In: Divide E by divider C 
0f6e			; Out: A = result, B = rest 
0f6e			; 
0f6e			Div8: 
0f6e af			    xor a 
0f6f 06 08		    ld b,8 
0f71			Div8_Loop: 
0f71 cb 13		    rl e 
0f73 17			    rla 
0f74 91			    sub c 
0f75 30 01		    jr nc,Div8_NoAdd 
0f77 81			    add a,c 
0f78			Div8_NoAdd: 
0f78 10 f7		    djnz Div8_Loop 
0f7a 47			    ld b,a 
0f7b 7b			    ld a,e 
0f7c 17			    rla 
0f7d 2f			    cpl 
0f7e c9			    ret 
0f7f			 
0f7f			; 
0f7f			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f7f			; In: Multiply A with DE 
0f7f			; Out: HL = result 
0f7f			; 
0f7f			Mult12U: 
0f7f 2e 00		    ld l,0 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd0 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd0: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd1 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd1: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd2 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd2: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd3 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd3: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 30 01		    jr nc,Mult12U_NoAdd4 
0f98 19			    add hl,de 
0f99			Mult12U_NoAdd4: 
0f99 29			    add hl,hl 
0f9a 87			    add a,a 
0f9b 30 01		    jr nc,Mult12U_NoAdd5 
0f9d 19			    add hl,de 
0f9e			Mult12U_NoAdd5: 
0f9e 29			    add hl,hl 
0f9f 87			    add a,a 
0fa0 30 01		    jr nc,Mult12U_NoAdd6 
0fa2 19			    add hl,de 
0fa3			Mult12U_NoAdd6: 
0fa3 29			    add hl,hl 
0fa4 87			    add a,a 
0fa5 d0			    ret nc 
0fa6 19			    add hl,de 
0fa7 c9			    ret 
0fa8			 
0fa8			; 
0fa8			; Multiply 8-bit value with a 16-bit value (right rotating) 
0fa8			; In: Multiply A with DE 
0fa8			;      Put lowest value in A for most efficient calculation 
0fa8			; Out: HL = result 
0fa8			; 
0fa8			Mult12R: 
0fa8 21 00 00		    ld hl,0 
0fab			Mult12R_Loop: 
0fab cb 3f		    srl a 
0fad 30 01		    jr nc,Mult12R_NoAdd 
0faf 19			    add hl,de 
0fb0			Mult12R_NoAdd: 
0fb0 cb 23		    sla e 
0fb2 cb 12		    rl d 
0fb4 b7			    or a 
0fb5 c2 ab 0f		    jp nz,Mult12R_Loop 
0fb8 c9			    ret 
0fb9			 
0fb9			; 
0fb9			; Multiply 16-bit values (with 32-bit result) 
0fb9			; In: Multiply BC with DE 
0fb9			; Out: BCHL = result 
0fb9			; 
0fb9			Mult32: 
0fb9 79			    ld a,c 
0fba 48			    ld c,b 
0fbb 21 00 00		    ld hl,0 
0fbe 06 10		    ld b,16 
0fc0			Mult32_Loop: 
0fc0 29			    add hl,hl 
0fc1 17			    rla 
0fc2 cb 11		    rl c 
0fc4 30 07		    jr nc,Mult32_NoAdd 
0fc6 19			    add hl,de 
0fc7 ce 00		    adc a,0 
0fc9 d2 cd 0f		    jp nc,Mult32_NoAdd 
0fcc 0c			    inc c 
0fcd			Mult32_NoAdd: 
0fcd 10 f1		    djnz Mult32_Loop 
0fcf 41			    ld b,c 
0fd0 4f			    ld c,a 
0fd1 c9			    ret 
0fd2			 
0fd2			 
0fd2			 
0fd2			; 
0fd2			; Multiply 8-bit values 
0fd2			; In:  Multiply H with E 
0fd2			; Out: HL = result 
0fd2			; 
0fd2			Mult8: 
0fd2 16 00		    ld d,0 
0fd4 6a			    ld l,d 
0fd5 06 08		    ld b,8 
0fd7			Mult8_Loop: 
0fd7 29			    add hl,hl 
0fd8 30 01		    jr nc,Mult8_NoAdd 
0fda 19			    add hl,de 
0fdb			Mult8_NoAdd: 
0fdb 10 fa		    djnz Mult8_Loop 
0fdd c9			    ret 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			;;http://z80-heaven.wikidot.com/math 
0fde			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fde			; 
0fde			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fde			;     ld a,16        ;7 
0fde			;     ld hl,0        ;10 
0fde			;     jp $+5         ;10 
0fde			;.DivLoop: 
0fde			;       add hl,bc    ;-- 
0fde			;       dec a        ;64 
0fde			;       jr z,.DivLoopEnd        ;86 
0fde			; 
0fde			;       sla e        ;128 
0fde			;       rl d         ;128 
0fde			;       adc hl,hl    ;240 
0fde			;       sbc hl,bc    ;240 
0fde			;       jr nc,.DivLoop ;23|21 
0fde			;       inc e        ;-- 
0fde			;       jp .DivLoop+1 
0fde			; 
0fde			;.DivLoopEnd: 
0fde			 
0fde			;HL_Div_C: 
0fde			;Inputs: 
0fde			;     HL is the numerator 
0fde			;     C is the denominator 
0fde			;Outputs: 
0fde			;     A is the remainder 
0fde			;     B is 0 
0fde			;     C is not changed 
0fde			;     DE is not changed 
0fde			;     HL is the quotient 
0fde			; 
0fde			;       ld b,16 
0fde			;       xor a 
0fde			;         add hl,hl 
0fde			;         rla 
0fde			;         cp c 
0fde			;         jr c,$+4 
0fde			;           inc l 
0fde			;           sub c 
0fde			;         djnz $-7 
0fde			 
0fde			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fde			 
0fde			addatohl: 
0fde 85			    add   a, l    ; A = A+L 
0fdf 6f			    ld    l, a    ; L = A+L 
0fe0 8c			    adc   a, h    ; A = A+L+H+carry 
0fe1 95			    sub   l       ; A = H+carry 
0fe2 67			    ld    h, a    ; H = H+carry 
0fe3 c9			ret 
0fe4			 
0fe4			addatode: 
0fe4 83			    add   a, e    ; A = A+L 
0fe5 5f			    ld    e, a    ; L = A+L 
0fe6 8a			    adc   a, d    ; A = A+L+H+carry 
0fe7 93			    sub   e       ; A = H+carry 
0fe8 57			    ld    d, a    ; H = H+carry 
0fe9 c9			ret 
0fea			 
0fea			 
0fea			addatobc: 
0fea 81			    add   a, c    ; A = A+L 
0feb 4f			    ld    c, a    ; L = A+L 
0fec 88			    adc   a, b    ; A = A+L+H+carry 
0fed 91			    sub   c       ; A = H+carry 
0fee 47			    ld    b, a    ; H = H+carry 
0fef c9			ret 
0ff0			 
0ff0			subafromhl: 
0ff0			   ; If A=0 do nothing 
0ff0			    ; Otherwise flip A's sign. Since 
0ff0			    ; the upper byte becomes -1, also 
0ff0			    ; substract 1 from H. 
0ff0 ed 44		    neg 
0ff2 ca fb 0f		    jp    z, Skip 
0ff5 25			    dec   h 
0ff6			     
0ff6			    ; Now add the low byte as usual 
0ff6			    ; Two's complement takes care of 
0ff6			    ; ensuring the result is correct 
0ff6 85			    add   a, l 
0ff7 6f			    ld    l, a 
0ff8 8c			    adc   a, h 
0ff9 95			    sub   l 
0ffa 67			    ld    h, a 
0ffb			Skip: 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			; compare hl and de 
0ffc			; returns:  
0ffc			; if hl = de, z=1, s=0, c0=0 
0ffc			; if hl > de, z=0, s=0, c=0 
0ffc			; if hl < de, z=0, s=1, c=1 
0ffc			cmp16:	 
0ffc b7				or a 
0ffd ed 52			sbc hl,de 
0fff e0				ret po 
1000 7c				ld a,h 
1001 1f				rra 
1002 ee 40			xor 01000000B 
1004 37				scf 
1005 8f				adc a,a 
1006 c9				ret 
1007			 
1007			 
1007			; test if hl contains zero   - A is destroyed 
1007			 
1007			ishlzero:    
1007 b7				or a     ; reset flags 
1008 7c				ld a, h 
1009 b5				or l        	 
100a			 
100a c9				ret 
100b			 
100b			 
100b			 
100b			 
100b			if FORTH_ENABLE_FLOATMATH 
100b			;include "float/bbcmath.z80" 
100b			include "float/lpfpcalc.asm" 
100b			endif 
100b			 
100b			 
100b			; eof 
100b			 
# End of file firmware_maths.asm
100b			include "firmware_strings.asm"   ; string handling  
100b			 
100b			 
100b			; TODO string len 
100b			; input text string, end on cr with zero term 
100b			; a offset into frame buffer to start prompt 
100b			; d is max length 
100b			; e is display size TODO 
100b			; c is current cursor position 
100b			; hl is ptr to where string will be stored and edited directly 
100b			 
100b			 
100b			; TODO check limit of buffer for new inserts 
100b			; TODO check insert does not push beyond buffer 
100b			; TODO scroll in a limited display area 
100b			; TODO scroll whole screen on page wrap 
100b			 
100b			 
100b			; TODO use LCD cursor? 
100b			 
100b			EDIT_V1: equ 0 
100b			EDIT_V2: equ 1 
100b			 
100b			 
100b			 
100b			if EDIT_V2 
100b			input_str: 
100b			 
100b 32 99 fd			    	ld (input_at_pos),a      ; save display position to start 
100e			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
100e 22 9c fd				ld (input_start), hl     ; save ptr to buffer 
1011			;		ld a, c 
1011			;		call addatohl 
1011			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1011 7a					ld a,d 
1012 32 9b fd			        ld (input_size), a       ; save length of input area 
1015 79					ld a, c 
1016 32 8a fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
1019 7b					ld a,e 
101a 32 9a fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101d			 
101d			 
101d					; add a trailing space to make screen refresh nicer 
101d			 
101d					;ld hl, (input_start) 
101d					;push hl 
101d					;ld a, 0 
101d					;call strlent 
101d					;ld a, l 
101d					;pop hl 
101d					;call addatohl 
101d					;dec hl 
101d					;ld a, ' ' 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld a, 0 
101d					;ld (hl), a 
101d			 
101d			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101d					; init cursor shape if not set by the cin routines 
101d 21 f6 fa				ld hl, cursor_shape 
1020			if BASE_KEV 
1020 3e ff				ld a, 255 
1022			else 
1022					ld a, '#' 
1022			endif 
1022 77					ld (hl), a 
1023 23					inc hl 
1024 3e 00				ld a, 0 
1026 77					ld (hl), a 
1027			 
1027 3e 09				ld a, CUR_BLINK_RATE 
1029 32 95 fd				ld (input_cur_flash), a 
102c 3e 01				ld a, 1 
102e 32 94 fd				ld (input_cur_onoff),a 
1031			.inmain:	 
1031			 
1031 cd 59 11				call input_disp_ref 
1034			 
1034					; save current length of string 
1034			 
1034 2a 9c fd				ld hl, (input_start) 
1037 3e 00				ld a, 0 
1039 cd 4f 13				call strlent 
103c 7d					ld a,l 
103d 32 8f fd				ld (input_len), a 
1040			 
1040					;call input_disp_oncur 
1040			 
1040					; display current state of input buffer 
1040			 
1040					; clean any backspace chars 
1040			 
1040 3e 20				ld a, " " 
1042 32 f6 f0				ld (scratch),a 
1045 3e 00				ld a, 0 
1047 32 f7 f0				ld (scratch+1),a 
104a 3a 99 fd				ld a,(input_at_pos) 
104d 85					add l 
104e 11 f6 f0				ld de, scratch 
1051 cd bd 0d				call str_at_display 
1054			 
1054					; pause 1ms 
1054			 
1054 3e 01				ld a, 1 
1056 cd d2 0c				call aDelayInMS 
1059			 
1059			; display cursor if visible on this cycle 
1059			 
1059					; dec flash counter 
1059 3a 95 fd				ld a, (input_cur_flash) 
105c 3d					dec a 
105d 32 95 fd				ld (input_cur_flash), a 
1060 fe 00				cp 0 
1062 20 0d				jr nz, .inochgstate 
1064			 
1064			 
1064					; reset on change of state 
1064 3e 09				ld a, CUR_BLINK_RATE 
1066 32 95 fd				ld (input_cur_flash), a 
1069			 
1069					; change state 
1069 3a 94 fd				ld a,(input_cur_onoff) 
106c ed 44				neg 
106e 32 94 fd				ld (input_cur_onoff),a 
1071			 
1071			 
1071			 
1071			 
1071					; TODO is cursor visible? 
1071					; TODO if so then over write the char at curspos pos with the cursor shape 
1071			 
1071								 
1071			 
1071			.inochgstate: 
1071 3a 94 fd				ld a,(input_cur_onoff) 
1074 fe ff				cp 255 
1076 28 0e				jr z, .skipcursor 
1078 3a 99 fd				ld a, (input_at_pos) 
107b 47					ld b, a 
107c 3a 8a fd				ld a, (input_cursor) 
107f 80					add b 
1080 11 f6 fa				ld de, cursor_shape 
1083					 
1083 cd bd 0d				call str_at_display 
1086			 
1086			.skipcursor: 
1086				if DEBUG_INPUTV2 
1086			 
1086					ld a,(input_at_pos) 
1086					ld hl, LFSRSeed 
1086					call hexout 
1086					ld a, (input_cursor) 
1086					ld hl, LFSRSeed+2 
1086					call hexout 
1086					ld a,(input_size) 
1086					ld hl, LFSRSeed+4 
1086					call hexout 
1086			 
1086					ld a,(input_cur_onoff) 
1086					ld hl, LFSRSeed+6 
1086					call hexout 
1086			 
1086					ld a,(input_cur_flash) 
1086					ld hl, LFSRSeed+8 
1086					call hexout 
1086			 
1086					ld a,(input_len) 
1086					ld hl, LFSRSeed+10 
1086					call hexout 
1086					ld hl, LFSRSeed+12 
1086					ld a, 0 
1086					ld (hl),a 
1086					ld a, display_row_4 
1086					ld de, LFSRSeed 
1086					call str_at_display 
1086				endif 
1086 cd cd 0d				call update_display 
1089			 
1089					; TODO keyboard processing 
1089			 
1089			if BASE_CPM 
1089					call cin_wait 
1089			else 
1089 cd 1d 73				call cin    ; _wait 
108c			endif 
108c fe 00				cp 0 
108e ca 31 10				jp z, .inmain 
1091			 
1091 fe 0b				cp KEY_LEFT    ; cursor left 
1093 ca 4b 11				jp z, input_left 
1096				 
1096 fe 0c				cp KEY_RIGHT      ; cursor right 
1098 ca 52 11				jp z, input_right 
109b			 
109b fe 0d				cp KEY_CR 
109d c8					ret z 
109e			 
109e fe 08				cp KEY_BS 
10a0 ca c0 11				jp z, input_delchar 
10a3			 
10a3 fe 06				cp KEY_NEXTWORD 
10a5 ca cc 10				jp z, input_nxtword 
10a8			 
10a8 fe 07				cp KEY_PREVWORD 
10aa ca f3 10				jp z, input_prvword 
10ad			 
10ad fe 0e				cp KEY_HOME    ; jump to start of line 
10af 20 08				jr nz, .ikh 
10b1 3e 00				ld a, 0 
10b3 32 8a fd				ld (input_cursor), a 
10b6 ca 31 10				jp z, .inmain 
10b9			.ikh: 
10b9			 
10b9 fe 0f				cp KEY_END     ; jump to end of line 
10bb 20 09				jr nz, .ike 
10bd 3a 8f fd				ld a, (input_len) 
10c0 32 8a fd				ld (input_cursor),a 
10c3 ca 31 10				jp z, .inmain 
10c6			.ike: 
10c6 fe 05			        cp KEY_UP      ; recall last command 
10c8 c8					ret z 
10c9			;jr nz, .irec 
10c9			; TODO next word 
10c9			; TODO prev word 
10c9			;  
10c9			; 
10c9			;	ld hl, scratch 
10c9			;	ld de, os_last_cmd 
10c9			;	call strcpy 
10c9			;		jp  .inmain 
10c9			.irec: 
10c9			;		jr .instr1 
10c9			 
10c9			 
10c9			 
10c9					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
10c9			 
10c9			; TODO return if any special keys are given 
10c9			;		ld l, a 
10c9			;		ld a, 28 ; KEY_F12   ; 27 
10c9			;		sub l 
10c9			;		ret m 
10c9			;		ld a, l 
10c9					; if no special key then insert as a char 
10c9			 
10c9 c3 92 11				jp input_inschr 
10cc			 
10cc				 
10cc			input_nxtword: 
10cc				; jump to start next word after the cursor 
10cc			 
10cc			.insknwn:	 
10cc cd 88 11				call input_curptr	 
10cf 7e					ld a,(hl)	 
10d0 fe 00				cp 0 
10d2 ca 31 10				jp z, .inmain    ; end of string 
10d5			 
10d5			; if we are on a word, then move off of it 
10d5			 
10d5 fe 20				cp ' ' 
10d7 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10d9 21 8a fd				ld hl, input_cursor 
10dc 34					inc (hl) 
10dd 18 ed				jr .insknwn 
10df			 
10df			.inspace: 
10df			 
10df cd 88 11				call input_curptr	 
10e2 7e					ld a,(hl)	 
10e3 fe 00				cp 0 
10e5 ca 31 10				jp z, .inmain    ; end of string 
10e8			 
10e8			; if we are on a word, then move off of it 
10e8			 
10e8 fe 20				cp ' ' 
10ea c2 31 10				jp nz, .inmain     ; we are on non space so at next word 
10ed 21 8a fd				ld hl, input_cursor 
10f0 34					inc (hl) 
10f1 18 ec				jr .inspace 
10f3			 
10f3			 
10f3			 
10f3			 
10f3			input_prvword: 
10f3				; jump to the start of previous word before the cursor 
10f3			 
10f3			; where are we to start with currently? 
10f3			 
10f3 cd 88 11				call input_curptr	 
10f6 7e					ld a, (hl) 
10f7 fe 20				cp ' ' 
10f9 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10fb			 
10fb			 
10fb			 
10fb			.inskpwn:	 
10fb 3a 8a fd				ld a,(input_cursor) 
10fe fe 00				cp 0 
1100 ca 31 10				jp z, .inmain    ; start of string 
1103			 
1103			;if we are on a word, then move off of it 
1103			 
1103 cd 88 11				call input_curptr	 
1106 7e					ld a, (hl) 
1107 fe 20				cp ' ' 
1109 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
110b					;jp z, .inmain    ; start of string 
110b 21 8a fd				ld hl, input_cursor 
110e 35					dec (hl) 
110f 18 ea				jr .inskpwn 
1111			.iwstart: 
1111 21 8a fd				ld hl, input_cursor 
1114 34					inc (hl) 
1115 c3 31 10				jp .inmain 
1118					 
1118			 
1118			.inspacep: 
1118			 
1118					;jp .inmain    ; start of string 
1118			 
1118			 
1118			 
1118 3a 8a fd				ld a,(input_cursor) 
111b fe 00				cp 0 
111d ca 31 10				jp z, .inmain    ; start of string 
1120			 
1120			; if we are on a word, then move off of it 
1120			 
1120 cd 88 11				call input_curptr	 
1123 7e					ld a, (hl) 
1124 fe 20				cp ' ' 
1126 c2 2f 11				jp nz, .incharp     ; we are on non space so at end of prev word 
1129 21 8a fd				ld hl, input_cursor 
112c 35					dec (hl) 
112d 18 e9				jr .inspacep 
112f			 
112f			 
112f			.incharp:	 
112f					; eat the word to get to the start 
112f 3a 8a fd				ld a,(input_cursor) 
1132 fe 00				cp 0 
1134 ca 31 10				jp z, .inmain    ; start of string 
1137			 
1137			; if we are on a word, then move off of it 
1137			 
1137 cd 88 11				call input_curptr	 
113a 7e					ld a, (hl) 
113b fe 20				cp ' ' 
113d 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
113f 21 8a fd				ld hl, input_cursor 
1142 35					dec (hl) 
1143 18 ea				jr .incharp 
1145			.ipwordst: 
1145					; at space before the prev word so reposition over it 
1145 21 8a fd				ld hl, input_cursor 
1148 34					inc (hl) 
1149 18 b0				jr .inskpwn 
114b					 
114b			 
114b			 
114b			input_left: 
114b				; move cursor left 
114b 21 8a fd			ld hl, input_cursor 
114e 35				dec (hl) 
114f			;	cp 0 
114f			;	jp z, .inmain    ; ignore left as at the start of the string 
114f c3 31 10			jp .inmain 
1152			 
1152			input_right: 
1152				; move cursor right 
1152				 
1152				;ld a, (input_size) 
1152				;ld b, a 
1152 21 8a fd			ld hl, input_cursor 
1155 34				inc (hl) 
1156				;dec b 
1156				;cp 0 
1156				;jp z, .inmain   ; ignore as at end of the string buffer 
1156				;ld a, b 
1156				;inc a 
1156				;ld (input_cursor), a 
1156 c3 31 10			jp .inmain 
1159			 
1159			 
1159			 
1159			input_disp_ref: 
1159				; display the text from start of buffer (ie full refresh) 
1159 3a 99 fd			ld a, (input_at_pos) 
115c 2a 9c fd			ld hl,(input_start) 
115f eb				ex de, hl 
1160 cd bd 0d			call str_at_display  
1163 c9				ret 
1164			input_disp_oncur: 
1164				; display the text from cursor position to end of buffer 
1164				; TODO position start of string at cursor position on screen 
1164				; TODO draw from that point on 
1164 3a 8a fd			ld a, (input_cursor) 
1167 47				ld b, a 
1168 3a 99 fd			ld a, (input_at_pos) 
116b 80				add b 
116c 48				ld c, b     ; save a 
116d 78				ld a, b     ; inc string start for cursor 
116e 2a 9c fd			ld hl,(input_start) 
1171 cd de 0f			call addatohl 
1174 eb				ex de, hl 
1175 79				ld a, c 
1176 cd bd 0d			call str_at_display  
1179 c9				ret 
117a			 
117a			input_nxtw: 
117a				; Find next word 
117a c9				ret 
117b			 
117b			input_prvw: 
117b				; Find previous word 
117b c9				ret 
117c			 
117c			input_lenrem:   
117c				; Calculate the length of string remaining from current cursor 
117c				; position to end of buffer (exc null term) 
117c				 
117c 3a 8a fd			ld a, (input_cursor) 
117f 4f				ld c, a 
1180 3a 9b fd			ld a, (input_size) 
1183 91				sub c 
1184 06 00			ld b, 0 
1186 0d				dec c 
1187 c9				ret	 
1188			 
1188			input_curptr: 
1188				; calc address of the character under the cursor 
1188				 
1188 2a 9c fd			ld hl, (input_start) 
118b 3a 8a fd			ld a, (input_cursor) 
118e cd de 0f			call addatohl 
1191 c9				ret 
1192			 
1192			input_inschr: 
1192				; Insert char at cursor position 
1192 f5				push af   ; save char 
1193				;call input_lenrem    ; get bc length of remaining string 
1193			 
1193				 
1193 cd 88 11			call input_curptr 
1196			;	ld hl, (input_start) 
1196			;	ld a, (input_cursor) 
1196			;	call addatohl 
1196				;push hl   ; save to come back to 
1196			 
1196				; shift everything up one to end of buffer 
1196			 
1196				;push hl 
1196				;dec de 
1196				;inc de 
1196			;	ldir 
1196				 
1196				;pop hl 
1196			 
1196				; are we adding to the end of line? 
1196			 
1196 3a 8a fd			ld a, (input_cursor) 
1199 47				ld b, a 
119a 3a 8f fd			ld a, (input_len) 
119d b8				cp b 
119e 20 09			jr nz, .insmid   ; no, insert in middle of text 
11a0			 
11a0				; tack on the end of the line 
11a0 f1				pop af 
11a1 77				ld (hl), a   ; save new char 
11a2 23				inc hl 
11a3 3e 00			ld a, 0 
11a5 77				ld (hl), a 
11a6 c3 52 11			jp input_right 
11a9				 
11a9			.insmid: 
11a9				; hl has insertion point so move everything up one to allow for insertion 
11a9				;call input_shiftright 
11a9 f1				pop af 
11aa			 
11aa			.shufinsmid: 
11aa 47				ld b, a     ; b contains new char, c prev char at this position  
11ab 7e				ld a, (hl) 
11ac			 
11ac fe 00			cp 0    ; at end of string need to then dump new char and add term 
11ae 28 07			jr z, .endinsmid 
11b0 4f				ld c, a 
11b1 78				ld a, b 
11b2 77				ld (hl), a 
11b3 23				inc hl 
11b4 79				ld a, c 
11b5 18 f3			jr .shufinsmid 
11b7				 
11b7			 
11b7			 
11b7			 
11b7			.endinsmid: 
11b7 78				ld a, b 
11b8 77				ld (hl), a 
11b9 23				inc hl 
11ba 3e 00			ld a, 0 
11bc 77				ld (hl), a 
11bd			 
11bd			 
11bd			;	ld (hl), a   ; save new char 
11bd			 
11bd c3 52 11			jp input_right 
11c0			 
11c0			;input_shiftright: 
11c0			;	; shift text right at cursor, hl has shift start 
11c0			;	push hl 
11c0			;	push de 
11c0			;	push bc 
11c0			; 
11c0			; 
11c0			;	; move to end of string past zero term 
11c0			;	ld hl,(input_start) 
11c0			;	ld a, (input_len) 
11c0			;	call addatohl 
11c0			;	inc hl 
11c0			;;	inc hl 
11c0			;;	inc hl 
11c0			;	ld a, 0 
11c0			;	ld (hl), a 
11c0			;;	dec hl 
11c0			;	 
11c0			;;	ld (hl), a 
11c0			;;	dec hl 
11c0			; 
11c0			;	push hl 
11c0			;	pop de 
11c0			;	inc de 
11c0			;	 
11c0			; 
11c0			;;	ld hl,(input_start) 
11c0			;;	ld a, (input_cursor) 
11c0			;;	call addatohl 
11c0			; 
11c0			; 
11c0			;	; calc how many bytes from cursor pos to end of string we need to shift 
11c0			;	call input_lenrem    ; get bc length of remaining string 
11c0			;	;ld a, (input_cursor) 
11c0			;	;ld c, a 
11c0			;	ld a, (input_len) 
11c0			;	cp 2 
11c0			;	jr z, .iskipzero	 
11c0			;	;sub c 
11c0			;	;inc a 
11c0			;	;ld c, a 
11c0			;	;ld b, 0 
11c0			;	inc c 
11c0			;	inc c 
11c0			;	; move data 
11c0			;	lddr 
11c0			;.iskipzero: 
11c0			; 
11c0			;	pop bc 
11c0			;	pop de 
11c0			;	pop hl 
11c0			;	ret	 
11c0			 
11c0			input_delchar: 
11c0				; Delete char at cursor position 
11c0 cd 7c 11			call input_lenrem    ; get bc length of remaining string 
11c3 2a 9c fd			ld hl, (input_start) 
11c6 3a 8a fd			ld a, (input_cursor) 
11c9 cd de 0f			call addatohl 
11cc			 
11cc e5				push hl 
11cd d1				pop de 
11ce 1b				dec de 
11cf			 
11cf			.dl:	 
11cf ed a0			ldi  
11d1 7e				ld a, (hl) 
11d2 fe 00			cp 0 
11d4 28 02			jr z, .dldone 
11d6 18 f7			jr .dl 
11d8			.dldone: 
11d8 ed a0			ldi 
11da			 
11da c3 4b 11			jp input_left 
11dd			 
11dd			 
11dd			endif 
11dd			 
11dd			 
11dd			 
11dd			if EDIT_V1 
11dd			input_str: 
11dd			 
11dd				    	ld (input_at_pos),a      ; save display position to start 
11dd					add c 
11dd					ld (input_at_cursor),a	; save draw pos of cursor 
11dd					ld (input_start), hl     ; save ptr to buffer 
11dd					ld a, c 
11dd					call addatohl 
11dd					ld (input_ptr), hl     ; save ptr to point under the cursor 
11dd					ld a,d 
11dd				        ld (input_size), a       ; save length of input area 
11dd					ld a, c 
11dd					ld (input_cursor),a      ; init cursor start position  
11dd					ld a,e 
11dd				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11dd					 
11dd					 
11dd			 
11dd			;		ld a,(input_ptr) 
11dd			;		ld (input_under_cursor),a 	; save what is under the cursor 
11dd			 
11dd			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11dd					; init cursor shape if not set by the cin routines 
11dd					ld hl, cursor_shape 
11dd			if BASE_KEV 
11dd					ld a, 255 
11dd			else 
11dd					ld a, '#' 
11dd			endif 
11dd					ld (hl), a 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl), a 
11dd			 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					ld a, 1 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'I' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd			.is1:		; main entry loop 
11dd			 
11dd			 
11dd			 
11dd					; pause 1ms 
11dd			 
11dd					ld a, 1 
11dd					call aDelayInMS 
11dd			 
11dd					; dec flash counter 
11dd					ld a, (input_cur_flash) 
11dd					dec a 
11dd					ld (input_cur_flash), a 
11dd					cp 0 
11dd					jr nz, .nochgstate 
11dd			 
11dd			 
11dd					; change state 
11dd					ld a,(input_cur_onoff) 
11dd					neg 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			 
11dd					; reset on change of state 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd			.nochgstate: 
11dd					 
11dd					 
11dd			 
11dd					; display cursor  
11dd			 
11dd			;		ld hl, (input_start) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			 
11dd					; get char under cursor and replace with cursor 
11dd			ld hl, (input_ptr) 
11dd			;		ld a, (hl) 
11dd			;		ld (input_under_cursor),a 
11dd			;		ld a, '_' 
11dd			;		ld (hl), a 
11dd			 
11dd					; display string 
11dd			 
11dd					ld de, (input_start) 
11dd					ld a, (input_at_pos) 
11dd					call str_at_display 
11dd			;	        call update_display 
11dd			 
11dd					; find place to put the cursor 
11dd			;		add h 
11dd			;		ld l, display_row_1 
11dd			;		sub l 
11dd			; (input_at_pos) 
11dd					;ld c, a 
11dd			;		ld a, (input_cursor) 
11dd			;		ld l, (input_at_pos) 
11dd			;		;ld b, h 
11dd			;		add l 
11dd			;		ld (input_at_cursor),a 
11dd					;ld l,h 
11dd			 
11dd			;		ld h, 0 
11dd			;		ld l,(input_at_pos) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11dd			;		call subafromhl 
11dd			;		ld a,l 
11dd			;		ld (input_at_cursor), a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					ld a, (hardware_diag) 
11dd					cp 0 
11dd					jr z, .skip_input_diag 
11dd			 
11dd					ld a,(input_at_pos) 
11dd					ld hl, LFSRSeed 
11dd					call hexout 
11dd					ld a, (input_cursor) 
11dd					ld hl, LFSRSeed+2 
11dd					call hexout 
11dd					ld a,(input_at_cursor) 
11dd					ld hl, LFSRSeed+4 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_onoff) 
11dd					ld hl, LFSRSeed+6 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_flash) 
11dd					ld hl, LFSRSeed+8 
11dd					call hexout 
11dd			 
11dd					ld a,(input_len) 
11dd					ld hl, LFSRSeed+10 
11dd					call hexout 
11dd					ld hl, LFSRSeed+12 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd					ld a, display_row_4 
11dd					ld de, LFSRSeed 
11dd					call str_at_display 
11dd					.skip_input_diag: 
11dd				endif 
11dd			 
11dd					; decide on if we are showing the cursor this time round 
11dd			 
11dd					ld a, (input_cur_onoff) 
11dd					cp 255 
11dd					jr z, .skipcur 
11dd			 
11dd			 
11dd					ld a,(input_at_cursor) 
11dd					ld de, cursor_shape 
11dd					call str_at_display 
11dd			 
11dd					; save length of current input string 
11dd					ld hl, (input_start) 
11dd					ld a, 0 
11dd					call strlent 
11dd					ld a,l 
11dd					ld (input_len),a 
11dd			 
11dd			.skipcur: 
11dd			 
11dd				        call update_display 
11dd					 
11dd			 
11dd			 
11dd					; wait 
11dd				 
11dd					; TODO loop without wait to flash the cursor and char under cursor	 
11dd					call cin    ; _wait 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 
11dd			 
11dd					; get ptr to char to input into 
11dd			 
11dd					ld c,a 
11dd					ld hl, (input_start) 
11dd					ld a, (input_cursor) 
11dd					call addatohl 
11dd					ld (input_ptr), hl 
11dd					ld a,c 
11dd			 
11dd					; replace char under cursor 
11dd			 
11dd			;		ld hl, (input_ptr) 
11dd			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11dd			;		ld (hl), a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'i' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					cp KEY_HOME 
11dd					jr nz, .iske 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor),a 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					jp .is1 
11dd					 
11dd			.iske:		cp KEY_END 
11dd					jr nz, .isknw 
11dd					jp .is1 
11dd			 
11dd			.isknw:		cp KEY_NEXTWORD 
11dd					jr nz, .iskpw 
11dd			 
11dd			.isknwm:	ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0 
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd					jr .isknwm 
11dd			 
11dd			.iskpw:		cp KEY_PREVWORD 
11dd					jr nz, .iskl 
11dd			.iskpwm:	 
11dd					ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0  
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd					jr .iskpwm 
11dd			 
11dd			 
11dd			.iskl:		cp KEY_LEFT 
11dd					jr nz, .isk1 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk1:		cp KEY_RIGHT 
11dd					jr nz, .isk2 
11dd			 
11dd					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11dd					ld e,a 
11dd					ld a, (input_cursor) 
11dd					cp e 
11dd					jp z, .is1		; at the end of string so dont go right 
11dd			 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk2:		cp KEY_UP 
11dd			 
11dd					jr nz, .isk3 
11dd			 
11dd					; swap last command with the current on 
11dd			 
11dd					; move cursor to start of string 
11dd					ld hl, (input_start) 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					 
11dd					; swap input and last command buffers 
11dd			 
11dd					ld hl, os_cli_cmd 
11dd					ld de, os_last_cmd 
11dd					ld b, 255 
11dd			.swap1:		ld a, (hl) 
11dd					ld c,a 
11dd					ld a, (de) 
11dd					ld (hl), a 
11dd					ld a,c 
11dd					ld (de),a 
11dd					inc hl 
11dd					inc de 
11dd					djnz .swap1 
11dd			 
11dd			 
11dd			 
11dd			 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk3:		cp KEY_BS 
11dd					jr nz, .isk4 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					; hl is source 
11dd					; de needs to be source - 1 
11dd			 
11dd			;		ld a, 0 
11dd			;		dec hl 
11dd			;		ld (hl), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					; shift all data 
11dd			 
11dd					push hl 
11dd					inc hl 
11dd					pop de 
11dd					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11dd					ld c,a 
11dd					ld b,0 
11dd					ldir  
11dd			 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					; remove char 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld de,.iblank 
11dd					call str_at_display 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk4:		cp KEY_CR 
11dd					jr z, .endinput 
11dd			 
11dd					; else add the key press to the end 
11dd			 
11dd					ld c, a			; save key pressed 
11dd			 
11dd					ld a,(hl)		; get what is currently under char 
11dd			 
11dd					cp 0			; we are at the end of the string 
11dd					jr nz, .onchar 
11dd					 
11dd					; add a char to the end of the string 
11dd				 
11dd					ld (hl),c 
11dd					inc hl 
11dd			;		ld a,' ' 
11dd			;		ld (hl),a 
11dd			;		inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					dec hl 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc a				; TODO check max string length and scroll  
11dd					ld (input_cursor), a		; inc cursor pos 
11dd							 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, '+' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					jp .is1 
11dd					 
11dd			 
11dd			 
11dd					; if on a char then insert 
11dd			.onchar: 
11dd			 
11dd					; TODO over flow check: make sure insert does not blow out buffer 
11dd			 
11dd					; need to do some maths to use lddr 
11dd			 
11dd					push hl   ; save char pos 
11dd					push bc 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a, (input_len) 
11dd					call addatohl  		; end of string 
11dd					inc hl 
11dd					inc hl		; past zero term 
11dd					push hl 
11dd					inc hl 
11dd					push hl  
11dd			 
11dd								; start and end of lddr set, now how much to move? 
11dd			 
11dd							 
11dd					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11dd					ld b,a 
11dd					ld a,(input_len) 
11dd					ld e,a 
11dd					sub b 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd			 
11dd					ld b,0 
11dd					ld c,a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'i' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					pop de 
11dd					pop hl 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'I' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					lddr 
11dd				 
11dd			 
11dd			 
11dd					; TODO have a key for insert/overwrite mode???? 
11dd					pop bc 
11dd					pop hl 
11dd					ld (hl), c		; otherwise overwrite current char 
11dd					 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.endinput:	; TODO look for end of string 
11dd			 
11dd					; add trailing space for end of token 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a,(input_len) 
11dd					call addatohl 
11dd					ld a, ' ' 
11dd					ld (hl),a 
11dd					; TODO eof of parse marker 
11dd			 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					ret 
11dd			 
11dd			.iblank: db " ",0 
11dd			 
11dd			 
11dd			input_str_prev:	ld (input_at_pos), a 
11dd					ld (input_start), hl 
11dd					ld a,1			; add cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					ld (input_ptr), hl 
11dd					ld a,d 
11dd					ld (input_size), a 
11dd					ld a,0 
11dd					ld (input_cursor),a 
11dd			.instr1:	 
11dd			 
11dd					; TODO do block cursor 
11dd					; TODO switch cursor depending on the modifer key 
11dd			 
11dd					; update cursor shape change on key hold 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl), a 
11dd			 
11dd					; display entered text 
11dd					ld a,(input_at_pos) 
11dd			            	CALL fLCD_Pos       ;Position cursor to location in A 
11dd			            	LD   de, (input_start) 
11dd			            	CALL fLCD_Str       ;Display string pointed to by DE 
11dd			 
11dd					call cin 
11dd					cp 0 
11dd					jr z, .instr1 
11dd			 
11dd					; proecess keyboard controls first 
11dd			 
11dd					ld hl,(input_ptr) 
11dd			 
11dd					cp KEY_CR	 ; pressing enter ends input 
11dd					jr z, .instrcr 
11dd			 
11dd					cp KEY_BS 	; back space 
11dd					jr nz, .instr2 
11dd					; process back space 
11dd			 
11dd					; TODO stop back space if at start of string 
11dd					dec hl 
11dd					dec hl ; to over write cursor 
11dd					ld a,(cursor_shape) 
11dd					;ld a,0 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a," " 
11dd					ld (hl),a 
11dd					ld (input_ptr),hl 
11dd					 
11dd			 
11dd					jr .instr1 
11dd			 
11dd			.instr2:	cp KEY_LEFT    ; cursor left 
11dd					jr nz, .instr3 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd				 
11dd			.instr3:	cp KEY_RIGHT      ; cursor right 
11dd					jr nz, .instr4 
11dd					inc hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr4:	cp KEY_HOME    ; jump to start of line 
11dd					jr nz, .instr5 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr5:	cp KEY_END     ; jump to end of line 
11dd					jr nz, .instr6 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			.instr6:        cp KEY_UP      ; recall last command 
11dd					jr nz, .instrnew 
11dd			 
11dd				ld hl, scratch 
11dd				ld de, os_last_cmd 
11dd				call strcpy 
11dd					jr .instr1 
11dd			 
11dd			 
11dd			.instrnew:	; no special key pressed to see if we have room to store it 
11dd			 
11dd					; TODO do string size test 
11dd			 
11dd					dec hl ; to over write cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd					ld (input_ptr),hl 
11dd					 
11dd					jr .instr1 
11dd			.instrcr:	dec hl		; remove cursor 
11dd					ld a,' '	; TODO add a trailing space for safety 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					; if at end of line scroll up    
11dd					; TODO detecting only end of line 4 for scroll up  
11dd			 
11dd					;ld   
11dd			 
11dd					ret 
11dd			 
11dd			 
11dd			endif 
11dd			; strcpy hl = dest, de source 
11dd			 
11dd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11de b7			            OR   A              ;Null terminator? 
11df c8			            RET  Z              ;Yes, so finished 
11e0 1a					ld a,(de) 
11e1 77					ld (hl),a 
11e2 13			            INC  DE             ;Point to next character 
11e3 23					inc hl 
11e4 18 f7		            JR   strcpy       ;Repeat 
11e6 c9					ret 
11e7			 
11e7			 
11e7			; TODO string_at  
11e7			; pass string which starts with lcd offset address and then null term string 
11e7			 
11e7			; TODO string to dec 
11e7			; TODO string to hex 
11e7			; TODO byte to string hex 
11e7			; TODO byte to string dec 
11e7			 
11e7			 
11e7			 
11e7			; from z80uartmonitor 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11e7			; pass hl for where to put the text 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7 c5			hexout:	PUSH BC 
11e8 f5					PUSH AF 
11e9 47					LD B, A 
11ea					; Upper nybble 
11ea cb 3f				SRL A 
11ec cb 3f				SRL A 
11ee cb 3f				SRL A 
11f0 cb 3f				SRL A 
11f2 cd 02 12				CALL tohex 
11f5 77					ld (hl),a 
11f6 23					inc hl	 
11f7					 
11f7					; Lower nybble 
11f7 78					LD A, B 
11f8 e6 0f				AND 0FH 
11fa cd 02 12				CALL tohex 
11fd 77					ld (hl),a 
11fe 23					inc hl	 
11ff					 
11ff f1					POP AF 
1200 c1					POP BC 
1201 c9					RET 
1202					 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			tohex: 
1202 e5					PUSH HL 
1203 d5					PUSH DE 
1204 16 00				LD D, 0 
1206 5f					LD E, A 
1207 21 0f 12				LD HL, .DATA 
120a 19					ADD HL, DE 
120b 7e					LD A, (HL) 
120c d1					POP DE 
120d e1					POP HL 
120e c9					RET 
120f			 
120f			.DATA: 
120f 30					DEFB	30h	; 0 
1210 31					DEFB	31h	; 1 
1211 32					DEFB	32h	; 2 
1212 33					DEFB	33h	; 3 
1213 34					DEFB	34h	; 4 
1214 35					DEFB	35h	; 5 
1215 36					DEFB	36h	; 6 
1216 37					DEFB	37h	; 7 
1217 38					DEFB	38h	; 8 
1218 39					DEFB	39h	; 9 
1219 41					DEFB	41h	; A 
121a 42					DEFB	42h	; B 
121b 43					DEFB	43h	; C 
121c 44					DEFB	44h	; D 
121d 45					DEFB	45h	; E 
121e 46					DEFB	46h	; F 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
121f			;;    subtract $30, if result > 9 then subtract $7 more 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			atohex: 
121f d6 30				SUB $30 
1221 fe 0a				CP 10 
1223 f8					RET M		; If result negative it was 0-9 so we're done 
1224 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1226 c9					RET		 
1227			 
1227			 
1227			 
1227			 
1227			; Get 2 ASCII characters as hex byte from pointer in hl 
1227			 
1227			BYTERD: 
1227 16 00			LD	D,00h		;Set up 
1229 cd 31 12			CALL	HEXCON		;Get byte and convert to hex 
122c 87				ADD	A,A		;First nibble so 
122d 87				ADD	A,A		;multiply by 16 
122e 87				ADD	A,A		; 
122f 87				ADD	A,A		; 
1230 57				LD	D,A		;Save hi nibble in D 
1231			HEXCON: 
1231 7e				ld a, (hl)		;Get next chr 
1232 23				inc hl 
1233 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1235 fe 0a			CP	00Ah		;Is it 0-9 ? 
1237 38 02			JR	C,NALPHA	;If so miss next bit 
1239 d6 07			SUB	007h		;Else convert alpha 
123b			NALPHA: 
123b b2				OR	D		;Add hi nibble back 
123c c9				RET			; 
123d			 
123d			 
123d			; 
123d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
123d			; Since the routines get_byte and therefore get_nibble are called, only valid 
123d			; characters (0-9a-f) are accepted. 
123d			; 
123d			;get_word        push    af 
123d			;                call    get_byte        ; Get the upper byte 
123d			;                ld      h, a 
123d			;                call    get_byte        ; Get the lower byte 
123d			;                ld      l, a 
123d			;                pop     af 
123d			;                ret 
123d			; 
123d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
123d			; the routine get_nibble is used only valid characters are accepted - the  
123d			; input routine only accepts characters 0-9a-f. 
123d			; 
123d c5			get_byte:        push    bc              ; Save contents of B (and C) 
123e 7e					ld a,(hl) 
123f 23					inc hl 
1240 cd 65 12		                call    nibble2val      ; Get upper nibble 
1243 cb 07		                rlc     a 
1245 cb 07		                rlc     a 
1247 cb 07		                rlc     a 
1249 cb 07		                rlc     a 
124b 47			                ld      b, a            ; Save upper four bits 
124c 7e					ld a,(hl) 
124d cd 65 12		                call    nibble2val      ; Get lower nibble 
1250 b0			                or      b               ; Combine both nibbles 
1251 c1			                pop     bc              ; Restore B (and C) 
1252 c9			                ret 
1253			; 
1253			; Get a hexadecimal digit from the serial line. This routine blocks until 
1253			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1253			; to the serial line interface. The lower 4 bits of A contain the value of  
1253			; that particular digit. 
1253			; 
1253			;get_nibble      ld a,(hl)           ; Read a character 
1253			;                call    to_upper        ; Convert to upper case 
1253			;                call    is_hex          ; Was it a hex digit? 
1253			;                jr      nc, get_nibble  ; No, get another character 
1253			 ;               call    nibble2val      ; Convert nibble to value 
1253			 ;               call    print_nibble 
1253			 ;               ret 
1253			; 
1253			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1253			; A valid hexadecimal digit is denoted by a set C flag. 
1253			; 
1253			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1253			;                ret     nc              ; Yes 
1253			;                cp      '0'             ; Less than '0'? 
1253			;                jr      nc, is_hex_1    ; No, continue 
1253			;                ccf                     ; Complement carry (i.e. clear it) 
1253			;                ret 
1253			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1253			;                ret     c               ; Yes 
1253			;                cp      'A'             ; Less than 'A'? 
1253			;                jr      nc, is_hex_2    ; No, continue 
1253			;                ccf                     ; Yes - clear carry and return 
1253			;                ret 
1253			;is_hex_2        scf                     ; Set carry 
1253			;                ret 
1253			; 
1253			; Convert a single character contained in A to upper case: 
1253			; 
1253 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1255 d8			                ret     c 
1256 fe 7b		                cp      'z' + 1         ; > 'z'? 
1258 d0			                ret     nc              ; Nothing to do, either 
1259 e6 5f		                and     $5f             ; Convert to upper case 
125b c9			                ret 
125c			 
125c			 
125c			to_lower: 
125c			 
125c			   ; if char is in [A-Z] make it lower case 
125c			 
125c			   ; enter : a = char 
125c			   ; exit  : a = lower case char 
125c			   ; uses  : af 
125c			 
125c fe 41		   cp 'A' 
125e d8			   ret c 
125f			    
125f fe 5b		   cp 'Z'+1 
1261 d0			   ret nc 
1262			    
1262 f6 20		   or $20 
1264 c9			   ret 
1265			 
1265			; 
1265			; Expects a hexadecimal digit (upper case!) in A and returns the 
1265			; corresponding value in A. 
1265			; 
1265 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1267 38 02		                jr      c, nibble2val_1 ; Yes 
1269 d6 07		                sub     7               ; Adjust for A-F 
126b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
126d e6 0f		                and     $f              ; Only return lower 4 bits 
126f c9			                ret 
1270			; 
1270			; Print_nibble prints a single hex nibble which is contained in the lower  
1270			; four bits of A: 
1270			; 
1270			;print_nibble    push    af              ; We won't destroy the contents of A 
1270			;                and     $f              ; Just in case... 
1270			;                add     a, '0'             ; If we have a digit we are done here. 
1270			;                cp      '9' + 1         ; Is the result > 9? 
1270			;                jr      c, print_nibble_1 
1270			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1270			;print_nibble_1  call    putc            ; Print the nibble and 
1270			;                pop     af              ; restore the original value of A 
1270			;                ret 
1270			;; 
1270			;; Send a CR/LF pair: 
1270			; 
1270			;crlf            push    af 
1270			;                ld      a, cr 
1270			;                call    putc 
1270			;                ld      a, lf 
1270			;                call    putc 
1270			;                pop     af 
1270			;                ret 
1270			; 
1270			; Print_word prints the four hex digits of a word to the serial line. The  
1270			; word is expected to be in HL. 
1270			; 
1270			;print_word      push    hl 
1270			;                push    af 
1270			;                ld      a, h 
1270			;                call    print_byte 
1270			;                ld      a, l 
1270			;                call    print_byte 
1270			;                pop     af 
1270			;                pop     hl 
1270			;                ret 
1270			; 
1270			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1270			; The byte to be printed is expected to be in A. 
1270			; 
1270			;print_byte      push    af              ; Save the contents of the registers 
1270			;                push    bc 
1270			;                ld      b, a 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                call    print_nibble    ; Print high nibble 
1270			;                ld      a, b 
1270			;                call    print_nibble    ; Print low nibble 
1270			;                pop     bc              ; Restore original register contents 
1270			;                pop     af 
1270			;                ret 
1270			 
1270			 
1270			 
1270			 
1270			 
1270			fourehexhl:  
1270 7e				ld a,(hl) 
1271 cd 1f 12			call atohex 
1274 cb 3f				SRL A 
1276 cb 3f				SRL A 
1278 cb 3f				SRL A 
127a cb 3f				SRL A 
127c 47				ld b, a 
127d 23				inc hl 
127e 7e				ld a,(hl) 
127f 23				inc hl 
1280 cd 1f 12			call atohex 
1283 80				add b 
1284 57				ld d,a 
1285 7e				ld a,(hl) 
1286 cd 1f 12			call atohex 
1289 cb 3f				SRL A 
128b cb 3f				SRL A 
128d cb 3f				SRL A 
128f cb 3f				SRL A 
1291 47				ld b, a 
1292 23				inc hl 
1293 7e				ld a,(hl) 
1294 23				inc hl 
1295 cd 1f 12			call atohex 
1298 80				add b 
1299 5f				ld e, a 
129a d5				push de 
129b e1				pop hl 
129c c9				ret 
129d			 
129d			; pass hl. returns z set if the byte at hl is a digit 
129d			;isdigithl:  
129d			;	push bc 
129d			;	ld a,(hl) 
129d			;	cp ':' 
129d			;	jr nc, .isdf 		; > 
129d			;	cp '0' 
129d			;	jr c, .isdf		; < 
129d			; 
129d			;	; TODO find a better way to set z 
129d			; 
129d			;	ld b,a 
129d			;	cp b 
129d			;	pop bc 
129d			;	ret 
129d			; 
129d			;.isdf:	; not digit so clear z 
129d			; 
129d			;	; TODO find a better way to unset z 
129d			; 
129d			;	ld b,a 
129d			;	inc b 
129d			;	cp b 
129d			; 
129d			;	pop bc 
129d			;	ret 
129d				 
129d				 
129d			 
129d			 
129d			; pass hl as the four byte address to load 
129d			 
129d			get_word_hl:  
129d e5				push hl 
129e cd 3d 12			call get_byte 
12a1				 
12a1 47				ld b, a 
12a2			 
12a2 e1				pop hl 
12a3 23				inc hl 
12a4 23				inc hl 
12a5			 
12a5			; TODO not able to handle a-f  
12a5 7e				ld a,(hl) 
12a6			;	;cp ':' 
12a6			;	cp 'g' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp 'G' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp '0' 
12a6			;	jr c, .single_byte_hl		; < 
12a6			 
12a6				;call isdigithl 
12a6 fe 00			cp 0 
12a8 28 06			jr z, .single_byte_hl 
12aa			 
12aa			.getwhln:   ; hex word so get next byte 
12aa			 
12aa cd 3d 12			call get_byte 
12ad 6f				ld l, a 
12ae 60				ld h,b 
12af c9				ret 
12b0 68			.single_byte_hl:   ld l,b 
12b1 26 00				ld h,0 
12b3 c9					ret 
12b4			 
12b4			 
12b4			 
12b4			 
12b4 21 21 1d			ld hl,asc+1 
12b7			;	ld a, (hl) 
12b7			;	call nibble2val 
12b7 cd 3d 12			call get_byte 
12ba			 
12ba			;	call fourehexhl 
12ba 32 2a f1			ld (scratch+52),a 
12bd				 
12bd 21 28 f1			ld hl,scratch+50 
12c0 22 19 f4			ld (os_cur_ptr),hl 
12c3			 
12c3 c9				ret 
12c4			 
12c4			 
12c4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12c4			 
12c4			; Decimal Unsigned Version 
12c4			 
12c4			;Number in a to decimal ASCII 
12c4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12c4			;Example: display a=56 as "056" 
12c4			;input: a = number 
12c4			;Output: a=0,value of a in the screen 
12c4			;destroys af,bc (don't know about hl and de) 
12c4			DispAToASCII: 
12c4 0e 9c			ld	c,-100 
12c6 cd d0 12			call	.Na1 
12c9 0e f6			ld	c,-10 
12cb cd d0 12			call	.Na1 
12ce 0e ff			ld	c,-1 
12d0 06 2f		.Na1:	ld	b,'0'-1 
12d2 04			.Na2:	inc	b 
12d3 81				add	a,c 
12d4 38 fc			jr	c,.Na2 
12d6 91				sub	c		;works as add 100/10/1 
12d7 f5				push af		;safer than ld c,a 
12d8 78				ld	a,b		;char is in b 
12d9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12d9 f1				pop af		;safer than ld a,c 
12da c9				ret 
12db			 
12db			; Decimal Signed Version 
12db			 
12db			; DispA 
12db			; -------------------------------------------------------------- 
12db			; Converts a signed integer value to a zero-terminated ASCII 
12db			; string representative of that value (using radix 10). 
12db			; -------------------------------------------------------------- 
12db			; INPUTS: 
12db			;     HL     Value to convert (two's complement integer). 
12db			;     DE     Base address of string destination. (pointer). 
12db			; -------------------------------------------------------------- 
12db			; OUTPUTS: 
12db			;     None 
12db			; -------------------------------------------------------------- 
12db			; REGISTERS/MEMORY DESTROYED 
12db			; AF HL 
12db			; -------------------------------------------------------------- 
12db			 
12db			;DispHLToASCII: 
12db			;   push    de 
12db			;   push    bc 
12db			; 
12db			;; Detect sign of HL. 
12db			;    bit    7, h 
12db			;    jr     z, ._DoConvert 
12db			; 
12db			;; HL is negative. Output '-' to string and negate HL. 
12db			;    ld     a, '-' 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			; 
12db			;; Negate HL (using two's complement) 
12db			;    xor    a 
12db			;    sub    l 
12db			;    ld     l, a 
12db			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12db			;    sbc    a, h 
12db			;    ld     h, a 
12db			; 
12db			;; Convert HL to digit characters 
12db			;._DoConvert: 
12db			;    ld     b, 0     ; B will count character length of number 
12db			;-   ld     a, 10 
12db			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12db			;    push   af 
12db			;    inc    b 
12db			;    ld     a, h 
12db			;    or     l 
12db			;    jr     nz, - 
12db			; 
12db			;; Retrieve digits from stack 
12db			;-   pop    af 
12db			;    or     $30 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			;    djnz   - 
12db			; 
12db			;; Terminate string with NULL 
12db			;    xor    a 
12db			;    ld     (de), a 
12db			; 
12db			;    pop    bc 
12db			;    pop    de 
12db			;    ret 
12db			 
12db			;Comments 
12db			; 
12db			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12db			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12db			;    Note that the output string will not be fixed-width. 
12db			; 
12db			;Example Usage 
12db			; 
12db			;    ld    hl, -1004 
12db			;    ld    de, OP1 
12db			;    call  DispA 
12db			;    ld    hl, OP1 
12db			;    syscall  PutS 
12db			 
12db			 
12db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12db			 
12db			 
12db			;Converts an ASCII string to an unsigned 16-bit integer 
12db			;Quits when it reaches a non-decimal digit 
12db			 
12db			string_to_uint16: 
12db			atoui_16: 
12db			;Input: 
12db			;     DE points to the string 
12db			;Outputs: 
12db			;     HL is the result 
12db			;     A is the 8-bit value of the number 
12db			;     DE points to the byte after the number 
12db			;Destroys: 
12db			;     BC 
12db			;       if the string is non-empty, BC is HL/10 
12db			;Size:  24 bytes 
12db			;Speed: 42+d(104+{0,9}) 
12db			;       d is the number of digits in the number 
12db			;       max is 640 cycles for a 5 digit number 
12db			;Assuming no leading zeros: 
12db			;1 digit:  146cc 
12db			;2 digit:  250cc 
12db			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12db			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12db			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12db			;avg: 544.81158447265625cc (544+13297/16384) 
12db			;=============================================================== 
12db 21 00 00		  ld hl,0 
12de			.u16a: 
12de 1a			  ld a,(de) 
12df d6 30		  sub 30h 
12e1 fe 0a		  cp 10 
12e3 d0			  ret nc 
12e4 13			  inc de 
12e5 44			  ld b,h 
12e6 4d			  ld c,l 
12e7 29			  add hl,hl 
12e8 29			  add hl,hl 
12e9 09			  add hl,bc 
12ea 29			  add hl,hl 
12eb 85			  add a,l 
12ec 6f			  ld l,a 
12ed 30 ef		  jr nc,.u16a 
12ef 24			  inc h 
12f0 c3 de 12		  jp .u16a 
12f3			 
12f3			 
12f3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f3			 
12f3			;written by Zeda 
12f3			;Converts a 16-bit unsigned integer to an ASCII string. 
12f3			 
12f3			uitoa_16: 
12f3			;Input: 
12f3			;   DE is the number to convert 
12f3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12f3			;Output: 
12f3			;   HL points to the null-terminated ASCII string 
12f3			;      NOTE: This isn't necessarily the same as the input HL. 
12f3 d5			  push de 
12f4 c5			  push bc 
12f5 f5			  push af 
12f6 eb			  ex de,hl 
12f7			 
12f7 01 f0 d8		  ld bc,-10000 
12fa 3e 2f		  ld a,'0'-1 
12fc 3c			  inc a 
12fd 09			  add hl,bc  
12fe 38 fc		   jr c,$-2 
1300 12			  ld (de),a 
1301 13			  inc de 
1302			 
1302 01 e8 03		  ld bc,1000 
1305 3e 3a		  ld a,'9'+1 
1307 3d			  dec a  
1308 09			  add hl,bc  
1309 30 fc		   jr nc,$-2 
130b 12			  ld (de),a 
130c 13			  inc de 
130d			 
130d 01 9c ff		  ld bc,-100 
1310 3e 2f		  ld a,'0'-1 
1312 3c			  inc a  
1313 09			  add hl,bc  
1314 38 fc		   jr c,$-2 
1316 12			  ld (de),a 
1317 13			  inc de 
1318			 
1318 7d			  ld a,l 
1319 26 3a		  ld h,'9'+1 
131b 25			  dec h  
131c c6 0a		  add a,10  
131e 30 fb		   jr nc,$-3 
1320 c6 30		  add a,'0' 
1322 eb			  ex de,hl 
1323 72			  ld (hl),d 
1324 23			  inc hl 
1325 77			  ld (hl),a 
1326 23			  inc hl 
1327 36 00		  ld (hl),0 
1329			 
1329			;Now strip the leading zeros 
1329 0e fa		  ld c,-6 
132b 09			  add hl,bc 
132c 3e 30		  ld a,'0' 
132e 23			  inc hl  
132f be			  cp (hl)  
1330 28 fc		  jr z,$-2 
1332			 
1332			;Make sure that the string is non-empty! 
1332 7e			  ld a,(hl) 
1333 b7			  or a 
1334 20 01		  jr nz,.atoub 
1336 2b			  dec hl 
1337			.atoub: 
1337			 
1337 f1			  pop af 
1338 c1			  pop bc 
1339 d1			  pop de 
133a c9			  ret 
133b			 
133b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
133b			 
133b			toUpper: 
133b			;A is the char. 
133b			;If A is a lowercase letter, this sets it to the matching uppercase 
133b			;18cc or 30cc or 41cc 
133b			;avg: 26.75cc 
133b fe 61		  cp 'a' 
133d d8			  ret c 
133e fe 7b		  cp 'z'+1 
1340 d0			  ret nc 
1341 d6 20		  sub 'a'-'A' 
1343 c9			  ret 
1344			 
1344			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1344			 
1344			; String Length 
1344			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1344			 
1344			; Get the length of the null-terminated string starting at $8000 hl 
1344			;    LD     HL, $8000 
1344			 
1344			strlenz: 
1344			 
1344 af			    XOR    A               ; Zero is the value we are looking for. 
1345 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1346 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1347			                           ; 65, 536 bytes (the entire addressable memory space). 
1347 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1349			 
1349			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1349 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
134a 6f			    LD     L, A             ; number of bytes 
134b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
134d 2b			    DEC    HL              ; Compensate for null. 
134e c9				ret 
134f			 
134f			; Get the length of the A terminated string starting at $8000 hl 
134f			;    LD     HL, $8000 
134f			 
134f			strlent: 
134f			 
134f			                  ; A is the value we are looking for. 
134f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1351 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1353			                           ; 65, 536 bytes (the entire addressable memory space). 
1353 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1355			 
1355			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1355 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1357 2e 00		    LD     L, 0             ; number of bytes 
1359 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
135b 2b			    DEC    HL              ; Compensate for null. 
135c c9				ret 
135d			 
135d			 
135d			;Comparing Strings 
135d			 
135d			;IN    HL     Address of string1. 
135d			;      DE     Address of string2. 
135d			 
135d			; doc given but wrong??? 
135d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
135d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
135d			; tested 
135d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
135d			 
135d			strcmp_old: 
135d e5			    PUSH   HL 
135e d5			    PUSH   DE 
135f			 
135f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1360 be			    CP     (HL)            ; (want to minimize work). 
1361 38 01		    JR     C, Str1IsBigger 
1363 7e			    LD     A, (HL) 
1364			 
1364			Str1IsBigger: 
1364 4f			    LD     C, A             ; Put length in BC 
1365 06 00		    LD     B, 0 
1367 13			    INC    DE              ; Increment pointers to meat of string. 
1368 23			    INC    HL 
1369			 
1369			CmpLoop: 
1369 1a			    LD     A, (DE)          ; Compare bytes. 
136a ed a1		    CPI 
136c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
136e 13			    INC    DE              ; Update pointer. 
136f ea 69 13		    JP     PE, CmpLoop 
1372			 
1372 d1			    POP    DE 
1373 e1			    POP    HL 
1374 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1375 be			    CP     (HL) 
1376 c9			    RET 
1377			 
1377			NoMatch: 
1377 2b			    DEC    HL 
1378 be			    CP     (HL)            ; Compare again to affect carry. 
1379 d1			    POP    DE 
137a e1			    POP    HL 
137b c9			    RET 
137c			 
137c			;; test strmp 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr z, .z1 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z1: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr z, .z2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr c, .c1 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c1: 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr c, .c2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;	NEXTW 
137c			;.str1:   db "string1",0 
137c			;.str2:   db "string2",0 
137c			 
137c			; only care about direct match or not 
137c			; hl and de strings 
137c			; zero set if the same 
137c			 
137c			strcmp: 
137c 1a				ld a, (de) 
137d be				cp (hl) 
137e 28 02			jr z, .ssame 
1380 b7				or a 
1381 c9				ret 
1382			 
1382			.ssame:  
1382 fe 00			cp 0 
1384 c8				ret z 
1385			 
1385 23				inc hl 
1386 13				inc de 
1387 18 f3			jr strcmp 
1389				 
1389				 
1389			 
1389			;Copyright (c) 2014, Luke Maurits 
1389			;All rights reserved. 
1389			; 
1389			;Redistribution and use in source and binary forms, with or without 
1389			;modification, are permitted provided that the following conditions are met: 
1389			; 
1389			;* Redistributions of source code must retain the above copyright notice, this 
1389			;  list of conditions and the following disclaimer. 
1389			; 
1389			;* Redistributions in binary form must reproduce the above copyright notice, 
1389			;  this list of conditions and the following disclaimer in the documentation 
1389			;  and/or other materials provided with the distribution. 
1389			; 
1389			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1389			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1389			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1389			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1389			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1389			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1389			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1389			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1389			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1389			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1389			 
1389			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1389			 
1389			StrictStrCmp: 
1389				; Load next chars of each string 
1389 1a				ld a, (de) 
138a 47				ld b, a 
138b 7e				ld a, (hl) 
138c				; Compare 
138c b8				cp b 
138d				; Return non-zero if chars don't match 
138d c0				ret nz 
138e				; Check for end of both strings 
138e fe 00			cp "\0" 
1390				; Return if strings have ended 
1390 c8				ret z 
1391				; Otherwise, advance to next chars 
1391 23				inc hl 
1392 13				inc de 
1393 18 f4			jr StrictStrCmp 
1395			 
1395			;end 
1395			; eof 
1395			 
1395			 
1395			 
1395			 
1395			 
1395			 
# End of file firmware_strings.asm
1395			include "firmware_memory.asm"   ; malloc and free  
1395			 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			.mallocsize: db "Wants malloc >256",0 
1395			.mallocasize: db "MALLOC gives >256",0 
1395			.malloczero: db "MALLOC gives zero",0 
1395			 
1395			malloc_guard_zerolen: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395				ld de, 0 
1395			        call cmp16 
1395				jr nz, .lowalloz 
1395			 
1395				push hl 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .malloczero 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395				call bp_on 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395			.lowalloz: 
1395			 
1395			 
1395				pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_entry: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowalloc 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocsize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395				jr .lowdone 
1395			.lowalloc: 
1395			 
1395			 
1395				pop hl 
1395			.lowdone:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_exit: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowallocx 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocasize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395				pop de 
1395				pop hl 
1395			 
1395				CALLMONITOR 
1395				jr .lowdonex 
1395			.lowallocx: 
1395			 
1395				pop hl 
1395			.lowdonex:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			endif 
1395			 
1395			if MALLOC_2 
1395			; Z80 Malloc and Free Functions 
1395			 
1395			; Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc: 
1395				 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_entry 
1395			endif 
1395			 
1395			 
1395			 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "mal" 
1395						CALLMONITOR 
1395					endif 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of size into A 
1395			    or h               ; Check if size is zero 
1395			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1395			 
1395			    ; Allocate memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma1" 
1395						CALLMONITOR 
1395					endif 
1395			    call malloc_internal ; Call internal malloc function 
1395			    pop af             ; Restore AF register 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret                ; Return 
1395			 
1395			; Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free: 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of pointer into A 
1395			    or h               ; Check if pointer is NULL 
1395			    jp z, free_exit    ; If pointer is NULL, exit 
1395			 
1395			    ; Free memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395			    call free_internal  ; Call internal free function 
1395			    pop af             ; Restore AF register 
1395			    ret                ; Return 
1395			 
1395			; Internal Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc_internal: 
1395			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to requested size 
1395			    ex de, hl          ; Save total size in DE, and keep it in HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			 
1395			    ; Search for free memory block 
1395			    ld de, (heap_end)  ; Load end of heap into DE 
1395			    ld bc, 0           ; Initialize counter 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			malloc_search_loop: 
1395			    ; Check if current block is free 
1395			    ld a, (hl)         ; Load current block's status (free or used) 
1395			    cp 0               ; Compare with zero (free) 
1395			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1395			 
1395			    ; Check if current block is large enough 
1395			    ld a, (hl+1)       ; Load high byte of block size 
1395			    cp l               ; Compare with low byte of requested size 
1395			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1395			 
1395			    ld a, (hl+2)       ; Load low byte of block size 
1395			    cp h               ; Compare with high byte of requested size 
1395			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1395			 
1395			    ; Mark block as used 
1395			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1395			 
1395			    ; Calculate remaining space in block 
1395			    ld bc, 0           ; Clear BC 
1395			    add hl, bc         ; Increment HL to point to start of data block 
1395			    add hl, de         ; HL = HL + DE (total size) 
1395			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to start of data block 
1395			 
1395			    ; Save pointer to allocated block in HL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma5" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			malloc_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3           ; Size of management overhead 
1395			    add hl, bc         ; Move to the next block 
1395			    inc de             ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e            ; Load low byte of heap end address 
1395			    cp (hl)            ; Compare with low byte of current address 
1395			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1395			    ld a, d            ; Load high byte of heap end address 
1395			    cp 0               ; Check if it's zero (end of memory) 
1395			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, allocation failed 
1395			    xor a              ; Set result to NULL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma6" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			malloc_exit: 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma7" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			; Internal Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free_internal: 
1395			    ld de, (heap_start) ; Load start of heap into DE 
1395			    ld bc, 0            ; Initialize counter 
1395			 
1395			free_search_loop: 
1395			    ; Check if current block contains the pointer 
1395			    ld a, l             ; Load low byte of pointer 
1395			    cp (hl+1)           ; Compare with high byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			    ld a, h             ; Load high byte of pointer 
1395			    cp (hl+2)           ; Compare with low byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			 
1395			    ; Mark block as free 
1395			    ld (hl), 0          ; Set status byte to indicate free block 
1395			    ret                 ; Return 
1395			 
1395			free_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3            ; Size of management overhead 
1395			    add hl, bc          ; Move to the next block 
1395			    inc de              ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e             ; Load low byte of heap end address 
1395			    cp (hl)             ; Compare with low byte of current address 
1395			    jr nz, free_search_loop  ; If not equal, continue searching 
1395			    ld a, d             ; Load high byte of heap end address 
1395			    cp 0                ; Check if it's zero (end of memory) 
1395			    jr nz, free_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, pointer is not found in heap 
1395			    ret 
1395			 
1395			free_exit: 
1395			    ret                 ; Return 
1395			 
1395			; Define heap start and end addresses 
1395			;heap_start:    .dw 0xC000   ; Start of heap 
1395			;heap_end:      .dw 0xE000   ; End of heap 
1395			 
1395			endif 
1395			 
1395			 
1395			if MALLOC_1 
1395			 
1395			 
1395			 
1395			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1395			 
1395			;moved to firmware.asm 
1395			;heap_start        .equ  0x9000      ; Starting address of heap 
1395			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1395			 
1395			;      .org 0 
1395			;      jp    main 
1395			 
1395			 
1395			;      .org  0x100 
1395			;main: 
1395			;      ld    HL, 0x8100 
1395			;      ld    SP, HL 
1395			; 
1395			;      call  heap_init 
1395			; 
1395			;      ; Make some allocations 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9004 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9014 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9024 
1395			; 
1395			;      ; Free some allocations 
1395			;      ld    HL, 0x9014 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9004 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9024 
1395			;      call  free 
1395			; 
1395			; 
1395			;      halt 
1395			 
1395			 
1395			;------------------------------------------------------------------------------ 
1395			;     heap_init                                                               : 
1395			;                                                                             : 
1395			; Description                                                                 : 
1395			;     Initialise the heap and make it ready for malloc and free operations.   : 
1395			;                                                                             : 
1395			;     The heap is maintained as a linked list, starting with an initial       : 
1395			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1395			;     the first free block in the heap. Each block then points to the next    : 
1395			;     free block within the heap, and the free list ends at the first block   : 
1395			;     with a null pointer to the next free block.                             : 
1395			;                                                                             : 
1395			; Parameters                                                                  : 
1395			;     Inputs are compile-time only. Two defines which specify the starting    : 
1395			;     address of the heap and its size are required, along with a memory      : 
1395			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1395			;     principally stores a pointer to the first free block in the heap.       : 
1395			;                                                                             : 
1395			; Returns                                                                     : 
1395			;     Nothing                                                                 : 
1395			;------------------------------------------------------------------------------ 
1395			heap_init: 
1395 e5			      push  HL 
1396			 
1396			      ; Initialise free list struct 
1396 21 0e 80		      ld    HL, heap_start 
1399 22 0a 80		      ld    (free_list), HL 
139c 21 00 00		      ld    HL, 0 
139f 22 0c 80		      ld    (free_list+2), HL 
13a2			 
13a2			      ; Insert first free block at bottom of heap, consumes entire heap 
13a2 21 cd f0		      ld    HL, heap_start+heap_size-4 
13a5 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13a8 21 bf 70		      ld    HL, heap_size-4 
13ab 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13ae			 
13ae			      ; Insert end of free list block at top of heap - two null words will 
13ae			      ; terminate the free list 
13ae 21 00 00		      ld    HL, 0 
13b1 22 cf f0		      ld    (heap_start+heap_size-2), HL 
13b4 22 cd f0		      ld    (heap_start+heap_size-4), HL 
13b7			 
13b7 e1			      pop   HL 
13b8			 
13b8 c9			      ret 
13b9			 
13b9			 
13b9			;------------------------------------------------------------------------------ 
13b9			;     malloc                                                                  : 
13b9			;                                                                             : 
13b9			; Description                                                                 : 
13b9			;     Allocates the wanted space from the heap and returns the address of the : 
13b9			;     first useable byte of the allocation.                                   : 
13b9			;                                                                             : 
13b9			;     Allocations can happen in one of two ways:                              : 
13b9			;                                                                             : 
13b9			;     1. A free block may be found which is the exact size wanted. In this    : 
13b9			;        case the block is removed from the free list and retuedn to the      : 
13b9			;        caller.                                                              : 
13b9			;     2. A free block may be found which is larger than the size wanted. In   : 
13b9			;        this case, the larger block is split into two. The first portion of  : 
13b9			;        this block will become the requested space by the malloc call and    : 
13b9			;        is returned to the caller. The second portion becomes a new free     : 
13b9			;        block, and the free list is adjusted to maintain continuity via this : 
13b9			;        newly created block.                                                 : 
13b9			;                                                                             : 
13b9			;     malloc does not set any initial value in the allocated space, the       : 
13b9			;     caller is required to do this as required.                              : 
13b9			;                                                                             : 
13b9			;     This implementation of malloc uses the stack exclusively, and is        : 
13b9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13b9			;     advisable to disable interrupts before calling malloc, and recommended  : 
13b9			;     to avoid the use of malloc inside ISRs in general.                      : 
13b9			;                                                                             : 
13b9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13b9			;                                                                             : 
13b9			; Parameters                                                                  : 
13b9			;     HL  Number of bytes wanted                                              : 
13b9			;                                                                             : 
13b9			; Returns                                                                     : 
13b9			;     HL  Address of the first useable byte of the allocation                 : 
13b9			;                                                                             : 
13b9			; Flags                                                                       : 
13b9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13b9			;                                                                             : 
13b9			; Stack frame                                                                 : 
13b9			;       |             |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     BC      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     DE      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     IX      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |  prev_free  |                                                       : 
13b9			;   +4  +-------------+                                                       : 
13b9			;       |  this_free  |                                                       : 
13b9			;   +2  +-------------+                                                       : 
13b9			;       |  next_free  |                                                       : 
13b9			;   +0  +-------------+                                                       : 
13b9			;       |             |                                                       : 
13b9			;                                                                             : 
13b9			;------------------------------------------------------------------------------ 
13b9			 
13b9			 
13b9			;malloc: 
13b9			; 
13b9			;	SAVESP ON 1 
13b9			; 
13b9			;	call malloc_code 
13b9			; 
13b9			;	CHECKSP ON 1 
13b9			;	ret 
13b9			 
13b9			 
13b9			malloc: 
13b9 c5			      push  BC 
13ba d5			      push  DE 
13bb dd e5		      push  IX 
13bd			if DEBUG_FORTH_MALLOC_HIGH 
13bd			call malloc_guard_entry 
13bd			endif 
13bd			 
13bd					if DEBUG_FORTH_MALLOC 
13bd						DMARK "mal" 
13bd						CALLMONITOR 
13bd					endif 
13bd 7c			      ld    A, H                    ; Exit if no space requested 
13be b5			      or    L 
13bf ca 7e 14		      jp    Z, malloc_early_exit 
13c2			 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			; 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			 
13c2			 
13c2			 
13c2			 
13c2					if DEBUG_FORTH_MALLOC 
13c2						DMARK "maA" 
13c2						CALLMONITOR 
13c2					endif 
13c2			      ; Set up stack frame 
13c2 eb			      ex    DE, HL 
13c3 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13c6 39			      add   HL, SP 
13c7 f9			      ld    SP, HL 
13c8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13cc dd 39		      add   IX, SP 
13ce			 
13ce			      ; Setup initial state 
13ce 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13d1 19			      add   HL, DE 
13d2			 
13d2 44			      ld    B, H                    ; Move want to BC 
13d3 4d			      ld    C, L 
13d4			 
13d4 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13d7 dd 75 04		      ld    (IX+4), L 
13da dd 74 05		      ld    (IX+5), H 
13dd			 
13dd 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13de 23			      inc   HL 
13df 56			      ld    D, (HL) 
13e0 dd 73 02		      ld    (IX+2), E 
13e3 dd 72 03		      ld    (IX+3), D 
13e6 eb			      ex    DE, HL                  ; this_free ptr into HL 
13e7			 
13e7					if DEBUG_FORTH_MALLOC 
13e7						DMARK "maB" 
13e7						CALLMONITOR 
13e7					endif 
13e7			      ; Loop through free block list to find some space 
13e7			malloc_find_space: 
13e7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13e8 23			      inc   HL 
13e9 56			      ld    D, (HL) 
13ea			 
13ea 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13eb b3			      or    E 
13ec ca 78 14		      jp    Z, malloc_no_space 
13ef			 
13ef dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13f2 dd 72 01		      ld    (IX+1), D 
13f5			 
13f5			      ; Does this block have enough space to make the allocation? 
13f5 23			      inc   HL                      ; Load free block size into DE 
13f6 5e			      ld    E, (HL) 
13f7 23			      inc   HL 
13f8 56			      ld    D, (HL) 
13f9			 
13f9 eb			      ex    DE, HL                  ; Check size of block against want 
13fa b7			      or    A                       ; Ensure carry flag clear 
13fb ed 42		      sbc   HL, BC 
13fd e5			      push  HL                      ; Store the result for later (new block size) 
13fe			 
13fe ca 4d 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1401 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1403			 
1403			      ; this_free block is not big enough, setup ptrs to test next free block 
1403 e1			      pop   HL                      ; Discard previous result 
1404			 
1404 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1407 dd 66 03		      ld    H, (IX+3) 
140a dd 75 04		      ld    (IX+4), L 
140d dd 74 05		      ld    (IX+5), H 
1410			 
1410 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1413 dd 66 01		      ld    H, (IX+1) 
1416 dd 75 02		      ld    (IX+2), L 
1419 dd 74 03		      ld    (IX+3), H 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "MA>" 
141c						CALLMONITOR 
141c					endif 
141c 18 c9		      jr    malloc_find_space 
141e			 
141e			      ; split a bigger block into two - requested size and remaining size 
141e			malloc_alloc_split: 
141e					if DEBUG_FORTH_MALLOC 
141e						DMARK "MAs" 
141e						CALLMONITOR 
141e					endif 
141e eb			      ex    DE, HL                  ; Calculate address of new free block 
141f 2b			      dec   HL 
1420 2b			      dec   HL 
1421 2b			      dec   HL 
1422 09			      add   HL, BC 
1423			 
1423			      ; Create a new block and point it at next_free 
1423 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1426 dd 56 01		      ld    D, (IX+1) 
1429			 
1429 73			      ld    (HL), E                 ; Store next_free ptr into new block 
142a 23			      inc   HL 
142b 72			      ld    (HL), D 
142c			 
142c d1			      pop   DE                      ; Store size of new block into new block 
142d 23			      inc   HL 
142e 73			      ld    (HL), E 
142f 23			      inc   HL 
1430 72			      ld    (HL), D 
1431			 
1431			      ; Update this_free ptr to point to new block 
1431 2b			      dec   HL 
1432 2b			      dec   HL 
1433 2b			      dec   HL 
1434			 
1434 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1437 dd 56 03		      ld    D, (IX+3) 
143a			 
143a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
143d dd 74 03		      ld    (IX+3), H 
1440			 
1440			      ; Modify this_free block to be allocation 
1440 eb			      ex    DE, HL 
1441 af			      xor   A                       ; Null the next block ptr of allocated block 
1442 77			      ld    (HL), A 
1443 23			      inc   HL 
1444 77			      ld    (HL), A 
1445			 
1445 23			      inc   HL                      ; Store want size into allocated block 
1446 71			      ld    (HL), C 
1447 23			      inc   HL 
1448 70			      ld    (HL), B 
1449 23			      inc   HL 
144a e5			      push  HL                      ; Address of allocation to return 
144b			 
144b 18 19		      jr    malloc_update_links 
144d			 
144d			malloc_alloc_fit: 
144d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
144e			 
144e					if DEBUG_FORTH_MALLOC 
144e						DMARK "MAf" 
144e						CALLMONITOR 
144e					endif 
144e			      ; Modify this_free block to be allocation 
144e eb			      ex    DE, HL 
144f 2b			      dec   HL 
1450 2b			      dec   HL 
1451 2b			      dec   HL 
1452			 
1452 af			      xor   A                       ; Null the next block ptr of allocated block 
1453 77			      ld    (HL), A 
1454 23			      inc   HL 
1455 77			      ld    (HL), A 
1456			 
1456 23			      inc   HL                      ; Store address of allocation to return 
1457 23			      inc   HL 
1458 23			      inc   HL 
1459 e5			      push  HL 
145a			 
145a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
145a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
145d dd 66 01		      ld    H, (IX+1) 
1460			 
1460 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1463 dd 74 03		      ld    (IX+3), H 
1466			 
1466			 
1466			malloc_update_links: 
1466			      ; Update prev_free ptr to point to this_free 
1466 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1469 dd 66 05		      ld    H, (IX+5) 
146c			 
146c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
146f dd 56 03		      ld    D, (IX+3) 
1472			 
1472 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1473 23			      inc   HL 
1474 72			      ld    (HL), D 
1475			 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "Mul" 
1475						CALLMONITOR 
1475					endif 
1475			      ; Clear the Z flag to indicate successful allocation 
1475 7a			      ld    A, D 
1476 b3			      or    E 
1477			 
1477 d1			      pop   DE                      ; Address of allocation 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAu" 
1478						CALLMONITOR 
1478					endif 
1478			 
1478			malloc_no_space: 
1478 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
147b 39			      add   HL, SP 
147c f9			      ld    SP, HL 
147d			 
147d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAN" 
147e						CALLMONITOR 
147e					endif 
147e			 
147e			malloc_early_exit: 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAx" 
147e						CALLMONITOR 
147e					endif 
147e dd e1		      pop   IX 
1480 d1			      pop   DE 
1481 c1			      pop   BC 
1482			 
1482			if DEBUG_FORTH_MALLOC_HIGH 
1482			call malloc_guard_exit 
1482			call malloc_guard_zerolen 
1482			endif 
1482 c9			      ret 
1483			 
1483			 
1483			;------------------------------------------------------------------------------ 
1483			;     free                                                                    : 
1483			;                                                                             : 
1483			; Description                                                                 : 
1483			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1483			;     returned by malloc, otherwise the behaviour is undefined.               : 
1483			;                                                                             : 
1483			;     Where possible, directly adjacent free blocks will be merged together   : 
1483			;     into larger blocks to help ensure that the heap does not become         : 
1483			;     excessively fragmented.                                                 : 
1483			;                                                                             : 
1483			;     free does not clear or set any other value into the freed space, and    : 
1483			;     therefore its contents may be visible through subsequent malloc's. The  : 
1483			;     caller should clear the freed space as required.                        : 
1483			;                                                                             : 
1483			;     This implementation of free uses the stack exclusively, and is          : 
1483			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1483			;     advisable to disable interrupts before calling free, and recommended    : 
1483			;     to avoid the use of free inside ISRs in general.                        : 
1483			;                                                                             : 
1483			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1483			;                                                                             : 
1483			; Parameters                                                                  : 
1483			;     HL  Pointer to address of first byte of allocation to be freed          : 
1483			;                                                                             : 
1483			; Returns                                                                     : 
1483			;     Nothing                                                                 : 
1483			;                                                                             : 
1483			; Stack frame                                                                 : 
1483			;       |             |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     BC      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     DE      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     IX      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |  prev_free  |                                                       : 
1483			;   +2  +-------------+                                                       : 
1483			;       |  next_free  |                                                       : 
1483			;   +0  +-------------+                                                       : 
1483			;       |             |                                                       : 
1483			;                                                                             : 
1483			;------------------------------------------------------------------------------ 
1483			free: 
1483 c5			      push  BC 
1484 d5			      push  DE 
1485 dd e5		      push  IX 
1487			 
1487 7c			      ld    A, H                    ; Exit if ptr is null 
1488 b5			      or    L 
1489 ca 4d 15		      jp    Z, free_early_exit 
148c			 
148c			      ; Set up stack frame 
148c eb			      ex    DE, HL 
148d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1490 39			      add   HL, SP 
1491 f9			      ld    SP, HL 
1492 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1496 dd 39		      add   IX, SP 
1498			 
1498			      ; The address in HL points to the start of the useable allocated space, 
1498			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1498			      ; address of the block itself. 
1498 eb			      ex    DE, HL 
1499 11 fc ff		      ld    DE, -4 
149c 19			      add   HL, DE 
149d			 
149d			      ; An allocated block must have a null next block pointer in it 
149d 7e			      ld    A, (HL) 
149e 23			      inc   HL 
149f b6			      or    (HL) 
14a0 c2 48 15		      jp    NZ, free_done 
14a3			 
14a3 2b			      dec   HL 
14a4			 
14a4 44			      ld    B, H                    ; Copy HL to BC 
14a5 4d			      ld    C, L 
14a6			 
14a6			      ; Loop through the free list to find the first block with an address 
14a6			      ; higher than the block being freed 
14a6 21 0a 80		      ld    HL, free_list 
14a9			 
14a9			free_find_higher_block: 
14a9 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14aa 23			      inc   HL 
14ab 56			      ld    D, (HL) 
14ac 2b			      dec   HL 
14ad			 
14ad dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14b0 dd 72 01		      ld    (IX+1), D 
14b3 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14b6 dd 74 03		      ld    (IX+3), H 
14b9			 
14b9 78			      ld    A, B                    ; Check if DE is greater than BC 
14ba ba			      cp    D                       ; Compare MSB first 
14bb 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14bd 30 04		      jr    NC, free_find_higher_block_skip 
14bf 79			      ld    A, C 
14c0 bb			      cp    E                       ; Then compare LSB 
14c1 38 08		      jr    C, free_found_higher_block 
14c3			 
14c3			free_find_higher_block_skip: 
14c3 7a			      ld    A, D                    ; Reached the end of the free list? 
14c4 b3			      or    E 
14c5 ca 48 15		      jp    Z, free_done 
14c8			 
14c8 eb			      ex    DE, HL 
14c9			 
14c9 18 de		      jr    free_find_higher_block 
14cb			 
14cb			free_found_higher_block: 
14cb			      ; Insert freed block between prev and next free blocks 
14cb 71			      ld    (HL), C                 ; Point prev free block to freed block 
14cc 23			      inc   HL 
14cd 70			      ld    (HL), B 
14ce			 
14ce 60			      ld    H, B                    ; Point freed block at next free block 
14cf 69			      ld    L, C 
14d0 73			      ld    (HL), E 
14d1 23			      inc   HL 
14d2 72			      ld    (HL), D 
14d3			 
14d3			      ; Check if the freed block is adjacent to the next free block 
14d3 23			      inc   HL                      ; Load size of freed block into HL 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7 eb			      ex    DE, HL 
14d8			 
14d8 09			      add   HL, BC                  ; Add addr of freed block and its size 
14d9			 
14d9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14dc dd 56 01		      ld    D, (IX+1) 
14df			 
14df b7			      or    A                       ; Clear the carry flag 
14e0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14e2 20 22		      jr    NZ, free_check_adjacent_to_prev 
14e4			 
14e4			      ; Freed block is adjacent to next, merge into one bigger block 
14e4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14e5 5e			      ld    E, (HL) 
14e6 23			      inc   HL 
14e7 56			      ld    D, (HL) 
14e8 e5			      push  HL                      ; Save ptr to next block for later 
14e9			 
14e9 60			      ld    H, B                    ; Store ptr from next block into freed block 
14ea 69			      ld    L, C 
14eb 73			      ld    (HL), E 
14ec 23			      inc   HL 
14ed 72			      ld    (HL), D 
14ee			 
14ee e1			      pop   HL                      ; Restore ptr to next block 
14ef 23			      inc   HL                      ; Load size of next block into DE 
14f0 5e			      ld    E, (HL) 
14f1 23			      inc   HL 
14f2 56			      ld    D, (HL) 
14f3 d5			      push  DE                      ; Save next block size for later 
14f4			 
14f4 60			      ld    H, B                    ; Load size of freed block into HL 
14f5 69			      ld    L, C 
14f6 23			      inc   HL 
14f7 23			      inc   HL 
14f8 5e			      ld    E, (HL) 
14f9 23			      inc   HL 
14fa 56			      ld    D, (HL) 
14fb eb			      ex    DE, HL 
14fc			 
14fc d1			      pop   DE                      ; Restore size of next block 
14fd 19			      add   HL, DE                  ; Add sizes of both blocks 
14fe eb			      ex    DE, HL 
14ff			 
14ff 60			      ld    H, B                    ; Store new bigger size into freed block 
1500 69			      ld    L, C 
1501 23			      inc   HL 
1502 23			      inc   HL 
1503 73			      ld    (HL), E 
1504 23			      inc   HL 
1505 72			      ld    (HL), D 
1506			 
1506			free_check_adjacent_to_prev: 
1506			      ; Check if the freed block is adjacent to the prev free block 
1506 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1509 dd 66 03		      ld    H, (IX+3) 
150c			 
150c 23			      inc   HL                      ; Size of prev free block into DE 
150d 23			      inc   HL 
150e 5e			      ld    E, (HL) 
150f 23			      inc   HL 
1510 56			      ld    D, (HL) 
1511 2b			      dec   HL 
1512 2b			      dec   HL 
1513 2b			      dec   HL 
1514			 
1514 19			      add   HL, DE                  ; Add prev block addr and size 
1515			 
1515 b7			      or    A                       ; Clear the carry flag 
1516 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1518 20 2e		      jr    NZ, free_done 
151a			 
151a			      ; Freed block is adjacent to prev, merge into one bigger block 
151a 60			      ld    H, B                    ; Load next ptr from freed block into DE 
151b 69			      ld    L, C 
151c 5e			      ld    E, (HL) 
151d 23			      inc   HL 
151e 56			      ld    D, (HL) 
151f e5			      push  HL                      ; Save freed block ptr for later 
1520			 
1520 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1523 dd 66 03		      ld    H, (IX+3) 
1526 73			      ld    (HL), E 
1527 23			      inc   HL 
1528 72			      ld    (HL), D 
1529			 
1529 e1			      pop   HL                      ; Restore freed block ptr 
152a 23			      inc   HL                      ; Load size of freed block into DE 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e d5			      push  DE                      ; Save freed block size for later 
152f			 
152f dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1532 dd 66 03		      ld    H, (IX+3) 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 5e			      ld    E, (HL) 
1538 23			      inc   HL 
1539 56			      ld    D, (HL) 
153a			 
153a e1			      pop   HL                      ; Add sizes of both blocks 
153b 19			      add   HL, DE 
153c eb			      ex    DE, HL 
153d			 
153d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1540 dd 66 03		      ld    H, (IX+3) 
1543 23			      inc   HL 
1544 23			      inc   HL 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548			free_done: 
1548 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
154b 39			      add   HL, SP 
154c f9			      ld    SP, HL 
154d			 
154d			free_early_exit: 
154d dd e1		      pop   IX 
154f d1			      pop   DE 
1550 c1			      pop   BC 
1551			 
1551 c9			      ret 
1552			 
1552			; moved to firmware.asm 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			;                  .dw   0 
1552			 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_3 
1552			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1552			;heap_start        .equ  0x9000      ; Starting address of heap 
1552			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1552			; 
1552			 ;     .org 0 
1552			  ;    jp    main 
1552			; 
1552			; 
1552			 ;     .org  0x100 
1552			;main: 
1552			 ;     ld    HL, 0x8100 
1552			  ;    ld    SP, HL 
1552			; 
1552			;      call  heap_init 
1552			 
1552			      ; Make some allocations 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9004 
1552			; 
1552			 ;     ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9014 
1552			 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9024 
1552			 
1552			      ; Free some allocations 
1552			;      ld    HL, 0x9014 
1552			;      call  free 
1552			 
1552			;      ld    HL, 0x9004 
1552			;      call  free 
1552			; 
1552			;      ld    HL, 0x9024 
1552			;      call  free 
1552			 
1552			 
1552			 ;     halt 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     heap_init                                                               : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Initialise the heap and make it ready for malloc and free operations.   : 
1552			;                                                                             : 
1552			;     The heap is maintained as a linked list, starting with an initial       : 
1552			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1552			;     the first free block in the heap. Each block then points to the next    : 
1552			;     free block within the heap, and the free list ends at the first block   : 
1552			;     with a null pointer to the next free block.                             : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     Inputs are compile-time only. Two defines which specify the starting    : 
1552			;     address of the heap and its size are required, along with a memory      : 
1552			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1552			;     principally stores a pointer to the first free block in the heap.       : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;------------------------------------------------------------------------------ 
1552			heap_init: 
1552			      push  HL 
1552			 
1552			      ; Initialise free list struct 
1552			      ld    HL, heap_start 
1552			      ld    (free_list), HL 
1552			      ld    HL, 0 
1552			      ld    (free_list+2), HL 
1552			 
1552			      ; Insert first free block at bottom of heap, consumes entire heap 
1552			      ld    HL, heap_start+heap_size-4 
1552			      ld    (heap_start), HL        ; Next block (end of free list) 
1552			      ld    HL, heap_size-4 
1552			      ld    (heap_start+2), HL      ; Block size 
1552			 
1552			      ; Insert end of free list block at top of heap - two null words will 
1552			      ; terminate the free list 
1552			      ld    HL, 0 
1552			      ld    (heap_start+heap_size-2), HL 
1552			      ld    (heap_start+heap_size-4), HL 
1552			 
1552			      pop   HL 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     malloc                                                                  : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Allocates the wanted space from the heap and returns the address of the : 
1552			;     first useable byte of the allocation.                                   : 
1552			;                                                                             : 
1552			;     Allocations can happen in one of two ways:                              : 
1552			;                                                                             : 
1552			;     1. A free block may be found which is the exact size wanted. In this    : 
1552			;        case the block is removed from the free list and retuedn to the      : 
1552			;        caller.                                                              : 
1552			;     2. A free block may be found which is larger than the size wanted. In   : 
1552			;        this case, the larger block is split into two. The first portion of  : 
1552			;        this block will become the requested space by the malloc call and    : 
1552			;        is returned to the caller. The second portion becomes a new free     : 
1552			;        block, and the free list is adjusted to maintain continuity via this : 
1552			;        newly created block.                                                 : 
1552			;                                                                             : 
1552			;     malloc does not set any initial value in the allocated space, the       : 
1552			;     caller is required to do this as required.                              : 
1552			;                                                                             : 
1552			;     This implementation of malloc uses the stack exclusively, and is        : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling malloc, and recommended  : 
1552			;     to avoid the use of malloc inside ISRs in general.                      : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Number of bytes wanted                                              : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     HL  Address of the first useable byte of the allocation                 : 
1552			;                                                                             : 
1552			; Flags                                                                       : 
1552			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +4  +-------------+                                                       : 
1552			;       |  this_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			malloc: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if no space requested 
1552			      or    L 
1552			      jp    Z, malloc_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; Setup initial state 
1552			      ld    HL, 4                   ; want must also include space used by block struct 
1552			      add   HL, DE 
1552			 
1552			      ld    B, H                    ; Move want to BC 
1552			      ld    C, L 
1552			 
1552			      ld    HL, free_list           ; Store prev_free ptr to stack 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    E, (HL)                 ; Store this_free ptr to stack 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ld    (IX+2), E 
1552			      ld    (IX+3), D 
1552			      ex    DE, HL                  ; this_free ptr into HL 
1552			 
1552			      ; Loop through free block list to find some space 
1552			malloc_find_space: 
1552			      ld    E, (HL)                 ; Load next_free ptr into DE 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1552			      or    E 
1552			      jp    Z, malloc_no_space 
1552			 
1552			      ld    (IX+0), E               ; Store next_free ptr to stack 
1552			      ld    (IX+1), D 
1552			 
1552			      ; Does this block have enough space to make the allocation? 
1552			      inc   HL                      ; Load free block size into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ex    DE, HL                  ; Check size of block against want 
1552			      or    A                       ; Ensure carry flag clear 
1552			      sbc   HL, BC 
1552			      push  HL                      ; Store the result for later (new block size) 
1552			 
1552			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1552			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1552			 
1552			      ; this_free block is not big enough, setup ptrs to test next free block 
1552			      pop   HL                      ; Discard previous result 
1552			 
1552			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1552			      ld    H, (IX+3) 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1552			      ld    H, (IX+1) 
1552			      ld    (IX+2), L 
1552			      ld    (IX+3), H 
1552			 
1552			      jr    malloc_find_space 
1552			 
1552			      ; split a bigger block into two - requested size and remaining size 
1552			malloc_alloc_split: 
1552			      ex    DE, HL                  ; Calculate address of new free block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      add   HL, BC 
1552			 
1552			      ; Create a new block and point it at next_free 
1552			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      ld    (HL), E                 ; Store next_free ptr into new block 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   DE                      ; Store size of new block into new block 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Update this_free ptr to point to new block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1552			      ld    (IX+3), H 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store want size into allocated block 
1552			      ld    (HL), C 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			      inc   HL 
1552			      push  HL                      ; Address of allocation to return 
1552			 
1552			      jr    malloc_update_links 
1552			 
1552			malloc_alloc_fit: 
1552			      pop   HL                      ; Dont need new block size, want is exact fit 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store address of allocation to return 
1552			      inc   HL 
1552			      inc   HL 
1552			      push  HL 
1552			 
1552			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1552			      ld    L, (IX+0)               ; next_free to HL 
1552			      ld    H, (IX+1) 
1552			 
1552			      ld    (IX+2), L               ; HL to this_free 
1552			      ld    (IX+3), H 
1552			 
1552			 
1552			malloc_update_links: 
1552			      ; Update prev_free ptr to point to this_free 
1552			      ld    L, (IX+4)               ; prev_free ptr to HL 
1552			      ld    H, (IX+5) 
1552			 
1552			      ld    E, (IX+2)               ; this_free ptr to DE 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (HL), E                 ; this_free ptr into prev_free 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Clear the Z flag to indicate successful allocation 
1552			      ld    A, D 
1552			      or    E 
1552			 
1552			      pop   DE                      ; Address of allocation 
1552			 
1552			malloc_no_space: 
1552			      ld    HL, 6                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			      ex    DE, HL                  ; Alloc addr into HL for return 
1552			 
1552			malloc_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     free                                                                    : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1552			;     returned by malloc, otherwise the behaviour is undefined.               : 
1552			;                                                                             : 
1552			;     Where possible, directly adjacent free blocks will be merged together   : 
1552			;     into larger blocks to help ensure that the heap does not become         : 
1552			;     excessively fragmented.                                                 : 
1552			;                                                                             : 
1552			;     free does not clear or set any other value into the freed space, and    : 
1552			;     therefore its contents may be visible through subsequent malloc's. The  : 
1552			;     caller should clear the freed space as required.                        : 
1552			;                                                                             : 
1552			;     This implementation of free uses the stack exclusively, and is          : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling free, and recommended    : 
1552			;     to avoid the use of free inside ISRs in general.                        : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Pointer to address of first byte of allocation to be freed          : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			free: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if ptr is null 
1552			      or    L 
1552			      jp    Z, free_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; The address in HL points to the start of the useable allocated space, 
1552			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1552			      ; address of the block itself. 
1552			      ex    DE, HL 
1552			      ld    DE, -4 
1552			      add   HL, DE 
1552			 
1552			      ; An allocated block must have a null next block pointer in it 
1552			      ld    A, (HL) 
1552			      inc   HL 
1552			      or    (HL) 
1552			      jp    NZ, free_done 
1552			 
1552			      dec   HL 
1552			 
1552			      ld    B, H                    ; Copy HL to BC 
1552			      ld    C, L 
1552			 
1552			      ; Loop through the free list to find the first block with an address 
1552			      ; higher than the block being freed 
1552			      ld    HL, free_list 
1552			 
1552			free_find_higher_block: 
1552			      ld    E, (HL)                 ; Load next ptr from free block 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			 
1552			      ld    (IX+0), E               ; Save ptr to next free block 
1552			      ld    (IX+1), D 
1552			      ld    (IX+2), L               ; Save ptr to prev free block 
1552			      ld    (IX+3), H 
1552			 
1552			      ld    A, B                    ; Check if DE is greater than BC 
1552			      cp    D                       ; Compare MSB first 
1552			      jr    Z, $+4                  ; MSB the same, compare LSB 
1552			      jr    NC, free_find_higher_block_skip 
1552			      ld    A, C 
1552			      cp    E                       ; Then compare LSB 
1552			      jr    C, free_found_higher_block 
1552			 
1552			free_find_higher_block_skip: 
1552			      ld    A, D                    ; Reached the end of the free list? 
1552			      or    E 
1552			      jp    Z, free_done 
1552			 
1552			      ex    DE, HL 
1552			 
1552			      jr    free_find_higher_block 
1552			 
1552			free_found_higher_block: 
1552			      ; Insert freed block between prev and next free blocks 
1552			      ld    (HL), C                 ; Point prev free block to freed block 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			 
1552			      ld    H, B                    ; Point freed block at next free block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Check if the freed block is adjacent to the next free block 
1552			      inc   HL                      ; Load size of freed block into HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      add   HL, BC                  ; Add addr of freed block and its size 
1552			 
1552			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_check_adjacent_to_prev 
1552			 
1552			      ; Freed block is adjacent to next, merge into one bigger block 
1552			      ex    DE, HL                  ; Load next ptr from next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save ptr to next block for later 
1552			 
1552			      ld    H, B                    ; Store ptr from next block into freed block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore ptr to next block 
1552			      inc   HL                      ; Load size of next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save next block size for later 
1552			 
1552			      ld    H, B                    ; Load size of freed block into HL 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      pop   DE                      ; Restore size of next block 
1552			      add   HL, DE                  ; Add sizes of both blocks 
1552			      ex    DE, HL 
1552			 
1552			      ld    H, B                    ; Store new bigger size into freed block 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_check_adjacent_to_prev: 
1552			      ; Check if the freed block is adjacent to the prev free block 
1552			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1552			      ld    H, (IX+3) 
1552			 
1552			      inc   HL                      ; Size of prev free block into DE 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      add   HL, DE                  ; Add prev block addr and size 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_done 
1552			 
1552			      ; Freed block is adjacent to prev, merge into one bigger block 
1552			      ld    H, B                    ; Load next ptr from freed block into DE 
1552			      ld    L, C 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save freed block ptr for later 
1552			 
1552			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1552			      ld    H, (IX+3) 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore freed block ptr 
1552			      inc   HL                      ; Load size of freed block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save freed block size for later 
1552			 
1552			      ld    L, (IX+2)               ; Load size of prev block into DE 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      pop   HL                      ; Add sizes of both blocks 
1552			      add   HL, DE 
1552			      ex    DE, HL 
1552			 
1552			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_done: 
1552			      ld    HL, 4                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			free_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;      .org 0x8000 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			 ;                 .dw   0 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_4 
1552			 
1552			; My memory allocation code. Very very simple.... 
1552			; allocate space under 250 chars 
1552			 
1552			heap_init: 
1552				; init start of heap as zero 
1552				;  
1552			 
1552				ld hl, heap_start 
1552				ld a, 0 
1552				ld (hl), a      ; empty block 
1552				inc hl 
1552				ld a, 0 
1552				ld (hl), a      ; length of block 
1552				; write end of list 
1552				inc hl 
1552				ld a,(hl) 
1552				inc hl 
1552				ld a,(hl) 
1552				 
1552			 
1552				; init some malloc vars 
1552			 
1552				ld hl, 0 
1552				ld (free_list), hl       ; store last malloc location 
1552			 
1552				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1552				ld a, 0 
1552				ld (hl), a 
1552			 
1552			 
1552				ld hl, heap_start 
1552				;  
1552				  
1552				ret 
1552			 
1552			 
1552			;    free block marker 
1552			;    requested size  
1552			;    pointer to next block 
1552			;    .... 
1552			;    next block marker 
1552			 
1552			 
1552			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1552			; 
1552			 
1552			 
1552			malloc:  
1552				push de 
1552				push bc 
1552				push af 
1552			 
1552				; hl space required 
1552				 
1552				ld c, l    ; hold space   (TODO only a max of 255) 
1552			 
1552			;	inc c     ; TODO BUG need to fix memory leak on push str 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			 
1552			 
1552			 
1552				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1552			 
1552				ld a, (free_list+3) 
1552				cp 0 
1552				jr z, .contheap 
1552			 
1552				ld hl, (free_list)     ; get last alloc 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mrs" 
1552						CALLMONITOR 
1552					endif 
1552				jr .startalloc 
1552			 
1552			.contheap: 
1552				ld hl, heap_start 
1552			 
1552			.startalloc: 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mym" 
1552						CALLMONITOR 
1552					endif 
1552			.findblock: 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmf" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552				ld a,(hl)  
1552				; if byte is zero then clear to use 
1552			 
1552				cp 0 
1552				jr z, .foundemptyblock 
1552			 
1552				; if byte is not clear 
1552				;     then byte is offset to next block 
1552			 
1552				inc hl 
1552				ld a, (hl) ; get size 
1552			.nextblock:	inc hl 
1552					ld e, (hl) 
1552					inc hl 
1552					ld d, (hl) 
1552					ex de, hl 
1552			;	inc hl  ; move past the store space 
1552			;	inc hl  ; move past zero index  
1552			 
1552				; TODO detect no more space 
1552			 
1552				push hl 
1552				ld de, heap_end 
1552				call cmp16 
1552				pop hl 
1552				jr nc, .nospace 
1552			 
1552				jr .findblock 
1552			 
1552			.nospace: ld hl, 0 
1552				jp .exit 
1552			 
1552			 
1552			.foundemptyblock:	 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mme" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; TODO has block enough space if reusing??? 
1552			 
1552				;  
1552			 
1552			; see if this block has been previously used 
1552				inc hl 
1552				ld a, (hl) 
1552				dec hl 
1552				cp 0 
1552				jr z, .newblock 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meR" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; no reusing previously allocated block 
1552			 
1552			; is it smaller than previously used? 
1552				 
1552				inc hl    ; move to size 
1552				ld a, c 
1552				sub (hl)        ; we want c < (hl) 
1552				dec hl    ; move back to marker 
1552			        jr z, .findblock 
1552			 
1552				; update with the new size which should be lower 
1552			 
1552			        ;inc  hl   ; negate next move. move back to size  
1552			 
1552			.newblock: 
1552				; need to be at marker here 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meN" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			 
1552				ld a, c 
1552			 
1552				ld (free_list+3), a	 ; flag resume from last malloc  
1552				ld (free_list), hl    ; save out last location 
1552			 
1552			 
1552				;inc a     ; space for length byte 
1552				ld (hl), a     ; save block in use marker 
1552			 
1552				inc hl   ; move to space marker 
1552				ld (hl), a    ; save new space 
1552			 
1552				inc hl   ; move to start of allocated area 
1552				 
1552			;	push hl     ; save where we are - 1  
1552			 
1552			;	inc hl  ; move past zero index  
1552				; skip space to set down new marker 
1552			 
1552				; provide some extra space for now 
1552			 
1552				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1552				inc a 
1552				inc a 
1552			 
1552				push hl   ; save where we are in the node block 
1552			 
1552				call addatohl 
1552			 
1552				; write linked list point 
1552			 
1552				pop de     ; get our node position 
1552				ex de, hl 
1552			 
1552				ld (hl), e 
1552				inc hl 
1552				ld (hl), d 
1552			 
1552				inc hl 
1552			 
1552				; now at start of allocated data so save pointer 
1552			 
1552				push hl 
1552			 
1552				; jump to position of next node and setup empty header in DE 
1552			 
1552				ex de, hl 
1552			 
1552			;	inc hl ; move past end of block 
1552			 
1552				ld a, 0 
1552				ld (hl), a   ; empty marker 
1552				inc hl 
1552				ld (hl), a   ; size 
1552				inc hl  
1552				ld (hl), a   ; ptr 
1552				inc hl 
1552				ld (hl), a   ; ptr 
1552			 
1552			 
1552				pop hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmr" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			.exit: 
1552				pop af 
1552				pop bc 
1552				pop de  
1552				ret 
1552			 
1552			 
1552			 
1552			 
1552			free:  
1552				push hl 
1552				push af 
1552				; get address in hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "fre" 
1552						CALLMONITOR 
1552					endif 
1552				; data is at hl - move to block count 
1552				dec hl 
1552				dec hl    ; get past pointer 
1552				dec hl 
1552			 
1552				ld a, (hl)    ; need this for a validation check 
1552			 
1552				dec hl    ; move to block marker 
1552			 
1552				; now check that the block count and block marker are the same  
1552			        ; this checks that we are on a malloc node and not random memory 
1552			        ; OK a faint chance this could be a problem but rare - famous last words! 
1552			 
1552				ld c, a 
1552				ld a, (hl)    
1552			 
1552				cp c 
1552				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1552			 
1552				; yes good chance we are on a malloc node 
1552			 
1552				ld a, 0      
1552				ld (hl), a   ; mark as free 
1552			 
1552				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1552			 
1552			.freeignore:  
1552			 
1552				pop af 
1552				pop hl 
1552			 
1552				ret 
1552			 
1552			 
1552			 
1552			endif 
1552			 
1552			; eof 
# End of file firmware_memory.asm
1552			  
1552			; device C  
1552			; Now handled by SPI  
1552			;if SOUND_ENABLE  
1552			;	include "firmware_sound.asm"  
1552			;endif  
1552			  
1552			include "firmware_diags.asm"  
1552			; Hardware diags menu 
1552			 
1552			 
1552			config: 
1552			 
1552 3e 00			ld a, 0 
1554 21 7d 15			ld hl, .configmn 
1557 cd db 0d			call menu 
155a			 
155a fe 00			cp 0 
155c c8				ret z 
155d			 
155d			;	cp 1 
155d			;	call z, .savetostore 
155d			 
155d fe 01			cp 1 
155f			if STARTUP_V1 
155f				call z, .selautoload 
155f			endif 
155f			 
155f			if STARTUP_V2 
155f cc 8b 15			call z, .enautoload 
1562			endif 
1562 fe 02			cp 2 
1564 cc a2 15			call z, .disautoload 
1567			;	cp 3 
1567			;	call z, .selbank 
1567 fe 03			cp 3 
1569 cc 0b 18			call z, .debug_tog 
156c fe 04			cp 4 
156e cc 59 19			call z, .bpsgo 
1571 fe 05			cp 5 
1573 cc 34 18			call z, hardware_diags 
1576			if STARTUP_V2 
1576 fe 06			cp 6 
1578 cc ce 15			call z, create_startup 
157b			endif 
157b 18 d5			jr config 
157d			 
157d			.configmn: 
157d			;	dw prom_c3 
157d 47 1b			dw prom_c2 
157f 5d 1b			dw prom_c2a 
1581			;	dw prom_c2b 
1581			;	dw prom_c4 
1581 d4 1b			dw prom_m4 
1583 ef 1b			dw prom_m4b 
1585 f7 1b			dw prom_c1 
1587			if STARTUP_V2 
1587 06 1c			dw prom_c9 
1589			endif 
1589 00 00			dw 0 
158b				 
158b			 
158b			if STARTUP_V2 
158b			.enautoload: 
158b				if STORAGE_SE 
158b 3e fe			ld a, $fe      ; bit 0 clear 
158d 32 95 f9			ld (spi_device), a 
1590			 
1590 cd 25 05			call storage_get_block_0 
1593			 
1593 3e 01			ld a, 1 
1595 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
1598			 
1598 21 00 00				ld hl, 0 
159b 11 af f9				ld de, store_page 
159e cd d9 04			call storage_write_block	 ; save update 
15a1				else 
15a1			 
15a1				ld hl, prom_notav 
15a1				ld de, prom_empty 
15a1				call info_panel 
15a1				endif 
15a1			 
15a1			 
15a1 c9				ret 
15a2			endif 
15a2			 
15a2			.disautoload: 
15a2				if STORAGE_SE 
15a2 3e fe			ld a, $fe      ; bit 0 clear 
15a4 32 95 f9			ld (spi_device), a 
15a7			 
15a7 cd 25 05			call storage_get_block_0 
15aa			 
15aa 3e 00			ld a, 0 
15ac 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
15af			 
15af 21 00 00				ld hl, 0 
15b2 11 af f9				ld de, store_page 
15b5 cd d9 04			call storage_write_block	 ; save update 
15b8				else 
15b8			 
15b8				ld hl, prom_notav 
15b8				ld de, prom_empty 
15b8				call info_panel 
15b8				endif 
15b8			 
15b8			 
15b8 c9				ret 
15b9			 
15b9			if STARTUP_V1 
15b9			 
15b9			; Select auto start 
15b9			 
15b9			.selautoload: 
15b9			 
15b9				 
15b9				if STORAGE_SE 
15b9			 
15b9					call config_dir 
15b9				        ld hl, scratch 
15b9					ld a, 0 
15b9					call menu 
15b9			 
15b9					cp 0 
15b9					ret z 
15b9			 
15b9					dec a 
15b9			 
15b9			 
15b9					; locate menu option 
15b9			 
15b9					ld hl, scratch 
15b9					call table_lookup 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALl" 
15b9						CALLMONITOR 
15b9					endif 
15b9					; with the pointer to the menu it, the byte following the zero term is the file id 
15b9			 
15b9					ld a, 0 
15b9					ld bc, 50   ; max of bytes to look at 
15b9					cpir  
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALb" 
15b9						CALLMONITOR 
15b9					endif 
15b9					;inc hl 
15b9			 
15b9					ld a, (hl)   ; file id 
15b9					 
15b9				        ; save bank and file ids 
15b9			 
15b9					push af 
15b9			 
15b9			; TODO need to save to block 0 on bank 1	 
15b9			 
15b9					call storage_get_block_0 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "AL0" 
15b9						CALLMONITOR 
15b9					endif 
15b9					pop af 
15b9			 
15b9					ld (store_page+STORE_0_FILERUN),a 
15b9					 
15b9					; save bank id 
15b9			 
15b9					ld a,(spi_device) 
15b9					ld (store_page+STORE_0_BANKRUN),a 
15b9			 
15b9					; enable auto run of store file 
15b9			 
15b9					ld a, 1 
15b9					ld (store_page+STORE_0_AUTOFILE),a 
15b9			 
15b9					; save buffer 
15b9			 
15b9					ld hl, 0 
15b9					ld de, store_page 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALw" 
15b9						CALLMONITOR 
15b9					endif 
15b9				call storage_write_block	 ; save update 
15b9			  
15b9			 
15b9			 
15b9			 
15b9					ld hl, scratch 
15b9					call config_fdir 
15b9			 
15b9				else 
15b9			 
15b9				ld hl, prom_notav 
15b9				ld de, prom_empty 
15b9				call info_panel 
15b9			 
15b9				endif 
15b9				ret 
15b9			endif 
15b9			 
15b9			 
15b9			; Select storage bank 
15b9			 
15b9			.selbank: 
15b9			 
15b9			;	if STORAGE_SE 
15b9			;	else 
15b9			 
15b9 21 1b 1c			ld hl, prom_notav 
15bc 11 31 1c			ld de, prom_empty 
15bf cd 3b 0d			call info_panel 
15c2			;	endif 
15c2				 
15c2 c9				ret 
15c3			 
15c3			if STORAGE_SE 
15c3			 
15c3			.config_ldir:   
15c3				; Load storage bank labels into menu array 
15c3			 
15c3				 
15c3			 
15c3			 
15c3 c9				ret 
15c4			 
15c4			 
15c4			endif 
15c4			 
15c4			 
15c4			; Save user words to storage 
15c4			 
15c4			.savetostore: 
15c4			 
15c4			;	if STORAGE_SE 
15c4			; 
15c4			;		call config_dir 
15c4			;	        ld hl, scratch 
15c4			;		ld a, 0 
15c4			;		call menu 
15c4			;		 
15c4			;		ld hl, scratch 
15c4			;		call config_fdir 
15c4			; 
15c4			;	else 
15c4			 
15c4 21 1b 1c			ld hl, prom_notav 
15c7 11 31 1c			ld de, prom_empty 
15ca cd 3b 0d			call info_panel 
15cd			 
15cd			;	endif 
15cd			 
15cd c9				ret 
15ce			 
15ce			if STARTUP_V2 
15ce			 
15ce			create_startup: 
15ce			 
15ce 3e 00			ld a, 0 
15d0 21 30 17			ld hl, .crstart 
15d3 cd db 0d			call menu 
15d6			 
15d6 fe 00			cp 0 
15d8 c8				ret z 
15d9			 
15d9 fe 01			cp 1 
15db cc 17 16			call z, .genlsword 
15de fe 02			cp 2 
15e0 cc 21 16			call z, .genedword 
15e3			 
15e3 fe 03			cp 3 
15e5 cc 2b 16			call z, .gendemword 
15e8			 
15e8 fe 04			cp 4 
15ea cc 35 16			call z, .genutlword 
15ed fe 05			cp 5 
15ef cc 3f 16			call z, .genspiword 
15f2 fe 06			cp 6 
15f4 cc 49 16			call z, .genkeyword 
15f7 fe 07			cp 7 
15f9 cc 0d 16			call z, .gensoundword 
15fc fe 07			cp 7 
15fe cc 03 16			call z, .genhwword 
1601 18 cb			jr create_startup 
1603			 
1603			.genhwword: 
1603 21 be 1b			ld hl, crs_hw 
1606 11 96 16			ld de, .hwworddef 
1609 cd 53 16			call .genfile 
160c c9				ret 
160d			.gensoundword: 
160d 21 b2 1b			ld hl, crs_sound 
1610 11 a4 16			ld de, .soundworddef 
1613 cd 53 16			call .genfile 
1616 c9				ret 
1617			.genlsword: 
1617 21 74 1b			ld hl, crs_s1 
161a 11 c8 16			ld de, .lsworddef 
161d cd 53 16			call .genfile 
1620 c9				ret 
1621			 
1621			.genedword: 
1621 11 cc 16			ld de, .edworddef 
1624 21 7d 1b			ld hl, crs_s2 
1627 cd 53 16			call .genfile 
162a c9				ret 
162b			 
162b			.gendemword: 
162b 11 d4 16			ld de, .demoworddef 
162e 21 86 1b			ld hl, crs_s3 
1631 cd 53 16			call .genfile 
1634 c9				ret 
1635			 
1635			.genutlword: 
1635 21 92 1b			ld hl, crs_s4 
1638 11 b8 16			ld de, .utilwordef 
163b cd 53 16			call .genfile 
163e c9				ret 
163f			.genspiword: 
163f 21 99 1b			ld hl, crs_s5 
1642 11 f6 16			ld de, .spiworddef 
1645 cd 53 16			call .genfile 
1648 c9				ret 
1649			.genkeyword: 
1649 21 a3 1b			ld hl, crs_s6 
164c 11 04 17			ld de, .keyworddef 
164f cd 53 16			call .genfile 
1652 c9				ret 
1653			 
1653			; hl - points to file name 
1653			; de - points to strings to add to file 
1653			 
1653			.genfile: 
1653 e5				push hl 
1654 d5				push de 
1655			 
1655 cd aa 0d			call clear_display 
1658 3e 00			ld a, display_row_1 
165a 11 85 16			ld de, .genfiletxt 
165d cd bd 0d			call str_at_display 
1660 cd cd 0d			call update_display 
1663			 
1663 d1				pop de 
1664 e1				pop hl 
1665			 
1665			 
1665 d5				push de 
1666 cd 77 08			call storage_create 
1669				; id in hl 
1669 d1				pop de   ; table of strings to add 
166a			 
166a			.genloop: 
166a			 
166a e5				push hl ; save id for next time around 
166b d5				push de ; save de for next time around 
166c			 
166c eb				ex de, hl 
166d cd b9 23			call loadwordinhl 
1670 eb				ex de, hl 
1671			 
1671				; need hl to be the id 
1671				; need de to be the string ptr 
1671				 
1671 cd 64 0b			call storage_append 
1674			 
1674 d1				pop de 
1675 e1				pop hl 
1676			 
1676 13				inc de 
1677 13				inc de 
1678			 
1678 1a				ld a,(de) 
1679 fe 00			cp 0 
167b 20 ed			jr nz, .genloop 
167d 13				inc de 
167e 1a				ld a, (de) 
167f 1b				dec de 
1680 fe 00			cp 0 
1682 20 e6			jr nz, .genloop	 
1684			 
1684 c9				ret 
1685			 
1685 .. 00		.genfiletxt:  db "Creating file...",0 
1696			 
1696			.hwworddef: 
1696 5c 65			dw test5 
1698 94 65			dw test6 
169a cc 65			dw test7 
169c e0 65			dw test8 
169e 0c 66			dw test9 
16a0 22 66			dw test10 
16a2 00 00			dw 0 
16a4			 
16a4			.soundworddef: 
16a4 47 66			dw sound1 
16a6 6b 66			dw sound2 
16a8 9b 66			dw sound3 
16aa c0 66			dw sound4 
16ac cd 66			dw sound5 
16ae da 66			dw sound6 
16b0 e7 66			dw sound7 
16b2 f4 66			dw sound8 
16b4 0c 67			dw sound9 
16b6 00 00			dw 0 
16b8			 
16b8			.utilwordef: 
16b8 95 63			dw strncpy 
16ba 70 63			dw type 
16bc 3c 63			dw clrstack 
16be f5 62			dw longread 
16c0 f6 63			dw start1 
16c2 06 64			dw start2 
16c4			; duplicated 
16c4			;	dw start3b 
16c4			;	dw start3c 
16c4 f2 64			dw list 
16c6 00 00			dw 0 
16c8			 
16c8			.lsworddef: 
16c8 17 64			dw start3b 
16ca 00 00			dw 0 
16cc			 
16cc			.edworddef: 
16cc 54 5f			dw edit1 
16ce 75 5f			dw edit2 
16d0 aa 5f			dw edit3 
16d2 00 00			dw 0 
16d4			 
16d4			.demoworddef: 
16d4 23 67			dw game1 
16d6 34 67			dw game1a 
16d8 96 67			dw game1b 
16da cb 67			dw game1c 
16dc 01 68			dw game1d 
16de 32 68			dw game1s 
16e0 46 68			dw game1t 
16e2 5b 68			dw game1f 
16e4 8f 68			dw game1z 
16e6 d3 68			dw game1zz 
16e8 3c 69			dw ssv2 
16ea 72 69			dw ssv3 
16ec 8e 69			dw ssv4 
16ee aa 69			dw ssv5 
16f0 c3 69			dw ssv1 
16f2 0b 6a			dw ssv1cpm	 
16f4			;	dw game2b 
16f4			;	dw game2bf 
16f4			;	dw game2mba 
16f4			;	dw game2mbas	 
16f4			;	dw game2mbht 
16f4			;	dw game2mbms 
16f4			;	dw game2mb 
16f4			;	dw game3w 
16f4			;	dw game3p 
16f4			;	dw game3sc 
16f4			;	dw game3vsi 
16f4			;	dw game3vs 
16f4 00 00			dw 0 
16f6			 
16f6			 
16f6			.spiworddef: 
16f6			 
16f6 e2 5f		    dw spi1 
16f8 3b 60		    dw spi2 
16fa 6f 60		    dw spi2b 
16fc f3 60		    dw spi3 
16fe 9d 60		    dw spi4 
1700 c6 60		    dw spi5 
1702			;    dw spi6 
1702			;    dw spi7 
1702			 
1702			;    dw spi8 
1702			;    dw spi9 
1702			;    dw spi10 
1702 00 00		    dw 0 
1704			 
1704			.keyworddef: 
1704			 
1704 62 6a			dw keyup 
1706 70 6a			dw keydown 
1708 80 6a			dw keyleft 
170a 90 6a			dw keyright 
170c a1 6a			dw 	keyf1 
170e af 6a			dw keyf2 
1710 bd 6a			dw keyf3 
1712 cb 6a			dw keyf4 
1714 d9 6a			dw keyf5 
1716 e7 6a			dw keyf6 
1718 f5 6a			dw keyf7 
171a 03 6b			dw keyf8 
171c 11 6b			dw keyf9 
171e 1f 6b			dw keyf10 
1720 2e 6b			dw keyf11 
1722 3d 6b			dw keyf12 
1724 4c 6b			dw keytab 
1726 5b 6b			dw keycr 
1728 69 6b			dw keyhome 
172a 79 6b			dw keyend 
172c 88 6b			dw keybs 
172e 00 00			dw 0 
1730			 
1730			.crstart: 
1730 74 1b			dw crs_s1 
1732 7d 1b			dw crs_s2 
1734 86 1b			dw crs_s3 
1736 92 1b			dw crs_s4 
1738 99 1b			dw crs_s5 
173a a3 1b			dw crs_s6 
173c b2 1b			dw crs_sound 
173e be 1b			dw crs_hw 
1740 00 00			dw 0 
1742			 
1742			endif 
1742			 
1742			 
1742			if STORAGE_SE 
1742			 
1742			config_fdir: 
1742				; using the scratch dir go through and release the memory allocated for each string 
1742				 
1742 21 f6 f0			ld hl, scratch 
1745 5e			.cfdir:	ld e,(hl) 
1746 23				inc hl 
1747 56				ld d,(hl) 
1748 23				inc hl 
1749			 
1749 eb				ex de, hl 
174a cd 07 10			call ishlzero 
174d c8				ret z     ; return on null pointer 
174e cd 83 14			call free 
1751 eb				ex de, hl 
1752 18 f1			jr .cfdir 
1754			 
1754			 
1754 c9				ret 
1755			 
1755			 
1755			config_dir: 
1755			 
1755				; for the config menus that need to build a directory of storage call this routine 
1755				; it will construct a menu in scratch to pass to menu 
1755			 
1755				; open storage device 
1755			 
1755				; execute DIR to build a list of files and their ids into scratch in menu format 
1755				; once the menu has finished then will need to call config_fdir to release the strings 
1755				 
1755				; c = number items 
1755			 
1755				 
1755 cd 25 05			call storage_get_block_0 
1758			 
1758 21 af f9			ld hl, store_page     ; get current id count 
175b 46				ld b, (hl) 
175c 0e 00			ld c, 0    ; count of files   
175e			 
175e			 
175e 21 f6 f0			ld hl, scratch 
1761 22 a6 f9			ld (store_tmp2), hl    ; location to poke strings 
1764			 
1764				; check for empty drive 
1764			 
1764 3e 00			ld a, 0 
1766 b8				cp b 
1767 ca 01 18			jp z, .dirdone 
176a			 
176a				 
176a					if DEBUG_FORTH_WORDS 
176a						DMARK "Cdc" 
176a f5				push af  
176b 3a 7f 17			ld a, (.dmark)  
176e 32 a0 fd			ld (debug_mark),a  
1771 3a 80 17			ld a, (.dmark+1)  
1774 32 a1 fd			ld (debug_mark+1),a  
1777 3a 81 17			ld a, (.dmark+2)  
177a 32 a2 fd			ld (debug_mark+2),a  
177d 18 03			jr .pastdmark  
177f ..			.dmark: db "Cdc"  
1782 f1			.pastdmark: pop af  
1783			endm  
# End of macro DMARK
1783						CALLMONITOR 
1783 cd aa fd			call debug_vector  
1786				endm  
# End of macro CALLMONITOR
1786					endif 
1786			 
1786			 
1786			.diritem:	 
1786 c5				push bc 
1787				; for each of the current ids do a search for them and if found push to stack 
1787			 
1787 21 40 00				ld hl, STORE_BLOCK_PHY 
178a 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
178c 58					ld e,b 
178d			 
178d cd a7 07				call storage_findnextid 
1790			 
1790			 
1790					; if found hl will be non zero 
1790			 
1790 cd 07 10				call ishlzero 
1793 28 69				jr z, .dirnotfound 
1795			 
1795					; increase count 
1795			 
1795 c1					pop bc	 
1796 0c					inc c 
1797 c5					push bc 
1798					 
1798			 
1798					; get file header and push the file name 
1798			 
1798 11 af f9				ld de, store_page 
179b cd 74 04				call storage_read_block 
179e			 
179e					; push file id to stack 
179e				 
179e 3a af f9				ld a, (store_page) 
17a1 26 00				ld h, 0 
17a3 6f					ld l, a 
17a4			 
17a4					;call forth_push_numhl 
17a4					; TODO store id 
17a4			 
17a4 e5					push hl 
17a5			 
17a5					; push extent count to stack  
17a5				 
17a5 21 b2 f9				ld hl, store_page+3 
17a8			 
17a8					; get file name length 
17a8			 
17a8 cd 44 13				call strlenz   
17ab			 
17ab 23					inc hl   ; cover zero term 
17ac 23					inc hl  ; stick the id at the end of the area 
17ad			 
17ad e5					push hl 
17ae c1					pop bc    ; move length to bc 
17af			 
17af cd b9 13				call malloc 
17b2			 
17b2					; TODO save malloc area to scratch 
17b2			 
17b2 eb					ex de, hl 
17b3 2a a6 f9				ld hl, (store_tmp2) 
17b6 73					ld (hl), e 
17b7 23					inc hl 
17b8 72					ld (hl), d 
17b9 23					inc hl 
17ba 22 a6 f9				ld (store_tmp2), hl 
17bd			 
17bd					 
17bd			 
17bd					;pop hl   ; get source 
17bd			;		ex de, hl    ; swap aronund	 
17bd			 
17bd 21 b2 f9				ld hl, store_page+3 
17c0					if DEBUG_FORTH_WORDS 
17c0						DMARK "CFd" 
17c0 f5				push af  
17c1 3a d5 17			ld a, (.dmark)  
17c4 32 a0 fd			ld (debug_mark),a  
17c7 3a d6 17			ld a, (.dmark+1)  
17ca 32 a1 fd			ld (debug_mark+1),a  
17cd 3a d7 17			ld a, (.dmark+2)  
17d0 32 a2 fd			ld (debug_mark+2),a  
17d3 18 03			jr .pastdmark  
17d5 ..			.dmark: db "CFd"  
17d8 f1			.pastdmark: pop af  
17d9			endm  
# End of macro DMARK
17d9						CALLMONITOR 
17d9 cd aa fd			call debug_vector  
17dc				endm  
# End of macro CALLMONITOR
17dc					endif 
17dc ed b0				ldir 
17de			 
17de					; de is past string, move back one and store id 
17de					 
17de 1b					dec de 
17df			 
17df					; store file id 
17df			 
17df e1					pop hl 
17e0 eb					ex de,hl 
17e1 73					ld (hl), e 
17e2			 
17e2					if DEBUG_FORTH_WORDS 
17e2						DMARK "Cdi" 
17e2 f5				push af  
17e3 3a f7 17			ld a, (.dmark)  
17e6 32 a0 fd			ld (debug_mark),a  
17e9 3a f8 17			ld a, (.dmark+1)  
17ec 32 a1 fd			ld (debug_mark+1),a  
17ef 3a f9 17			ld a, (.dmark+2)  
17f2 32 a2 fd			ld (debug_mark+2),a  
17f5 18 03			jr .pastdmark  
17f7 ..			.dmark: db "Cdi"  
17fa f1			.pastdmark: pop af  
17fb			endm  
# End of macro DMARK
17fb						CALLMONITOR 
17fb cd aa fd			call debug_vector  
17fe				endm  
# End of macro CALLMONITOR
17fe					endif 
17fe					 
17fe			.dirnotfound: 
17fe c1					pop bc     
17ff 10 85				djnz .diritem 
1801				 
1801			.dirdone:	 
1801			 
1801 3e 00				ld a, 0 
1803 2a a6 f9				ld hl, (store_tmp2) 
1806 77					ld (hl), a 
1807 23					inc hl 
1808 77					ld (hl), a 
1809 23					inc hl 
180a					; push a count of the dir items found 
180a			 
180a			;		ld h, 0 
180a			;		ld l, c 
180a			 
180a c9				ret 
180b			 
180b			endif 
180b			 
180b			 
180b			; Settings 
180b			; Run  
180b			 
180b			 
180b			 
180b			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
180b			;;hd_menu2:   db "        2: Editor",0   
180b			;hd_menu2:   db "        2: Editor       6: Menu",0   
180b			;hd_menu3:   db "        3: Storage",0 
180b			;hd_menu4:   db "0=quit  4: Debug",0 
180b			;hd_don:     db "ON",0 
180b			;hd_doff:     db "OFF",0 
180b			; 
180b			; 
180b			; 
180b			;hardware_diags_old:       
180b			; 
180b			;.diagmenu: 
180b			;	call clear_display 
180b			;	ld a, display_row_1 
180b			;	ld de, hd_menu1 
180b			;	call str_at_display 
180b			; 
180b			;	ld a, display_row_2 
180b			;	ld de, hd_menu2 
180b			;	call str_at_display 
180b			; 
180b			;	ld a, display_row_3 
180b			;	ld de, hd_menu3 
180b			;	call str_at_display 
180b			; 
180b			;	ld a,  display_row_4 
180b			;	ld de, hd_menu4 
180b			;	call str_at_display 
180b			; 
180b			;	; display debug state 
180b			; 
180b			;	ld de, hd_don 
180b			;	ld a, (os_view_disable) 
180b			;	cp 0 
180b			;	jr z, .distog 
180b			;	ld de, hd_doff 
180b			;.distog: ld a, display_row_4+17 
180b			;	call str_at_display 
180b			; 
180b			;	call update_display 
180b			; 
180b			;	call cin_wait 
180b			; 
180b			; 
180b			; 
180b			;	cp '4' 
180b			;	jr nz, .diagn1 
180b			; 
180b			;	; debug toggle 
180b			; 
180b			;	ld a, (os_view_disable) 
180b			;	ld b, '*' 
180b			;	cp 0 
180b			;	jr z, .debtog 
180b			;	ld b, 0 
180b			;.debtog:	 
180b			;	ld a,b 
180b			;	ld (os_view_disable),a 
180b			; 
180b			;.diagn1: cp '0' 
180b			;	 ret z 
180b			; 
180b			;;	cp '1' 
180b			;;       jp z, matrix	 
180b			;;   TODO keyboard matrix test 
180b			; 
180b			;	cp '2' 
180b			;	jp z, .diagedit 
180b			; 
180b			;;	cp '6' 
180b			;;	jp z, .menutest 
180b			;;if ENABLE_BASIC 
180b			;;	cp '6' 
180b			;;	jp z, basic 
180b			;;endif 
180b			 ; 
180b			;	jp .diagmenu 
180b			; 
180b			; 
180b			;	ret 
180b			 
180b			 
180b			.debug_tog: 
180b 21 55 18			ld hl, .menudebug 
180e				 
180e			;	ld a, (os_view_disable) 
180e			;	cp '*' 
180e 3a aa fd			ld a,(debug_vector) 
1811 fe c9			cp $C9   ; RET 
1813 20 04			jr nz,.tdon  
1815 3e 01			ld a, 1 
1817 18 02			jr .tog1 
1819 3e 00		.tdon: ld a, 0 
181b			 
181b			.tog1: 
181b cd db 0d			call menu 
181e fe 00			cp 0 
1820 c8				ret z 
1821 fe 01			cp 1    ; disable debug 
1823 28 04			jr z, .dtog0 
1825 3e 2a			ld a, '*' 
1827 18 05			jr .dtogset 
1829			.dtog0:  
1829				;ld a, 0 
1829 cd 47 19			call bp_on 
182c 18 dd			jr .debug_tog 
182e			.dtogset:  
182e				; ld (os_view_disable), a 
182e cd 53 19			call bp_off 
1831 c3 0b 18			jp .debug_tog 
1834			 
1834			 
1834			hardware_diags:       
1834			 
1834			.diagm: 
1834 21 47 18			ld hl, .menuitems 
1837 3e 00			ld a, 0 
1839 cd db 0d			call menu 
183c			 
183c fe 00		         cp 0 
183e c8				 ret z 
183f			 
183f fe 02			cp 2 
1841 ca a0 18			jp z, .diagedit 
1844			 
1844			;	cp '6' 
1844			;	jp z, .menutest 
1844			;if ENABLE_BASIC 
1844			;	cp '6' 
1844			;	jp z, basic 
1844			;endif 
1844			  
1844 c3 34 18			jp .diagm 
1847			 
1847				 
1847 5b 18		.menuitems:   	dw .m1 
1849 66 18				dw .m2 
184b 6d 18				dw .m3 
184d 75 18				dw .m5 
184f 7b 18				dw .m5a 
1851 84 18				dw .m5b 
1853 00 00				dw 0 
1855			 
1855			.menudebug: 
1855 8d 18				dw .m6 
1857 96 18				dw .m7 
1859 00 00				dw 0 
185b			 
185b .. 00		.m1:   db "Key Matrix",0 
1866 .. 00		.m2:   db "Editor",0 
186d .. 00		.m3:   db "Storage",0 
1875 .. 00		.m5:   db "Sound",0 
187b .. 00		.m5a:  db "RAM Test",0 
1884 .. 00		.m5b:  db "LCD Test",0 
188d			 
188d .. 00		.m6:   db "Debug ON",0 
1896 .. 00		.m7:   db "Debug OFF",0 
18a0			 
18a0			; debug editor 
18a0			 
18a0			.diagedit: 
18a0			 
18a0 21 f6 f0			ld hl, scratch 
18a3			;	ld bc, 250 
18a3			;	ldir 
18a3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18a3 3e 00			ld a, 0 
18a5 77				ld (hl), a 
18a6 23				inc hl 
18a7 77				ld (hl), a 
18a8 23				inc hl 
18a9 77				ld (hl), a 
18aa			 
18aa cd aa 0d		        call clear_display 
18ad cd cd 0d			call update_display 
18b0				;ld a, 1 
18b0				;ld (hardware_diag), a 
18b0			.diloop: 
18b0 3e 00			ld a, display_row_1 
18b2 0e 00			ld c, 0 
18b4 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18b6 1e 28			ld e, 40 
18b8			 
18b8 21 f6 f0			ld hl, scratch	 
18bb cd 0b 10			call input_str 
18be			 
18be 3e 28			ld a, display_row_2 
18c0 11 f6 f0			ld de, scratch 
18c3 cd bd 0d			call str_at_display 
18c6 cd cd 0d			call update_display 
18c9			 
18c9 c3 b0 18			jp .diloop 
18cc			 
18cc			 
18cc			; pass word in hl 
18cc			; a has display location 
18cc			display_word_at: 
18cc f5				push af 
18cd e5				push hl 
18ce 7c				ld a,h 
18cf 21 fb f3			ld hl, os_word_scratch 
18d2 cd e7 11			call hexout 
18d5 e1				pop hl 
18d6 7d				ld a,l 
18d7 21 fd f3			ld hl, os_word_scratch+2 
18da cd e7 11			call hexout 
18dd 21 ff f3			ld hl, os_word_scratch+4 
18e0 3e 00			ld a,0 
18e2 77				ld (hl),a 
18e3 11 fb f3			ld de,os_word_scratch 
18e6 f1				pop af 
18e7 cd bd 0d				call str_at_display 
18ea c9				ret 
18eb			 
18eb			display_ptr_state: 
18eb			 
18eb				; to restore afterwards 
18eb			 
18eb d5				push de 
18ec c5				push bc 
18ed e5				push hl 
18ee f5				push af 
18ef			 
18ef				; for use in here 
18ef			 
18ef			;	push bc 
18ef			;	push de 
18ef			;	push hl 
18ef			;	push af 
18ef			 
18ef cd aa 0d			call clear_display 
18f2			 
18f2 11 ca 1a			ld de, .ptrstate 
18f5 3e 00			ld a, display_row_1 
18f7 cd bd 0d			call str_at_display 
18fa			 
18fa				; display debug step 
18fa			 
18fa			 
18fa 11 a0 fd			ld de, debug_mark 
18fd 3e 26			ld a, display_row_1+display_cols-2 
18ff cd bd 0d			call str_at_display 
1902			 
1902				; display a 
1902 11 d4 1a			ld de, .ptrcliptr 
1905 3e 28			ld a, display_row_2 
1907 cd bd 0d			call str_at_display 
190a			 
190a f1				pop af 
190b 2a 75 f9			ld hl,(cli_ptr) 
190e 3e 30			ld a, display_row_2+8 
1910 cd cc 18			call display_word_at 
1913			 
1913			 
1913				; display hl 
1913			 
1913			 
1913 11 dc 1a			ld de, .ptrclioptr 
1916 3e 32			ld a, display_row_2+10 
1918 cd bd 0d			call str_at_display 
191b			; 
191b			;	pop hl 
191b 3e 35			ld a, display_row_2+13 
191d 2a 73 f9			ld hl,(cli_origptr) 
1920 cd cc 18			call display_word_at 
1923			; 
1923			;	 
1923			;	; display de 
1923			 
1923			;	ld de, .regstatede 
1923			;	ld a, display_row_3 
1923			;	call str_at_display 
1923			 
1923			;	pop de 
1923			;	ld h,d 
1923			;	ld l, e 
1923			;	ld a, display_row_3+3 
1923			;	call display_word_at 
1923			 
1923			 
1923				; display bc 
1923			 
1923			;	ld de, .regstatebc 
1923			;	ld a, display_row_3+10 
1923			;	call str_at_display 
1923			 
1923			;	pop bc 
1923			;	ld h,b 
1923			;	ld l, c 
1923			;	ld a, display_row_3+13 
1923			;	call display_word_at 
1923			 
1923			 
1923				; display dsp 
1923			 
1923			;	ld de, .regstatedsp 
1923			;	ld a, display_row_4 
1923			;	call str_at_display 
1923			 
1923				 
1923			;	ld hl,(cli_data_sp) 
1923			;	ld a, display_row_4+4 
1923			;	call display_word_at 
1923			 
1923				; display rsp 
1923			 
1923 11 0b 1b			ld de, .regstatersp 
1926 3e 82			ld a, display_row_4+10 
1928 cd bd 0d			call str_at_display 
192b			 
192b				 
192b 2a 27 f9			ld hl,(cli_ret_sp) 
192e 3e 86			ld a, display_row_4+14 
1930 cd cc 18			call display_word_at 
1933			 
1933 cd cd 0d			call update_display 
1936			 
1936 cd ed 0c			call delay1s 
1939 cd ed 0c			call delay1s 
193c cd ed 0c			call delay1s 
193f			 
193f			 
193f cd be 1f			call next_page_prompt 
1942			 
1942				; restore  
1942			 
1942 f1				pop af 
1943 e1				pop hl 
1944 c1				pop bc 
1945 d1				pop de 
1946 c9				ret 
1947			 
1947			; Update the break point vector so that the user can hook a new routine 
1947			 
1947			bp_on: 
1947 3e c3			ld a, $c3    ; JP 
1949 32 aa fd			ld (debug_vector), a 
194c 21 59 19			ld hl, break_point_state 
194f 22 ab fd			ld (debug_vector+1), hl 
1952 c9				ret 
1953			 
1953			bp_off: 
1953 3e c9			ld a, $c9    ; RET 
1955 32 aa fd			ld (debug_vector), a 
1958 c9				ret 
1959			 
1959			 
1959			break_point_state: 
1959			;	push af 
1959			; 
1959			;	; see if disabled 
1959			; 
1959			;	ld a, (os_view_disable) 
1959			;	cp '*' 
1959			;	jr nz, .bpsgo 
1959			;	pop af 
1959			;	ret 
1959			 
1959			.bpsgo: 
1959			;	pop af 
1959 f5				push af 
195a 22 d8 f0			ld (os_view_hl), hl 
195d ed 53 d6 f0		ld (os_view_de), de 
1961 ed 43 d4 f0		ld (os_view_bc), bc 
1965 e5				push hl 
1966 6f				ld l, a 
1967 26 00			ld h, 0 
1969 22 da f0			ld (os_view_af),hl 
196c			 
196c 21 e6 fc				ld hl, display_fb0 
196f 22 01 fb				ld (display_fb_active), hl 
1972 e1				pop hl	 
1973			 
1973 3e 31			ld a, '1' 
1975 fe 2a		.bps1:  cp '*' 
1977 cc 53 19			call z, bp_off 
197a			;	jr nz, .bps1b 
197a			;	ld (os_view_disable),a 
197a fe 31		.bps1b:  cp '1' 
197c 20 14			jr nz, .bps2 
197e			 
197e				; display reg 
197e			 
197e				 
197e			 
197e 3a da f0			ld a, (os_view_af) 
1981 2a d8 f0			ld hl, (os_view_hl) 
1984 ed 5b d6 f0		ld de, (os_view_de) 
1988 ed 4b d4 f0		ld bc, (os_view_bc) 
198c cd 26 1a			call display_reg_state 
198f c3 12 1a			jp .bpschk 
1992			 
1992 fe 32		.bps2:  cp '2' 
1994 20 08			jr nz, .bps3 
1996				 
1996				; display hl 
1996 2a d8 f0			ld hl, (os_view_hl) 
1999 cd 10 1b			call display_dump_at_hl 
199c			 
199c 18 74			jr .bpschk 
199e			 
199e fe 33		.bps3:  cp '3' 
19a0 20 08			jr nz, .bps4 
19a2			 
19a2			        ; display de 
19a2 2a d6 f0			ld hl, (os_view_de) 
19a5 cd 10 1b			call display_dump_at_hl 
19a8			 
19a8 18 68			jr .bpschk 
19aa fe 34		.bps4:  cp '4' 
19ac 20 08			jr nz, .bps5 
19ae			 
19ae			        ; display bc 
19ae 2a d4 f0			ld hl, (os_view_bc) 
19b1 cd 10 1b			call display_dump_at_hl 
19b4			 
19b4 18 5c			jr .bpschk 
19b6 fe 35		.bps5:  cp '5' 
19b8 20 08		        jr nz, .bps7 
19ba			 
19ba				; display cur ptr 
19ba 2a 75 f9			ld hl, (cli_ptr) 
19bd cd 10 1b			call display_dump_at_hl 
19c0			 
19c0 18 50			jr .bpschk 
19c2 fe 36		.bps7:  cp '6' 
19c4 20 08			jr nz, .bps8b 
19c6				 
19c6				; display cur orig ptr 
19c6 2a 73 f9			ld hl, (cli_origptr) 
19c9 cd 10 1b			call display_dump_at_hl 
19cc 18 44			jr .bpschk 
19ce fe 37		.bps8b:  cp '7' 
19d0 20 08			jr nz, .bps9 
19d2				 
19d2				; display dsp 
19d2 2a 23 f9			ld hl, (cli_data_sp) 
19d5 cd 10 1b			call display_dump_at_hl 
19d8			 
19d8 18 38			jr .bpschk 
19da fe 39		.bps9:  cp '9' 
19dc 20 05			jr nz, .bps8c 
19de				 
19de				; display SP 
19de			;	ld hl, sp 
19de cd 10 1b			call display_dump_at_hl 
19e1			 
19e1 18 2f			jr .bpschk 
19e3 fe 38		.bps8c:  cp '8' 
19e5 20 08			jr nz, .bps8d 
19e7				 
19e7				; display rsp 
19e7 2a 27 f9			ld hl, (cli_ret_sp) 
19ea cd 10 1b			call display_dump_at_hl 
19ed			 
19ed 18 23			jr .bpschk 
19ef fe 23		.bps8d:  cp '#'     ; access monitor sub system 
19f1 20 05			jr nz, .bps8 
19f3 cd 78 1d			call monitor 
19f6			 
19f6 18 1a			jr .bpschk 
19f8 fe 30		.bps8:  cp '0' 
19fa 20 16			jr nz, .bpschk 
19fc			 
19fc 21 45 fc				ld hl, display_fb1 
19ff 22 01 fb				ld (display_fb_active), hl 
1a02 cd cd 0d				call update_display 
1a05			 
1a05				;ld a, (os_view_af) 
1a05 2a d8 f0			ld hl, (os_view_hl) 
1a08 ed 5b d6 f0		ld de, (os_view_de) 
1a0c ed 4b d4 f0		ld bc, (os_view_bc) 
1a10 f1				pop af 
1a11 c9				ret 
1a12			 
1a12			.bpschk:   
1a12 cd ed 0c			call delay1s 
1a15 3e 9f		ld a,display_row_4 + display_cols - 1 
1a17 11 bc 1f		        ld de, endprg 
1a1a cd bd 0d			call str_at_display 
1a1d cd cd 0d			call update_display 
1a20 cd 0c 73			call cin_wait 
1a23			 
1a23 c3 75 19			jp .bps1 
1a26			 
1a26			 
1a26			display_reg_state: 
1a26			 
1a26				; to restore afterwards 
1a26			 
1a26 d5				push de 
1a27 c5				push bc 
1a28 e5				push hl 
1a29 f5				push af 
1a2a			 
1a2a				; for use in here 
1a2a			 
1a2a c5				push bc 
1a2b d5				push de 
1a2c e5				push hl 
1a2d f5				push af 
1a2e			 
1a2e cd aa 0d			call clear_display 
1a31			 
1a31 11 e6 1a			ld de, .regstate 
1a34 3e 00			ld a, display_row_1 
1a36 cd bd 0d			call str_at_display 
1a39			 
1a39				; display debug step 
1a39			 
1a39			 
1a39 11 a0 fd			ld de, debug_mark 
1a3c 3e 25			ld a, display_row_1+display_cols-3 
1a3e cd bd 0d			call str_at_display 
1a41			 
1a41				; display a 
1a41 11 02 1b			ld de, .regstatea 
1a44 3e 28			ld a, display_row_2 
1a46 cd bd 0d			call str_at_display 
1a49			 
1a49 e1				pop hl 
1a4a			;	ld h,0 
1a4a			;	ld l, a 
1a4a 3e 2b			ld a, display_row_2+3 
1a4c cd cc 18			call display_word_at 
1a4f			 
1a4f			 
1a4f				; display hl 
1a4f			 
1a4f			 
1a4f 11 f6 1a			ld de, .regstatehl 
1a52 3e 32			ld a, display_row_2+10 
1a54 cd bd 0d			call str_at_display 
1a57			 
1a57 e1				pop hl 
1a58 3e 35			ld a, display_row_2+13 
1a5a cd cc 18			call display_word_at 
1a5d			 
1a5d				 
1a5d				; display de 
1a5d			 
1a5d 11 fa 1a			ld de, .regstatede 
1a60 3e 50			ld a, display_row_3 
1a62 cd bd 0d			call str_at_display 
1a65			 
1a65 e1				pop hl 
1a66			;	ld h,d 
1a66			;	ld l, e 
1a66 3e 53			ld a, display_row_3+3 
1a68 cd cc 18			call display_word_at 
1a6b			 
1a6b			 
1a6b				; display bc 
1a6b			 
1a6b 11 fe 1a			ld de, .regstatebc 
1a6e 3e 5a			ld a, display_row_3+10 
1a70 cd bd 0d			call str_at_display 
1a73			 
1a73 e1				pop hl 
1a74			;	ld h,b 
1a74			;	ld l, c 
1a74 3e 5d			ld a, display_row_3+13 
1a76 cd cc 18			call display_word_at 
1a79			 
1a79			 
1a79				; display dsp 
1a79			 
1a79 11 06 1b			ld de, .regstatedsp 
1a7c 3e 78			ld a, display_row_4 
1a7e cd bd 0d			call str_at_display 
1a81			 
1a81				 
1a81 2a 23 f9			ld hl,(cli_data_sp) 
1a84 3e 7c			ld a, display_row_4+4 
1a86 cd cc 18			call display_word_at 
1a89			 
1a89				; display rsp 
1a89			 
1a89 11 0b 1b			ld de, .regstatersp 
1a8c 3e 82			ld a, display_row_4+10 
1a8e cd bd 0d			call str_at_display 
1a91			 
1a91				 
1a91 2a 27 f9			ld hl,(cli_ret_sp) 
1a94 3e 86			ld a, display_row_4+14 
1a96 cd cc 18			call display_word_at 
1a99			 
1a99 cd cd 0d			call update_display 
1a9c			 
1a9c			;	call delay1s 
1a9c			;	call delay1s 
1a9c			;	call delay1s 
1a9c			 
1a9c			 
1a9c			;	call next_page_prompt 
1a9c			 
1a9c				; restore  
1a9c			 
1a9c f1				pop af 
1a9d e1				pop hl 
1a9e c1				pop bc 
1a9f d1				pop de 
1aa0 c9				ret 
1aa1			 
1aa1 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ab5 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1aca .. 00		.ptrstate:	db "Ptr State",0 
1ad4 .. 00		.ptrcliptr:     db "cli_ptr",0 
1adc .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1ae6 .. 00		.regstate:	db "Reg State (1/0)",0 
1af6 .. 00		.regstatehl:	db "HL:",0 
1afa .. 00		.regstatede:	db "DE:",0 
1afe .. 00		.regstatebc:	db "BC:",0 
1b02 .. 00		.regstatea:	db "A :",0 
1b06 .. 00		.regstatedsp:	db "DSP:",0 
1b0b .. 00		.regstatersp:	db "RSP:",0 
1b10			 
1b10			display_dump_at_hl: 
1b10 e5				push hl 
1b11 d5				push de 
1b12 c5				push bc 
1b13 f5				push af 
1b14			 
1b14 22 19 f4			ld (os_cur_ptr),hl	 
1b17 cd aa 0d			call clear_display 
1b1a cd c6 1e			call dumpcont 
1b1d			;	call delay1s 
1b1d			;	call next_page_prompt 
1b1d			 
1b1d			 
1b1d f1				pop af 
1b1e c1				pop bc 
1b1f d1				pop de 
1b20 e1				pop hl 
1b21 c9				ret 
1b22			 
1b22			;if ENABLE_BASIC 
1b22			;	include "nascombasic.asm" 
1b22			;	basic: 
1b22			;	include "forth/FORTH.ASM" 
1b22			;endif 
1b22			 
1b22			; eof 
1b22			 
1b22			 
# End of file firmware_diags.asm
1b22			  
1b22			include "firmware_prompts.asm"  
1b22			; Prompts  
1b22			 
1b22			; boot messages 
1b22			 
1b22 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1b37 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b47			 
1b47			 
1b47			; config menus 
1b47			 
1b47			;prom_c3: db "Add Dictionary To File",0 
1b47			 
1b47			if STARTUP_V1 
1b47			prom_c2: db "Select Autoload File",0 
1b47			prom_c2a: db "Disable Autoload File", 0 
1b47			endif 
1b47			 
1b47			if STARTUP_V2 
1b47 .. 00		prom_c2: db "Enable Autoload Files",0 
1b5d .. 00		prom_c2a: db "Disable Autoload Files", 0 
1b74			 
1b74 .. 00		crs_s1: db "*ls-word", 0 
1b7d .. 00		crs_s2: db "*ed-word", 0 
1b86 .. 00		crs_s3: db "*Demo-Games", 0 
1b92 .. 00		crs_s4: db "*Utils", 0 
1b99 .. 00		crs_s5: db "*SPI-Util", 0 
1ba3 .. 00		crs_s6: db "*Key-Constants", 0 
1bb2 .. 00		crs_sound: db "*Sound-Util", 0 
1bbe .. 00		crs_hw: db "*Hello-World",0 
1bcb			 
1bcb			 
1bcb			 
1bcb			endif 
1bcb			;prom_c2b: db "Select Storage Bank",0 
1bcb .. 00		prom_c4: db "Settings",0 
1bd4 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1bef .. 00		prom_m4b:   db "Monitor",0 
1bf7 .. 00		prom_c1: db "Hardware Diags",0 
1c06			 
1c06			 
1c06			if STARTUP_V2 
1c06 .. 00		prom_c9: db "Create Startup Files",0 
1c1b			endif 
1c1b			 
1c1b .. 00		prom_notav:    db "Feature not available",0 
1c31 .. 00		prom_empty:    db "",0 
1c32			 
1c32			; eof 
1c32			 
# End of file firmware_prompts.asm
1c32			  
1c32			  
1c32			; eof  
1c32			  
# End of file firmware.asm
1c32			 
1c32			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c32			;if BASE_KEV  
1c32			;baseram: equ 08000h 
1c32			;endif 
1c32			 
1c32			;if BASE_SC114 
1c32			;baseram:     equ    endofcode 
1c32			;endif 
1c32			 
1c32			 
1c32			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c32			 
1c32			; start system 
1c32			 
1c32			coldstart: 
1c32				; set sp 
1c32				; di/ei 
1c32			 
1c32 f3				di 
1c33 31 fd ff			ld sp, tos 
1c36 cd 93 6f			call init_nmi 
1c39			;	ei 
1c39			 
1c39				; init spinner 
1c39 3e 00			ld a,0 
1c3b 32 fb fa			ld (display_active), a 
1c3e			 
1c3e				; disable breakpoint by default 
1c3e			 
1c3e				;ld a,'*' 
1c3e			;	ld a,' ' 
1c3e			;	ld (os_view_disable),a 
1c3e			 
1c3e				; set break point vector as new break point on or off 
1c3e cd 53 19			call bp_off 
1c41			 
1c41				; init hardware 
1c41			 
1c41				; init keyboard and screen hardware 
1c41			 
1c41 cd 6c 00			call hardware_init 
1c44			 
1c44			 
1c44 cd ed 0c			call delay1s 
1c47 3e 58			ld a, display_row_3+8 
1c49 11 03 00			ld de, buildtime 
1c4c cd bd 0d			call str_at_display 
1c4f cd cd 0d			call update_display 
1c52			 
1c52 cd ed 0c			call delay1s 
1c55 cd ed 0c			call delay1s 
1c58 cd ed 0c			call delay1s 
1c5b			 
1c5b				; detect if any keys are held down to enable breakpoints at start up 
1c5b			 
1c5b cd 1d 73			call cin  
1c5e fe 00			cp 0 
1c60 28 03			jr z, .nokeys 
1c62			 
1c62				;call hardware_diags 
1c62 cd 52 15			call config 
1c65			 
1c65			;	ld de, .bpen 
1c65			;	ld a, display_row_4 
1c65			;	call str_at_display 
1c65			;	call update_display 
1c65			; 
1c65			;	ld a,0 
1c65			;	ld (os_view_disable),a 
1c65			; 
1c65			;.bpwait: 
1c65			;	call cin 
1c65			;	cp 0 
1c65			;	jr z, .bpwait 
1c65			;	jr .nokeys 
1c65			; 
1c65			; 
1c65			;.bpen:  db "Break points enabled!",0 
1c65			 
1c65			 
1c65			 
1c65			 
1c65			 
1c65			 
1c65			.nokeys: 
1c65			 
1c65			 
1c65				 
1c65			 
1c65			;jp  testkey 
1c65			 
1c65			;call storage_get_block_0 
1c65			; 
1c65			;ld hl, 0 
1c65			;ld de, store_page 
1c65			;call storage_read_block 
1c65			 
1c65				 
1c65			;ld hl, 10 
1c65			;ld de, store_page 
1c65			;call storage_read_block 
1c65			 
1c65			 
1c65			 
1c65			 
1c65			 
1c65			;stop:	nop 
1c65			;	jp stop 
1c65			 
1c65			 
1c65			 
1c65			main: 
1c65 cd aa 0d			call clear_display 
1c68 cd cd 0d			call update_display 
1c6b			 
1c6b			 
1c6b			 
1c6b			;	call testlcd 
1c6b			 
1c6b			 
1c6b			 
1c6b cd 07 24			call forth_init 
1c6e			 
1c6e			 
1c6e			warmstart: 
1c6e cd dd 23			call forth_warmstart 
1c71			 
1c71				; run startup word load 
1c71			        ; TODO prevent this running at warmstart after crash  
1c71			 
1c71				if STARTUP_ENABLE 
1c71			 
1c71					if STARTUP_V1 
1c71			 
1c71						if STORAGE_SE 
1c71							call forth_autoload 
1c71						endif 
1c71						call forth_startup 
1c71					endif 
1c71			 
1c71					if STARTUP_V2 
1c71			 
1c71						if STORAGE_SE 
1c71 cd c1 6d						call forth_autoload 
1c74						else 
1c74							call forth_startup 
1c74						endif 
1c74			 
1c74			 
1c74					endif 
1c74			 
1c74				endif 
1c74			 
1c74			warmstart_afterauto: 
1c74			 
1c74				; show free memory after boot 
1c74 11 13 1d			ld de, freeram 
1c77 3e 00			ld a, display_row_1 
1c79 cd bd 0d			call str_at_display 
1c7c			 
1c7c				; get current heap start after loading any uwords 
1c7c			 
1c7c				;ld de, (os_last_new_uword) 
1c7c				;ex de, hl 
1c7c			 
1c7c			; Or use heap_size word???? 
1c7c				;ld hl, heap_end 
1c7c				;ld hl, heap_size 
1c7c				;ld de, topusermem 
1c7c				;ld de, heap_start 
1c7c ed 5b 0a 80			ld de, (free_list )      
1c80 21 d1 f0				ld hl, heap_end 
1c83 ed 52			sbc hl, de 
1c85				;push hl 
1c85				;ld a,h	         	 
1c85				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c85				;call hexout 
1c85			   	;pop hl 
1c85			; 
1c85			;	ld a,l 
1c85			;	ld hl, os_word_scratch+2 
1c85			;	call hexout 
1c85			;	ld hl, os_word_scratch+4 
1c85			;	ld a, 0 
1c85			;	ld (hl),a 
1c85 eb				ex de, hl 
1c86 21 fb f3			ld hl, os_word_scratch 
1c89 cd f3 12			call uitoa_16 
1c8c			 
1c8c			 
1c8c 11 fb f3			ld de, os_word_scratch 
1c8f 3e 0d			ld a, display_row_1 + 13 
1c91 cd bd 0d			call str_at_display 
1c94 cd cd 0d			call update_display 
1c97			 
1c97			 
1c97				;call demo 
1c97			 
1c97			 
1c97				; init scratch input area for cli commands 
1c97			 
1c97 21 1d f4			ld hl, os_cli_cmd 
1c9a 3e 00			ld a,0 
1c9c 77				ld (hl),a 
1c9d 23				inc hl 
1c9e 77				ld (hl),a 
1c9f			 
1c9f 3e 00			ld a,0 
1ca1 32 1c f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1ca4			 
1ca4 32 19 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1ca7 32 1a f4			ld (os_cur_ptr+1),a	 
1caa			 
1caa 32 fb f3			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1cad 32 fc f3			ld (os_word_scratch+1),a	 
1cb0				 
1cb0			 
1cb0				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cb0 21 1d f4			ld hl, os_cli_cmd 
1cb3			 
1cb3 3e 00			ld a, 0		 ; init cli input 
1cb5 77				ld (hl), a 
1cb6 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cb8			cli: 
1cb8				; show cli prompt 
1cb8				;push af 
1cb8				;ld a, 0 
1cb8				;ld de, prompt 
1cb8				;call str_at_display 
1cb8			 
1cb8				;call update_display 
1cb8				;pop af 
1cb8				;inc a 
1cb8				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1cb8			 
1cb8			.lastrecall: 
1cb8			 
1cb8 0e 00			ld c, 0 
1cba 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1cbc 1e 28			ld e, 40 
1cbe			 
1cbe 21 1d f4			ld hl, os_cli_cmd 
1cc1			 
1cc1				STACKFRAME OFF $fefe $9f9f 
1cc1				if DEBUG_STACK_IMB 
1cc1					if OFF 
1cc1						exx 
1cc1						ld de, $fefe 
1cc1						ld a, d 
1cc1						ld hl, curframe 
1cc1						call hexout 
1cc1						ld a, e 
1cc1						ld hl, curframe+2 
1cc1						call hexout 
1cc1						ld hl, $fefe 
1cc1						push hl 
1cc1						ld hl, $9f9f 
1cc1						push hl 
1cc1						exx 
1cc1					endif 
1cc1				endif 
1cc1			endm 
# End of macro STACKFRAME
1cc1			 
1cc1 cd 0b 10			call input_str 
1cc4			 
1cc4				STACKFRAMECHK OFF $fefe $9f9f 
1cc4				if DEBUG_STACK_IMB 
1cc4					if OFF 
1cc4						exx 
1cc4						ld hl, $9f9f 
1cc4						pop de   ; $9f9f 
1cc4						call cmp16 
1cc4						jr nz, .spnosame 
1cc4						ld hl, $fefe 
1cc4						pop de   ; $fefe 
1cc4						call cmp16 
1cc4						jr z, .spfrsame 
1cc4						.spnosame: call showsperror 
1cc4						.spfrsame: nop 
1cc4						exx 
1cc4					endif 
1cc4				endif 
1cc4			endm 
# End of macro STACKFRAMECHK
1cc4			 
1cc4			 
1cc4				; check to see if last line recall has been requested 
1cc4			 
1cc4			if EDIT_V2 
1cc4 fe 05			cp KEY_UP 
1cc6 20 0f			jr nz, .noexecline 
1cc8			 
1cc8 11 1d f4			ld de, os_cli_cmd 
1ccb 21 1c f5			ld hl, os_last_cmd 
1cce 01 ff 00			ld bc, 255 
1cd1 ed b0			ldir 
1cd3 3e 00			ld a, 0 
1cd5 18 e1			jr .lastrecall 
1cd7			endif 
1cd7			 
1cd7			.noexecline: 
1cd7				; no so exec the line		 
1cd7			 
1cd7				; copy input to last command 
1cd7			 
1cd7 21 1d f4			ld hl, os_cli_cmd 
1cda 11 1c f5			ld de, os_last_cmd 
1cdd 01 ff 00			ld bc, 255 
1ce0 ed b0			ldir 
1ce2			 
1ce2				; wipe current buffer 
1ce2			 
1ce2			;	ld a, 0 
1ce2			;	ld hl, os_cli_cmd 
1ce2			;	ld de, os_cli_cmd+1 
1ce2			;	ld bc, 254 
1ce2			;	ldir 
1ce2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1ce2			;	call strcpy 
1ce2			;	ld a, 0 
1ce2			;	ld (hl), a 
1ce2			;	inc hl 
1ce2			;	ld (hl), a 
1ce2			;	inc hl 
1ce2			;	ld (hl), a 
1ce2			 
1ce2				; switch frame buffer to program  
1ce2			 
1ce2 21 45 fc				ld hl, display_fb1 
1ce5 22 01 fb				ld (display_fb_active), hl 
1ce8			 
1ce8			;	nop 
1ce8				STACKFRAME ON $fbfe $8f9f 
1ce8				if DEBUG_STACK_IMB 
1ce8					if ON 
1ce8						exx 
1ce8						ld de, $fbfe 
1ce8						ld a, d 
1ce8						ld hl, curframe 
1ce8						call hexout 
1ce8						ld a, e 
1ce8						ld hl, curframe+2 
1ce8						call hexout 
1ce8						ld hl, $fbfe 
1ce8						push hl 
1ce8						ld hl, $8f9f 
1ce8						push hl 
1ce8						exx 
1ce8					endif 
1ce8				endif 
1ce8			endm 
# End of macro STACKFRAME
1ce8				; first time into the parser so pass over the current scratch pad 
1ce8 21 1d f4			ld hl,os_cli_cmd 
1ceb				; tokenise the entered statement(s) in HL 
1ceb cd 85 24			call forthparse 
1cee			        ; exec forth statements in top of return stack 
1cee cd c5 24			call forthexec 
1cf1				;call forthexec_cleanup 
1cf1			;	call parsenext 
1cf1			 
1cf1				STACKFRAMECHK ON $fbfe $8f9f 
1cf1				if DEBUG_STACK_IMB 
1cf1					if ON 
1cf1						exx 
1cf1						ld hl, $8f9f 
1cf1						pop de   ; $8f9f 
1cf1						call cmp16 
1cf1						jr nz, .spnosame 
1cf1						ld hl, $fbfe 
1cf1						pop de   ; $fbfe 
1cf1						call cmp16 
1cf1						jr z, .spfrsame 
1cf1						.spnosame: call showsperror 
1cf1						.spfrsame: nop 
1cf1						exx 
1cf1					endif 
1cf1				endif 
1cf1			endm 
# End of macro STACKFRAMECHK
1cf1				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1cf1			 
1cf1 3e 78			ld a, display_row_4 
1cf3 11 24 1d			ld de, endprog 
1cf6			 
1cf6 cd cd 0d			call update_display		 
1cf9			 
1cf9 cd be 1f			call next_page_prompt 
1cfc			 
1cfc				; switch frame buffer to cli 
1cfc			 
1cfc 21 e6 fc				ld hl, display_fb0 
1cff 22 01 fb				ld (display_fb_active), hl 
1d02			 
1d02			 
1d02 cd aa 0d		        call clear_display 
1d05 cd cd 0d			call update_display		 
1d08			 
1d08 21 1d f4			ld hl, os_cli_cmd 
1d0b			 
1d0b 3e 00			ld a, 0		 ; init cli input 
1d0d 77				ld (hl), a 
1d0e			 
1d0e				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1d0e			 
1d0e				; now on last line 
1d0e			 
1d0e				; TODO scroll screen up 
1d0e			 
1d0e				; TODO instead just clear screen and place at top of screen 
1d0e			 
1d0e			;	ld a, 0 
1d0e			;	ld (f_cursor_ptr),a 
1d0e			 
1d0e				;call clear_display 
1d0e				;call update_display 
1d0e			 
1d0e				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d0e 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d10 c3 b8 1c			jp cli 
1d13			 
1d13 .. 00		freeram: db "Free bytes: ",0 
1d20 ..			asc: db "1A2F" 
1d24 .. 00		endprog: db "End prog...",0 
1d30			 
1d30			testenter2:   
1d30 21 28 f1			ld hl,scratch+50 
1d33 22 19 f4			ld (os_cur_ptr),hl 
1d36 c3 b8 1c			jp cli 
1d39			 
1d39			testenter:  
1d39			 
1d39 21 20 1d			ld hl,asc 
1d3c			;	ld a,(hl) 
1d3c			;	call nibble2val 
1d3c cd 3d 12			call get_byte 
1d3f			 
1d3f			 
1d3f			;	ld a,(hl) 
1d3f			;	call atohex 
1d3f			 
1d3f			;	call fourehexhl 
1d3f 32 28 f1			ld (scratch+50),a 
1d42			 
1d42			 
1d42			 
1d42 21 22 1d			ld hl,asc+2 
1d45			;	ld a, (hl) 
1d45			;	call nibble2val 
1d45 cd 3d 12			call get_byte 
1d48			 
1d48			;	call fourehexhl 
1d48 32 2a f1			ld (scratch+52),a 
1d4b				 
1d4b 21 28 f1			ld hl,scratch+50 
1d4e 22 19 f4			ld (os_cur_ptr),hl 
1d51 c3 b8 1c			jp cli 
1d54			 
1d54			enter:	 
1d54 3a fa f0			ld a,(scratch+4) 
1d57 fe 00			cp 0 
1d59 28 0c			jr z, .entercont 
1d5b				; no, not a null term line so has an address to work out.... 
1d5b			 
1d5b 21 f8 f0			ld hl,scratch+2 
1d5e cd 9d 12			call get_word_hl 
1d61			 
1d61 22 19 f4			ld (os_cur_ptr),hl	 
1d64 c3 b8 1c			jp cli 
1d67			 
1d67			 
1d67			.entercont:  
1d67			 
1d67 21 f8 f0			ld hl, scratch+2 
1d6a cd 3d 12			call get_byte 
1d6d			 
1d6d 2a 19 f4		   	ld hl,(os_cur_ptr) 
1d70 77					ld (hl),a 
1d71 23					inc hl 
1d72 22 19 f4				ld (os_cur_ptr),hl 
1d75				 
1d75			; get byte  
1d75			 
1d75			 
1d75 c3 b8 1c			jp cli 
1d78			 
1d78			 
1d78			; basic monitor support 
1d78			 
1d78			monitor: 
1d78				;  
1d78 cd aa 0d			call clear_display 
1d7b 3e 00			ld a, 0 
1d7d 11 d1 1d			ld de, .monprompt 
1d80 cd bd 0d			call str_at_display 
1d83 cd cd 0d			call update_display 
1d86			 
1d86				; get a monitor command 
1d86			 
1d86 0e 00			ld c, 0     ; entry at top left 
1d88 16 64			ld d, 100   ; max buffer size 
1d8a 1e 0f			ld e, 15    ; input scroll area 
1d8c 3e 00			ld a, 0     ; init string 
1d8e 21 f4 f2			ld hl, os_input 
1d91 77				ld (hl), a 
1d92 23				inc hl 
1d93 77				ld (hl), a 
1d94 21 f4 f2			ld hl, os_input 
1d97 3e 01			ld a, 1     ; init string 
1d99 cd 0b 10			call input_str 
1d9c			 
1d9c cd aa 0d		        call clear_display 
1d9f cd cd 0d			call update_display		 
1da2			 
1da2 3a f4 f2			ld a, (os_input) 
1da5 cd 3b 13			call toUpper 
1da8 fe 48		        cp 'H' 
1daa ca 45 1e		        jp z, .monhelp 
1dad fe 44			cp 'D'		; dump 
1daf ca 78 1e			jp z, .mondump	 
1db2 fe 43			cp 'C'		; dump 
1db4 ca 92 1e			jp z, .moncdump	 
1db7 fe 4d			cp 'M'		; dump 
1db9 ca d3 1d			jp z, .moneditstart 
1dbc fe 55			cp 'U'		; dump 
1dbe ca df 1d			jp z, .monedit	 
1dc1 fe 47			cp 'G'		; dump 
1dc3 ca 6e 1e			jp z, .monjump 
1dc6 fe 42			cp 'B'		; forth breakpoint 
1dc8 cc 59 19			call z, break_point_state 
1dcb fe 51			cp 'Q'		; dump 
1dcd c8				ret z	 
1dce			 
1dce			 
1dce				; TODO "S" to access symbol by name and not need the address 
1dce				; TODO "F" to find a string in memory 
1dce			 
1dce c3 78 1d			jp monitor 
1dd1			 
1dd1 .. 00		.monprompt: db ">", 0 
1dd3			 
1dd3			.moneditstart: 
1dd3				; get starting address 
1dd3			 
1dd3 21 f6 f2			ld hl,os_input+2 
1dd6 cd 9d 12			call get_word_hl 
1dd9			 
1dd9 22 19 f4			ld (os_cur_ptr),hl	 
1ddc			 
1ddc c3 78 1d			jp monitor 
1ddf			 
1ddf			.monedit: 
1ddf				; get byte to load 
1ddf			 
1ddf 21 f6 f2			ld hl,os_input+2 
1de2 cd 3d 12			call get_byte 
1de5			 
1de5				; get address to update 
1de5 2a 19 f4			ld hl, (os_cur_ptr) 
1de8			 
1de8				; update byte 
1de8			 
1de8 77				ld (hl), a 
1de9			 
1de9				; move to next address and save it 
1de9			 
1de9 23				inc hl 
1dea 22 19 f4			ld (os_cur_ptr),hl	 
1ded			 
1ded c3 78 1d			jp monitor 
1df0			 
1df0			 
1df0 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1e04 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e20 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1e3e .. 00		.monhelptext4:  db "Q-Quit",0 
1e45			        
1e45			.monhelp: 
1e45 3e 00			ld a, display_row_1 
1e47 11 f0 1d		        ld de, .monhelptext1 
1e4a			 
1e4a cd bd 0d			call str_at_display 
1e4d 3e 28			ld a, display_row_2 
1e4f 11 04 1e		        ld de, .monhelptext2 
1e52					 
1e52 cd bd 0d			call str_at_display 
1e55 3e 50			ld a, display_row_3 
1e57 11 20 1e		        ld de, .monhelptext3 
1e5a					 
1e5a cd bd 0d			call str_at_display 
1e5d 3e 78			ld a, display_row_4 
1e5f 11 3e 1e		        ld de, .monhelptext4 
1e62 cd bd 0d			call str_at_display 
1e65			 
1e65 cd cd 0d			call update_display		 
1e68			 
1e68 cd be 1f			call next_page_prompt 
1e6b c3 78 1d			jp monitor 
1e6e			 
1e6e			.monjump:    
1e6e 21 f6 f2			ld hl,os_input+2 
1e71 cd 9d 12			call get_word_hl 
1e74			 
1e74 e9				jp (hl) 
1e75 c3 78 1d			jp monitor 
1e78			 
1e78			.mondump:    
1e78 21 f6 f2			ld hl,os_input+2 
1e7b cd 9d 12			call get_word_hl 
1e7e			 
1e7e 22 19 f4			ld (os_cur_ptr),hl	 
1e81 cd c6 1e			call dumpcont 
1e84 3e 78			ld a, display_row_4 
1e86 11 24 1d			ld de, endprog 
1e89			 
1e89 cd cd 0d			call update_display		 
1e8c			 
1e8c cd be 1f			call next_page_prompt 
1e8f c3 78 1d			jp monitor 
1e92			.moncdump: 
1e92 cd c6 1e			call dumpcont 
1e95 3e 78			ld a, display_row_4 
1e97 11 24 1d			ld de, endprog 
1e9a			 
1e9a cd cd 0d			call update_display		 
1e9d			 
1e9d cd be 1f			call next_page_prompt 
1ea0 c3 78 1d			jp monitor 
1ea3			 
1ea3			 
1ea3			; TODO symbol access  
1ea3			 
1ea3			.symbols:     ;; A list of symbols that can be called up  
1ea3 e6 fc			dw display_fb0 
1ea5 .. 00			db "fb0",0  
1ea9 af f9		     	dw store_page 
1eab .. 00			db "store_page",0 
1eb6			 
1eb6			 
1eb6			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1eb6			 
1eb6 3a f7 f0			ld a,(scratch+1) 
1eb9 fe 00			cp 0 
1ebb 28 09			jr z, dumpcont 
1ebd			 
1ebd				; no, not a null term line so has an address to work out.... 
1ebd			 
1ebd 21 f8 f0			ld hl,scratch+2 
1ec0 cd 9d 12			call get_word_hl 
1ec3			 
1ec3 22 19 f4			ld (os_cur_ptr),hl	 
1ec6			 
1ec6			 
1ec6			 
1ec6			dumpcont: 
1ec6			 
1ec6				; dump bytes at ptr 
1ec6			 
1ec6			 
1ec6 3e 00			ld a, display_row_1 
1ec8 2a 01 fb			ld hl, (display_fb_active) 
1ecb cd de 0f			call addatohl 
1ece cd f6 1e			call .dumpbyterow 
1ed1			 
1ed1 3e 28			ld a, display_row_2 
1ed3 2a 01 fb			ld hl, (display_fb_active) 
1ed6 cd de 0f			call addatohl 
1ed9 cd f6 1e			call .dumpbyterow 
1edc			 
1edc			 
1edc 3e 50			ld a, display_row_3 
1ede 2a 01 fb			ld hl, (display_fb_active) 
1ee1 cd de 0f			call addatohl 
1ee4 cd f6 1e			call .dumpbyterow 
1ee7			 
1ee7 3e 78			ld a, display_row_4 
1ee9 2a 01 fb			ld hl, (display_fb_active) 
1eec cd de 0f			call addatohl 
1eef cd f6 1e			call .dumpbyterow 
1ef2			 
1ef2 cd cd 0d			call update_display 
1ef5			;		jp cli 
1ef5 c9				ret 
1ef6			 
1ef6			.dumpbyterow: 
1ef6			 
1ef6				;push af 
1ef6			 
1ef6 e5				push hl 
1ef7			 
1ef7				; calc where to poke the ascii 
1ef7			if display_cols == 20 
1ef7				ld a, 16 
1ef7			else 
1ef7 3e 1f			ld a, 31 
1ef9			endif 
1ef9			 
1ef9 cd de 0f			call addatohl 
1efc 22 fb f3			ld (os_word_scratch),hl  		; save pos for later 
1eff			 
1eff			 
1eff			; display decoding address 
1eff 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f02			 
1f02 7c				ld a,h 
1f03 e1				pop hl 
1f04 e5				push hl 
1f05			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f05 cd e7 11			call hexout 
1f08 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f0b			 
1f0b 7d				ld a,l 
1f0c e1				pop hl 
1f0d 23				inc hl 
1f0e 23				inc hl 
1f0f e5				push hl 
1f10			;	ld hl, os_word_scratch+2 
1f10 cd e7 11			call hexout 
1f13 e1				pop hl 
1f14 23				inc hl 
1f15 23				inc hl 
1f16				;ld hl, os_word_scratch+4 
1f16 3e 3a			ld a, ':' 
1f18 77				ld (hl),a 
1f19 23				inc hl 
1f1a				;ld a, 0 
1f1a				;ld (hl),a 
1f1a				;ld de, os_word_scratch 
1f1a				;pop af 
1f1a				;push af 
1f1a			;		ld a, display_row_2 
1f1a			;		call str_at_display 
1f1a			;		call update_display 
1f1a			 
1f1a			 
1f1a			;pop af 
1f1a			;	add 5 
1f1a			 
1f1a			if display_cols == 20 
1f1a				ld b, 4 
1f1a			else 
1f1a 06 08			ld b, 8 
1f1c			endif	 
1f1c			 
1f1c			.dumpbyte: 
1f1c c5				push bc 
1f1d e5				push hl 
1f1e			 
1f1e			 
1f1e 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f21 7e					ld a,(hl) 
1f22			 
1f22					; poke the ascii to display 
1f22 2a fb f3				ld hl,(os_word_scratch) 
1f25 77					ld (hl),a 
1f26 23					inc hl 
1f27 22 fb f3				ld (os_word_scratch),hl 
1f2a			 
1f2a					 
1f2a			 
1f2a			 
1f2a e1					pop hl 
1f2b e5					push hl 
1f2c			 
1f2c cd e7 11				call hexout 
1f2f			 
1f2f					 
1f2f 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f32 23				inc hl 
1f33 22 19 f4		   	ld (os_cur_ptr),hl 
1f36			 
1f36 e1					pop hl 
1f37 23					inc hl 
1f38 23					inc hl 
1f39 23					inc hl 
1f3a			 
1f3a			 
1f3a			 
1f3a					;ld a,0 
1f3a					;ld (os_word_scratch+2),a 
1f3a					;pop af 
1f3a					;push af 
1f3a			 
1f3a					;ld de, os_word_scratch 
1f3a					;call str_at_display 
1f3a			;		call update_display 
1f3a			;		pop af 
1f3a c1					pop bc 
1f3b c6 03				add 3 
1f3d 10 dd			djnz .dumpbyte 
1f3f			 
1f3f				 
1f3f			 
1f3f c9				ret 
1f40			 
1f40			jump:	 
1f40			 
1f40 21 f8 f0			ld hl,scratch+2 
1f43 cd 9d 12			call get_word_hl 
1f46				;ld hl,(scratch+2) 
1f46				;call fourehexhl 
1f46			 
1f46 22 19 f4			ld (os_cur_ptr),hl	 
1f49			 
1f49 e9				jp (hl) 
1f4a			 
1f4a			 
1f4a			 
1f4a			; TODO implement a basic monitor mode to start with 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			; testing and demo code during development 
1f4a			 
1f4a			 
1f4a .. 00		str1: db "Enter some text...",0 
1f5d .. 00		clear: db "                    ",0 
1f72			 
1f72			demo: 
1f72			 
1f72			 
1f72			 
1f72			;	call update_display 
1f72			 
1f72				; init scratch input area for testing 
1f72 21 f6 f0			ld hl, scratch	 
1f75 3e 00			ld a,0 
1f77 77				ld (hl),a 
1f78			 
1f78			 
1f78 3e 28		            LD   A, display_row_2 
1f7a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f7a 11 4a 1f		            LD   DE, str1 
1f7d cd bd 0d			call str_at_display 
1f80			 
1f80			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f80			cloop:	 
1f80 3e 50		            LD   A, display_row_3 
1f82			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f82 11 5d 1f		            LD   DE, clear 
1f85			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f85 cd bd 0d				call str_at_display 
1f88 3e 78			ld a, display_row_4 
1f8a 11 ba 1f			ld de, prompt 
1f8d			 
1f8d cd bd 0d				call str_at_display 
1f90 cd cd 0d			call update_display 
1f93			 
1f93 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f95 16 0a			ld d, 10 
1f97 21 f6 f0			ld hl, scratch	 
1f9a cd 0b 10			call input_str 
1f9d			 
1f9d			;	call clear_display 
1f9d			;'	call update_display 
1f9d			 
1f9d 3e 00		            LD   A, display_row_1 
1f9f			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f9f 11 5d 1f		            LD   DE, clear 
1fa2 cd bd 0d				call str_at_display 
1fa5			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fa5 3e 00		            LD   A, display_row_1 
1fa7			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fa7 11 f6 f0		            LD   DE, scratch 
1faa			;            CALL fLCD_Str       ;Display string pointed to by DE 
1faa cd bd 0d				call str_at_display 
1fad cd cd 0d			call update_display 
1fb0			 
1fb0 3e 00				ld a,0 
1fb2 21 f6 f0			ld hl, scratch 
1fb5 77				ld (hl),a 
1fb6			 
1fb6 00				nop 
1fb7 c3 80 1f			jp cloop 
1fba			 
1fba			 
1fba			 
1fba			; OS Prompt 
1fba			 
1fba .. 00		prompt: db ">",0 
1fbc .. 00		endprg: db "?",0 
1fbe			 
1fbe			 
1fbe			; handy next page prompt 
1fbe			next_page_prompt: 
1fbe e5				push hl 
1fbf d5				push de 
1fc0 f5				push af 
1fc1 c5				push bc 
1fc2			 
1fc2 3e 9f			ld a,display_row_4 + display_cols - 1 
1fc4 11 bc 1f		        ld de, endprg 
1fc7 cd bd 0d			call str_at_display 
1fca cd cd 0d			call update_display 
1fcd cd 0c 73			call cin_wait 
1fd0 c1				pop bc 
1fd1 f1				pop af 
1fd2 d1				pop de 
1fd3 e1				pop hl 
1fd4			 
1fd4			 
1fd4 c9				ret 
1fd5			 
1fd5			 
1fd5			; forth parser 
1fd5			 
1fd5			; My forth kernel 
1fd5			include "forth_kernel.asm" 
1fd5			; 
1fd5			; kernel to the forth OS 
1fd5			 
1fd5			DS_TYPE_STR: equ 1     ; string type 
1fd5			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1fd5			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1fd5			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1fd5			 
1fd5			FORTH_PARSEV1: equ 0 
1fd5			FORTH_PARSEV2: equ 0 
1fd5			FORTH_PARSEV3: equ 0 
1fd5			FORTH_PARSEV4: equ 0 
1fd5			FORTH_PARSEV5: equ 1 
1fd5			 
1fd5			;if FORTH_PARSEV5 
1fd5			;	FORTH_END_BUFFER: equ 0 
1fd5			;else 
1fd5			FORTH_END_BUFFER: equ 127 
1fd5			;endif 
1fd5			 
1fd5			FORTH_TRUE: equ 1 
1fd5			FORTH_FALSE: equ 0 
1fd5			 
1fd5			if FORTH_PARSEV4 
1fd5			include "forth_stackops.asm" 
1fd5			endif 
1fd5			 
1fd5			if FORTH_PARSEV5 
1fd5			include "forth_stackopsv5.asm" 
1fd5			 
1fd5			; Stack operations for v5 parser on wards 
1fd5			; * DATA stack 
1fd5			; * LOOP stack 
1fd5			; * RETURN stack 
1fd5			 
1fd5			 
1fd5			 
1fd5			FORTH_CHK_DSP_UNDER: macro 
1fd5				push hl 
1fd5				push de 
1fd5				ld hl,(cli_data_sp) 
1fd5				ld de, cli_data_stack 
1fd5				call cmp16 
1fd5				jp c, fault_dsp_under 
1fd5				pop de 
1fd5				pop hl 
1fd5				endm 
1fd5			 
1fd5			 
1fd5			FORTH_CHK_RSP_UNDER: macro 
1fd5				push hl 
1fd5				push de 
1fd5				ld hl,(cli_ret_sp) 
1fd5				ld de, cli_ret_stack 
1fd5				call cmp16 
1fd5				jp c, fault_rsp_under 
1fd5				pop de 
1fd5				pop hl 
1fd5				endm 
1fd5			 
1fd5			FORTH_CHK_LOOP_UNDER: macro 
1fd5				push hl 
1fd5				push de 
1fd5				ld hl,(cli_loop_sp) 
1fd5				ld de, cli_loop_stack 
1fd5				call cmp16 
1fd5				jp c, fault_loop_under 
1fd5				pop de 
1fd5				pop hl 
1fd5				endm 
1fd5			 
1fd5			FORTH_ERR_TOS_NOTSTR: macro 
1fd5				; TOSO might need more for checks when used 
1fd5				push af 
1fd5				ld a,(hl) 
1fd5				cp DS_TYPE_STR 
1fd5				jp nz, type_faultn   
1fd5				pop af 
1fd5				endm 
1fd5			 
1fd5			FORTH_ERR_TOS_NOTNUM: macro 
1fd5				push af 
1fd5				ld a,(hl) 
1fd5				cp DS_TYPE_INUM 
1fd5				jp nz, type_faultn   
1fd5				pop af 
1fd5				endm 
1fd5			 
1fd5			 
1fd5			; increase data stack pointer and save hl to it 
1fd5				 
1fd5			FORTH_DSP_NEXT: macro 
1fd5				call macro_forth_dsp_next 
1fd5				endm 
1fd5			 
1fd5			 
1fd5			macro_forth_dsp_next: 
1fd5				if DEBUG_FORTH_STACK_GUARD 
1fd5 cd b0 6b				call check_stacks 
1fd8				endif 
1fd8 e5				push hl 
1fd9 d5				push de 
1fda eb				ex de,hl 
1fdb 2a 23 f9			ld hl,(cli_data_sp) 
1fde 23				inc hl 
1fdf 23				inc hl 
1fe0			 
1fe0			; PARSEV5 
1fe0 23				inc hl 
1fe1 22 23 f9			ld (cli_data_sp),hl 
1fe4 73				ld (hl), e 
1fe5 23				inc hl 
1fe6 72				ld (hl), d 
1fe7 d1				pop de 
1fe8 e1				pop hl 
1fe9				if DEBUG_FORTH_STACK_GUARD 
1fe9 cd b0 6b				call check_stacks 
1fec				endif 
1fec c9				ret 
1fed			 
1fed			 
1fed			; increase ret stack pointer and save hl to it 
1fed				 
1fed			FORTH_RSP_NEXT: macro 
1fed				call macro_forth_rsp_next 
1fed				endm 
1fed			 
1fed			macro_forth_rsp_next: 
1fed				if DEBUG_FORTH_STACK_GUARD 
1fed cd b0 6b				call check_stacks 
1ff0				endif 
1ff0 e5				push hl 
1ff1 d5				push de 
1ff2 eb				ex de,hl 
1ff3 2a 27 f9			ld hl,(cli_ret_sp) 
1ff6 23				inc hl 
1ff7 23				inc hl 
1ff8 22 27 f9			ld (cli_ret_sp),hl 
1ffb 73				ld (hl), e 
1ffc 23				inc hl 
1ffd 72				ld (hl), d 
1ffe d1				pop de 
1fff e1				pop hl 
2000				if DEBUG_FORTH_STACK_GUARD 
2000 cd b0 6b				call check_stacks 
2003				endif 
2003 c9				ret 
2004			 
2004			; get current ret stack pointer and save to hl  
2004				 
2004			FORTH_RSP_TOS: macro 
2004				call macro_forth_rsp_tos 
2004				endm 
2004			 
2004			macro_forth_rsp_tos: 
2004				;push de 
2004 2a 27 f9			ld hl,(cli_ret_sp) 
2007 cd 3f 20			call loadhlptrtohl 
200a				;ld e, (hl) 
200a				;inc hl 
200a				;ld d, (hl) 
200a				;ex de, hl 
200a					if DEBUG_FORTH_WORDS 
200a			;			DMARK "RST" 
200a						CALLMONITOR 
200a cd aa fd			call debug_vector  
200d				endm  
# End of macro CALLMONITOR
200d					endif 
200d				;pop de 
200d c9				ret 
200e			 
200e			; pop ret stack pointer 
200e				 
200e			FORTH_RSP_POP: macro 
200e				call macro_forth_rsp_pop 
200e				endm 
200e			 
200e			 
200e			macro_forth_rsp_pop: 
200e				if DEBUG_FORTH_STACK_GUARD 
200e			;		DMARK "RPP" 
200e cd b0 6b				call check_stacks 
2011					FORTH_CHK_RSP_UNDER 
2011 e5				push hl 
2012 d5				push de 
2013 2a 27 f9			ld hl,(cli_ret_sp) 
2016 11 e1 f8			ld de, cli_ret_stack 
2019 cd fc 0f			call cmp16 
201c da c7 6c			jp c, fault_rsp_under 
201f d1				pop de 
2020 e1				pop hl 
2021				endm 
# End of macro FORTH_CHK_RSP_UNDER
2021				endif 
2021 e5				push hl 
2022 2a 27 f9			ld hl,(cli_ret_sp) 
2025			 
2025			 
2025				if FORTH_ENABLE_FREE 
2025			 
2025					; get pointer 
2025			 
2025					push de 
2025					push hl 
2025			 
2025					ld e, (hl) 
2025					inc hl 
2025					ld d, (hl) 
2025			 
2025					ex de, hl 
2025					call free 
2025			 
2025					pop hl 
2025					pop de 
2025			 
2025			 
2025				endif 
2025			 
2025			 
2025 2b				dec hl 
2026 2b				dec hl 
2027 22 27 f9			ld (cli_ret_sp), hl 
202a				; do stack underflow checks 
202a e1				pop hl 
202b				if DEBUG_FORTH_STACK_GUARD 
202b cd b0 6b				call check_stacks 
202e					FORTH_CHK_RSP_UNDER 
202e e5				push hl 
202f d5				push de 
2030 2a 27 f9			ld hl,(cli_ret_sp) 
2033 11 e1 f8			ld de, cli_ret_stack 
2036 cd fc 0f			call cmp16 
2039 da c7 6c			jp c, fault_rsp_under 
203c d1				pop de 
203d e1				pop hl 
203e				endm 
# End of macro FORTH_CHK_RSP_UNDER
203e				endif 
203e c9				ret 
203f			 
203f			 
203f			 
203f			; routine to load word pointed to by hl into hl 
203f			 
203f			loadhlptrtohl: 
203f			 
203f d5				push de 
2040 5e				ld e, (hl) 
2041 23				inc hl 
2042 56				ld d, (hl) 
2043 eb				ex de, hl 
2044 d1				pop de 
2045			 
2045 c9				ret 
2046			 
2046			 
2046			 
2046			 
2046			 
2046			; push a number held in HL onto the data stack 
2046			; entry point for pushing a value when already in hl used in function above 
2046			 
2046			forth_push_numhl: 
2046			 
2046 e5				push hl    ; save value to push 
2047			 
2047			if DEBUG_FORTH_PUSH 
2047				; see if disabled 
2047			 
2047			 
2047 f5				push af 
2048 3a aa fd			ld a,(debug_vector) 
204b fe c9			cp $c9   ; ret 
204d			;	ld a, (os_view_disable) 
204d			;	cp '*' 
204d 28 34			jr z, .pskip2 
204f e5				push hl 
2050 e5			push hl 
2051 cd aa 0d			call clear_display 
2054 e1			pop hl 
2055 7c				ld a,h 
2056 21 fb f3			ld hl, os_word_scratch 
2059 cd e7 11			call hexout 
205c e1				pop hl 
205d 7d				ld a,l 
205e 21 fd f3			ld hl, os_word_scratch+2 
2061 cd e7 11			call hexout 
2064			 
2064 21 ff f3			ld hl, os_word_scratch+4 
2067 3e 00			ld a,0 
2069 77				ld (hl),a 
206a 11 fb f3			ld de,os_word_scratch 
206d 3e 28				ld a, display_row_2 
206f cd bd 0d				call str_at_display 
2072 11 be 5d			ld de, .push_num 
2075 3e 00			ld a, display_row_1 
2077			 
2077 cd bd 0d				call str_at_display 
207a			 
207a			 
207a cd cd 0d			call update_display 
207d cd ed 0c			call delay1s 
2080 cd ed 0c			call delay1s 
2083			.pskip2:  
2083			 
2083 f1				pop af 
2084			endif	 
2084			 
2084			 
2084				FORTH_DSP_NEXT 
2084 cd d5 1f			call macro_forth_dsp_next 
2087				endm 
# End of macro FORTH_DSP_NEXT
2087			 
2087 2a 23 f9			ld hl, (cli_data_sp) 
208a			 
208a				; save item type 
208a 3e 02			ld a,  DS_TYPE_INUM 
208c 77				ld (hl), a 
208d 23				inc hl 
208e			 
208e				; get word off stack 
208e d1				pop de 
208f 7b				ld a,e 
2090 77				ld (hl), a 
2091 23				inc hl 
2092 7a				ld a,d 
2093 77				ld (hl), a 
2094			 
2094			if DEBUG_FORTH_PUSH 
2094 2b				dec hl 
2095 2b				dec hl 
2096 2b				dec hl 
2097						DMARK "PH5" 
2097 f5				push af  
2098 3a ac 20			ld a, (.dmark)  
209b 32 a0 fd			ld (debug_mark),a  
209e 3a ad 20			ld a, (.dmark+1)  
20a1 32 a1 fd			ld (debug_mark+1),a  
20a4 3a ae 20			ld a, (.dmark+2)  
20a7 32 a2 fd			ld (debug_mark+2),a  
20aa 18 03			jr .pastdmark  
20ac ..			.dmark: db "PH5"  
20af f1			.pastdmark: pop af  
20b0			endm  
# End of macro DMARK
20b0				CALLMONITOR 
20b0 cd aa fd			call debug_vector  
20b3				endm  
# End of macro CALLMONITOR
20b3			endif	 
20b3			 
20b3 c9				ret 
20b4			 
20b4			 
20b4			; Push a string to stack pointed to by hl 
20b4			 
20b4			forth_push_str: 
20b4			 
20b4			if DEBUG_FORTH_PUSH 
20b4						DMARK "PSQ" 
20b4 f5				push af  
20b5 3a c9 20			ld a, (.dmark)  
20b8 32 a0 fd			ld (debug_mark),a  
20bb 3a ca 20			ld a, (.dmark+1)  
20be 32 a1 fd			ld (debug_mark+1),a  
20c1 3a cb 20			ld a, (.dmark+2)  
20c4 32 a2 fd			ld (debug_mark+2),a  
20c7 18 03			jr .pastdmark  
20c9 ..			.dmark: db "PSQ"  
20cc f1			.pastdmark: pop af  
20cd			endm  
# End of macro DMARK
20cd				CALLMONITOR 
20cd cd aa fd			call debug_vector  
20d0				endm  
# End of macro CALLMONITOR
20d0			endif	 
20d0			 
20d0			 
20d0			    
20d0 e5				push hl 
20d1 e5				push hl 
20d2			 
20d2			;	ld a, 0   ; find end of string 
20d2 cd 44 13			call strlenz 
20d5			if DEBUG_FORTH_PUSH 
20d5						DMARK "PQ2" 
20d5 f5				push af  
20d6 3a ea 20			ld a, (.dmark)  
20d9 32 a0 fd			ld (debug_mark),a  
20dc 3a eb 20			ld a, (.dmark+1)  
20df 32 a1 fd			ld (debug_mark+1),a  
20e2 3a ec 20			ld a, (.dmark+2)  
20e5 32 a2 fd			ld (debug_mark+2),a  
20e8 18 03			jr .pastdmark  
20ea ..			.dmark: db "PQ2"  
20ed f1			.pastdmark: pop af  
20ee			endm  
# End of macro DMARK
20ee				CALLMONITOR 
20ee cd aa fd			call debug_vector  
20f1				endm  
# End of macro CALLMONITOR
20f1			endif	 
20f1 eb				ex de, hl 
20f2 e1				pop hl   ; get ptr to start of string 
20f3			if DEBUG_FORTH_PUSH 
20f3						DMARK "PQ3" 
20f3 f5				push af  
20f4 3a 08 21			ld a, (.dmark)  
20f7 32 a0 fd			ld (debug_mark),a  
20fa 3a 09 21			ld a, (.dmark+1)  
20fd 32 a1 fd			ld (debug_mark+1),a  
2100 3a 0a 21			ld a, (.dmark+2)  
2103 32 a2 fd			ld (debug_mark+2),a  
2106 18 03			jr .pastdmark  
2108 ..			.dmark: db "PQ3"  
210b f1			.pastdmark: pop af  
210c			endm  
# End of macro DMARK
210c				CALLMONITOR 
210c cd aa fd			call debug_vector  
210f				endm  
# End of macro CALLMONITOR
210f			endif	 
210f 19				add hl,de 
2110			if DEBUG_FORTH_PUSH 
2110						DMARK "PQE" 
2110 f5				push af  
2111 3a 25 21			ld a, (.dmark)  
2114 32 a0 fd			ld (debug_mark),a  
2117 3a 26 21			ld a, (.dmark+1)  
211a 32 a1 fd			ld (debug_mark+1),a  
211d 3a 27 21			ld a, (.dmark+2)  
2120 32 a2 fd			ld (debug_mark+2),a  
2123 18 03			jr .pastdmark  
2125 ..			.dmark: db "PQE"  
2128 f1			.pastdmark: pop af  
2129			endm  
# End of macro DMARK
2129				CALLMONITOR 
2129 cd aa fd			call debug_vector  
212c				endm  
# End of macro CALLMONITOR
212c			endif	 
212c			 
212c 2b				dec hl    ; see if there is an optional trailing double quote 
212d 7e				ld a,(hl) 
212e fe 22			cp '"' 
2130 20 03			jr nz, .strnoq 
2132 3e 00			ld a, 0      ; get rid of double quote 
2134 77				ld (hl), a 
2135 23			.strnoq: inc hl 
2136			 
2136 3e 00			ld a, 0 
2138 77				ld (hl), a     ; add null term and get rid of trailing double quote 
2139			 
2139 13				inc de ; add one for the type string 
213a 13				inc de ; add one for null term??? 
213b			 
213b				; tos is get string pointer again 
213b				; de contains space to allocate 
213b				 
213b d5				push de 
213c			 
213c eb				ex de, hl 
213d			 
213d				;push af 
213d			 
213d			if DEBUG_FORTH_PUSH 
213d						DMARK "PHm" 
213d f5				push af  
213e 3a 52 21			ld a, (.dmark)  
2141 32 a0 fd			ld (debug_mark),a  
2144 3a 53 21			ld a, (.dmark+1)  
2147 32 a1 fd			ld (debug_mark+1),a  
214a 3a 54 21			ld a, (.dmark+2)  
214d 32 a2 fd			ld (debug_mark+2),a  
2150 18 03			jr .pastdmark  
2152 ..			.dmark: db "PHm"  
2155 f1			.pastdmark: pop af  
2156			endm  
# End of macro DMARK
2156				CALLMONITOR 
2156 cd aa fd			call debug_vector  
2159				endm  
# End of macro CALLMONITOR
2159			endif	 
2159 cd b9 13			call malloc	; on ret hl now contains allocated memory 
215c				if DEBUG_FORTH_MALLOC_GUARD 
215c cc 16 5e				call z,malloc_error 
215f				endif 
215f			 
215f				 
215f c1				pop bc    ; get length 
2160 d1				pop de   ;  get string start    
2161			 
2161				; hl has destination from malloc 
2161			 
2161 eb				ex de, hl    ; prep for ldir 
2162			 
2162 d5				push de   ; save malloc area for DSP later 
2163				;push hl   ; save malloc area for DSP later 
2163			 
2163			if DEBUG_FORTH_PUSH 
2163						DMARK "PHc" 
2163 f5				push af  
2164 3a 78 21			ld a, (.dmark)  
2167 32 a0 fd			ld (debug_mark),a  
216a 3a 79 21			ld a, (.dmark+1)  
216d 32 a1 fd			ld (debug_mark+1),a  
2170 3a 7a 21			ld a, (.dmark+2)  
2173 32 a2 fd			ld (debug_mark+2),a  
2176 18 03			jr .pastdmark  
2178 ..			.dmark: db "PHc"  
217b f1			.pastdmark: pop af  
217c			endm  
# End of macro DMARK
217c				CALLMONITOR 
217c cd aa fd			call debug_vector  
217f				endm  
# End of macro CALLMONITOR
217f			endif	 
217f			 
217f			 
217f ed b0			ldir 
2181			 
2181			 
2181				; push malloc to data stack     macro?????  
2181			 
2181				FORTH_DSP_NEXT 
2181 cd d5 1f			call macro_forth_dsp_next 
2184				endm 
# End of macro FORTH_DSP_NEXT
2184			 
2184				; save value and type 
2184			 
2184 2a 23 f9			ld hl, (cli_data_sp) 
2187			 
2187				; save item type 
2187 3e 01			ld a,  DS_TYPE_STR 
2189 77				ld (hl), a 
218a 23				inc hl 
218b			 
218b				; get malloc word off stack 
218b d1				pop de 
218c 73				ld (hl), e 
218d 23				inc hl 
218e 72				ld (hl), d 
218f			 
218f			 
218f			 
218f			if DEBUG_FORTH_PUSH 
218f 2a 23 f9			ld hl, (cli_data_sp) 
2192						DMARK "PHS" 
2192 f5				push af  
2193 3a a7 21			ld a, (.dmark)  
2196 32 a0 fd			ld (debug_mark),a  
2199 3a a8 21			ld a, (.dmark+1)  
219c 32 a1 fd			ld (debug_mark+1),a  
219f 3a a9 21			ld a, (.dmark+2)  
21a2 32 a2 fd			ld (debug_mark+2),a  
21a5 18 03			jr .pastdmark  
21a7 ..			.dmark: db "PHS"  
21aa f1			.pastdmark: pop af  
21ab			endm  
# End of macro DMARK
21ab				CALLMONITOR 
21ab cd aa fd			call debug_vector  
21ae				endm  
# End of macro CALLMONITOR
21ae			;	ex de,hl 
21ae			endif	 
21ae				; in case of spaces, skip the ptr past the copied string 
21ae				;pop af 
21ae				;ld (cli_origptr),hl 
21ae			 
21ae c9				ret 
21af			 
21af			 
21af			 
21af			; TODO ascii push input onto stack given hl to start of input 
21af			 
21af			; identify type 
21af			; if starts with a " then a string 
21af			; otherwise it is a number 
21af			;  
21af			; if a string 
21af			;     scan for ending " to get length of string to malloc for + 1 
21af			;     malloc 
21af			;     put pointer to string on stack first byte flags as string 
21af			; 
21af			; else a number 
21af			;    look for number format identifier 
21af			;    $xx hex 
21af			;    %xxxxx bin 
21af			;    xxxxx decimal 
21af			;    convert number to 16bit word.  
21af			;    malloc word + 1 with flag to identiy as num 
21af			;    put pointer to number on stack 
21af			;   
21af			;  
21af			  
21af			forth_apush: 
21af				; kernel push 
21af			 
21af			if DEBUG_FORTH_PUSH 
21af						DMARK "PSH" 
21af f5				push af  
21b0 3a c4 21			ld a, (.dmark)  
21b3 32 a0 fd			ld (debug_mark),a  
21b6 3a c5 21			ld a, (.dmark+1)  
21b9 32 a1 fd			ld (debug_mark+1),a  
21bc 3a c6 21			ld a, (.dmark+2)  
21bf 32 a2 fd			ld (debug_mark+2),a  
21c2 18 03			jr .pastdmark  
21c4 ..			.dmark: db "PSH"  
21c7 f1			.pastdmark: pop af  
21c8			endm  
# End of macro DMARK
21c8				CALLMONITOR 
21c8 cd aa fd			call debug_vector  
21cb				endm  
# End of macro CALLMONITOR
21cb			endif	 
21cb				; identify input type 
21cb			 
21cb 7e				ld a,(hl) 
21cc			 
21cc fe 23			cp '#' 
21ce ca 08 22			jp z, .fapdec 
21d1			 
21d1			 
21d1 fe 22			cp '"' 
21d3 28 0a			jr z, .fapstr 
21d5 fe 24			cp '$' 
21d7 ca ff 21			jp z, .faphex 
21da fe 25			cp '%' 
21dc ca e7 21			jp z, .fapbin 
21df			;	cp 'b' 
21df			;	jp z, .fabin 
21df				; else decimal 
21df			 
21df				; TODO do decimal conversion 
21df				; decimal is stored as a 16bit word 
21df			 
21df				; by default everything is a string if type is not detected 
21df			.fapstr: ; 
21df fe 22			cp '"' 
21e1 20 01			jr nz, .strnoqu 
21e3 23				inc hl 
21e4			.strnoqu: 
21e4 c3 b4 20			jp forth_push_str 
21e7			 
21e7			 
21e7			 
21e7			.fapbin:    ; push a binary string.  
21e7 11 00 00			ld de, 0   ; hold a 16bit value 
21ea			 
21ea 23			.fapbinshift:	inc hl  
21eb 7e				ld a,(hl) 
21ec fe 00			cp 0     ; done scanning  
21ee 28 0b			jr z, .fapbdone  	; got it in HL so push  
21f0			 
21f0				; left shift de 
21f0 eb				ex de, hl	 
21f1 29				add hl, hl 
21f2			 
21f2				; is 1 
21f2 fe 31			cp '1' 
21f4 20 02			jr nz, .binzero 
21f6 cb 4d			bit 1, l 
21f8			.binzero: 
21f8 eb				ex de, hl	 ; save current de 
21f9 18 ef			jr .fapbinshift 
21fb			 
21fb			.fapbdone: 
21fb eb				ex de, hl 
21fc c3 46 20			jp forth_push_numhl 
21ff			 
21ff			 
21ff			.faphex:   ; hex is always stored as a 16bit word 
21ff				; skip number prefix 
21ff 23				inc hl 
2200				; turn ascii into number 
2200 cd 9d 12			call get_word_hl	; ret 16bit word in hl 
2203			 
2203 c3 46 20			jp forth_push_numhl 
2206			 
2206 00				 nop 
2207			 
2207			.fabin:   ; TODO bin conversion 
2207			 
2207			 
2207 c9				ret 
2208			.fapdec:	 
2208				; string to dec conversion 
2208 23				inc hl 
2209 eb				ex de, hl 
220a cd db 12			call string_to_uint16 
220d c3 46 20			jp forth_push_numhl 
2210 c9				ret 
2211				 
2211			;atoui_16: 
2211			 
2211			; get either a string ptr or a 16bit word from the data stack 
2211			 
2211			FORTH_DSP: macro 
2211				call macro_forth_dsp 
2211				endm 
2211			 
2211			macro_forth_dsp: 
2211				; data stack pointer points to current word on tos 
2211			 
2211 2a 23 f9			ld hl,(cli_data_sp) 
2214			 
2214				if DEBUG_FORTH_PUSH 
2214						DMARK "DSP" 
2214 f5				push af  
2215 3a 29 22			ld a, (.dmark)  
2218 32 a0 fd			ld (debug_mark),a  
221b 3a 2a 22			ld a, (.dmark+1)  
221e 32 a1 fd			ld (debug_mark+1),a  
2221 3a 2b 22			ld a, (.dmark+2)  
2224 32 a2 fd			ld (debug_mark+2),a  
2227 18 03			jr .pastdmark  
2229 ..			.dmark: db "DSP"  
222c f1			.pastdmark: pop af  
222d			endm  
# End of macro DMARK
222d			 
222d cd 49 5e				call display_data_sp 
2230				;call break_point_state 
2230				;rst 030h 
2230				CALLMONITOR 
2230 cd aa fd			call debug_vector  
2233				endm  
# End of macro CALLMONITOR
2233				endif 
2233			 
2233 c9				ret 
2234			 
2234			; return hl to start of value on stack 
2234			 
2234			FORTH_DSP_VALUE: macro 
2234				call macro_forth_dsp_value 
2234				endm 
2234			 
2234			macro_forth_dsp_value: 
2234			 
2234				FORTH_DSP 
2234 cd 11 22			call macro_forth_dsp 
2237				endm 
# End of macro FORTH_DSP
2237			 
2237 d5				push de 
2238			 
2238 23				inc hl ; skip type 
2239			 
2239 5e				ld e, (hl) 
223a 23				inc hl 
223b 56				ld d, (hl) 
223c eb				ex de,hl  
223d			 
223d d1				pop de 
223e			 
223e c9				ret 
223f			 
223f			; return hl to start of value to second item on stack 
223f			 
223f			FORTH_DSP_VALUEM1: macro 
223f				call macro_forth_dsp_value_m1 
223f				endm 
223f			 
223f			macro_forth_dsp_value_m1: 
223f			 
223f				FORTH_DSP 
223f cd 11 22			call macro_forth_dsp 
2242				endm 
# End of macro FORTH_DSP
2242			 
2242 2b				dec hl 
2243 2b				dec hl 
2244			;	dec hl 
2244			 
2244 d5				push de 
2245			 
2245 5e				ld e, (hl) 
2246 23				inc hl 
2247 56				ld d, (hl) 
2248 eb				ex de,hl  
2249			 
2249 d1				pop de 
224a			 
224a c9				ret 
224b			 
224b				 
224b			 
224b			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
224b			 
224b			FORTH_DSP_POP: macro 
224b				call macro_forth_dsp_pop 
224b				endm 
224b			 
224b			 
224b			; get the tos data type 
224b			 
224b			FORTH_DSP_TYPE:   macro 
224b			 
224b				;FORTH_DSP_VALUE 
224b				FORTH_DSP 
224b				 
224b				; hl points to value 
224b				; check type 
224b			 
224b				ld a,(hl) 
224b			 
224b				endm 
224b			 
224b			; load the tos value into hl 
224b			 
224b			 
224b			FORTH_DSP_VALUEHL:  macro 
224b				call macro_dsp_valuehl 
224b				endm 
224b			 
224b			 
224b			 
224b			macro_dsp_valuehl: 
224b				FORTH_DSP_VALUE 
224b cd 34 22			call macro_forth_dsp_value 
224e				endm 
# End of macro FORTH_DSP_VALUE
224e			 
224e				;FORTH_ERR_TOS_NOTNUM 
224e			 
224e				;inc hl   ; skip type id 
224e			 
224e			;	push de 
224e			; 
224e			;	ld e, (hl) 
224e			;	inc hl 
224e			;	ld d, (hl) 
224e			;	ex de,hl  
224e			 
224e			;	pop de 
224e			 
224e				if DEBUG_FORTH_PUSH 
224e						DMARK "DVL" 
224e f5				push af  
224f 3a 63 22			ld a, (.dmark)  
2252 32 a0 fd			ld (debug_mark),a  
2255 3a 64 22			ld a, (.dmark+1)  
2258 32 a1 fd			ld (debug_mark+1),a  
225b 3a 65 22			ld a, (.dmark+2)  
225e 32 a2 fd			ld (debug_mark+2),a  
2261 18 03			jr .pastdmark  
2263 ..			.dmark: db "DVL"  
2266 f1			.pastdmark: pop af  
2267			endm  
# End of macro DMARK
2267				CALLMONITOR 
2267 cd aa fd			call debug_vector  
226a				endm  
# End of macro CALLMONITOR
226a				endif 
226a c9				ret 
226b			 
226b			forth_apushstrhl:      
226b				; push of string requires use of cli_origptr 
226b				; bodge use 
226b			 
226b				; get current cli_origptr, save, update with temp pointer  
226b ed 5b 73 f9		ld de, (cli_origptr) 
226f 22 73 f9			ld (cli_origptr), hl 
2272 d5				push de 
2273 cd af 21			call forth_apush 
2276 d1				pop de 
2277 ed 53 73 f9		ld (cli_origptr), de 
227b c9			        ret	 
227c			 
227c			 
227c			; increase loop stack pointer and save hl to it 
227c				 
227c			FORTH_LOOP_NEXT: macro 
227c				call macro_forth_loop_next 
227c				;nop 
227c				endm 
227c			 
227c			macro_forth_loop_next: 
227c				if DEBUG_FORTH_STACK_GUARD 
227c cd b0 6b				call check_stacks 
227f				endif 
227f e5				push hl 
2280 d5				push de 
2281 eb				ex de,hl 
2282 2a 25 f9			ld hl,(cli_loop_sp) 
2285 23				inc hl 
2286 23				inc hl 
2287					if DEBUG_FORTH_WORDS 
2287						DMARK "LNX" 
2287 f5				push af  
2288 3a 9c 22			ld a, (.dmark)  
228b 32 a0 fd			ld (debug_mark),a  
228e 3a 9d 22			ld a, (.dmark+1)  
2291 32 a1 fd			ld (debug_mark+1),a  
2294 3a 9e 22			ld a, (.dmark+2)  
2297 32 a2 fd			ld (debug_mark+2),a  
229a 18 03			jr .pastdmark  
229c ..			.dmark: db "LNX"  
229f f1			.pastdmark: pop af  
22a0			endm  
# End of macro DMARK
22a0						CALLMONITOR 
22a0 cd aa fd			call debug_vector  
22a3				endm  
# End of macro CALLMONITOR
22a3					endif 
22a3 22 25 f9			ld (cli_loop_sp),hl 
22a6 73				ld (hl), e 
22a7 23				inc hl 
22a8 72				ld (hl), d 
22a9 d1				pop de    ; been reversed so save a swap on restore 
22aa e1				pop hl 
22ab				if DEBUG_FORTH_STACK_GUARD 
22ab cd b0 6b				call check_stacks 
22ae				endif 
22ae c9				ret 
22af			 
22af			; get current ret stack pointer and save to hl  
22af				 
22af			FORTH_LOOP_TOS: macro 
22af				call macro_forth_loop_tos 
22af				endm 
22af			 
22af			macro_forth_loop_tos: 
22af d5				push de 
22b0 2a 25 f9			ld hl,(cli_loop_sp) 
22b3 5e				ld e, (hl) 
22b4 23				inc hl 
22b5 56				ld d, (hl) 
22b6 eb				ex de, hl 
22b7 d1				pop de 
22b8 c9				ret 
22b9			 
22b9			; pop loop stack pointer 
22b9				 
22b9			FORTH_LOOP_POP: macro 
22b9				call macro_forth_loop_pop 
22b9				endm 
22b9			 
22b9			 
22b9			macro_forth_loop_pop: 
22b9				if DEBUG_FORTH_STACK_GUARD 
22b9					DMARK "LPP" 
22b9 f5				push af  
22ba 3a ce 22			ld a, (.dmark)  
22bd 32 a0 fd			ld (debug_mark),a  
22c0 3a cf 22			ld a, (.dmark+1)  
22c3 32 a1 fd			ld (debug_mark+1),a  
22c6 3a d0 22			ld a, (.dmark+2)  
22c9 32 a2 fd			ld (debug_mark+2),a  
22cc 18 03			jr .pastdmark  
22ce ..			.dmark: db "LPP"  
22d1 f1			.pastdmark: pop af  
22d2			endm  
# End of macro DMARK
22d2 cd b0 6b				call check_stacks 
22d5					FORTH_CHK_LOOP_UNDER 
22d5 e5				push hl 
22d6 d5				push de 
22d7 2a 25 f9			ld hl,(cli_loop_sp) 
22da 11 5f f8			ld de, cli_loop_stack 
22dd cd fc 0f			call cmp16 
22e0 da cd 6c			jp c, fault_loop_under 
22e3 d1				pop de 
22e4 e1				pop hl 
22e5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22e5				endif 
22e5 e5				push hl 
22e6 2a 25 f9			ld hl,(cli_loop_sp) 
22e9 2b				dec hl 
22ea 2b				dec hl 
22eb 22 25 f9			ld (cli_loop_sp), hl 
22ee				; TODO do stack underflow checks 
22ee e1				pop hl 
22ef				if DEBUG_FORTH_STACK_GUARD 
22ef cd b0 6b				call check_stacks 
22f2					FORTH_CHK_LOOP_UNDER 
22f2 e5				push hl 
22f3 d5				push de 
22f4 2a 25 f9			ld hl,(cli_loop_sp) 
22f7 11 5f f8			ld de, cli_loop_stack 
22fa cd fc 0f			call cmp16 
22fd da cd 6c			jp c, fault_loop_under 
2300 d1				pop de 
2301 e1				pop hl 
2302				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2302				endif 
2302 c9				ret 
2303			 
2303			macro_forth_dsp_pop: 
2303			 
2303 e5				push hl 
2304			 
2304				; release malloc data 
2304			 
2304				if DEBUG_FORTH_STACK_GUARD 
2304 cd b0 6b				call check_stacks 
2307					FORTH_CHK_DSP_UNDER 
2307 e5				push hl 
2308 d5				push de 
2309 2a 23 f9			ld hl,(cli_data_sp) 
230c 11 5d f6			ld de, cli_data_stack 
230f cd fc 0f			call cmp16 
2312 da c1 6c			jp c, fault_dsp_under 
2315 d1				pop de 
2316 e1				pop hl 
2317				endm 
# End of macro FORTH_CHK_DSP_UNDER
2317				endif 
2317				;ld hl,(cli_data_sp) 
2317			if DEBUG_FORTH_DOT 
2317				DMARK "DPP" 
2317 f5				push af  
2318 3a 2c 23			ld a, (.dmark)  
231b 32 a0 fd			ld (debug_mark),a  
231e 3a 2d 23			ld a, (.dmark+1)  
2321 32 a1 fd			ld (debug_mark+1),a  
2324 3a 2e 23			ld a, (.dmark+2)  
2327 32 a2 fd			ld (debug_mark+2),a  
232a 18 03			jr .pastdmark  
232c ..			.dmark: db "DPP"  
232f f1			.pastdmark: pop af  
2330			endm  
# End of macro DMARK
2330				CALLMONITOR 
2330 cd aa fd			call debug_vector  
2333				endm  
# End of macro CALLMONITOR
2333			endif	 
2333			 
2333			 
2333			if FORTH_ENABLE_DSPPOPFREE 
2333			 
2333				FORTH_DSP 
2333 cd 11 22			call macro_forth_dsp 
2336				endm 
# End of macro FORTH_DSP
2336			 
2336 7e				ld a, (hl) 
2337 fe 01			cp DS_TYPE_STR 
2339 20 23			jr nz, .skippopfree 
233b			 
233b				FORTH_DSP_VALUEHL 
233b cd 4b 22			call macro_dsp_valuehl 
233e				endm 
# End of macro FORTH_DSP_VALUEHL
233e 00				nop 
233f			if DEBUG_FORTH_DOT 
233f				DMARK "DPf" 
233f f5				push af  
2340 3a 54 23			ld a, (.dmark)  
2343 32 a0 fd			ld (debug_mark),a  
2346 3a 55 23			ld a, (.dmark+1)  
2349 32 a1 fd			ld (debug_mark+1),a  
234c 3a 56 23			ld a, (.dmark+2)  
234f 32 a2 fd			ld (debug_mark+2),a  
2352 18 03			jr .pastdmark  
2354 ..			.dmark: db "DPf"  
2357 f1			.pastdmark: pop af  
2358			endm  
# End of macro DMARK
2358				CALLMONITOR 
2358 cd aa fd			call debug_vector  
235b				endm  
# End of macro CALLMONITOR
235b			endif	 
235b cd 83 14			call free 
235e			.skippopfree: 
235e				 
235e			 
235e			endif 
235e			 
235e			if DEBUG_FORTH_DOT_KEY 
235e				DMARK "DP2" 
235e				CALLMONITOR 
235e			endif	 
235e			 
235e				; move pointer down 
235e			 
235e 2a 23 f9			ld hl,(cli_data_sp) 
2361 2b				dec hl 
2362 2b				dec hl 
2363			; PARSEV5 
2363 2b				dec hl 
2364 22 23 f9			ld (cli_data_sp), hl 
2367			 
2367				if DEBUG_FORTH_STACK_GUARD 
2367 cd b0 6b				call check_stacks 
236a					FORTH_CHK_DSP_UNDER 
236a e5				push hl 
236b d5				push de 
236c 2a 23 f9			ld hl,(cli_data_sp) 
236f 11 5d f6			ld de, cli_data_stack 
2372 cd fc 0f			call cmp16 
2375 da c1 6c			jp c, fault_dsp_under 
2378 d1				pop de 
2379 e1				pop hl 
237a				endm 
# End of macro FORTH_CHK_DSP_UNDER
237a				endif 
237a			 
237a e1				pop hl 
237b			 
237b c9				ret 
237c			 
237c			getwordathl: 
237c				; hl points to an address 
237c				; load hl with the word at that address 
237c			 
237c d5				push de 
237d			 
237d 5e				ld e, (hl) 
237e 23				inc hl 
237f 56				ld d, (hl) 
2380 eb				ex de, hl 
2381			 
2381 d1				pop de 
2382 c9				ret 
2383			 
2383			 
2383			; functions to manuplite stack points 
2383			 
2383			; copy point in hl to stack tmp storage slots 1-4 
2383			hltostack1: 
2383 11 f3 f0			ld de, os_stack_1  
2386 c3 b1 23			jp hltostackmv 
2389			 
2389			hltostack2:  
2389 11 f0 f0			ld de, os_stack_2 
238c c3 b1 23			jp hltostackmv 
238f			 
238f			hltostack3:  
238f 11 ed f0			ld de, os_stack_3 
2392 c3 b1 23			jp hltostackmv 
2395			 
2395			hltostack4:  
2395 11 ea f0			ld de, os_stack_4  
2398 c3 b1 23			jp hltostackmv 
239b			 
239b			; copy to point in hl from stack tmp storage slots 1-4 
239b			hlfromstack1: 
239b 11 f3 f0			ld de, os_stack_1 
239e c3 b0 23			jp hlfromsttackmv 
23a1			 
23a1			hlfromstack2:  
23a1 11 f0 f0			ld de, os_stack_2 
23a4 c3 b0 23			jp hlfromsttackmv 
23a7			 
23a7			hlfromstack3:  
23a7 11 ed f0			ld de, os_stack_3 
23aa c3 b0 23			jp hlfromsttackmv 
23ad			 
23ad			hlfromstack4:  
23ad 11 ea f0			ld de, os_stack_4 
23b0			 
23b0			hlfromsttackmv: 
23b0 eb				ex de, hl 
23b1			 
23b1			hltostackmv: 
23b1			 
23b1				; do stack move 
23b1 c5				push bc 
23b2 01 03 00			ld bc, 3 
23b5 ed b0			ldir  
23b7 c1				pop bc	 
23b8 c9				ret 
23b9			 
23b9			; eof 
23b9			 
# End of file forth_stackopsv5.asm
23b9			endif 
23b9			 
23b9			loadwordinhl:	 
23b9			 
23b9 d5				push de 
23ba			 
23ba 5e				ld e, (hl) 
23bb 23				inc hl 
23bc 56				ld d, (hl) 
23bd eb				ex de,hl  
23be			 
23be d1				pop de 
23bf			 
23bf c9				ret 
23c0			 
23c0			user_word_eol:  
23c0				; hl contains the pointer to where to create a linked list item from the end 
23c0				; of the user dict to continue on at the system word dict 
23c0				 
23c0				; poke the stub of the word list linked list to repoint to rom words 
23c0			 
23c0				; stub format 
23c0				; db   word id 
23c0				; dw    link to next word 
23c0			        ; db char length of token 
23c0				; db string + 0 term 
23c0				; db exec code....  
23c0			 
23c0 3e 00			ld a, WORD_SYS_ROOT     ; root word 
23c2 77				ld (hl), a		; word id 
23c3 23				inc hl 
23c4			 
23c4 11 8f 25			ld de, sysdict 
23c7 73				ld (hl), e		; next word link ie system dict 
23c8 23				inc hl 
23c9 72				ld (hl), d		; next word link ie system dict 
23ca 23				inc hl	 
23cb			 
23cb			;	ld (hl), sysdict		; next word link ie system dict 
23cb			;	inc hl 
23cb			;	inc hl 
23cb			 
23cb			;	inc hl 
23cb			;	inc hl 
23cb			 
23cb 3e 02			ld a, 2			; word length is 0 
23cd 77				ld (hl), a	 
23ce 23				inc hl 
23cf			 
23cf 3e 7e			ld a, '~'			; word length is 0 
23d1 77				ld (hl), a	 
23d2 23				inc hl 
23d3 3e 00			ld a, 0			; save empty word 
23d5 77				ld (hl), a 
23d6			 
23d6 c9				ret 
23d7			 
23d7				 
23d7			 
23d7			forthexec_cleanup: 
23d7				FORTH_RSP_POP 
23d7 cd 0e 20			call macro_forth_rsp_pop 
23da				endm 
# End of macro FORTH_RSP_POP
23da c9				ret 
23db			 
23db			forth_call_hl: 
23db				; taking hl 
23db e5				push hl 
23dc c9				ret 
23dd			 
23dd			; this is called to reset Forth system but keep existing uwords etc 
23dd			 
23dd			forth_warmstart: 
23dd				; setup stack over/under flow checks 
23dd				if DEBUG_FORTH_STACK_GUARD 
23dd cd 96 6b				call chk_stk_init 
23e0				endif 
23e0			 
23e0				; init stack pointers  - * these stacks go upwards *  
23e0 21 e1 f8			ld hl, cli_ret_stack 
23e3 22 27 f9			ld (cli_ret_sp), hl	 
23e6				; set bottom of stack 
23e6 3e 00			ld a,0 
23e8 77				ld (hl),a 
23e9 23				inc hl 
23ea 77				ld (hl),a 
23eb			 
23eb 21 5d f6			ld hl, cli_data_stack 
23ee 22 23 f9			ld (cli_data_sp), hl	 
23f1				; set bottom of stack 
23f1 3e 00			ld a,0 
23f3 77				ld (hl),a 
23f4 23				inc hl 
23f5 77				ld (hl),a 
23f6			 
23f6 21 5f f8			ld hl, cli_loop_stack 
23f9 22 25 f9			ld (cli_loop_sp), hl	 
23fc				; set bottom of stack 
23fc 3e 00			ld a,0 
23fe 77				ld (hl),a 
23ff 23				inc hl 
2400 77				ld (hl),a 
2401			 
2401				; init extent of current open file 
2401			 
2401 3e 00			ld a, 0 
2403 32 9f f9			ld (store_openext), a 
2406			 
2406 c9				ret 
2407			 
2407			 
2407			 
2407			; Cold Start - this is called to setup the whole Forth system 
2407			 
2407			forth_init: 
2407			 
2407				; setup stack over/under flow checks 
2407			 
2407			;	if DEBUG_FORTH_STACK_GUARD 
2407			;		call chk_stk_init 
2407			;	endif 
2407			 
2407				; enable auto display updates (slow.....) 
2407			 
2407 3e 01			ld a, 1 
2409 32 71 f9			ld (cli_autodisplay), a 
240c			 
240c				; if storage is in use disable long reads for now 
240c 3e 00			ld a, 0 
240e 32 aa f9			ld (store_longread), a 
2411			 
2411			 
2411				; show start up screen 
2411			 
2411 cd aa 0d			call clear_display 
2414			 
2414 3e 00			ld a,0 
2416 32 93 f9			ld (f_cursor_ptr), a 
2419			 
2419				; set start of word list in start of ram - for use when creating user words 
2419			 
2419 21 00 80			ld hl, baseram 
241c 22 f3 f3			ld (os_last_new_uword), hl 
241f cd c0 23			call user_word_eol 
2422				 
2422			;		call display_data_sp 
2422			;		call next_page_prompt 
2422			 
2422			 
2422			 
2422			 
2422 c9				ret 
2423			 
2423 .. 00		.bootforth: db " Forth Kernel Init ",0 
2437			 
2437			; TODO push to stack 
2437			 
2437			;  
2437			 
2437			if FORTH_PARSEV2 
2437			 
2437			 
2437				include "forth_parserv2.asm" 
2437			 
2437			endif 
2437			 
2437			 
2437			; parse cli version 1 
2437			 
2437			if FORTH_PARSEV1 
2437			 
2437			 
2437			 
2437			      include "forth_parserv1.asm" 
2437			endif 
2437				 
2437			if FORTH_PARSEV3 
2437			 
2437			 
2437			 
2437			      include "forth_parserv3.asm" 
2437				include "forth_wordsv3.asm" 
2437			endif 
2437			 
2437			if FORTH_PARSEV4 
2437			 
2437			 
2437			 
2437			      include "forth_parserv4.asm" 
2437				include "forth_wordsv4.asm" 
2437			endif 
2437			 
2437			if FORTH_PARSEV5 
2437			 
2437			 
2437			 
2437			      include "forth_parserv5.asm" 
2437			 
2437			 
2437			; A better parser without using malloc and string copies all over the place.  
2437			; Exec in situ should be faster 
2437			 
2437			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2437			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2437			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2437			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2437			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2437			WORD_SYS_END: equ 0   ; Opcode for all user words 
2437			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2437			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2437			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2437			 
2437			; Core word preamble macro 
2437			 
2437			CWHEAD:   macro nxtword opcode lit len opflags 
2437				db WORD_SYS_CORE+opcode             
2437				; internal op code number 
2437				dw nxtword            
2437				; link to next dict word block 
2437				db len + 1 
2437				; literal length of dict word inc zero term 
2437				db lit,0              
2437				; literal dict word 
2437			        ; TODO db opflags        
2437				endm 
2437			 
2437			 
2437			NEXTW: macro  
2437				jp macro_next 
2437				endm 
2437			 
2437			macro_next: 
2437			if DEBUG_FORTH_PARSE_KEY 
2437				DMARK "NXT" 
2437				CALLMONITOR 
2437			endif	 
2437			;	inc hl  ; skip token null term  
2437 ed 4b 75 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
243b ed 5b 73 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
243f 2a f7 f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2442			if DEBUG_FORTH_PARSE_KEY 
2442				DMARK "}AA" 
2442				CALLMONITOR 
2442			endif	 
2442 c3 45 25			jp execnext 
2445				;jp exec1 
2445			       
2445			 
2445			 
2445			; Another go at the parser to compile  
2445			 
2445			 
2445			; TODO rework parser to change all of the string words to byte tokens 
2445			; TODO do a search for  
2445			 
2445			; TODO first run normal parser to zero term sections 
2445			; TODO for each word do a token look up to get the op code 
2445			; TODO need some means to flag to the exec that this is a byte code form    
2445			 
2445			 
2445			forthcompile: 
2445			 
2445			; 
2445			; line parse: 
2445			;       parse raw input buffer 
2445			;       tokenise the words 
2445			;       malloc new copy (for looping etc) 
2445			;       copy to malloc + current pc in line to start of string and add line term 
2445			;       save on new rsp 
2445			; 
2445			 
2445			; hl to point to the line to tokenise 
2445			 
2445			;	push hl 
2445 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
2448			 
2448			;	ld a,0		; string term on input 
2448			;	call strlent 
2448			 
2448			;	ld (os_tok_len), hl	 ; save string length 
2448			 
2448			;if DEBUG_FORTH_TOK 
2448			;	ex de,hl		 
2448			;endif 
2448			 
2448			;	pop hl 		; get back string pointer 
2448			 
2448			if DEBUG_FORTH_TOK 
2448						DMARK "TOc" 
2448				CALLMONITOR 
2448			endif 
2448 7e			.cptoken2:    ld a,(hl) 
2449 23				inc hl 
244a fe 7f			cp FORTH_END_BUFFER 
244c 28 29			jr z, .cptokendone2 
244e fe 00			cp 0 
2450 28 25			jr z, .cptokendone2 
2452 fe 22			cp '"' 
2454 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2456 fe 20			cp ' ' 
2458 20 ee			jr nz,  .cptoken2 
245a			 
245a			; TODO consume comments held between ( and ) 
245a			 
245a				; we have a space so change to zero term for dict match later 
245a 2b				dec hl 
245b 3e 00			ld a,0 
245d 77				ld (hl), a 
245e 23				inc hl 
245f 18 e7			jr .cptoken2 
2461				 
2461			 
2461			.cptokenstr2: 
2461				; skip all white space until either eol (because forgot to term) or end double quote 
2461			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2461				;inc hl ; skip current double quote 
2461 7e				ld a,(hl) 
2462 23				inc hl 
2463 fe 22			cp '"' 
2465 28 e1			jr z, .cptoken2 
2467 fe 7f			cp FORTH_END_BUFFER 
2469 28 0c			jr z, .cptokendone2 
246b fe 00			cp 0 
246d 28 08			jr z, .cptokendone2 
246f fe 20			cp ' ' 
2471 28 02			jr z, .cptmp2 
2473 18 ec			jr .cptokenstr2 
2475			 
2475			.cptmp2:	; we have a space so change to zero term for dict match later 
2475				;dec hl 
2475				;ld a,"-"	; TODO remove this when working 
2475				;ld (hl), a 
2475				;inc hl 
2475 18 ea			jr .cptokenstr2 
2477			 
2477			.cptokendone2: 
2477				;inc hl 
2477 3e 7f			ld a, FORTH_END_BUFFER 
2479 77				ld (hl),a 
247a 23				inc hl 
247b 3e 21			ld a, '!' 
247d 77				ld (hl),a 
247e			 
247e 2a f7 f3			ld hl,(os_tok_ptr) 
2481			         
2481			if DEBUG_FORTH_TOK 
2481						DMARK "Tc1" 
2481				CALLMONITOR 
2481			endif 
2481			 
2481				; push exec string to top of return stack 
2481				FORTH_RSP_NEXT 
2481 cd ed 1f			call macro_forth_rsp_next 
2484				endm 
# End of macro FORTH_RSP_NEXT
2484 c9				ret 
2485			 
2485			; Another go at the parser need to simplify the process 
2485			 
2485			forthparse: 
2485			 
2485			; 
2485			; line parse: 
2485			;       parse raw input buffer 
2485			;       tokenise the words 
2485			;       malloc new copy (for looping etc) 
2485			;       copy to malloc + current pc in line to start of string and add line term 
2485			;       save on new rsp 
2485			; 
2485			 
2485			; hl to point to the line to tokenise 
2485			 
2485			;	push hl 
2485 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
2488			 
2488			;	ld a,0		; string term on input 
2488			;	call strlent 
2488			 
2488			;	ld (os_tok_len), hl	 ; save string length 
2488			 
2488			;if DEBUG_FORTH_TOK 
2488			;	ex de,hl		 
2488			;endif 
2488			 
2488			;	pop hl 		; get back string pointer 
2488			 
2488			if DEBUG_FORTH_TOK 
2488						DMARK "TOK" 
2488				CALLMONITOR 
2488			endif 
2488 7e			.ptoken2:    ld a,(hl) 
2489 23				inc hl 
248a fe 7f			cp FORTH_END_BUFFER 
248c 28 29			jr z, .ptokendone2 
248e fe 00			cp 0 
2490 28 25			jr z, .ptokendone2 
2492 fe 22			cp '"' 
2494 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2496 fe 20			cp ' ' 
2498 20 ee			jr nz,  .ptoken2 
249a			 
249a			; TODO consume comments held between ( and ) 
249a			 
249a				; we have a space so change to zero term for dict match later 
249a 2b				dec hl 
249b 3e 00			ld a,0 
249d 77				ld (hl), a 
249e 23				inc hl 
249f 18 e7			jr .ptoken2 
24a1				 
24a1			 
24a1			.ptokenstr2: 
24a1				; skip all white space until either eol (because forgot to term) or end double quote 
24a1			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24a1				;inc hl ; skip current double quote 
24a1 7e				ld a,(hl) 
24a2 23				inc hl 
24a3 fe 22			cp '"' 
24a5 28 e1			jr z, .ptoken2 
24a7 fe 7f			cp FORTH_END_BUFFER 
24a9 28 0c			jr z, .ptokendone2 
24ab fe 00			cp 0 
24ad 28 08			jr z, .ptokendone2 
24af fe 20			cp ' ' 
24b1 28 02			jr z, .ptmp2 
24b3 18 ec			jr .ptokenstr2 
24b5			 
24b5			.ptmp2:	; we have a space so change to zero term for dict match later 
24b5				;dec hl 
24b5				;ld a,"-"	; TODO remove this when working 
24b5				;ld (hl), a 
24b5				;inc hl 
24b5 18 ea			jr .ptokenstr2 
24b7			 
24b7			.ptokendone2: 
24b7				;inc hl 
24b7 3e 7f			ld a, FORTH_END_BUFFER 
24b9 77				ld (hl),a 
24ba 23				inc hl 
24bb 3e 21			ld a, '!' 
24bd 77				ld (hl),a 
24be			 
24be 2a f7 f3			ld hl,(os_tok_ptr) 
24c1			         
24c1			if DEBUG_FORTH_TOK 
24c1						DMARK "TK1" 
24c1				CALLMONITOR 
24c1			endif 
24c1			 
24c1				; push exec string to top of return stack 
24c1				FORTH_RSP_NEXT 
24c1 cd ed 1f			call macro_forth_rsp_next 
24c4				endm 
# End of macro FORTH_RSP_NEXT
24c4 c9				ret 
24c5			 
24c5			; 
24c5			;	; malloc size + buffer pointer + if is loop flag 
24c5			;	ld hl,(os_tok_len) 		 ; get string length 
24c5			; 
24c5			;	ld a,l 
24c5			; 
24c5			;	cp 0			; we dont want to use a null string 
24c5			;	ret z 
24c5			; 
24c5			;;	add 3    ; prefix malloc with buffer for current word ptr 
24c5			; 
24c5			;	add 5     ; TODO when certain not over writing memory remove 
24c5			; 
24c5			;		 
24c5			; 
24c5			;if DEBUG_FORTH_TOK 
24c5			;			DMARK "TKE" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			; 
24c5			;	ld l,a 
24c5			;	ld h,0 
24c5			;;	push hl   ; save required space for the copy later 
24c5			;	call malloc 
24c5			;if DEBUG_FORTH_TOK 
24c5			;			DMARK "TKM" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			;	if DEBUG_FORTH_MALLOC_GUARD 
24c5			;		push af 
24c5			;		call ishlzero 
24c5			;;		ld a, l 
24c5			;;		add h 
24c5			;;		cp 0 
24c5			;		pop af 
24c5			;		 
24c5			;		call z,malloc_error 
24c5			;	endif 
24c5			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
24c5			; 
24c5			; 
24c5			;if DEBUG_FORTH_TOK 
24c5			;			DMARK "TKR" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			; 
24c5			;	FORTH_RSP_NEXT 
24c5			; 
24c5			;	;inc hl	 ; go past current buffer pointer 
24c5			;	;inc hl 
24c5			;	;inc hl   ; and past if loop flag 
24c5			;		; TODO Need to set flag  
24c5			; 
24c5			;	 
24c5			;	 
24c5			;	ex de,hl	; malloc is dest 
24c5			;	ld hl, (os_tok_len) 
24c5			;;	pop bc 
24c5			;	ld c, l                
24c5			;	ld b,0 
24c5			;	ld hl, (os_tok_ptr) 
24c5			; 
24c5			;if DEBUG_FORTH_TOK 
24c5			;			DMARK "TKT" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			; 
24c5			;	; do str cpy 
24c5			; 
24c5			;	ldir      ; copy byte in hl to de 
24c5			; 
24c5			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
24c5			; 
24c5			;if DEBUG_FORTH_TOK 
24c5			; 
24c5			;			DMARK "TKY" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			;	;ld a,0 
24c5			;	;ld a,FORTH_END_BUFFER 
24c5			;	ex de, hl 
24c5			;	;dec hl			 ; go back over the space delim at the end of word 
24c5			;	;ld (hl),a 
24c5			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
24c5			;	ld a,FORTH_END_BUFFER 
24c5			;	ld (hl),a 
24c5			;	inc hl 
24c5			;	ld a,FORTH_END_BUFFER 
24c5			;	ld (hl),a 
24c5			; 
24c5			;	; init the malloc area data 
24c5			;	; set pc for in current area 
24c5			;	;ld hl, (os_tok_malloc) 
24c5			;	;inc hl 
24c5			;	;inc hl 
24c5			;	;inc hl 
24c5			;	;ex de,hl 
24c5			;	;ld hl, (os_tok_malloc) 
24c5			;	;ld (hl),e 
24c5			;	;inc hl 
24c5			;	;ld (hl),d 
24c5			; 
24c5			; 
24c5			;	ld hl,(os_tok_malloc) 
24c5			;if DEBUG_FORTH_PARSE_KEY 
24c5			;			DMARK "TKU" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			; 
24c5			;	ret 
24c5			 
24c5			forthexec: 
24c5			 
24c5			; line exec: 
24c5			; forth parser 
24c5			 
24c5			; 
24c5			;       get current exec line on rsp 
24c5			 
24c5				FORTH_RSP_TOS 
24c5 cd 04 20			call macro_forth_rsp_tos 
24c8				endm 
# End of macro FORTH_RSP_TOS
24c8			 
24c8			;       restore current pc - hl points to malloc of data 
24c8			 
24c8				;ld e, (hl) 
24c8				;inc hl 
24c8				;ld d, (hl) 
24c8				;ex de,hl 
24c8			 
24c8			 
24c8			exec1: 
24c8 22 f7 f3			ld (os_tok_ptr), hl 
24cb			 
24cb				; copy our PC to working vars  
24cb 22 75 f9			ld (cli_ptr), hl 
24ce 22 73 f9			ld (cli_origptr), hl 
24d1			 
24d1 7e				ld a,(hl) 
24d2 fe 7f			cp FORTH_END_BUFFER 
24d4 c8				ret z 
24d5			 
24d5				; skip any nulls 
24d5			 
24d5 fe 00			cp 0 
24d7 20 03			jr nz, .execword 
24d9 23				inc hl 
24da 18 ec			jr exec1 
24dc			 
24dc			 
24dc			.execword: 
24dc			 
24dc			 
24dc			 
24dc			if DEBUG_FORTH_PARSE_KEY 
24dc						DMARK "KYQ" 
24dc				CALLMONITOR 
24dc			endif 
24dc			;       while at start of word: 
24dc			; get start of dict (in user area first) 
24dc			 
24dc 21 00 80		ld hl, baseram 
24df			;ld hl, sysdict 
24df 22 77 f9		ld (cli_nextword),hl 
24e2			;           match word at pc 
24e2			;           exec word 
24e2			;           or push to dsp 
24e2			;           forward to next token 
24e2			;           if line term pop rsp and exit 
24e2			;        
24e2			 
24e2			if DEBUG_FORTH_PARSE_KEY 
24e2						DMARK "KYq" 
24e2				CALLMONITOR 
24e2			endif 
24e2			 
24e2			; 
24e2			; word comp 
24e2			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
24e2			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
24e2			;    move to start of word  
24e2			;    compare word to cli_token 
24e2			 
24e2			.execpnword:	; HL at start of a word in the dictionary to check 
24e2			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
24e2			;	ld (cli_ptr), hl 
24e2			 
24e2 2a 77 f9			ld hl,(cli_nextword) 
24e5			 
24e5 cd 88 25			call forth_tok_next 
24e8			; tok next start here 
24e8			;	; TODO skip compiled symbol for now 
24e8			;	inc hl 
24e8			; 
24e8			;	; save pointer to next word 
24e8			; 
24e8			;	; hl now points to the address of the next word pointer  
24e8			;	ld e, (hl) 
24e8			;	inc hl 
24e8			;	ld d, (hl) 
24e8			;	inc l 
24e8			; 
24e8			;	ex de,hl 
24e8			;if DEBUG_FORTH_PARSE_NEXTWORD 
24e8			;	push bc 
24e8			;	ld bc, (cli_nextword) 
24e8			;			DMARK "NXW" 
24e8			;	CALLMONITOR 
24e8			;	pop bc 
24e8			;endif 
24e8			; tok next end here 
24e8 22 77 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
24eb eb				ex de, hl 
24ec			 
24ec			 
24ec				; save the pointer of the current token - 1 to check against 
24ec				 
24ec 22 7b f9			ld (cli_token), hl   
24ef				; TODO maybe remove below save if no debug 
24ef				; save token string ptr for any debug later 
24ef 23				inc hl  
24f0 22 7d f9			ld (cli_origtoken), hl 
24f3 2b				dec hl 
24f4				; save pointer to the start of the next dictionay word 
24f4 7e				ld a,(hl)   ; get string length 
24f5 47				ld b,a 
24f6			.execpnwordinc:  
24f6 23				inc hl 
24f7 10 fd			djnz .execpnwordinc 
24f9 22 79 f9			ld (cli_execword), hl      ; save start of this words code 
24fc			 
24fc				; now check the word token against the string being parsed 
24fc			 
24fc 2a 7b f9			ld hl,(cli_token) 
24ff 23				inc hl     ; skip string length (use zero term instead to end) 
2500 22 7b f9			ld (cli_token), hl 
2503			 
2503			if DEBUG_FORTH_PARSE_KEY 
2503						DMARK "KY2" 
2503			endif 
2503			if DEBUG_FORTH_PARSE_EXEC 
2503				; see if disabled 
2503			 
2503			;	ld a, (os_view_disable) 
2503			;	cp '*' 
2503				ld a, (debug_vector) 
2503				cp $c9   ; RET  
2503				jr z, .skip 
2503			 
2503				push hl 
2503				push hl 
2503				call clear_display 
2503				ld de, .compword 
2503				ld a, display_row_1 
2503				call str_at_display 
2503				pop de 
2503				ld a, display_row_2 
2503				call str_at_display 
2503				ld hl,(cli_ptr) 
2503				ld a,(hl) 
2503			        ld hl, os_word_scratch 
2503				ld (hl),a 
2503				ld a,0 
2503				inc hl 
2503				ld (hl),a 	 
2503				ld de, os_word_scratch 
2503				ld a, display_row_2+10 
2503				call str_at_display 
2503				call update_display 
2503				ld a, 100 
2503				call aDelayInMS 
2503				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2503				call delay250ms 
2503				endif 
2503				pop hl 
2503			.skip:  
2503			endif	 
2503			.execpnchar:    ; compare char between token and string to parse 
2503			 
2503			if DEBUG_FORTH_PARSE_KEY 
2503						DMARK "Ky3" 
2503			endif 
2503			if DEBUG_FORTH_PARSE_EXEC 
2503				; see if disabled 
2503			 
2503			;	ld a, (os_view_disable) 
2503			;	cp '*' 
2503				ld a, (debug_vector) 
2503				cp $C9  ; RET 
2503				jr z, .skip2 
2503			 
2503			;	call clear_display 
2503			ld hl,(cli_token) 
2503			ld a,(hl) 
2503			ld (os_word_scratch),a 
2503				ld hl,(cli_ptr) 
2503			ld a,(hl) 
2503				ld (os_word_scratch+1),a 
2503				ld a,0 
2503				ld (os_word_scratch+2),a 
2503				ld de,os_word_scratch 
2503				ld a,display_row_4 
2503				call str_at_display 
2503				call update_display 
2503			.skip2:  
2503			endif 
2503 2a 7b f9			ld hl,(cli_token) 
2506 7e				ld a, (hl)	 ; char in word token 
2507 23				inc hl 		; move to next char 
2508 22 7b f9			ld (cli_token), hl ; and save it 
250b 47				ld b,a 
250c			 
250c 2a 75 f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
250f 7e				ld a,(hl) 
2510 23				inc hl 
2511 22 75 f9			ld (cli_ptr), hl		; move to next char 
2514 cd 3b 13			call toUpper 		; make sure the input string matches case 
2517			 
2517			if DEBUG_FORTH_PARSE 
2517			endif 
2517			 
2517				; input stream end of token is a space so get rid of it 
2517			 
2517			;	cp ' ' 
2517			;	jr nz, .pnskipspace 
2517			; 
2517			;	ld a, 0		; make same term as word token term 
2517			; 
2517			;.pnskipspace: 
2517			 
2517			if DEBUG_FORTH_PARSE_KEY 
2517						DMARK "KY7" 
2517			endif 
2517 b8				cp b 
2518 c2 2e 25			jp nz, .execpnskipword	 ; no match so move to next word 
251b				 
251b			;    if same 
251b			;       scan for string terms 0 for token and 32 for input 
251b			 
251b				 
251b			if DEBUG_FORTH_PARSE_KEY 
251b						DMARK "KY8" 
251b			endif 
251b			 
251b 80				add b			 
251c fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
251e							; TODO need to make sure last word in zero term string is accounted for 
251e 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2520			 
2520			 
2520				; at end of both strings so both are exact match 
2520			 
2520			;       skip ptr for next word 
2520			 
2520 2a 75 f9			ld hl,(cli_ptr) 	; at input string term 
2523 23				inc hl			 ; at next char 
2524 22 75 f9			ld (cli_ptr), hl     ; save for next round of the parser 
2527 22 73 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
252a				 
252a				 
252a			if DEBUG_FORTH_PARSE_KEY 
252a						DMARK "KY3" 
252a			endif 
252a			 
252a			 
252a			 
252a			;       exec code block 
252a			if DEBUG_FORTH_JP 
252a				call clear_display 
252a				call update_display 
252a				call delay1s 
252a				ld hl, (cli_execword)     ; save for next check if no match on this word 
252a				ld a,h 
252a				ld hl, os_word_scratch 
252a				call hexout 
252a				ld hl, (cli_execword)     ; save for next check if no match on this word 
252a				ld a,l 
252a				ld hl, os_word_scratch+2 
252a				call hexout 
252a				ld hl, os_word_scratch+4 
252a				ld a,0 
252a				ld (hl),a 
252a				ld de,os_word_scratch 
252a				call str_at_display 
252a					ld a, display_row_2 
252a					call str_at_display 
252a				ld de, (cli_origtoken) 
252a				ld a, display_row_1+10 
252a					call str_at_display 
252a			 
252a				ld a,display_row_1 
252a				ld de, .foundword 
252a				ld a, display_row_3 
252a				call str_at_display 
252a				call update_display 
252a				call delay1s 
252a				call delay1s 
252a				call delay1s 
252a			endif 
252a			 
252a			if DEBUG_FORTH_PARSE_KEY 
252a						DMARK "KYj" 
252a			endif 
252a				; TODO save the word pointer in this exec 
252a			 
252a 2a 79 f9			ld hl,(cli_execword) 
252d e9				jp (hl) 
252e			 
252e			 
252e			;    if not same 
252e			;	scan for zero term 
252e			;	get ptr for next word 
252e			;	goto word comp 
252e			 
252e			.execpnskipword:	; get pointer to next word 
252e 2a 77 f9			ld hl,(cli_nextword) 
2531			 
2531 7e				ld a,(hl) 
2532 fe 00			cp WORD_SYS_END 
2534			;	cp 0 
2534 28 09			jr z, .execendofdict			 ; at end of words 
2536			 
2536			if DEBUG_FORTH_PARSE_KEY 
2536						DMARK "KY4" 
2536			endif 
2536			if DEBUG_FORTH_PARSE_EXEC 
2536			 
2536				; see if disabled 
2536			 
2536			;	ld a, (os_view_disable) 
2536			;	cp '*' 
2536				ld a,(debug_vector) 
2536				cp $c9   ; RET 
2536				jr z, .noskip 
2536			 
2536			 
2536				ld de, .nowordfound 
2536				ld a, display_row_3 
2536				call str_at_display 
2536				call update_display 
2536				ld a, 100 
2536				call aDelayInMS 
2536				 
2536				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2536					call delay250ms 
2536				endif 
2536			.noskip:  
2536			 
2536			endif	 
2536			 
2536 2a 73 f9			ld hl,(cli_origptr) 
2539 22 75 f9			ld (cli_ptr),hl 
253c			 
253c			if DEBUG_FORTH_PARSE_KEY 
253c						DMARK "KY5" 
253c			endif 
253c c3 e2 24			jp .execpnword			; else go to next word 
253f			 
253f			.execendofdict:  
253f			 
253f			if DEBUG_FORTH_PARSE_KEY 
253f						DMARK "KYe" 
253f			endif 
253f			if DEBUG_FORTH_PARSE_EXEC 
253f				; see if disabled 
253f			 
253f			;	ld a, (os_view_disable) 
253f			;	cp '*' 
253f				ld a,(debug_vector) 
253f				cp $c9   ; ret 
253f				jr z, .ispskip 
253f			 
253f				call clear_display 
253f				call update_display 
253f				call delay1s 
253f				ld de, (cli_origptr) 
253f				ld a, display_row_1 
253f				call str_at_display 
253f				 
253f				ld de, .enddict 
253f				ld a, display_row_3 
253f				call str_at_display 
253f				call update_display 
253f				ld a, 100 
253f				call aDelayInMS 
253f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
253f				call delay1s 
253f				call delay1s 
253f				call delay1s 
253f				endif 
253f			.ispskip:  
253f				 
253f			endif	 
253f			 
253f			 
253f			 
253f				; if the word is not a keyword then must be a literal so push it to stack 
253f			 
253f			; push token to stack to end of word 
253f			 
253f				STACKFRAME ON $1efe $2f9f 
253f				if DEBUG_STACK_IMB 
253f					if ON 
253f						exx 
253f						ld de, $1efe 
253f						ld a, d 
253f						ld hl, curframe 
253f						call hexout 
253f						ld a, e 
253f						ld hl, curframe+2 
253f						call hexout 
253f						ld hl, $1efe 
253f						push hl 
253f						ld hl, $2f9f 
253f						push hl 
253f						exx 
253f					endif 
253f				endif 
253f			endm 
# End of macro STACKFRAME
253f			 
253f 2a f7 f3		ld hl,(os_tok_ptr) 
2542 cd af 21		call forth_apush 
2545			 
2545				STACKFRAMECHK ON $1efe $2f9f 
2545				if DEBUG_STACK_IMB 
2545					if ON 
2545						exx 
2545						ld hl, $2f9f 
2545						pop de   ; $2f9f 
2545						call cmp16 
2545						jr nz, .spnosame 
2545						ld hl, $1efe 
2545						pop de   ; $1efe 
2545						call cmp16 
2545						jr z, .spfrsame 
2545						.spnosame: call showsperror 
2545						.spfrsame: nop 
2545						exx 
2545					endif 
2545				endif 
2545			endm 
# End of macro STACKFRAMECHK
2545			 
2545			execnext: 
2545			 
2545			if DEBUG_FORTH_PARSE_KEY 
2545						DMARK "KY>" 
2545			endif 
2545			; move past token to next word 
2545			 
2545 2a f7 f3		ld hl, (os_tok_ptr) 
2548 3e 00		ld a, 0 
254a 01 ff 00		ld bc, 255     ; input buffer size 
254d ed b1		cpir 
254f			 
254f			if DEBUG_FORTH_PARSE_KEY 
254f						DMARK "KY!" 
254f				CALLMONITOR 
254f			endif	 
254f			; TODO this might place hl on the null, so will need to forward on??? 
254f			;inc hl   ; see if this gets onto the next item 
254f			 
254f			 
254f			; TODO pass a pointer to the buffer to push 
254f			; TODO call function to push 
254f			 
254f			; look for end of input 
254f			 
254f			;inc hl 
254f			;ld a,(hl) 
254f			;cp FORTH_END_BUFFER 
254f			;ret z 
254f			 
254f			 
254f c3 c8 24		jp exec1 
2552			 
2552			 
2552			 
2552			 
2552			 
2552			 
2552			 
2552			 
2552			 
2552			findnexttok: 
2552			 
2552				; hl is pointer to move 
2552				; de is the token to locate 
2552			 
2552					if DEBUG_FORTH 
2552						DMARK "NTK" 
2552						CALLMONITOR 
2552					endif 
2552 d5				push de 
2553			 
2553			.fnt1:	 
2553				; find first char of token to locate 
2553			 
2553 1a				ld a, (de) 
2554 4f				ld c,a 
2555 7e				ld a,(hl) 
2556 cd 3b 13			call toUpper 
2559					if DEBUG_FORTH 
2559						DMARK "NT1" 
2559						CALLMONITOR 
2559					endif 
2559 b9				cp c 
255a			 
255a 28 03			jr z, .fnt2cmpmorefirst	 
255c			 
255c				; first char not found move to next char 
255c			 
255c 23				inc hl 
255d 18 f4			jr .fnt1 
255f			 
255f			.fnt2cmpmorefirst:	 
255f				; first char of token found.  
255f			 
255f e5				push hl     ; save start of token just in case it is the right one 
2560 d9				exx 
2561 e1				pop hl        ; save it to hl' 
2562 d9				exx 
2563			 
2563			 
2563			.fnt2cmpmore:	 
2563				; compare the rest 
2563				 
2563 23				inc hl 
2564 13				inc de 
2565				 
2565 1a				ld a, (de) 
2566 4f				ld c,a 
2567 7e				ld a,(hl) 
2568 cd 3b 13			call toUpper 
256b			 
256b					if DEBUG_FORTH 
256b						DMARK "NT2" 
256b						CALLMONITOR 
256b					endif 
256b				; c has the token to find char 
256b				; a has the mem to scan char 
256b			 
256b b9				cp c 
256c 28 04			jr z,.fntmatch1 
256e			 
256e				; they are not the same 
256e			 
256e					if DEBUG_FORTH 
256e						DMARK "NT3" 
256e						CALLMONITOR 
256e					endif 
256e d1				pop de	; reset de token to look for 
256f d5				push de 
2570 18 e1			jr .fnt1 
2572				 
2572			.fntmatch1: 
2572			 
2572				; is the same char a null which means we might have a full hit? 
2572					if DEBUG_FORTH 
2572						DMARK "NT4" 
2572						CALLMONITOR 
2572					endif 
2572			 
2572 fe 00			cp 0 
2574 28 0b			jr z, .fntmatchyes 
2576			 
2576				; are we at the end of the token to find? 
2576			 
2576					if DEBUG_FORTH 
2576						DMARK "NT5" 
2576						CALLMONITOR 
2576					endif 
2576 3e 00			ld a, 0 
2578 b9				cp c 
2579			 
2579 c2 63 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
257c			 
257c					if DEBUG_FORTH 
257c						DMARK "NT6" 
257c						CALLMONITOR 
257c					endif 
257c				; token to find is exhusted but no match to stream 
257c			 
257c				; restore tok pointer and continue on 
257c d1				pop de 
257d d5				push de 
257e c3 53 25			jp .fnt1 
2581			 
2581			 
2581			.fntmatchyes: 
2581			 
2581				; hl now contains the end of the found token 
2581			 
2581				; get rid of saved token pointer to find 
2581			 
2581 d1				pop de 
2582			 
2582					if DEBUG_FORTH 
2582						DMARK "NT9" 
2582						CALLMONITOR 
2582					endif 
2582			 
2582				; hl will be on the null term so forward on 
2582			 
2582				; get back the saved start of the token 
2582			 
2582 d9				exx 
2583 e5				push hl     ; save start of token just in case it is the right one 
2584 d9				exx 
2585 e1				pop hl        ; save it to hl 
2586			 
2586 c9				ret 
2587			 
2587			 
2587			; LIST needs to find a specific token   
2587			; FORGET needs to find a spefici token 
2587			 
2587			; SAVE needs to find all tokens by flag 
2587			; WORDS just needs to scan through all  by flag 
2587			; UWORDS needs to scan through all by flag 
2587			 
2587			 
2587			; given hl as pointer to start of dict look up string 
2587			; return hl as pointer to start of word block 
2587			; or 0 if not found 
2587			 
2587			forth_find_tok: 
2587 c9				ret 
2588			 
2588			; given hl as pointer to dict structure 
2588			; move to the next dict block structure 
2588			 
2588			forth_tok_next: 
2588				; hl now points to the address of the next word pointer  
2588				; TODO skip compiled symbol for now 
2588			;	push de 
2588 23				inc hl 
2589 5e				ld e, (hl) 
258a 23				inc hl 
258b 56				ld d, (hl) 
258c 23				inc hl 
258d			 
258d eb				ex de,hl 
258e			if DEBUG_FORTH_PARSE_NEXTWORD 
258e				push bc 
258e				ld bc, (cli_nextword) 
258e						DMARK "NXW" 
258e				CALLMONITOR 
258e				pop bc 
258e			endif 
258e			;	pop de	 
258e c9				ret 
258f			 
258f			 
258f			 
258f			; eof 
# End of file forth_parserv5.asm
258f				include "forth_wordsv4.asm" 
258f			 
258f			; the core word dictionary v4 
258f			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
258f			 
258f			; this is a linked list for each of the system words used 
258f			; user defined words will follow the same format but will be in ram 
258f			 
258f			 
258f			; 
258f			; 
258f			; define linked list: 
258f			; 
258f			; 1. compiled byte op code 
258f			; 2. len of text word 
258f			; 3. text word 
258f			; 4. ptr to next dictionary word 
258f			; 5. asm, calls etc for the word 
258f			; 
258f			;  if 1 == 0 then last word in dict  
258f			;   
258f			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
258f			;  
258f			;  
258f			; create basic standard set of words 
258f			; 
258f			;  
258f			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
258f			; 2DUP 2DROP 2SWAP  
258f			; @ C@ - get byte  
258f			; ! C! - store byte 
258f			; 0< true if less than zero 
258f			; 0= true if zero 
258f			; < >  
258f			; = true if same 
258f			; variables 
258f			 
258f			 
258f			; Hardware specific words I may need 
258f			; 
258f			; IN OUT  
258f			; calls to key util functions 
258f			; calls to hardward abstraction stuff 
258f			; easy control of frame buffers and lcd i/o 
258f			; keyboard  
258f			 
258f			 
258f			;DICT: macro 
258f			; op_code, len, word, next 
258f			;    word: 
258f			;    db op_code 
258f			;    ds word zero term 
258f			;    dw next 
258f			;    endm 
258f			 
258f			 
258f			 
258f			 
258f			; op code 1 is a flag for user define words which are to be handled differently 
258f			 
258f			 
258f			; 
258f			; 
258f			;    TODO on entry to a word this should be the expected environment 
258f			;    hl - tos value if number then held, if string this is the ptr 
258f			;    de -  
258f			 
258f			 
258f			; opcode ranges 
258f			; 0 - end of word dict 
258f			; 255 - user define words 
258f			 
258f			sysdict: 
258f			include "forth_opcodes.asm" 
258f			; op codes for forth keywords 
258f			; free to use code 0  
258f				OPCODE_HEAP: equ  1 
258f				OPCODE_EXEC: equ 2 
258f				OPCODE_DUP: equ 3 
258f				OPCODE_SWAP: equ 4 
258f				OPCODE_COLN: equ 5 
258f				OPCODE_SCOLN: equ 6 
258f				OPCODE_DROP: equ 7 
258f				OPCODE_DUP2: equ 8 
258f				OPCODE_DROP2: equ 9 
258f				OPCODE_SWAP2: equ 10 
258f				OPCODE_AT: equ 11 
258f				OPCODE_CAT: equ 12 
258f				OPCODE_BANG: equ 13 
258f				OPCODE_CBANG: equ 14 
258f				OPCODE_SCALL: equ 15 
258f				OPCODE_DEPTH: equ 16 
258f				OPCODE_OVER: equ 17 
258f				OPCODE_PAUSE: equ 18 
258f				OPCODE_PAUSES: equ 19 
258f				OPCODE_ROT: equ 20 
258f			;free to reuse	OPCODE_WORDS: equ 21 
258f			        OPCODE_NOT: equ 21 
258f				OPCODE_UWORDS: equ 22 
258f				OPCODE_BP: equ 23 
258f				OPCODE_MONITOR: equ 24  
258f				OPCODE_MALLOC: equ 25 
258f				OPCODE_FREE: equ 26 
258f				OPCODE_LIST: equ 27 
258f				OPCODE_FORGET: equ 28 
258f				OPCODE_NOP: equ 29 
258f				OPCODE_COMO: equ 30 
258f				OPCODE_COMC: equ 31 
258f			;free to reuse	OPCODE_ENDCORE: equ 32 
258f				OPCODE_AFTERSOUND: equ 33 
258f				OPCODE_GP2: equ 34 
258f				OPCODE_GP3: equ 35 
258f				OPCODE_GP4: equ 36 
258f				OPCODE_SIN: equ 37 
258f				OPCODE_SOUT: equ 38 
258f				OPCODE_SPIO: equ 39 
258f				OPCODE_SPICEH: equ 40 
258f				OPCODE_SPIOb: equ 41 
258f				OPCODE_SPII: equ 42 
258f				OPCODE_SESEL: equ 43 
258f				OPCODE_CARTDEV: equ 44 
258f			; free to reuse	OPCODE_ENDDEVICE: equ 45 
258f				OPCODE_FB: equ 46 
258f				OPCODE_EMIT: equ 47 
258f				OPCODE_DOTH: equ 48 
258f				OPCODE_DOTF: equ 49 
258f				OPCODE_DOT: equ 50 
258f				OPCODE_CLS: equ 51 
258f				OPCODE_DRAW: equ 52 
258f				OPCODE_DUMP: equ 53 
258f				OPCODE_CDUMP: equ 54 
258f				OPCODE_DAT: equ 55 
258f				OPCODE_HOME: equ 56 
258f				OPCODE_SPACE: equ 57 
258f				OPCODE_SPACES: equ 58 
258f				OPCODE_SCROLL: equ 59 
258f				OPCODE_ATQ: equ 60 
258f				OPCODE_AUTODSP: equ 61 
258f				OPCODE_MENU: equ 62 
258f			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
258f				OPCODE_THEN: equ 64 
258f				OPCODE_ELSE: equ 65 
258f				OPCODE_DO: equ 66 
258f				OPCODE_LOOP: equ 67 
258f				OPCODE_I: equ 68 
258f				OPCODE_DLOOP: equ 69  
258f				OPCODE_REPEAT: equ 70  
258f				OPCODE_UNTIL: equ 71 
258f				OPCODE_ENDFLOW: equ 72 
258f				OPCODE_WAITK: equ 73 
258f				OPCODE_ACCEPT: equ 74 
258f				OPCODE_EDIT: equ 75 
258f			;free to reuse	OPCODE_ENDKEY: equ 76 
258f				OPCODE_LZERO: equ 77 
258f				OPCODE_TZERO: equ 78 
258f				OPCODE_LESS: equ 79 
258f				OPCODE_GT: equ 80 
258f				OPCODE_EQUAL: equ 81  
258f			;free to reuse	OPCODE_ENDLOGIC: equ 82 
258f				OPCODE_NEG: equ 83 
258f				OPCODE_DIV: equ 84 
258f				OPCODE_MUL: equ 85 
258f				OPCODE_MIN: equ 86 
258f				OPCODE_MAX: equ 87 
258f				OPCODE_RND16: equ 88 
258f				OPCODE_RND8: equ 89 
258f				OPCODE_RND: equ 90 
258f			;free to reuse	OPCODE_ENDMATHS: equ 91  
258f				OPCODE_BYNAME: equ 92 
258f				OPCODE_DIR: equ 93 
258f				OPCODE_SAVE: equ 94 
258f				OPCODE_LOAD: equ 95 
258f				OPCODE_BSAVE: equ 96 
258f				OPCODE_BLOAD: equ 97 
258f				OPCODE_SEO: equ 98  
258f				OPCODE_SEI: equ 99 
258f				OPCODE_SFREE: equ 100 
258f				OPCODE_SIZE: equ 101 
258f				OPCODE_CREATE: equ 102 
258f				OPCODE_APPEND: equ 103 
258f				OPCODE_SDEL: equ 104 
258f				OPCODE_OPEN: equ 105 
258f				OPCODE_READ: equ 106 
258f				OPCODE_EOF: equ 106 
258f				OPCODE_FORMAT: equ 107 
258f				OPCODE_LABEL: equ 108 
258f				OPCODE_LABELS: equ 109 
258f			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
258f				OPCODE_UPPER: equ 111 
258f				OPCODE_LOWER: equ 112 
258f				OPCODE_SUBSTR: equ 113 
258f				OPCODE_LEFT: equ 114 
258f				OPCODE_RIGHT: equ 115 
258f				OPCODE_STR2NUM: equ 116 
258f				OPCODE_NUM2STR: equ 117 
258f				OPCODE_CONCAT: equ 118 
258f				OPCODE_FIND: equ 119 
258f				OPCODE_LEN: equ 120 
258f				OPCODE_CHAR: equ 121 
258f			; free to reuse	OPCODE_STRLEN: equ 122 
258f			; free to reuse	OPCODE_ENDSTR: equ 123 
258f				OPCODE_V0S: equ 124 
258f				OPCODE_V0Q: equ 125 
258f				OPCODE_V1S: equ 126 
258f				OPCODE_V1Q: equ 127 
258f				OPCODE_V2S: equ 128 
258f				OPCODE_V2Q: equ 129 
258f				OPCODE_V3S: equ 130 
258f				OPCODE_V3Q: equ 131 
258f			;free to reuse	OPCODE_END: equ 132 
258f				OPCODE_ZDUP: equ 133 
258f			 
258f			; eof 
# End of file forth_opcodes.asm
258f			 
258f			include "forth_words_core.asm" 
258f			 
258f			; | ## Core Words 
258f			 
258f			;if MALLOC_4 
258f			 
258f			.HEAP: 
258f			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
258f 15				db WORD_SYS_CORE+OPCODE_HEAP             
2590 ce 25			dw .EXEC            
2592 05				db 4 + 1 
2593 .. 00			db "HEAP",0              
2598				endm 
# End of macro CWHEAD
2598			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2598			; | | u1 - Current number of bytes in the heap 
2598			; | | u2 - Remaining bytes left on the heap 
2598			; | |  
2598			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2598			 
2598			 
2598				if DEBUG_FORTH_WORDS_KEY 
2598					DMARK "HEP" 
2598 f5				push af  
2599 3a ad 25			ld a, (.dmark)  
259c 32 a0 fd			ld (debug_mark),a  
259f 3a ae 25			ld a, (.dmark+1)  
25a2 32 a1 fd			ld (debug_mark+1),a  
25a5 3a af 25			ld a, (.dmark+2)  
25a8 32 a2 fd			ld (debug_mark+2),a  
25ab 18 03			jr .pastdmark  
25ad ..			.dmark: db "HEP"  
25b0 f1			.pastdmark: pop af  
25b1			endm  
# End of macro DMARK
25b1					CALLMONITOR 
25b1 cd aa fd			call debug_vector  
25b4				endm  
# End of macro CALLMONITOR
25b4				endif 
25b4 2a 0a 80			ld hl, (free_list )      
25b7 11 0e 80			ld de, heap_start 
25ba			 
25ba ed 52			sbc hl, de  
25bc			 
25bc cd 46 20			call forth_push_numhl 
25bf			 
25bf			 
25bf ed 5b 0a 80		ld de, (free_list )      
25c3 21 d1 f0			ld hl, heap_end 
25c6			 
25c6 ed 52			sbc hl, de 
25c8			 
25c8 cd 46 20			call forth_push_numhl 
25cb				 
25cb			 
25cb				 
25cb			 
25cb			 
25cb			 
25cb				NEXTW 
25cb c3 37 24			jp macro_next 
25ce				endm 
# End of macro NEXTW
25ce			;endif 
25ce			 
25ce			.EXEC: 
25ce			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
25ce			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
25ce			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
25ce			;; > > 
25ce			;; > >   
25ce			;	STACKFRAME OFF $5efe $5f9f 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS_KEY 
25ce			;			DMARK "EXE" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			;	FORTH_DSP_VALUEHL 
25ce			; 
25ce			;	FORTH_DSP_POP 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX1" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;;	ld e,(hl) 
25ce			;;	inc hl 
25ce			;;	ld d,(hl) 
25ce			;;	ex de,hl 
25ce			; 
25ce			;;		if DEBUG_FORTH_WORDS 
25ce			;;			DMARK "EX2" 
25ce			;;			CALLMONITOR 
25ce			;;		endif 
25ce			;	push hl 
25ce			; 
25ce			;	;ld a, 0 
25ce			;	;ld a, FORTH_END_BUFFER 
25ce			;	call strlenz 
25ce			;	inc hl   ; include zero term to copy 
25ce			;	inc hl   ; include term 
25ce			;	inc hl   ; include term 
25ce			;	ld b,0 
25ce			;	ld c,l 
25ce			;	pop hl 
25ce			;	ld de, execscratch 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX3" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	ldir 
25ce			; 
25ce			; 
25ce			;	ld hl, execscratch 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EXe" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			;	call forthparse 
25ce			;	call forthexec 
25ce			;;	call forthexec_cleanup 
25ce			;;	call forthparse 
25ce			;;	call forthexec 
25ce			; 
25ce			;	STACKFRAMECHK OFF $5efe $5f9f 
25ce			; 
25ce			;	; an immediate word so no need to process any more words 
25ce			;	ret 
25ce			;	NEXTW 
25ce			 
25ce			; dead code - old version  
25ce			;	FORTH_RSP_NEXT 
25ce			 
25ce			;  
25ce			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
25ce			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
25ce			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
25ce			;	push hl 
25ce			;	push de 
25ce			;	push bc 
25ce			; 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS_KEY 
25ce			;			DMARK "EXR" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			; 
25ce			; 
25ce			;	;v5 FORTH_DSP_VALUE 
25ce			;	FORTH_DSP_VALUEHL 
25ce			; 
25ce			;	; TODO do string type checks 
25ce			; 
25ce			;;v5	inc hl   ; skip type 
25ce			; 
25ce			;	push hl  ; source code  
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX1" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	ld a, 0 
25ce			;	call strlent 
25ce			; 
25ce			;	inc hl 
25ce			;	inc hl 
25ce			;	inc hl 
25ce			;	inc hl 
25ce			; 
25ce			;	push hl    ; size 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX2" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	call malloc 
25ce			; 
25ce			;	ex de, hl    ; de now contains malloc area 
25ce			;	pop bc   	; get byte count 
25ce			;	pop hl      ; get string to copy 
25ce			; 
25ce			;	push de     ; save malloc for free later 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX3" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	ldir       ; duplicate string 
25ce			; 
25ce			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
25ce			;	 
25ce			;	; TODO fix the parse would be better than this...  
25ce			;	ex de, hl 
25ce			;	dec hl 
25ce			;	ld a, 0 
25ce			;	ld (hl), a 
25ce			;	dec hl 
25ce			;	ld a, ' ' 
25ce			;	ld (hl), a 
25ce			;	dec hl 
25ce			;	ld (hl), a 
25ce			; 
25ce			;	dec hl 
25ce			;	ld (hl), a 
25ce			; 
25ce			; 
25ce			;	FORTH_DSP_POP  
25ce			; 
25ce			;	pop hl     
25ce			;	push hl    ; save malloc area 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX4" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			;	call forthparse 
25ce			;	call forthexec 
25ce			;	 
25ce			;	pop hl 
25ce			;	if DEBUG_FORTH_WORDS 
25ce			;		DMARK "EX5" 
25ce			;		CALLMONITOR 
25ce			;	endif 
25ce			; 
25ce			;	if FORTH_ENABLE_FREE 
25ce			;	call free 
25ce			;	endif 
25ce			; 
25ce			;	if DEBUG_FORTH_WORDS 
25ce			;		DMARK "EX6" 
25ce			;		CALLMONITOR 
25ce			;	endif 
25ce			; 
25ce			;	pop bc 
25ce			;	pop de 
25ce			;	pop hl 
25ce			;;	FORTH_RSP_POP	  
25ce			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
25ce			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
25ce			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
25ce			; 
25ce			;	if DEBUG_FORTH_WORDS 
25ce			;		DMARK "EX7" 
25ce			;		CALLMONITOR 
25ce			;	endif 
25ce			;	NEXTW 
25ce			 
25ce			;.STKEXEC: 
25ce			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
25ce			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
25ce			; 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS_KEY 
25ce			;			DMARK "STX" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			;	FORTH_DSP_VALUEHL 
25ce			; 
25ce			;	ld (store_tmp1), hl    ; count 
25ce			; 
25ce			;	FORTH_DSP_POP 
25ce			;.stkexec1: 
25ce			;	ld hl, (store_tmp1)   ; count 
25ce			;	ld a, 0 
25ce			;	cp l 
25ce			;	ret z 
25ce			; 
25ce			;	dec hl 
25ce			;	ld (store_tmp1), hl    ; count 
25ce			;	 
25ce			;	FORTH_DSP_VALUEHL 
25ce			;	push hl 
25ce			;	 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EXp" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	FORTH_DSP_POP 
25ce			; 
25ce			;	call strlenz 
25ce			;	inc hl   ; include zero term to copy 
25ce			;	inc hl   ; include zero term to copy 
25ce			;	inc hl   ; include zero term to copy 
25ce			;	ld b,0 
25ce			;	ld c,l 
25ce			;	pop hl 
25ce			;	ld de, execscratch 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX3" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	ldir 
25ce			; 
25ce			; 
25ce			;	ld hl, execscratch 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EXP" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			;	call forthparse 
25ce			;	ld hl, execscratch 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EXx" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	call forthexec 
25ce			; 
25ce			;	jp .stkexec1 
25ce			; 
25ce			;	ret 
25ce			 
25ce			 
25ce			.DUP: 
25ce			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
25ce 17				db WORD_SYS_CORE+OPCODE_DUP             
25cf 44 26			dw .ZDUP            
25d1 04				db 3 + 1 
25d2 .. 00			db "DUP",0              
25d6				endm 
# End of macro CWHEAD
25d6			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
25d6			 
25d6				if DEBUG_FORTH_WORDS_KEY 
25d6					DMARK "DUP" 
25d6 f5				push af  
25d7 3a eb 25			ld a, (.dmark)  
25da 32 a0 fd			ld (debug_mark),a  
25dd 3a ec 25			ld a, (.dmark+1)  
25e0 32 a1 fd			ld (debug_mark+1),a  
25e3 3a ed 25			ld a, (.dmark+2)  
25e6 32 a2 fd			ld (debug_mark+2),a  
25e9 18 03			jr .pastdmark  
25eb ..			.dmark: db "DUP"  
25ee f1			.pastdmark: pop af  
25ef			endm  
# End of macro DMARK
25ef					CALLMONITOR 
25ef cd aa fd			call debug_vector  
25f2				endm  
# End of macro CALLMONITOR
25f2				endif 
25f2			 
25f2				FORTH_DSP 
25f2 cd 11 22			call macro_forth_dsp 
25f5				endm 
# End of macro FORTH_DSP
25f5			 
25f5 7e				ld a, (HL) 
25f6 fe 01			cp DS_TYPE_STR 
25f8 20 25			jr nz, .dupinum 
25fa			 
25fa				; push another string 
25fa			 
25fa				FORTH_DSP_VALUEHL     		 
25fa cd 4b 22			call macro_dsp_valuehl 
25fd				endm 
# End of macro FORTH_DSP_VALUEHL
25fd			 
25fd			if DEBUG_FORTH_WORDS 
25fd				DMARK "DUs" 
25fd f5				push af  
25fe 3a 12 26			ld a, (.dmark)  
2601 32 a0 fd			ld (debug_mark),a  
2604 3a 13 26			ld a, (.dmark+1)  
2607 32 a1 fd			ld (debug_mark+1),a  
260a 3a 14 26			ld a, (.dmark+2)  
260d 32 a2 fd			ld (debug_mark+2),a  
2610 18 03			jr .pastdmark  
2612 ..			.dmark: db "DUs"  
2615 f1			.pastdmark: pop af  
2616			endm  
# End of macro DMARK
2616				CALLMONITOR 
2616 cd aa fd			call debug_vector  
2619				endm  
# End of macro CALLMONITOR
2619			endif 
2619 cd b4 20			call forth_push_str 
261c			 
261c				NEXTW 
261c c3 37 24			jp macro_next 
261f				endm 
# End of macro NEXTW
261f			 
261f			 
261f			.dupinum: 
261f				 
261f			 
261f			 
261f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
261f cd 4b 22			call macro_dsp_valuehl 
2622				endm 
# End of macro FORTH_DSP_VALUEHL
2622			 
2622			; TODO add floating point number detection 
2622			 
2622			if DEBUG_FORTH_WORDS 
2622				DMARK "DUi" 
2622 f5				push af  
2623 3a 37 26			ld a, (.dmark)  
2626 32 a0 fd			ld (debug_mark),a  
2629 3a 38 26			ld a, (.dmark+1)  
262c 32 a1 fd			ld (debug_mark+1),a  
262f 3a 39 26			ld a, (.dmark+2)  
2632 32 a2 fd			ld (debug_mark+2),a  
2635 18 03			jr .pastdmark  
2637 ..			.dmark: db "DUi"  
263a f1			.pastdmark: pop af  
263b			endm  
# End of macro DMARK
263b				CALLMONITOR 
263b cd aa fd			call debug_vector  
263e				endm  
# End of macro CALLMONITOR
263e			endif 
263e			 
263e cd 46 20			call forth_push_numhl 
2641				NEXTW 
2641 c3 37 24			jp macro_next 
2644				endm 
# End of macro NEXTW
2644			.ZDUP: 
2644			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2644 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2645 7c 26			dw .SWAP            
2647 05				db 4 + 1 
2648 .. 00			db "?DUP",0              
264d				endm 
# End of macro CWHEAD
264d			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
264d			 
264d				if DEBUG_FORTH_WORDS_KEY 
264d					DMARK "qDU" 
264d f5				push af  
264e 3a 62 26			ld a, (.dmark)  
2651 32 a0 fd			ld (debug_mark),a  
2654 3a 63 26			ld a, (.dmark+1)  
2657 32 a1 fd			ld (debug_mark+1),a  
265a 3a 64 26			ld a, (.dmark+2)  
265d 32 a2 fd			ld (debug_mark+2),a  
2660 18 03			jr .pastdmark  
2662 ..			.dmark: db "qDU"  
2665 f1			.pastdmark: pop af  
2666			endm  
# End of macro DMARK
2666					CALLMONITOR 
2666 cd aa fd			call debug_vector  
2669				endm  
# End of macro CALLMONITOR
2669				endif 
2669				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2669 cd 4b 22			call macro_dsp_valuehl 
266c				endm 
# End of macro FORTH_DSP_VALUEHL
266c			 
266c e5				push hl 
266d			 
266d				; is it a zero? 
266d			 
266d 3e 00			ld a, 0 
266f 84				add h 
2670 85				add l 
2671			 
2671 e1				pop hl 
2672			 
2672 fe 00			cp 0 
2674 28 03			jr z, .dup2orig 
2676			 
2676			 
2676 cd 46 20			call forth_push_numhl 
2679			 
2679			 
2679			; TODO add floating point number detection 
2679			 
2679			.dup2orig: 
2679			 
2679				NEXTW 
2679 c3 37 24			jp macro_next 
267c				endm 
# End of macro NEXTW
267c			.SWAP: 
267c			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
267c 18				db WORD_SYS_CORE+OPCODE_SWAP             
267d bb 26			dw .COLN            
267f 05				db 4 + 1 
2680 .. 00			db "SWAP",0              
2685				endm 
# End of macro CWHEAD
2685			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2685				if DEBUG_FORTH_WORDS_KEY 
2685					DMARK "SWP" 
2685 f5				push af  
2686 3a 9a 26			ld a, (.dmark)  
2689 32 a0 fd			ld (debug_mark),a  
268c 3a 9b 26			ld a, (.dmark+1)  
268f 32 a1 fd			ld (debug_mark+1),a  
2692 3a 9c 26			ld a, (.dmark+2)  
2695 32 a2 fd			ld (debug_mark+2),a  
2698 18 03			jr .pastdmark  
269a ..			.dmark: db "SWP"  
269d f1			.pastdmark: pop af  
269e			endm  
# End of macro DMARK
269e					CALLMONITOR 
269e cd aa fd			call debug_vector  
26a1				endm  
# End of macro CALLMONITOR
26a1				endif 
26a1			 
26a1			; TODO Use os stack swap memory 
26a1				FORTH_DSP_VALUEHL 
26a1 cd 4b 22			call macro_dsp_valuehl 
26a4				endm 
# End of macro FORTH_DSP_VALUEHL
26a4 e5				push hl     ; w2 
26a5			 
26a5				FORTH_DSP_POP 
26a5 cd 03 23			call macro_forth_dsp_pop 
26a8				endm 
# End of macro FORTH_DSP_POP
26a8			 
26a8				FORTH_DSP_VALUEHL 
26a8 cd 4b 22			call macro_dsp_valuehl 
26ab				endm 
# End of macro FORTH_DSP_VALUEHL
26ab			 
26ab				FORTH_DSP_POP 
26ab cd 03 23			call macro_forth_dsp_pop 
26ae				endm 
# End of macro FORTH_DSP_POP
26ae			 
26ae d1				pop de     ; w2	, hl = w1 
26af			 
26af eb				ex de, hl 
26b0 d5				push de 
26b1			 
26b1 cd 46 20			call forth_push_numhl 
26b4			 
26b4 e1				pop hl 
26b5			 
26b5 cd 46 20			call forth_push_numhl 
26b8				 
26b8			 
26b8				NEXTW 
26b8 c3 37 24			jp macro_next 
26bb				endm 
# End of macro NEXTW
26bb			.COLN: 
26bb			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
26bb 19				db WORD_SYS_CORE+OPCODE_COLN             
26bc 47 28			dw .SCOLN            
26be 02				db 1 + 1 
26bf .. 00			db ":",0              
26c1				endm 
# End of macro CWHEAD
26c1			; | : ( -- )         Create new word | DONE 
26c1			 
26c1				if DEBUG_FORTH_WORDS_KEY 
26c1					DMARK "CLN" 
26c1 f5				push af  
26c2 3a d6 26			ld a, (.dmark)  
26c5 32 a0 fd			ld (debug_mark),a  
26c8 3a d7 26			ld a, (.dmark+1)  
26cb 32 a1 fd			ld (debug_mark+1),a  
26ce 3a d8 26			ld a, (.dmark+2)  
26d1 32 a2 fd			ld (debug_mark+2),a  
26d4 18 03			jr .pastdmark  
26d6 ..			.dmark: db "CLN"  
26d9 f1			.pastdmark: pop af  
26da			endm  
# End of macro DMARK
26da					CALLMONITOR 
26da cd aa fd			call debug_vector  
26dd				endm  
# End of macro CALLMONITOR
26dd				endif 
26dd			STACKFRAME OFF $8efe $989f 
26dd				if DEBUG_STACK_IMB 
26dd					if OFF 
26dd						exx 
26dd						ld de, $8efe 
26dd						ld a, d 
26dd						ld hl, curframe 
26dd						call hexout 
26dd						ld a, e 
26dd						ld hl, curframe+2 
26dd						call hexout 
26dd						ld hl, $8efe 
26dd						push hl 
26dd						ld hl, $989f 
26dd						push hl 
26dd						exx 
26dd					endif 
26dd				endif 
26dd			endm 
# End of macro STACKFRAME
26dd			; get parser buffer length  of new word 
26dd			 
26dd			 
26dd			 
26dd				; move tok past this to start of name defintition 
26dd				; TODO get word to define 
26dd				; TODO Move past word token 
26dd				; TODO get length of string up to the ';' 
26dd			 
26dd 2a f7 f3		ld hl, (os_tok_ptr) 
26e0 23			inc hl 
26e1 23			inc hl 
26e2			 
26e2 3e 3b		ld a, ';' 
26e4 cd 4f 13		call strlent 
26e7			 
26e7 7d			ld a,l 
26e8 32 e6 f0		ld (os_new_parse_len), a 
26eb			 
26eb			 
26eb			if DEBUG_FORTH_UWORD 
26eb ed 5b f7 f3	ld de, (os_tok_ptr) 
26ef					DMARK ":01" 
26ef f5				push af  
26f0 3a 04 27			ld a, (.dmark)  
26f3 32 a0 fd			ld (debug_mark),a  
26f6 3a 05 27			ld a, (.dmark+1)  
26f9 32 a1 fd			ld (debug_mark+1),a  
26fc 3a 06 27			ld a, (.dmark+2)  
26ff 32 a2 fd			ld (debug_mark+2),a  
2702 18 03			jr .pastdmark  
2704 ..			.dmark: db ":01"  
2707 f1			.pastdmark: pop af  
2708			endm  
# End of macro DMARK
2708			CALLMONITOR 
2708 cd aa fd			call debug_vector  
270b				endm  
# End of macro CALLMONITOR
270b			endif 
270b			 
270b			; 
270b			;  new word memory layout: 
270b			;  
270b			;    : adg 6666 ;  
270b			; 
270b			;    db   1     ; user defined word  
270b 23			inc hl    
270c			;    dw   sysdict 
270c 23			inc hl 
270d 23			inc hl 
270e			;    db <word len>+1 (for null) 
270e 23			inc hl 
270f			;    db .... <word> 
270f			; 
270f			 
270f 23			inc hl    ; some extras for the word preamble before the above 
2710 23			inc hl 
2711 23			inc hl 
2712 23			inc hl 
2713 23			inc hl 
2714 23			inc hl 
2715 23			inc hl  
2716 23			inc hl 
2717 23			inc hl 
2718 23			inc hl 
2719 23			inc hl 
271a 23			inc hl 
271b 23			inc hl 
271c 23			inc hl     ; TODO how many do we really need?     maybe only 6 
271d			;       exec word buffer 
271d			;	<ptr word>   
271d 23			inc hl 
271e 23			inc hl 
271f			;       <word list><null term> 7F final term 
271f			 
271f			 
271f			if DEBUG_FORTH_UWORD 
271f					DMARK ":02" 
271f f5				push af  
2720 3a 34 27			ld a, (.dmark)  
2723 32 a0 fd			ld (debug_mark),a  
2726 3a 35 27			ld a, (.dmark+1)  
2729 32 a1 fd			ld (debug_mark+1),a  
272c 3a 36 27			ld a, (.dmark+2)  
272f 32 a2 fd			ld (debug_mark+2),a  
2732 18 03			jr .pastdmark  
2734 ..			.dmark: db ":02"  
2737 f1			.pastdmark: pop af  
2738			endm  
# End of macro DMARK
2738			CALLMONITOR 
2738 cd aa fd			call debug_vector  
273b				endm  
# End of macro CALLMONITOR
273b			endif 
273b			 
273b			 
273b				; malloc the size 
273b			 
273b cd b9 13			call malloc 
273e 22 e8 f0			ld (os_new_malloc), hl     ; save malloc start 
2741			 
2741			;    db   1     ; user defined word  
2741 3e 01			ld a, WORD_SYS_UWORD  
2743 77				ld (hl), a 
2744			 
2744 23			inc hl    
2745			;    dw   sysdict 
2745 11 8f 25		ld de, sysdict       ; continue on with the scan to the system dict 
2748 73			ld (hl), e 
2749 23			inc hl 
274a 72			ld (hl), d 
274b 23			inc hl 
274c			 
274c			 
274c			;    Setup dict word 
274c			 
274c 23			inc hl 
274d 22 e2 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
2750			 
2750			; 1. get length of dict word 
2750			 
2750			 
2750 2a f7 f3		ld hl, (os_tok_ptr) 
2753 23			inc hl 
2754 23			inc hl    ; position to start of dict word 
2755 3e 00		ld a, 0 
2757 cd 4f 13		call strlent 
275a			 
275a			 
275a 23			inc hl    ; to include null??? 
275b			 
275b			; write length of dict word 
275b			 
275b ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
275f 1b			dec de 
2760 eb			ex de, hl 
2761 73			ld (hl), e 
2762 eb			ex de, hl 
2763			 
2763			 
2763			 
2763			; copy  
2763 4d			ld c, l 
2764 06 00		ld b, 0 
2766 ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
276a 2a f7 f3		ld hl, (os_tok_ptr) 
276d 23			inc hl 
276e 23			inc hl    ; position to start of dict word 
276f			 
276f			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
276f			 
276f			; TODO need to convert word to upper case 
276f			 
276f			ucasetok:	 
276f 7e			ld a,(hl) 
2770 cd 3b 13		call toUpper 
2773 77			ld (hl),a 
2774 ed a0		ldi 
2776 f2 6f 27		jp p, ucasetok 
2779			 
2779			 
2779			 
2779			; de now points to start of where the word body code should be placed 
2779 ed 53 e2 f0	ld (os_new_work_ptr), de 
277d			; hl now points to the words to throw at forthexec which needs to be copied 
277d 22 e0 f0		ld (os_new_src_ptr), hl 
2780			 
2780			; TODO add 'call to forthexec' 
2780			 
2780			if DEBUG_FORTH_UWORD 
2780 c5			push bc 
2781 ed 4b e8 f0	ld bc, (os_new_malloc) 
2785					DMARK ":0x" 
2785 f5				push af  
2786 3a 9a 27			ld a, (.dmark)  
2789 32 a0 fd			ld (debug_mark),a  
278c 3a 9b 27			ld a, (.dmark+1)  
278f 32 a1 fd			ld (debug_mark+1),a  
2792 3a 9c 27			ld a, (.dmark+2)  
2795 32 a2 fd			ld (debug_mark+2),a  
2798 18 03			jr .pastdmark  
279a ..			.dmark: db ":0x"  
279d f1			.pastdmark: pop af  
279e			endm  
# End of macro DMARK
279e			CALLMONITOR 
279e cd aa fd			call debug_vector  
27a1				endm  
# End of macro CALLMONITOR
27a1 c1			pop bc 
27a2			endif 
27a2			 
27a2			 
27a2			; create word preamble which should be: 
27a2			 
27a2			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
27a2			 
27a2			;    ld hl, <word code> 
27a2			;    jp user_exec 
27a2			;    <word code bytes> 
27a2			 
27a2			 
27a2			;	inc de     ; TODO ??? or are we already past the word's null 
27a2 eb			ex de, hl 
27a3			 
27a3 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
27a5			 
27a5 23			inc hl 
27a6 22 dc f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
27a9 23			inc hl 
27aa			 
27aa 23			inc hl 
27ab 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
27ad			 
27ad 01 44 5d		ld bc, user_exec 
27b0 23			inc hl 
27b1 71			ld (hl), c     ; poke address of user_exec 
27b2 23			inc hl 
27b3 70			ld (hl), b     
27b4			; 
27b4			;	inc hl 
27b4			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27b4			; 
27b4			; 
27b4			;	ld bc, macro_forth_rsp_next 
27b4			;	inc hl 
27b4			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
27b4			;	inc hl 
27b4			;	ld (hl), b     
27b4			; 
27b4			;	inc hl 
27b4			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27b4			; 
27b4			; 
27b4			;	inc hl 
27b4			;	ld bc, forthexec 
27b4			;	ld (hl), c     ; poke address of forthexec 
27b4			;	inc hl 
27b4			;	ld (hl), b      
27b4			; 
27b4			;	inc hl 
27b4			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
27b4			; 
27b4			;	ld bc, user_dict_next 
27b4			;	inc hl 
27b4			;	ld (hl), c     ; poke address of forthexec 
27b4			;	inc hl 
27b4			;	ld (hl), b      
27b4			 
27b4			; hl is now where we need to copy the word byte data to save this 
27b4			 
27b4 23			inc hl 
27b5 22 de f0		ld (os_new_exec), hl 
27b8			 
27b8			; copy definition 
27b8			 
27b8 eb			ex de, hl 
27b9			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
27b9			;	inc de    ; skip the PC for this parse 
27b9 3a e6 f0		ld a, (os_new_parse_len) 
27bc 4f			ld c, a 
27bd 06 00		ld b, 0 
27bf ed b0		ldir		 ; copy defintion 
27c1			 
27c1			 
27c1			; poke the address of where the new word bytes live for forthexec 
27c1			 
27c1 2a dc f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
27c4			 
27c4 ed 5b de f0	ld de, (os_new_exec)      
27c8			 
27c8 73			ld (hl), e 
27c9 23			inc hl 
27ca 72			ld (hl), d 
27cb			 
27cb				; TODO copy last user dict word next link to this word 
27cb				; TODO update last user dict word to point to this word 
27cb			; 
27cb			; hl f923 de 812a ; bc 811a 
27cb			 
27cb			if DEBUG_FORTH_UWORD 
27cb c5			push bc 
27cc ed 4b e8 f0	ld bc, (os_new_malloc) 
27d0					DMARK ":0A" 
27d0 f5				push af  
27d1 3a e5 27			ld a, (.dmark)  
27d4 32 a0 fd			ld (debug_mark),a  
27d7 3a e6 27			ld a, (.dmark+1)  
27da 32 a1 fd			ld (debug_mark+1),a  
27dd 3a e7 27			ld a, (.dmark+2)  
27e0 32 a2 fd			ld (debug_mark+2),a  
27e3 18 03			jr .pastdmark  
27e5 ..			.dmark: db ":0A"  
27e8 f1			.pastdmark: pop af  
27e9			endm  
# End of macro DMARK
27e9			CALLMONITOR 
27e9 cd aa fd			call debug_vector  
27ec				endm  
# End of macro CALLMONITOR
27ec c1			pop bc 
27ed			endif 
27ed			if DEBUG_FORTH_UWORD 
27ed c5			push bc 
27ee ed 4b e8 f0	ld bc, (os_new_malloc) 
27f2 03			inc bc 
27f3 03			inc bc 
27f4 03			inc bc 
27f5 03			inc bc 
27f6 03			inc bc 
27f7 03			inc bc 
27f8 03			inc bc 
27f9 03			inc bc 
27fa			 
27fa					DMARK ":0B" 
27fa f5				push af  
27fb 3a 0f 28			ld a, (.dmark)  
27fe 32 a0 fd			ld (debug_mark),a  
2801 3a 10 28			ld a, (.dmark+1)  
2804 32 a1 fd			ld (debug_mark+1),a  
2807 3a 11 28			ld a, (.dmark+2)  
280a 32 a2 fd			ld (debug_mark+2),a  
280d 18 03			jr .pastdmark  
280f ..			.dmark: db ":0B"  
2812 f1			.pastdmark: pop af  
2813			endm  
# End of macro DMARK
2813			CALLMONITOR 
2813 cd aa fd			call debug_vector  
2816				endm  
# End of macro CALLMONITOR
2816 c1			pop bc 
2817			endif 
2817			 
2817			; update word dict linked list for new word 
2817			 
2817			 
2817 2a f3 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
281a 23			inc hl     ; move to next work linked list ptr 
281b			 
281b ed 5b e8 f0	ld de, (os_new_malloc)		 ; new next word 
281f 73			ld (hl), e 
2820 23			inc hl 
2821 72			ld (hl), d 
2822			 
2822			if DEBUG_FORTH_UWORD 
2822 ed 4b f3 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2826			endif 
2826			 
2826 ed 53 f3 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
282a			 
282a			 
282a			if DEBUG_FORTH_UWORD 
282a					DMARK ":0+" 
282a f5				push af  
282b 3a 3f 28			ld a, (.dmark)  
282e 32 a0 fd			ld (debug_mark),a  
2831 3a 40 28			ld a, (.dmark+1)  
2834 32 a1 fd			ld (debug_mark+1),a  
2837 3a 41 28			ld a, (.dmark+2)  
283a 32 a2 fd			ld (debug_mark+2),a  
283d 18 03			jr .pastdmark  
283f ..			.dmark: db ":0+"  
2842 f1			.pastdmark: pop af  
2843			endm  
# End of macro DMARK
2843			CALLMONITOR 
2843 cd aa fd			call debug_vector  
2846				endm  
# End of macro CALLMONITOR
2846			endif 
2846			 
2846			STACKFRAMECHK OFF $8efe $989f 
2846				if DEBUG_STACK_IMB 
2846					if OFF 
2846						exx 
2846						ld hl, $989f 
2846						pop de   ; $989f 
2846						call cmp16 
2846						jr nz, .spnosame 
2846						ld hl, $8efe 
2846						pop de   ; $8efe 
2846						call cmp16 
2846						jr z, .spfrsame 
2846						.spnosame: call showsperror 
2846						.spfrsame: nop 
2846						exx 
2846					endif 
2846				endif 
2846			endm 
# End of macro STACKFRAMECHK
2846			 
2846 c9			ret    ; dont process any remaining parser tokens as they form new word 
2847			 
2847			 
2847			 
2847			 
2847			;		NEXT 
2847			.SCOLN: 
2847			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2847 06			db OPCODE_SCOLN 
2848 93 28		dw .DROP 
284a 02			db 2 
284b .. 00		db ";",0           
284d			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
284d				if DEBUG_FORTH_WORDS_KEY 
284d					DMARK "SCN" 
284d f5				push af  
284e 3a 62 28			ld a, (.dmark)  
2851 32 a0 fd			ld (debug_mark),a  
2854 3a 63 28			ld a, (.dmark+1)  
2857 32 a1 fd			ld (debug_mark+1),a  
285a 3a 64 28			ld a, (.dmark+2)  
285d 32 a2 fd			ld (debug_mark+2),a  
2860 18 03			jr .pastdmark  
2862 ..			.dmark: db "SCN"  
2865 f1			.pastdmark: pop af  
2866			endm  
# End of macro DMARK
2866					CALLMONITOR 
2866 cd aa fd			call debug_vector  
2869				endm  
# End of macro CALLMONITOR
2869				endif 
2869				FORTH_RSP_TOS 
2869 cd 04 20			call macro_forth_rsp_tos 
286c				endm 
# End of macro FORTH_RSP_TOS
286c e5				push hl 
286d				FORTH_RSP_POP 
286d cd 0e 20			call macro_forth_rsp_pop 
2870				endm 
# End of macro FORTH_RSP_POP
2870 e1				pop hl 
2871			;		ex de,hl 
2871 22 f7 f3			ld (os_tok_ptr),hl 
2874			 
2874			if DEBUG_FORTH_UWORD 
2874					DMARK "SCL" 
2874 f5				push af  
2875 3a 89 28			ld a, (.dmark)  
2878 32 a0 fd			ld (debug_mark),a  
287b 3a 8a 28			ld a, (.dmark+1)  
287e 32 a1 fd			ld (debug_mark+1),a  
2881 3a 8b 28			ld a, (.dmark+2)  
2884 32 a2 fd			ld (debug_mark+2),a  
2887 18 03			jr .pastdmark  
2889 ..			.dmark: db "SCL"  
288c f1			.pastdmark: pop af  
288d			endm  
# End of macro DMARK
288d			CALLMONITOR 
288d cd aa fd			call debug_vector  
2890				endm  
# End of macro CALLMONITOR
2890			endif 
2890				NEXTW 
2890 c3 37 24			jp macro_next 
2893				endm 
# End of macro NEXTW
2893			 
2893			.DROP: 
2893			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2893 1b				db WORD_SYS_CORE+OPCODE_DROP             
2894 be 28			dw .DUP2            
2896 05				db 4 + 1 
2897 .. 00			db "DROP",0              
289c				endm 
# End of macro CWHEAD
289c			; | DROP ( w -- )   drop the TOS item   | DONE 
289c				if DEBUG_FORTH_WORDS_KEY 
289c					DMARK "DRP" 
289c f5				push af  
289d 3a b1 28			ld a, (.dmark)  
28a0 32 a0 fd			ld (debug_mark),a  
28a3 3a b2 28			ld a, (.dmark+1)  
28a6 32 a1 fd			ld (debug_mark+1),a  
28a9 3a b3 28			ld a, (.dmark+2)  
28ac 32 a2 fd			ld (debug_mark+2),a  
28af 18 03			jr .pastdmark  
28b1 ..			.dmark: db "DRP"  
28b4 f1			.pastdmark: pop af  
28b5			endm  
# End of macro DMARK
28b5					CALLMONITOR 
28b5 cd aa fd			call debug_vector  
28b8				endm  
# End of macro CALLMONITOR
28b8				endif 
28b8				FORTH_DSP_POP 
28b8 cd 03 23			call macro_forth_dsp_pop 
28bb				endm 
# End of macro FORTH_DSP_POP
28bb				NEXTW 
28bb c3 37 24			jp macro_next 
28be				endm 
# End of macro NEXTW
28be			.DUP2: 
28be			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
28be 1c				db WORD_SYS_CORE+OPCODE_DUP2             
28bf 03 29			dw .DROP2            
28c1 05				db 4 + 1 
28c2 .. 00			db "2DUP",0              
28c7				endm 
# End of macro CWHEAD
28c7			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
28c7				if DEBUG_FORTH_WORDS_KEY 
28c7					DMARK "2DU" 
28c7 f5				push af  
28c8 3a dc 28			ld a, (.dmark)  
28cb 32 a0 fd			ld (debug_mark),a  
28ce 3a dd 28			ld a, (.dmark+1)  
28d1 32 a1 fd			ld (debug_mark+1),a  
28d4 3a de 28			ld a, (.dmark+2)  
28d7 32 a2 fd			ld (debug_mark+2),a  
28da 18 03			jr .pastdmark  
28dc ..			.dmark: db "2DU"  
28df f1			.pastdmark: pop af  
28e0			endm  
# End of macro DMARK
28e0					CALLMONITOR 
28e0 cd aa fd			call debug_vector  
28e3				endm  
# End of macro CALLMONITOR
28e3				endif 
28e3				FORTH_DSP_VALUEHL 
28e3 cd 4b 22			call macro_dsp_valuehl 
28e6				endm 
# End of macro FORTH_DSP_VALUEHL
28e6 e5				push hl      ; 2 
28e7			 
28e7				FORTH_DSP_POP 
28e7 cd 03 23			call macro_forth_dsp_pop 
28ea				endm 
# End of macro FORTH_DSP_POP
28ea				 
28ea				FORTH_DSP_VALUEHL 
28ea cd 4b 22			call macro_dsp_valuehl 
28ed				endm 
# End of macro FORTH_DSP_VALUEHL
28ed			;		push hl      ; 1 
28ed			 
28ed				FORTH_DSP_POP 
28ed cd 03 23			call macro_forth_dsp_pop 
28f0				endm 
# End of macro FORTH_DSP_POP
28f0			 
28f0			;		pop hl       ; 1 
28f0 d1				pop de       ; 2 
28f1			 
28f1 cd 46 20			call forth_push_numhl 
28f4 eb				ex de, hl 
28f5 cd 46 20			call forth_push_numhl 
28f8			 
28f8				 
28f8 eb				ex de, hl 
28f9			 
28f9 cd 46 20			call forth_push_numhl 
28fc eb				ex de, hl 
28fd cd 46 20			call forth_push_numhl 
2900			 
2900			 
2900				NEXTW 
2900 c3 37 24			jp macro_next 
2903				endm 
# End of macro NEXTW
2903			.DROP2: 
2903			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2903 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2904 32 29			dw .SWAP2            
2906 06				db 5 + 1 
2907 .. 00			db "2DROP",0              
290d				endm 
# End of macro CWHEAD
290d			; | 2DROP ( w w -- )    Double drop | DONE 
290d				if DEBUG_FORTH_WORDS_KEY 
290d					DMARK "2DR" 
290d f5				push af  
290e 3a 22 29			ld a, (.dmark)  
2911 32 a0 fd			ld (debug_mark),a  
2914 3a 23 29			ld a, (.dmark+1)  
2917 32 a1 fd			ld (debug_mark+1),a  
291a 3a 24 29			ld a, (.dmark+2)  
291d 32 a2 fd			ld (debug_mark+2),a  
2920 18 03			jr .pastdmark  
2922 ..			.dmark: db "2DR"  
2925 f1			.pastdmark: pop af  
2926			endm  
# End of macro DMARK
2926					CALLMONITOR 
2926 cd aa fd			call debug_vector  
2929				endm  
# End of macro CALLMONITOR
2929				endif 
2929				FORTH_DSP_POP 
2929 cd 03 23			call macro_forth_dsp_pop 
292c				endm 
# End of macro FORTH_DSP_POP
292c				FORTH_DSP_POP 
292c cd 03 23			call macro_forth_dsp_pop 
292f				endm 
# End of macro FORTH_DSP_POP
292f				NEXTW 
292f c3 37 24			jp macro_next 
2932				endm 
# End of macro NEXTW
2932			.SWAP2: 
2932			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2932 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2933 5b 29			dw .AT            
2935 06				db 5 + 1 
2936 .. 00			db "2SWAP",0              
293c				endm 
# End of macro CWHEAD
293c			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
293c				if DEBUG_FORTH_WORDS_KEY 
293c					DMARK "2SW" 
293c f5				push af  
293d 3a 51 29			ld a, (.dmark)  
2940 32 a0 fd			ld (debug_mark),a  
2943 3a 52 29			ld a, (.dmark+1)  
2946 32 a1 fd			ld (debug_mark+1),a  
2949 3a 53 29			ld a, (.dmark+2)  
294c 32 a2 fd			ld (debug_mark+2),a  
294f 18 03			jr .pastdmark  
2951 ..			.dmark: db "2SW"  
2954 f1			.pastdmark: pop af  
2955			endm  
# End of macro DMARK
2955					CALLMONITOR 
2955 cd aa fd			call debug_vector  
2958				endm  
# End of macro CALLMONITOR
2958				endif 
2958			; TODO Use os stack swap memory 
2958				NEXTW 
2958 c3 37 24			jp macro_next 
295b				endm 
# End of macro NEXTW
295b			.AT: 
295b			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
295b 1f				db WORD_SYS_CORE+OPCODE_AT             
295c 8d 29			dw .CAT            
295e 02				db 1 + 1 
295f .. 00			db "@",0              
2961				endm 
# End of macro CWHEAD
2961			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2961			 
2961				if DEBUG_FORTH_WORDS_KEY 
2961					DMARK "AT." 
2961 f5				push af  
2962 3a 76 29			ld a, (.dmark)  
2965 32 a0 fd			ld (debug_mark),a  
2968 3a 77 29			ld a, (.dmark+1)  
296b 32 a1 fd			ld (debug_mark+1),a  
296e 3a 78 29			ld a, (.dmark+2)  
2971 32 a2 fd			ld (debug_mark+2),a  
2974 18 03			jr .pastdmark  
2976 ..			.dmark: db "AT."  
2979 f1			.pastdmark: pop af  
297a			endm  
# End of macro DMARK
297a					CALLMONITOR 
297a cd aa fd			call debug_vector  
297d				endm  
# End of macro CALLMONITOR
297d				endif 
297d			.getbyteat:	 
297d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
297d cd 4b 22			call macro_dsp_valuehl 
2980				endm 
# End of macro FORTH_DSP_VALUEHL
2980				 
2980			;		push hl 
2980			 
2980				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2980 cd 03 23			call macro_forth_dsp_pop 
2983				endm 
# End of macro FORTH_DSP_POP
2983			 
2983			;		pop hl 
2983			 
2983 7e				ld a, (hl) 
2984			 
2984 6f				ld l, a 
2985 26 00			ld h, 0 
2987 cd 46 20			call forth_push_numhl 
298a			 
298a				NEXTW 
298a c3 37 24			jp macro_next 
298d				endm 
# End of macro NEXTW
298d			.CAT: 
298d			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
298d 20				db WORD_SYS_CORE+OPCODE_CAT             
298e b6 29			dw .BANG            
2990 03				db 2 + 1 
2991 .. 00			db "C@",0              
2994				endm 
# End of macro CWHEAD
2994			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2994				if DEBUG_FORTH_WORDS_KEY 
2994					DMARK "CAA" 
2994 f5				push af  
2995 3a a9 29			ld a, (.dmark)  
2998 32 a0 fd			ld (debug_mark),a  
299b 3a aa 29			ld a, (.dmark+1)  
299e 32 a1 fd			ld (debug_mark+1),a  
29a1 3a ab 29			ld a, (.dmark+2)  
29a4 32 a2 fd			ld (debug_mark+2),a  
29a7 18 03			jr .pastdmark  
29a9 ..			.dmark: db "CAA"  
29ac f1			.pastdmark: pop af  
29ad			endm  
# End of macro DMARK
29ad					CALLMONITOR 
29ad cd aa fd			call debug_vector  
29b0				endm  
# End of macro CALLMONITOR
29b0				endif 
29b0 c3 7d 29			jp .getbyteat 
29b3				NEXTW 
29b3 c3 37 24			jp macro_next 
29b6				endm 
# End of macro NEXTW
29b6			.BANG: 
29b6			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
29b6 21				db WORD_SYS_CORE+OPCODE_BANG             
29b7 ec 29			dw .CBANG            
29b9 02				db 1 + 1 
29ba .. 00			db "!",0              
29bc				endm 
# End of macro CWHEAD
29bc			; | ! ( x w -- ) Store x at address w      | DONE 
29bc				if DEBUG_FORTH_WORDS_KEY 
29bc					DMARK "BNG" 
29bc f5				push af  
29bd 3a d1 29			ld a, (.dmark)  
29c0 32 a0 fd			ld (debug_mark),a  
29c3 3a d2 29			ld a, (.dmark+1)  
29c6 32 a1 fd			ld (debug_mark+1),a  
29c9 3a d3 29			ld a, (.dmark+2)  
29cc 32 a2 fd			ld (debug_mark+2),a  
29cf 18 03			jr .pastdmark  
29d1 ..			.dmark: db "BNG"  
29d4 f1			.pastdmark: pop af  
29d5			endm  
# End of macro DMARK
29d5					CALLMONITOR 
29d5 cd aa fd			call debug_vector  
29d8				endm  
# End of macro CALLMONITOR
29d8				endif 
29d8			 
29d8			.storebyteat:		 
29d8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d8 cd 4b 22			call macro_dsp_valuehl 
29db				endm 
# End of macro FORTH_DSP_VALUEHL
29db				 
29db e5				push hl 
29dc			 
29dc				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29dc cd 03 23			call macro_forth_dsp_pop 
29df				endm 
# End of macro FORTH_DSP_POP
29df			 
29df				; get byte to poke 
29df			 
29df				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29df cd 4b 22			call macro_dsp_valuehl 
29e2				endm 
# End of macro FORTH_DSP_VALUEHL
29e2 e5				push hl 
29e3			 
29e3			 
29e3				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29e3 cd 03 23			call macro_forth_dsp_pop 
29e6				endm 
# End of macro FORTH_DSP_POP
29e6			 
29e6			 
29e6 d1				pop de 
29e7 e1				pop hl 
29e8			 
29e8 73				ld (hl),e 
29e9			 
29e9			 
29e9				NEXTW 
29e9 c3 37 24			jp macro_next 
29ec				endm 
# End of macro NEXTW
29ec			.CBANG: 
29ec			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
29ec 22				db WORD_SYS_CORE+OPCODE_CBANG             
29ed 15 2a			dw .SCALL            
29ef 03				db 2 + 1 
29f0 .. 00			db "C!",0              
29f3				endm 
# End of macro CWHEAD
29f3			; | C!  ( x w -- ) Store x at address w  | DONE 
29f3				if DEBUG_FORTH_WORDS_KEY 
29f3					DMARK "CBA" 
29f3 f5				push af  
29f4 3a 08 2a			ld a, (.dmark)  
29f7 32 a0 fd			ld (debug_mark),a  
29fa 3a 09 2a			ld a, (.dmark+1)  
29fd 32 a1 fd			ld (debug_mark+1),a  
2a00 3a 0a 2a			ld a, (.dmark+2)  
2a03 32 a2 fd			ld (debug_mark+2),a  
2a06 18 03			jr .pastdmark  
2a08 ..			.dmark: db "CBA"  
2a0b f1			.pastdmark: pop af  
2a0c			endm  
# End of macro DMARK
2a0c					CALLMONITOR 
2a0c cd aa fd			call debug_vector  
2a0f				endm  
# End of macro CALLMONITOR
2a0f				endif 
2a0f c3 d8 29			jp .storebyteat 
2a12				NEXTW 
2a12 c3 37 24			jp macro_next 
2a15				endm 
# End of macro NEXTW
2a15			.SCALL: 
2a15			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a15 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a16 49 2a			dw .DEPTH            
2a18 05				db 4 + 1 
2a19 .. 00			db "CALL",0              
2a1e				endm 
# End of macro CWHEAD
2a1e			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a1e				if DEBUG_FORTH_WORDS_KEY 
2a1e					DMARK "CLL" 
2a1e f5				push af  
2a1f 3a 33 2a			ld a, (.dmark)  
2a22 32 a0 fd			ld (debug_mark),a  
2a25 3a 34 2a			ld a, (.dmark+1)  
2a28 32 a1 fd			ld (debug_mark+1),a  
2a2b 3a 35 2a			ld a, (.dmark+2)  
2a2e 32 a2 fd			ld (debug_mark+2),a  
2a31 18 03			jr .pastdmark  
2a33 ..			.dmark: db "CLL"  
2a36 f1			.pastdmark: pop af  
2a37			endm  
# End of macro DMARK
2a37					CALLMONITOR 
2a37 cd aa fd			call debug_vector  
2a3a				endm  
# End of macro CALLMONITOR
2a3a				endif 
2a3a			 
2a3a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a3a cd 4b 22			call macro_dsp_valuehl 
2a3d				endm 
# End of macro FORTH_DSP_VALUEHL
2a3d			 
2a3d			;		push hl 
2a3d			 
2a3d				; destroy value TOS 
2a3d			 
2a3d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a3d cd 03 23			call macro_forth_dsp_pop 
2a40				endm 
# End of macro FORTH_DSP_POP
2a40			 
2a40					 
2a40			;		pop hl 
2a40			 
2a40				; how to do a call with hl???? save SP? 
2a40 cd db 23			call forth_call_hl 
2a43			 
2a43			 
2a43				; TODO push value back onto stack for another op etc 
2a43			 
2a43 cd 46 20			call forth_push_numhl 
2a46				NEXTW 
2a46 c3 37 24			jp macro_next 
2a49				endm 
# End of macro NEXTW
2a49			.DEPTH: 
2a49			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2a49 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2a4a 86 2a			dw .OVER            
2a4c 06				db 5 + 1 
2a4d .. 00			db "DEPTH",0              
2a53				endm 
# End of macro CWHEAD
2a53			; | DEPTH ( -- u ) Push count of stack | DONE 
2a53				; take current TOS and remove from base value div by two to get count 
2a53				if DEBUG_FORTH_WORDS_KEY 
2a53					DMARK "DEP" 
2a53 f5				push af  
2a54 3a 68 2a			ld a, (.dmark)  
2a57 32 a0 fd			ld (debug_mark),a  
2a5a 3a 69 2a			ld a, (.dmark+1)  
2a5d 32 a1 fd			ld (debug_mark+1),a  
2a60 3a 6a 2a			ld a, (.dmark+2)  
2a63 32 a2 fd			ld (debug_mark+2),a  
2a66 18 03			jr .pastdmark  
2a68 ..			.dmark: db "DEP"  
2a6b f1			.pastdmark: pop af  
2a6c			endm  
# End of macro DMARK
2a6c					CALLMONITOR 
2a6c cd aa fd			call debug_vector  
2a6f				endm  
# End of macro CALLMONITOR
2a6f				endif 
2a6f			 
2a6f			 
2a6f 2a 23 f9		ld hl, (cli_data_sp) 
2a72 11 5d f6		ld de, cli_data_stack 
2a75 ed 52		sbc hl,de 
2a77			 
2a77			; div by size of stack item 
2a77			 
2a77 5d			ld e,l 
2a78 0e 03		ld c, 3 
2a7a cd 6e 0f		call Div8 
2a7d			 
2a7d 6f			ld l,a 
2a7e 26 00		ld h,0 
2a80			 
2a80			;srl h 
2a80			;rr l 
2a80			 
2a80 cd 46 20			call forth_push_numhl 
2a83				NEXTW 
2a83 c3 37 24			jp macro_next 
2a86				endm 
# End of macro NEXTW
2a86			.OVER: 
2a86			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2a86 42				db WORD_SYS_CORE+46             
2a87 cd 2a			dw .PAUSE            
2a89 05				db 4 + 1 
2a8a .. 00			db "OVER",0              
2a8f				endm 
# End of macro CWHEAD
2a8f			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2a8f				if DEBUG_FORTH_WORDS_KEY 
2a8f					DMARK "OVR" 
2a8f f5				push af  
2a90 3a a4 2a			ld a, (.dmark)  
2a93 32 a0 fd			ld (debug_mark),a  
2a96 3a a5 2a			ld a, (.dmark+1)  
2a99 32 a1 fd			ld (debug_mark+1),a  
2a9c 3a a6 2a			ld a, (.dmark+2)  
2a9f 32 a2 fd			ld (debug_mark+2),a  
2aa2 18 03			jr .pastdmark  
2aa4 ..			.dmark: db "OVR"  
2aa7 f1			.pastdmark: pop af  
2aa8			endm  
# End of macro DMARK
2aa8					CALLMONITOR 
2aa8 cd aa fd			call debug_vector  
2aab				endm  
# End of macro CALLMONITOR
2aab				endif 
2aab			 
2aab			; TODO Use os stack swap memory 
2aab				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2aab cd 4b 22			call macro_dsp_valuehl 
2aae				endm 
# End of macro FORTH_DSP_VALUEHL
2aae e5				push hl    ; n2 
2aaf				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2aaf cd 03 23			call macro_forth_dsp_pop 
2ab2				endm 
# End of macro FORTH_DSP_POP
2ab2			 
2ab2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ab2 cd 4b 22			call macro_dsp_valuehl 
2ab5				endm 
# End of macro FORTH_DSP_VALUEHL
2ab5 e5				push hl    ; n1 
2ab6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ab6 cd 03 23			call macro_forth_dsp_pop 
2ab9				endm 
# End of macro FORTH_DSP_POP
2ab9			 
2ab9 d1				pop de     ; n1 
2aba e1				pop hl     ; n2 
2abb			 
2abb d5				push de 
2abc e5				push hl 
2abd d5				push de 
2abe			 
2abe				; push back  
2abe			 
2abe e1				pop hl 
2abf cd 46 20			call forth_push_numhl 
2ac2 e1				pop hl 
2ac3 cd 46 20			call forth_push_numhl 
2ac6 e1				pop hl 
2ac7 cd 46 20			call forth_push_numhl 
2aca				NEXTW 
2aca c3 37 24			jp macro_next 
2acd				endm 
# End of macro NEXTW
2acd			 
2acd			.PAUSE: 
2acd			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2acd 43				db WORD_SYS_CORE+47             
2ace 02 2b			dw .PAUSES            
2ad0 08				db 7 + 1 
2ad1 .. 00			db "PAUSEMS",0              
2ad9				endm 
# End of macro CWHEAD
2ad9			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2ad9				if DEBUG_FORTH_WORDS_KEY 
2ad9					DMARK "PMS" 
2ad9 f5				push af  
2ada 3a ee 2a			ld a, (.dmark)  
2add 32 a0 fd			ld (debug_mark),a  
2ae0 3a ef 2a			ld a, (.dmark+1)  
2ae3 32 a1 fd			ld (debug_mark+1),a  
2ae6 3a f0 2a			ld a, (.dmark+2)  
2ae9 32 a2 fd			ld (debug_mark+2),a  
2aec 18 03			jr .pastdmark  
2aee ..			.dmark: db "PMS"  
2af1 f1			.pastdmark: pop af  
2af2			endm  
# End of macro DMARK
2af2					CALLMONITOR 
2af2 cd aa fd			call debug_vector  
2af5				endm  
# End of macro CALLMONITOR
2af5				endif 
2af5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2af5 cd 4b 22			call macro_dsp_valuehl 
2af8				endm 
# End of macro FORTH_DSP_VALUEHL
2af8			;		push hl    ; n2 
2af8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2af8 cd 03 23			call macro_forth_dsp_pop 
2afb				endm 
# End of macro FORTH_DSP_POP
2afb			;		pop hl 
2afb			 
2afb 7d				ld a, l 
2afc cd d2 0c			call aDelayInMS 
2aff			       NEXTW 
2aff c3 37 24			jp macro_next 
2b02				endm 
# End of macro NEXTW
2b02			.PAUSES:  
2b02			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b02 44				db WORD_SYS_CORE+48             
2b03 71 2b			dw .ROT            
2b05 06				db 5 + 1 
2b06 .. 00			db "PAUSE",0              
2b0c				endm 
# End of macro CWHEAD
2b0c			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b0c				if DEBUG_FORTH_WORDS_KEY 
2b0c					DMARK "PAU" 
2b0c f5				push af  
2b0d 3a 21 2b			ld a, (.dmark)  
2b10 32 a0 fd			ld (debug_mark),a  
2b13 3a 22 2b			ld a, (.dmark+1)  
2b16 32 a1 fd			ld (debug_mark+1),a  
2b19 3a 23 2b			ld a, (.dmark+2)  
2b1c 32 a2 fd			ld (debug_mark+2),a  
2b1f 18 03			jr .pastdmark  
2b21 ..			.dmark: db "PAU"  
2b24 f1			.pastdmark: pop af  
2b25			endm  
# End of macro DMARK
2b25					CALLMONITOR 
2b25 cd aa fd			call debug_vector  
2b28				endm  
# End of macro CALLMONITOR
2b28				endif 
2b28				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b28 cd 4b 22			call macro_dsp_valuehl 
2b2b				endm 
# End of macro FORTH_DSP_VALUEHL
2b2b			;		push hl    ; n2 
2b2b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b2b cd 03 23			call macro_forth_dsp_pop 
2b2e				endm 
# End of macro FORTH_DSP_POP
2b2e			;		pop hl 
2b2e 45				ld b, l 
2b2f				if DEBUG_FORTH_WORDS 
2b2f					DMARK "PAU" 
2b2f f5				push af  
2b30 3a 44 2b			ld a, (.dmark)  
2b33 32 a0 fd			ld (debug_mark),a  
2b36 3a 45 2b			ld a, (.dmark+1)  
2b39 32 a1 fd			ld (debug_mark+1),a  
2b3c 3a 46 2b			ld a, (.dmark+2)  
2b3f 32 a2 fd			ld (debug_mark+2),a  
2b42 18 03			jr .pastdmark  
2b44 ..			.dmark: db "PAU"  
2b47 f1			.pastdmark: pop af  
2b48			endm  
# End of macro DMARK
2b48					CALLMONITOR 
2b48 cd aa fd			call debug_vector  
2b4b				endm  
# End of macro CALLMONITOR
2b4b				endif 
2b4b c5			.pauses1:	push bc 
2b4c cd ed 0c			call delay1s 
2b4f c1				pop bc 
2b50				if DEBUG_FORTH_WORDS 
2b50					DMARK "PA1" 
2b50 f5				push af  
2b51 3a 65 2b			ld a, (.dmark)  
2b54 32 a0 fd			ld (debug_mark),a  
2b57 3a 66 2b			ld a, (.dmark+1)  
2b5a 32 a1 fd			ld (debug_mark+1),a  
2b5d 3a 67 2b			ld a, (.dmark+2)  
2b60 32 a2 fd			ld (debug_mark+2),a  
2b63 18 03			jr .pastdmark  
2b65 ..			.dmark: db "PA1"  
2b68 f1			.pastdmark: pop af  
2b69			endm  
# End of macro DMARK
2b69					CALLMONITOR 
2b69 cd aa fd			call debug_vector  
2b6c				endm  
# End of macro CALLMONITOR
2b6c				endif 
2b6c 10 dd			djnz .pauses1 
2b6e			 
2b6e			       NEXTW 
2b6e c3 37 24			jp macro_next 
2b71				endm 
# End of macro NEXTW
2b71			.ROT: 
2b71			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2b71 45				db WORD_SYS_CORE+49             
2b72 bf 2b			dw .UWORDS            
2b74 04				db 3 + 1 
2b75 .. 00			db "ROT",0              
2b79				endm 
# End of macro CWHEAD
2b79			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2b79				if DEBUG_FORTH_WORDS_KEY 
2b79					DMARK "ROT" 
2b79 f5				push af  
2b7a 3a 8e 2b			ld a, (.dmark)  
2b7d 32 a0 fd			ld (debug_mark),a  
2b80 3a 8f 2b			ld a, (.dmark+1)  
2b83 32 a1 fd			ld (debug_mark+1),a  
2b86 3a 90 2b			ld a, (.dmark+2)  
2b89 32 a2 fd			ld (debug_mark+2),a  
2b8c 18 03			jr .pastdmark  
2b8e ..			.dmark: db "ROT"  
2b91 f1			.pastdmark: pop af  
2b92			endm  
# End of macro DMARK
2b92					CALLMONITOR 
2b92 cd aa fd			call debug_vector  
2b95				endm  
# End of macro CALLMONITOR
2b95				endif 
2b95			 
2b95			; TODO Use os stack swap memory 
2b95				FORTH_DSP_VALUEHL 
2b95 cd 4b 22			call macro_dsp_valuehl 
2b98				endm 
# End of macro FORTH_DSP_VALUEHL
2b98 e5				push hl    ; u3  
2b99			 
2b99				FORTH_DSP_POP 
2b99 cd 03 23			call macro_forth_dsp_pop 
2b9c				endm 
# End of macro FORTH_DSP_POP
2b9c			 
2b9c				FORTH_DSP_VALUEHL 
2b9c cd 4b 22			call macro_dsp_valuehl 
2b9f				endm 
# End of macro FORTH_DSP_VALUEHL
2b9f e5				push hl     ; u2 
2ba0			 
2ba0				FORTH_DSP_POP 
2ba0 cd 03 23			call macro_forth_dsp_pop 
2ba3				endm 
# End of macro FORTH_DSP_POP
2ba3			 
2ba3				FORTH_DSP_VALUEHL 
2ba3 cd 4b 22			call macro_dsp_valuehl 
2ba6				endm 
# End of macro FORTH_DSP_VALUEHL
2ba6 e5				push hl     ; u1 
2ba7			 
2ba7				FORTH_DSP_POP 
2ba7 cd 03 23			call macro_forth_dsp_pop 
2baa				endm 
# End of macro FORTH_DSP_POP
2baa			 
2baa c1				pop bc      ; u1 
2bab e1				pop hl      ; u2 
2bac d1				pop de      ; u3 
2bad			 
2bad			 
2bad c5				push bc 
2bae d5				push de 
2baf e5				push hl 
2bb0			 
2bb0			 
2bb0 e1				pop hl 
2bb1 cd 46 20			call forth_push_numhl 
2bb4			 
2bb4 e1				pop hl 
2bb5 cd 46 20			call forth_push_numhl 
2bb8			 
2bb8 e1				pop hl 
2bb9 cd 46 20			call forth_push_numhl 
2bbc				 
2bbc			 
2bbc			 
2bbc			 
2bbc			 
2bbc			 
2bbc			       NEXTW 
2bbc c3 37 24			jp macro_next 
2bbf				endm 
# End of macro NEXTW
2bbf			 
2bbf			.UWORDS: 
2bbf			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2bbf 50				db WORD_SYS_CORE+60             
2bc0 81 2c			dw .BP            
2bc2 07				db 6 + 1 
2bc3 .. 00			db "UWORDS",0              
2bca				endm 
# End of macro CWHEAD
2bca			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2bca			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2bca			; | | Following the count are the individual words. 
2bca			; | | 
2bca			; | | e.g. UWORDS 
2bca			; | | BOX DIRLIST 2 
2bca			; | |  
2bca			; | | Can be used to save the words to storage via: 
2bca			; | | UWORDS $01 DO $01 APPEND LOOP 
2bca			if DEBUG_FORTH_WORDS_KEY 
2bca				DMARK "UWR" 
2bca f5				push af  
2bcb 3a df 2b			ld a, (.dmark)  
2bce 32 a0 fd			ld (debug_mark),a  
2bd1 3a e0 2b			ld a, (.dmark+1)  
2bd4 32 a1 fd			ld (debug_mark+1),a  
2bd7 3a e1 2b			ld a, (.dmark+2)  
2bda 32 a2 fd			ld (debug_mark+2),a  
2bdd 18 03			jr .pastdmark  
2bdf ..			.dmark: db "UWR"  
2be2 f1			.pastdmark: pop af  
2be3			endm  
# End of macro DMARK
2be3				CALLMONITOR 
2be3 cd aa fd			call debug_vector  
2be6				endm  
# End of macro CALLMONITOR
2be6			endif 
2be6 21 00 80			ld hl, baseram 
2be9				;ld hl, baseusermem 
2be9 01 00 00			ld bc, 0    ; start a counter 
2bec			 
2bec			; skip dict stub 
2bec			 
2bec cd 88 25			call forth_tok_next 
2bef			 
2bef			 
2bef			; while we have words to look for 
2bef			 
2bef 7e			.douscan:	ld a, (hl)      
2bf0			if DEBUG_FORTH_WORDS 
2bf0				DMARK "UWs" 
2bf0 f5				push af  
2bf1 3a 05 2c			ld a, (.dmark)  
2bf4 32 a0 fd			ld (debug_mark),a  
2bf7 3a 06 2c			ld a, (.dmark+1)  
2bfa 32 a1 fd			ld (debug_mark+1),a  
2bfd 3a 07 2c			ld a, (.dmark+2)  
2c00 32 a2 fd			ld (debug_mark+2),a  
2c03 18 03			jr .pastdmark  
2c05 ..			.dmark: db "UWs"  
2c08 f1			.pastdmark: pop af  
2c09			endm  
# End of macro DMARK
2c09				CALLMONITOR 
2c09 cd aa fd			call debug_vector  
2c0c				endm  
# End of macro CALLMONITOR
2c0c			endif 
2c0c fe 00			cp WORD_SYS_END 
2c0e 28 4d			jr z, .udone 
2c10 fe 01			cp WORD_SYS_UWORD 
2c12 20 44			jr nz, .nuword 
2c14			 
2c14			if DEBUG_FORTH_WORDS 
2c14				DMARK "UWu" 
2c14 f5				push af  
2c15 3a 29 2c			ld a, (.dmark)  
2c18 32 a0 fd			ld (debug_mark),a  
2c1b 3a 2a 2c			ld a, (.dmark+1)  
2c1e 32 a1 fd			ld (debug_mark+1),a  
2c21 3a 2b 2c			ld a, (.dmark+2)  
2c24 32 a2 fd			ld (debug_mark+2),a  
2c27 18 03			jr .pastdmark  
2c29 ..			.dmark: db "UWu"  
2c2c f1			.pastdmark: pop af  
2c2d			endm  
# End of macro DMARK
2c2d				CALLMONITOR 
2c2d cd aa fd			call debug_vector  
2c30				endm  
# End of macro CALLMONITOR
2c30			endif 
2c30				; we have a uword so push its name to the stack 
2c30			 
2c30 e5				push hl  ; save so we can move to next dict block 
2c31			 
2c31				; skip opcode 
2c31 23				inc hl  
2c32				; skip next ptr 
2c32 23				inc hl  
2c33 23				inc hl 
2c34				; skip len 
2c34 23				inc hl 
2c35			if DEBUG_FORTH_WORDS 
2c35				DMARK "UWt" 
2c35 f5				push af  
2c36 3a 4a 2c			ld a, (.dmark)  
2c39 32 a0 fd			ld (debug_mark),a  
2c3c 3a 4b 2c			ld a, (.dmark+1)  
2c3f 32 a1 fd			ld (debug_mark+1),a  
2c42 3a 4c 2c			ld a, (.dmark+2)  
2c45 32 a2 fd			ld (debug_mark+2),a  
2c48 18 03			jr .pastdmark  
2c4a ..			.dmark: db "UWt"  
2c4d f1			.pastdmark: pop af  
2c4e			endm  
# End of macro DMARK
2c4e				CALLMONITOR 
2c4e cd aa fd			call debug_vector  
2c51				endm  
# End of macro CALLMONITOR
2c51			endif 
2c51 03				inc bc 
2c52			 
2c52 c5				push bc 
2c53 cd b4 20			call forth_push_str 
2c56 c1				pop bc 
2c57			 
2c57 e1				pop hl 	 
2c58			 
2c58 cd 88 25		.nuword:	call forth_tok_next 
2c5b 18 92			jr .douscan  
2c5d			 
2c5d			.udone:		 ; push count of uwords found 
2c5d c5				push bc 
2c5e e1				pop hl 
2c5f			 
2c5f			if DEBUG_FORTH_WORDS 
2c5f				DMARK "UWc" 
2c5f f5				push af  
2c60 3a 74 2c			ld a, (.dmark)  
2c63 32 a0 fd			ld (debug_mark),a  
2c66 3a 75 2c			ld a, (.dmark+1)  
2c69 32 a1 fd			ld (debug_mark+1),a  
2c6c 3a 76 2c			ld a, (.dmark+2)  
2c6f 32 a2 fd			ld (debug_mark+2),a  
2c72 18 03			jr .pastdmark  
2c74 ..			.dmark: db "UWc"  
2c77 f1			.pastdmark: pop af  
2c78			endm  
# End of macro DMARK
2c78				CALLMONITOR 
2c78 cd aa fd			call debug_vector  
2c7b				endm  
# End of macro CALLMONITOR
2c7b			endif 
2c7b cd 46 20			call forth_push_numhl 
2c7e			 
2c7e			 
2c7e			       NEXTW 
2c7e c3 37 24			jp macro_next 
2c81				endm 
# End of macro NEXTW
2c81			 
2c81			.BP: 
2c81			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2c81 54				db WORD_SYS_CORE+64             
2c82 bb 2c			dw .MONITOR            
2c84 03				db 2 + 1 
2c85 .. 00			db "BP",0              
2c88				endm 
# End of macro CWHEAD
2c88			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2c88			; | | $00 Will enable the break points within specific code paths 
2c88			; | | $01 Will disable break points 
2c88			; | |  
2c88			; | | By default break points are off. Either the above can be used to enable them 
2c88			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2c88			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2c88			; | | can disable break points. Exiting will then continue boot process. 
2c88				; get byte count 
2c88				if DEBUG_FORTH_WORDS_KEY 
2c88					DMARK "BP." 
2c88 f5				push af  
2c89 3a 9d 2c			ld a, (.dmark)  
2c8c 32 a0 fd			ld (debug_mark),a  
2c8f 3a 9e 2c			ld a, (.dmark+1)  
2c92 32 a1 fd			ld (debug_mark+1),a  
2c95 3a 9f 2c			ld a, (.dmark+2)  
2c98 32 a2 fd			ld (debug_mark+2),a  
2c9b 18 03			jr .pastdmark  
2c9d ..			.dmark: db "BP."  
2ca0 f1			.pastdmark: pop af  
2ca1			endm  
# End of macro DMARK
2ca1					CALLMONITOR 
2ca1 cd aa fd			call debug_vector  
2ca4				endm  
# End of macro CALLMONITOR
2ca4				endif 
2ca4			 
2ca4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ca4 cd 4b 22			call macro_dsp_valuehl 
2ca7				endm 
# End of macro FORTH_DSP_VALUEHL
2ca7			 
2ca7			;		push hl 
2ca7			 
2ca7				; destroy value TOS 
2ca7			 
2ca7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ca7 cd 03 23			call macro_forth_dsp_pop 
2caa				endm 
# End of macro FORTH_DSP_POP
2caa			 
2caa			;		pop hl 
2caa			 
2caa 3e 00			ld a,0 
2cac bd				cp l 
2cad 28 06			jr z, .bpset 
2caf			;		ld a, '*' 
2caf cd 53 19			call bp_off 
2cb2				NEXTW 
2cb2 c3 37 24			jp macro_next 
2cb5				endm 
# End of macro NEXTW
2cb5			 
2cb5			.bpset:	 
2cb5				;	ld (os_view_disable), a 
2cb5 cd 47 19			call bp_on 
2cb8			 
2cb8			 
2cb8				NEXTW 
2cb8 c3 37 24			jp macro_next 
2cbb				endm 
# End of macro NEXTW
2cbb			 
2cbb			 
2cbb			.MONITOR: 
2cbb			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2cbb 55				db WORD_SYS_CORE+65             
2cbc ec 2c			dw .MALLOC            
2cbe 08				db 7 + 1 
2cbf .. 00			db "MONITOR",0              
2cc7				endm 
# End of macro CWHEAD
2cc7			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2cc7			; | | At start the current various registers will be displayed with contents. 
2cc7			; | | Top right corner will show the most recent debug marker seen. 
2cc7			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2cc7			; | | and the return stack pointer (RSP). 
2cc7			; | | Pressing: 
2cc7			; | |    1 - Initial screen 
2cc7			; | |    2 - Display a data dump of HL 
2cc7			; | |    3 - Display a data dump of DE 
2cc7			; | |    4 - Display a data dump of BC 
2cc7			; | |    5 - Display a data dump of HL 
2cc7			; | |    6 - Display a data dump of DSP 
2cc7			; | |    7 - Display a data dump of RSP 
2cc7			; | |    8 - Display a data dump of what is at DSP 
2cc7			; | |    9 - Display a data dump of what is at RSP 
2cc7			; | |    0 - Exit monitor and continue running. This will also enable break points 
2cc7			; | |    * - Disable break points 
2cc7			; | |    # - Enter traditional monitor mode 
2cc7			; | | 
2cc7			; | | Monitor Mode 
2cc7			; | | ------------ 
2cc7			; | | A prompt of '>' will be shown for various commands: 
2cc7			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2cc7			; | |    C - Continue display a data dump from the last set address 
2cc7			; | |    M xxxx - Set start of memory edit at address xx 
2cc7			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2cc7			; | |    G xxxx - Exec code at specific address 
2cc7			; | |    Q - Return to previous 
2cc7				if DEBUG_FORTH_WORDS_KEY 
2cc7					DMARK "MON" 
2cc7 f5				push af  
2cc8 3a dc 2c			ld a, (.dmark)  
2ccb 32 a0 fd			ld (debug_mark),a  
2cce 3a dd 2c			ld a, (.dmark+1)  
2cd1 32 a1 fd			ld (debug_mark+1),a  
2cd4 3a de 2c			ld a, (.dmark+2)  
2cd7 32 a2 fd			ld (debug_mark+2),a  
2cda 18 03			jr .pastdmark  
2cdc ..			.dmark: db "MON"  
2cdf f1			.pastdmark: pop af  
2ce0			endm  
# End of macro DMARK
2ce0					CALLMONITOR 
2ce0 cd aa fd			call debug_vector  
2ce3				endm  
# End of macro CALLMONITOR
2ce3				endif 
2ce3			;		ld a, 0 
2ce3			;		ld (os_view_disable), a 
2ce3 cd 47 19			call bp_on 
2ce6			 
2ce6				CALLMONITOR 
2ce6 cd aa fd			call debug_vector  
2ce9				endm  
# End of macro CALLMONITOR
2ce9			 
2ce9			;	call monitor 
2ce9			 
2ce9				NEXTW 
2ce9 c3 37 24			jp macro_next 
2cec				endm 
# End of macro NEXTW
2cec			 
2cec			 
2cec			.MALLOC: 
2cec			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2cec 56				db WORD_SYS_CORE+66             
2ced 15 2d			dw .MALLOC2            
2cef 06				db 5 + 1 
2cf0 .. 00			db "ALLOT",0              
2cf6				endm 
# End of macro CWHEAD
2cf6			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2cf6				if DEBUG_FORTH_WORDS_KEY 
2cf6					DMARK "ALL" 
2cf6 f5				push af  
2cf7 3a 0b 2d			ld a, (.dmark)  
2cfa 32 a0 fd			ld (debug_mark),a  
2cfd 3a 0c 2d			ld a, (.dmark+1)  
2d00 32 a1 fd			ld (debug_mark+1),a  
2d03 3a 0d 2d			ld a, (.dmark+2)  
2d06 32 a2 fd			ld (debug_mark+2),a  
2d09 18 03			jr .pastdmark  
2d0b ..			.dmark: db "ALL"  
2d0e f1			.pastdmark: pop af  
2d0f			endm  
# End of macro DMARK
2d0f					CALLMONITOR 
2d0f cd aa fd			call debug_vector  
2d12				endm  
# End of macro CALLMONITOR
2d12				endif 
2d12 c3 3c 2d			jp .mallocc 
2d15			.MALLOC2: 
2d15			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d15 56				db WORD_SYS_CORE+66             
2d16 53 2d			dw .FREE            
2d18 07				db 6 + 1 
2d19 .. 00			db "MALLOC",0              
2d20				endm 
# End of macro CWHEAD
2d20			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d20				; get byte count 
2d20				if DEBUG_FORTH_WORDS_KEY 
2d20					DMARK "MAL" 
2d20 f5				push af  
2d21 3a 35 2d			ld a, (.dmark)  
2d24 32 a0 fd			ld (debug_mark),a  
2d27 3a 36 2d			ld a, (.dmark+1)  
2d2a 32 a1 fd			ld (debug_mark+1),a  
2d2d 3a 37 2d			ld a, (.dmark+2)  
2d30 32 a2 fd			ld (debug_mark+2),a  
2d33 18 03			jr .pastdmark  
2d35 ..			.dmark: db "MAL"  
2d38 f1			.pastdmark: pop af  
2d39			endm  
# End of macro DMARK
2d39					CALLMONITOR 
2d39 cd aa fd			call debug_vector  
2d3c				endm  
# End of macro CALLMONITOR
2d3c				endif 
2d3c			.mallocc: 
2d3c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d3c cd 4b 22			call macro_dsp_valuehl 
2d3f				endm 
# End of macro FORTH_DSP_VALUEHL
2d3f			 
2d3f			;		push hl 
2d3f			 
2d3f				; destroy value TOS 
2d3f			 
2d3f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d3f cd 03 23			call macro_forth_dsp_pop 
2d42				endm 
# End of macro FORTH_DSP_POP
2d42			 
2d42			;		pop hl 
2d42 cd b9 13			call malloc 
2d45			if DEBUG_FORTH_MALLOC_GUARD 
2d45 f5				push af 
2d46 cd 07 10			call ishlzero 
2d49			;		ld a, l 
2d49			;		add h 
2d49			;		cp 0 
2d49 f1				pop af 
2d4a				 
2d4a cc 16 5e			call z,malloc_error 
2d4d			endif 
2d4d			 
2d4d cd 46 20			call forth_push_numhl 
2d50				NEXTW 
2d50 c3 37 24			jp macro_next 
2d53				endm 
# End of macro NEXTW
2d53			 
2d53			.FREE: 
2d53			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2d53 57				db WORD_SYS_CORE+67             
2d54 84 2d			dw .LIST            
2d56 05				db 4 + 1 
2d57 .. 00			db "FREE",0              
2d5c				endm 
# End of macro CWHEAD
2d5c			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2d5c				if DEBUG_FORTH_WORDS_KEY 
2d5c					DMARK "FRE" 
2d5c f5				push af  
2d5d 3a 71 2d			ld a, (.dmark)  
2d60 32 a0 fd			ld (debug_mark),a  
2d63 3a 72 2d			ld a, (.dmark+1)  
2d66 32 a1 fd			ld (debug_mark+1),a  
2d69 3a 73 2d			ld a, (.dmark+2)  
2d6c 32 a2 fd			ld (debug_mark+2),a  
2d6f 18 03			jr .pastdmark  
2d71 ..			.dmark: db "FRE"  
2d74 f1			.pastdmark: pop af  
2d75			endm  
# End of macro DMARK
2d75					CALLMONITOR 
2d75 cd aa fd			call debug_vector  
2d78				endm  
# End of macro CALLMONITOR
2d78				endif 
2d78				; get address 
2d78			 
2d78				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d78 cd 4b 22			call macro_dsp_valuehl 
2d7b				endm 
# End of macro FORTH_DSP_VALUEHL
2d7b			 
2d7b			;		push hl 
2d7b			 
2d7b				; destroy value TOS 
2d7b			 
2d7b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d7b cd 03 23			call macro_forth_dsp_pop 
2d7e				endm 
# End of macro FORTH_DSP_POP
2d7e			 
2d7e			;		pop hl 
2d7e			if FORTH_ENABLE_MALLOCFREE 
2d7e cd 83 14			call free 
2d81			endif 
2d81				NEXTW 
2d81 c3 37 24			jp macro_next 
2d84				endm 
# End of macro NEXTW
2d84			.LIST: 
2d84			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2d84 5c				db WORD_SYS_CORE+72             
2d85 80 2f			dw .FORGET            
2d87 05				db 4 + 1 
2d88 .. 00			db "LIST",0              
2d8d				endm 
# End of macro CWHEAD
2d8d			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2d8d			; | | The quoted word must be in upper case. 
2d8d			if DEBUG_FORTH_WORDS_KEY 
2d8d				DMARK "LST" 
2d8d f5				push af  
2d8e 3a a2 2d			ld a, (.dmark)  
2d91 32 a0 fd			ld (debug_mark),a  
2d94 3a a3 2d			ld a, (.dmark+1)  
2d97 32 a1 fd			ld (debug_mark+1),a  
2d9a 3a a4 2d			ld a, (.dmark+2)  
2d9d 32 a2 fd			ld (debug_mark+2),a  
2da0 18 03			jr .pastdmark  
2da2 ..			.dmark: db "LST"  
2da5 f1			.pastdmark: pop af  
2da6			endm  
# End of macro DMARK
2da6				CALLMONITOR 
2da6 cd aa fd			call debug_vector  
2da9				endm  
# End of macro CALLMONITOR
2da9			endif 
2da9			 
2da9				FORTH_DSP_VALUEHL 
2da9 cd 4b 22			call macro_dsp_valuehl 
2dac				endm 
# End of macro FORTH_DSP_VALUEHL
2dac			 
2dac e5				push hl 
2dad				FORTH_DSP_POP 
2dad cd 03 23			call macro_forth_dsp_pop 
2db0				endm 
# End of macro FORTH_DSP_POP
2db0 c1				pop bc 
2db1			 
2db1			; Start format of scratch string 
2db1			 
2db1 21 f6 f0			ld hl, scratch 
2db4			 
2db4 3e 3a			ld a, ':' 
2db6 77				ld (hl),a 
2db7 23				inc hl 
2db8 3e 20			ld a, ' ' 
2dba 77				ld (hl), a 
2dbb			 
2dbb				; Get ptr to the word we need to look up 
2dbb			 
2dbb			;		FORTH_DSP_VALUEHL 
2dbb				;v5 FORTH_DSP_VALUE 
2dbb			; TODO type check 
2dbb			;		inc hl    ; Skip type check  
2dbb			;		push hl 
2dbb			;		ex de, hl    ; put into DE 
2dbb			 
2dbb			 
2dbb 21 00 80			ld hl, baseram 
2dbe				;ld hl, baseusermem 
2dbe			 
2dbe e5			push hl   ; sacreifical push 
2dbf			 
2dbf			.ldouscanm: 
2dbf e1			pop hl 
2dc0			.ldouscan: 
2dc0			if DEBUG_FORTH_WORDS 
2dc0				DMARK "LSs" 
2dc0 f5				push af  
2dc1 3a d5 2d			ld a, (.dmark)  
2dc4 32 a0 fd			ld (debug_mark),a  
2dc7 3a d6 2d			ld a, (.dmark+1)  
2dca 32 a1 fd			ld (debug_mark+1),a  
2dcd 3a d7 2d			ld a, (.dmark+2)  
2dd0 32 a2 fd			ld (debug_mark+2),a  
2dd3 18 03			jr .pastdmark  
2dd5 ..			.dmark: db "LSs"  
2dd8 f1			.pastdmark: pop af  
2dd9			endm  
# End of macro DMARK
2dd9				CALLMONITOR 
2dd9 cd aa fd			call debug_vector  
2ddc				endm  
# End of macro CALLMONITOR
2ddc			endif 
2ddc			; skip dict stub 
2ddc cd 88 25			call forth_tok_next 
2ddf			 
2ddf			 
2ddf			; while we have words to look for 
2ddf			 
2ddf 7e			ld a, (hl)      
2de0			if DEBUG_FORTH_WORDS 
2de0				DMARK "LSk" 
2de0 f5				push af  
2de1 3a f5 2d			ld a, (.dmark)  
2de4 32 a0 fd			ld (debug_mark),a  
2de7 3a f6 2d			ld a, (.dmark+1)  
2dea 32 a1 fd			ld (debug_mark+1),a  
2ded 3a f7 2d			ld a, (.dmark+2)  
2df0 32 a2 fd			ld (debug_mark+2),a  
2df3 18 03			jr .pastdmark  
2df5 ..			.dmark: db "LSk"  
2df8 f1			.pastdmark: pop af  
2df9			endm  
# End of macro DMARK
2df9				CALLMONITOR 
2df9 cd aa fd			call debug_vector  
2dfc				endm  
# End of macro CALLMONITOR
2dfc			endif 
2dfc				;cp WORD_SYS_END 
2dfc				;jp z, .lunotfound 
2dfc			 
2dfc					; if we hit non uwords then gone too far 
2dfc fe 01				cp WORD_SYS_UWORD 
2dfe c2 3c 2f				jp nz, .lunotfound 
2e01			 
2e01				if DEBUG_FORTH_WORDS 
2e01					DMARK "LSu" 
2e01 f5				push af  
2e02 3a 16 2e			ld a, (.dmark)  
2e05 32 a0 fd			ld (debug_mark),a  
2e08 3a 17 2e			ld a, (.dmark+1)  
2e0b 32 a1 fd			ld (debug_mark+1),a  
2e0e 3a 18 2e			ld a, (.dmark+2)  
2e11 32 a2 fd			ld (debug_mark+2),a  
2e14 18 03			jr .pastdmark  
2e16 ..			.dmark: db "LSu"  
2e19 f1			.pastdmark: pop af  
2e1a			endm  
# End of macro DMARK
2e1a					CALLMONITOR 
2e1a cd aa fd			call debug_vector  
2e1d				endm  
# End of macro CALLMONITOR
2e1d				endif 
2e1d			 
2e1d					; found a uword but is it the one we want... 
2e1d			 
2e1d c5					push bc     ; uword to find is on bc 
2e1e d1					pop de 
2e1f			 
2e1f e5					push hl  ; to save the ptr 
2e20			 
2e20					; skip opcode 
2e20 23					inc hl  
2e21					; skip next ptr 
2e21 23					inc hl  
2e22 23					inc hl 
2e23					; skip len 
2e23 23					inc hl 
2e24			 
2e24				if DEBUG_FORTH_WORDS 
2e24					DMARK "LSc" 
2e24 f5				push af  
2e25 3a 39 2e			ld a, (.dmark)  
2e28 32 a0 fd			ld (debug_mark),a  
2e2b 3a 3a 2e			ld a, (.dmark+1)  
2e2e 32 a1 fd			ld (debug_mark+1),a  
2e31 3a 3b 2e			ld a, (.dmark+2)  
2e34 32 a2 fd			ld (debug_mark+2),a  
2e37 18 03			jr .pastdmark  
2e39 ..			.dmark: db "LSc"  
2e3c f1			.pastdmark: pop af  
2e3d			endm  
# End of macro DMARK
2e3d					CALLMONITOR 
2e3d cd aa fd			call debug_vector  
2e40				endm  
# End of macro CALLMONITOR
2e40				endif 
2e40			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2e40			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2e40			; Nope that has gone the other way. It needs to be exact not on first zero 
2e40			;		call strcmp 
2e40 c5					push bc 
2e41 cd 89 13				call StrictStrCmp 
2e44 c1					pop bc 
2e45 c2 bf 2d				jp nz, .ldouscanm 
2e48				 
2e48			 
2e48			 
2e48					; we have a uword so push its name to the stack 
2e48			 
2e48			;	   	push hl  ; save so we can move to next dict block 
2e48 e1			pop hl 
2e49			 
2e49				if DEBUG_FORTH_WORDS 
2e49					DMARK "LSm" 
2e49 f5				push af  
2e4a 3a 5e 2e			ld a, (.dmark)  
2e4d 32 a0 fd			ld (debug_mark),a  
2e50 3a 5f 2e			ld a, (.dmark+1)  
2e53 32 a1 fd			ld (debug_mark+1),a  
2e56 3a 60 2e			ld a, (.dmark+2)  
2e59 32 a2 fd			ld (debug_mark+2),a  
2e5c 18 03			jr .pastdmark  
2e5e ..			.dmark: db "LSm"  
2e61 f1			.pastdmark: pop af  
2e62			endm  
# End of macro DMARK
2e62					CALLMONITOR 
2e62 cd aa fd			call debug_vector  
2e65				endm  
# End of macro CALLMONITOR
2e65				endif 
2e65			 
2e65					; skip opcode 
2e65 23					inc hl  
2e66					; skip next ptr 
2e66 23					inc hl  
2e67 23					inc hl 
2e68					; skip len 
2e68 7e					ld a, (hl)   ; save length to add 
2e69				if DEBUG_FORTH_WORDS 
2e69					DMARK "LS2" 
2e69 f5				push af  
2e6a 3a 7e 2e			ld a, (.dmark)  
2e6d 32 a0 fd			ld (debug_mark),a  
2e70 3a 7f 2e			ld a, (.dmark+1)  
2e73 32 a1 fd			ld (debug_mark+1),a  
2e76 3a 80 2e			ld a, (.dmark+2)  
2e79 32 a2 fd			ld (debug_mark+2),a  
2e7c 18 03			jr .pastdmark  
2e7e ..			.dmark: db "LS2"  
2e81 f1			.pastdmark: pop af  
2e82			endm  
# End of macro DMARK
2e82					CALLMONITOR 
2e82 cd aa fd			call debug_vector  
2e85				endm  
# End of macro CALLMONITOR
2e85				endif 
2e85			 
2e85					; save this location 
2e85				 
2e85 e5					push hl 
2e86			 
2e86 23					inc hl 
2e87 11 f8 f0				ld de, scratch+2 
2e8a 4f					ld c, a 
2e8b 06 00				ld b, 0 
2e8d			 
2e8d				if DEBUG_FORTH_WORDS 
2e8d					DMARK "LSn" 
2e8d f5				push af  
2e8e 3a a2 2e			ld a, (.dmark)  
2e91 32 a0 fd			ld (debug_mark),a  
2e94 3a a3 2e			ld a, (.dmark+1)  
2e97 32 a1 fd			ld (debug_mark+1),a  
2e9a 3a a4 2e			ld a, (.dmark+2)  
2e9d 32 a2 fd			ld (debug_mark+2),a  
2ea0 18 03			jr .pastdmark  
2ea2 ..			.dmark: db "LSn"  
2ea5 f1			.pastdmark: pop af  
2ea6			endm  
# End of macro DMARK
2ea6					CALLMONITOR 
2ea6 cd aa fd			call debug_vector  
2ea9				endm  
# End of macro CALLMONITOR
2ea9				endif 
2ea9			 
2ea9					; copy uword name to scratch 
2ea9			 
2ea9			;		ldir 
2ea9			.licplw:	; copy uword name to scratch converting to lower case as we go 
2ea9 ed a0				ldi 
2eab 1b					dec de 
2eac 1a					ld a, (de) 
2ead cd 5c 12				call to_lower 
2eb0 12					ld (de),a 
2eb1 13					inc de 
2eb2 3e 00				ld a, 0 
2eb4 b9					cp c 
2eb5 20 f2				jr nz, .licplw 
2eb7			 
2eb7			 
2eb7			 
2eb7 1b					dec de 
2eb8 3e 20				ld a, ' '    ; change null to space 
2eba 12					ld (de), a 
2ebb			 
2ebb 13					inc de 
2ebc			 
2ebc d5					push de 
2ebd c1					pop bc     ; move scratch pointer to end of word name and save it 
2ebe			 
2ebe e1					pop hl 
2ebf 7e					ld a, (hl) 
2ec0					;inc hl 
2ec0					; skip word string 
2ec0 cd de 0f				call addatohl 
2ec3			 
2ec3 23					inc hl 
2ec4			 
2ec4				if DEBUG_FORTH_WORDS 
2ec4					DMARK "LS3" 
2ec4 f5				push af  
2ec5 3a d9 2e			ld a, (.dmark)  
2ec8 32 a0 fd			ld (debug_mark),a  
2ecb 3a da 2e			ld a, (.dmark+1)  
2ece 32 a1 fd			ld (debug_mark+1),a  
2ed1 3a db 2e			ld a, (.dmark+2)  
2ed4 32 a2 fd			ld (debug_mark+2),a  
2ed7 18 03			jr .pastdmark  
2ed9 ..			.dmark: db "LS3"  
2edc f1			.pastdmark: pop af  
2edd			endm  
# End of macro DMARK
2edd					CALLMONITOR 
2edd cd aa fd			call debug_vector  
2ee0				endm  
# End of macro CALLMONITOR
2ee0				endif 
2ee0					; should now be at the start of the machine code to setup the eval of the uword 
2ee0					; now locate the ptr to the string defintion 
2ee0			 
2ee0					; skip ld hl, 
2ee0					; then load the ptr 
2ee0			; TODO use get from hl ptr 
2ee0 23					inc hl 
2ee1 5e					ld e, (hl) 
2ee2 23					inc hl 
2ee3 56					ld d, (hl) 
2ee4 eb					ex de, hl 
2ee5			 
2ee5			 
2ee5				if DEBUG_FORTH_WORDS 
2ee5					DMARK "LSt" 
2ee5 f5				push af  
2ee6 3a fa 2e			ld a, (.dmark)  
2ee9 32 a0 fd			ld (debug_mark),a  
2eec 3a fb 2e			ld a, (.dmark+1)  
2eef 32 a1 fd			ld (debug_mark+1),a  
2ef2 3a fc 2e			ld a, (.dmark+2)  
2ef5 32 a2 fd			ld (debug_mark+2),a  
2ef8 18 03			jr .pastdmark  
2efa ..			.dmark: db "LSt"  
2efd f1			.pastdmark: pop af  
2efe			endm  
# End of macro DMARK
2efe					CALLMONITOR 
2efe cd aa fd			call debug_vector  
2f01				endm  
# End of macro CALLMONITOR
2f01				endif 
2f01			 
2f01			; cant push right now due to tokenised strings  
2f01			 
2f01			; get the destination of where to copy this definition to. 
2f01			 
2f01 c5					push bc 
2f02 d1					pop de 
2f03			 
2f03 7e			.listl:         ld a,(hl) 
2f04 fe 00				cp 0 
2f06 28 09				jr z, .lreplsp     ; replace zero with space 
2f08					;cp FORTH_END_BUFFER 
2f08 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f0a 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f0c				 
2f0c					; just copy this char as is then 
2f0c			 
2f0c 12					ld (de), a 
2f0d			 
2f0d 23			.listnxt:	inc hl 
2f0e 13					inc de 
2f0f 18 f2				jr .listl 
2f11			 
2f11 3e 20		.lreplsp:	ld a,' ' 
2f13 12					ld (de), a 
2f14 18 f7				jr .listnxt 
2f16			 
2f16			; close up uword def 
2f16			 
2f16			.listdone: 
2f16 12					ld (de), a 
2f17 13					inc de 
2f18 3e 00				ld a, 0 
2f1a 12					ld (de), a 
2f1b			 
2f1b			; now have def so clean up and push to stack 
2f1b			 
2f1b 21 f6 f0				ld hl, scratch 
2f1e				if DEBUG_FORTH_WORDS 
2f1e					DMARK "Ltp" 
2f1e f5				push af  
2f1f 3a 33 2f			ld a, (.dmark)  
2f22 32 a0 fd			ld (debug_mark),a  
2f25 3a 34 2f			ld a, (.dmark+1)  
2f28 32 a1 fd			ld (debug_mark+1),a  
2f2b 3a 35 2f			ld a, (.dmark+2)  
2f2e 32 a2 fd			ld (debug_mark+2),a  
2f31 18 03			jr .pastdmark  
2f33 ..			.dmark: db "Ltp"  
2f36 f1			.pastdmark: pop af  
2f37			endm  
# End of macro DMARK
2f37					CALLMONITOR 
2f37 cd aa fd			call debug_vector  
2f3a				endm  
# End of macro CALLMONITOR
2f3a				endif 
2f3a			 
2f3a 18 1f			jr .listpush 
2f3c			 
2f3c			;.lnuword:	pop hl 
2f3c			;		call forth_tok_next 
2f3c			;		jp .ldouscan  
2f3c			 
2f3c			.lunotfound:		  
2f3c			 
2f3c				if DEBUG_FORTH_WORDS 
2f3c					DMARK "LSn" 
2f3c f5				push af  
2f3d 3a 51 2f			ld a, (.dmark)  
2f40 32 a0 fd			ld (debug_mark),a  
2f43 3a 52 2f			ld a, (.dmark+1)  
2f46 32 a1 fd			ld (debug_mark+1),a  
2f49 3a 53 2f			ld a, (.dmark+2)  
2f4c 32 a2 fd			ld (debug_mark+2),a  
2f4f 18 03			jr .pastdmark  
2f51 ..			.dmark: db "LSn"  
2f54 f1			.pastdmark: pop af  
2f55			endm  
# End of macro DMARK
2f55					CALLMONITOR 
2f55 cd aa fd			call debug_vector  
2f58				endm  
# End of macro CALLMONITOR
2f58				endif 
2f58			 
2f58					 
2f58			;		FORTH_DSP_POP 
2f58			;		ld hl, .luno 
2f58			 
2f58					NEXTW			 
2f58 c3 37 24			jp macro_next 
2f5b				endm 
# End of macro NEXTW
2f5b			 
2f5b			.listpush: 
2f5b				if DEBUG_FORTH_WORDS 
2f5b					DMARK "LS>" 
2f5b f5				push af  
2f5c 3a 70 2f			ld a, (.dmark)  
2f5f 32 a0 fd			ld (debug_mark),a  
2f62 3a 71 2f			ld a, (.dmark+1)  
2f65 32 a1 fd			ld (debug_mark+1),a  
2f68 3a 72 2f			ld a, (.dmark+2)  
2f6b 32 a2 fd			ld (debug_mark+2),a  
2f6e 18 03			jr .pastdmark  
2f70 ..			.dmark: db "LS>"  
2f73 f1			.pastdmark: pop af  
2f74			endm  
# End of macro DMARK
2f74					CALLMONITOR 
2f74 cd aa fd			call debug_vector  
2f77				endm  
# End of macro CALLMONITOR
2f77				endif 
2f77 cd b4 20				call forth_push_str 
2f7a			 
2f7a			 
2f7a			 
2f7a					NEXTW 
2f7a c3 37 24			jp macro_next 
2f7d				endm 
# End of macro NEXTW
2f7d			 
2f7d			;.luno:    db "Word not found",0 
2f7d			 
2f7d			 
2f7d			 
2f7d			 
2f7d			 
2f7d			;		push hl   ; save pointer to start of uword def string 
2f7d			; 
2f7d			;; look for FORTH_EOL_LINE 
2f7d			;		ld a, FORTH_END_BUFFER 
2f7d			;		call strlent 
2f7d			; 
2f7d			;		inc hl		 ; space for coln def 
2f7d			;		inc hl 
2f7d			;		inc hl          ; space for terms 
2f7d			;		inc hl 
2f7d			; 
2f7d			;		ld a, 20   ; TODO get actual length 
2f7d			;		call addatohl    ; include a random amount of room for the uword name 
2f7d			; 
2f7d			;		 
2f7d			;	if DEBUG_FORTH_WORDS 
2f7d			;		DMARK "Lt1" 
2f7d			;		CALLMONITOR 
2f7d			;	endif 
2f7d			;		 
2f7d			; 
2f7d			;; malloc space for the string because we cant change it 
2f7d			; 
2f7d			;		call malloc 
2f7d			;	if DEBUG_FORTH_MALLOC_GUARD 
2f7d			;		push af 
2f7d			;		call ishlzero 
2f7d			;		pop af 
2f7d			;		 
2f7d			;		call z,malloc_error 
2f7d			;	endif 
2f7d			; 
2f7d			;	if DEBUG_FORTH_WORDS 
2f7d			;		DMARK "Lt2" 
2f7d			;		CALLMONITOR 
2f7d			;	endif 
2f7d			;		pop de 
2f7d			;		push hl    ; push the malloc to release later 
2f7d			;		push hl   ;  push back a copy for the later stack push 
2f7d			;		 
2f7d			;; copy the string swapping out the zero terms for spaces 
2f7d			; 
2f7d			;		; de has our source 
2f7d			;		; hl has our dest 
2f7d			; 
2f7d			;; add the coln def 
2f7d			; 
2f7d			;		ld a, ':' 
2f7d			;		ld (hl), a 
2f7d			;		inc hl 
2f7d			;		ld a, ' ' 
2f7d			;		ld (hl), a 
2f7d			;		inc hl 
2f7d			; 
2f7d			;; add the uname word 
2f7d			;		push de   ; save our string for now 
2f7d			;		ex de, hl 
2f7d			; 
2f7d			;		FORTH_DSP_VALUE 
2f7d			;		;v5 FORTH_DSP_VALUE 
2f7d			; 
2f7d			;		inc hl   ; skip type but we know by now this is OK 
2f7d			; 
2f7d			;.luword:	ld a,(hl) 
2f7d			;		cp 0 
2f7d			;		jr z, .luword2 
2f7d			;		ld (de), a 
2f7d			;		inc de 
2f7d			;		inc hl 
2f7d			;		jr .luword 
2f7d			; 
2f7d			;.luword2:	ld a, ' ' 
2f7d			;		ld (de), a 
2f7d			;;		inc hl 
2f7d			;;		inc de 
2f7d			;;		ld (de), a 
2f7d			;;		inc hl 
2f7d			;		inc de 
2f7d			; 
2f7d			;		ex de, hl 
2f7d			;		pop de 
2f7d			;		 
2f7d			;		 
2f7d			; 
2f7d			;; detoken that string and copy it 
2f7d			; 
2f7d			;	if DEBUG_FORTH_WORDS 
2f7d			;		DMARK "Lt2" 
2f7d			;		CALLMONITOR 
2f7d			;	endif 
2f7d			;.ldetok:	ld a, (de) 
2f7d			;		cp FORTH_END_BUFFER 
2f7d			;		jr z, .ldetokend 
2f7d			;		; swap out any zero term for space 
2f7d			;		cp 0 
2f7d			;		jr nz, .ldetoknext 
2f7d			;		ld a, ' ' 
2f7d			; 
2f7d			;	if DEBUG_FORTH_WORDS 
2f7d			;		DMARK "LtS" 
2f7d			;		CALLMONITOR 
2f7d			;	endif 
2f7d			;.ldetoknext:	ld (hl), a 
2f7d			;		inc de 
2f7d			;		inc hl 
2f7d			;		jr .ldetok 
2f7d			; 
2f7d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2f7d			;		ld (hl), a  
2f7d			; 
2f7d			;; free that temp malloc 
2f7d			; 
2f7d			;		pop hl    
2f7d			; 
2f7d			;	if DEBUG_FORTH_WORDS 
2f7d			;		DMARK "Lt4" 
2f7d			;		CALLMONITOR 
2f7d			;	endif 
2f7d			;		call forth_apushstrhl 
2f7d			; 
2f7d			;		; get rid of temp malloc area 
2f7d			; 
2f7d			;		pop hl 
2f7d			;		call free 
2f7d			; 
2f7d			;		jr .ludone 
2f7d			; 
2f7d			;.lnuword:	pop hl 
2f7d			;		call forth_tok_next 
2f7d			;		jp .ldouscan  
2f7d			; 
2f7d			;.ludone:		 pop hl 
2f7d			; 
2f7d					NEXTW 
2f7d c3 37 24			jp macro_next 
2f80				endm 
# End of macro NEXTW
2f80			 
2f80			.FORGET: 
2f80				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2f80 5d				db WORD_SYS_CORE+73             
2f81 f9 2f			dw .NOP            
2f83 07				db 6 + 1 
2f84 .. 00			db "FORGET",0              
2f8b				endm 
# End of macro CWHEAD
2f8b			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2f8b			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2f8b			; | |  
2f8b			; | | e.g. "MORE" forget 
2f8b					if DEBUG_FORTH_WORDS_KEY 
2f8b						DMARK "FRG" 
2f8b f5				push af  
2f8c 3a a0 2f			ld a, (.dmark)  
2f8f 32 a0 fd			ld (debug_mark),a  
2f92 3a a1 2f			ld a, (.dmark+1)  
2f95 32 a1 fd			ld (debug_mark+1),a  
2f98 3a a2 2f			ld a, (.dmark+2)  
2f9b 32 a2 fd			ld (debug_mark+2),a  
2f9e 18 03			jr .pastdmark  
2fa0 ..			.dmark: db "FRG"  
2fa3 f1			.pastdmark: pop af  
2fa4			endm  
# End of macro DMARK
2fa4						CALLMONITOR 
2fa4 cd aa fd			call debug_vector  
2fa7				endm  
# End of macro CALLMONITOR
2fa7					endif 
2fa7			 
2fa7				; find uword 
2fa7			        ; update start of word with "_" 
2fa7				; replace uword with deleted flag 
2fa7			 
2fa7			 
2fa7			;	if DEBUG_FORTH_WORDS 
2fa7			;		DMARK "FOG" 
2fa7			;		CALLMONITOR 
2fa7			;	endif 
2fa7			 
2fa7			 
2fa7					; Get ptr to the word we need to look up 
2fa7			 
2fa7					FORTH_DSP_VALUEHL 
2fa7 cd 4b 22			call macro_dsp_valuehl 
2faa				endm 
# End of macro FORTH_DSP_VALUEHL
2faa					;v5 FORTH_DSP_VALUE 
2faa				; TODO type check 
2faa			;		inc hl    ; Skip type check  
2faa e5					push hl 
2fab c1					pop bc 
2fac			;		ex de, hl    ; put into DE 
2fac			 
2fac			 
2fac 21 00 80				ld hl, baseram 
2faf					;ld hl, baseusermem 
2faf			 
2faf				; skip dict stub 
2faf			;	call forth_tok_next 
2faf e5			push hl   ; sacreifical push 
2fb0			 
2fb0			.fldouscanm: 
2fb0 e1				pop hl 
2fb1			.fldouscan: 
2fb1			;	if DEBUG_FORTH_WORDS 
2fb1			;		DMARK "LSs" 
2fb1			;		CALLMONITOR 
2fb1			;	endif 
2fb1				; skip dict stub 
2fb1 cd 88 25				call forth_tok_next 
2fb4			 
2fb4			 
2fb4			; while we have words to look for 
2fb4			 
2fb4 7e				ld a, (hl)      
2fb5			;	if DEBUG_FORTH_WORDS 
2fb5			;		DMARK "LSk" 
2fb5			;		CALLMONITOR 
2fb5			;	endif 
2fb5 fe 00				cp WORD_SYS_END 
2fb7 ca f3 2f				jp z, .flunotfound 
2fba fe 01				cp WORD_SYS_UWORD 
2fbc c2 b1 2f				jp nz, .fldouscan 
2fbf			 
2fbf			;	if DEBUG_FORTH_WORDS 
2fbf			;		DMARK "LSu" 
2fbf			;		CALLMONITOR 
2fbf			;	endif 
2fbf			 
2fbf					; found a uword but is it the one we want... 
2fbf			 
2fbf c5					push bc     ; uword to find is on bc 
2fc0 d1					pop de 
2fc1			 
2fc1 e5					push hl  ; to save the ptr 
2fc2			 
2fc2					; skip opcode 
2fc2 23					inc hl  
2fc3					; skip next ptr 
2fc3 23					inc hl  
2fc4 23					inc hl 
2fc5					; skip len 
2fc5 23					inc hl 
2fc6			 
2fc6			;	if DEBUG_FORTH_WORDS 
2fc6			;		DMARK "LSc" 
2fc6			;		CALLMONITOR 
2fc6			;	endif 
2fc6 cd 7c 13				call strcmp 
2fc9 c2 b0 2f				jp nz, .fldouscanm 
2fcc			; 
2fcc			; 
2fcc			;; while we have words to look for 
2fcc			; 
2fcc			;.fdouscan:	ld a, (hl)      
2fcc			;	if DEBUG_FORTH_WORDS 
2fcc			;		DMARK "LSs" 
2fcc			;		CALLMONITOR 
2fcc			;	endif 
2fcc			;		cp WORD_SYS_END 
2fcc			;		jp z, .fudone 
2fcc			;		cp WORD_SYS_UWORD 
2fcc			;		jp nz, .fnuword 
2fcc			; 
2fcc			;	if DEBUG_FORTH_WORDS 
2fcc			;		DMARK "FGu" 
2fcc			;		CALLMONITOR 
2fcc			;	endif 
2fcc			; 
2fcc			;		; found a uword but is it the one we want... 
2fcc			; 
2fcc			; 
2fcc			;	        pop de   ; get back the dsp name 
2fcc			;		push de 
2fcc			; 
2fcc			;		push hl  ; to save the ptr 
2fcc			; 
2fcc			;		; skip opcode 
2fcc			;		inc hl  
2fcc			;		; skip next ptr 
2fcc			;		inc hl  
2fcc			;		inc hl 
2fcc			;		; skip len 
2fcc			;		inc hl 
2fcc			; 
2fcc			;	if DEBUG_FORTH_WORDS 
2fcc			;		DMARK "FGc" 
2fcc			;		CALLMONITOR 
2fcc			;	endif 
2fcc			;		call strcmp 
2fcc			;		jp nz, .fnuword 
2fcc			 
2fcc			 
2fcc e1			pop hl 
2fcd			 
2fcd				 
2fcd				if DEBUG_FORTH_WORDS 
2fcd					DMARK "FGm" 
2fcd f5				push af  
2fce 3a e2 2f			ld a, (.dmark)  
2fd1 32 a0 fd			ld (debug_mark),a  
2fd4 3a e3 2f			ld a, (.dmark+1)  
2fd7 32 a1 fd			ld (debug_mark+1),a  
2fda 3a e4 2f			ld a, (.dmark+2)  
2fdd 32 a2 fd			ld (debug_mark+2),a  
2fe0 18 03			jr .pastdmark  
2fe2 ..			.dmark: db "FGm"  
2fe5 f1			.pastdmark: pop af  
2fe6			endm  
# End of macro DMARK
2fe6					CALLMONITOR 
2fe6 cd aa fd			call debug_vector  
2fe9				endm  
# End of macro CALLMONITOR
2fe9				endif 
2fe9			 
2fe9			 
2fe9			 
2fe9					; we have a uword so push its name to the stack 
2fe9			 
2fe9			;	   	push hl  ; save so we can move to next dict block 
2fe9			;pop hl 
2fe9			 
2fe9					; update opcode to deleted 
2fe9 3e 03				ld a, WORD_SYS_DELETED 
2feb 77					ld (hl), a 
2fec			 
2fec 23					inc hl  
2fed					; skip next ptr 
2fed 23					inc hl  
2fee 23					inc hl 
2fef					; skip len 
2fef 23					inc hl 
2ff0			 
2ff0					; TODO change parser to skip deleted words but for now mark it out 
2ff0 3e 5f				ld a, "_" 
2ff2 77					ld  (hl),a 
2ff3			 
2ff3			;		jr .fudone 
2ff3			; 
2ff3			;.fnuword:	pop hl 
2ff3			;		call forth_tok_next 
2ff3			;		jp .fdouscan  
2ff3			 
2ff3			.flunotfound:		  
2ff3			 
2ff3			 
2ff3					 
2ff3					FORTH_DSP_POP 
2ff3 cd 03 23			call macro_forth_dsp_pop 
2ff6				endm 
# End of macro FORTH_DSP_POP
2ff6			;		ld hl, .luno 
2ff6			;.fudone:		 pop hl 
2ff6					NEXTW 
2ff6 c3 37 24			jp macro_next 
2ff9				endm 
# End of macro NEXTW
2ff9			.NOP: 
2ff9				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ff9 61				db WORD_SYS_CORE+77             
2ffa 20 30			dw .COMO            
2ffc 04				db 3 + 1 
2ffd .. 00			db "NOP",0              
3001				endm 
# End of macro CWHEAD
3001			; | NOP (  --  ) Do nothing | DONE 
3001					if DEBUG_FORTH_WORDS_KEY 
3001						DMARK "NOP" 
3001 f5				push af  
3002 3a 16 30			ld a, (.dmark)  
3005 32 a0 fd			ld (debug_mark),a  
3008 3a 17 30			ld a, (.dmark+1)  
300b 32 a1 fd			ld (debug_mark+1),a  
300e 3a 18 30			ld a, (.dmark+2)  
3011 32 a2 fd			ld (debug_mark+2),a  
3014 18 03			jr .pastdmark  
3016 ..			.dmark: db "NOP"  
3019 f1			.pastdmark: pop af  
301a			endm  
# End of macro DMARK
301a						CALLMONITOR 
301a cd aa fd			call debug_vector  
301d				endm  
# End of macro CALLMONITOR
301d					endif 
301d				       NEXTW 
301d c3 37 24			jp macro_next 
3020				endm 
# End of macro NEXTW
3020			.COMO: 
3020				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
3020 6e				db WORD_SYS_CORE+90             
3021 72 30			dw .COMC            
3023 02				db 1 + 1 
3024 .. 00			db "(",0              
3026				endm 
# End of macro CWHEAD
3026			; | ( ( -- )  Start of comment | DONE 
3026			 
3026			 
3026 2a f7 f3				ld hl, ( os_tok_ptr) 
3029 11 6d 30			ld de, .closepar 
302c					 
302c					if DEBUG_FORTH_WORDS 
302c						DMARK ").." 
302c f5				push af  
302d 3a 41 30			ld a, (.dmark)  
3030 32 a0 fd			ld (debug_mark),a  
3033 3a 42 30			ld a, (.dmark+1)  
3036 32 a1 fd			ld (debug_mark+1),a  
3039 3a 43 30			ld a, (.dmark+2)  
303c 32 a2 fd			ld (debug_mark+2),a  
303f 18 03			jr .pastdmark  
3041 ..			.dmark: db ").."  
3044 f1			.pastdmark: pop af  
3045			endm  
# End of macro DMARK
3045						CALLMONITOR 
3045 cd aa fd			call debug_vector  
3048				endm  
# End of macro CALLMONITOR
3048					endif 
3048 cd 52 25			call findnexttok  
304b			 
304b					if DEBUG_FORTH_WORDS 
304b						DMARK "IF5" 
304b f5				push af  
304c 3a 60 30			ld a, (.dmark)  
304f 32 a0 fd			ld (debug_mark),a  
3052 3a 61 30			ld a, (.dmark+1)  
3055 32 a1 fd			ld (debug_mark+1),a  
3058 3a 62 30			ld a, (.dmark+2)  
305b 32 a2 fd			ld (debug_mark+2),a  
305e 18 03			jr .pastdmark  
3060 ..			.dmark: db "IF5"  
3063 f1			.pastdmark: pop af  
3064			endm  
# End of macro DMARK
3064						CALLMONITOR 
3064 cd aa fd			call debug_vector  
3067				endm  
# End of macro CALLMONITOR
3067					endif 
3067				; replace below with ) exec using tok_ptr 
3067 22 f7 f3			ld (os_tok_ptr), hl 
306a c3 c8 24			jp exec1 
306d			 
306d .. 00			.closepar:   db ")",0 
306f			 
306f				       NEXTW 
306f c3 37 24			jp macro_next 
3072				endm 
# End of macro NEXTW
3072			.COMC: 
3072				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
3072 6f				db WORD_SYS_CORE+91             
3073 7b 30			dw .SCRATCH            
3075 02				db 1 + 1 
3076 .. 00			db ")",0              
3078				endm 
# End of macro CWHEAD
3078			; | ) ( -- )  End of comment |  DONE  
3078				       NEXTW 
3078 c3 37 24			jp macro_next 
307b				endm 
# End of macro NEXTW
307b			 
307b			.SCRATCH: 
307b				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
307b 6f				db WORD_SYS_CORE+91             
307c b6 30			dw .INC            
307e 08				db 7 + 1 
307f .. 00			db "SCRATCH",0              
3087				endm 
# End of macro CWHEAD
3087			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3087			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3087			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3087			; | |  
3087			; | | e.g.    : score $00 scratch ; 
3087			; | |  
3087			; | | $00 score ! 
3087			; | | $01 score +! 
3087			; | |  
3087			; | | e.g.   : varword $0a scratch ;  
3087			; | | 
3087			; | | $8000 varword ! 
3087					if DEBUG_FORTH_WORDS_KEY 
3087						DMARK "SCR" 
3087 f5				push af  
3088 3a 9c 30			ld a, (.dmark)  
308b 32 a0 fd			ld (debug_mark),a  
308e 3a 9d 30			ld a, (.dmark+1)  
3091 32 a1 fd			ld (debug_mark+1),a  
3094 3a 9e 30			ld a, (.dmark+2)  
3097 32 a2 fd			ld (debug_mark+2),a  
309a 18 03			jr .pastdmark  
309c ..			.dmark: db "SCR"  
309f f1			.pastdmark: pop af  
30a0			endm  
# End of macro DMARK
30a0						CALLMONITOR 
30a0 cd aa fd			call debug_vector  
30a3				endm  
# End of macro CALLMONITOR
30a3					endif 
30a3			 
30a3					FORTH_DSP_VALUEHL 
30a3 cd 4b 22			call macro_dsp_valuehl 
30a6				endm 
# End of macro FORTH_DSP_VALUEHL
30a6				 
30a6					FORTH_DSP_POP 
30a6 cd 03 23			call macro_forth_dsp_pop 
30a9				endm 
# End of macro FORTH_DSP_POP
30a9			 
30a9 7d					ld a, l 
30aa 21 1b f6				ld hl, os_var_array 
30ad cd de 0f				call addatohl 
30b0			 
30b0 cd 46 20				call forth_push_numhl 
30b3			 
30b3				       NEXTW 
30b3 c3 37 24			jp macro_next 
30b6				endm 
# End of macro NEXTW
30b6			 
30b6			.INC: 
30b6				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
30b6 6f				db WORD_SYS_CORE+91             
30b7 0c 31			dw .DEC            
30b9 03				db 2 + 1 
30ba .. 00			db "+!",0              
30bd				endm 
# End of macro CWHEAD
30bd			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
30bd					if DEBUG_FORTH_WORDS_KEY 
30bd						DMARK "+s_" 
30bd f5				push af  
30be 3a d2 30			ld a, (.dmark)  
30c1 32 a0 fd			ld (debug_mark),a  
30c4 3a d3 30			ld a, (.dmark+1)  
30c7 32 a1 fd			ld (debug_mark+1),a  
30ca 3a d4 30			ld a, (.dmark+2)  
30cd 32 a2 fd			ld (debug_mark+2),a  
30d0 18 03			jr .pastdmark  
30d2 ..			.dmark: db "+s_"  
30d5 f1			.pastdmark: pop af  
30d6			endm  
# End of macro DMARK
30d6						CALLMONITOR 
30d6 cd aa fd			call debug_vector  
30d9				endm  
# End of macro CALLMONITOR
30d9					endif 
30d9			 
30d9					FORTH_DSP_VALUEHL 
30d9 cd 4b 22			call macro_dsp_valuehl 
30dc				endm 
# End of macro FORTH_DSP_VALUEHL
30dc			 
30dc e5					push hl   ; save address 
30dd			 
30dd					FORTH_DSP_POP 
30dd cd 03 23			call macro_forth_dsp_pop 
30e0				endm 
# End of macro FORTH_DSP_POP
30e0			 
30e0					FORTH_DSP_VALUEHL 
30e0 cd 4b 22			call macro_dsp_valuehl 
30e3				endm 
# End of macro FORTH_DSP_VALUEHL
30e3			 
30e3 e5					push hl 
30e4					FORTH_DSP_POP 
30e4 cd 03 23			call macro_forth_dsp_pop 
30e7				endm 
# End of macro FORTH_DSP_POP
30e7 e1					pop hl 
30e8			 
30e8					; hl contains value to add to byte at a 
30e8				 
30e8 eb					ex de, hl 
30e9			 
30e9 e1					pop hl 
30ea			 
30ea					if DEBUG_FORTH_WORDS 
30ea						DMARK "INC" 
30ea f5				push af  
30eb 3a ff 30			ld a, (.dmark)  
30ee 32 a0 fd			ld (debug_mark),a  
30f1 3a 00 31			ld a, (.dmark+1)  
30f4 32 a1 fd			ld (debug_mark+1),a  
30f7 3a 01 31			ld a, (.dmark+2)  
30fa 32 a2 fd			ld (debug_mark+2),a  
30fd 18 03			jr .pastdmark  
30ff ..			.dmark: db "INC"  
3102 f1			.pastdmark: pop af  
3103			endm  
# End of macro DMARK
3103						CALLMONITOR 
3103 cd aa fd			call debug_vector  
3106				endm  
# End of macro CALLMONITOR
3106					endif 
3106			 
3106 7e					ld a,(hl) 
3107 83					add e 
3108 77					ld (hl),a 
3109			 
3109			 
3109			 
3109				       NEXTW 
3109 c3 37 24			jp macro_next 
310c				endm 
# End of macro NEXTW
310c			 
310c			.DEC: 
310c				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
310c 6f				db WORD_SYS_CORE+91             
310d 60 31			dw .INC2            
310f 03				db 2 + 1 
3110 .. 00			db "-!",0              
3113				endm 
# End of macro CWHEAD
3113			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
3113					if DEBUG_FORTH_WORDS_KEY 
3113						DMARK "-s_" 
3113 f5				push af  
3114 3a 28 31			ld a, (.dmark)  
3117 32 a0 fd			ld (debug_mark),a  
311a 3a 29 31			ld a, (.dmark+1)  
311d 32 a1 fd			ld (debug_mark+1),a  
3120 3a 2a 31			ld a, (.dmark+2)  
3123 32 a2 fd			ld (debug_mark+2),a  
3126 18 03			jr .pastdmark  
3128 ..			.dmark: db "-s_"  
312b f1			.pastdmark: pop af  
312c			endm  
# End of macro DMARK
312c						CALLMONITOR 
312c cd aa fd			call debug_vector  
312f				endm  
# End of macro CALLMONITOR
312f					endif 
312f			 
312f					FORTH_DSP_VALUEHL 
312f cd 4b 22			call macro_dsp_valuehl 
3132				endm 
# End of macro FORTH_DSP_VALUEHL
3132			 
3132 e5					push hl   ; save address 
3133			 
3133					FORTH_DSP_POP 
3133 cd 03 23			call macro_forth_dsp_pop 
3136				endm 
# End of macro FORTH_DSP_POP
3136			 
3136					FORTH_DSP_VALUEHL 
3136 cd 4b 22			call macro_dsp_valuehl 
3139				endm 
# End of macro FORTH_DSP_VALUEHL
3139			 
3139					; hl contains value to add to byte at a 
3139				 
3139 eb					ex de, hl 
313a			 
313a e1					pop hl 
313b			 
313b					if DEBUG_FORTH_WORDS 
313b						DMARK "DEC" 
313b f5				push af  
313c 3a 50 31			ld a, (.dmark)  
313f 32 a0 fd			ld (debug_mark),a  
3142 3a 51 31			ld a, (.dmark+1)  
3145 32 a1 fd			ld (debug_mark+1),a  
3148 3a 52 31			ld a, (.dmark+2)  
314b 32 a2 fd			ld (debug_mark+2),a  
314e 18 03			jr .pastdmark  
3150 ..			.dmark: db "DEC"  
3153 f1			.pastdmark: pop af  
3154			endm  
# End of macro DMARK
3154						CALLMONITOR 
3154 cd aa fd			call debug_vector  
3157				endm  
# End of macro CALLMONITOR
3157					endif 
3157			 
3157 7e					ld a,(hl) 
3158 93					sub e 
3159 77					ld (hl),a 
315a			 
315a			 
315a					FORTH_DSP_POP 
315a cd 03 23			call macro_forth_dsp_pop 
315d				endm 
# End of macro FORTH_DSP_POP
315d			 
315d				       NEXTW 
315d c3 37 24			jp macro_next 
3160				endm 
# End of macro NEXTW
3160			 
3160			.INC2: 
3160				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
3160 6f				db WORD_SYS_CORE+91             
3161 0d 32			dw .DEC2            
3163 04				db 3 + 1 
3164 .. 00			db "+2!",0              
3168				endm 
# End of macro CWHEAD
3168			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3168			 
3168					if DEBUG_FORTH_WORDS_KEY 
3168						DMARK "+2s" 
3168 f5				push af  
3169 3a 7d 31			ld a, (.dmark)  
316c 32 a0 fd			ld (debug_mark),a  
316f 3a 7e 31			ld a, (.dmark+1)  
3172 32 a1 fd			ld (debug_mark+1),a  
3175 3a 7f 31			ld a, (.dmark+2)  
3178 32 a2 fd			ld (debug_mark+2),a  
317b 18 03			jr .pastdmark  
317d ..			.dmark: db "+2s"  
3180 f1			.pastdmark: pop af  
3181			endm  
# End of macro DMARK
3181						CALLMONITOR 
3181 cd aa fd			call debug_vector  
3184				endm  
# End of macro CALLMONITOR
3184					endif 
3184			 
3184					; Address 
3184			 
3184					FORTH_DSP_VALUEHL 
3184 cd 4b 22			call macro_dsp_valuehl 
3187				endm 
# End of macro FORTH_DSP_VALUEHL
3187			 
3187 e5					push hl    ; save address 
3188			 
3188					; load content into de 
3188			 
3188 5e					ld e,(hl) 
3189 23					inc hl 
318a 56					ld d, (hl) 
318b			 
318b					if DEBUG_FORTH_WORDS 
318b						DMARK "+2a" 
318b f5				push af  
318c 3a a0 31			ld a, (.dmark)  
318f 32 a0 fd			ld (debug_mark),a  
3192 3a a1 31			ld a, (.dmark+1)  
3195 32 a1 fd			ld (debug_mark+1),a  
3198 3a a2 31			ld a, (.dmark+2)  
319b 32 a2 fd			ld (debug_mark+2),a  
319e 18 03			jr .pastdmark  
31a0 ..			.dmark: db "+2a"  
31a3 f1			.pastdmark: pop af  
31a4			endm  
# End of macro DMARK
31a4						CALLMONITOR 
31a4 cd aa fd			call debug_vector  
31a7				endm  
# End of macro CALLMONITOR
31a7					endif 
31a7			 
31a7					FORTH_DSP_POP 
31a7 cd 03 23			call macro_forth_dsp_pop 
31aa				endm 
# End of macro FORTH_DSP_POP
31aa			 
31aa					; Get value to add 
31aa			 
31aa					FORTH_DSP_VALUE 
31aa cd 34 22			call macro_forth_dsp_value 
31ad				endm 
# End of macro FORTH_DSP_VALUE
31ad			 
31ad					if DEBUG_FORTH_WORDS 
31ad						DMARK "+2v" 
31ad f5				push af  
31ae 3a c2 31			ld a, (.dmark)  
31b1 32 a0 fd			ld (debug_mark),a  
31b4 3a c3 31			ld a, (.dmark+1)  
31b7 32 a1 fd			ld (debug_mark+1),a  
31ba 3a c4 31			ld a, (.dmark+2)  
31bd 32 a2 fd			ld (debug_mark+2),a  
31c0 18 03			jr .pastdmark  
31c2 ..			.dmark: db "+2v"  
31c5 f1			.pastdmark: pop af  
31c6			endm  
# End of macro DMARK
31c6						CALLMONITOR 
31c6 cd aa fd			call debug_vector  
31c9				endm  
# End of macro CALLMONITOR
31c9					endif 
31c9			 
31c9 19					add hl, de 
31ca			 
31ca					if DEBUG_FORTH_WORDS 
31ca						DMARK "+2+" 
31ca f5				push af  
31cb 3a df 31			ld a, (.dmark)  
31ce 32 a0 fd			ld (debug_mark),a  
31d1 3a e0 31			ld a, (.dmark+1)  
31d4 32 a1 fd			ld (debug_mark+1),a  
31d7 3a e1 31			ld a, (.dmark+2)  
31da 32 a2 fd			ld (debug_mark+2),a  
31dd 18 03			jr .pastdmark  
31df ..			.dmark: db "+2+"  
31e2 f1			.pastdmark: pop af  
31e3			endm  
# End of macro DMARK
31e3						CALLMONITOR 
31e3 cd aa fd			call debug_vector  
31e6				endm  
# End of macro CALLMONITOR
31e6					endif 
31e6			 
31e6					; move result to de 
31e6			 
31e6 eb					ex de, hl 
31e7			 
31e7					; Address 
31e7			 
31e7 e1					pop hl 
31e8			 
31e8					; save it back 
31e8			 
31e8 73					ld (hl), e 
31e9 23					inc hl 
31ea 72					ld (hl), d 
31eb			 
31eb					if DEBUG_FORTH_WORDS 
31eb						DMARK "+2e" 
31eb f5				push af  
31ec 3a 00 32			ld a, (.dmark)  
31ef 32 a0 fd			ld (debug_mark),a  
31f2 3a 01 32			ld a, (.dmark+1)  
31f5 32 a1 fd			ld (debug_mark+1),a  
31f8 3a 02 32			ld a, (.dmark+2)  
31fb 32 a2 fd			ld (debug_mark+2),a  
31fe 18 03			jr .pastdmark  
3200 ..			.dmark: db "+2e"  
3203 f1			.pastdmark: pop af  
3204			endm  
# End of macro DMARK
3204						CALLMONITOR 
3204 cd aa fd			call debug_vector  
3207				endm  
# End of macro CALLMONITOR
3207					endif 
3207			 
3207			 
3207			 
3207					FORTH_DSP_POP 
3207 cd 03 23			call macro_forth_dsp_pop 
320a				endm 
# End of macro FORTH_DSP_POP
320a			 
320a			 
320a				       NEXTW 
320a c3 37 24			jp macro_next 
320d				endm 
# End of macro NEXTW
320d			 
320d			.DEC2: 
320d				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
320d 6f				db WORD_SYS_CORE+91             
320e bc 32			dw .GET2            
3210 04				db 3 + 1 
3211 .. 00			db "-2!",0              
3215				endm 
# End of macro CWHEAD
3215			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3215			 
3215			 
3215					if DEBUG_FORTH_WORDS_KEY 
3215						DMARK "-2s" 
3215 f5				push af  
3216 3a 2a 32			ld a, (.dmark)  
3219 32 a0 fd			ld (debug_mark),a  
321c 3a 2b 32			ld a, (.dmark+1)  
321f 32 a1 fd			ld (debug_mark+1),a  
3222 3a 2c 32			ld a, (.dmark+2)  
3225 32 a2 fd			ld (debug_mark+2),a  
3228 18 03			jr .pastdmark  
322a ..			.dmark: db "-2s"  
322d f1			.pastdmark: pop af  
322e			endm  
# End of macro DMARK
322e						CALLMONITOR 
322e cd aa fd			call debug_vector  
3231				endm  
# End of macro CALLMONITOR
3231					endif 
3231			 
3231					; Address 
3231			 
3231					FORTH_DSP_VALUEHL 
3231 cd 4b 22			call macro_dsp_valuehl 
3234				endm 
# End of macro FORTH_DSP_VALUEHL
3234			 
3234 e5					push hl    ; save address 
3235			 
3235					; load content into de 
3235			 
3235 5e					ld e,(hl) 
3236 23					inc hl 
3237 56					ld d, (hl) 
3238			 
3238					if DEBUG_FORTH_WORDS 
3238						DMARK "-2a" 
3238 f5				push af  
3239 3a 4d 32			ld a, (.dmark)  
323c 32 a0 fd			ld (debug_mark),a  
323f 3a 4e 32			ld a, (.dmark+1)  
3242 32 a1 fd			ld (debug_mark+1),a  
3245 3a 4f 32			ld a, (.dmark+2)  
3248 32 a2 fd			ld (debug_mark+2),a  
324b 18 03			jr .pastdmark  
324d ..			.dmark: db "-2a"  
3250 f1			.pastdmark: pop af  
3251			endm  
# End of macro DMARK
3251						CALLMONITOR 
3251 cd aa fd			call debug_vector  
3254				endm  
# End of macro CALLMONITOR
3254					endif 
3254			 
3254					FORTH_DSP_POP 
3254 cd 03 23			call macro_forth_dsp_pop 
3257				endm 
# End of macro FORTH_DSP_POP
3257			 
3257					; Get value to remove 
3257			 
3257					FORTH_DSP_VALUE 
3257 cd 34 22			call macro_forth_dsp_value 
325a				endm 
# End of macro FORTH_DSP_VALUE
325a			 
325a					if DEBUG_FORTH_WORDS 
325a						DMARK "-2v" 
325a f5				push af  
325b 3a 6f 32			ld a, (.dmark)  
325e 32 a0 fd			ld (debug_mark),a  
3261 3a 70 32			ld a, (.dmark+1)  
3264 32 a1 fd			ld (debug_mark+1),a  
3267 3a 71 32			ld a, (.dmark+2)  
326a 32 a2 fd			ld (debug_mark+2),a  
326d 18 03			jr .pastdmark  
326f ..			.dmark: db "-2v"  
3272 f1			.pastdmark: pop af  
3273			endm  
# End of macro DMARK
3273						CALLMONITOR 
3273 cd aa fd			call debug_vector  
3276				endm  
# End of macro CALLMONITOR
3276					endif 
3276			 
3276 eb					ex de, hl 
3277 ed 52				sbc hl, de 
3279			 
3279					if DEBUG_FORTH_WORDS 
3279						DMARK "-2d" 
3279 f5				push af  
327a 3a 8e 32			ld a, (.dmark)  
327d 32 a0 fd			ld (debug_mark),a  
3280 3a 8f 32			ld a, (.dmark+1)  
3283 32 a1 fd			ld (debug_mark+1),a  
3286 3a 90 32			ld a, (.dmark+2)  
3289 32 a2 fd			ld (debug_mark+2),a  
328c 18 03			jr .pastdmark  
328e ..			.dmark: db "-2d"  
3291 f1			.pastdmark: pop af  
3292			endm  
# End of macro DMARK
3292						CALLMONITOR 
3292 cd aa fd			call debug_vector  
3295				endm  
# End of macro CALLMONITOR
3295					endif 
3295			 
3295					; move result to de 
3295			 
3295 eb					ex de, hl 
3296			 
3296					; Address 
3296			 
3296 e1					pop hl 
3297			 
3297					; save it back 
3297			 
3297 73					ld (hl), e 
3298 23					inc hl 
3299 72					ld (hl), d 
329a			 
329a					if DEBUG_FORTH_WORDS 
329a						DMARK "-2e" 
329a f5				push af  
329b 3a af 32			ld a, (.dmark)  
329e 32 a0 fd			ld (debug_mark),a  
32a1 3a b0 32			ld a, (.dmark+1)  
32a4 32 a1 fd			ld (debug_mark+1),a  
32a7 3a b1 32			ld a, (.dmark+2)  
32aa 32 a2 fd			ld (debug_mark+2),a  
32ad 18 03			jr .pastdmark  
32af ..			.dmark: db "-2e"  
32b2 f1			.pastdmark: pop af  
32b3			endm  
# End of macro DMARK
32b3						CALLMONITOR 
32b3 cd aa fd			call debug_vector  
32b6				endm  
# End of macro CALLMONITOR
32b6					endif 
32b6			 
32b6			 
32b6					FORTH_DSP_POP 
32b6 cd 03 23			call macro_forth_dsp_pop 
32b9				endm 
# End of macro FORTH_DSP_POP
32b9			 
32b9			 
32b9			 
32b9				       NEXTW 
32b9 c3 37 24			jp macro_next 
32bc				endm 
# End of macro NEXTW
32bc			.GET2: 
32bc				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
32bc 6f				db WORD_SYS_CORE+91             
32bd f1 32			dw .BANG2            
32bf 03				db 2 + 1 
32c0 .. 00			db "2@",0              
32c3				endm 
# End of macro CWHEAD
32c3			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
32c3					if DEBUG_FORTH_WORDS_KEY 
32c3						DMARK "2A_" 
32c3 f5				push af  
32c4 3a d8 32			ld a, (.dmark)  
32c7 32 a0 fd			ld (debug_mark),a  
32ca 3a d9 32			ld a, (.dmark+1)  
32cd 32 a1 fd			ld (debug_mark+1),a  
32d0 3a da 32			ld a, (.dmark+2)  
32d3 32 a2 fd			ld (debug_mark+2),a  
32d6 18 03			jr .pastdmark  
32d8 ..			.dmark: db "2A_"  
32db f1			.pastdmark: pop af  
32dc			endm  
# End of macro DMARK
32dc						CALLMONITOR 
32dc cd aa fd			call debug_vector  
32df				endm  
# End of macro CALLMONITOR
32df					endif 
32df			 
32df					FORTH_DSP_VALUEHL 
32df cd 4b 22			call macro_dsp_valuehl 
32e2				endm 
# End of macro FORTH_DSP_VALUEHL
32e2			 
32e2 e5					push hl   ; save address 
32e3			 
32e3					FORTH_DSP_POP 
32e3 cd 03 23			call macro_forth_dsp_pop 
32e6				endm 
# End of macro FORTH_DSP_POP
32e6			 
32e6 e1					pop hl 
32e7			 
32e7 5e					ld e, (hl) 
32e8 23					inc hl 
32e9 56					ld d, (hl) 
32ea			 
32ea eb					ex de, hl 
32eb			 
32eb cd 46 20				call forth_push_numhl 
32ee			 
32ee				       NEXTW 
32ee c3 37 24			jp macro_next 
32f1				endm 
# End of macro NEXTW
32f1			.BANG2: 
32f1				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
32f1 6f				db WORD_SYS_CORE+91             
32f2 29 33			dw .CONFIG            
32f4 03				db 2 + 1 
32f5 .. 00			db "2!",0              
32f8				endm 
# End of macro CWHEAD
32f8			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
32f8					if DEBUG_FORTH_WORDS_KEY 
32f8						DMARK "2S_" 
32f8 f5				push af  
32f9 3a 0d 33			ld a, (.dmark)  
32fc 32 a0 fd			ld (debug_mark),a  
32ff 3a 0e 33			ld a, (.dmark+1)  
3302 32 a1 fd			ld (debug_mark+1),a  
3305 3a 0f 33			ld a, (.dmark+2)  
3308 32 a2 fd			ld (debug_mark+2),a  
330b 18 03			jr .pastdmark  
330d ..			.dmark: db "2S_"  
3310 f1			.pastdmark: pop af  
3311			endm  
# End of macro DMARK
3311						CALLMONITOR 
3311 cd aa fd			call debug_vector  
3314				endm  
# End of macro CALLMONITOR
3314					endif 
3314			 
3314					FORTH_DSP_VALUEHL 
3314 cd 4b 22			call macro_dsp_valuehl 
3317				endm 
# End of macro FORTH_DSP_VALUEHL
3317			 
3317 e5					push hl   ; save address 
3318			 
3318			 
3318					FORTH_DSP_POP 
3318 cd 03 23			call macro_forth_dsp_pop 
331b				endm 
# End of macro FORTH_DSP_POP
331b			 
331b					 
331b					FORTH_DSP_VALUEHL 
331b cd 4b 22			call macro_dsp_valuehl 
331e				endm 
# End of macro FORTH_DSP_VALUEHL
331e			 
331e					FORTH_DSP_POP 
331e cd 03 23			call macro_forth_dsp_pop 
3321				endm 
# End of macro FORTH_DSP_POP
3321			 
3321 eb					ex de, hl    ; value now in de 
3322			 
3322 e1					pop hl 
3323			 
3323 73					ld (hl), e 
3324			 
3324 23					inc hl 
3325			 
3325 72					ld (hl), d 
3326			 
3326			 
3326				       NEXTW 
3326 c3 37 24			jp macro_next 
3329				endm 
# End of macro NEXTW
3329			.CONFIG: 
3329				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3329 6f				db WORD_SYS_CORE+91             
332a 3a 33			dw .ADTOS            
332c 07				db 6 + 1 
332d .. 00			db "CONFIG",0              
3334				endm 
# End of macro CWHEAD
3334			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3334			 
3334 cd 52 15				call config 
3337					NEXTW 
3337 c3 37 24			jp macro_next 
333a				endm 
# End of macro NEXTW
333a			 
333a			.ADTOS: 
333a				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
333a 6f				db WORD_SYS_CORE+91             
333b 50 33			dw .SBTOS            
333d 03				db 2 + 1 
333e .. 00			db "1+",0              
3341				endm 
# End of macro CWHEAD
3341			; | 1+ ( u -- u )  Increment value on TOS | DONE 
3341			 
3341					FORTH_DSP_VALUEHL 
3341 cd 4b 22			call macro_dsp_valuehl 
3344				endm 
# End of macro FORTH_DSP_VALUEHL
3344 e5					push hl 
3345			 
3345					FORTH_DSP_POP 
3345 cd 03 23			call macro_forth_dsp_pop 
3348				endm 
# End of macro FORTH_DSP_POP
3348 e1					pop hl 
3349			 
3349 23					inc hl 
334a cd 46 20				call forth_push_numhl 
334d					 
334d					NEXTW 
334d c3 37 24			jp macro_next 
3350				endm 
# End of macro NEXTW
3350			.SBTOS: 
3350				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
3350 6f				db WORD_SYS_CORE+91             
3351 66 33			dw .ADSTORE            
3353 03				db 2 + 1 
3354 .. 00			db "1-",0              
3357				endm 
# End of macro CWHEAD
3357			; | 1- ( u -- u )  Decrement value on TOS | DONE 
3357			 
3357					FORTH_DSP_VALUEHL 
3357 cd 4b 22			call macro_dsp_valuehl 
335a				endm 
# End of macro FORTH_DSP_VALUEHL
335a e5					push hl 
335b			 
335b					FORTH_DSP_POP 
335b cd 03 23			call macro_forth_dsp_pop 
335e				endm 
# End of macro FORTH_DSP_POP
335e e1					pop hl 
335f			 
335f 2b					dec hl 
3360 cd 46 20				call forth_push_numhl 
3363					 
3363					NEXTW 
3363 c3 37 24			jp macro_next 
3366				endm 
# End of macro NEXTW
3366			.ADSTORE: 
3366				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3366 6f				db WORD_SYS_CORE+91             
3367 7c 33			dw .ADWSTORE            
3369 04				db 3 + 1 
336a .. 00			db "1+!",0              
336e				endm 
# End of macro CWHEAD
336e			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
336e			 
336e					FORTH_DSP_VALUEHL 
336e cd 4b 22			call macro_dsp_valuehl 
3371				endm 
# End of macro FORTH_DSP_VALUEHL
3371 e5					push hl 
3372			 
3372					FORTH_DSP_POP 
3372 cd 03 23			call macro_forth_dsp_pop 
3375				endm 
# End of macro FORTH_DSP_POP
3375 e1					pop hl 
3376			 
3376 7e					ld a, (hl) 
3377 3c					inc a 
3378 77					ld (hl), a 
3379					 
3379					NEXTW 
3379 c3 37 24			jp macro_next 
337c				endm 
# End of macro NEXTW
337c			.ADWSTORE: 
337c				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
337c 6f				db WORD_SYS_CORE+91             
337d 9a 33			dw .SBSTORE            
337f 05				db 4 + 1 
3380 .. 00			db "1+2!",0              
3385				endm 
# End of macro CWHEAD
3385			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3385			 
3385					FORTH_DSP_VALUEHL 
3385 cd 4b 22			call macro_dsp_valuehl 
3388				endm 
# End of macro FORTH_DSP_VALUEHL
3388 e5					push hl 
3389			 
3389					FORTH_DSP_POP 
3389 cd 03 23			call macro_forth_dsp_pop 
338c				endm 
# End of macro FORTH_DSP_POP
338c e1					pop hl 
338d			 
338d e5					push hl 
338e			 
338e cd b9 23				call loadwordinhl 
3391 23					inc hl 
3392			 
3392 d1					pop de 
3393 eb					ex de, hl 
3394 73					ld (hl), e 
3395 23					inc hl 
3396 72					ld (hl), d 
3397					 
3397					NEXTW 
3397 c3 37 24			jp macro_next 
339a				endm 
# End of macro NEXTW
339a			.SBSTORE: 
339a				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
339a 6f				db WORD_SYS_CORE+91             
339b b0 33			dw .SBWSTORE            
339d 04				db 3 + 1 
339e .. 00			db "1-!",0              
33a2				endm 
# End of macro CWHEAD
33a2			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
33a2			 
33a2					FORTH_DSP_VALUEHL 
33a2 cd 4b 22			call macro_dsp_valuehl 
33a5				endm 
# End of macro FORTH_DSP_VALUEHL
33a5 e5					push hl 
33a6			 
33a6					FORTH_DSP_POP 
33a6 cd 03 23			call macro_forth_dsp_pop 
33a9				endm 
# End of macro FORTH_DSP_POP
33a9 e1					pop hl 
33aa			 
33aa 7e					ld a, (hl) 
33ab 3d					dec a 
33ac 77					ld (hl), a 
33ad					 
33ad					NEXTW 
33ad c3 37 24			jp macro_next 
33b0				endm 
# End of macro NEXTW
33b0			.SBWSTORE: 
33b0				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
33b0 6f				db WORD_SYS_CORE+91             
33b1 ce 33			dw .ENDCORE            
33b3 05				db 4 + 1 
33b4 .. 00			db "1-2!",0              
33b9				endm 
# End of macro CWHEAD
33b9			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
33b9			 
33b9					FORTH_DSP_VALUEHL 
33b9 cd 4b 22			call macro_dsp_valuehl 
33bc				endm 
# End of macro FORTH_DSP_VALUEHL
33bc e5					push hl 
33bd			 
33bd					FORTH_DSP_POP 
33bd cd 03 23			call macro_forth_dsp_pop 
33c0				endm 
# End of macro FORTH_DSP_POP
33c0 e1					pop hl 
33c1			 
33c1 e5					push hl 
33c2			 
33c2 cd b9 23				call loadwordinhl 
33c5 2b					dec hl 
33c6			 
33c6 d1					pop de 
33c7 eb					ex de, hl 
33c8 73					ld (hl), e 
33c9 23					inc hl 
33ca 72					ld (hl), d 
33cb					 
33cb					NEXTW 
33cb c3 37 24			jp macro_next 
33ce				endm 
# End of macro NEXTW
33ce			.ENDCORE: 
33ce			 
33ce			; eof 
33ce			 
33ce			 
# End of file forth_words_core.asm
33ce			include "forth_words_flow.asm" 
33ce			 
33ce			; | ## Program Flow Words 
33ce			 
33ce			.IF: 
33ce				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
33ce 1e				db WORD_SYS_CORE+10             
33cf c3 34			dw .THEN            
33d1 03				db 2 + 1 
33d2 .. 00			db "IF",0              
33d5				endm 
# End of macro CWHEAD
33d5			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
33d5			; 
33d5					if DEBUG_FORTH_WORDS_KEY 
33d5						DMARK "IF." 
33d5 f5				push af  
33d6 3a ea 33			ld a, (.dmark)  
33d9 32 a0 fd			ld (debug_mark),a  
33dc 3a eb 33			ld a, (.dmark+1)  
33df 32 a1 fd			ld (debug_mark+1),a  
33e2 3a ec 33			ld a, (.dmark+2)  
33e5 32 a2 fd			ld (debug_mark+2),a  
33e8 18 03			jr .pastdmark  
33ea ..			.dmark: db "IF."  
33ed f1			.pastdmark: pop af  
33ee			endm  
# End of macro DMARK
33ee						CALLMONITOR 
33ee cd aa fd			call debug_vector  
33f1				endm  
# End of macro CALLMONITOR
33f1					endif 
33f1			; eval TOS 
33f1			 
33f1				FORTH_DSP_VALUEHL 
33f1 cd 4b 22			call macro_dsp_valuehl 
33f4				endm 
# End of macro FORTH_DSP_VALUEHL
33f4			 
33f4			;	push hl 
33f4				FORTH_DSP_POP 
33f4 cd 03 23			call macro_forth_dsp_pop 
33f7				endm 
# End of macro FORTH_DSP_POP
33f7			;	pop hl 
33f7			 
33f7					if DEBUG_FORTH_WORDS 
33f7						DMARK "IF1" 
33f7 f5				push af  
33f8 3a 0c 34			ld a, (.dmark)  
33fb 32 a0 fd			ld (debug_mark),a  
33fe 3a 0d 34			ld a, (.dmark+1)  
3401 32 a1 fd			ld (debug_mark+1),a  
3404 3a 0e 34			ld a, (.dmark+2)  
3407 32 a2 fd			ld (debug_mark+2),a  
340a 18 03			jr .pastdmark  
340c ..			.dmark: db "IF1"  
340f f1			.pastdmark: pop af  
3410			endm  
# End of macro DMARK
3410						CALLMONITOR 
3410 cd aa fd			call debug_vector  
3413				endm  
# End of macro CALLMONITOR
3413					endif 
3413 b7				or a        ; clear carry flag 
3414 11 00 00			ld de, 0 
3417 eb				ex de,hl 
3418 ed 52			sbc hl, de 
341a c2 a4 34			jp nz, .iftrue 
341d			 
341d					if DEBUG_FORTH_WORDS 
341d						DMARK "IF2" 
341d f5				push af  
341e 3a 32 34			ld a, (.dmark)  
3421 32 a0 fd			ld (debug_mark),a  
3424 3a 33 34			ld a, (.dmark+1)  
3427 32 a1 fd			ld (debug_mark+1),a  
342a 3a 34 34			ld a, (.dmark+2)  
342d 32 a2 fd			ld (debug_mark+2),a  
3430 18 03			jr .pastdmark  
3432 ..			.dmark: db "IF2"  
3435 f1			.pastdmark: pop af  
3436			endm  
# End of macro DMARK
3436						CALLMONITOR 
3436 cd aa fd			call debug_vector  
3439				endm  
# End of macro CALLMONITOR
3439					endif 
3439			 
3439			; if not true then skip to THEN 
3439			 
3439				; TODO get tok_ptr 
3439				; TODO consume toks until we get to THEN 
3439			 
3439 2a f7 f3			ld hl, (os_tok_ptr) 
343c					if DEBUG_FORTH_WORDS 
343c						DMARK "IF3" 
343c f5				push af  
343d 3a 51 34			ld a, (.dmark)  
3440 32 a0 fd			ld (debug_mark),a  
3443 3a 52 34			ld a, (.dmark+1)  
3446 32 a1 fd			ld (debug_mark+1),a  
3449 3a 53 34			ld a, (.dmark+2)  
344c 32 a2 fd			ld (debug_mark+2),a  
344f 18 03			jr .pastdmark  
3451 ..			.dmark: db "IF3"  
3454 f1			.pastdmark: pop af  
3455			endm  
# End of macro DMARK
3455						CALLMONITOR 
3455 cd aa fd			call debug_vector  
3458				endm  
# End of macro CALLMONITOR
3458						 
3458					endif 
3458 11 9f 34			ld de, .ifthen 
345b					if DEBUG_FORTH_WORDS 
345b						DMARK "IF4" 
345b f5				push af  
345c 3a 70 34			ld a, (.dmark)  
345f 32 a0 fd			ld (debug_mark),a  
3462 3a 71 34			ld a, (.dmark+1)  
3465 32 a1 fd			ld (debug_mark+1),a  
3468 3a 72 34			ld a, (.dmark+2)  
346b 32 a2 fd			ld (debug_mark+2),a  
346e 18 03			jr .pastdmark  
3470 ..			.dmark: db "IF4"  
3473 f1			.pastdmark: pop af  
3474			endm  
# End of macro DMARK
3474						CALLMONITOR 
3474 cd aa fd			call debug_vector  
3477				endm  
# End of macro CALLMONITOR
3477					endif 
3477 cd 52 25			call findnexttok  
347a			 
347a					if DEBUG_FORTH_WORDS 
347a						DMARK "IF5" 
347a f5				push af  
347b 3a 8f 34			ld a, (.dmark)  
347e 32 a0 fd			ld (debug_mark),a  
3481 3a 90 34			ld a, (.dmark+1)  
3484 32 a1 fd			ld (debug_mark+1),a  
3487 3a 91 34			ld a, (.dmark+2)  
348a 32 a2 fd			ld (debug_mark+2),a  
348d 18 03			jr .pastdmark  
348f ..			.dmark: db "IF5"  
3492 f1			.pastdmark: pop af  
3493			endm  
# End of macro DMARK
3493						CALLMONITOR 
3493 cd aa fd			call debug_vector  
3496				endm  
# End of macro CALLMONITOR
3496					endif 
3496				; TODO replace below with ; exec using tok_ptr 
3496 22 f7 f3			ld (os_tok_ptr), hl 
3499 c3 c8 24			jp exec1 
349c				NEXTW 
349c c3 37 24			jp macro_next 
349f				endm 
# End of macro NEXTW
349f			 
349f .. 00		.ifthen:  db "THEN",0 
34a4			 
34a4			.iftrue:		 
34a4				; Exec next words normally 
34a4			 
34a4				; if true then exec following IF as normal 
34a4					if DEBUG_FORTH_WORDS 
34a4						DMARK "IFT" 
34a4 f5				push af  
34a5 3a b9 34			ld a, (.dmark)  
34a8 32 a0 fd			ld (debug_mark),a  
34ab 3a ba 34			ld a, (.dmark+1)  
34ae 32 a1 fd			ld (debug_mark+1),a  
34b1 3a bb 34			ld a, (.dmark+2)  
34b4 32 a2 fd			ld (debug_mark+2),a  
34b7 18 03			jr .pastdmark  
34b9 ..			.dmark: db "IFT"  
34bc f1			.pastdmark: pop af  
34bd			endm  
# End of macro DMARK
34bd						CALLMONITOR 
34bd cd aa fd			call debug_vector  
34c0				endm  
# End of macro CALLMONITOR
34c0					endif 
34c0			 
34c0					NEXTW 
34c0 c3 37 24			jp macro_next 
34c3				endm 
# End of macro NEXTW
34c3			.THEN: 
34c3				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
34c3 1f				db WORD_SYS_CORE+11             
34c4 eb 34			dw .ELSE            
34c6 05				db 4 + 1 
34c7 .. 00			db "THEN",0              
34cc				endm 
# End of macro CWHEAD
34cc			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
34cc					if DEBUG_FORTH_WORDS_KEY 
34cc						DMARK "THN" 
34cc f5				push af  
34cd 3a e1 34			ld a, (.dmark)  
34d0 32 a0 fd			ld (debug_mark),a  
34d3 3a e2 34			ld a, (.dmark+1)  
34d6 32 a1 fd			ld (debug_mark+1),a  
34d9 3a e3 34			ld a, (.dmark+2)  
34dc 32 a2 fd			ld (debug_mark+2),a  
34df 18 03			jr .pastdmark  
34e1 ..			.dmark: db "THN"  
34e4 f1			.pastdmark: pop af  
34e5			endm  
# End of macro DMARK
34e5						CALLMONITOR 
34e5 cd aa fd			call debug_vector  
34e8				endm  
# End of macro CALLMONITOR
34e8					endif 
34e8					NEXTW 
34e8 c3 37 24			jp macro_next 
34eb				endm 
# End of macro NEXTW
34eb			.ELSE: 
34eb				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
34eb 20				db WORD_SYS_CORE+12             
34ec 13 35			dw .DO            
34ee 03				db 2 + 1 
34ef .. 00			db "ELSE",0              
34f4				endm 
# End of macro CWHEAD
34f4			; | ELSE ( -- ) Not supported - does nothing | TODO 
34f4			 
34f4					if DEBUG_FORTH_WORDS_KEY 
34f4						DMARK "ELS" 
34f4 f5				push af  
34f5 3a 09 35			ld a, (.dmark)  
34f8 32 a0 fd			ld (debug_mark),a  
34fb 3a 0a 35			ld a, (.dmark+1)  
34fe 32 a1 fd			ld (debug_mark+1),a  
3501 3a 0b 35			ld a, (.dmark+2)  
3504 32 a2 fd			ld (debug_mark+2),a  
3507 18 03			jr .pastdmark  
3509 ..			.dmark: db "ELS"  
350c f1			.pastdmark: pop af  
350d			endm  
# End of macro DMARK
350d						CALLMONITOR 
350d cd aa fd			call debug_vector  
3510				endm  
# End of macro CALLMONITOR
3510					endif 
3510			 
3510			 
3510					NEXTW 
3510 c3 37 24			jp macro_next 
3513				endm 
# End of macro NEXTW
3513			.DO: 
3513				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3513 21				db WORD_SYS_CORE+13             
3514 3a 36			dw .LOOP            
3516 03				db 2 + 1 
3517 .. 00			db "DO",0              
351a				endm 
# End of macro CWHEAD
351a			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
351a			 
351a					if DEBUG_FORTH_WORDS_KEY 
351a						DMARK "DO." 
351a f5				push af  
351b 3a 2f 35			ld a, (.dmark)  
351e 32 a0 fd			ld (debug_mark),a  
3521 3a 30 35			ld a, (.dmark+1)  
3524 32 a1 fd			ld (debug_mark+1),a  
3527 3a 31 35			ld a, (.dmark+2)  
352a 32 a2 fd			ld (debug_mark+2),a  
352d 18 03			jr .pastdmark  
352f ..			.dmark: db "DO."  
3532 f1			.pastdmark: pop af  
3533			endm  
# End of macro DMARK
3533						CALLMONITOR 
3533 cd aa fd			call debug_vector  
3536				endm  
# End of macro CALLMONITOR
3536					endif 
3536			;  push pc to rsp stack past the DO 
3536			 
3536 2a f7 f3				ld hl, (os_tok_ptr) 
3539 23					inc hl   ; D 
353a 23					inc hl  ; O 
353b 23					inc hl   ; null 
353c					if DEBUG_FORTH_WORDS 
353c						DMARK "DO2" 
353c f5				push af  
353d 3a 51 35			ld a, (.dmark)  
3540 32 a0 fd			ld (debug_mark),a  
3543 3a 52 35			ld a, (.dmark+1)  
3546 32 a1 fd			ld (debug_mark+1),a  
3549 3a 53 35			ld a, (.dmark+2)  
354c 32 a2 fd			ld (debug_mark+2),a  
354f 18 03			jr .pastdmark  
3551 ..			.dmark: db "DO2"  
3554 f1			.pastdmark: pop af  
3555			endm  
# End of macro DMARK
3555						CALLMONITOR 
3555 cd aa fd			call debug_vector  
3558				endm  
# End of macro CALLMONITOR
3558					endif 
3558					FORTH_RSP_NEXT 
3558 cd ed 1f			call macro_forth_rsp_next 
355b				endm 
# End of macro FORTH_RSP_NEXT
355b					if DEBUG_FORTH_WORDS 
355b						DMARK "DO3" 
355b f5				push af  
355c 3a 70 35			ld a, (.dmark)  
355f 32 a0 fd			ld (debug_mark),a  
3562 3a 71 35			ld a, (.dmark+1)  
3565 32 a1 fd			ld (debug_mark+1),a  
3568 3a 72 35			ld a, (.dmark+2)  
356b 32 a2 fd			ld (debug_mark+2),a  
356e 18 03			jr .pastdmark  
3570 ..			.dmark: db "DO3"  
3573 f1			.pastdmark: pop af  
3574			endm  
# End of macro DMARK
3574						CALLMONITOR 
3574 cd aa fd			call debug_vector  
3577				endm  
# End of macro CALLMONITOR
3577					endif 
3577			 
3577					;if DEBUG_FORTH_WORDS 
3577				;		push hl 
3577			;		endif  
3577			 
3577			; get counters from data stack 
3577			 
3577			 
3577					FORTH_DSP_VALUEHL 
3577 cd 4b 22			call macro_dsp_valuehl 
357a				endm 
# End of macro FORTH_DSP_VALUEHL
357a e5					push hl		 ; hl now has starting counter which needs to be tos 
357b			 
357b					if DEBUG_FORTH_WORDS 
357b						DMARK "DO4" 
357b f5				push af  
357c 3a 90 35			ld a, (.dmark)  
357f 32 a0 fd			ld (debug_mark),a  
3582 3a 91 35			ld a, (.dmark+1)  
3585 32 a1 fd			ld (debug_mark+1),a  
3588 3a 92 35			ld a, (.dmark+2)  
358b 32 a2 fd			ld (debug_mark+2),a  
358e 18 03			jr .pastdmark  
3590 ..			.dmark: db "DO4"  
3593 f1			.pastdmark: pop af  
3594			endm  
# End of macro DMARK
3594						CALLMONITOR 
3594 cd aa fd			call debug_vector  
3597				endm  
# End of macro CALLMONITOR
3597					endif 
3597					FORTH_DSP_POP 
3597 cd 03 23			call macro_forth_dsp_pop 
359a				endm 
# End of macro FORTH_DSP_POP
359a			 
359a					if DEBUG_FORTH_WORDS 
359a						DMARK "DO5" 
359a f5				push af  
359b 3a af 35			ld a, (.dmark)  
359e 32 a0 fd			ld (debug_mark),a  
35a1 3a b0 35			ld a, (.dmark+1)  
35a4 32 a1 fd			ld (debug_mark+1),a  
35a7 3a b1 35			ld a, (.dmark+2)  
35aa 32 a2 fd			ld (debug_mark+2),a  
35ad 18 03			jr .pastdmark  
35af ..			.dmark: db "DO5"  
35b2 f1			.pastdmark: pop af  
35b3			endm  
# End of macro DMARK
35b3						CALLMONITOR 
35b3 cd aa fd			call debug_vector  
35b6				endm  
# End of macro CALLMONITOR
35b6					endif 
35b6			 
35b6					FORTH_DSP_VALUEHL 
35b6 cd 4b 22			call macro_dsp_valuehl 
35b9				endm 
# End of macro FORTH_DSP_VALUEHL
35b9			;		push hl		 ; hl now has starting limit counter 
35b9			 
35b9					if DEBUG_FORTH_WORDS 
35b9						DMARK "DO6" 
35b9 f5				push af  
35ba 3a ce 35			ld a, (.dmark)  
35bd 32 a0 fd			ld (debug_mark),a  
35c0 3a cf 35			ld a, (.dmark+1)  
35c3 32 a1 fd			ld (debug_mark+1),a  
35c6 3a d0 35			ld a, (.dmark+2)  
35c9 32 a2 fd			ld (debug_mark+2),a  
35cc 18 03			jr .pastdmark  
35ce ..			.dmark: db "DO6"  
35d1 f1			.pastdmark: pop af  
35d2			endm  
# End of macro DMARK
35d2						CALLMONITOR 
35d2 cd aa fd			call debug_vector  
35d5				endm  
# End of macro CALLMONITOR
35d5					endif 
35d5					FORTH_DSP_POP 
35d5 cd 03 23			call macro_forth_dsp_pop 
35d8				endm 
# End of macro FORTH_DSP_POP
35d8			 
35d8			; put counters on the loop stack 
35d8			 
35d8			;		pop hl			 ; limit counter 
35d8 d1					pop de			; start counter 
35d9			 
35d9					; push limit counter 
35d9			 
35d9					if DEBUG_FORTH_WORDS 
35d9						DMARK "DO7" 
35d9 f5				push af  
35da 3a ee 35			ld a, (.dmark)  
35dd 32 a0 fd			ld (debug_mark),a  
35e0 3a ef 35			ld a, (.dmark+1)  
35e3 32 a1 fd			ld (debug_mark+1),a  
35e6 3a f0 35			ld a, (.dmark+2)  
35e9 32 a2 fd			ld (debug_mark+2),a  
35ec 18 03			jr .pastdmark  
35ee ..			.dmark: db "DO7"  
35f1 f1			.pastdmark: pop af  
35f2			endm  
# End of macro DMARK
35f2						CALLMONITOR 
35f2 cd aa fd			call debug_vector  
35f5				endm  
# End of macro CALLMONITOR
35f5					endif 
35f5					FORTH_LOOP_NEXT 
35f5 cd 7c 22			call macro_forth_loop_next 
35f8				endm 
# End of macro FORTH_LOOP_NEXT
35f8			 
35f8					; push start counter 
35f8			 
35f8 eb					ex de, hl 
35f9					if DEBUG_FORTH_WORDS 
35f9						DMARK "DO7" 
35f9 f5				push af  
35fa 3a 0e 36			ld a, (.dmark)  
35fd 32 a0 fd			ld (debug_mark),a  
3600 3a 0f 36			ld a, (.dmark+1)  
3603 32 a1 fd			ld (debug_mark+1),a  
3606 3a 10 36			ld a, (.dmark+2)  
3609 32 a2 fd			ld (debug_mark+2),a  
360c 18 03			jr .pastdmark  
360e ..			.dmark: db "DO7"  
3611 f1			.pastdmark: pop af  
3612			endm  
# End of macro DMARK
3612						CALLMONITOR 
3612 cd aa fd			call debug_vector  
3615				endm  
# End of macro CALLMONITOR
3615					endif 
3615					FORTH_LOOP_NEXT 
3615 cd 7c 22			call macro_forth_loop_next 
3618				endm 
# End of macro FORTH_LOOP_NEXT
3618			 
3618			 
3618					; init first round of I counter 
3618			 
3618 22 1b f4				ld (os_current_i), hl 
361b			 
361b					if DEBUG_FORTH_WORDS 
361b						DMARK "DO8" 
361b f5				push af  
361c 3a 30 36			ld a, (.dmark)  
361f 32 a0 fd			ld (debug_mark),a  
3622 3a 31 36			ld a, (.dmark+1)  
3625 32 a1 fd			ld (debug_mark+1),a  
3628 3a 32 36			ld a, (.dmark+2)  
362b 32 a2 fd			ld (debug_mark+2),a  
362e 18 03			jr .pastdmark  
3630 ..			.dmark: db "DO8"  
3633 f1			.pastdmark: pop af  
3634			endm  
# End of macro DMARK
3634						CALLMONITOR 
3634 cd aa fd			call debug_vector  
3637				endm  
# End of macro CALLMONITOR
3637					endif 
3637			 
3637					NEXTW 
3637 c3 37 24			jp macro_next 
363a				endm 
# End of macro NEXTW
363a			.LOOP: 
363a				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
363a 22				db WORD_SYS_CORE+14             
363b 52 37			dw .I            
363d 05				db 4 + 1 
363e .. 00			db "LOOP",0              
3643				endm 
# End of macro CWHEAD
3643			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3643			 
3643				; pop tos as current loop count to hl 
3643			 
3643				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3643			 
3643				FORTH_LOOP_TOS 
3643 cd af 22			call macro_forth_loop_tos 
3646				endm 
# End of macro FORTH_LOOP_TOS
3646 e5				push hl 
3647			 
3647					if DEBUG_FORTH_WORDS_KEY 
3647						DMARK "LOP" 
3647 f5				push af  
3648 3a 5c 36			ld a, (.dmark)  
364b 32 a0 fd			ld (debug_mark),a  
364e 3a 5d 36			ld a, (.dmark+1)  
3651 32 a1 fd			ld (debug_mark+1),a  
3654 3a 5e 36			ld a, (.dmark+2)  
3657 32 a2 fd			ld (debug_mark+2),a  
365a 18 03			jr .pastdmark  
365c ..			.dmark: db "LOP"  
365f f1			.pastdmark: pop af  
3660			endm  
# End of macro DMARK
3660						CALLMONITOR 
3660 cd aa fd			call debug_vector  
3663				endm  
# End of macro CALLMONITOR
3663					endif 
3663				; next item on the stack is the limit. get it 
3663			 
3663			 
3663				FORTH_LOOP_POP 
3663 cd b9 22			call macro_forth_loop_pop 
3666				endm 
# End of macro FORTH_LOOP_POP
3666			 
3666				FORTH_LOOP_TOS 
3666 cd af 22			call macro_forth_loop_tos 
3669				endm 
# End of macro FORTH_LOOP_TOS
3669			 
3669 d1				pop de		 ; de = i, hl = limit 
366a			 
366a					if DEBUG_FORTH_WORDS 
366a						DMARK "LP1" 
366a f5				push af  
366b 3a 7f 36			ld a, (.dmark)  
366e 32 a0 fd			ld (debug_mark),a  
3671 3a 80 36			ld a, (.dmark+1)  
3674 32 a1 fd			ld (debug_mark+1),a  
3677 3a 81 36			ld a, (.dmark+2)  
367a 32 a2 fd			ld (debug_mark+2),a  
367d 18 03			jr .pastdmark  
367f ..			.dmark: db "LP1"  
3682 f1			.pastdmark: pop af  
3683			endm  
# End of macro DMARK
3683						CALLMONITOR 
3683 cd aa fd			call debug_vector  
3686				endm  
# End of macro CALLMONITOR
3686					endif 
3686			 
3686				; go back to previous word 
3686			 
3686 d5				push de    ; save I for inc later 
3687			 
3687			 
3687				; get limit 
3687				;  is I at limit? 
3687			 
3687			 
3687					if DEBUG_FORTH_WORDS 
3687						DMARK "LP1" 
3687 f5				push af  
3688 3a 9c 36			ld a, (.dmark)  
368b 32 a0 fd			ld (debug_mark),a  
368e 3a 9d 36			ld a, (.dmark+1)  
3691 32 a1 fd			ld (debug_mark+1),a  
3694 3a 9e 36			ld a, (.dmark+2)  
3697 32 a2 fd			ld (debug_mark+2),a  
369a 18 03			jr .pastdmark  
369c ..			.dmark: db "LP1"  
369f f1			.pastdmark: pop af  
36a0			endm  
# End of macro DMARK
36a0						CALLMONITOR 
36a0 cd aa fd			call debug_vector  
36a3				endm  
# End of macro CALLMONITOR
36a3					endif 
36a3			 
36a3 ed 52			sbc hl, de 
36a5			 
36a5			 
36a5				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
36a5			 
36a5 20 26				jr nz, .loopnotdone 
36a7			 
36a7 e1				pop hl   ; get rid of saved I 
36a8				FORTH_LOOP_POP     ; get rid of limit 
36a8 cd b9 22			call macro_forth_loop_pop 
36ab				endm 
# End of macro FORTH_LOOP_POP
36ab			 
36ab				FORTH_RSP_POP     ; get rid of DO ptr 
36ab cd 0e 20			call macro_forth_rsp_pop 
36ae				endm 
# End of macro FORTH_RSP_POP
36ae			 
36ae			if DEBUG_FORTH_WORDS 
36ae						DMARK "LP>" 
36ae f5				push af  
36af 3a c3 36			ld a, (.dmark)  
36b2 32 a0 fd			ld (debug_mark),a  
36b5 3a c4 36			ld a, (.dmark+1)  
36b8 32 a1 fd			ld (debug_mark+1),a  
36bb 3a c5 36			ld a, (.dmark+2)  
36be 32 a2 fd			ld (debug_mark+2),a  
36c1 18 03			jr .pastdmark  
36c3 ..			.dmark: db "LP>"  
36c6 f1			.pastdmark: pop af  
36c7			endm  
# End of macro DMARK
36c7				CALLMONITOR 
36c7 cd aa fd			call debug_vector  
36ca				endm  
# End of macro CALLMONITOR
36ca			endif 
36ca			 
36ca					NEXTW 
36ca c3 37 24			jp macro_next 
36cd				endm 
# End of macro NEXTW
36cd				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
36cd			 
36cd			.loopnotdone: 
36cd			 
36cd e1				pop hl    ; get I 
36ce 23				inc hl 
36cf			 
36cf			   	; save new I 
36cf			 
36cf			 
36cf					; set I counter 
36cf			 
36cf 22 1b f4				ld (os_current_i), hl 
36d2			 
36d2					if DEBUG_FORTH_WORDS 
36d2						DMARK "LPN" 
36d2 f5				push af  
36d3 3a e7 36			ld a, (.dmark)  
36d6 32 a0 fd			ld (debug_mark),a  
36d9 3a e8 36			ld a, (.dmark+1)  
36dc 32 a1 fd			ld (debug_mark+1),a  
36df 3a e9 36			ld a, (.dmark+2)  
36e2 32 a2 fd			ld (debug_mark+2),a  
36e5 18 03			jr .pastdmark  
36e7 ..			.dmark: db "LPN"  
36ea f1			.pastdmark: pop af  
36eb			endm  
# End of macro DMARK
36eb					CALLMONITOR 
36eb cd aa fd			call debug_vector  
36ee				endm  
# End of macro CALLMONITOR
36ee					endif 
36ee					 
36ee				FORTH_LOOP_NEXT 
36ee cd 7c 22			call macro_forth_loop_next 
36f1				endm 
# End of macro FORTH_LOOP_NEXT
36f1			 
36f1			 
36f1					if DEBUG_FORTH_WORDS 
36f1 eb						ex de,hl 
36f2					endif 
36f2			 
36f2			;	; get DO ptr 
36f2			; 
36f2					if DEBUG_FORTH_WORDS 
36f2						DMARK "LP7" 
36f2 f5				push af  
36f3 3a 07 37			ld a, (.dmark)  
36f6 32 a0 fd			ld (debug_mark),a  
36f9 3a 08 37			ld a, (.dmark+1)  
36fc 32 a1 fd			ld (debug_mark+1),a  
36ff 3a 09 37			ld a, (.dmark+2)  
3702 32 a2 fd			ld (debug_mark+2),a  
3705 18 03			jr .pastdmark  
3707 ..			.dmark: db "LP7"  
370a f1			.pastdmark: pop af  
370b			endm  
# End of macro DMARK
370b					CALLMONITOR 
370b cd aa fd			call debug_vector  
370e				endm  
# End of macro CALLMONITOR
370e					endif 
370e				FORTH_RSP_TOS 
370e cd 04 20			call macro_forth_rsp_tos 
3711				endm 
# End of macro FORTH_RSP_TOS
3711			 
3711					if DEBUG_FORTH_WORDS 
3711						DMARK "LP8" 
3711 f5				push af  
3712 3a 26 37			ld a, (.dmark)  
3715 32 a0 fd			ld (debug_mark),a  
3718 3a 27 37			ld a, (.dmark+1)  
371b 32 a1 fd			ld (debug_mark+1),a  
371e 3a 28 37			ld a, (.dmark+2)  
3721 32 a2 fd			ld (debug_mark+2),a  
3724 18 03			jr .pastdmark  
3726 ..			.dmark: db "LP8"  
3729 f1			.pastdmark: pop af  
372a			endm  
# End of macro DMARK
372a					CALLMONITOR 
372a cd aa fd			call debug_vector  
372d				endm  
# End of macro CALLMONITOR
372d					endif 
372d				;push hl 
372d			 
372d				; not going to DO any more 
372d				; get rid of the RSP pointer as DO will add it back in 
372d				;FORTH_RSP_POP 
372d				;pop hl 
372d			 
372d				;ld hl,(cli_ret_sp) 
372d				;ld e, (hl) 
372d				;inc hl 
372d				;ld d, (hl) 
372d				;ex de,hl 
372d 22 f7 f3			ld (os_tok_ptr), hl 
3730					if DEBUG_FORTH_WORDS 
3730						DMARK "LP<" 
3730 f5				push af  
3731 3a 45 37			ld a, (.dmark)  
3734 32 a0 fd			ld (debug_mark),a  
3737 3a 46 37			ld a, (.dmark+1)  
373a 32 a1 fd			ld (debug_mark+1),a  
373d 3a 47 37			ld a, (.dmark+2)  
3740 32 a2 fd			ld (debug_mark+2),a  
3743 18 03			jr .pastdmark  
3745 ..			.dmark: db "LP<"  
3748 f1			.pastdmark: pop af  
3749			endm  
# End of macro DMARK
3749					CALLMONITOR 
3749 cd aa fd			call debug_vector  
374c				endm  
# End of macro CALLMONITOR
374c				endif 
374c c3 c8 24			jp exec1 
374f			 
374f					 
374f			 
374f			 
374f					NEXTW 
374f c3 37 24			jp macro_next 
3752				endm 
# End of macro NEXTW
3752			.I:  
3752			 
3752				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3752 5e				db WORD_SYS_CORE+74             
3753 7d 37			dw .DLOOP            
3755 02				db 1 + 1 
3756 .. 00			db "I",0              
3758				endm 
# End of macro CWHEAD
3758			; | I ( -- ) Current loop counter | DONE 
3758					if DEBUG_FORTH_WORDS_KEY 
3758						DMARK "I.." 
3758 f5				push af  
3759 3a 6d 37			ld a, (.dmark)  
375c 32 a0 fd			ld (debug_mark),a  
375f 3a 6e 37			ld a, (.dmark+1)  
3762 32 a1 fd			ld (debug_mark+1),a  
3765 3a 6f 37			ld a, (.dmark+2)  
3768 32 a2 fd			ld (debug_mark+2),a  
376b 18 03			jr .pastdmark  
376d ..			.dmark: db "I.."  
3770 f1			.pastdmark: pop af  
3771			endm  
# End of macro DMARK
3771						CALLMONITOR 
3771 cd aa fd			call debug_vector  
3774				endm  
# End of macro CALLMONITOR
3774					endif 
3774			 
3774 2a 1b f4				ld hl,(os_current_i) 
3777 cd 46 20				call forth_push_numhl 
377a			 
377a					NEXTW 
377a c3 37 24			jp macro_next 
377d				endm 
# End of macro NEXTW
377d			.DLOOP: 
377d				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
377d 5f				db WORD_SYS_CORE+75             
377e 5e 38			dw .REPEAT            
3780 06				db 5 + 1 
3781 .. 00			db "-LOOP",0              
3787				endm 
# End of macro CWHEAD
3787			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3787				; pop tos as current loop count to hl 
3787					if DEBUG_FORTH_WORDS_KEY 
3787						DMARK "-LP" 
3787 f5				push af  
3788 3a 9c 37			ld a, (.dmark)  
378b 32 a0 fd			ld (debug_mark),a  
378e 3a 9d 37			ld a, (.dmark+1)  
3791 32 a1 fd			ld (debug_mark+1),a  
3794 3a 9e 37			ld a, (.dmark+2)  
3797 32 a2 fd			ld (debug_mark+2),a  
379a 18 03			jr .pastdmark  
379c ..			.dmark: db "-LP"  
379f f1			.pastdmark: pop af  
37a0			endm  
# End of macro DMARK
37a0						CALLMONITOR 
37a0 cd aa fd			call debug_vector  
37a3				endm  
# End of macro CALLMONITOR
37a3					endif 
37a3			 
37a3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
37a3			 
37a3				FORTH_LOOP_TOS 
37a3 cd af 22			call macro_forth_loop_tos 
37a6				endm 
# End of macro FORTH_LOOP_TOS
37a6 e5				push hl 
37a7			 
37a7					if DEBUG_FORTH_WORDS 
37a7						DMARK "-LP" 
37a7 f5				push af  
37a8 3a bc 37			ld a, (.dmark)  
37ab 32 a0 fd			ld (debug_mark),a  
37ae 3a bd 37			ld a, (.dmark+1)  
37b1 32 a1 fd			ld (debug_mark+1),a  
37b4 3a be 37			ld a, (.dmark+2)  
37b7 32 a2 fd			ld (debug_mark+2),a  
37ba 18 03			jr .pastdmark  
37bc ..			.dmark: db "-LP"  
37bf f1			.pastdmark: pop af  
37c0			endm  
# End of macro DMARK
37c0						CALLMONITOR 
37c0 cd aa fd			call debug_vector  
37c3				endm  
# End of macro CALLMONITOR
37c3					endif 
37c3				; next item on the stack is the limit. get it 
37c3			 
37c3			 
37c3				FORTH_LOOP_POP 
37c3 cd b9 22			call macro_forth_loop_pop 
37c6				endm 
# End of macro FORTH_LOOP_POP
37c6			 
37c6				FORTH_LOOP_TOS 
37c6 cd af 22			call macro_forth_loop_tos 
37c9				endm 
# End of macro FORTH_LOOP_TOS
37c9			 
37c9 d1				pop de		 ; de = i, hl = limit 
37ca			 
37ca					if DEBUG_FORTH_WORDS 
37ca						DMARK "-L1" 
37ca f5				push af  
37cb 3a df 37			ld a, (.dmark)  
37ce 32 a0 fd			ld (debug_mark),a  
37d1 3a e0 37			ld a, (.dmark+1)  
37d4 32 a1 fd			ld (debug_mark+1),a  
37d7 3a e1 37			ld a, (.dmark+2)  
37da 32 a2 fd			ld (debug_mark+2),a  
37dd 18 03			jr .pastdmark  
37df ..			.dmark: db "-L1"  
37e2 f1			.pastdmark: pop af  
37e3			endm  
# End of macro DMARK
37e3						CALLMONITOR 
37e3 cd aa fd			call debug_vector  
37e6				endm  
# End of macro CALLMONITOR
37e6					endif 
37e6			 
37e6				; go back to previous word 
37e6			 
37e6 d5				push de    ; save I for inc later 
37e7			 
37e7			 
37e7				; get limit 
37e7				;  is I at limit? 
37e7			 
37e7			 
37e7					if DEBUG_FORTH_WORDS 
37e7						DMARK "-L1" 
37e7 f5				push af  
37e8 3a fc 37			ld a, (.dmark)  
37eb 32 a0 fd			ld (debug_mark),a  
37ee 3a fd 37			ld a, (.dmark+1)  
37f1 32 a1 fd			ld (debug_mark+1),a  
37f4 3a fe 37			ld a, (.dmark+2)  
37f7 32 a2 fd			ld (debug_mark+2),a  
37fa 18 03			jr .pastdmark  
37fc ..			.dmark: db "-L1"  
37ff f1			.pastdmark: pop af  
3800			endm  
# End of macro DMARK
3800						CALLMONITOR 
3800 cd aa fd			call debug_vector  
3803				endm  
# End of macro CALLMONITOR
3803					endif 
3803			 
3803 ed 52			sbc hl, de 
3805			 
3805			 
3805				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3805			 
3805 20 26				jr nz, .mloopnotdone 
3807			 
3807 e1				pop hl   ; get rid of saved I 
3808				FORTH_LOOP_POP     ; get rid of limit 
3808 cd b9 22			call macro_forth_loop_pop 
380b				endm 
# End of macro FORTH_LOOP_POP
380b			 
380b				FORTH_RSP_POP     ; get rid of DO ptr 
380b cd 0e 20			call macro_forth_rsp_pop 
380e				endm 
# End of macro FORTH_RSP_POP
380e			 
380e			if DEBUG_FORTH_WORDS 
380e						DMARK "-L>" 
380e f5				push af  
380f 3a 23 38			ld a, (.dmark)  
3812 32 a0 fd			ld (debug_mark),a  
3815 3a 24 38			ld a, (.dmark+1)  
3818 32 a1 fd			ld (debug_mark+1),a  
381b 3a 25 38			ld a, (.dmark+2)  
381e 32 a2 fd			ld (debug_mark+2),a  
3821 18 03			jr .pastdmark  
3823 ..			.dmark: db "-L>"  
3826 f1			.pastdmark: pop af  
3827			endm  
# End of macro DMARK
3827				CALLMONITOR 
3827 cd aa fd			call debug_vector  
382a				endm  
# End of macro CALLMONITOR
382a			endif 
382a			 
382a					NEXTW 
382a c3 37 24			jp macro_next 
382d				endm 
# End of macro NEXTW
382d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
382d			 
382d			.mloopnotdone: 
382d			 
382d e1				pop hl    ; get I 
382e 2b				dec hl 
382f			 
382f			   	; save new I 
382f			 
382f			 
382f					; set I counter 
382f			 
382f 22 1b f4				ld (os_current_i), hl 
3832			 
3832					 
3832				FORTH_LOOP_NEXT 
3832 cd 7c 22			call macro_forth_loop_next 
3835				endm 
# End of macro FORTH_LOOP_NEXT
3835			 
3835			 
3835					if DEBUG_FORTH_WORDS 
3835 eb						ex de,hl 
3836					endif 
3836			 
3836			;	; get DO ptr 
3836			; 
3836				FORTH_RSP_TOS 
3836 cd 04 20			call macro_forth_rsp_tos 
3839				endm 
# End of macro FORTH_RSP_TOS
3839			 
3839				;push hl 
3839			 
3839				; not going to DO any more 
3839				; get rid of the RSP pointer as DO will add it back in 
3839				;FORTH_RSP_POP 
3839				;pop hl 
3839			 
3839			 
3839 22 f7 f3			ld (os_tok_ptr), hl 
383c					if DEBUG_FORTH_WORDS 
383c						DMARK "-L<" 
383c f5				push af  
383d 3a 51 38			ld a, (.dmark)  
3840 32 a0 fd			ld (debug_mark),a  
3843 3a 52 38			ld a, (.dmark+1)  
3846 32 a1 fd			ld (debug_mark+1),a  
3849 3a 53 38			ld a, (.dmark+2)  
384c 32 a2 fd			ld (debug_mark+2),a  
384f 18 03			jr .pastdmark  
3851 ..			.dmark: db "-L<"  
3854 f1			.pastdmark: pop af  
3855			endm  
# End of macro DMARK
3855					CALLMONITOR 
3855 cd aa fd			call debug_vector  
3858				endm  
# End of macro CALLMONITOR
3858				endif 
3858 c3 c8 24			jp exec1 
385b			 
385b					 
385b			 
385b			 
385b			 
385b				NEXTW 
385b c3 37 24			jp macro_next 
385e				endm 
# End of macro NEXTW
385e			 
385e			 
385e			 
385e			 
385e			.REPEAT: 
385e				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
385e 71				db WORD_SYS_CORE+93             
385f b1 38			dw .UNTIL            
3861 06				db 5 + 1 
3862 .. 00			db "REPEAT",0              
3869				endm 
# End of macro CWHEAD
3869			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3869			;  push pc to rsp stack past the REPEAT 
3869					if DEBUG_FORTH_WORDS_KEY 
3869						DMARK "REP" 
3869 f5				push af  
386a 3a 7e 38			ld a, (.dmark)  
386d 32 a0 fd			ld (debug_mark),a  
3870 3a 7f 38			ld a, (.dmark+1)  
3873 32 a1 fd			ld (debug_mark+1),a  
3876 3a 80 38			ld a, (.dmark+2)  
3879 32 a2 fd			ld (debug_mark+2),a  
387c 18 03			jr .pastdmark  
387e ..			.dmark: db "REP"  
3881 f1			.pastdmark: pop af  
3882			endm  
# End of macro DMARK
3882						CALLMONITOR 
3882 cd aa fd			call debug_vector  
3885				endm  
# End of macro CALLMONITOR
3885					endif 
3885			 
3885 2a f7 f3				ld hl, (os_tok_ptr) 
3888 23					inc hl   ; R 
3889 23					inc hl  ; E 
388a 23					inc hl   ; P 
388b 23					inc hl   ; E 
388c 23					inc hl   ; A 
388d 23					inc hl   ; T 
388e 23					inc hl   ; zero 
388f					FORTH_RSP_NEXT 
388f cd ed 1f			call macro_forth_rsp_next 
3892				endm 
# End of macro FORTH_RSP_NEXT
3892			 
3892			 
3892					if DEBUG_FORTH_WORDS 
3892						DMARK "REP" 
3892 f5				push af  
3893 3a a7 38			ld a, (.dmark)  
3896 32 a0 fd			ld (debug_mark),a  
3899 3a a8 38			ld a, (.dmark+1)  
389c 32 a1 fd			ld (debug_mark+1),a  
389f 3a a9 38			ld a, (.dmark+2)  
38a2 32 a2 fd			ld (debug_mark+2),a  
38a5 18 03			jr .pastdmark  
38a7 ..			.dmark: db "REP"  
38aa f1			.pastdmark: pop af  
38ab			endm  
# End of macro DMARK
38ab						;pop bc    ; TODO BUG ?????? what is this for???? 
38ab						CALLMONITOR 
38ab cd aa fd			call debug_vector  
38ae				endm  
# End of macro CALLMONITOR
38ae					endif 
38ae			 
38ae					NEXTW 
38ae c3 37 24			jp macro_next 
38b1				endm 
# End of macro NEXTW
38b1			;	       NEXTW 
38b1			 
38b1			.UNTIL: 
38b1				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
38b1 72				db WORD_SYS_CORE+94             
38b2 48 39			dw .ENDFLOW            
38b4 06				db 5 + 1 
38b5 .. 00			db "UNTIL",0              
38bb				endm 
# End of macro CWHEAD
38bb			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
38bb			 
38bb				; pop tos as check 
38bb			 
38bb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
38bb			 
38bb				FORTH_DSP_VALUEHL 
38bb cd 4b 22			call macro_dsp_valuehl 
38be				endm 
# End of macro FORTH_DSP_VALUEHL
38be			 
38be					if DEBUG_FORTH_WORDS_KEY 
38be						DMARK "UNT" 
38be f5				push af  
38bf 3a d3 38			ld a, (.dmark)  
38c2 32 a0 fd			ld (debug_mark),a  
38c5 3a d4 38			ld a, (.dmark+1)  
38c8 32 a1 fd			ld (debug_mark+1),a  
38cb 3a d5 38			ld a, (.dmark+2)  
38ce 32 a2 fd			ld (debug_mark+2),a  
38d1 18 03			jr .pastdmark  
38d3 ..			.dmark: db "UNT"  
38d6 f1			.pastdmark: pop af  
38d7			endm  
# End of macro DMARK
38d7						CALLMONITOR 
38d7 cd aa fd			call debug_vector  
38da				endm  
# End of macro CALLMONITOR
38da					endif 
38da			 
38da			;	push hl 
38da				FORTH_DSP_POP 
38da cd 03 23			call macro_forth_dsp_pop 
38dd				endm 
# End of macro FORTH_DSP_POP
38dd			 
38dd			;	pop hl 
38dd			 
38dd				; test if true 
38dd			 
38dd cd 07 10			call ishlzero 
38e0			;	ld a,l 
38e0			;	add h 
38e0			; 
38e0			;	cp 0 
38e0			 
38e0 20 3e			jr nz, .untilnotdone 
38e2			 
38e2					if DEBUG_FORTH_WORDS 
38e2						DMARK "UNf" 
38e2 f5				push af  
38e3 3a f7 38			ld a, (.dmark)  
38e6 32 a0 fd			ld (debug_mark),a  
38e9 3a f8 38			ld a, (.dmark+1)  
38ec 32 a1 fd			ld (debug_mark+1),a  
38ef 3a f9 38			ld a, (.dmark+2)  
38f2 32 a2 fd			ld (debug_mark+2),a  
38f5 18 03			jr .pastdmark  
38f7 ..			.dmark: db "UNf"  
38fa f1			.pastdmark: pop af  
38fb			endm  
# End of macro DMARK
38fb						CALLMONITOR 
38fb cd aa fd			call debug_vector  
38fe				endm  
# End of macro CALLMONITOR
38fe					endif 
38fe			 
38fe			 
38fe			 
38fe				FORTH_RSP_POP     ; get rid of DO ptr 
38fe cd 0e 20			call macro_forth_rsp_pop 
3901				endm 
# End of macro FORTH_RSP_POP
3901			 
3901			if DEBUG_FORTH_WORDS 
3901						DMARK "UN>" 
3901 f5				push af  
3902 3a 16 39			ld a, (.dmark)  
3905 32 a0 fd			ld (debug_mark),a  
3908 3a 17 39			ld a, (.dmark+1)  
390b 32 a1 fd			ld (debug_mark+1),a  
390e 3a 18 39			ld a, (.dmark+2)  
3911 32 a2 fd			ld (debug_mark+2),a  
3914 18 03			jr .pastdmark  
3916 ..			.dmark: db "UN>"  
3919 f1			.pastdmark: pop af  
391a			endm  
# End of macro DMARK
391a				CALLMONITOR 
391a cd aa fd			call debug_vector  
391d				endm  
# End of macro CALLMONITOR
391d			endif 
391d			 
391d					NEXTW 
391d c3 37 24			jp macro_next 
3920				endm 
# End of macro NEXTW
3920				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3920			 
3920			.untilnotdone: 
3920			 
3920			 
3920			;	; get DO ptr 
3920			; 
3920				FORTH_RSP_TOS 
3920 cd 04 20			call macro_forth_rsp_tos 
3923				endm 
# End of macro FORTH_RSP_TOS
3923			 
3923				;push hl 
3923			 
3923				; not going to DO any more 
3923				; get rid of the RSP pointer as DO will add it back in 
3923				;FORTH_RSP_POP 
3923				;pop hl 
3923			 
3923			 
3923 22 f7 f3			ld (os_tok_ptr), hl 
3926					if DEBUG_FORTH_WORDS 
3926						DMARK "UN<" 
3926 f5				push af  
3927 3a 3b 39			ld a, (.dmark)  
392a 32 a0 fd			ld (debug_mark),a  
392d 3a 3c 39			ld a, (.dmark+1)  
3930 32 a1 fd			ld (debug_mark+1),a  
3933 3a 3d 39			ld a, (.dmark+2)  
3936 32 a2 fd			ld (debug_mark+2),a  
3939 18 03			jr .pastdmark  
393b ..			.dmark: db "UN<"  
393e f1			.pastdmark: pop af  
393f			endm  
# End of macro DMARK
393f					CALLMONITOR 
393f cd aa fd			call debug_vector  
3942				endm  
# End of macro CALLMONITOR
3942				endif 
3942 c3 c8 24			jp exec1 
3945			 
3945					 
3945			 
3945			 
3945					NEXTW 
3945 c3 37 24			jp macro_next 
3948				endm 
# End of macro NEXTW
3948			 
3948			 
3948			.ENDFLOW: 
3948			 
3948			; eof 
3948			 
# End of file forth_words_flow.asm
3948			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3948			include "forth_words_logic.asm" 
3948			 
3948			; | ## Logic Words 
3948			 
3948			.NOT: 
3948				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3948 2d				db WORD_SYS_CORE+25             
3949 90 39			dw .IS            
394b 04				db 3 + 1 
394c .. 00			db "NOT",0              
3950				endm 
# End of macro CWHEAD
3950			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3950					if DEBUG_FORTH_WORDS_KEY 
3950						DMARK "NOT" 
3950 f5				push af  
3951 3a 65 39			ld a, (.dmark)  
3954 32 a0 fd			ld (debug_mark),a  
3957 3a 66 39			ld a, (.dmark+1)  
395a 32 a1 fd			ld (debug_mark+1),a  
395d 3a 67 39			ld a, (.dmark+2)  
3960 32 a2 fd			ld (debug_mark+2),a  
3963 18 03			jr .pastdmark  
3965 ..			.dmark: db "NOT"  
3968 f1			.pastdmark: pop af  
3969			endm  
# End of macro DMARK
3969						CALLMONITOR 
3969 cd aa fd			call debug_vector  
396c				endm  
# End of macro CALLMONITOR
396c					endif 
396c					FORTH_DSP 
396c cd 11 22			call macro_forth_dsp 
396f				endm 
# End of macro FORTH_DSP
396f 7e					ld a,(hl)	; get type of value on TOS 
3970 fe 02				cp DS_TYPE_INUM  
3972 28 03				jr z, .noti 
3974					NEXTW 
3974 c3 37 24			jp macro_next 
3977				endm 
# End of macro NEXTW
3977			.noti:          FORTH_DSP_VALUEHL 
3977 cd 4b 22			call macro_dsp_valuehl 
397a				endm 
# End of macro FORTH_DSP_VALUEHL
397a			;		push hl 
397a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
397a cd 03 23			call macro_forth_dsp_pop 
397d				endm 
# End of macro FORTH_DSP_POP
397d			;		pop hl 
397d 3e 00				ld a,0 
397f bd					cp l 
3980 28 04				jr z, .not2t 
3982 2e 00				ld l, 0 
3984 18 02				jr .notip 
3986			 
3986 2e ff		.not2t:		ld l, 255 
3988			 
3988 26 00		.notip:		ld h, 0	 
398a			 
398a cd 46 20				call forth_push_numhl 
398d					NEXTW 
398d c3 37 24			jp macro_next 
3990				endm 
# End of macro NEXTW
3990			 
3990			.IS: 
3990				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3990 2d				db WORD_SYS_CORE+25             
3991 b6 39			dw .LZERO            
3993 03				db 2 + 1 
3994 .. 00			db "IS",0              
3997				endm 
# End of macro CWHEAD
3997			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3997					if DEBUG_FORTH_WORDS_KEY 
3997						DMARK "IS." 
3997 f5				push af  
3998 3a ac 39			ld a, (.dmark)  
399b 32 a0 fd			ld (debug_mark),a  
399e 3a ad 39			ld a, (.dmark+1)  
39a1 32 a1 fd			ld (debug_mark+1),a  
39a4 3a ae 39			ld a, (.dmark+2)  
39a7 32 a2 fd			ld (debug_mark+2),a  
39aa 18 03			jr .pastdmark  
39ac ..			.dmark: db "IS."  
39af f1			.pastdmark: pop af  
39b0			endm  
# End of macro DMARK
39b0						CALLMONITOR 
39b0 cd aa fd			call debug_vector  
39b3				endm  
# End of macro CALLMONITOR
39b3					endif 
39b3					NEXTW 
39b3 c3 37 24			jp macro_next 
39b6				endm 
# End of macro NEXTW
39b6			.LZERO: 
39b6				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
39b6 2d				db WORD_SYS_CORE+25             
39b7 c0 39			dw .TZERO            
39b9 03				db 2 + 1 
39ba .. 00			db "0<",0              
39bd				endm 
# End of macro CWHEAD
39bd			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
39bd					NEXTW 
39bd c3 37 24			jp macro_next 
39c0				endm 
# End of macro NEXTW
39c0			.TZERO: 
39c0				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
39c0 2e				db WORD_SYS_CORE+26             
39c1 07 3a			dw .LESS            
39c3 03				db 2 + 1 
39c4 .. 00			db "0=",0              
39c7				endm 
# End of macro CWHEAD
39c7			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
39c7				; TODO add floating point number detection 
39c7					;v5 FORTH_DSP_VALUE 
39c7					if DEBUG_FORTH_WORDS_KEY 
39c7						DMARK "0=." 
39c7 f5				push af  
39c8 3a dc 39			ld a, (.dmark)  
39cb 32 a0 fd			ld (debug_mark),a  
39ce 3a dd 39			ld a, (.dmark+1)  
39d1 32 a1 fd			ld (debug_mark+1),a  
39d4 3a de 39			ld a, (.dmark+2)  
39d7 32 a2 fd			ld (debug_mark+2),a  
39da 18 03			jr .pastdmark  
39dc ..			.dmark: db "0=."  
39df f1			.pastdmark: pop af  
39e0			endm  
# End of macro DMARK
39e0						CALLMONITOR 
39e0 cd aa fd			call debug_vector  
39e3				endm  
# End of macro CALLMONITOR
39e3					endif 
39e3					FORTH_DSP 
39e3 cd 11 22			call macro_forth_dsp 
39e6				endm 
# End of macro FORTH_DSP
39e6 7e					ld a,(hl)	; get type of value on TOS 
39e7 fe 02				cp DS_TYPE_INUM  
39e9 28 00				jr z, .tz_inum 
39eb			 
39eb				if FORTH_ENABLE_FLOATMATH 
39eb					jr .tz_done 
39eb			 
39eb				endif 
39eb					 
39eb			 
39eb			.tz_inum: 
39eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39eb cd 4b 22			call macro_dsp_valuehl 
39ee				endm 
# End of macro FORTH_DSP_VALUEHL
39ee			 
39ee			;		push hl 
39ee			 
39ee					; destroy value TOS 
39ee			 
39ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ee cd 03 23			call macro_forth_dsp_pop 
39f1				endm 
# End of macro FORTH_DSP_POP
39f1			 
39f1			;		pop hl 
39f1			 
39f1 3e 00				ld a,0 
39f3			 
39f3 bd					cp l 
39f4 20 08				jr nz, .tz_notzero 
39f6			 
39f6 bc					cp h 
39f7			 
39f7 20 05				jr nz, .tz_notzero 
39f9			 
39f9			 
39f9 21 01 00				ld hl, FORTH_TRUE 
39fc 18 03				jr .tz_done 
39fe			 
39fe 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3a01			 
3a01					; push value back onto stack for another op etc 
3a01			 
3a01			.tz_done: 
3a01 cd 46 20				call forth_push_numhl 
3a04			 
3a04					NEXTW 
3a04 c3 37 24			jp macro_next 
3a07				endm 
# End of macro NEXTW
3a07			.LESS: 
3a07				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3a07 2f				db WORD_SYS_CORE+27             
3a08 70 3a			dw .GT            
3a0a 02				db 1 + 1 
3a0b .. 00			db "<",0              
3a0d				endm 
# End of macro CWHEAD
3a0d			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3a0d				; TODO add floating point number detection 
3a0d					if DEBUG_FORTH_WORDS_KEY 
3a0d						DMARK "LES" 
3a0d f5				push af  
3a0e 3a 22 3a			ld a, (.dmark)  
3a11 32 a0 fd			ld (debug_mark),a  
3a14 3a 23 3a			ld a, (.dmark+1)  
3a17 32 a1 fd			ld (debug_mark+1),a  
3a1a 3a 24 3a			ld a, (.dmark+2)  
3a1d 32 a2 fd			ld (debug_mark+2),a  
3a20 18 03			jr .pastdmark  
3a22 ..			.dmark: db "LES"  
3a25 f1			.pastdmark: pop af  
3a26			endm  
# End of macro DMARK
3a26						CALLMONITOR 
3a26 cd aa fd			call debug_vector  
3a29				endm  
# End of macro CALLMONITOR
3a29					endif 
3a29					FORTH_DSP 
3a29 cd 11 22			call macro_forth_dsp 
3a2c				endm 
# End of macro FORTH_DSP
3a2c					;v5 FORTH_DSP_VALUE 
3a2c 7e					ld a,(hl)	; get type of value on TOS 
3a2d fe 02				cp DS_TYPE_INUM  
3a2f 28 00				jr z, .less_inum 
3a31			 
3a31				if FORTH_ENABLE_FLOATMATH 
3a31					jr .less_done 
3a31			 
3a31				endif 
3a31					 
3a31			 
3a31			.less_inum: 
3a31					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a31 cd 4b 22			call macro_dsp_valuehl 
3a34				endm 
# End of macro FORTH_DSP_VALUEHL
3a34			 
3a34 e5					push hl  ; u2 
3a35			 
3a35					; destroy value TOS 
3a35			 
3a35					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a35 cd 03 23			call macro_forth_dsp_pop 
3a38				endm 
# End of macro FORTH_DSP_POP
3a38			 
3a38			 
3a38					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a38 cd 4b 22			call macro_dsp_valuehl 
3a3b				endm 
# End of macro FORTH_DSP_VALUEHL
3a3b			 
3a3b e5					push hl    ; u1 
3a3c			 
3a3c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a3c cd 03 23			call macro_forth_dsp_pop 
3a3f				endm 
# End of macro FORTH_DSP_POP
3a3f			 
3a3f			 
3a3f b7			 or a      ;clear carry flag 
3a40 01 00 00		 ld bc, FORTH_FALSE 
3a43 e1			  pop hl    ; u1 
3a44 d1			  pop de    ; u2 
3a45 ed 52		  sbc hl,de 
3a47 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3a49			 
3a49 01 01 00		 ld bc, FORTH_TRUE 
3a4c			.lscont:  
3a4c c5					push bc 
3a4d e1					pop hl 
3a4e			 
3a4e					if DEBUG_FORTH_WORDS 
3a4e						DMARK "LT1" 
3a4e f5				push af  
3a4f 3a 63 3a			ld a, (.dmark)  
3a52 32 a0 fd			ld (debug_mark),a  
3a55 3a 64 3a			ld a, (.dmark+1)  
3a58 32 a1 fd			ld (debug_mark+1),a  
3a5b 3a 65 3a			ld a, (.dmark+2)  
3a5e 32 a2 fd			ld (debug_mark+2),a  
3a61 18 03			jr .pastdmark  
3a63 ..			.dmark: db "LT1"  
3a66 f1			.pastdmark: pop af  
3a67			endm  
# End of macro DMARK
3a67						CALLMONITOR 
3a67 cd aa fd			call debug_vector  
3a6a				endm  
# End of macro CALLMONITOR
3a6a					endif 
3a6a cd 46 20				call forth_push_numhl 
3a6d			 
3a6d					NEXTW 
3a6d c3 37 24			jp macro_next 
3a70				endm 
# End of macro NEXTW
3a70			.GT: 
3a70				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3a70 30				db WORD_SYS_CORE+28             
3a71 d9 3a			dw .EQUAL            
3a73 02				db 1 + 1 
3a74 .. 00			db ">",0              
3a76				endm 
# End of macro CWHEAD
3a76			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3a76				; TODO add floating point number detection 
3a76					if DEBUG_FORTH_WORDS_KEY 
3a76						DMARK "GRT" 
3a76 f5				push af  
3a77 3a 8b 3a			ld a, (.dmark)  
3a7a 32 a0 fd			ld (debug_mark),a  
3a7d 3a 8c 3a			ld a, (.dmark+1)  
3a80 32 a1 fd			ld (debug_mark+1),a  
3a83 3a 8d 3a			ld a, (.dmark+2)  
3a86 32 a2 fd			ld (debug_mark+2),a  
3a89 18 03			jr .pastdmark  
3a8b ..			.dmark: db "GRT"  
3a8e f1			.pastdmark: pop af  
3a8f			endm  
# End of macro DMARK
3a8f						CALLMONITOR 
3a8f cd aa fd			call debug_vector  
3a92				endm  
# End of macro CALLMONITOR
3a92					endif 
3a92					FORTH_DSP 
3a92 cd 11 22			call macro_forth_dsp 
3a95				endm 
# End of macro FORTH_DSP
3a95					;FORTH_DSP_VALUE 
3a95 7e					ld a,(hl)	; get type of value on TOS 
3a96 fe 02				cp DS_TYPE_INUM  
3a98 28 00				jr z, .gt_inum 
3a9a			 
3a9a				if FORTH_ENABLE_FLOATMATH 
3a9a					jr .gt_done 
3a9a			 
3a9a				endif 
3a9a					 
3a9a			 
3a9a			.gt_inum: 
3a9a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a9a cd 4b 22			call macro_dsp_valuehl 
3a9d				endm 
# End of macro FORTH_DSP_VALUEHL
3a9d			 
3a9d e5					push hl  ; u2 
3a9e			 
3a9e					; destroy value TOS 
3a9e			 
3a9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9e cd 03 23			call macro_forth_dsp_pop 
3aa1				endm 
# End of macro FORTH_DSP_POP
3aa1			 
3aa1			 
3aa1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa1 cd 4b 22			call macro_dsp_valuehl 
3aa4				endm 
# End of macro FORTH_DSP_VALUEHL
3aa4			 
3aa4 e5					push hl    ; u1 
3aa5			 
3aa5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa5 cd 03 23			call macro_forth_dsp_pop 
3aa8				endm 
# End of macro FORTH_DSP_POP
3aa8			 
3aa8			 
3aa8 b7			 or a      ;clear carry flag 
3aa9 01 00 00		 ld bc, FORTH_FALSE 
3aac e1			  pop hl    ; u1 
3aad d1			  pop de    ; u2 
3aae ed 52		  sbc hl,de 
3ab0 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3ab2			 
3ab2 01 01 00		 ld bc, FORTH_TRUE 
3ab5			.gtcont:  
3ab5 c5					push bc 
3ab6 e1					pop hl 
3ab7			 
3ab7					if DEBUG_FORTH_WORDS 
3ab7						DMARK "GT1" 
3ab7 f5				push af  
3ab8 3a cc 3a			ld a, (.dmark)  
3abb 32 a0 fd			ld (debug_mark),a  
3abe 3a cd 3a			ld a, (.dmark+1)  
3ac1 32 a1 fd			ld (debug_mark+1),a  
3ac4 3a ce 3a			ld a, (.dmark+2)  
3ac7 32 a2 fd			ld (debug_mark+2),a  
3aca 18 03			jr .pastdmark  
3acc ..			.dmark: db "GT1"  
3acf f1			.pastdmark: pop af  
3ad0			endm  
# End of macro DMARK
3ad0						CALLMONITOR 
3ad0 cd aa fd			call debug_vector  
3ad3				endm  
# End of macro CALLMONITOR
3ad3					endif 
3ad3 cd 46 20				call forth_push_numhl 
3ad6			 
3ad6					NEXTW 
3ad6 c3 37 24			jp macro_next 
3ad9				endm 
# End of macro NEXTW
3ad9			.EQUAL: 
3ad9				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3ad9 31				db WORD_SYS_CORE+29             
3ada 44 3b			dw .ENDLOGIC            
3adc 02				db 1 + 1 
3add .. 00			db "=",0              
3adf				endm 
# End of macro CWHEAD
3adf			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3adf				; TODO add floating point number detection 
3adf					if DEBUG_FORTH_WORDS_KEY 
3adf						DMARK "EQ." 
3adf f5				push af  
3ae0 3a f4 3a			ld a, (.dmark)  
3ae3 32 a0 fd			ld (debug_mark),a  
3ae6 3a f5 3a			ld a, (.dmark+1)  
3ae9 32 a1 fd			ld (debug_mark+1),a  
3aec 3a f6 3a			ld a, (.dmark+2)  
3aef 32 a2 fd			ld (debug_mark+2),a  
3af2 18 03			jr .pastdmark  
3af4 ..			.dmark: db "EQ."  
3af7 f1			.pastdmark: pop af  
3af8			endm  
# End of macro DMARK
3af8						CALLMONITOR 
3af8 cd aa fd			call debug_vector  
3afb				endm  
# End of macro CALLMONITOR
3afb					endif 
3afb					FORTH_DSP 
3afb cd 11 22			call macro_forth_dsp 
3afe				endm 
# End of macro FORTH_DSP
3afe					;v5 FORTH_DSP_VALUE 
3afe 7e					ld a,(hl)	; get type of value on TOS 
3aff fe 02				cp DS_TYPE_INUM  
3b01 28 00				jr z, .eq_inum 
3b03			 
3b03				if FORTH_ENABLE_FLOATMATH 
3b03					jr .eq_done 
3b03			 
3b03				endif 
3b03					 
3b03			 
3b03			.eq_inum: 
3b03					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b03 cd 4b 22			call macro_dsp_valuehl 
3b06				endm 
# End of macro FORTH_DSP_VALUEHL
3b06			 
3b06 e5					push hl 
3b07			 
3b07					; destroy value TOS 
3b07			 
3b07					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b07 cd 03 23			call macro_forth_dsp_pop 
3b0a				endm 
# End of macro FORTH_DSP_POP
3b0a			 
3b0a			 
3b0a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b0a cd 4b 22			call macro_dsp_valuehl 
3b0d				endm 
# End of macro FORTH_DSP_VALUEHL
3b0d			 
3b0d					; one value on hl get other one back 
3b0d			 
3b0d e5					push hl 
3b0e			 
3b0e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b0e cd 03 23			call macro_forth_dsp_pop 
3b11				endm 
# End of macro FORTH_DSP_POP
3b11			 
3b11 0e 00				ld c, FORTH_FALSE 
3b13			 
3b13 e1					pop hl 
3b14 d1					pop de 
3b15			 
3b15 7b					ld a, e 
3b16 bd					cp l 
3b17			 
3b17 20 06				jr nz, .eq_done 
3b19			 
3b19 7a					ld a, d 
3b1a bc					cp h 
3b1b			 
3b1b 20 02				jr nz, .eq_done 
3b1d			 
3b1d 0e 01				ld c, FORTH_TRUE 
3b1f					 
3b1f			 
3b1f			 
3b1f			.eq_done: 
3b1f			 
3b1f					; TODO push value back onto stack for another op etc 
3b1f			 
3b1f 26 00				ld h, 0 
3b21 69					ld l, c 
3b22					if DEBUG_FORTH_WORDS 
3b22						DMARK "EQ1" 
3b22 f5				push af  
3b23 3a 37 3b			ld a, (.dmark)  
3b26 32 a0 fd			ld (debug_mark),a  
3b29 3a 38 3b			ld a, (.dmark+1)  
3b2c 32 a1 fd			ld (debug_mark+1),a  
3b2f 3a 39 3b			ld a, (.dmark+2)  
3b32 32 a2 fd			ld (debug_mark+2),a  
3b35 18 03			jr .pastdmark  
3b37 ..			.dmark: db "EQ1"  
3b3a f1			.pastdmark: pop af  
3b3b			endm  
# End of macro DMARK
3b3b						CALLMONITOR 
3b3b cd aa fd			call debug_vector  
3b3e				endm  
# End of macro CALLMONITOR
3b3e					endif 
3b3e cd 46 20				call forth_push_numhl 
3b41			 
3b41					NEXTW 
3b41 c3 37 24			jp macro_next 
3b44				endm 
# End of macro NEXTW
3b44			 
3b44			 
3b44			.ENDLOGIC: 
3b44			; eof 
3b44			 
3b44			 
# End of file forth_words_logic.asm
3b44			include "forth_words_maths.asm" 
3b44			 
3b44			; | ## Maths Words 
3b44			 
3b44			.PLUS:	 
3b44				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3b44 15				db WORD_SYS_CORE+1             
3b45 a2 3b			dw .NEG            
3b47 02				db 1 + 1 
3b48 .. 00			db "+",0              
3b4a				endm 
# End of macro CWHEAD
3b4a			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3b4a					if DEBUG_FORTH_WORDS_KEY 
3b4a						DMARK "PLU" 
3b4a f5				push af  
3b4b 3a 5f 3b			ld a, (.dmark)  
3b4e 32 a0 fd			ld (debug_mark),a  
3b51 3a 60 3b			ld a, (.dmark+1)  
3b54 32 a1 fd			ld (debug_mark+1),a  
3b57 3a 61 3b			ld a, (.dmark+2)  
3b5a 32 a2 fd			ld (debug_mark+2),a  
3b5d 18 03			jr .pastdmark  
3b5f ..			.dmark: db "PLU"  
3b62 f1			.pastdmark: pop af  
3b63			endm  
# End of macro DMARK
3b63						CALLMONITOR 
3b63 cd aa fd			call debug_vector  
3b66				endm  
# End of macro CALLMONITOR
3b66					endif 
3b66					; add top two values and push back result 
3b66			 
3b66					;for v5 FORTH_DSP_VALUE 
3b66					FORTH_DSP 
3b66 cd 11 22			call macro_forth_dsp 
3b69				endm 
# End of macro FORTH_DSP
3b69 7e					ld a,(hl)	; get type of value on TOS 
3b6a fe 02				cp DS_TYPE_INUM  
3b6c 28 03				jr z, .dot_inum 
3b6e			 
3b6e					NEXTW 
3b6e c3 37 24			jp macro_next 
3b71				endm 
# End of macro NEXTW
3b71			 
3b71			; float maths 
3b71			 
3b71				if FORTH_ENABLE_FLOATMATH 
3b71						inc hl      ; now at start of numeric as string 
3b71			 
3b71					if DEBUG_FORTH_MATHS 
3b71						DMARK "ADD" 
3b71				CALLMONITOR 
3b71					endif 
3b71			 
3b71					;ld ix, hl 
3b71					call CON 
3b71			 
3b71			 
3b71					push hl 
3b71					 
3b71					 
3b71			 
3b71						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3b71			 
3b71					; get next number 
3b71			 
3b71						FORTH_DSP_VALUE 
3b71			 
3b71						inc hl      ; now at start of numeric as string 
3b71			 
3b71					;ld ix, hl 
3b71					call CON 
3b71			 
3b71					push hl 
3b71			 
3b71			 
3b71						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b71			 
3b71						; TODO do add 
3b71			 
3b71						call IADD 
3b71			 
3b71						; TODO get result back as ascii 
3b71			 
3b71						; TODO push result  
3b71			 
3b71			 
3b71			 
3b71						jr .dot_done 
3b71				endif 
3b71			 
3b71			.dot_inum: 
3b71			 
3b71			 
3b71					if DEBUG_FORTH_DOT 
3b71						DMARK "+IT" 
3b71 f5				push af  
3b72 3a 86 3b			ld a, (.dmark)  
3b75 32 a0 fd			ld (debug_mark),a  
3b78 3a 87 3b			ld a, (.dmark+1)  
3b7b 32 a1 fd			ld (debug_mark+1),a  
3b7e 3a 88 3b			ld a, (.dmark+2)  
3b81 32 a2 fd			ld (debug_mark+2),a  
3b84 18 03			jr .pastdmark  
3b86 ..			.dmark: db "+IT"  
3b89 f1			.pastdmark: pop af  
3b8a			endm  
# End of macro DMARK
3b8a				CALLMONITOR 
3b8a cd aa fd			call debug_vector  
3b8d				endm  
# End of macro CALLMONITOR
3b8d					endif 
3b8d			 
3b8d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b8d cd 4b 22			call macro_dsp_valuehl 
3b90				endm 
# End of macro FORTH_DSP_VALUEHL
3b90			 
3b90				; TODO add floating point number detection 
3b90			 
3b90 e5					push hl 
3b91			 
3b91					; destroy value TOS 
3b91			 
3b91					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b91 cd 03 23			call macro_forth_dsp_pop 
3b94				endm 
# End of macro FORTH_DSP_POP
3b94			 
3b94			 
3b94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b94 cd 4b 22			call macro_dsp_valuehl 
3b97				endm 
# End of macro FORTH_DSP_VALUEHL
3b97			 
3b97					; one value on hl get other one back 
3b97			 
3b97 d1					pop de 
3b98			 
3b98					; do the add 
3b98			 
3b98 19					add hl,de 
3b99			 
3b99					; save it 
3b99			 
3b99			;		push hl	 
3b99			 
3b99					; 
3b99			 
3b99					; destroy value TOS 
3b99			 
3b99					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b99 cd 03 23			call macro_forth_dsp_pop 
3b9c				endm 
# End of macro FORTH_DSP_POP
3b9c			 
3b9c					; TODO push value back onto stack for another op etc 
3b9c			 
3b9c			;		pop hl 
3b9c			 
3b9c			.dot_done: 
3b9c cd 46 20				call forth_push_numhl 
3b9f			 
3b9f					NEXTW 
3b9f c3 37 24			jp macro_next 
3ba2				endm 
# End of macro NEXTW
3ba2			.NEG: 
3ba2			 
3ba2				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3ba2 17				db WORD_SYS_CORE+3             
3ba3 e5 3b			dw .DIV            
3ba5 02				db 1 + 1 
3ba6 .. 00			db "-",0              
3ba8				endm 
# End of macro CWHEAD
3ba8			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3ba8					if DEBUG_FORTH_WORDS_KEY 
3ba8						DMARK "SUB" 
3ba8 f5				push af  
3ba9 3a bd 3b			ld a, (.dmark)  
3bac 32 a0 fd			ld (debug_mark),a  
3baf 3a be 3b			ld a, (.dmark+1)  
3bb2 32 a1 fd			ld (debug_mark+1),a  
3bb5 3a bf 3b			ld a, (.dmark+2)  
3bb8 32 a2 fd			ld (debug_mark+2),a  
3bbb 18 03			jr .pastdmark  
3bbd ..			.dmark: db "SUB"  
3bc0 f1			.pastdmark: pop af  
3bc1			endm  
# End of macro DMARK
3bc1						CALLMONITOR 
3bc1 cd aa fd			call debug_vector  
3bc4				endm  
# End of macro CALLMONITOR
3bc4					endif 
3bc4			 
3bc4			 
3bc4				; TODO add floating point number detection 
3bc4					; v5 FORTH_DSP_VALUE 
3bc4					FORTH_DSP 
3bc4 cd 11 22			call macro_forth_dsp 
3bc7				endm 
# End of macro FORTH_DSP
3bc7 7e					ld a,(hl)	; get type of value on TOS 
3bc8 fe 02				cp DS_TYPE_INUM  
3bca 28 03				jr z, .neg_inum 
3bcc			 
3bcc					NEXTW 
3bcc c3 37 24			jp macro_next 
3bcf				endm 
# End of macro NEXTW
3bcf			 
3bcf			; float maths 
3bcf			 
3bcf				if FORTH_ENABLE_FLOATMATH 
3bcf					jr .neg_done 
3bcf			 
3bcf				endif 
3bcf					 
3bcf			 
3bcf			.neg_inum: 
3bcf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bcf cd 4b 22			call macro_dsp_valuehl 
3bd2				endm 
# End of macro FORTH_DSP_VALUEHL
3bd2			 
3bd2 e5					push hl 
3bd3			 
3bd3					; destroy value TOS 
3bd3			 
3bd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bd3 cd 03 23			call macro_forth_dsp_pop 
3bd6				endm 
# End of macro FORTH_DSP_POP
3bd6			 
3bd6			 
3bd6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bd6 cd 4b 22			call macro_dsp_valuehl 
3bd9				endm 
# End of macro FORTH_DSP_VALUEHL
3bd9			 
3bd9					; one value on hl get other one back 
3bd9			 
3bd9 d1					pop de 
3bda			 
3bda					; do the sub 
3bda			;		ex de, hl 
3bda			 
3bda ed 52				sbc hl,de 
3bdc			 
3bdc					; save it 
3bdc			 
3bdc			;		push hl	 
3bdc			 
3bdc					; 
3bdc			 
3bdc					; destroy value TOS 
3bdc			 
3bdc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bdc cd 03 23			call macro_forth_dsp_pop 
3bdf				endm 
# End of macro FORTH_DSP_POP
3bdf			 
3bdf					; TODO push value back onto stack for another op etc 
3bdf			 
3bdf			;		pop hl 
3bdf			 
3bdf cd 46 20				call forth_push_numhl 
3be2			.neg_done: 
3be2			 
3be2					NEXTW 
3be2 c3 37 24			jp macro_next 
3be5				endm 
# End of macro NEXTW
3be5			.DIV: 
3be5				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3be5 18				db WORD_SYS_CORE+4             
3be6 32 3c			dw .MUL            
3be8 02				db 1 + 1 
3be9 .. 00			db "/",0              
3beb				endm 
# End of macro CWHEAD
3beb			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3beb					if DEBUG_FORTH_WORDS_KEY 
3beb						DMARK "DIV" 
3beb f5				push af  
3bec 3a 00 3c			ld a, (.dmark)  
3bef 32 a0 fd			ld (debug_mark),a  
3bf2 3a 01 3c			ld a, (.dmark+1)  
3bf5 32 a1 fd			ld (debug_mark+1),a  
3bf8 3a 02 3c			ld a, (.dmark+2)  
3bfb 32 a2 fd			ld (debug_mark+2),a  
3bfe 18 03			jr .pastdmark  
3c00 ..			.dmark: db "DIV"  
3c03 f1			.pastdmark: pop af  
3c04			endm  
# End of macro DMARK
3c04						CALLMONITOR 
3c04 cd aa fd			call debug_vector  
3c07				endm  
# End of macro CALLMONITOR
3c07					endif 
3c07				; TODO add floating point number detection 
3c07					; v5 FORTH_DSP_VALUE 
3c07					FORTH_DSP 
3c07 cd 11 22			call macro_forth_dsp 
3c0a				endm 
# End of macro FORTH_DSP
3c0a 7e					ld a,(hl)	; get type of value on TOS 
3c0b fe 02				cp DS_TYPE_INUM  
3c0d 28 03				jr z, .div_inum 
3c0f			 
3c0f				if FORTH_ENABLE_FLOATMATH 
3c0f					jr .div_done 
3c0f			 
3c0f				endif 
3c0f					NEXTW 
3c0f c3 37 24			jp macro_next 
3c12				endm 
# End of macro NEXTW
3c12			.div_inum: 
3c12			 
3c12					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c12 cd 4b 22			call macro_dsp_valuehl 
3c15				endm 
# End of macro FORTH_DSP_VALUEHL
3c15			 
3c15 e5					push hl    ; to go to bc 
3c16			 
3c16					; destroy value TOS 
3c16			 
3c16					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c16 cd 03 23			call macro_forth_dsp_pop 
3c19				endm 
# End of macro FORTH_DSP_POP
3c19			 
3c19			 
3c19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c19 cd 4b 22			call macro_dsp_valuehl 
3c1c				endm 
# End of macro FORTH_DSP_VALUEHL
3c1c			 
3c1c					; hl to go to de 
3c1c			 
3c1c e5					push hl 
3c1d			 
3c1d c1					pop bc 
3c1e d1					pop de		 
3c1f			 
3c1f			 
3c1f					if DEBUG_FORTH_MATHS 
3c1f						DMARK "DIV" 
3c1f				CALLMONITOR 
3c1f					endif 
3c1f					; one value on hl but move to a get other one back 
3c1f			 
3c1f			        
3c1f cd 3b 0f			call Div16 
3c22			 
3c22			;	push af	 
3c22 e5				push hl 
3c23 c5				push bc 
3c24			 
3c24					if DEBUG_FORTH_MATHS 
3c24						DMARK "DI1" 
3c24				CALLMONITOR 
3c24					endif 
3c24			 
3c24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c24 cd 03 23			call macro_forth_dsp_pop 
3c27				endm 
# End of macro FORTH_DSP_POP
3c27			 
3c27			 
3c27			 
3c27 e1					pop hl    ; result 
3c28			 
3c28 cd 46 20				call forth_push_numhl 
3c2b			 
3c2b e1					pop hl    ; reminder 
3c2c			;		ld h,0 
3c2c			;		ld l,d 
3c2c			 
3c2c cd 46 20				call forth_push_numhl 
3c2f			.div_done: 
3c2f					NEXTW 
3c2f c3 37 24			jp macro_next 
3c32				endm 
# End of macro NEXTW
3c32			.MUL: 
3c32				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3c32 19				db WORD_SYS_CORE+5             
3c33 77 3c			dw .MIN            
3c35 02				db 1 + 1 
3c36 .. 00			db "*",0              
3c38				endm 
# End of macro CWHEAD
3c38			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3c38				; TODO add floating point number detection 
3c38					if DEBUG_FORTH_WORDS_KEY 
3c38						DMARK "MUL" 
3c38 f5				push af  
3c39 3a 4d 3c			ld a, (.dmark)  
3c3c 32 a0 fd			ld (debug_mark),a  
3c3f 3a 4e 3c			ld a, (.dmark+1)  
3c42 32 a1 fd			ld (debug_mark+1),a  
3c45 3a 4f 3c			ld a, (.dmark+2)  
3c48 32 a2 fd			ld (debug_mark+2),a  
3c4b 18 03			jr .pastdmark  
3c4d ..			.dmark: db "MUL"  
3c50 f1			.pastdmark: pop af  
3c51			endm  
# End of macro DMARK
3c51						CALLMONITOR 
3c51 cd aa fd			call debug_vector  
3c54				endm  
# End of macro CALLMONITOR
3c54					endif 
3c54					FORTH_DSP 
3c54 cd 11 22			call macro_forth_dsp 
3c57				endm 
# End of macro FORTH_DSP
3c57					; v5 FORTH_DSP_VALUE 
3c57 7e					ld a,(hl)	; get type of value on TOS 
3c58 fe 02				cp DS_TYPE_INUM  
3c5a 28 03				jr z, .mul_inum 
3c5c			 
3c5c				if FORTH_ENABLE_FLOATMATH 
3c5c					jr .mul_done 
3c5c			 
3c5c				endif 
3c5c			 
3c5c					NEXTW 
3c5c c3 37 24			jp macro_next 
3c5f				endm 
# End of macro NEXTW
3c5f			.mul_inum:	 
3c5f			 
3c5f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c5f cd 4b 22			call macro_dsp_valuehl 
3c62				endm 
# End of macro FORTH_DSP_VALUEHL
3c62			 
3c62 e5					push hl 
3c63			 
3c63					; destroy value TOS 
3c63			 
3c63					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c63 cd 03 23			call macro_forth_dsp_pop 
3c66				endm 
# End of macro FORTH_DSP_POP
3c66			 
3c66			 
3c66					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c66 cd 4b 22			call macro_dsp_valuehl 
3c69				endm 
# End of macro FORTH_DSP_VALUEHL
3c69			 
3c69					; one value on hl but move to a get other one back 
3c69			 
3c69 7d					ld a, l 
3c6a			 
3c6a d1					pop de 
3c6b			 
3c6b					; do the mull 
3c6b			;		ex de, hl 
3c6b			 
3c6b cd 61 0f				call Mult16 
3c6e					; save it 
3c6e			 
3c6e			;		push hl	 
3c6e			 
3c6e					; 
3c6e			 
3c6e					; destroy value TOS 
3c6e			 
3c6e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c6e cd 03 23			call macro_forth_dsp_pop 
3c71				endm 
# End of macro FORTH_DSP_POP
3c71			 
3c71					; TODO push value back onto stack for another op etc 
3c71			 
3c71			;		pop hl 
3c71			 
3c71 cd 46 20				call forth_push_numhl 
3c74			 
3c74			.mul_done: 
3c74					NEXTW 
3c74 c3 37 24			jp macro_next 
3c77				endm 
# End of macro NEXTW
3c77			 
3c77			 
3c77			 
3c77			 
3c77			.MIN: 
3c77				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3c77 49				db WORD_SYS_CORE+53             
3c78 f8 3c			dw .MAX            
3c7a 04				db 3 + 1 
3c7b .. 00			db "MIN",0              
3c7f				endm 
# End of macro CWHEAD
3c7f			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3c7f					if DEBUG_FORTH_WORDS_KEY 
3c7f						DMARK "MIN" 
3c7f f5				push af  
3c80 3a 94 3c			ld a, (.dmark)  
3c83 32 a0 fd			ld (debug_mark),a  
3c86 3a 95 3c			ld a, (.dmark+1)  
3c89 32 a1 fd			ld (debug_mark+1),a  
3c8c 3a 96 3c			ld a, (.dmark+2)  
3c8f 32 a2 fd			ld (debug_mark+2),a  
3c92 18 03			jr .pastdmark  
3c94 ..			.dmark: db "MIN"  
3c97 f1			.pastdmark: pop af  
3c98			endm  
# End of macro DMARK
3c98						CALLMONITOR 
3c98 cd aa fd			call debug_vector  
3c9b				endm  
# End of macro CALLMONITOR
3c9b					endif 
3c9b					; get u2 
3c9b			 
3c9b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c9b cd 4b 22			call macro_dsp_valuehl 
3c9e				endm 
# End of macro FORTH_DSP_VALUEHL
3c9e			 
3c9e e5					push hl   ; u2 
3c9f			 
3c9f					; destroy value TOS 
3c9f			 
3c9f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c9f cd 03 23			call macro_forth_dsp_pop 
3ca2				endm 
# End of macro FORTH_DSP_POP
3ca2			 
3ca2					; get u1 
3ca2			 
3ca2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ca2 cd 4b 22			call macro_dsp_valuehl 
3ca5				endm 
# End of macro FORTH_DSP_VALUEHL
3ca5			 
3ca5 e5					push hl  ; u1 
3ca6			 
3ca6					; destroy value TOS 
3ca6			 
3ca6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ca6 cd 03 23			call macro_forth_dsp_pop 
3ca9				endm 
# End of macro FORTH_DSP_POP
3ca9			 
3ca9 b7			 or a      ;clear carry flag 
3caa e1			  pop hl    ; u1 
3cab d1			  pop de    ; u2 
3cac e5				push hl   ; saved in case hl is lowest 
3cad ed 52		  sbc hl,de 
3caf 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3cb1			 
3cb1 e1				pop hl 
3cb2					if DEBUG_FORTH_WORDS 
3cb2						DMARK "MIN" 
3cb2 f5				push af  
3cb3 3a c7 3c			ld a, (.dmark)  
3cb6 32 a0 fd			ld (debug_mark),a  
3cb9 3a c8 3c			ld a, (.dmark+1)  
3cbc 32 a1 fd			ld (debug_mark+1),a  
3cbf 3a c9 3c			ld a, (.dmark+2)  
3cc2 32 a2 fd			ld (debug_mark+2),a  
3cc5 18 03			jr .pastdmark  
3cc7 ..			.dmark: db "MIN"  
3cca f1			.pastdmark: pop af  
3ccb			endm  
# End of macro DMARK
3ccb						CALLMONITOR 
3ccb cd aa fd			call debug_vector  
3cce				endm  
# End of macro CALLMONITOR
3cce					endif 
3cce cd 46 20				call forth_push_numhl 
3cd1			 
3cd1				       NEXTW 
3cd1 c3 37 24			jp macro_next 
3cd4				endm 
# End of macro NEXTW
3cd4			 
3cd4			.mincont:  
3cd4 c1				pop bc   ; tidy up 
3cd5 eb				ex de , hl  
3cd6					if DEBUG_FORTH_WORDS 
3cd6						DMARK "MI1" 
3cd6 f5				push af  
3cd7 3a eb 3c			ld a, (.dmark)  
3cda 32 a0 fd			ld (debug_mark),a  
3cdd 3a ec 3c			ld a, (.dmark+1)  
3ce0 32 a1 fd			ld (debug_mark+1),a  
3ce3 3a ed 3c			ld a, (.dmark+2)  
3ce6 32 a2 fd			ld (debug_mark+2),a  
3ce9 18 03			jr .pastdmark  
3ceb ..			.dmark: db "MI1"  
3cee f1			.pastdmark: pop af  
3cef			endm  
# End of macro DMARK
3cef						CALLMONITOR 
3cef cd aa fd			call debug_vector  
3cf2				endm  
# End of macro CALLMONITOR
3cf2					endif 
3cf2 cd 46 20				call forth_push_numhl 
3cf5			 
3cf5				       NEXTW 
3cf5 c3 37 24			jp macro_next 
3cf8				endm 
# End of macro NEXTW
3cf8			.MAX: 
3cf8				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3cf8 4a				db WORD_SYS_CORE+54             
3cf9 79 3d			dw .RND16            
3cfb 04				db 3 + 1 
3cfc .. 00			db "MAX",0              
3d00				endm 
# End of macro CWHEAD
3d00			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3d00					if DEBUG_FORTH_WORDS_KEY 
3d00						DMARK "MAX" 
3d00 f5				push af  
3d01 3a 15 3d			ld a, (.dmark)  
3d04 32 a0 fd			ld (debug_mark),a  
3d07 3a 16 3d			ld a, (.dmark+1)  
3d0a 32 a1 fd			ld (debug_mark+1),a  
3d0d 3a 17 3d			ld a, (.dmark+2)  
3d10 32 a2 fd			ld (debug_mark+2),a  
3d13 18 03			jr .pastdmark  
3d15 ..			.dmark: db "MAX"  
3d18 f1			.pastdmark: pop af  
3d19			endm  
# End of macro DMARK
3d19						CALLMONITOR 
3d19 cd aa fd			call debug_vector  
3d1c				endm  
# End of macro CALLMONITOR
3d1c					endif 
3d1c					; get u2 
3d1c			 
3d1c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d1c cd 4b 22			call macro_dsp_valuehl 
3d1f				endm 
# End of macro FORTH_DSP_VALUEHL
3d1f			 
3d1f e5					push hl   ; u2 
3d20			 
3d20					; destroy value TOS 
3d20			 
3d20					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d20 cd 03 23			call macro_forth_dsp_pop 
3d23				endm 
# End of macro FORTH_DSP_POP
3d23			 
3d23					; get u1 
3d23			 
3d23					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d23 cd 4b 22			call macro_dsp_valuehl 
3d26				endm 
# End of macro FORTH_DSP_VALUEHL
3d26			 
3d26 e5					push hl  ; u1 
3d27			 
3d27					; destroy value TOS 
3d27			 
3d27					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d27 cd 03 23			call macro_forth_dsp_pop 
3d2a				endm 
# End of macro FORTH_DSP_POP
3d2a			 
3d2a b7			 or a      ;clear carry flag 
3d2b e1			  pop hl    ; u1 
3d2c d1			  pop de    ; u2 
3d2d e5				push hl   ; saved in case hl is lowest 
3d2e ed 52		  sbc hl,de 
3d30 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3d32			 
3d32 e1				pop hl 
3d33					if DEBUG_FORTH_WORDS 
3d33						DMARK "MAX" 
3d33 f5				push af  
3d34 3a 48 3d			ld a, (.dmark)  
3d37 32 a0 fd			ld (debug_mark),a  
3d3a 3a 49 3d			ld a, (.dmark+1)  
3d3d 32 a1 fd			ld (debug_mark+1),a  
3d40 3a 4a 3d			ld a, (.dmark+2)  
3d43 32 a2 fd			ld (debug_mark+2),a  
3d46 18 03			jr .pastdmark  
3d48 ..			.dmark: db "MAX"  
3d4b f1			.pastdmark: pop af  
3d4c			endm  
# End of macro DMARK
3d4c						CALLMONITOR 
3d4c cd aa fd			call debug_vector  
3d4f				endm  
# End of macro CALLMONITOR
3d4f					endif 
3d4f cd 46 20				call forth_push_numhl 
3d52			 
3d52				       NEXTW 
3d52 c3 37 24			jp macro_next 
3d55				endm 
# End of macro NEXTW
3d55			 
3d55			.maxcont:  
3d55 c1				pop bc   ; tidy up 
3d56 eb				ex de , hl  
3d57					if DEBUG_FORTH_WORDS 
3d57						DMARK "MA1" 
3d57 f5				push af  
3d58 3a 6c 3d			ld a, (.dmark)  
3d5b 32 a0 fd			ld (debug_mark),a  
3d5e 3a 6d 3d			ld a, (.dmark+1)  
3d61 32 a1 fd			ld (debug_mark+1),a  
3d64 3a 6e 3d			ld a, (.dmark+2)  
3d67 32 a2 fd			ld (debug_mark+2),a  
3d6a 18 03			jr .pastdmark  
3d6c ..			.dmark: db "MA1"  
3d6f f1			.pastdmark: pop af  
3d70			endm  
# End of macro DMARK
3d70						CALLMONITOR 
3d70 cd aa fd			call debug_vector  
3d73				endm  
# End of macro CALLMONITOR
3d73					endif 
3d73 cd 46 20				call forth_push_numhl 
3d76				       NEXTW 
3d76 c3 37 24			jp macro_next 
3d79				endm 
# End of macro NEXTW
3d79			 
3d79			.RND16: 
3d79				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3d79 4e				db WORD_SYS_CORE+58             
3d7a a8 3d			dw .RND8            
3d7c 06				db 5 + 1 
3d7d .. 00			db "RND16",0              
3d83				endm 
# End of macro CWHEAD
3d83			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3d83					if DEBUG_FORTH_WORDS_KEY 
3d83						DMARK "R16" 
3d83 f5				push af  
3d84 3a 98 3d			ld a, (.dmark)  
3d87 32 a0 fd			ld (debug_mark),a  
3d8a 3a 99 3d			ld a, (.dmark+1)  
3d8d 32 a1 fd			ld (debug_mark+1),a  
3d90 3a 9a 3d			ld a, (.dmark+2)  
3d93 32 a2 fd			ld (debug_mark+2),a  
3d96 18 03			jr .pastdmark  
3d98 ..			.dmark: db "R16"  
3d9b f1			.pastdmark: pop af  
3d9c			endm  
# End of macro DMARK
3d9c						CALLMONITOR 
3d9c cd aa fd			call debug_vector  
3d9f				endm  
# End of macro CALLMONITOR
3d9f					endif 
3d9f cd 05 0f				call prng16  
3da2 cd 46 20				call forth_push_numhl 
3da5				       NEXTW 
3da5 c3 37 24			jp macro_next 
3da8				endm 
# End of macro NEXTW
3da8			.RND8: 
3da8				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3da8 60				db WORD_SYS_CORE+76             
3da9 dd 3d			dw .RND            
3dab 05				db 4 + 1 
3dac .. 00			db "RND8",0              
3db1				endm 
# End of macro CWHEAD
3db1			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3db1					if DEBUG_FORTH_WORDS_KEY 
3db1						DMARK "RN8" 
3db1 f5				push af  
3db2 3a c6 3d			ld a, (.dmark)  
3db5 32 a0 fd			ld (debug_mark),a  
3db8 3a c7 3d			ld a, (.dmark+1)  
3dbb 32 a1 fd			ld (debug_mark+1),a  
3dbe 3a c8 3d			ld a, (.dmark+2)  
3dc1 32 a2 fd			ld (debug_mark+2),a  
3dc4 18 03			jr .pastdmark  
3dc6 ..			.dmark: db "RN8"  
3dc9 f1			.pastdmark: pop af  
3dca			endm  
# End of macro DMARK
3dca						CALLMONITOR 
3dca cd aa fd			call debug_vector  
3dcd				endm  
# End of macro CALLMONITOR
3dcd					endif 
3dcd 2a de fa				ld hl,(xrandc) 
3dd0 23					inc hl 
3dd1 cd 1f 0f				call xrnd 
3dd4 6f					ld l,a	 
3dd5 26 00				ld h,0 
3dd7 cd 46 20				call forth_push_numhl 
3dda				       NEXTW 
3dda c3 37 24			jp macro_next 
3ddd				endm 
# End of macro NEXTW
3ddd			.RND: 
3ddd				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3ddd 60				db WORD_SYS_CORE+76             
3dde e3 3e			dw .ENDMATHS            
3de0 04				db 3 + 1 
3de1 .. 00			db "RND",0              
3de5				endm 
# End of macro CWHEAD
3de5			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3de5			 
3de5					if DEBUG_FORTH_WORDS_KEY 
3de5						DMARK "RND" 
3de5 f5				push af  
3de6 3a fa 3d			ld a, (.dmark)  
3de9 32 a0 fd			ld (debug_mark),a  
3dec 3a fb 3d			ld a, (.dmark+1)  
3def 32 a1 fd			ld (debug_mark+1),a  
3df2 3a fc 3d			ld a, (.dmark+2)  
3df5 32 a2 fd			ld (debug_mark+2),a  
3df8 18 03			jr .pastdmark  
3dfa ..			.dmark: db "RND"  
3dfd f1			.pastdmark: pop af  
3dfe			endm  
# End of macro DMARK
3dfe						CALLMONITOR 
3dfe cd aa fd			call debug_vector  
3e01				endm  
# End of macro CALLMONITOR
3e01					endif 
3e01					 
3e01					FORTH_DSP_VALUEHL    ; upper range 
3e01 cd 4b 22			call macro_dsp_valuehl 
3e04				endm 
# End of macro FORTH_DSP_VALUEHL
3e04			 
3e04 22 e2 fa				ld (LFSRSeed), hl	 
3e07			 
3e07					if DEBUG_FORTH_WORDS 
3e07						DMARK "RN1" 
3e07 f5				push af  
3e08 3a 1c 3e			ld a, (.dmark)  
3e0b 32 a0 fd			ld (debug_mark),a  
3e0e 3a 1d 3e			ld a, (.dmark+1)  
3e11 32 a1 fd			ld (debug_mark+1),a  
3e14 3a 1e 3e			ld a, (.dmark+2)  
3e17 32 a2 fd			ld (debug_mark+2),a  
3e1a 18 03			jr .pastdmark  
3e1c ..			.dmark: db "RN1"  
3e1f f1			.pastdmark: pop af  
3e20			endm  
# End of macro DMARK
3e20						CALLMONITOR 
3e20 cd aa fd			call debug_vector  
3e23				endm  
# End of macro CALLMONITOR
3e23					endif 
3e23					FORTH_DSP_POP 
3e23 cd 03 23			call macro_forth_dsp_pop 
3e26				endm 
# End of macro FORTH_DSP_POP
3e26			 
3e26					FORTH_DSP_VALUEHL    ; low range 
3e26 cd 4b 22			call macro_dsp_valuehl 
3e29				endm 
# End of macro FORTH_DSP_VALUEHL
3e29			 
3e29					if DEBUG_FORTH_WORDS 
3e29						DMARK "RN2" 
3e29 f5				push af  
3e2a 3a 3e 3e			ld a, (.dmark)  
3e2d 32 a0 fd			ld (debug_mark),a  
3e30 3a 3f 3e			ld a, (.dmark+1)  
3e33 32 a1 fd			ld (debug_mark+1),a  
3e36 3a 40 3e			ld a, (.dmark+2)  
3e39 32 a2 fd			ld (debug_mark+2),a  
3e3c 18 03			jr .pastdmark  
3e3e ..			.dmark: db "RN2"  
3e41 f1			.pastdmark: pop af  
3e42			endm  
# End of macro DMARK
3e42						CALLMONITOR 
3e42 cd aa fd			call debug_vector  
3e45				endm  
# End of macro CALLMONITOR
3e45					endif 
3e45 22 e4 fa				ld (LFSRSeed+2), hl 
3e48			 
3e48					FORTH_DSP_POP 
3e48 cd 03 23			call macro_forth_dsp_pop 
3e4b				endm 
# End of macro FORTH_DSP_POP
3e4b			 
3e4b e5					push hl 
3e4c			 
3e4c e1			.inrange:	pop hl 
3e4d cd 05 0f				call prng16  
3e50					if DEBUG_FORTH_WORDS 
3e50						DMARK "RN3" 
3e50 f5				push af  
3e51 3a 65 3e			ld a, (.dmark)  
3e54 32 a0 fd			ld (debug_mark),a  
3e57 3a 66 3e			ld a, (.dmark+1)  
3e5a 32 a1 fd			ld (debug_mark+1),a  
3e5d 3a 67 3e			ld a, (.dmark+2)  
3e60 32 a2 fd			ld (debug_mark+2),a  
3e63 18 03			jr .pastdmark  
3e65 ..			.dmark: db "RN3"  
3e68 f1			.pastdmark: pop af  
3e69			endm  
# End of macro DMARK
3e69						CALLMONITOR 
3e69 cd aa fd			call debug_vector  
3e6c				endm  
# End of macro CALLMONITOR
3e6c					endif 
3e6c					 
3e6c					; if the range is 8bit knock out the high byte 
3e6c			 
3e6c ed 5b e2 fa			ld de, (LFSRSeed)     ; check high level 
3e70			 
3e70 3e 00				ld a, 0 
3e72 ba					cp d  
3e73 20 1e				jr nz, .hirange 
3e75 26 00				ld h, 0   ; knock it down to 8bit 
3e77			 
3e77					if DEBUG_FORTH_WORDS 
3e77						DMARK "RNk" 
3e77 f5				push af  
3e78 3a 8c 3e			ld a, (.dmark)  
3e7b 32 a0 fd			ld (debug_mark),a  
3e7e 3a 8d 3e			ld a, (.dmark+1)  
3e81 32 a1 fd			ld (debug_mark+1),a  
3e84 3a 8e 3e			ld a, (.dmark+2)  
3e87 32 a2 fd			ld (debug_mark+2),a  
3e8a 18 03			jr .pastdmark  
3e8c ..			.dmark: db "RNk"  
3e8f f1			.pastdmark: pop af  
3e90			endm  
# End of macro DMARK
3e90						CALLMONITOR 
3e90 cd aa fd			call debug_vector  
3e93				endm  
# End of macro CALLMONITOR
3e93					endif 
3e93			.hirange:   
3e93 e5					push hl  
3e94 b7					or a  
3e95 ed 52		                sbc hl, de 
3e97			 
3e97					;call cmp16 
3e97			 
3e97 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3e99 e1					pop hl 
3e9a e5					push hl 
3e9b			 
3e9b					if DEBUG_FORTH_WORDS 
3e9b						DMARK "RN4" 
3e9b f5				push af  
3e9c 3a b0 3e			ld a, (.dmark)  
3e9f 32 a0 fd			ld (debug_mark),a  
3ea2 3a b1 3e			ld a, (.dmark+1)  
3ea5 32 a1 fd			ld (debug_mark+1),a  
3ea8 3a b2 3e			ld a, (.dmark+2)  
3eab 32 a2 fd			ld (debug_mark+2),a  
3eae 18 03			jr .pastdmark  
3eb0 ..			.dmark: db "RN4"  
3eb3 f1			.pastdmark: pop af  
3eb4			endm  
# End of macro DMARK
3eb4						CALLMONITOR 
3eb4 cd aa fd			call debug_vector  
3eb7				endm  
# End of macro CALLMONITOR
3eb7					endif 
3eb7 ed 5b e4 fa			ld de, (LFSRSeed+2)   ; check low range 
3ebb					;call cmp16 
3ebb				 
3ebb b7					or a  
3ebc ed 52		                sbc hl, de 
3ebe 38 8c				jr c, .inrange 
3ec0			 
3ec0 e1					pop hl 
3ec1					 
3ec1					if DEBUG_FORTH_WORDS 
3ec1						DMARK "RNd" 
3ec1 f5				push af  
3ec2 3a d6 3e			ld a, (.dmark)  
3ec5 32 a0 fd			ld (debug_mark),a  
3ec8 3a d7 3e			ld a, (.dmark+1)  
3ecb 32 a1 fd			ld (debug_mark+1),a  
3ece 3a d8 3e			ld a, (.dmark+2)  
3ed1 32 a2 fd			ld (debug_mark+2),a  
3ed4 18 03			jr .pastdmark  
3ed6 ..			.dmark: db "RNd"  
3ed9 f1			.pastdmark: pop af  
3eda			endm  
# End of macro DMARK
3eda						CALLMONITOR 
3eda cd aa fd			call debug_vector  
3edd				endm  
# End of macro CALLMONITOR
3edd					endif 
3edd			 
3edd			 
3edd cd 46 20				call forth_push_numhl 
3ee0				       NEXTW 
3ee0 c3 37 24			jp macro_next 
3ee3				endm 
# End of macro NEXTW
3ee3			 
3ee3			.ENDMATHS: 
3ee3			 
3ee3			; eof 
3ee3			 
# End of file forth_words_maths.asm
3ee3			include "forth_words_display.asm" 
3ee3			 
3ee3			; | ## Display Words 
3ee3			 
3ee3			.ACT: 
3ee3			 
3ee3				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3ee3 62				db WORD_SYS_CORE+78             
3ee4 2f 3f			dw .INFO            
3ee6 07				db 6 + 1 
3ee7 .. 00			db "ACTIVE",0              
3eee				endm 
# End of macro CWHEAD
3eee			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3eee			;  
3eee			; | | To display a pulsing activity indicator in a processing loop do this... 
3eee			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3eee			 
3eee					if DEBUG_FORTH_WORDS_KEY 
3eee						DMARK "ACT" 
3eee f5				push af  
3eef 3a 03 3f			ld a, (.dmark)  
3ef2 32 a0 fd			ld (debug_mark),a  
3ef5 3a 04 3f			ld a, (.dmark+1)  
3ef8 32 a1 fd			ld (debug_mark+1),a  
3efb 3a 05 3f			ld a, (.dmark+2)  
3efe 32 a2 fd			ld (debug_mark+2),a  
3f01 18 03			jr .pastdmark  
3f03 ..			.dmark: db "ACT"  
3f06 f1			.pastdmark: pop af  
3f07			endm  
# End of macro DMARK
3f07						CALLMONITOR 
3f07 cd aa fd			call debug_vector  
3f0a				endm  
# End of macro CALLMONITOR
3f0a					endif 
3f0a cd 01 0d				call active 
3f0d					if DEBUG_FORTH_WORDS 
3f0d						DMARK "ACp" 
3f0d f5				push af  
3f0e 3a 22 3f			ld a, (.dmark)  
3f11 32 a0 fd			ld (debug_mark),a  
3f14 3a 23 3f			ld a, (.dmark+1)  
3f17 32 a1 fd			ld (debug_mark+1),a  
3f1a 3a 24 3f			ld a, (.dmark+2)  
3f1d 32 a2 fd			ld (debug_mark+2),a  
3f20 18 03			jr .pastdmark  
3f22 ..			.dmark: db "ACp"  
3f25 f1			.pastdmark: pop af  
3f26			endm  
# End of macro DMARK
3f26						CALLMONITOR 
3f26 cd aa fd			call debug_vector  
3f29				endm  
# End of macro CALLMONITOR
3f29					endif 
3f29 cd b4 20				call forth_push_str 
3f2c			 
3f2c					NEXTW 
3f2c c3 37 24			jp macro_next 
3f2f				endm 
# End of macro NEXTW
3f2f			.INFO: 
3f2f			 
3f2f				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3f2f 62				db WORD_SYS_CORE+78             
3f30 4c 3f			dw .ATP            
3f32 05				db 4 + 1 
3f33 .. 00			db "INFO",0              
3f38				endm 
# End of macro CWHEAD
3f38			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3f38					FORTH_DSP_VALUEHL 
3f38 cd 4b 22			call macro_dsp_valuehl 
3f3b				endm 
# End of macro FORTH_DSP_VALUEHL
3f3b			 
3f3b					FORTH_DSP_POP 
3f3b cd 03 23			call macro_forth_dsp_pop 
3f3e				endm 
# End of macro FORTH_DSP_POP
3f3e			 
3f3e e5					push hl 
3f3f			 
3f3f					FORTH_DSP_VALUEHL 
3f3f cd 4b 22			call macro_dsp_valuehl 
3f42				endm 
# End of macro FORTH_DSP_VALUEHL
3f42			 
3f42					FORTH_DSP_POP 
3f42 cd 03 23			call macro_forth_dsp_pop 
3f45				endm 
# End of macro FORTH_DSP_POP
3f45			 
3f45 d1					pop de 
3f46			 
3f46 cd 3b 0d				call info_panel 
3f49			 
3f49			 
3f49					NEXTW 
3f49 c3 37 24			jp macro_next 
3f4c				endm 
# End of macro NEXTW
3f4c			.ATP: 
3f4c				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3f4c 62				db WORD_SYS_CORE+78             
3f4d c3 3f			dw .FB            
3f4f 04				db 3 + 1 
3f50 .. 00			db "AT?",0              
3f54				endm 
# End of macro CWHEAD
3f54			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3f54					if DEBUG_FORTH_WORDS_KEY 
3f54						DMARK "AT?" 
3f54 f5				push af  
3f55 3a 69 3f			ld a, (.dmark)  
3f58 32 a0 fd			ld (debug_mark),a  
3f5b 3a 6a 3f			ld a, (.dmark+1)  
3f5e 32 a1 fd			ld (debug_mark+1),a  
3f61 3a 6b 3f			ld a, (.dmark+2)  
3f64 32 a2 fd			ld (debug_mark+2),a  
3f67 18 03			jr .pastdmark  
3f69 ..			.dmark: db "AT?"  
3f6c f1			.pastdmark: pop af  
3f6d			endm  
# End of macro DMARK
3f6d						CALLMONITOR 
3f6d cd aa fd			call debug_vector  
3f70				endm  
# End of macro CALLMONITOR
3f70					endif 
3f70 3a 93 f9				ld a, (f_cursor_ptr) 
3f73			 
3f73			if DEBUG_FORTH_WORDS 
3f73				DMARK "AT?" 
3f73 f5				push af  
3f74 3a 88 3f			ld a, (.dmark)  
3f77 32 a0 fd			ld (debug_mark),a  
3f7a 3a 89 3f			ld a, (.dmark+1)  
3f7d 32 a1 fd			ld (debug_mark+1),a  
3f80 3a 8a 3f			ld a, (.dmark+2)  
3f83 32 a2 fd			ld (debug_mark+2),a  
3f86 18 03			jr .pastdmark  
3f88 ..			.dmark: db "AT?"  
3f8b f1			.pastdmark: pop af  
3f8c			endm  
# End of macro DMARK
3f8c				CALLMONITOR 
3f8c cd aa fd			call debug_vector  
3f8f				endm  
# End of macro CALLMONITOR
3f8f			endif	 
3f8f					; count the number of rows 
3f8f			 
3f8f 06 00				ld b, 0 
3f91 4f			.atpr:		ld c, a    ; save in case we go below zero 
3f92 d6 28				sub display_cols 
3f94 f2 9a 3f				jp p, .atprunder 
3f97 04					inc b 
3f98 18 f7				jr .atpr 
3f9a			.atprunder:	 
3f9a			if DEBUG_FORTH_WORDS 
3f9a				DMARK "A?2" 
3f9a f5				push af  
3f9b 3a af 3f			ld a, (.dmark)  
3f9e 32 a0 fd			ld (debug_mark),a  
3fa1 3a b0 3f			ld a, (.dmark+1)  
3fa4 32 a1 fd			ld (debug_mark+1),a  
3fa7 3a b1 3f			ld a, (.dmark+2)  
3faa 32 a2 fd			ld (debug_mark+2),a  
3fad 18 03			jr .pastdmark  
3faf ..			.dmark: db "A?2"  
3fb2 f1			.pastdmark: pop af  
3fb3			endm  
# End of macro DMARK
3fb3				CALLMONITOR 
3fb3 cd aa fd			call debug_vector  
3fb6				endm  
# End of macro CALLMONITOR
3fb6			endif	 
3fb6 26 00				ld h, 0 
3fb8 69					ld l, c 
3fb9 cd 46 20				call forth_push_numhl 
3fbc 68					ld l, b  
3fbd cd 46 20				call forth_push_numhl 
3fc0			 
3fc0			 
3fc0				NEXTW 
3fc0 c3 37 24			jp macro_next 
3fc3				endm 
# End of macro NEXTW
3fc3			 
3fc3			.FB: 
3fc3				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3fc3 1b				db WORD_SYS_CORE+7             
3fc4 11 40			dw .EMIT            
3fc6 03				db 2 + 1 
3fc7 .. 00			db "FB",0              
3fca				endm 
# End of macro CWHEAD
3fca			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3fca			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3fca			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3fca			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3fca					if DEBUG_FORTH_WORDS_KEY 
3fca						DMARK "FB." 
3fca f5				push af  
3fcb 3a df 3f			ld a, (.dmark)  
3fce 32 a0 fd			ld (debug_mark),a  
3fd1 3a e0 3f			ld a, (.dmark+1)  
3fd4 32 a1 fd			ld (debug_mark+1),a  
3fd7 3a e1 3f			ld a, (.dmark+2)  
3fda 32 a2 fd			ld (debug_mark+2),a  
3fdd 18 03			jr .pastdmark  
3fdf ..			.dmark: db "FB."  
3fe2 f1			.pastdmark: pop af  
3fe3			endm  
# End of macro DMARK
3fe3						CALLMONITOR 
3fe3 cd aa fd			call debug_vector  
3fe6				endm  
# End of macro CALLMONITOR
3fe6					endif 
3fe6			 
3fe6					FORTH_DSP_VALUEHL 
3fe6 cd 4b 22			call macro_dsp_valuehl 
3fe9				endm 
# End of macro FORTH_DSP_VALUEHL
3fe9			 
3fe9 7d					ld a, l 
3fea fe 01				cp 1 
3fec 20 05				jr nz, .fbn1 
3fee 21 45 fc				ld hl, display_fb1 
3ff1 18 15				jr .fbset 
3ff3 fe 02		.fbn1:		cp 2 
3ff5 20 05				jr nz, .fbn2 
3ff7 21 03 fb				ld hl, display_fb2 
3ffa 18 0c				jr .fbset 
3ffc fe 03		.fbn2:		cp 3 
3ffe 20 05				jr nz, .fbn3 
4000 21 a4 fb				ld hl, display_fb3 
4003 18 03				jr .fbset 
4005			.fbn3:		 ; if invalid number select first 
4005 21 45 fc				ld hl, display_fb1 
4008 22 01 fb		.fbset:		ld (display_fb_active), hl 
400b			 
400b					FORTH_DSP_POP 
400b cd 03 23			call macro_forth_dsp_pop 
400e				endm 
# End of macro FORTH_DSP_POP
400e			 
400e					NEXTW 
400e c3 37 24			jp macro_next 
4011				endm 
# End of macro NEXTW
4011			 
4011			 
4011			.EMIT: 
4011				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
4011 1b				db WORD_SYS_CORE+7             
4012 62 40			dw .DOTH            
4014 05				db 4 + 1 
4015 .. 00			db "EMIT",0              
401a				endm 
# End of macro CWHEAD
401a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
401a					; get value off TOS and display it 
401a			 
401a					if DEBUG_FORTH_WORDS_KEY 
401a						DMARK "EMT" 
401a f5				push af  
401b 3a 2f 40			ld a, (.dmark)  
401e 32 a0 fd			ld (debug_mark),a  
4021 3a 30 40			ld a, (.dmark+1)  
4024 32 a1 fd			ld (debug_mark+1),a  
4027 3a 31 40			ld a, (.dmark+2)  
402a 32 a2 fd			ld (debug_mark+2),a  
402d 18 03			jr .pastdmark  
402f ..			.dmark: db "EMT"  
4032 f1			.pastdmark: pop af  
4033			endm  
# End of macro DMARK
4033						CALLMONITOR 
4033 cd aa fd			call debug_vector  
4036				endm  
# End of macro CALLMONITOR
4036					endif 
4036			 
4036					FORTH_DSP_VALUEHL 
4036 cd 4b 22			call macro_dsp_valuehl 
4039				endm 
# End of macro FORTH_DSP_VALUEHL
4039			 
4039 7d					ld a,l 
403a			 
403a					; TODO write to display 
403a			 
403a 32 f4 f2				ld (os_input), a 
403d 3e 00				ld a, 0 
403f 32 f5 f2				ld (os_input+1), a 
4042					 
4042 3a 93 f9				ld a, (f_cursor_ptr) 
4045 11 f4 f2				ld de, os_input 
4048 cd bd 0d				call str_at_display 
404b			 
404b			 
404b 3a 71 f9				ld a,(cli_autodisplay) 
404e fe 00				cp 0 
4050 28 03				jr z, .enoupdate 
4052 cd cd 0d						call update_display 
4055					.enoupdate: 
4055			 
4055 3a 93 f9				ld a, (f_cursor_ptr) 
4058 3c					inc a 
4059 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
405c			 
405c			 
405c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
405c cd 03 23			call macro_forth_dsp_pop 
405f				endm 
# End of macro FORTH_DSP_POP
405f			  
405f			 
405f					NEXTW 
405f c3 37 24			jp macro_next 
4062				endm 
# End of macro NEXTW
4062			.DOTH: 
4062				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
4062 1c				db WORD_SYS_CORE+8             
4063 92 40			dw .DOTF            
4065 03				db 2 + 1 
4066 .. 00			db ".-",0              
4069				endm 
# End of macro CWHEAD
4069			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
4069					; get value off TOS and display it 
4069					if DEBUG_FORTH_WORDS_KEY 
4069						DMARK "DTD" 
4069 f5				push af  
406a 3a 7e 40			ld a, (.dmark)  
406d 32 a0 fd			ld (debug_mark),a  
4070 3a 7f 40			ld a, (.dmark+1)  
4073 32 a1 fd			ld (debug_mark+1),a  
4076 3a 80 40			ld a, (.dmark+2)  
4079 32 a2 fd			ld (debug_mark+2),a  
407c 18 03			jr .pastdmark  
407e ..			.dmark: db "DTD"  
4081 f1			.pastdmark: pop af  
4082			endm  
# End of macro DMARK
4082						CALLMONITOR 
4082 cd aa fd			call debug_vector  
4085				endm  
# End of macro CALLMONITOR
4085					endif 
4085 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
4087 3e 00			ld a, 0 
4089 32 72 f9			ld (cli_mvdot), a 
408c c3 e9 40			jp .dotgo 
408f				NEXTW 
408f c3 37 24			jp macro_next 
4092				endm 
# End of macro NEXTW
4092			.DOTF: 
4092				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4092 1c				db WORD_SYS_CORE+8             
4093 c0 40			dw .DOT            
4095 03				db 2 + 1 
4096 .. 00			db ".>",0              
4099				endm 
# End of macro CWHEAD
4099			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
4099					; get value off TOS and display it 
4099			        ; TODO BUG adds extra spaces 
4099			        ; TODO BUG handle numerics? 
4099					if DEBUG_FORTH_WORDS_KEY 
4099						DMARK "DTC" 
4099 f5				push af  
409a 3a ae 40			ld a, (.dmark)  
409d 32 a0 fd			ld (debug_mark),a  
40a0 3a af 40			ld a, (.dmark+1)  
40a3 32 a1 fd			ld (debug_mark+1),a  
40a6 3a b0 40			ld a, (.dmark+2)  
40a9 32 a2 fd			ld (debug_mark+2),a  
40ac 18 03			jr .pastdmark  
40ae ..			.dmark: db "DTC"  
40b1 f1			.pastdmark: pop af  
40b2			endm  
# End of macro DMARK
40b2						CALLMONITOR 
40b2 cd aa fd			call debug_vector  
40b5				endm  
# End of macro CALLMONITOR
40b5					endif 
40b5 3e 01			ld a, 1 
40b7 32 72 f9			ld (cli_mvdot), a 
40ba c3 e9 40			jp .dotgo 
40bd				NEXTW 
40bd c3 37 24			jp macro_next 
40c0				endm 
# End of macro NEXTW
40c0			 
40c0			.DOT: 
40c0				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
40c0 1c				db WORD_SYS_CORE+8             
40c1 9c 42			dw .CLS            
40c3 02				db 1 + 1 
40c4 .. 00			db ".",0              
40c6				endm 
# End of macro CWHEAD
40c6			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
40c6					; get value off TOS and display it 
40c6			 
40c6					if DEBUG_FORTH_WORDS_KEY 
40c6						DMARK "DOT" 
40c6 f5				push af  
40c7 3a db 40			ld a, (.dmark)  
40ca 32 a0 fd			ld (debug_mark),a  
40cd 3a dc 40			ld a, (.dmark+1)  
40d0 32 a1 fd			ld (debug_mark+1),a  
40d3 3a dd 40			ld a, (.dmark+2)  
40d6 32 a2 fd			ld (debug_mark+2),a  
40d9 18 03			jr .pastdmark  
40db ..			.dmark: db "DOT"  
40de f1			.pastdmark: pop af  
40df			endm  
# End of macro DMARK
40df						CALLMONITOR 
40df cd aa fd			call debug_vector  
40e2				endm  
# End of macro CALLMONITOR
40e2					endif 
40e2 3e 00			ld a, 0 
40e4 32 72 f9			ld (cli_mvdot), a 
40e7 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
40e9				 
40e9			 
40e9			.dotgo: 
40e9			 
40e9			; move up type to on stack for parserv5 
40e9					FORTH_DSP 
40e9 cd 11 22			call macro_forth_dsp 
40ec				endm 
# End of macro FORTH_DSP
40ec				;FORTH_DSP_VALUE  
40ec			 
40ec			if DEBUG_FORTH_DOT 
40ec				DMARK "DOT" 
40ec f5				push af  
40ed 3a 01 41			ld a, (.dmark)  
40f0 32 a0 fd			ld (debug_mark),a  
40f3 3a 02 41			ld a, (.dmark+1)  
40f6 32 a1 fd			ld (debug_mark+1),a  
40f9 3a 03 41			ld a, (.dmark+2)  
40fc 32 a2 fd			ld (debug_mark+2),a  
40ff 18 03			jr .pastdmark  
4101 ..			.dmark: db "DOT"  
4104 f1			.pastdmark: pop af  
4105			endm  
# End of macro DMARK
4105				CALLMONITOR 
4105 cd aa fd			call debug_vector  
4108				endm  
# End of macro CALLMONITOR
4108			endif	 
4108			;		.print: 
4108			 
4108 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4109 23				inc hl   ; position to the actual value 
410a fe 01			cp DS_TYPE_STR 
410c 20 06			jr nz, .dotnum1  
410e			 
410e			; display string 
410e				FORTH_DSP_VALUE  
410e cd 34 22			call macro_forth_dsp_value 
4111				endm 
# End of macro FORTH_DSP_VALUE
4111 eb				ex de,hl 
4112 18 49			jr .dotwrite 
4114			 
4114			.dotnum1: 
4114 fe 02			cp DS_TYPE_INUM 
4116 20 44			jr nz, .dotflot 
4118			 
4118			 
4118			; display number 
4118			 
4118			;	push hl 
4118			;	call clear_display 
4118			;	pop hl 
4118			 
4118 5e				ld e, (hl) 
4119 23				inc hl 
411a 56				ld d, (hl) 
411b 21 f6 f0			ld hl, scratch 
411e			if DEBUG_FORTH_DOT 
411e				DMARK "DT1" 
411e f5				push af  
411f 3a 33 41			ld a, (.dmark)  
4122 32 a0 fd			ld (debug_mark),a  
4125 3a 34 41			ld a, (.dmark+1)  
4128 32 a1 fd			ld (debug_mark+1),a  
412b 3a 35 41			ld a, (.dmark+2)  
412e 32 a2 fd			ld (debug_mark+2),a  
4131 18 03			jr .pastdmark  
4133 ..			.dmark: db "DT1"  
4136 f1			.pastdmark: pop af  
4137			endm  
# End of macro DMARK
4137				CALLMONITOR 
4137 cd aa fd			call debug_vector  
413a				endm  
# End of macro CALLMONITOR
413a			endif	 
413a			 
413a cd f3 12			call uitoa_16 
413d eb				ex de,hl 
413e			 
413e			if DEBUG_FORTH_DOT 
413e				DMARK "DT2" 
413e f5				push af  
413f 3a 53 41			ld a, (.dmark)  
4142 32 a0 fd			ld (debug_mark),a  
4145 3a 54 41			ld a, (.dmark+1)  
4148 32 a1 fd			ld (debug_mark+1),a  
414b 3a 55 41			ld a, (.dmark+2)  
414e 32 a2 fd			ld (debug_mark+2),a  
4151 18 03			jr .pastdmark  
4153 ..			.dmark: db "DT2"  
4156 f1			.pastdmark: pop af  
4157			endm  
# End of macro DMARK
4157				CALLMONITOR 
4157 cd aa fd			call debug_vector  
415a				endm  
# End of macro CALLMONITOR
415a			endif	 
415a			 
415a			;	ld de, os_word_scratch 
415a 18 01			jr .dotwrite 
415c			 
415c 00			.dotflot:   nop 
415d			; TODO print floating point number 
415d			 
415d			.dotwrite:		 
415d			 
415d					; if c is set then set all '-' to spaces 
415d					; need to also take into account .>  
415d			 
415d 3e 01				ld a, 1 
415f b9					cp c 
4160 20 67				jr nz, .nodashswap 
4162			 
4162					; DE has the string to write, working with HL 
4162			 
4162 06 ff				ld b, 255 
4164 d5					push de 
4165 e1					pop hl 
4166			 
4166			if DEBUG_FORTH_DOT 
4166				DMARK "DT-" 
4166 f5				push af  
4167 3a 7b 41			ld a, (.dmark)  
416a 32 a0 fd			ld (debug_mark),a  
416d 3a 7c 41			ld a, (.dmark+1)  
4170 32 a1 fd			ld (debug_mark+1),a  
4173 3a 7d 41			ld a, (.dmark+2)  
4176 32 a2 fd			ld (debug_mark+2),a  
4179 18 03			jr .pastdmark  
417b ..			.dmark: db "DT-"  
417e f1			.pastdmark: pop af  
417f			endm  
# End of macro DMARK
417f				CALLMONITOR 
417f cd aa fd			call debug_vector  
4182				endm  
# End of macro CALLMONITOR
4182			endif	 
4182 7e			.dashscan:	ld a, (hl) 
4183 fe 00				cp 0 
4185 28 42				jr z, .nodashswap 
4187 fe 2d				cp '-' 
4189 20 03				jr nz, .dashskip 
418b 3e 20				ld a, ' ' 
418d 77					ld (hl), a 
418e 23			.dashskip:	inc hl 
418f			if DEBUG_FORTH_DOT 
418f				DMARK "D-2" 
418f f5				push af  
4190 3a a4 41			ld a, (.dmark)  
4193 32 a0 fd			ld (debug_mark),a  
4196 3a a5 41			ld a, (.dmark+1)  
4199 32 a1 fd			ld (debug_mark+1),a  
419c 3a a6 41			ld a, (.dmark+2)  
419f 32 a2 fd			ld (debug_mark+2),a  
41a2 18 03			jr .pastdmark  
41a4 ..			.dmark: db "D-2"  
41a7 f1			.pastdmark: pop af  
41a8			endm  
# End of macro DMARK
41a8				CALLMONITOR 
41a8 cd aa fd			call debug_vector  
41ab				endm  
# End of macro CALLMONITOR
41ab			endif	 
41ab 10 d5				djnz .dashscan 
41ad			 
41ad			if DEBUG_FORTH_DOT 
41ad				DMARK "D-1" 
41ad f5				push af  
41ae 3a c2 41			ld a, (.dmark)  
41b1 32 a0 fd			ld (debug_mark),a  
41b4 3a c3 41			ld a, (.dmark+1)  
41b7 32 a1 fd			ld (debug_mark+1),a  
41ba 3a c4 41			ld a, (.dmark+2)  
41bd 32 a2 fd			ld (debug_mark+2),a  
41c0 18 03			jr .pastdmark  
41c2 ..			.dmark: db "D-1"  
41c5 f1			.pastdmark: pop af  
41c6			endm  
# End of macro DMARK
41c6				CALLMONITOR 
41c6 cd aa fd			call debug_vector  
41c9				endm  
# End of macro CALLMONITOR
41c9			endif	 
41c9			 
41c9			.nodashswap: 
41c9			 
41c9			if DEBUG_FORTH_DOT 
41c9				DMARK "D-o" 
41c9 f5				push af  
41ca 3a de 41			ld a, (.dmark)  
41cd 32 a0 fd			ld (debug_mark),a  
41d0 3a df 41			ld a, (.dmark+1)  
41d3 32 a1 fd			ld (debug_mark+1),a  
41d6 3a e0 41			ld a, (.dmark+2)  
41d9 32 a2 fd			ld (debug_mark+2),a  
41dc 18 03			jr .pastdmark  
41de ..			.dmark: db "D-o"  
41e1 f1			.pastdmark: pop af  
41e2			endm  
# End of macro DMARK
41e2				CALLMONITOR 
41e2 cd aa fd			call debug_vector  
41e5				endm  
# End of macro CALLMONITOR
41e5			endif	 
41e5			 
41e5 d5					push de   ; save string start in case we need to advance print 
41e6			 
41e6 3a 93 f9				ld a, (f_cursor_ptr) 
41e9 cd bd 0d				call str_at_display 
41ec 3a 71 f9				ld a,(cli_autodisplay) 
41ef fe 00				cp 0 
41f1 28 03				jr z, .noupdate 
41f3 cd cd 0d						call update_display 
41f6					.noupdate: 
41f6			 
41f6			 
41f6					; see if we need to advance the print position 
41f6			 
41f6 e1					pop hl   ; get back string 
41f7			;		ex de,hl 
41f7			 
41f7 3a 72 f9				ld a, (cli_mvdot) 
41fa			if DEBUG_FORTH_DOT 
41fa			;		ld e,a 
41fa				DMARK "D>1" 
41fa f5				push af  
41fb 3a 0f 42			ld a, (.dmark)  
41fe 32 a0 fd			ld (debug_mark),a  
4201 3a 10 42			ld a, (.dmark+1)  
4204 32 a1 fd			ld (debug_mark+1),a  
4207 3a 11 42			ld a, (.dmark+2)  
420a 32 a2 fd			ld (debug_mark+2),a  
420d 18 03			jr .pastdmark  
420f ..			.dmark: db "D>1"  
4212 f1			.pastdmark: pop af  
4213			endm  
# End of macro DMARK
4213				CALLMONITOR 
4213 cd aa fd			call debug_vector  
4216				endm  
# End of macro CALLMONITOR
4216			endif	 
4216 fe 00				cp 0 
4218 28 44				jr z, .noadv 
421a					; yes, lets advance the print position 
421a 3e 00				ld a, 0 
421c cd 4f 13				call strlent 
421f			if DEBUG_FORTH_DOT 
421f				DMARK "D-?" 
421f f5				push af  
4220 3a 34 42			ld a, (.dmark)  
4223 32 a0 fd			ld (debug_mark),a  
4226 3a 35 42			ld a, (.dmark+1)  
4229 32 a1 fd			ld (debug_mark+1),a  
422c 3a 36 42			ld a, (.dmark+2)  
422f 32 a2 fd			ld (debug_mark+2),a  
4232 18 03			jr .pastdmark  
4234 ..			.dmark: db "D-?"  
4237 f1			.pastdmark: pop af  
4238			endm  
# End of macro DMARK
4238				CALLMONITOR 
4238 cd aa fd			call debug_vector  
423b				endm  
# End of macro CALLMONITOR
423b			endif	 
423b 3a 93 f9				ld a, (f_cursor_ptr) 
423e 85					add a,l 
423f					;call addatohl 
423f					;ld a, l 
423f 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
4242			 
4242			if DEBUG_FORTH_DOT 
4242				DMARK "D->" 
4242 f5				push af  
4243 3a 57 42			ld a, (.dmark)  
4246 32 a0 fd			ld (debug_mark),a  
4249 3a 58 42			ld a, (.dmark+1)  
424c 32 a1 fd			ld (debug_mark+1),a  
424f 3a 59 42			ld a, (.dmark+2)  
4252 32 a2 fd			ld (debug_mark+2),a  
4255 18 03			jr .pastdmark  
4257 ..			.dmark: db "D->"  
425a f1			.pastdmark: pop af  
425b			endm  
# End of macro DMARK
425b				CALLMONITOR 
425b cd aa fd			call debug_vector  
425e				endm  
# End of macro CALLMONITOR
425e			endif	 
425e			 
425e			.noadv:	 
425e			 
425e					if DEBUG_FORTH_DOT_WAIT 
425e							call next_page_prompt 
425e					endif	 
425e			; TODO this pop off the stack causes a crash. i dont know why 
425e			 
425e			 
425e			if DEBUG_FORTH_DOT 
425e				DMARK "DTh" 
425e f5				push af  
425f 3a 73 42			ld a, (.dmark)  
4262 32 a0 fd			ld (debug_mark),a  
4265 3a 74 42			ld a, (.dmark+1)  
4268 32 a1 fd			ld (debug_mark+1),a  
426b 3a 75 42			ld a, (.dmark+2)  
426e 32 a2 fd			ld (debug_mark+2),a  
4271 18 03			jr .pastdmark  
4273 ..			.dmark: db "DTh"  
4276 f1			.pastdmark: pop af  
4277			endm  
# End of macro DMARK
4277				CALLMONITOR 
4277 cd aa fd			call debug_vector  
427a				endm  
# End of macro CALLMONITOR
427a			endif	 
427a			 
427a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
427a cd 03 23			call macro_forth_dsp_pop 
427d				endm 
# End of macro FORTH_DSP_POP
427d			 
427d			if DEBUG_FORTH_DOT 
427d				DMARK "DTi" 
427d f5				push af  
427e 3a 92 42			ld a, (.dmark)  
4281 32 a0 fd			ld (debug_mark),a  
4284 3a 93 42			ld a, (.dmark+1)  
4287 32 a1 fd			ld (debug_mark+1),a  
428a 3a 94 42			ld a, (.dmark+2)  
428d 32 a2 fd			ld (debug_mark+2),a  
4290 18 03			jr .pastdmark  
4292 ..			.dmark: db "DTi"  
4295 f1			.pastdmark: pop af  
4296			endm  
# End of macro DMARK
4296				CALLMONITOR 
4296 cd aa fd			call debug_vector  
4299				endm  
# End of macro CALLMONITOR
4299			endif	 
4299			 
4299			 
4299					NEXTW 
4299 c3 37 24			jp macro_next 
429c				endm 
# End of macro NEXTW
429c			 
429c			.CLS: 
429c				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
429c 35				db WORD_SYS_CORE+33             
429d c9 42			dw .DRAW            
429f 04				db 3 + 1 
42a0 .. 00			db "CLS",0              
42a4				endm 
# End of macro CWHEAD
42a4			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
42a4					if DEBUG_FORTH_WORDS_KEY 
42a4						DMARK "CLS" 
42a4 f5				push af  
42a5 3a b9 42			ld a, (.dmark)  
42a8 32 a0 fd			ld (debug_mark),a  
42ab 3a ba 42			ld a, (.dmark+1)  
42ae 32 a1 fd			ld (debug_mark+1),a  
42b1 3a bb 42			ld a, (.dmark+2)  
42b4 32 a2 fd			ld (debug_mark+2),a  
42b7 18 03			jr .pastdmark  
42b9 ..			.dmark: db "CLS"  
42bc f1			.pastdmark: pop af  
42bd			endm  
# End of macro DMARK
42bd						CALLMONITOR 
42bd cd aa fd			call debug_vector  
42c0				endm  
# End of macro CALLMONITOR
42c0					endif 
42c0 cd aa 0d				call clear_display 
42c3 c3 d7 43				jp .home		; and home cursor 
42c6					NEXTW 
42c6 c3 37 24			jp macro_next 
42c9				endm 
# End of macro NEXTW
42c9			 
42c9			.DRAW: 
42c9				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
42c9 36				db WORD_SYS_CORE+34             
42ca f4 42			dw .DUMP            
42cc 05				db 4 + 1 
42cd .. 00			db "DRAW",0              
42d2				endm 
# End of macro CWHEAD
42d2			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
42d2					if DEBUG_FORTH_WORDS_KEY 
42d2						DMARK "DRW" 
42d2 f5				push af  
42d3 3a e7 42			ld a, (.dmark)  
42d6 32 a0 fd			ld (debug_mark),a  
42d9 3a e8 42			ld a, (.dmark+1)  
42dc 32 a1 fd			ld (debug_mark+1),a  
42df 3a e9 42			ld a, (.dmark+2)  
42e2 32 a2 fd			ld (debug_mark+2),a  
42e5 18 03			jr .pastdmark  
42e7 ..			.dmark: db "DRW"  
42ea f1			.pastdmark: pop af  
42eb			endm  
# End of macro DMARK
42eb						CALLMONITOR 
42eb cd aa fd			call debug_vector  
42ee				endm  
# End of macro CALLMONITOR
42ee					endif 
42ee cd cd 0d				call update_display 
42f1					NEXTW 
42f1 c3 37 24			jp macro_next 
42f4				endm 
# End of macro NEXTW
42f4			 
42f4			.DUMP: 
42f4				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
42f4 37				db WORD_SYS_CORE+35             
42f5 2c 43			dw .CDUMP            
42f7 05				db 4 + 1 
42f8 .. 00			db "DUMP",0              
42fd				endm 
# End of macro CWHEAD
42fd			; | DUMP ( x -- ) With address x display dump   | DONE 
42fd			; TODO pop address to use off of the stack 
42fd					if DEBUG_FORTH_WORDS_KEY 
42fd						DMARK "DUM" 
42fd f5				push af  
42fe 3a 12 43			ld a, (.dmark)  
4301 32 a0 fd			ld (debug_mark),a  
4304 3a 13 43			ld a, (.dmark+1)  
4307 32 a1 fd			ld (debug_mark+1),a  
430a 3a 14 43			ld a, (.dmark+2)  
430d 32 a2 fd			ld (debug_mark+2),a  
4310 18 03			jr .pastdmark  
4312 ..			.dmark: db "DUM"  
4315 f1			.pastdmark: pop af  
4316			endm  
# End of macro DMARK
4316						CALLMONITOR 
4316 cd aa fd			call debug_vector  
4319				endm  
# End of macro CALLMONITOR
4319					endif 
4319 cd aa 0d				call clear_display 
431c			 
431c					; get address 
431c			 
431c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
431c cd 4b 22			call macro_dsp_valuehl 
431f				endm 
# End of macro FORTH_DSP_VALUEHL
431f				 
431f					; save it for cdump 
431f			 
431f 22 19 f4				ld (os_cur_ptr),hl 
4322			 
4322					; destroy value TOS 
4322			 
4322					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4322 cd 03 23			call macro_forth_dsp_pop 
4325				endm 
# End of macro FORTH_DSP_POP
4325			 
4325 cd c6 1e				call dumpcont	; skip old style of param parsing	 
4328 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4329					NEXTW 
4329 c3 37 24			jp macro_next 
432c				endm 
# End of macro NEXTW
432c			.CDUMP: 
432c				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
432c 38				db WORD_SYS_CORE+36             
432d 5c 43			dw .DAT            
432f 06				db 5 + 1 
4330 .. 00			db "CDUMP",0              
4336				endm 
# End of macro CWHEAD
4336			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
4336					if DEBUG_FORTH_WORDS_KEY 
4336						DMARK "CDP" 
4336 f5				push af  
4337 3a 4b 43			ld a, (.dmark)  
433a 32 a0 fd			ld (debug_mark),a  
433d 3a 4c 43			ld a, (.dmark+1)  
4340 32 a1 fd			ld (debug_mark+1),a  
4343 3a 4d 43			ld a, (.dmark+2)  
4346 32 a2 fd			ld (debug_mark+2),a  
4349 18 03			jr .pastdmark  
434b ..			.dmark: db "CDP"  
434e f1			.pastdmark: pop af  
434f			endm  
# End of macro DMARK
434f						CALLMONITOR 
434f cd aa fd			call debug_vector  
4352				endm  
# End of macro CALLMONITOR
4352					endif 
4352 cd aa 0d				call clear_display 
4355 cd c6 1e				call dumpcont	 
4358 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4359					NEXTW 
4359 c3 37 24			jp macro_next 
435c				endm 
# End of macro NEXTW
435c			 
435c			 
435c			 
435c			 
435c			.DAT: 
435c				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
435c 3d				db WORD_SYS_CORE+41             
435d b2 43			dw .HOME            
435f 03				db 2 + 1 
4360 .. 00			db "AT",0              
4363				endm 
# End of macro CWHEAD
4363			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4363					if DEBUG_FORTH_WORDS_KEY 
4363						DMARK "AT." 
4363 f5				push af  
4364 3a 78 43			ld a, (.dmark)  
4367 32 a0 fd			ld (debug_mark),a  
436a 3a 79 43			ld a, (.dmark+1)  
436d 32 a1 fd			ld (debug_mark+1),a  
4370 3a 7a 43			ld a, (.dmark+2)  
4373 32 a2 fd			ld (debug_mark+2),a  
4376 18 03			jr .pastdmark  
4378 ..			.dmark: db "AT."  
437b f1			.pastdmark: pop af  
437c			endm  
# End of macro DMARK
437c						CALLMONITOR 
437c cd aa fd			call debug_vector  
437f				endm  
# End of macro CALLMONITOR
437f					endif 
437f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
437f cd 4b 22			call macro_dsp_valuehl 
4382				endm 
# End of macro FORTH_DSP_VALUEHL
4382			 
4382			 
4382					; TODO save cursor row 
4382 7d					ld a,l 
4383 fe 02				cp 2 
4385 20 04				jr nz, .crow3 
4387 3e 28				ld a, display_row_2 
4389 18 12				jr .ccol1 
438b fe 03		.crow3:		cp 3 
438d 20 04				jr nz, .crow4 
438f 3e 50				ld a, display_row_3 
4391 18 0a				jr .ccol1 
4393 fe 04		.crow4:		cp 4 
4395 20 04				jr nz, .crow1 
4397 3e 78				ld a, display_row_4 
4399 18 02				jr .ccol1 
439b 3e 00		.crow1:		ld a,display_row_1 
439d f5			.ccol1:		push af			; got row offset 
439e 6f					ld l,a 
439f 26 00				ld h,0 
43a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43a1 cd 03 23			call macro_forth_dsp_pop 
43a4				endm 
# End of macro FORTH_DSP_POP
43a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43a4 cd 4b 22			call macro_dsp_valuehl 
43a7				endm 
# End of macro FORTH_DSP_VALUEHL
43a7					; TODO save cursor col 
43a7 f1					pop af 
43a8 85					add l		; add col offset 
43a9 32 93 f9				ld (f_cursor_ptr), a 
43ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43ac cd 03 23			call macro_forth_dsp_pop 
43af				endm 
# End of macro FORTH_DSP_POP
43af			 
43af					; calculate  
43af			 
43af					NEXTW 
43af c3 37 24			jp macro_next 
43b2				endm 
# End of macro NEXTW
43b2			 
43b2			 
43b2			.HOME: 
43b2				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
43b2 41				db WORD_SYS_CORE+45             
43b3 df 43			dw .CR            
43b5 05				db 4 + 1 
43b6 .. 00			db "HOME",0              
43bb				endm 
# End of macro CWHEAD
43bb			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
43bb					if DEBUG_FORTH_WORDS_KEY 
43bb						DMARK "HOM" 
43bb f5				push af  
43bc 3a d0 43			ld a, (.dmark)  
43bf 32 a0 fd			ld (debug_mark),a  
43c2 3a d1 43			ld a, (.dmark+1)  
43c5 32 a1 fd			ld (debug_mark+1),a  
43c8 3a d2 43			ld a, (.dmark+2)  
43cb 32 a2 fd			ld (debug_mark+2),a  
43ce 18 03			jr .pastdmark  
43d0 ..			.dmark: db "HOM"  
43d3 f1			.pastdmark: pop af  
43d4			endm  
# End of macro DMARK
43d4						CALLMONITOR 
43d4 cd aa fd			call debug_vector  
43d7				endm  
# End of macro CALLMONITOR
43d7					endif 
43d7 3e 00		.home:		ld a, 0		; and home cursor 
43d9 32 93 f9				ld (f_cursor_ptr), a 
43dc					NEXTW 
43dc c3 37 24			jp macro_next 
43df				endm 
# End of macro NEXTW
43df			 
43df			 
43df			.CR: 
43df				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
43df 46				db WORD_SYS_CORE+50             
43e0 1a 44			dw .SPACE            
43e2 03				db 2 + 1 
43e3 .. 00			db "CR",0              
43e6				endm 
# End of macro CWHEAD
43e6			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
43e6					if DEBUG_FORTH_WORDS_KEY 
43e6						DMARK "CR." 
43e6 f5				push af  
43e7 3a fb 43			ld a, (.dmark)  
43ea 32 a0 fd			ld (debug_mark),a  
43ed 3a fc 43			ld a, (.dmark+1)  
43f0 32 a1 fd			ld (debug_mark+1),a  
43f3 3a fd 43			ld a, (.dmark+2)  
43f6 32 a2 fd			ld (debug_mark+2),a  
43f9 18 03			jr .pastdmark  
43fb ..			.dmark: db "CR."  
43fe f1			.pastdmark: pop af  
43ff			endm  
# End of macro DMARK
43ff						CALLMONITOR 
43ff cd aa fd			call debug_vector  
4402				endm  
# End of macro CALLMONITOR
4402					endif 
4402 3e 0d				ld a, 13 
4404 32 f6 f0				ld (scratch),a 
4407 3e 0a				ld a, 10 
4409 32 f7 f0				ld (scratch+1),a 
440c 3e 00				ld a, 0 
440e 32 f8 f0				ld (scratch+2),a 
4411 21 f6 f0				ld hl, scratch 
4414 cd b4 20				call forth_push_str 
4417					 
4417				       NEXTW 
4417 c3 37 24			jp macro_next 
441a				endm 
# End of macro NEXTW
441a			.SPACE: 
441a				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
441a 46				db WORD_SYS_CORE+50             
441b 50 44			dw .SPACES            
441d 03				db 2 + 1 
441e .. 00			db "BL",0              
4421				endm 
# End of macro CWHEAD
4421			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
4421					if DEBUG_FORTH_WORDS_KEY 
4421						DMARK "BL." 
4421 f5				push af  
4422 3a 36 44			ld a, (.dmark)  
4425 32 a0 fd			ld (debug_mark),a  
4428 3a 37 44			ld a, (.dmark+1)  
442b 32 a1 fd			ld (debug_mark+1),a  
442e 3a 38 44			ld a, (.dmark+2)  
4431 32 a2 fd			ld (debug_mark+2),a  
4434 18 03			jr .pastdmark  
4436 ..			.dmark: db "BL."  
4439 f1			.pastdmark: pop af  
443a			endm  
# End of macro DMARK
443a						CALLMONITOR 
443a cd aa fd			call debug_vector  
443d				endm  
# End of macro CALLMONITOR
443d					endif 
443d 3e 20				ld a, " " 
443f 32 f6 f0				ld (scratch),a 
4442 3e 00				ld a, 0 
4444 32 f7 f0				ld (scratch+1),a 
4447 21 f6 f0				ld hl, scratch 
444a cd b4 20				call forth_push_str 
444d					 
444d				       NEXTW 
444d c3 37 24			jp macro_next 
4450				endm 
# End of macro NEXTW
4450			 
4450			;.blstr: db " ", 0 
4450			 
4450			.SPACES: 
4450				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
4450 47				db WORD_SYS_CORE+51             
4451 eb 44			dw .SCROLL            
4453 07				db 6 + 1 
4454 .. 00			db "SPACES",0              
445b				endm 
# End of macro CWHEAD
445b			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
445b					if DEBUG_FORTH_WORDS_KEY 
445b						DMARK "SPS" 
445b f5				push af  
445c 3a 70 44			ld a, (.dmark)  
445f 32 a0 fd			ld (debug_mark),a  
4462 3a 71 44			ld a, (.dmark+1)  
4465 32 a1 fd			ld (debug_mark+1),a  
4468 3a 72 44			ld a, (.dmark+2)  
446b 32 a2 fd			ld (debug_mark+2),a  
446e 18 03			jr .pastdmark  
4470 ..			.dmark: db "SPS"  
4473 f1			.pastdmark: pop af  
4474			endm  
# End of macro DMARK
4474						CALLMONITOR 
4474 cd aa fd			call debug_vector  
4477				endm  
# End of macro CALLMONITOR
4477					endif 
4477			 
4477			 
4477					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4477 cd 4b 22			call macro_dsp_valuehl 
447a				endm 
# End of macro FORTH_DSP_VALUEHL
447a			 
447a e5					push hl    ; u 
447b					if DEBUG_FORTH_WORDS 
447b						DMARK "SPA" 
447b f5				push af  
447c 3a 90 44			ld a, (.dmark)  
447f 32 a0 fd			ld (debug_mark),a  
4482 3a 91 44			ld a, (.dmark+1)  
4485 32 a1 fd			ld (debug_mark+1),a  
4488 3a 92 44			ld a, (.dmark+2)  
448b 32 a2 fd			ld (debug_mark+2),a  
448e 18 03			jr .pastdmark  
4490 ..			.dmark: db "SPA"  
4493 f1			.pastdmark: pop af  
4494			endm  
# End of macro DMARK
4494						CALLMONITOR 
4494 cd aa fd			call debug_vector  
4497				endm  
# End of macro CALLMONITOR
4497					endif 
4497			 
4497					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4497 cd 03 23			call macro_forth_dsp_pop 
449a				endm 
# End of macro FORTH_DSP_POP
449a e1					pop hl 
449b 0e 00				ld c, 0 
449d 45					ld b, l 
449e 21 f6 f0				ld hl, scratch  
44a1			 
44a1					if DEBUG_FORTH_WORDS 
44a1						DMARK "SP2" 
44a1 f5				push af  
44a2 3a b6 44			ld a, (.dmark)  
44a5 32 a0 fd			ld (debug_mark),a  
44a8 3a b7 44			ld a, (.dmark+1)  
44ab 32 a1 fd			ld (debug_mark+1),a  
44ae 3a b8 44			ld a, (.dmark+2)  
44b1 32 a2 fd			ld (debug_mark+2),a  
44b4 18 03			jr .pastdmark  
44b6 ..			.dmark: db "SP2"  
44b9 f1			.pastdmark: pop af  
44ba			endm  
# End of macro DMARK
44ba						CALLMONITOR 
44ba cd aa fd			call debug_vector  
44bd				endm  
# End of macro CALLMONITOR
44bd					endif 
44bd 3e 20				ld a, ' ' 
44bf			.spaces1:	 
44bf 77					ld (hl),a 
44c0 23					inc hl 
44c1					 
44c1 10 fc				djnz .spaces1 
44c3 3e 00				ld a,0 
44c5 77					ld (hl),a 
44c6 21 f6 f0				ld hl, scratch 
44c9					if DEBUG_FORTH_WORDS 
44c9						DMARK "SP3" 
44c9 f5				push af  
44ca 3a de 44			ld a, (.dmark)  
44cd 32 a0 fd			ld (debug_mark),a  
44d0 3a df 44			ld a, (.dmark+1)  
44d3 32 a1 fd			ld (debug_mark+1),a  
44d6 3a e0 44			ld a, (.dmark+2)  
44d9 32 a2 fd			ld (debug_mark+2),a  
44dc 18 03			jr .pastdmark  
44de ..			.dmark: db "SP3"  
44e1 f1			.pastdmark: pop af  
44e2			endm  
# End of macro DMARK
44e2						CALLMONITOR 
44e2 cd aa fd			call debug_vector  
44e5				endm  
# End of macro CALLMONITOR
44e5					endif 
44e5 cd b4 20				call forth_push_str 
44e8			 
44e8				       NEXTW 
44e8 c3 37 24			jp macro_next 
44eb				endm 
# End of macro NEXTW
44eb			 
44eb			 
44eb			 
44eb			.SCROLL: 
44eb				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
44eb 53				db WORD_SYS_CORE+63             
44ec 18 45			dw .SCROLLD            
44ee 07				db 6 + 1 
44ef .. 00			db "SCROLL",0              
44f6				endm 
# End of macro CWHEAD
44f6			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
44f6					if DEBUG_FORTH_WORDS_KEY 
44f6						DMARK "SCR" 
44f6 f5				push af  
44f7 3a 0b 45			ld a, (.dmark)  
44fa 32 a0 fd			ld (debug_mark),a  
44fd 3a 0c 45			ld a, (.dmark+1)  
4500 32 a1 fd			ld (debug_mark+1),a  
4503 3a 0d 45			ld a, (.dmark+2)  
4506 32 a2 fd			ld (debug_mark+2),a  
4509 18 03			jr .pastdmark  
450b ..			.dmark: db "SCR"  
450e f1			.pastdmark: pop af  
450f			endm  
# End of macro DMARK
450f						CALLMONITOR 
450f cd aa fd			call debug_vector  
4512				endm  
# End of macro CALLMONITOR
4512					endif 
4512			 
4512 cd 6c 0d			call scroll_up 
4515			;	call update_display 
4515			 
4515					NEXTW 
4515 c3 37 24			jp macro_next 
4518				endm 
# End of macro NEXTW
4518			 
4518			 
4518			 
4518			;		; get dir 
4518			; 
4518			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4518			; 
4518			;		push hl 
4518			; 
4518			;		; destroy value TOS 
4518			; 
4518			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4518			; 
4518			;		; get count 
4518			; 
4518			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4518			; 
4518			;		push hl 
4518			; 
4518			;		; destroy value TOS 
4518			; 
4518			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4518			; 
4518			;		; one value on hl get other one back 
4518			; 
4518			;		pop bc    ; count 
4518			; 
4518			;		pop de   ; dir 
4518			; 
4518			; 
4518			;		ld b, c 
4518			; 
4518			;.scrolldir:     push bc 
4518			;		push de 
4518			; 
4518			;		ld a, 0 
4518			;		cp e 
4518			;		jr z, .scrollup  
4518			;		call scroll_down 
4518			;		jr .scrollnext 
4518			;.scrollup:	call scroll_up 
4518			; 
4518			;		 
4518			;.scrollnext: 
4518			;		pop de 
4518			;		pop bc 
4518			;		djnz .scrolldir 
4518			; 
4518			; 
4518			; 
4518			; 
4518			; 
4518			;		NEXTW 
4518			 
4518			.SCROLLD: 
4518				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4518 53				db WORD_SYS_CORE+63             
4519 46 45			dw .ATQ            
451b 08				db 7 + 1 
451c .. 00			db "SCROLLD",0              
4524				endm 
# End of macro CWHEAD
4524			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4524					if DEBUG_FORTH_WORDS_KEY 
4524						DMARK "SCD" 
4524 f5				push af  
4525 3a 39 45			ld a, (.dmark)  
4528 32 a0 fd			ld (debug_mark),a  
452b 3a 3a 45			ld a, (.dmark+1)  
452e 32 a1 fd			ld (debug_mark+1),a  
4531 3a 3b 45			ld a, (.dmark+2)  
4534 32 a2 fd			ld (debug_mark+2),a  
4537 18 03			jr .pastdmark  
4539 ..			.dmark: db "SCD"  
453c f1			.pastdmark: pop af  
453d			endm  
# End of macro DMARK
453d						CALLMONITOR 
453d cd aa fd			call debug_vector  
4540				endm  
# End of macro CALLMONITOR
4540					endif 
4540			 
4540 cd 90 0d			call scroll_down 
4543			;	call update_display 
4543			 
4543					NEXTW 
4543 c3 37 24			jp macro_next 
4546				endm 
# End of macro NEXTW
4546			 
4546			 
4546			.ATQ: 
4546				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4546 62				db WORD_SYS_CORE+78             
4547 a4 45			dw .AUTODSP            
4549 04				db 3 + 1 
454a .. 00			db "AT@",0              
454e				endm 
# End of macro CWHEAD
454e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
454e					if DEBUG_FORTH_WORDS_KEY 
454e						DMARK "ATA" 
454e f5				push af  
454f 3a 63 45			ld a, (.dmark)  
4552 32 a0 fd			ld (debug_mark),a  
4555 3a 64 45			ld a, (.dmark+1)  
4558 32 a1 fd			ld (debug_mark+1),a  
455b 3a 65 45			ld a, (.dmark+2)  
455e 32 a2 fd			ld (debug_mark+2),a  
4561 18 03			jr .pastdmark  
4563 ..			.dmark: db "ATA"  
4566 f1			.pastdmark: pop af  
4567			endm  
# End of macro DMARK
4567						CALLMONITOR 
4567 cd aa fd			call debug_vector  
456a				endm  
# End of macro CALLMONITOR
456a					endif 
456a			 
456a			 
456a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
456a cd 4b 22			call macro_dsp_valuehl 
456d				endm 
# End of macro FORTH_DSP_VALUEHL
456d			 
456d					; TODO save cursor row 
456d 7d					ld a,l 
456e fe 02				cp 2 
4570 20 04				jr nz, .crow3aq 
4572 3e 28				ld a, display_row_2 
4574 18 12				jr .ccol1aq 
4576 fe 03		.crow3aq:		cp 3 
4578 20 04				jr nz, .crow4aq 
457a 3e 50				ld a, display_row_3 
457c 18 0a				jr .ccol1aq 
457e fe 04		.crow4aq:		cp 4 
4580 20 04				jr nz, .crow1aq 
4582 3e 78				ld a, display_row_4 
4584 18 02				jr .ccol1aq 
4586 3e 00		.crow1aq:		ld a,display_row_1 
4588 f5			.ccol1aq:		push af			; got row offset 
4589 6f					ld l,a 
458a 26 00				ld h,0 
458c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
458c cd 03 23			call macro_forth_dsp_pop 
458f				endm 
# End of macro FORTH_DSP_POP
458f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
458f cd 4b 22			call macro_dsp_valuehl 
4592				endm 
# End of macro FORTH_DSP_VALUEHL
4592					; TODO save cursor col 
4592 f1					pop af 
4593 85					add l		; add col offset 
4594			 
4594					; add current frame buffer address 
4594 2a 01 fb				ld hl, (display_fb_active) 
4597 cd de 0f				call addatohl 
459a			 
459a			 
459a			 
459a			 
459a					; get char frame buffer location offset in hl 
459a			 
459a 7e					ld a,(hl) 
459b 26 00				ld h, 0 
459d 6f					ld l, a 
459e			 
459e cd 46 20				call forth_push_numhl 
45a1			 
45a1			 
45a1					NEXTW 
45a1 c3 37 24			jp macro_next 
45a4				endm 
# End of macro NEXTW
45a4			 
45a4			.AUTODSP: 
45a4				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
45a4 63				db WORD_SYS_CORE+79             
45a5 ba 45			dw .MENU            
45a7 05				db 4 + 1 
45a8 .. 00			db "ADSP",0              
45ad				endm 
# End of macro CWHEAD
45ad			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
45ad			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
45ad			 
45ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45ad cd 4b 22			call macro_dsp_valuehl 
45b0				endm 
# End of macro FORTH_DSP_VALUEHL
45b0			 
45b0			;		push hl 
45b0			 
45b0					; destroy value TOS 
45b0			 
45b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45b0 cd 03 23			call macro_forth_dsp_pop 
45b3				endm 
# End of macro FORTH_DSP_POP
45b3			 
45b3			;		pop hl 
45b3			 
45b3 7d					ld a,l 
45b4 32 71 f9				ld (cli_autodisplay), a 
45b7				       NEXTW 
45b7 c3 37 24			jp macro_next 
45ba				endm 
# End of macro NEXTW
45ba			 
45ba			.MENU: 
45ba				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
45ba 70				db WORD_SYS_CORE+92             
45bb 63 46			dw .ENDDISPLAY            
45bd 05				db 4 + 1 
45be .. 00			db "MENU",0              
45c3				endm 
# End of macro CWHEAD
45c3			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
45c3			 
45c3			;		; get number of items on the stack 
45c3			; 
45c3				 
45c3					FORTH_DSP_VALUEHL 
45c3 cd 4b 22			call macro_dsp_valuehl 
45c6				endm 
# End of macro FORTH_DSP_VALUEHL
45c6				 
45c6					if DEBUG_FORTH_WORDS_KEY 
45c6						DMARK "MNU" 
45c6 f5				push af  
45c7 3a db 45			ld a, (.dmark)  
45ca 32 a0 fd			ld (debug_mark),a  
45cd 3a dc 45			ld a, (.dmark+1)  
45d0 32 a1 fd			ld (debug_mark+1),a  
45d3 3a dd 45			ld a, (.dmark+2)  
45d6 32 a2 fd			ld (debug_mark+2),a  
45d9 18 03			jr .pastdmark  
45db ..			.dmark: db "MNU"  
45de f1			.pastdmark: pop af  
45df			endm  
# End of macro DMARK
45df						CALLMONITOR 
45df cd aa fd			call debug_vector  
45e2				endm  
# End of macro CALLMONITOR
45e2					endif 
45e2			 
45e2 45					ld b, l	 
45e3 05					dec b 
45e4			 
45e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45e4 cd 03 23			call macro_forth_dsp_pop 
45e7				endm 
# End of macro FORTH_DSP_POP
45e7			 
45e7			 
45e7					; go directly through the stack to pluck out the string pointers and build an array 
45e7			 
45e7			;		FORTH_DSP 
45e7			 
45e7					; hl contains top most stack item 
45e7				 
45e7 11 f6 f0				ld de, scratch 
45ea			 
45ea			.mbuild: 
45ea			 
45ea					FORTH_DSP_VALUEHL 
45ea cd 4b 22			call macro_dsp_valuehl 
45ed				endm 
# End of macro FORTH_DSP_VALUEHL
45ed			 
45ed					if DEBUG_FORTH_WORDS 
45ed						DMARK "MN3" 
45ed f5				push af  
45ee 3a 02 46			ld a, (.dmark)  
45f1 32 a0 fd			ld (debug_mark),a  
45f4 3a 03 46			ld a, (.dmark+1)  
45f7 32 a1 fd			ld (debug_mark+1),a  
45fa 3a 04 46			ld a, (.dmark+2)  
45fd 32 a2 fd			ld (debug_mark+2),a  
4600 18 03			jr .pastdmark  
4602 ..			.dmark: db "MN3"  
4605 f1			.pastdmark: pop af  
4606			endm  
# End of macro DMARK
4606						CALLMONITOR 
4606 cd aa fd			call debug_vector  
4609				endm  
# End of macro CALLMONITOR
4609					endif 
4609 eb					ex de, hl 
460a 73					ld (hl), e 
460b 23					inc hl 
460c 72					ld (hl), d 
460d 23					inc hl 
460e eb					ex de, hl 
460f			 
460f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
460f cd 03 23			call macro_forth_dsp_pop 
4612				endm 
# End of macro FORTH_DSP_POP
4612			 
4612 10 d6				djnz .mbuild 
4614			 
4614					; done add term 
4614			 
4614 eb					ex de, hl 
4615 36 00				ld (hl), 0 
4617 23					inc hl 
4618 36 00				ld (hl), 0 
461a			 
461a				 
461a					 
461a 21 f6 f0				ld hl, scratch 
461d			 
461d					if DEBUG_FORTH_WORDS 
461d						DMARK "MNx" 
461d f5				push af  
461e 3a 32 46			ld a, (.dmark)  
4621 32 a0 fd			ld (debug_mark),a  
4624 3a 33 46			ld a, (.dmark+1)  
4627 32 a1 fd			ld (debug_mark+1),a  
462a 3a 34 46			ld a, (.dmark+2)  
462d 32 a2 fd			ld (debug_mark+2),a  
4630 18 03			jr .pastdmark  
4632 ..			.dmark: db "MNx"  
4635 f1			.pastdmark: pop af  
4636			endm  
# End of macro DMARK
4636						CALLMONITOR 
4636 cd aa fd			call debug_vector  
4639				endm  
# End of macro CALLMONITOR
4639					endif 
4639			 
4639			 
4639			 
4639 3e 00				ld a, 0 
463b cd db 0d				call menu 
463e			 
463e			 
463e 6f					ld l, a 
463f 26 00				ld h, 0 
4641			 
4641					if DEBUG_FORTH_WORDS 
4641						DMARK "MNr" 
4641 f5				push af  
4642 3a 56 46			ld a, (.dmark)  
4645 32 a0 fd			ld (debug_mark),a  
4648 3a 57 46			ld a, (.dmark+1)  
464b 32 a1 fd			ld (debug_mark+1),a  
464e 3a 58 46			ld a, (.dmark+2)  
4651 32 a2 fd			ld (debug_mark+2),a  
4654 18 03			jr .pastdmark  
4656 ..			.dmark: db "MNr"  
4659 f1			.pastdmark: pop af  
465a			endm  
# End of macro DMARK
465a						CALLMONITOR 
465a cd aa fd			call debug_vector  
465d				endm  
# End of macro CALLMONITOR
465d					endif 
465d			 
465d cd 46 20				call forth_push_numhl 
4660			 
4660			 
4660			 
4660			 
4660				       NEXTW 
4660 c3 37 24			jp macro_next 
4663				endm 
# End of macro NEXTW
4663			 
4663			 
4663			.ENDDISPLAY: 
4663			 
4663			; eof 
# End of file forth_words_display.asm
4663			include "forth_words_str.asm" 
4663			 
4663			; | ## String Words 
4663			 
4663			.PTR:   
4663			 
4663				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4663 48				db WORD_SYS_CORE+52             
4664 90 46			dw .STYPE            
4666 04				db 3 + 1 
4667 .. 00			db "PTR",0              
466b				endm 
# End of macro CWHEAD
466b			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
466b			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
466b			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
466b			 
466b					if DEBUG_FORTH_WORDS_KEY 
466b						DMARK "PTR" 
466b f5				push af  
466c 3a 80 46			ld a, (.dmark)  
466f 32 a0 fd			ld (debug_mark),a  
4672 3a 81 46			ld a, (.dmark+1)  
4675 32 a1 fd			ld (debug_mark+1),a  
4678 3a 82 46			ld a, (.dmark+2)  
467b 32 a2 fd			ld (debug_mark+2),a  
467e 18 03			jr .pastdmark  
4680 ..			.dmark: db "PTR"  
4683 f1			.pastdmark: pop af  
4684			endm  
# End of macro DMARK
4684						CALLMONITOR 
4684 cd aa fd			call debug_vector  
4687				endm  
# End of macro CALLMONITOR
4687					endif 
4687					FORTH_DSP_VALUEHL 
4687 cd 4b 22			call macro_dsp_valuehl 
468a				endm 
# End of macro FORTH_DSP_VALUEHL
468a cd 46 20				call forth_push_numhl 
468d			 
468d			 
468d					NEXTW 
468d c3 37 24			jp macro_next 
4690				endm 
# End of macro NEXTW
4690			.STYPE: 
4690				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4690 48				db WORD_SYS_CORE+52             
4691 df 46			dw .UPPER            
4693 06				db 5 + 1 
4694 .. 00			db "STYPE",0              
469a				endm 
# End of macro CWHEAD
469a			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
469a					if DEBUG_FORTH_WORDS_KEY 
469a						DMARK "STY" 
469a f5				push af  
469b 3a af 46			ld a, (.dmark)  
469e 32 a0 fd			ld (debug_mark),a  
46a1 3a b0 46			ld a, (.dmark+1)  
46a4 32 a1 fd			ld (debug_mark+1),a  
46a7 3a b1 46			ld a, (.dmark+2)  
46aa 32 a2 fd			ld (debug_mark+2),a  
46ad 18 03			jr .pastdmark  
46af ..			.dmark: db "STY"  
46b2 f1			.pastdmark: pop af  
46b3			endm  
# End of macro DMARK
46b3						CALLMONITOR 
46b3 cd aa fd			call debug_vector  
46b6				endm  
# End of macro CALLMONITOR
46b6					endif 
46b6					FORTH_DSP 
46b6 cd 11 22			call macro_forth_dsp 
46b9				endm 
# End of macro FORTH_DSP
46b9					;v5 FORTH_DSP_VALUE 
46b9			 
46b9 7e					ld a, (hl) 
46ba			 
46ba f5					push af 
46bb			 
46bb			; Dont destroy TOS		FORTH_DSP_POP 
46bb			 
46bb f1					pop af 
46bc			 
46bc fe 01				cp DS_TYPE_STR 
46be 28 09				jr z, .typestr 
46c0			 
46c0 fe 02				cp DS_TYPE_INUM 
46c2 28 0a				jr z, .typeinum 
46c4			 
46c4 21 dd 46				ld hl, .tna 
46c7 18 0a				jr .tpush 
46c9			 
46c9 21 d9 46		.typestr:	ld hl, .tstr 
46cc 18 05				jr .tpush 
46ce 21 db 46		.typeinum:	ld hl, .tinum 
46d1 18 00				jr .tpush 
46d3			 
46d3			.tpush: 
46d3			 
46d3 cd b4 20				call forth_push_str 
46d6			 
46d6					NEXTW 
46d6 c3 37 24			jp macro_next 
46d9				endm 
# End of macro NEXTW
46d9 .. 00		.tstr:	db "s",0 
46db .. 00		.tinum:  db "i",0 
46dd .. 00		.tna:   db "?", 0 
46df			 
46df			 
46df			.UPPER: 
46df				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
46df 48				db WORD_SYS_CORE+52             
46e0 1a 47			dw .LOWER            
46e2 06				db 5 + 1 
46e3 .. 00			db "UPPER",0              
46e9				endm 
# End of macro CWHEAD
46e9			; | UPPER ( s -- s ) Upper case string s  | DONE 
46e9					if DEBUG_FORTH_WORDS_KEY 
46e9						DMARK "UPR" 
46e9 f5				push af  
46ea 3a fe 46			ld a, (.dmark)  
46ed 32 a0 fd			ld (debug_mark),a  
46f0 3a ff 46			ld a, (.dmark+1)  
46f3 32 a1 fd			ld (debug_mark+1),a  
46f6 3a 00 47			ld a, (.dmark+2)  
46f9 32 a2 fd			ld (debug_mark+2),a  
46fc 18 03			jr .pastdmark  
46fe ..			.dmark: db "UPR"  
4701 f1			.pastdmark: pop af  
4702			endm  
# End of macro DMARK
4702						CALLMONITOR 
4702 cd aa fd			call debug_vector  
4705				endm  
# End of macro CALLMONITOR
4705					endif 
4705			 
4705					FORTH_DSP 
4705 cd 11 22			call macro_forth_dsp 
4708				endm 
# End of macro FORTH_DSP
4708					 
4708			; TODO check is string type 
4708			 
4708					FORTH_DSP_VALUEHL 
4708 cd 4b 22			call macro_dsp_valuehl 
470b				endm 
# End of macro FORTH_DSP_VALUEHL
470b			; get pointer to string in hl 
470b			 
470b 7e			.toup:		ld a, (hl) 
470c fe 00				cp 0 
470e 28 07				jr z, .toupdone 
4710			 
4710 cd 53 12				call to_upper 
4713			 
4713 77					ld (hl), a 
4714 23					inc hl 
4715 18 f4				jr .toup 
4717			 
4717					 
4717			 
4717			 
4717			; for each char convert to upper 
4717					 
4717			.toupdone: 
4717			 
4717			 
4717					NEXTW 
4717 c3 37 24			jp macro_next 
471a				endm 
# End of macro NEXTW
471a			.LOWER: 
471a				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
471a 48				db WORD_SYS_CORE+52             
471b 55 47			dw .TCASE            
471d 06				db 5 + 1 
471e .. 00			db "LOWER",0              
4724				endm 
# End of macro CWHEAD
4724			; | LOWER ( s -- s ) Lower case string s  | DONE 
4724					if DEBUG_FORTH_WORDS_KEY 
4724						DMARK "LWR" 
4724 f5				push af  
4725 3a 39 47			ld a, (.dmark)  
4728 32 a0 fd			ld (debug_mark),a  
472b 3a 3a 47			ld a, (.dmark+1)  
472e 32 a1 fd			ld (debug_mark+1),a  
4731 3a 3b 47			ld a, (.dmark+2)  
4734 32 a2 fd			ld (debug_mark+2),a  
4737 18 03			jr .pastdmark  
4739 ..			.dmark: db "LWR"  
473c f1			.pastdmark: pop af  
473d			endm  
# End of macro DMARK
473d						CALLMONITOR 
473d cd aa fd			call debug_vector  
4740				endm  
# End of macro CALLMONITOR
4740					endif 
4740			 
4740					FORTH_DSP 
4740 cd 11 22			call macro_forth_dsp 
4743				endm 
# End of macro FORTH_DSP
4743					 
4743			; TODO check is string type 
4743			 
4743					FORTH_DSP_VALUEHL 
4743 cd 4b 22			call macro_dsp_valuehl 
4746				endm 
# End of macro FORTH_DSP_VALUEHL
4746			; get pointer to string in hl 
4746			 
4746 7e			.tolow:		ld a, (hl) 
4747 fe 00				cp 0 
4749 28 07				jr z, .tolowdone 
474b			 
474b cd 5c 12				call to_lower 
474e			 
474e 77					ld (hl), a 
474f 23					inc hl 
4750 18 f4				jr .tolow 
4752			 
4752					 
4752			 
4752			 
4752			; for each char convert to low 
4752					 
4752			.tolowdone: 
4752					NEXTW 
4752 c3 37 24			jp macro_next 
4755				endm 
# End of macro NEXTW
4755			.TCASE: 
4755				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4755 48				db WORD_SYS_CORE+52             
4756 8b 48			dw .SUBSTR            
4758 06				db 5 + 1 
4759 .. 00			db "TCASE",0              
475f				endm 
# End of macro CWHEAD
475f			; | TCASE ( s -- s ) Title case string s  | DONE 
475f					if DEBUG_FORTH_WORDS_KEY 
475f						DMARK "TCS" 
475f f5				push af  
4760 3a 74 47			ld a, (.dmark)  
4763 32 a0 fd			ld (debug_mark),a  
4766 3a 75 47			ld a, (.dmark+1)  
4769 32 a1 fd			ld (debug_mark+1),a  
476c 3a 76 47			ld a, (.dmark+2)  
476f 32 a2 fd			ld (debug_mark+2),a  
4772 18 03			jr .pastdmark  
4774 ..			.dmark: db "TCS"  
4777 f1			.pastdmark: pop af  
4778			endm  
# End of macro DMARK
4778						CALLMONITOR 
4778 cd aa fd			call debug_vector  
477b				endm  
# End of macro CALLMONITOR
477b					endif 
477b			 
477b					FORTH_DSP 
477b cd 11 22			call macro_forth_dsp 
477e				endm 
# End of macro FORTH_DSP
477e					 
477e			; TODO check is string type 
477e			 
477e					FORTH_DSP_VALUEHL 
477e cd 4b 22			call macro_dsp_valuehl 
4781				endm 
# End of macro FORTH_DSP_VALUEHL
4781			; get pointer to string in hl 
4781			 
4781					if DEBUG_FORTH_WORDS 
4781						DMARK "TC1" 
4781 f5				push af  
4782 3a 96 47			ld a, (.dmark)  
4785 32 a0 fd			ld (debug_mark),a  
4788 3a 97 47			ld a, (.dmark+1)  
478b 32 a1 fd			ld (debug_mark+1),a  
478e 3a 98 47			ld a, (.dmark+2)  
4791 32 a2 fd			ld (debug_mark+2),a  
4794 18 03			jr .pastdmark  
4796 ..			.dmark: db "TC1"  
4799 f1			.pastdmark: pop af  
479a			endm  
# End of macro DMARK
479a						CALLMONITOR 
479a cd aa fd			call debug_vector  
479d				endm  
# End of macro CALLMONITOR
479d					endif 
479d			 
479d					; first time in turn to upper case first char 
479d			 
479d 7e					ld a, (hl) 
479e c3 28 48				jp .totsiptou 
47a1			 
47a1			 
47a1 7e			.tot:		ld a, (hl) 
47a2 fe 00				cp 0 
47a4 ca 6c 48				jp z, .totdone 
47a7			 
47a7					if DEBUG_FORTH_WORDS 
47a7						DMARK "TC2" 
47a7 f5				push af  
47a8 3a bc 47			ld a, (.dmark)  
47ab 32 a0 fd			ld (debug_mark),a  
47ae 3a bd 47			ld a, (.dmark+1)  
47b1 32 a1 fd			ld (debug_mark+1),a  
47b4 3a be 47			ld a, (.dmark+2)  
47b7 32 a2 fd			ld (debug_mark+2),a  
47ba 18 03			jr .pastdmark  
47bc ..			.dmark: db "TC2"  
47bf f1			.pastdmark: pop af  
47c0			endm  
# End of macro DMARK
47c0						CALLMONITOR 
47c0 cd aa fd			call debug_vector  
47c3				endm  
# End of macro CALLMONITOR
47c3					endif 
47c3					; check to see if current char is a space 
47c3			 
47c3 fe 20				cp ' ' 
47c5 28 21				jr z, .totsp 
47c7 cd 5c 12				call to_lower 
47ca					if DEBUG_FORTH_WORDS 
47ca						DMARK "TC3" 
47ca f5				push af  
47cb 3a df 47			ld a, (.dmark)  
47ce 32 a0 fd			ld (debug_mark),a  
47d1 3a e0 47			ld a, (.dmark+1)  
47d4 32 a1 fd			ld (debug_mark+1),a  
47d7 3a e1 47			ld a, (.dmark+2)  
47da 32 a2 fd			ld (debug_mark+2),a  
47dd 18 03			jr .pastdmark  
47df ..			.dmark: db "TC3"  
47e2 f1			.pastdmark: pop af  
47e3			endm  
# End of macro DMARK
47e3						CALLMONITOR 
47e3 cd aa fd			call debug_vector  
47e6				endm  
# End of macro CALLMONITOR
47e6					endif 
47e6 18 63				jr .totnxt 
47e8			 
47e8			.totsp:         ; on a space, find next char which should be upper 
47e8			 
47e8					if DEBUG_FORTH_WORDS 
47e8						DMARK "TC4" 
47e8 f5				push af  
47e9 3a fd 47			ld a, (.dmark)  
47ec 32 a0 fd			ld (debug_mark),a  
47ef 3a fe 47			ld a, (.dmark+1)  
47f2 32 a1 fd			ld (debug_mark+1),a  
47f5 3a ff 47			ld a, (.dmark+2)  
47f8 32 a2 fd			ld (debug_mark+2),a  
47fb 18 03			jr .pastdmark  
47fd ..			.dmark: db "TC4"  
4800 f1			.pastdmark: pop af  
4801			endm  
# End of macro DMARK
4801						CALLMONITOR 
4801 cd aa fd			call debug_vector  
4804				endm  
# End of macro CALLMONITOR
4804					endif 
4804					;; 
4804			 
4804 fe 20				cp ' ' 
4806 20 20				jr nz, .totsiptou 
4808 23					inc hl 
4809 7e					ld a, (hl) 
480a					if DEBUG_FORTH_WORDS 
480a						DMARK "TC5" 
480a f5				push af  
480b 3a 1f 48			ld a, (.dmark)  
480e 32 a0 fd			ld (debug_mark),a  
4811 3a 20 48			ld a, (.dmark+1)  
4814 32 a1 fd			ld (debug_mark+1),a  
4817 3a 21 48			ld a, (.dmark+2)  
481a 32 a2 fd			ld (debug_mark+2),a  
481d 18 03			jr .pastdmark  
481f ..			.dmark: db "TC5"  
4822 f1			.pastdmark: pop af  
4823			endm  
# End of macro DMARK
4823						CALLMONITOR 
4823 cd aa fd			call debug_vector  
4826				endm  
# End of macro CALLMONITOR
4826					endif 
4826 18 c0				jr .totsp 
4828 fe 00		.totsiptou:    cp 0 
482a 28 40				jr z, .totdone 
482c					; not space and not zero term so upper case it 
482c cd 53 12				call to_upper 
482f			 
482f					if DEBUG_FORTH_WORDS 
482f						DMARK "TC6" 
482f f5				push af  
4830 3a 44 48			ld a, (.dmark)  
4833 32 a0 fd			ld (debug_mark),a  
4836 3a 45 48			ld a, (.dmark+1)  
4839 32 a1 fd			ld (debug_mark+1),a  
483c 3a 46 48			ld a, (.dmark+2)  
483f 32 a2 fd			ld (debug_mark+2),a  
4842 18 03			jr .pastdmark  
4844 ..			.dmark: db "TC6"  
4847 f1			.pastdmark: pop af  
4848			endm  
# End of macro DMARK
4848						CALLMONITOR 
4848 cd aa fd			call debug_vector  
484b				endm  
# End of macro CALLMONITOR
484b					endif 
484b			 
484b			 
484b			.totnxt: 
484b			 
484b 77					ld (hl), a 
484c 23					inc hl 
484d					if DEBUG_FORTH_WORDS 
484d						DMARK "TC7" 
484d f5				push af  
484e 3a 62 48			ld a, (.dmark)  
4851 32 a0 fd			ld (debug_mark),a  
4854 3a 63 48			ld a, (.dmark+1)  
4857 32 a1 fd			ld (debug_mark+1),a  
485a 3a 64 48			ld a, (.dmark+2)  
485d 32 a2 fd			ld (debug_mark+2),a  
4860 18 03			jr .pastdmark  
4862 ..			.dmark: db "TC7"  
4865 f1			.pastdmark: pop af  
4866			endm  
# End of macro DMARK
4866						CALLMONITOR 
4866 cd aa fd			call debug_vector  
4869				endm  
# End of macro CALLMONITOR
4869					endif 
4869 c3 a1 47				jp .tot 
486c			 
486c					 
486c			 
486c			 
486c			; for each char convert to low 
486c					 
486c			.totdone: 
486c					if DEBUG_FORTH_WORDS 
486c						DMARK "TCd" 
486c f5				push af  
486d 3a 81 48			ld a, (.dmark)  
4870 32 a0 fd			ld (debug_mark),a  
4873 3a 82 48			ld a, (.dmark+1)  
4876 32 a1 fd			ld (debug_mark+1),a  
4879 3a 83 48			ld a, (.dmark+2)  
487c 32 a2 fd			ld (debug_mark+2),a  
487f 18 03			jr .pastdmark  
4881 ..			.dmark: db "TCd"  
4884 f1			.pastdmark: pop af  
4885			endm  
# End of macro DMARK
4885						CALLMONITOR 
4885 cd aa fd			call debug_vector  
4888				endm  
# End of macro CALLMONITOR
4888					endif 
4888					NEXTW 
4888 c3 37 24			jp macro_next 
488b				endm 
# End of macro NEXTW
488b			 
488b			.SUBSTR: 
488b				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
488b 48				db WORD_SYS_CORE+52             
488c e9 48			dw .LEFT            
488e 07				db 6 + 1 
488f .. 00			db "SUBSTR",0              
4896				endm 
# End of macro CWHEAD
4896			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4896			 
4896					if DEBUG_FORTH_WORDS_KEY 
4896						DMARK "SST" 
4896 f5				push af  
4897 3a ab 48			ld a, (.dmark)  
489a 32 a0 fd			ld (debug_mark),a  
489d 3a ac 48			ld a, (.dmark+1)  
48a0 32 a1 fd			ld (debug_mark+1),a  
48a3 3a ad 48			ld a, (.dmark+2)  
48a6 32 a2 fd			ld (debug_mark+2),a  
48a9 18 03			jr .pastdmark  
48ab ..			.dmark: db "SST"  
48ae f1			.pastdmark: pop af  
48af			endm  
# End of macro DMARK
48af						CALLMONITOR 
48af cd aa fd			call debug_vector  
48b2				endm  
# End of macro CALLMONITOR
48b2					endif 
48b2			; TODO check string type 
48b2					FORTH_DSP_VALUEHL 
48b2 cd 4b 22			call macro_dsp_valuehl 
48b5				endm 
# End of macro FORTH_DSP_VALUEHL
48b5			 
48b5 e5					push hl      ; string length 
48b6			 
48b6					FORTH_DSP_POP 
48b6 cd 03 23			call macro_forth_dsp_pop 
48b9				endm 
# End of macro FORTH_DSP_POP
48b9			 
48b9					FORTH_DSP_VALUEHL 
48b9 cd 4b 22			call macro_dsp_valuehl 
48bc				endm 
# End of macro FORTH_DSP_VALUEHL
48bc			 
48bc e5					push hl     ; start char 
48bd			 
48bd					FORTH_DSP_POP 
48bd cd 03 23			call macro_forth_dsp_pop 
48c0				endm 
# End of macro FORTH_DSP_POP
48c0			 
48c0			 
48c0					FORTH_DSP_VALUE 
48c0 cd 34 22			call macro_forth_dsp_value 
48c3				endm 
# End of macro FORTH_DSP_VALUE
48c3			 
48c3 d1					pop de    ; get start post offset 
48c4			 
48c4 19					add hl, de    ; starting offset 
48c5			 
48c5 c1					pop bc 
48c6 c5					push bc      ; grab size of string 
48c7			 
48c7 e5					push hl    ; save string start  
48c8			 
48c8 26 00				ld h, 0 
48ca 69					ld l, c 
48cb 23					inc hl 
48cc 23					inc hl 
48cd			 
48cd cd b9 13				call malloc 
48d0				if DEBUG_FORTH_MALLOC_GUARD 
48d0 cc 16 5e				call z,malloc_error 
48d3				endif 
48d3			 
48d3 eb					ex de, hl      ; save malloc area for string copy 
48d4 e1					pop hl    ; get back source 
48d5 c1					pop bc    ; get length of string back 
48d6			 
48d6 d5					push de    ; save malloc area for after we push 
48d7 ed b0				ldir     ; copy substr 
48d9			 
48d9			 
48d9 eb					ex de, hl 
48da 3e 00				ld a, 0 
48dc 77					ld (hl), a   ; term substr 
48dd			 
48dd					 
48dd e1					pop hl    ; get malloc so we can push it 
48de e5					push hl   ; save so we can free it afterwards 
48df			 
48df cd b4 20				call forth_push_str 
48e2			 
48e2 e1					pop hl 
48e3 cd 83 14				call free 
48e6			 
48e6					 
48e6					 
48e6			 
48e6			 
48e6					NEXTW 
48e6 c3 37 24			jp macro_next 
48e9				endm 
# End of macro NEXTW
48e9			 
48e9			.LEFT: 
48e9				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
48e9 48				db WORD_SYS_CORE+52             
48ea 11 49			dw .RIGHT            
48ec 05				db 4 + 1 
48ed .. 00			db "LEFT",0              
48f2				endm 
# End of macro CWHEAD
48f2			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
48f2					if DEBUG_FORTH_WORDS_KEY 
48f2						DMARK "LEF" 
48f2 f5				push af  
48f3 3a 07 49			ld a, (.dmark)  
48f6 32 a0 fd			ld (debug_mark),a  
48f9 3a 08 49			ld a, (.dmark+1)  
48fc 32 a1 fd			ld (debug_mark+1),a  
48ff 3a 09 49			ld a, (.dmark+2)  
4902 32 a2 fd			ld (debug_mark+2),a  
4905 18 03			jr .pastdmark  
4907 ..			.dmark: db "LEF"  
490a f1			.pastdmark: pop af  
490b			endm  
# End of macro DMARK
490b						CALLMONITOR 
490b cd aa fd			call debug_vector  
490e				endm  
# End of macro CALLMONITOR
490e					endif 
490e			 
490e					NEXTW 
490e c3 37 24			jp macro_next 
4911				endm 
# End of macro NEXTW
4911			.RIGHT: 
4911				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4911 48				db WORD_SYS_CORE+52             
4912 3a 49			dw .STR2NUM            
4914 06				db 5 + 1 
4915 .. 00			db "RIGHT",0              
491b				endm 
# End of macro CWHEAD
491b			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
491b					if DEBUG_FORTH_WORDS_KEY 
491b						DMARK "RIG" 
491b f5				push af  
491c 3a 30 49			ld a, (.dmark)  
491f 32 a0 fd			ld (debug_mark),a  
4922 3a 31 49			ld a, (.dmark+1)  
4925 32 a1 fd			ld (debug_mark+1),a  
4928 3a 32 49			ld a, (.dmark+2)  
492b 32 a2 fd			ld (debug_mark+2),a  
492e 18 03			jr .pastdmark  
4930 ..			.dmark: db "RIG"  
4933 f1			.pastdmark: pop af  
4934			endm  
# End of macro DMARK
4934						CALLMONITOR 
4934 cd aa fd			call debug_vector  
4937				endm  
# End of macro CALLMONITOR
4937					endif 
4937			 
4937					NEXTW 
4937 c3 37 24			jp macro_next 
493a				endm 
# End of macro NEXTW
493a			 
493a			 
493a			.STR2NUM: 
493a				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
493a 48				db WORD_SYS_CORE+52             
493b c6 49			dw .NUM2STR            
493d 08				db 7 + 1 
493e .. 00			db "STR2NUM",0              
4946				endm 
# End of macro CWHEAD
4946			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4946			 
4946			 
4946			; TODO STR type check to do 
4946					if DEBUG_FORTH_WORDS_KEY 
4946						DMARK "S2N" 
4946 f5				push af  
4947 3a 5b 49			ld a, (.dmark)  
494a 32 a0 fd			ld (debug_mark),a  
494d 3a 5c 49			ld a, (.dmark+1)  
4950 32 a1 fd			ld (debug_mark+1),a  
4953 3a 5d 49			ld a, (.dmark+2)  
4956 32 a2 fd			ld (debug_mark+2),a  
4959 18 03			jr .pastdmark  
495b ..			.dmark: db "S2N"  
495e f1			.pastdmark: pop af  
495f			endm  
# End of macro DMARK
495f						CALLMONITOR 
495f cd aa fd			call debug_vector  
4962				endm  
# End of macro CALLMONITOR
4962					endif 
4962			 
4962					;FORTH_DSP 
4962					FORTH_DSP_VALUE 
4962 cd 34 22			call macro_forth_dsp_value 
4965				endm 
# End of macro FORTH_DSP_VALUE
4965					;inc hl 
4965			 
4965 eb					ex de, hl 
4966					if DEBUG_FORTH_WORDS 
4966						DMARK "S2a" 
4966 f5				push af  
4967 3a 7b 49			ld a, (.dmark)  
496a 32 a0 fd			ld (debug_mark),a  
496d 3a 7c 49			ld a, (.dmark+1)  
4970 32 a1 fd			ld (debug_mark+1),a  
4973 3a 7d 49			ld a, (.dmark+2)  
4976 32 a2 fd			ld (debug_mark+2),a  
4979 18 03			jr .pastdmark  
497b ..			.dmark: db "S2a"  
497e f1			.pastdmark: pop af  
497f			endm  
# End of macro DMARK
497f						CALLMONITOR 
497f cd aa fd			call debug_vector  
4982				endm  
# End of macro CALLMONITOR
4982					endif 
4982 cd db 12				call string_to_uint16 
4985			 
4985					if DEBUG_FORTH_WORDS 
4985						DMARK "S2b" 
4985 f5				push af  
4986 3a 9a 49			ld a, (.dmark)  
4989 32 a0 fd			ld (debug_mark),a  
498c 3a 9b 49			ld a, (.dmark+1)  
498f 32 a1 fd			ld (debug_mark+1),a  
4992 3a 9c 49			ld a, (.dmark+2)  
4995 32 a2 fd			ld (debug_mark+2),a  
4998 18 03			jr .pastdmark  
499a ..			.dmark: db "S2b"  
499d f1			.pastdmark: pop af  
499e			endm  
# End of macro DMARK
499e						CALLMONITOR 
499e cd aa fd			call debug_vector  
49a1				endm  
# End of macro CALLMONITOR
49a1					endif 
49a1			;		push hl 
49a1					FORTH_DSP_POP 
49a1 cd 03 23			call macro_forth_dsp_pop 
49a4				endm 
# End of macro FORTH_DSP_POP
49a4			;		pop hl 
49a4					 
49a4					if DEBUG_FORTH_WORDS 
49a4						DMARK "S2b" 
49a4 f5				push af  
49a5 3a b9 49			ld a, (.dmark)  
49a8 32 a0 fd			ld (debug_mark),a  
49ab 3a ba 49			ld a, (.dmark+1)  
49ae 32 a1 fd			ld (debug_mark+1),a  
49b1 3a bb 49			ld a, (.dmark+2)  
49b4 32 a2 fd			ld (debug_mark+2),a  
49b7 18 03			jr .pastdmark  
49b9 ..			.dmark: db "S2b"  
49bc f1			.pastdmark: pop af  
49bd			endm  
# End of macro DMARK
49bd						CALLMONITOR 
49bd cd aa fd			call debug_vector  
49c0				endm  
# End of macro CALLMONITOR
49c0					endif 
49c0 cd 46 20				call forth_push_numhl	 
49c3			 
49c3				 
49c3				       NEXTW 
49c3 c3 37 24			jp macro_next 
49c6				endm 
# End of macro NEXTW
49c6			.NUM2STR: 
49c6				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
49c6 48				db WORD_SYS_CORE+52             
49c7 d5 49			dw .CONCAT            
49c9 08				db 7 + 1 
49ca .. 00			db "NUM2STR",0              
49d2				endm 
# End of macro CWHEAD
49d2			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
49d2			 
49d2			;		; malloc a string to target 
49d2			;		ld hl, 10     ; TODO max string size should be fine 
49d2			;		call malloc 
49d2			;		push hl    ; save malloc location 
49d2			; 
49d2			; 
49d2			;; TODO check int type 
49d2			;		FORTH_DSP_VALUEHL 
49d2			;		ld a, l 
49d2			;		call DispAToASCII   
49d2			;;TODO need to chage above call to dump into string 
49d2			; 
49d2			; 
49d2			 
49d2				       NEXTW 
49d2 c3 37 24			jp macro_next 
49d5				endm 
# End of macro NEXTW
49d5			 
49d5			.CONCAT: 
49d5				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
49d5 48				db WORD_SYS_CORE+52             
49d6 88 4a			dw .FIND            
49d8 07				db 6 + 1 
49d9 .. 00			db "CONCAT",0              
49e0				endm 
# End of macro CWHEAD
49e0			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
49e0			 
49e0			; TODO check string type 
49e0			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
49e0			 
49e0					if DEBUG_FORTH_WORDS_KEY 
49e0						DMARK "CON" 
49e0 f5				push af  
49e1 3a f5 49			ld a, (.dmark)  
49e4 32 a0 fd			ld (debug_mark),a  
49e7 3a f6 49			ld a, (.dmark+1)  
49ea 32 a1 fd			ld (debug_mark+1),a  
49ed 3a f7 49			ld a, (.dmark+2)  
49f0 32 a2 fd			ld (debug_mark+2),a  
49f3 18 03			jr .pastdmark  
49f5 ..			.dmark: db "CON"  
49f8 f1			.pastdmark: pop af  
49f9			endm  
# End of macro DMARK
49f9						CALLMONITOR 
49f9 cd aa fd			call debug_vector  
49fc				endm  
# End of macro CALLMONITOR
49fc					endif 
49fc			 
49fc			 
49fc					FORTH_DSP_VALUE 
49fc cd 34 22			call macro_forth_dsp_value 
49ff				endm 
# End of macro FORTH_DSP_VALUE
49ff e5					push hl   ; s2 
4a00			 
4a00					FORTH_DSP_POP 
4a00 cd 03 23			call macro_forth_dsp_pop 
4a03				endm 
# End of macro FORTH_DSP_POP
4a03			 
4a03					FORTH_DSP_VALUE 
4a03 cd 34 22			call macro_forth_dsp_value 
4a06				endm 
# End of macro FORTH_DSP_VALUE
4a06			 
4a06 e5					push hl   ; s1 
4a07			 
4a07					FORTH_DSP_POP 
4a07 cd 03 23			call macro_forth_dsp_pop 
4a0a				endm 
# End of macro FORTH_DSP_POP
4a0a					 
4a0a			 
4a0a					; copy s1 
4a0a			 
4a0a				 
4a0a					; save ptr 
4a0a e1					pop hl  
4a0b e5					push hl 
4a0c 3e 00				ld a, 0 
4a0e cd 4f 13				call strlent 
4a11					;inc hl    ; zer0 
4a11 06 00				ld b, 0 
4a13 4d					ld c, l 
4a14 e1					pop hl		 
4a15 11 f6 f0				ld de, scratch	 
4a18					if DEBUG_FORTH_WORDS 
4a18						DMARK "CO1" 
4a18 f5				push af  
4a19 3a 2d 4a			ld a, (.dmark)  
4a1c 32 a0 fd			ld (debug_mark),a  
4a1f 3a 2e 4a			ld a, (.dmark+1)  
4a22 32 a1 fd			ld (debug_mark+1),a  
4a25 3a 2f 4a			ld a, (.dmark+2)  
4a28 32 a2 fd			ld (debug_mark+2),a  
4a2b 18 03			jr .pastdmark  
4a2d ..			.dmark: db "CO1"  
4a30 f1			.pastdmark: pop af  
4a31			endm  
# End of macro DMARK
4a31						CALLMONITOR 
4a31 cd aa fd			call debug_vector  
4a34				endm  
# End of macro CALLMONITOR
4a34					endif 
4a34 ed b0				ldir 
4a36			 
4a36 e1					pop hl 
4a37 e5					push hl 
4a38 d5					push de 
4a39			 
4a39			 
4a39 3e 00				ld a, 0 
4a3b cd 4f 13				call strlent 
4a3e 23					inc hl    ; zer0 
4a3f 23					inc hl 
4a40 06 00				ld b, 0 
4a42 4d					ld c, l 
4a43 d1					pop de 
4a44 e1					pop hl		 
4a45					if DEBUG_FORTH_WORDS 
4a45						DMARK "CO2" 
4a45 f5				push af  
4a46 3a 5a 4a			ld a, (.dmark)  
4a49 32 a0 fd			ld (debug_mark),a  
4a4c 3a 5b 4a			ld a, (.dmark+1)  
4a4f 32 a1 fd			ld (debug_mark+1),a  
4a52 3a 5c 4a			ld a, (.dmark+2)  
4a55 32 a2 fd			ld (debug_mark+2),a  
4a58 18 03			jr .pastdmark  
4a5a ..			.dmark: db "CO2"  
4a5d f1			.pastdmark: pop af  
4a5e			endm  
# End of macro DMARK
4a5e						CALLMONITOR 
4a5e cd aa fd			call debug_vector  
4a61				endm  
# End of macro CALLMONITOR
4a61					endif 
4a61 ed b0				ldir 
4a63			 
4a63			 
4a63			 
4a63 21 f6 f0				ld hl, scratch 
4a66					if DEBUG_FORTH_WORDS 
4a66						DMARK "CO5" 
4a66 f5				push af  
4a67 3a 7b 4a			ld a, (.dmark)  
4a6a 32 a0 fd			ld (debug_mark),a  
4a6d 3a 7c 4a			ld a, (.dmark+1)  
4a70 32 a1 fd			ld (debug_mark+1),a  
4a73 3a 7d 4a			ld a, (.dmark+2)  
4a76 32 a2 fd			ld (debug_mark+2),a  
4a79 18 03			jr .pastdmark  
4a7b ..			.dmark: db "CO5"  
4a7e f1			.pastdmark: pop af  
4a7f			endm  
# End of macro DMARK
4a7f						CALLMONITOR 
4a7f cd aa fd			call debug_vector  
4a82				endm  
# End of macro CALLMONITOR
4a82					endif 
4a82			 
4a82 cd b4 20				call forth_push_str 
4a85			 
4a85			 
4a85			 
4a85			 
4a85				       NEXTW 
4a85 c3 37 24			jp macro_next 
4a88				endm 
# End of macro NEXTW
4a88			 
4a88			 
4a88			.FIND: 
4a88				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a88 4b				db WORD_SYS_CORE+55             
4a89 46 4b			dw .LEN            
4a8b 05				db 4 + 1 
4a8c .. 00			db "FIND",0              
4a91				endm 
# End of macro CWHEAD
4a91			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a91			 
4a91					if DEBUG_FORTH_WORDS_KEY 
4a91						DMARK "FND" 
4a91 f5				push af  
4a92 3a a6 4a			ld a, (.dmark)  
4a95 32 a0 fd			ld (debug_mark),a  
4a98 3a a7 4a			ld a, (.dmark+1)  
4a9b 32 a1 fd			ld (debug_mark+1),a  
4a9e 3a a8 4a			ld a, (.dmark+2)  
4aa1 32 a2 fd			ld (debug_mark+2),a  
4aa4 18 03			jr .pastdmark  
4aa6 ..			.dmark: db "FND"  
4aa9 f1			.pastdmark: pop af  
4aaa			endm  
# End of macro DMARK
4aaa						CALLMONITOR 
4aaa cd aa fd			call debug_vector  
4aad				endm  
# End of macro CALLMONITOR
4aad					endif 
4aad			 
4aad			; TODO check string type 
4aad					FORTH_DSP_VALUE 
4aad cd 34 22			call macro_forth_dsp_value 
4ab0				endm 
# End of macro FORTH_DSP_VALUE
4ab0			 
4ab0 e5					push hl    
4ab1 7e					ld a,(hl)    ; char to find   
4ab2			; TODO change char to substr 
4ab2			 
4ab2 f5					push af 
4ab3					 
4ab3			 
4ab3			 
4ab3					if DEBUG_FORTH_WORDS 
4ab3						DMARK "FN1" 
4ab3 f5				push af  
4ab4 3a c8 4a			ld a, (.dmark)  
4ab7 32 a0 fd			ld (debug_mark),a  
4aba 3a c9 4a			ld a, (.dmark+1)  
4abd 32 a1 fd			ld (debug_mark+1),a  
4ac0 3a ca 4a			ld a, (.dmark+2)  
4ac3 32 a2 fd			ld (debug_mark+2),a  
4ac6 18 03			jr .pastdmark  
4ac8 ..			.dmark: db "FN1"  
4acb f1			.pastdmark: pop af  
4acc			endm  
# End of macro DMARK
4acc						CALLMONITOR 
4acc cd aa fd			call debug_vector  
4acf				endm  
# End of macro CALLMONITOR
4acf					endif 
4acf			 
4acf					FORTH_DSP_POP 
4acf cd 03 23			call macro_forth_dsp_pop 
4ad2				endm 
# End of macro FORTH_DSP_POP
4ad2			 
4ad2					; string to search 
4ad2			 
4ad2					FORTH_DSP_VALUE 
4ad2 cd 34 22			call macro_forth_dsp_value 
4ad5				endm 
# End of macro FORTH_DSP_VALUE
4ad5			 
4ad5 d1					pop de  ; d is char to find  
4ad6			 
4ad6					if DEBUG_FORTH_WORDS 
4ad6						DMARK "FN2" 
4ad6 f5				push af  
4ad7 3a eb 4a			ld a, (.dmark)  
4ada 32 a0 fd			ld (debug_mark),a  
4add 3a ec 4a			ld a, (.dmark+1)  
4ae0 32 a1 fd			ld (debug_mark+1),a  
4ae3 3a ed 4a			ld a, (.dmark+2)  
4ae6 32 a2 fd			ld (debug_mark+2),a  
4ae9 18 03			jr .pastdmark  
4aeb ..			.dmark: db "FN2"  
4aee f1			.pastdmark: pop af  
4aef			endm  
# End of macro DMARK
4aef						CALLMONITOR 
4aef cd aa fd			call debug_vector  
4af2				endm  
# End of macro CALLMONITOR
4af2					endif 
4af2					 
4af2 01 00 00				ld bc, 0 
4af5 7e			.findchar:      ld a,(hl) 
4af6 fe 00				cp 0   		 
4af8 28 27				jr z, .finddone     
4afa ba					cp d 
4afb 28 20				jr z, .foundchar 
4afd 03					inc bc 
4afe 23					inc hl 
4aff					if DEBUG_FORTH_WORDS 
4aff						DMARK "FN3" 
4aff f5				push af  
4b00 3a 14 4b			ld a, (.dmark)  
4b03 32 a0 fd			ld (debug_mark),a  
4b06 3a 15 4b			ld a, (.dmark+1)  
4b09 32 a1 fd			ld (debug_mark+1),a  
4b0c 3a 16 4b			ld a, (.dmark+2)  
4b0f 32 a2 fd			ld (debug_mark+2),a  
4b12 18 03			jr .pastdmark  
4b14 ..			.dmark: db "FN3"  
4b17 f1			.pastdmark: pop af  
4b18			endm  
# End of macro DMARK
4b18						CALLMONITOR 
4b18 cd aa fd			call debug_vector  
4b1b				endm  
# End of macro CALLMONITOR
4b1b					endif 
4b1b 18 d8				jr .findchar 
4b1d			 
4b1d			 
4b1d c5			.foundchar:	push bc 
4b1e e1					pop hl 
4b1f 18 03				jr .findexit 
4b21			 
4b21			 
4b21							 
4b21			 
4b21			.finddone:     ; got to end of string with no find 
4b21 21 00 00				ld hl, 0 
4b24			.findexit: 
4b24			 
4b24					if DEBUG_FORTH_WORDS 
4b24						DMARK "FNd" 
4b24 f5				push af  
4b25 3a 39 4b			ld a, (.dmark)  
4b28 32 a0 fd			ld (debug_mark),a  
4b2b 3a 3a 4b			ld a, (.dmark+1)  
4b2e 32 a1 fd			ld (debug_mark+1),a  
4b31 3a 3b 4b			ld a, (.dmark+2)  
4b34 32 a2 fd			ld (debug_mark+2),a  
4b37 18 03			jr .pastdmark  
4b39 ..			.dmark: db "FNd"  
4b3c f1			.pastdmark: pop af  
4b3d			endm  
# End of macro DMARK
4b3d						CALLMONITOR 
4b3d cd aa fd			call debug_vector  
4b40				endm  
# End of macro CALLMONITOR
4b40					endif 
4b40 cd 46 20			call forth_push_numhl 
4b43			 
4b43				       NEXTW 
4b43 c3 37 24			jp macro_next 
4b46				endm 
# End of macro NEXTW
4b46			 
4b46			.LEN: 
4b46				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4b46 4c				db WORD_SYS_CORE+56             
4b47 b0 4b			dw .ASC            
4b49 06				db 5 + 1 
4b4a .. 00			db "COUNT",0              
4b50				endm 
# End of macro CWHEAD
4b50			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4b50			 
4b50					if DEBUG_FORTH_WORDS_KEY 
4b50						DMARK "CNT" 
4b50 f5				push af  
4b51 3a 65 4b			ld a, (.dmark)  
4b54 32 a0 fd			ld (debug_mark),a  
4b57 3a 66 4b			ld a, (.dmark+1)  
4b5a 32 a1 fd			ld (debug_mark+1),a  
4b5d 3a 67 4b			ld a, (.dmark+2)  
4b60 32 a2 fd			ld (debug_mark+2),a  
4b63 18 03			jr .pastdmark  
4b65 ..			.dmark: db "CNT"  
4b68 f1			.pastdmark: pop af  
4b69			endm  
# End of macro DMARK
4b69						CALLMONITOR 
4b69 cd aa fd			call debug_vector  
4b6c				endm  
# End of macro CALLMONITOR
4b6c					endif 
4b6c			; TODO check string type 
4b6c					FORTH_DSP_VALUE 
4b6c cd 34 22			call macro_forth_dsp_value 
4b6f				endm 
# End of macro FORTH_DSP_VALUE
4b6f			 
4b6f			 
4b6f					if DEBUG_FORTH_WORDS 
4b6f						DMARK "CN?" 
4b6f f5				push af  
4b70 3a 84 4b			ld a, (.dmark)  
4b73 32 a0 fd			ld (debug_mark),a  
4b76 3a 85 4b			ld a, (.dmark+1)  
4b79 32 a1 fd			ld (debug_mark+1),a  
4b7c 3a 86 4b			ld a, (.dmark+2)  
4b7f 32 a2 fd			ld (debug_mark+2),a  
4b82 18 03			jr .pastdmark  
4b84 ..			.dmark: db "CN?"  
4b87 f1			.pastdmark: pop af  
4b88			endm  
# End of macro DMARK
4b88						CALLMONITOR 
4b88 cd aa fd			call debug_vector  
4b8b				endm  
# End of macro CALLMONITOR
4b8b					endif 
4b8b cd 44 13				call strlenz 
4b8e					if DEBUG_FORTH_WORDS 
4b8e						DMARK "CNl" 
4b8e f5				push af  
4b8f 3a a3 4b			ld a, (.dmark)  
4b92 32 a0 fd			ld (debug_mark),a  
4b95 3a a4 4b			ld a, (.dmark+1)  
4b98 32 a1 fd			ld (debug_mark+1),a  
4b9b 3a a5 4b			ld a, (.dmark+2)  
4b9e 32 a2 fd			ld (debug_mark+2),a  
4ba1 18 03			jr .pastdmark  
4ba3 ..			.dmark: db "CNl"  
4ba6 f1			.pastdmark: pop af  
4ba7			endm  
# End of macro DMARK
4ba7						CALLMONITOR 
4ba7 cd aa fd			call debug_vector  
4baa				endm  
# End of macro CALLMONITOR
4baa					endif 
4baa			 
4baa cd 46 20				call forth_push_numhl 
4bad			 
4bad			 
4bad			 
4bad				       NEXTW 
4bad c3 37 24			jp macro_next 
4bb0				endm 
# End of macro NEXTW
4bb0			.ASC: 
4bb0				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4bb0 4d				db WORD_SYS_CORE+57             
4bb1 1e 4c			dw .CHR            
4bb3 04				db 3 + 1 
4bb4 .. 00			db "ASC",0              
4bb8				endm 
# End of macro CWHEAD
4bb8			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4bb8					if DEBUG_FORTH_WORDS_KEY 
4bb8						DMARK "ASC" 
4bb8 f5				push af  
4bb9 3a cd 4b			ld a, (.dmark)  
4bbc 32 a0 fd			ld (debug_mark),a  
4bbf 3a ce 4b			ld a, (.dmark+1)  
4bc2 32 a1 fd			ld (debug_mark+1),a  
4bc5 3a cf 4b			ld a, (.dmark+2)  
4bc8 32 a2 fd			ld (debug_mark+2),a  
4bcb 18 03			jr .pastdmark  
4bcd ..			.dmark: db "ASC"  
4bd0 f1			.pastdmark: pop af  
4bd1			endm  
# End of macro DMARK
4bd1						CALLMONITOR 
4bd1 cd aa fd			call debug_vector  
4bd4				endm  
# End of macro CALLMONITOR
4bd4					endif 
4bd4					FORTH_DSP_VALUE 
4bd4 cd 34 22			call macro_forth_dsp_value 
4bd7				endm 
# End of macro FORTH_DSP_VALUE
4bd7					;v5 FORTH_DSP_VALUE 
4bd7			;		inc hl      ; now at start of numeric as string 
4bd7			 
4bd7 e5					push hl 
4bd8			 
4bd8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bd8 cd 03 23			call macro_forth_dsp_pop 
4bdb				endm 
# End of macro FORTH_DSP_POP
4bdb			 
4bdb e1					pop hl 
4bdc			 
4bdc					if DEBUG_FORTH_WORDS 
4bdc						DMARK "AS1" 
4bdc f5				push af  
4bdd 3a f1 4b			ld a, (.dmark)  
4be0 32 a0 fd			ld (debug_mark),a  
4be3 3a f2 4b			ld a, (.dmark+1)  
4be6 32 a1 fd			ld (debug_mark+1),a  
4be9 3a f3 4b			ld a, (.dmark+2)  
4bec 32 a2 fd			ld (debug_mark+2),a  
4bef 18 03			jr .pastdmark  
4bf1 ..			.dmark: db "AS1"  
4bf4 f1			.pastdmark: pop af  
4bf5			endm  
# End of macro DMARK
4bf5						CALLMONITOR 
4bf5 cd aa fd			call debug_vector  
4bf8				endm  
# End of macro CALLMONITOR
4bf8					endif 
4bf8					; push the content of a onto the stack as a value 
4bf8			 
4bf8 7e					ld a,(hl)   ; get char 
4bf9 26 00				ld h,0 
4bfb 6f					ld l,a 
4bfc					if DEBUG_FORTH_WORDS 
4bfc						DMARK "AS2" 
4bfc f5				push af  
4bfd 3a 11 4c			ld a, (.dmark)  
4c00 32 a0 fd			ld (debug_mark),a  
4c03 3a 12 4c			ld a, (.dmark+1)  
4c06 32 a1 fd			ld (debug_mark+1),a  
4c09 3a 13 4c			ld a, (.dmark+2)  
4c0c 32 a2 fd			ld (debug_mark+2),a  
4c0f 18 03			jr .pastdmark  
4c11 ..			.dmark: db "AS2"  
4c14 f1			.pastdmark: pop af  
4c15			endm  
# End of macro DMARK
4c15						CALLMONITOR 
4c15 cd aa fd			call debug_vector  
4c18				endm  
# End of macro CALLMONITOR
4c18					endif 
4c18 cd 46 20				call forth_push_numhl 
4c1b			 
4c1b				       NEXTW 
4c1b c3 37 24			jp macro_next 
4c1e				endm 
# End of macro NEXTW
4c1e			 
4c1e			.CHR: 
4c1e				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4c1e 4d				db WORD_SYS_CORE+57             
4c1f 5a 4c			dw .ENDSTR            
4c21 04				db 3 + 1 
4c22 .. 00			db "CHR",0              
4c26				endm 
# End of macro CWHEAD
4c26			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4c26					if DEBUG_FORTH_WORDS_KEY 
4c26						DMARK "CHR" 
4c26 f5				push af  
4c27 3a 3b 4c			ld a, (.dmark)  
4c2a 32 a0 fd			ld (debug_mark),a  
4c2d 3a 3c 4c			ld a, (.dmark+1)  
4c30 32 a1 fd			ld (debug_mark+1),a  
4c33 3a 3d 4c			ld a, (.dmark+2)  
4c36 32 a2 fd			ld (debug_mark+2),a  
4c39 18 03			jr .pastdmark  
4c3b ..			.dmark: db "CHR"  
4c3e f1			.pastdmark: pop af  
4c3f			endm  
# End of macro DMARK
4c3f						CALLMONITOR 
4c3f cd aa fd			call debug_vector  
4c42				endm  
# End of macro CALLMONITOR
4c42					endif 
4c42					FORTH_DSP_VALUEHL 
4c42 cd 4b 22			call macro_dsp_valuehl 
4c45				endm 
# End of macro FORTH_DSP_VALUEHL
4c45			 
4c45					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c45 cd 03 23			call macro_forth_dsp_pop 
4c48				endm 
# End of macro FORTH_DSP_POP
4c48			 
4c48					; save asci byte as a zero term string and push string 
4c48			 
4c48 7d					ld a,l 
4c49 32 f6 f0				ld (scratch), a 
4c4c			 
4c4c 3e 00				ld a, 0 
4c4e 32 f7 f0				ld (scratch+1), a 
4c51			 
4c51 21 f6 f0				ld hl, scratch 
4c54 cd b4 20				call forth_push_str 
4c57			 
4c57			 
4c57				       NEXTW 
4c57 c3 37 24			jp macro_next 
4c5a				endm 
# End of macro NEXTW
4c5a			 
4c5a			 
4c5a			 
4c5a			 
4c5a			.ENDSTR: 
4c5a			; eof 
4c5a			 
# End of file forth_words_str.asm
4c5a			include "forth_words_key.asm" 
4c5a			 
4c5a			; | ## Keyboard Words 
4c5a			 
4c5a			.KEY: 
4c5a				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4c5a 3e				db WORD_SYS_CORE+42             
4c5b 8a 4c			dw .WAITK            
4c5d 04				db 3 + 1 
4c5e .. 00			db "KEY",0              
4c62				endm 
# End of macro CWHEAD
4c62			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4c62			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4c62			; | | Can use something like this to process: 
4c62			; | | > repeat active . key ?dup if emit then #1 until  
4c62			 
4c62					if DEBUG_FORTH_WORDS_KEY 
4c62						DMARK "KEY" 
4c62 f5				push af  
4c63 3a 77 4c			ld a, (.dmark)  
4c66 32 a0 fd			ld (debug_mark),a  
4c69 3a 78 4c			ld a, (.dmark+1)  
4c6c 32 a1 fd			ld (debug_mark+1),a  
4c6f 3a 79 4c			ld a, (.dmark+2)  
4c72 32 a2 fd			ld (debug_mark+2),a  
4c75 18 03			jr .pastdmark  
4c77 ..			.dmark: db "KEY"  
4c7a f1			.pastdmark: pop af  
4c7b			endm  
# End of macro DMARK
4c7b						CALLMONITOR 
4c7b cd aa fd			call debug_vector  
4c7e				endm  
# End of macro CALLMONITOR
4c7e					endif 
4c7e			; TODO currently waits 
4c7e cd 1d 73				call cin 
4c81					;call cin_wait 
4c81 6f					ld l, a 
4c82 26 00				ld h, 0 
4c84 cd 46 20				call forth_push_numhl 
4c87					NEXTW 
4c87 c3 37 24			jp macro_next 
4c8a				endm 
# End of macro NEXTW
4c8a			.WAITK: 
4c8a				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c8a 3f				db WORD_SYS_CORE+43             
4c8b bc 4c			dw .ACCEPT            
4c8d 06				db 5 + 1 
4c8e .. 00			db "WAITK",0              
4c94				endm 
# End of macro CWHEAD
4c94			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c94					if DEBUG_FORTH_WORDS_KEY 
4c94						DMARK "WAI" 
4c94 f5				push af  
4c95 3a a9 4c			ld a, (.dmark)  
4c98 32 a0 fd			ld (debug_mark),a  
4c9b 3a aa 4c			ld a, (.dmark+1)  
4c9e 32 a1 fd			ld (debug_mark+1),a  
4ca1 3a ab 4c			ld a, (.dmark+2)  
4ca4 32 a2 fd			ld (debug_mark+2),a  
4ca7 18 03			jr .pastdmark  
4ca9 ..			.dmark: db "WAI"  
4cac f1			.pastdmark: pop af  
4cad			endm  
# End of macro DMARK
4cad						CALLMONITOR 
4cad cd aa fd			call debug_vector  
4cb0				endm  
# End of macro CALLMONITOR
4cb0					endif 
4cb0 cd 0c 73				call cin_wait 
4cb3 6f					ld l, a 
4cb4 26 00				ld h, 0 
4cb6 cd 46 20				call forth_push_numhl 
4cb9					NEXTW 
4cb9 c3 37 24			jp macro_next 
4cbc				endm 
# End of macro NEXTW
4cbc			.ACCEPT: 
4cbc				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4cbc 40				db WORD_SYS_CORE+44             
4cbd 1a 4d			dw .EDIT            
4cbf 07				db 6 + 1 
4cc0 .. 00			db "ACCEPT",0              
4cc7				endm 
# End of macro CWHEAD
4cc7			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4cc7					; TODO crashes on push 
4cc7					if DEBUG_FORTH_WORDS_KEY 
4cc7						DMARK "ACC" 
4cc7 f5				push af  
4cc8 3a dc 4c			ld a, (.dmark)  
4ccb 32 a0 fd			ld (debug_mark),a  
4cce 3a dd 4c			ld a, (.dmark+1)  
4cd1 32 a1 fd			ld (debug_mark+1),a  
4cd4 3a de 4c			ld a, (.dmark+2)  
4cd7 32 a2 fd			ld (debug_mark+2),a  
4cda 18 03			jr .pastdmark  
4cdc ..			.dmark: db "ACC"  
4cdf f1			.pastdmark: pop af  
4ce0			endm  
# End of macro DMARK
4ce0						CALLMONITOR 
4ce0 cd aa fd			call debug_vector  
4ce3				endm  
# End of macro CALLMONITOR
4ce3					endif 
4ce3 21 f4 f2				ld hl, os_input 
4ce6 3e 00				ld a, 0 
4ce8 77					ld (hl),a 
4ce9 3a 93 f9				ld a,(f_cursor_ptr) 
4cec 16 64				ld d, 100 
4cee 0e 00				ld c, 0 
4cf0 1e 28				ld e, 40 
4cf2 cd 0b 10				call input_str 
4cf5					; TODO perhaps do a type check and wrap in quotes if not a number 
4cf5 21 f4 f2				ld hl, os_input 
4cf8					if DEBUG_FORTH_WORDS 
4cf8						DMARK "AC1" 
4cf8 f5				push af  
4cf9 3a 0d 4d			ld a, (.dmark)  
4cfc 32 a0 fd			ld (debug_mark),a  
4cff 3a 0e 4d			ld a, (.dmark+1)  
4d02 32 a1 fd			ld (debug_mark+1),a  
4d05 3a 0f 4d			ld a, (.dmark+2)  
4d08 32 a2 fd			ld (debug_mark+2),a  
4d0b 18 03			jr .pastdmark  
4d0d ..			.dmark: db "AC1"  
4d10 f1			.pastdmark: pop af  
4d11			endm  
# End of macro DMARK
4d11						CALLMONITOR 
4d11 cd aa fd			call debug_vector  
4d14				endm  
# End of macro CALLMONITOR
4d14					endif 
4d14 cd b4 20				call forth_push_str 
4d17					NEXTW 
4d17 c3 37 24			jp macro_next 
4d1a				endm 
# End of macro NEXTW
4d1a			 
4d1a			.EDIT: 
4d1a				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4d1a 40				db WORD_SYS_CORE+44             
4d1b bc 4d			dw .DEDIT            
4d1d 05				db 4 + 1 
4d1e .. 00			db "EDIT",0              
4d23				endm 
# End of macro CWHEAD
4d23			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4d23			 
4d23					; TODO does not copy from stack 
4d23					if DEBUG_FORTH_WORDS_KEY 
4d23						DMARK "EDT" 
4d23 f5				push af  
4d24 3a 38 4d			ld a, (.dmark)  
4d27 32 a0 fd			ld (debug_mark),a  
4d2a 3a 39 4d			ld a, (.dmark+1)  
4d2d 32 a1 fd			ld (debug_mark+1),a  
4d30 3a 3a 4d			ld a, (.dmark+2)  
4d33 32 a2 fd			ld (debug_mark+2),a  
4d36 18 03			jr .pastdmark  
4d38 ..			.dmark: db "EDT"  
4d3b f1			.pastdmark: pop af  
4d3c			endm  
# End of macro DMARK
4d3c						CALLMONITOR 
4d3c cd aa fd			call debug_vector  
4d3f				endm  
# End of macro CALLMONITOR
4d3f					endif 
4d3f			 
4d3f					;FORTH_DSP 
4d3f					FORTH_DSP_VALUEHL 
4d3f cd 4b 22			call macro_dsp_valuehl 
4d42				endm 
# End of macro FORTH_DSP_VALUEHL
4d42			;		inc hl    ; TODO do type check 
4d42			 
4d42			;		call get_word_hl 
4d42 e5					push hl 
4d43					if DEBUG_FORTH_WORDS 
4d43						DMARK "EDp" 
4d43 f5				push af  
4d44 3a 58 4d			ld a, (.dmark)  
4d47 32 a0 fd			ld (debug_mark),a  
4d4a 3a 59 4d			ld a, (.dmark+1)  
4d4d 32 a1 fd			ld (debug_mark+1),a  
4d50 3a 5a 4d			ld a, (.dmark+2)  
4d53 32 a2 fd			ld (debug_mark+2),a  
4d56 18 03			jr .pastdmark  
4d58 ..			.dmark: db "EDp"  
4d5b f1			.pastdmark: pop af  
4d5c			endm  
# End of macro DMARK
4d5c						CALLMONITOR 
4d5c cd aa fd			call debug_vector  
4d5f				endm  
# End of macro CALLMONITOR
4d5f					endif 
4d5f				;	ld a, 0 
4d5f cd 44 13				call strlenz 
4d62 23					inc hl 
4d63			 
4d63 06 00				ld b, 0 
4d65 4d					ld c, l 
4d66			 
4d66 e1					pop hl 
4d67 11 f4 f2				ld de, os_input 
4d6a					if DEBUG_FORTH_WORDS_KEY 
4d6a						DMARK "EDc" 
4d6a f5				push af  
4d6b 3a 7f 4d			ld a, (.dmark)  
4d6e 32 a0 fd			ld (debug_mark),a  
4d71 3a 80 4d			ld a, (.dmark+1)  
4d74 32 a1 fd			ld (debug_mark+1),a  
4d77 3a 81 4d			ld a, (.dmark+2)  
4d7a 32 a2 fd			ld (debug_mark+2),a  
4d7d 18 03			jr .pastdmark  
4d7f ..			.dmark: db "EDc"  
4d82 f1			.pastdmark: pop af  
4d83			endm  
# End of macro DMARK
4d83						CALLMONITOR 
4d83 cd aa fd			call debug_vector  
4d86				endm  
# End of macro CALLMONITOR
4d86					endif 
4d86 ed b0				ldir 
4d88			 
4d88			 
4d88 21 f4 f2				ld hl, os_input 
4d8b					;ld a, 0 
4d8b					;ld (hl),a 
4d8b 3a 93 f9				ld a,(f_cursor_ptr) 
4d8e 16 64				ld d, 100 
4d90 0e 00				ld c, 0 
4d92 1e 28				ld e, 40 
4d94 cd 0b 10				call input_str 
4d97					; TODO perhaps do a type check and wrap in quotes if not a number 
4d97 21 f4 f2				ld hl, os_input 
4d9a					if DEBUG_FORTH_WORDS 
4d9a						DMARK "ED1" 
4d9a f5				push af  
4d9b 3a af 4d			ld a, (.dmark)  
4d9e 32 a0 fd			ld (debug_mark),a  
4da1 3a b0 4d			ld a, (.dmark+1)  
4da4 32 a1 fd			ld (debug_mark+1),a  
4da7 3a b1 4d			ld a, (.dmark+2)  
4daa 32 a2 fd			ld (debug_mark+2),a  
4dad 18 03			jr .pastdmark  
4daf ..			.dmark: db "ED1"  
4db2 f1			.pastdmark: pop af  
4db3			endm  
# End of macro DMARK
4db3						CALLMONITOR 
4db3 cd aa fd			call debug_vector  
4db6				endm  
# End of macro CALLMONITOR
4db6					endif 
4db6 cd b4 20				call forth_push_str 
4db9					NEXTW 
4db9 c3 37 24			jp macro_next 
4dbc				endm 
# End of macro NEXTW
4dbc			 
4dbc			.DEDIT: 
4dbc				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4dbc 40				db WORD_SYS_CORE+44             
4dbd 1e 4e			dw .ENDKEY            
4dbf 06				db 5 + 1 
4dc0 .. 00			db "DEDIT",0              
4dc6				endm 
# End of macro CWHEAD
4dc6			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4dc6			 
4dc6					; TODO does not copy from stack 
4dc6					if DEBUG_FORTH_WORDS_KEY 
4dc6						DMARK "DED" 
4dc6 f5				push af  
4dc7 3a db 4d			ld a, (.dmark)  
4dca 32 a0 fd			ld (debug_mark),a  
4dcd 3a dc 4d			ld a, (.dmark+1)  
4dd0 32 a1 fd			ld (debug_mark+1),a  
4dd3 3a dd 4d			ld a, (.dmark+2)  
4dd6 32 a2 fd			ld (debug_mark+2),a  
4dd9 18 03			jr .pastdmark  
4ddb ..			.dmark: db "DED"  
4dde f1			.pastdmark: pop af  
4ddf			endm  
# End of macro DMARK
4ddf						CALLMONITOR 
4ddf cd aa fd			call debug_vector  
4de2				endm  
# End of macro CALLMONITOR
4de2					endif 
4de2			 
4de2					;FORTH_DSP 
4de2					FORTH_DSP_VALUEHL 
4de2 cd 4b 22			call macro_dsp_valuehl 
4de5				endm 
# End of macro FORTH_DSP_VALUEHL
4de5			;		inc hl    ; TODO do type check 
4de5			 
4de5			;		call get_word_hl 
4de5 e5					push hl 
4de6 e5					push hl 
4de7					FORTH_DSP_POP 
4de7 cd 03 23			call macro_forth_dsp_pop 
4dea				endm 
# End of macro FORTH_DSP_POP
4dea e1					pop hl 
4deb					if DEBUG_FORTH_WORDS 
4deb						DMARK "EDp" 
4deb f5				push af  
4dec 3a 00 4e			ld a, (.dmark)  
4def 32 a0 fd			ld (debug_mark),a  
4df2 3a 01 4e			ld a, (.dmark+1)  
4df5 32 a1 fd			ld (debug_mark+1),a  
4df8 3a 02 4e			ld a, (.dmark+2)  
4dfb 32 a2 fd			ld (debug_mark+2),a  
4dfe 18 03			jr .pastdmark  
4e00 ..			.dmark: db "EDp"  
4e03 f1			.pastdmark: pop af  
4e04			endm  
# End of macro DMARK
4e04						CALLMONITOR 
4e04 cd aa fd			call debug_vector  
4e07				endm  
# End of macro CALLMONITOR
4e07					endif 
4e07				;	ld a, 0 
4e07 cd 44 13				call strlenz 
4e0a 23					inc hl 
4e0b			 
4e0b 06 00				ld b, 0 
4e0d 4d					ld c, l 
4e0e			 
4e0e e1					pop hl 
4e0f			 
4e0f					;ld a, 0 
4e0f					;ld (hl),a 
4e0f 3a 93 f9				ld a,(f_cursor_ptr) 
4e12 16 64				ld d, 100 
4e14 0e 00				ld c, 0 
4e16 1e 28				ld e, 40 
4e18 cd 0b 10				call input_str 
4e1b					; TODO perhaps do a type check and wrap in quotes if not a number 
4e1b					NEXTW 
4e1b c3 37 24			jp macro_next 
4e1e				endm 
# End of macro NEXTW
4e1e			 
4e1e			 
4e1e			.ENDKEY: 
4e1e			; eof 
4e1e			 
# End of file forth_words_key.asm
4e1e			include "forth_words_const.asm" 
4e1e			 
4e1e			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4e1e			 
4e1e			 
4e1e			.SPITIME: 
4e1e				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4e1e 77				db WORD_SYS_CORE+99             
4e1f 33 4e			dw .VA            
4e21 08				db 7 + 1 
4e22 .. 00			db "SPITIME",0              
4e2a				endm 
# End of macro CWHEAD
4e2a			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4e2a			; 
4e2a			; | | If using BANK devices then leave as is. 
4e2a			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4e2a			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4e2a			 
4e2a 21 99 f9				ld hl, spi_clktime  
4e2d cd 46 20				call forth_push_numhl 
4e30			 
4e30					NEXTW 
4e30 c3 37 24			jp macro_next 
4e33				endm 
# End of macro NEXTW
4e33			 
4e33			 
4e33			.VA: 
4e33				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4e33 77				db WORD_SYS_CORE+99             
4e34 43 4e			dw .SYMBOL            
4e36 03				db 2 + 1 
4e37 .. 00			db "VA",0              
4e3a				endm 
# End of macro CWHEAD
4e3a			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4e3a 21 5d f9				ld hl, cli_var_array 
4e3d cd 46 20				call forth_push_numhl 
4e40			 
4e40					NEXTW 
4e40 c3 37 24			jp macro_next 
4e43				endm 
# End of macro NEXTW
4e43			 
4e43			.SYMBOL: 
4e43				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4e43 77				db WORD_SYS_CORE+99             
4e44 4d 4f			dw .ENDCONST            
4e46 07				db 6 + 1 
4e47 .. 00			db "SYMBOL",0              
4e4e				endm 
# End of macro CWHEAD
4e4e			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4e4e			; | 
4e4e			; | | The value is the number reference and the final address is pushed to stack 
4e4e			 
4e4e			; | | ``` 
4e4e			; | | dw sym_table 
4e4e			; | | dw nmi_vector 
4e4e			; | | dw cli_autodisplay 
4e4e			; | | dw cli_data_sp 
4e4e			; | | dw cli_data_stack 
4e4e			; | | dw cli_loop_sp 
4e4e			; | | dw cli_loop_stack 
4e4e			; | | dw cli_var_array 
4e4e			; | | dw cursor_col 
4e4e			; | | dw cursor_ptr 
4e4e			; | | ; 10 
4e4e			; | | dw cursor_row 
4e4e			; | | dw debug_mark 
4e4e			; | | dw display_fb0 
4e4e			; | | dw display_fb1 
4e4e			; | | dw display_fb2 
4e4e			; | | dw display_fb3 
4e4e			; | | dw display_fb_active 
4e4e			; | | dw execscratch 
4e4e			; | | dw f_cursor_ptr 
4e4e			; | | dw hardware_word 
4e4e			; | | ;20 
4e4e			; | | dw input_at_cursor 
4e4e			; | | dw input_at_pos 
4e4e			; | | dw input_cur_flash 
4e4e			; | | dw input_cur_onoff 
4e4e			; | | dw input_cursor 
4e4e			; | | dw input_display_size 
4e4e			; | | dw input_len 
4e4e			; | | dw input_ptr 
4e4e			; | | dw input_size 
4e4e			; | | dw input_start 
4e4e			; | | ; 30 
4e4e			; | | dw input_str 
4e4e			; | | dw input_under_cursor 
4e4e			; | | dw os_cli_cmd 
4e4e			; | | dw os_cur_ptr 
4e4e			; | | dw os_current_i 
4e4e			; | | dw os_input 
4e4e			; | | dw os_last_cmd 
4e4e			; | | dw os_last_new_uword 
4e4e			; | | dw debug_vector 
4e4e			; | | dw os_view_hl 
4e4e			; | | ;40 
4e4e			; | | dw os_word_scratch 
4e4e			; | | dw portbctl 
4e4e			; | | dw portbdata 
4e4e			; | | dw spi_cartdev 
4e4e			; | | dw spi_cartdev2 
4e4e			; | | dw spi_clktime 
4e4e			; | | dw spi_device 
4e4e			; | | dw spi_device_id 
4e4e			; | | dw spi_portbyte 
4e4e			; | | dw stackstore 
4e4e			; | | ; 50 
4e4e			; | | if STORAGE_SE 
4e4e			; | | dw storage_actl 
4e4e			; | | dw storage_adata 
4e4e			; | | else 
4e4e			; | | dw 0 
4e4e			; | | dw 0 
4e4e			; | | endif 
4e4e			; | | dw storage_append 
4e4e			; | | if STORAGE_SE 
4e4e			; | | dw storage_bctl 
4e4e			; | | else 
4e4e			; | | dw 0 
4e4e			; | | endif 
4e4e			; | | dw store_bank_active 
4e4e			; | | dw store_filecache 
4e4e			; | | dw store_longread 
4e4e			; | | dw store_openaddr 
4e4e			; | | dw store_openext 
4e4e			; | | dw store_openmaxext 
4e4e			; | | ; 60 
4e4e			; | | dw store_page 
4e4e			; | | dw store_readbuf 
4e4e			; | | dw store_readcont 
4e4e			; | | dw store_readptr 
4e4e			; | | dw store_tmpext 
4e4e			; | | dw store_tmpid 
4e4e			; | | dw store_tmppageid 
4e4e			; | | dw malloc 
4e4e			; | | dw free 
4e4e			; | | dw cin 
4e4e			; | | ; 70 
4e4e			; | | dw cin_wait 
4e4e			; | | dw forth_push_numhl 
4e4e			; | | dw forth_push_str 
4e4e			; | | ``` 
4e4e			 
4e4e					if DEBUG_FORTH_WORDS_KEY 
4e4e						DMARK "SYM" 
4e4e f5				push af  
4e4f 3a 63 4e			ld a, (.dmark)  
4e52 32 a0 fd			ld (debug_mark),a  
4e55 3a 64 4e			ld a, (.dmark+1)  
4e58 32 a1 fd			ld (debug_mark+1),a  
4e5b 3a 65 4e			ld a, (.dmark+2)  
4e5e 32 a2 fd			ld (debug_mark+2),a  
4e61 18 03			jr .pastdmark  
4e63 ..			.dmark: db "SYM"  
4e66 f1			.pastdmark: pop af  
4e67			endm  
# End of macro DMARK
4e67						CALLMONITOR 
4e67 cd aa fd			call debug_vector  
4e6a				endm  
# End of macro CALLMONITOR
4e6a					endif 
4e6a			 
4e6a					FORTH_DSP_VALUEHL 
4e6a cd 4b 22			call macro_dsp_valuehl 
4e6d				endm 
# End of macro FORTH_DSP_VALUEHL
4e6d			 
4e6d 7d					ld a, l     
4e6e			 
4e6e			 
4e6e					if DEBUG_FORTH_WORDS 
4e6e						DMARK "SY1" 
4e6e f5				push af  
4e6f 3a 83 4e			ld a, (.dmark)  
4e72 32 a0 fd			ld (debug_mark),a  
4e75 3a 84 4e			ld a, (.dmark+1)  
4e78 32 a1 fd			ld (debug_mark+1),a  
4e7b 3a 85 4e			ld a, (.dmark+2)  
4e7e 32 a2 fd			ld (debug_mark+2),a  
4e81 18 03			jr .pastdmark  
4e83 ..			.dmark: db "SY1"  
4e86 f1			.pastdmark: pop af  
4e87			endm  
# End of macro DMARK
4e87						CALLMONITOR 
4e87 cd aa fd			call debug_vector  
4e8a				endm  
# End of macro CALLMONITOR
4e8a					endif 
4e8a					 
4e8a f5					push af	 
4e8b					FORTH_DSP_POP 
4e8b cd 03 23			call macro_forth_dsp_pop 
4e8e				endm 
# End of macro FORTH_DSP_POP
4e8e f1					pop af 
4e8f			 
4e8f cb 27				sla a  
4e91				 
4e91					 
4e91					if DEBUG_FORTH_WORDS 
4e91						DMARK "SY" 
4e91 f5				push af  
4e92 3a a6 4e			ld a, (.dmark)  
4e95 32 a0 fd			ld (debug_mark),a  
4e98 3a a7 4e			ld a, (.dmark+1)  
4e9b 32 a1 fd			ld (debug_mark+1),a  
4e9e 3a a8 4e			ld a, (.dmark+2)  
4ea1 32 a2 fd			ld (debug_mark+2),a  
4ea4 18 02			jr .pastdmark  
4ea6 ..			.dmark: db "SY"  
4ea8 f1			.pastdmark: pop af  
4ea9			endm  
# End of macro DMARK
4ea9						CALLMONITOR 
4ea9 cd aa fd			call debug_vector  
4eac				endm  
# End of macro CALLMONITOR
4eac					endif 
4eac			 
4eac 21 bb 4e				ld hl, sym_table 
4eaf cd de 0f				call addatohl 
4eb2 cd b9 23				call loadwordinhl 
4eb5 cd 46 20				call forth_push_numhl 
4eb8			 
4eb8			 
4eb8				       NEXTW 
4eb8 c3 37 24			jp macro_next 
4ebb				endm 
# End of macro NEXTW
4ebb			 
4ebb			sym_table: 
4ebb			 
4ebb			; 0 
4ebb bb 4e		dw sym_table 
4ebd ad fd		dw nmi_vector 
4ebf 71 f9		dw cli_autodisplay 
4ec1 23 f9		dw cli_data_sp 
4ec3 5d f6		dw cli_data_stack 
4ec5 25 f9		dw cli_loop_sp 
4ec7 5f f8		dw cli_loop_stack 
4ec9 5d f9		dw cli_var_array 
4ecb fa fa		dw cursor_col 
4ecd f8 fa		dw cursor_ptr 
4ecf			; 10 
4ecf f9 fa		dw cursor_row 
4ed1 a0 fd		dw debug_mark 
4ed3 e6 fc		dw display_fb0 
4ed5 45 fc		dw display_fb1 
4ed7 03 fb		dw display_fb2 
4ed9 a4 fb		dw display_fb3 
4edb 01 fb		dw display_fb_active 
4edd f5 f1		dw execscratch 
4edf 93 f9		dw f_cursor_ptr 
4ee1 b0 fd		dw hardware_word 
4ee3			;20 
4ee3 97 fd		dw input_at_cursor 
4ee5 99 fd		dw input_at_pos 
4ee7 95 fd		dw input_cur_flash 
4ee9 94 fd		dw input_cur_onoff 
4eeb 8a fd		dw input_cursor 
4eed 9a fd		dw input_display_size 
4eef 8f fd		dw input_len 
4ef1 9e fd		dw input_ptr 
4ef3 9b fd		dw input_size 
4ef5 9c fd		dw input_start 
4ef7			; 30 
4ef7 0b 10		dw input_str 
4ef9 98 fd		dw input_under_cursor 
4efb 1d f4		dw os_cli_cmd 
4efd 19 f4		dw os_cur_ptr 
4eff 1b f4		dw os_current_i 
4f01 f4 f2		dw os_input 
4f03 1c f5		dw os_last_cmd 
4f05 f3 f3		dw os_last_new_uword 
4f07 aa fd		dw debug_vector 
4f09 d8 f0		dw os_view_hl 
4f0b			;40 
4f0b fb f3		dw os_word_scratch 
4f0d c3 00		dw portbctl 
4f0f c1 00		dw portbdata 
4f11 98 f9		dw spi_cartdev 
4f13 97 f9		dw spi_cartdev2 
4f15 99 f9		dw spi_clktime 
4f17 95 f9		dw spi_device 
4f19 94 f9		dw spi_device_id 
4f1b 96 f9		dw spi_portbyte 
4f1d dc fa		dw stackstore 
4f1f			; 50 
4f1f			if STORAGE_SE 
4f1f 82 00		dw storage_actl 
4f21 80 00		dw storage_adata 
4f23			else 
4f23			dw 0 
4f23			dw 0 
4f23			endif 
4f23 64 0b		dw storage_append 
4f25			if STORAGE_SE 
4f25 83 00		dw storage_bctl 
4f27			else 
4f27			dw 0 
4f27			endif 
4f27 c8 fa		dw store_bank_active 
4f29 9c f9		dw store_filecache 
4f2b aa f9		dw store_longread 
4f2d a0 f9		dw store_openaddr 
4f2f 9f f9		dw store_openext 
4f31 9e f9		dw store_openmaxext 
4f33			; 60 
4f33 af f9		dw store_page 
4f35 ab f9		dw store_readbuf 
4f37 a2 f9		dw store_readcont 
4f39 ad f9		dw store_readptr 
4f3b a2 f9		dw store_tmpext 
4f3d a3 f9		dw store_tmpid 
4f3f 9a f9		dw store_tmppageid 
4f41 b9 13		dw malloc 
4f43 83 14		dw free 
4f45 1d 73		dw cin 
4f47			; 70 
4f47 0c 73		dw cin_wait 
4f49 46 20		dw forth_push_numhl 
4f4b b4 20		dw forth_push_str 
4f4d			 
4f4d			 
4f4d			.ENDCONST: 
4f4d			 
4f4d			; eof 
4f4d			 
4f4d			 
# End of file forth_words_const.asm
4f4d			 
4f4d			if STORAGE_SE 
4f4d			   	include "forth_words_storage.asm" 
4f4d			 
4f4d			; | ## Fixed Storage Words 
4f4d			 
4f4d			.RENAME: 
4f4d			  
4f4d				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4f4d 3a				db WORD_SYS_CORE+38             
4f4e 43 50			dw .RECORD            
4f50 07				db 6 + 1 
4f51 .. 00			db "RENAME",0              
4f58				endm 
# End of macro CWHEAD
4f58			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4f58			; | | > [!NOTE] 
4f58			; | | > Compatible with PicoSPINet  
4f58					if DEBUG_FORTH_WORDS_KEY 
4f58						DMARK "REN" 
4f58 f5				push af  
4f59 3a 6d 4f			ld a, (.dmark)  
4f5c 32 a0 fd			ld (debug_mark),a  
4f5f 3a 6e 4f			ld a, (.dmark+1)  
4f62 32 a1 fd			ld (debug_mark+1),a  
4f65 3a 6f 4f			ld a, (.dmark+2)  
4f68 32 a2 fd			ld (debug_mark+2),a  
4f6b 18 03			jr .pastdmark  
4f6d ..			.dmark: db "REN"  
4f70 f1			.pastdmark: pop af  
4f71			endm  
# End of macro DMARK
4f71						CALLMONITOR 
4f71 cd aa fd			call debug_vector  
4f74				endm  
# End of macro CALLMONITOR
4f74					endif 
4f74			 
4f74			 
4f74					; preserve some internal vars used by other file handing routines 
4f74			 
4f74 2a a0 f9				ld hl, (store_openaddr) 
4f77 e5					push hl 
4f78 3a a2 f9				ld a, (store_readcont) 
4f7b f5					push af 
4f7c			 
4f7c					FORTH_DSP_VALUEHL 
4f7c cd 4b 22			call macro_dsp_valuehl 
4f7f				endm 
# End of macro FORTH_DSP_VALUEHL
4f7f			 
4f7f					; move ext and id around for the file header 
4f7f			 
4f7f 65					ld h, l 
4f80 2e 00				ld l, 0 
4f82			 
4f82 e5					push hl    ; id 
4f83			 
4f83					FORTH_DSP_POP 
4f83 cd 03 23			call macro_forth_dsp_pop 
4f86				endm 
# End of macro FORTH_DSP_POP
4f86			 
4f86					; Locate the file header 
4f86			 
4f86 e1					pop hl 
4f87 e5					push hl 
4f88 11 af f9				ld de, store_page      ; get block zero of file 
4f8b					if DEBUG_FORTH_WORDS 
4f8b						DMARK "REr" 
4f8b f5				push af  
4f8c 3a a0 4f			ld a, (.dmark)  
4f8f 32 a0 fd			ld (debug_mark),a  
4f92 3a a1 4f			ld a, (.dmark+1)  
4f95 32 a1 fd			ld (debug_mark+1),a  
4f98 3a a2 4f			ld a, (.dmark+2)  
4f9b 32 a2 fd			ld (debug_mark+2),a  
4f9e 18 03			jr .pastdmark  
4fa0 ..			.dmark: db "REr"  
4fa3 f1			.pastdmark: pop af  
4fa4			endm  
# End of macro DMARK
4fa4						CALLMONITOR 
4fa4 cd aa fd			call debug_vector  
4fa7				endm  
# End of macro CALLMONITOR
4fa7					endif 
4fa7 cd cd 09				call storage_read 
4faa			 
4faa cd 07 10			call ishlzero 
4fad 20 05			jr nz, .rnfound 
4faf			 
4faf				; file does not exist so indicate with 255 extents in use 
4faf			 
4faf 3e ff			ld a, 255 
4fb1 e1				pop hl ; clear dup hl 
4fb2 18 7b			jr .skiprneof 
4fb4			 
4fb4			 
4fb4			.rnfound: 
4fb4					; file found so rename 
4fb4			 
4fb4					FORTH_DSP_VALUEHL 
4fb4 cd 4b 22			call macro_dsp_valuehl 
4fb7				endm 
# End of macro FORTH_DSP_VALUEHL
4fb7			 
4fb7 e5				push hl 
4fb8 3e 00			ld a, 0 
4fba cd 4f 13			call strlent 
4fbd 23				inc hl   ; cover zero term 
4fbe 06 00			ld b,0 
4fc0 4d				ld c,l 
4fc1 e1				pop hl 
4fc2 11 b2 f9				ld de, store_page + 3 
4fc5 ed b0				ldir 
4fc7			 
4fc7 11 af f9				ld de, store_page 
4fca					if DEBUG_FORTH_WORDS 
4fca						DMARK "RER" 
4fca f5				push af  
4fcb 3a df 4f			ld a, (.dmark)  
4fce 32 a0 fd			ld (debug_mark),a  
4fd1 3a e0 4f			ld a, (.dmark+1)  
4fd4 32 a1 fd			ld (debug_mark+1),a  
4fd7 3a e1 4f			ld a, (.dmark+2)  
4fda 32 a2 fd			ld (debug_mark+2),a  
4fdd 18 03			jr .pastdmark  
4fdf ..			.dmark: db "RER"  
4fe2 f1			.pastdmark: pop af  
4fe3			endm  
# End of macro DMARK
4fe3						CALLMONITOR 
4fe3 cd aa fd			call debug_vector  
4fe6				endm  
# End of macro CALLMONITOR
4fe6					endif 
4fe6			 
4fe6 e1					pop hl    ; get orig file id and mangle it for find id 
4fe7 55					ld d, l 
4fe8 5c					ld e, h 
4fe9			 
4fe9 21 00 00				ld hl, 0 
4fec					if DEBUG_FORTH_WORDS 
4fec						DMARK "REf" 
4fec f5				push af  
4fed 3a 01 50			ld a, (.dmark)  
4ff0 32 a0 fd			ld (debug_mark),a  
4ff3 3a 02 50			ld a, (.dmark+1)  
4ff6 32 a1 fd			ld (debug_mark+1),a  
4ff9 3a 03 50			ld a, (.dmark+2)  
4ffc 32 a2 fd			ld (debug_mark+2),a  
4fff 18 03			jr .pastdmark  
5001 ..			.dmark: db "REf"  
5004 f1			.pastdmark: pop af  
5005			endm  
# End of macro DMARK
5005						CALLMONITOR 
5005 cd aa fd			call debug_vector  
5008				endm  
# End of macro CALLMONITOR
5008					endif 
5008 cd a7 07				call storage_findnextid 
500b 11 af f9				ld de, store_page 
500e					if DEBUG_FORTH_WORDS 
500e						DMARK "REw" 
500e f5				push af  
500f 3a 23 50			ld a, (.dmark)  
5012 32 a0 fd			ld (debug_mark),a  
5015 3a 24 50			ld a, (.dmark+1)  
5018 32 a1 fd			ld (debug_mark+1),a  
501b 3a 25 50			ld a, (.dmark+2)  
501e 32 a2 fd			ld (debug_mark+2),a  
5021 18 03			jr .pastdmark  
5023 ..			.dmark: db "REw"  
5026 f1			.pastdmark: pop af  
5027			endm  
# End of macro DMARK
5027						CALLMONITOR 
5027 cd aa fd			call debug_vector  
502a				endm  
# End of macro CALLMONITOR
502a					endif 
502a cd d9 04				call storage_write_block 
502d			 
502d 3e 00				ld a, 0 
502f			.skiprneof: 
502f					; drop file name 
502f					FORTH_DSP_POP 
502f cd 03 23			call macro_forth_dsp_pop 
5032				endm 
# End of macro FORTH_DSP_POP
5032			 
5032 6f					ld l, a 
5033 26 00				ld h, 0 
5035 cd 46 20				call forth_push_numhl 
5038			 
5038			 
5038 f1					pop af 
5039 32 a2 f9				ld (store_readcont),a 
503c e1					pop hl 
503d 22 a0 f9				ld (store_openaddr), hl 
5040						 
5040				NEXTW 
5040 c3 37 24			jp macro_next 
5043				endm 
# End of macro NEXTW
5043			.RECORD: 
5043			  
5043				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
5043 3a				db WORD_SYS_CORE+38             
5044 e7 50			dw .BREAD            
5046 07				db 6 + 1 
5047 .. 00			db "RECORD",0              
504e				endm 
# End of macro CWHEAD
504e			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
504e			; | | > [!NOTE] 
504e			; | | > Compatible with PicoSPINet  
504e			 
504e					if DEBUG_FORTH_WORDS_KEY 
504e						DMARK "REC" 
504e f5				push af  
504f 3a 63 50			ld a, (.dmark)  
5052 32 a0 fd			ld (debug_mark),a  
5055 3a 64 50			ld a, (.dmark+1)  
5058 32 a1 fd			ld (debug_mark+1),a  
505b 3a 65 50			ld a, (.dmark+2)  
505e 32 a2 fd			ld (debug_mark+2),a  
5061 18 03			jr .pastdmark  
5063 ..			.dmark: db "REC"  
5066 f1			.pastdmark: pop af  
5067			endm  
# End of macro DMARK
5067						CALLMONITOR 
5067 cd aa fd			call debug_vector  
506a				endm  
# End of macro CALLMONITOR
506a					endif 
506a			 
506a					FORTH_DSP_VALUEHL 
506a cd 4b 22			call macro_dsp_valuehl 
506d				endm 
# End of macro FORTH_DSP_VALUEHL
506d			 
506d e5					push hl    ; id 
506e			 
506e					FORTH_DSP_POP 
506e cd 03 23			call macro_forth_dsp_pop 
5071				endm 
# End of macro FORTH_DSP_POP
5071			 
5071					FORTH_DSP_VALUEHL 
5071 cd 4b 22			call macro_dsp_valuehl 
5074				endm 
# End of macro FORTH_DSP_VALUEHL
5074			 
5074					FORTH_DSP_POP 
5074 cd 03 23			call macro_forth_dsp_pop 
5077				endm 
# End of macro FORTH_DSP_POP
5077			 
5077 d1					pop de     ; get file id 
5078			 
5078					; e = file id 
5078					; l = file extent 
5078			 
5078			 
5078					; construct request to access file extent 
5078			 
5078			;		ld a, e 
5078 63					ld h, e 
5079					 
5079					 
5079					 
5079			 
5079					; e has id 
5079			 
5079 11 af f9			ld de, store_page 
507c					if DEBUG_FORTH_WORDS 
507c						DMARK "REr" 
507c f5				push af  
507d 3a 91 50			ld a, (.dmark)  
5080 32 a0 fd			ld (debug_mark),a  
5083 3a 92 50			ld a, (.dmark+1)  
5086 32 a1 fd			ld (debug_mark+1),a  
5089 3a 93 50			ld a, (.dmark+2)  
508c 32 a2 fd			ld (debug_mark+2),a  
508f 18 03			jr .pastdmark  
5091 ..			.dmark: db "REr"  
5094 f1			.pastdmark: pop af  
5095			endm  
# End of macro DMARK
5095						CALLMONITOR 
5095 cd aa fd			call debug_vector  
5098				endm  
# End of macro CALLMONITOR
5098					endif 
5098 cd cd 09				call storage_read 
509b cd 07 10			call ishlzero 
509e 28 22			jr z, .recnotfound 
50a0			 
50a0			 
50a0					if DEBUG_FORTH_WORDS 
50a0						DMARK "REe" 
50a0 f5				push af  
50a1 3a b5 50			ld a, (.dmark)  
50a4 32 a0 fd			ld (debug_mark),a  
50a7 3a b6 50			ld a, (.dmark+1)  
50aa 32 a1 fd			ld (debug_mark+1),a  
50ad 3a b7 50			ld a, (.dmark+2)  
50b0 32 a2 fd			ld (debug_mark+2),a  
50b3 18 03			jr .pastdmark  
50b5 ..			.dmark: db "REe"  
50b8 f1			.pastdmark: pop af  
50b9			endm  
# End of macro DMARK
50b9						CALLMONITOR 
50b9 cd aa fd			call debug_vector  
50bc				endm  
# End of macro CALLMONITOR
50bc					endif 
50bc cd b4 20			call forth_push_str 
50bf			 
50bf					NEXTW 
50bf c3 37 24			jp macro_next 
50c2				endm 
# End of macro NEXTW
50c2			 
50c2			.recnotfound: 
50c2					if DEBUG_FORTH_WORDS 
50c2						DMARK "REf" 
50c2 f5				push af  
50c3 3a d7 50			ld a, (.dmark)  
50c6 32 a0 fd			ld (debug_mark),a  
50c9 3a d8 50			ld a, (.dmark+1)  
50cc 32 a1 fd			ld (debug_mark+1),a  
50cf 3a d9 50			ld a, (.dmark+2)  
50d2 32 a2 fd			ld (debug_mark+2),a  
50d5 18 03			jr .pastdmark  
50d7 ..			.dmark: db "REf"  
50da f1			.pastdmark: pop af  
50db			endm  
# End of macro DMARK
50db						CALLMONITOR 
50db cd aa fd			call debug_vector  
50de				endm  
# End of macro CALLMONITOR
50de					endif 
50de 21 ff 00			ld hl, 255 
50e1 cd 46 20			call forth_push_numhl 
50e4				NEXTW 
50e4 c3 37 24			jp macro_next 
50e7				endm 
# End of macro NEXTW
50e7			 
50e7			 
50e7			.BREAD: 
50e7			  
50e7				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
50e7 3a				db WORD_SYS_CORE+38             
50e8 6a 51			dw .BWRITE            
50ea 06				db 5 + 1 
50eb .. 00			db "BREAD",0              
50f1				endm 
# End of macro CWHEAD
50f1			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
50f1			; | | > [!NOTE] 
50f1			; | | > Compatible with PicoSPINet  
50f1				 
50f1					if DEBUG_FORTH_WORDS_KEY 
50f1						DMARK "BRD" 
50f1 f5				push af  
50f2 3a 06 51			ld a, (.dmark)  
50f5 32 a0 fd			ld (debug_mark),a  
50f8 3a 07 51			ld a, (.dmark+1)  
50fb 32 a1 fd			ld (debug_mark+1),a  
50fe 3a 08 51			ld a, (.dmark+2)  
5101 32 a2 fd			ld (debug_mark+2),a  
5104 18 03			jr .pastdmark  
5106 ..			.dmark: db "BRD"  
5109 f1			.pastdmark: pop af  
510a			endm  
# End of macro DMARK
510a						CALLMONITOR 
510a cd aa fd			call debug_vector  
510d				endm  
# End of macro CALLMONITOR
510d					endif 
510d			 
510d				FORTH_DSP_VALUEHL 
510d cd 4b 22			call macro_dsp_valuehl 
5110				endm 
# End of macro FORTH_DSP_VALUEHL
5110			 
5110				FORTH_DSP_POP 
5110 cd 03 23			call macro_forth_dsp_pop 
5113				endm 
# End of macro FORTH_DSP_POP
5113			 
5113				; calc block address 
5113			 
5113 eb				ex de, hl 
5114 3e 40			ld a, STORE_BLOCK_PHY 
5116 cd 61 0f			call Mult16 
5119			 
5119			 
5119 11 af f9			ld de, store_page 
511c			 
511c					if DEBUG_FORTH_WORDS 
511c						DMARK "BR1" 
511c f5				push af  
511d 3a 31 51			ld a, (.dmark)  
5120 32 a0 fd			ld (debug_mark),a  
5123 3a 32 51			ld a, (.dmark+1)  
5126 32 a1 fd			ld (debug_mark+1),a  
5129 3a 33 51			ld a, (.dmark+2)  
512c 32 a2 fd			ld (debug_mark+2),a  
512f 18 03			jr .pastdmark  
5131 ..			.dmark: db "BR1"  
5134 f1			.pastdmark: pop af  
5135			endm  
# End of macro DMARK
5135						CALLMONITOR 
5135 cd aa fd			call debug_vector  
5138				endm  
# End of macro CALLMONITOR
5138					endif 
5138			 
5138 cd 74 04			call storage_read_block 
513b			 
513b cd 07 10			call ishlzero 
513e 20 05			jr nz, .brfound 
5140			 
5140 cd 46 20			call forth_push_numhl 
5143 18 22			jr .brdone 
5145			 
5145			 
5145			.brfound: 
5145 21 b1 f9		        ld hl, store_page+2 
5148			 
5148					if DEBUG_FORTH_WORDS 
5148						DMARK "BR2" 
5148 f5				push af  
5149 3a 5d 51			ld a, (.dmark)  
514c 32 a0 fd			ld (debug_mark),a  
514f 3a 5e 51			ld a, (.dmark+1)  
5152 32 a1 fd			ld (debug_mark+1),a  
5155 3a 5f 51			ld a, (.dmark+2)  
5158 32 a2 fd			ld (debug_mark+2),a  
515b 18 03			jr .pastdmark  
515d ..			.dmark: db "BR2"  
5160 f1			.pastdmark: pop af  
5161			endm  
# End of macro DMARK
5161						CALLMONITOR 
5161 cd aa fd			call debug_vector  
5164				endm  
# End of macro CALLMONITOR
5164					endif 
5164			 
5164 cd b4 20			call forth_push_str 
5167			 
5167			 
5167			.brdone: 
5167			 
5167					NEXTW 
5167 c3 37 24			jp macro_next 
516a				endm 
# End of macro NEXTW
516a			.BWRITE: 
516a				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
516a 3a				db WORD_SYS_CORE+38             
516b ff 51			dw .BUPD            
516d 07				db 6 + 1 
516e .. 00			db "BWRITE",0              
5175				endm 
# End of macro CWHEAD
5175			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5175			; | | > [!NOTE] 
5175			; | | > Compatible with PicoSPINet  
5175			 
5175					if DEBUG_FORTH_WORDS_KEY 
5175						DMARK "BWR" 
5175 f5				push af  
5176 3a 8a 51			ld a, (.dmark)  
5179 32 a0 fd			ld (debug_mark),a  
517c 3a 8b 51			ld a, (.dmark+1)  
517f 32 a1 fd			ld (debug_mark+1),a  
5182 3a 8c 51			ld a, (.dmark+2)  
5185 32 a2 fd			ld (debug_mark+2),a  
5188 18 03			jr .pastdmark  
518a ..			.dmark: db "BWR"  
518d f1			.pastdmark: pop af  
518e			endm  
# End of macro DMARK
518e						CALLMONITOR 
518e cd aa fd			call debug_vector  
5191				endm  
# End of macro CALLMONITOR
5191					endif 
5191			 
5191				FORTH_DSP_VALUEHL 
5191 cd 4b 22			call macro_dsp_valuehl 
5194				endm 
# End of macro FORTH_DSP_VALUEHL
5194			 
5194				; calc block address 
5194			 
5194 eb				ex de, hl 
5195 3e 40			ld a, STORE_BLOCK_PHY 
5197 cd 61 0f			call Mult16 
519a			 
519a e5				push hl         ; address 
519b			 
519b				FORTH_DSP_POP 
519b cd 03 23			call macro_forth_dsp_pop 
519e				endm 
# End of macro FORTH_DSP_POP
519e			 
519e				FORTH_DSP_VALUEHL 
519e cd 4b 22			call macro_dsp_valuehl 
51a1				endm 
# End of macro FORTH_DSP_VALUEHL
51a1			 
51a1				FORTH_DSP_POP 
51a1 cd 03 23			call macro_forth_dsp_pop 
51a4				endm 
# End of macro FORTH_DSP_POP
51a4			 
51a4 cd b0 0c			call storage_clear_page 
51a7			 
51a7				; copy string to store page 
51a7			 
51a7 e5				push hl     ; save string address 
51a8			 
51a8 3e 00			ld a, 0 
51aa cd 4f 13			call strlent 
51ad			 
51ad 23				inc hl 
51ae			 
51ae 4d				ld c, l 
51af 06 00			ld b, 0 
51b1			 
51b1 e1				pop hl 
51b2 11 b1 f9			ld de, store_page + 2 
51b5					if DEBUG_FORTH_WORDS 
51b5						DMARK "BW1" 
51b5 f5				push af  
51b6 3a ca 51			ld a, (.dmark)  
51b9 32 a0 fd			ld (debug_mark),a  
51bc 3a cb 51			ld a, (.dmark+1)  
51bf 32 a1 fd			ld (debug_mark+1),a  
51c2 3a cc 51			ld a, (.dmark+2)  
51c5 32 a2 fd			ld (debug_mark+2),a  
51c8 18 03			jr .pastdmark  
51ca ..			.dmark: db "BW1"  
51cd f1			.pastdmark: pop af  
51ce			endm  
# End of macro DMARK
51ce						CALLMONITOR 
51ce cd aa fd			call debug_vector  
51d1				endm  
# End of macro CALLMONITOR
51d1					endif 
51d1 ed b0			ldir 
51d3			 
51d3			 
51d3				; poke the start of the block with flags to prevent high level file ops hitting the block 
51d3			 
51d3 21 ff ff			ld hl, $ffff 
51d6			 
51d6 22 af f9			ld (store_page), hl	 
51d9				 
51d9 e1				pop hl    ; get address 
51da 11 af f9			ld de, store_page 
51dd			 
51dd					if DEBUG_FORTH_WORDS 
51dd						DMARK "BW2" 
51dd f5				push af  
51de 3a f2 51			ld a, (.dmark)  
51e1 32 a0 fd			ld (debug_mark),a  
51e4 3a f3 51			ld a, (.dmark+1)  
51e7 32 a1 fd			ld (debug_mark+1),a  
51ea 3a f4 51			ld a, (.dmark+2)  
51ed 32 a2 fd			ld (debug_mark+2),a  
51f0 18 03			jr .pastdmark  
51f2 ..			.dmark: db "BW2"  
51f5 f1			.pastdmark: pop af  
51f6			endm  
# End of macro DMARK
51f6						CALLMONITOR 
51f6 cd aa fd			call debug_vector  
51f9				endm  
# End of macro CALLMONITOR
51f9					endif 
51f9			 
51f9 cd d9 04			call storage_write_block 
51fc			 
51fc					NEXTW 
51fc c3 37 24			jp macro_next 
51ff				endm 
# End of macro NEXTW
51ff			 
51ff			.BUPD: 
51ff				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
51ff 3a				db WORD_SYS_CORE+38             
5200 55 52			dw .BYID            
5202 05				db 4 + 1 
5203 .. 00			db "BUPD",0              
5208				endm 
# End of macro CWHEAD
5208			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
5208			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
5208			; | | or completely different file system structure. 
5208			; | | > [!NOTE] 
5208			; | | > Compatible with PicoSPINet  
5208			 
5208					if DEBUG_FORTH_WORDS_KEY 
5208						DMARK "BUD" 
5208 f5				push af  
5209 3a 1d 52			ld a, (.dmark)  
520c 32 a0 fd			ld (debug_mark),a  
520f 3a 1e 52			ld a, (.dmark+1)  
5212 32 a1 fd			ld (debug_mark+1),a  
5215 3a 1f 52			ld a, (.dmark+2)  
5218 32 a2 fd			ld (debug_mark+2),a  
521b 18 03			jr .pastdmark  
521d ..			.dmark: db "BUD"  
5220 f1			.pastdmark: pop af  
5221			endm  
# End of macro DMARK
5221						CALLMONITOR 
5221 cd aa fd			call debug_vector  
5224				endm  
# End of macro CALLMONITOR
5224					endif 
5224			 
5224				FORTH_DSP_VALUEHL 
5224 cd 4b 22			call macro_dsp_valuehl 
5227				endm 
# End of macro FORTH_DSP_VALUEHL
5227			 
5227				; calc block address 
5227			 
5227 eb				ex de, hl 
5228 3e 40			ld a, STORE_BLOCK_PHY 
522a cd 61 0f			call Mult16 
522d			 
522d				FORTH_DSP_POP 
522d cd 03 23			call macro_forth_dsp_pop 
5230				endm 
# End of macro FORTH_DSP_POP
5230			 
5230			 
5230 11 af f9			ld de, store_page 
5233			 
5233					if DEBUG_FORTH_WORDS 
5233						DMARK "BUe" 
5233 f5				push af  
5234 3a 48 52			ld a, (.dmark)  
5237 32 a0 fd			ld (debug_mark),a  
523a 3a 49 52			ld a, (.dmark+1)  
523d 32 a1 fd			ld (debug_mark+1),a  
5240 3a 4a 52			ld a, (.dmark+2)  
5243 32 a2 fd			ld (debug_mark+2),a  
5246 18 03			jr .pastdmark  
5248 ..			.dmark: db "BUe"  
524b f1			.pastdmark: pop af  
524c			endm  
# End of macro DMARK
524c						CALLMONITOR 
524c cd aa fd			call debug_vector  
524f				endm  
# End of macro CALLMONITOR
524f					endif 
524f			 
524f cd d9 04			call storage_write_block 
5252			 
5252					NEXTW 
5252 c3 37 24			jp macro_next 
5255				endm 
# End of macro NEXTW
5255			 
5255			.BYID: 
5255			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5255			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5255			; 
5255			;		 
5255			;		if DEBUG_FORTH_WORDS_KEY 
5255			;			DMARK "BYID" 
5255			;			CALLMONITOR 
5255			;		endif 
5255			; 
5255			;		; get direct address 
5255			; 
5255			;		FORTH_DSP_VALUEHL 
5255			; 
5255			;		FORTH_DSP_POP 
5255			; 
5255			;	; calc block address 
5255			; 
5255			;	ex de, hl 
5255			;	ld a, STORE_BLOCK_PHY 
5255			;	call Mult16 
5255			;	;	do BREAD with number as param 
5255			;	; push the file name	 
5255			;	ld de, store_page 
5255			;	call storage_read_block 
5255			 ;       ld hl, store_page+2 
5255			; 
5255			; 
5255			;		NEXTW 
5255			;.BYNAME: 
5255				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5255 3a				db WORD_SYS_CORE+38             
5256 6e 52			dw .DIR            
5258 06				db 5 + 1 
5259 .. 00			db "GETID",0              
525f				endm 
# End of macro CWHEAD
525f			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
525f			; | | > [!NOTE] 
525f			; | | > Compatible with PicoSPINet  
525f			 
525f					; get pointer to file name to seek 
525f			 
525f					FORTH_DSP_VALUEHL 
525f cd 4b 22			call macro_dsp_valuehl 
5262				endm 
# End of macro FORTH_DSP_VALUEHL
5262			 
5262			 
5262 cd 9b 03				call storage_getid  
5265			 
5265					FORTH_DSP_POP 
5265 cd 03 23			call macro_forth_dsp_pop 
5268				endm 
# End of macro FORTH_DSP_POP
5268			 
5268 cd 46 20				call forth_push_numhl 
526b			 
526b					NEXTW 
526b c3 37 24			jp macro_next 
526e				endm 
# End of macro NEXTW
526e			; 
526e			.DIR: 
526e				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
526e 3a				db WORD_SYS_CORE+38             
526f 72 53			dw .SAVE            
5271 04				db 3 + 1 
5272 .. 00			db "DIR",0              
5276				endm 
# End of macro CWHEAD
5276			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5276			; | | > [!NOTE] 
5276			; | | > Compatible with PicoSPINet  
5276			 
5276					if DEBUG_FORTH_WORDS_KEY 
5276						DMARK "DIR" 
5276 f5				push af  
5277 3a 8b 52			ld a, (.dmark)  
527a 32 a0 fd			ld (debug_mark),a  
527d 3a 8c 52			ld a, (.dmark+1)  
5280 32 a1 fd			ld (debug_mark+1),a  
5283 3a 8d 52			ld a, (.dmark+2)  
5286 32 a2 fd			ld (debug_mark+2),a  
5289 18 03			jr .pastdmark  
528b ..			.dmark: db "DIR"  
528e f1			.pastdmark: pop af  
528f			endm  
# End of macro DMARK
528f						CALLMONITOR 
528f cd aa fd			call debug_vector  
5292				endm  
# End of macro CALLMONITOR
5292					endif 
5292 cd 25 05			call storage_get_block_0 
5295			 
5295 21 af f9			ld hl, store_page     ; get current id count 
5298 46				ld b, (hl) 
5299 0e 00			ld c, 0    ; count of files   
529b					if DEBUG_FORTH_WORDS 
529b						DMARK "DI1" 
529b f5				push af  
529c 3a b0 52			ld a, (.dmark)  
529f 32 a0 fd			ld (debug_mark),a  
52a2 3a b1 52			ld a, (.dmark+1)  
52a5 32 a1 fd			ld (debug_mark+1),a  
52a8 3a b2 52			ld a, (.dmark+2)  
52ab 32 a2 fd			ld (debug_mark+2),a  
52ae 18 03			jr .pastdmark  
52b0 ..			.dmark: db "DI1"  
52b3 f1			.pastdmark: pop af  
52b4			endm  
# End of macro DMARK
52b4						CALLMONITOR 
52b4 cd aa fd			call debug_vector  
52b7				endm  
# End of macro CALLMONITOR
52b7					endif 
52b7			 
52b7				; check for empty drive 
52b7			 
52b7 3e 00			ld a, 0 
52b9 b8				cp b 
52ba ca 28 53			jp z, .dirdone 
52bd			 
52bd				; for each of the current ids do a search for them and if found push to stack 
52bd			 
52bd c5			.diritem:	push bc 
52be 21 40 00				ld hl, STORE_BLOCK_PHY 
52c1 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
52c3 58					ld e,b 
52c4			 
52c4			;		if DEBUG_FORTH_WORDS 
52c4			;			DMARK "DI2" 
52c4			;			CALLMONITOR 
52c4			;		endif 
52c4			 
52c4 cd a7 07				call storage_findnextid 
52c7			 
52c7			;		if DEBUG_FORTH_WORDS 
52c7			;			DMARK "DI3" 
52c7			;			CALLMONITOR 
52c7			;		endif 
52c7			 
52c7					; if found hl will be non zero 
52c7			 
52c7 cd 07 10				call ishlzero 
52ca			;		ld a, l 
52ca			;		add h 
52ca			; 
52ca			;		cp 0 
52ca 28 59				jr z, .dirnotfound 
52cc			 
52cc					; increase count 
52cc			 
52cc c1					pop bc	 
52cd 0c					inc c 
52ce c5					push bc 
52cf					 
52cf			 
52cf					; get file header and push the file name 
52cf			 
52cf 11 af f9				ld de, store_page 
52d2 cd 74 04				call storage_read_block 
52d5			 
52d5					; push file id to stack 
52d5				 
52d5 3a af f9				ld a, (store_page) 
52d8 26 00				ld h, 0 
52da 6f					ld l, a 
52db cd 46 20				call forth_push_numhl 
52de			 
52de					; push extent count to stack  
52de				 
52de 3a b1 f9				ld a, (store_page+2) 
52e1 26 00				ld h, 0 
52e3 6f					ld l, a 
52e4 cd 46 20				call forth_push_numhl 
52e7			 
52e7					; push file name 
52e7			 
52e7 21 b2 f9				ld hl, store_page+3 
52ea					if DEBUG_FORTH_WORDS 
52ea						DMARK "DI5" 
52ea f5				push af  
52eb 3a ff 52			ld a, (.dmark)  
52ee 32 a0 fd			ld (debug_mark),a  
52f1 3a 00 53			ld a, (.dmark+1)  
52f4 32 a1 fd			ld (debug_mark+1),a  
52f7 3a 01 53			ld a, (.dmark+2)  
52fa 32 a2 fd			ld (debug_mark+2),a  
52fd 18 03			jr .pastdmark  
52ff ..			.dmark: db "DI5"  
5302 f1			.pastdmark: pop af  
5303			endm  
# End of macro DMARK
5303						CALLMONITOR 
5303 cd aa fd			call debug_vector  
5306				endm  
# End of macro CALLMONITOR
5306					endif 
5306 cd b4 20				call forth_push_str 
5309					if DEBUG_FORTH_WORDS 
5309						DMARK "DI6" 
5309 f5				push af  
530a 3a 1e 53			ld a, (.dmark)  
530d 32 a0 fd			ld (debug_mark),a  
5310 3a 1f 53			ld a, (.dmark+1)  
5313 32 a1 fd			ld (debug_mark+1),a  
5316 3a 20 53			ld a, (.dmark+2)  
5319 32 a2 fd			ld (debug_mark+2),a  
531c 18 03			jr .pastdmark  
531e ..			.dmark: db "DI6"  
5321 f1			.pastdmark: pop af  
5322			endm  
# End of macro DMARK
5322						CALLMONITOR 
5322 cd aa fd			call debug_vector  
5325				endm  
# End of macro CALLMONITOR
5325					endif 
5325			.dirnotfound: 
5325 c1					pop bc     
5326 10 95				djnz .diritem 
5328				 
5328			.dirdone:	 
5328					if DEBUG_FORTH_WORDS 
5328						DMARK "DI7" 
5328 f5				push af  
5329 3a 3d 53			ld a, (.dmark)  
532c 32 a0 fd			ld (debug_mark),a  
532f 3a 3e 53			ld a, (.dmark+1)  
5332 32 a1 fd			ld (debug_mark+1),a  
5335 3a 3f 53			ld a, (.dmark+2)  
5338 32 a2 fd			ld (debug_mark+2),a  
533b 18 03			jr .pastdmark  
533d ..			.dmark: db "DI7"  
5340 f1			.pastdmark: pop af  
5341			endm  
# End of macro DMARK
5341						CALLMONITOR 
5341 cd aa fd			call debug_vector  
5344				endm  
# End of macro CALLMONITOR
5344					endif 
5344			 
5344					; push a count of the dir items found 
5344			 
5344 26 00				ld h, 0 
5346 69					ld l, c 
5347 cd 46 20				call forth_push_numhl 
534a			 
534a					; push the bank label 
534a			 
534a cd 25 05				call storage_get_block_0 
534d			 
534d				 
534d 21 b2 f9		 		ld hl, store_page+3 
5350			 
5350					if DEBUG_FORTH_WORDS 
5350						DMARK "DI8" 
5350 f5				push af  
5351 3a 65 53			ld a, (.dmark)  
5354 32 a0 fd			ld (debug_mark),a  
5357 3a 66 53			ld a, (.dmark+1)  
535a 32 a1 fd			ld (debug_mark+1),a  
535d 3a 67 53			ld a, (.dmark+2)  
5360 32 a2 fd			ld (debug_mark+2),a  
5363 18 03			jr .pastdmark  
5365 ..			.dmark: db "DI8"  
5368 f1			.pastdmark: pop af  
5369			endm  
# End of macro DMARK
5369						CALLMONITOR 
5369 cd aa fd			call debug_vector  
536c				endm  
# End of macro CALLMONITOR
536c					endif 
536c cd b4 20				call forth_push_str 
536f			 
536f			 
536f				 
536f					NEXTW 
536f c3 37 24			jp macro_next 
5372				endm 
# End of macro NEXTW
5372			.SAVE: 
5372			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5372			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5372			;		NEXTW 
5372			;.LOAD: 
5372			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5372			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5372			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5372			;; > > The LOAD command can not be used in any user words or compound lines. 
5372			; 
5372			;		; store_openext use it. If zero it is EOF 
5372			; 
5372			;		; read block from current stream id 
5372			;		; if the block does not contain zero term keep reading blocks until zero found 
5372			;		; push the block to stack 
5372			;		; save the block id to stream 
5372			; 
5372			; 
5372			;		FORTH_DSP_VALUEHL 
5372			; 
5372			;;		push hl 
5372			; 
5372			;	if DEBUG_STORESE 
5372			;		DMARK "LOA" 
5372			;		CALLMONITOR 
5372			;	endif 
5372			;		FORTH_DSP_POP 
5372			; 
5372			;;		pop hl 
5372			; 
5372			;		ld h, l 
5372			;		ld l, 0 
5372			; 
5372			;		push hl     ; stack holds current file id and extent to work with 
5372			; 
5372			; 
5372			;		ld de, store_page      ; get block zero of file 
5372			;	if DEBUG_STORESE 
5372			;		DMARK "LO0" 
5372			;		CALLMONITOR 
5372			;	endif 
5372			;		call storage_read 
5372			; 
5372			;		ld a, (store_page+2)    ; max extents for this file 
5372			;		ld  (store_openmaxext),a   ; get our limit 
5372			; 
5372			;	if DEBUG_STORESE 
5372			;		DMARK "LOE" 
5372			;		CALLMONITOR 
5372			;	endif 
5372			; 
5372			;; TODO dont know why max extents are not present 
5372			;;		cp 0 
5372			;;		jp z, .loadeof     ; dont read past eof 
5372			; 
5372			;;		ld a, 1   ; start from the head of the file 
5372			; 
5372			;.loadline:	pop hl 
5372			;		inc hl 
5372			;		ld  a, (store_openmaxext)   ; get our limit 
5372			;	if DEBUG_STORESE 
5372			;		DMARK "LOx" 
5372			;		CALLMONITOR 
5372			;	endif 
5372			;		inc a 
5372			;		cp l 
5372			;		jp z, .loadeof 
5372			;		push hl    ; save current extent 
5372			; 
5372			;		ld de, store_page 
5372			; 
5372			;	if DEBUG_STORESE 
5372			;		DMARK "LO1" 
5372			;		CALLMONITOR 
5372			;	endif 
5372			;		call storage_read 
5372			; 
5372			;	if DEBUG_STORESE 
5372			;		DMARK "LO2" 
5372			;		CALLMONITOR 
5372			;	endif 
5372			;	call ishlzero 
5372			;	ld a, l 
5372			;	add h 
5372			;	cp 0 
5372			;	jr z, .loadeof 
5372			; 
5372			;	; not eof so hl should point to data to exec 
5372			; 
5372			;	; will need to add the FORTH_END_BUFFER flag 
5372			 ; 
5372			;	ld hl, store_page+2 
5372			;	ld bc, 255 
5372			;	ld a, 0 
5372			;	cpir 
5372			;	if DEBUG_STORESE 
5372			;		DMARK "LOt" 
5372			;		CALLMONITOR 
5372			;	endif 
5372			;	dec hl 
5372			;	ld a, ' ' 
5372			;	ld (hl), a 
5372			;	inc hl 
5372			;	ld (hl), a 
5372			;	inc hl 
5372			;	ld (hl), a 
5372			;	inc hl 
5372			;	ld a, FORTH_END_BUFFER 
5372			;	ld (hl), a 
5372			; 
5372			;	; TODO handle more than a single block read 
5372			; 
5372			; 
5372			;	ld hl, store_page+2 
5372			; 
5372			;	ld (os_tok_ptr), hl 
5372			; 
5372			;	if DEBUG_STORESE 
5372			;		DMARK "LO3" 
5372			;		CALLMONITOR 
5372			;	endif 
5372			; 
5372			;	call forthparse 
5372			;	call forthexec 
5372			;	call forthexec_cleanup 
5372			; 
5372			;	; go to next extent 
5372			; 
5372			;	; get next block  or mark as eof 
5372			;	jp .loadline 
5372			; 
5372			; 
5372			; 
5372			;	       NEXTW 
5372			;.loadeof:	ld a, 0 
5372			;		ld (store_openext), a 
5372			; 
5372			;	if DEBUG_STORESE 
5372			;		DMARK "LOF" 
5372			;		CALLMONITOR 
5372			;	endif 
5372			;		ret 
5372			;		;NEXTW 
5372			;.BSAVE:   
5372			; 
5372			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5372			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5372			;		NEXTW 
5372			;.BLOAD: 
5372			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5372			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5372			;		NEXTW 
5372			;;;; counter gap 
5372			 
5372			 
5372			.SEO: 
5372				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5372 64				db WORD_SYS_CORE+80             
5373 91 53			dw .SEI            
5375 04				db 3 + 1 
5376 .. 00			db "SEO",0              
537a				endm 
# End of macro CWHEAD
537a			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
537a			 
537a					; get port 
537a			 
537a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
537a cd 4b 22			call macro_dsp_valuehl 
537d				endm 
# End of macro FORTH_DSP_VALUEHL
537d			 
537d e5					push hl    ; u2 - byte 
537e			 
537e					; destroy value TOS 
537e			 
537e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
537e cd 03 23			call macro_forth_dsp_pop 
5381				endm 
# End of macro FORTH_DSP_POP
5381			 
5381					; get byte to send 
5381			 
5381					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5381 cd 4b 22			call macro_dsp_valuehl 
5384				endm 
# End of macro FORTH_DSP_VALUEHL
5384			 
5384 e5					push hl    ; u1 - addr 
5385			 
5385					; destroy value TOS 
5385			 
5385					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5385 cd 03 23			call macro_forth_dsp_pop 
5388				endm 
# End of macro FORTH_DSP_POP
5388			 
5388					; one value on hl get other one back 
5388			 
5388 d1					pop de   ; u1 - byte 
5389			 
5389 e1					pop hl   ; u2 - addr 
538a			 
538a					; TODO Send SPI byte 
538a			 
538a			 
538a 7b					ld a, e 
538b cd 79 02				call se_writebyte 
538e			 
538e					 
538e			 
538e					NEXTW 
538e c3 37 24			jp macro_next 
5391				endm 
# End of macro NEXTW
5391			 
5391			.SEI: 
5391				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5391 65				db WORD_SYS_CORE+81             
5392 ab 53			dw .SFREE            
5394 04				db 3 + 1 
5395 .. 00			db "SEI",0              
5399				endm 
# End of macro CWHEAD
5399			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5399			 
5399					; get port 
5399			 
5399					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5399 cd 4b 22			call macro_dsp_valuehl 
539c				endm 
# End of macro FORTH_DSP_VALUEHL
539c			 
539c			;		push hl 
539c			 
539c					; destroy value TOS 
539c			 
539c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
539c cd 03 23			call macro_forth_dsp_pop 
539f				endm 
# End of macro FORTH_DSP_POP
539f			 
539f					; one value on hl get other one back 
539f			 
539f			;		pop hl 
539f			 
539f			 
539f					; TODO Get SPI byte 
539f			 
539f cd 1b 03				call se_readbyte 
53a2			 
53a2 26 00				ld h, 0 
53a4 6f					ld l, a 
53a5 cd 46 20				call forth_push_numhl 
53a8			 
53a8					NEXTW 
53a8 c3 37 24			jp macro_next 
53ab				endm 
# End of macro NEXTW
53ab			 
53ab			.SFREE: 
53ab				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
53ab 67				db WORD_SYS_CORE+83             
53ac da 53			dw .SIZE            
53ae 06				db 5 + 1 
53af .. 00			db "FFREE",0              
53b5				endm 
# End of macro CWHEAD
53b5			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
53b5			; | | > [!NOTE] 
53b5			; | | > Compatible with PicoSPINet  
53b5					if DEBUG_FORTH_WORDS_KEY 
53b5						DMARK "FFR" 
53b5 f5				push af  
53b6 3a ca 53			ld a, (.dmark)  
53b9 32 a0 fd			ld (debug_mark),a  
53bc 3a cb 53			ld a, (.dmark+1)  
53bf 32 a1 fd			ld (debug_mark+1),a  
53c2 3a cc 53			ld a, (.dmark+2)  
53c5 32 a2 fd			ld (debug_mark+2),a  
53c8 18 03			jr .pastdmark  
53ca ..			.dmark: db "FFR"  
53cd f1			.pastdmark: pop af  
53ce			endm  
# End of macro DMARK
53ce						CALLMONITOR 
53ce cd aa fd			call debug_vector  
53d1				endm  
# End of macro CALLMONITOR
53d1					endif 
53d1			 
53d1 cd 41 08				call storage_freeblocks 
53d4			 
53d4 cd 46 20				call forth_push_numhl 
53d7			 
53d7				       NEXTW 
53d7 c3 37 24			jp macro_next 
53da				endm 
# End of macro NEXTW
53da			.SIZE: 
53da				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
53da 67				db WORD_SYS_CORE+83             
53db 0e 54			dw .CREATE            
53dd 05				db 4 + 1 
53de .. 00			db "SIZE",0              
53e3				endm 
# End of macro CWHEAD
53e3			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
53e3			; | | > [!NOTE] 
53e3			; | | > Compatible with PicoSPINet  
53e3					if DEBUG_FORTH_WORDS_KEY 
53e3						DMARK "SIZ" 
53e3 f5				push af  
53e4 3a f8 53			ld a, (.dmark)  
53e7 32 a0 fd			ld (debug_mark),a  
53ea 3a f9 53			ld a, (.dmark+1)  
53ed 32 a1 fd			ld (debug_mark+1),a  
53f0 3a fa 53			ld a, (.dmark+2)  
53f3 32 a2 fd			ld (debug_mark+2),a  
53f6 18 03			jr .pastdmark  
53f8 ..			.dmark: db "SIZ"  
53fb f1			.pastdmark: pop af  
53fc			endm  
# End of macro DMARK
53fc						CALLMONITOR 
53fc cd aa fd			call debug_vector  
53ff				endm  
# End of macro CALLMONITOR
53ff					endif 
53ff			 
53ff					FORTH_DSP_VALUEHL 
53ff cd 4b 22			call macro_dsp_valuehl 
5402				endm 
# End of macro FORTH_DSP_VALUEHL
5402			;		push hl 
5402					FORTH_DSP_POP 
5402 cd 03 23			call macro_forth_dsp_pop 
5405				endm 
# End of macro FORTH_DSP_POP
5405			;		pop hl 
5405 cd a3 04				call storage_file_size 
5408			 
5408 cd 46 20				call forth_push_numhl 
540b			  
540b			 
540b				       NEXTW 
540b c3 37 24			jp macro_next 
540e				endm 
# End of macro NEXTW
540e			 
540e			.CREATE: 
540e				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
540e 68				db WORD_SYS_CORE+84             
540f 7c 54			dw .APPEND            
5411 07				db 6 + 1 
5412 .. 00			db "CREATE",0              
5419				endm 
# End of macro CWHEAD
5419			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5419			; | | e.g.  
5419			; | | TestProgram CREATE 
5419			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5419			; | |  
5419			; | | Max file IDs are 255. 
5419			; | |  
5419			; | | > [!NOTE] 
5419			; | | > Compatible with PicoSPINet  
5419					 
5419					if DEBUG_FORTH_WORDS_KEY 
5419						DMARK "CRT" 
5419 f5				push af  
541a 3a 2e 54			ld a, (.dmark)  
541d 32 a0 fd			ld (debug_mark),a  
5420 3a 2f 54			ld a, (.dmark+1)  
5423 32 a1 fd			ld (debug_mark+1),a  
5426 3a 30 54			ld a, (.dmark+2)  
5429 32 a2 fd			ld (debug_mark+2),a  
542c 18 03			jr .pastdmark  
542e ..			.dmark: db "CRT"  
5431 f1			.pastdmark: pop af  
5432			endm  
# End of macro DMARK
5432						CALLMONITOR 
5432 cd aa fd			call debug_vector  
5435				endm  
# End of macro CALLMONITOR
5435					endif 
5435			;		call storage_get_block_0 
5435			 
5435					; TODO pop hl 
5435			 
5435					;v5 FORTH_DSP_VALUE 
5435					FORTH_DSP_VALUE 
5435 cd 34 22			call macro_forth_dsp_value 
5438				endm 
# End of macro FORTH_DSP_VALUE
5438			 
5438				if DEBUG_STORESE 
5438					DMARK "CR1" 
5438 f5				push af  
5439 3a 4d 54			ld a, (.dmark)  
543c 32 a0 fd			ld (debug_mark),a  
543f 3a 4e 54			ld a, (.dmark+1)  
5442 32 a1 fd			ld (debug_mark+1),a  
5445 3a 4f 54			ld a, (.dmark+2)  
5448 32 a2 fd			ld (debug_mark+2),a  
544b 18 03			jr .pastdmark  
544d ..			.dmark: db "CR1"  
5450 f1			.pastdmark: pop af  
5451			endm  
# End of macro DMARK
5451					CALLMONITOR 
5451 cd aa fd			call debug_vector  
5454				endm  
# End of macro CALLMONITOR
5454				endif 
5454			;		push hl 
5454			;		FORTH_DSP_POP 
5454			;		pop hl 
5454			 
5454			;		inc hl   ; move past the type marker 
5454			 
5454 cd 77 08				call storage_create 
5457			 
5457				if DEBUG_STORESE 
5457					DMARK "CT1" 
5457 f5				push af  
5458 3a 6c 54			ld a, (.dmark)  
545b 32 a0 fd			ld (debug_mark),a  
545e 3a 6d 54			ld a, (.dmark+1)  
5461 32 a1 fd			ld (debug_mark+1),a  
5464 3a 6e 54			ld a, (.dmark+2)  
5467 32 a2 fd			ld (debug_mark+2),a  
546a 18 03			jr .pastdmark  
546c ..			.dmark: db "CT1"  
546f f1			.pastdmark: pop af  
5470			endm  
# End of macro DMARK
5470					CALLMONITOR 
5470 cd aa fd			call debug_vector  
5473				endm  
# End of macro CALLMONITOR
5473				endif 
5473			;		push hl 
5473					FORTH_DSP_POP 
5473 cd 03 23			call macro_forth_dsp_pop 
5476				endm 
# End of macro FORTH_DSP_POP
5476			;		pop hl 
5476					; push file id to stack 
5476 cd 46 20				call forth_push_numhl 
5479			 
5479			 
5479			 
5479				       NEXTW 
5479 c3 37 24			jp macro_next 
547c				endm 
# End of macro NEXTW
547c			 
547c			.APPEND: 
547c				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
547c 69				db WORD_SYS_CORE+85             
547d 0d 55			dw .SDEL            
547f 07				db 6 + 1 
5480 .. 00			db "APPEND",0              
5487				endm 
# End of macro CWHEAD
5487			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5487			; | | e.g. 
5487			; | | Test CREATE      -> $01 
5487			; | | "A string to add to file" $01 APPEND 
5487			; | |  
5487			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5487			; | | > [!NOTE] 
5487			; | | > Compatible with PicoSPINet  
5487					if DEBUG_FORTH_WORDS_KEY 
5487						DMARK "APP" 
5487 f5				push af  
5488 3a 9c 54			ld a, (.dmark)  
548b 32 a0 fd			ld (debug_mark),a  
548e 3a 9d 54			ld a, (.dmark+1)  
5491 32 a1 fd			ld (debug_mark+1),a  
5494 3a 9e 54			ld a, (.dmark+2)  
5497 32 a2 fd			ld (debug_mark+2),a  
549a 18 03			jr .pastdmark  
549c ..			.dmark: db "APP"  
549f f1			.pastdmark: pop af  
54a0			endm  
# End of macro DMARK
54a0						CALLMONITOR 
54a0 cd aa fd			call debug_vector  
54a3				endm  
# End of macro CALLMONITOR
54a3					endif 
54a3			 
54a3					FORTH_DSP_VALUEHL 
54a3 cd 4b 22			call macro_dsp_valuehl 
54a6				endm 
# End of macro FORTH_DSP_VALUEHL
54a6 e5					push hl 	; save file id 
54a7			 
54a7				if DEBUG_STORESE 
54a7					DMARK "AP1" 
54a7 f5				push af  
54a8 3a bc 54			ld a, (.dmark)  
54ab 32 a0 fd			ld (debug_mark),a  
54ae 3a bd 54			ld a, (.dmark+1)  
54b1 32 a1 fd			ld (debug_mark+1),a  
54b4 3a be 54			ld a, (.dmark+2)  
54b7 32 a2 fd			ld (debug_mark+2),a  
54ba 18 03			jr .pastdmark  
54bc ..			.dmark: db "AP1"  
54bf f1			.pastdmark: pop af  
54c0			endm  
# End of macro DMARK
54c0					CALLMONITOR 
54c0 cd aa fd			call debug_vector  
54c3				endm  
# End of macro CALLMONITOR
54c3				endif 
54c3					FORTH_DSP_POP 
54c3 cd 03 23			call macro_forth_dsp_pop 
54c6				endm 
# End of macro FORTH_DSP_POP
54c6			 
54c6					FORTH_DSP_VALUEHL 
54c6 cd 4b 22			call macro_dsp_valuehl 
54c9				endm 
# End of macro FORTH_DSP_VALUEHL
54c9					;v5 FORTH_DSP_VALUE 
54c9 e5					push hl 	; save ptr to string to save 
54ca			 
54ca				if DEBUG_STORESE 
54ca					DMARK "AP1" 
54ca f5				push af  
54cb 3a df 54			ld a, (.dmark)  
54ce 32 a0 fd			ld (debug_mark),a  
54d1 3a e0 54			ld a, (.dmark+1)  
54d4 32 a1 fd			ld (debug_mark+1),a  
54d7 3a e1 54			ld a, (.dmark+2)  
54da 32 a2 fd			ld (debug_mark+2),a  
54dd 18 03			jr .pastdmark  
54df ..			.dmark: db "AP1"  
54e2 f1			.pastdmark: pop af  
54e3			endm  
# End of macro DMARK
54e3					CALLMONITOR 
54e3 cd aa fd			call debug_vector  
54e6				endm  
# End of macro CALLMONITOR
54e6				endif 
54e6					FORTH_DSP_POP 
54e6 cd 03 23			call macro_forth_dsp_pop 
54e9				endm 
# End of macro FORTH_DSP_POP
54e9			 
54e9 d1					pop de 
54ea e1					pop hl 
54eb				if DEBUG_STORESE 
54eb					DMARK "AP2" 
54eb f5				push af  
54ec 3a 00 55			ld a, (.dmark)  
54ef 32 a0 fd			ld (debug_mark),a  
54f2 3a 01 55			ld a, (.dmark+1)  
54f5 32 a1 fd			ld (debug_mark+1),a  
54f8 3a 02 55			ld a, (.dmark+2)  
54fb 32 a2 fd			ld (debug_mark+2),a  
54fe 18 03			jr .pastdmark  
5500 ..			.dmark: db "AP2"  
5503 f1			.pastdmark: pop af  
5504			endm  
# End of macro DMARK
5504					CALLMONITOR 
5504 cd aa fd			call debug_vector  
5507				endm  
# End of macro CALLMONITOR
5507				endif 
5507					;inc de ; skip var type indicator 
5507			 
5507					; TODO how to append numerics???? 
5507			 
5507 cd 64 0b				call storage_append		 
550a			 
550a				       NEXTW 
550a c3 37 24			jp macro_next 
550d				endm 
# End of macro NEXTW
550d			.SDEL: 
550d				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
550d 6a				db WORD_SYS_CORE+86             
550e 59 55			dw .OPEN            
5510 05				db 4 + 1 
5511 .. 00			db "ERA",0              
5515				endm 
# End of macro CWHEAD
5515			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5515			; | | > [!NOTE] 
5515			; | | > Compatible with PicoSPINet  
5515					FORTH_DSP_VALUEHL 
5515 cd 4b 22			call macro_dsp_valuehl 
5518				endm 
# End of macro FORTH_DSP_VALUEHL
5518			;		push hl 	; save file id 
5518			 
5518					if DEBUG_FORTH_WORDS_KEY 
5518						DMARK "ERA" 
5518 f5				push af  
5519 3a 2d 55			ld a, (.dmark)  
551c 32 a0 fd			ld (debug_mark),a  
551f 3a 2e 55			ld a, (.dmark+1)  
5522 32 a1 fd			ld (debug_mark+1),a  
5525 3a 2f 55			ld a, (.dmark+2)  
5528 32 a2 fd			ld (debug_mark+2),a  
552b 18 03			jr .pastdmark  
552d ..			.dmark: db "ERA"  
5530 f1			.pastdmark: pop af  
5531			endm  
# End of macro DMARK
5531						CALLMONITOR 
5531 cd aa fd			call debug_vector  
5534				endm  
# End of macro CALLMONITOR
5534					endif 
5534				if DEBUG_STORESE 
5534					DMARK "ER1" 
5534 f5				push af  
5535 3a 49 55			ld a, (.dmark)  
5538 32 a0 fd			ld (debug_mark),a  
553b 3a 4a 55			ld a, (.dmark+1)  
553e 32 a1 fd			ld (debug_mark+1),a  
5541 3a 4b 55			ld a, (.dmark+2)  
5544 32 a2 fd			ld (debug_mark+2),a  
5547 18 03			jr .pastdmark  
5549 ..			.dmark: db "ER1"  
554c f1			.pastdmark: pop af  
554d			endm  
# End of macro DMARK
554d					CALLMONITOR 
554d cd aa fd			call debug_vector  
5550				endm  
# End of macro CALLMONITOR
5550				endif 
5550					FORTH_DSP_POP 
5550 cd 03 23			call macro_forth_dsp_pop 
5553				endm 
# End of macro FORTH_DSP_POP
5553			 
5553			;		pop hl 
5553			 
5553 cd b6 06				call storage_erase 
5556				       NEXTW 
5556 c3 37 24			jp macro_next 
5559				endm 
# End of macro NEXTW
5559			 
5559			.OPEN: 
5559				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5559 6b				db WORD_SYS_CORE+87             
555a ed 55			dw .READ            
555c 05				db 4 + 1 
555d .. 00			db "OPEN",0              
5562				endm 
# End of macro CWHEAD
5562			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5562			; | | e.g. 
5562			; | | $01 OPEN $01 DO $01 READ . LOOP 
5562			; | | 
5562			; | | Will return with 255 blocks if the file does not exist 
5562			; | | > [!NOTE] 
5562			; | | > Compatible with PicoSPINet  
5562			 
5562					if DEBUG_FORTH_WORDS_KEY 
5562						DMARK "OPN" 
5562 f5				push af  
5563 3a 77 55			ld a, (.dmark)  
5566 32 a0 fd			ld (debug_mark),a  
5569 3a 78 55			ld a, (.dmark+1)  
556c 32 a1 fd			ld (debug_mark+1),a  
556f 3a 79 55			ld a, (.dmark+2)  
5572 32 a2 fd			ld (debug_mark+2),a  
5575 18 03			jr .pastdmark  
5577 ..			.dmark: db "OPN"  
557a f1			.pastdmark: pop af  
557b			endm  
# End of macro DMARK
557b						CALLMONITOR 
557b cd aa fd			call debug_vector  
557e				endm  
# End of macro CALLMONITOR
557e					endif 
557e					; TODO handle multiple file opens 
557e			 
557e 3e 01			       	ld a, 1 
5580 32 9f f9				ld (store_openext), a 
5583			 
5583					; get max extents for this file 
5583				 
5583								 
5583					FORTH_DSP_VALUEHL 
5583 cd 4b 22			call macro_dsp_valuehl 
5586				endm 
# End of macro FORTH_DSP_VALUEHL
5586			 
5586 65					ld h, l 
5587 2e 00				ld l, 0 
5589			 
5589					; store file id 
5589			 
5589 7c					ld a, h 
558a 32 9c f9				ld (store_filecache), a 
558d			 
558d				if DEBUG_STORESE 
558d					DMARK "OPN" 
558d f5				push af  
558e 3a a2 55			ld a, (.dmark)  
5591 32 a0 fd			ld (debug_mark),a  
5594 3a a3 55			ld a, (.dmark+1)  
5597 32 a1 fd			ld (debug_mark+1),a  
559a 3a a4 55			ld a, (.dmark+2)  
559d 32 a2 fd			ld (debug_mark+2),a  
55a0 18 03			jr .pastdmark  
55a2 ..			.dmark: db "OPN"  
55a5 f1			.pastdmark: pop af  
55a6			endm  
# End of macro DMARK
55a6					CALLMONITOR 
55a6 cd aa fd			call debug_vector  
55a9				endm  
# End of macro CALLMONITOR
55a9				endif 
55a9			;		push hl 
55a9					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
55a9 cd 03 23			call macro_forth_dsp_pop 
55ac				endm 
# End of macro FORTH_DSP_POP
55ac			;		pop hl 
55ac						 
55ac 11 af f9				ld de, store_page      ; get block zero of file 
55af cd cd 09				call storage_read 
55b2 cd 07 10			call ishlzero 
55b5 20 04			jr nz, .opfound 
55b7			 
55b7				; file does not exist so indicate with 255 extents in use 
55b7			 
55b7 3e ff			ld a, 255 
55b9 18 29			jr .skipopeneof 
55bb			 
55bb			 
55bb			.opfound: 
55bb			 
55bb			 
55bb 3a b1 f9				ld a, (store_page+2)    ; max extents for this file 
55be 32 9e f9				ld  (store_openmaxext), a   ; get our limit and push 
55c1					 
55c1				if DEBUG_STORESE 
55c1					DMARK "OPx" 
55c1 f5				push af  
55c2 3a d6 55			ld a, (.dmark)  
55c5 32 a0 fd			ld (debug_mark),a  
55c8 3a d7 55			ld a, (.dmark+1)  
55cb 32 a1 fd			ld (debug_mark+1),a  
55ce 3a d8 55			ld a, (.dmark+2)  
55d1 32 a2 fd			ld (debug_mark+2),a  
55d4 18 03			jr .pastdmark  
55d6 ..			.dmark: db "OPx"  
55d9 f1			.pastdmark: pop af  
55da			endm  
# End of macro DMARK
55da					CALLMONITOR 
55da cd aa fd			call debug_vector  
55dd				endm  
# End of macro CALLMONITOR
55dd				endif 
55dd fe 00				cp 0 
55df 20 03				jr nz, .skipopeneof 
55e1					; have opened an empty file 
55e1					 
55e1 32 9f f9				ld (store_openext), a 
55e4			 
55e4			.skipopeneof: 
55e4			 
55e4 6f					ld l, a 
55e5 26 00				ld h, 0 
55e7 cd 46 20				call forth_push_numhl 
55ea			 
55ea			 
55ea				       NEXTW 
55ea c3 37 24			jp macro_next 
55ed				endm 
# End of macro NEXTW
55ed			.READ: 
55ed				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
55ed 6c				db WORD_SYS_CORE+88             
55ee 17 57			dw .EOF            
55f0 05				db 4 + 1 
55f1 .. 00			db "READ",0              
55f6				endm 
# End of macro CWHEAD
55f6			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
55f6			; | | e.g. 
55f6			; | | $01 OPEN $01 DO READ . LOOP 
55f6			; | | 
55f6			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
55f6			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
55f6			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
55f6			; | | two bytes contain the file id and extent. 
55f6			; | |  
55f6			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
55f6			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
55f6			; | | > [!NOTE] 
55f6			; | | > Compatible with PicoSPINet  
55f6			 
55f6					if DEBUG_FORTH_WORDS_KEY 
55f6						DMARK "REA" 
55f6 f5				push af  
55f7 3a 0b 56			ld a, (.dmark)  
55fa 32 a0 fd			ld (debug_mark),a  
55fd 3a 0c 56			ld a, (.dmark+1)  
5600 32 a1 fd			ld (debug_mark+1),a  
5603 3a 0d 56			ld a, (.dmark+2)  
5606 32 a2 fd			ld (debug_mark+2),a  
5609 18 03			jr .pastdmark  
560b ..			.dmark: db "REA"  
560e f1			.pastdmark: pop af  
560f			endm  
# End of macro DMARK
560f						CALLMONITOR 
560f cd aa fd			call debug_vector  
5612				endm  
# End of macro CALLMONITOR
5612					endif 
5612					; store_openext use it. If zero it is EOF 
5612			 
5612					; read block from current stream id 
5612					; if the block does not contain zero term keep reading blocks until zero found 
5612					; push the block to stack 
5612					; save the block id to stream 
5612			 
5612			 
5612 cd 44 57				call .testeof 
5615 3e 01				ld a, 1 
5617 bd					cp l 
5618 ca f3 56				jp z, .ateof 
561b			 
561b			 
561b			;		FORTH_DSP_VALUEHL 
561b			 
561b			;		push hl 
561b			 
561b			;	if DEBUG_STORESE 
561b			;		DMARK "REA" 
561b			;		CALLMONITOR 
561b			;	endif 
561b			;		FORTH_DSP_POP 
561b			 
561b			;		pop hl 
561b				 
561b 3a 9c f9				ld a, (store_filecache) 
561e 67					ld h,a 
561f			 
561f 3a 9f f9				ld a, (store_openext) 
5622 6f					ld l, a 
5623					 
5623 fe 00				cp 0 
5625 ca f3 56				jp z, .ateof     ; dont read past eof 
5628			 
5628 cd b0 0c				call storage_clear_page 
562b			 
562b 11 af f9				ld de, store_page 
562e				if DEBUG_STORESE 
562e					DMARK "RE1" 
562e f5				push af  
562f 3a 43 56			ld a, (.dmark)  
5632 32 a0 fd			ld (debug_mark),a  
5635 3a 44 56			ld a, (.dmark+1)  
5638 32 a1 fd			ld (debug_mark+1),a  
563b 3a 45 56			ld a, (.dmark+2)  
563e 32 a2 fd			ld (debug_mark+2),a  
5641 18 03			jr .pastdmark  
5643 ..			.dmark: db "RE1"  
5646 f1			.pastdmark: pop af  
5647			endm  
# End of macro DMARK
5647					CALLMONITOR 
5647 cd aa fd			call debug_vector  
564a				endm  
# End of macro CALLMONITOR
564a				endif 
564a cd cd 09				call storage_read 
564d			 
564d				if DEBUG_STORESE 
564d					DMARK "RE2" 
564d f5				push af  
564e 3a 62 56			ld a, (.dmark)  
5651 32 a0 fd			ld (debug_mark),a  
5654 3a 63 56			ld a, (.dmark+1)  
5657 32 a1 fd			ld (debug_mark+1),a  
565a 3a 64 56			ld a, (.dmark+2)  
565d 32 a2 fd			ld (debug_mark+2),a  
5660 18 03			jr .pastdmark  
5662 ..			.dmark: db "RE2"  
5665 f1			.pastdmark: pop af  
5666			endm  
# End of macro DMARK
5666					CALLMONITOR 
5666 cd aa fd			call debug_vector  
5669				endm  
# End of macro CALLMONITOR
5669				endif 
5669 cd 07 10			call ishlzero 
566c			;	ld a, l 
566c			;	add h 
566c			;	cp 0 
566c ca f3 56			jp z, .readeof 
566f			 
566f				; not eof so hl should point to data to push to stack 
566f			 
566f				if DEBUG_STORESE 
566f					DMARK "RE3" 
566f f5				push af  
5670 3a 84 56			ld a, (.dmark)  
5673 32 a0 fd			ld (debug_mark),a  
5676 3a 85 56			ld a, (.dmark+1)  
5679 32 a1 fd			ld (debug_mark+1),a  
567c 3a 86 56			ld a, (.dmark+2)  
567f 32 a2 fd			ld (debug_mark+2),a  
5682 18 03			jr .pastdmark  
5684 ..			.dmark: db "RE3"  
5687 f1			.pastdmark: pop af  
5688			endm  
# End of macro DMARK
5688					CALLMONITOR 
5688 cd aa fd			call debug_vector  
568b				endm  
# End of macro CALLMONITOR
568b				endif 
568b cd b4 20			call forth_push_str 
568e			 
568e				if DEBUG_STORESE 
568e					DMARK "RE4" 
568e f5				push af  
568f 3a a3 56			ld a, (.dmark)  
5692 32 a0 fd			ld (debug_mark),a  
5695 3a a4 56			ld a, (.dmark+1)  
5698 32 a1 fd			ld (debug_mark+1),a  
569b 3a a5 56			ld a, (.dmark+2)  
569e 32 a2 fd			ld (debug_mark+2),a  
56a1 18 03			jr .pastdmark  
56a3 ..			.dmark: db "RE4"  
56a6 f1			.pastdmark: pop af  
56a7			endm  
# End of macro DMARK
56a7					CALLMONITOR 
56a7 cd aa fd			call debug_vector  
56aa				endm  
# End of macro CALLMONITOR
56aa				endif 
56aa				; get next block  or mark as eof 
56aa			 
56aa 3a 9e f9			ld a, (store_openmaxext)   ; get our limit 
56ad 4f				ld c, a	 
56ae 3a 9f f9			ld a, (store_openext) 
56b1			 
56b1				if DEBUG_STORESE 
56b1					DMARK "RE5" 
56b1 f5				push af  
56b2 3a c6 56			ld a, (.dmark)  
56b5 32 a0 fd			ld (debug_mark),a  
56b8 3a c7 56			ld a, (.dmark+1)  
56bb 32 a1 fd			ld (debug_mark+1),a  
56be 3a c8 56			ld a, (.dmark+2)  
56c1 32 a2 fd			ld (debug_mark+2),a  
56c4 18 03			jr .pastdmark  
56c6 ..			.dmark: db "RE5"  
56c9 f1			.pastdmark: pop af  
56ca			endm  
# End of macro DMARK
56ca					CALLMONITOR 
56ca cd aa fd			call debug_vector  
56cd				endm  
# End of macro CALLMONITOR
56cd				endif 
56cd b9				cp c 
56ce 28 23			jr z, .readeof     ; at last extent 
56d0			 
56d0 3c					inc a 
56d1 32 9f f9				ld (store_openext), a 
56d4			 
56d4				if DEBUG_STORESE 
56d4					DMARK "RE6" 
56d4 f5				push af  
56d5 3a e9 56			ld a, (.dmark)  
56d8 32 a0 fd			ld (debug_mark),a  
56db 3a ea 56			ld a, (.dmark+1)  
56de 32 a1 fd			ld (debug_mark+1),a  
56e1 3a eb 56			ld a, (.dmark+2)  
56e4 32 a2 fd			ld (debug_mark+2),a  
56e7 18 03			jr .pastdmark  
56e9 ..			.dmark: db "RE6"  
56ec f1			.pastdmark: pop af  
56ed			endm  
# End of macro DMARK
56ed					CALLMONITOR 
56ed cd aa fd			call debug_vector  
56f0				endm  
# End of macro CALLMONITOR
56f0				endif 
56f0			 
56f0			 
56f0				       NEXTW 
56f0 c3 37 24			jp macro_next 
56f3				endm 
# End of macro NEXTW
56f3			.ateof: 
56f3				;	ld hl, .showeof 
56f3				;	call forth_push_str 
56f3 3e 00		.readeof:	ld a, 0 
56f5 32 9f f9				ld (store_openext), a 
56f8			 
56f8					 
56f8				if DEBUG_STORESE 
56f8					DMARK "REF" 
56f8 f5				push af  
56f9 3a 0d 57			ld a, (.dmark)  
56fc 32 a0 fd			ld (debug_mark),a  
56ff 3a 0e 57			ld a, (.dmark+1)  
5702 32 a1 fd			ld (debug_mark+1),a  
5705 3a 0f 57			ld a, (.dmark+2)  
5708 32 a2 fd			ld (debug_mark+2),a  
570b 18 03			jr .pastdmark  
570d ..			.dmark: db "REF"  
5710 f1			.pastdmark: pop af  
5711			endm  
# End of macro DMARK
5711					CALLMONITOR 
5711 cd aa fd			call debug_vector  
5714				endm  
# End of macro CALLMONITOR
5714				endif 
5714				       NEXTW 
5714 c3 37 24			jp macro_next 
5717				endm 
# End of macro NEXTW
5717			 
5717			;.showeof:   db "eof", 0 
5717			 
5717			 
5717			.EOF: 
5717				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5717 6d				db WORD_SYS_CORE+89             
5718 59 57			dw .FORMAT            
571a 04				db 3 + 1 
571b .. 00			db "EOF",0              
571f				endm 
# End of macro CWHEAD
571f			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
571f			; | | e.g. 
571f			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
571f			; | | > [!NOTE] 
571f			; | | > Compatible with PicoSPINet  
571f					; TODO if current block id for stream is zero then push true else false 
571f			 
571f					if DEBUG_FORTH_WORDS_KEY 
571f						DMARK "EOF" 
571f f5				push af  
5720 3a 34 57			ld a, (.dmark)  
5723 32 a0 fd			ld (debug_mark),a  
5726 3a 35 57			ld a, (.dmark+1)  
5729 32 a1 fd			ld (debug_mark+1),a  
572c 3a 36 57			ld a, (.dmark+2)  
572f 32 a2 fd			ld (debug_mark+2),a  
5732 18 03			jr .pastdmark  
5734 ..			.dmark: db "EOF"  
5737 f1			.pastdmark: pop af  
5738			endm  
# End of macro DMARK
5738						CALLMONITOR 
5738 cd aa fd			call debug_vector  
573b				endm  
# End of macro CALLMONITOR
573b					endif 
573b			 
573b					; TODO handlue multiple file streams 
573b			 
573b			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
573b cd 44 57				call .testeof 
573e cd 46 20				call forth_push_numhl 
5741			 
5741			 
5741				       NEXTW 
5741 c3 37 24			jp macro_next 
5744				endm 
# End of macro NEXTW
5744			 
5744			.testeof: 
5744 2e 01				ld l, 1 
5746 3a 9e f9				ld a, (store_openmaxext) 
5749 fe 00				cp 0 
574b 28 09				jr  z, .eofdone   ; empty file 
574d 3a 9f f9				ld a, (store_openext) 
5750 fe 00				cp 0 
5752 28 02				jr  z, .eofdone 
5754 2e 00				ld l, 0 
5756 26 00		.eofdone:	ld h, 0 
5758 c9					ret 
5759			 
5759			 
5759			 
5759			 
5759			.FORMAT: 
5759				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5759 6d				db WORD_SYS_CORE+89             
575a aa 57			dw .LABEL            
575c 07				db 6 + 1 
575d .. 00			db "FORMAT",0              
5764				endm 
# End of macro CWHEAD
5764			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5764			; | | > [!NOTE] 
5764			; | | > Compatible with PicoSPINet  
5764					; TODO if current block id for stream is zero then push true else false 
5764				 
5764				if DEBUG_STORESE 
5764					DMARK "FOR" 
5764 f5				push af  
5765 3a 79 57			ld a, (.dmark)  
5768 32 a0 fd			ld (debug_mark),a  
576b 3a 7a 57			ld a, (.dmark+1)  
576e 32 a1 fd			ld (debug_mark+1),a  
5771 3a 7b 57			ld a, (.dmark+2)  
5774 32 a2 fd			ld (debug_mark+2),a  
5777 18 03			jr .pastdmark  
5779 ..			.dmark: db "FOR"  
577c f1			.pastdmark: pop af  
577d			endm  
# End of macro DMARK
577d					CALLMONITOR 
577d cd aa fd			call debug_vector  
5780				endm  
# End of macro CALLMONITOR
5780				endif 
5780					; Wipes the bank check flags to cause a reformat on next block 0 read 
5780			 
5780 21 01 00				ld hl, 1 
5783 3e 00				ld a, 0 
5785 cd 79 02				call se_writebyte 
5788			 
5788				if DEBUG_STORESE 
5788					DMARK "FO0" 
5788 f5				push af  
5789 3a 9d 57			ld a, (.dmark)  
578c 32 a0 fd			ld (debug_mark),a  
578f 3a 9e 57			ld a, (.dmark+1)  
5792 32 a1 fd			ld (debug_mark+1),a  
5795 3a 9f 57			ld a, (.dmark+2)  
5798 32 a2 fd			ld (debug_mark+2),a  
579b 18 03			jr .pastdmark  
579d ..			.dmark: db "FO0"  
57a0 f1			.pastdmark: pop af  
57a1			endm  
# End of macro DMARK
57a1					CALLMONITOR 
57a1 cd aa fd			call debug_vector  
57a4				endm  
# End of macro CALLMONITOR
57a4				endif 
57a4					; force bank init 
57a4			 
57a4 cd 25 05				call storage_get_block_0 
57a7					 
57a7				       NEXTW 
57a7 c3 37 24			jp macro_next 
57aa				endm 
# End of macro NEXTW
57aa			.LABEL: 
57aa				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
57aa 6d				db WORD_SYS_CORE+89             
57ab f8 57			dw .STOREPAGE            
57ad 06				db 5 + 1 
57ae .. 00			db "LABEL",0              
57b4				endm 
# End of macro CWHEAD
57b4			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
57b4			; | | > [!NOTE] 
57b4			; | | > Compatible with PicoSPINet  
57b4					; TODO test to see if bank is selected 
57b4				 
57b4					if DEBUG_FORTH_WORDS_KEY 
57b4						DMARK "LBL" 
57b4 f5				push af  
57b5 3a c9 57			ld a, (.dmark)  
57b8 32 a0 fd			ld (debug_mark),a  
57bb 3a ca 57			ld a, (.dmark+1)  
57be 32 a1 fd			ld (debug_mark+1),a  
57c1 3a cb 57			ld a, (.dmark+2)  
57c4 32 a2 fd			ld (debug_mark+2),a  
57c7 18 03			jr .pastdmark  
57c9 ..			.dmark: db "LBL"  
57cc f1			.pastdmark: pop af  
57cd			endm  
# End of macro DMARK
57cd						CALLMONITOR 
57cd cd aa fd			call debug_vector  
57d0				endm  
# End of macro CALLMONITOR
57d0					endif 
57d0			;	if DEBUG_STORESE 
57d0			;		DMARK "LBL" 
57d0			;		CALLMONITOR 
57d0			;	endif 
57d0					FORTH_DSP_VALUEHL 
57d0 cd 4b 22			call macro_dsp_valuehl 
57d3				endm 
# End of macro FORTH_DSP_VALUEHL
57d3					;v5FORTH_DSP_VALUE 
57d3					 
57d3			;		push hl 
57d3					FORTH_DSP_POP 
57d3 cd 03 23			call macro_forth_dsp_pop 
57d6				endm 
# End of macro FORTH_DSP_POP
57d6			;		pop hl 
57d6			 
57d6			;v5		inc hl   ; move past the type marker 
57d6			 
57d6				if DEBUG_STORESE 
57d6					DMARK "LBl" 
57d6 f5				push af  
57d7 3a eb 57			ld a, (.dmark)  
57da 32 a0 fd			ld (debug_mark),a  
57dd 3a ec 57			ld a, (.dmark+1)  
57e0 32 a1 fd			ld (debug_mark+1),a  
57e3 3a ed 57			ld a, (.dmark+2)  
57e6 32 a2 fd			ld (debug_mark+2),a  
57e9 18 03			jr .pastdmark  
57eb ..			.dmark: db "LBl"  
57ee f1			.pastdmark: pop af  
57ef			endm  
# End of macro DMARK
57ef					CALLMONITOR 
57ef cd aa fd			call debug_vector  
57f2				endm  
# End of macro CALLMONITOR
57f2				endif 
57f2 cd 49 06				call storage_label 
57f5			 
57f5				       NEXTW 
57f5 c3 37 24			jp macro_next 
57f8				endm 
# End of macro NEXTW
57f8			.STOREPAGE: 
57f8				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
57f8 6d				db WORD_SYS_CORE+89             
57f9 2b 58			dw .LABELS            
57fb 0a				db 9 + 1 
57fc .. 00			db "STOREPAGE",0              
5806				endm 
# End of macro CWHEAD
5806			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5806			; | | > [!NOTE] 
5806			; | | > Compatible with PicoSPINet  
5806					; TODO test to see if bank is selected 
5806				 
5806					if DEBUG_FORTH_WORDS_KEY 
5806						DMARK "STP" 
5806 f5				push af  
5807 3a 1b 58			ld a, (.dmark)  
580a 32 a0 fd			ld (debug_mark),a  
580d 3a 1c 58			ld a, (.dmark+1)  
5810 32 a1 fd			ld (debug_mark+1),a  
5813 3a 1d 58			ld a, (.dmark+2)  
5816 32 a2 fd			ld (debug_mark+2),a  
5819 18 03			jr .pastdmark  
581b ..			.dmark: db "STP"  
581e f1			.pastdmark: pop af  
581f			endm  
# End of macro DMARK
581f						CALLMONITOR 
581f cd aa fd			call debug_vector  
5822				endm  
# End of macro CALLMONITOR
5822					endif 
5822			;	if DEBUG_STORESE 
5822			;		DMARK "STP" 
5822			;		CALLMONITOR 
5822			;	endif 
5822			 
5822 21 af f9			ld hl, store_page 
5825 cd 46 20			call forth_push_numhl 
5828			 
5828			 
5828				       NEXTW 
5828 c3 37 24			jp macro_next 
582b				endm 
# End of macro NEXTW
582b			.LABELS: 
582b				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
582b 6d				db WORD_SYS_CORE+89             
582c b5 58			dw .SCONST1            
582e 07				db 6 + 1 
582f .. 00			db "LABELS",0              
5836				endm 
# End of macro CWHEAD
5836			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
5836			; | | > [!CAUTION] 
5836			; | | > *NOT* Compatible with PicoSPINet  
5836					;  
5836			 
5836					; save the current device selected to restore afterwards 
5836				 
5836 3a 95 f9				ld a, (spi_device) 
5839 f5					push af 
583a			 
583a			 
583a					; run through each of the banks 
583a			 
583a 21 01 00				ld hl, 1 
583d cd 46 20				call forth_push_numhl 
5840 3e ff				ld a, SPI_CE_HIGH 
5842 cb 87				res SPI_CE0, a 
5844 32 95 f9				ld (spi_device), a 
5847 cd 25 05				call storage_get_block_0 
584a 21 b2 f9				ld hl, store_page+3 
584d cd b4 20				call forth_push_str 
5850			 
5850					 
5850 21 02 00				ld hl, 2 
5853 cd 46 20				call forth_push_numhl 
5856 3e ff				ld a, SPI_CE_HIGH 
5858 cb 8f				res SPI_CE1, a 
585a 32 95 f9				ld (spi_device), a 
585d cd 25 05				call storage_get_block_0 
5860 21 b2 f9				ld hl, store_page+3 
5863 cd b4 20				call forth_push_str 
5866			 
5866					 
5866 21 03 00				ld hl, 3 
5869 cd 46 20				call forth_push_numhl 
586c 3e ff				ld a, SPI_CE_HIGH 
586e cb 97				res SPI_CE2, a 
5870 32 95 f9				ld (spi_device), a 
5873 cd 25 05				call storage_get_block_0 
5876 21 b2 f9				ld hl, store_page+3 
5879 cd b4 20				call forth_push_str 
587c			 
587c			 
587c 21 04 00				ld hl, 4 
587f cd 46 20				call forth_push_numhl 
5882 3e ff				ld a, SPI_CE_HIGH 
5884 cb 9f				res SPI_CE3, a 
5886 32 95 f9				ld (spi_device), a 
5889 cd 25 05				call storage_get_block_0 
588c 21 b2 f9				ld hl, store_page+3 
588f cd b4 20				call forth_push_str 
5892			 
5892					 
5892			 
5892 21 05 00				ld hl, 5 
5895 cd 46 20				call forth_push_numhl 
5898 3e ff				ld a, SPI_CE_HIGH 
589a cb a7				res SPI_CE4, a 
589c 32 95 f9				ld (spi_device), a 
589f cd 25 05				call storage_get_block_0 
58a2 21 b2 f9				ld hl, store_page+3 
58a5 cd b4 20				call forth_push_str 
58a8			 
58a8					 
58a8					; push fixed count of storage devices (on board) for now 
58a8			 
58a8 21 05 00				ld hl, 5 
58ab cd 46 20				call forth_push_numhl 
58ae			 
58ae					; restore selected device  
58ae				 
58ae f1					pop af 
58af 32 95 f9				ld (spi_device), a 
58b2			 
58b2				       NEXTW 
58b2 c3 37 24			jp macro_next 
58b5				endm 
# End of macro NEXTW
58b5			 
58b5			.SCONST1: 
58b5				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
58b5 6d				db WORD_SYS_CORE+89             
58b6 cc 58			dw .SCONST2            
58b8 07				db 6 + 1 
58b9 .. 00			db "FILEID",0              
58c0				endm 
# End of macro CWHEAD
58c0			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
58c0			; | | > [!NOTE] 
58c0			; | | > Compatible with PicoSPINet  
58c0 3a 9c f9				ld a, (store_filecache) 
58c3 26 00				ld h, 0 
58c5 6f					ld l, a 
58c6 cd 46 20				call forth_push_numhl 
58c9					NEXTW 
58c9 c3 37 24			jp macro_next 
58cc				endm 
# End of macro NEXTW
58cc			.SCONST2: 
58cc				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
58cc 6d				db WORD_SYS_CORE+89             
58cd e4 58			dw .SCONST3            
58cf 08				db 7 + 1 
58d0 .. 00			db "FILEEXT",0              
58d8				endm 
# End of macro CWHEAD
58d8			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
58d8			; | | > [!NOTE] 
58d8			; | | > Compatible with PicoSPINet  
58d8 3a 9f f9				ld a, (store_openext) 
58db 26 00				ld h, 0 
58dd 6f					ld l, a 
58de cd 46 20				call forth_push_numhl 
58e1					NEXTW 
58e1 c3 37 24			jp macro_next 
58e4				endm 
# End of macro NEXTW
58e4			.SCONST3: 
58e4				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
58e4 6d				db WORD_SYS_CORE+89             
58e5 fc 58			dw .SCONST4            
58e7 08				db 7 + 1 
58e8 .. 00			db "FILEMAX",0              
58f0				endm 
# End of macro CWHEAD
58f0			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
58f0			; | | > [!NOTE] 
58f0			; | | > Compatible with PicoSPINet  
58f0 3a 9e f9				ld a, (store_openmaxext) 
58f3 26 00				ld h, 0 
58f5 6f					ld l, a 
58f6 cd 46 20				call forth_push_numhl 
58f9					NEXTW 
58f9 c3 37 24			jp macro_next 
58fc				endm 
# End of macro NEXTW
58fc			.SCONST4: 
58fc				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
58fc 6d				db WORD_SYS_CORE+89             
58fd 12 59			dw .SCONST5            
58ff 09				db 8 + 1 
5900 .. 00			db "FILEADDR",0              
5909				endm 
# End of macro CWHEAD
5909			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5909			; | | > [!NOTE] 
5909			; | | > Compatible with PicoSPINet  
5909 2a a0 f9				ld hl, (store_openaddr) 
590c cd 46 20				call forth_push_numhl 
590f					NEXTW 
590f c3 37 24			jp macro_next 
5912				endm 
# End of macro NEXTW
5912			.SCONST5: 
5912				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5912 6d				db WORD_SYS_CORE+89             
5913 33 59			dw .SCONST6            
5915 09				db 8 + 1 
5916 .. 00			db "FILEPAGE",0              
591f				endm 
# End of macro CWHEAD
591f			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
591f			; | | > [!NOTE] 
591f			; | | > Compatible with PicoSPINet  
591f 2a a0 f9				ld hl, (store_openaddr) 
5922 e5					push hl 
5923 c1					pop bc 
5924 16 00				ld d, 0 
5926 1e 40				ld e, STORE_BLOCK_PHY 
5928 cd 3b 0f				call Div16 
592b c5					push bc 
592c e1					pop hl 
592d cd 46 20				call forth_push_numhl 
5930					NEXTW 
5930 c3 37 24			jp macro_next 
5933				endm 
# End of macro NEXTW
5933			.SCONST6: 
5933				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5933 6d				db WORD_SYS_CORE+89             
5934 4c 59			dw .ENDSTORAGE            
5936 09				db 8 + 1 
5937 .. 00			db "READCONT",0              
5940				endm 
# End of macro CWHEAD
5940			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5940			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5940			; | | a further read should, if applicable, be CONCAT to the previous read. 
5940			; | | > [!NOTE] 
5940			; | | > Compatible with PicoSPINet  
5940 3a a2 f9				ld a, (store_readcont) 
5943 26 00				ld h, 0 
5945 6f					ld l, a 
5946 cd 46 20				call forth_push_numhl 
5949					NEXTW 
5949 c3 37 24			jp macro_next 
594c				endm 
# End of macro NEXTW
594c			.ENDSTORAGE: 
594c			; eof 
# End of file forth_words_storage.asm
594c			endif 
594c				include "forth_words_device.asm" 
594c			; Device related words 
594c			 
594c			; | ## Device Words 
594c			 
594c			;if SOUND_ENABLE 
594c			;.NOTE: 
594c			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
594c			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
594c			;		if DEBUG_FORTH_WORDS_KEY 
594c			;			DMARK "NTE" 
594c			;			CALLMONITOR 
594c			;		endif 
594c			; 
594c			;	 
594c			; 
594c			;		NEXTW 
594c			;.AFTERSOUND: 
594c			;endif 
594c			 
594c			 
594c			USE_GPIO: equ 0 
594c			 
594c			if USE_GPIO 
594c			.GP1: 
594c				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
594c			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
594c					NEXTW 
594c			.GP2: 
594c				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
594c			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
594c			 
594c					NEXTW 
594c			 
594c			.GP3: 
594c				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
594c			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
594c			 
594c					NEXTW 
594c			 
594c			.GP4: 
594c				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
594c			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
594c			 
594c					NEXTW 
594c			.SIN: 
594c			 
594c			 
594c			endif 
594c			 
594c			 
594c				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
594c 33				db WORD_SYS_CORE+31             
594d 81 59			dw .SOUT            
594f 03				db 2 + 1 
5950 .. 00			db "IN",0              
5953				endm 
# End of macro CWHEAD
5953			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5953					if DEBUG_FORTH_WORDS_KEY 
5953						DMARK "IN." 
5953 f5				push af  
5954 3a 68 59			ld a, (.dmark)  
5957 32 a0 fd			ld (debug_mark),a  
595a 3a 69 59			ld a, (.dmark+1)  
595d 32 a1 fd			ld (debug_mark+1),a  
5960 3a 6a 59			ld a, (.dmark+2)  
5963 32 a2 fd			ld (debug_mark+2),a  
5966 18 03			jr .pastdmark  
5968 ..			.dmark: db "IN."  
596b f1			.pastdmark: pop af  
596c			endm  
# End of macro DMARK
596c						CALLMONITOR 
596c cd aa fd			call debug_vector  
596f				endm  
# End of macro CALLMONITOR
596f					endif 
596f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
596f cd 4b 22			call macro_dsp_valuehl 
5972				endm 
# End of macro FORTH_DSP_VALUEHL
5972			 
5972 e5					push hl 
5973			 
5973					; destroy value TOS 
5973			 
5973					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5973 cd 03 23			call macro_forth_dsp_pop 
5976				endm 
# End of macro FORTH_DSP_POP
5976			 
5976					; one value on hl get other one back 
5976			 
5976 c1					pop bc 
5977			 
5977					; do the sub 
5977			;		ex de, hl 
5977			 
5977 ed 68				in l,(c) 
5979			 
5979					; save it 
5979			 
5979 26 00				ld h,0 
597b			 
597b					; TODO push value back onto stack for another op etc 
597b			 
597b cd 46 20				call forth_push_numhl 
597e					NEXTW 
597e c3 37 24			jp macro_next 
5981				endm 
# End of macro NEXTW
5981			.SOUT: 
5981				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5981 34				db WORD_SYS_CORE+32             
5982 d4 59			dw .SPIO            
5984 04				db 3 + 1 
5985 .. 00			db "OUT",0              
5989				endm 
# End of macro CWHEAD
5989			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5989					if DEBUG_FORTH_WORDS_KEY 
5989						DMARK "OUT" 
5989 f5				push af  
598a 3a 9e 59			ld a, (.dmark)  
598d 32 a0 fd			ld (debug_mark),a  
5990 3a 9f 59			ld a, (.dmark+1)  
5993 32 a1 fd			ld (debug_mark+1),a  
5996 3a a0 59			ld a, (.dmark+2)  
5999 32 a2 fd			ld (debug_mark+2),a  
599c 18 03			jr .pastdmark  
599e ..			.dmark: db "OUT"  
59a1 f1			.pastdmark: pop af  
59a2			endm  
# End of macro DMARK
59a2						CALLMONITOR 
59a2 cd aa fd			call debug_vector  
59a5				endm  
# End of macro CALLMONITOR
59a5					endif 
59a5			 
59a5					; get port 
59a5			 
59a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59a5 cd 4b 22			call macro_dsp_valuehl 
59a8				endm 
# End of macro FORTH_DSP_VALUEHL
59a8			 
59a8 e5					push hl 
59a9			 
59a9					; destroy value TOS 
59a9			 
59a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59a9 cd 03 23			call macro_forth_dsp_pop 
59ac				endm 
# End of macro FORTH_DSP_POP
59ac			 
59ac					; get byte to send 
59ac			 
59ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59ac cd 4b 22			call macro_dsp_valuehl 
59af				endm 
# End of macro FORTH_DSP_VALUEHL
59af			 
59af			;		push hl 
59af			 
59af					; destroy value TOS 
59af			 
59af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59af cd 03 23			call macro_forth_dsp_pop 
59b2				endm 
# End of macro FORTH_DSP_POP
59b2			 
59b2					; one value on hl get other one back 
59b2			 
59b2			;		pop hl 
59b2			 
59b2 c1					pop bc 
59b3			 
59b3					if DEBUG_FORTH_WORDS 
59b3						DMARK "OUT" 
59b3 f5				push af  
59b4 3a c8 59			ld a, (.dmark)  
59b7 32 a0 fd			ld (debug_mark),a  
59ba 3a c9 59			ld a, (.dmark+1)  
59bd 32 a1 fd			ld (debug_mark+1),a  
59c0 3a ca 59			ld a, (.dmark+2)  
59c3 32 a2 fd			ld (debug_mark+2),a  
59c6 18 03			jr .pastdmark  
59c8 ..			.dmark: db "OUT"  
59cb f1			.pastdmark: pop af  
59cc			endm  
# End of macro DMARK
59cc						CALLMONITOR 
59cc cd aa fd			call debug_vector  
59cf				endm  
# End of macro CALLMONITOR
59cf					endif 
59cf			 
59cf ed 69				out (c), l 
59d1			 
59d1					NEXTW 
59d1 c3 37 24			jp macro_next 
59d4				endm 
# End of macro NEXTW
59d4			 
59d4			 
59d4			.SPIO: 
59d4			 
59d4			if STORAGE_SE 
59d4				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
59d4 51				db WORD_SYS_CORE+61             
59d5 e5 59			dw .SPICEH            
59d7 07				db 6 + 1 
59d8 .. 00			db "SPICEL",0              
59df				endm 
# End of macro CWHEAD
59df			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
59df			 
59df cd 22 02				call spi_ce_low 
59e2			    NEXTW 
59e2 c3 37 24			jp macro_next 
59e5				endm 
# End of macro NEXTW
59e5			 
59e5			.SPICEH: 
59e5				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
59e5 51				db WORD_SYS_CORE+61             
59e6 f6 59			dw .SPIOb            
59e8 07				db 6 + 1 
59e9 .. 00			db "SPICEH",0              
59f0				endm 
# End of macro CWHEAD
59f0			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
59f0			 
59f0 cd 11 02				call spi_ce_high 
59f3			    NEXTW 
59f3 c3 37 24			jp macro_next 
59f6				endm 
# End of macro NEXTW
59f6			 
59f6			 
59f6			.SPIOb: 
59f6			 
59f6				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
59f6 51				db WORD_SYS_CORE+61             
59f7 28 5a			dw .SPII            
59f9 05				db 4 + 1 
59fa .. 00			db "SPIO",0              
59ff				endm 
# End of macro CWHEAD
59ff			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
59ff			 
59ff					if DEBUG_FORTH_WORDS_KEY 
59ff						DMARK "SPo" 
59ff f5				push af  
5a00 3a 14 5a			ld a, (.dmark)  
5a03 32 a0 fd			ld (debug_mark),a  
5a06 3a 15 5a			ld a, (.dmark+1)  
5a09 32 a1 fd			ld (debug_mark+1),a  
5a0c 3a 16 5a			ld a, (.dmark+2)  
5a0f 32 a2 fd			ld (debug_mark+2),a  
5a12 18 03			jr .pastdmark  
5a14 ..			.dmark: db "SPo"  
5a17 f1			.pastdmark: pop af  
5a18			endm  
# End of macro DMARK
5a18						CALLMONITOR 
5a18 cd aa fd			call debug_vector  
5a1b				endm  
# End of macro CALLMONITOR
5a1b					endif 
5a1b					; get port 
5a1b			 
5a1b			 
5a1b					; get byte to send 
5a1b			 
5a1b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a1b cd 4b 22			call macro_dsp_valuehl 
5a1e				endm 
# End of macro FORTH_DSP_VALUEHL
5a1e			 
5a1e			;		push hl    ; u1  
5a1e			 
5a1e					; destroy value TOS 
5a1e			 
5a1e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a1e cd 03 23			call macro_forth_dsp_pop 
5a21				endm 
# End of macro FORTH_DSP_POP
5a21			 
5a21					; one value on hl get other one back 
5a21			 
5a21			;		pop hl   ; u2 - addr 
5a21			 
5a21					; TODO Send SPI byte 
5a21			 
5a21			;		push hl 
5a21			;		call spi_ce_low 
5a21			;		pop hl 
5a21 7d					ld a, l 
5a22 cd 10 01				call spi_send_byte 
5a25			;		call spi_ce_high 
5a25			 
5a25					NEXTW 
5a25 c3 37 24			jp macro_next 
5a28				endm 
# End of macro NEXTW
5a28			 
5a28			.SPII: 
5a28				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5a28 52				db WORD_SYS_CORE+62             
5a29 91 5a			dw .SESEL            
5a2b 06				db 5 + 1 
5a2c .. 00			db "SPII",0              
5a31				endm 
# End of macro CWHEAD
5a31			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5a31					if DEBUG_FORTH_WORDS_KEY 
5a31						DMARK "SPi" 
5a31 f5				push af  
5a32 3a 46 5a			ld a, (.dmark)  
5a35 32 a0 fd			ld (debug_mark),a  
5a38 3a 47 5a			ld a, (.dmark+1)  
5a3b 32 a1 fd			ld (debug_mark+1),a  
5a3e 3a 48 5a			ld a, (.dmark+2)  
5a41 32 a2 fd			ld (debug_mark+2),a  
5a44 18 03			jr .pastdmark  
5a46 ..			.dmark: db "SPi"  
5a49 f1			.pastdmark: pop af  
5a4a			endm  
# End of macro DMARK
5a4a						CALLMONITOR 
5a4a cd aa fd			call debug_vector  
5a4d				endm  
# End of macro CALLMONITOR
5a4d					endif 
5a4d			 
5a4d					; TODO Get SPI byte 
5a4d			 
5a4d cd 37 01				call spi_read_byte 
5a50			 
5a50					if DEBUG_FORTH_WORDS 
5a50						DMARK "Si2" 
5a50 f5				push af  
5a51 3a 65 5a			ld a, (.dmark)  
5a54 32 a0 fd			ld (debug_mark),a  
5a57 3a 66 5a			ld a, (.dmark+1)  
5a5a 32 a1 fd			ld (debug_mark+1),a  
5a5d 3a 67 5a			ld a, (.dmark+2)  
5a60 32 a2 fd			ld (debug_mark+2),a  
5a63 18 03			jr .pastdmark  
5a65 ..			.dmark: db "Si2"  
5a68 f1			.pastdmark: pop af  
5a69			endm  
# End of macro DMARK
5a69						CALLMONITOR 
5a69 cd aa fd			call debug_vector  
5a6c				endm  
# End of macro CALLMONITOR
5a6c					endif 
5a6c 26 00				ld h, 0 
5a6e 6f					ld l, a 
5a6f					if DEBUG_FORTH_WORDS 
5a6f						DMARK "Si3" 
5a6f f5				push af  
5a70 3a 84 5a			ld a, (.dmark)  
5a73 32 a0 fd			ld (debug_mark),a  
5a76 3a 85 5a			ld a, (.dmark+1)  
5a79 32 a1 fd			ld (debug_mark+1),a  
5a7c 3a 86 5a			ld a, (.dmark+2)  
5a7f 32 a2 fd			ld (debug_mark+2),a  
5a82 18 03			jr .pastdmark  
5a84 ..			.dmark: db "Si3"  
5a87 f1			.pastdmark: pop af  
5a88			endm  
# End of macro DMARK
5a88						CALLMONITOR 
5a88 cd aa fd			call debug_vector  
5a8b				endm  
# End of macro CALLMONITOR
5a8b					endif 
5a8b cd 46 20				call forth_push_numhl 
5a8e			 
5a8e					NEXTW 
5a8e c3 37 24			jp macro_next 
5a91				endm 
# End of macro NEXTW
5a91			 
5a91			 
5a91			 
5a91			.SESEL: 
5a91				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a91 66				db WORD_SYS_CORE+82             
5a92 3a 5b			dw .CARTDEV            
5a94 05				db 4 + 1 
5a95 .. 00			db "BANK",0              
5a9a				endm 
# End of macro CWHEAD
5a9a			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a9a					if DEBUG_FORTH_WORDS_KEY 
5a9a						DMARK "BNK" 
5a9a f5				push af  
5a9b 3a af 5a			ld a, (.dmark)  
5a9e 32 a0 fd			ld (debug_mark),a  
5aa1 3a b0 5a			ld a, (.dmark+1)  
5aa4 32 a1 fd			ld (debug_mark+1),a  
5aa7 3a b1 5a			ld a, (.dmark+2)  
5aaa 32 a2 fd			ld (debug_mark+2),a  
5aad 18 03			jr .pastdmark  
5aaf ..			.dmark: db "BNK"  
5ab2 f1			.pastdmark: pop af  
5ab3			endm  
# End of macro DMARK
5ab3						CALLMONITOR 
5ab3 cd aa fd			call debug_vector  
5ab6				endm  
# End of macro CALLMONITOR
5ab6					endif 
5ab6			 
5ab6 3e ff				ld a, 255 
5ab8 32 98 f9				ld (spi_cartdev), a 
5abb			 
5abb					; get bank 
5abb			 
5abb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5abb cd 4b 22			call macro_dsp_valuehl 
5abe				endm 
# End of macro FORTH_DSP_VALUEHL
5abe			 
5abe			;		push hl 
5abe			 
5abe					; destroy value TOS 
5abe			 
5abe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5abe cd 03 23			call macro_forth_dsp_pop 
5ac1				endm 
# End of macro FORTH_DSP_POP
5ac1			 
5ac1					; one value on hl get other one back 
5ac1			 
5ac1			;		pop hl 
5ac1			 
5ac1			 
5ac1 0e ff				ld c, SPI_CE_HIGH 
5ac3 06 30				ld b, '0'    ; human readable bank number 
5ac5			 
5ac5 7d					ld a, l 
5ac6			 
5ac6					if DEBUG_FORTH_WORDS 
5ac6						DMARK "BNK" 
5ac6 f5				push af  
5ac7 3a db 5a			ld a, (.dmark)  
5aca 32 a0 fd			ld (debug_mark),a  
5acd 3a dc 5a			ld a, (.dmark+1)  
5ad0 32 a1 fd			ld (debug_mark+1),a  
5ad3 3a dd 5a			ld a, (.dmark+2)  
5ad6 32 a2 fd			ld (debug_mark+2),a  
5ad9 18 03			jr .pastdmark  
5adb ..			.dmark: db "BNK"  
5ade f1			.pastdmark: pop af  
5adf			endm  
# End of macro DMARK
5adf						CALLMONITOR 
5adf cd aa fd			call debug_vector  
5ae2				endm  
# End of macro CALLMONITOR
5ae2					endif 
5ae2			 
5ae2					; active low 
5ae2			 
5ae2 fe 00				cp 0 
5ae4 28 28				jr z, .bset 
5ae6 fe 01				cp 1 
5ae8 20 04				jr nz, .b2 
5aea cb 81				res 0, c 
5aec 06 31				ld b, '1'    ; human readable bank number 
5aee fe 02		.b2:		cp 2 
5af0 20 04				jr nz, .b3 
5af2 cb 89				res 1, c 
5af4 06 32				ld b, '2'    ; human readable bank number 
5af6 fe 03		.b3:		cp 3 
5af8 20 04				jr nz, .b4 
5afa cb 91				res 2, c 
5afc 06 33				ld b, '3'    ; human readable bank number 
5afe fe 04		.b4:		cp 4 
5b00 20 04				jr nz, .b5 
5b02 cb 99				res 3, c 
5b04 06 34				ld b, '4'    ; human readable bank number 
5b06 fe 05		.b5:		cp 5 
5b08 20 04				jr nz, .bset 
5b0a cb a1				res 4, c 
5b0c 06 35				ld b, '5'    ; human readable bank number 
5b0e			 
5b0e			.bset: 
5b0e 79					ld a, c 
5b0f 32 95 f9				ld (spi_device),a 
5b12 78					ld a, b 
5b13 32 94 f9				ld (spi_device_id),a 
5b16					if DEBUG_FORTH_WORDS 
5b16						DMARK "BN2" 
5b16 f5				push af  
5b17 3a 2b 5b			ld a, (.dmark)  
5b1a 32 a0 fd			ld (debug_mark),a  
5b1d 3a 2c 5b			ld a, (.dmark+1)  
5b20 32 a1 fd			ld (debug_mark+1),a  
5b23 3a 2d 5b			ld a, (.dmark+2)  
5b26 32 a2 fd			ld (debug_mark+2),a  
5b29 18 03			jr .pastdmark  
5b2b ..			.dmark: db "BN2"  
5b2e f1			.pastdmark: pop af  
5b2f			endm  
# End of macro DMARK
5b2f						CALLMONITOR 
5b2f cd aa fd			call debug_vector  
5b32				endm  
# End of macro CALLMONITOR
5b32					endif 
5b32			 
5b32					; set default SPI clk pulse time as disabled for BANK use 
5b32			 
5b32 3e 00				ld a, 0 
5b34 32 99 f9				ld (spi_clktime), a 
5b37			 
5b37					NEXTW 
5b37 c3 37 24			jp macro_next 
5b3a				endm 
# End of macro NEXTW
5b3a			 
5b3a			.CARTDEV: 
5b3a				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5b3a 66				db WORD_SYS_CORE+82             
5b3b e8 5b			dw .ENDDEVICE            
5b3d 08				db 7 + 1 
5b3e .. 00			db "CARTDEV",0              
5b46				endm 
# End of macro CWHEAD
5b46			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5b46					if DEBUG_FORTH_WORDS_KEY 
5b46						DMARK "CDV" 
5b46 f5				push af  
5b47 3a 5b 5b			ld a, (.dmark)  
5b4a 32 a0 fd			ld (debug_mark),a  
5b4d 3a 5c 5b			ld a, (.dmark+1)  
5b50 32 a1 fd			ld (debug_mark+1),a  
5b53 3a 5d 5b			ld a, (.dmark+2)  
5b56 32 a2 fd			ld (debug_mark+2),a  
5b59 18 03			jr .pastdmark  
5b5b ..			.dmark: db "CDV"  
5b5e f1			.pastdmark: pop af  
5b5f			endm  
# End of macro DMARK
5b5f						CALLMONITOR 
5b5f cd aa fd			call debug_vector  
5b62				endm  
# End of macro CALLMONITOR
5b62					endif 
5b62			 
5b62					; disable se storage bank selection 
5b62			 
5b62 3e ff				ld a, SPI_CE_HIGH		; ce high 
5b64 32 95 f9				ld (spi_device), a 
5b67			 
5b67					; get bank 
5b67			 
5b67					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b67 cd 4b 22			call macro_dsp_valuehl 
5b6a				endm 
# End of macro FORTH_DSP_VALUEHL
5b6a			 
5b6a			;		push hl 
5b6a			 
5b6a					; destroy value TOS 
5b6a			 
5b6a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b6a cd 03 23			call macro_forth_dsp_pop 
5b6d				endm 
# End of macro FORTH_DSP_POP
5b6d			 
5b6d					; one value on hl get other one back 
5b6d			 
5b6d			;		pop hl 
5b6d			 
5b6d					; active low 
5b6d			 
5b6d 0e ff				ld c, 255 
5b6f			 
5b6f 7d					ld a, l 
5b70					if DEBUG_FORTH_WORDS 
5b70						DMARK "CDV" 
5b70 f5				push af  
5b71 3a 85 5b			ld a, (.dmark)  
5b74 32 a0 fd			ld (debug_mark),a  
5b77 3a 86 5b			ld a, (.dmark+1)  
5b7a 32 a1 fd			ld (debug_mark+1),a  
5b7d 3a 87 5b			ld a, (.dmark+2)  
5b80 32 a2 fd			ld (debug_mark+2),a  
5b83 18 03			jr .pastdmark  
5b85 ..			.dmark: db "CDV"  
5b88 f1			.pastdmark: pop af  
5b89			endm  
# End of macro DMARK
5b89						CALLMONITOR 
5b89 cd aa fd			call debug_vector  
5b8c				endm  
# End of macro CALLMONITOR
5b8c					endif 
5b8c fe 00				cp 0 
5b8e 28 30				jr z, .cset 
5b90 fe 01				cp 1 
5b92 20 02				jr nz, .c2 
5b94 cb 81				res 0, c 
5b96 fe 02		.c2:		cp 2 
5b98 20 02				jr nz, .c3 
5b9a cb 89				res 1, c 
5b9c fe 03		.c3:		cp 3 
5b9e 20 02				jr nz, .c4 
5ba0 cb 91				res 2, c 
5ba2 fe 04		.c4:		cp 4 
5ba4 20 02				jr nz, .c5 
5ba6 cb 99				res 3, c 
5ba8 fe 05		.c5:		cp 5 
5baa 20 02				jr nz, .c6 
5bac cb a1				res 4, c 
5bae fe 06		.c6:		cp 6 
5bb0 20 02				jr nz, .c7 
5bb2 cb a9				res 5, c 
5bb4 fe 07		.c7:		cp 7 
5bb6 20 02				jr nz, .c8 
5bb8 cb b1				res 6, c 
5bba fe 08		.c8:		cp 8 
5bbc 20 02				jr nz, .cset 
5bbe cb b9				res 7, c 
5bc0 79			.cset:		ld a, c 
5bc1 32 98 f9				ld (spi_cartdev),a 
5bc4			 
5bc4					if DEBUG_FORTH_WORDS 
5bc4						DMARK "CD2" 
5bc4 f5				push af  
5bc5 3a d9 5b			ld a, (.dmark)  
5bc8 32 a0 fd			ld (debug_mark),a  
5bcb 3a da 5b			ld a, (.dmark+1)  
5bce 32 a1 fd			ld (debug_mark+1),a  
5bd1 3a db 5b			ld a, (.dmark+2)  
5bd4 32 a2 fd			ld (debug_mark+2),a  
5bd7 18 03			jr .pastdmark  
5bd9 ..			.dmark: db "CD2"  
5bdc f1			.pastdmark: pop af  
5bdd			endm  
# End of macro DMARK
5bdd						CALLMONITOR 
5bdd cd aa fd			call debug_vector  
5be0				endm  
# End of macro CALLMONITOR
5be0					endif 
5be0			 
5be0					; set default SPI clk pulse time as 10ms for CARTDEV use 
5be0			 
5be0 3e 0a				ld a, $0a 
5be2 32 99 f9				ld (spi_clktime), a 
5be5					NEXTW 
5be5 c3 37 24			jp macro_next 
5be8				endm 
# End of macro NEXTW
5be8			endif 
5be8			 
5be8			.ENDDEVICE: 
5be8			; eof 
5be8			 
# End of file forth_words_device.asm
5be8			 
5be8			; var handler 
5be8			 
5be8			 
5be8			.VARS: 
5be8				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5be8 77				db WORD_SYS_CORE+99             
5be9 99 5c			dw .V0            
5beb 04				db 3 + 1 
5bec .. 00			db "VAR",0              
5bf0				endm 
# End of macro CWHEAD
5bf0			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5bf0			;| 
5bf0			;| The variable name should consist of a single letter. e.g. "a" 
5bf0			;! If a full string is passed then only the first char is looked at 
5bf0			;| Any other char could exceed bounds checks!  
5bf0			 
5bf0					if DEBUG_FORTH_WORDS_KEY 
5bf0						DMARK "VAR" 
5bf0 f5				push af  
5bf1 3a 05 5c			ld a, (.dmark)  
5bf4 32 a0 fd			ld (debug_mark),a  
5bf7 3a 06 5c			ld a, (.dmark+1)  
5bfa 32 a1 fd			ld (debug_mark+1),a  
5bfd 3a 07 5c			ld a, (.dmark+2)  
5c00 32 a2 fd			ld (debug_mark+2),a  
5c03 18 03			jr .pastdmark  
5c05 ..			.dmark: db "VAR"  
5c08 f1			.pastdmark: pop af  
5c09			endm  
# End of macro DMARK
5c09						CALLMONITOR 
5c09 cd aa fd			call debug_vector  
5c0c				endm  
# End of macro CALLMONITOR
5c0c					endif 
5c0c			 
5c0c					FORTH_DSP_VALUEHL 
5c0c cd 4b 22			call macro_dsp_valuehl 
5c0f				endm 
# End of macro FORTH_DSP_VALUEHL
5c0f			 
5c0f 7e					ld a, (hl)    ; get first char on of the string 
5c10			 
5c10			 
5c10					if DEBUG_FORTH_WORDS 
5c10						DMARK "VR1" 
5c10 f5				push af  
5c11 3a 25 5c			ld a, (.dmark)  
5c14 32 a0 fd			ld (debug_mark),a  
5c17 3a 26 5c			ld a, (.dmark+1)  
5c1a 32 a1 fd			ld (debug_mark+1),a  
5c1d 3a 27 5c			ld a, (.dmark+2)  
5c20 32 a2 fd			ld (debug_mark+2),a  
5c23 18 03			jr .pastdmark  
5c25 ..			.dmark: db "VR1"  
5c28 f1			.pastdmark: pop af  
5c29			endm  
# End of macro DMARK
5c29						CALLMONITOR 
5c29 cd aa fd			call debug_vector  
5c2c				endm  
# End of macro CALLMONITOR
5c2c					endif 
5c2c					 
5c2c f5					push af	 
5c2d					FORTH_DSP_POP 
5c2d cd 03 23			call macro_forth_dsp_pop 
5c30				endm 
# End of macro FORTH_DSP_POP
5c30 f1					pop af 
5c31			 
5c31					; convert to upper 
5c31			 
5c31 cd 53 12				call to_upper 
5c34					if DEBUG_FORTH_WORDS 
5c34						DMARK "Vaa" 
5c34 f5				push af  
5c35 3a 49 5c			ld a, (.dmark)  
5c38 32 a0 fd			ld (debug_mark),a  
5c3b 3a 4a 5c			ld a, (.dmark+1)  
5c3e 32 a1 fd			ld (debug_mark+1),a  
5c41 3a 4b 5c			ld a, (.dmark+2)  
5c44 32 a2 fd			ld (debug_mark+2),a  
5c47 18 03			jr .pastdmark  
5c49 ..			.dmark: db "Vaa"  
5c4c f1			.pastdmark: pop af  
5c4d			endm  
# End of macro DMARK
5c4d						CALLMONITOR 
5c4d cd aa fd			call debug_vector  
5c50				endm  
# End of macro CALLMONITOR
5c50					endif 
5c50 06 41				ld b, 'A' 
5c52 90					sub b			; set offset 
5c53					if DEBUG_FORTH_WORDS 
5c53						DMARK "Vbb" 
5c53 f5				push af  
5c54 3a 68 5c			ld a, (.dmark)  
5c57 32 a0 fd			ld (debug_mark),a  
5c5a 3a 69 5c			ld a, (.dmark+1)  
5c5d 32 a1 fd			ld (debug_mark+1),a  
5c60 3a 6a 5c			ld a, (.dmark+2)  
5c63 32 a2 fd			ld (debug_mark+2),a  
5c66 18 03			jr .pastdmark  
5c68 ..			.dmark: db "Vbb"  
5c6b f1			.pastdmark: pop af  
5c6c			endm  
# End of macro DMARK
5c6c						CALLMONITOR 
5c6c cd aa fd			call debug_vector  
5c6f				endm  
# End of macro CALLMONITOR
5c6f					endif 
5c6f cb 27				sla a  
5c71				 
5c71					 
5c71					if DEBUG_FORTH_WORDS 
5c71						DMARK "VR2" 
5c71 f5				push af  
5c72 3a 86 5c			ld a, (.dmark)  
5c75 32 a0 fd			ld (debug_mark),a  
5c78 3a 87 5c			ld a, (.dmark+1)  
5c7b 32 a1 fd			ld (debug_mark+1),a  
5c7e 3a 88 5c			ld a, (.dmark+2)  
5c81 32 a2 fd			ld (debug_mark+2),a  
5c84 18 03			jr .pastdmark  
5c86 ..			.dmark: db "VR2"  
5c89 f1			.pastdmark: pop af  
5c8a			endm  
# End of macro DMARK
5c8a						CALLMONITOR 
5c8a cd aa fd			call debug_vector  
5c8d				endm  
# End of macro CALLMONITOR
5c8d					endif 
5c8d			 
5c8d 21 29 f9				ld hl, cli_var_array2 
5c90 cd de 0f				call addatohl 
5c93 cd 46 20				call forth_push_numhl 
5c96			 
5c96			 
5c96				       NEXTW 
5c96 c3 37 24			jp macro_next 
5c99				endm 
# End of macro NEXTW
5c99			.V0: 
5c99				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c99 78				db WORD_SYS_CORE+100             
5c9a b1 5c			dw .V0Q            
5c9c 04				db 3 + 1 
5c9d .. 00			db "V0!",0              
5ca1				endm 
# End of macro CWHEAD
5ca1			;| V0! ( u1 -- )  Store value to v0  | DONE 
5ca1			 
5ca1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ca1 cd 4b 22			call macro_dsp_valuehl 
5ca4				endm 
# End of macro FORTH_DSP_VALUEHL
5ca4			 
5ca4 11 5d f9				ld de, cli_var_array 
5ca7			 
5ca7 eb					ex de, hl 
5ca8 73					ld (hl), e 
5ca9 23					inc hl 
5caa 72					ld (hl), d 
5cab			 
5cab					; destroy value TOS 
5cab			 
5cab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cab cd 03 23			call macro_forth_dsp_pop 
5cae				endm 
# End of macro FORTH_DSP_POP
5cae			 
5cae				       NEXTW 
5cae c3 37 24			jp macro_next 
5cb1				endm 
# End of macro NEXTW
5cb1			.V0Q: 
5cb1				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5cb1 79				db WORD_SYS_CORE+101             
5cb2 c2 5c			dw .V1S            
5cb4 04				db 3 + 1 
5cb5 .. 00			db "V0@",0              
5cb9				endm 
# End of macro CWHEAD
5cb9			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5cb9 2a 5d f9				ld hl, (cli_var_array) 
5cbc cd 46 20				call forth_push_numhl 
5cbf			 
5cbf				       NEXTW 
5cbf c3 37 24			jp macro_next 
5cc2				endm 
# End of macro NEXTW
5cc2			.V1S: 
5cc2				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5cc2 7a				db WORD_SYS_CORE+102             
5cc3 da 5c			dw .V1Q            
5cc5 04				db 3 + 1 
5cc6 .. 00			db "V1!",0              
5cca				endm 
# End of macro CWHEAD
5cca			;| V1! ( u1 -- )  Store value to v1 | DONE 
5cca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cca cd 4b 22			call macro_dsp_valuehl 
5ccd				endm 
# End of macro FORTH_DSP_VALUEHL
5ccd			 
5ccd 11 5f f9				ld de, cli_var_array+2 
5cd0				 
5cd0 eb					ex de, hl 
5cd1 73					ld (hl), e 
5cd2 23					inc hl 
5cd3 72					ld (hl), d 
5cd4			 
5cd4					; destroy value TOS 
5cd4			 
5cd4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cd4 cd 03 23			call macro_forth_dsp_pop 
5cd7				endm 
# End of macro FORTH_DSP_POP
5cd7				       NEXTW 
5cd7 c3 37 24			jp macro_next 
5cda				endm 
# End of macro NEXTW
5cda			.V1Q: 
5cda				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5cda 7b				db WORD_SYS_CORE+103             
5cdb eb 5c			dw .V2S            
5cdd 04				db 3 + 1 
5cde .. 00			db "V1@",0              
5ce2				endm 
# End of macro CWHEAD
5ce2			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5ce2 2a 5f f9				ld hl, (cli_var_array+2) 
5ce5 cd 46 20				call forth_push_numhl 
5ce8				       NEXTW 
5ce8 c3 37 24			jp macro_next 
5ceb				endm 
# End of macro NEXTW
5ceb			.V2S: 
5ceb				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5ceb 7c				db WORD_SYS_CORE+104             
5cec 03 5d			dw .V2Q            
5cee 04				db 3 + 1 
5cef .. 00			db "V2!",0              
5cf3				endm 
# End of macro CWHEAD
5cf3			;| V2! ( u1 -- )  Store value to v2 | DONE 
5cf3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cf3 cd 4b 22			call macro_dsp_valuehl 
5cf6				endm 
# End of macro FORTH_DSP_VALUEHL
5cf6			 
5cf6 11 61 f9				ld de, cli_var_array+4 
5cf9				 
5cf9 eb					ex de, hl 
5cfa 73					ld (hl), e 
5cfb 23					inc hl 
5cfc 72					ld (hl), d 
5cfd			 
5cfd					; destroy value TOS 
5cfd			 
5cfd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cfd cd 03 23			call macro_forth_dsp_pop 
5d00				endm 
# End of macro FORTH_DSP_POP
5d00				       NEXTW 
5d00 c3 37 24			jp macro_next 
5d03				endm 
# End of macro NEXTW
5d03			.V2Q: 
5d03				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5d03 7d				db WORD_SYS_CORE+105             
5d04 14 5d			dw .V3S            
5d06 04				db 3 + 1 
5d07 .. 00			db "V2@",0              
5d0b				endm 
# End of macro CWHEAD
5d0b			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5d0b 2a 61 f9				ld hl, (cli_var_array+4) 
5d0e cd 46 20				call forth_push_numhl 
5d11				       NEXTW 
5d11 c3 37 24			jp macro_next 
5d14				endm 
# End of macro NEXTW
5d14			.V3S: 
5d14				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5d14 7c				db WORD_SYS_CORE+104             
5d15 2c 5d			dw .V3Q            
5d17 04				db 3 + 1 
5d18 .. 00			db "V3!",0              
5d1c				endm 
# End of macro CWHEAD
5d1c			;| V3! ( u1 -- )  Store value to v3 | DONE 
5d1c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d1c cd 4b 22			call macro_dsp_valuehl 
5d1f				endm 
# End of macro FORTH_DSP_VALUEHL
5d1f			 
5d1f 11 63 f9				ld de, cli_var_array+6 
5d22				 
5d22 eb					ex de, hl 
5d23 73					ld (hl), e 
5d24 23					inc hl 
5d25 72					ld (hl), d 
5d26			 
5d26					; destroy value TOS 
5d26			 
5d26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d26 cd 03 23			call macro_forth_dsp_pop 
5d29				endm 
# End of macro FORTH_DSP_POP
5d29				       NEXTW 
5d29 c3 37 24			jp macro_next 
5d2c				endm 
# End of macro NEXTW
5d2c			.V3Q: 
5d2c				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5d2c 7d				db WORD_SYS_CORE+105             
5d2d 3d 5d			dw .END            
5d2f 04				db 3 + 1 
5d30 .. 00			db "V3@",0              
5d34				endm 
# End of macro CWHEAD
5d34			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5d34 2a 63 f9				ld hl, (cli_var_array+6) 
5d37 cd 46 20				call forth_push_numhl 
5d3a				       NEXTW 
5d3a c3 37 24			jp macro_next 
5d3d				endm 
# End of macro NEXTW
5d3d			 
5d3d			 
5d3d			 
5d3d			 
5d3d			 
5d3d			; end of dict marker 
5d3d			 
5d3d 00			.END:    db WORD_SYS_END 
5d3e 00 00			dw 0 
5d40 00				db 0 
5d41			 
5d41			; use to jp here for user dict words to save on macro expansion  
5d41			 
5d41			user_dict_next: 
5d41				NEXTW 
5d41 c3 37 24			jp macro_next 
5d44				endm 
# End of macro NEXTW
5d44			 
5d44			 
5d44			user_exec: 
5d44				;    ld hl, <word code> 
5d44				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5d44				;    call forthexec 
5d44				;    jp user_dict_next   (NEXT) 
5d44			        ;    <word code bytes> 
5d44 eb				ex de, hl 
5d45 2a f7 f3			ld hl,(os_tok_ptr) 
5d48				 
5d48				FORTH_RSP_NEXT 
5d48 cd ed 1f			call macro_forth_rsp_next 
5d4b				endm 
# End of macro FORTH_RSP_NEXT
5d4b			 
5d4b			if DEBUG_FORTH_UWORD 
5d4b						DMARK "UEX" 
5d4b f5				push af  
5d4c 3a 60 5d			ld a, (.dmark)  
5d4f 32 a0 fd			ld (debug_mark),a  
5d52 3a 61 5d			ld a, (.dmark+1)  
5d55 32 a1 fd			ld (debug_mark+1),a  
5d58 3a 62 5d			ld a, (.dmark+2)  
5d5b 32 a2 fd			ld (debug_mark+2),a  
5d5e 18 03			jr .pastdmark  
5d60 ..			.dmark: db "UEX"  
5d63 f1			.pastdmark: pop af  
5d64			endm  
# End of macro DMARK
5d64				CALLMONITOR 
5d64 cd aa fd			call debug_vector  
5d67				endm  
# End of macro CALLMONITOR
5d67			endif 
5d67			 
5d67			 
5d67			 
5d67 eb				ex de, hl 
5d68 22 f7 f3			ld (os_tok_ptr), hl 
5d6b				 
5d6b				; Don't use next - Skips the first word in uword. 
5d6b			 
5d6b c3 c8 24			jp exec1 
5d6e			;	NEXT 
5d6e			 
5d6e			 
5d6e			; eof 
# End of file forth_wordsv4.asm
5d6e			endif 
5d6e			;;;;;;;;;;;;;; Debug code 
5d6e			 
5d6e			 
5d6e			;if DEBUG_FORTH_PARSE 
5d6e .. 00		.nowordfound: db "No match",0 
5d77 .. 00		.compword:	db "Comparing word ",0 
5d87 .. 00		.nextwordat:	db "Next word at",0 
5d94 .. 00		.charmatch:	db "Char match",0 
5d9f			;endif 
5d9f			if DEBUG_FORTH_JP 
5d9f			.foundword:	db "Word match. Exec..",0 
5d9f			endif 
5d9f			;if DEBUG_FORTH_PUSH 
5d9f .. 00		.enddict:	db "Dict end. Push.",0 
5daf .. 00		.push_str:	db "Pushing string",0 
5dbe .. 00		.push_num:	db "Pushing number",0 
5dcd .. 00		.data_sp:	db "SP:",0 
5dd1 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5de3 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5df5 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5e07			;endif 
5e07			;if DEBUG_FORTH_MALLOC 
5e07 .. 00		.push_malloc:	db "Malloc address",0 
5e16			;endif 
5e16			 
5e16			 
5e16			 
5e16			; display malloc address and current data stack pointer  
5e16			 
5e16			malloc_error: 
5e16 d5				push de 
5e17 f5				push af 
5e18 e5				push hl 
5e19 cd aa 0d			call clear_display 
5e1c 11 3c 5e			ld de, .mallocerr 
5e1f 3e 00			ld a,0 
5e21			;	ld de,os_word_scratch 
5e21 cd bd 0d			call str_at_display 
5e24 3e 11			ld a, display_row_1+17 
5e26 11 a0 fd			ld de, debug_mark 
5e29 cd bd 0d			call str_at_display 
5e2c cd cd 0d			call update_display 
5e2f				;call break_point_state 
5e2f cd 0c 73			call cin_wait 
5e32			 
5e32			;	ld a, ' ' 
5e32			;	ld (os_view_disable), a 
5e32 cd 47 19			call bp_on 
5e35 e1				pop hl 
5e36 f1				pop af 
5e37 d1				pop de	 
5e38				CALLMONITOR 
5e38 cd aa fd			call debug_vector  
5e3b				endm  
# End of macro CALLMONITOR
5e3b c9				ret 
5e3c			 
5e3c .. 00		.mallocerr: 	db "Malloc Error",0 
5e49			;if DEBUG_FORTH_PUSH 
5e49			display_data_sp: 
5e49 f5				push af 
5e4a			 
5e4a				; see if disabled 
5e4a			 
5e4a			 
5e4a 3a aa fd			ld a, (debug_vector) 
5e4d fe c9			cp $C9  ; RET 
5e4f				;ld a, (os_view_disable) 
5e4f				;cp '*' 
5e4f 28 67			jr z, .skipdsp 
5e51			 
5e51 e5				push hl 
5e52 e5				push hl 
5e53 e5			push hl 
5e54 cd aa 0d			call clear_display 
5e57 e1			pop hl 
5e58 7c				ld a,h 
5e59 21 fb f3			ld hl, os_word_scratch 
5e5c cd e7 11			call hexout 
5e5f e1				pop hl 
5e60 7d				ld a,l 
5e61 21 fd f3			ld hl, os_word_scratch+2 
5e64 cd e7 11			call hexout 
5e67 21 ff f3			ld hl, os_word_scratch+4 
5e6a 3e 00			ld a,0 
5e6c 77				ld (hl),a 
5e6d 11 fb f3			ld de,os_word_scratch 
5e70 3e 28				ld a, display_row_2 
5e72 cd bd 0d				call str_at_display 
5e75 11 d1 5d			ld de, .wordinhl 
5e78 3e 00			ld a, display_row_1 
5e7a			 
5e7a cd bd 0d				call str_at_display 
5e7d 11 a0 fd			ld de, debug_mark 
5e80 3e 11			ld a, display_row_1+17 
5e82			 
5e82 cd bd 0d				call str_at_display 
5e85			 
5e85				; display current data stack pointer 
5e85 11 cd 5d			ld de,.data_sp 
5e88 3e 30				ld a, display_row_2 + 8 
5e8a cd bd 0d				call str_at_display 
5e8d			 
5e8d 2a 23 f9			ld hl,(cli_data_sp) 
5e90 e5				push hl 
5e91 7c				ld a,h 
5e92 21 fb f3			ld hl, os_word_scratch 
5e95 cd e7 11			call hexout 
5e98 e1				pop hl 
5e99 7d				ld a,l 
5e9a 21 fd f3			ld hl, os_word_scratch+2 
5e9d cd e7 11			call hexout 
5ea0 21 ff f3			ld hl, os_word_scratch+4 
5ea3 3e 00			ld a,0 
5ea5 77				ld (hl),a 
5ea6 11 fb f3			ld de,os_word_scratch 
5ea9 3e 33				ld a, display_row_2 + 11 
5eab cd bd 0d				call str_at_display 
5eae			 
5eae			 
5eae cd cd 0d			call update_display 
5eb1 cd ed 0c			call delay1s 
5eb4 cd ed 0c			call delay1s 
5eb7 e1				pop hl 
5eb8			.skipdsp: 
5eb8 f1				pop af 
5eb9 c9				ret 
5eba			 
5eba			display_data_malloc: 
5eba			 
5eba f5				push af 
5ebb e5				push hl 
5ebc e5				push hl 
5ebd e5			push hl 
5ebe cd aa 0d			call clear_display 
5ec1 e1			pop hl 
5ec2 7c				ld a,h 
5ec3 21 fb f3			ld hl, os_word_scratch 
5ec6 cd e7 11			call hexout 
5ec9 e1				pop hl 
5eca 7d				ld a,l 
5ecb 21 fd f3			ld hl, os_word_scratch+2 
5ece cd e7 11			call hexout 
5ed1 21 ff f3			ld hl, os_word_scratch+4 
5ed4 3e 00			ld a,0 
5ed6 77				ld (hl),a 
5ed7 11 fb f3			ld de,os_word_scratch 
5eda 3e 28				ld a, display_row_2 
5edc cd bd 0d				call str_at_display 
5edf 11 07 5e			ld de, .push_malloc 
5ee2 3e 00			ld a, display_row_1 
5ee4			 
5ee4 cd bd 0d				call str_at_display 
5ee7			 
5ee7				; display current data stack pointer 
5ee7 11 cd 5d			ld de,.data_sp 
5eea 3e 30				ld a, display_row_2 + 8 
5eec cd bd 0d				call str_at_display 
5eef			 
5eef 2a 23 f9			ld hl,(cli_data_sp) 
5ef2 e5				push hl 
5ef3 7c				ld a,h 
5ef4 21 fb f3			ld hl, os_word_scratch 
5ef7 cd e7 11			call hexout 
5efa e1				pop hl 
5efb 7d				ld a,l 
5efc 21 fd f3			ld hl, os_word_scratch+2 
5eff cd e7 11			call hexout 
5f02 21 ff f3			ld hl, os_word_scratch+4 
5f05 3e 00			ld a,0 
5f07 77				ld (hl),a 
5f08 11 fb f3			ld de,os_word_scratch 
5f0b 3e 33				ld a, display_row_2 + 11 
5f0d cd bd 0d				call str_at_display 
5f10			 
5f10 cd cd 0d			call update_display 
5f13 cd ed 0c			call delay1s 
5f16 cd ed 0c			call delay1s 
5f19 e1				pop hl 
5f1a f1				pop af 
5f1b c9				ret 
5f1c			;endif 
5f1c			 
5f1c			include "forth_autostart.asm" 
5f1c			; list of commands to perform at system start up 
5f1c			 
5f1c			startcmds: 
5f1c			;	dw test11 
5f1c			;	dw test12 
5f1c			;	dw test13 
5f1c			;	dw test14 
5f1c			;	dw test15 
5f1c			;	dw test16 
5f1c			;	dw test17 
5f1c			;	dw ifthtest1 
5f1c			;	dw ifthtest2 
5f1c			;	dw ifthtest3 
5f1c			;	dw mmtest1 
5f1c			;	dw mmtest2 
5f1c			;	dw mmtest3 
5f1c			;	dw mmtest4 
5f1c			;	dw mmtest5 
5f1c			;	dw mmtest6 
5f1c			;	dw iftest1 
5f1c			;	dw iftest2 
5f1c			;	dw iftest3 
5f1c			;	dw looptest1 
5f1c			;	dw looptest2 
5f1c			;	dw test1 
5f1c			;	dw test2 
5f1c			;	dw test3 
5f1c			;	dw test4 
5f1c			;	dw game2r 
5f1c			;	dw game2b1 
5f1c			;	dw game2b2 
5f1c			 
5f1c				; start up words that are actually useful 
5f1c			 
5f1c			;    dw spi1 
5f1c			;    dw spi2 
5f1c			;    dw spi3 
5f1c			;    dw spi4 
5f1c			;    dw spi5 
5f1c			;    dw spi6 
5f1c			;    dw spi7 
5f1c			; 
5f1c			;    dw spi8 
5f1c			;    dw spi9 
5f1c			;    dw spi10 
5f1c			 
5f1c			; file editor 
5f1c			;	dw edit1 
5f1c			;	dw edit2 
5f1c			;	dw edit3 
5f1c			 
5f1c			;	dw longread 
5f1c 3c 63			dw clrstack 
5f1e 70 63			dw type 
5f20			;	dw stest 
5f20 95 63			dw strncpy 
5f22			;	dw list 
5f22 f6 63			dw start1 
5f24 06 64			dw start2 
5f26			;	dw start3 
5f26			;	dw start3b 
5f26			;	dw start3c 
5f26			 
5f26				; (unit) testing words 
5f26			 
5f26			;	dw mtesta 
5f26			;	dw mtestb 
5f26			;	dw mtestc 
5f26			;	dw mtestd 
5f26			;	dw mteste 
5f26			 
5f26				; demo/game words 
5f26			 
5f26			;        dw game3w 
5f26			;        dw game3p 
5f26			;        dw game3sc 
5f26			;        dw game3vsi 
5f26			;        dw game3vs 
5f26				 
5f26			;	dw game2b 
5f26			;	dw game2bf 
5f26			;	dw game2mba 
5f26			;	dw game2mbas 
5f26			;	dw game2mb 
5f26			 
5f26 23 67			dw game1 
5f28 34 67			dw game1a 
5f2a 96 67			dw game1b 
5f2c cb 67			dw game1c 
5f2e 01 68			dw game1d 
5f30 32 68			dw game1s 
5f32 46 68			dw game1t 
5f34 5b 68			dw game1f 
5f36 8f 68			dw game1z 
5f38 d3 68			dw game1zz 
5f3a			 
5f3a 5c 65			dw test5 
5f3c 94 65			dw test6 
5f3e cc 65			dw test7 
5f40 e0 65			dw test8 
5f42 0c 66			dw test9 
5f44 22 66			dw test10 
5f46				 
5f46 aa 69		        dw ssv5 
5f48 8e 69		        dw ssv4 
5f4a 72 69		        dw ssv3 
5f4c 3c 69		        dw ssv2 
5f4e c3 69		        dw ssv1 
5f50 0b 6a		        dw ssv1cpm 
5f52			;	dw keyup 
5f52			;	dw keydown 
5f52			;	dw keyleft 
5f52			;	dw keyright 
5f52			;	dw 	keyf1 
5f52			;	dw keyf2 
5f52			;	dw keyf3 
5f52			;	dw keyf4 
5f52			;	dw keyf5 
5f52			;	dw keyf6 
5f52			;	dw keyf7 
5f52			;	dw keyf8 
5f52			;	dw keyf9 
5f52			;	dw keyf10 
5f52			;	dw keyf11 
5f52			;	dw keyf12 
5f52			;	dw keytab 
5f52			;	dw keycr 
5f52			;	dw keyhome 
5f52			;	dw keyend 
5f52			;	dw keybs 
5f52 00 00			db 0, 0	 
5f54			 
5f54			 
5f54			; File Editor 
5f54			 
5f54			; ( id - ) use 'e' to edit the displayed line 
5f54 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f75 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5faa			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5faa .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5fe2			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5fe2			 
5fe2			; SPI Net support words 
5fe2			 
5fe2			; v0! = node to send to 
5fe2			; ( str count - ) 
5fe2 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
603b			 
603b			; spiputc ( char node - ) 
603b .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
606f			; spiputc ( u node - ) 
606f .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
609d			 
609d			; spigetc ( - n ) 
609d .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
60c6			 
60c6			; getnode ( - n ) 
60c6 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
60f3			 
60f3			; ( str node - )  
60f3 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6159			; store string ( str i - ) 
6159			 
6159			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6159 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
61ae			 
61ae			; get string ( addr i -  )    TO FIX 
61ae			 
61ae .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6206			 
6206			 
6206			; NETCHAT (TODO) 
6206			; Program to allow two nodes to chat with eachother 
6206			; 
6206			; v0 - target node 
6206			;  
6206			; accept input at 0,0 
6206			; if input is string send spitype to target node 
6206			; starting at row 2,0 , while spigetchr is not zero ->  
6206			; 
6206			; 
6206			; TODO add paging of get request 
6206			 
6206			; ( node - ) 
6206 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
6225 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
627d .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
62f5			 
62f5			 
62f5			; Long read of currently open file 
62f5 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
633c			 
633c			; clear stack  
633c			 
633c .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
6370			 
6370			; type ( addr count - ) 
6370 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6395			 
6395			; some direct memory words 
6395			; strncpy ( len t f -- t ) 
6395			 
6395 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
63f6			 
63f6 .. 00		start1:     	db ": bpon $00 bp ;",0 
6406 .. 00		start2:     	db ": bpoff $01 bp ;",0 
6417 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6492 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
64f2			 
64f2			 
64f2			; a handy word to list items on the stack 
64f2			 
64f2 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
655c			 
655c			 
655c			; test stack  
655c			; rnd8 stest 
655c			 
655c			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
655c			 
655c			; random malloc and free cycles 
655c			 
655c			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
655c			 
655c			; fixed malloc and free cycles 
655c			 
655c			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
655c			 
655c			; fixed double string push and drop cycle  
655c			 
655c			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
655c			 
655c			; consistent fixed string push and drop cycle  
655c			 
655c			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
655c			 
655c			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
655c			 
655c			;test1:		db ": aa 1 2 3 ;", 0 
655c			;test2:     	db "111 aa 888 999",0 
655c			;test3:     	db ": bb 77 ;",0 
655c			;test4:     	db "$02 $01 do i . loop bb",0 
655c			 
655c .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6594 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
65cc .. 00		test7:     	db ": box hline vline ;",0 
65e0 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
660c .. 00		test9:     	db ": sw $01 adsp world ;",0 
6622 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6647			;test11:     	db "hello create .",0 
6647			;test12:     	db "hello2 create .",0 
6647			 
6647			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6647			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6647			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6647			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6647			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6647			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6647			 
6647			;iftest1:     	db "$0001 IF cls .",0 
6647			;iftest2:     	db "$0000 IF cls .",0 
6647			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6647			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6647			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6647			 
6647			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6647			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6647			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6647			 
6647			 
6647 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
666b .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
669b .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
66c0 .. 00		sound4: db ": cha $00 ; ",0 
66cd .. 00		sound5: db ": chb $20 ; ",0 
66da .. 00		sound6: db ": chc $40 ; ",0 
66e7 .. 00		sound7: db ": chd $60 ; ",0 
66f4 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
670c .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6723			 
6723			 
6723			 
6723			 
6723			; a small guess the number game 
6723			 
6723 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6734 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6796			 
6796 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
67cb .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6801 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6832 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6846 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
685b .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
688f .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
68d3			 
68d3			; Using 'ga' save a high score across multiple runs using external storage 
68d3			 
68d3 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
693c			 
693c			 
693c			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
693c			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
693c			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
693c			 
693c			; simple screen saver to test code memory reuse to destruction 
693c			 
693c .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6972 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
698e .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
69aa .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
69c3 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6a0b .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6a62			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6a62			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6a62			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6a62			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6a62			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6a62			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6a62			 
6a62			 
6a62			 
6a62			; minesweeper/battleship finding game 
6a62			; draws a game board of random ship/mine positions 
6a62			; user enters coords to see if it hits on 
6a62			; game ends when all are hit 
6a62			; when hit or miss says how many may be in the area 
6a62			 
6a62			; setup the game board and then hide it 
6a62			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6a62			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6a62			;; prompt for where to target 
6a62			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6a62			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6a62			;; TODO see if the entered coords hits or misses pushes char hit of miss 
6a62			;game2mbht:      db ": mbckht nop ;",0 
6a62			;game2mbms:      db ": mbcms nop ;",0 
6a62			; TODO how many might be near by 
6a62			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6a62			 
6a62			; Game 3 
6a62			 
6a62			; Vert scroller ski game - avoid the trees! 
6a62			 
6a62			; v0 score (ie turns) 
6a62			; v1 player pos 
6a62			; v2 left wall 
6a62			; v3 right wall 
6a62			 
6a62			; Draw side walls randomly 
6a62			 
6a62			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6a62			 
6a62			; Draw player 
6a62			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6a62			 
6a62			; TODO Get Key 
6a62			 
6a62			; TODO Move left right 
6a62			 
6a62			; scroll and move walls a bit 
6a62			 
6a62			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6a62			 
6a62			; main game loop 
6a62			 
6a62			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6a62			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6a62			 
6a62			; key board defs 
6a62			 
6a62 .. 00		keyup:       db ": keyup $05 ;",0 
6a70 .. 00		keydown:       db ": keydown $0a ;",0 
6a80 .. 00		keyleft:       db ": keyleft $0b ;",0 
6a90 .. 00		keyright:       db ": keyright $0c ;",0 
6aa1 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6aaf .. 00		keyf2:       db ": keyf2 $11 ;",0 
6abd .. 00		keyf3:       db ": keyf3 $12 ;",0 
6acb .. 00		keyf4:       db ": keyf4 $13 ;",0 
6ad9 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6ae7 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6af5 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6b03 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6b11 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6b1f .. 00		keyf10:       db ": keyf10 $19 ;",0 
6b2e .. 00		keyf11:       db ": keyf11 $1a ;",0 
6b3d .. 00		keyf12:       db ": keyf12 $1b ;",0 
6b4c			 
6b4c .. 00		keytab:       db ": keytab $09 ;",0 
6b5b .. 00		keycr:       db ": keycr $0d ;",0 
6b69 .. 00		keyhome:       db ": keyhome $0e ;",0 
6b79 .. 00		keyend:       db ": keyend $0f ;",0 
6b88 .. 00		keybs:       db ": keybs $08 ;",0 
6b96			 
6b96			   
6b96			 
6b96			 
6b96			 
6b96			; eof 
# End of file forth_autostart.asm
6b96			 
6b96			 
6b96			 
6b96			; stack over and underflow checks 
6b96			 
6b96			; init the words to detect the under/overflow 
6b96			 
6b96			chk_stk_init: 
6b96				; a vague random number to check so we dont get any "lucky" hits 
6b96 3e 2d			ld a, 45 
6b98 6f				ld l, a 
6b99 00				nop 
6b9a 3e 17			ld a, 23 
6b9c 67				ld h, a 
6b9d			 
6b9d 22 d2 f0			ld (chk_word), hl     ; the word we need to check against 
6ba0			 
6ba0			;	ld (chk_stund), hl	; stack points.... 
6ba0 22 3b fe			ld (chk_stovr), hl 
6ba3 22 21 f9			ld (chk_ret_und), hl 
6ba6 22 df f8			ld (chk_ret_ovr), hl 
6ba9 22 5d f8			ld (chk_loop_ovr), hl 
6bac 22 5b f6			ld (chk_data_ovr), hl 
6baf c9				ret 
6bb0				 
6bb0			check_stacks: 
6bb0				; check all stack words 
6bb0			 
6bb0 e5				push hl 
6bb1 d5				push de 
6bb2			 
6bb2			;	ld de,(chk_word) 
6bb2			;	ld hl, (chk_stund)	; stack points.... 
6bb2			;	if DEBUG_STK_FAULT 
6bb2			;		DMARK "FAa" 
6bb2			;		CALLMONITOR 
6bb2			;	endif 
6bb2			;	call cmp16 
6bb2			;	jp z, .chk_faulta 
6bb2			; 
6bb2			;	ld de, sfaultsu 
6bb2			;	jp .chk_fault 
6bb2			 
6bb2 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
6bb5 ed 5b d2 f0		ld de,(chk_word) 
6bb9				if DEBUG_STK_FAULT 
6bb9					DMARK "FAb" 
6bb9					CALLMONITOR 
6bb9				endif 
6bb9 cd fc 0f			call cmp16 
6bbc 28 06			jr z, .chk_fault1 
6bbe 11 62 6c			ld de, sfaultso 
6bc1 c3 13 6c			jp .chk_fault 
6bc4			.chk_fault1:  
6bc4 2a 21 f9			ld hl, (chk_ret_und) 
6bc7 ed 5b d2 f0		ld de,(chk_word) 
6bcb				if DEBUG_STK_FAULT 
6bcb					DMARK "FAU" 
6bcb					CALLMONITOR 
6bcb				endif 
6bcb cd fc 0f			call cmp16 
6bce ca d7 6b			jp z, .chk_fault2 
6bd1 11 72 6c			ld de, sfaultru 
6bd4 c3 13 6c			jp .chk_fault 
6bd7			.chk_fault2:  
6bd7 2a df f8			ld hl, (chk_ret_ovr) 
6bda ed 5b d2 f0		ld de,(chk_word) 
6bde				if DEBUG_STK_FAULT 
6bde					DMARK "FA1" 
6bde					CALLMONITOR 
6bde				endif 
6bde cd fc 0f			call cmp16 
6be1 ca ea 6b			jp z, .chk_fault3 
6be4 11 80 6c			ld de, sfaultro 
6be7 c3 13 6c			jp .chk_fault 
6bea			.chk_fault3:  
6bea 2a 5d f8			ld hl, (chk_loop_ovr) 
6bed ed 5b d2 f0		ld de,(chk_word) 
6bf1				if DEBUG_STK_FAULT 
6bf1					DMARK "FA2" 
6bf1					CALLMONITOR 
6bf1				endif 
6bf1 cd fc 0f			call cmp16 
6bf4 ca fd 6b			jp z, .chk_fault4 
6bf7 11 9a 6c			ld de, sfaultlo 
6bfa c3 13 6c			jp .chk_fault 
6bfd			.chk_fault4:  
6bfd 2a 5b f6			ld hl, (chk_data_ovr) 
6c00 ed 5b d2 f0		ld de,(chk_word) 
6c04				if DEBUG_STK_FAULT 
6c04					DMARK "FA3" 
6c04					CALLMONITOR 
6c04				endif 
6c04 cd fc 0f			call cmp16 
6c07 ca 10 6c			jp z, .chk_fault5 
6c0a 11 b4 6c			ld de, sfaultdo 
6c0d c3 13 6c			jp .chk_fault 
6c10			 
6c10			 
6c10			.chk_fault5:  
6c10 d1				pop de 
6c11 e1				pop hl 
6c12			 
6c12 c9				ret 
6c13			 
6c13 cd aa 0d		.chk_fault: 	call clear_display 
6c16 3e 28				ld a, display_row_2 
6c18 cd bd 0d				call str_at_display 
6c1b 11 44 6c				   ld de, .stackfault 
6c1e 3e 00				ld a, display_row_1 
6c20 cd bd 0d				call str_at_display 
6c23 11 a0 fd				    ld de, debug_mark 
6c26 3e 11				ld a, display_row_1+17 
6c28 cd bd 0d				call str_at_display 
6c2b cd cd 0d				call update_display 
6c2e			 
6c2e				; prompt before entering montior for investigating issue 
6c2e			 
6c2e 3e 78			ld a, display_row_4 
6c30 11 24 1d			ld de, endprog 
6c33			 
6c33 cd cd 0d			call update_display		 
6c36			 
6c36 cd be 1f			call next_page_prompt 
6c39			 
6c39 d1				pop de 
6c3a e1				pop hl 
6c3b cd 78 1d				call monitor 
6c3e cd dd 23				call forth_warmstart 
6c41 c3 74 1c				jp warmstart_afterauto 
6c44					;jp 0 
6c44					;halt 
6c44			 
6c44			 
6c44			 
6c44 .. 00		.stackfault: 	db "Stack fault:",0 
6c51			 
6c51 .. 00		sfaultsu: 	db	"Stack under flow",0 
6c62 .. 00		sfaultso: 	db	"Stack over flow",0 
6c72 .. 00		sfaultru:	db "RTS underflow",0 
6c80 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6c9a .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6cb4 .. 00		sfaultdo:	db "DTS overflow", 0 
6cc1			 
6cc1			 
6cc1			fault_dsp_under: 
6cc1 11 d3 6c			ld de, .dsp_under 
6cc4 c3 89 6d			jp .show_fault 
6cc7			 
6cc7			fault_rsp_under: 
6cc7 11 e1 6c			ld de, .rsp_under 
6cca c3 89 6d			jp .show_fault 
6ccd			fault_loop_under: 
6ccd 11 ef 6c			ld de, .loop_under 
6cd0 c3 89 6d			jp .show_fault 
6cd3			 
6cd3 .. 00		.dsp_under: db "DSP Underflow",0 
6ce1 .. 00		.rsp_under: db "RSP Underflow",0 
6cef .. 00		.loop_under: db "LOOP Underflow",0 
6cfe			 
6cfe			 
6cfe d5			type_faultn: 	push de 
6cff e5					push hl 
6d00 cd aa 0d				call clear_display 
6d03 11 2d 6d				   ld de, .typefaultn 
6d06 3e 00				ld a, display_row_1 
6d08 cd bd 0d				call str_at_display 
6d0b 11 a0 fd				    ld de, debug_mark 
6d0e 3e 11				ld a, display_row_1+17 
6d10 cd bd 0d				call str_at_display 
6d13 cd cd 0d				call update_display 
6d16			 
6d16				; prompt before entering montior for investigating issue 
6d16			 
6d16 3e 78			ld a, display_row_4 
6d18 11 24 1d			ld de, endprog 
6d1b			 
6d1b cd cd 0d			call update_display		 
6d1e			 
6d1e cd be 1f			call next_page_prompt 
6d21			 
6d21 e5					push hl 
6d22 d5					push de 
6d23 cd 78 1d				call monitor 
6d26 cd dd 23				call forth_warmstart 
6d29 c3 74 1c				jp warmstart_afterauto 
6d2c 76					halt 
6d2d			 
6d2d			 
6d2d .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6d44			 
6d44 d5			type_faults: 	push de 
6d45 e5					push hl 
6d46 cd aa 0d				call clear_display 
6d49 11 72 6d				   ld de, .typefaults 
6d4c 3e 00				ld a, display_row_1 
6d4e cd bd 0d				call str_at_display 
6d51 11 a0 fd				    ld de, debug_mark 
6d54 3e 11				ld a, display_row_1+17 
6d56 cd bd 0d				call str_at_display 
6d59 cd cd 0d				call update_display 
6d5c			 
6d5c				; prompt before entering montior for investigating issue 
6d5c			 
6d5c 3e 78			ld a, display_row_4 
6d5e 11 24 1d			ld de, endprog 
6d61			 
6d61 cd cd 0d			call update_display		 
6d64			 
6d64 cd be 1f			call next_page_prompt 
6d67			 
6d67 e1					pop hl 
6d68 d1					pop de 
6d69 cd 78 1d				call monitor 
6d6c cd dd 23				call forth_warmstart 
6d6f c3 74 1c				jp warmstart_afterauto 
6d72			 
6d72			 
6d72 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6d89			 
6d89			.show_fault: 	 
6d89 d5					push de 
6d8a cd aa 0d				call clear_display 
6d8d d1					pop de 
6d8e 3e 00				ld a, display_row_1 
6d90 cd bd 0d				call str_at_display 
6d93 11 a0 fd				    ld de, debug_mark 
6d96 3e 11				ld a, display_row_1+17 
6d98 cd bd 0d				call str_at_display 
6d9b cd cd 0d				call update_display 
6d9e			 
6d9e				; prompt before entering montior for investigating issue 
6d9e			 
6d9e 3e 78			ld a, display_row_4 
6da0 11 24 1d			ld de, endprog 
6da3			 
6da3 cd cd 0d			call update_display		 
6da6			 
6da6 cd be 1f			call next_page_prompt 
6da9			 
6da9 e1					pop hl 
6daa d1					pop de 
6dab cd 78 1d				call monitor 
6dae			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6dae			; TODO Make optional fault restart to cli or warm boot? 
6dae					;jp warmstart 
6dae c3 b8 1c				jp cli 
6db1 76					halt 
6db2			 
6db2			 
6db2			; handle the auto run of code from files in storage 
6db2			 
6db2			 
6db2			include "forth_startup.asm" 
6db2			; Which startup method to use? 
6db2			; 
6db2			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6db2			; followed by loading of a list of scripts in eeprom 
6db2			 
6db2			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6db2			; from eeprom 
6db2			 
6db2			; Select with define in main stubs 
6db2			 
6db2			if STARTUP_V1 
6db2				include "forth_startupv1.asm" 
6db2			endif 
6db2			if STARTUP_V2 
6db2				include "forth_startupv2.asm" 
6db2			; Version 2 of the startup  
6db2			;  
6db2			; Auto load any files in bank 1 that start with a '*' 
6db2			; If no se storage then revert to using eprom 
6db2			 
6db2			 
6db2			if STORAGE_SE = 0 
6db2			 
6db2			sprompt1: db "Startup load...",0 
6db2			sprompt2: db "Run? 1=No *=End #=All",0 
6db2			 
6db2			 
6db2			 
6db2			 
6db2			forth_startup: 
6db2				ld hl, startcmds 
6db2				ld a, 0 
6db2				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6db2			 
6db2			.start1:	push hl 
6db2				call clear_display 
6db2				ld de, sprompt1 
6db2			        ld a, display_row_1 
6db2				call str_at_display 
6db2				ld de, sprompt2 
6db2			        ld a, display_row_2 
6db2				call str_at_display 
6db2				pop hl 
6db2				push hl 
6db2				ld e,(hl) 
6db2				inc hl 
6db2				ld d,(hl) 
6db2			        ld a, display_row_3 
6db2				call str_at_display 
6db2				call update_display 
6db2			 
6db2			 
6db2				ld a, (os_last_cmd) 
6db2				cp 0 
6db2				jr z, .startprompt 
6db2				call delay250ms 
6db2				jr .startdo 
6db2				 
6db2				 
6db2			 
6db2			.startprompt: 
6db2			 
6db2				ld a,display_row_4 + display_cols - 1 
6db2			        ld de, endprg 
6db2				call str_at_display 
6db2				call update_display 
6db2				call delay1s 
6db2				call cin_wait 
6db2						 
6db2				cp '*' 
6db2				jr z, .startupend1 
6db2				cp '#' 
6db2				jr nz, .startno 
6db2				ld a, 1 
6db2				ld (os_last_cmd),a 
6db2				jr .startdo 
6db2			.startno:	cp '1' 
6db2				jr z,.startnxt  
6db2			 
6db2				; exec startup line 
6db2			.startdo:	 
6db2				pop hl 
6db2				push hl 
6db2				 
6db2				ld e,(hl) 
6db2				inc hl 
6db2				ld d,(hl) 
6db2				ex de,hl 
6db2			 
6db2				push hl 
6db2			 
6db2				ld a, 0 
6db2				;ld a, FORTH_END_BUFFER 
6db2				call strlent 
6db2				inc hl   ; include zero term to copy 
6db2				ld b,0 
6db2				ld c,l 
6db2				pop hl 
6db2				ld de, scratch 
6db2				ldir 
6db2			 
6db2			 
6db2				ld hl, scratch 
6db2				call forthparse 
6db2				call forthexec 
6db2				call forthexec_cleanup 
6db2			 
6db2				ld a, display_row_4 
6db2				ld de, endprog 
6db2			 
6db2				call update_display		 
6db2			 
6db2				ld a, (os_last_cmd) 
6db2				cp 0 
6db2				jr nz, .startnxt 
6db2				call next_page_prompt 
6db2			        call clear_display 
6db2				call update_display		 
6db2			 
6db2				; move onto next startup line? 
6db2			.startnxt: 
6db2			 
6db2				call delay250ms 
6db2				pop hl 
6db2			 
6db2				inc hl 
6db2				inc hl 
6db2			 
6db2				push hl 
6db2				ld e, (hl) 
6db2				inc hl 
6db2				ld d, (hl) 
6db2				pop hl 
6db2				; TODO replace 0 test 
6db2			 
6db2				ex de, hl 
6db2				call ishlzero 
6db2			;	ld a,e 
6db2			;	add d 
6db2			;	cp 0    ; any left to do? 
6db2				ex de, hl 
6db2				jp nz, .start1 
6db2				jr .startupend 
6db2			 
6db2			.startupend1: pop hl 
6db2			.startupend: 
6db2			 
6db2				call clear_display 
6db2				call update_display 
6db2				ret 
6db2			endif 
6db2			 
6db2			 
6db2			if STORAGE_SE 
6db2			 
6db2			;sprompt3: db "Loading from start-up file:",0 
6db2 .. 00		sprompt3: db "  Searching...",0 
6dc1			;sprompt4: db "(Any key to stop)",0 
6dc1			 
6dc1			 
6dc1			forth_autoload: 
6dc1			 
6dc1				; load block 0 of store 1 
6dc1				 
6dc1 3e fe			ld a, $fe      ; bit 0 clear 
6dc3 32 95 f9			ld (spi_device), a 
6dc6			 
6dc6 cd 25 05			call storage_get_block_0 
6dc9			 
6dc9 3a d0 f9			ld a, (store_page+STORE_0_AUTOFILE) 
6dcc			 
6dcc fe 00			cp 0 
6dce c8				ret z     ; auto start not enabled 
6dcf			 
6dcf cd aa 0d			call clear_display 
6dd2			 
6dd2				; set bank 
6dd2			 
6dd2 3a d2 f9				ld a, (store_page+STORE_0_BANKRUN) 
6dd5 32 95 f9				ld (spi_device), a 
6dd8			 
6dd8			 
6dd8				; generate a directory of bank 1 and search for flagged files 
6dd8			 
6dd8					if DEBUG_FORTH_WORDS_KEY 
6dd8						DMARK "DIR" 
6dd8 f5				push af  
6dd9 3a ed 6d			ld a, (.dmark)  
6ddc 32 a0 fd			ld (debug_mark),a  
6ddf 3a ee 6d			ld a, (.dmark+1)  
6de2 32 a1 fd			ld (debug_mark+1),a  
6de5 3a ef 6d			ld a, (.dmark+2)  
6de8 32 a2 fd			ld (debug_mark+2),a  
6deb 18 03			jr .pastdmark  
6ded ..			.dmark: db "DIR"  
6df0 f1			.pastdmark: pop af  
6df1			endm  
# End of macro DMARK
6df1						CALLMONITOR 
6df1 cd aa fd			call debug_vector  
6df4				endm  
# End of macro CALLMONITOR
6df4					endif 
6df4			 
6df4 cd 25 05			call storage_get_block_0 
6df7			 
6df7 21 af f9			ld hl, store_page     ; get current id count 
6dfa 46				ld b, (hl) 
6dfb 0e 00			ld c, 0    ; count of files   
6dfd					if DEBUG_FORTH_WORDS 
6dfd						DMARK "DI1" 
6dfd f5				push af  
6dfe 3a 12 6e			ld a, (.dmark)  
6e01 32 a0 fd			ld (debug_mark),a  
6e04 3a 13 6e			ld a, (.dmark+1)  
6e07 32 a1 fd			ld (debug_mark+1),a  
6e0a 3a 14 6e			ld a, (.dmark+2)  
6e0d 32 a2 fd			ld (debug_mark+2),a  
6e10 18 03			jr .pastdmark  
6e12 ..			.dmark: db "DI1"  
6e15 f1			.pastdmark: pop af  
6e16			endm  
# End of macro DMARK
6e16						CALLMONITOR 
6e16 cd aa fd			call debug_vector  
6e19				endm  
# End of macro CALLMONITOR
6e19					endif 
6e19			 
6e19				; check for empty drive 
6e19			 
6e19 3e 00			ld a, 0 
6e1b b8				cp b 
6e1c ca 69 6e			jp z, .dirdone 
6e1f			 
6e1f				; for each of the current ids do a search for them and if found push to stack 
6e1f			 
6e1f c5			.diritem:	push bc 
6e20 21 40 00				ld hl, STORE_BLOCK_PHY 
6e23 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
6e25 58					ld e,b 
6e26			 
6e26 d5					push de 
6e27 e5					push hl 
6e28 cd aa 0d			call clear_display 
6e2b 3e 32			ld a, display_row_2 + 10 
6e2d 11 b2 6d			ld de, sprompt3 
6e30 cd bd 0d			call str_at_display 
6e33 cd 01 0d			call active 
6e36 eb				ex de, hl 
6e37 3e 2f			ld a, display_row_2 + 7 
6e39 cd bd 0d			call str_at_display 
6e3c cd cd 0d			call update_display 
6e3f e1				pop hl 
6e40 d1				pop de 
6e41			 
6e41			;		if DEBUG_FORTH_WORDS 
6e41			;			DMARK "DI2" 
6e41			;			CALLMONITOR 
6e41			;		endif 
6e41			 
6e41 cd a7 07				call storage_findnextid 
6e44			 
6e44			;		if DEBUG_FORTH_WORDS 
6e44			;			DMARK "DI3" 
6e44			;			CALLMONITOR 
6e44			;		endif 
6e44			 
6e44					; if found hl will be non zero 
6e44			 
6e44 cd 07 10				call ishlzero 
6e47			;		ld a, l 
6e47			;		add h 
6e47			; 
6e47			;		cp 0 
6e47 28 1d				jr z, .dirnotfound 
6e49			 
6e49					; increase count 
6e49			 
6e49 c1					pop bc	 
6e4a 0c					inc c 
6e4b c5					push bc 
6e4c					 
6e4c			 
6e4c					; get file header and push the file name 
6e4c			 
6e4c 11 af f9				ld de, store_page 
6e4f cd 74 04				call storage_read_block 
6e52			 
6e52					; push file id to stack 
6e52				 
6e52			 
6e52					; is this a file we want to run? 
6e52			 
6e52 21 b2 f9				ld hl, store_page+3 
6e55 7e					ld a,(hl) 
6e56 fe 2a				cp '*' 
6e58 20 0c				jr nz,  .dirnotfound 
6e5a					 
6e5a			 
6e5a			 
6e5a 3a af f9				ld a, (store_page) 
6e5d d5					push de 
6e5e e5					push hl 
6e5f c5					push bc 
6e60 cd 8c 6e				call .autorunf 
6e63 c1					pop bc 
6e64 e1					pop hl 
6e65 d1					pop de 
6e66			 
6e66			 
6e66			 
6e66				; save this extent 
6e66			 
6e66					; push file name 
6e66			;display file name to run 
6e66			 
6e66			;		ld hl, store_page+3 
6e66			;		if DEBUG_FORTH_WORDS 
6e66			;			DMARK "DI5" 
6e66			;			CALLMONITOR 
6e66			;		endif 
6e66			; 
6e66			;		 
6e66			; 
6e66			;		call forth_push_str 
6e66			;		if DEBUG_FORTH_WORDS 
6e66			;			DMARK "DI6" 
6e66			;			CALLMONITOR 
6e66			;		endif 
6e66			.dirnotfound: 
6e66 c1					pop bc     
6e67 10 b6				djnz .diritem 
6e69				 
6e69			.dirdone:	 
6e69					if DEBUG_FORTH_WORDS 
6e69						DMARK "DI7" 
6e69 f5				push af  
6e6a 3a 7e 6e			ld a, (.dmark)  
6e6d 32 a0 fd			ld (debug_mark),a  
6e70 3a 7f 6e			ld a, (.dmark+1)  
6e73 32 a1 fd			ld (debug_mark+1),a  
6e76 3a 80 6e			ld a, (.dmark+2)  
6e79 32 a2 fd			ld (debug_mark+2),a  
6e7c 18 03			jr .pastdmark  
6e7e ..			.dmark: db "DI7"  
6e81 f1			.pastdmark: pop af  
6e82			endm  
# End of macro DMARK
6e82						CALLMONITOR 
6e82 cd aa fd			call debug_vector  
6e85				endm  
# End of macro CALLMONITOR
6e85					endif 
6e85			 
6e85 cd aa 0d				call clear_display 
6e88 cd cd 0d				call update_display 
6e8b			 
6e8b c9					ret 
6e8c			 
6e8c			 
6e8c			 
6e8c			 
6e8c			 
6e8c			.autorunf: 
6e8c			 
6e8c			 
6e8c				; get file id to load from and get the file name to display 
6e8c			 
6e8c			;		ld a, (store_page+STORE_0_FILERUN) 
6e8c			 
6e8c 2e 00				ld l, 0 
6e8e 67					ld h, a 
6e8f 11 af f9				ld de, store_page 
6e92			 
6e92					if DEBUG_FORTH_WORDS 
6e92						DMARK "ASp" 
6e92 f5				push af  
6e93 3a a7 6e			ld a, (.dmark)  
6e96 32 a0 fd			ld (debug_mark),a  
6e99 3a a8 6e			ld a, (.dmark+1)  
6e9c 32 a1 fd			ld (debug_mark+1),a  
6e9f 3a a9 6e			ld a, (.dmark+2)  
6ea2 32 a2 fd			ld (debug_mark+2),a  
6ea5 18 03			jr .pastdmark  
6ea7 ..			.dmark: db "ASp"  
6eaa f1			.pastdmark: pop af  
6eab			endm  
# End of macro DMARK
6eab						CALLMONITOR 
6eab cd aa fd			call debug_vector  
6eae				endm  
# End of macro CALLMONITOR
6eae					endif 
6eae cd cd 09				call storage_read 
6eb1			 
6eb1					if DEBUG_FORTH_WORDS 
6eb1						DMARK "ASr" 
6eb1 f5				push af  
6eb2 3a c6 6e			ld a, (.dmark)  
6eb5 32 a0 fd			ld (debug_mark),a  
6eb8 3a c7 6e			ld a, (.dmark+1)  
6ebb 32 a1 fd			ld (debug_mark+1),a  
6ebe 3a c8 6e			ld a, (.dmark+2)  
6ec1 32 a2 fd			ld (debug_mark+2),a  
6ec4 18 03			jr .pastdmark  
6ec6 ..			.dmark: db "ASr"  
6ec9 f1			.pastdmark: pop af  
6eca			endm  
# End of macro DMARK
6eca						CALLMONITOR 
6eca cd aa fd			call debug_vector  
6ecd				endm  
# End of macro CALLMONITOR
6ecd					endif 
6ecd			 
6ecd cd 07 10				call ishlzero 
6ed0 c8					ret z             ; file not found 
6ed1			 
6ed1					; display file name we are loading 
6ed1			 
6ed1 cd aa 0d				call clear_display 
6ed4			 
6ed4 3e 32				ld a, display_row_2 + 10 
6ed6 11 b2 f9				ld de, store_page+3 
6ed9 cd bd 0d				call str_at_display 
6edc				 
6edc			; 
6edc			 
6edc			;	ld a, display_row_1+5 
6edc			;	ld de, sprompt3 
6edc			;	call str_at_display 
6edc			;	ld a, display_row_2+7 
6edc			;	call active 
6edc			;	ex de, hl 
6edc			;;	ld de, sprompt4 
6edc			;	call str_at_display 
6edc			; 
6edc cd cd 0d			call update_display 
6edf			 
6edf			;	call cin_wait 
6edf			;	cp 'n' 
6edf			;	ret z 
6edf			;	cp 'N' 
6edf			;	ret z 
6edf			 
6edf			;	call delay1s 
6edf			 
6edf 3a b1 f9			ld a, (store_page+2) 
6ee2 32 9e f9			ld (store_openmaxext), a    ; save count of ext 
6ee5 3e 01			ld a, 1  
6ee7 32 9f f9			ld (store_openext), a    ; save count of ext 
6eea			 
6eea			.autof: 
6eea				; begin to read a line from file 
6eea			 
6eea 21 1d f4			ld hl, os_cli_cmd 
6eed 22 1b f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
6ef0			  
6ef0			.readext: 
6ef0 3a 9f f9			ld a, (store_openext) 
6ef3 6f				ld l , a 
6ef4				 
6ef4 3a af f9			ld a, (store_page) 
6ef7 67				ld h, a	 
6ef8 11 af f9			ld de, store_page 
6efb					if DEBUG_FORTH_WORDS 
6efb						DMARK "ASl" 
6efb f5				push af  
6efc 3a 10 6f			ld a, (.dmark)  
6eff 32 a0 fd			ld (debug_mark),a  
6f02 3a 11 6f			ld a, (.dmark+1)  
6f05 32 a1 fd			ld (debug_mark+1),a  
6f08 3a 12 6f			ld a, (.dmark+2)  
6f0b 32 a2 fd			ld (debug_mark+2),a  
6f0e 18 03			jr .pastdmark  
6f10 ..			.dmark: db "ASl"  
6f13 f1			.pastdmark: pop af  
6f14			endm  
# End of macro DMARK
6f14						CALLMONITOR 
6f14 cd aa fd			call debug_vector  
6f17				endm  
# End of macro CALLMONITOR
6f17					endif 
6f17 cd cd 09				call storage_read 
6f1a cd 07 10			call ishlzero 
6f1d c8				ret z 
6f1e			 
6f1e			; TODO copy to exec buffer 
6f1e			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
6f1e			 
6f1e				; copy the record buffer to the cli buffer 
6f1e			 
6f1e ed 5b 1b f6		ld de, (os_var_array) 
6f22 21 b1 f9			ld hl, store_page+2 
6f25			;	ex de, hl 
6f25 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
6f28 ed b0			ldir 
6f2a ed 53 1b f6		ld (os_var_array), de 
6f2e				 
6f2e 3a 9f f9			ld a, (store_openext) 
6f31 3c				inc a 
6f32 32 9f f9			ld (store_openext), a    ; save count of ext 
6f35			 
6f35			 
6f35			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
6f35				 
6f35 3a a2 f9			ld a, (store_readcont) 
6f38 fe 00			cp 0 
6f3a 20 b4			jr nz, .readext 
6f3c			 
6f3c			;	jr z, .autoend 
6f3c			 
6f3c					if DEBUG_FORTH_WORDS 
6f3c						DMARK "ASc" 
6f3c f5				push af  
6f3d 3a 51 6f			ld a, (.dmark)  
6f40 32 a0 fd			ld (debug_mark),a  
6f43 3a 52 6f			ld a, (.dmark+1)  
6f46 32 a1 fd			ld (debug_mark+1),a  
6f49 3a 53 6f			ld a, (.dmark+2)  
6f4c 32 a2 fd			ld (debug_mark+2),a  
6f4f 18 03			jr .pastdmark  
6f51 ..			.dmark: db "ASc"  
6f54 f1			.pastdmark: pop af  
6f55			endm  
# End of macro DMARK
6f55						CALLMONITOR 
6f55 cd aa fd			call debug_vector  
6f58				endm  
# End of macro CALLMONITOR
6f58					endif 
6f58 e5				push hl	 
6f59 d5				push de 
6f5a cd 01 0d			call active 
6f5d eb				ex de, hl 
6f5e 3e 2f			ld a, display_row_2 + 7 
6f60 cd bd 0d			call str_at_display 
6f63			 
6f63 cd cd 0d			call update_display 
6f66 d1				pop de  
6f67 e1				pop hl 
6f68			;	call delay250ms 
6f68			 
6f68			 
6f68			 
6f68			 
6f68			.autoexec: 
6f68			 
6f68			 
6f68 21 1d f4			ld hl, os_cli_cmd 
6f6b					if DEBUG_FORTH_WORDS 
6f6b						DMARK "ASx" 
6f6b f5				push af  
6f6c 3a 80 6f			ld a, (.dmark)  
6f6f 32 a0 fd			ld (debug_mark),a  
6f72 3a 81 6f			ld a, (.dmark+1)  
6f75 32 a1 fd			ld (debug_mark+1),a  
6f78 3a 82 6f			ld a, (.dmark+2)  
6f7b 32 a2 fd			ld (debug_mark+2),a  
6f7e 18 03			jr .pastdmark  
6f80 ..			.dmark: db "ASx"  
6f83 f1			.pastdmark: pop af  
6f84			endm  
# End of macro DMARK
6f84						CALLMONITOR 
6f84 cd aa fd			call debug_vector  
6f87				endm  
# End of macro CALLMONITOR
6f87					endif 
6f87 cd 85 24			call forthparse 
6f8a cd c5 24			call forthexec 
6f8d cd d7 23			call forthexec_cleanup 
6f90			 
6f90			 
6f90			 
6f90 c3 ea 6e			jp .autof 
6f93			;.autofdone: 
6f93			; 
6f93			;		if DEBUG_FORTH_WORDS 
6f93			;			DMARK "ASx" 
6f93			;			CALLMONITOR 
6f93			;		endif 
6f93			;;	call clear_display 
6f93			;	ret 
6f93			 
6f93			 
6f93			 
6f93			endif 
# End of file forth_startupv2.asm
6f93			endif 
6f93			 
# End of file forth_startup.asm
6f93			 
6f93			; eof 
# End of file forth_kernel.asm
6f93			;include "nascombasic.asm" 
6f93			 
6f93			 
6f93			; find out where the code ends if loaded into RAM (for SC114) 
6f93			;endofcode:  
6f93			;	nop 
6f93			 
6f93			 
6f93			; jump to nmi vector 
6f93			 
6f93			init_nmi: 
6f93 3e c9			ld a, $c9   ; RET 
6f95 32 ad fd			ld (nmi_vector), a 
6f98 c9				ret 
6f99			nmi: 
6f99 e5				push hl 
6f9a d5				push de 
6f9b c5				push bc 
6f9c f5				push af 
6f9d cd ad fd			call nmi_vector 
6fa0 f5				push af 
6fa1 c5				push bc 
6fa2 d5				push de 
6fa3 e5				push hl 
6fa4 ed 4d			reti 
6fa6			 
6fa6			 
6fa6			; eof 
6fa6			 
# End of file main.asm
6fa6			include "firmware_lcd_4x40.asm" 
6fa6			; **********************************************************************  
6fa6			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6fa6			; **********************************************************************  
6fa6			;  
6fa6			; **  Written as a Small Computer Monitor App  
6fa6			; **  www.scc.me.uk  
6fa6			;  
6fa6			; History  
6fa6			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6fa6			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6fa6			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6fa6			;  
6fa6			; **********************************************************************  
6fa6			;  
6fa6			; This program is an example of one of the methods of interfacing an   
6fa6			; alphanumeric LCD module.   
6fa6			;  
6fa6			; In this example the display is connected to either a Z80 PIO or a   
6fa6			; simple 8-bit output port.   
6fa6			;  
6fa6			; This interfacing method uses 4-bit data mode and uses time delays  
6fa6			; rather than polling the display's ready status. As a result the   
6fa6			; interface only requires 6 simple output lines:  
6fa6			;   Output bit 0 = not used  
6fa6			;   Output bit 1 = not used  
6fa6			;   Output bit 2 = RS         High = data, Low = instruction  
6fa6			;   Output bit 3 = E          Active high  
6fa6			;   Output bit 4 = DB4  
6fa6			;   Output bit 5 = DB5  
6fa6			;   Output bit 6 = DB6  
6fa6			;   Output bit 7 = DB7  
6fa6			; Display's R/W is connected to 0v so it is always in write mode  
6fa6			;  
6fa6			; This set up should work with any system supporting the RC2014 bus  
6fa6			  
6fa6			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6fa6			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6fa6			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6fa6			;  
6fa6			; **********************************************************************  
6fa6			  
6fa6			; Additonal for 4x40. E1 and E2 instead of just E   
6fa6			; TODO swipe vidout signal on port a to activate E2  
6fa6			  
6fa6			; **********************************************************************  
6fa6			; **  Constants  
6fa6			; **********************************************************************  
6fa6			; LCD constants required by LCD support module  
6fa6			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6fa6			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6fa6			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
6fa6			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
6fa6			; TODO Decide which E is being set  
6fa6			kLCDWidth:  EQU display_cols             ;Width in characters  
6fa6			  
6fa6			; **********************************************************************  
6fa6			; **  Code library usage  
6fa6			; **********************************************************************  
6fa6			  
6fa6			; send character to current cursor position  
6fa6			; wraps and/or scrolls screen automatically  
6fa6			  
6fa6			  
6fa6			  
6fa6			lcd_init:  
6fa6			  
6fa6			; SCMonAPI functions used  
6fa6			  
6fa6			; Alphanumeric LCD functions used  
6fa6			; no need to specify specific functions for this module  
6fa6			  
6fa6 3e cf		            LD   A, 11001111b  
6fa8 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6faa 3e 00		            LD   A, 00000000b  
6fac d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6fae			  
6fae			; Initialise alphanumeric LCD module  
6fae 3e 00				ld a, 0  
6fb0 32 00 fb				ld (display_lcde1e2), a  
6fb3 cd 34 70		            CALL fLCD_Init      ;Initialise LCD module  
6fb6 3e 01				ld a, 1  
6fb8 32 00 fb				ld (display_lcde1e2), a  
6fbb cd 34 70		            CALL fLCD_Init      ;Initialise LCD module  
6fbe			  
6fbe c9				ret  
6fbf			  
6fbf			;  
6fbf			;;  
6fbf			; lcd functions  
6fbf			;  
6fbf			;  
6fbf			  
6fbf			; what is at cursor position   
6fbf			  
6fbf			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6fbf			;		call curptr  
6fbf			;		ret  
6fbf			  
6fbf			  
6fbf			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6fbf			  
6fbf			curptr:  
6fbf c5				push bc  
6fc0 21 e6 fc			ld hl, display_fb0  
6fc3			cpr:	  
6fc3				; loop for cursor whole row  
6fc3 0e 28			ld c, display_cols  
6fc5 23			cpr1:	inc hl  
6fc6 0d				dec c  
6fc7 20 fc			jr nz, cpr1  
6fc9 05				dec b  
6fca 20 f7			jr nz, cpr  
6fcc			  
6fcc				; add col	  
6fcc			  
6fcc 23			cpr2:	inc hl  
6fcd 1d				dec e  
6fce 20 fc			jr nz, cpr2  
6fd0			  
6fd0 c1				pop bc  
6fd1 c9				ret  
6fd2				  
6fd2			  
6fd2			  
6fd2			  
6fd2			  
6fd2			; write the frame buffer given in hl to hardware   
6fd2 22 fe fa		write_display: ld (display_write_tmp), hl 	   
6fd5 3e 00			ld a, kLCD_Line1  
6fd7 cd e1 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6fda 06 28			ld b, display_cols  
6fdc ed 5b fe fa		ld de, (display_write_tmp)  
6fe0 cd 2c 70			call write_len_string  
6fe3				  
6fe3				  
6fe3 2a fe fa			ld hl, (display_write_tmp)  
6fe6 11 28 00			ld de, display_cols  
6fe9 19				add hl,de  
6fea 22 fe fa			ld (display_write_tmp),hl  
6fed			  
6fed				  
6fed 3e 28			ld a, kLCD_Line2  
6fef cd e1 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6ff2 06 28			ld b, display_cols  
6ff4 ed 5b fe fa		ld de, (display_write_tmp)  
6ff8 cd 2c 70			call write_len_string  
6ffb				  
6ffb 2a fe fa			ld hl, (display_write_tmp)  
6ffe 11 28 00			ld de, display_cols  
7001 19				add hl,de  
7002 22 fe fa			ld (display_write_tmp),hl  
7005			  
7005				  
7005 3e 50			ld a, kLCD_Line3  
7007 cd e1 70		            CALL fLCD_Pos       ;Position cursor to location in A  
700a 06 28			ld b, display_cols  
700c ed 5b fe fa		ld de, (display_write_tmp)  
7010 cd 2c 70			call write_len_string  
7013				  
7013 2a fe fa			ld hl, (display_write_tmp)  
7016 11 28 00			ld de, display_cols  
7019 19				add hl,de  
701a 22 fe fa			ld (display_write_tmp),hl  
701d			  
701d				  
701d 3e 78			ld a, kLCD_Line4  
701f cd e1 70		            CALL fLCD_Pos       ;Position cursor to location in A  
7022 06 28			ld b, display_cols  
7024 ed 5b fe fa		ld de, (display_write_tmp)  
7028 cd 2c 70			call write_len_string  
702b c9					ret  
702c				  
702c				; write out a fixed length string given in b from de  
702c			  
702c 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
702d cd 99 70		            CALL fLCD_Data      ;Write character to display  
7030 13				inc de  
7031 10 f9			djnz write_len_string  
7033 c9				ret  
7034			  
7034			; Some other things to do  
7034			;            LD   A, kLCD_Clear ;Display clear  
7034			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7034			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7034			;            LD   A, kLCD_On     ;Display on with no cursor  
7034			;            ;LD   A, kLCD_Off   ;Display off  
7034			;            CALL fLCD_Inst      ;Send instruction to display  
7034			;  
7034			;  
7034			;            halt  
7034			;  
7034			;  
7034			;MsgHello:   DB  "Hello World!",0  
7034			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7034			  
7034			; Custom characters 5 pixels wide by 8 pixels high  
7034			; Up to 8 custom characters can be defined  
7034			;BitMaps:      
7034			;; Character 0x00 = Battery icon  
7034			;            DB  01110b  
7034			;            DB  11011b  
7034			;            DB  10001b  
7034			;            DB  10001b  
7034			;            DB  11111b  
7034			;            DB  11111b  
7034			;            DB  11111b  
7034			;            DB  11111b  
7034			;; Character 0x01 = Bluetooth icon  
7034			;            DB  01100b  
7034			;            DB  01010b  
7034			;            DB  11100b  
7034			;            DB  01000b  
7034			;            DB  11100b  
7034			;            DB  01010b  
7034			;            DB  01100b  
7034			;            DB  00000b  
7034			;  
7034			  
7034			  
7034			; **********************************************************************  
7034			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7034			; **********************************************************************  
7034			;  
7034			; **  Written as a Small Computer Monitor App   
7034			; **  Version 0.1 SCC 2018-05-16  
7034			; **  www.scc.me.uk  
7034			;  
7034			; **********************************************************************  
7034			;  
7034			; This module provides support for alphanumeric LCD modules using with  
7034			; *  HD44780 (or compatible) controller  
7034			; *  5 x 7 pixel fonts  
7034			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7034			; *  Interface via six digital outputs to the display (see below)  
7034			;  
7034			; LCD module pinout:  
7034			;   1  Vss   0v supply  
7034			;   2  Vdd   5v supply  
7034			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7034			;   4  RS    High = data, Low = instruction  
7034			;   5  R/W   High = Read, Low = Write  
7034			;   6  E     Enable signal (active high)  
7034			;   7  DB0   Data bit 0  
7034			;   8  DB1   Data bit 1  
7034			;   9  DB2   Data bit 2  
7034			;  10  DB3   Data bit 3  
7034			;  11  DB4   Data bit 4  
7034			;  12  DB5   Data bit 5  
7034			;  13  DB6   Data bit 6  
7034			;  14  DB7   Data bit 7  
7034			;  15  A     Backlight anode (+)  
7034			;  16  K     Backlight cathode (-)  
7034			;  
7034			; This interfacing method uses 4-bit data mode and uses time delays  
7034			; rather than polling the display's ready status. As a result the   
7034			; interface only requires 6 simple output lines:  
7034			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7034			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7034			;   LCD DB4 = Microcomputer output port bit 4  
7034			;   LCD DB5 = Microcomputer output port bit 5  
7034			;   LCD DB6 = Microcomputer output port bit 6  
7034			;   LCD DB7 = Microcomputer output port bit 7  
7034			; Display's R/W is connected to 0v so it is always in write mode  
7034			; All 6 connections must be on the same port address <kLCDPrt>  
7034			; This method also allows a decent length of cable from micro to LCD  
7034			;  
7034			; **********************************************************************  
7034			;  
7034			; To include the code for any given function provided by this module,   
7034			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7034			; the parent source file.  
7034			; For example:  #REQUIRES   uHexPrefix  
7034			;  
7034			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7034			; in the parent source file.  
7034			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7034			;  
7034			; These are the function names provided by this module:  
7034			; fLCD_Init                     ;Initialise LCD  
7034			; fLCD_Inst                     ;Send instruction to LCD  
7034			; fLCD_Data                     ;Send data byte to LCD  
7034			; fLCD_Pos                      ;Position cursor  
7034			; fLCD_Str                      ;Display string  
7034			; fLCD_Def                      ;Define custom character  
7034			;  
7034			; **********************************************************************  
7034			;  
7034			; Requires SCMonAPI.asm to also be included in the project  
7034			;  
7034			  
7034			  
7034			; **********************************************************************  
7034			; **  Constants  
7034			; **********************************************************************  
7034			  
7034			; Constants that must be defined externally  
7034			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7034			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7034			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7034			;kLCDWidth: EQU 20             ;Width in characters  
7034			  
7034			; general line offsets in any frame buffer  
7034			  
7034			  
7034			display_row_1: equ 0  
7034			display_row_2: equ display_row_1+display_cols  
7034			display_row_3: equ display_row_2 + display_cols  
7034			display_row_4: equ display_row_3 + display_cols  
7034			;display_row_4_eol:   
7034			  
7034			  
7034			; Cursor position values for the start of each line  
7034			  
7034			; E  
7034			kLCD_Line1: EQU 0x00   
7034			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
7034			; E1  
7034			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
7034			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
7034			  
7034			; Instructions to send as A register to fLCD_Inst  
7034			kLCD_Clear: EQU 00000001b     ;LCD clear  
7034			kLCD_Off:   EQU 00001000b     ;LCD off  
7034			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7034			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7034			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7034			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7034			  
7034			; Constants used by this code module  
7034			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7034			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7034			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7034			  
7034			  
7034			  
7034			; **********************************************************************  
7034			; **  LCD support functions  
7034			; **********************************************************************  
7034			  
7034			; Initialise alphanumeric LCD module  
7034			; LCD control register codes:  
7034			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7034			;   N    0 = 1-line mode       1 = 2-line mode  
7034			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7034			;   D    0 = Display off       1 = Display on  
7034			;   C    0 = Cursor off        1 = Cursor on  
7034			;   B    0 = Blinking off      1 = Blinking on  
7034			;   ID   0 = Decrement mode    1 = Increment mode  
7034			;   SH   0 = Entire shift off  1 = Entire shift on  
7034 3e 28		fLCD_Init:  LD   A, 40  
7036 cd 5b 71		            CALL LCDDelay       ;Delay 40ms after power up  
7039			; For reliable reset set 8-bit mode - 3 times  
7039 cd 2b 71		            CALL WrFn8bit       ;Function = 8-bit mode  
703c cd 2b 71		            CALL WrFn8bit       ;Function = 8-bit mode  
703f cd 2b 71		            CALL WrFn8bit       ;Function = 8-bit mode  
7042			; Set 4-bit mode  
7042 cd 27 71		            CALL WrFn4bit       ;Function = 4-bit mode  
7045 cd 59 71		            CALL LCDDelay1      ;Delay 37 us or more  
7048			; Function set  
7048 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
704a cd 5d 70		            CALL fLCD_Inst      ;2 line, display on  
704d			; Display On/Off control  
704d 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
704f cd 5d 70		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7052			; Display Clear  
7052 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7054 cd 5d 70		            CALL fLCD_Inst      ;Clear display  
7057			; Entry mode  
7057 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7059 cd 5d 70		            CALL fLCD_Inst      ;Increment mode, shift off  
705c			; Display module now initialised  
705c c9			            RET  
705d			; ok to here  
705d			  
705d			; Write instruction to LCD  
705d			;   On entry: A = Instruction byte to be written  
705d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
705d f5			fLCD_Inst:  PUSH AF  
705e f5			            PUSH AF  
705f cd 71 70		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7062 f1			            POP  AF  
7063 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7064 17			            RLA  
7065 17			            RLA  
7066 17			            RLA  
7067 cd 71 70		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
706a 3e 02		            LD   A, 2  
706c cd 5b 71		            CALL LCDDelay       ;Delay 2 ms to complete   
706f f1			            POP  AF  
7070 c9			            RET  
7071			Wr4bits:   
7071 f5					push af  
7072 3a 00 fb				ld a, (display_lcde1e2)  
7075 fe 00				cp 0     ; e  
7077 20 10				jr nz, .wea2	  
7079 f1					pop af  
707a e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
707c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
707e cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7080 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7082 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7084 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7086 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7088 c9			            RET  
7089 f1			.wea2:		pop af  
708a e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
708c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
708e cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7090 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7092 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7094 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7096 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7098 c9			            RET  
7099			  
7099			  
7099			; Write data to LCD  
7099			;   On entry: A = Data byte to be written  
7099			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7099 f5			fLCD_Data:  PUSH AF  
709a f5			            PUSH AF  
709b cd ad 70		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
709e f1			            POP  AF  
709f 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
70a0 17			            RLA  
70a1 17			            RLA  
70a2 17			            RLA  
70a3 cd ad 70		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
70a6 3e 96		            LD   A, 150  
70a8 3d			Wait:      DEC  A              ;Wait a while to allow data   
70a9 20 fd		            JR   NZ, Wait      ;  write to complete  
70ab f1			            POP  AF  
70ac c9			            RET  
70ad			Wr4bitsa:     
70ad f5					push af  
70ae 3a 00 fb				ld a, (display_lcde1e2)  
70b1 fe 00				cp 0     ; e1  
70b3 20 16				jr nz, .we2	  
70b5 f1					pop af  
70b6 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
70b8 cb d7		            SET  kLCDBitRS, A  
70ba d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
70bc cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
70be cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
70c0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
70c2 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
70c4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
70c6 cb 97		            RES  kLCDBitRS, A  
70c8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70ca c9			            RET  
70cb f1			.we2:		pop af  
70cc e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
70ce cb d7		            SET  kLCDBitRS, A  
70d0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
70d2 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
70d4 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
70d6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
70d8 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
70da d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
70dc cb 97		            RES  kLCDBitRS, A  
70de d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70e0 c9			            RET  
70e1			  
70e1			  
70e1			; Position cursor to specified location  
70e1			;   On entry: A = Cursor position  
70e1			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
70e1 f5			fLCD_Pos:   PUSH AF  
70e2					; at this point set the E1 or E2 flag depending on position  
70e2			  
70e2 c5					push bc  
70e3			;		push af  
70e3 06 00				ld b, 0  
70e5 4f					ld c, a  
70e6 3e 4f				ld a, kLCD_Line3-1  
70e8 b7			 		or a      ;clear carry flag  
70e9 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
70ea 38 04				jr c, .pe1  
70ec			  
70ec					; E selection  
70ec cb 80				res 0, b         ; bit 0 unset e  
70ee			;		pop af    ; before line 3 so recover orig pos  
70ee			;		ld c, a    ; save for poking back  
70ee 18 06				jr .peset	          
70f0			.pe1:          	; E2 selection  
70f0 cb c0				set 0, b         ; bit 0 set e1  
70f2 79					ld a, c  
70f3 de 4f				sbc a, kLCD_Line3-1  
70f5 4f					ld c, a	         ; save caculated offset  
70f6			;		pop af     ; bin this original value now we have calculated form  
70f6			  
70f6			.peset:		; set bit  
70f6 78					ld a, b  
70f7 32 00 fb				ld (display_lcde1e2), a 	  
70fa 79					ld a, c  
70fb c1					pop bc  
70fc			  
70fc f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
70fe cd 5d 70		            CALL fLCD_Inst      ;Write instruction to LCD  
7101 f1			            POP  AF  
7102 c9			            RET  
7103			  
7103			  
7103			; Output text string to LCD  
7103			;   On entry: DE = Pointer to null terminated text string  
7103			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7103 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7104 b7			            OR   A              ;Null terminator?  
7105 c8			            RET  Z              ;Yes, so finished  
7106 cd 99 70		            CALL fLCD_Data      ;Write character to display  
7109 13			            INC  DE             ;Point to next character  
710a 18 f7		            JR   fLCD_Str       ;Repeat  
710c c9					ret  
710d			  
710d			; Define custom character  
710d			;   On entry: A = Character number (0 to 7)  
710d			;             DE = Pointer to character bitmap data  
710d			;   On exit:  A = Next character number  
710d			;             DE = Next location following bitmap  
710d			;             BC HL IX IY I AF' BC' DE' HL' preserved  
710d			; Character is   
710d c5			fLCD_Def:   PUSH BC  
710e f5			            PUSH AF  
710f 07			            RLCA                ;Calculate location  
7110 07			            RLCA                ;  for bitmap data  
7111 07			            RLCA                ;  = 8 x CharacterNumber  
7112 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7114 cd 5d 70		            CALL fLCD_Inst      ;Write instruction to LCD  
7117 06 00		            LD   B, 0  
7119 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
711a cd 99 70		            CALL fLCD_Data      ;Write byte to display  
711d 13			            INC  DE             ;Point to next byte  
711e 04			            INC  B              ;Count bytes  
711f cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7121 28 f6		            JR   Z, Loop       ;No, so repeat  
7123 f1			            POP  AF  
7124 3c			            INC  A              ;Increment character number  
7125 c1			            POP  BC  
7126 c9			            RET  
7127			  
7127			  
7127			; **********************************************************************  
7127			; **  Private functions  
7127			; **********************************************************************  
7127			  
7127			; Write function to LCD  
7127			;   On entry: A = Function byte to be written  
7127			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7127 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7129 18 02		            JR   WrFunc  
712b 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
712d f5			WrFunc:     PUSH AF  
712e f5					push af  
712f 3a 00 fb				ld a, (display_lcde1e2)  
7132 fe 00				cp 0     ; e1  
7134 20 0f				jr nz, .wfea2	  
7136 f1					pop af  
7137 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7139 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
713b cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
713d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
713f cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7141 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7143 18 0d			jr .wfskip  
7145 f1			.wfea2:		pop af  
7146 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7148 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
714a cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
714c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
714e cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7150 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7152 3e 05		.wfskip:            LD  A, 5  
7154 cd 5b 71		            CALL LCDDelay       ;Delay 5 ms to complete  
7157 f1			            POP  AF  
7158 c9			            RET  
7159			  
7159			  
7159			; Delay in milliseconds  
7159			;   On entry: A = Number of milliseconds delay  
7159			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7159 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
715b d5			LCDDelay:   PUSH DE  
715c 5f			            LD   E, A           ;Delay by 'A' ms  
715d 16 00		            LD   D, 0  
715f cd d2 0c		            CALL aDelayInMS  
7162 d1			            POP  DE  
7163 c9			            RET  
7164			  
7164			  
7164			testlcd:  
7164 3e 00			ld a, kLCD_Line1  
7166 cd e1 70			call fLCD_Pos  
7169 06 28			ld b, 40  
716b 11 99 71			ld de, .ttext1  
716e cd 2c 70			call write_len_string  
7171			  
7171 3e 28			ld a, kLCD_Line2  
7173 cd e1 70			call fLCD_Pos  
7176 06 28			ld b, 40  
7178 11 c2 71			ld de, .ttext2  
717b cd 2c 70			call write_len_string  
717e 3e 50			ld a, kLCD_Line3  
7180 cd e1 70			call fLCD_Pos  
7183 06 28			ld b, 40  
7185 11 eb 71			ld de, .ttext3  
7188 cd 2c 70			call write_len_string  
718b 3e 78			ld a, kLCD_Line4  
718d cd e1 70			call fLCD_Pos  
7190 06 28			ld b, 40  
7192 11 14 72			ld de, .ttext4  
7195 cd 2c 70			call write_len_string  
7198			  
7198 76				halt  
7199			  
7199			  
7199 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
71c2 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
71eb .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7214 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
723d			   
723d			  
723d			  
723d			; eof  
723d			  
# End of file firmware_lcd_4x40.asm
723d			;include "firmware_lcd_4x20.asm" 
723d			include "firmware_key_5x10.asm" 
723d			; 5 x 10 decade counter scanner  
723d			  
723d			  
723d			; TODO do cursor shape change for shift keys  
723d			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
723d			  
723d			  
723d			; bit mask for each scan column and row for teing the matrix  
723d			  
723d			  
723d			key_init:  
723d			  
723d			; SCMonAPI functions used  
723d			  
723d			; Alphanumeric LCD functions used  
723d			; no need to specify specific functions for this module  
723d			  
723d			  
723d 3e cf		            LD   A, 11001111b  
723f d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
7241			;            LD   A, 00000000b  
7241 3e 1f		            LD   A, 00011111b  
7243 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7245			  
7245			  
7245				; TODO Configure cursor shapes  
7245			  
7245				; Load cursor shapes   
7245 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7247 11 57 72		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
724a 06 02		            LD   B, 2           ;Number of characters to define  
724c cd 0d 71		.DefLoop:   CALL fLCD_Def       ;Define custom character  
724f 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7251			  
7251 3e 01				ld a, 1  
7253 32 f6 fa			ld (cursor_shape),a  
7256 c9				ret  
7257			  
7257			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7257			; Up to 8 custom characters can be defined  
7257			.cursor_shapes:      
7257			;; Character 0x00 = Normal  
7257 1f			            DB  11111b  
7258 1f			            DB  11111b  
7259 1f			            DB  11111b  
725a 1f			            DB  11111b  
725b 1f			            DB  11111b  
725c 1f			            DB  11111b  
725d 1f			            DB  11111b  
725e 1f			            DB  11111b  
725f			;; Character 0x01 = Modifier  
725f 1f			            DB  11111b  
7260 1b			            DB  11011b  
7261 1b			            DB  11011b  
7262 1b			            DB  11011b  
7263 1b			            DB  11011b  
7264 1f			            DB  11111b  
7265 1b			            DB  11011b  
7266 1f			            DB  11111b  
7267			  
7267			  
7267			  
7267			  
7267			; Display custom character 0  
7267			;            LD   A, kLCD_Line1+14  
7267			;            CALL fLCD_Pos       ;Position cursor to location in A  
7267			;            LD   A, 0  
7267			;            CALL fLCD_Data      ;Write character in A at cursor  
7267			  
7267			; Display custom character 1  
7267			;            LD   A, kLCD_Line2+14  
7267			;            CALL fLCD_Pos      ;Position cursor to location in A  
7267			;            LD   A, 1  
7267			;            CALL fLCD_Data     ;Write character in A at cursor  
7267			  
7267			; keyboard scanning   
7267			  
7267			; character in from keyboard  
7267			  
7267			; mapping for the pcb layout  
7267			  
7267			.matrix_to_char:  
7267 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7272 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
727d 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7288 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7293 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
729e			.matrix_to_shift:  
729e			  
729e .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
72a9 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
72b4 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
72bf 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
72ca .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
72d5			  
72d5			.matrix_to_symbolshift:  
72d5			  
72d5 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
72e0 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
72eb 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
72f6			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
72f6 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7301 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
730c			  
730c			  
730c			  
730c			; mapping for a simple straight through breadboard layout  
730c			  
730c			;.matrix_to_char:  
730c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
730c			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
730c			;		db "asdfghjkl",KEY_CR,0  
730c			;		db "qwertyuiop",0  
730c			;		 db "1234567890",0  
730c			;.matrix_to_shift:  
730c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
730c			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
730c			;		db "ASDFGHJKL",KEY_CR,0  
730c			;		db "QWERTYUIOP",0  
730c			;		 db "!",'"',"#$%^&*()",0  
730c			;.matrix_to_symbolshift:  
730c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
730c			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
730c			;		db "_?*fghjk=",KEY_CR,0  
730c			;		db "-/+*[]{}@#",0  
730c			;		 db "1234567890",0  
730c			  
730c			;.matrix_to_char: db "D#0*C987B654A321"  
730c			  
730c			  
730c				  
730c			  
730c			; add cin and cin_wait  
730c			  
730c cd 1d 73		cin_wait: 	call cin  
730f						if DEBUG_KEYCINWAIT  
730f							push af  
730f							  
730f							ld hl,key_repeat_ct  
730f							ld (hl),a  
730f							inc hl  
730f							call hexout  
730f							ld hl,key_repeat_ct+3  
730f							ld a,0  
730f							ld (hl),a  
730f			  
730f							    LD   A, kLCD_Line1+11  
730f							    CALL fLCD_Pos       ;Position cursor to location in A  
730f							    LD   DE, key_repeat_ct  
730f							    ;LD   DE, MsgHello  
730f							    CALL fLCD_Str       ;Display string pointed to by DE  
730f			  
730f			  
730f			  
730f							pop af  
730f						endif  
730f fe 00			cp 0  
7311 28 f9			jr z, cin_wait   ; block until key press  
7313			  
7313							if DEBUG_KEYCINWAIT  
7313								push af  
7313			  
7313								ld a, 'A'	  
7313								ld hl,key_repeat_ct  
7313								ld (hl),a  
7313								inc hl  
7313								ld a,0  
7313								ld (hl),a  
7313			  
7313								    LD   A, kLCD_Line2+11  
7313								    CALL fLCD_Pos       ;Position cursor to location in A  
7313								    LD   DE, key_repeat_ct  
7313								    ;LD   DE, MsgHello  
7313								    CALL fLCD_Str       ;Display string pointed to by DE  
7313			  
7313							call delay500ms  
7313			  
7313								pop af  
7313							endif  
7313 f5				push af   ; save key pressed  
7314			  
7314			.cin_wait1:	  
7314							if DEBUG_KEYCINWAIT  
7314								push af  
7314			  
7314								ld a, 'b'	  
7314								ld hl,key_repeat_ct  
7314								ld (hl),a  
7314								inc hl  
7314								ld a,0  
7314								ld (hl),a  
7314			  
7314								    LD   A, kLCD_Line2+11  
7314								    CALL fLCD_Pos       ;Position cursor to location in A  
7314								    LD   DE, key_repeat_ct  
7314								    ;LD   DE, MsgHello  
7314								    CALL fLCD_Str       ;Display string pointed to by DE  
7314			  
7314			  
7314							call delay500ms  
7314			  
7314								pop af  
7314							endif  
7314			  
7314 cd 1d 73		call cin  
7317 fe 00			cp 0  
7319 20 f9			jr nz, .cin_wait1  	; wait for key release  
731b			if DEBUG_KEYCINWAIT  
731b				push af  
731b			  
731b				ld a, '3'	  
731b				ld hl,key_repeat_ct  
731b				ld (hl),a  
731b				inc hl  
731b				ld a,0  
731b				ld (hl),a  
731b			  
731b			            LD   A, kLCD_Line2+11  
731b			            CALL fLCD_Pos       ;Position cursor to location in A  
731b			            LD   DE, key_repeat_ct  
731b			            ;LD   DE, MsgHello  
731b			            CALL fLCD_Str       ;Display string pointed to by DE  
731b			  
731b			  
731b			call delay500ms  
731b			  
731b				pop af  
731b			endif  
731b			  
731b f1				pop af   ; get key  
731c c9				ret  
731d			  
731d			  
731d cd 31 73		cin: 	call .mtoc  
7320			  
7320			if DEBUG_KEYCIN  
7320				push af  
7320				  
7320				ld hl,key_repeat_ct  
7320				ld (hl),a  
7320				inc hl  
7320				call hexout  
7320				ld hl,key_repeat_ct+3  
7320				ld a,0  
7320				ld (hl),a  
7320			  
7320			            LD   A, kLCD_Line3+15  
7320			            CALL fLCD_Pos       ;Position cursor to location in A  
7320			            LD   DE, key_repeat_ct  
7320			            ;LD   DE, MsgHello  
7320			            CALL fLCD_Str       ;Display string pointed to by DE  
7320			  
7320			  
7320			call delay500ms  
7320			  
7320				pop af  
7320			endif  
7320			  
7320			  
7320				; no key held  
7320 fe 00			cp 0  
7322 c8				ret z  
7323			  
7323			if DEBUG_KEYCIN  
7323				push af  
7323			  
7323				ld a, '1'	  
7323				ld hl,key_repeat_ct  
7323				ld (hl),a  
7323				inc hl  
7323				ld a,0  
7323				ld (hl),a  
7323			  
7323			            LD   A, kLCD_Line4+15  
7323			            CALL fLCD_Pos       ;Position cursor to location in A  
7323			            LD   DE, key_repeat_ct  
7323			            ;LD   DE, MsgHello  
7323			            CALL fLCD_Str       ;Display string pointed to by DE  
7323			  
7323			  
7323			call delay500ms  
7323			  
7323				pop af  
7323			endif  
7323			  
7323				; stop key bounce  
7323			  
7323 32 c6 fd			ld (key_held),a		 ; save it  
7326 47				ld b, a  
7327			  
7327 c5			.cina1:	push bc  
7328			if DEBUG_KEYCIN  
7328				push af  
7328			  
7328				ld hl,key_repeat_ct  
7328				inc hl  
7328				call hexout  
7328				ld hl,key_repeat_ct+3  
7328				ld a,0  
7328				ld (hl),a  
7328				ld hl,key_repeat_ct  
7328				ld a, '2'	  
7328				ld (hl),a  
7328			  
7328			            LD   A, kLCD_Line4+15  
7328			            CALL fLCD_Pos       ;Position cursor to location in A  
7328			            LD   DE, key_repeat_ct  
7328			            ;LD   DE, MsgHello  
7328			            CALL fLCD_Str       ;Display string pointed to by DE  
7328			  
7328				pop af  
7328			endif  
7328 cd 31 73			call .mtoc  
732b c1				pop bc  
732c b8				cp b  
732d 28 f8			jr z, .cina1  
732f 78				ld a,b		  
7330			if DEBUG_KEYCIN  
7330				push af  
7330			  
7330				ld hl,key_repeat_ct  
7330				inc hl  
7330				call hexout  
7330				ld hl,key_repeat_ct+3  
7330				ld a,0  
7330				ld (hl),a  
7330				ld hl,key_repeat_ct  
7330				ld a, '3'	  
7330				ld (hl),a  
7330			  
7330			            LD   A, kLCD_Line4+15  
7330			            CALL fLCD_Pos       ;Position cursor to location in A  
7330			            LD   DE, key_repeat_ct  
7330			            ;LD   DE, MsgHello  
7330			            CALL fLCD_Str       ;Display string pointed to by DE  
7330			  
7330				pop af  
7330			endif  
7330 c9				ret  
7331			  
7331			; detect keyboard modifier key press and apply new overlay to the face key held  
7331			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7331			  
7331			;.cin_map_modifier:   
7331			;	ld a, (hl)  
7331			;	and 255  
7331			;	ret NZ		; modifier key not flagged  
7331			;  
7331			;	; get key face  
7331			;  
7331			;	ld b,(key_face_held)  
7331			;  
7331			;	ld b, key_cols * key_rows  
7331			;  
7331			;	push de  
7331			;	pop hl  
7331			;  
7331			;.mmod1: ld a,(hl)   ; get map test  
7331			;	cp b  
7331			;	jr z, .mmod2  
7331			;  
7331			;  
7331			;  
7331			;.mmod2: inc hl    ;   
7331			;  
7331			;	  
7331			;  
7331			;	  
7331			;  
7331			;	ld hl,key_actual_pressed  
7331			;	ld (hl),a,  
7331			;	ret  
7331			  
7331			; map matrix key held to char on face of key  
7331			  
7331			.mtoc:  
7331			  
7331			; test decade counter strobes  
7331			  
7331			;.decadetest1:  
7331			  
7331			; reset counter  
7331			;ld a, 128  
7331			;out (portbdata),a  
7331			  
7331			  
7331			;ld b, 5  
7331			;.dec1:  
7331			;ld a, 0  
7331			;out (portbdata),a  
7331			;call delay1s  
7331			  
7331			;ld a, 32  
7331			;out (portbdata),a  
7331			;call delay1s  
7331			;call delay1s  
7331			;call delay1s  
7331			;  
7331			;ld a, 64+32  
7331			;out (portbdata),a  
7331			;call delay1s  
7331			;;djnz .dec1  
7331			;  
7331			;jp .decadetest1  
7331			  
7331			  
7331			  
7331			  
7331			  
7331			  
7331			  
7331			  
7331			  
7331			  
7331				; scan keyboard matrix and generate raw scan map  
7331 cd c4 73			call matrix  
7334			  
7334				; reuse c bit 0 left modifer button - ie shift  
7334			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7334				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7334			  
7334 0e 00			ld c, 0  
7336			  
7336				; TODO set flags for modifer key presses   
7336				; TODO do a search for modifer key...  
7336			  
7336				;ld hl,keyscan_table_row4  
7336 21 25 fe			ld hl,keyscan_table_row2  
7339			  
7339 7e				ld a, (hl)  
733a fe 23			cp '#'  
733c 20 07			jr nz, .nextmodcheck  
733e cb c1			set 0, c  
7340 21 9e 72			ld hl, .matrix_to_shift  
7343 18 21			jr .dokeymap  
7345				; TODO for now igonre  
7345			.nextmodcheck:  
7345 21 1a fe			ld hl,keyscan_table_row3  
7348			  
7348 7e				ld a, (hl)  
7349 fe 23			cp '#'  
734b 20 07			jr nz, .nextmodcheck2  
734d cb c9			set 1, c   
734f 21 d5 72			ld hl, .matrix_to_symbolshift  
7352 18 12			jr .dokeymap  
7354			.nextmodcheck2:  
7354 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
7357			  
7357 7e				ld a, (hl)  
7358 fe 23			cp '#'  
735a 20 07			jr nz, .donemodcheck  
735c cb c9			set 1, c   
735e 21 9e 72			ld hl, .matrix_to_shift  
7361 18 03			jr .dokeymap  
7363			  
7363				; no modifer found so just map to normal keys  
7363				; get mtoc map matrix to respective keys  
7363			;	ld hl, .matrix_to_char  
7363			;	ld hl, .matrix_to_char  
7363			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7363			;	ld a, KEY_SHIFT  
7363			;	call findchar  
7363			;  
7363			;	; got offset to key modifer in b  
7363			;  
7363			;	ld hl,keyscan_table_row5  
7363			;  
7363			;	ld a,b  
7363			;	call addatohl  
7363			;	ld a,(hl)  
7363			;  
7363			;	cp '#'  
7363			;	jr nz, .nextmodcheck  
7363			;	set 0, c  
7363			;	ld hl, .matrix_to_char  
7363			;	jr .dokeymap  
7363			;	; TODO for now igonre  
7363			;.nextmodcheck:  
7363			;	ld hl, .matrix_to_symbolshift  
7363			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7363			;	ld a, KEY_SYMBOLSHIFT  
7363			;	call findchar  
7363			;  
7363			;  
7363			;	; got offset to key modifer in b  
7363			;  
7363			;	ld hl,keyscan_table_row5  
7363			;  
7363			;	ld a,b  
7363			;	call addatohl  
7363			;	ld a,(hl)  
7363			;  
7363			;	cp '#'  
7363			;	jr nz, .donemodcheck  
7363			;	set 1, c   
7363			;	ld hl, .matrix_to_symbolshift  
7363			;	jr .dokeymap  
7363			  
7363			  
7363			  
7363			.donemodcheck:  
7363				; no modifer found so just map to normal keys  
7363				; get mtoc map matrix to respective keys  
7363 21 67 72			ld hl, .matrix_to_char  
7366			  
7366			.dokeymap:  
7366				;ld (key_fa), c   
7366 cd 7f 73			call .mapkeys  
7369			  
7369			  
7369			if DEBUG_KEY  
7369			  
7369			; Display text on first line  
7369			            LD   A, kLCD_Line1  
7369			            CALL fLCD_Pos       ;Position cursor to location in A  
7369			            LD   DE, keyscan_table_row1  
7369			            ;LD   DE, MsgHello  
7369			            CALL fLCD_Str       ;Display string pointed to by DE  
7369			  
7369			; Display text on second line  
7369			            LD   A, kLCD_Line2  
7369			            CALL fLCD_Pos       ;Position cursor to location in A  
7369			            LD   DE, keyscan_table_row2  
7369			            CALL fLCD_Str       ;Display string pointed to by DE  
7369			            LD   A, kLCD_Line3  
7369			            CALL fLCD_Pos       ;Position cursor to location in A  
7369			            LD   DE, keyscan_table_row3  
7369			            CALL fLCD_Str       ;Display string pointed to by DE  
7369			            LD   A, kLCD_Line4  
7369			            CALL fLCD_Pos       ;Position cursor to location in A  
7369			            LD   DE, keyscan_table_row4  
7369			            CALL fLCD_Str       ;Display string pointed to by DE  
7369			            LD   A, kLCD_Line1+10  
7369			            CALL fLCD_Pos       ;Position cursor to location in A  
7369			            LD   DE, keyscan_table_row5  
7369			            CALL fLCD_Str       ;Display string pointed to by DE  
7369			  
7369				;call delay250ms  
7369			endif  
7369			;	jp testkey  
7369			  
7369			; get first char reported  
7369			  
7369 21 04 fe			ld hl,keyscan_table_row5  
736c			  
736c				;ld b, 46   ; 30 keys to remap + 8 nulls   
736c 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
736e			.findkey:  
736e 7e				ld a,(hl)  
736f fe 00			cp 0  
7371 28 04			jr z, .nextkey  
7373 fe 7e			cp KEY_MATRIX_NO_PRESS  
7375 20 06			jr nz, .foundkey  
7377			.nextkey:  
7377 23				inc hl  
7378 10 f4			djnz .findkey  
737a 3e 00			ld a,0  
737c c9				ret  
737d			.foundkey:  
737d 7e				ld a,(hl)  
737e c9				ret  
737f				  
737f			  
737f			; convert the raw key map given hl for destination key  
737f			.mapkeys:  
737f 11 04 fe			ld de,keyscan_table_row5  
7382			  
7382 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7384			.remap:  
7384 1a				ld a,(de)  
7385 fe 23			cp '#'  
7387 20 02			jr nz, .remapnext  
7389				;CALLMONITOR  
7389 7e				ld a,(hl)  
738a 12				ld (de),a  
738b			  
738b			  
738b			  
738b			.remapnext:  
738b 23				inc hl  
738c 13				inc de  
738d 10 f5			djnz .remap  
738f				  
738f c9				ret  
7390			  
7390			  
7390			  
7390			.mtocold2:  
7390			  
7390			;	; flag if key D is held down and remove from reporting  
7390			;	ld bc, .key_map_fd    
7390			;	ld hl, keyscan_table  
7390			;	ld de, key_fd  
7390			;	call .key_shift_hold  
7390			;	cp 255  
7390			;	jr z, .cinmap  
7390			;	; flag if key C is held down and remove from reporting  
7390			;	ld bc, .key_map_fc    
7390			;	ld hl, keyscan_table+key_cols  
7390			;	ld de, key_fc  
7390			;	call .key_shift_hold  
7390			;	cp 255  
7390			;	jr z, .cinmap  
7390			;	; flag if key B is held down and remove from reporting  
7390			;	ld bc, .key_map_fb    
7390			;	ld hl, keyscan_table+(key_cols*2)  
7390			;	ld de, key_fb  
7390			;	call .key_shift_hold  
7390			;	cp 255  
7390			;	jr z, .cinmap  
7390			;	; flag if key A is held down and remove from reporting  
7390			;	ld bc, .key_map_fa    
7390			;	ld hl, keyscan_table+(key_cols*3)  
7390			;	ld de, key_fa  
7390			;	call .key_shift_hold  
7390			;	cp 255  
7390			;	jr z, .cinmap  
7390			  
7390 11 67 72			ld de, .matrix_to_char  
7393			  
7393			  
7393			.cinmap1:   
7393				if DEBUG_KEY  
7393			            LD   A, kLCD_Line4  
7393			            CALL fLCD_Pos       ;Position cursor to location in A  
7393					push de  
7393			            LD   DE, keyscan_table  
7393			            CALL fLCD_Str       ;Display string pointed to by DE  
7393					pop de  
7393				endif  
7393			  
7393				; scan key matrix table for any held key  
7393			  
7393				; de holds either the default matrix or one selected above  
7393			  
7393 21 d1 fd			ld hl, keyscan_table  
7396 06 32			ld b,key_cols*key_rows  
7398			  
7398 7e			.cin11:	ld a,(hl)  
7399 fe 23			cp '#'  
739b 28 08			jr z, .cinhit1  
739d 23				inc hl  
739e 13				inc de  
739f 05				dec b  
73a0 20 f6			jr nz, .cin11  
73a2				; no key found held  
73a2 3e 00			ld a,0  
73a4 c9				ret  
73a5 d5			.cinhit1: push de  
73a6 e1				pop hl  
73a7 7e				ld a,(hl)  
73a8 c9				ret  
73a9			  
73a9			; flag a control key is held   
73a9			; hl is key pin, de is flag indicator  
73a9			  
73a9			.key_shift_hold1:  
73a9 c5				push bc  
73aa 3e 01			ld a, 1  
73ac 32 f6 fa			ld (cursor_shape),a  
73af 06 00			ld b, 0  
73b1 7e				ld a, (hl)  
73b2 fe 2e			cp '.'  
73b4 28 0a			jr z, .key_shift11  
73b6 06 ff			ld b, 255  
73b8 3e 2b			ld a, '+'    ; hide key from later scans  
73ba 77				ld (hl),a  
73bb 3e 02			ld a, 2  
73bd 32 f6 fa			ld (cursor_shape),a  
73c0			.key_shift11:  
73c0				; write flag indicator  
73c0 78				ld a,b  
73c1 12				ld (de),a  
73c2			  
73c2 d1				pop de    ; de now holds the key map ptr  
73c3 c9				ret  
73c4			  
73c4				  
73c4			  
73c4			; scans keyboard matrix and flags key press in memory array	  
73c4				  
73c4			matrix:  
73c4				;call matrix  
73c4				; TODO optimise the code....  
73c4			  
73c4			  
73c4			;ld hl, keyscan_table_row1  
73c4			;ld de, keyscan_table_row1+1  
73c4			;ld bc,46  
73c4			;ld a,KEY_MATRIX_NO_PRESS  
73c4			;ldir  
73c4			  
73c4			  
73c4			  
73c4			; reset counter  
73c4 3e 80		ld a, 128  
73c6 d3 c1		out (portbdata),a  
73c8			  
73c8 06 0a		ld b, 10  
73ca 0e 00		ld c, 0       ; current clock toggle  
73cc			  
73cc			.colscan:  
73cc			  
73cc			; set current column  
73cc			; disable clock enable and set clock low  
73cc			  
73cc			;ld a, 0  
73cc			;out (portbdata),a  
73cc			  
73cc			; For each column scan for switches  
73cc			  
73cc c5			push bc  
73cd 21 c7 fd		ld hl, keyscan_scancol  
73d0 cd d9 74		call .rowscan  
73d3 c1			pop bc  
73d4			  
73d4			  
73d4			; get back current column  
73d4			  
73d4			; translate the row scan  
73d4			  
73d4			;   
73d4			; row 1  
73d4			  
73d4 78			ld a,b  
73d5			  
73d5 21 3a fe		LD   hl, keyscan_table_row1+10  
73d8			  
73d8 cd f0 0f		call subafromhl  
73db			;call addatohl  
73db			  
73db 11 c7 fd		ld de, keyscan_scancol  
73de			  
73de 1a			ld a,(de)  
73df 77			ld (hl),a  
73e0			  
73e0			  
73e0			  
73e0			  
73e0			; row 2  
73e0			  
73e0 78			ld a,b  
73e1			  
73e1 21 2f fe		LD   hl, keyscan_table_row2+10  
73e4			  
73e4			;call addatohl  
73e4 cd f0 0f		call subafromhl  
73e7			  
73e7			  
73e7 11 c8 fd		ld de, keyscan_scancol+1  
73ea			  
73ea 1a			ld a,(de)  
73eb 77			ld (hl),a  
73ec			  
73ec			  
73ec			; row 3  
73ec			  
73ec 78			ld a,b  
73ed			  
73ed 21 24 fe		LD   hl, keyscan_table_row3+10  
73f0			  
73f0			;call addatohl  
73f0 cd f0 0f		call subafromhl  
73f3			  
73f3 11 c9 fd		ld de, keyscan_scancol+2  
73f6			  
73f6 1a			ld a,(de)  
73f7 77			ld (hl),a  
73f8			  
73f8			  
73f8			  
73f8			; row 4  
73f8			  
73f8 78			ld a,b  
73f9			  
73f9 21 19 fe		LD   hl, keyscan_table_row4+10  
73fc			  
73fc			;call addatohl  
73fc cd f0 0f		call subafromhl  
73ff			  
73ff 11 ca fd		ld de, keyscan_scancol+3  
7402			  
7402 1a			ld a,(de)  
7403 77			ld (hl),a  
7404			  
7404			; row 5  
7404			  
7404 78			ld a,b  
7405			  
7405 21 0e fe		LD   hl, keyscan_table_row5+10  
7408			  
7408			;call addatohl  
7408 cd f0 0f		call subafromhl  
740b			  
740b 11 cb fd		ld de, keyscan_scancol+4  
740e			  
740e 1a			ld a,(de)  
740f 77			ld (hl),a  
7410			  
7410			; handshake next column  
7410			  
7410			  
7410 3e 40		ld a, 64  
7412 d3 c1		out (portbdata),a  
7414			  
7414 3e 00		ld a, 0  
7416 d3 c1		out (portbdata),a  
7418			  
7418			; toggle clk and move to next column  
7418			;ld a, 64  
7418			;cp c  
7418			;  
7418			;jr z, .coltoglow  
7418			;ld c, a  
7418			;jr .coltog  
7418			;.coltoglow:  
7418			;ld c, 0  
7418			;.coltog:  
7418			;ld a, c  
7418			;out (portbdata),a  
7418			  
7418 10 b2		djnz .colscan  
741a			  
741a 3e 0a		ld a,10  
741c 21 30 fe		LD   hl, keyscan_table_row1  
741f cd de 0f		call addatohl  
7422 3e 00		ld a, 0  
7424 77			ld (hl), a  
7425			  
7425			  
7425 3e 0a		ld a,10  
7427 21 25 fe		LD   hl, keyscan_table_row2  
742a cd de 0f		call addatohl  
742d 3e 00		ld a, 0  
742f 77			ld (hl), a  
7430			  
7430 3e 0a		ld a,10  
7432 21 1a fe		LD   hl, keyscan_table_row3  
7435 cd de 0f		call addatohl  
7438 3e 00		ld a, 0  
743a 77			ld (hl), a  
743b			  
743b 3e 0a		ld a,10  
743d 21 0f fe		LD   hl, keyscan_table_row4  
7440 cd de 0f		call addatohl  
7443 3e 00		ld a, 0  
7445 77			ld (hl), a  
7446			  
7446 3e 0a		ld a,10  
7448 21 04 fe		LD   hl, keyscan_table_row5  
744b cd de 0f		call addatohl  
744e 3e 00		ld a, 0  
7450 77			ld (hl), a  
7451			  
7451			if DEBUG_KEY_MATRIX  
7451			  
7451			; Display text on first line  
7451			            LD   A, kLCD_Line1  
7451			            CALL fLCD_Pos       ;Position cursor to location in A  
7451			            LD   DE, keyscan_table_row1  
7451			            ;LD   DE, MsgHello  
7451			            CALL fLCD_Str       ;Display string pointed to by DE  
7451			  
7451			; Display text on second line  
7451			            LD   A, kLCD_Line2  
7451			            CALL fLCD_Pos       ;Position cursor to location in A  
7451			            LD   DE, keyscan_table_row2  
7451			            CALL fLCD_Str       ;Display string pointed to by DE  
7451			            LD   A, kLCD_Line3  
7451			            CALL fLCD_Pos       ;Position cursor to location in A  
7451			            LD   DE, keyscan_table_row3  
7451			            CALL fLCD_Str       ;Display string pointed to by DE  
7451			            LD   A, kLCD_Line4  
7451			            CALL fLCD_Pos       ;Position cursor to location in A  
7451			            LD   DE, keyscan_table_row4  
7451			            CALL fLCD_Str       ;Display string pointed to by DE  
7451			            LD   A, kLCD_Line4+10  
7451			            CALL fLCD_Pos       ;Position cursor to location in A  
7451			            LD   DE, keyscan_table_row5  
7451			            CALL fLCD_Str       ;Display string pointed to by DE  
7451			  
7451			;call delay250ms  
7451				jp matrix  
7451			endif  
7451 c9			ret  
7452			  
7452			; using decade counter....  
7452			  
7452			  
7452			; TODO reset decade counter to start of scan  
7452			  
7452			; reset 15  
7452			; clock 14  
7452			; ce 13  
7452			  
7452			; 1 - q5  
7452			; 2 - q1  
7452			; 3 - q0  
7452			; 4 - q2  
7452			; 5 - q6  
7452			; 6 - q7  
7452			; 7 - q3  
7452			; 8 - vss  
7452			; 9 - q8  
7452			; 10 - q4  
7452			; 11 - q9  
7452			; 12 - cout  
7452			; 16 - vdd  
7452			  
7452			; clock      ce       reset     output  
7452			; 0          x        0         n  
7452			; x          1        0         n  
7452			; x          x        1         q0  
7452			; rising     0        0         n+1  
7452			; falling    x        0         n  
7452			; x          rising   0         n  
7452			; 1          falling  0         x+1  
7452			;  
7452			; x = dont care, if n < 5 carry = 1 otherwise 0  
7452			  
7452			;   
7452			; reset   
7452			; 13=0, 14=0, 15=1 .. 15=0  
7452			;  
7452			; handshake line  
7452			; 14=1.... read line 14=0  
7452			  
7452			  
7452			  
7452			  
7452			  
7452			; TODO hand shake clock for next column scan  
7452			; TODO detect each row  
7452			  
7452			  
7452			  
7452			  
7452			; reset 128  
7452			; clock 64  
7452			; ce 32  
7452			  
7452			  
7452			.cyclestart:  
7452			  
7452			; reset counter  
7452 3e 80		ld a, 128  
7454 d3 c1		out (portbdata),a  
7456			  
7456			; loop leds  
7456 06 0a		ld b,10  
7458			  
7458			.cycle1:  
7458 c5			push bc  
7459 3e 00		ld a, 0  
745b d3 c1		out (portbdata),a  
745d cd e1 0c		call delay250ms  
7460			  
7460 3e 40		ld a, 64  
7462 d3 c1		out (portbdata),a  
7464 cd e1 0c		call delay250ms  
7467			  
7467 3e 00		ld a, 0  
7469 d3 c1		out (portbdata),a  
746b cd e1 0c		call delay250ms  
746e			  
746e c1			pop bc  
746f 10 e7		djnz .cycle1  
7471			  
7471			  
7471 18 df		jr .cyclestart  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			; map matrix key held to char on face of key  
7473			  
7473			;.mtocold:  
7473			;  
7473			;  
7473			;; reset counter  
7473			;ld a, 128  
7473			;out (portbdata),a  
7473			;  
7473			;  
7473			;; scan keyboard row 1  
7473			;ld a, 0  
7473			;out (portbdata),a  
7473			;;ld a, 64  
7473			;;out (portbdata),a  
7473			;  
7473			;  
7473			;	ld a, 128  
7473			;	ld hl, keyscan_table  
7473			;	call .rowscan  
7473			;  
7473			;;ld a, 0  
7473			;;out (portbdata),a  
7473			;ld a, 64  
7473			;out (portbdata),a  
7473			;  
7473			;	ld a, 64  
7473			;	ld hl, keyscan_table+key_cols  
7473			;	call .rowscan  
7473			;  
7473			;ld a, 0  
7473			;out (portbdata),a  
7473			;;ld a, 64  
7473			;;out (portbdata),a  
7473			;	ld a, 32  
7473			;	ld hl, keyscan_table+(key_cols*2)  
7473			;	call .rowscan  
7473			;  
7473			;  
7473			;;ld a, 0  
7473			;;out (portbdata),a  
7473			;ld a, 64  
7473			;out (portbdata),a  
7473			;  
7473			;	ld a, 16  
7473			;	ld hl, keyscan_table+(key_cols*3)  
7473			;	call .rowscan  
7473			;  
7473			;  
7473			;	; flag if key D is held down and remove from reporting  
7473			;	ld bc, .key_map_fd    
7473			;	ld hl, keyscan_table  
7473			;	ld de, key_fd  
7473			;	call .key_shift_hold  
7473			;	cp 255  
7473			;	jr z, .cinmap  
7473			;	; flag if key C is held down and remove from reporting  
7473			;	ld bc, .key_map_fc    
7473			;	ld hl, keyscan_table+key_cols  
7473			;	ld de, key_fc  
7473			;	call .key_shift_hold  
7473			;	cp 255  
7473			;	jr z, .cinmap  
7473			;	; flag if key B is held down and remove from reporting  
7473			;	ld bc, .key_map_fb    
7473			;	ld hl, keyscan_table+(key_cols*2)  
7473			;	ld de, key_fb  
7473			;	call .key_shift_hold  
7473			;	cp 255  
7473			;	jr z, .cinmap  
7473			;	; flag if key A is held down and remove from reporting  
7473			;	ld bc, .key_map_fa    
7473			;	ld hl, keyscan_table+(key_cols*3)  
7473			;	ld de, key_fa  
7473			;	call .key_shift_hold  
7473			;	cp 255  
7473			;	jr z, .cinmap  
7473			;  
7473			;	ld de, .matrix_to_char  
7473			;  
7473			;  
7473			;.cinmap:   
7473			;	if DEBUG_KEY  
7473			;            LD   A, kLCD_Line4  
7473			;            CALL fLCD_Pos       ;Position cursor to location in A  
7473			;		push de  
7473			;            LD   DE, keyscan_table  
7473			;            CALL fLCD_Str       ;Display string pointed to by DE  
7473			;		pop de  
7473			;	endif  
7473			  
7473				; scan key matrix table for any held key  
7473			  
7473				; de holds either the default matrix or one selected above  
7473			  
7473			;	ld hl, keyscan_table  
7473			;	ld b,key_cols*key_rows  
7473			;  
7473			;.cin1:	ld a,(hl)  
7473			;	cp '#'  
7473			;	jr z, .cinhit  
7473			;	inc hl  
7473			;	inc de  
7473			;	dec b  
7473			;	jr nz, .cin1  
7473			;	; no key found held  
7473			;	ld a,0  
7473			;	ret  
7473			;.cinhit: push de  
7473			;	pop hl  
7473			;	ld a,(hl)  
7473			;	ret  
7473			  
7473			; flag a control key is held   
7473			; hl is key pin, de is flag indicator  
7473			  
7473			;.key_shift_hold:  
7473			;	push bc  
7473			;	ld a, 1  
7473			;	ld (cursor_shape),a  
7473			;	ld b, 0  
7473			;	ld a, (hl)  
7473			;	cp '.'  
7473			;	jr z, .key_shift1  
7473			;	ld b, 255  
7473			;	ld a, '+'    ; hide key from later scans  
7473			;	ld (hl),a  
7473			;	ld a, 2  
7473			;	ld (cursor_shape),a  
7473			;.key_shift1:  
7473			;	; write flag indicator  
7473			;	ld a,b  
7473			;	ld (de),a  
7473			;  
7473			;	pop de    ; de now holds the key map ptr  
7473			;	ret  
7473			  
7473				  
7473				  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			  
7473			;	push hl  
7473			;	push de  
7473			;	push bc  
7473			;	call keyscan  
7473			;	; map key matrix to ascii value of key face  
7473			;  
7473			;	ld hl, key_face_map  
7473			;	ld de, keyscan_table  
7473			;  
7473			;	; get how many keys to look at  
7473			;	ld b, keyscan_table_len  
7473			;	  
7473			;  
7473			;	; at this stage fall out on first key hit  
7473			;	; TODO handle multiple key press  
7473			;  
7473			;map1:	ld a,(hl)  
7473			;	cp '#'  
7473			;	jr z, keyhit  
7473			;	inc hl  
7473			;	inc de  
7473			;	dec b  
7473			;	jr nz, map1  
7473			;nohit:	ld a, 0  
7473			;	jr keydone  
7473			;keyhit: push de  
7473			;	pop hl  
7473			;	ld a,(hl)  
7473			;keydone:  
7473			;	push bc  
7473			;	push de  
7473			; 	push hl  
7473			;	ret   
7473			;  
7473			  
7473			  
7473			  
7473			  
7473			; scan physical key matrix  
7473			  
7473			  
7473			;keyscan:  
7473			;  
7473			;; for each key_row use keyscanr bit mask for out  
7473			;; then read in for keyscanc bitmask  
7473			;; save result of row scan to keyscantable  
7473			;  
7473			;; scan keyboard row 1  
7473			;  
7473			;	ld b, key_rows  
7473			;	ld hl, key_scanr  
7473			;	ld de, keyscan_table  
7473			;  
7473			;rowloop:  
7473			;  
7473			;	ld a,(hl)		; out bit mask to energise keyboard row  
7473			;	call rowscan  
7473			;	inc hl  
7473			;	dec b  
7473			;	jr nz, rowloop  
7473			;  
7473			;	ret  
7473			;  
7473			;  
7473			;; pass a out bitmask, b row number  
7473			;arowscan:   
7473			;	push bc  
7473			;  
7473			;	ld d, b  
7473			;  
7473			;	; calculate buffer location for this row  
7473			;  
7473			;	ld hl, keyscan_table	  
7473			;kbufr:  ld e, key_cols  
7473			;kbufc:	inc hl  
7473			;	dec e  
7473			;	jr nz, kbufc  
7473			;	dec d  
7473			;	jr nz, kbufr  
7473			;  
7473			;	; energise row and read columns  
7473			;  
7473			;	out (portbdata),a  
7473			;	in a,(portbdata)  
7473			;	ld c,a  
7473			;  
7473			;  
7473			;	; save buffer loc  
7473			;  
7473			;	ld (keybufptr), hl  
7473			;  
7473			;	ld hl, key_scanc  
7473			;	ld d, key_cols  
7473			;  
7473			;	; for each column check each bit mask  
7473			;  
7473			;colloop:  
7473			;	  
7473			;  
7473			;	; reset flags for the row   
7473			;  
7473			;	ld b,'.'  
7473			;	and (hl)  
7473			;	jr z, maskskip  
7473			;	ld b,'#'  
7473			;maskskip:  
7473			;	; save  key state  
7473			;	push hl  
7473			;	ld hl, (keybufptr)  
7473			;	ld (hl), b  
7473			;	inc hl  
7473			;	ld (keybufptr), hl  
7473			;  
7473			;	; move to next bit mask  
7473			;	pop hl  
7473			;	inc hl  
7473			;  
7473			;	dec d  
7473			;	jr nz, colloop  
7473			;  
7473			;	ret  
7473			;  
7473			;  
7473			;;  
7473			; lcd functions  
7473			;  
7473			;  
7473			  
7473			;if DEBUG_KEY_MATRIX  
7473			  
7473			; test function to display hardware view of matrix state  
7473			  
7473			matrixold:  
7473			  
7473			  
7473			  
7473			; reset counter  
7473 3e 80		ld a, 128  
7475 d3 c1		out (portbdata),a  
7477			; scan keyboard row 1  
7477 3e 00		ld a, 0  
7479 d3 c1		out (portbdata),a  
747b			;ld a, 64  
747b			;out (portbdata),a  
747b 3e 80			ld a, 128  
747d 21 30 fe			ld hl, keyscan_table_row1  
7480 cd d9 74			call .rowscan  
7483			  
7483			;ld a, 0  
7483			;out (portbdata),a  
7483 3e 40		ld a, 64  
7485 d3 c1		out (portbdata),a  
7487 3e 40			ld a, 64  
7489 21 25 fe			ld hl, keyscan_table_row2  
748c cd d9 74			call .rowscan  
748f			  
748f 3e 00		ld a, 0  
7491 d3 c1		out (portbdata),a  
7493			;ld a, 64  
7493			;out (portbdata),a  
7493 3e 20			ld a, 32  
7495 21 1a fe			ld hl, keyscan_table_row3  
7498 cd d9 74			call .rowscan  
749b			  
749b			;ld a, 0  
749b			;out (portbdata),a  
749b 3e 40		ld a, 64  
749d d3 c1		out (portbdata),a  
749f 3e 10			ld a, 16  
74a1 21 0f fe			ld hl, keyscan_table_row4  
74a4 cd d9 74			call .rowscan  
74a7			  
74a7			; Display text on first line  
74a7 3e 00		            LD   A, kLCD_Line1  
74a9 cd e1 70		            CALL fLCD_Pos       ;Position cursor to location in A  
74ac 11 30 fe		            LD   DE, keyscan_table_row1  
74af			            ;LD   DE, MsgHello  
74af cd 03 71		            CALL fLCD_Str       ;Display string pointed to by DE  
74b2			  
74b2			; Display text on second line  
74b2 3e 28		            LD   A, kLCD_Line2  
74b4 cd e1 70		            CALL fLCD_Pos       ;Position cursor to location in A  
74b7 11 25 fe		            LD   DE, keyscan_table_row2  
74ba cd 03 71		            CALL fLCD_Str       ;Display string pointed to by DE  
74bd 3e 50		            LD   A, kLCD_Line3  
74bf cd e1 70		            CALL fLCD_Pos       ;Position cursor to location in A  
74c2 11 1a fe		            LD   DE, keyscan_table_row3  
74c5 cd 03 71		            CALL fLCD_Str       ;Display string pointed to by DE  
74c8 3e 78		            LD   A, kLCD_Line4  
74ca cd e1 70		            CALL fLCD_Pos       ;Position cursor to location in A  
74cd 11 0f fe		            LD   DE, keyscan_table_row4  
74d0 cd 03 71		            CALL fLCD_Str       ;Display string pointed to by DE  
74d3			  
74d3 cd e1 0c			call delay250ms  
74d6 c3 c4 73			jp matrix  
74d9			  
74d9			; pass de as row display flags  
74d9			.rowscan:   
74d9			;	out (portbdata),a  
74d9 db c1			in a,(portbdata)  
74db 4f				ld c,a  
74dc				; reset flags for the row   
74dc 06 7e			ld b,KEY_MATRIX_NO_PRESS  
74de e6 01			and 1  
74e0 28 02			jr z, .p1on  
74e2 06 23			ld b,'#'  
74e4			.p1on:  
74e4 70				ld (hl), b  
74e5 23				inc hl  
74e6			  
74e6 06 7e			ld b,KEY_MATRIX_NO_PRESS  
74e8 79				ld a,c  
74e9 e6 02			and 2  
74eb			;	bit 0,a  
74eb 28 02			jr z, .p2on  
74ed 06 23			ld b,'#'  
74ef			.p2on:  
74ef 70				ld (hl), b  
74f0 23				inc hl  
74f1			;  
74f1 06 7e			ld b,KEY_MATRIX_NO_PRESS  
74f3 79				ld a,c  
74f4 e6 04			and 4  
74f6			;;	bit 0,a  
74f6 28 02			jr z, .p3on  
74f8 06 23			ld b,'#'  
74fa			.p3on:  
74fa 70				ld (hl), b  
74fb 23				inc hl  
74fc			;;  
74fc 06 7e			ld b,KEY_MATRIX_NO_PRESS  
74fe			;;	bit 0,a  
74fe 79				ld a,c  
74ff e6 08			and 8  
7501 28 02			jr z, .p4on  
7503 06 23			ld b,'#'  
7505			.p4on:  
7505 70				ld (hl), b  
7506 23				inc hl  
7507			  
7507 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7509			;;	bit 0,a  
7509 79				ld a,c  
750a e6 10			and 16  
750c 28 02			jr z, .p5on  
750e 06 23			ld b,'#'  
7510			.p5on:  
7510 70				ld (hl), b  
7511 23				inc hl  
7512			; zero term  
7512 06 00			ld b,0  
7514 70				ld (hl), b  
7515			  
7515 c9			.rscandone: ret  
7516			  
7516			;addatohl:  
7516			;  
7516			 ;add   a, l    ; A = A+L  
7516			  ;  ld    l, a    ; L = A+L  
7516			   ; adc   a, h    ; A = A+L+H+carry  
7516			   ; sub   l       ; A = H+carry  
7516			   ; ld    h, a    ; H = H+carry  
7516			  
7516			;ret  
7516			; eof  
# End of file firmware_key_5x10.asm
7516			;include "firmware_key_4x10.asm" 
7516			 
7516			heap_size:    equ heap_end - heap_start 
7516			;eof 
# End of file os_mega.asm
7516
