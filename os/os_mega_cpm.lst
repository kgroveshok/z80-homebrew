# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 5a 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			if BASE_KEV = 1  
011c			 
011c				; need to be at $66 for nmi support 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255 
011c				jp nmi 
011c			endif 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 0       
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 1  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c			;	call break_point_state  
011c			; now use the break point debug vector  
011c				call debug_vector  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011c			  
011c			debug_mark: equ debug_vector - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_active-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			;os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_new_exec_ptr - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c			;	ld a, ' ' 
011c			;	ld (os_view_disable), a 
011c				call bp_on 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 10 ed				ld hl, display_fb1  
011f 22 cc eb				ld (display_fb_active), hl  
0122			  
0122 cd ba 0b				call clear_display  
0125			  
0125 21 ce eb				ld hl, display_fb2  
0128 22 cc eb				ld (display_fb_active), hl  
012b			  
012b cd ba 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b1 ed				ld hl, display_fb0  
0131 22 cc eb				ld (display_fb_active), hl  
0134			  
0134 cd ba 0b				call clear_display  
0137			  
0137			  
0137 cd 7f 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd 6d 65			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 8a 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd dd 0b			call update_display  
0146 cd f2 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd bf 0b			call fill_display  
014e cd dd 0b			call update_display  
0151 cd f2 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd bf 0b			call fill_display  
0159 cd dd 0b			call update_display  
015c cd f2 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd bf 0b			call fill_display  
0164 cd dd 0b			call update_display  
0167 cd f2 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 b8 17			ld de, prom_bootmsg  
016f cd cd 0b			call str_at_display  
0172 cd dd 0b			call update_display  
0175			  
0175			  
0175 cd f2 0a			call delay1s  
0178 cd f2 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 cd 17			ld de, prom_bootmsg1  
0180 cd cd 0b			call str_at_display  
0183 cd dd 0b			call update_display  
0186 cd f2 0a			call delay1s  
0189 cd f2 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 6b ee		ld (debug_mark),a  
0191 32 6c ee		ld (debug_mark+1),a  
0194 32 6d ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 6e ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 73 ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 6b ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 6c ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 6d ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd 6f ee			call debug_vector  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 7a ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 6b ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 6c ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 6d ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd 6f ee			call debug_vector  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 7a ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 6b ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 6c ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 6d ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd 6f ee			call debug_vector  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd 10 0e				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 73 ea				ld hl, (store_tmp1) 
0210 11 7d ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 6b ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 6c ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 6d ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd 6f ee			call debug_vector  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 7d 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 6b ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 6c ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 6d ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd 6f ee			call debug_vector  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 6b ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 6c ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 6d ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd 6f ee			call debug_vector  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 6b ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 6c ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 6d ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd 6f ee			call debug_vector  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 6b ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 6c ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 6d ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd 6f ee			call debug_vector  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd 10 0e			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 7a ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 6b ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 6c ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 6d ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd 6f ee			call debug_vector  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 6b ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 6c ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 6d ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd 6f ee			call debug_vector  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 7a ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 6b ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 6c ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 6d ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 7a ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd 6f ee			call debug_vector  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 7b ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 6b ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 6c ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 6d ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd 6f ee			call debug_vector  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 6b ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 6c ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 6d ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd 6f ee			call debug_vector  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd b5 0a			call storage_clear_page 
039b			 
039b 21 7a ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 7b ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 7d ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 86 ea			ld hl, store_page+3+9 
03b5 3a 5f ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 7a ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 6b ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 6c ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 6d ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd 6f ee			call debug_vector  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 6b ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 6c ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 6d ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd 6f ee			call debug_vector  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d7 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d7 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd e7 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d7 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d7 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd e7 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 6b ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 6c ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 6d ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd 6f ee			call debug_vector  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 7d ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 6b ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 6c ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 6d ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd 6f ee			call debug_vector  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 7a ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 6b ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 6c ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 6d ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd 6f ee			call debug_vector  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 6b ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 6c ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 6d ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd 6f ee			call debug_vector  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd 10 0e			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 7a ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd 10 0e			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 6b ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 6c ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 6d ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd 6f ee			call debug_vector  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 7a ea			ld a, (store_page)	; get file id 
0510 32 6e ea			ld (store_tmpid), a 
0513			 
0513 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0516 32 6d ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 7a ea			ld (store_page), a 
051f 32 7b ea			ld (store_page+1),a 
0522 11 7a ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 6b ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 6c ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 6d ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd 6f ee			call debug_vector  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 6d ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 6e ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 6b ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 6c ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 6d ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd 6f ee			call debug_vector  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd 10 0e			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 7a ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 7a ea			ld (store_page), a 
0582 32 7b ea			ld (store_page+1),a 
0585 11 7a ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 6b ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 6c ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 6d ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd 6f ee			call debug_vector  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 6b ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 6c ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 6d ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd 6f ee			call debug_vector  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd 05 0e				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd e7 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd 05 0e				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd e7 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 6b ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 6c ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 6d ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd 6f ee			call debug_vector  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 6b ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 6c ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 6d ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd 6f ee			call debug_vector  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd e7 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd e7 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 6b ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 6c ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 6d ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd 6f ee			call debug_vector  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 7a ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 7a ea			ld (store_page),a 
06a3				 
06a3 32 6e ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 7a ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 6b ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 6c ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 6d ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd 6f ee			call debug_vector  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 7a ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 6b ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 6c ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 6d ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd 6f ee			call debug_vector  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 6b ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 6c ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 6d ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd 6f ee			call debug_vector  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 65 ea			ld (store_tmppageid), hl 
0715				 
0715 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 7a ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 7b ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 6b ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 6c ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 6d ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd 6f ee			call debug_vector  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 50 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 6b ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 6c ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 6d ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd 6f ee			call debug_vector  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 6b ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 6c ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 6d ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd 6f ee			call debug_vector  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 65 ea			ld hl,(store_tmppageid) 
078b 11 7a ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 6b ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 6c ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 6d ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd 6f ee			call debug_vector  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 6e ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 6b ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 6c ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 6d ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd 6f ee			call debug_vector  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 6b ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 6c ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 6d ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd 6f ee			call debug_vector  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 6b ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 6c ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 6d ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd 6f ee			call debug_vector  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd 10 0e			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; save current address for use by higher level words etc 
081f			 
081f 22 6b ea			ld (store_openaddr),hl 
0822			 
0822			 
0822				; hl contains page number to load 
0822 d1				pop de   ; get storage 
0823 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0827 d5				push de 
0828				if DEBUG_STORESE 
0828					DMARK "srg" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 6b ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 6c ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 6d ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "srg"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd 6f ee			call debug_vector  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844 cd 79 02			call storage_read_block 
0847			 
0847				; if this a continuation read??? 
0847			 
0847 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084a			 
084a 3e 3f			ld a, STORE_BLOCK_PHY-1 
084c cd e7 0d			call addatohl 
084f 7e				ld a,(hl) 
0850 fe 00			cp 0 
0852 28 02			jr z, .markiscont 
0854 3e ff			ld a, 255 
0856			 
0856			.markiscont: 
0856 32 6d ea			ld (store_readcont), a 
0859			 
0859				if DEBUG_STORESE 
0859					DMARK "srC" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 6b ee			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 6c ee			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 6d ee			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "srC"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd 6f ee			call debug_vector  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875				; only short reads enabled 
0875			 
0875 3a 75 ea			ld a, (store_longread) 
0878 fe 00			cp 0 
087a ca 47 09			jp z, .readdone 
087d			 
087d			; TODO if block has no zeros then need to read next block  
087d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087d			; check last byte of physical block. 
087d			; if not zero then the next block needs to be loaded 
087d			 
087d			 
087d 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0880			 
0880 3e 3f			ld a, STORE_BLOCK_PHY-1 
0882 cd e7 0d			call addatohl 
0885				;dec hl 
0885 7e				ld a,(hl) 
0886				if DEBUG_STORESE 
0886					DMARK "sr?" 
0886 f5				push af  
0887 3a 9b 08			ld a, (.dmark)  
088a 32 6b ee			ld (debug_mark),a  
088d 3a 9c 08			ld a, (.dmark+1)  
0890 32 6c ee			ld (debug_mark+1),a  
0893 3a 9d 08			ld a, (.dmark+2)  
0896 32 6d ee			ld (debug_mark+2),a  
0899 18 03			jr .pastdmark  
089b ..			.dmark: db "sr?"  
089e f1			.pastdmark: pop af  
089f			endm  
# End of macro DMARK
089f					CALLMONITOR 
089f cd 6f ee			call debug_vector  
08a2				endm  
# End of macro CALLMONITOR
08a2				endif 
08a2 fe 00			cp 0 
08a4 ca 47 09			jp z, .readdone 
08a7			 
08a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a7			 
08a7 23				inc hl 
08a8			 
08a8 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ab			 
08ab ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08af			 
08af eb				ex de, hl 
08b0			 
08b0				; next ext 
08b0			 
08b0 23				inc hl 
08b1 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b4			 
08b4				if DEBUG_STORESE 
08b4					DMARK "sF2" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 6b ee			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 6c ee			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 6d ee			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "sF2"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd 6f ee			call debug_vector  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0			 
08d0				; get and load block 
08d0			 
08d0 cd ac 05			call storage_findnextid 
08d3			 
08d3				if DEBUG_STORESE 
08d3					DMARK "sf2" 
08d3 f5				push af  
08d4 3a e8 08			ld a, (.dmark)  
08d7 32 6b ee			ld (debug_mark),a  
08da 3a e9 08			ld a, (.dmark+1)  
08dd 32 6c ee			ld (debug_mark+1),a  
08e0 3a ea 08			ld a, (.dmark+2)  
08e3 32 6d ee			ld (debug_mark+2),a  
08e6 18 03			jr .pastdmark  
08e8 ..			.dmark: db "sf2"  
08eb f1			.pastdmark: pop af  
08ec			endm  
# End of macro DMARK
08ec					CALLMONITOR 
08ec cd 6f ee			call debug_vector  
08ef				endm  
# End of macro CALLMONITOR
08ef				endif 
08ef cd 10 0e			call ishlzero 
08f2			;	ld a, l 
08f2			;	add h 
08f2			;	cp 0 
08f2 ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f5				 
08f5				; save current address for use by higher level words etc 
08f5			 
08f5 22 6b ea			ld (store_openaddr),hl 
08f8			 
08f8 cd 79 02			call storage_read_block 
08fb			 
08fb				; on a continuation block, we now have the file id and ext in the middle of the block 
08fb				; we need to pull everything back  
08fb			 
08fb ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08ff 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0902 23				inc hl 
0903 23				inc hl     ; skip id and ext 
0904 01 40 00			ld bc, STORE_BLOCK_PHY 
0907				if DEBUG_STORESE 
0907					DMARK "SR<" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 6b ee			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 6c ee			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 6d ee			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "SR<"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd 6f ee			call debug_vector  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923 ed b0			ldir     ; copy data 
0925			 
0925				; move the pointer back and pretend we have a full buffer for next recheck 
0925			 
0925 1b				dec de 
0926 1b				dec de 
0927			 
0927			; TODO do pop below now short circuit loop????? 
0927 c1				pop bc     ; get rid of spare de on stack 
0928				if DEBUG_STORESE 
0928					DMARK "SR>" 
0928 f5				push af  
0929 3a 3d 09			ld a, (.dmark)  
092c 32 6b ee			ld (debug_mark),a  
092f 3a 3e 09			ld a, (.dmark+1)  
0932 32 6c ee			ld (debug_mark+1),a  
0935 3a 3f 09			ld a, (.dmark+2)  
0938 32 6d ee			ld (debug_mark+2),a  
093b 18 03			jr .pastdmark  
093d ..			.dmark: db "SR>"  
0940 f1			.pastdmark: pop af  
0941			endm  
# End of macro DMARK
0941					CALLMONITOR 
0941 cd 6f ee			call debug_vector  
0944				endm  
# End of macro CALLMONITOR
0944				endif 
0944 c3 d5 07			jp .srext 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			.readdone:		 
0947 e1				pop hl 		 ; return start of data to show as not EOF 
0948 23				inc hl   ; past file id 
0949 23				inc hl   ; past ext 
094a				if DEBUG_STORESE 
094a					DMARK "SRe" 
094a f5				push af  
094b 3a 5f 09			ld a, (.dmark)  
094e 32 6b ee			ld (debug_mark),a  
0951 3a 60 09			ld a, (.dmark+1)  
0954 32 6c ee			ld (debug_mark+1),a  
0957 3a 61 09			ld a, (.dmark+2)  
095a 32 6d ee			ld (debug_mark+2),a  
095d 18 03			jr .pastdmark  
095f ..			.dmark: db "SRe"  
0962 f1			.pastdmark: pop af  
0963			endm  
# End of macro DMARK
0963					CALLMONITOR 
0963 cd 6f ee			call debug_vector  
0966				endm  
# End of macro CALLMONITOR
0966				endif 
0966 c9					ret 
0967			 
0967			 
0967			 
0967			; 
0967			; Append File 
0967			; 
0967			; hl - file id to locate 
0967			; de - pointer to (multi block) string to write 
0967			 
0967			.sa_notfound: 
0967 d1				pop de 
0968 c9				ret 
0969			 
0969			 
0969			storage_append: 
0969				; hl -  file id to append to 
0969				; de - string to append 
0969			 
0969 d5				push de 
096a				 
096a				if DEBUG_STORESE 
096a					DMARK "AP1" 
096a f5				push af  
096b 3a 7f 09			ld a, (.dmark)  
096e 32 6b ee			ld (debug_mark),a  
0971 3a 80 09			ld a, (.dmark+1)  
0974 32 6c ee			ld (debug_mark+1),a  
0977 3a 81 09			ld a, (.dmark+2)  
097a 32 6d ee			ld (debug_mark+2),a  
097d 18 03			jr .pastdmark  
097f ..			.dmark: db "AP1"  
0982 f1			.pastdmark: pop af  
0983			endm  
# End of macro DMARK
0983					CALLMONITOR 
0983 cd 6f ee			call debug_vector  
0986				endm  
# End of macro CALLMONITOR
0986				endif 
0986			 
0986 7d				ld a, l 
0987 32 6e ea			ld (store_tmpid), a 
098a			 
098a				; get file header  
098a			 
098a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098c 3a 6e ea			ld a, (store_tmpid) 
098f 5f				ld e, a 
0990			 
0990 21 40 00				ld hl, STORE_BLOCK_PHY 
0993 cd ac 05				call storage_findnextid 
0996			 
0996 cd 10 0e			call ishlzero 
0999 28 cc			jr z, .sa_notfound 
099b			 
099b 22 65 ea			ld (store_tmppageid), hl 
099e			 
099e				; TODO handle file id not found 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "AP2" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 6b ee			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 6c ee			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 6d ee			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP2"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd 6f ee			call debug_vector  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba				; update file extent count 
09ba			 
09ba 11 7a ea			ld de, store_page 
09bd			 
09bd cd 79 02			call storage_read_block 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP3" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 6b ee			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 6c ee			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 6d ee			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP3"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd 6f ee			call debug_vector  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			;	ld (store_tmppageid), hl 
09dc			 
09dc 3a 7c ea			ld a, (store_page+2) 
09df 3c				inc a 
09e0 32 7c ea			ld (store_page+2), a 
09e3 32 6d ea			ld (store_tmpext), a 
09e6				 
09e6				if DEBUG_STORESE 
09e6					DMARK "AP3" 
09e6 f5				push af  
09e7 3a fb 09			ld a, (.dmark)  
09ea 32 6b ee			ld (debug_mark),a  
09ed 3a fc 09			ld a, (.dmark+1)  
09f0 32 6c ee			ld (debug_mark+1),a  
09f3 3a fd 09			ld a, (.dmark+2)  
09f6 32 6d ee			ld (debug_mark+2),a  
09f9 18 03			jr .pastdmark  
09fb ..			.dmark: db "AP3"  
09fe f1			.pastdmark: pop af  
09ff			endm  
# End of macro DMARK
09ff					CALLMONITOR 
09ff cd 6f ee			call debug_vector  
0a02				endm  
# End of macro CALLMONITOR
0a02				endif 
0a02 2a 65 ea			ld hl, (store_tmppageid) 
0a05 11 7a ea			ld de, store_page 
0a08 cd de 02			call storage_write_block 
0a0b			 
0a0b				; find free block 
0a0b			 
0a0b 11 00 00			ld de, 0			 ; file extent to locate 
0a0e			 
0a0e 21 40 00				ld hl, STORE_BLOCK_PHY 
0a11 cd ac 05				call storage_findnextid 
0a14 cd 10 0e			call ishlzero 
0a17 ca 67 09			jp z, .sa_notfound 
0a1a			 
0a1a					; TODO handle no space left 
0a1a					 
0a1a 22 65 ea				ld (store_tmppageid), hl 
0a1d			 
0a1d				if DEBUG_STORESE 
0a1d					DMARK "AP4" 
0a1d f5				push af  
0a1e 3a 32 0a			ld a, (.dmark)  
0a21 32 6b ee			ld (debug_mark),a  
0a24 3a 33 0a			ld a, (.dmark+1)  
0a27 32 6c ee			ld (debug_mark+1),a  
0a2a 3a 34 0a			ld a, (.dmark+2)  
0a2d 32 6d ee			ld (debug_mark+2),a  
0a30 18 03			jr .pastdmark  
0a32 ..			.dmark: db "AP4"  
0a35 f1			.pastdmark: pop af  
0a36			endm  
# End of macro DMARK
0a36					CALLMONITOR 
0a36 cd 6f ee			call debug_vector  
0a39				endm  
# End of macro CALLMONITOR
0a39				endif 
0a39					; init the buffer with zeros so we can id if the buffer is full or not 
0a39			 
0a39 e5					push hl 
0a3a c5					push bc 
0a3b			 
0a3b 21 7a ea				ld hl, store_page 
0a3e 06 40				ld b, STORE_BLOCK_PHY 
0a40 3e 00				ld a, 0 
0a42 77			.zeroblock:	ld (hl), a 
0a43 23					inc hl 
0a44 10 fc				djnz .zeroblock 
0a46			 
0a46 c1					pop bc 
0a47 e1					pop hl 
0a48			 
0a48					; construct block 
0a48			 
0a48 3a 6e ea				ld a, (store_tmpid) 
0a4b 32 7a ea				ld (store_page), a   ; file id 
0a4e 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a51 32 7b ea				ld (store_page+1), a 
0a54			 
0a54 e1					pop hl    ; get string to write 
0a55 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a57 11 7c ea				ld de, store_page+2 
0a5a			 
0a5a				if DEBUG_STORESE 
0a5a					DMARK "AP5" 
0a5a f5				push af  
0a5b 3a 6f 0a			ld a, (.dmark)  
0a5e 32 6b ee			ld (debug_mark),a  
0a61 3a 70 0a			ld a, (.dmark+1)  
0a64 32 6c ee			ld (debug_mark+1),a  
0a67 3a 71 0a			ld a, (.dmark+2)  
0a6a 32 6d ee			ld (debug_mark+2),a  
0a6d 18 03			jr .pastdmark  
0a6f ..			.dmark: db "AP5"  
0a72 f1			.pastdmark: pop af  
0a73			endm  
# End of macro DMARK
0a73					CALLMONITOR 
0a73 cd 6f ee			call debug_vector  
0a76				endm  
# End of macro CALLMONITOR
0a76				endif 
0a76			 
0a76			 
0a76			 
0a76					; fill buffer with data until end of string or full block 
0a76			 
0a76 7e			.appd:		ld a, (hl) 
0a77 12					ld (de), a 
0a78 fe 00				cp 0 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f6				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 65 ea			ld hl, (store_tmppageid) 
0a85 11 7a ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 6b ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 6c ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 6d ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd 6f ee			call debug_vector  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd de 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9 fe 00				cp 0		 ; no, string was fully written 
0aab c8					ret z 
0aac			 
0aac					; setup vars for next cycle 
0aac			 
0aac 3a 6e ea				ld a, (store_tmpid) 
0aaf 6f					ld l, a 
0ab0 26 00				ld h, 0 
0ab2			 
0ab2 c3 69 09			 	jp storage_append	 ; yes, need to write out some more 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			if DEBUG_STORECF 
0ab5			storageput:	 
0ab5					ret 
0ab5			storageread: 
0ab5					ld hl, store_page 
0ab5					ld b, 200 
0ab5					ld a,0 
0ab5			.src:		ld (hl),a 
0ab5					inc hl 
0ab5					djnz .src 
0ab5					 
0ab5			 
0ab5					ld de, 0 
0ab5					ld bc, 1 
0ab5					ld hl, store_page 
0ab5					call cfRead 
0ab5			 
0ab5				call cfGetError 
0ab5				ld hl,scratch 
0ab5				call hexout 
0ab5				ld hl, scratch+2 
0ab5				ld a, 0 
0ab5				ld (hl),a 
0ab5				ld de, scratch 
0ab5				ld a,display_row_1 
0ab5				call str_at_display 
0ab5				call update_display 
0ab5			 
0ab5					ld hl, store_page 
0ab5					ld (os_cur_ptr),hl 
0ab5			 
0ab5					ret 
0ab5			endif 
0ab5			 
0ab5			 
0ab5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab5			 
0ab5			storage_clear_page: 
0ab5 e5				push hl 
0ab6 d5				push de 
0ab7 c5				push bc 
0ab8 21 7a ea			ld hl, store_page 
0abb 3e 00			ld a, 0 
0abd 77				ld (hl), a 
0abe			 
0abe 11 7b ea			ld de, store_page+1 
0ac1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac4			 
0ac4 ed b0			ldir 
0ac6				 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9 c9				ret 
0aca			 
0aca			; eof 
# End of file firmware_storage.asm
0aca			  
0aca			; support routines for above hardware abstraction layer  
0aca			  
0aca			include "firmware_general.asm"        ; general support functions  
0aca			 
0aca			; word look up 
0aca			 
0aca			; in 
0aca			; a is the index 
0aca			; hl is pointer start of array 
0aca			; 
0aca			; returns 
0aca			; hl to the word 
0aca			; 
0aca			 
0aca			table_lookup:  
0aca d5					push de 
0acb eb					ex de, hl 
0acc			 
0acc 6f					ld l, a 
0acd 26 00				ld h, 0 
0acf 29					add hl, hl 
0ad0 19					add hl, de 
0ad1 7e					ld a, (hl) 
0ad2 23					inc hl 
0ad3 66					ld h,(hl) 
0ad4 6f					ld l, a 
0ad5			 
0ad5 d1					pop de 
0ad6 c9					ret 
0ad7			 
0ad7			; Delay loops 
0ad7			 
0ad7			 
0ad7			 
0ad7			aDelayInMS: 
0ad7 c5				push bc 
0ad8 47				ld b,a 
0ad9			msdelay: 
0ad9 c5				push bc 
0ada				 
0ada			 
0ada 01 41 00			ld bc,041h 
0add cd f5 0a			call delayloop 
0ae0 c1				pop bc 
0ae1 05				dec b 
0ae2 20 f5			jr nz,msdelay 
0ae4			 
0ae4			;if CPU_CLOCK_8MHZ 
0ae4			;msdelay8: 
0ae4			;	push bc 
0ae4			;	 
0ae4			; 
0ae4			;	ld bc,041h 
0ae4			;	call delayloop 
0ae4			;	pop bc 
0ae4			;	dec b 
0ae4			;	jr nz,msdelay8 
0ae4			;endif 
0ae4			 
0ae4			 
0ae4 c1				pop bc 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			delay250ms: 
0ae6				;push de 
0ae6 01 00 40			ld bc, 04000h 
0ae9 c3 f5 0a			jp delayloop 
0aec			delay500ms: 
0aec				;push de 
0aec 01 00 80			ld bc, 08000h 
0aef c3 f5 0a			jp delayloop 
0af2			delay1s: 
0af2				;push bc 
0af2			   ; Clobbers A, d and e 
0af2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af5			delayloop: 
0af5 c5			    push bc 
0af6			 
0af6			if BASE_CPM 
0af6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af9			.cpmloop: 
0af9 c5				push bc 
0afa			 
0afa			endif 
0afa			 
0afa			 
0afa			 
0afa			delayloopi: 
0afa			;	push bc 
0afa			;.dl: 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe cb 47		    bit     0,a    	; 8 
0b00 e6 ff		    and     255  	; 7 
0b02 0b			    dec     bc      	; 6 
0b03 79			    ld      a,c     	; 4 
0b04 b0			    or      b     	; 4 
0b05 c2 fa 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b08			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b08				;pop de 
0b08			;pop bc 
0b08			 
0b08			if BASE_CPM 
0b08 c1				pop bc 
0b09				 
0b09 0b			    dec     bc      	; 6 
0b0a 79			    ld      a,c     	; 4 
0b0b b0			    or      b     	; 4 
0b0c c2 f9 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0f				 
0b0f			 
0b0f			endif 
0b0f			;if CPU_CLOCK_8MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f			 
0b0f			;if CPU_CLOCK_10MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f c1			    pop bc 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			 
0b11			; eof 
# End of file firmware_general.asm
0b11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b11			; display routines that use the physical hardware abstraction layer 
0b11			 
0b11			 
0b11			; Display an activity indicator 
0b11			; Each call returns the new char pointed to in hl 
0b11			 
0b11			active: 
0b11 3a c6 eb			ld a, (display_active) 
0b14 fe 06			cp 6 
0b16			 
0b16 20 02			jr nz, .sne 
0b18				; gone past the last one reset sequence 
0b18 3e ff			ld a, 255 
0b1a			 
0b1a			.sne:   
0b1a				; get the next char in seq 
0b1a 3c				inc a 
0b1b 32 c6 eb			ld (display_active), a 
0b1e			 
0b1e				; look up the string in the table 
0b1e 21 35 0b			ld hl, actseq 
0b21 cb 27			sla a 
0b23 cd e7 0d			call addatohl 
0b26 cd 74 1f			call loadwordinhl 
0b29			 
0b29				; forth will write the to string when pushing so move from rom to ram 
0b29			 
0b29 11 c7 eb			ld de, display_active+1 
0b2c 01 02 00			ld bc, 2 
0b2f ed b0			ldir 
0b31			 
0b31 21 c7 eb			ld hl, display_active+1 
0b34 c9				ret 
0b35				 
0b35				 
0b35			 
0b35			 
0b35			;db "|/-\|-\" 
0b35			 
0b35			actseq: 
0b35			 
0b35 43 0b		dw spin0 
0b37 45 0b		dw spin1 
0b39 47 0b		dw spin2 
0b3b 49 0b		dw spin3 
0b3d 47 0b		dw spin2 
0b3f 45 0b		dw spin1 
0b41 43 0b		dw spin0 
0b43			 
0b43 .. 00		spin0: db " ", 0 
0b45 .. 00		spin1: db "-", 0 
0b47 .. 00		spin2: db "+", 0 
0b49 .. 00		spin3: db "#", 0 
0b4b			 
0b4b			 
0b4b			; information window 
0b4b			 
0b4b			; pass hl with 1st string to display 
0b4b			; pass de with 2nd string to display 
0b4b			 
0b4b			info_panel: 
0b4b e5				push hl 
0b4c			 
0b4c 2a cc eb			ld hl, (display_fb_active) 
0b4f e5				push hl    ; future de destination 
0b50 21 b1 ed				ld hl, display_fb0 
0b53 22 cc eb				ld (display_fb_active), hl 
0b56			 
0b56			;	call clear_display 
0b56			 
0b56				if BASE_CPM 
0b56 3e 2e			ld a, '.' 
0b58				else 
0b58				ld a, 165 
0b58				endif 
0b58 cd bf 0b			call fill_display 
0b5b			 
0b5b			 
0b5b 3e 55			ld a, display_row_3 + 5 
0b5d cd cd 0b			call str_at_display 
0b60			 
0b60 e1				pop hl 
0b61 d1				pop de 
0b62			 
0b62 e5				push hl 
0b63			 
0b63			 
0b63 3e 2d			ld a, display_row_2 + 5 
0b65 cd cd 0b			call str_at_display 
0b68			 
0b68			 
0b68 cd dd 0b			call update_display 
0b6b cd bd 1b			call next_page_prompt 
0b6e cd ba 0b			call clear_display 
0b71			 
0b71				 
0b71 21 10 ed				ld hl, display_fb1 
0b74 22 cc eb				ld (display_fb_active), hl 
0b77 cd dd 0b			call update_display 
0b7a			 
0b7a e1				pop hl 
0b7b			 
0b7b c9				ret 
0b7c			 
0b7c			 
0b7c			 
0b7c			 
0b7c			; TODO windowing? 
0b7c			 
0b7c			; TODO scroll line up 
0b7c			 
0b7c			scroll_up: 
0b7c			 
0b7c e5				push hl 
0b7d d5				push de 
0b7e c5				push bc 
0b7f			 
0b7f				; get frame buffer  
0b7f			 
0b7f 2a cc eb			ld hl, (display_fb_active) 
0b82 e5				push hl    ; future de destination 
0b83			 
0b83 11 28 00			ld  de, display_cols 
0b86 19				add hl, de 
0b87			 
0b87 d1				pop de 
0b88			 
0b88				;ex de, hl 
0b88 01 9f 00			ld bc, display_fb_len -1  
0b8b			;if DEBUG_FORTH_WORDS 
0b8b			;	DMARK "SCL" 
0b8b			;	CALLMONITOR 
0b8b			;endif	 
0b8b ed b0			ldir 
0b8d			 
0b8d				; wipe bottom row 
0b8d			 
0b8d			 
0b8d 2a cc eb			ld hl, (display_fb_active) 
0b90 11 a0 00			ld de, display_cols*display_rows 
0b93 19				add hl, de 
0b94 06 28			ld b, display_cols 
0b96 3e 20			ld a, ' ' 
0b98			.scwipe: 
0b98 77				ld (hl), a 
0b99 2b				dec hl 
0b9a 10 fc			djnz .scwipe 
0b9c			 
0b9c				;pop hl 
0b9c			 
0b9c c1				pop bc 
0b9d d1				pop de 
0b9e e1				pop hl 
0b9f			 
0b9f c9				ret 
0ba0			 
0ba0			 
0ba0			;scroll_upo: 
0ba0			;	ld de, display_row_1 
0ba0			 ;	ld hl, display_row_2 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_2 
0ba0			 ;	ld hl, display_row_3 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_3 
0ba0			 ;	ld hl, display_row_4 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			 
0ba0			; TODO clear row 4 
0ba0			 
0ba0			;	ret 
0ba0			 
0ba0				 
0ba0			scroll_down: 
0ba0			 
0ba0 e5				push hl 
0ba1 d5				push de 
0ba2 c5				push bc 
0ba3			 
0ba3				; get frame buffer  
0ba3			 
0ba3 2a cc eb			ld hl, (display_fb_active) 
0ba6			 
0ba6 11 9f 00			ld de, display_fb_len - 1 
0ba9 19				add hl, de 
0baa			 
0baa e5			push hl    ; future de destination 
0bab			 
0bab 11 28 00			ld  de, display_cols 
0bae ed 52			sbc hl, de 
0bb0			 
0bb0			 
0bb0 d1				pop de 
0bb1			 
0bb1			;	ex de, hl 
0bb1 01 9f 00			ld bc, display_fb_len -1  
0bb4			 
0bb4			 
0bb4				 
0bb4			 
0bb4 ed b0			ldir 
0bb6			 
0bb6				; wipe bottom row 
0bb6			 
0bb6			 
0bb6			;	ld hl, (display_fb_active) 
0bb6			;;	ld de, display_cols*display_rows 
0bb6			;;	add hl, de 
0bb6			;	ld b, display_cols 
0bb6			;	ld a, ' ' 
0bb6			;.scwiped: 
0bb6			;	ld (hl), a 
0bb6			;	dec hl 
0bb6			;	djnz .scwiped 
0bb6			 
0bb6				;pop hl 
0bb6			 
0bb6 c1				pop bc 
0bb7 d1				pop de 
0bb8 e1				pop hl 
0bb9			 
0bb9 c9				ret 
0bba			;scroll_down: 
0bba			;	ld de, display_row_4 
0bba			;	ld hl, display_row_3 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_3 
0bba			; 	ld hl, display_row_2 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_2 
0bba			;	ld hl, display_row_1 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;;; TODO clear row 1 
0bba			;	ret 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			; clear active frame buffer 
0bba			 
0bba			clear_display: 
0bba 3e 20			ld a, ' ' 
0bbc c3 bf 0b			jp fill_display 
0bbf			 
0bbf			; fill active frame buffer with a char in A 
0bbf			 
0bbf			fill_display: 
0bbf 06 a0			ld b,display_fb_len 
0bc1 2a cc eb			ld hl, (display_fb_active) 
0bc4 77			.fd1:	ld (hl),a 
0bc5 23				inc hl 
0bc6 10 fc			djnz .fd1 
0bc8 23				inc hl 
0bc9 3e 00			ld a,0 
0bcb 77				ld (hl),a 
0bcc			 
0bcc			 
0bcc c9				ret 
0bcd			; Write string (DE) at pos (A) to active frame buffer 
0bcd			 
0bcd 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bd0 06 00					ld b,0 
0bd2 4f					ld c,a 
0bd3 09					add hl,bc 
0bd4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd5 b7			            OR   A              ;Null terminator? 
0bd6 c8			            RET  Z              ;Yes, so finished 
0bd7 77					ld (hl),a 
0bd8 23				inc hl 
0bd9 13			            INC  DE             ;Point to next character 
0bda 18 f8		            JR   .sad1     ;Repeat 
0bdc c9					ret 
0bdd			 
0bdd			; using current frame buffer write to physical display 
0bdd			 
0bdd			update_display: 
0bdd e5				push hl 
0bde 2a cc eb			ld hl, (display_fb_active) 
0be1 cd bc 64			call write_display 
0be4 e1				pop hl 
0be5 c9				ret 
0be6			 
0be6			; TODO scrolling 
0be6			 
0be6			 
0be6			; move cursor right one char 
0be6			cursor_right: 
0be6			 
0be6				; TODO shift right 
0be6				; TODO if beyond max col 
0be6				; TODO       cursor_next_line 
0be6			 
0be6 c9				ret 
0be7			 
0be7			 
0be7			cursor_next_line: 
0be7				; TODO first char 
0be7				; TODO line down 
0be7				; TODO if past last row 
0be7				; TODO    scroll up 
0be7			 
0be7 c9				ret 
0be8			 
0be8			cursor_left: 
0be8				; TODO shift left 
0be8				; TODO if beyond left  
0be8				; TODO     cursor prev line 
0be8				 
0be8 c9				ret 
0be9			 
0be9			cursor_prev_line: 
0be9				; TODO last char 
0be9				; TODO line up 
0be9				; TODO if past first row 
0be9				; TODO   scroll down 
0be9			 
0be9 c9				ret 
0bea			 
0bea			 
0bea			cout: 
0bea				; A - char 
0bea c9				ret 
0beb			 
0beb			 
0beb			; Display a menu and allow item selection (optional toggle items) 
0beb			; 
0beb			; format: 
0beb			; hl pointer to word array with zero term for items 
0beb			; e.g.    db item1 
0beb			;         db .... 
0beb			;         db 0 
0beb			; 
0beb			; a = starting menu item  
0beb			; 
0beb			; de = pointer item toggle array   (todo) 
0beb			; 
0beb			; returns item selected in a 1-... 
0beb			; returns 0 if back button pressed 
0beb			; 
0beb			; NOTE: Uses system frame buffer to display 
0beb			; 
0beb			; LEFT, Q = go back 
0beb			; RIGHT, SPACE, CR = select 
0beb			; UP, A - Up 
0beb			; DOWN, Z - Down 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			menu: 
0beb			 
0beb					; keep array pointer 
0beb			 
0beb 22 73 ea				ld (store_tmp1), hl 
0bee 32 71 ea				ld (store_tmp2), a 
0bf1			 
0bf1					; check for key bounce 
0bf1			 
0bf1			if BASE_KEV 
0bf1			 
0bf1			.mbounce:	call cin 
0bf1					cp 0 
0bf1					jr nz, .mbounce 
0bf1			endif 
0bf1					; for ease use ex 
0bf1			 
0bf1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf1 21 b1 ed				ld hl, display_fb0 
0bf4 22 cc eb				ld (display_fb_active), hl 
0bf7			 
0bf7 cd ba 0b		.mloop:		call clear_display 
0bfa cd dd 0b				call update_display 
0bfd			 
0bfd					; draw selection id '>' at 1 
0bfd			 
0bfd					; init start of list display 
0bfd			 
0bfd 3e 05				ld a, 5 
0bff 32 6f ea				ld (store_tmp3), a   ; display row count 
0c02 3a 71 ea				ld a,( store_tmp2) 
0c05 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c08			 
0c08					 
0c08			.mitem:	 
0c08			 
0c08			 
0c08 3a 72 ea				ld a,(store_tmp2+1) 
0c0b 6f					ld l, a 
0c0c 26 00				ld h, 0 
0c0e 29					add hl, hl 
0c0f ed 5b 73 ea			ld de, (store_tmp1) 
0c13 19					add hl, de 
0c14 7e					ld a, (hl) 
0c15 23					inc hl 
0c16 66					ld h,(hl) 
0c17 6f					ld l, a 
0c18			 
0c18 cd 10 0e				call ishlzero 
0c1b 28 1a				jr z, .mdone 
0c1d			 
0c1d eb					ex de, hl 
0c1e 3a 6f ea				ld a, (store_tmp3) 
0c21 cd cd 0b				call str_at_display 
0c24					 
0c24			 
0c24					; next item 
0c24 3a 72 ea				ld a, (store_tmp2+1) 
0c27 3c					inc a 
0c28 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2b			 
0c2b			 		; next row 
0c2b			 
0c2b 3a 6f ea				ld a, (store_tmp3) 
0c2e c6 28				add display_cols 
0c30 32 6f ea				ld (store_tmp3), a 
0c33			 
0c33					; at end of screen? 
0c33			 
0c33 fe 10				cp display_rows*4 
0c35 20 d1				jr nz, .mitem 
0c37			 
0c37			 
0c37			.mdone: 
0c37 cd 10 0e				call ishlzero 
0c3a 28 08				jr z, .nodn 
0c3c			 
0c3c 3e 78				ld a, display_row_4 
0c3e 11 bd 0c				ld de, .mdown 
0c41 cd cd 0b				call str_at_display 
0c44			 
0c44					; draw options to fill the screens with active item on line 1 
0c44					; if current option is 2 or more then display ^ in top 
0c44			 
0c44 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c47 fe 00				cp 0 
0c49 28 08				jr z, .noup 
0c4b			 
0c4b 3e 00				ld a, 0 
0c4d 11 bb 0c				ld de, .mup 
0c50 cd cd 0b				call str_at_display 
0c53			 
0c53 3e 02		.noup:		ld a, 2 
0c55 11 b9 0c				ld de, .msel 
0c58 cd cd 0b				call str_at_display 
0c5b			 
0c5b					; if current option + 1 is not null then display V in bottom 
0c5b					; get key 
0c5b cd dd 0b				call update_display 
0c5e			 
0c5e			 
0c5e					; handle key 
0c5e			 
0c5e cd 6e 65				call cin_wait 
0c61			 
0c61 fe 05				cp KEY_UP 
0c63 28 2b				jr z, .mgoup 
0c65 fe 61				cp 'a' 
0c67 28 27				jr z, .mgoup 
0c69 fe 0a				cp KEY_DOWN 
0c6b 28 32				jr z, .mgod 
0c6d fe 7a				cp 'z' 
0c6f 28 2e				jr z, .mgod 
0c71 fe 20				cp ' ' 
0c73 28 34				jr z, .goend 
0c75 fe 0c				cp KEY_RIGHT 
0c77 28 30				jr z, .goend 
0c79 fe 0d				cp KEY_CR 
0c7b 28 2c				jr z, .goend 
0c7d fe 71				cp 'q' 
0c7f 28 0b				jr z, .goback 
0c81			 
0c81 fe 0b				cp KEY_LEFT 
0c83 28 07				jr z, .goback 
0c85 fe 08				cp KEY_BS 
0c87 28 03				jr z, .goback 
0c89 c3 f7 0b				jp .mloop 
0c8c			 
0c8c			.goback: 
0c8c 3e 00			ld a, 0 
0c8e 18 1d			jr .goend2 
0c90			 
0c90				; move up one 
0c90			.mgoup: 
0c90 3a 71 ea				ld a, (store_tmp2) 
0c93 fe 00				cp 0 
0c95 ca f7 0b				jp z, .mloop 
0c98 3d					dec a 
0c99 32 71 ea				ld (store_tmp2), a 
0c9c c3 f7 0b				jp .mloop 
0c9f			 
0c9f				; move down one 
0c9f			.mgod: 
0c9f 3a 71 ea				ld a, (store_tmp2) 
0ca2 3c					inc a 
0ca3 32 71 ea				ld (store_tmp2), a 
0ca6 c3 f7 0b				jp .mloop 
0ca9			 
0ca9			 
0ca9			.goend: 
0ca9					; get selected item number 
0ca9			 
0ca9 3a 71 ea				ld a, (store_tmp2) 
0cac 3c					inc a 
0cad			 
0cad			.goend2: 
0cad f5					push af 
0cae			 
0cae					; restore active fb 
0cae					; TODO BUG assumes fb1 
0cae			 
0cae 21 10 ed				ld hl, display_fb1 
0cb1 22 cc eb				ld (display_fb_active), hl 
0cb4			 
0cb4					; restore main regs 
0cb4			 
0cb4			 
0cb4 cd dd 0b				call update_display 
0cb7			 
0cb7 f1					pop af 
0cb8			 
0cb8 c9				ret 
0cb9			 
0cb9 .. 00		.msel:   db ">",0 
0cbb .. 00		.mup:   db "^",0 
0cbd .. 00		.mdown:   db "v",0 
0cbf			 
0cbf			 
0cbf			; eof 
0cbf			 
# End of file firmware_display.asm
0cbf			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbf			; random number generators 
0cbf			 
0cbf			 
0cbf			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbf			 
0cbf			 
0cbf			;-----> Generate a random number 
0cbf			; output a=answer 0<=a<=255 
0cbf			; all registers are preserved except: af 
0cbf			random: 
0cbf e5			        push    hl 
0cc0 d5			        push    de 
0cc1 2a ab eb		        ld      hl,(randData) 
0cc4 ed 5f		        ld      a,r 
0cc6 57			        ld      d,a 
0cc7 5e			        ld      e,(hl) 
0cc8 19			        add     hl,de 
0cc9 85			        add     a,l 
0cca ac			        xor     h 
0ccb 22 ab eb		        ld      (randData),hl 
0cce d1			        pop     de 
0ccf e1			        pop     hl 
0cd0 c9			        ret 
0cd1			 
0cd1			 
0cd1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd1			 
0cd1			 
0cd1			 
0cd1			;------LFSR------ 
0cd1			;James Montelongo 
0cd1			;optimized by Spencer Putt 
0cd1			;out: 
0cd1			; a = 8 bit random number 
0cd1			RandLFSR: 
0cd1 21 b1 eb		        ld hl,LFSRSeed+4 
0cd4 5e			        ld e,(hl) 
0cd5 23			        inc hl 
0cd6 56			        ld d,(hl) 
0cd7 23			        inc hl 
0cd8 4e			        ld c,(hl) 
0cd9 23			        inc hl 
0cda 7e			        ld a,(hl) 
0cdb 47			        ld b,a 
0cdc cb 13		        rl e  
0cde cb 12			rl d 
0ce0 cb 11		        rl c  
0ce2 17				rla 
0ce3 cb 13		        rl e  
0ce5 cb 12			rl d 
0ce7 cb 11		        rl c  
0ce9 17				rla 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 67			        ld h,a 
0cf2 cb 13		        rl e  
0cf4 cb 12			rl d 
0cf6 cb 11		        rl c  
0cf8 17				rla 
0cf9 a8			        xor b 
0cfa cb 13		        rl e  
0cfc cb 12			rl d 
0cfe ac			        xor h 
0cff a9			        xor c 
0d00 aa			        xor d 
0d01 21 b3 eb		        ld hl,LFSRSeed+6 
0d04 11 b4 eb		        ld de,LFSRSeed+7 
0d07 01 07 00		        ld bc,7 
0d0a ed b8		        lddr 
0d0c 12			        ld (de),a 
0d0d c9			        ret 
0d0e			 
0d0e			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0e			 
0d0e			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0e			 
0d0e			 
0d0e			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0e			 
0d0e			prng16: 
0d0e			;Inputs: 
0d0e			;   (seed1) contains a 16-bit seed value 
0d0e			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0e			;Outputs: 
0d0e			;   HL is the result 
0d0e			;   BC is the result of the LCG, so not that great of quality 
0d0e			;   DE is preserved 
0d0e			;Destroys: 
0d0e			;   AF 
0d0e			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0e			;160cc 
0d0e			;26 bytes 
0d0e 2a a5 eb		    ld hl,(seed1) 
0d11 44			    ld b,h 
0d12 4d			    ld c,l 
0d13 29			    add hl,hl 
0d14 29			    add hl,hl 
0d15 2c			    inc l 
0d16 09			    add hl,bc 
0d17 22 a5 eb		    ld (seed1),hl 
0d1a 2a a3 eb		    ld hl,(seed2) 
0d1d 29			    add hl,hl 
0d1e 9f			    sbc a,a 
0d1f e6 2d		    and %00101101 
0d21 ad			    xor l 
0d22 6f			    ld l,a 
0d23 22 a3 eb		    ld (seed2),hl 
0d26 09			    add hl,bc 
0d27 c9			    ret 
0d28			 
0d28			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d28			 
0d28			rand32: 
0d28			;Inputs: 
0d28			;   (seed1_0) holds the lower 16 bits of the first seed 
0d28			;   (seed1_1) holds the upper 16 bits of the first seed 
0d28			;   (seed2_0) holds the lower 16 bits of the second seed 
0d28			;   (seed2_1) holds the upper 16 bits of the second seed 
0d28			;   **NOTE: seed2 must be non-zero 
0d28			;Outputs: 
0d28			;   HL is the result 
0d28			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d28			;Destroys: 
0d28			;   AF 
0d28			;Tested and passes all CAcert tests 
0d28			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d28			;it has a period of 18,446,744,069,414,584,320 
0d28			;roughly 18.4 quintillion. 
0d28			;LFSR taps: 0,2,6,7  = 11000101 
0d28			;291cc 
0d28			;seed1_0=$+1 
0d28			;    ld hl,12345 
0d28			;seed1_1=$+1 
0d28			;    ld de,6789 
0d28			;    ld b,h 
0d28			;    ld c,l 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    inc l 
0d28			;    add hl,bc 
0d28			;    ld (seed1_0),hl 
0d28			;    ld hl,(seed1_1) 
0d28			;    adc hl,de 
0d28			;    ld (seed1_1),hl 
0d28			;    ex de,hl 
0d28			;seed2_0=$+1 
0d28			;    ld hl,9876 
0d28			;seed2_1=$+1 
0d28			;    ld bc,54321 
0d28			;    add hl,hl \ rl c \ rl b 
0d28			;    ld (seed2_1),bc 
0d28			;    sbc a,a 
0d28			;    and %11000101 
0d28			;    xor l 
0d28			;    ld l,a 
0d28			;    ld (seed2_0),hl 
0d28			;    ex de,hl 
0d28			;    add hl,bc 
0d28			;    ret 
0d28			; 
0d28			 
0d28			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d28			; 20 bytes, 86 cycles (excluding ret) 
0d28			 
0d28			; returns   hl = pseudorandom number 
0d28			; corrupts   a 
0d28			 
0d28			; generates 16-bit pseudorandom numbers with a period of 65535 
0d28			; using the xorshift method: 
0d28			 
0d28			; hl ^= hl << 7 
0d28			; hl ^= hl >> 9 
0d28			; hl ^= hl << 8 
0d28			 
0d28			; some alternative shift triplets which also perform well are: 
0d28			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d28			 
0d28			;  org 32768 
0d28			 
0d28			xrnd: 
0d28 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2b 3e 00		  ld a,0 
0d2d bd			  cp l 
0d2e 20 02		  jr nz, .xrnd1 
0d30 2e 01		  ld l, 1 
0d32			.xrnd1: 
0d32			 
0d32 7c			  ld a,h 
0d33 1f			  rra 
0d34 7d			  ld a,l 
0d35 1f			  rra 
0d36 ac			  xor h 
0d37 67			  ld h,a 
0d38 7d			  ld a,l 
0d39 1f			  rra 
0d3a 7c			  ld a,h 
0d3b 1f			  rra 
0d3c ad			  xor l 
0d3d 6f			  ld l,a 
0d3e ac			  xor h 
0d3f 67			  ld h,a 
0d40			 
0d40 22 a9 eb		  ld (xrandc),hl 
0d43			 
0d43 c9			  ret 
0d44			;  
0d44			 
0d44			 
0d44			;;;; int maths 
0d44			 
0d44			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d44			; Divide 16-bit values (with 16-bit result) 
0d44			; In: Divide BC by divider DE 
0d44			; Out: BC = result, HL = rest 
0d44			; 
0d44			Div16: 
0d44 21 00 00		    ld hl,0 
0d47 78			    ld a,b 
0d48 06 08		    ld b,8 
0d4a			Div16_Loop1: 
0d4a 17			    rla 
0d4b ed 6a		    adc hl,hl 
0d4d ed 52		    sbc hl,de 
0d4f 30 01		    jr nc,Div16_NoAdd1 
0d51 19			    add hl,de 
0d52			Div16_NoAdd1: 
0d52 10 f6		    djnz Div16_Loop1 
0d54 17			    rla 
0d55 2f			    cpl 
0d56 47			    ld b,a 
0d57 79			    ld a,c 
0d58 48			    ld c,b 
0d59 06 08		    ld b,8 
0d5b			Div16_Loop2: 
0d5b 17			    rla 
0d5c ed 6a		    adc hl,hl 
0d5e ed 52		    sbc hl,de 
0d60 30 01		    jr nc,Div16_NoAdd2 
0d62 19			    add hl,de 
0d63			Div16_NoAdd2: 
0d63 10 f6		    djnz Div16_Loop2 
0d65 17			    rla 
0d66 2f			    cpl 
0d67 41			    ld b,c 
0d68 4f			    ld c,a 
0d69 c9			ret 
0d6a			 
0d6a			 
0d6a			;http://z80-heaven.wikidot.com/math 
0d6a			; 
0d6a			;Inputs: 
0d6a			;     DE and A are factors 
0d6a			;Outputs: 
0d6a			;     A is not changed 
0d6a			;     B is 0 
0d6a			;     C is not changed 
0d6a			;     DE is not changed 
0d6a			;     HL is the product 
0d6a			;Time: 
0d6a			;     342+6x 
0d6a			; 
0d6a			Mult16: 
0d6a			 
0d6a 06 08		     ld b,8          ;7           7 
0d6c 21 00 00		     ld hl,0         ;10         10 
0d6f 29			       add hl,hl     ;11*8       88 
0d70 07			       rlca          ;4*8        32 
0d71 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d73 19			         add hl,de   ;--         -- 
0d74 10 f9		       djnz $-5      ;13*7+8     99 
0d76 c9			ret 
0d77			 
0d77			; 
0d77			; Square root of 16-bit value 
0d77			; In:  HL = value 
0d77			; Out:  D = result (rounded down) 
0d77			; 
0d77			;Sqr16: 
0d77			;    ld de,#0040 
0d77			;    ld a,l 
0d77			;    ld l,h 
0d77			;    ld h,d 
0d77			;    or a 
0d77			;    ld b,8 
0d77			;Sqr16_Loop: 
0d77			;    sbc hl,de 
0d77			;    jr nc,Sqr16_Skip 
0d77			;    add hl,de 
0d77			;Sqr16_Skip: 
0d77			;    ccf 
0d77			;    rl d 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    djnz Sqr16_Loop 
0d77			;    ret 
0d77			; 
0d77			; 
0d77			; Divide 8-bit values 
0d77			; In: Divide E by divider C 
0d77			; Out: A = result, B = rest 
0d77			; 
0d77			Div8: 
0d77 af			    xor a 
0d78 06 08		    ld b,8 
0d7a			Div8_Loop: 
0d7a cb 13		    rl e 
0d7c 17			    rla 
0d7d 91			    sub c 
0d7e 30 01		    jr nc,Div8_NoAdd 
0d80 81			    add a,c 
0d81			Div8_NoAdd: 
0d81 10 f7		    djnz Div8_Loop 
0d83 47			    ld b,a 
0d84 7b			    ld a,e 
0d85 17			    rla 
0d86 2f			    cpl 
0d87 c9			    ret 
0d88			 
0d88			; 
0d88			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d88			; In: Multiply A with DE 
0d88			; Out: HL = result 
0d88			; 
0d88			Mult12U: 
0d88 2e 00		    ld l,0 
0d8a 87			    add a,a 
0d8b 30 01		    jr nc,Mult12U_NoAdd0 
0d8d 19			    add hl,de 
0d8e			Mult12U_NoAdd0: 
0d8e 29			    add hl,hl 
0d8f 87			    add a,a 
0d90 30 01		    jr nc,Mult12U_NoAdd1 
0d92 19			    add hl,de 
0d93			Mult12U_NoAdd1: 
0d93 29			    add hl,hl 
0d94 87			    add a,a 
0d95 30 01		    jr nc,Mult12U_NoAdd2 
0d97 19			    add hl,de 
0d98			Mult12U_NoAdd2: 
0d98 29			    add hl,hl 
0d99 87			    add a,a 
0d9a 30 01		    jr nc,Mult12U_NoAdd3 
0d9c 19			    add hl,de 
0d9d			Mult12U_NoAdd3: 
0d9d 29			    add hl,hl 
0d9e 87			    add a,a 
0d9f 30 01		    jr nc,Mult12U_NoAdd4 
0da1 19			    add hl,de 
0da2			Mult12U_NoAdd4: 
0da2 29			    add hl,hl 
0da3 87			    add a,a 
0da4 30 01		    jr nc,Mult12U_NoAdd5 
0da6 19			    add hl,de 
0da7			Mult12U_NoAdd5: 
0da7 29			    add hl,hl 
0da8 87			    add a,a 
0da9 30 01		    jr nc,Mult12U_NoAdd6 
0dab 19			    add hl,de 
0dac			Mult12U_NoAdd6: 
0dac 29			    add hl,hl 
0dad 87			    add a,a 
0dae d0			    ret nc 
0daf 19			    add hl,de 
0db0 c9			    ret 
0db1			 
0db1			; 
0db1			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db1			; In: Multiply A with DE 
0db1			;      Put lowest value in A for most efficient calculation 
0db1			; Out: HL = result 
0db1			; 
0db1			Mult12R: 
0db1 21 00 00		    ld hl,0 
0db4			Mult12R_Loop: 
0db4 cb 3f		    srl a 
0db6 30 01		    jr nc,Mult12R_NoAdd 
0db8 19			    add hl,de 
0db9			Mult12R_NoAdd: 
0db9 cb 23		    sla e 
0dbb cb 12		    rl d 
0dbd b7			    or a 
0dbe c2 b4 0d		    jp nz,Mult12R_Loop 
0dc1 c9			    ret 
0dc2			 
0dc2			; 
0dc2			; Multiply 16-bit values (with 32-bit result) 
0dc2			; In: Multiply BC with DE 
0dc2			; Out: BCHL = result 
0dc2			; 
0dc2			Mult32: 
0dc2 79			    ld a,c 
0dc3 48			    ld c,b 
0dc4 21 00 00		    ld hl,0 
0dc7 06 10		    ld b,16 
0dc9			Mult32_Loop: 
0dc9 29			    add hl,hl 
0dca 17			    rla 
0dcb cb 11		    rl c 
0dcd 30 07		    jr nc,Mult32_NoAdd 
0dcf 19			    add hl,de 
0dd0 ce 00		    adc a,0 
0dd2 d2 d6 0d		    jp nc,Mult32_NoAdd 
0dd5 0c			    inc c 
0dd6			Mult32_NoAdd: 
0dd6 10 f1		    djnz Mult32_Loop 
0dd8 41			    ld b,c 
0dd9 4f			    ld c,a 
0dda c9			    ret 
0ddb			 
0ddb			 
0ddb			 
0ddb			; 
0ddb			; Multiply 8-bit values 
0ddb			; In:  Multiply H with E 
0ddb			; Out: HL = result 
0ddb			; 
0ddb			Mult8: 
0ddb 16 00		    ld d,0 
0ddd 6a			    ld l,d 
0dde 06 08		    ld b,8 
0de0			Mult8_Loop: 
0de0 29			    add hl,hl 
0de1 30 01		    jr nc,Mult8_NoAdd 
0de3 19			    add hl,de 
0de4			Mult8_NoAdd: 
0de4 10 fa		    djnz Mult8_Loop 
0de6 c9			    ret 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			;;http://z80-heaven.wikidot.com/math 
0de7			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de7			; 
0de7			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de7			;     ld a,16        ;7 
0de7			;     ld hl,0        ;10 
0de7			;     jp $+5         ;10 
0de7			;.DivLoop: 
0de7			;       add hl,bc    ;-- 
0de7			;       dec a        ;64 
0de7			;       jr z,.DivLoopEnd        ;86 
0de7			; 
0de7			;       sla e        ;128 
0de7			;       rl d         ;128 
0de7			;       adc hl,hl    ;240 
0de7			;       sbc hl,bc    ;240 
0de7			;       jr nc,.DivLoop ;23|21 
0de7			;       inc e        ;-- 
0de7			;       jp .DivLoop+1 
0de7			; 
0de7			;.DivLoopEnd: 
0de7			 
0de7			;HL_Div_C: 
0de7			;Inputs: 
0de7			;     HL is the numerator 
0de7			;     C is the denominator 
0de7			;Outputs: 
0de7			;     A is the remainder 
0de7			;     B is 0 
0de7			;     C is not changed 
0de7			;     DE is not changed 
0de7			;     HL is the quotient 
0de7			; 
0de7			;       ld b,16 
0de7			;       xor a 
0de7			;         add hl,hl 
0de7			;         rla 
0de7			;         cp c 
0de7			;         jr c,$+4 
0de7			;           inc l 
0de7			;           sub c 
0de7			;         djnz $-7 
0de7			 
0de7			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de7			 
0de7			addatohl: 
0de7 85			    add   a, l    ; A = A+L 
0de8 6f			    ld    l, a    ; L = A+L 
0de9 8c			    adc   a, h    ; A = A+L+H+carry 
0dea 95			    sub   l       ; A = H+carry 
0deb 67			    ld    h, a    ; H = H+carry 
0dec c9			ret 
0ded			 
0ded			addatode: 
0ded 83			    add   a, e    ; A = A+L 
0dee 5f			    ld    e, a    ; L = A+L 
0def 8a			    adc   a, d    ; A = A+L+H+carry 
0df0 93			    sub   e       ; A = H+carry 
0df1 57			    ld    d, a    ; H = H+carry 
0df2 c9			ret 
0df3			 
0df3			 
0df3			addatobc: 
0df3 81			    add   a, c    ; A = A+L 
0df4 4f			    ld    c, a    ; L = A+L 
0df5 88			    adc   a, b    ; A = A+L+H+carry 
0df6 91			    sub   c       ; A = H+carry 
0df7 47			    ld    b, a    ; H = H+carry 
0df8 c9			ret 
0df9			 
0df9			subafromhl: 
0df9			   ; If A=0 do nothing 
0df9			    ; Otherwise flip A's sign. Since 
0df9			    ; the upper byte becomes -1, also 
0df9			    ; substract 1 from H. 
0df9 ed 44		    neg 
0dfb ca 04 0e		    jp    z, Skip 
0dfe 25			    dec   h 
0dff			     
0dff			    ; Now add the low byte as usual 
0dff			    ; Two's complement takes care of 
0dff			    ; ensuring the result is correct 
0dff 85			    add   a, l 
0e00 6f			    ld    l, a 
0e01 8c			    adc   a, h 
0e02 95			    sub   l 
0e03 67			    ld    h, a 
0e04			Skip: 
0e04 c9				ret 
0e05			 
0e05			 
0e05			; compare hl and de 
0e05			; returns:  
0e05			; if hl = de, z=1, s=0, c0=0 
0e05			; if hl > de, z=0, s=0, c=0 
0e05			; if hl < de, z=0, s=1, c=1 
0e05			cmp16:	 
0e05 b7				or a 
0e06 ed 52			sbc hl,de 
0e08 e0				ret po 
0e09 7c				ld a,h 
0e0a 1f				rra 
0e0b ee 40			xor 01000000B 
0e0d 37				scf 
0e0e 8f				adc a,a 
0e0f c9				ret 
0e10			 
0e10			 
0e10			; test if hl contains zero   - A is destroyed 
0e10			 
0e10			ishlzero:    
0e10 b7				or a     ; reset flags 
0e11 7c				ld a, h 
0e12 b5				or l        	 
0e13			 
0e13 c9				ret 
0e14			 
0e14			 
0e14			 
0e14			 
0e14			if FORTH_ENABLE_FLOATMATH 
0e14			;include "float/bbcmath.z80" 
0e14			include "float/lpfpcalc.asm" 
0e14			endif 
0e14			 
0e14			 
0e14			; eof 
0e14			 
# End of file firmware_maths.asm
0e14			include "firmware_strings.asm"   ; string handling  
0e14			 
0e14			 
0e14			; TODO string len 
0e14			; input text string, end on cr with zero term 
0e14			; a offset into frame buffer to start prompt 
0e14			; d is max length 
0e14			; e is display size TODO 
0e14			; c is current cursor position 
0e14			; hl is ptr to where string will be stored 
0e14			 
0e14			 
0e14			; TODO check limit of buffer for new inserts 
0e14			; TODO check insert does not push beyond buffer 
0e14			; TODO scroll in a limited display area 
0e14			; TODO scroll whole screen on page wrap 
0e14			 
0e14			 
0e14			; TODO handle KEY_PREVWORD 
0e14			; TODO handle KEY_NEXTWORD 
0e14			; TODO handle KEY_HOME 
0e14			; TODO handle KEY_END 
0e14			; TODO use LCD cursor? 
0e14			 
0e14 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e17 81					add c 
0e18 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0e1b 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e1e 79					ld a, c 
0e1f cd e7 0d				call addatohl 
0e22 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e25 7a					ld a,d 
0e26 32 66 ee			        ld (input_size), a       ; save length of input area 
0e29 79					ld a, c 
0e2a 32 55 ee				ld (input_cursor),a      ; init cursor start position  
0e2d 7b					ld a,e 
0e2e 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e31					 
0e31					 
0e31			 
0e31			;		ld a,(input_ptr) 
0e31			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e31			 
0e31			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e31					; init cursor shape if not set by the cin routines 
0e31 21 c1 eb				ld hl, cursor_shape 
0e34 3e ff				ld a, 255 
0e36 77					ld (hl), a 
0e37 23					inc hl 
0e38 3e 00				ld a, 0 
0e3a 77					ld (hl), a 
0e3b			 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 60 ee				ld (input_cur_flash), a 
0e40 3e 01				ld a, 1 
0e42 32 5f ee				ld (input_cur_onoff),a 
0e45			 
0e45			;	if DEBUG_INPUT 
0e45			;		push af 
0e45			;		ld a, 'I' 
0e45			;		ld (debug_mark),a 
0e45			;		pop af 
0e45			;		CALLMONITOR 
0e45			;	endif 
0e45			.is1:		; main entry loop 
0e45			 
0e45			 
0e45			 
0e45					; pause 1ms 
0e45			 
0e45 3e 01				ld a, 1 
0e47 cd d7 0a				call aDelayInMS 
0e4a			 
0e4a					; dec flash counter 
0e4a 3a 60 ee				ld a, (input_cur_flash) 
0e4d 3d					dec a 
0e4e 32 60 ee				ld (input_cur_flash), a 
0e51 fe 00				cp 0 
0e53 20 0d				jr nz, .nochgstate 
0e55			 
0e55			 
0e55					; change state 
0e55 3a 5f ee				ld a,(input_cur_onoff) 
0e58 ed 44				neg 
0e5a 32 5f ee				ld (input_cur_onoff),a 
0e5d			 
0e5d			 
0e5d					; reset on change of state 
0e5d 3e 0f				ld a, CUR_BLINK_RATE 
0e5f 32 60 ee				ld (input_cur_flash), a 
0e62			 
0e62			.nochgstate: 
0e62					 
0e62					 
0e62			 
0e62					; display cursor  
0e62			 
0e62			;		ld hl, (input_start) 
0e62			;		ld a, (input_cursor) 
0e62			;		call addatohl 
0e62			 
0e62					; get char under cursor and replace with cursor 
0e62 2a 69 ee		ld hl, (input_ptr) 
0e65			;		ld a, (hl) 
0e65			;		ld (input_under_cursor),a 
0e65			;		ld a, '_' 
0e65			;		ld (hl), a 
0e65			 
0e65					; display string 
0e65			 
0e65 ed 5b 67 ee			ld de, (input_start) 
0e69 3a 64 ee				ld a, (input_at_pos) 
0e6c cd cd 0b				call str_at_display 
0e6f			;	        call update_display 
0e6f			 
0e6f					; find place to put the cursor 
0e6f			;		add h 
0e6f			;		ld l, display_row_1 
0e6f			;		sub l 
0e6f			; (input_at_pos) 
0e6f					;ld c, a 
0e6f			;		ld a, (input_cursor) 
0e6f			;		ld l, (input_at_pos) 
0e6f			;		;ld b, h 
0e6f			;		add l 
0e6f			;		ld (input_at_cursor),a 
0e6f					;ld l,h 
0e6f			 
0e6f			;		ld h, 0 
0e6f			;		ld l,(input_at_pos) 
0e6f			;		ld a, (input_cursor) 
0e6f			;		call addatohl 
0e6f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e6f			;		call subafromhl 
0e6f			;		ld a,l 
0e6f			;		ld (input_at_cursor), a 
0e6f			 
0e6f				if DEBUG_INPUT 
0e6f					ld a, (hardware_diag) 
0e6f					cp 0 
0e6f					jr z, .skip_input_diag 
0e6f			 
0e6f					ld a,(input_at_pos) 
0e6f					ld hl, LFSRSeed 
0e6f					call hexout 
0e6f					ld a, (input_cursor) 
0e6f					ld hl, LFSRSeed+2 
0e6f					call hexout 
0e6f					ld a,(input_at_cursor) 
0e6f					ld hl, LFSRSeed+4 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_onoff) 
0e6f					ld hl, LFSRSeed+6 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_flash) 
0e6f					ld hl, LFSRSeed+8 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_len) 
0e6f					ld hl, LFSRSeed+10 
0e6f					call hexout 
0e6f					ld hl, LFSRSeed+12 
0e6f					ld a, 0 
0e6f					ld (hl),a 
0e6f					ld a, display_row_4 
0e6f					ld de, LFSRSeed 
0e6f					call str_at_display 
0e6f					.skip_input_diag: 
0e6f				endif 
0e6f			 
0e6f					; decide on if we are showing the cursor this time round 
0e6f			 
0e6f 3a 5f ee				ld a, (input_cur_onoff) 
0e72 fe ff				cp 255 
0e74 28 13				jr z, .skipcur 
0e76			 
0e76			 
0e76 3a 62 ee				ld a,(input_at_cursor) 
0e79 11 c1 eb				ld de, cursor_shape 
0e7c cd cd 0b				call str_at_display 
0e7f			 
0e7f					; save length of current input string 
0e7f 2a 67 ee				ld hl, (input_start) 
0e82 cd 45 12				call strlenz 
0e85 7d					ld a,l 
0e86 32 5a ee				ld (input_len),a 
0e89			 
0e89			.skipcur: 
0e89			 
0e89 cd dd 0b			        call update_display 
0e8c					 
0e8c			 
0e8c			 
0e8c					; wait 
0e8c				 
0e8c					; TODO loop without wait to flash the cursor and char under cursor	 
0e8c cd 76 65				call cin    ; _wait 
0e8f			 
0e8f fe 00				cp 0 
0e91 ca 45 0e				jp z, .is1 
0e94			 
0e94					; get ptr to char to input into 
0e94			 
0e94 4f					ld c,a 
0e95 2a 67 ee				ld hl, (input_start) 
0e98 3a 55 ee				ld a, (input_cursor) 
0e9b cd e7 0d				call addatohl 
0e9e 22 69 ee				ld (input_ptr), hl 
0ea1 79					ld a,c 
0ea2			 
0ea2					; replace char under cursor 
0ea2			 
0ea2			;		ld hl, (input_ptr) 
0ea2			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ea2			;		ld (hl), a 
0ea2			 
0ea2			;	if DEBUG_INPUT 
0ea2			;		push af 
0ea2			;		ld a, 'i' 
0ea2			;		ld (debug_mark),a 
0ea2			;		pop af 
0ea2			;		CALLMONITOR 
0ea2			;	endif 
0ea2 fe 0e				cp KEY_HOME 
0ea4 20 0e				jr nz, .iske 
0ea6			 
0ea6 3a 64 ee				ld a, (input_at_pos) 
0ea9 32 62 ee				ld (input_at_cursor),a 
0eac 3e 00				ld a, 0 
0eae 32 55 ee				ld (input_cursor), a 
0eb1 c3 45 0e				jp .is1 
0eb4					 
0eb4 fe 0f		.iske:		cp KEY_END 
0eb6 20 03				jr nz, .isknw 
0eb8 c3 45 0e				jp .is1 
0ebb			 
0ebb fe 06		.isknw:		cp KEY_NEXTWORD 
0ebd 20 1b				jr nz, .iskpw 
0ebf			 
0ebf 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
0ec2 7e					ld a,(hl)	 
0ec3 fe 00				cp 0 
0ec5 ca 45 0e				jp z, .is1    ; end of string 
0ec8 fe 20				cp ' ' 
0eca ca 45 0e				jp z, .is1    ; end of word 
0ecd 23					inc hl 
0ece 22 69 ee				ld (input_ptr), hl 
0ed1 3a 62 ee				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 32 62 ee				ld (input_at_cursor), a 
0ed8 18 e5				jr .isknwm 
0eda			 
0eda fe 07		.iskpw:		cp KEY_PREVWORD 
0edc 20 1b				jr nz, .iskl 
0ede			.iskpwm:	 
0ede 2a 69 ee				ld hl, (input_ptr) 
0ee1 7e					ld a,(hl)	 
0ee2 fe 00				cp 0  
0ee4 ca 45 0e				jp z, .is1    ; end of string 
0ee7 fe 20				cp ' ' 
0ee9 ca 45 0e				jp z, .is1    ; end of word 
0eec 2b					dec hl 
0eed 22 69 ee				ld (input_ptr), hl 
0ef0 3a 62 ee				ld a, (input_at_cursor) 
0ef3 3d					dec a 
0ef4 32 62 ee				ld (input_at_cursor), a 
0ef7 18 e5				jr .iskpwm 
0ef9			 
0ef9			 
0ef9 fe 0b		.iskl:		cp KEY_LEFT 
0efb 20 27				jr nz, .isk1 
0efd			 
0efd 3a 55 ee				ld a, (input_cursor) 
0f00			 
0f00 fe 00				cp 0 
0f02 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f05			 
0f05 3d					dec  a 		; TODO check underflow 
0f06 32 55 ee				ld (input_cursor), a 
0f09			 
0f09 2a 69 ee				ld hl, (input_ptr) 
0f0c 2b					dec hl 
0f0d 22 69 ee				ld (input_ptr), hl 
0f10					 
0f10 3a 62 ee				ld a, (input_at_cursor) 
0f13 3d					dec a 
0f14 32 62 ee				ld (input_at_cursor), a 
0f17			 
0f17 3e 01				ld a, 1		; show cursor moving 
0f19 32 5f ee				ld (input_cur_onoff),a 
0f1c 3e 0f				ld a, CUR_BLINK_RATE 
0f1e 32 60 ee				ld (input_cur_flash), a 
0f21			 
0f21 c3 45 0e				jp .is1 
0f24			 
0f24 fe 0c		.isk1:		cp KEY_RIGHT 
0f26 20 2a				jr nz, .isk2 
0f28			 
0f28 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f2b 5f					ld e,a 
0f2c 3a 55 ee				ld a, (input_cursor) 
0f2f bb					cp e 
0f30 ca 45 0e				jp z, .is1		; at the end of string so dont go right 
0f33			 
0f33 3c					inc  a 		; TODO check overflow 
0f34 32 55 ee				ld (input_cursor), a 
0f37			 
0f37 3a 62 ee				ld a, (input_at_cursor) 
0f3a 3c					inc a 
0f3b 32 62 ee				ld (input_at_cursor), a 
0f3e			 
0f3e 2a 69 ee				ld hl, (input_ptr) 
0f41 23					inc hl 
0f42 22 69 ee				ld (input_ptr), hl 
0f45			 
0f45 3e 01				ld a, 1		; show cursor moving 
0f47 32 5f ee				ld (input_cur_onoff),a 
0f4a 3e 0f				ld a, CUR_BLINK_RATE 
0f4c 32 60 ee				ld (input_cur_flash), a 
0f4f			 
0f4f c3 45 0e				jp .is1 
0f52			 
0f52 fe 05		.isk2:		cp KEY_UP 
0f54			 
0f54 20 26				jr nz, .isk3 
0f56			 
0f56					; swap last command with the current on 
0f56			 
0f56					; move cursor to start of string 
0f56 2a 67 ee				ld hl, (input_start) 
0f59 22 69 ee				ld (input_ptr), hl 
0f5c			 
0f5c 3a 64 ee				ld a, (input_at_pos) 
0f5f 32 62 ee				ld (input_at_cursor), a 
0f62			 
0f62 3e 00				ld a, 0 
0f64 32 55 ee				ld (input_cursor), a 
0f67					 
0f67					; swap input and last command buffers 
0f67			 
0f67 21 e8 e5				ld hl, os_cli_cmd 
0f6a 11 e7 e6				ld de, os_last_cmd 
0f6d 06 ff				ld b, 255 
0f6f 7e			.swap1:		ld a, (hl) 
0f70 4f					ld c,a 
0f71 1a					ld a, (de) 
0f72 77					ld (hl), a 
0f73 79					ld a,c 
0f74 12					ld (de),a 
0f75 23					inc hl 
0f76 13					inc de 
0f77 10 f6				djnz .swap1 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			 
0f79 c3 45 0e				jp .is1 
0f7c			 
0f7c fe 08		.isk3:		cp KEY_BS 
0f7e 20 3c				jr nz, .isk4 
0f80			 
0f80 3a 55 ee				ld a, (input_cursor) 
0f83			 
0f83 fe 00				cp 0 
0f85 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f88			 
0f88 3d					dec  a 		; TODO check underflow 
0f89 32 55 ee				ld (input_cursor), a 
0f8c			 
0f8c					; hl is source 
0f8c					; de needs to be source - 1 
0f8c			 
0f8c			;		ld a, 0 
0f8c			;		dec hl 
0f8c			;		ld (hl), a 
0f8c			 
0f8c 2a 69 ee				ld hl, (input_ptr) 
0f8f 2b					dec hl 
0f90 22 69 ee				ld (input_ptr), hl 
0f93			 
0f93					; shift all data 
0f93			 
0f93 e5					push hl 
0f94 23					inc hl 
0f95 d1					pop de 
0f96 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f99 4f					ld c,a 
0f9a 06 00				ld b,0 
0f9c ed b0				ldir  
0f9e			 
0f9e			 
0f9e			 
0f9e			 
0f9e 3a 62 ee				ld a, (input_at_cursor) 
0fa1 3d					dec a 
0fa2 32 62 ee				ld (input_at_cursor), a 
0fa5			 
0fa5			 
0fa5 3e 01				ld a, 1		; show cursor moving 
0fa7 32 5f ee				ld (input_cur_onoff),a 
0faa 3e 0f				ld a, CUR_BLINK_RATE 
0fac 32 60 ee				ld (input_cur_flash), a 
0faf			 
0faf					; remove char 
0faf 3a 62 ee				ld a, (input_at_cursor) 
0fb2 3c					inc a 
0fb3 11 3d 10				ld de,.iblank 
0fb6 cd cd 0b				call str_at_display 
0fb9			 
0fb9 c3 45 0e				jp .is1 
0fbc			 
0fbc fe 0d		.isk4:		cp KEY_CR 
0fbe 28 6c				jr z, .endinput 
0fc0			 
0fc0					; else add the key press to the end 
0fc0			 
0fc0 4f					ld c, a			; save key pressed 
0fc1			 
0fc1 7e					ld a,(hl)		; get what is currently under char 
0fc2			 
0fc2 fe 00				cp 0			; we are at the end of the string 
0fc4 20 2f				jr nz, .onchar 
0fc6					 
0fc6					; add a char to the end of the string 
0fc6				 
0fc6 71					ld (hl),c 
0fc7 23					inc hl 
0fc8			;		ld a,' ' 
0fc8			;		ld (hl),a 
0fc8			;		inc hl 
0fc8 3e 00				ld a,0 
0fca 77					ld (hl),a 
0fcb 2b					dec hl 
0fcc			 
0fcc 3a 55 ee				ld a, (input_cursor) 
0fcf 3c					inc a				; TODO check max string length and scroll  
0fd0 32 55 ee				ld (input_cursor), a		; inc cursor pos 
0fd3							 
0fd3 3a 62 ee				ld a, (input_at_cursor) 
0fd6 3c					inc a 
0fd7 32 62 ee				ld (input_at_cursor), a 
0fda			 
0fda 2a 69 ee				ld hl, (input_ptr) 
0fdd 23					inc hl 
0fde 22 69 ee				ld (input_ptr), hl 
0fe1			 
0fe1 2a 69 ee				ld hl, (input_ptr) 
0fe4 23					inc hl 
0fe5 22 69 ee				ld (input_ptr), hl 
0fe8			;	if DEBUG_INPUT 
0fe8			;		push af 
0fe8			;		ld a, '+' 
0fe8			;		ld (debug_mark),a 
0fe8			;		pop af 
0fe8			;		CALLMONITOR 
0fe8			;	endif 
0fe8 3e 01				ld a, 1		; show cursor moving 
0fea 32 5f ee				ld (input_cur_onoff),a 
0fed 3e 0f				ld a, CUR_BLINK_RATE 
0fef 32 60 ee				ld (input_cur_flash), a 
0ff2 c3 45 0e				jp .is1 
0ff5					 
0ff5			 
0ff5			 
0ff5					; if on a char then insert 
0ff5			.onchar: 
0ff5			 
0ff5					; TODO over flow check: make sure insert does not blow out buffer 
0ff5			 
0ff5					; need to do some maths to use lddr 
0ff5			 
0ff5 e5					push hl   ; save char pos 
0ff6 c5					push bc 
0ff7			 
0ff7 2a 67 ee				ld hl, (input_start) 
0ffa 3a 5a ee				ld a, (input_len) 
0ffd cd e7 0d				call addatohl  		; end of string 
1000 23					inc hl 
1001 23					inc hl		; past zero term 
1002 e5					push hl 
1003 23					inc hl 
1004 e5					push hl  
1005			 
1005								; start and end of lddr set, now how much to move? 
1005			 
1005							 
1005 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1008 47					ld b,a 
1009 3a 5a ee				ld a,(input_len) 
100c 5f					ld e,a 
100d 90					sub b 
100e 3c					inc a		;?? 
100f 3c					inc a		;?? 
1010 3c					inc a		;?? 
1011			 
1011 06 00				ld b,0 
1013 4f					ld c,a 
1014			 
1014				if DEBUG_INPUT 
1014					push af 
1014					ld a, 'i' 
1014					ld (debug_mark),a 
1014					pop af 
1014			;		CALLMONITOR 
1014				endif 
1014 d1					pop de 
1015 e1					pop hl 
1016				if DEBUG_INPUT 
1016					push af 
1016					ld a, 'I' 
1016					ld (debug_mark),a 
1016					pop af 
1016			;		CALLMONITOR 
1016				endif 
1016 ed b8				lddr 
1018				 
1018			 
1018			 
1018					; TODO have a key for insert/overwrite mode???? 
1018 c1					pop bc 
1019 e1					pop hl 
101a 71					ld (hl), c		; otherwise overwrite current char 
101b					 
101b			 
101b			 
101b			 
101b 3a 55 ee				ld a, (input_cursor) 
101e 3c					inc  a 		; TODO check overflow 
101f 32 55 ee				ld (input_cursor), a 
1022			 
1022 3a 62 ee				ld a, (input_at_cursor) 
1025 3c					inc a 
1026 32 62 ee				ld (input_at_cursor), a 
1029			 
1029 c3 45 0e				jp .is1 
102c			 
102c			.endinput:	; TODO look for end of string 
102c			 
102c					; add trailing space for end of token 
102c			 
102c 2a 67 ee				ld hl, (input_start) 
102f 3a 5a ee				ld a,(input_len) 
1032 cd e7 0d				call addatohl 
1035 3e 20				ld a, ' ' 
1037 77					ld (hl),a 
1038					; TODO eof of parse marker 
1038			 
1038 23					inc hl 
1039 3e 00				ld a, 0 
103b 77					ld (hl),a 
103c			 
103c			 
103c c9					ret 
103d			 
103d .. 00		.iblank: db " ",0 
103f			 
103f			 
103f 32 64 ee		input_str_prev:	ld (input_at_pos), a 
1042 22 67 ee				ld (input_start), hl 
1045 3e 01				ld a,1			; add cursor 
1047 77					ld (hl),a 
1048 23					inc hl 
1049 3e 00				ld a,0 
104b 77					ld (hl),a 
104c 22 69 ee				ld (input_ptr), hl 
104f 7a					ld a,d 
1050 32 66 ee				ld (input_size), a 
1053 3e 00				ld a,0 
1055 32 55 ee				ld (input_cursor),a 
1058			.instr1:	 
1058			 
1058					; TODO do block cursor 
1058					; TODO switch cursor depending on the modifer key 
1058			 
1058					; update cursor shape change on key hold 
1058			 
1058 2a 69 ee				ld hl, (input_ptr) 
105b 2b					dec hl 
105c 3a c1 eb				ld a,(cursor_shape) 
105f 77					ld (hl), a 
1060			 
1060					; display entered text 
1060 3a 64 ee				ld a,(input_at_pos) 
1063 cd 8b 64		            	CALL fLCD_Pos       ;Position cursor to location in A 
1066 ed 5b 67 ee	            	LD   de, (input_start) 
106a cd 80 64		            	CALL fLCD_Str       ;Display string pointed to by DE 
106d			 
106d cd 76 65				call cin 
1070 fe 00				cp 0 
1072 28 e4				jr z, .instr1 
1074			 
1074					; proecess keyboard controls first 
1074			 
1074 2a 69 ee				ld hl,(input_ptr) 
1077			 
1077 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1079 28 5a				jr z, .instrcr 
107b			 
107b fe 08				cp KEY_BS 	; back space 
107d 20 0f				jr nz, .instr2 
107f					; process back space 
107f			 
107f					; TODO stop back space if at start of string 
107f 2b					dec hl 
1080 2b					dec hl ; to over write cursor 
1081 3a c1 eb				ld a,(cursor_shape) 
1084					;ld a,0 
1084 77					ld (hl),a 
1085 23					inc hl 
1086 3e 20				ld a," " 
1088 77					ld (hl),a 
1089 22 69 ee				ld (input_ptr),hl 
108c					 
108c			 
108c 18 ca				jr .instr1 
108e			 
108e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1090 20 06				jr nz, .instr3 
1092 2b					dec hl 
1093 22 69 ee				ld (input_ptr),hl 
1096 18 c0				jr .instr1 
1098				 
1098 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
109a 20 06				jr nz, .instr4 
109c 23					inc hl 
109d 22 69 ee				ld (input_ptr),hl 
10a0 18 b6				jr .instr1 
10a2			 
10a2 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10a4 20 06				jr nz, .instr5 
10a6 2b					dec hl 
10a7 22 69 ee				ld (input_ptr),hl 
10aa 18 ac				jr .instr1 
10ac			 
10ac fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10ae 20 06				jr nz, .instr6 
10b0 2b					dec hl 
10b1 22 69 ee				ld (input_ptr),hl 
10b4 18 a2				jr .instr1 
10b6 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10b8 20 0b				jr nz, .instrnew 
10ba			 
10ba 21 c1 e2			ld hl, scratch 
10bd 11 e7 e6			ld de, os_last_cmd 
10c0 cd de 10			call strcpy 
10c3 18 93				jr .instr1 
10c5			 
10c5			 
10c5			.instrnew:	; no special key pressed to see if we have room to store it 
10c5			 
10c5					; TODO do string size test 
10c5			 
10c5 2b					dec hl ; to over write cursor 
10c6 77					ld (hl),a 
10c7 23					inc hl 
10c8 3a c1 eb				ld a,(cursor_shape) 
10cb 77					ld (hl),a 
10cc 23					inc hl 
10cd 3e 00				ld a,0 
10cf 77					ld (hl),a 
10d0			 
10d0 22 69 ee				ld (input_ptr),hl 
10d3					 
10d3 18 83				jr .instr1 
10d5 2b			.instrcr:	dec hl		; remove cursor 
10d6 3e 20				ld a,' '	; TODO add a trailing space for safety 
10d8 77					ld (hl),a 
10d9 23					inc hl 
10da 3e 00				ld a,0 
10dc 77					ld (hl),a 
10dd			 
10dd			 
10dd					; if at end of line scroll up    
10dd					; TODO detecting only end of line 4 for scroll up  
10dd			 
10dd					;ld   
10dd			 
10dd c9					ret 
10de			 
10de			 
10de			; strcpy hl = dest, de source 
10de			 
10de 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10df b7			            OR   A              ;Null terminator? 
10e0 c8			            RET  Z              ;Yes, so finished 
10e1 1a					ld a,(de) 
10e2 77					ld (hl),a 
10e3 13			            INC  DE             ;Point to next character 
10e4 23					inc hl 
10e5 18 f7		            JR   strcpy       ;Repeat 
10e7 c9					ret 
10e8			 
10e8			 
10e8			; TODO string_at  
10e8			; pass string which starts with lcd offset address and then null term string 
10e8			 
10e8			; TODO string to dec 
10e8			; TODO string to hex 
10e8			; TODO byte to string hex 
10e8			; TODO byte to string dec 
10e8			 
10e8			 
10e8			 
10e8			; from z80uartmonitor 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10e8			; pass hl for where to put the text 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8 c5			hexout:	PUSH BC 
10e9 f5					PUSH AF 
10ea 47					LD B, A 
10eb					; Upper nybble 
10eb cb 3f				SRL A 
10ed cb 3f				SRL A 
10ef cb 3f				SRL A 
10f1 cb 3f				SRL A 
10f3 cd 03 11				CALL tohex 
10f6 77					ld (hl),a 
10f7 23					inc hl	 
10f8					 
10f8					; Lower nybble 
10f8 78					LD A, B 
10f9 e6 0f				AND 0FH 
10fb cd 03 11				CALL tohex 
10fe 77					ld (hl),a 
10ff 23					inc hl	 
1100					 
1100 f1					POP AF 
1101 c1					POP BC 
1102 c9					RET 
1103					 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			tohex: 
1103 e5					PUSH HL 
1104 d5					PUSH DE 
1105 16 00				LD D, 0 
1107 5f					LD E, A 
1108 21 10 11				LD HL, .DATA 
110b 19					ADD HL, DE 
110c 7e					LD A, (HL) 
110d d1					POP DE 
110e e1					POP HL 
110f c9					RET 
1110			 
1110			.DATA: 
1110 30					DEFB	30h	; 0 
1111 31					DEFB	31h	; 1 
1112 32					DEFB	32h	; 2 
1113 33					DEFB	33h	; 3 
1114 34					DEFB	34h	; 4 
1115 35					DEFB	35h	; 5 
1116 36					DEFB	36h	; 6 
1117 37					DEFB	37h	; 7 
1118 38					DEFB	38h	; 8 
1119 39					DEFB	39h	; 9 
111a 41					DEFB	41h	; A 
111b 42					DEFB	42h	; B 
111c 43					DEFB	43h	; C 
111d 44					DEFB	44h	; D 
111e 45					DEFB	45h	; E 
111f 46					DEFB	46h	; F 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1120			;;    subtract $30, if result > 9 then subtract $7 more 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			atohex: 
1120 d6 30				SUB $30 
1122 fe 0a				CP 10 
1124 f8					RET M		; If result negative it was 0-9 so we're done 
1125 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1127 c9					RET		 
1128			 
1128			 
1128			 
1128			 
1128			; Get 2 ASCII characters as hex byte from pointer in hl 
1128			 
1128			BYTERD: 
1128 16 00			LD	D,00h		;Set up 
112a cd 32 11			CALL	HEXCON		;Get byte and convert to hex 
112d 87				ADD	A,A		;First nibble so 
112e 87				ADD	A,A		;multiply by 16 
112f 87				ADD	A,A		; 
1130 87				ADD	A,A		; 
1131 57				LD	D,A		;Save hi nibble in D 
1132			HEXCON: 
1132 7e				ld a, (hl)		;Get next chr 
1133 23				inc hl 
1134 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1136 fe 0a			CP	00Ah		;Is it 0-9 ? 
1138 38 02			JR	C,NALPHA	;If so miss next bit 
113a d6 07			SUB	007h		;Else convert alpha 
113c			NALPHA: 
113c b2				OR	D		;Add hi nibble back 
113d c9				RET			; 
113e			 
113e			 
113e			; 
113e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
113e			; Since the routines get_byte and therefore get_nibble are called, only valid 
113e			; characters (0-9a-f) are accepted. 
113e			; 
113e			;get_word        push    af 
113e			;                call    get_byte        ; Get the upper byte 
113e			;                ld      h, a 
113e			;                call    get_byte        ; Get the lower byte 
113e			;                ld      l, a 
113e			;                pop     af 
113e			;                ret 
113e			; 
113e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
113e			; the routine get_nibble is used only valid characters are accepted - the  
113e			; input routine only accepts characters 0-9a-f. 
113e			; 
113e c5			get_byte:        push    bc              ; Save contents of B (and C) 
113f 7e					ld a,(hl) 
1140 23					inc hl 
1141 cd 66 11		                call    nibble2val      ; Get upper nibble 
1144 cb 07		                rlc     a 
1146 cb 07		                rlc     a 
1148 cb 07		                rlc     a 
114a cb 07		                rlc     a 
114c 47			                ld      b, a            ; Save upper four bits 
114d 7e					ld a,(hl) 
114e cd 66 11		                call    nibble2val      ; Get lower nibble 
1151 b0			                or      b               ; Combine both nibbles 
1152 c1			                pop     bc              ; Restore B (and C) 
1153 c9			                ret 
1154			; 
1154			; Get a hexadecimal digit from the serial line. This routine blocks until 
1154			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1154			; to the serial line interface. The lower 4 bits of A contain the value of  
1154			; that particular digit. 
1154			; 
1154			;get_nibble      ld a,(hl)           ; Read a character 
1154			;                call    to_upper        ; Convert to upper case 
1154			;                call    is_hex          ; Was it a hex digit? 
1154			;                jr      nc, get_nibble  ; No, get another character 
1154			 ;               call    nibble2val      ; Convert nibble to value 
1154			 ;               call    print_nibble 
1154			 ;               ret 
1154			; 
1154			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1154			; A valid hexadecimal digit is denoted by a set C flag. 
1154			; 
1154			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1154			;                ret     nc              ; Yes 
1154			;                cp      '0'             ; Less than '0'? 
1154			;                jr      nc, is_hex_1    ; No, continue 
1154			;                ccf                     ; Complement carry (i.e. clear it) 
1154			;                ret 
1154			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1154			;                ret     c               ; Yes 
1154			;                cp      'A'             ; Less than 'A'? 
1154			;                jr      nc, is_hex_2    ; No, continue 
1154			;                ccf                     ; Yes - clear carry and return 
1154			;                ret 
1154			;is_hex_2        scf                     ; Set carry 
1154			;                ret 
1154			; 
1154			; Convert a single character contained in A to upper case: 
1154			; 
1154 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1156 d8			                ret     c 
1157 fe 7b		                cp      'z' + 1         ; > 'z'? 
1159 d0			                ret     nc              ; Nothing to do, either 
115a e6 5f		                and     $5f             ; Convert to upper case 
115c c9			                ret 
115d			 
115d			 
115d			to_lower: 
115d			 
115d			   ; if char is in [A-Z] make it lower case 
115d			 
115d			   ; enter : a = char 
115d			   ; exit  : a = lower case char 
115d			   ; uses  : af 
115d			 
115d fe 41		   cp 'A' 
115f d8			   ret c 
1160			    
1160 fe 5b		   cp 'Z'+1 
1162 d0			   ret nc 
1163			    
1163 f6 20		   or $20 
1165 c9			   ret 
1166			 
1166			; 
1166			; Expects a hexadecimal digit (upper case!) in A and returns the 
1166			; corresponding value in A. 
1166			; 
1166 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1168 38 02		                jr      c, nibble2val_1 ; Yes 
116a d6 07		                sub     7               ; Adjust for A-F 
116c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
116e e6 0f		                and     $f              ; Only return lower 4 bits 
1170 c9			                ret 
1171			; 
1171			; Print_nibble prints a single hex nibble which is contained in the lower  
1171			; four bits of A: 
1171			; 
1171			;print_nibble    push    af              ; We won't destroy the contents of A 
1171			;                and     $f              ; Just in case... 
1171			;                add     a, '0'             ; If we have a digit we are done here. 
1171			;                cp      '9' + 1         ; Is the result > 9? 
1171			;                jr      c, print_nibble_1 
1171			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1171			;print_nibble_1  call    putc            ; Print the nibble and 
1171			;                pop     af              ; restore the original value of A 
1171			;                ret 
1171			;; 
1171			;; Send a CR/LF pair: 
1171			; 
1171			;crlf            push    af 
1171			;                ld      a, cr 
1171			;                call    putc 
1171			;                ld      a, lf 
1171			;                call    putc 
1171			;                pop     af 
1171			;                ret 
1171			; 
1171			; Print_word prints the four hex digits of a word to the serial line. The  
1171			; word is expected to be in HL. 
1171			; 
1171			;print_word      push    hl 
1171			;                push    af 
1171			;                ld      a, h 
1171			;                call    print_byte 
1171			;                ld      a, l 
1171			;                call    print_byte 
1171			;                pop     af 
1171			;                pop     hl 
1171			;                ret 
1171			; 
1171			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1171			; The byte to be printed is expected to be in A. 
1171			; 
1171			;print_byte      push    af              ; Save the contents of the registers 
1171			;                push    bc 
1171			;                ld      b, a 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                call    print_nibble    ; Print high nibble 
1171			;                ld      a, b 
1171			;                call    print_nibble    ; Print low nibble 
1171			;                pop     bc              ; Restore original register contents 
1171			;                pop     af 
1171			;                ret 
1171			 
1171			 
1171			 
1171			 
1171			 
1171			fourehexhl:  
1171 7e				ld a,(hl) 
1172 cd 20 11			call atohex 
1175 cb 3f				SRL A 
1177 cb 3f				SRL A 
1179 cb 3f				SRL A 
117b cb 3f				SRL A 
117d 47				ld b, a 
117e 23				inc hl 
117f 7e				ld a,(hl) 
1180 23				inc hl 
1181 cd 20 11			call atohex 
1184 80				add b 
1185 57				ld d,a 
1186 7e				ld a,(hl) 
1187 cd 20 11			call atohex 
118a cb 3f				SRL A 
118c cb 3f				SRL A 
118e cb 3f				SRL A 
1190 cb 3f				SRL A 
1192 47				ld b, a 
1193 23				inc hl 
1194 7e				ld a,(hl) 
1195 23				inc hl 
1196 cd 20 11			call atohex 
1199 80				add b 
119a 5f				ld e, a 
119b d5				push de 
119c e1				pop hl 
119d c9				ret 
119e			 
119e			; pass hl. returns z set if the byte at hl is a digit 
119e			;isdigithl:  
119e			;	push bc 
119e			;	ld a,(hl) 
119e			;	cp ':' 
119e			;	jr nc, .isdf 		; > 
119e			;	cp '0' 
119e			;	jr c, .isdf		; < 
119e			; 
119e			;	; TODO find a better way to set z 
119e			; 
119e			;	ld b,a 
119e			;	cp b 
119e			;	pop bc 
119e			;	ret 
119e			; 
119e			;.isdf:	; not digit so clear z 
119e			; 
119e			;	; TODO find a better way to unset z 
119e			; 
119e			;	ld b,a 
119e			;	inc b 
119e			;	cp b 
119e			; 
119e			;	pop bc 
119e			;	ret 
119e				 
119e				 
119e			 
119e			 
119e			; pass hl as the four byte address to load 
119e			 
119e			get_word_hl:  
119e e5				push hl 
119f cd 3e 11			call get_byte 
11a2				 
11a2 47				ld b, a 
11a3			 
11a3 e1				pop hl 
11a4 23				inc hl 
11a5 23				inc hl 
11a6			 
11a6			; TODO not able to handle a-f  
11a6 7e				ld a,(hl) 
11a7			;	;cp ':' 
11a7			;	cp 'g' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp 'G' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp '0' 
11a7			;	jr c, .single_byte_hl		; < 
11a7			 
11a7				;call isdigithl 
11a7 fe 00			cp 0 
11a9 28 06			jr z, .single_byte_hl 
11ab			 
11ab			.getwhln:   ; hex word so get next byte 
11ab			 
11ab cd 3e 11			call get_byte 
11ae 6f				ld l, a 
11af 60				ld h,b 
11b0 c9				ret 
11b1 68			.single_byte_hl:   ld l,b 
11b2 26 00				ld h,0 
11b4 c9					ret 
11b5			 
11b5			 
11b5			 
11b5			 
11b5 21 34 19			ld hl,asc+1 
11b8			;	ld a, (hl) 
11b8			;	call nibble2val 
11b8 cd 3e 11			call get_byte 
11bb			 
11bb			;	call fourehexhl 
11bb 32 f5 e2			ld (scratch+52),a 
11be				 
11be 21 f3 e2			ld hl,scratch+50 
11c1 22 e4 e5			ld (os_cur_ptr),hl 
11c4			 
11c4 c9				ret 
11c5			 
11c5			 
11c5			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11c5			 
11c5			; Decimal Unsigned Version 
11c5			 
11c5			;Number in a to decimal ASCII 
11c5			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11c5			;Example: display a=56 as "056" 
11c5			;input: a = number 
11c5			;Output: a=0,value of a in the screen 
11c5			;destroys af,bc (don't know about hl and de) 
11c5			DispAToASCII: 
11c5 0e 9c			ld	c,-100 
11c7 cd d1 11			call	.Na1 
11ca 0e f6			ld	c,-10 
11cc cd d1 11			call	.Na1 
11cf 0e ff			ld	c,-1 
11d1 06 2f		.Na1:	ld	b,'0'-1 
11d3 04			.Na2:	inc	b 
11d4 81				add	a,c 
11d5 38 fc			jr	c,.Na2 
11d7 91				sub	c		;works as add 100/10/1 
11d8 f5				push af		;safer than ld c,a 
11d9 78				ld	a,b		;char is in b 
11da			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11da f1				pop af		;safer than ld a,c 
11db c9				ret 
11dc			 
11dc			; Decimal Signed Version 
11dc			 
11dc			; DispA 
11dc			; -------------------------------------------------------------- 
11dc			; Converts a signed integer value to a zero-terminated ASCII 
11dc			; string representative of that value (using radix 10). 
11dc			; -------------------------------------------------------------- 
11dc			; INPUTS: 
11dc			;     HL     Value to convert (two's complement integer). 
11dc			;     DE     Base address of string destination. (pointer). 
11dc			; -------------------------------------------------------------- 
11dc			; OUTPUTS: 
11dc			;     None 
11dc			; -------------------------------------------------------------- 
11dc			; REGISTERS/MEMORY DESTROYED 
11dc			; AF HL 
11dc			; -------------------------------------------------------------- 
11dc			 
11dc			;DispHLToASCII: 
11dc			;   push    de 
11dc			;   push    bc 
11dc			; 
11dc			;; Detect sign of HL. 
11dc			;    bit    7, h 
11dc			;    jr     z, ._DoConvert 
11dc			; 
11dc			;; HL is negative. Output '-' to string and negate HL. 
11dc			;    ld     a, '-' 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			; 
11dc			;; Negate HL (using two's complement) 
11dc			;    xor    a 
11dc			;    sub    l 
11dc			;    ld     l, a 
11dc			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11dc			;    sbc    a, h 
11dc			;    ld     h, a 
11dc			; 
11dc			;; Convert HL to digit characters 
11dc			;._DoConvert: 
11dc			;    ld     b, 0     ; B will count character length of number 
11dc			;-   ld     a, 10 
11dc			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11dc			;    push   af 
11dc			;    inc    b 
11dc			;    ld     a, h 
11dc			;    or     l 
11dc			;    jr     nz, - 
11dc			; 
11dc			;; Retrieve digits from stack 
11dc			;-   pop    af 
11dc			;    or     $30 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			;    djnz   - 
11dc			; 
11dc			;; Terminate string with NULL 
11dc			;    xor    a 
11dc			;    ld     (de), a 
11dc			; 
11dc			;    pop    bc 
11dc			;    pop    de 
11dc			;    ret 
11dc			 
11dc			;Comments 
11dc			; 
11dc			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11dc			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11dc			;    Note that the output string will not be fixed-width. 
11dc			; 
11dc			;Example Usage 
11dc			; 
11dc			;    ld    hl, -1004 
11dc			;    ld    de, OP1 
11dc			;    call  DispA 
11dc			;    ld    hl, OP1 
11dc			;    syscall  PutS 
11dc			 
11dc			 
11dc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11dc			 
11dc			 
11dc			;Converts an ASCII string to an unsigned 16-bit integer 
11dc			;Quits when it reaches a non-decimal digit 
11dc			 
11dc			string_to_uint16: 
11dc			atoui_16: 
11dc			;Input: 
11dc			;     DE points to the string 
11dc			;Outputs: 
11dc			;     HL is the result 
11dc			;     A is the 8-bit value of the number 
11dc			;     DE points to the byte after the number 
11dc			;Destroys: 
11dc			;     BC 
11dc			;       if the string is non-empty, BC is HL/10 
11dc			;Size:  24 bytes 
11dc			;Speed: 42+d(104+{0,9}) 
11dc			;       d is the number of digits in the number 
11dc			;       max is 640 cycles for a 5 digit number 
11dc			;Assuming no leading zeros: 
11dc			;1 digit:  146cc 
11dc			;2 digit:  250cc 
11dc			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11dc			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11dc			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11dc			;avg: 544.81158447265625cc (544+13297/16384) 
11dc			;=============================================================== 
11dc 21 00 00		  ld hl,0 
11df			.u16a: 
11df 1a			  ld a,(de) 
11e0 d6 30		  sub 30h 
11e2 fe 0a		  cp 10 
11e4 d0			  ret nc 
11e5 13			  inc de 
11e6 44			  ld b,h 
11e7 4d			  ld c,l 
11e8 29			  add hl,hl 
11e9 29			  add hl,hl 
11ea 09			  add hl,bc 
11eb 29			  add hl,hl 
11ec 85			  add a,l 
11ed 6f			  ld l,a 
11ee 30 ef		  jr nc,.u16a 
11f0 24			  inc h 
11f1 c3 df 11		  jp .u16a 
11f4			 
11f4			 
11f4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11f4			 
11f4			;written by Zeda 
11f4			;Converts a 16-bit unsigned integer to an ASCII string. 
11f4			 
11f4			uitoa_16: 
11f4			;Input: 
11f4			;   DE is the number to convert 
11f4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11f4			;Output: 
11f4			;   HL points to the null-terminated ASCII string 
11f4			;      NOTE: This isn't necessarily the same as the input HL. 
11f4 d5			  push de 
11f5 c5			  push bc 
11f6 f5			  push af 
11f7 eb			  ex de,hl 
11f8			 
11f8 01 f0 d8		  ld bc,-10000 
11fb 3e 2f		  ld a,'0'-1 
11fd 3c			  inc a 
11fe 09			  add hl,bc  
11ff 38 fc		   jr c,$-2 
1201 12			  ld (de),a 
1202 13			  inc de 
1203			 
1203 01 e8 03		  ld bc,1000 
1206 3e 3a		  ld a,'9'+1 
1208 3d			  dec a  
1209 09			  add hl,bc  
120a 30 fc		   jr nc,$-2 
120c 12			  ld (de),a 
120d 13			  inc de 
120e			 
120e 01 9c ff		  ld bc,-100 
1211 3e 2f		  ld a,'0'-1 
1213 3c			  inc a  
1214 09			  add hl,bc  
1215 38 fc		   jr c,$-2 
1217 12			  ld (de),a 
1218 13			  inc de 
1219			 
1219 7d			  ld a,l 
121a 26 3a		  ld h,'9'+1 
121c 25			  dec h  
121d c6 0a		  add a,10  
121f 30 fb		   jr nc,$-3 
1221 c6 30		  add a,'0' 
1223 eb			  ex de,hl 
1224 72			  ld (hl),d 
1225 23			  inc hl 
1226 77			  ld (hl),a 
1227 23			  inc hl 
1228 36 00		  ld (hl),0 
122a			 
122a			;Now strip the leading zeros 
122a 0e fa		  ld c,-6 
122c 09			  add hl,bc 
122d 3e 30		  ld a,'0' 
122f 23			  inc hl  
1230 be			  cp (hl)  
1231 28 fc		  jr z,$-2 
1233			 
1233			;Make sure that the string is non-empty! 
1233 7e			  ld a,(hl) 
1234 b7			  or a 
1235 20 01		  jr nz,.atoub 
1237 2b			  dec hl 
1238			.atoub: 
1238			 
1238 f1			  pop af 
1239 c1			  pop bc 
123a d1			  pop de 
123b c9			  ret 
123c			 
123c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
123c			 
123c			toUpper: 
123c			;A is the char. 
123c			;If A is a lowercase letter, this sets it to the matching uppercase 
123c			;18cc or 30cc or 41cc 
123c			;avg: 26.75cc 
123c fe 61		  cp 'a' 
123e d8			  ret c 
123f fe 7b		  cp 'z'+1 
1241 d0			  ret nc 
1242 d6 20		  sub 'a'-'A' 
1244 c9			  ret 
1245			 
1245			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1245			 
1245			; String Length 
1245			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1245			 
1245			; Get the length of the null-terminated string starting at $8000 hl 
1245			;    LD     HL, $8000 
1245			 
1245			strlenz: 
1245			 
1245 af			    XOR    A               ; Zero is the value we are looking for. 
1246 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1247 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1248			                           ; 65, 536 bytes (the entire addressable memory space). 
1248 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
124a			 
124a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
124a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
124b 6f			    LD     L, A             ; number of bytes 
124c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
124e 2b			    DEC    HL              ; Compensate for null. 
124f c9				ret 
1250			 
1250			; Get the length of the A terminated string starting at $8000 hl 
1250			;    LD     HL, $8000 
1250			 
1250			strlent: 
1250			 
1250			                  ; A is the value we are looking for. 
1250 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1252 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1254			                           ; 65, 536 bytes (the entire addressable memory space). 
1254 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1256			 
1256			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1256 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1258 2e 00		    LD     L, 0             ; number of bytes 
125a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125c 2b			    DEC    HL              ; Compensate for null. 
125d c9				ret 
125e			 
125e			 
125e			;Comparing Strings 
125e			 
125e			;IN    HL     Address of string1. 
125e			;      DE     Address of string2. 
125e			 
125e			; doc given but wrong??? 
125e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
125e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
125e			; tested 
125e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
125e			 
125e			strcmp_old: 
125e e5			    PUSH   HL 
125f d5			    PUSH   DE 
1260			 
1260 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1261 be			    CP     (HL)            ; (want to minimize work). 
1262 38 01		    JR     C, Str1IsBigger 
1264 7e			    LD     A, (HL) 
1265			 
1265			Str1IsBigger: 
1265 4f			    LD     C, A             ; Put length in BC 
1266 06 00		    LD     B, 0 
1268 13			    INC    DE              ; Increment pointers to meat of string. 
1269 23			    INC    HL 
126a			 
126a			CmpLoop: 
126a 1a			    LD     A, (DE)          ; Compare bytes. 
126b ed a1		    CPI 
126d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
126f 13			    INC    DE              ; Update pointer. 
1270 ea 6a 12		    JP     PE, CmpLoop 
1273			 
1273 d1			    POP    DE 
1274 e1			    POP    HL 
1275 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1276 be			    CP     (HL) 
1277 c9			    RET 
1278			 
1278			NoMatch: 
1278 2b			    DEC    HL 
1279 be			    CP     (HL)            ; Compare again to affect carry. 
127a d1			    POP    DE 
127b e1			    POP    HL 
127c c9			    RET 
127d			 
127d			;; test strmp 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr z, .z1 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z1: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr z, .z2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr c, .c1 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c1: 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr c, .c2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;	NEXTW 
127d			;.str1:   db "string1",0 
127d			;.str2:   db "string2",0 
127d			 
127d			; only care about direct match or not 
127d			; hl and de strings 
127d			; zero set if the same 
127d			 
127d			strcmp: 
127d 1a				ld a, (de) 
127e be				cp (hl) 
127f 28 02			jr z, .ssame 
1281 b7				or a 
1282 c9				ret 
1283			 
1283			.ssame:  
1283 fe 00			cp 0 
1285 c8				ret z 
1286			 
1286 23				inc hl 
1287 13				inc de 
1288 18 f3			jr strcmp 
128a				 
128a				 
128a			 
128a			 
128a			 
128a			 
128a			; eof 
128a			 
128a			 
128a			 
128a			 
128a			 
128a			 
# End of file firmware_strings.asm
128a			include "firmware_memory.asm"   ; malloc and free  
128a			 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			.mallocsize: db "Wants malloc >256",0 
128a			.mallocasize: db "MALLOC gives >256",0 
128a			.malloczero: db "MALLOC gives zero",0 
128a			 
128a			malloc_guard_zerolen: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a				ld de, 0 
128a			        call cmp16 
128a				jr nz, .lowalloz 
128a			 
128a				push hl 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .malloczero 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				call bp_on 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a			.lowalloz: 
128a			 
128a			 
128a				pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_entry: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowalloc 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocsize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a				jr .lowdone 
128a			.lowalloc: 
128a			 
128a			 
128a				pop hl 
128a			.lowdone:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_exit: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowallocx 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocasize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a				pop de 
128a				pop hl 
128a			 
128a				CALLMONITOR 
128a				jr .lowdonex 
128a			.lowallocx: 
128a			 
128a				pop hl 
128a			.lowdonex:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			endif 
128a			 
128a			if MALLOC_2 
128a			; Z80 Malloc and Free Functions 
128a			 
128a			; Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc: 
128a				 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_entry 
128a			endif 
128a			 
128a			 
128a			 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "mal" 
128a						CALLMONITOR 
128a					endif 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of size into A 
128a			    or h               ; Check if size is zero 
128a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
128a			 
128a			    ; Allocate memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma1" 
128a						CALLMONITOR 
128a					endif 
128a			    call malloc_internal ; Call internal malloc function 
128a			    pop af             ; Restore AF register 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret                ; Return 
128a			 
128a			; Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free: 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of pointer into A 
128a			    or h               ; Check if pointer is NULL 
128a			    jp z, free_exit    ; If pointer is NULL, exit 
128a			 
128a			    ; Free memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a			    call free_internal  ; Call internal free function 
128a			    pop af             ; Restore AF register 
128a			    ret                ; Return 
128a			 
128a			; Internal Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc_internal: 
128a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to requested size 
128a			    ex de, hl          ; Save total size in DE, and keep it in HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			 
128a			    ; Search for free memory block 
128a			    ld de, (heap_end)  ; Load end of heap into DE 
128a			    ld bc, 0           ; Initialize counter 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			malloc_search_loop: 
128a			    ; Check if current block is free 
128a			    ld a, (hl)         ; Load current block's status (free or used) 
128a			    cp 0               ; Compare with zero (free) 
128a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
128a			 
128a			    ; Check if current block is large enough 
128a			    ld a, (hl+1)       ; Load high byte of block size 
128a			    cp l               ; Compare with low byte of requested size 
128a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
128a			 
128a			    ld a, (hl+2)       ; Load low byte of block size 
128a			    cp h               ; Compare with high byte of requested size 
128a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
128a			 
128a			    ; Mark block as used 
128a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
128a			 
128a			    ; Calculate remaining space in block 
128a			    ld bc, 0           ; Clear BC 
128a			    add hl, bc         ; Increment HL to point to start of data block 
128a			    add hl, de         ; HL = HL + DE (total size) 
128a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to start of data block 
128a			 
128a			    ; Save pointer to allocated block in HL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma5" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			malloc_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3           ; Size of management overhead 
128a			    add hl, bc         ; Move to the next block 
128a			    inc de             ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e            ; Load low byte of heap end address 
128a			    cp (hl)            ; Compare with low byte of current address 
128a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
128a			    ld a, d            ; Load high byte of heap end address 
128a			    cp 0               ; Check if it's zero (end of memory) 
128a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, allocation failed 
128a			    xor a              ; Set result to NULL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma6" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			malloc_exit: 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma7" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			; Internal Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free_internal: 
128a			    ld de, (heap_start) ; Load start of heap into DE 
128a			    ld bc, 0            ; Initialize counter 
128a			 
128a			free_search_loop: 
128a			    ; Check if current block contains the pointer 
128a			    ld a, l             ; Load low byte of pointer 
128a			    cp (hl+1)           ; Compare with high byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			    ld a, h             ; Load high byte of pointer 
128a			    cp (hl+2)           ; Compare with low byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			 
128a			    ; Mark block as free 
128a			    ld (hl), 0          ; Set status byte to indicate free block 
128a			    ret                 ; Return 
128a			 
128a			free_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3            ; Size of management overhead 
128a			    add hl, bc          ; Move to the next block 
128a			    inc de              ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e             ; Load low byte of heap end address 
128a			    cp (hl)             ; Compare with low byte of current address 
128a			    jr nz, free_search_loop  ; If not equal, continue searching 
128a			    ld a, d             ; Load high byte of heap end address 
128a			    cp 0                ; Check if it's zero (end of memory) 
128a			    jr nz, free_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, pointer is not found in heap 
128a			    ret 
128a			 
128a			free_exit: 
128a			    ret                 ; Return 
128a			 
128a			; Define heap start and end addresses 
128a			;heap_start:    .dw 0xC000   ; Start of heap 
128a			;heap_end:      .dw 0xE000   ; End of heap 
128a			 
128a			endif 
128a			 
128a			 
128a			if MALLOC_1 
128a			 
128a			 
128a			 
128a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
128a			 
128a			;moved to firmware.asm 
128a			;heap_start        .equ  0x9000      ; Starting address of heap 
128a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
128a			 
128a			;      .org 0 
128a			;      jp    main 
128a			 
128a			 
128a			;      .org  0x100 
128a			;main: 
128a			;      ld    HL, 0x8100 
128a			;      ld    SP, HL 
128a			; 
128a			;      call  heap_init 
128a			; 
128a			;      ; Make some allocations 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9004 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9014 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9024 
128a			; 
128a			;      ; Free some allocations 
128a			;      ld    HL, 0x9014 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9004 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9024 
128a			;      call  free 
128a			; 
128a			; 
128a			;      halt 
128a			 
128a			 
128a			;------------------------------------------------------------------------------ 
128a			;     heap_init                                                               : 
128a			;                                                                             : 
128a			; Description                                                                 : 
128a			;     Initialise the heap and make it ready for malloc and free operations.   : 
128a			;                                                                             : 
128a			;     The heap is maintained as a linked list, starting with an initial       : 
128a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
128a			;     the first free block in the heap. Each block then points to the next    : 
128a			;     free block within the heap, and the free list ends at the first block   : 
128a			;     with a null pointer to the next free block.                             : 
128a			;                                                                             : 
128a			; Parameters                                                                  : 
128a			;     Inputs are compile-time only. Two defines which specify the starting    : 
128a			;     address of the heap and its size are required, along with a memory      : 
128a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
128a			;     principally stores a pointer to the first free block in the heap.       : 
128a			;                                                                             : 
128a			; Returns                                                                     : 
128a			;     Nothing                                                                 : 
128a			;------------------------------------------------------------------------------ 
128a			heap_init: 
128a e5			      push  HL 
128b			 
128b			      ; Initialise free list struct 
128b 21 9e 65		      ld    HL, heap_start 
128e 22 99 65		      ld    (free_list), HL 
1291 21 00 00		      ld    HL, 0 
1294 22 9b 65		      ld    (free_list+2), HL 
1297			 
1297			      ; Insert first free block at bottom of heap, consumes entire heap 
1297 21 a4 e2		      ld    HL, heap_start+heap_size-4 
129a 22 9e 65		      ld    (heap_start), HL        ; Next block (end of free list) 
129d 21 06 7d		      ld    HL, heap_size-4 
12a0 22 a0 65		      ld    (heap_start+2), HL      ; Block size 
12a3			 
12a3			      ; Insert end of free list block at top of heap - two null words will 
12a3			      ; terminate the free list 
12a3 21 00 00		      ld    HL, 0 
12a6 22 a6 e2		      ld    (heap_start+heap_size-2), HL 
12a9 22 a4 e2		      ld    (heap_start+heap_size-4), HL 
12ac			 
12ac e1			      pop   HL 
12ad			 
12ad c9			      ret 
12ae			 
12ae			 
12ae			;------------------------------------------------------------------------------ 
12ae			;     malloc                                                                  : 
12ae			;                                                                             : 
12ae			; Description                                                                 : 
12ae			;     Allocates the wanted space from the heap and returns the address of the : 
12ae			;     first useable byte of the allocation.                                   : 
12ae			;                                                                             : 
12ae			;     Allocations can happen in one of two ways:                              : 
12ae			;                                                                             : 
12ae			;     1. A free block may be found which is the exact size wanted. In this    : 
12ae			;        case the block is removed from the free list and retuedn to the      : 
12ae			;        caller.                                                              : 
12ae			;     2. A free block may be found which is larger than the size wanted. In   : 
12ae			;        this case, the larger block is split into two. The first portion of  : 
12ae			;        this block will become the requested space by the malloc call and    : 
12ae			;        is returned to the caller. The second portion becomes a new free     : 
12ae			;        block, and the free list is adjusted to maintain continuity via this : 
12ae			;        newly created block.                                                 : 
12ae			;                                                                             : 
12ae			;     malloc does not set any initial value in the allocated space, the       : 
12ae			;     caller is required to do this as required.                              : 
12ae			;                                                                             : 
12ae			;     This implementation of malloc uses the stack exclusively, and is        : 
12ae			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ae			;     advisable to disable interrupts before calling malloc, and recommended  : 
12ae			;     to avoid the use of malloc inside ISRs in general.                      : 
12ae			;                                                                             : 
12ae			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ae			;                                                                             : 
12ae			; Parameters                                                                  : 
12ae			;     HL  Number of bytes wanted                                              : 
12ae			;                                                                             : 
12ae			; Returns                                                                     : 
12ae			;     HL  Address of the first useable byte of the allocation                 : 
12ae			;                                                                             : 
12ae			; Flags                                                                       : 
12ae			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12ae			;                                                                             : 
12ae			; Stack frame                                                                 : 
12ae			;       |             |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     BC      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     DE      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     IX      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |  prev_free  |                                                       : 
12ae			;   +4  +-------------+                                                       : 
12ae			;       |  this_free  |                                                       : 
12ae			;   +2  +-------------+                                                       : 
12ae			;       |  next_free  |                                                       : 
12ae			;   +0  +-------------+                                                       : 
12ae			;       |             |                                                       : 
12ae			;                                                                             : 
12ae			;------------------------------------------------------------------------------ 
12ae			 
12ae			 
12ae			;malloc: 
12ae			; 
12ae			;	SAVESP ON 1 
12ae			; 
12ae			;	call malloc_code 
12ae			; 
12ae			;	CHECKSP ON 1 
12ae			;	ret 
12ae			 
12ae			 
12ae			malloc: 
12ae c5			      push  BC 
12af d5			      push  DE 
12b0 dd e5		      push  IX 
12b2			if DEBUG_FORTH_MALLOC_HIGH 
12b2			call malloc_guard_entry 
12b2			endif 
12b2			 
12b2					if DEBUG_FORTH_MALLOC 
12b2						DMARK "mal" 
12b2						CALLMONITOR 
12b2					endif 
12b2 7c			      ld    A, H                    ; Exit if no space requested 
12b3 b5			      or    L 
12b4 ca 73 13		      jp    Z, malloc_early_exit 
12b7			 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			; 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			 
12b7			 
12b7			 
12b7			 
12b7					if DEBUG_FORTH_MALLOC 
12b7						DMARK "maA" 
12b7						CALLMONITOR 
12b7					endif 
12b7			      ; Set up stack frame 
12b7 eb			      ex    DE, HL 
12b8 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12bb 39			      add   HL, SP 
12bc f9			      ld    SP, HL 
12bd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c1 dd 39		      add   IX, SP 
12c3			 
12c3			      ; Setup initial state 
12c3 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12c6 19			      add   HL, DE 
12c7			 
12c7 44			      ld    B, H                    ; Move want to BC 
12c8 4d			      ld    C, L 
12c9			 
12c9 21 99 65		      ld    HL, free_list           ; Store prev_free ptr to stack 
12cc dd 75 04		      ld    (IX+4), L 
12cf dd 74 05		      ld    (IX+5), H 
12d2			 
12d2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12d3 23			      inc   HL 
12d4 56			      ld    D, (HL) 
12d5 dd 73 02		      ld    (IX+2), E 
12d8 dd 72 03		      ld    (IX+3), D 
12db eb			      ex    DE, HL                  ; this_free ptr into HL 
12dc			 
12dc					if DEBUG_FORTH_MALLOC 
12dc						DMARK "maB" 
12dc						CALLMONITOR 
12dc					endif 
12dc			      ; Loop through free block list to find some space 
12dc			malloc_find_space: 
12dc 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12dd 23			      inc   HL 
12de 56			      ld    D, (HL) 
12df			 
12df 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12e0 b3			      or    E 
12e1 ca 6d 13		      jp    Z, malloc_no_space 
12e4			 
12e4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12e7 dd 72 01		      ld    (IX+1), D 
12ea			 
12ea			      ; Does this block have enough space to make the allocation? 
12ea 23			      inc   HL                      ; Load free block size into DE 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee			 
12ee eb			      ex    DE, HL                  ; Check size of block against want 
12ef b7			      or    A                       ; Ensure carry flag clear 
12f0 ed 42		      sbc   HL, BC 
12f2 e5			      push  HL                      ; Store the result for later (new block size) 
12f3			 
12f3 ca 42 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12f6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12f8			 
12f8			      ; this_free block is not big enough, setup ptrs to test next free block 
12f8 e1			      pop   HL                      ; Discard previous result 
12f9			 
12f9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12fc dd 66 03		      ld    H, (IX+3) 
12ff dd 75 04		      ld    (IX+4), L 
1302 dd 74 05		      ld    (IX+5), H 
1305			 
1305 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1308 dd 66 01		      ld    H, (IX+1) 
130b dd 75 02		      ld    (IX+2), L 
130e dd 74 03		      ld    (IX+3), H 
1311			 
1311					if DEBUG_FORTH_MALLOC 
1311						DMARK "MA>" 
1311						CALLMONITOR 
1311					endif 
1311 18 c9		      jr    malloc_find_space 
1313			 
1313			      ; split a bigger block into two - requested size and remaining size 
1313			malloc_alloc_split: 
1313					if DEBUG_FORTH_MALLOC 
1313						DMARK "MAs" 
1313						CALLMONITOR 
1313					endif 
1313 eb			      ex    DE, HL                  ; Calculate address of new free block 
1314 2b			      dec   HL 
1315 2b			      dec   HL 
1316 2b			      dec   HL 
1317 09			      add   HL, BC 
1318			 
1318			      ; Create a new block and point it at next_free 
1318 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
131b dd 56 01		      ld    D, (IX+1) 
131e			 
131e 73			      ld    (HL), E                 ; Store next_free ptr into new block 
131f 23			      inc   HL 
1320 72			      ld    (HL), D 
1321			 
1321 d1			      pop   DE                      ; Store size of new block into new block 
1322 23			      inc   HL 
1323 73			      ld    (HL), E 
1324 23			      inc   HL 
1325 72			      ld    (HL), D 
1326			 
1326			      ; Update this_free ptr to point to new block 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328 2b			      dec   HL 
1329			 
1329 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
132c dd 56 03		      ld    D, (IX+3) 
132f			 
132f dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1332 dd 74 03		      ld    (IX+3), H 
1335			 
1335			      ; Modify this_free block to be allocation 
1335 eb			      ex    DE, HL 
1336 af			      xor   A                       ; Null the next block ptr of allocated block 
1337 77			      ld    (HL), A 
1338 23			      inc   HL 
1339 77			      ld    (HL), A 
133a			 
133a 23			      inc   HL                      ; Store want size into allocated block 
133b 71			      ld    (HL), C 
133c 23			      inc   HL 
133d 70			      ld    (HL), B 
133e 23			      inc   HL 
133f e5			      push  HL                      ; Address of allocation to return 
1340			 
1340 18 19		      jr    malloc_update_links 
1342			 
1342			malloc_alloc_fit: 
1342 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1343			 
1343					if DEBUG_FORTH_MALLOC 
1343						DMARK "MAf" 
1343						CALLMONITOR 
1343					endif 
1343			      ; Modify this_free block to be allocation 
1343 eb			      ex    DE, HL 
1344 2b			      dec   HL 
1345 2b			      dec   HL 
1346 2b			      dec   HL 
1347			 
1347 af			      xor   A                       ; Null the next block ptr of allocated block 
1348 77			      ld    (HL), A 
1349 23			      inc   HL 
134a 77			      ld    (HL), A 
134b			 
134b 23			      inc   HL                      ; Store address of allocation to return 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e e5			      push  HL 
134f			 
134f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
134f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1352 dd 66 01		      ld    H, (IX+1) 
1355			 
1355 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1358 dd 74 03		      ld    (IX+3), H 
135b			 
135b			 
135b			malloc_update_links: 
135b			      ; Update prev_free ptr to point to this_free 
135b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
135e dd 66 05		      ld    H, (IX+5) 
1361			 
1361 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1364 dd 56 03		      ld    D, (IX+3) 
1367			 
1367 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1368 23			      inc   HL 
1369 72			      ld    (HL), D 
136a			 
136a					if DEBUG_FORTH_MALLOC 
136a						DMARK "Mul" 
136a						CALLMONITOR 
136a					endif 
136a			      ; Clear the Z flag to indicate successful allocation 
136a 7a			      ld    A, D 
136b b3			      or    E 
136c			 
136c d1			      pop   DE                      ; Address of allocation 
136d					if DEBUG_FORTH_MALLOC 
136d						DMARK "MAu" 
136d						CALLMONITOR 
136d					endif 
136d			 
136d			malloc_no_space: 
136d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1370 39			      add   HL, SP 
1371 f9			      ld    SP, HL 
1372			 
1372 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAN" 
1373						CALLMONITOR 
1373					endif 
1373			 
1373			malloc_early_exit: 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAx" 
1373						CALLMONITOR 
1373					endif 
1373 dd e1		      pop   IX 
1375 d1			      pop   DE 
1376 c1			      pop   BC 
1377			 
1377			if DEBUG_FORTH_MALLOC_HIGH 
1377			call malloc_guard_exit 
1377			call malloc_guard_zerolen 
1377			endif 
1377 c9			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     free                                                                    : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1378			;     returned by malloc, otherwise the behaviour is undefined.               : 
1378			;                                                                             : 
1378			;     Where possible, directly adjacent free blocks will be merged together   : 
1378			;     into larger blocks to help ensure that the heap does not become         : 
1378			;     excessively fragmented.                                                 : 
1378			;                                                                             : 
1378			;     free does not clear or set any other value into the freed space, and    : 
1378			;     therefore its contents may be visible through subsequent malloc's. The  : 
1378			;     caller should clear the freed space as required.                        : 
1378			;                                                                             : 
1378			;     This implementation of free uses the stack exclusively, and is          : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling free, and recommended    : 
1378			;     to avoid the use of free inside ISRs in general.                        : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Pointer to address of first byte of allocation to be freed          : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     Nothing                                                                 : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			free: 
1378 c5			      push  BC 
1379 d5			      push  DE 
137a dd e5		      push  IX 
137c			 
137c 7c			      ld    A, H                    ; Exit if ptr is null 
137d b5			      or    L 
137e ca 42 14		      jp    Z, free_early_exit 
1381			 
1381			      ; Set up stack frame 
1381 eb			      ex    DE, HL 
1382 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1385 39			      add   HL, SP 
1386 f9			      ld    SP, HL 
1387 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
138b dd 39		      add   IX, SP 
138d			 
138d			      ; The address in HL points to the start of the useable allocated space, 
138d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
138d			      ; address of the block itself. 
138d eb			      ex    DE, HL 
138e 11 fc ff		      ld    DE, -4 
1391 19			      add   HL, DE 
1392			 
1392			      ; An allocated block must have a null next block pointer in it 
1392 7e			      ld    A, (HL) 
1393 23			      inc   HL 
1394 b6			      or    (HL) 
1395 c2 3d 14		      jp    NZ, free_done 
1398			 
1398 2b			      dec   HL 
1399			 
1399 44			      ld    B, H                    ; Copy HL to BC 
139a 4d			      ld    C, L 
139b			 
139b			      ; Loop through the free list to find the first block with an address 
139b			      ; higher than the block being freed 
139b 21 99 65		      ld    HL, free_list 
139e			 
139e			free_find_higher_block: 
139e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
139f 23			      inc   HL 
13a0 56			      ld    D, (HL) 
13a1 2b			      dec   HL 
13a2			 
13a2 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13a5 dd 72 01		      ld    (IX+1), D 
13a8 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13ab dd 74 03		      ld    (IX+3), H 
13ae			 
13ae 78			      ld    A, B                    ; Check if DE is greater than BC 
13af ba			      cp    D                       ; Compare MSB first 
13b0 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13b2 30 04		      jr    NC, free_find_higher_block_skip 
13b4 79			      ld    A, C 
13b5 bb			      cp    E                       ; Then compare LSB 
13b6 38 08		      jr    C, free_found_higher_block 
13b8			 
13b8			free_find_higher_block_skip: 
13b8 7a			      ld    A, D                    ; Reached the end of the free list? 
13b9 b3			      or    E 
13ba ca 3d 14		      jp    Z, free_done 
13bd			 
13bd eb			      ex    DE, HL 
13be			 
13be 18 de		      jr    free_find_higher_block 
13c0			 
13c0			free_found_higher_block: 
13c0			      ; Insert freed block between prev and next free blocks 
13c0 71			      ld    (HL), C                 ; Point prev free block to freed block 
13c1 23			      inc   HL 
13c2 70			      ld    (HL), B 
13c3			 
13c3 60			      ld    H, B                    ; Point freed block at next free block 
13c4 69			      ld    L, C 
13c5 73			      ld    (HL), E 
13c6 23			      inc   HL 
13c7 72			      ld    (HL), D 
13c8			 
13c8			      ; Check if the freed block is adjacent to the next free block 
13c8 23			      inc   HL                      ; Load size of freed block into HL 
13c9 5e			      ld    E, (HL) 
13ca 23			      inc   HL 
13cb 56			      ld    D, (HL) 
13cc eb			      ex    DE, HL 
13cd			 
13cd 09			      add   HL, BC                  ; Add addr of freed block and its size 
13ce			 
13ce dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13d1 dd 56 01		      ld    D, (IX+1) 
13d4			 
13d4 b7			      or    A                       ; Clear the carry flag 
13d5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13d7 20 22		      jr    NZ, free_check_adjacent_to_prev 
13d9			 
13d9			      ; Freed block is adjacent to next, merge into one bigger block 
13d9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13da 5e			      ld    E, (HL) 
13db 23			      inc   HL 
13dc 56			      ld    D, (HL) 
13dd e5			      push  HL                      ; Save ptr to next block for later 
13de			 
13de 60			      ld    H, B                    ; Store ptr from next block into freed block 
13df 69			      ld    L, C 
13e0 73			      ld    (HL), E 
13e1 23			      inc   HL 
13e2 72			      ld    (HL), D 
13e3			 
13e3 e1			      pop   HL                      ; Restore ptr to next block 
13e4 23			      inc   HL                      ; Load size of next block into DE 
13e5 5e			      ld    E, (HL) 
13e6 23			      inc   HL 
13e7 56			      ld    D, (HL) 
13e8 d5			      push  DE                      ; Save next block size for later 
13e9			 
13e9 60			      ld    H, B                    ; Load size of freed block into HL 
13ea 69			      ld    L, C 
13eb 23			      inc   HL 
13ec 23			      inc   HL 
13ed 5e			      ld    E, (HL) 
13ee 23			      inc   HL 
13ef 56			      ld    D, (HL) 
13f0 eb			      ex    DE, HL 
13f1			 
13f1 d1			      pop   DE                      ; Restore size of next block 
13f2 19			      add   HL, DE                  ; Add sizes of both blocks 
13f3 eb			      ex    DE, HL 
13f4			 
13f4 60			      ld    H, B                    ; Store new bigger size into freed block 
13f5 69			      ld    L, C 
13f6 23			      inc   HL 
13f7 23			      inc   HL 
13f8 73			      ld    (HL), E 
13f9 23			      inc   HL 
13fa 72			      ld    (HL), D 
13fb			 
13fb			free_check_adjacent_to_prev: 
13fb			      ; Check if the freed block is adjacent to the prev free block 
13fb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13fe dd 66 03		      ld    H, (IX+3) 
1401			 
1401 23			      inc   HL                      ; Size of prev free block into DE 
1402 23			      inc   HL 
1403 5e			      ld    E, (HL) 
1404 23			      inc   HL 
1405 56			      ld    D, (HL) 
1406 2b			      dec   HL 
1407 2b			      dec   HL 
1408 2b			      dec   HL 
1409			 
1409 19			      add   HL, DE                  ; Add prev block addr and size 
140a			 
140a b7			      or    A                       ; Clear the carry flag 
140b ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140d 20 2e		      jr    NZ, free_done 
140f			 
140f			      ; Freed block is adjacent to prev, merge into one bigger block 
140f 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1410 69			      ld    L, C 
1411 5e			      ld    E, (HL) 
1412 23			      inc   HL 
1413 56			      ld    D, (HL) 
1414 e5			      push  HL                      ; Save freed block ptr for later 
1415			 
1415 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1418 dd 66 03		      ld    H, (IX+3) 
141b 73			      ld    (HL), E 
141c 23			      inc   HL 
141d 72			      ld    (HL), D 
141e			 
141e e1			      pop   HL                      ; Restore freed block ptr 
141f 23			      inc   HL                      ; Load size of freed block into DE 
1420 5e			      ld    E, (HL) 
1421 23			      inc   HL 
1422 56			      ld    D, (HL) 
1423 d5			      push  DE                      ; Save freed block size for later 
1424			 
1424 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1427 dd 66 03		      ld    H, (IX+3) 
142a 23			      inc   HL 
142b 23			      inc   HL 
142c 5e			      ld    E, (HL) 
142d 23			      inc   HL 
142e 56			      ld    D, (HL) 
142f			 
142f e1			      pop   HL                      ; Add sizes of both blocks 
1430 19			      add   HL, DE 
1431 eb			      ex    DE, HL 
1432			 
1432 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1435 dd 66 03		      ld    H, (IX+3) 
1438 23			      inc   HL 
1439 23			      inc   HL 
143a 73			      ld    (HL), E 
143b 23			      inc   HL 
143c 72			      ld    (HL), D 
143d			 
143d			free_done: 
143d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1440 39			      add   HL, SP 
1441 f9			      ld    SP, HL 
1442			 
1442			free_early_exit: 
1442 dd e1		      pop   IX 
1444 d1			      pop   DE 
1445 c1			      pop   BC 
1446			 
1446 c9			      ret 
1447			 
1447			; moved to firmware.asm 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			;                  .dw   0 
1447			 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_3 
1447			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1447			;heap_start        .equ  0x9000      ; Starting address of heap 
1447			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1447			; 
1447			 ;     .org 0 
1447			  ;    jp    main 
1447			; 
1447			; 
1447			 ;     .org  0x100 
1447			;main: 
1447			 ;     ld    HL, 0x8100 
1447			  ;    ld    SP, HL 
1447			; 
1447			;      call  heap_init 
1447			 
1447			      ; Make some allocations 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9004 
1447			; 
1447			 ;     ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9014 
1447			 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9024 
1447			 
1447			      ; Free some allocations 
1447			;      ld    HL, 0x9014 
1447			;      call  free 
1447			 
1447			;      ld    HL, 0x9004 
1447			;      call  free 
1447			; 
1447			;      ld    HL, 0x9024 
1447			;      call  free 
1447			 
1447			 
1447			 ;     halt 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     heap_init                                                               : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Initialise the heap and make it ready for malloc and free operations.   : 
1447			;                                                                             : 
1447			;     The heap is maintained as a linked list, starting with an initial       : 
1447			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1447			;     the first free block in the heap. Each block then points to the next    : 
1447			;     free block within the heap, and the free list ends at the first block   : 
1447			;     with a null pointer to the next free block.                             : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     Inputs are compile-time only. Two defines which specify the starting    : 
1447			;     address of the heap and its size are required, along with a memory      : 
1447			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1447			;     principally stores a pointer to the first free block in the heap.       : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;------------------------------------------------------------------------------ 
1447			heap_init: 
1447			      push  HL 
1447			 
1447			      ; Initialise free list struct 
1447			      ld    HL, heap_start 
1447			      ld    (free_list), HL 
1447			      ld    HL, 0 
1447			      ld    (free_list+2), HL 
1447			 
1447			      ; Insert first free block at bottom of heap, consumes entire heap 
1447			      ld    HL, heap_start+heap_size-4 
1447			      ld    (heap_start), HL        ; Next block (end of free list) 
1447			      ld    HL, heap_size-4 
1447			      ld    (heap_start+2), HL      ; Block size 
1447			 
1447			      ; Insert end of free list block at top of heap - two null words will 
1447			      ; terminate the free list 
1447			      ld    HL, 0 
1447			      ld    (heap_start+heap_size-2), HL 
1447			      ld    (heap_start+heap_size-4), HL 
1447			 
1447			      pop   HL 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     malloc                                                                  : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Allocates the wanted space from the heap and returns the address of the : 
1447			;     first useable byte of the allocation.                                   : 
1447			;                                                                             : 
1447			;     Allocations can happen in one of two ways:                              : 
1447			;                                                                             : 
1447			;     1. A free block may be found which is the exact size wanted. In this    : 
1447			;        case the block is removed from the free list and retuedn to the      : 
1447			;        caller.                                                              : 
1447			;     2. A free block may be found which is larger than the size wanted. In   : 
1447			;        this case, the larger block is split into two. The first portion of  : 
1447			;        this block will become the requested space by the malloc call and    : 
1447			;        is returned to the caller. The second portion becomes a new free     : 
1447			;        block, and the free list is adjusted to maintain continuity via this : 
1447			;        newly created block.                                                 : 
1447			;                                                                             : 
1447			;     malloc does not set any initial value in the allocated space, the       : 
1447			;     caller is required to do this as required.                              : 
1447			;                                                                             : 
1447			;     This implementation of malloc uses the stack exclusively, and is        : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling malloc, and recommended  : 
1447			;     to avoid the use of malloc inside ISRs in general.                      : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Number of bytes wanted                                              : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     HL  Address of the first useable byte of the allocation                 : 
1447			;                                                                             : 
1447			; Flags                                                                       : 
1447			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +4  +-------------+                                                       : 
1447			;       |  this_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			malloc: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if no space requested 
1447			      or    L 
1447			      jp    Z, malloc_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; Setup initial state 
1447			      ld    HL, 4                   ; want must also include space used by block struct 
1447			      add   HL, DE 
1447			 
1447			      ld    B, H                    ; Move want to BC 
1447			      ld    C, L 
1447			 
1447			      ld    HL, free_list           ; Store prev_free ptr to stack 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    E, (HL)                 ; Store this_free ptr to stack 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ld    (IX+2), E 
1447			      ld    (IX+3), D 
1447			      ex    DE, HL                  ; this_free ptr into HL 
1447			 
1447			      ; Loop through free block list to find some space 
1447			malloc_find_space: 
1447			      ld    E, (HL)                 ; Load next_free ptr into DE 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1447			      or    E 
1447			      jp    Z, malloc_no_space 
1447			 
1447			      ld    (IX+0), E               ; Store next_free ptr to stack 
1447			      ld    (IX+1), D 
1447			 
1447			      ; Does this block have enough space to make the allocation? 
1447			      inc   HL                      ; Load free block size into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ex    DE, HL                  ; Check size of block against want 
1447			      or    A                       ; Ensure carry flag clear 
1447			      sbc   HL, BC 
1447			      push  HL                      ; Store the result for later (new block size) 
1447			 
1447			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1447			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1447			 
1447			      ; this_free block is not big enough, setup ptrs to test next free block 
1447			      pop   HL                      ; Discard previous result 
1447			 
1447			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1447			      ld    H, (IX+3) 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1447			      ld    H, (IX+1) 
1447			      ld    (IX+2), L 
1447			      ld    (IX+3), H 
1447			 
1447			      jr    malloc_find_space 
1447			 
1447			      ; split a bigger block into two - requested size and remaining size 
1447			malloc_alloc_split: 
1447			      ex    DE, HL                  ; Calculate address of new free block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      add   HL, BC 
1447			 
1447			      ; Create a new block and point it at next_free 
1447			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      ld    (HL), E                 ; Store next_free ptr into new block 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   DE                      ; Store size of new block into new block 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Update this_free ptr to point to new block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1447			      ld    (IX+3), H 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store want size into allocated block 
1447			      ld    (HL), C 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			      inc   HL 
1447			      push  HL                      ; Address of allocation to return 
1447			 
1447			      jr    malloc_update_links 
1447			 
1447			malloc_alloc_fit: 
1447			      pop   HL                      ; Dont need new block size, want is exact fit 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store address of allocation to return 
1447			      inc   HL 
1447			      inc   HL 
1447			      push  HL 
1447			 
1447			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1447			      ld    L, (IX+0)               ; next_free to HL 
1447			      ld    H, (IX+1) 
1447			 
1447			      ld    (IX+2), L               ; HL to this_free 
1447			      ld    (IX+3), H 
1447			 
1447			 
1447			malloc_update_links: 
1447			      ; Update prev_free ptr to point to this_free 
1447			      ld    L, (IX+4)               ; prev_free ptr to HL 
1447			      ld    H, (IX+5) 
1447			 
1447			      ld    E, (IX+2)               ; this_free ptr to DE 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (HL), E                 ; this_free ptr into prev_free 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Clear the Z flag to indicate successful allocation 
1447			      ld    A, D 
1447			      or    E 
1447			 
1447			      pop   DE                      ; Address of allocation 
1447			 
1447			malloc_no_space: 
1447			      ld    HL, 6                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			      ex    DE, HL                  ; Alloc addr into HL for return 
1447			 
1447			malloc_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     free                                                                    : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1447			;     returned by malloc, otherwise the behaviour is undefined.               : 
1447			;                                                                             : 
1447			;     Where possible, directly adjacent free blocks will be merged together   : 
1447			;     into larger blocks to help ensure that the heap does not become         : 
1447			;     excessively fragmented.                                                 : 
1447			;                                                                             : 
1447			;     free does not clear or set any other value into the freed space, and    : 
1447			;     therefore its contents may be visible through subsequent malloc's. The  : 
1447			;     caller should clear the freed space as required.                        : 
1447			;                                                                             : 
1447			;     This implementation of free uses the stack exclusively, and is          : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling free, and recommended    : 
1447			;     to avoid the use of free inside ISRs in general.                        : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Pointer to address of first byte of allocation to be freed          : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			free: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if ptr is null 
1447			      or    L 
1447			      jp    Z, free_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; The address in HL points to the start of the useable allocated space, 
1447			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1447			      ; address of the block itself. 
1447			      ex    DE, HL 
1447			      ld    DE, -4 
1447			      add   HL, DE 
1447			 
1447			      ; An allocated block must have a null next block pointer in it 
1447			      ld    A, (HL) 
1447			      inc   HL 
1447			      or    (HL) 
1447			      jp    NZ, free_done 
1447			 
1447			      dec   HL 
1447			 
1447			      ld    B, H                    ; Copy HL to BC 
1447			      ld    C, L 
1447			 
1447			      ; Loop through the free list to find the first block with an address 
1447			      ; higher than the block being freed 
1447			      ld    HL, free_list 
1447			 
1447			free_find_higher_block: 
1447			      ld    E, (HL)                 ; Load next ptr from free block 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			 
1447			      ld    (IX+0), E               ; Save ptr to next free block 
1447			      ld    (IX+1), D 
1447			      ld    (IX+2), L               ; Save ptr to prev free block 
1447			      ld    (IX+3), H 
1447			 
1447			      ld    A, B                    ; Check if DE is greater than BC 
1447			      cp    D                       ; Compare MSB first 
1447			      jr    Z, $+4                  ; MSB the same, compare LSB 
1447			      jr    NC, free_find_higher_block_skip 
1447			      ld    A, C 
1447			      cp    E                       ; Then compare LSB 
1447			      jr    C, free_found_higher_block 
1447			 
1447			free_find_higher_block_skip: 
1447			      ld    A, D                    ; Reached the end of the free list? 
1447			      or    E 
1447			      jp    Z, free_done 
1447			 
1447			      ex    DE, HL 
1447			 
1447			      jr    free_find_higher_block 
1447			 
1447			free_found_higher_block: 
1447			      ; Insert freed block between prev and next free blocks 
1447			      ld    (HL), C                 ; Point prev free block to freed block 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			 
1447			      ld    H, B                    ; Point freed block at next free block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Check if the freed block is adjacent to the next free block 
1447			      inc   HL                      ; Load size of freed block into HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      add   HL, BC                  ; Add addr of freed block and its size 
1447			 
1447			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_check_adjacent_to_prev 
1447			 
1447			      ; Freed block is adjacent to next, merge into one bigger block 
1447			      ex    DE, HL                  ; Load next ptr from next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save ptr to next block for later 
1447			 
1447			      ld    H, B                    ; Store ptr from next block into freed block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore ptr to next block 
1447			      inc   HL                      ; Load size of next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save next block size for later 
1447			 
1447			      ld    H, B                    ; Load size of freed block into HL 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      pop   DE                      ; Restore size of next block 
1447			      add   HL, DE                  ; Add sizes of both blocks 
1447			      ex    DE, HL 
1447			 
1447			      ld    H, B                    ; Store new bigger size into freed block 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_check_adjacent_to_prev: 
1447			      ; Check if the freed block is adjacent to the prev free block 
1447			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1447			      ld    H, (IX+3) 
1447			 
1447			      inc   HL                      ; Size of prev free block into DE 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      add   HL, DE                  ; Add prev block addr and size 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_done 
1447			 
1447			      ; Freed block is adjacent to prev, merge into one bigger block 
1447			      ld    H, B                    ; Load next ptr from freed block into DE 
1447			      ld    L, C 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save freed block ptr for later 
1447			 
1447			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1447			      ld    H, (IX+3) 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore freed block ptr 
1447			      inc   HL                      ; Load size of freed block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save freed block size for later 
1447			 
1447			      ld    L, (IX+2)               ; Load size of prev block into DE 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      pop   HL                      ; Add sizes of both blocks 
1447			      add   HL, DE 
1447			      ex    DE, HL 
1447			 
1447			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_done: 
1447			      ld    HL, 4                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			free_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;      .org 0x8000 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			 ;                 .dw   0 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_4 
1447			 
1447			; My memory allocation code. Very very simple.... 
1447			; allocate space under 250 chars 
1447			 
1447			heap_init: 
1447				; init start of heap as zero 
1447				;  
1447			 
1447				ld hl, heap_start 
1447				ld a, 0 
1447				ld (hl), a      ; empty block 
1447				inc hl 
1447				ld a, 0 
1447				ld (hl), a      ; length of block 
1447				; write end of list 
1447				inc hl 
1447				ld a,(hl) 
1447				inc hl 
1447				ld a,(hl) 
1447				 
1447			 
1447				; init some malloc vars 
1447			 
1447				ld hl, 0 
1447				ld (free_list), hl       ; store last malloc location 
1447			 
1447				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1447				ld a, 0 
1447				ld (hl), a 
1447			 
1447			 
1447				ld hl, heap_start 
1447				;  
1447				  
1447				ret 
1447			 
1447			 
1447			;    free block marker 
1447			;    requested size  
1447			;    pointer to next block 
1447			;    .... 
1447			;    next block marker 
1447			 
1447			 
1447			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1447			; 
1447			 
1447			 
1447			malloc:  
1447				push de 
1447				push bc 
1447				push af 
1447			 
1447				; hl space required 
1447				 
1447				ld c, l    ; hold space   (TODO only a max of 255) 
1447			 
1447			;	inc c     ; TODO BUG need to fix memory leak on push str 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			 
1447			 
1447			 
1447				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1447			 
1447				ld a, (free_list+3) 
1447				cp 0 
1447				jr z, .contheap 
1447			 
1447				ld hl, (free_list)     ; get last alloc 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mrs" 
1447						CALLMONITOR 
1447					endif 
1447				jr .startalloc 
1447			 
1447			.contheap: 
1447				ld hl, heap_start 
1447			 
1447			.startalloc: 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mym" 
1447						CALLMONITOR 
1447					endif 
1447			.findblock: 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmf" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447				ld a,(hl)  
1447				; if byte is zero then clear to use 
1447			 
1447				cp 0 
1447				jr z, .foundemptyblock 
1447			 
1447				; if byte is not clear 
1447				;     then byte is offset to next block 
1447			 
1447				inc hl 
1447				ld a, (hl) ; get size 
1447			.nextblock:	inc hl 
1447					ld e, (hl) 
1447					inc hl 
1447					ld d, (hl) 
1447					ex de, hl 
1447			;	inc hl  ; move past the store space 
1447			;	inc hl  ; move past zero index  
1447			 
1447				; TODO detect no more space 
1447			 
1447				push hl 
1447				ld de, heap_end 
1447				call cmp16 
1447				pop hl 
1447				jr nc, .nospace 
1447			 
1447				jr .findblock 
1447			 
1447			.nospace: ld hl, 0 
1447				jp .exit 
1447			 
1447			 
1447			.foundemptyblock:	 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mme" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; TODO has block enough space if reusing??? 
1447			 
1447				;  
1447			 
1447			; see if this block has been previously used 
1447				inc hl 
1447				ld a, (hl) 
1447				dec hl 
1447				cp 0 
1447				jr z, .newblock 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meR" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; no reusing previously allocated block 
1447			 
1447			; is it smaller than previously used? 
1447				 
1447				inc hl    ; move to size 
1447				ld a, c 
1447				sub (hl)        ; we want c < (hl) 
1447				dec hl    ; move back to marker 
1447			        jr z, .findblock 
1447			 
1447				; update with the new size which should be lower 
1447			 
1447			        ;inc  hl   ; negate next move. move back to size  
1447			 
1447			.newblock: 
1447				; need to be at marker here 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meN" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			 
1447				ld a, c 
1447			 
1447				ld (free_list+3), a	 ; flag resume from last malloc  
1447				ld (free_list), hl    ; save out last location 
1447			 
1447			 
1447				;inc a     ; space for length byte 
1447				ld (hl), a     ; save block in use marker 
1447			 
1447				inc hl   ; move to space marker 
1447				ld (hl), a    ; save new space 
1447			 
1447				inc hl   ; move to start of allocated area 
1447				 
1447			;	push hl     ; save where we are - 1  
1447			 
1447			;	inc hl  ; move past zero index  
1447				; skip space to set down new marker 
1447			 
1447				; provide some extra space for now 
1447			 
1447				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1447				inc a 
1447				inc a 
1447			 
1447				push hl   ; save where we are in the node block 
1447			 
1447				call addatohl 
1447			 
1447				; write linked list point 
1447			 
1447				pop de     ; get our node position 
1447				ex de, hl 
1447			 
1447				ld (hl), e 
1447				inc hl 
1447				ld (hl), d 
1447			 
1447				inc hl 
1447			 
1447				; now at start of allocated data so save pointer 
1447			 
1447				push hl 
1447			 
1447				; jump to position of next node and setup empty header in DE 
1447			 
1447				ex de, hl 
1447			 
1447			;	inc hl ; move past end of block 
1447			 
1447				ld a, 0 
1447				ld (hl), a   ; empty marker 
1447				inc hl 
1447				ld (hl), a   ; size 
1447				inc hl  
1447				ld (hl), a   ; ptr 
1447				inc hl 
1447				ld (hl), a   ; ptr 
1447			 
1447			 
1447				pop hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmr" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			.exit: 
1447				pop af 
1447				pop bc 
1447				pop de  
1447				ret 
1447			 
1447			 
1447			 
1447			 
1447			free:  
1447				push hl 
1447				push af 
1447				; get address in hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "fre" 
1447						CALLMONITOR 
1447					endif 
1447				; data is at hl - move to block count 
1447				dec hl 
1447				dec hl    ; get past pointer 
1447				dec hl 
1447			 
1447				ld a, (hl)    ; need this for a validation check 
1447			 
1447				dec hl    ; move to block marker 
1447			 
1447				; now check that the block count and block marker are the same  
1447			        ; this checks that we are on a malloc node and not random memory 
1447			        ; OK a faint chance this could be a problem but rare - famous last words! 
1447			 
1447				ld c, a 
1447				ld a, (hl)    
1447			 
1447				cp c 
1447				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1447			 
1447				; yes good chance we are on a malloc node 
1447			 
1447				ld a, 0      
1447				ld (hl), a   ; mark as free 
1447			 
1447				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1447			 
1447			.freeignore:  
1447			 
1447				pop af 
1447				pop hl 
1447			 
1447				ret 
1447			 
1447			 
1447			 
1447			endif 
1447			 
1447			; eof 
# End of file firmware_memory.asm
1447			  
1447			; device C  
1447			; Now handled by SPI  
1447			;if SOUND_ENABLE  
1447			;	include "firmware_sound.asm"  
1447			;endif  
1447			  
1447			include "firmware_diags.asm"  
1447			; Hardware diags menu 
1447			 
1447			 
1447			config: 
1447			 
1447 3e 00			ld a, 0 
1449 21 6d 14			ld hl, .configmn 
144c cd eb 0b			call menu 
144f			 
144f fe 00			cp 0 
1451 c8				ret z 
1452			 
1452			;	cp 1 
1452			;	call z, .savetostore 
1452			 
1452 fe 01			cp 1 
1454			if STARTUP_V1 
1454 cc 83 14			call z, .selautoload 
1457			endif 
1457			 
1457			if STARTUP_V2 
1457				call z, .enautoload 
1457			endif 
1457 fe 02			cp 2 
1459 cc 79 14			call z, .disautoload 
145c			;	cp 3 
145c			;	call z, .selbank 
145c fe 03			cp 3 
145e cc a1 14			call z, .debug_tog 
1461 fe 04			cp 4 
1463 cc ef 15			call z, .bpsgo 
1466 fe 05			cp 5 
1468 cc ca 14			call z, hardware_diags 
146b			if STARTUP_V2 
146b				cp 6 
146b				call z, create_startup 
146b			endif 
146b 18 da			jr config 
146d			 
146d			.configmn: 
146d			;	dw prom_c3 
146d dd 17			dw prom_c2 
146f f2 17			dw prom_c2a 
1471			;	dw prom_c2b 
1471			;	dw prom_c4 
1471 11 18			dw prom_m4 
1473 2c 18			dw prom_m4b 
1475 34 18			dw prom_c1 
1477			if STARTUP_V2 
1477				dw prom_c9 
1477			endif 
1477 00 00			dw 0 
1479				 
1479			 
1479			if STARTUP_V2 
1479			.enautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 1 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479				ld hl, prom_notav 
1479				ld de, prom_empty 
1479				call info_panel 
1479				endif 
1479			 
1479			 
1479				ret 
1479			endif 
1479			 
1479			.disautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 0 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479 21 43 18			ld hl, prom_notav 
147c 11 59 18			ld de, prom_empty 
147f cd 4b 0b			call info_panel 
1482				endif 
1482			 
1482			 
1482 c9				ret 
1483			 
1483			if STARTUP_V1 
1483			 
1483			; Select auto start 
1483			 
1483			.selautoload: 
1483			 
1483				 
1483				if STORAGE_SE 
1483			 
1483					call config_dir 
1483				        ld hl, scratch 
1483					ld a, 0 
1483					call menu 
1483			 
1483					cp 0 
1483					ret z 
1483			 
1483					dec a 
1483			 
1483			 
1483					; locate menu option 
1483			 
1483					ld hl, scratch 
1483					call table_lookup 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALl" 
1483						CALLMONITOR 
1483					endif 
1483					; with the pointer to the menu it, the byte following the zero term is the file id 
1483			 
1483					ld a, 0 
1483					ld bc, 50   ; max of bytes to look at 
1483					cpir  
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALb" 
1483						CALLMONITOR 
1483					endif 
1483					;inc hl 
1483			 
1483					ld a, (hl)   ; file id 
1483					 
1483				        ; save bank and file ids 
1483			 
1483					push af 
1483			 
1483			; TODO need to save to block 0 on bank 1	 
1483			 
1483					call storage_get_block_0 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "AL0" 
1483						CALLMONITOR 
1483					endif 
1483					pop af 
1483			 
1483					ld (store_page+STORE_0_FILERUN),a 
1483					 
1483					; save bank id 
1483			 
1483					ld a,(spi_device) 
1483					ld (store_page+STORE_0_BANKRUN),a 
1483			 
1483					; enable auto run of store file 
1483			 
1483					ld a, 1 
1483					ld (store_page+STORE_0_AUTOFILE),a 
1483			 
1483					; save buffer 
1483			 
1483					ld hl, 0 
1483					ld de, store_page 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALw" 
1483						CALLMONITOR 
1483					endif 
1483				call storage_write_block	 ; save update 
1483			  
1483			 
1483			 
1483			 
1483					ld hl, scratch 
1483					call config_fdir 
1483			 
1483				else 
1483			 
1483 21 43 18			ld hl, prom_notav 
1486 11 59 18			ld de, prom_empty 
1489 cd 4b 0b			call info_panel 
148c			 
148c				endif 
148c c9				ret 
148d			endif 
148d			 
148d			 
148d			; Select storage bank 
148d			 
148d			.selbank: 
148d			 
148d			;	if STORAGE_SE 
148d			;	else 
148d			 
148d 21 43 18			ld hl, prom_notav 
1490 11 59 18			ld de, prom_empty 
1493 cd 4b 0b			call info_panel 
1496			;	endif 
1496				 
1496 c9				ret 
1497			 
1497			if STORAGE_SE 
1497			 
1497			.config_ldir:   
1497				; Load storage bank labels into menu array 
1497			 
1497				 
1497			 
1497			 
1497				ret 
1497			 
1497			 
1497			endif 
1497			 
1497			 
1497			; Save user words to storage 
1497			 
1497			.savetostore: 
1497			 
1497			;	if STORAGE_SE 
1497			; 
1497			;		call config_dir 
1497			;	        ld hl, scratch 
1497			;		ld a, 0 
1497			;		call menu 
1497			;		 
1497			;		ld hl, scratch 
1497			;		call config_fdir 
1497			; 
1497			;	else 
1497			 
1497 21 43 18			ld hl, prom_notav 
149a 11 59 18			ld de, prom_empty 
149d cd 4b 0b			call info_panel 
14a0			 
14a0			;	endif 
14a0			 
14a0 c9				ret 
14a1			 
14a1			if STARTUP_V2 
14a1			 
14a1			create_startup: 
14a1			 
14a1				ld a, 0 
14a1				ld hl, .crstart 
14a1				call menu 
14a1			 
14a1				cp 0 
14a1				ret z 
14a1			 
14a1				cp 1 
14a1				call z, .genlsword 
14a1				cp 2 
14a1				call z, .genedword 
14a1			 
14a1				cp 3 
14a1				call z, .gendemword 
14a1			 
14a1				cp 4 
14a1				call z, .genutlword 
14a1				cp 5 
14a1				call z, .genspiword 
14a1				cp 6 
14a1				call z, .genkeyword 
14a1				cp 7 
14a1				call z, .gensoundword 
14a1				jr create_startup 
14a1			 
14a1			.gensoundword: 
14a1				ld hl, crs_sound 
14a1				ld de, .soundworddef 
14a1				call .genfile 
14a1				ret 
14a1			.genlsword: 
14a1				ld hl, crs_s1 
14a1				ld de, .lsworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genedword: 
14a1				ld de, .edworddef 
14a1				ld hl, crs_s2 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.gendemword: 
14a1				ld de, .demoworddef 
14a1				ld hl, crs_s3 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genutlword: 
14a1				ld hl, crs_s4 
14a1				ld de, .utilwordef 
14a1				call .genfile 
14a1				ret 
14a1			.genspiword: 
14a1				ld hl, crs_s5 
14a1				ld de, .spiworddef 
14a1				call .genfile 
14a1				ret 
14a1			.genkeyword: 
14a1				ld hl, crs_s6 
14a1				ld de, .keyworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			; hl - points to file name 
14a1			; de - points to strings to add to file 
14a1			 
14a1			.genfile: 
14a1				push hl 
14a1				push de 
14a1			 
14a1				call clear_display 
14a1				ld a, display_row_1 
14a1				ld de, .genfiletxt 
14a1				call str_at_display 
14a1				call update_display 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1			 
14a1				push de 
14a1				call storage_create 
14a1				; id in hl 
14a1				pop de   ; table of strings to add 
14a1			 
14a1			.genloop: 
14a1			 
14a1				push hl ; save id for next time around 
14a1				push de ; save de for next time around 
14a1			 
14a1				ex de, hl 
14a1				call loadwordinhl 
14a1				ex de, hl 
14a1			 
14a1				; need hl to be the id 
14a1				; need de to be the string ptr 
14a1				 
14a1				call storage_append 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1				inc de 
14a1				inc de 
14a1			 
14a1				ld a,(de) 
14a1				cp 0 
14a1				jr nz, .genloop 
14a1				inc de 
14a1				ld a, (de) 
14a1				dec de 
14a1				cp 0 
14a1				jr nz, .genloop	 
14a1			 
14a1				ret 
14a1			 
14a1			.genfiletxt:  db "Creating file...",0 
14a1			 
14a1			.soundworddef: 
14a1				dw sound1 
14a1				dw sound2 
14a1				dw sound3 
14a1				dw sound4 
14a1				dw sound5 
14a1				dw sound6 
14a1				dw sound7 
14a1				dw sound8 
14a1				dw sound9 
14a1				dw 0 
14a1			 
14a1			.utilwordef: 
14a1				dw strncpy 
14a1				dw type 
14a1				dw clrstack 
14a1				dw longread 
14a1				dw start1 
14a1				dw start2 
14a1				dw start3b 
14a1				dw start3c 
14a1				dw list 
14a1				dw 0 
14a1			 
14a1			.lsworddef: 
14a1				dw start3b 
14a1				dw 0 
14a1			 
14a1			.edworddef: 
14a1				dw edit1 
14a1				dw edit2 
14a1				dw edit3 
14a1				dw 0 
14a1			 
14a1			.demoworddef: 
14a1				dw test5 
14a1				dw test6 
14a1				dw test7 
14a1				dw test8 
14a1				dw test9 
14a1				dw test10 
14a1				dw game1 
14a1				dw game1a 
14a1				dw game1b 
14a1				dw game1c 
14a1				dw game1d 
14a1				dw game1s 
14a1				dw game1t 
14a1				dw game1f 
14a1				dw game1z 
14a1				dw game1zz 
14a1				dw ssv2 
14a1				dw ssv3 
14a1				dw ssv4 
14a1				dw ssv5 
14a1				dw ssv1 
14a1				dw ssv1cpm	 
14a1				dw game2b 
14a1				dw game2bf 
14a1				dw game2mba 
14a1				dw game2mbas	 
14a1				dw game2mbht 
14a1				dw game2mbms 
14a1				dw game2mb 
14a1				dw game3w 
14a1				dw game3p 
14a1				dw game3sc 
14a1				dw game3vsi 
14a1				dw game3vs 
14a1				dw 0 
14a1			 
14a1			 
14a1			.spiworddef: 
14a1			 
14a1			    dw spi1 
14a1			    dw spi2 
14a1			    dw spi3 
14a1			    dw spi4 
14a1			    dw spi5 
14a1			    dw spi6 
14a1			    dw spi7 
14a1			 
14a1			    dw spi8 
14a1			    dw spi9 
14a1			    dw spi10 
14a1			    dw 0 
14a1			 
14a1			.keyworddef: 
14a1			 
14a1				dw keyup 
14a1				dw keydown 
14a1				dw keyleft 
14a1				dw keyright 
14a1				dw 	keyf1 
14a1				dw keyf2 
14a1				dw keyf3 
14a1				dw keyf4 
14a1				dw keyf5 
14a1				dw keyf6 
14a1				dw keyf7 
14a1				dw keyf8 
14a1				dw keyf9 
14a1				dw keyf10 
14a1				dw keyf11 
14a1				dw keyf12 
14a1				dw keytab 
14a1				dw keycr 
14a1				dw keyhome 
14a1				dw keyend 
14a1				dw keybs 
14a1				dw 0 
14a1			 
14a1			.crstart: 
14a1				dw crs_s1 
14a1				dw crs_s2 
14a1				dw crs_s3 
14a1				dw crs_s4 
14a1				dw crs_s5 
14a1				dw crs_s6 
14a1				dw crs_sound 
14a1				dw 0 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			if STORAGE_SE 
14a1			 
14a1			config_fdir: 
14a1				; using the scratch dir go through and release the memory allocated for each string 
14a1				 
14a1				ld hl, scratch 
14a1			.cfdir:	ld e,(hl) 
14a1				inc hl 
14a1				ld d,(hl) 
14a1				inc hl 
14a1			 
14a1				ex de, hl 
14a1				call ishlzero 
14a1				ret z     ; return on null pointer 
14a1				call free 
14a1				ex de, hl 
14a1				jr .cfdir 
14a1			 
14a1			 
14a1				ret 
14a1			 
14a1			 
14a1			config_dir: 
14a1			 
14a1				; for the config menus that need to build a directory of storage call this routine 
14a1				; it will construct a menu in scratch to pass to menu 
14a1			 
14a1				; open storage device 
14a1			 
14a1				; execute DIR to build a list of files and their ids into scratch in menu format 
14a1				; once the menu has finished then will need to call config_fdir to release the strings 
14a1				 
14a1				; c = number items 
14a1			 
14a1				 
14a1				call storage_get_block_0 
14a1			 
14a1				ld hl, store_page     ; get current id count 
14a1				ld b, (hl) 
14a1				ld c, 0    ; count of files   
14a1			 
14a1			 
14a1				ld hl, scratch 
14a1				ld (store_tmp2), hl    ; location to poke strings 
14a1			 
14a1				; check for empty drive 
14a1			 
14a1				ld a, 0 
14a1				cp b 
14a1				jp z, .dirdone 
14a1			 
14a1				 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdc" 
14a1						CALLMONITOR 
14a1					endif 
14a1			 
14a1			 
14a1			.diritem:	 
14a1				push bc 
14a1				; for each of the current ids do a search for them and if found push to stack 
14a1			 
14a1					ld hl, STORE_BLOCK_PHY 
14a1					ld d, 0		 ; look for extent 0 of block id as this contains file name 
14a1					ld e,b 
14a1			 
14a1					call storage_findnextid 
14a1			 
14a1			 
14a1					; if found hl will be non zero 
14a1			 
14a1					call ishlzero 
14a1					jr z, .dirnotfound 
14a1			 
14a1					; increase count 
14a1			 
14a1					pop bc	 
14a1					inc c 
14a1					push bc 
14a1					 
14a1			 
14a1					; get file header and push the file name 
14a1			 
14a1					ld de, store_page 
14a1					call storage_read_block 
14a1			 
14a1					; push file id to stack 
14a1				 
14a1					ld a, (store_page) 
14a1					ld h, 0 
14a1					ld l, a 
14a1			 
14a1					;call forth_push_numhl 
14a1					; TODO store id 
14a1			 
14a1					push hl 
14a1			 
14a1					; push extent count to stack  
14a1				 
14a1					ld hl, store_page+3 
14a1			 
14a1					; get file name length 
14a1			 
14a1					call strlenz   
14a1			 
14a1					inc hl   ; cover zero term 
14a1					inc hl  ; stick the id at the end of the area 
14a1			 
14a1					push hl 
14a1					pop bc    ; move length to bc 
14a1			 
14a1					call malloc 
14a1			 
14a1					; TODO save malloc area to scratch 
14a1			 
14a1					ex de, hl 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), e 
14a1					inc hl 
14a1					ld (hl), d 
14a1					inc hl 
14a1					ld (store_tmp2), hl 
14a1			 
14a1					 
14a1			 
14a1					;pop hl   ; get source 
14a1			;		ex de, hl    ; swap aronund	 
14a1			 
14a1					ld hl, store_page+3 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "CFd" 
14a1						CALLMONITOR 
14a1					endif 
14a1					ldir 
14a1			 
14a1					; de is past string, move back one and store id 
14a1					 
14a1					dec de 
14a1			 
14a1					; store file id 
14a1			 
14a1					pop hl 
14a1					ex de,hl 
14a1					ld (hl), e 
14a1			 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdi" 
14a1						CALLMONITOR 
14a1					endif 
14a1					 
14a1			.dirnotfound: 
14a1					pop bc     
14a1					djnz .diritem 
14a1				 
14a1			.dirdone:	 
14a1			 
14a1					ld a, 0 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), a 
14a1					inc hl 
14a1					ld (hl), a 
14a1					inc hl 
14a1					; push a count of the dir items found 
14a1			 
14a1			;		ld h, 0 
14a1			;		ld l, c 
14a1			 
14a1				ret 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			; Settings 
14a1			; Run  
14a1			 
14a1			 
14a1			 
14a1			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14a1			;;hd_menu2:   db "        2: Editor",0   
14a1			;hd_menu2:   db "        2: Editor       6: Menu",0   
14a1			;hd_menu3:   db "        3: Storage",0 
14a1			;hd_menu4:   db "0=quit  4: Debug",0 
14a1			;hd_don:     db "ON",0 
14a1			;hd_doff:     db "OFF",0 
14a1			; 
14a1			; 
14a1			; 
14a1			;hardware_diags_old:       
14a1			; 
14a1			;.diagmenu: 
14a1			;	call clear_display 
14a1			;	ld a, display_row_1 
14a1			;	ld de, hd_menu1 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_2 
14a1			;	ld de, hd_menu2 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_3 
14a1			;	ld de, hd_menu3 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a,  display_row_4 
14a1			;	ld de, hd_menu4 
14a1			;	call str_at_display 
14a1			; 
14a1			;	; display debug state 
14a1			; 
14a1			;	ld de, hd_don 
14a1			;	ld a, (os_view_disable) 
14a1			;	cp 0 
14a1			;	jr z, .distog 
14a1			;	ld de, hd_doff 
14a1			;.distog: ld a, display_row_4+17 
14a1			;	call str_at_display 
14a1			; 
14a1			;	call update_display 
14a1			; 
14a1			;	call cin_wait 
14a1			; 
14a1			; 
14a1			; 
14a1			;	cp '4' 
14a1			;	jr nz, .diagn1 
14a1			; 
14a1			;	; debug toggle 
14a1			; 
14a1			;	ld a, (os_view_disable) 
14a1			;	ld b, '*' 
14a1			;	cp 0 
14a1			;	jr z, .debtog 
14a1			;	ld b, 0 
14a1			;.debtog:	 
14a1			;	ld a,b 
14a1			;	ld (os_view_disable),a 
14a1			; 
14a1			;.diagn1: cp '0' 
14a1			;	 ret z 
14a1			; 
14a1			;;	cp '1' 
14a1			;;       jp z, matrix	 
14a1			;;   TODO keyboard matrix test 
14a1			; 
14a1			;	cp '2' 
14a1			;	jp z, .diagedit 
14a1			; 
14a1			;;	cp '6' 
14a1			;;	jp z, .menutest 
14a1			;;if ENABLE_BASIC 
14a1			;;	cp '6' 
14a1			;;	jp z, basic 
14a1			;;endif 
14a1			 ; 
14a1			;	jp .diagmenu 
14a1			; 
14a1			; 
14a1			;	ret 
14a1			 
14a1			 
14a1			.debug_tog: 
14a1 21 eb 14			ld hl, .menudebug 
14a4				 
14a4			;	ld a, (os_view_disable) 
14a4			;	cp '*' 
14a4 3a 6f ee			ld a,(debug_vector) 
14a7 fe c9			cp $C9   ; RET 
14a9 20 04			jr nz,.tdon  
14ab 3e 01			ld a, 1 
14ad 18 02			jr .tog1 
14af 3e 00		.tdon: ld a, 0 
14b1			 
14b1			.tog1: 
14b1 cd eb 0b			call menu 
14b4 fe 00			cp 0 
14b6 c8				ret z 
14b7 fe 01			cp 1    ; disable debug 
14b9 28 04			jr z, .dtog0 
14bb 3e 2a			ld a, '*' 
14bd 18 05			jr .dtogset 
14bf			.dtog0:  
14bf				;ld a, 0 
14bf cd dd 15			call bp_on 
14c2 18 dd			jr .debug_tog 
14c4			.dtogset:  
14c4				; ld (os_view_disable), a 
14c4 cd e9 15			call bp_off 
14c7 c3 a1 14			jp .debug_tog 
14ca			 
14ca			 
14ca			hardware_diags:       
14ca			 
14ca			.diagm: 
14ca 21 dd 14			ld hl, .menuitems 
14cd 3e 00			ld a, 0 
14cf cd eb 0b			call menu 
14d2			 
14d2 fe 00		         cp 0 
14d4 c8				 ret z 
14d5			 
14d5 fe 02			cp 2 
14d7 ca 36 15			jp z, .diagedit 
14da			 
14da			;	cp '6' 
14da			;	jp z, .menutest 
14da			;if ENABLE_BASIC 
14da			;	cp '6' 
14da			;	jp z, basic 
14da			;endif 
14da			  
14da c3 ca 14			jp .diagm 
14dd			 
14dd				 
14dd f1 14		.menuitems:   	dw .m1 
14df fc 14				dw .m2 
14e1 03 15				dw .m3 
14e3 0b 15				dw .m5 
14e5 11 15				dw .m5a 
14e7 1a 15				dw .m5b 
14e9 00 00				dw 0 
14eb			 
14eb			.menudebug: 
14eb 23 15				dw .m6 
14ed 2c 15				dw .m7 
14ef 00 00				dw 0 
14f1			 
14f1 .. 00		.m1:   db "Key Matrix",0 
14fc .. 00		.m2:   db "Editor",0 
1503 .. 00		.m3:   db "Storage",0 
150b .. 00		.m5:   db "Sound",0 
1511 .. 00		.m5a:  db "RAM Test",0 
151a .. 00		.m5b:  db "LCD Test",0 
1523			 
1523 .. 00		.m6:   db "Debug ON",0 
152c .. 00		.m7:   db "Debug OFF",0 
1536			 
1536			; debug editor 
1536			 
1536			.diagedit: 
1536			 
1536 21 c1 e2			ld hl, scratch 
1539			;	ld bc, 250 
1539			;	ldir 
1539				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1539 3e 00			ld a, 0 
153b 77				ld (hl), a 
153c 23				inc hl 
153d 77				ld (hl), a 
153e 23				inc hl 
153f 77				ld (hl), a 
1540			 
1540 cd ba 0b		        call clear_display 
1543 cd dd 0b			call update_display 
1546				;ld a, 1 
1546				;ld (hardware_diag), a 
1546			.diloop: 
1546 3e 00			ld a, display_row_1 
1548 0e 00			ld c, 0 
154a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
154c 1e 28			ld e, 40 
154e			 
154e 21 c1 e2			ld hl, scratch	 
1551 cd 14 0e			call input_str 
1554			 
1554 3e 28			ld a, display_row_2 
1556 11 c1 e2			ld de, scratch 
1559 cd cd 0b			call str_at_display 
155c cd dd 0b			call update_display 
155f			 
155f c3 46 15			jp .diloop 
1562			 
1562			 
1562			; pass word in hl 
1562			; a has display location 
1562			display_word_at: 
1562 f5				push af 
1563 e5				push hl 
1564 7c				ld a,h 
1565 21 c6 e5			ld hl, os_word_scratch 
1568 cd e8 10			call hexout 
156b e1				pop hl 
156c 7d				ld a,l 
156d 21 c8 e5			ld hl, os_word_scratch+2 
1570 cd e8 10			call hexout 
1573 21 ca e5			ld hl, os_word_scratch+4 
1576 3e 00			ld a,0 
1578 77				ld (hl),a 
1579 11 c6 e5			ld de,os_word_scratch 
157c f1				pop af 
157d cd cd 0b				call str_at_display 
1580 c9				ret 
1581			 
1581			display_ptr_state: 
1581			 
1581				; to restore afterwards 
1581			 
1581 d5				push de 
1582 c5				push bc 
1583 e5				push hl 
1584 f5				push af 
1585			 
1585				; for use in here 
1585			 
1585			;	push bc 
1585			;	push de 
1585			;	push hl 
1585			;	push af 
1585			 
1585 cd ba 0b			call clear_display 
1588			 
1588 11 60 17			ld de, .ptrstate 
158b 3e 00			ld a, display_row_1 
158d cd cd 0b			call str_at_display 
1590			 
1590				; display debug step 
1590			 
1590			 
1590 11 6b ee			ld de, debug_mark 
1593 3e 26			ld a, display_row_1+display_cols-2 
1595 cd cd 0b			call str_at_display 
1598			 
1598				; display a 
1598 11 6a 17			ld de, .ptrcliptr 
159b 3e 28			ld a, display_row_2 
159d cd cd 0b			call str_at_display 
15a0			 
15a0 f1				pop af 
15a1 2a 40 ea			ld hl,(cli_ptr) 
15a4 3e 30			ld a, display_row_2+8 
15a6 cd 62 15			call display_word_at 
15a9			 
15a9			 
15a9				; display hl 
15a9			 
15a9			 
15a9 11 72 17			ld de, .ptrclioptr 
15ac 3e 32			ld a, display_row_2+10 
15ae cd cd 0b			call str_at_display 
15b1			; 
15b1			;	pop hl 
15b1 3e 35			ld a, display_row_2+13 
15b3 2a 3e ea			ld hl,(cli_origptr) 
15b6 cd 62 15			call display_word_at 
15b9			; 
15b9			;	 
15b9			;	; display de 
15b9			 
15b9			;	ld de, .regstatede 
15b9			;	ld a, display_row_3 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop de 
15b9			;	ld h,d 
15b9			;	ld l, e 
15b9			;	ld a, display_row_3+3 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display bc 
15b9			 
15b9			;	ld de, .regstatebc 
15b9			;	ld a, display_row_3+10 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop bc 
15b9			;	ld h,b 
15b9			;	ld l, c 
15b9			;	ld a, display_row_3+13 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display dsp 
15b9			 
15b9			;	ld de, .regstatedsp 
15b9			;	ld a, display_row_4 
15b9			;	call str_at_display 
15b9			 
15b9				 
15b9			;	ld hl,(cli_data_sp) 
15b9			;	ld a, display_row_4+4 
15b9			;	call display_word_at 
15b9			 
15b9				; display rsp 
15b9			 
15b9 11 a1 17			ld de, .regstatersp 
15bc 3e 82			ld a, display_row_4+10 
15be cd cd 0b			call str_at_display 
15c1			 
15c1				 
15c1 2a f2 e9			ld hl,(cli_ret_sp) 
15c4 3e 86			ld a, display_row_4+14 
15c6 cd 62 15			call display_word_at 
15c9			 
15c9 cd dd 0b			call update_display 
15cc			 
15cc cd f2 0a			call delay1s 
15cf cd f2 0a			call delay1s 
15d2 cd f2 0a			call delay1s 
15d5			 
15d5			 
15d5 cd bd 1b			call next_page_prompt 
15d8			 
15d8				; restore  
15d8			 
15d8 f1				pop af 
15d9 e1				pop hl 
15da c1				pop bc 
15db d1				pop de 
15dc c9				ret 
15dd			 
15dd			; Update the break point vector so that the user can hook a new routine 
15dd			 
15dd			bp_on: 
15dd 3e c3			ld a, $c3    ; JP 
15df 32 6f ee			ld (debug_vector), a 
15e2 21 ef 15			ld hl, break_point_state 
15e5 22 70 ee			ld (debug_vector+1), hl 
15e8 c9				ret 
15e9			 
15e9			bp_off: 
15e9 3e c9			ld a, $c9    ; RET 
15eb 32 6f ee			ld (debug_vector), a 
15ee c9				ret 
15ef			 
15ef			 
15ef			break_point_state: 
15ef			;	push af 
15ef			; 
15ef			;	; see if disabled 
15ef			; 
15ef			;	ld a, (os_view_disable) 
15ef			;	cp '*' 
15ef			;	jr nz, .bpsgo 
15ef			;	pop af 
15ef			;	ret 
15ef			 
15ef			.bpsgo: 
15ef			;	pop af 
15ef f5				push af 
15f0 22 af e2			ld (os_view_hl), hl 
15f3 ed 53 ad e2		ld (os_view_de), de 
15f7 ed 43 ab e2		ld (os_view_bc), bc 
15fb e5				push hl 
15fc 6f				ld l, a 
15fd 26 00			ld h, 0 
15ff 22 b1 e2			ld (os_view_af),hl 
1602			 
1602 21 b1 ed				ld hl, display_fb0 
1605 22 cc eb				ld (display_fb_active), hl 
1608 e1				pop hl	 
1609			 
1609 3e 31			ld a, '1' 
160b fe 2a		.bps1:  cp '*' 
160d cc e9 15			call z, bp_off 
1610			;	jr nz, .bps1b 
1610			;	ld (os_view_disable),a 
1610 fe 31		.bps1b:  cp '1' 
1612 20 14			jr nz, .bps2 
1614			 
1614				; display reg 
1614			 
1614				 
1614			 
1614 3a b1 e2			ld a, (os_view_af) 
1617 2a af e2			ld hl, (os_view_hl) 
161a ed 5b ad e2		ld de, (os_view_de) 
161e ed 4b ab e2		ld bc, (os_view_bc) 
1622 cd bc 16			call display_reg_state 
1625 c3 a8 16			jp .bpschk 
1628			 
1628 fe 32		.bps2:  cp '2' 
162a 20 08			jr nz, .bps3 
162c				 
162c				; display hl 
162c 2a af e2			ld hl, (os_view_hl) 
162f cd a6 17			call display_dump_at_hl 
1632			 
1632 18 74			jr .bpschk 
1634			 
1634 fe 33		.bps3:  cp '3' 
1636 20 08			jr nz, .bps4 
1638			 
1638			        ; display de 
1638 2a ad e2			ld hl, (os_view_de) 
163b cd a6 17			call display_dump_at_hl 
163e			 
163e 18 68			jr .bpschk 
1640 fe 34		.bps4:  cp '4' 
1642 20 08			jr nz, .bps5 
1644			 
1644			        ; display bc 
1644 2a ab e2			ld hl, (os_view_bc) 
1647 cd a6 17			call display_dump_at_hl 
164a			 
164a 18 5c			jr .bpschk 
164c fe 35		.bps5:  cp '5' 
164e 20 08		        jr nz, .bps7 
1650			 
1650				; display cur ptr 
1650 2a 40 ea			ld hl, (cli_ptr) 
1653 cd a6 17			call display_dump_at_hl 
1656			 
1656 18 50			jr .bpschk 
1658 fe 36		.bps7:  cp '6' 
165a 20 08			jr nz, .bps8b 
165c				 
165c				; display cur orig ptr 
165c 2a 3e ea			ld hl, (cli_origptr) 
165f cd a6 17			call display_dump_at_hl 
1662 18 44			jr .bpschk 
1664 fe 37		.bps8b:  cp '7' 
1666 20 08			jr nz, .bps9 
1668				 
1668				; display dsp 
1668 2a ee e9			ld hl, (cli_data_sp) 
166b cd a6 17			call display_dump_at_hl 
166e			 
166e 18 38			jr .bpschk 
1670 fe 39		.bps9:  cp '9' 
1672 20 05			jr nz, .bps8c 
1674				 
1674				; display SP 
1674			;	ld hl, sp 
1674 cd a6 17			call display_dump_at_hl 
1677			 
1677 18 2f			jr .bpschk 
1679 fe 38		.bps8c:  cp '8' 
167b 20 08			jr nz, .bps8d 
167d				 
167d				; display rsp 
167d 2a f2 e9			ld hl, (cli_ret_sp) 
1680 cd a6 17			call display_dump_at_hl 
1683			 
1683 18 23			jr .bpschk 
1685 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1687 20 05			jr nz, .bps8 
1689 cd 8b 19			call monitor 
168c			 
168c 18 1a			jr .bpschk 
168e fe 30		.bps8:  cp '0' 
1690 20 16			jr nz, .bpschk 
1692			 
1692 21 10 ed				ld hl, display_fb1 
1695 22 cc eb				ld (display_fb_active), hl 
1698 cd dd 0b				call update_display 
169b			 
169b				;ld a, (os_view_af) 
169b 2a af e2			ld hl, (os_view_hl) 
169e ed 5b ad e2		ld de, (os_view_de) 
16a2 ed 4b ab e2		ld bc, (os_view_bc) 
16a6 f1				pop af 
16a7 c9				ret 
16a8			 
16a8			.bpschk:   
16a8 cd f2 0a			call delay1s 
16ab 3e 9f		ld a,display_row_4 + display_cols - 1 
16ad 11 bb 1b		        ld de, endprg 
16b0 cd cd 0b			call str_at_display 
16b3 cd dd 0b			call update_display 
16b6 cd 6e 65			call cin_wait 
16b9			 
16b9 c3 0b 16			jp .bps1 
16bc			 
16bc			 
16bc			display_reg_state: 
16bc			 
16bc				; to restore afterwards 
16bc			 
16bc d5				push de 
16bd c5				push bc 
16be e5				push hl 
16bf f5				push af 
16c0			 
16c0				; for use in here 
16c0			 
16c0 c5				push bc 
16c1 d5				push de 
16c2 e5				push hl 
16c3 f5				push af 
16c4			 
16c4 cd ba 0b			call clear_display 
16c7			 
16c7 11 7c 17			ld de, .regstate 
16ca 3e 00			ld a, display_row_1 
16cc cd cd 0b			call str_at_display 
16cf			 
16cf				; display debug step 
16cf			 
16cf			 
16cf 11 6b ee			ld de, debug_mark 
16d2 3e 25			ld a, display_row_1+display_cols-3 
16d4 cd cd 0b			call str_at_display 
16d7			 
16d7				; display a 
16d7 11 98 17			ld de, .regstatea 
16da 3e 28			ld a, display_row_2 
16dc cd cd 0b			call str_at_display 
16df			 
16df e1				pop hl 
16e0			;	ld h,0 
16e0			;	ld l, a 
16e0 3e 2b			ld a, display_row_2+3 
16e2 cd 62 15			call display_word_at 
16e5			 
16e5			 
16e5				; display hl 
16e5			 
16e5			 
16e5 11 8c 17			ld de, .regstatehl 
16e8 3e 32			ld a, display_row_2+10 
16ea cd cd 0b			call str_at_display 
16ed			 
16ed e1				pop hl 
16ee 3e 35			ld a, display_row_2+13 
16f0 cd 62 15			call display_word_at 
16f3			 
16f3				 
16f3				; display de 
16f3			 
16f3 11 90 17			ld de, .regstatede 
16f6 3e 50			ld a, display_row_3 
16f8 cd cd 0b			call str_at_display 
16fb			 
16fb e1				pop hl 
16fc			;	ld h,d 
16fc			;	ld l, e 
16fc 3e 53			ld a, display_row_3+3 
16fe cd 62 15			call display_word_at 
1701			 
1701			 
1701				; display bc 
1701			 
1701 11 94 17			ld de, .regstatebc 
1704 3e 5a			ld a, display_row_3+10 
1706 cd cd 0b			call str_at_display 
1709			 
1709 e1				pop hl 
170a			;	ld h,b 
170a			;	ld l, c 
170a 3e 5d			ld a, display_row_3+13 
170c cd 62 15			call display_word_at 
170f			 
170f			 
170f				; display dsp 
170f			 
170f 11 9c 17			ld de, .regstatedsp 
1712 3e 78			ld a, display_row_4 
1714 cd cd 0b			call str_at_display 
1717			 
1717				 
1717 2a ee e9			ld hl,(cli_data_sp) 
171a 3e 7c			ld a, display_row_4+4 
171c cd 62 15			call display_word_at 
171f			 
171f				; display rsp 
171f			 
171f 11 a1 17			ld de, .regstatersp 
1722 3e 82			ld a, display_row_4+10 
1724 cd cd 0b			call str_at_display 
1727			 
1727				 
1727 2a f2 e9			ld hl,(cli_ret_sp) 
172a 3e 86			ld a, display_row_4+14 
172c cd 62 15			call display_word_at 
172f			 
172f cd dd 0b			call update_display 
1732			 
1732			;	call delay1s 
1732			;	call delay1s 
1732			;	call delay1s 
1732			 
1732			 
1732			;	call next_page_prompt 
1732			 
1732				; restore  
1732			 
1732 f1				pop af 
1733 e1				pop hl 
1734 c1				pop bc 
1735 d1				pop de 
1736 c9				ret 
1737			 
1737 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
174b .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1760 .. 00		.ptrstate:	db "Ptr State",0 
176a .. 00		.ptrcliptr:     db "cli_ptr",0 
1772 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
177c .. 00		.regstate:	db "Reg State (1/0)",0 
178c .. 00		.regstatehl:	db "HL:",0 
1790 .. 00		.regstatede:	db "DE:",0 
1794 .. 00		.regstatebc:	db "BC:",0 
1798 .. 00		.regstatea:	db "A :",0 
179c .. 00		.regstatedsp:	db "DSP:",0 
17a1 .. 00		.regstatersp:	db "RSP:",0 
17a6			 
17a6			display_dump_at_hl: 
17a6 e5				push hl 
17a7 d5				push de 
17a8 c5				push bc 
17a9 f5				push af 
17aa			 
17aa 22 e4 e5			ld (os_cur_ptr),hl	 
17ad cd ba 0b			call clear_display 
17b0 cd c5 1a			call dumpcont 
17b3			;	call delay1s 
17b3			;	call next_page_prompt 
17b3			 
17b3			 
17b3 f1				pop af 
17b4 c1				pop bc 
17b5 d1				pop de 
17b6 e1				pop hl 
17b7 c9				ret 
17b8			 
17b8			;if ENABLE_BASIC 
17b8			;	include "nascombasic.asm" 
17b8			;	basic: 
17b8			;	include "forth/FORTH.ASM" 
17b8			;endif 
17b8			 
17b8			; eof 
17b8			 
17b8			 
# End of file firmware_diags.asm
17b8			  
17b8			include "firmware_prompts.asm"  
17b8			; Prompts  
17b8			 
17b8			; boot messages 
17b8			 
17b8 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
17cd .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17dd			 
17dd			 
17dd			; config menus 
17dd			 
17dd			;prom_c3: db "Add Dictionary To File",0 
17dd			 
17dd			if STARTUP_V1 
17dd .. 00		prom_c2: db "Select Autoload File",0 
17f2 .. 00		prom_c2a: db "Disable Autoload File", 0 
1808			endif 
1808			 
1808			if STARTUP_V2 
1808			prom_c2: db "Enable Autoload Files",0 
1808			prom_c2a: db "Disable Autoload Files", 0 
1808			 
1808			crs_s1: db "*ls-word", 0 
1808			crs_s2: db "*ed-word", 0 
1808			crs_s3: db "*Demo-Programs", 0 
1808			crs_s4: db "*Utils", 0 
1808			crs_s5: db "*SPI-Addons", 0 
1808			crs_s6: db "*Key-constants", 0 
1808			crs_sound: db "*Sound-Util", 0 
1808			 
1808			 
1808			 
1808			endif 
1808			;prom_c2b: db "Select Storage Bank",0 
1808 .. 00		prom_c4: db "Settings",0 
1811 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
182c .. 00		prom_m4b:   db "Monitor",0 
1834 .. 00		prom_c1: db "Hardware Diags",0 
1843			 
1843			 
1843			if STARTUP_V2 
1843			prom_c9: db "Create Startup Files",0 
1843			endif 
1843			 
1843 .. 00		prom_notav:    db "Feature not available",0 
1859 .. 00		prom_empty:    db "",0 
185a			 
185a			; eof 
185a			 
# End of file firmware_prompts.asm
185a			  
185a			  
185a			; eof  
185a			  
# End of file firmware.asm
185a			 
185a			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
185a			;if BASE_KEV  
185a			;baseram: equ 08000h 
185a			;endif 
185a			 
185a			;if BASE_SC114 
185a			;baseram:     equ    endofcode 
185a			;endif 
185a			 
185a			 
185a			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
185a			 
185a			; start system 
185a			 
185a			coldstart: 
185a				; set sp 
185a				; di/ei 
185a			 
185a f3				di 
185b 31 00 f0			ld sp, tos 
185e cd 6c 64			call init_nmi 
1861			;	ei 
1861			 
1861				; init spinner 
1861 3e 00			ld a,0 
1863 32 c6 eb			ld (display_active), a 
1866			 
1866				; disable breakpoint by default 
1866			 
1866				;ld a,'*' 
1866			;	ld a,' ' 
1866			;	ld (os_view_disable),a 
1866			 
1866				; set break point vector as new break point on or off 
1866 cd e9 15			call bp_off 
1869			 
1869				; init hardware 
1869			 
1869				; init keyboard and screen hardware 
1869			 
1869 cd 1c 01			call hardware_init 
186c			 
186c			 
186c cd f2 0a			call delay1s 
186f 3e 58			ld a, display_row_3+8 
1871 11 03 01			ld de, buildtime 
1874 cd cd 0b			call str_at_display 
1877 cd dd 0b			call update_display 
187a			 
187a cd f2 0a			call delay1s 
187d cd f2 0a			call delay1s 
1880 cd f2 0a			call delay1s 
1883			 
1883				; detect if any keys are held down to enable breakpoints at start up 
1883			 
1883 cd 76 65			call cin  
1886 fe 00			cp 0 
1888 28 03			jr z, .nokeys 
188a			 
188a				;call hardware_diags 
188a cd 47 14			call config 
188d			 
188d			;	ld de, .bpen 
188d			;	ld a, display_row_4 
188d			;	call str_at_display 
188d			;	call update_display 
188d			; 
188d			;	ld a,0 
188d			;	ld (os_view_disable),a 
188d			; 
188d			;.bpwait: 
188d			;	call cin 
188d			;	cp 0 
188d			;	jr z, .bpwait 
188d			;	jr .nokeys 
188d			; 
188d			; 
188d			;.bpen:  db "Break points enabled!",0 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			.nokeys: 
188d			 
188d			 
188d				 
188d			 
188d			;jp  testkey 
188d			 
188d			;call storage_get_block_0 
188d			; 
188d			;ld hl, 0 
188d			;ld de, store_page 
188d			;call storage_read_block 
188d			 
188d				 
188d			;ld hl, 10 
188d			;ld de, store_page 
188d			;call storage_read_block 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			;stop:	nop 
188d			;	jp stop 
188d			 
188d			 
188d			 
188d			main: 
188d cd ba 0b			call clear_display 
1890 cd dd 0b			call update_display 
1893			 
1893			 
1893			 
1893			;	call testlcd 
1893			 
1893			 
1893			 
1893 cd c2 1f			call forth_init 
1896			 
1896			 
1896			warmstart: 
1896 cd 98 1f			call forth_warmstart 
1899			 
1899				; run startup word load 
1899			        ; TODO prevent this running at warmstart after crash  
1899			 
1899				if STARTUP_ENABLE 
1899			 
1899					if STARTUP_V1 
1899			 
1899						if STORAGE_SE 
1899							call forth_autoload 
1899						endif 
1899 cd bc 63					call forth_startup 
189c					endif 
189c			 
189c					if STARTUP_V2 
189c			 
189c						if STORAGE_SE 
189c							call forth_autoload 
189c						else 
189c							call forth_startup 
189c						endif 
189c			 
189c			 
189c					endif 
189c			 
189c				endif 
189c			 
189c				; show free memory after boot 
189c 11 26 19			ld de, freeram 
189f 3e 00			ld a, display_row_1 
18a1 cd cd 0b			call str_at_display 
18a4			 
18a4			; Or use heap_size word???? 
18a4 21 a8 e2			ld hl, heap_end 
18a7 11 9e 65			ld de, heap_start 
18aa ed 52			sbc hl, de 
18ac				;push hl 
18ac				;ld a,h	         	 
18ac				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18ac				;call hexout 
18ac			   	;pop hl 
18ac			; 
18ac			;	ld a,l 
18ac			;	ld hl, os_word_scratch+2 
18ac			;	call hexout 
18ac			;	ld hl, os_word_scratch+4 
18ac			;	ld a, 0 
18ac			;	ld (hl),a 
18ac			 
18ac 21 c6 e5			ld hl, os_word_scratch 
18af cd f4 11			call uitoa_16 
18b2			 
18b2			 
18b2 11 c6 e5			ld de, os_word_scratch 
18b5 3e 0d			ld a, display_row_1 + 13 
18b7 cd cd 0b			call str_at_display 
18ba cd dd 0b			call update_display 
18bd			 
18bd			 
18bd				;call demo 
18bd			 
18bd			 
18bd				; init scratch input area for cli commands 
18bd			 
18bd 21 e8 e5			ld hl, os_cli_cmd 
18c0 3e 00			ld a,0 
18c2 77				ld (hl),a 
18c3 23				inc hl 
18c4 77				ld (hl),a 
18c5			 
18c5 3e 00			ld a,0 
18c7 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18ca			 
18ca 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18cd 32 e5 e5			ld (os_cur_ptr+1),a	 
18d0			 
18d0 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18d3 32 c7 e5			ld (os_word_scratch+1),a	 
18d6				 
18d6			 
18d6				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18d6 21 e8 e5			ld hl, os_cli_cmd 
18d9			 
18d9 3e 00			ld a, 0		 ; init cli input 
18db 77				ld (hl), a 
18dc 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18de			cli: 
18de				; show cli prompt 
18de				;push af 
18de				;ld a, 0 
18de				;ld de, prompt 
18de				;call str_at_display 
18de			 
18de				;call update_display 
18de				;pop af 
18de				;inc a 
18de				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18de 0e 00			ld c, 0 
18e0 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18e2 1e 28			ld e, 40 
18e4			 
18e4 21 e8 e5			ld hl, os_cli_cmd 
18e7			 
18e7				STACKFRAME OFF $fefe $9f9f 
18e7				if DEBUG_STACK_IMB 
18e7					if OFF 
18e7						exx 
18e7						ld de, $fefe 
18e7						ld a, d 
18e7						ld hl, curframe 
18e7						call hexout 
18e7						ld a, e 
18e7						ld hl, curframe+2 
18e7						call hexout 
18e7						ld hl, $fefe 
18e7						push hl 
18e7						ld hl, $9f9f 
18e7						push hl 
18e7						exx 
18e7					endif 
18e7				endif 
18e7			endm 
# End of macro STACKFRAME
18e7			 
18e7 cd 14 0e			call input_str 
18ea			 
18ea				STACKFRAMECHK OFF $fefe $9f9f 
18ea				if DEBUG_STACK_IMB 
18ea					if OFF 
18ea						exx 
18ea						ld hl, $9f9f 
18ea						pop de   ; $9f9f 
18ea						call cmp16 
18ea						jr nz, .spnosame 
18ea						ld hl, $fefe 
18ea						pop de   ; $fefe 
18ea						call cmp16 
18ea						jr z, .spfrsame 
18ea						.spnosame: call showsperror 
18ea						.spfrsame: nop 
18ea						exx 
18ea					endif 
18ea				endif 
18ea			endm 
# End of macro STACKFRAMECHK
18ea			 
18ea				; copy input to last command 
18ea			 
18ea 21 e8 e5			ld hl, os_cli_cmd 
18ed 11 e7 e6			ld de, os_last_cmd 
18f0 01 ff 00			ld bc, 255 
18f3 ed b0			ldir 
18f5			 
18f5				; wipe current buffer 
18f5			 
18f5			;	ld a, 0 
18f5			;	ld hl, os_cli_cmd 
18f5			;	ld de, os_cli_cmd+1 
18f5			;	ld bc, 254 
18f5			;	ldir 
18f5				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18f5			;	call strcpy 
18f5			;	ld a, 0 
18f5			;	ld (hl), a 
18f5			;	inc hl 
18f5			;	ld (hl), a 
18f5			;	inc hl 
18f5			;	ld (hl), a 
18f5			 
18f5				; switch frame buffer to program  
18f5			 
18f5 21 10 ed				ld hl, display_fb1 
18f8 22 cc eb				ld (display_fb_active), hl 
18fb			 
18fb			;	nop 
18fb				STACKFRAME ON $fbfe $8f9f 
18fb				if DEBUG_STACK_IMB 
18fb					if ON 
18fb						exx 
18fb						ld de, $fbfe 
18fb						ld a, d 
18fb						ld hl, curframe 
18fb						call hexout 
18fb						ld a, e 
18fb						ld hl, curframe+2 
18fb						call hexout 
18fb						ld hl, $fbfe 
18fb						push hl 
18fb						ld hl, $8f9f 
18fb						push hl 
18fb						exx 
18fb					endif 
18fb				endif 
18fb			endm 
# End of macro STACKFRAME
18fb				; first time into the parser so pass over the current scratch pad 
18fb 21 e8 e5			ld hl,os_cli_cmd 
18fe				; tokenise the entered statement(s) in HL 
18fe cd 40 20			call forthparse 
1901			        ; exec forth statements in top of return stack 
1901 cd 80 20			call forthexec 
1904				;call forthexec_cleanup 
1904			;	call parsenext 
1904			 
1904				STACKFRAMECHK ON $fbfe $8f9f 
1904				if DEBUG_STACK_IMB 
1904					if ON 
1904						exx 
1904						ld hl, $8f9f 
1904						pop de   ; $8f9f 
1904						call cmp16 
1904						jr nz, .spnosame 
1904						ld hl, $fbfe 
1904						pop de   ; $fbfe 
1904						call cmp16 
1904						jr z, .spfrsame 
1904						.spnosame: call showsperror 
1904						.spfrsame: nop 
1904						exx 
1904					endif 
1904				endif 
1904			endm 
# End of macro STACKFRAMECHK
1904				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1904			 
1904 3e 78			ld a, display_row_4 
1906 11 37 19			ld de, endprog 
1909			 
1909 cd dd 0b			call update_display		 
190c			 
190c cd bd 1b			call next_page_prompt 
190f			 
190f				; switch frame buffer to cli 
190f			 
190f 21 b1 ed				ld hl, display_fb0 
1912 22 cc eb				ld (display_fb_active), hl 
1915			 
1915			 
1915 cd ba 0b		        call clear_display 
1918 cd dd 0b			call update_display		 
191b			 
191b 21 e8 e5			ld hl, os_cli_cmd 
191e			 
191e 3e 00			ld a, 0		 ; init cli input 
1920 77				ld (hl), a 
1921			 
1921				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1921			 
1921				; now on last line 
1921			 
1921				; TODO scroll screen up 
1921			 
1921				; TODO instead just clear screen and place at top of screen 
1921			 
1921			;	ld a, 0 
1921			;	ld (f_cursor_ptr),a 
1921			 
1921				;call clear_display 
1921				;call update_display 
1921			 
1921				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1921 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1923 c3 de 18			jp cli 
1926			 
1926 .. 00		freeram: db "Free bytes: ",0 
1933 ..			asc: db "1A2F" 
1937 .. 00		endprog: db "End prog...",0 
1943			 
1943			testenter2:   
1943 21 f3 e2			ld hl,scratch+50 
1946 22 e4 e5			ld (os_cur_ptr),hl 
1949 c3 de 18			jp cli 
194c			 
194c			testenter:  
194c			 
194c 21 33 19			ld hl,asc 
194f			;	ld a,(hl) 
194f			;	call nibble2val 
194f cd 3e 11			call get_byte 
1952			 
1952			 
1952			;	ld a,(hl) 
1952			;	call atohex 
1952			 
1952			;	call fourehexhl 
1952 32 f3 e2			ld (scratch+50),a 
1955			 
1955			 
1955			 
1955 21 35 19			ld hl,asc+2 
1958			;	ld a, (hl) 
1958			;	call nibble2val 
1958 cd 3e 11			call get_byte 
195b			 
195b			;	call fourehexhl 
195b 32 f5 e2			ld (scratch+52),a 
195e				 
195e 21 f3 e2			ld hl,scratch+50 
1961 22 e4 e5			ld (os_cur_ptr),hl 
1964 c3 de 18			jp cli 
1967			 
1967			enter:	 
1967 3a c5 e2			ld a,(scratch+4) 
196a fe 00			cp 0 
196c 28 0c			jr z, .entercont 
196e				; no, not a null term line so has an address to work out.... 
196e			 
196e 21 c3 e2			ld hl,scratch+2 
1971 cd 9e 11			call get_word_hl 
1974			 
1974 22 e4 e5			ld (os_cur_ptr),hl	 
1977 c3 de 18			jp cli 
197a			 
197a			 
197a			.entercont:  
197a			 
197a 21 c3 e2			ld hl, scratch+2 
197d cd 3e 11			call get_byte 
1980			 
1980 2a e4 e5		   	ld hl,(os_cur_ptr) 
1983 77					ld (hl),a 
1984 23					inc hl 
1985 22 e4 e5				ld (os_cur_ptr),hl 
1988				 
1988			; get byte  
1988			 
1988			 
1988 c3 de 18			jp cli 
198b			 
198b			 
198b			; basic monitor support 
198b			 
198b			monitor: 
198b				;  
198b cd ba 0b			call clear_display 
198e 3e 00			ld a, 0 
1990 11 df 19			ld de, .monprompt 
1993 cd cd 0b			call str_at_display 
1996 cd dd 0b			call update_display 
1999			 
1999				; get a monitor command 
1999			 
1999 0e 00			ld c, 0     ; entry at top left 
199b 16 64			ld d, 100   ; max buffer size 
199d 1e 0f			ld e, 15    ; input scroll area 
199f 3e 00			ld a, 0     ; init string 
19a1 21 bf e4			ld hl, os_input 
19a4 77				ld (hl), a 
19a5 23				inc hl 
19a6 77				ld (hl), a 
19a7 21 bf e4			ld hl, os_input 
19aa 3e 01			ld a, 1     ; init string 
19ac cd 14 0e			call input_str 
19af			 
19af cd ba 0b		        call clear_display 
19b2 cd dd 0b			call update_display		 
19b5			 
19b5 3a bf e4			ld a, (os_input) 
19b8 cd 3c 12			call toUpper 
19bb fe 48		        cp 'H' 
19bd ca 44 1a		        jp z, .monhelp 
19c0 fe 44			cp 'D'		; dump 
19c2 ca 77 1a			jp z, .mondump	 
19c5 fe 43			cp 'C'		; dump 
19c7 ca 91 1a			jp z, .moncdump	 
19ca fe 4d			cp 'M'		; dump 
19cc ca e1 19			jp z, .moneditstart 
19cf fe 55			cp 'U'		; dump 
19d1 ca ed 19			jp z, .monedit	 
19d4 fe 47			cp 'G'		; dump 
19d6 ca 6d 1a			jp z, .monjump 
19d9 fe 51			cp 'Q'		; dump 
19db c8				ret z	 
19dc			 
19dc			 
19dc				; TODO "S" to access symbol by name and not need the address 
19dc				; TODO "F" to find a string in memory 
19dc			 
19dc c3 8b 19			jp monitor 
19df			 
19df .. 00		.monprompt: db ">", 0 
19e1			 
19e1			.moneditstart: 
19e1				; get starting address 
19e1			 
19e1 21 c1 e4			ld hl,os_input+2 
19e4 cd 9e 11			call get_word_hl 
19e7			 
19e7 22 e4 e5			ld (os_cur_ptr),hl	 
19ea			 
19ea c3 8b 19			jp monitor 
19ed			 
19ed			.monedit: 
19ed				; get byte to load 
19ed			 
19ed 21 c1 e4			ld hl,os_input+2 
19f0 cd 3e 11			call get_byte 
19f3			 
19f3				; get address to update 
19f3 2a e4 e5			ld hl, (os_cur_ptr) 
19f6			 
19f6				; update byte 
19f6			 
19f6 77				ld (hl), a 
19f7			 
19f7				; move to next address and save it 
19f7			 
19f7 23				inc hl 
19f8 22 e4 e5			ld (os_cur_ptr),hl	 
19fb			 
19fb c3 8b 19			jp monitor 
19fe			 
19fe			 
19fe .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a12 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a2e .. 00		.monhelptext3:  db "G-Call address",0 
1a3d .. 00		.monhelptext4:  db "Q-Quit",0 
1a44			        
1a44			.monhelp: 
1a44 3e 00			ld a, display_row_1 
1a46 11 fe 19		        ld de, .monhelptext1 
1a49			 
1a49 cd cd 0b			call str_at_display 
1a4c 3e 28			ld a, display_row_2 
1a4e 11 12 1a		        ld de, .monhelptext2 
1a51					 
1a51 cd cd 0b			call str_at_display 
1a54 3e 50			ld a, display_row_3 
1a56 11 2e 1a		        ld de, .monhelptext3 
1a59					 
1a59 cd cd 0b			call str_at_display 
1a5c 3e 78			ld a, display_row_4 
1a5e 11 3d 1a		        ld de, .monhelptext4 
1a61 cd cd 0b			call str_at_display 
1a64			 
1a64 cd dd 0b			call update_display		 
1a67			 
1a67 cd bd 1b			call next_page_prompt 
1a6a c3 8b 19			jp monitor 
1a6d			 
1a6d			.monjump:    
1a6d 21 c1 e4			ld hl,os_input+2 
1a70 cd 9e 11			call get_word_hl 
1a73			 
1a73 e9				jp (hl) 
1a74 c3 8b 19			jp monitor 
1a77			 
1a77			.mondump:    
1a77 21 c1 e4			ld hl,os_input+2 
1a7a cd 9e 11			call get_word_hl 
1a7d			 
1a7d 22 e4 e5			ld (os_cur_ptr),hl	 
1a80 cd c5 1a			call dumpcont 
1a83 3e 78			ld a, display_row_4 
1a85 11 37 19			ld de, endprog 
1a88			 
1a88 cd dd 0b			call update_display		 
1a8b			 
1a8b cd bd 1b			call next_page_prompt 
1a8e c3 8b 19			jp monitor 
1a91			.moncdump: 
1a91 cd c5 1a			call dumpcont 
1a94 3e 78			ld a, display_row_4 
1a96 11 37 19			ld de, endprog 
1a99			 
1a99 cd dd 0b			call update_display		 
1a9c			 
1a9c cd bd 1b			call next_page_prompt 
1a9f c3 8b 19			jp monitor 
1aa2			 
1aa2			 
1aa2			; TODO symbol access  
1aa2			 
1aa2			.symbols:     ;; A list of symbols that can be called up  
1aa2 b1 ed			dw display_fb0 
1aa4 .. 00			db "fb0",0  
1aa8 7a ea		     	dw store_page 
1aaa .. 00			db "store_page",0 
1ab5			 
1ab5			 
1ab5			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1ab5			 
1ab5 3a c2 e2			ld a,(scratch+1) 
1ab8 fe 00			cp 0 
1aba 28 09			jr z, dumpcont 
1abc			 
1abc				; no, not a null term line so has an address to work out.... 
1abc			 
1abc 21 c3 e2			ld hl,scratch+2 
1abf cd 9e 11			call get_word_hl 
1ac2			 
1ac2 22 e4 e5			ld (os_cur_ptr),hl	 
1ac5			 
1ac5			 
1ac5			 
1ac5			dumpcont: 
1ac5			 
1ac5				; dump bytes at ptr 
1ac5			 
1ac5			 
1ac5 3e 00			ld a, display_row_1 
1ac7 2a cc eb			ld hl, (display_fb_active) 
1aca cd e7 0d			call addatohl 
1acd cd f5 1a			call .dumpbyterow 
1ad0			 
1ad0 3e 28			ld a, display_row_2 
1ad2 2a cc eb			ld hl, (display_fb_active) 
1ad5 cd e7 0d			call addatohl 
1ad8 cd f5 1a			call .dumpbyterow 
1adb			 
1adb			 
1adb 3e 50			ld a, display_row_3 
1add 2a cc eb			ld hl, (display_fb_active) 
1ae0 cd e7 0d			call addatohl 
1ae3 cd f5 1a			call .dumpbyterow 
1ae6			 
1ae6 3e 78			ld a, display_row_4 
1ae8 2a cc eb			ld hl, (display_fb_active) 
1aeb cd e7 0d			call addatohl 
1aee cd f5 1a			call .dumpbyterow 
1af1			 
1af1 cd dd 0b			call update_display 
1af4			;		jp cli 
1af4 c9				ret 
1af5			 
1af5			.dumpbyterow: 
1af5			 
1af5				;push af 
1af5			 
1af5 e5				push hl 
1af6			 
1af6				; calc where to poke the ascii 
1af6			if display_cols == 20 
1af6				ld a, 16 
1af6			else 
1af6 3e 1f			ld a, 31 
1af8			endif 
1af8			 
1af8 cd e7 0d			call addatohl 
1afb 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1afe			 
1afe			 
1afe			; display decoding address 
1afe 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b01			 
1b01 7c				ld a,h 
1b02 e1				pop hl 
1b03 e5				push hl 
1b04			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b04 cd e8 10			call hexout 
1b07 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b0a			 
1b0a 7d				ld a,l 
1b0b e1				pop hl 
1b0c 23				inc hl 
1b0d 23				inc hl 
1b0e e5				push hl 
1b0f			;	ld hl, os_word_scratch+2 
1b0f cd e8 10			call hexout 
1b12 e1				pop hl 
1b13 23				inc hl 
1b14 23				inc hl 
1b15				;ld hl, os_word_scratch+4 
1b15 3e 3a			ld a, ':' 
1b17 77				ld (hl),a 
1b18 23				inc hl 
1b19				;ld a, 0 
1b19				;ld (hl),a 
1b19				;ld de, os_word_scratch 
1b19				;pop af 
1b19				;push af 
1b19			;		ld a, display_row_2 
1b19			;		call str_at_display 
1b19			;		call update_display 
1b19			 
1b19			 
1b19			;pop af 
1b19			;	add 5 
1b19			 
1b19			if display_cols == 20 
1b19				ld b, 4 
1b19			else 
1b19 06 08			ld b, 8 
1b1b			endif	 
1b1b			 
1b1b			.dumpbyte: 
1b1b c5				push bc 
1b1c e5				push hl 
1b1d			 
1b1d			 
1b1d 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b20 7e					ld a,(hl) 
1b21			 
1b21					; poke the ascii to display 
1b21 2a c6 e5				ld hl,(os_word_scratch) 
1b24 77					ld (hl),a 
1b25 23					inc hl 
1b26 22 c6 e5				ld (os_word_scratch),hl 
1b29			 
1b29					 
1b29			 
1b29			 
1b29 e1					pop hl 
1b2a e5					push hl 
1b2b			 
1b2b cd e8 10				call hexout 
1b2e			 
1b2e					 
1b2e 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b31 23				inc hl 
1b32 22 e4 e5		   	ld (os_cur_ptr),hl 
1b35			 
1b35 e1					pop hl 
1b36 23					inc hl 
1b37 23					inc hl 
1b38 23					inc hl 
1b39			 
1b39			 
1b39			 
1b39					;ld a,0 
1b39					;ld (os_word_scratch+2),a 
1b39					;pop af 
1b39					;push af 
1b39			 
1b39					;ld de, os_word_scratch 
1b39					;call str_at_display 
1b39			;		call update_display 
1b39			;		pop af 
1b39 c1					pop bc 
1b3a c6 03				add 3 
1b3c 10 dd			djnz .dumpbyte 
1b3e			 
1b3e				 
1b3e			 
1b3e c9				ret 
1b3f			 
1b3f			jump:	 
1b3f			 
1b3f 21 c3 e2			ld hl,scratch+2 
1b42 cd 9e 11			call get_word_hl 
1b45				;ld hl,(scratch+2) 
1b45				;call fourehexhl 
1b45			 
1b45 22 e4 e5			ld (os_cur_ptr),hl	 
1b48			 
1b48 e9				jp (hl) 
1b49			 
1b49			 
1b49			 
1b49			; TODO implement a basic monitor mode to start with 
1b49			 
1b49			 
1b49			 
1b49			 
1b49			 
1b49			 
1b49			 
1b49			 
1b49			 
1b49			; testing and demo code during development 
1b49			 
1b49			 
1b49 .. 00		str1: db "Enter some text...",0 
1b5c .. 00		clear: db "                    ",0 
1b71			 
1b71			demo: 
1b71			 
1b71			 
1b71			 
1b71			;	call update_display 
1b71			 
1b71				; init scratch input area for testing 
1b71 21 c1 e2			ld hl, scratch	 
1b74 3e 00			ld a,0 
1b76 77				ld (hl),a 
1b77			 
1b77			 
1b77 3e 28		            LD   A, display_row_2 
1b79			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b79 11 49 1b		            LD   DE, str1 
1b7c cd cd 0b			call str_at_display 
1b7f			 
1b7f			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b7f			cloop:	 
1b7f 3e 50		            LD   A, display_row_3 
1b81			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b81 11 5c 1b		            LD   DE, clear 
1b84			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b84 cd cd 0b				call str_at_display 
1b87 3e 78			ld a, display_row_4 
1b89 11 b9 1b			ld de, prompt 
1b8c			 
1b8c cd cd 0b				call str_at_display 
1b8f cd dd 0b			call update_display 
1b92			 
1b92 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b94 16 0a			ld d, 10 
1b96 21 c1 e2			ld hl, scratch	 
1b99 cd 14 0e			call input_str 
1b9c			 
1b9c			;	call clear_display 
1b9c			;'	call update_display 
1b9c			 
1b9c 3e 00		            LD   A, display_row_1 
1b9e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b9e 11 5c 1b		            LD   DE, clear 
1ba1 cd cd 0b				call str_at_display 
1ba4			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ba4 3e 00		            LD   A, display_row_1 
1ba6			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ba6 11 c1 e2		            LD   DE, scratch 
1ba9			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ba9 cd cd 0b				call str_at_display 
1bac cd dd 0b			call update_display 
1baf			 
1baf 3e 00				ld a,0 
1bb1 21 c1 e2			ld hl, scratch 
1bb4 77				ld (hl),a 
1bb5			 
1bb5 00				nop 
1bb6 c3 7f 1b			jp cloop 
1bb9			 
1bb9			 
1bb9			 
1bb9			; OS Prompt 
1bb9			 
1bb9 .. 00		prompt: db ">",0 
1bbb .. 00		endprg: db "?",0 
1bbd			 
1bbd			 
1bbd			; handy next page prompt 
1bbd			next_page_prompt: 
1bbd e5				push hl 
1bbe d5				push de 
1bbf f5				push af 
1bc0 c5				push bc 
1bc1			 
1bc1 3e 9f			ld a,display_row_4 + display_cols - 1 
1bc3 11 bb 1b		        ld de, endprg 
1bc6 cd cd 0b			call str_at_display 
1bc9 cd dd 0b			call update_display 
1bcc cd 6e 65			call cin_wait 
1bcf c1				pop bc 
1bd0 f1				pop af 
1bd1 d1				pop de 
1bd2 e1				pop hl 
1bd3			 
1bd3			 
1bd3 c9				ret 
1bd4			 
1bd4			 
1bd4			; forth parser 
1bd4			 
1bd4			; My forth kernel 
1bd4			include "forth_kernel.asm" 
1bd4			; 
1bd4			; kernel to the forth OS 
1bd4			 
1bd4			DS_TYPE_STR: equ 1     ; string type 
1bd4			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1bd4			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1bd4			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1bd4			 
1bd4			FORTH_PARSEV1: equ 0 
1bd4			FORTH_PARSEV2: equ 0 
1bd4			FORTH_PARSEV3: equ 0 
1bd4			FORTH_PARSEV4: equ 0 
1bd4			FORTH_PARSEV5: equ 1 
1bd4			 
1bd4			;if FORTH_PARSEV5 
1bd4			;	FORTH_END_BUFFER: equ 0 
1bd4			;else 
1bd4			FORTH_END_BUFFER: equ 127 
1bd4			;endif 
1bd4			 
1bd4			FORTH_TRUE: equ 1 
1bd4			FORTH_FALSE: equ 0 
1bd4			 
1bd4			if FORTH_PARSEV4 
1bd4			include "forth_stackops.asm" 
1bd4			endif 
1bd4			 
1bd4			if FORTH_PARSEV5 
1bd4			include "forth_stackopsv5.asm" 
1bd4			 
1bd4			; Stack operations for v5 parser on wards 
1bd4			; * DATA stack 
1bd4			; * LOOP stack 
1bd4			; * RETURN stack 
1bd4			 
1bd4			 
1bd4			 
1bd4			FORTH_CHK_DSP_UNDER: macro 
1bd4				push hl 
1bd4				push de 
1bd4				ld hl,(cli_data_sp) 
1bd4				ld de, cli_data_stack 
1bd4				call cmp16 
1bd4				jp c, fault_dsp_under 
1bd4				pop de 
1bd4				pop hl 
1bd4				endm 
1bd4			 
1bd4			 
1bd4			FORTH_CHK_RSP_UNDER: macro 
1bd4				push hl 
1bd4				push de 
1bd4				ld hl,(cli_ret_sp) 
1bd4				ld de, cli_ret_stack 
1bd4				call cmp16 
1bd4				jp c, fault_rsp_under 
1bd4				pop de 
1bd4				pop hl 
1bd4				endm 
1bd4			 
1bd4			FORTH_CHK_LOOP_UNDER: macro 
1bd4				push hl 
1bd4				push de 
1bd4				ld hl,(cli_loop_sp) 
1bd4				ld de, cli_loop_stack 
1bd4				call cmp16 
1bd4				jp c, fault_loop_under 
1bd4				pop de 
1bd4				pop hl 
1bd4				endm 
1bd4			 
1bd4			FORTH_ERR_TOS_NOTSTR: macro 
1bd4				; TOSO might need more for checks when used 
1bd4				push af 
1bd4				ld a,(hl) 
1bd4				cp DS_TYPE_STR 
1bd4				jp nz, type_faultn   
1bd4				pop af 
1bd4				endm 
1bd4			 
1bd4			FORTH_ERR_TOS_NOTNUM: macro 
1bd4				push af 
1bd4				ld a,(hl) 
1bd4				cp DS_TYPE_INUM 
1bd4				jp nz, type_faultn   
1bd4				pop af 
1bd4				endm 
1bd4			 
1bd4			 
1bd4			; increase data stack pointer and save hl to it 
1bd4				 
1bd4			FORTH_DSP_NEXT: macro 
1bd4				call macro_forth_dsp_next 
1bd4				endm 
1bd4			 
1bd4			 
1bd4			macro_forth_dsp_next: 
1bd4				if DEBUG_FORTH_STACK_GUARD 
1bd4 cd 9d 61				call check_stacks 
1bd7				endif 
1bd7 e5				push hl 
1bd8 d5				push de 
1bd9 eb				ex de,hl 
1bda 2a ee e9			ld hl,(cli_data_sp) 
1bdd 23				inc hl 
1bde 23				inc hl 
1bdf			 
1bdf			; PARSEV5 
1bdf 23				inc hl 
1be0 22 ee e9			ld (cli_data_sp),hl 
1be3 73				ld (hl), e 
1be4 23				inc hl 
1be5 72				ld (hl), d 
1be6 d1				pop de 
1be7 e1				pop hl 
1be8				if DEBUG_FORTH_STACK_GUARD 
1be8 cd 9d 61				call check_stacks 
1beb				endif 
1beb c9				ret 
1bec			 
1bec			 
1bec			; increase ret stack pointer and save hl to it 
1bec				 
1bec			FORTH_RSP_NEXT: macro 
1bec				call macro_forth_rsp_next 
1bec				endm 
1bec			 
1bec			macro_forth_rsp_next: 
1bec				if DEBUG_FORTH_STACK_GUARD 
1bec cd 9d 61				call check_stacks 
1bef				endif 
1bef e5				push hl 
1bf0 d5				push de 
1bf1 eb				ex de,hl 
1bf2 2a f2 e9			ld hl,(cli_ret_sp) 
1bf5 23				inc hl 
1bf6 23				inc hl 
1bf7 22 f2 e9			ld (cli_ret_sp),hl 
1bfa 73				ld (hl), e 
1bfb 23				inc hl 
1bfc 72				ld (hl), d 
1bfd d1				pop de 
1bfe e1				pop hl 
1bff				if DEBUG_FORTH_STACK_GUARD 
1bff cd 9d 61				call check_stacks 
1c02				endif 
1c02 c9				ret 
1c03			 
1c03			; get current ret stack pointer and save to hl  
1c03				 
1c03			FORTH_RSP_TOS: macro 
1c03				call macro_forth_rsp_tos 
1c03				endm 
1c03			 
1c03			macro_forth_rsp_tos: 
1c03				;push de 
1c03 2a f2 e9			ld hl,(cli_ret_sp) 
1c06 cd 3e 1c			call loadhlptrtohl 
1c09				;ld e, (hl) 
1c09				;inc hl 
1c09				;ld d, (hl) 
1c09				;ex de, hl 
1c09					if DEBUG_FORTH_WORDS 
1c09			;			DMARK "RST" 
1c09						CALLMONITOR 
1c09 cd 6f ee			call debug_vector  
1c0c				endm  
# End of macro CALLMONITOR
1c0c					endif 
1c0c				;pop de 
1c0c c9				ret 
1c0d			 
1c0d			; pop ret stack pointer 
1c0d				 
1c0d			FORTH_RSP_POP: macro 
1c0d				call macro_forth_rsp_pop 
1c0d				endm 
1c0d			 
1c0d			 
1c0d			macro_forth_rsp_pop: 
1c0d				if DEBUG_FORTH_STACK_GUARD 
1c0d			;		DMARK "RPP" 
1c0d cd 9d 61				call check_stacks 
1c10					FORTH_CHK_RSP_UNDER 
1c10 e5				push hl 
1c11 d5				push de 
1c12 2a f2 e9			ld hl,(cli_ret_sp) 
1c15 11 ac e9			ld de, cli_ret_stack 
1c18 cd 05 0e			call cmp16 
1c1b da b1 62			jp c, fault_rsp_under 
1c1e d1				pop de 
1c1f e1				pop hl 
1c20				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c20				endif 
1c20 e5				push hl 
1c21 2a f2 e9			ld hl,(cli_ret_sp) 
1c24			 
1c24			 
1c24				if FORTH_ENABLE_FREE 
1c24			 
1c24					; get pointer 
1c24			 
1c24					push de 
1c24					push hl 
1c24			 
1c24					ld e, (hl) 
1c24					inc hl 
1c24					ld d, (hl) 
1c24			 
1c24					ex de, hl 
1c24					call free 
1c24			 
1c24					pop hl 
1c24					pop de 
1c24			 
1c24			 
1c24				endif 
1c24			 
1c24			 
1c24 2b				dec hl 
1c25 2b				dec hl 
1c26 22 f2 e9			ld (cli_ret_sp), hl 
1c29				; do stack underflow checks 
1c29 e1				pop hl 
1c2a				if DEBUG_FORTH_STACK_GUARD 
1c2a cd 9d 61				call check_stacks 
1c2d					FORTH_CHK_RSP_UNDER 
1c2d e5				push hl 
1c2e d5				push de 
1c2f 2a f2 e9			ld hl,(cli_ret_sp) 
1c32 11 ac e9			ld de, cli_ret_stack 
1c35 cd 05 0e			call cmp16 
1c38 da b1 62			jp c, fault_rsp_under 
1c3b d1				pop de 
1c3c e1				pop hl 
1c3d				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c3d				endif 
1c3d c9				ret 
1c3e			 
1c3e			 
1c3e			 
1c3e			; routine to load word pointed to by hl into hl 
1c3e			 
1c3e			loadhlptrtohl: 
1c3e			 
1c3e d5				push de 
1c3f 5e				ld e, (hl) 
1c40 23				inc hl 
1c41 56				ld d, (hl) 
1c42 eb				ex de, hl 
1c43 d1				pop de 
1c44			 
1c44 c9				ret 
1c45			 
1c45			 
1c45			 
1c45			 
1c45			 
1c45			; push a number held in HL onto the data stack 
1c45			; entry point for pushing a value when already in hl used in function above 
1c45			 
1c45			forth_push_numhl: 
1c45			 
1c45 e5				push hl    ; save value to push 
1c46			 
1c46			if DEBUG_FORTH_PUSH 
1c46				; see if disabled 
1c46			 
1c46			 
1c46 f5				push af 
1c47 3a 6f ee			ld a,(debug_vector) 
1c4a fe c9			cp $c9   ; ret 
1c4c			;	ld a, (os_view_disable) 
1c4c			;	cp '*' 
1c4c 28 34			jr z, .pskip2 
1c4e e5				push hl 
1c4f e5			push hl 
1c50 cd ba 0b			call clear_display 
1c53 e1			pop hl 
1c54 7c				ld a,h 
1c55 21 c6 e5			ld hl, os_word_scratch 
1c58 cd e8 10			call hexout 
1c5b e1				pop hl 
1c5c 7d				ld a,l 
1c5d 21 c8 e5			ld hl, os_word_scratch+2 
1c60 cd e8 10			call hexout 
1c63			 
1c63 21 ca e5			ld hl, os_word_scratch+4 
1c66 3e 00			ld a,0 
1c68 77				ld (hl),a 
1c69 11 c6 e5			ld de,os_word_scratch 
1c6c 3e 28				ld a, display_row_2 
1c6e cd cd 0b				call str_at_display 
1c71 11 d9 4c			ld de, .push_num 
1c74 3e 00			ld a, display_row_1 
1c76			 
1c76 cd cd 0b				call str_at_display 
1c79			 
1c79			 
1c79 cd dd 0b			call update_display 
1c7c cd f2 0a			call delay1s 
1c7f cd f2 0a			call delay1s 
1c82			.pskip2:  
1c82			 
1c82 f1				pop af 
1c83			endif	 
1c83			 
1c83			 
1c83				FORTH_DSP_NEXT 
1c83 cd d4 1b			call macro_forth_dsp_next 
1c86				endm 
# End of macro FORTH_DSP_NEXT
1c86			 
1c86 2a ee e9			ld hl, (cli_data_sp) 
1c89			 
1c89				; save item type 
1c89 3e 02			ld a,  DS_TYPE_INUM 
1c8b 77				ld (hl), a 
1c8c 23				inc hl 
1c8d			 
1c8d				; get word off stack 
1c8d d1				pop de 
1c8e 7b				ld a,e 
1c8f 77				ld (hl), a 
1c90 23				inc hl 
1c91 7a				ld a,d 
1c92 77				ld (hl), a 
1c93			 
1c93			if DEBUG_FORTH_PUSH 
1c93 2b				dec hl 
1c94 2b				dec hl 
1c95 2b				dec hl 
1c96						DMARK "PH5" 
1c96 f5				push af  
1c97 3a ab 1c			ld a, (.dmark)  
1c9a 32 6b ee			ld (debug_mark),a  
1c9d 3a ac 1c			ld a, (.dmark+1)  
1ca0 32 6c ee			ld (debug_mark+1),a  
1ca3 3a ad 1c			ld a, (.dmark+2)  
1ca6 32 6d ee			ld (debug_mark+2),a  
1ca9 18 03			jr .pastdmark  
1cab ..			.dmark: db "PH5"  
1cae f1			.pastdmark: pop af  
1caf			endm  
# End of macro DMARK
1caf				CALLMONITOR 
1caf cd 6f ee			call debug_vector  
1cb2				endm  
# End of macro CALLMONITOR
1cb2			endif	 
1cb2			 
1cb2 c9				ret 
1cb3			 
1cb3			 
1cb3			; Push a string to stack pointed to by hl 
1cb3			 
1cb3			forth_push_str: 
1cb3			 
1cb3			if DEBUG_FORTH_PUSH 
1cb3						DMARK "PSQ" 
1cb3 f5				push af  
1cb4 3a c8 1c			ld a, (.dmark)  
1cb7 32 6b ee			ld (debug_mark),a  
1cba 3a c9 1c			ld a, (.dmark+1)  
1cbd 32 6c ee			ld (debug_mark+1),a  
1cc0 3a ca 1c			ld a, (.dmark+2)  
1cc3 32 6d ee			ld (debug_mark+2),a  
1cc6 18 03			jr .pastdmark  
1cc8 ..			.dmark: db "PSQ"  
1ccb f1			.pastdmark: pop af  
1ccc			endm  
# End of macro DMARK
1ccc				CALLMONITOR 
1ccc cd 6f ee			call debug_vector  
1ccf				endm  
# End of macro CALLMONITOR
1ccf			endif	 
1ccf			    
1ccf e5				push hl 
1cd0 e5				push hl 
1cd1			 
1cd1			;	ld a, 0   ; find end of string 
1cd1 cd 45 12			call strlenz 
1cd4			if DEBUG_FORTH_PUSH 
1cd4						DMARK "PQ2" 
1cd4 f5				push af  
1cd5 3a e9 1c			ld a, (.dmark)  
1cd8 32 6b ee			ld (debug_mark),a  
1cdb 3a ea 1c			ld a, (.dmark+1)  
1cde 32 6c ee			ld (debug_mark+1),a  
1ce1 3a eb 1c			ld a, (.dmark+2)  
1ce4 32 6d ee			ld (debug_mark+2),a  
1ce7 18 03			jr .pastdmark  
1ce9 ..			.dmark: db "PQ2"  
1cec f1			.pastdmark: pop af  
1ced			endm  
# End of macro DMARK
1ced				CALLMONITOR 
1ced cd 6f ee			call debug_vector  
1cf0				endm  
# End of macro CALLMONITOR
1cf0			endif	 
1cf0 eb				ex de, hl 
1cf1 e1				pop hl   ; get ptr to start of string 
1cf2			if DEBUG_FORTH_PUSH 
1cf2						DMARK "PQ3" 
1cf2 f5				push af  
1cf3 3a 07 1d			ld a, (.dmark)  
1cf6 32 6b ee			ld (debug_mark),a  
1cf9 3a 08 1d			ld a, (.dmark+1)  
1cfc 32 6c ee			ld (debug_mark+1),a  
1cff 3a 09 1d			ld a, (.dmark+2)  
1d02 32 6d ee			ld (debug_mark+2),a  
1d05 18 03			jr .pastdmark  
1d07 ..			.dmark: db "PQ3"  
1d0a f1			.pastdmark: pop af  
1d0b			endm  
# End of macro DMARK
1d0b				CALLMONITOR 
1d0b cd 6f ee			call debug_vector  
1d0e				endm  
# End of macro CALLMONITOR
1d0e			endif	 
1d0e 19				add hl,de 
1d0f			if DEBUG_FORTH_PUSH 
1d0f						DMARK "PQE" 
1d0f f5				push af  
1d10 3a 24 1d			ld a, (.dmark)  
1d13 32 6b ee			ld (debug_mark),a  
1d16 3a 25 1d			ld a, (.dmark+1)  
1d19 32 6c ee			ld (debug_mark+1),a  
1d1c 3a 26 1d			ld a, (.dmark+2)  
1d1f 32 6d ee			ld (debug_mark+2),a  
1d22 18 03			jr .pastdmark  
1d24 ..			.dmark: db "PQE"  
1d27 f1			.pastdmark: pop af  
1d28			endm  
# End of macro DMARK
1d28				CALLMONITOR 
1d28 cd 6f ee			call debug_vector  
1d2b				endm  
# End of macro CALLMONITOR
1d2b			endif	 
1d2b			 
1d2b 2b				dec hl    ; see if there is an optional trailing double quote 
1d2c 7e				ld a,(hl) 
1d2d fe 22			cp '"' 
1d2f 20 03			jr nz, .strnoq 
1d31 3e 00			ld a, 0      ; get rid of double quote 
1d33 77				ld (hl), a 
1d34 23			.strnoq: inc hl 
1d35			 
1d35 3e 00			ld a, 0 
1d37 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d38			 
1d38 13				inc de ; add one for the type string 
1d39 13				inc de ; add one for null term??? 
1d3a			 
1d3a				; tos is get string pointer again 
1d3a				; de contains space to allocate 
1d3a				 
1d3a d5				push de 
1d3b			 
1d3b eb				ex de, hl 
1d3c			 
1d3c				;push af 
1d3c			 
1d3c			if DEBUG_FORTH_PUSH 
1d3c						DMARK "PHm" 
1d3c f5				push af  
1d3d 3a 51 1d			ld a, (.dmark)  
1d40 32 6b ee			ld (debug_mark),a  
1d43 3a 52 1d			ld a, (.dmark+1)  
1d46 32 6c ee			ld (debug_mark+1),a  
1d49 3a 53 1d			ld a, (.dmark+2)  
1d4c 32 6d ee			ld (debug_mark+2),a  
1d4f 18 03			jr .pastdmark  
1d51 ..			.dmark: db "PHm"  
1d54 f1			.pastdmark: pop af  
1d55			endm  
# End of macro DMARK
1d55				CALLMONITOR 
1d55 cd 6f ee			call debug_vector  
1d58				endm  
# End of macro CALLMONITOR
1d58			endif	 
1d58 cd ae 12			call malloc	; on ret hl now contains allocated memory 
1d5b				if DEBUG_FORTH_MALLOC_GUARD 
1d5b cc 31 4d				call z,malloc_error 
1d5e				endif 
1d5e			 
1d5e				 
1d5e c1				pop bc    ; get length 
1d5f d1				pop de   ;  get string start    
1d60			 
1d60				; hl has destination from malloc 
1d60			 
1d60 eb				ex de, hl    ; prep for ldir 
1d61			 
1d61 d5				push de   ; save malloc area for DSP later 
1d62				;push hl   ; save malloc area for DSP later 
1d62			 
1d62			if DEBUG_FORTH_PUSH 
1d62						DMARK "PHc" 
1d62 f5				push af  
1d63 3a 77 1d			ld a, (.dmark)  
1d66 32 6b ee			ld (debug_mark),a  
1d69 3a 78 1d			ld a, (.dmark+1)  
1d6c 32 6c ee			ld (debug_mark+1),a  
1d6f 3a 79 1d			ld a, (.dmark+2)  
1d72 32 6d ee			ld (debug_mark+2),a  
1d75 18 03			jr .pastdmark  
1d77 ..			.dmark: db "PHc"  
1d7a f1			.pastdmark: pop af  
1d7b			endm  
# End of macro DMARK
1d7b				CALLMONITOR 
1d7b cd 6f ee			call debug_vector  
1d7e				endm  
# End of macro CALLMONITOR
1d7e			endif	 
1d7e			 
1d7e			 
1d7e ed b0			ldir 
1d80			 
1d80			 
1d80				; push malloc to data stack     macro?????  
1d80			 
1d80				FORTH_DSP_NEXT 
1d80 cd d4 1b			call macro_forth_dsp_next 
1d83				endm 
# End of macro FORTH_DSP_NEXT
1d83			 
1d83				; save value and type 
1d83			 
1d83 2a ee e9			ld hl, (cli_data_sp) 
1d86			 
1d86				; save item type 
1d86 3e 01			ld a,  DS_TYPE_STR 
1d88 77				ld (hl), a 
1d89 23				inc hl 
1d8a			 
1d8a				; get malloc word off stack 
1d8a d1				pop de 
1d8b 73				ld (hl), e 
1d8c 23				inc hl 
1d8d 72				ld (hl), d 
1d8e			 
1d8e			 
1d8e			 
1d8e			if DEBUG_FORTH_PUSH 
1d8e 2a ee e9			ld hl, (cli_data_sp) 
1d91						DMARK "PHS" 
1d91 f5				push af  
1d92 3a a6 1d			ld a, (.dmark)  
1d95 32 6b ee			ld (debug_mark),a  
1d98 3a a7 1d			ld a, (.dmark+1)  
1d9b 32 6c ee			ld (debug_mark+1),a  
1d9e 3a a8 1d			ld a, (.dmark+2)  
1da1 32 6d ee			ld (debug_mark+2),a  
1da4 18 03			jr .pastdmark  
1da6 ..			.dmark: db "PHS"  
1da9 f1			.pastdmark: pop af  
1daa			endm  
# End of macro DMARK
1daa				CALLMONITOR 
1daa cd 6f ee			call debug_vector  
1dad				endm  
# End of macro CALLMONITOR
1dad			;	ex de,hl 
1dad			endif	 
1dad				; in case of spaces, skip the ptr past the copied string 
1dad				;pop af 
1dad				;ld (cli_origptr),hl 
1dad			 
1dad c9				ret 
1dae			 
1dae			 
1dae			 
1dae			; TODO ascii push input onto stack given hl to start of input 
1dae			 
1dae			; identify type 
1dae			; if starts with a " then a string 
1dae			; otherwise it is a number 
1dae			;  
1dae			; if a string 
1dae			;     scan for ending " to get length of string to malloc for + 1 
1dae			;     malloc 
1dae			;     put pointer to string on stack first byte flags as string 
1dae			; 
1dae			; else a number 
1dae			;    look for number format identifier 
1dae			;    $xx hex 
1dae			;    %xxxxx bin 
1dae			;    xxxxx decimal 
1dae			;    convert number to 16bit word.  
1dae			;    malloc word + 1 with flag to identiy as num 
1dae			;    put pointer to number on stack 
1dae			;   
1dae			;  
1dae			  
1dae			forth_apush: 
1dae				; kernel push 
1dae			 
1dae			if DEBUG_FORTH_PUSH 
1dae						DMARK "PSH" 
1dae f5				push af  
1daf 3a c3 1d			ld a, (.dmark)  
1db2 32 6b ee			ld (debug_mark),a  
1db5 3a c4 1d			ld a, (.dmark+1)  
1db8 32 6c ee			ld (debug_mark+1),a  
1dbb 3a c5 1d			ld a, (.dmark+2)  
1dbe 32 6d ee			ld (debug_mark+2),a  
1dc1 18 03			jr .pastdmark  
1dc3 ..			.dmark: db "PSH"  
1dc6 f1			.pastdmark: pop af  
1dc7			endm  
# End of macro DMARK
1dc7				CALLMONITOR 
1dc7 cd 6f ee			call debug_vector  
1dca				endm  
# End of macro CALLMONITOR
1dca			endif	 
1dca				; identify input type 
1dca			 
1dca 7e				ld a,(hl) 
1dcb fe 22			cp '"' 
1dcd 28 0a			jr z, .fapstr 
1dcf fe 24			cp '$' 
1dd1 ca f9 1d			jp z, .faphex 
1dd4 fe 25			cp '%' 
1dd6 ca e1 1d			jp z, .fapbin 
1dd9			;	cp 'b' 
1dd9			;	jp z, .fabin 
1dd9				; else decimal 
1dd9			 
1dd9				; TODO do decimal conversion 
1dd9				; decimal is stored as a 16bit word 
1dd9			 
1dd9				; by default everything is a string if type is not detected 
1dd9			.fapstr: ; 
1dd9 fe 22			cp '"' 
1ddb 20 01			jr nz, .strnoqu 
1ddd 23				inc hl 
1dde			.strnoqu: 
1dde c3 b3 1c			jp forth_push_str 
1de1			 
1de1			 
1de1			 
1de1			.fapbin:    ; push a binary string.  
1de1 11 00 00			ld de, 0   ; hold a 16bit value 
1de4			 
1de4 23			.fapbinshift:	inc hl  
1de5 7e				ld a,(hl) 
1de6 fe 00			cp 0     ; done scanning  
1de8 28 0b			jr z, .fapbdone  	; got it in HL so push  
1dea			 
1dea				; left shift de 
1dea eb				ex de, hl	 
1deb 29				add hl, hl 
1dec			 
1dec				; is 1 
1dec fe 31			cp '1' 
1dee 20 02			jr nz, .binzero 
1df0 cb 4d			bit 1, l 
1df2			.binzero: 
1df2 eb				ex de, hl	 ; save current de 
1df3 18 ef			jr .fapbinshift 
1df5			 
1df5			.fapbdone: 
1df5 eb				ex de, hl 
1df6 c3 45 1c			jp forth_push_numhl 
1df9			 
1df9			 
1df9			.faphex:   ; hex is always stored as a 16bit word 
1df9				; skip number prefix 
1df9 23				inc hl 
1dfa				; turn ascii into number 
1dfa cd 9e 11			call get_word_hl	; ret 16bit word in hl 
1dfd			 
1dfd c3 45 1c			jp forth_push_numhl 
1e00			 
1e00 00				 nop 
1e01			 
1e01			.fabin:   ; TODO bin conversion 
1e01			 
1e01			 
1e01 c9				ret 
1e02			 
1e02			 
1e02			; get either a string ptr or a 16bit word from the data stack 
1e02			 
1e02			FORTH_DSP: macro 
1e02				call macro_forth_dsp 
1e02				endm 
1e02			 
1e02			macro_forth_dsp: 
1e02				; data stack pointer points to current word on tos 
1e02			 
1e02 2a ee e9			ld hl,(cli_data_sp) 
1e05			 
1e05				if DEBUG_FORTH_PUSH 
1e05						DMARK "DSP" 
1e05 f5				push af  
1e06 3a 1a 1e			ld a, (.dmark)  
1e09 32 6b ee			ld (debug_mark),a  
1e0c 3a 1b 1e			ld a, (.dmark+1)  
1e0f 32 6c ee			ld (debug_mark+1),a  
1e12 3a 1c 1e			ld a, (.dmark+2)  
1e15 32 6d ee			ld (debug_mark+2),a  
1e18 18 03			jr .pastdmark  
1e1a ..			.dmark: db "DSP"  
1e1d f1			.pastdmark: pop af  
1e1e			endm  
# End of macro DMARK
1e1e			 
1e1e cd 64 4d				call display_data_sp 
1e21				;call break_point_state 
1e21				;rst 030h 
1e21				CALLMONITOR 
1e21 cd 6f ee			call debug_vector  
1e24				endm  
# End of macro CALLMONITOR
1e24				endif 
1e24			 
1e24 c9				ret 
1e25			 
1e25			; return hl to start of value on stack 
1e25			 
1e25			FORTH_DSP_VALUE: macro 
1e25				call macro_forth_dsp_value 
1e25				endm 
1e25			 
1e25			macro_forth_dsp_value: 
1e25			 
1e25				FORTH_DSP 
1e25 cd 02 1e			call macro_forth_dsp 
1e28				endm 
# End of macro FORTH_DSP
1e28			 
1e28 d5				push de 
1e29			 
1e29 23				inc hl ; skip type 
1e2a			 
1e2a 5e				ld e, (hl) 
1e2b 23				inc hl 
1e2c 56				ld d, (hl) 
1e2d eb				ex de,hl  
1e2e			 
1e2e d1				pop de 
1e2f			 
1e2f c9				ret 
1e30			 
1e30			; return hl to start of value to second item on stack 
1e30			 
1e30			FORTH_DSP_VALUEM1: macro 
1e30				call macro_forth_dsp_value_m1 
1e30				endm 
1e30			 
1e30			macro_forth_dsp_value_m1: 
1e30			 
1e30				FORTH_DSP 
1e30 cd 02 1e			call macro_forth_dsp 
1e33				endm 
# End of macro FORTH_DSP
1e33			 
1e33 2b				dec hl 
1e34 2b				dec hl 
1e35			;	dec hl 
1e35			 
1e35 d5				push de 
1e36			 
1e36 5e				ld e, (hl) 
1e37 23				inc hl 
1e38 56				ld d, (hl) 
1e39 eb				ex de,hl  
1e3a			 
1e3a d1				pop de 
1e3b			 
1e3b c9				ret 
1e3c			 
1e3c				 
1e3c			 
1e3c			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e3c			 
1e3c			FORTH_DSP_POP: macro 
1e3c				call macro_forth_dsp_pop 
1e3c				endm 
1e3c			 
1e3c			 
1e3c			; get the tos data type 
1e3c			 
1e3c			FORTH_DSP_TYPE:   macro 
1e3c			 
1e3c				;FORTH_DSP_VALUE 
1e3c				FORTH_DSP 
1e3c				 
1e3c				; hl points to value 
1e3c				; check type 
1e3c			 
1e3c				ld a,(hl) 
1e3c			 
1e3c				endm 
1e3c			 
1e3c			; load the tos value into hl 
1e3c			 
1e3c			 
1e3c			FORTH_DSP_VALUEHL:  macro 
1e3c				call macro_dsp_valuehl 
1e3c				endm 
1e3c			 
1e3c			 
1e3c			 
1e3c			macro_dsp_valuehl: 
1e3c				FORTH_DSP_VALUE 
1e3c cd 25 1e			call macro_forth_dsp_value 
1e3f				endm 
# End of macro FORTH_DSP_VALUE
1e3f			 
1e3f				;FORTH_ERR_TOS_NOTNUM 
1e3f			 
1e3f				;inc hl   ; skip type id 
1e3f			 
1e3f			;	push de 
1e3f			; 
1e3f			;	ld e, (hl) 
1e3f			;	inc hl 
1e3f			;	ld d, (hl) 
1e3f			;	ex de,hl  
1e3f			 
1e3f			;	pop de 
1e3f			 
1e3f				if DEBUG_FORTH_PUSH 
1e3f						DMARK "DVL" 
1e3f f5				push af  
1e40 3a 54 1e			ld a, (.dmark)  
1e43 32 6b ee			ld (debug_mark),a  
1e46 3a 55 1e			ld a, (.dmark+1)  
1e49 32 6c ee			ld (debug_mark+1),a  
1e4c 3a 56 1e			ld a, (.dmark+2)  
1e4f 32 6d ee			ld (debug_mark+2),a  
1e52 18 03			jr .pastdmark  
1e54 ..			.dmark: db "DVL"  
1e57 f1			.pastdmark: pop af  
1e58			endm  
# End of macro DMARK
1e58				CALLMONITOR 
1e58 cd 6f ee			call debug_vector  
1e5b				endm  
# End of macro CALLMONITOR
1e5b				endif 
1e5b c9				ret 
1e5c			 
1e5c			forth_apushstrhl:      
1e5c				; push of string requires use of cli_origptr 
1e5c				; bodge use 
1e5c			 
1e5c				; get current cli_origptr, save, update with temp pointer  
1e5c ed 5b 3e ea		ld de, (cli_origptr) 
1e60 22 3e ea			ld (cli_origptr), hl 
1e63 d5				push de 
1e64 cd ae 1d			call forth_apush 
1e67 d1				pop de 
1e68 ed 53 3e ea		ld (cli_origptr), de 
1e6c c9			        ret	 
1e6d			 
1e6d			 
1e6d			; increase loop stack pointer and save hl to it 
1e6d				 
1e6d			FORTH_LOOP_NEXT: macro 
1e6d				call macro_forth_loop_next 
1e6d				;nop 
1e6d				endm 
1e6d			 
1e6d			macro_forth_loop_next: 
1e6d				if DEBUG_FORTH_STACK_GUARD 
1e6d cd 9d 61				call check_stacks 
1e70				endif 
1e70 e5				push hl 
1e71 d5				push de 
1e72 eb				ex de,hl 
1e73 2a f0 e9			ld hl,(cli_loop_sp) 
1e76 23				inc hl 
1e77 23				inc hl 
1e78					if DEBUG_FORTH_WORDS 
1e78						DMARK "LNX" 
1e78 f5				push af  
1e79 3a 8d 1e			ld a, (.dmark)  
1e7c 32 6b ee			ld (debug_mark),a  
1e7f 3a 8e 1e			ld a, (.dmark+1)  
1e82 32 6c ee			ld (debug_mark+1),a  
1e85 3a 8f 1e			ld a, (.dmark+2)  
1e88 32 6d ee			ld (debug_mark+2),a  
1e8b 18 03			jr .pastdmark  
1e8d ..			.dmark: db "LNX"  
1e90 f1			.pastdmark: pop af  
1e91			endm  
# End of macro DMARK
1e91						CALLMONITOR 
1e91 cd 6f ee			call debug_vector  
1e94				endm  
# End of macro CALLMONITOR
1e94					endif 
1e94 22 f0 e9			ld (cli_loop_sp),hl 
1e97 73				ld (hl), e 
1e98 23				inc hl 
1e99 72				ld (hl), d 
1e9a d1				pop de    ; been reversed so save a swap on restore 
1e9b e1				pop hl 
1e9c				if DEBUG_FORTH_STACK_GUARD 
1e9c cd 9d 61				call check_stacks 
1e9f				endif 
1e9f c9				ret 
1ea0			 
1ea0			; get current ret stack pointer and save to hl  
1ea0				 
1ea0			FORTH_LOOP_TOS: macro 
1ea0				call macro_forth_loop_tos 
1ea0				endm 
1ea0			 
1ea0			macro_forth_loop_tos: 
1ea0 d5				push de 
1ea1 2a f0 e9			ld hl,(cli_loop_sp) 
1ea4 5e				ld e, (hl) 
1ea5 23				inc hl 
1ea6 56				ld d, (hl) 
1ea7 eb				ex de, hl 
1ea8 d1				pop de 
1ea9 c9				ret 
1eaa			 
1eaa			; pop loop stack pointer 
1eaa				 
1eaa			FORTH_LOOP_POP: macro 
1eaa				call macro_forth_loop_pop 
1eaa				endm 
1eaa			 
1eaa			 
1eaa			macro_forth_loop_pop: 
1eaa				if DEBUG_FORTH_STACK_GUARD 
1eaa					DMARK "LPP" 
1eaa f5				push af  
1eab 3a bf 1e			ld a, (.dmark)  
1eae 32 6b ee			ld (debug_mark),a  
1eb1 3a c0 1e			ld a, (.dmark+1)  
1eb4 32 6c ee			ld (debug_mark+1),a  
1eb7 3a c1 1e			ld a, (.dmark+2)  
1eba 32 6d ee			ld (debug_mark+2),a  
1ebd 18 03			jr .pastdmark  
1ebf ..			.dmark: db "LPP"  
1ec2 f1			.pastdmark: pop af  
1ec3			endm  
# End of macro DMARK
1ec3 cd 9d 61				call check_stacks 
1ec6					FORTH_CHK_LOOP_UNDER 
1ec6 e5				push hl 
1ec7 d5				push de 
1ec8 2a f0 e9			ld hl,(cli_loop_sp) 
1ecb 11 2a e9			ld de, cli_loop_stack 
1ece cd 05 0e			call cmp16 
1ed1 da b7 62			jp c, fault_loop_under 
1ed4 d1				pop de 
1ed5 e1				pop hl 
1ed6				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ed6				endif 
1ed6 e5				push hl 
1ed7 2a f0 e9			ld hl,(cli_loop_sp) 
1eda 2b				dec hl 
1edb 2b				dec hl 
1edc 22 f0 e9			ld (cli_loop_sp), hl 
1edf				; TODO do stack underflow checks 
1edf e1				pop hl 
1ee0				if DEBUG_FORTH_STACK_GUARD 
1ee0 cd 9d 61				call check_stacks 
1ee3					FORTH_CHK_LOOP_UNDER 
1ee3 e5				push hl 
1ee4 d5				push de 
1ee5 2a f0 e9			ld hl,(cli_loop_sp) 
1ee8 11 2a e9			ld de, cli_loop_stack 
1eeb cd 05 0e			call cmp16 
1eee da b7 62			jp c, fault_loop_under 
1ef1 d1				pop de 
1ef2 e1				pop hl 
1ef3				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ef3				endif 
1ef3 c9				ret 
1ef4			 
1ef4			macro_forth_dsp_pop: 
1ef4			 
1ef4 e5				push hl 
1ef5			 
1ef5				; release malloc data 
1ef5			 
1ef5				if DEBUG_FORTH_STACK_GUARD 
1ef5 cd 9d 61				call check_stacks 
1ef8					FORTH_CHK_DSP_UNDER 
1ef8 e5				push hl 
1ef9 d5				push de 
1efa 2a ee e9			ld hl,(cli_data_sp) 
1efd 11 28 e8			ld de, cli_data_stack 
1f00 cd 05 0e			call cmp16 
1f03 da ab 62			jp c, fault_dsp_under 
1f06 d1				pop de 
1f07 e1				pop hl 
1f08				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f08				endif 
1f08				;ld hl,(cli_data_sp) 
1f08			if DEBUG_FORTH_DOT 
1f08				DMARK "DPP" 
1f08 f5				push af  
1f09 3a 1d 1f			ld a, (.dmark)  
1f0c 32 6b ee			ld (debug_mark),a  
1f0f 3a 1e 1f			ld a, (.dmark+1)  
1f12 32 6c ee			ld (debug_mark+1),a  
1f15 3a 1f 1f			ld a, (.dmark+2)  
1f18 32 6d ee			ld (debug_mark+2),a  
1f1b 18 03			jr .pastdmark  
1f1d ..			.dmark: db "DPP"  
1f20 f1			.pastdmark: pop af  
1f21			endm  
# End of macro DMARK
1f21				CALLMONITOR 
1f21 cd 6f ee			call debug_vector  
1f24				endm  
# End of macro CALLMONITOR
1f24			endif	 
1f24			 
1f24			 
1f24			if FORTH_ENABLE_DSPPOPFREE 
1f24			 
1f24				FORTH_DSP 
1f24 cd 02 1e			call macro_forth_dsp 
1f27				endm 
# End of macro FORTH_DSP
1f27			 
1f27 7e				ld a, (hl) 
1f28 fe 01			cp DS_TYPE_STR 
1f2a 20 23			jr nz, .skippopfree 
1f2c			 
1f2c				FORTH_DSP_VALUEHL 
1f2c cd 3c 1e			call macro_dsp_valuehl 
1f2f				endm 
# End of macro FORTH_DSP_VALUEHL
1f2f 00				nop 
1f30			if DEBUG_FORTH_DOT 
1f30				DMARK "DPf" 
1f30 f5				push af  
1f31 3a 45 1f			ld a, (.dmark)  
1f34 32 6b ee			ld (debug_mark),a  
1f37 3a 46 1f			ld a, (.dmark+1)  
1f3a 32 6c ee			ld (debug_mark+1),a  
1f3d 3a 47 1f			ld a, (.dmark+2)  
1f40 32 6d ee			ld (debug_mark+2),a  
1f43 18 03			jr .pastdmark  
1f45 ..			.dmark: db "DPf"  
1f48 f1			.pastdmark: pop af  
1f49			endm  
# End of macro DMARK
1f49				CALLMONITOR 
1f49 cd 6f ee			call debug_vector  
1f4c				endm  
# End of macro CALLMONITOR
1f4c			endif	 
1f4c cd 78 13			call free 
1f4f			.skippopfree: 
1f4f				 
1f4f			 
1f4f			endif 
1f4f			 
1f4f			if DEBUG_FORTH_DOT_KEY 
1f4f				DMARK "DP2" 
1f4f				CALLMONITOR 
1f4f			endif	 
1f4f			 
1f4f				; move pointer down 
1f4f			 
1f4f 2a ee e9			ld hl,(cli_data_sp) 
1f52 2b				dec hl 
1f53 2b				dec hl 
1f54			; PARSEV5 
1f54 2b				dec hl 
1f55 22 ee e9			ld (cli_data_sp), hl 
1f58			 
1f58				if DEBUG_FORTH_STACK_GUARD 
1f58 cd 9d 61				call check_stacks 
1f5b					FORTH_CHK_DSP_UNDER 
1f5b e5				push hl 
1f5c d5				push de 
1f5d 2a ee e9			ld hl,(cli_data_sp) 
1f60 11 28 e8			ld de, cli_data_stack 
1f63 cd 05 0e			call cmp16 
1f66 da ab 62			jp c, fault_dsp_under 
1f69 d1				pop de 
1f6a e1				pop hl 
1f6b				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f6b				endif 
1f6b			 
1f6b e1				pop hl 
1f6c			 
1f6c c9				ret 
1f6d			 
1f6d			getwordathl: 
1f6d				; hl points to an address 
1f6d				; load hl with the word at that address 
1f6d			 
1f6d d5				push de 
1f6e			 
1f6e 5e				ld e, (hl) 
1f6f 23				inc hl 
1f70 56				ld d, (hl) 
1f71 eb				ex de, hl 
1f72			 
1f72 d1				pop de 
1f73 c9				ret 
1f74			 
1f74			 
1f74			 
1f74			 
1f74			 
1f74			; eof 
1f74			 
# End of file forth_stackopsv5.asm
1f74			endif 
1f74			 
1f74			loadwordinhl:	 
1f74			 
1f74 d5				push de 
1f75			 
1f75 5e				ld e, (hl) 
1f76 23				inc hl 
1f77 56				ld d, (hl) 
1f78 eb				ex de,hl  
1f79			 
1f79 d1				pop de 
1f7a			 
1f7a c9				ret 
1f7b			 
1f7b			user_word_eol:  
1f7b				; hl contains the pointer to where to create a linked list item from the end 
1f7b				; of the user dict to continue on at the system word dict 
1f7b				 
1f7b				; poke the stub of the word list linked list to repoint to rom words 
1f7b			 
1f7b				; stub format 
1f7b				; db   word id 
1f7b				; dw    link to next word 
1f7b			        ; db char length of token 
1f7b				; db string + 0 term 
1f7b				; db exec code....  
1f7b			 
1f7b 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f7d 77				ld (hl), a		; word id 
1f7e 23				inc hl 
1f7f			 
1f7f 11 4a 21			ld de, sysdict 
1f82 73				ld (hl), e		; next word link ie system dict 
1f83 23				inc hl 
1f84 72				ld (hl), d		; next word link ie system dict 
1f85 23				inc hl	 
1f86			 
1f86			;	ld (hl), sysdict		; next word link ie system dict 
1f86			;	inc hl 
1f86			;	inc hl 
1f86			 
1f86			;	inc hl 
1f86			;	inc hl 
1f86			 
1f86 3e 02			ld a, 2			; word length is 0 
1f88 77				ld (hl), a	 
1f89 23				inc hl 
1f8a			 
1f8a 3e 7e			ld a, '~'			; word length is 0 
1f8c 77				ld (hl), a	 
1f8d 23				inc hl 
1f8e 3e 00			ld a, 0			; save empty word 
1f90 77				ld (hl), a 
1f91			 
1f91 c9				ret 
1f92			 
1f92				 
1f92			 
1f92			forthexec_cleanup: 
1f92				FORTH_RSP_POP 
1f92 cd 0d 1c			call macro_forth_rsp_pop 
1f95				endm 
# End of macro FORTH_RSP_POP
1f95 c9				ret 
1f96			 
1f96			forth_call_hl: 
1f96				; taking hl 
1f96 e5				push hl 
1f97 c9				ret 
1f98			 
1f98			; this is called to reset Forth system but keep existing uwords etc 
1f98			 
1f98			forth_warmstart: 
1f98				; setup stack over/under flow checks 
1f98				if DEBUG_FORTH_STACK_GUARD 
1f98 cd 83 61				call chk_stk_init 
1f9b				endif 
1f9b			 
1f9b				; init stack pointers  - * these stacks go upwards *  
1f9b 21 ac e9			ld hl, cli_ret_stack 
1f9e 22 f2 e9			ld (cli_ret_sp), hl	 
1fa1				; set bottom of stack 
1fa1 3e 00			ld a,0 
1fa3 77				ld (hl),a 
1fa4 23				inc hl 
1fa5 77				ld (hl),a 
1fa6			 
1fa6 21 28 e8			ld hl, cli_data_stack 
1fa9 22 ee e9			ld (cli_data_sp), hl	 
1fac				; set bottom of stack 
1fac 3e 00			ld a,0 
1fae 77				ld (hl),a 
1faf 23				inc hl 
1fb0 77				ld (hl),a 
1fb1			 
1fb1 21 2a e9			ld hl, cli_loop_stack 
1fb4 22 f0 e9			ld (cli_loop_sp), hl	 
1fb7				; set bottom of stack 
1fb7 3e 00			ld a,0 
1fb9 77				ld (hl),a 
1fba 23				inc hl 
1fbb 77				ld (hl),a 
1fbc			 
1fbc				; init extent of current open file 
1fbc			 
1fbc 3e 00			ld a, 0 
1fbe 32 6a ea			ld (store_openext), a 
1fc1			 
1fc1 c9				ret 
1fc2			 
1fc2			 
1fc2			 
1fc2			; Cold Start - this is called to setup the whole Forth system 
1fc2			 
1fc2			forth_init: 
1fc2			 
1fc2				; setup stack over/under flow checks 
1fc2			 
1fc2			;	if DEBUG_FORTH_STACK_GUARD 
1fc2			;		call chk_stk_init 
1fc2			;	endif 
1fc2			 
1fc2				; enable auto display updates (slow.....) 
1fc2			 
1fc2 3e 01			ld a, 1 
1fc4 32 3c ea			ld (cli_autodisplay), a 
1fc7			 
1fc7				; if storage is in use disable long reads for now 
1fc7 3e 00			ld a, 0 
1fc9 32 75 ea			ld (store_longread), a 
1fcc			 
1fcc			 
1fcc				; show start up screen 
1fcc			 
1fcc cd ba 0b			call clear_display 
1fcf			 
1fcf 3e 00			ld a,0 
1fd1 32 5e ea			ld (f_cursor_ptr), a 
1fd4			 
1fd4				; set start of word list in start of ram - for use when creating user words 
1fd4			 
1fd4 21 8f 65			ld hl, baseram 
1fd7 22 be e5			ld (os_last_new_uword), hl 
1fda cd 7b 1f			call user_word_eol 
1fdd				 
1fdd			;		call display_data_sp 
1fdd			;		call next_page_prompt 
1fdd			 
1fdd			 
1fdd			 
1fdd			 
1fdd c9				ret 
1fde			 
1fde .. 00		.bootforth: db " Forth Kernel Init ",0 
1ff2			 
1ff2			; TODO push to stack 
1ff2			 
1ff2			;  
1ff2			 
1ff2			if FORTH_PARSEV2 
1ff2			 
1ff2			 
1ff2				include "forth_parserv2.asm" 
1ff2			 
1ff2			endif 
1ff2			 
1ff2			 
1ff2			; parse cli version 1 
1ff2			 
1ff2			if FORTH_PARSEV1 
1ff2			 
1ff2			 
1ff2			 
1ff2			      include "forth_parserv1.asm" 
1ff2			endif 
1ff2				 
1ff2			if FORTH_PARSEV3 
1ff2			 
1ff2			 
1ff2			 
1ff2			      include "forth_parserv3.asm" 
1ff2				include "forth_wordsv3.asm" 
1ff2			endif 
1ff2			 
1ff2			if FORTH_PARSEV4 
1ff2			 
1ff2			 
1ff2			 
1ff2			      include "forth_parserv4.asm" 
1ff2				include "forth_wordsv4.asm" 
1ff2			endif 
1ff2			 
1ff2			if FORTH_PARSEV5 
1ff2			 
1ff2			 
1ff2			 
1ff2			      include "forth_parserv5.asm" 
1ff2			 
1ff2			 
1ff2			; A better parser without using malloc and string copies all over the place.  
1ff2			; Exec in situ should be faster 
1ff2			 
1ff2			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1ff2			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1ff2			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1ff2			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1ff2			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1ff2			WORD_SYS_END: equ 0   ; Opcode for all user words 
1ff2			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1ff2			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1ff2			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1ff2			 
1ff2			; Core word preamble macro 
1ff2			 
1ff2			CWHEAD:   macro nxtword opcode lit len opflags 
1ff2				db WORD_SYS_CORE+opcode             
1ff2				; internal op code number 
1ff2				dw nxtword            
1ff2				; link to next dict word block 
1ff2				db len + 1 
1ff2				; literal length of dict word inc zero term 
1ff2				db lit,0              
1ff2				; literal dict word 
1ff2			        ; TODO db opflags        
1ff2				endm 
1ff2			 
1ff2			 
1ff2			NEXTW: macro  
1ff2				jp macro_next 
1ff2				endm 
1ff2			 
1ff2			macro_next: 
1ff2			if DEBUG_FORTH_PARSE_KEY 
1ff2				DMARK "NXT" 
1ff2				CALLMONITOR 
1ff2			endif	 
1ff2			;	inc hl  ; skip token null term  
1ff2 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ff6 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ffa 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ffd			if DEBUG_FORTH_PARSE_KEY 
1ffd				DMARK "}AA" 
1ffd				CALLMONITOR 
1ffd			endif	 
1ffd c3 00 21			jp execnext 
2000				;jp exec1 
2000			       
2000			 
2000			 
2000			; Another go at the parser to compile  
2000			 
2000			 
2000			; TODO rework parser to change all of the string words to byte tokens 
2000			; TODO do a search for  
2000			 
2000			; TODO first run normal parser to zero term sections 
2000			; TODO for each word do a token look up to get the op code 
2000			; TODO need some means to flag to the exec that this is a byte code form    
2000			 
2000			 
2000			forthcompile: 
2000			 
2000			; 
2000			; line parse: 
2000			;       parse raw input buffer 
2000			;       tokenise the words 
2000			;       malloc new copy (for looping etc) 
2000			;       copy to malloc + current pc in line to start of string and add line term 
2000			;       save on new rsp 
2000			; 
2000			 
2000			; hl to point to the line to tokenise 
2000			 
2000			;	push hl 
2000 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2003			 
2003			;	ld a,0		; string term on input 
2003			;	call strlent 
2003			 
2003			;	ld (os_tok_len), hl	 ; save string length 
2003			 
2003			;if DEBUG_FORTH_TOK 
2003			;	ex de,hl		 
2003			;endif 
2003			 
2003			;	pop hl 		; get back string pointer 
2003			 
2003			if DEBUG_FORTH_TOK 
2003						DMARK "TOc" 
2003				CALLMONITOR 
2003			endif 
2003 7e			.cptoken2:    ld a,(hl) 
2004 23				inc hl 
2005 fe 7f			cp FORTH_END_BUFFER 
2007 28 29			jr z, .cptokendone2 
2009 fe 00			cp 0 
200b 28 25			jr z, .cptokendone2 
200d fe 22			cp '"' 
200f 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2011 fe 20			cp ' ' 
2013 20 ee			jr nz,  .cptoken2 
2015			 
2015			; TODO consume comments held between ( and ) 
2015			 
2015				; we have a space so change to zero term for dict match later 
2015 2b				dec hl 
2016 3e 00			ld a,0 
2018 77				ld (hl), a 
2019 23				inc hl 
201a 18 e7			jr .cptoken2 
201c				 
201c			 
201c			.cptokenstr2: 
201c				; skip all white space until either eol (because forgot to term) or end double quote 
201c			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
201c				;inc hl ; skip current double quote 
201c 7e				ld a,(hl) 
201d 23				inc hl 
201e fe 22			cp '"' 
2020 28 e1			jr z, .cptoken2 
2022 fe 7f			cp FORTH_END_BUFFER 
2024 28 0c			jr z, .cptokendone2 
2026 fe 00			cp 0 
2028 28 08			jr z, .cptokendone2 
202a fe 20			cp ' ' 
202c 28 02			jr z, .cptmp2 
202e 18 ec			jr .cptokenstr2 
2030			 
2030			.cptmp2:	; we have a space so change to zero term for dict match later 
2030				;dec hl 
2030				;ld a,"-"	; TODO remove this when working 
2030				;ld (hl), a 
2030				;inc hl 
2030 18 ea			jr .cptokenstr2 
2032			 
2032			.cptokendone2: 
2032				;inc hl 
2032 3e 7f			ld a, FORTH_END_BUFFER 
2034 77				ld (hl),a 
2035 23				inc hl 
2036 3e 21			ld a, '!' 
2038 77				ld (hl),a 
2039			 
2039 2a c2 e5			ld hl,(os_tok_ptr) 
203c			         
203c			if DEBUG_FORTH_TOK 
203c						DMARK "Tc1" 
203c				CALLMONITOR 
203c			endif 
203c			 
203c				; push exec string to top of return stack 
203c				FORTH_RSP_NEXT 
203c cd ec 1b			call macro_forth_rsp_next 
203f				endm 
# End of macro FORTH_RSP_NEXT
203f c9				ret 
2040			 
2040			; Another go at the parser need to simplify the process 
2040			 
2040			forthparse: 
2040			 
2040			; 
2040			; line parse: 
2040			;       parse raw input buffer 
2040			;       tokenise the words 
2040			;       malloc new copy (for looping etc) 
2040			;       copy to malloc + current pc in line to start of string and add line term 
2040			;       save on new rsp 
2040			; 
2040			 
2040			; hl to point to the line to tokenise 
2040			 
2040			;	push hl 
2040 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2043			 
2043			;	ld a,0		; string term on input 
2043			;	call strlent 
2043			 
2043			;	ld (os_tok_len), hl	 ; save string length 
2043			 
2043			;if DEBUG_FORTH_TOK 
2043			;	ex de,hl		 
2043			;endif 
2043			 
2043			;	pop hl 		; get back string pointer 
2043			 
2043			if DEBUG_FORTH_TOK 
2043						DMARK "TOK" 
2043				CALLMONITOR 
2043			endif 
2043 7e			.ptoken2:    ld a,(hl) 
2044 23				inc hl 
2045 fe 7f			cp FORTH_END_BUFFER 
2047 28 29			jr z, .ptokendone2 
2049 fe 00			cp 0 
204b 28 25			jr z, .ptokendone2 
204d fe 22			cp '"' 
204f 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2051 fe 20			cp ' ' 
2053 20 ee			jr nz,  .ptoken2 
2055			 
2055			; TODO consume comments held between ( and ) 
2055			 
2055				; we have a space so change to zero term for dict match later 
2055 2b				dec hl 
2056 3e 00			ld a,0 
2058 77				ld (hl), a 
2059 23				inc hl 
205a 18 e7			jr .ptoken2 
205c				 
205c			 
205c			.ptokenstr2: 
205c				; skip all white space until either eol (because forgot to term) or end double quote 
205c			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
205c				;inc hl ; skip current double quote 
205c 7e				ld a,(hl) 
205d 23				inc hl 
205e fe 22			cp '"' 
2060 28 e1			jr z, .ptoken2 
2062 fe 7f			cp FORTH_END_BUFFER 
2064 28 0c			jr z, .ptokendone2 
2066 fe 00			cp 0 
2068 28 08			jr z, .ptokendone2 
206a fe 20			cp ' ' 
206c 28 02			jr z, .ptmp2 
206e 18 ec			jr .ptokenstr2 
2070			 
2070			.ptmp2:	; we have a space so change to zero term for dict match later 
2070				;dec hl 
2070				;ld a,"-"	; TODO remove this when working 
2070				;ld (hl), a 
2070				;inc hl 
2070 18 ea			jr .ptokenstr2 
2072			 
2072			.ptokendone2: 
2072				;inc hl 
2072 3e 7f			ld a, FORTH_END_BUFFER 
2074 77				ld (hl),a 
2075 23				inc hl 
2076 3e 21			ld a, '!' 
2078 77				ld (hl),a 
2079			 
2079 2a c2 e5			ld hl,(os_tok_ptr) 
207c			         
207c			if DEBUG_FORTH_TOK 
207c						DMARK "TK1" 
207c				CALLMONITOR 
207c			endif 
207c			 
207c				; push exec string to top of return stack 
207c				FORTH_RSP_NEXT 
207c cd ec 1b			call macro_forth_rsp_next 
207f				endm 
# End of macro FORTH_RSP_NEXT
207f c9				ret 
2080			 
2080			; 
2080			;	; malloc size + buffer pointer + if is loop flag 
2080			;	ld hl,(os_tok_len) 		 ; get string length 
2080			; 
2080			;	ld a,l 
2080			; 
2080			;	cp 0			; we dont want to use a null string 
2080			;	ret z 
2080			; 
2080			;;	add 3    ; prefix malloc with buffer for current word ptr 
2080			; 
2080			;	add 5     ; TODO when certain not over writing memory remove 
2080			; 
2080			;		 
2080			; 
2080			;if DEBUG_FORTH_TOK 
2080			;			DMARK "TKE" 
2080			;	CALLMONITOR 
2080			;endif 
2080			; 
2080			;	ld l,a 
2080			;	ld h,0 
2080			;;	push hl   ; save required space for the copy later 
2080			;	call malloc 
2080			;if DEBUG_FORTH_TOK 
2080			;			DMARK "TKM" 
2080			;	CALLMONITOR 
2080			;endif 
2080			;	if DEBUG_FORTH_MALLOC_GUARD 
2080			;		push af 
2080			;		call ishlzero 
2080			;;		ld a, l 
2080			;;		add h 
2080			;;		cp 0 
2080			;		pop af 
2080			;		 
2080			;		call z,malloc_error 
2080			;	endif 
2080			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2080			; 
2080			; 
2080			;if DEBUG_FORTH_TOK 
2080			;			DMARK "TKR" 
2080			;	CALLMONITOR 
2080			;endif 
2080			; 
2080			;	FORTH_RSP_NEXT 
2080			; 
2080			;	;inc hl	 ; go past current buffer pointer 
2080			;	;inc hl 
2080			;	;inc hl   ; and past if loop flag 
2080			;		; TODO Need to set flag  
2080			; 
2080			;	 
2080			;	 
2080			;	ex de,hl	; malloc is dest 
2080			;	ld hl, (os_tok_len) 
2080			;;	pop bc 
2080			;	ld c, l                
2080			;	ld b,0 
2080			;	ld hl, (os_tok_ptr) 
2080			; 
2080			;if DEBUG_FORTH_TOK 
2080			;			DMARK "TKT" 
2080			;	CALLMONITOR 
2080			;endif 
2080			; 
2080			;	; do str cpy 
2080			; 
2080			;	ldir      ; copy byte in hl to de 
2080			; 
2080			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2080			; 
2080			;if DEBUG_FORTH_TOK 
2080			; 
2080			;			DMARK "TKY" 
2080			;	CALLMONITOR 
2080			;endif 
2080			;	;ld a,0 
2080			;	;ld a,FORTH_END_BUFFER 
2080			;	ex de, hl 
2080			;	;dec hl			 ; go back over the space delim at the end of word 
2080			;	;ld (hl),a 
2080			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2080			;	ld a,FORTH_END_BUFFER 
2080			;	ld (hl),a 
2080			;	inc hl 
2080			;	ld a,FORTH_END_BUFFER 
2080			;	ld (hl),a 
2080			; 
2080			;	; init the malloc area data 
2080			;	; set pc for in current area 
2080			;	;ld hl, (os_tok_malloc) 
2080			;	;inc hl 
2080			;	;inc hl 
2080			;	;inc hl 
2080			;	;ex de,hl 
2080			;	;ld hl, (os_tok_malloc) 
2080			;	;ld (hl),e 
2080			;	;inc hl 
2080			;	;ld (hl),d 
2080			; 
2080			; 
2080			;	ld hl,(os_tok_malloc) 
2080			;if DEBUG_FORTH_PARSE_KEY 
2080			;			DMARK "TKU" 
2080			;	CALLMONITOR 
2080			;endif 
2080			; 
2080			;	ret 
2080			 
2080			forthexec: 
2080			 
2080			; line exec: 
2080			; forth parser 
2080			 
2080			; 
2080			;       get current exec line on rsp 
2080			 
2080				FORTH_RSP_TOS 
2080 cd 03 1c			call macro_forth_rsp_tos 
2083				endm 
# End of macro FORTH_RSP_TOS
2083			 
2083			;       restore current pc - hl points to malloc of data 
2083			 
2083				;ld e, (hl) 
2083				;inc hl 
2083				;ld d, (hl) 
2083				;ex de,hl 
2083			 
2083			 
2083			exec1: 
2083 22 c2 e5			ld (os_tok_ptr), hl 
2086			 
2086				; copy our PC to working vars  
2086 22 40 ea			ld (cli_ptr), hl 
2089 22 3e ea			ld (cli_origptr), hl 
208c			 
208c 7e				ld a,(hl) 
208d fe 7f			cp FORTH_END_BUFFER 
208f c8				ret z 
2090			 
2090				; skip any nulls 
2090			 
2090 fe 00			cp 0 
2092 20 03			jr nz, .execword 
2094 23				inc hl 
2095 18 ec			jr exec1 
2097			 
2097			 
2097			.execword: 
2097			 
2097			 
2097			 
2097			if DEBUG_FORTH_PARSE_KEY 
2097						DMARK "KYQ" 
2097				CALLMONITOR 
2097			endif 
2097			;       while at start of word: 
2097			; get start of dict (in user area first) 
2097			 
2097 21 8f 65		ld hl, baseram 
209a			;ld hl, sysdict 
209a 22 42 ea		ld (cli_nextword),hl 
209d			;           match word at pc 
209d			;           exec word 
209d			;           or push to dsp 
209d			;           forward to next token 
209d			;           if line term pop rsp and exit 
209d			;        
209d			 
209d			if DEBUG_FORTH_PARSE_KEY 
209d						DMARK "KYq" 
209d				CALLMONITOR 
209d			endif 
209d			 
209d			; 
209d			; word comp 
209d			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
209d			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
209d			;    move to start of word  
209d			;    compare word to cli_token 
209d			 
209d			.execpnword:	; HL at start of a word in the dictionary to check 
209d			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
209d			;	ld (cli_ptr), hl 
209d			 
209d 2a 42 ea			ld hl,(cli_nextword) 
20a0			 
20a0 cd 43 21			call forth_tok_next 
20a3			; tok next start here 
20a3			;	; TODO skip compiled symbol for now 
20a3			;	inc hl 
20a3			; 
20a3			;	; save pointer to next word 
20a3			; 
20a3			;	; hl now points to the address of the next word pointer  
20a3			;	ld e, (hl) 
20a3			;	inc hl 
20a3			;	ld d, (hl) 
20a3			;	inc l 
20a3			; 
20a3			;	ex de,hl 
20a3			;if DEBUG_FORTH_PARSE_NEXTWORD 
20a3			;	push bc 
20a3			;	ld bc, (cli_nextword) 
20a3			;			DMARK "NXW" 
20a3			;	CALLMONITOR 
20a3			;	pop bc 
20a3			;endif 
20a3			; tok next end here 
20a3 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
20a6 eb				ex de, hl 
20a7			 
20a7			 
20a7				; save the pointer of the current token - 1 to check against 
20a7				 
20a7 22 46 ea			ld (cli_token), hl   
20aa				; TODO maybe remove below save if no debug 
20aa				; save token string ptr for any debug later 
20aa 23				inc hl  
20ab 22 48 ea			ld (cli_origtoken), hl 
20ae 2b				dec hl 
20af				; save pointer to the start of the next dictionay word 
20af 7e				ld a,(hl)   ; get string length 
20b0 47				ld b,a 
20b1			.execpnwordinc:  
20b1 23				inc hl 
20b2 10 fd			djnz .execpnwordinc 
20b4 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
20b7			 
20b7				; now check the word token against the string being parsed 
20b7			 
20b7 2a 46 ea			ld hl,(cli_token) 
20ba 23				inc hl     ; skip string length (use zero term instead to end) 
20bb 22 46 ea			ld (cli_token), hl 
20be			 
20be			if DEBUG_FORTH_PARSE_KEY 
20be						DMARK "KY2" 
20be			endif 
20be			if DEBUG_FORTH_PARSE_EXEC 
20be				; see if disabled 
20be			 
20be			;	ld a, (os_view_disable) 
20be			;	cp '*' 
20be				ld a, (debug_vector) 
20be				cp $c9   ; RET  
20be				jr z, .skip 
20be			 
20be				push hl 
20be				push hl 
20be				call clear_display 
20be				ld de, .compword 
20be				ld a, display_row_1 
20be				call str_at_display 
20be				pop de 
20be				ld a, display_row_2 
20be				call str_at_display 
20be				ld hl,(cli_ptr) 
20be				ld a,(hl) 
20be			        ld hl, os_word_scratch 
20be				ld (hl),a 
20be				ld a,0 
20be				inc hl 
20be				ld (hl),a 	 
20be				ld de, os_word_scratch 
20be				ld a, display_row_2+10 
20be				call str_at_display 
20be				call update_display 
20be				ld a, 100 
20be				call aDelayInMS 
20be				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20be				call delay250ms 
20be				endif 
20be				pop hl 
20be			.skip:  
20be			endif	 
20be			.execpnchar:    ; compare char between token and string to parse 
20be			 
20be			if DEBUG_FORTH_PARSE_KEY 
20be						DMARK "Ky3" 
20be			endif 
20be			if DEBUG_FORTH_PARSE_EXEC 
20be				; see if disabled 
20be			 
20be			;	ld a, (os_view_disable) 
20be			;	cp '*' 
20be				ld a, (debug_vector) 
20be				cp $C9  ; RET 
20be				jr z, .skip2 
20be			 
20be			;	call clear_display 
20be			ld hl,(cli_token) 
20be			ld a,(hl) 
20be			ld (os_word_scratch),a 
20be				ld hl,(cli_ptr) 
20be			ld a,(hl) 
20be				ld (os_word_scratch+1),a 
20be				ld a,0 
20be				ld (os_word_scratch+2),a 
20be				ld de,os_word_scratch 
20be				ld a,display_row_4 
20be				call str_at_display 
20be				call update_display 
20be			.skip2:  
20be			endif 
20be 2a 46 ea			ld hl,(cli_token) 
20c1 7e				ld a, (hl)	 ; char in word token 
20c2 23				inc hl 		; move to next char 
20c3 22 46 ea			ld (cli_token), hl ; and save it 
20c6 47				ld b,a 
20c7			 
20c7 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
20ca 7e				ld a,(hl) 
20cb 23				inc hl 
20cc 22 40 ea			ld (cli_ptr), hl		; move to next char 
20cf cd 3c 12			call toUpper 		; make sure the input string matches case 
20d2			 
20d2			if DEBUG_FORTH_PARSE 
20d2			endif 
20d2			 
20d2				; input stream end of token is a space so get rid of it 
20d2			 
20d2			;	cp ' ' 
20d2			;	jr nz, .pnskipspace 
20d2			; 
20d2			;	ld a, 0		; make same term as word token term 
20d2			; 
20d2			;.pnskipspace: 
20d2			 
20d2			if DEBUG_FORTH_PARSE_KEY 
20d2						DMARK "KY7" 
20d2			endif 
20d2 b8				cp b 
20d3 c2 e9 20			jp nz, .execpnskipword	 ; no match so move to next word 
20d6				 
20d6			;    if same 
20d6			;       scan for string terms 0 for token and 32 for input 
20d6			 
20d6				 
20d6			if DEBUG_FORTH_PARSE_KEY 
20d6						DMARK "KY8" 
20d6			endif 
20d6			 
20d6 80				add b			 
20d7 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20d9							; TODO need to make sure last word in zero term string is accounted for 
20d9 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20db			 
20db			 
20db				; at end of both strings so both are exact match 
20db			 
20db			;       skip ptr for next word 
20db			 
20db 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
20de 23				inc hl			 ; at next char 
20df 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
20e2 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20e5				 
20e5				 
20e5			if DEBUG_FORTH_PARSE_KEY 
20e5						DMARK "KY3" 
20e5			endif 
20e5			 
20e5			 
20e5			 
20e5			;       exec code block 
20e5			if DEBUG_FORTH_JP 
20e5				call clear_display 
20e5				call update_display 
20e5				call delay1s 
20e5				ld hl, (cli_execword)     ; save for next check if no match on this word 
20e5				ld a,h 
20e5				ld hl, os_word_scratch 
20e5				call hexout 
20e5				ld hl, (cli_execword)     ; save for next check if no match on this word 
20e5				ld a,l 
20e5				ld hl, os_word_scratch+2 
20e5				call hexout 
20e5				ld hl, os_word_scratch+4 
20e5				ld a,0 
20e5				ld (hl),a 
20e5				ld de,os_word_scratch 
20e5				call str_at_display 
20e5					ld a, display_row_2 
20e5					call str_at_display 
20e5				ld de, (cli_origtoken) 
20e5				ld a, display_row_1+10 
20e5					call str_at_display 
20e5			 
20e5				ld a,display_row_1 
20e5				ld de, .foundword 
20e5				ld a, display_row_3 
20e5				call str_at_display 
20e5				call update_display 
20e5				call delay1s 
20e5				call delay1s 
20e5				call delay1s 
20e5			endif 
20e5			 
20e5			if DEBUG_FORTH_PARSE_KEY 
20e5						DMARK "KYj" 
20e5			endif 
20e5				; TODO save the word pointer in this exec 
20e5			 
20e5 2a 44 ea			ld hl,(cli_execword) 
20e8 e9				jp (hl) 
20e9			 
20e9			 
20e9			;    if not same 
20e9			;	scan for zero term 
20e9			;	get ptr for next word 
20e9			;	goto word comp 
20e9			 
20e9			.execpnskipword:	; get pointer to next word 
20e9 2a 42 ea			ld hl,(cli_nextword) 
20ec			 
20ec 7e				ld a,(hl) 
20ed fe 00			cp WORD_SYS_END 
20ef			;	cp 0 
20ef 28 09			jr z, .execendofdict			 ; at end of words 
20f1			 
20f1			if DEBUG_FORTH_PARSE_KEY 
20f1						DMARK "KY4" 
20f1			endif 
20f1			if DEBUG_FORTH_PARSE_EXEC 
20f1			 
20f1				; see if disabled 
20f1			 
20f1			;	ld a, (os_view_disable) 
20f1			;	cp '*' 
20f1				ld a,(debug_vector) 
20f1				cp $c9   ; RET 
20f1				jr z, .noskip 
20f1			 
20f1			 
20f1				ld de, .nowordfound 
20f1				ld a, display_row_3 
20f1				call str_at_display 
20f1				call update_display 
20f1				ld a, 100 
20f1				call aDelayInMS 
20f1				 
20f1				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20f1					call delay250ms 
20f1				endif 
20f1			.noskip:  
20f1			 
20f1			endif	 
20f1			 
20f1 2a 3e ea			ld hl,(cli_origptr) 
20f4 22 40 ea			ld (cli_ptr),hl 
20f7			 
20f7			if DEBUG_FORTH_PARSE_KEY 
20f7						DMARK "KY5" 
20f7			endif 
20f7 c3 9d 20			jp .execpnword			; else go to next word 
20fa			 
20fa			.execendofdict:  
20fa			 
20fa			if DEBUG_FORTH_PARSE_KEY 
20fa						DMARK "KYe" 
20fa			endif 
20fa			if DEBUG_FORTH_PARSE_EXEC 
20fa				; see if disabled 
20fa			 
20fa			;	ld a, (os_view_disable) 
20fa			;	cp '*' 
20fa				ld a,(debug_vector) 
20fa				cp $c9   ; ret 
20fa				jr z, .ispskip 
20fa			 
20fa				call clear_display 
20fa				call update_display 
20fa				call delay1s 
20fa				ld de, (cli_origptr) 
20fa				ld a, display_row_1 
20fa				call str_at_display 
20fa				 
20fa				ld de, .enddict 
20fa				ld a, display_row_3 
20fa				call str_at_display 
20fa				call update_display 
20fa				ld a, 100 
20fa				call aDelayInMS 
20fa				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20fa				call delay1s 
20fa				call delay1s 
20fa				call delay1s 
20fa				endif 
20fa			.ispskip:  
20fa				 
20fa			endif	 
20fa			 
20fa			 
20fa			 
20fa				; if the word is not a keyword then must be a literal so push it to stack 
20fa			 
20fa			; push token to stack to end of word 
20fa			 
20fa				STACKFRAME ON $1efe $2f9f 
20fa				if DEBUG_STACK_IMB 
20fa					if ON 
20fa						exx 
20fa						ld de, $1efe 
20fa						ld a, d 
20fa						ld hl, curframe 
20fa						call hexout 
20fa						ld a, e 
20fa						ld hl, curframe+2 
20fa						call hexout 
20fa						ld hl, $1efe 
20fa						push hl 
20fa						ld hl, $2f9f 
20fa						push hl 
20fa						exx 
20fa					endif 
20fa				endif 
20fa			endm 
# End of macro STACKFRAME
20fa			 
20fa 2a c2 e5		ld hl,(os_tok_ptr) 
20fd cd ae 1d		call forth_apush 
2100			 
2100				STACKFRAMECHK ON $1efe $2f9f 
2100				if DEBUG_STACK_IMB 
2100					if ON 
2100						exx 
2100						ld hl, $2f9f 
2100						pop de   ; $2f9f 
2100						call cmp16 
2100						jr nz, .spnosame 
2100						ld hl, $1efe 
2100						pop de   ; $1efe 
2100						call cmp16 
2100						jr z, .spfrsame 
2100						.spnosame: call showsperror 
2100						.spfrsame: nop 
2100						exx 
2100					endif 
2100				endif 
2100			endm 
# End of macro STACKFRAMECHK
2100			 
2100			execnext: 
2100			 
2100			if DEBUG_FORTH_PARSE_KEY 
2100						DMARK "KY>" 
2100			endif 
2100			; move past token to next word 
2100			 
2100 2a c2 e5		ld hl, (os_tok_ptr) 
2103 3e 00		ld a, 0 
2105 01 ff 00		ld bc, 255     ; input buffer size 
2108 ed b1		cpir 
210a			 
210a			if DEBUG_FORTH_PARSE_KEY 
210a						DMARK "KY!" 
210a				CALLMONITOR 
210a			endif	 
210a			; TODO this might place hl on the null, so will need to forward on??? 
210a			;inc hl   ; see if this gets onto the next item 
210a			 
210a			 
210a			; TODO pass a pointer to the buffer to push 
210a			; TODO call function to push 
210a			 
210a			; look for end of input 
210a			 
210a			;inc hl 
210a			;ld a,(hl) 
210a			;cp FORTH_END_BUFFER 
210a			;ret z 
210a			 
210a			 
210a c3 83 20		jp exec1 
210d			 
210d			 
210d			 
210d			 
210d			 
210d			 
210d			 
210d			 
210d			 
210d			findnexttok: 
210d			 
210d				; hl is pointer to move 
210d				; de is the token to locate 
210d			 
210d					if DEBUG_FORTH 
210d						DMARK "NTK" 
210d						CALLMONITOR 
210d					endif 
210d d5				push de 
210e			 
210e			.fnt1:	 
210e				; find first char of token to locate 
210e			 
210e 1a				ld a, (de) 
210f 4f				ld c,a 
2110 7e				ld a,(hl) 
2111 cd 3c 12			call toUpper 
2114					if DEBUG_FORTH 
2114						DMARK "NT1" 
2114						CALLMONITOR 
2114					endif 
2114 b9				cp c 
2115			 
2115 28 03			jr z, .fnt2cmpmorefirst	 
2117			 
2117				; first char not found move to next char 
2117			 
2117 23				inc hl 
2118 18 f4			jr .fnt1 
211a			 
211a			.fnt2cmpmorefirst:	 
211a				; first char of token found.  
211a			 
211a e5				push hl     ; save start of token just in case it is the right one 
211b d9				exx 
211c e1				pop hl        ; save it to hl' 
211d d9				exx 
211e			 
211e			 
211e			.fnt2cmpmore:	 
211e				; compare the rest 
211e				 
211e 23				inc hl 
211f 13				inc de 
2120				 
2120 1a				ld a, (de) 
2121 4f				ld c,a 
2122 7e				ld a,(hl) 
2123 cd 3c 12			call toUpper 
2126			 
2126					if DEBUG_FORTH 
2126						DMARK "NT2" 
2126						CALLMONITOR 
2126					endif 
2126				; c has the token to find char 
2126				; a has the mem to scan char 
2126			 
2126 b9				cp c 
2127 28 04			jr z,.fntmatch1 
2129			 
2129				; they are not the same 
2129			 
2129					if DEBUG_FORTH 
2129						DMARK "NT3" 
2129						CALLMONITOR 
2129					endif 
2129 d1				pop de	; reset de token to look for 
212a d5				push de 
212b 18 e1			jr .fnt1 
212d				 
212d			.fntmatch1: 
212d			 
212d				; is the same char a null which means we might have a full hit? 
212d					if DEBUG_FORTH 
212d						DMARK "NT4" 
212d						CALLMONITOR 
212d					endif 
212d			 
212d fe 00			cp 0 
212f 28 0b			jr z, .fntmatchyes 
2131			 
2131				; are we at the end of the token to find? 
2131			 
2131					if DEBUG_FORTH 
2131						DMARK "NT5" 
2131						CALLMONITOR 
2131					endif 
2131 3e 00			ld a, 0 
2133 b9				cp c 
2134			 
2134 c2 1e 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2137			 
2137					if DEBUG_FORTH 
2137						DMARK "NT6" 
2137						CALLMONITOR 
2137					endif 
2137				; token to find is exhusted but no match to stream 
2137			 
2137				; restore tok pointer and continue on 
2137 d1				pop de 
2138 d5				push de 
2139 c3 0e 21			jp .fnt1 
213c			 
213c			 
213c			.fntmatchyes: 
213c			 
213c				; hl now contains the end of the found token 
213c			 
213c				; get rid of saved token pointer to find 
213c			 
213c d1				pop de 
213d			 
213d					if DEBUG_FORTH 
213d						DMARK "NT9" 
213d						CALLMONITOR 
213d					endif 
213d			 
213d				; hl will be on the null term so forward on 
213d			 
213d				; get back the saved start of the token 
213d			 
213d d9				exx 
213e e5				push hl     ; save start of token just in case it is the right one 
213f d9				exx 
2140 e1				pop hl        ; save it to hl 
2141			 
2141 c9				ret 
2142			 
2142			 
2142			; LIST needs to find a specific token   
2142			; FORGET needs to find a spefici token 
2142			 
2142			; SAVE needs to find all tokens by flag 
2142			; WORDS just needs to scan through all  by flag 
2142			; UWORDS needs to scan through all by flag 
2142			 
2142			 
2142			; given hl as pointer to start of dict look up string 
2142			; return hl as pointer to start of word block 
2142			; or 0 if not found 
2142			 
2142			forth_find_tok: 
2142 c9				ret 
2143			 
2143			; given hl as pointer to dict structure 
2143			; move to the next dict block structure 
2143			 
2143			forth_tok_next: 
2143				; hl now points to the address of the next word pointer  
2143				; TODO skip compiled symbol for now 
2143			;	push de 
2143 23				inc hl 
2144 5e				ld e, (hl) 
2145 23				inc hl 
2146 56				ld d, (hl) 
2147 23				inc hl 
2148			 
2148 eb				ex de,hl 
2149			if DEBUG_FORTH_PARSE_NEXTWORD 
2149				push bc 
2149				ld bc, (cli_nextword) 
2149						DMARK "NXW" 
2149				CALLMONITOR 
2149				pop bc 
2149			endif 
2149			;	pop de	 
2149 c9				ret 
214a			 
214a			 
214a			 
214a			; eof 
# End of file forth_parserv5.asm
214a				include "forth_wordsv4.asm" 
214a			 
214a			; the core word dictionary v4 
214a			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
214a			 
214a			; this is a linked list for each of the system words used 
214a			; user defined words will follow the same format but will be in ram 
214a			 
214a			 
214a			; 
214a			; 
214a			; define linked list: 
214a			; 
214a			; 1. compiled byte op code 
214a			; 2. len of text word 
214a			; 3. text word 
214a			; 4. ptr to next dictionary word 
214a			; 5. asm, calls etc for the word 
214a			; 
214a			;  if 1 == 0 then last word in dict  
214a			;   
214a			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
214a			;  
214a			;  
214a			; create basic standard set of words 
214a			; 
214a			;  
214a			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
214a			; 2DUP 2DROP 2SWAP  
214a			; @ C@ - get byte  
214a			; ! C! - store byte 
214a			; 0< true if less than zero 
214a			; 0= true if zero 
214a			; < >  
214a			; = true if same 
214a			; variables 
214a			 
214a			 
214a			; Hardware specific words I may need 
214a			; 
214a			; IN OUT  
214a			; calls to key util functions 
214a			; calls to hardward abstraction stuff 
214a			; easy control of frame buffers and lcd i/o 
214a			; keyboard  
214a			 
214a			 
214a			;DICT: macro 
214a			; op_code, len, word, next 
214a			;    word: 
214a			;    db op_code 
214a			;    ds word zero term 
214a			;    dw next 
214a			;    endm 
214a			 
214a			 
214a			 
214a			 
214a			; op code 1 is a flag for user define words which are to be handled differently 
214a			 
214a			 
214a			; 
214a			; 
214a			;    TODO on entry to a word this should be the expected environment 
214a			;    hl - tos value if number then held, if string this is the ptr 
214a			;    de -  
214a			 
214a			 
214a			; opcode ranges 
214a			; 0 - end of word dict 
214a			; 255 - user define words 
214a			 
214a			sysdict: 
214a			include "forth_opcodes.asm" 
214a			; op codes for forth keywords 
214a			; free to use code 0  
214a				OPCODE_HEAP: equ  1 
214a				OPCODE_EXEC: equ 2 
214a				OPCODE_DUP: equ 3 
214a				OPCODE_SWAP: equ 4 
214a				OPCODE_COLN: equ 5 
214a				OPCODE_SCOLN: equ 6 
214a				OPCODE_DROP: equ 7 
214a				OPCODE_DUP2: equ 8 
214a				OPCODE_DROP2: equ 9 
214a				OPCODE_SWAP2: equ 10 
214a				OPCODE_AT: equ 11 
214a				OPCODE_CAT: equ 12 
214a				OPCODE_BANG: equ 13 
214a				OPCODE_CBANG: equ 14 
214a				OPCODE_SCALL: equ 15 
214a				OPCODE_DEPTH: equ 16 
214a				OPCODE_OVER: equ 17 
214a				OPCODE_PAUSE: equ 18 
214a				OPCODE_PAUSES: equ 19 
214a				OPCODE_ROT: equ 20 
214a			;free to reuse	OPCODE_WORDS: equ 21 
214a			        OPCODE_NOT: equ 21 
214a				OPCODE_UWORDS: equ 22 
214a				OPCODE_BP: equ 23 
214a				OPCODE_MONITOR: equ 24  
214a				OPCODE_MALLOC: equ 25 
214a				OPCODE_FREE: equ 26 
214a				OPCODE_LIST: equ 27 
214a				OPCODE_FORGET: equ 28 
214a				OPCODE_NOP: equ 29 
214a				OPCODE_COMO: equ 30 
214a				OPCODE_COMC: equ 31 
214a			;free to reuse	OPCODE_ENDCORE: equ 32 
214a				OPCODE_AFTERSOUND: equ 33 
214a				OPCODE_GP2: equ 34 
214a				OPCODE_GP3: equ 35 
214a				OPCODE_GP4: equ 36 
214a				OPCODE_SIN: equ 37 
214a				OPCODE_SOUT: equ 38 
214a				OPCODE_SPIO: equ 39 
214a				OPCODE_SPICEH: equ 40 
214a				OPCODE_SPIOb: equ 41 
214a				OPCODE_SPII: equ 42 
214a				OPCODE_SESEL: equ 43 
214a				OPCODE_CARTDEV: equ 44 
214a			; free to reuse	OPCODE_ENDDEVICE: equ 45 
214a				OPCODE_FB: equ 46 
214a				OPCODE_EMIT: equ 47 
214a				OPCODE_DOTH: equ 48 
214a				OPCODE_DOTF: equ 49 
214a				OPCODE_DOT: equ 50 
214a				OPCODE_CLS: equ 51 
214a				OPCODE_DRAW: equ 52 
214a				OPCODE_DUMP: equ 53 
214a				OPCODE_CDUMP: equ 54 
214a				OPCODE_DAT: equ 55 
214a				OPCODE_HOME: equ 56 
214a				OPCODE_SPACE: equ 57 
214a				OPCODE_SPACES: equ 58 
214a				OPCODE_SCROLL: equ 59 
214a				OPCODE_ATQ: equ 60 
214a				OPCODE_AUTODSP: equ 61 
214a				OPCODE_MENU: equ 62 
214a			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
214a				OPCODE_THEN: equ 64 
214a				OPCODE_ELSE: equ 65 
214a				OPCODE_DO: equ 66 
214a				OPCODE_LOOP: equ 67 
214a				OPCODE_I: equ 68 
214a				OPCODE_DLOOP: equ 69  
214a				OPCODE_REPEAT: equ 70  
214a				OPCODE_UNTIL: equ 71 
214a				OPCODE_ENDFLOW: equ 72 
214a				OPCODE_WAITK: equ 73 
214a				OPCODE_ACCEPT: equ 74 
214a				OPCODE_EDIT: equ 75 
214a			;free to reuse	OPCODE_ENDKEY: equ 76 
214a				OPCODE_LZERO: equ 77 
214a				OPCODE_TZERO: equ 78 
214a				OPCODE_LESS: equ 79 
214a				OPCODE_GT: equ 80 
214a				OPCODE_EQUAL: equ 81  
214a			;free to reuse	OPCODE_ENDLOGIC: equ 82 
214a				OPCODE_NEG: equ 83 
214a				OPCODE_DIV: equ 84 
214a				OPCODE_MUL: equ 85 
214a				OPCODE_MIN: equ 86 
214a				OPCODE_MAX: equ 87 
214a				OPCODE_RND16: equ 88 
214a				OPCODE_RND8: equ 89 
214a				OPCODE_RND: equ 90 
214a			;free to reuse	OPCODE_ENDMATHS: equ 91  
214a				OPCODE_BYNAME: equ 92 
214a				OPCODE_DIR: equ 93 
214a				OPCODE_SAVE: equ 94 
214a				OPCODE_LOAD: equ 95 
214a				OPCODE_BSAVE: equ 96 
214a				OPCODE_BLOAD: equ 97 
214a				OPCODE_SEO: equ 98  
214a				OPCODE_SEI: equ 99 
214a				OPCODE_SFREE: equ 100 
214a				OPCODE_SIZE: equ 101 
214a				OPCODE_CREATE: equ 102 
214a				OPCODE_APPEND: equ 103 
214a				OPCODE_SDEL: equ 104 
214a				OPCODE_OPEN: equ 105 
214a				OPCODE_READ: equ 106 
214a				OPCODE_EOF: equ 106 
214a				OPCODE_FORMAT: equ 107 
214a				OPCODE_LABEL: equ 108 
214a				OPCODE_LABELS: equ 109 
214a			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
214a				OPCODE_UPPER: equ 111 
214a				OPCODE_LOWER: equ 112 
214a				OPCODE_SUBSTR: equ 113 
214a				OPCODE_LEFT: equ 114 
214a				OPCODE_RIGHT: equ 115 
214a				OPCODE_STR2NUM: equ 116 
214a				OPCODE_NUM2STR: equ 117 
214a				OPCODE_CONCAT: equ 118 
214a				OPCODE_FIND: equ 119 
214a				OPCODE_LEN: equ 120 
214a				OPCODE_CHAR: equ 121 
214a			; free to reuse	OPCODE_STRLEN: equ 122 
214a			; free to reuse	OPCODE_ENDSTR: equ 123 
214a				OPCODE_V0S: equ 124 
214a				OPCODE_V0Q: equ 125 
214a				OPCODE_V1S: equ 126 
214a				OPCODE_V1Q: equ 127 
214a				OPCODE_V2S: equ 128 
214a				OPCODE_V2Q: equ 129 
214a				OPCODE_V3S: equ 130 
214a				OPCODE_V3Q: equ 131 
214a			;free to reuse	OPCODE_END: equ 132 
214a				OPCODE_ZDUP: equ 133 
214a			 
214a			; eof 
# End of file forth_opcodes.asm
214a			 
214a			include "forth_words_core.asm" 
214a			 
214a			; | ## Core Words 
214a			 
214a			;if MALLOC_4 
214a			 
214a			.HEAP: 
214a				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
214a 15				db WORD_SYS_CORE+OPCODE_HEAP             
214b 89 21			dw .EXEC            
214d 05				db 4 + 1 
214e .. 00			db "HEAP",0              
2153				endm 
# End of macro CWHEAD
2153			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2153			; | | u1 - Current number of bytes in the heap 
2153			; | | u2 - Remaining bytes left on the heap 
2153			; | |  
2153			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2153			 
2153			 
2153					if DEBUG_FORTH_WORDS_KEY 
2153						DMARK "HEP" 
2153 f5				push af  
2154 3a 68 21			ld a, (.dmark)  
2157 32 6b ee			ld (debug_mark),a  
215a 3a 69 21			ld a, (.dmark+1)  
215d 32 6c ee			ld (debug_mark+1),a  
2160 3a 6a 21			ld a, (.dmark+2)  
2163 32 6d ee			ld (debug_mark+2),a  
2166 18 03			jr .pastdmark  
2168 ..			.dmark: db "HEP"  
216b f1			.pastdmark: pop af  
216c			endm  
# End of macro DMARK
216c						CALLMONITOR 
216c cd 6f ee			call debug_vector  
216f				endm  
# End of macro CALLMONITOR
216f					endif 
216f 2a 99 65				ld hl, (free_list )      
2172 11 9e 65				ld de, heap_start 
2175			 
2175 ed 52				sbc hl, de  
2177			 
2177 cd 45 1c				call forth_push_numhl 
217a			 
217a			 
217a ed 5b 99 65			ld de, (free_list )      
217e 21 a8 e2				ld hl, heap_end 
2181			 
2181 ed 52				sbc hl, de 
2183			 
2183 cd 45 1c				call forth_push_numhl 
2186					 
2186			 
2186					 
2186			 
2186			 
2186			 
2186					NEXTW 
2186 c3 f2 1f			jp macro_next 
2189				endm 
# End of macro NEXTW
2189			;endif 
2189			 
2189			.EXEC: 
2189			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2189			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2189			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2189			;; > > 
2189			;; > >   
2189			;	STACKFRAME OFF $5efe $5f9f 
2189			; 
2189			;		if DEBUG_FORTH_WORDS_KEY 
2189			;			DMARK "EXE" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			; 
2189			;	FORTH_DSP_VALUEHL 
2189			; 
2189			;	FORTH_DSP_POP 
2189			; 
2189			;		if DEBUG_FORTH_WORDS 
2189			;			DMARK "EX1" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			;;	ld e,(hl) 
2189			;;	inc hl 
2189			;;	ld d,(hl) 
2189			;;	ex de,hl 
2189			; 
2189			;;		if DEBUG_FORTH_WORDS 
2189			;;			DMARK "EX2" 
2189			;;			CALLMONITOR 
2189			;;		endif 
2189			;	push hl 
2189			; 
2189			;	;ld a, 0 
2189			;	;ld a, FORTH_END_BUFFER 
2189			;	call strlenz 
2189			;	inc hl   ; include zero term to copy 
2189			;	inc hl   ; include term 
2189			;	inc hl   ; include term 
2189			;	ld b,0 
2189			;	ld c,l 
2189			;	pop hl 
2189			;	ld de, execscratch 
2189			;		if DEBUG_FORTH_WORDS 
2189			;			DMARK "EX3" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			;	ldir 
2189			; 
2189			; 
2189			;	ld hl, execscratch 
2189			; 
2189			;		if DEBUG_FORTH_WORDS 
2189			;			DMARK "EXe" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			; 
2189			;	call forthparse 
2189			;	call forthexec 
2189			;;	call forthexec_cleanup 
2189			;;	call forthparse 
2189			;;	call forthexec 
2189			; 
2189			;	STACKFRAMECHK OFF $5efe $5f9f 
2189			; 
2189			;	; an immediate word so no need to process any more words 
2189			;	ret 
2189			;	NEXTW 
2189			 
2189			; dead code - old version  
2189			;	FORTH_RSP_NEXT 
2189			 
2189			;  
2189			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2189			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2189			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2189			;	push hl 
2189			;	push de 
2189			;	push bc 
2189			; 
2189			; 
2189			;		if DEBUG_FORTH_WORDS_KEY 
2189			;			DMARK "EXR" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			; 
2189			; 
2189			; 
2189			;	;v5 FORTH_DSP_VALUE 
2189			;	FORTH_DSP_VALUEHL 
2189			; 
2189			;	; TODO do string type checks 
2189			; 
2189			;;v5	inc hl   ; skip type 
2189			; 
2189			;	push hl  ; source code  
2189			;		if DEBUG_FORTH_WORDS 
2189			;			DMARK "EX1" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			;	ld a, 0 
2189			;	call strlent 
2189			; 
2189			;	inc hl 
2189			;	inc hl 
2189			;	inc hl 
2189			;	inc hl 
2189			; 
2189			;	push hl    ; size 
2189			; 
2189			;		if DEBUG_FORTH_WORDS 
2189			;			DMARK "EX2" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			;	call malloc 
2189			; 
2189			;	ex de, hl    ; de now contains malloc area 
2189			;	pop bc   	; get byte count 
2189			;	pop hl      ; get string to copy 
2189			; 
2189			;	push de     ; save malloc for free later 
2189			; 
2189			;		if DEBUG_FORTH_WORDS 
2189			;			DMARK "EX3" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			;	ldir       ; duplicate string 
2189			; 
2189			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2189			;	 
2189			;	; TODO fix the parse would be better than this...  
2189			;	ex de, hl 
2189			;	dec hl 
2189			;	ld a, 0 
2189			;	ld (hl), a 
2189			;	dec hl 
2189			;	ld a, ' ' 
2189			;	ld (hl), a 
2189			;	dec hl 
2189			;	ld (hl), a 
2189			; 
2189			;	dec hl 
2189			;	ld (hl), a 
2189			; 
2189			; 
2189			;	FORTH_DSP_POP  
2189			; 
2189			;	pop hl     
2189			;	push hl    ; save malloc area 
2189			; 
2189			;		if DEBUG_FORTH_WORDS 
2189			;			DMARK "EX4" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			; 
2189			;	call forthparse 
2189			;	call forthexec 
2189			;	 
2189			;	pop hl 
2189			;	if DEBUG_FORTH_WORDS 
2189			;		DMARK "EX5" 
2189			;		CALLMONITOR 
2189			;	endif 
2189			; 
2189			;	if FORTH_ENABLE_FREE 
2189			;	call free 
2189			;	endif 
2189			; 
2189			;	if DEBUG_FORTH_WORDS 
2189			;		DMARK "EX6" 
2189			;		CALLMONITOR 
2189			;	endif 
2189			; 
2189			;	pop bc 
2189			;	pop de 
2189			;	pop hl 
2189			;;	FORTH_RSP_POP	  
2189			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2189			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2189			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2189			; 
2189			;	if DEBUG_FORTH_WORDS 
2189			;		DMARK "EX7" 
2189			;		CALLMONITOR 
2189			;	endif 
2189			;	NEXTW 
2189			 
2189			;.STKEXEC: 
2189			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2189			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2189			; 
2189			; 
2189			;		if DEBUG_FORTH_WORDS_KEY 
2189			;			DMARK "STX" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			; 
2189			;	FORTH_DSP_VALUEHL 
2189			; 
2189			;	ld (store_tmp1), hl    ; count 
2189			; 
2189			;	FORTH_DSP_POP 
2189			;.stkexec1: 
2189			;	ld hl, (store_tmp1)   ; count 
2189			;	ld a, 0 
2189			;	cp l 
2189			;	ret z 
2189			; 
2189			;	dec hl 
2189			;	ld (store_tmp1), hl    ; count 
2189			;	 
2189			;	FORTH_DSP_VALUEHL 
2189			;	push hl 
2189			;	 
2189			;		if DEBUG_FORTH_WORDS 
2189			;			DMARK "EXp" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			;	FORTH_DSP_POP 
2189			; 
2189			;	call strlenz 
2189			;	inc hl   ; include zero term to copy 
2189			;	inc hl   ; include zero term to copy 
2189			;	inc hl   ; include zero term to copy 
2189			;	ld b,0 
2189			;	ld c,l 
2189			;	pop hl 
2189			;	ld de, execscratch 
2189			;		if DEBUG_FORTH_WORDS 
2189			;			DMARK "EX3" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			;	ldir 
2189			; 
2189			; 
2189			;	ld hl, execscratch 
2189			; 
2189			;		if DEBUG_FORTH_WORDS 
2189			;			DMARK "EXP" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			; 
2189			;	call forthparse 
2189			;	ld hl, execscratch 
2189			;		if DEBUG_FORTH_WORDS 
2189			;			DMARK "EXx" 
2189			;			CALLMONITOR 
2189			;		endif 
2189			;	call forthexec 
2189			; 
2189			;	jp .stkexec1 
2189			; 
2189			;	ret 
2189			 
2189			 
2189			.DUP: 
2189				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2189 17				db WORD_SYS_CORE+OPCODE_DUP             
218a ff 21			dw .ZDUP            
218c 04				db 3 + 1 
218d .. 00			db "DUP",0              
2191				endm 
# End of macro CWHEAD
2191			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2191			 
2191					if DEBUG_FORTH_WORDS_KEY 
2191						DMARK "DUP" 
2191 f5				push af  
2192 3a a6 21			ld a, (.dmark)  
2195 32 6b ee			ld (debug_mark),a  
2198 3a a7 21			ld a, (.dmark+1)  
219b 32 6c ee			ld (debug_mark+1),a  
219e 3a a8 21			ld a, (.dmark+2)  
21a1 32 6d ee			ld (debug_mark+2),a  
21a4 18 03			jr .pastdmark  
21a6 ..			.dmark: db "DUP"  
21a9 f1			.pastdmark: pop af  
21aa			endm  
# End of macro DMARK
21aa						CALLMONITOR 
21aa cd 6f ee			call debug_vector  
21ad				endm  
# End of macro CALLMONITOR
21ad					endif 
21ad			 
21ad					FORTH_DSP 
21ad cd 02 1e			call macro_forth_dsp 
21b0				endm 
# End of macro FORTH_DSP
21b0			 
21b0 7e					ld a, (HL) 
21b1 fe 01				cp DS_TYPE_STR 
21b3 20 25				jr nz, .dupinum 
21b5			 
21b5					; push another string 
21b5			 
21b5					FORTH_DSP_VALUEHL     		 
21b5 cd 3c 1e			call macro_dsp_valuehl 
21b8				endm 
# End of macro FORTH_DSP_VALUEHL
21b8			 
21b8				if DEBUG_FORTH_WORDS 
21b8					DMARK "DUs" 
21b8 f5				push af  
21b9 3a cd 21			ld a, (.dmark)  
21bc 32 6b ee			ld (debug_mark),a  
21bf 3a ce 21			ld a, (.dmark+1)  
21c2 32 6c ee			ld (debug_mark+1),a  
21c5 3a cf 21			ld a, (.dmark+2)  
21c8 32 6d ee			ld (debug_mark+2),a  
21cb 18 03			jr .pastdmark  
21cd ..			.dmark: db "DUs"  
21d0 f1			.pastdmark: pop af  
21d1			endm  
# End of macro DMARK
21d1					CALLMONITOR 
21d1 cd 6f ee			call debug_vector  
21d4				endm  
# End of macro CALLMONITOR
21d4				endif 
21d4 cd b3 1c				call forth_push_str 
21d7			 
21d7					NEXTW 
21d7 c3 f2 1f			jp macro_next 
21da				endm 
# End of macro NEXTW
21da			 
21da			 
21da			.dupinum: 
21da					 
21da			 
21da			 
21da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21da cd 3c 1e			call macro_dsp_valuehl 
21dd				endm 
# End of macro FORTH_DSP_VALUEHL
21dd			 
21dd				; TODO add floating point number detection 
21dd			 
21dd				if DEBUG_FORTH_WORDS 
21dd					DMARK "DUi" 
21dd f5				push af  
21de 3a f2 21			ld a, (.dmark)  
21e1 32 6b ee			ld (debug_mark),a  
21e4 3a f3 21			ld a, (.dmark+1)  
21e7 32 6c ee			ld (debug_mark+1),a  
21ea 3a f4 21			ld a, (.dmark+2)  
21ed 32 6d ee			ld (debug_mark+2),a  
21f0 18 03			jr .pastdmark  
21f2 ..			.dmark: db "DUi"  
21f5 f1			.pastdmark: pop af  
21f6			endm  
# End of macro DMARK
21f6					CALLMONITOR 
21f6 cd 6f ee			call debug_vector  
21f9				endm  
# End of macro CALLMONITOR
21f9				endif 
21f9			 
21f9 cd 45 1c				call forth_push_numhl 
21fc					NEXTW 
21fc c3 f2 1f			jp macro_next 
21ff				endm 
# End of macro NEXTW
21ff			.ZDUP: 
21ff				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
21ff 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2200 37 22			dw .SWAP            
2202 05				db 4 + 1 
2203 .. 00			db "?DUP",0              
2208				endm 
# End of macro CWHEAD
2208			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2208			 
2208					if DEBUG_FORTH_WORDS_KEY 
2208						DMARK "qDU" 
2208 f5				push af  
2209 3a 1d 22			ld a, (.dmark)  
220c 32 6b ee			ld (debug_mark),a  
220f 3a 1e 22			ld a, (.dmark+1)  
2212 32 6c ee			ld (debug_mark+1),a  
2215 3a 1f 22			ld a, (.dmark+2)  
2218 32 6d ee			ld (debug_mark+2),a  
221b 18 03			jr .pastdmark  
221d ..			.dmark: db "qDU"  
2220 f1			.pastdmark: pop af  
2221			endm  
# End of macro DMARK
2221						CALLMONITOR 
2221 cd 6f ee			call debug_vector  
2224				endm  
# End of macro CALLMONITOR
2224					endif 
2224					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2224 cd 3c 1e			call macro_dsp_valuehl 
2227				endm 
# End of macro FORTH_DSP_VALUEHL
2227			 
2227 e5					push hl 
2228			 
2228					; is it a zero? 
2228			 
2228 3e 00				ld a, 0 
222a 84					add h 
222b 85					add l 
222c			 
222c e1					pop hl 
222d			 
222d fe 00				cp 0 
222f 28 03				jr z, .dup2orig 
2231			 
2231			 
2231 cd 45 1c				call forth_push_numhl 
2234			 
2234			 
2234				; TODO add floating point number detection 
2234			 
2234			.dup2orig: 
2234			 
2234					NEXTW 
2234 c3 f2 1f			jp macro_next 
2237				endm 
# End of macro NEXTW
2237			.SWAP: 
2237				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2237 18				db WORD_SYS_CORE+OPCODE_SWAP             
2238 76 22			dw .COLN            
223a 05				db 4 + 1 
223b .. 00			db "SWAP",0              
2240				endm 
# End of macro CWHEAD
2240			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2240					if DEBUG_FORTH_WORDS_KEY 
2240						DMARK "SWP" 
2240 f5				push af  
2241 3a 55 22			ld a, (.dmark)  
2244 32 6b ee			ld (debug_mark),a  
2247 3a 56 22			ld a, (.dmark+1)  
224a 32 6c ee			ld (debug_mark+1),a  
224d 3a 57 22			ld a, (.dmark+2)  
2250 32 6d ee			ld (debug_mark+2),a  
2253 18 03			jr .pastdmark  
2255 ..			.dmark: db "SWP"  
2258 f1			.pastdmark: pop af  
2259			endm  
# End of macro DMARK
2259						CALLMONITOR 
2259 cd 6f ee			call debug_vector  
225c				endm  
# End of macro CALLMONITOR
225c					endif 
225c			 
225c					FORTH_DSP_VALUEHL 
225c cd 3c 1e			call macro_dsp_valuehl 
225f				endm 
# End of macro FORTH_DSP_VALUEHL
225f e5					push hl     ; w2 
2260			 
2260					FORTH_DSP_POP 
2260 cd f4 1e			call macro_forth_dsp_pop 
2263				endm 
# End of macro FORTH_DSP_POP
2263			 
2263					FORTH_DSP_VALUEHL 
2263 cd 3c 1e			call macro_dsp_valuehl 
2266				endm 
# End of macro FORTH_DSP_VALUEHL
2266			 
2266					FORTH_DSP_POP 
2266 cd f4 1e			call macro_forth_dsp_pop 
2269				endm 
# End of macro FORTH_DSP_POP
2269			 
2269 d1					pop de     ; w2	, hl = w1 
226a			 
226a eb					ex de, hl 
226b d5					push de 
226c			 
226c cd 45 1c				call forth_push_numhl 
226f			 
226f e1					pop hl 
2270			 
2270 cd 45 1c				call forth_push_numhl 
2273					 
2273			 
2273					NEXTW 
2273 c3 f2 1f			jp macro_next 
2276				endm 
# End of macro NEXTW
2276			.COLN: 
2276				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2276 19				db WORD_SYS_CORE+OPCODE_COLN             
2277 02 24			dw .SCOLN            
2279 02				db 1 + 1 
227a .. 00			db ":",0              
227c				endm 
# End of macro CWHEAD
227c			; | : ( -- )         Create new word | DONE 
227c			 
227c					if DEBUG_FORTH_WORDS_KEY 
227c						DMARK "CLN" 
227c f5				push af  
227d 3a 91 22			ld a, (.dmark)  
2280 32 6b ee			ld (debug_mark),a  
2283 3a 92 22			ld a, (.dmark+1)  
2286 32 6c ee			ld (debug_mark+1),a  
2289 3a 93 22			ld a, (.dmark+2)  
228c 32 6d ee			ld (debug_mark+2),a  
228f 18 03			jr .pastdmark  
2291 ..			.dmark: db "CLN"  
2294 f1			.pastdmark: pop af  
2295			endm  
# End of macro DMARK
2295						CALLMONITOR 
2295 cd 6f ee			call debug_vector  
2298				endm  
# End of macro CALLMONITOR
2298					endif 
2298				STACKFRAME OFF $8efe $989f 
2298				if DEBUG_STACK_IMB 
2298					if OFF 
2298						exx 
2298						ld de, $8efe 
2298						ld a, d 
2298						ld hl, curframe 
2298						call hexout 
2298						ld a, e 
2298						ld hl, curframe+2 
2298						call hexout 
2298						ld hl, $8efe 
2298						push hl 
2298						ld hl, $989f 
2298						push hl 
2298						exx 
2298					endif 
2298				endif 
2298			endm 
# End of macro STACKFRAME
2298				; get parser buffer length  of new word 
2298			 
2298				 
2298			 
2298					; move tok past this to start of name defintition 
2298					; TODO get word to define 
2298					; TODO Move past word token 
2298					; TODO get length of string up to the ';' 
2298			 
2298 2a c2 e5			ld hl, (os_tok_ptr) 
229b 23				inc hl 
229c 23				inc hl 
229d			 
229d 3e 3b			ld a, ';' 
229f cd 50 12			call strlent 
22a2			 
22a2 7d				ld a,l 
22a3 32 bd e2			ld (os_new_parse_len), a 
22a6			 
22a6			 
22a6			if DEBUG_FORTH_UWORD 
22a6 ed 5b c2 e5		ld de, (os_tok_ptr) 
22aa						DMARK ":01" 
22aa f5				push af  
22ab 3a bf 22			ld a, (.dmark)  
22ae 32 6b ee			ld (debug_mark),a  
22b1 3a c0 22			ld a, (.dmark+1)  
22b4 32 6c ee			ld (debug_mark+1),a  
22b7 3a c1 22			ld a, (.dmark+2)  
22ba 32 6d ee			ld (debug_mark+2),a  
22bd 18 03			jr .pastdmark  
22bf ..			.dmark: db ":01"  
22c2 f1			.pastdmark: pop af  
22c3			endm  
# End of macro DMARK
22c3				CALLMONITOR 
22c3 cd 6f ee			call debug_vector  
22c6				endm  
# End of macro CALLMONITOR
22c6			endif 
22c6			 
22c6			; 
22c6			;  new word memory layout: 
22c6			;  
22c6			;    : adg 6666 ;  
22c6			; 
22c6			;    db   1     ; user defined word  
22c6 23				inc hl    
22c7			;    dw   sysdict 
22c7 23				inc hl 
22c8 23				inc hl 
22c9			;    db <word len>+1 (for null) 
22c9 23				inc hl 
22ca			;    db .... <word> 
22ca			; 
22ca			 
22ca 23				inc hl    ; some extras for the word preamble before the above 
22cb 23				inc hl 
22cc 23				inc hl 
22cd 23				inc hl 
22ce 23				inc hl 
22cf 23				inc hl 
22d0 23				inc hl  
22d1 23				inc hl 
22d2 23				inc hl 
22d3 23				inc hl 
22d4 23				inc hl 
22d5 23				inc hl 
22d6 23				inc hl 
22d7 23				inc hl     ; TODO how many do we really need?     maybe only 6 
22d8			;       exec word buffer 
22d8			;	<ptr word>   
22d8 23				inc hl 
22d9 23				inc hl 
22da			;       <word list><null term> 7F final term 
22da			 
22da			 
22da			if DEBUG_FORTH_UWORD 
22da						DMARK ":02" 
22da f5				push af  
22db 3a ef 22			ld a, (.dmark)  
22de 32 6b ee			ld (debug_mark),a  
22e1 3a f0 22			ld a, (.dmark+1)  
22e4 32 6c ee			ld (debug_mark+1),a  
22e7 3a f1 22			ld a, (.dmark+2)  
22ea 32 6d ee			ld (debug_mark+2),a  
22ed 18 03			jr .pastdmark  
22ef ..			.dmark: db ":02"  
22f2 f1			.pastdmark: pop af  
22f3			endm  
# End of macro DMARK
22f3				CALLMONITOR 
22f3 cd 6f ee			call debug_vector  
22f6				endm  
# End of macro CALLMONITOR
22f6			endif 
22f6			 
22f6				 
22f6					; malloc the size 
22f6			 
22f6 cd ae 12				call malloc 
22f9 22 bf e2				ld (os_new_malloc), hl     ; save malloc start 
22fc			 
22fc			;    db   1     ; user defined word  
22fc 3e 01				ld a, WORD_SYS_UWORD  
22fe 77					ld (hl), a 
22ff				 
22ff 23				inc hl    
2300			;    dw   sysdict 
2300 11 4a 21			ld de, sysdict       ; continue on with the scan to the system dict 
2303 73				ld (hl), e 
2304 23				inc hl 
2305 72				ld (hl), d 
2306 23				inc hl 
2307			 
2307			 
2307			;    Setup dict word 
2307			 
2307 23				inc hl 
2308 22 b9 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
230b			 
230b				; 1. get length of dict word 
230b			 
230b			 
230b 2a c2 e5			ld hl, (os_tok_ptr) 
230e 23				inc hl 
230f 23				inc hl    ; position to start of dict word 
2310 3e 00			ld a, 0 
2312 cd 50 12			call strlent 
2315			 
2315			 
2315 23				inc hl    ; to include null??? 
2316			 
2316				; write length of dict word 
2316			 
2316 ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
231a 1b				dec de 
231b eb				ex de, hl 
231c 73				ld (hl), e 
231d eb				ex de, hl 
231e			 
231e				 
231e			 
231e				; copy  
231e 4d				ld c, l 
231f 06 00			ld b, 0 
2321 ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2325 2a c2 e5			ld hl, (os_tok_ptr) 
2328 23				inc hl 
2329 23				inc hl    ; position to start of dict word 
232a				 
232a			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
232a				 
232a				; TODO need to convert word to upper case 
232a			 
232a			ucasetok:	 
232a 7e				ld a,(hl) 
232b cd 3c 12			call toUpper 
232e 77				ld (hl),a 
232f ed a0			ldi 
2331 f2 2a 23		 	jp p, ucasetok 
2334			 
2334			 
2334			 
2334				; de now points to start of where the word body code should be placed 
2334 ed 53 b9 e2		ld (os_new_work_ptr), de 
2338				; hl now points to the words to throw at forthexec which needs to be copied 
2338 22 b7 e2			ld (os_new_src_ptr), hl 
233b			 
233b				; TODO add 'call to forthexec' 
233b			 
233b			if DEBUG_FORTH_UWORD 
233b c5				push bc 
233c ed 4b bf e2		ld bc, (os_new_malloc) 
2340						DMARK ":0x" 
2340 f5				push af  
2341 3a 55 23			ld a, (.dmark)  
2344 32 6b ee			ld (debug_mark),a  
2347 3a 56 23			ld a, (.dmark+1)  
234a 32 6c ee			ld (debug_mark+1),a  
234d 3a 57 23			ld a, (.dmark+2)  
2350 32 6d ee			ld (debug_mark+2),a  
2353 18 03			jr .pastdmark  
2355 ..			.dmark: db ":0x"  
2358 f1			.pastdmark: pop af  
2359			endm  
# End of macro DMARK
2359				CALLMONITOR 
2359 cd 6f ee			call debug_vector  
235c				endm  
# End of macro CALLMONITOR
235c c1				pop bc 
235d			endif 
235d			 
235d			 
235d				; create word preamble which should be: 
235d			 
235d			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
235d			 
235d				;    ld hl, <word code> 
235d				;    jp user_exec 
235d			        ;    <word code bytes> 
235d			 
235d			 
235d			;	inc de     ; TODO ??? or are we already past the word's null 
235d eb				ex de, hl 
235e			 
235e 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2360			 
2360 23				inc hl 
2361 22 b3 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2364 23				inc hl 
2365			 
2365 23				inc hl 
2366 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2368			 
2368 01 5f 4c			ld bc, user_exec 
236b 23				inc hl 
236c 71				ld (hl), c     ; poke address of user_exec 
236d 23				inc hl 
236e 70				ld (hl), b     
236f			 ; 
236f			;	inc hl 
236f			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
236f			; 
236f			; 
236f			;	ld bc, macro_forth_rsp_next 
236f			;	inc hl 
236f			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
236f			;	inc hl 
236f			;	ld (hl), b     
236f			 ; 
236f			;	inc hl 
236f			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
236f			; 
236f			; 
236f			;	inc hl 
236f			;	ld bc, forthexec 
236f			;	ld (hl), c     ; poke address of forthexec 
236f			;	inc hl 
236f			;	ld (hl), b      
236f			; 
236f			;	inc hl 
236f			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
236f			; 
236f			;	ld bc, user_dict_next 
236f			;	inc hl 
236f			;	ld (hl), c     ; poke address of forthexec 
236f			;	inc hl 
236f			;	ld (hl), b      
236f			 
236f				; hl is now where we need to copy the word byte data to save this 
236f			 
236f 23				inc hl 
2370 22 b5 e2			ld (os_new_exec), hl 
2373				 
2373				; copy definition 
2373			 
2373 eb				ex de, hl 
2374			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2374			;	inc de    ; skip the PC for this parse 
2374 3a bd e2			ld a, (os_new_parse_len) 
2377 4f				ld c, a 
2378 06 00			ld b, 0 
237a ed b0			ldir		 ; copy defintion 
237c			 
237c			 
237c				; poke the address of where the new word bytes live for forthexec 
237c			 
237c 2a b3 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
237f			 
237f ed 5b b5 e2		ld de, (os_new_exec)      
2383				 
2383 73				ld (hl), e 
2384 23				inc hl 
2385 72				ld (hl), d 
2386			 
2386					; TODO copy last user dict word next link to this word 
2386					; TODO update last user dict word to point to this word 
2386			; 
2386			; hl f923 de 812a ; bc 811a 
2386			 
2386			if DEBUG_FORTH_UWORD 
2386 c5				push bc 
2387 ed 4b bf e2		ld bc, (os_new_malloc) 
238b						DMARK ":0A" 
238b f5				push af  
238c 3a a0 23			ld a, (.dmark)  
238f 32 6b ee			ld (debug_mark),a  
2392 3a a1 23			ld a, (.dmark+1)  
2395 32 6c ee			ld (debug_mark+1),a  
2398 3a a2 23			ld a, (.dmark+2)  
239b 32 6d ee			ld (debug_mark+2),a  
239e 18 03			jr .pastdmark  
23a0 ..			.dmark: db ":0A"  
23a3 f1			.pastdmark: pop af  
23a4			endm  
# End of macro DMARK
23a4				CALLMONITOR 
23a4 cd 6f ee			call debug_vector  
23a7				endm  
# End of macro CALLMONITOR
23a7 c1				pop bc 
23a8			endif 
23a8			if DEBUG_FORTH_UWORD 
23a8 c5				push bc 
23a9 ed 4b bf e2		ld bc, (os_new_malloc) 
23ad 03				inc bc 
23ae 03				inc bc 
23af 03				inc bc 
23b0 03				inc bc 
23b1 03				inc bc 
23b2 03				inc bc 
23b3 03				inc bc 
23b4 03				inc bc 
23b5			 
23b5						DMARK ":0B" 
23b5 f5				push af  
23b6 3a ca 23			ld a, (.dmark)  
23b9 32 6b ee			ld (debug_mark),a  
23bc 3a cb 23			ld a, (.dmark+1)  
23bf 32 6c ee			ld (debug_mark+1),a  
23c2 3a cc 23			ld a, (.dmark+2)  
23c5 32 6d ee			ld (debug_mark+2),a  
23c8 18 03			jr .pastdmark  
23ca ..			.dmark: db ":0B"  
23cd f1			.pastdmark: pop af  
23ce			endm  
# End of macro DMARK
23ce				CALLMONITOR 
23ce cd 6f ee			call debug_vector  
23d1				endm  
# End of macro CALLMONITOR
23d1 c1				pop bc 
23d2			endif 
23d2			 
23d2			; update word dict linked list for new word 
23d2			 
23d2			 
23d2 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23d5 23			inc hl     ; move to next work linked list ptr 
23d6			 
23d6 ed 5b bf e2	ld de, (os_new_malloc)		 ; new next word 
23da 73			ld (hl), e 
23db 23			inc hl 
23dc 72			ld (hl), d 
23dd			 
23dd			if DEBUG_FORTH_UWORD 
23dd ed 4b be e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23e1			endif 
23e1			 
23e1 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23e5			 
23e5			 
23e5			if DEBUG_FORTH_UWORD 
23e5						DMARK ":0+" 
23e5 f5				push af  
23e6 3a fa 23			ld a, (.dmark)  
23e9 32 6b ee			ld (debug_mark),a  
23ec 3a fb 23			ld a, (.dmark+1)  
23ef 32 6c ee			ld (debug_mark+1),a  
23f2 3a fc 23			ld a, (.dmark+2)  
23f5 32 6d ee			ld (debug_mark+2),a  
23f8 18 03			jr .pastdmark  
23fa ..			.dmark: db ":0+"  
23fd f1			.pastdmark: pop af  
23fe			endm  
# End of macro DMARK
23fe				CALLMONITOR 
23fe cd 6f ee			call debug_vector  
2401				endm  
# End of macro CALLMONITOR
2401			endif 
2401			 
2401				STACKFRAMECHK OFF $8efe $989f 
2401				if DEBUG_STACK_IMB 
2401					if OFF 
2401						exx 
2401						ld hl, $989f 
2401						pop de   ; $989f 
2401						call cmp16 
2401						jr nz, .spnosame 
2401						ld hl, $8efe 
2401						pop de   ; $8efe 
2401						call cmp16 
2401						jr z, .spfrsame 
2401						.spnosame: call showsperror 
2401						.spfrsame: nop 
2401						exx 
2401					endif 
2401				endif 
2401			endm 
# End of macro STACKFRAMECHK
2401			 
2401 c9			ret    ; dont process any remaining parser tokens as they form new word 
2402			 
2402			 
2402			 
2402			 
2402			;		NEXT 
2402			.SCOLN: 
2402			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2402 06				db OPCODE_SCOLN 
2403 4e 24			dw .DROP 
2405 02				db 2 
2406 .. 00			db ";",0           
2408			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2408					if DEBUG_FORTH_WORDS_KEY 
2408						DMARK "SCN" 
2408 f5				push af  
2409 3a 1d 24			ld a, (.dmark)  
240c 32 6b ee			ld (debug_mark),a  
240f 3a 1e 24			ld a, (.dmark+1)  
2412 32 6c ee			ld (debug_mark+1),a  
2415 3a 1f 24			ld a, (.dmark+2)  
2418 32 6d ee			ld (debug_mark+2),a  
241b 18 03			jr .pastdmark  
241d ..			.dmark: db "SCN"  
2420 f1			.pastdmark: pop af  
2421			endm  
# End of macro DMARK
2421						CALLMONITOR 
2421 cd 6f ee			call debug_vector  
2424				endm  
# End of macro CALLMONITOR
2424					endif 
2424					FORTH_RSP_TOS 
2424 cd 03 1c			call macro_forth_rsp_tos 
2427				endm 
# End of macro FORTH_RSP_TOS
2427 e5					push hl 
2428					FORTH_RSP_POP 
2428 cd 0d 1c			call macro_forth_rsp_pop 
242b				endm 
# End of macro FORTH_RSP_POP
242b e1					pop hl 
242c			;		ex de,hl 
242c 22 c2 e5				ld (os_tok_ptr),hl 
242f			 
242f			if DEBUG_FORTH_UWORD 
242f						DMARK "SCL" 
242f f5				push af  
2430 3a 44 24			ld a, (.dmark)  
2433 32 6b ee			ld (debug_mark),a  
2436 3a 45 24			ld a, (.dmark+1)  
2439 32 6c ee			ld (debug_mark+1),a  
243c 3a 46 24			ld a, (.dmark+2)  
243f 32 6d ee			ld (debug_mark+2),a  
2442 18 03			jr .pastdmark  
2444 ..			.dmark: db "SCL"  
2447 f1			.pastdmark: pop af  
2448			endm  
# End of macro DMARK
2448				CALLMONITOR 
2448 cd 6f ee			call debug_vector  
244b				endm  
# End of macro CALLMONITOR
244b			endif 
244b					NEXTW 
244b c3 f2 1f			jp macro_next 
244e				endm 
# End of macro NEXTW
244e			 
244e			.DROP: 
244e				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
244e 1b				db WORD_SYS_CORE+OPCODE_DROP             
244f 79 24			dw .DUP2            
2451 05				db 4 + 1 
2452 .. 00			db "DROP",0              
2457				endm 
# End of macro CWHEAD
2457			; | DROP ( w -- )   drop the TOS item   | DONE 
2457					if DEBUG_FORTH_WORDS_KEY 
2457						DMARK "DRP" 
2457 f5				push af  
2458 3a 6c 24			ld a, (.dmark)  
245b 32 6b ee			ld (debug_mark),a  
245e 3a 6d 24			ld a, (.dmark+1)  
2461 32 6c ee			ld (debug_mark+1),a  
2464 3a 6e 24			ld a, (.dmark+2)  
2467 32 6d ee			ld (debug_mark+2),a  
246a 18 03			jr .pastdmark  
246c ..			.dmark: db "DRP"  
246f f1			.pastdmark: pop af  
2470			endm  
# End of macro DMARK
2470						CALLMONITOR 
2470 cd 6f ee			call debug_vector  
2473				endm  
# End of macro CALLMONITOR
2473					endif 
2473					FORTH_DSP_POP 
2473 cd f4 1e			call macro_forth_dsp_pop 
2476				endm 
# End of macro FORTH_DSP_POP
2476					NEXTW 
2476 c3 f2 1f			jp macro_next 
2479				endm 
# End of macro NEXTW
2479			.DUP2: 
2479				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2479 1c				db WORD_SYS_CORE+OPCODE_DUP2             
247a be 24			dw .DROP2            
247c 05				db 4 + 1 
247d .. 00			db "2DUP",0              
2482				endm 
# End of macro CWHEAD
2482			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2482					if DEBUG_FORTH_WORDS_KEY 
2482						DMARK "2DU" 
2482 f5				push af  
2483 3a 97 24			ld a, (.dmark)  
2486 32 6b ee			ld (debug_mark),a  
2489 3a 98 24			ld a, (.dmark+1)  
248c 32 6c ee			ld (debug_mark+1),a  
248f 3a 99 24			ld a, (.dmark+2)  
2492 32 6d ee			ld (debug_mark+2),a  
2495 18 03			jr .pastdmark  
2497 ..			.dmark: db "2DU"  
249a f1			.pastdmark: pop af  
249b			endm  
# End of macro DMARK
249b						CALLMONITOR 
249b cd 6f ee			call debug_vector  
249e				endm  
# End of macro CALLMONITOR
249e					endif 
249e					FORTH_DSP_VALUEHL 
249e cd 3c 1e			call macro_dsp_valuehl 
24a1				endm 
# End of macro FORTH_DSP_VALUEHL
24a1 e5					push hl      ; 2 
24a2			 
24a2					FORTH_DSP_POP 
24a2 cd f4 1e			call macro_forth_dsp_pop 
24a5				endm 
# End of macro FORTH_DSP_POP
24a5					 
24a5					FORTH_DSP_VALUEHL 
24a5 cd 3c 1e			call macro_dsp_valuehl 
24a8				endm 
# End of macro FORTH_DSP_VALUEHL
24a8			;		push hl      ; 1 
24a8			 
24a8					FORTH_DSP_POP 
24a8 cd f4 1e			call macro_forth_dsp_pop 
24ab				endm 
# End of macro FORTH_DSP_POP
24ab			 
24ab			;		pop hl       ; 1 
24ab d1					pop de       ; 2 
24ac			 
24ac cd 45 1c				call forth_push_numhl 
24af eb					ex de, hl 
24b0 cd 45 1c				call forth_push_numhl 
24b3			 
24b3					 
24b3 eb					ex de, hl 
24b4			 
24b4 cd 45 1c				call forth_push_numhl 
24b7 eb					ex de, hl 
24b8 cd 45 1c				call forth_push_numhl 
24bb			 
24bb			 
24bb					NEXTW 
24bb c3 f2 1f			jp macro_next 
24be				endm 
# End of macro NEXTW
24be			.DROP2: 
24be				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24be 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24bf ed 24			dw .SWAP2            
24c1 06				db 5 + 1 
24c2 .. 00			db "2DROP",0              
24c8				endm 
# End of macro CWHEAD
24c8			; | 2DROP ( w w -- )    Double drop | DONE 
24c8					if DEBUG_FORTH_WORDS_KEY 
24c8						DMARK "2DR" 
24c8 f5				push af  
24c9 3a dd 24			ld a, (.dmark)  
24cc 32 6b ee			ld (debug_mark),a  
24cf 3a de 24			ld a, (.dmark+1)  
24d2 32 6c ee			ld (debug_mark+1),a  
24d5 3a df 24			ld a, (.dmark+2)  
24d8 32 6d ee			ld (debug_mark+2),a  
24db 18 03			jr .pastdmark  
24dd ..			.dmark: db "2DR"  
24e0 f1			.pastdmark: pop af  
24e1			endm  
# End of macro DMARK
24e1						CALLMONITOR 
24e1 cd 6f ee			call debug_vector  
24e4				endm  
# End of macro CALLMONITOR
24e4					endif 
24e4					FORTH_DSP_POP 
24e4 cd f4 1e			call macro_forth_dsp_pop 
24e7				endm 
# End of macro FORTH_DSP_POP
24e7					FORTH_DSP_POP 
24e7 cd f4 1e			call macro_forth_dsp_pop 
24ea				endm 
# End of macro FORTH_DSP_POP
24ea					NEXTW 
24ea c3 f2 1f			jp macro_next 
24ed				endm 
# End of macro NEXTW
24ed			.SWAP2: 
24ed				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
24ed 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
24ee 16 25			dw .AT            
24f0 06				db 5 + 1 
24f1 .. 00			db "2SWAP",0              
24f7				endm 
# End of macro CWHEAD
24f7			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
24f7					if DEBUG_FORTH_WORDS_KEY 
24f7						DMARK "2SW" 
24f7 f5				push af  
24f8 3a 0c 25			ld a, (.dmark)  
24fb 32 6b ee			ld (debug_mark),a  
24fe 3a 0d 25			ld a, (.dmark+1)  
2501 32 6c ee			ld (debug_mark+1),a  
2504 3a 0e 25			ld a, (.dmark+2)  
2507 32 6d ee			ld (debug_mark+2),a  
250a 18 03			jr .pastdmark  
250c ..			.dmark: db "2SW"  
250f f1			.pastdmark: pop af  
2510			endm  
# End of macro DMARK
2510						CALLMONITOR 
2510 cd 6f ee			call debug_vector  
2513				endm  
# End of macro CALLMONITOR
2513					endif 
2513					NEXTW 
2513 c3 f2 1f			jp macro_next 
2516				endm 
# End of macro NEXTW
2516			.AT: 
2516				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2516 1f				db WORD_SYS_CORE+OPCODE_AT             
2517 48 25			dw .CAT            
2519 02				db 1 + 1 
251a .. 00			db "@",0              
251c				endm 
# End of macro CWHEAD
251c			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
251c			 
251c					if DEBUG_FORTH_WORDS_KEY 
251c						DMARK "AT." 
251c f5				push af  
251d 3a 31 25			ld a, (.dmark)  
2520 32 6b ee			ld (debug_mark),a  
2523 3a 32 25			ld a, (.dmark+1)  
2526 32 6c ee			ld (debug_mark+1),a  
2529 3a 33 25			ld a, (.dmark+2)  
252c 32 6d ee			ld (debug_mark+2),a  
252f 18 03			jr .pastdmark  
2531 ..			.dmark: db "AT."  
2534 f1			.pastdmark: pop af  
2535			endm  
# End of macro DMARK
2535						CALLMONITOR 
2535 cd 6f ee			call debug_vector  
2538				endm  
# End of macro CALLMONITOR
2538					endif 
2538			.getbyteat:	 
2538					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2538 cd 3c 1e			call macro_dsp_valuehl 
253b				endm 
# End of macro FORTH_DSP_VALUEHL
253b					 
253b			;		push hl 
253b				 
253b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
253b cd f4 1e			call macro_forth_dsp_pop 
253e				endm 
# End of macro FORTH_DSP_POP
253e			 
253e			;		pop hl 
253e			 
253e 7e					ld a, (hl) 
253f			 
253f 6f					ld l, a 
2540 26 00				ld h, 0 
2542 cd 45 1c				call forth_push_numhl 
2545			 
2545					NEXTW 
2545 c3 f2 1f			jp macro_next 
2548				endm 
# End of macro NEXTW
2548			.CAT: 
2548				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2548 20				db WORD_SYS_CORE+OPCODE_CAT             
2549 71 25			dw .BANG            
254b 03				db 2 + 1 
254c .. 00			db "C@",0              
254f				endm 
# End of macro CWHEAD
254f			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
254f					if DEBUG_FORTH_WORDS_KEY 
254f						DMARK "CAA" 
254f f5				push af  
2550 3a 64 25			ld a, (.dmark)  
2553 32 6b ee			ld (debug_mark),a  
2556 3a 65 25			ld a, (.dmark+1)  
2559 32 6c ee			ld (debug_mark+1),a  
255c 3a 66 25			ld a, (.dmark+2)  
255f 32 6d ee			ld (debug_mark+2),a  
2562 18 03			jr .pastdmark  
2564 ..			.dmark: db "CAA"  
2567 f1			.pastdmark: pop af  
2568			endm  
# End of macro DMARK
2568						CALLMONITOR 
2568 cd 6f ee			call debug_vector  
256b				endm  
# End of macro CALLMONITOR
256b					endif 
256b c3 38 25				jp .getbyteat 
256e					NEXTW 
256e c3 f2 1f			jp macro_next 
2571				endm 
# End of macro NEXTW
2571			.BANG: 
2571				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2571 21				db WORD_SYS_CORE+OPCODE_BANG             
2572 a7 25			dw .CBANG            
2574 02				db 1 + 1 
2575 .. 00			db "!",0              
2577				endm 
# End of macro CWHEAD
2577			; | ! ( x w -- ) Store x at address w      | DONE 
2577					if DEBUG_FORTH_WORDS_KEY 
2577						DMARK "BNG" 
2577 f5				push af  
2578 3a 8c 25			ld a, (.dmark)  
257b 32 6b ee			ld (debug_mark),a  
257e 3a 8d 25			ld a, (.dmark+1)  
2581 32 6c ee			ld (debug_mark+1),a  
2584 3a 8e 25			ld a, (.dmark+2)  
2587 32 6d ee			ld (debug_mark+2),a  
258a 18 03			jr .pastdmark  
258c ..			.dmark: db "BNG"  
258f f1			.pastdmark: pop af  
2590			endm  
# End of macro DMARK
2590						CALLMONITOR 
2590 cd 6f ee			call debug_vector  
2593				endm  
# End of macro CALLMONITOR
2593					endif 
2593			 
2593			.storebyteat:		 
2593					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2593 cd 3c 1e			call macro_dsp_valuehl 
2596				endm 
# End of macro FORTH_DSP_VALUEHL
2596					 
2596 e5					push hl 
2597				 
2597					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2597 cd f4 1e			call macro_forth_dsp_pop 
259a				endm 
# End of macro FORTH_DSP_POP
259a			 
259a					; get byte to poke 
259a			 
259a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
259a cd 3c 1e			call macro_dsp_valuehl 
259d				endm 
# End of macro FORTH_DSP_VALUEHL
259d e5					push hl 
259e			 
259e			 
259e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
259e cd f4 1e			call macro_forth_dsp_pop 
25a1				endm 
# End of macro FORTH_DSP_POP
25a1			 
25a1			 
25a1 d1					pop de 
25a2 e1					pop hl 
25a3			 
25a3 73					ld (hl),e 
25a4			 
25a4			 
25a4					NEXTW 
25a4 c3 f2 1f			jp macro_next 
25a7				endm 
# End of macro NEXTW
25a7			.CBANG: 
25a7				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25a7 22				db WORD_SYS_CORE+OPCODE_CBANG             
25a8 d0 25			dw .SCALL            
25aa 03				db 2 + 1 
25ab .. 00			db "C!",0              
25ae				endm 
# End of macro CWHEAD
25ae			; | C!  ( x w -- ) Store x at address w  | DONE 
25ae					if DEBUG_FORTH_WORDS_KEY 
25ae						DMARK "CBA" 
25ae f5				push af  
25af 3a c3 25			ld a, (.dmark)  
25b2 32 6b ee			ld (debug_mark),a  
25b5 3a c4 25			ld a, (.dmark+1)  
25b8 32 6c ee			ld (debug_mark+1),a  
25bb 3a c5 25			ld a, (.dmark+2)  
25be 32 6d ee			ld (debug_mark+2),a  
25c1 18 03			jr .pastdmark  
25c3 ..			.dmark: db "CBA"  
25c6 f1			.pastdmark: pop af  
25c7			endm  
# End of macro DMARK
25c7						CALLMONITOR 
25c7 cd 6f ee			call debug_vector  
25ca				endm  
# End of macro CALLMONITOR
25ca					endif 
25ca c3 93 25				jp .storebyteat 
25cd					NEXTW 
25cd c3 f2 1f			jp macro_next 
25d0				endm 
# End of macro NEXTW
25d0			.SCALL: 
25d0				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25d0 23				db WORD_SYS_CORE+OPCODE_SCALL             
25d1 04 26			dw .DEPTH            
25d3 05				db 4 + 1 
25d4 .. 00			db "CALL",0              
25d9				endm 
# End of macro CWHEAD
25d9			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25d9					if DEBUG_FORTH_WORDS_KEY 
25d9						DMARK "CLL" 
25d9 f5				push af  
25da 3a ee 25			ld a, (.dmark)  
25dd 32 6b ee			ld (debug_mark),a  
25e0 3a ef 25			ld a, (.dmark+1)  
25e3 32 6c ee			ld (debug_mark+1),a  
25e6 3a f0 25			ld a, (.dmark+2)  
25e9 32 6d ee			ld (debug_mark+2),a  
25ec 18 03			jr .pastdmark  
25ee ..			.dmark: db "CLL"  
25f1 f1			.pastdmark: pop af  
25f2			endm  
# End of macro DMARK
25f2						CALLMONITOR 
25f2 cd 6f ee			call debug_vector  
25f5				endm  
# End of macro CALLMONITOR
25f5					endif 
25f5			 
25f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25f5 cd 3c 1e			call macro_dsp_valuehl 
25f8				endm 
# End of macro FORTH_DSP_VALUEHL
25f8			 
25f8			;		push hl 
25f8			 
25f8					; destroy value TOS 
25f8			 
25f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25f8 cd f4 1e			call macro_forth_dsp_pop 
25fb				endm 
# End of macro FORTH_DSP_POP
25fb			 
25fb						 
25fb			;		pop hl 
25fb			 
25fb					; how to do a call with hl???? save SP? 
25fb cd 96 1f				call forth_call_hl 
25fe			 
25fe			 
25fe					; TODO push value back onto stack for another op etc 
25fe			 
25fe cd 45 1c				call forth_push_numhl 
2601					NEXTW 
2601 c3 f2 1f			jp macro_next 
2604				endm 
# End of macro NEXTW
2604			.DEPTH: 
2604				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2604 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2605 41 26			dw .OVER            
2607 06				db 5 + 1 
2608 .. 00			db "DEPTH",0              
260e				endm 
# End of macro CWHEAD
260e			; | DEPTH ( -- u ) Push count of stack | DONE 
260e					; take current TOS and remove from base value div by two to get count 
260e					if DEBUG_FORTH_WORDS_KEY 
260e						DMARK "DEP" 
260e f5				push af  
260f 3a 23 26			ld a, (.dmark)  
2612 32 6b ee			ld (debug_mark),a  
2615 3a 24 26			ld a, (.dmark+1)  
2618 32 6c ee			ld (debug_mark+1),a  
261b 3a 25 26			ld a, (.dmark+2)  
261e 32 6d ee			ld (debug_mark+2),a  
2621 18 03			jr .pastdmark  
2623 ..			.dmark: db "DEP"  
2626 f1			.pastdmark: pop af  
2627			endm  
# End of macro DMARK
2627						CALLMONITOR 
2627 cd 6f ee			call debug_vector  
262a				endm  
# End of macro CALLMONITOR
262a					endif 
262a			 
262a			 
262a 2a ee e9			ld hl, (cli_data_sp) 
262d 11 28 e8			ld de, cli_data_stack 
2630 ed 52			sbc hl,de 
2632				 
2632				; div by size of stack item 
2632			 
2632 5d				ld e,l 
2633 0e 03			ld c, 3 
2635 cd 77 0d			call Div8 
2638			 
2638 6f				ld l,a 
2639 26 00			ld h,0 
263b			 
263b				;srl h 
263b				;rr l 
263b			 
263b cd 45 1c				call forth_push_numhl 
263e					NEXTW 
263e c3 f2 1f			jp macro_next 
2641				endm 
# End of macro NEXTW
2641			.OVER: 
2641				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2641 42				db WORD_SYS_CORE+46             
2642 88 26			dw .PAUSE            
2644 05				db 4 + 1 
2645 .. 00			db "OVER",0              
264a				endm 
# End of macro CWHEAD
264a			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
264a					if DEBUG_FORTH_WORDS_KEY 
264a						DMARK "OVR" 
264a f5				push af  
264b 3a 5f 26			ld a, (.dmark)  
264e 32 6b ee			ld (debug_mark),a  
2651 3a 60 26			ld a, (.dmark+1)  
2654 32 6c ee			ld (debug_mark+1),a  
2657 3a 61 26			ld a, (.dmark+2)  
265a 32 6d ee			ld (debug_mark+2),a  
265d 18 03			jr .pastdmark  
265f ..			.dmark: db "OVR"  
2662 f1			.pastdmark: pop af  
2663			endm  
# End of macro DMARK
2663						CALLMONITOR 
2663 cd 6f ee			call debug_vector  
2666				endm  
# End of macro CALLMONITOR
2666					endif 
2666			 
2666					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2666 cd 3c 1e			call macro_dsp_valuehl 
2669				endm 
# End of macro FORTH_DSP_VALUEHL
2669 e5					push hl    ; n2 
266a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
266a cd f4 1e			call macro_forth_dsp_pop 
266d				endm 
# End of macro FORTH_DSP_POP
266d			 
266d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
266d cd 3c 1e			call macro_dsp_valuehl 
2670				endm 
# End of macro FORTH_DSP_VALUEHL
2670 e5					push hl    ; n1 
2671					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2671 cd f4 1e			call macro_forth_dsp_pop 
2674				endm 
# End of macro FORTH_DSP_POP
2674			 
2674 d1					pop de     ; n1 
2675 e1					pop hl     ; n2 
2676			 
2676 d5					push de 
2677 e5					push hl 
2678 d5					push de 
2679			 
2679					; push back  
2679			 
2679 e1					pop hl 
267a cd 45 1c				call forth_push_numhl 
267d e1					pop hl 
267e cd 45 1c				call forth_push_numhl 
2681 e1					pop hl 
2682 cd 45 1c				call forth_push_numhl 
2685					NEXTW 
2685 c3 f2 1f			jp macro_next 
2688				endm 
# End of macro NEXTW
2688			 
2688			.PAUSE: 
2688				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2688 43				db WORD_SYS_CORE+47             
2689 bd 26			dw .PAUSES            
268b 08				db 7 + 1 
268c .. 00			db "PAUSEMS",0              
2694				endm 
# End of macro CWHEAD
2694			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2694					if DEBUG_FORTH_WORDS_KEY 
2694						DMARK "PMS" 
2694 f5				push af  
2695 3a a9 26			ld a, (.dmark)  
2698 32 6b ee			ld (debug_mark),a  
269b 3a aa 26			ld a, (.dmark+1)  
269e 32 6c ee			ld (debug_mark+1),a  
26a1 3a ab 26			ld a, (.dmark+2)  
26a4 32 6d ee			ld (debug_mark+2),a  
26a7 18 03			jr .pastdmark  
26a9 ..			.dmark: db "PMS"  
26ac f1			.pastdmark: pop af  
26ad			endm  
# End of macro DMARK
26ad						CALLMONITOR 
26ad cd 6f ee			call debug_vector  
26b0				endm  
# End of macro CALLMONITOR
26b0					endif 
26b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b0 cd 3c 1e			call macro_dsp_valuehl 
26b3				endm 
# End of macro FORTH_DSP_VALUEHL
26b3			;		push hl    ; n2 
26b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26b3 cd f4 1e			call macro_forth_dsp_pop 
26b6				endm 
# End of macro FORTH_DSP_POP
26b6			;		pop hl 
26b6			 
26b6 7d					ld a, l 
26b7 cd d7 0a				call aDelayInMS 
26ba				       NEXTW 
26ba c3 f2 1f			jp macro_next 
26bd				endm 
# End of macro NEXTW
26bd			.PAUSES:  
26bd				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26bd 44				db WORD_SYS_CORE+48             
26be 2c 27			dw .ROT            
26c0 06				db 5 + 1 
26c1 .. 00			db "PAUSE",0              
26c7				endm 
# End of macro CWHEAD
26c7			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26c7					if DEBUG_FORTH_WORDS_KEY 
26c7						DMARK "PAU" 
26c7 f5				push af  
26c8 3a dc 26			ld a, (.dmark)  
26cb 32 6b ee			ld (debug_mark),a  
26ce 3a dd 26			ld a, (.dmark+1)  
26d1 32 6c ee			ld (debug_mark+1),a  
26d4 3a de 26			ld a, (.dmark+2)  
26d7 32 6d ee			ld (debug_mark+2),a  
26da 18 03			jr .pastdmark  
26dc ..			.dmark: db "PAU"  
26df f1			.pastdmark: pop af  
26e0			endm  
# End of macro DMARK
26e0						CALLMONITOR 
26e0 cd 6f ee			call debug_vector  
26e3				endm  
# End of macro CALLMONITOR
26e3					endif 
26e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e3 cd 3c 1e			call macro_dsp_valuehl 
26e6				endm 
# End of macro FORTH_DSP_VALUEHL
26e6			;		push hl    ; n2 
26e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26e6 cd f4 1e			call macro_forth_dsp_pop 
26e9				endm 
# End of macro FORTH_DSP_POP
26e9			;		pop hl 
26e9 45					ld b, l 
26ea					if DEBUG_FORTH_WORDS 
26ea						DMARK "PAU" 
26ea f5				push af  
26eb 3a ff 26			ld a, (.dmark)  
26ee 32 6b ee			ld (debug_mark),a  
26f1 3a 00 27			ld a, (.dmark+1)  
26f4 32 6c ee			ld (debug_mark+1),a  
26f7 3a 01 27			ld a, (.dmark+2)  
26fa 32 6d ee			ld (debug_mark+2),a  
26fd 18 03			jr .pastdmark  
26ff ..			.dmark: db "PAU"  
2702 f1			.pastdmark: pop af  
2703			endm  
# End of macro DMARK
2703						CALLMONITOR 
2703 cd 6f ee			call debug_vector  
2706				endm  
# End of macro CALLMONITOR
2706					endif 
2706 c5			.pauses1:	push bc 
2707 cd f2 0a				call delay1s 
270a c1					pop bc 
270b					if DEBUG_FORTH_WORDS 
270b						DMARK "PA1" 
270b f5				push af  
270c 3a 20 27			ld a, (.dmark)  
270f 32 6b ee			ld (debug_mark),a  
2712 3a 21 27			ld a, (.dmark+1)  
2715 32 6c ee			ld (debug_mark+1),a  
2718 3a 22 27			ld a, (.dmark+2)  
271b 32 6d ee			ld (debug_mark+2),a  
271e 18 03			jr .pastdmark  
2720 ..			.dmark: db "PA1"  
2723 f1			.pastdmark: pop af  
2724			endm  
# End of macro DMARK
2724						CALLMONITOR 
2724 cd 6f ee			call debug_vector  
2727				endm  
# End of macro CALLMONITOR
2727					endif 
2727 10 dd				djnz .pauses1 
2729			 
2729				       NEXTW 
2729 c3 f2 1f			jp macro_next 
272c				endm 
# End of macro NEXTW
272c			.ROT: 
272c				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
272c 45				db WORD_SYS_CORE+49             
272d 7a 27			dw .UWORDS            
272f 04				db 3 + 1 
2730 .. 00			db "ROT",0              
2734				endm 
# End of macro CWHEAD
2734			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2734					if DEBUG_FORTH_WORDS_KEY 
2734						DMARK "ROT" 
2734 f5				push af  
2735 3a 49 27			ld a, (.dmark)  
2738 32 6b ee			ld (debug_mark),a  
273b 3a 4a 27			ld a, (.dmark+1)  
273e 32 6c ee			ld (debug_mark+1),a  
2741 3a 4b 27			ld a, (.dmark+2)  
2744 32 6d ee			ld (debug_mark+2),a  
2747 18 03			jr .pastdmark  
2749 ..			.dmark: db "ROT"  
274c f1			.pastdmark: pop af  
274d			endm  
# End of macro DMARK
274d						CALLMONITOR 
274d cd 6f ee			call debug_vector  
2750				endm  
# End of macro CALLMONITOR
2750					endif 
2750			 
2750					FORTH_DSP_VALUEHL 
2750 cd 3c 1e			call macro_dsp_valuehl 
2753				endm 
# End of macro FORTH_DSP_VALUEHL
2753 e5					push hl    ; u3  
2754			 
2754					FORTH_DSP_POP 
2754 cd f4 1e			call macro_forth_dsp_pop 
2757				endm 
# End of macro FORTH_DSP_POP
2757			   
2757					FORTH_DSP_VALUEHL 
2757 cd 3c 1e			call macro_dsp_valuehl 
275a				endm 
# End of macro FORTH_DSP_VALUEHL
275a e5					push hl     ; u2 
275b			 
275b					FORTH_DSP_POP 
275b cd f4 1e			call macro_forth_dsp_pop 
275e				endm 
# End of macro FORTH_DSP_POP
275e			 
275e					FORTH_DSP_VALUEHL 
275e cd 3c 1e			call macro_dsp_valuehl 
2761				endm 
# End of macro FORTH_DSP_VALUEHL
2761 e5					push hl     ; u1 
2762			 
2762					FORTH_DSP_POP 
2762 cd f4 1e			call macro_forth_dsp_pop 
2765				endm 
# End of macro FORTH_DSP_POP
2765			 
2765 c1					pop bc      ; u1 
2766 e1					pop hl      ; u2 
2767 d1					pop de      ; u3 
2768			 
2768			 
2768 c5					push bc 
2769 d5					push de 
276a e5					push hl 
276b			 
276b			 
276b e1					pop hl 
276c cd 45 1c				call forth_push_numhl 
276f			 
276f e1					pop hl 
2770 cd 45 1c				call forth_push_numhl 
2773			 
2773 e1					pop hl 
2774 cd 45 1c				call forth_push_numhl 
2777					 
2777			 
2777			 
2777			 
2777			 
2777			 
2777				       NEXTW 
2777 c3 f2 1f			jp macro_next 
277a				endm 
# End of macro NEXTW
277a			 
277a			.UWORDS: 
277a				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
277a 50				db WORD_SYS_CORE+60             
277b 3c 28			dw .BP            
277d 07				db 6 + 1 
277e .. 00			db "UWORDS",0              
2785				endm 
# End of macro CWHEAD
2785			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2785			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2785			; | | Following the count are the individual words. 
2785			; | | 
2785			; | | e.g. UWORDS 
2785			; | | BOX DIRLIST 2 
2785			; | |  
2785			; | | Can be used to save the words to storage via: 
2785			; | | UWORDS $01 DO $01 APPEND LOOP 
2785				if DEBUG_FORTH_WORDS_KEY 
2785					DMARK "UWR" 
2785 f5				push af  
2786 3a 9a 27			ld a, (.dmark)  
2789 32 6b ee			ld (debug_mark),a  
278c 3a 9b 27			ld a, (.dmark+1)  
278f 32 6c ee			ld (debug_mark+1),a  
2792 3a 9c 27			ld a, (.dmark+2)  
2795 32 6d ee			ld (debug_mark+2),a  
2798 18 03			jr .pastdmark  
279a ..			.dmark: db "UWR"  
279d f1			.pastdmark: pop af  
279e			endm  
# End of macro DMARK
279e					CALLMONITOR 
279e cd 6f ee			call debug_vector  
27a1				endm  
# End of macro CALLMONITOR
27a1				endif 
27a1 21 8f 65				ld hl, baseram 
27a4					;ld hl, baseusermem 
27a4 01 00 00				ld bc, 0    ; start a counter 
27a7			 
27a7				; skip dict stub 
27a7			 
27a7 cd 43 21				call forth_tok_next 
27aa			 
27aa			 
27aa			; while we have words to look for 
27aa			 
27aa 7e			.douscan:	ld a, (hl)      
27ab				if DEBUG_FORTH_WORDS 
27ab					DMARK "UWs" 
27ab f5				push af  
27ac 3a c0 27			ld a, (.dmark)  
27af 32 6b ee			ld (debug_mark),a  
27b2 3a c1 27			ld a, (.dmark+1)  
27b5 32 6c ee			ld (debug_mark+1),a  
27b8 3a c2 27			ld a, (.dmark+2)  
27bb 32 6d ee			ld (debug_mark+2),a  
27be 18 03			jr .pastdmark  
27c0 ..			.dmark: db "UWs"  
27c3 f1			.pastdmark: pop af  
27c4			endm  
# End of macro DMARK
27c4					CALLMONITOR 
27c4 cd 6f ee			call debug_vector  
27c7				endm  
# End of macro CALLMONITOR
27c7				endif 
27c7 fe 00				cp WORD_SYS_END 
27c9 28 4d				jr z, .udone 
27cb fe 01				cp WORD_SYS_UWORD 
27cd 20 44				jr nz, .nuword 
27cf			 
27cf				if DEBUG_FORTH_WORDS 
27cf					DMARK "UWu" 
27cf f5				push af  
27d0 3a e4 27			ld a, (.dmark)  
27d3 32 6b ee			ld (debug_mark),a  
27d6 3a e5 27			ld a, (.dmark+1)  
27d9 32 6c ee			ld (debug_mark+1),a  
27dc 3a e6 27			ld a, (.dmark+2)  
27df 32 6d ee			ld (debug_mark+2),a  
27e2 18 03			jr .pastdmark  
27e4 ..			.dmark: db "UWu"  
27e7 f1			.pastdmark: pop af  
27e8			endm  
# End of macro DMARK
27e8					CALLMONITOR 
27e8 cd 6f ee			call debug_vector  
27eb				endm  
# End of macro CALLMONITOR
27eb				endif 
27eb					; we have a uword so push its name to the stack 
27eb			 
27eb e5				   	push hl  ; save so we can move to next dict block 
27ec			 
27ec					; skip opcode 
27ec 23					inc hl  
27ed					; skip next ptr 
27ed 23					inc hl  
27ee 23					inc hl 
27ef					; skip len 
27ef 23					inc hl 
27f0				if DEBUG_FORTH_WORDS 
27f0					DMARK "UWt" 
27f0 f5				push af  
27f1 3a 05 28			ld a, (.dmark)  
27f4 32 6b ee			ld (debug_mark),a  
27f7 3a 06 28			ld a, (.dmark+1)  
27fa 32 6c ee			ld (debug_mark+1),a  
27fd 3a 07 28			ld a, (.dmark+2)  
2800 32 6d ee			ld (debug_mark+2),a  
2803 18 03			jr .pastdmark  
2805 ..			.dmark: db "UWt"  
2808 f1			.pastdmark: pop af  
2809			endm  
# End of macro DMARK
2809					CALLMONITOR 
2809 cd 6f ee			call debug_vector  
280c				endm  
# End of macro CALLMONITOR
280c				endif 
280c 03					inc bc 
280d			 
280d c5					push bc 
280e cd b3 1c				call forth_push_str 
2811 c1					pop bc 
2812			 
2812 e1					pop hl 	 
2813			 
2813 cd 43 21		.nuword:	call forth_tok_next 
2816 18 92				jr .douscan  
2818			 
2818			.udone:		 ; push count of uwords found 
2818 c5					push bc 
2819 e1					pop hl 
281a			 
281a				if DEBUG_FORTH_WORDS 
281a					DMARK "UWc" 
281a f5				push af  
281b 3a 2f 28			ld a, (.dmark)  
281e 32 6b ee			ld (debug_mark),a  
2821 3a 30 28			ld a, (.dmark+1)  
2824 32 6c ee			ld (debug_mark+1),a  
2827 3a 31 28			ld a, (.dmark+2)  
282a 32 6d ee			ld (debug_mark+2),a  
282d 18 03			jr .pastdmark  
282f ..			.dmark: db "UWc"  
2832 f1			.pastdmark: pop af  
2833			endm  
# End of macro DMARK
2833					CALLMONITOR 
2833 cd 6f ee			call debug_vector  
2836				endm  
# End of macro CALLMONITOR
2836				endif 
2836 cd 45 1c				call forth_push_numhl 
2839			 
2839			 
2839				       NEXTW 
2839 c3 f2 1f			jp macro_next 
283c				endm 
# End of macro NEXTW
283c			 
283c			.BP: 
283c				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
283c 54				db WORD_SYS_CORE+64             
283d 76 28			dw .MONITOR            
283f 03				db 2 + 1 
2840 .. 00			db "BP",0              
2843				endm 
# End of macro CWHEAD
2843			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2843			; | | $00 Will enable the break points within specific code paths 
2843			; | | $01 Will disable break points 
2843			; | |  
2843			; | | By default break points are off. Either the above can be used to enable them 
2843			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2843			; | | and on release of the pressed key a message will be disaplayed to notify 
2843			; | | that break points are enabled. Pressing any key will then continue boot process. 
2843					; get byte count 
2843					if DEBUG_FORTH_WORDS_KEY 
2843						DMARK "BP." 
2843 f5				push af  
2844 3a 58 28			ld a, (.dmark)  
2847 32 6b ee			ld (debug_mark),a  
284a 3a 59 28			ld a, (.dmark+1)  
284d 32 6c ee			ld (debug_mark+1),a  
2850 3a 5a 28			ld a, (.dmark+2)  
2853 32 6d ee			ld (debug_mark+2),a  
2856 18 03			jr .pastdmark  
2858 ..			.dmark: db "BP."  
285b f1			.pastdmark: pop af  
285c			endm  
# End of macro DMARK
285c						CALLMONITOR 
285c cd 6f ee			call debug_vector  
285f				endm  
# End of macro CALLMONITOR
285f					endif 
285f			 
285f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
285f cd 3c 1e			call macro_dsp_valuehl 
2862				endm 
# End of macro FORTH_DSP_VALUEHL
2862			 
2862			;		push hl 
2862			 
2862					; destroy value TOS 
2862			 
2862					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2862 cd f4 1e			call macro_forth_dsp_pop 
2865				endm 
# End of macro FORTH_DSP_POP
2865			 
2865			;		pop hl 
2865			 
2865 3e 00				ld a,0 
2867 bd					cp l 
2868 28 06				jr z, .bpset 
286a			;		ld a, '*' 
286a cd e9 15				call bp_off 
286d					NEXTW 
286d c3 f2 1f			jp macro_next 
2870				endm 
# End of macro NEXTW
2870			 
2870			.bpset:	 
2870					;	ld (os_view_disable), a 
2870 cd dd 15				call bp_on 
2873			 
2873			 
2873					NEXTW 
2873 c3 f2 1f			jp macro_next 
2876				endm 
# End of macro NEXTW
2876			 
2876			 
2876			.MONITOR: 
2876				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2876 55				db WORD_SYS_CORE+65             
2877 a7 28			dw .MALLOC            
2879 08				db 7 + 1 
287a .. 00			db "MONITOR",0              
2882				endm 
# End of macro CWHEAD
2882			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2882			; | | At start the current various registers will be displayed with contents. 
2882			; | | Top right corner will show the most recent debug marker seen. 
2882			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2882			; | | and the return stack pointer (RSP). 
2882			; | | Pressing: 
2882			; | |    1 - Initial screen 
2882			; | |    2 - Display a data dump of HL 
2882			; | |    3 - Display a data dump of DE 
2882			; | |    4 - Display a data dump of BC 
2882			; | |    5 - Display a data dump of HL 
2882			; | |    6 - Display a data dump of DSP 
2882			; | |    7 - Display a data dump of RSP 
2882			; | |    8 - Display a data dump of what is at DSP 
2882			; | |    9 - Display a data dump of what is at RSP 
2882			; | |    0 - Exit monitor and continue running. This will also enable break points 
2882			; | |    * - Disable break points 
2882			; | |    # - Enter traditional monitor mode 
2882			; | | 
2882			; | | Monitor Mode 
2882			; | | ------------ 
2882			; | | A prompt of '>' will be shown for various commands: 
2882			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2882			; | |    C - Continue display a data dump from the last set address 
2882			; | |    M xxxx - Set start of memory edit at address xx 
2882			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2882			; | |    Q - Return to previous 
2882					if DEBUG_FORTH_WORDS_KEY 
2882						DMARK "MON" 
2882 f5				push af  
2883 3a 97 28			ld a, (.dmark)  
2886 32 6b ee			ld (debug_mark),a  
2889 3a 98 28			ld a, (.dmark+1)  
288c 32 6c ee			ld (debug_mark+1),a  
288f 3a 99 28			ld a, (.dmark+2)  
2892 32 6d ee			ld (debug_mark+2),a  
2895 18 03			jr .pastdmark  
2897 ..			.dmark: db "MON"  
289a f1			.pastdmark: pop af  
289b			endm  
# End of macro DMARK
289b						CALLMONITOR 
289b cd 6f ee			call debug_vector  
289e				endm  
# End of macro CALLMONITOR
289e					endif 
289e			;		ld a, 0 
289e			;		ld (os_view_disable), a 
289e cd dd 15				call bp_on 
28a1			 
28a1					CALLMONITOR 
28a1 cd 6f ee			call debug_vector  
28a4				endm  
# End of macro CALLMONITOR
28a4			 
28a4			;	call monitor 
28a4			 
28a4					NEXTW 
28a4 c3 f2 1f			jp macro_next 
28a7				endm 
# End of macro NEXTW
28a7			 
28a7			 
28a7			.MALLOC: 
28a7				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28a7 56				db WORD_SYS_CORE+66             
28a8 d0 28			dw .MALLOC2            
28aa 06				db 5 + 1 
28ab .. 00			db "ALLOT",0              
28b1				endm 
# End of macro CWHEAD
28b1			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28b1					if DEBUG_FORTH_WORDS_KEY 
28b1						DMARK "ALL" 
28b1 f5				push af  
28b2 3a c6 28			ld a, (.dmark)  
28b5 32 6b ee			ld (debug_mark),a  
28b8 3a c7 28			ld a, (.dmark+1)  
28bb 32 6c ee			ld (debug_mark+1),a  
28be 3a c8 28			ld a, (.dmark+2)  
28c1 32 6d ee			ld (debug_mark+2),a  
28c4 18 03			jr .pastdmark  
28c6 ..			.dmark: db "ALL"  
28c9 f1			.pastdmark: pop af  
28ca			endm  
# End of macro DMARK
28ca						CALLMONITOR 
28ca cd 6f ee			call debug_vector  
28cd				endm  
# End of macro CALLMONITOR
28cd					endif 
28cd c3 f7 28				jp .mallocc 
28d0			.MALLOC2: 
28d0				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28d0 56				db WORD_SYS_CORE+66             
28d1 0e 29			dw .FREE            
28d3 07				db 6 + 1 
28d4 .. 00			db "MALLOC",0              
28db				endm 
# End of macro CWHEAD
28db			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28db					; get byte count 
28db					if DEBUG_FORTH_WORDS_KEY 
28db						DMARK "MAL" 
28db f5				push af  
28dc 3a f0 28			ld a, (.dmark)  
28df 32 6b ee			ld (debug_mark),a  
28e2 3a f1 28			ld a, (.dmark+1)  
28e5 32 6c ee			ld (debug_mark+1),a  
28e8 3a f2 28			ld a, (.dmark+2)  
28eb 32 6d ee			ld (debug_mark+2),a  
28ee 18 03			jr .pastdmark  
28f0 ..			.dmark: db "MAL"  
28f3 f1			.pastdmark: pop af  
28f4			endm  
# End of macro DMARK
28f4						CALLMONITOR 
28f4 cd 6f ee			call debug_vector  
28f7				endm  
# End of macro CALLMONITOR
28f7					endif 
28f7			.mallocc: 
28f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28f7 cd 3c 1e			call macro_dsp_valuehl 
28fa				endm 
# End of macro FORTH_DSP_VALUEHL
28fa			 
28fa			;		push hl 
28fa			 
28fa					; destroy value TOS 
28fa			 
28fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28fa cd f4 1e			call macro_forth_dsp_pop 
28fd				endm 
# End of macro FORTH_DSP_POP
28fd			 
28fd			;		pop hl 
28fd cd ae 12				call malloc 
2900				if DEBUG_FORTH_MALLOC_GUARD 
2900 f5					push af 
2901 cd 10 0e				call ishlzero 
2904			;		ld a, l 
2904			;		add h 
2904			;		cp 0 
2904 f1					pop af 
2905					 
2905 cc 31 4d				call z,malloc_error 
2908				endif 
2908			 
2908 cd 45 1c				call forth_push_numhl 
290b					NEXTW 
290b c3 f2 1f			jp macro_next 
290e				endm 
# End of macro NEXTW
290e			 
290e			.FREE: 
290e				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
290e 57				db WORD_SYS_CORE+67             
290f 3f 29			dw .LIST            
2911 05				db 4 + 1 
2912 .. 00			db "FREE",0              
2917				endm 
# End of macro CWHEAD
2917			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2917					if DEBUG_FORTH_WORDS_KEY 
2917						DMARK "FRE" 
2917 f5				push af  
2918 3a 2c 29			ld a, (.dmark)  
291b 32 6b ee			ld (debug_mark),a  
291e 3a 2d 29			ld a, (.dmark+1)  
2921 32 6c ee			ld (debug_mark+1),a  
2924 3a 2e 29			ld a, (.dmark+2)  
2927 32 6d ee			ld (debug_mark+2),a  
292a 18 03			jr .pastdmark  
292c ..			.dmark: db "FRE"  
292f f1			.pastdmark: pop af  
2930			endm  
# End of macro DMARK
2930						CALLMONITOR 
2930 cd 6f ee			call debug_vector  
2933				endm  
# End of macro CALLMONITOR
2933					endif 
2933					; get address 
2933			 
2933					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2933 cd 3c 1e			call macro_dsp_valuehl 
2936				endm 
# End of macro FORTH_DSP_VALUEHL
2936			 
2936			;		push hl 
2936			 
2936					; destroy value TOS 
2936			 
2936					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2936 cd f4 1e			call macro_forth_dsp_pop 
2939				endm 
# End of macro FORTH_DSP_POP
2939			 
2939			;		pop hl 
2939			if FORTH_ENABLE_MALLOCFREE 
2939 cd 78 13				call free 
293c			endif 
293c					NEXTW 
293c c3 f2 1f			jp macro_next 
293f				endm 
# End of macro NEXTW
293f			.LIST: 
293f				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
293f 5c				db WORD_SYS_CORE+72             
2940 2d 2b			dw .FORGET            
2942 05				db 4 + 1 
2943 .. 00			db "LIST",0              
2948				endm 
# End of macro CWHEAD
2948			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2948			; | | The quoted word must be in upper case. 
2948				if DEBUG_FORTH_WORDS_KEY 
2948					DMARK "LST" 
2948 f5				push af  
2949 3a 5d 29			ld a, (.dmark)  
294c 32 6b ee			ld (debug_mark),a  
294f 3a 5e 29			ld a, (.dmark+1)  
2952 32 6c ee			ld (debug_mark+1),a  
2955 3a 5f 29			ld a, (.dmark+2)  
2958 32 6d ee			ld (debug_mark+2),a  
295b 18 03			jr .pastdmark  
295d ..			.dmark: db "LST"  
2960 f1			.pastdmark: pop af  
2961			endm  
# End of macro DMARK
2961					CALLMONITOR 
2961 cd 6f ee			call debug_vector  
2964				endm  
# End of macro CALLMONITOR
2964				endif 
2964			 
2964					FORTH_DSP_VALUEHL 
2964 cd 3c 1e			call macro_dsp_valuehl 
2967				endm 
# End of macro FORTH_DSP_VALUEHL
2967			 
2967 e5					push hl 
2968					FORTH_DSP_POP 
2968 cd f4 1e			call macro_forth_dsp_pop 
296b				endm 
# End of macro FORTH_DSP_POP
296b c1					pop bc 
296c			 
296c			; Start format of scratch string 
296c			 
296c 21 c1 e2				ld hl, scratch 
296f			 
296f 3e 3a				ld a, ':' 
2971 77					ld (hl),a 
2972 23					inc hl 
2973 3e 20				ld a, ' ' 
2975 77					ld (hl), a 
2976			 
2976					; Get ptr to the word we need to look up 
2976			 
2976			;		FORTH_DSP_VALUEHL 
2976					;v5 FORTH_DSP_VALUE 
2976				; TODO type check 
2976			;		inc hl    ; Skip type check  
2976			;		push hl 
2976			;		ex de, hl    ; put into DE 
2976			 
2976			 
2976 21 8f 65				ld hl, baseram 
2979					;ld hl, baseusermem 
2979			 
2979 e5			push hl   ; sacreifical push 
297a			 
297a			.ldouscanm: 
297a e1				pop hl 
297b			.ldouscan: 
297b				if DEBUG_FORTH_WORDS 
297b					DMARK "LSs" 
297b f5				push af  
297c 3a 90 29			ld a, (.dmark)  
297f 32 6b ee			ld (debug_mark),a  
2982 3a 91 29			ld a, (.dmark+1)  
2985 32 6c ee			ld (debug_mark+1),a  
2988 3a 92 29			ld a, (.dmark+2)  
298b 32 6d ee			ld (debug_mark+2),a  
298e 18 03			jr .pastdmark  
2990 ..			.dmark: db "LSs"  
2993 f1			.pastdmark: pop af  
2994			endm  
# End of macro DMARK
2994					CALLMONITOR 
2994 cd 6f ee			call debug_vector  
2997				endm  
# End of macro CALLMONITOR
2997				endif 
2997				; skip dict stub 
2997 cd 43 21				call forth_tok_next 
299a			 
299a			 
299a			; while we have words to look for 
299a			 
299a 7e				ld a, (hl)      
299b				if DEBUG_FORTH_WORDS 
299b					DMARK "LSk" 
299b f5				push af  
299c 3a b0 29			ld a, (.dmark)  
299f 32 6b ee			ld (debug_mark),a  
29a2 3a b1 29			ld a, (.dmark+1)  
29a5 32 6c ee			ld (debug_mark+1),a  
29a8 3a b2 29			ld a, (.dmark+2)  
29ab 32 6d ee			ld (debug_mark+2),a  
29ae 18 03			jr .pastdmark  
29b0 ..			.dmark: db "LSk"  
29b3 f1			.pastdmark: pop af  
29b4			endm  
# End of macro DMARK
29b4					CALLMONITOR 
29b4 cd 6f ee			call debug_vector  
29b7				endm  
# End of macro CALLMONITOR
29b7				endif 
29b7					;cp WORD_SYS_END 
29b7					;jp z, .lunotfound 
29b7			 
29b7					; if we hit non uwords then gone too far 
29b7 fe 01				cp WORD_SYS_UWORD 
29b9 c2 e9 2a				jp nz, .lunotfound 
29bc			 
29bc				if DEBUG_FORTH_WORDS 
29bc					DMARK "LSu" 
29bc f5				push af  
29bd 3a d1 29			ld a, (.dmark)  
29c0 32 6b ee			ld (debug_mark),a  
29c3 3a d2 29			ld a, (.dmark+1)  
29c6 32 6c ee			ld (debug_mark+1),a  
29c9 3a d3 29			ld a, (.dmark+2)  
29cc 32 6d ee			ld (debug_mark+2),a  
29cf 18 03			jr .pastdmark  
29d1 ..			.dmark: db "LSu"  
29d4 f1			.pastdmark: pop af  
29d5			endm  
# End of macro DMARK
29d5					CALLMONITOR 
29d5 cd 6f ee			call debug_vector  
29d8				endm  
# End of macro CALLMONITOR
29d8				endif 
29d8			 
29d8					; found a uword but is it the one we want... 
29d8			 
29d8 c5					push bc     ; uword to find is on bc 
29d9 d1					pop de 
29da			 
29da e5					push hl  ; to save the ptr 
29db			 
29db					; skip opcode 
29db 23					inc hl  
29dc					; skip next ptr 
29dc 23					inc hl  
29dd 23					inc hl 
29de					; skip len 
29de 23					inc hl 
29df			 
29df				if DEBUG_FORTH_WORDS 
29df					DMARK "LSc" 
29df f5				push af  
29e0 3a f4 29			ld a, (.dmark)  
29e3 32 6b ee			ld (debug_mark),a  
29e6 3a f5 29			ld a, (.dmark+1)  
29e9 32 6c ee			ld (debug_mark+1),a  
29ec 3a f6 29			ld a, (.dmark+2)  
29ef 32 6d ee			ld (debug_mark+2),a  
29f2 18 03			jr .pastdmark  
29f4 ..			.dmark: db "LSc"  
29f7 f1			.pastdmark: pop af  
29f8			endm  
# End of macro DMARK
29f8					CALLMONITOR 
29f8 cd 6f ee			call debug_vector  
29fb				endm  
# End of macro CALLMONITOR
29fb				endif 
29fb cd 7d 12				call strcmp 
29fe c2 7a 29				jp nz, .ldouscanm 
2a01				 
2a01			 
2a01			 
2a01					; we have a uword so push its name to the stack 
2a01			 
2a01			;	   	push hl  ; save so we can move to next dict block 
2a01 e1			pop hl 
2a02			 
2a02				if DEBUG_FORTH_WORDS 
2a02					DMARK "LSm" 
2a02 f5				push af  
2a03 3a 17 2a			ld a, (.dmark)  
2a06 32 6b ee			ld (debug_mark),a  
2a09 3a 18 2a			ld a, (.dmark+1)  
2a0c 32 6c ee			ld (debug_mark+1),a  
2a0f 3a 19 2a			ld a, (.dmark+2)  
2a12 32 6d ee			ld (debug_mark+2),a  
2a15 18 03			jr .pastdmark  
2a17 ..			.dmark: db "LSm"  
2a1a f1			.pastdmark: pop af  
2a1b			endm  
# End of macro DMARK
2a1b					CALLMONITOR 
2a1b cd 6f ee			call debug_vector  
2a1e				endm  
# End of macro CALLMONITOR
2a1e				endif 
2a1e			 
2a1e					; skip opcode 
2a1e 23					inc hl  
2a1f					; skip next ptr 
2a1f 23					inc hl  
2a20 23					inc hl 
2a21					; skip len 
2a21 7e					ld a, (hl)   ; save length to add 
2a22				if DEBUG_FORTH_WORDS 
2a22					DMARK "LS2" 
2a22 f5				push af  
2a23 3a 37 2a			ld a, (.dmark)  
2a26 32 6b ee			ld (debug_mark),a  
2a29 3a 38 2a			ld a, (.dmark+1)  
2a2c 32 6c ee			ld (debug_mark+1),a  
2a2f 3a 39 2a			ld a, (.dmark+2)  
2a32 32 6d ee			ld (debug_mark+2),a  
2a35 18 03			jr .pastdmark  
2a37 ..			.dmark: db "LS2"  
2a3a f1			.pastdmark: pop af  
2a3b			endm  
# End of macro DMARK
2a3b					CALLMONITOR 
2a3b cd 6f ee			call debug_vector  
2a3e				endm  
# End of macro CALLMONITOR
2a3e				endif 
2a3e			 
2a3e					; save this location 
2a3e				 
2a3e e5					push hl 
2a3f			 
2a3f 23					inc hl 
2a40 11 c3 e2				ld de, scratch+2 
2a43 4f					ld c, a 
2a44 06 00				ld b, 0 
2a46			 
2a46				if DEBUG_FORTH_WORDS 
2a46					DMARK "LSn" 
2a46 f5				push af  
2a47 3a 5b 2a			ld a, (.dmark)  
2a4a 32 6b ee			ld (debug_mark),a  
2a4d 3a 5c 2a			ld a, (.dmark+1)  
2a50 32 6c ee			ld (debug_mark+1),a  
2a53 3a 5d 2a			ld a, (.dmark+2)  
2a56 32 6d ee			ld (debug_mark+2),a  
2a59 18 03			jr .pastdmark  
2a5b ..			.dmark: db "LSn"  
2a5e f1			.pastdmark: pop af  
2a5f			endm  
# End of macro DMARK
2a5f					CALLMONITOR 
2a5f cd 6f ee			call debug_vector  
2a62				endm  
# End of macro CALLMONITOR
2a62				endif 
2a62			 
2a62					; copy uword name to scratch 
2a62			 
2a62 ed b0				ldir 
2a64			 
2a64 1b					dec de 
2a65 3e 20				ld a, ' '    ; change null to space 
2a67 12					ld (de), a 
2a68			 
2a68 13					inc de 
2a69			 
2a69 d5					push de 
2a6a c1					pop bc     ; move scratch pointer to end of word name and save it 
2a6b			 
2a6b e1					pop hl 
2a6c 7e					ld a, (hl) 
2a6d					;inc hl 
2a6d					; skip word string 
2a6d cd e7 0d				call addatohl 
2a70			 
2a70 23					inc hl 
2a71			 
2a71				if DEBUG_FORTH_WORDS 
2a71					DMARK "LS3" 
2a71 f5				push af  
2a72 3a 86 2a			ld a, (.dmark)  
2a75 32 6b ee			ld (debug_mark),a  
2a78 3a 87 2a			ld a, (.dmark+1)  
2a7b 32 6c ee			ld (debug_mark+1),a  
2a7e 3a 88 2a			ld a, (.dmark+2)  
2a81 32 6d ee			ld (debug_mark+2),a  
2a84 18 03			jr .pastdmark  
2a86 ..			.dmark: db "LS3"  
2a89 f1			.pastdmark: pop af  
2a8a			endm  
# End of macro DMARK
2a8a					CALLMONITOR 
2a8a cd 6f ee			call debug_vector  
2a8d				endm  
# End of macro CALLMONITOR
2a8d				endif 
2a8d					; should now be at the start of the machine code to setup the eval of the uword 
2a8d					; now locate the ptr to the string defintion 
2a8d			 
2a8d					; skip ld hl, 
2a8d					; then load the ptr 
2a8d			; TODO use get from hl ptr 
2a8d 23					inc hl 
2a8e 5e					ld e, (hl) 
2a8f 23					inc hl 
2a90 56					ld d, (hl) 
2a91 eb					ex de, hl 
2a92			 
2a92			 
2a92				if DEBUG_FORTH_WORDS 
2a92					DMARK "LSt" 
2a92 f5				push af  
2a93 3a a7 2a			ld a, (.dmark)  
2a96 32 6b ee			ld (debug_mark),a  
2a99 3a a8 2a			ld a, (.dmark+1)  
2a9c 32 6c ee			ld (debug_mark+1),a  
2a9f 3a a9 2a			ld a, (.dmark+2)  
2aa2 32 6d ee			ld (debug_mark+2),a  
2aa5 18 03			jr .pastdmark  
2aa7 ..			.dmark: db "LSt"  
2aaa f1			.pastdmark: pop af  
2aab			endm  
# End of macro DMARK
2aab					CALLMONITOR 
2aab cd 6f ee			call debug_vector  
2aae				endm  
# End of macro CALLMONITOR
2aae				endif 
2aae			 
2aae			; cant push right now due to tokenised strings  
2aae			 
2aae			; get the destination of where to copy this definition to. 
2aae			 
2aae c5					push bc 
2aaf d1					pop de 
2ab0			 
2ab0 7e			.listl:         ld a,(hl) 
2ab1 fe 00				cp 0 
2ab3 28 09				jr z, .lreplsp     ; replace zero with space 
2ab5					;cp FORTH_END_BUFFER 
2ab5 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ab7 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ab9				 
2ab9					; just copy this char as is then 
2ab9			 
2ab9 12					ld (de), a 
2aba			 
2aba 23			.listnxt:	inc hl 
2abb 13					inc de 
2abc 18 f2				jr .listl 
2abe			 
2abe 3e 20		.lreplsp:	ld a,' ' 
2ac0 12					ld (de), a 
2ac1 18 f7				jr .listnxt 
2ac3			 
2ac3			; close up uword def 
2ac3			 
2ac3			.listdone: 
2ac3 12					ld (de), a 
2ac4 13					inc de 
2ac5 3e 00				ld a, 0 
2ac7 12					ld (de), a 
2ac8			 
2ac8			; now have def so clean up and push to stack 
2ac8			 
2ac8 21 c1 e2				ld hl, scratch 
2acb				if DEBUG_FORTH_WORDS 
2acb					DMARK "Ltp" 
2acb f5				push af  
2acc 3a e0 2a			ld a, (.dmark)  
2acf 32 6b ee			ld (debug_mark),a  
2ad2 3a e1 2a			ld a, (.dmark+1)  
2ad5 32 6c ee			ld (debug_mark+1),a  
2ad8 3a e2 2a			ld a, (.dmark+2)  
2adb 32 6d ee			ld (debug_mark+2),a  
2ade 18 03			jr .pastdmark  
2ae0 ..			.dmark: db "Ltp"  
2ae3 f1			.pastdmark: pop af  
2ae4			endm  
# End of macro DMARK
2ae4					CALLMONITOR 
2ae4 cd 6f ee			call debug_vector  
2ae7				endm  
# End of macro CALLMONITOR
2ae7				endif 
2ae7			 
2ae7 18 1f			jr .listpush 
2ae9			 
2ae9			;.lnuword:	pop hl 
2ae9			;		call forth_tok_next 
2ae9			;		jp .ldouscan  
2ae9			 
2ae9			.lunotfound:		  
2ae9			 
2ae9				if DEBUG_FORTH_WORDS 
2ae9					DMARK "LSn" 
2ae9 f5				push af  
2aea 3a fe 2a			ld a, (.dmark)  
2aed 32 6b ee			ld (debug_mark),a  
2af0 3a ff 2a			ld a, (.dmark+1)  
2af3 32 6c ee			ld (debug_mark+1),a  
2af6 3a 00 2b			ld a, (.dmark+2)  
2af9 32 6d ee			ld (debug_mark+2),a  
2afc 18 03			jr .pastdmark  
2afe ..			.dmark: db "LSn"  
2b01 f1			.pastdmark: pop af  
2b02			endm  
# End of macro DMARK
2b02					CALLMONITOR 
2b02 cd 6f ee			call debug_vector  
2b05				endm  
# End of macro CALLMONITOR
2b05				endif 
2b05			 
2b05					 
2b05			;		FORTH_DSP_POP 
2b05			;		ld hl, .luno 
2b05			 
2b05					NEXTW			 
2b05 c3 f2 1f			jp macro_next 
2b08				endm 
# End of macro NEXTW
2b08			 
2b08			.listpush: 
2b08				if DEBUG_FORTH_WORDS 
2b08					DMARK "LS>" 
2b08 f5				push af  
2b09 3a 1d 2b			ld a, (.dmark)  
2b0c 32 6b ee			ld (debug_mark),a  
2b0f 3a 1e 2b			ld a, (.dmark+1)  
2b12 32 6c ee			ld (debug_mark+1),a  
2b15 3a 1f 2b			ld a, (.dmark+2)  
2b18 32 6d ee			ld (debug_mark+2),a  
2b1b 18 03			jr .pastdmark  
2b1d ..			.dmark: db "LS>"  
2b20 f1			.pastdmark: pop af  
2b21			endm  
# End of macro DMARK
2b21					CALLMONITOR 
2b21 cd 6f ee			call debug_vector  
2b24				endm  
# End of macro CALLMONITOR
2b24				endif 
2b24 cd b3 1c				call forth_push_str 
2b27			 
2b27			 
2b27			 
2b27					NEXTW 
2b27 c3 f2 1f			jp macro_next 
2b2a				endm 
# End of macro NEXTW
2b2a			 
2b2a			;.luno:    db "Word not found",0 
2b2a			 
2b2a			 
2b2a			 
2b2a			 
2b2a			 
2b2a			;		push hl   ; save pointer to start of uword def string 
2b2a			; 
2b2a			;; look for FORTH_EOL_LINE 
2b2a			;		ld a, FORTH_END_BUFFER 
2b2a			;		call strlent 
2b2a			; 
2b2a			;		inc hl		 ; space for coln def 
2b2a			;		inc hl 
2b2a			;		inc hl          ; space for terms 
2b2a			;		inc hl 
2b2a			; 
2b2a			;		ld a, 20   ; TODO get actual length 
2b2a			;		call addatohl    ; include a random amount of room for the uword name 
2b2a			; 
2b2a			;		 
2b2a			;	if DEBUG_FORTH_WORDS 
2b2a			;		DMARK "Lt1" 
2b2a			;		CALLMONITOR 
2b2a			;	endif 
2b2a			;		 
2b2a			; 
2b2a			;; malloc space for the string because we cant change it 
2b2a			; 
2b2a			;		call malloc 
2b2a			;	if DEBUG_FORTH_MALLOC_GUARD 
2b2a			;		push af 
2b2a			;		call ishlzero 
2b2a			;		pop af 
2b2a			;		 
2b2a			;		call z,malloc_error 
2b2a			;	endif 
2b2a			; 
2b2a			;	if DEBUG_FORTH_WORDS 
2b2a			;		DMARK "Lt2" 
2b2a			;		CALLMONITOR 
2b2a			;	endif 
2b2a			;		pop de 
2b2a			;		push hl    ; push the malloc to release later 
2b2a			;		push hl   ;  push back a copy for the later stack push 
2b2a			;		 
2b2a			;; copy the string swapping out the zero terms for spaces 
2b2a			; 
2b2a			;		; de has our source 
2b2a			;		; hl has our dest 
2b2a			; 
2b2a			;; add the coln def 
2b2a			; 
2b2a			;		ld a, ':' 
2b2a			;		ld (hl), a 
2b2a			;		inc hl 
2b2a			;		ld a, ' ' 
2b2a			;		ld (hl), a 
2b2a			;		inc hl 
2b2a			; 
2b2a			;; add the uname word 
2b2a			;		push de   ; save our string for now 
2b2a			;		ex de, hl 
2b2a			; 
2b2a			;		FORTH_DSP_VALUE 
2b2a			;		;v5 FORTH_DSP_VALUE 
2b2a			; 
2b2a			;		inc hl   ; skip type but we know by now this is OK 
2b2a			; 
2b2a			;.luword:	ld a,(hl) 
2b2a			;		cp 0 
2b2a			;		jr z, .luword2 
2b2a			;		ld (de), a 
2b2a			;		inc de 
2b2a			;		inc hl 
2b2a			;		jr .luword 
2b2a			; 
2b2a			;.luword2:	ld a, ' ' 
2b2a			;		ld (de), a 
2b2a			;;		inc hl 
2b2a			;;		inc de 
2b2a			;;		ld (de), a 
2b2a			;;		inc hl 
2b2a			;		inc de 
2b2a			; 
2b2a			;		ex de, hl 
2b2a			;		pop de 
2b2a			;		 
2b2a			;		 
2b2a			; 
2b2a			;; detoken that string and copy it 
2b2a			; 
2b2a			;	if DEBUG_FORTH_WORDS 
2b2a			;		DMARK "Lt2" 
2b2a			;		CALLMONITOR 
2b2a			;	endif 
2b2a			;.ldetok:	ld a, (de) 
2b2a			;		cp FORTH_END_BUFFER 
2b2a			;		jr z, .ldetokend 
2b2a			;		; swap out any zero term for space 
2b2a			;		cp 0 
2b2a			;		jr nz, .ldetoknext 
2b2a			;		ld a, ' ' 
2b2a			; 
2b2a			;	if DEBUG_FORTH_WORDS 
2b2a			;		DMARK "LtS" 
2b2a			;		CALLMONITOR 
2b2a			;	endif 
2b2a			;.ldetoknext:	ld (hl), a 
2b2a			;		inc de 
2b2a			;		inc hl 
2b2a			;		jr .ldetok 
2b2a			; 
2b2a			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b2a			;		ld (hl), a  
2b2a			; 
2b2a			;; free that temp malloc 
2b2a			; 
2b2a			;		pop hl    
2b2a			; 
2b2a			;	if DEBUG_FORTH_WORDS 
2b2a			;		DMARK "Lt4" 
2b2a			;		CALLMONITOR 
2b2a			;	endif 
2b2a			;		call forth_apushstrhl 
2b2a			; 
2b2a			;		; get rid of temp malloc area 
2b2a			; 
2b2a			;		pop hl 
2b2a			;		call free 
2b2a			; 
2b2a			;		jr .ludone 
2b2a			; 
2b2a			;.lnuword:	pop hl 
2b2a			;		call forth_tok_next 
2b2a			;		jp .ldouscan  
2b2a			; 
2b2a			;.ludone:		 pop hl 
2b2a			; 
2b2a					NEXTW 
2b2a c3 f2 1f			jp macro_next 
2b2d				endm 
# End of macro NEXTW
2b2d			 
2b2d			.FORGET: 
2b2d				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b2d 5d				db WORD_SYS_CORE+73             
2b2e a6 2b			dw .NOP            
2b30 07				db 6 + 1 
2b31 .. 00			db "FORGET",0              
2b38				endm 
# End of macro CWHEAD
2b38			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b38			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b38			; | |  
2b38			; | | e.g. "MORE" forget 
2b38					if DEBUG_FORTH_WORDS_KEY 
2b38						DMARK "FRG" 
2b38 f5				push af  
2b39 3a 4d 2b			ld a, (.dmark)  
2b3c 32 6b ee			ld (debug_mark),a  
2b3f 3a 4e 2b			ld a, (.dmark+1)  
2b42 32 6c ee			ld (debug_mark+1),a  
2b45 3a 4f 2b			ld a, (.dmark+2)  
2b48 32 6d ee			ld (debug_mark+2),a  
2b4b 18 03			jr .pastdmark  
2b4d ..			.dmark: db "FRG"  
2b50 f1			.pastdmark: pop af  
2b51			endm  
# End of macro DMARK
2b51						CALLMONITOR 
2b51 cd 6f ee			call debug_vector  
2b54				endm  
# End of macro CALLMONITOR
2b54					endif 
2b54			 
2b54				; find uword 
2b54			        ; update start of word with "_" 
2b54				; replace uword with deleted flag 
2b54			 
2b54			 
2b54			;	if DEBUG_FORTH_WORDS 
2b54			;		DMARK "FOG" 
2b54			;		CALLMONITOR 
2b54			;	endif 
2b54			 
2b54			 
2b54					; Get ptr to the word we need to look up 
2b54			 
2b54					FORTH_DSP_VALUEHL 
2b54 cd 3c 1e			call macro_dsp_valuehl 
2b57				endm 
# End of macro FORTH_DSP_VALUEHL
2b57					;v5 FORTH_DSP_VALUE 
2b57				; TODO type check 
2b57			;		inc hl    ; Skip type check  
2b57 e5					push hl 
2b58 c1					pop bc 
2b59			;		ex de, hl    ; put into DE 
2b59			 
2b59			 
2b59 21 8f 65				ld hl, baseram 
2b5c					;ld hl, baseusermem 
2b5c			 
2b5c				; skip dict stub 
2b5c			;	call forth_tok_next 
2b5c e5			push hl   ; sacreifical push 
2b5d			 
2b5d			.fldouscanm: 
2b5d e1				pop hl 
2b5e			.fldouscan: 
2b5e			;	if DEBUG_FORTH_WORDS 
2b5e			;		DMARK "LSs" 
2b5e			;		CALLMONITOR 
2b5e			;	endif 
2b5e				; skip dict stub 
2b5e cd 43 21				call forth_tok_next 
2b61			 
2b61			 
2b61			; while we have words to look for 
2b61			 
2b61 7e				ld a, (hl)      
2b62			;	if DEBUG_FORTH_WORDS 
2b62			;		DMARK "LSk" 
2b62			;		CALLMONITOR 
2b62			;	endif 
2b62 fe 00				cp WORD_SYS_END 
2b64 ca a0 2b				jp z, .flunotfound 
2b67 fe 01				cp WORD_SYS_UWORD 
2b69 c2 5e 2b				jp nz, .fldouscan 
2b6c			 
2b6c			;	if DEBUG_FORTH_WORDS 
2b6c			;		DMARK "LSu" 
2b6c			;		CALLMONITOR 
2b6c			;	endif 
2b6c			 
2b6c					; found a uword but is it the one we want... 
2b6c			 
2b6c c5					push bc     ; uword to find is on bc 
2b6d d1					pop de 
2b6e			 
2b6e e5					push hl  ; to save the ptr 
2b6f			 
2b6f					; skip opcode 
2b6f 23					inc hl  
2b70					; skip next ptr 
2b70 23					inc hl  
2b71 23					inc hl 
2b72					; skip len 
2b72 23					inc hl 
2b73			 
2b73			;	if DEBUG_FORTH_WORDS 
2b73			;		DMARK "LSc" 
2b73			;		CALLMONITOR 
2b73			;	endif 
2b73 cd 7d 12				call strcmp 
2b76 c2 5d 2b				jp nz, .fldouscanm 
2b79			; 
2b79			; 
2b79			;; while we have words to look for 
2b79			; 
2b79			;.fdouscan:	ld a, (hl)      
2b79			;	if DEBUG_FORTH_WORDS 
2b79			;		DMARK "LSs" 
2b79			;		CALLMONITOR 
2b79			;	endif 
2b79			;		cp WORD_SYS_END 
2b79			;		jp z, .fudone 
2b79			;		cp WORD_SYS_UWORD 
2b79			;		jp nz, .fnuword 
2b79			; 
2b79			;	if DEBUG_FORTH_WORDS 
2b79			;		DMARK "FGu" 
2b79			;		CALLMONITOR 
2b79			;	endif 
2b79			; 
2b79			;		; found a uword but is it the one we want... 
2b79			; 
2b79			; 
2b79			;	        pop de   ; get back the dsp name 
2b79			;		push de 
2b79			; 
2b79			;		push hl  ; to save the ptr 
2b79			; 
2b79			;		; skip opcode 
2b79			;		inc hl  
2b79			;		; skip next ptr 
2b79			;		inc hl  
2b79			;		inc hl 
2b79			;		; skip len 
2b79			;		inc hl 
2b79			; 
2b79			;	if DEBUG_FORTH_WORDS 
2b79			;		DMARK "FGc" 
2b79			;		CALLMONITOR 
2b79			;	endif 
2b79			;		call strcmp 
2b79			;		jp nz, .fnuword 
2b79			 
2b79			 
2b79 e1			pop hl 
2b7a			 
2b7a				 
2b7a				if DEBUG_FORTH_WORDS 
2b7a					DMARK "FGm" 
2b7a f5				push af  
2b7b 3a 8f 2b			ld a, (.dmark)  
2b7e 32 6b ee			ld (debug_mark),a  
2b81 3a 90 2b			ld a, (.dmark+1)  
2b84 32 6c ee			ld (debug_mark+1),a  
2b87 3a 91 2b			ld a, (.dmark+2)  
2b8a 32 6d ee			ld (debug_mark+2),a  
2b8d 18 03			jr .pastdmark  
2b8f ..			.dmark: db "FGm"  
2b92 f1			.pastdmark: pop af  
2b93			endm  
# End of macro DMARK
2b93					CALLMONITOR 
2b93 cd 6f ee			call debug_vector  
2b96				endm  
# End of macro CALLMONITOR
2b96				endif 
2b96			 
2b96			 
2b96			 
2b96					; we have a uword so push its name to the stack 
2b96			 
2b96			;	   	push hl  ; save so we can move to next dict block 
2b96			;pop hl 
2b96			 
2b96					; update opcode to deleted 
2b96 3e 03				ld a, WORD_SYS_DELETED 
2b98 77					ld (hl), a 
2b99			 
2b99 23					inc hl  
2b9a					; skip next ptr 
2b9a 23					inc hl  
2b9b 23					inc hl 
2b9c					; skip len 
2b9c 23					inc hl 
2b9d			 
2b9d					; TODO change parser to skip deleted words but for now mark it out 
2b9d 3e 5f				ld a, "_" 
2b9f 77					ld  (hl),a 
2ba0			 
2ba0			;		jr .fudone 
2ba0			; 
2ba0			;.fnuword:	pop hl 
2ba0			;		call forth_tok_next 
2ba0			;		jp .fdouscan  
2ba0			 
2ba0			.flunotfound:		  
2ba0			 
2ba0			 
2ba0					 
2ba0					FORTH_DSP_POP 
2ba0 cd f4 1e			call macro_forth_dsp_pop 
2ba3				endm 
# End of macro FORTH_DSP_POP
2ba3			;		ld hl, .luno 
2ba3			;.fudone:		 pop hl 
2ba3					NEXTW 
2ba3 c3 f2 1f			jp macro_next 
2ba6				endm 
# End of macro NEXTW
2ba6			.NOP: 
2ba6				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ba6 61				db WORD_SYS_CORE+77             
2ba7 cd 2b			dw .COMO            
2ba9 04				db 3 + 1 
2baa .. 00			db "NOP",0              
2bae				endm 
# End of macro CWHEAD
2bae			; | NOP (  --  ) Do nothing | DONE 
2bae					if DEBUG_FORTH_WORDS_KEY 
2bae						DMARK "NOP" 
2bae f5				push af  
2baf 3a c3 2b			ld a, (.dmark)  
2bb2 32 6b ee			ld (debug_mark),a  
2bb5 3a c4 2b			ld a, (.dmark+1)  
2bb8 32 6c ee			ld (debug_mark+1),a  
2bbb 3a c5 2b			ld a, (.dmark+2)  
2bbe 32 6d ee			ld (debug_mark+2),a  
2bc1 18 03			jr .pastdmark  
2bc3 ..			.dmark: db "NOP"  
2bc6 f1			.pastdmark: pop af  
2bc7			endm  
# End of macro DMARK
2bc7						CALLMONITOR 
2bc7 cd 6f ee			call debug_vector  
2bca				endm  
# End of macro CALLMONITOR
2bca					endif 
2bca				       NEXTW 
2bca c3 f2 1f			jp macro_next 
2bcd				endm 
# End of macro NEXTW
2bcd			.COMO: 
2bcd				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bcd 6e				db WORD_SYS_CORE+90             
2bce 1f 2c			dw .COMC            
2bd0 02				db 1 + 1 
2bd1 .. 00			db "(",0              
2bd3				endm 
# End of macro CWHEAD
2bd3			; | ( ( -- )  Start of comment | DONE 
2bd3			 
2bd3			 
2bd3 2a c2 e5				ld hl, ( os_tok_ptr) 
2bd6 11 1a 2c			ld de, .closepar 
2bd9					 
2bd9					if DEBUG_FORTH_WORDS 
2bd9						DMARK ").." 
2bd9 f5				push af  
2bda 3a ee 2b			ld a, (.dmark)  
2bdd 32 6b ee			ld (debug_mark),a  
2be0 3a ef 2b			ld a, (.dmark+1)  
2be3 32 6c ee			ld (debug_mark+1),a  
2be6 3a f0 2b			ld a, (.dmark+2)  
2be9 32 6d ee			ld (debug_mark+2),a  
2bec 18 03			jr .pastdmark  
2bee ..			.dmark: db ").."  
2bf1 f1			.pastdmark: pop af  
2bf2			endm  
# End of macro DMARK
2bf2						CALLMONITOR 
2bf2 cd 6f ee			call debug_vector  
2bf5				endm  
# End of macro CALLMONITOR
2bf5					endif 
2bf5 cd 0d 21			call findnexttok  
2bf8			 
2bf8					if DEBUG_FORTH_WORDS 
2bf8						DMARK "IF5" 
2bf8 f5				push af  
2bf9 3a 0d 2c			ld a, (.dmark)  
2bfc 32 6b ee			ld (debug_mark),a  
2bff 3a 0e 2c			ld a, (.dmark+1)  
2c02 32 6c ee			ld (debug_mark+1),a  
2c05 3a 0f 2c			ld a, (.dmark+2)  
2c08 32 6d ee			ld (debug_mark+2),a  
2c0b 18 03			jr .pastdmark  
2c0d ..			.dmark: db "IF5"  
2c10 f1			.pastdmark: pop af  
2c11			endm  
# End of macro DMARK
2c11						CALLMONITOR 
2c11 cd 6f ee			call debug_vector  
2c14				endm  
# End of macro CALLMONITOR
2c14					endif 
2c14				; replace below with ) exec using tok_ptr 
2c14 22 c2 e5			ld (os_tok_ptr), hl 
2c17 c3 83 20			jp exec1 
2c1a			 
2c1a .. 00			.closepar:   db ")",0 
2c1c			 
2c1c				       NEXTW 
2c1c c3 f2 1f			jp macro_next 
2c1f				endm 
# End of macro NEXTW
2c1f			.COMC: 
2c1f				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c1f 6f				db WORD_SYS_CORE+91             
2c20 28 2c			dw .SCRATCH            
2c22 02				db 1 + 1 
2c23 .. 00			db ")",0              
2c25				endm 
# End of macro CWHEAD
2c25			; | ) ( -- )  End of comment |  DONE  
2c25				       NEXTW 
2c25 c3 f2 1f			jp macro_next 
2c28				endm 
# End of macro NEXTW
2c28			 
2c28			.SCRATCH: 
2c28				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c28 6f				db WORD_SYS_CORE+91             
2c29 63 2c			dw .INC            
2c2b 08				db 7 + 1 
2c2c .. 00			db "SCRATCH",0              
2c34				endm 
# End of macro CWHEAD
2c34			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c34			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c34			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c34			; | |  
2c34			; | | e.g.    : score $00 scratch ; 
2c34			; | |  
2c34			; | | $00 score ! 
2c34			; | | $01 score +! 
2c34			; | |  
2c34			; | | e.g.   : varword $0a scratch ;  
2c34			; | | 
2c34			; | | $8000 varword ! 
2c34					if DEBUG_FORTH_WORDS_KEY 
2c34						DMARK "SCR" 
2c34 f5				push af  
2c35 3a 49 2c			ld a, (.dmark)  
2c38 32 6b ee			ld (debug_mark),a  
2c3b 3a 4a 2c			ld a, (.dmark+1)  
2c3e 32 6c ee			ld (debug_mark+1),a  
2c41 3a 4b 2c			ld a, (.dmark+2)  
2c44 32 6d ee			ld (debug_mark+2),a  
2c47 18 03			jr .pastdmark  
2c49 ..			.dmark: db "SCR"  
2c4c f1			.pastdmark: pop af  
2c4d			endm  
# End of macro DMARK
2c4d						CALLMONITOR 
2c4d cd 6f ee			call debug_vector  
2c50				endm  
# End of macro CALLMONITOR
2c50					endif 
2c50			 
2c50					FORTH_DSP_VALUEHL 
2c50 cd 3c 1e			call macro_dsp_valuehl 
2c53				endm 
# End of macro FORTH_DSP_VALUEHL
2c53				 
2c53					FORTH_DSP_POP 
2c53 cd f4 1e			call macro_forth_dsp_pop 
2c56				endm 
# End of macro FORTH_DSP_POP
2c56			 
2c56 7d					ld a, l 
2c57 21 e6 e7				ld hl, os_var_array 
2c5a cd e7 0d				call addatohl 
2c5d			 
2c5d cd 45 1c				call forth_push_numhl 
2c60			 
2c60				       NEXTW 
2c60 c3 f2 1f			jp macro_next 
2c63				endm 
# End of macro NEXTW
2c63			 
2c63			.INC: 
2c63				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c63 6f				db WORD_SYS_CORE+91             
2c64 b7 2c			dw .DEC            
2c66 03				db 2 + 1 
2c67 .. 00			db "+!",0              
2c6a				endm 
# End of macro CWHEAD
2c6a			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c6a					if DEBUG_FORTH_WORDS_KEY 
2c6a						DMARK "+s_" 
2c6a f5				push af  
2c6b 3a 7f 2c			ld a, (.dmark)  
2c6e 32 6b ee			ld (debug_mark),a  
2c71 3a 80 2c			ld a, (.dmark+1)  
2c74 32 6c ee			ld (debug_mark+1),a  
2c77 3a 81 2c			ld a, (.dmark+2)  
2c7a 32 6d ee			ld (debug_mark+2),a  
2c7d 18 03			jr .pastdmark  
2c7f ..			.dmark: db "+s_"  
2c82 f1			.pastdmark: pop af  
2c83			endm  
# End of macro DMARK
2c83						CALLMONITOR 
2c83 cd 6f ee			call debug_vector  
2c86				endm  
# End of macro CALLMONITOR
2c86					endif 
2c86			 
2c86					FORTH_DSP_VALUEHL 
2c86 cd 3c 1e			call macro_dsp_valuehl 
2c89				endm 
# End of macro FORTH_DSP_VALUEHL
2c89			 
2c89 e5					push hl   ; save address 
2c8a			 
2c8a					FORTH_DSP_POP 
2c8a cd f4 1e			call macro_forth_dsp_pop 
2c8d				endm 
# End of macro FORTH_DSP_POP
2c8d			 
2c8d					FORTH_DSP_VALUEHL 
2c8d cd 3c 1e			call macro_dsp_valuehl 
2c90				endm 
# End of macro FORTH_DSP_VALUEHL
2c90			 
2c90					FORTH_DSP_POP 
2c90 cd f4 1e			call macro_forth_dsp_pop 
2c93				endm 
# End of macro FORTH_DSP_POP
2c93			 
2c93					; hl contains value to add to byte at a 
2c93				 
2c93 eb					ex de, hl 
2c94			 
2c94 e1					pop hl 
2c95			 
2c95					if DEBUG_FORTH_WORDS 
2c95						DMARK "INC" 
2c95 f5				push af  
2c96 3a aa 2c			ld a, (.dmark)  
2c99 32 6b ee			ld (debug_mark),a  
2c9c 3a ab 2c			ld a, (.dmark+1)  
2c9f 32 6c ee			ld (debug_mark+1),a  
2ca2 3a ac 2c			ld a, (.dmark+2)  
2ca5 32 6d ee			ld (debug_mark+2),a  
2ca8 18 03			jr .pastdmark  
2caa ..			.dmark: db "INC"  
2cad f1			.pastdmark: pop af  
2cae			endm  
# End of macro DMARK
2cae						CALLMONITOR 
2cae cd 6f ee			call debug_vector  
2cb1				endm  
# End of macro CALLMONITOR
2cb1					endif 
2cb1			 
2cb1 7e					ld a,(hl) 
2cb2 83					add e 
2cb3 77					ld (hl),a 
2cb4			 
2cb4			 
2cb4			 
2cb4				       NEXTW 
2cb4 c3 f2 1f			jp macro_next 
2cb7				endm 
# End of macro NEXTW
2cb7			 
2cb7			.DEC: 
2cb7				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cb7 6f				db WORD_SYS_CORE+91             
2cb8 08 2d			dw .INC2            
2cba 03				db 2 + 1 
2cbb .. 00			db "-!",0              
2cbe				endm 
# End of macro CWHEAD
2cbe			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2cbe					if DEBUG_FORTH_WORDS_KEY 
2cbe						DMARK "-s_" 
2cbe f5				push af  
2cbf 3a d3 2c			ld a, (.dmark)  
2cc2 32 6b ee			ld (debug_mark),a  
2cc5 3a d4 2c			ld a, (.dmark+1)  
2cc8 32 6c ee			ld (debug_mark+1),a  
2ccb 3a d5 2c			ld a, (.dmark+2)  
2cce 32 6d ee			ld (debug_mark+2),a  
2cd1 18 03			jr .pastdmark  
2cd3 ..			.dmark: db "-s_"  
2cd6 f1			.pastdmark: pop af  
2cd7			endm  
# End of macro DMARK
2cd7						CALLMONITOR 
2cd7 cd 6f ee			call debug_vector  
2cda				endm  
# End of macro CALLMONITOR
2cda					endif 
2cda			 
2cda					FORTH_DSP_VALUEHL 
2cda cd 3c 1e			call macro_dsp_valuehl 
2cdd				endm 
# End of macro FORTH_DSP_VALUEHL
2cdd			 
2cdd e5					push hl   ; save address 
2cde			 
2cde					FORTH_DSP_POP 
2cde cd f4 1e			call macro_forth_dsp_pop 
2ce1				endm 
# End of macro FORTH_DSP_POP
2ce1			 
2ce1					FORTH_DSP_VALUEHL 
2ce1 cd 3c 1e			call macro_dsp_valuehl 
2ce4				endm 
# End of macro FORTH_DSP_VALUEHL
2ce4			 
2ce4					; hl contains value to add to byte at a 
2ce4				 
2ce4 eb					ex de, hl 
2ce5			 
2ce5 e1					pop hl 
2ce6			 
2ce6					if DEBUG_FORTH_WORDS 
2ce6						DMARK "DEC" 
2ce6 f5				push af  
2ce7 3a fb 2c			ld a, (.dmark)  
2cea 32 6b ee			ld (debug_mark),a  
2ced 3a fc 2c			ld a, (.dmark+1)  
2cf0 32 6c ee			ld (debug_mark+1),a  
2cf3 3a fd 2c			ld a, (.dmark+2)  
2cf6 32 6d ee			ld (debug_mark+2),a  
2cf9 18 03			jr .pastdmark  
2cfb ..			.dmark: db "DEC"  
2cfe f1			.pastdmark: pop af  
2cff			endm  
# End of macro DMARK
2cff						CALLMONITOR 
2cff cd 6f ee			call debug_vector  
2d02				endm  
# End of macro CALLMONITOR
2d02					endif 
2d02			 
2d02 7e					ld a,(hl) 
2d03 93					sub e 
2d04 77					ld (hl),a 
2d05			 
2d05			 
2d05			 
2d05				       NEXTW 
2d05 c3 f2 1f			jp macro_next 
2d08				endm 
# End of macro NEXTW
2d08			 
2d08			.INC2: 
2d08				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d08 6f				db WORD_SYS_CORE+91             
2d09 b2 2d			dw .DEC2            
2d0b 04				db 3 + 1 
2d0c .. 00			db "+2!",0              
2d10				endm 
# End of macro CWHEAD
2d10			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d10			 
2d10					if DEBUG_FORTH_WORDS_KEY 
2d10						DMARK "+2s" 
2d10 f5				push af  
2d11 3a 25 2d			ld a, (.dmark)  
2d14 32 6b ee			ld (debug_mark),a  
2d17 3a 26 2d			ld a, (.dmark+1)  
2d1a 32 6c ee			ld (debug_mark+1),a  
2d1d 3a 27 2d			ld a, (.dmark+2)  
2d20 32 6d ee			ld (debug_mark+2),a  
2d23 18 03			jr .pastdmark  
2d25 ..			.dmark: db "+2s"  
2d28 f1			.pastdmark: pop af  
2d29			endm  
# End of macro DMARK
2d29						CALLMONITOR 
2d29 cd 6f ee			call debug_vector  
2d2c				endm  
# End of macro CALLMONITOR
2d2c					endif 
2d2c			 
2d2c					; Address 
2d2c			 
2d2c					FORTH_DSP_VALUEHL 
2d2c cd 3c 1e			call macro_dsp_valuehl 
2d2f				endm 
# End of macro FORTH_DSP_VALUEHL
2d2f			 
2d2f e5					push hl    ; save address 
2d30			 
2d30					; load content into de 
2d30			 
2d30 5e					ld e,(hl) 
2d31 23					inc hl 
2d32 56					ld d, (hl) 
2d33			 
2d33					if DEBUG_FORTH_WORDS 
2d33						DMARK "+2a" 
2d33 f5				push af  
2d34 3a 48 2d			ld a, (.dmark)  
2d37 32 6b ee			ld (debug_mark),a  
2d3a 3a 49 2d			ld a, (.dmark+1)  
2d3d 32 6c ee			ld (debug_mark+1),a  
2d40 3a 4a 2d			ld a, (.dmark+2)  
2d43 32 6d ee			ld (debug_mark+2),a  
2d46 18 03			jr .pastdmark  
2d48 ..			.dmark: db "+2a"  
2d4b f1			.pastdmark: pop af  
2d4c			endm  
# End of macro DMARK
2d4c						CALLMONITOR 
2d4c cd 6f ee			call debug_vector  
2d4f				endm  
# End of macro CALLMONITOR
2d4f					endif 
2d4f			 
2d4f					FORTH_DSP_POP 
2d4f cd f4 1e			call macro_forth_dsp_pop 
2d52				endm 
# End of macro FORTH_DSP_POP
2d52			 
2d52					; Get value to add 
2d52			 
2d52					FORTH_DSP_VALUE 
2d52 cd 25 1e			call macro_forth_dsp_value 
2d55				endm 
# End of macro FORTH_DSP_VALUE
2d55			 
2d55					if DEBUG_FORTH_WORDS 
2d55						DMARK "+2v" 
2d55 f5				push af  
2d56 3a 6a 2d			ld a, (.dmark)  
2d59 32 6b ee			ld (debug_mark),a  
2d5c 3a 6b 2d			ld a, (.dmark+1)  
2d5f 32 6c ee			ld (debug_mark+1),a  
2d62 3a 6c 2d			ld a, (.dmark+2)  
2d65 32 6d ee			ld (debug_mark+2),a  
2d68 18 03			jr .pastdmark  
2d6a ..			.dmark: db "+2v"  
2d6d f1			.pastdmark: pop af  
2d6e			endm  
# End of macro DMARK
2d6e						CALLMONITOR 
2d6e cd 6f ee			call debug_vector  
2d71				endm  
# End of macro CALLMONITOR
2d71					endif 
2d71			 
2d71 19					add hl, de 
2d72			 
2d72					if DEBUG_FORTH_WORDS 
2d72						DMARK "+2+" 
2d72 f5				push af  
2d73 3a 87 2d			ld a, (.dmark)  
2d76 32 6b ee			ld (debug_mark),a  
2d79 3a 88 2d			ld a, (.dmark+1)  
2d7c 32 6c ee			ld (debug_mark+1),a  
2d7f 3a 89 2d			ld a, (.dmark+2)  
2d82 32 6d ee			ld (debug_mark+2),a  
2d85 18 03			jr .pastdmark  
2d87 ..			.dmark: db "+2+"  
2d8a f1			.pastdmark: pop af  
2d8b			endm  
# End of macro DMARK
2d8b						CALLMONITOR 
2d8b cd 6f ee			call debug_vector  
2d8e				endm  
# End of macro CALLMONITOR
2d8e					endif 
2d8e			 
2d8e					; move result to de 
2d8e			 
2d8e eb					ex de, hl 
2d8f			 
2d8f					; Address 
2d8f			 
2d8f e1					pop hl 
2d90			 
2d90					; save it back 
2d90			 
2d90 73					ld (hl), e 
2d91 23					inc hl 
2d92 72					ld (hl), d 
2d93			 
2d93					if DEBUG_FORTH_WORDS 
2d93						DMARK "+2e" 
2d93 f5				push af  
2d94 3a a8 2d			ld a, (.dmark)  
2d97 32 6b ee			ld (debug_mark),a  
2d9a 3a a9 2d			ld a, (.dmark+1)  
2d9d 32 6c ee			ld (debug_mark+1),a  
2da0 3a aa 2d			ld a, (.dmark+2)  
2da3 32 6d ee			ld (debug_mark+2),a  
2da6 18 03			jr .pastdmark  
2da8 ..			.dmark: db "+2e"  
2dab f1			.pastdmark: pop af  
2dac			endm  
# End of macro DMARK
2dac						CALLMONITOR 
2dac cd 6f ee			call debug_vector  
2daf				endm  
# End of macro CALLMONITOR
2daf					endif 
2daf			 
2daf			 
2daf			 
2daf			 
2daf			 
2daf				       NEXTW 
2daf c3 f2 1f			jp macro_next 
2db2				endm 
# End of macro NEXTW
2db2			 
2db2			.DEC2: 
2db2				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2db2 6f				db WORD_SYS_CORE+91             
2db3 5e 2e			dw .GET2            
2db5 04				db 3 + 1 
2db6 .. 00			db "-2!",0              
2dba				endm 
# End of macro CWHEAD
2dba			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dba			 
2dba			 
2dba					if DEBUG_FORTH_WORDS_KEY 
2dba						DMARK "-2s" 
2dba f5				push af  
2dbb 3a cf 2d			ld a, (.dmark)  
2dbe 32 6b ee			ld (debug_mark),a  
2dc1 3a d0 2d			ld a, (.dmark+1)  
2dc4 32 6c ee			ld (debug_mark+1),a  
2dc7 3a d1 2d			ld a, (.dmark+2)  
2dca 32 6d ee			ld (debug_mark+2),a  
2dcd 18 03			jr .pastdmark  
2dcf ..			.dmark: db "-2s"  
2dd2 f1			.pastdmark: pop af  
2dd3			endm  
# End of macro DMARK
2dd3						CALLMONITOR 
2dd3 cd 6f ee			call debug_vector  
2dd6				endm  
# End of macro CALLMONITOR
2dd6					endif 
2dd6			 
2dd6					; Address 
2dd6			 
2dd6					FORTH_DSP_VALUEHL 
2dd6 cd 3c 1e			call macro_dsp_valuehl 
2dd9				endm 
# End of macro FORTH_DSP_VALUEHL
2dd9			 
2dd9 e5					push hl    ; save address 
2dda			 
2dda					; load content into de 
2dda			 
2dda 5e					ld e,(hl) 
2ddb 23					inc hl 
2ddc 56					ld d, (hl) 
2ddd			 
2ddd					if DEBUG_FORTH_WORDS 
2ddd						DMARK "-2a" 
2ddd f5				push af  
2dde 3a f2 2d			ld a, (.dmark)  
2de1 32 6b ee			ld (debug_mark),a  
2de4 3a f3 2d			ld a, (.dmark+1)  
2de7 32 6c ee			ld (debug_mark+1),a  
2dea 3a f4 2d			ld a, (.dmark+2)  
2ded 32 6d ee			ld (debug_mark+2),a  
2df0 18 03			jr .pastdmark  
2df2 ..			.dmark: db "-2a"  
2df5 f1			.pastdmark: pop af  
2df6			endm  
# End of macro DMARK
2df6						CALLMONITOR 
2df6 cd 6f ee			call debug_vector  
2df9				endm  
# End of macro CALLMONITOR
2df9					endif 
2df9			 
2df9					FORTH_DSP_POP 
2df9 cd f4 1e			call macro_forth_dsp_pop 
2dfc				endm 
# End of macro FORTH_DSP_POP
2dfc			 
2dfc					; Get value to remove 
2dfc			 
2dfc					FORTH_DSP_VALUE 
2dfc cd 25 1e			call macro_forth_dsp_value 
2dff				endm 
# End of macro FORTH_DSP_VALUE
2dff			 
2dff					if DEBUG_FORTH_WORDS 
2dff						DMARK "-2v" 
2dff f5				push af  
2e00 3a 14 2e			ld a, (.dmark)  
2e03 32 6b ee			ld (debug_mark),a  
2e06 3a 15 2e			ld a, (.dmark+1)  
2e09 32 6c ee			ld (debug_mark+1),a  
2e0c 3a 16 2e			ld a, (.dmark+2)  
2e0f 32 6d ee			ld (debug_mark+2),a  
2e12 18 03			jr .pastdmark  
2e14 ..			.dmark: db "-2v"  
2e17 f1			.pastdmark: pop af  
2e18			endm  
# End of macro DMARK
2e18						CALLMONITOR 
2e18 cd 6f ee			call debug_vector  
2e1b				endm  
# End of macro CALLMONITOR
2e1b					endif 
2e1b			 
2e1b eb					ex de, hl 
2e1c ed 52				sbc hl, de 
2e1e			 
2e1e					if DEBUG_FORTH_WORDS 
2e1e						DMARK "-2d" 
2e1e f5				push af  
2e1f 3a 33 2e			ld a, (.dmark)  
2e22 32 6b ee			ld (debug_mark),a  
2e25 3a 34 2e			ld a, (.dmark+1)  
2e28 32 6c ee			ld (debug_mark+1),a  
2e2b 3a 35 2e			ld a, (.dmark+2)  
2e2e 32 6d ee			ld (debug_mark+2),a  
2e31 18 03			jr .pastdmark  
2e33 ..			.dmark: db "-2d"  
2e36 f1			.pastdmark: pop af  
2e37			endm  
# End of macro DMARK
2e37						CALLMONITOR 
2e37 cd 6f ee			call debug_vector  
2e3a				endm  
# End of macro CALLMONITOR
2e3a					endif 
2e3a			 
2e3a					; move result to de 
2e3a			 
2e3a eb					ex de, hl 
2e3b			 
2e3b					; Address 
2e3b			 
2e3b e1					pop hl 
2e3c			 
2e3c					; save it back 
2e3c			 
2e3c 73					ld (hl), e 
2e3d 23					inc hl 
2e3e 72					ld (hl), d 
2e3f			 
2e3f					if DEBUG_FORTH_WORDS 
2e3f						DMARK "-2e" 
2e3f f5				push af  
2e40 3a 54 2e			ld a, (.dmark)  
2e43 32 6b ee			ld (debug_mark),a  
2e46 3a 55 2e			ld a, (.dmark+1)  
2e49 32 6c ee			ld (debug_mark+1),a  
2e4c 3a 56 2e			ld a, (.dmark+2)  
2e4f 32 6d ee			ld (debug_mark+2),a  
2e52 18 03			jr .pastdmark  
2e54 ..			.dmark: db "-2e"  
2e57 f1			.pastdmark: pop af  
2e58			endm  
# End of macro DMARK
2e58						CALLMONITOR 
2e58 cd 6f ee			call debug_vector  
2e5b				endm  
# End of macro CALLMONITOR
2e5b					endif 
2e5b			 
2e5b			 
2e5b			 
2e5b			 
2e5b			 
2e5b				       NEXTW 
2e5b c3 f2 1f			jp macro_next 
2e5e				endm 
# End of macro NEXTW
2e5e			.GET2: 
2e5e				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e5e 6f				db WORD_SYS_CORE+91             
2e5f 8e 2e			dw .BANG2            
2e61 03				db 2 + 1 
2e62 .. 00			db "2@",0              
2e65				endm 
# End of macro CWHEAD
2e65			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e65					if DEBUG_FORTH_WORDS_KEY 
2e65						DMARK "2A_" 
2e65 f5				push af  
2e66 3a 7a 2e			ld a, (.dmark)  
2e69 32 6b ee			ld (debug_mark),a  
2e6c 3a 7b 2e			ld a, (.dmark+1)  
2e6f 32 6c ee			ld (debug_mark+1),a  
2e72 3a 7c 2e			ld a, (.dmark+2)  
2e75 32 6d ee			ld (debug_mark+2),a  
2e78 18 03			jr .pastdmark  
2e7a ..			.dmark: db "2A_"  
2e7d f1			.pastdmark: pop af  
2e7e			endm  
# End of macro DMARK
2e7e						CALLMONITOR 
2e7e cd 6f ee			call debug_vector  
2e81				endm  
# End of macro CALLMONITOR
2e81					endif 
2e81			 
2e81					FORTH_DSP_VALUEHL 
2e81 cd 3c 1e			call macro_dsp_valuehl 
2e84				endm 
# End of macro FORTH_DSP_VALUEHL
2e84			 
2e84 5e					ld e, (hl) 
2e85 23					inc hl 
2e86 56					ld d, (hl) 
2e87			 
2e87 eb					ex de, hl 
2e88			 
2e88 cd 45 1c				call forth_push_numhl 
2e8b			 
2e8b				       NEXTW 
2e8b c3 f2 1f			jp macro_next 
2e8e				endm 
# End of macro NEXTW
2e8e			.BANG2: 
2e8e				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e8e 6f				db WORD_SYS_CORE+91             
2e8f c6 2e			dw .CONFIG            
2e91 03				db 2 + 1 
2e92 .. 00			db "2!",0              
2e95				endm 
# End of macro CWHEAD
2e95			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2e95					if DEBUG_FORTH_WORDS_KEY 
2e95						DMARK "2S_" 
2e95 f5				push af  
2e96 3a aa 2e			ld a, (.dmark)  
2e99 32 6b ee			ld (debug_mark),a  
2e9c 3a ab 2e			ld a, (.dmark+1)  
2e9f 32 6c ee			ld (debug_mark+1),a  
2ea2 3a ac 2e			ld a, (.dmark+2)  
2ea5 32 6d ee			ld (debug_mark+2),a  
2ea8 18 03			jr .pastdmark  
2eaa ..			.dmark: db "2S_"  
2ead f1			.pastdmark: pop af  
2eae			endm  
# End of macro DMARK
2eae						CALLMONITOR 
2eae cd 6f ee			call debug_vector  
2eb1				endm  
# End of macro CALLMONITOR
2eb1					endif 
2eb1			 
2eb1					FORTH_DSP_VALUEHL 
2eb1 cd 3c 1e			call macro_dsp_valuehl 
2eb4				endm 
# End of macro FORTH_DSP_VALUEHL
2eb4			 
2eb4 e5					push hl   ; save address 
2eb5			 
2eb5			 
2eb5					FORTH_DSP_POP 
2eb5 cd f4 1e			call macro_forth_dsp_pop 
2eb8				endm 
# End of macro FORTH_DSP_POP
2eb8			 
2eb8					 
2eb8					FORTH_DSP_VALUEHL 
2eb8 cd 3c 1e			call macro_dsp_valuehl 
2ebb				endm 
# End of macro FORTH_DSP_VALUEHL
2ebb			 
2ebb					FORTH_DSP_POP 
2ebb cd f4 1e			call macro_forth_dsp_pop 
2ebe				endm 
# End of macro FORTH_DSP_POP
2ebe			 
2ebe eb					ex de, hl    ; value now in de 
2ebf			 
2ebf e1					pop hl 
2ec0			 
2ec0 73					ld (hl), e 
2ec1			 
2ec1 23					inc hl 
2ec2			 
2ec2 72					ld (hl), d 
2ec3			 
2ec3			 
2ec3				       NEXTW 
2ec3 c3 f2 1f			jp macro_next 
2ec6				endm 
# End of macro NEXTW
2ec6			.CONFIG: 
2ec6				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2ec6 6f				db WORD_SYS_CORE+91             
2ec7 d7 2e			dw .ADTOS            
2ec9 07				db 6 + 1 
2eca .. 00			db "CONFIG",0              
2ed1				endm 
# End of macro CWHEAD
2ed1			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ed1			 
2ed1 cd 47 14				call config 
2ed4					NEXTW 
2ed4 c3 f2 1f			jp macro_next 
2ed7				endm 
# End of macro NEXTW
2ed7			 
2ed7			.ADTOS: 
2ed7				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2ed7 6f				db WORD_SYS_CORE+91             
2ed8 ed 2e			dw .SBTOS            
2eda 03				db 2 + 1 
2edb .. 00			db "1+",0              
2ede				endm 
# End of macro CWHEAD
2ede			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2ede			 
2ede					FORTH_DSP_VALUEHL 
2ede cd 3c 1e			call macro_dsp_valuehl 
2ee1				endm 
# End of macro FORTH_DSP_VALUEHL
2ee1 e5					push hl 
2ee2			 
2ee2					FORTH_DSP_POP 
2ee2 cd f4 1e			call macro_forth_dsp_pop 
2ee5				endm 
# End of macro FORTH_DSP_POP
2ee5 e1					pop hl 
2ee6			 
2ee6 23					inc hl 
2ee7 cd 45 1c				call forth_push_numhl 
2eea					 
2eea					NEXTW 
2eea c3 f2 1f			jp macro_next 
2eed				endm 
# End of macro NEXTW
2eed			.SBTOS: 
2eed				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2eed 6f				db WORD_SYS_CORE+91             
2eee 03 2f			dw .ADSTORE            
2ef0 03				db 2 + 1 
2ef1 .. 00			db "1-",0              
2ef4				endm 
# End of macro CWHEAD
2ef4			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2ef4			 
2ef4					FORTH_DSP_VALUEHL 
2ef4 cd 3c 1e			call macro_dsp_valuehl 
2ef7				endm 
# End of macro FORTH_DSP_VALUEHL
2ef7 e5					push hl 
2ef8			 
2ef8					FORTH_DSP_POP 
2ef8 cd f4 1e			call macro_forth_dsp_pop 
2efb				endm 
# End of macro FORTH_DSP_POP
2efb e1					pop hl 
2efc			 
2efc 2b					dec hl 
2efd cd 45 1c				call forth_push_numhl 
2f00					 
2f00					NEXTW 
2f00 c3 f2 1f			jp macro_next 
2f03				endm 
# End of macro NEXTW
2f03			.ADSTORE: 
2f03				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2f03 6f				db WORD_SYS_CORE+91             
2f04 19 2f			dw .ADWSTORE            
2f06 04				db 3 + 1 
2f07 .. 00			db "1+!",0              
2f0b				endm 
# End of macro CWHEAD
2f0b			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2f0b			 
2f0b					FORTH_DSP_VALUEHL 
2f0b cd 3c 1e			call macro_dsp_valuehl 
2f0e				endm 
# End of macro FORTH_DSP_VALUEHL
2f0e e5					push hl 
2f0f			 
2f0f					FORTH_DSP_POP 
2f0f cd f4 1e			call macro_forth_dsp_pop 
2f12				endm 
# End of macro FORTH_DSP_POP
2f12 e1					pop hl 
2f13			 
2f13 7e					ld a, (hl) 
2f14 3c					inc a 
2f15 77					ld (hl), a 
2f16					 
2f16					NEXTW 
2f16 c3 f2 1f			jp macro_next 
2f19				endm 
# End of macro NEXTW
2f19			.ADWSTORE: 
2f19				CWHEAD .ENDCORE 91 "1+2!" 4 WORD_FLAG_CODE 
2f19 6f				db WORD_SYS_CORE+91             
2f1a 37 2f			dw .ENDCORE            
2f1c 05				db 4 + 1 
2f1d .. 00			db "1+2!",0              
2f22				endm 
# End of macro CWHEAD
2f22			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2f22			 
2f22					FORTH_DSP_VALUEHL 
2f22 cd 3c 1e			call macro_dsp_valuehl 
2f25				endm 
# End of macro FORTH_DSP_VALUEHL
2f25 e5					push hl 
2f26			 
2f26					FORTH_DSP_POP 
2f26 cd f4 1e			call macro_forth_dsp_pop 
2f29				endm 
# End of macro FORTH_DSP_POP
2f29 e1					pop hl 
2f2a			 
2f2a e5					push hl 
2f2b			 
2f2b cd 74 1f				call loadwordinhl 
2f2e 23					inc hl 
2f2f			 
2f2f d1					pop de 
2f30 eb					ex de, hl 
2f31 73					ld (hl), e 
2f32 23					inc hl 
2f33 72					ld (hl), d 
2f34					 
2f34					NEXTW 
2f34 c3 f2 1f			jp macro_next 
2f37				endm 
# End of macro NEXTW
2f37			.ENDCORE: 
2f37			 
2f37			; eof 
2f37			 
2f37			 
# End of file forth_words_core.asm
2f37			include "forth_words_flow.asm" 
2f37			 
2f37			; | ## Program Flow Words 
2f37			 
2f37			.IF: 
2f37				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f37 1e				db WORD_SYS_CORE+10             
2f38 2c 30			dw .THEN            
2f3a 03				db 2 + 1 
2f3b .. 00			db "IF",0              
2f3e				endm 
# End of macro CWHEAD
2f3e			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f3e			; 
2f3e					if DEBUG_FORTH_WORDS_KEY 
2f3e						DMARK "IF." 
2f3e f5				push af  
2f3f 3a 53 2f			ld a, (.dmark)  
2f42 32 6b ee			ld (debug_mark),a  
2f45 3a 54 2f			ld a, (.dmark+1)  
2f48 32 6c ee			ld (debug_mark+1),a  
2f4b 3a 55 2f			ld a, (.dmark+2)  
2f4e 32 6d ee			ld (debug_mark+2),a  
2f51 18 03			jr .pastdmark  
2f53 ..			.dmark: db "IF."  
2f56 f1			.pastdmark: pop af  
2f57			endm  
# End of macro DMARK
2f57						CALLMONITOR 
2f57 cd 6f ee			call debug_vector  
2f5a				endm  
# End of macro CALLMONITOR
2f5a					endif 
2f5a			; eval TOS 
2f5a			 
2f5a				FORTH_DSP_VALUEHL 
2f5a cd 3c 1e			call macro_dsp_valuehl 
2f5d				endm 
# End of macro FORTH_DSP_VALUEHL
2f5d			 
2f5d			;	push hl 
2f5d				FORTH_DSP_POP 
2f5d cd f4 1e			call macro_forth_dsp_pop 
2f60				endm 
# End of macro FORTH_DSP_POP
2f60			;	pop hl 
2f60			 
2f60					if DEBUG_FORTH_WORDS 
2f60						DMARK "IF1" 
2f60 f5				push af  
2f61 3a 75 2f			ld a, (.dmark)  
2f64 32 6b ee			ld (debug_mark),a  
2f67 3a 76 2f			ld a, (.dmark+1)  
2f6a 32 6c ee			ld (debug_mark+1),a  
2f6d 3a 77 2f			ld a, (.dmark+2)  
2f70 32 6d ee			ld (debug_mark+2),a  
2f73 18 03			jr .pastdmark  
2f75 ..			.dmark: db "IF1"  
2f78 f1			.pastdmark: pop af  
2f79			endm  
# End of macro DMARK
2f79						CALLMONITOR 
2f79 cd 6f ee			call debug_vector  
2f7c				endm  
# End of macro CALLMONITOR
2f7c					endif 
2f7c b7				or a        ; clear carry flag 
2f7d 11 00 00			ld de, 0 
2f80 eb				ex de,hl 
2f81 ed 52			sbc hl, de 
2f83 c2 0d 30			jp nz, .iftrue 
2f86			 
2f86					if DEBUG_FORTH_WORDS 
2f86						DMARK "IF2" 
2f86 f5				push af  
2f87 3a 9b 2f			ld a, (.dmark)  
2f8a 32 6b ee			ld (debug_mark),a  
2f8d 3a 9c 2f			ld a, (.dmark+1)  
2f90 32 6c ee			ld (debug_mark+1),a  
2f93 3a 9d 2f			ld a, (.dmark+2)  
2f96 32 6d ee			ld (debug_mark+2),a  
2f99 18 03			jr .pastdmark  
2f9b ..			.dmark: db "IF2"  
2f9e f1			.pastdmark: pop af  
2f9f			endm  
# End of macro DMARK
2f9f						CALLMONITOR 
2f9f cd 6f ee			call debug_vector  
2fa2				endm  
# End of macro CALLMONITOR
2fa2					endif 
2fa2			 
2fa2			; if not true then skip to THEN 
2fa2			 
2fa2				; TODO get tok_ptr 
2fa2				; TODO consume toks until we get to THEN 
2fa2			 
2fa2 2a c2 e5			ld hl, (os_tok_ptr) 
2fa5					if DEBUG_FORTH_WORDS 
2fa5						DMARK "IF3" 
2fa5 f5				push af  
2fa6 3a ba 2f			ld a, (.dmark)  
2fa9 32 6b ee			ld (debug_mark),a  
2fac 3a bb 2f			ld a, (.dmark+1)  
2faf 32 6c ee			ld (debug_mark+1),a  
2fb2 3a bc 2f			ld a, (.dmark+2)  
2fb5 32 6d ee			ld (debug_mark+2),a  
2fb8 18 03			jr .pastdmark  
2fba ..			.dmark: db "IF3"  
2fbd f1			.pastdmark: pop af  
2fbe			endm  
# End of macro DMARK
2fbe						CALLMONITOR 
2fbe cd 6f ee			call debug_vector  
2fc1				endm  
# End of macro CALLMONITOR
2fc1						 
2fc1					endif 
2fc1 11 08 30			ld de, .ifthen 
2fc4					if DEBUG_FORTH_WORDS 
2fc4						DMARK "IF4" 
2fc4 f5				push af  
2fc5 3a d9 2f			ld a, (.dmark)  
2fc8 32 6b ee			ld (debug_mark),a  
2fcb 3a da 2f			ld a, (.dmark+1)  
2fce 32 6c ee			ld (debug_mark+1),a  
2fd1 3a db 2f			ld a, (.dmark+2)  
2fd4 32 6d ee			ld (debug_mark+2),a  
2fd7 18 03			jr .pastdmark  
2fd9 ..			.dmark: db "IF4"  
2fdc f1			.pastdmark: pop af  
2fdd			endm  
# End of macro DMARK
2fdd						CALLMONITOR 
2fdd cd 6f ee			call debug_vector  
2fe0				endm  
# End of macro CALLMONITOR
2fe0					endif 
2fe0 cd 0d 21			call findnexttok  
2fe3			 
2fe3					if DEBUG_FORTH_WORDS 
2fe3						DMARK "IF5" 
2fe3 f5				push af  
2fe4 3a f8 2f			ld a, (.dmark)  
2fe7 32 6b ee			ld (debug_mark),a  
2fea 3a f9 2f			ld a, (.dmark+1)  
2fed 32 6c ee			ld (debug_mark+1),a  
2ff0 3a fa 2f			ld a, (.dmark+2)  
2ff3 32 6d ee			ld (debug_mark+2),a  
2ff6 18 03			jr .pastdmark  
2ff8 ..			.dmark: db "IF5"  
2ffb f1			.pastdmark: pop af  
2ffc			endm  
# End of macro DMARK
2ffc						CALLMONITOR 
2ffc cd 6f ee			call debug_vector  
2fff				endm  
# End of macro CALLMONITOR
2fff					endif 
2fff				; TODO replace below with ; exec using tok_ptr 
2fff 22 c2 e5			ld (os_tok_ptr), hl 
3002 c3 83 20			jp exec1 
3005				NEXTW 
3005 c3 f2 1f			jp macro_next 
3008				endm 
# End of macro NEXTW
3008			 
3008 .. 00		.ifthen:  db "THEN",0 
300d			 
300d			.iftrue:		 
300d				; Exec next words normally 
300d			 
300d				; if true then exec following IF as normal 
300d					if DEBUG_FORTH_WORDS 
300d						DMARK "IFT" 
300d f5				push af  
300e 3a 22 30			ld a, (.dmark)  
3011 32 6b ee			ld (debug_mark),a  
3014 3a 23 30			ld a, (.dmark+1)  
3017 32 6c ee			ld (debug_mark+1),a  
301a 3a 24 30			ld a, (.dmark+2)  
301d 32 6d ee			ld (debug_mark+2),a  
3020 18 03			jr .pastdmark  
3022 ..			.dmark: db "IFT"  
3025 f1			.pastdmark: pop af  
3026			endm  
# End of macro DMARK
3026						CALLMONITOR 
3026 cd 6f ee			call debug_vector  
3029				endm  
# End of macro CALLMONITOR
3029					endif 
3029			 
3029					NEXTW 
3029 c3 f2 1f			jp macro_next 
302c				endm 
# End of macro NEXTW
302c			.THEN: 
302c				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
302c 1f				db WORD_SYS_CORE+11             
302d 54 30			dw .ELSE            
302f 05				db 4 + 1 
3030 .. 00			db "THEN",0              
3035				endm 
# End of macro CWHEAD
3035			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3035					if DEBUG_FORTH_WORDS_KEY 
3035						DMARK "THN" 
3035 f5				push af  
3036 3a 4a 30			ld a, (.dmark)  
3039 32 6b ee			ld (debug_mark),a  
303c 3a 4b 30			ld a, (.dmark+1)  
303f 32 6c ee			ld (debug_mark+1),a  
3042 3a 4c 30			ld a, (.dmark+2)  
3045 32 6d ee			ld (debug_mark+2),a  
3048 18 03			jr .pastdmark  
304a ..			.dmark: db "THN"  
304d f1			.pastdmark: pop af  
304e			endm  
# End of macro DMARK
304e						CALLMONITOR 
304e cd 6f ee			call debug_vector  
3051				endm  
# End of macro CALLMONITOR
3051					endif 
3051					NEXTW 
3051 c3 f2 1f			jp macro_next 
3054				endm 
# End of macro NEXTW
3054			.ELSE: 
3054				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3054 20				db WORD_SYS_CORE+12             
3055 7c 30			dw .DO            
3057 03				db 2 + 1 
3058 .. 00			db "ELSE",0              
305d				endm 
# End of macro CWHEAD
305d			; | ELSE ( -- ) Not supported - does nothing | TODO 
305d			 
305d					if DEBUG_FORTH_WORDS_KEY 
305d						DMARK "ELS" 
305d f5				push af  
305e 3a 72 30			ld a, (.dmark)  
3061 32 6b ee			ld (debug_mark),a  
3064 3a 73 30			ld a, (.dmark+1)  
3067 32 6c ee			ld (debug_mark+1),a  
306a 3a 74 30			ld a, (.dmark+2)  
306d 32 6d ee			ld (debug_mark+2),a  
3070 18 03			jr .pastdmark  
3072 ..			.dmark: db "ELS"  
3075 f1			.pastdmark: pop af  
3076			endm  
# End of macro DMARK
3076						CALLMONITOR 
3076 cd 6f ee			call debug_vector  
3079				endm  
# End of macro CALLMONITOR
3079					endif 
3079			 
3079			 
3079					NEXTW 
3079 c3 f2 1f			jp macro_next 
307c				endm 
# End of macro NEXTW
307c			.DO: 
307c				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
307c 21				db WORD_SYS_CORE+13             
307d a3 31			dw .LOOP            
307f 03				db 2 + 1 
3080 .. 00			db "DO",0              
3083				endm 
# End of macro CWHEAD
3083			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3083			 
3083					if DEBUG_FORTH_WORDS_KEY 
3083						DMARK "DO." 
3083 f5				push af  
3084 3a 98 30			ld a, (.dmark)  
3087 32 6b ee			ld (debug_mark),a  
308a 3a 99 30			ld a, (.dmark+1)  
308d 32 6c ee			ld (debug_mark+1),a  
3090 3a 9a 30			ld a, (.dmark+2)  
3093 32 6d ee			ld (debug_mark+2),a  
3096 18 03			jr .pastdmark  
3098 ..			.dmark: db "DO."  
309b f1			.pastdmark: pop af  
309c			endm  
# End of macro DMARK
309c						CALLMONITOR 
309c cd 6f ee			call debug_vector  
309f				endm  
# End of macro CALLMONITOR
309f					endif 
309f			;  push pc to rsp stack past the DO 
309f			 
309f 2a c2 e5				ld hl, (os_tok_ptr) 
30a2 23					inc hl   ; D 
30a3 23					inc hl  ; O 
30a4 23					inc hl   ; null 
30a5					if DEBUG_FORTH_WORDS 
30a5						DMARK "DO2" 
30a5 f5				push af  
30a6 3a ba 30			ld a, (.dmark)  
30a9 32 6b ee			ld (debug_mark),a  
30ac 3a bb 30			ld a, (.dmark+1)  
30af 32 6c ee			ld (debug_mark+1),a  
30b2 3a bc 30			ld a, (.dmark+2)  
30b5 32 6d ee			ld (debug_mark+2),a  
30b8 18 03			jr .pastdmark  
30ba ..			.dmark: db "DO2"  
30bd f1			.pastdmark: pop af  
30be			endm  
# End of macro DMARK
30be						CALLMONITOR 
30be cd 6f ee			call debug_vector  
30c1				endm  
# End of macro CALLMONITOR
30c1					endif 
30c1					FORTH_RSP_NEXT 
30c1 cd ec 1b			call macro_forth_rsp_next 
30c4				endm 
# End of macro FORTH_RSP_NEXT
30c4					if DEBUG_FORTH_WORDS 
30c4						DMARK "DO3" 
30c4 f5				push af  
30c5 3a d9 30			ld a, (.dmark)  
30c8 32 6b ee			ld (debug_mark),a  
30cb 3a da 30			ld a, (.dmark+1)  
30ce 32 6c ee			ld (debug_mark+1),a  
30d1 3a db 30			ld a, (.dmark+2)  
30d4 32 6d ee			ld (debug_mark+2),a  
30d7 18 03			jr .pastdmark  
30d9 ..			.dmark: db "DO3"  
30dc f1			.pastdmark: pop af  
30dd			endm  
# End of macro DMARK
30dd						CALLMONITOR 
30dd cd 6f ee			call debug_vector  
30e0				endm  
# End of macro CALLMONITOR
30e0					endif 
30e0			 
30e0					;if DEBUG_FORTH_WORDS 
30e0				;		push hl 
30e0			;		endif  
30e0			 
30e0			; get counters from data stack 
30e0			 
30e0			 
30e0					FORTH_DSP_VALUEHL 
30e0 cd 3c 1e			call macro_dsp_valuehl 
30e3				endm 
# End of macro FORTH_DSP_VALUEHL
30e3 e5					push hl		 ; hl now has starting counter which needs to be tos 
30e4			 
30e4					if DEBUG_FORTH_WORDS 
30e4						DMARK "DO4" 
30e4 f5				push af  
30e5 3a f9 30			ld a, (.dmark)  
30e8 32 6b ee			ld (debug_mark),a  
30eb 3a fa 30			ld a, (.dmark+1)  
30ee 32 6c ee			ld (debug_mark+1),a  
30f1 3a fb 30			ld a, (.dmark+2)  
30f4 32 6d ee			ld (debug_mark+2),a  
30f7 18 03			jr .pastdmark  
30f9 ..			.dmark: db "DO4"  
30fc f1			.pastdmark: pop af  
30fd			endm  
# End of macro DMARK
30fd						CALLMONITOR 
30fd cd 6f ee			call debug_vector  
3100				endm  
# End of macro CALLMONITOR
3100					endif 
3100					FORTH_DSP_POP 
3100 cd f4 1e			call macro_forth_dsp_pop 
3103				endm 
# End of macro FORTH_DSP_POP
3103			 
3103					if DEBUG_FORTH_WORDS 
3103						DMARK "DO5" 
3103 f5				push af  
3104 3a 18 31			ld a, (.dmark)  
3107 32 6b ee			ld (debug_mark),a  
310a 3a 19 31			ld a, (.dmark+1)  
310d 32 6c ee			ld (debug_mark+1),a  
3110 3a 1a 31			ld a, (.dmark+2)  
3113 32 6d ee			ld (debug_mark+2),a  
3116 18 03			jr .pastdmark  
3118 ..			.dmark: db "DO5"  
311b f1			.pastdmark: pop af  
311c			endm  
# End of macro DMARK
311c						CALLMONITOR 
311c cd 6f ee			call debug_vector  
311f				endm  
# End of macro CALLMONITOR
311f					endif 
311f			 
311f					FORTH_DSP_VALUEHL 
311f cd 3c 1e			call macro_dsp_valuehl 
3122				endm 
# End of macro FORTH_DSP_VALUEHL
3122			;		push hl		 ; hl now has starting limit counter 
3122			 
3122					if DEBUG_FORTH_WORDS 
3122						DMARK "DO6" 
3122 f5				push af  
3123 3a 37 31			ld a, (.dmark)  
3126 32 6b ee			ld (debug_mark),a  
3129 3a 38 31			ld a, (.dmark+1)  
312c 32 6c ee			ld (debug_mark+1),a  
312f 3a 39 31			ld a, (.dmark+2)  
3132 32 6d ee			ld (debug_mark+2),a  
3135 18 03			jr .pastdmark  
3137 ..			.dmark: db "DO6"  
313a f1			.pastdmark: pop af  
313b			endm  
# End of macro DMARK
313b						CALLMONITOR 
313b cd 6f ee			call debug_vector  
313e				endm  
# End of macro CALLMONITOR
313e					endif 
313e					FORTH_DSP_POP 
313e cd f4 1e			call macro_forth_dsp_pop 
3141				endm 
# End of macro FORTH_DSP_POP
3141			 
3141			; put counters on the loop stack 
3141			 
3141			;		pop hl			 ; limit counter 
3141 d1					pop de			; start counter 
3142			 
3142					; push limit counter 
3142			 
3142					if DEBUG_FORTH_WORDS 
3142						DMARK "DO7" 
3142 f5				push af  
3143 3a 57 31			ld a, (.dmark)  
3146 32 6b ee			ld (debug_mark),a  
3149 3a 58 31			ld a, (.dmark+1)  
314c 32 6c ee			ld (debug_mark+1),a  
314f 3a 59 31			ld a, (.dmark+2)  
3152 32 6d ee			ld (debug_mark+2),a  
3155 18 03			jr .pastdmark  
3157 ..			.dmark: db "DO7"  
315a f1			.pastdmark: pop af  
315b			endm  
# End of macro DMARK
315b						CALLMONITOR 
315b cd 6f ee			call debug_vector  
315e				endm  
# End of macro CALLMONITOR
315e					endif 
315e					FORTH_LOOP_NEXT 
315e cd 6d 1e			call macro_forth_loop_next 
3161				endm 
# End of macro FORTH_LOOP_NEXT
3161			 
3161					; push start counter 
3161			 
3161 eb					ex de, hl 
3162					if DEBUG_FORTH_WORDS 
3162						DMARK "DO7" 
3162 f5				push af  
3163 3a 77 31			ld a, (.dmark)  
3166 32 6b ee			ld (debug_mark),a  
3169 3a 78 31			ld a, (.dmark+1)  
316c 32 6c ee			ld (debug_mark+1),a  
316f 3a 79 31			ld a, (.dmark+2)  
3172 32 6d ee			ld (debug_mark+2),a  
3175 18 03			jr .pastdmark  
3177 ..			.dmark: db "DO7"  
317a f1			.pastdmark: pop af  
317b			endm  
# End of macro DMARK
317b						CALLMONITOR 
317b cd 6f ee			call debug_vector  
317e				endm  
# End of macro CALLMONITOR
317e					endif 
317e					FORTH_LOOP_NEXT 
317e cd 6d 1e			call macro_forth_loop_next 
3181				endm 
# End of macro FORTH_LOOP_NEXT
3181			 
3181			 
3181					; init first round of I counter 
3181			 
3181 22 e6 e5				ld (os_current_i), hl 
3184			 
3184					if DEBUG_FORTH_WORDS 
3184						DMARK "DO8" 
3184 f5				push af  
3185 3a 99 31			ld a, (.dmark)  
3188 32 6b ee			ld (debug_mark),a  
318b 3a 9a 31			ld a, (.dmark+1)  
318e 32 6c ee			ld (debug_mark+1),a  
3191 3a 9b 31			ld a, (.dmark+2)  
3194 32 6d ee			ld (debug_mark+2),a  
3197 18 03			jr .pastdmark  
3199 ..			.dmark: db "DO8"  
319c f1			.pastdmark: pop af  
319d			endm  
# End of macro DMARK
319d						CALLMONITOR 
319d cd 6f ee			call debug_vector  
31a0				endm  
# End of macro CALLMONITOR
31a0					endif 
31a0			 
31a0					NEXTW 
31a0 c3 f2 1f			jp macro_next 
31a3				endm 
# End of macro NEXTW
31a3			.LOOP: 
31a3				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31a3 22				db WORD_SYS_CORE+14             
31a4 bb 32			dw .I            
31a6 05				db 4 + 1 
31a7 .. 00			db "LOOP",0              
31ac				endm 
# End of macro CWHEAD
31ac			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31ac			 
31ac				; pop tos as current loop count to hl 
31ac			 
31ac				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31ac			 
31ac				FORTH_LOOP_TOS 
31ac cd a0 1e			call macro_forth_loop_tos 
31af				endm 
# End of macro FORTH_LOOP_TOS
31af e5				push hl 
31b0			 
31b0					if DEBUG_FORTH_WORDS_KEY 
31b0						DMARK "LOP" 
31b0 f5				push af  
31b1 3a c5 31			ld a, (.dmark)  
31b4 32 6b ee			ld (debug_mark),a  
31b7 3a c6 31			ld a, (.dmark+1)  
31ba 32 6c ee			ld (debug_mark+1),a  
31bd 3a c7 31			ld a, (.dmark+2)  
31c0 32 6d ee			ld (debug_mark+2),a  
31c3 18 03			jr .pastdmark  
31c5 ..			.dmark: db "LOP"  
31c8 f1			.pastdmark: pop af  
31c9			endm  
# End of macro DMARK
31c9						CALLMONITOR 
31c9 cd 6f ee			call debug_vector  
31cc				endm  
# End of macro CALLMONITOR
31cc					endif 
31cc				; next item on the stack is the limit. get it 
31cc			 
31cc			 
31cc				FORTH_LOOP_POP 
31cc cd aa 1e			call macro_forth_loop_pop 
31cf				endm 
# End of macro FORTH_LOOP_POP
31cf			 
31cf				FORTH_LOOP_TOS 
31cf cd a0 1e			call macro_forth_loop_tos 
31d2				endm 
# End of macro FORTH_LOOP_TOS
31d2			 
31d2 d1				pop de		 ; de = i, hl = limit 
31d3			 
31d3					if DEBUG_FORTH_WORDS 
31d3						DMARK "LP1" 
31d3 f5				push af  
31d4 3a e8 31			ld a, (.dmark)  
31d7 32 6b ee			ld (debug_mark),a  
31da 3a e9 31			ld a, (.dmark+1)  
31dd 32 6c ee			ld (debug_mark+1),a  
31e0 3a ea 31			ld a, (.dmark+2)  
31e3 32 6d ee			ld (debug_mark+2),a  
31e6 18 03			jr .pastdmark  
31e8 ..			.dmark: db "LP1"  
31eb f1			.pastdmark: pop af  
31ec			endm  
# End of macro DMARK
31ec						CALLMONITOR 
31ec cd 6f ee			call debug_vector  
31ef				endm  
# End of macro CALLMONITOR
31ef					endif 
31ef			 
31ef				; go back to previous word 
31ef			 
31ef d5				push de    ; save I for inc later 
31f0			 
31f0			 
31f0				; get limit 
31f0				;  is I at limit? 
31f0			 
31f0			 
31f0					if DEBUG_FORTH_WORDS 
31f0						DMARK "LP1" 
31f0 f5				push af  
31f1 3a 05 32			ld a, (.dmark)  
31f4 32 6b ee			ld (debug_mark),a  
31f7 3a 06 32			ld a, (.dmark+1)  
31fa 32 6c ee			ld (debug_mark+1),a  
31fd 3a 07 32			ld a, (.dmark+2)  
3200 32 6d ee			ld (debug_mark+2),a  
3203 18 03			jr .pastdmark  
3205 ..			.dmark: db "LP1"  
3208 f1			.pastdmark: pop af  
3209			endm  
# End of macro DMARK
3209						CALLMONITOR 
3209 cd 6f ee			call debug_vector  
320c				endm  
# End of macro CALLMONITOR
320c					endif 
320c			 
320c ed 52			sbc hl, de 
320e			 
320e			 
320e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
320e			 
320e 20 26				jr nz, .loopnotdone 
3210			 
3210 e1				pop hl   ; get rid of saved I 
3211				FORTH_LOOP_POP     ; get rid of limit 
3211 cd aa 1e			call macro_forth_loop_pop 
3214				endm 
# End of macro FORTH_LOOP_POP
3214			 
3214				FORTH_RSP_POP     ; get rid of DO ptr 
3214 cd 0d 1c			call macro_forth_rsp_pop 
3217				endm 
# End of macro FORTH_RSP_POP
3217			 
3217			if DEBUG_FORTH_WORDS 
3217						DMARK "LP>" 
3217 f5				push af  
3218 3a 2c 32			ld a, (.dmark)  
321b 32 6b ee			ld (debug_mark),a  
321e 3a 2d 32			ld a, (.dmark+1)  
3221 32 6c ee			ld (debug_mark+1),a  
3224 3a 2e 32			ld a, (.dmark+2)  
3227 32 6d ee			ld (debug_mark+2),a  
322a 18 03			jr .pastdmark  
322c ..			.dmark: db "LP>"  
322f f1			.pastdmark: pop af  
3230			endm  
# End of macro DMARK
3230				CALLMONITOR 
3230 cd 6f ee			call debug_vector  
3233				endm  
# End of macro CALLMONITOR
3233			endif 
3233			 
3233					NEXTW 
3233 c3 f2 1f			jp macro_next 
3236				endm 
# End of macro NEXTW
3236				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3236			 
3236			.loopnotdone: 
3236			 
3236 e1				pop hl    ; get I 
3237 23				inc hl 
3238			 
3238			   	; save new I 
3238			 
3238			 
3238					; set I counter 
3238			 
3238 22 e6 e5				ld (os_current_i), hl 
323b			 
323b					if DEBUG_FORTH_WORDS 
323b						DMARK "LPN" 
323b f5				push af  
323c 3a 50 32			ld a, (.dmark)  
323f 32 6b ee			ld (debug_mark),a  
3242 3a 51 32			ld a, (.dmark+1)  
3245 32 6c ee			ld (debug_mark+1),a  
3248 3a 52 32			ld a, (.dmark+2)  
324b 32 6d ee			ld (debug_mark+2),a  
324e 18 03			jr .pastdmark  
3250 ..			.dmark: db "LPN"  
3253 f1			.pastdmark: pop af  
3254			endm  
# End of macro DMARK
3254					CALLMONITOR 
3254 cd 6f ee			call debug_vector  
3257				endm  
# End of macro CALLMONITOR
3257					endif 
3257					 
3257				FORTH_LOOP_NEXT 
3257 cd 6d 1e			call macro_forth_loop_next 
325a				endm 
# End of macro FORTH_LOOP_NEXT
325a			 
325a			 
325a					if DEBUG_FORTH_WORDS 
325a eb						ex de,hl 
325b					endif 
325b			 
325b			;	; get DO ptr 
325b			; 
325b					if DEBUG_FORTH_WORDS 
325b						DMARK "LP7" 
325b f5				push af  
325c 3a 70 32			ld a, (.dmark)  
325f 32 6b ee			ld (debug_mark),a  
3262 3a 71 32			ld a, (.dmark+1)  
3265 32 6c ee			ld (debug_mark+1),a  
3268 3a 72 32			ld a, (.dmark+2)  
326b 32 6d ee			ld (debug_mark+2),a  
326e 18 03			jr .pastdmark  
3270 ..			.dmark: db "LP7"  
3273 f1			.pastdmark: pop af  
3274			endm  
# End of macro DMARK
3274					CALLMONITOR 
3274 cd 6f ee			call debug_vector  
3277				endm  
# End of macro CALLMONITOR
3277					endif 
3277				FORTH_RSP_TOS 
3277 cd 03 1c			call macro_forth_rsp_tos 
327a				endm 
# End of macro FORTH_RSP_TOS
327a			 
327a					if DEBUG_FORTH_WORDS 
327a						DMARK "LP8" 
327a f5				push af  
327b 3a 8f 32			ld a, (.dmark)  
327e 32 6b ee			ld (debug_mark),a  
3281 3a 90 32			ld a, (.dmark+1)  
3284 32 6c ee			ld (debug_mark+1),a  
3287 3a 91 32			ld a, (.dmark+2)  
328a 32 6d ee			ld (debug_mark+2),a  
328d 18 03			jr .pastdmark  
328f ..			.dmark: db "LP8"  
3292 f1			.pastdmark: pop af  
3293			endm  
# End of macro DMARK
3293					CALLMONITOR 
3293 cd 6f ee			call debug_vector  
3296				endm  
# End of macro CALLMONITOR
3296					endif 
3296				;push hl 
3296			 
3296				; not going to DO any more 
3296				; get rid of the RSP pointer as DO will add it back in 
3296				;FORTH_RSP_POP 
3296				;pop hl 
3296			 
3296				;ld hl,(cli_ret_sp) 
3296				;ld e, (hl) 
3296				;inc hl 
3296				;ld d, (hl) 
3296				;ex de,hl 
3296 22 c2 e5			ld (os_tok_ptr), hl 
3299					if DEBUG_FORTH_WORDS 
3299						DMARK "LP<" 
3299 f5				push af  
329a 3a ae 32			ld a, (.dmark)  
329d 32 6b ee			ld (debug_mark),a  
32a0 3a af 32			ld a, (.dmark+1)  
32a3 32 6c ee			ld (debug_mark+1),a  
32a6 3a b0 32			ld a, (.dmark+2)  
32a9 32 6d ee			ld (debug_mark+2),a  
32ac 18 03			jr .pastdmark  
32ae ..			.dmark: db "LP<"  
32b1 f1			.pastdmark: pop af  
32b2			endm  
# End of macro DMARK
32b2					CALLMONITOR 
32b2 cd 6f ee			call debug_vector  
32b5				endm  
# End of macro CALLMONITOR
32b5				endif 
32b5 c3 83 20			jp exec1 
32b8			 
32b8					 
32b8			 
32b8			 
32b8					NEXTW 
32b8 c3 f2 1f			jp macro_next 
32bb				endm 
# End of macro NEXTW
32bb			.I:  
32bb			 
32bb				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32bb 5e				db WORD_SYS_CORE+74             
32bc e6 32			dw .DLOOP            
32be 02				db 1 + 1 
32bf .. 00			db "I",0              
32c1				endm 
# End of macro CWHEAD
32c1			; | I ( -- ) Current loop counter | DONE 
32c1					if DEBUG_FORTH_WORDS_KEY 
32c1						DMARK "I.." 
32c1 f5				push af  
32c2 3a d6 32			ld a, (.dmark)  
32c5 32 6b ee			ld (debug_mark),a  
32c8 3a d7 32			ld a, (.dmark+1)  
32cb 32 6c ee			ld (debug_mark+1),a  
32ce 3a d8 32			ld a, (.dmark+2)  
32d1 32 6d ee			ld (debug_mark+2),a  
32d4 18 03			jr .pastdmark  
32d6 ..			.dmark: db "I.."  
32d9 f1			.pastdmark: pop af  
32da			endm  
# End of macro DMARK
32da						CALLMONITOR 
32da cd 6f ee			call debug_vector  
32dd				endm  
# End of macro CALLMONITOR
32dd					endif 
32dd			 
32dd 2a e6 e5				ld hl,(os_current_i) 
32e0 cd 45 1c				call forth_push_numhl 
32e3			 
32e3					NEXTW 
32e3 c3 f2 1f			jp macro_next 
32e6				endm 
# End of macro NEXTW
32e6			.DLOOP: 
32e6				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32e6 5f				db WORD_SYS_CORE+75             
32e7 c7 33			dw .REPEAT            
32e9 06				db 5 + 1 
32ea .. 00			db "-LOOP",0              
32f0				endm 
# End of macro CWHEAD
32f0			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32f0				; pop tos as current loop count to hl 
32f0					if DEBUG_FORTH_WORDS_KEY 
32f0						DMARK "-LP" 
32f0 f5				push af  
32f1 3a 05 33			ld a, (.dmark)  
32f4 32 6b ee			ld (debug_mark),a  
32f7 3a 06 33			ld a, (.dmark+1)  
32fa 32 6c ee			ld (debug_mark+1),a  
32fd 3a 07 33			ld a, (.dmark+2)  
3300 32 6d ee			ld (debug_mark+2),a  
3303 18 03			jr .pastdmark  
3305 ..			.dmark: db "-LP"  
3308 f1			.pastdmark: pop af  
3309			endm  
# End of macro DMARK
3309						CALLMONITOR 
3309 cd 6f ee			call debug_vector  
330c				endm  
# End of macro CALLMONITOR
330c					endif 
330c			 
330c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
330c			 
330c				FORTH_LOOP_TOS 
330c cd a0 1e			call macro_forth_loop_tos 
330f				endm 
# End of macro FORTH_LOOP_TOS
330f e5				push hl 
3310			 
3310					if DEBUG_FORTH_WORDS 
3310						DMARK "-LP" 
3310 f5				push af  
3311 3a 25 33			ld a, (.dmark)  
3314 32 6b ee			ld (debug_mark),a  
3317 3a 26 33			ld a, (.dmark+1)  
331a 32 6c ee			ld (debug_mark+1),a  
331d 3a 27 33			ld a, (.dmark+2)  
3320 32 6d ee			ld (debug_mark+2),a  
3323 18 03			jr .pastdmark  
3325 ..			.dmark: db "-LP"  
3328 f1			.pastdmark: pop af  
3329			endm  
# End of macro DMARK
3329						CALLMONITOR 
3329 cd 6f ee			call debug_vector  
332c				endm  
# End of macro CALLMONITOR
332c					endif 
332c				; next item on the stack is the limit. get it 
332c			 
332c			 
332c				FORTH_LOOP_POP 
332c cd aa 1e			call macro_forth_loop_pop 
332f				endm 
# End of macro FORTH_LOOP_POP
332f			 
332f				FORTH_LOOP_TOS 
332f cd a0 1e			call macro_forth_loop_tos 
3332				endm 
# End of macro FORTH_LOOP_TOS
3332			 
3332 d1				pop de		 ; de = i, hl = limit 
3333			 
3333					if DEBUG_FORTH_WORDS 
3333						DMARK "-L1" 
3333 f5				push af  
3334 3a 48 33			ld a, (.dmark)  
3337 32 6b ee			ld (debug_mark),a  
333a 3a 49 33			ld a, (.dmark+1)  
333d 32 6c ee			ld (debug_mark+1),a  
3340 3a 4a 33			ld a, (.dmark+2)  
3343 32 6d ee			ld (debug_mark+2),a  
3346 18 03			jr .pastdmark  
3348 ..			.dmark: db "-L1"  
334b f1			.pastdmark: pop af  
334c			endm  
# End of macro DMARK
334c						CALLMONITOR 
334c cd 6f ee			call debug_vector  
334f				endm  
# End of macro CALLMONITOR
334f					endif 
334f			 
334f				; go back to previous word 
334f			 
334f d5				push de    ; save I for inc later 
3350			 
3350			 
3350				; get limit 
3350				;  is I at limit? 
3350			 
3350			 
3350					if DEBUG_FORTH_WORDS 
3350						DMARK "-L1" 
3350 f5				push af  
3351 3a 65 33			ld a, (.dmark)  
3354 32 6b ee			ld (debug_mark),a  
3357 3a 66 33			ld a, (.dmark+1)  
335a 32 6c ee			ld (debug_mark+1),a  
335d 3a 67 33			ld a, (.dmark+2)  
3360 32 6d ee			ld (debug_mark+2),a  
3363 18 03			jr .pastdmark  
3365 ..			.dmark: db "-L1"  
3368 f1			.pastdmark: pop af  
3369			endm  
# End of macro DMARK
3369						CALLMONITOR 
3369 cd 6f ee			call debug_vector  
336c				endm  
# End of macro CALLMONITOR
336c					endif 
336c			 
336c ed 52			sbc hl, de 
336e			 
336e			 
336e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
336e			 
336e 20 26				jr nz, .mloopnotdone 
3370			 
3370 e1				pop hl   ; get rid of saved I 
3371				FORTH_LOOP_POP     ; get rid of limit 
3371 cd aa 1e			call macro_forth_loop_pop 
3374				endm 
# End of macro FORTH_LOOP_POP
3374			 
3374				FORTH_RSP_POP     ; get rid of DO ptr 
3374 cd 0d 1c			call macro_forth_rsp_pop 
3377				endm 
# End of macro FORTH_RSP_POP
3377			 
3377			if DEBUG_FORTH_WORDS 
3377						DMARK "-L>" 
3377 f5				push af  
3378 3a 8c 33			ld a, (.dmark)  
337b 32 6b ee			ld (debug_mark),a  
337e 3a 8d 33			ld a, (.dmark+1)  
3381 32 6c ee			ld (debug_mark+1),a  
3384 3a 8e 33			ld a, (.dmark+2)  
3387 32 6d ee			ld (debug_mark+2),a  
338a 18 03			jr .pastdmark  
338c ..			.dmark: db "-L>"  
338f f1			.pastdmark: pop af  
3390			endm  
# End of macro DMARK
3390				CALLMONITOR 
3390 cd 6f ee			call debug_vector  
3393				endm  
# End of macro CALLMONITOR
3393			endif 
3393			 
3393					NEXTW 
3393 c3 f2 1f			jp macro_next 
3396				endm 
# End of macro NEXTW
3396				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3396			 
3396			.mloopnotdone: 
3396			 
3396 e1				pop hl    ; get I 
3397 2b				dec hl 
3398			 
3398			   	; save new I 
3398			 
3398			 
3398					; set I counter 
3398			 
3398 22 e6 e5				ld (os_current_i), hl 
339b			 
339b					 
339b				FORTH_LOOP_NEXT 
339b cd 6d 1e			call macro_forth_loop_next 
339e				endm 
# End of macro FORTH_LOOP_NEXT
339e			 
339e			 
339e					if DEBUG_FORTH_WORDS 
339e eb						ex de,hl 
339f					endif 
339f			 
339f			;	; get DO ptr 
339f			; 
339f				FORTH_RSP_TOS 
339f cd 03 1c			call macro_forth_rsp_tos 
33a2				endm 
# End of macro FORTH_RSP_TOS
33a2			 
33a2				;push hl 
33a2			 
33a2				; not going to DO any more 
33a2				; get rid of the RSP pointer as DO will add it back in 
33a2				;FORTH_RSP_POP 
33a2				;pop hl 
33a2			 
33a2			 
33a2 22 c2 e5			ld (os_tok_ptr), hl 
33a5					if DEBUG_FORTH_WORDS 
33a5						DMARK "-L<" 
33a5 f5				push af  
33a6 3a ba 33			ld a, (.dmark)  
33a9 32 6b ee			ld (debug_mark),a  
33ac 3a bb 33			ld a, (.dmark+1)  
33af 32 6c ee			ld (debug_mark+1),a  
33b2 3a bc 33			ld a, (.dmark+2)  
33b5 32 6d ee			ld (debug_mark+2),a  
33b8 18 03			jr .pastdmark  
33ba ..			.dmark: db "-L<"  
33bd f1			.pastdmark: pop af  
33be			endm  
# End of macro DMARK
33be					CALLMONITOR 
33be cd 6f ee			call debug_vector  
33c1				endm  
# End of macro CALLMONITOR
33c1				endif 
33c1 c3 83 20			jp exec1 
33c4			 
33c4					 
33c4			 
33c4			 
33c4			 
33c4				NEXTW 
33c4 c3 f2 1f			jp macro_next 
33c7				endm 
# End of macro NEXTW
33c7			 
33c7			 
33c7			 
33c7			 
33c7			.REPEAT: 
33c7				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33c7 71				db WORD_SYS_CORE+93             
33c8 1a 34			dw .UNTIL            
33ca 06				db 5 + 1 
33cb .. 00			db "REPEAT",0              
33d2				endm 
# End of macro CWHEAD
33d2			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33d2			;  push pc to rsp stack past the REPEAT 
33d2					if DEBUG_FORTH_WORDS_KEY 
33d2						DMARK "REP" 
33d2 f5				push af  
33d3 3a e7 33			ld a, (.dmark)  
33d6 32 6b ee			ld (debug_mark),a  
33d9 3a e8 33			ld a, (.dmark+1)  
33dc 32 6c ee			ld (debug_mark+1),a  
33df 3a e9 33			ld a, (.dmark+2)  
33e2 32 6d ee			ld (debug_mark+2),a  
33e5 18 03			jr .pastdmark  
33e7 ..			.dmark: db "REP"  
33ea f1			.pastdmark: pop af  
33eb			endm  
# End of macro DMARK
33eb						CALLMONITOR 
33eb cd 6f ee			call debug_vector  
33ee				endm  
# End of macro CALLMONITOR
33ee					endif 
33ee			 
33ee 2a c2 e5				ld hl, (os_tok_ptr) 
33f1 23					inc hl   ; R 
33f2 23					inc hl  ; E 
33f3 23					inc hl   ; P 
33f4 23					inc hl   ; E 
33f5 23					inc hl   ; A 
33f6 23					inc hl   ; T 
33f7 23					inc hl   ; zero 
33f8					FORTH_RSP_NEXT 
33f8 cd ec 1b			call macro_forth_rsp_next 
33fb				endm 
# End of macro FORTH_RSP_NEXT
33fb			 
33fb			 
33fb					if DEBUG_FORTH_WORDS 
33fb						DMARK "REP" 
33fb f5				push af  
33fc 3a 10 34			ld a, (.dmark)  
33ff 32 6b ee			ld (debug_mark),a  
3402 3a 11 34			ld a, (.dmark+1)  
3405 32 6c ee			ld (debug_mark+1),a  
3408 3a 12 34			ld a, (.dmark+2)  
340b 32 6d ee			ld (debug_mark+2),a  
340e 18 03			jr .pastdmark  
3410 ..			.dmark: db "REP"  
3413 f1			.pastdmark: pop af  
3414			endm  
# End of macro DMARK
3414						;pop bc    ; TODO BUG ?????? what is this for???? 
3414						CALLMONITOR 
3414 cd 6f ee			call debug_vector  
3417				endm  
# End of macro CALLMONITOR
3417					endif 
3417			 
3417					NEXTW 
3417 c3 f2 1f			jp macro_next 
341a				endm 
# End of macro NEXTW
341a			;	       NEXTW 
341a			 
341a			.UNTIL: 
341a				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
341a 72				db WORD_SYS_CORE+94             
341b b1 34			dw .ENDFLOW            
341d 06				db 5 + 1 
341e .. 00			db "UNTIL",0              
3424				endm 
# End of macro CWHEAD
3424			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3424			 
3424				; pop tos as check 
3424			 
3424				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3424			 
3424				FORTH_DSP_VALUEHL 
3424 cd 3c 1e			call macro_dsp_valuehl 
3427				endm 
# End of macro FORTH_DSP_VALUEHL
3427			 
3427					if DEBUG_FORTH_WORDS_KEY 
3427						DMARK "UNT" 
3427 f5				push af  
3428 3a 3c 34			ld a, (.dmark)  
342b 32 6b ee			ld (debug_mark),a  
342e 3a 3d 34			ld a, (.dmark+1)  
3431 32 6c ee			ld (debug_mark+1),a  
3434 3a 3e 34			ld a, (.dmark+2)  
3437 32 6d ee			ld (debug_mark+2),a  
343a 18 03			jr .pastdmark  
343c ..			.dmark: db "UNT"  
343f f1			.pastdmark: pop af  
3440			endm  
# End of macro DMARK
3440						CALLMONITOR 
3440 cd 6f ee			call debug_vector  
3443				endm  
# End of macro CALLMONITOR
3443					endif 
3443			 
3443			;	push hl 
3443				FORTH_DSP_POP 
3443 cd f4 1e			call macro_forth_dsp_pop 
3446				endm 
# End of macro FORTH_DSP_POP
3446			 
3446			;	pop hl 
3446			 
3446				; test if true 
3446			 
3446 cd 10 0e			call ishlzero 
3449			;	ld a,l 
3449			;	add h 
3449			; 
3449			;	cp 0 
3449			 
3449 20 3e			jr nz, .untilnotdone 
344b			 
344b					if DEBUG_FORTH_WORDS 
344b						DMARK "UNf" 
344b f5				push af  
344c 3a 60 34			ld a, (.dmark)  
344f 32 6b ee			ld (debug_mark),a  
3452 3a 61 34			ld a, (.dmark+1)  
3455 32 6c ee			ld (debug_mark+1),a  
3458 3a 62 34			ld a, (.dmark+2)  
345b 32 6d ee			ld (debug_mark+2),a  
345e 18 03			jr .pastdmark  
3460 ..			.dmark: db "UNf"  
3463 f1			.pastdmark: pop af  
3464			endm  
# End of macro DMARK
3464						CALLMONITOR 
3464 cd 6f ee			call debug_vector  
3467				endm  
# End of macro CALLMONITOR
3467					endif 
3467			 
3467			 
3467			 
3467				FORTH_RSP_POP     ; get rid of DO ptr 
3467 cd 0d 1c			call macro_forth_rsp_pop 
346a				endm 
# End of macro FORTH_RSP_POP
346a			 
346a			if DEBUG_FORTH_WORDS 
346a						DMARK "UN>" 
346a f5				push af  
346b 3a 7f 34			ld a, (.dmark)  
346e 32 6b ee			ld (debug_mark),a  
3471 3a 80 34			ld a, (.dmark+1)  
3474 32 6c ee			ld (debug_mark+1),a  
3477 3a 81 34			ld a, (.dmark+2)  
347a 32 6d ee			ld (debug_mark+2),a  
347d 18 03			jr .pastdmark  
347f ..			.dmark: db "UN>"  
3482 f1			.pastdmark: pop af  
3483			endm  
# End of macro DMARK
3483				CALLMONITOR 
3483 cd 6f ee			call debug_vector  
3486				endm  
# End of macro CALLMONITOR
3486			endif 
3486			 
3486					NEXTW 
3486 c3 f2 1f			jp macro_next 
3489				endm 
# End of macro NEXTW
3489				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3489			 
3489			.untilnotdone: 
3489			 
3489			 
3489			;	; get DO ptr 
3489			; 
3489				FORTH_RSP_TOS 
3489 cd 03 1c			call macro_forth_rsp_tos 
348c				endm 
# End of macro FORTH_RSP_TOS
348c			 
348c				;push hl 
348c			 
348c				; not going to DO any more 
348c				; get rid of the RSP pointer as DO will add it back in 
348c				;FORTH_RSP_POP 
348c				;pop hl 
348c			 
348c			 
348c 22 c2 e5			ld (os_tok_ptr), hl 
348f					if DEBUG_FORTH_WORDS 
348f						DMARK "UN<" 
348f f5				push af  
3490 3a a4 34			ld a, (.dmark)  
3493 32 6b ee			ld (debug_mark),a  
3496 3a a5 34			ld a, (.dmark+1)  
3499 32 6c ee			ld (debug_mark+1),a  
349c 3a a6 34			ld a, (.dmark+2)  
349f 32 6d ee			ld (debug_mark+2),a  
34a2 18 03			jr .pastdmark  
34a4 ..			.dmark: db "UN<"  
34a7 f1			.pastdmark: pop af  
34a8			endm  
# End of macro DMARK
34a8					CALLMONITOR 
34a8 cd 6f ee			call debug_vector  
34ab				endm  
# End of macro CALLMONITOR
34ab				endif 
34ab c3 83 20			jp exec1 
34ae			 
34ae					 
34ae			 
34ae			 
34ae					NEXTW 
34ae c3 f2 1f			jp macro_next 
34b1				endm 
# End of macro NEXTW
34b1			 
34b1			 
34b1			.ENDFLOW: 
34b1			 
34b1			; eof 
34b1			 
# End of file forth_words_flow.asm
34b1			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34b1			include "forth_words_logic.asm" 
34b1			 
34b1			; | ## Logic Words 
34b1			 
34b1			.NOT: 
34b1				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34b1 2d				db WORD_SYS_CORE+25             
34b2 f9 34			dw .IS            
34b4 04				db 3 + 1 
34b5 .. 00			db "NOT",0              
34b9				endm 
# End of macro CWHEAD
34b9			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34b9					if DEBUG_FORTH_WORDS_KEY 
34b9						DMARK "NOT" 
34b9 f5				push af  
34ba 3a ce 34			ld a, (.dmark)  
34bd 32 6b ee			ld (debug_mark),a  
34c0 3a cf 34			ld a, (.dmark+1)  
34c3 32 6c ee			ld (debug_mark+1),a  
34c6 3a d0 34			ld a, (.dmark+2)  
34c9 32 6d ee			ld (debug_mark+2),a  
34cc 18 03			jr .pastdmark  
34ce ..			.dmark: db "NOT"  
34d1 f1			.pastdmark: pop af  
34d2			endm  
# End of macro DMARK
34d2						CALLMONITOR 
34d2 cd 6f ee			call debug_vector  
34d5				endm  
# End of macro CALLMONITOR
34d5					endif 
34d5					FORTH_DSP 
34d5 cd 02 1e			call macro_forth_dsp 
34d8				endm 
# End of macro FORTH_DSP
34d8 7e					ld a,(hl)	; get type of value on TOS 
34d9 fe 02				cp DS_TYPE_INUM  
34db 28 03				jr z, .noti 
34dd					NEXTW 
34dd c3 f2 1f			jp macro_next 
34e0				endm 
# End of macro NEXTW
34e0			.noti:          FORTH_DSP_VALUEHL 
34e0 cd 3c 1e			call macro_dsp_valuehl 
34e3				endm 
# End of macro FORTH_DSP_VALUEHL
34e3			;		push hl 
34e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34e3 cd f4 1e			call macro_forth_dsp_pop 
34e6				endm 
# End of macro FORTH_DSP_POP
34e6			;		pop hl 
34e6 3e 00				ld a,0 
34e8 bd					cp l 
34e9 28 04				jr z, .not2t 
34eb 2e 00				ld l, 0 
34ed 18 02				jr .notip 
34ef			 
34ef 2e ff		.not2t:		ld l, 255 
34f1			 
34f1 26 00		.notip:		ld h, 0	 
34f3			 
34f3 cd 45 1c				call forth_push_numhl 
34f6					NEXTW 
34f6 c3 f2 1f			jp macro_next 
34f9				endm 
# End of macro NEXTW
34f9			 
34f9			.IS: 
34f9				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34f9 2d				db WORD_SYS_CORE+25             
34fa 1f 35			dw .LZERO            
34fc 03				db 2 + 1 
34fd .. 00			db "IS",0              
3500				endm 
# End of macro CWHEAD
3500			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3500					if DEBUG_FORTH_WORDS_KEY 
3500						DMARK "IS." 
3500 f5				push af  
3501 3a 15 35			ld a, (.dmark)  
3504 32 6b ee			ld (debug_mark),a  
3507 3a 16 35			ld a, (.dmark+1)  
350a 32 6c ee			ld (debug_mark+1),a  
350d 3a 17 35			ld a, (.dmark+2)  
3510 32 6d ee			ld (debug_mark+2),a  
3513 18 03			jr .pastdmark  
3515 ..			.dmark: db "IS."  
3518 f1			.pastdmark: pop af  
3519			endm  
# End of macro DMARK
3519						CALLMONITOR 
3519 cd 6f ee			call debug_vector  
351c				endm  
# End of macro CALLMONITOR
351c					endif 
351c					NEXTW 
351c c3 f2 1f			jp macro_next 
351f				endm 
# End of macro NEXTW
351f			.LZERO: 
351f				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
351f 2d				db WORD_SYS_CORE+25             
3520 29 35			dw .TZERO            
3522 03				db 2 + 1 
3523 .. 00			db "0<",0              
3526				endm 
# End of macro CWHEAD
3526			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3526					NEXTW 
3526 c3 f2 1f			jp macro_next 
3529				endm 
# End of macro NEXTW
3529			.TZERO: 
3529				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3529 2e				db WORD_SYS_CORE+26             
352a 70 35			dw .LESS            
352c 03				db 2 + 1 
352d .. 00			db "0=",0              
3530				endm 
# End of macro CWHEAD
3530			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3530				; TODO add floating point number detection 
3530					;v5 FORTH_DSP_VALUE 
3530					if DEBUG_FORTH_WORDS_KEY 
3530						DMARK "0=." 
3530 f5				push af  
3531 3a 45 35			ld a, (.dmark)  
3534 32 6b ee			ld (debug_mark),a  
3537 3a 46 35			ld a, (.dmark+1)  
353a 32 6c ee			ld (debug_mark+1),a  
353d 3a 47 35			ld a, (.dmark+2)  
3540 32 6d ee			ld (debug_mark+2),a  
3543 18 03			jr .pastdmark  
3545 ..			.dmark: db "0=."  
3548 f1			.pastdmark: pop af  
3549			endm  
# End of macro DMARK
3549						CALLMONITOR 
3549 cd 6f ee			call debug_vector  
354c				endm  
# End of macro CALLMONITOR
354c					endif 
354c					FORTH_DSP 
354c cd 02 1e			call macro_forth_dsp 
354f				endm 
# End of macro FORTH_DSP
354f 7e					ld a,(hl)	; get type of value on TOS 
3550 fe 02				cp DS_TYPE_INUM  
3552 28 00				jr z, .tz_inum 
3554			 
3554				if FORTH_ENABLE_FLOATMATH 
3554					jr .tz_done 
3554			 
3554				endif 
3554					 
3554			 
3554			.tz_inum: 
3554					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3554 cd 3c 1e			call macro_dsp_valuehl 
3557				endm 
# End of macro FORTH_DSP_VALUEHL
3557			 
3557			;		push hl 
3557			 
3557					; destroy value TOS 
3557			 
3557					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3557 cd f4 1e			call macro_forth_dsp_pop 
355a				endm 
# End of macro FORTH_DSP_POP
355a			 
355a			;		pop hl 
355a			 
355a 3e 00				ld a,0 
355c			 
355c bd					cp l 
355d 20 08				jr nz, .tz_notzero 
355f			 
355f bc					cp h 
3560			 
3560 20 05				jr nz, .tz_notzero 
3562			 
3562			 
3562 21 01 00				ld hl, FORTH_TRUE 
3565 18 03				jr .tz_done 
3567			 
3567 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
356a			 
356a					; push value back onto stack for another op etc 
356a			 
356a			.tz_done: 
356a cd 45 1c				call forth_push_numhl 
356d			 
356d					NEXTW 
356d c3 f2 1f			jp macro_next 
3570				endm 
# End of macro NEXTW
3570			.LESS: 
3570				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3570 2f				db WORD_SYS_CORE+27             
3571 d9 35			dw .GT            
3573 02				db 1 + 1 
3574 .. 00			db "<",0              
3576				endm 
# End of macro CWHEAD
3576			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3576				; TODO add floating point number detection 
3576					if DEBUG_FORTH_WORDS_KEY 
3576						DMARK "LES" 
3576 f5				push af  
3577 3a 8b 35			ld a, (.dmark)  
357a 32 6b ee			ld (debug_mark),a  
357d 3a 8c 35			ld a, (.dmark+1)  
3580 32 6c ee			ld (debug_mark+1),a  
3583 3a 8d 35			ld a, (.dmark+2)  
3586 32 6d ee			ld (debug_mark+2),a  
3589 18 03			jr .pastdmark  
358b ..			.dmark: db "LES"  
358e f1			.pastdmark: pop af  
358f			endm  
# End of macro DMARK
358f						CALLMONITOR 
358f cd 6f ee			call debug_vector  
3592				endm  
# End of macro CALLMONITOR
3592					endif 
3592					FORTH_DSP 
3592 cd 02 1e			call macro_forth_dsp 
3595				endm 
# End of macro FORTH_DSP
3595					;v5 FORTH_DSP_VALUE 
3595 7e					ld a,(hl)	; get type of value on TOS 
3596 fe 02				cp DS_TYPE_INUM  
3598 28 00				jr z, .less_inum 
359a			 
359a				if FORTH_ENABLE_FLOATMATH 
359a					jr .less_done 
359a			 
359a				endif 
359a					 
359a			 
359a			.less_inum: 
359a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
359a cd 3c 1e			call macro_dsp_valuehl 
359d				endm 
# End of macro FORTH_DSP_VALUEHL
359d			 
359d e5					push hl  ; u2 
359e			 
359e					; destroy value TOS 
359e			 
359e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
359e cd f4 1e			call macro_forth_dsp_pop 
35a1				endm 
# End of macro FORTH_DSP_POP
35a1			 
35a1			 
35a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a1 cd 3c 1e			call macro_dsp_valuehl 
35a4				endm 
# End of macro FORTH_DSP_VALUEHL
35a4			 
35a4 e5					push hl    ; u1 
35a5			 
35a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a5 cd f4 1e			call macro_forth_dsp_pop 
35a8				endm 
# End of macro FORTH_DSP_POP
35a8			 
35a8			 
35a8 b7			 or a      ;clear carry flag 
35a9 01 00 00		 ld bc, FORTH_FALSE 
35ac e1			  pop hl    ; u1 
35ad d1			  pop de    ; u2 
35ae ed 52		  sbc hl,de 
35b0 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35b2			 
35b2 01 01 00		 ld bc, FORTH_TRUE 
35b5			.lscont:  
35b5 c5					push bc 
35b6 e1					pop hl 
35b7			 
35b7					if DEBUG_FORTH_WORDS 
35b7						DMARK "LT1" 
35b7 f5				push af  
35b8 3a cc 35			ld a, (.dmark)  
35bb 32 6b ee			ld (debug_mark),a  
35be 3a cd 35			ld a, (.dmark+1)  
35c1 32 6c ee			ld (debug_mark+1),a  
35c4 3a ce 35			ld a, (.dmark+2)  
35c7 32 6d ee			ld (debug_mark+2),a  
35ca 18 03			jr .pastdmark  
35cc ..			.dmark: db "LT1"  
35cf f1			.pastdmark: pop af  
35d0			endm  
# End of macro DMARK
35d0						CALLMONITOR 
35d0 cd 6f ee			call debug_vector  
35d3				endm  
# End of macro CALLMONITOR
35d3					endif 
35d3 cd 45 1c				call forth_push_numhl 
35d6			 
35d6					NEXTW 
35d6 c3 f2 1f			jp macro_next 
35d9				endm 
# End of macro NEXTW
35d9			.GT: 
35d9				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35d9 30				db WORD_SYS_CORE+28             
35da 42 36			dw .EQUAL            
35dc 02				db 1 + 1 
35dd .. 00			db ">",0              
35df				endm 
# End of macro CWHEAD
35df			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35df				; TODO add floating point number detection 
35df					if DEBUG_FORTH_WORDS_KEY 
35df						DMARK "GRT" 
35df f5				push af  
35e0 3a f4 35			ld a, (.dmark)  
35e3 32 6b ee			ld (debug_mark),a  
35e6 3a f5 35			ld a, (.dmark+1)  
35e9 32 6c ee			ld (debug_mark+1),a  
35ec 3a f6 35			ld a, (.dmark+2)  
35ef 32 6d ee			ld (debug_mark+2),a  
35f2 18 03			jr .pastdmark  
35f4 ..			.dmark: db "GRT"  
35f7 f1			.pastdmark: pop af  
35f8			endm  
# End of macro DMARK
35f8						CALLMONITOR 
35f8 cd 6f ee			call debug_vector  
35fb				endm  
# End of macro CALLMONITOR
35fb					endif 
35fb					FORTH_DSP 
35fb cd 02 1e			call macro_forth_dsp 
35fe				endm 
# End of macro FORTH_DSP
35fe					;FORTH_DSP_VALUE 
35fe 7e					ld a,(hl)	; get type of value on TOS 
35ff fe 02				cp DS_TYPE_INUM  
3601 28 00				jr z, .gt_inum 
3603			 
3603				if FORTH_ENABLE_FLOATMATH 
3603					jr .gt_done 
3603			 
3603				endif 
3603					 
3603			 
3603			.gt_inum: 
3603					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3603 cd 3c 1e			call macro_dsp_valuehl 
3606				endm 
# End of macro FORTH_DSP_VALUEHL
3606			 
3606 e5					push hl  ; u2 
3607			 
3607					; destroy value TOS 
3607			 
3607					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3607 cd f4 1e			call macro_forth_dsp_pop 
360a				endm 
# End of macro FORTH_DSP_POP
360a			 
360a			 
360a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
360a cd 3c 1e			call macro_dsp_valuehl 
360d				endm 
# End of macro FORTH_DSP_VALUEHL
360d			 
360d e5					push hl    ; u1 
360e			 
360e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
360e cd f4 1e			call macro_forth_dsp_pop 
3611				endm 
# End of macro FORTH_DSP_POP
3611			 
3611			 
3611 b7			 or a      ;clear carry flag 
3612 01 00 00		 ld bc, FORTH_FALSE 
3615 e1			  pop hl    ; u1 
3616 d1			  pop de    ; u2 
3617 ed 52		  sbc hl,de 
3619 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
361b			 
361b 01 01 00		 ld bc, FORTH_TRUE 
361e			.gtcont:  
361e c5					push bc 
361f e1					pop hl 
3620			 
3620					if DEBUG_FORTH_WORDS 
3620						DMARK "GT1" 
3620 f5				push af  
3621 3a 35 36			ld a, (.dmark)  
3624 32 6b ee			ld (debug_mark),a  
3627 3a 36 36			ld a, (.dmark+1)  
362a 32 6c ee			ld (debug_mark+1),a  
362d 3a 37 36			ld a, (.dmark+2)  
3630 32 6d ee			ld (debug_mark+2),a  
3633 18 03			jr .pastdmark  
3635 ..			.dmark: db "GT1"  
3638 f1			.pastdmark: pop af  
3639			endm  
# End of macro DMARK
3639						CALLMONITOR 
3639 cd 6f ee			call debug_vector  
363c				endm  
# End of macro CALLMONITOR
363c					endif 
363c cd 45 1c				call forth_push_numhl 
363f			 
363f					NEXTW 
363f c3 f2 1f			jp macro_next 
3642				endm 
# End of macro NEXTW
3642			.EQUAL: 
3642				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3642 31				db WORD_SYS_CORE+29             
3643 ad 36			dw .ENDLOGIC            
3645 02				db 1 + 1 
3646 .. 00			db "=",0              
3648				endm 
# End of macro CWHEAD
3648			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3648				; TODO add floating point number detection 
3648					if DEBUG_FORTH_WORDS_KEY 
3648						DMARK "EQ." 
3648 f5				push af  
3649 3a 5d 36			ld a, (.dmark)  
364c 32 6b ee			ld (debug_mark),a  
364f 3a 5e 36			ld a, (.dmark+1)  
3652 32 6c ee			ld (debug_mark+1),a  
3655 3a 5f 36			ld a, (.dmark+2)  
3658 32 6d ee			ld (debug_mark+2),a  
365b 18 03			jr .pastdmark  
365d ..			.dmark: db "EQ."  
3660 f1			.pastdmark: pop af  
3661			endm  
# End of macro DMARK
3661						CALLMONITOR 
3661 cd 6f ee			call debug_vector  
3664				endm  
# End of macro CALLMONITOR
3664					endif 
3664					FORTH_DSP 
3664 cd 02 1e			call macro_forth_dsp 
3667				endm 
# End of macro FORTH_DSP
3667					;v5 FORTH_DSP_VALUE 
3667 7e					ld a,(hl)	; get type of value on TOS 
3668 fe 02				cp DS_TYPE_INUM  
366a 28 00				jr z, .eq_inum 
366c			 
366c				if FORTH_ENABLE_FLOATMATH 
366c					jr .eq_done 
366c			 
366c				endif 
366c					 
366c			 
366c			.eq_inum: 
366c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
366c cd 3c 1e			call macro_dsp_valuehl 
366f				endm 
# End of macro FORTH_DSP_VALUEHL
366f			 
366f e5					push hl 
3670			 
3670					; destroy value TOS 
3670			 
3670					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3670 cd f4 1e			call macro_forth_dsp_pop 
3673				endm 
# End of macro FORTH_DSP_POP
3673			 
3673			 
3673					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3673 cd 3c 1e			call macro_dsp_valuehl 
3676				endm 
# End of macro FORTH_DSP_VALUEHL
3676			 
3676					; one value on hl get other one back 
3676			 
3676 e5					push hl 
3677			 
3677					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3677 cd f4 1e			call macro_forth_dsp_pop 
367a				endm 
# End of macro FORTH_DSP_POP
367a			 
367a 0e 00				ld c, FORTH_FALSE 
367c			 
367c e1					pop hl 
367d d1					pop de 
367e			 
367e 7b					ld a, e 
367f bd					cp l 
3680			 
3680 20 06				jr nz, .eq_done 
3682			 
3682 7a					ld a, d 
3683 bc					cp h 
3684			 
3684 20 02				jr nz, .eq_done 
3686			 
3686 0e 01				ld c, FORTH_TRUE 
3688					 
3688			 
3688			 
3688			.eq_done: 
3688			 
3688					; TODO push value back onto stack for another op etc 
3688			 
3688 26 00				ld h, 0 
368a 69					ld l, c 
368b					if DEBUG_FORTH_WORDS 
368b						DMARK "EQ1" 
368b f5				push af  
368c 3a a0 36			ld a, (.dmark)  
368f 32 6b ee			ld (debug_mark),a  
3692 3a a1 36			ld a, (.dmark+1)  
3695 32 6c ee			ld (debug_mark+1),a  
3698 3a a2 36			ld a, (.dmark+2)  
369b 32 6d ee			ld (debug_mark+2),a  
369e 18 03			jr .pastdmark  
36a0 ..			.dmark: db "EQ1"  
36a3 f1			.pastdmark: pop af  
36a4			endm  
# End of macro DMARK
36a4						CALLMONITOR 
36a4 cd 6f ee			call debug_vector  
36a7				endm  
# End of macro CALLMONITOR
36a7					endif 
36a7 cd 45 1c				call forth_push_numhl 
36aa			 
36aa					NEXTW 
36aa c3 f2 1f			jp macro_next 
36ad				endm 
# End of macro NEXTW
36ad			 
36ad			 
36ad			.ENDLOGIC: 
36ad			; eof 
36ad			 
36ad			 
# End of file forth_words_logic.asm
36ad			include "forth_words_maths.asm" 
36ad			 
36ad			; | ## Maths Words 
36ad			 
36ad			.PLUS:	 
36ad				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36ad 15				db WORD_SYS_CORE+1             
36ae 0b 37			dw .NEG            
36b0 02				db 1 + 1 
36b1 .. 00			db "+",0              
36b3				endm 
# End of macro CWHEAD
36b3			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36b3					if DEBUG_FORTH_WORDS_KEY 
36b3						DMARK "PLU" 
36b3 f5				push af  
36b4 3a c8 36			ld a, (.dmark)  
36b7 32 6b ee			ld (debug_mark),a  
36ba 3a c9 36			ld a, (.dmark+1)  
36bd 32 6c ee			ld (debug_mark+1),a  
36c0 3a ca 36			ld a, (.dmark+2)  
36c3 32 6d ee			ld (debug_mark+2),a  
36c6 18 03			jr .pastdmark  
36c8 ..			.dmark: db "PLU"  
36cb f1			.pastdmark: pop af  
36cc			endm  
# End of macro DMARK
36cc						CALLMONITOR 
36cc cd 6f ee			call debug_vector  
36cf				endm  
# End of macro CALLMONITOR
36cf					endif 
36cf					; add top two values and push back result 
36cf			 
36cf					;for v5 FORTH_DSP_VALUE 
36cf					FORTH_DSP 
36cf cd 02 1e			call macro_forth_dsp 
36d2				endm 
# End of macro FORTH_DSP
36d2 7e					ld a,(hl)	; get type of value on TOS 
36d3 fe 02				cp DS_TYPE_INUM  
36d5 28 03				jr z, .dot_inum 
36d7			 
36d7					NEXTW 
36d7 c3 f2 1f			jp macro_next 
36da				endm 
# End of macro NEXTW
36da			 
36da			; float maths 
36da			 
36da				if FORTH_ENABLE_FLOATMATH 
36da						inc hl      ; now at start of numeric as string 
36da			 
36da					if DEBUG_FORTH_MATHS 
36da						DMARK "ADD" 
36da				CALLMONITOR 
36da					endif 
36da			 
36da					;ld ix, hl 
36da					call CON 
36da			 
36da			 
36da					push hl 
36da					 
36da					 
36da			 
36da						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36da			 
36da					; get next number 
36da			 
36da						FORTH_DSP_VALUE 
36da			 
36da						inc hl      ; now at start of numeric as string 
36da			 
36da					;ld ix, hl 
36da					call CON 
36da			 
36da					push hl 
36da			 
36da			 
36da						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36da			 
36da						; TODO do add 
36da			 
36da						call IADD 
36da			 
36da						; TODO get result back as ascii 
36da			 
36da						; TODO push result  
36da			 
36da			 
36da			 
36da						jr .dot_done 
36da				endif 
36da			 
36da			.dot_inum: 
36da			 
36da			 
36da					if DEBUG_FORTH_DOT 
36da						DMARK "+IT" 
36da f5				push af  
36db 3a ef 36			ld a, (.dmark)  
36de 32 6b ee			ld (debug_mark),a  
36e1 3a f0 36			ld a, (.dmark+1)  
36e4 32 6c ee			ld (debug_mark+1),a  
36e7 3a f1 36			ld a, (.dmark+2)  
36ea 32 6d ee			ld (debug_mark+2),a  
36ed 18 03			jr .pastdmark  
36ef ..			.dmark: db "+IT"  
36f2 f1			.pastdmark: pop af  
36f3			endm  
# End of macro DMARK
36f3				CALLMONITOR 
36f3 cd 6f ee			call debug_vector  
36f6				endm  
# End of macro CALLMONITOR
36f6					endif 
36f6			 
36f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f6 cd 3c 1e			call macro_dsp_valuehl 
36f9				endm 
# End of macro FORTH_DSP_VALUEHL
36f9			 
36f9				; TODO add floating point number detection 
36f9			 
36f9 e5					push hl 
36fa			 
36fa					; destroy value TOS 
36fa			 
36fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fa cd f4 1e			call macro_forth_dsp_pop 
36fd				endm 
# End of macro FORTH_DSP_POP
36fd			 
36fd			 
36fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36fd cd 3c 1e			call macro_dsp_valuehl 
3700				endm 
# End of macro FORTH_DSP_VALUEHL
3700			 
3700					; one value on hl get other one back 
3700			 
3700 d1					pop de 
3701			 
3701					; do the add 
3701			 
3701 19					add hl,de 
3702			 
3702					; save it 
3702			 
3702			;		push hl	 
3702			 
3702					; 
3702			 
3702					; destroy value TOS 
3702			 
3702					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3702 cd f4 1e			call macro_forth_dsp_pop 
3705				endm 
# End of macro FORTH_DSP_POP
3705			 
3705					; TODO push value back onto stack for another op etc 
3705			 
3705			;		pop hl 
3705			 
3705			.dot_done: 
3705 cd 45 1c				call forth_push_numhl 
3708			 
3708					NEXTW 
3708 c3 f2 1f			jp macro_next 
370b				endm 
# End of macro NEXTW
370b			.NEG: 
370b			 
370b				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
370b 17				db WORD_SYS_CORE+3             
370c 4e 37			dw .DIV            
370e 02				db 1 + 1 
370f .. 00			db "-",0              
3711				endm 
# End of macro CWHEAD
3711			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3711					if DEBUG_FORTH_WORDS_KEY 
3711						DMARK "SUB" 
3711 f5				push af  
3712 3a 26 37			ld a, (.dmark)  
3715 32 6b ee			ld (debug_mark),a  
3718 3a 27 37			ld a, (.dmark+1)  
371b 32 6c ee			ld (debug_mark+1),a  
371e 3a 28 37			ld a, (.dmark+2)  
3721 32 6d ee			ld (debug_mark+2),a  
3724 18 03			jr .pastdmark  
3726 ..			.dmark: db "SUB"  
3729 f1			.pastdmark: pop af  
372a			endm  
# End of macro DMARK
372a						CALLMONITOR 
372a cd 6f ee			call debug_vector  
372d				endm  
# End of macro CALLMONITOR
372d					endif 
372d			 
372d			 
372d				; TODO add floating point number detection 
372d					; v5 FORTH_DSP_VALUE 
372d					FORTH_DSP 
372d cd 02 1e			call macro_forth_dsp 
3730				endm 
# End of macro FORTH_DSP
3730 7e					ld a,(hl)	; get type of value on TOS 
3731 fe 02				cp DS_TYPE_INUM  
3733 28 03				jr z, .neg_inum 
3735			 
3735					NEXTW 
3735 c3 f2 1f			jp macro_next 
3738				endm 
# End of macro NEXTW
3738			 
3738			; float maths 
3738			 
3738				if FORTH_ENABLE_FLOATMATH 
3738					jr .neg_done 
3738			 
3738				endif 
3738					 
3738			 
3738			.neg_inum: 
3738					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3738 cd 3c 1e			call macro_dsp_valuehl 
373b				endm 
# End of macro FORTH_DSP_VALUEHL
373b			 
373b e5					push hl 
373c			 
373c					; destroy value TOS 
373c			 
373c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373c cd f4 1e			call macro_forth_dsp_pop 
373f				endm 
# End of macro FORTH_DSP_POP
373f			 
373f			 
373f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
373f cd 3c 1e			call macro_dsp_valuehl 
3742				endm 
# End of macro FORTH_DSP_VALUEHL
3742			 
3742					; one value on hl get other one back 
3742			 
3742 d1					pop de 
3743			 
3743					; do the sub 
3743			;		ex de, hl 
3743			 
3743 ed 52				sbc hl,de 
3745			 
3745					; save it 
3745			 
3745			;		push hl	 
3745			 
3745					; 
3745			 
3745					; destroy value TOS 
3745			 
3745					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3745 cd f4 1e			call macro_forth_dsp_pop 
3748				endm 
# End of macro FORTH_DSP_POP
3748			 
3748					; TODO push value back onto stack for another op etc 
3748			 
3748			;		pop hl 
3748			 
3748 cd 45 1c				call forth_push_numhl 
374b			.neg_done: 
374b			 
374b					NEXTW 
374b c3 f2 1f			jp macro_next 
374e				endm 
# End of macro NEXTW
374e			.DIV: 
374e				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
374e 18				db WORD_SYS_CORE+4             
374f 9b 37			dw .MUL            
3751 02				db 1 + 1 
3752 .. 00			db "/",0              
3754				endm 
# End of macro CWHEAD
3754			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3754					if DEBUG_FORTH_WORDS_KEY 
3754						DMARK "DIV" 
3754 f5				push af  
3755 3a 69 37			ld a, (.dmark)  
3758 32 6b ee			ld (debug_mark),a  
375b 3a 6a 37			ld a, (.dmark+1)  
375e 32 6c ee			ld (debug_mark+1),a  
3761 3a 6b 37			ld a, (.dmark+2)  
3764 32 6d ee			ld (debug_mark+2),a  
3767 18 03			jr .pastdmark  
3769 ..			.dmark: db "DIV"  
376c f1			.pastdmark: pop af  
376d			endm  
# End of macro DMARK
376d						CALLMONITOR 
376d cd 6f ee			call debug_vector  
3770				endm  
# End of macro CALLMONITOR
3770					endif 
3770				; TODO add floating point number detection 
3770					; v5 FORTH_DSP_VALUE 
3770					FORTH_DSP 
3770 cd 02 1e			call macro_forth_dsp 
3773				endm 
# End of macro FORTH_DSP
3773 7e					ld a,(hl)	; get type of value on TOS 
3774 fe 02				cp DS_TYPE_INUM  
3776 28 03				jr z, .div_inum 
3778			 
3778				if FORTH_ENABLE_FLOATMATH 
3778					jr .div_done 
3778			 
3778				endif 
3778					NEXTW 
3778 c3 f2 1f			jp macro_next 
377b				endm 
# End of macro NEXTW
377b			.div_inum: 
377b			 
377b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377b cd 3c 1e			call macro_dsp_valuehl 
377e				endm 
# End of macro FORTH_DSP_VALUEHL
377e			 
377e e5					push hl    ; to go to bc 
377f			 
377f					; destroy value TOS 
377f			 
377f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
377f cd f4 1e			call macro_forth_dsp_pop 
3782				endm 
# End of macro FORTH_DSP_POP
3782			 
3782			 
3782					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3782 cd 3c 1e			call macro_dsp_valuehl 
3785				endm 
# End of macro FORTH_DSP_VALUEHL
3785			 
3785					; hl to go to de 
3785			 
3785 e5					push hl 
3786			 
3786 c1					pop bc 
3787 d1					pop de		 
3788			 
3788			 
3788					if DEBUG_FORTH_MATHS 
3788						DMARK "DIV" 
3788				CALLMONITOR 
3788					endif 
3788					; one value on hl but move to a get other one back 
3788			 
3788			        
3788 cd 44 0d			call Div16 
378b			 
378b			;	push af	 
378b e5				push hl 
378c c5				push bc 
378d			 
378d					if DEBUG_FORTH_MATHS 
378d						DMARK "DI1" 
378d				CALLMONITOR 
378d					endif 
378d			 
378d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378d cd f4 1e			call macro_forth_dsp_pop 
3790				endm 
# End of macro FORTH_DSP_POP
3790			 
3790			 
3790			 
3790 e1					pop hl    ; result 
3791			 
3791 cd 45 1c				call forth_push_numhl 
3794			 
3794 e1					pop hl    ; reminder 
3795			;		ld h,0 
3795			;		ld l,d 
3795			 
3795 cd 45 1c				call forth_push_numhl 
3798			.div_done: 
3798					NEXTW 
3798 c3 f2 1f			jp macro_next 
379b				endm 
# End of macro NEXTW
379b			.MUL: 
379b				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
379b 19				db WORD_SYS_CORE+5             
379c e0 37			dw .MIN            
379e 02				db 1 + 1 
379f .. 00			db "*",0              
37a1				endm 
# End of macro CWHEAD
37a1			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37a1				; TODO add floating point number detection 
37a1					if DEBUG_FORTH_WORDS_KEY 
37a1						DMARK "MUL" 
37a1 f5				push af  
37a2 3a b6 37			ld a, (.dmark)  
37a5 32 6b ee			ld (debug_mark),a  
37a8 3a b7 37			ld a, (.dmark+1)  
37ab 32 6c ee			ld (debug_mark+1),a  
37ae 3a b8 37			ld a, (.dmark+2)  
37b1 32 6d ee			ld (debug_mark+2),a  
37b4 18 03			jr .pastdmark  
37b6 ..			.dmark: db "MUL"  
37b9 f1			.pastdmark: pop af  
37ba			endm  
# End of macro DMARK
37ba						CALLMONITOR 
37ba cd 6f ee			call debug_vector  
37bd				endm  
# End of macro CALLMONITOR
37bd					endif 
37bd					FORTH_DSP 
37bd cd 02 1e			call macro_forth_dsp 
37c0				endm 
# End of macro FORTH_DSP
37c0					; v5 FORTH_DSP_VALUE 
37c0 7e					ld a,(hl)	; get type of value on TOS 
37c1 fe 02				cp DS_TYPE_INUM  
37c3 28 03				jr z, .mul_inum 
37c5			 
37c5				if FORTH_ENABLE_FLOATMATH 
37c5					jr .mul_done 
37c5			 
37c5				endif 
37c5			 
37c5					NEXTW 
37c5 c3 f2 1f			jp macro_next 
37c8				endm 
# End of macro NEXTW
37c8			.mul_inum:	 
37c8			 
37c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37c8 cd 3c 1e			call macro_dsp_valuehl 
37cb				endm 
# End of macro FORTH_DSP_VALUEHL
37cb			 
37cb e5					push hl 
37cc			 
37cc					; destroy value TOS 
37cc			 
37cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37cc cd f4 1e			call macro_forth_dsp_pop 
37cf				endm 
# End of macro FORTH_DSP_POP
37cf			 
37cf			 
37cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37cf cd 3c 1e			call macro_dsp_valuehl 
37d2				endm 
# End of macro FORTH_DSP_VALUEHL
37d2			 
37d2					; one value on hl but move to a get other one back 
37d2			 
37d2 7d					ld a, l 
37d3			 
37d3 d1					pop de 
37d4			 
37d4					; do the mull 
37d4			;		ex de, hl 
37d4			 
37d4 cd 6a 0d				call Mult16 
37d7					; save it 
37d7			 
37d7			;		push hl	 
37d7			 
37d7					; 
37d7			 
37d7					; destroy value TOS 
37d7			 
37d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d7 cd f4 1e			call macro_forth_dsp_pop 
37da				endm 
# End of macro FORTH_DSP_POP
37da			 
37da					; TODO push value back onto stack for another op etc 
37da			 
37da			;		pop hl 
37da			 
37da cd 45 1c				call forth_push_numhl 
37dd			 
37dd			.mul_done: 
37dd					NEXTW 
37dd c3 f2 1f			jp macro_next 
37e0				endm 
# End of macro NEXTW
37e0			 
37e0			 
37e0			 
37e0			 
37e0			.MIN: 
37e0				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37e0 49				db WORD_SYS_CORE+53             
37e1 61 38			dw .MAX            
37e3 04				db 3 + 1 
37e4 .. 00			db "MIN",0              
37e8				endm 
# End of macro CWHEAD
37e8			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37e8					if DEBUG_FORTH_WORDS_KEY 
37e8						DMARK "MIN" 
37e8 f5				push af  
37e9 3a fd 37			ld a, (.dmark)  
37ec 32 6b ee			ld (debug_mark),a  
37ef 3a fe 37			ld a, (.dmark+1)  
37f2 32 6c ee			ld (debug_mark+1),a  
37f5 3a ff 37			ld a, (.dmark+2)  
37f8 32 6d ee			ld (debug_mark+2),a  
37fb 18 03			jr .pastdmark  
37fd ..			.dmark: db "MIN"  
3800 f1			.pastdmark: pop af  
3801			endm  
# End of macro DMARK
3801						CALLMONITOR 
3801 cd 6f ee			call debug_vector  
3804				endm  
# End of macro CALLMONITOR
3804					endif 
3804					; get u2 
3804			 
3804					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3804 cd 3c 1e			call macro_dsp_valuehl 
3807				endm 
# End of macro FORTH_DSP_VALUEHL
3807			 
3807 e5					push hl   ; u2 
3808			 
3808					; destroy value TOS 
3808			 
3808					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3808 cd f4 1e			call macro_forth_dsp_pop 
380b				endm 
# End of macro FORTH_DSP_POP
380b			 
380b					; get u1 
380b			 
380b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380b cd 3c 1e			call macro_dsp_valuehl 
380e				endm 
# End of macro FORTH_DSP_VALUEHL
380e			 
380e e5					push hl  ; u1 
380f			 
380f					; destroy value TOS 
380f			 
380f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380f cd f4 1e			call macro_forth_dsp_pop 
3812				endm 
# End of macro FORTH_DSP_POP
3812			 
3812 b7			 or a      ;clear carry flag 
3813 e1			  pop hl    ; u1 
3814 d1			  pop de    ; u2 
3815 e5				push hl   ; saved in case hl is lowest 
3816 ed 52		  sbc hl,de 
3818 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
381a			 
381a e1				pop hl 
381b					if DEBUG_FORTH_WORDS 
381b						DMARK "MIN" 
381b f5				push af  
381c 3a 30 38			ld a, (.dmark)  
381f 32 6b ee			ld (debug_mark),a  
3822 3a 31 38			ld a, (.dmark+1)  
3825 32 6c ee			ld (debug_mark+1),a  
3828 3a 32 38			ld a, (.dmark+2)  
382b 32 6d ee			ld (debug_mark+2),a  
382e 18 03			jr .pastdmark  
3830 ..			.dmark: db "MIN"  
3833 f1			.pastdmark: pop af  
3834			endm  
# End of macro DMARK
3834						CALLMONITOR 
3834 cd 6f ee			call debug_vector  
3837				endm  
# End of macro CALLMONITOR
3837					endif 
3837 cd 45 1c				call forth_push_numhl 
383a			 
383a				       NEXTW 
383a c3 f2 1f			jp macro_next 
383d				endm 
# End of macro NEXTW
383d			 
383d			.mincont:  
383d c1				pop bc   ; tidy up 
383e eb				ex de , hl  
383f					if DEBUG_FORTH_WORDS 
383f						DMARK "MI1" 
383f f5				push af  
3840 3a 54 38			ld a, (.dmark)  
3843 32 6b ee			ld (debug_mark),a  
3846 3a 55 38			ld a, (.dmark+1)  
3849 32 6c ee			ld (debug_mark+1),a  
384c 3a 56 38			ld a, (.dmark+2)  
384f 32 6d ee			ld (debug_mark+2),a  
3852 18 03			jr .pastdmark  
3854 ..			.dmark: db "MI1"  
3857 f1			.pastdmark: pop af  
3858			endm  
# End of macro DMARK
3858						CALLMONITOR 
3858 cd 6f ee			call debug_vector  
385b				endm  
# End of macro CALLMONITOR
385b					endif 
385b cd 45 1c				call forth_push_numhl 
385e			 
385e				       NEXTW 
385e c3 f2 1f			jp macro_next 
3861				endm 
# End of macro NEXTW
3861			.MAX: 
3861				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3861 4a				db WORD_SYS_CORE+54             
3862 e2 38			dw .RND16            
3864 04				db 3 + 1 
3865 .. 00			db "MAX",0              
3869				endm 
# End of macro CWHEAD
3869			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3869					if DEBUG_FORTH_WORDS_KEY 
3869						DMARK "MAX" 
3869 f5				push af  
386a 3a 7e 38			ld a, (.dmark)  
386d 32 6b ee			ld (debug_mark),a  
3870 3a 7f 38			ld a, (.dmark+1)  
3873 32 6c ee			ld (debug_mark+1),a  
3876 3a 80 38			ld a, (.dmark+2)  
3879 32 6d ee			ld (debug_mark+2),a  
387c 18 03			jr .pastdmark  
387e ..			.dmark: db "MAX"  
3881 f1			.pastdmark: pop af  
3882			endm  
# End of macro DMARK
3882						CALLMONITOR 
3882 cd 6f ee			call debug_vector  
3885				endm  
# End of macro CALLMONITOR
3885					endif 
3885					; get u2 
3885			 
3885					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3885 cd 3c 1e			call macro_dsp_valuehl 
3888				endm 
# End of macro FORTH_DSP_VALUEHL
3888			 
3888 e5					push hl   ; u2 
3889			 
3889					; destroy value TOS 
3889			 
3889					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3889 cd f4 1e			call macro_forth_dsp_pop 
388c				endm 
# End of macro FORTH_DSP_POP
388c			 
388c					; get u1 
388c			 
388c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
388c cd 3c 1e			call macro_dsp_valuehl 
388f				endm 
# End of macro FORTH_DSP_VALUEHL
388f			 
388f e5					push hl  ; u1 
3890			 
3890					; destroy value TOS 
3890			 
3890					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3890 cd f4 1e			call macro_forth_dsp_pop 
3893				endm 
# End of macro FORTH_DSP_POP
3893			 
3893 b7			 or a      ;clear carry flag 
3894 e1			  pop hl    ; u1 
3895 d1			  pop de    ; u2 
3896 e5				push hl   ; saved in case hl is lowest 
3897 ed 52		  sbc hl,de 
3899 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
389b			 
389b e1				pop hl 
389c					if DEBUG_FORTH_WORDS 
389c						DMARK "MAX" 
389c f5				push af  
389d 3a b1 38			ld a, (.dmark)  
38a0 32 6b ee			ld (debug_mark),a  
38a3 3a b2 38			ld a, (.dmark+1)  
38a6 32 6c ee			ld (debug_mark+1),a  
38a9 3a b3 38			ld a, (.dmark+2)  
38ac 32 6d ee			ld (debug_mark+2),a  
38af 18 03			jr .pastdmark  
38b1 ..			.dmark: db "MAX"  
38b4 f1			.pastdmark: pop af  
38b5			endm  
# End of macro DMARK
38b5						CALLMONITOR 
38b5 cd 6f ee			call debug_vector  
38b8				endm  
# End of macro CALLMONITOR
38b8					endif 
38b8 cd 45 1c				call forth_push_numhl 
38bb			 
38bb				       NEXTW 
38bb c3 f2 1f			jp macro_next 
38be				endm 
# End of macro NEXTW
38be			 
38be			.maxcont:  
38be c1				pop bc   ; tidy up 
38bf eb				ex de , hl  
38c0					if DEBUG_FORTH_WORDS 
38c0						DMARK "MA1" 
38c0 f5				push af  
38c1 3a d5 38			ld a, (.dmark)  
38c4 32 6b ee			ld (debug_mark),a  
38c7 3a d6 38			ld a, (.dmark+1)  
38ca 32 6c ee			ld (debug_mark+1),a  
38cd 3a d7 38			ld a, (.dmark+2)  
38d0 32 6d ee			ld (debug_mark+2),a  
38d3 18 03			jr .pastdmark  
38d5 ..			.dmark: db "MA1"  
38d8 f1			.pastdmark: pop af  
38d9			endm  
# End of macro DMARK
38d9						CALLMONITOR 
38d9 cd 6f ee			call debug_vector  
38dc				endm  
# End of macro CALLMONITOR
38dc					endif 
38dc cd 45 1c				call forth_push_numhl 
38df				       NEXTW 
38df c3 f2 1f			jp macro_next 
38e2				endm 
# End of macro NEXTW
38e2			 
38e2			.RND16: 
38e2				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38e2 4e				db WORD_SYS_CORE+58             
38e3 11 39			dw .RND8            
38e5 06				db 5 + 1 
38e6 .. 00			db "RND16",0              
38ec				endm 
# End of macro CWHEAD
38ec			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38ec					if DEBUG_FORTH_WORDS_KEY 
38ec						DMARK "R16" 
38ec f5				push af  
38ed 3a 01 39			ld a, (.dmark)  
38f0 32 6b ee			ld (debug_mark),a  
38f3 3a 02 39			ld a, (.dmark+1)  
38f6 32 6c ee			ld (debug_mark+1),a  
38f9 3a 03 39			ld a, (.dmark+2)  
38fc 32 6d ee			ld (debug_mark+2),a  
38ff 18 03			jr .pastdmark  
3901 ..			.dmark: db "R16"  
3904 f1			.pastdmark: pop af  
3905			endm  
# End of macro DMARK
3905						CALLMONITOR 
3905 cd 6f ee			call debug_vector  
3908				endm  
# End of macro CALLMONITOR
3908					endif 
3908 cd 0e 0d				call prng16  
390b cd 45 1c				call forth_push_numhl 
390e				       NEXTW 
390e c3 f2 1f			jp macro_next 
3911				endm 
# End of macro NEXTW
3911			.RND8: 
3911				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3911 60				db WORD_SYS_CORE+76             
3912 46 39			dw .RND            
3914 05				db 4 + 1 
3915 .. 00			db "RND8",0              
391a				endm 
# End of macro CWHEAD
391a			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
391a					if DEBUG_FORTH_WORDS_KEY 
391a						DMARK "RN8" 
391a f5				push af  
391b 3a 2f 39			ld a, (.dmark)  
391e 32 6b ee			ld (debug_mark),a  
3921 3a 30 39			ld a, (.dmark+1)  
3924 32 6c ee			ld (debug_mark+1),a  
3927 3a 31 39			ld a, (.dmark+2)  
392a 32 6d ee			ld (debug_mark+2),a  
392d 18 03			jr .pastdmark  
392f ..			.dmark: db "RN8"  
3932 f1			.pastdmark: pop af  
3933			endm  
# End of macro DMARK
3933						CALLMONITOR 
3933 cd 6f ee			call debug_vector  
3936				endm  
# End of macro CALLMONITOR
3936					endif 
3936 2a a9 eb				ld hl,(xrandc) 
3939 23					inc hl 
393a cd 28 0d				call xrnd 
393d 6f					ld l,a	 
393e 26 00				ld h,0 
3940 cd 45 1c				call forth_push_numhl 
3943				       NEXTW 
3943 c3 f2 1f			jp macro_next 
3946				endm 
# End of macro NEXTW
3946			.RND: 
3946				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3946 60				db WORD_SYS_CORE+76             
3947 4c 3a			dw .ENDMATHS            
3949 04				db 3 + 1 
394a .. 00			db "RND",0              
394e				endm 
# End of macro CWHEAD
394e			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
394e			 
394e					if DEBUG_FORTH_WORDS_KEY 
394e						DMARK "RND" 
394e f5				push af  
394f 3a 63 39			ld a, (.dmark)  
3952 32 6b ee			ld (debug_mark),a  
3955 3a 64 39			ld a, (.dmark+1)  
3958 32 6c ee			ld (debug_mark+1),a  
395b 3a 65 39			ld a, (.dmark+2)  
395e 32 6d ee			ld (debug_mark+2),a  
3961 18 03			jr .pastdmark  
3963 ..			.dmark: db "RND"  
3966 f1			.pastdmark: pop af  
3967			endm  
# End of macro DMARK
3967						CALLMONITOR 
3967 cd 6f ee			call debug_vector  
396a				endm  
# End of macro CALLMONITOR
396a					endif 
396a					 
396a					FORTH_DSP_VALUEHL    ; upper range 
396a cd 3c 1e			call macro_dsp_valuehl 
396d				endm 
# End of macro FORTH_DSP_VALUEHL
396d			 
396d 22 ad eb				ld (LFSRSeed), hl	 
3970			 
3970					if DEBUG_FORTH_WORDS 
3970						DMARK "RN1" 
3970 f5				push af  
3971 3a 85 39			ld a, (.dmark)  
3974 32 6b ee			ld (debug_mark),a  
3977 3a 86 39			ld a, (.dmark+1)  
397a 32 6c ee			ld (debug_mark+1),a  
397d 3a 87 39			ld a, (.dmark+2)  
3980 32 6d ee			ld (debug_mark+2),a  
3983 18 03			jr .pastdmark  
3985 ..			.dmark: db "RN1"  
3988 f1			.pastdmark: pop af  
3989			endm  
# End of macro DMARK
3989						CALLMONITOR 
3989 cd 6f ee			call debug_vector  
398c				endm  
# End of macro CALLMONITOR
398c					endif 
398c					FORTH_DSP_POP 
398c cd f4 1e			call macro_forth_dsp_pop 
398f				endm 
# End of macro FORTH_DSP_POP
398f			 
398f					FORTH_DSP_VALUEHL    ; low range 
398f cd 3c 1e			call macro_dsp_valuehl 
3992				endm 
# End of macro FORTH_DSP_VALUEHL
3992			 
3992					if DEBUG_FORTH_WORDS 
3992						DMARK "RN2" 
3992 f5				push af  
3993 3a a7 39			ld a, (.dmark)  
3996 32 6b ee			ld (debug_mark),a  
3999 3a a8 39			ld a, (.dmark+1)  
399c 32 6c ee			ld (debug_mark+1),a  
399f 3a a9 39			ld a, (.dmark+2)  
39a2 32 6d ee			ld (debug_mark+2),a  
39a5 18 03			jr .pastdmark  
39a7 ..			.dmark: db "RN2"  
39aa f1			.pastdmark: pop af  
39ab			endm  
# End of macro DMARK
39ab						CALLMONITOR 
39ab cd 6f ee			call debug_vector  
39ae				endm  
# End of macro CALLMONITOR
39ae					endif 
39ae 22 af eb				ld (LFSRSeed+2), hl 
39b1			 
39b1					FORTH_DSP_POP 
39b1 cd f4 1e			call macro_forth_dsp_pop 
39b4				endm 
# End of macro FORTH_DSP_POP
39b4			 
39b4 e5					push hl 
39b5			 
39b5 e1			.inrange:	pop hl 
39b6 cd 0e 0d				call prng16  
39b9					if DEBUG_FORTH_WORDS 
39b9						DMARK "RN3" 
39b9 f5				push af  
39ba 3a ce 39			ld a, (.dmark)  
39bd 32 6b ee			ld (debug_mark),a  
39c0 3a cf 39			ld a, (.dmark+1)  
39c3 32 6c ee			ld (debug_mark+1),a  
39c6 3a d0 39			ld a, (.dmark+2)  
39c9 32 6d ee			ld (debug_mark+2),a  
39cc 18 03			jr .pastdmark  
39ce ..			.dmark: db "RN3"  
39d1 f1			.pastdmark: pop af  
39d2			endm  
# End of macro DMARK
39d2						CALLMONITOR 
39d2 cd 6f ee			call debug_vector  
39d5				endm  
# End of macro CALLMONITOR
39d5					endif 
39d5					 
39d5					; if the range is 8bit knock out the high byte 
39d5			 
39d5 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
39d9			 
39d9 3e 00				ld a, 0 
39db ba					cp d  
39dc 20 1e				jr nz, .hirange 
39de 26 00				ld h, 0   ; knock it down to 8bit 
39e0			 
39e0					if DEBUG_FORTH_WORDS 
39e0						DMARK "RNk" 
39e0 f5				push af  
39e1 3a f5 39			ld a, (.dmark)  
39e4 32 6b ee			ld (debug_mark),a  
39e7 3a f6 39			ld a, (.dmark+1)  
39ea 32 6c ee			ld (debug_mark+1),a  
39ed 3a f7 39			ld a, (.dmark+2)  
39f0 32 6d ee			ld (debug_mark+2),a  
39f3 18 03			jr .pastdmark  
39f5 ..			.dmark: db "RNk"  
39f8 f1			.pastdmark: pop af  
39f9			endm  
# End of macro DMARK
39f9						CALLMONITOR 
39f9 cd 6f ee			call debug_vector  
39fc				endm  
# End of macro CALLMONITOR
39fc					endif 
39fc			.hirange:   
39fc e5					push hl  
39fd b7					or a  
39fe ed 52		                sbc hl, de 
3a00			 
3a00					;call cmp16 
3a00			 
3a00 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a02 e1					pop hl 
3a03 e5					push hl 
3a04			 
3a04					if DEBUG_FORTH_WORDS 
3a04						DMARK "RN4" 
3a04 f5				push af  
3a05 3a 19 3a			ld a, (.dmark)  
3a08 32 6b ee			ld (debug_mark),a  
3a0b 3a 1a 3a			ld a, (.dmark+1)  
3a0e 32 6c ee			ld (debug_mark+1),a  
3a11 3a 1b 3a			ld a, (.dmark+2)  
3a14 32 6d ee			ld (debug_mark+2),a  
3a17 18 03			jr .pastdmark  
3a19 ..			.dmark: db "RN4"  
3a1c f1			.pastdmark: pop af  
3a1d			endm  
# End of macro DMARK
3a1d						CALLMONITOR 
3a1d cd 6f ee			call debug_vector  
3a20				endm  
# End of macro CALLMONITOR
3a20					endif 
3a20 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
3a24					;call cmp16 
3a24				 
3a24 b7					or a  
3a25 ed 52		                sbc hl, de 
3a27 38 8c				jr c, .inrange 
3a29			 
3a29 e1					pop hl 
3a2a					 
3a2a					if DEBUG_FORTH_WORDS 
3a2a						DMARK "RNd" 
3a2a f5				push af  
3a2b 3a 3f 3a			ld a, (.dmark)  
3a2e 32 6b ee			ld (debug_mark),a  
3a31 3a 40 3a			ld a, (.dmark+1)  
3a34 32 6c ee			ld (debug_mark+1),a  
3a37 3a 41 3a			ld a, (.dmark+2)  
3a3a 32 6d ee			ld (debug_mark+2),a  
3a3d 18 03			jr .pastdmark  
3a3f ..			.dmark: db "RNd"  
3a42 f1			.pastdmark: pop af  
3a43			endm  
# End of macro DMARK
3a43						CALLMONITOR 
3a43 cd 6f ee			call debug_vector  
3a46				endm  
# End of macro CALLMONITOR
3a46					endif 
3a46			 
3a46			 
3a46 cd 45 1c				call forth_push_numhl 
3a49				       NEXTW 
3a49 c3 f2 1f			jp macro_next 
3a4c				endm 
# End of macro NEXTW
3a4c			 
3a4c			.ENDMATHS: 
3a4c			 
3a4c			; eof 
3a4c			 
# End of file forth_words_maths.asm
3a4c			include "forth_words_display.asm" 
3a4c			 
3a4c			; | ## Display Words 
3a4c			 
3a4c			.ACT: 
3a4c			 
3a4c				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3a4c 62				db WORD_SYS_CORE+78             
3a4d 98 3a			dw .INFO            
3a4f 07				db 6 + 1 
3a50 .. 00			db "ACTIVE",0              
3a57				endm 
# End of macro CWHEAD
3a57			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3a57			;  
3a57			; | | e.g. $ff $00 do active . $01 pause loop 
3a57			 
3a57					if DEBUG_FORTH_WORDS_KEY 
3a57						DMARK "ACT" 
3a57 f5				push af  
3a58 3a 6c 3a			ld a, (.dmark)  
3a5b 32 6b ee			ld (debug_mark),a  
3a5e 3a 6d 3a			ld a, (.dmark+1)  
3a61 32 6c ee			ld (debug_mark+1),a  
3a64 3a 6e 3a			ld a, (.dmark+2)  
3a67 32 6d ee			ld (debug_mark+2),a  
3a6a 18 03			jr .pastdmark  
3a6c ..			.dmark: db "ACT"  
3a6f f1			.pastdmark: pop af  
3a70			endm  
# End of macro DMARK
3a70						CALLMONITOR 
3a70 cd 6f ee			call debug_vector  
3a73				endm  
# End of macro CALLMONITOR
3a73					endif 
3a73 cd 11 0b				call active 
3a76					if DEBUG_FORTH_WORDS 
3a76						DMARK "ACp" 
3a76 f5				push af  
3a77 3a 8b 3a			ld a, (.dmark)  
3a7a 32 6b ee			ld (debug_mark),a  
3a7d 3a 8c 3a			ld a, (.dmark+1)  
3a80 32 6c ee			ld (debug_mark+1),a  
3a83 3a 8d 3a			ld a, (.dmark+2)  
3a86 32 6d ee			ld (debug_mark+2),a  
3a89 18 03			jr .pastdmark  
3a8b ..			.dmark: db "ACp"  
3a8e f1			.pastdmark: pop af  
3a8f			endm  
# End of macro DMARK
3a8f						CALLMONITOR 
3a8f cd 6f ee			call debug_vector  
3a92				endm  
# End of macro CALLMONITOR
3a92					endif 
3a92 cd b3 1c				call forth_push_str 
3a95			 
3a95					NEXTW 
3a95 c3 f2 1f			jp macro_next 
3a98				endm 
# End of macro NEXTW
3a98			.INFO: 
3a98			 
3a98				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a98 62				db WORD_SYS_CORE+78             
3a99 b5 3a			dw .ATP            
3a9b 05				db 4 + 1 
3a9c .. 00			db "INFO",0              
3aa1				endm 
# End of macro CWHEAD
3aa1			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3aa1					FORTH_DSP_VALUEHL 
3aa1 cd 3c 1e			call macro_dsp_valuehl 
3aa4				endm 
# End of macro FORTH_DSP_VALUEHL
3aa4			 
3aa4					FORTH_DSP_POP 
3aa4 cd f4 1e			call macro_forth_dsp_pop 
3aa7				endm 
# End of macro FORTH_DSP_POP
3aa7			 
3aa7 e5					push hl 
3aa8			 
3aa8					FORTH_DSP_VALUEHL 
3aa8 cd 3c 1e			call macro_dsp_valuehl 
3aab				endm 
# End of macro FORTH_DSP_VALUEHL
3aab			 
3aab					FORTH_DSP_POP 
3aab cd f4 1e			call macro_forth_dsp_pop 
3aae				endm 
# End of macro FORTH_DSP_POP
3aae			 
3aae d1					pop de 
3aaf			 
3aaf cd 4b 0b				call info_panel 
3ab2			 
3ab2			 
3ab2					NEXTW 
3ab2 c3 f2 1f			jp macro_next 
3ab5				endm 
# End of macro NEXTW
3ab5			.ATP: 
3ab5				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ab5 62				db WORD_SYS_CORE+78             
3ab6 2c 3b			dw .FB            
3ab8 04				db 3 + 1 
3ab9 .. 00			db "AT?",0              
3abd				endm 
# End of macro CWHEAD
3abd			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3abd					if DEBUG_FORTH_WORDS_KEY 
3abd						DMARK "AT?" 
3abd f5				push af  
3abe 3a d2 3a			ld a, (.dmark)  
3ac1 32 6b ee			ld (debug_mark),a  
3ac4 3a d3 3a			ld a, (.dmark+1)  
3ac7 32 6c ee			ld (debug_mark+1),a  
3aca 3a d4 3a			ld a, (.dmark+2)  
3acd 32 6d ee			ld (debug_mark+2),a  
3ad0 18 03			jr .pastdmark  
3ad2 ..			.dmark: db "AT?"  
3ad5 f1			.pastdmark: pop af  
3ad6			endm  
# End of macro DMARK
3ad6						CALLMONITOR 
3ad6 cd 6f ee			call debug_vector  
3ad9				endm  
# End of macro CALLMONITOR
3ad9					endif 
3ad9 3a 5e ea				ld a, (f_cursor_ptr) 
3adc			 
3adc			if DEBUG_FORTH_WORDS 
3adc				DMARK "AT?" 
3adc f5				push af  
3add 3a f1 3a			ld a, (.dmark)  
3ae0 32 6b ee			ld (debug_mark),a  
3ae3 3a f2 3a			ld a, (.dmark+1)  
3ae6 32 6c ee			ld (debug_mark+1),a  
3ae9 3a f3 3a			ld a, (.dmark+2)  
3aec 32 6d ee			ld (debug_mark+2),a  
3aef 18 03			jr .pastdmark  
3af1 ..			.dmark: db "AT?"  
3af4 f1			.pastdmark: pop af  
3af5			endm  
# End of macro DMARK
3af5				CALLMONITOR 
3af5 cd 6f ee			call debug_vector  
3af8				endm  
# End of macro CALLMONITOR
3af8			endif	 
3af8					; count the number of rows 
3af8			 
3af8 06 00				ld b, 0 
3afa 4f			.atpr:		ld c, a    ; save in case we go below zero 
3afb d6 28				sub display_cols 
3afd f2 03 3b				jp p, .atprunder 
3b00 04					inc b 
3b01 18 f7				jr .atpr 
3b03			.atprunder:	 
3b03			if DEBUG_FORTH_WORDS 
3b03				DMARK "A?2" 
3b03 f5				push af  
3b04 3a 18 3b			ld a, (.dmark)  
3b07 32 6b ee			ld (debug_mark),a  
3b0a 3a 19 3b			ld a, (.dmark+1)  
3b0d 32 6c ee			ld (debug_mark+1),a  
3b10 3a 1a 3b			ld a, (.dmark+2)  
3b13 32 6d ee			ld (debug_mark+2),a  
3b16 18 03			jr .pastdmark  
3b18 ..			.dmark: db "A?2"  
3b1b f1			.pastdmark: pop af  
3b1c			endm  
# End of macro DMARK
3b1c				CALLMONITOR 
3b1c cd 6f ee			call debug_vector  
3b1f				endm  
# End of macro CALLMONITOR
3b1f			endif	 
3b1f 26 00				ld h, 0 
3b21 69					ld l, c 
3b22 cd 45 1c				call forth_push_numhl 
3b25 68					ld l, b  
3b26 cd 45 1c				call forth_push_numhl 
3b29			 
3b29			 
3b29				NEXTW 
3b29 c3 f2 1f			jp macro_next 
3b2c				endm 
# End of macro NEXTW
3b2c			 
3b2c			.FB: 
3b2c				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b2c 1b				db WORD_SYS_CORE+7             
3b2d 7a 3b			dw .EMIT            
3b2f 03				db 2 + 1 
3b30 .. 00			db "FB",0              
3b33				endm 
# End of macro CWHEAD
3b33			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b33			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b33			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b33			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b33					if DEBUG_FORTH_WORDS_KEY 
3b33						DMARK "FB." 
3b33 f5				push af  
3b34 3a 48 3b			ld a, (.dmark)  
3b37 32 6b ee			ld (debug_mark),a  
3b3a 3a 49 3b			ld a, (.dmark+1)  
3b3d 32 6c ee			ld (debug_mark+1),a  
3b40 3a 4a 3b			ld a, (.dmark+2)  
3b43 32 6d ee			ld (debug_mark+2),a  
3b46 18 03			jr .pastdmark  
3b48 ..			.dmark: db "FB."  
3b4b f1			.pastdmark: pop af  
3b4c			endm  
# End of macro DMARK
3b4c						CALLMONITOR 
3b4c cd 6f ee			call debug_vector  
3b4f				endm  
# End of macro CALLMONITOR
3b4f					endif 
3b4f			 
3b4f					FORTH_DSP_VALUEHL 
3b4f cd 3c 1e			call macro_dsp_valuehl 
3b52				endm 
# End of macro FORTH_DSP_VALUEHL
3b52			 
3b52 7d					ld a, l 
3b53 fe 01				cp 1 
3b55 20 05				jr nz, .fbn1 
3b57 21 10 ed				ld hl, display_fb1 
3b5a 18 15				jr .fbset 
3b5c fe 02		.fbn1:		cp 2 
3b5e 20 05				jr nz, .fbn2 
3b60 21 ce eb				ld hl, display_fb2 
3b63 18 0c				jr .fbset 
3b65 fe 03		.fbn2:		cp 3 
3b67 20 05				jr nz, .fbn3 
3b69 21 6f ec				ld hl, display_fb3 
3b6c 18 03				jr .fbset 
3b6e			.fbn3:		 ; if invalid number select first 
3b6e 21 10 ed				ld hl, display_fb1 
3b71 22 cc eb		.fbset:		ld (display_fb_active), hl 
3b74			 
3b74					FORTH_DSP_POP 
3b74 cd f4 1e			call macro_forth_dsp_pop 
3b77				endm 
# End of macro FORTH_DSP_POP
3b77			 
3b77					NEXTW 
3b77 c3 f2 1f			jp macro_next 
3b7a				endm 
# End of macro NEXTW
3b7a			 
3b7a			 
3b7a			.EMIT: 
3b7a				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b7a 1b				db WORD_SYS_CORE+7             
3b7b cb 3b			dw .DOTH            
3b7d 05				db 4 + 1 
3b7e .. 00			db "EMIT",0              
3b83				endm 
# End of macro CWHEAD
3b83			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b83					; get value off TOS and display it 
3b83			 
3b83					if DEBUG_FORTH_WORDS_KEY 
3b83						DMARK "EMT" 
3b83 f5				push af  
3b84 3a 98 3b			ld a, (.dmark)  
3b87 32 6b ee			ld (debug_mark),a  
3b8a 3a 99 3b			ld a, (.dmark+1)  
3b8d 32 6c ee			ld (debug_mark+1),a  
3b90 3a 9a 3b			ld a, (.dmark+2)  
3b93 32 6d ee			ld (debug_mark+2),a  
3b96 18 03			jr .pastdmark  
3b98 ..			.dmark: db "EMT"  
3b9b f1			.pastdmark: pop af  
3b9c			endm  
# End of macro DMARK
3b9c						CALLMONITOR 
3b9c cd 6f ee			call debug_vector  
3b9f				endm  
# End of macro CALLMONITOR
3b9f					endif 
3b9f			 
3b9f					FORTH_DSP_VALUEHL 
3b9f cd 3c 1e			call macro_dsp_valuehl 
3ba2				endm 
# End of macro FORTH_DSP_VALUEHL
3ba2			 
3ba2 7d					ld a,l 
3ba3			 
3ba3					; TODO write to display 
3ba3			 
3ba3 32 bf e4				ld (os_input), a 
3ba6 3e 00				ld a, 0 
3ba8 32 c0 e4				ld (os_input+1), a 
3bab					 
3bab 3a 5e ea				ld a, (f_cursor_ptr) 
3bae 11 bf e4				ld de, os_input 
3bb1 cd cd 0b				call str_at_display 
3bb4			 
3bb4			 
3bb4 3a 3c ea				ld a,(cli_autodisplay) 
3bb7 fe 00				cp 0 
3bb9 28 03				jr z, .enoupdate 
3bbb cd dd 0b						call update_display 
3bbe					.enoupdate: 
3bbe			 
3bbe 3a 5e ea				ld a, (f_cursor_ptr) 
3bc1 3c					inc a 
3bc2 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3bc5			 
3bc5			 
3bc5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bc5 cd f4 1e			call macro_forth_dsp_pop 
3bc8				endm 
# End of macro FORTH_DSP_POP
3bc8			  
3bc8			 
3bc8					NEXTW 
3bc8 c3 f2 1f			jp macro_next 
3bcb				endm 
# End of macro NEXTW
3bcb			.DOTH: 
3bcb				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3bcb 1c				db WORD_SYS_CORE+8             
3bcc fb 3b			dw .DOTF            
3bce 03				db 2 + 1 
3bcf .. 00			db ".-",0              
3bd2				endm 
# End of macro CWHEAD
3bd2			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3bd2					; get value off TOS and display it 
3bd2					if DEBUG_FORTH_WORDS_KEY 
3bd2						DMARK "DTD" 
3bd2 f5				push af  
3bd3 3a e7 3b			ld a, (.dmark)  
3bd6 32 6b ee			ld (debug_mark),a  
3bd9 3a e8 3b			ld a, (.dmark+1)  
3bdc 32 6c ee			ld (debug_mark+1),a  
3bdf 3a e9 3b			ld a, (.dmark+2)  
3be2 32 6d ee			ld (debug_mark+2),a  
3be5 18 03			jr .pastdmark  
3be7 ..			.dmark: db "DTD"  
3bea f1			.pastdmark: pop af  
3beb			endm  
# End of macro DMARK
3beb						CALLMONITOR 
3beb cd 6f ee			call debug_vector  
3bee				endm  
# End of macro CALLMONITOR
3bee					endif 
3bee 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3bf0 3e 00			ld a, 0 
3bf2 32 3d ea			ld (cli_mvdot), a 
3bf5 c3 52 3c			jp .dotgo 
3bf8				NEXTW 
3bf8 c3 f2 1f			jp macro_next 
3bfb				endm 
# End of macro NEXTW
3bfb			.DOTF: 
3bfb				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bfb 1c				db WORD_SYS_CORE+8             
3bfc 29 3c			dw .DOT            
3bfe 03				db 2 + 1 
3bff .. 00			db ".>",0              
3c02				endm 
# End of macro CWHEAD
3c02			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3c02					; get value off TOS and display it 
3c02			        ; TODO BUG adds extra spaces 
3c02			        ; TODO BUG handle numerics? 
3c02					if DEBUG_FORTH_WORDS_KEY 
3c02						DMARK "DTC" 
3c02 f5				push af  
3c03 3a 17 3c			ld a, (.dmark)  
3c06 32 6b ee			ld (debug_mark),a  
3c09 3a 18 3c			ld a, (.dmark+1)  
3c0c 32 6c ee			ld (debug_mark+1),a  
3c0f 3a 19 3c			ld a, (.dmark+2)  
3c12 32 6d ee			ld (debug_mark+2),a  
3c15 18 03			jr .pastdmark  
3c17 ..			.dmark: db "DTC"  
3c1a f1			.pastdmark: pop af  
3c1b			endm  
# End of macro DMARK
3c1b						CALLMONITOR 
3c1b cd 6f ee			call debug_vector  
3c1e				endm  
# End of macro CALLMONITOR
3c1e					endif 
3c1e 3e 01			ld a, 1 
3c20 32 3d ea			ld (cli_mvdot), a 
3c23 c3 52 3c			jp .dotgo 
3c26				NEXTW 
3c26 c3 f2 1f			jp macro_next 
3c29				endm 
# End of macro NEXTW
3c29			 
3c29			.DOT: 
3c29				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c29 1c				db WORD_SYS_CORE+8             
3c2a 05 3e			dw .CLS            
3c2c 02				db 1 + 1 
3c2d .. 00			db ".",0              
3c2f				endm 
# End of macro CWHEAD
3c2f			        ; | . ( u -- ) Display TOS | DONE 
3c2f					; get value off TOS and display it 
3c2f			 
3c2f					if DEBUG_FORTH_WORDS_KEY 
3c2f						DMARK "DOT" 
3c2f f5				push af  
3c30 3a 44 3c			ld a, (.dmark)  
3c33 32 6b ee			ld (debug_mark),a  
3c36 3a 45 3c			ld a, (.dmark+1)  
3c39 32 6c ee			ld (debug_mark+1),a  
3c3c 3a 46 3c			ld a, (.dmark+2)  
3c3f 32 6d ee			ld (debug_mark+2),a  
3c42 18 03			jr .pastdmark  
3c44 ..			.dmark: db "DOT"  
3c47 f1			.pastdmark: pop af  
3c48			endm  
# End of macro DMARK
3c48						CALLMONITOR 
3c48 cd 6f ee			call debug_vector  
3c4b				endm  
# End of macro CALLMONITOR
3c4b					endif 
3c4b 3e 00			ld a, 0 
3c4d 32 3d ea			ld (cli_mvdot), a 
3c50 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c52				 
3c52			 
3c52			.dotgo: 
3c52			 
3c52			; move up type to on stack for parserv5 
3c52					FORTH_DSP 
3c52 cd 02 1e			call macro_forth_dsp 
3c55				endm 
# End of macro FORTH_DSP
3c55				;FORTH_DSP_VALUE  
3c55			 
3c55			if DEBUG_FORTH_DOT 
3c55				DMARK "DOT" 
3c55 f5				push af  
3c56 3a 6a 3c			ld a, (.dmark)  
3c59 32 6b ee			ld (debug_mark),a  
3c5c 3a 6b 3c			ld a, (.dmark+1)  
3c5f 32 6c ee			ld (debug_mark+1),a  
3c62 3a 6c 3c			ld a, (.dmark+2)  
3c65 32 6d ee			ld (debug_mark+2),a  
3c68 18 03			jr .pastdmark  
3c6a ..			.dmark: db "DOT"  
3c6d f1			.pastdmark: pop af  
3c6e			endm  
# End of macro DMARK
3c6e				CALLMONITOR 
3c6e cd 6f ee			call debug_vector  
3c71				endm  
# End of macro CALLMONITOR
3c71			endif	 
3c71			;		.print: 
3c71			 
3c71 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c72 23				inc hl   ; position to the actual value 
3c73 fe 01			cp DS_TYPE_STR 
3c75 20 06			jr nz, .dotnum1  
3c77			 
3c77			; display string 
3c77				FORTH_DSP_VALUE  
3c77 cd 25 1e			call macro_forth_dsp_value 
3c7a				endm 
# End of macro FORTH_DSP_VALUE
3c7a eb				ex de,hl 
3c7b 18 49			jr .dotwrite 
3c7d			 
3c7d			.dotnum1: 
3c7d fe 02			cp DS_TYPE_INUM 
3c7f 20 44			jr nz, .dotflot 
3c81			 
3c81			 
3c81			; display number 
3c81			 
3c81			;	push hl 
3c81			;	call clear_display 
3c81			;	pop hl 
3c81			 
3c81 5e				ld e, (hl) 
3c82 23				inc hl 
3c83 56				ld d, (hl) 
3c84 21 c1 e2			ld hl, scratch 
3c87			if DEBUG_FORTH_DOT 
3c87				DMARK "DT1" 
3c87 f5				push af  
3c88 3a 9c 3c			ld a, (.dmark)  
3c8b 32 6b ee			ld (debug_mark),a  
3c8e 3a 9d 3c			ld a, (.dmark+1)  
3c91 32 6c ee			ld (debug_mark+1),a  
3c94 3a 9e 3c			ld a, (.dmark+2)  
3c97 32 6d ee			ld (debug_mark+2),a  
3c9a 18 03			jr .pastdmark  
3c9c ..			.dmark: db "DT1"  
3c9f f1			.pastdmark: pop af  
3ca0			endm  
# End of macro DMARK
3ca0				CALLMONITOR 
3ca0 cd 6f ee			call debug_vector  
3ca3				endm  
# End of macro CALLMONITOR
3ca3			endif	 
3ca3			 
3ca3 cd f4 11			call uitoa_16 
3ca6 eb				ex de,hl 
3ca7			 
3ca7			if DEBUG_FORTH_DOT 
3ca7				DMARK "DT2" 
3ca7 f5				push af  
3ca8 3a bc 3c			ld a, (.dmark)  
3cab 32 6b ee			ld (debug_mark),a  
3cae 3a bd 3c			ld a, (.dmark+1)  
3cb1 32 6c ee			ld (debug_mark+1),a  
3cb4 3a be 3c			ld a, (.dmark+2)  
3cb7 32 6d ee			ld (debug_mark+2),a  
3cba 18 03			jr .pastdmark  
3cbc ..			.dmark: db "DT2"  
3cbf f1			.pastdmark: pop af  
3cc0			endm  
# End of macro DMARK
3cc0				CALLMONITOR 
3cc0 cd 6f ee			call debug_vector  
3cc3				endm  
# End of macro CALLMONITOR
3cc3			endif	 
3cc3			 
3cc3			;	ld de, os_word_scratch 
3cc3 18 01			jr .dotwrite 
3cc5			 
3cc5 00			.dotflot:   nop 
3cc6			; TODO print floating point number 
3cc6			 
3cc6			.dotwrite:		 
3cc6			 
3cc6					; if c is set then set all '-' to spaces 
3cc6					; need to also take into account .>  
3cc6			 
3cc6 3e 01				ld a, 1 
3cc8 b9					cp c 
3cc9 20 67				jr nz, .nodashswap 
3ccb			 
3ccb					; DE has the string to write, working with HL 
3ccb			 
3ccb 06 ff				ld b, 255 
3ccd d5					push de 
3cce e1					pop hl 
3ccf			 
3ccf			if DEBUG_FORTH_DOT 
3ccf				DMARK "DT-" 
3ccf f5				push af  
3cd0 3a e4 3c			ld a, (.dmark)  
3cd3 32 6b ee			ld (debug_mark),a  
3cd6 3a e5 3c			ld a, (.dmark+1)  
3cd9 32 6c ee			ld (debug_mark+1),a  
3cdc 3a e6 3c			ld a, (.dmark+2)  
3cdf 32 6d ee			ld (debug_mark+2),a  
3ce2 18 03			jr .pastdmark  
3ce4 ..			.dmark: db "DT-"  
3ce7 f1			.pastdmark: pop af  
3ce8			endm  
# End of macro DMARK
3ce8				CALLMONITOR 
3ce8 cd 6f ee			call debug_vector  
3ceb				endm  
# End of macro CALLMONITOR
3ceb			endif	 
3ceb 7e			.dashscan:	ld a, (hl) 
3cec fe 00				cp 0 
3cee 28 42				jr z, .nodashswap 
3cf0 fe 2d				cp '-' 
3cf2 20 03				jr nz, .dashskip 
3cf4 3e 20				ld a, ' ' 
3cf6 77					ld (hl), a 
3cf7 23			.dashskip:	inc hl 
3cf8			if DEBUG_FORTH_DOT 
3cf8				DMARK "D-2" 
3cf8 f5				push af  
3cf9 3a 0d 3d			ld a, (.dmark)  
3cfc 32 6b ee			ld (debug_mark),a  
3cff 3a 0e 3d			ld a, (.dmark+1)  
3d02 32 6c ee			ld (debug_mark+1),a  
3d05 3a 0f 3d			ld a, (.dmark+2)  
3d08 32 6d ee			ld (debug_mark+2),a  
3d0b 18 03			jr .pastdmark  
3d0d ..			.dmark: db "D-2"  
3d10 f1			.pastdmark: pop af  
3d11			endm  
# End of macro DMARK
3d11				CALLMONITOR 
3d11 cd 6f ee			call debug_vector  
3d14				endm  
# End of macro CALLMONITOR
3d14			endif	 
3d14 10 d5				djnz .dashscan 
3d16			 
3d16			if DEBUG_FORTH_DOT 
3d16				DMARK "D-1" 
3d16 f5				push af  
3d17 3a 2b 3d			ld a, (.dmark)  
3d1a 32 6b ee			ld (debug_mark),a  
3d1d 3a 2c 3d			ld a, (.dmark+1)  
3d20 32 6c ee			ld (debug_mark+1),a  
3d23 3a 2d 3d			ld a, (.dmark+2)  
3d26 32 6d ee			ld (debug_mark+2),a  
3d29 18 03			jr .pastdmark  
3d2b ..			.dmark: db "D-1"  
3d2e f1			.pastdmark: pop af  
3d2f			endm  
# End of macro DMARK
3d2f				CALLMONITOR 
3d2f cd 6f ee			call debug_vector  
3d32				endm  
# End of macro CALLMONITOR
3d32			endif	 
3d32			 
3d32			.nodashswap: 
3d32			 
3d32			if DEBUG_FORTH_DOT 
3d32				DMARK "D-o" 
3d32 f5				push af  
3d33 3a 47 3d			ld a, (.dmark)  
3d36 32 6b ee			ld (debug_mark),a  
3d39 3a 48 3d			ld a, (.dmark+1)  
3d3c 32 6c ee			ld (debug_mark+1),a  
3d3f 3a 49 3d			ld a, (.dmark+2)  
3d42 32 6d ee			ld (debug_mark+2),a  
3d45 18 03			jr .pastdmark  
3d47 ..			.dmark: db "D-o"  
3d4a f1			.pastdmark: pop af  
3d4b			endm  
# End of macro DMARK
3d4b				CALLMONITOR 
3d4b cd 6f ee			call debug_vector  
3d4e				endm  
# End of macro CALLMONITOR
3d4e			endif	 
3d4e			 
3d4e d5					push de   ; save string start in case we need to advance print 
3d4f			 
3d4f 3a 5e ea				ld a, (f_cursor_ptr) 
3d52 cd cd 0b				call str_at_display 
3d55 3a 3c ea				ld a,(cli_autodisplay) 
3d58 fe 00				cp 0 
3d5a 28 03				jr z, .noupdate 
3d5c cd dd 0b						call update_display 
3d5f					.noupdate: 
3d5f			 
3d5f			 
3d5f					; see if we need to advance the print position 
3d5f			 
3d5f e1					pop hl   ; get back string 
3d60			;		ex de,hl 
3d60			 
3d60 3a 3d ea				ld a, (cli_mvdot) 
3d63			if DEBUG_FORTH_DOT 
3d63			;		ld e,a 
3d63				DMARK "D>1" 
3d63 f5				push af  
3d64 3a 78 3d			ld a, (.dmark)  
3d67 32 6b ee			ld (debug_mark),a  
3d6a 3a 79 3d			ld a, (.dmark+1)  
3d6d 32 6c ee			ld (debug_mark+1),a  
3d70 3a 7a 3d			ld a, (.dmark+2)  
3d73 32 6d ee			ld (debug_mark+2),a  
3d76 18 03			jr .pastdmark  
3d78 ..			.dmark: db "D>1"  
3d7b f1			.pastdmark: pop af  
3d7c			endm  
# End of macro DMARK
3d7c				CALLMONITOR 
3d7c cd 6f ee			call debug_vector  
3d7f				endm  
# End of macro CALLMONITOR
3d7f			endif	 
3d7f fe 00				cp 0 
3d81 28 44				jr z, .noadv 
3d83					; yes, lets advance the print position 
3d83 3e 00				ld a, 0 
3d85 cd 50 12				call strlent 
3d88			if DEBUG_FORTH_DOT 
3d88				DMARK "D-?" 
3d88 f5				push af  
3d89 3a 9d 3d			ld a, (.dmark)  
3d8c 32 6b ee			ld (debug_mark),a  
3d8f 3a 9e 3d			ld a, (.dmark+1)  
3d92 32 6c ee			ld (debug_mark+1),a  
3d95 3a 9f 3d			ld a, (.dmark+2)  
3d98 32 6d ee			ld (debug_mark+2),a  
3d9b 18 03			jr .pastdmark  
3d9d ..			.dmark: db "D-?"  
3da0 f1			.pastdmark: pop af  
3da1			endm  
# End of macro DMARK
3da1				CALLMONITOR 
3da1 cd 6f ee			call debug_vector  
3da4				endm  
# End of macro CALLMONITOR
3da4			endif	 
3da4 3a 5e ea				ld a, (f_cursor_ptr) 
3da7 85					add a,l 
3da8					;call addatohl 
3da8					;ld a, l 
3da8 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3dab			 
3dab			if DEBUG_FORTH_DOT 
3dab				DMARK "D->" 
3dab f5				push af  
3dac 3a c0 3d			ld a, (.dmark)  
3daf 32 6b ee			ld (debug_mark),a  
3db2 3a c1 3d			ld a, (.dmark+1)  
3db5 32 6c ee			ld (debug_mark+1),a  
3db8 3a c2 3d			ld a, (.dmark+2)  
3dbb 32 6d ee			ld (debug_mark+2),a  
3dbe 18 03			jr .pastdmark  
3dc0 ..			.dmark: db "D->"  
3dc3 f1			.pastdmark: pop af  
3dc4			endm  
# End of macro DMARK
3dc4				CALLMONITOR 
3dc4 cd 6f ee			call debug_vector  
3dc7				endm  
# End of macro CALLMONITOR
3dc7			endif	 
3dc7			 
3dc7			.noadv:	 
3dc7			 
3dc7					if DEBUG_FORTH_DOT_WAIT 
3dc7							call next_page_prompt 
3dc7					endif	 
3dc7			; TODO this pop off the stack causes a crash. i dont know why 
3dc7			 
3dc7			 
3dc7			if DEBUG_FORTH_DOT 
3dc7				DMARK "DTh" 
3dc7 f5				push af  
3dc8 3a dc 3d			ld a, (.dmark)  
3dcb 32 6b ee			ld (debug_mark),a  
3dce 3a dd 3d			ld a, (.dmark+1)  
3dd1 32 6c ee			ld (debug_mark+1),a  
3dd4 3a de 3d			ld a, (.dmark+2)  
3dd7 32 6d ee			ld (debug_mark+2),a  
3dda 18 03			jr .pastdmark  
3ddc ..			.dmark: db "DTh"  
3ddf f1			.pastdmark: pop af  
3de0			endm  
# End of macro DMARK
3de0				CALLMONITOR 
3de0 cd 6f ee			call debug_vector  
3de3				endm  
# End of macro CALLMONITOR
3de3			endif	 
3de3			 
3de3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3de3 cd f4 1e			call macro_forth_dsp_pop 
3de6				endm 
# End of macro FORTH_DSP_POP
3de6			 
3de6			if DEBUG_FORTH_DOT 
3de6				DMARK "DTi" 
3de6 f5				push af  
3de7 3a fb 3d			ld a, (.dmark)  
3dea 32 6b ee			ld (debug_mark),a  
3ded 3a fc 3d			ld a, (.dmark+1)  
3df0 32 6c ee			ld (debug_mark+1),a  
3df3 3a fd 3d			ld a, (.dmark+2)  
3df6 32 6d ee			ld (debug_mark+2),a  
3df9 18 03			jr .pastdmark  
3dfb ..			.dmark: db "DTi"  
3dfe f1			.pastdmark: pop af  
3dff			endm  
# End of macro DMARK
3dff				CALLMONITOR 
3dff cd 6f ee			call debug_vector  
3e02				endm  
# End of macro CALLMONITOR
3e02			endif	 
3e02			 
3e02			 
3e02					NEXTW 
3e02 c3 f2 1f			jp macro_next 
3e05				endm 
# End of macro NEXTW
3e05			 
3e05			.CLS: 
3e05				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e05 35				db WORD_SYS_CORE+33             
3e06 32 3e			dw .DRAW            
3e08 04				db 3 + 1 
3e09 .. 00			db "CLS",0              
3e0d				endm 
# End of macro CWHEAD
3e0d			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e0d					if DEBUG_FORTH_WORDS_KEY 
3e0d						DMARK "CLS" 
3e0d f5				push af  
3e0e 3a 22 3e			ld a, (.dmark)  
3e11 32 6b ee			ld (debug_mark),a  
3e14 3a 23 3e			ld a, (.dmark+1)  
3e17 32 6c ee			ld (debug_mark+1),a  
3e1a 3a 24 3e			ld a, (.dmark+2)  
3e1d 32 6d ee			ld (debug_mark+2),a  
3e20 18 03			jr .pastdmark  
3e22 ..			.dmark: db "CLS"  
3e25 f1			.pastdmark: pop af  
3e26			endm  
# End of macro DMARK
3e26						CALLMONITOR 
3e26 cd 6f ee			call debug_vector  
3e29				endm  
# End of macro CALLMONITOR
3e29					endif 
3e29 cd ba 0b				call clear_display 
3e2c c3 40 3f				jp .home		; and home cursor 
3e2f					NEXTW 
3e2f c3 f2 1f			jp macro_next 
3e32				endm 
# End of macro NEXTW
3e32			 
3e32			.DRAW: 
3e32				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e32 36				db WORD_SYS_CORE+34             
3e33 5d 3e			dw .DUMP            
3e35 05				db 4 + 1 
3e36 .. 00			db "DRAW",0              
3e3b				endm 
# End of macro CWHEAD
3e3b			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e3b					if DEBUG_FORTH_WORDS_KEY 
3e3b						DMARK "DRW" 
3e3b f5				push af  
3e3c 3a 50 3e			ld a, (.dmark)  
3e3f 32 6b ee			ld (debug_mark),a  
3e42 3a 51 3e			ld a, (.dmark+1)  
3e45 32 6c ee			ld (debug_mark+1),a  
3e48 3a 52 3e			ld a, (.dmark+2)  
3e4b 32 6d ee			ld (debug_mark+2),a  
3e4e 18 03			jr .pastdmark  
3e50 ..			.dmark: db "DRW"  
3e53 f1			.pastdmark: pop af  
3e54			endm  
# End of macro DMARK
3e54						CALLMONITOR 
3e54 cd 6f ee			call debug_vector  
3e57				endm  
# End of macro CALLMONITOR
3e57					endif 
3e57 cd dd 0b				call update_display 
3e5a					NEXTW 
3e5a c3 f2 1f			jp macro_next 
3e5d				endm 
# End of macro NEXTW
3e5d			 
3e5d			.DUMP: 
3e5d				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3e5d 37				db WORD_SYS_CORE+35             
3e5e 95 3e			dw .CDUMP            
3e60 05				db 4 + 1 
3e61 .. 00			db "DUMP",0              
3e66				endm 
# End of macro CWHEAD
3e66			; | DUMP ( x -- ) With address x display dump   | DONE 
3e66			; TODO pop address to use off of the stack 
3e66					if DEBUG_FORTH_WORDS_KEY 
3e66						DMARK "DUM" 
3e66 f5				push af  
3e67 3a 7b 3e			ld a, (.dmark)  
3e6a 32 6b ee			ld (debug_mark),a  
3e6d 3a 7c 3e			ld a, (.dmark+1)  
3e70 32 6c ee			ld (debug_mark+1),a  
3e73 3a 7d 3e			ld a, (.dmark+2)  
3e76 32 6d ee			ld (debug_mark+2),a  
3e79 18 03			jr .pastdmark  
3e7b ..			.dmark: db "DUM"  
3e7e f1			.pastdmark: pop af  
3e7f			endm  
# End of macro DMARK
3e7f						CALLMONITOR 
3e7f cd 6f ee			call debug_vector  
3e82				endm  
# End of macro CALLMONITOR
3e82					endif 
3e82 cd ba 0b				call clear_display 
3e85			 
3e85					; get address 
3e85			 
3e85					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e85 cd 3c 1e			call macro_dsp_valuehl 
3e88				endm 
# End of macro FORTH_DSP_VALUEHL
3e88				 
3e88					; save it for cdump 
3e88			 
3e88 22 e4 e5				ld (os_cur_ptr),hl 
3e8b			 
3e8b					; destroy value TOS 
3e8b			 
3e8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e8b cd f4 1e			call macro_forth_dsp_pop 
3e8e				endm 
# End of macro FORTH_DSP_POP
3e8e			 
3e8e cd c5 1a				call dumpcont	; skip old style of param parsing	 
3e91 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e92					NEXTW 
3e92 c3 f2 1f			jp macro_next 
3e95				endm 
# End of macro NEXTW
3e95			.CDUMP: 
3e95				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e95 38				db WORD_SYS_CORE+36             
3e96 c5 3e			dw .DAT            
3e98 06				db 5 + 1 
3e99 .. 00			db "CDUMP",0              
3e9f				endm 
# End of macro CWHEAD
3e9f			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e9f					if DEBUG_FORTH_WORDS_KEY 
3e9f						DMARK "CDP" 
3e9f f5				push af  
3ea0 3a b4 3e			ld a, (.dmark)  
3ea3 32 6b ee			ld (debug_mark),a  
3ea6 3a b5 3e			ld a, (.dmark+1)  
3ea9 32 6c ee			ld (debug_mark+1),a  
3eac 3a b6 3e			ld a, (.dmark+2)  
3eaf 32 6d ee			ld (debug_mark+2),a  
3eb2 18 03			jr .pastdmark  
3eb4 ..			.dmark: db "CDP"  
3eb7 f1			.pastdmark: pop af  
3eb8			endm  
# End of macro DMARK
3eb8						CALLMONITOR 
3eb8 cd 6f ee			call debug_vector  
3ebb				endm  
# End of macro CALLMONITOR
3ebb					endif 
3ebb cd ba 0b				call clear_display 
3ebe cd c5 1a				call dumpcont	 
3ec1 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3ec2					NEXTW 
3ec2 c3 f2 1f			jp macro_next 
3ec5				endm 
# End of macro NEXTW
3ec5			 
3ec5			 
3ec5			 
3ec5			 
3ec5			.DAT: 
3ec5				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3ec5 3d				db WORD_SYS_CORE+41             
3ec6 1b 3f			dw .HOME            
3ec8 03				db 2 + 1 
3ec9 .. 00			db "AT",0              
3ecc				endm 
# End of macro CWHEAD
3ecc			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3ecc					if DEBUG_FORTH_WORDS_KEY 
3ecc						DMARK "AT." 
3ecc f5				push af  
3ecd 3a e1 3e			ld a, (.dmark)  
3ed0 32 6b ee			ld (debug_mark),a  
3ed3 3a e2 3e			ld a, (.dmark+1)  
3ed6 32 6c ee			ld (debug_mark+1),a  
3ed9 3a e3 3e			ld a, (.dmark+2)  
3edc 32 6d ee			ld (debug_mark+2),a  
3edf 18 03			jr .pastdmark  
3ee1 ..			.dmark: db "AT."  
3ee4 f1			.pastdmark: pop af  
3ee5			endm  
# End of macro DMARK
3ee5						CALLMONITOR 
3ee5 cd 6f ee			call debug_vector  
3ee8				endm  
# End of macro CALLMONITOR
3ee8					endif 
3ee8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee8 cd 3c 1e			call macro_dsp_valuehl 
3eeb				endm 
# End of macro FORTH_DSP_VALUEHL
3eeb			 
3eeb			 
3eeb					; TODO save cursor row 
3eeb 7d					ld a,l 
3eec fe 02				cp 2 
3eee 20 04				jr nz, .crow3 
3ef0 3e 28				ld a, display_row_2 
3ef2 18 12				jr .ccol1 
3ef4 fe 03		.crow3:		cp 3 
3ef6 20 04				jr nz, .crow4 
3ef8 3e 50				ld a, display_row_3 
3efa 18 0a				jr .ccol1 
3efc fe 04		.crow4:		cp 4 
3efe 20 04				jr nz, .crow1 
3f00 3e 78				ld a, display_row_4 
3f02 18 02				jr .ccol1 
3f04 3e 00		.crow1:		ld a,display_row_1 
3f06 f5			.ccol1:		push af			; got row offset 
3f07 6f					ld l,a 
3f08 26 00				ld h,0 
3f0a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f0a cd f4 1e			call macro_forth_dsp_pop 
3f0d				endm 
# End of macro FORTH_DSP_POP
3f0d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f0d cd 3c 1e			call macro_dsp_valuehl 
3f10				endm 
# End of macro FORTH_DSP_VALUEHL
3f10					; TODO save cursor col 
3f10 f1					pop af 
3f11 85					add l		; add col offset 
3f12 32 5e ea				ld (f_cursor_ptr), a 
3f15					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f15 cd f4 1e			call macro_forth_dsp_pop 
3f18				endm 
# End of macro FORTH_DSP_POP
3f18			 
3f18					; calculate  
3f18			 
3f18					NEXTW 
3f18 c3 f2 1f			jp macro_next 
3f1b				endm 
# End of macro NEXTW
3f1b			 
3f1b			 
3f1b			.HOME: 
3f1b				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3f1b 41				db WORD_SYS_CORE+45             
3f1c 48 3f			dw .SPACE            
3f1e 05				db 4 + 1 
3f1f .. 00			db "HOME",0              
3f24				endm 
# End of macro CWHEAD
3f24			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f24					if DEBUG_FORTH_WORDS_KEY 
3f24						DMARK "HOM" 
3f24 f5				push af  
3f25 3a 39 3f			ld a, (.dmark)  
3f28 32 6b ee			ld (debug_mark),a  
3f2b 3a 3a 3f			ld a, (.dmark+1)  
3f2e 32 6c ee			ld (debug_mark+1),a  
3f31 3a 3b 3f			ld a, (.dmark+2)  
3f34 32 6d ee			ld (debug_mark+2),a  
3f37 18 03			jr .pastdmark  
3f39 ..			.dmark: db "HOM"  
3f3c f1			.pastdmark: pop af  
3f3d			endm  
# End of macro DMARK
3f3d						CALLMONITOR 
3f3d cd 6f ee			call debug_vector  
3f40				endm  
# End of macro CALLMONITOR
3f40					endif 
3f40 3e 00		.home:		ld a, 0		; and home cursor 
3f42 32 5e ea				ld (f_cursor_ptr), a 
3f45					NEXTW 
3f45 c3 f2 1f			jp macro_next 
3f48				endm 
# End of macro NEXTW
3f48			 
3f48			 
3f48			.SPACE: 
3f48				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f48 46				db WORD_SYS_CORE+50             
3f49 7e 3f			dw .SPACES            
3f4b 03				db 2 + 1 
3f4c .. 00			db "BL",0              
3f4f				endm 
# End of macro CWHEAD
3f4f			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f4f					if DEBUG_FORTH_WORDS_KEY 
3f4f						DMARK "BL." 
3f4f f5				push af  
3f50 3a 64 3f			ld a, (.dmark)  
3f53 32 6b ee			ld (debug_mark),a  
3f56 3a 65 3f			ld a, (.dmark+1)  
3f59 32 6c ee			ld (debug_mark+1),a  
3f5c 3a 66 3f			ld a, (.dmark+2)  
3f5f 32 6d ee			ld (debug_mark+2),a  
3f62 18 03			jr .pastdmark  
3f64 ..			.dmark: db "BL."  
3f67 f1			.pastdmark: pop af  
3f68			endm  
# End of macro DMARK
3f68						CALLMONITOR 
3f68 cd 6f ee			call debug_vector  
3f6b				endm  
# End of macro CALLMONITOR
3f6b					endif 
3f6b 3e 20				ld a, " " 
3f6d 32 c1 e2				ld (scratch),a 
3f70 3e 00				ld a, 0 
3f72 32 c2 e2				ld (scratch+1),a 
3f75 21 c1 e2				ld hl, scratch 
3f78 cd b3 1c				call forth_push_str 
3f7b					 
3f7b				       NEXTW 
3f7b c3 f2 1f			jp macro_next 
3f7e				endm 
# End of macro NEXTW
3f7e			 
3f7e			;.blstr: db " ", 0 
3f7e			 
3f7e			.SPACES: 
3f7e				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f7e 47				db WORD_SYS_CORE+51             
3f7f 19 40			dw .SCROLL            
3f81 07				db 6 + 1 
3f82 .. 00			db "SPACES",0              
3f89				endm 
# End of macro CWHEAD
3f89			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f89					if DEBUG_FORTH_WORDS_KEY 
3f89						DMARK "SPS" 
3f89 f5				push af  
3f8a 3a 9e 3f			ld a, (.dmark)  
3f8d 32 6b ee			ld (debug_mark),a  
3f90 3a 9f 3f			ld a, (.dmark+1)  
3f93 32 6c ee			ld (debug_mark+1),a  
3f96 3a a0 3f			ld a, (.dmark+2)  
3f99 32 6d ee			ld (debug_mark+2),a  
3f9c 18 03			jr .pastdmark  
3f9e ..			.dmark: db "SPS"  
3fa1 f1			.pastdmark: pop af  
3fa2			endm  
# End of macro DMARK
3fa2						CALLMONITOR 
3fa2 cd 6f ee			call debug_vector  
3fa5				endm  
# End of macro CALLMONITOR
3fa5					endif 
3fa5			 
3fa5			 
3fa5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fa5 cd 3c 1e			call macro_dsp_valuehl 
3fa8				endm 
# End of macro FORTH_DSP_VALUEHL
3fa8			 
3fa8 e5					push hl    ; u 
3fa9					if DEBUG_FORTH_WORDS 
3fa9						DMARK "SPA" 
3fa9 f5				push af  
3faa 3a be 3f			ld a, (.dmark)  
3fad 32 6b ee			ld (debug_mark),a  
3fb0 3a bf 3f			ld a, (.dmark+1)  
3fb3 32 6c ee			ld (debug_mark+1),a  
3fb6 3a c0 3f			ld a, (.dmark+2)  
3fb9 32 6d ee			ld (debug_mark+2),a  
3fbc 18 03			jr .pastdmark  
3fbe ..			.dmark: db "SPA"  
3fc1 f1			.pastdmark: pop af  
3fc2			endm  
# End of macro DMARK
3fc2						CALLMONITOR 
3fc2 cd 6f ee			call debug_vector  
3fc5				endm  
# End of macro CALLMONITOR
3fc5					endif 
3fc5			 
3fc5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fc5 cd f4 1e			call macro_forth_dsp_pop 
3fc8				endm 
# End of macro FORTH_DSP_POP
3fc8 e1					pop hl 
3fc9 0e 00				ld c, 0 
3fcb 45					ld b, l 
3fcc 21 c1 e2				ld hl, scratch  
3fcf			 
3fcf					if DEBUG_FORTH_WORDS 
3fcf						DMARK "SP2" 
3fcf f5				push af  
3fd0 3a e4 3f			ld a, (.dmark)  
3fd3 32 6b ee			ld (debug_mark),a  
3fd6 3a e5 3f			ld a, (.dmark+1)  
3fd9 32 6c ee			ld (debug_mark+1),a  
3fdc 3a e6 3f			ld a, (.dmark+2)  
3fdf 32 6d ee			ld (debug_mark+2),a  
3fe2 18 03			jr .pastdmark  
3fe4 ..			.dmark: db "SP2"  
3fe7 f1			.pastdmark: pop af  
3fe8			endm  
# End of macro DMARK
3fe8						CALLMONITOR 
3fe8 cd 6f ee			call debug_vector  
3feb				endm  
# End of macro CALLMONITOR
3feb					endif 
3feb 3e 20				ld a, ' ' 
3fed			.spaces1:	 
3fed 77					ld (hl),a 
3fee 23					inc hl 
3fef					 
3fef 10 fc				djnz .spaces1 
3ff1 3e 00				ld a,0 
3ff3 77					ld (hl),a 
3ff4 21 c1 e2				ld hl, scratch 
3ff7					if DEBUG_FORTH_WORDS 
3ff7						DMARK "SP3" 
3ff7 f5				push af  
3ff8 3a 0c 40			ld a, (.dmark)  
3ffb 32 6b ee			ld (debug_mark),a  
3ffe 3a 0d 40			ld a, (.dmark+1)  
4001 32 6c ee			ld (debug_mark+1),a  
4004 3a 0e 40			ld a, (.dmark+2)  
4007 32 6d ee			ld (debug_mark+2),a  
400a 18 03			jr .pastdmark  
400c ..			.dmark: db "SP3"  
400f f1			.pastdmark: pop af  
4010			endm  
# End of macro DMARK
4010						CALLMONITOR 
4010 cd 6f ee			call debug_vector  
4013				endm  
# End of macro CALLMONITOR
4013					endif 
4013 cd b3 1c				call forth_push_str 
4016			 
4016				       NEXTW 
4016 c3 f2 1f			jp macro_next 
4019				endm 
# End of macro NEXTW
4019			 
4019			 
4019			 
4019			.SCROLL: 
4019				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4019 53				db WORD_SYS_CORE+63             
401a 46 40			dw .SCROLLD            
401c 07				db 6 + 1 
401d .. 00			db "SCROLL",0              
4024				endm 
# End of macro CWHEAD
4024			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4024					if DEBUG_FORTH_WORDS_KEY 
4024						DMARK "SCR" 
4024 f5				push af  
4025 3a 39 40			ld a, (.dmark)  
4028 32 6b ee			ld (debug_mark),a  
402b 3a 3a 40			ld a, (.dmark+1)  
402e 32 6c ee			ld (debug_mark+1),a  
4031 3a 3b 40			ld a, (.dmark+2)  
4034 32 6d ee			ld (debug_mark+2),a  
4037 18 03			jr .pastdmark  
4039 ..			.dmark: db "SCR"  
403c f1			.pastdmark: pop af  
403d			endm  
# End of macro DMARK
403d						CALLMONITOR 
403d cd 6f ee			call debug_vector  
4040				endm  
# End of macro CALLMONITOR
4040					endif 
4040			 
4040 cd 7c 0b			call scroll_up 
4043			;	call update_display 
4043			 
4043					NEXTW 
4043 c3 f2 1f			jp macro_next 
4046				endm 
# End of macro NEXTW
4046			 
4046			 
4046			 
4046			;		; get dir 
4046			; 
4046			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4046			; 
4046			;		push hl 
4046			; 
4046			;		; destroy value TOS 
4046			; 
4046			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4046			; 
4046			;		; get count 
4046			; 
4046			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4046			; 
4046			;		push hl 
4046			; 
4046			;		; destroy value TOS 
4046			; 
4046			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4046			; 
4046			;		; one value on hl get other one back 
4046			; 
4046			;		pop bc    ; count 
4046			; 
4046			;		pop de   ; dir 
4046			; 
4046			; 
4046			;		ld b, c 
4046			; 
4046			;.scrolldir:     push bc 
4046			;		push de 
4046			; 
4046			;		ld a, 0 
4046			;		cp e 
4046			;		jr z, .scrollup  
4046			;		call scroll_down 
4046			;		jr .scrollnext 
4046			;.scrollup:	call scroll_up 
4046			; 
4046			;		 
4046			;.scrollnext: 
4046			;		pop de 
4046			;		pop bc 
4046			;		djnz .scrolldir 
4046			; 
4046			; 
4046			; 
4046			; 
4046			; 
4046			;		NEXTW 
4046			 
4046			.SCROLLD: 
4046				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4046 53				db WORD_SYS_CORE+63             
4047 74 40			dw .ATQ            
4049 08				db 7 + 1 
404a .. 00			db "SCROLLD",0              
4052				endm 
# End of macro CWHEAD
4052			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4052					if DEBUG_FORTH_WORDS_KEY 
4052						DMARK "SCD" 
4052 f5				push af  
4053 3a 67 40			ld a, (.dmark)  
4056 32 6b ee			ld (debug_mark),a  
4059 3a 68 40			ld a, (.dmark+1)  
405c 32 6c ee			ld (debug_mark+1),a  
405f 3a 69 40			ld a, (.dmark+2)  
4062 32 6d ee			ld (debug_mark+2),a  
4065 18 03			jr .pastdmark  
4067 ..			.dmark: db "SCD"  
406a f1			.pastdmark: pop af  
406b			endm  
# End of macro DMARK
406b						CALLMONITOR 
406b cd 6f ee			call debug_vector  
406e				endm  
# End of macro CALLMONITOR
406e					endif 
406e			 
406e cd a0 0b			call scroll_down 
4071			;	call update_display 
4071			 
4071					NEXTW 
4071 c3 f2 1f			jp macro_next 
4074				endm 
# End of macro NEXTW
4074			 
4074			 
4074			.ATQ: 
4074				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4074 62				db WORD_SYS_CORE+78             
4075 d2 40			dw .AUTODSP            
4077 04				db 3 + 1 
4078 .. 00			db "AT@",0              
407c				endm 
# End of macro CWHEAD
407c			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
407c					if DEBUG_FORTH_WORDS_KEY 
407c						DMARK "ATA" 
407c f5				push af  
407d 3a 91 40			ld a, (.dmark)  
4080 32 6b ee			ld (debug_mark),a  
4083 3a 92 40			ld a, (.dmark+1)  
4086 32 6c ee			ld (debug_mark+1),a  
4089 3a 93 40			ld a, (.dmark+2)  
408c 32 6d ee			ld (debug_mark+2),a  
408f 18 03			jr .pastdmark  
4091 ..			.dmark: db "ATA"  
4094 f1			.pastdmark: pop af  
4095			endm  
# End of macro DMARK
4095						CALLMONITOR 
4095 cd 6f ee			call debug_vector  
4098				endm  
# End of macro CALLMONITOR
4098					endif 
4098			 
4098			 
4098					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4098 cd 3c 1e			call macro_dsp_valuehl 
409b				endm 
# End of macro FORTH_DSP_VALUEHL
409b			 
409b					; TODO save cursor row 
409b 7d					ld a,l 
409c fe 02				cp 2 
409e 20 04				jr nz, .crow3aq 
40a0 3e 28				ld a, display_row_2 
40a2 18 12				jr .ccol1aq 
40a4 fe 03		.crow3aq:		cp 3 
40a6 20 04				jr nz, .crow4aq 
40a8 3e 50				ld a, display_row_3 
40aa 18 0a				jr .ccol1aq 
40ac fe 04		.crow4aq:		cp 4 
40ae 20 04				jr nz, .crow1aq 
40b0 3e 78				ld a, display_row_4 
40b2 18 02				jr .ccol1aq 
40b4 3e 00		.crow1aq:		ld a,display_row_1 
40b6 f5			.ccol1aq:		push af			; got row offset 
40b7 6f					ld l,a 
40b8 26 00				ld h,0 
40ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ba cd f4 1e			call macro_forth_dsp_pop 
40bd				endm 
# End of macro FORTH_DSP_POP
40bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40bd cd 3c 1e			call macro_dsp_valuehl 
40c0				endm 
# End of macro FORTH_DSP_VALUEHL
40c0					; TODO save cursor col 
40c0 f1					pop af 
40c1 85					add l		; add col offset 
40c2			 
40c2					; add current frame buffer address 
40c2 2a cc eb				ld hl, (display_fb_active) 
40c5 cd e7 0d				call addatohl 
40c8			 
40c8			 
40c8			 
40c8			 
40c8					; get char frame buffer location offset in hl 
40c8			 
40c8 7e					ld a,(hl) 
40c9 26 00				ld h, 0 
40cb 6f					ld l, a 
40cc			 
40cc cd 45 1c				call forth_push_numhl 
40cf			 
40cf			 
40cf					NEXTW 
40cf c3 f2 1f			jp macro_next 
40d2				endm 
# End of macro NEXTW
40d2			 
40d2			.AUTODSP: 
40d2				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
40d2 63				db WORD_SYS_CORE+79             
40d3 e8 40			dw .MENU            
40d5 05				db 4 + 1 
40d6 .. 00			db "ADSP",0              
40db				endm 
# End of macro CWHEAD
40db			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
40db			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
40db			 
40db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40db cd 3c 1e			call macro_dsp_valuehl 
40de				endm 
# End of macro FORTH_DSP_VALUEHL
40de			 
40de			;		push hl 
40de			 
40de					; destroy value TOS 
40de			 
40de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40de cd f4 1e			call macro_forth_dsp_pop 
40e1				endm 
# End of macro FORTH_DSP_POP
40e1			 
40e1			;		pop hl 
40e1			 
40e1 7d					ld a,l 
40e2 32 3c ea				ld (cli_autodisplay), a 
40e5				       NEXTW 
40e5 c3 f2 1f			jp macro_next 
40e8				endm 
# End of macro NEXTW
40e8			 
40e8			.MENU: 
40e8				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
40e8 70				db WORD_SYS_CORE+92             
40e9 91 41			dw .ENDDISPLAY            
40eb 05				db 4 + 1 
40ec .. 00			db "MENU",0              
40f1				endm 
# End of macro CWHEAD
40f1			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
40f1			 
40f1			;		; get number of items on the stack 
40f1			; 
40f1				 
40f1					FORTH_DSP_VALUEHL 
40f1 cd 3c 1e			call macro_dsp_valuehl 
40f4				endm 
# End of macro FORTH_DSP_VALUEHL
40f4				 
40f4					if DEBUG_FORTH_WORDS_KEY 
40f4						DMARK "MNU" 
40f4 f5				push af  
40f5 3a 09 41			ld a, (.dmark)  
40f8 32 6b ee			ld (debug_mark),a  
40fb 3a 0a 41			ld a, (.dmark+1)  
40fe 32 6c ee			ld (debug_mark+1),a  
4101 3a 0b 41			ld a, (.dmark+2)  
4104 32 6d ee			ld (debug_mark+2),a  
4107 18 03			jr .pastdmark  
4109 ..			.dmark: db "MNU"  
410c f1			.pastdmark: pop af  
410d			endm  
# End of macro DMARK
410d						CALLMONITOR 
410d cd 6f ee			call debug_vector  
4110				endm  
# End of macro CALLMONITOR
4110					endif 
4110			 
4110 45					ld b, l	 
4111 05					dec b 
4112			 
4112					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4112 cd f4 1e			call macro_forth_dsp_pop 
4115				endm 
# End of macro FORTH_DSP_POP
4115			 
4115			 
4115					; go directly through the stack to pluck out the string pointers and build an array 
4115			 
4115			;		FORTH_DSP 
4115			 
4115					; hl contains top most stack item 
4115				 
4115 11 c1 e2				ld de, scratch 
4118			 
4118			.mbuild: 
4118			 
4118					FORTH_DSP_VALUEHL 
4118 cd 3c 1e			call macro_dsp_valuehl 
411b				endm 
# End of macro FORTH_DSP_VALUEHL
411b			 
411b					if DEBUG_FORTH_WORDS 
411b						DMARK "MN3" 
411b f5				push af  
411c 3a 30 41			ld a, (.dmark)  
411f 32 6b ee			ld (debug_mark),a  
4122 3a 31 41			ld a, (.dmark+1)  
4125 32 6c ee			ld (debug_mark+1),a  
4128 3a 32 41			ld a, (.dmark+2)  
412b 32 6d ee			ld (debug_mark+2),a  
412e 18 03			jr .pastdmark  
4130 ..			.dmark: db "MN3"  
4133 f1			.pastdmark: pop af  
4134			endm  
# End of macro DMARK
4134						CALLMONITOR 
4134 cd 6f ee			call debug_vector  
4137				endm  
# End of macro CALLMONITOR
4137					endif 
4137 eb					ex de, hl 
4138 73					ld (hl), e 
4139 23					inc hl 
413a 72					ld (hl), d 
413b 23					inc hl 
413c eb					ex de, hl 
413d			 
413d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
413d cd f4 1e			call macro_forth_dsp_pop 
4140				endm 
# End of macro FORTH_DSP_POP
4140			 
4140 10 d6				djnz .mbuild 
4142			 
4142					; done add term 
4142			 
4142 eb					ex de, hl 
4143 36 00				ld (hl), 0 
4145 23					inc hl 
4146 36 00				ld (hl), 0 
4148			 
4148				 
4148					 
4148 21 c1 e2				ld hl, scratch 
414b			 
414b					if DEBUG_FORTH_WORDS 
414b						DMARK "MNx" 
414b f5				push af  
414c 3a 60 41			ld a, (.dmark)  
414f 32 6b ee			ld (debug_mark),a  
4152 3a 61 41			ld a, (.dmark+1)  
4155 32 6c ee			ld (debug_mark+1),a  
4158 3a 62 41			ld a, (.dmark+2)  
415b 32 6d ee			ld (debug_mark+2),a  
415e 18 03			jr .pastdmark  
4160 ..			.dmark: db "MNx"  
4163 f1			.pastdmark: pop af  
4164			endm  
# End of macro DMARK
4164						CALLMONITOR 
4164 cd 6f ee			call debug_vector  
4167				endm  
# End of macro CALLMONITOR
4167					endif 
4167			 
4167			 
4167			 
4167 3e 00				ld a, 0 
4169 cd eb 0b				call menu 
416c			 
416c			 
416c 6f					ld l, a 
416d 26 00				ld h, 0 
416f			 
416f					if DEBUG_FORTH_WORDS 
416f						DMARK "MNr" 
416f f5				push af  
4170 3a 84 41			ld a, (.dmark)  
4173 32 6b ee			ld (debug_mark),a  
4176 3a 85 41			ld a, (.dmark+1)  
4179 32 6c ee			ld (debug_mark+1),a  
417c 3a 86 41			ld a, (.dmark+2)  
417f 32 6d ee			ld (debug_mark+2),a  
4182 18 03			jr .pastdmark  
4184 ..			.dmark: db "MNr"  
4187 f1			.pastdmark: pop af  
4188			endm  
# End of macro DMARK
4188						CALLMONITOR 
4188 cd 6f ee			call debug_vector  
418b				endm  
# End of macro CALLMONITOR
418b					endif 
418b			 
418b cd 45 1c				call forth_push_numhl 
418e			 
418e			 
418e			 
418e			 
418e				       NEXTW 
418e c3 f2 1f			jp macro_next 
4191				endm 
# End of macro NEXTW
4191			 
4191			 
4191			.ENDDISPLAY: 
4191			 
4191			; eof 
# End of file forth_words_display.asm
4191			include "forth_words_str.asm" 
4191			 
4191			; | ## String Words 
4191			 
4191			.PTR:   
4191			 
4191				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4191 48				db WORD_SYS_CORE+52             
4192 be 41			dw .STYPE            
4194 04				db 3 + 1 
4195 .. 00			db "PTR",0              
4199				endm 
# End of macro CWHEAD
4199			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4199			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4199			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4199			 
4199					if DEBUG_FORTH_WORDS_KEY 
4199						DMARK "PTR" 
4199 f5				push af  
419a 3a ae 41			ld a, (.dmark)  
419d 32 6b ee			ld (debug_mark),a  
41a0 3a af 41			ld a, (.dmark+1)  
41a3 32 6c ee			ld (debug_mark+1),a  
41a6 3a b0 41			ld a, (.dmark+2)  
41a9 32 6d ee			ld (debug_mark+2),a  
41ac 18 03			jr .pastdmark  
41ae ..			.dmark: db "PTR"  
41b1 f1			.pastdmark: pop af  
41b2			endm  
# End of macro DMARK
41b2						CALLMONITOR 
41b2 cd 6f ee			call debug_vector  
41b5				endm  
# End of macro CALLMONITOR
41b5					endif 
41b5					FORTH_DSP_VALUEHL 
41b5 cd 3c 1e			call macro_dsp_valuehl 
41b8				endm 
# End of macro FORTH_DSP_VALUEHL
41b8 cd 45 1c				call forth_push_numhl 
41bb			 
41bb			 
41bb					NEXTW 
41bb c3 f2 1f			jp macro_next 
41be				endm 
# End of macro NEXTW
41be			.STYPE: 
41be				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
41be 48				db WORD_SYS_CORE+52             
41bf 0d 42			dw .UPPER            
41c1 06				db 5 + 1 
41c2 .. 00			db "STYPE",0              
41c8				endm 
# End of macro CWHEAD
41c8			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
41c8					if DEBUG_FORTH_WORDS_KEY 
41c8						DMARK "STY" 
41c8 f5				push af  
41c9 3a dd 41			ld a, (.dmark)  
41cc 32 6b ee			ld (debug_mark),a  
41cf 3a de 41			ld a, (.dmark+1)  
41d2 32 6c ee			ld (debug_mark+1),a  
41d5 3a df 41			ld a, (.dmark+2)  
41d8 32 6d ee			ld (debug_mark+2),a  
41db 18 03			jr .pastdmark  
41dd ..			.dmark: db "STY"  
41e0 f1			.pastdmark: pop af  
41e1			endm  
# End of macro DMARK
41e1						CALLMONITOR 
41e1 cd 6f ee			call debug_vector  
41e4				endm  
# End of macro CALLMONITOR
41e4					endif 
41e4					FORTH_DSP 
41e4 cd 02 1e			call macro_forth_dsp 
41e7				endm 
# End of macro FORTH_DSP
41e7					;v5 FORTH_DSP_VALUE 
41e7			 
41e7 7e					ld a, (hl) 
41e8			 
41e8 f5					push af 
41e9			 
41e9			; Dont destroy TOS		FORTH_DSP_POP 
41e9			 
41e9 f1					pop af 
41ea			 
41ea fe 01				cp DS_TYPE_STR 
41ec 28 09				jr z, .typestr 
41ee			 
41ee fe 02				cp DS_TYPE_INUM 
41f0 28 0a				jr z, .typeinum 
41f2			 
41f2 21 0b 42				ld hl, .tna 
41f5 18 0a				jr .tpush 
41f7			 
41f7 21 07 42		.typestr:	ld hl, .tstr 
41fa 18 05				jr .tpush 
41fc 21 09 42		.typeinum:	ld hl, .tinum 
41ff 18 00				jr .tpush 
4201			 
4201			.tpush: 
4201			 
4201 cd b3 1c				call forth_push_str 
4204			 
4204					NEXTW 
4204 c3 f2 1f			jp macro_next 
4207				endm 
# End of macro NEXTW
4207 .. 00		.tstr:	db "s",0 
4209 .. 00		.tinum:  db "i",0 
420b .. 00		.tna:   db "?", 0 
420d			 
420d			 
420d			.UPPER: 
420d				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
420d 48				db WORD_SYS_CORE+52             
420e 48 42			dw .LOWER            
4210 06				db 5 + 1 
4211 .. 00			db "UPPER",0              
4217				endm 
# End of macro CWHEAD
4217			; | UPPER ( s -- s ) Upper case string s  | DONE 
4217					if DEBUG_FORTH_WORDS_KEY 
4217						DMARK "UPR" 
4217 f5				push af  
4218 3a 2c 42			ld a, (.dmark)  
421b 32 6b ee			ld (debug_mark),a  
421e 3a 2d 42			ld a, (.dmark+1)  
4221 32 6c ee			ld (debug_mark+1),a  
4224 3a 2e 42			ld a, (.dmark+2)  
4227 32 6d ee			ld (debug_mark+2),a  
422a 18 03			jr .pastdmark  
422c ..			.dmark: db "UPR"  
422f f1			.pastdmark: pop af  
4230			endm  
# End of macro DMARK
4230						CALLMONITOR 
4230 cd 6f ee			call debug_vector  
4233				endm  
# End of macro CALLMONITOR
4233					endif 
4233			 
4233					FORTH_DSP 
4233 cd 02 1e			call macro_forth_dsp 
4236				endm 
# End of macro FORTH_DSP
4236					 
4236			; TODO check is string type 
4236			 
4236					FORTH_DSP_VALUEHL 
4236 cd 3c 1e			call macro_dsp_valuehl 
4239				endm 
# End of macro FORTH_DSP_VALUEHL
4239			; get pointer to string in hl 
4239			 
4239 7e			.toup:		ld a, (hl) 
423a fe 00				cp 0 
423c 28 07				jr z, .toupdone 
423e			 
423e cd 54 11				call to_upper 
4241			 
4241 77					ld (hl), a 
4242 23					inc hl 
4243 18 f4				jr .toup 
4245			 
4245					 
4245			 
4245			 
4245			; for each char convert to upper 
4245					 
4245			.toupdone: 
4245			 
4245			 
4245					NEXTW 
4245 c3 f2 1f			jp macro_next 
4248				endm 
# End of macro NEXTW
4248			.LOWER: 
4248				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4248 48				db WORD_SYS_CORE+52             
4249 83 42			dw .TCASE            
424b 06				db 5 + 1 
424c .. 00			db "LOWER",0              
4252				endm 
# End of macro CWHEAD
4252			; | LOWER ( s -- s ) Lower case string s  | DONE 
4252					if DEBUG_FORTH_WORDS_KEY 
4252						DMARK "LWR" 
4252 f5				push af  
4253 3a 67 42			ld a, (.dmark)  
4256 32 6b ee			ld (debug_mark),a  
4259 3a 68 42			ld a, (.dmark+1)  
425c 32 6c ee			ld (debug_mark+1),a  
425f 3a 69 42			ld a, (.dmark+2)  
4262 32 6d ee			ld (debug_mark+2),a  
4265 18 03			jr .pastdmark  
4267 ..			.dmark: db "LWR"  
426a f1			.pastdmark: pop af  
426b			endm  
# End of macro DMARK
426b						CALLMONITOR 
426b cd 6f ee			call debug_vector  
426e				endm  
# End of macro CALLMONITOR
426e					endif 
426e			 
426e					FORTH_DSP 
426e cd 02 1e			call macro_forth_dsp 
4271				endm 
# End of macro FORTH_DSP
4271					 
4271			; TODO check is string type 
4271			 
4271					FORTH_DSP_VALUEHL 
4271 cd 3c 1e			call macro_dsp_valuehl 
4274				endm 
# End of macro FORTH_DSP_VALUEHL
4274			; get pointer to string in hl 
4274			 
4274 7e			.tolow:		ld a, (hl) 
4275 fe 00				cp 0 
4277 28 07				jr z, .tolowdone 
4279			 
4279 cd 5d 11				call to_lower 
427c			 
427c 77					ld (hl), a 
427d 23					inc hl 
427e 18 f4				jr .tolow 
4280			 
4280					 
4280			 
4280			 
4280			; for each char convert to low 
4280					 
4280			.tolowdone: 
4280					NEXTW 
4280 c3 f2 1f			jp macro_next 
4283				endm 
# End of macro NEXTW
4283			.TCASE: 
4283				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4283 48				db WORD_SYS_CORE+52             
4284 b9 43			dw .SUBSTR            
4286 06				db 5 + 1 
4287 .. 00			db "TCASE",0              
428d				endm 
# End of macro CWHEAD
428d			; | TCASE ( s -- s ) Title case string s  | DONE 
428d					if DEBUG_FORTH_WORDS_KEY 
428d						DMARK "TCS" 
428d f5				push af  
428e 3a a2 42			ld a, (.dmark)  
4291 32 6b ee			ld (debug_mark),a  
4294 3a a3 42			ld a, (.dmark+1)  
4297 32 6c ee			ld (debug_mark+1),a  
429a 3a a4 42			ld a, (.dmark+2)  
429d 32 6d ee			ld (debug_mark+2),a  
42a0 18 03			jr .pastdmark  
42a2 ..			.dmark: db "TCS"  
42a5 f1			.pastdmark: pop af  
42a6			endm  
# End of macro DMARK
42a6						CALLMONITOR 
42a6 cd 6f ee			call debug_vector  
42a9				endm  
# End of macro CALLMONITOR
42a9					endif 
42a9			 
42a9					FORTH_DSP 
42a9 cd 02 1e			call macro_forth_dsp 
42ac				endm 
# End of macro FORTH_DSP
42ac					 
42ac			; TODO check is string type 
42ac			 
42ac					FORTH_DSP_VALUEHL 
42ac cd 3c 1e			call macro_dsp_valuehl 
42af				endm 
# End of macro FORTH_DSP_VALUEHL
42af			; get pointer to string in hl 
42af			 
42af					if DEBUG_FORTH_WORDS 
42af						DMARK "TC1" 
42af f5				push af  
42b0 3a c4 42			ld a, (.dmark)  
42b3 32 6b ee			ld (debug_mark),a  
42b6 3a c5 42			ld a, (.dmark+1)  
42b9 32 6c ee			ld (debug_mark+1),a  
42bc 3a c6 42			ld a, (.dmark+2)  
42bf 32 6d ee			ld (debug_mark+2),a  
42c2 18 03			jr .pastdmark  
42c4 ..			.dmark: db "TC1"  
42c7 f1			.pastdmark: pop af  
42c8			endm  
# End of macro DMARK
42c8						CALLMONITOR 
42c8 cd 6f ee			call debug_vector  
42cb				endm  
# End of macro CALLMONITOR
42cb					endif 
42cb			 
42cb					; first time in turn to upper case first char 
42cb			 
42cb 7e					ld a, (hl) 
42cc c3 56 43				jp .totsiptou 
42cf			 
42cf			 
42cf 7e			.tot:		ld a, (hl) 
42d0 fe 00				cp 0 
42d2 ca 9a 43				jp z, .totdone 
42d5			 
42d5					if DEBUG_FORTH_WORDS 
42d5						DMARK "TC2" 
42d5 f5				push af  
42d6 3a ea 42			ld a, (.dmark)  
42d9 32 6b ee			ld (debug_mark),a  
42dc 3a eb 42			ld a, (.dmark+1)  
42df 32 6c ee			ld (debug_mark+1),a  
42e2 3a ec 42			ld a, (.dmark+2)  
42e5 32 6d ee			ld (debug_mark+2),a  
42e8 18 03			jr .pastdmark  
42ea ..			.dmark: db "TC2"  
42ed f1			.pastdmark: pop af  
42ee			endm  
# End of macro DMARK
42ee						CALLMONITOR 
42ee cd 6f ee			call debug_vector  
42f1				endm  
# End of macro CALLMONITOR
42f1					endif 
42f1					; check to see if current char is a space 
42f1			 
42f1 fe 20				cp ' ' 
42f3 28 21				jr z, .totsp 
42f5 cd 5d 11				call to_lower 
42f8					if DEBUG_FORTH_WORDS 
42f8						DMARK "TC3" 
42f8 f5				push af  
42f9 3a 0d 43			ld a, (.dmark)  
42fc 32 6b ee			ld (debug_mark),a  
42ff 3a 0e 43			ld a, (.dmark+1)  
4302 32 6c ee			ld (debug_mark+1),a  
4305 3a 0f 43			ld a, (.dmark+2)  
4308 32 6d ee			ld (debug_mark+2),a  
430b 18 03			jr .pastdmark  
430d ..			.dmark: db "TC3"  
4310 f1			.pastdmark: pop af  
4311			endm  
# End of macro DMARK
4311						CALLMONITOR 
4311 cd 6f ee			call debug_vector  
4314				endm  
# End of macro CALLMONITOR
4314					endif 
4314 18 63				jr .totnxt 
4316			 
4316			.totsp:         ; on a space, find next char which should be upper 
4316			 
4316					if DEBUG_FORTH_WORDS 
4316						DMARK "TC4" 
4316 f5				push af  
4317 3a 2b 43			ld a, (.dmark)  
431a 32 6b ee			ld (debug_mark),a  
431d 3a 2c 43			ld a, (.dmark+1)  
4320 32 6c ee			ld (debug_mark+1),a  
4323 3a 2d 43			ld a, (.dmark+2)  
4326 32 6d ee			ld (debug_mark+2),a  
4329 18 03			jr .pastdmark  
432b ..			.dmark: db "TC4"  
432e f1			.pastdmark: pop af  
432f			endm  
# End of macro DMARK
432f						CALLMONITOR 
432f cd 6f ee			call debug_vector  
4332				endm  
# End of macro CALLMONITOR
4332					endif 
4332					;; 
4332			 
4332 fe 20				cp ' ' 
4334 20 20				jr nz, .totsiptou 
4336 23					inc hl 
4337 7e					ld a, (hl) 
4338					if DEBUG_FORTH_WORDS 
4338						DMARK "TC5" 
4338 f5				push af  
4339 3a 4d 43			ld a, (.dmark)  
433c 32 6b ee			ld (debug_mark),a  
433f 3a 4e 43			ld a, (.dmark+1)  
4342 32 6c ee			ld (debug_mark+1),a  
4345 3a 4f 43			ld a, (.dmark+2)  
4348 32 6d ee			ld (debug_mark+2),a  
434b 18 03			jr .pastdmark  
434d ..			.dmark: db "TC5"  
4350 f1			.pastdmark: pop af  
4351			endm  
# End of macro DMARK
4351						CALLMONITOR 
4351 cd 6f ee			call debug_vector  
4354				endm  
# End of macro CALLMONITOR
4354					endif 
4354 18 c0				jr .totsp 
4356 fe 00		.totsiptou:    cp 0 
4358 28 40				jr z, .totdone 
435a					; not space and not zero term so upper case it 
435a cd 54 11				call to_upper 
435d			 
435d					if DEBUG_FORTH_WORDS 
435d						DMARK "TC6" 
435d f5				push af  
435e 3a 72 43			ld a, (.dmark)  
4361 32 6b ee			ld (debug_mark),a  
4364 3a 73 43			ld a, (.dmark+1)  
4367 32 6c ee			ld (debug_mark+1),a  
436a 3a 74 43			ld a, (.dmark+2)  
436d 32 6d ee			ld (debug_mark+2),a  
4370 18 03			jr .pastdmark  
4372 ..			.dmark: db "TC6"  
4375 f1			.pastdmark: pop af  
4376			endm  
# End of macro DMARK
4376						CALLMONITOR 
4376 cd 6f ee			call debug_vector  
4379				endm  
# End of macro CALLMONITOR
4379					endif 
4379			 
4379			 
4379			.totnxt: 
4379			 
4379 77					ld (hl), a 
437a 23					inc hl 
437b					if DEBUG_FORTH_WORDS 
437b						DMARK "TC7" 
437b f5				push af  
437c 3a 90 43			ld a, (.dmark)  
437f 32 6b ee			ld (debug_mark),a  
4382 3a 91 43			ld a, (.dmark+1)  
4385 32 6c ee			ld (debug_mark+1),a  
4388 3a 92 43			ld a, (.dmark+2)  
438b 32 6d ee			ld (debug_mark+2),a  
438e 18 03			jr .pastdmark  
4390 ..			.dmark: db "TC7"  
4393 f1			.pastdmark: pop af  
4394			endm  
# End of macro DMARK
4394						CALLMONITOR 
4394 cd 6f ee			call debug_vector  
4397				endm  
# End of macro CALLMONITOR
4397					endif 
4397 c3 cf 42				jp .tot 
439a			 
439a					 
439a			 
439a			 
439a			; for each char convert to low 
439a					 
439a			.totdone: 
439a					if DEBUG_FORTH_WORDS 
439a						DMARK "TCd" 
439a f5				push af  
439b 3a af 43			ld a, (.dmark)  
439e 32 6b ee			ld (debug_mark),a  
43a1 3a b0 43			ld a, (.dmark+1)  
43a4 32 6c ee			ld (debug_mark+1),a  
43a7 3a b1 43			ld a, (.dmark+2)  
43aa 32 6d ee			ld (debug_mark+2),a  
43ad 18 03			jr .pastdmark  
43af ..			.dmark: db "TCd"  
43b2 f1			.pastdmark: pop af  
43b3			endm  
# End of macro DMARK
43b3						CALLMONITOR 
43b3 cd 6f ee			call debug_vector  
43b6				endm  
# End of macro CALLMONITOR
43b6					endif 
43b6					NEXTW 
43b6 c3 f2 1f			jp macro_next 
43b9				endm 
# End of macro NEXTW
43b9			 
43b9			.SUBSTR: 
43b9				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
43b9 48				db WORD_SYS_CORE+52             
43ba 17 44			dw .LEFT            
43bc 07				db 6 + 1 
43bd .. 00			db "SUBSTR",0              
43c4				endm 
# End of macro CWHEAD
43c4			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
43c4			 
43c4					if DEBUG_FORTH_WORDS_KEY 
43c4						DMARK "SST" 
43c4 f5				push af  
43c5 3a d9 43			ld a, (.dmark)  
43c8 32 6b ee			ld (debug_mark),a  
43cb 3a da 43			ld a, (.dmark+1)  
43ce 32 6c ee			ld (debug_mark+1),a  
43d1 3a db 43			ld a, (.dmark+2)  
43d4 32 6d ee			ld (debug_mark+2),a  
43d7 18 03			jr .pastdmark  
43d9 ..			.dmark: db "SST"  
43dc f1			.pastdmark: pop af  
43dd			endm  
# End of macro DMARK
43dd						CALLMONITOR 
43dd cd 6f ee			call debug_vector  
43e0				endm  
# End of macro CALLMONITOR
43e0					endif 
43e0			; TODO check string type 
43e0					FORTH_DSP_VALUEHL 
43e0 cd 3c 1e			call macro_dsp_valuehl 
43e3				endm 
# End of macro FORTH_DSP_VALUEHL
43e3			 
43e3 e5					push hl      ; string length 
43e4			 
43e4					FORTH_DSP_POP 
43e4 cd f4 1e			call macro_forth_dsp_pop 
43e7				endm 
# End of macro FORTH_DSP_POP
43e7			 
43e7					FORTH_DSP_VALUEHL 
43e7 cd 3c 1e			call macro_dsp_valuehl 
43ea				endm 
# End of macro FORTH_DSP_VALUEHL
43ea			 
43ea e5					push hl     ; start char 
43eb			 
43eb					FORTH_DSP_POP 
43eb cd f4 1e			call macro_forth_dsp_pop 
43ee				endm 
# End of macro FORTH_DSP_POP
43ee			 
43ee			 
43ee					FORTH_DSP_VALUE 
43ee cd 25 1e			call macro_forth_dsp_value 
43f1				endm 
# End of macro FORTH_DSP_VALUE
43f1			 
43f1 d1					pop de    ; get start post offset 
43f2			 
43f2 19					add hl, de    ; starting offset 
43f3			 
43f3 c1					pop bc 
43f4 c5					push bc      ; grab size of string 
43f5			 
43f5 e5					push hl    ; save string start  
43f6			 
43f6 26 00				ld h, 0 
43f8 69					ld l, c 
43f9 23					inc hl 
43fa 23					inc hl 
43fb			 
43fb cd ae 12				call malloc 
43fe				if DEBUG_FORTH_MALLOC_GUARD 
43fe cc 31 4d				call z,malloc_error 
4401				endif 
4401			 
4401 eb					ex de, hl      ; save malloc area for string copy 
4402 e1					pop hl    ; get back source 
4403 c1					pop bc    ; get length of string back 
4404			 
4404 d5					push de    ; save malloc area for after we push 
4405 ed b0				ldir     ; copy substr 
4407			 
4407			 
4407 eb					ex de, hl 
4408 3e 00				ld a, 0 
440a 77					ld (hl), a   ; term substr 
440b			 
440b					 
440b e1					pop hl    ; get malloc so we can push it 
440c e5					push hl   ; save so we can free it afterwards 
440d			 
440d cd b3 1c				call forth_push_str 
4410			 
4410 e1					pop hl 
4411 cd 78 13				call free 
4414			 
4414					 
4414					 
4414			 
4414			 
4414					NEXTW 
4414 c3 f2 1f			jp macro_next 
4417				endm 
# End of macro NEXTW
4417			 
4417			.LEFT: 
4417				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4417 48				db WORD_SYS_CORE+52             
4418 3f 44			dw .RIGHT            
441a 05				db 4 + 1 
441b .. 00			db "LEFT",0              
4420				endm 
# End of macro CWHEAD
4420			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4420					if DEBUG_FORTH_WORDS_KEY 
4420						DMARK "LEF" 
4420 f5				push af  
4421 3a 35 44			ld a, (.dmark)  
4424 32 6b ee			ld (debug_mark),a  
4427 3a 36 44			ld a, (.dmark+1)  
442a 32 6c ee			ld (debug_mark+1),a  
442d 3a 37 44			ld a, (.dmark+2)  
4430 32 6d ee			ld (debug_mark+2),a  
4433 18 03			jr .pastdmark  
4435 ..			.dmark: db "LEF"  
4438 f1			.pastdmark: pop af  
4439			endm  
# End of macro DMARK
4439						CALLMONITOR 
4439 cd 6f ee			call debug_vector  
443c				endm  
# End of macro CALLMONITOR
443c					endif 
443c			 
443c					NEXTW 
443c c3 f2 1f			jp macro_next 
443f				endm 
# End of macro NEXTW
443f			.RIGHT: 
443f				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
443f 48				db WORD_SYS_CORE+52             
4440 68 44			dw .STR2NUM            
4442 06				db 5 + 1 
4443 .. 00			db "RIGHT",0              
4449				endm 
# End of macro CWHEAD
4449			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4449					if DEBUG_FORTH_WORDS_KEY 
4449						DMARK "RIG" 
4449 f5				push af  
444a 3a 5e 44			ld a, (.dmark)  
444d 32 6b ee			ld (debug_mark),a  
4450 3a 5f 44			ld a, (.dmark+1)  
4453 32 6c ee			ld (debug_mark+1),a  
4456 3a 60 44			ld a, (.dmark+2)  
4459 32 6d ee			ld (debug_mark+2),a  
445c 18 03			jr .pastdmark  
445e ..			.dmark: db "RIG"  
4461 f1			.pastdmark: pop af  
4462			endm  
# End of macro DMARK
4462						CALLMONITOR 
4462 cd 6f ee			call debug_vector  
4465				endm  
# End of macro CALLMONITOR
4465					endif 
4465			 
4465					NEXTW 
4465 c3 f2 1f			jp macro_next 
4468				endm 
# End of macro NEXTW
4468			 
4468			 
4468			.STR2NUM: 
4468				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4468 48				db WORD_SYS_CORE+52             
4469 f4 44			dw .NUM2STR            
446b 08				db 7 + 1 
446c .. 00			db "STR2NUM",0              
4474				endm 
# End of macro CWHEAD
4474			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4474			 
4474			 
4474			; TODO STR type check to do 
4474					if DEBUG_FORTH_WORDS_KEY 
4474						DMARK "S2N" 
4474 f5				push af  
4475 3a 89 44			ld a, (.dmark)  
4478 32 6b ee			ld (debug_mark),a  
447b 3a 8a 44			ld a, (.dmark+1)  
447e 32 6c ee			ld (debug_mark+1),a  
4481 3a 8b 44			ld a, (.dmark+2)  
4484 32 6d ee			ld (debug_mark+2),a  
4487 18 03			jr .pastdmark  
4489 ..			.dmark: db "S2N"  
448c f1			.pastdmark: pop af  
448d			endm  
# End of macro DMARK
448d						CALLMONITOR 
448d cd 6f ee			call debug_vector  
4490				endm  
# End of macro CALLMONITOR
4490					endif 
4490			 
4490					;FORTH_DSP 
4490					FORTH_DSP_VALUE 
4490 cd 25 1e			call macro_forth_dsp_value 
4493				endm 
# End of macro FORTH_DSP_VALUE
4493					;inc hl 
4493			 
4493 eb					ex de, hl 
4494					if DEBUG_FORTH_WORDS 
4494						DMARK "S2a" 
4494 f5				push af  
4495 3a a9 44			ld a, (.dmark)  
4498 32 6b ee			ld (debug_mark),a  
449b 3a aa 44			ld a, (.dmark+1)  
449e 32 6c ee			ld (debug_mark+1),a  
44a1 3a ab 44			ld a, (.dmark+2)  
44a4 32 6d ee			ld (debug_mark+2),a  
44a7 18 03			jr .pastdmark  
44a9 ..			.dmark: db "S2a"  
44ac f1			.pastdmark: pop af  
44ad			endm  
# End of macro DMARK
44ad						CALLMONITOR 
44ad cd 6f ee			call debug_vector  
44b0				endm  
# End of macro CALLMONITOR
44b0					endif 
44b0 cd dc 11				call string_to_uint16 
44b3			 
44b3					if DEBUG_FORTH_WORDS 
44b3						DMARK "S2b" 
44b3 f5				push af  
44b4 3a c8 44			ld a, (.dmark)  
44b7 32 6b ee			ld (debug_mark),a  
44ba 3a c9 44			ld a, (.dmark+1)  
44bd 32 6c ee			ld (debug_mark+1),a  
44c0 3a ca 44			ld a, (.dmark+2)  
44c3 32 6d ee			ld (debug_mark+2),a  
44c6 18 03			jr .pastdmark  
44c8 ..			.dmark: db "S2b"  
44cb f1			.pastdmark: pop af  
44cc			endm  
# End of macro DMARK
44cc						CALLMONITOR 
44cc cd 6f ee			call debug_vector  
44cf				endm  
# End of macro CALLMONITOR
44cf					endif 
44cf			;		push hl 
44cf					FORTH_DSP_POP 
44cf cd f4 1e			call macro_forth_dsp_pop 
44d2				endm 
# End of macro FORTH_DSP_POP
44d2			;		pop hl 
44d2					 
44d2					if DEBUG_FORTH_WORDS 
44d2						DMARK "S2b" 
44d2 f5				push af  
44d3 3a e7 44			ld a, (.dmark)  
44d6 32 6b ee			ld (debug_mark),a  
44d9 3a e8 44			ld a, (.dmark+1)  
44dc 32 6c ee			ld (debug_mark+1),a  
44df 3a e9 44			ld a, (.dmark+2)  
44e2 32 6d ee			ld (debug_mark+2),a  
44e5 18 03			jr .pastdmark  
44e7 ..			.dmark: db "S2b"  
44ea f1			.pastdmark: pop af  
44eb			endm  
# End of macro DMARK
44eb						CALLMONITOR 
44eb cd 6f ee			call debug_vector  
44ee				endm  
# End of macro CALLMONITOR
44ee					endif 
44ee cd 45 1c				call forth_push_numhl	 
44f1			 
44f1				 
44f1				       NEXTW 
44f1 c3 f2 1f			jp macro_next 
44f4				endm 
# End of macro NEXTW
44f4			.NUM2STR: 
44f4				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
44f4 48				db WORD_SYS_CORE+52             
44f5 03 45			dw .CONCAT            
44f7 08				db 7 + 1 
44f8 .. 00			db "NUM2STR",0              
4500				endm 
# End of macro CWHEAD
4500			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4500			 
4500			;		; malloc a string to target 
4500			;		ld hl, 10     ; TODO max string size should be fine 
4500			;		call malloc 
4500			;		push hl    ; save malloc location 
4500			; 
4500			; 
4500			;; TODO check int type 
4500			;		FORTH_DSP_VALUEHL 
4500			;		ld a, l 
4500			;		call DispAToASCII   
4500			;;TODO need to chage above call to dump into string 
4500			; 
4500			; 
4500			 
4500				       NEXTW 
4500 c3 f2 1f			jp macro_next 
4503				endm 
# End of macro NEXTW
4503			 
4503			.CONCAT: 
4503				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4503 48				db WORD_SYS_CORE+52             
4504 b6 45			dw .FIND            
4506 07				db 6 + 1 
4507 .. 00			db "CONCAT",0              
450e				endm 
# End of macro CWHEAD
450e			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
450e			 
450e			; TODO check string type 
450e			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
450e			 
450e					if DEBUG_FORTH_WORDS_KEY 
450e						DMARK "CON" 
450e f5				push af  
450f 3a 23 45			ld a, (.dmark)  
4512 32 6b ee			ld (debug_mark),a  
4515 3a 24 45			ld a, (.dmark+1)  
4518 32 6c ee			ld (debug_mark+1),a  
451b 3a 25 45			ld a, (.dmark+2)  
451e 32 6d ee			ld (debug_mark+2),a  
4521 18 03			jr .pastdmark  
4523 ..			.dmark: db "CON"  
4526 f1			.pastdmark: pop af  
4527			endm  
# End of macro DMARK
4527						CALLMONITOR 
4527 cd 6f ee			call debug_vector  
452a				endm  
# End of macro CALLMONITOR
452a					endif 
452a			 
452a			 
452a					FORTH_DSP_VALUE 
452a cd 25 1e			call macro_forth_dsp_value 
452d				endm 
# End of macro FORTH_DSP_VALUE
452d e5					push hl   ; s2 
452e			 
452e					FORTH_DSP_POP 
452e cd f4 1e			call macro_forth_dsp_pop 
4531				endm 
# End of macro FORTH_DSP_POP
4531			 
4531					FORTH_DSP_VALUE 
4531 cd 25 1e			call macro_forth_dsp_value 
4534				endm 
# End of macro FORTH_DSP_VALUE
4534			 
4534 e5					push hl   ; s1 
4535			 
4535					FORTH_DSP_POP 
4535 cd f4 1e			call macro_forth_dsp_pop 
4538				endm 
# End of macro FORTH_DSP_POP
4538					 
4538			 
4538					; copy s1 
4538			 
4538				 
4538					; save ptr 
4538 e1					pop hl  
4539 e5					push hl 
453a 3e 00				ld a, 0 
453c cd 50 12				call strlent 
453f					;inc hl    ; zer0 
453f 06 00				ld b, 0 
4541 4d					ld c, l 
4542 e1					pop hl		 
4543 11 c1 e2				ld de, scratch	 
4546					if DEBUG_FORTH_WORDS 
4546						DMARK "CO1" 
4546 f5				push af  
4547 3a 5b 45			ld a, (.dmark)  
454a 32 6b ee			ld (debug_mark),a  
454d 3a 5c 45			ld a, (.dmark+1)  
4550 32 6c ee			ld (debug_mark+1),a  
4553 3a 5d 45			ld a, (.dmark+2)  
4556 32 6d ee			ld (debug_mark+2),a  
4559 18 03			jr .pastdmark  
455b ..			.dmark: db "CO1"  
455e f1			.pastdmark: pop af  
455f			endm  
# End of macro DMARK
455f						CALLMONITOR 
455f cd 6f ee			call debug_vector  
4562				endm  
# End of macro CALLMONITOR
4562					endif 
4562 ed b0				ldir 
4564			 
4564 e1					pop hl 
4565 e5					push hl 
4566 d5					push de 
4567			 
4567			 
4567 3e 00				ld a, 0 
4569 cd 50 12				call strlent 
456c 23					inc hl    ; zer0 
456d 23					inc hl 
456e 06 00				ld b, 0 
4570 4d					ld c, l 
4571 d1					pop de 
4572 e1					pop hl		 
4573					if DEBUG_FORTH_WORDS 
4573						DMARK "CO2" 
4573 f5				push af  
4574 3a 88 45			ld a, (.dmark)  
4577 32 6b ee			ld (debug_mark),a  
457a 3a 89 45			ld a, (.dmark+1)  
457d 32 6c ee			ld (debug_mark+1),a  
4580 3a 8a 45			ld a, (.dmark+2)  
4583 32 6d ee			ld (debug_mark+2),a  
4586 18 03			jr .pastdmark  
4588 ..			.dmark: db "CO2"  
458b f1			.pastdmark: pop af  
458c			endm  
# End of macro DMARK
458c						CALLMONITOR 
458c cd 6f ee			call debug_vector  
458f				endm  
# End of macro CALLMONITOR
458f					endif 
458f ed b0				ldir 
4591			 
4591			 
4591			 
4591 21 c1 e2				ld hl, scratch 
4594					if DEBUG_FORTH_WORDS 
4594						DMARK "CO5" 
4594 f5				push af  
4595 3a a9 45			ld a, (.dmark)  
4598 32 6b ee			ld (debug_mark),a  
459b 3a aa 45			ld a, (.dmark+1)  
459e 32 6c ee			ld (debug_mark+1),a  
45a1 3a ab 45			ld a, (.dmark+2)  
45a4 32 6d ee			ld (debug_mark+2),a  
45a7 18 03			jr .pastdmark  
45a9 ..			.dmark: db "CO5"  
45ac f1			.pastdmark: pop af  
45ad			endm  
# End of macro DMARK
45ad						CALLMONITOR 
45ad cd 6f ee			call debug_vector  
45b0				endm  
# End of macro CALLMONITOR
45b0					endif 
45b0			 
45b0 cd b3 1c				call forth_push_str 
45b3			 
45b3			 
45b3			 
45b3			 
45b3				       NEXTW 
45b3 c3 f2 1f			jp macro_next 
45b6				endm 
# End of macro NEXTW
45b6			 
45b6			 
45b6			.FIND: 
45b6				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
45b6 4b				db WORD_SYS_CORE+55             
45b7 74 46			dw .LEN            
45b9 05				db 4 + 1 
45ba .. 00			db "FIND",0              
45bf				endm 
# End of macro CWHEAD
45bf			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
45bf			 
45bf					if DEBUG_FORTH_WORDS_KEY 
45bf						DMARK "FND" 
45bf f5				push af  
45c0 3a d4 45			ld a, (.dmark)  
45c3 32 6b ee			ld (debug_mark),a  
45c6 3a d5 45			ld a, (.dmark+1)  
45c9 32 6c ee			ld (debug_mark+1),a  
45cc 3a d6 45			ld a, (.dmark+2)  
45cf 32 6d ee			ld (debug_mark+2),a  
45d2 18 03			jr .pastdmark  
45d4 ..			.dmark: db "FND"  
45d7 f1			.pastdmark: pop af  
45d8			endm  
# End of macro DMARK
45d8						CALLMONITOR 
45d8 cd 6f ee			call debug_vector  
45db				endm  
# End of macro CALLMONITOR
45db					endif 
45db			 
45db			; TODO check string type 
45db					FORTH_DSP_VALUE 
45db cd 25 1e			call macro_forth_dsp_value 
45de				endm 
# End of macro FORTH_DSP_VALUE
45de			 
45de e5					push hl    
45df 7e					ld a,(hl)    ; char to find   
45e0			; TODO change char to substr 
45e0			 
45e0 f5					push af 
45e1					 
45e1			 
45e1			 
45e1					if DEBUG_FORTH_WORDS 
45e1						DMARK "FN1" 
45e1 f5				push af  
45e2 3a f6 45			ld a, (.dmark)  
45e5 32 6b ee			ld (debug_mark),a  
45e8 3a f7 45			ld a, (.dmark+1)  
45eb 32 6c ee			ld (debug_mark+1),a  
45ee 3a f8 45			ld a, (.dmark+2)  
45f1 32 6d ee			ld (debug_mark+2),a  
45f4 18 03			jr .pastdmark  
45f6 ..			.dmark: db "FN1"  
45f9 f1			.pastdmark: pop af  
45fa			endm  
# End of macro DMARK
45fa						CALLMONITOR 
45fa cd 6f ee			call debug_vector  
45fd				endm  
# End of macro CALLMONITOR
45fd					endif 
45fd			 
45fd					FORTH_DSP_POP 
45fd cd f4 1e			call macro_forth_dsp_pop 
4600				endm 
# End of macro FORTH_DSP_POP
4600			 
4600					; string to search 
4600			 
4600					FORTH_DSP_VALUE 
4600 cd 25 1e			call macro_forth_dsp_value 
4603				endm 
# End of macro FORTH_DSP_VALUE
4603			 
4603 d1					pop de  ; d is char to find  
4604			 
4604					if DEBUG_FORTH_WORDS 
4604						DMARK "FN2" 
4604 f5				push af  
4605 3a 19 46			ld a, (.dmark)  
4608 32 6b ee			ld (debug_mark),a  
460b 3a 1a 46			ld a, (.dmark+1)  
460e 32 6c ee			ld (debug_mark+1),a  
4611 3a 1b 46			ld a, (.dmark+2)  
4614 32 6d ee			ld (debug_mark+2),a  
4617 18 03			jr .pastdmark  
4619 ..			.dmark: db "FN2"  
461c f1			.pastdmark: pop af  
461d			endm  
# End of macro DMARK
461d						CALLMONITOR 
461d cd 6f ee			call debug_vector  
4620				endm  
# End of macro CALLMONITOR
4620					endif 
4620					 
4620 01 00 00				ld bc, 0 
4623 7e			.findchar:      ld a,(hl) 
4624 fe 00				cp 0   		 
4626 28 27				jr z, .finddone     
4628 ba					cp d 
4629 28 20				jr z, .foundchar 
462b 03					inc bc 
462c 23					inc hl 
462d					if DEBUG_FORTH_WORDS 
462d						DMARK "FN3" 
462d f5				push af  
462e 3a 42 46			ld a, (.dmark)  
4631 32 6b ee			ld (debug_mark),a  
4634 3a 43 46			ld a, (.dmark+1)  
4637 32 6c ee			ld (debug_mark+1),a  
463a 3a 44 46			ld a, (.dmark+2)  
463d 32 6d ee			ld (debug_mark+2),a  
4640 18 03			jr .pastdmark  
4642 ..			.dmark: db "FN3"  
4645 f1			.pastdmark: pop af  
4646			endm  
# End of macro DMARK
4646						CALLMONITOR 
4646 cd 6f ee			call debug_vector  
4649				endm  
# End of macro CALLMONITOR
4649					endif 
4649 18 d8				jr .findchar 
464b			 
464b			 
464b c5			.foundchar:	push bc 
464c e1					pop hl 
464d 18 03				jr .findexit 
464f			 
464f			 
464f							 
464f			 
464f			.finddone:     ; got to end of string with no find 
464f 21 00 00				ld hl, 0 
4652			.findexit: 
4652			 
4652					if DEBUG_FORTH_WORDS 
4652						DMARK "FNd" 
4652 f5				push af  
4653 3a 67 46			ld a, (.dmark)  
4656 32 6b ee			ld (debug_mark),a  
4659 3a 68 46			ld a, (.dmark+1)  
465c 32 6c ee			ld (debug_mark+1),a  
465f 3a 69 46			ld a, (.dmark+2)  
4662 32 6d ee			ld (debug_mark+2),a  
4665 18 03			jr .pastdmark  
4667 ..			.dmark: db "FNd"  
466a f1			.pastdmark: pop af  
466b			endm  
# End of macro DMARK
466b						CALLMONITOR 
466b cd 6f ee			call debug_vector  
466e				endm  
# End of macro CALLMONITOR
466e					endif 
466e cd 45 1c			call forth_push_numhl 
4671			 
4671				       NEXTW 
4671 c3 f2 1f			jp macro_next 
4674				endm 
# End of macro NEXTW
4674			 
4674			.LEN: 
4674				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4674 4c				db WORD_SYS_CORE+56             
4675 de 46			dw .ASC            
4677 06				db 5 + 1 
4678 .. 00			db "COUNT",0              
467e				endm 
# End of macro CWHEAD
467e			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
467e			 
467e					if DEBUG_FORTH_WORDS_KEY 
467e						DMARK "CNT" 
467e f5				push af  
467f 3a 93 46			ld a, (.dmark)  
4682 32 6b ee			ld (debug_mark),a  
4685 3a 94 46			ld a, (.dmark+1)  
4688 32 6c ee			ld (debug_mark+1),a  
468b 3a 95 46			ld a, (.dmark+2)  
468e 32 6d ee			ld (debug_mark+2),a  
4691 18 03			jr .pastdmark  
4693 ..			.dmark: db "CNT"  
4696 f1			.pastdmark: pop af  
4697			endm  
# End of macro DMARK
4697						CALLMONITOR 
4697 cd 6f ee			call debug_vector  
469a				endm  
# End of macro CALLMONITOR
469a					endif 
469a			; TODO check string type 
469a					FORTH_DSP_VALUE 
469a cd 25 1e			call macro_forth_dsp_value 
469d				endm 
# End of macro FORTH_DSP_VALUE
469d			 
469d			 
469d					if DEBUG_FORTH_WORDS 
469d						DMARK "CN?" 
469d f5				push af  
469e 3a b2 46			ld a, (.dmark)  
46a1 32 6b ee			ld (debug_mark),a  
46a4 3a b3 46			ld a, (.dmark+1)  
46a7 32 6c ee			ld (debug_mark+1),a  
46aa 3a b4 46			ld a, (.dmark+2)  
46ad 32 6d ee			ld (debug_mark+2),a  
46b0 18 03			jr .pastdmark  
46b2 ..			.dmark: db "CN?"  
46b5 f1			.pastdmark: pop af  
46b6			endm  
# End of macro DMARK
46b6						CALLMONITOR 
46b6 cd 6f ee			call debug_vector  
46b9				endm  
# End of macro CALLMONITOR
46b9					endif 
46b9 cd 45 12				call strlenz 
46bc					if DEBUG_FORTH_WORDS 
46bc						DMARK "CNl" 
46bc f5				push af  
46bd 3a d1 46			ld a, (.dmark)  
46c0 32 6b ee			ld (debug_mark),a  
46c3 3a d2 46			ld a, (.dmark+1)  
46c6 32 6c ee			ld (debug_mark+1),a  
46c9 3a d3 46			ld a, (.dmark+2)  
46cc 32 6d ee			ld (debug_mark+2),a  
46cf 18 03			jr .pastdmark  
46d1 ..			.dmark: db "CNl"  
46d4 f1			.pastdmark: pop af  
46d5			endm  
# End of macro DMARK
46d5						CALLMONITOR 
46d5 cd 6f ee			call debug_vector  
46d8				endm  
# End of macro CALLMONITOR
46d8					endif 
46d8			 
46d8 cd 45 1c				call forth_push_numhl 
46db			 
46db			 
46db			 
46db				       NEXTW 
46db c3 f2 1f			jp macro_next 
46de				endm 
# End of macro NEXTW
46de			.ASC: 
46de				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
46de 4d				db WORD_SYS_CORE+57             
46df 4c 47			dw .CHR            
46e1 04				db 3 + 1 
46e2 .. 00			db "ASC",0              
46e6				endm 
# End of macro CWHEAD
46e6			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
46e6					if DEBUG_FORTH_WORDS_KEY 
46e6						DMARK "ASC" 
46e6 f5				push af  
46e7 3a fb 46			ld a, (.dmark)  
46ea 32 6b ee			ld (debug_mark),a  
46ed 3a fc 46			ld a, (.dmark+1)  
46f0 32 6c ee			ld (debug_mark+1),a  
46f3 3a fd 46			ld a, (.dmark+2)  
46f6 32 6d ee			ld (debug_mark+2),a  
46f9 18 03			jr .pastdmark  
46fb ..			.dmark: db "ASC"  
46fe f1			.pastdmark: pop af  
46ff			endm  
# End of macro DMARK
46ff						CALLMONITOR 
46ff cd 6f ee			call debug_vector  
4702				endm  
# End of macro CALLMONITOR
4702					endif 
4702					FORTH_DSP_VALUE 
4702 cd 25 1e			call macro_forth_dsp_value 
4705				endm 
# End of macro FORTH_DSP_VALUE
4705					;v5 FORTH_DSP_VALUE 
4705			;		inc hl      ; now at start of numeric as string 
4705			 
4705 e5					push hl 
4706			 
4706					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4706 cd f4 1e			call macro_forth_dsp_pop 
4709				endm 
# End of macro FORTH_DSP_POP
4709			 
4709 e1					pop hl 
470a			 
470a					if DEBUG_FORTH_WORDS 
470a						DMARK "AS1" 
470a f5				push af  
470b 3a 1f 47			ld a, (.dmark)  
470e 32 6b ee			ld (debug_mark),a  
4711 3a 20 47			ld a, (.dmark+1)  
4714 32 6c ee			ld (debug_mark+1),a  
4717 3a 21 47			ld a, (.dmark+2)  
471a 32 6d ee			ld (debug_mark+2),a  
471d 18 03			jr .pastdmark  
471f ..			.dmark: db "AS1"  
4722 f1			.pastdmark: pop af  
4723			endm  
# End of macro DMARK
4723						CALLMONITOR 
4723 cd 6f ee			call debug_vector  
4726				endm  
# End of macro CALLMONITOR
4726					endif 
4726					; push the content of a onto the stack as a value 
4726			 
4726 7e					ld a,(hl)   ; get char 
4727 26 00				ld h,0 
4729 6f					ld l,a 
472a					if DEBUG_FORTH_WORDS 
472a						DMARK "AS2" 
472a f5				push af  
472b 3a 3f 47			ld a, (.dmark)  
472e 32 6b ee			ld (debug_mark),a  
4731 3a 40 47			ld a, (.dmark+1)  
4734 32 6c ee			ld (debug_mark+1),a  
4737 3a 41 47			ld a, (.dmark+2)  
473a 32 6d ee			ld (debug_mark+2),a  
473d 18 03			jr .pastdmark  
473f ..			.dmark: db "AS2"  
4742 f1			.pastdmark: pop af  
4743			endm  
# End of macro DMARK
4743						CALLMONITOR 
4743 cd 6f ee			call debug_vector  
4746				endm  
# End of macro CALLMONITOR
4746					endif 
4746 cd 45 1c				call forth_push_numhl 
4749			 
4749				       NEXTW 
4749 c3 f2 1f			jp macro_next 
474c				endm 
# End of macro NEXTW
474c			 
474c			.CHR: 
474c				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
474c 4d				db WORD_SYS_CORE+57             
474d 88 47			dw .ENDSTR            
474f 04				db 3 + 1 
4750 .. 00			db "CHR",0              
4754				endm 
# End of macro CWHEAD
4754			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4754					if DEBUG_FORTH_WORDS_KEY 
4754						DMARK "CHR" 
4754 f5				push af  
4755 3a 69 47			ld a, (.dmark)  
4758 32 6b ee			ld (debug_mark),a  
475b 3a 6a 47			ld a, (.dmark+1)  
475e 32 6c ee			ld (debug_mark+1),a  
4761 3a 6b 47			ld a, (.dmark+2)  
4764 32 6d ee			ld (debug_mark+2),a  
4767 18 03			jr .pastdmark  
4769 ..			.dmark: db "CHR"  
476c f1			.pastdmark: pop af  
476d			endm  
# End of macro DMARK
476d						CALLMONITOR 
476d cd 6f ee			call debug_vector  
4770				endm  
# End of macro CALLMONITOR
4770					endif 
4770					FORTH_DSP_VALUEHL 
4770 cd 3c 1e			call macro_dsp_valuehl 
4773				endm 
# End of macro FORTH_DSP_VALUEHL
4773			 
4773					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4773 cd f4 1e			call macro_forth_dsp_pop 
4776				endm 
# End of macro FORTH_DSP_POP
4776			 
4776					; save asci byte as a zero term string and push string 
4776			 
4776 7d					ld a,l 
4777 32 c1 e2				ld (scratch), a 
477a			 
477a 3e 00				ld a, 0 
477c 32 c2 e2				ld (scratch+1), a 
477f			 
477f 21 c1 e2				ld hl, scratch 
4782 cd b3 1c				call forth_push_str 
4785			 
4785			 
4785				       NEXTW 
4785 c3 f2 1f			jp macro_next 
4788				endm 
# End of macro NEXTW
4788			 
4788			 
4788			 
4788			 
4788			.ENDSTR: 
4788			; eof 
4788			 
# End of file forth_words_str.asm
4788			include "forth_words_key.asm" 
4788			 
4788			; | ## Keyboard Words 
4788			 
4788			.KEY: 
4788				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4788 3e				db WORD_SYS_CORE+42             
4789 b8 47			dw .WAITK            
478b 04				db 3 + 1 
478c .. 00			db "KEY",0              
4790				endm 
# End of macro CWHEAD
4790			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4790			 
4790					if DEBUG_FORTH_WORDS_KEY 
4790						DMARK "KEY" 
4790 f5				push af  
4791 3a a5 47			ld a, (.dmark)  
4794 32 6b ee			ld (debug_mark),a  
4797 3a a6 47			ld a, (.dmark+1)  
479a 32 6c ee			ld (debug_mark+1),a  
479d 3a a7 47			ld a, (.dmark+2)  
47a0 32 6d ee			ld (debug_mark+2),a  
47a3 18 03			jr .pastdmark  
47a5 ..			.dmark: db "KEY"  
47a8 f1			.pastdmark: pop af  
47a9			endm  
# End of macro DMARK
47a9						CALLMONITOR 
47a9 cd 6f ee			call debug_vector  
47ac				endm  
# End of macro CALLMONITOR
47ac					endif 
47ac			; TODO currently waits 
47ac cd 76 65				call cin 
47af					;call cin_wait 
47af 6f					ld l, a 
47b0 26 00				ld h, 0 
47b2 cd 45 1c				call forth_push_numhl 
47b5					NEXTW 
47b5 c3 f2 1f			jp macro_next 
47b8				endm 
# End of macro NEXTW
47b8			.WAITK: 
47b8				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
47b8 3f				db WORD_SYS_CORE+43             
47b9 ea 47			dw .ACCEPT            
47bb 06				db 5 + 1 
47bc .. 00			db "WAITK",0              
47c2				endm 
# End of macro CWHEAD
47c2			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
47c2					if DEBUG_FORTH_WORDS_KEY 
47c2						DMARK "WAI" 
47c2 f5				push af  
47c3 3a d7 47			ld a, (.dmark)  
47c6 32 6b ee			ld (debug_mark),a  
47c9 3a d8 47			ld a, (.dmark+1)  
47cc 32 6c ee			ld (debug_mark+1),a  
47cf 3a d9 47			ld a, (.dmark+2)  
47d2 32 6d ee			ld (debug_mark+2),a  
47d5 18 03			jr .pastdmark  
47d7 ..			.dmark: db "WAI"  
47da f1			.pastdmark: pop af  
47db			endm  
# End of macro DMARK
47db						CALLMONITOR 
47db cd 6f ee			call debug_vector  
47de				endm  
# End of macro CALLMONITOR
47de					endif 
47de cd 6e 65				call cin_wait 
47e1 6f					ld l, a 
47e2 26 00				ld h, 0 
47e4 cd 45 1c				call forth_push_numhl 
47e7					NEXTW 
47e7 c3 f2 1f			jp macro_next 
47ea				endm 
# End of macro NEXTW
47ea			.ACCEPT: 
47ea				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47ea 40				db WORD_SYS_CORE+44             
47eb 48 48			dw .EDIT            
47ed 07				db 6 + 1 
47ee .. 00			db "ACCEPT",0              
47f5				endm 
# End of macro CWHEAD
47f5			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47f5					; TODO crashes on push 
47f5					if DEBUG_FORTH_WORDS_KEY 
47f5						DMARK "ACC" 
47f5 f5				push af  
47f6 3a 0a 48			ld a, (.dmark)  
47f9 32 6b ee			ld (debug_mark),a  
47fc 3a 0b 48			ld a, (.dmark+1)  
47ff 32 6c ee			ld (debug_mark+1),a  
4802 3a 0c 48			ld a, (.dmark+2)  
4805 32 6d ee			ld (debug_mark+2),a  
4808 18 03			jr .pastdmark  
480a ..			.dmark: db "ACC"  
480d f1			.pastdmark: pop af  
480e			endm  
# End of macro DMARK
480e						CALLMONITOR 
480e cd 6f ee			call debug_vector  
4811				endm  
# End of macro CALLMONITOR
4811					endif 
4811 21 bf e4				ld hl, os_input 
4814 3e 00				ld a, 0 
4816 77					ld (hl),a 
4817 3a 5e ea				ld a,(f_cursor_ptr) 
481a 16 64				ld d, 100 
481c 0e 00				ld c, 0 
481e 1e 28				ld e, 40 
4820 cd 14 0e				call input_str 
4823					; TODO perhaps do a type check and wrap in quotes if not a number 
4823 21 bf e4				ld hl, os_input 
4826					if DEBUG_FORTH_WORDS 
4826						DMARK "AC1" 
4826 f5				push af  
4827 3a 3b 48			ld a, (.dmark)  
482a 32 6b ee			ld (debug_mark),a  
482d 3a 3c 48			ld a, (.dmark+1)  
4830 32 6c ee			ld (debug_mark+1),a  
4833 3a 3d 48			ld a, (.dmark+2)  
4836 32 6d ee			ld (debug_mark+2),a  
4839 18 03			jr .pastdmark  
483b ..			.dmark: db "AC1"  
483e f1			.pastdmark: pop af  
483f			endm  
# End of macro DMARK
483f						CALLMONITOR 
483f cd 6f ee			call debug_vector  
4842				endm  
# End of macro CALLMONITOR
4842					endif 
4842 cd b3 1c				call forth_push_str 
4845					NEXTW 
4845 c3 f2 1f			jp macro_next 
4848				endm 
# End of macro NEXTW
4848			 
4848			.EDIT: 
4848				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4848 40				db WORD_SYS_CORE+44             
4849 ea 48			dw .DEDIT            
484b 05				db 4 + 1 
484c .. 00			db "EDIT",0              
4851				endm 
# End of macro CWHEAD
4851			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4851			 
4851					; TODO does not copy from stack 
4851					if DEBUG_FORTH_WORDS_KEY 
4851						DMARK "EDT" 
4851 f5				push af  
4852 3a 66 48			ld a, (.dmark)  
4855 32 6b ee			ld (debug_mark),a  
4858 3a 67 48			ld a, (.dmark+1)  
485b 32 6c ee			ld (debug_mark+1),a  
485e 3a 68 48			ld a, (.dmark+2)  
4861 32 6d ee			ld (debug_mark+2),a  
4864 18 03			jr .pastdmark  
4866 ..			.dmark: db "EDT"  
4869 f1			.pastdmark: pop af  
486a			endm  
# End of macro DMARK
486a						CALLMONITOR 
486a cd 6f ee			call debug_vector  
486d				endm  
# End of macro CALLMONITOR
486d					endif 
486d			 
486d					;FORTH_DSP 
486d					FORTH_DSP_VALUEHL 
486d cd 3c 1e			call macro_dsp_valuehl 
4870				endm 
# End of macro FORTH_DSP_VALUEHL
4870			;		inc hl    ; TODO do type check 
4870			 
4870			;		call get_word_hl 
4870 e5					push hl 
4871					if DEBUG_FORTH_WORDS 
4871						DMARK "EDp" 
4871 f5				push af  
4872 3a 86 48			ld a, (.dmark)  
4875 32 6b ee			ld (debug_mark),a  
4878 3a 87 48			ld a, (.dmark+1)  
487b 32 6c ee			ld (debug_mark+1),a  
487e 3a 88 48			ld a, (.dmark+2)  
4881 32 6d ee			ld (debug_mark+2),a  
4884 18 03			jr .pastdmark  
4886 ..			.dmark: db "EDp"  
4889 f1			.pastdmark: pop af  
488a			endm  
# End of macro DMARK
488a						CALLMONITOR 
488a cd 6f ee			call debug_vector  
488d				endm  
# End of macro CALLMONITOR
488d					endif 
488d				;	ld a, 0 
488d cd 45 12				call strlenz 
4890 23					inc hl 
4891			 
4891 06 00				ld b, 0 
4893 4d					ld c, l 
4894			 
4894 e1					pop hl 
4895 11 bf e4				ld de, os_input 
4898					if DEBUG_FORTH_WORDS_KEY 
4898						DMARK "EDc" 
4898 f5				push af  
4899 3a ad 48			ld a, (.dmark)  
489c 32 6b ee			ld (debug_mark),a  
489f 3a ae 48			ld a, (.dmark+1)  
48a2 32 6c ee			ld (debug_mark+1),a  
48a5 3a af 48			ld a, (.dmark+2)  
48a8 32 6d ee			ld (debug_mark+2),a  
48ab 18 03			jr .pastdmark  
48ad ..			.dmark: db "EDc"  
48b0 f1			.pastdmark: pop af  
48b1			endm  
# End of macro DMARK
48b1						CALLMONITOR 
48b1 cd 6f ee			call debug_vector  
48b4				endm  
# End of macro CALLMONITOR
48b4					endif 
48b4 ed b0				ldir 
48b6			 
48b6			 
48b6 21 bf e4				ld hl, os_input 
48b9					;ld a, 0 
48b9					;ld (hl),a 
48b9 3a 5e ea				ld a,(f_cursor_ptr) 
48bc 16 64				ld d, 100 
48be 0e 00				ld c, 0 
48c0 1e 28				ld e, 40 
48c2 cd 14 0e				call input_str 
48c5					; TODO perhaps do a type check and wrap in quotes if not a number 
48c5 21 bf e4				ld hl, os_input 
48c8					if DEBUG_FORTH_WORDS 
48c8						DMARK "ED1" 
48c8 f5				push af  
48c9 3a dd 48			ld a, (.dmark)  
48cc 32 6b ee			ld (debug_mark),a  
48cf 3a de 48			ld a, (.dmark+1)  
48d2 32 6c ee			ld (debug_mark+1),a  
48d5 3a df 48			ld a, (.dmark+2)  
48d8 32 6d ee			ld (debug_mark+2),a  
48db 18 03			jr .pastdmark  
48dd ..			.dmark: db "ED1"  
48e0 f1			.pastdmark: pop af  
48e1			endm  
# End of macro DMARK
48e1						CALLMONITOR 
48e1 cd 6f ee			call debug_vector  
48e4				endm  
# End of macro CALLMONITOR
48e4					endif 
48e4 cd b3 1c				call forth_push_str 
48e7					NEXTW 
48e7 c3 f2 1f			jp macro_next 
48ea				endm 
# End of macro NEXTW
48ea			 
48ea			.DEDIT: 
48ea				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
48ea 40				db WORD_SYS_CORE+44             
48eb 4c 49			dw .ENDKEY            
48ed 06				db 5 + 1 
48ee .. 00			db "DEDIT",0              
48f4				endm 
# End of macro CWHEAD
48f4			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
48f4			 
48f4					; TODO does not copy from stack 
48f4					if DEBUG_FORTH_WORDS_KEY 
48f4						DMARK "DED" 
48f4 f5				push af  
48f5 3a 09 49			ld a, (.dmark)  
48f8 32 6b ee			ld (debug_mark),a  
48fb 3a 0a 49			ld a, (.dmark+1)  
48fe 32 6c ee			ld (debug_mark+1),a  
4901 3a 0b 49			ld a, (.dmark+2)  
4904 32 6d ee			ld (debug_mark+2),a  
4907 18 03			jr .pastdmark  
4909 ..			.dmark: db "DED"  
490c f1			.pastdmark: pop af  
490d			endm  
# End of macro DMARK
490d						CALLMONITOR 
490d cd 6f ee			call debug_vector  
4910				endm  
# End of macro CALLMONITOR
4910					endif 
4910			 
4910					;FORTH_DSP 
4910					FORTH_DSP_VALUEHL 
4910 cd 3c 1e			call macro_dsp_valuehl 
4913				endm 
# End of macro FORTH_DSP_VALUEHL
4913			;		inc hl    ; TODO do type check 
4913			 
4913			;		call get_word_hl 
4913 e5					push hl 
4914 e5					push hl 
4915					FORTH_DSP_POP 
4915 cd f4 1e			call macro_forth_dsp_pop 
4918				endm 
# End of macro FORTH_DSP_POP
4918 e1					pop hl 
4919					if DEBUG_FORTH_WORDS 
4919						DMARK "EDp" 
4919 f5				push af  
491a 3a 2e 49			ld a, (.dmark)  
491d 32 6b ee			ld (debug_mark),a  
4920 3a 2f 49			ld a, (.dmark+1)  
4923 32 6c ee			ld (debug_mark+1),a  
4926 3a 30 49			ld a, (.dmark+2)  
4929 32 6d ee			ld (debug_mark+2),a  
492c 18 03			jr .pastdmark  
492e ..			.dmark: db "EDp"  
4931 f1			.pastdmark: pop af  
4932			endm  
# End of macro DMARK
4932						CALLMONITOR 
4932 cd 6f ee			call debug_vector  
4935				endm  
# End of macro CALLMONITOR
4935					endif 
4935				;	ld a, 0 
4935 cd 45 12				call strlenz 
4938 23					inc hl 
4939			 
4939 06 00				ld b, 0 
493b 4d					ld c, l 
493c			 
493c e1					pop hl 
493d			 
493d					;ld a, 0 
493d					;ld (hl),a 
493d 3a 5e ea				ld a,(f_cursor_ptr) 
4940 16 64				ld d, 100 
4942 0e 00				ld c, 0 
4944 1e 28				ld e, 40 
4946 cd 14 0e				call input_str 
4949					; TODO perhaps do a type check and wrap in quotes if not a number 
4949					NEXTW 
4949 c3 f2 1f			jp macro_next 
494c				endm 
# End of macro NEXTW
494c			 
494c			 
494c			.ENDKEY: 
494c			; eof 
494c			 
# End of file forth_words_key.asm
494c			include "forth_words_const.asm" 
494c			 
494c			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
494c			 
494c			 
494c			.SPITIME: 
494c				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
494c 77				db WORD_SYS_CORE+99             
494d 61 49			dw .VA            
494f 08				db 7 + 1 
4950 .. 00			db "SPITIME",0              
4958				endm 
# End of macro CWHEAD
4958			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4958			; 
4958			; | If using BANK devices then leave as is. 
4958			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4958			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4958			 
4958 21 64 ea				ld hl, spi_clktime  
495b cd 45 1c				call forth_push_numhl 
495e			 
495e					NEXTW 
495e c3 f2 1f			jp macro_next 
4961				endm 
# End of macro NEXTW
4961			 
4961			 
4961			.VA: 
4961				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4961 77				db WORD_SYS_CORE+99             
4962 71 49			dw .SYMBOL            
4964 03				db 2 + 1 
4965 .. 00			db "VA",0              
4968				endm 
# End of macro CWHEAD
4968			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4968 21 28 ea				ld hl, cli_var_array 
496b cd 45 1c				call forth_push_numhl 
496e			 
496e					NEXTW 
496e c3 f2 1f			jp macro_next 
4971				endm 
# End of macro NEXTW
4971			 
4971			.SYMBOL: 
4971				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4971 77				db WORD_SYS_CORE+99             
4972 7b 4a			dw .ENDCONST            
4974 07				db 6 + 1 
4975 .. 00			db "SYMBOL",0              
497c				endm 
# End of macro CWHEAD
497c			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
497c			; | 
497c			; | The value is the number reference and the final address is pushed to stack 
497c			 
497c			; | dw sym_table 
497c			; | dw nmi_vector 
497c			; | dw cli_autodisplay 
497c			; | dw cli_data_sp 
497c			; | dw cli_data_stack 
497c			; | dw cli_loop_sp 
497c			; | dw cli_loop_stack 
497c			; | dw cli_var_array 
497c			; | dw cursor_col 
497c			; | dw cursor_ptr 
497c			; | ; 10 
497c			; | dw cursor_row 
497c			; | dw debug_mark 
497c			; | dw display_fb0 
497c			; | dw display_fb1 
497c			; | dw display_fb2 
497c			; | dw display_fb3 
497c			; | dw display_fb_active 
497c			; | dw execscratch 
497c			; | dw f_cursor_ptr 
497c			; | dw hardware_word 
497c			; | ;20 
497c			; | dw input_at_cursor 
497c			; | dw input_at_pos 
497c			; | dw input_cur_flash 
497c			; | dw input_cur_onoff 
497c			; | dw input_cursor 
497c			; | dw input_display_size 
497c			; | dw input_len 
497c			; | dw input_ptr 
497c			; | dw input_size 
497c			; | dw input_start 
497c			; | ; 30 
497c			; | dw input_str 
497c			; | dw input_under_cursor 
497c			; | dw os_cli_cmd 
497c			; | dw os_cur_ptr 
497c			; | dw os_current_i 
497c			; | dw os_input 
497c			; | dw os_last_cmd 
497c			; | dw os_last_new_uword 
497c			; | dw debug_vector 
497c			; | dw os_view_hl 
497c			; | ;40 
497c			; | dw os_word_scratch 
497c			; | dw portbctl 
497c			; | dw portbdata 
497c			; | dw spi_cartdev 
497c			; | dw spi_cartdev2 
497c			; | dw spi_clktime 
497c			; | dw spi_device 
497c			; | dw spi_device_id 
497c			; | dw spi_portbyte 
497c			; | dw stackstore 
497c			; | ; 50 
497c			; | if STORAGE_SE 
497c			; | dw storage_actl 
497c			; | dw storage_adata 
497c			; | else 
497c			; | dw 0 
497c			; | dw 0 
497c			; | endif 
497c			; | dw storage_append 
497c			; | if STORAGE_SE 
497c			; | dw storage_bctl 
497c			; | else 
497c			; | dw 0 
497c			; | endif 
497c			; | dw store_bank_active 
497c			; | dw store_filecache 
497c			; | dw store_longread 
497c			; | dw store_openaddr 
497c			; | dw store_openext 
497c			; | dw store_openmaxext 
497c			; | ; 60 
497c			; | dw store_page 
497c			; | dw store_readbuf 
497c			; | dw store_readcont 
497c			; | dw store_readptr 
497c			; | dw store_tmpext 
497c			; | dw store_tmpid 
497c			; | dw store_tmppageid 
497c			; | dw malloc 
497c			; | dw free 
497c			; | dw cin 
497c			; | ; 70 
497c			; | dw cin_wait 
497c			; | dw forth_push_numhl 
497c			; | dw forth_push_str 
497c			 
497c					if DEBUG_FORTH_WORDS_KEY 
497c						DMARK "SYM" 
497c f5				push af  
497d 3a 91 49			ld a, (.dmark)  
4980 32 6b ee			ld (debug_mark),a  
4983 3a 92 49			ld a, (.dmark+1)  
4986 32 6c ee			ld (debug_mark+1),a  
4989 3a 93 49			ld a, (.dmark+2)  
498c 32 6d ee			ld (debug_mark+2),a  
498f 18 03			jr .pastdmark  
4991 ..			.dmark: db "SYM"  
4994 f1			.pastdmark: pop af  
4995			endm  
# End of macro DMARK
4995						CALLMONITOR 
4995 cd 6f ee			call debug_vector  
4998				endm  
# End of macro CALLMONITOR
4998					endif 
4998			 
4998					FORTH_DSP_VALUEHL 
4998 cd 3c 1e			call macro_dsp_valuehl 
499b				endm 
# End of macro FORTH_DSP_VALUEHL
499b			 
499b 7d					ld a, l     
499c			 
499c			 
499c					if DEBUG_FORTH_WORDS 
499c						DMARK "SY1" 
499c f5				push af  
499d 3a b1 49			ld a, (.dmark)  
49a0 32 6b ee			ld (debug_mark),a  
49a3 3a b2 49			ld a, (.dmark+1)  
49a6 32 6c ee			ld (debug_mark+1),a  
49a9 3a b3 49			ld a, (.dmark+2)  
49ac 32 6d ee			ld (debug_mark+2),a  
49af 18 03			jr .pastdmark  
49b1 ..			.dmark: db "SY1"  
49b4 f1			.pastdmark: pop af  
49b5			endm  
# End of macro DMARK
49b5						CALLMONITOR 
49b5 cd 6f ee			call debug_vector  
49b8				endm  
# End of macro CALLMONITOR
49b8					endif 
49b8					 
49b8 f5					push af	 
49b9					FORTH_DSP_POP 
49b9 cd f4 1e			call macro_forth_dsp_pop 
49bc				endm 
# End of macro FORTH_DSP_POP
49bc f1					pop af 
49bd			 
49bd cb 27				sla a  
49bf				 
49bf					 
49bf					if DEBUG_FORTH_WORDS 
49bf						DMARK "SY" 
49bf f5				push af  
49c0 3a d4 49			ld a, (.dmark)  
49c3 32 6b ee			ld (debug_mark),a  
49c6 3a d5 49			ld a, (.dmark+1)  
49c9 32 6c ee			ld (debug_mark+1),a  
49cc 3a d6 49			ld a, (.dmark+2)  
49cf 32 6d ee			ld (debug_mark+2),a  
49d2 18 02			jr .pastdmark  
49d4 ..			.dmark: db "SY"  
49d6 f1			.pastdmark: pop af  
49d7			endm  
# End of macro DMARK
49d7						CALLMONITOR 
49d7 cd 6f ee			call debug_vector  
49da				endm  
# End of macro CALLMONITOR
49da					endif 
49da			 
49da 21 e9 49				ld hl, sym_table 
49dd cd e7 0d				call addatohl 
49e0 cd 74 1f				call loadwordinhl 
49e3 cd 45 1c				call forth_push_numhl 
49e6			 
49e6			 
49e6				       NEXTW 
49e6 c3 f2 1f			jp macro_next 
49e9				endm 
# End of macro NEXTW
49e9			 
49e9			sym_table: 
49e9			 
49e9			; 0 
49e9 e9 49		dw sym_table 
49eb 72 ee		dw nmi_vector 
49ed 3c ea		dw cli_autodisplay 
49ef ee e9		dw cli_data_sp 
49f1 28 e8		dw cli_data_stack 
49f3 f0 e9		dw cli_loop_sp 
49f5 2a e9		dw cli_loop_stack 
49f7 28 ea		dw cli_var_array 
49f9 c5 eb		dw cursor_col 
49fb c3 eb		dw cursor_ptr 
49fd			; 10 
49fd c4 eb		dw cursor_row 
49ff 6b ee		dw debug_mark 
4a01 b1 ed		dw display_fb0 
4a03 10 ed		dw display_fb1 
4a05 ce eb		dw display_fb2 
4a07 6f ec		dw display_fb3 
4a09 cc eb		dw display_fb_active 
4a0b c0 e3		dw execscratch 
4a0d 5e ea		dw f_cursor_ptr 
4a0f 75 ee		dw hardware_word 
4a11			;20 
4a11 62 ee		dw input_at_cursor 
4a13 64 ee		dw input_at_pos 
4a15 60 ee		dw input_cur_flash 
4a17 5f ee		dw input_cur_onoff 
4a19 55 ee		dw input_cursor 
4a1b 65 ee		dw input_display_size 
4a1d 5a ee		dw input_len 
4a1f 69 ee		dw input_ptr 
4a21 66 ee		dw input_size 
4a23 67 ee		dw input_start 
4a25			; 30 
4a25 14 0e		dw input_str 
4a27 63 ee		dw input_under_cursor 
4a29 e8 e5		dw os_cli_cmd 
4a2b e4 e5		dw os_cur_ptr 
4a2d e6 e5		dw os_current_i 
4a2f bf e4		dw os_input 
4a31 e7 e6		dw os_last_cmd 
4a33 be e5		dw os_last_new_uword 
4a35 6f ee		dw debug_vector 
4a37 af e2		dw os_view_hl 
4a39			;40 
4a39 c6 e5		dw os_word_scratch 
4a3b c3 00		dw portbctl 
4a3d c1 00		dw portbdata 
4a3f 63 ea		dw spi_cartdev 
4a41 62 ea		dw spi_cartdev2 
4a43 64 ea		dw spi_clktime 
4a45 60 ea		dw spi_device 
4a47 5f ea		dw spi_device_id 
4a49 61 ea		dw spi_portbyte 
4a4b a7 eb		dw stackstore 
4a4d			; 50 
4a4d			if STORAGE_SE 
4a4d			dw storage_actl 
4a4d			dw storage_adata 
4a4d			else 
4a4d 00 00		dw 0 
4a4f 00 00		dw 0 
4a51			endif 
4a51 69 09		dw storage_append 
4a53			if STORAGE_SE 
4a53			dw storage_bctl 
4a53			else 
4a53 00 00		dw 0 
4a55			endif 
4a55 93 eb		dw store_bank_active 
4a57 67 ea		dw store_filecache 
4a59 75 ea		dw store_longread 
4a5b 6b ea		dw store_openaddr 
4a5d 6a ea		dw store_openext 
4a5f 69 ea		dw store_openmaxext 
4a61			; 60 
4a61 7a ea		dw store_page 
4a63 76 ea		dw store_readbuf 
4a65 6d ea		dw store_readcont 
4a67 78 ea		dw store_readptr 
4a69 6d ea		dw store_tmpext 
4a6b 6e ea		dw store_tmpid 
4a6d 65 ea		dw store_tmppageid 
4a6f ae 12		dw malloc 
4a71 78 13		dw free 
4a73 76 65		dw cin 
4a75			; 70 
4a75 6e 65		dw cin_wait 
4a77 45 1c		dw forth_push_numhl 
4a79 b3 1c		dw forth_push_str 
4a7b			 
4a7b			 
4a7b			.ENDCONST: 
4a7b			 
4a7b			; eof 
4a7b			 
4a7b			 
# End of file forth_words_const.asm
4a7b			 
4a7b			if STORAGE_SE 
4a7b			   	include "forth_words_storage.asm" 
4a7b			endif 
4a7b				include "forth_words_device.asm" 
4a7b			; Device related words 
4a7b			 
4a7b			; | ## Device Words 
4a7b			 
4a7b			;if SOUND_ENABLE 
4a7b			;.NOTE: 
4a7b			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a7b			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4a7b			;		if DEBUG_FORTH_WORDS_KEY 
4a7b			;			DMARK "NTE" 
4a7b			;			CALLMONITOR 
4a7b			;		endif 
4a7b			; 
4a7b			;	 
4a7b			; 
4a7b			;		NEXTW 
4a7b			;.AFTERSOUND: 
4a7b			;endif 
4a7b			 
4a7b			 
4a7b			USE_GPIO: equ 0 
4a7b			 
4a7b			if USE_GPIO 
4a7b			.GP1: 
4a7b				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a7b			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4a7b					NEXTW 
4a7b			.GP2: 
4a7b				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a7b			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4a7b			 
4a7b					NEXTW 
4a7b			 
4a7b			.GP3: 
4a7b				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a7b			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4a7b			 
4a7b					NEXTW 
4a7b			 
4a7b			.GP4: 
4a7b				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a7b			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4a7b			 
4a7b					NEXTW 
4a7b			.SIN: 
4a7b			 
4a7b			 
4a7b			endif 
4a7b			 
4a7b			 
4a7b				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a7b 33				db WORD_SYS_CORE+31             
4a7c b0 4a			dw .SOUT            
4a7e 03				db 2 + 1 
4a7f .. 00			db "IN",0              
4a82				endm 
# End of macro CWHEAD
4a82			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a82					if DEBUG_FORTH_WORDS_KEY 
4a82						DMARK "IN." 
4a82 f5				push af  
4a83 3a 97 4a			ld a, (.dmark)  
4a86 32 6b ee			ld (debug_mark),a  
4a89 3a 98 4a			ld a, (.dmark+1)  
4a8c 32 6c ee			ld (debug_mark+1),a  
4a8f 3a 99 4a			ld a, (.dmark+2)  
4a92 32 6d ee			ld (debug_mark+2),a  
4a95 18 03			jr .pastdmark  
4a97 ..			.dmark: db "IN."  
4a9a f1			.pastdmark: pop af  
4a9b			endm  
# End of macro DMARK
4a9b						CALLMONITOR 
4a9b cd 6f ee			call debug_vector  
4a9e				endm  
# End of macro CALLMONITOR
4a9e					endif 
4a9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a9e cd 3c 1e			call macro_dsp_valuehl 
4aa1				endm 
# End of macro FORTH_DSP_VALUEHL
4aa1			 
4aa1 e5					push hl 
4aa2			 
4aa2					; destroy value TOS 
4aa2			 
4aa2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aa2 cd f4 1e			call macro_forth_dsp_pop 
4aa5				endm 
# End of macro FORTH_DSP_POP
4aa5			 
4aa5					; one value on hl get other one back 
4aa5			 
4aa5 c1					pop bc 
4aa6			 
4aa6					; do the sub 
4aa6			;		ex de, hl 
4aa6			 
4aa6 ed 68				in l,(c) 
4aa8			 
4aa8					; save it 
4aa8			 
4aa8 26 00				ld h,0 
4aaa			 
4aaa					; TODO push value back onto stack for another op etc 
4aaa			 
4aaa cd 45 1c				call forth_push_numhl 
4aad					NEXTW 
4aad c3 f2 1f			jp macro_next 
4ab0				endm 
# End of macro NEXTW
4ab0			.SOUT: 
4ab0				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4ab0 34				db WORD_SYS_CORE+32             
4ab1 03 4b			dw .SPIO            
4ab3 04				db 3 + 1 
4ab4 .. 00			db "OUT",0              
4ab8				endm 
# End of macro CWHEAD
4ab8			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4ab8					if DEBUG_FORTH_WORDS_KEY 
4ab8						DMARK "OUT" 
4ab8 f5				push af  
4ab9 3a cd 4a			ld a, (.dmark)  
4abc 32 6b ee			ld (debug_mark),a  
4abf 3a ce 4a			ld a, (.dmark+1)  
4ac2 32 6c ee			ld (debug_mark+1),a  
4ac5 3a cf 4a			ld a, (.dmark+2)  
4ac8 32 6d ee			ld (debug_mark+2),a  
4acb 18 03			jr .pastdmark  
4acd ..			.dmark: db "OUT"  
4ad0 f1			.pastdmark: pop af  
4ad1			endm  
# End of macro DMARK
4ad1						CALLMONITOR 
4ad1 cd 6f ee			call debug_vector  
4ad4				endm  
# End of macro CALLMONITOR
4ad4					endif 
4ad4			 
4ad4					; get port 
4ad4			 
4ad4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ad4 cd 3c 1e			call macro_dsp_valuehl 
4ad7				endm 
# End of macro FORTH_DSP_VALUEHL
4ad7			 
4ad7 e5					push hl 
4ad8			 
4ad8					; destroy value TOS 
4ad8			 
4ad8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ad8 cd f4 1e			call macro_forth_dsp_pop 
4adb				endm 
# End of macro FORTH_DSP_POP
4adb			 
4adb					; get byte to send 
4adb			 
4adb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4adb cd 3c 1e			call macro_dsp_valuehl 
4ade				endm 
# End of macro FORTH_DSP_VALUEHL
4ade			 
4ade			;		push hl 
4ade			 
4ade					; destroy value TOS 
4ade			 
4ade					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ade cd f4 1e			call macro_forth_dsp_pop 
4ae1				endm 
# End of macro FORTH_DSP_POP
4ae1			 
4ae1					; one value on hl get other one back 
4ae1			 
4ae1			;		pop hl 
4ae1			 
4ae1 c1					pop bc 
4ae2			 
4ae2					if DEBUG_FORTH_WORDS 
4ae2						DMARK "OUT" 
4ae2 f5				push af  
4ae3 3a f7 4a			ld a, (.dmark)  
4ae6 32 6b ee			ld (debug_mark),a  
4ae9 3a f8 4a			ld a, (.dmark+1)  
4aec 32 6c ee			ld (debug_mark+1),a  
4aef 3a f9 4a			ld a, (.dmark+2)  
4af2 32 6d ee			ld (debug_mark+2),a  
4af5 18 03			jr .pastdmark  
4af7 ..			.dmark: db "OUT"  
4afa f1			.pastdmark: pop af  
4afb			endm  
# End of macro DMARK
4afb						CALLMONITOR 
4afb cd 6f ee			call debug_vector  
4afe				endm  
# End of macro CALLMONITOR
4afe					endif 
4afe			 
4afe ed 69				out (c), l 
4b00			 
4b00					NEXTW 
4b00 c3 f2 1f			jp macro_next 
4b03				endm 
# End of macro NEXTW
4b03			 
4b03			 
4b03			.SPIO: 
4b03			 
4b03			if STORAGE_SE 
4b03				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4b03			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4b03			 
4b03					call spi_ce_low 
4b03			    NEXTW 
4b03			 
4b03			.SPICEH: 
4b03				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4b03			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4b03			 
4b03					call spi_ce_high 
4b03			    NEXTW 
4b03			 
4b03			 
4b03			.SPIOb: 
4b03			 
4b03				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4b03			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4b03			 
4b03					if DEBUG_FORTH_WORDS_KEY 
4b03						DMARK "SPo" 
4b03						CALLMONITOR 
4b03					endif 
4b03					; get port 
4b03			 
4b03			 
4b03					; get byte to send 
4b03			 
4b03					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b03			 
4b03			;		push hl    ; u1  
4b03			 
4b03					; destroy value TOS 
4b03			 
4b03					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b03			 
4b03					; one value on hl get other one back 
4b03			 
4b03			;		pop hl   ; u2 - addr 
4b03			 
4b03					; TODO Send SPI byte 
4b03			 
4b03			;		push hl 
4b03			;		call spi_ce_low 
4b03			;		pop hl 
4b03					ld a, l 
4b03					call spi_send_byte 
4b03			;		call spi_ce_high 
4b03			 
4b03					NEXTW 
4b03			 
4b03			.SPII: 
4b03				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4b03			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4b03					if DEBUG_FORTH_WORDS_KEY 
4b03						DMARK "SPi" 
4b03						CALLMONITOR 
4b03					endif 
4b03			 
4b03					; TODO Get SPI byte 
4b03			 
4b03					call spi_read_byte 
4b03			 
4b03					if DEBUG_FORTH_WORDS 
4b03						DMARK "Si2" 
4b03						CALLMONITOR 
4b03					endif 
4b03					ld h, 0 
4b03					ld l, a 
4b03					if DEBUG_FORTH_WORDS 
4b03						DMARK "Si3" 
4b03						CALLMONITOR 
4b03					endif 
4b03					call forth_push_numhl 
4b03			 
4b03					NEXTW 
4b03			 
4b03			 
4b03			 
4b03			.SESEL: 
4b03				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4b03			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4b03					if DEBUG_FORTH_WORDS_KEY 
4b03						DMARK "BNK" 
4b03						CALLMONITOR 
4b03					endif 
4b03			 
4b03					ld a, 255 
4b03					ld (spi_cartdev), a 
4b03			 
4b03					; get bank 
4b03			 
4b03					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b03			 
4b03			;		push hl 
4b03			 
4b03					; destroy value TOS 
4b03			 
4b03					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b03			 
4b03					; one value on hl get other one back 
4b03			 
4b03			;		pop hl 
4b03			 
4b03			 
4b03					ld c, SPI_CE_HIGH 
4b03					ld b, '0'    ; human readable bank number 
4b03			 
4b03					ld a, l 
4b03			 
4b03					if DEBUG_FORTH_WORDS 
4b03						DMARK "BNK" 
4b03						CALLMONITOR 
4b03					endif 
4b03			 
4b03					; active low 
4b03			 
4b03					cp 0 
4b03					jr z, .bset 
4b03					cp 1 
4b03					jr nz, .b2 
4b03					res 0, c 
4b03					ld b, '1'    ; human readable bank number 
4b03			.b2:		cp 2 
4b03					jr nz, .b3 
4b03					res 1, c 
4b03					ld b, '2'    ; human readable bank number 
4b03			.b3:		cp 3 
4b03					jr nz, .b4 
4b03					res 2, c 
4b03					ld b, '3'    ; human readable bank number 
4b03			.b4:		cp 4 
4b03					jr nz, .b5 
4b03					res 3, c 
4b03					ld b, '4'    ; human readable bank number 
4b03			.b5:		cp 5 
4b03					jr nz, .bset 
4b03					res 4, c 
4b03					ld b, '5'    ; human readable bank number 
4b03			 
4b03			.bset: 
4b03					ld a, c 
4b03					ld (spi_device),a 
4b03					ld a, b 
4b03					ld (spi_device_id),a 
4b03					if DEBUG_FORTH_WORDS 
4b03						DMARK "BN2" 
4b03						CALLMONITOR 
4b03					endif 
4b03			 
4b03					; set default SPI clk pulse time as disabled for BANK use 
4b03			 
4b03					ld a, 0 
4b03					ld (spi_clktime), a 
4b03			 
4b03					NEXTW 
4b03			 
4b03			.CARTDEV: 
4b03				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4b03			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4b03					if DEBUG_FORTH_WORDS_KEY 
4b03						DMARK "CDV" 
4b03						CALLMONITOR 
4b03					endif 
4b03			 
4b03					; disable se storage bank selection 
4b03			 
4b03					ld a, SPI_CE_HIGH		; ce high 
4b03					ld (spi_device), a 
4b03			 
4b03					; get bank 
4b03			 
4b03					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b03			 
4b03			;		push hl 
4b03			 
4b03					; destroy value TOS 
4b03			 
4b03					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b03			 
4b03					; one value on hl get other one back 
4b03			 
4b03			;		pop hl 
4b03			 
4b03					; active low 
4b03			 
4b03					ld c, 255 
4b03			 
4b03					ld a, l 
4b03					if DEBUG_FORTH_WORDS 
4b03						DMARK "CDV" 
4b03						CALLMONITOR 
4b03					endif 
4b03					cp 0 
4b03					jr z, .cset 
4b03					cp 1 
4b03					jr nz, .c2 
4b03					res 0, c 
4b03			.c2:		cp 2 
4b03					jr nz, .c3 
4b03					res 1, c 
4b03			.c3:		cp 3 
4b03					jr nz, .c4 
4b03					res 2, c 
4b03			.c4:		cp 4 
4b03					jr nz, .c5 
4b03					res 3, c 
4b03			.c5:		cp 5 
4b03					jr nz, .c6 
4b03					res 4, c 
4b03			.c6:		cp 6 
4b03					jr nz, .c7 
4b03					res 5, c 
4b03			.c7:		cp 7 
4b03					jr nz, .c8 
4b03					res 6, c 
4b03			.c8:		cp 8 
4b03					jr nz, .cset 
4b03					res 7, c 
4b03			.cset:		ld a, c 
4b03					ld (spi_cartdev),a 
4b03			 
4b03					if DEBUG_FORTH_WORDS 
4b03						DMARK "CD2" 
4b03						CALLMONITOR 
4b03					endif 
4b03			 
4b03					; set default SPI clk pulse time as 10ms for CARTDEV use 
4b03			 
4b03					ld a, $0a 
4b03					ld (spi_clktime), a 
4b03					NEXTW 
4b03			endif 
4b03			 
4b03			.ENDDEVICE: 
4b03			; eof 
4b03			 
# End of file forth_words_device.asm
4b03			 
4b03			; var handler 
4b03			 
4b03			 
4b03			.VARS: 
4b03				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4b03 77				db WORD_SYS_CORE+99             
4b04 b4 4b			dw .V0            
4b06 04				db 3 + 1 
4b07 .. 00			db "VAR",0              
4b0b				endm 
# End of macro CWHEAD
4b0b			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4b0b			;| 
4b0b			;| The variable name should consist of a single letter. e.g. "a" 
4b0b			;! If a full string is passed then only the first char is looked at 
4b0b			;| Any other char could exceed bounds checks!  
4b0b			 
4b0b					if DEBUG_FORTH_WORDS_KEY 
4b0b						DMARK "VAR" 
4b0b f5				push af  
4b0c 3a 20 4b			ld a, (.dmark)  
4b0f 32 6b ee			ld (debug_mark),a  
4b12 3a 21 4b			ld a, (.dmark+1)  
4b15 32 6c ee			ld (debug_mark+1),a  
4b18 3a 22 4b			ld a, (.dmark+2)  
4b1b 32 6d ee			ld (debug_mark+2),a  
4b1e 18 03			jr .pastdmark  
4b20 ..			.dmark: db "VAR"  
4b23 f1			.pastdmark: pop af  
4b24			endm  
# End of macro DMARK
4b24						CALLMONITOR 
4b24 cd 6f ee			call debug_vector  
4b27				endm  
# End of macro CALLMONITOR
4b27					endif 
4b27			 
4b27					FORTH_DSP_VALUEHL 
4b27 cd 3c 1e			call macro_dsp_valuehl 
4b2a				endm 
# End of macro FORTH_DSP_VALUEHL
4b2a			 
4b2a 7e					ld a, (hl)    ; get first char on of the string 
4b2b			 
4b2b			 
4b2b					if DEBUG_FORTH_WORDS 
4b2b						DMARK "VR1" 
4b2b f5				push af  
4b2c 3a 40 4b			ld a, (.dmark)  
4b2f 32 6b ee			ld (debug_mark),a  
4b32 3a 41 4b			ld a, (.dmark+1)  
4b35 32 6c ee			ld (debug_mark+1),a  
4b38 3a 42 4b			ld a, (.dmark+2)  
4b3b 32 6d ee			ld (debug_mark+2),a  
4b3e 18 03			jr .pastdmark  
4b40 ..			.dmark: db "VR1"  
4b43 f1			.pastdmark: pop af  
4b44			endm  
# End of macro DMARK
4b44						CALLMONITOR 
4b44 cd 6f ee			call debug_vector  
4b47				endm  
# End of macro CALLMONITOR
4b47					endif 
4b47					 
4b47 f5					push af	 
4b48					FORTH_DSP_POP 
4b48 cd f4 1e			call macro_forth_dsp_pop 
4b4b				endm 
# End of macro FORTH_DSP_POP
4b4b f1					pop af 
4b4c			 
4b4c					; convert to upper 
4b4c			 
4b4c cd 54 11				call to_upper 
4b4f					if DEBUG_FORTH_WORDS 
4b4f						DMARK "Vaa" 
4b4f f5				push af  
4b50 3a 64 4b			ld a, (.dmark)  
4b53 32 6b ee			ld (debug_mark),a  
4b56 3a 65 4b			ld a, (.dmark+1)  
4b59 32 6c ee			ld (debug_mark+1),a  
4b5c 3a 66 4b			ld a, (.dmark+2)  
4b5f 32 6d ee			ld (debug_mark+2),a  
4b62 18 03			jr .pastdmark  
4b64 ..			.dmark: db "Vaa"  
4b67 f1			.pastdmark: pop af  
4b68			endm  
# End of macro DMARK
4b68						CALLMONITOR 
4b68 cd 6f ee			call debug_vector  
4b6b				endm  
# End of macro CALLMONITOR
4b6b					endif 
4b6b 06 41				ld b, 'A' 
4b6d 90					sub b			; set offset 
4b6e					if DEBUG_FORTH_WORDS 
4b6e						DMARK "Vbb" 
4b6e f5				push af  
4b6f 3a 83 4b			ld a, (.dmark)  
4b72 32 6b ee			ld (debug_mark),a  
4b75 3a 84 4b			ld a, (.dmark+1)  
4b78 32 6c ee			ld (debug_mark+1),a  
4b7b 3a 85 4b			ld a, (.dmark+2)  
4b7e 32 6d ee			ld (debug_mark+2),a  
4b81 18 03			jr .pastdmark  
4b83 ..			.dmark: db "Vbb"  
4b86 f1			.pastdmark: pop af  
4b87			endm  
# End of macro DMARK
4b87						CALLMONITOR 
4b87 cd 6f ee			call debug_vector  
4b8a				endm  
# End of macro CALLMONITOR
4b8a					endif 
4b8a cb 27				sla a  
4b8c				 
4b8c					 
4b8c					if DEBUG_FORTH_WORDS 
4b8c						DMARK "VR2" 
4b8c f5				push af  
4b8d 3a a1 4b			ld a, (.dmark)  
4b90 32 6b ee			ld (debug_mark),a  
4b93 3a a2 4b			ld a, (.dmark+1)  
4b96 32 6c ee			ld (debug_mark+1),a  
4b99 3a a3 4b			ld a, (.dmark+2)  
4b9c 32 6d ee			ld (debug_mark+2),a  
4b9f 18 03			jr .pastdmark  
4ba1 ..			.dmark: db "VR2"  
4ba4 f1			.pastdmark: pop af  
4ba5			endm  
# End of macro DMARK
4ba5						CALLMONITOR 
4ba5 cd 6f ee			call debug_vector  
4ba8				endm  
# End of macro CALLMONITOR
4ba8					endif 
4ba8			 
4ba8 21 f4 e9				ld hl, cli_var_array2 
4bab cd e7 0d				call addatohl 
4bae cd 45 1c				call forth_push_numhl 
4bb1			 
4bb1			 
4bb1				       NEXTW 
4bb1 c3 f2 1f			jp macro_next 
4bb4				endm 
# End of macro NEXTW
4bb4			.V0: 
4bb4				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4bb4 78				db WORD_SYS_CORE+100             
4bb5 cc 4b			dw .V0Q            
4bb7 04				db 3 + 1 
4bb8 .. 00			db "V0!",0              
4bbc				endm 
# End of macro CWHEAD
4bbc			;| V0! ( u1 -- )  Store value to v0  | DONE 
4bbc			 
4bbc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bbc cd 3c 1e			call macro_dsp_valuehl 
4bbf				endm 
# End of macro FORTH_DSP_VALUEHL
4bbf			 
4bbf 11 28 ea				ld de, cli_var_array 
4bc2			 
4bc2 eb					ex de, hl 
4bc3 73					ld (hl), e 
4bc4 23					inc hl 
4bc5 72					ld (hl), d 
4bc6			 
4bc6					; destroy value TOS 
4bc6			 
4bc6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc6 cd f4 1e			call macro_forth_dsp_pop 
4bc9				endm 
# End of macro FORTH_DSP_POP
4bc9			 
4bc9				       NEXTW 
4bc9 c3 f2 1f			jp macro_next 
4bcc				endm 
# End of macro NEXTW
4bcc			.V0Q: 
4bcc				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4bcc 79				db WORD_SYS_CORE+101             
4bcd dd 4b			dw .V1S            
4bcf 04				db 3 + 1 
4bd0 .. 00			db "V0@",0              
4bd4				endm 
# End of macro CWHEAD
4bd4			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4bd4 2a 28 ea				ld hl, (cli_var_array) 
4bd7 cd 45 1c				call forth_push_numhl 
4bda			 
4bda				       NEXTW 
4bda c3 f2 1f			jp macro_next 
4bdd				endm 
# End of macro NEXTW
4bdd			.V1S: 
4bdd				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4bdd 7a				db WORD_SYS_CORE+102             
4bde f5 4b			dw .V1Q            
4be0 04				db 3 + 1 
4be1 .. 00			db "V1!",0              
4be5				endm 
# End of macro CWHEAD
4be5			;| V1! ( u1 -- )  Store value to v1 | DONE 
4be5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4be5 cd 3c 1e			call macro_dsp_valuehl 
4be8				endm 
# End of macro FORTH_DSP_VALUEHL
4be8			 
4be8 11 2a ea				ld de, cli_var_array+2 
4beb				 
4beb eb					ex de, hl 
4bec 73					ld (hl), e 
4bed 23					inc hl 
4bee 72					ld (hl), d 
4bef			 
4bef					; destroy value TOS 
4bef			 
4bef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bef cd f4 1e			call macro_forth_dsp_pop 
4bf2				endm 
# End of macro FORTH_DSP_POP
4bf2				       NEXTW 
4bf2 c3 f2 1f			jp macro_next 
4bf5				endm 
# End of macro NEXTW
4bf5			.V1Q: 
4bf5				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4bf5 7b				db WORD_SYS_CORE+103             
4bf6 06 4c			dw .V2S            
4bf8 04				db 3 + 1 
4bf9 .. 00			db "V1@",0              
4bfd				endm 
# End of macro CWHEAD
4bfd			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4bfd 2a 2a ea				ld hl, (cli_var_array+2) 
4c00 cd 45 1c				call forth_push_numhl 
4c03				       NEXTW 
4c03 c3 f2 1f			jp macro_next 
4c06				endm 
# End of macro NEXTW
4c06			.V2S: 
4c06				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4c06 7c				db WORD_SYS_CORE+104             
4c07 1e 4c			dw .V2Q            
4c09 04				db 3 + 1 
4c0a .. 00			db "V2!",0              
4c0e				endm 
# End of macro CWHEAD
4c0e			;| V2! ( u1 -- )  Store value to v2 | DONE 
4c0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c0e cd 3c 1e			call macro_dsp_valuehl 
4c11				endm 
# End of macro FORTH_DSP_VALUEHL
4c11			 
4c11 11 2c ea				ld de, cli_var_array+4 
4c14				 
4c14 eb					ex de, hl 
4c15 73					ld (hl), e 
4c16 23					inc hl 
4c17 72					ld (hl), d 
4c18			 
4c18					; destroy value TOS 
4c18			 
4c18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c18 cd f4 1e			call macro_forth_dsp_pop 
4c1b				endm 
# End of macro FORTH_DSP_POP
4c1b				       NEXTW 
4c1b c3 f2 1f			jp macro_next 
4c1e				endm 
# End of macro NEXTW
4c1e			.V2Q: 
4c1e				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4c1e 7d				db WORD_SYS_CORE+105             
4c1f 2f 4c			dw .V3S            
4c21 04				db 3 + 1 
4c22 .. 00			db "V2@",0              
4c26				endm 
# End of macro CWHEAD
4c26			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4c26 2a 2c ea				ld hl, (cli_var_array+4) 
4c29 cd 45 1c				call forth_push_numhl 
4c2c				       NEXTW 
4c2c c3 f2 1f			jp macro_next 
4c2f				endm 
# End of macro NEXTW
4c2f			.V3S: 
4c2f				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4c2f 7c				db WORD_SYS_CORE+104             
4c30 47 4c			dw .V3Q            
4c32 04				db 3 + 1 
4c33 .. 00			db "V3!",0              
4c37				endm 
# End of macro CWHEAD
4c37			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c37					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c37 cd 3c 1e			call macro_dsp_valuehl 
4c3a				endm 
# End of macro FORTH_DSP_VALUEHL
4c3a			 
4c3a 11 2e ea				ld de, cli_var_array+6 
4c3d				 
4c3d eb					ex de, hl 
4c3e 73					ld (hl), e 
4c3f 23					inc hl 
4c40 72					ld (hl), d 
4c41			 
4c41					; destroy value TOS 
4c41			 
4c41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c41 cd f4 1e			call macro_forth_dsp_pop 
4c44				endm 
# End of macro FORTH_DSP_POP
4c44				       NEXTW 
4c44 c3 f2 1f			jp macro_next 
4c47				endm 
# End of macro NEXTW
4c47			.V3Q: 
4c47				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c47 7d				db WORD_SYS_CORE+105             
4c48 58 4c			dw .END            
4c4a 04				db 3 + 1 
4c4b .. 00			db "V3@",0              
4c4f				endm 
# End of macro CWHEAD
4c4f			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c4f 2a 2e ea				ld hl, (cli_var_array+6) 
4c52 cd 45 1c				call forth_push_numhl 
4c55				       NEXTW 
4c55 c3 f2 1f			jp macro_next 
4c58				endm 
# End of macro NEXTW
4c58			 
4c58			 
4c58			 
4c58			 
4c58			 
4c58			; end of dict marker 
4c58			 
4c58 00			.END:    db WORD_SYS_END 
4c59 00 00			dw 0 
4c5b 00				db 0 
4c5c			 
4c5c			; use to jp here for user dict words to save on macro expansion  
4c5c			 
4c5c			user_dict_next: 
4c5c				NEXTW 
4c5c c3 f2 1f			jp macro_next 
4c5f				endm 
# End of macro NEXTW
4c5f			 
4c5f			 
4c5f			user_exec: 
4c5f				;    ld hl, <word code> 
4c5f				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c5f				;    call forthexec 
4c5f				;    jp user_dict_next   (NEXT) 
4c5f			        ;    <word code bytes> 
4c5f eb				ex de, hl 
4c60 2a c2 e5			ld hl,(os_tok_ptr) 
4c63				 
4c63				FORTH_RSP_NEXT 
4c63 cd ec 1b			call macro_forth_rsp_next 
4c66				endm 
# End of macro FORTH_RSP_NEXT
4c66			 
4c66			if DEBUG_FORTH_UWORD 
4c66						DMARK "UEX" 
4c66 f5				push af  
4c67 3a 7b 4c			ld a, (.dmark)  
4c6a 32 6b ee			ld (debug_mark),a  
4c6d 3a 7c 4c			ld a, (.dmark+1)  
4c70 32 6c ee			ld (debug_mark+1),a  
4c73 3a 7d 4c			ld a, (.dmark+2)  
4c76 32 6d ee			ld (debug_mark+2),a  
4c79 18 03			jr .pastdmark  
4c7b ..			.dmark: db "UEX"  
4c7e f1			.pastdmark: pop af  
4c7f			endm  
# End of macro DMARK
4c7f				CALLMONITOR 
4c7f cd 6f ee			call debug_vector  
4c82				endm  
# End of macro CALLMONITOR
4c82			endif 
4c82			 
4c82			 
4c82			 
4c82 eb				ex de, hl 
4c83 22 c2 e5			ld (os_tok_ptr), hl 
4c86				 
4c86				; Don't use next - Skips the first word in uword. 
4c86			 
4c86 c3 83 20			jp exec1 
4c89			;	NEXT 
4c89			 
4c89			 
4c89			; eof 
# End of file forth_wordsv4.asm
4c89			endif 
4c89			;;;;;;;;;;;;;; Debug code 
4c89			 
4c89			 
4c89			;if DEBUG_FORTH_PARSE 
4c89 .. 00		.nowordfound: db "No match",0 
4c92 .. 00		.compword:	db "Comparing word ",0 
4ca2 .. 00		.nextwordat:	db "Next word at",0 
4caf .. 00		.charmatch:	db "Char match",0 
4cba			;endif 
4cba			if DEBUG_FORTH_JP 
4cba			.foundword:	db "Word match. Exec..",0 
4cba			endif 
4cba			;if DEBUG_FORTH_PUSH 
4cba .. 00		.enddict:	db "Dict end. Push.",0 
4cca .. 00		.push_str:	db "Pushing string",0 
4cd9 .. 00		.push_num:	db "Pushing number",0 
4ce8 .. 00		.data_sp:	db "SP:",0 
4cec .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4cfe .. 00		.wordinde:	db "Word in DE (3/0):",0 
4d10 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4d22			;endif 
4d22			;if DEBUG_FORTH_MALLOC 
4d22 .. 00		.push_malloc:	db "Malloc address",0 
4d31			;endif 
4d31			 
4d31			 
4d31			 
4d31			; display malloc address and current data stack pointer  
4d31			 
4d31			malloc_error: 
4d31 d5				push de 
4d32 f5				push af 
4d33 e5				push hl 
4d34 cd ba 0b			call clear_display 
4d37 11 57 4d			ld de, .mallocerr 
4d3a 3e 00			ld a,0 
4d3c			;	ld de,os_word_scratch 
4d3c cd cd 0b			call str_at_display 
4d3f 3e 11			ld a, display_row_1+17 
4d41 11 6b ee			ld de, debug_mark 
4d44 cd cd 0b			call str_at_display 
4d47 cd dd 0b			call update_display 
4d4a				;call break_point_state 
4d4a cd 6e 65			call cin_wait 
4d4d			 
4d4d			;	ld a, ' ' 
4d4d			;	ld (os_view_disable), a 
4d4d cd dd 15			call bp_on 
4d50 e1				pop hl 
4d51 f1				pop af 
4d52 d1				pop de	 
4d53				CALLMONITOR 
4d53 cd 6f ee			call debug_vector  
4d56				endm  
# End of macro CALLMONITOR
4d56 c9				ret 
4d57			 
4d57 .. 00		.mallocerr: 	db "Malloc Error",0 
4d64			;if DEBUG_FORTH_PUSH 
4d64			display_data_sp: 
4d64 f5				push af 
4d65			 
4d65				; see if disabled 
4d65			 
4d65			 
4d65 3a 6f ee			ld a, (debug_vector) 
4d68 fe c9			cp $C9  ; RET 
4d6a				;ld a, (os_view_disable) 
4d6a				;cp '*' 
4d6a 28 67			jr z, .skipdsp 
4d6c			 
4d6c e5				push hl 
4d6d e5				push hl 
4d6e e5			push hl 
4d6f cd ba 0b			call clear_display 
4d72 e1			pop hl 
4d73 7c				ld a,h 
4d74 21 c6 e5			ld hl, os_word_scratch 
4d77 cd e8 10			call hexout 
4d7a e1				pop hl 
4d7b 7d				ld a,l 
4d7c 21 c8 e5			ld hl, os_word_scratch+2 
4d7f cd e8 10			call hexout 
4d82 21 ca e5			ld hl, os_word_scratch+4 
4d85 3e 00			ld a,0 
4d87 77				ld (hl),a 
4d88 11 c6 e5			ld de,os_word_scratch 
4d8b 3e 28				ld a, display_row_2 
4d8d cd cd 0b				call str_at_display 
4d90 11 ec 4c			ld de, .wordinhl 
4d93 3e 00			ld a, display_row_1 
4d95			 
4d95 cd cd 0b				call str_at_display 
4d98 11 6b ee			ld de, debug_mark 
4d9b 3e 11			ld a, display_row_1+17 
4d9d			 
4d9d cd cd 0b				call str_at_display 
4da0			 
4da0				; display current data stack pointer 
4da0 11 e8 4c			ld de,.data_sp 
4da3 3e 30				ld a, display_row_2 + 8 
4da5 cd cd 0b				call str_at_display 
4da8			 
4da8 2a ee e9			ld hl,(cli_data_sp) 
4dab e5				push hl 
4dac 7c				ld a,h 
4dad 21 c6 e5			ld hl, os_word_scratch 
4db0 cd e8 10			call hexout 
4db3 e1				pop hl 
4db4 7d				ld a,l 
4db5 21 c8 e5			ld hl, os_word_scratch+2 
4db8 cd e8 10			call hexout 
4dbb 21 ca e5			ld hl, os_word_scratch+4 
4dbe 3e 00			ld a,0 
4dc0 77				ld (hl),a 
4dc1 11 c6 e5			ld de,os_word_scratch 
4dc4 3e 33				ld a, display_row_2 + 11 
4dc6 cd cd 0b				call str_at_display 
4dc9			 
4dc9			 
4dc9 cd dd 0b			call update_display 
4dcc cd f2 0a			call delay1s 
4dcf cd f2 0a			call delay1s 
4dd2 e1				pop hl 
4dd3			.skipdsp: 
4dd3 f1				pop af 
4dd4 c9				ret 
4dd5			 
4dd5			display_data_malloc: 
4dd5			 
4dd5 f5				push af 
4dd6 e5				push hl 
4dd7 e5				push hl 
4dd8 e5			push hl 
4dd9 cd ba 0b			call clear_display 
4ddc e1			pop hl 
4ddd 7c				ld a,h 
4dde 21 c6 e5			ld hl, os_word_scratch 
4de1 cd e8 10			call hexout 
4de4 e1				pop hl 
4de5 7d				ld a,l 
4de6 21 c8 e5			ld hl, os_word_scratch+2 
4de9 cd e8 10			call hexout 
4dec 21 ca e5			ld hl, os_word_scratch+4 
4def 3e 00			ld a,0 
4df1 77				ld (hl),a 
4df2 11 c6 e5			ld de,os_word_scratch 
4df5 3e 28				ld a, display_row_2 
4df7 cd cd 0b				call str_at_display 
4dfa 11 22 4d			ld de, .push_malloc 
4dfd 3e 00			ld a, display_row_1 
4dff			 
4dff cd cd 0b				call str_at_display 
4e02			 
4e02				; display current data stack pointer 
4e02 11 e8 4c			ld de,.data_sp 
4e05 3e 30				ld a, display_row_2 + 8 
4e07 cd cd 0b				call str_at_display 
4e0a			 
4e0a 2a ee e9			ld hl,(cli_data_sp) 
4e0d e5				push hl 
4e0e 7c				ld a,h 
4e0f 21 c6 e5			ld hl, os_word_scratch 
4e12 cd e8 10			call hexout 
4e15 e1				pop hl 
4e16 7d				ld a,l 
4e17 21 c8 e5			ld hl, os_word_scratch+2 
4e1a cd e8 10			call hexout 
4e1d 21 ca e5			ld hl, os_word_scratch+4 
4e20 3e 00			ld a,0 
4e22 77				ld (hl),a 
4e23 11 c6 e5			ld de,os_word_scratch 
4e26 3e 33				ld a, display_row_2 + 11 
4e28 cd cd 0b				call str_at_display 
4e2b			 
4e2b cd dd 0b			call update_display 
4e2e cd f2 0a			call delay1s 
4e31 cd f2 0a			call delay1s 
4e34 e1				pop hl 
4e35 f1				pop af 
4e36 c9				ret 
4e37			;endif 
4e37			 
4e37			include "forth_autostart.asm" 
4e37			; list of commands to perform at system start up 
4e37			 
4e37			startcmds: 
4e37			;	dw test11 
4e37			;	dw test12 
4e37			;	dw test13 
4e37			;	dw test14 
4e37			;	dw test15 
4e37			;	dw test16 
4e37			;	dw test17 
4e37			;	dw ifthtest1 
4e37			;	dw ifthtest2 
4e37			;	dw ifthtest3 
4e37			;	dw mmtest1 
4e37			;	dw mmtest2 
4e37			;	dw mmtest3 
4e37			;	dw mmtest4 
4e37			;	dw mmtest5 
4e37			;	dw mmtest6 
4e37			;	dw iftest1 
4e37			;	dw iftest2 
4e37			;	dw iftest3 
4e37			;	dw looptest1 
4e37			;	dw looptest2 
4e37			;	dw test1 
4e37			;	dw test2 
4e37			;	dw test3 
4e37			;	dw test4 
4e37			;	dw game2r 
4e37			;	dw game2b1 
4e37			;	dw game2b2 
4e37			 
4e37				; start up words that are actually useful 
4e37			 
4e37			;    dw spi1 
4e37			;    dw spi2 
4e37			;    dw spi3 
4e37			;    dw spi4 
4e37			;    dw spi5 
4e37			;    dw spi6 
4e37			;    dw spi7 
4e37			; 
4e37			;    dw spi8 
4e37			;    dw spi9 
4e37			;    dw spi10 
4e37			 
4e37			; file editor 
4e37			;	dw edit1 
4e37			;	dw edit2 
4e37			;	dw edit3 
4e37			 
4e37			;	dw longread 
4e37 37 52			dw clrstack 
4e39 6b 52			dw type 
4e3b			;	dw stest 
4e3b 90 52			dw strncpy 
4e3d			;	dw list 
4e3d f1 52			dw start1 
4e3f 01 53			dw start2 
4e41			;	dw start3 
4e41			;	dw start3b 
4e41			;	dw start3c 
4e41			 
4e41				; (unit) testing words 
4e41			 
4e41			;	dw mtesta 
4e41			;	dw mtestb 
4e41			;	dw mtestc 
4e41			;	dw mtestd 
4e41			;	dw mteste 
4e41			 
4e41				; demo/game words 
4e41			 
4e41			;        dw game3w 
4e41			;        dw game3p 
4e41			;        dw game3sc 
4e41			;        dw game3vsi 
4e41			;        dw game3vs 
4e41				 
4e41 5a 5d			dw game2b 
4e43 c8 5d			dw game2bf 
4e45 12 5e			dw game2mba 
4e47 a8 5e			dw game2mbas 
4e49 ea 5e			dw game2mb 
4e4b			 
4e4b 1b 5a			dw game1 
4e4d 2c 5a			dw game1a 
4e4f 8e 5a			dw game1b 
4e51 c3 5a			dw game1c 
4e53 f9 5a			dw game1d 
4e55 2a 5b			dw game1s 
4e57 3e 5b			dw game1t 
4e59 53 5b			dw game1f 
4e5b 87 5b			dw game1z 
4e5d cb 5b			dw game1zz 
4e5f			 
4e5f 35 58			dw test5 
4e61 6d 58			dw test6 
4e63 a5 58			dw test7 
4e65 b9 58			dw test8 
4e67 e5 58			dw test9 
4e69 fb 58			dw test10 
4e6b				 
4e6b a2 5c		        dw ssv5 
4e6d 86 5c		        dw ssv4 
4e6f 6a 5c		        dw ssv3 
4e71 34 5c		        dw ssv2 
4e73 bb 5c		        dw ssv1 
4e75 03 5d		        dw ssv1cpm 
4e77			;	dw keyup 
4e77			;	dw keydown 
4e77			;	dw keyleft 
4e77			;	dw keyright 
4e77			;	dw 	keyf1 
4e77			;	dw keyf2 
4e77			;	dw keyf3 
4e77			;	dw keyf4 
4e77			;	dw keyf5 
4e77			;	dw keyf6 
4e77			;	dw keyf7 
4e77			;	dw keyf8 
4e77			;	dw keyf9 
4e77			;	dw keyf10 
4e77			;	dw keyf11 
4e77			;	dw keyf12 
4e77			;	dw keytab 
4e77			;	dw keycr 
4e77			;	dw keyhome 
4e77			;	dw keyend 
4e77			;	dw keybs 
4e77 00 00			db 0, 0	 
4e79			 
4e79			 
4e79			; File Editor 
4e79			 
4e79			; ( id - ) use 'e' to edit the displayed line 
4e79 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4e9a .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4ecf			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4ecf .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4f07			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4f07			 
4f07			; SPI Net support words 
4f07			 
4f07			; v0! = node to send to 
4f07			; ( str count - ) 
4f07 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f60			 
4f60			; spiputchr ( char node - ) 
4f60 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4f96			 
4f96			; spigetchr ( - n ) 
4f96 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
4fc1			 
4fc1			; getnode ( - n ) 
4fc1 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4fee			 
4fee			; ( str node - )  
4fee .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5054			; store string ( str i - ) 
5054			 
5054			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5054 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
50a9			 
50a9			; get string ( addr i -  )    TO FIX 
50a9			 
50a9 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5101			 
5101			 
5101			; NETCHAT (TODO) 
5101			; Program to allow two nodes to chat with eachother 
5101			; 
5101			; v0 - target node 
5101			;  
5101			; accept input at 0,0 
5101			; if input is string send spitype to target node 
5101			; starting at row 2,0 , while spigetchr is not zero ->  
5101			; 
5101			; 
5101			; TODO add paging of get request 
5101			 
5101			; ( node - ) 
5101 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5120 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5178 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
51f0			 
51f0			 
51f0			; Long read of currently open file 
51f0 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5237			 
5237			; clear stack  
5237			 
5237 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
526b			 
526b			; type ( addr count - ) 
526b .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
5290			 
5290			; some direct memory words 
5290			; strncpy ( len t f -- t ) 
5290			 
5290 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
52f1			 
52f1 .. 00		start1:     	db ": bpon $00 bp ;",0 
5301 .. 00		start2:     	db ": bpoff $01 bp ;",0 
5312 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
538d .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
53ed			 
53ed			 
53ed			; a handy word to list items on the stack 
53ed			 
53ed .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5457			 
5457			 
5457			; test stack  
5457			; rnd8 stest 
5457			 
5457 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
54ce			 
54ce			; random malloc and free cycles 
54ce			 
54ce .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5583			 
5583			; fixed malloc and free cycles 
5583			 
5583 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5626			 
5626			; fixed double string push and drop cycle  
5626			 
5626 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
56db			 
56db			; consistent fixed string push and drop cycle  
56db			 
56db .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
577f			 
577f .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5835			 
5835			;test1:		db ": aa 1 2 3 ;", 0 
5835			;test2:     	db "111 aa 888 999",0 
5835			;test3:     	db ": bb 77 ;",0 
5835			;test4:     	db "$02 $01 do i . loop bb",0 
5835			 
5835 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
586d .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
58a5 .. 00		test7:     	db ": box hline vline ;",0 
58b9 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
58e5 .. 00		test9:     	db ": sw $01 adsp world ;",0 
58fb .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5920 .. 00		test11:     	db "hello create .",0 
592f .. 00		test12:     	db "hello2 create .",0 
593f			 
593f			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
593f			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
593f			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
593f			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
593f			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
593f			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
593f			 
593f			;iftest1:     	db "$0001 IF cls .",0 
593f			;iftest2:     	db "$0000 IF cls .",0 
593f			;iftest3:     	db "$0002 $0003 - IF cls .",0 
593f			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
593f			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
593f			 
593f			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
593f			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
593f			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
593f			 
593f			 
593f .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5963 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5993 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
59b8 .. 00		sound4: db ": cha $00 ; ",0 
59c5 .. 00		sound5: db ": chb $20 ; ",0 
59d2 .. 00		sound6: db ": chc $40 ; ",0 
59df .. 00		sound7: db ": chd $60 ; ",0 
59ec .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5a04 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5a1b			 
5a1b			 
5a1b			 
5a1b			 
5a1b			; a small guess the number game 
5a1b			 
5a1b .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a2c .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a8e			 
5a8e .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ac3 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5af9 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b2a .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b3e .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b53 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b87 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5bcb			 
5bcb			; Using 'ga' save a high score across multiple runs using external storage 
5bcb			 
5bcb .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c34			 
5c34			 
5c34			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c34			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c34			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c34			 
5c34			; simple screen saver to test code memory reuse to destruction 
5c34			 
5c34 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c6a .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c86 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5ca2 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5cbb .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d03 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d5a			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d5a			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d5a			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d5a			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d5a			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d5a			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d5a			 
5d5a			 
5d5a			 
5d5a			; minesweeper/battleship finding game 
5d5a			; draws a game board of random ship/mine positions 
5d5a			; user enters coords to see if it hits on 
5d5a			; game ends when all are hit 
5d5a			; when hit or miss says how many may be in the area 
5d5a			 
5d5a			; setup the game board and then hide it 
5d5a .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5dc8 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e12			; prompt for where to target 
5e12 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5ea8 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ecd			; TODO see if the entered coords hits or misses pushes char hit of miss 
5ecd .. 00		game2mbht:      db ": mbckht nop ;",0 
5edc .. 00		game2mbms:      db ": mbcms nop ;",0 
5eea			; TODO how many might be near by 
5eea .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f67			 
5f67			; Game 3 
5f67			 
5f67			; Vert scroller ski game - avoid the trees! 
5f67			 
5f67			; v0 score (ie turns) 
5f67			; v1 player pos 
5f67			; v2 left wall 
5f67			; v3 right wall 
5f67			 
5f67			; Draw side walls randomly 
5f67			 
5f67 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f95			 
5f95			; Draw player 
5f95 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fb3			 
5fb3			; TODO Get Key 
5fb3			 
5fb3			; TODO Move left right 
5fb3			 
5fb3			; scroll and move walls a bit 
5fb3			 
5fb3 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5fe4			 
5fe4			; main game loop 
5fe4			 
5fe4 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6010 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
604f			 
604f			; key board defs 
604f			 
604f .. 00		keyup:       db ": keyup $05 ;",0 
605d .. 00		keydown:       db ": keydown $0a ;",0 
606d .. 00		keyleft:       db ": keyleft $0b ;",0 
607d .. 00		keyright:       db ": keyright $0c ;",0 
608e .. 00		keyf1:       db ": keyf1 $10 ;",0 
609c .. 00		keyf2:       db ": keyf2 $11 ;",0 
60aa .. 00		keyf3:       db ": keyf3 $12 ;",0 
60b8 .. 00		keyf4:       db ": keyf4 $13 ;",0 
60c6 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60d4 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60e2 .. 00		keyf7:       db ": keyf7 $16 ;",0 
60f0 .. 00		keyf8:       db ": keyf8 $17 ;",0 
60fe .. 00		keyf9:       db ": keyf9 $18 ;",0 
610c .. 00		keyf10:       db ": keyf10 $19 ;",0 
611b .. 00		keyf11:       db ": keyf11 $1a ;",0 
612a .. 00		keyf12:       db ": keyf12 $1b ;",0 
6139			 
6139 .. 00		keytab:       db ": keytab $09 ;",0 
6148 .. 00		keycr:       db ": keycr $0d ;",0 
6156 .. 00		keyhome:       db ": keyhome $0e ;",0 
6166 .. 00		keyend:       db ": keyend $0f ;",0 
6175 .. 00		keybs:       db ": keybs $08 ;",0 
6183			 
6183			   
6183			 
6183			 
6183			 
6183			; eof 
# End of file forth_autostart.asm
6183			 
6183			 
6183			 
6183			; stack over and underflow checks 
6183			 
6183			; init the words to detect the under/overflow 
6183			 
6183			chk_stk_init: 
6183				; a vague random number to check so we dont get any "lucky" hits 
6183 3e 2d			ld a, 45 
6185 6f				ld l, a 
6186 00				nop 
6187 3e 17			ld a, 23 
6189 67				ld h, a 
618a			 
618a 22 a9 e2			ld (chk_word), hl     ; the word we need to check against 
618d			 
618d			;	ld (chk_stund), hl	; stack points.... 
618d 22 00 ef			ld (chk_stovr), hl 
6190 22 ec e9			ld (chk_ret_und), hl 
6193 22 aa e9			ld (chk_ret_ovr), hl 
6196 22 28 e9			ld (chk_loop_ovr), hl 
6199 22 26 e8			ld (chk_data_ovr), hl 
619c c9				ret 
619d				 
619d			check_stacks: 
619d				; check all stack words 
619d			 
619d e5				push hl 
619e d5				push de 
619f			 
619f			;	ld de,(chk_word) 
619f			;	ld hl, (chk_stund)	; stack points.... 
619f			;	if DEBUG_STK_FAULT 
619f			;		DMARK "FAa" 
619f			;		CALLMONITOR 
619f			;	endif 
619f			;	call cmp16 
619f			;	jp z, .chk_faulta 
619f			; 
619f			;	ld de, sfaultsu 
619f			;	jp .chk_fault 
619f			 
619f 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
61a2 ed 5b a9 e2		ld de,(chk_word) 
61a6				if DEBUG_STK_FAULT 
61a6					DMARK "FAb" 
61a6					CALLMONITOR 
61a6				endif 
61a6 cd 05 0e			call cmp16 
61a9 28 06			jr z, .chk_fault1 
61ab 11 4c 62			ld de, sfaultso 
61ae c3 00 62			jp .chk_fault 
61b1			.chk_fault1:  
61b1 2a ec e9			ld hl, (chk_ret_und) 
61b4 ed 5b a9 e2		ld de,(chk_word) 
61b8				if DEBUG_STK_FAULT 
61b8					DMARK "FAU" 
61b8					CALLMONITOR 
61b8				endif 
61b8 cd 05 0e			call cmp16 
61bb ca c4 61			jp z, .chk_fault2 
61be 11 5c 62			ld de, sfaultru 
61c1 c3 00 62			jp .chk_fault 
61c4			.chk_fault2:  
61c4 2a aa e9			ld hl, (chk_ret_ovr) 
61c7 ed 5b a9 e2		ld de,(chk_word) 
61cb				if DEBUG_STK_FAULT 
61cb					DMARK "FA1" 
61cb					CALLMONITOR 
61cb				endif 
61cb cd 05 0e			call cmp16 
61ce ca d7 61			jp z, .chk_fault3 
61d1 11 6a 62			ld de, sfaultro 
61d4 c3 00 62			jp .chk_fault 
61d7			.chk_fault3:  
61d7 2a 28 e9			ld hl, (chk_loop_ovr) 
61da ed 5b a9 e2		ld de,(chk_word) 
61de				if DEBUG_STK_FAULT 
61de					DMARK "FA2" 
61de					CALLMONITOR 
61de				endif 
61de cd 05 0e			call cmp16 
61e1 ca ea 61			jp z, .chk_fault4 
61e4 11 84 62			ld de, sfaultlo 
61e7 c3 00 62			jp .chk_fault 
61ea			.chk_fault4:  
61ea 2a 26 e8			ld hl, (chk_data_ovr) 
61ed ed 5b a9 e2		ld de,(chk_word) 
61f1				if DEBUG_STK_FAULT 
61f1					DMARK "FA3" 
61f1					CALLMONITOR 
61f1				endif 
61f1 cd 05 0e			call cmp16 
61f4 ca fd 61			jp z, .chk_fault5 
61f7 11 9e 62			ld de, sfaultdo 
61fa c3 00 62			jp .chk_fault 
61fd			 
61fd			 
61fd			.chk_fault5:  
61fd d1				pop de 
61fe e1				pop hl 
61ff			 
61ff c9				ret 
6200			 
6200 cd ba 0b		.chk_fault: 	call clear_display 
6203 3e 28				ld a, display_row_2 
6205 cd cd 0b				call str_at_display 
6208 11 2e 62				   ld de, .stackfault 
620b 3e 00				ld a, display_row_1 
620d cd cd 0b				call str_at_display 
6210 11 6b ee				    ld de, debug_mark 
6213 3e 11				ld a, display_row_1+17 
6215 cd cd 0b				call str_at_display 
6218 cd dd 0b				call update_display 
621b			 
621b				; prompt before entering montior for investigating issue 
621b			 
621b 3e 78			ld a, display_row_4 
621d 11 37 19			ld de, endprog 
6220			 
6220 cd dd 0b			call update_display		 
6223			 
6223 cd bd 1b			call next_page_prompt 
6226			 
6226 d1				pop de 
6227 e1				pop hl 
6228 cd 8b 19				call monitor 
622b c3 96 18				jp warmstart 
622e					;jp 0 
622e					;halt 
622e			 
622e			 
622e			 
622e .. 00		.stackfault: 	db "Stack fault:",0 
623b			 
623b .. 00		sfaultsu: 	db	"Stack under flow",0 
624c .. 00		sfaultso: 	db	"Stack over flow",0 
625c .. 00		sfaultru:	db "RTS underflow",0 
626a .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6284 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
629e .. 00		sfaultdo:	db "DTS overflow", 0 
62ab			 
62ab			 
62ab			fault_dsp_under: 
62ab 11 bd 62			ld de, .dsp_under 
62ae c3 6d 63			jp .show_fault 
62b1			 
62b1			fault_rsp_under: 
62b1 11 cb 62			ld de, .rsp_under 
62b4 c3 6d 63			jp .show_fault 
62b7			fault_loop_under: 
62b7 11 d9 62			ld de, .loop_under 
62ba c3 6d 63			jp .show_fault 
62bd			 
62bd .. 00		.dsp_under: db "DSP Underflow",0 
62cb .. 00		.rsp_under: db "RSP Underflow",0 
62d9 .. 00		.loop_under: db "LOOP Underflow",0 
62e8			 
62e8			 
62e8 d5			type_faultn: 	push de 
62e9 e5					push hl 
62ea cd ba 0b				call clear_display 
62ed 11 14 63				   ld de, .typefaultn 
62f0 3e 00				ld a, display_row_1 
62f2 cd cd 0b				call str_at_display 
62f5 11 6b ee				    ld de, debug_mark 
62f8 3e 11				ld a, display_row_1+17 
62fa cd cd 0b				call str_at_display 
62fd cd dd 0b				call update_display 
6300			 
6300				; prompt before entering montior for investigating issue 
6300			 
6300 3e 78			ld a, display_row_4 
6302 11 37 19			ld de, endprog 
6305			 
6305 cd dd 0b			call update_display		 
6308			 
6308 cd bd 1b			call next_page_prompt 
630b			 
630b e5					push hl 
630c d5					push de 
630d cd 8b 19				call monitor 
6310 c3 96 18				jp warmstart 
6313 76					halt 
6314			 
6314			 
6314 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
632b			 
632b d5			type_faults: 	push de 
632c e5					push hl 
632d cd ba 0b				call clear_display 
6330 11 56 63				   ld de, .typefaults 
6333 3e 00				ld a, display_row_1 
6335 cd cd 0b				call str_at_display 
6338 11 6b ee				    ld de, debug_mark 
633b 3e 11				ld a, display_row_1+17 
633d cd cd 0b				call str_at_display 
6340 cd dd 0b				call update_display 
6343			 
6343				; prompt before entering montior for investigating issue 
6343			 
6343 3e 78			ld a, display_row_4 
6345 11 37 19			ld de, endprog 
6348			 
6348 cd dd 0b			call update_display		 
634b			 
634b cd bd 1b			call next_page_prompt 
634e			 
634e e1					pop hl 
634f d1					pop de 
6350 cd 8b 19				call monitor 
6353 c3 96 18				jp warmstart 
6356			 
6356			 
6356 .. 00		.typefaults: db "STR Type Expected TOS!",0 
636d			 
636d			.show_fault: 	 
636d d5					push de 
636e cd ba 0b				call clear_display 
6371 d1					pop de 
6372 3e 00				ld a, display_row_1 
6374 cd cd 0b				call str_at_display 
6377 11 6b ee				    ld de, debug_mark 
637a 3e 11				ld a, display_row_1+17 
637c cd cd 0b				call str_at_display 
637f cd dd 0b				call update_display 
6382			 
6382				; prompt before entering montior for investigating issue 
6382			 
6382 3e 78			ld a, display_row_4 
6384 11 37 19			ld de, endprog 
6387			 
6387 cd dd 0b			call update_display		 
638a			 
638a cd bd 1b			call next_page_prompt 
638d			 
638d e1					pop hl 
638e d1					pop de 
638f cd 8b 19				call monitor 
6392			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6392			; TODO Make optional fault restart to cli or warm boot? 
6392					;jp warmstart 
6392 c3 de 18				jp cli 
6395 76					halt 
6396			 
6396			; handle the auto run of code from files in storage 
6396			 
6396			 
6396			include "forth_startup.asm" 
6396			; Which startup method to use? 
6396			; 
6396			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6396			; followed by loading of a list of scripts in eeprom 
6396			 
6396			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6396			; from eeprom 
6396			 
6396			; Select with define in main stubs 
6396			 
6396			if STARTUP_V1 
6396				include "forth_startupv1.asm" 
6396			; Startup script loading version 1 
6396			 
6396			; If SE storage is available first stage is to use the selected file 
6396			; then go through the eeprom list 
6396			 
6396 .. 00		sprompt1: db "Startup load...",0 
63a6 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
63bc			 
63bc			 
63bc			 
63bc			 
63bc			forth_startup: 
63bc 21 37 4e			ld hl, startcmds 
63bf 3e 00			ld a, 0 
63c1 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
63c4			 
63c4 e5			.start1:	push hl 
63c5 cd ba 0b			call clear_display 
63c8 11 96 63			ld de, sprompt1 
63cb 3e 00		        ld a, display_row_1 
63cd cd cd 0b			call str_at_display 
63d0 11 a6 63			ld de, sprompt2 
63d3 3e 28		        ld a, display_row_2 
63d5 cd cd 0b			call str_at_display 
63d8 e1				pop hl 
63d9 e5				push hl 
63da 5e				ld e,(hl) 
63db 23				inc hl 
63dc 56				ld d,(hl) 
63dd 3e 50		        ld a, display_row_3 
63df cd cd 0b			call str_at_display 
63e2 cd dd 0b			call update_display 
63e5			 
63e5			 
63e5 3a e7 e6			ld a, (os_last_cmd) 
63e8 fe 00			cp 0 
63ea 28 05			jr z, .startprompt 
63ec cd e6 0a			call delay250ms 
63ef 18 24			jr .startdo 
63f1				 
63f1				 
63f1			 
63f1			.startprompt: 
63f1			 
63f1 3e 9f			ld a,display_row_4 + display_cols - 1 
63f3 11 bb 1b		        ld de, endprg 
63f6 cd cd 0b			call str_at_display 
63f9 cd dd 0b			call update_display 
63fc cd f2 0a			call delay1s 
63ff cd 6e 65			call cin_wait 
6402						 
6402 fe 2a			cp '*' 
6404 28 5e			jr z, .startupend1 
6406 fe 23			cp '#' 
6408 20 07			jr nz, .startno 
640a 3e 01			ld a, 1 
640c 32 e7 e6			ld (os_last_cmd),a 
640f 18 04			jr .startdo 
6411 fe 31		.startno:	cp '1' 
6413 28 3a			jr z,.startnxt  
6415			 
6415				; exec startup line 
6415			.startdo:	 
6415 e1				pop hl 
6416 e5				push hl 
6417				 
6417 5e				ld e,(hl) 
6418 23				inc hl 
6419 56				ld d,(hl) 
641a eb				ex de,hl 
641b			 
641b e5				push hl 
641c			 
641c 3e 00			ld a, 0 
641e				;ld a, FORTH_END_BUFFER 
641e cd 50 12			call strlent 
6421 23				inc hl   ; include zero term to copy 
6422 06 00			ld b,0 
6424 4d				ld c,l 
6425 e1				pop hl 
6426 11 c1 e2			ld de, scratch 
6429 ed b0			ldir 
642b			 
642b			 
642b 21 c1 e2			ld hl, scratch 
642e cd 40 20			call forthparse 
6431 cd 80 20			call forthexec 
6434 cd 92 1f			call forthexec_cleanup 
6437			 
6437 3e 78			ld a, display_row_4 
6439 11 37 19			ld de, endprog 
643c			 
643c cd dd 0b			call update_display		 
643f			 
643f 3a e7 e6			ld a, (os_last_cmd) 
6442 fe 00			cp 0 
6444 20 09			jr nz, .startnxt 
6446 cd bd 1b			call next_page_prompt 
6449 cd ba 0b		        call clear_display 
644c cd dd 0b			call update_display		 
644f			 
644f				; move onto next startup line? 
644f			.startnxt: 
644f			 
644f cd e6 0a			call delay250ms 
6452 e1				pop hl 
6453			 
6453 23				inc hl 
6454 23				inc hl 
6455			 
6455 e5				push hl 
6456 5e				ld e, (hl) 
6457 23				inc hl 
6458 56				ld d, (hl) 
6459 e1				pop hl 
645a				; TODO replace 0 test 
645a			 
645a eb				ex de, hl 
645b cd 10 0e			call ishlzero 
645e			;	ld a,e 
645e			;	add d 
645e			;	cp 0    ; any left to do? 
645e eb				ex de, hl 
645f c2 c4 63			jp nz, .start1 
6462 18 01			jr .startupend 
6464			 
6464 e1			.startupend1: pop hl 
6465			.startupend: 
6465			 
6465 cd ba 0b			call clear_display 
6468 cd dd 0b			call update_display 
646b c9				ret 
646c			if STORAGE_SE 
646c			 
646c			sprompt3: db "Loading from start-up file?:",0 
646c			sprompt4: db "(Y=Any key/N=No)",0 
646c			 
646c			 
646c			forth_autoload: 
646c			 
646c				; load block 0 of store 1 
646c				 
646c				ld a, $fe      ; bit 0 clear 
646c				ld (spi_device), a 
646c			 
646c				call storage_get_block_0 
646c			 
646c				ld a, (store_page+STORE_0_AUTOFILE) 
646c			 
646c				cp 0 
646c				ret z     ; auto start not enabled 
646c			 
646c				call clear_display 
646c			 
646c				; set bank 
646c			 
646c					ld a, (store_page+STORE_0_BANKRUN) 
646c					ld (spi_device), a 
646c			 
646c				; get file id to load from and get the file name to display 
646c			 
646c					ld a, (store_page+STORE_0_FILERUN) 
646c			 
646c					ld l, 0 
646c					ld h, a 
646c					ld de, store_page 
646c			 
646c					if DEBUG_FORTH_WORDS 
646c						DMARK "ASp" 
646c						CALLMONITOR 
646c					endif 
646c					call storage_read 
646c			 
646c					if DEBUG_FORTH_WORDS 
646c						DMARK "ASr" 
646c						CALLMONITOR 
646c					endif 
646c			 
646c					call ishlzero 
646c					ret z             ; file not found 
646c			 
646c					ld a, display_row_2 + 10 
646c					ld de, store_page+3 
646c					call str_at_display 
646c				 
646c			; 
646c			 
646c				ld a, display_row_1+5 
646c				ld de, sprompt3 
646c				call str_at_display 
646c				ld a, display_row_3+15 
646c				ld de, sprompt4 
646c				call str_at_display 
646c			 
646c				call update_display 
646c			 
646c				call cin_wait 
646c				cp 'n' 
646c				ret z 
646c				cp 'N' 
646c				ret z 
646c			 
646c				call delay1s 
646c			 
646c				ld a, (store_page+2) 
646c				ld (store_openmaxext), a    ; save count of ext 
646c				ld a, 1  
646c				ld (store_openext), a    ; save count of ext 
646c			 
646c			.autof:  
646c				ld l , a 
646c				 
646c				ld a, (store_page) 
646c				ld h, a	 
646c				ld de, store_page 
646c					if DEBUG_FORTH_WORDS 
646c						DMARK "ASl" 
646c						CALLMONITOR 
646c					endif 
646c					call storage_read 
646c				call ishlzero 
646c				ret z 
646c			;	jr z, .autoend 
646c			 
646c					if DEBUG_FORTH_WORDS 
646c						DMARK "ASc" 
646c						CALLMONITOR 
646c					endif 
646c				ld de, store_page+2 
646c				ld a, display_row_4 
646c				call str_at_display 
646c			 
646c				call update_display 
646c				call delay250ms 
646c			 
646c			 
646c			 
646c				ld hl, store_page+2 
646c				call forthparse 
646c				call forthexec 
646c				call forthexec_cleanup 
646c			 
646c				 
646c				ld a, (store_openext) 
646c				inc a 
646c				ld (store_openext), a    ; save count of ext 
646c			 
646c				jr .autof 
646c			;.autofdone: 
646c			; 
646c			;		if DEBUG_FORTH_WORDS 
646c			;			DMARK "ASx" 
646c			;			CALLMONITOR 
646c			;		endif 
646c			;;	call clear_display 
646c			;	ret 
646c			 
646c			 
646c			 
646c			endif 
# End of file forth_startupv1.asm
646c			endif 
646c			if STARTUP_V2 
646c				include "forth_startupv2.asm" 
646c			endif 
646c			 
# End of file forth_startup.asm
646c			 
646c			; eof 
# End of file forth_kernel.asm
646c			;include "nascombasic.asm" 
646c			 
646c			 
646c			; find out where the code ends if loaded into RAM (for SC114) 
646c			;endofcode:  
646c			;	nop 
646c			 
646c			 
646c			; jump to nmi vector 
646c			 
646c			init_nmi: 
646c 3e c9			ld a, $c9   ; RET 
646e 32 72 ee			ld (nmi_vector), a 
6471 c9				ret 
6472			nmi: 
6472 e5				push hl 
6473 d5				push de 
6474 c5				push bc 
6475 f5				push af 
6476 cd 72 ee			call nmi_vector 
6479 f5				push af 
647a c5				push bc 
647b d5				push de 
647c e5				push hl 
647d ed 4d			reti 
647f			 
647f			 
647f			; eof 
647f			 
# End of file main.asm
647f			;include "firmware_lcd_4x40.asm" 
647f			;;include "firmware_lcd_4x20.asm" 
647f			include "firmware_cpm_display.asm" 
647f			 
647f			; Serial display interface for SC114 
647f			 
647f			 
647f			display_row_1: equ 0 
647f			display_row_2: equ display_row_1+display_cols 
647f			display_row_3: equ display_row_2 + display_cols 
647f			display_row_4: equ display_row_3 + display_cols 
647f			 
647f			kLCDWidth:  EQU display_cols             ;Width in characters 
647f			kLCD_Line1: EQU 0x00  
647f			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
647f			; E1 
647f			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
647f			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
647f			 
647f			lcd_init: 
647f				; no init as handled by the SCM bios 
647f c9				ret 
6480			 
6480			 
6480			; low level functions for direct screen writes 
6480			 
6480			; output char at pos? 
6480			fLCD_Str: 
6480			        ;out (SC114_SIO_1_OUT),a 
6480 c5				push bc 
6481 d5				push de 
6482 5f				ld e, a 
6483			; TODO Replace with CP/M BIOS call 
6483 0e 02			ld c, $02 
6485 cd 05 00			call 5 
6488 d1				pop de 
6489 c1				pop bc 
648a c9				ret 
648b			 
648b			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
648b			fLCD_Pos: 
648b				; use ASCII escape to position 
648b			        ;out (SC114_SIO_1_OUT),a 
648b c5				push bc 
648c d5				push de 
648d 5f				ld e, a 
648e 0e 02			ld c, $02 
6490			; TODO Replace with CP/M BIOS call 
6490 cd 05 00			call 5 
6493 d1				pop de 
6494 c1				pop bc 
6495			 
6495 c9				ret 
6496			 
6496			; output char at pos 
6496			fLCD_Data: 
6496			      ;  out (SC114_SIO_1_OUT),a 
6496 c5				push bc 
6497 d5				push de 
6498 0e 02			ld c, $02 
649a 5f				ld e, a 
649b			; TODO Replace with CP/M BIOS call 
649b cd 05 00			call 5 
649e d1				pop de 
649f c1				pop bc 
64a0			 
64a0 c9				ret 
64a1			 
64a1			; ascii cls  
64a1			 
64a1 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
64a5			 
64a5 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
64bc			;.clscpm: db 3, $3c,"$" 
64bc			 
64bc			; write the frame buffer given in hl to hardware  
64bc			write_display: 
64bc			 
64bc			API: equ 0 
64bc			 
64bc			if API 
64bc				push bc 
64bc				ld b, 4 
64bc			 
64bc			        ld (display_write_tmp), hl 	  
64bc			 
64bc				; clear and home cursor 
64bc			 
64bc				ld c, 9 
64bc				ld de, .cls 
64bc			; TODO Replace with CP/M BIOS call 
64bc				call 5 
64bc			 
64bc			 
64bc			.writeln: 
64bc			 
64bc				ld de, (display_write_tmp) 
64bc				ld c, 6 
64bc			; TODO Replace with CP/M BIOS call 
64bc				rst $30 
64bc				ld c, 7 
64bc				rst $30 
64bc			 
64bc				ld hl, (display_write_tmp) 
64bc				ld de, display_cols 
64bc				add hl,de 
64bc				ld (display_write_tmp),hl 
64bc			 
64bc				djnz  .writeln 
64bc			 
64bc				pop bc 
64bc			 
64bc			 
64bc				ret 
64bc			endif 
64bc e5				push hl 
64bd c5				push bc 
64be d5				push de 
64bf			 
64bf			;	ld c, 2 
64bf			;	;ld de, .cls 
64bf			;	ld a, 27 
64bf			;	rst $30 
64bf			;	ld c, 2 
64bf			;	;ld de, .cls 
64bf			;	ld a, '[' 
64bf			;	rst $30 
64bf			; 
64bf			;	ld c, 2 
64bf			;	;ld de, .cls 
64bf			;	ld a, 'H' 
64bf			;	rst $30 
64bf			; 
64bf			 
64bf			 
64bf			; lots of CR/LF 
64bf			;	ld c, 9 
64bf			;	ld de, .clscpm 
64bf			;	call 5 
64bf			 
64bf			; xterm cls 
64bf 0e 02			ld c, 2 
64c1 1e 1b			ld e, 27 
64c3 cd 05 00			call 5 
64c6			; cls causes too much flicker 
64c6			;	ld c, 2 
64c6			;	ld e, 'c' 
64c6			;	call 5 
64c6			 
64c6			; use xterm home instead 
64c6 0e 02			ld c, 2 
64c8 1e 5b			ld e, '[' 
64ca cd 05 00			call 5 
64cd 0e 02			ld c, 2 
64cf 1e 48			ld e, 'H' 
64d1 cd 05 00			call 5 
64d4			LLL: equ 0 
64d4			 
64d4			if LLL 
64d4			 
64d4				ld c, 2 
64d4				;ld de, .cls 
64d4				ld e, 27 
64d4			; TODO Replace with CP/M BIOS call 
64d4				call 5 
64d4			 
64d4			 
64d4				ld c, 2 
64d4				;ld de, .cls 
64d4				ld e, '[' 
64d4			; TODO Replace with CP/M BIOS call 
64d4				call 5 
64d4				ld c, 2 
64d4				;ld de, .cls 
64d4				ld e, '2' 
64d4			; TODO Replace with CP/M BIOS call 
64d4				call 5 
64d4				ld c, 2 
64d4				;ld de, .cls 
64d4				ld e, 'J' 
64d4			; TODO Replace with CP/M BIOS call 
64d4				call 5 
64d4			 
64d4			endif 
64d4			 
64d4 d1				pop de 
64d5 c1				pop bc 
64d6 e1				pop hl 
64d7			 
64d7			 
64d7 22 c9 eb		        ld (display_write_tmp), hl 	  
64da 3e 00			ld a, kLCD_Line1 
64dc			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
64dc 06 28			ld b, display_cols 
64de ed 5b c9 eb		ld de, (display_write_tmp) 
64e2 cd 65 65			call write_len_string 
64e5				 
64e5			 
64e5 e5			push hl 
64e6 d5			push de 
64e7 c5			push bc 
64e8 0e 02			ld c, 2 
64ea 1e 0a			ld e, 10 
64ec cd 05 00			call 5 
64ef 0e 02			ld c, 2 
64f1 1e 0d			ld e, 13 
64f3 cd 05 00			call 5 
64f6			; TODO Replace with CP/M BIOS call 
64f6				;rst $30 
64f6 c1			pop bc 
64f7 d1			pop de 
64f8 e1			pop hl 
64f9			 
64f9				 
64f9 2a c9 eb			ld hl, (display_write_tmp) 
64fc 11 28 00			ld de, display_cols 
64ff 19				add hl,de 
6500 22 c9 eb			ld (display_write_tmp),hl 
6503			 
6503				 
6503 3e 28			ld a, kLCD_Line2 
6505			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6505 06 28			ld b, display_cols 
6507 ed 5b c9 eb		ld de, (display_write_tmp) 
650b cd 65 65			call write_len_string 
650e				 
650e 2a c9 eb			ld hl, (display_write_tmp) 
6511 11 28 00			ld de, display_cols 
6514 19				add hl,de 
6515 22 c9 eb			ld (display_write_tmp),hl 
6518			 
6518 e5			push hl 
6519 d5			push de 
651a c5			push bc 
651b 0e 07			ld c, 7 
651d			; TODO Replace with CP/M BIOS call 
651d				;rst $30 
651d 0e 02			ld c, 2 
651f 1e 0a			ld e, 10 
6521 cd 05 00			call 5 
6524 0e 02			ld c, 2 
6526 1e 0d			ld e, 13 
6528 cd 05 00			call 5 
652b c1			pop bc 
652c d1			pop de 
652d e1			pop hl 
652e			 
652e				 
652e 3e 50			ld a, kLCD_Line3 
6530			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
6530 06 28			ld b, display_cols 
6532 ed 5b c9 eb		ld de, (display_write_tmp) 
6536 cd 65 65			call write_len_string 
6539				 
6539 2a c9 eb			ld hl, (display_write_tmp) 
653c 11 28 00			ld de, display_cols 
653f 19				add hl,de 
6540 22 c9 eb			ld (display_write_tmp),hl 
6543			 
6543 e5			push hl 
6544 d5			push de 
6545 c5			push bc 
6546 0e 07			ld c, 7 
6548			; TODO Replace with CP/M BIOS call 
6548				;rst $30 
6548 0e 02			ld c, 2 
654a 1e 0a			ld e, 10 
654c cd 05 00			call 5 
654f 0e 02			ld c, 2 
6551 1e 0d			ld e, 13 
6553 cd 05 00			call 5 
6556 c1			pop bc 
6557 d1			pop de 
6558 e1			pop hl 
6559			 
6559				 
6559 3e 78			ld a, kLCD_Line4 
655b			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
655b 06 28			ld b, display_cols 
655d ed 5b c9 eb		ld de, (display_write_tmp) 
6561 cd 65 65			call write_len_string 
6564 c9					ret 
6565			 
6565			 
6565				; write out a fixed length string given in b from de 
6565			 
6565 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
6566 cd 96 64		            CALL fLCD_Data      ;Write character to display 
6569 13				inc de 
656a 10 f9			djnz write_len_string 
656c c9				ret 
656d			 
656d			 
656d			; eof 
# End of file firmware_cpm_display.asm
656d			;include "firmware_key_5x10.asm" 
656d			;;include "firmware_key_4x10.asm" 
656d			include "firmware_key_cpm.asm" 
656d			; Serial keyboard interface for SC114 
656d			 
656d			 
656d			key_init: 
656d				; no init as handled by the SCM bios 
656d c9				ret 
656e			 
656e			 
656e			cin_wait: 
656e			;	ld a, 0 
656e			;	ret 
656e			 
656e				;in a,(SC114_SIO_1_IN) 
656e			        ; Use SCM API to get from whatever console device we are using 
656e			 
656e			; TODO Replace with CP/M BIOS call 
656e c5				push bc 
656f 0e 01			ld c, $01 
6571 cd 05 00			call 5 
6574 c1				pop bc 
6575 c9				ret 
6576			 
6576			cin: 
6576			 
6576			 
6576 c5				push bc 
6577			 
6577				; any key waiting to process? 
6577			; TODO Replace with CP/M BIOS call 
6577 0e 06			ld c, $06 
6579 cd 05 00			call 5 
657c 28 0d			jr z, .cin_skip 
657e			 
657e				; yep, get it 
657e			 
657e 0e 01			ld c, $01 
6580			; TODO Replace with CP/M BIOS call 
6580 cd 05 00			call 5 
6583			 
6583 fe 7f			cp $7f     ; back space 
6585 20 02			jr nz, .skipbs 
6587 3e 08			ld a, KEY_BS 
6589			.skipbs: 
6589			 
6589 c1				pop bc 
658a c9				ret 
658b			.cin_skip: 
658b 3e 00			ld a, 0 
658d c1				pop bc 
658e c9				ret 
658f			 
658f			 
658f			 
658f			 
# End of file firmware_key_cpm.asm
658f			endofcode:  
658f			baseram:  
658f 00				nop 
6590			 
6590			heap_start: equ baseram+15  ; Starting address of heap 
6590			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
6590			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
6590			;VDU:  EQU     endofcode           ; BASIC Work space 
6590			; eof 
6590			 
# End of file os_mega_cpm.asm
6590
