# File os_mini_sc114.asm
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			 
0000			 
0000			tos:	equ 0f000h 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			SC103_PIO: equ 068h 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 04 95			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 1   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
8003			  
8003			STORE_0_AUTOFILE: equ $21  
8003			STORE_0_BANKRUN: equ $23  
8003			STORE_0_FILERUN: equ $24  
8003			  
8003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
8003			  
8003			STORE_0_AUTORUN: equ $20  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			spi_device_id: equ spi_device - 1    ; human readable bank number  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ scratch-2  
8003			os_new_parse_len: equ os_new_malloc - 2  
8003			os_new_word_len: equ os_new_parse_len - 2  
8003			os_new_work_ptr: equ os_new_word_len - 2  
8003			os_new_src_ptr: equ os_new_work_ptr - 2  
8003			os_new_exec: equ os_new_src_ptr - 2  
8003			os_new_exec_ptr: equ os_new_exec - 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ os_new_exec_ptr - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 c6 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 05 ee				ld hl, display_fb1  
800b 22 61 ed				ld (display_fb_active), hl  
800e			  
800e cd 8e 88				call clear_display  
8011			  
8011 21 63 ed				ld hl, display_fb2  
8014 22 61 ed				ld (display_fb_active), hl  
8017			  
8017 cd 8e 88				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 56 ee				ld hl, display_fb0  
801d 22 61 ed				ld (display_fb_active), hl  
8020			  
8020 cd 8e 88				call clear_display  
8023			  
8023			  
8023 cd bd d6				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd 5f d7			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 5e 8f				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd b1 88			call update_display  
8032 cd 0e 88			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 93 88			call fill_display  
803a cd b1 88			call update_display  
803d cd 0e 88			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 93 88			call fill_display  
8045 cd b1 88			call update_display  
8048 cd 0e 88			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 93 88			call fill_display  
8050 cd b1 88			call update_display  
8053 cd 0e 88			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056 3e 00		        ld a, display_row_1    
8058			else  
8058			        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd a1 88			call str_at_display  
805e cd b1 88			call update_display  
8061			  
8061			  
8061 cd 0e 88			call delay1s  
8064 cd 0e 88			call delay1s  
8067			if display_cols == 20	  
8067 3e 2a		            LD   A, display_row_3+2  
8069			else  
8069			            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd a1 88			call str_at_display  
806f cd b1 88			call update_display  
8072 cd 0e 88			call delay1s  
8075 cd 0e 88			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 c0 ee		ld (debug_mark),a  
807d 32 c1 ee		ld (debug_mark+1),a  
8080 32 c2 ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 c3 ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 c0 ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 c1 ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 c2 ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd 2e 93			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6 f5				push af  
80e7 3a fb 80			ld a, (.dmark)  
80ea 32 c0 ee			ld (debug_mark),a  
80ed 3a fc 80			ld a, (.dmark+1)  
80f0 32 c1 ee			ld (debug_mark+1),a  
80f3 3a fd 80			ld a, (.dmark+2)  
80f6 32 c2 ee			ld (debug_mark+2),a  
80f9 18 03			jr .pastdmark  
80fb ..			.dmark: db "SIZ"  
80fe f1			.pastdmark: pop af  
80ff			endm  
# End of macro DMARK
80ff						CALLMONITOR 
80ff cd 2e 93			call break_point_state  
8102				endm  
# End of macro CALLMONITOR
8102					endif 
8102 cd d6 83			call storage_findnextid 
8105			 
8105 cd e4 8a			call ishlzero 
8108			;	ld a, l 
8108			;	add h 
8108			;	cp 0 
8108 c8				ret z			; block not found so EOF 
8109			 
8109 11 eb ec			ld de, store_page 
810c cd b1 80			call storage_read_block 
810f			 
810f 3a ed ec			ld a, (store_page+2)	 ; get extent count 
8112 6f				ld l, a 
8113 26 00			ld h, 0 
8115 c9			 	ret 
8116			 
8116			 
8116			; Write Block 
8116			; ----------- 
8116			; 
8116			; With current bank 
8116			;  
8116			; Get block number to write 
8116			; Write physical blocks starting at start block from buffer 
8116			  
8116			storage_write_block: 
8116				; TODO bank selection 
8116			 
8116				; for each of the physical blocks read it into the buffer 
8116 06 40			ld b, STORE_BLOCK_PHY 
8118			 
8118				if DEBUG_STORESE 
8118					DMARK "SWB" 
8118 f5				push af  
8119 3a 2d 81			ld a, (.dmark)  
811c 32 c0 ee			ld (debug_mark),a  
811f 3a 2e 81			ld a, (.dmark+1)  
8122 32 c1 ee			ld (debug_mark+1),a  
8125 3a 2f 81			ld a, (.dmark+2)  
8128 32 c2 ee			ld (debug_mark+2),a  
812b 18 03			jr .pastdmark  
812d ..			.dmark: db "SWB"  
8130 f1			.pastdmark: pop af  
8131			endm  
# End of macro DMARK
8131			 
8131					;push af 
8131					;ld a, 'W' 
8131					;ld (debug_mark),a 
8131					;pop af 
8131					CALLMONITOR 
8131 cd 2e 93			call break_point_state  
8134				endm  
# End of macro CALLMONITOR
8134				endif 
8134			 
8134			; might not be working 
8134			;	call se_writepage 
8134			 
8134			;	ret 
8134			; 
8134			 
8134			 
8134			 
8134			.wl1:    
8134			 
8134				; read physical block at hl into de 
8134			        ; increment hl and de to next read position on exit 
8134			 
8134 e5				push hl 
8135 d5				push de	 
8136 c5				push bc 
8137 1a				ld a,(de) 
8138				;if DEBUG_STORESE 
8138			;		push af 
8138			;		ld a, 'W' 
8138			;		ld (debug_mark),a 
8138			;		pop af 
8138			;		CALLMONITOR 
8138			;	endif 
8138 cd af 80			call se_writebyte 
813b			;	call delay250ms 
813b 00				nop 
813c 00				nop 
813d 00				nop 
813e			;	if DEBUG_STORESE 
813e			;		push af 
813e			;		ld a, 'w' 
813e			;		ld (debug_mark),a 
813e			;		pop af 
813e			;		CALLMONITOR 
813e			;	endif 
813e c1				pop bc 
813f d1				pop de 
8140 e1				pop hl 
8141 23				inc hl 
8142 13				inc de 
8143			 
8143			 
8143 10 ef			djnz .wl1 
8145			 
8145				if DEBUG_STORESE 
8145					DMARK "SW2" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 c0 ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 c1 ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 c2 ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SW2"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e			 
815e					;push af 
815e					;ld a, 'W' 
815e					;ld (debug_mark),a 
815e					;pop af 
815e					CALLMONITOR 
815e cd 2e 93			call break_point_state  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161 c9				ret	 
8162			 
8162			; Init bank 
8162			; --------- 
8162			; 
8162			; With current bank 
8162			; 
8162			; Setup block 0 config 
8162			;     Set 0 file id counter 
8162			;     Set formatted byte pattern 
8162			;     Zero out bank label 
8162			;      
8162			; For every logical block write 0-1 byte as null 
8162			 
8162			storage_get_block_0: 
8162			 
8162				; TODO check presence 
8162			 
8162				; get block 0 config 
8162			 
8162 21 00 00			ld hl, 0 
8165 11 eb ec			ld de, store_page 
8168 cd b1 80			call storage_read_block 
816b			 
816b				if DEBUG_STORESE 
816b					DMARK "SB0" 
816b f5				push af  
816c 3a 80 81			ld a, (.dmark)  
816f 32 c0 ee			ld (debug_mark),a  
8172 3a 81 81			ld a, (.dmark+1)  
8175 32 c1 ee			ld (debug_mark+1),a  
8178 3a 82 81			ld a, (.dmark+2)  
817b 32 c2 ee			ld (debug_mark+2),a  
817e 18 03			jr .pastdmark  
8180 ..			.dmark: db "SB0"  
8183 f1			.pastdmark: pop af  
8184			endm  
# End of macro DMARK
8184 11 eb ec				ld de, store_page 
8187			;		push af 
8187			;		ld a, 'i' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187					CALLMONITOR 
8187 cd 2e 93			call break_point_state  
818a				endm  
# End of macro CALLMONITOR
818a				endif 
818a			 
818a				; is this area formatted? 
818a			 
818a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
818a 2a ec ec			ld hl, (store_page+1) 
818d 3e 80			ld a,0x80 
818f bd				cp l 
8190 20 22			jr nz, .ininotformatted 
8192				; do a double check 
8192 3e 27			ld a, 0x27 
8194 bc				cp h 
8195 20 1d			jr nz, .ininotformatted 
8197			 
8197				; formatted then 
8197			 
8197				if DEBUG_STORESE 
8197					DMARK "SB1" 
8197 f5				push af  
8198 3a ac 81			ld a, (.dmark)  
819b 32 c0 ee			ld (debug_mark),a  
819e 3a ad 81			ld a, (.dmark+1)  
81a1 32 c1 ee			ld (debug_mark+1),a  
81a4 3a ae 81			ld a, (.dmark+2)  
81a7 32 c2 ee			ld (debug_mark+2),a  
81aa 18 03			jr .pastdmark  
81ac ..			.dmark: db "SB1"  
81af f1			.pastdmark: pop af  
81b0			endm  
# End of macro DMARK
81b0					;push af 
81b0					;ld a, 'I' 
81b0					;ld (debug_mark),a 
81b0					;pop af 
81b0					CALLMONITOR 
81b0 cd 2e 93			call break_point_state  
81b3				endm  
# End of macro CALLMONITOR
81b3				endif 
81b3 c9				ret 
81b4			 
81b4			.ininotformatted: 
81b4				; bank not formatted so poke various bits to make sure 
81b4			 
81b4				if DEBUG_STORESE 
81b4					DMARK "SB2" 
81b4 f5				push af  
81b5 3a c9 81			ld a, (.dmark)  
81b8 32 c0 ee			ld (debug_mark),a  
81bb 3a ca 81			ld a, (.dmark+1)  
81be 32 c1 ee			ld (debug_mark+1),a  
81c1 3a cb 81			ld a, (.dmark+2)  
81c4 32 c2 ee			ld (debug_mark+2),a  
81c7 18 03			jr .pastdmark  
81c9 ..			.dmark: db "SB2"  
81cc f1			.pastdmark: pop af  
81cd			endm  
# End of macro DMARK
81cd					;push af 
81cd					;ld a, 'f' 
81cd					;ld (debug_mark),a 
81cd					;pop af 
81cd					CALLMONITOR 
81cd cd 2e 93			call break_point_state  
81d0				endm  
# End of macro CALLMONITOR
81d0				endif 
81d0			 
81d0 cd d1 87			call storage_clear_page 
81d3			 
81d3 21 eb ec			ld hl, store_page 
81d6 3e 00			ld a, 0 
81d8				 
81d8 77				ld (hl),a   ; reset file counter 
81d9			 
81d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81dc 22 ec ec		 	ld (store_page+1), hl	 
81df			 
81df				; set default label 
81df			 
81df 21 7b 82			ld hl, .defaultbanklabl 
81e2 11 ee ec		 	ld de, store_page+3 
81e5 01 0f 00			ld bc, 15 
81e8 ed b0			ldir 
81ea			 
81ea				; Append the current bank id 
81ea 21 f7 ec			ld hl, store_page+3+9 
81ed 3a d0 ec			ld a, (spi_device_id) 
81f0 77				ld (hl), a 
81f1			 
81f1				; save default page 0 
81f1			 
81f1 21 00 00			ld hl, 0 
81f4 11 eb ec			ld de, store_page 
81f7				if DEBUG_STORESE 
81f7					DMARK "SB3" 
81f7 f5				push af  
81f8 3a 0c 82			ld a, (.dmark)  
81fb 32 c0 ee			ld (debug_mark),a  
81fe 3a 0d 82			ld a, (.dmark+1)  
8201 32 c1 ee			ld (debug_mark+1),a  
8204 3a 0e 82			ld a, (.dmark+2)  
8207 32 c2 ee			ld (debug_mark+2),a  
820a 18 03			jr .pastdmark  
820c ..			.dmark: db "SB3"  
820f f1			.pastdmark: pop af  
8210			endm  
# End of macro DMARK
8210			;		push af 
8210			;		ld a, 'F' 
8210			;		ld (debug_mark),a 
8210			;		pop af 
8210					CALLMONITOR 
8210 cd 2e 93			call break_point_state  
8213				endm  
# End of macro CALLMONITOR
8213				endif 
8213 cd 16 81			call storage_write_block 
8216				if DEBUG_STORESE 
8216					DMARK "SB4" 
8216 f5				push af  
8217 3a 2b 82			ld a, (.dmark)  
821a 32 c0 ee			ld (debug_mark),a  
821d 3a 2c 82			ld a, (.dmark+1)  
8220 32 c1 ee			ld (debug_mark+1),a  
8223 3a 2d 82			ld a, (.dmark+2)  
8226 32 c2 ee			ld (debug_mark+2),a  
8229 18 03			jr .pastdmark  
822b ..			.dmark: db "SB4"  
822e f1			.pastdmark: pop af  
822f			endm  
# End of macro DMARK
822f			;		push af 
822f			;		ld a, '>' 
822f			;		ld (debug_mark),a 
822f			;		pop af 
822f					CALLMONITOR 
822f cd 2e 93			call break_point_state  
8232				endm  
# End of macro CALLMONITOR
8232				endif 
8232			 
8232 00				nop 
8233 00				nop 
8234 00				nop 
8235			 
8235				; now set 0 in every page to mark as a free block 
8235			 
8235 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8237 21 40 00			ld hl, STORE_BLOCK_PHY 
823a			 
823a 3e 00		.setmark1:   	ld a,0 
823c e5					push hl 
823d c5					push bc 
823e cd af 80				call se_writebyte 
8241 3e 0a			ld a, 10 
8243 cd f3 87			call aDelayInMS 
8246 23				inc hl 
8247 cd af 80				call se_writebyte 
824a 3e 0a			ld a, 10 
824c cd f3 87			call aDelayInMS 
824f 2b				dec hl 
8250 c1					pop bc 
8251 e1					pop hl 
8252 3e 40				ld a, STORE_BLOCK_PHY 
8254 cd bb 8a				call addatohl 
8257 10 e1				djnz .setmark1 
8259			 
8259 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
825b 3e 00		.setmark2:   	ld a,0 
825d e5					push hl 
825e c5					push bc 
825f cd af 80				call se_writebyte 
8262 3e 0a			ld a, 10 
8264 cd f3 87			call aDelayInMS 
8267 23				inc hl 
8268 cd af 80				call se_writebyte 
826b 3e 0a			ld a, 10 
826d cd f3 87			call aDelayInMS 
8270 2b				dec hl 
8271 c1					pop bc 
8272 e1					pop hl 
8273 3e 40				ld a, STORE_BLOCK_PHY 
8275 cd bb 8a				call addatohl 
8278 10 e1				djnz .setmark2 
827a			 
827a					 
827a			 
827a			 
827a c9				ret 
827b			 
827b			 
827b			 
827b			 
827b .. 00		.defaultbanklabl:   db "BankLabel_",0 
8286			 
8286			 
8286			 
8286			; Label Bank 
8286			; ---------- 
8286			; 
8286			; With current bank 
8286			; Read block 0 
8286			; Set label 
8286			; Write block 0 
8286			 
8286			; label str pointer in hl 
8286			 
8286			storage_label:     
8286			 
8286				if DEBUG_STORESE 
8286					DMARK "LBL" 
8286 f5				push af  
8287 3a 9b 82			ld a, (.dmark)  
828a 32 c0 ee			ld (debug_mark),a  
828d 3a 9c 82			ld a, (.dmark+1)  
8290 32 c1 ee			ld (debug_mark+1),a  
8293 3a 9d 82			ld a, (.dmark+2)  
8296 32 c2 ee			ld (debug_mark+2),a  
8299 18 03			jr .pastdmark  
829b ..			.dmark: db "LBL"  
829e f1			.pastdmark: pop af  
829f			endm  
# End of macro DMARK
829f					CALLMONITOR 
829f cd 2e 93			call break_point_state  
82a2				endm  
# End of macro CALLMONITOR
82a2				endif 
82a2			 
82a2 e5				push hl 
82a3			 
82a3 cd 62 81			call storage_get_block_0 
82a6			 
82a6				; set default label 
82a6			 
82a6 e1				pop hl 
82a7			 
82a7 11 ee ec		 	ld de, store_page+3 
82aa 01 0f 00			ld bc, 15 
82ad				if DEBUG_STORESE 
82ad					DMARK "LB3" 
82ad f5				push af  
82ae 3a c2 82			ld a, (.dmark)  
82b1 32 c0 ee			ld (debug_mark),a  
82b4 3a c3 82			ld a, (.dmark+1)  
82b7 32 c1 ee			ld (debug_mark+1),a  
82ba 3a c4 82			ld a, (.dmark+2)  
82bd 32 c2 ee			ld (debug_mark+2),a  
82c0 18 03			jr .pastdmark  
82c2 ..			.dmark: db "LB3"  
82c5 f1			.pastdmark: pop af  
82c6			endm  
# End of macro DMARK
82c6					CALLMONITOR 
82c6 cd 2e 93			call break_point_state  
82c9				endm  
# End of macro CALLMONITOR
82c9				endif 
82c9 ed b0			ldir 
82cb				; save default page 0 
82cb			 
82cb 21 00 00			ld hl, 0 
82ce 11 eb ec			ld de, store_page 
82d1				if DEBUG_STORESE 
82d1					DMARK "LBW" 
82d1 f5				push af  
82d2 3a e6 82			ld a, (.dmark)  
82d5 32 c0 ee			ld (debug_mark),a  
82d8 3a e7 82			ld a, (.dmark+1)  
82db 32 c1 ee			ld (debug_mark+1),a  
82de 3a e8 82			ld a, (.dmark+2)  
82e1 32 c2 ee			ld (debug_mark+2),a  
82e4 18 03			jr .pastdmark  
82e6 ..			.dmark: db "LBW"  
82e9 f1			.pastdmark: pop af  
82ea			endm  
# End of macro DMARK
82ea					CALLMONITOR 
82ea cd 2e 93			call break_point_state  
82ed				endm  
# End of macro CALLMONITOR
82ed				endif 
82ed cd 16 81			call storage_write_block 
82f0			 
82f0 c9				ret 
82f1			 
82f1			 
82f1			 
82f1			; Read Block 0 - Config 
82f1			; --------------------- 
82f1			; 
82f1			; With current bank 
82f1			; Call presence test 
82f1			;    If not present format/init bank  
82f1			; Read block 0  
82f1			;  
82f1			 
82f1			 
82f1			; Dir 
82f1			; --- 
82f1			; 
82f1			; With current bank 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block read byte 2 
82f1			;      if first block of file 
82f1			;         Display file name 
82f1			;         Display type flags for file 
82f1			;        
82f1			 
82f1			; moving to words as this requires stack control 
82f1			 
82f1			 
82f1			; Delete File 
82f1			; ----------- 
82f1			; 
82f1			; With current bank 
82f1			; 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block file id 
82f1			;      If first block of file and dont have file id 
82f1			;         if file to delete 
82f1			;         Save file id 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			;      If file id is one saved 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			 
82f1			storage_erase: 
82f1			 
82f1				; hl contains the file id 
82f1			 
82f1 5d				ld e, l 
82f2 16 00			ld d, 0 
82f4 21 40 00			ld hl, STORE_BLOCK_PHY 
82f7					if DEBUG_FORTH_WORDS 
82f7						DMARK "ERA" 
82f7 f5				push af  
82f8 3a 0c 83			ld a, (.dmark)  
82fb 32 c0 ee			ld (debug_mark),a  
82fe 3a 0d 83			ld a, (.dmark+1)  
8301 32 c1 ee			ld (debug_mark+1),a  
8304 3a 0e 83			ld a, (.dmark+2)  
8307 32 c2 ee			ld (debug_mark+2),a  
830a 18 03			jr .pastdmark  
830c ..			.dmark: db "ERA"  
830f f1			.pastdmark: pop af  
8310			endm  
# End of macro DMARK
8310						CALLMONITOR 
8310 cd 2e 93			call break_point_state  
8313				endm  
# End of macro CALLMONITOR
8313					endif 
8313 cd d6 83			call storage_findnextid 
8316 cd e4 8a			call ishlzero 
8319 c8				ret z 
831a			 
831a e5				push hl 
831b			 
831b				; TODO check file not found 
831b			 
831b 11 eb ec			ld de, store_page 
831e cd b1 80			call storage_read_block 
8321			 
8321					if DEBUG_FORTH_WORDS 
8321						DMARK "ER1" 
8321 f5				push af  
8322 3a 36 83			ld a, (.dmark)  
8325 32 c0 ee			ld (debug_mark),a  
8328 3a 37 83			ld a, (.dmark+1)  
832b 32 c1 ee			ld (debug_mark+1),a  
832e 3a 38 83			ld a, (.dmark+2)  
8331 32 c2 ee			ld (debug_mark+2),a  
8334 18 03			jr .pastdmark  
8336 ..			.dmark: db "ER1"  
8339 f1			.pastdmark: pop af  
833a			endm  
# End of macro DMARK
833a						CALLMONITOR 
833a cd 2e 93			call break_point_state  
833d				endm  
# End of macro CALLMONITOR
833d					endif 
833d 3a eb ec			ld a, (store_page)	; get file id 
8340 32 e4 ec			ld (store_tmpid), a 
8343			 
8343 3a ed ec			ld a, (store_page+2)    ; get count of extends 
8346 32 e3 ec			ld (store_tmpext), a 
8349			 
8349				; wipe file header 
8349			 
8349 e1				pop hl 
834a 3e 00			ld a, 0 
834c 32 eb ec			ld (store_page), a 
834f 32 ec ec			ld (store_page+1),a 
8352 11 eb ec			ld de, store_page 
8355					if DEBUG_FORTH_WORDS 
8355						DMARK "ER2" 
8355 f5				push af  
8356 3a 6a 83			ld a, (.dmark)  
8359 32 c0 ee			ld (debug_mark),a  
835c 3a 6b 83			ld a, (.dmark+1)  
835f 32 c1 ee			ld (debug_mark+1),a  
8362 3a 6c 83			ld a, (.dmark+2)  
8365 32 c2 ee			ld (debug_mark+2),a  
8368 18 03			jr .pastdmark  
836a ..			.dmark: db "ER2"  
836d f1			.pastdmark: pop af  
836e			endm  
# End of macro DMARK
836e						CALLMONITOR 
836e cd 2e 93			call break_point_state  
8371				endm  
# End of macro CALLMONITOR
8371					endif 
8371 cd 16 81			call storage_write_block 
8374			 
8374			 
8374				; wipe file extents 
8374			 
8374 3a e3 ec			ld a, (store_tmpext) 
8377 47				ld b, a 
8378			 
8378			.eraext:	  
8378 c5				push bc 
8379			 
8379 21 40 00			ld hl, STORE_BLOCK_PHY 
837c 3a e4 ec			ld a,(store_tmpid) 
837f 5f				ld e, a 
8380 50				ld d, b	 
8381					if DEBUG_FORTH_WORDS 
8381						DMARK "ER3" 
8381 f5				push af  
8382 3a 96 83			ld a, (.dmark)  
8385 32 c0 ee			ld (debug_mark),a  
8388 3a 97 83			ld a, (.dmark+1)  
838b 32 c1 ee			ld (debug_mark+1),a  
838e 3a 98 83			ld a, (.dmark+2)  
8391 32 c2 ee			ld (debug_mark+2),a  
8394 18 03			jr .pastdmark  
8396 ..			.dmark: db "ER3"  
8399 f1			.pastdmark: pop af  
839a			endm  
# End of macro DMARK
839a						CALLMONITOR 
839a cd 2e 93			call break_point_state  
839d				endm  
# End of macro CALLMONITOR
839d					endif 
839d cd d6 83			call storage_findnextid 
83a0			 
83a0 e5				push hl 
83a1 11 eb ec			ld de, store_page 
83a4 cd b1 80			call storage_read_block 
83a7			 
83a7				; free block	 
83a7			 
83a7 3e 00			ld a, 0 
83a9 32 eb ec			ld (store_page), a 
83ac 32 ec ec			ld (store_page+1),a 
83af 11 eb ec			ld de, store_page 
83b2 e1				pop hl 
83b3					if DEBUG_FORTH_WORDS 
83b3						DMARK "ER4" 
83b3 f5				push af  
83b4 3a c8 83			ld a, (.dmark)  
83b7 32 c0 ee			ld (debug_mark),a  
83ba 3a c9 83			ld a, (.dmark+1)  
83bd 32 c1 ee			ld (debug_mark+1),a  
83c0 3a ca 83			ld a, (.dmark+2)  
83c3 32 c2 ee			ld (debug_mark+2),a  
83c6 18 03			jr .pastdmark  
83c8 ..			.dmark: db "ER4"  
83cb f1			.pastdmark: pop af  
83cc			endm  
# End of macro DMARK
83cc						CALLMONITOR 
83cc cd 2e 93			call break_point_state  
83cf				endm  
# End of macro CALLMONITOR
83cf					endif 
83cf cd 16 81			call storage_write_block 
83d2			 
83d2 c1				pop bc 
83d3 10 a3			djnz .eraext 
83d5			 
83d5 c9				ret 
83d6			 
83d6			 
83d6			; Find Free Block 
83d6			; --------------- 
83d6			; 
83d6			; With current bank 
83d6			;  
83d6			; From given starting logical block 
83d6			;    Read block  
83d6			;    If no file id 
83d6			;         Return block id 
83d6			 
83d6			 
83d6			; hl starting page number 
83d6			; hl contains free page number or zero if no pages free 
83d6			; e contains the file id to locate 
83d6			; d contains the block number 
83d6			 
83d6			; TODO change to find file id and use zero for free block 
83d6			 
83d6			storage_findnextid: 
83d6			 
83d6				; now locate first 0 page to mark as a free block 
83d6			 
83d6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83d8			;	ld hl, STORE_BLOCK_PHY 
83d8			 
83d8					if DEBUG_FORTH_WORDS 
83d8					DMARK "FNI" 
83d8 f5				push af  
83d9 3a ed 83			ld a, (.dmark)  
83dc 32 c0 ee			ld (debug_mark),a  
83df 3a ee 83			ld a, (.dmark+1)  
83e2 32 c1 ee			ld (debug_mark+1),a  
83e5 3a ef 83			ld a, (.dmark+2)  
83e8 32 c2 ee			ld (debug_mark+2),a  
83eb 18 03			jr .pastdmark  
83ed ..			.dmark: db "FNI"  
83f0 f1			.pastdmark: pop af  
83f1			endm  
# End of macro DMARK
83f1						CALLMONITOR 
83f1 cd 2e 93			call break_point_state  
83f4				endm  
# End of macro CALLMONITOR
83f4					endif 
83f4			.ff1:   	 
83f4 e5					push hl 
83f5 c5					push bc 
83f6 d5					push de 
83f7 cd ae 80				call se_readbyte 
83fa 5f					ld e,a 
83fb 23					inc hl 
83fc cd ae 80				call se_readbyte 
83ff 57					ld d, a 
8400 e1					pop hl 
8401 e5					push hl 
8402 cd d9 8a				call cmp16 
8405 28 49				jr z, .fffound 
8407			 
8407 d1					pop de 
8408 c1					pop bc 
8409 e1					pop hl 
840a			 
840a					; is found? 
840a					;cp e 
840a					;ret z 
840a			 
840a 3e 40				ld a, STORE_BLOCK_PHY 
840c cd bb 8a				call addatohl 
840f 10 e3				djnz .ff1 
8411			 
8411 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8413			.ff2:   	 
8413			 
8413 e5					push hl 
8414 c5					push bc 
8415 d5					push de 
8416 cd ae 80				call se_readbyte 
8419 5f					ld e,a 
841a 23					inc hl 
841b cd ae 80				call se_readbyte 
841e 57					ld d, a 
841f			 
841f e1					pop hl 
8420 e5					push hl 
8421 cd d9 8a				call cmp16 
8424 28 2a				jr z, .fffound 
8426			 
8426 d1					pop de 
8427 c1					pop bc 
8428 e1					pop hl 
8429					; is found? 
8429					;cp e 
8429					;ret z 
8429			 
8429 3e 40				ld a, STORE_BLOCK_PHY 
842b cd bb 8a				call addatohl 
842e 10 e3				djnz .ff2 
8430			 
8430			 
8430					if DEBUG_FORTH_WORDS 
8430					DMARK "FN-" 
8430 f5				push af  
8431 3a 45 84			ld a, (.dmark)  
8434 32 c0 ee			ld (debug_mark),a  
8437 3a 46 84			ld a, (.dmark+1)  
843a 32 c1 ee			ld (debug_mark+1),a  
843d 3a 47 84			ld a, (.dmark+2)  
8440 32 c2 ee			ld (debug_mark+2),a  
8443 18 03			jr .pastdmark  
8445 ..			.dmark: db "FN-"  
8448 f1			.pastdmark: pop af  
8449			endm  
# End of macro DMARK
8449					;	push af 
8449					;	ld a, 'n' 
8449					;	ld (debug_mark),a 
8449					;	pop af 
8449						CALLMONITOR 
8449 cd 2e 93			call break_point_state  
844c				endm  
# End of macro CALLMONITOR
844c					endif 
844c				; no free marks! 
844c 21 00 00				ld hl, 0 
844f c9				ret 
8450			.fffound: 
8450				 
8450			 
8450 d1					pop de 
8451 c1					pop bc 
8452 e1					pop hl 
8453					if DEBUG_FORTH_WORDS 
8453					DMARK "FNF" 
8453 f5				push af  
8454 3a 68 84			ld a, (.dmark)  
8457 32 c0 ee			ld (debug_mark),a  
845a 3a 69 84			ld a, (.dmark+1)  
845d 32 c1 ee			ld (debug_mark+1),a  
8460 3a 6a 84			ld a, (.dmark+2)  
8463 32 c2 ee			ld (debug_mark+2),a  
8466 18 03			jr .pastdmark  
8468 ..			.dmark: db "FNF"  
846b f1			.pastdmark: pop af  
846c			endm  
# End of macro DMARK
846c					;	push af 
846c					;	ld a, 'n' 
846c					;	ld (debug_mark),a 
846c					;	pop af 
846c						CALLMONITOR 
846c cd 2e 93			call break_point_state  
846f				endm  
# End of macro CALLMONITOR
846f					endif 
846f c9				ret 
8470			 
8470			 
8470			 
8470			; Free Space 
8470			; ---------- 
8470			; 
8470			; With current bank 
8470			; 
8470			; Set block count to zero 
8470			; Starting with first logical block 
8470			;      Find free block  
8470			;      If block id given, increment block count 
8470			; 
8470			;  
8470			 
8470			 
8470			; hl contains count of free blocks 
8470			 
8470			storage_freeblocks: 
8470			 
8470				; now locate first 0 page to mark as a free block 
8470			 
8470 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8472 21 40 00			ld hl, STORE_BLOCK_PHY 
8475 11 00 00			ld de, 0 
8478			 
8478			.fb1:   	 
8478 e5					push hl 
8479 c5					push bc 
847a d5					push de 
847b cd ae 80				call se_readbyte 
847e d1					pop de 
847f c1					pop bc 
8480 e1					pop hl 
8481			 
8481					; is free? 
8481 fe 00				cp 0 
8483 20 01				jr nz, .ff1cont 
8485 13					inc de 
8486			 
8486			.ff1cont: 
8486			 
8486			 
8486 3e 40				ld a, STORE_BLOCK_PHY 
8488 cd bb 8a				call addatohl 
848b 10 eb				djnz .fb1 
848d			 
848d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
848f			.fb2:   	 
848f e5					push hl 
8490 c5					push bc 
8491 d5					push de 
8492 cd ae 80				call se_readbyte 
8495 d1					pop de 
8496 c1					pop bc 
8497 e1					pop hl 
8498			 
8498					; is free? 
8498 fe 00				cp 0 
849a 20 01				jr nz, .ff2cont 
849c 13					inc de 
849d			 
849d			.ff2cont: 
849d			 
849d 3e 40				ld a, STORE_BLOCK_PHY 
849f cd bb 8a				call addatohl 
84a2 10 eb				djnz .fb2 
84a4			 
84a4 eb				ex de, hl 
84a5 c9				ret 
84a6			 
84a6			; Get File ID 
84a6			; ----------- 
84a6			; 
84a6			; With current bank 
84a6			;  
84a6			; Load Block 0 Config 
84a6			; Get max file id number 
84a6			; For each logical block 
84a6			;    Read block file id 
84a6			;      If first block of file and dont have file id 
84a6			;         if file get id and exit 
84a6			 
84a6			 
84a6			 
84a6			 
84a6			; Create File 
84a6			; ----------- 
84a6			; 
84a6			; With current bank  
84a6			; Load Block 0 Config 
84a6			; Get max file id number 
84a6			; Increment file id number 
84a6			; Save Config 
84a6			; Find free block 
84a6			; Set buffer with file name and file id 
84a6			; Write buffer to free block  
84a6			 
84a6			 
84a6			; hl point to file name 
84a6			; hl returns file id 
84a6			 
84a6			; file format: 
84a6			; byte 0 - file id 
84a6			; byte 1 - extent number 
84a6			; byte 2-> data 
84a6			 
84a6			; format for extent number 0: 
84a6			; 
84a6			; byte 0 - file id 
84a6			; byte 1 - extent 0 
84a6			; byte 2 - extent count 
84a6			; byte 3 -> file name and meta data 
84a6			 
84a6			 
84a6			storage_create: 
84a6				if DEBUG_STORESE 
84a6					DMARK "SCR" 
84a6 f5				push af  
84a7 3a bb 84			ld a, (.dmark)  
84aa 32 c0 ee			ld (debug_mark),a  
84ad 3a bc 84			ld a, (.dmark+1)  
84b0 32 c1 ee			ld (debug_mark+1),a  
84b3 3a bd 84			ld a, (.dmark+2)  
84b6 32 c2 ee			ld (debug_mark+2),a  
84b9 18 03			jr .pastdmark  
84bb ..			.dmark: db "SCR"  
84be f1			.pastdmark: pop af  
84bf			endm  
# End of macro DMARK
84bf					CALLMONITOR 
84bf cd 2e 93			call break_point_state  
84c2				endm  
# End of macro CALLMONITOR
84c2				endif 
84c2			 
84c2 e5				push hl		; save file name pointer 
84c3			 
84c3 cd 62 81			call storage_get_block_0 
84c6			 
84c6 3a eb ec			ld a,(store_page)	; get current file id 
84c9 3c				inc a 
84ca 32 eb ec			ld (store_page),a 
84cd				 
84cd 32 e4 ec			ld (store_tmpid),a			; save id 
84d0			 
84d0 21 00 00			ld hl, 0 
84d3 11 eb ec			ld de, store_page 
84d6				if DEBUG_STORESE 
84d6					DMARK "SCw" 
84d6 f5				push af  
84d7 3a eb 84			ld a, (.dmark)  
84da 32 c0 ee			ld (debug_mark),a  
84dd 3a ec 84			ld a, (.dmark+1)  
84e0 32 c1 ee			ld (debug_mark+1),a  
84e3 3a ed 84			ld a, (.dmark+2)  
84e6 32 c2 ee			ld (debug_mark+2),a  
84e9 18 03			jr .pastdmark  
84eb ..			.dmark: db "SCw"  
84ee f1			.pastdmark: pop af  
84ef			endm  
# End of macro DMARK
84ef					CALLMONITOR 
84ef cd 2e 93			call break_point_state  
84f2				endm  
# End of macro CALLMONITOR
84f2				endif 
84f2 cd 16 81			call storage_write_block	 ; save update 
84f5			 
84f5				if DEBUG_STORESE 
84f5 11 eb ec				ld de, store_page 
84f8					DMARK "SCC" 
84f8 f5				push af  
84f9 3a 0d 85			ld a, (.dmark)  
84fc 32 c0 ee			ld (debug_mark),a  
84ff 3a 0e 85			ld a, (.dmark+1)  
8502 32 c1 ee			ld (debug_mark+1),a  
8505 3a 0f 85			ld a, (.dmark+2)  
8508 32 c2 ee			ld (debug_mark+2),a  
850b 18 03			jr .pastdmark  
850d ..			.dmark: db "SCC"  
8510 f1			.pastdmark: pop af  
8511			endm  
# End of macro DMARK
8511					CALLMONITOR 
8511 cd 2e 93			call break_point_state  
8514				endm  
# End of macro CALLMONITOR
8514				endif 
8514				;  
8514				 
8514 21 40 00			ld hl, STORE_BLOCK_PHY 
8517 11 00 00			ld de, 0 
851a cd d6 83			call storage_findnextid 
851d			 
851d 22 d5 ec			ld (store_tmppageid), hl    ; save page to use  
8520			 
8520				; TODO detect 0 = no spare blocks 
8520			 
8520				; hl now contains the free page to use for the file header page 
8520			 
8520				if DEBUG_STORESE 
8520				DMARK "SCF" 
8520 f5				push af  
8521 3a 35 85			ld a, (.dmark)  
8524 32 c0 ee			ld (debug_mark),a  
8527 3a 36 85			ld a, (.dmark+1)  
852a 32 c1 ee			ld (debug_mark+1),a  
852d 3a 37 85			ld a, (.dmark+2)  
8530 32 c2 ee			ld (debug_mark+2),a  
8533 18 03			jr .pastdmark  
8535 ..			.dmark: db "SCF"  
8538 f1			.pastdmark: pop af  
8539			endm  
# End of macro DMARK
8539					CALLMONITOR 
8539 cd 2e 93			call break_point_state  
853c				endm  
# End of macro CALLMONITOR
853c				endif 
853c			 
853c 22 d5 ec			ld (store_tmppageid), hl 
853f				 
853f 3a e4 ec			ld a,(store_tmpid)    ; get file id 
8542			;	ld a, (store_filecache)			; save to cache 
8542			 
8542 32 eb ec			ld (store_page),a    ; set page id 
8545 3e 00			ld a, 0			 ; extent 0 is file header 
8547 32 ec ec			ld (store_page+1), a   ; set file extent 
854a			 
854a 32 ed ec			ld (store_page+2), a   ; extent count for the file 
854d			 
854d			;	inc hl 		; init block 0 of file 
854d			;	inc hl   		; skip file and extent id 
854d			 ;       ld a, 0 
854d			;	ld (hl),a 
854d			;	ld a, (store_filecache+1)  	; save to cache 
854d			 
854d			;	inc hl    ; file name 
854d				 
854d				 
854d 11 ee ec			ld de, store_page+3    ; get buffer for term string to use as file name 
8550				if DEBUG_STORESE 
8550					DMARK "SCc" 
8550 f5				push af  
8551 3a 65 85			ld a, (.dmark)  
8554 32 c0 ee			ld (debug_mark),a  
8557 3a 66 85			ld a, (.dmark+1)  
855a 32 c1 ee			ld (debug_mark+1),a  
855d 3a 67 85			ld a, (.dmark+2)  
8560 32 c2 ee			ld (debug_mark+2),a  
8563 18 03			jr .pastdmark  
8565 ..			.dmark: db "SCc"  
8568 f1			.pastdmark: pop af  
8569			endm  
# End of macro DMARK
8569					CALLMONITOR 
8569 cd 2e 93			call break_point_state  
856c				endm  
# End of macro CALLMONITOR
856c				endif 
856c e1				pop hl    ; get zero term string 
856d e5				push hl 
856e 3e 00			ld a, 0 
8570 cd 24 8f			call strlent 
8573 23				inc hl   ; cover zero term 
8574 06 00			ld b,0 
8576 4d				ld c,l 
8577 e1				pop hl 
8578				;ex de, hl 
8578				if DEBUG_STORESE 
8578					DMARK "SCa" 
8578 f5				push af  
8579 3a 8d 85			ld a, (.dmark)  
857c 32 c0 ee			ld (debug_mark),a  
857f 3a 8e 85			ld a, (.dmark+1)  
8582 32 c1 ee			ld (debug_mark+1),a  
8585 3a 8f 85			ld a, (.dmark+2)  
8588 32 c2 ee			ld (debug_mark+2),a  
858b 18 03			jr .pastdmark  
858d ..			.dmark: db "SCa"  
8590 f1			.pastdmark: pop af  
8591			endm  
# End of macro DMARK
8591					;push af 
8591					;ld a, 'a' 
8591					;ld (debug_mark),a 
8591					;pop af 
8591					CALLMONITOR 
8591 cd 2e 93			call break_point_state  
8594				endm  
# End of macro CALLMONITOR
8594				endif 
8594 ed b0			ldir    ; copy zero term string 
8596				if DEBUG_STORESE 
8596					DMARK "SCA" 
8596 f5				push af  
8597 3a ab 85			ld a, (.dmark)  
859a 32 c0 ee			ld (debug_mark),a  
859d 3a ac 85			ld a, (.dmark+1)  
85a0 32 c1 ee			ld (debug_mark+1),a  
85a3 3a ad 85			ld a, (.dmark+2)  
85a6 32 c2 ee			ld (debug_mark+2),a  
85a9 18 03			jr .pastdmark  
85ab ..			.dmark: db "SCA"  
85ae f1			.pastdmark: pop af  
85af			endm  
# End of macro DMARK
85af					CALLMONITOR 
85af cd 2e 93			call break_point_state  
85b2				endm  
# End of macro CALLMONITOR
85b2				endif 
85b2			 
85b2				; write file header page 
85b2			 
85b2 2a d5 ec			ld hl,(store_tmppageid) 
85b5 11 eb ec			ld de, store_page 
85b8				if DEBUG_STORESE 
85b8					DMARK "SCb" 
85b8 f5				push af  
85b9 3a cd 85			ld a, (.dmark)  
85bc 32 c0 ee			ld (debug_mark),a  
85bf 3a ce 85			ld a, (.dmark+1)  
85c2 32 c1 ee			ld (debug_mark+1),a  
85c5 3a cf 85			ld a, (.dmark+2)  
85c8 32 c2 ee			ld (debug_mark+2),a  
85cb 18 03			jr .pastdmark  
85cd ..			.dmark: db "SCb"  
85d0 f1			.pastdmark: pop af  
85d1			endm  
# End of macro DMARK
85d1					;push af 
85d1					;ld a, 'b' 
85d1					;ld (debug_mark),a 
85d1					;pop af 
85d1					CALLMONITOR 
85d1 cd 2e 93			call break_point_state  
85d4				endm  
# End of macro CALLMONITOR
85d4				endif 
85d4 cd 16 81			call storage_write_block 
85d7			 
85d7 3a e4 ec			ld a, (store_tmpid) 
85da 6f				ld l, a 
85db 26 00			ld h,0 
85dd				if DEBUG_STORESE 
85dd					DMARK "SCz" 
85dd f5				push af  
85de 3a f2 85			ld a, (.dmark)  
85e1 32 c0 ee			ld (debug_mark),a  
85e4 3a f3 85			ld a, (.dmark+1)  
85e7 32 c1 ee			ld (debug_mark+1),a  
85ea 3a f4 85			ld a, (.dmark+2)  
85ed 32 c2 ee			ld (debug_mark+2),a  
85f0 18 03			jr .pastdmark  
85f2 ..			.dmark: db "SCz"  
85f5 f1			.pastdmark: pop af  
85f6			endm  
# End of macro DMARK
85f6					CALLMONITOR 
85f6 cd 2e 93			call break_point_state  
85f9				endm  
# End of macro CALLMONITOR
85f9				endif 
85f9 c9				ret 
85fa				 
85fa			 
85fa			 
85fa			; 
85fa			; Read File 
85fa			; 
85fa			; h - file id to locate 
85fa			; l - extent to locate 
85fa			; de - pointer to string to read into 
85fa			; 
85fa			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85fa			 
85fa			.sr_fail: 
85fa d1				pop de 
85fb c9				ret 
85fc			 
85fc			storage_read: 
85fc d5				push de 
85fd			 
85fd			; TODO BUG the above push is it popped before the RET Z? 
85fd			 
85fd			; TODO how to handle multiple part blocks 
85fd			 
85fd				; locate file extent to read 
85fd			 
85fd 5c				ld e, h 
85fe 55				ld d, l 
85ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8602				if DEBUG_STORESE 
8602					DMARK "SRE" 
8602 f5				push af  
8603 3a 17 86			ld a, (.dmark)  
8606 32 c0 ee			ld (debug_mark),a  
8609 3a 18 86			ld a, (.dmark+1)  
860c 32 c1 ee			ld (debug_mark+1),a  
860f 3a 19 86			ld a, (.dmark+2)  
8612 32 c2 ee			ld (debug_mark+2),a  
8615 18 03			jr .pastdmark  
8617 ..			.dmark: db "SRE"  
861a f1			.pastdmark: pop af  
861b			endm  
# End of macro DMARK
861b					CALLMONITOR 
861b cd 2e 93			call break_point_state  
861e				endm  
# End of macro CALLMONITOR
861e				endif 
861e cd d6 83			call storage_findnextid 
8621			 
8621				if DEBUG_STORESE 
8621					DMARK "SRf" 
8621 f5				push af  
8622 3a 36 86			ld a, (.dmark)  
8625 32 c0 ee			ld (debug_mark),a  
8628 3a 37 86			ld a, (.dmark+1)  
862b 32 c1 ee			ld (debug_mark+1),a  
862e 3a 38 86			ld a, (.dmark+2)  
8631 32 c2 ee			ld (debug_mark+2),a  
8634 18 03			jr .pastdmark  
8636 ..			.dmark: db "SRf"  
8639 f1			.pastdmark: pop af  
863a			endm  
# End of macro DMARK
863a					CALLMONITOR 
863a cd 2e 93			call break_point_state  
863d				endm  
# End of macro CALLMONITOR
863d				endif 
863d cd e4 8a			call ishlzero 
8640			;	ld a, l 
8640			;	add h 
8640			;	cp 0 
8640 28 b8			jr z,.sr_fail			; block not found so EOF 
8642			 
8642				; hl contains page number to load 
8642 d1				pop de   ; get storage 
8643 d5				push de 
8644				if DEBUG_STORESE 
8644					DMARK "SRg" 
8644 f5				push af  
8645 3a 59 86			ld a, (.dmark)  
8648 32 c0 ee			ld (debug_mark),a  
864b 3a 5a 86			ld a, (.dmark+1)  
864e 32 c1 ee			ld (debug_mark+1),a  
8651 3a 5b 86			ld a, (.dmark+2)  
8654 32 c2 ee			ld (debug_mark+2),a  
8657 18 03			jr .pastdmark  
8659 ..			.dmark: db "SRg"  
865c f1			.pastdmark: pop af  
865d			endm  
# End of macro DMARK
865d					CALLMONITOR 
865d cd 2e 93			call break_point_state  
8660				endm  
# End of macro CALLMONITOR
8660				endif 
8660 cd b1 80			call storage_read_block 
8663			 
8663			 
8663			; TODO if block has no zeros then need to read next block  
8663			 
8663			 
8663					 
8663 e1				pop hl 		 ; return start of data to show as not EOF 
8664 23				inc hl   ; past file id 
8665 23				inc hl   ; past ext 
8666				if DEBUG_STORESE 
8666					DMARK "SRe" 
8666 f5				push af  
8667 3a 7b 86			ld a, (.dmark)  
866a 32 c0 ee			ld (debug_mark),a  
866d 3a 7c 86			ld a, (.dmark+1)  
8670 32 c1 ee			ld (debug_mark+1),a  
8673 3a 7d 86			ld a, (.dmark+2)  
8676 32 c2 ee			ld (debug_mark+2),a  
8679 18 03			jr .pastdmark  
867b ..			.dmark: db "SRe"  
867e f1			.pastdmark: pop af  
867f			endm  
# End of macro DMARK
867f					CALLMONITOR 
867f cd 2e 93			call break_point_state  
8682				endm  
# End of macro CALLMONITOR
8682				endif 
8682 c9					ret 
8683			 
8683			 
8683			 
8683			; 
8683			; Append File 
8683			; 
8683			; hl - file id to locate 
8683			; de - pointer to (multi block) string to write 
8683			 
8683			.sa_notfound: 
8683 d1				pop de 
8684 c9				ret 
8685			 
8685			 
8685			storage_append: 
8685				; hl -  file id to append to 
8685				; de - string to append 
8685			 
8685 d5				push de 
8686				 
8686				if DEBUG_STORESE 
8686					DMARK "AP1" 
8686 f5				push af  
8687 3a 9b 86			ld a, (.dmark)  
868a 32 c0 ee			ld (debug_mark),a  
868d 3a 9c 86			ld a, (.dmark+1)  
8690 32 c1 ee			ld (debug_mark+1),a  
8693 3a 9d 86			ld a, (.dmark+2)  
8696 32 c2 ee			ld (debug_mark+2),a  
8699 18 03			jr .pastdmark  
869b ..			.dmark: db "AP1"  
869e f1			.pastdmark: pop af  
869f			endm  
# End of macro DMARK
869f					CALLMONITOR 
869f cd 2e 93			call break_point_state  
86a2				endm  
# End of macro CALLMONITOR
86a2				endif 
86a2			 
86a2 7d				ld a, l 
86a3 32 e4 ec			ld (store_tmpid), a 
86a6			 
86a6				; get file header  
86a6			 
86a6 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
86a8 3a e4 ec			ld a, (store_tmpid) 
86ab 5f				ld e, a 
86ac			 
86ac 21 40 00				ld hl, STORE_BLOCK_PHY 
86af cd d6 83				call storage_findnextid 
86b2			 
86b2 cd e4 8a			call ishlzero 
86b5 28 cc			jr z, .sa_notfound 
86b7			 
86b7 22 d5 ec			ld (store_tmppageid), hl 
86ba			 
86ba				; TODO handle file id not found 
86ba			 
86ba				if DEBUG_STORESE 
86ba					DMARK "AP2" 
86ba f5				push af  
86bb 3a cf 86			ld a, (.dmark)  
86be 32 c0 ee			ld (debug_mark),a  
86c1 3a d0 86			ld a, (.dmark+1)  
86c4 32 c1 ee			ld (debug_mark+1),a  
86c7 3a d1 86			ld a, (.dmark+2)  
86ca 32 c2 ee			ld (debug_mark+2),a  
86cd 18 03			jr .pastdmark  
86cf ..			.dmark: db "AP2"  
86d2 f1			.pastdmark: pop af  
86d3			endm  
# End of macro DMARK
86d3					CALLMONITOR 
86d3 cd 2e 93			call break_point_state  
86d6				endm  
# End of macro CALLMONITOR
86d6				endif 
86d6			 
86d6				; update file extent count 
86d6			 
86d6 11 eb ec			ld de, store_page 
86d9			 
86d9 cd b1 80			call storage_read_block 
86dc			 
86dc				if DEBUG_STORESE 
86dc					DMARK "AP3" 
86dc f5				push af  
86dd 3a f1 86			ld a, (.dmark)  
86e0 32 c0 ee			ld (debug_mark),a  
86e3 3a f2 86			ld a, (.dmark+1)  
86e6 32 c1 ee			ld (debug_mark+1),a  
86e9 3a f3 86			ld a, (.dmark+2)  
86ec 32 c2 ee			ld (debug_mark+2),a  
86ef 18 03			jr .pastdmark  
86f1 ..			.dmark: db "AP3"  
86f4 f1			.pastdmark: pop af  
86f5			endm  
# End of macro DMARK
86f5					CALLMONITOR 
86f5 cd 2e 93			call break_point_state  
86f8				endm  
# End of macro CALLMONITOR
86f8				endif 
86f8			;	ld (store_tmppageid), hl 
86f8			 
86f8 3a ed ec			ld a, (store_page+2) 
86fb 3c				inc a 
86fc 32 ed ec			ld (store_page+2), a 
86ff 32 e3 ec			ld (store_tmpext), a 
8702				 
8702				if DEBUG_STORESE 
8702					DMARK "AP3" 
8702 f5				push af  
8703 3a 17 87			ld a, (.dmark)  
8706 32 c0 ee			ld (debug_mark),a  
8709 3a 18 87			ld a, (.dmark+1)  
870c 32 c1 ee			ld (debug_mark+1),a  
870f 3a 19 87			ld a, (.dmark+2)  
8712 32 c2 ee			ld (debug_mark+2),a  
8715 18 03			jr .pastdmark  
8717 ..			.dmark: db "AP3"  
871a f1			.pastdmark: pop af  
871b			endm  
# End of macro DMARK
871b					CALLMONITOR 
871b cd 2e 93			call break_point_state  
871e				endm  
# End of macro CALLMONITOR
871e				endif 
871e 2a d5 ec			ld hl, (store_tmppageid) 
8721 11 eb ec			ld de, store_page 
8724 cd 16 81			call storage_write_block 
8727			 
8727				; find free block 
8727			 
8727 11 00 00			ld de, 0			 ; file extent to locate 
872a			 
872a 21 40 00				ld hl, STORE_BLOCK_PHY 
872d cd d6 83				call storage_findnextid 
8730 cd e4 8a			call ishlzero 
8733 ca 83 86			jp z, .sa_notfound 
8736			 
8736					; TODO handle no space left 
8736					 
8736 22 d5 ec				ld (store_tmppageid), hl 
8739			 
8739				if DEBUG_STORESE 
8739					DMARK "AP4" 
8739 f5				push af  
873a 3a 4e 87			ld a, (.dmark)  
873d 32 c0 ee			ld (debug_mark),a  
8740 3a 4f 87			ld a, (.dmark+1)  
8743 32 c1 ee			ld (debug_mark+1),a  
8746 3a 50 87			ld a, (.dmark+2)  
8749 32 c2 ee			ld (debug_mark+2),a  
874c 18 03			jr .pastdmark  
874e ..			.dmark: db "AP4"  
8751 f1			.pastdmark: pop af  
8752			endm  
# End of macro DMARK
8752					CALLMONITOR 
8752 cd 2e 93			call break_point_state  
8755				endm  
# End of macro CALLMONITOR
8755				endif 
8755					; init the buffer with zeros so we can id if the buffer is full or not 
8755			 
8755 e5					push hl 
8756 c5					push bc 
8757			 
8757 21 eb ec				ld hl, store_page 
875a 06 40				ld b, STORE_BLOCK_PHY 
875c 3e 00				ld a, 0 
875e 77			.zeroblock:	ld (hl), a 
875f 23					inc hl 
8760 10 fc				djnz .zeroblock 
8762			 
8762 c1					pop bc 
8763 e1					pop hl 
8764			 
8764					; construct block 
8764			 
8764 3a e4 ec				ld a, (store_tmpid) 
8767 32 eb ec				ld (store_page), a   ; file id 
876a 3a e3 ec				ld a, (store_tmpext)   ; extent for this block 
876d 32 ec ec				ld (store_page+1), a 
8770			 
8770 e1					pop hl    ; get string to write 
8771 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8773 11 ed ec				ld de, store_page+2 
8776			 
8776				if DEBUG_STORESE 
8776					DMARK "AP5" 
8776 f5				push af  
8777 3a 8b 87			ld a, (.dmark)  
877a 32 c0 ee			ld (debug_mark),a  
877d 3a 8c 87			ld a, (.dmark+1)  
8780 32 c1 ee			ld (debug_mark+1),a  
8783 3a 8d 87			ld a, (.dmark+2)  
8786 32 c2 ee			ld (debug_mark+2),a  
8789 18 03			jr .pastdmark  
878b ..			.dmark: db "AP5"  
878e f1			.pastdmark: pop af  
878f			endm  
# End of macro DMARK
878f					CALLMONITOR 
878f cd 2e 93			call break_point_state  
8792				endm  
# End of macro CALLMONITOR
8792				endif 
8792			 
8792			 
8792			 
8792					; fill buffer with data until end of string or full block 
8792			 
8792 7e			.appd:		ld a, (hl) 
8793 12					ld (de), a 
8794 fe 00				cp 0 
8796 28 04				jr z, .appdone 
8798 23					inc hl 
8799 13					inc de 
879a 10 f6				djnz .appd 
879c			 
879c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
879d f5					push af   		; save last byte dumped 
879e			 
879e			 
879e 2a d5 ec			ld hl, (store_tmppageid) 
87a1 11 eb ec			ld de, store_page 
87a4				if DEBUG_STORESE 
87a4					DMARK "AP6" 
87a4 f5				push af  
87a5 3a b9 87			ld a, (.dmark)  
87a8 32 c0 ee			ld (debug_mark),a  
87ab 3a ba 87			ld a, (.dmark+1)  
87ae 32 c1 ee			ld (debug_mark+1),a  
87b1 3a bb 87			ld a, (.dmark+2)  
87b4 32 c2 ee			ld (debug_mark+2),a  
87b7 18 03			jr .pastdmark  
87b9 ..			.dmark: db "AP6"  
87bc f1			.pastdmark: pop af  
87bd			endm  
# End of macro DMARK
87bd					CALLMONITOR 
87bd cd 2e 93			call break_point_state  
87c0				endm  
# End of macro CALLMONITOR
87c0				endif 
87c0 cd 16 81				call storage_write_block 
87c3			 
87c3			 
87c3				; was that a full block of data written? 
87c3				; any more to write out? 
87c3			 
87c3				; if yes then set vars and jump to start of function again 
87c3			 
87c3 f1					pop af 
87c4 d1					pop de 
87c5			 
87c5 fe 00				cp 0		 ; no, string was fully written 
87c7 c8					ret z 
87c8			 
87c8					; setup vars for next cycle 
87c8			 
87c8 3a e4 ec				ld a, (store_tmpid) 
87cb 6f					ld l, a 
87cc 26 00				ld h, 0 
87ce			 
87ce c3 85 86			 	jp storage_append	 ; yes, need to write out some more 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			if DEBUG_STORECF 
87d1			storageput:	 
87d1					ret 
87d1			storageread: 
87d1					ld hl, store_page 
87d1					ld b, 200 
87d1					ld a,0 
87d1			.src:		ld (hl),a 
87d1					inc hl 
87d1					djnz .src 
87d1					 
87d1			 
87d1					ld de, 0 
87d1					ld bc, 1 
87d1					ld hl, store_page 
87d1					call cfRead 
87d1			 
87d1				call cfGetError 
87d1				ld hl,scratch 
87d1				call hexout 
87d1				ld hl, scratch+2 
87d1				ld a, 0 
87d1				ld (hl),a 
87d1				ld de, scratch 
87d1				ld a,display_row_1 
87d1				call str_at_display 
87d1				call update_display 
87d1			 
87d1					ld hl, store_page 
87d1					ld (os_cur_ptr),hl 
87d1			 
87d1					ret 
87d1			endif 
87d1			 
87d1			 
87d1			; Clear out the main buffer store (used to remove junk before writing a new block) 
87d1			 
87d1			storage_clear_page: 
87d1 e5				push hl 
87d2 d5				push de 
87d3 c5				push bc 
87d4 21 eb ec			ld hl, store_page 
87d7 3e 00			ld a, 0 
87d9 77				ld (hl), a 
87da			 
87da 11 ec ec			ld de, store_page+1 
87dd 01 40 00			ld bc, STORE_BLOCK_PHY 
87e0			 
87e0 ed b0			ldir 
87e2				 
87e2 c1				pop bc 
87e3 d1				pop de 
87e4 e1				pop hl 
87e5 c9				ret 
87e6			 
87e6			; eof 
# End of file firmware_storage.asm
87e6			  
87e6			; support routines for above hardware abstraction layer  
87e6			  
87e6			include "firmware_general.asm"        ; general support functions  
87e6			 
87e6			; word look up 
87e6			 
87e6			; in 
87e6			; a is the index 
87e6			; hl is pointer start of array 
87e6			; 
87e6			; returns 
87e6			; hl to the word 
87e6			; 
87e6			 
87e6			table_lookup:  
87e6 d5					push de 
87e7 eb					ex de, hl 
87e8			 
87e8 6f					ld l, a 
87e9 26 00				ld h, 0 
87eb 29					add hl, hl 
87ec 19					add hl, de 
87ed 7e					ld a, (hl) 
87ee 23					inc hl 
87ef 66					ld h,(hl) 
87f0 6f					ld l, a 
87f1			 
87f1 d1					pop de 
87f2 c9					ret 
87f3			 
87f3			; Delay loops 
87f3			 
87f3			 
87f3			 
87f3			aDelayInMS: 
87f3 c5				push bc 
87f4 47				ld b,a 
87f5			msdelay: 
87f5 c5				push bc 
87f6				 
87f6			 
87f6 01 41 00			ld bc,041h 
87f9 cd 11 88			call delayloop 
87fc c1				pop bc 
87fd 05				dec b 
87fe 20 f5			jr nz,msdelay 
8800			 
8800			;if CPU_CLOCK_8MHZ 
8800			;msdelay8: 
8800			;	push bc 
8800			;	 
8800			; 
8800			;	ld bc,041h 
8800			;	call delayloop 
8800			;	pop bc 
8800			;	dec b 
8800			;	jr nz,msdelay8 
8800			;endif 
8800			 
8800			 
8800 c1				pop bc 
8801 c9				ret 
8802			 
8802			 
8802			delay250ms: 
8802				;push de 
8802 01 00 40			ld bc, 04000h 
8805 c3 11 88			jp delayloop 
8808			delay500ms: 
8808				;push de 
8808 01 00 80			ld bc, 08000h 
880b c3 11 88			jp delayloop 
880e			delay1s: 
880e				;push bc 
880e			   ; Clobbers A, d and e 
880e 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
8811			delayloop: 
8811 c5			    push bc 
8812			 
8812			if BASE_CPM 
8812				ld bc, CPM_DELAY_TUNE 
8812			.cpmloop: 
8812				push bc 
8812			 
8812			endif 
8812			 
8812			 
8812			 
8812			delayloopi: 
8812			;	push bc 
8812			;.dl: 
8812 cb 47		    bit     0,a    	; 8 
8814 cb 47		    bit     0,a    	; 8 
8816 cb 47		    bit     0,a    	; 8 
8818 e6 ff		    and     255  	; 7 
881a 0b			    dec     bc      	; 6 
881b 79			    ld      a,c     	; 4 
881c b0			    or      b     	; 4 
881d c2 12 88		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8820			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8820				;pop de 
8820			;pop bc 
8820			 
8820			if BASE_CPM 
8820				pop bc 
8820				 
8820			    dec     bc      	; 6 
8820			    ld      a,c     	; 4 
8820			    or      b     	; 4 
8820			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8820				 
8820			 
8820			endif 
8820			;if CPU_CLOCK_8MHZ 
8820			;    pop bc 
8820			;    push bc 
8820			;.dl8: 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    and     255  	; 7 
8820			;    dec     bc      	; 6 
8820			;    ld      a,c     	; 4 
8820			;    or      b     	; 4 
8820			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8820			;endif 
8820			 
8820			;if CPU_CLOCK_10MHZ 
8820			;    pop bc 
8820			;    push bc 
8820			;.dl8: 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    and     255  	; 7 
8820			;    dec     bc      	; 6 
8820			;    ld      a,c     	; 4 
8820			;    or      b     	; 4 
8820			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8820			;endif 
8820 c1			    pop bc 
8821			 
8821 c9				ret 
8822			 
8822			 
8822			 
8822			; eof 
# End of file firmware_general.asm
8822			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8822			; display routines that use the physical hardware abstraction layer 
8822			 
8822			 
8822			; information window 
8822			 
8822			; pass hl with 1st string to display 
8822			; pass de with 2nd string to display 
8822			 
8822			info_panel: 
8822 e5				push hl 
8823			 
8823 2a 61 ed			ld hl, (display_fb_active) 
8826 e5				push hl    ; future de destination 
8827 21 56 ee				ld hl, display_fb0 
882a 22 61 ed				ld (display_fb_active), hl 
882d			 
882d cd 8e 88			call clear_display 
8830			 
8830			 
8830 3e 2d			ld a, display_row_3 + 5 
8832 cd a1 88			call str_at_display 
8835			 
8835 e1				pop hl 
8836 d1				pop de 
8837			 
8837 e5				push hl 
8838			 
8838			 
8838 3e 19			ld a, display_row_2 + 5 
883a cd a1 88			call str_at_display 
883d			 
883d			 
883d cd b1 88			call update_display 
8840 cd 33 98			call next_page_prompt 
8843 cd 8e 88			call clear_display 
8846			 
8846				 
8846 21 05 ee				ld hl, display_fb1 
8849 22 61 ed				ld (display_fb_active), hl 
884c cd b1 88			call update_display 
884f			 
884f			 
884f c9				ret 
8850			 
8850			 
8850			 
8850			 
8850			; TODO windowing? 
8850			 
8850			; TODO scroll line up 
8850			 
8850			scroll_up: 
8850			 
8850 e5				push hl 
8851 d5				push de 
8852 c5				push bc 
8853			 
8853				; get frame buffer  
8853			 
8853 2a 61 ed			ld hl, (display_fb_active) 
8856 e5				push hl    ; future de destination 
8857			 
8857 11 14 00			ld  de, display_cols 
885a 19				add hl, de 
885b			 
885b d1				pop de 
885c			 
885c				;ex de, hl 
885c 01 4f 00			ld bc, display_fb_len -1  
885f			;if DEBUG_FORTH_WORDS 
885f			;	DMARK "SCL" 
885f			;	CALLMONITOR 
885f			;endif	 
885f ed b0			ldir 
8861			 
8861				; wipe bottom row 
8861			 
8861			 
8861 2a 61 ed			ld hl, (display_fb_active) 
8864 11 50 00			ld de, display_cols*display_rows 
8867 19				add hl, de 
8868 06 14			ld b, display_cols 
886a 3e 20			ld a, ' ' 
886c			.scwipe: 
886c 77				ld (hl), a 
886d 2b				dec hl 
886e 10 fc			djnz .scwipe 
8870			 
8870				;pop hl 
8870			 
8870 c1				pop bc 
8871 d1				pop de 
8872 e1				pop hl 
8873			 
8873 c9				ret 
8874			 
8874			 
8874			;scroll_upo: 
8874			;	ld de, display_row_1 
8874			 ;	ld hl, display_row_2 
8874			;	ld bc, display_cols 
8874			;	ldir 
8874			;	ld de, display_row_2 
8874			 ;	ld hl, display_row_3 
8874			;	ld bc, display_cols 
8874			;	ldir 
8874			;	ld de, display_row_3 
8874			 ;	ld hl, display_row_4 
8874			;	ld bc, display_cols 
8874			;	ldir 
8874			 
8874			; TODO clear row 4 
8874			 
8874			;	ret 
8874			 
8874				 
8874			scroll_down: 
8874			 
8874 e5				push hl 
8875 d5				push de 
8876 c5				push bc 
8877			 
8877				; get frame buffer  
8877			 
8877 2a 61 ed			ld hl, (display_fb_active) 
887a			 
887a 11 4f 00			ld de, display_fb_len - 1 
887d 19				add hl, de 
887e			 
887e e5			push hl    ; future de destination 
887f			 
887f 11 14 00			ld  de, display_cols 
8882 ed 52			sbc hl, de 
8884			 
8884			 
8884 d1				pop de 
8885			 
8885			;	ex de, hl 
8885 01 4f 00			ld bc, display_fb_len -1  
8888			 
8888			 
8888				 
8888			 
8888 ed b0			ldir 
888a			 
888a				; wipe bottom row 
888a			 
888a			 
888a			;	ld hl, (display_fb_active) 
888a			;;	ld de, display_cols*display_rows 
888a			;;	add hl, de 
888a			;	ld b, display_cols 
888a			;	ld a, ' ' 
888a			;.scwiped: 
888a			;	ld (hl), a 
888a			;	dec hl 
888a			;	djnz .scwiped 
888a			 
888a				;pop hl 
888a			 
888a c1				pop bc 
888b d1				pop de 
888c e1				pop hl 
888d			 
888d c9				ret 
888e			;scroll_down: 
888e			;	ld de, display_row_4 
888e			;	ld hl, display_row_3 
888e			;	ld bc, display_cols 
888e			;	ldir 
888e			;	ld de, display_row_3 
888e			; 	ld hl, display_row_2 
888e			;	ld bc, display_cols 
888e			;	ldir 
888e			;	ld de, display_row_2 
888e			;	ld hl, display_row_1 
888e			;	ld bc, display_cols 
888e			;	ldir 
888e			;;; TODO clear row 1 
888e			;	ret 
888e			 
888e			 
888e			 
888e			 
888e			 
888e			; clear active frame buffer 
888e			 
888e			clear_display: 
888e 3e 20			ld a, ' ' 
8890 c3 93 88			jp fill_display 
8893			 
8893			; fill active frame buffer with a char in A 
8893			 
8893			fill_display: 
8893 06 50			ld b,display_fb_len 
8895 2a 61 ed			ld hl, (display_fb_active) 
8898 77			.fd1:	ld (hl),a 
8899 23				inc hl 
889a 10 fc			djnz .fd1 
889c 23				inc hl 
889d 3e 00			ld a,0 
889f 77				ld (hl),a 
88a0			 
88a0			 
88a0 c9				ret 
88a1			; Write string (DE) at pos (A) to active frame buffer 
88a1			 
88a1 2a 61 ed		str_at_display:    ld hl,(display_fb_active) 
88a4 06 00					ld b,0 
88a6 4f					ld c,a 
88a7 09					add hl,bc 
88a8 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
88a9 b7			            OR   A              ;Null terminator? 
88aa c8			            RET  Z              ;Yes, so finished 
88ab 77					ld (hl),a 
88ac 23				inc hl 
88ad 13			            INC  DE             ;Point to next character 
88ae 18 f8		            JR   .sad1     ;Repeat 
88b0 c9					ret 
88b1			 
88b1			; using current frame buffer write to physical display 
88b1			 
88b1			update_display: 
88b1 e5				push hl 
88b2 2a 61 ed			ld hl, (display_fb_active) 
88b5 cd d4 d6			call write_display 
88b8 e1				pop hl 
88b9 c9				ret 
88ba			 
88ba			; TODO scrolling 
88ba			 
88ba			 
88ba			; move cursor right one char 
88ba			cursor_right: 
88ba			 
88ba				; TODO shift right 
88ba				; TODO if beyond max col 
88ba				; TODO       cursor_next_line 
88ba			 
88ba c9				ret 
88bb			 
88bb			 
88bb			cursor_next_line: 
88bb				; TODO first char 
88bb				; TODO line down 
88bb				; TODO if past last row 
88bb				; TODO    scroll up 
88bb			 
88bb c9				ret 
88bc			 
88bc			cursor_left: 
88bc				; TODO shift left 
88bc				; TODO if beyond left  
88bc				; TODO     cursor prev line 
88bc				 
88bc c9				ret 
88bd			 
88bd			cursor_prev_line: 
88bd				; TODO last char 
88bd				; TODO line up 
88bd				; TODO if past first row 
88bd				; TODO   scroll down 
88bd			 
88bd c9				ret 
88be			 
88be			 
88be			cout: 
88be				; A - char 
88be c9				ret 
88bf			 
88bf			 
88bf			; Display a menu and allow item selection (optional toggle items) 
88bf			; 
88bf			; format: 
88bf			; hl pointer to word array with zero term for items 
88bf			; e.g.    db item1 
88bf			;         db .... 
88bf			;         db 0 
88bf			; 
88bf			; a = starting menu item  
88bf			; 
88bf			; de = pointer item toggle array   (todo) 
88bf			; 
88bf			; returns item selected in a 1-... 
88bf			; returns 0 if back button pressed 
88bf			; 
88bf			; NOTE: Uses system frame buffer to display 
88bf			; 
88bf			; LEFT, Q = go back 
88bf			; RIGHT, SPACE, CR = select 
88bf			; UP, A - Up 
88bf			; DOWN, Z - Down 
88bf			 
88bf			 
88bf			 
88bf			 
88bf			 
88bf			menu: 
88bf			 
88bf					; keep array pointer 
88bf			 
88bf 22 e9 ec				ld (store_tmp1), hl 
88c2 32 e7 ec				ld (store_tmp2), a 
88c5			 
88c5					; check for key bounce 
88c5			 
88c5			if BASE_KEV 
88c5			 
88c5			.mbounce:	call cin 
88c5					cp 0 
88c5					jr nz, .mbounce 
88c5			endif 
88c5					; for ease use ex 
88c5			 
88c5					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
88c5 21 56 ee				ld hl, display_fb0 
88c8 22 61 ed				ld (display_fb_active), hl 
88cb			 
88cb cd 8e 88		.mloop:		call clear_display 
88ce cd b1 88				call update_display 
88d1			 
88d1					; draw selection id '>' at 1 
88d1			 
88d1					; init start of list display 
88d1			 
88d1 3e 05				ld a, 5 
88d3 32 e5 ec				ld (store_tmp3), a   ; display row count 
88d6 3a e7 ec				ld a,( store_tmp2) 
88d9 32 e8 ec				ld (store_tmp2+1), a   ; display item count 
88dc			 
88dc					 
88dc			.mitem:	 
88dc			 
88dc			 
88dc 3a e8 ec				ld a,(store_tmp2+1) 
88df 6f					ld l, a 
88e0 26 00				ld h, 0 
88e2 29					add hl, hl 
88e3 ed 5b e9 ec			ld de, (store_tmp1) 
88e7 19					add hl, de 
88e8 7e					ld a, (hl) 
88e9 23					inc hl 
88ea 66					ld h,(hl) 
88eb 6f					ld l, a 
88ec			 
88ec cd e4 8a				call ishlzero 
88ef 28 1a				jr z, .mdone 
88f1			 
88f1 eb					ex de, hl 
88f2 3a e5 ec				ld a, (store_tmp3) 
88f5 cd a1 88				call str_at_display 
88f8					 
88f8			 
88f8					; next item 
88f8 3a e8 ec				ld a, (store_tmp2+1) 
88fb 3c					inc a 
88fc 32 e8 ec				ld (store_tmp2+1), a   ; display item count 
88ff			 
88ff			 		; next row 
88ff			 
88ff 3a e5 ec				ld a, (store_tmp3) 
8902 c6 14				add display_cols 
8904 32 e5 ec				ld (store_tmp3), a 
8907			 
8907					; at end of screen? 
8907			 
8907 fe 10				cp display_rows*4 
8909 20 d1				jr nz, .mitem 
890b			 
890b			 
890b			.mdone: 
890b cd e4 8a				call ishlzero 
890e 28 08				jr z, .nodn 
8910			 
8910 3e 3c				ld a, display_row_4 
8912 11 91 89				ld de, .mdown 
8915 cd a1 88				call str_at_display 
8918			 
8918					; draw options to fill the screens with active item on line 1 
8918					; if current option is 2 or more then display ^ in top 
8918			 
8918 3a e7 ec		.nodn:		ld a, (store_tmp2) 
891b fe 00				cp 0 
891d 28 08				jr z, .noup 
891f			 
891f 3e 00				ld a, 0 
8921 11 8f 89				ld de, .mup 
8924 cd a1 88				call str_at_display 
8927			 
8927 3e 02		.noup:		ld a, 2 
8929 11 8d 89				ld de, .msel 
892c cd a1 88				call str_at_display 
892f			 
892f					; if current option + 1 is not null then display V in bottom 
892f					; get key 
892f cd b1 88				call update_display 
8932			 
8932			 
8932					; handle key 
8932			 
8932 cd 60 d7				call cin_wait 
8935			 
8935 fe 05				cp KEY_UP 
8937 28 2b				jr z, .mgoup 
8939 fe 61				cp 'a' 
893b 28 27				jr z, .mgoup 
893d fe 0a				cp KEY_DOWN 
893f 28 32				jr z, .mgod 
8941 fe 7a				cp 'z' 
8943 28 2e				jr z, .mgod 
8945 fe 20				cp ' ' 
8947 28 34				jr z, .goend 
8949 fe 0c				cp KEY_RIGHT 
894b 28 30				jr z, .goend 
894d fe 0d				cp KEY_CR 
894f 28 2c				jr z, .goend 
8951 fe 71				cp 'q' 
8953 28 0b				jr z, .goback 
8955			 
8955 fe 0b				cp KEY_LEFT 
8957 28 07				jr z, .goback 
8959 fe 08				cp KEY_BS 
895b 28 03				jr z, .goback 
895d c3 cb 88				jp .mloop 
8960			 
8960			.goback: 
8960 3e 00			ld a, 0 
8962 18 1d			jr .goend2 
8964			 
8964				; move up one 
8964			.mgoup: 
8964 3a e7 ec				ld a, (store_tmp2) 
8967 fe 00				cp 0 
8969 ca cb 88				jp z, .mloop 
896c 3d					dec a 
896d 32 e7 ec				ld (store_tmp2), a 
8970 c3 cb 88				jp .mloop 
8973			 
8973				; move down one 
8973			.mgod: 
8973 3a e7 ec				ld a, (store_tmp2) 
8976 3c					inc a 
8977 32 e7 ec				ld (store_tmp2), a 
897a c3 cb 88				jp .mloop 
897d			 
897d			 
897d			.goend: 
897d					; get selected item number 
897d			 
897d 3a e7 ec				ld a, (store_tmp2) 
8980 3c					inc a 
8981			 
8981			.goend2: 
8981 f5					push af 
8982			 
8982					; restore active fb 
8982					; TODO BUG assumes fb1 
8982			 
8982 21 05 ee				ld hl, display_fb1 
8985 22 61 ed				ld (display_fb_active), hl 
8988			 
8988					; restore main regs 
8988			 
8988			 
8988 cd b1 88				call update_display 
898b			 
898b f1					pop af 
898c			 
898c c9				ret 
898d			 
898d .. 00		.msel:   db ">",0 
898f .. 00		.mup:   db "^",0 
8991 .. 00		.mdown:   db "v",0 
8993			 
8993			 
8993			; eof 
8993			 
# End of file firmware_display.asm
8993			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8993			; random number generators 
8993			 
8993			 
8993			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8993			 
8993			 
8993			;-----> Generate a random number 
8993			; output a=answer 0<=a<=255 
8993			; all registers are preserved except: af 
8993			random: 
8993 e5			        push    hl 
8994 d5			        push    de 
8995 2a 43 ed		        ld      hl,(randData) 
8998 ed 5f		        ld      a,r 
899a 57			        ld      d,a 
899b 5e			        ld      e,(hl) 
899c 19			        add     hl,de 
899d 85			        add     a,l 
899e ac			        xor     h 
899f 22 43 ed		        ld      (randData),hl 
89a2 d1			        pop     de 
89a3 e1			        pop     hl 
89a4 c9			        ret 
89a5			 
89a5			 
89a5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
89a5			 
89a5			 
89a5			 
89a5			;------LFSR------ 
89a5			;James Montelongo 
89a5			;optimized by Spencer Putt 
89a5			;out: 
89a5			; a = 8 bit random number 
89a5			RandLFSR: 
89a5 21 49 ed		        ld hl,LFSRSeed+4 
89a8 5e			        ld e,(hl) 
89a9 23			        inc hl 
89aa 56			        ld d,(hl) 
89ab 23			        inc hl 
89ac 4e			        ld c,(hl) 
89ad 23			        inc hl 
89ae 7e			        ld a,(hl) 
89af 47			        ld b,a 
89b0 cb 13		        rl e  
89b2 cb 12			rl d 
89b4 cb 11		        rl c  
89b6 17				rla 
89b7 cb 13		        rl e  
89b9 cb 12			rl d 
89bb cb 11		        rl c  
89bd 17				rla 
89be cb 13		        rl e  
89c0 cb 12			rl d 
89c2 cb 11		        rl c  
89c4 17				rla 
89c5 67			        ld h,a 
89c6 cb 13		        rl e  
89c8 cb 12			rl d 
89ca cb 11		        rl c  
89cc 17				rla 
89cd a8			        xor b 
89ce cb 13		        rl e  
89d0 cb 12			rl d 
89d2 ac			        xor h 
89d3 a9			        xor c 
89d4 aa			        xor d 
89d5 21 4b ed		        ld hl,LFSRSeed+6 
89d8 11 4c ed		        ld de,LFSRSeed+7 
89db 01 07 00		        ld bc,7 
89de ed b8		        lddr 
89e0 12			        ld (de),a 
89e1 c9			        ret 
89e2			 
89e2			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
89e2			 
89e2			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
89e2			 
89e2			 
89e2			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
89e2			 
89e2			prng16: 
89e2			;Inputs: 
89e2			;   (seed1) contains a 16-bit seed value 
89e2			;   (seed2) contains a NON-ZERO 16-bit seed value 
89e2			;Outputs: 
89e2			;   HL is the result 
89e2			;   BC is the result of the LCG, so not that great of quality 
89e2			;   DE is preserved 
89e2			;Destroys: 
89e2			;   AF 
89e2			;cycle: 4,294,901,760 (almost 4.3 billion) 
89e2			;160cc 
89e2			;26 bytes 
89e2 2a 3d ed		    ld hl,(seed1) 
89e5 44			    ld b,h 
89e6 4d			    ld c,l 
89e7 29			    add hl,hl 
89e8 29			    add hl,hl 
89e9 2c			    inc l 
89ea 09			    add hl,bc 
89eb 22 3d ed		    ld (seed1),hl 
89ee 2a 3b ed		    ld hl,(seed2) 
89f1 29			    add hl,hl 
89f2 9f			    sbc a,a 
89f3 e6 2d		    and %00101101 
89f5 ad			    xor l 
89f6 6f			    ld l,a 
89f7 22 3b ed		    ld (seed2),hl 
89fa 09			    add hl,bc 
89fb c9			    ret 
89fc			 
89fc			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
89fc			 
89fc			rand32: 
89fc			;Inputs: 
89fc			;   (seed1_0) holds the lower 16 bits of the first seed 
89fc			;   (seed1_1) holds the upper 16 bits of the first seed 
89fc			;   (seed2_0) holds the lower 16 bits of the second seed 
89fc			;   (seed2_1) holds the upper 16 bits of the second seed 
89fc			;   **NOTE: seed2 must be non-zero 
89fc			;Outputs: 
89fc			;   HL is the result 
89fc			;   BC,DE can be used as lower quality values, but are not independent of HL. 
89fc			;Destroys: 
89fc			;   AF 
89fc			;Tested and passes all CAcert tests 
89fc			;Uses a very simple 32-bit LCG and 32-bit LFSR 
89fc			;it has a period of 18,446,744,069,414,584,320 
89fc			;roughly 18.4 quintillion. 
89fc			;LFSR taps: 0,2,6,7  = 11000101 
89fc			;291cc 
89fc			;seed1_0=$+1 
89fc			;    ld hl,12345 
89fc			;seed1_1=$+1 
89fc			;    ld de,6789 
89fc			;    ld b,h 
89fc			;    ld c,l 
89fc			;    add hl,hl \ rl e \ rl d 
89fc			;    add hl,hl \ rl e \ rl d 
89fc			;    inc l 
89fc			;    add hl,bc 
89fc			;    ld (seed1_0),hl 
89fc			;    ld hl,(seed1_1) 
89fc			;    adc hl,de 
89fc			;    ld (seed1_1),hl 
89fc			;    ex de,hl 
89fc			;seed2_0=$+1 
89fc			;    ld hl,9876 
89fc			;seed2_1=$+1 
89fc			;    ld bc,54321 
89fc			;    add hl,hl \ rl c \ rl b 
89fc			;    ld (seed2_1),bc 
89fc			;    sbc a,a 
89fc			;    and %11000101 
89fc			;    xor l 
89fc			;    ld l,a 
89fc			;    ld (seed2_0),hl 
89fc			;    ex de,hl 
89fc			;    add hl,bc 
89fc			;    ret 
89fc			; 
89fc			 
89fc			; 16-bit xorshift pseudorandom number generator by John Metcalf 
89fc			; 20 bytes, 86 cycles (excluding ret) 
89fc			 
89fc			; returns   hl = pseudorandom number 
89fc			; corrupts   a 
89fc			 
89fc			; generates 16-bit pseudorandom numbers with a period of 65535 
89fc			; using the xorshift method: 
89fc			 
89fc			; hl ^= hl << 7 
89fc			; hl ^= hl >> 9 
89fc			; hl ^= hl << 8 
89fc			 
89fc			; some alternative shift triplets which also perform well are: 
89fc			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
89fc			 
89fc			;  org 32768 
89fc			 
89fc			xrnd: 
89fc 2a 41 ed		  ld hl,(xrandc)       ; seed must not be 0 
89ff 3e 00		  ld a,0 
8a01 bd			  cp l 
8a02 20 02		  jr nz, .xrnd1 
8a04 2e 01		  ld l, 1 
8a06			.xrnd1: 
8a06			 
8a06 7c			  ld a,h 
8a07 1f			  rra 
8a08 7d			  ld a,l 
8a09 1f			  rra 
8a0a ac			  xor h 
8a0b 67			  ld h,a 
8a0c 7d			  ld a,l 
8a0d 1f			  rra 
8a0e 7c			  ld a,h 
8a0f 1f			  rra 
8a10 ad			  xor l 
8a11 6f			  ld l,a 
8a12 ac			  xor h 
8a13 67			  ld h,a 
8a14			 
8a14 22 41 ed		  ld (xrandc),hl 
8a17			 
8a17 c9			  ret 
8a18			;  
8a18			 
8a18			 
8a18			;;;; int maths 
8a18			 
8a18			; https://map.grauw.nl/articles/mult_div_shifts.php 
8a18			; Divide 16-bit values (with 16-bit result) 
8a18			; In: Divide BC by divider DE 
8a18			; Out: BC = result, HL = rest 
8a18			; 
8a18			Div16: 
8a18 21 00 00		    ld hl,0 
8a1b 78			    ld a,b 
8a1c 06 08		    ld b,8 
8a1e			Div16_Loop1: 
8a1e 17			    rla 
8a1f ed 6a		    adc hl,hl 
8a21 ed 52		    sbc hl,de 
8a23 30 01		    jr nc,Div16_NoAdd1 
8a25 19			    add hl,de 
8a26			Div16_NoAdd1: 
8a26 10 f6		    djnz Div16_Loop1 
8a28 17			    rla 
8a29 2f			    cpl 
8a2a 47			    ld b,a 
8a2b 79			    ld a,c 
8a2c 48			    ld c,b 
8a2d 06 08		    ld b,8 
8a2f			Div16_Loop2: 
8a2f 17			    rla 
8a30 ed 6a		    adc hl,hl 
8a32 ed 52		    sbc hl,de 
8a34 30 01		    jr nc,Div16_NoAdd2 
8a36 19			    add hl,de 
8a37			Div16_NoAdd2: 
8a37 10 f6		    djnz Div16_Loop2 
8a39 17			    rla 
8a3a 2f			    cpl 
8a3b 41			    ld b,c 
8a3c 4f			    ld c,a 
8a3d c9			ret 
8a3e			 
8a3e			 
8a3e			;http://z80-heaven.wikidot.com/math 
8a3e			; 
8a3e			;Inputs: 
8a3e			;     DE and A are factors 
8a3e			;Outputs: 
8a3e			;     A is not changed 
8a3e			;     B is 0 
8a3e			;     C is not changed 
8a3e			;     DE is not changed 
8a3e			;     HL is the product 
8a3e			;Time: 
8a3e			;     342+6x 
8a3e			; 
8a3e			Mult16: 
8a3e			 
8a3e 06 08		     ld b,8          ;7           7 
8a40 21 00 00		     ld hl,0         ;10         10 
8a43 29			       add hl,hl     ;11*8       88 
8a44 07			       rlca          ;4*8        32 
8a45 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8a47 19			         add hl,de   ;--         -- 
8a48 10 f9		       djnz $-5      ;13*7+8     99 
8a4a c9			ret 
8a4b			 
8a4b			; 
8a4b			; Square root of 16-bit value 
8a4b			; In:  HL = value 
8a4b			; Out:  D = result (rounded down) 
8a4b			; 
8a4b			;Sqr16: 
8a4b			;    ld de,#0040 
8a4b			;    ld a,l 
8a4b			;    ld l,h 
8a4b			;    ld h,d 
8a4b			;    or a 
8a4b			;    ld b,8 
8a4b			;Sqr16_Loop: 
8a4b			;    sbc hl,de 
8a4b			;    jr nc,Sqr16_Skip 
8a4b			;    add hl,de 
8a4b			;Sqr16_Skip: 
8a4b			;    ccf 
8a4b			;    rl d 
8a4b			;    add a,a 
8a4b			;    adc hl,hl 
8a4b			;    add a,a 
8a4b			;    adc hl,hl 
8a4b			;    djnz Sqr16_Loop 
8a4b			;    ret 
8a4b			; 
8a4b			; 
8a4b			; Divide 8-bit values 
8a4b			; In: Divide E by divider C 
8a4b			; Out: A = result, B = rest 
8a4b			; 
8a4b			Div8: 
8a4b af			    xor a 
8a4c 06 08		    ld b,8 
8a4e			Div8_Loop: 
8a4e cb 13		    rl e 
8a50 17			    rla 
8a51 91			    sub c 
8a52 30 01		    jr nc,Div8_NoAdd 
8a54 81			    add a,c 
8a55			Div8_NoAdd: 
8a55 10 f7		    djnz Div8_Loop 
8a57 47			    ld b,a 
8a58 7b			    ld a,e 
8a59 17			    rla 
8a5a 2f			    cpl 
8a5b c9			    ret 
8a5c			 
8a5c			; 
8a5c			; Multiply 8-bit value with a 16-bit value (unrolled) 
8a5c			; In: Multiply A with DE 
8a5c			; Out: HL = result 
8a5c			; 
8a5c			Mult12U: 
8a5c 2e 00		    ld l,0 
8a5e 87			    add a,a 
8a5f 30 01		    jr nc,Mult12U_NoAdd0 
8a61 19			    add hl,de 
8a62			Mult12U_NoAdd0: 
8a62 29			    add hl,hl 
8a63 87			    add a,a 
8a64 30 01		    jr nc,Mult12U_NoAdd1 
8a66 19			    add hl,de 
8a67			Mult12U_NoAdd1: 
8a67 29			    add hl,hl 
8a68 87			    add a,a 
8a69 30 01		    jr nc,Mult12U_NoAdd2 
8a6b 19			    add hl,de 
8a6c			Mult12U_NoAdd2: 
8a6c 29			    add hl,hl 
8a6d 87			    add a,a 
8a6e 30 01		    jr nc,Mult12U_NoAdd3 
8a70 19			    add hl,de 
8a71			Mult12U_NoAdd3: 
8a71 29			    add hl,hl 
8a72 87			    add a,a 
8a73 30 01		    jr nc,Mult12U_NoAdd4 
8a75 19			    add hl,de 
8a76			Mult12U_NoAdd4: 
8a76 29			    add hl,hl 
8a77 87			    add a,a 
8a78 30 01		    jr nc,Mult12U_NoAdd5 
8a7a 19			    add hl,de 
8a7b			Mult12U_NoAdd5: 
8a7b 29			    add hl,hl 
8a7c 87			    add a,a 
8a7d 30 01		    jr nc,Mult12U_NoAdd6 
8a7f 19			    add hl,de 
8a80			Mult12U_NoAdd6: 
8a80 29			    add hl,hl 
8a81 87			    add a,a 
8a82 d0			    ret nc 
8a83 19			    add hl,de 
8a84 c9			    ret 
8a85			 
8a85			; 
8a85			; Multiply 8-bit value with a 16-bit value (right rotating) 
8a85			; In: Multiply A with DE 
8a85			;      Put lowest value in A for most efficient calculation 
8a85			; Out: HL = result 
8a85			; 
8a85			Mult12R: 
8a85 21 00 00		    ld hl,0 
8a88			Mult12R_Loop: 
8a88 cb 3f		    srl a 
8a8a 30 01		    jr nc,Mult12R_NoAdd 
8a8c 19			    add hl,de 
8a8d			Mult12R_NoAdd: 
8a8d cb 23		    sla e 
8a8f cb 12		    rl d 
8a91 b7			    or a 
8a92 c2 88 8a		    jp nz,Mult12R_Loop 
8a95 c9			    ret 
8a96			 
8a96			; 
8a96			; Multiply 16-bit values (with 32-bit result) 
8a96			; In: Multiply BC with DE 
8a96			; Out: BCHL = result 
8a96			; 
8a96			Mult32: 
8a96 79			    ld a,c 
8a97 48			    ld c,b 
8a98 21 00 00		    ld hl,0 
8a9b 06 10		    ld b,16 
8a9d			Mult32_Loop: 
8a9d 29			    add hl,hl 
8a9e 17			    rla 
8a9f cb 11		    rl c 
8aa1 30 07		    jr nc,Mult32_NoAdd 
8aa3 19			    add hl,de 
8aa4 ce 00		    adc a,0 
8aa6 d2 aa 8a		    jp nc,Mult32_NoAdd 
8aa9 0c			    inc c 
8aaa			Mult32_NoAdd: 
8aaa 10 f1		    djnz Mult32_Loop 
8aac 41			    ld b,c 
8aad 4f			    ld c,a 
8aae c9			    ret 
8aaf			 
8aaf			 
8aaf			 
8aaf			; 
8aaf			; Multiply 8-bit values 
8aaf			; In:  Multiply H with E 
8aaf			; Out: HL = result 
8aaf			; 
8aaf			Mult8: 
8aaf 16 00		    ld d,0 
8ab1 6a			    ld l,d 
8ab2 06 08		    ld b,8 
8ab4			Mult8_Loop: 
8ab4 29			    add hl,hl 
8ab5 30 01		    jr nc,Mult8_NoAdd 
8ab7 19			    add hl,de 
8ab8			Mult8_NoAdd: 
8ab8 10 fa		    djnz Mult8_Loop 
8aba c9			    ret 
8abb			 
8abb			 
8abb			 
8abb			 
8abb			 
8abb			 
8abb			 
8abb			 
8abb			;;http://z80-heaven.wikidot.com/math 
8abb			;;This divides DE by BC, storing the result in DE, remainder in HL 
8abb			; 
8abb			;DE_Div_BC:          ;1281-2x, x is at most 16 
8abb			;     ld a,16        ;7 
8abb			;     ld hl,0        ;10 
8abb			;     jp $+5         ;10 
8abb			;.DivLoop: 
8abb			;       add hl,bc    ;-- 
8abb			;       dec a        ;64 
8abb			;       jr z,.DivLoopEnd        ;86 
8abb			; 
8abb			;       sla e        ;128 
8abb			;       rl d         ;128 
8abb			;       adc hl,hl    ;240 
8abb			;       sbc hl,bc    ;240 
8abb			;       jr nc,.DivLoop ;23|21 
8abb			;       inc e        ;-- 
8abb			;       jp .DivLoop+1 
8abb			; 
8abb			;.DivLoopEnd: 
8abb			 
8abb			;HL_Div_C: 
8abb			;Inputs: 
8abb			;     HL is the numerator 
8abb			;     C is the denominator 
8abb			;Outputs: 
8abb			;     A is the remainder 
8abb			;     B is 0 
8abb			;     C is not changed 
8abb			;     DE is not changed 
8abb			;     HL is the quotient 
8abb			; 
8abb			;       ld b,16 
8abb			;       xor a 
8abb			;         add hl,hl 
8abb			;         rla 
8abb			;         cp c 
8abb			;         jr c,$+4 
8abb			;           inc l 
8abb			;           sub c 
8abb			;         djnz $-7 
8abb			 
8abb			; https://plutiedev.com/z80-add-8bit-to-16bit 
8abb			 
8abb			addatohl: 
8abb 85			    add   a, l    ; A = A+L 
8abc 6f			    ld    l, a    ; L = A+L 
8abd 8c			    adc   a, h    ; A = A+L+H+carry 
8abe 95			    sub   l       ; A = H+carry 
8abf 67			    ld    h, a    ; H = H+carry 
8ac0 c9			ret 
8ac1			 
8ac1			addatode: 
8ac1 83			    add   a, e    ; A = A+L 
8ac2 5f			    ld    e, a    ; L = A+L 
8ac3 8a			    adc   a, d    ; A = A+L+H+carry 
8ac4 93			    sub   e       ; A = H+carry 
8ac5 57			    ld    d, a    ; H = H+carry 
8ac6 c9			ret 
8ac7			 
8ac7			 
8ac7			addatobc: 
8ac7 81			    add   a, c    ; A = A+L 
8ac8 4f			    ld    c, a    ; L = A+L 
8ac9 88			    adc   a, b    ; A = A+L+H+carry 
8aca 91			    sub   c       ; A = H+carry 
8acb 47			    ld    b, a    ; H = H+carry 
8acc c9			ret 
8acd			 
8acd			subafromhl: 
8acd			   ; If A=0 do nothing 
8acd			    ; Otherwise flip A's sign. Since 
8acd			    ; the upper byte becomes -1, also 
8acd			    ; substract 1 from H. 
8acd ed 44		    neg 
8acf ca d8 8a		    jp    z, Skip 
8ad2 25			    dec   h 
8ad3			     
8ad3			    ; Now add the low byte as usual 
8ad3			    ; Two's complement takes care of 
8ad3			    ; ensuring the result is correct 
8ad3 85			    add   a, l 
8ad4 6f			    ld    l, a 
8ad5 8c			    adc   a, h 
8ad6 95			    sub   l 
8ad7 67			    ld    h, a 
8ad8			Skip: 
8ad8 c9				ret 
8ad9			 
8ad9			 
8ad9			; compare hl and de 
8ad9			; returns:  
8ad9			; if hl = de, z=1, s=0, c0=0 
8ad9			; if hl > de, z=0, s=0, c=0 
8ad9			; if hl < de, z=0, s=1, c=1 
8ad9			cmp16:	 
8ad9 b7				or a 
8ada ed 52			sbc hl,de 
8adc e0				ret po 
8add 7c				ld a,h 
8ade 1f				rra 
8adf ee 40			xor 01000000B 
8ae1 37				scf 
8ae2 8f				adc a,a 
8ae3 c9				ret 
8ae4			 
8ae4			 
8ae4			; test if hl contains zero   - A is destroyed 
8ae4			 
8ae4			ishlzero:    
8ae4 b7				or a     ; reset flags 
8ae5 7c				ld a, h 
8ae6 b5				or l        	 
8ae7			 
8ae7 c9				ret 
8ae8			 
8ae8			 
8ae8			 
8ae8			 
8ae8			if FORTH_ENABLE_FLOATMATH 
8ae8			;include "float/bbcmath.z80" 
8ae8			include "float/lpfpcalc.asm" 
8ae8			endif 
8ae8			 
8ae8			 
8ae8			; eof 
8ae8			 
# End of file firmware_maths.asm
8ae8			include "firmware_strings.asm"   ; string handling  
8ae8			 
8ae8			 
8ae8			; TODO string len 
8ae8			; input text string, end on cr with zero term 
8ae8			; a offset into frame buffer to start prompt 
8ae8			; d is max length 
8ae8			; e is display size TODO 
8ae8			; c is current cursor position 
8ae8			; hl is ptr to where string will be stored 
8ae8			 
8ae8			 
8ae8			; TODO check limit of buffer for new inserts 
8ae8			; TODO check insert does not push beyond buffer 
8ae8			; TODO scroll in a limited display area 
8ae8			; TODO scroll whole screen on page wrap 
8ae8			 
8ae8			 
8ae8			; TODO handle KEY_PREVWORD 
8ae8			; TODO handle KEY_NEXTWORD 
8ae8			; TODO handle KEY_HOME 
8ae8			; TODO handle KEY_END 
8ae8			; TODO use LCD cursor? 
8ae8			 
8ae8 32 b9 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8aeb 81					add c 
8aec 32 b7 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8aef 22 bc ee				ld (input_start), hl     ; save ptr to buffer 
8af2 79					ld a, c 
8af3 cd bb 8a				call addatohl 
8af6 22 be ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8af9 7a					ld a,d 
8afa 32 bb ee			        ld (input_size), a       ; save length of input area 
8afd 79					ld a, c 
8afe 32 aa ee				ld (input_cursor),a      ; init cursor start position  
8b01 7b					ld a,e 
8b02 32 ba ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8b05					 
8b05					 
8b05			 
8b05			;		ld a,(input_ptr) 
8b05			;		ld (input_under_cursor),a 	; save what is under the cursor 
8b05			 
8b05			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8b05					; init cursor shape if not set by the cin routines 
8b05 21 59 ed				ld hl, cursor_shape 
8b08 3e ff				ld a, 255 
8b0a 77					ld (hl), a 
8b0b 23					inc hl 
8b0c 3e 00				ld a, 0 
8b0e 77					ld (hl), a 
8b0f			 
8b0f 3e 0f				ld a, CUR_BLINK_RATE 
8b11 32 b5 ee				ld (input_cur_flash), a 
8b14 3e 01				ld a, 1 
8b16 32 b4 ee				ld (input_cur_onoff),a 
8b19			 
8b19			;	if DEBUG_INPUT 
8b19			;		push af 
8b19			;		ld a, 'I' 
8b19			;		ld (debug_mark),a 
8b19			;		pop af 
8b19			;		CALLMONITOR 
8b19			;	endif 
8b19			.is1:		; main entry loop 
8b19			 
8b19			 
8b19			 
8b19					; pause 1ms 
8b19			 
8b19 3e 01				ld a, 1 
8b1b cd f3 87				call aDelayInMS 
8b1e			 
8b1e					; dec flash counter 
8b1e 3a b5 ee				ld a, (input_cur_flash) 
8b21 3d					dec a 
8b22 32 b5 ee				ld (input_cur_flash), a 
8b25 fe 00				cp 0 
8b27 20 0d				jr nz, .nochgstate 
8b29			 
8b29			 
8b29					; change state 
8b29 3a b4 ee				ld a,(input_cur_onoff) 
8b2c ed 44				neg 
8b2e 32 b4 ee				ld (input_cur_onoff),a 
8b31			 
8b31			 
8b31					; reset on change of state 
8b31 3e 0f				ld a, CUR_BLINK_RATE 
8b33 32 b5 ee				ld (input_cur_flash), a 
8b36			 
8b36			.nochgstate: 
8b36					 
8b36					 
8b36			 
8b36					; display cursor  
8b36			 
8b36			;		ld hl, (input_start) 
8b36			;		ld a, (input_cursor) 
8b36			;		call addatohl 
8b36			 
8b36					; get char under cursor and replace with cursor 
8b36 2a be ee		ld hl, (input_ptr) 
8b39			;		ld a, (hl) 
8b39			;		ld (input_under_cursor),a 
8b39			;		ld a, '_' 
8b39			;		ld (hl), a 
8b39			 
8b39					; display string 
8b39			 
8b39 ed 5b bc ee			ld de, (input_start) 
8b3d 3a b9 ee				ld a, (input_at_pos) 
8b40 cd a1 88				call str_at_display 
8b43			;	        call update_display 
8b43			 
8b43					; find place to put the cursor 
8b43			;		add h 
8b43			;		ld l, display_row_1 
8b43			;		sub l 
8b43			; (input_at_pos) 
8b43					;ld c, a 
8b43			;		ld a, (input_cursor) 
8b43			;		ld l, (input_at_pos) 
8b43			;		;ld b, h 
8b43			;		add l 
8b43			;		ld (input_at_cursor),a 
8b43					;ld l,h 
8b43			 
8b43			;		ld h, 0 
8b43			;		ld l,(input_at_pos) 
8b43			;		ld a, (input_cursor) 
8b43			;		call addatohl 
8b43			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8b43			;		call subafromhl 
8b43			;		ld a,l 
8b43			;		ld (input_at_cursor), a 
8b43			 
8b43				if DEBUG_INPUT 
8b43					ld a, (hardware_diag) 
8b43					cp 0 
8b43					jr z, .skip_input_diag 
8b43			 
8b43					ld a,(input_at_pos) 
8b43					ld hl, LFSRSeed 
8b43					call hexout 
8b43					ld a, (input_cursor) 
8b43					ld hl, LFSRSeed+2 
8b43					call hexout 
8b43					ld a,(input_at_cursor) 
8b43					ld hl, LFSRSeed+4 
8b43					call hexout 
8b43			 
8b43					ld a,(input_cur_onoff) 
8b43					ld hl, LFSRSeed+6 
8b43					call hexout 
8b43			 
8b43					ld a,(input_cur_flash) 
8b43					ld hl, LFSRSeed+8 
8b43					call hexout 
8b43			 
8b43					ld a,(input_len) 
8b43					ld hl, LFSRSeed+10 
8b43					call hexout 
8b43					ld hl, LFSRSeed+12 
8b43					ld a, 0 
8b43					ld (hl),a 
8b43					ld a, display_row_4 
8b43					ld de, LFSRSeed 
8b43					call str_at_display 
8b43					.skip_input_diag: 
8b43				endif 
8b43			 
8b43					; decide on if we are showing the cursor this time round 
8b43			 
8b43 3a b4 ee				ld a, (input_cur_onoff) 
8b46 fe ff				cp 255 
8b48 28 13				jr z, .skipcur 
8b4a			 
8b4a			 
8b4a 3a b7 ee				ld a,(input_at_cursor) 
8b4d 11 59 ed				ld de, cursor_shape 
8b50 cd a1 88				call str_at_display 
8b53			 
8b53					; save length of current input string 
8b53 2a bc ee				ld hl, (input_start) 
8b56 cd 19 8f				call strlenz 
8b59 7d					ld a,l 
8b5a 32 af ee				ld (input_len),a 
8b5d			 
8b5d			.skipcur: 
8b5d			 
8b5d cd b1 88			        call update_display 
8b60					 
8b60			 
8b60			 
8b60					; wait 
8b60				 
8b60					; TODO loop without wait to flash the cursor and char under cursor	 
8b60 cd 66 d7				call cin    ; _wait 
8b63			 
8b63 fe 00				cp 0 
8b65 ca 19 8b				jp z, .is1 
8b68			 
8b68					; get ptr to char to input into 
8b68			 
8b68 4f					ld c,a 
8b69 2a bc ee				ld hl, (input_start) 
8b6c 3a aa ee				ld a, (input_cursor) 
8b6f cd bb 8a				call addatohl 
8b72 22 be ee				ld (input_ptr), hl 
8b75 79					ld a,c 
8b76			 
8b76					; replace char under cursor 
8b76			 
8b76			;		ld hl, (input_ptr) 
8b76			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8b76			;		ld (hl), a 
8b76			 
8b76			;	if DEBUG_INPUT 
8b76			;		push af 
8b76			;		ld a, 'i' 
8b76			;		ld (debug_mark),a 
8b76			;		pop af 
8b76			;		CALLMONITOR 
8b76			;	endif 
8b76 fe 0e				cp KEY_HOME 
8b78 20 0e				jr nz, .iske 
8b7a			 
8b7a 3a b9 ee				ld a, (input_at_pos) 
8b7d 32 b7 ee				ld (input_at_cursor),a 
8b80 3e 00				ld a, 0 
8b82 32 aa ee				ld (input_cursor), a 
8b85 c3 19 8b				jp .is1 
8b88					 
8b88 fe 0f		.iske:		cp KEY_END 
8b8a 20 03				jr nz, .isknw 
8b8c c3 19 8b				jp .is1 
8b8f			 
8b8f fe 06		.isknw:		cp KEY_NEXTWORD 
8b91 20 1b				jr nz, .iskpw 
8b93			 
8b93 2a be ee		.isknwm:	ld hl, (input_ptr) 
8b96 7e					ld a,(hl)	 
8b97 fe 00				cp 0 
8b99 ca 19 8b				jp z, .is1    ; end of string 
8b9c fe 20				cp ' ' 
8b9e ca 19 8b				jp z, .is1    ; end of word 
8ba1 23					inc hl 
8ba2 22 be ee				ld (input_ptr), hl 
8ba5 3a b7 ee				ld a, (input_at_cursor) 
8ba8 3c					inc a 
8ba9 32 b7 ee				ld (input_at_cursor), a 
8bac 18 e5				jr .isknwm 
8bae			 
8bae fe 07		.iskpw:		cp KEY_PREVWORD 
8bb0 20 1b				jr nz, .iskl 
8bb2			.iskpwm:	 
8bb2 2a be ee				ld hl, (input_ptr) 
8bb5 7e					ld a,(hl)	 
8bb6 fe 00				cp 0  
8bb8 ca 19 8b				jp z, .is1    ; end of string 
8bbb fe 20				cp ' ' 
8bbd ca 19 8b				jp z, .is1    ; end of word 
8bc0 2b					dec hl 
8bc1 22 be ee				ld (input_ptr), hl 
8bc4 3a b7 ee				ld a, (input_at_cursor) 
8bc7 3d					dec a 
8bc8 32 b7 ee				ld (input_at_cursor), a 
8bcb 18 e5				jr .iskpwm 
8bcd			 
8bcd			 
8bcd fe 0b		.iskl:		cp KEY_LEFT 
8bcf 20 27				jr nz, .isk1 
8bd1			 
8bd1 3a aa ee				ld a, (input_cursor) 
8bd4			 
8bd4 fe 00				cp 0 
8bd6 ca 19 8b				jp z, .is1 		; at start of line to ignore  
8bd9			 
8bd9 3d					dec  a 		; TODO check underflow 
8bda 32 aa ee				ld (input_cursor), a 
8bdd			 
8bdd 2a be ee				ld hl, (input_ptr) 
8be0 2b					dec hl 
8be1 22 be ee				ld (input_ptr), hl 
8be4					 
8be4 3a b7 ee				ld a, (input_at_cursor) 
8be7 3d					dec a 
8be8 32 b7 ee				ld (input_at_cursor), a 
8beb			 
8beb 3e 01				ld a, 1		; show cursor moving 
8bed 32 b4 ee				ld (input_cur_onoff),a 
8bf0 3e 0f				ld a, CUR_BLINK_RATE 
8bf2 32 b5 ee				ld (input_cur_flash), a 
8bf5			 
8bf5 c3 19 8b				jp .is1 
8bf8			 
8bf8 fe 0c		.isk1:		cp KEY_RIGHT 
8bfa 20 2a				jr nz, .isk2 
8bfc			 
8bfc 3a af ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8bff 5f					ld e,a 
8c00 3a aa ee				ld a, (input_cursor) 
8c03 bb					cp e 
8c04 ca 19 8b				jp z, .is1		; at the end of string so dont go right 
8c07			 
8c07 3c					inc  a 		; TODO check overflow 
8c08 32 aa ee				ld (input_cursor), a 
8c0b			 
8c0b 3a b7 ee				ld a, (input_at_cursor) 
8c0e 3c					inc a 
8c0f 32 b7 ee				ld (input_at_cursor), a 
8c12			 
8c12 2a be ee				ld hl, (input_ptr) 
8c15 23					inc hl 
8c16 22 be ee				ld (input_ptr), hl 
8c19			 
8c19 3e 01				ld a, 1		; show cursor moving 
8c1b 32 b4 ee				ld (input_cur_onoff),a 
8c1e 3e 0f				ld a, CUR_BLINK_RATE 
8c20 32 b5 ee				ld (input_cur_flash), a 
8c23			 
8c23 c3 19 8b				jp .is1 
8c26			 
8c26 fe 05		.isk2:		cp KEY_UP 
8c28			 
8c28 20 26				jr nz, .isk3 
8c2a			 
8c2a					; swap last command with the current on 
8c2a			 
8c2a					; move cursor to start of string 
8c2a 2a bc ee				ld hl, (input_start) 
8c2d 22 be ee				ld (input_ptr), hl 
8c30			 
8c30 3a b9 ee				ld a, (input_at_pos) 
8c33 32 b7 ee				ld (input_at_cursor), a 
8c36			 
8c36 3e 00				ld a, 0 
8c38 32 aa ee				ld (input_cursor), a 
8c3b					 
8c3b					; swap input and last command buffers 
8c3b			 
8c3b 21 0d e8				ld hl, os_cli_cmd 
8c3e 11 0c e9				ld de, os_last_cmd 
8c41 06 ff				ld b, 255 
8c43 7e			.swap1:		ld a, (hl) 
8c44 4f					ld c,a 
8c45 1a					ld a, (de) 
8c46 77					ld (hl), a 
8c47 79					ld a,c 
8c48 12					ld (de),a 
8c49 23					inc hl 
8c4a 13					inc de 
8c4b 10 f6				djnz .swap1 
8c4d			 
8c4d			 
8c4d			 
8c4d			 
8c4d			 
8c4d c3 19 8b				jp .is1 
8c50			 
8c50 fe 08		.isk3:		cp KEY_BS 
8c52 20 3c				jr nz, .isk4 
8c54			 
8c54 3a aa ee				ld a, (input_cursor) 
8c57			 
8c57 fe 00				cp 0 
8c59 ca 19 8b				jp z, .is1 		; at start of line to ignore  
8c5c			 
8c5c 3d					dec  a 		; TODO check underflow 
8c5d 32 aa ee				ld (input_cursor), a 
8c60			 
8c60					; hl is source 
8c60					; de needs to be source - 1 
8c60			 
8c60			;		ld a, 0 
8c60			;		dec hl 
8c60			;		ld (hl), a 
8c60			 
8c60 2a be ee				ld hl, (input_ptr) 
8c63 2b					dec hl 
8c64 22 be ee				ld (input_ptr), hl 
8c67			 
8c67					; shift all data 
8c67			 
8c67 e5					push hl 
8c68 23					inc hl 
8c69 d1					pop de 
8c6a 3a af ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8c6d 4f					ld c,a 
8c6e 06 00				ld b,0 
8c70 ed b0				ldir  
8c72			 
8c72			 
8c72			 
8c72			 
8c72 3a b7 ee				ld a, (input_at_cursor) 
8c75 3d					dec a 
8c76 32 b7 ee				ld (input_at_cursor), a 
8c79			 
8c79			 
8c79 3e 01				ld a, 1		; show cursor moving 
8c7b 32 b4 ee				ld (input_cur_onoff),a 
8c7e 3e 0f				ld a, CUR_BLINK_RATE 
8c80 32 b5 ee				ld (input_cur_flash), a 
8c83			 
8c83					; remove char 
8c83 3a b7 ee				ld a, (input_at_cursor) 
8c86 3c					inc a 
8c87 11 11 8d				ld de,.iblank 
8c8a cd a1 88				call str_at_display 
8c8d			 
8c8d c3 19 8b				jp .is1 
8c90			 
8c90 fe 0d		.isk4:		cp KEY_CR 
8c92 28 6c				jr z, .endinput 
8c94			 
8c94					; else add the key press to the end 
8c94			 
8c94 4f					ld c, a			; save key pressed 
8c95			 
8c95 7e					ld a,(hl)		; get what is currently under char 
8c96			 
8c96 fe 00				cp 0			; we are at the end of the string 
8c98 20 2f				jr nz, .onchar 
8c9a					 
8c9a					; add a char to the end of the string 
8c9a				 
8c9a 71					ld (hl),c 
8c9b 23					inc hl 
8c9c			;		ld a,' ' 
8c9c			;		ld (hl),a 
8c9c			;		inc hl 
8c9c 3e 00				ld a,0 
8c9e 77					ld (hl),a 
8c9f 2b					dec hl 
8ca0			 
8ca0 3a aa ee				ld a, (input_cursor) 
8ca3 3c					inc a				; TODO check max string length and scroll  
8ca4 32 aa ee				ld (input_cursor), a		; inc cursor pos 
8ca7							 
8ca7 3a b7 ee				ld a, (input_at_cursor) 
8caa 3c					inc a 
8cab 32 b7 ee				ld (input_at_cursor), a 
8cae			 
8cae 2a be ee				ld hl, (input_ptr) 
8cb1 23					inc hl 
8cb2 22 be ee				ld (input_ptr), hl 
8cb5			 
8cb5 2a be ee				ld hl, (input_ptr) 
8cb8 23					inc hl 
8cb9 22 be ee				ld (input_ptr), hl 
8cbc			;	if DEBUG_INPUT 
8cbc			;		push af 
8cbc			;		ld a, '+' 
8cbc			;		ld (debug_mark),a 
8cbc			;		pop af 
8cbc			;		CALLMONITOR 
8cbc			;	endif 
8cbc 3e 01				ld a, 1		; show cursor moving 
8cbe 32 b4 ee				ld (input_cur_onoff),a 
8cc1 3e 0f				ld a, CUR_BLINK_RATE 
8cc3 32 b5 ee				ld (input_cur_flash), a 
8cc6 c3 19 8b				jp .is1 
8cc9					 
8cc9			 
8cc9			 
8cc9					; if on a char then insert 
8cc9			.onchar: 
8cc9			 
8cc9					; TODO over flow check: make sure insert does not blow out buffer 
8cc9			 
8cc9					; need to do some maths to use lddr 
8cc9			 
8cc9 e5					push hl   ; save char pos 
8cca c5					push bc 
8ccb			 
8ccb 2a bc ee				ld hl, (input_start) 
8cce 3a af ee				ld a, (input_len) 
8cd1 cd bb 8a				call addatohl  		; end of string 
8cd4 23					inc hl 
8cd5 23					inc hl		; past zero term 
8cd6 e5					push hl 
8cd7 23					inc hl 
8cd8 e5					push hl  
8cd9			 
8cd9								; start and end of lddr set, now how much to move? 
8cd9			 
8cd9							 
8cd9 3a aa ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8cdc 47					ld b,a 
8cdd 3a af ee				ld a,(input_len) 
8ce0 5f					ld e,a 
8ce1 90					sub b 
8ce2 3c					inc a		;?? 
8ce3 3c					inc a		;?? 
8ce4 3c					inc a		;?? 
8ce5			 
8ce5 06 00				ld b,0 
8ce7 4f					ld c,a 
8ce8			 
8ce8				if DEBUG_INPUT 
8ce8					push af 
8ce8					ld a, 'i' 
8ce8					ld (debug_mark),a 
8ce8					pop af 
8ce8			;		CALLMONITOR 
8ce8				endif 
8ce8 d1					pop de 
8ce9 e1					pop hl 
8cea				if DEBUG_INPUT 
8cea					push af 
8cea					ld a, 'I' 
8cea					ld (debug_mark),a 
8cea					pop af 
8cea			;		CALLMONITOR 
8cea				endif 
8cea ed b8				lddr 
8cec				 
8cec			 
8cec			 
8cec					; TODO have a key for insert/overwrite mode???? 
8cec c1					pop bc 
8ced e1					pop hl 
8cee 71					ld (hl), c		; otherwise overwrite current char 
8cef					 
8cef			 
8cef			 
8cef			 
8cef 3a aa ee				ld a, (input_cursor) 
8cf2 3c					inc  a 		; TODO check overflow 
8cf3 32 aa ee				ld (input_cursor), a 
8cf6			 
8cf6 3a b7 ee				ld a, (input_at_cursor) 
8cf9 3c					inc a 
8cfa 32 b7 ee				ld (input_at_cursor), a 
8cfd			 
8cfd c3 19 8b				jp .is1 
8d00			 
8d00			.endinput:	; TODO look for end of string 
8d00			 
8d00					; add trailing space for end of token 
8d00			 
8d00 2a bc ee				ld hl, (input_start) 
8d03 3a af ee				ld a,(input_len) 
8d06 cd bb 8a				call addatohl 
8d09 3e 20				ld a, ' ' 
8d0b 77					ld (hl),a 
8d0c					; TODO eof of parse marker 
8d0c			 
8d0c 23					inc hl 
8d0d 3e 00				ld a, 0 
8d0f 77					ld (hl),a 
8d10			 
8d10			 
8d10 c9					ret 
8d11			 
8d11 .. 00		.iblank: db " ",0 
8d13			 
8d13			 
8d13 32 b9 ee		input_str_prev:	ld (input_at_pos), a 
8d16 22 bc ee				ld (input_start), hl 
8d19 3e 01				ld a,1			; add cursor 
8d1b 77					ld (hl),a 
8d1c 23					inc hl 
8d1d 3e 00				ld a,0 
8d1f 77					ld (hl),a 
8d20 22 be ee				ld (input_ptr), hl 
8d23 7a					ld a,d 
8d24 32 bb ee				ld (input_size), a 
8d27 3e 00				ld a,0 
8d29 32 aa ee				ld (input_cursor),a 
8d2c			.instr1:	 
8d2c			 
8d2c					; TODO do block cursor 
8d2c					; TODO switch cursor depending on the modifer key 
8d2c			 
8d2c					; update cursor shape change on key hold 
8d2c			 
8d2c 2a be ee				ld hl, (input_ptr) 
8d2f 2b					dec hl 
8d30 3a 59 ed				ld a,(cursor_shape) 
8d33 77					ld (hl), a 
8d34			 
8d34					; display entered text 
8d34 3a b9 ee				ld a,(input_at_pos) 
8d37 cd c4 d6		            	CALL fLCD_Pos       ;Position cursor to location in A 
8d3a ed 5b bc ee	            	LD   de, (input_start) 
8d3e cd be d6		            	CALL fLCD_Str       ;Display string pointed to by DE 
8d41			 
8d41 cd 66 d7				call cin 
8d44 fe 00				cp 0 
8d46 28 e4				jr z, .instr1 
8d48			 
8d48					; proecess keyboard controls first 
8d48			 
8d48 2a be ee				ld hl,(input_ptr) 
8d4b			 
8d4b fe 0d				cp KEY_CR	 ; pressing enter ends input 
8d4d 28 5a				jr z, .instrcr 
8d4f			 
8d4f fe 08				cp KEY_BS 	; back space 
8d51 20 0f				jr nz, .instr2 
8d53					; process back space 
8d53			 
8d53					; TODO stop back space if at start of string 
8d53 2b					dec hl 
8d54 2b					dec hl ; to over write cursor 
8d55 3a 59 ed				ld a,(cursor_shape) 
8d58					;ld a,0 
8d58 77					ld (hl),a 
8d59 23					inc hl 
8d5a 3e 20				ld a," " 
8d5c 77					ld (hl),a 
8d5d 22 be ee				ld (input_ptr),hl 
8d60					 
8d60			 
8d60 18 ca				jr .instr1 
8d62			 
8d62 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8d64 20 06				jr nz, .instr3 
8d66 2b					dec hl 
8d67 22 be ee				ld (input_ptr),hl 
8d6a 18 c0				jr .instr1 
8d6c				 
8d6c fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8d6e 20 06				jr nz, .instr4 
8d70 23					inc hl 
8d71 22 be ee				ld (input_ptr),hl 
8d74 18 b6				jr .instr1 
8d76			 
8d76 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8d78 20 06				jr nz, .instr5 
8d7a 2b					dec hl 
8d7b 22 be ee				ld (input_ptr),hl 
8d7e 18 ac				jr .instr1 
8d80			 
8d80 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8d82 20 06				jr nz, .instr6 
8d84 2b					dec hl 
8d85 22 be ee				ld (input_ptr),hl 
8d88 18 a2				jr .instr1 
8d8a fe 05		.instr6:        cp KEY_UP      ; recall last command 
8d8c 20 0b				jr nz, .instrnew 
8d8e			 
8d8e 21 e6 e4			ld hl, scratch 
8d91 11 0c e9			ld de, os_last_cmd 
8d94 cd b2 8d			call strcpy 
8d97 18 93				jr .instr1 
8d99			 
8d99			 
8d99			.instrnew:	; no special key pressed to see if we have room to store it 
8d99			 
8d99					; TODO do string size test 
8d99			 
8d99 2b					dec hl ; to over write cursor 
8d9a 77					ld (hl),a 
8d9b 23					inc hl 
8d9c 3a 59 ed				ld a,(cursor_shape) 
8d9f 77					ld (hl),a 
8da0 23					inc hl 
8da1 3e 00				ld a,0 
8da3 77					ld (hl),a 
8da4			 
8da4 22 be ee				ld (input_ptr),hl 
8da7					 
8da7 18 83				jr .instr1 
8da9 2b			.instrcr:	dec hl		; remove cursor 
8daa 3e 20				ld a,' '	; TODO add a trailing space for safety 
8dac 77					ld (hl),a 
8dad 23					inc hl 
8dae 3e 00				ld a,0 
8db0 77					ld (hl),a 
8db1			 
8db1			 
8db1					; if at end of line scroll up    
8db1					; TODO detecting only end of line 4 for scroll up  
8db1			 
8db1					;ld   
8db1			 
8db1 c9					ret 
8db2			 
8db2			 
8db2			; strcpy hl = dest, de source 
8db2			 
8db2 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8db3 b7			            OR   A              ;Null terminator? 
8db4 c8			            RET  Z              ;Yes, so finished 
8db5 1a					ld a,(de) 
8db6 77					ld (hl),a 
8db7 13			            INC  DE             ;Point to next character 
8db8 23					inc hl 
8db9 18 f7		            JR   strcpy       ;Repeat 
8dbb c9					ret 
8dbc			 
8dbc			 
8dbc			; TODO string_at  
8dbc			; pass string which starts with lcd offset address and then null term string 
8dbc			 
8dbc			; TODO string to dec 
8dbc			; TODO string to hex 
8dbc			; TODO byte to string hex 
8dbc			; TODO byte to string dec 
8dbc			 
8dbc			 
8dbc			 
8dbc			; from z80uartmonitor 
8dbc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dbc			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8dbc			; pass hl for where to put the text 
8dbc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dbc c5			hexout:	PUSH BC 
8dbd f5					PUSH AF 
8dbe 47					LD B, A 
8dbf					; Upper nybble 
8dbf cb 3f				SRL A 
8dc1 cb 3f				SRL A 
8dc3 cb 3f				SRL A 
8dc5 cb 3f				SRL A 
8dc7 cd d7 8d				CALL tohex 
8dca 77					ld (hl),a 
8dcb 23					inc hl	 
8dcc					 
8dcc					; Lower nybble 
8dcc 78					LD A, B 
8dcd e6 0f				AND 0FH 
8dcf cd d7 8d				CALL tohex 
8dd2 77					ld (hl),a 
8dd3 23					inc hl	 
8dd4					 
8dd4 f1					POP AF 
8dd5 c1					POP BC 
8dd6 c9					RET 
8dd7					 
8dd7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dd7			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8dd7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dd7			tohex: 
8dd7 e5					PUSH HL 
8dd8 d5					PUSH DE 
8dd9 16 00				LD D, 0 
8ddb 5f					LD E, A 
8ddc 21 e4 8d				LD HL, .DATA 
8ddf 19					ADD HL, DE 
8de0 7e					LD A, (HL) 
8de1 d1					POP DE 
8de2 e1					POP HL 
8de3 c9					RET 
8de4			 
8de4			.DATA: 
8de4 30					DEFB	30h	; 0 
8de5 31					DEFB	31h	; 1 
8de6 32					DEFB	32h	; 2 
8de7 33					DEFB	33h	; 3 
8de8 34					DEFB	34h	; 4 
8de9 35					DEFB	35h	; 5 
8dea 36					DEFB	36h	; 6 
8deb 37					DEFB	37h	; 7 
8dec 38					DEFB	38h	; 8 
8ded 39					DEFB	39h	; 9 
8dee 41					DEFB	41h	; A 
8def 42					DEFB	42h	; B 
8df0 43					DEFB	43h	; C 
8df1 44					DEFB	44h	; D 
8df2 45					DEFB	45h	; E 
8df3 46					DEFB	46h	; F 
8df4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8df4			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8df4			;;    subtract $30, if result > 9 then subtract $7 more 
8df4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8df4			atohex: 
8df4 d6 30				SUB $30 
8df6 fe 0a				CP 10 
8df8 f8					RET M		; If result negative it was 0-9 so we're done 
8df9 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8dfb c9					RET		 
8dfc			 
8dfc			 
8dfc			 
8dfc			 
8dfc			; Get 2 ASCII characters as hex byte from pointer in hl 
8dfc			 
8dfc			BYTERD: 
8dfc 16 00			LD	D,00h		;Set up 
8dfe cd 06 8e			CALL	HEXCON		;Get byte and convert to hex 
8e01 87				ADD	A,A		;First nibble so 
8e02 87				ADD	A,A		;multiply by 16 
8e03 87				ADD	A,A		; 
8e04 87				ADD	A,A		; 
8e05 57				LD	D,A		;Save hi nibble in D 
8e06			HEXCON: 
8e06 7e				ld a, (hl)		;Get next chr 
8e07 23				inc hl 
8e08 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8e0a fe 0a			CP	00Ah		;Is it 0-9 ? 
8e0c 38 02			JR	C,NALPHA	;If so miss next bit 
8e0e d6 07			SUB	007h		;Else convert alpha 
8e10			NALPHA: 
8e10 b2				OR	D		;Add hi nibble back 
8e11 c9				RET			; 
8e12			 
8e12			 
8e12			; 
8e12			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8e12			; Since the routines get_byte and therefore get_nibble are called, only valid 
8e12			; characters (0-9a-f) are accepted. 
8e12			; 
8e12			;get_word        push    af 
8e12			;                call    get_byte        ; Get the upper byte 
8e12			;                ld      h, a 
8e12			;                call    get_byte        ; Get the lower byte 
8e12			;                ld      l, a 
8e12			;                pop     af 
8e12			;                ret 
8e12			; 
8e12			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8e12			; the routine get_nibble is used only valid characters are accepted - the  
8e12			; input routine only accepts characters 0-9a-f. 
8e12			; 
8e12 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8e13 7e					ld a,(hl) 
8e14 23					inc hl 
8e15 cd 3a 8e		                call    nibble2val      ; Get upper nibble 
8e18 cb 07		                rlc     a 
8e1a cb 07		                rlc     a 
8e1c cb 07		                rlc     a 
8e1e cb 07		                rlc     a 
8e20 47			                ld      b, a            ; Save upper four bits 
8e21 7e					ld a,(hl) 
8e22 cd 3a 8e		                call    nibble2val      ; Get lower nibble 
8e25 b0			                or      b               ; Combine both nibbles 
8e26 c1			                pop     bc              ; Restore B (and C) 
8e27 c9			                ret 
8e28			; 
8e28			; Get a hexadecimal digit from the serial line. This routine blocks until 
8e28			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8e28			; to the serial line interface. The lower 4 bits of A contain the value of  
8e28			; that particular digit. 
8e28			; 
8e28			;get_nibble      ld a,(hl)           ; Read a character 
8e28			;                call    to_upper        ; Convert to upper case 
8e28			;                call    is_hex          ; Was it a hex digit? 
8e28			;                jr      nc, get_nibble  ; No, get another character 
8e28			 ;               call    nibble2val      ; Convert nibble to value 
8e28			 ;               call    print_nibble 
8e28			 ;               ret 
8e28			; 
8e28			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8e28			; A valid hexadecimal digit is denoted by a set C flag. 
8e28			; 
8e28			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8e28			;                ret     nc              ; Yes 
8e28			;                cp      '0'             ; Less than '0'? 
8e28			;                jr      nc, is_hex_1    ; No, continue 
8e28			;                ccf                     ; Complement carry (i.e. clear it) 
8e28			;                ret 
8e28			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8e28			;                ret     c               ; Yes 
8e28			;                cp      'A'             ; Less than 'A'? 
8e28			;                jr      nc, is_hex_2    ; No, continue 
8e28			;                ccf                     ; Yes - clear carry and return 
8e28			;                ret 
8e28			;is_hex_2        scf                     ; Set carry 
8e28			;                ret 
8e28			; 
8e28			; Convert a single character contained in A to upper case: 
8e28			; 
8e28 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8e2a d8			                ret     c 
8e2b fe 7b		                cp      'z' + 1         ; > 'z'? 
8e2d d0			                ret     nc              ; Nothing to do, either 
8e2e e6 5f		                and     $5f             ; Convert to upper case 
8e30 c9			                ret 
8e31			 
8e31			 
8e31			to_lower: 
8e31			 
8e31			   ; if char is in [A-Z] make it lower case 
8e31			 
8e31			   ; enter : a = char 
8e31			   ; exit  : a = lower case char 
8e31			   ; uses  : af 
8e31			 
8e31 fe 41		   cp 'A' 
8e33 d8			   ret c 
8e34			    
8e34 fe 5b		   cp 'Z'+1 
8e36 d0			   ret nc 
8e37			    
8e37 f6 20		   or $20 
8e39 c9			   ret 
8e3a			 
8e3a			; 
8e3a			; Expects a hexadecimal digit (upper case!) in A and returns the 
8e3a			; corresponding value in A. 
8e3a			; 
8e3a fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8e3c 38 02		                jr      c, nibble2val_1 ; Yes 
8e3e d6 07		                sub     7               ; Adjust for A-F 
8e40 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8e42 e6 0f		                and     $f              ; Only return lower 4 bits 
8e44 c9			                ret 
8e45			; 
8e45			; Print_nibble prints a single hex nibble which is contained in the lower  
8e45			; four bits of A: 
8e45			; 
8e45			;print_nibble    push    af              ; We won't destroy the contents of A 
8e45			;                and     $f              ; Just in case... 
8e45			;                add     a, '0'             ; If we have a digit we are done here. 
8e45			;                cp      '9' + 1         ; Is the result > 9? 
8e45			;                jr      c, print_nibble_1 
8e45			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8e45			;print_nibble_1  call    putc            ; Print the nibble and 
8e45			;                pop     af              ; restore the original value of A 
8e45			;                ret 
8e45			;; 
8e45			;; Send a CR/LF pair: 
8e45			; 
8e45			;crlf            push    af 
8e45			;                ld      a, cr 
8e45			;                call    putc 
8e45			;                ld      a, lf 
8e45			;                call    putc 
8e45			;                pop     af 
8e45			;                ret 
8e45			; 
8e45			; Print_word prints the four hex digits of a word to the serial line. The  
8e45			; word is expected to be in HL. 
8e45			; 
8e45			;print_word      push    hl 
8e45			;                push    af 
8e45			;                ld      a, h 
8e45			;                call    print_byte 
8e45			;                ld      a, l 
8e45			;                call    print_byte 
8e45			;                pop     af 
8e45			;                pop     hl 
8e45			;                ret 
8e45			; 
8e45			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8e45			; The byte to be printed is expected to be in A. 
8e45			; 
8e45			;print_byte      push    af              ; Save the contents of the registers 
8e45			;                push    bc 
8e45			;                ld      b, a 
8e45			;                rrca 
8e45			;                rrca 
8e45			;                rrca 
8e45			;                rrca 
8e45			;                call    print_nibble    ; Print high nibble 
8e45			;                ld      a, b 
8e45			;                call    print_nibble    ; Print low nibble 
8e45			;                pop     bc              ; Restore original register contents 
8e45			;                pop     af 
8e45			;                ret 
8e45			 
8e45			 
8e45			 
8e45			 
8e45			 
8e45			fourehexhl:  
8e45 7e				ld a,(hl) 
8e46 cd f4 8d			call atohex 
8e49 cb 3f				SRL A 
8e4b cb 3f				SRL A 
8e4d cb 3f				SRL A 
8e4f cb 3f				SRL A 
8e51 47				ld b, a 
8e52 23				inc hl 
8e53 7e				ld a,(hl) 
8e54 23				inc hl 
8e55 cd f4 8d			call atohex 
8e58 80				add b 
8e59 57				ld d,a 
8e5a 7e				ld a,(hl) 
8e5b cd f4 8d			call atohex 
8e5e cb 3f				SRL A 
8e60 cb 3f				SRL A 
8e62 cb 3f				SRL A 
8e64 cb 3f				SRL A 
8e66 47				ld b, a 
8e67 23				inc hl 
8e68 7e				ld a,(hl) 
8e69 23				inc hl 
8e6a cd f4 8d			call atohex 
8e6d 80				add b 
8e6e 5f				ld e, a 
8e6f d5				push de 
8e70 e1				pop hl 
8e71 c9				ret 
8e72			 
8e72			; pass hl. returns z set if the byte at hl is a digit 
8e72			;isdigithl:  
8e72			;	push bc 
8e72			;	ld a,(hl) 
8e72			;	cp ':' 
8e72			;	jr nc, .isdf 		; > 
8e72			;	cp '0' 
8e72			;	jr c, .isdf		; < 
8e72			; 
8e72			;	; TODO find a better way to set z 
8e72			; 
8e72			;	ld b,a 
8e72			;	cp b 
8e72			;	pop bc 
8e72			;	ret 
8e72			; 
8e72			;.isdf:	; not digit so clear z 
8e72			; 
8e72			;	; TODO find a better way to unset z 
8e72			; 
8e72			;	ld b,a 
8e72			;	inc b 
8e72			;	cp b 
8e72			; 
8e72			;	pop bc 
8e72			;	ret 
8e72				 
8e72				 
8e72			 
8e72			 
8e72			; pass hl as the four byte address to load 
8e72			 
8e72			get_word_hl:  
8e72 e5				push hl 
8e73 cd 12 8e			call get_byte 
8e76				 
8e76 47				ld b, a 
8e77			 
8e77 e1				pop hl 
8e78 23				inc hl 
8e79 23				inc hl 
8e7a			 
8e7a			; TODO not able to handle a-f  
8e7a 7e				ld a,(hl) 
8e7b			;	;cp ':' 
8e7b			;	cp 'g' 
8e7b			;	jr nc, .single_byte_hl 		; > 
8e7b			;	cp 'G' 
8e7b			;	jr nc, .single_byte_hl 		; > 
8e7b			;	cp '0' 
8e7b			;	jr c, .single_byte_hl		; < 
8e7b			 
8e7b				;call isdigithl 
8e7b fe 00			cp 0 
8e7d 28 06			jr z, .single_byte_hl 
8e7f			 
8e7f			.getwhln:   ; hex word so get next byte 
8e7f			 
8e7f cd 12 8e			call get_byte 
8e82 6f				ld l, a 
8e83 60				ld h,b 
8e84 c9				ret 
8e85 68			.single_byte_hl:   ld l,b 
8e86 26 00				ld h,0 
8e88 c9					ret 
8e89			 
8e89			 
8e89			 
8e89			 
8e89 21 d2 95			ld hl,asc+1 
8e8c			;	ld a, (hl) 
8e8c			;	call nibble2val 
8e8c cd 12 8e			call get_byte 
8e8f			 
8e8f			;	call fourehexhl 
8e8f 32 1a e5			ld (scratch+52),a 
8e92				 
8e92 21 18 e5			ld hl,scratch+50 
8e95 22 09 e8			ld (os_cur_ptr),hl 
8e98			 
8e98 c9				ret 
8e99			 
8e99			 
8e99			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8e99			 
8e99			; Decimal Unsigned Version 
8e99			 
8e99			;Number in a to decimal ASCII 
8e99			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8e99			;Example: display a=56 as "056" 
8e99			;input: a = number 
8e99			;Output: a=0,value of a in the screen 
8e99			;destroys af,bc (don't know about hl and de) 
8e99			DispAToASCII: 
8e99 0e 9c			ld	c,-100 
8e9b cd a5 8e			call	.Na1 
8e9e 0e f6			ld	c,-10 
8ea0 cd a5 8e			call	.Na1 
8ea3 0e ff			ld	c,-1 
8ea5 06 2f		.Na1:	ld	b,'0'-1 
8ea7 04			.Na2:	inc	b 
8ea8 81				add	a,c 
8ea9 38 fc			jr	c,.Na2 
8eab 91				sub	c		;works as add 100/10/1 
8eac f5				push af		;safer than ld c,a 
8ead 78				ld	a,b		;char is in b 
8eae			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8eae f1				pop af		;safer than ld a,c 
8eaf c9				ret 
8eb0			 
8eb0			; Decimal Signed Version 
8eb0			 
8eb0			; DispA 
8eb0			; -------------------------------------------------------------- 
8eb0			; Converts a signed integer value to a zero-terminated ASCII 
8eb0			; string representative of that value (using radix 10). 
8eb0			; -------------------------------------------------------------- 
8eb0			; INPUTS: 
8eb0			;     HL     Value to convert (two's complement integer). 
8eb0			;     DE     Base address of string destination. (pointer). 
8eb0			; -------------------------------------------------------------- 
8eb0			; OUTPUTS: 
8eb0			;     None 
8eb0			; -------------------------------------------------------------- 
8eb0			; REGISTERS/MEMORY DESTROYED 
8eb0			; AF HL 
8eb0			; -------------------------------------------------------------- 
8eb0			 
8eb0			;DispHLToASCII: 
8eb0			;   push    de 
8eb0			;   push    bc 
8eb0			; 
8eb0			;; Detect sign of HL. 
8eb0			;    bit    7, h 
8eb0			;    jr     z, ._DoConvert 
8eb0			; 
8eb0			;; HL is negative. Output '-' to string and negate HL. 
8eb0			;    ld     a, '-' 
8eb0			;    ld     (de), a 
8eb0			;    inc    de 
8eb0			; 
8eb0			;; Negate HL (using two's complement) 
8eb0			;    xor    a 
8eb0			;    sub    l 
8eb0			;    ld     l, a 
8eb0			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8eb0			;    sbc    a, h 
8eb0			;    ld     h, a 
8eb0			; 
8eb0			;; Convert HL to digit characters 
8eb0			;._DoConvert: 
8eb0			;    ld     b, 0     ; B will count character length of number 
8eb0			;-   ld     a, 10 
8eb0			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8eb0			;    push   af 
8eb0			;    inc    b 
8eb0			;    ld     a, h 
8eb0			;    or     l 
8eb0			;    jr     nz, - 
8eb0			; 
8eb0			;; Retrieve digits from stack 
8eb0			;-   pop    af 
8eb0			;    or     $30 
8eb0			;    ld     (de), a 
8eb0			;    inc    de 
8eb0			;    djnz   - 
8eb0			; 
8eb0			;; Terminate string with NULL 
8eb0			;    xor    a 
8eb0			;    ld     (de), a 
8eb0			; 
8eb0			;    pop    bc 
8eb0			;    pop    de 
8eb0			;    ret 
8eb0			 
8eb0			;Comments 
8eb0			; 
8eb0			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8eb0			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8eb0			;    Note that the output string will not be fixed-width. 
8eb0			; 
8eb0			;Example Usage 
8eb0			; 
8eb0			;    ld    hl, -1004 
8eb0			;    ld    de, OP1 
8eb0			;    call  DispA 
8eb0			;    ld    hl, OP1 
8eb0			;    syscall  PutS 
8eb0			 
8eb0			 
8eb0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8eb0			 
8eb0			 
8eb0			;Converts an ASCII string to an unsigned 16-bit integer 
8eb0			;Quits when it reaches a non-decimal digit 
8eb0			 
8eb0			string_to_uint16: 
8eb0			atoui_16: 
8eb0			;Input: 
8eb0			;     DE points to the string 
8eb0			;Outputs: 
8eb0			;     HL is the result 
8eb0			;     A is the 8-bit value of the number 
8eb0			;     DE points to the byte after the number 
8eb0			;Destroys: 
8eb0			;     BC 
8eb0			;       if the string is non-empty, BC is HL/10 
8eb0			;Size:  24 bytes 
8eb0			;Speed: 42+d(104+{0,9}) 
8eb0			;       d is the number of digits in the number 
8eb0			;       max is 640 cycles for a 5 digit number 
8eb0			;Assuming no leading zeros: 
8eb0			;1 digit:  146cc 
8eb0			;2 digit:  250cc 
8eb0			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8eb0			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8eb0			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8eb0			;avg: 544.81158447265625cc (544+13297/16384) 
8eb0			;=============================================================== 
8eb0 21 00 00		  ld hl,0 
8eb3			.u16a: 
8eb3 1a			  ld a,(de) 
8eb4 d6 30		  sub 30h 
8eb6 fe 0a		  cp 10 
8eb8 d0			  ret nc 
8eb9 13			  inc de 
8eba 44			  ld b,h 
8ebb 4d			  ld c,l 
8ebc 29			  add hl,hl 
8ebd 29			  add hl,hl 
8ebe 09			  add hl,bc 
8ebf 29			  add hl,hl 
8ec0 85			  add a,l 
8ec1 6f			  ld l,a 
8ec2 30 ef		  jr nc,.u16a 
8ec4 24			  inc h 
8ec5 c3 b3 8e		  jp .u16a 
8ec8			 
8ec8			 
8ec8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8ec8			 
8ec8			;written by Zeda 
8ec8			;Converts a 16-bit unsigned integer to an ASCII string. 
8ec8			 
8ec8			uitoa_16: 
8ec8			;Input: 
8ec8			;   DE is the number to convert 
8ec8			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8ec8			;Output: 
8ec8			;   HL points to the null-terminated ASCII string 
8ec8			;      NOTE: This isn't necessarily the same as the input HL. 
8ec8 d5			  push de 
8ec9 c5			  push bc 
8eca f5			  push af 
8ecb eb			  ex de,hl 
8ecc			 
8ecc 01 f0 d8		  ld bc,-10000 
8ecf 3e 2f		  ld a,'0'-1 
8ed1 3c			  inc a 
8ed2 09			  add hl,bc  
8ed3 38 fc		   jr c,$-2 
8ed5 12			  ld (de),a 
8ed6 13			  inc de 
8ed7			 
8ed7 01 e8 03		  ld bc,1000 
8eda 3e 3a		  ld a,'9'+1 
8edc 3d			  dec a  
8edd 09			  add hl,bc  
8ede 30 fc		   jr nc,$-2 
8ee0 12			  ld (de),a 
8ee1 13			  inc de 
8ee2			 
8ee2 01 9c ff		  ld bc,-100 
8ee5 3e 2f		  ld a,'0'-1 
8ee7 3c			  inc a  
8ee8 09			  add hl,bc  
8ee9 38 fc		   jr c,$-2 
8eeb 12			  ld (de),a 
8eec 13			  inc de 
8eed			 
8eed 7d			  ld a,l 
8eee 26 3a		  ld h,'9'+1 
8ef0 25			  dec h  
8ef1 c6 0a		  add a,10  
8ef3 30 fb		   jr nc,$-3 
8ef5 c6 30		  add a,'0' 
8ef7 eb			  ex de,hl 
8ef8 72			  ld (hl),d 
8ef9 23			  inc hl 
8efa 77			  ld (hl),a 
8efb 23			  inc hl 
8efc 36 00		  ld (hl),0 
8efe			 
8efe			;Now strip the leading zeros 
8efe 0e fa		  ld c,-6 
8f00 09			  add hl,bc 
8f01 3e 30		  ld a,'0' 
8f03 23			  inc hl  
8f04 be			  cp (hl)  
8f05 28 fc		  jr z,$-2 
8f07			 
8f07			;Make sure that the string is non-empty! 
8f07 7e			  ld a,(hl) 
8f08 b7			  or a 
8f09 20 01		  jr nz,.atoub 
8f0b 2b			  dec hl 
8f0c			.atoub: 
8f0c			 
8f0c f1			  pop af 
8f0d c1			  pop bc 
8f0e d1			  pop de 
8f0f c9			  ret 
8f10			 
8f10			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8f10			 
8f10			toUpper: 
8f10			;A is the char. 
8f10			;If A is a lowercase letter, this sets it to the matching uppercase 
8f10			;18cc or 30cc or 41cc 
8f10			;avg: 26.75cc 
8f10 fe 61		  cp 'a' 
8f12 d8			  ret c 
8f13 fe 7b		  cp 'z'+1 
8f15 d0			  ret nc 
8f16 d6 20		  sub 'a'-'A' 
8f18 c9			  ret 
8f19			 
8f19			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8f19			 
8f19			; String Length 
8f19			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8f19			 
8f19			; Get the length of the null-terminated string starting at $8000 hl 
8f19			;    LD     HL, $8000 
8f19			 
8f19			strlenz: 
8f19			 
8f19 af			    XOR    A               ; Zero is the value we are looking for. 
8f1a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8f1b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8f1c			                           ; 65, 536 bytes (the entire addressable memory space). 
8f1c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f1e			 
8f1e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f1e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8f1f 6f			    LD     L, A             ; number of bytes 
8f20 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f22 2b			    DEC    HL              ; Compensate for null. 
8f23 c9				ret 
8f24			 
8f24			; Get the length of the A terminated string starting at $8000 hl 
8f24			;    LD     HL, $8000 
8f24			 
8f24			strlent: 
8f24			 
8f24			                  ; A is the value we are looking for. 
8f24 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8f26 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8f28			                           ; 65, 536 bytes (the entire addressable memory space). 
8f28 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f2a			 
8f2a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f2a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8f2c 2e 00		    LD     L, 0             ; number of bytes 
8f2e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f30 2b			    DEC    HL              ; Compensate for null. 
8f31 c9				ret 
8f32			 
8f32			 
8f32			;Comparing Strings 
8f32			 
8f32			;IN    HL     Address of string1. 
8f32			;      DE     Address of string2. 
8f32			 
8f32			; doc given but wrong??? 
8f32			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8f32			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8f32			; tested 
8f32			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8f32			 
8f32			strcmp_old: 
8f32 e5			    PUSH   HL 
8f33 d5			    PUSH   DE 
8f34			 
8f34 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8f35 be			    CP     (HL)            ; (want to minimize work). 
8f36 38 01		    JR     C, Str1IsBigger 
8f38 7e			    LD     A, (HL) 
8f39			 
8f39			Str1IsBigger: 
8f39 4f			    LD     C, A             ; Put length in BC 
8f3a 06 00		    LD     B, 0 
8f3c 13			    INC    DE              ; Increment pointers to meat of string. 
8f3d 23			    INC    HL 
8f3e			 
8f3e			CmpLoop: 
8f3e 1a			    LD     A, (DE)          ; Compare bytes. 
8f3f ed a1		    CPI 
8f41 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8f43 13			    INC    DE              ; Update pointer. 
8f44 ea 3e 8f		    JP     PE, CmpLoop 
8f47			 
8f47 d1			    POP    DE 
8f48 e1			    POP    HL 
8f49 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8f4a be			    CP     (HL) 
8f4b c9			    RET 
8f4c			 
8f4c			NoMatch: 
8f4c 2b			    DEC    HL 
8f4d be			    CP     (HL)            ; Compare again to affect carry. 
8f4e d1			    POP    DE 
8f4f e1			    POP    HL 
8f50 c9			    RET 
8f51			 
8f51			;; test strmp 
8f51			; 
8f51			;ld de, .str1 
8f51			;ld hl, .str2 
8f51			;call strcmp 
8f51			;jr z, .z1 
8f51			;;this 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "NZ1" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			;.z1: 
8f51			; 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "ZZ1" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			; 
8f51			;ld de, .str1 
8f51			;ld hl, .str1 
8f51			;call strcmp 
8f51			;jr z, .z2 
8f51			;;this 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "NZ2" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			;.z2: 
8f51			; 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "ZZ2" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			; 
8f51			;ld de, .str1 
8f51			;ld hl, .str2 
8f51			;call strcmp 
8f51			;jr c, .c1 
8f51			; 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "Nc1" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			;.c1: 
8f51			;;this 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "cc1" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			; 
8f51			;ld de, .str1 
8f51			;ld hl, .str1 
8f51			;call strcmp 
8f51			;jr c, .c2 
8f51			;;this 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "Nc2" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			;.c2: 
8f51			; 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "cc2" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			;	NEXTW 
8f51			;.str1:   db "string1",0 
8f51			;.str2:   db "string2",0 
8f51			 
8f51			; only care about direct match or not 
8f51			; hl and de strings 
8f51			; zero set if the same 
8f51			 
8f51			strcmp: 
8f51 1a				ld a, (de) 
8f52 be				cp (hl) 
8f53 28 02			jr z, .ssame 
8f55 b7				or a 
8f56 c9				ret 
8f57			 
8f57			.ssame:  
8f57 fe 00			cp 0 
8f59 c8				ret z 
8f5a			 
8f5a 23				inc hl 
8f5b 13				inc de 
8f5c 18 f3			jr strcmp 
8f5e				 
8f5e				 
8f5e			 
8f5e			 
8f5e			 
8f5e			 
8f5e			; eof 
8f5e			 
8f5e			 
8f5e			 
8f5e			 
8f5e			 
8f5e			 
# End of file firmware_strings.asm
8f5e			include "firmware_memory.asm"   ; malloc and free  
8f5e			 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e			.mallocsize: db "Wants malloc >256",0 
8f5e			.mallocasize: db "MALLOC gives >256",0 
8f5e			.malloczero: db "MALLOC gives zero",0 
8f5e			 
8f5e			malloc_guard_zerolen: 
8f5e				push hl 
8f5e				push de 
8f5e				push af 
8f5e			 
8f5e				ld de, 0 
8f5e			        call cmp16 
8f5e				jr nz, .lowalloz 
8f5e			 
8f5e				push hl 
8f5e				push de 
8f5e					ld hl, display_fb0 
8f5e					ld (display_fb_active), hl 
8f5e				call clear_display 
8f5e				ld a, 0 
8f5e				ld de, .malloczero 
8f5e				call str_at_display 
8f5e				call update_display 
8f5e				call delay1s 
8f5e				call delay1s 
8f5e				ld a, 0 
8f5e				ld (os_view_disable), a 
8f5e			 
8f5e				pop de 
8f5e				pop hl 
8f5e			 
8f5e				 
8f5e			 
8f5e				CALLMONITOR 
8f5e			.lowalloz: 
8f5e			 
8f5e			 
8f5e				pop af 
8f5e				pop de 
8f5e				pop hl 
8f5e			ret 
8f5e			 
8f5e			malloc_guard_entry: 
8f5e				push hl 
8f5e				push de 
8f5e				push af 
8f5e			 
8f5e			 	or a      ;clear carry flag 
8f5e				push hl 
8f5e				ld de, 255 
8f5e				sbc hl, de 
8f5e				jr c, .lowalloc 
8f5e			 
8f5e				push de 
8f5e					ld hl, display_fb0 
8f5e					ld (display_fb_active), hl 
8f5e				call clear_display 
8f5e				ld a, 0 
8f5e				ld de, .mallocsize 
8f5e				call str_at_display 
8f5e				call update_display 
8f5e				call delay1s 
8f5e				call delay1s 
8f5e				ld a, 0 
8f5e				ld (os_view_disable), a 
8f5e			 
8f5e				pop de 
8f5e				pop hl 
8f5e			 
8f5e				 
8f5e			 
8f5e				CALLMONITOR 
8f5e				jr .lowdone 
8f5e			.lowalloc: 
8f5e			 
8f5e			 
8f5e				pop hl 
8f5e			.lowdone:	pop af 
8f5e				pop de 
8f5e				pop hl 
8f5e			ret 
8f5e			 
8f5e			malloc_guard_exit: 
8f5e				push hl 
8f5e				push de 
8f5e				push af 
8f5e			 
8f5e			 	or a      ;clear carry flag 
8f5e				push hl 
8f5e				ld de, 255 
8f5e				sbc hl, de 
8f5e				jr c, .lowallocx 
8f5e			 
8f5e				push de 
8f5e					ld hl, display_fb0 
8f5e					ld (display_fb_active), hl 
8f5e				call clear_display 
8f5e				ld a, 0 
8f5e				ld de, .mallocasize 
8f5e				call str_at_display 
8f5e				call update_display 
8f5e				call delay1s 
8f5e				call delay1s 
8f5e				ld a, 0 
8f5e				ld (os_view_disable), a 
8f5e				pop de 
8f5e				pop hl 
8f5e			 
8f5e				CALLMONITOR 
8f5e				jr .lowdonex 
8f5e			.lowallocx: 
8f5e			 
8f5e				pop hl 
8f5e			.lowdonex:	pop af 
8f5e				pop de 
8f5e				pop hl 
8f5e			ret 
8f5e			endif 
8f5e			 
8f5e			if MALLOC_2 
8f5e			; Z80 Malloc and Free Functions 
8f5e			 
8f5e			; Malloc Function: 
8f5e			; Input: 
8f5e			;   HL: Size of block to allocate 
8f5e			; Output: 
8f5e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f5e			 
8f5e			malloc: 
8f5e				 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e			call malloc_guard_entry 
8f5e			endif 
8f5e			 
8f5e			 
8f5e			 
8f5e			 
8f5e					if DEBUG_FORTH_MALLOC 
8f5e						DMARK "mal" 
8f5e						CALLMONITOR 
8f5e					endif 
8f5e			    push af            ; Save AF register 
8f5e			    ld a, l            ; Load low byte of size into A 
8f5e			    or h               ; Check if size is zero 
8f5e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8f5e			 
8f5e			    ; Allocate memory 
8f5e			    ld hl, (heap_start) ; Load start of heap into HL 
8f5e					if DEBUG_FORTH_MALLOC 
8f5e						DMARK "ma1" 
8f5e						CALLMONITOR 
8f5e					endif 
8f5e			    call malloc_internal ; Call internal malloc function 
8f5e			    pop af             ; Restore AF register 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e			call malloc_guard_exit 
8f5e			call malloc_guard_zerolen 
8f5e			endif 
8f5e			    ret                ; Return 
8f5e			 
8f5e			; Free Function: 
8f5e			; Input: 
8f5e			;   HL: Pointer to memory block to free 
8f5e			; Output: 
8f5e			;   None 
8f5e			 
8f5e			free: 
8f5e			    push af            ; Save AF register 
8f5e			    ld a, l            ; Load low byte of pointer into A 
8f5e			    or h               ; Check if pointer is NULL 
8f5e			    jp z, free_exit    ; If pointer is NULL, exit 
8f5e			 
8f5e			    ; Free memory 
8f5e			    ld hl, (heap_start) ; Load start of heap into HL 
8f5e			    call free_internal  ; Call internal free function 
8f5e			    pop af             ; Restore AF register 
8f5e			    ret                ; Return 
8f5e			 
8f5e			; Internal Malloc Function: 
8f5e			; Input: 
8f5e			;   HL: Size of block to allocate 
8f5e			; Output: 
8f5e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f5e			 
8f5e			malloc_internal: 
8f5e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8f5e			    add hl, bc         ; Add management overhead to requested size 
8f5e			    ex de, hl          ; Save total size in DE, and keep it in HL 
8f5e					if DEBUG_FORTH_MALLOC 
8f5e						DMARK "ma2" 
8f5e						CALLMONITOR 
8f5e					endif 
8f5e			 
8f5e			    ; Search for free memory block 
8f5e			    ld de, (heap_end)  ; Load end of heap into DE 
8f5e			    ld bc, 0           ; Initialize counter 
8f5e			 
8f5e					if DEBUG_FORTH_MALLOC 
8f5e						DMARK "ma2" 
8f5e						CALLMONITOR 
8f5e					endif 
8f5e			malloc_search_loop: 
8f5e			    ; Check if current block is free 
8f5e			    ld a, (hl)         ; Load current block's status (free or used) 
8f5e			    cp 0               ; Compare with zero (free) 
8f5e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8f5e			 
8f5e			    ; Check if current block is large enough 
8f5e			    ld a, (hl+1)       ; Load high byte of block size 
8f5e			    cp l               ; Compare with low byte of requested size 
8f5e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8f5e			 
8f5e			    ld a, (hl+2)       ; Load low byte of block size 
8f5e			    cp h               ; Compare with high byte of requested size 
8f5e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8f5e			 
8f5e			    ; Mark block as used 
8f5e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8f5e			 
8f5e			    ; Calculate remaining space in block 
8f5e			    ld bc, 0           ; Clear BC 
8f5e			    add hl, bc         ; Increment HL to point to start of data block 
8f5e			    add hl, de         ; HL = HL + DE (total size) 
8f5e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8f5e			    add hl, bc         ; Add management overhead to start of data block 
8f5e			 
8f5e			    ; Save pointer to allocated block in HL 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e						DMARK "ma5" 
8f5e			call malloc_guard_exit 
8f5e			call malloc_guard_zerolen 
8f5e			endif 
8f5e			    ret 
8f5e			 
8f5e			malloc_skip_block_check: 
8f5e			    ; Move to the next block 
8f5e			    ld bc, 3           ; Size of management overhead 
8f5e			    add hl, bc         ; Move to the next block 
8f5e			    inc de             ; Increment counter 
8f5e			 
8f5e			    ; Check if we have reached the end of heap 
8f5e			    ld a, e            ; Load low byte of heap end address 
8f5e			    cp (hl)            ; Compare with low byte of current address 
8f5e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8f5e			    ld a, d            ; Load high byte of heap end address 
8f5e			    cp 0               ; Check if it's zero (end of memory) 
8f5e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8f5e			 
8f5e			    ; If we reached here, allocation failed 
8f5e			    xor a              ; Set result to NULL 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e						DMARK "ma6" 
8f5e			call malloc_guard_exit 
8f5e			call malloc_guard_zerolen 
8f5e			endif 
8f5e			    ret 
8f5e			malloc_exit: 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e						DMARK "ma7" 
8f5e			call malloc_guard_exit 
8f5e			call malloc_guard_zerolen 
8f5e			endif 
8f5e			    ret 
8f5e			 
8f5e			; Internal Free Function: 
8f5e			; Input: 
8f5e			;   HL: Pointer to memory block to free 
8f5e			; Output: 
8f5e			;   None 
8f5e			 
8f5e			free_internal: 
8f5e			    ld de, (heap_start) ; Load start of heap into DE 
8f5e			    ld bc, 0            ; Initialize counter 
8f5e			 
8f5e			free_search_loop: 
8f5e			    ; Check if current block contains the pointer 
8f5e			    ld a, l             ; Load low byte of pointer 
8f5e			    cp (hl+1)           ; Compare with high byte of current block's address 
8f5e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f5e			    ld a, h             ; Load high byte of pointer 
8f5e			    cp (hl+2)           ; Compare with low byte of current block's address 
8f5e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f5e			 
8f5e			    ; Mark block as free 
8f5e			    ld (hl), 0          ; Set status byte to indicate free block 
8f5e			    ret                 ; Return 
8f5e			 
8f5e			free_skip_block_check: 
8f5e			    ; Move to the next block 
8f5e			    ld bc, 3            ; Size of management overhead 
8f5e			    add hl, bc          ; Move to the next block 
8f5e			    inc de              ; Increment counter 
8f5e			 
8f5e			    ; Check if we have reached the end of heap 
8f5e			    ld a, e             ; Load low byte of heap end address 
8f5e			    cp (hl)             ; Compare with low byte of current address 
8f5e			    jr nz, free_search_loop  ; If not equal, continue searching 
8f5e			    ld a, d             ; Load high byte of heap end address 
8f5e			    cp 0                ; Check if it's zero (end of memory) 
8f5e			    jr nz, free_search_loop  ; If not zero, continue searching 
8f5e			 
8f5e			    ; If we reached here, pointer is not found in heap 
8f5e			    ret 
8f5e			 
8f5e			free_exit: 
8f5e			    ret                 ; Return 
8f5e			 
8f5e			; Define heap start and end addresses 
8f5e			;heap_start:    .dw 0xC000   ; Start of heap 
8f5e			;heap_end:      .dw 0xE000   ; End of heap 
8f5e			 
8f5e			endif 
8f5e			 
8f5e			 
8f5e			if MALLOC_1 
8f5e			 
8f5e			 
8f5e			 
8f5e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8f5e			 
8f5e			;moved to firmware.asm 
8f5e			;heap_start        .equ  0x9000      ; Starting address of heap 
8f5e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f5e			 
8f5e			;      .org 0 
8f5e			;      jp    main 
8f5e			 
8f5e			 
8f5e			;      .org  0x100 
8f5e			;main: 
8f5e			;      ld    HL, 0x8100 
8f5e			;      ld    SP, HL 
8f5e			; 
8f5e			;      call  heap_init 
8f5e			; 
8f5e			;      ; Make some allocations 
8f5e			;      ld    HL, 12 
8f5e			;      call  malloc            ; Allocates 0x9004 
8f5e			; 
8f5e			;      ld    HL, 12 
8f5e			;      call  malloc            ; Allocates 0x9014 
8f5e			; 
8f5e			;      ld    HL, 12 
8f5e			;      call  malloc            ; Allocates 0x9024 
8f5e			; 
8f5e			;      ; Free some allocations 
8f5e			;      ld    HL, 0x9014 
8f5e			;      call  free 
8f5e			; 
8f5e			;      ld    HL, 0x9004 
8f5e			;      call  free 
8f5e			; 
8f5e			;      ld    HL, 0x9024 
8f5e			;      call  free 
8f5e			; 
8f5e			; 
8f5e			;      halt 
8f5e			 
8f5e			 
8f5e			;------------------------------------------------------------------------------ 
8f5e			;     heap_init                                                               : 
8f5e			;                                                                             : 
8f5e			; Description                                                                 : 
8f5e			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f5e			;                                                                             : 
8f5e			;     The heap is maintained as a linked list, starting with an initial       : 
8f5e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f5e			;     the first free block in the heap. Each block then points to the next    : 
8f5e			;     free block within the heap, and the free list ends at the first block   : 
8f5e			;     with a null pointer to the next free block.                             : 
8f5e			;                                                                             : 
8f5e			; Parameters                                                                  : 
8f5e			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f5e			;     address of the heap and its size are required, along with a memory      : 
8f5e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f5e			;     principally stores a pointer to the first free block in the heap.       : 
8f5e			;                                                                             : 
8f5e			; Returns                                                                     : 
8f5e			;     Nothing                                                                 : 
8f5e			;------------------------------------------------------------------------------ 
8f5e			heap_init: 
8f5e e5			      push  HL 
8f5f			 
8f5f			      ; Initialise free list struct 
8f5f 21 84 d7		      ld    HL, heap_start 
8f62 22 7f d7		      ld    (free_list), HL 
8f65 21 00 00		      ld    HL, 0 
8f68 22 81 d7		      ld    (free_list+2), HL 
8f6b			 
8f6b			      ; Insert first free block at bottom of heap, consumes entire heap 
8f6b 21 c8 e4		      ld    HL, heap_start+heap_size-4 
8f6e 22 84 d7		      ld    (heap_start), HL        ; Next block (end of free list) 
8f71 21 44 0d		      ld    HL, heap_size-4 
8f74 22 86 d7		      ld    (heap_start+2), HL      ; Block size 
8f77			 
8f77			      ; Insert end of free list block at top of heap - two null words will 
8f77			      ; terminate the free list 
8f77 21 00 00		      ld    HL, 0 
8f7a 22 ca e4		      ld    (heap_start+heap_size-2), HL 
8f7d 22 c8 e4		      ld    (heap_start+heap_size-4), HL 
8f80			 
8f80 e1			      pop   HL 
8f81			 
8f81 c9			      ret 
8f82			 
8f82			 
8f82			;------------------------------------------------------------------------------ 
8f82			;     malloc                                                                  : 
8f82			;                                                                             : 
8f82			; Description                                                                 : 
8f82			;     Allocates the wanted space from the heap and returns the address of the : 
8f82			;     first useable byte of the allocation.                                   : 
8f82			;                                                                             : 
8f82			;     Allocations can happen in one of two ways:                              : 
8f82			;                                                                             : 
8f82			;     1. A free block may be found which is the exact size wanted. In this    : 
8f82			;        case the block is removed from the free list and retuedn to the      : 
8f82			;        caller.                                                              : 
8f82			;     2. A free block may be found which is larger than the size wanted. In   : 
8f82			;        this case, the larger block is split into two. The first portion of  : 
8f82			;        this block will become the requested space by the malloc call and    : 
8f82			;        is returned to the caller. The second portion becomes a new free     : 
8f82			;        block, and the free list is adjusted to maintain continuity via this : 
8f82			;        newly created block.                                                 : 
8f82			;                                                                             : 
8f82			;     malloc does not set any initial value in the allocated space, the       : 
8f82			;     caller is required to do this as required.                              : 
8f82			;                                                                             : 
8f82			;     This implementation of malloc uses the stack exclusively, and is        : 
8f82			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f82			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f82			;     to avoid the use of malloc inside ISRs in general.                      : 
8f82			;                                                                             : 
8f82			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f82			;                                                                             : 
8f82			; Parameters                                                                  : 
8f82			;     HL  Number of bytes wanted                                              : 
8f82			;                                                                             : 
8f82			; Returns                                                                     : 
8f82			;     HL  Address of the first useable byte of the allocation                 : 
8f82			;                                                                             : 
8f82			; Flags                                                                       : 
8f82			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f82			;                                                                             : 
8f82			; Stack frame                                                                 : 
8f82			;       |             |                                                       : 
8f82			;       +-------------+                                                       : 
8f82			;       |     BC      |                                                       : 
8f82			;       +-------------+                                                       : 
8f82			;       |     DE      |                                                       : 
8f82			;       +-------------+                                                       : 
8f82			;       |     IX      |                                                       : 
8f82			;       +-------------+                                                       : 
8f82			;       |  prev_free  |                                                       : 
8f82			;   +4  +-------------+                                                       : 
8f82			;       |  this_free  |                                                       : 
8f82			;   +2  +-------------+                                                       : 
8f82			;       |  next_free  |                                                       : 
8f82			;   +0  +-------------+                                                       : 
8f82			;       |             |                                                       : 
8f82			;                                                                             : 
8f82			;------------------------------------------------------------------------------ 
8f82			 
8f82			 
8f82			;malloc: 
8f82			; 
8f82			;	SAVESP ON 1 
8f82			; 
8f82			;	call malloc_code 
8f82			; 
8f82			;	CHECKSP ON 1 
8f82			;	ret 
8f82			 
8f82			 
8f82			malloc: 
8f82 c5			      push  BC 
8f83 d5			      push  DE 
8f84 dd e5		      push  IX 
8f86			if DEBUG_FORTH_MALLOC_HIGH 
8f86			call malloc_guard_entry 
8f86			endif 
8f86			 
8f86					if DEBUG_FORTH_MALLOC 
8f86						DMARK "mal" 
8f86						CALLMONITOR 
8f86					endif 
8f86 7c			      ld    A, H                    ; Exit if no space requested 
8f87 b5			      or    L 
8f88 ca 47 90		      jp    Z, malloc_early_exit 
8f8b			 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			; 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			 
8f8b			 
8f8b			 
8f8b			 
8f8b					if DEBUG_FORTH_MALLOC 
8f8b						DMARK "maA" 
8f8b						CALLMONITOR 
8f8b					endif 
8f8b			      ; Set up stack frame 
8f8b eb			      ex    DE, HL 
8f8c 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f8f 39			      add   HL, SP 
8f90 f9			      ld    SP, HL 
8f91 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f95 dd 39		      add   IX, SP 
8f97			 
8f97			      ; Setup initial state 
8f97 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8f9a 19			      add   HL, DE 
8f9b			 
8f9b 44			      ld    B, H                    ; Move want to BC 
8f9c 4d			      ld    C, L 
8f9d			 
8f9d 21 7f d7		      ld    HL, free_list           ; Store prev_free ptr to stack 
8fa0 dd 75 04		      ld    (IX+4), L 
8fa3 dd 74 05		      ld    (IX+5), H 
8fa6			 
8fa6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8fa7 23			      inc   HL 
8fa8 56			      ld    D, (HL) 
8fa9 dd 73 02		      ld    (IX+2), E 
8fac dd 72 03		      ld    (IX+3), D 
8faf eb			      ex    DE, HL                  ; this_free ptr into HL 
8fb0			 
8fb0					if DEBUG_FORTH_MALLOC 
8fb0						DMARK "maB" 
8fb0						CALLMONITOR 
8fb0					endif 
8fb0			      ; Loop through free block list to find some space 
8fb0			malloc_find_space: 
8fb0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8fb1 23			      inc   HL 
8fb2 56			      ld    D, (HL) 
8fb3			 
8fb3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8fb4 b3			      or    E 
8fb5 ca 41 90		      jp    Z, malloc_no_space 
8fb8			 
8fb8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8fbb dd 72 01		      ld    (IX+1), D 
8fbe			 
8fbe			      ; Does this block have enough space to make the allocation? 
8fbe 23			      inc   HL                      ; Load free block size into DE 
8fbf 5e			      ld    E, (HL) 
8fc0 23			      inc   HL 
8fc1 56			      ld    D, (HL) 
8fc2			 
8fc2 eb			      ex    DE, HL                  ; Check size of block against want 
8fc3 b7			      or    A                       ; Ensure carry flag clear 
8fc4 ed 42		      sbc   HL, BC 
8fc6 e5			      push  HL                      ; Store the result for later (new block size) 
8fc7			 
8fc7 ca 16 90		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8fca 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8fcc			 
8fcc			      ; this_free block is not big enough, setup ptrs to test next free block 
8fcc e1			      pop   HL                      ; Discard previous result 
8fcd			 
8fcd dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8fd0 dd 66 03		      ld    H, (IX+3) 
8fd3 dd 75 04		      ld    (IX+4), L 
8fd6 dd 74 05		      ld    (IX+5), H 
8fd9			 
8fd9 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8fdc dd 66 01		      ld    H, (IX+1) 
8fdf dd 75 02		      ld    (IX+2), L 
8fe2 dd 74 03		      ld    (IX+3), H 
8fe5			 
8fe5					if DEBUG_FORTH_MALLOC 
8fe5						DMARK "MA>" 
8fe5						CALLMONITOR 
8fe5					endif 
8fe5 18 c9		      jr    malloc_find_space 
8fe7			 
8fe7			      ; split a bigger block into two - requested size and remaining size 
8fe7			malloc_alloc_split: 
8fe7					if DEBUG_FORTH_MALLOC 
8fe7						DMARK "MAs" 
8fe7						CALLMONITOR 
8fe7					endif 
8fe7 eb			      ex    DE, HL                  ; Calculate address of new free block 
8fe8 2b			      dec   HL 
8fe9 2b			      dec   HL 
8fea 2b			      dec   HL 
8feb 09			      add   HL, BC 
8fec			 
8fec			      ; Create a new block and point it at next_free 
8fec dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8fef dd 56 01		      ld    D, (IX+1) 
8ff2			 
8ff2 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8ff3 23			      inc   HL 
8ff4 72			      ld    (HL), D 
8ff5			 
8ff5 d1			      pop   DE                      ; Store size of new block into new block 
8ff6 23			      inc   HL 
8ff7 73			      ld    (HL), E 
8ff8 23			      inc   HL 
8ff9 72			      ld    (HL), D 
8ffa			 
8ffa			      ; Update this_free ptr to point to new block 
8ffa 2b			      dec   HL 
8ffb 2b			      dec   HL 
8ffc 2b			      dec   HL 
8ffd			 
8ffd dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9000 dd 56 03		      ld    D, (IX+3) 
9003			 
9003 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9006 dd 74 03		      ld    (IX+3), H 
9009			 
9009			      ; Modify this_free block to be allocation 
9009 eb			      ex    DE, HL 
900a af			      xor   A                       ; Null the next block ptr of allocated block 
900b 77			      ld    (HL), A 
900c 23			      inc   HL 
900d 77			      ld    (HL), A 
900e			 
900e 23			      inc   HL                      ; Store want size into allocated block 
900f 71			      ld    (HL), C 
9010 23			      inc   HL 
9011 70			      ld    (HL), B 
9012 23			      inc   HL 
9013 e5			      push  HL                      ; Address of allocation to return 
9014			 
9014 18 19		      jr    malloc_update_links 
9016			 
9016			malloc_alloc_fit: 
9016 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9017			 
9017					if DEBUG_FORTH_MALLOC 
9017						DMARK "MAf" 
9017						CALLMONITOR 
9017					endif 
9017			      ; Modify this_free block to be allocation 
9017 eb			      ex    DE, HL 
9018 2b			      dec   HL 
9019 2b			      dec   HL 
901a 2b			      dec   HL 
901b			 
901b af			      xor   A                       ; Null the next block ptr of allocated block 
901c 77			      ld    (HL), A 
901d 23			      inc   HL 
901e 77			      ld    (HL), A 
901f			 
901f 23			      inc   HL                      ; Store address of allocation to return 
9020 23			      inc   HL 
9021 23			      inc   HL 
9022 e5			      push  HL 
9023			 
9023			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9023 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9026 dd 66 01		      ld    H, (IX+1) 
9029			 
9029 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
902c dd 74 03		      ld    (IX+3), H 
902f			 
902f			 
902f			malloc_update_links: 
902f			      ; Update prev_free ptr to point to this_free 
902f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9032 dd 66 05		      ld    H, (IX+5) 
9035			 
9035 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9038 dd 56 03		      ld    D, (IX+3) 
903b			 
903b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
903c 23			      inc   HL 
903d 72			      ld    (HL), D 
903e			 
903e					if DEBUG_FORTH_MALLOC 
903e						DMARK "Mul" 
903e						CALLMONITOR 
903e					endif 
903e			      ; Clear the Z flag to indicate successful allocation 
903e 7a			      ld    A, D 
903f b3			      or    E 
9040			 
9040 d1			      pop   DE                      ; Address of allocation 
9041					if DEBUG_FORTH_MALLOC 
9041						DMARK "MAu" 
9041						CALLMONITOR 
9041					endif 
9041			 
9041			malloc_no_space: 
9041 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9044 39			      add   HL, SP 
9045 f9			      ld    SP, HL 
9046			 
9046 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9047					if DEBUG_FORTH_MALLOC 
9047						DMARK "MAN" 
9047						CALLMONITOR 
9047					endif 
9047			 
9047			malloc_early_exit: 
9047					if DEBUG_FORTH_MALLOC 
9047						DMARK "MAx" 
9047						CALLMONITOR 
9047					endif 
9047 dd e1		      pop   IX 
9049 d1			      pop   DE 
904a c1			      pop   BC 
904b			 
904b			if DEBUG_FORTH_MALLOC_HIGH 
904b			call malloc_guard_exit 
904b			call malloc_guard_zerolen 
904b			endif 
904b c9			      ret 
904c			 
904c			 
904c			;------------------------------------------------------------------------------ 
904c			;     free                                                                    : 
904c			;                                                                             : 
904c			; Description                                                                 : 
904c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
904c			;     returned by malloc, otherwise the behaviour is undefined.               : 
904c			;                                                                             : 
904c			;     Where possible, directly adjacent free blocks will be merged together   : 
904c			;     into larger blocks to help ensure that the heap does not become         : 
904c			;     excessively fragmented.                                                 : 
904c			;                                                                             : 
904c			;     free does not clear or set any other value into the freed space, and    : 
904c			;     therefore its contents may be visible through subsequent malloc's. The  : 
904c			;     caller should clear the freed space as required.                        : 
904c			;                                                                             : 
904c			;     This implementation of free uses the stack exclusively, and is          : 
904c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
904c			;     advisable to disable interrupts before calling free, and recommended    : 
904c			;     to avoid the use of free inside ISRs in general.                        : 
904c			;                                                                             : 
904c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
904c			;                                                                             : 
904c			; Parameters                                                                  : 
904c			;     HL  Pointer to address of first byte of allocation to be freed          : 
904c			;                                                                             : 
904c			; Returns                                                                     : 
904c			;     Nothing                                                                 : 
904c			;                                                                             : 
904c			; Stack frame                                                                 : 
904c			;       |             |                                                       : 
904c			;       +-------------+                                                       : 
904c			;       |     BC      |                                                       : 
904c			;       +-------------+                                                       : 
904c			;       |     DE      |                                                       : 
904c			;       +-------------+                                                       : 
904c			;       |     IX      |                                                       : 
904c			;       +-------------+                                                       : 
904c			;       |  prev_free  |                                                       : 
904c			;   +2  +-------------+                                                       : 
904c			;       |  next_free  |                                                       : 
904c			;   +0  +-------------+                                                       : 
904c			;       |             |                                                       : 
904c			;                                                                             : 
904c			;------------------------------------------------------------------------------ 
904c			free: 
904c c5			      push  BC 
904d d5			      push  DE 
904e dd e5		      push  IX 
9050			 
9050 7c			      ld    A, H                    ; Exit if ptr is null 
9051 b5			      or    L 
9052 ca 16 91		      jp    Z, free_early_exit 
9055			 
9055			      ; Set up stack frame 
9055 eb			      ex    DE, HL 
9056 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9059 39			      add   HL, SP 
905a f9			      ld    SP, HL 
905b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
905f dd 39		      add   IX, SP 
9061			 
9061			      ; The address in HL points to the start of the useable allocated space, 
9061			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9061			      ; address of the block itself. 
9061 eb			      ex    DE, HL 
9062 11 fc ff		      ld    DE, -4 
9065 19			      add   HL, DE 
9066			 
9066			      ; An allocated block must have a null next block pointer in it 
9066 7e			      ld    A, (HL) 
9067 23			      inc   HL 
9068 b6			      or    (HL) 
9069 c2 11 91		      jp    NZ, free_done 
906c			 
906c 2b			      dec   HL 
906d			 
906d 44			      ld    B, H                    ; Copy HL to BC 
906e 4d			      ld    C, L 
906f			 
906f			      ; Loop through the free list to find the first block with an address 
906f			      ; higher than the block being freed 
906f 21 7f d7		      ld    HL, free_list 
9072			 
9072			free_find_higher_block: 
9072 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9073 23			      inc   HL 
9074 56			      ld    D, (HL) 
9075 2b			      dec   HL 
9076			 
9076 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9079 dd 72 01		      ld    (IX+1), D 
907c dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
907f dd 74 03		      ld    (IX+3), H 
9082			 
9082 78			      ld    A, B                    ; Check if DE is greater than BC 
9083 ba			      cp    D                       ; Compare MSB first 
9084 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9086 30 04		      jr    NC, free_find_higher_block_skip 
9088 79			      ld    A, C 
9089 bb			      cp    E                       ; Then compare LSB 
908a 38 08		      jr    C, free_found_higher_block 
908c			 
908c			free_find_higher_block_skip: 
908c 7a			      ld    A, D                    ; Reached the end of the free list? 
908d b3			      or    E 
908e ca 11 91		      jp    Z, free_done 
9091			 
9091 eb			      ex    DE, HL 
9092			 
9092 18 de		      jr    free_find_higher_block 
9094			 
9094			free_found_higher_block: 
9094			      ; Insert freed block between prev and next free blocks 
9094 71			      ld    (HL), C                 ; Point prev free block to freed block 
9095 23			      inc   HL 
9096 70			      ld    (HL), B 
9097			 
9097 60			      ld    H, B                    ; Point freed block at next free block 
9098 69			      ld    L, C 
9099 73			      ld    (HL), E 
909a 23			      inc   HL 
909b 72			      ld    (HL), D 
909c			 
909c			      ; Check if the freed block is adjacent to the next free block 
909c 23			      inc   HL                      ; Load size of freed block into HL 
909d 5e			      ld    E, (HL) 
909e 23			      inc   HL 
909f 56			      ld    D, (HL) 
90a0 eb			      ex    DE, HL 
90a1			 
90a1 09			      add   HL, BC                  ; Add addr of freed block and its size 
90a2			 
90a2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
90a5 dd 56 01		      ld    D, (IX+1) 
90a8			 
90a8 b7			      or    A                       ; Clear the carry flag 
90a9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
90ab 20 22		      jr    NZ, free_check_adjacent_to_prev 
90ad			 
90ad			      ; Freed block is adjacent to next, merge into one bigger block 
90ad eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
90ae 5e			      ld    E, (HL) 
90af 23			      inc   HL 
90b0 56			      ld    D, (HL) 
90b1 e5			      push  HL                      ; Save ptr to next block for later 
90b2			 
90b2 60			      ld    H, B                    ; Store ptr from next block into freed block 
90b3 69			      ld    L, C 
90b4 73			      ld    (HL), E 
90b5 23			      inc   HL 
90b6 72			      ld    (HL), D 
90b7			 
90b7 e1			      pop   HL                      ; Restore ptr to next block 
90b8 23			      inc   HL                      ; Load size of next block into DE 
90b9 5e			      ld    E, (HL) 
90ba 23			      inc   HL 
90bb 56			      ld    D, (HL) 
90bc d5			      push  DE                      ; Save next block size for later 
90bd			 
90bd 60			      ld    H, B                    ; Load size of freed block into HL 
90be 69			      ld    L, C 
90bf 23			      inc   HL 
90c0 23			      inc   HL 
90c1 5e			      ld    E, (HL) 
90c2 23			      inc   HL 
90c3 56			      ld    D, (HL) 
90c4 eb			      ex    DE, HL 
90c5			 
90c5 d1			      pop   DE                      ; Restore size of next block 
90c6 19			      add   HL, DE                  ; Add sizes of both blocks 
90c7 eb			      ex    DE, HL 
90c8			 
90c8 60			      ld    H, B                    ; Store new bigger size into freed block 
90c9 69			      ld    L, C 
90ca 23			      inc   HL 
90cb 23			      inc   HL 
90cc 73			      ld    (HL), E 
90cd 23			      inc   HL 
90ce 72			      ld    (HL), D 
90cf			 
90cf			free_check_adjacent_to_prev: 
90cf			      ; Check if the freed block is adjacent to the prev free block 
90cf dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
90d2 dd 66 03		      ld    H, (IX+3) 
90d5			 
90d5 23			      inc   HL                      ; Size of prev free block into DE 
90d6 23			      inc   HL 
90d7 5e			      ld    E, (HL) 
90d8 23			      inc   HL 
90d9 56			      ld    D, (HL) 
90da 2b			      dec   HL 
90db 2b			      dec   HL 
90dc 2b			      dec   HL 
90dd			 
90dd 19			      add   HL, DE                  ; Add prev block addr and size 
90de			 
90de b7			      or    A                       ; Clear the carry flag 
90df ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
90e1 20 2e		      jr    NZ, free_done 
90e3			 
90e3			      ; Freed block is adjacent to prev, merge into one bigger block 
90e3 60			      ld    H, B                    ; Load next ptr from freed block into DE 
90e4 69			      ld    L, C 
90e5 5e			      ld    E, (HL) 
90e6 23			      inc   HL 
90e7 56			      ld    D, (HL) 
90e8 e5			      push  HL                      ; Save freed block ptr for later 
90e9			 
90e9 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
90ec dd 66 03		      ld    H, (IX+3) 
90ef 73			      ld    (HL), E 
90f0 23			      inc   HL 
90f1 72			      ld    (HL), D 
90f2			 
90f2 e1			      pop   HL                      ; Restore freed block ptr 
90f3 23			      inc   HL                      ; Load size of freed block into DE 
90f4 5e			      ld    E, (HL) 
90f5 23			      inc   HL 
90f6 56			      ld    D, (HL) 
90f7 d5			      push  DE                      ; Save freed block size for later 
90f8			 
90f8 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
90fb dd 66 03		      ld    H, (IX+3) 
90fe 23			      inc   HL 
90ff 23			      inc   HL 
9100 5e			      ld    E, (HL) 
9101 23			      inc   HL 
9102 56			      ld    D, (HL) 
9103			 
9103 e1			      pop   HL                      ; Add sizes of both blocks 
9104 19			      add   HL, DE 
9105 eb			      ex    DE, HL 
9106			 
9106 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9109 dd 66 03		      ld    H, (IX+3) 
910c 23			      inc   HL 
910d 23			      inc   HL 
910e 73			      ld    (HL), E 
910f 23			      inc   HL 
9110 72			      ld    (HL), D 
9111			 
9111			free_done: 
9111 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9114 39			      add   HL, SP 
9115 f9			      ld    SP, HL 
9116			 
9116			free_early_exit: 
9116 dd e1		      pop   IX 
9118 d1			      pop   DE 
9119 c1			      pop   BC 
911a			 
911a c9			      ret 
911b			 
911b			; moved to firmware.asm 
911b			; 
911b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
911b			;                  .dw   0 
911b			 
911b			 
911b			endif 
911b			 
911b			 
911b			if MALLOC_3 
911b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
911b			;heap_start        .equ  0x9000      ; Starting address of heap 
911b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
911b			; 
911b			 ;     .org 0 
911b			  ;    jp    main 
911b			; 
911b			; 
911b			 ;     .org  0x100 
911b			;main: 
911b			 ;     ld    HL, 0x8100 
911b			  ;    ld    SP, HL 
911b			; 
911b			;      call  heap_init 
911b			 
911b			      ; Make some allocations 
911b			;      ld    HL, 12 
911b			;      call  malloc            ; Allocates 0x9004 
911b			; 
911b			 ;     ld    HL, 12 
911b			;      call  malloc            ; Allocates 0x9014 
911b			 
911b			;      ld    HL, 12 
911b			;      call  malloc            ; Allocates 0x9024 
911b			 
911b			      ; Free some allocations 
911b			;      ld    HL, 0x9014 
911b			;      call  free 
911b			 
911b			;      ld    HL, 0x9004 
911b			;      call  free 
911b			; 
911b			;      ld    HL, 0x9024 
911b			;      call  free 
911b			 
911b			 
911b			 ;     halt 
911b			 
911b			 
911b			;------------------------------------------------------------------------------ 
911b			;     heap_init                                                               : 
911b			;                                                                             : 
911b			; Description                                                                 : 
911b			;     Initialise the heap and make it ready for malloc and free operations.   : 
911b			;                                                                             : 
911b			;     The heap is maintained as a linked list, starting with an initial       : 
911b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
911b			;     the first free block in the heap. Each block then points to the next    : 
911b			;     free block within the heap, and the free list ends at the first block   : 
911b			;     with a null pointer to the next free block.                             : 
911b			;                                                                             : 
911b			; Parameters                                                                  : 
911b			;     Inputs are compile-time only. Two defines which specify the starting    : 
911b			;     address of the heap and its size are required, along with a memory      : 
911b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
911b			;     principally stores a pointer to the first free block in the heap.       : 
911b			;                                                                             : 
911b			; Returns                                                                     : 
911b			;     Nothing                                                                 : 
911b			;------------------------------------------------------------------------------ 
911b			heap_init: 
911b			      push  HL 
911b			 
911b			      ; Initialise free list struct 
911b			      ld    HL, heap_start 
911b			      ld    (free_list), HL 
911b			      ld    HL, 0 
911b			      ld    (free_list+2), HL 
911b			 
911b			      ; Insert first free block at bottom of heap, consumes entire heap 
911b			      ld    HL, heap_start+heap_size-4 
911b			      ld    (heap_start), HL        ; Next block (end of free list) 
911b			      ld    HL, heap_size-4 
911b			      ld    (heap_start+2), HL      ; Block size 
911b			 
911b			      ; Insert end of free list block at top of heap - two null words will 
911b			      ; terminate the free list 
911b			      ld    HL, 0 
911b			      ld    (heap_start+heap_size-2), HL 
911b			      ld    (heap_start+heap_size-4), HL 
911b			 
911b			      pop   HL 
911b			 
911b			      ret 
911b			 
911b			 
911b			;------------------------------------------------------------------------------ 
911b			;     malloc                                                                  : 
911b			;                                                                             : 
911b			; Description                                                                 : 
911b			;     Allocates the wanted space from the heap and returns the address of the : 
911b			;     first useable byte of the allocation.                                   : 
911b			;                                                                             : 
911b			;     Allocations can happen in one of two ways:                              : 
911b			;                                                                             : 
911b			;     1. A free block may be found which is the exact size wanted. In this    : 
911b			;        case the block is removed from the free list and retuedn to the      : 
911b			;        caller.                                                              : 
911b			;     2. A free block may be found which is larger than the size wanted. In   : 
911b			;        this case, the larger block is split into two. The first portion of  : 
911b			;        this block will become the requested space by the malloc call and    : 
911b			;        is returned to the caller. The second portion becomes a new free     : 
911b			;        block, and the free list is adjusted to maintain continuity via this : 
911b			;        newly created block.                                                 : 
911b			;                                                                             : 
911b			;     malloc does not set any initial value in the allocated space, the       : 
911b			;     caller is required to do this as required.                              : 
911b			;                                                                             : 
911b			;     This implementation of malloc uses the stack exclusively, and is        : 
911b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
911b			;     advisable to disable interrupts before calling malloc, and recommended  : 
911b			;     to avoid the use of malloc inside ISRs in general.                      : 
911b			;                                                                             : 
911b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
911b			;                                                                             : 
911b			; Parameters                                                                  : 
911b			;     HL  Number of bytes wanted                                              : 
911b			;                                                                             : 
911b			; Returns                                                                     : 
911b			;     HL  Address of the first useable byte of the allocation                 : 
911b			;                                                                             : 
911b			; Flags                                                                       : 
911b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
911b			;                                                                             : 
911b			; Stack frame                                                                 : 
911b			;       |             |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     BC      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     DE      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     IX      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |  prev_free  |                                                       : 
911b			;   +4  +-------------+                                                       : 
911b			;       |  this_free  |                                                       : 
911b			;   +2  +-------------+                                                       : 
911b			;       |  next_free  |                                                       : 
911b			;   +0  +-------------+                                                       : 
911b			;       |             |                                                       : 
911b			;                                                                             : 
911b			;------------------------------------------------------------------------------ 
911b			malloc: 
911b			      push  BC 
911b			      push  DE 
911b			      push  IX 
911b			 
911b			      ld    A, H                    ; Exit if no space requested 
911b			      or    L 
911b			      jp    Z, malloc_early_exit 
911b			 
911b			      ; Set up stack frame 
911b			      ex    DE, HL 
911b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
911b			      add   HL, SP 
911b			      ld    SP, HL 
911b			      ld    IX, 0                   ; Use IX as a frame pointer 
911b			      add   IX, SP 
911b			 
911b			      ; Setup initial state 
911b			      ld    HL, 4                   ; want must also include space used by block struct 
911b			      add   HL, DE 
911b			 
911b			      ld    B, H                    ; Move want to BC 
911b			      ld    C, L 
911b			 
911b			      ld    HL, free_list           ; Store prev_free ptr to stack 
911b			      ld    (IX+4), L 
911b			      ld    (IX+5), H 
911b			 
911b			      ld    E, (HL)                 ; Store this_free ptr to stack 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      ld    (IX+2), E 
911b			      ld    (IX+3), D 
911b			      ex    DE, HL                  ; this_free ptr into HL 
911b			 
911b			      ; Loop through free block list to find some space 
911b			malloc_find_space: 
911b			      ld    E, (HL)                 ; Load next_free ptr into DE 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			 
911b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
911b			      or    E 
911b			      jp    Z, malloc_no_space 
911b			 
911b			      ld    (IX+0), E               ; Store next_free ptr to stack 
911b			      ld    (IX+1), D 
911b			 
911b			      ; Does this block have enough space to make the allocation? 
911b			      inc   HL                      ; Load free block size into DE 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			 
911b			      ex    DE, HL                  ; Check size of block against want 
911b			      or    A                       ; Ensure carry flag clear 
911b			      sbc   HL, BC 
911b			      push  HL                      ; Store the result for later (new block size) 
911b			 
911b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
911b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
911b			 
911b			      ; this_free block is not big enough, setup ptrs to test next free block 
911b			      pop   HL                      ; Discard previous result 
911b			 
911b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
911b			      ld    H, (IX+3) 
911b			      ld    (IX+4), L 
911b			      ld    (IX+5), H 
911b			 
911b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
911b			      ld    H, (IX+1) 
911b			      ld    (IX+2), L 
911b			      ld    (IX+3), H 
911b			 
911b			      jr    malloc_find_space 
911b			 
911b			      ; split a bigger block into two - requested size and remaining size 
911b			malloc_alloc_split: 
911b			      ex    DE, HL                  ; Calculate address of new free block 
911b			      dec   HL 
911b			      dec   HL 
911b			      dec   HL 
911b			      add   HL, BC 
911b			 
911b			      ; Create a new block and point it at next_free 
911b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
911b			      ld    D, (IX+1) 
911b			 
911b			      ld    (HL), E                 ; Store next_free ptr into new block 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      pop   DE                      ; Store size of new block into new block 
911b			      inc   HL 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      ; Update this_free ptr to point to new block 
911b			      dec   HL 
911b			      dec   HL 
911b			      dec   HL 
911b			 
911b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
911b			      ld    D, (IX+3) 
911b			 
911b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
911b			      ld    (IX+3), H 
911b			 
911b			      ; Modify this_free block to be allocation 
911b			      ex    DE, HL 
911b			      xor   A                       ; Null the next block ptr of allocated block 
911b			      ld    (HL), A 
911b			      inc   HL 
911b			      ld    (HL), A 
911b			 
911b			      inc   HL                      ; Store want size into allocated block 
911b			      ld    (HL), C 
911b			      inc   HL 
911b			      ld    (HL), B 
911b			      inc   HL 
911b			      push  HL                      ; Address of allocation to return 
911b			 
911b			      jr    malloc_update_links 
911b			 
911b			malloc_alloc_fit: 
911b			      pop   HL                      ; Dont need new block size, want is exact fit 
911b			 
911b			      ; Modify this_free block to be allocation 
911b			      ex    DE, HL 
911b			      dec   HL 
911b			      dec   HL 
911b			      dec   HL 
911b			 
911b			      xor   A                       ; Null the next block ptr of allocated block 
911b			      ld    (HL), A 
911b			      inc   HL 
911b			      ld    (HL), A 
911b			 
911b			      inc   HL                      ; Store address of allocation to return 
911b			      inc   HL 
911b			      inc   HL 
911b			      push  HL 
911b			 
911b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
911b			      ld    L, (IX+0)               ; next_free to HL 
911b			      ld    H, (IX+1) 
911b			 
911b			      ld    (IX+2), L               ; HL to this_free 
911b			      ld    (IX+3), H 
911b			 
911b			 
911b			malloc_update_links: 
911b			      ; Update prev_free ptr to point to this_free 
911b			      ld    L, (IX+4)               ; prev_free ptr to HL 
911b			      ld    H, (IX+5) 
911b			 
911b			      ld    E, (IX+2)               ; this_free ptr to DE 
911b			      ld    D, (IX+3) 
911b			 
911b			      ld    (HL), E                 ; this_free ptr into prev_free 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      ; Clear the Z flag to indicate successful allocation 
911b			      ld    A, D 
911b			      or    E 
911b			 
911b			      pop   DE                      ; Address of allocation 
911b			 
911b			malloc_no_space: 
911b			      ld    HL, 6                   ; Clean up stack frame 
911b			      add   HL, SP 
911b			      ld    SP, HL 
911b			 
911b			      ex    DE, HL                  ; Alloc addr into HL for return 
911b			 
911b			malloc_early_exit: 
911b			      pop   IX 
911b			      pop   DE 
911b			      pop   BC 
911b			 
911b			      ret 
911b			 
911b			 
911b			;------------------------------------------------------------------------------ 
911b			;     free                                                                    : 
911b			;                                                                             : 
911b			; Description                                                                 : 
911b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
911b			;     returned by malloc, otherwise the behaviour is undefined.               : 
911b			;                                                                             : 
911b			;     Where possible, directly adjacent free blocks will be merged together   : 
911b			;     into larger blocks to help ensure that the heap does not become         : 
911b			;     excessively fragmented.                                                 : 
911b			;                                                                             : 
911b			;     free does not clear or set any other value into the freed space, and    : 
911b			;     therefore its contents may be visible through subsequent malloc's. The  : 
911b			;     caller should clear the freed space as required.                        : 
911b			;                                                                             : 
911b			;     This implementation of free uses the stack exclusively, and is          : 
911b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
911b			;     advisable to disable interrupts before calling free, and recommended    : 
911b			;     to avoid the use of free inside ISRs in general.                        : 
911b			;                                                                             : 
911b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
911b			;                                                                             : 
911b			; Parameters                                                                  : 
911b			;     HL  Pointer to address of first byte of allocation to be freed          : 
911b			;                                                                             : 
911b			; Returns                                                                     : 
911b			;     Nothing                                                                 : 
911b			;                                                                             : 
911b			; Stack frame                                                                 : 
911b			;       |             |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     BC      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     DE      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     IX      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |  prev_free  |                                                       : 
911b			;   +2  +-------------+                                                       : 
911b			;       |  next_free  |                                                       : 
911b			;   +0  +-------------+                                                       : 
911b			;       |             |                                                       : 
911b			;                                                                             : 
911b			;------------------------------------------------------------------------------ 
911b			free: 
911b			      push  BC 
911b			      push  DE 
911b			      push  IX 
911b			 
911b			      ld    A, H                    ; Exit if ptr is null 
911b			      or    L 
911b			      jp    Z, free_early_exit 
911b			 
911b			      ; Set up stack frame 
911b			      ex    DE, HL 
911b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
911b			      add   HL, SP 
911b			      ld    SP, HL 
911b			      ld    IX, 0                   ; Use IX as a frame pointer 
911b			      add   IX, SP 
911b			 
911b			      ; The address in HL points to the start of the useable allocated space, 
911b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
911b			      ; address of the block itself. 
911b			      ex    DE, HL 
911b			      ld    DE, -4 
911b			      add   HL, DE 
911b			 
911b			      ; An allocated block must have a null next block pointer in it 
911b			      ld    A, (HL) 
911b			      inc   HL 
911b			      or    (HL) 
911b			      jp    NZ, free_done 
911b			 
911b			      dec   HL 
911b			 
911b			      ld    B, H                    ; Copy HL to BC 
911b			      ld    C, L 
911b			 
911b			      ; Loop through the free list to find the first block with an address 
911b			      ; higher than the block being freed 
911b			      ld    HL, free_list 
911b			 
911b			free_find_higher_block: 
911b			      ld    E, (HL)                 ; Load next ptr from free block 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      dec   HL 
911b			 
911b			      ld    (IX+0), E               ; Save ptr to next free block 
911b			      ld    (IX+1), D 
911b			      ld    (IX+2), L               ; Save ptr to prev free block 
911b			      ld    (IX+3), H 
911b			 
911b			      ld    A, B                    ; Check if DE is greater than BC 
911b			      cp    D                       ; Compare MSB first 
911b			      jr    Z, $+4                  ; MSB the same, compare LSB 
911b			      jr    NC, free_find_higher_block_skip 
911b			      ld    A, C 
911b			      cp    E                       ; Then compare LSB 
911b			      jr    C, free_found_higher_block 
911b			 
911b			free_find_higher_block_skip: 
911b			      ld    A, D                    ; Reached the end of the free list? 
911b			      or    E 
911b			      jp    Z, free_done 
911b			 
911b			      ex    DE, HL 
911b			 
911b			      jr    free_find_higher_block 
911b			 
911b			free_found_higher_block: 
911b			      ; Insert freed block between prev and next free blocks 
911b			      ld    (HL), C                 ; Point prev free block to freed block 
911b			      inc   HL 
911b			      ld    (HL), B 
911b			 
911b			      ld    H, B                    ; Point freed block at next free block 
911b			      ld    L, C 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      ; Check if the freed block is adjacent to the next free block 
911b			      inc   HL                      ; Load size of freed block into HL 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      ex    DE, HL 
911b			 
911b			      add   HL, BC                  ; Add addr of freed block and its size 
911b			 
911b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
911b			      ld    D, (IX+1) 
911b			 
911b			      or    A                       ; Clear the carry flag 
911b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
911b			      jr    NZ, free_check_adjacent_to_prev 
911b			 
911b			      ; Freed block is adjacent to next, merge into one bigger block 
911b			      ex    DE, HL                  ; Load next ptr from next block into DE 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      push  HL                      ; Save ptr to next block for later 
911b			 
911b			      ld    H, B                    ; Store ptr from next block into freed block 
911b			      ld    L, C 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      pop   HL                      ; Restore ptr to next block 
911b			      inc   HL                      ; Load size of next block into DE 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      push  DE                      ; Save next block size for later 
911b			 
911b			      ld    H, B                    ; Load size of freed block into HL 
911b			      ld    L, C 
911b			      inc   HL 
911b			      inc   HL 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      ex    DE, HL 
911b			 
911b			      pop   DE                      ; Restore size of next block 
911b			      add   HL, DE                  ; Add sizes of both blocks 
911b			      ex    DE, HL 
911b			 
911b			      ld    H, B                    ; Store new bigger size into freed block 
911b			      ld    L, C 
911b			      inc   HL 
911b			      inc   HL 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			free_check_adjacent_to_prev: 
911b			      ; Check if the freed block is adjacent to the prev free block 
911b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
911b			      ld    H, (IX+3) 
911b			 
911b			      inc   HL                      ; Size of prev free block into DE 
911b			      inc   HL 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      dec   HL 
911b			      dec   HL 
911b			      dec   HL 
911b			 
911b			      add   HL, DE                  ; Add prev block addr and size 
911b			 
911b			      or    A                       ; Clear the carry flag 
911b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
911b			      jr    NZ, free_done 
911b			 
911b			      ; Freed block is adjacent to prev, merge into one bigger block 
911b			      ld    H, B                    ; Load next ptr from freed block into DE 
911b			      ld    L, C 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      push  HL                      ; Save freed block ptr for later 
911b			 
911b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
911b			      ld    H, (IX+3) 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      pop   HL                      ; Restore freed block ptr 
911b			      inc   HL                      ; Load size of freed block into DE 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      push  DE                      ; Save freed block size for later 
911b			 
911b			      ld    L, (IX+2)               ; Load size of prev block into DE 
911b			      ld    H, (IX+3) 
911b			      inc   HL 
911b			      inc   HL 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			 
911b			      pop   HL                      ; Add sizes of both blocks 
911b			      add   HL, DE 
911b			      ex    DE, HL 
911b			 
911b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
911b			      ld    H, (IX+3) 
911b			      inc   HL 
911b			      inc   HL 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			free_done: 
911b			      ld    HL, 4                   ; Clean up stack frame 
911b			      add   HL, SP 
911b			      ld    SP, HL 
911b			 
911b			free_early_exit: 
911b			      pop   IX 
911b			      pop   DE 
911b			      pop   BC 
911b			 
911b			      ret 
911b			 
911b			 
911b			;      .org 0x8000 
911b			; 
911b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
911b			 ;                 .dw   0 
911b			 
911b			endif 
911b			 
911b			 
911b			if MALLOC_4 
911b			 
911b			; My memory allocation code. Very very simple.... 
911b			; allocate space under 250 chars 
911b			 
911b			heap_init: 
911b				; init start of heap as zero 
911b				;  
911b			 
911b				ld hl, heap_start 
911b				ld a, 0 
911b				ld (hl), a      ; empty block 
911b				inc hl 
911b				ld a, 0 
911b				ld (hl), a      ; length of block 
911b				; write end of list 
911b				inc hl 
911b				ld a,(hl) 
911b				inc hl 
911b				ld a,(hl) 
911b				 
911b			 
911b				; init some malloc vars 
911b			 
911b				ld hl, 0 
911b				ld (free_list), hl       ; store last malloc location 
911b			 
911b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
911b				ld a, 0 
911b				ld (hl), a 
911b			 
911b			 
911b				ld hl, heap_start 
911b				;  
911b				  
911b				ret 
911b			 
911b			 
911b			;    free block marker 
911b			;    requested size  
911b			;    pointer to next block 
911b			;    .... 
911b			;    next block marker 
911b			 
911b			 
911b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
911b			; 
911b			 
911b			 
911b			malloc:  
911b				push de 
911b				push bc 
911b				push af 
911b			 
911b				; hl space required 
911b				 
911b				ld c, l    ; hold space   (TODO only a max of 255) 
911b			 
911b			;	inc c     ; TODO BUG need to fix memory leak on push str 
911b			;	inc c 
911b			;	inc c 
911b			;	inc c 
911b			;	inc c 
911b			;	inc c 
911b			;	inc c 
911b			 
911b			 
911b			 
911b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
911b			 
911b				ld a, (free_list+3) 
911b				cp 0 
911b				jr z, .contheap 
911b			 
911b				ld hl, (free_list)     ; get last alloc 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "mrs" 
911b						CALLMONITOR 
911b					endif 
911b				jr .startalloc 
911b			 
911b			.contheap: 
911b				ld hl, heap_start 
911b			 
911b			.startalloc: 
911b			 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "mym" 
911b						CALLMONITOR 
911b					endif 
911b			.findblock: 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "mmf" 
911b						CALLMONITOR 
911b					endif 
911b			 
911b				ld a,(hl)  
911b				; if byte is zero then clear to use 
911b			 
911b				cp 0 
911b				jr z, .foundemptyblock 
911b			 
911b				; if byte is not clear 
911b				;     then byte is offset to next block 
911b			 
911b				inc hl 
911b				ld a, (hl) ; get size 
911b			.nextblock:	inc hl 
911b					ld e, (hl) 
911b					inc hl 
911b					ld d, (hl) 
911b					ex de, hl 
911b			;	inc hl  ; move past the store space 
911b			;	inc hl  ; move past zero index  
911b			 
911b				; TODO detect no more space 
911b			 
911b				push hl 
911b				ld de, heap_end 
911b				call cmp16 
911b				pop hl 
911b				jr nc, .nospace 
911b			 
911b				jr .findblock 
911b			 
911b			.nospace: ld hl, 0 
911b				jp .exit 
911b			 
911b			 
911b			.foundemptyblock:	 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "mme" 
911b						CALLMONITOR 
911b					endif 
911b			 
911b			; TODO has block enough space if reusing??? 
911b			 
911b				;  
911b			 
911b			; see if this block has been previously used 
911b				inc hl 
911b				ld a, (hl) 
911b				dec hl 
911b				cp 0 
911b				jr z, .newblock 
911b			 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "meR" 
911b						CALLMONITOR 
911b					endif 
911b			 
911b			; no reusing previously allocated block 
911b			 
911b			; is it smaller than previously used? 
911b				 
911b				inc hl    ; move to size 
911b				ld a, c 
911b				sub (hl)        ; we want c < (hl) 
911b				dec hl    ; move back to marker 
911b			        jr z, .findblock 
911b			 
911b				; update with the new size which should be lower 
911b			 
911b			        ;inc  hl   ; negate next move. move back to size  
911b			 
911b			.newblock: 
911b				; need to be at marker here 
911b			 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "meN" 
911b						CALLMONITOR 
911b					endif 
911b			 
911b			 
911b				ld a, c 
911b			 
911b				ld (free_list+3), a	 ; flag resume from last malloc  
911b				ld (free_list), hl    ; save out last location 
911b			 
911b			 
911b				;inc a     ; space for length byte 
911b				ld (hl), a     ; save block in use marker 
911b			 
911b				inc hl   ; move to space marker 
911b				ld (hl), a    ; save new space 
911b			 
911b				inc hl   ; move to start of allocated area 
911b				 
911b			;	push hl     ; save where we are - 1  
911b			 
911b			;	inc hl  ; move past zero index  
911b				; skip space to set down new marker 
911b			 
911b				; provide some extra space for now 
911b			 
911b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
911b				inc a 
911b				inc a 
911b			 
911b				push hl   ; save where we are in the node block 
911b			 
911b				call addatohl 
911b			 
911b				; write linked list point 
911b			 
911b				pop de     ; get our node position 
911b				ex de, hl 
911b			 
911b				ld (hl), e 
911b				inc hl 
911b				ld (hl), d 
911b			 
911b				inc hl 
911b			 
911b				; now at start of allocated data so save pointer 
911b			 
911b				push hl 
911b			 
911b				; jump to position of next node and setup empty header in DE 
911b			 
911b				ex de, hl 
911b			 
911b			;	inc hl ; move past end of block 
911b			 
911b				ld a, 0 
911b				ld (hl), a   ; empty marker 
911b				inc hl 
911b				ld (hl), a   ; size 
911b				inc hl  
911b				ld (hl), a   ; ptr 
911b				inc hl 
911b				ld (hl), a   ; ptr 
911b			 
911b			 
911b				pop hl 
911b			 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "mmr" 
911b						CALLMONITOR 
911b					endif 
911b			 
911b			.exit: 
911b				pop af 
911b				pop bc 
911b				pop de  
911b				ret 
911b			 
911b			 
911b			 
911b			 
911b			free:  
911b				push hl 
911b				push af 
911b				; get address in hl 
911b			 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "fre" 
911b						CALLMONITOR 
911b					endif 
911b				; data is at hl - move to block count 
911b				dec hl 
911b				dec hl    ; get past pointer 
911b				dec hl 
911b			 
911b				ld a, (hl)    ; need this for a validation check 
911b			 
911b				dec hl    ; move to block marker 
911b			 
911b				; now check that the block count and block marker are the same  
911b			        ; this checks that we are on a malloc node and not random memory 
911b			        ; OK a faint chance this could be a problem but rare - famous last words! 
911b			 
911b				ld c, a 
911b				ld a, (hl)    
911b			 
911b				cp c 
911b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
911b			 
911b				; yes good chance we are on a malloc node 
911b			 
911b				ld a, 0      
911b				ld (hl), a   ; mark as free 
911b			 
911b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
911b			 
911b			.freeignore:  
911b			 
911b				pop af 
911b				pop hl 
911b			 
911b				ret 
911b			 
911b			 
911b			 
911b			endif 
911b			 
911b			; eof 
# End of file firmware_memory.asm
911b			  
911b			; device C  
911b			if SOUND_ENABLE  
911b				include "firmware_sound.asm"  
911b			endif  
911b			  
911b			include "firmware_diags.asm"  
911b			; Hardware diags menu 
911b			 
911b			 
911b			config: 
911b			 
911b 3e 00			ld a, 0 
911d 21 4b 91			ld hl, .configmn 
9120 cd bf 88			call menu 
9123			 
9123 fe 00			cp 0 
9125 c8				ret z 
9126			 
9126 fe 01			cp 1 
9128 cc ef 91			call z, .savetostore 
912b			 
912b fe 02			cp 2 
912d cc ed 91			call z, .selautoload 
9130 fe 03			cp 3 
9132 cc ec 91			call z, .disautoload 
9135 fe 04			cp 4 
9137 cc ee 91			call z, .selbank 
913a fe 05			cp 5 
913c cc f0 91			call z, .debug_tog 
913f fe 06			cp 6 
9141 cc 38 93			call z, .bpsgo 
9144 fe 07			cp 7 
9146 cc 16 92			call z, hardware_diags 
9149			 
9149 18 d0			jr config 
914b			 
914b			.configmn: 
914b 5b 91			dw .c3 
914d 72 91			dw .c2 
914f 87 91			dw .c2a 
9151 9d 91			dw .c2b 
9153			;	dw .c4 
9153 ba 91			dw .m4 
9155 d5 91			dw .m4b 
9157 dd 91			dw .c1 
9159 00 00			dw 0 
915b				 
915b			 
915b .. 00		.c3: db "Add Dictionary To File",0 
9172 .. 00		.c2: db "Select Autoload File",0 
9187 .. 00		.c2a: db "Disable Autoload File", 0 
919d .. 00		.c2b: db "Select Storage Bank",0 
91b1 .. 00		.c4: db "Settings",0 
91ba .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
91d5 .. 00		.m4b:   db "Monitor",0 
91dd .. 00		.c1: db "Hardware Diags",0 
91ec			 
91ec			 
91ec			.disautoload: 
91ec				if STORAGE_SE 
91ec				ld a, $fe      ; bit 0 clear 
91ec				ld (spi_device), a 
91ec			 
91ec				call storage_get_block_0 
91ec			 
91ec				ld a, 0 
91ec				ld (store_page+STORE_0_AUTOFILE), a 
91ec			 
91ec					ld hl, 0 
91ec					ld de, store_page 
91ec				call storage_write_block	 ; save update 
91ec				endif 
91ec			 
91ec			 
91ec c9				ret 
91ed			 
91ed			 
91ed			 
91ed			; Select auto start 
91ed			 
91ed			.selautoload: 
91ed			 
91ed				 
91ed				if STORAGE_SE 
91ed			 
91ed					call config_dir 
91ed				        ld hl, scratch 
91ed					ld a, 0 
91ed					call menu 
91ed			 
91ed					cp 0 
91ed					ret z 
91ed			 
91ed					dec a 
91ed			 
91ed			 
91ed					; locate menu option 
91ed			 
91ed					ld hl, scratch 
91ed					call table_lookup 
91ed			 
91ed					if DEBUG_FORTH_WORDS 
91ed						DMARK "ALl" 
91ed						CALLMONITOR 
91ed					endif 
91ed					; with the pointer to the menu it, the byte following the zero term is the file id 
91ed			 
91ed					ld a, 0 
91ed					ld bc, 50   ; max of bytes to look at 
91ed					cpir  
91ed			 
91ed					if DEBUG_FORTH_WORDS 
91ed						DMARK "ALb" 
91ed						CALLMONITOR 
91ed					endif 
91ed					;inc hl 
91ed			 
91ed					ld a, (hl)   ; file id 
91ed					 
91ed				        ; save bank and file ids 
91ed			 
91ed					push af 
91ed			 
91ed			; TODO need to save to block 0 on bank 1	 
91ed			 
91ed					call storage_get_block_0 
91ed			 
91ed					if DEBUG_FORTH_WORDS 
91ed						DMARK "AL0" 
91ed						CALLMONITOR 
91ed					endif 
91ed					pop af 
91ed			 
91ed					ld (store_page+STORE_0_FILERUN),a 
91ed					 
91ed					; save bank id 
91ed			 
91ed					ld a,(spi_device) 
91ed					ld (store_page+STORE_0_BANKRUN),a 
91ed			 
91ed					; enable auto run of store file 
91ed			 
91ed					ld a, 1 
91ed					ld (store_page+STORE_0_AUTOFILE),a 
91ed			 
91ed					; save buffer 
91ed			 
91ed					ld hl, 0 
91ed					ld de, store_page 
91ed					if DEBUG_FORTH_WORDS 
91ed						DMARK "ALw" 
91ed						CALLMONITOR 
91ed					endif 
91ed				call storage_write_block	 ; save update 
91ed			  
91ed			 
91ed			 
91ed			 
91ed					ld hl, scratch 
91ed					call config_fdir 
91ed			 
91ed			 
91ed				endif 
91ed c9				ret 
91ee			 
91ee			 
91ee			 
91ee			; Select storage bank 
91ee			 
91ee			.selbank: 
91ee			 
91ee				if STORAGE_SE 
91ee				endif 
91ee				 
91ee c9				ret 
91ef			 
91ef			if STORAGE_SE 
91ef			 
91ef			.config_ldir:   
91ef				; Load storage bank labels into menu array 
91ef			 
91ef				 
91ef			 
91ef			 
91ef				ret 
91ef			 
91ef			 
91ef			endif 
91ef			 
91ef			 
91ef			; Save user words to storage 
91ef			 
91ef			.savetostore: 
91ef			 
91ef				if STORAGE_SE 
91ef			 
91ef					call config_dir 
91ef				        ld hl, scratch 
91ef					ld a, 0 
91ef					call menu 
91ef					 
91ef					ld hl, scratch 
91ef					call config_fdir 
91ef			 
91ef			 
91ef				endif 
91ef			 
91ef c9				ret 
91f0			 
91f0			 
91f0			 
91f0			if STORAGE_SE 
91f0			 
91f0			config_fdir: 
91f0				; using the scratch dir go through and release the memory allocated for each string 
91f0				 
91f0				ld hl, scratch 
91f0			.cfdir:	ld e,(hl) 
91f0				inc hl 
91f0				ld d,(hl) 
91f0				inc hl 
91f0			 
91f0				ex de, hl 
91f0				call ishlzero 
91f0				ret z     ; return on null pointer 
91f0				call free 
91f0				ex de, hl 
91f0				jr .cfdir 
91f0			 
91f0			 
91f0				ret 
91f0			 
91f0			 
91f0			config_dir: 
91f0			 
91f0				; for the config menus that need to build a directory of storage call this routine 
91f0				; it will construct a menu in scratch to pass to menu 
91f0			 
91f0				; open storage device 
91f0			 
91f0				; execute DIR to build a list of files and their ids into scratch in menu format 
91f0				; once the menu has finished then will need to call config_fdir to release the strings 
91f0				 
91f0				; c = number items 
91f0			 
91f0				 
91f0				call storage_get_block_0 
91f0			 
91f0				ld hl, store_page     ; get current id count 
91f0				ld b, (hl) 
91f0				ld c, 0    ; count of files   
91f0			 
91f0			 
91f0				ld hl, scratch 
91f0				ld (store_tmp2), hl    ; location to poke strings 
91f0			 
91f0				; check for empty drive 
91f0			 
91f0				ld a, 0 
91f0				cp b 
91f0				jp z, .dirdone 
91f0			 
91f0				 
91f0					if DEBUG_FORTH_WORDS 
91f0						DMARK "Cdc" 
91f0						CALLMONITOR 
91f0					endif 
91f0			 
91f0			 
91f0			.diritem:	 
91f0				push bc 
91f0				; for each of the current ids do a search for them and if found push to stack 
91f0			 
91f0					ld hl, STORE_BLOCK_PHY 
91f0					ld d, 0		 ; look for extent 0 of block id as this contains file name 
91f0					ld e,b 
91f0			 
91f0					call storage_findnextid 
91f0			 
91f0			 
91f0					; if found hl will be non zero 
91f0			 
91f0					call ishlzero 
91f0					jr z, .dirnotfound 
91f0			 
91f0					; increase count 
91f0			 
91f0					pop bc	 
91f0					inc c 
91f0					push bc 
91f0					 
91f0			 
91f0					; get file header and push the file name 
91f0			 
91f0					ld de, store_page 
91f0					call storage_read_block 
91f0			 
91f0					; push file id to stack 
91f0				 
91f0					ld a, (store_page) 
91f0					ld h, 0 
91f0					ld l, a 
91f0			 
91f0					;call forth_push_numhl 
91f0					; TODO store id 
91f0			 
91f0					push hl 
91f0			 
91f0					; push extent count to stack  
91f0				 
91f0					ld hl, store_page+3 
91f0			 
91f0					; get file name length 
91f0			 
91f0					call strlenz   
91f0			 
91f0					inc hl   ; cover zero term 
91f0					inc hl  ; stick the id at the end of the area 
91f0			 
91f0					push hl 
91f0					pop bc    ; move length to bc 
91f0			 
91f0					call malloc 
91f0			 
91f0					; TODO save malloc area to scratch 
91f0			 
91f0					ex de, hl 
91f0					ld hl, (store_tmp2) 
91f0					ld (hl), e 
91f0					inc hl 
91f0					ld (hl), d 
91f0					inc hl 
91f0					ld (store_tmp2), hl 
91f0			 
91f0					 
91f0			 
91f0					;pop hl   ; get source 
91f0			;		ex de, hl    ; swap aronund	 
91f0			 
91f0					ld hl, store_page+3 
91f0					if DEBUG_FORTH_WORDS 
91f0						DMARK "CFd" 
91f0						CALLMONITOR 
91f0					endif 
91f0					ldir 
91f0			 
91f0					; de is past string, move back one and store id 
91f0					 
91f0					dec de 
91f0			 
91f0					; store file id 
91f0			 
91f0					pop hl 
91f0					ex de,hl 
91f0					ld (hl), e 
91f0			 
91f0					if DEBUG_FORTH_WORDS 
91f0						DMARK "Cdi" 
91f0						CALLMONITOR 
91f0					endif 
91f0					 
91f0			.dirnotfound: 
91f0					pop bc     
91f0					djnz .diritem 
91f0				 
91f0			.dirdone:	 
91f0			 
91f0					ld a, 0 
91f0					ld hl, (store_tmp2) 
91f0					ld (hl), a 
91f0					inc hl 
91f0					ld (hl), a 
91f0					inc hl 
91f0					; push a count of the dir items found 
91f0			 
91f0			;		ld h, 0 
91f0			;		ld l, c 
91f0			 
91f0				ret 
91f0			 
91f0			endif 
91f0			 
91f0			 
91f0			; Settings 
91f0			; Run  
91f0			 
91f0			 
91f0			 
91f0			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
91f0			;;hd_menu2:   db "        2: Editor",0   
91f0			;hd_menu2:   db "        2: Editor       6: Menu",0   
91f0			;hd_menu3:   db "        3: Storage",0 
91f0			;hd_menu4:   db "0=quit  4: Debug",0 
91f0			;hd_don:     db "ON",0 
91f0			;hd_doff:     db "OFF",0 
91f0			; 
91f0			; 
91f0			; 
91f0			;hardware_diags_old:       
91f0			; 
91f0			;.diagmenu: 
91f0			;	call clear_display 
91f0			;	ld a, display_row_1 
91f0			;	ld de, hd_menu1 
91f0			;	call str_at_display 
91f0			; 
91f0			;	ld a, display_row_2 
91f0			;	ld de, hd_menu2 
91f0			;	call str_at_display 
91f0			; 
91f0			;	ld a, display_row_3 
91f0			;	ld de, hd_menu3 
91f0			;	call str_at_display 
91f0			; 
91f0			;	ld a,  display_row_4 
91f0			;	ld de, hd_menu4 
91f0			;	call str_at_display 
91f0			; 
91f0			;	; display debug state 
91f0			; 
91f0			;	ld de, hd_don 
91f0			;	ld a, (os_view_disable) 
91f0			;	cp 0 
91f0			;	jr z, .distog 
91f0			;	ld de, hd_doff 
91f0			;.distog: ld a, display_row_4+17 
91f0			;	call str_at_display 
91f0			; 
91f0			;	call update_display 
91f0			; 
91f0			;	call cin_wait 
91f0			; 
91f0			; 
91f0			; 
91f0			;	cp '4' 
91f0			;	jr nz, .diagn1 
91f0			; 
91f0			;	; debug toggle 
91f0			; 
91f0			;	ld a, (os_view_disable) 
91f0			;	ld b, '*' 
91f0			;	cp 0 
91f0			;	jr z, .debtog 
91f0			;	ld b, 0 
91f0			;.debtog:	 
91f0			;	ld a,b 
91f0			;	ld (os_view_disable),a 
91f0			; 
91f0			;.diagn1: cp '0' 
91f0			;	 ret z 
91f0			; 
91f0			;;	cp '1' 
91f0			;;       jp z, matrix	 
91f0			;;   TODO keyboard matrix test 
91f0			; 
91f0			;	cp '2' 
91f0			;	jp z, .diagedit 
91f0			; 
91f0			;;	cp '6' 
91f0			;;	jp z, .menutest 
91f0			;;if ENABLE_BASIC 
91f0			;;	cp '6' 
91f0			;;	jp z, basic 
91f0			;;endif 
91f0			 ; 
91f0			;	jp .diagmenu 
91f0			; 
91f0			; 
91f0			;	ret 
91f0			 
91f0			 
91f0			.debug_tog: 
91f0 21 37 92			ld hl, .menudebug 
91f3				 
91f3 3a d7 e4			ld a, (os_view_disable) 
91f6 fe 2a			cp '*' 
91f8 20 04			jr nz,.tdon  
91fa 3e 01			ld a, 1 
91fc 18 02			jr .tog1 
91fe 3e 00		.tdon: ld a, 0 
9200			 
9200			.tog1: 
9200 cd bf 88			call menu 
9203 fe 00			cp 0 
9205 c8				ret z 
9206 fe 01			cp 1    ; disable debug 
9208 28 04			jr z, .dtog0 
920a 3e 2a			ld a, '*' 
920c 18 02			jr .dtogset 
920e 3e 00		.dtog0: ld a, 0 
9210 32 d7 e4		.dtogset:  ld (os_view_disable), a 
9213 c3 f0 91			jp .debug_tog 
9216			 
9216			 
9216			hardware_diags:       
9216			 
9216			.diagm: 
9216 21 29 92			ld hl, .menuitems 
9219 3e 00			ld a, 0 
921b cd bf 88			call menu 
921e			 
921e fe 00		         cp 0 
9220 c8				 ret z 
9221			 
9221 fe 02			cp 2 
9223 ca 82 92			jp z, .diagedit 
9226			 
9226			;	cp '6' 
9226			;	jp z, .menutest 
9226			;if ENABLE_BASIC 
9226			;	cp '6' 
9226			;	jp z, basic 
9226			;endif 
9226			  
9226 c3 16 92			jp .diagm 
9229			 
9229				 
9229 3d 92		.menuitems:   	dw .m1 
922b 48 92				dw .m2 
922d 4f 92				dw .m3 
922f 57 92				dw .m5 
9231 5d 92				dw .m5a 
9233 66 92				dw .m5b 
9235 00 00				dw 0 
9237			 
9237			.menudebug: 
9237 6f 92				dw .m6 
9239 78 92				dw .m7 
923b 00 00				dw 0 
923d			 
923d .. 00		.m1:   db "Key Matrix",0 
9248 .. 00		.m2:   db "Editor",0 
924f .. 00		.m3:   db "Storage",0 
9257 .. 00		.m5:   db "Sound",0 
925d .. 00		.m5a:  db "RAM Test",0 
9266 .. 00		.m5b:  db "LCD Test",0 
926f			 
926f .. 00		.m6:   db "Debug ON",0 
9278 .. 00		.m7:   db "Debug OFF",0 
9282			 
9282			; debug editor 
9282			 
9282			.diagedit: 
9282			 
9282 21 e6 e4			ld hl, scratch 
9285			;	ld bc, 250 
9285			;	ldir 
9285				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9285 3e 00			ld a, 0 
9287 77				ld (hl), a 
9288 23				inc hl 
9289 77				ld (hl), a 
928a 23				inc hl 
928b 77				ld (hl), a 
928c			 
928c cd 8e 88		        call clear_display 
928f cd b1 88			call update_display 
9292 3e 01			ld a, 1 
9294 32 c6 ee			ld (hardware_diag), a 
9297			.diloop: 
9297 3e 00			ld a, display_row_1 
9299 0e 00			ld c, 0 
929b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
929d 1e 28			ld e, 40 
929f			 
929f 21 e6 e4			ld hl, scratch	 
92a2 cd e8 8a			call input_str 
92a5			 
92a5 3e 14			ld a, display_row_2 
92a7 11 e6 e4			ld de, scratch 
92aa cd a1 88			call str_at_display 
92ad cd b1 88			call update_display 
92b0			 
92b0 c3 97 92			jp .diloop 
92b3			 
92b3			 
92b3			; pass word in hl 
92b3			; a has display location 
92b3			display_word_at: 
92b3 f5				push af 
92b4 e5				push hl 
92b5 7c				ld a,h 
92b6 21 eb e7			ld hl, os_word_scratch 
92b9 cd bc 8d			call hexout 
92bc e1				pop hl 
92bd 7d				ld a,l 
92be 21 ed e7			ld hl, os_word_scratch+2 
92c1 cd bc 8d			call hexout 
92c4 21 ef e7			ld hl, os_word_scratch+4 
92c7 3e 00			ld a,0 
92c9 77				ld (hl),a 
92ca 11 eb e7			ld de,os_word_scratch 
92cd f1				pop af 
92ce cd a1 88				call str_at_display 
92d1 c9				ret 
92d2			 
92d2			display_ptr_state: 
92d2			 
92d2				; to restore afterwards 
92d2			 
92d2 d5				push de 
92d3 c5				push bc 
92d4 e5				push hl 
92d5 f5				push af 
92d6			 
92d6				; for use in here 
92d6			 
92d6			;	push bc 
92d6			;	push de 
92d6			;	push hl 
92d6			;	push af 
92d6			 
92d6 cd 8e 88			call clear_display 
92d9			 
92d9 11 ac 94			ld de, .ptrstate 
92dc 3e 00			ld a, display_row_1 
92de cd a1 88			call str_at_display 
92e1			 
92e1				; display debug step 
92e1			 
92e1			 
92e1 11 c0 ee			ld de, debug_mark 
92e4 3e 12			ld a, display_row_1+display_cols-2 
92e6 cd a1 88			call str_at_display 
92e9			 
92e9				; display a 
92e9 11 b6 94			ld de, .ptrcliptr 
92ec 3e 14			ld a, display_row_2 
92ee cd a1 88			call str_at_display 
92f1			 
92f1 f1				pop af 
92f2 2a b1 ec			ld hl,(cli_ptr) 
92f5 3e 1c			ld a, display_row_2+8 
92f7 cd b3 92			call display_word_at 
92fa			 
92fa			 
92fa				; display hl 
92fa			 
92fa			 
92fa 11 be 94			ld de, .ptrclioptr 
92fd 3e 1e			ld a, display_row_2+10 
92ff cd a1 88			call str_at_display 
9302			; 
9302			;	pop hl 
9302 3e 21			ld a, display_row_2+13 
9304 2a af ec			ld hl,(cli_origptr) 
9307 cd b3 92			call display_word_at 
930a			; 
930a			;	 
930a			;	; display de 
930a			 
930a			;	ld de, .regstatede 
930a			;	ld a, display_row_3 
930a			;	call str_at_display 
930a			 
930a			;	pop de 
930a			;	ld h,d 
930a			;	ld l, e 
930a			;	ld a, display_row_3+3 
930a			;	call display_word_at 
930a			 
930a			 
930a				; display bc 
930a			 
930a			;	ld de, .regstatebc 
930a			;	ld a, display_row_3+10 
930a			;	call str_at_display 
930a			 
930a			;	pop bc 
930a			;	ld h,b 
930a			;	ld l, c 
930a			;	ld a, display_row_3+13 
930a			;	call display_word_at 
930a			 
930a			 
930a				; display dsp 
930a			 
930a			;	ld de, .regstatedsp 
930a			;	ld a, display_row_4 
930a			;	call str_at_display 
930a			 
930a				 
930a			;	ld hl,(cli_data_sp) 
930a			;	ld a, display_row_4+4 
930a			;	call display_word_at 
930a			 
930a				; display rsp 
930a			 
930a 11 ed 94			ld de, .regstatersp 
930d 3e 46			ld a, display_row_4+10 
930f cd a1 88			call str_at_display 
9312			 
9312				 
9312 2a 97 ec			ld hl,(cli_ret_sp) 
9315 3e 4a			ld a, display_row_4+14 
9317 cd b3 92			call display_word_at 
931a			 
931a cd b1 88			call update_display 
931d			 
931d cd 0e 88			call delay1s 
9320 cd 0e 88			call delay1s 
9323 cd 0e 88			call delay1s 
9326			 
9326			 
9326 cd 33 98			call next_page_prompt 
9329			 
9329				; restore  
9329			 
9329 f1				pop af 
932a e1				pop hl 
932b c1				pop bc 
932c d1				pop de 
932d c9				ret 
932e			 
932e			break_point_state: 
932e f5				push af 
932f			 
932f				; see if disabled 
932f			 
932f 3a d7 e4			ld a, (os_view_disable) 
9332 fe 2a			cp '*' 
9334 20 02			jr nz, .bpsgo 
9336 f1				pop af 
9337 c9				ret 
9338			 
9338			.bpsgo: 
9338 f1				pop af 
9339 f5				push af 
933a 22 d3 e4			ld (os_view_hl), hl 
933d ed 53 d1 e4		ld (os_view_de), de 
9341 ed 43 cf e4		ld (os_view_bc), bc 
9345 e5				push hl 
9346 6f				ld l, a 
9347 26 00			ld h, 0 
9349 22 d5 e4			ld (os_view_af),hl 
934c			 
934c 21 56 ee				ld hl, display_fb0 
934f 22 61 ed				ld (display_fb_active), hl 
9352 e1				pop hl	 
9353			 
9353 3e 31			ld a, '1' 
9355 fe 2a		.bps1:  cp '*' 
9357 20 03			jr nz, .bps1b 
9359 32 d7 e4			ld (os_view_disable),a 
935c fe 31		.bps1b:  cp '1' 
935e 20 14			jr nz, .bps2 
9360			 
9360				; display reg 
9360			 
9360				 
9360			 
9360 3a d5 e4			ld a, (os_view_af) 
9363 2a d3 e4			ld hl, (os_view_hl) 
9366 ed 5b d1 e4		ld de, (os_view_de) 
936a ed 4b cf e4		ld bc, (os_view_bc) 
936e cd 08 94			call display_reg_state 
9371 c3 f4 93			jp .bpschk 
9374			 
9374 fe 32		.bps2:  cp '2' 
9376 20 08			jr nz, .bps3 
9378				 
9378				; display hl 
9378 2a d3 e4			ld hl, (os_view_hl) 
937b cd f2 94			call display_dump_at_hl 
937e			 
937e 18 74			jr .bpschk 
9380			 
9380 fe 33		.bps3:  cp '3' 
9382 20 08			jr nz, .bps4 
9384			 
9384			        ; display de 
9384 2a d1 e4			ld hl, (os_view_de) 
9387 cd f2 94			call display_dump_at_hl 
938a			 
938a 18 68			jr .bpschk 
938c fe 34		.bps4:  cp '4' 
938e 20 08			jr nz, .bps5 
9390			 
9390			        ; display bc 
9390 2a cf e4			ld hl, (os_view_bc) 
9393 cd f2 94			call display_dump_at_hl 
9396			 
9396 18 5c			jr .bpschk 
9398 fe 35		.bps5:  cp '5' 
939a 20 08		        jr nz, .bps7 
939c			 
939c				; display cur ptr 
939c 2a b1 ec			ld hl, (cli_ptr) 
939f cd f2 94			call display_dump_at_hl 
93a2			 
93a2 18 50			jr .bpschk 
93a4 fe 36		.bps7:  cp '6' 
93a6 20 08			jr nz, .bps8b 
93a8				 
93a8				; display cur orig ptr 
93a8 2a af ec			ld hl, (cli_origptr) 
93ab cd f2 94			call display_dump_at_hl 
93ae 18 44			jr .bpschk 
93b0 fe 37		.bps8b:  cp '7' 
93b2 20 08			jr nz, .bps9 
93b4				 
93b4				; display dsp 
93b4 2a 93 ec			ld hl, (cli_data_sp) 
93b7 cd f2 94			call display_dump_at_hl 
93ba			 
93ba 18 38			jr .bpschk 
93bc fe 39		.bps9:  cp '9' 
93be 20 05			jr nz, .bps8c 
93c0				 
93c0				; display SP 
93c0			;	ld hl, sp 
93c0 cd f2 94			call display_dump_at_hl 
93c3			 
93c3 18 2f			jr .bpschk 
93c5 fe 38		.bps8c:  cp '8' 
93c7 20 08			jr nz, .bps8d 
93c9				 
93c9				; display rsp 
93c9 2a 97 ec			ld hl, (cli_ret_sp) 
93cc cd f2 94			call display_dump_at_hl 
93cf			 
93cf 18 23			jr .bpschk 
93d1 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
93d3 20 05			jr nz, .bps8 
93d5 cd 29 96			call monitor 
93d8			 
93d8 18 1a			jr .bpschk 
93da fe 30		.bps8:  cp '0' 
93dc 20 16			jr nz, .bpschk 
93de			 
93de 21 05 ee				ld hl, display_fb1 
93e1 22 61 ed				ld (display_fb_active), hl 
93e4 cd b1 88				call update_display 
93e7			 
93e7				;ld a, (os_view_af) 
93e7 2a d3 e4			ld hl, (os_view_hl) 
93ea ed 5b d1 e4		ld de, (os_view_de) 
93ee ed 4b cf e4		ld bc, (os_view_bc) 
93f2 f1				pop af 
93f3 c9				ret 
93f4			 
93f4			.bpschk:   
93f4 cd 0e 88			call delay1s 
93f7 3e 4f		ld a,display_row_4 + display_cols - 1 
93f9 11 31 98		        ld de, endprg 
93fc cd a1 88			call str_at_display 
93ff cd b1 88			call update_display 
9402 cd 60 d7			call cin_wait 
9405			 
9405 c3 55 93			jp .bps1 
9408			 
9408			 
9408			display_reg_state: 
9408			 
9408				; to restore afterwards 
9408			 
9408 d5				push de 
9409 c5				push bc 
940a e5				push hl 
940b f5				push af 
940c			 
940c				; for use in here 
940c			 
940c c5				push bc 
940d d5				push de 
940e e5				push hl 
940f f5				push af 
9410			 
9410 cd 8e 88			call clear_display 
9413			 
9413 11 c8 94			ld de, .regstate 
9416 3e 00			ld a, display_row_1 
9418 cd a1 88			call str_at_display 
941b			 
941b				; display debug step 
941b			 
941b			 
941b 11 c0 ee			ld de, debug_mark 
941e 3e 11			ld a, display_row_1+display_cols-3 
9420 cd a1 88			call str_at_display 
9423			 
9423				; display a 
9423 11 e4 94			ld de, .regstatea 
9426 3e 14			ld a, display_row_2 
9428 cd a1 88			call str_at_display 
942b			 
942b e1				pop hl 
942c			;	ld h,0 
942c			;	ld l, a 
942c 3e 17			ld a, display_row_2+3 
942e cd b3 92			call display_word_at 
9431			 
9431			 
9431				; display hl 
9431			 
9431			 
9431 11 d8 94			ld de, .regstatehl 
9434 3e 1e			ld a, display_row_2+10 
9436 cd a1 88			call str_at_display 
9439			 
9439 e1				pop hl 
943a 3e 21			ld a, display_row_2+13 
943c cd b3 92			call display_word_at 
943f			 
943f				 
943f				; display de 
943f			 
943f 11 dc 94			ld de, .regstatede 
9442 3e 28			ld a, display_row_3 
9444 cd a1 88			call str_at_display 
9447			 
9447 e1				pop hl 
9448			;	ld h,d 
9448			;	ld l, e 
9448 3e 2b			ld a, display_row_3+3 
944a cd b3 92			call display_word_at 
944d			 
944d			 
944d				; display bc 
944d			 
944d 11 e0 94			ld de, .regstatebc 
9450 3e 32			ld a, display_row_3+10 
9452 cd a1 88			call str_at_display 
9455			 
9455 e1				pop hl 
9456			;	ld h,b 
9456			;	ld l, c 
9456 3e 35			ld a, display_row_3+13 
9458 cd b3 92			call display_word_at 
945b			 
945b			 
945b				; display dsp 
945b			 
945b 11 e8 94			ld de, .regstatedsp 
945e 3e 3c			ld a, display_row_4 
9460 cd a1 88			call str_at_display 
9463			 
9463				 
9463 2a 93 ec			ld hl,(cli_data_sp) 
9466 3e 40			ld a, display_row_4+4 
9468 cd b3 92			call display_word_at 
946b			 
946b				; display rsp 
946b			 
946b 11 ed 94			ld de, .regstatersp 
946e 3e 46			ld a, display_row_4+10 
9470 cd a1 88			call str_at_display 
9473			 
9473				 
9473 2a 97 ec			ld hl,(cli_ret_sp) 
9476 3e 4a			ld a, display_row_4+14 
9478 cd b3 92			call display_word_at 
947b			 
947b cd b1 88			call update_display 
947e			 
947e			;	call delay1s 
947e			;	call delay1s 
947e			;	call delay1s 
947e			 
947e			 
947e			;	call next_page_prompt 
947e			 
947e				; restore  
947e			 
947e f1				pop af 
947f e1				pop hl 
9480 c1				pop bc 
9481 d1				pop de 
9482 c9				ret 
9483			 
9483 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9497 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
94ac .. 00		.ptrstate:	db "Ptr State",0 
94b6 .. 00		.ptrcliptr:     db "cli_ptr",0 
94be .. 00		.ptrclioptr:     db "cli_o_ptr",0 
94c8 .. 00		.regstate:	db "Reg State (1/0)",0 
94d8 .. 00		.regstatehl:	db "HL:",0 
94dc .. 00		.regstatede:	db "DE:",0 
94e0 .. 00		.regstatebc:	db "BC:",0 
94e4 .. 00		.regstatea:	db "A :",0 
94e8 .. 00		.regstatedsp:	db "DSP:",0 
94ed .. 00		.regstatersp:	db "RSP:",0 
94f2			 
94f2			display_dump_at_hl: 
94f2 e5				push hl 
94f3 d5				push de 
94f4 c5				push bc 
94f5 f5				push af 
94f6			 
94f6 22 09 e8			ld (os_cur_ptr),hl	 
94f9 cd 8e 88			call clear_display 
94fc cd 3b 97			call dumpcont 
94ff			;	call delay1s 
94ff			;	call next_page_prompt 
94ff			 
94ff			 
94ff f1				pop af 
9500 c1				pop bc 
9501 d1				pop de 
9502 e1				pop hl 
9503 c9				ret 
9504			 
9504			;if ENABLE_BASIC 
9504			;	include "nascombasic.asm" 
9504			;	basic: 
9504			;	include "forth/FORTH.ASM" 
9504			;endif 
9504			 
9504			; eof 
9504			 
9504			 
# End of file firmware_diags.asm
9504			  
9504			  
9504			  
9504			  
9504			; eof  
9504			  
# End of file firmware.asm
9504			 
9504			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9504			;if BASE_KEV  
9504			;baseram: equ 08000h 
9504			;endif 
9504			 
9504			;if BASE_SC114 
9504			;baseram:     equ    endofcode 
9504			;endif 
9504			 
9504			 
9504			; start system 
9504			 
9504			coldstart: 
9504				; set sp 
9504				; di/ei 
9504			 
9504 f3				di 
9505 31 00 f0			ld sp, tos 
9508			;	ei 
9508			 
9508			 
9508				; disable breakpoint by default 
9508			 
9508 3e 2a			ld a,'*' 
950a 32 d7 e4			ld (os_view_disable),a 
950d			 
950d				; init hardware 
950d			 
950d				; init keyboard and screen hardware 
950d			 
950d cd 03 80			call hardware_init 
9510			 
9510			 
9510				; detect if any keys are held down to enable breakpoints at start up 
9510			 
9510 cd 66 d7			call cin  
9513 fe 00			cp 0 
9515 28 03			jr z, .nokeys 
9517			 
9517				;call hardware_diags 
9517 cd 1b 91			call config 
951a			 
951a			;	ld de, .bpen 
951a			;	ld a, display_row_4 
951a			;	call str_at_display 
951a			;	call update_display 
951a			; 
951a			;	ld a,0 
951a			;	ld (os_view_disable),a 
951a			; 
951a			;.bpwait: 
951a			;	call cin 
951a			;	cp 0 
951a			;	jr z, .bpwait 
951a			;	jr .nokeys 
951a			; 
951a			; 
951a			;.bpen:  db "Break points enabled!",0 
951a			 
951a			 
951a			 
951a			 
951a			 
951a			 
951a			.nokeys: 
951a			 
951a			 
951a				 
951a			 
951a			;jp  testkey 
951a			 
951a			;call storage_get_block_0 
951a			; 
951a			;ld hl, 0 
951a			;ld de, store_page 
951a			;call storage_read_block 
951a			 
951a				 
951a			;ld hl, 10 
951a			;ld de, store_page 
951a			;call storage_read_block 
951a			 
951a			 
951a			 
951a			 
951a			 
951a			;stop:	nop 
951a			;	jp stop 
951a			 
951a			 
951a			 
951a			main: 
951a cd 8e 88			call clear_display 
951d cd b1 88			call update_display 
9520			 
9520			 
9520			 
9520			;	call testlcd 
9520			 
9520			 
9520			 
9520 cd f9 9b			call forth_init 
9523			 
9523			 
9523			warmstart: 
9523 cd cf 9b			call forth_warmstart 
9526			 
9526				; run startup word load 
9526			        ; TODO prevent this running at warmstart after crash  
9526			 
9526				if STARTUP_ENABLE 
9526					if STORAGE_SE 
9526						call forth_autoload 
9526					endif 
9526 cd fa d3				call forth_startup 
9529			 
9529			 
9529				endif 
9529			 
9529				; show free memory after boot 
9529 11 c3 95			ld de, freeram 
952c 3e 00			ld a, display_row_1 
952e cd a1 88			call str_at_display 
9531			 
9531			; Or use heap_size word???? 
9531 21 cc e4			ld hl, heap_end 
9534 11 84 d7			ld de, heap_start 
9537 ed 52			sbc hl, de 
9539 e5				push hl 
953a 7c				ld a,h	         	 
953b 21 eb e7			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
953e cd bc 8d			call hexout 
9541 e1			   	pop hl 
9542			 
9542 7d				ld a,l 
9543 21 ed e7			ld hl, os_word_scratch+2 
9546 cd bc 8d			call hexout 
9549 21 ef e7			ld hl, os_word_scratch+4 
954c 3e 00			ld a, 0 
954e 77				ld (hl),a 
954f 11 eb e7			ld de, os_word_scratch 
9552 3e 0d			ld a, display_row_1 + 13 
9554 cd a1 88			call str_at_display 
9557 cd b1 88			call update_display 
955a			 
955a			 
955a				;call demo 
955a			 
955a			 
955a				; init scratch input area for cli commands 
955a			 
955a 21 0d e8			ld hl, os_cli_cmd 
955d 3e 00			ld a,0 
955f 77				ld (hl),a 
9560 23				inc hl 
9561 77				ld (hl),a 
9562			 
9562 3e 00			ld a,0 
9564 32 0c e9			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
9567			 
9567 32 09 e8			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
956a 32 0a e8			ld (os_cur_ptr+1),a	 
956d			 
956d 32 eb e7			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9570 32 ec e7			ld (os_word_scratch+1),a	 
9573				 
9573			 
9573				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9573 21 0d e8			ld hl, os_cli_cmd 
9576			 
9576 3e 00			ld a, 0		 ; init cli input 
9578 77				ld (hl), a 
9579 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
957b			cli: 
957b				; show cli prompt 
957b				;push af 
957b				;ld a, 0 
957b				;ld de, prompt 
957b				;call str_at_display 
957b			 
957b				;call update_display 
957b				;pop af 
957b				;inc a 
957b				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
957b 0e 00			ld c, 0 
957d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
957f 1e 28			ld e, 40 
9581			 
9581 21 0d e8			ld hl, os_cli_cmd 
9584			 
9584				STACKFRAME OFF $fefe $9f9f 
9584				if DEBUG_STACK_IMB 
9584					if OFF 
9584						exx 
9584						ld de, $fefe 
9584						ld a, d 
9584						ld hl, curframe 
9584						call hexout 
9584						ld a, e 
9584						ld hl, curframe+2 
9584						call hexout 
9584						ld hl, $fefe 
9584						push hl 
9584						ld hl, $9f9f 
9584						push hl 
9584						exx 
9584					endif 
9584				endif 
9584			endm 
# End of macro STACKFRAME
9584			 
9584 cd e8 8a			call input_str 
9587			 
9587				STACKFRAMECHK OFF $fefe $9f9f 
9587				if DEBUG_STACK_IMB 
9587					if OFF 
9587						exx 
9587						ld hl, $9f9f 
9587						pop de   ; $9f9f 
9587						call cmp16 
9587						jr nz, .spnosame 
9587						ld hl, $fefe 
9587						pop de   ; $fefe 
9587						call cmp16 
9587						jr z, .spfrsame 
9587						.spnosame: call showsperror 
9587						.spfrsame: nop 
9587						exx 
9587					endif 
9587				endif 
9587			endm 
# End of macro STACKFRAMECHK
9587			 
9587				; copy input to last command 
9587			 
9587 21 0d e8			ld hl, os_cli_cmd 
958a 11 0c e9			ld de, os_last_cmd 
958d 01 ff 00			ld bc, 255 
9590 ed b0			ldir 
9592			 
9592				; wipe current buffer 
9592			 
9592			;	ld a, 0 
9592			;	ld hl, os_cli_cmd 
9592			;	ld de, os_cli_cmd+1 
9592			;	ld bc, 254 
9592			;	ldir 
9592				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9592			;	call strcpy 
9592			;	ld a, 0 
9592			;	ld (hl), a 
9592			;	inc hl 
9592			;	ld (hl), a 
9592			;	inc hl 
9592			;	ld (hl), a 
9592			 
9592				; switch frame buffer to program  
9592			 
9592 21 05 ee				ld hl, display_fb1 
9595 22 61 ed				ld (display_fb_active), hl 
9598			 
9598			;	nop 
9598				STACKFRAME ON $fbfe $8f9f 
9598				if DEBUG_STACK_IMB 
9598					if ON 
9598						exx 
9598						ld de, $fbfe 
9598						ld a, d 
9598						ld hl, curframe 
9598						call hexout 
9598						ld a, e 
9598						ld hl, curframe+2 
9598						call hexout 
9598						ld hl, $fbfe 
9598						push hl 
9598						ld hl, $8f9f 
9598						push hl 
9598						exx 
9598					endif 
9598				endif 
9598			endm 
# End of macro STACKFRAME
9598				; first time into the parser so pass over the current scratch pad 
9598 21 0d e8			ld hl,os_cli_cmd 
959b				; tokenise the entered statement(s) in HL 
959b cd 72 9c			call forthparse 
959e			        ; exec forth statements in top of return stack 
959e cd b2 9c			call forthexec 
95a1				;call forthexec_cleanup 
95a1			;	call parsenext 
95a1			 
95a1				STACKFRAMECHK ON $fbfe $8f9f 
95a1				if DEBUG_STACK_IMB 
95a1					if ON 
95a1						exx 
95a1						ld hl, $8f9f 
95a1						pop de   ; $8f9f 
95a1						call cmp16 
95a1						jr nz, .spnosame 
95a1						ld hl, $fbfe 
95a1						pop de   ; $fbfe 
95a1						call cmp16 
95a1						jr z, .spfrsame 
95a1						.spnosame: call showsperror 
95a1						.spfrsame: nop 
95a1						exx 
95a1					endif 
95a1				endif 
95a1			endm 
# End of macro STACKFRAMECHK
95a1				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
95a1			 
95a1 3e 3c			ld a, display_row_4 
95a3 11 d5 95			ld de, endprog 
95a6			 
95a6 cd b1 88			call update_display		 
95a9			 
95a9 cd 33 98			call next_page_prompt 
95ac			 
95ac				; switch frame buffer to cli 
95ac			 
95ac 21 56 ee				ld hl, display_fb0 
95af 22 61 ed				ld (display_fb_active), hl 
95b2			 
95b2			 
95b2 cd 8e 88		        call clear_display 
95b5 cd b1 88			call update_display		 
95b8			 
95b8 21 0d e8			ld hl, os_cli_cmd 
95bb			 
95bb 3e 00			ld a, 0		 ; init cli input 
95bd 77				ld (hl), a 
95be			 
95be				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
95be			 
95be				; now on last line 
95be			 
95be				; TODO scroll screen up 
95be			 
95be				; TODO instead just clear screen and place at top of screen 
95be			 
95be			;	ld a, 0 
95be			;	ld (f_cursor_ptr),a 
95be			 
95be				;call clear_display 
95be				;call update_display 
95be			 
95be				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95be 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95c0 c3 7b 95			jp cli 
95c3			 
95c3 .. 00		freeram: db "Free bytes: $",0 
95d1 ..			asc: db "1A2F" 
95d5 .. 00		endprog: db "End prog...",0 
95e1			 
95e1			testenter2:   
95e1 21 18 e5			ld hl,scratch+50 
95e4 22 09 e8			ld (os_cur_ptr),hl 
95e7 c3 7b 95			jp cli 
95ea			 
95ea			testenter:  
95ea			 
95ea 21 d1 95			ld hl,asc 
95ed			;	ld a,(hl) 
95ed			;	call nibble2val 
95ed cd 12 8e			call get_byte 
95f0			 
95f0			 
95f0			;	ld a,(hl) 
95f0			;	call atohex 
95f0			 
95f0			;	call fourehexhl 
95f0 32 18 e5			ld (scratch+50),a 
95f3			 
95f3			 
95f3			 
95f3 21 d3 95			ld hl,asc+2 
95f6			;	ld a, (hl) 
95f6			;	call nibble2val 
95f6 cd 12 8e			call get_byte 
95f9			 
95f9			;	call fourehexhl 
95f9 32 1a e5			ld (scratch+52),a 
95fc				 
95fc 21 18 e5			ld hl,scratch+50 
95ff 22 09 e8			ld (os_cur_ptr),hl 
9602 c3 7b 95			jp cli 
9605			 
9605			enter:	 
9605 3a ea e4			ld a,(scratch+4) 
9608 fe 00			cp 0 
960a 28 0c			jr z, .entercont 
960c				; no, not a null term line so has an address to work out.... 
960c			 
960c 21 e8 e4			ld hl,scratch+2 
960f cd 72 8e			call get_word_hl 
9612			 
9612 22 09 e8			ld (os_cur_ptr),hl	 
9615 c3 7b 95			jp cli 
9618			 
9618			 
9618			.entercont:  
9618			 
9618 21 e8 e4			ld hl, scratch+2 
961b cd 12 8e			call get_byte 
961e			 
961e 2a 09 e8		   	ld hl,(os_cur_ptr) 
9621 77					ld (hl),a 
9622 23					inc hl 
9623 22 09 e8				ld (os_cur_ptr),hl 
9626				 
9626			; get byte  
9626			 
9626			 
9626 c3 7b 95			jp cli 
9629			 
9629			 
9629			; basic monitor support 
9629			 
9629			monitor: 
9629				;  
9629 cd 8e 88			call clear_display 
962c 3e 00			ld a, 0 
962e 11 76 96			ld de, .monprompt 
9631 cd a1 88			call str_at_display 
9634 cd b1 88			call update_display 
9637			 
9637				; get a monitor command 
9637			 
9637 0e 00			ld c, 0     ; entry at top left 
9639 16 64			ld d, 100   ; max buffer size 
963b 1e 0f			ld e, 15    ; input scroll area 
963d 3e 00			ld a, 0     ; init string 
963f 21 e4 e6			ld hl, os_input 
9642 77				ld (hl), a 
9643 23				inc hl 
9644 77				ld (hl), a 
9645 21 e4 e6			ld hl, os_input 
9648 3e 01			ld a, 1     ; init string 
964a cd e8 8a			call input_str 
964d			 
964d cd 8e 88		        call clear_display 
9650 cd b1 88			call update_display		 
9653			 
9653 3a e4 e6			ld a, (os_input) 
9656 cd 10 8f			call toUpper 
9659 fe 48		        cp 'H' 
965b 28 6f		        jr z, .monhelp 
965d fe 44			cp 'D'		; dump 
965f ca ed 96			jp z, .mondump	 
9662 fe 43			cp 'C'		; dump 
9664 ca 07 97			jp z, .moncdump	 
9667 fe 4d			cp 'M'		; dump 
9669 ca 78 96			jp z, .moneditstart 
966c fe 55			cp 'U'		; dump 
966e 28 14			jr z, .monedit	 
9670 fe 51			cp 'Q'		; dump 
9672 c8				ret z	 
9673			 
9673			 
9673				; TODO "S" to access symbol by name and not need the address 
9673				; TODO "F" to find a string in memory 
9673			 
9673 c3 29 96			jp monitor 
9676			 
9676 .. 00		.monprompt: db ">", 0 
9678			 
9678			.moneditstart: 
9678				; get starting address 
9678			 
9678 21 e6 e6			ld hl,os_input+2 
967b cd 72 8e			call get_word_hl 
967e			 
967e 22 09 e8			ld (os_cur_ptr),hl	 
9681			 
9681 c3 29 96			jp monitor 
9684			 
9684			.monedit: 
9684				; get byte to load 
9684			 
9684 21 e6 e6			ld hl,os_input+2 
9687 cd 12 8e			call get_byte 
968a			 
968a				; get address to update 
968a 2a 09 e8			ld hl, (os_cur_ptr) 
968d			 
968d				; update byte 
968d			 
968d 77				ld (hl), a 
968e			 
968e				; move to next address and save it 
968e			 
968e 23				inc hl 
968f 22 09 e8			ld (os_cur_ptr),hl	 
9692			 
9692 c3 29 96			jp monitor 
9695			 
9695			 
9695 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
96a9 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
96c5 .. 00		.monhelptext3:  db "Q-Quit",0 
96cc			        
96cc			.monhelp: 
96cc 3e 00			ld a, display_row_1 
96ce 11 95 96		        ld de, .monhelptext1 
96d1			 
96d1 cd a1 88			call str_at_display 
96d4 3e 14			ld a, display_row_2 
96d6 11 a9 96		        ld de, .monhelptext2 
96d9					 
96d9 cd a1 88			call str_at_display 
96dc 3e 28			ld a, display_row_3 
96de 11 c5 96		        ld de, .monhelptext3 
96e1					 
96e1 cd a1 88			call str_at_display 
96e4 cd b1 88			call update_display		 
96e7			 
96e7 cd 33 98			call next_page_prompt 
96ea c3 29 96			jp monitor 
96ed			 
96ed			.mondump:    
96ed 21 e6 e6			ld hl,os_input+2 
96f0 cd 72 8e			call get_word_hl 
96f3			 
96f3 22 09 e8			ld (os_cur_ptr),hl	 
96f6 cd 3b 97			call dumpcont 
96f9 3e 3c			ld a, display_row_4 
96fb 11 d5 95			ld de, endprog 
96fe			 
96fe cd b1 88			call update_display		 
9701			 
9701 cd 33 98			call next_page_prompt 
9704 c3 29 96			jp monitor 
9707			.moncdump: 
9707 cd 3b 97			call dumpcont 
970a 3e 3c			ld a, display_row_4 
970c 11 d5 95			ld de, endprog 
970f			 
970f cd b1 88			call update_display		 
9712			 
9712 cd 33 98			call next_page_prompt 
9715 c3 29 96			jp monitor 
9718			 
9718			 
9718			; TODO symbol access  
9718			 
9718			.symbols:     ;; A list of symbols that can be called up  
9718 56 ee			dw display_fb0 
971a .. 00			db "fb0",0  
971e eb ec		     	dw store_page 
9720 .. 00			db "store_page",0 
972b			 
972b			 
972b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
972b			 
972b 3a e7 e4			ld a,(scratch+1) 
972e fe 00			cp 0 
9730 28 09			jr z, dumpcont 
9732			 
9732				; no, not a null term line so has an address to work out.... 
9732			 
9732 21 e8 e4			ld hl,scratch+2 
9735 cd 72 8e			call get_word_hl 
9738			 
9738 22 09 e8			ld (os_cur_ptr),hl	 
973b			 
973b			 
973b			 
973b			dumpcont: 
973b			 
973b				; dump bytes at ptr 
973b			 
973b			 
973b 3e 00			ld a, display_row_1 
973d 2a 61 ed			ld hl, (display_fb_active) 
9740 cd bb 8a			call addatohl 
9743 cd 6b 97			call .dumpbyterow 
9746			 
9746 3e 14			ld a, display_row_2 
9748 2a 61 ed			ld hl, (display_fb_active) 
974b cd bb 8a			call addatohl 
974e cd 6b 97			call .dumpbyterow 
9751			 
9751			 
9751 3e 28			ld a, display_row_3 
9753 2a 61 ed			ld hl, (display_fb_active) 
9756 cd bb 8a			call addatohl 
9759 cd 6b 97			call .dumpbyterow 
975c			 
975c 3e 3c			ld a, display_row_4 
975e 2a 61 ed			ld hl, (display_fb_active) 
9761 cd bb 8a			call addatohl 
9764 cd 6b 97			call .dumpbyterow 
9767			 
9767 cd b1 88			call update_display 
976a			;		jp cli 
976a c9				ret 
976b			 
976b			.dumpbyterow: 
976b			 
976b				;push af 
976b			 
976b e5				push hl 
976c			 
976c				; calc where to poke the ascii 
976c			if display_cols == 20 
976c 3e 10			ld a, 16 
976e			else 
976e				ld a, 31 
976e			endif 
976e			 
976e cd bb 8a			call addatohl 
9771 22 eb e7			ld (os_word_scratch),hl  		; save pos for later 
9774			 
9774			 
9774			; display decoding address 
9774 2a 09 e8		   	ld hl,(os_cur_ptr) 
9777			 
9777 7c				ld a,h 
9778 e1				pop hl 
9779 e5				push hl 
977a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
977a cd bc 8d			call hexout 
977d 2a 09 e8		   	ld hl,(os_cur_ptr) 
9780			 
9780 7d				ld a,l 
9781 e1				pop hl 
9782 23				inc hl 
9783 23				inc hl 
9784 e5				push hl 
9785			;	ld hl, os_word_scratch+2 
9785 cd bc 8d			call hexout 
9788 e1				pop hl 
9789 23				inc hl 
978a 23				inc hl 
978b				;ld hl, os_word_scratch+4 
978b 3e 3a			ld a, ':' 
978d 77				ld (hl),a 
978e 23				inc hl 
978f				;ld a, 0 
978f				;ld (hl),a 
978f				;ld de, os_word_scratch 
978f				;pop af 
978f				;push af 
978f			;		ld a, display_row_2 
978f			;		call str_at_display 
978f			;		call update_display 
978f			 
978f			 
978f			;pop af 
978f			;	add 5 
978f			 
978f			if display_cols == 20 
978f 06 04			ld b, 4 
9791			else 
9791				ld b, 8 
9791			endif	 
9791			 
9791			.dumpbyte: 
9791 c5				push bc 
9792 e5				push hl 
9793			 
9793			 
9793 2a 09 e8		   	ld hl,(os_cur_ptr) 
9796 7e					ld a,(hl) 
9797			 
9797					; poke the ascii to display 
9797 2a eb e7				ld hl,(os_word_scratch) 
979a 77					ld (hl),a 
979b 23					inc hl 
979c 22 eb e7				ld (os_word_scratch),hl 
979f			 
979f					 
979f			 
979f			 
979f e1					pop hl 
97a0 e5					push hl 
97a1			 
97a1 cd bc 8d				call hexout 
97a4			 
97a4					 
97a4 2a 09 e8		   	ld hl,(os_cur_ptr) 
97a7 23				inc hl 
97a8 22 09 e8		   	ld (os_cur_ptr),hl 
97ab			 
97ab e1					pop hl 
97ac 23					inc hl 
97ad 23					inc hl 
97ae 23					inc hl 
97af			 
97af			 
97af			 
97af					;ld a,0 
97af					;ld (os_word_scratch+2),a 
97af					;pop af 
97af					;push af 
97af			 
97af					;ld de, os_word_scratch 
97af					;call str_at_display 
97af			;		call update_display 
97af			;		pop af 
97af c1					pop bc 
97b0 c6 03				add 3 
97b2 10 dd			djnz .dumpbyte 
97b4			 
97b4				 
97b4			 
97b4 c9				ret 
97b5			 
97b5			jump:	 
97b5			 
97b5 21 e8 e4			ld hl,scratch+2 
97b8 cd 72 8e			call get_word_hl 
97bb				;ld hl,(scratch+2) 
97bb				;call fourehexhl 
97bb			 
97bb 22 09 e8			ld (os_cur_ptr),hl	 
97be			 
97be e9				jp (hl) 
97bf			 
97bf			 
97bf			 
97bf			; TODO implement a basic monitor mode to start with 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			; testing and demo code during development 
97bf			 
97bf			 
97bf .. 00		str1: db "Enter some text...",0 
97d2 .. 00		clear: db "                    ",0 
97e7			 
97e7			demo: 
97e7			 
97e7			 
97e7			 
97e7			;	call update_display 
97e7			 
97e7				; init scratch input area for testing 
97e7 21 e6 e4			ld hl, scratch	 
97ea 3e 00			ld a,0 
97ec 77				ld (hl),a 
97ed			 
97ed			 
97ed 3e 14		            LD   A, display_row_2 
97ef			;            CALL fLCD_Pos       ;Position cursor to location in A 
97ef 11 bf 97		            LD   DE, str1 
97f2 cd a1 88			call str_at_display 
97f5			 
97f5			;            CALL fLCD_Str       ;Display string pointed to by DE 
97f5			cloop:	 
97f5 3e 28		            LD   A, display_row_3 
97f7			;            CALL fLCD_Pos       ;Position cursor to location in A 
97f7 11 d2 97		            LD   DE, clear 
97fa			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
97fa cd a1 88				call str_at_display 
97fd 3e 3c			ld a, display_row_4 
97ff 11 2f 98			ld de, prompt 
9802			 
9802 cd a1 88				call str_at_display 
9805 cd b1 88			call update_display 
9808			 
9808 3e 3d			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
980a 16 0a			ld d, 10 
980c 21 e6 e4			ld hl, scratch	 
980f cd e8 8a			call input_str 
9812			 
9812			;	call clear_display 
9812			;'	call update_display 
9812			 
9812 3e 00		            LD   A, display_row_1 
9814			;            CALL fLCD_Pos       ;Position cursor to location in A 
9814 11 d2 97		            LD   DE, clear 
9817 cd a1 88				call str_at_display 
981a			;            CALL fLCD_Str       ;Display string pointed to by DE 
981a 3e 00		            LD   A, display_row_1 
981c			;            CALL fLCD_Pos       ;Position cursor to location in A 
981c 11 e6 e4		            LD   DE, scratch 
981f			;            CALL fLCD_Str       ;Display string pointed to by DE 
981f cd a1 88				call str_at_display 
9822 cd b1 88			call update_display 
9825			 
9825 3e 00				ld a,0 
9827 21 e6 e4			ld hl, scratch 
982a 77				ld (hl),a 
982b			 
982b 00				nop 
982c c3 f5 97			jp cloop 
982f			 
982f			 
982f			 
982f			; OS Prompt 
982f			 
982f .. 00		prompt: db ">",0 
9831 .. 00		endprg: db "?",0 
9833			 
9833			 
9833			; handy next page prompt 
9833			next_page_prompt: 
9833 e5				push hl 
9834 d5				push de 
9835 f5				push af 
9836 c5				push bc 
9837			 
9837 3e 4f			ld a,display_row_4 + display_cols - 1 
9839 11 31 98		        ld de, endprg 
983c cd a1 88			call str_at_display 
983f cd b1 88			call update_display 
9842 cd 60 d7			call cin_wait 
9845 c1				pop bc 
9846 f1				pop af 
9847 d1				pop de 
9848 e1				pop hl 
9849			 
9849			 
9849 c9				ret 
984a			 
984a			 
984a			; forth parser 
984a			 
984a			; My forth kernel 
984a			include "forth_kernel.asm" 
984a			; 
984a			; kernel to the forth OS 
984a			 
984a			DS_TYPE_STR: equ 1     ; string type 
984a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
984a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
984a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
984a			 
984a			FORTH_PARSEV1: equ 0 
984a			FORTH_PARSEV2: equ 0 
984a			FORTH_PARSEV3: equ 0 
984a			FORTH_PARSEV4: equ 0 
984a			FORTH_PARSEV5: equ 1 
984a			 
984a			;if FORTH_PARSEV5 
984a			;	FORTH_END_BUFFER: equ 0 
984a			;else 
984a			FORTH_END_BUFFER: equ 127 
984a			;endif 
984a			 
984a			FORTH_TRUE: equ 1 
984a			FORTH_FALSE: equ 0 
984a			 
984a			if FORTH_PARSEV4 
984a			include "forth_stackops.asm" 
984a			endif 
984a			 
984a			if FORTH_PARSEV5 
984a			include "forth_stackopsv5.asm" 
984a			 
984a			; Stack operations for v5 parser on wards 
984a			; * DATA stack 
984a			; * LOOP stack 
984a			; * RETURN stack 
984a			 
984a			 
984a			 
984a			FORTH_CHK_DSP_UNDER: macro 
984a				push hl 
984a				push de 
984a				ld hl,(cli_data_sp) 
984a				ld de, cli_data_stack 
984a				call cmp16 
984a				jp c, fault_dsp_under 
984a				pop de 
984a				pop hl 
984a				endm 
984a			 
984a			 
984a			FORTH_CHK_RSP_UNDER: macro 
984a				push hl 
984a				push de 
984a				ld hl,(cli_ret_sp) 
984a				ld de, cli_ret_stack 
984a				call cmp16 
984a				jp c, fault_rsp_under 
984a				pop de 
984a				pop hl 
984a				endm 
984a			 
984a			FORTH_CHK_LOOP_UNDER: macro 
984a				push hl 
984a				push de 
984a				ld hl,(cli_loop_sp) 
984a				ld de, cli_loop_stack 
984a				call cmp16 
984a				jp c, fault_loop_under 
984a				pop de 
984a				pop hl 
984a				endm 
984a			 
984a			FORTH_ERR_TOS_NOTSTR: macro 
984a				; TOSO might need more for checks when used 
984a				push af 
984a				ld a,(hl) 
984a				cp DS_TYPE_STR 
984a				jp nz, type_faultn   
984a				pop af 
984a				endm 
984a			 
984a			FORTH_ERR_TOS_NOTNUM: macro 
984a				push af 
984a				ld a,(hl) 
984a				cp DS_TYPE_INUM 
984a				jp nz, type_faultn   
984a				pop af 
984a				endm 
984a			 
984a			 
984a			; increase data stack pointer and save hl to it 
984a				 
984a			FORTH_DSP_NEXT: macro 
984a				call macro_forth_dsp_next 
984a				endm 
984a			 
984a			 
984a			macro_forth_dsp_next: 
984a				if DEBUG_FORTH_STACK_GUARD 
984a cd c4 d4				call check_stacks 
984d				endif 
984d e5				push hl 
984e d5				push de 
984f eb				ex de,hl 
9850 2a 93 ec			ld hl,(cli_data_sp) 
9853 23				inc hl 
9854 23				inc hl 
9855			 
9855			; PARSEV5 
9855 23				inc hl 
9856 22 93 ec			ld (cli_data_sp),hl 
9859 73				ld (hl), e 
985a 23				inc hl 
985b 72				ld (hl), d 
985c d1				pop de 
985d e1				pop hl 
985e				if DEBUG_FORTH_STACK_GUARD 
985e cd c4 d4				call check_stacks 
9861				endif 
9861 c9				ret 
9862			 
9862			 
9862			; increase ret stack pointer and save hl to it 
9862				 
9862			FORTH_RSP_NEXT: macro 
9862				call macro_forth_rsp_next 
9862				endm 
9862			 
9862			macro_forth_rsp_next: 
9862				if DEBUG_FORTH_STACK_GUARD 
9862 cd c4 d4				call check_stacks 
9865				endif 
9865 e5				push hl 
9866 d5				push de 
9867 eb				ex de,hl 
9868 2a 97 ec			ld hl,(cli_ret_sp) 
986b 23				inc hl 
986c 23				inc hl 
986d 22 97 ec			ld (cli_ret_sp),hl 
9870 73				ld (hl), e 
9871 23				inc hl 
9872 72				ld (hl), d 
9873 d1				pop de 
9874 e1				pop hl 
9875				if DEBUG_FORTH_STACK_GUARD 
9875 cd c4 d4				call check_stacks 
9878				endif 
9878 c9				ret 
9879			 
9879			; get current ret stack pointer and save to hl  
9879				 
9879			FORTH_RSP_TOS: macro 
9879				call macro_forth_rsp_tos 
9879				endm 
9879			 
9879			macro_forth_rsp_tos: 
9879				;push de 
9879 2a 97 ec			ld hl,(cli_ret_sp) 
987c cd b4 98			call loadhlptrtohl 
987f				;ld e, (hl) 
987f				;inc hl 
987f				;ld d, (hl) 
987f				;ex de, hl 
987f					if DEBUG_FORTH_WORDS 
987f			;			DMARK "RST" 
987f						CALLMONITOR 
987f cd 2e 93			call break_point_state  
9882				endm  
# End of macro CALLMONITOR
9882					endif 
9882				;pop de 
9882 c9				ret 
9883			 
9883			; pop ret stack pointer 
9883				 
9883			FORTH_RSP_POP: macro 
9883				call macro_forth_rsp_pop 
9883				endm 
9883			 
9883			 
9883			macro_forth_rsp_pop: 
9883				if DEBUG_FORTH_STACK_GUARD 
9883			;		DMARK "RPP" 
9883 cd c4 d4				call check_stacks 
9886					FORTH_CHK_RSP_UNDER 
9886 e5				push hl 
9887 d5				push de 
9888 2a 97 ec			ld hl,(cli_ret_sp) 
988b 11 51 ec			ld de, cli_ret_stack 
988e cd d9 8a			call cmp16 
9891 da d8 d5			jp c, fault_rsp_under 
9894 d1				pop de 
9895 e1				pop hl 
9896				endm 
# End of macro FORTH_CHK_RSP_UNDER
9896				endif 
9896 e5				push hl 
9897 2a 97 ec			ld hl,(cli_ret_sp) 
989a			 
989a			 
989a				if FORTH_ENABLE_FREE 
989a			 
989a					; get pointer 
989a			 
989a					push de 
989a					push hl 
989a			 
989a					ld e, (hl) 
989a					inc hl 
989a					ld d, (hl) 
989a			 
989a					ex de, hl 
989a					call free 
989a			 
989a					pop hl 
989a					pop de 
989a			 
989a			 
989a				endif 
989a			 
989a			 
989a 2b				dec hl 
989b 2b				dec hl 
989c 22 97 ec			ld (cli_ret_sp), hl 
989f				; do stack underflow checks 
989f e1				pop hl 
98a0				if DEBUG_FORTH_STACK_GUARD 
98a0 cd c4 d4				call check_stacks 
98a3					FORTH_CHK_RSP_UNDER 
98a3 e5				push hl 
98a4 d5				push de 
98a5 2a 97 ec			ld hl,(cli_ret_sp) 
98a8 11 51 ec			ld de, cli_ret_stack 
98ab cd d9 8a			call cmp16 
98ae da d8 d5			jp c, fault_rsp_under 
98b1 d1				pop de 
98b2 e1				pop hl 
98b3				endm 
# End of macro FORTH_CHK_RSP_UNDER
98b3				endif 
98b3 c9				ret 
98b4			 
98b4			 
98b4			 
98b4			; routine to load word pointed to by hl into hl 
98b4			 
98b4			loadhlptrtohl: 
98b4			 
98b4 d5				push de 
98b5 5e				ld e, (hl) 
98b6 23				inc hl 
98b7 56				ld d, (hl) 
98b8 eb				ex de, hl 
98b9 d1				pop de 
98ba			 
98ba c9				ret 
98bb			 
98bb			 
98bb			 
98bb			 
98bb			 
98bb			; push a number held in HL onto the data stack 
98bb			; entry point for pushing a value when already in hl used in function above 
98bb			 
98bb			forth_push_numhl: 
98bb			 
98bb e5				push hl    ; save value to push 
98bc			 
98bc			if DEBUG_FORTH_PUSH 
98bc				; see if disabled 
98bc			 
98bc			 
98bc f5				push af 
98bd 3a d7 e4			ld a, (os_view_disable) 
98c0 fe 2a			cp '*' 
98c2 28 34			jr z, .pskip2 
98c4 e5				push hl 
98c5 e5			push hl 
98c6 cd 8e 88			call clear_display 
98c9 e1			pop hl 
98ca 7c				ld a,h 
98cb 21 eb e7			ld hl, os_word_scratch 
98ce cd bc 8d			call hexout 
98d1 e1				pop hl 
98d2 7d				ld a,l 
98d3 21 ed e7			ld hl, os_word_scratch+2 
98d6 cd bc 8d			call hexout 
98d9			 
98d9 21 ef e7			ld hl, os_word_scratch+4 
98dc 3e 00			ld a,0 
98de 77				ld (hl),a 
98df 11 eb e7			ld de,os_word_scratch 
98e2 3e 14				ld a, display_row_2 
98e4 cd a1 88				call str_at_display 
98e7 11 d2 c3			ld de, .push_num 
98ea 3e 00			ld a, display_row_1 
98ec			 
98ec cd a1 88				call str_at_display 
98ef			 
98ef			 
98ef cd b1 88			call update_display 
98f2 cd 0e 88			call delay1s 
98f5 cd 0e 88			call delay1s 
98f8			.pskip2:  
98f8			 
98f8 f1				pop af 
98f9			endif	 
98f9			 
98f9			 
98f9				FORTH_DSP_NEXT 
98f9 cd 4a 98			call macro_forth_dsp_next 
98fc				endm 
# End of macro FORTH_DSP_NEXT
98fc			 
98fc 2a 93 ec			ld hl, (cli_data_sp) 
98ff			 
98ff				; save item type 
98ff 3e 02			ld a,  DS_TYPE_INUM 
9901 77				ld (hl), a 
9902 23				inc hl 
9903			 
9903				; get word off stack 
9903 d1				pop de 
9904 7b				ld a,e 
9905 77				ld (hl), a 
9906 23				inc hl 
9907 7a				ld a,d 
9908 77				ld (hl), a 
9909			 
9909			if DEBUG_FORTH_PUSH 
9909 2b				dec hl 
990a 2b				dec hl 
990b 2b				dec hl 
990c						DMARK "PH5" 
990c f5				push af  
990d 3a 21 99			ld a, (.dmark)  
9910 32 c0 ee			ld (debug_mark),a  
9913 3a 22 99			ld a, (.dmark+1)  
9916 32 c1 ee			ld (debug_mark+1),a  
9919 3a 23 99			ld a, (.dmark+2)  
991c 32 c2 ee			ld (debug_mark+2),a  
991f 18 03			jr .pastdmark  
9921 ..			.dmark: db "PH5"  
9924 f1			.pastdmark: pop af  
9925			endm  
# End of macro DMARK
9925				CALLMONITOR 
9925 cd 2e 93			call break_point_state  
9928				endm  
# End of macro CALLMONITOR
9928			endif	 
9928			 
9928 c9				ret 
9929			 
9929			 
9929			; Push a string to stack pointed to by hl 
9929			 
9929			forth_push_str: 
9929			 
9929			if DEBUG_FORTH_PUSH 
9929						DMARK "PSQ" 
9929 f5				push af  
992a 3a 3e 99			ld a, (.dmark)  
992d 32 c0 ee			ld (debug_mark),a  
9930 3a 3f 99			ld a, (.dmark+1)  
9933 32 c1 ee			ld (debug_mark+1),a  
9936 3a 40 99			ld a, (.dmark+2)  
9939 32 c2 ee			ld (debug_mark+2),a  
993c 18 03			jr .pastdmark  
993e ..			.dmark: db "PSQ"  
9941 f1			.pastdmark: pop af  
9942			endm  
# End of macro DMARK
9942				CALLMONITOR 
9942 cd 2e 93			call break_point_state  
9945				endm  
# End of macro CALLMONITOR
9945			endif	 
9945			    
9945 e5				push hl 
9946 e5				push hl 
9947			 
9947			;	ld a, 0   ; find end of string 
9947 cd 19 8f			call strlenz 
994a			if DEBUG_FORTH_PUSH 
994a						DMARK "PQ2" 
994a f5				push af  
994b 3a 5f 99			ld a, (.dmark)  
994e 32 c0 ee			ld (debug_mark),a  
9951 3a 60 99			ld a, (.dmark+1)  
9954 32 c1 ee			ld (debug_mark+1),a  
9957 3a 61 99			ld a, (.dmark+2)  
995a 32 c2 ee			ld (debug_mark+2),a  
995d 18 03			jr .pastdmark  
995f ..			.dmark: db "PQ2"  
9962 f1			.pastdmark: pop af  
9963			endm  
# End of macro DMARK
9963				CALLMONITOR 
9963 cd 2e 93			call break_point_state  
9966				endm  
# End of macro CALLMONITOR
9966			endif	 
9966 eb				ex de, hl 
9967 e1				pop hl   ; get ptr to start of string 
9968			if DEBUG_FORTH_PUSH 
9968						DMARK "PQ3" 
9968 f5				push af  
9969 3a 7d 99			ld a, (.dmark)  
996c 32 c0 ee			ld (debug_mark),a  
996f 3a 7e 99			ld a, (.dmark+1)  
9972 32 c1 ee			ld (debug_mark+1),a  
9975 3a 7f 99			ld a, (.dmark+2)  
9978 32 c2 ee			ld (debug_mark+2),a  
997b 18 03			jr .pastdmark  
997d ..			.dmark: db "PQ3"  
9980 f1			.pastdmark: pop af  
9981			endm  
# End of macro DMARK
9981				CALLMONITOR 
9981 cd 2e 93			call break_point_state  
9984				endm  
# End of macro CALLMONITOR
9984			endif	 
9984 19				add hl,de 
9985			if DEBUG_FORTH_PUSH 
9985						DMARK "PQE" 
9985 f5				push af  
9986 3a 9a 99			ld a, (.dmark)  
9989 32 c0 ee			ld (debug_mark),a  
998c 3a 9b 99			ld a, (.dmark+1)  
998f 32 c1 ee			ld (debug_mark+1),a  
9992 3a 9c 99			ld a, (.dmark+2)  
9995 32 c2 ee			ld (debug_mark+2),a  
9998 18 03			jr .pastdmark  
999a ..			.dmark: db "PQE"  
999d f1			.pastdmark: pop af  
999e			endm  
# End of macro DMARK
999e				CALLMONITOR 
999e cd 2e 93			call break_point_state  
99a1				endm  
# End of macro CALLMONITOR
99a1			endif	 
99a1			 
99a1 2b				dec hl    ; see if there is an optional trailing double quote 
99a2 7e				ld a,(hl) 
99a3 fe 22			cp '"' 
99a5 20 03			jr nz, .strnoq 
99a7 3e 00			ld a, 0      ; get rid of double quote 
99a9 77				ld (hl), a 
99aa 23			.strnoq: inc hl 
99ab			 
99ab 3e 00			ld a, 0 
99ad 77				ld (hl), a     ; add null term and get rid of trailing double quote 
99ae			 
99ae 13				inc de ; add one for the type string 
99af 13				inc de ; add one for null term??? 
99b0			 
99b0				; tos is get string pointer again 
99b0				; de contains space to allocate 
99b0				 
99b0 d5				push de 
99b1			 
99b1 eb				ex de, hl 
99b2			 
99b2				;push af 
99b2			 
99b2			if DEBUG_FORTH_PUSH 
99b2						DMARK "PHm" 
99b2 f5				push af  
99b3 3a c7 99			ld a, (.dmark)  
99b6 32 c0 ee			ld (debug_mark),a  
99b9 3a c8 99			ld a, (.dmark+1)  
99bc 32 c1 ee			ld (debug_mark+1),a  
99bf 3a c9 99			ld a, (.dmark+2)  
99c2 32 c2 ee			ld (debug_mark+2),a  
99c5 18 03			jr .pastdmark  
99c7 ..			.dmark: db "PHm"  
99ca f1			.pastdmark: pop af  
99cb			endm  
# End of macro DMARK
99cb				CALLMONITOR 
99cb cd 2e 93			call break_point_state  
99ce				endm  
# End of macro CALLMONITOR
99ce			endif	 
99ce cd 82 8f			call malloc	; on ret hl now contains allocated memory 
99d1				if DEBUG_FORTH_MALLOC_GUARD 
99d1 cc 2a c4				call z,malloc_error 
99d4				endif 
99d4			 
99d4				 
99d4 c1				pop bc    ; get length 
99d5 d1				pop de   ;  get string start    
99d6			 
99d6				; hl has destination from malloc 
99d6			 
99d6 eb				ex de, hl    ; prep for ldir 
99d7			 
99d7 d5				push de   ; save malloc area for DSP later 
99d8				;push hl   ; save malloc area for DSP later 
99d8			 
99d8			if DEBUG_FORTH_PUSH 
99d8						DMARK "PHc" 
99d8 f5				push af  
99d9 3a ed 99			ld a, (.dmark)  
99dc 32 c0 ee			ld (debug_mark),a  
99df 3a ee 99			ld a, (.dmark+1)  
99e2 32 c1 ee			ld (debug_mark+1),a  
99e5 3a ef 99			ld a, (.dmark+2)  
99e8 32 c2 ee			ld (debug_mark+2),a  
99eb 18 03			jr .pastdmark  
99ed ..			.dmark: db "PHc"  
99f0 f1			.pastdmark: pop af  
99f1			endm  
# End of macro DMARK
99f1				CALLMONITOR 
99f1 cd 2e 93			call break_point_state  
99f4				endm  
# End of macro CALLMONITOR
99f4			endif	 
99f4			 
99f4			 
99f4 ed b0			ldir 
99f6			 
99f6			 
99f6				; push malloc to data stack     macro?????  
99f6			 
99f6				FORTH_DSP_NEXT 
99f6 cd 4a 98			call macro_forth_dsp_next 
99f9				endm 
# End of macro FORTH_DSP_NEXT
99f9			 
99f9				; save value and type 
99f9			 
99f9 2a 93 ec			ld hl, (cli_data_sp) 
99fc			 
99fc				; save item type 
99fc 3e 01			ld a,  DS_TYPE_STR 
99fe 77				ld (hl), a 
99ff 23				inc hl 
9a00			 
9a00				; get malloc word off stack 
9a00 d1				pop de 
9a01 73				ld (hl), e 
9a02 23				inc hl 
9a03 72				ld (hl), d 
9a04			 
9a04			 
9a04			 
9a04			if DEBUG_FORTH_PUSH 
9a04 2a 93 ec			ld hl, (cli_data_sp) 
9a07						DMARK "PHS" 
9a07 f5				push af  
9a08 3a 1c 9a			ld a, (.dmark)  
9a0b 32 c0 ee			ld (debug_mark),a  
9a0e 3a 1d 9a			ld a, (.dmark+1)  
9a11 32 c1 ee			ld (debug_mark+1),a  
9a14 3a 1e 9a			ld a, (.dmark+2)  
9a17 32 c2 ee			ld (debug_mark+2),a  
9a1a 18 03			jr .pastdmark  
9a1c ..			.dmark: db "PHS"  
9a1f f1			.pastdmark: pop af  
9a20			endm  
# End of macro DMARK
9a20				CALLMONITOR 
9a20 cd 2e 93			call break_point_state  
9a23				endm  
# End of macro CALLMONITOR
9a23			;	ex de,hl 
9a23			endif	 
9a23				; in case of spaces, skip the ptr past the copied string 
9a23				;pop af 
9a23				;ld (cli_origptr),hl 
9a23			 
9a23 c9				ret 
9a24			 
9a24			 
9a24			 
9a24			; TODO ascii push input onto stack given hl to start of input 
9a24			 
9a24			; identify type 
9a24			; if starts with a " then a string 
9a24			; otherwise it is a number 
9a24			;  
9a24			; if a string 
9a24			;     scan for ending " to get length of string to malloc for + 1 
9a24			;     malloc 
9a24			;     put pointer to string on stack first byte flags as string 
9a24			; 
9a24			; else a number 
9a24			;    look for number format identifier 
9a24			;    $xx hex 
9a24			;    %xxxxx bin 
9a24			;    xxxxx decimal 
9a24			;    convert number to 16bit word.  
9a24			;    malloc word + 1 with flag to identiy as num 
9a24			;    put pointer to number on stack 
9a24			;   
9a24			;  
9a24			  
9a24			forth_apush: 
9a24				; kernel push 
9a24			 
9a24			if DEBUG_FORTH_PUSH 
9a24						DMARK "PSH" 
9a24 f5				push af  
9a25 3a 39 9a			ld a, (.dmark)  
9a28 32 c0 ee			ld (debug_mark),a  
9a2b 3a 3a 9a			ld a, (.dmark+1)  
9a2e 32 c1 ee			ld (debug_mark+1),a  
9a31 3a 3b 9a			ld a, (.dmark+2)  
9a34 32 c2 ee			ld (debug_mark+2),a  
9a37 18 03			jr .pastdmark  
9a39 ..			.dmark: db "PSH"  
9a3c f1			.pastdmark: pop af  
9a3d			endm  
# End of macro DMARK
9a3d				CALLMONITOR 
9a3d cd 2e 93			call break_point_state  
9a40				endm  
# End of macro CALLMONITOR
9a40			endif	 
9a40				; identify input type 
9a40			 
9a40 7e				ld a,(hl) 
9a41 fe 22			cp '"' 
9a43 28 0a			jr z, .fapstr 
9a45 fe 24			cp '$' 
9a47 ca 6f 9a			jp z, .faphex 
9a4a fe 25			cp '%' 
9a4c ca 57 9a			jp z, .fapbin 
9a4f			;	cp 'b' 
9a4f			;	jp z, .fabin 
9a4f				; else decimal 
9a4f			 
9a4f				; TODO do decimal conversion 
9a4f				; decimal is stored as a 16bit word 
9a4f			 
9a4f				; by default everything is a string if type is not detected 
9a4f			.fapstr: ; 
9a4f fe 22			cp '"' 
9a51 20 01			jr nz, .strnoqu 
9a53 23				inc hl 
9a54			.strnoqu: 
9a54 c3 29 99			jp forth_push_str 
9a57			 
9a57			 
9a57			 
9a57			.fapbin:    ; push a binary string.  
9a57 11 00 00			ld de, 0   ; hold a 16bit value 
9a5a			 
9a5a 23			.fapbinshift:	inc hl  
9a5b 7e				ld a,(hl) 
9a5c fe 00			cp 0     ; done scanning  
9a5e 28 0b			jr z, .fapbdone  	; got it in HL so push  
9a60			 
9a60				; left shift de 
9a60 eb				ex de, hl	 
9a61 29				add hl, hl 
9a62			 
9a62				; is 1 
9a62 fe 31			cp '1' 
9a64 20 02			jr nz, .binzero 
9a66 cb 4d			bit 1, l 
9a68			.binzero: 
9a68 eb				ex de, hl	 ; save current de 
9a69 18 ef			jr .fapbinshift 
9a6b			 
9a6b			.fapbdone: 
9a6b eb				ex de, hl 
9a6c c3 bb 98			jp forth_push_numhl 
9a6f			 
9a6f			 
9a6f			.faphex:   ; hex is always stored as a 16bit word 
9a6f				; skip number prefix 
9a6f 23				inc hl 
9a70				; turn ascii into number 
9a70 cd 72 8e			call get_word_hl	; ret 16bit word in hl 
9a73			 
9a73 c3 bb 98			jp forth_push_numhl 
9a76			 
9a76 00				 nop 
9a77			 
9a77			.fabin:   ; TODO bin conversion 
9a77			 
9a77			 
9a77 c9				ret 
9a78			 
9a78			 
9a78			; get either a string ptr or a 16bit word from the data stack 
9a78			 
9a78			FORTH_DSP: macro 
9a78				call macro_forth_dsp 
9a78				endm 
9a78			 
9a78			macro_forth_dsp: 
9a78				; data stack pointer points to current word on tos 
9a78			 
9a78 2a 93 ec			ld hl,(cli_data_sp) 
9a7b			 
9a7b				if DEBUG_FORTH_PUSH 
9a7b						DMARK "DSP" 
9a7b f5				push af  
9a7c 3a 90 9a			ld a, (.dmark)  
9a7f 32 c0 ee			ld (debug_mark),a  
9a82 3a 91 9a			ld a, (.dmark+1)  
9a85 32 c1 ee			ld (debug_mark+1),a  
9a88 3a 92 9a			ld a, (.dmark+2)  
9a8b 32 c2 ee			ld (debug_mark+2),a  
9a8e 18 03			jr .pastdmark  
9a90 ..			.dmark: db "DSP"  
9a93 f1			.pastdmark: pop af  
9a94			endm  
# End of macro DMARK
9a94			 
9a94 cd 5f c4				call display_data_sp 
9a97				;call break_point_state 
9a97				;rst 030h 
9a97				CALLMONITOR 
9a97 cd 2e 93			call break_point_state  
9a9a				endm  
# End of macro CALLMONITOR
9a9a				endif 
9a9a			 
9a9a c9				ret 
9a9b			 
9a9b			; return hl to start of value on stack 
9a9b			 
9a9b			FORTH_DSP_VALUE: macro 
9a9b				call macro_forth_dsp_value 
9a9b				endm 
9a9b			 
9a9b			macro_forth_dsp_value: 
9a9b			 
9a9b				FORTH_DSP 
9a9b cd 78 9a			call macro_forth_dsp 
9a9e				endm 
# End of macro FORTH_DSP
9a9e			 
9a9e d5				push de 
9a9f			 
9a9f 23				inc hl ; skip type 
9aa0			 
9aa0 5e				ld e, (hl) 
9aa1 23				inc hl 
9aa2 56				ld d, (hl) 
9aa3 eb				ex de,hl  
9aa4			 
9aa4 d1				pop de 
9aa5			 
9aa5 c9				ret 
9aa6			 
9aa6			; return hl to start of value to second item on stack 
9aa6			 
9aa6			FORTH_DSP_VALUEM1: macro 
9aa6				call macro_forth_dsp_value_m1 
9aa6				endm 
9aa6			 
9aa6			macro_forth_dsp_value_m1: 
9aa6			 
9aa6				FORTH_DSP 
9aa6 cd 78 9a			call macro_forth_dsp 
9aa9				endm 
# End of macro FORTH_DSP
9aa9			 
9aa9 2b				dec hl 
9aaa 2b				dec hl 
9aab			;	dec hl 
9aab			 
9aab d5				push de 
9aac			 
9aac 5e				ld e, (hl) 
9aad 23				inc hl 
9aae 56				ld d, (hl) 
9aaf eb				ex de,hl  
9ab0			 
9ab0 d1				pop de 
9ab1			 
9ab1 c9				ret 
9ab2			 
9ab2				 
9ab2			 
9ab2			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9ab2			 
9ab2			FORTH_DSP_POP: macro 
9ab2				call macro_forth_dsp_pop 
9ab2				endm 
9ab2			 
9ab2			 
9ab2			; get the tos data type 
9ab2			 
9ab2			FORTH_DSP_TYPE:   macro 
9ab2			 
9ab2				;FORTH_DSP_VALUE 
9ab2				FORTH_DSP 
9ab2				 
9ab2				; hl points to value 
9ab2				; check type 
9ab2			 
9ab2				ld a,(hl) 
9ab2			 
9ab2				endm 
9ab2			 
9ab2			; load the tos value into hl 
9ab2			 
9ab2			 
9ab2			FORTH_DSP_VALUEHL:  macro 
9ab2				call macro_dsp_valuehl 
9ab2				endm 
9ab2			 
9ab2			 
9ab2			 
9ab2			macro_dsp_valuehl: 
9ab2				FORTH_DSP_VALUE 
9ab2 cd 9b 9a			call macro_forth_dsp_value 
9ab5				endm 
# End of macro FORTH_DSP_VALUE
9ab5			 
9ab5				;FORTH_ERR_TOS_NOTNUM 
9ab5			 
9ab5				;inc hl   ; skip type id 
9ab5			 
9ab5			;	push de 
9ab5			; 
9ab5			;	ld e, (hl) 
9ab5			;	inc hl 
9ab5			;	ld d, (hl) 
9ab5			;	ex de,hl  
9ab5			 
9ab5			;	pop de 
9ab5			 
9ab5				if DEBUG_FORTH_PUSH 
9ab5						DMARK "DVL" 
9ab5 f5				push af  
9ab6 3a ca 9a			ld a, (.dmark)  
9ab9 32 c0 ee			ld (debug_mark),a  
9abc 3a cb 9a			ld a, (.dmark+1)  
9abf 32 c1 ee			ld (debug_mark+1),a  
9ac2 3a cc 9a			ld a, (.dmark+2)  
9ac5 32 c2 ee			ld (debug_mark+2),a  
9ac8 18 03			jr .pastdmark  
9aca ..			.dmark: db "DVL"  
9acd f1			.pastdmark: pop af  
9ace			endm  
# End of macro DMARK
9ace				CALLMONITOR 
9ace cd 2e 93			call break_point_state  
9ad1				endm  
# End of macro CALLMONITOR
9ad1				endif 
9ad1 c9				ret 
9ad2			 
9ad2			forth_apushstrhl:      
9ad2				; push of string requires use of cli_origptr 
9ad2				; bodge use 
9ad2			 
9ad2				; get current cli_origptr, save, update with temp pointer  
9ad2 ed 5b af ec		ld de, (cli_origptr) 
9ad6 22 af ec			ld (cli_origptr), hl 
9ad9 d5				push de 
9ada cd 24 9a			call forth_apush 
9add d1				pop de 
9ade ed 53 af ec		ld (cli_origptr), de 
9ae2 c9			        ret	 
9ae3			 
9ae3			 
9ae3			; increase loop stack pointer and save hl to it 
9ae3				 
9ae3			FORTH_LOOP_NEXT: macro 
9ae3				call macro_forth_loop_next 
9ae3				;nop 
9ae3				endm 
9ae3			 
9ae3			macro_forth_loop_next: 
9ae3				if DEBUG_FORTH_STACK_GUARD 
9ae3 cd c4 d4				call check_stacks 
9ae6				endif 
9ae6 e5				push hl 
9ae7 d5				push de 
9ae8 eb				ex de,hl 
9ae9 2a 95 ec			ld hl,(cli_loop_sp) 
9aec 23				inc hl 
9aed 23				inc hl 
9aee					if DEBUG_FORTH_WORDS 
9aee						DMARK "LNX" 
9aee f5				push af  
9aef 3a 03 9b			ld a, (.dmark)  
9af2 32 c0 ee			ld (debug_mark),a  
9af5 3a 04 9b			ld a, (.dmark+1)  
9af8 32 c1 ee			ld (debug_mark+1),a  
9afb 3a 05 9b			ld a, (.dmark+2)  
9afe 32 c2 ee			ld (debug_mark+2),a  
9b01 18 03			jr .pastdmark  
9b03 ..			.dmark: db "LNX"  
9b06 f1			.pastdmark: pop af  
9b07			endm  
# End of macro DMARK
9b07						CALLMONITOR 
9b07 cd 2e 93			call break_point_state  
9b0a				endm  
# End of macro CALLMONITOR
9b0a					endif 
9b0a 22 95 ec			ld (cli_loop_sp),hl 
9b0d 73				ld (hl), e 
9b0e 23				inc hl 
9b0f 72				ld (hl), d 
9b10 d1				pop de    ; been reversed so save a swap on restore 
9b11 e1				pop hl 
9b12				if DEBUG_FORTH_STACK_GUARD 
9b12 cd c4 d4				call check_stacks 
9b15				endif 
9b15 c9				ret 
9b16			 
9b16			; get current ret stack pointer and save to hl  
9b16				 
9b16			FORTH_LOOP_TOS: macro 
9b16				call macro_forth_loop_tos 
9b16				endm 
9b16			 
9b16			macro_forth_loop_tos: 
9b16 d5				push de 
9b17 2a 95 ec			ld hl,(cli_loop_sp) 
9b1a 5e				ld e, (hl) 
9b1b 23				inc hl 
9b1c 56				ld d, (hl) 
9b1d eb				ex de, hl 
9b1e d1				pop de 
9b1f c9				ret 
9b20			 
9b20			; pop loop stack pointer 
9b20				 
9b20			FORTH_LOOP_POP: macro 
9b20				call macro_forth_loop_pop 
9b20				endm 
9b20			 
9b20			 
9b20			macro_forth_loop_pop: 
9b20				if DEBUG_FORTH_STACK_GUARD 
9b20					DMARK "LPP" 
9b20 f5				push af  
9b21 3a 35 9b			ld a, (.dmark)  
9b24 32 c0 ee			ld (debug_mark),a  
9b27 3a 36 9b			ld a, (.dmark+1)  
9b2a 32 c1 ee			ld (debug_mark+1),a  
9b2d 3a 37 9b			ld a, (.dmark+2)  
9b30 32 c2 ee			ld (debug_mark+2),a  
9b33 18 03			jr .pastdmark  
9b35 ..			.dmark: db "LPP"  
9b38 f1			.pastdmark: pop af  
9b39			endm  
# End of macro DMARK
9b39 cd c4 d4				call check_stacks 
9b3c					FORTH_CHK_LOOP_UNDER 
9b3c e5				push hl 
9b3d d5				push de 
9b3e 2a 95 ec			ld hl,(cli_loop_sp) 
9b41 11 4f eb			ld de, cli_loop_stack 
9b44 cd d9 8a			call cmp16 
9b47 da de d5			jp c, fault_loop_under 
9b4a d1				pop de 
9b4b e1				pop hl 
9b4c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b4c				endif 
9b4c e5				push hl 
9b4d 2a 95 ec			ld hl,(cli_loop_sp) 
9b50 2b				dec hl 
9b51 2b				dec hl 
9b52 22 95 ec			ld (cli_loop_sp), hl 
9b55				; TODO do stack underflow checks 
9b55 e1				pop hl 
9b56				if DEBUG_FORTH_STACK_GUARD 
9b56 cd c4 d4				call check_stacks 
9b59					FORTH_CHK_LOOP_UNDER 
9b59 e5				push hl 
9b5a d5				push de 
9b5b 2a 95 ec			ld hl,(cli_loop_sp) 
9b5e 11 4f eb			ld de, cli_loop_stack 
9b61 cd d9 8a			call cmp16 
9b64 da de d5			jp c, fault_loop_under 
9b67 d1				pop de 
9b68 e1				pop hl 
9b69				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b69				endif 
9b69 c9				ret 
9b6a			 
9b6a			macro_forth_dsp_pop: 
9b6a			 
9b6a e5				push hl 
9b6b			 
9b6b				; release malloc data 
9b6b			 
9b6b				if DEBUG_FORTH_STACK_GUARD 
9b6b cd c4 d4				call check_stacks 
9b6e					FORTH_CHK_DSP_UNDER 
9b6e e5				push hl 
9b6f d5				push de 
9b70 2a 93 ec			ld hl,(cli_data_sp) 
9b73 11 4d ea			ld de, cli_data_stack 
9b76 cd d9 8a			call cmp16 
9b79 da d2 d5			jp c, fault_dsp_under 
9b7c d1				pop de 
9b7d e1				pop hl 
9b7e				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b7e				endif 
9b7e				;ld hl,(cli_data_sp) 
9b7e			if DEBUG_FORTH_DOT 
9b7e				DMARK "DPP" 
9b7e				CALLMONITOR 
9b7e			endif	 
9b7e			 
9b7e			 
9b7e			if FORTH_ENABLE_DSPPOPFREE 
9b7e			 
9b7e				FORTH_DSP 
9b7e cd 78 9a			call macro_forth_dsp 
9b81				endm 
# End of macro FORTH_DSP
9b81			 
9b81 7e				ld a, (hl) 
9b82 fe 01			cp DS_TYPE_STR 
9b84 20 07			jr nz, .skippopfree 
9b86			 
9b86				FORTH_DSP_VALUEHL 
9b86 cd b2 9a			call macro_dsp_valuehl 
9b89				endm 
# End of macro FORTH_DSP_VALUEHL
9b89 00				nop 
9b8a			if DEBUG_FORTH_DOT 
9b8a				DMARK "DPf" 
9b8a				CALLMONITOR 
9b8a			endif	 
9b8a cd 4c 90			call free 
9b8d			.skippopfree: 
9b8d				 
9b8d			 
9b8d			endif 
9b8d			 
9b8d			if DEBUG_FORTH_DOT_KEY 
9b8d				DMARK "DP2" 
9b8d				CALLMONITOR 
9b8d			endif	 
9b8d			 
9b8d				; move pointer down 
9b8d			 
9b8d 2a 93 ec			ld hl,(cli_data_sp) 
9b90 2b				dec hl 
9b91 2b				dec hl 
9b92			; PARSEV5 
9b92 2b				dec hl 
9b93 22 93 ec			ld (cli_data_sp), hl 
9b96			 
9b96				if DEBUG_FORTH_STACK_GUARD 
9b96 cd c4 d4				call check_stacks 
9b99					FORTH_CHK_DSP_UNDER 
9b99 e5				push hl 
9b9a d5				push de 
9b9b 2a 93 ec			ld hl,(cli_data_sp) 
9b9e 11 4d ea			ld de, cli_data_stack 
9ba1 cd d9 8a			call cmp16 
9ba4 da d2 d5			jp c, fault_dsp_under 
9ba7 d1				pop de 
9ba8 e1				pop hl 
9ba9				endm 
# End of macro FORTH_CHK_DSP_UNDER
9ba9				endif 
9ba9			 
9ba9 e1				pop hl 
9baa			 
9baa c9				ret 
9bab			 
9bab			getwordathl: 
9bab				; hl points to an address 
9bab				; load hl with the word at that address 
9bab			 
9bab d5				push de 
9bac			 
9bac 5e				ld e, (hl) 
9bad 23				inc hl 
9bae 56				ld d, (hl) 
9baf eb				ex de, hl 
9bb0			 
9bb0 d1				pop de 
9bb1 c9				ret 
9bb2			 
9bb2			 
9bb2			 
9bb2			 
9bb2			 
9bb2			; eof 
9bb2			 
# End of file forth_stackopsv5.asm
9bb2			endif 
9bb2			 
9bb2			user_word_eol:  
9bb2				; hl contains the pointer to where to create a linked list item from the end 
9bb2				; of the user dict to continue on at the system word dict 
9bb2				 
9bb2				; poke the stub of the word list linked list to repoint to rom words 
9bb2			 
9bb2				; stub format 
9bb2				; db   word id 
9bb2				; dw    link to next word 
9bb2			        ; db char length of token 
9bb2				; db string + 0 term 
9bb2				; db exec code....  
9bb2			 
9bb2 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9bb4 77				ld (hl), a		; word id 
9bb5 23				inc hl 
9bb6			 
9bb6 11 7c 9d			ld de, sysdict 
9bb9 73				ld (hl), e		; next word link ie system dict 
9bba 23				inc hl 
9bbb 72				ld (hl), d		; next word link ie system dict 
9bbc 23				inc hl	 
9bbd			 
9bbd			;	ld (hl), sysdict		; next word link ie system dict 
9bbd			;	inc hl 
9bbd			;	inc hl 
9bbd			 
9bbd			;	inc hl 
9bbd			;	inc hl 
9bbd			 
9bbd 3e 02			ld a, 2			; word length is 0 
9bbf 77				ld (hl), a	 
9bc0 23				inc hl 
9bc1			 
9bc1 3e 7e			ld a, '~'			; word length is 0 
9bc3 77				ld (hl), a	 
9bc4 23				inc hl 
9bc5 3e 00			ld a, 0			; save empty word 
9bc7 77				ld (hl), a 
9bc8			 
9bc8 c9				ret 
9bc9			 
9bc9				 
9bc9			 
9bc9			forthexec_cleanup: 
9bc9				FORTH_RSP_POP 
9bc9 cd 83 98			call macro_forth_rsp_pop 
9bcc				endm 
# End of macro FORTH_RSP_POP
9bcc c9				ret 
9bcd			 
9bcd			forth_call_hl: 
9bcd				; taking hl 
9bcd e5				push hl 
9bce c9				ret 
9bcf			 
9bcf			; this is called to reset Forth system but keep existing uwords etc 
9bcf			 
9bcf			forth_warmstart: 
9bcf				; setup stack over/under flow checks 
9bcf				if DEBUG_FORTH_STACK_GUARD 
9bcf cd aa d4				call chk_stk_init 
9bd2				endif 
9bd2			 
9bd2				; init stack pointers  - * these stacks go upwards *  
9bd2 21 51 ec			ld hl, cli_ret_stack 
9bd5 22 97 ec			ld (cli_ret_sp), hl	 
9bd8				; set bottom of stack 
9bd8 3e 00			ld a,0 
9bda 77				ld (hl),a 
9bdb 23				inc hl 
9bdc 77				ld (hl),a 
9bdd			 
9bdd 21 4d ea			ld hl, cli_data_stack 
9be0 22 93 ec			ld (cli_data_sp), hl	 
9be3				; set bottom of stack 
9be3 3e 00			ld a,0 
9be5 77				ld (hl),a 
9be6 23				inc hl 
9be7 77				ld (hl),a 
9be8			 
9be8 21 4f eb			ld hl, cli_loop_stack 
9beb 22 95 ec			ld (cli_loop_sp), hl	 
9bee				; set bottom of stack 
9bee 3e 00			ld a,0 
9bf0 77				ld (hl),a 
9bf1 23				inc hl 
9bf2 77				ld (hl),a 
9bf3			 
9bf3				; init extent of current open file 
9bf3			 
9bf3 3e 00			ld a, 0 
9bf5 32 e2 ec			ld (store_openext), a 
9bf8			 
9bf8 c9				ret 
9bf9			 
9bf9			 
9bf9			; Cold Start - this is called to setup the whole Forth system 
9bf9			 
9bf9			forth_init: 
9bf9			 
9bf9				; setup stack over/under flow checks 
9bf9			 
9bf9			;	if DEBUG_FORTH_STACK_GUARD 
9bf9			;		call chk_stk_init 
9bf9			;	endif 
9bf9			 
9bf9				; enable auto display updates (slow.....) 
9bf9			 
9bf9 3e 01			ld a, 1 
9bfb 32 ad ec			ld (cli_autodisplay), a 
9bfe			 
9bfe			 
9bfe			 
9bfe				; show start up screen 
9bfe			 
9bfe cd 8e 88			call clear_display 
9c01			 
9c01 3e 00			ld a,0 
9c03 32 cf ec			ld (f_cursor_ptr), a 
9c06			 
9c06				; set start of word list in start of ram - for use when creating user words 
9c06			 
9c06 21 75 d7			ld hl, baseram 
9c09 22 e3 e7			ld (os_last_new_uword), hl 
9c0c cd b2 9b			call user_word_eol 
9c0f				 
9c0f			;		call display_data_sp 
9c0f			;		call next_page_prompt 
9c0f			 
9c0f			 
9c0f			 
9c0f			 
9c0f c9				ret 
9c10			 
9c10 .. 00		.bootforth: db " Forth Kernel Init ",0 
9c24			 
9c24			; TODO push to stack 
9c24			 
9c24			;  
9c24			 
9c24			if FORTH_PARSEV2 
9c24			 
9c24			 
9c24				include "forth_parserv2.asm" 
9c24			 
9c24			endif 
9c24			 
9c24			 
9c24			; parse cli version 1 
9c24			 
9c24			if FORTH_PARSEV1 
9c24			 
9c24			 
9c24			 
9c24			      include "forth_parserv1.asm" 
9c24			endif 
9c24				 
9c24			if FORTH_PARSEV3 
9c24			 
9c24			 
9c24			 
9c24			      include "forth_parserv3.asm" 
9c24				include "forth_wordsv3.asm" 
9c24			endif 
9c24			 
9c24			if FORTH_PARSEV4 
9c24			 
9c24			 
9c24			 
9c24			      include "forth_parserv4.asm" 
9c24				include "forth_wordsv4.asm" 
9c24			endif 
9c24			 
9c24			if FORTH_PARSEV5 
9c24			 
9c24			 
9c24			 
9c24			      include "forth_parserv5.asm" 
9c24			 
9c24			 
9c24			; A better parser without using malloc and string copies all over the place.  
9c24			; Exec in situ should be faster 
9c24			 
9c24			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9c24			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9c24			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9c24			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9c24			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9c24			WORD_SYS_END: equ 0   ; Opcode for all user words 
9c24			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9c24			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9c24			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9c24			 
9c24			; Core word preamble macro 
9c24			 
9c24			CWHEAD:   macro nxtword opcode lit len opflags 
9c24				db WORD_SYS_CORE+opcode             
9c24				; internal op code number 
9c24				dw nxtword            
9c24				; link to next dict word block 
9c24				db len + 1 
9c24				; literal length of dict word inc zero term 
9c24				db lit,0              
9c24				; literal dict word 
9c24			        ; TODO db opflags        
9c24				endm 
9c24			 
9c24			 
9c24			NEXTW: macro  
9c24				jp macro_next 
9c24				endm 
9c24			 
9c24			macro_next: 
9c24			if DEBUG_FORTH_PARSE_KEY 
9c24				DMARK "NXT" 
9c24				CALLMONITOR 
9c24			endif	 
9c24			;	inc hl  ; skip token null term  
9c24 ed 4b b1 ec		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9c28 ed 5b af ec		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9c2c 2a e7 e7			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9c2f			if DEBUG_FORTH_PARSE_KEY 
9c2f				DMARK "}AA" 
9c2f				CALLMONITOR 
9c2f			endif	 
9c2f c3 32 9d			jp execnext 
9c32				;jp exec1 
9c32			       
9c32			 
9c32			 
9c32			; Another go at the parser to compile  
9c32			 
9c32			 
9c32			; TODO rework parser to change all of the string words to byte tokens 
9c32			; TODO do a search for  
9c32			 
9c32			; TODO first run normal parser to zero term sections 
9c32			; TODO for each word do a token look up to get the op code 
9c32			; TODO need some means to flag to the exec that this is a byte code form    
9c32			 
9c32			 
9c32			forthcompile: 
9c32			 
9c32			; 
9c32			; line parse: 
9c32			;       parse raw input buffer 
9c32			;       tokenise the words 
9c32			;       malloc new copy (for looping etc) 
9c32			;       copy to malloc + current pc in line to start of string and add line term 
9c32			;       save on new rsp 
9c32			; 
9c32			 
9c32			; hl to point to the line to tokenise 
9c32			 
9c32			;	push hl 
9c32 22 e7 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9c35			 
9c35			;	ld a,0		; string term on input 
9c35			;	call strlent 
9c35			 
9c35			;	ld (os_tok_len), hl	 ; save string length 
9c35			 
9c35			;if DEBUG_FORTH_TOK 
9c35			;	ex de,hl		 
9c35			;endif 
9c35			 
9c35			;	pop hl 		; get back string pointer 
9c35			 
9c35			if DEBUG_FORTH_TOK 
9c35						DMARK "TOc" 
9c35				CALLMONITOR 
9c35			endif 
9c35 7e			.cptoken2:    ld a,(hl) 
9c36 23				inc hl 
9c37 fe 7f			cp FORTH_END_BUFFER 
9c39 28 29			jr z, .cptokendone2 
9c3b fe 00			cp 0 
9c3d 28 25			jr z, .cptokendone2 
9c3f fe 22			cp '"' 
9c41 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9c43 fe 20			cp ' ' 
9c45 20 ee			jr nz,  .cptoken2 
9c47			 
9c47			; TODO consume comments held between ( and ) 
9c47			 
9c47				; we have a space so change to zero term for dict match later 
9c47 2b				dec hl 
9c48 3e 00			ld a,0 
9c4a 77				ld (hl), a 
9c4b 23				inc hl 
9c4c 18 e7			jr .cptoken2 
9c4e				 
9c4e			 
9c4e			.cptokenstr2: 
9c4e				; skip all white space until either eol (because forgot to term) or end double quote 
9c4e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c4e				;inc hl ; skip current double quote 
9c4e 7e				ld a,(hl) 
9c4f 23				inc hl 
9c50 fe 22			cp '"' 
9c52 28 e1			jr z, .cptoken2 
9c54 fe 7f			cp FORTH_END_BUFFER 
9c56 28 0c			jr z, .cptokendone2 
9c58 fe 00			cp 0 
9c5a 28 08			jr z, .cptokendone2 
9c5c fe 20			cp ' ' 
9c5e 28 02			jr z, .cptmp2 
9c60 18 ec			jr .cptokenstr2 
9c62			 
9c62			.cptmp2:	; we have a space so change to zero term for dict match later 
9c62				;dec hl 
9c62				;ld a,"-"	; TODO remove this when working 
9c62				;ld (hl), a 
9c62				;inc hl 
9c62 18 ea			jr .cptokenstr2 
9c64			 
9c64			.cptokendone2: 
9c64				;inc hl 
9c64 3e 7f			ld a, FORTH_END_BUFFER 
9c66 77				ld (hl),a 
9c67 23				inc hl 
9c68 3e 21			ld a, '!' 
9c6a 77				ld (hl),a 
9c6b			 
9c6b 2a e7 e7			ld hl,(os_tok_ptr) 
9c6e			         
9c6e			if DEBUG_FORTH_TOK 
9c6e						DMARK "Tc1" 
9c6e				CALLMONITOR 
9c6e			endif 
9c6e			 
9c6e				; push exec string to top of return stack 
9c6e				FORTH_RSP_NEXT 
9c6e cd 62 98			call macro_forth_rsp_next 
9c71				endm 
# End of macro FORTH_RSP_NEXT
9c71 c9				ret 
9c72			 
9c72			; Another go at the parser need to simplify the process 
9c72			 
9c72			forthparse: 
9c72			 
9c72			; 
9c72			; line parse: 
9c72			;       parse raw input buffer 
9c72			;       tokenise the words 
9c72			;       malloc new copy (for looping etc) 
9c72			;       copy to malloc + current pc in line to start of string and add line term 
9c72			;       save on new rsp 
9c72			; 
9c72			 
9c72			; hl to point to the line to tokenise 
9c72			 
9c72			;	push hl 
9c72 22 e7 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9c75			 
9c75			;	ld a,0		; string term on input 
9c75			;	call strlent 
9c75			 
9c75			;	ld (os_tok_len), hl	 ; save string length 
9c75			 
9c75			;if DEBUG_FORTH_TOK 
9c75			;	ex de,hl		 
9c75			;endif 
9c75			 
9c75			;	pop hl 		; get back string pointer 
9c75			 
9c75			if DEBUG_FORTH_TOK 
9c75						DMARK "TOK" 
9c75				CALLMONITOR 
9c75			endif 
9c75 7e			.ptoken2:    ld a,(hl) 
9c76 23				inc hl 
9c77 fe 7f			cp FORTH_END_BUFFER 
9c79 28 29			jr z, .ptokendone2 
9c7b fe 00			cp 0 
9c7d 28 25			jr z, .ptokendone2 
9c7f fe 22			cp '"' 
9c81 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9c83 fe 20			cp ' ' 
9c85 20 ee			jr nz,  .ptoken2 
9c87			 
9c87			; TODO consume comments held between ( and ) 
9c87			 
9c87				; we have a space so change to zero term for dict match later 
9c87 2b				dec hl 
9c88 3e 00			ld a,0 
9c8a 77				ld (hl), a 
9c8b 23				inc hl 
9c8c 18 e7			jr .ptoken2 
9c8e				 
9c8e			 
9c8e			.ptokenstr2: 
9c8e				; skip all white space until either eol (because forgot to term) or end double quote 
9c8e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c8e				;inc hl ; skip current double quote 
9c8e 7e				ld a,(hl) 
9c8f 23				inc hl 
9c90 fe 22			cp '"' 
9c92 28 e1			jr z, .ptoken2 
9c94 fe 7f			cp FORTH_END_BUFFER 
9c96 28 0c			jr z, .ptokendone2 
9c98 fe 00			cp 0 
9c9a 28 08			jr z, .ptokendone2 
9c9c fe 20			cp ' ' 
9c9e 28 02			jr z, .ptmp2 
9ca0 18 ec			jr .ptokenstr2 
9ca2			 
9ca2			.ptmp2:	; we have a space so change to zero term for dict match later 
9ca2				;dec hl 
9ca2				;ld a,"-"	; TODO remove this when working 
9ca2				;ld (hl), a 
9ca2				;inc hl 
9ca2 18 ea			jr .ptokenstr2 
9ca4			 
9ca4			.ptokendone2: 
9ca4				;inc hl 
9ca4 3e 7f			ld a, FORTH_END_BUFFER 
9ca6 77				ld (hl),a 
9ca7 23				inc hl 
9ca8 3e 21			ld a, '!' 
9caa 77				ld (hl),a 
9cab			 
9cab 2a e7 e7			ld hl,(os_tok_ptr) 
9cae			         
9cae			if DEBUG_FORTH_TOK 
9cae						DMARK "TK1" 
9cae				CALLMONITOR 
9cae			endif 
9cae			 
9cae				; push exec string to top of return stack 
9cae				FORTH_RSP_NEXT 
9cae cd 62 98			call macro_forth_rsp_next 
9cb1				endm 
# End of macro FORTH_RSP_NEXT
9cb1 c9				ret 
9cb2			 
9cb2			; 
9cb2			;	; malloc size + buffer pointer + if is loop flag 
9cb2			;	ld hl,(os_tok_len) 		 ; get string length 
9cb2			; 
9cb2			;	ld a,l 
9cb2			; 
9cb2			;	cp 0			; we dont want to use a null string 
9cb2			;	ret z 
9cb2			; 
9cb2			;;	add 3    ; prefix malloc with buffer for current word ptr 
9cb2			; 
9cb2			;	add 5     ; TODO when certain not over writing memory remove 
9cb2			; 
9cb2			;		 
9cb2			; 
9cb2			;if DEBUG_FORTH_TOK 
9cb2			;			DMARK "TKE" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			; 
9cb2			;	ld l,a 
9cb2			;	ld h,0 
9cb2			;;	push hl   ; save required space for the copy later 
9cb2			;	call malloc 
9cb2			;if DEBUG_FORTH_TOK 
9cb2			;			DMARK "TKM" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			;	if DEBUG_FORTH_MALLOC_GUARD 
9cb2			;		push af 
9cb2			;		call ishlzero 
9cb2			;;		ld a, l 
9cb2			;;		add h 
9cb2			;;		cp 0 
9cb2			;		pop af 
9cb2			;		 
9cb2			;		call z,malloc_error 
9cb2			;	endif 
9cb2			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9cb2			; 
9cb2			; 
9cb2			;if DEBUG_FORTH_TOK 
9cb2			;			DMARK "TKR" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			; 
9cb2			;	FORTH_RSP_NEXT 
9cb2			; 
9cb2			;	;inc hl	 ; go past current buffer pointer 
9cb2			;	;inc hl 
9cb2			;	;inc hl   ; and past if loop flag 
9cb2			;		; TODO Need to set flag  
9cb2			; 
9cb2			;	 
9cb2			;	 
9cb2			;	ex de,hl	; malloc is dest 
9cb2			;	ld hl, (os_tok_len) 
9cb2			;;	pop bc 
9cb2			;	ld c, l                
9cb2			;	ld b,0 
9cb2			;	ld hl, (os_tok_ptr) 
9cb2			; 
9cb2			;if DEBUG_FORTH_TOK 
9cb2			;			DMARK "TKT" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			; 
9cb2			;	; do str cpy 
9cb2			; 
9cb2			;	ldir      ; copy byte in hl to de 
9cb2			; 
9cb2			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9cb2			; 
9cb2			;if DEBUG_FORTH_TOK 
9cb2			; 
9cb2			;			DMARK "TKY" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			;	;ld a,0 
9cb2			;	;ld a,FORTH_END_BUFFER 
9cb2			;	ex de, hl 
9cb2			;	;dec hl			 ; go back over the space delim at the end of word 
9cb2			;	;ld (hl),a 
9cb2			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9cb2			;	ld a,FORTH_END_BUFFER 
9cb2			;	ld (hl),a 
9cb2			;	inc hl 
9cb2			;	ld a,FORTH_END_BUFFER 
9cb2			;	ld (hl),a 
9cb2			; 
9cb2			;	; init the malloc area data 
9cb2			;	; set pc for in current area 
9cb2			;	;ld hl, (os_tok_malloc) 
9cb2			;	;inc hl 
9cb2			;	;inc hl 
9cb2			;	;inc hl 
9cb2			;	;ex de,hl 
9cb2			;	;ld hl, (os_tok_malloc) 
9cb2			;	;ld (hl),e 
9cb2			;	;inc hl 
9cb2			;	;ld (hl),d 
9cb2			; 
9cb2			; 
9cb2			;	ld hl,(os_tok_malloc) 
9cb2			;if DEBUG_FORTH_PARSE_KEY 
9cb2			;			DMARK "TKU" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			; 
9cb2			;	ret 
9cb2			 
9cb2			forthexec: 
9cb2			 
9cb2			; line exec: 
9cb2			; forth parser 
9cb2			 
9cb2			; 
9cb2			;       get current exec line on rsp 
9cb2			 
9cb2				FORTH_RSP_TOS 
9cb2 cd 79 98			call macro_forth_rsp_tos 
9cb5				endm 
# End of macro FORTH_RSP_TOS
9cb5			 
9cb5			;       restore current pc - hl points to malloc of data 
9cb5			 
9cb5				;ld e, (hl) 
9cb5				;inc hl 
9cb5				;ld d, (hl) 
9cb5				;ex de,hl 
9cb5			 
9cb5			 
9cb5			exec1: 
9cb5 22 e7 e7			ld (os_tok_ptr), hl 
9cb8			 
9cb8				; copy our PC to working vars  
9cb8 22 b1 ec			ld (cli_ptr), hl 
9cbb 22 af ec			ld (cli_origptr), hl 
9cbe			 
9cbe 7e				ld a,(hl) 
9cbf fe 7f			cp FORTH_END_BUFFER 
9cc1 c8				ret z 
9cc2			 
9cc2				; skip any nulls 
9cc2			 
9cc2 fe 00			cp 0 
9cc4 20 03			jr nz, .execword 
9cc6 23				inc hl 
9cc7 18 ec			jr exec1 
9cc9			 
9cc9			 
9cc9			.execword: 
9cc9			 
9cc9			 
9cc9			 
9cc9			if DEBUG_FORTH_PARSE_KEY 
9cc9						DMARK "KYQ" 
9cc9				CALLMONITOR 
9cc9			endif 
9cc9			;       while at start of word: 
9cc9			; get start of dict (in user area first) 
9cc9			 
9cc9 21 75 d7		ld hl, baseram 
9ccc			;ld hl, sysdict 
9ccc 22 b3 ec		ld (cli_nextword),hl 
9ccf			;           match word at pc 
9ccf			;           exec word 
9ccf			;           or push to dsp 
9ccf			;           forward to next token 
9ccf			;           if line term pop rsp and exit 
9ccf			;        
9ccf			 
9ccf			if DEBUG_FORTH_PARSE_KEY 
9ccf						DMARK "KYq" 
9ccf				CALLMONITOR 
9ccf			endif 
9ccf			 
9ccf			; 
9ccf			; word comp 
9ccf			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9ccf			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9ccf			;    move to start of word  
9ccf			;    compare word to cli_token 
9ccf			 
9ccf			.execpnword:	; HL at start of a word in the dictionary to check 
9ccf			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9ccf			;	ld (cli_ptr), hl 
9ccf			 
9ccf 2a b3 ec			ld hl,(cli_nextword) 
9cd2			 
9cd2 cd 75 9d			call forth_tok_next 
9cd5			; tok next start here 
9cd5			;	; TODO skip compiled symbol for now 
9cd5			;	inc hl 
9cd5			; 
9cd5			;	; save pointer to next word 
9cd5			; 
9cd5			;	; hl now points to the address of the next word pointer  
9cd5			;	ld e, (hl) 
9cd5			;	inc hl 
9cd5			;	ld d, (hl) 
9cd5			;	inc l 
9cd5			; 
9cd5			;	ex de,hl 
9cd5			;if DEBUG_FORTH_PARSE_NEXTWORD 
9cd5			;	push bc 
9cd5			;	ld bc, (cli_nextword) 
9cd5			;			DMARK "NXW" 
9cd5			;	CALLMONITOR 
9cd5			;	pop bc 
9cd5			;endif 
9cd5			; tok next end here 
9cd5 22 b3 ec			ld (cli_nextword), hl     ; save for next check if no match on this word 
9cd8 eb				ex de, hl 
9cd9			 
9cd9			 
9cd9				; save the pointer of the current token - 1 to check against 
9cd9				 
9cd9 22 b7 ec			ld (cli_token), hl   
9cdc				; TODO maybe remove below save if no debug 
9cdc				; save token string ptr for any debug later 
9cdc 23				inc hl  
9cdd 22 b9 ec			ld (cli_origtoken), hl 
9ce0 2b				dec hl 
9ce1				; save pointer to the start of the next dictionay word 
9ce1 7e				ld a,(hl)   ; get string length 
9ce2 47				ld b,a 
9ce3			.execpnwordinc:  
9ce3 23				inc hl 
9ce4 10 fd			djnz .execpnwordinc 
9ce6 22 b5 ec			ld (cli_execword), hl      ; save start of this words code 
9ce9			 
9ce9				; now check the word token against the string being parsed 
9ce9			 
9ce9 2a b7 ec			ld hl,(cli_token) 
9cec 23				inc hl     ; skip string length (use zero term instead to end) 
9ced 22 b7 ec			ld (cli_token), hl 
9cf0			 
9cf0			if DEBUG_FORTH_PARSE_KEY 
9cf0						DMARK "KY2" 
9cf0			endif 
9cf0			if DEBUG_FORTH_PARSE_EXEC 
9cf0				; see if disabled 
9cf0			 
9cf0				ld a, (os_view_disable) 
9cf0				cp '*' 
9cf0				jr z, .skip 
9cf0			 
9cf0				push hl 
9cf0				push hl 
9cf0				call clear_display 
9cf0				ld de, .compword 
9cf0				ld a, display_row_1 
9cf0				call str_at_display 
9cf0				pop de 
9cf0				ld a, display_row_2 
9cf0				call str_at_display 
9cf0				ld hl,(cli_ptr) 
9cf0				ld a,(hl) 
9cf0			        ld hl, os_word_scratch 
9cf0				ld (hl),a 
9cf0				ld a,0 
9cf0				inc hl 
9cf0				ld (hl),a 	 
9cf0				ld de, os_word_scratch 
9cf0				ld a, display_row_2+10 
9cf0				call str_at_display 
9cf0				call update_display 
9cf0				ld a, 100 
9cf0				call aDelayInMS 
9cf0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9cf0				call delay250ms 
9cf0				endif 
9cf0				pop hl 
9cf0			.skip:  
9cf0			endif	 
9cf0			.execpnchar:    ; compare char between token and string to parse 
9cf0			 
9cf0			if DEBUG_FORTH_PARSE_KEY 
9cf0						DMARK "Ky3" 
9cf0			endif 
9cf0			if DEBUG_FORTH_PARSE_EXEC 
9cf0				; see if disabled 
9cf0			 
9cf0				ld a, (os_view_disable) 
9cf0				cp '*' 
9cf0				jr z, .skip2 
9cf0			 
9cf0			;	call clear_display 
9cf0			ld hl,(cli_token) 
9cf0			ld a,(hl) 
9cf0			ld (os_word_scratch),a 
9cf0				ld hl,(cli_ptr) 
9cf0			ld a,(hl) 
9cf0				ld (os_word_scratch+1),a 
9cf0				ld a,0 
9cf0				ld (os_word_scratch+2),a 
9cf0				ld de,os_word_scratch 
9cf0				ld a,display_row_4 
9cf0				call str_at_display 
9cf0				call update_display 
9cf0			.skip2:  
9cf0			endif 
9cf0 2a b7 ec			ld hl,(cli_token) 
9cf3 7e				ld a, (hl)	 ; char in word token 
9cf4 23				inc hl 		; move to next char 
9cf5 22 b7 ec			ld (cli_token), hl ; and save it 
9cf8 47				ld b,a 
9cf9			 
9cf9 2a b1 ec			ld hl,(cli_ptr) ;	get the char from the string to parse 
9cfc 7e				ld a,(hl) 
9cfd 23				inc hl 
9cfe 22 b1 ec			ld (cli_ptr), hl		; move to next char 
9d01 cd 10 8f			call toUpper 		; make sure the input string matches case 
9d04			 
9d04			if DEBUG_FORTH_PARSE 
9d04			endif 
9d04			 
9d04				; input stream end of token is a space so get rid of it 
9d04			 
9d04			;	cp ' ' 
9d04			;	jr nz, .pnskipspace 
9d04			; 
9d04			;	ld a, 0		; make same term as word token term 
9d04			; 
9d04			;.pnskipspace: 
9d04			 
9d04			if DEBUG_FORTH_PARSE_KEY 
9d04						DMARK "KY7" 
9d04			endif 
9d04 b8				cp b 
9d05 c2 1b 9d			jp nz, .execpnskipword	 ; no match so move to next word 
9d08				 
9d08			;    if same 
9d08			;       scan for string terms 0 for token and 32 for input 
9d08			 
9d08				 
9d08			if DEBUG_FORTH_PARSE_KEY 
9d08						DMARK "KY8" 
9d08			endif 
9d08			 
9d08 80				add b			 
9d09 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9d0b							; TODO need to make sure last word in zero term string is accounted for 
9d0b 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9d0d			 
9d0d			 
9d0d				; at end of both strings so both are exact match 
9d0d			 
9d0d			;       skip ptr for next word 
9d0d			 
9d0d 2a b1 ec			ld hl,(cli_ptr) 	; at input string term 
9d10 23				inc hl			 ; at next char 
9d11 22 b1 ec			ld (cli_ptr), hl     ; save for next round of the parser 
9d14 22 af ec			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9d17				 
9d17				 
9d17			if DEBUG_FORTH_PARSE_KEY 
9d17						DMARK "KY3" 
9d17			endif 
9d17			 
9d17			 
9d17			 
9d17			;       exec code block 
9d17			if DEBUG_FORTH_JP 
9d17				call clear_display 
9d17				call update_display 
9d17				call delay1s 
9d17				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d17				ld a,h 
9d17				ld hl, os_word_scratch 
9d17				call hexout 
9d17				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d17				ld a,l 
9d17				ld hl, os_word_scratch+2 
9d17				call hexout 
9d17				ld hl, os_word_scratch+4 
9d17				ld a,0 
9d17				ld (hl),a 
9d17				ld de,os_word_scratch 
9d17				call str_at_display 
9d17					ld a, display_row_2 
9d17					call str_at_display 
9d17				ld de, (cli_origtoken) 
9d17				ld a, display_row_1+10 
9d17					call str_at_display 
9d17			 
9d17				ld a,display_row_1 
9d17				ld de, .foundword 
9d17				ld a, display_row_3 
9d17				call str_at_display 
9d17				call update_display 
9d17				call delay1s 
9d17				call delay1s 
9d17				call delay1s 
9d17			endif 
9d17			 
9d17			if DEBUG_FORTH_PARSE_KEY 
9d17						DMARK "KYj" 
9d17			endif 
9d17				; TODO save the word pointer in this exec 
9d17			 
9d17 2a b5 ec			ld hl,(cli_execword) 
9d1a e9				jp (hl) 
9d1b			 
9d1b			 
9d1b			;    if not same 
9d1b			;	scan for zero term 
9d1b			;	get ptr for next word 
9d1b			;	goto word comp 
9d1b			 
9d1b			.execpnskipword:	; get pointer to next word 
9d1b 2a b3 ec			ld hl,(cli_nextword) 
9d1e			 
9d1e 7e				ld a,(hl) 
9d1f fe 00			cp WORD_SYS_END 
9d21			;	cp 0 
9d21 28 09			jr z, .execendofdict			 ; at end of words 
9d23			 
9d23			if DEBUG_FORTH_PARSE_KEY 
9d23						DMARK "KY4" 
9d23			endif 
9d23			if DEBUG_FORTH_PARSE_EXEC 
9d23			 
9d23				; see if disabled 
9d23			 
9d23				ld a, (os_view_disable) 
9d23				cp '*' 
9d23				jr z, .noskip 
9d23			 
9d23			 
9d23				ld de, .nowordfound 
9d23				ld a, display_row_3 
9d23				call str_at_display 
9d23				call update_display 
9d23				ld a, 100 
9d23				call aDelayInMS 
9d23				 
9d23				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d23					call delay250ms 
9d23				endif 
9d23			.noskip:  
9d23			 
9d23			endif	 
9d23			 
9d23 2a af ec			ld hl,(cli_origptr) 
9d26 22 b1 ec			ld (cli_ptr),hl 
9d29			 
9d29			if DEBUG_FORTH_PARSE_KEY 
9d29						DMARK "KY5" 
9d29			endif 
9d29 c3 cf 9c			jp .execpnword			; else go to next word 
9d2c			 
9d2c			.execendofdict:  
9d2c			 
9d2c			if DEBUG_FORTH_PARSE_KEY 
9d2c						DMARK "KYe" 
9d2c			endif 
9d2c			if DEBUG_FORTH_PARSE_EXEC 
9d2c				; see if disabled 
9d2c			 
9d2c				ld a, (os_view_disable) 
9d2c				cp '*' 
9d2c				jr z, .ispskip 
9d2c			 
9d2c				call clear_display 
9d2c				call update_display 
9d2c				call delay1s 
9d2c				ld de, (cli_origptr) 
9d2c				ld a, display_row_1 
9d2c				call str_at_display 
9d2c				 
9d2c				ld de, .enddict 
9d2c				ld a, display_row_3 
9d2c				call str_at_display 
9d2c				call update_display 
9d2c				ld a, 100 
9d2c				call aDelayInMS 
9d2c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d2c				call delay1s 
9d2c				call delay1s 
9d2c				call delay1s 
9d2c				endif 
9d2c			.ispskip:  
9d2c				 
9d2c			endif	 
9d2c			 
9d2c			 
9d2c			 
9d2c				; if the word is not a keyword then must be a literal so push it to stack 
9d2c			 
9d2c			; push token to stack to end of word 
9d2c			 
9d2c				STACKFRAME ON $1efe $2f9f 
9d2c				if DEBUG_STACK_IMB 
9d2c					if ON 
9d2c						exx 
9d2c						ld de, $1efe 
9d2c						ld a, d 
9d2c						ld hl, curframe 
9d2c						call hexout 
9d2c						ld a, e 
9d2c						ld hl, curframe+2 
9d2c						call hexout 
9d2c						ld hl, $1efe 
9d2c						push hl 
9d2c						ld hl, $2f9f 
9d2c						push hl 
9d2c						exx 
9d2c					endif 
9d2c				endif 
9d2c			endm 
# End of macro STACKFRAME
9d2c			 
9d2c 2a e7 e7		ld hl,(os_tok_ptr) 
9d2f cd 24 9a		call forth_apush 
9d32			 
9d32				STACKFRAMECHK ON $1efe $2f9f 
9d32				if DEBUG_STACK_IMB 
9d32					if ON 
9d32						exx 
9d32						ld hl, $2f9f 
9d32						pop de   ; $2f9f 
9d32						call cmp16 
9d32						jr nz, .spnosame 
9d32						ld hl, $1efe 
9d32						pop de   ; $1efe 
9d32						call cmp16 
9d32						jr z, .spfrsame 
9d32						.spnosame: call showsperror 
9d32						.spfrsame: nop 
9d32						exx 
9d32					endif 
9d32				endif 
9d32			endm 
# End of macro STACKFRAMECHK
9d32			 
9d32			execnext: 
9d32			 
9d32			if DEBUG_FORTH_PARSE_KEY 
9d32						DMARK "KY>" 
9d32			endif 
9d32			; move past token to next word 
9d32			 
9d32 2a e7 e7		ld hl, (os_tok_ptr) 
9d35 3e 00		ld a, 0 
9d37 01 ff 00		ld bc, 255     ; input buffer size 
9d3a ed b1		cpir 
9d3c			 
9d3c			if DEBUG_FORTH_PARSE_KEY 
9d3c						DMARK "KY!" 
9d3c				CALLMONITOR 
9d3c			endif	 
9d3c			; TODO this might place hl on the null, so will need to forward on??? 
9d3c			;inc hl   ; see if this gets onto the next item 
9d3c			 
9d3c			 
9d3c			; TODO pass a pointer to the buffer to push 
9d3c			; TODO call function to push 
9d3c			 
9d3c			; look for end of input 
9d3c			 
9d3c			;inc hl 
9d3c			;ld a,(hl) 
9d3c			;cp FORTH_END_BUFFER 
9d3c			;ret z 
9d3c			 
9d3c			 
9d3c c3 b5 9c		jp exec1 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			findnexttok: 
9d3f			 
9d3f				; hl is pointer to move 
9d3f				; de is the token to locate 
9d3f			 
9d3f					if DEBUG_FORTH 
9d3f						DMARK "NTK" 
9d3f						CALLMONITOR 
9d3f					endif 
9d3f d5				push de 
9d40			 
9d40			.fnt1:	 
9d40				; find first char of token to locate 
9d40			 
9d40 1a				ld a, (de) 
9d41 4f				ld c,a 
9d42 7e				ld a,(hl) 
9d43 cd 10 8f			call toUpper 
9d46					if DEBUG_FORTH 
9d46						DMARK "NT1" 
9d46						CALLMONITOR 
9d46					endif 
9d46 b9				cp c 
9d47			 
9d47 28 03			jr z, .fnt2cmpmorefirst	 
9d49			 
9d49				; first char not found move to next char 
9d49			 
9d49 23				inc hl 
9d4a 18 f4			jr .fnt1 
9d4c			 
9d4c			.fnt2cmpmorefirst:	 
9d4c				; first char of token found.  
9d4c			 
9d4c e5				push hl     ; save start of token just in case it is the right one 
9d4d d9				exx 
9d4e e1				pop hl        ; save it to hl' 
9d4f d9				exx 
9d50			 
9d50			 
9d50			.fnt2cmpmore:	 
9d50				; compare the rest 
9d50				 
9d50 23				inc hl 
9d51 13				inc de 
9d52				 
9d52 1a				ld a, (de) 
9d53 4f				ld c,a 
9d54 7e				ld a,(hl) 
9d55 cd 10 8f			call toUpper 
9d58			 
9d58					if DEBUG_FORTH 
9d58						DMARK "NT2" 
9d58						CALLMONITOR 
9d58					endif 
9d58				; c has the token to find char 
9d58				; a has the mem to scan char 
9d58			 
9d58 b9				cp c 
9d59 28 04			jr z,.fntmatch1 
9d5b			 
9d5b				; they are not the same 
9d5b			 
9d5b					if DEBUG_FORTH 
9d5b						DMARK "NT3" 
9d5b						CALLMONITOR 
9d5b					endif 
9d5b d1				pop de	; reset de token to look for 
9d5c d5				push de 
9d5d 18 e1			jr .fnt1 
9d5f				 
9d5f			.fntmatch1: 
9d5f			 
9d5f				; is the same char a null which means we might have a full hit? 
9d5f					if DEBUG_FORTH 
9d5f						DMARK "NT4" 
9d5f						CALLMONITOR 
9d5f					endif 
9d5f			 
9d5f fe 00			cp 0 
9d61 28 0b			jr z, .fntmatchyes 
9d63			 
9d63				; are we at the end of the token to find? 
9d63			 
9d63					if DEBUG_FORTH 
9d63						DMARK "NT5" 
9d63						CALLMONITOR 
9d63					endif 
9d63 3e 00			ld a, 0 
9d65 b9				cp c 
9d66			 
9d66 c2 50 9d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9d69			 
9d69					if DEBUG_FORTH 
9d69						DMARK "NT6" 
9d69						CALLMONITOR 
9d69					endif 
9d69				; token to find is exhusted but no match to stream 
9d69			 
9d69				; restore tok pointer and continue on 
9d69 d1				pop de 
9d6a d5				push de 
9d6b c3 40 9d			jp .fnt1 
9d6e			 
9d6e			 
9d6e			.fntmatchyes: 
9d6e			 
9d6e				; hl now contains the end of the found token 
9d6e			 
9d6e				; get rid of saved token pointer to find 
9d6e			 
9d6e d1				pop de 
9d6f			 
9d6f					if DEBUG_FORTH 
9d6f						DMARK "NT9" 
9d6f						CALLMONITOR 
9d6f					endif 
9d6f			 
9d6f				; hl will be on the null term so forward on 
9d6f			 
9d6f				; get back the saved start of the token 
9d6f			 
9d6f d9				exx 
9d70 e5				push hl     ; save start of token just in case it is the right one 
9d71 d9				exx 
9d72 e1				pop hl        ; save it to hl 
9d73			 
9d73 c9				ret 
9d74			 
9d74			 
9d74			; LIST needs to find a specific token   
9d74			; FORGET needs to find a spefici token 
9d74			 
9d74			; SAVE needs to find all tokens by flag 
9d74			; WORDS just needs to scan through all  by flag 
9d74			; UWORDS needs to scan through all by flag 
9d74			 
9d74			 
9d74			; given hl as pointer to start of dict look up string 
9d74			; return hl as pointer to start of word block 
9d74			; or 0 if not found 
9d74			 
9d74			forth_find_tok: 
9d74 c9				ret 
9d75			 
9d75			; given hl as pointer to dict structure 
9d75			; move to the next dict block structure 
9d75			 
9d75			forth_tok_next: 
9d75				; hl now points to the address of the next word pointer  
9d75				; TODO skip compiled symbol for now 
9d75			;	push de 
9d75 23				inc hl 
9d76 5e				ld e, (hl) 
9d77 23				inc hl 
9d78 56				ld d, (hl) 
9d79 23				inc hl 
9d7a			 
9d7a eb				ex de,hl 
9d7b			if DEBUG_FORTH_PARSE_NEXTWORD 
9d7b				push bc 
9d7b				ld bc, (cli_nextword) 
9d7b						DMARK "NXW" 
9d7b				CALLMONITOR 
9d7b				pop bc 
9d7b			endif 
9d7b			;	pop de	 
9d7b c9				ret 
9d7c			 
9d7c			 
9d7c			 
9d7c			; eof 
# End of file forth_parserv5.asm
9d7c				include "forth_wordsv4.asm" 
9d7c			 
9d7c			; the core word dictionary v4 
9d7c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9d7c			 
9d7c			; this is a linked list for each of the system words used 
9d7c			; user defined words will follow the same format but will be in ram 
9d7c			 
9d7c			 
9d7c			; 
9d7c			; 
9d7c			; define linked list: 
9d7c			; 
9d7c			; 1. compiled byte op code 
9d7c			; 2. len of text word 
9d7c			; 3. text word 
9d7c			; 4. ptr to next dictionary word 
9d7c			; 5. asm, calls etc for the word 
9d7c			; 
9d7c			;  if 1 == 0 then last word in dict  
9d7c			;   
9d7c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9d7c			;  
9d7c			;  
9d7c			; create basic standard set of words 
9d7c			; 
9d7c			;  
9d7c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9d7c			; 2DUP 2DROP 2SWAP  
9d7c			; @ C@ - get byte  
9d7c			; ! C! - store byte 
9d7c			; 0< true if less than zero 
9d7c			; 0= true if zero 
9d7c			; < >  
9d7c			; = true if same 
9d7c			; variables 
9d7c			 
9d7c			 
9d7c			; Hardware specific words I may need 
9d7c			; 
9d7c			; IN OUT  
9d7c			; calls to key util functions 
9d7c			; calls to hardward abstraction stuff 
9d7c			; easy control of frame buffers and lcd i/o 
9d7c			; keyboard  
9d7c			 
9d7c			 
9d7c			;DICT: macro 
9d7c			; op_code, len, word, next 
9d7c			;    word: 
9d7c			;    db op_code 
9d7c			;    ds word zero term 
9d7c			;    dw next 
9d7c			;    endm 
9d7c			 
9d7c			 
9d7c			 
9d7c			 
9d7c			; op code 1 is a flag for user define words which are to be handled differently 
9d7c			 
9d7c			 
9d7c			; 
9d7c			; 
9d7c			;    TODO on entry to a word this should be the expected environment 
9d7c			;    hl - tos value if number then held, if string this is the ptr 
9d7c			;    de -  
9d7c			 
9d7c			 
9d7c			; opcode ranges 
9d7c			; 0 - end of word dict 
9d7c			; 255 - user define words 
9d7c			 
9d7c			sysdict: 
9d7c			include "forth_opcodes.asm" 
9d7c			; op codes for forth keywords 
9d7c			; free to use code 0  
9d7c				OPCODE_HEAP: equ  1 
9d7c				OPCODE_EXEC: equ 2 
9d7c				OPCODE_DUP: equ 3 
9d7c				OPCODE_SWAP: equ 4 
9d7c				OPCODE_COLN: equ 5 
9d7c				OPCODE_SCOLN: equ 6 
9d7c				OPCODE_DROP: equ 7 
9d7c				OPCODE_DUP2: equ 8 
9d7c				OPCODE_DROP2: equ 9 
9d7c				OPCODE_SWAP2: equ 10 
9d7c				OPCODE_AT: equ 11 
9d7c				OPCODE_CAT: equ 12 
9d7c				OPCODE_BANG: equ 13 
9d7c				OPCODE_CBANG: equ 14 
9d7c				OPCODE_SCALL: equ 15 
9d7c				OPCODE_DEPTH: equ 16 
9d7c				OPCODE_OVER: equ 17 
9d7c				OPCODE_PAUSE: equ 18 
9d7c				OPCODE_PAUSES: equ 19 
9d7c				OPCODE_ROT: equ 20 
9d7c			;free to reuse	OPCODE_WORDS: equ 21 
9d7c			        OPCODE_NOT: equ 21 
9d7c				OPCODE_UWORDS: equ 22 
9d7c				OPCODE_BP: equ 23 
9d7c				OPCODE_MONITOR: equ 24  
9d7c				OPCODE_MALLOC: equ 25 
9d7c				OPCODE_FREE: equ 26 
9d7c				OPCODE_LIST: equ 27 
9d7c				OPCODE_FORGET: equ 28 
9d7c				OPCODE_NOP: equ 29 
9d7c				OPCODE_COMO: equ 30 
9d7c				OPCODE_COMC: equ 31 
9d7c			;free to reuse	OPCODE_ENDCORE: equ 32 
9d7c				OPCODE_AFTERSOUND: equ 33 
9d7c				OPCODE_GP2: equ 34 
9d7c				OPCODE_GP3: equ 35 
9d7c				OPCODE_GP4: equ 36 
9d7c				OPCODE_SIN: equ 37 
9d7c				OPCODE_SOUT: equ 38 
9d7c				OPCODE_SPIO: equ 39 
9d7c				OPCODE_SPICEH: equ 40 
9d7c				OPCODE_SPIOb: equ 41 
9d7c				OPCODE_SPII: equ 42 
9d7c				OPCODE_SESEL: equ 43 
9d7c				OPCODE_CARTDEV: equ 44 
9d7c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9d7c				OPCODE_FB: equ 46 
9d7c				OPCODE_EMIT: equ 47 
9d7c				OPCODE_DOTH: equ 48 
9d7c				OPCODE_DOTF: equ 49 
9d7c				OPCODE_DOT: equ 50 
9d7c				OPCODE_CLS: equ 51 
9d7c				OPCODE_DRAW: equ 52 
9d7c				OPCODE_DUMP: equ 53 
9d7c				OPCODE_CDUMP: equ 54 
9d7c				OPCODE_DAT: equ 55 
9d7c				OPCODE_HOME: equ 56 
9d7c				OPCODE_SPACE: equ 57 
9d7c				OPCODE_SPACES: equ 58 
9d7c				OPCODE_SCROLL: equ 59 
9d7c				OPCODE_ATQ: equ 60 
9d7c				OPCODE_AUTODSP: equ 61 
9d7c				OPCODE_MENU: equ 62 
9d7c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9d7c				OPCODE_THEN: equ 64 
9d7c				OPCODE_ELSE: equ 65 
9d7c				OPCODE_DO: equ 66 
9d7c				OPCODE_LOOP: equ 67 
9d7c				OPCODE_I: equ 68 
9d7c				OPCODE_DLOOP: equ 69  
9d7c				OPCODE_REPEAT: equ 70  
9d7c				OPCODE_UNTIL: equ 71 
9d7c				OPCODE_ENDFLOW: equ 72 
9d7c				OPCODE_WAITK: equ 73 
9d7c				OPCODE_ACCEPT: equ 74 
9d7c				OPCODE_EDIT: equ 75 
9d7c			;free to reuse	OPCODE_ENDKEY: equ 76 
9d7c				OPCODE_LZERO: equ 77 
9d7c				OPCODE_TZERO: equ 78 
9d7c				OPCODE_LESS: equ 79 
9d7c				OPCODE_GT: equ 80 
9d7c				OPCODE_EQUAL: equ 81  
9d7c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9d7c				OPCODE_NEG: equ 83 
9d7c				OPCODE_DIV: equ 84 
9d7c				OPCODE_MUL: equ 85 
9d7c				OPCODE_MIN: equ 86 
9d7c				OPCODE_MAX: equ 87 
9d7c				OPCODE_RND16: equ 88 
9d7c				OPCODE_RND8: equ 89 
9d7c				OPCODE_RND: equ 90 
9d7c			;free to reuse	OPCODE_ENDMATHS: equ 91  
9d7c				OPCODE_BYNAME: equ 92 
9d7c				OPCODE_DIR: equ 93 
9d7c				OPCODE_SAVE: equ 94 
9d7c				OPCODE_LOAD: equ 95 
9d7c				OPCODE_BSAVE: equ 96 
9d7c				OPCODE_BLOAD: equ 97 
9d7c				OPCODE_SEO: equ 98  
9d7c				OPCODE_SEI: equ 99 
9d7c				OPCODE_SFREE: equ 100 
9d7c				OPCODE_SIZE: equ 101 
9d7c				OPCODE_CREATE: equ 102 
9d7c				OPCODE_APPEND: equ 103 
9d7c				OPCODE_SDEL: equ 104 
9d7c				OPCODE_OPEN: equ 105 
9d7c				OPCODE_READ: equ 106 
9d7c				OPCODE_EOF: equ 106 
9d7c				OPCODE_FORMAT: equ 107 
9d7c				OPCODE_LABEL: equ 108 
9d7c				OPCODE_LABELS: equ 109 
9d7c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9d7c				OPCODE_UPPER: equ 111 
9d7c				OPCODE_LOWER: equ 112 
9d7c				OPCODE_SUBSTR: equ 113 
9d7c				OPCODE_LEFT: equ 114 
9d7c				OPCODE_RIGHT: equ 115 
9d7c				OPCODE_STR2NUM: equ 116 
9d7c				OPCODE_NUM2STR: equ 117 
9d7c				OPCODE_CONCAT: equ 118 
9d7c				OPCODE_FIND: equ 119 
9d7c				OPCODE_LEN: equ 120 
9d7c				OPCODE_CHAR: equ 121 
9d7c			; free to reuse	OPCODE_STRLEN: equ 122 
9d7c			; free to reuse	OPCODE_ENDSTR: equ 123 
9d7c				OPCODE_V0S: equ 124 
9d7c				OPCODE_V0Q: equ 125 
9d7c				OPCODE_V1S: equ 126 
9d7c				OPCODE_V1Q: equ 127 
9d7c				OPCODE_V2S: equ 128 
9d7c				OPCODE_V2Q: equ 129 
9d7c				OPCODE_V3S: equ 130 
9d7c				OPCODE_V3Q: equ 131 
9d7c			;free to reuse	OPCODE_END: equ 132 
9d7c				OPCODE_ZDUP: equ 133 
9d7c			 
9d7c			; eof 
# End of file forth_opcodes.asm
9d7c			 
9d7c			include "forth_words_core.asm" 
9d7c			 
9d7c			; | ## Core Words 
9d7c			 
9d7c			;if MALLOC_4 
9d7c			 
9d7c			.HEAP: 
9d7c				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9d7c 15				db WORD_SYS_CORE+OPCODE_HEAP             
9d7d bb 9d			dw .EXEC            
9d7f 05				db 4 + 1 
9d80 .. 00			db "HEAP",0              
9d85				endm 
# End of macro CWHEAD
9d85			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9d85			; | | u1 - Current number of bytes in the heap 
9d85			; | | u2 - Remaining bytes left on the heap 
9d85			; | |  
9d85			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9d85			 
9d85			 
9d85					if DEBUG_FORTH_WORDS_KEY 
9d85						DMARK "HEP" 
9d85 f5				push af  
9d86 3a 9a 9d			ld a, (.dmark)  
9d89 32 c0 ee			ld (debug_mark),a  
9d8c 3a 9b 9d			ld a, (.dmark+1)  
9d8f 32 c1 ee			ld (debug_mark+1),a  
9d92 3a 9c 9d			ld a, (.dmark+2)  
9d95 32 c2 ee			ld (debug_mark+2),a  
9d98 18 03			jr .pastdmark  
9d9a ..			.dmark: db "HEP"  
9d9d f1			.pastdmark: pop af  
9d9e			endm  
# End of macro DMARK
9d9e						CALLMONITOR 
9d9e cd 2e 93			call break_point_state  
9da1				endm  
# End of macro CALLMONITOR
9da1					endif 
9da1 2a 7f d7				ld hl, (free_list )      
9da4 11 84 d7				ld de, heap_start 
9da7			 
9da7 ed 52				sbc hl, de  
9da9			 
9da9 cd bb 98				call forth_push_numhl 
9dac			 
9dac			 
9dac ed 5b 7f d7			ld de, (free_list )      
9db0 21 cc e4				ld hl, heap_end 
9db3			 
9db3 ed 52				sbc hl, de 
9db5			 
9db5 cd bb 98				call forth_push_numhl 
9db8					 
9db8			 
9db8					 
9db8			 
9db8			 
9db8			 
9db8					NEXTW 
9db8 c3 24 9c			jp macro_next 
9dbb				endm 
# End of macro NEXTW
9dbb			;endif 
9dbb			 
9dbb			.EXEC: 
9dbb			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9dbb			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9dbb			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9dbb			;; > > 
9dbb			;; > >   
9dbb			;	STACKFRAME OFF $5efe $5f9f 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS_KEY 
9dbb			;			DMARK "EXE" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			;	FORTH_DSP_VALUEHL 
9dbb			; 
9dbb			;	FORTH_DSP_POP 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX1" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;;	ld e,(hl) 
9dbb			;;	inc hl 
9dbb			;;	ld d,(hl) 
9dbb			;;	ex de,hl 
9dbb			; 
9dbb			;;		if DEBUG_FORTH_WORDS 
9dbb			;;			DMARK "EX2" 
9dbb			;;			CALLMONITOR 
9dbb			;;		endif 
9dbb			;	push hl 
9dbb			; 
9dbb			;	;ld a, 0 
9dbb			;	;ld a, FORTH_END_BUFFER 
9dbb			;	call strlenz 
9dbb			;	inc hl   ; include zero term to copy 
9dbb			;	inc hl   ; include term 
9dbb			;	inc hl   ; include term 
9dbb			;	ld b,0 
9dbb			;	ld c,l 
9dbb			;	pop hl 
9dbb			;	ld de, execscratch 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX3" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	ldir 
9dbb			; 
9dbb			; 
9dbb			;	ld hl, execscratch 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EXe" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			;	call forthparse 
9dbb			;	call forthexec 
9dbb			;;	call forthexec_cleanup 
9dbb			;;	call forthparse 
9dbb			;;	call forthexec 
9dbb			; 
9dbb			;	STACKFRAMECHK OFF $5efe $5f9f 
9dbb			; 
9dbb			;	; an immediate word so no need to process any more words 
9dbb			;	ret 
9dbb			;	NEXTW 
9dbb			 
9dbb			; dead code - old version  
9dbb			;	FORTH_RSP_NEXT 
9dbb			 
9dbb			;  
9dbb			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9dbb			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9dbb			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9dbb			;	push hl 
9dbb			;	push de 
9dbb			;	push bc 
9dbb			; 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS_KEY 
9dbb			;			DMARK "EXR" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			; 
9dbb			; 
9dbb			;	;v5 FORTH_DSP_VALUE 
9dbb			;	FORTH_DSP_VALUEHL 
9dbb			; 
9dbb			;	; TODO do string type checks 
9dbb			; 
9dbb			;;v5	inc hl   ; skip type 
9dbb			; 
9dbb			;	push hl  ; source code  
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX1" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	ld a, 0 
9dbb			;	call strlent 
9dbb			; 
9dbb			;	inc hl 
9dbb			;	inc hl 
9dbb			;	inc hl 
9dbb			;	inc hl 
9dbb			; 
9dbb			;	push hl    ; size 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX2" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	call malloc 
9dbb			; 
9dbb			;	ex de, hl    ; de now contains malloc area 
9dbb			;	pop bc   	; get byte count 
9dbb			;	pop hl      ; get string to copy 
9dbb			; 
9dbb			;	push de     ; save malloc for free later 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX3" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	ldir       ; duplicate string 
9dbb			; 
9dbb			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9dbb			;	 
9dbb			;	; TODO fix the parse would be better than this...  
9dbb			;	ex de, hl 
9dbb			;	dec hl 
9dbb			;	ld a, 0 
9dbb			;	ld (hl), a 
9dbb			;	dec hl 
9dbb			;	ld a, ' ' 
9dbb			;	ld (hl), a 
9dbb			;	dec hl 
9dbb			;	ld (hl), a 
9dbb			; 
9dbb			;	dec hl 
9dbb			;	ld (hl), a 
9dbb			; 
9dbb			; 
9dbb			;	FORTH_DSP_POP  
9dbb			; 
9dbb			;	pop hl     
9dbb			;	push hl    ; save malloc area 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX4" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			;	call forthparse 
9dbb			;	call forthexec 
9dbb			;	 
9dbb			;	pop hl 
9dbb			;	if DEBUG_FORTH_WORDS 
9dbb			;		DMARK "EX5" 
9dbb			;		CALLMONITOR 
9dbb			;	endif 
9dbb			; 
9dbb			;	if FORTH_ENABLE_FREE 
9dbb			;	call free 
9dbb			;	endif 
9dbb			; 
9dbb			;	if DEBUG_FORTH_WORDS 
9dbb			;		DMARK "EX6" 
9dbb			;		CALLMONITOR 
9dbb			;	endif 
9dbb			; 
9dbb			;	pop bc 
9dbb			;	pop de 
9dbb			;	pop hl 
9dbb			;;	FORTH_RSP_POP	  
9dbb			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9dbb			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9dbb			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9dbb			; 
9dbb			;	if DEBUG_FORTH_WORDS 
9dbb			;		DMARK "EX7" 
9dbb			;		CALLMONITOR 
9dbb			;	endif 
9dbb			;	NEXTW 
9dbb			 
9dbb			;.STKEXEC: 
9dbb			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9dbb			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9dbb			; 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS_KEY 
9dbb			;			DMARK "STX" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			;	FORTH_DSP_VALUEHL 
9dbb			; 
9dbb			;	ld (store_tmp1), hl    ; count 
9dbb			; 
9dbb			;	FORTH_DSP_POP 
9dbb			;.stkexec1: 
9dbb			;	ld hl, (store_tmp1)   ; count 
9dbb			;	ld a, 0 
9dbb			;	cp l 
9dbb			;	ret z 
9dbb			; 
9dbb			;	dec hl 
9dbb			;	ld (store_tmp1), hl    ; count 
9dbb			;	 
9dbb			;	FORTH_DSP_VALUEHL 
9dbb			;	push hl 
9dbb			;	 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EXp" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	FORTH_DSP_POP 
9dbb			; 
9dbb			;	call strlenz 
9dbb			;	inc hl   ; include zero term to copy 
9dbb			;	inc hl   ; include zero term to copy 
9dbb			;	inc hl   ; include zero term to copy 
9dbb			;	ld b,0 
9dbb			;	ld c,l 
9dbb			;	pop hl 
9dbb			;	ld de, execscratch 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX3" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	ldir 
9dbb			; 
9dbb			; 
9dbb			;	ld hl, execscratch 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EXP" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			;	call forthparse 
9dbb			;	ld hl, execscratch 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EXx" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	call forthexec 
9dbb			; 
9dbb			;	jp .stkexec1 
9dbb			; 
9dbb			;	ret 
9dbb			 
9dbb			 
9dbb			.DUP: 
9dbb				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9dbb 17				db WORD_SYS_CORE+OPCODE_DUP             
9dbc 31 9e			dw .ZDUP            
9dbe 04				db 3 + 1 
9dbf .. 00			db "DUP",0              
9dc3				endm 
# End of macro CWHEAD
9dc3			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9dc3			 
9dc3					if DEBUG_FORTH_WORDS_KEY 
9dc3						DMARK "DUP" 
9dc3 f5				push af  
9dc4 3a d8 9d			ld a, (.dmark)  
9dc7 32 c0 ee			ld (debug_mark),a  
9dca 3a d9 9d			ld a, (.dmark+1)  
9dcd 32 c1 ee			ld (debug_mark+1),a  
9dd0 3a da 9d			ld a, (.dmark+2)  
9dd3 32 c2 ee			ld (debug_mark+2),a  
9dd6 18 03			jr .pastdmark  
9dd8 ..			.dmark: db "DUP"  
9ddb f1			.pastdmark: pop af  
9ddc			endm  
# End of macro DMARK
9ddc						CALLMONITOR 
9ddc cd 2e 93			call break_point_state  
9ddf				endm  
# End of macro CALLMONITOR
9ddf					endif 
9ddf			 
9ddf					FORTH_DSP 
9ddf cd 78 9a			call macro_forth_dsp 
9de2				endm 
# End of macro FORTH_DSP
9de2			 
9de2 7e					ld a, (HL) 
9de3 fe 01				cp DS_TYPE_STR 
9de5 20 25				jr nz, .dupinum 
9de7			 
9de7					; push another string 
9de7			 
9de7					FORTH_DSP_VALUEHL     		 
9de7 cd b2 9a			call macro_dsp_valuehl 
9dea				endm 
# End of macro FORTH_DSP_VALUEHL
9dea			 
9dea				if DEBUG_FORTH_WORDS 
9dea					DMARK "DUs" 
9dea f5				push af  
9deb 3a ff 9d			ld a, (.dmark)  
9dee 32 c0 ee			ld (debug_mark),a  
9df1 3a 00 9e			ld a, (.dmark+1)  
9df4 32 c1 ee			ld (debug_mark+1),a  
9df7 3a 01 9e			ld a, (.dmark+2)  
9dfa 32 c2 ee			ld (debug_mark+2),a  
9dfd 18 03			jr .pastdmark  
9dff ..			.dmark: db "DUs"  
9e02 f1			.pastdmark: pop af  
9e03			endm  
# End of macro DMARK
9e03					CALLMONITOR 
9e03 cd 2e 93			call break_point_state  
9e06				endm  
# End of macro CALLMONITOR
9e06				endif 
9e06 cd 29 99				call forth_push_str 
9e09			 
9e09					NEXTW 
9e09 c3 24 9c			jp macro_next 
9e0c				endm 
# End of macro NEXTW
9e0c			 
9e0c			 
9e0c			.dupinum: 
9e0c					 
9e0c			 
9e0c			 
9e0c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e0c cd b2 9a			call macro_dsp_valuehl 
9e0f				endm 
# End of macro FORTH_DSP_VALUEHL
9e0f			 
9e0f				; TODO add floating point number detection 
9e0f			 
9e0f				if DEBUG_FORTH_WORDS 
9e0f					DMARK "DUi" 
9e0f f5				push af  
9e10 3a 24 9e			ld a, (.dmark)  
9e13 32 c0 ee			ld (debug_mark),a  
9e16 3a 25 9e			ld a, (.dmark+1)  
9e19 32 c1 ee			ld (debug_mark+1),a  
9e1c 3a 26 9e			ld a, (.dmark+2)  
9e1f 32 c2 ee			ld (debug_mark+2),a  
9e22 18 03			jr .pastdmark  
9e24 ..			.dmark: db "DUi"  
9e27 f1			.pastdmark: pop af  
9e28			endm  
# End of macro DMARK
9e28					CALLMONITOR 
9e28 cd 2e 93			call break_point_state  
9e2b				endm  
# End of macro CALLMONITOR
9e2b				endif 
9e2b			 
9e2b cd bb 98				call forth_push_numhl 
9e2e					NEXTW 
9e2e c3 24 9c			jp macro_next 
9e31				endm 
# End of macro NEXTW
9e31			.ZDUP: 
9e31				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9e31 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9e32 69 9e			dw .SWAP            
9e34 05				db 4 + 1 
9e35 .. 00			db "?DUP",0              
9e3a				endm 
# End of macro CWHEAD
9e3a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9e3a			 
9e3a					if DEBUG_FORTH_WORDS_KEY 
9e3a						DMARK "qDU" 
9e3a f5				push af  
9e3b 3a 4f 9e			ld a, (.dmark)  
9e3e 32 c0 ee			ld (debug_mark),a  
9e41 3a 50 9e			ld a, (.dmark+1)  
9e44 32 c1 ee			ld (debug_mark+1),a  
9e47 3a 51 9e			ld a, (.dmark+2)  
9e4a 32 c2 ee			ld (debug_mark+2),a  
9e4d 18 03			jr .pastdmark  
9e4f ..			.dmark: db "qDU"  
9e52 f1			.pastdmark: pop af  
9e53			endm  
# End of macro DMARK
9e53						CALLMONITOR 
9e53 cd 2e 93			call break_point_state  
9e56				endm  
# End of macro CALLMONITOR
9e56					endif 
9e56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e56 cd b2 9a			call macro_dsp_valuehl 
9e59				endm 
# End of macro FORTH_DSP_VALUEHL
9e59			 
9e59 e5					push hl 
9e5a			 
9e5a					; is it a zero? 
9e5a			 
9e5a 3e 00				ld a, 0 
9e5c 84					add h 
9e5d 85					add l 
9e5e			 
9e5e e1					pop hl 
9e5f			 
9e5f fe 00				cp 0 
9e61 28 03				jr z, .dup2orig 
9e63			 
9e63			 
9e63 cd bb 98				call forth_push_numhl 
9e66			 
9e66			 
9e66				; TODO add floating point number detection 
9e66			 
9e66			.dup2orig: 
9e66			 
9e66					NEXTW 
9e66 c3 24 9c			jp macro_next 
9e69				endm 
# End of macro NEXTW
9e69			.SWAP: 
9e69				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9e69 18				db WORD_SYS_CORE+OPCODE_SWAP             
9e6a a8 9e			dw .COLN            
9e6c 05				db 4 + 1 
9e6d .. 00			db "SWAP",0              
9e72				endm 
# End of macro CWHEAD
9e72			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9e72					if DEBUG_FORTH_WORDS_KEY 
9e72						DMARK "SWP" 
9e72 f5				push af  
9e73 3a 87 9e			ld a, (.dmark)  
9e76 32 c0 ee			ld (debug_mark),a  
9e79 3a 88 9e			ld a, (.dmark+1)  
9e7c 32 c1 ee			ld (debug_mark+1),a  
9e7f 3a 89 9e			ld a, (.dmark+2)  
9e82 32 c2 ee			ld (debug_mark+2),a  
9e85 18 03			jr .pastdmark  
9e87 ..			.dmark: db "SWP"  
9e8a f1			.pastdmark: pop af  
9e8b			endm  
# End of macro DMARK
9e8b						CALLMONITOR 
9e8b cd 2e 93			call break_point_state  
9e8e				endm  
# End of macro CALLMONITOR
9e8e					endif 
9e8e			 
9e8e					FORTH_DSP_VALUEHL 
9e8e cd b2 9a			call macro_dsp_valuehl 
9e91				endm 
# End of macro FORTH_DSP_VALUEHL
9e91 e5					push hl     ; w2 
9e92			 
9e92					FORTH_DSP_POP 
9e92 cd 6a 9b			call macro_forth_dsp_pop 
9e95				endm 
# End of macro FORTH_DSP_POP
9e95			 
9e95					FORTH_DSP_VALUEHL 
9e95 cd b2 9a			call macro_dsp_valuehl 
9e98				endm 
# End of macro FORTH_DSP_VALUEHL
9e98			 
9e98					FORTH_DSP_POP 
9e98 cd 6a 9b			call macro_forth_dsp_pop 
9e9b				endm 
# End of macro FORTH_DSP_POP
9e9b			 
9e9b d1					pop de     ; w2	, hl = w1 
9e9c			 
9e9c eb					ex de, hl 
9e9d d5					push de 
9e9e			 
9e9e cd bb 98				call forth_push_numhl 
9ea1			 
9ea1 e1					pop hl 
9ea2			 
9ea2 cd bb 98				call forth_push_numhl 
9ea5					 
9ea5			 
9ea5					NEXTW 
9ea5 c3 24 9c			jp macro_next 
9ea8				endm 
# End of macro NEXTW
9ea8			.COLN: 
9ea8				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9ea8 19				db WORD_SYS_CORE+OPCODE_COLN             
9ea9 34 a0			dw .SCOLN            
9eab 02				db 1 + 1 
9eac .. 00			db ":",0              
9eae				endm 
# End of macro CWHEAD
9eae			; | : ( -- )         Create new word | DONE 
9eae			 
9eae					if DEBUG_FORTH_WORDS_KEY 
9eae						DMARK "CLN" 
9eae f5				push af  
9eaf 3a c3 9e			ld a, (.dmark)  
9eb2 32 c0 ee			ld (debug_mark),a  
9eb5 3a c4 9e			ld a, (.dmark+1)  
9eb8 32 c1 ee			ld (debug_mark+1),a  
9ebb 3a c5 9e			ld a, (.dmark+2)  
9ebe 32 c2 ee			ld (debug_mark+2),a  
9ec1 18 03			jr .pastdmark  
9ec3 ..			.dmark: db "CLN"  
9ec6 f1			.pastdmark: pop af  
9ec7			endm  
# End of macro DMARK
9ec7						CALLMONITOR 
9ec7 cd 2e 93			call break_point_state  
9eca				endm  
# End of macro CALLMONITOR
9eca					endif 
9eca				STACKFRAME OFF $8efe $989f 
9eca				if DEBUG_STACK_IMB 
9eca					if OFF 
9eca						exx 
9eca						ld de, $8efe 
9eca						ld a, d 
9eca						ld hl, curframe 
9eca						call hexout 
9eca						ld a, e 
9eca						ld hl, curframe+2 
9eca						call hexout 
9eca						ld hl, $8efe 
9eca						push hl 
9eca						ld hl, $989f 
9eca						push hl 
9eca						exx 
9eca					endif 
9eca				endif 
9eca			endm 
# End of macro STACKFRAME
9eca				; get parser buffer length  of new word 
9eca			 
9eca				 
9eca			 
9eca					; move tok past this to start of name defintition 
9eca					; TODO get word to define 
9eca					; TODO Move past word token 
9eca					; TODO get length of string up to the ';' 
9eca			 
9eca 2a e7 e7			ld hl, (os_tok_ptr) 
9ecd 23				inc hl 
9ece 23				inc hl 
9ecf			 
9ecf 3e 3b			ld a, ';' 
9ed1 cd 24 8f			call strlent 
9ed4			 
9ed4 7d				ld a,l 
9ed5 32 e2 e4			ld (os_new_parse_len), a 
9ed8			 
9ed8			 
9ed8			if DEBUG_FORTH_UWORD 
9ed8 ed 5b e7 e7		ld de, (os_tok_ptr) 
9edc						DMARK ":01" 
9edc f5				push af  
9edd 3a f1 9e			ld a, (.dmark)  
9ee0 32 c0 ee			ld (debug_mark),a  
9ee3 3a f2 9e			ld a, (.dmark+1)  
9ee6 32 c1 ee			ld (debug_mark+1),a  
9ee9 3a f3 9e			ld a, (.dmark+2)  
9eec 32 c2 ee			ld (debug_mark+2),a  
9eef 18 03			jr .pastdmark  
9ef1 ..			.dmark: db ":01"  
9ef4 f1			.pastdmark: pop af  
9ef5			endm  
# End of macro DMARK
9ef5				CALLMONITOR 
9ef5 cd 2e 93			call break_point_state  
9ef8				endm  
# End of macro CALLMONITOR
9ef8			endif 
9ef8			 
9ef8			; 
9ef8			;  new word memory layout: 
9ef8			;  
9ef8			;    : adg 6666 ;  
9ef8			; 
9ef8			;    db   1     ; user defined word  
9ef8 23				inc hl    
9ef9			;    dw   sysdict 
9ef9 23				inc hl 
9efa 23				inc hl 
9efb			;    db <word len>+1 (for null) 
9efb 23				inc hl 
9efc			;    db .... <word> 
9efc			; 
9efc			 
9efc 23				inc hl    ; some extras for the word preamble before the above 
9efd 23				inc hl 
9efe 23				inc hl 
9eff 23				inc hl 
9f00 23				inc hl 
9f01 23				inc hl 
9f02 23				inc hl  
9f03 23				inc hl 
9f04 23				inc hl 
9f05 23				inc hl 
9f06 23				inc hl 
9f07 23				inc hl 
9f08 23				inc hl 
9f09 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9f0a			;       exec word buffer 
9f0a			;	<ptr word>   
9f0a 23				inc hl 
9f0b 23				inc hl 
9f0c			;       <word list><null term> 7F final term 
9f0c			 
9f0c			 
9f0c			if DEBUG_FORTH_UWORD 
9f0c						DMARK ":02" 
9f0c f5				push af  
9f0d 3a 21 9f			ld a, (.dmark)  
9f10 32 c0 ee			ld (debug_mark),a  
9f13 3a 22 9f			ld a, (.dmark+1)  
9f16 32 c1 ee			ld (debug_mark+1),a  
9f19 3a 23 9f			ld a, (.dmark+2)  
9f1c 32 c2 ee			ld (debug_mark+2),a  
9f1f 18 03			jr .pastdmark  
9f21 ..			.dmark: db ":02"  
9f24 f1			.pastdmark: pop af  
9f25			endm  
# End of macro DMARK
9f25				CALLMONITOR 
9f25 cd 2e 93			call break_point_state  
9f28				endm  
# End of macro CALLMONITOR
9f28			endif 
9f28			 
9f28				 
9f28					; malloc the size 
9f28			 
9f28 cd 82 8f				call malloc 
9f2b 22 e4 e4				ld (os_new_malloc), hl     ; save malloc start 
9f2e			 
9f2e			;    db   1     ; user defined word  
9f2e 3e 01				ld a, WORD_SYS_UWORD  
9f30 77					ld (hl), a 
9f31				 
9f31 23				inc hl    
9f32			;    dw   sysdict 
9f32 11 7c 9d			ld de, sysdict       ; continue on with the scan to the system dict 
9f35 73				ld (hl), e 
9f36 23				inc hl 
9f37 72				ld (hl), d 
9f38 23				inc hl 
9f39			 
9f39			 
9f39			;    Setup dict word 
9f39			 
9f39 23				inc hl 
9f3a 22 de e4			ld (os_new_work_ptr), hl     ; save start of dict word  
9f3d			 
9f3d				; 1. get length of dict word 
9f3d			 
9f3d			 
9f3d 2a e7 e7			ld hl, (os_tok_ptr) 
9f40 23				inc hl 
9f41 23				inc hl    ; position to start of dict word 
9f42 3e 00			ld a, 0 
9f44 cd 24 8f			call strlent 
9f47			 
9f47			 
9f47 23				inc hl    ; to include null??? 
9f48			 
9f48				; write length of dict word 
9f48			 
9f48 ed 5b de e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f4c 1b				dec de 
9f4d eb				ex de, hl 
9f4e 73				ld (hl), e 
9f4f eb				ex de, hl 
9f50			 
9f50				 
9f50			 
9f50				; copy  
9f50 4d				ld c, l 
9f51 06 00			ld b, 0 
9f53 ed 5b de e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f57 2a e7 e7			ld hl, (os_tok_ptr) 
9f5a 23				inc hl 
9f5b 23				inc hl    ; position to start of dict word 
9f5c				 
9f5c			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
9f5c				 
9f5c				; TODO need to convert word to upper case 
9f5c			 
9f5c			ucasetok:	 
9f5c 7e				ld a,(hl) 
9f5d cd 10 8f			call toUpper 
9f60 77				ld (hl),a 
9f61 ed a0			ldi 
9f63 f2 5c 9f		 	jp p, ucasetok 
9f66			 
9f66			 
9f66			 
9f66				; de now points to start of where the word body code should be placed 
9f66 ed 53 de e4		ld (os_new_work_ptr), de 
9f6a				; hl now points to the words to throw at forthexec which needs to be copied 
9f6a 22 dc e4			ld (os_new_src_ptr), hl 
9f6d			 
9f6d				; TODO add 'call to forthexec' 
9f6d			 
9f6d			if DEBUG_FORTH_UWORD 
9f6d c5				push bc 
9f6e ed 4b e4 e4		ld bc, (os_new_malloc) 
9f72						DMARK ":0x" 
9f72 f5				push af  
9f73 3a 87 9f			ld a, (.dmark)  
9f76 32 c0 ee			ld (debug_mark),a  
9f79 3a 88 9f			ld a, (.dmark+1)  
9f7c 32 c1 ee			ld (debug_mark+1),a  
9f7f 3a 89 9f			ld a, (.dmark+2)  
9f82 32 c2 ee			ld (debug_mark+2),a  
9f85 18 03			jr .pastdmark  
9f87 ..			.dmark: db ":0x"  
9f8a f1			.pastdmark: pop af  
9f8b			endm  
# End of macro DMARK
9f8b				CALLMONITOR 
9f8b cd 2e 93			call break_point_state  
9f8e				endm  
# End of macro CALLMONITOR
9f8e c1				pop bc 
9f8f			endif 
9f8f			 
9f8f			 
9f8f				; create word preamble which should be: 
9f8f			 
9f8f			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
9f8f			 
9f8f				;    ld hl, <word code> 
9f8f				;    jp user_exec 
9f8f			        ;    <word code bytes> 
9f8f			 
9f8f			 
9f8f			;	inc de     ; TODO ??? or are we already past the word's null 
9f8f eb				ex de, hl 
9f90			 
9f90 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
9f92			 
9f92 23				inc hl 
9f93 22 d8 e4			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
9f96 23				inc hl 
9f97			 
9f97 23				inc hl 
9f98 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
9f9a			 
9f9a 01 58 c3			ld bc, user_exec 
9f9d 23				inc hl 
9f9e 71				ld (hl), c     ; poke address of user_exec 
9f9f 23				inc hl 
9fa0 70				ld (hl), b     
9fa1			 ; 
9fa1			;	inc hl 
9fa1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9fa1			; 
9fa1			; 
9fa1			;	ld bc, macro_forth_rsp_next 
9fa1			;	inc hl 
9fa1			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
9fa1			;	inc hl 
9fa1			;	ld (hl), b     
9fa1			 ; 
9fa1			;	inc hl 
9fa1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9fa1			; 
9fa1			; 
9fa1			;	inc hl 
9fa1			;	ld bc, forthexec 
9fa1			;	ld (hl), c     ; poke address of forthexec 
9fa1			;	inc hl 
9fa1			;	ld (hl), b      
9fa1			; 
9fa1			;	inc hl 
9fa1			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
9fa1			; 
9fa1			;	ld bc, user_dict_next 
9fa1			;	inc hl 
9fa1			;	ld (hl), c     ; poke address of forthexec 
9fa1			;	inc hl 
9fa1			;	ld (hl), b      
9fa1			 
9fa1				; hl is now where we need to copy the word byte data to save this 
9fa1			 
9fa1 23				inc hl 
9fa2 22 da e4			ld (os_new_exec), hl 
9fa5				 
9fa5				; copy definition 
9fa5			 
9fa5 eb				ex de, hl 
9fa6			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
9fa6			;	inc de    ; skip the PC for this parse 
9fa6 3a e2 e4			ld a, (os_new_parse_len) 
9fa9 4f				ld c, a 
9faa 06 00			ld b, 0 
9fac ed b0			ldir		 ; copy defintion 
9fae			 
9fae			 
9fae				; poke the address of where the new word bytes live for forthexec 
9fae			 
9fae 2a d8 e4			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
9fb1			 
9fb1 ed 5b da e4		ld de, (os_new_exec)      
9fb5				 
9fb5 73				ld (hl), e 
9fb6 23				inc hl 
9fb7 72				ld (hl), d 
9fb8			 
9fb8					; TODO copy last user dict word next link to this word 
9fb8					; TODO update last user dict word to point to this word 
9fb8			; 
9fb8			; hl f923 de 812a ; bc 811a 
9fb8			 
9fb8			if DEBUG_FORTH_UWORD 
9fb8 c5				push bc 
9fb9 ed 4b e4 e4		ld bc, (os_new_malloc) 
9fbd						DMARK ":0A" 
9fbd f5				push af  
9fbe 3a d2 9f			ld a, (.dmark)  
9fc1 32 c0 ee			ld (debug_mark),a  
9fc4 3a d3 9f			ld a, (.dmark+1)  
9fc7 32 c1 ee			ld (debug_mark+1),a  
9fca 3a d4 9f			ld a, (.dmark+2)  
9fcd 32 c2 ee			ld (debug_mark+2),a  
9fd0 18 03			jr .pastdmark  
9fd2 ..			.dmark: db ":0A"  
9fd5 f1			.pastdmark: pop af  
9fd6			endm  
# End of macro DMARK
9fd6				CALLMONITOR 
9fd6 cd 2e 93			call break_point_state  
9fd9				endm  
# End of macro CALLMONITOR
9fd9 c1				pop bc 
9fda			endif 
9fda			if DEBUG_FORTH_UWORD 
9fda c5				push bc 
9fdb ed 4b e4 e4		ld bc, (os_new_malloc) 
9fdf 03				inc bc 
9fe0 03				inc bc 
9fe1 03				inc bc 
9fe2 03				inc bc 
9fe3 03				inc bc 
9fe4 03				inc bc 
9fe5 03				inc bc 
9fe6 03				inc bc 
9fe7			 
9fe7						DMARK ":0B" 
9fe7 f5				push af  
9fe8 3a fc 9f			ld a, (.dmark)  
9feb 32 c0 ee			ld (debug_mark),a  
9fee 3a fd 9f			ld a, (.dmark+1)  
9ff1 32 c1 ee			ld (debug_mark+1),a  
9ff4 3a fe 9f			ld a, (.dmark+2)  
9ff7 32 c2 ee			ld (debug_mark+2),a  
9ffa 18 03			jr .pastdmark  
9ffc ..			.dmark: db ":0B"  
9fff f1			.pastdmark: pop af  
a000			endm  
# End of macro DMARK
a000				CALLMONITOR 
a000 cd 2e 93			call break_point_state  
a003				endm  
# End of macro CALLMONITOR
a003 c1				pop bc 
a004			endif 
a004			 
a004			; update word dict linked list for new word 
a004			 
a004			 
a004 2a e3 e7		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a007 23			inc hl     ; move to next work linked list ptr 
a008			 
a008 ed 5b e4 e4	ld de, (os_new_malloc)		 ; new next word 
a00c 73			ld (hl), e 
a00d 23			inc hl 
a00e 72			ld (hl), d 
a00f			 
a00f			if DEBUG_FORTH_UWORD 
a00f ed 4b e3 e7		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a013			endif 
a013			 
a013 ed 53 e3 e7	ld (os_last_new_uword), de      ; update last new uword ptr 
a017			 
a017			 
a017			if DEBUG_FORTH_UWORD 
a017						DMARK ":0+" 
a017 f5				push af  
a018 3a 2c a0			ld a, (.dmark)  
a01b 32 c0 ee			ld (debug_mark),a  
a01e 3a 2d a0			ld a, (.dmark+1)  
a021 32 c1 ee			ld (debug_mark+1),a  
a024 3a 2e a0			ld a, (.dmark+2)  
a027 32 c2 ee			ld (debug_mark+2),a  
a02a 18 03			jr .pastdmark  
a02c ..			.dmark: db ":0+"  
a02f f1			.pastdmark: pop af  
a030			endm  
# End of macro DMARK
a030				CALLMONITOR 
a030 cd 2e 93			call break_point_state  
a033				endm  
# End of macro CALLMONITOR
a033			endif 
a033			 
a033				STACKFRAMECHK OFF $8efe $989f 
a033				if DEBUG_STACK_IMB 
a033					if OFF 
a033						exx 
a033						ld hl, $989f 
a033						pop de   ; $989f 
a033						call cmp16 
a033						jr nz, .spnosame 
a033						ld hl, $8efe 
a033						pop de   ; $8efe 
a033						call cmp16 
a033						jr z, .spfrsame 
a033						.spnosame: call showsperror 
a033						.spfrsame: nop 
a033						exx 
a033					endif 
a033				endif 
a033			endm 
# End of macro STACKFRAMECHK
a033			 
a033 c9			ret    ; dont process any remaining parser tokens as they form new word 
a034			 
a034			 
a034			 
a034			 
a034			;		NEXT 
a034			.SCOLN: 
a034			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a034 06				db OPCODE_SCOLN 
a035 80 a0			dw .DROP 
a037 02				db 2 
a038 .. 00			db ";",0           
a03a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a03a					if DEBUG_FORTH_WORDS_KEY 
a03a						DMARK "SCN" 
a03a f5				push af  
a03b 3a 4f a0			ld a, (.dmark)  
a03e 32 c0 ee			ld (debug_mark),a  
a041 3a 50 a0			ld a, (.dmark+1)  
a044 32 c1 ee			ld (debug_mark+1),a  
a047 3a 51 a0			ld a, (.dmark+2)  
a04a 32 c2 ee			ld (debug_mark+2),a  
a04d 18 03			jr .pastdmark  
a04f ..			.dmark: db "SCN"  
a052 f1			.pastdmark: pop af  
a053			endm  
# End of macro DMARK
a053						CALLMONITOR 
a053 cd 2e 93			call break_point_state  
a056				endm  
# End of macro CALLMONITOR
a056					endif 
a056					FORTH_RSP_TOS 
a056 cd 79 98			call macro_forth_rsp_tos 
a059				endm 
# End of macro FORTH_RSP_TOS
a059 e5					push hl 
a05a					FORTH_RSP_POP 
a05a cd 83 98			call macro_forth_rsp_pop 
a05d				endm 
# End of macro FORTH_RSP_POP
a05d e1					pop hl 
a05e			;		ex de,hl 
a05e 22 e7 e7				ld (os_tok_ptr),hl 
a061			 
a061			if DEBUG_FORTH_UWORD 
a061						DMARK "SCL" 
a061 f5				push af  
a062 3a 76 a0			ld a, (.dmark)  
a065 32 c0 ee			ld (debug_mark),a  
a068 3a 77 a0			ld a, (.dmark+1)  
a06b 32 c1 ee			ld (debug_mark+1),a  
a06e 3a 78 a0			ld a, (.dmark+2)  
a071 32 c2 ee			ld (debug_mark+2),a  
a074 18 03			jr .pastdmark  
a076 ..			.dmark: db "SCL"  
a079 f1			.pastdmark: pop af  
a07a			endm  
# End of macro DMARK
a07a				CALLMONITOR 
a07a cd 2e 93			call break_point_state  
a07d				endm  
# End of macro CALLMONITOR
a07d			endif 
a07d					NEXTW 
a07d c3 24 9c			jp macro_next 
a080				endm 
# End of macro NEXTW
a080			 
a080			.DROP: 
a080				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a080 1b				db WORD_SYS_CORE+OPCODE_DROP             
a081 ab a0			dw .DUP2            
a083 05				db 4 + 1 
a084 .. 00			db "DROP",0              
a089				endm 
# End of macro CWHEAD
a089			; | DROP ( w -- )   drop the TOS item   | DONE 
a089					if DEBUG_FORTH_WORDS_KEY 
a089						DMARK "DRP" 
a089 f5				push af  
a08a 3a 9e a0			ld a, (.dmark)  
a08d 32 c0 ee			ld (debug_mark),a  
a090 3a 9f a0			ld a, (.dmark+1)  
a093 32 c1 ee			ld (debug_mark+1),a  
a096 3a a0 a0			ld a, (.dmark+2)  
a099 32 c2 ee			ld (debug_mark+2),a  
a09c 18 03			jr .pastdmark  
a09e ..			.dmark: db "DRP"  
a0a1 f1			.pastdmark: pop af  
a0a2			endm  
# End of macro DMARK
a0a2						CALLMONITOR 
a0a2 cd 2e 93			call break_point_state  
a0a5				endm  
# End of macro CALLMONITOR
a0a5					endif 
a0a5					FORTH_DSP_POP 
a0a5 cd 6a 9b			call macro_forth_dsp_pop 
a0a8				endm 
# End of macro FORTH_DSP_POP
a0a8					NEXTW 
a0a8 c3 24 9c			jp macro_next 
a0ab				endm 
# End of macro NEXTW
a0ab			.DUP2: 
a0ab				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a0ab 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a0ac f0 a0			dw .DROP2            
a0ae 05				db 4 + 1 
a0af .. 00			db "2DUP",0              
a0b4				endm 
# End of macro CWHEAD
a0b4			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a0b4					if DEBUG_FORTH_WORDS_KEY 
a0b4						DMARK "2DU" 
a0b4 f5				push af  
a0b5 3a c9 a0			ld a, (.dmark)  
a0b8 32 c0 ee			ld (debug_mark),a  
a0bb 3a ca a0			ld a, (.dmark+1)  
a0be 32 c1 ee			ld (debug_mark+1),a  
a0c1 3a cb a0			ld a, (.dmark+2)  
a0c4 32 c2 ee			ld (debug_mark+2),a  
a0c7 18 03			jr .pastdmark  
a0c9 ..			.dmark: db "2DU"  
a0cc f1			.pastdmark: pop af  
a0cd			endm  
# End of macro DMARK
a0cd						CALLMONITOR 
a0cd cd 2e 93			call break_point_state  
a0d0				endm  
# End of macro CALLMONITOR
a0d0					endif 
a0d0					FORTH_DSP_VALUEHL 
a0d0 cd b2 9a			call macro_dsp_valuehl 
a0d3				endm 
# End of macro FORTH_DSP_VALUEHL
a0d3 e5					push hl      ; 2 
a0d4			 
a0d4					FORTH_DSP_POP 
a0d4 cd 6a 9b			call macro_forth_dsp_pop 
a0d7				endm 
# End of macro FORTH_DSP_POP
a0d7					 
a0d7					FORTH_DSP_VALUEHL 
a0d7 cd b2 9a			call macro_dsp_valuehl 
a0da				endm 
# End of macro FORTH_DSP_VALUEHL
a0da			;		push hl      ; 1 
a0da			 
a0da					FORTH_DSP_POP 
a0da cd 6a 9b			call macro_forth_dsp_pop 
a0dd				endm 
# End of macro FORTH_DSP_POP
a0dd			 
a0dd			;		pop hl       ; 1 
a0dd d1					pop de       ; 2 
a0de			 
a0de cd bb 98				call forth_push_numhl 
a0e1 eb					ex de, hl 
a0e2 cd bb 98				call forth_push_numhl 
a0e5			 
a0e5					 
a0e5 eb					ex de, hl 
a0e6			 
a0e6 cd bb 98				call forth_push_numhl 
a0e9 eb					ex de, hl 
a0ea cd bb 98				call forth_push_numhl 
a0ed			 
a0ed			 
a0ed					NEXTW 
a0ed c3 24 9c			jp macro_next 
a0f0				endm 
# End of macro NEXTW
a0f0			.DROP2: 
a0f0				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a0f0 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a0f1 1f a1			dw .SWAP2            
a0f3 06				db 5 + 1 
a0f4 .. 00			db "2DROP",0              
a0fa				endm 
# End of macro CWHEAD
a0fa			; | 2DROP ( w w -- )    Double drop | DONE 
a0fa					if DEBUG_FORTH_WORDS_KEY 
a0fa						DMARK "2DR" 
a0fa f5				push af  
a0fb 3a 0f a1			ld a, (.dmark)  
a0fe 32 c0 ee			ld (debug_mark),a  
a101 3a 10 a1			ld a, (.dmark+1)  
a104 32 c1 ee			ld (debug_mark+1),a  
a107 3a 11 a1			ld a, (.dmark+2)  
a10a 32 c2 ee			ld (debug_mark+2),a  
a10d 18 03			jr .pastdmark  
a10f ..			.dmark: db "2DR"  
a112 f1			.pastdmark: pop af  
a113			endm  
# End of macro DMARK
a113						CALLMONITOR 
a113 cd 2e 93			call break_point_state  
a116				endm  
# End of macro CALLMONITOR
a116					endif 
a116					FORTH_DSP_POP 
a116 cd 6a 9b			call macro_forth_dsp_pop 
a119				endm 
# End of macro FORTH_DSP_POP
a119					FORTH_DSP_POP 
a119 cd 6a 9b			call macro_forth_dsp_pop 
a11c				endm 
# End of macro FORTH_DSP_POP
a11c					NEXTW 
a11c c3 24 9c			jp macro_next 
a11f				endm 
# End of macro NEXTW
a11f			.SWAP2: 
a11f				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a11f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a120 48 a1			dw .AT            
a122 06				db 5 + 1 
a123 .. 00			db "2SWAP",0              
a129				endm 
# End of macro CWHEAD
a129			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a129					if DEBUG_FORTH_WORDS_KEY 
a129						DMARK "2SW" 
a129 f5				push af  
a12a 3a 3e a1			ld a, (.dmark)  
a12d 32 c0 ee			ld (debug_mark),a  
a130 3a 3f a1			ld a, (.dmark+1)  
a133 32 c1 ee			ld (debug_mark+1),a  
a136 3a 40 a1			ld a, (.dmark+2)  
a139 32 c2 ee			ld (debug_mark+2),a  
a13c 18 03			jr .pastdmark  
a13e ..			.dmark: db "2SW"  
a141 f1			.pastdmark: pop af  
a142			endm  
# End of macro DMARK
a142						CALLMONITOR 
a142 cd 2e 93			call break_point_state  
a145				endm  
# End of macro CALLMONITOR
a145					endif 
a145					NEXTW 
a145 c3 24 9c			jp macro_next 
a148				endm 
# End of macro NEXTW
a148			.AT: 
a148				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a148 1f				db WORD_SYS_CORE+OPCODE_AT             
a149 7a a1			dw .CAT            
a14b 02				db 1 + 1 
a14c .. 00			db "@",0              
a14e				endm 
# End of macro CWHEAD
a14e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a14e			 
a14e					if DEBUG_FORTH_WORDS_KEY 
a14e						DMARK "AT." 
a14e f5				push af  
a14f 3a 63 a1			ld a, (.dmark)  
a152 32 c0 ee			ld (debug_mark),a  
a155 3a 64 a1			ld a, (.dmark+1)  
a158 32 c1 ee			ld (debug_mark+1),a  
a15b 3a 65 a1			ld a, (.dmark+2)  
a15e 32 c2 ee			ld (debug_mark+2),a  
a161 18 03			jr .pastdmark  
a163 ..			.dmark: db "AT."  
a166 f1			.pastdmark: pop af  
a167			endm  
# End of macro DMARK
a167						CALLMONITOR 
a167 cd 2e 93			call break_point_state  
a16a				endm  
# End of macro CALLMONITOR
a16a					endif 
a16a			.getbyteat:	 
a16a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a16a cd b2 9a			call macro_dsp_valuehl 
a16d				endm 
# End of macro FORTH_DSP_VALUEHL
a16d					 
a16d			;		push hl 
a16d				 
a16d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a16d cd 6a 9b			call macro_forth_dsp_pop 
a170				endm 
# End of macro FORTH_DSP_POP
a170			 
a170			;		pop hl 
a170			 
a170 7e					ld a, (hl) 
a171			 
a171 6f					ld l, a 
a172 26 00				ld h, 0 
a174 cd bb 98				call forth_push_numhl 
a177			 
a177					NEXTW 
a177 c3 24 9c			jp macro_next 
a17a				endm 
# End of macro NEXTW
a17a			.CAT: 
a17a				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a17a 20				db WORD_SYS_CORE+OPCODE_CAT             
a17b a3 a1			dw .BANG            
a17d 03				db 2 + 1 
a17e .. 00			db "C@",0              
a181				endm 
# End of macro CWHEAD
a181			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a181					if DEBUG_FORTH_WORDS_KEY 
a181						DMARK "CAA" 
a181 f5				push af  
a182 3a 96 a1			ld a, (.dmark)  
a185 32 c0 ee			ld (debug_mark),a  
a188 3a 97 a1			ld a, (.dmark+1)  
a18b 32 c1 ee			ld (debug_mark+1),a  
a18e 3a 98 a1			ld a, (.dmark+2)  
a191 32 c2 ee			ld (debug_mark+2),a  
a194 18 03			jr .pastdmark  
a196 ..			.dmark: db "CAA"  
a199 f1			.pastdmark: pop af  
a19a			endm  
# End of macro DMARK
a19a						CALLMONITOR 
a19a cd 2e 93			call break_point_state  
a19d				endm  
# End of macro CALLMONITOR
a19d					endif 
a19d c3 6a a1				jp .getbyteat 
a1a0					NEXTW 
a1a0 c3 24 9c			jp macro_next 
a1a3				endm 
# End of macro NEXTW
a1a3			.BANG: 
a1a3				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a1a3 21				db WORD_SYS_CORE+OPCODE_BANG             
a1a4 d9 a1			dw .CBANG            
a1a6 02				db 1 + 1 
a1a7 .. 00			db "!",0              
a1a9				endm 
# End of macro CWHEAD
a1a9			; | ! ( x w -- ) Store x at address w      | DONE 
a1a9					if DEBUG_FORTH_WORDS_KEY 
a1a9						DMARK "BNG" 
a1a9 f5				push af  
a1aa 3a be a1			ld a, (.dmark)  
a1ad 32 c0 ee			ld (debug_mark),a  
a1b0 3a bf a1			ld a, (.dmark+1)  
a1b3 32 c1 ee			ld (debug_mark+1),a  
a1b6 3a c0 a1			ld a, (.dmark+2)  
a1b9 32 c2 ee			ld (debug_mark+2),a  
a1bc 18 03			jr .pastdmark  
a1be ..			.dmark: db "BNG"  
a1c1 f1			.pastdmark: pop af  
a1c2			endm  
# End of macro DMARK
a1c2						CALLMONITOR 
a1c2 cd 2e 93			call break_point_state  
a1c5				endm  
# End of macro CALLMONITOR
a1c5					endif 
a1c5			 
a1c5			.storebyteat:		 
a1c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1c5 cd b2 9a			call macro_dsp_valuehl 
a1c8				endm 
# End of macro FORTH_DSP_VALUEHL
a1c8					 
a1c8 e5					push hl 
a1c9				 
a1c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1c9 cd 6a 9b			call macro_forth_dsp_pop 
a1cc				endm 
# End of macro FORTH_DSP_POP
a1cc			 
a1cc					; get byte to poke 
a1cc			 
a1cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1cc cd b2 9a			call macro_dsp_valuehl 
a1cf				endm 
# End of macro FORTH_DSP_VALUEHL
a1cf e5					push hl 
a1d0			 
a1d0			 
a1d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1d0 cd 6a 9b			call macro_forth_dsp_pop 
a1d3				endm 
# End of macro FORTH_DSP_POP
a1d3			 
a1d3			 
a1d3 d1					pop de 
a1d4 e1					pop hl 
a1d5			 
a1d5 73					ld (hl),e 
a1d6			 
a1d6			 
a1d6					NEXTW 
a1d6 c3 24 9c			jp macro_next 
a1d9				endm 
# End of macro NEXTW
a1d9			.CBANG: 
a1d9				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a1d9 22				db WORD_SYS_CORE+OPCODE_CBANG             
a1da 02 a2			dw .SCALL            
a1dc 03				db 2 + 1 
a1dd .. 00			db "C!",0              
a1e0				endm 
# End of macro CWHEAD
a1e0			; | C!  ( x w -- ) Store x at address w  | DONE 
a1e0					if DEBUG_FORTH_WORDS_KEY 
a1e0						DMARK "CBA" 
a1e0 f5				push af  
a1e1 3a f5 a1			ld a, (.dmark)  
a1e4 32 c0 ee			ld (debug_mark),a  
a1e7 3a f6 a1			ld a, (.dmark+1)  
a1ea 32 c1 ee			ld (debug_mark+1),a  
a1ed 3a f7 a1			ld a, (.dmark+2)  
a1f0 32 c2 ee			ld (debug_mark+2),a  
a1f3 18 03			jr .pastdmark  
a1f5 ..			.dmark: db "CBA"  
a1f8 f1			.pastdmark: pop af  
a1f9			endm  
# End of macro DMARK
a1f9						CALLMONITOR 
a1f9 cd 2e 93			call break_point_state  
a1fc				endm  
# End of macro CALLMONITOR
a1fc					endif 
a1fc c3 c5 a1				jp .storebyteat 
a1ff					NEXTW 
a1ff c3 24 9c			jp macro_next 
a202				endm 
# End of macro NEXTW
a202			.SCALL: 
a202				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a202 23				db WORD_SYS_CORE+OPCODE_SCALL             
a203 36 a2			dw .DEPTH            
a205 05				db 4 + 1 
a206 .. 00			db "CALL",0              
a20b				endm 
# End of macro CWHEAD
a20b			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a20b					if DEBUG_FORTH_WORDS_KEY 
a20b						DMARK "CLL" 
a20b f5				push af  
a20c 3a 20 a2			ld a, (.dmark)  
a20f 32 c0 ee			ld (debug_mark),a  
a212 3a 21 a2			ld a, (.dmark+1)  
a215 32 c1 ee			ld (debug_mark+1),a  
a218 3a 22 a2			ld a, (.dmark+2)  
a21b 32 c2 ee			ld (debug_mark+2),a  
a21e 18 03			jr .pastdmark  
a220 ..			.dmark: db "CLL"  
a223 f1			.pastdmark: pop af  
a224			endm  
# End of macro DMARK
a224						CALLMONITOR 
a224 cd 2e 93			call break_point_state  
a227				endm  
# End of macro CALLMONITOR
a227					endif 
a227			 
a227					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a227 cd b2 9a			call macro_dsp_valuehl 
a22a				endm 
# End of macro FORTH_DSP_VALUEHL
a22a			 
a22a			;		push hl 
a22a			 
a22a					; destroy value TOS 
a22a			 
a22a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a22a cd 6a 9b			call macro_forth_dsp_pop 
a22d				endm 
# End of macro FORTH_DSP_POP
a22d			 
a22d						 
a22d			;		pop hl 
a22d			 
a22d					; how to do a call with hl???? save SP? 
a22d cd cd 9b				call forth_call_hl 
a230			 
a230			 
a230					; TODO push value back onto stack for another op etc 
a230			 
a230 cd bb 98				call forth_push_numhl 
a233					NEXTW 
a233 c3 24 9c			jp macro_next 
a236				endm 
# End of macro NEXTW
a236			.DEPTH: 
a236				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a236 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a237 73 a2			dw .OVER            
a239 06				db 5 + 1 
a23a .. 00			db "DEPTH",0              
a240				endm 
# End of macro CWHEAD
a240			; | DEPTH ( -- u ) Push count of stack | DONE 
a240					; take current TOS and remove from base value div by two to get count 
a240					if DEBUG_FORTH_WORDS_KEY 
a240						DMARK "DEP" 
a240 f5				push af  
a241 3a 55 a2			ld a, (.dmark)  
a244 32 c0 ee			ld (debug_mark),a  
a247 3a 56 a2			ld a, (.dmark+1)  
a24a 32 c1 ee			ld (debug_mark+1),a  
a24d 3a 57 a2			ld a, (.dmark+2)  
a250 32 c2 ee			ld (debug_mark+2),a  
a253 18 03			jr .pastdmark  
a255 ..			.dmark: db "DEP"  
a258 f1			.pastdmark: pop af  
a259			endm  
# End of macro DMARK
a259						CALLMONITOR 
a259 cd 2e 93			call break_point_state  
a25c				endm  
# End of macro CALLMONITOR
a25c					endif 
a25c			 
a25c			 
a25c 2a 93 ec			ld hl, (cli_data_sp) 
a25f 11 4d ea			ld de, cli_data_stack 
a262 ed 52			sbc hl,de 
a264				 
a264				; div by size of stack item 
a264			 
a264 5d				ld e,l 
a265 0e 03			ld c, 3 
a267 cd 4b 8a			call Div8 
a26a			 
a26a 6f				ld l,a 
a26b 26 00			ld h,0 
a26d			 
a26d				;srl h 
a26d				;rr l 
a26d			 
a26d cd bb 98				call forth_push_numhl 
a270					NEXTW 
a270 c3 24 9c			jp macro_next 
a273				endm 
# End of macro NEXTW
a273			.OVER: 
a273				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a273 42				db WORD_SYS_CORE+46             
a274 ba a2			dw .PAUSE            
a276 05				db 4 + 1 
a277 .. 00			db "OVER",0              
a27c				endm 
# End of macro CWHEAD
a27c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a27c					if DEBUG_FORTH_WORDS_KEY 
a27c						DMARK "OVR" 
a27c f5				push af  
a27d 3a 91 a2			ld a, (.dmark)  
a280 32 c0 ee			ld (debug_mark),a  
a283 3a 92 a2			ld a, (.dmark+1)  
a286 32 c1 ee			ld (debug_mark+1),a  
a289 3a 93 a2			ld a, (.dmark+2)  
a28c 32 c2 ee			ld (debug_mark+2),a  
a28f 18 03			jr .pastdmark  
a291 ..			.dmark: db "OVR"  
a294 f1			.pastdmark: pop af  
a295			endm  
# End of macro DMARK
a295						CALLMONITOR 
a295 cd 2e 93			call break_point_state  
a298				endm  
# End of macro CALLMONITOR
a298					endif 
a298			 
a298					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a298 cd b2 9a			call macro_dsp_valuehl 
a29b				endm 
# End of macro FORTH_DSP_VALUEHL
a29b e5					push hl    ; n2 
a29c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a29c cd 6a 9b			call macro_forth_dsp_pop 
a29f				endm 
# End of macro FORTH_DSP_POP
a29f			 
a29f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a29f cd b2 9a			call macro_dsp_valuehl 
a2a2				endm 
# End of macro FORTH_DSP_VALUEHL
a2a2 e5					push hl    ; n1 
a2a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2a3 cd 6a 9b			call macro_forth_dsp_pop 
a2a6				endm 
# End of macro FORTH_DSP_POP
a2a6			 
a2a6 d1					pop de     ; n1 
a2a7 e1					pop hl     ; n2 
a2a8			 
a2a8 d5					push de 
a2a9 e5					push hl 
a2aa d5					push de 
a2ab			 
a2ab					; push back  
a2ab			 
a2ab e1					pop hl 
a2ac cd bb 98				call forth_push_numhl 
a2af e1					pop hl 
a2b0 cd bb 98				call forth_push_numhl 
a2b3 e1					pop hl 
a2b4 cd bb 98				call forth_push_numhl 
a2b7					NEXTW 
a2b7 c3 24 9c			jp macro_next 
a2ba				endm 
# End of macro NEXTW
a2ba			 
a2ba			.PAUSE: 
a2ba				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a2ba 43				db WORD_SYS_CORE+47             
a2bb ef a2			dw .PAUSES            
a2bd 08				db 7 + 1 
a2be .. 00			db "PAUSEMS",0              
a2c6				endm 
# End of macro CWHEAD
a2c6			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a2c6					if DEBUG_FORTH_WORDS_KEY 
a2c6						DMARK "PMS" 
a2c6 f5				push af  
a2c7 3a db a2			ld a, (.dmark)  
a2ca 32 c0 ee			ld (debug_mark),a  
a2cd 3a dc a2			ld a, (.dmark+1)  
a2d0 32 c1 ee			ld (debug_mark+1),a  
a2d3 3a dd a2			ld a, (.dmark+2)  
a2d6 32 c2 ee			ld (debug_mark+2),a  
a2d9 18 03			jr .pastdmark  
a2db ..			.dmark: db "PMS"  
a2de f1			.pastdmark: pop af  
a2df			endm  
# End of macro DMARK
a2df						CALLMONITOR 
a2df cd 2e 93			call break_point_state  
a2e2				endm  
# End of macro CALLMONITOR
a2e2					endif 
a2e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2e2 cd b2 9a			call macro_dsp_valuehl 
a2e5				endm 
# End of macro FORTH_DSP_VALUEHL
a2e5			;		push hl    ; n2 
a2e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2e5 cd 6a 9b			call macro_forth_dsp_pop 
a2e8				endm 
# End of macro FORTH_DSP_POP
a2e8			;		pop hl 
a2e8			 
a2e8 7d					ld a, l 
a2e9 cd f3 87				call aDelayInMS 
a2ec				       NEXTW 
a2ec c3 24 9c			jp macro_next 
a2ef				endm 
# End of macro NEXTW
a2ef			.PAUSES:  
a2ef				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a2ef 44				db WORD_SYS_CORE+48             
a2f0 5e a3			dw .ROT            
a2f2 06				db 5 + 1 
a2f3 .. 00			db "PAUSE",0              
a2f9				endm 
# End of macro CWHEAD
a2f9			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a2f9					if DEBUG_FORTH_WORDS_KEY 
a2f9						DMARK "PAU" 
a2f9 f5				push af  
a2fa 3a 0e a3			ld a, (.dmark)  
a2fd 32 c0 ee			ld (debug_mark),a  
a300 3a 0f a3			ld a, (.dmark+1)  
a303 32 c1 ee			ld (debug_mark+1),a  
a306 3a 10 a3			ld a, (.dmark+2)  
a309 32 c2 ee			ld (debug_mark+2),a  
a30c 18 03			jr .pastdmark  
a30e ..			.dmark: db "PAU"  
a311 f1			.pastdmark: pop af  
a312			endm  
# End of macro DMARK
a312						CALLMONITOR 
a312 cd 2e 93			call break_point_state  
a315				endm  
# End of macro CALLMONITOR
a315					endif 
a315					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a315 cd b2 9a			call macro_dsp_valuehl 
a318				endm 
# End of macro FORTH_DSP_VALUEHL
a318			;		push hl    ; n2 
a318					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a318 cd 6a 9b			call macro_forth_dsp_pop 
a31b				endm 
# End of macro FORTH_DSP_POP
a31b			;		pop hl 
a31b 45					ld b, l 
a31c					if DEBUG_FORTH_WORDS 
a31c						DMARK "PAU" 
a31c f5				push af  
a31d 3a 31 a3			ld a, (.dmark)  
a320 32 c0 ee			ld (debug_mark),a  
a323 3a 32 a3			ld a, (.dmark+1)  
a326 32 c1 ee			ld (debug_mark+1),a  
a329 3a 33 a3			ld a, (.dmark+2)  
a32c 32 c2 ee			ld (debug_mark+2),a  
a32f 18 03			jr .pastdmark  
a331 ..			.dmark: db "PAU"  
a334 f1			.pastdmark: pop af  
a335			endm  
# End of macro DMARK
a335						CALLMONITOR 
a335 cd 2e 93			call break_point_state  
a338				endm  
# End of macro CALLMONITOR
a338					endif 
a338 c5			.pauses1:	push bc 
a339 cd 0e 88				call delay1s 
a33c c1					pop bc 
a33d					if DEBUG_FORTH_WORDS 
a33d						DMARK "PA1" 
a33d f5				push af  
a33e 3a 52 a3			ld a, (.dmark)  
a341 32 c0 ee			ld (debug_mark),a  
a344 3a 53 a3			ld a, (.dmark+1)  
a347 32 c1 ee			ld (debug_mark+1),a  
a34a 3a 54 a3			ld a, (.dmark+2)  
a34d 32 c2 ee			ld (debug_mark+2),a  
a350 18 03			jr .pastdmark  
a352 ..			.dmark: db "PA1"  
a355 f1			.pastdmark: pop af  
a356			endm  
# End of macro DMARK
a356						CALLMONITOR 
a356 cd 2e 93			call break_point_state  
a359				endm  
# End of macro CALLMONITOR
a359					endif 
a359 10 dd				djnz .pauses1 
a35b			 
a35b				       NEXTW 
a35b c3 24 9c			jp macro_next 
a35e				endm 
# End of macro NEXTW
a35e			.ROT: 
a35e				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a35e 45				db WORD_SYS_CORE+49             
a35f ac a3			dw .UWORDS            
a361 04				db 3 + 1 
a362 .. 00			db "ROT",0              
a366				endm 
# End of macro CWHEAD
a366			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a366					if DEBUG_FORTH_WORDS_KEY 
a366						DMARK "ROT" 
a366 f5				push af  
a367 3a 7b a3			ld a, (.dmark)  
a36a 32 c0 ee			ld (debug_mark),a  
a36d 3a 7c a3			ld a, (.dmark+1)  
a370 32 c1 ee			ld (debug_mark+1),a  
a373 3a 7d a3			ld a, (.dmark+2)  
a376 32 c2 ee			ld (debug_mark+2),a  
a379 18 03			jr .pastdmark  
a37b ..			.dmark: db "ROT"  
a37e f1			.pastdmark: pop af  
a37f			endm  
# End of macro DMARK
a37f						CALLMONITOR 
a37f cd 2e 93			call break_point_state  
a382				endm  
# End of macro CALLMONITOR
a382					endif 
a382			 
a382					FORTH_DSP_VALUEHL 
a382 cd b2 9a			call macro_dsp_valuehl 
a385				endm 
# End of macro FORTH_DSP_VALUEHL
a385 e5					push hl    ; u3  
a386			 
a386					FORTH_DSP_POP 
a386 cd 6a 9b			call macro_forth_dsp_pop 
a389				endm 
# End of macro FORTH_DSP_POP
a389			   
a389					FORTH_DSP_VALUEHL 
a389 cd b2 9a			call macro_dsp_valuehl 
a38c				endm 
# End of macro FORTH_DSP_VALUEHL
a38c e5					push hl     ; u2 
a38d			 
a38d					FORTH_DSP_POP 
a38d cd 6a 9b			call macro_forth_dsp_pop 
a390				endm 
# End of macro FORTH_DSP_POP
a390			 
a390					FORTH_DSP_VALUEHL 
a390 cd b2 9a			call macro_dsp_valuehl 
a393				endm 
# End of macro FORTH_DSP_VALUEHL
a393 e5					push hl     ; u1 
a394			 
a394					FORTH_DSP_POP 
a394 cd 6a 9b			call macro_forth_dsp_pop 
a397				endm 
# End of macro FORTH_DSP_POP
a397			 
a397 c1					pop bc      ; u1 
a398 e1					pop hl      ; u2 
a399 d1					pop de      ; u3 
a39a			 
a39a			 
a39a c5					push bc 
a39b d5					push de 
a39c e5					push hl 
a39d			 
a39d			 
a39d e1					pop hl 
a39e cd bb 98				call forth_push_numhl 
a3a1			 
a3a1 e1					pop hl 
a3a2 cd bb 98				call forth_push_numhl 
a3a5			 
a3a5 e1					pop hl 
a3a6 cd bb 98				call forth_push_numhl 
a3a9					 
a3a9			 
a3a9			 
a3a9			 
a3a9			 
a3a9			 
a3a9				       NEXTW 
a3a9 c3 24 9c			jp macro_next 
a3ac				endm 
# End of macro NEXTW
a3ac			 
a3ac			.UWORDS: 
a3ac				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a3ac 50				db WORD_SYS_CORE+60             
a3ad 6e a4			dw .BP            
a3af 07				db 6 + 1 
a3b0 .. 00			db "UWORDS",0              
a3b7				endm 
# End of macro CWHEAD
a3b7			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a3b7			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a3b7			; | | Following the count are the individual words. 
a3b7			; | | 
a3b7			; | | e.g. UWORDS 
a3b7			; | | BOX DIRLIST 2 
a3b7			; | |  
a3b7			; | | Can be used to save the words to storage via: 
a3b7			; | | UWORDS $01 DO $01 APPEND LOOP 
a3b7				if DEBUG_FORTH_WORDS_KEY 
a3b7					DMARK "UWR" 
a3b7 f5				push af  
a3b8 3a cc a3			ld a, (.dmark)  
a3bb 32 c0 ee			ld (debug_mark),a  
a3be 3a cd a3			ld a, (.dmark+1)  
a3c1 32 c1 ee			ld (debug_mark+1),a  
a3c4 3a ce a3			ld a, (.dmark+2)  
a3c7 32 c2 ee			ld (debug_mark+2),a  
a3ca 18 03			jr .pastdmark  
a3cc ..			.dmark: db "UWR"  
a3cf f1			.pastdmark: pop af  
a3d0			endm  
# End of macro DMARK
a3d0					CALLMONITOR 
a3d0 cd 2e 93			call break_point_state  
a3d3				endm  
# End of macro CALLMONITOR
a3d3				endif 
a3d3 21 75 d7				ld hl, baseram 
a3d6					;ld hl, baseusermem 
a3d6 01 00 00				ld bc, 0    ; start a counter 
a3d9			 
a3d9				; skip dict stub 
a3d9			 
a3d9 cd 75 9d				call forth_tok_next 
a3dc			 
a3dc			 
a3dc			; while we have words to look for 
a3dc			 
a3dc 7e			.douscan:	ld a, (hl)      
a3dd				if DEBUG_FORTH_WORDS 
a3dd					DMARK "UWs" 
a3dd f5				push af  
a3de 3a f2 a3			ld a, (.dmark)  
a3e1 32 c0 ee			ld (debug_mark),a  
a3e4 3a f3 a3			ld a, (.dmark+1)  
a3e7 32 c1 ee			ld (debug_mark+1),a  
a3ea 3a f4 a3			ld a, (.dmark+2)  
a3ed 32 c2 ee			ld (debug_mark+2),a  
a3f0 18 03			jr .pastdmark  
a3f2 ..			.dmark: db "UWs"  
a3f5 f1			.pastdmark: pop af  
a3f6			endm  
# End of macro DMARK
a3f6					CALLMONITOR 
a3f6 cd 2e 93			call break_point_state  
a3f9				endm  
# End of macro CALLMONITOR
a3f9				endif 
a3f9 fe 00				cp WORD_SYS_END 
a3fb 28 4d				jr z, .udone 
a3fd fe 01				cp WORD_SYS_UWORD 
a3ff 20 44				jr nz, .nuword 
a401			 
a401				if DEBUG_FORTH_WORDS 
a401					DMARK "UWu" 
a401 f5				push af  
a402 3a 16 a4			ld a, (.dmark)  
a405 32 c0 ee			ld (debug_mark),a  
a408 3a 17 a4			ld a, (.dmark+1)  
a40b 32 c1 ee			ld (debug_mark+1),a  
a40e 3a 18 a4			ld a, (.dmark+2)  
a411 32 c2 ee			ld (debug_mark+2),a  
a414 18 03			jr .pastdmark  
a416 ..			.dmark: db "UWu"  
a419 f1			.pastdmark: pop af  
a41a			endm  
# End of macro DMARK
a41a					CALLMONITOR 
a41a cd 2e 93			call break_point_state  
a41d				endm  
# End of macro CALLMONITOR
a41d				endif 
a41d					; we have a uword so push its name to the stack 
a41d			 
a41d e5				   	push hl  ; save so we can move to next dict block 
a41e			 
a41e					; skip opcode 
a41e 23					inc hl  
a41f					; skip next ptr 
a41f 23					inc hl  
a420 23					inc hl 
a421					; skip len 
a421 23					inc hl 
a422				if DEBUG_FORTH_WORDS 
a422					DMARK "UWt" 
a422 f5				push af  
a423 3a 37 a4			ld a, (.dmark)  
a426 32 c0 ee			ld (debug_mark),a  
a429 3a 38 a4			ld a, (.dmark+1)  
a42c 32 c1 ee			ld (debug_mark+1),a  
a42f 3a 39 a4			ld a, (.dmark+2)  
a432 32 c2 ee			ld (debug_mark+2),a  
a435 18 03			jr .pastdmark  
a437 ..			.dmark: db "UWt"  
a43a f1			.pastdmark: pop af  
a43b			endm  
# End of macro DMARK
a43b					CALLMONITOR 
a43b cd 2e 93			call break_point_state  
a43e				endm  
# End of macro CALLMONITOR
a43e				endif 
a43e 03					inc bc 
a43f			 
a43f c5					push bc 
a440 cd 29 99				call forth_push_str 
a443 c1					pop bc 
a444			 
a444 e1					pop hl 	 
a445			 
a445 cd 75 9d		.nuword:	call forth_tok_next 
a448 18 92				jr .douscan  
a44a			 
a44a			.udone:		 ; push count of uwords found 
a44a c5					push bc 
a44b e1					pop hl 
a44c			 
a44c				if DEBUG_FORTH_WORDS 
a44c					DMARK "UWc" 
a44c f5				push af  
a44d 3a 61 a4			ld a, (.dmark)  
a450 32 c0 ee			ld (debug_mark),a  
a453 3a 62 a4			ld a, (.dmark+1)  
a456 32 c1 ee			ld (debug_mark+1),a  
a459 3a 63 a4			ld a, (.dmark+2)  
a45c 32 c2 ee			ld (debug_mark+2),a  
a45f 18 03			jr .pastdmark  
a461 ..			.dmark: db "UWc"  
a464 f1			.pastdmark: pop af  
a465			endm  
# End of macro DMARK
a465					CALLMONITOR 
a465 cd 2e 93			call break_point_state  
a468				endm  
# End of macro CALLMONITOR
a468				endif 
a468 cd bb 98				call forth_push_numhl 
a46b			 
a46b			 
a46b				       NEXTW 
a46b c3 24 9c			jp macro_next 
a46e				endm 
# End of macro NEXTW
a46e			 
a46e			.BP: 
a46e				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a46e 54				db WORD_SYS_CORE+64             
a46f a4 a4			dw .MONITOR            
a471 03				db 2 + 1 
a472 .. 00			db "BP",0              
a475				endm 
# End of macro CWHEAD
a475			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a475			; | | $00 Will enable the break points within specific code paths 
a475			; | | $01 Will disable break points 
a475			; | |  
a475			; | | By default break points are off. Either the above can be used to enable them 
a475			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a475			; | | and on release of the pressed key a message will be disaplayed to notify 
a475			; | | that break points are enabled. Pressing any key will then continue boot process. 
a475					; get byte count 
a475					if DEBUG_FORTH_WORDS_KEY 
a475						DMARK "BP." 
a475 f5				push af  
a476 3a 8a a4			ld a, (.dmark)  
a479 32 c0 ee			ld (debug_mark),a  
a47c 3a 8b a4			ld a, (.dmark+1)  
a47f 32 c1 ee			ld (debug_mark+1),a  
a482 3a 8c a4			ld a, (.dmark+2)  
a485 32 c2 ee			ld (debug_mark+2),a  
a488 18 03			jr .pastdmark  
a48a ..			.dmark: db "BP."  
a48d f1			.pastdmark: pop af  
a48e			endm  
# End of macro DMARK
a48e						CALLMONITOR 
a48e cd 2e 93			call break_point_state  
a491				endm  
# End of macro CALLMONITOR
a491					endif 
a491			 
a491					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a491 cd b2 9a			call macro_dsp_valuehl 
a494				endm 
# End of macro FORTH_DSP_VALUEHL
a494			 
a494			;		push hl 
a494			 
a494					; destroy value TOS 
a494			 
a494					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a494 cd 6a 9b			call macro_forth_dsp_pop 
a497				endm 
# End of macro FORTH_DSP_POP
a497			 
a497			;		pop hl 
a497			 
a497 3e 00				ld a,0 
a499 bd					cp l 
a49a 28 02				jr z, .bpset 
a49c 3e 2a				ld a, '*' 
a49e			 
a49e 32 d7 e4		.bpset:		ld (os_view_disable), a 
a4a1			 
a4a1			 
a4a1					NEXTW 
a4a1 c3 24 9c			jp macro_next 
a4a4				endm 
# End of macro NEXTW
a4a4			 
a4a4			 
a4a4			.MONITOR: 
a4a4				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a4a4 55				db WORD_SYS_CORE+65             
a4a5 d7 a4			dw .MALLOC            
a4a7 08				db 7 + 1 
a4a8 .. 00			db "MONITOR",0              
a4b0				endm 
# End of macro CWHEAD
a4b0			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a4b0			; | | At start the current various registers will be displayed with contents. 
a4b0			; | | Top right corner will show the most recent debug marker seen. 
a4b0			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a4b0			; | | and the return stack pointer (RSP). 
a4b0			; | | Pressing: 
a4b0			; | |    1 - Initial screen 
a4b0			; | |    2 - Display a data dump of HL 
a4b0			; | |    3 - Display a data dump of DE 
a4b0			; | |    4 - Display a data dump of BC 
a4b0			; | |    5 - Display a data dump of HL 
a4b0			; | |    6 - Display a data dump of DSP 
a4b0			; | |    7 - Display a data dump of RSP 
a4b0			; | |    8 - Display a data dump of what is at DSP 
a4b0			; | |    9 - Display a data dump of what is at RSP 
a4b0			; | |    0 - Exit monitor and continue running. This will also enable break points 
a4b0			; | |    * - Disable break points 
a4b0			; | |    # - Enter traditional monitor mode 
a4b0			; | | 
a4b0			; | | Monitor Mode 
a4b0			; | | ------------ 
a4b0			; | | A prompt of '>' will be shown for various commands: 
a4b0			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a4b0			; | |    C - Continue display a data dump from the last set address 
a4b0			; | |    M xxxx - Set start of memory edit at address xx 
a4b0			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a4b0			; | |    Q - Return to previous 
a4b0					if DEBUG_FORTH_WORDS_KEY 
a4b0						DMARK "MON" 
a4b0 f5				push af  
a4b1 3a c5 a4			ld a, (.dmark)  
a4b4 32 c0 ee			ld (debug_mark),a  
a4b7 3a c6 a4			ld a, (.dmark+1)  
a4ba 32 c1 ee			ld (debug_mark+1),a  
a4bd 3a c7 a4			ld a, (.dmark+2)  
a4c0 32 c2 ee			ld (debug_mark+2),a  
a4c3 18 03			jr .pastdmark  
a4c5 ..			.dmark: db "MON"  
a4c8 f1			.pastdmark: pop af  
a4c9			endm  
# End of macro DMARK
a4c9						CALLMONITOR 
a4c9 cd 2e 93			call break_point_state  
a4cc				endm  
# End of macro CALLMONITOR
a4cc					endif 
a4cc 3e 00				ld a, 0 
a4ce 32 d7 e4				ld (os_view_disable), a 
a4d1			 
a4d1					CALLMONITOR 
a4d1 cd 2e 93			call break_point_state  
a4d4				endm  
# End of macro CALLMONITOR
a4d4			 
a4d4			;	call monitor 
a4d4			 
a4d4					NEXTW 
a4d4 c3 24 9c			jp macro_next 
a4d7				endm 
# End of macro NEXTW
a4d7			 
a4d7			 
a4d7			.MALLOC: 
a4d7				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a4d7 56				db WORD_SYS_CORE+66             
a4d8 00 a5			dw .MALLOC2            
a4da 06				db 5 + 1 
a4db .. 00			db "ALLOT",0              
a4e1				endm 
# End of macro CWHEAD
a4e1			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a4e1					if DEBUG_FORTH_WORDS_KEY 
a4e1						DMARK "ALL" 
a4e1 f5				push af  
a4e2 3a f6 a4			ld a, (.dmark)  
a4e5 32 c0 ee			ld (debug_mark),a  
a4e8 3a f7 a4			ld a, (.dmark+1)  
a4eb 32 c1 ee			ld (debug_mark+1),a  
a4ee 3a f8 a4			ld a, (.dmark+2)  
a4f1 32 c2 ee			ld (debug_mark+2),a  
a4f4 18 03			jr .pastdmark  
a4f6 ..			.dmark: db "ALL"  
a4f9 f1			.pastdmark: pop af  
a4fa			endm  
# End of macro DMARK
a4fa						CALLMONITOR 
a4fa cd 2e 93			call break_point_state  
a4fd				endm  
# End of macro CALLMONITOR
a4fd					endif 
a4fd c3 27 a5				jp .mallocc 
a500			.MALLOC2: 
a500				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a500 56				db WORD_SYS_CORE+66             
a501 3e a5			dw .FREE            
a503 07				db 6 + 1 
a504 .. 00			db "MALLOC",0              
a50b				endm 
# End of macro CWHEAD
a50b			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a50b					; get byte count 
a50b					if DEBUG_FORTH_WORDS_KEY 
a50b						DMARK "MAL" 
a50b f5				push af  
a50c 3a 20 a5			ld a, (.dmark)  
a50f 32 c0 ee			ld (debug_mark),a  
a512 3a 21 a5			ld a, (.dmark+1)  
a515 32 c1 ee			ld (debug_mark+1),a  
a518 3a 22 a5			ld a, (.dmark+2)  
a51b 32 c2 ee			ld (debug_mark+2),a  
a51e 18 03			jr .pastdmark  
a520 ..			.dmark: db "MAL"  
a523 f1			.pastdmark: pop af  
a524			endm  
# End of macro DMARK
a524						CALLMONITOR 
a524 cd 2e 93			call break_point_state  
a527				endm  
# End of macro CALLMONITOR
a527					endif 
a527			.mallocc: 
a527					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a527 cd b2 9a			call macro_dsp_valuehl 
a52a				endm 
# End of macro FORTH_DSP_VALUEHL
a52a			 
a52a			;		push hl 
a52a			 
a52a					; destroy value TOS 
a52a			 
a52a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a52a cd 6a 9b			call macro_forth_dsp_pop 
a52d				endm 
# End of macro FORTH_DSP_POP
a52d			 
a52d			;		pop hl 
a52d cd 82 8f				call malloc 
a530				if DEBUG_FORTH_MALLOC_GUARD 
a530 f5					push af 
a531 cd e4 8a				call ishlzero 
a534			;		ld a, l 
a534			;		add h 
a534			;		cp 0 
a534 f1					pop af 
a535					 
a535 cc 2a c4				call z,malloc_error 
a538				endif 
a538			 
a538 cd bb 98				call forth_push_numhl 
a53b					NEXTW 
a53b c3 24 9c			jp macro_next 
a53e				endm 
# End of macro NEXTW
a53e			 
a53e			.FREE: 
a53e				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a53e 57				db WORD_SYS_CORE+67             
a53f 6f a5			dw .LIST            
a541 05				db 4 + 1 
a542 .. 00			db "FREE",0              
a547				endm 
# End of macro CWHEAD
a547			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a547					if DEBUG_FORTH_WORDS_KEY 
a547						DMARK "FRE" 
a547 f5				push af  
a548 3a 5c a5			ld a, (.dmark)  
a54b 32 c0 ee			ld (debug_mark),a  
a54e 3a 5d a5			ld a, (.dmark+1)  
a551 32 c1 ee			ld (debug_mark+1),a  
a554 3a 5e a5			ld a, (.dmark+2)  
a557 32 c2 ee			ld (debug_mark+2),a  
a55a 18 03			jr .pastdmark  
a55c ..			.dmark: db "FRE"  
a55f f1			.pastdmark: pop af  
a560			endm  
# End of macro DMARK
a560						CALLMONITOR 
a560 cd 2e 93			call break_point_state  
a563				endm  
# End of macro CALLMONITOR
a563					endif 
a563					; get address 
a563			 
a563					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a563 cd b2 9a			call macro_dsp_valuehl 
a566				endm 
# End of macro FORTH_DSP_VALUEHL
a566			 
a566			;		push hl 
a566			 
a566					; destroy value TOS 
a566			 
a566					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a566 cd 6a 9b			call macro_forth_dsp_pop 
a569				endm 
# End of macro FORTH_DSP_POP
a569			 
a569			;		pop hl 
a569			if FORTH_ENABLE_MALLOCFREE 
a569 cd 4c 90				call free 
a56c			endif 
a56c					NEXTW 
a56c c3 24 9c			jp macro_next 
a56f				endm 
# End of macro NEXTW
a56f			.LIST: 
a56f				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a56f 5c				db WORD_SYS_CORE+72             
a570 4e a7			dw .FORGET            
a572 05				db 4 + 1 
a573 .. 00			db "LIST",0              
a578				endm 
# End of macro CWHEAD
a578			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a578			; | | The quoted word must be in upper case. 
a578				if DEBUG_FORTH_WORDS_KEY 
a578					DMARK "LST" 
a578 f5				push af  
a579 3a 8d a5			ld a, (.dmark)  
a57c 32 c0 ee			ld (debug_mark),a  
a57f 3a 8e a5			ld a, (.dmark+1)  
a582 32 c1 ee			ld (debug_mark+1),a  
a585 3a 8f a5			ld a, (.dmark+2)  
a588 32 c2 ee			ld (debug_mark+2),a  
a58b 18 03			jr .pastdmark  
a58d ..			.dmark: db "LST"  
a590 f1			.pastdmark: pop af  
a591			endm  
# End of macro DMARK
a591					CALLMONITOR 
a591 cd 2e 93			call break_point_state  
a594				endm  
# End of macro CALLMONITOR
a594				endif 
a594			 
a594					FORTH_DSP_VALUEHL 
a594 cd b2 9a			call macro_dsp_valuehl 
a597				endm 
# End of macro FORTH_DSP_VALUEHL
a597			 
a597 e5					push hl 
a598 c1					pop bc 
a599			 
a599			; Start format of scratch string 
a599			 
a599 21 e6 e4				ld hl, scratch 
a59c			 
a59c 3e 3a				ld a, ':' 
a59e 77					ld (hl),a 
a59f 23					inc hl 
a5a0 3e 20				ld a, ' ' 
a5a2 77					ld (hl), a 
a5a3			 
a5a3					; Get ptr to the word we need to look up 
a5a3			 
a5a3			;		FORTH_DSP_VALUEHL 
a5a3					;v5 FORTH_DSP_VALUE 
a5a3				; TODO type check 
a5a3			;		inc hl    ; Skip type check  
a5a3			;		push hl 
a5a3			;		ex de, hl    ; put into DE 
a5a3			 
a5a3			 
a5a3 21 75 d7				ld hl, baseram 
a5a6					;ld hl, baseusermem 
a5a6			 
a5a6 e5			push hl   ; sacreifical push 
a5a7			 
a5a7			.ldouscanm: 
a5a7 e1				pop hl 
a5a8			.ldouscan: 
a5a8				if DEBUG_FORTH_WORDS 
a5a8					DMARK "LSs" 
a5a8 f5				push af  
a5a9 3a bd a5			ld a, (.dmark)  
a5ac 32 c0 ee			ld (debug_mark),a  
a5af 3a be a5			ld a, (.dmark+1)  
a5b2 32 c1 ee			ld (debug_mark+1),a  
a5b5 3a bf a5			ld a, (.dmark+2)  
a5b8 32 c2 ee			ld (debug_mark+2),a  
a5bb 18 03			jr .pastdmark  
a5bd ..			.dmark: db "LSs"  
a5c0 f1			.pastdmark: pop af  
a5c1			endm  
# End of macro DMARK
a5c1					CALLMONITOR 
a5c1 cd 2e 93			call break_point_state  
a5c4				endm  
# End of macro CALLMONITOR
a5c4				endif 
a5c4				; skip dict stub 
a5c4 cd 75 9d				call forth_tok_next 
a5c7			 
a5c7			 
a5c7			; while we have words to look for 
a5c7			 
a5c7 7e				ld a, (hl)      
a5c8				if DEBUG_FORTH_WORDS 
a5c8					DMARK "LSk" 
a5c8 f5				push af  
a5c9 3a dd a5			ld a, (.dmark)  
a5cc 32 c0 ee			ld (debug_mark),a  
a5cf 3a de a5			ld a, (.dmark+1)  
a5d2 32 c1 ee			ld (debug_mark+1),a  
a5d5 3a df a5			ld a, (.dmark+2)  
a5d8 32 c2 ee			ld (debug_mark+2),a  
a5db 18 03			jr .pastdmark  
a5dd ..			.dmark: db "LSk"  
a5e0 f1			.pastdmark: pop af  
a5e1			endm  
# End of macro DMARK
a5e1					CALLMONITOR 
a5e1 cd 2e 93			call break_point_state  
a5e4				endm  
# End of macro CALLMONITOR
a5e4				endif 
a5e4 fe 00				cp WORD_SYS_END 
a5e6 ca 19 a7				jp z, .lunotfound 
a5e9 fe 01				cp WORD_SYS_UWORD 
a5eb c2 a8 a5				jp nz, .ldouscan 
a5ee			 
a5ee				if DEBUG_FORTH_WORDS 
a5ee					DMARK "LSu" 
a5ee f5				push af  
a5ef 3a 03 a6			ld a, (.dmark)  
a5f2 32 c0 ee			ld (debug_mark),a  
a5f5 3a 04 a6			ld a, (.dmark+1)  
a5f8 32 c1 ee			ld (debug_mark+1),a  
a5fb 3a 05 a6			ld a, (.dmark+2)  
a5fe 32 c2 ee			ld (debug_mark+2),a  
a601 18 03			jr .pastdmark  
a603 ..			.dmark: db "LSu"  
a606 f1			.pastdmark: pop af  
a607			endm  
# End of macro DMARK
a607					CALLMONITOR 
a607 cd 2e 93			call break_point_state  
a60a				endm  
# End of macro CALLMONITOR
a60a				endif 
a60a			 
a60a					; found a uword but is it the one we want... 
a60a			 
a60a c5					push bc     ; uword to find is on bc 
a60b d1					pop de 
a60c			 
a60c e5					push hl  ; to save the ptr 
a60d			 
a60d					; skip opcode 
a60d 23					inc hl  
a60e					; skip next ptr 
a60e 23					inc hl  
a60f 23					inc hl 
a610					; skip len 
a610 23					inc hl 
a611			 
a611				if DEBUG_FORTH_WORDS 
a611					DMARK "LSc" 
a611 f5				push af  
a612 3a 26 a6			ld a, (.dmark)  
a615 32 c0 ee			ld (debug_mark),a  
a618 3a 27 a6			ld a, (.dmark+1)  
a61b 32 c1 ee			ld (debug_mark+1),a  
a61e 3a 28 a6			ld a, (.dmark+2)  
a621 32 c2 ee			ld (debug_mark+2),a  
a624 18 03			jr .pastdmark  
a626 ..			.dmark: db "LSc"  
a629 f1			.pastdmark: pop af  
a62a			endm  
# End of macro DMARK
a62a					CALLMONITOR 
a62a cd 2e 93			call break_point_state  
a62d				endm  
# End of macro CALLMONITOR
a62d				endif 
a62d cd 51 8f				call strcmp 
a630 c2 a7 a5				jp nz, .ldouscanm 
a633				 
a633			 
a633			 
a633					; we have a uword so push its name to the stack 
a633			 
a633			;	   	push hl  ; save so we can move to next dict block 
a633 e1			pop hl 
a634			 
a634				if DEBUG_FORTH_WORDS 
a634					DMARK "LSm" 
a634 f5				push af  
a635 3a 49 a6			ld a, (.dmark)  
a638 32 c0 ee			ld (debug_mark),a  
a63b 3a 4a a6			ld a, (.dmark+1)  
a63e 32 c1 ee			ld (debug_mark+1),a  
a641 3a 4b a6			ld a, (.dmark+2)  
a644 32 c2 ee			ld (debug_mark+2),a  
a647 18 03			jr .pastdmark  
a649 ..			.dmark: db "LSm"  
a64c f1			.pastdmark: pop af  
a64d			endm  
# End of macro DMARK
a64d					CALLMONITOR 
a64d cd 2e 93			call break_point_state  
a650				endm  
# End of macro CALLMONITOR
a650				endif 
a650			 
a650					; skip opcode 
a650 23					inc hl  
a651					; skip next ptr 
a651 23					inc hl  
a652 23					inc hl 
a653					; skip len 
a653 7e					ld a, (hl)   ; save length to add 
a654				if DEBUG_FORTH_WORDS 
a654					DMARK "LS2" 
a654 f5				push af  
a655 3a 69 a6			ld a, (.dmark)  
a658 32 c0 ee			ld (debug_mark),a  
a65b 3a 6a a6			ld a, (.dmark+1)  
a65e 32 c1 ee			ld (debug_mark+1),a  
a661 3a 6b a6			ld a, (.dmark+2)  
a664 32 c2 ee			ld (debug_mark+2),a  
a667 18 03			jr .pastdmark  
a669 ..			.dmark: db "LS2"  
a66c f1			.pastdmark: pop af  
a66d			endm  
# End of macro DMARK
a66d					CALLMONITOR 
a66d cd 2e 93			call break_point_state  
a670				endm  
# End of macro CALLMONITOR
a670				endif 
a670			 
a670					; save this location 
a670				 
a670 e5					push hl 
a671			 
a671 23					inc hl 
a672 11 e8 e4				ld de, scratch+2 
a675 4f					ld c, a 
a676 06 00				ld b, 0 
a678			 
a678				if DEBUG_FORTH_WORDS 
a678					DMARK "LSn" 
a678 f5				push af  
a679 3a 8d a6			ld a, (.dmark)  
a67c 32 c0 ee			ld (debug_mark),a  
a67f 3a 8e a6			ld a, (.dmark+1)  
a682 32 c1 ee			ld (debug_mark+1),a  
a685 3a 8f a6			ld a, (.dmark+2)  
a688 32 c2 ee			ld (debug_mark+2),a  
a68b 18 03			jr .pastdmark  
a68d ..			.dmark: db "LSn"  
a690 f1			.pastdmark: pop af  
a691			endm  
# End of macro DMARK
a691					CALLMONITOR 
a691 cd 2e 93			call break_point_state  
a694				endm  
# End of macro CALLMONITOR
a694				endif 
a694			 
a694					; copy uword name to scratch 
a694			 
a694 ed b0				ldir 
a696			 
a696 1b					dec de 
a697 3e 20				ld a, ' '    ; change null to space 
a699 12					ld (de), a 
a69a			 
a69a 13					inc de 
a69b			 
a69b d5					push de 
a69c c1					pop bc     ; move scratch pointer to end of word name and save it 
a69d			 
a69d e1					pop hl 
a69e 7e					ld a, (hl) 
a69f					;inc hl 
a69f					; skip word string 
a69f cd bb 8a				call addatohl 
a6a2			 
a6a2 23					inc hl 
a6a3			 
a6a3				if DEBUG_FORTH_WORDS 
a6a3					DMARK "LS3" 
a6a3 f5				push af  
a6a4 3a b8 a6			ld a, (.dmark)  
a6a7 32 c0 ee			ld (debug_mark),a  
a6aa 3a b9 a6			ld a, (.dmark+1)  
a6ad 32 c1 ee			ld (debug_mark+1),a  
a6b0 3a ba a6			ld a, (.dmark+2)  
a6b3 32 c2 ee			ld (debug_mark+2),a  
a6b6 18 03			jr .pastdmark  
a6b8 ..			.dmark: db "LS3"  
a6bb f1			.pastdmark: pop af  
a6bc			endm  
# End of macro DMARK
a6bc					CALLMONITOR 
a6bc cd 2e 93			call break_point_state  
a6bf				endm  
# End of macro CALLMONITOR
a6bf				endif 
a6bf					; should now be at the start of the machine code to setup the eval of the uword 
a6bf					; now locate the ptr to the string defintion 
a6bf			 
a6bf					; skip ld hl, 
a6bf					; then load the ptr 
a6bf			 
a6bf 23					inc hl 
a6c0 5e					ld e, (hl) 
a6c1 23					inc hl 
a6c2 56					ld d, (hl) 
a6c3 eb					ex de, hl 
a6c4			 
a6c4			 
a6c4				if DEBUG_FORTH_WORDS 
a6c4					DMARK "LSt" 
a6c4 f5				push af  
a6c5 3a d9 a6			ld a, (.dmark)  
a6c8 32 c0 ee			ld (debug_mark),a  
a6cb 3a da a6			ld a, (.dmark+1)  
a6ce 32 c1 ee			ld (debug_mark+1),a  
a6d1 3a db a6			ld a, (.dmark+2)  
a6d4 32 c2 ee			ld (debug_mark+2),a  
a6d7 18 03			jr .pastdmark  
a6d9 ..			.dmark: db "LSt"  
a6dc f1			.pastdmark: pop af  
a6dd			endm  
# End of macro DMARK
a6dd					CALLMONITOR 
a6dd cd 2e 93			call break_point_state  
a6e0				endm  
# End of macro CALLMONITOR
a6e0				endif 
a6e0			 
a6e0			; cant push right now due to tokenised strings  
a6e0			 
a6e0			; get the destination of where to copy this definition to. 
a6e0			 
a6e0 c5					push bc 
a6e1 d1					pop de 
a6e2			 
a6e2 7e			.listl:         ld a,(hl) 
a6e3 fe 00				cp 0 
a6e5 28 09				jr z, .lreplsp     ; replace zero with space 
a6e7 fe 7f				cp FORTH_END_BUFFER 
a6e9 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a6eb				 
a6eb					; just copy this char as is then 
a6eb			 
a6eb 12					ld (de), a 
a6ec			 
a6ec 23			.listnxt:	inc hl 
a6ed 13					inc de 
a6ee 18 f2				jr .listl 
a6f0			 
a6f0 3e 20		.lreplsp:	ld a,' ' 
a6f2 12					ld (de), a 
a6f3 18 f7				jr .listnxt 
a6f5			 
a6f5			; close up uword def 
a6f5			 
a6f5			.listdone: 
a6f5 3e 00				ld a, 0 
a6f7 12					ld (de), a 
a6f8			 
a6f8			; now have def so clean up and push to stack 
a6f8			 
a6f8 21 e6 e4				ld hl, scratch 
a6fb				if DEBUG_FORTH_WORDS 
a6fb					DMARK "Ltp" 
a6fb f5				push af  
a6fc 3a 10 a7			ld a, (.dmark)  
a6ff 32 c0 ee			ld (debug_mark),a  
a702 3a 11 a7			ld a, (.dmark+1)  
a705 32 c1 ee			ld (debug_mark+1),a  
a708 3a 12 a7			ld a, (.dmark+2)  
a70b 32 c2 ee			ld (debug_mark+2),a  
a70e 18 03			jr .pastdmark  
a710 ..			.dmark: db "Ltp"  
a713 f1			.pastdmark: pop af  
a714			endm  
# End of macro DMARK
a714					CALLMONITOR 
a714 cd 2e 93			call break_point_state  
a717				endm  
# End of macro CALLMONITOR
a717				endif 
a717			 
a717 18 22			jr .listpush 
a719			 
a719			;.lnuword:	pop hl 
a719			;		call forth_tok_next 
a719			;		jp .ldouscan  
a719			 
a719			.lunotfound:		  
a719			 
a719				if DEBUG_FORTH_WORDS 
a719					DMARK "LSn" 
a719 f5				push af  
a71a 3a 2e a7			ld a, (.dmark)  
a71d 32 c0 ee			ld (debug_mark),a  
a720 3a 2f a7			ld a, (.dmark+1)  
a723 32 c1 ee			ld (debug_mark+1),a  
a726 3a 30 a7			ld a, (.dmark+2)  
a729 32 c2 ee			ld (debug_mark+2),a  
a72c 18 03			jr .pastdmark  
a72e ..			.dmark: db "LSn"  
a731 f1			.pastdmark: pop af  
a732			endm  
# End of macro DMARK
a732					CALLMONITOR 
a732 cd 2e 93			call break_point_state  
a735				endm  
# End of macro CALLMONITOR
a735				endif 
a735			 
a735					 
a735					FORTH_DSP_POP 
a735 cd 6a 9b			call macro_forth_dsp_pop 
a738				endm 
# End of macro FORTH_DSP_POP
a738 21 41 a7				ld hl, .luno 
a73b						 
a73b			 
a73b			.listpush: 
a73b cd 29 99				call forth_push_str 
a73e			 
a73e			 
a73e			 
a73e					NEXTW 
a73e c3 24 9c			jp macro_next 
a741				endm 
# End of macro NEXTW
a741			 
a741 .. 00		.luno:    db "Not found",0 
a74b			 
a74b			 
a74b			 
a74b			 
a74b			 
a74b			;		push hl   ; save pointer to start of uword def string 
a74b			; 
a74b			;; look for FORTH_EOL_LINE 
a74b			;		ld a, FORTH_END_BUFFER 
a74b			;		call strlent 
a74b			; 
a74b			;		inc hl		 ; space for coln def 
a74b			;		inc hl 
a74b			;		inc hl          ; space for terms 
a74b			;		inc hl 
a74b			; 
a74b			;		ld a, 20   ; TODO get actual length 
a74b			;		call addatohl    ; include a random amount of room for the uword name 
a74b			; 
a74b			;		 
a74b			;	if DEBUG_FORTH_WORDS 
a74b			;		DMARK "Lt1" 
a74b			;		CALLMONITOR 
a74b			;	endif 
a74b			;		 
a74b			; 
a74b			;; malloc space for the string because we cant change it 
a74b			; 
a74b			;		call malloc 
a74b			;	if DEBUG_FORTH_MALLOC_GUARD 
a74b			;		push af 
a74b			;		call ishlzero 
a74b			;		pop af 
a74b			;		 
a74b			;		call z,malloc_error 
a74b			;	endif 
a74b			; 
a74b			;	if DEBUG_FORTH_WORDS 
a74b			;		DMARK "Lt2" 
a74b			;		CALLMONITOR 
a74b			;	endif 
a74b			;		pop de 
a74b			;		push hl    ; push the malloc to release later 
a74b			;		push hl   ;  push back a copy for the later stack push 
a74b			;		 
a74b			;; copy the string swapping out the zero terms for spaces 
a74b			; 
a74b			;		; de has our source 
a74b			;		; hl has our dest 
a74b			; 
a74b			;; add the coln def 
a74b			; 
a74b			;		ld a, ':' 
a74b			;		ld (hl), a 
a74b			;		inc hl 
a74b			;		ld a, ' ' 
a74b			;		ld (hl), a 
a74b			;		inc hl 
a74b			; 
a74b			;; add the uname word 
a74b			;		push de   ; save our string for now 
a74b			;		ex de, hl 
a74b			; 
a74b			;		FORTH_DSP_VALUE 
a74b			;		;v5 FORTH_DSP_VALUE 
a74b			; 
a74b			;		inc hl   ; skip type but we know by now this is OK 
a74b			; 
a74b			;.luword:	ld a,(hl) 
a74b			;		cp 0 
a74b			;		jr z, .luword2 
a74b			;		ld (de), a 
a74b			;		inc de 
a74b			;		inc hl 
a74b			;		jr .luword 
a74b			; 
a74b			;.luword2:	ld a, ' ' 
a74b			;		ld (de), a 
a74b			;;		inc hl 
a74b			;;		inc de 
a74b			;;		ld (de), a 
a74b			;;		inc hl 
a74b			;		inc de 
a74b			; 
a74b			;		ex de, hl 
a74b			;		pop de 
a74b			;		 
a74b			;		 
a74b			; 
a74b			;; detoken that string and copy it 
a74b			; 
a74b			;	if DEBUG_FORTH_WORDS 
a74b			;		DMARK "Lt2" 
a74b			;		CALLMONITOR 
a74b			;	endif 
a74b			;.ldetok:	ld a, (de) 
a74b			;		cp FORTH_END_BUFFER 
a74b			;		jr z, .ldetokend 
a74b			;		; swap out any zero term for space 
a74b			;		cp 0 
a74b			;		jr nz, .ldetoknext 
a74b			;		ld a, ' ' 
a74b			; 
a74b			;	if DEBUG_FORTH_WORDS 
a74b			;		DMARK "LtS" 
a74b			;		CALLMONITOR 
a74b			;	endif 
a74b			;.ldetoknext:	ld (hl), a 
a74b			;		inc de 
a74b			;		inc hl 
a74b			;		jr .ldetok 
a74b			; 
a74b			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a74b			;		ld (hl), a  
a74b			; 
a74b			;; free that temp malloc 
a74b			; 
a74b			;		pop hl    
a74b			; 
a74b			;	if DEBUG_FORTH_WORDS 
a74b			;		DMARK "Lt4" 
a74b			;		CALLMONITOR 
a74b			;	endif 
a74b			;		call forth_apushstrhl 
a74b			; 
a74b			;		; get rid of temp malloc area 
a74b			; 
a74b			;		pop hl 
a74b			;		call free 
a74b			; 
a74b			;		jr .ludone 
a74b			; 
a74b			;.lnuword:	pop hl 
a74b			;		call forth_tok_next 
a74b			;		jp .ldouscan  
a74b			; 
a74b			;.ludone:		 pop hl 
a74b			; 
a74b					NEXTW 
a74b c3 24 9c			jp macro_next 
a74e				endm 
# End of macro NEXTW
a74e			 
a74e			.FORGET: 
a74e				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a74e 5d				db WORD_SYS_CORE+73             
a74f c7 a7			dw .NOP            
a751 07				db 6 + 1 
a752 .. 00			db "FORGET",0              
a759				endm 
# End of macro CWHEAD
a759			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a759			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a759			; | |  
a759			; | | e.g. "MORE" forget 
a759					if DEBUG_FORTH_WORDS_KEY 
a759						DMARK "FRG" 
a759 f5				push af  
a75a 3a 6e a7			ld a, (.dmark)  
a75d 32 c0 ee			ld (debug_mark),a  
a760 3a 6f a7			ld a, (.dmark+1)  
a763 32 c1 ee			ld (debug_mark+1),a  
a766 3a 70 a7			ld a, (.dmark+2)  
a769 32 c2 ee			ld (debug_mark+2),a  
a76c 18 03			jr .pastdmark  
a76e ..			.dmark: db "FRG"  
a771 f1			.pastdmark: pop af  
a772			endm  
# End of macro DMARK
a772						CALLMONITOR 
a772 cd 2e 93			call break_point_state  
a775				endm  
# End of macro CALLMONITOR
a775					endif 
a775			 
a775				; find uword 
a775			        ; update start of word with "_" 
a775				; replace uword with deleted flag 
a775			 
a775			 
a775			;	if DEBUG_FORTH_WORDS 
a775			;		DMARK "FOG" 
a775			;		CALLMONITOR 
a775			;	endif 
a775			 
a775			 
a775					; Get ptr to the word we need to look up 
a775			 
a775					FORTH_DSP_VALUEHL 
a775 cd b2 9a			call macro_dsp_valuehl 
a778				endm 
# End of macro FORTH_DSP_VALUEHL
a778					;v5 FORTH_DSP_VALUE 
a778				; TODO type check 
a778			;		inc hl    ; Skip type check  
a778 e5					push hl 
a779 c1					pop bc 
a77a			;		ex de, hl    ; put into DE 
a77a			 
a77a			 
a77a 21 75 d7				ld hl, baseram 
a77d					;ld hl, baseusermem 
a77d			 
a77d				; skip dict stub 
a77d			;	call forth_tok_next 
a77d e5			push hl   ; sacreifical push 
a77e			 
a77e			.fldouscanm: 
a77e e1				pop hl 
a77f			.fldouscan: 
a77f			;	if DEBUG_FORTH_WORDS 
a77f			;		DMARK "LSs" 
a77f			;		CALLMONITOR 
a77f			;	endif 
a77f				; skip dict stub 
a77f cd 75 9d				call forth_tok_next 
a782			 
a782			 
a782			; while we have words to look for 
a782			 
a782 7e				ld a, (hl)      
a783			;	if DEBUG_FORTH_WORDS 
a783			;		DMARK "LSk" 
a783			;		CALLMONITOR 
a783			;	endif 
a783 fe 00				cp WORD_SYS_END 
a785 ca c1 a7				jp z, .flunotfound 
a788 fe 01				cp WORD_SYS_UWORD 
a78a c2 7f a7				jp nz, .fldouscan 
a78d			 
a78d			;	if DEBUG_FORTH_WORDS 
a78d			;		DMARK "LSu" 
a78d			;		CALLMONITOR 
a78d			;	endif 
a78d			 
a78d					; found a uword but is it the one we want... 
a78d			 
a78d c5					push bc     ; uword to find is on bc 
a78e d1					pop de 
a78f			 
a78f e5					push hl  ; to save the ptr 
a790			 
a790					; skip opcode 
a790 23					inc hl  
a791					; skip next ptr 
a791 23					inc hl  
a792 23					inc hl 
a793					; skip len 
a793 23					inc hl 
a794			 
a794			;	if DEBUG_FORTH_WORDS 
a794			;		DMARK "LSc" 
a794			;		CALLMONITOR 
a794			;	endif 
a794 cd 51 8f				call strcmp 
a797 c2 7e a7				jp nz, .fldouscanm 
a79a			; 
a79a			; 
a79a			;; while we have words to look for 
a79a			; 
a79a			;.fdouscan:	ld a, (hl)      
a79a			;	if DEBUG_FORTH_WORDS 
a79a			;		DMARK "LSs" 
a79a			;		CALLMONITOR 
a79a			;	endif 
a79a			;		cp WORD_SYS_END 
a79a			;		jp z, .fudone 
a79a			;		cp WORD_SYS_UWORD 
a79a			;		jp nz, .fnuword 
a79a			; 
a79a			;	if DEBUG_FORTH_WORDS 
a79a			;		DMARK "FGu" 
a79a			;		CALLMONITOR 
a79a			;	endif 
a79a			; 
a79a			;		; found a uword but is it the one we want... 
a79a			; 
a79a			; 
a79a			;	        pop de   ; get back the dsp name 
a79a			;		push de 
a79a			; 
a79a			;		push hl  ; to save the ptr 
a79a			; 
a79a			;		; skip opcode 
a79a			;		inc hl  
a79a			;		; skip next ptr 
a79a			;		inc hl  
a79a			;		inc hl 
a79a			;		; skip len 
a79a			;		inc hl 
a79a			; 
a79a			;	if DEBUG_FORTH_WORDS 
a79a			;		DMARK "FGc" 
a79a			;		CALLMONITOR 
a79a			;	endif 
a79a			;		call strcmp 
a79a			;		jp nz, .fnuword 
a79a			 
a79a			 
a79a e1			pop hl 
a79b			 
a79b				 
a79b				if DEBUG_FORTH_WORDS 
a79b					DMARK "FGm" 
a79b f5				push af  
a79c 3a b0 a7			ld a, (.dmark)  
a79f 32 c0 ee			ld (debug_mark),a  
a7a2 3a b1 a7			ld a, (.dmark+1)  
a7a5 32 c1 ee			ld (debug_mark+1),a  
a7a8 3a b2 a7			ld a, (.dmark+2)  
a7ab 32 c2 ee			ld (debug_mark+2),a  
a7ae 18 03			jr .pastdmark  
a7b0 ..			.dmark: db "FGm"  
a7b3 f1			.pastdmark: pop af  
a7b4			endm  
# End of macro DMARK
a7b4					CALLMONITOR 
a7b4 cd 2e 93			call break_point_state  
a7b7				endm  
# End of macro CALLMONITOR
a7b7				endif 
a7b7			 
a7b7			 
a7b7			 
a7b7					; we have a uword so push its name to the stack 
a7b7			 
a7b7			;	   	push hl  ; save so we can move to next dict block 
a7b7			;pop hl 
a7b7			 
a7b7					; update opcode to deleted 
a7b7 3e 03				ld a, WORD_SYS_DELETED 
a7b9 77					ld (hl), a 
a7ba			 
a7ba 23					inc hl  
a7bb					; skip next ptr 
a7bb 23					inc hl  
a7bc 23					inc hl 
a7bd					; skip len 
a7bd 23					inc hl 
a7be			 
a7be					; TODO change parser to skip deleted words but for now mark it out 
a7be 3e 5f				ld a, "_" 
a7c0 77					ld  (hl),a 
a7c1			 
a7c1			;		jr .fudone 
a7c1			; 
a7c1			;.fnuword:	pop hl 
a7c1			;		call forth_tok_next 
a7c1			;		jp .fdouscan  
a7c1			 
a7c1			.flunotfound:		  
a7c1			 
a7c1			 
a7c1					 
a7c1					FORTH_DSP_POP 
a7c1 cd 6a 9b			call macro_forth_dsp_pop 
a7c4				endm 
# End of macro FORTH_DSP_POP
a7c4			;		ld hl, .luno 
a7c4			;.fudone:		 pop hl 
a7c4					NEXTW 
a7c4 c3 24 9c			jp macro_next 
a7c7				endm 
# End of macro NEXTW
a7c7			.NOP: 
a7c7				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a7c7 61				db WORD_SYS_CORE+77             
a7c8 ee a7			dw .COMO            
a7ca 04				db 3 + 1 
a7cb .. 00			db "NOP",0              
a7cf				endm 
# End of macro CWHEAD
a7cf			; | NOP (  --  ) Do nothing | DONE 
a7cf					if DEBUG_FORTH_WORDS_KEY 
a7cf						DMARK "NOP" 
a7cf f5				push af  
a7d0 3a e4 a7			ld a, (.dmark)  
a7d3 32 c0 ee			ld (debug_mark),a  
a7d6 3a e5 a7			ld a, (.dmark+1)  
a7d9 32 c1 ee			ld (debug_mark+1),a  
a7dc 3a e6 a7			ld a, (.dmark+2)  
a7df 32 c2 ee			ld (debug_mark+2),a  
a7e2 18 03			jr .pastdmark  
a7e4 ..			.dmark: db "NOP"  
a7e7 f1			.pastdmark: pop af  
a7e8			endm  
# End of macro DMARK
a7e8						CALLMONITOR 
a7e8 cd 2e 93			call break_point_state  
a7eb				endm  
# End of macro CALLMONITOR
a7eb					endif 
a7eb				       NEXTW 
a7eb c3 24 9c			jp macro_next 
a7ee				endm 
# End of macro NEXTW
a7ee			.COMO: 
a7ee				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a7ee 6e				db WORD_SYS_CORE+90             
a7ef 40 a8			dw .COMC            
a7f1 02				db 1 + 1 
a7f2 .. 00			db "(",0              
a7f4				endm 
# End of macro CWHEAD
a7f4			; | ( ( -- )  Start of comment | DONE 
a7f4			 
a7f4			 
a7f4 2a e7 e7				ld hl, ( os_tok_ptr) 
a7f7 11 3b a8			ld de, .closepar 
a7fa					 
a7fa					if DEBUG_FORTH_WORDS 
a7fa						DMARK ").." 
a7fa f5				push af  
a7fb 3a 0f a8			ld a, (.dmark)  
a7fe 32 c0 ee			ld (debug_mark),a  
a801 3a 10 a8			ld a, (.dmark+1)  
a804 32 c1 ee			ld (debug_mark+1),a  
a807 3a 11 a8			ld a, (.dmark+2)  
a80a 32 c2 ee			ld (debug_mark+2),a  
a80d 18 03			jr .pastdmark  
a80f ..			.dmark: db ").."  
a812 f1			.pastdmark: pop af  
a813			endm  
# End of macro DMARK
a813						CALLMONITOR 
a813 cd 2e 93			call break_point_state  
a816				endm  
# End of macro CALLMONITOR
a816					endif 
a816 cd 3f 9d			call findnexttok  
a819			 
a819					if DEBUG_FORTH_WORDS 
a819						DMARK "IF5" 
a819 f5				push af  
a81a 3a 2e a8			ld a, (.dmark)  
a81d 32 c0 ee			ld (debug_mark),a  
a820 3a 2f a8			ld a, (.dmark+1)  
a823 32 c1 ee			ld (debug_mark+1),a  
a826 3a 30 a8			ld a, (.dmark+2)  
a829 32 c2 ee			ld (debug_mark+2),a  
a82c 18 03			jr .pastdmark  
a82e ..			.dmark: db "IF5"  
a831 f1			.pastdmark: pop af  
a832			endm  
# End of macro DMARK
a832						CALLMONITOR 
a832 cd 2e 93			call break_point_state  
a835				endm  
# End of macro CALLMONITOR
a835					endif 
a835				; replace below with ) exec using tok_ptr 
a835 22 e7 e7			ld (os_tok_ptr), hl 
a838 c3 b5 9c			jp exec1 
a83b			 
a83b .. 00			.closepar:   db ")",0 
a83d			 
a83d				       NEXTW 
a83d c3 24 9c			jp macro_next 
a840				endm 
# End of macro NEXTW
a840			.COMC: 
a840				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a840 6f				db WORD_SYS_CORE+91             
a841 49 a8			dw .SCRATCH            
a843 02				db 1 + 1 
a844 .. 00			db ")",0              
a846				endm 
# End of macro CWHEAD
a846			; | ) ( -- )  End of comment |  DONE  
a846				       NEXTW 
a846 c3 24 9c			jp macro_next 
a849				endm 
# End of macro NEXTW
a849			 
a849			.SCRATCH: 
a849				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a849 6f				db WORD_SYS_CORE+91             
a84a 84 a8			dw .INC            
a84c 08				db 7 + 1 
a84d .. 00			db "SCRATCH",0              
a855				endm 
# End of macro CWHEAD
a855			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a855			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a855			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a855			; | |  
a855			; | | e.g.    : score $00 scratch ; 
a855			; | |  
a855			; | | $00 score ! 
a855			; | | $01 score +! 
a855			; | |  
a855			; | | e.g.   : varword $0a scratch ;  
a855			; | | 
a855			; | | $8000 varword ! 
a855					if DEBUG_FORTH_WORDS_KEY 
a855						DMARK "SCR" 
a855 f5				push af  
a856 3a 6a a8			ld a, (.dmark)  
a859 32 c0 ee			ld (debug_mark),a  
a85c 3a 6b a8			ld a, (.dmark+1)  
a85f 32 c1 ee			ld (debug_mark+1),a  
a862 3a 6c a8			ld a, (.dmark+2)  
a865 32 c2 ee			ld (debug_mark+2),a  
a868 18 03			jr .pastdmark  
a86a ..			.dmark: db "SCR"  
a86d f1			.pastdmark: pop af  
a86e			endm  
# End of macro DMARK
a86e						CALLMONITOR 
a86e cd 2e 93			call break_point_state  
a871				endm  
# End of macro CALLMONITOR
a871					endif 
a871			 
a871					FORTH_DSP_VALUEHL 
a871 cd b2 9a			call macro_dsp_valuehl 
a874				endm 
# End of macro FORTH_DSP_VALUEHL
a874				 
a874					FORTH_DSP_POP 
a874 cd 6a 9b			call macro_forth_dsp_pop 
a877				endm 
# End of macro FORTH_DSP_POP
a877			 
a877 7d					ld a, l 
a878 21 0b ea				ld hl, os_var_array 
a87b cd bb 8a				call addatohl 
a87e			 
a87e cd bb 98				call forth_push_numhl 
a881			 
a881				       NEXTW 
a881 c3 24 9c			jp macro_next 
a884				endm 
# End of macro NEXTW
a884			 
a884			.INC: 
a884				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a884 6f				db WORD_SYS_CORE+91             
a885 d8 a8			dw .DEC            
a887 03				db 2 + 1 
a888 .. 00			db "+!",0              
a88b				endm 
# End of macro CWHEAD
a88b			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a88b					if DEBUG_FORTH_WORDS_KEY 
a88b						DMARK "+s_" 
a88b f5				push af  
a88c 3a a0 a8			ld a, (.dmark)  
a88f 32 c0 ee			ld (debug_mark),a  
a892 3a a1 a8			ld a, (.dmark+1)  
a895 32 c1 ee			ld (debug_mark+1),a  
a898 3a a2 a8			ld a, (.dmark+2)  
a89b 32 c2 ee			ld (debug_mark+2),a  
a89e 18 03			jr .pastdmark  
a8a0 ..			.dmark: db "+s_"  
a8a3 f1			.pastdmark: pop af  
a8a4			endm  
# End of macro DMARK
a8a4						CALLMONITOR 
a8a4 cd 2e 93			call break_point_state  
a8a7				endm  
# End of macro CALLMONITOR
a8a7					endif 
a8a7			 
a8a7					FORTH_DSP_VALUEHL 
a8a7 cd b2 9a			call macro_dsp_valuehl 
a8aa				endm 
# End of macro FORTH_DSP_VALUEHL
a8aa			 
a8aa e5					push hl   ; save address 
a8ab			 
a8ab					FORTH_DSP_POP 
a8ab cd 6a 9b			call macro_forth_dsp_pop 
a8ae				endm 
# End of macro FORTH_DSP_POP
a8ae			 
a8ae					FORTH_DSP_VALUEHL 
a8ae cd b2 9a			call macro_dsp_valuehl 
a8b1				endm 
# End of macro FORTH_DSP_VALUEHL
a8b1			 
a8b1					FORTH_DSP_POP 
a8b1 cd 6a 9b			call macro_forth_dsp_pop 
a8b4				endm 
# End of macro FORTH_DSP_POP
a8b4			 
a8b4					; hl contains value to add to byte at a 
a8b4				 
a8b4 eb					ex de, hl 
a8b5			 
a8b5 e1					pop hl 
a8b6			 
a8b6					if DEBUG_FORTH_WORDS 
a8b6						DMARK "INC" 
a8b6 f5				push af  
a8b7 3a cb a8			ld a, (.dmark)  
a8ba 32 c0 ee			ld (debug_mark),a  
a8bd 3a cc a8			ld a, (.dmark+1)  
a8c0 32 c1 ee			ld (debug_mark+1),a  
a8c3 3a cd a8			ld a, (.dmark+2)  
a8c6 32 c2 ee			ld (debug_mark+2),a  
a8c9 18 03			jr .pastdmark  
a8cb ..			.dmark: db "INC"  
a8ce f1			.pastdmark: pop af  
a8cf			endm  
# End of macro DMARK
a8cf						CALLMONITOR 
a8cf cd 2e 93			call break_point_state  
a8d2				endm  
# End of macro CALLMONITOR
a8d2					endif 
a8d2			 
a8d2 7e					ld a,(hl) 
a8d3 83					add e 
a8d4 77					ld (hl),a 
a8d5			 
a8d5			 
a8d5			 
a8d5				       NEXTW 
a8d5 c3 24 9c			jp macro_next 
a8d8				endm 
# End of macro NEXTW
a8d8			 
a8d8			.DEC: 
a8d8				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a8d8 6f				db WORD_SYS_CORE+91             
a8d9 29 a9			dw .INC2            
a8db 03				db 2 + 1 
a8dc .. 00			db "-!",0              
a8df				endm 
# End of macro CWHEAD
a8df			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a8df					if DEBUG_FORTH_WORDS_KEY 
a8df						DMARK "-s_" 
a8df f5				push af  
a8e0 3a f4 a8			ld a, (.dmark)  
a8e3 32 c0 ee			ld (debug_mark),a  
a8e6 3a f5 a8			ld a, (.dmark+1)  
a8e9 32 c1 ee			ld (debug_mark+1),a  
a8ec 3a f6 a8			ld a, (.dmark+2)  
a8ef 32 c2 ee			ld (debug_mark+2),a  
a8f2 18 03			jr .pastdmark  
a8f4 ..			.dmark: db "-s_"  
a8f7 f1			.pastdmark: pop af  
a8f8			endm  
# End of macro DMARK
a8f8						CALLMONITOR 
a8f8 cd 2e 93			call break_point_state  
a8fb				endm  
# End of macro CALLMONITOR
a8fb					endif 
a8fb			 
a8fb					FORTH_DSP_VALUEHL 
a8fb cd b2 9a			call macro_dsp_valuehl 
a8fe				endm 
# End of macro FORTH_DSP_VALUEHL
a8fe			 
a8fe e5					push hl   ; save address 
a8ff			 
a8ff					FORTH_DSP_POP 
a8ff cd 6a 9b			call macro_forth_dsp_pop 
a902				endm 
# End of macro FORTH_DSP_POP
a902			 
a902					FORTH_DSP_VALUEHL 
a902 cd b2 9a			call macro_dsp_valuehl 
a905				endm 
# End of macro FORTH_DSP_VALUEHL
a905			 
a905					; hl contains value to add to byte at a 
a905				 
a905 eb					ex de, hl 
a906			 
a906 e1					pop hl 
a907			 
a907					if DEBUG_FORTH_WORDS 
a907						DMARK "DEC" 
a907 f5				push af  
a908 3a 1c a9			ld a, (.dmark)  
a90b 32 c0 ee			ld (debug_mark),a  
a90e 3a 1d a9			ld a, (.dmark+1)  
a911 32 c1 ee			ld (debug_mark+1),a  
a914 3a 1e a9			ld a, (.dmark+2)  
a917 32 c2 ee			ld (debug_mark+2),a  
a91a 18 03			jr .pastdmark  
a91c ..			.dmark: db "DEC"  
a91f f1			.pastdmark: pop af  
a920			endm  
# End of macro DMARK
a920						CALLMONITOR 
a920 cd 2e 93			call break_point_state  
a923				endm  
# End of macro CALLMONITOR
a923					endif 
a923			 
a923 7e					ld a,(hl) 
a924 93					sub e 
a925 77					ld (hl),a 
a926			 
a926			 
a926			 
a926				       NEXTW 
a926 c3 24 9c			jp macro_next 
a929				endm 
# End of macro NEXTW
a929			 
a929			.INC2: 
a929				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a929 6f				db WORD_SYS_CORE+91             
a92a d3 a9			dw .DEC2            
a92c 04				db 3 + 1 
a92d .. 00			db "+2!",0              
a931				endm 
# End of macro CWHEAD
a931			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
a931			 
a931					if DEBUG_FORTH_WORDS_KEY 
a931						DMARK "+2s" 
a931 f5				push af  
a932 3a 46 a9			ld a, (.dmark)  
a935 32 c0 ee			ld (debug_mark),a  
a938 3a 47 a9			ld a, (.dmark+1)  
a93b 32 c1 ee			ld (debug_mark+1),a  
a93e 3a 48 a9			ld a, (.dmark+2)  
a941 32 c2 ee			ld (debug_mark+2),a  
a944 18 03			jr .pastdmark  
a946 ..			.dmark: db "+2s"  
a949 f1			.pastdmark: pop af  
a94a			endm  
# End of macro DMARK
a94a						CALLMONITOR 
a94a cd 2e 93			call break_point_state  
a94d				endm  
# End of macro CALLMONITOR
a94d					endif 
a94d			 
a94d					; Address 
a94d			 
a94d					FORTH_DSP_VALUEHL 
a94d cd b2 9a			call macro_dsp_valuehl 
a950				endm 
# End of macro FORTH_DSP_VALUEHL
a950			 
a950 e5					push hl    ; save address 
a951			 
a951					; load content into de 
a951			 
a951 5e					ld e,(hl) 
a952 23					inc hl 
a953 56					ld d, (hl) 
a954			 
a954					if DEBUG_FORTH_WORDS 
a954						DMARK "+2a" 
a954 f5				push af  
a955 3a 69 a9			ld a, (.dmark)  
a958 32 c0 ee			ld (debug_mark),a  
a95b 3a 6a a9			ld a, (.dmark+1)  
a95e 32 c1 ee			ld (debug_mark+1),a  
a961 3a 6b a9			ld a, (.dmark+2)  
a964 32 c2 ee			ld (debug_mark+2),a  
a967 18 03			jr .pastdmark  
a969 ..			.dmark: db "+2a"  
a96c f1			.pastdmark: pop af  
a96d			endm  
# End of macro DMARK
a96d						CALLMONITOR 
a96d cd 2e 93			call break_point_state  
a970				endm  
# End of macro CALLMONITOR
a970					endif 
a970			 
a970					FORTH_DSP_POP 
a970 cd 6a 9b			call macro_forth_dsp_pop 
a973				endm 
# End of macro FORTH_DSP_POP
a973			 
a973					; Get value to add 
a973			 
a973					FORTH_DSP_VALUE 
a973 cd 9b 9a			call macro_forth_dsp_value 
a976				endm 
# End of macro FORTH_DSP_VALUE
a976			 
a976					if DEBUG_FORTH_WORDS 
a976						DMARK "+2v" 
a976 f5				push af  
a977 3a 8b a9			ld a, (.dmark)  
a97a 32 c0 ee			ld (debug_mark),a  
a97d 3a 8c a9			ld a, (.dmark+1)  
a980 32 c1 ee			ld (debug_mark+1),a  
a983 3a 8d a9			ld a, (.dmark+2)  
a986 32 c2 ee			ld (debug_mark+2),a  
a989 18 03			jr .pastdmark  
a98b ..			.dmark: db "+2v"  
a98e f1			.pastdmark: pop af  
a98f			endm  
# End of macro DMARK
a98f						CALLMONITOR 
a98f cd 2e 93			call break_point_state  
a992				endm  
# End of macro CALLMONITOR
a992					endif 
a992			 
a992 19					add hl, de 
a993			 
a993					if DEBUG_FORTH_WORDS 
a993						DMARK "+2+" 
a993 f5				push af  
a994 3a a8 a9			ld a, (.dmark)  
a997 32 c0 ee			ld (debug_mark),a  
a99a 3a a9 a9			ld a, (.dmark+1)  
a99d 32 c1 ee			ld (debug_mark+1),a  
a9a0 3a aa a9			ld a, (.dmark+2)  
a9a3 32 c2 ee			ld (debug_mark+2),a  
a9a6 18 03			jr .pastdmark  
a9a8 ..			.dmark: db "+2+"  
a9ab f1			.pastdmark: pop af  
a9ac			endm  
# End of macro DMARK
a9ac						CALLMONITOR 
a9ac cd 2e 93			call break_point_state  
a9af				endm  
# End of macro CALLMONITOR
a9af					endif 
a9af			 
a9af					; move result to de 
a9af			 
a9af eb					ex de, hl 
a9b0			 
a9b0					; Address 
a9b0			 
a9b0 e1					pop hl 
a9b1			 
a9b1					; save it back 
a9b1			 
a9b1 73					ld (hl), e 
a9b2 23					inc hl 
a9b3 72					ld (hl), d 
a9b4			 
a9b4					if DEBUG_FORTH_WORDS 
a9b4						DMARK "+2e" 
a9b4 f5				push af  
a9b5 3a c9 a9			ld a, (.dmark)  
a9b8 32 c0 ee			ld (debug_mark),a  
a9bb 3a ca a9			ld a, (.dmark+1)  
a9be 32 c1 ee			ld (debug_mark+1),a  
a9c1 3a cb a9			ld a, (.dmark+2)  
a9c4 32 c2 ee			ld (debug_mark+2),a  
a9c7 18 03			jr .pastdmark  
a9c9 ..			.dmark: db "+2e"  
a9cc f1			.pastdmark: pop af  
a9cd			endm  
# End of macro DMARK
a9cd						CALLMONITOR 
a9cd cd 2e 93			call break_point_state  
a9d0				endm  
# End of macro CALLMONITOR
a9d0					endif 
a9d0			 
a9d0			 
a9d0			 
a9d0			 
a9d0			 
a9d0				       NEXTW 
a9d0 c3 24 9c			jp macro_next 
a9d3				endm 
# End of macro NEXTW
a9d3			 
a9d3			.DEC2: 
a9d3				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
a9d3 6f				db WORD_SYS_CORE+91             
a9d4 7f aa			dw .GET2            
a9d6 04				db 3 + 1 
a9d7 .. 00			db "-2!",0              
a9db				endm 
# End of macro CWHEAD
a9db			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
a9db			 
a9db			 
a9db					if DEBUG_FORTH_WORDS_KEY 
a9db						DMARK "-2s" 
a9db f5				push af  
a9dc 3a f0 a9			ld a, (.dmark)  
a9df 32 c0 ee			ld (debug_mark),a  
a9e2 3a f1 a9			ld a, (.dmark+1)  
a9e5 32 c1 ee			ld (debug_mark+1),a  
a9e8 3a f2 a9			ld a, (.dmark+2)  
a9eb 32 c2 ee			ld (debug_mark+2),a  
a9ee 18 03			jr .pastdmark  
a9f0 ..			.dmark: db "-2s"  
a9f3 f1			.pastdmark: pop af  
a9f4			endm  
# End of macro DMARK
a9f4						CALLMONITOR 
a9f4 cd 2e 93			call break_point_state  
a9f7				endm  
# End of macro CALLMONITOR
a9f7					endif 
a9f7			 
a9f7					; Address 
a9f7			 
a9f7					FORTH_DSP_VALUEHL 
a9f7 cd b2 9a			call macro_dsp_valuehl 
a9fa				endm 
# End of macro FORTH_DSP_VALUEHL
a9fa			 
a9fa e5					push hl    ; save address 
a9fb			 
a9fb					; load content into de 
a9fb			 
a9fb 5e					ld e,(hl) 
a9fc 23					inc hl 
a9fd 56					ld d, (hl) 
a9fe			 
a9fe					if DEBUG_FORTH_WORDS 
a9fe						DMARK "-2a" 
a9fe f5				push af  
a9ff 3a 13 aa			ld a, (.dmark)  
aa02 32 c0 ee			ld (debug_mark),a  
aa05 3a 14 aa			ld a, (.dmark+1)  
aa08 32 c1 ee			ld (debug_mark+1),a  
aa0b 3a 15 aa			ld a, (.dmark+2)  
aa0e 32 c2 ee			ld (debug_mark+2),a  
aa11 18 03			jr .pastdmark  
aa13 ..			.dmark: db "-2a"  
aa16 f1			.pastdmark: pop af  
aa17			endm  
# End of macro DMARK
aa17						CALLMONITOR 
aa17 cd 2e 93			call break_point_state  
aa1a				endm  
# End of macro CALLMONITOR
aa1a					endif 
aa1a			 
aa1a					FORTH_DSP_POP 
aa1a cd 6a 9b			call macro_forth_dsp_pop 
aa1d				endm 
# End of macro FORTH_DSP_POP
aa1d			 
aa1d					; Get value to remove 
aa1d			 
aa1d					FORTH_DSP_VALUE 
aa1d cd 9b 9a			call macro_forth_dsp_value 
aa20				endm 
# End of macro FORTH_DSP_VALUE
aa20			 
aa20					if DEBUG_FORTH_WORDS 
aa20						DMARK "-2v" 
aa20 f5				push af  
aa21 3a 35 aa			ld a, (.dmark)  
aa24 32 c0 ee			ld (debug_mark),a  
aa27 3a 36 aa			ld a, (.dmark+1)  
aa2a 32 c1 ee			ld (debug_mark+1),a  
aa2d 3a 37 aa			ld a, (.dmark+2)  
aa30 32 c2 ee			ld (debug_mark+2),a  
aa33 18 03			jr .pastdmark  
aa35 ..			.dmark: db "-2v"  
aa38 f1			.pastdmark: pop af  
aa39			endm  
# End of macro DMARK
aa39						CALLMONITOR 
aa39 cd 2e 93			call break_point_state  
aa3c				endm  
# End of macro CALLMONITOR
aa3c					endif 
aa3c			 
aa3c eb					ex de, hl 
aa3d ed 52				sbc hl, de 
aa3f			 
aa3f					if DEBUG_FORTH_WORDS 
aa3f						DMARK "-2d" 
aa3f f5				push af  
aa40 3a 54 aa			ld a, (.dmark)  
aa43 32 c0 ee			ld (debug_mark),a  
aa46 3a 55 aa			ld a, (.dmark+1)  
aa49 32 c1 ee			ld (debug_mark+1),a  
aa4c 3a 56 aa			ld a, (.dmark+2)  
aa4f 32 c2 ee			ld (debug_mark+2),a  
aa52 18 03			jr .pastdmark  
aa54 ..			.dmark: db "-2d"  
aa57 f1			.pastdmark: pop af  
aa58			endm  
# End of macro DMARK
aa58						CALLMONITOR 
aa58 cd 2e 93			call break_point_state  
aa5b				endm  
# End of macro CALLMONITOR
aa5b					endif 
aa5b			 
aa5b					; move result to de 
aa5b			 
aa5b eb					ex de, hl 
aa5c			 
aa5c					; Address 
aa5c			 
aa5c e1					pop hl 
aa5d			 
aa5d					; save it back 
aa5d			 
aa5d 73					ld (hl), e 
aa5e 23					inc hl 
aa5f 72					ld (hl), d 
aa60			 
aa60					if DEBUG_FORTH_WORDS 
aa60						DMARK "-2e" 
aa60 f5				push af  
aa61 3a 75 aa			ld a, (.dmark)  
aa64 32 c0 ee			ld (debug_mark),a  
aa67 3a 76 aa			ld a, (.dmark+1)  
aa6a 32 c1 ee			ld (debug_mark+1),a  
aa6d 3a 77 aa			ld a, (.dmark+2)  
aa70 32 c2 ee			ld (debug_mark+2),a  
aa73 18 03			jr .pastdmark  
aa75 ..			.dmark: db "-2e"  
aa78 f1			.pastdmark: pop af  
aa79			endm  
# End of macro DMARK
aa79						CALLMONITOR 
aa79 cd 2e 93			call break_point_state  
aa7c				endm  
# End of macro CALLMONITOR
aa7c					endif 
aa7c			 
aa7c			 
aa7c			 
aa7c			 
aa7c			 
aa7c				       NEXTW 
aa7c c3 24 9c			jp macro_next 
aa7f				endm 
# End of macro NEXTW
aa7f			.GET2: 
aa7f				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
aa7f 6f				db WORD_SYS_CORE+91             
aa80 af aa			dw .BANG2            
aa82 03				db 2 + 1 
aa83 .. 00			db "2@",0              
aa86				endm 
# End of macro CWHEAD
aa86			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
aa86					if DEBUG_FORTH_WORDS_KEY 
aa86						DMARK "2A_" 
aa86 f5				push af  
aa87 3a 9b aa			ld a, (.dmark)  
aa8a 32 c0 ee			ld (debug_mark),a  
aa8d 3a 9c aa			ld a, (.dmark+1)  
aa90 32 c1 ee			ld (debug_mark+1),a  
aa93 3a 9d aa			ld a, (.dmark+2)  
aa96 32 c2 ee			ld (debug_mark+2),a  
aa99 18 03			jr .pastdmark  
aa9b ..			.dmark: db "2A_"  
aa9e f1			.pastdmark: pop af  
aa9f			endm  
# End of macro DMARK
aa9f						CALLMONITOR 
aa9f cd 2e 93			call break_point_state  
aaa2				endm  
# End of macro CALLMONITOR
aaa2					endif 
aaa2			 
aaa2					FORTH_DSP_VALUEHL 
aaa2 cd b2 9a			call macro_dsp_valuehl 
aaa5				endm 
# End of macro FORTH_DSP_VALUEHL
aaa5			 
aaa5 5e					ld e, (hl) 
aaa6 23					inc hl 
aaa7 56					ld d, (hl) 
aaa8			 
aaa8 eb					ex de, hl 
aaa9			 
aaa9 cd bb 98				call forth_push_numhl 
aaac			 
aaac				       NEXTW 
aaac c3 24 9c			jp macro_next 
aaaf				endm 
# End of macro NEXTW
aaaf			.BANG2: 
aaaf				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
aaaf 6f				db WORD_SYS_CORE+91             
aab0 e7 aa			dw .CONFIG            
aab2 03				db 2 + 1 
aab3 .. 00			db "2!",0              
aab6				endm 
# End of macro CWHEAD
aab6			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
aab6					if DEBUG_FORTH_WORDS_KEY 
aab6						DMARK "2S_" 
aab6 f5				push af  
aab7 3a cb aa			ld a, (.dmark)  
aaba 32 c0 ee			ld (debug_mark),a  
aabd 3a cc aa			ld a, (.dmark+1)  
aac0 32 c1 ee			ld (debug_mark+1),a  
aac3 3a cd aa			ld a, (.dmark+2)  
aac6 32 c2 ee			ld (debug_mark+2),a  
aac9 18 03			jr .pastdmark  
aacb ..			.dmark: db "2S_"  
aace f1			.pastdmark: pop af  
aacf			endm  
# End of macro DMARK
aacf						CALLMONITOR 
aacf cd 2e 93			call break_point_state  
aad2				endm  
# End of macro CALLMONITOR
aad2					endif 
aad2			 
aad2					FORTH_DSP_VALUEHL 
aad2 cd b2 9a			call macro_dsp_valuehl 
aad5				endm 
# End of macro FORTH_DSP_VALUEHL
aad5			 
aad5 e5					push hl   ; save address 
aad6			 
aad6			 
aad6					FORTH_DSP_POP 
aad6 cd 6a 9b			call macro_forth_dsp_pop 
aad9				endm 
# End of macro FORTH_DSP_POP
aad9			 
aad9					 
aad9					FORTH_DSP_VALUEHL 
aad9 cd b2 9a			call macro_dsp_valuehl 
aadc				endm 
# End of macro FORTH_DSP_VALUEHL
aadc			 
aadc					FORTH_DSP_POP 
aadc cd 6a 9b			call macro_forth_dsp_pop 
aadf				endm 
# End of macro FORTH_DSP_POP
aadf			 
aadf eb					ex de, hl    ; value now in de 
aae0			 
aae0 e1					pop hl 
aae1			 
aae1 73					ld (hl), e 
aae2			 
aae2 23					inc hl 
aae3			 
aae3 72					ld (hl), d 
aae4			 
aae4			 
aae4				       NEXTW 
aae4 c3 24 9c			jp macro_next 
aae7				endm 
# End of macro NEXTW
aae7			.CONFIG: 
aae7				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
aae7 6f				db WORD_SYS_CORE+91             
aae8 f8 aa			dw .ENDCORE            
aaea 07				db 6 + 1 
aaeb .. 00			db "CONFIG",0              
aaf2				endm 
# End of macro CWHEAD
aaf2			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
aaf2			 
aaf2 cd 1b 91				call config 
aaf5					NEXTW 
aaf5 c3 24 9c			jp macro_next 
aaf8				endm 
# End of macro NEXTW
aaf8			.ENDCORE: 
aaf8			 
aaf8			; eof 
aaf8			 
aaf8			 
# End of file forth_words_core.asm
aaf8			include "forth_words_flow.asm" 
aaf8			 
aaf8			; | ## Program Flow Words 
aaf8			 
aaf8			.IF: 
aaf8				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
aaf8 1e				db WORD_SYS_CORE+10             
aaf9 ed ab			dw .THEN            
aafb 03				db 2 + 1 
aafc .. 00			db "IF",0              
aaff				endm 
# End of macro CWHEAD
aaff			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
aaff			; 
aaff					if DEBUG_FORTH_WORDS_KEY 
aaff						DMARK "IF." 
aaff f5				push af  
ab00 3a 14 ab			ld a, (.dmark)  
ab03 32 c0 ee			ld (debug_mark),a  
ab06 3a 15 ab			ld a, (.dmark+1)  
ab09 32 c1 ee			ld (debug_mark+1),a  
ab0c 3a 16 ab			ld a, (.dmark+2)  
ab0f 32 c2 ee			ld (debug_mark+2),a  
ab12 18 03			jr .pastdmark  
ab14 ..			.dmark: db "IF."  
ab17 f1			.pastdmark: pop af  
ab18			endm  
# End of macro DMARK
ab18						CALLMONITOR 
ab18 cd 2e 93			call break_point_state  
ab1b				endm  
# End of macro CALLMONITOR
ab1b					endif 
ab1b			; eval TOS 
ab1b			 
ab1b				FORTH_DSP_VALUEHL 
ab1b cd b2 9a			call macro_dsp_valuehl 
ab1e				endm 
# End of macro FORTH_DSP_VALUEHL
ab1e			 
ab1e			;	push hl 
ab1e				FORTH_DSP_POP 
ab1e cd 6a 9b			call macro_forth_dsp_pop 
ab21				endm 
# End of macro FORTH_DSP_POP
ab21			;	pop hl 
ab21			 
ab21					if DEBUG_FORTH_WORDS 
ab21						DMARK "IF1" 
ab21 f5				push af  
ab22 3a 36 ab			ld a, (.dmark)  
ab25 32 c0 ee			ld (debug_mark),a  
ab28 3a 37 ab			ld a, (.dmark+1)  
ab2b 32 c1 ee			ld (debug_mark+1),a  
ab2e 3a 38 ab			ld a, (.dmark+2)  
ab31 32 c2 ee			ld (debug_mark+2),a  
ab34 18 03			jr .pastdmark  
ab36 ..			.dmark: db "IF1"  
ab39 f1			.pastdmark: pop af  
ab3a			endm  
# End of macro DMARK
ab3a						CALLMONITOR 
ab3a cd 2e 93			call break_point_state  
ab3d				endm  
# End of macro CALLMONITOR
ab3d					endif 
ab3d b7				or a        ; clear carry flag 
ab3e 11 00 00			ld de, 0 
ab41 eb				ex de,hl 
ab42 ed 52			sbc hl, de 
ab44 c2 ce ab			jp nz, .iftrue 
ab47			 
ab47					if DEBUG_FORTH_WORDS 
ab47						DMARK "IF2" 
ab47 f5				push af  
ab48 3a 5c ab			ld a, (.dmark)  
ab4b 32 c0 ee			ld (debug_mark),a  
ab4e 3a 5d ab			ld a, (.dmark+1)  
ab51 32 c1 ee			ld (debug_mark+1),a  
ab54 3a 5e ab			ld a, (.dmark+2)  
ab57 32 c2 ee			ld (debug_mark+2),a  
ab5a 18 03			jr .pastdmark  
ab5c ..			.dmark: db "IF2"  
ab5f f1			.pastdmark: pop af  
ab60			endm  
# End of macro DMARK
ab60						CALLMONITOR 
ab60 cd 2e 93			call break_point_state  
ab63				endm  
# End of macro CALLMONITOR
ab63					endif 
ab63			 
ab63			; if not true then skip to THEN 
ab63			 
ab63				; TODO get tok_ptr 
ab63				; TODO consume toks until we get to THEN 
ab63			 
ab63 2a e7 e7			ld hl, (os_tok_ptr) 
ab66					if DEBUG_FORTH_WORDS 
ab66						DMARK "IF3" 
ab66 f5				push af  
ab67 3a 7b ab			ld a, (.dmark)  
ab6a 32 c0 ee			ld (debug_mark),a  
ab6d 3a 7c ab			ld a, (.dmark+1)  
ab70 32 c1 ee			ld (debug_mark+1),a  
ab73 3a 7d ab			ld a, (.dmark+2)  
ab76 32 c2 ee			ld (debug_mark+2),a  
ab79 18 03			jr .pastdmark  
ab7b ..			.dmark: db "IF3"  
ab7e f1			.pastdmark: pop af  
ab7f			endm  
# End of macro DMARK
ab7f						CALLMONITOR 
ab7f cd 2e 93			call break_point_state  
ab82				endm  
# End of macro CALLMONITOR
ab82						 
ab82					endif 
ab82 11 c9 ab			ld de, .ifthen 
ab85					if DEBUG_FORTH_WORDS 
ab85						DMARK "IF4" 
ab85 f5				push af  
ab86 3a 9a ab			ld a, (.dmark)  
ab89 32 c0 ee			ld (debug_mark),a  
ab8c 3a 9b ab			ld a, (.dmark+1)  
ab8f 32 c1 ee			ld (debug_mark+1),a  
ab92 3a 9c ab			ld a, (.dmark+2)  
ab95 32 c2 ee			ld (debug_mark+2),a  
ab98 18 03			jr .pastdmark  
ab9a ..			.dmark: db "IF4"  
ab9d f1			.pastdmark: pop af  
ab9e			endm  
# End of macro DMARK
ab9e						CALLMONITOR 
ab9e cd 2e 93			call break_point_state  
aba1				endm  
# End of macro CALLMONITOR
aba1					endif 
aba1 cd 3f 9d			call findnexttok  
aba4			 
aba4					if DEBUG_FORTH_WORDS 
aba4						DMARK "IF5" 
aba4 f5				push af  
aba5 3a b9 ab			ld a, (.dmark)  
aba8 32 c0 ee			ld (debug_mark),a  
abab 3a ba ab			ld a, (.dmark+1)  
abae 32 c1 ee			ld (debug_mark+1),a  
abb1 3a bb ab			ld a, (.dmark+2)  
abb4 32 c2 ee			ld (debug_mark+2),a  
abb7 18 03			jr .pastdmark  
abb9 ..			.dmark: db "IF5"  
abbc f1			.pastdmark: pop af  
abbd			endm  
# End of macro DMARK
abbd						CALLMONITOR 
abbd cd 2e 93			call break_point_state  
abc0				endm  
# End of macro CALLMONITOR
abc0					endif 
abc0				; TODO replace below with ; exec using tok_ptr 
abc0 22 e7 e7			ld (os_tok_ptr), hl 
abc3 c3 b5 9c			jp exec1 
abc6				NEXTW 
abc6 c3 24 9c			jp macro_next 
abc9				endm 
# End of macro NEXTW
abc9			 
abc9 .. 00		.ifthen:  db "THEN",0 
abce			 
abce			.iftrue:		 
abce				; Exec next words normally 
abce			 
abce				; if true then exec following IF as normal 
abce					if DEBUG_FORTH_WORDS 
abce						DMARK "IFT" 
abce f5				push af  
abcf 3a e3 ab			ld a, (.dmark)  
abd2 32 c0 ee			ld (debug_mark),a  
abd5 3a e4 ab			ld a, (.dmark+1)  
abd8 32 c1 ee			ld (debug_mark+1),a  
abdb 3a e5 ab			ld a, (.dmark+2)  
abde 32 c2 ee			ld (debug_mark+2),a  
abe1 18 03			jr .pastdmark  
abe3 ..			.dmark: db "IFT"  
abe6 f1			.pastdmark: pop af  
abe7			endm  
# End of macro DMARK
abe7						CALLMONITOR 
abe7 cd 2e 93			call break_point_state  
abea				endm  
# End of macro CALLMONITOR
abea					endif 
abea			 
abea					NEXTW 
abea c3 24 9c			jp macro_next 
abed				endm 
# End of macro NEXTW
abed			.THEN: 
abed				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
abed 1f				db WORD_SYS_CORE+11             
abee 15 ac			dw .ELSE            
abf0 05				db 4 + 1 
abf1 .. 00			db "THEN",0              
abf6				endm 
# End of macro CWHEAD
abf6			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
abf6					if DEBUG_FORTH_WORDS_KEY 
abf6						DMARK "THN" 
abf6 f5				push af  
abf7 3a 0b ac			ld a, (.dmark)  
abfa 32 c0 ee			ld (debug_mark),a  
abfd 3a 0c ac			ld a, (.dmark+1)  
ac00 32 c1 ee			ld (debug_mark+1),a  
ac03 3a 0d ac			ld a, (.dmark+2)  
ac06 32 c2 ee			ld (debug_mark+2),a  
ac09 18 03			jr .pastdmark  
ac0b ..			.dmark: db "THN"  
ac0e f1			.pastdmark: pop af  
ac0f			endm  
# End of macro DMARK
ac0f						CALLMONITOR 
ac0f cd 2e 93			call break_point_state  
ac12				endm  
# End of macro CALLMONITOR
ac12					endif 
ac12					NEXTW 
ac12 c3 24 9c			jp macro_next 
ac15				endm 
# End of macro NEXTW
ac15			.ELSE: 
ac15				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ac15 20				db WORD_SYS_CORE+12             
ac16 3d ac			dw .DO            
ac18 03				db 2 + 1 
ac19 .. 00			db "ELSE",0              
ac1e				endm 
# End of macro CWHEAD
ac1e			; | ELSE ( -- ) Not supported - does nothing | TODO 
ac1e			 
ac1e					if DEBUG_FORTH_WORDS_KEY 
ac1e						DMARK "ELS" 
ac1e f5				push af  
ac1f 3a 33 ac			ld a, (.dmark)  
ac22 32 c0 ee			ld (debug_mark),a  
ac25 3a 34 ac			ld a, (.dmark+1)  
ac28 32 c1 ee			ld (debug_mark+1),a  
ac2b 3a 35 ac			ld a, (.dmark+2)  
ac2e 32 c2 ee			ld (debug_mark+2),a  
ac31 18 03			jr .pastdmark  
ac33 ..			.dmark: db "ELS"  
ac36 f1			.pastdmark: pop af  
ac37			endm  
# End of macro DMARK
ac37						CALLMONITOR 
ac37 cd 2e 93			call break_point_state  
ac3a				endm  
# End of macro CALLMONITOR
ac3a					endif 
ac3a			 
ac3a			 
ac3a					NEXTW 
ac3a c3 24 9c			jp macro_next 
ac3d				endm 
# End of macro NEXTW
ac3d			.DO: 
ac3d				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ac3d 21				db WORD_SYS_CORE+13             
ac3e 64 ad			dw .LOOP            
ac40 03				db 2 + 1 
ac41 .. 00			db "DO",0              
ac44				endm 
# End of macro CWHEAD
ac44			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ac44			 
ac44					if DEBUG_FORTH_WORDS_KEY 
ac44						DMARK "DO." 
ac44 f5				push af  
ac45 3a 59 ac			ld a, (.dmark)  
ac48 32 c0 ee			ld (debug_mark),a  
ac4b 3a 5a ac			ld a, (.dmark+1)  
ac4e 32 c1 ee			ld (debug_mark+1),a  
ac51 3a 5b ac			ld a, (.dmark+2)  
ac54 32 c2 ee			ld (debug_mark+2),a  
ac57 18 03			jr .pastdmark  
ac59 ..			.dmark: db "DO."  
ac5c f1			.pastdmark: pop af  
ac5d			endm  
# End of macro DMARK
ac5d						CALLMONITOR 
ac5d cd 2e 93			call break_point_state  
ac60				endm  
# End of macro CALLMONITOR
ac60					endif 
ac60			;  push pc to rsp stack past the DO 
ac60			 
ac60 2a e7 e7				ld hl, (os_tok_ptr) 
ac63 23					inc hl   ; D 
ac64 23					inc hl  ; O 
ac65 23					inc hl   ; null 
ac66					if DEBUG_FORTH_WORDS 
ac66						DMARK "DO2" 
ac66 f5				push af  
ac67 3a 7b ac			ld a, (.dmark)  
ac6a 32 c0 ee			ld (debug_mark),a  
ac6d 3a 7c ac			ld a, (.dmark+1)  
ac70 32 c1 ee			ld (debug_mark+1),a  
ac73 3a 7d ac			ld a, (.dmark+2)  
ac76 32 c2 ee			ld (debug_mark+2),a  
ac79 18 03			jr .pastdmark  
ac7b ..			.dmark: db "DO2"  
ac7e f1			.pastdmark: pop af  
ac7f			endm  
# End of macro DMARK
ac7f						CALLMONITOR 
ac7f cd 2e 93			call break_point_state  
ac82				endm  
# End of macro CALLMONITOR
ac82					endif 
ac82					FORTH_RSP_NEXT 
ac82 cd 62 98			call macro_forth_rsp_next 
ac85				endm 
# End of macro FORTH_RSP_NEXT
ac85					if DEBUG_FORTH_WORDS 
ac85						DMARK "DO3" 
ac85 f5				push af  
ac86 3a 9a ac			ld a, (.dmark)  
ac89 32 c0 ee			ld (debug_mark),a  
ac8c 3a 9b ac			ld a, (.dmark+1)  
ac8f 32 c1 ee			ld (debug_mark+1),a  
ac92 3a 9c ac			ld a, (.dmark+2)  
ac95 32 c2 ee			ld (debug_mark+2),a  
ac98 18 03			jr .pastdmark  
ac9a ..			.dmark: db "DO3"  
ac9d f1			.pastdmark: pop af  
ac9e			endm  
# End of macro DMARK
ac9e						CALLMONITOR 
ac9e cd 2e 93			call break_point_state  
aca1				endm  
# End of macro CALLMONITOR
aca1					endif 
aca1			 
aca1					;if DEBUG_FORTH_WORDS 
aca1				;		push hl 
aca1			;		endif  
aca1			 
aca1			; get counters from data stack 
aca1			 
aca1			 
aca1					FORTH_DSP_VALUEHL 
aca1 cd b2 9a			call macro_dsp_valuehl 
aca4				endm 
# End of macro FORTH_DSP_VALUEHL
aca4 e5					push hl		 ; hl now has starting counter which needs to be tos 
aca5			 
aca5					if DEBUG_FORTH_WORDS 
aca5						DMARK "DO4" 
aca5 f5				push af  
aca6 3a ba ac			ld a, (.dmark)  
aca9 32 c0 ee			ld (debug_mark),a  
acac 3a bb ac			ld a, (.dmark+1)  
acaf 32 c1 ee			ld (debug_mark+1),a  
acb2 3a bc ac			ld a, (.dmark+2)  
acb5 32 c2 ee			ld (debug_mark+2),a  
acb8 18 03			jr .pastdmark  
acba ..			.dmark: db "DO4"  
acbd f1			.pastdmark: pop af  
acbe			endm  
# End of macro DMARK
acbe						CALLMONITOR 
acbe cd 2e 93			call break_point_state  
acc1				endm  
# End of macro CALLMONITOR
acc1					endif 
acc1					FORTH_DSP_POP 
acc1 cd 6a 9b			call macro_forth_dsp_pop 
acc4				endm 
# End of macro FORTH_DSP_POP
acc4			 
acc4					if DEBUG_FORTH_WORDS 
acc4						DMARK "DO5" 
acc4 f5				push af  
acc5 3a d9 ac			ld a, (.dmark)  
acc8 32 c0 ee			ld (debug_mark),a  
accb 3a da ac			ld a, (.dmark+1)  
acce 32 c1 ee			ld (debug_mark+1),a  
acd1 3a db ac			ld a, (.dmark+2)  
acd4 32 c2 ee			ld (debug_mark+2),a  
acd7 18 03			jr .pastdmark  
acd9 ..			.dmark: db "DO5"  
acdc f1			.pastdmark: pop af  
acdd			endm  
# End of macro DMARK
acdd						CALLMONITOR 
acdd cd 2e 93			call break_point_state  
ace0				endm  
# End of macro CALLMONITOR
ace0					endif 
ace0			 
ace0					FORTH_DSP_VALUEHL 
ace0 cd b2 9a			call macro_dsp_valuehl 
ace3				endm 
# End of macro FORTH_DSP_VALUEHL
ace3			;		push hl		 ; hl now has starting limit counter 
ace3			 
ace3					if DEBUG_FORTH_WORDS 
ace3						DMARK "DO6" 
ace3 f5				push af  
ace4 3a f8 ac			ld a, (.dmark)  
ace7 32 c0 ee			ld (debug_mark),a  
acea 3a f9 ac			ld a, (.dmark+1)  
aced 32 c1 ee			ld (debug_mark+1),a  
acf0 3a fa ac			ld a, (.dmark+2)  
acf3 32 c2 ee			ld (debug_mark+2),a  
acf6 18 03			jr .pastdmark  
acf8 ..			.dmark: db "DO6"  
acfb f1			.pastdmark: pop af  
acfc			endm  
# End of macro DMARK
acfc						CALLMONITOR 
acfc cd 2e 93			call break_point_state  
acff				endm  
# End of macro CALLMONITOR
acff					endif 
acff					FORTH_DSP_POP 
acff cd 6a 9b			call macro_forth_dsp_pop 
ad02				endm 
# End of macro FORTH_DSP_POP
ad02			 
ad02			; put counters on the loop stack 
ad02			 
ad02			;		pop hl			 ; limit counter 
ad02 d1					pop de			; start counter 
ad03			 
ad03					; push limit counter 
ad03			 
ad03					if DEBUG_FORTH_WORDS 
ad03						DMARK "DO7" 
ad03 f5				push af  
ad04 3a 18 ad			ld a, (.dmark)  
ad07 32 c0 ee			ld (debug_mark),a  
ad0a 3a 19 ad			ld a, (.dmark+1)  
ad0d 32 c1 ee			ld (debug_mark+1),a  
ad10 3a 1a ad			ld a, (.dmark+2)  
ad13 32 c2 ee			ld (debug_mark+2),a  
ad16 18 03			jr .pastdmark  
ad18 ..			.dmark: db "DO7"  
ad1b f1			.pastdmark: pop af  
ad1c			endm  
# End of macro DMARK
ad1c						CALLMONITOR 
ad1c cd 2e 93			call break_point_state  
ad1f				endm  
# End of macro CALLMONITOR
ad1f					endif 
ad1f					FORTH_LOOP_NEXT 
ad1f cd e3 9a			call macro_forth_loop_next 
ad22				endm 
# End of macro FORTH_LOOP_NEXT
ad22			 
ad22					; push start counter 
ad22			 
ad22 eb					ex de, hl 
ad23					if DEBUG_FORTH_WORDS 
ad23						DMARK "DO7" 
ad23 f5				push af  
ad24 3a 38 ad			ld a, (.dmark)  
ad27 32 c0 ee			ld (debug_mark),a  
ad2a 3a 39 ad			ld a, (.dmark+1)  
ad2d 32 c1 ee			ld (debug_mark+1),a  
ad30 3a 3a ad			ld a, (.dmark+2)  
ad33 32 c2 ee			ld (debug_mark+2),a  
ad36 18 03			jr .pastdmark  
ad38 ..			.dmark: db "DO7"  
ad3b f1			.pastdmark: pop af  
ad3c			endm  
# End of macro DMARK
ad3c						CALLMONITOR 
ad3c cd 2e 93			call break_point_state  
ad3f				endm  
# End of macro CALLMONITOR
ad3f					endif 
ad3f					FORTH_LOOP_NEXT 
ad3f cd e3 9a			call macro_forth_loop_next 
ad42				endm 
# End of macro FORTH_LOOP_NEXT
ad42			 
ad42			 
ad42					; init first round of I counter 
ad42			 
ad42 22 0b e8				ld (os_current_i), hl 
ad45			 
ad45					if DEBUG_FORTH_WORDS 
ad45						DMARK "DO8" 
ad45 f5				push af  
ad46 3a 5a ad			ld a, (.dmark)  
ad49 32 c0 ee			ld (debug_mark),a  
ad4c 3a 5b ad			ld a, (.dmark+1)  
ad4f 32 c1 ee			ld (debug_mark+1),a  
ad52 3a 5c ad			ld a, (.dmark+2)  
ad55 32 c2 ee			ld (debug_mark+2),a  
ad58 18 03			jr .pastdmark  
ad5a ..			.dmark: db "DO8"  
ad5d f1			.pastdmark: pop af  
ad5e			endm  
# End of macro DMARK
ad5e						CALLMONITOR 
ad5e cd 2e 93			call break_point_state  
ad61				endm  
# End of macro CALLMONITOR
ad61					endif 
ad61			 
ad61					NEXTW 
ad61 c3 24 9c			jp macro_next 
ad64				endm 
# End of macro NEXTW
ad64			.LOOP: 
ad64				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ad64 22				db WORD_SYS_CORE+14             
ad65 7c ae			dw .I            
ad67 05				db 4 + 1 
ad68 .. 00			db "LOOP",0              
ad6d				endm 
# End of macro CWHEAD
ad6d			; | LOOP ( -- ) Increment and test loop counter  | DONE 
ad6d			 
ad6d				; pop tos as current loop count to hl 
ad6d			 
ad6d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ad6d			 
ad6d				FORTH_LOOP_TOS 
ad6d cd 16 9b			call macro_forth_loop_tos 
ad70				endm 
# End of macro FORTH_LOOP_TOS
ad70 e5				push hl 
ad71			 
ad71					if DEBUG_FORTH_WORDS_KEY 
ad71						DMARK "LOP" 
ad71 f5				push af  
ad72 3a 86 ad			ld a, (.dmark)  
ad75 32 c0 ee			ld (debug_mark),a  
ad78 3a 87 ad			ld a, (.dmark+1)  
ad7b 32 c1 ee			ld (debug_mark+1),a  
ad7e 3a 88 ad			ld a, (.dmark+2)  
ad81 32 c2 ee			ld (debug_mark+2),a  
ad84 18 03			jr .pastdmark  
ad86 ..			.dmark: db "LOP"  
ad89 f1			.pastdmark: pop af  
ad8a			endm  
# End of macro DMARK
ad8a						CALLMONITOR 
ad8a cd 2e 93			call break_point_state  
ad8d				endm  
# End of macro CALLMONITOR
ad8d					endif 
ad8d				; next item on the stack is the limit. get it 
ad8d			 
ad8d			 
ad8d				FORTH_LOOP_POP 
ad8d cd 20 9b			call macro_forth_loop_pop 
ad90				endm 
# End of macro FORTH_LOOP_POP
ad90			 
ad90				FORTH_LOOP_TOS 
ad90 cd 16 9b			call macro_forth_loop_tos 
ad93				endm 
# End of macro FORTH_LOOP_TOS
ad93			 
ad93 d1				pop de		 ; de = i, hl = limit 
ad94			 
ad94					if DEBUG_FORTH_WORDS 
ad94						DMARK "LP1" 
ad94 f5				push af  
ad95 3a a9 ad			ld a, (.dmark)  
ad98 32 c0 ee			ld (debug_mark),a  
ad9b 3a aa ad			ld a, (.dmark+1)  
ad9e 32 c1 ee			ld (debug_mark+1),a  
ada1 3a ab ad			ld a, (.dmark+2)  
ada4 32 c2 ee			ld (debug_mark+2),a  
ada7 18 03			jr .pastdmark  
ada9 ..			.dmark: db "LP1"  
adac f1			.pastdmark: pop af  
adad			endm  
# End of macro DMARK
adad						CALLMONITOR 
adad cd 2e 93			call break_point_state  
adb0				endm  
# End of macro CALLMONITOR
adb0					endif 
adb0			 
adb0				; go back to previous word 
adb0			 
adb0 d5				push de    ; save I for inc later 
adb1			 
adb1			 
adb1				; get limit 
adb1				;  is I at limit? 
adb1			 
adb1			 
adb1					if DEBUG_FORTH_WORDS 
adb1						DMARK "LP1" 
adb1 f5				push af  
adb2 3a c6 ad			ld a, (.dmark)  
adb5 32 c0 ee			ld (debug_mark),a  
adb8 3a c7 ad			ld a, (.dmark+1)  
adbb 32 c1 ee			ld (debug_mark+1),a  
adbe 3a c8 ad			ld a, (.dmark+2)  
adc1 32 c2 ee			ld (debug_mark+2),a  
adc4 18 03			jr .pastdmark  
adc6 ..			.dmark: db "LP1"  
adc9 f1			.pastdmark: pop af  
adca			endm  
# End of macro DMARK
adca						CALLMONITOR 
adca cd 2e 93			call break_point_state  
adcd				endm  
# End of macro CALLMONITOR
adcd					endif 
adcd			 
adcd ed 52			sbc hl, de 
adcf			 
adcf			 
adcf				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
adcf			 
adcf 20 26				jr nz, .loopnotdone 
add1			 
add1 e1				pop hl   ; get rid of saved I 
add2				FORTH_LOOP_POP     ; get rid of limit 
add2 cd 20 9b			call macro_forth_loop_pop 
add5				endm 
# End of macro FORTH_LOOP_POP
add5			 
add5				FORTH_RSP_POP     ; get rid of DO ptr 
add5 cd 83 98			call macro_forth_rsp_pop 
add8				endm 
# End of macro FORTH_RSP_POP
add8			 
add8			if DEBUG_FORTH_WORDS 
add8						DMARK "LP>" 
add8 f5				push af  
add9 3a ed ad			ld a, (.dmark)  
addc 32 c0 ee			ld (debug_mark),a  
addf 3a ee ad			ld a, (.dmark+1)  
ade2 32 c1 ee			ld (debug_mark+1),a  
ade5 3a ef ad			ld a, (.dmark+2)  
ade8 32 c2 ee			ld (debug_mark+2),a  
adeb 18 03			jr .pastdmark  
aded ..			.dmark: db "LP>"  
adf0 f1			.pastdmark: pop af  
adf1			endm  
# End of macro DMARK
adf1				CALLMONITOR 
adf1 cd 2e 93			call break_point_state  
adf4				endm  
# End of macro CALLMONITOR
adf4			endif 
adf4			 
adf4					NEXTW 
adf4 c3 24 9c			jp macro_next 
adf7				endm 
# End of macro NEXTW
adf7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
adf7			 
adf7			.loopnotdone: 
adf7			 
adf7 e1				pop hl    ; get I 
adf8 23				inc hl 
adf9			 
adf9			   	; save new I 
adf9			 
adf9			 
adf9					; set I counter 
adf9			 
adf9 22 0b e8				ld (os_current_i), hl 
adfc			 
adfc					if DEBUG_FORTH_WORDS 
adfc						DMARK "LPN" 
adfc f5				push af  
adfd 3a 11 ae			ld a, (.dmark)  
ae00 32 c0 ee			ld (debug_mark),a  
ae03 3a 12 ae			ld a, (.dmark+1)  
ae06 32 c1 ee			ld (debug_mark+1),a  
ae09 3a 13 ae			ld a, (.dmark+2)  
ae0c 32 c2 ee			ld (debug_mark+2),a  
ae0f 18 03			jr .pastdmark  
ae11 ..			.dmark: db "LPN"  
ae14 f1			.pastdmark: pop af  
ae15			endm  
# End of macro DMARK
ae15					CALLMONITOR 
ae15 cd 2e 93			call break_point_state  
ae18				endm  
# End of macro CALLMONITOR
ae18					endif 
ae18					 
ae18				FORTH_LOOP_NEXT 
ae18 cd e3 9a			call macro_forth_loop_next 
ae1b				endm 
# End of macro FORTH_LOOP_NEXT
ae1b			 
ae1b			 
ae1b					if DEBUG_FORTH_WORDS 
ae1b eb						ex de,hl 
ae1c					endif 
ae1c			 
ae1c			;	; get DO ptr 
ae1c			; 
ae1c					if DEBUG_FORTH_WORDS 
ae1c						DMARK "LP7" 
ae1c f5				push af  
ae1d 3a 31 ae			ld a, (.dmark)  
ae20 32 c0 ee			ld (debug_mark),a  
ae23 3a 32 ae			ld a, (.dmark+1)  
ae26 32 c1 ee			ld (debug_mark+1),a  
ae29 3a 33 ae			ld a, (.dmark+2)  
ae2c 32 c2 ee			ld (debug_mark+2),a  
ae2f 18 03			jr .pastdmark  
ae31 ..			.dmark: db "LP7"  
ae34 f1			.pastdmark: pop af  
ae35			endm  
# End of macro DMARK
ae35					CALLMONITOR 
ae35 cd 2e 93			call break_point_state  
ae38				endm  
# End of macro CALLMONITOR
ae38					endif 
ae38				FORTH_RSP_TOS 
ae38 cd 79 98			call macro_forth_rsp_tos 
ae3b				endm 
# End of macro FORTH_RSP_TOS
ae3b			 
ae3b					if DEBUG_FORTH_WORDS 
ae3b						DMARK "LP8" 
ae3b f5				push af  
ae3c 3a 50 ae			ld a, (.dmark)  
ae3f 32 c0 ee			ld (debug_mark),a  
ae42 3a 51 ae			ld a, (.dmark+1)  
ae45 32 c1 ee			ld (debug_mark+1),a  
ae48 3a 52 ae			ld a, (.dmark+2)  
ae4b 32 c2 ee			ld (debug_mark+2),a  
ae4e 18 03			jr .pastdmark  
ae50 ..			.dmark: db "LP8"  
ae53 f1			.pastdmark: pop af  
ae54			endm  
# End of macro DMARK
ae54					CALLMONITOR 
ae54 cd 2e 93			call break_point_state  
ae57				endm  
# End of macro CALLMONITOR
ae57					endif 
ae57				;push hl 
ae57			 
ae57				; not going to DO any more 
ae57				; get rid of the RSP pointer as DO will add it back in 
ae57				;FORTH_RSP_POP 
ae57				;pop hl 
ae57			 
ae57				;ld hl,(cli_ret_sp) 
ae57				;ld e, (hl) 
ae57				;inc hl 
ae57				;ld d, (hl) 
ae57				;ex de,hl 
ae57 22 e7 e7			ld (os_tok_ptr), hl 
ae5a					if DEBUG_FORTH_WORDS 
ae5a						DMARK "LP<" 
ae5a f5				push af  
ae5b 3a 6f ae			ld a, (.dmark)  
ae5e 32 c0 ee			ld (debug_mark),a  
ae61 3a 70 ae			ld a, (.dmark+1)  
ae64 32 c1 ee			ld (debug_mark+1),a  
ae67 3a 71 ae			ld a, (.dmark+2)  
ae6a 32 c2 ee			ld (debug_mark+2),a  
ae6d 18 03			jr .pastdmark  
ae6f ..			.dmark: db "LP<"  
ae72 f1			.pastdmark: pop af  
ae73			endm  
# End of macro DMARK
ae73					CALLMONITOR 
ae73 cd 2e 93			call break_point_state  
ae76				endm  
# End of macro CALLMONITOR
ae76				endif 
ae76 c3 b5 9c			jp exec1 
ae79			 
ae79					 
ae79			 
ae79			 
ae79					NEXTW 
ae79 c3 24 9c			jp macro_next 
ae7c				endm 
# End of macro NEXTW
ae7c			.I:  
ae7c			 
ae7c				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
ae7c 5e				db WORD_SYS_CORE+74             
ae7d a7 ae			dw .DLOOP            
ae7f 02				db 1 + 1 
ae80 .. 00			db "I",0              
ae82				endm 
# End of macro CWHEAD
ae82			; | I ( -- ) Current loop counter | DONE 
ae82					if DEBUG_FORTH_WORDS_KEY 
ae82						DMARK "I.." 
ae82 f5				push af  
ae83 3a 97 ae			ld a, (.dmark)  
ae86 32 c0 ee			ld (debug_mark),a  
ae89 3a 98 ae			ld a, (.dmark+1)  
ae8c 32 c1 ee			ld (debug_mark+1),a  
ae8f 3a 99 ae			ld a, (.dmark+2)  
ae92 32 c2 ee			ld (debug_mark+2),a  
ae95 18 03			jr .pastdmark  
ae97 ..			.dmark: db "I.."  
ae9a f1			.pastdmark: pop af  
ae9b			endm  
# End of macro DMARK
ae9b						CALLMONITOR 
ae9b cd 2e 93			call break_point_state  
ae9e				endm  
# End of macro CALLMONITOR
ae9e					endif 
ae9e			 
ae9e 2a 0b e8				ld hl,(os_current_i) 
aea1 cd bb 98				call forth_push_numhl 
aea4			 
aea4					NEXTW 
aea4 c3 24 9c			jp macro_next 
aea7				endm 
# End of macro NEXTW
aea7			.DLOOP: 
aea7				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
aea7 5f				db WORD_SYS_CORE+75             
aea8 88 af			dw .REPEAT            
aeaa 06				db 5 + 1 
aeab .. 00			db "-LOOP",0              
aeb1				endm 
# End of macro CWHEAD
aeb1			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
aeb1				; pop tos as current loop count to hl 
aeb1					if DEBUG_FORTH_WORDS_KEY 
aeb1						DMARK "-LP" 
aeb1 f5				push af  
aeb2 3a c6 ae			ld a, (.dmark)  
aeb5 32 c0 ee			ld (debug_mark),a  
aeb8 3a c7 ae			ld a, (.dmark+1)  
aebb 32 c1 ee			ld (debug_mark+1),a  
aebe 3a c8 ae			ld a, (.dmark+2)  
aec1 32 c2 ee			ld (debug_mark+2),a  
aec4 18 03			jr .pastdmark  
aec6 ..			.dmark: db "-LP"  
aec9 f1			.pastdmark: pop af  
aeca			endm  
# End of macro DMARK
aeca						CALLMONITOR 
aeca cd 2e 93			call break_point_state  
aecd				endm  
# End of macro CALLMONITOR
aecd					endif 
aecd			 
aecd				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
aecd			 
aecd				FORTH_LOOP_TOS 
aecd cd 16 9b			call macro_forth_loop_tos 
aed0				endm 
# End of macro FORTH_LOOP_TOS
aed0 e5				push hl 
aed1			 
aed1					if DEBUG_FORTH_WORDS 
aed1						DMARK "-LP" 
aed1 f5				push af  
aed2 3a e6 ae			ld a, (.dmark)  
aed5 32 c0 ee			ld (debug_mark),a  
aed8 3a e7 ae			ld a, (.dmark+1)  
aedb 32 c1 ee			ld (debug_mark+1),a  
aede 3a e8 ae			ld a, (.dmark+2)  
aee1 32 c2 ee			ld (debug_mark+2),a  
aee4 18 03			jr .pastdmark  
aee6 ..			.dmark: db "-LP"  
aee9 f1			.pastdmark: pop af  
aeea			endm  
# End of macro DMARK
aeea						CALLMONITOR 
aeea cd 2e 93			call break_point_state  
aeed				endm  
# End of macro CALLMONITOR
aeed					endif 
aeed				; next item on the stack is the limit. get it 
aeed			 
aeed			 
aeed				FORTH_LOOP_POP 
aeed cd 20 9b			call macro_forth_loop_pop 
aef0				endm 
# End of macro FORTH_LOOP_POP
aef0			 
aef0				FORTH_LOOP_TOS 
aef0 cd 16 9b			call macro_forth_loop_tos 
aef3				endm 
# End of macro FORTH_LOOP_TOS
aef3			 
aef3 d1				pop de		 ; de = i, hl = limit 
aef4			 
aef4					if DEBUG_FORTH_WORDS 
aef4						DMARK "-L1" 
aef4 f5				push af  
aef5 3a 09 af			ld a, (.dmark)  
aef8 32 c0 ee			ld (debug_mark),a  
aefb 3a 0a af			ld a, (.dmark+1)  
aefe 32 c1 ee			ld (debug_mark+1),a  
af01 3a 0b af			ld a, (.dmark+2)  
af04 32 c2 ee			ld (debug_mark+2),a  
af07 18 03			jr .pastdmark  
af09 ..			.dmark: db "-L1"  
af0c f1			.pastdmark: pop af  
af0d			endm  
# End of macro DMARK
af0d						CALLMONITOR 
af0d cd 2e 93			call break_point_state  
af10				endm  
# End of macro CALLMONITOR
af10					endif 
af10			 
af10				; go back to previous word 
af10			 
af10 d5				push de    ; save I for inc later 
af11			 
af11			 
af11				; get limit 
af11				;  is I at limit? 
af11			 
af11			 
af11					if DEBUG_FORTH_WORDS 
af11						DMARK "-L1" 
af11 f5				push af  
af12 3a 26 af			ld a, (.dmark)  
af15 32 c0 ee			ld (debug_mark),a  
af18 3a 27 af			ld a, (.dmark+1)  
af1b 32 c1 ee			ld (debug_mark+1),a  
af1e 3a 28 af			ld a, (.dmark+2)  
af21 32 c2 ee			ld (debug_mark+2),a  
af24 18 03			jr .pastdmark  
af26 ..			.dmark: db "-L1"  
af29 f1			.pastdmark: pop af  
af2a			endm  
# End of macro DMARK
af2a						CALLMONITOR 
af2a cd 2e 93			call break_point_state  
af2d				endm  
# End of macro CALLMONITOR
af2d					endif 
af2d			 
af2d ed 52			sbc hl, de 
af2f			 
af2f			 
af2f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
af2f			 
af2f 20 26				jr nz, .mloopnotdone 
af31			 
af31 e1				pop hl   ; get rid of saved I 
af32				FORTH_LOOP_POP     ; get rid of limit 
af32 cd 20 9b			call macro_forth_loop_pop 
af35				endm 
# End of macro FORTH_LOOP_POP
af35			 
af35				FORTH_RSP_POP     ; get rid of DO ptr 
af35 cd 83 98			call macro_forth_rsp_pop 
af38				endm 
# End of macro FORTH_RSP_POP
af38			 
af38			if DEBUG_FORTH_WORDS 
af38						DMARK "-L>" 
af38 f5				push af  
af39 3a 4d af			ld a, (.dmark)  
af3c 32 c0 ee			ld (debug_mark),a  
af3f 3a 4e af			ld a, (.dmark+1)  
af42 32 c1 ee			ld (debug_mark+1),a  
af45 3a 4f af			ld a, (.dmark+2)  
af48 32 c2 ee			ld (debug_mark+2),a  
af4b 18 03			jr .pastdmark  
af4d ..			.dmark: db "-L>"  
af50 f1			.pastdmark: pop af  
af51			endm  
# End of macro DMARK
af51				CALLMONITOR 
af51 cd 2e 93			call break_point_state  
af54				endm  
# End of macro CALLMONITOR
af54			endif 
af54			 
af54					NEXTW 
af54 c3 24 9c			jp macro_next 
af57				endm 
# End of macro NEXTW
af57				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
af57			 
af57			.mloopnotdone: 
af57			 
af57 e1				pop hl    ; get I 
af58 2b				dec hl 
af59			 
af59			   	; save new I 
af59			 
af59			 
af59					; set I counter 
af59			 
af59 22 0b e8				ld (os_current_i), hl 
af5c			 
af5c					 
af5c				FORTH_LOOP_NEXT 
af5c cd e3 9a			call macro_forth_loop_next 
af5f				endm 
# End of macro FORTH_LOOP_NEXT
af5f			 
af5f			 
af5f					if DEBUG_FORTH_WORDS 
af5f eb						ex de,hl 
af60					endif 
af60			 
af60			;	; get DO ptr 
af60			; 
af60				FORTH_RSP_TOS 
af60 cd 79 98			call macro_forth_rsp_tos 
af63				endm 
# End of macro FORTH_RSP_TOS
af63			 
af63				;push hl 
af63			 
af63				; not going to DO any more 
af63				; get rid of the RSP pointer as DO will add it back in 
af63				;FORTH_RSP_POP 
af63				;pop hl 
af63			 
af63			 
af63 22 e7 e7			ld (os_tok_ptr), hl 
af66					if DEBUG_FORTH_WORDS 
af66						DMARK "-L<" 
af66 f5				push af  
af67 3a 7b af			ld a, (.dmark)  
af6a 32 c0 ee			ld (debug_mark),a  
af6d 3a 7c af			ld a, (.dmark+1)  
af70 32 c1 ee			ld (debug_mark+1),a  
af73 3a 7d af			ld a, (.dmark+2)  
af76 32 c2 ee			ld (debug_mark+2),a  
af79 18 03			jr .pastdmark  
af7b ..			.dmark: db "-L<"  
af7e f1			.pastdmark: pop af  
af7f			endm  
# End of macro DMARK
af7f					CALLMONITOR 
af7f cd 2e 93			call break_point_state  
af82				endm  
# End of macro CALLMONITOR
af82				endif 
af82 c3 b5 9c			jp exec1 
af85			 
af85					 
af85			 
af85			 
af85			 
af85				NEXTW 
af85 c3 24 9c			jp macro_next 
af88				endm 
# End of macro NEXTW
af88			 
af88			 
af88			 
af88			 
af88			.REPEAT: 
af88				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
af88 71				db WORD_SYS_CORE+93             
af89 db af			dw .UNTIL            
af8b 06				db 5 + 1 
af8c .. 00			db "REPEAT",0              
af93				endm 
# End of macro CWHEAD
af93			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
af93			;  push pc to rsp stack past the REPEAT 
af93					if DEBUG_FORTH_WORDS_KEY 
af93						DMARK "REP" 
af93 f5				push af  
af94 3a a8 af			ld a, (.dmark)  
af97 32 c0 ee			ld (debug_mark),a  
af9a 3a a9 af			ld a, (.dmark+1)  
af9d 32 c1 ee			ld (debug_mark+1),a  
afa0 3a aa af			ld a, (.dmark+2)  
afa3 32 c2 ee			ld (debug_mark+2),a  
afa6 18 03			jr .pastdmark  
afa8 ..			.dmark: db "REP"  
afab f1			.pastdmark: pop af  
afac			endm  
# End of macro DMARK
afac						CALLMONITOR 
afac cd 2e 93			call break_point_state  
afaf				endm  
# End of macro CALLMONITOR
afaf					endif 
afaf			 
afaf 2a e7 e7				ld hl, (os_tok_ptr) 
afb2 23					inc hl   ; R 
afb3 23					inc hl  ; E 
afb4 23					inc hl   ; P 
afb5 23					inc hl   ; E 
afb6 23					inc hl   ; A 
afb7 23					inc hl   ; T 
afb8 23					inc hl   ; zero 
afb9					FORTH_RSP_NEXT 
afb9 cd 62 98			call macro_forth_rsp_next 
afbc				endm 
# End of macro FORTH_RSP_NEXT
afbc			 
afbc			 
afbc					if DEBUG_FORTH_WORDS 
afbc						DMARK "REP" 
afbc f5				push af  
afbd 3a d1 af			ld a, (.dmark)  
afc0 32 c0 ee			ld (debug_mark),a  
afc3 3a d2 af			ld a, (.dmark+1)  
afc6 32 c1 ee			ld (debug_mark+1),a  
afc9 3a d3 af			ld a, (.dmark+2)  
afcc 32 c2 ee			ld (debug_mark+2),a  
afcf 18 03			jr .pastdmark  
afd1 ..			.dmark: db "REP"  
afd4 f1			.pastdmark: pop af  
afd5			endm  
# End of macro DMARK
afd5						;pop bc    ; TODO BUG ?????? what is this for???? 
afd5						CALLMONITOR 
afd5 cd 2e 93			call break_point_state  
afd8				endm  
# End of macro CALLMONITOR
afd8					endif 
afd8			 
afd8					NEXTW 
afd8 c3 24 9c			jp macro_next 
afdb				endm 
# End of macro NEXTW
afdb			;	       NEXTW 
afdb			 
afdb			.UNTIL: 
afdb				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
afdb 72				db WORD_SYS_CORE+94             
afdc 72 b0			dw .ENDFLOW            
afde 06				db 5 + 1 
afdf .. 00			db "UNTIL",0              
afe5				endm 
# End of macro CWHEAD
afe5			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
afe5			 
afe5				; pop tos as check 
afe5			 
afe5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
afe5			 
afe5				FORTH_DSP_VALUEHL 
afe5 cd b2 9a			call macro_dsp_valuehl 
afe8				endm 
# End of macro FORTH_DSP_VALUEHL
afe8			 
afe8					if DEBUG_FORTH_WORDS_KEY 
afe8						DMARK "UNT" 
afe8 f5				push af  
afe9 3a fd af			ld a, (.dmark)  
afec 32 c0 ee			ld (debug_mark),a  
afef 3a fe af			ld a, (.dmark+1)  
aff2 32 c1 ee			ld (debug_mark+1),a  
aff5 3a ff af			ld a, (.dmark+2)  
aff8 32 c2 ee			ld (debug_mark+2),a  
affb 18 03			jr .pastdmark  
affd ..			.dmark: db "UNT"  
b000 f1			.pastdmark: pop af  
b001			endm  
# End of macro DMARK
b001						CALLMONITOR 
b001 cd 2e 93			call break_point_state  
b004				endm  
# End of macro CALLMONITOR
b004					endif 
b004			 
b004			;	push hl 
b004				FORTH_DSP_POP 
b004 cd 6a 9b			call macro_forth_dsp_pop 
b007				endm 
# End of macro FORTH_DSP_POP
b007			 
b007			;	pop hl 
b007			 
b007				; test if true 
b007			 
b007 cd e4 8a			call ishlzero 
b00a			;	ld a,l 
b00a			;	add h 
b00a			; 
b00a			;	cp 0 
b00a			 
b00a 20 3e			jr nz, .untilnotdone 
b00c			 
b00c					if DEBUG_FORTH_WORDS 
b00c						DMARK "UNf" 
b00c f5				push af  
b00d 3a 21 b0			ld a, (.dmark)  
b010 32 c0 ee			ld (debug_mark),a  
b013 3a 22 b0			ld a, (.dmark+1)  
b016 32 c1 ee			ld (debug_mark+1),a  
b019 3a 23 b0			ld a, (.dmark+2)  
b01c 32 c2 ee			ld (debug_mark+2),a  
b01f 18 03			jr .pastdmark  
b021 ..			.dmark: db "UNf"  
b024 f1			.pastdmark: pop af  
b025			endm  
# End of macro DMARK
b025						CALLMONITOR 
b025 cd 2e 93			call break_point_state  
b028				endm  
# End of macro CALLMONITOR
b028					endif 
b028			 
b028			 
b028			 
b028				FORTH_RSP_POP     ; get rid of DO ptr 
b028 cd 83 98			call macro_forth_rsp_pop 
b02b				endm 
# End of macro FORTH_RSP_POP
b02b			 
b02b			if DEBUG_FORTH_WORDS 
b02b						DMARK "UN>" 
b02b f5				push af  
b02c 3a 40 b0			ld a, (.dmark)  
b02f 32 c0 ee			ld (debug_mark),a  
b032 3a 41 b0			ld a, (.dmark+1)  
b035 32 c1 ee			ld (debug_mark+1),a  
b038 3a 42 b0			ld a, (.dmark+2)  
b03b 32 c2 ee			ld (debug_mark+2),a  
b03e 18 03			jr .pastdmark  
b040 ..			.dmark: db "UN>"  
b043 f1			.pastdmark: pop af  
b044			endm  
# End of macro DMARK
b044				CALLMONITOR 
b044 cd 2e 93			call break_point_state  
b047				endm  
# End of macro CALLMONITOR
b047			endif 
b047			 
b047					NEXTW 
b047 c3 24 9c			jp macro_next 
b04a				endm 
# End of macro NEXTW
b04a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b04a			 
b04a			.untilnotdone: 
b04a			 
b04a			 
b04a			;	; get DO ptr 
b04a			; 
b04a				FORTH_RSP_TOS 
b04a cd 79 98			call macro_forth_rsp_tos 
b04d				endm 
# End of macro FORTH_RSP_TOS
b04d			 
b04d				;push hl 
b04d			 
b04d				; not going to DO any more 
b04d				; get rid of the RSP pointer as DO will add it back in 
b04d				;FORTH_RSP_POP 
b04d				;pop hl 
b04d			 
b04d			 
b04d 22 e7 e7			ld (os_tok_ptr), hl 
b050					if DEBUG_FORTH_WORDS 
b050						DMARK "UN<" 
b050 f5				push af  
b051 3a 65 b0			ld a, (.dmark)  
b054 32 c0 ee			ld (debug_mark),a  
b057 3a 66 b0			ld a, (.dmark+1)  
b05a 32 c1 ee			ld (debug_mark+1),a  
b05d 3a 67 b0			ld a, (.dmark+2)  
b060 32 c2 ee			ld (debug_mark+2),a  
b063 18 03			jr .pastdmark  
b065 ..			.dmark: db "UN<"  
b068 f1			.pastdmark: pop af  
b069			endm  
# End of macro DMARK
b069					CALLMONITOR 
b069 cd 2e 93			call break_point_state  
b06c				endm  
# End of macro CALLMONITOR
b06c				endif 
b06c c3 b5 9c			jp exec1 
b06f			 
b06f					 
b06f			 
b06f			 
b06f					NEXTW 
b06f c3 24 9c			jp macro_next 
b072				endm 
# End of macro NEXTW
b072			 
b072			 
b072			.ENDFLOW: 
b072			 
b072			; eof 
b072			 
# End of file forth_words_flow.asm
b072			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b072			include "forth_words_logic.asm" 
b072			 
b072			; | ## Logic Words 
b072			 
b072			.NOT: 
b072				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b072 2d				db WORD_SYS_CORE+25             
b073 ba b0			dw .IS            
b075 04				db 3 + 1 
b076 .. 00			db "NOT",0              
b07a				endm 
# End of macro CWHEAD
b07a			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b07a					if DEBUG_FORTH_WORDS_KEY 
b07a						DMARK "NOT" 
b07a f5				push af  
b07b 3a 8f b0			ld a, (.dmark)  
b07e 32 c0 ee			ld (debug_mark),a  
b081 3a 90 b0			ld a, (.dmark+1)  
b084 32 c1 ee			ld (debug_mark+1),a  
b087 3a 91 b0			ld a, (.dmark+2)  
b08a 32 c2 ee			ld (debug_mark+2),a  
b08d 18 03			jr .pastdmark  
b08f ..			.dmark: db "NOT"  
b092 f1			.pastdmark: pop af  
b093			endm  
# End of macro DMARK
b093						CALLMONITOR 
b093 cd 2e 93			call break_point_state  
b096				endm  
# End of macro CALLMONITOR
b096					endif 
b096					FORTH_DSP 
b096 cd 78 9a			call macro_forth_dsp 
b099				endm 
# End of macro FORTH_DSP
b099 7e					ld a,(hl)	; get type of value on TOS 
b09a fe 02				cp DS_TYPE_INUM  
b09c 28 03				jr z, .noti 
b09e					NEXTW 
b09e c3 24 9c			jp macro_next 
b0a1				endm 
# End of macro NEXTW
b0a1			.noti:          FORTH_DSP_VALUEHL 
b0a1 cd b2 9a			call macro_dsp_valuehl 
b0a4				endm 
# End of macro FORTH_DSP_VALUEHL
b0a4			;		push hl 
b0a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0a4 cd 6a 9b			call macro_forth_dsp_pop 
b0a7				endm 
# End of macro FORTH_DSP_POP
b0a7			;		pop hl 
b0a7 3e 00				ld a,0 
b0a9 bd					cp l 
b0aa 28 04				jr z, .not2t 
b0ac 2e 00				ld l, 0 
b0ae 18 02				jr .notip 
b0b0			 
b0b0 2e ff		.not2t:		ld l, 255 
b0b2			 
b0b2 26 00		.notip:		ld h, 0	 
b0b4			 
b0b4 cd bb 98				call forth_push_numhl 
b0b7					NEXTW 
b0b7 c3 24 9c			jp macro_next 
b0ba				endm 
# End of macro NEXTW
b0ba			 
b0ba			.IS: 
b0ba				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b0ba 2d				db WORD_SYS_CORE+25             
b0bb e0 b0			dw .LZERO            
b0bd 03				db 2 + 1 
b0be .. 00			db "IS",0              
b0c1				endm 
# End of macro CWHEAD
b0c1			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b0c1					if DEBUG_FORTH_WORDS_KEY 
b0c1						DMARK "IS." 
b0c1 f5				push af  
b0c2 3a d6 b0			ld a, (.dmark)  
b0c5 32 c0 ee			ld (debug_mark),a  
b0c8 3a d7 b0			ld a, (.dmark+1)  
b0cb 32 c1 ee			ld (debug_mark+1),a  
b0ce 3a d8 b0			ld a, (.dmark+2)  
b0d1 32 c2 ee			ld (debug_mark+2),a  
b0d4 18 03			jr .pastdmark  
b0d6 ..			.dmark: db "IS."  
b0d9 f1			.pastdmark: pop af  
b0da			endm  
# End of macro DMARK
b0da						CALLMONITOR 
b0da cd 2e 93			call break_point_state  
b0dd				endm  
# End of macro CALLMONITOR
b0dd					endif 
b0dd					NEXTW 
b0dd c3 24 9c			jp macro_next 
b0e0				endm 
# End of macro NEXTW
b0e0			.LZERO: 
b0e0				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b0e0 2d				db WORD_SYS_CORE+25             
b0e1 ea b0			dw .TZERO            
b0e3 03				db 2 + 1 
b0e4 .. 00			db "0<",0              
b0e7				endm 
# End of macro CWHEAD
b0e7			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b0e7					NEXTW 
b0e7 c3 24 9c			jp macro_next 
b0ea				endm 
# End of macro NEXTW
b0ea			.TZERO: 
b0ea				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b0ea 2e				db WORD_SYS_CORE+26             
b0eb 31 b1			dw .LESS            
b0ed 03				db 2 + 1 
b0ee .. 00			db "0=",0              
b0f1				endm 
# End of macro CWHEAD
b0f1			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b0f1				; TODO add floating point number detection 
b0f1					;v5 FORTH_DSP_VALUE 
b0f1					if DEBUG_FORTH_WORDS_KEY 
b0f1						DMARK "0=." 
b0f1 f5				push af  
b0f2 3a 06 b1			ld a, (.dmark)  
b0f5 32 c0 ee			ld (debug_mark),a  
b0f8 3a 07 b1			ld a, (.dmark+1)  
b0fb 32 c1 ee			ld (debug_mark+1),a  
b0fe 3a 08 b1			ld a, (.dmark+2)  
b101 32 c2 ee			ld (debug_mark+2),a  
b104 18 03			jr .pastdmark  
b106 ..			.dmark: db "0=."  
b109 f1			.pastdmark: pop af  
b10a			endm  
# End of macro DMARK
b10a						CALLMONITOR 
b10a cd 2e 93			call break_point_state  
b10d				endm  
# End of macro CALLMONITOR
b10d					endif 
b10d					FORTH_DSP 
b10d cd 78 9a			call macro_forth_dsp 
b110				endm 
# End of macro FORTH_DSP
b110 7e					ld a,(hl)	; get type of value on TOS 
b111 fe 02				cp DS_TYPE_INUM  
b113 28 00				jr z, .tz_inum 
b115			 
b115				if FORTH_ENABLE_FLOATMATH 
b115					jr .tz_done 
b115			 
b115				endif 
b115					 
b115			 
b115			.tz_inum: 
b115					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b115 cd b2 9a			call macro_dsp_valuehl 
b118				endm 
# End of macro FORTH_DSP_VALUEHL
b118			 
b118			;		push hl 
b118			 
b118					; destroy value TOS 
b118			 
b118					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b118 cd 6a 9b			call macro_forth_dsp_pop 
b11b				endm 
# End of macro FORTH_DSP_POP
b11b			 
b11b			;		pop hl 
b11b			 
b11b 3e 00				ld a,0 
b11d			 
b11d bd					cp l 
b11e 20 08				jr nz, .tz_notzero 
b120			 
b120 bc					cp h 
b121			 
b121 20 05				jr nz, .tz_notzero 
b123			 
b123			 
b123 21 01 00				ld hl, FORTH_TRUE 
b126 18 03				jr .tz_done 
b128			 
b128 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b12b			 
b12b					; push value back onto stack for another op etc 
b12b			 
b12b			.tz_done: 
b12b cd bb 98				call forth_push_numhl 
b12e			 
b12e					NEXTW 
b12e c3 24 9c			jp macro_next 
b131				endm 
# End of macro NEXTW
b131			.LESS: 
b131				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b131 2f				db WORD_SYS_CORE+27             
b132 9a b1			dw .GT            
b134 02				db 1 + 1 
b135 .. 00			db "<",0              
b137				endm 
# End of macro CWHEAD
b137			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b137				; TODO add floating point number detection 
b137					if DEBUG_FORTH_WORDS_KEY 
b137						DMARK "LES" 
b137 f5				push af  
b138 3a 4c b1			ld a, (.dmark)  
b13b 32 c0 ee			ld (debug_mark),a  
b13e 3a 4d b1			ld a, (.dmark+1)  
b141 32 c1 ee			ld (debug_mark+1),a  
b144 3a 4e b1			ld a, (.dmark+2)  
b147 32 c2 ee			ld (debug_mark+2),a  
b14a 18 03			jr .pastdmark  
b14c ..			.dmark: db "LES"  
b14f f1			.pastdmark: pop af  
b150			endm  
# End of macro DMARK
b150						CALLMONITOR 
b150 cd 2e 93			call break_point_state  
b153				endm  
# End of macro CALLMONITOR
b153					endif 
b153					FORTH_DSP 
b153 cd 78 9a			call macro_forth_dsp 
b156				endm 
# End of macro FORTH_DSP
b156					;v5 FORTH_DSP_VALUE 
b156 7e					ld a,(hl)	; get type of value on TOS 
b157 fe 02				cp DS_TYPE_INUM  
b159 28 00				jr z, .less_inum 
b15b			 
b15b				if FORTH_ENABLE_FLOATMATH 
b15b					jr .less_done 
b15b			 
b15b				endif 
b15b					 
b15b			 
b15b			.less_inum: 
b15b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b15b cd b2 9a			call macro_dsp_valuehl 
b15e				endm 
# End of macro FORTH_DSP_VALUEHL
b15e			 
b15e e5					push hl  ; u2 
b15f			 
b15f					; destroy value TOS 
b15f			 
b15f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b15f cd 6a 9b			call macro_forth_dsp_pop 
b162				endm 
# End of macro FORTH_DSP_POP
b162			 
b162			 
b162					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b162 cd b2 9a			call macro_dsp_valuehl 
b165				endm 
# End of macro FORTH_DSP_VALUEHL
b165			 
b165 e5					push hl    ; u1 
b166			 
b166					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b166 cd 6a 9b			call macro_forth_dsp_pop 
b169				endm 
# End of macro FORTH_DSP_POP
b169			 
b169			 
b169 b7			 or a      ;clear carry flag 
b16a 01 00 00		 ld bc, FORTH_FALSE 
b16d e1			  pop hl    ; u1 
b16e d1			  pop de    ; u2 
b16f ed 52		  sbc hl,de 
b171 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b173			 
b173 01 01 00		 ld bc, FORTH_TRUE 
b176			.lscont:  
b176 c5					push bc 
b177 e1					pop hl 
b178			 
b178					if DEBUG_FORTH_WORDS 
b178						DMARK "LT1" 
b178 f5				push af  
b179 3a 8d b1			ld a, (.dmark)  
b17c 32 c0 ee			ld (debug_mark),a  
b17f 3a 8e b1			ld a, (.dmark+1)  
b182 32 c1 ee			ld (debug_mark+1),a  
b185 3a 8f b1			ld a, (.dmark+2)  
b188 32 c2 ee			ld (debug_mark+2),a  
b18b 18 03			jr .pastdmark  
b18d ..			.dmark: db "LT1"  
b190 f1			.pastdmark: pop af  
b191			endm  
# End of macro DMARK
b191						CALLMONITOR 
b191 cd 2e 93			call break_point_state  
b194				endm  
# End of macro CALLMONITOR
b194					endif 
b194 cd bb 98				call forth_push_numhl 
b197			 
b197					NEXTW 
b197 c3 24 9c			jp macro_next 
b19a				endm 
# End of macro NEXTW
b19a			.GT: 
b19a				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b19a 30				db WORD_SYS_CORE+28             
b19b 03 b2			dw .EQUAL            
b19d 02				db 1 + 1 
b19e .. 00			db ">",0              
b1a0				endm 
# End of macro CWHEAD
b1a0			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b1a0				; TODO add floating point number detection 
b1a0					if DEBUG_FORTH_WORDS_KEY 
b1a0						DMARK "GRT" 
b1a0 f5				push af  
b1a1 3a b5 b1			ld a, (.dmark)  
b1a4 32 c0 ee			ld (debug_mark),a  
b1a7 3a b6 b1			ld a, (.dmark+1)  
b1aa 32 c1 ee			ld (debug_mark+1),a  
b1ad 3a b7 b1			ld a, (.dmark+2)  
b1b0 32 c2 ee			ld (debug_mark+2),a  
b1b3 18 03			jr .pastdmark  
b1b5 ..			.dmark: db "GRT"  
b1b8 f1			.pastdmark: pop af  
b1b9			endm  
# End of macro DMARK
b1b9						CALLMONITOR 
b1b9 cd 2e 93			call break_point_state  
b1bc				endm  
# End of macro CALLMONITOR
b1bc					endif 
b1bc					FORTH_DSP 
b1bc cd 78 9a			call macro_forth_dsp 
b1bf				endm 
# End of macro FORTH_DSP
b1bf					;FORTH_DSP_VALUE 
b1bf 7e					ld a,(hl)	; get type of value on TOS 
b1c0 fe 02				cp DS_TYPE_INUM  
b1c2 28 00				jr z, .gt_inum 
b1c4			 
b1c4				if FORTH_ENABLE_FLOATMATH 
b1c4					jr .gt_done 
b1c4			 
b1c4				endif 
b1c4					 
b1c4			 
b1c4			.gt_inum: 
b1c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1c4 cd b2 9a			call macro_dsp_valuehl 
b1c7				endm 
# End of macro FORTH_DSP_VALUEHL
b1c7			 
b1c7 e5					push hl  ; u2 
b1c8			 
b1c8					; destroy value TOS 
b1c8			 
b1c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1c8 cd 6a 9b			call macro_forth_dsp_pop 
b1cb				endm 
# End of macro FORTH_DSP_POP
b1cb			 
b1cb			 
b1cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1cb cd b2 9a			call macro_dsp_valuehl 
b1ce				endm 
# End of macro FORTH_DSP_VALUEHL
b1ce			 
b1ce e5					push hl    ; u1 
b1cf			 
b1cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1cf cd 6a 9b			call macro_forth_dsp_pop 
b1d2				endm 
# End of macro FORTH_DSP_POP
b1d2			 
b1d2			 
b1d2 b7			 or a      ;clear carry flag 
b1d3 01 00 00		 ld bc, FORTH_FALSE 
b1d6 e1			  pop hl    ; u1 
b1d7 d1			  pop de    ; u2 
b1d8 ed 52		  sbc hl,de 
b1da 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b1dc			 
b1dc 01 01 00		 ld bc, FORTH_TRUE 
b1df			.gtcont:  
b1df c5					push bc 
b1e0 e1					pop hl 
b1e1			 
b1e1					if DEBUG_FORTH_WORDS 
b1e1						DMARK "GT1" 
b1e1 f5				push af  
b1e2 3a f6 b1			ld a, (.dmark)  
b1e5 32 c0 ee			ld (debug_mark),a  
b1e8 3a f7 b1			ld a, (.dmark+1)  
b1eb 32 c1 ee			ld (debug_mark+1),a  
b1ee 3a f8 b1			ld a, (.dmark+2)  
b1f1 32 c2 ee			ld (debug_mark+2),a  
b1f4 18 03			jr .pastdmark  
b1f6 ..			.dmark: db "GT1"  
b1f9 f1			.pastdmark: pop af  
b1fa			endm  
# End of macro DMARK
b1fa						CALLMONITOR 
b1fa cd 2e 93			call break_point_state  
b1fd				endm  
# End of macro CALLMONITOR
b1fd					endif 
b1fd cd bb 98				call forth_push_numhl 
b200			 
b200					NEXTW 
b200 c3 24 9c			jp macro_next 
b203				endm 
# End of macro NEXTW
b203			.EQUAL: 
b203				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b203 31				db WORD_SYS_CORE+29             
b204 6e b2			dw .ENDLOGIC            
b206 02				db 1 + 1 
b207 .. 00			db "=",0              
b209				endm 
# End of macro CWHEAD
b209			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b209				; TODO add floating point number detection 
b209					if DEBUG_FORTH_WORDS_KEY 
b209						DMARK "EQ." 
b209 f5				push af  
b20a 3a 1e b2			ld a, (.dmark)  
b20d 32 c0 ee			ld (debug_mark),a  
b210 3a 1f b2			ld a, (.dmark+1)  
b213 32 c1 ee			ld (debug_mark+1),a  
b216 3a 20 b2			ld a, (.dmark+2)  
b219 32 c2 ee			ld (debug_mark+2),a  
b21c 18 03			jr .pastdmark  
b21e ..			.dmark: db "EQ."  
b221 f1			.pastdmark: pop af  
b222			endm  
# End of macro DMARK
b222						CALLMONITOR 
b222 cd 2e 93			call break_point_state  
b225				endm  
# End of macro CALLMONITOR
b225					endif 
b225					FORTH_DSP 
b225 cd 78 9a			call macro_forth_dsp 
b228				endm 
# End of macro FORTH_DSP
b228					;v5 FORTH_DSP_VALUE 
b228 7e					ld a,(hl)	; get type of value on TOS 
b229 fe 02				cp DS_TYPE_INUM  
b22b 28 00				jr z, .eq_inum 
b22d			 
b22d				if FORTH_ENABLE_FLOATMATH 
b22d					jr .eq_done 
b22d			 
b22d				endif 
b22d					 
b22d			 
b22d			.eq_inum: 
b22d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b22d cd b2 9a			call macro_dsp_valuehl 
b230				endm 
# End of macro FORTH_DSP_VALUEHL
b230			 
b230 e5					push hl 
b231			 
b231					; destroy value TOS 
b231			 
b231					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b231 cd 6a 9b			call macro_forth_dsp_pop 
b234				endm 
# End of macro FORTH_DSP_POP
b234			 
b234			 
b234					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b234 cd b2 9a			call macro_dsp_valuehl 
b237				endm 
# End of macro FORTH_DSP_VALUEHL
b237			 
b237					; one value on hl get other one back 
b237			 
b237 e5					push hl 
b238			 
b238					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b238 cd 6a 9b			call macro_forth_dsp_pop 
b23b				endm 
# End of macro FORTH_DSP_POP
b23b			 
b23b 0e 00				ld c, FORTH_FALSE 
b23d			 
b23d e1					pop hl 
b23e d1					pop de 
b23f			 
b23f 7b					ld a, e 
b240 bd					cp l 
b241			 
b241 20 06				jr nz, .eq_done 
b243			 
b243 7a					ld a, d 
b244 bc					cp h 
b245			 
b245 20 02				jr nz, .eq_done 
b247			 
b247 0e 01				ld c, FORTH_TRUE 
b249					 
b249			 
b249			 
b249			.eq_done: 
b249			 
b249					; TODO push value back onto stack for another op etc 
b249			 
b249 26 00				ld h, 0 
b24b 69					ld l, c 
b24c					if DEBUG_FORTH_WORDS 
b24c						DMARK "EQ1" 
b24c f5				push af  
b24d 3a 61 b2			ld a, (.dmark)  
b250 32 c0 ee			ld (debug_mark),a  
b253 3a 62 b2			ld a, (.dmark+1)  
b256 32 c1 ee			ld (debug_mark+1),a  
b259 3a 63 b2			ld a, (.dmark+2)  
b25c 32 c2 ee			ld (debug_mark+2),a  
b25f 18 03			jr .pastdmark  
b261 ..			.dmark: db "EQ1"  
b264 f1			.pastdmark: pop af  
b265			endm  
# End of macro DMARK
b265						CALLMONITOR 
b265 cd 2e 93			call break_point_state  
b268				endm  
# End of macro CALLMONITOR
b268					endif 
b268 cd bb 98				call forth_push_numhl 
b26b			 
b26b					NEXTW 
b26b c3 24 9c			jp macro_next 
b26e				endm 
# End of macro NEXTW
b26e			 
b26e			 
b26e			.ENDLOGIC: 
b26e			; eof 
b26e			 
b26e			 
# End of file forth_words_logic.asm
b26e			include "forth_words_maths.asm" 
b26e			 
b26e			; | ## Maths Words 
b26e			 
b26e			.PLUS:	 
b26e				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b26e 15				db WORD_SYS_CORE+1             
b26f b0 b2			dw .NEG            
b271 02				db 1 + 1 
b272 .. 00			db "+",0              
b274				endm 
# End of macro CWHEAD
b274			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b274					if DEBUG_FORTH_WORDS_KEY 
b274						DMARK "PLU" 
b274 f5				push af  
b275 3a 89 b2			ld a, (.dmark)  
b278 32 c0 ee			ld (debug_mark),a  
b27b 3a 8a b2			ld a, (.dmark+1)  
b27e 32 c1 ee			ld (debug_mark+1),a  
b281 3a 8b b2			ld a, (.dmark+2)  
b284 32 c2 ee			ld (debug_mark+2),a  
b287 18 03			jr .pastdmark  
b289 ..			.dmark: db "PLU"  
b28c f1			.pastdmark: pop af  
b28d			endm  
# End of macro DMARK
b28d						CALLMONITOR 
b28d cd 2e 93			call break_point_state  
b290				endm  
# End of macro CALLMONITOR
b290					endif 
b290					; add top two values and push back result 
b290			 
b290					;for v5 FORTH_DSP_VALUE 
b290					FORTH_DSP 
b290 cd 78 9a			call macro_forth_dsp 
b293				endm 
# End of macro FORTH_DSP
b293 7e					ld a,(hl)	; get type of value on TOS 
b294 fe 02				cp DS_TYPE_INUM  
b296 28 03				jr z, .dot_inum 
b298			 
b298					NEXTW 
b298 c3 24 9c			jp macro_next 
b29b				endm 
# End of macro NEXTW
b29b			 
b29b			; float maths 
b29b			 
b29b				if FORTH_ENABLE_FLOATMATH 
b29b						inc hl      ; now at start of numeric as string 
b29b			 
b29b					if DEBUG_FORTH_MATHS 
b29b						DMARK "ADD" 
b29b				CALLMONITOR 
b29b					endif 
b29b			 
b29b					;ld ix, hl 
b29b					call CON 
b29b			 
b29b			 
b29b					push hl 
b29b					 
b29b					 
b29b			 
b29b						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b29b			 
b29b					; get next number 
b29b			 
b29b						FORTH_DSP_VALUE 
b29b			 
b29b						inc hl      ; now at start of numeric as string 
b29b			 
b29b					;ld ix, hl 
b29b					call CON 
b29b			 
b29b					push hl 
b29b			 
b29b			 
b29b						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b29b			 
b29b						; TODO do add 
b29b			 
b29b						call IADD 
b29b			 
b29b						; TODO get result back as ascii 
b29b			 
b29b						; TODO push result  
b29b			 
b29b			 
b29b			 
b29b						jr .dot_done 
b29b				endif 
b29b			 
b29b			.dot_inum: 
b29b			 
b29b			 
b29b					if DEBUG_FORTH_DOT 
b29b						DMARK "+IT" 
b29b				CALLMONITOR 
b29b					endif 
b29b			 
b29b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b29b cd b2 9a			call macro_dsp_valuehl 
b29e				endm 
# End of macro FORTH_DSP_VALUEHL
b29e			 
b29e				; TODO add floating point number detection 
b29e			 
b29e e5					push hl 
b29f			 
b29f					; destroy value TOS 
b29f			 
b29f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b29f cd 6a 9b			call macro_forth_dsp_pop 
b2a2				endm 
# End of macro FORTH_DSP_POP
b2a2			 
b2a2			 
b2a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2a2 cd b2 9a			call macro_dsp_valuehl 
b2a5				endm 
# End of macro FORTH_DSP_VALUEHL
b2a5			 
b2a5					; one value on hl get other one back 
b2a5			 
b2a5 d1					pop de 
b2a6			 
b2a6					; do the add 
b2a6			 
b2a6 19					add hl,de 
b2a7			 
b2a7					; save it 
b2a7			 
b2a7			;		push hl	 
b2a7			 
b2a7					; 
b2a7			 
b2a7					; destroy value TOS 
b2a7			 
b2a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2a7 cd 6a 9b			call macro_forth_dsp_pop 
b2aa				endm 
# End of macro FORTH_DSP_POP
b2aa			 
b2aa					; TODO push value back onto stack for another op etc 
b2aa			 
b2aa			;		pop hl 
b2aa			 
b2aa			.dot_done: 
b2aa cd bb 98				call forth_push_numhl 
b2ad			 
b2ad					NEXTW 
b2ad c3 24 9c			jp macro_next 
b2b0				endm 
# End of macro NEXTW
b2b0			.NEG: 
b2b0			 
b2b0				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b2b0 17				db WORD_SYS_CORE+3             
b2b1 f3 b2			dw .DIV            
b2b3 02				db 1 + 1 
b2b4 .. 00			db "-",0              
b2b6				endm 
# End of macro CWHEAD
b2b6			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b2b6					if DEBUG_FORTH_WORDS_KEY 
b2b6						DMARK "SUB" 
b2b6 f5				push af  
b2b7 3a cb b2			ld a, (.dmark)  
b2ba 32 c0 ee			ld (debug_mark),a  
b2bd 3a cc b2			ld a, (.dmark+1)  
b2c0 32 c1 ee			ld (debug_mark+1),a  
b2c3 3a cd b2			ld a, (.dmark+2)  
b2c6 32 c2 ee			ld (debug_mark+2),a  
b2c9 18 03			jr .pastdmark  
b2cb ..			.dmark: db "SUB"  
b2ce f1			.pastdmark: pop af  
b2cf			endm  
# End of macro DMARK
b2cf						CALLMONITOR 
b2cf cd 2e 93			call break_point_state  
b2d2				endm  
# End of macro CALLMONITOR
b2d2					endif 
b2d2			 
b2d2			 
b2d2				; TODO add floating point number detection 
b2d2					; v5 FORTH_DSP_VALUE 
b2d2					FORTH_DSP 
b2d2 cd 78 9a			call macro_forth_dsp 
b2d5				endm 
# End of macro FORTH_DSP
b2d5 7e					ld a,(hl)	; get type of value on TOS 
b2d6 fe 02				cp DS_TYPE_INUM  
b2d8 28 03				jr z, .neg_inum 
b2da			 
b2da					NEXTW 
b2da c3 24 9c			jp macro_next 
b2dd				endm 
# End of macro NEXTW
b2dd			 
b2dd			; float maths 
b2dd			 
b2dd				if FORTH_ENABLE_FLOATMATH 
b2dd					jr .neg_done 
b2dd			 
b2dd				endif 
b2dd					 
b2dd			 
b2dd			.neg_inum: 
b2dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2dd cd b2 9a			call macro_dsp_valuehl 
b2e0				endm 
# End of macro FORTH_DSP_VALUEHL
b2e0			 
b2e0 e5					push hl 
b2e1			 
b2e1					; destroy value TOS 
b2e1			 
b2e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2e1 cd 6a 9b			call macro_forth_dsp_pop 
b2e4				endm 
# End of macro FORTH_DSP_POP
b2e4			 
b2e4			 
b2e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2e4 cd b2 9a			call macro_dsp_valuehl 
b2e7				endm 
# End of macro FORTH_DSP_VALUEHL
b2e7			 
b2e7					; one value on hl get other one back 
b2e7			 
b2e7 d1					pop de 
b2e8			 
b2e8					; do the sub 
b2e8			;		ex de, hl 
b2e8			 
b2e8 ed 52				sbc hl,de 
b2ea			 
b2ea					; save it 
b2ea			 
b2ea			;		push hl	 
b2ea			 
b2ea					; 
b2ea			 
b2ea					; destroy value TOS 
b2ea			 
b2ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2ea cd 6a 9b			call macro_forth_dsp_pop 
b2ed				endm 
# End of macro FORTH_DSP_POP
b2ed			 
b2ed					; TODO push value back onto stack for another op etc 
b2ed			 
b2ed			;		pop hl 
b2ed			 
b2ed cd bb 98				call forth_push_numhl 
b2f0			.neg_done: 
b2f0			 
b2f0					NEXTW 
b2f0 c3 24 9c			jp macro_next 
b2f3				endm 
# End of macro NEXTW
b2f3			.DIV: 
b2f3				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b2f3 18				db WORD_SYS_CORE+4             
b2f4 40 b3			dw .MUL            
b2f6 02				db 1 + 1 
b2f7 .. 00			db "/",0              
b2f9				endm 
# End of macro CWHEAD
b2f9			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b2f9					if DEBUG_FORTH_WORDS_KEY 
b2f9						DMARK "DIV" 
b2f9 f5				push af  
b2fa 3a 0e b3			ld a, (.dmark)  
b2fd 32 c0 ee			ld (debug_mark),a  
b300 3a 0f b3			ld a, (.dmark+1)  
b303 32 c1 ee			ld (debug_mark+1),a  
b306 3a 10 b3			ld a, (.dmark+2)  
b309 32 c2 ee			ld (debug_mark+2),a  
b30c 18 03			jr .pastdmark  
b30e ..			.dmark: db "DIV"  
b311 f1			.pastdmark: pop af  
b312			endm  
# End of macro DMARK
b312						CALLMONITOR 
b312 cd 2e 93			call break_point_state  
b315				endm  
# End of macro CALLMONITOR
b315					endif 
b315				; TODO add floating point number detection 
b315					; v5 FORTH_DSP_VALUE 
b315					FORTH_DSP 
b315 cd 78 9a			call macro_forth_dsp 
b318				endm 
# End of macro FORTH_DSP
b318 7e					ld a,(hl)	; get type of value on TOS 
b319 fe 02				cp DS_TYPE_INUM  
b31b 28 03				jr z, .div_inum 
b31d			 
b31d				if FORTH_ENABLE_FLOATMATH 
b31d					jr .div_done 
b31d			 
b31d				endif 
b31d					NEXTW 
b31d c3 24 9c			jp macro_next 
b320				endm 
# End of macro NEXTW
b320			.div_inum: 
b320			 
b320					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b320 cd b2 9a			call macro_dsp_valuehl 
b323				endm 
# End of macro FORTH_DSP_VALUEHL
b323			 
b323 e5					push hl    ; to go to bc 
b324			 
b324					; destroy value TOS 
b324			 
b324					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b324 cd 6a 9b			call macro_forth_dsp_pop 
b327				endm 
# End of macro FORTH_DSP_POP
b327			 
b327			 
b327					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b327 cd b2 9a			call macro_dsp_valuehl 
b32a				endm 
# End of macro FORTH_DSP_VALUEHL
b32a			 
b32a					; hl to go to de 
b32a			 
b32a e5					push hl 
b32b			 
b32b c1					pop bc 
b32c d1					pop de		 
b32d			 
b32d			 
b32d					if DEBUG_FORTH_MATHS 
b32d						DMARK "DIV" 
b32d				CALLMONITOR 
b32d					endif 
b32d					; one value on hl but move to a get other one back 
b32d			 
b32d			        
b32d cd 18 8a			call Div16 
b330			 
b330			;	push af	 
b330 e5				push hl 
b331 c5				push bc 
b332			 
b332					if DEBUG_FORTH_MATHS 
b332						DMARK "DI1" 
b332				CALLMONITOR 
b332					endif 
b332			 
b332					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b332 cd 6a 9b			call macro_forth_dsp_pop 
b335				endm 
# End of macro FORTH_DSP_POP
b335			 
b335			 
b335			 
b335 e1					pop hl    ; result 
b336			 
b336 cd bb 98				call forth_push_numhl 
b339			 
b339 e1					pop hl    ; reminder 
b33a			;		ld h,0 
b33a			;		ld l,d 
b33a			 
b33a cd bb 98				call forth_push_numhl 
b33d			.div_done: 
b33d					NEXTW 
b33d c3 24 9c			jp macro_next 
b340				endm 
# End of macro NEXTW
b340			.MUL: 
b340				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b340 19				db WORD_SYS_CORE+5             
b341 85 b3			dw .MIN            
b343 02				db 1 + 1 
b344 .. 00			db "*",0              
b346				endm 
# End of macro CWHEAD
b346			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b346				; TODO add floating point number detection 
b346					if DEBUG_FORTH_WORDS_KEY 
b346						DMARK "MUL" 
b346 f5				push af  
b347 3a 5b b3			ld a, (.dmark)  
b34a 32 c0 ee			ld (debug_mark),a  
b34d 3a 5c b3			ld a, (.dmark+1)  
b350 32 c1 ee			ld (debug_mark+1),a  
b353 3a 5d b3			ld a, (.dmark+2)  
b356 32 c2 ee			ld (debug_mark+2),a  
b359 18 03			jr .pastdmark  
b35b ..			.dmark: db "MUL"  
b35e f1			.pastdmark: pop af  
b35f			endm  
# End of macro DMARK
b35f						CALLMONITOR 
b35f cd 2e 93			call break_point_state  
b362				endm  
# End of macro CALLMONITOR
b362					endif 
b362					FORTH_DSP 
b362 cd 78 9a			call macro_forth_dsp 
b365				endm 
# End of macro FORTH_DSP
b365					; v5 FORTH_DSP_VALUE 
b365 7e					ld a,(hl)	; get type of value on TOS 
b366 fe 02				cp DS_TYPE_INUM  
b368 28 03				jr z, .mul_inum 
b36a			 
b36a				if FORTH_ENABLE_FLOATMATH 
b36a					jr .mul_done 
b36a			 
b36a				endif 
b36a			 
b36a					NEXTW 
b36a c3 24 9c			jp macro_next 
b36d				endm 
# End of macro NEXTW
b36d			.mul_inum:	 
b36d			 
b36d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b36d cd b2 9a			call macro_dsp_valuehl 
b370				endm 
# End of macro FORTH_DSP_VALUEHL
b370			 
b370 e5					push hl 
b371			 
b371					; destroy value TOS 
b371			 
b371					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b371 cd 6a 9b			call macro_forth_dsp_pop 
b374				endm 
# End of macro FORTH_DSP_POP
b374			 
b374			 
b374					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b374 cd b2 9a			call macro_dsp_valuehl 
b377				endm 
# End of macro FORTH_DSP_VALUEHL
b377			 
b377					; one value on hl but move to a get other one back 
b377			 
b377 7d					ld a, l 
b378			 
b378 d1					pop de 
b379			 
b379					; do the mull 
b379			;		ex de, hl 
b379			 
b379 cd 3e 8a				call Mult16 
b37c					; save it 
b37c			 
b37c			;		push hl	 
b37c			 
b37c					; 
b37c			 
b37c					; destroy value TOS 
b37c			 
b37c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b37c cd 6a 9b			call macro_forth_dsp_pop 
b37f				endm 
# End of macro FORTH_DSP_POP
b37f			 
b37f					; TODO push value back onto stack for another op etc 
b37f			 
b37f			;		pop hl 
b37f			 
b37f cd bb 98				call forth_push_numhl 
b382			 
b382			.mul_done: 
b382					NEXTW 
b382 c3 24 9c			jp macro_next 
b385				endm 
# End of macro NEXTW
b385			 
b385			 
b385			 
b385			 
b385			.MIN: 
b385				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b385 49				db WORD_SYS_CORE+53             
b386 06 b4			dw .MAX            
b388 04				db 3 + 1 
b389 .. 00			db "MIN",0              
b38d				endm 
# End of macro CWHEAD
b38d			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b38d					if DEBUG_FORTH_WORDS_KEY 
b38d						DMARK "MIN" 
b38d f5				push af  
b38e 3a a2 b3			ld a, (.dmark)  
b391 32 c0 ee			ld (debug_mark),a  
b394 3a a3 b3			ld a, (.dmark+1)  
b397 32 c1 ee			ld (debug_mark+1),a  
b39a 3a a4 b3			ld a, (.dmark+2)  
b39d 32 c2 ee			ld (debug_mark+2),a  
b3a0 18 03			jr .pastdmark  
b3a2 ..			.dmark: db "MIN"  
b3a5 f1			.pastdmark: pop af  
b3a6			endm  
# End of macro DMARK
b3a6						CALLMONITOR 
b3a6 cd 2e 93			call break_point_state  
b3a9				endm  
# End of macro CALLMONITOR
b3a9					endif 
b3a9					; get u2 
b3a9			 
b3a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3a9 cd b2 9a			call macro_dsp_valuehl 
b3ac				endm 
# End of macro FORTH_DSP_VALUEHL
b3ac			 
b3ac e5					push hl   ; u2 
b3ad			 
b3ad					; destroy value TOS 
b3ad			 
b3ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3ad cd 6a 9b			call macro_forth_dsp_pop 
b3b0				endm 
# End of macro FORTH_DSP_POP
b3b0			 
b3b0					; get u1 
b3b0			 
b3b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3b0 cd b2 9a			call macro_dsp_valuehl 
b3b3				endm 
# End of macro FORTH_DSP_VALUEHL
b3b3			 
b3b3 e5					push hl  ; u1 
b3b4			 
b3b4					; destroy value TOS 
b3b4			 
b3b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3b4 cd 6a 9b			call macro_forth_dsp_pop 
b3b7				endm 
# End of macro FORTH_DSP_POP
b3b7			 
b3b7 b7			 or a      ;clear carry flag 
b3b8 e1			  pop hl    ; u1 
b3b9 d1			  pop de    ; u2 
b3ba e5				push hl   ; saved in case hl is lowest 
b3bb ed 52		  sbc hl,de 
b3bd 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b3bf			 
b3bf e1				pop hl 
b3c0					if DEBUG_FORTH_WORDS 
b3c0						DMARK "MIN" 
b3c0 f5				push af  
b3c1 3a d5 b3			ld a, (.dmark)  
b3c4 32 c0 ee			ld (debug_mark),a  
b3c7 3a d6 b3			ld a, (.dmark+1)  
b3ca 32 c1 ee			ld (debug_mark+1),a  
b3cd 3a d7 b3			ld a, (.dmark+2)  
b3d0 32 c2 ee			ld (debug_mark+2),a  
b3d3 18 03			jr .pastdmark  
b3d5 ..			.dmark: db "MIN"  
b3d8 f1			.pastdmark: pop af  
b3d9			endm  
# End of macro DMARK
b3d9						CALLMONITOR 
b3d9 cd 2e 93			call break_point_state  
b3dc				endm  
# End of macro CALLMONITOR
b3dc					endif 
b3dc cd bb 98				call forth_push_numhl 
b3df			 
b3df				       NEXTW 
b3df c3 24 9c			jp macro_next 
b3e2				endm 
# End of macro NEXTW
b3e2			 
b3e2			.mincont:  
b3e2 c1				pop bc   ; tidy up 
b3e3 eb				ex de , hl  
b3e4					if DEBUG_FORTH_WORDS 
b3e4						DMARK "MI1" 
b3e4 f5				push af  
b3e5 3a f9 b3			ld a, (.dmark)  
b3e8 32 c0 ee			ld (debug_mark),a  
b3eb 3a fa b3			ld a, (.dmark+1)  
b3ee 32 c1 ee			ld (debug_mark+1),a  
b3f1 3a fb b3			ld a, (.dmark+2)  
b3f4 32 c2 ee			ld (debug_mark+2),a  
b3f7 18 03			jr .pastdmark  
b3f9 ..			.dmark: db "MI1"  
b3fc f1			.pastdmark: pop af  
b3fd			endm  
# End of macro DMARK
b3fd						CALLMONITOR 
b3fd cd 2e 93			call break_point_state  
b400				endm  
# End of macro CALLMONITOR
b400					endif 
b400 cd bb 98				call forth_push_numhl 
b403			 
b403				       NEXTW 
b403 c3 24 9c			jp macro_next 
b406				endm 
# End of macro NEXTW
b406			.MAX: 
b406				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b406 4a				db WORD_SYS_CORE+54             
b407 87 b4			dw .RND16            
b409 04				db 3 + 1 
b40a .. 00			db "MAX",0              
b40e				endm 
# End of macro CWHEAD
b40e			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b40e					if DEBUG_FORTH_WORDS_KEY 
b40e						DMARK "MAX" 
b40e f5				push af  
b40f 3a 23 b4			ld a, (.dmark)  
b412 32 c0 ee			ld (debug_mark),a  
b415 3a 24 b4			ld a, (.dmark+1)  
b418 32 c1 ee			ld (debug_mark+1),a  
b41b 3a 25 b4			ld a, (.dmark+2)  
b41e 32 c2 ee			ld (debug_mark+2),a  
b421 18 03			jr .pastdmark  
b423 ..			.dmark: db "MAX"  
b426 f1			.pastdmark: pop af  
b427			endm  
# End of macro DMARK
b427						CALLMONITOR 
b427 cd 2e 93			call break_point_state  
b42a				endm  
# End of macro CALLMONITOR
b42a					endif 
b42a					; get u2 
b42a			 
b42a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b42a cd b2 9a			call macro_dsp_valuehl 
b42d				endm 
# End of macro FORTH_DSP_VALUEHL
b42d			 
b42d e5					push hl   ; u2 
b42e			 
b42e					; destroy value TOS 
b42e			 
b42e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b42e cd 6a 9b			call macro_forth_dsp_pop 
b431				endm 
# End of macro FORTH_DSP_POP
b431			 
b431					; get u1 
b431			 
b431					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b431 cd b2 9a			call macro_dsp_valuehl 
b434				endm 
# End of macro FORTH_DSP_VALUEHL
b434			 
b434 e5					push hl  ; u1 
b435			 
b435					; destroy value TOS 
b435			 
b435					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b435 cd 6a 9b			call macro_forth_dsp_pop 
b438				endm 
# End of macro FORTH_DSP_POP
b438			 
b438 b7			 or a      ;clear carry flag 
b439 e1			  pop hl    ; u1 
b43a d1			  pop de    ; u2 
b43b e5				push hl   ; saved in case hl is lowest 
b43c ed 52		  sbc hl,de 
b43e 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b440			 
b440 e1				pop hl 
b441					if DEBUG_FORTH_WORDS 
b441						DMARK "MAX" 
b441 f5				push af  
b442 3a 56 b4			ld a, (.dmark)  
b445 32 c0 ee			ld (debug_mark),a  
b448 3a 57 b4			ld a, (.dmark+1)  
b44b 32 c1 ee			ld (debug_mark+1),a  
b44e 3a 58 b4			ld a, (.dmark+2)  
b451 32 c2 ee			ld (debug_mark+2),a  
b454 18 03			jr .pastdmark  
b456 ..			.dmark: db "MAX"  
b459 f1			.pastdmark: pop af  
b45a			endm  
# End of macro DMARK
b45a						CALLMONITOR 
b45a cd 2e 93			call break_point_state  
b45d				endm  
# End of macro CALLMONITOR
b45d					endif 
b45d cd bb 98				call forth_push_numhl 
b460			 
b460				       NEXTW 
b460 c3 24 9c			jp macro_next 
b463				endm 
# End of macro NEXTW
b463			 
b463			.maxcont:  
b463 c1				pop bc   ; tidy up 
b464 eb				ex de , hl  
b465					if DEBUG_FORTH_WORDS 
b465						DMARK "MA1" 
b465 f5				push af  
b466 3a 7a b4			ld a, (.dmark)  
b469 32 c0 ee			ld (debug_mark),a  
b46c 3a 7b b4			ld a, (.dmark+1)  
b46f 32 c1 ee			ld (debug_mark+1),a  
b472 3a 7c b4			ld a, (.dmark+2)  
b475 32 c2 ee			ld (debug_mark+2),a  
b478 18 03			jr .pastdmark  
b47a ..			.dmark: db "MA1"  
b47d f1			.pastdmark: pop af  
b47e			endm  
# End of macro DMARK
b47e						CALLMONITOR 
b47e cd 2e 93			call break_point_state  
b481				endm  
# End of macro CALLMONITOR
b481					endif 
b481 cd bb 98				call forth_push_numhl 
b484				       NEXTW 
b484 c3 24 9c			jp macro_next 
b487				endm 
# End of macro NEXTW
b487			 
b487			.RND16: 
b487				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b487 4e				db WORD_SYS_CORE+58             
b488 b6 b4			dw .RND8            
b48a 06				db 5 + 1 
b48b .. 00			db "RND16",0              
b491				endm 
# End of macro CWHEAD
b491			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b491					if DEBUG_FORTH_WORDS_KEY 
b491						DMARK "R16" 
b491 f5				push af  
b492 3a a6 b4			ld a, (.dmark)  
b495 32 c0 ee			ld (debug_mark),a  
b498 3a a7 b4			ld a, (.dmark+1)  
b49b 32 c1 ee			ld (debug_mark+1),a  
b49e 3a a8 b4			ld a, (.dmark+2)  
b4a1 32 c2 ee			ld (debug_mark+2),a  
b4a4 18 03			jr .pastdmark  
b4a6 ..			.dmark: db "R16"  
b4a9 f1			.pastdmark: pop af  
b4aa			endm  
# End of macro DMARK
b4aa						CALLMONITOR 
b4aa cd 2e 93			call break_point_state  
b4ad				endm  
# End of macro CALLMONITOR
b4ad					endif 
b4ad cd e2 89				call prng16  
b4b0 cd bb 98				call forth_push_numhl 
b4b3				       NEXTW 
b4b3 c3 24 9c			jp macro_next 
b4b6				endm 
# End of macro NEXTW
b4b6			.RND8: 
b4b6				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b4b6 60				db WORD_SYS_CORE+76             
b4b7 eb b4			dw .RND            
b4b9 05				db 4 + 1 
b4ba .. 00			db "RND8",0              
b4bf				endm 
# End of macro CWHEAD
b4bf			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b4bf					if DEBUG_FORTH_WORDS_KEY 
b4bf						DMARK "RN8" 
b4bf f5				push af  
b4c0 3a d4 b4			ld a, (.dmark)  
b4c3 32 c0 ee			ld (debug_mark),a  
b4c6 3a d5 b4			ld a, (.dmark+1)  
b4c9 32 c1 ee			ld (debug_mark+1),a  
b4cc 3a d6 b4			ld a, (.dmark+2)  
b4cf 32 c2 ee			ld (debug_mark+2),a  
b4d2 18 03			jr .pastdmark  
b4d4 ..			.dmark: db "RN8"  
b4d7 f1			.pastdmark: pop af  
b4d8			endm  
# End of macro DMARK
b4d8						CALLMONITOR 
b4d8 cd 2e 93			call break_point_state  
b4db				endm  
# End of macro CALLMONITOR
b4db					endif 
b4db 2a 41 ed				ld hl,(xrandc) 
b4de 23					inc hl 
b4df cd fc 89				call xrnd 
b4e2 6f					ld l,a	 
b4e3 26 00				ld h,0 
b4e5 cd bb 98				call forth_push_numhl 
b4e8				       NEXTW 
b4e8 c3 24 9c			jp macro_next 
b4eb				endm 
# End of macro NEXTW
b4eb			.RND: 
b4eb				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b4eb 60				db WORD_SYS_CORE+76             
b4ec f1 b5			dw .ENDMATHS            
b4ee 04				db 3 + 1 
b4ef .. 00			db "RND",0              
b4f3				endm 
# End of macro CWHEAD
b4f3			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b4f3			 
b4f3					if DEBUG_FORTH_WORDS_KEY 
b4f3						DMARK "RND" 
b4f3 f5				push af  
b4f4 3a 08 b5			ld a, (.dmark)  
b4f7 32 c0 ee			ld (debug_mark),a  
b4fa 3a 09 b5			ld a, (.dmark+1)  
b4fd 32 c1 ee			ld (debug_mark+1),a  
b500 3a 0a b5			ld a, (.dmark+2)  
b503 32 c2 ee			ld (debug_mark+2),a  
b506 18 03			jr .pastdmark  
b508 ..			.dmark: db "RND"  
b50b f1			.pastdmark: pop af  
b50c			endm  
# End of macro DMARK
b50c						CALLMONITOR 
b50c cd 2e 93			call break_point_state  
b50f				endm  
# End of macro CALLMONITOR
b50f					endif 
b50f					 
b50f					FORTH_DSP_VALUEHL    ; upper range 
b50f cd b2 9a			call macro_dsp_valuehl 
b512				endm 
# End of macro FORTH_DSP_VALUEHL
b512			 
b512 22 45 ed				ld (LFSRSeed), hl	 
b515			 
b515					if DEBUG_FORTH_WORDS 
b515						DMARK "RN1" 
b515 f5				push af  
b516 3a 2a b5			ld a, (.dmark)  
b519 32 c0 ee			ld (debug_mark),a  
b51c 3a 2b b5			ld a, (.dmark+1)  
b51f 32 c1 ee			ld (debug_mark+1),a  
b522 3a 2c b5			ld a, (.dmark+2)  
b525 32 c2 ee			ld (debug_mark+2),a  
b528 18 03			jr .pastdmark  
b52a ..			.dmark: db "RN1"  
b52d f1			.pastdmark: pop af  
b52e			endm  
# End of macro DMARK
b52e						CALLMONITOR 
b52e cd 2e 93			call break_point_state  
b531				endm  
# End of macro CALLMONITOR
b531					endif 
b531					FORTH_DSP_POP 
b531 cd 6a 9b			call macro_forth_dsp_pop 
b534				endm 
# End of macro FORTH_DSP_POP
b534			 
b534					FORTH_DSP_VALUEHL    ; low range 
b534 cd b2 9a			call macro_dsp_valuehl 
b537				endm 
# End of macro FORTH_DSP_VALUEHL
b537			 
b537					if DEBUG_FORTH_WORDS 
b537						DMARK "RN2" 
b537 f5				push af  
b538 3a 4c b5			ld a, (.dmark)  
b53b 32 c0 ee			ld (debug_mark),a  
b53e 3a 4d b5			ld a, (.dmark+1)  
b541 32 c1 ee			ld (debug_mark+1),a  
b544 3a 4e b5			ld a, (.dmark+2)  
b547 32 c2 ee			ld (debug_mark+2),a  
b54a 18 03			jr .pastdmark  
b54c ..			.dmark: db "RN2"  
b54f f1			.pastdmark: pop af  
b550			endm  
# End of macro DMARK
b550						CALLMONITOR 
b550 cd 2e 93			call break_point_state  
b553				endm  
# End of macro CALLMONITOR
b553					endif 
b553 22 47 ed				ld (LFSRSeed+2), hl 
b556			 
b556					FORTH_DSP_POP 
b556 cd 6a 9b			call macro_forth_dsp_pop 
b559				endm 
# End of macro FORTH_DSP_POP
b559			 
b559 e5					push hl 
b55a			 
b55a e1			.inrange:	pop hl 
b55b cd e2 89				call prng16  
b55e					if DEBUG_FORTH_WORDS 
b55e						DMARK "RN3" 
b55e f5				push af  
b55f 3a 73 b5			ld a, (.dmark)  
b562 32 c0 ee			ld (debug_mark),a  
b565 3a 74 b5			ld a, (.dmark+1)  
b568 32 c1 ee			ld (debug_mark+1),a  
b56b 3a 75 b5			ld a, (.dmark+2)  
b56e 32 c2 ee			ld (debug_mark+2),a  
b571 18 03			jr .pastdmark  
b573 ..			.dmark: db "RN3"  
b576 f1			.pastdmark: pop af  
b577			endm  
# End of macro DMARK
b577						CALLMONITOR 
b577 cd 2e 93			call break_point_state  
b57a				endm  
# End of macro CALLMONITOR
b57a					endif 
b57a					 
b57a					; if the range is 8bit knock out the high byte 
b57a			 
b57a ed 5b 45 ed			ld de, (LFSRSeed)     ; check high level 
b57e			 
b57e 3e 00				ld a, 0 
b580 ba					cp d  
b581 20 1e				jr nz, .hirange 
b583 26 00				ld h, 0   ; knock it down to 8bit 
b585			 
b585					if DEBUG_FORTH_WORDS 
b585						DMARK "RNk" 
b585 f5				push af  
b586 3a 9a b5			ld a, (.dmark)  
b589 32 c0 ee			ld (debug_mark),a  
b58c 3a 9b b5			ld a, (.dmark+1)  
b58f 32 c1 ee			ld (debug_mark+1),a  
b592 3a 9c b5			ld a, (.dmark+2)  
b595 32 c2 ee			ld (debug_mark+2),a  
b598 18 03			jr .pastdmark  
b59a ..			.dmark: db "RNk"  
b59d f1			.pastdmark: pop af  
b59e			endm  
# End of macro DMARK
b59e						CALLMONITOR 
b59e cd 2e 93			call break_point_state  
b5a1				endm  
# End of macro CALLMONITOR
b5a1					endif 
b5a1			.hirange:   
b5a1 e5					push hl  
b5a2 b7					or a  
b5a3 ed 52		                sbc hl, de 
b5a5			 
b5a5					;call cmp16 
b5a5			 
b5a5 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b5a7 e1					pop hl 
b5a8 e5					push hl 
b5a9			 
b5a9					if DEBUG_FORTH_WORDS 
b5a9						DMARK "RN4" 
b5a9 f5				push af  
b5aa 3a be b5			ld a, (.dmark)  
b5ad 32 c0 ee			ld (debug_mark),a  
b5b0 3a bf b5			ld a, (.dmark+1)  
b5b3 32 c1 ee			ld (debug_mark+1),a  
b5b6 3a c0 b5			ld a, (.dmark+2)  
b5b9 32 c2 ee			ld (debug_mark+2),a  
b5bc 18 03			jr .pastdmark  
b5be ..			.dmark: db "RN4"  
b5c1 f1			.pastdmark: pop af  
b5c2			endm  
# End of macro DMARK
b5c2						CALLMONITOR 
b5c2 cd 2e 93			call break_point_state  
b5c5				endm  
# End of macro CALLMONITOR
b5c5					endif 
b5c5 ed 5b 47 ed			ld de, (LFSRSeed+2)   ; check low range 
b5c9					;call cmp16 
b5c9				 
b5c9 b7					or a  
b5ca ed 52		                sbc hl, de 
b5cc 38 8c				jr c, .inrange 
b5ce			 
b5ce e1					pop hl 
b5cf					 
b5cf					if DEBUG_FORTH_WORDS 
b5cf						DMARK "RNd" 
b5cf f5				push af  
b5d0 3a e4 b5			ld a, (.dmark)  
b5d3 32 c0 ee			ld (debug_mark),a  
b5d6 3a e5 b5			ld a, (.dmark+1)  
b5d9 32 c1 ee			ld (debug_mark+1),a  
b5dc 3a e6 b5			ld a, (.dmark+2)  
b5df 32 c2 ee			ld (debug_mark+2),a  
b5e2 18 03			jr .pastdmark  
b5e4 ..			.dmark: db "RNd"  
b5e7 f1			.pastdmark: pop af  
b5e8			endm  
# End of macro DMARK
b5e8						CALLMONITOR 
b5e8 cd 2e 93			call break_point_state  
b5eb				endm  
# End of macro CALLMONITOR
b5eb					endif 
b5eb			 
b5eb			 
b5eb cd bb 98				call forth_push_numhl 
b5ee				       NEXTW 
b5ee c3 24 9c			jp macro_next 
b5f1				endm 
# End of macro NEXTW
b5f1			 
b5f1			.ENDMATHS: 
b5f1			 
b5f1			; eof 
b5f1			 
# End of file forth_words_maths.asm
b5f1			include "forth_words_display.asm" 
b5f1			 
b5f1			; | ## Display Words 
b5f1			 
b5f1			.ATP: 
b5f1				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b5f1 62				db WORD_SYS_CORE+78             
b5f2 68 b6			dw .FB            
b5f4 04				db 3 + 1 
b5f5 .. 00			db "AT?",0              
b5f9				endm 
# End of macro CWHEAD
b5f9			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b5f9					if DEBUG_FORTH_WORDS_KEY 
b5f9						DMARK "AT?" 
b5f9 f5				push af  
b5fa 3a 0e b6			ld a, (.dmark)  
b5fd 32 c0 ee			ld (debug_mark),a  
b600 3a 0f b6			ld a, (.dmark+1)  
b603 32 c1 ee			ld (debug_mark+1),a  
b606 3a 10 b6			ld a, (.dmark+2)  
b609 32 c2 ee			ld (debug_mark+2),a  
b60c 18 03			jr .pastdmark  
b60e ..			.dmark: db "AT?"  
b611 f1			.pastdmark: pop af  
b612			endm  
# End of macro DMARK
b612						CALLMONITOR 
b612 cd 2e 93			call break_point_state  
b615				endm  
# End of macro CALLMONITOR
b615					endif 
b615 3a cf ec				ld a, (f_cursor_ptr) 
b618			 
b618			if DEBUG_FORTH_WORDS 
b618				DMARK "AT?" 
b618 f5				push af  
b619 3a 2d b6			ld a, (.dmark)  
b61c 32 c0 ee			ld (debug_mark),a  
b61f 3a 2e b6			ld a, (.dmark+1)  
b622 32 c1 ee			ld (debug_mark+1),a  
b625 3a 2f b6			ld a, (.dmark+2)  
b628 32 c2 ee			ld (debug_mark+2),a  
b62b 18 03			jr .pastdmark  
b62d ..			.dmark: db "AT?"  
b630 f1			.pastdmark: pop af  
b631			endm  
# End of macro DMARK
b631				CALLMONITOR 
b631 cd 2e 93			call break_point_state  
b634				endm  
# End of macro CALLMONITOR
b634			endif	 
b634					; count the number of rows 
b634			 
b634 06 00				ld b, 0 
b636 4f			.atpr:		ld c, a    ; save in case we go below zero 
b637 d6 14				sub display_cols 
b639 f2 3f b6				jp p, .atprunder 
b63c 04					inc b 
b63d 18 f7				jr .atpr 
b63f			.atprunder:	 
b63f			if DEBUG_FORTH_WORDS 
b63f				DMARK "A?2" 
b63f f5				push af  
b640 3a 54 b6			ld a, (.dmark)  
b643 32 c0 ee			ld (debug_mark),a  
b646 3a 55 b6			ld a, (.dmark+1)  
b649 32 c1 ee			ld (debug_mark+1),a  
b64c 3a 56 b6			ld a, (.dmark+2)  
b64f 32 c2 ee			ld (debug_mark+2),a  
b652 18 03			jr .pastdmark  
b654 ..			.dmark: db "A?2"  
b657 f1			.pastdmark: pop af  
b658			endm  
# End of macro DMARK
b658				CALLMONITOR 
b658 cd 2e 93			call break_point_state  
b65b				endm  
# End of macro CALLMONITOR
b65b			endif	 
b65b 26 00				ld h, 0 
b65d 69					ld l, c 
b65e cd bb 98				call forth_push_numhl 
b661 68					ld l, b  
b662 cd bb 98				call forth_push_numhl 
b665			 
b665			 
b665				NEXTW 
b665 c3 24 9c			jp macro_next 
b668				endm 
# End of macro NEXTW
b668			 
b668			.FB: 
b668				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b668 1b				db WORD_SYS_CORE+7             
b669 b6 b6			dw .EMIT            
b66b 03				db 2 + 1 
b66c .. 00			db "FB",0              
b66f				endm 
# End of macro CWHEAD
b66f			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b66f			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b66f			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b66f			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b66f					if DEBUG_FORTH_WORDS_KEY 
b66f						DMARK "FB." 
b66f f5				push af  
b670 3a 84 b6			ld a, (.dmark)  
b673 32 c0 ee			ld (debug_mark),a  
b676 3a 85 b6			ld a, (.dmark+1)  
b679 32 c1 ee			ld (debug_mark+1),a  
b67c 3a 86 b6			ld a, (.dmark+2)  
b67f 32 c2 ee			ld (debug_mark+2),a  
b682 18 03			jr .pastdmark  
b684 ..			.dmark: db "FB."  
b687 f1			.pastdmark: pop af  
b688			endm  
# End of macro DMARK
b688						CALLMONITOR 
b688 cd 2e 93			call break_point_state  
b68b				endm  
# End of macro CALLMONITOR
b68b					endif 
b68b			 
b68b					FORTH_DSP_VALUEHL 
b68b cd b2 9a			call macro_dsp_valuehl 
b68e				endm 
# End of macro FORTH_DSP_VALUEHL
b68e			 
b68e 7d					ld a, l 
b68f fe 01				cp 1 
b691 20 05				jr nz, .fbn1 
b693 21 05 ee				ld hl, display_fb1 
b696 18 15				jr .fbset 
b698 fe 02		.fbn1:		cp 2 
b69a 20 05				jr nz, .fbn2 
b69c 21 63 ed				ld hl, display_fb2 
b69f 18 0c				jr .fbset 
b6a1 fe 03		.fbn2:		cp 3 
b6a3 20 05				jr nz, .fbn3 
b6a5 21 b4 ed				ld hl, display_fb3 
b6a8 18 03				jr .fbset 
b6aa			.fbn3:		 ; if invalid number select first 
b6aa 21 05 ee				ld hl, display_fb1 
b6ad 22 61 ed		.fbset:		ld (display_fb_active), hl 
b6b0			 
b6b0					FORTH_DSP_POP 
b6b0 cd 6a 9b			call macro_forth_dsp_pop 
b6b3				endm 
# End of macro FORTH_DSP_POP
b6b3			 
b6b3					NEXTW 
b6b3 c3 24 9c			jp macro_next 
b6b6				endm 
# End of macro NEXTW
b6b6			 
b6b6			 
b6b6			.EMIT: 
b6b6				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b6b6 1b				db WORD_SYS_CORE+7             
b6b7 07 b7			dw .DOTH            
b6b9 05				db 4 + 1 
b6ba .. 00			db "EMIT",0              
b6bf				endm 
# End of macro CWHEAD
b6bf			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b6bf					; get value off TOS and display it 
b6bf			 
b6bf					if DEBUG_FORTH_WORDS_KEY 
b6bf						DMARK "EMT" 
b6bf f5				push af  
b6c0 3a d4 b6			ld a, (.dmark)  
b6c3 32 c0 ee			ld (debug_mark),a  
b6c6 3a d5 b6			ld a, (.dmark+1)  
b6c9 32 c1 ee			ld (debug_mark+1),a  
b6cc 3a d6 b6			ld a, (.dmark+2)  
b6cf 32 c2 ee			ld (debug_mark+2),a  
b6d2 18 03			jr .pastdmark  
b6d4 ..			.dmark: db "EMT"  
b6d7 f1			.pastdmark: pop af  
b6d8			endm  
# End of macro DMARK
b6d8						CALLMONITOR 
b6d8 cd 2e 93			call break_point_state  
b6db				endm  
# End of macro CALLMONITOR
b6db					endif 
b6db			 
b6db					FORTH_DSP_VALUEHL 
b6db cd b2 9a			call macro_dsp_valuehl 
b6de				endm 
# End of macro FORTH_DSP_VALUEHL
b6de			 
b6de 7d					ld a,l 
b6df			 
b6df					; TODO write to display 
b6df			 
b6df 32 e4 e6				ld (os_input), a 
b6e2 3e 00				ld a, 0 
b6e4 32 e5 e6				ld (os_input+1), a 
b6e7					 
b6e7 3a cf ec				ld a, (f_cursor_ptr) 
b6ea 11 e4 e6				ld de, os_input 
b6ed cd a1 88				call str_at_display 
b6f0			 
b6f0			 
b6f0 3a ad ec				ld a,(cli_autodisplay) 
b6f3 fe 00				cp 0 
b6f5 28 03				jr z, .enoupdate 
b6f7 cd b1 88						call update_display 
b6fa					.enoupdate: 
b6fa			 
b6fa 3a cf ec				ld a, (f_cursor_ptr) 
b6fd 3c					inc a 
b6fe 32 cf ec				ld (f_cursor_ptr), a   ; save new pos 
b701			 
b701			 
b701					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b701 cd 6a 9b			call macro_forth_dsp_pop 
b704				endm 
# End of macro FORTH_DSP_POP
b704			  
b704			 
b704					NEXTW 
b704 c3 24 9c			jp macro_next 
b707				endm 
# End of macro NEXTW
b707			.DOTH: 
b707				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b707 1c				db WORD_SYS_CORE+8             
b708 37 b7			dw .DOTF            
b70a 03				db 2 + 1 
b70b .. 00			db ".-",0              
b70e				endm 
# End of macro CWHEAD
b70e			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b70e					; get value off TOS and display it 
b70e					if DEBUG_FORTH_WORDS_KEY 
b70e						DMARK "DTD" 
b70e f5				push af  
b70f 3a 23 b7			ld a, (.dmark)  
b712 32 c0 ee			ld (debug_mark),a  
b715 3a 24 b7			ld a, (.dmark+1)  
b718 32 c1 ee			ld (debug_mark+1),a  
b71b 3a 25 b7			ld a, (.dmark+2)  
b71e 32 c2 ee			ld (debug_mark+2),a  
b721 18 03			jr .pastdmark  
b723 ..			.dmark: db "DTD"  
b726 f1			.pastdmark: pop af  
b727			endm  
# End of macro DMARK
b727						CALLMONITOR 
b727 cd 2e 93			call break_point_state  
b72a				endm  
# End of macro CALLMONITOR
b72a					endif 
b72a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b72c 3e 00			ld a, 0 
b72e 32 ae ec			ld (cli_mvdot), a 
b731 c3 8e b7			jp .dotgo 
b734				NEXTW 
b734 c3 24 9c			jp macro_next 
b737				endm 
# End of macro NEXTW
b737			.DOTF: 
b737				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b737 1c				db WORD_SYS_CORE+8             
b738 65 b7			dw .DOT            
b73a 03				db 2 + 1 
b73b .. 00			db ".>",0              
b73e				endm 
# End of macro CWHEAD
b73e			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b73e					; get value off TOS and display it 
b73e			        ; TODO BUG adds extra spaces 
b73e			        ; TODO BUG handle numerics? 
b73e					if DEBUG_FORTH_WORDS_KEY 
b73e						DMARK "DTC" 
b73e f5				push af  
b73f 3a 53 b7			ld a, (.dmark)  
b742 32 c0 ee			ld (debug_mark),a  
b745 3a 54 b7			ld a, (.dmark+1)  
b748 32 c1 ee			ld (debug_mark+1),a  
b74b 3a 55 b7			ld a, (.dmark+2)  
b74e 32 c2 ee			ld (debug_mark+2),a  
b751 18 03			jr .pastdmark  
b753 ..			.dmark: db "DTC"  
b756 f1			.pastdmark: pop af  
b757			endm  
# End of macro DMARK
b757						CALLMONITOR 
b757 cd 2e 93			call break_point_state  
b75a				endm  
# End of macro CALLMONITOR
b75a					endif 
b75a 3e 01			ld a, 1 
b75c 32 ae ec			ld (cli_mvdot), a 
b75f c3 8e b7			jp .dotgo 
b762				NEXTW 
b762 c3 24 9c			jp macro_next 
b765				endm 
# End of macro NEXTW
b765			 
b765			.DOT: 
b765				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b765 1c				db WORD_SYS_CORE+8             
b766 f1 b7			dw .CLS            
b768 02				db 1 + 1 
b769 .. 00			db ".",0              
b76b				endm 
# End of macro CWHEAD
b76b			        ; | . ( u -- ) Display TOS | DONE 
b76b					; get value off TOS and display it 
b76b			 
b76b					if DEBUG_FORTH_WORDS_KEY 
b76b						DMARK "DOT" 
b76b f5				push af  
b76c 3a 80 b7			ld a, (.dmark)  
b76f 32 c0 ee			ld (debug_mark),a  
b772 3a 81 b7			ld a, (.dmark+1)  
b775 32 c1 ee			ld (debug_mark+1),a  
b778 3a 82 b7			ld a, (.dmark+2)  
b77b 32 c2 ee			ld (debug_mark+2),a  
b77e 18 03			jr .pastdmark  
b780 ..			.dmark: db "DOT"  
b783 f1			.pastdmark: pop af  
b784			endm  
# End of macro DMARK
b784						CALLMONITOR 
b784 cd 2e 93			call break_point_state  
b787				endm  
# End of macro CALLMONITOR
b787					endif 
b787 3e 00			ld a, 0 
b789 32 ae ec			ld (cli_mvdot), a 
b78c 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b78e				 
b78e			 
b78e			.dotgo: 
b78e			 
b78e			; move up type to on stack for parserv5 
b78e					FORTH_DSP 
b78e cd 78 9a			call macro_forth_dsp 
b791				endm 
# End of macro FORTH_DSP
b791				;FORTH_DSP_VALUE  
b791			 
b791			if DEBUG_FORTH_DOT 
b791				DMARK "DOT" 
b791				CALLMONITOR 
b791			endif	 
b791			;		.print: 
b791			 
b791 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b792 23				inc hl   ; position to the actual value 
b793 fe 01			cp DS_TYPE_STR 
b795 20 06			jr nz, .dotnum1  
b797			 
b797			; display string 
b797				FORTH_DSP_VALUE  
b797 cd 9b 9a			call macro_forth_dsp_value 
b79a				endm 
# End of macro FORTH_DSP_VALUE
b79a eb				ex de,hl 
b79b 18 11			jr .dotwrite 
b79d			 
b79d			.dotnum1: 
b79d fe 02			cp DS_TYPE_INUM 
b79f 20 0c			jr nz, .dotflot 
b7a1			 
b7a1			 
b7a1			; display number 
b7a1			 
b7a1			;	push hl 
b7a1			;	call clear_display 
b7a1			;	pop hl 
b7a1			 
b7a1 5e				ld e, (hl) 
b7a2 23				inc hl 
b7a3 56				ld d, (hl) 
b7a4 21 e6 e4			ld hl, scratch 
b7a7			if DEBUG_FORTH_DOT 
b7a7				DMARK "DT1" 
b7a7				CALLMONITOR 
b7a7			endif	 
b7a7			 
b7a7 cd c8 8e			call uitoa_16 
b7aa eb				ex de,hl 
b7ab			 
b7ab			if DEBUG_FORTH_DOT 
b7ab				DMARK "DT2" 
b7ab				CALLMONITOR 
b7ab			endif	 
b7ab			 
b7ab			;	ld de, os_word_scratch 
b7ab 18 01			jr .dotwrite 
b7ad			 
b7ad 00			.dotflot:   nop 
b7ae			; TODO print floating point number 
b7ae			 
b7ae			.dotwrite:		 
b7ae			 
b7ae					; if c is set then set all '-' to spaces 
b7ae					; need to also take into account .>  
b7ae			 
b7ae 3e 01				ld a, 1 
b7b0 b9					cp c 
b7b1 20 13				jr nz, .nodashswap 
b7b3			 
b7b3					; DE has the string to write, working with HL 
b7b3			 
b7b3 06 ff				ld b, 255 
b7b5 d5					push de 
b7b6 e1					pop hl 
b7b7			 
b7b7			if DEBUG_FORTH_DOT 
b7b7				DMARK "DT-" 
b7b7				CALLMONITOR 
b7b7			endif	 
b7b7 7e			.dashscan:	ld a, (hl) 
b7b8 fe 00				cp 0 
b7ba 28 0a				jr z, .nodashswap 
b7bc fe 2d				cp '-' 
b7be 20 03				jr nz, .dashskip 
b7c0 3e 20				ld a, ' ' 
b7c2 77					ld (hl), a 
b7c3 23			.dashskip:	inc hl 
b7c4			if DEBUG_FORTH_DOT 
b7c4				DMARK "D-2" 
b7c4				CALLMONITOR 
b7c4			endif	 
b7c4 10 f1				djnz .dashscan 
b7c6			 
b7c6			if DEBUG_FORTH_DOT 
b7c6				DMARK "D-1" 
b7c6				CALLMONITOR 
b7c6			endif	 
b7c6			 
b7c6			.nodashswap: 
b7c6			 
b7c6 e5					push hl   ; save string start in case we need to advance print 
b7c7			 
b7c7 3a cf ec				ld a, (f_cursor_ptr) 
b7ca cd a1 88				call str_at_display 
b7cd 3a ad ec				ld a,(cli_autodisplay) 
b7d0 fe 00				cp 0 
b7d2 28 03				jr z, .noupdate 
b7d4 cd b1 88						call update_display 
b7d7					.noupdate: 
b7d7			 
b7d7			 
b7d7					; see if we need to advance the print position 
b7d7			 
b7d7 e1					pop hl   ; get back string 
b7d8			 
b7d8 3a ae ec				ld a, (cli_mvdot) 
b7db			if DEBUG_FORTH_DOT 
b7db					ld e,a 
b7db				DMARK "D>1" 
b7db				CALLMONITOR 
b7db			endif	 
b7db fe 00				cp 0 
b7dd 28 0c				jr z, .noadv 
b7df					; yes, lets advance the print position 
b7df 3e 00				ld a, 0 
b7e1 cd 24 8f				call strlent 
b7e4 3a cf ec				ld a, (f_cursor_ptr) 
b7e7 85					add a,l 
b7e8					;call addatohl 
b7e8					;ld a, l 
b7e8 32 cf ec				ld (f_cursor_ptr), a   ; save new pos 
b7eb			 
b7eb			if DEBUG_FORTH_DOT 
b7eb				DMARK "D->" 
b7eb				CALLMONITOR 
b7eb			endif	 
b7eb			 
b7eb			.noadv:	 
b7eb			 
b7eb					if DEBUG_FORTH_DOT_WAIT 
b7eb							call next_page_prompt 
b7eb					endif	 
b7eb			; TODO this pop off the stack causes a crash. i dont know why 
b7eb			 
b7eb			 
b7eb			if DEBUG_FORTH_DOT 
b7eb				DMARK "DTh" 
b7eb				CALLMONITOR 
b7eb			endif	 
b7eb			 
b7eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7eb cd 6a 9b			call macro_forth_dsp_pop 
b7ee				endm 
# End of macro FORTH_DSP_POP
b7ee			 
b7ee			if DEBUG_FORTH_DOT 
b7ee				DMARK "DTi" 
b7ee				CALLMONITOR 
b7ee			endif	 
b7ee			 
b7ee			 
b7ee					NEXTW 
b7ee c3 24 9c			jp macro_next 
b7f1				endm 
# End of macro NEXTW
b7f1			 
b7f1			.CLS: 
b7f1				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b7f1 35				db WORD_SYS_CORE+33             
b7f2 1e b8			dw .DRAW            
b7f4 04				db 3 + 1 
b7f5 .. 00			db "CLS",0              
b7f9				endm 
# End of macro CWHEAD
b7f9			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b7f9					if DEBUG_FORTH_WORDS_KEY 
b7f9						DMARK "CLS" 
b7f9 f5				push af  
b7fa 3a 0e b8			ld a, (.dmark)  
b7fd 32 c0 ee			ld (debug_mark),a  
b800 3a 0f b8			ld a, (.dmark+1)  
b803 32 c1 ee			ld (debug_mark+1),a  
b806 3a 10 b8			ld a, (.dmark+2)  
b809 32 c2 ee			ld (debug_mark+2),a  
b80c 18 03			jr .pastdmark  
b80e ..			.dmark: db "CLS"  
b811 f1			.pastdmark: pop af  
b812			endm  
# End of macro DMARK
b812						CALLMONITOR 
b812 cd 2e 93			call break_point_state  
b815				endm  
# End of macro CALLMONITOR
b815					endif 
b815 cd 8e 88				call clear_display 
b818 c3 2c b9				jp .home		; and home cursor 
b81b					NEXTW 
b81b c3 24 9c			jp macro_next 
b81e				endm 
# End of macro NEXTW
b81e			 
b81e			.DRAW: 
b81e				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b81e 36				db WORD_SYS_CORE+34             
b81f 49 b8			dw .DUMP            
b821 05				db 4 + 1 
b822 .. 00			db "DRAW",0              
b827				endm 
# End of macro CWHEAD
b827			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b827					if DEBUG_FORTH_WORDS_KEY 
b827						DMARK "DRW" 
b827 f5				push af  
b828 3a 3c b8			ld a, (.dmark)  
b82b 32 c0 ee			ld (debug_mark),a  
b82e 3a 3d b8			ld a, (.dmark+1)  
b831 32 c1 ee			ld (debug_mark+1),a  
b834 3a 3e b8			ld a, (.dmark+2)  
b837 32 c2 ee			ld (debug_mark+2),a  
b83a 18 03			jr .pastdmark  
b83c ..			.dmark: db "DRW"  
b83f f1			.pastdmark: pop af  
b840			endm  
# End of macro DMARK
b840						CALLMONITOR 
b840 cd 2e 93			call break_point_state  
b843				endm  
# End of macro CALLMONITOR
b843					endif 
b843 cd b1 88				call update_display 
b846					NEXTW 
b846 c3 24 9c			jp macro_next 
b849				endm 
# End of macro NEXTW
b849			 
b849			.DUMP: 
b849				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b849 37				db WORD_SYS_CORE+35             
b84a 81 b8			dw .CDUMP            
b84c 05				db 4 + 1 
b84d .. 00			db "DUMP",0              
b852				endm 
# End of macro CWHEAD
b852			; | DUMP ( x -- ) With address x display dump   | DONE 
b852			; TODO pop address to use off of the stack 
b852					if DEBUG_FORTH_WORDS_KEY 
b852						DMARK "DUM" 
b852 f5				push af  
b853 3a 67 b8			ld a, (.dmark)  
b856 32 c0 ee			ld (debug_mark),a  
b859 3a 68 b8			ld a, (.dmark+1)  
b85c 32 c1 ee			ld (debug_mark+1),a  
b85f 3a 69 b8			ld a, (.dmark+2)  
b862 32 c2 ee			ld (debug_mark+2),a  
b865 18 03			jr .pastdmark  
b867 ..			.dmark: db "DUM"  
b86a f1			.pastdmark: pop af  
b86b			endm  
# End of macro DMARK
b86b						CALLMONITOR 
b86b cd 2e 93			call break_point_state  
b86e				endm  
# End of macro CALLMONITOR
b86e					endif 
b86e cd 8e 88				call clear_display 
b871			 
b871					; get address 
b871			 
b871					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b871 cd b2 9a			call macro_dsp_valuehl 
b874				endm 
# End of macro FORTH_DSP_VALUEHL
b874				 
b874					; save it for cdump 
b874			 
b874 22 09 e8				ld (os_cur_ptr),hl 
b877			 
b877					; destroy value TOS 
b877			 
b877					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b877 cd 6a 9b			call macro_forth_dsp_pop 
b87a				endm 
# End of macro FORTH_DSP_POP
b87a			 
b87a cd 3b 97				call dumpcont	; skip old style of param parsing	 
b87d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b87e					NEXTW 
b87e c3 24 9c			jp macro_next 
b881				endm 
# End of macro NEXTW
b881			.CDUMP: 
b881				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b881 38				db WORD_SYS_CORE+36             
b882 b1 b8			dw .DAT            
b884 06				db 5 + 1 
b885 .. 00			db "CDUMP",0              
b88b				endm 
# End of macro CWHEAD
b88b			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b88b					if DEBUG_FORTH_WORDS_KEY 
b88b						DMARK "CDP" 
b88b f5				push af  
b88c 3a a0 b8			ld a, (.dmark)  
b88f 32 c0 ee			ld (debug_mark),a  
b892 3a a1 b8			ld a, (.dmark+1)  
b895 32 c1 ee			ld (debug_mark+1),a  
b898 3a a2 b8			ld a, (.dmark+2)  
b89b 32 c2 ee			ld (debug_mark+2),a  
b89e 18 03			jr .pastdmark  
b8a0 ..			.dmark: db "CDP"  
b8a3 f1			.pastdmark: pop af  
b8a4			endm  
# End of macro DMARK
b8a4						CALLMONITOR 
b8a4 cd 2e 93			call break_point_state  
b8a7				endm  
# End of macro CALLMONITOR
b8a7					endif 
b8a7 cd 8e 88				call clear_display 
b8aa cd 3b 97				call dumpcont	 
b8ad c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b8ae					NEXTW 
b8ae c3 24 9c			jp macro_next 
b8b1				endm 
# End of macro NEXTW
b8b1			 
b8b1			 
b8b1			 
b8b1			 
b8b1			.DAT: 
b8b1				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b8b1 3d				db WORD_SYS_CORE+41             
b8b2 07 b9			dw .HOME            
b8b4 03				db 2 + 1 
b8b5 .. 00			db "AT",0              
b8b8				endm 
# End of macro CWHEAD
b8b8			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b8b8					if DEBUG_FORTH_WORDS_KEY 
b8b8						DMARK "AT." 
b8b8 f5				push af  
b8b9 3a cd b8			ld a, (.dmark)  
b8bc 32 c0 ee			ld (debug_mark),a  
b8bf 3a ce b8			ld a, (.dmark+1)  
b8c2 32 c1 ee			ld (debug_mark+1),a  
b8c5 3a cf b8			ld a, (.dmark+2)  
b8c8 32 c2 ee			ld (debug_mark+2),a  
b8cb 18 03			jr .pastdmark  
b8cd ..			.dmark: db "AT."  
b8d0 f1			.pastdmark: pop af  
b8d1			endm  
# End of macro DMARK
b8d1						CALLMONITOR 
b8d1 cd 2e 93			call break_point_state  
b8d4				endm  
# End of macro CALLMONITOR
b8d4					endif 
b8d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8d4 cd b2 9a			call macro_dsp_valuehl 
b8d7				endm 
# End of macro FORTH_DSP_VALUEHL
b8d7			 
b8d7			 
b8d7					; TODO save cursor row 
b8d7 7d					ld a,l 
b8d8 fe 02				cp 2 
b8da 20 04				jr nz, .crow3 
b8dc 3e 14				ld a, display_row_2 
b8de 18 12				jr .ccol1 
b8e0 fe 03		.crow3:		cp 3 
b8e2 20 04				jr nz, .crow4 
b8e4 3e 28				ld a, display_row_3 
b8e6 18 0a				jr .ccol1 
b8e8 fe 04		.crow4:		cp 4 
b8ea 20 04				jr nz, .crow1 
b8ec 3e 3c				ld a, display_row_4 
b8ee 18 02				jr .ccol1 
b8f0 3e 00		.crow1:		ld a,display_row_1 
b8f2 f5			.ccol1:		push af			; got row offset 
b8f3 6f					ld l,a 
b8f4 26 00				ld h,0 
b8f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8f6 cd 6a 9b			call macro_forth_dsp_pop 
b8f9				endm 
# End of macro FORTH_DSP_POP
b8f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8f9 cd b2 9a			call macro_dsp_valuehl 
b8fc				endm 
# End of macro FORTH_DSP_VALUEHL
b8fc					; TODO save cursor col 
b8fc f1					pop af 
b8fd 85					add l		; add col offset 
b8fe 32 cf ec				ld (f_cursor_ptr), a 
b901					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b901 cd 6a 9b			call macro_forth_dsp_pop 
b904				endm 
# End of macro FORTH_DSP_POP
b904			 
b904					; calculate  
b904			 
b904					NEXTW 
b904 c3 24 9c			jp macro_next 
b907				endm 
# End of macro NEXTW
b907			 
b907			 
b907			.HOME: 
b907				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
b907 41				db WORD_SYS_CORE+45             
b908 34 b9			dw .SPACE            
b90a 05				db 4 + 1 
b90b .. 00			db "HOME",0              
b910				endm 
# End of macro CWHEAD
b910			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
b910					if DEBUG_FORTH_WORDS_KEY 
b910						DMARK "HOM" 
b910 f5				push af  
b911 3a 25 b9			ld a, (.dmark)  
b914 32 c0 ee			ld (debug_mark),a  
b917 3a 26 b9			ld a, (.dmark+1)  
b91a 32 c1 ee			ld (debug_mark+1),a  
b91d 3a 27 b9			ld a, (.dmark+2)  
b920 32 c2 ee			ld (debug_mark+2),a  
b923 18 03			jr .pastdmark  
b925 ..			.dmark: db "HOM"  
b928 f1			.pastdmark: pop af  
b929			endm  
# End of macro DMARK
b929						CALLMONITOR 
b929 cd 2e 93			call break_point_state  
b92c				endm  
# End of macro CALLMONITOR
b92c					endif 
b92c 3e 00		.home:		ld a, 0		; and home cursor 
b92e 32 cf ec				ld (f_cursor_ptr), a 
b931					NEXTW 
b931 c3 24 9c			jp macro_next 
b934				endm 
# End of macro NEXTW
b934			 
b934			 
b934			.SPACE: 
b934				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
b934 46				db WORD_SYS_CORE+50             
b935 62 b9			dw .SPACES            
b937 03				db 2 + 1 
b938 .. 00			db "BL",0              
b93b				endm 
# End of macro CWHEAD
b93b			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
b93b					if DEBUG_FORTH_WORDS_KEY 
b93b						DMARK "BL." 
b93b f5				push af  
b93c 3a 50 b9			ld a, (.dmark)  
b93f 32 c0 ee			ld (debug_mark),a  
b942 3a 51 b9			ld a, (.dmark+1)  
b945 32 c1 ee			ld (debug_mark+1),a  
b948 3a 52 b9			ld a, (.dmark+2)  
b94b 32 c2 ee			ld (debug_mark+2),a  
b94e 18 03			jr .pastdmark  
b950 ..			.dmark: db "BL."  
b953 f1			.pastdmark: pop af  
b954			endm  
# End of macro DMARK
b954						CALLMONITOR 
b954 cd 2e 93			call break_point_state  
b957				endm  
# End of macro CALLMONITOR
b957					endif 
b957 21 60 b9				ld hl, .blstr 
b95a cd 29 99				call forth_push_str 
b95d					 
b95d				       NEXTW 
b95d c3 24 9c			jp macro_next 
b960				endm 
# End of macro NEXTW
b960			 
b960 .. 00		.blstr: db " ", 0 
b962			 
b962			.SPACES: 
b962				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
b962 47				db WORD_SYS_CORE+51             
b963 fd b9			dw .SCROLL            
b965 07				db 6 + 1 
b966 .. 00			db "SPACES",0              
b96d				endm 
# End of macro CWHEAD
b96d			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
b96d					if DEBUG_FORTH_WORDS_KEY 
b96d						DMARK "SPS" 
b96d f5				push af  
b96e 3a 82 b9			ld a, (.dmark)  
b971 32 c0 ee			ld (debug_mark),a  
b974 3a 83 b9			ld a, (.dmark+1)  
b977 32 c1 ee			ld (debug_mark+1),a  
b97a 3a 84 b9			ld a, (.dmark+2)  
b97d 32 c2 ee			ld (debug_mark+2),a  
b980 18 03			jr .pastdmark  
b982 ..			.dmark: db "SPS"  
b985 f1			.pastdmark: pop af  
b986			endm  
# End of macro DMARK
b986						CALLMONITOR 
b986 cd 2e 93			call break_point_state  
b989				endm  
# End of macro CALLMONITOR
b989					endif 
b989			 
b989			 
b989					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b989 cd b2 9a			call macro_dsp_valuehl 
b98c				endm 
# End of macro FORTH_DSP_VALUEHL
b98c			 
b98c			;		push hl    ; u 
b98c					if DEBUG_FORTH_WORDS 
b98c						DMARK "SPA" 
b98c f5				push af  
b98d 3a a1 b9			ld a, (.dmark)  
b990 32 c0 ee			ld (debug_mark),a  
b993 3a a2 b9			ld a, (.dmark+1)  
b996 32 c1 ee			ld (debug_mark+1),a  
b999 3a a3 b9			ld a, (.dmark+2)  
b99c 32 c2 ee			ld (debug_mark+2),a  
b99f 18 03			jr .pastdmark  
b9a1 ..			.dmark: db "SPA"  
b9a4 f1			.pastdmark: pop af  
b9a5			endm  
# End of macro DMARK
b9a5						CALLMONITOR 
b9a5 cd 2e 93			call break_point_state  
b9a8				endm  
# End of macro CALLMONITOR
b9a8					endif 
b9a8			 
b9a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9a8 cd 6a 9b			call macro_forth_dsp_pop 
b9ab				endm 
# End of macro FORTH_DSP_POP
b9ab			;		pop hl 
b9ab 4d					ld c, l 
b9ac 06 00				ld b, 0 
b9ae 21 e6 e4				ld hl, scratch  
b9b1			 
b9b1					if DEBUG_FORTH_WORDS 
b9b1						DMARK "SP2" 
b9b1 f5				push af  
b9b2 3a c6 b9			ld a, (.dmark)  
b9b5 32 c0 ee			ld (debug_mark),a  
b9b8 3a c7 b9			ld a, (.dmark+1)  
b9bb 32 c1 ee			ld (debug_mark+1),a  
b9be 3a c8 b9			ld a, (.dmark+2)  
b9c1 32 c2 ee			ld (debug_mark+2),a  
b9c4 18 03			jr .pastdmark  
b9c6 ..			.dmark: db "SP2"  
b9c9 f1			.pastdmark: pop af  
b9ca			endm  
# End of macro DMARK
b9ca						CALLMONITOR 
b9ca cd 2e 93			call break_point_state  
b9cd				endm  
# End of macro CALLMONITOR
b9cd					endif 
b9cd 3e 20				ld a, ' ' 
b9cf c5			.spaces1:	push bc 
b9d0 77					ld (hl),a 
b9d1 23					inc hl 
b9d2 c1					pop bc 
b9d3 10 fa				djnz .spaces1 
b9d5 3e 00				ld a,0 
b9d7 77					ld (hl),a 
b9d8 21 e6 e4				ld hl, scratch 
b9db					if DEBUG_FORTH_WORDS 
b9db						DMARK "SP3" 
b9db f5				push af  
b9dc 3a f0 b9			ld a, (.dmark)  
b9df 32 c0 ee			ld (debug_mark),a  
b9e2 3a f1 b9			ld a, (.dmark+1)  
b9e5 32 c1 ee			ld (debug_mark+1),a  
b9e8 3a f2 b9			ld a, (.dmark+2)  
b9eb 32 c2 ee			ld (debug_mark+2),a  
b9ee 18 03			jr .pastdmark  
b9f0 ..			.dmark: db "SP3"  
b9f3 f1			.pastdmark: pop af  
b9f4			endm  
# End of macro DMARK
b9f4						CALLMONITOR 
b9f4 cd 2e 93			call break_point_state  
b9f7				endm  
# End of macro CALLMONITOR
b9f7					endif 
b9f7 cd 24 9a				call forth_apush 
b9fa			 
b9fa				       NEXTW 
b9fa c3 24 9c			jp macro_next 
b9fd				endm 
# End of macro NEXTW
b9fd			 
b9fd			 
b9fd			 
b9fd			.SCROLL: 
b9fd				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
b9fd 53				db WORD_SYS_CORE+63             
b9fe 2a ba			dw .SCROLLD            
ba00 07				db 6 + 1 
ba01 .. 00			db "SCROLL",0              
ba08				endm 
# End of macro CWHEAD
ba08			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
ba08					if DEBUG_FORTH_WORDS_KEY 
ba08						DMARK "SCR" 
ba08 f5				push af  
ba09 3a 1d ba			ld a, (.dmark)  
ba0c 32 c0 ee			ld (debug_mark),a  
ba0f 3a 1e ba			ld a, (.dmark+1)  
ba12 32 c1 ee			ld (debug_mark+1),a  
ba15 3a 1f ba			ld a, (.dmark+2)  
ba18 32 c2 ee			ld (debug_mark+2),a  
ba1b 18 03			jr .pastdmark  
ba1d ..			.dmark: db "SCR"  
ba20 f1			.pastdmark: pop af  
ba21			endm  
# End of macro DMARK
ba21						CALLMONITOR 
ba21 cd 2e 93			call break_point_state  
ba24				endm  
# End of macro CALLMONITOR
ba24					endif 
ba24			 
ba24 cd 50 88			call scroll_up 
ba27			;	call update_display 
ba27			 
ba27					NEXTW 
ba27 c3 24 9c			jp macro_next 
ba2a				endm 
# End of macro NEXTW
ba2a			 
ba2a			 
ba2a			 
ba2a			;		; get dir 
ba2a			; 
ba2a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba2a			; 
ba2a			;		push hl 
ba2a			; 
ba2a			;		; destroy value TOS 
ba2a			; 
ba2a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba2a			; 
ba2a			;		; get count 
ba2a			; 
ba2a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba2a			; 
ba2a			;		push hl 
ba2a			; 
ba2a			;		; destroy value TOS 
ba2a			; 
ba2a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba2a			; 
ba2a			;		; one value on hl get other one back 
ba2a			; 
ba2a			;		pop bc    ; count 
ba2a			; 
ba2a			;		pop de   ; dir 
ba2a			; 
ba2a			; 
ba2a			;		ld b, c 
ba2a			; 
ba2a			;.scrolldir:     push bc 
ba2a			;		push de 
ba2a			; 
ba2a			;		ld a, 0 
ba2a			;		cp e 
ba2a			;		jr z, .scrollup  
ba2a			;		call scroll_down 
ba2a			;		jr .scrollnext 
ba2a			;.scrollup:	call scroll_up 
ba2a			; 
ba2a			;		 
ba2a			;.scrollnext: 
ba2a			;		pop de 
ba2a			;		pop bc 
ba2a			;		djnz .scrolldir 
ba2a			; 
ba2a			; 
ba2a			; 
ba2a			; 
ba2a			; 
ba2a			;		NEXTW 
ba2a			 
ba2a			.SCROLLD: 
ba2a				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
ba2a 53				db WORD_SYS_CORE+63             
ba2b 58 ba			dw .ATQ            
ba2d 08				db 7 + 1 
ba2e .. 00			db "SCROLLD",0              
ba36				endm 
# End of macro CWHEAD
ba36			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
ba36					if DEBUG_FORTH_WORDS_KEY 
ba36						DMARK "SCD" 
ba36 f5				push af  
ba37 3a 4b ba			ld a, (.dmark)  
ba3a 32 c0 ee			ld (debug_mark),a  
ba3d 3a 4c ba			ld a, (.dmark+1)  
ba40 32 c1 ee			ld (debug_mark+1),a  
ba43 3a 4d ba			ld a, (.dmark+2)  
ba46 32 c2 ee			ld (debug_mark+2),a  
ba49 18 03			jr .pastdmark  
ba4b ..			.dmark: db "SCD"  
ba4e f1			.pastdmark: pop af  
ba4f			endm  
# End of macro DMARK
ba4f						CALLMONITOR 
ba4f cd 2e 93			call break_point_state  
ba52				endm  
# End of macro CALLMONITOR
ba52					endif 
ba52			 
ba52 cd 74 88			call scroll_down 
ba55			;	call update_display 
ba55			 
ba55					NEXTW 
ba55 c3 24 9c			jp macro_next 
ba58				endm 
# End of macro NEXTW
ba58			 
ba58			 
ba58			.ATQ: 
ba58				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
ba58 62				db WORD_SYS_CORE+78             
ba59 b6 ba			dw .AUTODSP            
ba5b 04				db 3 + 1 
ba5c .. 00			db "AT@",0              
ba60				endm 
# End of macro CWHEAD
ba60			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
ba60					if DEBUG_FORTH_WORDS_KEY 
ba60						DMARK "ATA" 
ba60 f5				push af  
ba61 3a 75 ba			ld a, (.dmark)  
ba64 32 c0 ee			ld (debug_mark),a  
ba67 3a 76 ba			ld a, (.dmark+1)  
ba6a 32 c1 ee			ld (debug_mark+1),a  
ba6d 3a 77 ba			ld a, (.dmark+2)  
ba70 32 c2 ee			ld (debug_mark+2),a  
ba73 18 03			jr .pastdmark  
ba75 ..			.dmark: db "ATA"  
ba78 f1			.pastdmark: pop af  
ba79			endm  
# End of macro DMARK
ba79						CALLMONITOR 
ba79 cd 2e 93			call break_point_state  
ba7c				endm  
# End of macro CALLMONITOR
ba7c					endif 
ba7c			 
ba7c			 
ba7c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba7c cd b2 9a			call macro_dsp_valuehl 
ba7f				endm 
# End of macro FORTH_DSP_VALUEHL
ba7f			 
ba7f					; TODO save cursor row 
ba7f 7d					ld a,l 
ba80 fe 02				cp 2 
ba82 20 04				jr nz, .crow3aq 
ba84 3e 14				ld a, display_row_2 
ba86 18 12				jr .ccol1aq 
ba88 fe 03		.crow3aq:		cp 3 
ba8a 20 04				jr nz, .crow4aq 
ba8c 3e 28				ld a, display_row_3 
ba8e 18 0a				jr .ccol1aq 
ba90 fe 04		.crow4aq:		cp 4 
ba92 20 04				jr nz, .crow1aq 
ba94 3e 3c				ld a, display_row_4 
ba96 18 02				jr .ccol1aq 
ba98 3e 00		.crow1aq:		ld a,display_row_1 
ba9a f5			.ccol1aq:		push af			; got row offset 
ba9b 6f					ld l,a 
ba9c 26 00				ld h,0 
ba9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba9e cd 6a 9b			call macro_forth_dsp_pop 
baa1				endm 
# End of macro FORTH_DSP_POP
baa1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
baa1 cd b2 9a			call macro_dsp_valuehl 
baa4				endm 
# End of macro FORTH_DSP_VALUEHL
baa4					; TODO save cursor col 
baa4 f1					pop af 
baa5 85					add l		; add col offset 
baa6			 
baa6					; add current frame buffer address 
baa6 2a 61 ed				ld hl, (display_fb_active) 
baa9 cd bb 8a				call addatohl 
baac			 
baac			 
baac			 
baac			 
baac					; get char frame buffer location offset in hl 
baac			 
baac 7e					ld a,(hl) 
baad 26 00				ld h, 0 
baaf 6f					ld l, a 
bab0			 
bab0 cd bb 98				call forth_push_numhl 
bab3			 
bab3			 
bab3					NEXTW 
bab3 c3 24 9c			jp macro_next 
bab6				endm 
# End of macro NEXTW
bab6			 
bab6			.AUTODSP: 
bab6				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bab6 63				db WORD_SYS_CORE+79             
bab7 cc ba			dw .MENU            
bab9 05				db 4 + 1 
baba .. 00			db "ADSP",0              
babf				endm 
# End of macro CWHEAD
babf			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
babf			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
babf			 
babf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
babf cd b2 9a			call macro_dsp_valuehl 
bac2				endm 
# End of macro FORTH_DSP_VALUEHL
bac2			 
bac2			;		push hl 
bac2			 
bac2					; destroy value TOS 
bac2			 
bac2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bac2 cd 6a 9b			call macro_forth_dsp_pop 
bac5				endm 
# End of macro FORTH_DSP_POP
bac5			 
bac5			;		pop hl 
bac5			 
bac5 7d					ld a,l 
bac6 32 ad ec				ld (cli_autodisplay), a 
bac9				       NEXTW 
bac9 c3 24 9c			jp macro_next 
bacc				endm 
# End of macro NEXTW
bacc			 
bacc			.MENU: 
bacc				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bacc 70				db WORD_SYS_CORE+92             
bacd 75 bb			dw .ENDDISPLAY            
bacf 05				db 4 + 1 
bad0 .. 00			db "MENU",0              
bad5				endm 
# End of macro CWHEAD
bad5			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bad5			 
bad5			;		; get number of items on the stack 
bad5			; 
bad5				 
bad5					FORTH_DSP_VALUEHL 
bad5 cd b2 9a			call macro_dsp_valuehl 
bad8				endm 
# End of macro FORTH_DSP_VALUEHL
bad8				 
bad8					if DEBUG_FORTH_WORDS_KEY 
bad8						DMARK "MNU" 
bad8 f5				push af  
bad9 3a ed ba			ld a, (.dmark)  
badc 32 c0 ee			ld (debug_mark),a  
badf 3a ee ba			ld a, (.dmark+1)  
bae2 32 c1 ee			ld (debug_mark+1),a  
bae5 3a ef ba			ld a, (.dmark+2)  
bae8 32 c2 ee			ld (debug_mark+2),a  
baeb 18 03			jr .pastdmark  
baed ..			.dmark: db "MNU"  
baf0 f1			.pastdmark: pop af  
baf1			endm  
# End of macro DMARK
baf1						CALLMONITOR 
baf1 cd 2e 93			call break_point_state  
baf4				endm  
# End of macro CALLMONITOR
baf4					endif 
baf4			 
baf4 45					ld b, l	 
baf5 05					dec b 
baf6			 
baf6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
baf6 cd 6a 9b			call macro_forth_dsp_pop 
baf9				endm 
# End of macro FORTH_DSP_POP
baf9			 
baf9			 
baf9					; go directly through the stack to pluck out the string pointers and build an array 
baf9			 
baf9			;		FORTH_DSP 
baf9			 
baf9					; hl contains top most stack item 
baf9				 
baf9 11 e6 e4				ld de, scratch 
bafc			 
bafc			.mbuild: 
bafc			 
bafc					FORTH_DSP_VALUEHL 
bafc cd b2 9a			call macro_dsp_valuehl 
baff				endm 
# End of macro FORTH_DSP_VALUEHL
baff			 
baff					if DEBUG_FORTH_WORDS 
baff						DMARK "MN3" 
baff f5				push af  
bb00 3a 14 bb			ld a, (.dmark)  
bb03 32 c0 ee			ld (debug_mark),a  
bb06 3a 15 bb			ld a, (.dmark+1)  
bb09 32 c1 ee			ld (debug_mark+1),a  
bb0c 3a 16 bb			ld a, (.dmark+2)  
bb0f 32 c2 ee			ld (debug_mark+2),a  
bb12 18 03			jr .pastdmark  
bb14 ..			.dmark: db "MN3"  
bb17 f1			.pastdmark: pop af  
bb18			endm  
# End of macro DMARK
bb18						CALLMONITOR 
bb18 cd 2e 93			call break_point_state  
bb1b				endm  
# End of macro CALLMONITOR
bb1b					endif 
bb1b eb					ex de, hl 
bb1c 73					ld (hl), e 
bb1d 23					inc hl 
bb1e 72					ld (hl), d 
bb1f 23					inc hl 
bb20 eb					ex de, hl 
bb21			 
bb21					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb21 cd 6a 9b			call macro_forth_dsp_pop 
bb24				endm 
# End of macro FORTH_DSP_POP
bb24			 
bb24 10 d6				djnz .mbuild 
bb26			 
bb26					; done add term 
bb26			 
bb26 eb					ex de, hl 
bb27 36 00				ld (hl), 0 
bb29 23					inc hl 
bb2a 36 00				ld (hl), 0 
bb2c			 
bb2c				 
bb2c					 
bb2c 21 e6 e4				ld hl, scratch 
bb2f			 
bb2f					if DEBUG_FORTH_WORDS 
bb2f						DMARK "MNx" 
bb2f f5				push af  
bb30 3a 44 bb			ld a, (.dmark)  
bb33 32 c0 ee			ld (debug_mark),a  
bb36 3a 45 bb			ld a, (.dmark+1)  
bb39 32 c1 ee			ld (debug_mark+1),a  
bb3c 3a 46 bb			ld a, (.dmark+2)  
bb3f 32 c2 ee			ld (debug_mark+2),a  
bb42 18 03			jr .pastdmark  
bb44 ..			.dmark: db "MNx"  
bb47 f1			.pastdmark: pop af  
bb48			endm  
# End of macro DMARK
bb48						CALLMONITOR 
bb48 cd 2e 93			call break_point_state  
bb4b				endm  
# End of macro CALLMONITOR
bb4b					endif 
bb4b			 
bb4b			 
bb4b			 
bb4b 3e 00				ld a, 0 
bb4d cd bf 88				call menu 
bb50			 
bb50			 
bb50 6f					ld l, a 
bb51 26 00				ld h, 0 
bb53			 
bb53					if DEBUG_FORTH_WORDS 
bb53						DMARK "MNr" 
bb53 f5				push af  
bb54 3a 68 bb			ld a, (.dmark)  
bb57 32 c0 ee			ld (debug_mark),a  
bb5a 3a 69 bb			ld a, (.dmark+1)  
bb5d 32 c1 ee			ld (debug_mark+1),a  
bb60 3a 6a bb			ld a, (.dmark+2)  
bb63 32 c2 ee			ld (debug_mark+2),a  
bb66 18 03			jr .pastdmark  
bb68 ..			.dmark: db "MNr"  
bb6b f1			.pastdmark: pop af  
bb6c			endm  
# End of macro DMARK
bb6c						CALLMONITOR 
bb6c cd 2e 93			call break_point_state  
bb6f				endm  
# End of macro CALLMONITOR
bb6f					endif 
bb6f			 
bb6f cd bb 98				call forth_push_numhl 
bb72			 
bb72			 
bb72			 
bb72			 
bb72				       NEXTW 
bb72 c3 24 9c			jp macro_next 
bb75				endm 
# End of macro NEXTW
bb75			 
bb75			 
bb75			.ENDDISPLAY: 
bb75			 
bb75			; eof 
# End of file forth_words_display.asm
bb75			include "forth_words_str.asm" 
bb75			 
bb75			; | ## String Words 
bb75			 
bb75			.PTR:   
bb75			 
bb75				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bb75 48				db WORD_SYS_CORE+52             
bb76 a2 bb			dw .STYPE            
bb78 04				db 3 + 1 
bb79 .. 00			db "PTR",0              
bb7d				endm 
# End of macro CWHEAD
bb7d			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bb7d			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bb7d			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bb7d			 
bb7d					if DEBUG_FORTH_WORDS_KEY 
bb7d						DMARK "PTR" 
bb7d f5				push af  
bb7e 3a 92 bb			ld a, (.dmark)  
bb81 32 c0 ee			ld (debug_mark),a  
bb84 3a 93 bb			ld a, (.dmark+1)  
bb87 32 c1 ee			ld (debug_mark+1),a  
bb8a 3a 94 bb			ld a, (.dmark+2)  
bb8d 32 c2 ee			ld (debug_mark+2),a  
bb90 18 03			jr .pastdmark  
bb92 ..			.dmark: db "PTR"  
bb95 f1			.pastdmark: pop af  
bb96			endm  
# End of macro DMARK
bb96						CALLMONITOR 
bb96 cd 2e 93			call break_point_state  
bb99				endm  
# End of macro CALLMONITOR
bb99					endif 
bb99					FORTH_DSP_VALUEHL 
bb99 cd b2 9a			call macro_dsp_valuehl 
bb9c				endm 
# End of macro FORTH_DSP_VALUEHL
bb9c cd bb 98				call forth_push_numhl 
bb9f			 
bb9f			 
bb9f					NEXTW 
bb9f c3 24 9c			jp macro_next 
bba2				endm 
# End of macro NEXTW
bba2			.STYPE: 
bba2				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bba2 48				db WORD_SYS_CORE+52             
bba3 f1 bb			dw .UPPER            
bba5 06				db 5 + 1 
bba6 .. 00			db "STYPE",0              
bbac				endm 
# End of macro CWHEAD
bbac			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bbac					if DEBUG_FORTH_WORDS_KEY 
bbac						DMARK "STY" 
bbac f5				push af  
bbad 3a c1 bb			ld a, (.dmark)  
bbb0 32 c0 ee			ld (debug_mark),a  
bbb3 3a c2 bb			ld a, (.dmark+1)  
bbb6 32 c1 ee			ld (debug_mark+1),a  
bbb9 3a c3 bb			ld a, (.dmark+2)  
bbbc 32 c2 ee			ld (debug_mark+2),a  
bbbf 18 03			jr .pastdmark  
bbc1 ..			.dmark: db "STY"  
bbc4 f1			.pastdmark: pop af  
bbc5			endm  
# End of macro DMARK
bbc5						CALLMONITOR 
bbc5 cd 2e 93			call break_point_state  
bbc8				endm  
# End of macro CALLMONITOR
bbc8					endif 
bbc8					FORTH_DSP 
bbc8 cd 78 9a			call macro_forth_dsp 
bbcb				endm 
# End of macro FORTH_DSP
bbcb					;v5 FORTH_DSP_VALUE 
bbcb			 
bbcb 7e					ld a, (hl) 
bbcc			 
bbcc f5					push af 
bbcd			 
bbcd			; Dont destroy TOS		FORTH_DSP_POP 
bbcd			 
bbcd f1					pop af 
bbce			 
bbce fe 01				cp DS_TYPE_STR 
bbd0 28 09				jr z, .typestr 
bbd2			 
bbd2 fe 02				cp DS_TYPE_INUM 
bbd4 28 0a				jr z, .typeinum 
bbd6			 
bbd6 21 ef bb				ld hl, .tna 
bbd9 18 0a				jr .tpush 
bbdb			 
bbdb 21 eb bb		.typestr:	ld hl, .tstr 
bbde 18 05				jr .tpush 
bbe0 21 ed bb		.typeinum:	ld hl, .tinum 
bbe3 18 00				jr .tpush 
bbe5			 
bbe5			.tpush: 
bbe5			 
bbe5 cd 29 99				call forth_push_str 
bbe8			 
bbe8					NEXTW 
bbe8 c3 24 9c			jp macro_next 
bbeb				endm 
# End of macro NEXTW
bbeb .. 00		.tstr:	db "s",0 
bbed .. 00		.tinum:  db "i",0 
bbef .. 00		.tna:   db "?", 0 
bbf1			 
bbf1			 
bbf1			.UPPER: 
bbf1				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bbf1 48				db WORD_SYS_CORE+52             
bbf2 2c bc			dw .LOWER            
bbf4 06				db 5 + 1 
bbf5 .. 00			db "UPPER",0              
bbfb				endm 
# End of macro CWHEAD
bbfb			; | UPPER ( s -- s ) Upper case string s  | DONE 
bbfb					if DEBUG_FORTH_WORDS_KEY 
bbfb						DMARK "UPR" 
bbfb f5				push af  
bbfc 3a 10 bc			ld a, (.dmark)  
bbff 32 c0 ee			ld (debug_mark),a  
bc02 3a 11 bc			ld a, (.dmark+1)  
bc05 32 c1 ee			ld (debug_mark+1),a  
bc08 3a 12 bc			ld a, (.dmark+2)  
bc0b 32 c2 ee			ld (debug_mark+2),a  
bc0e 18 03			jr .pastdmark  
bc10 ..			.dmark: db "UPR"  
bc13 f1			.pastdmark: pop af  
bc14			endm  
# End of macro DMARK
bc14						CALLMONITOR 
bc14 cd 2e 93			call break_point_state  
bc17				endm  
# End of macro CALLMONITOR
bc17					endif 
bc17			 
bc17					FORTH_DSP 
bc17 cd 78 9a			call macro_forth_dsp 
bc1a				endm 
# End of macro FORTH_DSP
bc1a					 
bc1a			; TODO check is string type 
bc1a			 
bc1a					FORTH_DSP_VALUEHL 
bc1a cd b2 9a			call macro_dsp_valuehl 
bc1d				endm 
# End of macro FORTH_DSP_VALUEHL
bc1d			; get pointer to string in hl 
bc1d			 
bc1d 7e			.toup:		ld a, (hl) 
bc1e fe 00				cp 0 
bc20 28 07				jr z, .toupdone 
bc22			 
bc22 cd 28 8e				call to_upper 
bc25			 
bc25 77					ld (hl), a 
bc26 23					inc hl 
bc27 18 f4				jr .toup 
bc29			 
bc29					 
bc29			 
bc29			 
bc29			; for each char convert to upper 
bc29					 
bc29			.toupdone: 
bc29			 
bc29			 
bc29					NEXTW 
bc29 c3 24 9c			jp macro_next 
bc2c				endm 
# End of macro NEXTW
bc2c			.LOWER: 
bc2c				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bc2c 48				db WORD_SYS_CORE+52             
bc2d 67 bc			dw .TCASE            
bc2f 06				db 5 + 1 
bc30 .. 00			db "LOWER",0              
bc36				endm 
# End of macro CWHEAD
bc36			; | LOWER ( s -- s ) Lower case string s  | DONE 
bc36					if DEBUG_FORTH_WORDS_KEY 
bc36						DMARK "LWR" 
bc36 f5				push af  
bc37 3a 4b bc			ld a, (.dmark)  
bc3a 32 c0 ee			ld (debug_mark),a  
bc3d 3a 4c bc			ld a, (.dmark+1)  
bc40 32 c1 ee			ld (debug_mark+1),a  
bc43 3a 4d bc			ld a, (.dmark+2)  
bc46 32 c2 ee			ld (debug_mark+2),a  
bc49 18 03			jr .pastdmark  
bc4b ..			.dmark: db "LWR"  
bc4e f1			.pastdmark: pop af  
bc4f			endm  
# End of macro DMARK
bc4f						CALLMONITOR 
bc4f cd 2e 93			call break_point_state  
bc52				endm  
# End of macro CALLMONITOR
bc52					endif 
bc52			 
bc52					FORTH_DSP 
bc52 cd 78 9a			call macro_forth_dsp 
bc55				endm 
# End of macro FORTH_DSP
bc55					 
bc55			; TODO check is string type 
bc55			 
bc55					FORTH_DSP_VALUEHL 
bc55 cd b2 9a			call macro_dsp_valuehl 
bc58				endm 
# End of macro FORTH_DSP_VALUEHL
bc58			; get pointer to string in hl 
bc58			 
bc58 7e			.tolow:		ld a, (hl) 
bc59 fe 00				cp 0 
bc5b 28 07				jr z, .tolowdone 
bc5d			 
bc5d cd 31 8e				call to_lower 
bc60			 
bc60 77					ld (hl), a 
bc61 23					inc hl 
bc62 18 f4				jr .tolow 
bc64			 
bc64					 
bc64			 
bc64			 
bc64			; for each char convert to low 
bc64					 
bc64			.tolowdone: 
bc64					NEXTW 
bc64 c3 24 9c			jp macro_next 
bc67				endm 
# End of macro NEXTW
bc67			.TCASE: 
bc67				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bc67 48				db WORD_SYS_CORE+52             
bc68 9d bd			dw .SUBSTR            
bc6a 06				db 5 + 1 
bc6b .. 00			db "TCASE",0              
bc71				endm 
# End of macro CWHEAD
bc71			; | TCASE ( s -- s ) Title case string s  | DONE 
bc71					if DEBUG_FORTH_WORDS_KEY 
bc71						DMARK "TCS" 
bc71 f5				push af  
bc72 3a 86 bc			ld a, (.dmark)  
bc75 32 c0 ee			ld (debug_mark),a  
bc78 3a 87 bc			ld a, (.dmark+1)  
bc7b 32 c1 ee			ld (debug_mark+1),a  
bc7e 3a 88 bc			ld a, (.dmark+2)  
bc81 32 c2 ee			ld (debug_mark+2),a  
bc84 18 03			jr .pastdmark  
bc86 ..			.dmark: db "TCS"  
bc89 f1			.pastdmark: pop af  
bc8a			endm  
# End of macro DMARK
bc8a						CALLMONITOR 
bc8a cd 2e 93			call break_point_state  
bc8d				endm  
# End of macro CALLMONITOR
bc8d					endif 
bc8d			 
bc8d					FORTH_DSP 
bc8d cd 78 9a			call macro_forth_dsp 
bc90				endm 
# End of macro FORTH_DSP
bc90					 
bc90			; TODO check is string type 
bc90			 
bc90					FORTH_DSP_VALUEHL 
bc90 cd b2 9a			call macro_dsp_valuehl 
bc93				endm 
# End of macro FORTH_DSP_VALUEHL
bc93			; get pointer to string in hl 
bc93			 
bc93					if DEBUG_FORTH_WORDS 
bc93						DMARK "TC1" 
bc93 f5				push af  
bc94 3a a8 bc			ld a, (.dmark)  
bc97 32 c0 ee			ld (debug_mark),a  
bc9a 3a a9 bc			ld a, (.dmark+1)  
bc9d 32 c1 ee			ld (debug_mark+1),a  
bca0 3a aa bc			ld a, (.dmark+2)  
bca3 32 c2 ee			ld (debug_mark+2),a  
bca6 18 03			jr .pastdmark  
bca8 ..			.dmark: db "TC1"  
bcab f1			.pastdmark: pop af  
bcac			endm  
# End of macro DMARK
bcac						CALLMONITOR 
bcac cd 2e 93			call break_point_state  
bcaf				endm  
# End of macro CALLMONITOR
bcaf					endif 
bcaf			 
bcaf					; first time in turn to upper case first char 
bcaf			 
bcaf 7e					ld a, (hl) 
bcb0 c3 3a bd				jp .totsiptou 
bcb3			 
bcb3			 
bcb3 7e			.tot:		ld a, (hl) 
bcb4 fe 00				cp 0 
bcb6 ca 7e bd				jp z, .totdone 
bcb9			 
bcb9					if DEBUG_FORTH_WORDS 
bcb9						DMARK "TC2" 
bcb9 f5				push af  
bcba 3a ce bc			ld a, (.dmark)  
bcbd 32 c0 ee			ld (debug_mark),a  
bcc0 3a cf bc			ld a, (.dmark+1)  
bcc3 32 c1 ee			ld (debug_mark+1),a  
bcc6 3a d0 bc			ld a, (.dmark+2)  
bcc9 32 c2 ee			ld (debug_mark+2),a  
bccc 18 03			jr .pastdmark  
bcce ..			.dmark: db "TC2"  
bcd1 f1			.pastdmark: pop af  
bcd2			endm  
# End of macro DMARK
bcd2						CALLMONITOR 
bcd2 cd 2e 93			call break_point_state  
bcd5				endm  
# End of macro CALLMONITOR
bcd5					endif 
bcd5					; check to see if current char is a space 
bcd5			 
bcd5 fe 20				cp ' ' 
bcd7 28 21				jr z, .totsp 
bcd9 cd 31 8e				call to_lower 
bcdc					if DEBUG_FORTH_WORDS 
bcdc						DMARK "TC3" 
bcdc f5				push af  
bcdd 3a f1 bc			ld a, (.dmark)  
bce0 32 c0 ee			ld (debug_mark),a  
bce3 3a f2 bc			ld a, (.dmark+1)  
bce6 32 c1 ee			ld (debug_mark+1),a  
bce9 3a f3 bc			ld a, (.dmark+2)  
bcec 32 c2 ee			ld (debug_mark+2),a  
bcef 18 03			jr .pastdmark  
bcf1 ..			.dmark: db "TC3"  
bcf4 f1			.pastdmark: pop af  
bcf5			endm  
# End of macro DMARK
bcf5						CALLMONITOR 
bcf5 cd 2e 93			call break_point_state  
bcf8				endm  
# End of macro CALLMONITOR
bcf8					endif 
bcf8 18 63				jr .totnxt 
bcfa			 
bcfa			.totsp:         ; on a space, find next char which should be upper 
bcfa			 
bcfa					if DEBUG_FORTH_WORDS 
bcfa						DMARK "TC4" 
bcfa f5				push af  
bcfb 3a 0f bd			ld a, (.dmark)  
bcfe 32 c0 ee			ld (debug_mark),a  
bd01 3a 10 bd			ld a, (.dmark+1)  
bd04 32 c1 ee			ld (debug_mark+1),a  
bd07 3a 11 bd			ld a, (.dmark+2)  
bd0a 32 c2 ee			ld (debug_mark+2),a  
bd0d 18 03			jr .pastdmark  
bd0f ..			.dmark: db "TC4"  
bd12 f1			.pastdmark: pop af  
bd13			endm  
# End of macro DMARK
bd13						CALLMONITOR 
bd13 cd 2e 93			call break_point_state  
bd16				endm  
# End of macro CALLMONITOR
bd16					endif 
bd16					;; 
bd16			 
bd16 fe 20				cp ' ' 
bd18 20 20				jr nz, .totsiptou 
bd1a 23					inc hl 
bd1b 7e					ld a, (hl) 
bd1c					if DEBUG_FORTH_WORDS 
bd1c						DMARK "TC5" 
bd1c f5				push af  
bd1d 3a 31 bd			ld a, (.dmark)  
bd20 32 c0 ee			ld (debug_mark),a  
bd23 3a 32 bd			ld a, (.dmark+1)  
bd26 32 c1 ee			ld (debug_mark+1),a  
bd29 3a 33 bd			ld a, (.dmark+2)  
bd2c 32 c2 ee			ld (debug_mark+2),a  
bd2f 18 03			jr .pastdmark  
bd31 ..			.dmark: db "TC5"  
bd34 f1			.pastdmark: pop af  
bd35			endm  
# End of macro DMARK
bd35						CALLMONITOR 
bd35 cd 2e 93			call break_point_state  
bd38				endm  
# End of macro CALLMONITOR
bd38					endif 
bd38 18 c0				jr .totsp 
bd3a fe 00		.totsiptou:    cp 0 
bd3c 28 40				jr z, .totdone 
bd3e					; not space and not zero term so upper case it 
bd3e cd 28 8e				call to_upper 
bd41			 
bd41					if DEBUG_FORTH_WORDS 
bd41						DMARK "TC6" 
bd41 f5				push af  
bd42 3a 56 bd			ld a, (.dmark)  
bd45 32 c0 ee			ld (debug_mark),a  
bd48 3a 57 bd			ld a, (.dmark+1)  
bd4b 32 c1 ee			ld (debug_mark+1),a  
bd4e 3a 58 bd			ld a, (.dmark+2)  
bd51 32 c2 ee			ld (debug_mark+2),a  
bd54 18 03			jr .pastdmark  
bd56 ..			.dmark: db "TC6"  
bd59 f1			.pastdmark: pop af  
bd5a			endm  
# End of macro DMARK
bd5a						CALLMONITOR 
bd5a cd 2e 93			call break_point_state  
bd5d				endm  
# End of macro CALLMONITOR
bd5d					endif 
bd5d			 
bd5d			 
bd5d			.totnxt: 
bd5d			 
bd5d 77					ld (hl), a 
bd5e 23					inc hl 
bd5f					if DEBUG_FORTH_WORDS 
bd5f						DMARK "TC7" 
bd5f f5				push af  
bd60 3a 74 bd			ld a, (.dmark)  
bd63 32 c0 ee			ld (debug_mark),a  
bd66 3a 75 bd			ld a, (.dmark+1)  
bd69 32 c1 ee			ld (debug_mark+1),a  
bd6c 3a 76 bd			ld a, (.dmark+2)  
bd6f 32 c2 ee			ld (debug_mark+2),a  
bd72 18 03			jr .pastdmark  
bd74 ..			.dmark: db "TC7"  
bd77 f1			.pastdmark: pop af  
bd78			endm  
# End of macro DMARK
bd78						CALLMONITOR 
bd78 cd 2e 93			call break_point_state  
bd7b				endm  
# End of macro CALLMONITOR
bd7b					endif 
bd7b c3 b3 bc				jp .tot 
bd7e			 
bd7e					 
bd7e			 
bd7e			 
bd7e			; for each char convert to low 
bd7e					 
bd7e			.totdone: 
bd7e					if DEBUG_FORTH_WORDS 
bd7e						DMARK "TCd" 
bd7e f5				push af  
bd7f 3a 93 bd			ld a, (.dmark)  
bd82 32 c0 ee			ld (debug_mark),a  
bd85 3a 94 bd			ld a, (.dmark+1)  
bd88 32 c1 ee			ld (debug_mark+1),a  
bd8b 3a 95 bd			ld a, (.dmark+2)  
bd8e 32 c2 ee			ld (debug_mark+2),a  
bd91 18 03			jr .pastdmark  
bd93 ..			.dmark: db "TCd"  
bd96 f1			.pastdmark: pop af  
bd97			endm  
# End of macro DMARK
bd97						CALLMONITOR 
bd97 cd 2e 93			call break_point_state  
bd9a				endm  
# End of macro CALLMONITOR
bd9a					endif 
bd9a					NEXTW 
bd9a c3 24 9c			jp macro_next 
bd9d				endm 
# End of macro NEXTW
bd9d			 
bd9d			.SUBSTR: 
bd9d				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
bd9d 48				db WORD_SYS_CORE+52             
bd9e fb bd			dw .LEFT            
bda0 07				db 6 + 1 
bda1 .. 00			db "SUBSTR",0              
bda8				endm 
# End of macro CWHEAD
bda8			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
bda8			 
bda8					if DEBUG_FORTH_WORDS_KEY 
bda8						DMARK "SST" 
bda8 f5				push af  
bda9 3a bd bd			ld a, (.dmark)  
bdac 32 c0 ee			ld (debug_mark),a  
bdaf 3a be bd			ld a, (.dmark+1)  
bdb2 32 c1 ee			ld (debug_mark+1),a  
bdb5 3a bf bd			ld a, (.dmark+2)  
bdb8 32 c2 ee			ld (debug_mark+2),a  
bdbb 18 03			jr .pastdmark  
bdbd ..			.dmark: db "SST"  
bdc0 f1			.pastdmark: pop af  
bdc1			endm  
# End of macro DMARK
bdc1						CALLMONITOR 
bdc1 cd 2e 93			call break_point_state  
bdc4				endm  
# End of macro CALLMONITOR
bdc4					endif 
bdc4			; TODO check string type 
bdc4					FORTH_DSP_VALUEHL 
bdc4 cd b2 9a			call macro_dsp_valuehl 
bdc7				endm 
# End of macro FORTH_DSP_VALUEHL
bdc7			 
bdc7 e5					push hl      ; string length 
bdc8			 
bdc8					FORTH_DSP_POP 
bdc8 cd 6a 9b			call macro_forth_dsp_pop 
bdcb				endm 
# End of macro FORTH_DSP_POP
bdcb			 
bdcb					FORTH_DSP_VALUEHL 
bdcb cd b2 9a			call macro_dsp_valuehl 
bdce				endm 
# End of macro FORTH_DSP_VALUEHL
bdce			 
bdce e5					push hl     ; start char 
bdcf			 
bdcf					FORTH_DSP_POP 
bdcf cd 6a 9b			call macro_forth_dsp_pop 
bdd2				endm 
# End of macro FORTH_DSP_POP
bdd2			 
bdd2			 
bdd2					FORTH_DSP_VALUE 
bdd2 cd 9b 9a			call macro_forth_dsp_value 
bdd5				endm 
# End of macro FORTH_DSP_VALUE
bdd5			 
bdd5 d1					pop de    ; get start post offset 
bdd6			 
bdd6 19					add hl, de    ; starting offset 
bdd7			 
bdd7 c1					pop bc 
bdd8 c5					push bc      ; grab size of string 
bdd9			 
bdd9 e5					push hl    ; save string start  
bdda			 
bdda 26 00				ld h, 0 
bddc 69					ld l, c 
bddd 23					inc hl 
bdde 23					inc hl 
bddf			 
bddf cd 82 8f				call malloc 
bde2				if DEBUG_FORTH_MALLOC_GUARD 
bde2 cc 2a c4				call z,malloc_error 
bde5				endif 
bde5			 
bde5 eb					ex de, hl      ; save malloc area for string copy 
bde6 e1					pop hl    ; get back source 
bde7 c1					pop bc    ; get length of string back 
bde8			 
bde8 d5					push de    ; save malloc area for after we push 
bde9 ed b0				ldir     ; copy substr 
bdeb			 
bdeb			 
bdeb eb					ex de, hl 
bdec 3e 00				ld a, 0 
bdee 77					ld (hl), a   ; term substr 
bdef			 
bdef					 
bdef e1					pop hl    ; get malloc so we can push it 
bdf0 e5					push hl   ; save so we can free it afterwards 
bdf1			 
bdf1 cd 29 99				call forth_push_str 
bdf4			 
bdf4 e1					pop hl 
bdf5 cd 4c 90				call free 
bdf8			 
bdf8					 
bdf8					 
bdf8			 
bdf8			 
bdf8					NEXTW 
bdf8 c3 24 9c			jp macro_next 
bdfb				endm 
# End of macro NEXTW
bdfb			 
bdfb			.LEFT: 
bdfb				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
bdfb 48				db WORD_SYS_CORE+52             
bdfc 23 be			dw .RIGHT            
bdfe 05				db 4 + 1 
bdff .. 00			db "LEFT",0              
be04				endm 
# End of macro CWHEAD
be04			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
be04					if DEBUG_FORTH_WORDS_KEY 
be04						DMARK "LEF" 
be04 f5				push af  
be05 3a 19 be			ld a, (.dmark)  
be08 32 c0 ee			ld (debug_mark),a  
be0b 3a 1a be			ld a, (.dmark+1)  
be0e 32 c1 ee			ld (debug_mark+1),a  
be11 3a 1b be			ld a, (.dmark+2)  
be14 32 c2 ee			ld (debug_mark+2),a  
be17 18 03			jr .pastdmark  
be19 ..			.dmark: db "LEF"  
be1c f1			.pastdmark: pop af  
be1d			endm  
# End of macro DMARK
be1d						CALLMONITOR 
be1d cd 2e 93			call break_point_state  
be20				endm  
# End of macro CALLMONITOR
be20					endif 
be20			 
be20					NEXTW 
be20 c3 24 9c			jp macro_next 
be23				endm 
# End of macro NEXTW
be23			.RIGHT: 
be23				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
be23 48				db WORD_SYS_CORE+52             
be24 4c be			dw .STR2NUM            
be26 06				db 5 + 1 
be27 .. 00			db "RIGHT",0              
be2d				endm 
# End of macro CWHEAD
be2d			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
be2d					if DEBUG_FORTH_WORDS_KEY 
be2d						DMARK "RIG" 
be2d f5				push af  
be2e 3a 42 be			ld a, (.dmark)  
be31 32 c0 ee			ld (debug_mark),a  
be34 3a 43 be			ld a, (.dmark+1)  
be37 32 c1 ee			ld (debug_mark+1),a  
be3a 3a 44 be			ld a, (.dmark+2)  
be3d 32 c2 ee			ld (debug_mark+2),a  
be40 18 03			jr .pastdmark  
be42 ..			.dmark: db "RIG"  
be45 f1			.pastdmark: pop af  
be46			endm  
# End of macro DMARK
be46						CALLMONITOR 
be46 cd 2e 93			call break_point_state  
be49				endm  
# End of macro CALLMONITOR
be49					endif 
be49			 
be49					NEXTW 
be49 c3 24 9c			jp macro_next 
be4c				endm 
# End of macro NEXTW
be4c			 
be4c			 
be4c			.STR2NUM: 
be4c				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
be4c 48				db WORD_SYS_CORE+52             
be4d d8 be			dw .NUM2STR            
be4f 08				db 7 + 1 
be50 .. 00			db "STR2NUM",0              
be58				endm 
# End of macro CWHEAD
be58			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
be58			 
be58			 
be58			; TODO STR type check to do 
be58					if DEBUG_FORTH_WORDS_KEY 
be58						DMARK "S2N" 
be58 f5				push af  
be59 3a 6d be			ld a, (.dmark)  
be5c 32 c0 ee			ld (debug_mark),a  
be5f 3a 6e be			ld a, (.dmark+1)  
be62 32 c1 ee			ld (debug_mark+1),a  
be65 3a 6f be			ld a, (.dmark+2)  
be68 32 c2 ee			ld (debug_mark+2),a  
be6b 18 03			jr .pastdmark  
be6d ..			.dmark: db "S2N"  
be70 f1			.pastdmark: pop af  
be71			endm  
# End of macro DMARK
be71						CALLMONITOR 
be71 cd 2e 93			call break_point_state  
be74				endm  
# End of macro CALLMONITOR
be74					endif 
be74			 
be74					;FORTH_DSP 
be74					FORTH_DSP_VALUE 
be74 cd 9b 9a			call macro_forth_dsp_value 
be77				endm 
# End of macro FORTH_DSP_VALUE
be77					;inc hl 
be77			 
be77 eb					ex de, hl 
be78					if DEBUG_FORTH_WORDS 
be78						DMARK "S2a" 
be78 f5				push af  
be79 3a 8d be			ld a, (.dmark)  
be7c 32 c0 ee			ld (debug_mark),a  
be7f 3a 8e be			ld a, (.dmark+1)  
be82 32 c1 ee			ld (debug_mark+1),a  
be85 3a 8f be			ld a, (.dmark+2)  
be88 32 c2 ee			ld (debug_mark+2),a  
be8b 18 03			jr .pastdmark  
be8d ..			.dmark: db "S2a"  
be90 f1			.pastdmark: pop af  
be91			endm  
# End of macro DMARK
be91						CALLMONITOR 
be91 cd 2e 93			call break_point_state  
be94				endm  
# End of macro CALLMONITOR
be94					endif 
be94 cd b0 8e				call string_to_uint16 
be97			 
be97					if DEBUG_FORTH_WORDS 
be97						DMARK "S2b" 
be97 f5				push af  
be98 3a ac be			ld a, (.dmark)  
be9b 32 c0 ee			ld (debug_mark),a  
be9e 3a ad be			ld a, (.dmark+1)  
bea1 32 c1 ee			ld (debug_mark+1),a  
bea4 3a ae be			ld a, (.dmark+2)  
bea7 32 c2 ee			ld (debug_mark+2),a  
beaa 18 03			jr .pastdmark  
beac ..			.dmark: db "S2b"  
beaf f1			.pastdmark: pop af  
beb0			endm  
# End of macro DMARK
beb0						CALLMONITOR 
beb0 cd 2e 93			call break_point_state  
beb3				endm  
# End of macro CALLMONITOR
beb3					endif 
beb3			;		push hl 
beb3					FORTH_DSP_POP 
beb3 cd 6a 9b			call macro_forth_dsp_pop 
beb6				endm 
# End of macro FORTH_DSP_POP
beb6			;		pop hl 
beb6					 
beb6					if DEBUG_FORTH_WORDS 
beb6						DMARK "S2b" 
beb6 f5				push af  
beb7 3a cb be			ld a, (.dmark)  
beba 32 c0 ee			ld (debug_mark),a  
bebd 3a cc be			ld a, (.dmark+1)  
bec0 32 c1 ee			ld (debug_mark+1),a  
bec3 3a cd be			ld a, (.dmark+2)  
bec6 32 c2 ee			ld (debug_mark+2),a  
bec9 18 03			jr .pastdmark  
becb ..			.dmark: db "S2b"  
bece f1			.pastdmark: pop af  
becf			endm  
# End of macro DMARK
becf						CALLMONITOR 
becf cd 2e 93			call break_point_state  
bed2				endm  
# End of macro CALLMONITOR
bed2					endif 
bed2 cd bb 98				call forth_push_numhl	 
bed5			 
bed5				 
bed5				       NEXTW 
bed5 c3 24 9c			jp macro_next 
bed8				endm 
# End of macro NEXTW
bed8			.NUM2STR: 
bed8				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
bed8 48				db WORD_SYS_CORE+52             
bed9 e7 be			dw .CONCAT            
bedb 08				db 7 + 1 
bedc .. 00			db "NUM2STR",0              
bee4				endm 
# End of macro CWHEAD
bee4			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
bee4			 
bee4			;		; malloc a string to target 
bee4			;		ld hl, 10     ; TODO max string size should be fine 
bee4			;		call malloc 
bee4			;		push hl    ; save malloc location 
bee4			; 
bee4			; 
bee4			;; TODO check int type 
bee4			;		FORTH_DSP_VALUEHL 
bee4			;		ld a, l 
bee4			;		call DispAToASCII   
bee4			;;TODO need to chage above call to dump into string 
bee4			; 
bee4			; 
bee4			 
bee4				       NEXTW 
bee4 c3 24 9c			jp macro_next 
bee7				endm 
# End of macro NEXTW
bee7			 
bee7			.CONCAT: 
bee7				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
bee7 48				db WORD_SYS_CORE+52             
bee8 9a bf			dw .FIND            
beea 07				db 6 + 1 
beeb .. 00			db "CONCAT",0              
bef2				endm 
# End of macro CWHEAD
bef2			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
bef2			 
bef2			; TODO check string type 
bef2			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
bef2			 
bef2					if DEBUG_FORTH_WORDS_KEY 
bef2						DMARK "CON" 
bef2 f5				push af  
bef3 3a 07 bf			ld a, (.dmark)  
bef6 32 c0 ee			ld (debug_mark),a  
bef9 3a 08 bf			ld a, (.dmark+1)  
befc 32 c1 ee			ld (debug_mark+1),a  
beff 3a 09 bf			ld a, (.dmark+2)  
bf02 32 c2 ee			ld (debug_mark+2),a  
bf05 18 03			jr .pastdmark  
bf07 ..			.dmark: db "CON"  
bf0a f1			.pastdmark: pop af  
bf0b			endm  
# End of macro DMARK
bf0b						CALLMONITOR 
bf0b cd 2e 93			call break_point_state  
bf0e				endm  
# End of macro CALLMONITOR
bf0e					endif 
bf0e			 
bf0e			 
bf0e					FORTH_DSP_VALUE 
bf0e cd 9b 9a			call macro_forth_dsp_value 
bf11				endm 
# End of macro FORTH_DSP_VALUE
bf11 e5					push hl   ; s2 
bf12			 
bf12					FORTH_DSP_POP 
bf12 cd 6a 9b			call macro_forth_dsp_pop 
bf15				endm 
# End of macro FORTH_DSP_POP
bf15			 
bf15					FORTH_DSP_VALUE 
bf15 cd 9b 9a			call macro_forth_dsp_value 
bf18				endm 
# End of macro FORTH_DSP_VALUE
bf18			 
bf18 e5					push hl   ; s1 
bf19			 
bf19					FORTH_DSP_POP 
bf19 cd 6a 9b			call macro_forth_dsp_pop 
bf1c				endm 
# End of macro FORTH_DSP_POP
bf1c					 
bf1c			 
bf1c					; copy s1 
bf1c			 
bf1c				 
bf1c					; save ptr 
bf1c e1					pop hl  
bf1d e5					push hl 
bf1e 3e 00				ld a, 0 
bf20 cd 24 8f				call strlent 
bf23					;inc hl    ; zer0 
bf23 06 00				ld b, 0 
bf25 4d					ld c, l 
bf26 e1					pop hl		 
bf27 11 e6 e4				ld de, scratch	 
bf2a					if DEBUG_FORTH_WORDS 
bf2a						DMARK "CO1" 
bf2a f5				push af  
bf2b 3a 3f bf			ld a, (.dmark)  
bf2e 32 c0 ee			ld (debug_mark),a  
bf31 3a 40 bf			ld a, (.dmark+1)  
bf34 32 c1 ee			ld (debug_mark+1),a  
bf37 3a 41 bf			ld a, (.dmark+2)  
bf3a 32 c2 ee			ld (debug_mark+2),a  
bf3d 18 03			jr .pastdmark  
bf3f ..			.dmark: db "CO1"  
bf42 f1			.pastdmark: pop af  
bf43			endm  
# End of macro DMARK
bf43						CALLMONITOR 
bf43 cd 2e 93			call break_point_state  
bf46				endm  
# End of macro CALLMONITOR
bf46					endif 
bf46 ed b0				ldir 
bf48			 
bf48 e1					pop hl 
bf49 e5					push hl 
bf4a d5					push de 
bf4b			 
bf4b			 
bf4b 3e 00				ld a, 0 
bf4d cd 24 8f				call strlent 
bf50 23					inc hl    ; zer0 
bf51 23					inc hl 
bf52 06 00				ld b, 0 
bf54 4d					ld c, l 
bf55 d1					pop de 
bf56 e1					pop hl		 
bf57					if DEBUG_FORTH_WORDS 
bf57						DMARK "CO2" 
bf57 f5				push af  
bf58 3a 6c bf			ld a, (.dmark)  
bf5b 32 c0 ee			ld (debug_mark),a  
bf5e 3a 6d bf			ld a, (.dmark+1)  
bf61 32 c1 ee			ld (debug_mark+1),a  
bf64 3a 6e bf			ld a, (.dmark+2)  
bf67 32 c2 ee			ld (debug_mark+2),a  
bf6a 18 03			jr .pastdmark  
bf6c ..			.dmark: db "CO2"  
bf6f f1			.pastdmark: pop af  
bf70			endm  
# End of macro DMARK
bf70						CALLMONITOR 
bf70 cd 2e 93			call break_point_state  
bf73				endm  
# End of macro CALLMONITOR
bf73					endif 
bf73 ed b0				ldir 
bf75			 
bf75			 
bf75			 
bf75 21 e6 e4				ld hl, scratch 
bf78					if DEBUG_FORTH_WORDS 
bf78						DMARK "CO5" 
bf78 f5				push af  
bf79 3a 8d bf			ld a, (.dmark)  
bf7c 32 c0 ee			ld (debug_mark),a  
bf7f 3a 8e bf			ld a, (.dmark+1)  
bf82 32 c1 ee			ld (debug_mark+1),a  
bf85 3a 8f bf			ld a, (.dmark+2)  
bf88 32 c2 ee			ld (debug_mark+2),a  
bf8b 18 03			jr .pastdmark  
bf8d ..			.dmark: db "CO5"  
bf90 f1			.pastdmark: pop af  
bf91			endm  
# End of macro DMARK
bf91						CALLMONITOR 
bf91 cd 2e 93			call break_point_state  
bf94				endm  
# End of macro CALLMONITOR
bf94					endif 
bf94			 
bf94 cd 29 99				call forth_push_str 
bf97			 
bf97			 
bf97			 
bf97			 
bf97				       NEXTW 
bf97 c3 24 9c			jp macro_next 
bf9a				endm 
# End of macro NEXTW
bf9a			 
bf9a			 
bf9a			.FIND: 
bf9a				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
bf9a 4b				db WORD_SYS_CORE+55             
bf9b 58 c0			dw .LEN            
bf9d 05				db 4 + 1 
bf9e .. 00			db "FIND",0              
bfa3				endm 
# End of macro CWHEAD
bfa3			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
bfa3			 
bfa3					if DEBUG_FORTH_WORDS_KEY 
bfa3						DMARK "FND" 
bfa3 f5				push af  
bfa4 3a b8 bf			ld a, (.dmark)  
bfa7 32 c0 ee			ld (debug_mark),a  
bfaa 3a b9 bf			ld a, (.dmark+1)  
bfad 32 c1 ee			ld (debug_mark+1),a  
bfb0 3a ba bf			ld a, (.dmark+2)  
bfb3 32 c2 ee			ld (debug_mark+2),a  
bfb6 18 03			jr .pastdmark  
bfb8 ..			.dmark: db "FND"  
bfbb f1			.pastdmark: pop af  
bfbc			endm  
# End of macro DMARK
bfbc						CALLMONITOR 
bfbc cd 2e 93			call break_point_state  
bfbf				endm  
# End of macro CALLMONITOR
bfbf					endif 
bfbf			 
bfbf			; TODO check string type 
bfbf					FORTH_DSP_VALUE 
bfbf cd 9b 9a			call macro_forth_dsp_value 
bfc2				endm 
# End of macro FORTH_DSP_VALUE
bfc2			 
bfc2 e5					push hl    
bfc3 7e					ld a,(hl)    ; char to find   
bfc4			; TODO change char to substr 
bfc4			 
bfc4 f5					push af 
bfc5					 
bfc5			 
bfc5			 
bfc5					if DEBUG_FORTH_WORDS 
bfc5						DMARK "FN1" 
bfc5 f5				push af  
bfc6 3a da bf			ld a, (.dmark)  
bfc9 32 c0 ee			ld (debug_mark),a  
bfcc 3a db bf			ld a, (.dmark+1)  
bfcf 32 c1 ee			ld (debug_mark+1),a  
bfd2 3a dc bf			ld a, (.dmark+2)  
bfd5 32 c2 ee			ld (debug_mark+2),a  
bfd8 18 03			jr .pastdmark  
bfda ..			.dmark: db "FN1"  
bfdd f1			.pastdmark: pop af  
bfde			endm  
# End of macro DMARK
bfde						CALLMONITOR 
bfde cd 2e 93			call break_point_state  
bfe1				endm  
# End of macro CALLMONITOR
bfe1					endif 
bfe1			 
bfe1					FORTH_DSP_POP 
bfe1 cd 6a 9b			call macro_forth_dsp_pop 
bfe4				endm 
# End of macro FORTH_DSP_POP
bfe4			 
bfe4					; string to search 
bfe4			 
bfe4					FORTH_DSP_VALUE 
bfe4 cd 9b 9a			call macro_forth_dsp_value 
bfe7				endm 
# End of macro FORTH_DSP_VALUE
bfe7			 
bfe7 d1					pop de  ; d is char to find  
bfe8			 
bfe8					if DEBUG_FORTH_WORDS 
bfe8						DMARK "FN2" 
bfe8 f5				push af  
bfe9 3a fd bf			ld a, (.dmark)  
bfec 32 c0 ee			ld (debug_mark),a  
bfef 3a fe bf			ld a, (.dmark+1)  
bff2 32 c1 ee			ld (debug_mark+1),a  
bff5 3a ff bf			ld a, (.dmark+2)  
bff8 32 c2 ee			ld (debug_mark+2),a  
bffb 18 03			jr .pastdmark  
bffd ..			.dmark: db "FN2"  
c000 f1			.pastdmark: pop af  
c001			endm  
# End of macro DMARK
c001						CALLMONITOR 
c001 cd 2e 93			call break_point_state  
c004				endm  
# End of macro CALLMONITOR
c004					endif 
c004					 
c004 01 00 00				ld bc, 0 
c007 7e			.findchar:      ld a,(hl) 
c008 fe 00				cp 0   		 
c00a 28 27				jr z, .finddone     
c00c ba					cp d 
c00d 28 20				jr z, .foundchar 
c00f 03					inc bc 
c010 23					inc hl 
c011					if DEBUG_FORTH_WORDS 
c011						DMARK "FN3" 
c011 f5				push af  
c012 3a 26 c0			ld a, (.dmark)  
c015 32 c0 ee			ld (debug_mark),a  
c018 3a 27 c0			ld a, (.dmark+1)  
c01b 32 c1 ee			ld (debug_mark+1),a  
c01e 3a 28 c0			ld a, (.dmark+2)  
c021 32 c2 ee			ld (debug_mark+2),a  
c024 18 03			jr .pastdmark  
c026 ..			.dmark: db "FN3"  
c029 f1			.pastdmark: pop af  
c02a			endm  
# End of macro DMARK
c02a						CALLMONITOR 
c02a cd 2e 93			call break_point_state  
c02d				endm  
# End of macro CALLMONITOR
c02d					endif 
c02d 18 d8				jr .findchar 
c02f			 
c02f			 
c02f c5			.foundchar:	push bc 
c030 e1					pop hl 
c031 18 03				jr .findexit 
c033			 
c033			 
c033							 
c033			 
c033			.finddone:     ; got to end of string with no find 
c033 21 00 00				ld hl, 0 
c036			.findexit: 
c036			 
c036					if DEBUG_FORTH_WORDS 
c036						DMARK "FNd" 
c036 f5				push af  
c037 3a 4b c0			ld a, (.dmark)  
c03a 32 c0 ee			ld (debug_mark),a  
c03d 3a 4c c0			ld a, (.dmark+1)  
c040 32 c1 ee			ld (debug_mark+1),a  
c043 3a 4d c0			ld a, (.dmark+2)  
c046 32 c2 ee			ld (debug_mark+2),a  
c049 18 03			jr .pastdmark  
c04b ..			.dmark: db "FNd"  
c04e f1			.pastdmark: pop af  
c04f			endm  
# End of macro DMARK
c04f						CALLMONITOR 
c04f cd 2e 93			call break_point_state  
c052				endm  
# End of macro CALLMONITOR
c052					endif 
c052 cd bb 98			call forth_push_numhl 
c055			 
c055				       NEXTW 
c055 c3 24 9c			jp macro_next 
c058				endm 
# End of macro NEXTW
c058			 
c058			.LEN: 
c058				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c058 4c				db WORD_SYS_CORE+56             
c059 8d c0			dw .CHAR            
c05b 06				db 5 + 1 
c05c .. 00			db "COUNT",0              
c062				endm 
# End of macro CWHEAD
c062			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c062			 
c062					if DEBUG_FORTH_WORDS_KEY 
c062						DMARK "CNT" 
c062 f5				push af  
c063 3a 77 c0			ld a, (.dmark)  
c066 32 c0 ee			ld (debug_mark),a  
c069 3a 78 c0			ld a, (.dmark+1)  
c06c 32 c1 ee			ld (debug_mark+1),a  
c06f 3a 79 c0			ld a, (.dmark+2)  
c072 32 c2 ee			ld (debug_mark+2),a  
c075 18 03			jr .pastdmark  
c077 ..			.dmark: db "CNT"  
c07a f1			.pastdmark: pop af  
c07b			endm  
# End of macro DMARK
c07b						CALLMONITOR 
c07b cd 2e 93			call break_point_state  
c07e				endm  
# End of macro CALLMONITOR
c07e					endif 
c07e			; TODO check string type 
c07e					FORTH_DSP 
c07e cd 78 9a			call macro_forth_dsp 
c081				endm 
# End of macro FORTH_DSP
c081					;v5FORTH_DSP_VALUE 
c081			 
c081 23					inc hl 
c082			 
c082 3e 00				ld a, 0 
c084 cd 24 8f				call strlent 
c087			 
c087 cd bb 98				call forth_push_numhl 
c08a			 
c08a			 
c08a			 
c08a				       NEXTW 
c08a c3 24 9c			jp macro_next 
c08d				endm 
# End of macro NEXTW
c08d			.CHAR: 
c08d				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c08d 4d				db WORD_SYS_CORE+57             
c08e c3 c0			dw .ENDSTR            
c090 05				db 4 + 1 
c091 .. 00			db "CHAR",0              
c096				endm 
# End of macro CWHEAD
c096			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c096					if DEBUG_FORTH_WORDS_KEY 
c096						DMARK "CHR" 
c096 f5				push af  
c097 3a ab c0			ld a, (.dmark)  
c09a 32 c0 ee			ld (debug_mark),a  
c09d 3a ac c0			ld a, (.dmark+1)  
c0a0 32 c1 ee			ld (debug_mark+1),a  
c0a3 3a ad c0			ld a, (.dmark+2)  
c0a6 32 c2 ee			ld (debug_mark+2),a  
c0a9 18 03			jr .pastdmark  
c0ab ..			.dmark: db "CHR"  
c0ae f1			.pastdmark: pop af  
c0af			endm  
# End of macro DMARK
c0af						CALLMONITOR 
c0af cd 2e 93			call break_point_state  
c0b2				endm  
# End of macro CALLMONITOR
c0b2					endif 
c0b2					FORTH_DSP 
c0b2 cd 78 9a			call macro_forth_dsp 
c0b5				endm 
# End of macro FORTH_DSP
c0b5					;v5 FORTH_DSP_VALUE 
c0b5 23					inc hl      ; now at start of numeric as string 
c0b6			 
c0b6			;		push hl 
c0b6			 
c0b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c0b6 cd 6a 9b			call macro_forth_dsp_pop 
c0b9				endm 
# End of macro FORTH_DSP_POP
c0b9			 
c0b9			;		pop hl 
c0b9			 
c0b9					; push the content of a onto the stack as a value 
c0b9			 
c0b9 7e					ld a,(hl)   ; get char 
c0ba 26 00				ld h,0 
c0bc 6f					ld l,a 
c0bd cd bb 98				call forth_push_numhl 
c0c0			 
c0c0				       NEXTW 
c0c0 c3 24 9c			jp macro_next 
c0c3				endm 
# End of macro NEXTW
c0c3			 
c0c3			 
c0c3			 
c0c3			 
c0c3			.ENDSTR: 
c0c3			; eof 
c0c3			 
# End of file forth_words_str.asm
c0c3			include "forth_words_key.asm" 
c0c3			 
c0c3			; | ## Keyboard Words 
c0c3			 
c0c3			.KEY: 
c0c3				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c0c3 3e				db WORD_SYS_CORE+42             
c0c4 f3 c0			dw .WAITK            
c0c6 04				db 3 + 1 
c0c7 .. 00			db "KEY",0              
c0cb				endm 
# End of macro CWHEAD
c0cb			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c0cb			 
c0cb					if DEBUG_FORTH_WORDS_KEY 
c0cb						DMARK "KEY" 
c0cb f5				push af  
c0cc 3a e0 c0			ld a, (.dmark)  
c0cf 32 c0 ee			ld (debug_mark),a  
c0d2 3a e1 c0			ld a, (.dmark+1)  
c0d5 32 c1 ee			ld (debug_mark+1),a  
c0d8 3a e2 c0			ld a, (.dmark+2)  
c0db 32 c2 ee			ld (debug_mark+2),a  
c0de 18 03			jr .pastdmark  
c0e0 ..			.dmark: db "KEY"  
c0e3 f1			.pastdmark: pop af  
c0e4			endm  
# End of macro DMARK
c0e4						CALLMONITOR 
c0e4 cd 2e 93			call break_point_state  
c0e7				endm  
# End of macro CALLMONITOR
c0e7					endif 
c0e7			; TODO currently waits 
c0e7 cd 66 d7				call cin 
c0ea					;call cin_wait 
c0ea 6f					ld l, a 
c0eb 26 00				ld h, 0 
c0ed cd bb 98				call forth_push_numhl 
c0f0					NEXTW 
c0f0 c3 24 9c			jp macro_next 
c0f3				endm 
# End of macro NEXTW
c0f3			.WAITK: 
c0f3				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c0f3 3f				db WORD_SYS_CORE+43             
c0f4 25 c1			dw .ACCEPT            
c0f6 06				db 5 + 1 
c0f7 .. 00			db "WAITK",0              
c0fd				endm 
# End of macro CWHEAD
c0fd			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c0fd					if DEBUG_FORTH_WORDS_KEY 
c0fd						DMARK "WAI" 
c0fd f5				push af  
c0fe 3a 12 c1			ld a, (.dmark)  
c101 32 c0 ee			ld (debug_mark),a  
c104 3a 13 c1			ld a, (.dmark+1)  
c107 32 c1 ee			ld (debug_mark+1),a  
c10a 3a 14 c1			ld a, (.dmark+2)  
c10d 32 c2 ee			ld (debug_mark+2),a  
c110 18 03			jr .pastdmark  
c112 ..			.dmark: db "WAI"  
c115 f1			.pastdmark: pop af  
c116			endm  
# End of macro DMARK
c116						CALLMONITOR 
c116 cd 2e 93			call break_point_state  
c119				endm  
# End of macro CALLMONITOR
c119					endif 
c119 cd 60 d7				call cin_wait 
c11c 6f					ld l, a 
c11d 26 00				ld h, 0 
c11f cd bb 98				call forth_push_numhl 
c122					NEXTW 
c122 c3 24 9c			jp macro_next 
c125				endm 
# End of macro NEXTW
c125			.ACCEPT: 
c125				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c125 40				db WORD_SYS_CORE+44             
c126 83 c1			dw .EDIT            
c128 07				db 6 + 1 
c129 .. 00			db "ACCEPT",0              
c130				endm 
# End of macro CWHEAD
c130			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c130					; TODO crashes on push 
c130					if DEBUG_FORTH_WORDS_KEY 
c130						DMARK "ACC" 
c130 f5				push af  
c131 3a 45 c1			ld a, (.dmark)  
c134 32 c0 ee			ld (debug_mark),a  
c137 3a 46 c1			ld a, (.dmark+1)  
c13a 32 c1 ee			ld (debug_mark+1),a  
c13d 3a 47 c1			ld a, (.dmark+2)  
c140 32 c2 ee			ld (debug_mark+2),a  
c143 18 03			jr .pastdmark  
c145 ..			.dmark: db "ACC"  
c148 f1			.pastdmark: pop af  
c149			endm  
# End of macro DMARK
c149						CALLMONITOR 
c149 cd 2e 93			call break_point_state  
c14c				endm  
# End of macro CALLMONITOR
c14c					endif 
c14c 21 e4 e6				ld hl, os_input 
c14f 3e 00				ld a, 0 
c151 77					ld (hl),a 
c152 3a cf ec				ld a,(f_cursor_ptr) 
c155 16 64				ld d, 100 
c157 0e 00				ld c, 0 
c159 1e 28				ld e, 40 
c15b cd e8 8a				call input_str 
c15e					; TODO perhaps do a type check and wrap in quotes if not a number 
c15e 21 e4 e6				ld hl, os_input 
c161					if DEBUG_FORTH_WORDS 
c161						DMARK "AC1" 
c161 f5				push af  
c162 3a 76 c1			ld a, (.dmark)  
c165 32 c0 ee			ld (debug_mark),a  
c168 3a 77 c1			ld a, (.dmark+1)  
c16b 32 c1 ee			ld (debug_mark+1),a  
c16e 3a 78 c1			ld a, (.dmark+2)  
c171 32 c2 ee			ld (debug_mark+2),a  
c174 18 03			jr .pastdmark  
c176 ..			.dmark: db "AC1"  
c179 f1			.pastdmark: pop af  
c17a			endm  
# End of macro DMARK
c17a						CALLMONITOR 
c17a cd 2e 93			call break_point_state  
c17d				endm  
# End of macro CALLMONITOR
c17d					endif 
c17d cd 29 99				call forth_push_str 
c180					NEXTW 
c180 c3 24 9c			jp macro_next 
c183				endm 
# End of macro NEXTW
c183			 
c183			.EDIT: 
c183				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c183 40				db WORD_SYS_CORE+44             
c184 25 c2			dw .ENDKEY            
c186 05				db 4 + 1 
c187 .. 00			db "EDIT",0              
c18c				endm 
# End of macro CWHEAD
c18c			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c18c			 
c18c					; TODO does not copy from stack 
c18c					if DEBUG_FORTH_WORDS_KEY 
c18c						DMARK "EDT" 
c18c f5				push af  
c18d 3a a1 c1			ld a, (.dmark)  
c190 32 c0 ee			ld (debug_mark),a  
c193 3a a2 c1			ld a, (.dmark+1)  
c196 32 c1 ee			ld (debug_mark+1),a  
c199 3a a3 c1			ld a, (.dmark+2)  
c19c 32 c2 ee			ld (debug_mark+2),a  
c19f 18 03			jr .pastdmark  
c1a1 ..			.dmark: db "EDT"  
c1a4 f1			.pastdmark: pop af  
c1a5			endm  
# End of macro DMARK
c1a5						CALLMONITOR 
c1a5 cd 2e 93			call break_point_state  
c1a8				endm  
# End of macro CALLMONITOR
c1a8					endif 
c1a8			 
c1a8					;FORTH_DSP 
c1a8					FORTH_DSP_VALUEHL 
c1a8 cd b2 9a			call macro_dsp_valuehl 
c1ab				endm 
# End of macro FORTH_DSP_VALUEHL
c1ab			;		inc hl    ; TODO do type check 
c1ab			 
c1ab			;		call get_word_hl 
c1ab e5					push hl 
c1ac					if DEBUG_FORTH_WORDS 
c1ac						DMARK "EDp" 
c1ac f5				push af  
c1ad 3a c1 c1			ld a, (.dmark)  
c1b0 32 c0 ee			ld (debug_mark),a  
c1b3 3a c2 c1			ld a, (.dmark+1)  
c1b6 32 c1 ee			ld (debug_mark+1),a  
c1b9 3a c3 c1			ld a, (.dmark+2)  
c1bc 32 c2 ee			ld (debug_mark+2),a  
c1bf 18 03			jr .pastdmark  
c1c1 ..			.dmark: db "EDp"  
c1c4 f1			.pastdmark: pop af  
c1c5			endm  
# End of macro DMARK
c1c5						CALLMONITOR 
c1c5 cd 2e 93			call break_point_state  
c1c8				endm  
# End of macro CALLMONITOR
c1c8					endif 
c1c8				;	ld a, 0 
c1c8 cd 19 8f				call strlenz 
c1cb 23					inc hl 
c1cc			 
c1cc 06 00				ld b, 0 
c1ce 4d					ld c, l 
c1cf			 
c1cf e1					pop hl 
c1d0 11 e4 e6				ld de, os_input 
c1d3					if DEBUG_FORTH_WORDS_KEY 
c1d3						DMARK "EDc" 
c1d3 f5				push af  
c1d4 3a e8 c1			ld a, (.dmark)  
c1d7 32 c0 ee			ld (debug_mark),a  
c1da 3a e9 c1			ld a, (.dmark+1)  
c1dd 32 c1 ee			ld (debug_mark+1),a  
c1e0 3a ea c1			ld a, (.dmark+2)  
c1e3 32 c2 ee			ld (debug_mark+2),a  
c1e6 18 03			jr .pastdmark  
c1e8 ..			.dmark: db "EDc"  
c1eb f1			.pastdmark: pop af  
c1ec			endm  
# End of macro DMARK
c1ec						CALLMONITOR 
c1ec cd 2e 93			call break_point_state  
c1ef				endm  
# End of macro CALLMONITOR
c1ef					endif 
c1ef ed b0				ldir 
c1f1			 
c1f1			 
c1f1 21 e4 e6				ld hl, os_input 
c1f4					;ld a, 0 
c1f4					;ld (hl),a 
c1f4 3a cf ec				ld a,(f_cursor_ptr) 
c1f7 16 64				ld d, 100 
c1f9 0e 00				ld c, 0 
c1fb 1e 28				ld e, 40 
c1fd cd e8 8a				call input_str 
c200					; TODO perhaps do a type check and wrap in quotes if not a number 
c200 21 e4 e6				ld hl, os_input 
c203					if DEBUG_FORTH_WORDS 
c203						DMARK "ED1" 
c203 f5				push af  
c204 3a 18 c2			ld a, (.dmark)  
c207 32 c0 ee			ld (debug_mark),a  
c20a 3a 19 c2			ld a, (.dmark+1)  
c20d 32 c1 ee			ld (debug_mark+1),a  
c210 3a 1a c2			ld a, (.dmark+2)  
c213 32 c2 ee			ld (debug_mark+2),a  
c216 18 03			jr .pastdmark  
c218 ..			.dmark: db "ED1"  
c21b f1			.pastdmark: pop af  
c21c			endm  
# End of macro DMARK
c21c						CALLMONITOR 
c21c cd 2e 93			call break_point_state  
c21f				endm  
# End of macro CALLMONITOR
c21f					endif 
c21f cd 29 99				call forth_push_str 
c222					NEXTW 
c222 c3 24 9c			jp macro_next 
c225				endm 
# End of macro NEXTW
c225			 
c225			 
c225			 
c225			.ENDKEY: 
c225			; eof 
c225			 
# End of file forth_words_key.asm
c225			 
c225			if STORAGE_SE 
c225			   	include "forth_words_storage.asm" 
c225			endif 
c225				include "forth_words_device.asm" 
c225			; Device related words 
c225			 
c225			; | ## Device Words 
c225			 
c225			if SOUND_ENABLE 
c225			.NOTE: 
c225				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c225			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c225					if DEBUG_FORTH_WORDS_KEY 
c225						DMARK "NTE" 
c225						CALLMONITOR 
c225					endif 
c225			 
c225				 
c225			 
c225					NEXTW 
c225			.AFTERSOUND: 
c225			endif 
c225			 
c225			 
c225			USE_GPIO: equ 0 
c225			 
c225			if USE_GPIO 
c225			.GP1: 
c225				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c225			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c225					NEXTW 
c225			.GP2: 
c225				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c225			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c225			 
c225					NEXTW 
c225			 
c225			.GP3: 
c225				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c225			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c225			 
c225					NEXTW 
c225			 
c225			.GP4: 
c225				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c225			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c225			 
c225					NEXTW 
c225			.SIN: 
c225			 
c225			 
c225			endif 
c225			 
c225			 
c225				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c225 33				db WORD_SYS_CORE+31             
c226 5a c2			dw .SOUT            
c228 03				db 2 + 1 
c229 .. 00			db "IN",0              
c22c				endm 
# End of macro CWHEAD
c22c			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c22c					if DEBUG_FORTH_WORDS_KEY 
c22c						DMARK "IN." 
c22c f5				push af  
c22d 3a 41 c2			ld a, (.dmark)  
c230 32 c0 ee			ld (debug_mark),a  
c233 3a 42 c2			ld a, (.dmark+1)  
c236 32 c1 ee			ld (debug_mark+1),a  
c239 3a 43 c2			ld a, (.dmark+2)  
c23c 32 c2 ee			ld (debug_mark+2),a  
c23f 18 03			jr .pastdmark  
c241 ..			.dmark: db "IN."  
c244 f1			.pastdmark: pop af  
c245			endm  
# End of macro DMARK
c245						CALLMONITOR 
c245 cd 2e 93			call break_point_state  
c248				endm  
# End of macro CALLMONITOR
c248					endif 
c248					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c248 cd b2 9a			call macro_dsp_valuehl 
c24b				endm 
# End of macro FORTH_DSP_VALUEHL
c24b			 
c24b e5					push hl 
c24c			 
c24c					; destroy value TOS 
c24c			 
c24c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c24c cd 6a 9b			call macro_forth_dsp_pop 
c24f				endm 
# End of macro FORTH_DSP_POP
c24f			 
c24f					; one value on hl get other one back 
c24f			 
c24f c1					pop bc 
c250			 
c250					; do the sub 
c250			;		ex de, hl 
c250			 
c250 ed 68				in l,(c) 
c252			 
c252					; save it 
c252			 
c252 26 00				ld h,0 
c254			 
c254					; TODO push value back onto stack for another op etc 
c254			 
c254 cd bb 98				call forth_push_numhl 
c257					NEXTW 
c257 c3 24 9c			jp macro_next 
c25a				endm 
# End of macro NEXTW
c25a			.SOUT: 
c25a				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c25a 34				db WORD_SYS_CORE+32             
c25b ad c2			dw .SPIO            
c25d 04				db 3 + 1 
c25e .. 00			db "OUT",0              
c262				endm 
# End of macro CWHEAD
c262			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c262					if DEBUG_FORTH_WORDS_KEY 
c262						DMARK "OUT" 
c262 f5				push af  
c263 3a 77 c2			ld a, (.dmark)  
c266 32 c0 ee			ld (debug_mark),a  
c269 3a 78 c2			ld a, (.dmark+1)  
c26c 32 c1 ee			ld (debug_mark+1),a  
c26f 3a 79 c2			ld a, (.dmark+2)  
c272 32 c2 ee			ld (debug_mark+2),a  
c275 18 03			jr .pastdmark  
c277 ..			.dmark: db "OUT"  
c27a f1			.pastdmark: pop af  
c27b			endm  
# End of macro DMARK
c27b						CALLMONITOR 
c27b cd 2e 93			call break_point_state  
c27e				endm  
# End of macro CALLMONITOR
c27e					endif 
c27e			 
c27e					; get port 
c27e			 
c27e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c27e cd b2 9a			call macro_dsp_valuehl 
c281				endm 
# End of macro FORTH_DSP_VALUEHL
c281			 
c281 e5					push hl 
c282			 
c282					; destroy value TOS 
c282			 
c282					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c282 cd 6a 9b			call macro_forth_dsp_pop 
c285				endm 
# End of macro FORTH_DSP_POP
c285			 
c285					; get byte to send 
c285			 
c285					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c285 cd b2 9a			call macro_dsp_valuehl 
c288				endm 
# End of macro FORTH_DSP_VALUEHL
c288			 
c288			;		push hl 
c288			 
c288					; destroy value TOS 
c288			 
c288					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c288 cd 6a 9b			call macro_forth_dsp_pop 
c28b				endm 
# End of macro FORTH_DSP_POP
c28b			 
c28b					; one value on hl get other one back 
c28b			 
c28b			;		pop hl 
c28b			 
c28b c1					pop bc 
c28c			 
c28c					if DEBUG_FORTH_WORDS 
c28c						DMARK "OUT" 
c28c f5				push af  
c28d 3a a1 c2			ld a, (.dmark)  
c290 32 c0 ee			ld (debug_mark),a  
c293 3a a2 c2			ld a, (.dmark+1)  
c296 32 c1 ee			ld (debug_mark+1),a  
c299 3a a3 c2			ld a, (.dmark+2)  
c29c 32 c2 ee			ld (debug_mark+2),a  
c29f 18 03			jr .pastdmark  
c2a1 ..			.dmark: db "OUT"  
c2a4 f1			.pastdmark: pop af  
c2a5			endm  
# End of macro DMARK
c2a5						CALLMONITOR 
c2a5 cd 2e 93			call break_point_state  
c2a8				endm  
# End of macro CALLMONITOR
c2a8					endif 
c2a8			 
c2a8 ed 69				out (c), l 
c2aa			 
c2aa					NEXTW 
c2aa c3 24 9c			jp macro_next 
c2ad				endm 
# End of macro NEXTW
c2ad			 
c2ad			 
c2ad			.SPIO: 
c2ad			 
c2ad			if STORAGE_SE 
c2ad				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c2ad			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c2ad			 
c2ad					call spi_ce_low 
c2ad			    NEXTW 
c2ad			 
c2ad			.SPICEH: 
c2ad				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c2ad			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c2ad			 
c2ad					call spi_ce_high 
c2ad			    NEXTW 
c2ad			 
c2ad			 
c2ad			.SPIOb: 
c2ad			 
c2ad				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c2ad			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c2ad			 
c2ad					; get port 
c2ad			 
c2ad			 
c2ad					; get byte to send 
c2ad			 
c2ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2ad			 
c2ad			;		push hl    ; u1  
c2ad			 
c2ad					; destroy value TOS 
c2ad			 
c2ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2ad			 
c2ad					; one value on hl get other one back 
c2ad			 
c2ad			;		pop hl   ; u2 - addr 
c2ad			 
c2ad					; TODO Send SPI byte 
c2ad			 
c2ad					ld a, l 
c2ad					call spi_send_byte 
c2ad			 
c2ad					NEXTW 
c2ad			 
c2ad			.SPII: 
c2ad				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c2ad			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c2ad			 
c2ad					; TODO Get SPI byte 
c2ad			 
c2ad					call spi_read_byte 
c2ad			 
c2ad					ld h, 0 
c2ad					ld l, a 
c2ad					call forth_push_numhl 
c2ad			 
c2ad					NEXTW 
c2ad			 
c2ad			 
c2ad			 
c2ad			.SESEL: 
c2ad				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c2ad			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c2ad					if DEBUG_FORTH_WORDS_KEY 
c2ad						DMARK "BNK" 
c2ad						CALLMONITOR 
c2ad					endif 
c2ad			 
c2ad					ld a, 255 
c2ad					ld (spi_cartdev), a 
c2ad			 
c2ad					; get bank 
c2ad			 
c2ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2ad			 
c2ad			;		push hl 
c2ad			 
c2ad					; destroy value TOS 
c2ad			 
c2ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2ad			 
c2ad					; one value on hl get other one back 
c2ad			 
c2ad			;		pop hl 
c2ad			 
c2ad			 
c2ad					ld c, SPI_CE_HIGH 
c2ad					ld b, '0'    ; human readable bank number 
c2ad			 
c2ad					ld a, l 
c2ad			 
c2ad					if DEBUG_FORTH_WORDS 
c2ad						DMARK "BNK" 
c2ad						CALLMONITOR 
c2ad					endif 
c2ad			 
c2ad					; active low 
c2ad			 
c2ad					cp 0 
c2ad					jr z, .bset 
c2ad					cp 1 
c2ad					jr nz, .b2 
c2ad					res 0, c 
c2ad					ld b, '1'    ; human readable bank number 
c2ad			.b2:		cp 2 
c2ad					jr nz, .b3 
c2ad					res 1, c 
c2ad					ld b, '2'    ; human readable bank number 
c2ad			.b3:		cp 3 
c2ad					jr nz, .b4 
c2ad					res 2, c 
c2ad					ld b, '3'    ; human readable bank number 
c2ad			.b4:		cp 4 
c2ad					jr nz, .b5 
c2ad					res 3, c 
c2ad					ld b, '4'    ; human readable bank number 
c2ad			.b5:		cp 5 
c2ad					jr nz, .bset 
c2ad					res 4, c 
c2ad					ld b, '5'    ; human readable bank number 
c2ad			 
c2ad			.bset: 
c2ad					ld a, c 
c2ad					ld (spi_device),a 
c2ad					ld a, b 
c2ad					ld (spi_device_id),a 
c2ad					if DEBUG_FORTH_WORDS 
c2ad						DMARK "BN2" 
c2ad						CALLMONITOR 
c2ad					endif 
c2ad			 
c2ad					NEXTW 
c2ad			 
c2ad			.CARTDEV: 
c2ad				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c2ad			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c2ad					if DEBUG_FORTH_WORDS_KEY 
c2ad						DMARK "CDV" 
c2ad						CALLMONITOR 
c2ad					endif 
c2ad			 
c2ad					; disable se storage bank selection 
c2ad			 
c2ad					ld a, SPI_CE_HIGH		; ce high 
c2ad					ld (spi_device), a 
c2ad			 
c2ad					; get bank 
c2ad			 
c2ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2ad			 
c2ad			;		push hl 
c2ad			 
c2ad					; destroy value TOS 
c2ad			 
c2ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2ad			 
c2ad					; one value on hl get other one back 
c2ad			 
c2ad			;		pop hl 
c2ad			 
c2ad					; active low 
c2ad			 
c2ad					ld c, 255 
c2ad			 
c2ad					ld a, l 
c2ad					if DEBUG_FORTH_WORDS 
c2ad						DMARK "CDV" 
c2ad						CALLMONITOR 
c2ad					endif 
c2ad					cp 0 
c2ad					jr z, .cset 
c2ad					cp 1 
c2ad					jr nz, .c2 
c2ad					res 0, c 
c2ad			.c2:		cp 2 
c2ad					jr nz, .c3 
c2ad					res 1, c 
c2ad			.c3:		cp 3 
c2ad					jr nz, .c4 
c2ad					res 2, c 
c2ad			.c4:		cp 4 
c2ad					jr nz, .c5 
c2ad					res 3, c 
c2ad			.c5:		cp 5 
c2ad					jr nz, .c6 
c2ad					res 4, c 
c2ad			.c6:		cp 6 
c2ad					jr nz, .c7 
c2ad					res 5, c 
c2ad			.c7:		cp 7 
c2ad					jr nz, .c8 
c2ad					res 6, c 
c2ad			.c8:		cp 8 
c2ad					jr nz, .cset 
c2ad					res 7, c 
c2ad			.cset:		ld a, c 
c2ad					ld (spi_cartdev),a 
c2ad			 
c2ad					if DEBUG_FORTH_WORDS 
c2ad						DMARK "CD2" 
c2ad						CALLMONITOR 
c2ad					endif 
c2ad					NEXTW 
c2ad			endif 
c2ad			 
c2ad			.ENDDEVICE: 
c2ad			; eof 
c2ad			 
# End of file forth_words_device.asm
c2ad			 
c2ad			; var handler 
c2ad			 
c2ad			 
c2ad			.VARS: 
c2ad				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c2ad 78				db WORD_SYS_CORE+100             
c2ae c5 c2			dw .V0Q            
c2b0 04				db 3 + 1 
c2b1 .. 00			db "V0!",0              
c2b5				endm 
# End of macro CWHEAD
c2b5			;| V0! ( u1 -- )  Store value to v0  | DONE 
c2b5			 
c2b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2b5 cd b2 9a			call macro_dsp_valuehl 
c2b8				endm 
# End of macro FORTH_DSP_VALUEHL
c2b8			 
c2b8 11 99 ec				ld de, cli_var_array 
c2bb			 
c2bb eb					ex de, hl 
c2bc 73					ld (hl), e 
c2bd 23					inc hl 
c2be 72					ld (hl), d 
c2bf			 
c2bf					; destroy value TOS 
c2bf			 
c2bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2bf cd 6a 9b			call macro_forth_dsp_pop 
c2c2				endm 
# End of macro FORTH_DSP_POP
c2c2			 
c2c2				       NEXTW 
c2c2 c3 24 9c			jp macro_next 
c2c5				endm 
# End of macro NEXTW
c2c5			.V0Q: 
c2c5				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c2c5 79				db WORD_SYS_CORE+101             
c2c6 d6 c2			dw .V1S            
c2c8 04				db 3 + 1 
c2c9 .. 00			db "V0@",0              
c2cd				endm 
# End of macro CWHEAD
c2cd			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c2cd 2a 99 ec				ld hl, (cli_var_array) 
c2d0 cd bb 98				call forth_push_numhl 
c2d3			 
c2d3				       NEXTW 
c2d3 c3 24 9c			jp macro_next 
c2d6				endm 
# End of macro NEXTW
c2d6			.V1S: 
c2d6				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c2d6 7a				db WORD_SYS_CORE+102             
c2d7 ee c2			dw .V1Q            
c2d9 04				db 3 + 1 
c2da .. 00			db "V1!",0              
c2de				endm 
# End of macro CWHEAD
c2de			;| V1! ( u1 -- )  Store value to v1 | DONE 
c2de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2de cd b2 9a			call macro_dsp_valuehl 
c2e1				endm 
# End of macro FORTH_DSP_VALUEHL
c2e1			 
c2e1 11 9b ec				ld de, cli_var_array+2 
c2e4				 
c2e4 eb					ex de, hl 
c2e5 73					ld (hl), e 
c2e6 23					inc hl 
c2e7 72					ld (hl), d 
c2e8			 
c2e8					; destroy value TOS 
c2e8			 
c2e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2e8 cd 6a 9b			call macro_forth_dsp_pop 
c2eb				endm 
# End of macro FORTH_DSP_POP
c2eb				       NEXTW 
c2eb c3 24 9c			jp macro_next 
c2ee				endm 
# End of macro NEXTW
c2ee			.V1Q: 
c2ee				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c2ee 7b				db WORD_SYS_CORE+103             
c2ef ff c2			dw .V2S            
c2f1 04				db 3 + 1 
c2f2 .. 00			db "V1@",0              
c2f6				endm 
# End of macro CWHEAD
c2f6			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c2f6 2a 9b ec				ld hl, (cli_var_array+2) 
c2f9 cd bb 98				call forth_push_numhl 
c2fc				       NEXTW 
c2fc c3 24 9c			jp macro_next 
c2ff				endm 
# End of macro NEXTW
c2ff			.V2S: 
c2ff				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c2ff 7c				db WORD_SYS_CORE+104             
c300 17 c3			dw .V2Q            
c302 04				db 3 + 1 
c303 .. 00			db "V2!",0              
c307				endm 
# End of macro CWHEAD
c307			;| V2! ( u1 -- )  Store value to v2 | DONE 
c307					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c307 cd b2 9a			call macro_dsp_valuehl 
c30a				endm 
# End of macro FORTH_DSP_VALUEHL
c30a			 
c30a 11 9d ec				ld de, cli_var_array+4 
c30d				 
c30d eb					ex de, hl 
c30e 73					ld (hl), e 
c30f 23					inc hl 
c310 72					ld (hl), d 
c311			 
c311					; destroy value TOS 
c311			 
c311					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c311 cd 6a 9b			call macro_forth_dsp_pop 
c314				endm 
# End of macro FORTH_DSP_POP
c314				       NEXTW 
c314 c3 24 9c			jp macro_next 
c317				endm 
# End of macro NEXTW
c317			.V2Q: 
c317				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c317 7d				db WORD_SYS_CORE+105             
c318 28 c3			dw .V3S            
c31a 04				db 3 + 1 
c31b .. 00			db "V2@",0              
c31f				endm 
# End of macro CWHEAD
c31f			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c31f 2a 9d ec				ld hl, (cli_var_array+4) 
c322 cd bb 98				call forth_push_numhl 
c325				       NEXTW 
c325 c3 24 9c			jp macro_next 
c328				endm 
# End of macro NEXTW
c328			.V3S: 
c328				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c328 7c				db WORD_SYS_CORE+104             
c329 40 c3			dw .V3Q            
c32b 04				db 3 + 1 
c32c .. 00			db "V3!",0              
c330				endm 
# End of macro CWHEAD
c330			;| V3! ( u1 -- )  Store value to v3 | DONE 
c330					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c330 cd b2 9a			call macro_dsp_valuehl 
c333				endm 
# End of macro FORTH_DSP_VALUEHL
c333			 
c333 11 9f ec				ld de, cli_var_array+6 
c336				 
c336 eb					ex de, hl 
c337 73					ld (hl), e 
c338 23					inc hl 
c339 72					ld (hl), d 
c33a			 
c33a					; destroy value TOS 
c33a			 
c33a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c33a cd 6a 9b			call macro_forth_dsp_pop 
c33d				endm 
# End of macro FORTH_DSP_POP
c33d				       NEXTW 
c33d c3 24 9c			jp macro_next 
c340				endm 
# End of macro NEXTW
c340			.V3Q: 
c340				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c340 7d				db WORD_SYS_CORE+105             
c341 51 c3			dw .END            
c343 04				db 3 + 1 
c344 .. 00			db "V3@",0              
c348				endm 
# End of macro CWHEAD
c348			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c348 2a 9f ec				ld hl, (cli_var_array+6) 
c34b cd bb 98				call forth_push_numhl 
c34e				       NEXTW 
c34e c3 24 9c			jp macro_next 
c351				endm 
# End of macro NEXTW
c351			 
c351			 
c351			 
c351			 
c351			 
c351			; end of dict marker 
c351			 
c351 00			.END:    db WORD_SYS_END 
c352 00 00			dw 0 
c354 00				db 0 
c355			 
c355			; use to jp here for user dict words to save on macro expansion  
c355			 
c355			user_dict_next: 
c355				NEXTW 
c355 c3 24 9c			jp macro_next 
c358				endm 
# End of macro NEXTW
c358			 
c358			 
c358			user_exec: 
c358				;    ld hl, <word code> 
c358				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c358				;    call forthexec 
c358				;    jp user_dict_next   (NEXT) 
c358			        ;    <word code bytes> 
c358 eb				ex de, hl 
c359 2a e7 e7			ld hl,(os_tok_ptr) 
c35c				 
c35c				FORTH_RSP_NEXT 
c35c cd 62 98			call macro_forth_rsp_next 
c35f				endm 
# End of macro FORTH_RSP_NEXT
c35f			 
c35f			if DEBUG_FORTH_UWORD 
c35f						DMARK "UEX" 
c35f f5				push af  
c360 3a 74 c3			ld a, (.dmark)  
c363 32 c0 ee			ld (debug_mark),a  
c366 3a 75 c3			ld a, (.dmark+1)  
c369 32 c1 ee			ld (debug_mark+1),a  
c36c 3a 76 c3			ld a, (.dmark+2)  
c36f 32 c2 ee			ld (debug_mark+2),a  
c372 18 03			jr .pastdmark  
c374 ..			.dmark: db "UEX"  
c377 f1			.pastdmark: pop af  
c378			endm  
# End of macro DMARK
c378				CALLMONITOR 
c378 cd 2e 93			call break_point_state  
c37b				endm  
# End of macro CALLMONITOR
c37b			endif 
c37b			 
c37b			 
c37b			 
c37b eb				ex de, hl 
c37c 22 e7 e7			ld (os_tok_ptr), hl 
c37f				 
c37f				; Don't use next - Skips the first word in uword. 
c37f			 
c37f c3 b5 9c			jp exec1 
c382			;	NEXT 
c382			 
c382			 
c382			; eof 
# End of file forth_wordsv4.asm
c382			endif 
c382			;;;;;;;;;;;;;; Debug code 
c382			 
c382			 
c382			;if DEBUG_FORTH_PARSE 
c382 .. 00		.nowordfound: db "No match",0 
c38b .. 00		.compword:	db "Comparing word ",0 
c39b .. 00		.nextwordat:	db "Next word at",0 
c3a8 .. 00		.charmatch:	db "Char match",0 
c3b3			;endif 
c3b3			if DEBUG_FORTH_JP 
c3b3			.foundword:	db "Word match. Exec..",0 
c3b3			endif 
c3b3			;if DEBUG_FORTH_PUSH 
c3b3 .. 00		.enddict:	db "Dict end. Push.",0 
c3c3 .. 00		.push_str:	db "Pushing string",0 
c3d2 .. 00		.push_num:	db "Pushing number",0 
c3e1 .. 00		.data_sp:	db "SP:",0 
c3e5 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c3f7 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c409 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c41b			;endif 
c41b			;if DEBUG_FORTH_MALLOC 
c41b .. 00		.push_malloc:	db "Malloc address",0 
c42a			;endif 
c42a			 
c42a			 
c42a			 
c42a			; display malloc address and current data stack pointer  
c42a			 
c42a			malloc_error: 
c42a d5				push de 
c42b f5				push af 
c42c e5				push hl 
c42d cd 8e 88			call clear_display 
c430 11 52 c4			ld de, .mallocerr 
c433 3e 00			ld a,0 
c435			;	ld de,os_word_scratch 
c435 cd a1 88			call str_at_display 
c438 3e 11			ld a, display_row_1+17 
c43a 11 c0 ee			ld de, debug_mark 
c43d cd a1 88			call str_at_display 
c440 cd b1 88			call update_display 
c443				;call break_point_state 
c443 cd 60 d7			call cin_wait 
c446			 
c446 3e 20			ld a, ' ' 
c448 32 d7 e4			ld (os_view_disable), a 
c44b e1				pop hl 
c44c f1				pop af 
c44d d1				pop de	 
c44e				CALLMONITOR 
c44e cd 2e 93			call break_point_state  
c451				endm  
# End of macro CALLMONITOR
c451 c9				ret 
c452			 
c452 .. 00		.mallocerr: 	db "Malloc Error",0 
c45f			;if DEBUG_FORTH_PUSH 
c45f			display_data_sp: 
c45f f5				push af 
c460			 
c460				; see if disabled 
c460			 
c460 3a d7 e4			ld a, (os_view_disable) 
c463 fe 2a			cp '*' 
c465 28 67			jr z, .skipdsp 
c467			 
c467 e5				push hl 
c468 e5				push hl 
c469 e5			push hl 
c46a cd 8e 88			call clear_display 
c46d e1			pop hl 
c46e 7c				ld a,h 
c46f 21 eb e7			ld hl, os_word_scratch 
c472 cd bc 8d			call hexout 
c475 e1				pop hl 
c476 7d				ld a,l 
c477 21 ed e7			ld hl, os_word_scratch+2 
c47a cd bc 8d			call hexout 
c47d 21 ef e7			ld hl, os_word_scratch+4 
c480 3e 00			ld a,0 
c482 77				ld (hl),a 
c483 11 eb e7			ld de,os_word_scratch 
c486 3e 14				ld a, display_row_2 
c488 cd a1 88				call str_at_display 
c48b 11 e5 c3			ld de, .wordinhl 
c48e 3e 00			ld a, display_row_1 
c490			 
c490 cd a1 88				call str_at_display 
c493 11 c0 ee			ld de, debug_mark 
c496 3e 11			ld a, display_row_1+17 
c498			 
c498 cd a1 88				call str_at_display 
c49b			 
c49b				; display current data stack pointer 
c49b 11 e1 c3			ld de,.data_sp 
c49e 3e 1c				ld a, display_row_2 + 8 
c4a0 cd a1 88				call str_at_display 
c4a3			 
c4a3 2a 93 ec			ld hl,(cli_data_sp) 
c4a6 e5				push hl 
c4a7 7c				ld a,h 
c4a8 21 eb e7			ld hl, os_word_scratch 
c4ab cd bc 8d			call hexout 
c4ae e1				pop hl 
c4af 7d				ld a,l 
c4b0 21 ed e7			ld hl, os_word_scratch+2 
c4b3 cd bc 8d			call hexout 
c4b6 21 ef e7			ld hl, os_word_scratch+4 
c4b9 3e 00			ld a,0 
c4bb 77				ld (hl),a 
c4bc 11 eb e7			ld de,os_word_scratch 
c4bf 3e 1f				ld a, display_row_2 + 11 
c4c1 cd a1 88				call str_at_display 
c4c4			 
c4c4			 
c4c4 cd b1 88			call update_display 
c4c7 cd 0e 88			call delay1s 
c4ca cd 0e 88			call delay1s 
c4cd e1				pop hl 
c4ce			.skipdsp: 
c4ce f1				pop af 
c4cf c9				ret 
c4d0			 
c4d0			display_data_malloc: 
c4d0			 
c4d0 f5				push af 
c4d1 e5				push hl 
c4d2 e5				push hl 
c4d3 e5			push hl 
c4d4 cd 8e 88			call clear_display 
c4d7 e1			pop hl 
c4d8 7c				ld a,h 
c4d9 21 eb e7			ld hl, os_word_scratch 
c4dc cd bc 8d			call hexout 
c4df e1				pop hl 
c4e0 7d				ld a,l 
c4e1 21 ed e7			ld hl, os_word_scratch+2 
c4e4 cd bc 8d			call hexout 
c4e7 21 ef e7			ld hl, os_word_scratch+4 
c4ea 3e 00			ld a,0 
c4ec 77				ld (hl),a 
c4ed 11 eb e7			ld de,os_word_scratch 
c4f0 3e 14				ld a, display_row_2 
c4f2 cd a1 88				call str_at_display 
c4f5 11 1b c4			ld de, .push_malloc 
c4f8 3e 00			ld a, display_row_1 
c4fa			 
c4fa cd a1 88				call str_at_display 
c4fd			 
c4fd				; display current data stack pointer 
c4fd 11 e1 c3			ld de,.data_sp 
c500 3e 1c				ld a, display_row_2 + 8 
c502 cd a1 88				call str_at_display 
c505			 
c505 2a 93 ec			ld hl,(cli_data_sp) 
c508 e5				push hl 
c509 7c				ld a,h 
c50a 21 eb e7			ld hl, os_word_scratch 
c50d cd bc 8d			call hexout 
c510 e1				pop hl 
c511 7d				ld a,l 
c512 21 ed e7			ld hl, os_word_scratch+2 
c515 cd bc 8d			call hexout 
c518 21 ef e7			ld hl, os_word_scratch+4 
c51b 3e 00			ld a,0 
c51d 77				ld (hl),a 
c51e 11 eb e7			ld de,os_word_scratch 
c521 3e 1f				ld a, display_row_2 + 11 
c523 cd a1 88				call str_at_display 
c526			 
c526 cd b1 88			call update_display 
c529 cd 0e 88			call delay1s 
c52c cd 0e 88			call delay1s 
c52f e1				pop hl 
c530 f1				pop af 
c531 c9				ret 
c532			;endif 
c532			 
c532			include "forth_autostart.asm" 
c532			; list of commands to perform at system start up 
c532			 
c532			startcmds: 
c532			;	dw test11 
c532			;	dw test12 
c532			;	dw test13 
c532			;	dw test14 
c532			;	dw test15 
c532			;	dw test16 
c532			;	dw test17 
c532			;	dw ifthtest1 
c532			;	dw ifthtest2 
c532			;	dw ifthtest3 
c532			;	dw mmtest1 
c532			;	dw mmtest2 
c532			;	dw mmtest3 
c532			;	dw mmtest4 
c532			;	dw mmtest5 
c532			;	dw mmtest6 
c532			;	dw iftest1 
c532			;	dw iftest2 
c532			;	dw iftest3 
c532			;	dw looptest1 
c532			;	dw looptest2 
c532			;	dw test1 
c532			;	dw test2 
c532			;	dw test3 
c532			;	dw test4 
c532			;	dw game2r 
c532			;	dw game2b1 
c532			;	dw game2b2 
c532			 
c532				; start up words that are actually useful 
c532			 
c532 90 c5			dw clrstack 
c534 c3 c5			dw type 
c536 84 c7			dw stest 
c538 e7 c5			dw strncpy 
c53a 25 c7			dw list 
c53c 48 c6			dw start1 
c53e 5a c6			dw start2 
c540			;	dw start3 
c540 6d c6			dw start3b 
c542 c5 c6			dw start3c 
c544			 
c544				; (unit) testing words 
c544			 
c544 fb c7			dw mtesta 
c546 b0 c8			dw mtestb 
c548 53 c9			dw mtestc 
c54a 08 ca			dw mtestd 
c54c ac ca			dw mteste 
c54e			 
c54e				; demo/game words 
c54e			 
c54e b8 d1		        dw game3w 
c550 e6 d1		        dw game3p 
c552 04 d2		        dw game3sc 
c554 35 d2		        dw game3vsi 
c556 61 d2		        dw game3vs 
c558				 
c558 ab cf			dw game2b 
c55a 19 d0			dw game2bf 
c55c 63 d0			dw game2mba 
c55e f9 d0			dw game2mbas 
c560 3b d1			dw game2mb 
c562			 
c562 6c cc			dw game1 
c564 7d cc			dw game1a 
c566 df cc			dw game1b 
c568 14 cd			dw game1c 
c56a 4a cd			dw game1d 
c56c 7b cd			dw game1s 
c56e 8f cd			dw game1t 
c570 a4 cd			dw game1f 
c572 d8 cd			dw game1z 
c574 1c ce			dw game1zz 
c576			 
c576 62 cb			dw test5 
c578 9a cb			dw test6 
c57a d2 cb			dw test7 
c57c e6 cb			dw test8 
c57e 12 cc			dw test9 
c580 28 cc			dw test10 
c582				 
c582 f3 ce		        dw ssv5 
c584 d7 ce		        dw ssv4 
c586 bb ce		        dw ssv3 
c588 85 ce		        dw ssv2 
c58a 0c cf		        dw ssv1 
c58c 54 cf		        dw ssv1cpm 
c58e			;	dw keyup 
c58e			;	dw keydown 
c58e			;	dw keyleft 
c58e			;	dw keyright 
c58e			;	dw 	keyf1 
c58e			;	dw keyf2 
c58e			;	dw keyf3 
c58e			;	dw keyf4 
c58e			;	dw keyf5 
c58e			;	dw keyf6 
c58e			;	dw keyf7 
c58e			;	dw keyf8 
c58e			;	dw keyf9 
c58e			;	dw keyf10 
c58e			;	dw keyf11 
c58e			;	dw keyf12 
c58e			;	dw keytab 
c58e			;	dw keycr 
c58e			;	dw keyhome 
c58e			;	dw keyend 
c58e			;	dw keybs 
c58e 00 00			db 0, 0	 
c590			 
c590			 
c590			; clear stack  
c590			 
c590 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c5c3			 
c5c3			; type ( addr count - ) 
c5c3 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c5e7			 
c5e7			; some direct memory words 
c5e7			; strncpy ( len t f -- t ) 
c5e7			 
c5e7 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c648			 
c648 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c65a .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c66d			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c66d .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c6c5 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c725			 
c725			 
c725			; a handy word to list items on the stack 
c725			 
c725 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c784			 
c784			 
c784			; test stack  
c784			; rnd8 stest 
c784			 
c784 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c7fb			 
c7fb			; random malloc and free cycles 
c7fb			 
c7fb .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c8b0			 
c8b0			; fixed malloc and free cycles 
c8b0			 
c8b0 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c953			 
c953			; fixed double string push and drop cycle  
c953			 
c953 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
ca08			 
ca08			; consistent fixed string push and drop cycle  
ca08			 
ca08 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
caac			 
caac .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cb62			 
cb62			;test1:		db ": aa 1 2 3 ;", 0 
cb62			;test2:     	db "111 aa 888 999",0 
cb62			;test3:     	db ": bb 77 ;",0 
cb62			;test4:     	db "$02 $01 do i . loop bb",0 
cb62			 
cb62 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cb9a .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cbd2 .. 00		test7:     	db ": box hline vline ;",0 
cbe6 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cc12 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cc28 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cc4d .. 00		test11:     	db "hello create .",0 
cc5c .. 00		test12:     	db "hello2 create .",0 
cc6c			 
cc6c			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cc6c			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cc6c			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cc6c			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cc6c			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cc6c			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cc6c			 
cc6c			;iftest1:     	db "$0001 IF cls .",0 
cc6c			;iftest2:     	db "$0000 IF cls .",0 
cc6c			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cc6c			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cc6c			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cc6c			 
cc6c			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc6c			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc6c			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc6c			 
cc6c			 
cc6c			 
cc6c			; a small guess the number game 
cc6c			 
cc6c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cc7d .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
ccdf			 
ccdf .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
cd14 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
cd4a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
cd7b .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cd8f .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
cda4 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
cdd8 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
ce1c			 
ce1c			; Using 'ga' save a high score across multiple runs using external storage 
ce1c			 
ce1c .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
ce85			 
ce85			 
ce85			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
ce85			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
ce85			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
ce85			 
ce85			; simple screen saver to test code memory reuse to destruction 
ce85			 
ce85 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
cebb .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
ced7 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
cef3 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
cf0c .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
cf54 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
cfab			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
cfab			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
cfab			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
cfab			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
cfab			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
cfab			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
cfab			 
cfab			 
cfab			 
cfab			; minesweeper/battleship finding game 
cfab			; draws a game board of random ship/mine positions 
cfab			; user enters coords to see if it hits on 
cfab			; game ends when all are hit 
cfab			; when hit or miss says how many may be in the area 
cfab			 
cfab			; setup the game board and then hide it 
cfab .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d019 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d063			; prompt for where to target 
d063 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d0f9 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d11e			; TODO see if the entered coords hits or misses pushes char hit of miss 
d11e .. 00		game2mbht:      db ": mbckht nop ;",0 
d12d .. 00		game2mbms:      db ": mbcms nop ;",0 
d13b			; TODO how many might be near by 
d13b .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d1b8			 
d1b8			; Game 3 
d1b8			 
d1b8			; Vert scroller ski game - avoid the trees! 
d1b8			 
d1b8			; v0 score (ie turns) 
d1b8			; v1 player pos 
d1b8			; v2 left wall 
d1b8			; v3 right wall 
d1b8			 
d1b8			; Draw side walls randomly 
d1b8			 
d1b8 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d1e6			 
d1e6			; Draw player 
d1e6 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d204			 
d204			; TODO Get Key 
d204			 
d204			; TODO Move left right 
d204			 
d204			; scroll and move walls a bit 
d204			 
d204 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d235			 
d235			; main game loop 
d235			 
d235 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d261 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d2a0			 
d2a0			; key board defs 
d2a0			 
d2a0 .. 00		keyup:       db ": keyup $05 ;",0 
d2ae .. 00		keydown:       db ": keydown $0a ;",0 
d2be .. 00		keyleft:       db ": keyleft $0b ;",0 
d2ce .. 00		keyright:       db ": keyright $0c ;",0 
d2df .. 00		keyf1:       db ": keyf1 $10 ;",0 
d2ed .. 00		keyf2:       db ": keyf2 $11 ;",0 
d2fb .. 00		keyf3:       db ": keyf3 $12 ;",0 
d309 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d317 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d325 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d333 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d341 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d34f .. 00		keyf9:       db ": keyf9 $18 ;",0 
d35d .. 00		keyf10:       db ": keyf10 $19 ;",0 
d36c .. 00		keyf11:       db ": keyf11 $1a ;",0 
d37b .. 00		keyf12:       db ": keyf12 $1b ;",0 
d38a			 
d38a .. 00		keytab:       db ": keytab $09 ;",0 
d399 .. 00		keycr:       db ": keycr $0d ;",0 
d3a7 .. 00		keyhome:       db ": keyhome $0e ;",0 
d3b7 .. 00		keyend:       db ": keyend $0f ;",0 
d3c6 .. 00		keybs:       db ": keybs $08 ;",0 
d3d4			 
d3d4			   
d3d4			 
d3d4			 
d3d4			 
d3d4			; eof 
# End of file forth_autostart.asm
d3d4			 
d3d4 .. 00		sprompt1: db "Startup load...",0 
d3e4 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d3fa			 
d3fa			 
d3fa			 
d3fa			 
d3fa			forth_startup: 
d3fa 21 32 c5			ld hl, startcmds 
d3fd 3e 00			ld a, 0 
d3ff 32 0c e9			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d402			 
d402 e5			.start1:	push hl 
d403 cd 8e 88			call clear_display 
d406 11 d4 d3			ld de, sprompt1 
d409 3e 00		        ld a, display_row_1 
d40b cd a1 88			call str_at_display 
d40e 11 e4 d3			ld de, sprompt2 
d411 3e 14		        ld a, display_row_2 
d413 cd a1 88			call str_at_display 
d416 e1				pop hl 
d417 e5				push hl 
d418 5e				ld e,(hl) 
d419 23				inc hl 
d41a 56				ld d,(hl) 
d41b 3e 28		        ld a, display_row_3 
d41d cd a1 88			call str_at_display 
d420 cd b1 88			call update_display 
d423			 
d423			 
d423 3a 0c e9			ld a, (os_last_cmd) 
d426 fe 00			cp 0 
d428 28 05			jr z, .startprompt 
d42a cd 02 88			call delay250ms 
d42d 18 24			jr .startdo 
d42f				 
d42f				 
d42f			 
d42f			.startprompt: 
d42f			 
d42f 3e 4f			ld a,display_row_4 + display_cols - 1 
d431 11 31 98		        ld de, endprg 
d434 cd a1 88			call str_at_display 
d437 cd b1 88			call update_display 
d43a cd 0e 88			call delay1s 
d43d cd 60 d7			call cin_wait 
d440						 
d440 fe 2a			cp '*' 
d442 28 5e			jr z, .startupend1 
d444 fe 23			cp '#' 
d446 20 07			jr nz, .startno 
d448 3e 01			ld a, 1 
d44a 32 0c e9			ld (os_last_cmd),a 
d44d 18 04			jr .startdo 
d44f fe 31		.startno:	cp '1' 
d451 28 3a			jr z,.startnxt  
d453			 
d453				; exec startup line 
d453			.startdo:	 
d453 e1				pop hl 
d454 e5				push hl 
d455				 
d455 5e				ld e,(hl) 
d456 23				inc hl 
d457 56				ld d,(hl) 
d458 eb				ex de,hl 
d459			 
d459 e5				push hl 
d45a			 
d45a 3e 00			ld a, 0 
d45c				;ld a, FORTH_END_BUFFER 
d45c cd 24 8f			call strlent 
d45f 23				inc hl   ; include zero term to copy 
d460 06 00			ld b,0 
d462 4d				ld c,l 
d463 e1				pop hl 
d464 11 e6 e4			ld de, scratch 
d467 ed b0			ldir 
d469			 
d469			 
d469 21 e6 e4			ld hl, scratch 
d46c cd 72 9c			call forthparse 
d46f cd b2 9c			call forthexec 
d472 cd c9 9b			call forthexec_cleanup 
d475			 
d475 3e 3c			ld a, display_row_4 
d477 11 d5 95			ld de, endprog 
d47a			 
d47a cd b1 88			call update_display		 
d47d			 
d47d 3a 0c e9			ld a, (os_last_cmd) 
d480 fe 00			cp 0 
d482 20 09			jr nz, .startnxt 
d484 cd 33 98			call next_page_prompt 
d487 cd 8e 88		        call clear_display 
d48a cd b1 88			call update_display		 
d48d			 
d48d				; move onto next startup line? 
d48d			.startnxt: 
d48d			 
d48d cd 02 88			call delay250ms 
d490 e1				pop hl 
d491			 
d491 23				inc hl 
d492 23				inc hl 
d493			 
d493 e5				push hl 
d494 5e				ld e, (hl) 
d495 23				inc hl 
d496 56				ld d, (hl) 
d497 e1				pop hl 
d498				; TODO replace 0 test 
d498			 
d498 eb				ex de, hl 
d499 cd e4 8a			call ishlzero 
d49c			;	ld a,e 
d49c			;	add d 
d49c			;	cp 0    ; any left to do? 
d49c eb				ex de, hl 
d49d c2 02 d4			jp nz, .start1 
d4a0 18 01			jr .startupend 
d4a2			 
d4a2 e1			.startupend1: pop hl 
d4a3			.startupend: 
d4a3			 
d4a3 cd 8e 88			call clear_display 
d4a6 cd b1 88			call update_display 
d4a9 c9				ret 
d4aa			 
d4aa			 
d4aa			; stack over and underflow checks 
d4aa			 
d4aa			; init the words to detect the under/overflow 
d4aa			 
d4aa			chk_stk_init: 
d4aa				; a vague random number to check so we dont get any "lucky" hits 
d4aa 3e 2d			ld a, 45 
d4ac 6f				ld l, a 
d4ad 00				nop 
d4ae 3e 17			ld a, 23 
d4b0 67				ld h, a 
d4b1			 
d4b1 22 cd e4			ld (chk_word), hl     ; the word we need to check against 
d4b4			 
d4b4			;	ld (chk_stund), hl	; stack points.... 
d4b4 22 00 ef			ld (chk_stovr), hl 
d4b7 22 91 ec			ld (chk_ret_und), hl 
d4ba 22 4f ec			ld (chk_ret_ovr), hl 
d4bd 22 4d eb			ld (chk_loop_ovr), hl 
d4c0 22 4b ea			ld (chk_data_ovr), hl 
d4c3 c9				ret 
d4c4				 
d4c4			check_stacks: 
d4c4				; check all stack words 
d4c4			 
d4c4 e5				push hl 
d4c5 d5				push de 
d4c6			 
d4c6			;	ld de,(chk_word) 
d4c6			;	ld hl, (chk_stund)	; stack points.... 
d4c6			;	if DEBUG_STK_FAULT 
d4c6			;		DMARK "FAa" 
d4c6			;		CALLMONITOR 
d4c6			;	endif 
d4c6			;	call cmp16 
d4c6			;	jp z, .chk_faulta 
d4c6			; 
d4c6			;	ld de, sfaultsu 
d4c6			;	jp .chk_fault 
d4c6			 
d4c6 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d4c9 ed 5b cd e4		ld de,(chk_word) 
d4cd				if DEBUG_STK_FAULT 
d4cd					DMARK "FAb" 
d4cd					CALLMONITOR 
d4cd				endif 
d4cd cd d9 8a			call cmp16 
d4d0 28 06			jr z, .chk_fault1 
d4d2 11 73 d5			ld de, sfaultso 
d4d5 c3 27 d5			jp .chk_fault 
d4d8			.chk_fault1:  
d4d8 2a 91 ec			ld hl, (chk_ret_und) 
d4db ed 5b cd e4		ld de,(chk_word) 
d4df				if DEBUG_STK_FAULT 
d4df					DMARK "FAU" 
d4df					CALLMONITOR 
d4df				endif 
d4df cd d9 8a			call cmp16 
d4e2 ca eb d4			jp z, .chk_fault2 
d4e5 11 83 d5			ld de, sfaultru 
d4e8 c3 27 d5			jp .chk_fault 
d4eb			.chk_fault2:  
d4eb 2a 4f ec			ld hl, (chk_ret_ovr) 
d4ee ed 5b cd e4		ld de,(chk_word) 
d4f2				if DEBUG_STK_FAULT 
d4f2					DMARK "FA1" 
d4f2					CALLMONITOR 
d4f2				endif 
d4f2 cd d9 8a			call cmp16 
d4f5 ca fe d4			jp z, .chk_fault3 
d4f8 11 91 d5			ld de, sfaultro 
d4fb c3 27 d5			jp .chk_fault 
d4fe			.chk_fault3:  
d4fe 2a 4d eb			ld hl, (chk_loop_ovr) 
d501 ed 5b cd e4		ld de,(chk_word) 
d505				if DEBUG_STK_FAULT 
d505					DMARK "FA2" 
d505					CALLMONITOR 
d505				endif 
d505 cd d9 8a			call cmp16 
d508 ca 11 d5			jp z, .chk_fault4 
d50b 11 ab d5			ld de, sfaultlo 
d50e c3 27 d5			jp .chk_fault 
d511			.chk_fault4:  
d511 2a 4b ea			ld hl, (chk_data_ovr) 
d514 ed 5b cd e4		ld de,(chk_word) 
d518				if DEBUG_STK_FAULT 
d518					DMARK "FA3" 
d518					CALLMONITOR 
d518				endif 
d518 cd d9 8a			call cmp16 
d51b ca 24 d5			jp z, .chk_fault5 
d51e 11 c5 d5			ld de, sfaultdo 
d521 c3 27 d5			jp .chk_fault 
d524			 
d524			 
d524			.chk_fault5:  
d524 d1				pop de 
d525 e1				pop hl 
d526			 
d526 c9				ret 
d527			 
d527 cd 8e 88		.chk_fault: 	call clear_display 
d52a 3e 14				ld a, display_row_2 
d52c cd a1 88				call str_at_display 
d52f 11 55 d5				   ld de, .stackfault 
d532 3e 00				ld a, display_row_1 
d534 cd a1 88				call str_at_display 
d537 11 c0 ee				    ld de, debug_mark 
d53a 3e 11				ld a, display_row_1+17 
d53c cd a1 88				call str_at_display 
d53f cd b1 88				call update_display 
d542			 
d542				; prompt before entering montior for investigating issue 
d542			 
d542 3e 3c			ld a, display_row_4 
d544 11 d5 95			ld de, endprog 
d547			 
d547 cd b1 88			call update_display		 
d54a			 
d54a cd 33 98			call next_page_prompt 
d54d			 
d54d d1				pop de 
d54e e1				pop hl 
d54f cd 29 96				call monitor 
d552 c3 23 95				jp warmstart 
d555					;jp 0 
d555					;halt 
d555			 
d555			 
d555			 
d555 .. 00		.stackfault: 	db "Stack fault:",0 
d562			 
d562 .. 00		sfaultsu: 	db	"Stack under flow",0 
d573 .. 00		sfaultso: 	db	"Stack over flow",0 
d583 .. 00		sfaultru:	db "RTS underflow",0 
d591 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d5ab .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d5c5 .. 00		sfaultdo:	db "DTS overflow", 0 
d5d2			 
d5d2			 
d5d2			fault_dsp_under: 
d5d2 11 e4 d5			ld de, .dsp_under 
d5d5 c3 94 d6			jp .show_fault 
d5d8			 
d5d8			fault_rsp_under: 
d5d8 11 f2 d5			ld de, .rsp_under 
d5db c3 94 d6			jp .show_fault 
d5de			fault_loop_under: 
d5de 11 00 d6			ld de, .loop_under 
d5e1 c3 94 d6			jp .show_fault 
d5e4			 
d5e4 .. 00		.dsp_under: db "DSP Underflow",0 
d5f2 .. 00		.rsp_under: db "RSP Underflow",0 
d600 .. 00		.loop_under: db "LOOP Underflow",0 
d60f			 
d60f			 
d60f d5			type_faultn: 	push de 
d610 e5					push hl 
d611 cd 8e 88				call clear_display 
d614 11 3b d6				   ld de, .typefaultn 
d617 3e 00				ld a, display_row_1 
d619 cd a1 88				call str_at_display 
d61c 11 c0 ee				    ld de, debug_mark 
d61f 3e 11				ld a, display_row_1+17 
d621 cd a1 88				call str_at_display 
d624 cd b1 88				call update_display 
d627			 
d627				; prompt before entering montior for investigating issue 
d627			 
d627 3e 3c			ld a, display_row_4 
d629 11 d5 95			ld de, endprog 
d62c			 
d62c cd b1 88			call update_display		 
d62f			 
d62f cd 33 98			call next_page_prompt 
d632			 
d632 e5					push hl 
d633 d5					push de 
d634 cd 29 96				call monitor 
d637 c3 23 95				jp warmstart 
d63a 76					halt 
d63b			 
d63b			 
d63b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d652			 
d652 d5			type_faults: 	push de 
d653 e5					push hl 
d654 cd 8e 88				call clear_display 
d657 11 7d d6				   ld de, .typefaults 
d65a 3e 00				ld a, display_row_1 
d65c cd a1 88				call str_at_display 
d65f 11 c0 ee				    ld de, debug_mark 
d662 3e 11				ld a, display_row_1+17 
d664 cd a1 88				call str_at_display 
d667 cd b1 88				call update_display 
d66a			 
d66a				; prompt before entering montior for investigating issue 
d66a			 
d66a 3e 3c			ld a, display_row_4 
d66c 11 d5 95			ld de, endprog 
d66f			 
d66f cd b1 88			call update_display		 
d672			 
d672 cd 33 98			call next_page_prompt 
d675			 
d675 e1					pop hl 
d676 d1					pop de 
d677 cd 29 96				call monitor 
d67a c3 23 95				jp warmstart 
d67d			 
d67d			 
d67d .. 00		.typefaults: db "STR Type Expected TOS!",0 
d694			 
d694			.show_fault: 	 
d694 d5					push de 
d695 cd 8e 88				call clear_display 
d698 d1					pop de 
d699 3e 00				ld a, display_row_1 
d69b cd a1 88				call str_at_display 
d69e 11 c0 ee				    ld de, debug_mark 
d6a1 3e 11				ld a, display_row_1+17 
d6a3 cd a1 88				call str_at_display 
d6a6 cd b1 88				call update_display 
d6a9			 
d6a9				; prompt before entering montior for investigating issue 
d6a9			 
d6a9 3e 3c			ld a, display_row_4 
d6ab 11 d5 95			ld de, endprog 
d6ae			 
d6ae cd b1 88			call update_display		 
d6b1			 
d6b1 cd 33 98			call next_page_prompt 
d6b4			 
d6b4 e1					pop hl 
d6b5 d1					pop de 
d6b6 cd 29 96				call monitor 
d6b9			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d6b9			; TODO Make optional fault restart to cli or warm boot? 
d6b9					;jp warmstart 
d6b9 c3 7b 95				jp cli 
d6bc 76					halt 
d6bd			 
d6bd			; handle the auto run of code from files in storage 
d6bd			 
d6bd			 
d6bd			if STORAGE_SE 
d6bd			 
d6bd			sprompt3: db "Loading from start-up file?:",0 
d6bd			sprompt4: db "(Y=Any key/N=No)",0 
d6bd			 
d6bd			 
d6bd			forth_autoload: 
d6bd			 
d6bd				; load block 0 of store 1 
d6bd				 
d6bd				ld a, $fe      ; bit 0 clear 
d6bd				ld (spi_device), a 
d6bd			 
d6bd				call storage_get_block_0 
d6bd			 
d6bd				ld a, (store_page+STORE_0_AUTOFILE) 
d6bd			 
d6bd				cp 0 
d6bd				ret z     ; auto start not enabled 
d6bd			 
d6bd				call clear_display 
d6bd			 
d6bd				; set bank 
d6bd			 
d6bd					ld a, (store_page+STORE_0_BANKRUN) 
d6bd					ld (spi_device), a 
d6bd			 
d6bd				; get file id to load from and get the file name to display 
d6bd			 
d6bd					ld a, (store_page+STORE_0_FILERUN) 
d6bd			 
d6bd					ld l, 0 
d6bd					ld h, a 
d6bd					ld de, store_page 
d6bd			 
d6bd					if DEBUG_FORTH_WORDS 
d6bd						DMARK "ASp" 
d6bd						CALLMONITOR 
d6bd					endif 
d6bd					call storage_read 
d6bd			 
d6bd					if DEBUG_FORTH_WORDS 
d6bd						DMARK "ASr" 
d6bd						CALLMONITOR 
d6bd					endif 
d6bd			 
d6bd					call ishlzero 
d6bd					ret z             ; file not found 
d6bd			 
d6bd					ld a, display_row_2 + 10 
d6bd					ld de, store_page+3 
d6bd					call str_at_display 
d6bd				 
d6bd			; 
d6bd			 
d6bd				ld a, display_row_1+5 
d6bd				ld de, sprompt3 
d6bd				call str_at_display 
d6bd				ld a, display_row_3+15 
d6bd				ld de, sprompt4 
d6bd				call str_at_display 
d6bd			 
d6bd				call update_display 
d6bd			 
d6bd				call cin_wait 
d6bd				cp 'n' 
d6bd				ret z 
d6bd				cp 'N' 
d6bd				ret z 
d6bd			 
d6bd				call delay1s 
d6bd			 
d6bd				ld a, (store_page+2) 
d6bd				ld (store_openmaxext), a    ; save count of ext 
d6bd				ld a, 1  
d6bd				ld (store_openext), a    ; save count of ext 
d6bd			 
d6bd			.autof:  
d6bd				ld l , a 
d6bd				 
d6bd				ld a, (store_page) 
d6bd				ld h, a	 
d6bd				ld de, store_page 
d6bd					if DEBUG_FORTH_WORDS 
d6bd						DMARK "ASl" 
d6bd						CALLMONITOR 
d6bd					endif 
d6bd					call storage_read 
d6bd				call ishlzero 
d6bd				ret z 
d6bd			;	jr z, .autoend 
d6bd			 
d6bd					if DEBUG_FORTH_WORDS 
d6bd						DMARK "ASc" 
d6bd						CALLMONITOR 
d6bd					endif 
d6bd				ld de, store_page+2 
d6bd				ld a, display_row_4 
d6bd				call str_at_display 
d6bd			 
d6bd				call update_display 
d6bd				call delay250ms 
d6bd			 
d6bd			 
d6bd			 
d6bd				ld hl, store_page+2 
d6bd				call forthparse 
d6bd				call forthexec 
d6bd				call forthexec_cleanup 
d6bd			 
d6bd				 
d6bd				ld a, (store_openext) 
d6bd				inc a 
d6bd				ld (store_openext), a    ; save count of ext 
d6bd			 
d6bd				jr .autof 
d6bd			;.autofdone: 
d6bd			; 
d6bd			;		if DEBUG_FORTH_WORDS 
d6bd			;			DMARK "ASx" 
d6bd			;			CALLMONITOR 
d6bd			;		endif 
d6bd			;;	call clear_display 
d6bd			;	ret 
d6bd			 
d6bd			 
d6bd			 
d6bd			endif 
d6bd			 
d6bd			 
d6bd			; eof 
# End of file forth_kernel.asm
d6bd			;include "nascombasic.asm" 
d6bd			 
d6bd			 
d6bd			; find out where the code ends if loaded into RAM (for SC114) 
d6bd			;endofcode:  
d6bd			;	nop 
d6bd			 
d6bd			 
d6bd			; eof 
d6bd			 
# End of file main.asm
d6bd			;include "firmware_lcd_4x20.asm" 
d6bd			;include "firmware_key_4x4.asm" 
d6bd			include "firmware_serial_display.asm" 
d6bd			 
d6bd			; Serial display interface for SC114 
d6bd			 
d6bd			 
d6bd			display_row_1: equ 0 
d6bd			display_row_2: equ display_row_1+display_cols 
d6bd			display_row_3: equ display_row_2 + display_cols 
d6bd			display_row_4: equ display_row_3 + display_cols 
d6bd			 
d6bd			kLCDWidth:  EQU display_cols             ;Width in characters 
d6bd			kLCD_Line1: EQU 0x00  
d6bd			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d6bd			; E1 
d6bd			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d6bd			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d6bd			 
d6bd			lcd_init: 
d6bd				; no init as handled by the SCM bios 
d6bd c9				ret 
d6be			 
d6be			 
d6be			; low level functions for direct screen writes 
d6be			 
d6be			; output char at pos? 
d6be			fLCD_Str: 
d6be			        ;out (SC114_SIO_1_OUT),a 
d6be c5				push bc 
d6bf 0e 02			ld c, $02 
d6c1 f7				rst $30 
d6c2 c1				pop bc 
d6c3 c9				ret 
d6c4			 
d6c4			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d6c4			fLCD_Pos: 
d6c4				; use ASCII escape to position 
d6c4			        ;out (SC114_SIO_1_OUT),a 
d6c4 c5				push bc 
d6c5 0e 02			ld c, $02 
d6c7 f7				rst $30 
d6c8 c1				pop bc 
d6c9			 
d6c9 c9				ret 
d6ca			 
d6ca			; output char at pos 
d6ca			fLCD_Data: 
d6ca			      ;  out (SC114_SIO_1_OUT),a 
d6ca c5				push bc 
d6cb 0e 02			ld c, $02 
d6cd f7				rst $30 
d6ce c1				pop bc 
d6cf			 
d6cf c9				ret 
d6d0			 
d6d0			; ascii cls  
d6d0			 
d6d0 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d6d4			 
d6d4			; write the frame buffer given in hl to hardware  
d6d4			write_display: 
d6d4			 
d6d4			API: equ 0 
d6d4			 
d6d4			if API 
d6d4				push bc 
d6d4				ld b, 4 
d6d4			 
d6d4			        ld (display_write_tmp), hl 	  
d6d4			 
d6d4				; clear and home cursor 
d6d4			 
d6d4				ld c, 6 
d6d4				ld de, .cls 
d6d4				rst $30 
d6d4			 
d6d4			 
d6d4			.writeln: 
d6d4			 
d6d4				ld de, (display_write_tmp) 
d6d4				ld c, 6 
d6d4				rst $30 
d6d4				ld c, 7 
d6d4				rst $30 
d6d4			 
d6d4				ld hl, (display_write_tmp) 
d6d4				ld de, display_cols 
d6d4				add hl,de 
d6d4				ld (display_write_tmp),hl 
d6d4			 
d6d4				djnz  .writeln 
d6d4			 
d6d4				pop bc 
d6d4			 
d6d4			 
d6d4				ret 
d6d4			endif 
d6d4 e5				push hl 
d6d5 c5				push bc 
d6d6 d5				push de 
d6d7			 
d6d7			;	ld c, 2 
d6d7			;	;ld de, .cls 
d6d7			;	ld a, 27 
d6d7			;	rst $30 
d6d7			;	ld c, 2 
d6d7			;	;ld de, .cls 
d6d7			;	ld a, '[' 
d6d7			;	rst $30 
d6d7			; 
d6d7			;	ld c, 2 
d6d7			;	;ld de, .cls 
d6d7			;	ld a, 'H' 
d6d7			;	rst $30 
d6d7			; 
d6d7			 
d6d7 0e 02			ld c, 2 
d6d9				;ld de, .cls 
d6d9 3e 1b			ld a, 27 
d6db f7				rst $30 
d6dc			 
d6dc			 
d6dc 0e 02			ld c, 2 
d6de				;ld de, .cls 
d6de 3e 5b			ld a, '[' 
d6e0 f7				rst $30 
d6e1 0e 02			ld c, 2 
d6e3				;ld de, .cls 
d6e3 3e 32			ld a, '2' 
d6e5 f7				rst $30 
d6e6 0e 02			ld c, 2 
d6e8				;ld de, .cls 
d6e8 3e 4a			ld a, 'J' 
d6ea f7				rst $30 
d6eb d1				pop de 
d6ec c1				pop bc 
d6ed e1				pop hl 
d6ee			 
d6ee			 
d6ee 22 5e ed		        ld (display_write_tmp), hl 	  
d6f1 3e 00			ld a, kLCD_Line1 
d6f3			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d6f3 06 14			ld b, display_cols 
d6f5 ed 5b 5e ed		ld de, (display_write_tmp) 
d6f9 cd 57 d7			call write_len_string 
d6fc				 
d6fc			 
d6fc e5			push hl 
d6fd d5			push de 
d6fe c5			push bc 
d6ff 0e 07			ld c, 7 
d701 f7				rst $30 
d702 c1			pop bc 
d703 d1			pop de 
d704 e1			pop hl 
d705			 
d705				 
d705 2a 5e ed			ld hl, (display_write_tmp) 
d708 11 14 00			ld de, display_cols 
d70b 19				add hl,de 
d70c 22 5e ed			ld (display_write_tmp),hl 
d70f			 
d70f				 
d70f 3e 14			ld a, kLCD_Line2 
d711			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d711 06 14			ld b, display_cols 
d713 ed 5b 5e ed		ld de, (display_write_tmp) 
d717 cd 57 d7			call write_len_string 
d71a				 
d71a 2a 5e ed			ld hl, (display_write_tmp) 
d71d 11 14 00			ld de, display_cols 
d720 19				add hl,de 
d721 22 5e ed			ld (display_write_tmp),hl 
d724			 
d724 e5			push hl 
d725 d5			push de 
d726 c5			push bc 
d727 0e 07			ld c, 7 
d729 f7				rst $30 
d72a c1			pop bc 
d72b d1			pop de 
d72c e1			pop hl 
d72d			 
d72d				 
d72d 3e 28			ld a, kLCD_Line3 
d72f			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d72f 06 14			ld b, display_cols 
d731 ed 5b 5e ed		ld de, (display_write_tmp) 
d735 cd 57 d7			call write_len_string 
d738				 
d738 2a 5e ed			ld hl, (display_write_tmp) 
d73b 11 14 00			ld de, display_cols 
d73e 19				add hl,de 
d73f 22 5e ed			ld (display_write_tmp),hl 
d742			 
d742 e5			push hl 
d743 d5			push de 
d744 c5			push bc 
d745 0e 07			ld c, 7 
d747 f7				rst $30 
d748 c1			pop bc 
d749 d1			pop de 
d74a e1			pop hl 
d74b			 
d74b				 
d74b 3e 3c			ld a, kLCD_Line4 
d74d			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d74d 06 14			ld b, display_cols 
d74f ed 5b 5e ed		ld de, (display_write_tmp) 
d753 cd 57 d7			call write_len_string 
d756 c9					ret 
d757			 
d757			 
d757				; write out a fixed length string given in b from de 
d757			 
d757 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d758 cd ca d6		            CALL fLCD_Data      ;Write character to display 
d75b 13				inc de 
d75c 10 f9			djnz write_len_string 
d75e c9				ret 
d75f			 
d75f			 
d75f			; eof 
# End of file firmware_serial_display.asm
d75f			include "firmware_key_serial.asm" 
d75f			; Serial keyboard interface for SC114 
d75f			 
d75f			key_init: 
d75f				; no init as handled by the SCM bios 
d75f c9				ret 
d760			 
d760			 
d760			cin_wait: 
d760			;	ld a, 0 
d760			;	ret 
d760			 
d760				;in a,(SC114_SIO_1_IN) 
d760			        ; Use SCM API to get from whatever console device we are using 
d760 c5				push bc 
d761 0e 01			ld c, $01 
d763 f7				rst $30 
d764 c1				pop bc 
d765 c9				ret 
d766			 
d766			cin: 
d766			 
d766			 
d766 c5				push bc 
d767			 
d767				; any key waiting to process? 
d767 0e 03			ld c, $03 
d769 f7				rst $30 
d76a 28 05			jr z, .cin_skip 
d76c			 
d76c				; yep, get it 
d76c			 
d76c 0e 01			ld c, $01 
d76e f7				rst $30 
d76f c1				pop bc 
d770 c9				ret 
d771			.cin_skip: 
d771 3e 00			ld a, 0 
d773 c1				pop bc 
d774 c9				ret 
d775			 
d775			 
d775			 
d775			 
# End of file firmware_key_serial.asm
d775			 
d775			baseram:  
d775			endofcode: 
d775 00				nop 
d776			 
d776			heap_start: equ baseram+15  ; Starting address of heap 
d776			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d776			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d776			; 
d776			 
# End of file os_mini_sc114.asm
d776
